00:22:44 <ninestrokeroll> \leave
00:33:36 <wolfgangbeck> how do i write a TVar inside a record?
00:33:59 <wolfgangbeck> updating a  field is myrecord { member = x }
00:34:24 <wolfgangbeck> how do i do a writeTVar on 'member'?
00:34:45 <ski_> writeTVar (member myrecord) foo
00:34:48 <kolmodin> you have to get the value out of your record first
00:35:01 <kolmodin> 'member myrecord' will do that
00:35:20 <kolmodin> then use writeTVar, as ski_ shows
00:35:36 <ski_> (assuming the 'member' field contains the 'TVar' .. as opposed to just the 'myrecord' lying in a 'TVar')
00:35:45 <wolfgangbeck> aah, it works! thank you!
00:36:10 <kolmodin> great, np
00:36:17 <ski_> yw
01:19:33 <dons> morning all
01:19:33 <lambdabot> dons: You have 3 new messages. '/msg lambdabot @messages' to read them.
01:19:34 <dons> ?users
01:19:34 <lambdabot> Maximum users seen in #haskell: 311, currently: 280 (90.0%), active: 22 (7.9%)
01:30:11 <robreim> ?localtime dons
01:30:13 <lambdabot> Local time for dons is Tue Jan 16 20:27:59 2007
01:30:24 <robreim> good evening(?) dons
01:30:38 <robreim> How'd hs-plugins go?
02:02:19 <Masklinn> good morning #haskell
02:25:34 <kzm> I can't commit to cvs.haskell.org (without an account etc etc), can I?
02:29:30 <kolmodin> kzm: no, sorry
02:29:43 <kolmodin> kzm: what would you like to commit?
02:30:05 <kzm> Tiny patches to haskell-mode to make it work with XEmacs.
02:30:25 * kzm notes another point in darcs's favor.
02:30:31 <kolmodin> yeah
02:30:39 <kolmodin> who is maintaining the haskell-mode?
02:30:50 <kzm> Stefan Monnier.
02:30:59 <kzm> So I mailed him some diffs.
02:31:06 <kzm> Sort of manual darcs :-)
02:31:23 <kzm> Back in Göteborg?
02:31:27 <kolmodin> yep
02:31:41 <kolmodin> if he doesn't like manual darcs he should move to the real stuff :)
02:31:52 * kzm nods.
02:33:49 <kolmodin> kind of ill, though. both me and bringert caught something on the way back
02:35:24 <kzm> I sat on the bus to Stansted for 4h, and it must have had a leak from its toilet or something.
02:35:51 <kzm> Thank god I bought a book (by Bret E. Ellis) to lighten my mood.
02:36:23 <kzm> :-)
02:41:15 <kolmodin> oh :)
02:41:22 <kolmodin> I slept most of the way to heathrow
02:41:37 <kolmodin> so about a total of 4h that night/morning
02:41:59 <kolmodin> I usually get ill if I don't sleep enough for a week
02:45:15 <kosmikus> kolmodin: are you still planning to go to fosdem?
02:49:51 <Syzygy-> Operad and Monad is obviously the same thing - or so it seems on the latest lecture I heard.
02:49:58 <kolmodin> kosmikus: I don't know. It would be fun, but it takes time and cost money and reduces income..
03:37:11 <mq_mattr> quiet night
03:40:46 <earthy> night?
03:49:15 <gds> @localtime mq_mattr
03:49:17 <lambdabot> Local time for mq_mattr is 2007-01-16 22:47:02 +1100
03:49:24 <gds> Yup - night ;)
03:49:30 <mq_mattr> damn straight
03:49:39 <gds> @localtime
03:49:42 <lambdabot> Local time for gds is Tue Jan 16 11:47:25 2007
03:49:48 <gds> :)
03:50:19 <mq_mattr> why is lambdabot 1 hour ahead of me?
03:50:29 <mq_mattr> maybe he is not on daylight savings time
03:51:10 <mq_mattr> ah! no, that's gds :)
03:51:14 <mq_mattr> where is that?
03:51:25 <gds> london :)
03:51:36 <mq_mattr> ah, 11am!!!
03:51:40 <gds> :)
03:51:44 <mq_mattr> boy, I must be half asleep
03:52:05 <mq_mattr> @localtime lambdabot
03:52:05 <lambdabot> I live on the internet, do you expect me to have a local time?
03:52:11 <mq_mattr> :)
03:53:17 <mq_mattr> nodnol
03:53:42 <earthy> lambdabot: yes, I do. swatch internet beats. :)
03:54:35 <mq_mattr> earth: damn, those things were misconceived
03:54:40 * earthy nods
03:55:36 <paolino> @instances Eq
03:55:37 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
03:56:01 <gds> time: the last frontier of the metric system... ;)
03:56:29 <earthy> actually, time is metric
03:56:51 * wolfgangbeck wants the revolutionary calendar
03:57:08 <paolino> Good morning,
03:57:09 <paolino> I'm trying to istantiate (Eq a) => Eq (DiffArray Int a)  but I get
03:57:09 <paolino>    Illegal instance declaration for `Eq (IOToDiffArray GHC.IOBase.IOArray Int s)'
03:57:09 <paolino>         (The instance type must be of form (T a b c)
03:57:09 <paolino>          where T is not a synonym, and a,b,c are distinct type variables)
03:57:10 <earthy> date reckoning isn't. :)
03:58:14 <mq_mattr> paolino: how is diffArray coded?
03:58:18 <matthew_-> paolino: -fglasgow-exts?
03:58:30 <paolino> it meeans DiffArray is a synonym ?
03:58:38 <paolino> @src DiffArray
03:58:39 <lambdabot> Source not found. Where did you learn to type?
03:59:10 <mq_mattr> it may be, but then it would probably inherit Eq, try showing it
03:59:16 <matthew_-> paolino: I saw that same error yesterday with some code and the glasgow-exts made it go away.
03:59:32 <wolfgangbeck> today is Nivose, sixtidi 3. Decade, in the year 215 of the republic
03:59:59 <paolino> it did. Thanks
04:01:05 <jethr0> @list
04:01:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
04:01:37 <matthew_-> np. I'm not totally sure what feature of the glasgow exts makes it work, but it's quite useful, whatever it is! ;)
04:01:40 <jethr0> @poll-show cheeky-off
04:01:41 <lambdabot> ["MakeItAbuseCowboyNeal","AddFlag","No","Yes"]
04:01:51 <jethr0> @poll-result cheeky-off
04:01:51 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=0, Yes=8
04:02:42 <earthy> wolfgangbeck: even the republican calendar has 12 months
04:02:49 <earthy> (of 30 days each)
04:03:19 <earthy> but see also http://www.tondering.dk/claus/calendar.html
04:03:21 <lambdabot> Title: The Calendar FAQ
04:05:18 <paolino> if there should be something properly academic in haskell, that's -fglasgow-exts
04:07:09 * SamB laughs upon reading that HNOP has been split into two packages
04:09:33 <matthew_-> paolino: oh I fully expect that there's a paper for each of the features enabled for glasgow-exts
04:09:47 <mq_mattr> SamB: that make me laugh too
04:11:55 <tuukkah> how do i draw diagrams of classes and instances?
04:12:43 <mq_mattr> tuukkah: with your favourite drawing program - or a pen and paper
04:13:23 <tuukkah> fair enough :-)
04:13:24 <flux-> I've used TCM, Toolkit for Conceptual Modeling
04:13:45 <flux-> I've also used Dia, but it annoys me. maybe it's better these days.
04:13:51 <flux-> TCM isn't quite as pretty, though
04:14:13 <SamB> the Haskell report has a graph of the Prelude classes
04:14:18 <flux-> assuming this was what you were asking for, not about some way of generating the graphs with haskell :-)
04:14:31 <wolfgangbeck> graphviz
04:14:31 <flux-> then there's graphviz for auto-generating graphs
04:14:33 <matthew_-> tuukkah: I tend to use graphviz/dot
04:14:56 <mq_mattr> omnigraffle
04:14:57 <matthew_-> and then with the ladot stuff you can put LaTeX in the labels which is very useful
04:15:00 <tuukkah> well, it would of course be cool to automatically extract the graph from the source files
04:15:13 <SamB> ooh, ladot?
04:15:19 <flux-> you could probably write a neat dsl for generating the graphviz files with a more domain-appropriate syntax
04:15:20 <SamB> tuukkah: maybe
04:15:22 <mq_mattr> that's a haddock task surely
04:15:23 <matthew_-> yeah. it's somewhere around
04:15:24 <SamB> or maybe it would just be ugly
04:15:47 <matthew_-> SamB: it's a hack which outputs ps and then you put the latex in via pstricks
04:15:59 <SamB> flux-: oh, you mean like class and instance declarations?
04:16:06 <matthew_-> it works reasonably well, though you have to go round the houses to get it back to PDF
04:16:25 <SamB> 'round the house?
04:16:48 <SamB> couldn't you just use ps2pdf or something?
04:17:00 <earthy> yeah, but that's the roundabout way
04:17:15 <flux-> samb, yes
04:17:15 <SamB> what would be less roundabout?
04:17:41 <matthew_-> SamB, yes, but if you want to include the diagram as a fig within a latexpdf doc you have to go ps2pdf and then include the graphicxs
04:17:46 <SamB> outputting PDF with holes in it and munging pdflatex output into that somehow?
04:18:03 <matthew_-> it would be nicer if ladot didn't restrict to PS output
04:18:19 <matthew_-> but given how it works with pstricks there's not much you can do to avoid it. that's all.
04:18:20 <SamB> Somehow that doesn't sound like much of an improvement...
04:18:43 <SamB> oh, right, you said it used pstricks...
04:19:10 <SamB> anyway, the only way I can think of to make PDF requires post-processing...
04:19:19 <matthew_-> yep.
04:19:34 <SamB> I mean, even if you skip postscript entirely...
04:20:21 <tuukkah> i would have some use for a free omnigraffle
04:20:47 <matthew_-> SamB: well I guess you really want some package that takes a .dot file and inserts a suitable output of dot/graphviz/ladot automatically...
04:21:15 <SamB> mmm.
04:24:38 <paolino> @pl solve0 how init = run0 how init solve
04:24:38 <lambdabot> solve0 = flip flip solve . run0
04:37:12 <paolino> I have this func
04:37:13 <paolino> solve = do start <- get
04:37:13 <paolino>            next <- evolve >> get
04:37:13 <paolino>            if next == start then return start else solve
04:37:36 <paolino> but the test next==start is not really effective
04:37:56 <paolino> sometimes the solution oscillate
04:38:50 <mq_mattr> not sure what you mean
04:39:09 <paolino> I'd like to get an infinite stream of evolve and judge from outside the monad when  to cut it for reached goal
04:40:06 <paolino> but running the monad with a recursion like that never stops
04:40:27 <paolino> so I cannot judge
04:40:47 <mq_mattr> hmmm, tough to debug from here
04:40:51 <mq_mattr> nothing jumping out at me
04:42:06 <paolino> say
04:42:07 <paolino> evolves = do start <- get
04:42:07 <paolino>                     rest <- evolves
04:42:07 <paolino>                     return (start:rest)
04:42:26 <apfelmus> paolino: are you sure that you can't just use pure functions and (iterate evolves start)?
04:42:36 <paolino> this produces the infinit stream of evolve
04:43:23 <paolino> apfelmus , the monadic type is
04:43:24 <paolino> type Net s g r e = StateT (Nodes s) ( ReaderT r (State g)) e
04:44:01 <paolino> where g is a RandomGen
04:44:37 <paolino> I would have to throw away all the code for that test
04:45:54 <apfelmus> mhh, to many variables... why don't you zip an infinite stream of random numbers into the sequence? and what's the object you evolve, anyway?
04:46:54 <apfelmus> paolino: what code do you need to throw away?
04:46:57 <paolino> I feel I have to wrap it in the ContT to stop it, but I'm not sure how it works
04:46:58 <paolino> btw
04:46:58 <paolino> evolve :: (Metrics s,RandomGen g, Friends r) => Net s g r ()
04:47:59 <mq_mattr> geez, that's complicated code
04:48:14 <apfelmus> paolino: most likely, evolve does not return (), otherwise your program above has a superflous variable 'rest'
04:49:12 <paolino> mmh, I get my evolution from an execStateT
04:49:27 <paolino> but yes
04:49:36 <paolino> Net s g r (Nodes s)
04:49:43 <paolino> this is more appropriate
04:50:04 <paolino> so I end evolve func with a "get"
04:50:29 <apfelmus> sure it is. and this way, you can almost throw away the StateT (Nodes s) altogether. why to keep the state hidden when you pass it out anyway?
04:51:46 <paolino> not to pass it to the inner functionalities
04:52:53 <paolino> in the beginning I was not having any transformer
04:53:26 <paolino> and a lot  of args everywhere
04:53:29 <Pastorn> @seen xinming
04:53:30 <lambdabot> xinming is in #haskell and #perl6. I don't know when xinming last spoke.
04:53:54 <paolino> isn't this the way to go with monads ?
04:54:42 <paolino> now only most meaningful args are around
04:56:41 <apfelmus> paolino: mmh. introducing a monad makes parameters go away but does not necessarily help your program. say, can you paste some code and explain what it does? i'm having a short lunch now and could ponder it during that.
04:58:59 <paolino> doing ..
04:59:00 <stefanpa_> Hi. Something occurred to me the other day and I was wondering if it's used by the haskell runtime. Are previous results of functions cached?
04:59:27 <mq_mattr> well, that's complicated :)
04:59:38 <mq_mattr> you mean beyond normal laziness?
04:59:44 <stefanpa_> yep
05:00:13 <mq_mattr> hmm, each runtime will be different, but I don't know the details of any one
05:00:44 <paolino> apfelmus: catanova.org/~paolino/clusterer/net.hs
05:01:08 <stefanpa_> I'm sure it's been thought about I was just wondering if there was any documentation discussion about it anywhere. I cannot seem to find any
05:01:23 <paolino> don't have documentation now.
05:01:30 <mq_mattr> i can't imagine it would be that useful given laziness takes care of most instances where it pays dividends
05:03:08 <apfelmus> paolino: mh, the url seems down/deficient. cornerning docs, i just want to know the colloquial problem formulation
05:03:33 <stefanpa_> I don't know if lziness does help
05:03:50 <xinming> Pastorn: hi
05:03:54 <pejo> stefanpa_, Cale had a paper reference about writing memoization functions the other day. The paper highlights the difficulty in designing one general mechanism for it.
05:04:03 <xinming> Pastorn: join #i-like-hof please...
05:04:20 <paolino> mmh *catenova.org
05:04:30 <stefanpa_> pejo: you don't have a link/reference for it do you?
05:04:56 <pejo> stefanpa, http://www.haskell.org/~simonmar/papers/weak.pdf
05:05:14 <stefanpa_> thanks
05:05:54 <apfelmus> paolino: ok, found it.
05:06:43 <bakert> Is there a replace function like this: replace "hello" "he" => "llo" ... something in List?
05:07:12 <bakert> I found subRegex but it seems like overkill
05:07:17 <bakert> for removing commas from a string
05:07:24 <Pastorn> > "hello" \\ "he"
05:07:25 <lambdabot>  "llo"
05:07:26 <paolino> apfelmus: the algorithm evolve a DiffArray of {value,friends}  where friends are indexes of the array.The evolution is only concerning friends field
05:07:39 <bakert> > "100,000" \\ ","
05:07:40 <lambdabot>  "100000"
05:07:45 <bakert> > "100,000,000" \\ ","
05:07:46 <lambdabot>  "100000,000"
05:07:51 <jethr0> > "hello" \\ "l"
05:07:52 <lambdabot>  "helo"
05:08:07 <bakert> anything that does all occurrences not just the first?
05:08:08 <Pastorn> bakert: http://www.cs.chalmers.se/Cs/Grundutb/Kurser/d1pt/d1pta/ListDoc/
05:08:11 <lambdabot> Title: Haskell's Standard List Functions
05:08:27 <bakert> filter?
05:08:30 <bakert> i suppose i could do
05:08:34 <Pastorn> check that page... has most of the stuff you might come up with
05:08:43 <apfelmus> paolino: yes, but what are "friends" for?? i mean what kind of application do you code? :)
05:08:54 <bakert> > filter (\x -> x == ',') "100,000,000"
05:08:55 <lambdabot>  ",,"
05:09:00 <bakert> > filter (\x -> x /= ',') "100,000,000"
05:09:01 <lambdabot>  "100000000"
05:09:06 <edwinb> > "hello" \\ "eh"
05:09:07 <lambdabot>  "llo"
05:09:14 <edwinb> I guess that's not quite what you want...
05:09:18 <bakert> nah
05:09:24 <bakert> but it is quite funky
05:09:28 <stefanpa_> So the problem is the storage of the cached results and implementing that in a functional manner?
05:09:33 <edwinb> but if it's just commas it's even easier
05:09:45 <bakert> i guess the filter is what i want and noone made it a library function because it is too simple, or something.
05:10:16 <Pastorn> then write a primitive recursive function?
05:13:05 <paolino> apfelmus: friends should be choosen to minimize the mean deviation of the value they    point to from the value associated to them
05:13:09 <bakert> i'm an idiot.  the filter only works for single chars1
05:13:10 <bakert> !
05:15:05 <paolino> apfelmus: I do this in different ways. Two of them are implemented at the end of the file
05:29:18 <dons> ?uptime
05:29:18 <lambdabot> uptime: 1d 2h 31m 3s, longest uptime: 2d 3h 42m 19s
05:29:21 <dons> ?users
05:29:21 <lambdabot> Maximum users seen in #haskell: 311, currently: 292 (93.9%), active: 32 (11.0%)
05:29:34 <apfelmus> paolino: ok. so you have some people (Node ?) who chose randomly some friends among their friend's friends and try to get the best ones?
05:31:35 <apfelmus> paolino: or do you code a solver for some numeric equation and "friends" is just a funny name for "neighboring node"?
05:34:23 <paolino> mmh, the first one sounds right
05:37:16 <bakert> ?paste
05:37:16 <paolino> the algorithm is actually "wrong" ,it misses the 2 way friendship, but for now  I want to solve the convergence side
05:37:17 <lambdabot> http://paste.lisp.org/new/haskell
05:37:51 <lisppaste2> bakert pasted "My replace function" at http://paste.lisp.org/display/35464
05:37:58 <apfelmus> ok. so "Node" means "Person" then. how is this "friend choosing" business done exactly? you parametrize on the exact algorithm (encoded in class Friends), but i don't quite see what they do
05:38:11 <apfelmus> and what's the role of (Metrics s)?
05:38:15 <bakert> OK, so I wrote a replace function.  If anyone gives it a once over and spots a flaw or something newbie-ish please let me know!
05:38:49 <paolino> Metrics give (-|) operator
05:39:22 <paolino> to measure distances between friends
05:40:48 <apfelmus> paolino: what might a "distance" be? difference in height? in weight? difference of the hues of the favorite color?
05:42:24 <paolino> KPath is a constant length of random paths, the sample population is taken on them
05:42:26 <paolino> KRPath "opens"  sections of the friends of friends levels  [n from 1 level, n from 2 level, n from 3 level....]
05:42:36 <paolino> Yes
05:47:11 <apfelmus> ah, so you mean (1 likes 2 for 70%), (2 likes 3 for 80 %), so you much does (1 like 3)?
05:47:14 <bakert> ?hoogle [a] -> [a] -> [a] -> [a]
05:47:15 <lambdabot> Prelude.zipWith3 :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
05:47:15 <lambdabot> List.zipWith4 :: (a -> b -> c -> d -> e) -> [a] -> [b] -> [c] -> [d] -> [e]
05:48:51 <bakert> I'm getting cocky now http://bluebones.net/2007/01/replace-in-haskell/
05:48:53 <lambdabot> Title: bluebones.net » Replace in Haskell
05:49:41 <apfelmus> paolino: with a direct approach (a likes b for x percent), you might get inconsistencies like  "the friends of my friends are not my friends", so you chose to attribute a value to every person and compare only differences? so that adding up "friendship" along any closed path is 0?
05:52:30 <lisppaste2> tuukkah pasted "Overlapping arising from superclasses" at http://paste.lisp.org/display/35465
05:53:14 <twanvl> bakert: You should switch the order of the arguments, so it is replace "h" "x" "hello", this works better with composition.
05:53:46 <bakert> ok!
05:54:16 <jethr0> bakert: i tried annotating, but it's unformatted now :(
05:54:28 <jethr0> @paste
05:54:28 <lambdabot> http://paste.lisp.org/new/haskell
05:54:44 <bakert> oop.  sorry.  my comment thing isn't very amazing at formatting.  the email that came through to me was perfect though!
05:54:45 <lisppaste2> jethr0 pasted "replace" at http://paste.lisp.org/display/35466
05:54:59 <jethr0> hehe
05:55:33 <jethr0> isPrefixOf is also somewhere in prelude
05:55:35 <jethr0> @hoogle isPrefix
05:55:36 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
05:58:20 <apfelmus> paolino: still there?
05:59:14 <bakert> jethr0, thanks.  i reformatted your comment
05:59:22 <jethr0> thx
06:01:17 <twanvl> jethr0: You forgot the recursive call to subst in the 'then' branch
06:02:03 <jethr0> twanvl: the function i pasted was supposed to only replace the first occurrence
06:02:36 <bakert> that is a horrendously clever use of zipWith.
06:02:51 <bakert> i think my mother would call it "a bit too clever by half"
06:03:07 <jethr0> i don't find it overly obscure
06:03:12 <bakert> one day i will think of things like that
06:03:15 <twanvl> Except it doesn't work:
06:03:17 <jethr0> but as i said isPrefixOf is in prelude
06:03:34 <twanvl> > let isPrefixOf as bs = and $ zipWith (==) as bs in "xyz" `isPrefixOf` "x"
06:03:35 <lambdabot>  True
06:03:43 <jethr0> also: "subStrOf a b = any (isPrefixOf a) $ tails b
06:03:52 <jethr0> ups
06:04:12 * jethr0 hides under the carpet
06:05:01 <jethr0> > "xyz" `isPrefixOf` "x"
06:05:02 <lambdabot>  False
06:05:06 <bakert> i wasn't trying to say it was obscure.  it's just the kind of "functional thinking" that i don't have at the moment.
06:05:12 <jethr0> k, so the prelude function is "more" correct
06:05:23 <jethr0> bakert: and it doesn't work :(
06:05:25 <bakert> i was being impressed!  although i'll stick to library routines where possible!
06:18:47 <jethr0> i find it a bit unintuitive that pattern matching against "[]" works for any type, whereas comparing to "[]" only works for (Eq a =>).
06:18:55 <jethr0> not very transparent to the programmer
06:23:31 <chessguy> well, an empty basket of apples looks the same as an empty basket of oranges, but you may not be able to directly compare an apple to an orange
06:24:11 <jethr0> i understand the mechanism, but it can be confusing. but maybe i'll just have to get used to it
06:25:01 <liyang> the Eq a => comes from the use of == , so...
06:25:09 <jethr0> also, your example is badly chosen because you might not even be able to compare an empty basket of apples to an empty basket of apples
06:25:29 <chessguy> sure you can
06:25:39 <chessguy> as long as we're talking about the same kind of basket
06:25:46 <jethr0> not if apples isn't an instance of (Eq)
06:26:24 <chessguy> it doesn't matter, that's the whole point
06:26:32 <chessguy> like you said, an empty list works for any type
06:26:47 <chessguy> oh wait, maybe i misunderstood
06:27:11 <chessguy> i think i did. my apologies
06:27:16 <jethr0> np
06:28:14 <chessguy> i do see your point then, it's a little unusual. bot not too difficult to remember, because of liyang's point
06:28:33 <jethr0> yes
06:29:39 * allbery_b notes that "pattern match" implies to him matching on a "shape", not a value, so it makes reasonable sense to him
06:30:06 <allbery_b> whereas with "==" I'm obviously working with values
06:30:44 <jethr0> ok, so i am overly sensible to the dichotomy of "if a == [] ..." and "case a of [] -> ..."
06:31:42 <apfelmus> jethr0: well, the point is that "==" works for non-empty lists as well.
06:32:11 <jethr0> yes
06:32:15 <allbery_b> I admit that I'm not fond of the "case" keyword because I'm somewhat used to case being a sort of structured if (switch construct) in other languages
06:32:40 <allbery_b> otoh note that in /bin/sh and derivatives case /if *does* have this particular difference
06:33:07 <apfelmus> "==" is able to do more than a pattern match, so it needs more information (Eq a =>).
06:33:11 <allbery_b> (well, sorta.  "if []" has it; "if" y itself is too general)
06:33:32 <chessguy> @type if []
06:33:37 <lambdabot> parse error (possibly incorrect indentation)
06:33:45 <chessguy> @type if
06:33:46 <lambdabot> parse error (possibly incorrect indentation)
06:33:52 <allbery_b> don't think LB can help you with sh syntax :>
06:33:54 <jethr0> if is (regrettably) not a function
06:34:19 <chessguy> hmm, surprising
06:34:28 <apfelmus> jethr0: but you have a point, because every data type has a natural Eq instance (that's why there is a (deriving Eq))
06:34:28 <allbery_b> @src if'
06:34:29 <lambdabot> Source not found. My mind is going. I can feel it.
06:34:41 <allbery_b> oh well
06:34:52 <allbery_b> if' is the "function form" of if
06:35:01 <chessguy> @type if'
06:35:03 <lambdabot> Not in scope: `if''
06:35:10 <chessguy> @hoogle if'
06:35:11 <lambdabot> No matches found
06:35:13 <e_e_coli> Hello. Does ghci not do tail-call-elimination?
06:35:17 <jethr0> > let if' p c a = if p then c else a in liftM3 if' (Just True) (Just 4) (Just 5)
06:35:21 <lambdabot>  Just 4
06:35:38 <jethr0> e_e_coli: yes it does
06:35:41 <e_e_coli> ok
06:35:45 <e_e_coli> ?paste
06:35:45 <lambdabot> http://paste.lisp.org/new/haskell
06:35:52 <jethr0> but it has a limited stack so you can still outgrow it
06:36:12 <e_e_coli> but if tail recursion is eliminated, then there's no stack
06:36:13 <e_e_coli> I thought
06:36:26 <jethr0> hmm, true. are you sure your function is tail recursive?
06:36:39 <e_e_coli> that's why I'm pasting :)
06:36:51 <allbery_b> tail recursion doesn't help you much if laziness is pushing thunks on the stack
06:36:58 <e_e_coli> well, I've tried $!
06:37:26 <chessguy> wow, they added a captcha to lisppasate
06:37:29 <chessguy> lisppaste
06:37:57 <bakert> they did.  it's a £"%$£"U*(%"£ kind of a one too.
06:38:13 <bakert> a bit annoying but i guess someone must have been using it for automated spam.
06:38:32 <bakert> Is there an equivalent of printf in haskell?
06:38:44 <allbery_b> @hoogle printf
06:38:44 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
06:38:44 <lambdabot> Text.Printf :: module
06:38:44 <lambdabot> Text.Printf.hPrintf :: HPrintfType r => Handle -> String -> r
06:38:45 <daniel_larsson> Text.Printf
06:38:47 * kowey keeps failing captchas
06:38:51 <jethr0> and the captcha is WAY long
06:38:53 <bakert> ha!
06:39:11 <jethr0> kowey: have you given any thought to the idea that you might not be human?
06:39:13 <bakert> i looked at all the submodules of Text but didn't think of there being anything in text itself.  cripes i'm thick.
06:39:25 <kowey> jethr0: it's quite  distressing
06:39:27 <chessguy> these captchas don't look too bad
06:39:39 <edwinb> I almost always fail captchas too
06:39:39 <lisppaste2> e_e_coli pasted "Where's the stack overflow?" at http://paste.lisp.org/display/35467
06:39:41 <daniel_larsson> Oh, it's a separate module, Text.Printf
06:39:43 <jethr0> they aren't and i'm sure they're quite easily breakable
06:39:47 <edwinb> I need to upgrade myself
06:39:55 <jethr0> another case of annoying to users, a nuissance to spammers
06:40:00 <e_e_coli> I failed the captcha once
06:40:08 <e_e_coli> that's annoying
06:40:14 <bakert> daniel_larsson, oh thanks.  i must be blind.
06:40:31 <e_e_coli> this is, by the way, a problem from the euler challenge
06:41:03 <chessguy> are none of those returning, or only the last one not returning?
06:41:08 <e_e_coli> only the last one
06:41:11 <apfelmus> e_e_coli: flen' (f n) ((1+) $! k)
06:41:23 <e_e_coli> seriously?
06:41:29 <jethr0> e_e_coli: have you considered the possibility that it just doesn't converge? or does this function always converge?
06:41:48 <e_e_coli> shouldn't matter
06:41:54 <e_e_coli> should never run out of memory
06:41:54 <allbery_b> that spec looks familiar, don't think convergence is proven
06:42:00 <jethr0> with the new bang patterns you can also write "flen' n !k"
06:42:02 <e_e_coli> let's pretend it doesn't converge
06:42:12 <e_e_coli> it still shouldn't run out of memory
06:42:17 <jethr0> hmm
06:42:31 <jethr0> if you are createing lazy thunks at all it will
06:42:40 <e_e_coli> so put $! on every application?
06:42:51 <jethr0> e_e_coli: try using bang patterns
06:42:52 <allbery_b> (but he's right, failure to converge shouldn't run out of memory, just should run forever --- assuming strict evaluation)
06:42:58 <apfelmus> e_e_coli: ah, the previous was nonsense. i think you'd have to do flen' (f n) $! k+1
06:43:13 <e_e_coli> apfelmus
06:43:15 <e_e_coli> I don't get that
06:43:24 <e_e_coli> doesn't f $1 x mean apply f to x strictly?
06:43:29 <e_e_coli> I mean $!
06:43:42 <apfelmus> e_e_coli: yes. isn't this what you want?
06:43:55 <e_e_coli> How do I apply an Int to an Int ?
06:44:07 <jethr0> it means "evaluated the argument to weak header normal form before applying the function"
06:44:13 <apfelmus> e_e_coli: flen' :: Int -> Int -> Int
06:44:20 <allbery_b> e_e_coli: remember currying
06:44:25 <e_e_coli> ah
06:44:36 <allbery_b> you're applying a partially applied function to an Int
06:44:52 <e_e_coli> that did it!
06:44:56 <e_e_coli> unfortunately
06:45:06 <e_e_coli> guessing where to put the $! looks like voodoo to me
06:45:44 * apfelmus dances in trance around the fire. beware of his voodoo puppet, harharhar!
06:45:54 * allbery_b doesn't get it either but figures that means he doesn't understand where laziness is likely to be a problem
06:46:16 <allbery_b> it's presumably something you get a feel for as you continue to use Haskell
06:46:40 <lisppaste2> jethr0 annotated #35467 with "untested flen" at http://paste.lisp.org/display/35467#1
06:46:50 <e_e_coli> so in a lazy language, you don't get tail-call elimination "for free"; you must magically invoke strict eval?
06:46:57 <apfelmus> well, you can always perform normal order graph reduction to see what's going on
06:47:12 <e_e_coli> jethr0
06:47:15 <e_e_coli> that's new syntax to me
06:47:18 <e_e_coli> what does bang mean?
06:47:24 <allbery_b> "strict"
06:47:28 <e_e_coli> well blow me down
06:47:41 <e_e_coli> and that's not "dirty" haskell?
06:47:43 <allbery_b> (hence $! for "strict apply")
06:47:49 <apfelmus> jethr0: the !n is not superflous.
06:47:55 <apfelmus> *is superflous
06:47:59 <jethr0> apfelmus: i just added it everywhere :)
06:48:17 <jethr0> e_e_coli: not really, but i can see why it displeases you
06:48:44 <jethr0> lazyness makes the hard stuff easy and the easy stuff hard :)
06:49:06 <e_e_coli> jethr0, I get a syntax error at flen' 1 with your version
06:49:24 <e_e_coli> "Parse error in pattern"
06:49:35 <jethr0> it's untested and i've never used bang patterns. which ghc do you have?
06:49:36 <allbery_b> I htink bang patterns are an extension
06:49:48 <e_e_coli> 6.6
06:49:55 <jethr0> yes, i guess they are. let me see if i can get it to work
06:50:18 <e_e_coli> well, since $! did work, I'll stick with that
06:50:20 <apfelmus> jethr0: !ah, !i !see. !but !this !can !be !harmful, !as !in (let  when !p !x !y = if p then x else y in when False (1 `div` 0) 2)
06:50:31 <e_e_coli> and now throw away the whole algorithm since it turns out not to converge on 1
06:50:33 <allbery_b> so you need -fglasgow-exts
06:50:44 <apfelmus> e_e_coli: -fbang-patterns. ghc told you that, didn't it?
06:50:53 <allbery_b> or that
06:51:27 <e_e_coli> apfelmus: no, it just whinges
06:51:47 <apfelmus> strange.
06:52:41 <e_e_coli> but I'm using (*cough*) Visual Haskell and GHCi
06:52:46 <e_e_coli> so who knows?
06:54:44 <jethr0> *dumdidum*
07:03:46 <bakert> When I run "runhaskell Setup.lhs build" the ghc that fires is 6.4.1 even though I have 6.6 installed.  Do you know how runhaskell decides what to call?
07:04:06 <bakert> or is it to do with the cabal file???
07:04:56 <kolmodin> bakert: you can either compile Setup.lhs with the correct ghc version, or try to run with runhaskell -f ghcpath
07:05:35 <kolmodin> option 1 would look like: ghc-6.6 --make Setup -o setup
07:05:43 <pbx> This may be a terribly dorky question, but: Are there any Haskell-oriented podcasts?
07:06:16 <kolmodin> pbx: good idea! never herd of any, though
07:06:27 <bakert> kolmodin, i get the same thing from option 1.  when i run "./setup build" i get ghc-6.4.1: unknown package:HDBC-1.0.1 same as before
07:06:36 <bakert> Perhaps i haven't understood my problem properly!
07:06:39 <bringert> pbx: you could run speech synthesis on planet.haskell.org content
07:06:52 <bringert> just kidding
07:06:56 <bakert> "Steven Hawking does Haskell"
07:06:59 <bakert> "the show"
07:07:03 <pbx> bringert: Somebody did that with comp.lang.python and the general reaction was: blech
07:07:14 <bringert> TTS of code is hard
07:07:30 <bringert> we proposed that as a master's thesis project. noone picked it up
07:07:42 <jethr0> speech synthesis is still tiring to listen to
07:07:54 <bringert> how do you read layout syntax alound?
07:08:00 <flux-> I recently hooked festival to my irssi (only specific to a certain person), and it's an amusement atleast ;)
07:10:44 <bakert> kolmodin, i still get the same thing with option 2 as well.  i think i must have some other problem.
07:11:00 <e_e_coli> oof
07:11:11 <e_e_coli> my problem was not the non-convergence of the collatz function
07:11:18 <e_e_coli> it's an overflow
07:11:25 <jethr0> is it possible to generically make all implementations of a type class instances of monad? "instance Monad (TypeClass t => t) where ..."?
07:11:40 <e_e_coli> given
07:11:42 <e_e_coli> collatz n = if even n then n `quot` 2 else 3*n + 1
07:11:47 <e_e_coli> in fact
07:11:51 <e_e_coli> > collatz n = if even n then n `quot` 2 else 3*n + 1
07:11:51 <lambdabot>  Parse error
07:11:58 <jethr0> should've used "Integer" instead of "Int"?
07:12:14 * e_e_coli is running before he can walk, apparently
07:12:27 <kolmodin> bakert: looks so
07:12:32 <bakert> I've seen this one before but I've forgotten what it means.  ld not find module `Database.HDBC.PostgreSQL':
07:12:32 <bakert>       it is a member of package HDBC-postgresql-1.0.1.0, which is hidden
07:12:44 <e_e_coli> ?jethr0++
07:12:44 <lambdabot> Unknown command, try @list
07:12:55 <bringert> bakert: use -package HDBC-postgresql
07:13:33 <jethr0> e_e_coli: my guess is that it might even work without strictness annotations (at least for pretty deep calls)
07:13:38 <bakert> bringert, what does that "hidden" mean?
07:13:41 <e_e_coli> yes
07:13:46 <e_e_coli> and it does converge :)
07:14:04 <bringert> bakert: that it is not available without a -package flag
07:14:11 <bakert> oh
07:14:20 * e_e_coli . o O (so that't the difference between Int and Integer)
07:14:22 <bakert> sort of "not in the standard libraries" type thing.
07:15:24 <bringert> bakert: not really. user-installed libraries can be hidden or exposed
07:15:36 <kolmodin> bakert: edit the packages you use in your cabal file, add HDBC-postgresql
07:15:42 <bakert> well i seem to have zillions of hidden ones.
07:15:46 <bakert> is that bad?
07:15:58 <bringert> bakert, are you using cabal to build your program? or straight ghc?
07:15:59 <kolmodin> no
07:16:00 <bakert> xhtml, regex-compat, cgi-compat, all sorts ...
07:16:15 <bakert> bringert, trying to move from straight ghc to cabal
07:16:28 <bringert> ok, then do as kolmodin says
07:16:31 <kolmodin> :D
07:16:56 <kolmodin> adding that package won't help you select compiler though
07:17:07 <bakert> no i think i might have got around that.
07:17:16 <kolmodin> try this too: runhaskell Setup.lhs configure --help
07:17:17 <kolmodin> ok
07:17:33 <kolmodin> that will give you a list of options, for example to select your compiler manually
07:18:09 <bakert> ok cool.  do i add these packages to ghc-options in the cabal file or to Build-Depends?
07:18:29 <bringert> build-depends
07:18:38 <bakert> ok cool thanks
07:18:44 <kolmodin> yeah, do as bringert says
07:18:45 <kolmodin> :)
07:18:46 <bringert> build-depends: HDBC-postgresql, xhtml, cgi
07:18:48 <bringert> etc
07:19:03 <kolmodin> bringert: at work today?
07:19:11 <bringert> kolmodin, yep
07:19:14 <bakert> what does -O do in ghc-options ... that seems to be in there already.
07:19:18 <bringert> kolmodin, not aarne though
07:19:29 <kolmodin> ok, I think I should've stayed home
07:19:56 <kolmodin> oh right, iirc he'll be in tomorrow
07:20:00 <bringert> yeah
07:20:12 <bringert> I had to come here today to meet a master's thesis student :-)
07:20:15 <kolmodin> I might pop by, I just have to find all the papers
07:20:21 <bringert> sure
07:20:46 <kolmodin> and read up on how this works, prepare my part of the papers
07:20:53 <bakert> sorry guys.  when i add them to Build-Depends instead of with "-package blah" under ghc-options then I get that "is hidden" message again.
07:21:01 <bakert> do you know what i might do to sort that out?
07:21:21 <bringert> ghc-pkg expose HDBC-postgresql
07:21:27 <bringert> maybe
07:21:33 <kolmodin> although you shouldn't have to do that
07:21:38 <bringert> yeah
07:21:45 <kolmodin> using build-depends: x or -package x is the same thing
07:21:55 <bringert> bakert, did you re-run runghc Setup.hs configure?
07:22:01 <bringert> after changing the cabal file?
07:22:05 <kolmodin> run your setup with -v and you'll se the flags cabal passes to ghc
07:22:12 <kolmodin> bringert: good point
07:22:29 <bakert> think i have it now.  after the expose and another configure it seems to work.  i'll check with -v if i get more probs.  thanks so much.
07:22:47 <kolmodin> runhaskell Setup.lhs build should warn if the configuration has changed since you last ran configure
07:23:00 <kolmodin> I forget that too, sometimes
07:23:10 <bakert> doesn't seem to but never mind.
07:23:40 <bringert> kolmodin, yeah, taht would be good
07:23:41 <bringert> that
07:23:43 <kolmodin> no, I ment, I'd like cabal to warn, not that it does
07:23:54 <bakert> oh i see.  yes that would be great!
07:24:25 <kolmodin> ok, someone write it down quick before we forget it
07:24:26 <kolmodin> :D
07:24:43 <bringert> bakert: try undoing the ghc-pkg expose with "ghc-pkg hide HDBC-postgresql"
07:24:49 <bringert> it should work after that
07:24:57 <bakert> cool i will.
07:25:01 <bringert> the expose shouldn't be needed, as kolmodin said
07:25:30 <dons> hey
07:25:33 <bakert> i get it.  expose brings it into the core family, but better to list your dependencies explicitly in the cabal file for the next time you have to set things up.
07:25:34 <glguy> hey!
07:25:41 <dons> we're now beating NewBinary for a bunch of cases
07:25:43 <dons> yay :)
07:25:47 <bringert> hi dons!
07:25:51 <dons> heay
07:26:02 <bringert> did I tell you that htar is faster than BSD tar in some cases?
07:26:08 <dons> oh nice
07:26:16 <dons> and we've only *just* started tuning binary...
07:26:17 * glguy wonders which case
07:26:18 <bringert> when the files in the tar are large
07:26:20 <dons> pull the latest patches
07:26:26 <dons> glguy: Word8 writes seem slower
07:26:30 <dons> everything else seems faster
07:26:31 <dons> not sure why
07:26:48 <bringert> will do, I will just implement recursing through directories first
07:26:49 <dons> NewBinary does super evil mgicks
07:26:52 <kolmodin> dons: good work!
07:27:00 <dons> kolmodin: so grab the latest patches
07:27:01 <glguy> what is NewBinary?
07:27:10 <dons> inlinePerformIO and -fcase-liberate help a fair bit
07:27:10 <glguy> something from the hackathon thingy?
07:27:15 <dons> and some careful careful inlining
07:27:16 <kolmodin> dons: I will as soon I get home from work
07:27:16 <dons> glguy: yeah
07:27:16 <bakert> kolmodin, bringert, thanks for your help ... all building properly now.
07:27:24 <kolmodin> bakert: you're welcome
07:27:25 <shapr> glguy: NewBinary is nhc98's Binary ported to GHC
07:27:47 <shapr> Ported by Hal Daume and maintained by Jeremy Shaw last I checked
07:28:20 <bringert> glguy, basically, in this context, NewBinary is the old binary
07:28:52 <chessguy> that's nice and intuitive
07:28:57 * shapr grins
07:29:20 <bringert> that's why naming things new* is no good
07:29:23 <kolmodin> that's why you never should name your libraries 'newX' and similar :)
07:29:27 <bringert> says the guy who wrote NewCGI
07:29:29 <kolmodin> hah :)
07:29:29 <glguy> so NewBinary is a library? or a compiler extension?
07:29:49 <bringert> lib
07:30:20 <bringert> kolmodin: filipino!
07:30:29 <bringert> kolmodin: now you owe me a beer
07:30:35 <bringert> or whatever the rule is
07:30:54 <bringert> no, you're supposed to say something else
07:30:58 <bringert> can't remember
07:31:23 <mauke> hello
07:31:26 <shapr> jinx?
07:31:41 <shapr> or "pinch poke, you owe me a coke" ?
07:31:49 <bringert> very culturally dependent I guess
07:31:52 <shapr> hiya mauke
07:31:53 <mauke> I could have invented de bruijn indices :(
07:31:56 <kolmodin> bringert: smurf :)
07:32:01 <bringert> dammit
07:32:03 <kolmodin> bringert: and I did already owe you a bir
07:32:04 <dons> kolmodin:
07:32:05 <kolmodin> beer
07:32:07 <dons> 10MB of Word8 in chunks of 1: 9.28MB/s
07:32:07 <dons> 10MB of Word8 in chunks of 2: 12.93MB/s
07:32:07 <dons> 10MB of Word8 in chunks of 4: 13.47MB/s
07:32:07 <dons> 10MB of Word8 in chunks of 8: 13.62MB/s
07:32:10 <dons> 10MB of Word8 in chunks of 16: 14.22MB/s
07:32:12 <dons> :D
07:32:15 <dons> on my *laptop*
07:32:17 <kolmodin> dons: you have got to be joking!?!?! :D
07:32:19 <shapr> mauke: Can you invent de bruijn arrays?
07:32:23 <kolmodin> dons: very nice work!
07:32:32 <mauke> I don't think so
07:32:33 <dons> well, the speed up seemed roughly double with the careful changes i just made
07:32:48 <malebria> @type Data.Set.partition
07:32:49 <lambdabot> forall a. (Ord a) => (a -> Bool) -> Data.Set.Set a -> (Data.Set.Set a, Data.Set.Set a)
07:32:53 <kolmodin> I can't wait to get home and try this myself
07:32:53 <bringert> dons: that isn't the bytestring chunck size, right?
07:32:57 <malebria> Why does this need Ord a?
07:32:57 <mauke> I had this idea for a language where { B } would represent a function with body B
07:33:19 <mauke> @ is the function argument, @@ the outer argument, @@@ the next outer argument, etc
07:33:43 <mauke> this was before I learned any functional language, btw
07:33:52 <kolmodin> dons: remember in oxford where we got 0.25 mb/s with the first prototype.. :D
07:34:04 <mauke> infinite loop: { @ @ } { @ @ }
07:34:18 <mauke> /dev/null function: {{ @@ @@ }} {{ @@ @@ }}
07:34:27 <JKnecht> HOBOL (haskel + snobol)
07:34:28 <kolmodin> dons: I guess that it's the number of word8 we write at once
07:34:30 <chessguy> is this a cousin of BF?
07:34:38 <dons> kolmodin: hehe
07:34:45 <kolmodin> bringert: ^^
07:34:52 <glguy> mutanton: what would an examle of a program that "does something" do?
07:34:54 <dons> bringert: right, that's just big amounts of data
07:36:15 <shapr> mauke: My advice is to carefully write down all the ideas you have now or have had before about programming languages, and then learn everything that's already been published. You're going in the right direction!
07:36:44 <shapr> mauke: Once you know what's been published already, you'll be in the right spot to publish new stuff, right?
07:36:46 <chessguy> shapr, "everything"? that could take a while...
07:36:53 <shapr> Nah, not too long.
07:37:06 <mauke> but they keep publishing more stuff!
07:37:21 <shapr> mauke: I don't think it'll take you more than five years if you focus on it.
07:37:28 <chessguy> so create a stream-processor for learning things that are published
07:37:34 <chessguy> oh wait...
07:37:48 <dmead> bonk.
07:37:49 <mauke> zeno says I can't catch up, no matter how fast I read
07:37:58 <shapr> zeno never wrote code, did he?
07:38:34 <chessguy> who/what is zeno?
07:38:41 <bakert> the greek
07:38:43 <bakert> dude
07:38:53 <shapr> chessguy: You gotta read Hofstadter
07:39:09 <bakert> who said the thing about achilles and the tortoise.  or was it a frog jumping out of a pool?
07:39:18 <chessguy> who/what is Hofstadter
07:39:34 <bakert> Godel, Escher, Bach: An Eternal Golden Braid.
07:39:37 <shapr> exactyl
07:39:44 <mauke> http://en.wikipedia.org/wiki/GEB
07:39:53 <bakert> A mindblowing book about consciousness, logic, strange loops and other good stuff.
07:39:54 <shapr> chessguy: If you like Haskell, you'll enjoy that series.
07:40:12 <chessguy> shapr, you mean GEB?
07:40:15 <bakert> It is quite funny, on occassion, too.
07:40:15 <shapr> This Hamming book I got is amazing also, though very hard to find.
07:40:17 <shapr> chessguy: yup
07:40:21 <pbx> GEB made me into a programmer before I was a programmer...
07:40:40 * bos_ confesses to hating GEB
07:40:41 <shapr> pbx: Hey, did you see notsmack's paste prototype?
07:41:08 <chessguy> sounds interesting
07:41:18 <pbx> shapr: No, is there a URL?
07:41:25 * glguy got his paste prototype to accept new pastes and list pastes
07:41:37 <glguy> annotation support exists but I didn't get to fniishing the page
07:41:42 <glguy> and then I fell asleep
07:41:45 <shapr> pbx: http://70.101.76.11:8000/test
07:41:53 <shapr> glguy: Cool, is it online?
07:42:00 <glguy> nope... its at home
07:42:03 <shapr> aww
07:42:08 <pbx> bos_: I have a hard time reading it now, but at 15 it absolutely blew my mind.
07:42:14 <tuukkah> @source Data.Set.partition
07:42:14 <lambdabot> Data.Set.partition not available
07:42:19 <glguy> I actually fell asleep while writting it
07:42:23 <shapr> heh
07:42:23 <glguy> last night
07:42:35 <shapr> You guys should get a homebound Haskell job...
07:42:41 * JKnecht guesses it's not Coding and Information Theory
07:42:45 <bos_> pbx: ah, like zen and the art of motorcycle maintenance, then :-)
07:42:49 <chessguy> it looks way over my head
07:42:54 <shapr> chessguy: Nah, it's not.
07:43:14 <shapr> chessguy: It bootstraps programmer-ness from nothing.
07:43:56 <JKnecht> all demiurgic like
07:44:49 <shapr> JKnecht: "The Art of Doing Science and Engineering : Learning to Learn"
07:45:23 <JKnecht> shapr: duly noted
07:45:51 <shapr> JKnecht: took me almost two years to find a copy though
07:46:29 <bakert> You know I've been working on this haskell program full time for 11 days and it is 295 non-blank lines (including comments!)
07:46:35 <bakert> I don't know whether to be pleased or depressed!
07:47:18 <edwinb> I bet they're really good effective lines ;)
07:47:57 <shapr> When I first starting learning Haskell after years of Python, I asked Heffalump to read through twenty pages of code. He said he didn't have that much spare time. Twenty pages of Python is half an hour's reading, but twenty pages of Haskell can take a long time.
07:48:13 <opqdonut> :)
07:48:22 <bakert> The thing is I can see a few bits now that are still flabby.
07:48:25 <bakert> When I do:
07:48:34 <mauke> .oO( huhu, twenty characters of Perl )
07:48:34 <bakert> blah <- getInput "blah"
07:48:46 <bakert> I really feel like that line isn't pulling it's weight compared to the others!
07:48:52 * shapr grins
07:48:58 <opqdonut> mauke: yep :)
07:49:12 <bakert> Something with >>= could probably include into the middle of something else.
07:49:27 <bos_> what does [_$_] mean?
07:49:39 <bakert> Fat woman in a parking lot?
07:49:47 <opqdonut> :D
07:50:04 <Igloo> bos_: End of line - it's showing you trailing white space
07:50:11 <bakert> well, you know those funny pictures they make with characters -- it could be one of those.  "expensive hooker"?
07:50:25 <bos_> Igloo: so it's a darcsism?
07:50:30 <Igloo> Yes
07:50:36 <bos_> thanks!
07:50:36 <mauke> it's a reference to an anonymous array containing the result of applying _ to $_
07:50:53 * bos_ smacks mauke and bakert
07:51:14 <shapr> Dang, I missed the opportunity for wild speculation..
07:51:27 * bakert looks pensive
07:51:46 <mauke> I guess it could also be a method call
07:51:59 <mauke> depends on whether _ is in scope or not
07:52:41 <shapr> mauke: C'mon, read faster. I want to know what de bruijn arrays should do.
07:53:24 <mauke> what should I read for that?
07:53:36 <shapr> I'm not sure.
07:54:36 <bos_> a de bruijn array is just a concrete representation of a de bruijn sequence,
07:54:46 <bos_> so look up "de bruijn sequence" in google.
07:54:47 <mauke> I guess you could call Γ an array
07:57:08 <pbx> shapr: Nice.  I added preliminary Haskell support to my pastebin, but it's somewhat broken (the most serious being that HsColour seems to double newlines after comments, or I'm doing something wrong with it) so I may pull it until I can fix that stuff. But anyway, for example: http://dpaste.com/4733/
07:57:46 <bakert> pbx, that's very nice.
07:57:48 <glguy> Do HaXml and HXT solve mostly the same problems?
07:57:58 <bakert> pbx, good set of options.
07:58:02 <glguy> or are they more ortogonal than that
07:58:57 <pbx> bakert: Thanks. Trying to keep it clean...
07:58:58 <shapr> glguy: HXT capabilities have been expanding for years. I know HXT can do XSLT now. But they're totally different libraries under the hood as well.
07:59:41 <malebria> @type findMin
07:59:42 <lambdabot> Not in scope: `findMin'
07:59:47 <malebria> @type Data.Set.findMin
07:59:48 <lambdabot> forall a. Data.Set.Set a -> a
08:00:03 <shapr> glguy: I haven't used HXT in a long time, but I use HaXml every once in awhile. Though I've not compared them recently, I'd guess that HXT does more stuff, but that HaXml is easier to use.
08:00:08 <malebria> Why does findMin is not Ord a and partition is?
08:00:41 <glguy> ?type Data.Set.insert
08:00:43 <lambdabot> forall a. (Ord a) => a -> Data.Set.Set a -> Data.Set.Set a
08:00:45 * shapr wonders if that was a filibuster
08:00:53 <glguy> ?type Data.Set.fromList
08:00:54 <lambdabot> forall a. (Ord a) => [a] -> Data.Set.Set a
08:01:10 <glguy> Sets contain things that are instances of Ord..
08:01:24 <shapr> pbx: looks nice
08:01:37 <malebria> glguy: but shouldn't  findMin need Ord a?
08:01:50 <glguy> malebria: not if the way a set is laid out
08:01:55 <glguy> malebria: allows it to lookup the min
08:01:58 <glguy> malebria: without comparing
08:02:16 <glguy> for example, you can find the min of a binary search tree
08:02:19 <malebria> glguy: hum sure.
08:02:19 <glguy> without looking at the elements
08:02:45 <chessguy> but you have to be able to compare the elements to build a binary search tree
08:03:03 <glguy> chessguy: but you don't have to build a binary search tree to find the min of a set :)
08:03:12 <glguy> since a set is already ordered
08:03:29 <chessguy> then it's not a set
08:03:33 <glguy> which is why the construction functions on Data.Set have Ord requriements
08:03:35 <glguy> and findMin doesn't
08:03:53 <chessguy> ?type findMin
08:03:55 <lambdabot> Not in scope: `findMin'
08:04:01 <glguy> ugh
08:04:02 <chessguy> @hoogle findMin
08:04:02 <lambdabot> Data.Map.findMin :: Map k a -> (k, a)
08:04:03 <lambdabot> Data.Set.findMin :: Set a -> a
08:04:03 <lambdabot> Data.Graph.Inductive.Internal.Heap.findMin :: Ord a => Heap a b -> (a, b)
08:04:05 <glguy> ?type Data.Set.findMin
08:04:07 <lambdabot> forall a. Data.Set.Set a -> a
08:04:26 <glguy> You can find the minimum of a Data.Set.Set without looking at the actual elements of the set!
08:04:32 <chessguy> i don't get it. how?
08:04:41 <chessguy> ?src Data.Set.findMin
08:04:42 <lambdabot> Source not found. Take a stress pill and think things over.
08:04:47 <bakert> ?where Network.Browser
08:04:48 <lambdabot> I know nothing about network.browser.
08:04:48 <glguy> because a Data.Set.Set is stored in an ordered way
08:04:56 <bakert> ?where Network.HTTP
08:04:56 <lambdabot> I know nothing about network.http.
08:05:19 <chessguy> but if it's stored in an ordered way, then a must be an instance of Ord
08:05:21 <glguy> chessguy: if I gave you a dictionary, coudl you find the min word using lexigraphical sorting?
08:05:32 <JKnecht> (scratches head) the blue ones or red ones?
08:05:40 <bringert> bakert: http://www.haskell.org/http/
08:05:41 <lambdabot> Title: Haskell HTTP package
08:06:04 <glguy> chessguy: without comparing any two of the words?
08:06:06 <bakert> bringert, waah.  thanks bjorn ... i was going mad trying to find it in google!
08:06:06 <chessguy> oh, i get it now
08:06:17 <chessguy> but still...if it's ordered, then it shouldn't be called a set
08:06:31 <bringert> @google haskell http
08:06:32 <lambdabot> http://www.haskell.org/http/
08:06:33 <lambdabot> Title: Haskell HTTP package
08:06:33 <glguy> chessguy: it has to do with the internal representation
08:06:52 <bringert> bakert, remember to always include "haskell" when googling for haskell stuff
08:07:02 <therp> haha.. ad goedel escher bach, amazon has this "consumers who bought this item also bought..".. and for GEB, you get there: "Compilers. Principles, Techniques, and Tools"
08:07:02 <bringert> otherwise it can be hard to find for example haddock
08:07:11 <bringert> @google haddock
08:07:14 <lambdabot> http://www.haddock.org/
08:07:14 <lambdabot> Title: Haddock
08:07:18 <bakert> ?google haskell network.http
08:07:19 <lambdabot> http://packages.debian.org/cgi-bin/search_contents.pl?searchmode=filelist&word=libghc6-http-dev&version=unstable&arch=kfreebsd-i386
08:07:20 <lambdabot> Title: Debian -- Debian package contents search results
08:07:26 <bakert> ?google haskell network.browser
08:07:28 <lambdabot> http://www.ugcs.caltech.edu/manuals/libs/haskell-libraries/http-20060324/Network-Browser.html
08:07:38 <bakert> you have to know how to pick your search terms i guess!
08:07:49 <bringert> ah, yes
08:07:58 <bringert> I knew what was in the title of the page
08:08:04 <bakert> i thought the other would be too general .. http appearing in URLs and all.
08:08:12 <bakert> silly me
08:08:26 <bakert> actually i need the version with my changes anyway!
08:08:27 <bakert> doh
08:08:48 <bringert> bakert, I pushed those to the darcs repo
08:08:56 <bringert> afairc
08:09:09 <bringert> maybe without the -c
08:09:09 <bakert> cool.  but not the .tgz for download.  i get it.
08:09:12 <glguy> There is a guy at my office that makes pancakes every week
08:09:25 <glguy> he makes enough for our group to have one every morning
08:09:31 <bakert> glguy, that is excellent!  i microwave pancakes at my office on occasion but every week is very nice.
08:09:49 <chessguy> microwave pancakes? never heard of doing that
08:10:00 <chessguy> it sounds messy
08:10:01 <glguy> he puts all sorts of delicous stuff in them too
08:10:06 <glguy> last week was blueberrys
08:10:12 <glguy> this week is chocolate
08:10:21 <bakert> chessguy, you need to embrace crap food.  they're not real pancakes they are like hardier ones that have already been cooked.  still nice, though
08:10:24 <glguy> and then he uses all sorts of health food ingredients
08:11:22 <malebria> Why isn't there an filter function on Data.Hashtable?
08:11:32 <malebria> Hashtables are not very much used, right?
08:11:33 <chessguy> bakert, i'm not opposed to the notion, just never heard of it
08:11:41 <malebria> Should I use an array instead of that?
08:11:55 <bakert> if you are in the UK, saisburys sell them.  Very cheap.  In the bakery sections.
08:12:01 <bakert> Does cabal have the ability to add targets like "deploy" and stuff to move things around?  i guess in the Setup.lhs you can do pretty much anything.  But I mean in the .cabal file?
08:12:05 <chessguy> i'm not
08:12:12 <bakert> @localtime chessguy
08:12:13 <lambdabot> Local time for chessguy is Tue Jan 16 11:09:57 2007
08:12:21 <bakert> east coast eh?
08:12:24 <chessguy> indeed
08:12:36 <bakert> well if you are in new york you so don't need me to help you find nice food!
08:12:39 <chessguy> and you're making me hungry for lunch early
08:12:53 <bakert> i may have a second lunch in a minute.
08:12:59 <bakert> or some more cake.
08:13:01 <chessguy> i'm not in NY either
08:13:18 <dons> ?yow!
08:13:19 <lambdabot> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like RICARDO
08:13:19 <lambdabot> MONTALBAN'S HAIR!
08:13:19 <bakert> oh.  well it was my most likely guess.  as long as you are not in Savannah.
08:13:46 <bakert> Two friends of mine just moved to Savannah.
08:14:03 <bakert> My entire knowledge of the city comes from Midnight In the Garden of Good and Evil
08:14:10 <bakert> (the book, not seen the movie)
08:14:15 <chessguy> where's savannah?
08:14:27 <bakert> Somewhere east-ish.
08:14:30 <shapr> georgia
08:14:30 <bakert> And south
08:14:33 <chessguy> ah
08:14:41 <shapr> Pretty close to here.
08:14:43 <chessguy> i'm much closer to new york than savannah
08:15:11 <bakert> what's Savannah like.  we were thinking of doing Boston->Savannah and then stopping there with the friends in March.
08:15:13 <jethr0> i'm about equally close to both ^_^
08:15:47 <bakert> http://maps.google.com/maps?f=q&hl=en&q=Savannah,+GA&ie=UTF8&z=5&ll=38.993572,-80.947266&spn=25.093622,53.920898&om=1
08:15:48 <lambdabot> Title: Google Maps, http://tinyurl.com/yax7r7
08:15:52 <shapr> dons: Hey, this Hamming book is amazing. He predicted multi-core/smp would be the predominant arch 10+ years ago.
08:16:07 <shapr> jethr0: In that case, come visit me! I have a very comfy couch.
08:16:08 <bakert> ooh lambdabot URL interaction got smarter.
08:16:30 <shapr> jethr0: Aren't you still between education and serious employment?
08:16:46 <bringert> shapr: haven't people been saying that for like 30 years?
08:16:48 <jethr0> hmm, it's equally far because both are thousands of miles away... but thanks for the offer
08:17:00 <jethr0> shapr: yes i am. i've got an interview day after tomorrow again
08:17:02 <bakert> @localtime jethr0
08:17:04 <lambdabot> Local time for jethr0 is Tuesday, 16 January, 2007 17:14:48
08:17:11 <bakert> central europe
08:17:13 <shapr> bringert: Yeah, but Hamming puts it differently.
08:17:24 <jethr0> or anywhere north/south of there
08:17:51 <shapr> jethr0: Well, if you happen to be in the area, you can sleep on my couch.
08:18:12 <chessguy> http://maps.google.com/maps?f=q&hl=en&q=hershey,+pa&ie=UTF8&z=5&ll=40.513799,-76.640625&spn=16.184604,44.296875&om=1&iwloc=addr
08:18:13 <jethr0> *yeah*
08:18:14 <lambdabot> Title: Google Maps, http://tinyurl.com/yx7evv
08:18:21 <shapr> bringert: Hamming's back of the envelope calculations are surprisingly insightful.
08:18:48 <shapr> bringert: I'm sure you can get a copy of the book from inter-library loan or something, and it's really worth reading.
08:19:03 <bakert> What's the title, shapr?
08:19:20 * glguy starts grad school today
08:19:22 <shapr> http://www.scannedinavian.com/hope/entry/111
08:19:25 <glguy> (part-time)
08:19:27 <chessguy> are there any entry-level haskell jobs
08:19:38 <chessguy> in the  us
08:19:44 <shapr> bakert: It's the hamming book mentioned at that URL
08:19:48 <glguy> I think they are passing those out next to the free money samples at the bank
08:19:56 <bakert> chessguy, best to get a job then start writing haskell!
08:20:02 <bakert> chessguy, that's what i did!
08:20:11 <bakert> shapr, thanks.  sounds interesting.
08:20:20 <dons> shapr: seen the 'application level threads for haskell' webserver?
08:20:22 <dons> based on epoll
08:20:27 <chessguy> hard to find time to write in haskell while working full-time doing something else
08:20:28 <dons> and some 64k *threads*
08:20:38 <dons> that beats apache .... in 200 lines ....
08:20:54 <shapr> dons: Don't think I've seen it. Is it from HAC07?
08:21:10 <glguy> dons: the erlang webserver can beat apache with high concurrency as well
08:21:13 <dons> no, talk given at DAMP, let me find the src
08:21:14 <shapr> chessguy: If it's full-time PHP coding, you have lots of spare time!
08:21:19 <dons> glguy: yeah, HAppS does too
08:22:00 <dons> shapr: the 'uifying events and threads' guys
08:22:27 <dons> ?where+ appthreads http://www.seas.upenn.edu/~lipeng/homepage/unify.html
08:22:27 <lambdabot> Done.
08:22:42 <dons> the epoll src looks kinda sweishy
08:23:33 <chessguy> PHP, isn't that short for Please Hack me, Please!
08:23:50 <dons> personal home page ....
08:23:59 <dons> 'nuf said ;)
08:24:09 <bringert> shapr: hmm, Hope lists comments by descending date
08:24:22 * bringert added http://www.scannedinavian.com/hope/comment/59
08:24:27 <chessguy> actually, at this job i'm not even really doing programming, except for the project i invented for myself to do, and i'm doing that one in perl
08:25:36 <jethr0> shapr: is the rabhi book "functional programming approach" good? is it basic stuff or advanced?
08:26:44 <shapr> jethr0: It's basic
08:27:12 <jethr0> :(
08:27:24 <shapr> bringert: scary!
08:27:42 <shapr> jethr0: But I enjoyed it because I had only read a single imperative data structures book before that.
08:27:46 <bringert> shapr: that guy was the XO of an NAS
08:27:51 <glguy> anyone know of a PuTTY that allows you to double click on URLs?
08:28:02 <shapr> jethr0: If you already know lots about data structures you'll enjoy Okasaki's book moer.
08:28:03 <shapr> more*
08:28:11 * jethr0 is still looking for a haskell/func. progr. book that is advanced but not too theoretic. "functional data structures" is nice, but too much O() and proofs for me :)
08:28:17 <pbx> shapr: Thanks. Work in progress. I send a note to the HsColour guy; hopefully I can resolve at least the extra-blank-lines issue soon.
08:28:30 <jethr0> shapr: yes, but it's very tiring for me to read it
08:28:37 <glguy> Oh, sweden is a country?
08:28:42 <bringert> :-)
08:28:51 <shapr> jethr0: How so?
08:29:03 <glguy> I thought it was invented by Americans when they created the Swedish bikini team
08:29:08 <shapr> oy
08:29:15 <shapr> bringert: that's way scary
08:29:39 * glguy hadn't heard of the "US Naval Air Force" either... so
08:29:57 <shapr> Well, the navy does have its own air force...
08:30:00 <glguy> right
08:30:07 <glguy> I just didn't realize that is what they called it
08:30:16 <jethr0> shapr: i don't really know. it's just that i can better get into practical examples than theoretical texts.
08:30:35 <bringert> unsafeInterleaveIO rocks!
08:30:46 <glguy> makes htar super fast?
08:30:47 <jethr0> that's why i like papers by SPJ so much, because they are highly and directly applicable
08:30:50 <opqdonut> glguy: nutty has hyperlinks
08:31:04 <opqdonut> glguy: but i think it is based on an old putty version with some vulns
08:31:17 <shapr> Okasaki's book focusses on amortization. Maybe you'd get into it better if you read about finger trees and other useful amortization applications?
08:31:42 <bakert> The guy who wrote putty went to my primary school (age 5-11).  I emailed him the other day but he didn't remember me.
08:31:47 <shapr> For example, worst case imperative ephemeral data structures are mentioned in there. They're useful in interrupt handlers for example.
08:31:47 <bos_> dons: ping
08:31:51 <bringert> glguy: I just use it for lazy recursive directory traversal, but lazy bytestrings also use it, which lets htar run in constant space
08:31:55 <bakert> Which is a bit of a cheek as we were both on the "top maths table".
08:32:13 <opqdonut> :)
08:32:14 <bakert> To be fair to him he was only there one year.
08:32:18 <bos_> @seen dons
08:32:18 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 8m 18s ago.
08:32:21 <glguy> bringert: is there anything I should read about when it is appropriate to use it?
08:33:01 <jethr0> shapr: i'm pretty alright with the basics from my CS studies, i just don't get hyped by it as much as i'd like to
08:33:02 <bringert> glguy, hmm, I don't know. It is the primitive used to implement lazy IO
08:33:20 * kolmodin is home from work
08:33:33 * shapr is about to start work!
08:33:40 <bakert> @localtime kolmodin
08:33:41 <lambdabot> Local time for kolmodin is Tue Jan 16 17:31:24 2007
08:33:45 <bakert> not bad.
08:34:05 <shapr> I bought a nice USB card reader for $14 from Sam's. I can upload pix near-instantly now!
08:34:10 <kolmodin> bakert: I left early :)
08:34:19 <bakert> kolmodin, always the best plan.
08:34:30 <pbx> ?users
08:34:30 <lambdabot> Maximum users seen in #haskell: 311, currently: 301 (96.8%), active: 33 (11.0%)
08:34:46 <koala_man> what is the definition of an active user?
08:34:51 <bakert> last 3 hours
08:34:56 <koala_man> ?users
08:34:56 <bakert> having said something (i think)
08:34:56 <lambdabot> Maximum users seen in #haskell: 311, currently: 301 (96.8%), active: 34 (11.3%)
08:35:03 <koala_man> apparently
08:37:14 <chessguy> LB should say 'active in the last 3 hours'
08:37:22 <chessguy> would be much less ambiguous
08:37:26 <earthy> there, another feature in dazzle.
08:37:45 <earthy> damn, plumbing is easy in Haskell
08:38:04 <glguy> ?losers
08:38:04 <lambdabot> Maximum users seen in #haskell: 311, currently: 301 (96.8%), active: 35 (11.6%)
08:38:07 <glguy> ?teens
08:38:08 <lambdabot> Lately, I have seen [particle], bakert, bos_, bringert, chessguy, dons, earthy, elpolilla, erg0t, glguy, jethr0, koala_man, kolmodin, lithyum, opqdonut, pbx, sebazzz, shapr, sjanssen and timtoady.
08:38:13 <chessguy> heh
08:38:23 <chessguy> ?l
08:38:23 <earthy> teens?!
08:38:23 <lambdabot> Maybe you meant: learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban . pl v
08:38:36 <chessguy> ?lojban
08:38:52 <chessguy> uh-oh, did i crash it?
08:38:53 <chessguy> @bot
08:38:53 <lambdabot> :)
08:38:56 <earthy> ?lojban Maybe you meant something to translate?
08:38:57 <jethr0> edit_distance "seen" "teens" = replace + insert
08:39:01 <lambdabot> Error: 501 Syntax error, illegal parametersError: 501 Syntax error, illegal parametersError: 501 Syntax error, illegal parametersError: 501 Syntax error, illegal parametersError: 501 Syntax error,
08:39:01 <lambdabot> illegal parametersError: 501 Syntax error, illegal parameters
08:39:02 <chessguy> whew
08:40:04 <glguy> ?quote lojban
08:40:04 <lambdabot> robreim says: Great, now we've got to start an IRC channel for lojban-speaking, haskell-coding anarchists
08:40:26 <basvd> Does anybody know what the current URL of Coddfish is? See: http://www.haskell.org/haskellwiki/Libraries_and_tools/Database_interfaces/CoddFish The old website and papers can still be found in Google cache but I would like to update the wiki to the new url.
08:40:28 <lambdabot> Title: Libraries and tools/Database interfaces/CoddFish - HaskellWiki, http://tinyurl.com/ymaeu7
08:42:38 <pbx> "The origins of the Singularity have been traced back to mid-2008, when the #haskell lambdabot became the largest single software entity on the planet..."
08:43:03 * shapr grins
08:43:18 <Masklinn> is that before of after lambdabot becomes self-aware?
08:43:30 * glguy finds a PuTTY with clickable hyperlinks
08:44:15 <ClaudiusMaximus> which xml parser is recommended
08:44:52 * glguy has used and likes HXT
08:44:55 <lambdabot> Masklinn: I am already self-aware
08:45:01 <glguy> shapr suggested that HaXml was easier to use
08:45:06 <glguy> (but I haven't used it)
08:45:49 <pbx> Masklinn: Looks like I may have gotten the timeline wrong.
08:45:50 <shapr> But HXT does some stuff that HaXml doesn't. I guess we need a survey article...
08:46:05 <bringert> @vixen are you really self-aware?
08:46:05 <lambdabot> <undefined>
08:46:19 <bringert> that's interesting
08:46:22 <Masklinn> lol
08:46:26 <bringert> @vixen foo?
08:46:26 <lambdabot> <undefined>
08:46:34 <Masklinn> @foo bar
08:46:34 <lambdabot> Maybe you meant: faq ft todo yow
08:46:37 <glguy> vixen was broken
08:46:42 <glguy> by the change in regex format
08:46:46 <bringert> ah
08:47:14 <Masklinn> which goes to show that lambdabot isn't self aware yet, but can already lie
08:47:38 <Masklinn> pbx > looks like your timeline isn't too endangered yet
08:48:24 <dons> vixen broke, i'll fix it later
08:48:29 <dons> hey SyntaxNinja
08:48:42 * dons waves from Nice
08:49:30 <Masklinn> dons > you should try Scala instead
08:49:30 <glguy> Is that in France?
08:49:45 <bringert> it's a nice place anyway
08:49:45 <bos_> dons: i'm having trouble building hs-plugins from darcs
08:49:56 <Masklinn> glguy > duh no http://nice.sourceforge.net/
08:50:06 <Masklinn> (:))
08:52:24 <SyntaxNinja> hi dons
08:52:25 <glguy> looks like the mean min/max temperature in Nice is 4.9 - 12.5 degrees C... how is it actually, dons?
08:52:27 <SyntaxNinja> is it nice?
08:52:32 * glguy is reading the wikipage
08:53:19 <dons> SyntaxNinja: yeah very
08:53:31 <dons> lots of interesting talks too
08:53:58 <dons> SyntaxNinja: seen the new replacement for NewBinary dcoutts, kolmodin and I've been hacking on?
08:54:01 <shapr> I wish haskellwiki had an 'unlit'. It's hard to automatically strip out the sources in a page for testing. Can I do inline attachments instead?
08:54:12 <SyntaxNinja> dons: no, sounds rock, though.
08:54:22 <dcoutts__> SyntaxNinja: hia
08:54:22 <SyntaxNinja> I have to chnange rooms. I'll brb
08:54:23 <dons> its a pure bytestring serialiser, and today we just got it running faster than newBinary
08:54:26 <dons> without the clutter
08:54:29 <SyntaxNinja> it's snowing here and I"m freezing in my back office.
08:54:29 <shapr> And since SyntaxNinja is a rock climber, that's a great compliment!
08:54:37 <dcoutts__> mmm, snow
08:54:48 * dcoutts__ yearns for snow
08:55:02 <glguy> it was snowing here this morning
08:55:24 <glguy> When I tried backing up, my wheels stopped me, they were frozen
08:55:31 <glguy> I gave it more gas and broke them free
08:58:46 <dons> mmm. binary is writing Word8s at 19.08MB/s
08:59:27 <kolmodin> SyntaxNinja: hi
08:59:28 <bos_> that's rather slow.
09:00:21 <bringert> dons: have you compared it to a simple C loop?
09:00:23 <dons> well, its beating newBinary, so I'm happy :)
09:00:27 <dons> bringert: ah good idea
09:00:45 <dons> and considering its generating the results lazily
09:00:51 <dons> in a Writer...
09:00:52 <dons>  :)
09:01:03 <SyntaxNinja> wjew
09:01:04 <bringert> maybe you can compare to cat too?
09:01:11 <glguy> are there any types that work well in a writer?
09:01:11 <bringert> or dd rather
09:01:20 <dons> glguy: dlists
09:01:23 <dons> or their equivalent
09:01:30 <glguy> dons: what module are those in
09:01:47 <dons> ?where binary
09:01:47 <lambdabot> http://darcs.haskell.org/binary
09:02:52 <dons> bos_: so its /serialising/ though
09:03:57 <glguy> once this gets stable, is it something that HAppS might use
09:04:02 <glguy> for its serialization of the appstate
09:04:08 <dons> yeah
09:07:40 <ClaudiusMaximus> hmm, is it normal that http://haskell.org/hawiki/ThisPageDoesNotExist (for example) spits out a long list of error messages?
09:07:41 <lambdabot> Title: ThisPageDoesNotExist - The Haskell Wiki
09:13:50 <sjanssen> ClaudiusMaximus: hawiki is deprecated
09:14:16 <sjanssen> the error message reflects that you are not allowed to create new pages, I think
09:14:47 <glguy> What type does haskell use to represent dates?
09:14:54 <glguy> ?hoogle date
09:14:54 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
09:14:54 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
09:14:54 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
09:15:28 <sjanssen> @docs Data.Time
09:15:28 <lambdabot> Data.Time not available
09:15:54 <bos_> dons: for reference, serialising one byte at a time from python goes anywhere from 1.1 MB/sec to 70 KB/sec, depending on the module you use
09:15:58 <sjanssen> http://www.haskell.org/ghc/docs/latest/html/libraries/time/Data-Time.html
09:15:59 <lambdabot> http://tinyurl.com/yzllnx
09:16:43 <sjanssen> bos_: and serialization is pretty mature in Python?
09:16:49 <bos_> sjanssen: yes.
09:17:06 <sjanssen> pwned :)
09:17:33 <bos_> sjanssen: it's a long way ahead of what we have in haskell, in terms of capabilities.
09:17:45 <vincenz> > 1.4 * 1024 / 19.08
09:17:46 <lambdabot>  75.13626834381552
09:18:16 <sjanssen> bos_: oh?  what sorts of features are we missing?
09:18:20 <vincenz> dons: two questions regarding binary: 1) will it be possible to use "deriving", 2) Will it be possible to use custom byte-layouts?
09:18:21 <bos_> but the new binary stuff is very nicely put together, so it's a great start.
09:18:41 <sjanssen> vincenz: 2 is possible right now
09:18:42 <bos_> sjanssen: type safety. writing and reading cyclic data.
09:18:55 <bos_> sjanssen: automatic derivations.
09:19:33 <bos_> i have a trivial typesafe module that sits on top of the new Data.Binary
09:20:02 <sjanssen> bos_: what is type unsafe about Data.Binary?
09:20:25 <bos_> sjanssen: if you write out an Int, and read back a String, it will give you garbage quite happily.
09:20:36 <glguy> can I export record accessors without exporting the data constructor?
09:21:01 <bos_> the serialised representation contains no type info.
09:21:12 <dons> vincenz: a) yes, b) yes (but its like suing Show for custom formats...)
09:21:23 <dons> so the idea is not to use Binary for custom protocol parsing
09:21:28 <dons> instead ot use a combinator library on top
09:21:31 <bos_> but i'd rather have a solid foundation, which Binary gives.
09:21:43 <bos_> and layer stuff on top of it, such as cycle handling, etc.
09:21:50 <dons> bos_, 1MB -> 70 kb?
09:21:57 <dons> bos_ yeah
09:22:02 <bos_> dons: yes, depending on the strategy.
09:22:07 <dons> so quite slow?
09:22:19 <bos_> dons: but this is being very silly, pickling literally a byte at a time.
09:22:29 <dons> ah ok. including type info?
09:22:39 <dons> but our byte at a time stuff is doing 16M/s here?
09:22:45 <bos_> dons: yes to both.
09:22:48 <dons> ah
09:22:58 <bos_> in other words, Binary is teh roxor compared to python.
09:23:23 <vincenz> dons: 'suing'?
09:23:27 <shapr> using
09:23:28 <bos_> but all of the stuff that sits on top needs to be there, too :-)
09:23:40 <vincenz> oh
09:23:40 <dons> yeah
09:23:40 <musasabi> and one-byte-at-a-time can be combined into many bytes at a time with some rules.
09:23:50 <dons> hey musasabi. /me waves from .fr
09:23:55 <musasabi> the largest problem with that is keeping alignment.
09:23:58 <dons> yeah
09:23:59 <musasabi> hello dons
09:24:15 <bos_> i think dons is already using rules to do some fusing.
09:24:18 <dons> we had dinner with the erlang/hipe/bitstream guys last night, and have some good ideas for the next layer up
09:24:21 <dons> nope. no rules yet
09:24:33 <vincenz> dons: bonjour, est ce que vous avez manger des croissants ce matin?
09:24:37 <bos_> dons: what kind of stuff have you in mind?
09:25:00 <dons> vincenz: oui :)
09:25:05 <dons> well, cafe anyway
09:25:23 <dons> bos_ well, we can adopt much of their model for bit packing
09:25:43 <musasabi> I have some rules for monadic combination of serialization that should be easy to port to the new binary, but handling alignment is not solved by them.
09:25:46 <dons> and to do arbitrary protocols I think abd Pretty and Parsec combinator library
09:25:56 <dons> musasabi: ok
09:26:03 <dons> so you just go the fast path, for unaligned data?
09:26:10 <dons> or rely on it being aligned to start with?
09:26:32 <bos_> dons: is this thhhhhuff they describe in their padl paper?
09:26:35 <dons> musasabi: if you want to check the binary src
09:26:38 <dons> bos_ yeah
09:26:42 <dons> ?where binary
09:26:42 <lambdabot> http://darcs.haskell.org/binary
09:26:46 <musasabi> dons: I was looking at the repo.
09:26:47 <dons> the rules should be fairly simple I think
09:27:14 <dons> but according to the erlang guys, speed is less important than flexibility (for the protocl parsing)
09:27:19 * glguy wonders if there is a FiniteIntMap
09:27:21 <dons> so a parsec style thing there is the way to go
09:27:24 <musasabi> btw there was a paper about Haskell + bit syntax some time ago.
09:27:25 <dons> glguy: yeah, IntMap
09:27:28 <dons> yeah
09:27:35 <mauke> btw, I wrote a program in haskell: http://rafb.net/p/gibBdO55.html
09:27:41 <glguy> oh, duh
09:27:42 <musasabi> having the same syntax for both encoding/decoding is important.
09:27:42 <lambdabot> Title: Nopaste - No description
09:27:49 <dons> mmm. yes
09:27:53 <glguy> (I'm already using IntMap, forgot that it was already finite :)
09:28:43 <SyntaxNinja> http://darcs.haskell.org/haskell-prime-report/report/haskell-prime-draft.html
09:28:44 <lambdabot> Title: The Haskell Prime Report: Working Draft, http://tinyurl.com/y99amy
09:28:45 <dons> musasabi: so the plan is to make this the standard Binary, I think
09:28:45 <SyntaxNinja> W00t!
09:28:53 <dons> whoo!
09:28:58 <dons> SyntaxNinja++
09:29:13 <bos_> the erlang bitstream stuff contains lots of special pattern matching syntax.
09:29:13 <shapr> yay!
09:29:20 <dons> SyntaxNinja: I noticed I had 97 cabalised haskell packages on my laptop yesterday...
09:29:23 <dons> :D
09:29:29 <dons> bos_ right
09:29:38 <dons> we want to think about special syntax at some point
09:29:43 <dons> but combinators will do for now, I think
09:29:50 <bos_> they're a good place to start.
09:30:50 <vincenz> you can always desugar syntax to the combinators
09:30:55 <vincenz> much like do-syntax
09:31:14 <bos_> sure.
09:31:28 <bos_> you just have to sit through the endless language war first :-)
09:31:41 <dons> we've talked a bit to simon about extending pattern guards for this
09:31:50 <vincenz> There's nothing like the smell of a language-flame-war in the morning
09:31:52 <dons> its a bit like the case for arrows or parallel arrays
09:31:58 <dons> both of which get special syntax
09:32:48 <SyntaxNinja> dons: 97? wow :)
09:32:54 <SyntaxNinja> dons: we need to get those guys into hackage :)
09:33:21 <SyntaxNinja> malcolm set up a darcs commit hook to automagically generate the html when folks do a checkin.
09:33:23 <dons> right
09:33:33 <SyntaxNinja> (of Haskell' report)
09:33:42 <dons> ah great
09:33:47 <earthy> schweet
09:33:51 <glguy> shapr: you there?
09:34:00 <earthy> time for dinner.
09:34:10 <glguy> ?seen shapr
09:34:10 <lambdabot> shapr is in #scannedinavian, #unicycling and #haskell. I last heard shapr speak 4m 57s ago.
09:34:41 <shapr> glguy: eh?
09:34:47 <JKnecht> testes
09:34:55 <shapr> glguy: I'm working on the HAppS tutorial, what's up?
09:34:59 <glguy> shapr: did you notice that the odl Happs tutorial neglects to use "thebody"
09:35:02 <glguy> when generating HTML?
09:35:09 <glguy> it puts everything in <head></head>
09:35:18 * shapr blinks
09:35:30 <glguy> I don't know if that has anything to do with you
09:35:42 <glguy> but I figured it woudl be something to watch out for in the new tutorial
09:35:53 <shapr> I don't know either, I'll investigate it after I've finished with the parts I'm working on. Thanks for pointing it out.
09:38:01 * glguy wonders if you can run a HAppS main from ghci...
09:39:10 <pixel> i'm looking http://haskell.org/haskellwiki/99_questions/11_to_20, one solution to pb18 is wrong IMO
09:39:11 <lambdabot> Title: 99 questions/11 to 20 - HaskellWiki
09:40:01 <chessguy> which solution?
09:40:01 <pixel> slice xs i j = [xs!!(i-1)..xs!!(j-1)]   -- only works if the list is [ 'a' .. 'z' ] as in the example, but is no real slice
09:40:40 <glguy> slice xs i j = take (j - i) ( drop i xs) -- ?
09:40:52 <glguy> > let slice xs i j = take (j - i) ( drop i xs) in slice 5 10 ['a'..'z']
09:40:53 <lambdabot>  Couldn't match `Int' against `[a]'
09:41:00 <chessguy> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [1..20] 4 3
09:41:00 <glguy> > let slice xs i j = take (j - i) ( drop i xs) in slice ['a'..'z'] 5 10
09:41:02 <lambdabot>  "fghij"
09:41:02 <lambdabot>  []
09:41:12 <chessguy> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [1..20] 4 3
09:41:14 <lambdabot>  []
09:41:18 <bakert> I have three Doubles and an Int.  Together they make up a little group that I'd like to map stuff across.  But I can't because they are different types.  I get the feeling this is because I am getting this problem because I am not "thinking in haskell".  What do you normally do when you have a set of data like that?  Create a type?
09:41:26 <pixel> sure, the first solution is  slice xs (i+1) k = take (k-i) $ drop i xs
09:41:32 <chessguy> oh they're both supposed to be indices
09:41:37 <chessguy> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [1..20] 4 14
09:41:38 <lambdabot>  [4,5,6,7,8,9,10,11,12,13,14]
09:41:47 <chessguy> this looks fine to me
09:42:03 <chessguy> ohh, i see what you're saying
09:42:04 <glguy> pixel is saying that it doesn't work for: [1,3,6,3,1,6,7,8,3,2,4,76,8]
09:42:07 <pixel> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [10..20] 4 14
09:42:08 <lambdabot>  Exception: Prelude.(!!): index too large
09:42:27 <romano_cr> HAy alguien que quiera hablar de sistemas de alta disponibilidad en Linux?
09:42:29 <chessguy> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [1,3,6,3,1,6,7,8,3,2,4,76,8] 4 14
09:42:30 <lambdabot>  Exception: Prelude.(!!): index too large
09:42:40 <chessguy> > let slice xs i j = [xs!!(i-1)..xs!!(j-1)] in slice [1,3,6,3,1,6,7,8,3,2,4,76,8] 4 5
09:42:41 <lambdabot>  []
09:42:54 <chessguy> yeah, that's not good
09:43:04 <glguy> > badslice (x:_) i j = [x + i - 1 .. x + j - i - 1] in badSlice [5..10] 3 6
09:43:05 <lambdabot>  Parse error
09:43:08 <chessguy> i think the first one on the page is the simplest anyway
09:43:11 <glguy> > let badslice (x:_) i j = [x + i - 1 .. x + j - i - 1] in badSlice [5..10] 3 6
09:43:11 <lambdabot>   Not in scope: `badSlice'
09:43:17 <glguy> > let badSlice (x:_) i j = [x + i - 1 .. x + j - i - 1] in badSlice [5..10] 3 6
09:43:18 <lambdabot>  [7]
09:43:30 <glguy> oh well
09:43:38 <chessguy> though i'd rather it didn't use an n+1 pattern
09:43:48 <vincenz> hmm
09:43:49 <PaulAJ> bakert: I think this is the problem.  Three doubles and an Int sounds like a tuple, not a list.
09:44:07 <bakert> PaulAJ, well yes.  but you can't map over a tuple!
09:44:30 <bakert> PaulAJ, which is why i feel like i might be doing something dumb.  or not understanding the tools available to me.  or something.
09:44:33 <PaulAJ> Thats right.  You need to specify your operations on each member.  What does this tuple represent?
09:44:42 <dons> ?let mapTuple f = f *** f
09:44:43 <lambdabot> Defined.
09:44:51 <bakert> It is the balance, the "funds pending" and a number of transactions.
09:44:52 <dons> > mapTuple toupper ('a', 'b')
09:44:52 <lambdabot>   Not in scope: `toupper'
09:45:01 <dons> > mapTuple toUpper ('a', 'b')
09:45:02 <lambdabot>  ('A','B')
09:45:10 <dons> ;)
09:45:14 <bakert> aha!
09:45:17 <bakert> mapTuple eh?
09:45:23 <bakert> that's interesting.
09:45:34 <Jaak> > mapTuple show (1 :: Int, 0.5 :: Float)
09:45:35 <dons> see the recent thread on -cafe for a variety of other tricksy apporaches
09:45:35 <lambdabot>  Couldn't match `Int' against `Float'
09:45:42 <rahikkala> > mapTuple toUpper ('a', 'b', 'c')
09:45:43 <lambdabot>  Couldn't match `(Char, Char)' against `(a, b, c)'
09:45:52 <PaulAJ> I'm going to have to read that too.
09:45:53 <dons> right
09:45:56 <PaulAJ> Bye
09:46:02 <bakert> dons oh lord arrows ... that looks complicated
09:46:06 <bakert> PaulAJ, thanks for your help
09:46:18 <dons> nah, not really.
09:46:37 <dons> well, ok. yes.
09:46:39 <bakert> dons is day 20 of learning haskell the right time to take on arrows?  i'm game if you think i can handle it!
09:46:47 <dons> but not too hard when you treat them like tuple hacking functoins
09:46:54 <dons> i'm heading out now, so no!
09:46:58 <bakert> "don't look in the box"
09:47:07 <chessguy> ok, i edited the wiki page
09:47:14 <malebria> @type Database.HDBC.withTransaction
09:47:15 <lambdabot> Couldn't find qualified module.
09:47:34 <malebria> Is there a way to do the same as withTransaction from HDBC with haskelldb?
09:47:50 <bakert> malebria, isn't everything in HDBC in a transaction by default?
09:48:09 <bakert> malebria, don't quote me i just have some vague memory of reading something in the docs
09:48:17 <bakert> about not supporting autocommit and ...
09:48:26 <bakert> might be in there.
09:48:38 <malebria> http://darcs.complete.org/hdbc/doc/Database-HDBC.html#v%3AwithTransaction
09:48:40 <lambdabot> http://tinyurl.com/rrers
09:48:45 <bakert> ah.  sorry.  no. that is in HDBC, not haskelldb.
09:48:54 <bakert> you are going TO haskelldb.
09:48:57 <bakert> wrong end of stick.
09:49:06 <fghj> ocaml has it's own virtual machine; does any implementation of haskell also have this?
09:49:15 <vegai> yhc
09:49:36 <bringert> malebria, yes
09:50:01 <bringert> the transaction function
09:50:17 <malebria> bringert: thanks..
09:50:39 <musasabi> Who takes patches to binary? kolmodin?
09:51:07 <chessguy> mmm, still 12 problems on that list not solved yet
09:51:09 <DracoCepheus> any one has a c# parser (using Parsec) somewhere?
09:51:55 <fghj> scheme/lisp users have emacs; is there some editor written in haskell?
09:52:41 <malebria> bringert: why isn't genericConnect in haddock doc from haskelldb?
09:52:43 <musasabi> fghj: yi
09:52:49 <bakert> fghj, there's yi
09:53:05 <Jaak> is it even usable?
09:53:06 <bringert> malebria: the haddocks and the release are quite old. get the darcs version
09:53:34 <bringert> one of these days someone should do something about that
09:54:13 <Lemmih> @seen alexj__
09:54:13 <lambdabot> alexj__ is in #haskell. I don't know when alexj__ last spoke.
09:54:39 <malebria> bringert: sorry, I'm using it, I just wasn't looking in the right doc.
09:54:48 <malebria> I'm using sid version.
09:55:03 <DracoCepheus> is it feasible to write a c# parser using Parsec?
09:55:07 <paolino> @pl do {idx <- gets (indices.arra);(lift.lift) (shuffle idx) >>= mapM_ new}
09:55:08 <lambdabot> (line 1, column 4):
09:55:08 <lambdabot> unexpected "{"
09:55:08 <lambdabot> expecting variable, "(", operator or end of input
09:55:19 <malebria> bringert: the sid version has genericConnect in haddock, but without any help.
09:56:20 <kolmodin> musasabi: I can take them, unless you can't commit to the repo directly
09:56:53 <mgsloan> to whoever I was discussing STM and ruby a few days ago - looks like mentalguy can do it because he's helping with that new ruby implementation
09:57:22 <bringert> malebria: I don't recommend using genericConnect, in fact, its not included in the current darcs version. the debian package seems to be based on the old CVS version.
09:57:36 <chessguy> is there a library for graph-functionality written in haskell somewhere?
09:57:41 <malebria> bringert: yes, it's. What do you recommend for connecting?
09:58:05 <musasabi> kolmodin: I don't think I have permissions.
09:58:15 <bringert> malebria: the easiest is the concrete connection function for your back-end
09:58:31 <bringert> malebria: there is also dynConnect which loads a driver using hs-plugins
09:58:41 <bringert> but that doesn't work on ghc 6.6 yet
09:59:02 <musasabi> kolmodin: http://www.cs.helsinki.fi/u/ekarttun/haskell/binary.patch
09:59:07 <malebria> bringert: ok, thanks.
09:59:15 <mgsloan> chessguy - I think there's Data.Graph
09:59:32 <kolmodin> musasabi: thanks
09:59:39 <mgsloan> From what I've seen of it its not super complete, though (at least, none of the difficult things were implemented :P )
09:59:54 <chessguy> mgsloan, ah, so there is
10:00:18 <chessguy> is nobody familiar enough with it to solve those exercises?
10:00:50 <malebria> bringert: I didn't get how to connect and to run DBDirect without password, is it possible?
10:01:02 <kolmodin> musasabi: you're that finnish guy who wrote a strict bytestring encoder, right?
10:01:30 <bringert> malebria: I'm not sure actually. Maybe using an empty string as password? What back-end is this?
10:01:56 <musasabi> yes, but that was more of a prototype.
10:02:13 <paolino> @pl do {print "ciao"}
10:02:13 <lambdabot> (line 1, column 4):
10:02:13 <lambdabot> unexpected "{"
10:02:13 <lambdabot> expecting variable, "(", operator or end of input
10:02:35 <malebria> bringert: postgreSql. I haven't tried using haskelldb, but with DBDirect I couldn't.
10:02:43 <bakert> what's the quickest way to say "if any of these (not all the same type) are Nothing"
10:02:44 <malebria> bringert: I tried with ""
10:03:36 <bringert> malebria: I don't know how to do that. You could try with the underlying layer directly. Are you using HDBC?
10:03:38 <kolmodin> musasabi: right, but as you can see, I used a few ideas from your library
10:03:49 <paolino> how does it work @pl with {} ?
10:04:06 <kolmodin> musasabi: and we'd really like to get your rules working in our library
10:04:09 <malebria> bringert: it's not necessary to disconnect, right? I think the sid version uses hsql.
10:04:18 <malebria> bringert: at least the package depends on hsql.
10:04:57 <bringert> malebria: I don't know
10:05:43 <bringert> bakert: liftMX where x = 2,3,...
10:05:52 <master_bater> If a million monkeys were typing on computers, one of them will eventually write a Java program. The rest of them will write Perl programs.
10:07:33 <mgsloan> a few might write lisp programs if they really like ( and )
10:08:19 <malebria> bringert: is there a good way to insert a value in a table with a SERIAL field and then get the inserted number without doing commit and query?
10:08:33 <jethr0> is something like "instance Monad (TypeClass t => t) where ..." possible?
10:08:34 <vincenz> master_bater: Perhaps change your name to something different?
10:09:16 <JKnecht> liek master_baiter
10:09:23 <vincenz> JKnecht: yah..
10:09:27 <bringert> malebria: with a bit of hacking, yes. see http://darcs.haskell.org/haskelldb/test/old/CustomSql.hs
10:09:49 <jethr0> @src isPrefixOf
10:09:49 <lambdabot> isPrefixOf [] _          = True
10:09:49 <lambdabot> isPrefixOf _  []         = False
10:09:49 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
10:10:41 <rahikkala> master_bater: Or how about... reppie? It would suit you so well.
10:10:58 <malebria> bringert: thanks a lot.
10:11:01 <mauke> master_bater: see also http://perl.plover.com/idiocy/RandProg.html
10:11:03 <lambdabot> Title: The Easy Way to Write Programs in Perl
10:12:09 <kolmodin> musasabi: pushed
10:12:59 <musasabi> thanks
10:14:00 <chessguy> heh. interesting article
10:14:13 <jethr0> A Lisp programmer who wanted to generate code at random would never generate a random string. Instead, they would generate a random list structure [...]. This does throw light on an important difference between Perl and Lisp. Perl programmers are concerned with strings and with string data; Lisp programmers use structured data wherever possible. [...]. The rest of the world is only beginning...
10:14:14 <jethr0> ...to discover the benefits of the Lisp way of doing things---this approach is precisely what XML is about.
10:14:37 <jethr0> haha
10:17:57 <dmhouse> Anyone ever got a message from haskell-cafe-bounces before after trying to post a message, with the original message included and the word 'Unprocessed'?
10:18:05 <dmhouse> What do I do, just resend?
10:20:29 <chessguy> "Microsoft has a new version out, Windows XP, which according to everybody
10:20:29 <chessguy> is the 'most reliable Windows ever.' To me, this is like saying that
10:20:29 <chessguy> asparagus is 'the most articulate vegetable ever.'
10:20:29 <chessguy>     -- Dave Barry
10:20:32 <chessguy> "
10:20:44 <chessguy> purloined off the signature of someone on -Cafe
10:22:17 <jethr0> @dict articulate
10:22:17 <lambdabot> Supported dictionary-lookup commands:
10:22:17 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
10:22:17 <lambdabot> Use "dict-help [cmd...]" for more.
10:22:59 <DracoCepheus> articulate: Expressing yourself easily or characterized by clear expressive language
10:23:22 <DracoCepheus> OR articulate: Consisting of segments held together by joints
10:23:27 <jethr0> yes, i guess it's part of the joke that it's totally inapplicable here
10:32:06 <fghj> is there something like Gun TeXmacs (WYSIWYG Tex Editor) written hin Haskell?
10:32:30 <vegai> ESR forked GNU? ;)
10:32:50 <vegai> but seriously, there's an editor called yi, which strives to be something like that
10:33:09 <ctkrohn> I don't think there are too many programs like TeXmacs written in any language... the only other graphical math word processors I know of are things like Mathematica and Scientific Workplace
10:33:28 <vegai> ohh, texmacs. I read badly.
10:34:11 <ctkrohn> once you get good enough with TeX you don't want to use TeXmacs anyway
10:34:12 <mgsloan> yeah, I heard that ESR forked a Gnu once...
10:34:22 <ctkrohn> but texmacs is useful to learn...
10:36:38 <dmhouse> mgsloan: sounds painful.
10:36:59 <mgsloan> for the gnu? yes
10:44:54 <chessguy> mmmm, gnu. the other brown meat
10:46:50 <gour> http://darcs.haskell.org/haskell-prime-report/report/haskell.pdf - dead link, as well as http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html.tar.gz
10:48:36 <huschi> does anybody know if getLine is blocking?
10:49:31 <glguy> I can't see how it couldn't be
10:49:54 <huschi> to my mind getchar in c is blocking.
10:50:14 <huschi> and you need to use select if you want an unblocking version.
10:50:43 <mauke> no, you need O_NONBLOCK
10:50:57 <huschi> what's O_NONBLOCK?
10:51:01 <mauke> select just checks the state of the file descriptor (and blocks)
10:51:17 <mauke> man open/man fcntl
10:51:22 <chessguy> hmm, i'm surprised nobody's answered the missionary/cannibal question on -cafe yet. it seems relatively easy
10:52:13 <huschi> mauke: but in the docs of realtimebattle is an unblocking robot that uses select.
10:52:28 <fasta> Isn't this inefficient? f (x:xs) =  f xs ++ [x]
10:52:30 <mauke> that doesn't mean the read() calls are nonblocking
10:52:57 <fasta> Since I can't imagine it gets optimized to f (x:xs) = [x] ++ f xs, since that doesn't hold in general.
10:53:28 <fasta> The first version is O(n^2) the second O(n), if I am not mistaken.
10:53:29 <augustss> fasta: yes that looks inefficient
10:53:41 <fasta> augustss: That's from FGL, again.
10:53:56 <fasta> Why do people even write code if they don't know what it does?
10:54:00 <huschi> mauke: ok, i don't know much about this so i will believe you.
10:54:15 <augustss> fasta: maybe they know the list can only be a few elements long?
10:54:20 <glguy> fasta: f (x:xs) =  f xs ++ [x] -- they are implementing reverse?
10:54:30 <huschi> mauke: has getLine the same behavoiur as select in concerning blocking?
10:54:32 <fasta> augustss: no, they don't know that.
10:54:42 <augustss> fasta: then that code is bad
10:54:45 <mauke> huschi: that doesn't make sense
10:54:53 <fasta> augustss: It's O(degree of a node)
10:55:17 <huschi> mauke: ok, i'm a fool. i noticed the difference.
10:55:29 <mauke> getLine will wait until it sees a '\n'
10:56:05 <huschi> i think i should use hReady to query whether input is available.
10:57:00 <mauke> why do you need to query?
10:57:23 <huschi> i get about 4 lines every 50 ms and have to do some work in between.
10:57:26 <romano_cr> alguno de ustedes habla español?
10:57:35 <vincenz> no, pero esiste haskell.es
10:57:54 <mauke> huschi: hmm, how about threads?
10:58:13 <araujo> romano_cr, me!
10:58:33 <araujo> romano_cr, aunque creo que #haskell.es seria unmejor lugar para hablar español :-)
10:59:05 <huschi> mauke: that won't work. i need exactly the 4 till 6 six lines i get every tick then do some work and then wait for the next lines to repeat the process.
10:59:47 <huschi> mauke: i've written a version that uses a thread to write the outputs from getContents to a channel.
10:59:48 <mauke> that sounds broken
11:00:11 <huschi> mauke: no, it's game about robot programming.
11:00:25 <DracoCepheus> i get a compile error (unexpected '.') when importing Parsec.Token .. any ideas?
11:00:38 <huschi> mauke: i want to program a robot using frp.
11:00:38 <mauke> DracoCepheus: what compiler?
11:00:50 <DracoCepheus> hugs
11:01:03 <huschi> DracoCepheus: it need so bee "import Parces.Token (..)"
11:01:30 <glguy> is there a better way to determine if something is a number than: all isDigit xs   or   (not . null) [() | (_,"") <- reads xs :: ReadS Int]
11:01:34 <mauke> DracoCepheus: hmm, try hugs -98
11:02:05 <mauke> glguy: I'd use all isDigit
11:02:24 <huschi> Text.ParserCombinators.Parsec.Token isn't that the name of the module?
11:03:08 <allbery_b> or ParsecToken in H98 mode
11:04:03 <DracoCepheus> -98 worked
11:04:20 <DracoCepheus> does this mean parsec is not standard (or something)?
11:05:45 <mauke> it means you can't use . in module names in haskell98
11:06:16 <DracoCepheus> oh ok
11:06:20 <ClaudiusMaximus> ?hoogle entities
11:06:21 <lambdabot> No matches found
11:06:30 <ClaudiusMaximus> ?hoogle entity
11:06:30 <lambdabot> Control.Monad.Identity :: module
11:06:31 <lambdabot> Control.Monad.Identity.Identity :: a -> Identity a
11:06:31 <lambdabot> Control.Monad.Identity.Identity :: newtype Identity a
11:06:39 <dmhouse> Yay, Wikipedia donations exceed $1,000,000.
11:11:19 <DracoCepheus> ?hoogle combinator
11:11:20 <lambdabot> Text.ParserCombinators.Parsec.Combinator :: module
11:11:27 <velco> ~300k only this year
11:23:03 <ClaudiusMaximus> ?hoogle unescape
11:23:04 <lambdabot> Network.URI.unEscapeString :: String -> String
11:23:04 <lambdabot> Network.URI.isUnescapedInURI :: Char -> Bool
11:24:18 <ClaudiusMaximus> ?hoogle [(String,String)] -> String -> String
11:24:19 <lambdabot> No matches, try a more general search
11:24:34 <mauke> what are you trying to do?
11:24:36 <ClaudiusMaximus> ?hoogle [(String,String)] -> String -> String
11:24:37 <lambdabot> No matches, try a more general search
11:24:38 <ClaudiusMaximus> oops
11:25:13 <ClaudiusMaximus> mauke: i have an xml file, which contains further xml with all the xml special characters converted into entity references
11:26:20 <ClaudiusMaximus> mauke: so i need to parse the xml, unescape the resulting strings into xml, and parse that xml
11:26:39 <mauke> sounds like parse (parse xml)
11:29:23 <fasta> Can I profile code compiled with -O?
11:30:10 <huschi> what's better to use fmap or liftM for the IO monad?
11:30:50 <Igloo> fasta: Yes
11:31:12 <glguy> http://fserv.pikapphi.umr.edu:8000/ -- pastebot in progress
11:31:17 <glguy> annotations not live yet
11:31:24 <Igloo> huschi: Whichever feels more natural to you
11:32:06 <shapr> glguy: Yay! Go Fastah!
11:32:07 <huschi> fmap is easier to use since i don't need to import liftM :)
11:32:15 <glguy> shapr: I started recoding it over lunch
11:32:24 <glguy> shapr: I might not get to work on it much until tonight after class :)
11:32:39 <glguy> I figure that I will using CSS to make it pretty when I'm done
11:32:42 <shapr> Running code is good code.
11:33:09 <glguy> it will store up to 100 pastes before it starts overwriting
11:34:22 <shapr> spiffy
11:34:36 <glguy> you should paste something...
11:34:37 <glguy> anything
11:35:07 <psnl> @seen dcouts
11:35:07 <lambdabot> I haven't seen dcouts.
11:35:12 <shapr> http://fserv.pikapphi.umr.edu:8000/2
11:35:19 <psnl> @dcoutts_:
11:35:19 <lambdabot> Unknown command, try @list
11:35:24 <glguy> hurrah! :)
11:35:24 * psnl curses
11:35:32 <psnl> @seen dcoutts_
11:35:33 <lambdabot> dcoutts_ is in #ghc, #gentoo-haskell, #haskell-overflow and #haskell. I don't know when dcoutts_ last spoke.
11:35:35 <glguy> the forms will look a lot better when CSS is ther
11:35:39 <ctkrohn> glguy: did you use happs to write it?  or did you just use network.cgi, etc. directly
11:35:46 <glguy> ctkrohn: this is happs
11:35:52 <glguy> I'll paste the in progress code :)
11:35:55 <shapr> yay!
11:36:18 <vegai> whoa
11:36:24 <glguy> paste 0 is the state module
11:37:02 * glguy takes down the site to up the paste limit
11:37:12 <notsmack> glguy: nitpick:  The code highlighting is absolutely not XHtml Strict  :-)
11:37:19 <dmhouse> Eww, horrible looking syntx highlighting.
11:37:28 <dmhouse> Eww, <font>.
11:37:29 <glguy> dmhouse: it's configurable, that is hscolour defautls
11:37:45 <huschi> has evaluate also the effect of a deepSeq?
11:37:56 <notsmack> dmhouse: bikeshed.
11:37:56 <glguy> http://fserv.pikapphi.umr.edu:8000/5
11:38:22 <dmhouse> huschi: no, I think it only does WHNF. I might be wrong, though.
11:39:42 * jethr0 doesn't like light blue as highlighting color... apart from that *way to go glguy*
11:39:51 <huschi> dmhouse: mhm, it looks like. we need something like deepseq for haskell!
11:39:57 * glguy plans to make the colros better, and to not use font tags
11:40:13 <jethr0> huschi: supposedly there's something in Strategies
11:40:14 <glguy> but I haven't read anything about hscolour more than how to do exactly what is there now
11:40:16 <jethr0> @hoogle rnf
11:40:16 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
11:40:17 <glguy> rnf
11:40:29 <notsmack> glguy: i've got some code that might help
11:40:39 <glguy> notsmack: yeah, I liked you use of bold
11:42:13 <huschi> the docs for rnf are very poor.
11:44:13 <syntaxfree> a fortune cookie said "You're about to get promoted in your job".
11:44:15 <syntaxfree> I have no job.
11:44:23 <notsmack> http://fserv.pikapphi.umr.edu:8000/6
11:44:34 <malebria> syntaxfree: maybe that means you should get one.
11:44:51 <syntaxfree> actually, it's not precisely what it said.
11:44:58 <syntaxfree> "You're the next to be promoted in your company".
11:45:20 <notsmack> glguy: add a CSS style for those classes and "colorFragment code" should work
11:45:53 <syntaxfree> interesting project: an abstract, Haskell-based language for stylesheets.
11:46:13 <syntaxfree> Which can be compiled into CSS2, CSS3, table-und-<font color> design, etc.
11:46:25 <syntaxfree> maybe later TeX too.
11:46:35 <dmhouse> Ooh.
11:46:36 <dmhouse> I like.
11:46:41 <glguy> notsmack: cool, thanks
11:47:02 <dmhouse> Although I don't see why you'd write the table-and-<font> backend.
11:47:21 <syntaxfree> dmhouse: to demonstrate its power?
11:47:29 <syntaxfree> also, for backwards-compatible sites.
11:47:59 <dmhouse> You can achieve backward-compatibility with just CSS and <div>s.
11:48:06 <dmhouse> Unless you want to go older than IE5.
11:48:21 <syntaxfree> well, yeah. and with firefox running on old enough computers...
11:48:39 <syntaxfree> (I go to this place where they have some 486s running some minimal WM that serves only to boot Firefox)
11:50:03 <syntaxfree> dmhouse: do you think some basic design expertise is necessary for such a project, or inspecting the CSS2 and CSS3 specs would do?
11:50:49 <dmhouse> syntaxfree: some design expertise would be nice, you're basically aiming for a CSS implementation that is usable by visual designers.
11:50:50 <notsmack> syntaxfree: inspecting the specs will almost always do
11:51:12 <bos_> inspecting the specs isn't enough.
11:51:15 <syntaxfree> I'm aiming for some general design language.
11:51:23 <bos_> ah.
11:51:26 <syntaxfree> compilation to CSSn would be lossy.
11:51:32 <syntaxfree> Lossier as n collapses to 0.
11:51:43 <jethr0> @paste
11:51:43 <lambdabot> http://paste.lisp.org/new/haskell
11:51:53 <bos_> bear in mind that compiling to CSSn isn't intrinsically useful, as browsers have vast numbers of CSS bugs.
11:52:08 <bos_> so you want to be compiling to CSS-for-IE6, etc.
11:52:10 <lisppaste2> jethr0 pasted "infinite zip" at http://paste.lisp.org/display/35478
11:52:11 <syntaxfree> well, compiling to <browser>-CSSn
11:52:12 <syntaxfree> yes.
11:52:28 <jethr0> do you have a better idea to zip two infinite lists?
11:52:34 <dmhouse> bos_: how would that help? You can only feed one stylesheet to all the browsers.
11:52:38 <syntaxfree> > zip [1..] [1..]
11:52:39 <lambdabot>  [(1,1),(2,2),(3,3),(4,4),(5,5),(6,6),(7,7),(8,8),(9,9),(10,10),(11,11),(12,1...
11:52:44 <jethr0> not zip, product. sry
11:52:51 <dmhouse> Unless you do mucky browser detection with JS.
11:52:55 <jethr0> [(a,b)| a<-xs, b<-ys]
11:53:18 <syntaxfree> dmhouse: well, the fact is that there are many "practical-CSSes"
11:53:26 <bos_> dmhouse: people parameterise their style sheets on the server side.
11:53:32 <ClaudiusMaximus> mauke: parse (parse xml) doesn't work (i get error: no top level element: found &), it really needs to be something like:   map (parse . wrapWithFakeTopLevelElement. unescape)  (parse xml)   where unescape :: String -> String
11:53:33 <syntaxfree> an uniform language that compiles to them would be useful.
11:53:50 <dmhouse> You could serve to lowest-common-denominator-CSS, which is what is normally done.
11:53:54 * mgsloan always hated XML
11:53:57 <dmhouse> Or CSS-with-some-hacks-for-IE.
11:54:02 <ClaudiusMaximus> mgsloan: me too
11:54:20 <mgsloan> actually, that's a lie.  I used to like it.  Then i tried to extensively use it...
11:54:56 * syntaxfree has a penchant for General Generalized Generalizable Model-kind of stuff.
11:55:18 <mgsloan> yeah, I like it when that general model is nice
11:55:29 <mgsloan> but when the spec is like 1000 pages, no way jose
11:55:32 <dmhouse> syntaxfree: my advice would be chat to visual designers, find out how they think about designs, then write that in Haskell.
11:55:57 <syntaxfree> I'm not *that* into it yet. It just popped up in my head.
11:55:59 <dmhouse> I.e. if they think about 'this block to the left of this other block', then provide a leftOf function.
11:56:04 <syntaxfree> I have about 15 halted projects.
11:56:39 <mgsloan> and when the DOM is horrid to work with
11:56:42 <dmhouse> Oh, sure, I just meant that if you wanted to start this, that's how I'd go about it.
11:58:42 <jethr0> dmhouse: but there's also the fact that programmers are (supposedly, sapir-whorf) very much influenced by the language they are currently using. so, maybe they'd embrace a different approach if it was only presented to them
11:59:29 <dmhouse> jethr0: what do you mean?
11:59:36 <syntaxfree> back in black.
12:00:04 <mgsloan> yeah, often times you will find that languages written in a language will reflect the implementation language - if it is designed on the fly, at least
12:00:12 <jethr0> that "users" often don't know what they'd like best, but that they can only say how they expect sth to work. but that's already something
12:01:33 * notsmack nods
12:01:50 <jethr0> put a css guru and a php programmer in the same room and ask them what they'd expect from a structuring language and you'd get diametrically different answers.
12:01:54 <mgsloan> yeah, that's often times true - the new excel actually graphs 0% as having an area on a bar chart, because the testers thought it would look nicer that way
12:02:23 <syntaxfree> mgsloan: I'm sure there's a simple way to switch that off.
12:02:32 <mgsloan> maybe
12:02:40 <mgsloan> what matters is the default, anyway
12:02:56 <syntaxfree> Microsoft Office is the Land of Switches.
12:03:12 <syntaxfree> instead of allowing you to choose a background color, there's a "White on blue" switch in Word.
12:03:39 <syntaxfree> I wish the develoeprs of R would invest in better-looking graphics.
12:04:07 <syntaxfree> even on Quartz, they're passable for an academic paper, but not for a presentation or a magazine article.
12:04:23 <syntaxfree> it's really optimized for cheap printing as per academic papers.
12:05:10 <vincenz> heh
12:05:18 <vincenz> academic papers are typically written in Latex
12:05:24 <syntaxfree> yes.
12:05:35 <syntaxfree> graphics are often imported from separate PDFs, though.
12:05:40 <vincenz> correct
12:05:40 <syntaxfree> ah, you think I'm still talking of Word?
12:05:44 <syntaxfree> I'm talking about GNU R.
12:05:48 <vincenz> Oh
12:05:52 <syntaxfree> The statistics environment.
12:05:54 * vincenz thought you were talking about word
12:06:10 <syntaxfree> (It's like a statistics package, plus a programming language, plus graphics generation)
12:06:12 <PaulAJ> syntaxfree: I think the white on blue thing in Word is for feature-equality with WordPerfect or something.
12:06:26 <PaulAJ> I know its been there since Word 2
12:06:28 <syntaxfree> I'm kinda comparing them with what you can obtain from Excel.
12:07:06 <syntaxfree> Excel has boxplots and even candlestick charts nowadays, but crunching the numbers is nowhere as convenient as with R.
12:07:18 <syntaxfree> having to export crunched numbers to Excel is a hassle.
12:07:42 <PaulAJ> Hear hear.  If you ever do export in CSV to Haskell, don't get caught by the Magic Characters.
12:07:56 <syntaxfree> magic characters?
12:08:48 <PaulAJ> I meant to Excel.  It does a DWIM thing to imported fields, so a field that has numbers separated by a slash or hyphen or colon
12:09:14 <PaulAJ> will be interpreted as a date or time.  Similar other things happen with quotes.  I think you can just quote a string, but you need to escape it as well.
12:09:19 <syntaxfree> I think R exports directly to XLS.
12:09:29 <syntaxfree> Not sure, though.
12:09:33 <syntaxfree> It does read directly from XLS.
12:09:33 <PaulAJ> Thats safe then.
12:09:51 <PaulAJ> If it can read XLS then it ought to be able to write a subset.
12:10:04 * syntaxfree had a work routine that downloaded .XLS data files from www.ipeadata.gov.br and ran through his "bluelineplot" module.
12:10:49 <lisppaste2> ClaudiusMaximus pasted "how to parse this xml from hell?" at http://paste.lisp.org/display/35479
12:11:26 <fasta> How can I compute the time it takes for a certain function to evaluate, without counting how long the arguments take to evaluate and assuming a consumer of this function consumes the entire value this function produces?
12:11:53 <syntaxfree> this is a "blue line plot": http://img220.imageshack.us/img220/51/pibmundobrasilzq7.png
12:11:58 <syntaxfree> (I invented that kind of chart, mostly)
12:12:35 <bos_> syntaxfree: it looks like a negative of a meteor shower :-)
12:12:52 <syntaxfree> the blue line is a least-squares line.
12:13:07 <syntaxfree> it's kind of a generalized mean -- it's the "middle" of the points.
12:13:29 <syntaxfree> so in the Y axis you have world GDP growth, in the X axis you have Brazil GDP growth.
12:13:35 <vincenz> what is the red
12:13:41 <syntaxfree> If below the blue line, it was a better-than-average year. Get it?
12:13:49 <syntaxfree> red is y=x
12:14:00 <syntaxfree> that is, below the red line Brazil fared better than the rest of the world.
12:14:57 <Saizan> in 1995!
12:15:11 <shapr> syntaxfree: Due to the convention of up = better, why not flip the Y axis?
12:15:13 <Saizan> what happened in 95?
12:15:36 <syntaxfree> shapr: yes, bad psychology.  I should have switched Y and X axes.
12:16:07 <syntaxfree> That was meant to defend the more market-oriented 1995-2002 administration as opposed to the more socialist 2003-2006 administration.
12:16:08 <shapr> syntaxfree: Other than that minor quibble, it's a nifty graph, do you have it described in a blog entry somewhere?
12:16:23 <shapr> I'd like to read about it.
12:16:37 <syntaxfree> ah, I haven't written any meta-stuff on it. Maybe I should.
12:16:54 <shapr> Do you read Tufte books?
12:16:55 <syntaxfree> That was written before the presidential elections of 2006.
12:17:07 <syntaxfree> I read some of the stuff available on the web.
12:17:23 <syntaxfree> I'm very very fond of "exploratory data analysis" in the Tukey tradition.
12:17:24 <shapr> You'd like his books.
12:17:33 <shapr> Do you know sparklines?
12:17:36 <syntaxfree> yes.
12:17:53 <syntaxfree> I think they're statistically limited, though very interesting from a graphic design viewpoint.
12:18:11 <syntaxfree> What my kind of chart does is to explore deviations from a general rule.
12:18:21 <syntaxfree> In general, Brazil's growth is closely associated to world growth.
12:18:31 <shapr> Please write meta-stuff!
12:18:56 <syntaxfree> But apart from that general rule, how different governments fared in improving Brazil's growth?
12:19:06 <syntaxfree> another example: interest-rate and unemployment.
12:19:22 <syntaxfree> In general, interest-rate hikes will bring forth unemployment. But when is the trade-off steeper?
12:19:34 <syntaxfree> of course, you should test the relationship first.
12:19:47 <syntaxfree> Preferably with some suitably large model.
12:19:52 <dmhouse> syntaxfree: what's your day job?
12:20:10 <syntaxfree> But that kind of chart is very clear, and it shows time-evolution of that trade-off.
12:20:19 <syntaxfree> dmhouse: I'm in graduate school in economics.
12:20:40 <jethr0> fasta: you can see timings using the profiler output
12:21:08 <syntaxfree> shapr: I even have a hacked up routine that will produce that plot with two keystrokes -- once data is properly imported to R.
12:21:33 <fasta> jethr0: I asked a pretty precise question, could you reply in the same way, please?
12:21:49 <shapr> syntaxfree: Is the Haskell gnuplot binding any good?
12:21:56 <syntaxfree> shapr: never used it.
12:22:22 <syntaxfree> from that chart, you see that if you don't take into account world growth, 2004 seems better than 1997 and comparable to 1995.
12:22:34 <jethr0> fasta: don't get unfriendly. i'm looking around the web for a profiling tutorial i remember
12:22:44 <fasta> jethr0: I am not unfriendly.
12:22:48 <syntaxfree> If that general relationship is noticed, you see that 2004 was actually a poor year.
12:23:15 <fasta> jethr0: I already used the profiling tools, I am just interested in this one bit of information.
12:23:16 <jethr0> "pretty precise" sounded sarcastic to me, but never mind
12:23:50 <jethr0> fasta: so why won't the profiling tools help you with this problem. is the function not shown in the profiling output?
12:23:55 <syntaxfree> this is an unemployment-inflation blue line plot for Brazil.
12:23:55 <syntaxfree> http://img220.imageshack.us/img220/2347/desempregoinflacqaome3.png
12:23:58 <lambdabot> http://tinyurl.com/ydkwnr
12:24:07 <syntaxfree> the red line makes no sense in this case. two different variables.
12:24:39 <syntaxfree> again, below-the-line = better. I suck at psychology ;)
12:25:49 <jethr0> fasta: i'll be back in some time...
12:38:16 <glguy> yea... paste site isn't *as* ugly and annotations work :)
12:39:06 <chessguy> this is really annoying me. someone asked about solving the classic missionary/cannibal problem on -cafe, and i thought it would be simple, but i'm not coming up with a good way of doing it
12:39:27 <chessguy> i can't even come up with an efficient way to brute-force it by hand
12:41:44 <mgsloan> well, that's practically the definition of brute force, eh :)
12:43:14 <kowey> would the escape from zurg paper be relevant?
12:43:14 <chessguy> screw this, i'll just google it
12:44:03 * glguy encourages people to use http://fserv.pikapphi.umr.edu:8000/ when fitting so that he will have some test data to play with when he gets home :) 
12:48:59 <syntaxfree> bbl. will write the meta-stuff about blue line plots!
12:49:11 <shapr> syntaxfree: thanks!
12:49:18 <syntaxfree> np.
12:49:28 <syntaxfree> I'm starting to think they might actually be interesting and impress some profs.
12:49:55 <syntaxfree> "Proper" statistical analysis has better, more formal methods of detecting this kind of structure, but this is easy to see.
12:50:01 <syntaxfree> Could be easily be popularized, as well.
12:50:04 <syntaxfree> anyway, bbl.
12:50:45 <psnl> ooh, instances aren't first class do-dads
13:00:44 <tuukkah> now that i read about visual haskell i want to use it :-(
13:01:29 <psnl> @seen ndm
13:01:30 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 5h 29m 11s ago, and .
13:01:44 <chessguy> this is why reading is bad
13:01:56 <psnl> @help msg
13:01:56 <lambdabot> msg <nick or channel> <msg>
13:02:24 <glguy> You wanted ?tell?
13:02:35 <psnl> lovely, thanks
13:02:39 <glguy> tuukkah: why don't you use it?
13:02:43 <tuukkah> chessguy, yeah, if i wrote an ide instead, i would be able to use it...
13:02:59 <tuukkah> glguy, proprietary software, on windows
13:03:07 <glguy> tuukkah: and you don't have windows?
13:03:25 <jumps54321> is this the correct place to ask a really beginner question about the type system?
13:03:27 <tuukkah> glguy, nope
13:03:42 <chessguy> jumps54321, sure. go for it
13:03:44 <glguy> jumps54321: is that your question?
13:04:02 * glguy notes that you only get 3
13:04:08 <chessguy> jumps54321, rule # 1 is: ignore glguy
13:04:10 <tuukkah> ;-)
13:04:18 <psnl> ?tell ndm is there some cunning reason why hat doesn't generate a function for changing a Transformed type back to its orginal type?
13:04:18 <lambdabot> Consider it noted.
13:04:20 <glguy> lol, thats a wonderful to miss out on answers
13:04:36 <psnl> jumps54321: I guess so
13:04:36 <glguy> way*
13:04:59 <chessguy> :) i'm just kidding, glguy is a great source when he's not making snide comments
13:05:06 <glguy> tuukkah: does visual c# run in wine?
13:05:17 <glguy> since visual studio express is afree download
13:05:19 <fasta> Anybody with a clue of what the -xt options precisely does?
13:05:40 <fasta> option, even
13:05:49 <fasta> Or where it's implemented in GHC?
13:05:58 <tuukkah> glguy, it would still be proprietary :-(
13:06:02 <fasta> grepping for xt doesn't really work...
13:06:14 <glguy> tuukkah: and you have personal objections to using it?
13:06:29 <fasta> It must be somewhere in the RTS, but well that's not exactly small either.
13:07:14 <glguy> jumps54321: don't leave us hanging, chessguy and I are poised over our keyboards ready to race to answer your question ;)
13:07:17 <tuukkah> glguy, personal? more like societal i suppose
13:07:19 <jumps54321> I am doing scientific programming; is there a nice way to mix integers and floating pt. types in a calculation without the type system assuming everything is a floating pt.?  As an example of this problem:
13:07:32 <jumps54321> myfun n r		= (r+n)^n
13:07:37 <pate> anyone interested in helping a haskell noob?  I'm trying to use it to build RType (a Ruby in Haskell) and am getting an error that I think I understand, but don't know how to solve.
13:07:45 <pate> src/Value.hs:10:7:
13:07:45 <pate>     Could not find module `Control.Monad.State':
13:07:45 <pate>       it is a member of package mtl-1.0, which is hidden
13:07:47 <glguy> jumps54321: you want the fromIntegral function
13:08:08 <glguy> jumps54321: and if you want to exponentiate a float, you want ** instead of ^
13:08:08 <tuukkah> pate, option -package mtl-1.0
13:09:10 <jumps54321> the only problem is that I have long formulas where this type of prob. occurs many times; am I right to assume the only nice way is to use a let binding to represent the same value in two types?
13:09:19 <glguy> :t \n r -> (fromIntegral n + r) ^^ n
13:09:20 <chessguy> @type fromIntegral
13:09:20 <lambdabot> forall b a. (Fractional b, Integral a) => a -> b -> b
13:09:21 <lambdabot> forall b a. (Num b, Integral a) => a -> b
13:09:29 <chessguy> oops
13:09:36 <jumps54321> this is the real code:
13:09:37 <glguy> :t (^^)
13:09:38 <jumps54321> radialProb n l r	= (r*exp (-r/n) * (r/n)^l * (laguerre (2*l+1) (n-l-1) (2*r/n)))^2
13:09:38 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:09:58 <jumps54321> and other similarly complex lines throughout my prog.
13:10:01 <glguy> jumps54321: which arguments: n l r  are integers?
13:10:11 <jumps54321> n and l are integers
13:10:14 <jumps54321> r is floating pt.
13:10:18 <pate> tuukkah: like this?  runhaskell -package mtl-1.0 Setup.hs build
13:10:27 <pate> (because that fails too)
13:11:03 <tuukkah> pate, oh, you're using Cabal. add the package to dependencies in the cabal file, i suppose
13:11:44 <jumps54321> the problem is that expression like r/n and n-l-1 make haskell assume n and l are floats like r, but then (...)^l is undefined
13:11:46 <glguy> http://fserv.pikapphi.umr.edu:8000/9
13:11:48 <glguy> jumps54321: ^^
13:12:06 <glguy> that's a starting point showing fromIntegral and ^^
13:12:10 <jumps54321> k
13:12:22 <glguy> :t (^)
13:12:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
13:12:25 <glguy> :t (^^)
13:12:26 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
13:12:28 <glguy> :t (**)
13:12:29 <lambdabot> forall a. (Floating a) => a -> a -> a
13:12:37 <tuukkah> jumps54321, could you consider using rational numbers within each formula?
13:13:27 <jumps54321> not really, r needs to be a float, esp. since i will take (exp r) at one pt.
13:13:28 <huschi> @hoogle (a -> IO ()) -> Maybe a -> IO ()
13:13:28 <lambdabot> No matches, try a more general search
13:14:06 <jumps54321> and that will probably infest my calcs with more floats
13:14:20 <glguy> (^) raise a number to a non-negative integral power
13:14:26 <glguy> (^^) raise a number to an integral power
13:14:41 <jumps54321> ah, that should work
13:14:43 <glguy> (**) raise a number to a fractional power
13:14:45 <jumps54321> maybe
13:15:05 <huschi> jumps54321: you meant me?
13:15:19 <tuukkah> huschi, we have maybeDo m f = maybe (return ()) f m at least
13:15:39 <huschi> tuukkah: is it in a library?
13:15:43 <jumps54321> no, sorry, i was talking to glguy
13:16:07 <glguy> tuukkah: do you mean: fromMaybe (return ())
13:16:12 <jumps54321> thank you
13:16:13 <glguy> err
13:16:15 <glguy> nvm
13:16:18 <glguy> jumps54321: welcome
13:16:24 <tuukkah> huschi, i assume we defined it in our code because it's not in a library
13:16:30 <huschi> @type fromMaybe
13:16:31 <lambdabot> forall a. a -> Maybe a -> a
13:16:40 <glguy> fromMaybe wouldn't do it, you'd need:
13:16:45 <glguy> what he had
13:17:07 <glguy> > [fromMaybe 1 Nothing, fromMaybe 1 (Just 2)]
13:17:08 <lambdabot>  [1,2]
13:17:10 <huschi> i know. but i hoped to find this very often needed function in a library
13:17:55 <pate> tuukkah, do I add it to the existing BuildDepends line?  I tried that as a csv (Build-Depends:  base, mtl >= 1.0) and that didn't work either (same error)
13:18:16 <glguy> huschi: it is similar to: maybeDo f m = fromJust (return ()) (fmap f m)
13:18:47 <tuukkah> pate, actually, i haven't worked with cabal files myself yet so i don't know
13:18:52 <huschi> i defined it like tuukkah did.
13:19:11 <glguy> sure, that would be a better way
13:19:33 <huschi> fromMaybe x m == maybe x id m, or am i wrong?
13:19:38 <glguy> right
13:20:26 <nmessenger> ?src fromMaybe
13:20:26 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
13:20:43 <huschi> but what's the better type signature for maybeDo: (a -> IO()) -> Maybe a -> IO ()
13:20:52 <huschi> or Maybe a -> (a -> IO ()) -> IO ()
13:21:07 <nmessenger> whichever you curry more should go first
13:21:09 <pate> oh well, thanks anyway
13:21:10 <glguy> maybeDo :: (a -> m ()) -> Maybe a -> m ()
13:21:19 <glguy> what does maybeDo have to do with IO?
13:21:25 <glguy> looks like it has to do with Monads
13:21:25 <sjanssen> @type maybe
13:21:27 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
13:21:27 <glguy> in general
13:21:40 <huschi> the first has the advantage that you can define functions like maybePrint better
13:21:41 <glguy> maybeDo :: Monad m => (a -> m ()) -> Maybe a -> m ()
13:21:55 <sjanssen> @type \f -> maybe (return ()) f
13:21:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
13:22:00 <glguy> huschi: what does maybe print do?
13:22:02 <huschi> and the second is better for special application
13:22:35 <huschi> maybePrint (Just x) = print x and maybePrint Nothing = return ()
13:22:58 <huschi> glguy: i just wrote IO because i'm working in the io monad at the moment :)
13:23:51 <glguy> huschi: my guess would be that you are moving your control stuctures into the wrong functions, but I haven't seen much of your code
13:23:53 <nmessenger> so maybePrint = maybeDo print -- with the (a -> m a) as the first arg to maybeDo
13:24:00 <glguy> so it may very well make sense
13:24:26 <huschi> i'm interfacing with a imperative system.
13:24:42 <glguy> I would say:  when someCondition (print x)
13:25:16 <huschi> i've got commands for robots that concern acceleration and rotation.
13:25:20 <glguy> huschi: your maybeDo is like sequence_ for Maybe
13:25:37 <glguy> with an fmap in between
13:25:51 <huschi> and i need to print them on stdout.
13:25:57 <glguy> or:  mapM_ print xs
13:26:12 <glguy> mapM_ print (maybeToList x)
13:26:29 <huschi> but i only need to print those that are not nothing.
13:26:40 <glguy> huschi: if you have a list of them:
13:26:48 <glguy> mapM_ print (concatMaybes xs)
13:26:57 <huschi> glguy: it's more like a set.
13:27:11 <huschi> but only of at most 5 members.
13:27:17 <sjanssen> huschi: did you see my suggestion above?
13:27:27 <huschi> so i decided to avoid using a set and introduced a record type.
13:27:27 <glguy> :t concatMaybes
13:27:29 <lambdabot> Not in scope: `concatMaybes'
13:27:31 <huschi> which one?
13:27:33 <glguy> huschi: ah
13:27:36 <glguy> :t concatMaybe
13:27:38 <lambdabot> Not in scope: `concatMaybe'
13:27:43 <glguy> ?hoogle concat
13:27:43 <lambdabot> Prelude.concat :: [[a]] -> [a]
13:27:44 <lambdabot> Prelude.concatMap :: (a -> [b]) -> [a] -> [b]
13:27:44 <lambdabot> Data.PackedString.concatPS :: [PackedString] -> PackedString
13:27:47 <sjanssen> :t \f -> maybe (return ()) f -- this one, huschi
13:27:48 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
13:27:59 <huschi> @hoogle catMaybes
13:27:59 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
13:28:07 <glguy> > catMaybes [Just 1, Nothing, Just 2]
13:28:08 <lambdabot>  [1,2]
13:28:08 <glguy> yeah, that
13:28:25 <huschi> but i also have different print commands for them :)
13:28:29 <sjanssen> :t maybe (return ()) print -- isn't this quite clear?
13:28:31 <lambdabot> forall a. (Show a) => Maybe a -> IO ()
13:28:32 <glguy> ah
13:28:46 <huschi> it's becaus i'm interfacing with the imperative world. it sucks.
13:29:01 <huschi> sjanssen: it's too long :)
13:29:30 <huschi> what about maybeDo :: Monad m => Maybe a -> (a -> m ()) -> m ()
13:29:38 <nmessenger> @type maybe (return ())
13:29:39 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
13:29:52 <huschi> and doMaybe :: Monad m => (a -> m ()) -> Maybe a -> m ()
13:30:17 <huschi> the positions of do and maybe in the name tell me which argument comes when :)
13:30:40 <nmessenger> I like it
13:30:52 <huschi> nmessenger: what do you like?
13:31:00 <huschi> maybe (return ())
13:31:17 <nmessenger> huschi, name order that specifys arg order :)
13:31:27 <nmessenger> specifys?!!  o.O
13:31:42 <tuukkah> you can just use flip when you need the other order
13:31:46 <huschi> nmessenger: so you thind it's a good idea? wow.
13:32:09 <huschi> tuukkah: i know: doMaybe = flip maybeDO
13:32:22 <nmessenger> huschi, it's part of the Smalltalk syntax, methinks.
13:32:42 <sjanssen> huschi: doMaybe's argument order is the most typical for Haskell, I think
13:33:00 <huschi> it's good for partial application.
13:33:34 <tuukkah> so i would provide maybeDo and when partial application is needed, use flip maybeDo and avoid namespace pollution
13:33:39 <huschi> but when the a -> m () part is a lambda expression with a do it becomes ugly
13:34:34 <sjanssen> huschi: yeah, common problem in Haskell (see mapM vs. forM)
13:35:13 * glguy thinks if we have a forM we should have a for
13:35:16 <huschi> forM isn't very old?
13:35:23 <glguy> forM is a 6.6 addition
13:35:24 * nmessenger remembers reading a paper somewhere that recommends putting most-curried parameters first, with the Data.Bits library as a counterexample
13:35:26 <sjanssen> huschi: new in GHC 6.6
13:35:41 <huschi> i've never used it. maybe because i'm using ghc 6.4
13:36:00 <sjanssen> glguy: do you think forM should be called for?
13:36:11 <glguy> sjanssen: no, I think for should be flip map
13:36:12 <huschi> it makes haskell more imperative i think.
13:36:16 <sjanssen> nmessenger: yes, Data.Bits argument order is very annoying
13:37:06 <sjanssen> glguy: it's nice to have a short, readable name -- because it's used so often
13:37:06 <Igloo> It's so things read right as infix operators
13:37:08 <huschi> > forM [1..3] $ \x -> do { print x }
13:37:08 <lambdabot>   Not in scope: `forM'
13:37:36 <huschi> it looks like c or something alike.
13:38:18 <sjanssen> Igloo: I would've liked operators with the current argument order and functions with flipped order
13:38:33 <chessguy> ?src forM
13:38:34 <lambdabot> forM = flip mapM
13:39:11 <glguy> there are times I would like to write: for [1..10] $ \ i -> i + x * y . etc
13:39:46 <nmessenger> glguy, well, you could always 'for = flip map'  :P
13:39:49 <glguy> forM [1..3] $ \x -> print x -- works too
13:39:53 <glguy> nmessenger: I do
13:40:07 <glguy> nmessenger: it just seems like most of the M function have a non-M compliment
13:40:25 <glguy> I didn't know why that one was overlooked
13:40:28 <huschi> glguy: i know. but it doesn't look to much imperative :)
13:40:52 <glguy> actually, forM [1..3] print  works too :-p
13:41:03 <glguy> but I understand what you are saying
13:41:45 <huschi> mapM print [1..3] looks best :)
13:42:09 <ClaudiusMaximus> :t xmlUnEscape
13:42:11 <lambdabot> Not in scope: `xmlUnEscape'
13:42:27 <glguy> lambdabot doesn't have HaXml or HXT loaded
13:42:40 <huschi> @pl \s -> doMaybe (putStrLn . s)
13:42:41 <lambdabot> doMaybe . (putStrLn .)
13:43:47 <glguy> doMaybe putStrLn . fmap s
13:44:18 <glguy> er
13:44:53 <glguy> (doMaybe putStrLn .) . fmap -- not much clearer :)
13:46:56 <monochrom> \s -> f (g . s)  is indeed not easily pointfree.  f . (g .) is about the best pointfree form.  If you are not comfortable with that, don't worry about it.
13:47:56 <huschi> f . (g .) seems less expressive than \s -> f (g . s)
13:48:37 <huschi> looks not seems.
13:48:48 <nmessenger> takes a function, attaches 'g' to it, and attaches 'f' to the resulting function.  Seems intuitive to me ;)
13:49:45 <huschi> nmessenger: ok, i've never seen it like this, thx.
13:52:16 <monochrom> People with pointfree training can read f.(g.) without thinking.
13:52:33 * nmessenger recently had one of those brain-hurty things that helped him understand composition sections :D
13:52:54 <nmessenger> "epiphanies" I think they're called.
13:53:43 <LoganCapaldo> f. (g.) h x -> f (g (h x)) no?
13:53:58 <nmessenger> add parens around (f . (g .))
13:54:23 <nmessenger> or use ($)
13:54:50 <monochrom> @unpl f . (g .) h x
13:54:50 <lambdabot> (\ d -> f (g (h x) d))
13:55:28 <nmessenger> oops, I missed a param
13:55:44 * nmessenger hugs lambdabot
13:56:23 <ihope> Aha! It's just like phantom types, except not as phantom!
13:56:37 <monochrom> @unpl f
13:56:37 <lambdabot> f
13:56:43 <monochrom> @unpl f . g
13:56:43 <lambdabot> (\ c -> f (g c))
13:56:51 <glguy> @unpl f . (g . h x)
13:56:51 <lambdabot> (\ c -> f (g (h x c)))
13:57:03 <monochrom> ok, I have faith in lambdabot.
13:57:06 <glguy> @unpl f . ((g . h) x)
13:57:06 <lambdabot> (\ c -> f (g (h x) c))
13:57:14 <glguy> @unpl f . (g . h) x
13:57:14 <lambdabot> (\ c -> f (g (h x) c))
13:57:22 <nmessenger> @pointy f . ((g . h .) j x)
13:57:22 <lambdabot> (\ d -> f (g (h (j x)) d))
13:57:57 <glguy> best written: f . g (h x)
13:58:55 <glguy> I was working out the point free \f g x y -> g x `f` g y   yesterday as an exercise
13:59:17 <glguy> trying to build up my ability :-p
13:59:40 <ihope> There's free as in freedom, free as in beer, and free as in lack.
14:00:13 <glguy> that quit message doesn't make sense to me...
14:00:49 <ihope> Maybe it's truncated.
14:01:00 <LoganCapaldo> Does pf have a point besides making ex-forth programmers feel good?
14:01:12 <nmessenger> conciseness
14:01:32 <ihope> Conciseness...
14:01:34 <nmessenger> concision?  concisitude?
14:01:47 <glguy> ?spell conciseness
14:01:48 <lambdabot> conciseness
14:01:51 <dmhouse> Is there no 'debug print' function that will print anything I want, even if it doesn't instantiate Show?
14:02:02 <emu> ``If the pure-CS academics are aghast at the prospect of crippling their innocent charges' minds with C++, yet have trouble with finding real-world projects that can be done in pure functional languages, I would encourage them to take on the security-critical arena and re-code standard apps in (for example) Haskell.''
14:02:20 <emu> someone wrote that in a letter to The Register
14:03:02 <ihope> Real-world projects that *can* be done in purely functional languages?
14:03:17 <ihope> I think that'd be everything.
14:03:30 <emu> he then goes on to recommend someone re-write ssh/sshd
14:03:38 * nmessenger wonders how a thing can be printed if it can't be made into a String.
14:03:43 <nmessenger> dmhouse, I'd guess not.
14:03:49 <ihope> unsafeCoerce#
14:03:57 <dmhouse> nmessenger: _debug_ print.
14:04:04 <dmhouse> nmessenger: it'd print some kind of internal representation.
14:04:21 <dmhouse> I think something like that was actually developed for the GHCi debugger project.
14:04:33 <monochrom> LoganCapaldo: http://www.vex.net/~trebla/weblog/pointfree.html
14:04:35 <lambdabot> Title: The Point of Pointfree
14:05:08 <monochrom> Perhaps a summary is "it also makes unix shell pipeline programmers feel good"
14:05:59 <nmessenger> Can one pipe a partially piped command through other commands?
14:06:40 <monochrom> I don't understand the question.
14:07:09 <nmessenger> f . (g .) -- just pointing out that composition seems to me as more general
14:07:49 <monochrom> That's sectioning.  Unix shell doesn't have sectioning.
14:08:41 <nmessenger> true, and sectioning is just syntax sugar for currying
14:08:45 <mauke> unix doesn't have partial application
14:08:48 <monochrom> But I don't see any problem defining a new Unix shell that has sectioning or equivalent.  You just need to support higher-order functions.
14:09:26 <monochrom> There is a unix shell with Haskell-like syntax and semantics.
14:09:41 <emu> haskhell?
14:09:55 <nmessenger> hash?
14:10:26 <monochrom> @google haskhell
14:10:29 <lambdabot> http://paste.lisp.org/display/26378/xml
14:10:40 <monochrom> hee hee hee!
14:13:59 <monochrom> probably some stuff in http://www.haskell.org/haskellwiki/Libraries_and_tools/Operating_system#Shell
14:14:02 <lambdabot> Title: Libraries and tools/Operating system - HaskellWiki, http://tinyurl.com/yhvr5j
14:14:08 <dmhouse> Grr, existentials make debugging hard.
14:15:36 <erider> > sqrt (-10)
14:15:37 <lambdabot>  NaN
14:16:11 <mauke> > sqrt (-10 :+ 0)
14:16:12 <lambdabot>      precedence parsing error
14:16:12 <lambdabot>         cannot mix prefix `-' [infixl 6] and `(...
14:16:28 <mauke> > sqrt ((-10) :+ 0)
14:16:29 <lambdabot>  0.0 :+ 3.1622776601683795
14:16:56 <monochrom> debugging haskell is hard :)
14:18:17 <dmhouse> monochrom: well, existentials just compound the problems.
14:18:23 <dmhouse> The new GHCi debugger looks lovely, though.
14:18:28 <dmhouse> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
14:18:29 <lambdabot> Title: 3.8. The GHCi debugger, http://tinyurl.com/2nxab2
14:18:43 <monochrom> w00t
14:19:10 <dmhouse> Is it possible to install GHC HEAD alongside a stable GHC to play with it?
14:21:56 <dmhouse> It feels weird fixing bugs in Haskell.
14:22:02 <svref> I'm confused by Data.Map.lookup being "m a".  I'm using them to map a -> [b], and lookup "returns the result in the monad".  But my call to lookup won't compile: expected type b got [b]
14:22:07 <dmhouse> It's something you don't do as much.
14:22:14 <dmhouse> svref: paste your code.
14:22:26 <dmhouse> ?where paste
14:22:26 <lambdabot> http://paste.lisp.org/new/haskell
14:22:52 <monochrom> You can install as many versions as you want.  For example I still have both 6.4.2 and 6.6
14:23:13 <dmhouse> monochrom: if you type 'ghc' at a shell, which version do you get?
14:23:19 <monochrom> 6.6
14:23:20 <lisppaste2> svref pasted "map problem " at http://paste.lisp.org/display/35485
14:23:33 <glguy> dmhouse: which ever one your ghc symlink point sto
14:23:34 <dmhouse> I guess I could install HEAD with a different --prefix.
14:24:17 <monochrom> /usr/local/bin has ghc-6.6, ghc-6.4.2, and ghc.  ghc is a symlink to one of them.
14:24:18 <glguy> svref: what is "Dict.Map"?
14:24:23 <lisppaste2> svref annotated #35485 with "PS" at http://paste.lisp.org/display/35485#1
14:24:24 <glguy> Data.Map.Map?
14:24:29 <dmhouse> glguy: I guess import Data.Map as Dict
14:24:37 <svref> dmhouse: yeah
14:24:40 <monochrom> /usr/local/lib has ghc-6.4.2 and ghc-6.6.  They do not interfere with each other.
14:24:57 <dmhouse> svref: well, the problem is that the type of optimizedRunsNow doesn't return its result in a monad.
14:25:01 <svref> I'd already clobbered "map", in one of my many brilliant design decisions.
14:25:03 <monochrom> Thus, I even used the same --prefix for both.
14:25:27 <glguy> OH
14:25:33 <glguy> Map.lookup returns a MonadPLus
14:25:42 <glguy> you need to either do a lookupwith default
14:25:42 <glguy> or
14:25:55 <glguy> return a [[]] or a Maybe []
14:25:56 <dmhouse> MonadPlus?
14:26:01 <dmhouse> ?hoogle lookup
14:26:02 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
14:26:02 <lambdabot> Data.HashTable.lookup :: HashTable key val -> key -> IO (Maybe val)
14:26:02 <lambdabot> Data.IntMap.lookup :: Key -> IntMap a -> Maybe a
14:26:02 <monochrom> Take a look at your current /usr/local/bin and you will see what will be preserved and what will be overwritten.
14:26:06 <glguy> ?type Data.Map.lookup
14:26:07 <svref> dmhouse: how can it take a list of elements, and return them as just a single element?  I don't understand.
14:26:08 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
14:26:17 <nmessenger> svref: head?
14:26:19 <dmhouse> glguy: it does fail on not found.
14:26:28 <dmhouse> nmessenger: not what he means.
14:26:29 <glguy> svref: No, it thinks you want your MonadPLus instance to be []
14:26:44 <dmhouse> svref: it'll give you weird errors because your type doesn't include a monad.
14:26:58 <glguy> svref: try: Dict.lookupWithDefault []
14:27:01 <dmhouse> Basically lookup needs something to do if the key wasn't in the map.
14:27:16 <dmhouse> So it requires that the result type be a monadic type, which supports failure.
14:27:17 <glguy> ?type Data.Map.lookupWithDefault
14:27:18 <lambdabot> Not in scope: `Data.Map.lookupWithDefault'
14:27:29 <glguy> ?type Data.Map.findWithDefault
14:27:31 <lambdabot> forall a k. (Ord k) => a -> k -> Data.Map.Map k a -> a
14:27:34 <glguy> ^^
14:27:47 <dmhouse> That function glguy just pointed you toward allows you to specify a default value for if the key isn't found.
14:28:04 <svref> got it.
14:28:20 <monochrom> @src Data.Map.lookup
14:28:20 <lambdabot> Source not found. Maybe if you used more than just two fingers...
14:28:43 <svref> I've been here 2 months, and I still only kinda grok monads.
14:28:45 <svref> :P
14:28:52 <dmhouse> svref: don't worry. They're not easy. :)
14:29:14 <monochrom> They are easy.
14:29:22 <dmhouse> Once you get them, they're easy.
14:29:25 <glguy> svref: with Data.Map, if you return a Maybe, it will give you 0 or 1 result
14:29:41 <glguy> [] would be more meaningful if Map could return many results
14:29:44 <glguy> (but it doesn't)
14:29:56 <svref> it doesn't!?
14:30:04 <dmhouse> If you want to nail them, my recommendation is to read, in this order: 1) Cale's 'Monads as Containers' article. 2) The Wikibook's 'Understanding Monads' and 'Advanced Monads' chapters, 3) nomaware's 'All About Monads' tutorial.
14:30:05 <nmessenger> glguy: in this case, the type is Map Foo [Bar]
14:30:15 <glguy> nmessenger: fully aware :)
14:30:28 <monochrom> They are difficult if you read all those analogies and intuitions, which make them look like a philosophy.  Well philosophy is difficult.
14:30:48 <kowey> yay! House runs under Parallels
14:31:01 <glguy> nmessenger: the problem is that GHC thought that he was using [] as his monadplus instance to store results
14:31:11 <nmessenger> ah
14:31:13 <dmhouse> glguy: it's got nothing to do with MonadPlus, by the way.
14:31:16 <dmhouse> ?type Data.Map.lookup
14:31:17 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
14:31:26 <dmhouse> ?type fail
14:31:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
14:31:54 <svref> So did someone say Data.Map.findWithDefault on a (Map a [b]) didn't return [b]?
14:32:00 <svref> but rather b?
14:32:06 <glguy> nope
14:32:10 <dmhouse> svref: no, it'll return a [b].
14:32:17 <nmessenger> svref, no, glguy was saying it didn't return [[b]]
14:32:20 <glguy> ?fptools Data.Map
14:32:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
14:32:28 <dmhouse> This is confusing because your value type is a monadic type itself.
14:32:56 <svref> dmhouse: well, it could hardly be otherwise...
14:33:02 <svref> I think
14:33:04 <monochrom> When I first learned set theory I did not notice {{b}} /= {b}
14:33:08 <dmhouse> No, I know, but it's confusing nonetheless. :)
14:33:24 <nmessenger> perhaps a 'type' alias for [(Line,Direction,[(Stop,Time)])].  Any better names?
14:34:20 <monochrom> ListOfLDST
14:35:12 <svref> One thing I truly miss from LISP is the ability to put all kinds of funky symbols into identifiers.
14:35:47 <svref> let ((wombat+/grovel/ 5)) ...
14:35:55 <svref> bound wombat+/grovel/ to 5.
14:36:13 <nmessenger> symbols in name would be cool, but would break a lot of code that doesn't space operators :(
14:36:15 <glguy> I'm glad that Haskell saves us from looking at people's code with wombat+/grovel/
14:36:18 <glguy> as a varname
14:36:48 <glguy> suddenly you wouldn't be able to write:  x+y
14:36:54 <glguy> you'd need to always write: x + y
14:37:03 <svref> its LISP.  Of COURSE you're not able to write x+y!
14:37:13 <glguy> LISP or Lisp?
14:37:21 <glguy> how long ago was it that you used it? :)
14:37:32 <svref> LisP I suppose
14:37:48 <glguy> oh, half way in between? :-D
14:37:53 <dmhouse> I wouldn't mind if there were a restriction on spacing out infix ops.
14:38:06 <dmhouse> Of course, it couldn't be introduced now, but in retrospect it'd be nice.
14:38:44 <glguy> I can see it now: #haskell <newb> Why doesn't "x+y" exist in z = x+y?
14:38:47 <svref> it'd avoid errors with, for example: id 2+2 :: too many arguments
14:39:09 <dmhouse> glguy: it'd be really easy to give sensible errors for that, though.
14:39:14 <sjanssen> > id 2 + 2 -- I don't see a problem here
14:39:15 <lambdabot>  4
14:39:26 <sjanssen> > id 2+2 -- oops
14:39:28 <lambdabot>  4
14:39:31 <svref> I wanted id (2+2)
14:39:36 <glguy> why?
14:39:44 <svref> BECAUSE I DIDN"T PUT IN SPACES!!
14:39:45 <sjanssen> svref: still okay :)
14:39:51 <glguy> > flip id (2+2) succ
14:39:53 <lambdabot>  5
14:39:56 <glguy> > flip id 2+2 succ
14:39:57 <lambdabot>   add an instance declaration for (Num ((a -> a) -> (b -> c) -> c))
14:40:13 <dmhouse> If you found aOPb, which wasn't in scope, then see if OP is in scope. If it is, say 'Maybe you meant a OP b'.
14:40:13 * svref knows his head is full of cheese
14:40:21 <dmhouse> Ta-da! Newbie problems solved.
14:40:40 <glguy> I'd fix my copy of GHC if that happened ;)
14:40:54 <sjanssen> @check \x y -> (id x + y :: Int) == id (x + y)
14:40:56 <lambdabot>  OK, passed 500 tests.
14:41:11 <glguy> if GHC tried to stop me from writing   x^2  , I'd release glguyGHC
14:41:27 <dmhouse> But it'd fix _so_ many problems.
14:41:35 <dmhouse> Suddenly Module.name is unambiguous.
14:41:45 <dmhouse> Suddenly record.field is possible.
14:41:55 <dmhouse> We can use symbols in names.
14:42:09 <glguy> unambiguous to the compiler
14:42:09 <sjanssen> dmhouse: I don't think symbols in names is a good thing
14:42:12 <glguy> but confusing to everyone else
14:42:27 <glguy> a . f.g . h . y . q8t.y
14:42:29 <svref> how do you feel about ' in names?
14:42:37 <Anon4888> I'd like to be able to put spaces in names too
14:42:52 <sjanssen> nobody wants "x+y" to be an identifier
14:42:53 <dmhouse> glguy: in this case, you'd probably know that f and q8t are records, no problems.
14:42:55 <svref> the #1 needed symbol is '-'.  Its the OneTrueStudlyCapsReplacementCharacter
14:43:07 <sjanssen> svref: I'm fine with it, because it looks like mathematical convention
14:43:10 <dmhouse> Yeah, I'd like - to be available.
14:43:12 <glguy> but_that_was_solved
14:43:31 <bos_> ooh, Control.Exceptions is *yummy*.
14:43:31 <svref> underscores look like vomit and require shift.
14:43:36 <sjanssen> - would be an okay separator, but I don't like any of the other operator characters
14:43:44 <fasta> sjanssen: +1 is used often as an identifier in lispy languages.
14:44:00 <glguy> (+1 2)
14:44:11 <fasta> er or 1+
14:44:21 <sjanssen> fasta: I call it succ :)
14:44:23 <svref> an early bug I had in haskell was that (1- 10) was -9 not +9.
14:44:30 <LoganCapaldo> I too like dash in-my-identifiers
14:44:42 <fasta> (define 1+ 'foo)  workds
14:44:50 <glguy> > (1- 10)
14:44:52 <lambdabot>  -9
14:44:56 <dmhouse> I'm remember getting all excited when seeing (1+) and (1-) in Lisp. I thought we had sections.
14:44:59 <glguy> why would you expect that to be 9?
14:45:11 <sjanssen> svref: under what interpretation would (1- 10) be +9?
14:45:13 <svref> glguy: in lisp it just is.
14:45:20 <glguy> ah
14:45:32 <sjanssen> ah, because 1- is the decrement operator?
14:45:35 <Botje> sjanssen: 1- = \x -> x-1
14:45:43 <dmhouse> 1- is a stupid name.
14:45:46 * glguy never did care for any of the Common Lisp naming conventions
14:45:48 <fasta> sjanssen: I usually call it inc and dec.
14:45:59 <svref> yeah.  They started with 1+, then halfway through the laungage some bright boy decided to add 1-, and they figured they had to stay in naming scheme.
14:46:10 <svref> to maintaing back compatibility
14:46:18 <kpreid> they had to because -1 would be a number, not a symbol
14:46:29 <nmessenger> inc and dec imply destructive update to me.  succ and pred imply definition.
14:46:45 <Anon4888> In an IDE you can just use underscore to input a separation character, and then leave the formatting configurable.  Ids could be rendered in camelCase or with-dashes...
14:46:47 <kpreid> nmessenger: Common Lisp agrees with you
14:47:13 <mauke> incf, you mean
14:47:29 <kpreid> well, yes, but if CL had inc it would still agree with him
14:47:58 <glguy> I like Scheme's ! convention
14:48:17 <fasta> How about construct_new_number_incrementing?
14:48:19 * fasta ducks
14:48:25 <glguy> unsafeInc
14:48:25 <svref> haskell pretty much keeps that convention, since its so side-effect free.
14:48:42 <sjanssen> anyway, Haskell tends to follow mathematical convention for expressions and sep-like-this is contrary to that convention
14:48:53 <mauke> IORef Int -> ()
14:49:04 <nmessenger> inc = modifyIORef succ
14:49:11 <nmessenger> ;P
14:49:24 <mauke> unsafePerformIO plz
14:49:28 <svref> math is not the best way to represent code.
14:49:37 <glguy> neither is Lisp ;)
14:49:41 <dmhouse> mauke: -> IO (), unless you meant IORef as a restricted comonadic IO.
14:49:59 <nmessenger> svref, I'd wager the overall opinion in this channel disagrees.
14:50:17 <mauke> glguy wanted unsafeInc
14:50:24 <dmhouse> Oh, right.
14:50:44 <glguy> I just meant that Lisp should use the unsafe convention for destructive functions ;)
14:50:52 <dmhouse> nmessenger: we're only talking naming conventions here. if hyphen-seps are clearer, they should be allowed.
14:51:10 <nmessenger> oh, nevermind then
14:51:19 <sjanssen> dmhouse: if we allow hyphen-seps, do we allow plus+seps?
14:51:21 <svref> I agree, lisp should.  Instead, it sometimes tacks on an "n" prefix to destructive function names.
14:51:25 <fasta> I like hyphens more
14:51:41 <glguy> glguyPrefersCamelcase :)
14:51:57 <sjanssen> and if we don't allow plus+seps, is x+y a valid expression?
14:51:57 * nmessenger thinks Lisp should look like Lisp and Haskell like Haskell
14:52:03 <sjanssen> is x - y?
14:52:04 <fasta> iDontLikeThatTheStandardLibrariesHaveCamelCase
14:52:29 <glguy> you-should-alias-your-functions
14:52:41 <monochrom> why is it called Camel case?
14:52:50 <nmessenger> humps in the middle ;)
14:52:56 <monochrom> darn
14:52:59 <glguy> I_would-be^likely-to_write-things^like-this
14:53:06 <monochrom> ^_^
14:53:15 <svref> Lisp also let you use anything at all in identifiers swandwiched with ||s.  E.g. (setf |2+2| 5)
14:53:23 <sjanssen> I don't see any consistent formulation that both allows hypen-seps and disallows plus+seps
14:53:49 * LoganCapaldo was thinking about making ' delimit identifier strings
14:53:54 <monochrom> Just use -- if you mean +
14:54:07 <int-e> you'mean'like'this'question'mark
14:54:07 <svref> sjanssen, since - is already brain damaged by the unary minus, maybe worth making it a special case.
14:54:11 <glguy> a`long`library`function`name
14:54:14 <LoganCapaldo> 'an identifier with no need for underscores or hyphes' = 3
14:54:42 <Saizan> but - is already overloaded for unary minus, do we want more ambiguation?
14:54:42 <nmessenger> gah!  But the confusion with Char literals!
14:54:51 <sjanssen> svref: it's such a small gain for the break in backwards compatibility
14:54:54 <Saizan> ops
14:55:00 <svref> true.
14:55:13 <LoganCapaldo> nmessenger, yeah well I wasn't thinking of Haskell at the time I came up with this "brilliant" idea
14:55:18 <sjanssen> especially since the entire body of Haskell code uses camelCase
14:55:25 <glguy> peole should stick with single letter var names ;)
14:55:30 <dmhouse> How about allowing symbols at the end of identifiers, so we get predicate?
14:55:35 <glguy> x y z were good enough for Jesus, they are good enough for you
14:55:51 <dmhouse> map even? [1..10], etc.
14:55:54 <nmessenger> y a s, a y, g?
14:55:59 <monochrom> I thought Jesus used α and ω
14:56:04 <nmessenger> (you aren't serious, are you, glguy?)
14:56:07 <glguy> nope, x y and z...
14:56:18 <sjanssen> dmhouse: still backwards incompatible
14:56:31 <monochrom> I did read the Revelations and he did use α and ω ...
14:56:33 <glguy> monochrom: common misconception ;)
14:57:09 <dmhouse> sjanssen: true, although I do wonder how many people are implementing an '?' operator and using it without seperation.
14:57:15 <LoganCapaldo> Well if x and y are S and K that leaves z for anything the programmer wants
14:57:21 <LoganCapaldo> its perfect
14:57:25 <dmhouse> Meh, it wouldn't be that good, isEven is good enough.
14:57:30 <sjanssen> dmhouse: I thought you meant any operator as a suffix
14:57:42 <dmhouse> sjanssen: I was toying with that, but maybe not.
14:58:02 <dmhouse> I like it in Ruby because of the parallel with ! to indicate side effects, but of course you wouldn't need that in Haskell.
14:58:18 <nmessenger> LoganCapaldo, but 'ap' and 'const' are already S and K :P
14:58:23 <glguy> unicode–solution
14:58:43 <LoganCapaldo> nmessenger, I thought he wanted _only_ x y z
14:58:49 <dmhouse> glguy: is ideal, yeah.
14:58:50 <LoganCapaldo> Things in the stdlib are exempt?
14:58:54 <sjanssen> dmhouse: I guarantee there are plenty of (x:) in Haskell code
14:59:16 <dmhouse> glguy: especially as we then have loads of choices for a replacement for (.)
14:59:20 * sjanssen wants all of the characters he types to be keys on his keyboard
14:59:20 <dmhouse> sjanssen: hrm, true.
14:59:22 <nmessenger> we *could* forego names entirely and work in the SKI calculus.
14:59:36 <monochrom> > let 5 ^_^ 6 = 10 = 5 ^_^ 6
14:59:36 <lambdabot>  Parse error in pattern
14:59:41 <monochrom> Oh!
14:59:44 <glguy> we could skip writing programs and just start writing answers
15:00:02 <nmessenger> is '_' not a symbol character?
15:00:02 <glguy> even¿
15:00:08 <sjanssen> nmessenger: nope
15:00:22 <monochrom> > let 5 ^_^ 6 = 10 in 5 ^_^ 6
15:00:22 <lambdabot>  Parse error in pattern
15:00:26 <nmessenger> > let 5 ^.^ 6 = 10 in 5 ^.^ 6
15:00:27 <lambdabot>  10
15:00:29 <sjanssen> erm, _ is not a symbol character, if you found my statement to be ambiguous
15:00:44 <dmhouse> nmessenger: no, it's used for the wildcard pattern.
15:01:04 <nmessenger> I know, I just wondered if it could also work in symbol names
15:01:30 <LoganCapaldo> Is this being mean to Haskell: f a@_ = a + 1 ?
15:01:47 <monochrom> > let morse_code__ _ _ __ = 10 in morse_code__ 1 2 3
15:01:48 <lambdabot>  10
15:01:52 <monochrom> hee hee hee!
15:01:59 <nmessenger> LoganCapaldo, no, it's being mean to maintanance programmers :D
15:02:04 <monochrom> Err I mean hee he he hee!
15:02:12 <dmhouse> > let f a@_ = a + 1 in f 10
15:02:13 <lambdabot>  11
15:02:22 <dmhouse> nmessenger: it's not that bad if you actually think about it.
15:02:37 <dmhouse> Anyway, time for bed.
15:02:42 <Cale> Why would you not simply write that as  f a = a + 1  ?
15:02:47 <nmessenger> dmhouse, that's the key, though, forcing unneccessary thought. :P
15:02:50 <Cale> It means the same thing.
15:02:53 <monochrom> because we're mean
15:03:36 <nmessenger> the channel recieved an IOError oh noes!
15:03:51 <Cale> > let f a@(b@_) = a + b in f 5
15:03:52 <lambdabot>  10
15:04:06 <monochrom> It's fun to be mean
15:04:30 * resiak doesn't get why a@_ is mean...
15:04:43 <Cale> > let f ~a@(~b@(~_)) = a + b in f 5
15:04:44 <lambdabot>  10
15:04:51 <nmessenger> resiak: a@_ is equivalent to the notationally simpler a
15:05:19 <Cale> It's starting to look like a bad Japanese-style smiley.
15:05:20 <monochrom> When you are truly mean, you don't know that you're mean.
15:05:32 <nmessenger> tildes, at-patterns, and wildcards, oh my!
15:05:34 <monochrom> @_@
15:05:34 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
15:05:40 <resiak> nmessenger: yeah, I know what it means, but ... it's fairly transparent :)
15:05:53 <LoganCapaldo> What I was really wondering is ifthe use of _ forced the unecessary execution of the "pattern matching code path"
15:05:58 <nmessenger> 'fairly' :P
15:06:26 <nmessenger> LoganCapaldo, you might want seq or GHC's ! patterns
15:06:41 <LoganCapaldo> nmessenger, no no :)
15:06:42 <Cale> LoganCapaldo: I would be pretty surprised if  f a@_ = ... produced different code from f a = ...
15:06:52 <monochrom> f _ = ... and f a = ...  are very similar
15:06:57 <LoganCapaldo> I'm talking about inside the compiler
15:07:02 <LoganCapaldo> Cale, I agree
15:07:03 <nmessenger> the second just introduces a name
15:07:20 <LoganCapaldo> but sometimes things are surprising :)
15:07:32 <monochrom> I don't know about "unnecessary".  But slightly different path yes.
15:08:22 <LoganCapaldo> Why the explicit type anonatation in the topic?
15:09:17 <nmessenger> I suppose one could restrict pattern matching so the the *only* binding could be by @-patterns and the *only* wildcard matching is done by _
15:09:19 <LoganCapaldo> @. eval topic
15:09:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "topic"
15:09:21 <psnl> are people trolling on edwinb's blog?
15:09:26 <edwinb> no
15:09:35 <edwinb> hth ;)
15:10:00 <LoganCapaldo> @topic
15:10:00 <lambdabot> Maybe you meant: topic-cons topic-init topic-null topic-snoc topic-tail topic-tell join todo type
15:10:22 <LoganCapaldo> @topic-tell
15:10:22 <lambdabot> Do not know that channel
15:10:35 <nmessenger> @topic-tell #haskell
15:10:35 <lambdabot> ["The Haskell programming language: get yourself some cognitive dissonance!","http://haskell.org","Hac 07 Haskell Hackathon, 10-12 Jan, http://haskell.org/haskellwiki/Hac_2007","Logs: http://tunes.
15:10:35 <lambdabot> org/~nef/logs/haskell/","The language of ICFP winners 3 years running"] :: [String]
15:10:58 <LoganCapaldo> @. eval (topic-tell #haskell)
15:10:58 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "(topic-tell"
15:11:04 <resiak> nmessenger: point.
15:11:14 <LoganCapaldo> :(
15:11:14 <nmessenger> resiak, click
15:11:53 <LoganCapaldo> @$ eval topic-tell #haskell
15:11:53 <lambdabot> Maybe you meant: . v
15:12:00 <resiak> nmessenger: Esc Esc Esc Esc THAT WAS THE WRONG BUTTON!
15:12:03 <LoganCapaldo> I surrender
15:13:50 <psnl> for the record and logs, edwinb doesn't have a blog, anf if he had one he would post about the death of his cat and not his research
15:14:49 <nmessenger> @. eval topic-tell #haskell
15:15:14 <Saizan> ?bot
15:15:14 <lambdabot> :)
15:15:27 <monochrom> @snack
15:15:28 <lambdabot> Unknown command, try @list
15:15:33 <monochrom> @bo
15:15:33 <lambdabot> :)
15:15:36 <monochrom> @b
15:15:36 <lambdabot> Maybe you meant: b52s babel bf botsnack brain bug . v
15:15:44 <monochrom> Ah!
15:16:30 <nmessenger> @help eval
15:16:30 <lambdabot> eval. Do nothing (perversely)
15:16:34 <nmessenger> :>
15:16:38 <nmessenger> @help run
15:16:38 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
15:18:17 <LoganCapaldo> @. run topic-tell #haskell
15:18:18 <lambdabot>  ["The Haskell programming language: get yourself some cognitive dissonance!"...
15:18:29 <LoganCapaldo> Victory!
15:19:46 <LoganCapaldo> @. type topic-tell #haskell
15:19:47 <lambdabot> [String] :: [String]
15:19:56 <LoganCapaldo> woot
15:20:10 <LoganCapaldo> @botsnack
15:20:11 <lambdabot> :)
15:20:41 <nmessenger> @vixen Thanks for always being so helpful, LB.
15:20:41 <lambdabot> <undefined>
15:21:42 <sorear> tell fodder
15:22:16 <mbishop> When I grow up, I wanna troll reddit like grauenwolf
15:24:27 <sorear> @users
15:24:27 <lambdabot> Maximum users seen in #haskell: 311, currently: 290 (93.2%), active: 39 (13.4%)
15:30:58 <psnl> mbishop: whats the story with grauenwolf?
15:31:23 * mbishop shrugs
15:31:47 <mbishop> disgruntled kid? bitter old systems administator? who knows
15:31:51 <mbishop> -5 points 6 days ago by grauenwolf
15:31:51 <mbishop> Are they serious or is this just a collection of toys like those from Microsoft Research?
15:31:54 <mbishop> heh
15:31:57 <mbishop> that made me laugh
15:32:09 <psnl> just a troll, or is there some decent backstory from which we can infer child abuse or devil worship?
15:32:43 <sorear> obviously he needs to be forcibly converted to spjism
15:33:31 * psnl notes "spjism" for the next census
15:34:16 * bos_ misread that horribly
15:34:29 <psnl> yeah, same
15:36:16 <yaxu> i'm having problems installing shell-pipe, a dependency of haskore
15:37:04 <yaxu> darcs get http://darcs.haskell.org/shell-pipe/ is giving me a 404 on the second file
15:37:06 <lambdabot> Title: Index of /shell-pipe
15:37:35 <sorear> yaxu: try --partial
15:37:57 <sorear> (it should not work, but it could with a suitibly misconfigured repository)
15:38:26 * sorear looks at the site...
15:39:10 <sorear> yaxu: did you get a 404 or a 403?
15:39:35 <yaxu> curl says "404?" but when I look with a browser it's a 403
15:39:42 <yaxu> so i guess curl is guessing wrong...
15:39:52 <sorear> well same problem here
15:40:28 <sorear> and --partial won't help with this flavor of brokenness...
15:40:31 <yaxu> the darcs file thinks it's at /shell/ rather than /shell-pipe/ too, i guess it's in transition or something
15:40:52 <yaxu> i don't think it's an important dependency, i'll try doing without it
15:40:55 <yaxu> thanks
15:41:21 <yaxu> will see if i can find someone to email too
15:41:44 <sorear> In my browser I get a webmaster link
15:42:03 <sorear> weirdly enough it matches .*cvs.*
15:52:06 <ihope> Well, a natural number datatype isn't quite as nice-looking in Epigram as it is in Haskell, is it?
15:52:51 <edwinb> hmm, in what way?
15:53:15 <ihope> Well, for one, it takes up three lines.
15:53:30 <ihope> Well, maybe it could be put on one line.
15:53:39 * ihope seems to like the word "well" today
15:53:49 <edwinb> ah, I agree with you there
15:53:57 <mbishop> help I fell down a well!
15:54:06 <edwinb> I think the syntax looks nice in latex but a bit weird in ascii
15:54:16 <ihope> Yeah, I guess it works on one line.
15:54:25 <psnl> edwinb: you should code in latex
15:54:28 * psnl runs
15:55:01 <ihope> data (---; Nat : *) where (---; zero : Nat); (x : Nat; ---; succ x : Nat)
15:55:20 <sorear> data Nat where
15:55:24 <sorear>    Zero :: Nat
15:55:26 <edwinb> I'd prefer to see something like: data Nat:* where zero:Nat | suc:Nat
15:55:38 <sorear>    Succ :: Nat -> Nat
15:55:41 <edwinb> and even that, for a simple type, could easily be data Nat = zero | suc Nat
15:55:50 <edwinb> (um, I mean suc:(k:Nat)->Nat)
15:56:02 <sorear> oh interesting, GADTs are like pointfree epigram decls...
15:56:35 <ihope> Yeah, they are...
15:56:47 <edwinb> A lot of people seem to find the epigram natural deduction style data declarations off putting
15:57:18 <ihope> Makes me want to write that Vec datatype in Haskell.
15:57:30 <ihope> Vec :: Nat -> * -> *
15:57:43 <Philippa> yeah, if you're not used to natural deduction then they are
15:58:06 <Philippa> much as haskell datatypes are offputting to some C coders
15:58:26 <ihope> Does that mean Epigram is better than Haskell which is better than C?
15:58:41 <edwinb> data Vec:Nat->*->* = nil:Vec A zero | cons:A -> Vec A k -> Vec A (suc k)
15:58:46 <edwinb> would be a better epigram syntax, I think
15:59:01 <edwinb> however, they have more important things to worry about than syntax at the minute
15:59:10 <edwinb> even if it's the syntax that puts people off in the end...
15:59:20 <ihope> What's one of the more important things?
15:59:21 <emk> What's the best way to get a working copy of "cabal-install"? It appears to be in the Cabal repository, but isn't shipped with GHC 6.6.
15:59:28 <edwinb> ihope: making it work at all ;)
15:59:41 <ihope> I take it it currently doesn't...
15:59:52 <psnl> edwinb: talking about epigram 2?
16:00:10 <ihope> What is Epigram 2, exactly?
16:00:11 <edwinb> I don't know the current state, haven't looked for a while. Epigram 1 (the emacs version) was a prototype proof-of-concept kind of thing
16:00:13 <emk> Would it be reasonably sane to just pull the latest Cabal from Darcs and install it over GHC 6.6's?
16:00:31 <edwinb> Epigram 2 is a more serious effort, but it's a huge task
16:00:55 <ihope> I guess I have plain old Epigram. Is Epigram 2 usable in any way?
16:00:55 <edwinb> I must catch up with how they're getting on...
16:01:13 <psnl> edwinb: oh god, you aren't looking for warm bodies to do work on it then
16:01:19 <psnl> s/god/good/
16:01:24 <edwinb> psnl: not me, no...
16:01:34 <liyang> What's OLEG then?
16:01:39 <ihope> You know, "oh god" and "oh good" certainly are different...
16:02:20 <psnl> edwinb: I'm having spazzes due to my idea for a thesis topic, but thats another story
16:03:23 <edwinb> We're more looking for warm bodies to do PhDs in the resource bounded functional programming kind of area...
16:04:07 <sorear> oh so if I keep trying to solve that problem I might not have trouble with a PhD topic? :)
16:04:34 <ihope> What is a PhD, exactly?
16:05:16 <psnl> ihope: a way of mapping three years of your life to three letters after youe name
16:05:56 <ihope> Seems it'd be more efficient just to change one's last name to have "PhD" at the end of it.
16:05:57 <allbery_b> <cynic type=academentia> a union card for tenure </cynic>
16:06:58 <tuukkah> the best peer-reviewed reference: http://www.phdcomics.com/
16:06:58 <lambdabot> Title: Piled Higher and Deeper
16:07:04 <edwinb> hehe
16:07:51 <psnl> hum, I feel worried now
16:09:09 <erider> > sin (-10)
16:09:11 <lambdabot>  0.5440211108893698
16:09:31 <micahcowan> > acos (-1)
16:09:32 <lambdabot>  3.141592653589793
16:09:41 <mauke> mmh, pi
16:09:55 <ihope> You know, many of these thingies are probably unnecessary.
16:10:09 <ihope> How do I put something back into a shed?
16:10:34 <edwinb> undo until the bit where you put it in...
16:10:42 <edwinb> er, where you elaborated
16:10:46 <edwinb> sadly, there is no better way
16:10:47 <sorear> > pi
16:10:48 <lambdabot>  3.141592653589793
16:11:19 <ihope> There isn't?
16:11:23 <mauke> > pi - acos (-1)
16:11:24 <lambdabot>  0.0
16:11:52 <tuukkah> now someone give pi in infinite precision :-)
16:12:22 <edwinb> see what I mean about prototype ;)
16:13:09 <erider> > pi - sin (-10)
16:13:10 <lambdabot>  2.5975715427004236
16:13:43 <ihope> tuukkah: 3.1415926535... uh, lemme get back to you on that one
16:15:07 <tuukkah> ihope, i perceive laziness :-)
16:15:49 <ihope> tuukkah: what, you have more digits memorized?
16:16:09 <tuukkah> no, same as lambdabot, always resorting to an ellipsis
16:16:18 <ihope> Oh.
16:16:25 <mbishop> I can only remember up to 3.14159
16:16:29 <monochrom> "An Unbounded Spigot Algorithm for the Digits of Pi" http://web.comlab.ox.ac.uk/oucl/work/jeremy.gibbons/publications/spigot.pdf
16:16:42 <monochrom> I found it on LTU: http://lambda-the-ultimate.org/classic/functional.html
16:16:51 <lambdabot> Title: Lambda the Ultimate functional
16:17:59 * ihope copies the *Epigram* buffer into *scratch* and puts a shed around it
16:18:35 <ClaudiusMaximus> :t get
16:18:36 <lambdabot> forall s (m :: * -> *). (MonadState s m) => m s
16:19:12 <ihope> ...Wow, I think it worked.
16:19:40 <edwinb> ihope: actually there are shortcuts for that ;)
16:19:43 <ihope> Wait, shed within a shed?
16:19:51 <ihope> edwinb: now you tell me? :-P
16:19:52 <edwinb> copying buffer into a new buffer
16:20:00 * edwinb tries to remember what they are
16:20:01 <tuukkah> > let g(q,r,t,k,n,l) = if 4*q+r-t<n*t then n : g(10*q,10*(r-n*t),t,k,div(10*(3*q+r))t-10*n,l) else g(q*k,(2*q+r)*l,t*l,k+1,div(q*(7*k+2)+r*l)(t*l),l+2) in g(1,0,1,1,3,3)
16:20:03 <lambdabot>  [3,1,4,1,5,9,2,6,5,3,5,8,9,7,9,3,2,3,8,4,6,2,6,4,3,3,8,3,2,7,9,5,0,2,8,8,4,1...
16:20:12 <edwinb> then another one to copy a buffer into an open shed
16:20:15 <edwinb> I think C-c c and C-c e
16:20:30 <edwinb> ihope: well it's not quite the same as local undo...
16:20:33 <tuukkah> not bad at all, thanks monochrom !-)
16:20:35 <monochrom> Wow tuukkah is fast :)
16:20:35 <edwinb> but it can be good enough
16:26:03 <lisppaste2> ClaudiusMaximus annotated #35479 with "i solved my xml problem" at http://paste.lisp.org/display/35479#1
16:27:48 <sorear> @users
16:27:48 <lambdabot> Maximum users seen in #haskell: 311, currently: 287 (92.3%), active: 36 (12.5%)
16:30:24 <complaisant> how can i communicate through a network with haskell ?
16:31:55 <tuukkah> do you mean to implement a tcp/ip networking application, or a remote connection to ghci, or something like that?
16:33:01 <sorear> ?docs Network
16:33:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
16:33:12 <sorear> ?where lambdabot -- good example
16:33:13 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:33:40 <complaisant> wow nice :D
16:38:43 <newsham> example with commentary: http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
16:38:44 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
16:39:09 * sorear feels silly
16:39:26 <sorear> I was about to comment that lambdabot was plenty concurrent
16:39:39 <sorear> and you of all people should know that!
16:39:54 <sorear> but "concurrency" /= "commentary" :)
16:40:32 <newsham> haskell needs a good idea:  http://sofia.fhda.edu/gallery/java/unit12/idlg.gif
16:40:37 <mauke> don't worry, "concurrency" == "commentary" in Perl
16:40:46 <newsham> IDE
16:40:48 <newsham> not idea.
16:41:01 <sorear> mauke: thank you.
16:41:18 <sorear> mauke: I was doing *such* a good job at forgetting that.
16:42:19 <mauke> for you, there's always use warnings FATAL => 'all'; :-)
16:43:07 <allbery_b> but you haven't had fun until you encounter "nancy typing" :)
16:43:24 <sorear> c?
16:43:52 <sorear> nan*c*y - typo ?
16:44:16 <allbery_b> no.  it's a "refinement" on the comparing-strngs-with-== thing:  certan strings used to be recognized as "numbers"
16:44:22 <allbery_b> google for "nancy typing"
16:46:40 <mauke> nice.
16:46:52 <mauke> that's why you always use warnings; in Perl
17:01:41 <ihope> Mmh.
17:01:55 <ihope> The Epigram editor doesn't seem to have a way to put a shed around something.
17:02:00 <ihope> And that something is still in a shed.
17:03:35 <stepcut> what color ?
17:03:54 <stepcut> nm.
17:04:36 * allbery_b has been thinking that every time sheds get mentioned :)
17:04:53 <stepcut> :p
17:05:40 <SamB> allbery_b: including bikesheds?
17:05:55 <allbery_b> perzactly
17:06:17 <allbery_b> (but I meant within the past hour or so in this channel, specifically...)
17:15:36 <Anon4888> @src not
17:15:36 <lambdabot> not True   =  False
17:15:36 <lambdabot> not False  =  True
17:22:04 <sorear> mauke: (reading through the logs) you reinvented de Bruijn numbering
17:27:15 <ClaudiusMaximus> ?hoogle String -> String -> FilePath
17:27:16 <lambdabot> Distribution.Compat.FilePath.joinFileExt :: String -> String -> FilePath
17:27:16 <lambdabot> Distribution.Compat.FilePath.joinFileName :: String -> String -> FilePath
17:27:56 <ClaudiusMaximus> ?docs Distribution.Compat.FilePath
17:27:56 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/Cabal/Distribution-Compat-FilePath.html
17:29:24 <Cale> Man, there's a certain irony in trying to talk about software correctness, and being repeatedly bitten by bugs in the software one is trying to use to communicate.
17:30:39 <newsham> ?babel fr en rouge
17:30:40 <lambdabot>   red
17:30:46 <newsham> ?babel en fr red
17:30:48 <lambdabot>   rouge
17:30:56 <sorear> ?src babel
17:30:57 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:30:57 <newsham> it works at first, but after a while it stops working
17:31:09 <newsham> ?babel fr end a la mode
17:31:10 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language end not supported
17:31:14 <newsham> ?babel fr en rouge
17:31:15 <lambdabot>   red
17:31:21 <newsham> hrmm...
17:31:35 <newsham> odd failure modes.. on my bot its failing even for fr en rouge now
17:31:37 <sorear> newsham: maybe it's a function of "is babelfish.altivista up?"
17:31:58 <allbery_b> and/or does it do rate limiting?
17:31:59 <sorear> Babel has () state...
17:32:06 <newsham> sorear: i think its more ocmplex than that
17:32:13 <sorear> newsham: what is the failure mode?
17:32:15 <newsham> ?babel en fr red
17:32:16 <lambdabot>   rouge
17:32:27 <newsham> ?babel fr end a la mode
17:32:27 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language end not supported
17:32:30 <newsham> ?babel fr en a la mode
17:32:31 <lambdabot>   the fashion has
17:32:42 <newsham> hrmm.. its working fine now.. but it will not be working in 30min.
17:33:06 <newsham> i think it might be something like the first time you use it after lambdabot starts it works until the connection times out, then it fails...
17:33:20 <monochrom> Interesting
17:33:49 <sorear> but ... Babel.hs is stateless ... it can't cache connections
17:33:58 <allbery_b> someone was trying to use it yesterday, I think, and @babel en fr red didn't work but @babel fr en rouge did
17:34:17 <newsham> sorear: hrm.. i dont really know.. i havent looked at src.. i just know it works sometimes and not others
17:34:22 <allbery_b> wouldn't be a cached connection in that case because the succeesful one followed the failing one by a minute or so
17:34:26 <newsham> and sometimes its workign fine on one bot and not another (at the same time)
17:34:44 <sorear> what is the error?
17:34:49 <allbery_b> (also wouldn't be rate limiting since it had been idle before that)
17:34:50 <sorear> pattern matching?
17:34:52 <newsham> [15:27] <@nul-2845> ?babel fr en rouge
17:34:54 <newsham> [15:27] < noBotE> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:35:14 <sorear> hmm
17:35:16 <allbery_b> yeh, that was the one I saw
17:35:20 <newsham> ?babel en fr black
17:35:21 <lambdabot>   noir
17:35:53 <sorear> while sleep 300 ; do echo -e 'GET blah blah\nblah blah blah' | nc babelfish.altavista.com 80 ; done
17:36:35 <sorear> watch --d=cumulative bash -c "echo -e 'GET blah blah\nblah blah blah' | nc babelfish.altavista.com 80"
17:38:45 <newsham> ?babel en fr orage
17:38:46 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:38:50 <newsham> ?babel en fr red
17:38:51 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:38:54 <newsham> doot dee doo
17:39:10 <newsham> maybe its a DNS round-robin thing..
17:39:26 <sorear> ?babel en fr red
17:39:27 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:39:28 <sorear> ?babel en fr red
17:39:28 <newsham> or some other weird load-balancing thing on their end
17:39:29 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:39:29 <sorear> ?babel en fr red
17:39:30 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:39:48 <sorear> http://babelfish.altavista.com
17:39:49 <lambdabot> Title: AltaVista - Babel Fish Translation
17:39:51 <sorear> ?babel en fr red
17:39:51 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
17:40:18 <allbery_b> ...except this follows a legtimately failed lookup.  transient state in the plugin that's confused now?
17:41:07 <tuukkah> newsham, did you use microsoft visual studio as an example of a good ide or a bad ide?
17:41:15 <newsham> does readPage do connection keepalive?
17:41:23 <sorear> newsham: babelfish doesn't have a roundrobin
17:41:24 <newsham> tuukkah: did you see the picture?
17:42:24 <tuukkah> yes, it seemed to have a lot of features crammed in a bad user interface
17:43:10 * allbery_b "liked" how the source editng subwindow was almost the smallest thing in the window
17:43:21 <newsham> hmm.. readPage makes a new connection each time..
17:44:11 <tuukkah> allbery_b, here it looks slightly larger: http://www.haskell.org/visualhaskell/screen1.png
17:44:55 <newsham> tuukah: yah, mostly making fun of the IDE.
17:45:38 <ClaudiusMaximus> is there a standard function to sanitize arbitrary strings before turning them into filenames?  (inconvenient characters include  "/:*&|" ++ more)
17:46:16 <mauke> how is : inconvenient?
17:46:27 <newsham> claudius: if you want to restrict the alloweable characters a better approach to filtering out bad characters (blacklisting) is to filter to allow only good characters (whitelisting)
17:46:29 <allbery_b> unsafe on windows and mac os 9
17:46:33 <tuukkah> in theory '/' is the only problematic
17:46:34 <newsham> since you are less likely to make a mistake.
17:46:34 <allbery_b> (and vms)
17:46:42 <newsham> tuuk: depends on the filesystem.
17:46:47 <mauke> tuukkah: and '\0'
17:46:52 <newsham> and colon... and ....
17:47:23 <tuukkah> well if you think outside posix, '\\' should come first in the list :-)
17:47:29 <jcreigh> ClaudiusMaximus: Not that I know of.
17:47:34 <newsham> and "com" and "lpt" and ...
17:48:01 <ClaudiusMaximus> tuukkah: i was bitten by '/'; newsham: indeed true, thanks for the reminder
17:48:13 <allbery_b> (hm, does Windows still recognize those even with extesions?)
17:49:20 <Anon4888> Are there any Haskell mods that merge typeclasses and types?
17:49:30 <tuukkah> mauke, i wonder what posix says about '\0'...
17:49:31 <newsham> my winbox has a bunch: c, d:, aux, com6, pipe, etc..  bound into the "GLOBAL??" namespace (see winobj tool)
17:49:43 <sorear> tuukkah:  the ghc simplifier?
17:49:49 <Anon4888> (that unify typeclasses & types into a single concept)?
17:50:06 <newsham> tuuk: probably something along the lines of "dont" :)
17:50:23 <allbery_b> POSIX assumes C strings, so \0 can't occur
17:50:31 <bd_> tuukkah: \0 is end-of-string, so \0 will truncate the file path
17:51:00 <tuukkah> only in these boring c strings =)
17:51:03 <sorear> replicate PATH_MAX 'x' is unsafe on POSIX
17:51:33 <tuukkah> sorear, i'm not following, what do you refer to with the ghc simplifier?
17:51:34 <newsham> tuuk: right, but since the posix APIs take in C strings, any characters that might exist in your strings past the NUL are just an illusion in your language ;-)
17:52:01 <augustss> howdy
17:52:02 * allbery_b doesn't recall if POSIX specifies a path component maximum; most modernish Unixen use 255
17:52:03 <sorear> tuukkah: the dictionary transform, which turns typeclasses into types.
17:52:06 <newsham> (and wont be copied into kernel space when parsing the args)
17:52:38 <sorear> I suppose it's actually part of the desugarer.
17:52:49 * sorear hasn't studied the ghc code yet
17:53:36 <tuukkah> sorear, that was Anon4888 asking :-)
17:53:36 <augustss> sorear: it's done partly in the type checker, I believe
17:53:44 <master_bater> allbery_b i think posix says the maximum should be at least 255
17:54:41 <allbery_b> that would surprise me since when POSIX came out there were still System V Release 3 systems around which claimed POSIX compatibility, with the old 14-character maximum
17:54:54 <master_bater> interesting
17:55:01 <sorear> PATH_MAX is for the whole name iirc
17:55:05 <allbery_b> yep
17:55:44 <sorear> even /usr/man/man1/lprm.1 is longer than 14 chars :)
17:55:51 <allbery_b> no, component
17:55:56 <allbery_b> the part between slashes
17:56:02 <sgillesp1e> hey guys
17:56:07 <sorear> hey!
17:56:12 <sgillesp1e> I'm trying to get the command line arguments
17:56:21 <sorear> ?hoogle getArgs
17:56:22 <lambdabot> System.getArgs :: IO [String]
17:56:24 <sgillesp1e> I've seen that getArg would seem to do it
17:56:30 <allbery_b> (in the old unix filesystem, directory entries were 2-byte inumber, 14-byte name)
17:56:30 <sgillesp1e> okay, gotcha
17:56:31 <sgillesp1e> thanks
17:56:36 <emu> do args <- getArgs ; ...
17:56:46 <sorear> getArgs >>= \ a -> foo
17:57:04 <emu> fooey
17:57:15 <sgillesp1e> is it possible to get args from a ghci session?
17:57:20 <sorear> yes
17:57:27 <sgillesp1e> how is that?
17:57:29 <sorear> :m + System.Environment
17:57:32 <sorear> getArgs
17:57:54 <sorear> or did you mean *set* args?
17:57:58 <sgillesp1e> no get
17:58:37 <allbery_b> ah, NAME_MAX
17:59:04 <sgillesp1e> Prelude System.Environment> getArgs
17:59:04 <sgillesp1e> []
17:59:14 <sorear> so is NAME_MAX the one that is 14 on SysV?
17:59:20 <sorear> sgillesp1e: that's correct
17:59:24 <allbery_b> yes
17:59:30 <sgillesp1e> but i ran ghci rarara
17:59:40 <sgillesp1e> but its giving me an empty list
17:59:45 <sorear> ghci is parsing rarara as a file name
17:59:49 <sorear> :?
17:59:53 <sgillesp1e> oh
17:59:55 <allbery_b> (SVR3 and earlier; SVR4 imported the BSD FFS)
18:00:13 <sorear> :set args "foo
18:00:15 <sorear> :set args foo
18:01:23 <sgillesp1e> even if i do
18:01:26 <br1> the espresion problem is named after math expresions?
18:01:38 <sgillesp1e> ghci -fglasgow-exts
18:01:40 <sgillesp1e> i get []
18:01:59 <sorear> uh, arguments aren't a glasgow ext :)
18:02:27 <sorear> do you maybe want runhaskell ?
18:02:54 <sgillesp1e> but shouldn't -fglasgow-exts be a program argument?
18:03:14 <Igloo> To ghci, not to your program
18:03:17 <sorear> it's an argument to ghci, not the program running in ghci
18:03:26 <tuukkah> Prelude> :set args foo bar
18:03:26 <tuukkah> Prelude> System.Environment.getArgs
18:03:26 <tuukkah> ["foo","bar"]
18:03:41 <sgillesp1e> I see
18:04:29 <sgillesp1e> so now lets say....normally arguments would look like "<script> -f foo -b bar"
18:04:54 <sgillesp1e> would i put :set args -f foo -b bar
18:05:19 <sorear> runhaskell MyScript.hs -f foo -b bar
18:05:22 <tuukkah> to get started with the ghc integration of an ide: "Visual Haskell is available in both source and binary form under BSD like license."
18:05:37 <tuukkah> now *where* is the code available?
18:05:41 <sgillesp1e> I'm trying to simulate normal command line arguments with ghci
18:05:53 <sorear> yow, how'd they get the vs redist licence :)
18:06:11 <beschmi> http://darcs.haskell.org/vshaskell
18:06:12 <lambdabot> Title: Index of /vshaskell
18:06:25 <sgillesp1e> that way i don't have to use print statements to debug/figure out what i'm doing
18:07:08 <tuukkah> thanks beschmi!
18:07:15 <beschmi> but "-- Copyright    : (c) Microsoft Corporation, All Rights Reserved" in most of the files doesn't look like BSD license to me
18:07:25 <beschmi> tuukkah: where is the quote from?
18:07:36 <sgillesp1e> Microsoft switching to BSD style licence? :)
18:07:39 <tuukkah> http://www.haskell.org/visualhaskell/doc/index.html#release-notes
18:07:40 <lambdabot> Title: Visual Haskell User's Guide
18:08:20 <beschmi> tuukkah: thanks
18:10:01 <sgillesp1e> ahhh
18:10:46 <sgillesp1e> following the example for getOpt I can't seem to parse cmd options right
18:12:05 <allbery_b> also, turns out that the first rev of POSIX permitted NAME_MAX to be 14 but a more recent revision bumped it to 255, since nobody uses S51K any more
18:26:37 <tuukkah> one idea would be to use lambabot as a basis for a conversational ide :-)
18:27:17 <sorear> methinks hslife would make a better starting point
18:27:41 <sorear> although I have plans to radically rewrite the ui-layer
18:27:50 <sorear> and it's unreleased
18:28:08 <glguy> slow night?
18:28:09 <sorear> and it was my first project (read: n00b code)
18:28:15 <LoganCapaldo> conversational ide?
18:28:15 <sorear> yeh
18:28:38 <LoganCapaldo> Is that like a contraversial ide?
18:28:43 <sorear> glguy: the lisppaste captcha is incompatible with elinks
18:28:56 <glguy> sorear: fserv.pikapphi.umr.edu:8000
18:29:00 <sorear> glguy: translation: since I can't use lisppaste, may I have your darcs url?
18:29:10 <glguy> my darcs url?
18:29:34 <sorear> what, the code isn't online in a sendable repository?
18:30:08 <sorear> sendable == having a _darcs/prefs/email file
18:30:11 <glguy> not yet, I'm going to fire up my work laptop and download it now
18:30:28 <glguy> and then maybe I'll darcs it...
18:30:39 <sorear> it's a lot easier to get the right color of bikeshed when you have a paintbrush :)
18:30:39 <glguy> you want my email address?
18:31:02 <tuukkah> sorear, where can i find info on hslife?
18:31:11 <sorear> ideally it would be in all your _darcs/prefs/email files, that way darcs send can find it
18:31:36 <sorear> tuukkah: not again!  I'm not used to having interest in my code :)
18:31:48 <sorear> lemme find it
18:32:00 <monochrom> What is a conversational IDE?
18:32:14 <sorear> i dunno
18:32:23 <tuukkah> good question
18:32:30 <sorear> but hslife is a conversational ide for Conway's Life
18:32:43 <sorear> using conversational as a normal adjective
18:32:44 <TSC> "Hi, it looks like you're writing a monad!  Would you like some help?"
18:33:15 * sorear shoots clippy
18:33:18 <tuukkah> TSC, does lambdabot normally speak in that tone?
18:33:23 <monochrom> You: "computer, I want a function that breaks strings words, like f "hello you" = ["hello", "you"]. any idea?"
18:33:30 * LoganCapaldo still is not sure what a conversational ide is
18:33:30 <LoganCapaldo> I can guess
18:33:44 <monochrom> Computer: "try f "hello you" = ["hello", "you"]; f _ = undefined"
18:33:53 <jcreigh> @hoogle String -> [String]
18:33:53 <lambdabot> Prelude.lines :: String -> [String]
18:33:53 <lambdabot> Prelude.words :: String -> [String]
18:33:53 <lambdabot> Text.Regex.splitRegex :: Regex -> String -> [String]
18:33:55 <monochrom> You: "but I want it to be more general"
18:34:02 <LoganCapaldo> That seems useful
18:34:03 <monochrom> Computer: "oh...."  <hangs>
18:34:07 <LoganCapaldo> lol
18:34:13 <sorear>  @djinn
18:34:16 <monochrom> Is that kind of a conversational IDE?
18:35:03 <allbery_b> @remember TSC "Hi, it looks like you're writing a monad!  Would you like some help?"
18:35:03 <lambdabot> Done memoising quote for `TSC', if that is their real name...
18:35:41 <tuukkah> well, lambdabot seems to be highly useful and constantly developing further
18:36:05 <DukeDave> team..
18:36:31 <sorear> muahahaha!
18:36:40 <Anon4888> sorear:  RE: The dictionary transform.  That's the mechanism Haskell uses to implement typeclasses?
18:36:49 <sorear> Anon4888: no
18:36:55 <DukeDave> I'm following a HOpenGL tutorial here: http://www.cin.ufpe.br/~haskell/hopengl/files/first.hs
18:36:57 <sorear> Anon4888: it's the mechanism GHC uses
18:37:02 <Anon4888> err ya :)
18:37:19 <sorear> Anon4888: Haskell wisely leaves such details unspecified
18:37:29 <DukeDave> can anyone comment if it is still relevant ?
18:37:33 <Anon4888> right - uncareful language on my part :)
18:37:59 <cjeris> "Hi, it looks like you're writing a monad!  Would you like some methamphetamine?"
18:38:09 <tuukkah> if there was a way for lambdabot to actually see what you're writing in the source file, perhaps you could "pair-program" with it in the vein of "could you hoogle this?"
18:39:02 <sorear> argh, it seems hslife is broken atm
18:39:30 * sorear has hacked hslife's dependancies more recently than hslife itself
18:46:39 <sorear> fixed & uploading.
18:48:48 <sorear> tuukkah:
18:49:00 <sorear> grr selection aging sounded like such a good idea...
18:49:17 <sorear> http://members.cox.net/stefanor/hslife
18:49:19 <lambdabot> Title: Directory listing
18:49:24 <OliverB> DukeDave: I think it is old
18:50:28 <OliverB> DukeDave: In fact the HOpenGL site it refers to is out of date too
18:54:05 <DukeDave> OliverB: yes, thanks it is very out of date
18:54:24 <DukeDave> I have located a more relevant tutorial now, but thanks again :)
18:55:20 <tuukkah> sorear, i suppose the genius of hslife is in the user interface?
18:55:39 <tuukkah> DukeDave, care to tell which one ?-)
18:55:57 <DukeDave> http://www.tfh-berlin.de/~panitz/hopengl/skript.html
18:55:58 <DukeDave> :)
18:55:59 <lambdabot> Title: Skript
18:56:19 <DukeDave> 2003, so at least this millenium ;)
18:57:16 <tuukkah> that still talks about hopengl
18:58:53 <sorear> tuukkah: if there is any genius it has to be in the user interface, the algorithm is probably the dumbest in existense :)
18:59:47 <sorear> oh yeah and one other thing I forgot to mention there is no documentation whatsoever :(
19:00:25 * sorear runs grep -re '--' and is suprised to learn there are any comments
19:07:36 <glguy> I don't remember who complained that my paste app used font tags, but it doesn't now ;-)
19:07:55 * sorear really needs to add ?grep-logs
19:08:14 <sorear> anyway, it was at about 5am PST
19:08:27 <glguy> oh, it was dmhouse
19:08:33 <sorear> @localtime glguy
19:08:35 <lambdabot> Local time for glguy is Sun Jan 14 11:53:58 2007
19:08:47 <tuukkah> @localtime tuukkah
19:08:48 <lambdabot> Local time for tuukkah is Wed Jan 17 05:06:45
19:09:04 <glguy> yeah... this computer was down, i need to fix the date
19:09:16 <sorear> tuukkah: you figure out how it works yet?
19:09:26 <glguy> ?localtime glguy
19:09:29 <lambdabot> Local time for glguy is Tue Jan 16 21:07:06 2007
19:09:48 <tuukkah> sorear, not really
19:09:58 <sorear> ^ATIME^A
19:10:30 <chessguy> i can't believe, there's still nobody who's stepped up and taken on the problem on -cafe of solving the classic cannibal/missionary problem in haskell
19:10:40 * glguy doesn't read -cafe
19:10:44 <glguy> link?
19:11:07 * sorear didn't undestand the problem
19:11:38 <chessguy> i don't know the link for haskell-cafe offhand
19:11:52 <sorear> http://haskell.org/pipermail/haskell-cafe
19:11:53 <lambdabot> Title: The Haskell-Cafe Archives
19:12:08 <sorear> (from memory, glad to see lambdabot likes it)
19:12:14 <tuukkah> this one contains a solution as an example: http://okmij.org/ftp/Computation/monads.html#LogicT
19:12:16 <lambdabot> Title: Monads
19:12:22 <chessguy> here's a problem description: http://www.delphiforfun.org/Programs/Missionaries.htm
19:12:24 <lambdabot> Title: Missionaries and Cannibals
19:15:42 <tuukkah> now the local time for me is too large for me to stay awake 8-|
19:16:17 <chessguy> ?localtime tuukkah
19:16:18 <lambdabot> Local time for tuukkah is Wed Jan 17 05:14:14
19:16:27 <chessguy> wow, that is a big number...
19:17:47 <sorear> I think it should by Tue Jan 16 29:14:14
19:18:04 <monochrom> 29?!
19:18:21 <sorear> True
19:18:22 <jcreigh> the days are getting longer...
19:18:33 <sorear> :)
19:18:46 <chessguy> i wouldn't think you would even need real backtracking to solve this problem, but i'm not sure
19:19:20 <monochrom> what's wrong with solving by hand and hardcoding the hand-found solution :)
19:19:46 <chessguy> it's not a very illustrative approach for a newbie to haskell :)
19:19:49 <monochrom> OH! There are variables...
19:20:27 <monochrom> "hello world" is hardcoded and illustrative.  The inventors didn't even use #define for that.
19:20:54 <sorear> every programming language should come with a HELLO define
19:20:55 <chessguy> well, i'm sure variations of it have been done, but it's usually given pretty much the same way
19:21:34 <chessguy> e.g., if there are 4 cannibals and 4 missionaries, there is no solution, interestingly enough
19:22:38 <sorear> 1. feed a missionary a very large number of sleeping pills  2. abandon him  3. ...
19:23:13 <jcreigh> tactical nukes are out of the question, I suppose.
19:23:38 <chessguy> let's stay on-topic, shall we?
19:23:57 <SamB> topic? whats that?
19:24:05 <sorear> @topic-tell #haskell
19:24:05 <lambdabot> ["The Haskell programming language: get yourself some cognitive dissonance!","http://haskell.org","Hac 07 Haskell Hackathon, 10-12 Jan, http://haskell.org/haskellwiki/Hac_2007","Logs: http://tunes.
19:24:05 <lambdabot> org/~nef/logs/haskell/","The language of ICFP winners 3 years running"] :: [String]
19:36:26 * araujo back from univ
19:40:49 <NichardRixon> ok, so I have a list like [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:40:56 <NichardRixon> it's a list of the prime factors of numbers up to 10
19:41:31 <NichardRixon> so how do I go about removing the factors of numbers in that list, such as 2, 3, etc
19:42:18 * allbery_b is not quite sure what you mean
19:42:24 <int-e> map or filter?
19:42:56 <sorear> map nub ?
19:43:14 <sorear> nub . concat ?
19:43:16 <NichardRixon> allbery_b, well, [2] is a factor of 4 (which is [2,2]), so I don't need it
19:43:37 <NichardRixon> sorear, nub will just get rid of all the 2s but one
19:44:54 <allbery_b> hm, so do you want nub . concatMap nub ?
19:45:02 <LoganCapaldo> (groupBy head) . sort ?
19:45:14 <NichardRixon> hrm
19:45:19 <allbery_b> > (nub . concatMap nub) [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:45:20 <lambdabot>  [2,3,5,7]
19:45:48 <sorear> allbery_b: you don't need the second nub
19:46:07 <NichardRixon> (groupBy head) . sort [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:46:11 <NichardRixon> > (groupBy head) . sort [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:46:11 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t -> t1]
19:46:11 <lambdabot>       Ex...
19:46:20 <allbery_b> hm, nub . concat would work
19:46:23 <allbery_b> yeh
19:46:29 <sorear> groupBy (equating head) ?
19:46:45 <NichardRixon> > groupBy (equating head) [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:46:46 <lambdabot>  [[[2]],[[3]],[[2,2]],[[5]],[[2,3]],[[7]],[[2,2,2]],[[3,3]],[[2,5]]]
19:47:01 <NichardRixon> ooh, triple lists
19:47:03 <glguy> :t equating
19:47:04 <lambdabot> Not in scope: `equating'
19:47:32 <glguy> is that like comparing f x y = f x `compare` f y
19:47:32 <sorear> it's 6.6 only
19:47:33 <sorear> 19:44 <sorear> ?let equating f x y = f x == f y
19:47:42 <LoganCapaldo> so much for my idea :)
19:47:51 <sorear> so I installed it in the bot 10s ago
19:48:26 <sorear> > groupBy (equating head) . sort $ [[2],[3],[2,2],[5],[2,3],[7],[2,2,2],[3,3],[2,5]]
19:48:28 <lambdabot>  [[[2],[2,2],[2,2,2],[2,3],[2,5]],[[3],[3,3]],[[5]],[[7]]]
19:54:02 <NichardRixon>  I am getting somewhere with filter
19:54:06 <NichardRixon> it's awkward, though
19:55:05 <chessguy> ?t sequence
19:55:06 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
19:55:10 <chessguy> :t sequence
19:55:12 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:56:03 <chessguy> > sequence 3 [True, False]
19:56:04 <lambdabot>   add an instance declaration for (Num [[Bool] -> a])
19:56:20 <sorear> > replicateM 3 [False,True]
19:56:21 <lambdabot>  [[False,False,False],[False,False,True],[False,True,False],[False,True,True]...
19:56:31 <sorear> > replicateM 4 " #"
19:56:32 <lambdabot>  ["    ","   #","  # ","  ##"," #  "," # #"," ## "," ###","#   ","#  #","# # ...
19:56:36 <chessguy> @type replicateM
19:56:38 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
19:56:44 <sorear> is that what you wanted ?
19:57:00 <chessguy> mmm
19:57:15 <sorear> > transpose $ replicateM 5 " #"
19:57:16 <lambdabot>  ["                ################","        ########        ########","    ...
19:57:20 <sorear> > transpose $ replicateM 4 " #"
19:57:21 <lambdabot>  ["        ########","    ####    ####","  ##  ##  ##  ##"," # # # # # # # #"]
19:57:23 <chessguy> > length $ replicateM 3 [True, False]
19:57:24 <lambdabot>  8
19:57:29 <chessguy> yes, i think that's it
19:59:14 <NichardRixon> what's the reverse of intersect?
19:59:24 <sorear> union
19:59:26 <LoganCapaldo> union?
19:59:50 <LoganCapaldo> @t union
19:59:51 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
20:00:11 <LoganCapaldo> Oh I can't be that lazy huh?
20:00:17 <LoganCapaldo> @type union
20:00:18 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:00:25 <glguy> http://fserv.pikapphi.umr.edu:8000/10
20:00:27 <notsmack> @ty union
20:00:28 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:00:38 <glguy> http://fserv.pikapphi.umr.edu:8000/10 -- first shot at a cannibals solution
20:00:40 <chessguy> i can't get this stupid cannibal/missionary problem out of my head, and i don't have haskell on this machine, so i can't really play with it
20:00:42 <NichardRixon> well I have a list X, and I want to only get the elements from another list Z that don't appear in X
20:01:01 <LoganCapaldo> Oh thats set difference no?
20:01:03 <NichardRixon> yeah
20:01:27 <sorear> \\
20:01:28 <NichardRixon> but there's no diff that I can find ;_;
20:01:30 <NichardRixon> oh
20:01:34 <sorear> :t (\\)
20:01:35 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
20:01:37 <NichardRixon> sweet :D
20:01:42 <LoganCapaldo> filter (`elem` X) Z
20:01:54 <LoganCapaldo> er
20:02:06 <sorear> > "hello" \\ "world"
20:02:06 <LoganCapaldo> Thats cooler than mine anyway )
20:02:07 <lambdabot>  "hel"
20:02:16 <sorear> > "helo" \\ "world"
20:02:17 <lambdabot>  "he"
20:02:17 <LoganCapaldo> esp. since mine is wrong
20:02:38 <sorear> ?pl filter . flip elem
20:02:39 <lambdabot> filter . flip elem
20:02:43 <sorear> aw
20:02:58 <NichardRixon> uh oh what have I done to hugs :(
20:03:03 <LoganCapaldo> @pl filter (not . elem)
20:03:04 <lambdabot> filter (not . elem)
20:03:06 <sorear> *kaboom*
20:03:06 <NichardRixon> when I press stop it just dings
20:03:12 <LoganCapaldo> err
20:03:39 <sorear> LoganCapaldo: notElem - it's predefined
20:03:46 <NichardRixon> oh shite all the lines I was working on are gone D:
20:03:46 <LoganCapaldo> @pl (\x -> filter (not . (`elem` x)))
20:03:46 <lambdabot> filter . (not .) . flip elem
20:03:52 <LoganCapaldo> lol
20:04:02 <LoganCapaldo> silly me :)
20:04:32 <LoganCapaldo> @hoogle (a -> Bool) -> [a] -> [a]
20:04:33 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
20:04:33 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
20:04:33 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
20:05:01 <LoganCapaldo> @hoogle a -> [a] -> Bool
20:05:01 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
20:05:01 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
20:14:30 <LoganCapaldo> So I tried to write a recursive version of fib without names
20:14:45 <LoganCapaldo> apparently Haskell doesn't like (\f -> f f)
20:15:52 <LoganCapaldo> @type (\f -> f f)
20:15:53 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:15:53 <lambdabot>       Expected type: t
20:15:59 <sorear> heh
20:16:13 <sorear> no, you need type system extensions for that
20:16:36 <jcreigh> yes, self-application is tricky with a type system.
20:16:41 <sorear> Expr> (\x ( x x ))
20:16:41 <sorear> (fix a . a -> b)
20:16:55 <LoganCapaldo> But I can do it in a dynmically typed language with 1st class functions
20:17:01 <jcreigh> sure
20:17:05 <sorear> type system extensions that Haskell does not currently support.
20:17:10 <jcreigh> (lambda (f) (f f))
20:17:16 <sorear> ``sii
20:18:06 <sorear> Expr> (\f (\x ( x x )) (\x (f (x x))))
20:18:06 <sorear> (a -> a) -> a
20:18:10 <LoganCapaldo> However I was wondering if there was a type annotation I could use to tell it "Hey, relax i promise this is ok"?
20:18:19 <sorear> nope
20:18:39 <sorear> In Haskell, if you want infinite types you'll need to use a wrapper type
20:19:01 <sorear> newtype Curry a = Curry (Curry a -> a)
20:19:13 <LoganCapaldo> What about a Y builtin (ala seq)?
20:19:24 <sorear> w a@(Curry b) = b a
20:19:32 <sorear> LoganCapaldo: fix
20:19:43 <LoganCapaldo> ah
20:19:47 <sorear> > fix ((1:) . scanl (+) 1)
20:19:48 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
20:19:50 <LoganCapaldo> So I could write it with fix somehow
20:20:06 <LoganCapaldo> eh
20:20:15 <bd_> :t scanl
20:20:17 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
20:20:36 <emu> @hoogle select
20:20:37 <lambdabot> Text.Html.select :: Html -> Html
20:20:37 <lambdabot> Text.Html.selected :: HtmlAttr
20:20:45 <bd_> @unpl  fix ((1:) . scanl (+) 1)
20:20:45 <lambdabot> fix (\ d -> 1 : (scanl (+) 1 d))
20:20:55 <emu> is there a select()?
20:20:57 <sorear> emu: use forkIO
20:21:06 <LoganCapaldo> I wanted > let fib x = (fix ((1:) . scanl (+) 1)) !! x in fib 7
20:21:18 <LoganCapaldo> > let fib x = (fix ((1:) . scanl (+) 1)) !! x in fib 7
20:21:19 <lambdabot>  21
20:21:27 <sorear> > (fix ((1:) . scanl (+) 1) !!)    7
20:21:28 <lambdabot>  21
20:21:33 <sorear> just use sections
20:22:01 <LoganCapaldo> Can you do it without the list?
20:22:27 <sorear> > fix (\nfib n -> if (n < 2) then 1 else nfib (n-1) + nfib (n-2))  7
20:22:28 <lambdabot>  21
20:22:33 <sorear> @pl fix (\nfib n -> if (n < 2) then 1 else nfib (n-1) + nfib (n-2))
20:22:34 <lambdabot> fix (ap (flip if' 1 . (< 2)) . ap (ap . ((+) .) . (. subtract 1)) (. subtract 2))
20:22:47 <sorear> ah how very elegant.
20:22:55 <LoganCapaldo> oh goody :)
20:23:03 <LoganCapaldo> pthanks
20:23:38 <sorear> anyway, it IS possible to type self-application, but fix is the Haskell Way.
20:23:52 <sorear> interestingly, fix has a very simple definition in Haskell:
20:23:53 <LoganCapaldo> fix is good enough for me
20:23:57 <sorear> fix f = f (fix f)
20:24:19 <LoganCapaldo> I'll just pretend its  fix = (\f -> f f) ;)
20:24:23 <LoganCapaldo> lol
20:24:26 <bd_> @pl let fix f = f (fix f) in fix
20:24:26 <lambdabot> fix (ap id)
20:24:34 <LoganCapaldo> laziness for the win
20:24:36 <sorear> bd_: don't do that!
20:24:47 <bd_> sorear: :)
20:24:49 <sorear> @pl let fixit f = f (fixit f) in fixit
20:24:49 <lambdabot> fix (ap id)
20:24:50 <bd_> :t fix (ap id)
20:24:52 <lambdabot> forall b. (b -> b) -> b
20:25:06 <sorear> bd_:
20:25:14 <sorear> @pl \x -> let a = 2 in a
20:25:15 <lambdabot> const 2
20:25:18 <sorear> @pl \fix -> let a = 2 in a
20:25:18 <lambdabot> ($ const 2)
20:25:21 <LoganCapaldo> @type let Y f = f (Y f) in Y
20:25:21 <bd_> heh
20:25:22 <lambdabot> Not in scope: data constructor `Y'
20:25:22 <lambdabot>  
20:25:22 <lambdabot> <interactive>:1:13: Not in scope: data constructor `Y'
20:25:27 <bd_> well apparently it didn't matter in this case
20:25:34 <LoganCapaldo> doh
20:25:45 <LoganCapaldo> @type let y f = f (y f) in y
20:25:46 <lambdabot> forall t. (t -> t) -> t
20:25:55 <bd_> :t ap id
20:25:56 <lambdabot> forall a b. ((a -> b) -> a) -> (a -> b) -> b
20:25:57 <sorear> as you can see, rebinding fix wreaks havoc with @pl's let-remover.
20:26:37 <LoganCapaldo> I don't think I get it :)
20:26:51 <LoganCapaldo> (fix vs. (\f -> f f))
20:27:05 <sorear> fix f = (\x -> x x) (\x -> f (x x))
20:28:19 <LoganCapaldo> I'll just have to cogitate on this one for a while :)
20:28:24 <LoganCapaldo> thanks
20:29:15 <LoganCapaldo> > fix (1:) -- [1,1,1,1,..]
20:29:16 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
20:29:32 * lambdabot claps
20:29:45 <LoganCapaldo> really?
20:29:49 <LoganCapaldo> whoa
20:30:01 <LoganCapaldo> why did she clap?
20:30:10 <LoganCapaldo> >1 -- 1
20:30:34 <allbery_b> because someone with privs told her to, I suspect :)
20:31:57 <master_baiter> lambdabot is the smartets bot ever
20:33:29 * sorear confesses
20:34:28 <svref> According to the ghc profiler, this function is doing 65% of my consing...I don't understand why it would cons much at all (its called about 10,000 times and  conses about 100megabytes:
20:34:37 <svref> findExplicitVertex datum graph =
20:34:37 <svref>   find ((datum==) . vertexDatum) (explicitVertexes graph)
20:35:03 <sorear> svref: -O ?
20:35:10 <svref> sorear: yes
20:35:16 <sorear> @src find
20:35:16 <lambdabot> find p          = listToMaybe . filter p
20:35:23 <sorear> @src filter
20:35:23 <lambdabot> filter _ []     = []
20:35:23 <lambdabot> filter p (x:xs)
20:35:23 <lambdabot>     | p x       = x : filter p xs
20:35:23 <lambdabot>     | otherwise = filter p xs
20:35:34 <sorear> what, filter isn't a foldr?
20:35:42 * sorear checks the REAL source
20:36:40 <sorear> wow, it's really not a foldr
20:37:14 <sorear> oh tricky special case rules
20:37:17 <sorear> @src filterFB
20:37:18 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
20:37:28 <sorear> @src listToMaybe
20:37:28 <lambdabot> listToMaybe []        =  Nothing
20:37:28 <lambdabot> listToMaybe (a:_)     =  Just a
20:37:34 <SamB> there is a mapFB too
20:37:44 <LoganCapaldo> find p (x:xs) = if p x then Just x else Nothing `mplus` find p xs; find p [] = Nothing :)
20:37:50 <trane> how does lambdabot prevent users from hacking into or otherwise abusing the server it's on
20:38:00 <notsmack> trane: lasers.
20:38:02 <sorear> the type system
20:38:11 <LoganCapaldo> Proof carrying code!
20:38:17 <LoganCapaldo> :)
20:38:21 <sorear> > deleteFile "/etc/passwd"
20:38:21 <lambdabot>   Not in scope: `deleteFile'
20:38:29 <sorear> oh, and the module system too
20:38:34 <SamB> > readFile "/etc/passwd"
20:38:35 <lambdabot>  <IO [Char]>
20:38:38 <bd_> tsk, that's a perfectly safe function
20:38:49 <bd_> its return value, on the other hand...
20:39:18 <SamB> see, there is no way to actually *run* the action
20:39:26 <SamB> also, I bet it isn't running as root ;-)
20:39:43 <notsmack> reading /etc/passwd doesn't need root
20:39:48 <SamB> indeed
20:39:49 <sorear> and there's a privilege systme
20:39:52 <bd_> > fix forkIO
20:39:52 <svref> by the way, "explicitVertexes" is a, whats the word?, accessor for a field in a Data declaration, so it doesn't show up in the profile.
20:39:53 <lambdabot>   Not in scope: `forkIO'
20:39:55 <SamB> I did it once when there was an exploit
20:40:02 <SamB> it had no passwords in it anyway ;-)
20:40:20 <SamB> not even crypted ones
20:40:30 <notsmack> SamB: yeah, shadow file
20:40:52 <SamB> of course, I was assuming that it would be that way, or I would have considered it bad form to do it ;-)
20:41:01 * allbery_b notes that even his shadow files don't contain much in the way of passwords
20:41:09 <araujo> sorear, i think the idea of the Prelude is to implement the functions as 'stand-alone' as possible.
20:41:23 <araujo> Though i am not sure if there is some optimization concerns too.
20:41:29 <sorear> @irc-connect freenode4 chat.freenode.net 6667 lambdabot4 trane_cant_do_this_because_of_the_privilege_system
20:41:37 <sorear> @join freenode4:#haskell
20:41:54 <SamB> @bot
20:41:54 <lambdabot> :)
20:41:54 <lambdabot4> :)
20:42:06 <SamB> nice
20:42:19 <SamB> @seen me
20:42:19 <lambdabot> I haven't seen me.
20:42:19 <lambdabot4> I haven't seen me.
20:42:23 <SamB> @seen you
20:42:23 <lambdabot> I haven't seen you.
20:42:23 <lambdabot4> I haven't seen you.
20:42:28 <araujo> o_O
20:42:31 <sorear> @seen lambdabot
20:42:31 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
20:42:31 <lambdabot4> lambdabot is in #haskell. I last heard lambdabot speak 8s ago.
20:42:36 <SamB> @seen a lot of things
20:42:37 <lambdabot> I haven't seen a.
20:42:37 <lambdabot4> I haven't seen a.
20:42:40 <SamB> aww
20:42:55 <SamB> @seen lambdabot4
20:42:55 <lambdabot> lambdabot4 is in #haskell. I last heard lambdabot4 speak 18s ago.
20:42:55 <lambdabot4> Yes, I'm here. I'm in #haskell
20:43:02 <sorear> lambdabot4: @bot
20:43:03 <lambdabot4> :)
20:43:18 <SamB> @seen sorear
20:43:18 <lambdabot4> sorear is in #haskell. I last heard sorear speak 15s ago.
20:43:18 <lambdabot> sorear is in #oasis, #ghc, #darcs, #haskell.hac07 and #haskell. I last heard sorear speak 15s ago.
20:43:30 <SamB> hmm.
20:43:45 <SamB> I guess it keeps seperate seen data for each connection?
20:43:59 <SamB> @vixen what do you think of ocaml
20:43:59 <lambdabot> <undefined>
20:43:59 <lambdabot4> <undefined>
20:44:08 <sorear> SamB: it's the naming system
20:44:10 <SamB> @vixen what was that about?
20:44:10 <lambdabot> <undefined>
20:44:10 <lambdabot4> <undefined>
20:44:20 <allbery_b> when they changed the regex foo they broke vixen
20:44:20 <sorear> @seen freenode:sorear
20:44:20 <lambdabot> You are in #oasis, #ghc, #darcs, #haskell.hac07 and #haskell. I last heard you speak just now.
20:44:20 <lambdabot4> freenode:sorear is in freenode:#oasis, freenode:#ghc, freenode:#darcs, freenode:#haskell.hac07 and freenode:#haskell. I last heard freenode:sorear speak 13s ago.
20:44:28 <SamB> !
20:44:32 <SamB> who changed the regex foo?
20:44:34 <sorear> @seen freenode4:sorear
20:44:34 <lambdabot> freenode4:sorear is in freenode4:#haskell. I last heard freenode4:sorear speak 13s ago.
20:44:34 <lambdabot4> You are in #haskell. I last heard you speak just now.
20:44:37 <sorear> dons
20:44:39 <allbery_b> one presumes eventually the state ill be fixed or rewritten
20:44:41 <sorear> hacathon
20:44:41 <SamB> what *is* the regex foo?
20:44:48 <sorear> serialisation
20:45:09 <sorear> SamB: the naming system assumes you are talking about the server the message came from
20:45:36 <sorear> SamB: that's why you haven't noticed the fact that everyone's nick has a colon in it :)
20:45:41 <SamB> mmmm
20:45:45 <SamB> @quote
20:45:46 <lambdabot> therp says: and minion pro comes with acrobat reader. I never thought that I would find this proprietary thing useful for anything than blocking my cpu
20:45:46 <lambdabot4> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
20:45:52 <sorear> @users fn:#haskell
20:45:52 <lambdabot> Maximum users seen in fn:#haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
20:45:52 <lambdabot4> Maximum users seen in fn:#haskell: 1, currently: 0 (0.0%), active: 0 (NaN%)
20:46:00 <notsmack> > putStrLn "> \"Hello, World!\""
20:46:02 <SamB> ???
20:46:02 <lambdabot>  <IO ()>
20:46:02 <lambdabot4>  <IO ()>
20:46:02 <sorear> quote works on raw strings, not nicks
20:46:23 <sorear> oh right dons killed the obsolete seen state
20:46:24 <notsmack> lame.  :)
20:46:30 <SamB> how does it know if nobody is in fn:?
20:46:35 <SamB> @quote
20:46:35 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
20:46:35 <lambdabot4> timthelion says: oh wait, I LOVE foldr!! and I have only been learning haskel for hours
20:46:40 <glguy> http://fserv.pikapphi.umr.edu:8000/11 -- working cannibals solution
20:46:43 <glguy> very ugly
20:46:46 <SamB> heh, snakes on a plane...
20:46:47 <glguy> tried a bunch ofstuff
20:46:52 <sorear> glguy: I
20:46:55 <SamB> is that a Python web framework?
20:47:44 <sorear> lambdabot: @remember SamB [<lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane] <SamB> is that a Python web framework?
20:47:44 <lambdabot> Done memoising quote for `SamB', if that is their real name...
20:48:31 <sorear> glguy: I'll happily add lambdabot support if I can get or add usable web-apis  (recent pastes, add pastes)
20:48:53 <glguy> sorear: what sort of API do you need?
20:49:41 <sorear> a url which streams the paste names/nicks in real time
20:49:55 <sorear> not sure if that's possible with HAppS
20:50:04 <sorear> anyway, there's a wide design space
20:50:07 <glguy> could HAppS do that?
20:50:35 <glguy> I'll investigate
20:51:40 <sorear> I'd prefer a streaming approach because I'm allergic to polling :)
20:51:52 <glguy> polling sounds terrible, i agree
20:52:12 <sorear> I'd like your bikeshed painted yellow, and I'll bring my own paintbrush if you don't mind :)
20:53:41 <sorear> lambdabot4: @quit
20:53:42 <lambdabot4> Not enough privileges
20:53:44 <SamB> oh, did anyone finish designing my nuclear power plant yet?
20:53:54 <sorear> @admin + freenode4:sorear
20:53:55 <lambdabot4> Not enough privileges
20:53:58 <sorear> lambdabot4: @quit
20:54:04 <sorear> @admin - freenode4:sorear
20:54:44 <SamB> I'll take that as a "no"?
20:54:48 * SamB goes to bed now
20:54:57 <bd_> SamB: We're not sure what color to paint it.
20:55:10 <SamB> didn't I already say I wanted it Red?
20:55:32 <SamB> or maybe a sickly glowing pale green?
20:56:03 <bd_> We feel that something more of a pastel shade would appeal more to the 40-60 age group.
20:56:08 <SamB> anyway... sleep
20:56:51 * LoganCapaldo votes for a transparent building material for the bikeshed
21:00:24 <allbery_b> ...of which there are, what, two of us here?
21:00:35 <shapr> At least
21:00:46 <shapr> Wait, I'm not 40 yet.
21:00:58 <sorear> I am 40-60 in an uncountable number of units.
21:01:17 <allbery_b> ...and the other one doesn't actually appear to be here anyway :)
21:01:25 <sjanssen> I'd like my bikeshed to be painted with a mural of a hillside covered with bikeshed painted with murals of hillsides covered with ...
21:01:49 <sjanssen> s/covered with bikeshed/covered with bikesheds
21:01:55 <sorear> at least o< 1 of which are semantically different.
21:02:20 <LoganCapaldo> fix paintBikeShed ?
21:02:33 <sorear> fix it before painting it!
21:02:35 <sjanssen> LoganCapaldo: yes please
21:02:48 <sorear> @index stdHTTP
21:02:48 <lambdabot> bzzt
21:03:12 <int-e> sorear: but if the color is pretty enough, who will care that it's broken?
21:03:40 <sjanssen> int-e: scary how true that is
21:04:49 <shapr> sorear: It's simpleHTTP with :*: End added
21:05:43 <sorear> shapr: where is it defined?
21:06:07 <sorear> and how does HAppS reexport HList?
21:06:20 * sorear is reading the haddocks trying to understand the tutorial
21:07:13 <sorear> nor do I see a definition of h
21:07:31 <shapr> sorear: stdHTTP is on line 428 of SimpleHTTP2.hs
21:07:51 <sorear> it's not in the haddock index :(
21:07:52 <glguy> shapr: any guesses how I would use HAppS to allow sorear to connect to my paste page and get a stream of paste titles and nicks as they occur
21:08:31 <mutjida> @users
21:08:32 <lambdabot> Maximum users seen in #haskell: 311, currently: 277 (89.1%), active: 32 (11.6%)
21:08:36 <glguy> ?losers
21:08:36 <lambdabot> Maximum users seen in #haskell: 311, currently: 277 (89.1%), active: 32 (11.6%)
21:08:37 <shapr> What about the standard http trickle?
21:08:40 <glguy> ?teens
21:08:40 <shapr> hiya mutjida
21:08:40 <lambdabot> Lately, I have seen freenode4:samb, freenode4:sorear, allbery_b, bd_, beppu, glguy, int-e, logancapaldo, mutjida, samb, shapr, sjanssen and sorear.
21:08:50 <shapr> What's up with that freenode4 stuff?
21:08:51 <mutjida> hello
21:08:58 <int-e> glguy: wee.
21:09:03 <sorear> shapr: my fault
21:09:11 * shapr bought an iPod shuffle, and is trying to talk to it from Debian
21:09:19 <allbery_b> he was showing off privileges, then showing off the multiconnct foo
21:09:21 <glguy> shapr: How do I write a function in HAppS that is told when the state changes...
21:09:38 <shapr> I don't know.
21:09:41 <glguy> :-(
21:09:49 <sorear> glguy: liftSTM retry?
21:09:49 <mutjida> anybody know how to contact GHC HQ?
21:09:55 <sorear> mutjida: email ?
21:09:58 <sjanssen> could you write to a TChan?
21:10:02 <shapr> mutjida: You can try #ghc, or you can email the Simons.
21:10:06 <mutjida> email to where?
21:10:15 <sorear> @where spj
21:10:15 <lambdabot> I know nothing about spj.
21:10:17 <shapr> glguy: I'll probably know by the time I finish the tutorial :-)
21:10:19 <sorear> @where smarlow
21:10:20 <glguy> sorear: but I have to run outside of the STM, and run individual STM actions atomically
21:10:20 <lambdabot> I know nothing about smarlow.
21:10:28 <shapr> @google simon marlow haskell
21:10:34 <shapr> hmm
21:10:41 <int-e> @seen simonm
21:10:45 <shapr> aha
21:10:48 <mutjida> I got a ghc 6.7 compiler message telling me to contact ghc hq to request the compiler allow some code.
21:10:48 <sorear> @seen JaffaCake
21:10:55 <shapr> simonmar at microsoft com
21:11:01 <sorear> @activity-full 1000
21:11:47 <sorear> @bot
21:12:04 <sorear> @part #haskell
21:12:19 <sorear> @bot
21:12:28 <sorear> this is *weird*
21:12:55 <sorear> @bot
21:13:12 <sorear> ok, it's not sending anything
21:13:24 <sorear> (confirmed w/ activity-full in privmsg)
21:13:44 <glguy> murderer
21:13:45 <allbery_b> hmmmm.
21:13:54 <allbery_b> no, lambdabot is fine, just not talking to #haskell
21:13:57 <allbery_b> try a /msg
21:13:59 <sorear> lambdabot can hear you
21:14:10 <lambdabot> foo
21:14:21 <sorear> ok, lambdabot responds to @msg
21:14:48 <sorear> @help
21:14:53 <sorear> @
21:14:56 <sorear> @bo
21:15:09 <sorear> http://www.google.com
21:15:22 <sorear> ok, it's not responding to contextuals
21:15:37 <shapr> lambdabot: @part #haskell
21:16:00 <sorear> shapr: did you use @msg ?
21:16:03 <shapr> yup
21:16:04 <sorear> shapr: did you use /msg ?
21:16:14 <shapr> @bot
21:16:15 <sorear> @bot
21:16:20 <shapr> odd
21:16:25 <sorear> haskell is responding in #haskell.hac07
21:16:30 <sorear> lambdabot is responding in #haskell.hac07
21:16:49 <sorear> why doesn't it talk here ?
21:17:26 * shapr doesn't know
21:17:33 <lambdabot> I'm shy
21:17:50 <allbery_b> *snerk*
21:18:43 <sjanssen> @msg #haskell works?
21:18:49 <lambdabot> yes
21:19:10 <sjanssen> from a /msg it works, but not in this channel
21:19:28 <sorear> @msg #haskell can't hurt to try
21:20:08 <mutjida> shapr: thanks
21:22:53 <mutjida> @users
21:23:02 <allbery_b> bot's being wonky
21:23:14 <allbery_b> ...hm.  try reconnecting freenode4 again?
21:23:33 <sorear> @irc-connect freenode4 chat.freenode.net 6667 lambdabot4 trane_cant_do_this_because_of_the_privilege_system
21:23:52 <allbery_b> oh well
21:23:57 * sorear feels stupid
21:24:09 <newsham> ?babel fr en rouge
21:24:16 <sorear> ?bot
21:25:11 <sorear> joy
21:25:21 <sorear> it doesn't even work in @msg now
21:26:06 <allbery_b> huh.  that does suggest t me that it's stuck on something related to freenode4 though...
21:26:31 * allbery_b should probably darcs pull... but shoudl also probably go to bed instead :>
21:27:00 <mbishop> allbery_b: and send me that card :P
21:27:26 <allbery_b> yeh, it's at work, just been busy catching up on crap from being otu sick :/
21:28:12 <sorear> @irc-connect freenode2 chat.freenode.net 6667 sorearbot2 foo
21:28:16 <sorear> @irc-connect freenode2 chat.freenode.net 6667 sorearbot2 foo
21:28:17 <sorear-lambdabot> Plugin `irc' failed with: IRCRaised user error (attempted to create two servers named freenode2)
21:28:24 <sorear> @join freenode2:#haskell
21:28:39 <sorear> sorearbot2: @part #haskell
21:28:39 <sorearbot2> Not enough privileges
21:28:47 <sorear> @part freenode2:#haskell
21:28:47 <sorearbot2> Not enough privileges
21:28:53 <sorear> @Bot
21:28:53 <lambdabot> Maybe you meant: ft let vote yow
21:28:53 <sorear-lambdabot> Maybe you meant: ft let vote yow
21:28:57 <sorear> @bot
21:28:57 <sorear-lambdabot> :)
21:29:10 <sorear> that's interesting
21:29:30 <sorear> would someone without privs say '@quit' please?
21:29:46 <allbery_b> @quit
21:29:47 <sorear-lambdabot> Not enough privileges
21:30:12 <sorear> ok, so it responds for spellcheck but not privs
21:30:22 <sorear> this narrows things down a good deal
21:30:35 <sorear> @admin freenode2:sorear
21:30:35 <sorear-lambdabot> Plugin `system' failed with: IRCRaised user error (@admin: invalid usage)
21:30:40 <sorear> @admin + freenode2:sorear
21:30:48 <sorear> @bot
21:30:49 <sorear-lambdabot> :)
21:31:07 <sorear> @listservers
21:31:07 <sorear-lambdabot> freenode
21:32:55 <sorear> @foodnznlkzas
21:32:56 <sorear-lambdabot> Unknown command, try @list
21:34:41 <sorear> @Bot
21:34:41 <lambdabot> Maybe you meant: ft let vote yow
21:34:42 <sorear-lambdabot> Maybe you meant: ft let vote yow
21:34:50 <sorear> @bbot
21:34:50 <sorear-lambdabot> Unknown command, try @list
21:34:55 <sorear> @botslap
21:34:55 <sorear-lambdabot> Unknown command, try @list
21:34:58 <sorear> @botslack
21:34:59 <sorear-lambdabot> :)
21:36:30 * sorear goes back to the happs tutorial :(
21:37:17 <sorear> I wish I had a command that mailed dons' stderr to me :)
21:37:32 <shapr> sorear: Sadly, I'm too sleepy to answer any questions, but if you have feedback on the tutorial on the wiki, I want to hear it!
21:37:36 * shapr goes to sleep
21:38:07 <sorear> at this point all I can see as possibilities are corruption of base module state, and corruption of the module table.
21:38:13 <sorear> neither is plausible.
21:38:24 <glguy> either?
21:39:36 <sorear> nope, neither
21:39:40 <bd_> > 1
21:39:41 <lambdabot>  1
21:39:48 <bd_> What's wrong with it now?
21:39:59 <allbery_b> huuuh
21:40:01 <allbery_b> @bot
21:40:02 <sorear-lambdabot> :)
21:40:09 <glguy> maybe simple backlog
21:40:18 <bd_> @seen bd_
21:40:18 <sorear> http://www.google.com
21:40:18 <sorear-lambdabot> You are in #haskell. I last heard you speak just now.
21:40:19 <sorear-lambdabot> Title: Google
21:40:22 <bd_> hmm
21:40:33 <sorear> so > x works but not url
21:40:34 <sorear> > 2
21:40:35 <lambdabot>  2
21:40:39 <sorear> great!
21:40:39 <allbery_b> lb's accepting commands for me in /msg
21:40:45 <allbery_b> and > works
21:41:01 <sorear> the one thing sorear-lambdabot is incapable of, lambdabot is responding to!
21:41:30 <bd_> Well, as long as all commands are covered, it doesn't really matter which bot is handling them :)
21:41:35 <bd_> @echo @echo
21:41:36 <sorear-lambdabot> Not enough privileges
21:41:39 <bd_> aw
21:41:45 <bd_> oh, it's @id
21:41:46 <bd_> @id @id
21:41:46 <sorear-lambdabot>  @id
21:42:10 <sorear> allbery_b: lambdabot is accepting commands in /msg for you?
21:42:21 <allbery_b> well, @bot at least
21:42:39 <sorear> not even that for me.
21:42:41 <allbery_b> just took "@seen #haskell" too
21:44:56 <syntaxfree> everyone who wants to hear me moan and kvetch head over to #haskell-blah
22:06:57 <glguy> aux x xs = (x:) $ fromJust $ find (valid x) $ tails xs
22:07:07 <glguy> is there a more obvious way to express this that I am missing
22:08:14 <sorear> eta convert
22:08:35 <sorear> aux x = (x:) . fromJust . find (valid x) . tails
22:08:43 <sorear> (I am merely optimizing...)
22:09:00 <bd_> aux x = liftM (x:) . find (valid x) . tails -- bottom considered harmful?
22:09:21 <glguy> valid will return true on a list of one or zero elements
22:09:42 <bd_> glguy: valid is taking two arguments here, though
22:09:47 <bd_> do you mean it's:
22:09:50 <bd_> valid _ [] = True
22:09:54 <bd_> valid _ [_] = True
22:09:56 <bd_> valid _ _ = False
22:09:56 <bd_> ?
22:09:58 <glguy>   valid x (x1:x2:_) = orient x x1 x2 < 0
22:09:59 <glguy>     valid _ _         = True
22:10:26 <bd_> oic
22:10:34 <bd_> so it's guarenteed not to fail
22:10:38 <glguy> right
22:11:55 <augustss> how is that guaranteed?
22:12:04 <augustss> what if xs is []
22:12:12 <augustss> oh
22:12:27 <augustss> i see
22:13:00 <glguy> http://fserv.pikapphi.umr.edu:8000/12
22:13:13 <glguy> all 6 lines or so
22:13:47 <augustss> as said, you can get rid of xs.  and ps
22:14:25 <glguy> paste annotated
22:15:08 <seliopou> glguy: are you implementing graham scan?
22:15:30 <glguy> I don't know the name of the algorithm, we just discussed this in class tonight
22:15:41 <glguy> and I wanted to write it out to grind it in ;)
22:16:19 <augustss> glguy: good strategy
22:16:41 <glguy> we also have to write psuedocode for the algorithm and prove it
22:16:53 <glguy> i figured tha Haskell code is good enough for psuedocode for me
22:16:59 <glguy> so I'd try making it clear here
22:17:22 <augustss> it's nice when you can run the pseudocode :)
22:17:44 <glguy> in that respect, I'm not sure if making it pointfree helps , however
22:18:14 <augustss> well, the removal of ps makes it clearer, I think
22:18:23 <augustss> but it's a matter of taste
22:18:29 <glguy> sure
22:18:29 <sorear> must ... slee repeat 'g'
22:19:14 <augustss> when you see a function composition you know that it's a kind of pipeline
22:19:30 <glguy> from a haskell point of view it makes sense to me
22:19:37 <glguy> but I've never had to prove haskell code before
22:19:40 <augustss> you don't have to check if the argument (ps) is used somewhere else
22:19:41 <glguy> that was my only concern
22:19:46 <augustss> ah
22:19:56 <augustss> point free is often easier to prove
22:19:57 <seliopou> it seems as though your implementation is not linear
22:20:08 <glguy> n log n
22:20:21 <glguy> (uses sort)
22:20:26 <seliopou> minus the sort I mean
22:20:30 <glguy> each point can only be deleted once
22:20:51 <glguy> and each point is only added once
22:21:16 <glguy> or did you mean in a different sense
22:21:46 <seliopou> i guess it's not entirely clear what you mean by delete and add
22:21:52 <seliopou> (to me)
22:22:01 <seliopou> so the add is clear
22:22:06 <glguy> each point is added to the list of points on the convex hull once
22:22:15 <glguy> each point can only be removed from that list once
22:22:22 <glguy> once all the points have been added
22:22:28 <glguy> and alll the non hull points removed
22:22:33 <glguy> you have your list of points on the hull
22:22:36 <seliopou> ok, I see
22:22:40 <glguy> (half hull, algorithm gets run twice)
22:22:50 <glguy> with points sorted in reverse order
22:23:17 <glguy> (which would make ps' = sort ps    useful, so that i can reverse ps'
22:23:26 <glguy> instead of sortby (flip compare) ps later)
22:23:48 <augustss> yes
22:24:15 <glguy> but then instead of using ps in the halfhull function
22:24:19 <glguy> I just pass in a sorted list
22:24:59 <augustss> @src sort
22:25:00 <glguy> hull ps = (halfhull ps', halfhull (reverse ps')) where ps' = sort ps
22:25:10 <seliopou> at which point, you will have written graham's scan
22:25:13 <augustss> @bot
22:25:14 <glguy> (I need to test edge cases
22:25:53 <augustss> has our faithful bot died?
22:26:07 <glguy> augustss: sort = sortBy compare
22:26:17 <sjanssen> augustss: lambdabot is not responding to messages in #haskell
22:26:25 <glguy> > "but was"
22:26:25 <augustss> yeah, it was really sortBy I wanted to see
22:26:26 <lambdabot>  "but was"
22:26:27 <sjanssen> I don't think anyone knows why
22:26:34 <glguy> > "lambdabot is being selective"
22:26:35 <lambdabot>  "lambdabot is being selective"
22:26:46 <glguy> GHC sortBY is a merge sort
22:27:06 <nmessenger> @vixen Don't you love me anymore?
22:27:10 <augustss> glguy: that's what I wanted to check.  I'm pretty sure it's the one I wrote many years ago
22:27:12 <LoganCapaldo> what its not that famous list comprehension quick sort? :)
22:27:43 <augustss> it's natural merge sort.  so it's linear on sorted lists
22:27:59 <sjanssen> LoganCapaldo: nope.  Quicksort has that nasty O(n^2) problem
22:28:16 <LoganCapaldo> n^2?
22:28:21 <augustss> worst case
22:28:24 <LoganCapaldo> when is quicksort n^2
22:28:28 <LoganCapaldo> ?
22:28:30 <sjanssen> LoganCapaldo: when run on a sorted list
22:28:35 <augustss> when it's sorted
22:28:49 <LoganCapaldo> REALLY?
22:28:53 <seliopou> You guys need to fix a quicksort algorithm before you go into this
22:28:55 <LoganCapaldo> gah
22:29:15 <augustss> seliopou: i think we're all talking about the cute haskell "quicksort"
22:29:36 <augustss> which is not really quicksort at all, imo
22:29:54 <glguy> augustss: do you like my duct-tape made pastebin? B^D
22:30:13 <augustss> glguy: seems to work fine :)
22:30:24 <augustss> and i can't see any duct tape
22:30:45 <seliopou> glguy: if you could, I would appreciate it if you would let me know of any other CG algos you implement
22:31:08 <glguy> seliopou: there ought to be a lot of them, class meets 2 times a week
22:31:13 <seliopou> I did an independent study on CG last semester with a few friends of mine
22:31:19 <int-e> augustss: hmm, how is that merge sort linear if the original list is sorted? (looking at base/Data/List.hs in ghc)
22:31:28 <seliopou> All theory though, we didn't implement anything
22:31:48 <seliopou> What book is the course using?
22:31:53 <augustss> int-e: so, I'm not sure about the one in Data.List, that's what I wanted to check
22:32:12 <glguy> "Computational Geometry" by "M. de Berg"
22:32:21 <glguy> "Algorithms and Applications - Second Ed."
22:32:24 <augustss> int-e: you can make it linear my collecting increasing runs and then merge those
22:32:27 <int-e> augustss: it looks like O(n log(n)) to me, regardless of the original list.
22:32:36 <int-e> augustss: yes, it doesn't do that
22:32:50 <augustss> int-e: bah!
22:33:02 <int-e> augustss: it builds singleton lists and merges them from bottom up, in pairs (of lists)
22:33:07 <sjanssen> http://fserv.pikapphi.umr.edu:8000/13 -- the relevant Data.List source
22:33:22 <augustss> int-e: yeah, that's no good
22:33:35 * glguy needs to add anchors for linking into the annotations
22:34:11 <int-e> it's a stable sort and it produces the head in O(n) operations (and takes O(log n) for further elements) ... I think that's how far my analysis went.
22:34:26 <glguy> just a warning, the pastebin is configured to reuse ids after 99
22:34:32 <sjanssen> augustss: do you think that run detection is worthwhile?
22:35:20 <Saizan> glguy: pastebin in happs yet working?
22:35:24 <augustss> sjanssen: I thought we did some benchmarks many years ago and decided that natural merge sort was the best.  but maybe I'm wrong
22:35:28 <glguy> http://fserv.pikapphi.umr.edu:8000/
22:35:31 <glguy> Saizan: ^^
22:35:48 <glguy> Saizan: work in progress, put pasting, annotations, and highlighting work
22:36:24 <LoganCapaldo> Seeing if a list is sorted is O(n) right? So if you wanted to make the cute quicksort O(n log n) you'd just have to test for sorted-ness first right?
22:36:44 <TSC> But it's also slow for nearly-sorted
22:36:46 <augustss> LoganCapaldo: that's not enough
22:37:15 <LoganCapaldo> what a pain
22:37:16 <sjanssen> augustss: there's a note in the code that says quicksort was replaced by mergesort in 2002
22:37:20 <sjanssen> written by Igloo
22:37:35 * LoganCapaldo decides to write a cute mergesort instead
22:37:38 <richcollins> Does the + symbol represent the currying operator?
22:37:42 <sjanssen> LoganCapaldo: reverse sorted is a problem too
22:37:45 <richcollins> add x y                 =  x + y
22:37:58 <int-e> richcollins: no, that's an infix operator.
22:38:05 <int-e> richcollins: it adds to numbers :)
22:38:10 <int-e> > 2 + 2
22:38:11 <richcollins> http://www.haskell.org/tutorial/functions.html
22:38:11 <lambdabot>  4
22:38:18 <int-e> > (+) 2 2
22:38:19 <lambdabot>  4
22:38:25 <richcollins> "This is an example of a curried function"
22:38:26 <LoganCapaldo> > let 2 + 2 = 5 in 2 + 2
22:38:27 <lambdabot>  5
22:38:30 <araujo> yes, it is a currying operator
22:38:31 <augustss> sjanssen: someone should benchmark again
22:38:46 <araujo> It is kind of an unusual way of calling it. But it is correct.
22:39:10 <LoganCapaldo> richcollins, the "currying operator" is the space between x and y <g>
22:39:17 <araujo> @type (2 +)
22:39:18 <LoganCapaldo> and add and x
22:39:26 <richcollins> LoganCapaldo, ah ok
22:39:46 <richcollins> add (x,y)               = x + y
22:39:52 <richcollins> that would be a "normal" add
22:39:55 <LoganCapaldo> (compare to add(x, y))
22:39:58 <richcollins> I see
22:40:39 <LoganCapaldo> currying just means an n-ary function is actually just n 1-ary functions
22:40:52 <LoganCapaldo> woah that came out wrong I think
22:41:07 <nmessenger> Seems close to correct.
22:41:15 <augustss> and there are functions to convert between curried and uncurried
22:41:22 <LoganCapaldo> let add x y = x + y in let f = add 1 in f 2
22:41:23 <nmessenger> ?hoogle curry
22:41:31 <LoganCapaldo> > let add x y = x + y in let f = add 1 in f 2
22:41:32 <lambdabot>  3
22:41:34 <nmessenger> bleh, curry and uncurry
22:41:42 <glguy> http://fserv.pikapphi.umr.edu:8000/12#2
22:41:52 <glguy> yea, annotation lilnks
22:42:07 <augustss> that was quick
22:42:14 <glguy> HAppS is easy to use ;)
22:42:16 <int-e> @type uncurry (flip (,))
22:42:20 <augustss> it must be written in haskell :)
22:42:47 <int-e> [oh right, no lambdabot] uncurry (flip (,)) :: (a, b) -> (b, a)
22:42:54 <araujo> > let sum = uncurry (+) in sum (2,3)
22:42:55 <lambdabot>  5
22:42:57 <glguy> > "half lambdabot, no @"
22:42:58 <lambdabot>  "half lambdabot, no @"
22:43:12 <sjanssen> glguy++ -- when you add lambdabot integration I'll increment you some more :)
22:43:12 <int-e> ?type 1
22:43:16 <int-e> ;)
22:43:19 <araujo> So, (+) is a currified operator.
22:43:34 <LoganCapaldo> ?type uncurry (flip (,))
22:43:38 <glguy> sjanssen: once I figure out how to write a function that can read changes to the state and print them continuously, sorear can make it happen
22:43:44 <nmessenger> as is any paren-surrounded operator
22:44:17 <Saizan> glguy: then you need js for parens highlighting :D
22:44:31 <glguy> Saizan: I know... but I'm using hscolour atm
22:44:35 <araujo> yes, operators aren't just but currified infix functions
22:44:39 <sjanssen> glguy: that's for communication over http?
22:44:43 <glguy> Saizan: so that will be a hack for a latter date (I'm not much good with JS)
22:44:50 <glguy> sjanssen: yeah
22:44:55 <richcollins> LoganCapaldo, Have I seen you in #ruby-lang or #io (or maybe both)
22:45:10 <glguy> sjanssen: sorear wants a persistent connection for lambdabot that announces nick and paste title
22:45:14 * araujo is on both
22:45:27 <sjanssen> glguy: maybe same process communication would be easier?  You could just send messages over a TChan
22:45:54 <glguy> sjanssen: probably easier, yes
22:45:54 <LoganCapaldo> richcollins, definitely #ruby-lang, maybe #io
22:46:01 <LoganCapaldo> I'm only very very very rarely in #io
22:46:02 <richcollins> must have been ruby
22:46:26 * richcollins would prefer to use Io instead of Ruby, but it is not nearly there yet 
22:46:37 <richcollins> Learning Haskell for fun
22:46:54 <araujo> yup, Io is fun.
22:47:03 * nmessenger adores the sample code page on the Io site.
22:47:10 <richcollins> Io is fun, but also preferable to Ruby IMO
22:47:20 <araujo> nice for small and simple scripting appli.
22:47:47 <richcollins> araujo, I think it would be better for most things if the libraries were there
22:47:55 <richcollins> and the language were stable
22:48:05 <araujo> richcollins, well, the language is *very* new
22:48:10 <araujo> i think they are doing fine
22:48:11 <richcollins> right
22:50:27 <richcollins> wow the semantics of haskell are way over my head - guess this is going to take a while
22:50:49 <araujo> Haskell is Fun(ctional)!
22:51:13 <augustss> richcollins: not over your head, just not what you're used to
22:51:40 <richcollins> I meant I am not just going to pick it up, like another OO language
22:51:53 <nmessenger> richcollins, which tutorials have you read?
22:51:57 <augustss> richcollins: nope, because it isn't :)
22:52:01 <araujo> richcollins, you know too many oo langs?
22:52:18 <richcollins> araujo, I don't know how I could know "too many" ;)
22:52:25 <araujo> :-}
22:52:38 <araujo> too many as in .... too many :-P
22:52:40 <richcollins> nmessenger, http://www.haskell.org/tutorial/
22:54:01 <richcollins> for instance this definition: (.)                     :: (b->c) -> (a->b) -> (a->c)
22:54:17 <augustss> that's just the type
22:54:28 <augustss> but it tells you all you need to know :)
22:54:34 <richcollins> right - I don't understand the semantics
22:54:42 <richcollins> (and probably the syntax)
22:54:43 <LoganCapaldo_> the definition is f . g = (\x -> f (g x))
22:54:43 <araujo> richcollins, they are type variables
22:54:52 <araujo> (yes, Haskell has variables for types!)
22:55:08 <richcollins> araujo, I actually understand that part
22:55:11 <augustss> richcollins: if you know the syntax, you can pretty much read it
22:55:26 <LoganCapaldo_> <heresy>Sort of kinda like templates in C++</heresy>
22:55:27 <richcollins> so the first part says that there is a function that accepts b and returns c?
22:55:41 <araujo> richcollins, then you got it *almost* , every single variable only can match one single type during that specific function application
22:55:49 <nmessenger> compose has type: given a function from b to c and a function from a to b, stick 'em together into a function from a to c.
22:56:06 <richcollins> nmessenger, ah well explained
22:56:32 <richcollins> transitivity?
22:56:46 <augustss> yes, in a sense
22:56:51 <richcollins> I guess they don't have the return the same value
22:56:53 <richcollins> just the same type
22:56:54 <nmessenger> > ((+1) . negate) 6
22:56:55 <lambdabot>  -5
22:57:05 <augustss> in a very precise sense it's exactly transitivity
22:57:19 <richcollins> augustss, right but transitivity of type
22:57:20 <richcollins> not value
22:57:29 <araujo> richcollins, they are type variable
22:57:30 <augustss> richcollins: yes
22:57:34 <richcollins> (value wrt to the type variables)
22:57:36 <richcollins> ok cool
22:57:37 <araujo> Not of values
22:57:55 <richcollins> araujo, well I guess types are considered values in that context
22:58:02 <araujo> yes
22:58:06 <LoganCapaldo_> types are fun!
22:58:10 <augustss> richcollins: an interesting thing about that type is that once you know the type, there's really only one function it could be
22:58:24 <LoganCapaldo_> @djinn (a -> b) -> (b -> c) -> (a -> c)
22:58:26 <araujo> But here, we make the distinction
22:58:34 <nmessenger> no @ commands to LB
22:58:37 <LoganCapaldo_> Oh right, @ is broken
22:58:40 <nmessenger> :(
22:58:44 <araujo> Between, a data value, and a type value
22:59:32 <LoganCapaldo_> prentends to be lambdabot: f a b c = b (a c)
22:59:33 <augustss> Haskell makes a sharp distinction between types and values.  (This isn't really necessary, but that's how Haskell is.)
22:59:46 <nmessenger> the terms are many, and confused me at first, but correct usage is helps to be understood.
22:59:49 <richcollins> augustss, how could there be only one function based on the types?
22:59:51 <araujo> yeah
22:59:57 <richcollins> you mean based on the types and the functions right?
23:00:10 <LoganCapaldo_> richcollins, parametric polymorphism
23:00:25 <augustss> richcollins: given the type of (.), you can only find one function with that type
23:00:33 <LoganCapaldo_> Theres only one function that can satisfy the type of (.)
23:00:36 <augustss> (unless you make a function that loops)
23:00:47 <nmessenger> augustss, because the args are unconstrained?
23:00:49 <richcollins> ah right
23:01:01 <augustss> richcollins: yes, because of the type variables
23:01:01 <nmessenger> undefined has any type!
23:01:17 <richcollins> I thought you were saying given the types, a, b,c you automatically knew the composition function
23:01:32 <richcollins> you are saying  you can match it
23:01:39 <glguy> anyone know how you make an <li> render even when empty?
23:01:43 <LoganCapaldo_> No, given (a -> b) -> (b -> c) -> (a -> c) you know the definition
23:01:44 <augustss> richcollins: given that a, b, and c are type variables I know it's composition
23:01:58 <nmessenger> In *this* case, since there's not much else useful you can do given the type constraints.
23:02:06 <richcollins> augustss, ah ok
23:02:18 <araujo> @src (.)
23:02:27 <LoganCapaldo_> No @ to lambdabot
23:02:30 <augustss> richcollins: if a=Int, b=Bool, c=Double, it could be many functions
23:02:32 <LoganCapaldo_> You have to fake it :)
23:02:33 <richcollins> nmessenger, right I see
23:02:37 <glguy> ?bot
23:02:46 <glguy> -- had to try ? if @ wasn't working ;)
23:02:47 <araujo> no more @?
23:02:54 <nmessenger> If, for example, there was a Num b =>, then one might compose succ in between.
23:03:01 <araujo> > src (.)
23:03:01 <LoganCapaldo_> araujo, it works if you message him
23:03:01 <lambdabot>   Not in scope: `src'
23:03:05 <LoganCapaldo_> err her
23:03:06 <araujo> >src (.)
23:03:23 <araujo> @type (+ 1)
23:03:32 <araujo> it worked before
23:03:36 <augustss> richcollins: the easiest example to stare at is 'id x = x', which has type 'id :: a -> a'
23:03:43 <nmessenger> > typeOf (.)
23:03:44 <lambdabot>  Add a type signature
23:03:57 <nmessenger> bleh, monomorphism :/
23:04:06 <richcollins> augustss, right identify function
23:04:19 <LoganCapaldo_> > -fno-monomorphism-restriction
23:04:20 <lambdabot>   Not in scope: `restriction'
23:04:23 <LoganCapaldo_> ;)
23:04:32 <augustss> richcollins: and it's hard to imagine how it could be anything but the identity function
23:05:05 <augustss> richcollins: you must return an 'a' (for any 'a'), and you have one.  so what else can you do? :)
23:05:09 <nmessenger> LoganCapaldo, well, typeOf needs a value to find its type, and a value necessarily has *one* type.
23:05:10 <richcollins> augustss, since the types are polymorphic?
23:05:17 <rahikkala> You could return bottom :p
23:05:18 <augustss> richcollins: exactly
23:05:42 <richcollins> cool - well thanks for the info, time for bed
23:05:43 <LoganCapaldo_> > id x = id x in id 4 -- "returns" bottom I think
23:05:43 <lambdabot>  Parse error
23:05:52 <LoganCapaldo_> oops
23:05:56 <augustss> rahikkala: yeah, you can always return some kind of bottom, but that's uninteresting :)
23:05:57 <LoganCapaldo_> > let id x = id x in id 4 -- "returns" bottom I think
23:05:57 <lambdabot>  Add a type signature
23:06:02 <nmessenger> > typeOf ((.) :: (Int -> Char) -> (Char -> Bool) -> (Int -> Bool)) -- is a little boring :D
23:06:02 <lambdabot>  Couldn't match `Int' against `Bool'
23:06:14 <nmessenger> *grumble*
23:06:24 <nmessenger> flipped it
23:06:31 <LoganCapaldo_> > let (id :: a -> a) x = id x in id 4 -- "returns" bottom I think
23:06:31 <lambdabot>  Parse error in pattern
23:06:38 <LoganCapaldo_> gah
23:06:43 <LoganCapaldo_> I can't win
23:07:22 <LoganCapaldo_> > let id (x :: Int) = (id x :: Int) in id 4 -- "returns" bottom I think
23:07:22 <lambdabot>  Parse error in pattern
23:07:35 <nmessenger> since bottom doesn't actually exist, "returning" bottom doesn't mean much.
23:07:37 <LoganCapaldo_> > let id x = (id x :: Int) in id 4 -- "returns" bottom I think
23:07:39 <lambdabot>  Exception: <<loop>>
23:07:51 <nmessenger> > let x = x in x
23:07:52 <lambdabot>  Add a type signature
23:08:03 <nmessenger> > let x = x in x :: Int
23:08:04 <lambdabot>  Exception: <<loop>>
23:08:21 <LoganCapaldo_> Woo bottom golf :)
23:08:24 <LoganCapaldo_> > fix fix
23:08:24 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> a
23:08:24 <lambdabot>       Expec...
23:08:34 <LoganCapaldo_> drat foiled again
23:08:38 <nmessenger> undefined
23:08:42 <nmessenger> :P
23:08:45 <LoganCapaldo_> > fix id
23:08:45 <lambdabot>  Add a type signature
23:08:53 <LoganCapaldo_> > fix id :: Int
23:08:54 <lambdabot>  Exception: <<loop>>
23:09:12 <sjanssen> augustss: any ideas for a speedy "extractRuns :: Ord a => [a] -> [[a]]"?
23:09:51 <LoganCapaldo_> Is that not groupBy (<) ?
23:09:58 <sjanssen> wrap cmp xs = map (map fst) . groupBy (\(_, p) (_, q) -> p && q) . ((head xs, True):) . zipWith (\x y -> (y, cmp x y /= GT)) xs $ tail xs
23:10:08 <sjanssen> ^^^ this is the hackish solution I've got for now
23:10:18 <LoganCapaldo_> I guess not :)
23:10:34 <sjanssen> LoganCapaldo_: sadly, no.  groupBy compares with the first element of the run, not consecutive elements
23:10:36 <nmessenger> exactRuns [1,2,3,7,8,4,5,10] = [[1,2,3],[7,8],[4,5],[10]] ?
23:11:10 <sjanssen> nmessenger: yes, consecutive, increasing sequences
23:11:53 * nmessenger wrote a adjacentsSatisfy p xs function.
23:12:35 <nmessenger> adjacentsSatisfy p xs = and $ zipWith p xs (tail xs)
23:13:18 <LoganCapaldo_> let
23:13:18 <LoganCapaldo_> [02:10] *** dblhelix (n
23:13:22 <LoganCapaldo_> eeks
23:13:25 <nmessenger> exactRuns = adjacentsSatisfy (\x1 x2 -> x1 == pred x2)
23:13:32 <LoganCapaldo_> that wasn't meant to happen
23:14:00 <nmessenger> wait no nvm
23:14:26 * nmessenger zoned out there for a minute
23:14:49 <Elifant> does anybody know how to mix pretty-printing and output colouring with ANSI ESC sequences?
23:15:59 <Elifant> I can't find solution, so I already started to modify HughesPj to be more general, i.e. to work not only with strings...
23:25:18 <glguy> http://fserv.pikapphi.umr.edu:8000/12 -- do these links look horrendous (trying to look decent without actually using graphics)
23:27:00 <glguy> too many boxes?
23:27:26 <TSC> It's hard to tell which boxes go with which paste
23:27:43 <TSC> A divider between each group would help
23:27:49 <glguy> seems reasonable
23:27:54 <Cale> So maybe too few boxes :)
23:28:18 <TSC> Yes, another big box could group them, or just a line in between would do (:
23:28:19 <Cale> actually, put the links corresponding to the paste on the same line as the Nick/Title thing, perhaps.
23:28:30 <glguy> and divider?
23:28:34 <glguy> or just same line?
23:28:42 <Cale> Try both
23:28:47 <TSC> I'd still add an unobtrusive divider
23:28:50 <Cale> yeah
23:29:08 <Cale> also, watch out what happens when the title gets long
23:29:14 <aleator> Hi. I've got haskell, 1.2g file and I need last line of it. Whats a good way to do this?
23:29:15 <glguy> 100 char limit
23:29:40 <Cale> aleator: Data.ByteString.Lazy
23:30:09 <Cale> Or rather, Data.ByteString.Lazy.Char8
23:30:14 <glguy> changes "kind of" in :)
23:31:22 <sjanssen> import qualified Data.ByteString.Lazy.Char8 as L; main = L.readFile "somefilename" >>= L.putStrLn . last . L.lines -- this line is the program you want, aleator
23:31:44 <aleator> Cale: Lazy enough to not to read the rest of the file?
23:32:09 <sjanssen> aleator: my solution will read the entire file, but it will do it very quickly
23:32:40 <_velco> can't you just hSeek backwards untill you find a newline ?
23:33:07 <sjanssen> aleator: any faster solution will require gratuitous hSeeking
23:33:31 <Cale> You'd need to know the length of the string
23:33:39 <aleator> sjanssen: ok. using usual strings that just.. does horrible things :)
23:33:41 <Cale> Which you might be able to get from the filesyste,
23:33:42 <Cale> m*
23:34:22 <sjanssen> aleator: oh yes.  This is why we invented (Lazy) ByteStrings :)
23:34:58 <Cale> Don processed a terabyte of data with lazy bytestrings just to show that it could be done :)
23:35:51 <Cale> I believe it was just some transliteration filter, but still :)
23:35:59 <aleator> Cale: That is comforting. Due to a bug I have only ~45G of stuff..
23:36:20 <glguy> looks like I got a couple hits and no major complaints, so I'll stop tinkering in that area :)
23:39:32 <Cale> glguy: some subtle colour in the background perhaps?
23:39:39 <glguy> instead of white?
23:39:44 <glguy> or instead of gray
23:40:14 <Cale> instead of grey
23:40:20 <Cale> #667788
23:40:27 <Cale> For instance :)
23:40:43 <glguy> that looks pretty
23:40:52 <glguy> need to change thet blue link color though
23:40:55 <glguy> clashes
23:41:02 <Cale> yeah
23:41:44 <Cale> 004488 shouldn't clash
23:42:20 <LoganCapaldo> sjanssen, Did you have the right type for extractRuns ? How can it be (Ord a) => if they are to be 1 unit apart? Or did I misunderstand?
23:43:12 <sjanssen> LoganCapaldo: I didn't mean 1 unit apart
23:43:43 <sjanssen> I responded to nmessenger's question incorrectly, sorry
23:43:50 <Cale> glguy: perhaps whiten the buttons a bit too
23:44:00 <LoganCapaldo> Ah
23:44:08 <Cale> because the contrast of the link colour against that grey is poor now
23:44:25 <Cale> yeah, like that :)
23:44:48 <glguy> thnx ;)
23:44:54 * glguy isn't so good with colors
23:45:21 <sjanssen> LoganCapaldo: the code I pasted earlier should do what I mean
23:45:47 <Cale> Are you using separate stylesheets?
23:45:57 <Cale> yeah, hmm
23:45:57 <glguy> I was planning on using a @import
23:46:02 <glguy> but I don't know how to do that yet, need ot look it up
23:46:15 <Cale> Is the link colour changed on the all pastes page?
23:46:26 <glguy> nope, I was doing that now adtually
23:46:28 <glguy> i saw it
23:46:31 <glguy> aweful :)
23:46:33 <glguy> awful
23:46:57 <Cale> How come it's a separate css?
23:47:18 <nmessenger> glguy, some small notes: does it say 'link to original' when there are no annotations?  Perhaps 'link to this paste'?  Maybe also move 'all pastes' and 'annotate this paste' to the bottom and add a 'new paste' link.
23:47:20 <glguy> I thought that you could do @import for the common stuff
23:47:33 <Cale> hm, yeah, you could
23:49:09 <Cale> But it's usually simpler just to use the same file for all of them. I suppose it's nice to be able to control things on an individual basis too.
23:49:27 <glguy> the original reason it that when i started I was just screwingaround
23:49:32 <glguy> I didn't even plan to CSS it
23:49:38 <glguy> so nothing had classes
23:53:18 <bakert> ?src isPrefixOf
23:53:38 <lisppaste2> LoganCapaldo pasted "My take on extractRuns" at http://paste.lisp.org/display/35507
23:54:17 <glguy> LoganCapaldo: bah, all this pastebin work and you use lisp.org
23:55:06 <glguy> ;)
23:55:36 <LoganCapaldo> Huh?
23:57:28 <glguy> oh, I thought you were here earlier: http://fserv.pikapphi.umr.edu:8000/
23:58:04 <aleator> Another silly question. How do you find out if a file exists? (Asking is unfortunately faster that RTFM)
23:58:16 <int-e> @index fileExists
23:58:16 <glguy> ?hoogle exists
23:58:22 <glguy> lol
23:58:26 <glguy> we don't have our tools
23:58:36 <int-e> yeah :/
23:58:43 <LoganCapaldo> glguy, nope. silly me (?)
23:58:59 <glguy> no problem B^D I'm just playing around
23:59:21 <int-e> http://haskell.org/hoogle/?q=exist
23:59:56 <glguy> the new paste page is a pretty sudden shock after using the other pages ;)
23:59:57 <lisppaste2> LoganCapaldo annotated #35507 with "Bug or feature?" at http://paste.lisp.org/display/35507#1
