00:03:41 <tieTYT2> hi, i'm supposed to make a function called rectangle that takes 2 sides and returns a Rectangle.  I have rectangle defined as data Shape = Rectangle Side Side
00:03:59 <tieTYT2> and i'm wondering what the proper way to define the function "rectangle"'s signature as
00:04:16 <tieTYT2> I used rectangle :: Side -> Side -> Shape
00:04:26 <tieTYT2> but only because it gave me an erro rwhen i did ... -> Rectangle
00:05:11 <TSC> That's because "Rectangle" isn't a type; "Shape" is the type
00:05:22 <glguy> tieTYT2: rectangle = Rectangle
00:05:25 <TSC> Rectangle is what you use to make a value of type Shape
00:05:45 * Cale replaces 6.7 with 6.6 following impossible things happening.
00:05:49 <glguy> tieTYT2: that doesn't do anything useful, but it does do what you asked for
00:06:10 <glguy> man... I'm glad that the BBC world news is like CNN, 4 stories looped
00:06:19 <glguy> I might have forgotten something I heard earlier
00:06:21 <tieTYT2> ok i can understand that.  But why the error message: Not in scope: type constructor or class `Rectangle'
00:06:26 <Cale> (I suppose I could submit a bug report, but my copy of 6.7 was way out of date)
00:06:30 <tieTYT2> it says the type constructor is not in scope?
00:06:45 <TSC> Because it's looking for a type called Rectangle, and there isn't one
00:07:00 <tieTYT2> but Rectangle is a constructor right?
00:07:01 <TSC> Your Rectangle is a data constructor, not a type constructor
00:07:08 <tieTYT2> oh
00:07:08 <tieTYT2> ok
00:07:14 <dancor> does anyone else not really buy the List is a Monad thing
00:07:14 <TSC> It makes values, not types
00:07:15 <tieTYT2> confusing but i guess i'll get to that eventually
00:07:32 <glguy> dancor: You have a particularly compelling argument against?
00:07:38 <tieTYT2> ah
00:07:39 <tieTYT2> ok thanks
00:07:49 <dancor> the 'mode of computation' it would represent is that of 'simultaneous possible values' right
00:08:13 <dancor> i don't buy the naturalness of that as what List's are and are predominantly used for
00:08:16 <Korollary> not in the quantum computing sense
00:09:00 <Korollary> but it's a collection of values of arbitrary size
00:09:46 <sieni> cd /kitchen && more coffee
00:11:56 <glguy> [f x | x@(_:_,_) <- xs] -- woot for readability
00:13:25 <TSC> So it's the list of all (f x) in xs that matches the pattern?
00:13:37 <TSC> Err, such that x matches the pattern
00:13:45 <dancor> Korollary: but that is the way you would interpret it as a mode-of-execution monad right?
00:13:46 <glguy> map f . filter (not . null . fst) $ xs
00:15:06 <Korollary> dancor: Yes
00:15:44 <dancor> why is that the right one
00:15:58 <dancor> aren't there others, and would they have a different >>=
00:16:23 <Korollary> if you can find another definition that satisfies the laws, I don't see why not.
00:16:36 <dancor> it doesn't seem to capture the truth that Lists are ordered
00:17:15 <dancor> are there other possibilities for >>= that satifies the monad laws
00:17:49 <Korollary> well, if you just look at return, I don't see that there could be anything else
00:19:14 <Korollary> mayeb something like return a = [(a,a)] ?
00:19:37 <Korollary> instead of return a = [a]
00:20:16 * glguy wonders if main can be run without GHCi trying to automatically show it
00:20:21 <glguy> without adding return ()
00:20:34 <dancor> return is pretty natural
00:21:12 <dancor> List.>>= is concatMap right
00:21:30 <glguy> yeah
00:21:34 <iah> return = repeat seems possible
00:21:44 <iah> i don't know how you'd define bind though
00:22:35 <dancor> i guess i just wonder how making List a Monad in a way that seems very odd/unnatural to me, results in usefulness
00:22:50 <iah> :t (>>=)
00:22:52 <dancor> how is List being a Monad usefull
00:23:00 <glguy> all bots are down :-(
00:23:03 <iah> ugh
00:23:05 <sieni> dancor: who cares?
00:23:14 <Korollary> nah we do care
00:23:22 <sieni> dancor: it's a monad because it satisfies the monad axioms
00:23:27 <astrolabe> dancour: sorry, I missed the beginning.  Why does it seem unnatural?
00:23:28 <Korollary> for instance, Map.lookup is monadic. That means that you can produce lists.
00:23:59 <_velco> > do { x <- [1, 2]; y <- [3, 4]; return (x, y); }
00:23:59 <dancor> sieni: but is concatMap itself even useful
00:24:01 <rortian> hi i have a quick question
00:24:14 <iah> dancor: it also lets you express nondeterministic functions as kleisli arrows
00:24:27 <Korollary> You don't have treat lists as monads unless you want to. Sometimes you want to.
00:24:35 <rortian> Is there an easy way to generate images, with access to pixel coordinates?
00:24:37 <dancor> sieni: i care about this because anything that makes haskell seem arcaner scares away more ppl.  so i would like to see that it is worth it
00:24:41 <_velco> > let a = 1 in a
00:24:58 <_velco> bots on strike ...
00:25:23 <iah> http://lambdabot.codersbase.com/
00:25:34 <Korollary> rortian: I don't understand your question.
00:25:45 <rortian> Fairy enough
00:26:10 <astrolabe> dancor: If you think of an (a -> m b) as modelling some kind of corruption of the idea of a pure function, then each monad gives a different type of corruption.  The list monad gives quite a good model of a multi-function: a function that can return several values, or none.
00:26:10 <rortian> Let me give quick overview for my problem
00:26:46 <sieni> dancor: I don't understand your point. Lists form a monad regardless of whether they are useful or not. It's just a fact like 2 + 2 = 4. If you find the fact that 2 + 2 = 4 useless, then don't use it, but it still doesn't become untrue.
00:27:16 <dancor> astrolabe: i think that was a very good explanation
00:27:25 <glguy> When I close my eyes, the world disappears...
00:27:37 <astrolabe> dancor: thank you!  Sadly it isn't mine originally :)
00:27:39 <rortian> I'm trying to generate images of singularly perterbed complex z^n, I've coded it in Java, but it takes forever for anysize grid else I rewrite the stuff for Javolution, which I'd have to learn...
00:27:51 <rortian> sorry for typos
00:28:33 <rortian> anyway could do it fast enough in haskell, but I'd like to know if there is a nice way to generate images
00:28:39 <dancor> astrolabe: still i wish i could see why we are describing _ordered_ lists
00:28:51 <dancor> astrolabe: with repetitions possible!
00:28:52 <Korollary> rortian: Umm. From what I understand, you have an n-dimensional complex space.
00:29:16 <rortian> its a 2d image 1d complex space
00:29:31 <Korollary> oh ok
00:29:39 <Korollary> You can have 2 dimensional arrays in haskell
00:29:50 <Korollary> would that do?
00:30:26 <iah> dancor: i don't think you can make a set monad in haskell
00:30:30 <iah> i forget why though
00:30:31 <rortian> I'd like that array an image file, tiff,png,gif,whatever
00:30:55 <astrolabe> dancor: Well what (a -> m b) gives when m = [] is a function returning a list of values.  This is a more natural concept in computer science than maths perhaps.  I guess Set is also a monad, which models mathematical multi-functions more closely.
00:30:56 <Korollary> rortian: yes, you can save the array to a file.
00:31:06 <astrolabe> iah: youcan't?
00:31:13 <Korollary> iah: sets have the Ord constraint on the contained types. Monads don't.
00:31:33 <iah> oh, that's right
00:31:42 <astrolabe> iah/Korollary: ah, that is just for efficiency.
00:32:03 <rortian> I know, but that would suck, I'll just have to learn Javolution if there's no good library, I'm lazy
00:32:04 <Korollary> for membership you need at least Eq then
00:32:41 <rortian> do people really discuss monads here all the time?
00:32:51 <Korollary> rortian: true. 2d mutable arrays are no more fun than they are in other languages.
00:33:09 <Cale> > foldr (+) 0 [1..10]
00:33:14 <astrolabe> rortian: It is quite a common topic
00:33:17 <Cale> hmm
00:33:22 <rortian> 2d mutable arrays are well abstracted in java
00:33:24 <Cale> @bot
00:33:25 <mbot> :)
00:33:28 <rortian> for images anyway
00:33:36 <Cale> @run 1 + 1
00:33:37 <mbot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
00:33:40 <Cale> aha
00:34:05 <sieni> anything mutable is hard in haskell on purpose :-)
00:34:09 <astrolabe> > 3
00:34:19 <rortian> I've got nice objects to give colors and other things, I can't find shit to help me for Javolution though
00:34:23 <astrolabe> bah :(
00:34:30 <TSC> No 3 for you
00:36:02 <rortian> I'd be fine if I could only set the values once sieni
00:36:17 <dancor> sieni: i'm coming around to your nihilism more
00:37:00 <dancor> sieni: but you can't blame me for questioning the existance of Prelude.2+2=4
00:37:27 <dancor> sieni: also if i'm missing out on cool things ppl do with List as a Monad, i'd like to know!
00:38:26 <iah> this is a pretty cool use of the list and listT monads: http://sigfpe.blogspot.com/2006/10/games-strategies-and-self-composition.html
00:46:40 <redson> I seem to be missing something, I'm trying to follow the gentle introduction to haskell while using ghci
00:46:48 <redson> and just defining a datatype, such as:
00:46:57 <redson> data Color = Red | Green | Blue | Indigo | Violet
00:47:04 <redson> produces a parse error
00:47:07 <Cale> errr... hang on, if hs-plugins doesn't work with GHC 6.6, then runplugs surely won't work
00:47:18 <astrolabe> redson: the gentle introduction has a really inappropriate name :)
00:47:21 <vegaiW> redson: you forgot the constructor
00:47:25 <Cale> So how is dons' lambdabot evaluating expressions?
00:47:40 <vegaiW> ohh. Actually, it's because you cannot define datatypes with ghci
00:47:43 <astrolabe> redson: you should type that into a file, and load it into ghci
00:47:51 <redson> ouch
00:47:57 <redson> that's interesting
00:48:16 <Cale> Right, that's a perfectly valid declaration, but the ghci prompt is for expressions only.
00:48:17 <vegaiW> (forget my first comment, that was wrong)
00:48:36 <Cale> (and a few other special commands)
00:49:03 <redson> vegaiW: thanks, that worked
00:49:26 <vegaiW> astrolabe++
00:49:36 <redson> astrolabe: yes, that worked
00:49:41 <vegaiW> ;)
00:49:51 <vegaiW> > 1+1
00:50:05 <vegaiW> she has a hang-over again.
00:50:13 * glguy demonstrates that mixing <<< and >>> makes for confusing results
00:50:14 <glguy>   getUserState >>> changeUserState (const (+1)) >>>
00:50:14 <glguy>   app <<^ \s -> (mkelem "item" (attrs s) [q,a], undefined)
00:50:30 <Cale> lamdabot is stuck, and mbot won't be evaluating any expressions until someone tells me how to make runplugs work with ghc 6.6
00:50:44 <vegaiW> Cale: by poking dons until he ports hs-plugins
00:50:52 <Cale> vegaiW: well, yeah
00:51:10 <Cale> vegaiW: But lambdabot doesn't seem to compile under 6.4 anymore.
00:51:36 <redson> astrolabe: as for "Gentle" being a misnomer, I've done a bit of ML so I'm hoping it won't be too hard
00:51:57 <Cale> yeah, if you've done some ML, then it's gentle
00:52:08 <Cale> If not, it's kind of brutal :)
00:53:16 <redson> I can imagine
00:56:35 <Cale> > foldr (+) 0 [1..10]
00:56:36 <mbot>  55
00:56:38 <Cale> okay
00:56:42 <Cale> that worked
00:56:57 <Cale> I just set the default ghc back to 6.4
00:57:19 <Cale> that only took... hours
00:58:23 <glguy> do I need to do anything to use PhantomTypes?
00:58:31 <glguy> other than -fglasgow-exts
00:59:01 <mauke> Cale: where do I get the regex/gzip libs it needs?
00:59:56 <Cale> mauke: as far as I can tell, compiling it with ghc-6.6 works
01:00:15 <Cale> that gets you the regex parts
01:00:22 <Cale> http://haskell.org/~duncan/zlib/
01:00:28 <Cale> has the zlib parts
01:04:27 <Masklinn> good morning #hs
01:11:30 <mauke> ARGH I HATE ZLIB
01:35:41 <glguy> given: a :: [MyGadt A ]   and   b :: [MyGadt B]  ... is there a way to (a ++ b) :: [MyGadt c]
01:36:41 <integral> given maps f :: MyGadt A -> MyGadt C, and g :: MyGadt A -> MyGadt C ...
01:37:00 <glguy> not "C", 'c'
01:37:17 <integral> existential type thingies
01:37:21 <glguy> I have a function: worksOnMyGadt a -> String
01:37:27 <glguy> for example
01:37:53 <glguy> ok
01:38:01 <integral> data AnyMyGadt = forall c. AnyMyGadt (MyGadt c); (map AnyMyGadt a) ++ (map AnyMyGadt b)
01:39:27 <glguy> at which point I might as well just use typeclasses
01:40:38 <glguy> I think I'm suffering from one part not needing GADTs for this little program
01:40:47 <glguy> and one part not fully understanding what they are capable of
01:41:08 * glguy has put all of the following in one Faq type
01:41:10 <glguy> newtype Faq      = Faq [FaqTopic]
01:41:10 <glguy> data FaqTopic    = FaqTopic String [FaqItem] [FaqSubtopic]
01:41:10 <glguy> data FaqSubtopic = FaqSubtopic String [FaqItem]
01:41:10 <glguy> data FaqItem     = FaqItem String String (Maybe Int) Bool
01:42:43 <glguy> *had*
01:42:59 <glguy> since functions that applied to one applied to all in most cases
01:45:31 <augustss> you could have overloaded your functions
01:45:42 <glguy> ?
01:46:21 <augustss> the functions that that applied to one/all
01:46:56 <glguy> like: faqToXml :: Faq a -> IOStateArrow Int b XmlTree
01:47:00 <kosmikus> moin Teggy
01:47:55 <augustss> I mean, if there was some advantage to having separate types, you could have kept them
01:48:50 <ProfTeggy> Hi kosmikus.
01:49:15 <ProfTeggy> kosmikus, will you be at POPL?
01:49:18 <glguy> one of the things I tried was: Topic :: String -> [forall a . Faq a] -> Faq Topic
01:49:27 <glguy> data Topic;
01:49:30 <kosmikus> ProfTeggy: no, unfortunately not
01:49:49 <kosmikus> ProfTeggy: good luck with PLANX though
01:50:20 <ProfTeggy> I see.  Nice in January may be not as nice as the picture they always tend to show you ;-)
01:50:28 <ProfTeggy> Thanks, kosmikus
01:51:05 <ProfTeggy> We've got two Haskell-related sumissions... but both were rather weak, I'd say.  Rejected.
01:52:19 <kosmikus> ProfTeggy: there've been Haskell-related papers at PLAN-X before, or not?
01:55:05 <kosmikus> Nice in January is not the reason I'm not going ;) I just didn't succeed to get a paper finished for any of the deadlines ...
01:58:18 <ProfTeggy> kosmikus, yes, there have, e.g. http://planx2006.ens.fr/demofiles/Lu-Sulzmann.pdf
02:01:33 <huschi_> \hoogle map
02:01:41 <huschi_> @hoogle map
02:01:42 <mbot> http://maps.google.com/
02:01:42 <mbot> Title: Google Maps
02:01:57 <huschi_> @pl \d1 l1 s0 -> d1-l1*s0
02:01:58 <mbot> (. (*)) . (.) . (-)
04:23:36 --- topic: '["The Haskell programming language: get yourself some cognitive dissonance!","http://haskell.org","Hac 07 Haskell Hackathon, 10-12 Jan, http://haskell.org/haskellwiki/Hac_2007","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"] :: [String]'
04:23:36 --- topic: set by dons on [Sun Jan 07 23:15:34 2007]
04:23:36 --- names: list (clog ADEpt boegel kaol_ iblechbot Danten falseep jgrimes daniel_larsson xpika emk bringert dcoutts__ lambdabot delamon beelsebob sad0ur Itkovian mnislaih kzm_ waern Averell niksnut Excedrin Mitar swiert Igel augustss beschmi conal vja mgdm chris2 bakert dblhelix kowey yaba huschi_ norpan malcolmw genneth BCoppens Masklinn gour kjdf matthew_- wilx|wrk wolfgangbeck redson magr vincenz lisppaste2 therp _velco marko_ amiddelk Betovsky russo)
04:23:36 --- names: list (tessier_ dancor bos__ Jaak kilimanjaro woggle AtnNn user317 bdash Plareplane jewel kinetik_ X-Scale finchely dgoldsmith aking jdroid- Spark Cale perspectival wchogg ytinasni falconair ademan Baughn MisterC metaperl ikegami-- qwr integral calvins_ PupenoR ulfdoz loud- fnordus Saizan tphyahoo rc-1 notsmack Pupeno tessier Lunchy calvins LOKadin nornagon temujin dmuino matthew-_ xerox shapr thou resiak mauke mikael JaffaCake felipe koffein)
04:23:36 --- names: list (bos_ ikaros ClaudiusMaximus fabiim liyang slipstream-- Khisanth cameron Igloo takuan shawn bd_ manveru ramkrsna Korollary noclouds Hunter_wow araujo Nioate fridim_ fridim Si Eelis GeoBes1 SamB_XP kosmikus kpreid _frederik_ benc__ hyrax42 bortzmeyer vegaiW slava robreim atsampson koe mbishop MikeJS boulez raxas zamez eyck dcoutts Muad_Dibber pitecus PhilKC koala_man mattam Tigge ozone psykotic blink GeoBesh glguy flux__ rds ski emu Eidolos)
04:23:36 --- names: list (SamB earthy wilx cognominal ohmega jbalint mattiast bobwhoops jrockway gds Vq^ Lemmih audreyt newsham mr_ank ToRA mahogny levitation[A] dgriffi3 jcreigh allbery_b pejo rey_ arjanoosting lucca kolmodin_ gdsx saccade xinming cajole kzm lispy thelsdj jdev Prozen ski_ gvdm_other mathrick xian cpfr kolmodin tuukkah eno Mynstral mlh l_a_m dcoutts_ jmob Nafai ascii Botje master_bater gaal cmeme rafl dons Poeir Azmo moconnor arcasin johs_ kalven)
04:23:36 --- names: list (SimonRC ray ibid Wallbraker Codex_ magagr opqdonut sieni Lor Kattana joene_ noj kpk arcatan df__ Syzygy- carp_ wolverian quetzal yosemite mornfall mux edwinb Akheron orbitz starfruit benja_ profmakx sjanssen dany2k TwigEther cods jmg_ Philippa nothingmuch dylan @ChanServ scw TSC Lunar^ explicitjelly bacek |shad0w| nnunley psnl dino- moonlite JKnecht ph8 Hirvinen grumpy_old_one bitshifter Tanuk- juli)
04:24:12 <mgdm> that ain't your daddy's eggdrop
04:25:39 <nornagon> ?let (=^.^=) = (+)
04:25:40 <lambdabot> Defined.
04:25:52 <nornagon> > 1 =^.^= 2
04:25:54 <lambdabot>  3
04:25:57 <nornagon> I love haskell.
04:27:37 <mgdm> I was reading about Parsec the other day which made me get back into it
04:27:42 <mgdm> I did some at Uni, ages ago
04:28:26 <mgdm> but learning Haskell at the same time as learning how to make Parallel Haskell works messed with my head
04:29:22 <manveru> hrm
04:29:48 <manveru> nornagon: !?
04:29:51 <manveru> wow
04:30:36 <manveru> omfg
04:30:46 <manveru> Prelude> 1 + 1
04:30:46 <manveru> 3
04:30:59 <manveru> I love haskell.
04:31:48 <manveru> uhm, guys... how do i access getClockTime
04:31:58 <manveru> i did import System.Time
04:32:16 <manveru> however, it complains with: Not in scope: `getClocktime'
04:34:12 <bakert> if i have this, how do i turn it into a one liner?
04:34:16 <Jaak> seems to work for me :\
04:34:16 <bakert> success <- doThing
04:34:24 <bakert> if success then return "yes" else return "no"
04:34:27 <bakert> ???
04:35:30 <flux__> @. pl undo do { success <- doThing; if success then return "yes" else return "no" }
04:36:40 <bakert> oh.  so there's no clever way to "unwrap" and use a value in a monad in one swift move?
04:38:48 <Masklinn> @hoogle getClockTime
04:38:48 <lambdabot> Time.getClockTime :: IO ClockTime
04:39:04 <Saizan> ?type liftM (\x -> if' x "yes" "no")
04:39:04 <bakert> thanks flux__
04:39:05 <lambdabot> Not in scope: `if''
04:39:20 <Saizan> ?type liftM (\x -> if x then "yes" else "no")
04:39:21 <lambdabot> forall (m :: * -> *). (Monad m) => m Bool -> m [Char]
04:39:26 <manveru> hmm
04:39:41 <manveru> Masklinn: i knew that much... but how do i use it?
04:40:04 <Saizan> bakert: liftM (\x -> if x then "yes" else "no") doThing
04:40:07 <bakert> interesting Saizan thanks
04:40:26 <Masklinn> > foo <- System.Time.getClockTime
04:40:26 <lambdabot>  Parse error
04:40:30 <Masklinn> blah
04:40:49 <manveru> > System.Time.getClockTime
04:40:50 <lambdabot>   Not in scope: `System.Time.getClockTime'
04:41:54 <Masklinn> $ cat TestTime.hs
04:41:54 <Masklinn> import System.Time
04:41:54 <Masklinn> main = do
04:41:54 <Masklinn>     time <- getClockTime
04:41:54 <Masklinn>     putStrLn (show time)
04:42:01 <raxas> > Time.getClockTime
04:42:02 <lambdabot>   Not in scope: `Time.getClockTime'
04:42:34 <raxas> but it works in ghci for me
04:43:31 <Jaak> > getClockTime >>= print
04:43:31 <lambdabot>   Not in scope: `getClockTime'
04:43:42 <Jaak> hm
04:44:08 <Masklinn> it does work in ghci though
04:44:17 <Jaak> yep
04:44:20 <Saizan> you simply can't do IO in lambdabot
04:44:28 <Masklinn> that's probably why
04:44:33 <Masklinn> fairly logical too
04:46:44 <Masklinn> manveru > other issues with getClockTime?
04:46:58 <manveru> uhm
04:47:03 <manveru> well, it doesn't work...
04:47:12 <manveru> lemme show you :)
04:47:16 <Masklinn> yes please
04:47:52 <ClaudiusMaximus> @hoogle (a -> IO b) -> [a] -> IO [b]
04:47:53 <lambdabot> No matches, try a more general search
04:48:00 <lisppaste2> manveru pasted "the bot" at http://paste.lisp.org/display/34745
04:48:18 <ClaudiusMaximus> @hoogle (Monad m) => (a -> m b) -> [a] -> m [b]
04:48:19 <lambdabot> No matches, try a more general search
04:48:22 <earthy> @type sequence . map
04:48:23 <manveru> there are two places...
04:48:24 <lambdabot>     Expecting a function type, but found `b'
04:48:24 <lambdabot>       Expected type: (a1 -> b) -> [m a]
04:48:54 <manveru> i tried various ways... System.Time.getClockTime Time.getClockTime getClockTime alone...
04:48:55 <earthy> @type sequence . (map :: (a -> IO b) -> a -> IO b)
04:48:57 <lambdabot>     Couldn't match the rigid variable `a' against `[a]'
04:48:57 <lambdabot>       `a' is bound by the polymorphic type `forall a b. (a -> IO b) -> a -> IO b'
04:49:04 <earthy> grmz.
04:49:09 <manveru> it just tells me out of scope :P
04:49:44 <earthy> anyway, claudiusmaximus, that's pretty much what you want. sequence . map ;)
04:49:50 <Masklinn> manveru > try getClockTime instead of getClocktime line 76
04:49:51 <earthy> @type sequence
04:49:53 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
04:49:59 <ClaudiusMaximus> earthy: thanks
04:50:03 <Saizan> ?type mapM
04:50:04 <lambdabot> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> [a] -> m [b]
04:50:10 <manveru> Masklinn: !!!
04:50:14 <Masklinn> manveru hehe
04:50:20 <earthy> *right*
04:50:29 <malebria> > t (++)
04:50:30 <lambdabot>   Not in scope: `t'
04:50:32 <manveru> Masklinn: :| *stupidiam*
04:50:36 <malebria> @t (++)
04:50:37 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
04:50:38 <malebria> @type
04:50:39 <lambdabot> not an expression: `'
04:50:42 <malebria> @type (++)
04:50:42 <earthy> that'd work too, ofcourse
04:50:43 <manveru> Masklinn: thanks :)
04:50:43 <lambdabot> forall a. [a] -> [a] -> [a]
04:50:44 <Masklinn> manveru > no biggie ;)
04:50:47 <ClaudiusMaximus> Saizan: thanks
04:51:21 <malebria> What does the forall mean? I thought that if it's a low case letter it'd be always be forall
04:52:00 <mgdm> @hoogle head
04:52:00 <lambdabot> Prelude.head :: [a] -> a
04:52:00 <lambdabot> Data.PackedString.headPS :: PackedString -> Char
04:52:00 <lambdabot> Text.Html.header :: Html -> Html
04:53:36 <ClaudiusMaximus> @type liftIO
04:53:38 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
04:53:54 <Masklinn> malebria > http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
04:53:56 <lambdabot> http://tinyurl.com/f9umb
04:54:37 <ClaudiusMaximus> @docs liftIO
04:54:38 <Masklinn> malebria > forall is part of GHC's extended type system
04:54:38 <lambdabot> liftIO not available
04:55:17 <Masklinn> malebria > you can also check http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
04:55:19 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/8bwuf
04:55:29 <ohmega> @type head
04:55:30 <lambdabot> forall a. [a] -> a
04:55:46 <ClaudiusMaximus> @index liftIO
04:55:46 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
04:56:12 <Masklinn> @quote dons
04:56:12 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
04:57:35 <nothingmuch> can somebody estimate a ballpark figure for bootstrapping ghc on an old (2002ish) ibook?
04:57:59 <nothingmuch> make it sound scary, i'm trying to discourage someone from doing that ;-)
04:58:57 <psykotic> a ballpark figure for what, exactly?
04:59:08 <nothingmuch> time
04:59:08 <mattam> 6hours i'd say
04:59:22 <manveru> more like 8
04:59:26 <therp> really that much?
04:59:33 <manveru> maybe 10 even :P
04:59:42 <mattam> maybe much more indeed
04:59:55 <manveru> watching grass grow is in any case much more exciting
04:59:58 <mattam> depends on the proc freq and memory
05:00:04 <nothingmuch> 512 mb of ram
05:00:27 <nothingmuch> i would estimate ~1ghz
05:00:29 <nothingmuch> asking her now
05:00:33 <nothingmuch> ppc g4
05:00:39 <therp> now you have to do it,  because we all want to know. I'd say 4 hours.
05:00:42 <manveru> hey, that's not that old
05:00:53 <mattam> yeah around 6-8
05:01:13 <mgdm> 2002 will be <1GHz
05:01:23 <nothingmuch> i might have been wrong
05:01:27 <nothingmuch> she said 1.07ghz
05:01:29 <nothingmuch> it could be 2003
05:01:46 <mgdm> Ah, fair enough, my knowledge of Macs has been erased from my mind since mine blew up
05:01:54 <mattam> yeah I did it with ~ the same spec and it's long
05:01:58 <ClaudiusMaximus> nothingmuch: i compiled ghc-6.6 from the source tarball using an existing ghc-6.4.2 binary, on gentoo linux on athlon-xp 1600, 1GB ram;  took  214m41.426s
05:02:14 <nothingmuch> ClaudiusMaximus: ah, that is a scary number
05:02:17 <nothingmuch> thanks =)
05:04:38 <nothingmuch> hmm... is a .pkg still available for 6.6?
05:06:01 <therp> looks like I've been running out of GHC-foo today.  ghc-6.7: panic! (the 'impossible' happened) (GHC version 6.7 for x86_64-unknown-linux): lookupRecBndr toParseTree{v a1ip} [lid]
05:08:43 <Saizan> @quote impossible
05:08:43 <lambdabot> ghc says: panic! (the `impossible' happened, GHC version 6.4)
05:26:59 <ClaudiusMaximus> @src intersperse
05:26:59 <lambdabot> intersperse _   []     = []
05:27:00 <lambdabot> intersperse _   [x]    = [x]
05:27:00 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
05:34:34 <kowey> is there a nicer way to express firstMaybe fn = listToMaybe . mapMaybe fn ?
05:39:03 <manveru> hmm
05:39:07 <manveru> ?hoogle regex
05:39:08 <lambdabot> Text.Regex.Regex :: data Regex
05:39:08 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
05:43:38 <luqui> I remember being told that I shouldn't use Writer [a]
05:43:46 <luqui> because it is slow...
05:43:51 <luqui> what was the alternative
05:45:51 <tphyahoo> is "do" syntax ever used outside of code that deals with monads?
05:46:02 <luqui> tphyahoo, no
05:46:12 <tphyahoo> ok, thx
05:47:58 <ClaudiusMaximus> ?paste
05:48:10 <ClaudiusMaximus> @paste
05:48:10 <lambdabot> http://paste.lisp.org/new/haskell
05:50:20 <manveru> ?hoogle harp
05:50:21 <lambdabot> Language.Haskell.Syntax.HsCharPrim :: Char -> HsLiteral
05:50:21 <lambdabot> Text.ParserCombinators.Parsec.Char.CharParser :: type CharParser st a
05:50:41 <manveru> hrm
05:50:49 <manveru> what's the best thing for regex?
05:51:02 <manveru> preferably out of the box :)
05:53:17 <luqui> Text.Regex?
05:54:23 <dons> manveru: Text.Regex (or one of the other regex-* packges)
05:54:29 <dons> ?where regex-compat
05:54:36 <dons> well, it comes with ghc anyway :)
05:54:40 <dons> ?bot silly
05:54:40 <lambdabot> :)
05:54:56 <maskd> how can i check if a string can be parsed as a number?
05:55:33 <wolfgangbeck> has anybody managed to build network-alt-0.3.2 with ghc-6.6?
05:57:23 <Masklinn> ?hoogle String -> Maybe a
05:57:24 <lambdabot> No matches, try a more general search
05:57:39 <wolfgangbeck> maskd: Numeric.readDec "99"  results in [(99, "")]
05:58:00 <wolfgangbeck> maskd: Numeric.readDec "blubb" results in []
05:58:03 <lisppaste2> ClaudiusMaximus pasted "hs-plugins weirdness (race condition or bug in my code?)" at http://paste.lisp.org/display/34753
05:58:26 <wolfgangbeck> maskd: Numeric.readDec "9blubb" results in [(9, "blubb")]
05:58:50 <luqui> that will do
05:59:12 <luqui> maskd, you know how to use that, right?
05:59:41 <tphyahoo> manveru: check haskell cafe mailing list, I asked about this and got a lot of replies
06:00:08 <tphyahoo> if you want perl regex, you can get this, but need ghc 6.6
06:00:44 <tphyahoo> for posix regex, you can get this OOTB where "the box" is apt get on ubuntu.
06:01:30 <manveru> tphyahoo: i got 6.6
06:01:33 <dons> check haskell.org, under 'libraries and apps'/lexing
06:01:43 <dons> there's about 7 regex libs now, for posix, pcre, tre and so on
06:01:48 <dons> posix and -compat come standard
06:01:48 <manveru> i try import Text.Regex.Posix
06:02:06 <manveru> hmh, pcre would be even nicer :)
06:02:12 <vincenz> btw, people who never worked with haskell are commenting on how great the haskell wikibook is!
06:02:16 <vincenz> @join #haskell.dut
06:02:21 <vincenz> @join #oasis
06:02:31 <dons> vincenz: ah yes.
06:02:36 * dons fixes
06:02:44 <dons> yeah, the wiki book is pretty fine
06:02:50 <kowey> the wikibook or the wiki?
06:02:59 <vincenz> more people are getting interested :)  Wikibook
06:03:13 <tphyahoo> manveru: http://www.nabble.com/trivial-function-application-question-t2922232.html#a8173692
06:03:16 <lambdabot> Title: Nabble - trivial function application question, http://tinyurl.com/yx7jvq
06:03:22 <kowey> yay! i think we have dmhouse to thank for the push towards newbie-friendliness
06:04:16 <vincenz> dmhouse++
06:04:18 <tphyahoo> I still got to get 6.6 installed on my box. this week I hope :)
06:04:56 <maskd> luqui: i'm just trying to write a function that gets user input and returns the list [1..n] (where n is the number the user typed). probably there's an easier way to do that
06:05:31 <luqui> do you have to check for errors?
06:05:45 <luqui> if not, you can just use readLn
06:06:04 <manveru> tphyahoo: thank you, reading now...
06:06:42 <dons> http://corfield.org/blog/index.cfm/do/blog.entry/entry/Haskell_Revisited
06:06:44 <lambdabot> Title: An Architect's View - Haskell Revisited, http://tinyurl.com/y2dl2d
06:07:32 <maskd> luqui: no, but the program won't run
06:07:51 <luqui> maskd, elaborate/paste?
06:11:05 <vegaiW> "Haskell is a pure functional language. That means that nothing is allowed to have a side effect. However this is a bit of a problem if we want to do something involving side effects."
06:11:11 <vegaiW> I actually like that style :)
06:11:24 <vegaiW> (that's from the aforementioned wikibook)
06:12:19 <maskd> nevermind, i figured it out
06:12:26 <luqui> maskd, :-)
06:12:42 <dons> hack hack hack!
06:12:49 <dons> lunch time at the hackathon
06:13:16 <tphyahoo> putStrLn ( getLine )
06:13:27 <tphyahoo> maskd, I just tried that but no dice. what works?
06:13:32 <shapr> @yow !
06:13:32 <lambdabot> We place two copies of PEOPLE magazine in a DARK, HUMID mobile home.
06:13:32 <lambdabot> 45 minutes later CYNDI LAUPER emerges wearing a BIRD CAGE on her head!
06:13:52 * shapr boings cheerfully
06:13:57 <tphyahoo> basically I have to take an IO String value and make it a string value
06:14:15 <tphyahoo> I thought return, but no, return goes the other way: t -> M t
06:14:16 <tphyahoo> I think.
06:14:20 <manveru> puh
06:14:20 <Botje> tphyahoo: getLine >>= putStrLn
06:14:32 <manveru> tphyahoo: this regex-stuff is not as easy as i thought
06:14:39 <manveru> maybe i'm thinking too complicated
06:14:48 <Botje> getLine is of type IO String , and putStrLn is of type String -> IO ()
06:15:06 <Botje> >>= goes from IO a -> (a -> IO b) -> IO b
06:15:06 <luqui> tphyahoo, until you grok monads, do { line <- getLine; putStrLn line }   might be easier to understand
06:15:07 <tphyahoo> manveru: you should have access to =~ type syntax if I read the read correctly
06:15:13 <manveru> so, my problem...
06:15:19 <tphyahoo> unfortunately couldn't try that out myself since no 6.6
06:15:23 <manveru> ":manveru!n=manveru@pq120.opt2.point.ne.jp PRIVMSG #haskot :!id hey"
06:15:26 <manveru> this is my string...
06:15:54 <tphyahoo> manveru, can you do it with perl -e 'stuff...' ?
06:16:08 <manveru> i need to extract "PRIVMSG" "#haskot" and the stuff :.*?:(.*?)$
06:16:12 <manveru> uhm
06:16:21 <manveru> i can do it with ruby -e "stuff..."
06:16:23 <tphyahoo> My goal is to be able to do any regex stuff that works for perl -e stuff, with haskell, without sweating.
06:16:34 <manveru> :P
06:16:40 <manveru> but ruby uses mostly PCRE
06:16:52 <manveru> so yeah, i could do it with perl -e if i knew perl
06:17:06 <Botje> hmm
06:17:16 <Botje> simulating an NDA is actually trivial with the list monad.
06:17:19 <manveru> it's just a simple extract-variables
06:17:26 <luqui> umm, yeah, definitely use a library
06:17:37 <luqui> you could try to make it yourself, but it would not be fun
06:17:43 <integral> Botje: not with a specialised contract monad?
06:17:53 <lisppaste2> ClaudiusMaximus annotated #34753 with "hs-plugins make fails 1st time, succeeds 2nd time, source unchanged..." at http://paste.lisp.org/display/34753#1
06:17:55 <bakert> manveru, what's your existing perl compatible regex?
06:17:59 <Botje> integral: bleh :)
06:18:13 <manveru> bakert: second, building :)
06:18:24 <bakert> just convert it to posix and use Text.Regex
06:18:25 <bakert> ??
06:18:56 <bakert> matchRegex (mkRegex "bar[0-9]+foo")  -- that sort of thing
06:19:11 <bakert> no \d for digits in posix i don't think
06:19:21 <dons> or use pcre
06:19:24 <dons> regex-pcre
06:19:32 <manveru> user, hostmask, cmd, channel, msg = ":manveru!n=manveru@pq120.opt2.point.ne.jp PRIVMSG #haskot :!id hey".scan(/:(.*?)!(.*?) (.*?) (.*?) :(.*)/)
06:19:32 <manveru> # [["manveru", "n=manveru@pq120.opt2.point.ne.jp", "PRIVMSG", "#haskot", "!id hey"]]
06:19:34 <bakert> That's a separately installable thing is it?
06:19:48 <shapr> dons: Have you seen the scarlet lambda?
06:19:57 <bakert> sorry, dons, is regex-pcre someone's library?
06:20:03 <manveru> it's a really really simple regex :)
06:20:41 <manveru> i could basically split it though...
06:21:12 <manveru> won't get me the hostmask, but when i split on space it would work...
06:21:34 <manveru> and i can get the hostmask easily afterwards
06:21:50 <Botje> > tail $ dropWhile (/='@') ":manveru!n=manveru@pq120.opt2.point.ne.jp"
06:22:03 <Botje> oh, \bot fell over again?
06:22:26 <manveru> hmm
06:22:37 <manveru> i know about dropWhile
06:22:59 <manveru> is there no split -> String -> String ?
06:23:11 <tphyahoo> maybe unlines
06:23:14 <Botje> that's not a very valid type
06:23:15 <tphyahoo> or something like it
06:23:23 <Botje> ?source words
06:23:23 <lambdabot> words not available
06:23:23 <tphyahoo> (that was for manveru)
06:23:31 <manveru> :P
06:23:45 <tphyahoo> ?src words
06:23:45 <lambdabot> words s = case dropWhile isSpace s of
06:23:46 <lambdabot>     "" -> []
06:23:46 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
06:23:47 <manveru> unlines...
06:23:50 <Botje> blah :)
06:23:52 <tphyahoo> ?src unwords
06:23:52 <lambdabot> unwords [] = ""
06:23:52 <lambdabot> unwords ws = foldr1 (\w s -> w ++ ' ':s) ws
06:23:56 <manveru> a ha!
06:24:18 <tphyahoo> there ya go :)
06:24:28 * manveru sets out in unchartered territories
06:25:36 <tphyahoo> manveru:
06:25:38 <tphyahoo> hartman@ds0207:~> perl -e 'my $string = "blah"; $string =~ /(bl)(ah)/; print "first group: $1\n"'
06:25:42 <tphyahoo> first group: bl
06:25:58 <manveru> yeah
06:26:05 <manveru> almost the same in ruby :)
06:26:11 <tphyahoo> (template for asking the pcre question in a "perly" way)
06:26:47 <manveru> i'm no big perl-fan and i think regex are ugly, but they are gooood drugs :)
06:27:22 <wolfgangbeck> is there a version of c2hs compilable under ghc-6.6?
06:27:56 <manveru> hmm
06:28:06 <tphyahoo> manveru: ashamed to like perl/regex (but I think haskell is better drugs)
06:28:15 <wolfgangbeck> seems as if ghc-6.6 Distribution libs break many existing Setup.hs
06:28:25 <tphyahoo> I get very ugly interaction with emacs in haskell mode.
06:28:25 <manveru> words :: String -> String -> IO ()
06:28:25 <manveru> words s = dropWhile isSpace s of
06:28:38 <manveru> something's b0rken about 'of'
06:28:51 <tphyahoo> sometimes, irreproducibly, it just starts doing what I didn't type, showing the screen wrong.
06:29:08 <tphyahoo> I think it's a haskell mode thing and not a terminal mode thing... anyone have this?
06:29:20 <lisppaste2> e_e_coli pasted "Exercise solution seeking criticism" at http://paste.lisp.org/display/34756
06:29:20 <daniel_larsson> manveru: case dropWhile ....
06:29:50 <manveru> uuh
06:29:58 <manveru> words is defined already!
06:30:01 <manveru> lol
06:30:02 <daniel_larsson> yea
06:30:07 <manveru> rofl
06:30:12 <manveru> :D
06:30:17 <manveru> still that snippet is wrong :)
06:30:36 <e_e_coli> Hello. I just pasted my solution to an early exercise in the YAHT tutorial. If anyone has a moment to look at it and criticize it, I'd be much obliged.
06:31:34 <bakert> from a fellow newbie, it looks good e_e_coli
06:32:02 <bakert> If I am going to use exceptions in my code, should I be throwing userError from IOError?  Or what is the right way?  Thanks, T
06:32:23 <e_e_coli> Building strings for output seems verbose compared to other languages... is there anything like format strings, rather than ++ with (show foo) ?
06:32:44 <bakert> Sorry ignore me ... Control.Exception, right?
06:33:13 <wolfgangbeck> e_e_coli: Text.Printf
06:33:17 <e_e_coli> d'oh
06:33:22 <lisppaste2> ClaudiusMaximus annotated #34753 with "FIXED: putting "-v" in hs-plugins make options breaks things" at http://paste.lisp.org/display/34753#2
06:33:42 <kowey> e_e_coli: it also helps to know that you often need fewer parentheses than that
06:33:54 <kowey> e_e_coli: which potentially cuts down on the verbosity
06:34:00 <e_e_coli> I have found that function application binds more tightly than, say ++
06:34:06 <e_e_coli> am I wrong?
06:34:45 <e_e_coli> so that <putStrLn foo ++ bar> is a syntax error, but <putStrLn (foo ++ bar) is ok
06:35:11 <daniel_larsson> correct
06:35:13 <bakert> yeah i noticed that e_e_coli
06:35:16 <tphyahoo> re my emacs question above, forget it. seems my term *is* borked. bah.
06:35:22 <wolfgangbeck> btw, why does printf throw exceptions after i've upgraded to ghc-6.6?
06:35:27 <kowey> as a consequence, you can replace ++ (show num) ++
06:35:30 <kowey> by ++ show num ++
06:35:33 <Botje> e_e_coli: $ has a very low precedence.
06:36:02 <Botje> so (show (fact num)) can be show $ fact num
06:36:06 <e_e_coli> kowey: you is correct; thanks
06:36:11 <e_e_coli> ahhh
06:36:13 <kowey> putting all this together... you get...
06:36:20 <e_e_coli> perl :)
06:36:36 * e_e_coli is not serious
06:36:55 <manveru> > group "Mississippi"
06:37:02 <lambdabot>  ["M","i","ss","i","ss","i","pp","i"]
06:37:18 <manveru> man, i love those :)
06:37:24 <kowey> putStrLn $ "The factorial of " ++ show num ++ " is " ++ show (fact num)
06:37:32 <kowey> or (show $ fact num)
06:38:23 <Botje> e_e_coli: alternatively, you could use unwords.
06:38:30 <e_e_coli> What is theis it un-heaskelly to use Text.Printf?
06:38:33 <e_e_coli> sorry
06:38:39 <e_e_coli> Is it un-heaskelly to use Text.Printf?
06:38:45 <Botje> putStrLn $ unwords ["The factorial of", show num," is ", show $ fact num]
06:39:38 <paolino> @instances Ix
06:39:39 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
06:39:41 <shapr> Wow, Kolmogorov is hitting the bigtime with shared information distance.
06:39:58 <wolfgangbeck> > printf "bla %d" 10
06:39:59 <lambdabot>  Add a type signature
06:40:08 <e_e_coli> (10::Int) ?
06:40:10 <kowey> e_e_coli: i don't know... personally, it never occured to me to want printf
06:40:11 <manveru> hmm
06:40:21 <wolfgangbeck> > printf "bla %" (10 :: Int)
06:40:22 <lambdabot>  Add a type signature
06:40:39 <wolfgangbeck> > printf "bla %d" (10 :: Int)
06:40:40 <e_e_coli> yours sincerely, integer
06:40:40 <lambdabot>  Add a type signature
06:40:47 <manveru> is it possible to define two variables like (stuff, msg = splitAt 3 [1,2,3,4,5])
06:41:06 <wolfgangbeck> ghci does it, but throws Prelude.undefined afterwards
06:41:28 <manveru> > printf "bla %s" 10
06:41:29 <lambdabot>  Add a type signature
06:41:31 <paolino> manveru: yes, put the par around the tuple
06:41:45 <earthy> hey, shapr, did you know about http://en.wikipedia.org/wiki/Sweden,_New_York
06:41:51 <manveru> paolino: oh, just did that to seperate from my sentence :)
06:41:55 <manveru> cool
06:42:06 <e_e_coli> it's hard to search for operators on Google
06:42:19 <dino-> Can runhaskell be used like runhugs with a #! ? Having trouble with it.
06:42:26 <shapr> earthy: Yes, I did, that's why I chose the name of my blog post. My gf suggested that we look for a Swedish speaking community in the USA when she moves over here.
06:42:41 <shapr> dino-: I think I've used it that way.. and documented it in my blog.
06:42:43 * shapr digs
06:42:57 <earthy> :)
06:43:06 <Saizan> > printf "bla %d" 10 :: String
06:43:06 <lambdabot>  Add a type signature
06:43:10 <dino-> Sadly, runhaskell/runghc has zero man page docs. :(
06:43:10 <wolfgangbeck> [google searching] thats why Haskell' is a bad choice for naming the next Haskell
06:43:13 <shapr> I can't find any communities that still speak Swedish.
06:43:18 <manveru> oh, so i can just assign variables from a list...
06:43:26 <daniel_larsson> What about Sveeeedish?
06:43:34 <manveru> no, i can't :P
06:43:40 <paolino> dino-, that's a feature of the shell I think
06:43:41 <e_e_coli> Thanks all very much for your help
06:43:42 <shapr> dino-: http://www.scannedinavian.com/hope/entry/65
06:43:44 <tphyahoo> e_e_coli: you might try google code search
06:43:52 <e_e_coli> I love to learn the idioms of a language, and not just stomp around
06:44:06 <e_e_coli> The $ operator is noce
06:44:08 <e_e_coli> i
06:44:13 <ray> cool how people use literate haskell for flog posts
06:44:22 <manveru> paolino: ok, aksed different :)
06:44:27 <manveru> *asked
06:44:30 <manveru> a, b = [1,2]
06:44:53 <dino-> Huh, has to be literate, is that what this basically means?
06:45:08 <paolino> dino- .If is the case put the result of 'which runhugs' there after #!
06:45:15 <shapr> dino-: Yeah, I used literate Haskell for that script, and some of my other scripts.
06:45:31 <kowey> why not use /usr/bin/env ?
06:45:34 <ray> it shouldn't have to be literate
06:45:36 <daniel_larsson> dino-: but it doesn't need to be literate haskell
06:45:50 <paolino> > (a,b) = [1,2]
06:45:50 <lambdabot>  Parse error
06:45:59 <shapr> ray: Well, the first line should start with the magic hash bang, right? But -- is a comment in Haskell, so...?
06:46:06 <manveru> paolino: exactly :)
06:46:17 <paolino> > (a,b) = (1,2)
06:46:17 <lambdabot>  Parse error
06:46:25 <dino-> Huh, still no good.
06:46:27 <dino-> Well, thanks.
06:46:38 <ClaudiusMaximus> > let [a,b] = [1,2] in a + b
06:46:38 <shapr> daniel_larsson: How to do it without being literate?
06:46:39 <paolino> > let (a,b) = (1,2) in a
06:46:39 <lambdabot>  3
06:46:40 <lambdabot>  1
06:46:45 <shapr> dino-: What doesn't work? Can you paste the code?
06:46:46 <dino-> I get 'Failed to load interface for `Main'
06:46:50 <ray> yeah, not sure if it's smart enough for that
06:47:00 <manveru> a ha
06:47:16 <dino-> will do
06:47:18 <manveru> thank you :)
06:47:19 <ClaudiusMaximus> > let [a,b] = [1,2,3] in a + b
06:47:20 <lambdabot>   Irrefutable pattern failed for pattern [a, b]
06:47:31 <daniel_larsson> shapr: good point. I'll have to check :) I could have sworn I've seen hash bang in non literate haskell scripts though
06:47:38 <shapr> Jag vet inte.
06:47:51 <shapr> Jag hoppas att du har det r√§tt.
06:47:52 <e_e_coli> I wonder how the YAHT author expects folks to solve the looping part of the exercise without having introduced mapM_
06:47:59 <dino-> @paste
06:47:59 <lambdabot> http://paste.lisp.org/new/haskell
06:48:22 <ray> #!/usr/bin/env runhaskell is working for me
06:48:36 <chessguy> e_e_coli, what's the exercise?
06:48:37 <ray> non-literate
06:48:43 <lisppaste2> dino- pasted "runhaskell doesn't like me" at http://paste.lisp.org/display/34759
06:48:45 * allbery_b just checked his code stash; fps does it that way (with Setup.hs)
06:48:46 <shapr> ray: Show us the code! Can you paste it?
06:48:48 <daniel_larsson> Japp, non-literate fungerar bra :)
06:49:02 <shapr> I want to see!
06:49:05 <kowey> e_e_coli: explicit recursion?
06:49:12 <daniel_larsson> #!/usr/bin/env runhaskell
06:49:12 <daniel_larsson> import Distribution.Simple
06:49:12 <daniel_larsson> main = defaultMain
06:49:18 <shapr> daniel_larsson: Hey, are you on #haskell.se also?
06:49:20 <daniel_larsson> (Setup.hs)
06:49:35 <daniel_larsson> Nope, didn't know it existed!
06:49:36 <e_e_coli> kowey: maybe, though that's awkward (to me, as a beginner) in the context of a do block
06:49:40 <ray> it just says #!/usr/bin/env runhaskell and then main = putStrLn "foo"
06:50:00 <shapr> Thought bringert recently suggested changing it to #haskell.sv so that the Swedish colonies could also feel welcome.
06:50:04 <lisppaste2> dino- annotated #34759 with "output" at http://paste.lisp.org/display/34759#1
06:50:10 <e_e_coli> because we haven't been given any real idea of Monadic "types"
06:50:20 <e_e_coli> in OCaml, it's simple; you just evaluate to "unit"
06:50:39 <e_e_coli> but I don't yet get what the value is of do
06:51:05 <paolino> @help instances-importing
06:51:06 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
06:51:11 <manveru> ClaudiusMaximus: i get that problem right now...
06:51:12 <shapr> e_e_coli: Have you seen monadic code written without do?
06:51:16 <e_e_coli> no
06:51:25 <e_e_coli> I'm just starting the YAHT tutorial
06:51:31 <e_e_coli> which implies that you have to use do
06:51:36 <shapr> e_e_coli: It's easier to use monadic code if you understand how it works without the do first.
06:51:38 <lisppaste2> ray pasted "works for me!" at http://paste.lisp.org/display/34760
06:51:41 <norpan> you understand why you want "do" when you see code written without it
06:51:45 <ray> for completeness
06:51:54 <luqui> shapr, are you sure?
06:51:55 <paolino> @instances-importing Data.IArray Ix
06:51:56 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
06:52:06 <ClaudiusMaximus> > let (a:b:_) = [1,2,3,4] in a+b
06:52:07 <lambdabot>  3
06:52:09 <kowey> i suspect that's just 'do' not being explained better
06:52:14 <e_e_coli> so, between shapr and norpan, I don't quite know what to think
06:52:20 <paolino> @instances-importing Data.Array.IArray Ix
06:52:21 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
06:52:23 <e_e_coli> kowey: no doubt
06:52:25 <manveru> ClaudiusMaximus: but i need the rest
06:52:37 <ClaudiusMaximus> > let (a:b:rest) = [1,2,3,4] in rest
06:52:37 <luqui> shapr, when learning, I kind of worked from both directions; getting a functional understanding of "do" and a theoretical understanding of >>=
06:52:37 <e_e_coli> I'm just waiting for me books to arrive
06:52:38 <kowey> (i'll bet there is a way to give a solid intuition for do, without neccesarily going into monads, but without leaving
06:52:38 <lambdabot>  [3,4]
06:52:39 <manveru> ah, just gonna do it the long way :)
06:52:44 <kowey> thu user with the impression that it's magical)
06:52:46 <manveru> oh
06:52:48 <manveru> ?
06:52:51 <luqui> shapr, and gradually putting them together
06:52:56 * manveru is confused by :
06:53:10 <dino-> Very curious. Could be something with my ghc installation here. :/
06:53:14 <ClaudiusMaximus> @type (:)
06:53:15 <lambdabot> forall a. a -> [a] -> [a]
06:53:24 <e_e_coli> Is there a point where IO doesn't seem weird, magical, and awkward?
06:53:30 <ray> yes
06:53:32 <e_e_coli> yay
06:53:47 <complaisant> hi , noob question here.. i have the following dataype declaration : ( data Elem = T Int Int Bool ) (type Tab = [Elem]) & i want to create a function newTab 1 2 = [(T 1 1 False),(T 1 2 False)] .. i tried to do this with comprehension lists but ghci tells me that  "(`Elem' has non-nullary constructors)" any ideas how i could do this ?
06:53:54 <kowey> once you try to use it for one of your own programs, and make many mistakes
06:53:59 <ray> it still *is* weird, magical, and awkward, but it doesn't seem it anymore
06:54:01 <ray> :)
06:54:03 <shapr> luqui: If it works for you, it's good. But I think learning purely lambda-based use of monads first will let you learn do notation as a simple rewrite.
06:54:08 <e_e_coli> Everyone here++
06:54:17 <kowey> ?karma here
06:54:17 <lambdabot> here has a karma of 1
06:54:21 <shapr> luqui: But I learned it like you did too, so I'm being sort of hypocritical/hypothetical =)
06:54:34 <dino-> ray: What version of ghc do you have there?
06:54:43 <dino-> Mine is 6.6-3
06:54:45 <ray> 6.4.2
06:54:47 <luqui> I figure in an applied medium like programming, purely theoretical foundations usually aren't optimal
06:54:59 <shapr> luqui: good point.
06:55:25 <dino-> ray: Your example with the foo! fails in exactly the same way for me. Suggesting that all of our code is fine and it's my compiler here.
06:55:26 <shapr> dino-: ray's code works for me with runhaskell, runhugs, or runghc as the last word of the first line.
06:55:32 * manveru got no theoretical foundations :|
06:55:45 <ClaudiusMaximus> @tell dons hs-plugins-1.0-rc0, ghc-6.4.2, using "-v" as an option to 'make' gives a MakeFailure ( http://paste.lisp.org/display/34753#2 )
06:55:46 <lambdabot> Consider it noted.
06:56:25 <dino-> shapr, paolino, ray: Thanks for your help.
06:56:47 <allbery_b> dino-: you need to give the script a .lhs extension, or use the -x lhs option
06:56:53 <paolino> manuveru (:) separate the head element from a list in the pattern matching
06:57:07 <tphyahoo> ?karma dons
06:57:07 <lambdabot> dons has a karma of 111
06:57:13 <allbery_b> if it's just called "foo" then ghc feeds it to the linker
06:57:21 <manveru> > let (a:b) = (splitAt 2 (words "foo bar foobarius")) in b
06:57:21 <lambdabot>  Couldn't match `[a]' against `([a1], [a1])'
06:57:21 <dino-> allbery_b: That may be so, but even ray's non-lhs example fails for me.
06:57:40 <paolino> :T splitAt
06:57:41 <allbery_b> "foo" is not considered haskell source.
06:57:50 <paolino> :t splitAt
06:57:51 <lambdabot> forall a. Int -> [a] -> ([a], [a])
06:57:57 <allbery_b> "foo.hs" and "foo.lhs" are (normal and literate, respectively)
06:57:59 <dino-> This one: http://paste.lisp.org/display/34760
06:58:04 <allbery_b> unless you use -x to force it
06:58:26 <paolino> manveru: it returns two lists in a tuple
06:58:38 <manveru> so i need ([a] : [b]) ?
06:58:42 <dino-> allbery_b: I understand that, but trying to run them with runhaskell (without a filename extension) isn't working even for non-lhs source code.
06:58:49 <complaisant> > [(1,1)..(3,3)]
06:58:49 <lambdabot>   add an instance declaration for (Enum (a, b))
06:58:49 <lambdabot>     In an arithmetic sequence...
06:58:55 <paolino> you tried to match it with a single list
06:59:11 <manveru> duh
06:59:20 <manveru> so all was useless :P
06:59:28 * manveru goes the long way
06:59:31 <paolino> > let (a:b)=[1,2,3] in (a,b)
06:59:32 <lambdabot>  (1,[2,3])
06:59:58 * allbery_b would not expect that to do anything sensible given that runghc is a wrapper for ghc
07:00:14 <allbery_b> and ghc isn't expected to do anything sensible with a file with the wrong extension
07:00:17 <paolino> > let (a,b) = splitAt 2 [1,2,3] in (a,b)
07:00:18 <lambdabot>  ([1,2],[3])
07:00:40 <manveru> oh man
07:00:42 <ray> i named it with .hs
07:00:50 <bakert> stupid cabal question.  program works fine with "runhaskell Module.hs" but won't build with cabal because of Could not find module `Database.HDBC.PostgreSQL'
07:00:51 <ray> like everything
07:00:52 <manveru> from [a,b] over (a:b) to (a,b)
07:00:59 <bakert> What do I need to add to build-depends?
07:01:01 <manveru> :P
07:01:25 <paolino> there is no (:) in my paste
07:01:26 <manveru> which is where i come from
07:01:31 <paolino> ah
07:01:36 <dino-> allbery_b, ray: Ah, I didn't understand the script has to be named like this even for #!
07:01:41 <dino-> I get what you're saying now.
07:01:57 <wolfgangbeck> bakert: download / compile / install the pkg implementing Database.HDBC.PostgreSQL
07:02:33 <dino-> I was expecting it to act like any old sh script.
07:02:38 <bakert> wolfgangbeck, i have that.  i just need to tell cabal about it?
07:02:51 <bakert> wolfgangbeck, works fine if i just run it.  but compiling with cabal gives the error.
07:03:09 <wolfgangbeck> bakert: if it is installed, cabal just find it
07:03:29 <bakert> wolfgangbeck, observation begs to differ!
07:03:42 <wolfgangbeck> ghc-6.6 seems to break many cabal files
07:03:42 <bakert> wolfgangbeck, don't i need anything in "Build-Depends"?
07:04:27 <wolfgangbeck> bakert: i'm not a cabal expert, i just installed a few packages
07:04:57 <wolfgangbeck> and those pkgs did find the pkgs they relied on
07:04:59 <bakert> wolfgangbeck, no probs.  it is a bit odd.  You don't know the syntax for Build-Depends?  it doesn't seem to like anything with a full stop in.
07:05:52 <lisppaste2> manveru pasted "the darn answer" at http://paste.lisp.org/display/34762
07:06:06 <jewel> if I were to write a parser for a language with syntax similar to python, which would be more appropriate, happy, parsec or something else?
07:06:08 <manveru> paolino: i don't get anywhere :(
07:06:22 <shapr> coi djul .i ma nuzba
07:06:44 <manveru> you guys speak lojban? :)
07:07:00 <shapr> doi manveru .i xu do tavla bau la lojban
07:07:22 <manveru> :D
07:07:29 * manveru digs out some attidutionals
07:07:57 <jewel> coi manveru .i ko na xanka
07:07:58 <luqui> http://xkcd.com/c191.html
07:07:59 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
07:08:07 <manveru> :)
07:08:30 <manveru> .uiviu
07:08:39 <manveru> :P
07:08:45 * manveru doesn't know much more anymore
07:08:47 <shapr> luqui: :-P
07:22:13 <paolin1> @pl\ foldl (flip (.)) id
07:22:13 <lambdabot> foldl (flip (.)) id
07:24:16 <paolin1> @pl\ flip (foldl $ flip ($))
07:24:17 <lambdabot> flip (foldl (flip id))
07:27:51 <vincenz> btw, there is a haskell course at mit
07:29:47 <wolfgangbeck> how do i convert a Float to Int?
07:29:56 <sjanssen> carefully :)
07:30:10 <bakert> wolfgangbeck, round or there's another one
07:30:21 <bakert> floor
07:30:22 <wolfgangbeck> round gives you Integer, not Int
07:30:57 <sjanssen> wolfgangbeck: from a ghci prompt, type ":info RealFrac"
07:31:33 <sjanssen> that has 5 different functions to achieve your goal
07:31:54 <wolfgangbeck> sjanssen: none of them work. They all give Integer, not Int
07:32:08 <allbery_b> so pass the result through toInteger
07:32:20 <sjanssen> wolfgangbeck: all of them can give both Int and Integer
07:32:25 <wolfgangbeck> toInteger gives me an Integer, not Int
07:32:31 <allbery_b> sorry, wrong one
07:32:51 <sjanssen> > truncate 1.2 :: Int
07:32:51 <wolfgangbeck> i tried quite a few combinations
07:32:52 <lambdabot>  1
07:32:52 <allbery_b> fromIntegral coerces to whatever its context is
07:33:04 <sjanssen> wolfgangbeck: fromInteger is not in the RealFrac class
07:33:13 <allbery_b> if yopu're getting Integer then you'll need to tell the type inferencer you really want Int somehow
07:33:25 <allbery_b> add an explicit type somewhere
07:33:54 <allbery_b> ?hoogle (RealFrac a, Integral b) => a -> b
07:33:55 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
07:33:55 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
07:33:55 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:34:21 <allbery_b> ...and truncate, which @hoogle doesn't show because it only provides the top 3 results
07:34:35 <wolfgangbeck> tst :: (Integral t) => t -> Int
07:34:35 <wolfgangbeck> tst x = truncate x
07:34:42 <wolfgangbeck>     Could not deduce (RealFrac t) from the context (Integral t)
07:34:42 <wolfgangbeck>       arising from use of `truncate' at win.hs:5:8-17
07:34:42 <wolfgangbeck>     Possible fix: add (RealFrac t) to the type signature(s) for `tst'
07:34:42 <wolfgangbeck>     In the expression: truncate x
07:34:42 <wolfgangbeck>     In the definition of `tst': tst x = truncate x
07:35:01 <_frederik_> hello
07:35:11 <allbery_b> hm, no, wrong type there
07:35:24 <allbery_b> t is RealFrac, not Integral
07:35:32 <allbery_b> (no point in truncating an Integral)
07:36:00 <wolfgangbeck> oops
07:36:01 <_frederik_> does anyone know if there is a GADT version of ExpQ?
07:36:36 <wolfgangbeck> allbery_b: doesn't work with Floating, though
07:36:49 <wolfgangbeck> allbery_: like in :t sin 9.5
07:37:21 <sjanssen> wolfgangbeck: it will work with both Double and Float
07:37:29 <allbery_b> :t truncate $ sin 9.5
07:37:31 <lambdabot> forall b. (Integral b) => b
07:37:42 <wolfgangbeck> allbery_b: thx
07:44:50 <rahikkala> Here's a question for the Haskell Hierarchical Libraries Trivial Pursuit masters here: Is this function already defined somewhere with some name I didn't expect?
07:44:53 <rahikkala> (\functions value -> zipWith (\f x -> f x) functions $ repeat value)
07:46:09 <luqui> rahikkala, is it iterate?
07:46:31 <luqui> no...
07:46:42 <sjanssen> @type \fs -> map ($ x) fs
07:46:43 <lambdabot> Not in scope: `x'
07:46:51 <sjanssen> @type \fs x -> map ($ x) fs
07:46:52 <lambdabot> forall a b. [a -> b] -> a -> [b]
07:47:32 <luqui> ya, I think that one does it nicely
07:47:33 <sjanssen> rahikkala: not in the libs, but you can write it quite succinctly with map ^^^
07:47:56 <rahikkala> ... yeah, I'll take that as concise enough :)
07:48:11 <luqui> (also much clearer; I had no idea what the original was doing)
07:49:25 <sjanssen> there should be a Haskell Hierarchical Libraries Trivial Pursuit game
07:50:35 <Binkley> it would have to be called "Nontrivial Pursuit", though
07:51:08 <allbery_b> "Foggy _|_ Trivia"
07:53:26 <glguy> I'm glad my computer at work is running so slow... its nice not *being able* to work hard
08:04:31 <dons> ?bug
08:04:32 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
08:05:09 <malebria> dons: can you give me again that link of the typeOf in haskell?
08:07:22 <sjanssen> @docs Data.Typeable
08:07:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
08:07:34 <sjanssen> malebria: there ^
08:08:16 <malebria> sjanssen: it's not this, it's a script that calls ghci to get the type inference of a function.
08:08:50 <sjanssen> malebria: http://www.cse.unsw.edu.au/~dons/code/typeof/
08:08:50 <lambdabot> Title: Index of /~dons/code/typeof
08:09:40 <malebria> sjanssen: thanks. How did you got the link? I searched it for a lot of time.
08:10:05 <sjanssen> malebria: got it from dons, it was still in my URL history
08:10:20 <dons> hackathon pickies: http://planet.haskell.org/
08:10:21 <lambdabot> Title: Planet Haskell
08:10:33 <malebria> sjanssen: thanks. I bookmarked it now.
08:11:05 <tuukkah> Process.hs is also good to know so you never have to write one yourself...
08:12:48 <araujo> morning
08:15:35 <bakert> how can i convert a list to a tuple?
08:15:44 <dons> > f [1,2] = (1,2)
08:15:44 <lambdabot>  Parse error
08:16:23 <apfelmus> @let f [x,y] = (x,y)
08:16:24 <lambdabot> Defined.
08:16:31 <apfelmus> ?type f
08:16:32 <lambdabot> Not in scope: `f'
08:16:36 <sjanssen> heh.  "of course you need Cont!"
08:16:47 <apfelmus> > f [1,2]
08:16:48 <lambdabot>  (1,2)
08:17:13 <apfelmus> ?type f -- feature request for lambdabot
08:17:14 <lambdabot> Not in scope: `f'
08:17:46 <dons> apfelmus: yeah, need to do that
08:17:55 <dons> sjanssen: yeah, the Binary class, working on it right now!
08:18:04 <dons> uses ContT, thanks to kolmodin
08:18:28 <apfelmus> dons: that would be great!
08:19:12 * sjanssen doesn't understand why ContT is needed, but he trusts the hackers
08:21:30 <kolmodin> sjanssen: it's the same project as we looked at the rules recently
08:22:32 <_frederik_> dons: do you know if someone has written something to turn the ExpQ of Template Haskell into a GADT-based term datatype with de bruijn bindings?
08:22:34 <sjanssen> kolmodin: right.  I just didn't grasp what ContT is doing
08:24:08 <kolmodin> same as Cont, but with another monad inside :D
08:24:32 <kolmodin> </unhelpful>
08:27:28 <cperfumo> does anybody know where can i find a tutorial on how to modify Haskell RTS? (in fact I want to add new functions to STM API)
08:28:10 * sjanssen is very glad to see this from JP Bernardy regarding collections vs. Edison: "Robert: if that is actually the direction where you want to move for edison, I'd suggest to merge the two packages."
08:37:32 <cperfumo> 3
08:38:04 <sjanssen> cperfumo: have you seen the GHC commentary?
08:40:43 <paolino> @help instances
08:40:43 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
08:59:01 <Owner_> dons, did you send the link to your modified version of largeword?
08:59:20 <shapr> Owner_: You should ask that on #haskell.hac07 probably
08:59:55 <shapr> Owner_: You're Dominic Steinitz, yeah?
09:01:38 <dons> shapr: yeah
09:01:52 <kilimanjaro> dom: Your cover has been blown!
09:01:56 <shapr> rahikkala: Your function is more concise with Cale's swing combinator.
09:01:59 <glguy> ?bot
09:01:59 <lambdabot> :)
09:02:31 <glguy> swing :: (((a -> b) -> b) -> c -> d) -> c -> a -> d
09:02:32 <glguy> swing f c a = (f ($ a)) c
09:02:33 <shapr> rahikkala: In fact, I'll be very surprised if you can get any more concise than to use Cale's swing combinator.
09:03:32 <kilimanjaro> shapr: In general, the best way to handle these sorts of situations is to just have Cale write it.
09:03:43 * shapr laughs
09:03:46 <glguy> (\functions value -> zipWith id functions $ repeat value)
09:03:48 <glguy> that one?
09:03:51 <shapr> glguy: Yeah
09:04:03 <shapr> The simple solution is swing map
09:04:08 <vincenz> @type swing f c a = f ($a) c
09:04:09 <lambdabot> parse error on input `='
09:04:19 <vincenz> @type let swing f c a = f ($ a) c in swing
09:04:21 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
09:04:23 <glguy> ?type let swing f c a = (f ($ a)) c in swing map
09:04:25 <lambdabot> forall a b. [a -> b] -> a -> [b]
09:04:36 <vincenz> glguy: remove the outer parens
09:04:38 <vincenz> not only that
09:05:13 <glguy> vincenz: I'm just pasting from http://www.haskell.org/hawiki/LicensedPreludeExts
09:05:14 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
09:05:20 <vincenz> @type let swing f c a = (f . ($)) a c in swing
09:05:22 <lambdabot> forall a b t t1. ((a -> b) -> t -> t1) -> t -> (a -> b) -> t1
09:05:30 <vincenz> @type let swing f c a = (f . flip ($)) a c in swing
09:05:31 <lambdabot> forall a b t t1. (((a -> b) -> b) -> t -> t1) -> t -> a -> t1
09:05:43 <vincenz> @type let swing f  = flip (f . flip ($)) in swing
09:05:44 <lambdabot> forall a b b1 c. (((a -> b) -> b) -> b1 -> c) -> b1 -> a -> c
09:05:46 <vincenz> ;)
09:05:48 <glguy> ?pl swing f c a = f ($ a) c
09:05:49 <lambdabot> swing = flip . (. flip id)
09:05:59 <vincenz> @pl swing f  = flip (f . flip ($))
09:05:59 <lambdabot> swing = flip . (. flip id)
09:06:02 <shapr> I think I saw Cale write it as (.).(.) also.
09:06:06 <shapr> hej Danten
09:06:07 <rahikkala> shapr: I think I'll just go with sjanssen's version rather than try to understand all the typespam ><
09:06:14 <glguy> wait, better idea:
09:06:20 <glguy> \functions value -> sequence functions value
09:06:20 <vincenz> UUStudent: #haskell.dut :)
09:06:23 <UUStudent> whoops. this works better than expected. :)
09:06:24 <Danten> hej
09:06:26 <shapr> rahikkala: Oh, swing is *really* easy.
09:06:36 <shapr> rahikkala: It inverts value and function.
09:06:36 <glguy> shapr: the shortest version was "sequence"
09:06:49 <sjanssen> glguy++ always bonus points for the (->) a monad
09:06:49 <glguy> > sequence [succ, pred, id] 5
09:06:51 <lambdabot>  [6,4,5]
09:07:02 <shapr> glguy: doh, you win today's Haskell golf.
09:07:09 <glguy> > let swing f c a = f ($ a) c in swing map [succ, pred, id] 5
09:07:10 <lambdabot>  [6,4,5]
09:07:23 <shapr> Danten: Learning Haskell? Long time user?
09:07:39 <glguy> rahikkala: here is your function B^D :    sequence
09:07:57 <Danten> kinda in the learning process :)
09:07:57 <shapr> glguy++ For great justice
09:08:03 <rahikkala> glguy++
09:08:04 <shapr> Danten: Have any questions?
09:08:19 <Danten> not really, but thanks
09:08:24 <shapr> glguy: I hadn't thought of (->) a
09:08:55 <shapr> Danten: Are you learning Haskell for business or pleasure?
09:09:02 <Danten> pleasure
09:09:12 <shapr> Good choice!
09:09:20 <shapr> In that case, may I give you a short tour of #haskell?
09:09:36 <Danten> huh?
09:09:45 <glguy> ?bot
09:09:45 <lambdabot> :)
09:09:56 <shapr> You'd like to get a quick overview of the tourist sites here on #haskell, right?
09:10:15 * mgdm would too
09:10:17 <mgdm> :)
09:10:19 <glguy> lol, #haskell is *so* friendly, we actually drive people off wanting to help
09:10:27 <Syzygy-> Ooooooooooh? Touristing? I'm in!
09:10:27 <Danten> well sure :P
09:10:34 <kilimanjaro> mgdm: Shh, you have to leave and rejoin this channel if you want the special treatment.
09:10:37 <mauke_> friend... friend...
09:10:39 <glguy> gift shop?
09:10:44 * shapr grins
09:10:48 <mgdm> kilimanjaro: Aww, that's too much effort :)
09:10:50 <glguy> you can leave the channel?
09:10:55 <shapr> glguy: Actually, there is a gift shop now that you mention it...
09:10:57 * glguy wonders what that means
09:11:37 <shapr> Danten: Anyway, the quick tour includes the channel bot, the channel logs, and the haskell wiki. The longer tour takes years, and is much fun.
09:11:38 <kilimanjaro> glguy: Maybe shapr will make you a historical landmark and you will get your own preservation society!
09:12:00 * shapr pours agile formeldahype onto glguy 
09:12:04 <glguy> ?remember kilimanjaroglguy: Maybe shapr will make you a historical landmark and you will get your own preservation society!
09:12:04 <lambdabot> Done memoising quote for `kilimanjaroglguy:', if that is their real name...
09:12:12 <glguy> ?remember kilimanjaro glguy: Maybe shapr will make you a historical landmark and you will get your own preservation society!
09:12:12 <lambdabot> Done memoising quote for `kilimanjaro', if that is their real name...
09:12:33 <mauke_> ?forget kilimanjaroglguy:
09:12:33 <lambdabot> Unknown command, try @list
09:12:38 <shapr> Danten: On your left you'll see lambdabot, holder of much nifty and educational code.
09:12:43 <glguy> mauke_: I think that's a job for vim
09:12:44 <shapr> > map (+1) [1..5]
09:12:45 <lambdabot>  [2,3,4,5,6]
09:12:49 <shapr> @type map
09:12:49 <Danten> :o
09:12:50 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
09:12:55 <shapr> @index any
09:12:55 <lambdabot> Data.List, Prelude
09:12:57 <dmhouse> ?src map
09:12:57 <lambdabot> map _ []     = []
09:12:58 <lambdabot> map f (x:xs) = f x : map f xs
09:13:02 <mauke_> @keal
09:13:02 <lambdabot> perhaps i just genius and never tested
09:13:04 * Danten notes
09:13:06 <dmhouse> ?quote
09:13:06 <lambdabot> nilsi says: #haskell is better than google
09:13:08 <glguy> ?yow
09:13:08 <lambdabot> In 1962, you could buy a pair of SHARKSKIN SLACKS, with a "Continental
09:13:09 <lambdabot> Belt," for $10.99!!
09:13:23 <dmhouse> ?hoogle forkIO
09:13:24 <lambdabot> Control.Concurrent.forkIO :: IO () -> IO ThreadId
09:13:24 <Syzygy-> It doesn't matter what you're trying to do - odds are lambdabot knows half of it.
09:13:24 <mauke_> @ghc
09:13:25 <lambdabot> ghc says: Generic method type is too complex
09:13:25 <shapr> Danten: On your right is the channel topic, which includes the url to the channel logs, and other useful advertising.
09:13:29 <Syzygy-> @shapr
09:13:29 * lambdabot smacks  about with a large trout
09:13:40 <mauke_> @shapr Syzygy-
09:13:41 * lambdabot slaps Syzygy-
09:13:44 <glguy> lol
09:13:50 <therp> lambdabot, fun for everyone
09:13:51 <shapr> Danten: In case your client doesn't show it, http://tunes.org/~nef/logs/haskell/
09:13:52 <Syzygy-> Hmmm... What was, then, the syntax to page shapr through lambdabot?
09:13:53 <lambdabot> Title: Index of /~nef/logs/haskell
09:13:57 <shapr> @get-shapr
09:13:57 <lambdabot> shapr!!
09:14:01 <glguy> shapr is just an insert change and a delete away from slap
09:14:01 <Syzygy-> That's it.
09:14:04 <Danten> oki
09:14:06 * shapr responds to the shapr-signal!
09:14:23 <Syzygy-> glguy: Ah! And lambdabot nowadays is that versatile in command parsing? Coool.
09:14:26 <shapr> I'm not really a superhero, I just play one on IRC.
09:14:29 <paolino> @hoogle repeatM
09:14:29 <lambdabot> No matches found
09:14:32 <shapr> So does nmessenger.
09:14:47 <shapr> Danten: Right there in front of you is the Haskell wiki, holder of many marvels
09:14:56 <shapr> Danten: http://www.haskell.org/haskellwiki/Special:Recentchanges
09:14:58 <lambdabot> Title: Recent changes - HaskellWiki
09:15:24 <Danten> alright
09:15:48 <shapr> Danten: New sites worth mentioning since the last tour I gave include http://planet.haskell.org/ and http://sequence.complete.org/hwn
09:15:49 <lambdabot> Title: Planet Haskell
09:16:02 <shapr> Danten: Any questions?
09:16:08 * Syzygy- realizes he has to keep away from catching up with his blogroll... Otherwise the homework I need to correct won't get done.
09:16:56 <kilimanjaro> Danten: The only appropriate answer to that is, "yes, I have many questions, but I don't want you to answer them".
09:17:01 * shapr laughs
09:17:05 <shapr> mgdm: Do you have any questions?
09:17:06 <Danten> ;)
09:17:21 <mgdm> mgdm: No, that was most informative, thank you :)
09:17:26 <mgdm> oops
09:17:28 <glguy> paolino: it's usually: forever x = x >> forever x
09:17:30 * shapr boings cheerfully
09:17:32 <mgdm> shapr: see above
09:17:44 <shapr> mgdm: Got it!
09:17:47 * mgdm does enough talking to himself as it is, never mind on IRC
09:18:10 * glguy notes that forever doesn't what it seems in Cont and Maybe and Either... and IO...
09:18:28 * Danten reached enlightenment
09:18:34 <shapr> Danten: OcksÂ finns det #haskell.se om du talar svenska.
09:18:47 <Danten> :)
09:19:16 <Syzygy-> @type forever
09:19:17 <lambdabot> Not in scope: `forever'
09:19:30 <Syzygy-> @define forever x = x >> forever x
09:19:31 <lambdabot> Undefined.
09:19:36 <mauke_> hahaha
09:19:36 <dmhouse> Monad comprehensions must have been awesome when they were around. They seem so expressive.
09:19:38 <glguy> you wanted ?let
09:19:43 <Syzygy-> @let forever x = x >> forever x
09:19:44 <lambdabot> Defined.
09:19:49 <Syzygy-> @type L.forever
09:19:50 <lambdabot> Couldn't find qualified module.
09:19:55 <Syzygy-> Bugger.
09:20:06 <glguy> ?type forever
09:20:08 <lambdabot> Not in scope: `forever'
09:20:19 <glguy> anyways: m a -> m b
09:20:21 <Syzygy-> > forever Nothing
09:20:22 <lambdabot>  Add a type signature
09:20:36 <Syzygy-> > L.forever (Nothing :: Maybe Int)
09:20:36 <lambdabot>  Add a type signature
09:20:42 <Syzygy-> > L.forever (Nothing :: Maybe Int) :: Maybe Int
09:20:43 <lambdabot>  Nothing
09:20:53 <Syzygy-> > L.forever (Just 2 :: Maybe Int) :: Maybe Int
09:20:56 <lambdabot> Terminated
09:21:33 <Terabyte> hey, could sombody explain what use does break have?
09:21:33 <glguy> Syzygy-: that's deep
09:21:47 <dmhouse> Terabyte: it splits a list on a predicate.
09:21:49 <Syzygy-> glguy: I dunno. I was just trying to find out what you were saying...
09:21:56 <dmhouse> > break (> 5) [1..10]
09:21:58 <lambdabot>  ([1,2,3,4,5],[6,7,8,9,10])
09:22:06 <Terabyte> i see
09:22:14 <glguy> > break (> 2) [1,2,3,4,3,2,1]
09:22:15 <lambdabot>  ([1,2],[3,4,3,2,1])
09:22:19 <glguy> > partition (> 2) [1,2,3,4,3,2,1]
09:22:19 <Syzygy-> > break (`div` 2 == 0) [1..10]
09:22:20 <lambdabot>      The operator `div' [infixl 7] of a section
09:22:20 <lambdabot>         must have lower prece...
09:22:20 <lambdabot>  ([3,4,3],[1,2,2,1])
09:22:29 <Syzygy-> > div (even) [1..10]
09:22:30 <lambdabot>  Couldn't match `a -> Bool' against `[a1]'
09:22:32 <dmhouse> > break (==':') "Referer: http://google.com"
09:22:33 <lambdabot>  ("Referer",": http://google.com")
09:22:34 <glguy> > span (<= 2) [1,2,3,4,3,2,1]
09:22:35 <lambdabot> Title: Google
09:22:35 <lambdabot>  ([1,2],[3,4,3,2,1])
09:22:51 <glguy> break p xs = span (not . p) xs
09:22:55 <glguy> or visa versa
09:23:01 <Terabyte> how come break (even) [1..10]
09:23:02 <Syzygy-> > break (even) [1..10] -- what I meant to write...
09:23:02 <Terabyte> doesnt work
09:23:04 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
09:23:07 <Terabyte> ah
09:23:11 <glguy> > partition even [1..10]
09:23:12 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
09:23:13 <vincenz> > break even [1..10]
09:23:15 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
09:23:20 <Syzygy-> ?src break
09:23:20 <lambdabot> break p =  span (not . p)
09:23:25 <Syzygy-> ?src span
09:23:26 <lambdabot> Source not found. I've seen penguins that can type better than that.
09:23:26 <vincenz> no need for () around even
09:23:32 <Terabyte> so yeah whats the difference between partition and break
09:23:39 <vincenz> Terabyte: it only goes until the condition is true
09:23:43 <Syzygy-> Terabyte: break stops working with a match.
09:23:46 <allbery_b> break stops at the first, partition runs the whole list
09:23:46 <dmhouse> > break even [1..10
09:23:46 <lambdabot>  Parse error
09:23:51 <dmhouse> > break even [1..10]
09:23:52 <lambdabot>  ([1],[2,3,4,5,6,7,8,9,10])
09:23:57 <dmhouse> > partition even [1..10]
09:23:59 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
09:24:02 <vincenz> @localtime dons
09:24:04 <lambdabot> Local time for dons is Thu Jan 11 04:19:59 2007
09:24:11 <Terabyte> oh rite
09:24:13 <glguy> > splitAt 3 [1..10] -- break and span are like splitAt with a predicate
09:24:18 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
09:24:45 * allbery_b thinks @localtime isn't ware dons is at HAC07
09:24:54 <vincenz> Woo this rocks
09:25:11 <vincenz> 2 days: haskell.dut > haskell.fr and haskell.de, and not only that, soon we'll have an influx of dutch students!
09:25:24 <Syzygy-> Neat.
09:25:54 <Syzygy-> vincenz: Was that dut > fr + de or dut > fr `max` de ?
09:25:59 <vincenz> earthy: is making a webchat tied into #haskell.dut for a haskell course
09:26:02 <dmhouse> allbery_b: it's 17:20 here in England, which is where Hac is.
09:26:03 <vincenz> Syzygy-: second
09:26:13 <Syzygy-> vincenz: Right.
09:26:25 <vincenz> max-user count: 13 (including lb)
09:26:31 <malebria> dons: why did you used runInteractiveProcess in typeof instead of simply runProcess?
09:27:45 <glguy> ?lusers
09:27:45 <lambdabot> Maximum users seen in #haskell: 315, currently: 297 (94.3%), active: 53 (17.8%)
09:28:04 <glguy> ?seen
09:28:04 <lambdabot> Lately, I have seen allbery_b, benja_, botje, dmhouse, dons, earthy, eelis, erg0t, glguy, kilimanjaro, kolmodin, malebria, mauke_, mgdm, mwc, paolino, samus_, sebazzz, shapr, sjanssen, syzygy-,
09:28:04 <lambdabot> terabyte, therp, vincenz and xdie.
09:28:09 <dons> malebria: hmm, not sure.
09:28:44 <dons> allbery_b: yeah, my irc is 16,000 kms away :)
09:28:46 <malebria> dons: you should add a link to it in your page, I tried to find it some days ago but I couldn't.
09:28:56 <dons> malebria: yeah good idea
09:29:04 * mgdm wanders off
09:29:06 * allbery_b does the same thing but rarely gets that far away from the vnc session :)
09:30:58 <shapr> dmhouse: Can you give some examples of monad comprehensions?
09:31:07 <cperfumo> sjanssen: Which part of the commentary is supposed to explain that?
09:32:02 <sjanssen> cperfumo: not sure
09:32:24 <sjanssen> but if the documentation you seek exists, it is in the commentary
09:32:51 <tuukkah> shapr, any list comprehension, but the type is generalized, right?
09:33:04 <cperfumo> sjanssen: I mean... it should be a "how-to" or something like that that explains the way to do such an important thing, right?
09:33:12 <glguy> Maybe comprehension: [f x | x <- find pred xs]
09:33:21 <cperfumo> does anyone else hav any idea?
09:33:27 <cperfumo> have, sorry
09:33:40 <sjanssen> cperfumo: extending GHC's RTS is also a very uncommon thing
09:33:49 <sjanssen> I doubt there is any specific information
09:33:59 <sjanssen> certainly not a walkthrough
09:35:29 <shapr> But hey, if you like extending GHC, try #ghc
09:35:29 <dmhouse> shapr: I was reading http://citeseer.ist.psu.edu/wadler92comprehending.html, which seems to be one of the original papers introducing monads to functional programming.
09:35:31 <lambdabot> Title: Comprehending Monads - Wadler (ResearchIndex)
09:35:43 <dmhouse> shapr: it seems they basically take the place of do blocks, so I'm not sure they were actually that fantastic.
09:35:49 <dmhouse> do blocks are probably clearer.
09:36:33 <vincenz> dmhouse: btw, I got a GREAt comment from a colleague of mine (he's a very smart guy) wanting to learn haskell.  I showed him wikibook and he said it's very well written
09:36:41 <dons> shapr: you saw http://www.stonecode.org/blog/?p=101 ?
09:36:46 <lambdabot> Title: Stone Code Weblog ¬ª Blog Archive ¬ª Haskell, first impressions (with sexy resul ...
09:36:47 <bakert> ?where wikibook
09:36:47 <lambdabot> http://en.wikibooks.org/wiki/Haskell
09:36:58 <vincenz> dons: earthy is putting #haskell.dut on a website of a course that teaches haskell with javachat :)
09:37:13 <vincenz> dons: so soon we'll have a ton of UU students ;)
09:37:25 <dons> mm. cool!
09:37:30 <dons> and you have a lambdabot in there?
09:37:32 <shapr> dons: Yeah, thought it was entertaining.
09:37:36 <dmhouse> vincenz: great! :)
09:37:48 <vincenz> dons: well, hmm, yours
09:37:57 <dons> first impressions == impression of the community .... remember this everyone!
09:38:05 <shapr> Yup :-)
09:38:06 <malebria> dons: In typeof, are the MVars really necessary even with waitForProcess?
09:38:26 <dons> I think that's just being overly cautious :)
09:38:31 <vincenz> dons: he put both #haskell and #haskell.dut on the webpage, but warned that #haskell is very busy (he's gonna have > 100 students, so perhaps it's best they don't all come into here)
09:38:33 <malebria> dons: =D
09:38:36 <dmhouse> The Wikibook is a collaboration between mostly kowey and myself, it's aimed at people who've never programmed before, although we're aiming to give comprehensive coverage to the advanced topics in functional programming and Haskell, which is where I think the wikibook is really exciting.
09:40:20 <bakert> I see from the purple links that I've googled my way to a few of the wikibook's pages already in my nosing through haskell.
09:40:39 <dmhouse> :)
09:41:02 <dmhouse> I think I'm finally beginning to grok how categorical monads and Haskell monads intertwine.
09:41:36 <dons> vincenz: and the plan is to use lambdabot?
09:41:41 <dons> we better make sure it stays stable..
09:42:01 <bakert> Is there any documentation for Text.Html anywhere?  Apart from the "first example" page?
09:42:15 <dmhouse> bakert: Haddock?
09:42:32 <dmhouse> bakert: that module's particularly badly documented, IIRC. I used the source as a reference quite a bit.
09:42:56 <bakert> dmhouse, yes i suppose that's what i need to do ... it will probably be quite simple looking at the source.
09:43:31 <therp> yes, my embedded prolog compiler is working, jiha! actually that would be prolog->liskell->haskell->core compiler :>
09:48:15 <vincenz> dons: Unless you have strong objections?
09:48:34 <bakert> therp, that sounds dangerous!
09:48:45 <dons> vincenz: no . its great news :)
09:48:53 <vincenz> Cool :)
09:57:31 <dmhouse> What's LaTeX for function composition?
09:58:28 <therp> \circle?
09:59:24 * glguy was trying to figure out how you could have "function composition" in LaTeX
09:59:43 <kosmikus> dmhouse: \circ or \cdot, depending on what you
09:59:46 <kosmikus> like
10:00:09 <dmhouse> kosmikus: thanks.
10:01:35 <vincenz> stupid question
10:01:38 <vincenz> let's say you have a definition
10:01:42 <vincenz> a ::= A | B | C
10:01:46 <vincenz> but it doesn't fit on one line so you have
10:01:50 <vincenz> a ::= A | B
10:01:52 <vincenz>      | C
10:01:55 <vincenz> do you add ... and where?
10:02:13 <vincenz> "a ::= A | B | ...  \n ... | C"     ?
10:02:46 <Syzygy-> vincenz: I would probably do, in that case, a ::= A \n |B \n |C \n ...
10:02:50 <Syzygy-> At least in source code.
10:02:54 <vincenz> it's not source code
10:02:57 <Syzygy-> Gives you nice room for comments too.
10:03:03 <vincenz> it's a latex file
10:03:08 <vincenz> and it's not a data definition
10:03:09 <Syzygy-> Outside source it's very very much a question of aesthetics.
10:03:18 <vincenz> it's formal semantics, was hoping someone who knew about it
10:03:32 <glguy> "a ::= A | B | ...  \n ... | C" -- wouldn't think imply some sort of rang?
10:03:33 <glguy> e
10:03:53 <glguy> s/think/this
10:04:18 <vincenz> SyntaxNinja: you probably know this:  when denoting an AST "a ::= A | B | C"  but it doesn't fit on one line, do you do "a ::= A | B |  ... \n ... | C" or do you not put ... on the second line (or no | on the second line to start with)?
10:06:14 <araujo> hello around here.
10:06:23 <SyntaxNinja> vincenz: what's the context here? happy? human-readable convention?
10:06:25 <glguy> haven't seen him
10:06:48 <vincenz> SyntaxNinja: human-readable for a pdf
10:06:59 <vincenz> for a paper, in fact :)
10:07:02 <bringert> SyntaxNinja: I pushed cabal-install to the Cabal repo now
10:07:18 <bringert> it seems to build and it works for me
10:07:25 <SyntaxNinja> bringert: woohoo!
10:07:31 <kosmikus> vincenz: don't put dots; dots suggest something's missing
10:07:33 <vincenz> bringert: or if you know , you can answer :)
10:07:34 <bringert> it was a messy merge
10:07:43 <vincenz> kosmikus: just start a fresh line starting with a |?
10:07:46 <vincenz> a ::= A | B
10:07:48 <vincenz>     | C
10:07:49 <SyntaxNinja> bringert: try removing all traces of cabal and cabal-install (from ghc-pkg and /usr/local or whatever) then "sudo make install" and make sure it works :)
10:07:55 <SyntaxNinja> vincenz: I have no idea what the convention is
10:08:00 <vincenz> Alright, thanks
10:08:01 <kosmikus> vincenz: yes
10:08:06 <bringert> SyntaxNinja: removing cabal sounds danagerous
10:08:06 <vincenz> kosmikus: rather ugly, no?
10:08:18 <SyntaxNinja> bringert: I do it all the time! :)
10:08:30 <SyntaxNinja> make install always gets it back.
10:08:45 <SyntaxNinja> if you squirrel away a copy of cabal-setup you don't even need to bootstrap
10:08:45 <vincenz> kosmikus: and what if you have "let's assume we have model 1:  a ::= A | B | C" and we extends this (would you then write) "a ::= ... | D" ?
10:08:54 <kosmikus> vincenz: if the | C part is short compared to the previous line, it's ugly; but not in general
10:09:07 <kosmikus> vincenz: yes
10:09:11 <SyntaxNinja> I'm glad to hear, though, that Cabal is so great that people are afraid to remove it ;)
10:09:15 <vincenz> alright, thank you for the feedback :)
10:09:44 <vincenz> kosmikus: the | on the new line or the end of the previous one?
10:09:59 <vincenz> "a ::= A  | B | \n C" or " \n | C"
10:10:26 <kosmikus> glguy: btw, function composition in LaTeX would be much like in Haskell: \newcommand\comp[3]{#1{#2{#3}}
10:11:03 <kosmikus> vincenz: I see | as an operator, so I'd put it on the new line; I'd also break before rather than after a +
10:11:24 <kosmikus> vincenz: there are some people who put the operator both on the end and the beginning of the line, but I don't like that
10:11:45 * vincenz nods
10:11:53 <glguy> reminds me of the old german way of hyphenating words at the ends of lines
10:11:55 <vincenz> Alright, thanks for the feedback :)
10:12:01 <earthy> there.
10:12:04 <earthy> http://www.cs.uu.nl/wiki/FP/HowToGetHelp
10:12:06 <lambdabot> Title: FP / How To Get Help
10:12:10 <paolino> is there any freebsd user ?
10:12:18 <earthy> that should teach students to tread gently when entering the Haskell community. :)
10:12:59 <vincenz> earthy: typo
10:13:02 <vincenz> earthy: freenode not feenode
10:13:04 <vincenz> on irc page
10:13:28 <vincenz> kosmikus++ -- for feedback
10:13:30 <kosmikus> hehe, feenode
10:13:53 <earthy> whoos. :)
10:13:53 <kosmikus> that should keep them away ;)
10:13:59 <earthy> :P
10:14:09 <glguy> asking smart questions in #haskell isn't so much about making sure you get an answer as making sure you get the answer you were looking for ;)
10:14:21 <earthy> glguy: good point.
10:15:31 <kosmikus> earthy: good page
10:15:46 <glguy> People asking homework questions should also learn to be less specific
10:15:52 <earthy> glguy: fixed that. makes the page even stronger.
10:16:52 <glguy> #2 How do I write nub using foldr?
10:17:13 <vincenz> very carefuly
10:17:23 <Botje> with an editor, preferably
10:17:32 <vincenz> and a keyboard
10:17:46 <Botje> speech recognition :p
10:17:53 <vincenz> and by extension your fingers or mouth
10:17:59 <glguy> > let nub xs = foldr (\x xs -> if x `elem` xs then xs else x:xs) [] xs in nub "these are all good answers!"
10:18:00 <lambdabot>  "thlgod anwers!"
10:18:18 <Botje> vincenz: don't forget brains!
10:18:24 <vincenz> > nub "these are all good answers"
10:18:25 <lambdabot>  "thes arlgodnw"
10:18:27 <vincenz> Botje: that's optional
10:18:34 <complaisant> ?paste
10:18:34 <lambdabot> http://paste.lisp.org/new/haskell
10:18:36 <glguy> > let nub xs = foldl (\xs x -> if x `elem` xs then xs else x:xs) [] xs in nub "these are all good answers!"
10:18:37 <lambdabot>  "!wndoglra seht"
10:18:42 <glguy> heh
10:18:55 <glguy> > let nub xs = reverse $ foldl (\xs x -> if x `elem` xs then xs else x:xs) [] xs in nub "these are all good answers!"
10:18:56 <lambdabot>  "thes arlgodnw!"
10:19:02 <vincenz> eww
10:19:21 <shapr> complaisant: I didn't understand your question.
10:19:32 <vincenz> > let nub xs = foldr (\x xs -> x:(filter (/= x) xs))
10:19:32 <lambdabot>  Parse error
10:19:46 <vincenz> > let nub xs = foldr (\x xs -> x:(filter (/= x) xs)) [] xs in nub "these are all good answers"
10:19:47 <lambdabot>  "thes arlgodnw"
10:19:54 <lisppaste2> complaisant pasted "data.Map" at http://paste.lisp.org/display/34785
10:20:01 <vincenz> of course mine is not very efficient
10:20:20 <vincenz> complaisant: eh?
10:20:21 <glguy> ?src nub
10:20:21 <lambdabot> nub = nubBy (==)
10:20:26 <glguy> ?src nubBy
10:20:26 <lambdabot> nubBy eq []             =  []
10:20:27 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:20:27 <vincenz> @src nubBy
10:20:27 <lambdabot> nubBy eq []             =  []
10:20:27 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:20:33 <vincenz> yep
10:20:35 <glguy> vincenz for the win
10:20:37 <vincenz> seems that it's my system :)
10:20:56 <dpiponi> I've never successfully built darcs, either on MacOS X or Linux
10:21:06 <complaisant> vincenz : i want to create a new tab .. but i dont know howto
10:21:07 <dpiponi> Can anyone help?
10:21:19 <dpiponi> Lcs.lhs:433:8: Not in scope: type constructor or class `HasBounds'
10:21:31 <allbery_b> I failed to build darcs on OSX and eventually pulled down an olderbinary package
10:21:34 <glguy> dpiponi: and you are using macports?
10:22:01 <dpiponi> I just downloaded the source
10:22:07 <glguy> dpiponi: port install darcs
10:22:17 <vincenz> complaisant: you assume we understand what your code is supposed to do and what a "new tab" is
10:22:18 <glguy> worked like the charm for me
10:22:38 <dpiponi> What is 'macports' anyway?
10:22:53 <dpiponi> Is it like fink?
10:22:55 <allbery_b> www.macports.org
10:23:02 <allbery_b> fpormerly known as darwinports
10:23:10 <dpiponi> Ah
10:23:19 <allbery_b> it's modeled after freebsd ports:  it's a framework for building packages from source
10:23:31 <allbery_b> so, somewhat like fink, but not
10:23:43 <dpiponi> I like freebsd ports. But iuf the source doesn't build, should that be submitted as a bug?
10:23:46 <allbery_b> (since fink installs prebuild packages)
10:23:49 <glguy> complaisant: you wrote: data Tab = Map Int (Map Int Marker)
10:23:50 * vincenz read a funny thing in the newspaper on darwin-awards for 2006
10:23:51 <allbery_b> yes
10:23:57 <glguy> so you create a new tab with "Map"
10:24:21 <glguy> complaisant: you meant: data Tab = Tab (Map Int (Map Int Marker))
10:24:23 <vincenz> The darwin-awards went to a couple that made a huge helium baloon so they would sound funny, they forgot that inside such a big balloon they could stand in with only helium there'd be no oxigen
10:24:28 * vincenz lols
10:24:38 <dpiponi> Thanks
10:24:45 <vincenz> oxygen even
10:25:29 <glguy> complaisant: or maybe you mean: type Tab = 12:20  vincenz> The darwin-awards went to a couple that made a huge helium baloon so they would sound funny, they forgot that inside such a big balloon they could stand in with only helium there'd be no oxigen
10:25:34 <glguy> errr
10:25:41 <glguy> complaisant: maybe you meant: type Tab = Map Int (Map Int Marker)
10:26:59 <glguy> complaisant: in that case, you create a new Tab like this: Data.Map.empty
10:27:20 <complaisant> yep
10:27:22 <complaisant> type
10:27:46 <glguy> complaisant: also, you have to insert into a map with a key
10:27:55 <glguy> insert $ replicate l (insert c Empty) -- so this won't work
10:28:03 <complaisant> glguy but if i create a newtab like that i won't have limits
10:28:32 <complaisant> & want to insert l * c elems
10:28:42 <complaisant> with marker Empty
10:28:54 <glguy> complaisant: you have to have a key to insert an element
10:30:13 <paolino> @src replicate
10:30:14 <lambdabot> replicate n x = take n (repeat x)
10:31:23 <glguy> ?unpl (. repeat) . take
10:31:23 <lambdabot> (\ d g -> take d (repeat g))
10:40:56 <lisppaste2> paolino pasted "Shuffle module" at http://paste.lisp.org/display/34792
10:41:24 <paolino> comments and improvements are very welcome
10:42:49 <glguy> Is this being run on a particularly large dataset?
10:43:17 <paolino> not yet
10:43:39 <paolino> should I ?
10:44:07 <glguy> I just wanted to know if you are targeting performance, readability, correctness, etc
10:44:22 <Masklinn> doesn't one always target correctness anyway?
10:44:36 <glguy> Masklinn: as in "perfect shuffle"
10:44:39 <glguy> algorithm
10:44:42 <Masklinn> oh
10:44:54 <glguy> that's what I meant..
10:45:03 <Masklinn> yeah I didn't understand that, sorry
10:45:12 <paolino> this is the imperative algorithm mentioned there
10:45:37 <Masklinn> but it's not like you can get a "perfect" shuffle from a pseudorandom computer source can you?
10:45:38 <paolino> which should be correct
10:46:02 <paolino> aside the prng correctness
10:46:08 <glguy> Masklinn: you can get an imperfect shuffle from a random source, however
10:46:16 <paolino> sure
10:46:27 <glguy> so the point is to make the algorithm correct
10:46:33 <glguy> and then only as good as the source
10:46:44 <Masklinn> I understood, I was just trying to annoy you :p
10:46:54 <glguy> ah
10:47:30 <paolino> readability and performance are both targeted as I'm just learning haskell
10:48:24 <paolino> perforamnce mainly
10:49:38 <dmhouse> Would it be valid to say functors in Haskell are from the category of Haskell types and functions Hask to the subcategory defined by that functor? I.e. [] : Hask -> Lst, where Lst is the category of list types and functions lifted to list types?
10:50:26 <dmhouse> I noticed that functors are normally said to be endofunctors in Hask but this seems like a more accurate description.
10:54:57 <paolino> how do I force evaluation of
10:54:59 <paolino>  evalState (replicateM 2000 $ shuffle [1..100]) gen0
10:54:59 <paolino> without printing the result ?
10:55:32 <lisppaste2> glguy annotated #34792 with "paolino, same algorithm? or at least same idea?" at http://paste.lisp.org/display/34792#1
10:56:20 <lisppaste2> paolino pasted "Shuffle module" at http://paste.lisp.org/display/34795
10:57:06 <jethr0> paolino: maybe something like "let x = evalState ... in x `seq` x" ?
10:57:06 <paolino> wtf, sorry
10:57:41 <paolino> I destroyed your annotation glguy :(
10:57:54 <jethr0> :t ($!)
10:58:22 <paolino> @src seq
10:58:22 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:58:32 <bd_> jethr0: ($!) :: (a -> b) -> a -> b
10:58:43 <bd_> weird that lambdabot didn't respond
10:58:52 <bd_> and seq is a primitive
10:58:52 <glguy> a $! b = b `seq` a b
10:58:54 <jethr0> bd_: thx
10:59:18 <dpiponi> dmhouse: You ask "Would it be valid to say..." I'd say maybe yes, but it's no more 'accurate'.
10:59:20 <jethr0> the bots have been kinda flaky since yesterday evening
10:59:28 <bd_> @botsnack
10:59:28 <lambdabot> :)
10:59:31 <bd_> :t ($!)
10:59:32 <lambdabot> forall b a. (a -> b) -> a -> b
10:59:34 <shapr> @users #haskell
10:59:34 <lambdabot> Maximum users seen in #haskell: 315, currently: 298 (94.6%), active: 51 (17.1%)
10:59:36 <bd_> there we go :)
10:59:49 <shapr> New high water mark, 315.
10:59:50 <dmhouse> dpiponi: it seems to give more information, then.
10:59:52 <bd_> bribery works, I guess
10:59:55 <jethr0> or maybe they're just ignoring me
11:00:11 <shapr> jethr0: did you say something?
11:00:17 * shapr teases jethr0 
11:00:38 <dpiponi> It's like saying that \x -> x^2 is of type Float->NonNegativeFloat instead of Float->Float
11:00:50 * jethr0 thinks shapr might be able to read his mind since he couldn't possibly have read my postings
11:01:07 <paolino> jethr0: that prints the result the same
11:01:33 <paolino> glguy: can you repaste your annotation please ?
11:01:43 <dmhouse> dpiponi: which would be useful, because you could then define a total function sqrt :: NonNegativeFloat -> NonNegativeFloat and compose them with the validness of this composition guaranteed statically by the type system.
11:01:52 <shapr> jethr0: :-)
11:02:04 <dmhouse> dpiponi: so I say it's a useful formulation.
11:02:12 <glguy> k
11:02:15 <jethr0> hmm
11:02:25 <dpiponi> dmhouse: But that can be kinda awkward because then you have to deal with the inclusion NonNegativeFloat->Float. Just depends on what you're doing.
11:03:13 <glguy> paolino: I noticed a bug that I'm fixing first
11:03:21 <dmhouse> dpiponi: given some subtyping, though, it'd be nice, yes?
11:03:22 <paolino> ok
11:03:26 <dmhouse> I guess I see your point, though.
11:03:46 <dpiponi> dmhouse: Isn't that the sort of thing epigram is good at?
11:03:51 <paolino> anyway I didn't destroy it, I paste another identical page
11:04:00 <dmhouse> dpiponi: I wouldn't really know.
11:04:13 <dmhouse> dpiponi: unless that was more of a rhetorical statement. :)
11:04:28 <dpiponi> dmhouse: http://www.e-pig.org/
11:04:28 <lambdabot> Title: Epigram
11:04:31 <wy> Hi all. I'm back
11:04:52 <ohmega> dpiponi: http://www.cs.chalmers.se/~ulfn/agdaLight/index.html
11:04:54 <lambdabot> Title: AgdaLight
11:04:58 <ohmega> dpiponi: that's my new favourite language :)
11:05:20 <shapr> hi wy
11:05:38 <dmhouse> dpiponi: thanks, then.
11:05:43 * dmhouse has to dash
11:05:55 <wy> I remember that there is someone here trying to develop another language that has typing features like Haskell but has syntax like Lisp
11:06:00 <wy> Hi shapr
11:07:13 <dpiponi> ohmega: The AgdaLight web site is a bit...er...light. Are there some examples online?
11:07:18 <ohmega> agdaLight is like epigram but a lot more like haskell
11:07:20 <lisppaste2> glguy pasted "paolino my code" at http://paste.lisp.org/display/34797
11:09:14 <paolino> :t gets
11:09:15 <lambdabot> forall a (m :: * -> *) s. (MonadState s m) => (s -> a) -> m a
11:09:18 <ohmega> dpiponi: hm, there are a few examples included. this is what i'm currently working on though: http://sonata.csbnet.se/testing.al
11:10:23 <lisppaste2> glguy annotated #34797 with "bug found" at http://paste.lisp.org/display/34797#1
11:10:24 <wy> @users
11:10:24 <lambdabot> Maximum users seen in #haskell: 315, currently: 293 (93.0%), active: 42 (14.3%)
11:10:33 <dpiponi> ohmega: Greek characters, blackboard bold, subscripts. Now that's how Haskell should look :-)
11:10:41 <ohmega> yes!
11:11:14 <ohmega> you become addicted to UTF-8 after a while :)
11:11:22 <jethr0> it would make haskell look even more "mathy" to newbies though. although i'm all for those features myself
11:11:33 <paolino> glguy , that [hi,hi-1,lo] is [hi,hi-1..lo] ?
11:11:40 <glguy> yeah, that was the bug i found
11:11:46 <ohmega> jethr0: it would attract math people :)
11:12:00 <dpiponi> I'm finding that code remarkably readable myself. Of course Greek characters need to be optional :-)
11:12:07 <jethr0> i don't think that's very high on haskell's TODO list, though
11:12:13 <glguy> where is this greek code?
11:12:23 <dpiponi> http://sonata.csbnet.se/testing.al
11:12:30 <mahogny> I think haskell has already sucked up all the math people. now the question is how to suck up the rest. greek characters might have a bad effect :)
11:12:31 <wy> Sorry I'll ask again. I remember that there is someone here trying to develop another language that has typing features like Haskell but has syntax like Lisp?
11:12:50 <dpiponi> Maybe it would attract Greek people too
11:12:59 * dpiponi ducks
11:13:24 <jethr0> problem with greek letters is that my "inner code voice" and "symbol rememberer" don't instantaneously remember their names and are giving me a hard time :(
11:13:24 <ohmega> dpiponi: you could probably understand the code for (<=) and isLeq, isLeq tries to find proof that m ‚â§ n
11:13:48 <jethr0> wy: no idea
11:14:26 <ohmega> dpiponi: you can only construct an element of m <= n (or a proof of that proposition, which is the same thing) if in fact m ‚â§ n
11:15:02 <dpiponi> jethr0: I can sympathise a bit. In my head xi/zeta are represented as "the character that's like a zeta or xi but has/hasn't an extra squiggle"
11:15:09 <wy> I still feel the syntax is not good enough. Sometimes I have to write some redundant code. That's not fun
11:16:24 <jethr0> dpiponi: yeah, with the most common letters i'm quite familiar, but until recently i didn't even know that omicron existed
11:17:02 <jethr0> wy: are you missing lisp-style macros or what exactly are you missing from "syntax"?
11:17:22 <Cale> You know you're in math when you don't know a word of Greek and your handwritten lowercase zeta and xi start to look like they should.
11:17:28 <wy> jethr0: something like macros
11:17:43 <dpiponi> I guess people don't use omicron for obvious reasons.
11:18:08 <wy> I thought I don't need macros. But now I realized it can save a lot of typing
11:19:00 <glguy> paolino: still around?
11:19:07 <jethr0> wy: there sure are some cases where lisp-style macros are superior to what haskell offers (even including template haskell). but often enough sufficiently high-order functions do the job just nicely
11:19:16 <jethr0> wy: do you have an example of "forced" code duplication?
11:19:45 <apfelmus> Cale: alas, xi is easy, but a shiny zeta is not
11:20:21 <Cale> Yeah, it's harder to leave that middle loop out.
11:20:36 <wy> jethr0: Something with tuples. I have written a program where I was force to write functions like pThen, pThen3, pThen4, pThen5, ...
11:20:56 <wy> jethr0: Just for different tuple sizes
11:21:22 <jethr0> yes, i agree. this can be solved very easily with template haskell, but it's not quite as integrated as it might be
11:21:40 <apfelmus> wy: this surely calls for type class hackery
11:22:13 <glguy> shuff a = foldM f a [hi, hi - 1 .. lo]
11:22:13 <glguy>   where (lo,hi) = bounds a
11:22:13 <glguy>         f a u = liftM (swap a u) (getRandomR (lo,u))
11:22:13 <glguy>         swap a x y = a // [(x,a!y),(y,a!x)]
11:22:14 <jethr0> i can see it before me: "The new Oleg Paper - Writing Template Haskell in the Type System"
11:22:26 <apfelmus> hehe
11:23:11 <apfelmus> but in fact, i think that with a slightly augmented type system, that would work
11:24:07 <jethr0> the type system (with extensions) already being turing complete i don't see how it doesn't already (except for file input, ... :)
11:25:07 <jethr0> on the wiki it says that "seq breaks parametericity". any ideas what that means apart from the fact that "seq" forces evaluation?
11:25:34 <apfelmus> turing completeness does not mean that you can express all template haskell programs
11:25:40 <avnit> is there an easy way to download an html page and convert the html to some kind of haskell data structure programatically?
11:26:12 <jethr0> hmm
11:26:17 <sjanssen> avnit: there is an HTML library
11:26:27 <sjanssen> I don't know if it parses HTML though
11:26:47 <avnit> i don't think it does...
11:27:01 <jethr0> avnit: as you can't alter haskell code without template haskell, there's little sense in parsing to "haskell". or am i overlooking something?
11:27:22 <avnit> well, i mean a DOM representation of the html
11:27:49 <sjanssen> avnit: can you restrict yourself to XHTML?
11:27:51 <apfelmus> avnit: difficult, because most html pages do not adhere to any standard. otherwise, HaXml has support for that
11:27:52 <avnit> there should be an easier way than parsec right?
11:27:58 <arjanb> jethr0: it breaks some properties as in 'theorems for free' from Wadler
11:28:01 <sjanssen> because there are plenty of XML libraries
11:28:02 <wy> jethr0: Can there be a proof that we don't need macros? I can't stand the feel of imperfection
11:28:19 <avnit> hmm... i don't think so, i'd need plain html as well
11:28:29 <e_e_coli> you could always preprocess with tidy
11:28:54 <avnit> does tidy guarantee xhtml compliance?
11:29:10 <glguy> HXT doesn't need xhtml compliance to parse
11:29:11 <sjanssen> avnit: there is an -asxml flag
11:29:18 <avnit> something like http://code.whytheluckystiff.net/hpricot/
11:29:20 <lambdabot> Title: Hpricot, a fast and delightful HTML parser
11:29:25 <jethr0> wy: i do think that in some cases macros would be great, but after using TH i realized that typed ASTs make hard work what in lisp is chaotic fun
11:29:29 <sjanssen> -asxml         to convert HTML to well formed XHTML
11:29:52 <avnit> ok, but then how do i parse the xhtml?
11:30:00 <fasta> Why does the State monad give a stack overflow when used like on the mailing lists(adding 1 a large number of times)?
11:30:05 <glguy> avnit: HXT can parse HTML
11:30:18 <apfelmus> jethr0: "parametricity" means that (forall a) means that the thing of type a may not be inspected further. `seq` itself does not fulfill that
11:30:21 <sjanssen> avnit: take your pick of any number of XML libs, hxt, haxml
11:30:43 <avnit> ok, so i need to convert to xhtml and then load into a xml library?
11:30:53 <glguy> avnit: HXT can parse HTML
11:31:04 <sjanssen> avnit: maybe not.  glguy has repeatedly said that HXT can parse HTML
11:31:06 * e_e_coli smiles at glguy's patience
11:31:07 <avnit> ok, cool. thanks.
11:31:10 <glguy> can anyone else seem me/
11:31:20 <avnit> yeah, sorry
11:31:51 <glguy> there is a parser flag in HXT you should try: (a_parse_html,v_1) -- or something close
11:31:56 <apfelmus> fasta: good question.
11:31:56 <apfelmus> @let f = do {n <- get; put $! (n+1) } :: State Int ()
11:31:57 <lambdabot> Defined.
11:32:21 <apfelmus> > flip evalState undefined . sequence_ . replicate 10000 $ f
11:32:23 <lambdabot>  ()
11:32:31 <avnit> sounds good
11:32:31 <apfelmus> > flip evalState undefined . sequence_ . replicate 1000000 $ f
11:32:33 <lambdabot>  ()
11:32:35 <glguy> > execState (replicateM_ 1000 f) 1
11:32:36 <lambdabot>  1001
11:32:40 <glguy> > execState (replicateM_ 1000000 f) 1
11:32:42 <lambdabot>  Exception: stack overflow
11:33:00 <ohmega> does GHC 6.6 have full support for UTF-8 by the way?
11:33:02 <apfelmus> ?src replicateM_
11:33:03 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
11:33:22 <sjanssen> ohmega: it supports UTF-8 in source files
11:33:37 <wy> jethr0: So do you mean you prefer TH?
11:33:49 <sjanssen> ohmega: and some keywords have character replacements, forall is one
11:33:59 <ohmega> nice
11:34:10 <apfelmus> fasta: the point is that while the state delivered by f threaded in a strict way, the whole pair (a,s) returned by f is not.
11:34:40 <Cale> ‚àÄ
11:34:54 * e_e_coli boggles
11:35:33 <apfelmus> ‚àÉ
11:35:43 * sjanssen wonders whether UTF-8 will work now that lambdabot is GHC 6.6
11:35:55 <fasta> apfelmus: is there some picture displaying what happens or otherwise just text that says what thunks are being built up?
11:36:04 <ohmega> @pl f œÉ = œÉ
11:36:05 <lambdabot> (line 1, column 4):
11:36:05 <lambdabot> unexpected "\131"
11:36:05 <lambdabot> expecting variable, "(", operator or end of input
11:36:24 <sjanssen> ohmega: pl won't be able to handle it
11:36:45 <wolverian> ?version
11:36:45 <lambdabot> lambdabot 4p448, GHC 6.5 (OpenBSD i386)
11:36:45 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:37:02 <wolverian> that's no 6.6!
11:37:04 <apfelmus> fasta: neither, currently
11:37:11 <ohmega> > (\œÉ -> œÉ) 1
11:37:11 <lambdabot>  Illegal character ''\131''
11:37:14 <sjanssen> ohmega: while GHC can read source in UTF-8, the IO routines do not support UTF-8
11:37:30 <jethr0> wy: hmm, prefer to what?
11:37:41 <sjanssen> ah, so dons still hasn't upgraded, apparently
11:37:48 <Cale> ‚ÖÅ -- too bad I don't have a font with this character
11:37:54 <shapr> ookk: Oook! Oook?
11:37:55 <jethr0> TH is annoying to work with, whereas lisp macros will twist your brain (in a bad way) if they get complicated enough
11:38:05 <wy> jethr0: to lisp macros?
11:38:29 <wolverian> sjanssen, does hs-plugins work now on ghc6.6?
11:38:41 <jethr0> TH pretty much takes the fun out of programming (at least for me) that haskell put there again
11:38:49 <sjanssen> wolverian: nope
11:39:01 <sjanssen> wolverian: so dons obviously hasn't upgraded :)
11:39:03 <wy> jethr0: So you generally think metaprogramming is no fun?
11:39:11 <jethr0> no!
11:39:14 <wolverian> sjanssen, well, duh. :) that's what I'm waiting for. :)
11:39:35 <glguy> the only compelling case for macros that I saw for TH was use to generate Ruby style string replacement for a SafeStrings library: $(q"This includes #{varname} variables")
11:39:38 <mahogny> jethr0, twisting your brain is a sign of language being to complicated :)
11:39:50 <jethr0> i generally think that statically typed meta-programming can be very time consuming. and that lisp macros are a very sharp instrument to be used sparingly and by well-trained personel
11:40:01 <glguy> mahogny: or of learning something new
11:40:18 <mahogny> glguy, at times. depends on if it gets the job done in a better way or not
11:40:39 <fasta> jethr0: what do you mean by "lisp"?
11:41:11 <jethr0> Everyone knows that debugging is twice as hard as writing a program in the first place. So if you're as clever as you can be when you write it, how will you ever debug it? (Brian Kernighan)
11:41:22 <glguy> I've always hated that quote
11:41:44 <mahogny> jethr0, right on. totally agree. macros are evil
11:41:53 <jethr0> i find it very applicable, at least when you're doing low-level imperative coding and getting all mixed up in the "complexity"
11:42:03 <jethr0> i'm still not saying that
11:42:07 <vincenz> hah
11:42:08 <avnit> yes, if you write something really cleverly, it shouldn't have to be debugged as much as something written not as cleverly
11:42:19 <vincenz> people should disambiguate complex from complicated
11:42:24 <jethr0> fasta: i mean common ansi lisp
11:42:26 <shapr> vincenz: Yeah
11:42:35 <mahogny> clever code should mean clever as in "won't have to be debugged, easy to maintain"
11:42:38 <ohmega> f ‚à∑ œÉ ‚Üí œÑ
11:42:42 <ohmega> looks nice doesn't it
11:42:47 <vincenz> ohmega: ooooh
11:42:47 <avnit> mayhogny: exactly
11:42:47 <mahogny> eew
11:43:14 <mahogny> ohmega, and where did all the material constants go? :)
11:43:19 <apfelmus> ohmega: sure, but its ‚ä•
11:43:36 <vincenz> apfelmus: and you know how we all like @ss
11:43:38 <apfelmus> *it's
11:43:46 <apfelmus> @ss
11:43:47 <lambdabot> Maybe you meant: . ask bf ft id msg pl src v wn
11:43:47 <vincenz> *coughs* bottom
11:43:49 <jethr0> k, maybe that quote isn't all that good. but when working debugging-intensively it's definitely applicable
11:43:58 <vincenz> apfelmus: 'ass'
11:44:08 <mahogny> talking about debugging, someone wanna debug my matlab code? :(
11:44:22 <jethr0> not really
11:44:42 <mahogny> me neither.
11:44:51 * allbery_b thankfully only has to maintain matlab --- not comprehend it
11:45:04 <allbery_b> (and even that not so often)
11:45:55 <ohmega> f ‚à∑ (œÉ ‚à∑ ‚Ñï) ‚Üí (œÑ ‚à∑ ‚Ñï) ‚Üí œÉ ‚â§ œÑ
11:45:57 <ohmega> then
11:46:12 <fasta> I think the quote is lame.
11:46:26 <apfelmus> vincenz: huh?
11:46:26 <wy> I have a problem with setters. If I have a named product type: data Person = {name::String, age::Int, salary::Int}. I have the functions to get the fields. But I don't have the setters. If I want to modify a structure like this often. I would write something like "john{salary=salary john+1000}. This is another case I want macros.
11:46:57 <glguy> when you write things at a really basic level, they span pages an
11:47:05 <paolino> :t foldM
11:47:07 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:47:36 <glguy> paolino: I took it a little farther
11:47:36 <glguy> shuff a = foldM randSwap a [lo .. hi]
11:47:36 <glguy>   where (lo,hi) = bounds a
11:47:36 <glguy>         randSwap a u = swap `fmap` getRandomR (u,hi)
11:47:37 <glguy>           where swap x = a // [(x,a!u),(u,a!x)]
11:47:42 <fasta> apfelmus: can you demonstrate the reason lazyness blows the stack in simpler cases?
11:48:15 <glguy> futher*?
11:48:30 <vincenz> apfelmus: nm
11:49:00 <liyang> wy: you get the salary by salary john; you set it by john { salary = newvalue }. It may not be particularly symmetrical but it's not that much more verbose either...
11:49:51 <Saizan> liyang: the problem is that setters are not first class
11:50:27 <liyang> Maybe define something like modifySalary f p = p { salary = f (salary p) } for each field. :-/
11:50:50 <paolino> glguy, wait to paste the next one please. I'm lost on the way
11:51:20 <wy> liyang: That's exactly my problem. I would have to write those for every field.
11:51:21 <glguy> ?src foldM
11:51:22 <lambdabot> foldM _ a []     = return a
11:51:22 <lambdabot> foldM f a (x:xs) = f a x >>= \fax -> foldM f fax xs
11:51:23 <apfelmus> fasta: mh, evaluating (1
11:52:01 <apfelmus> rats, evaluating (1+(1+(1+...))) has to push many 1 on the stack.
11:53:31 <apfelmus> "x + y" => push x; push y; jump to code of (+)
11:54:05 <Cale> > foldl' (+) 0 (replicate 1000000 1)
11:54:07 <lambdabot>  1000000
11:54:19 <bd_> GHC optimization?
11:54:21 <Cale> foldl' avoids that problem
11:54:27 <bd_> :t foldl'
11:54:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:54:30 <e_e_coli> > foldr' (+) 0 (replicate 1000000 1)
11:54:30 <lambdabot>   Not in scope: `foldr''
11:54:33 <bd_> strict?
11:54:37 <Cale> yeah
11:55:00 <Cale> foldl' is a variant of foldl which forces the accumulating parameter before recursing
11:55:33 <avnit> i'm getting an error when compiling HXT:
11:55:34 <avnit> src/Control/Arrow/ArrowTree.hs:43:0:
11:55:34 <avnit>     All of the type variables in the constraint `ArrowTree a' are already in scope
11:55:34 <avnit>         (at least one must be universally quantified here)
11:55:34 <avnit>     When checking the class method:
11:55:34 <avnit>       insertTreeTemplate :: forall (t :: * -> *) b c.
11:55:36 <avnit>                             (ArrowTree a, Tree t) =>
11:55:36 <bos> here's an unfamiliar signature to me.
11:55:37 <avnit>                             a (t b) (t b) -> [IfThen (a (t b) c) (a (t b) (t b))] -> a (t b) (t b)
11:55:38 <bos> @type second
11:55:39 <avnit>     In the class declaration for `ArrowTree'
11:55:40 <lambdabot> forall (a :: * -> * -> *) c d b. (Arrow a) => a b c -> a (d, b) (d, c)
11:55:40 <liyang> wy: it's a purely mechanical procedure though. Maybe write some Template Haskell to define those automatically?
11:55:48 <Cale> Most of the time when you want a fold, you want foldr, which interacts well with laziness. The rest of the time, you usually want foldl'
11:55:54 <e_e_coli> Cale: why wouldn't one awlays want foldl to behave that way? Are there semantics that break?
11:55:58 <bd_> bos: Do you know about arrows in general?
11:55:59 <bos> what does the "a b c" in the signature above mean? that a is a type constructor?
11:56:03 <avnit> oops
11:56:12 <bos> i know that arrows generalise monads, but no more.
11:56:35 <Cale> e_e_coli: yeah, it still makes things stricter than they might otherwise have to be
11:57:01 <bd_> bos: the a is an arrow type - that's the meaning of the (Arrow a) => . Arrows generalize a process which produces a value of one type out of another - for example, the function type constructor (->) is a simple arrow
11:57:03 <apfelmus> e_e_coli: any = foldl or False
11:57:23 <Cale> foldl will certainly force the entire spine of a list, but foldl' will certainly force all the elements into WHNF as well, regardless of whether they'd really be needed.
11:57:34 <bos> yeah, i guess that (a :: *->*->*) and a b c kind of answers my question.
11:57:39 <bos> thanks, bd_.
11:57:40 <bd_> bos: what second does is sort of forking the computation - given an arrow from b to c, we can create an arrow from (d, b) to (d, c) - that is, leave the first element of the pair alone and only work on the second
11:57:48 <Cale> avnit: hmm
11:57:55 <apfelmus> e_e_coli: i think that this example was wrong
11:58:07 <fasta> How can I predict what GHC's strictness analyzer comes up with?
11:58:54 <bos> bd_: wonderful, thanks
11:59:23 <apfelmus> fasta: you cannot :) but it will detect simple cases if you force the resulting value at some point.
11:59:47 <fasta> apfelmus: oh, how I love black boxes :(
12:00:31 <vincenz> Anyone up for a game of Go?
12:00:40 <glguy> > execState (replicateM_ 1000 (do { x <- get; when (x>0) (put (x+1))}) 1
12:00:40 <lambdabot>  Parse error
12:00:47 <Cale> avnit: which version of GHC?
12:00:58 <avnit> 6.4.1
12:01:10 <glguy> > execState (replicateM_ 1000 (do { x <- get; when (x>0) (put (x+1))})) 1
12:01:11 <lambdabot>  1001
12:01:16 <glguy> > execState (replicateM_ 1000000 (do { x <- get; when (x>0) (put (x+1))})) 1
12:01:18 <lambdabot>  Exception: stack overflow
12:01:49 <apfelmus> fasta: mh, well, you don't have to look into it :) but forcing a value i.e. like in ((2+) $! foldl (+) 0 [1..5]) will surely help
12:01:49 <glguy> ?type runState
12:01:51 <lambdabot> forall s a. State s a -> s -> (a, s)
12:02:06 <avnit> Cale: should i get 6.6
12:02:08 <avnit> ?
12:02:33 <fasta> apfelmus: yes, I do need to understand.
12:02:34 <glguy> > runState (State (\x -> (1,x))) 2
12:02:35 <lambdabot>  (1,2)
12:02:37 <Cale> avnit: It might help, or maybe 6.4.2 if you'd like to stick with 6.4 for now.
12:02:54 <avnit> ok
12:03:12 <Cale> avnit: you were following the instructions on the website for building it?
12:03:51 <avnit> yeah... i built and installed the http module, make setup, ./setup configure --ghc, ./setup build
12:04:56 <avnit> Cale: o wait, i'll try installing with make instead of cabal
12:05:23 <Cale> It builds fine for me on 6.4.2
12:05:32 <emu> ``Any functional which may perform an I/O action either because it is a primitive action or because it invokes other functionals which perform I/O actions must be declared with the io modifier.''
12:05:43 <avnit> any advantage of 6.4.2 > 6.6
12:05:47 <avnit> ?
12:05:49 <glguy> emu: what language is that?
12:05:53 <emu> Fortress specification
12:06:01 <glguy> avnit: runs hsplugins
12:06:03 <Cale> Only that certain packages haven't been updated to work with 6.6 yet.
12:06:15 <avnit> ok, thanks
12:06:37 <Cale> But hs-plugins should be done by the end of the week?
12:06:52 <emu> i'm still trying to figure out how that statement fits together with code snippets using a function named "print"
12:06:54 <glguy> is that being done at Hac07?
12:06:56 <Cale> I heard some mumblings like that from dons :)
12:07:03 <apfelmus> fasta: ghc's strictness analyzer is simple minded, but gets common cases. space leaks arise by a computation that is invariably built up but might well be discarded.
12:07:18 <apfelmus> i mean there is a possibility that it's discarded
12:10:27 <glguy> execStateT (replicateM_ 1000000 (get >>= \g -> liftIO (print g) >> put (g+1))) 1 -- is running well enough on my box
12:11:48 <fasta> glguy: it should also run good when n->\infty. Does it?
12:12:37 <glguy> fasta: I don't know, but 1000000 didn't work for the runState example
12:12:48 <glguy> but does in this example with added strictness
12:12:53 <glguy> that was my point
12:14:04 <fasta> I am more interested in learning the function: given a piece of source code that I have written, know what run-time characteristics it has and prove this.
12:14:23 <fasta> (and space behaviour)
12:14:51 <apfelmus> glguy: ah, but you're using StateT over IO.
12:14:55 <glguy> yeah
12:15:01 <glguy> which I figured would work :)
12:15:11 <fasta> Typing something into the interpreter and seeing whether it works until a specific value is a hackish approach.
12:15:36 <fasta> The Monad Lift idea was nice.
12:15:45 <glguy> regardless, it still taught me something
12:15:52 <glguy> I won't be writing a paper over it
12:16:14 <glguy> but it made me wonder if we couldn't have a StrictIdentity monad
12:16:23 <avnit> is there a way to easily write long numbers with separators? all i've come up with is:
12:16:23 <avnit> (#) :: Integer -> Integer -> Integer
12:16:23 <avnit> (x) # (y) = read $ (show x) ++ y'
12:16:23 <avnit>             where y' = replicate diff '0' ++ show y
12:16:23 <avnit>                   diff = 3 - length (show y)
12:17:00 <avnit> so 100#000#000 == 100000000
12:17:09 <apfelmus> fasta: mh, the only way is to perform graph reduction by hand.
12:17:41 <kpreid> avnit: how about x # y = x * 1000 + y ?
12:17:56 <apfelmus> > let x # y = 1000*x + y in 2 # (000 # 001)
12:17:57 <lambdabot>  2001
12:18:05 <emu> Fortress appears to be a strict language with constructs that may execute statements in arbitrary order
12:18:24 <kpreid> > let x # y = 1000*x + y in (2 # 000) # 001
12:18:25 <lambdabot>  2000001
12:18:33 <kpreid> just need to make it left-associative
12:18:39 <fasta> apfelmus: Graph reduction works on graphs with possible cycles, right? What documents the graph reduction process best?
12:18:41 <avnit> ahh, that makes sense
12:18:47 <glguy> > let x * y | y > 999 = error "bad number"
12:18:47 <lambdabot>  Parse error
12:18:51 <glguy> errr
12:18:54 <glguy> x # y
12:18:55 <fasta> apfelmus: Algorithms, a functional approach had a small section on it.
12:19:04 <fasta> apfelmus: Is that the whole story?
12:20:51 <glguy> ?docs Control.Monad.Identity
12:20:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
12:21:19 <seliopou> :t runState
12:21:21 <lambdabot> forall s a. State s a -> s -> (a, s)
12:21:46 <seliopou> does anybody know if a good state monad tutorial?
12:21:48 <apfelmus> fasta: huh, just rewrite the expression until you see what's going on, always using the outermost redex? mh, i can't remember the section from the book, but i think i have not been very fond of it. but you are right that there is not much about it. you may want to try the runState example by hand.
12:21:55 <seliopou> emphasis on the /good/
12:22:27 <fasta> apfelmus: thanks, I think I will do that. Good exercise
12:22:28 <apfelmus> fasta: the size of the expression is equivalent to memory used.
12:32:35 <newsham> > runState (do { x <- get; put (x+3); return (2*x)}) 2
12:33:02 <glguy> (4,5)
12:33:19 <newsham> thanks glbot
12:33:24 <glguy> :)
12:34:57 <glguy> ?bot
12:34:57 <lambdabot> :)
12:35:32 <glguy> > runState (do { x <- get; put (x+3); State (\s -> (-1,-2))}) 2
12:35:33 <lambdabot>  (-1,-2)
12:36:24 <glguy> > runState (withState (*3) (do { x <- get; put (x+3)})) 2
12:36:25 <lambdabot>  ((),9)
12:36:38 <glguy> > runState (withState (*3) (do { x <- get; put (x+3); return (2*x)})) 2
12:36:39 <lambdabot>  (12,9)
12:36:59 <wolverian> ?type runState
12:37:00 <lambdabot> forall s a. State s a -> s -> (a, s)
12:37:30 <glguy> > runState (mapState (\(a,b)->(a*3,b*3)) (do { x <- get; put (x+3); return (2*x)})) 2
12:37:31 <lambdabot>  (12,15)
12:39:16 <newsham> > runState (liftM (++ "!") (do { x <- get; put (x+3); return (show x)}) (2,3)
12:39:16 <lambdabot>  Parse error
12:39:25 <newsham> > runState (liftM (++ "!") (do { x <- get; put (x+3); return (show x)})) (2,3)
12:39:26 <lambdabot>   add an instance declaration for (Num (a, b))
12:39:28 <glguy> > filterM (\_->[False ..]) [1..3]
12:39:29 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:39:48 <newsham> > runState (liftM (++ "!") (do { x <- get; put (x+3); return (show x)})) 2
12:39:49 <lambdabot>  ("2!",5)
12:40:12 <glguy> > mapM (([]:).(:[]).(:[])) [1..3]
12:40:13 <lambdabot>  [[[],[],[]],[[],[],[3]],[[],[2],[]],[[],[2],[3]],[[1],[],[]],[[1],[],[3]],[[...
12:40:18 <glguy> > concat $ mapM (([]:).(:[]).(:[])) [1..3]
12:40:20 <lambdabot>  [[],[],[],[],[],[3],[],[2],[],[],[2],[3],[1],[],[],[1],[],[3],[1],[2],[],[1]...
12:40:40 <glguy> > map concat $ mapM (([]:).(:[]).(:[])) [1..3]
12:40:41 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:45:45 <newsham> hi bob
12:45:58 <newsham> say "hi" to phil for me.
12:46:30 <wy> I wonder if this server has only free software related channels? I want to find a channel for Illustrator.
12:47:28 <newsham> ask freenode #svg?
12:47:56 <temujin> > 1 + 1
12:47:57 <lambdabot>  2
12:48:04 <temujin> > 2 + 2
12:48:05 <lambdabot>  4
12:48:08 <temujin> > 4 + 4
12:48:10 <lambdabot>  8
12:48:14 <temujin> > 8 + 8
12:48:15 <lambdabot>  16
12:48:20 <temujin> I love abusing that bot
12:48:27 * temujin hugs lambdabot
12:48:31 <temujin> > 16 + 16
12:48:32 <lambdabot>  32
12:48:40 <glguy> just get it over with:
12:48:45 <glguy> > iterate (*2) 1
12:48:46 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:48:48 <temujin> ahhahaha
12:48:58 <temujin> but thats not abusing it
12:49:09 <newsham> > liftM (+ 1) (return 1) :: State Int Int
12:49:10 <lambdabot>   add an instance declaration for (Show (State Int Int))
12:49:53 <newsham> > fix (iterate (* 2)) 1
12:49:53 <lambdabot>  Couldn't match `t -> t1' against `[t -> t1]'
12:50:09 <glguy> > fix ((1:) . map (*2))
12:50:09 <newsham> > fix (* 2) 1
12:50:10 <lambdabot>   add an instance declaration for (Num (t -> a))
12:50:10 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
12:50:28 <temujin> ?fix
12:50:28 <lambdabot> Maybe you meant: faq ft id
12:50:34 <temujin> bleh
12:50:52 <glguy> :t fix
12:50:53 <lambdabot> forall a. (a -> a) -> a
12:50:58 <temujin> ahhh
12:51:01 <temujin> thx
12:51:12 <temujin> wait that makes no sense to me
12:51:19 <temujin> > fix (1)
12:51:19 <lambdabot>   add an instance declaration for (Num (a -> a))
12:51:25 <newsham> > fix id
12:51:25 <lambdabot>  Add a type signature
12:51:27 <temujin> > fix (1) :: int
12:51:28 <lambdabot>        add (Num (int -> int)) to the expected type of an expression
12:51:28 <lambdabot>       or ...
12:51:31 <newsham> > fix id :: Int
12:51:32 <lambdabot>  Exception: <<loop>>
12:51:45 <temujin> > fix (1) :: Int
12:51:45 <lambdabot>   add an instance declaration for (Num (Int -> Int))
12:51:51 <newsham> > fix (const 1)
12:51:52 <lambdabot>  1
12:51:55 <LoganCapaldo> I just got tempted to try an add an instance declaration for Num (a -> a) :)
12:51:56 <glguy> > fix (scanl (+) 1 . (1:))
12:52:02 <lambdabot>  [1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,1771...
12:52:22 <glguy> > fix ((1:) . (1:) . scanl1 (+))
12:52:23 <lambdabot>  [1,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
12:52:38 <temujin> so I still don't get what fix does
12:52:42 <glguy> > fix ((1:) . scanl1 (+) . (1:))
12:52:43 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:52:51 <glguy> ?src fix
12:52:51 <lambdabot> fix f = let x = f x in x
12:53:13 <pitecus> is the e constant defined in some standard library?
12:53:15 <newsham> > fix ((* 0.5) . (+ 1.0))
12:53:15 <temujin> so just like iterate?
12:53:16 <lambdabot>  Exception: <<loop>>
12:53:22 <glguy> ?src iterate
12:53:22 <lambdabot> iterate f x =  x : iterate f (f x)
12:53:37 <glguy> fix f = f $ f $ f $ f $ f $ f $ f $ f $ f
12:53:42 <glguy> $ f $ f $ f $ f $ f
12:53:43 <glguy> $ f $ f $ f $ f $ f
12:53:44 <glguy> $ f $ f $ f $ f $ f
12:53:45 <newsham> > fix (\x -> 1 - 0.5*x)
12:53:45 <glguy> ...
12:53:46 <lambdabot>  Exception: <<loop>>
12:53:59 <temujin> oooo it concatenates? or in case of integers adds?
12:54:08 <temujin> > fix (1) 1
12:54:09 <lambdabot>   add an instance declaration for (Num ((t -> a) -> t -> a))
12:54:11 <temujin> damnit
12:54:16 <temujin> > fix (1:) 1
12:54:17 <lambdabot>  Couldn't match `[a]' against `t -> t1'
12:54:19 <newsham> temujin: it composes a function with itself infinitely
12:54:29 <temujin> ooo
12:54:39 <glguy> fix f = last $ iterate f undefined
12:54:52 <newsham> > iterate (\x -> 1 - 0.5*x) 1
12:54:53 <lambdabot>  [1.0,0.5,0.75,0.625,0.6875,0.65625,0.671875,0.6640625,0.66796875,0.666015625...
12:55:06 <newsham> > fix (\x -> 1 - 0.5*x)
12:55:07 <lambdabot>  Exception: <<loop>>
12:55:19 <temujin> > fix (x+5)
12:55:20 <lambdabot>   Not in scope: `x'
12:55:21 <temujin> > fix (x+5) 1
12:55:22 <lambdabot>   Not in scope: `x'
12:55:29 <temujin> :(
12:55:31 <pitecus> > e
12:55:31 <temujin> I am so lost
12:55:31 <lambdabot>   Not in scope: `e'
12:55:33 <glguy> > sequence (fix (succ:)) 3
12:55:34 <lambdabot>  [4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4,4...
12:55:52 <temujin> fix (x -> x + 5)
12:55:56 <temujin> > fix (x -> x + 5)
12:55:57 <lambdabot>  Parse error
12:55:59 <temujin> damnit
12:56:05 <temujin> I hate you you dumb bot
12:56:06 <LoganCapaldo> fix (\x -> x + 5)
12:56:13 <temujin> > fix (\x -> x + 5)
12:56:14 <glguy> ?slap temujin
12:56:15 <lambdabot>  Exception: <<loop>>
12:56:15 <lambdabot> why on earth would I slap temujin
12:56:17 <glguy> ?slap temujin
12:56:17 * lambdabot slaps temujin
12:56:35 <temujin> hey... it didn't slap me the first time
12:56:36 <temujin> hehe
12:57:43 <temujin> ok back to work... and by work I mean smoke break
13:03:40 <glguy> ?instances MonadFix
13:03:41 <lambdabot> ((->) r), Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:04:16 <glguy> :t mfix
13:04:17 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
13:04:43 <glguy> > runIdentity $ mfix $ \_ -> return 1 -- starting small
13:04:44 <lambdabot>  1
13:06:17 <glguy> ?src mfix
13:06:17 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:06:36 <glguy> so true
13:08:18 <newsham> > fix (\f n -> if (n==0) then 1 else n * f (n-1))
13:08:19 <lambdabot>  Add a type signature
13:08:26 <newsham> > fix (\f n -> if (n==0) then 1 else n * f (n-1)) 5
13:08:27 <lambdabot>  120
13:09:42 <glguy> mfix (return . h) = return (fix h)
13:10:33 <newsham> ?unpl (\f n -> if (n==0) then 1 else n * f (n-1))
13:10:34 <lambdabot> (\ f n -> if (n == 0) then 1 else (n * (f (n - 1))))
13:10:40 <newsham> ?pl (\f n -> if (n==0) then 1 else n * f (n-1))
13:10:40 <lambdabot> ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)
13:10:49 <newsham> > fix (ap (flip if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
13:10:50 <lambdabot>   Not in scope: `if''
13:11:23 <newsham> ?let if' b t e = if b then t else e
13:11:24 <lambdabot> Defined.
13:11:31 <newsham> > fix (ap (flip L.if' 1 . (0 ==)) . ap (*) . (. subtract 1)) 5
13:11:32 <lambdabot>  120
13:12:20 <glguy> ?src [].mfix
13:12:20 <lambdabot> Source not found. That's something I cannot allow to happen.
13:12:32 <newsham> use the source, luke
13:12:34 <temujin> ?src []
13:12:34 <lambdabot> data [] a = [] | a : [a]
13:12:40 <temujin> ?src .
13:12:40 <lambdabot> Source not found. My pet ferret can type better than you!
13:12:47 <temujin> ?src mfix
13:12:48 <lambdabot> Source not found. My pet ferret can type better than you!
13:12:50 <glguy> ?src (.)
13:12:50 <lambdabot> (.) f g x = f (g x)
13:12:53 <temujin> ahhh
13:12:59 <temujin> ?src (mfix)
13:12:59 <lambdabot> Source not found. stty: unknown mode: doofus
13:13:10 <allbery_b> ?index mfix
13:13:10 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
13:13:30 <temujin> so... [].mfix ==  data [] a = [] | a : [a] My pet ferret can type better than you!  stty: unknown mode: doofus
13:13:37 <temujin> awesome function
13:13:59 <allbery_b> src Control.Monad.Fix mfix
13:14:02 <allbery_b> oops
13:14:06 <allbery_b> @src Control.Monad.Fix mfix
13:14:06 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:14:09 <allbery_b> feh
13:14:13 <glguy> mfix is a class function
13:14:21 <glguy> has specific implementations for each instance
13:14:27 <glguy> ?src (>>=)
13:14:27 <lambdabot> Source not found. Where did you learn to type?
13:14:32 <bd_> @src IO mfix
13:14:32 <lambdabot> mfix = fixIO
13:14:34 <allbery_b> @src Control.Monad.Identity mfix
13:14:35 <lambdabot> Source not found. You speak an infinite deal of nothing
13:14:36 <glguy> ?src [].(>>=)
13:14:36 <lambdabot> Source not found. stty: unknown mode: doofus
13:14:39 <bd_> @src fixIO
13:14:40 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:14:42 <glguy> ?src Either.(>>=)
13:14:42 <bd_> td
13:14:42 <lambdabot> Source not found. You speak an infinite deal of nothing
13:14:43 <bd_> tsk*
13:14:45 <glguy> ?src Either.>>=
13:14:46 <lambdabot> Source not found. Do you think like you type?
13:15:06 <allbery_b> ?src Either (>>=)
13:15:06 <lambdabot> Left  l >>= _ = Left l
13:15:06 <lambdabot> Right r >>= k = k r
13:15:15 <glguy> ?src [] mfix
13:15:16 <lambdabot> mfix f = case fix (f . head) of
13:15:16 <lambdabot>            []    -> []
13:15:16 <lambdabot>            (x:_) -> x : mfix (tail . f)
13:15:19 <glguy> huzzah
13:15:49 <temujin> hhrehehe
13:15:58 <glguy> you OK?
13:16:00 <temujin> glguy your knowledge of haskell and its libraries amaze me
13:16:14 <glguy> temujin: lambdabot is doign all the work
13:16:16 <temujin> yeah... I have a cold... so all the mucus makes my laugh sound like that
13:16:17 <newsham> ?src Just mfix
13:16:17 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:16:22 <glguy> I'm just typing things in
13:16:23 <newsham> ?src Maybe mfix
13:16:23 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
13:16:24 <glguy> ?src Maybe mfix
13:16:24 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
13:16:30 <glguy> unJust??
13:16:34 <glguy> I love it
13:16:42 <temujin> ahahaha
13:16:43 <bd_> isn't that fromJust?
13:16:52 <glguy> yeah, but its locally defined
13:17:00 <bd_> yeah but why?
13:17:00 <newsham> case mx of (Just x) -> inheritWorld x
13:17:06 <glguy> dunno
13:17:15 <bd_> pre-Data.Maybe code?
13:18:47 <glguy> > mfix (\s -> Just (1:s))
13:18:49 <lambdabot>  Just [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,...
13:19:32 <newsham> > liftM sum $ mfix (\s -> Just (1:s))
13:19:36 <lambdabot> Terminated
13:19:45 <ClaudiusMaximus> @tell lambdabot > 1 + 1
13:19:46 <lambdabot> Nice try ;)
13:19:51 <ClaudiusMaximus> heh
13:20:15 <glguy> mfix (liftM h . f) = liftM h (mfix (f . h)), for strict h.
13:22:12 <newsham> > fix (\x -> 1 + 0.001*x)
13:22:13 <lambdabot>  Exception: <<loop>>
13:22:50 <newsham> > (iterate (\x -> 1 + 0.001*x)) !! 100
13:22:51 <lambdabot>      Expecting a function type, but found `[a]'
13:22:51 <lambdabot>       Expected type: [a]
13:22:51 <lambdabot>     ...
13:23:03 <newsham> > (iterate (\x -> 1 + 0.001*x) 1) !! 100
13:23:04 <lambdabot>  1.001001001001001
13:23:07 <glguy> > mdo { s <- Just (1 : s); return s }
13:23:08 <lambdabot>  Parse error
13:23:16 <newsham> > (iterate (\x -> 1 + 0.001*x) 1) !! 1000
13:23:17 <lambdabot>  1.001001001001001
13:23:49 <newsham> > let xs = (iterate (\x -> 1 + 0.001*x) 1) in (xs !! 1000) == (xs !! 1001)
13:23:50 <lambdabot>  True
13:23:56 <newsham> hrmph
13:23:59 <glguy> > mdo { s <- Just (1 : s); return s } -- this works in ghci
13:23:59 <lambdabot>  Parse error
13:24:22 <newsham> ?src fix
13:24:22 <lambdabot> fix f = let x = f x in x
13:27:07 <glguy> > mdo { s <- Just (1 : s); return (map succ s) } -- Just (repeat 2)
13:27:07 <lambdabot>  Parse error
13:27:29 <newsham> mdo?
13:27:31 <paolino> glguy, is possible to  write better
13:27:32 <paolino> swapper xs (l,n) = liftM (take n . elems) $ foldM randSwap a [1 .. n]
13:27:32 <paolino>   where a = diffArray (1,l) xs   ?
13:28:36 <glguy> paolino: why (take n . elems)?
13:29:08 <paolino> because it's a function also for choice n xs
13:29:16 <paolino> and shuffle xs
13:29:31 <newsham> randSwap is array -> IO array?
13:29:51 <glguy> RandomGen g => State g (Array i e)
13:30:05 <allbery_b> newsham: mdo is recursive do bindings
13:30:29 <glguy> newsham: mdo lets you do things like in C++ when you reference an object in its own constructor
13:30:44 <allbery_b> (that is:  mdo xs <- Just (1:xs) -- legal for mdo, not for do)
13:31:07 <yaarg> sudo mount -t vfat -o umask=000 /dev/sdd1 /mnt/camera/
13:31:12 <yaarg> oppsy!
13:31:16 <glguy> also legal: mdo { a <- b c; c <- b a
13:31:23 <fasta> Password:
13:31:33 <glguy> rainbow
13:31:35 <glguy> oh
13:31:41 <paolino> yaarg, the pictures ?
13:31:45 <yaarg> drowssap
13:32:15 <yaarg> paolino: heh it's actually my mp3 player
13:32:33 <glguy> paolino: there isn't anything obvious that i woudl change looking at those two lines
13:32:41 <paolino> ok
13:34:06 <paolino> one question.Is fmap there in
13:34:07 <paolino> randSwap a u = fmap (swap a u) (getRandomR (u,snd $ bounds a))
13:34:07 <paolino> instead of a lift ?
13:34:20 <temujin> > 72 / 3
13:34:21 <lambdabot>  24.0
13:35:35 <paolino> fmap == liftM ?
13:36:34 <bakert> I assume everyone here is signed up to haskell-cafe and the other haskell mailing list?  how do you interact with it?  I get the digest but it make replying very awkward.
13:36:47 <allbery_b> that's one reason I don't use digests
13:37:15 <paolino> @type fmap
13:37:16 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
13:37:25 <allbery_b> paolino: I think so, yes. fmap is generalized map; map is lift for lists (e.g. liftM on [])
13:37:37 <allbery_b> @type liftM
13:37:38 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
13:37:50 <allbery_b> note the resemblance
13:37:53 <paolino> @instances Functor
13:37:54 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
13:38:31 <paolino> 'State s'  is the one
13:39:19 <bakert> allbery_b, if you get the digests from google groups then the posts are all hyperlinks and you can reply on the web.  depending what mailer you use that can be a lot better.  i always get the digests there.  non-digest is just tooooo busy
13:39:20 <paolino> eh glguy wanted to confuse the little paolo
13:39:27 <glguy> ?
13:39:34 <glguy> paolino: I resent that accusation
13:39:52 <glguy> All I did was show you a door you didn't nkow about :-p
13:40:11 <paolino> I apologise then :P
13:40:24 <glguy> what are you confused about
13:41:28 <paolino> nothing now, I thought fmap was something different from liftM
13:41:47 <glguy> liftM is a specialized fmap, as you just learned
13:41:52 <glguy> :-D
13:42:20 <glguy> liftM also uses one more letter than fmal
13:42:22 <glguy> fmap
13:42:30 <glguy> so I tend towards fmap :)
13:42:56 <Terabyte> hey
13:43:44 <Terabyte> the other day sombody showed me a way of getting a unique list of elements from a list containing duplicates.. i lost the file where i kept it.. it was something along the lines of foldr (\x y  -> if x `elem` y then y else x:y) list.  anyone help me out?
13:43:54 <glguy> ?src nubBy
13:43:55 <lambdabot> nubBy eq []             =  []
13:43:55 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
13:44:07 <glguy> ?src nub
13:44:07 <lambdabot> nub = nubBy (==)
13:44:09 <Terabyte> using foldr
13:44:12 <Terabyte> please :)
13:44:17 <Terabyte> or foldr1 sorry
13:44:25 <glguy> Terabyte: using your mind, convert nubBy into a foldr
13:46:03 <fasta> @type nubBy
13:46:04 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
13:46:07 <jethr0> another way would be to go via Set
13:46:12 <fasta> nub is the root of evil
13:46:44 <Terabyte> or perhaps sombody can explain whats wrong with (\x y  -> if x `elem` y then y else x:y) bit
13:46:56 <glguy> it takes the last unique element
13:46:58 <glguy> instead of the first
13:46:59 <lisppaste2> paolino annotated #34792 with "Shuffle module 0.1" at http://paste.lisp.org/display/34792#2
13:47:26 <fasta> apfelmus: Why do you say that s gets threaded in a strict way?
13:47:41 <glguy> paolino: aww, you're too kind
13:47:53 <bakert> paolino, what are you working on?  I cobbled together a shuffle the other day if it might be useful?
13:48:38 <bakert> oh i see this is the finished article not a help thing.  ignore me!
13:48:46 <glguy> bakert: did it look like mine?
13:48:47 <glguy> shuffle a = foldM randSwap a [lo .. hi]
13:48:47 <glguy>   where (lo,hi) = bounds a
13:48:47 <glguy>         randSwap a u = swap `fmap` getRandomR (u,hi)
13:48:47 <glguy>           where swap x = a // [(x,a!u),(u,a!x)]
13:49:53 <bakert> shuffle :: [b] -> [Integer] -> [b]
13:49:53 <bakert> shuffle [e] [] = [e]
13:49:53 <bakert> shuffle elements (r:r_others) = let (b,rest) = extract r elements
13:49:53 <bakert>                 in b:(shuffle rest r_others)
13:49:59 <paolino> ehm, haskelling my mind bakert, anyway I'm working on clustering data algorithms in the end
13:50:20 <apfelmus> fasta: mh, what did i say? :) can you post the log context to remind me?
13:50:55 <fasta> apfelmus> fasta: the point is that while the state delivered by f threaded in a strict way, the whole pair (a,s) returned by f is not.
13:51:08 <Terabyte> glguy: still stuck
13:51:29 <fasta> apfelmus: ^^
13:51:55 <jethr0> > foldl (\a b -> if b `elem` a then a else a++[b]) [] [1,2,3,1]
13:51:56 <lambdabot>  [1,2,3]
13:52:08 <jethr0> neither what you wanted nor very nice though (++[b])
13:52:13 <Terabyte> thanks
13:52:19 <Terabyte> exactly what i wanted
13:52:43 <jethr0> and why can't you use nub?
13:52:43 <Terabyte> maybe not nice but it uses just the prelude
13:52:52 <jethr0> aaahhh
13:52:55 <Terabyte> :)
13:53:29 <jethr0> foldr version would work too, but it would drop all but the last occurrence, as was said earlier
13:53:41 <Terabyte> sure
13:53:43 <jethr0> > foldr (\b a -> if b `elem` a then a else b:a) [] [1,2,3,1]
13:53:44 <lambdabot>  [2,3,1]
13:53:48 <CosmicRay> SyntaxNinja: ping?
13:55:29 <apfelmus> fasta: thanks. i think meant that s will be in weak head normal form if you evaluate x = (a,s) to weak head normal form but this seems to be wrong. mh. in the case of (Int), it does not matter, but i had in mind that the construction of (s) is done with strict functions as opposed to lazy ones.
13:55:43 <CosmicRay> ooo, haskell bindings to fuse and inotify.  <burns>excellent</burns>
13:56:52 <apfelmus> fasta: ah, i wanted to say is that (runState f _|_) is not _|_, but a pair ((),_|_)
13:58:16 <glguy> shuff xs = aux (length xs) xs
13:58:17 <glguy>   where aux _ [] = return []
13:58:17 <glguy>         aux n xs = do
13:58:17 <glguy>           (as,b:bs) <- flip splitAt xs `fmap` getRandomR (0,n-1)
13:58:17 <glguy>           (b:) `fmap` aux (n-1) (as ++ bs)
13:59:15 * glguy proceeds to transform that into a foldM
13:59:23 <glguy> err
13:59:25 <glguy> nvm
14:00:03 <fasta> apfelmus: what is weak header normal form again?
14:00:13 <fasta> er weak head
14:00:21 <Heffalump> don't reduce under lambda
14:00:48 <Heffalump> \x -> ((\y -> x+y) 3) is in WHNF but not HNF
14:01:03 <fasta> HNF is without lambdas?
14:01:08 <mattam> you want a constructor at the head and weak is for not reducing under lambdas
14:01:33 <Heffalump> in HNF, you have to reduce under the lambda, so you get \x -> x + 3
14:01:41 <apfelmus> fasta: evaluate stuff until you hit a constructor, i.e. map f (1:ones) => ... => (:) 1 (map f ones)
14:01:48 <mattam> most of the time people use whnf
14:02:10 <gour> where is zlib lib required to build lambdabot?
14:02:23 <bd_> ?where zlib
14:02:27 <bd_> ...
14:02:29 <bd_> ?botsnack
14:02:29 <lambdabot> :)
14:02:31 <bd_> ?where zlib
14:02:31 <lambdabot> darcs get http://haskell.org/~duncan/zlib
14:02:36 <temujin> ?log
14:02:36 <lambdabot> Maybe you meant: bug let msg yow
14:02:43 <temujin> damnit
14:02:49 <glguy> ?yow
14:02:49 <lambdabot> Hiccuping & trembling into the WASTE DUMPS of New Jersey like some
14:02:49 <lambdabot> drunken CABBAGE PATCH DOLL, coughing in line at FIORUCCI'S!!
14:02:59 <glguy> ?protontorpedo
14:02:59 <lambdabot> so if I learn haskell i can make cool interactive websites and get rich right?
14:03:12 <temujin> so does lambdabot do log base 2?
14:03:18 <temujin> > lg(72)
14:03:19 <lambdabot>   Not in scope: `lg'
14:03:21 <temujin> something like that?
14:03:29 <bd_> > log 4
14:03:30 <lambdabot>  1.3862943611198906
14:03:37 <bd_> > (log 4) / (log 2)
14:03:39 <lambdabot>  2.0
14:03:40 <glguy> > log 4 / log 2
14:03:41 <lambdabot>  2.0
14:03:57 <temujin> > log 72 / log 2
14:03:59 <lambdabot>  6.169925001442312
14:04:02 <temujin> :(
14:04:02 <glguy> mbot lets you say:  % Log[4,2]
14:04:06 <temujin> ahh
14:04:49 <bos> @seen dons
14:04:49 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 3h 37m 12s ago.
14:05:00 <gour> i wonder why lambdabot on #haskell.hr does not know anything about it (zlib)
14:05:30 <jethr0> > logBase 2 10
14:05:31 <lambdabot>  3.3219280948873626
14:05:56 <glguy> ?src logBase
14:05:56 <lambdabot> Source not found. Do you think like you type?
14:06:03 <glguy> > log 10 / log 2
14:06:04 <lambdabot>  3.3219280948873626
14:06:34 <jethr0> one is implemented using the other. i think "logBase b n == log b / log n"
14:06:43 <jethr0> other way 'round
14:06:54 <fasta> This is in WHNF? \y->((\x->x) 1,y) The same expression evaluated to HNF: \y->(1,y)?
14:07:09 <Heffalump> correct
14:07:19 <fasta> thanks
14:13:51 <mattam> humm, Heffalump, you reduce under (,) for hnf ?
14:14:18 <mattam> looks like NF to me
14:15:22 <fasta> (,) is a constructor so if the rule says:" stop at constructors", then you are right.
14:16:12 <Heffalump> mattam: oh, yes, sorry
14:16:15 <Heffalump> wasn't paying attention
14:16:36 <ClaudiusMaximus> @type fix
14:16:37 <lambdabot> forall a. (a -> a) -> a
14:19:29 <jethr0> ClaudiusMaximus: fix allows to create recursive anonymous functions
14:19:52 <fasta> apfelmus: The reason why the stack blows is: (get>>=\n -> put (n+1)>>return n)<n times> , when the final action (return) of these n is forced because the answer is needed, all the preceding actions are evaluated too. It kind of works in reverse. Ok?
14:20:59 <[d-_-b]> I want a function that receive a list of Int and returns True if they are all diferent or False if exists two or more equal elements... anyone helps me?
14:22:09 <jethr0> > let df as = as == nub as in df [1,2,3,1]
14:22:11 <lambdabot>  False
14:22:25 <fasta> nub works in O(n^2)
14:22:33 <fasta> (which is almost never what you want)
14:22:35 <jethr0> nobody said anything about complexity :)
14:23:20 <jethr0> all ((<2) . length) . group . sort
14:24:07 <glguy> > let check xs = and $ zipWith (/=) `ap` tail $ sort xs in check [1,2,3,6,3,1]
14:24:08 <lambdabot>  False
14:24:13 <glguy> > let check xs = and $ zipWith (/=) `ap` tail $ sort xs in check [1,2,3,6]
14:24:14 <lambdabot>  True
14:24:17 <glguy> w00t
14:24:44 <fasta> Can you do it faster than O(n lg n)?
14:24:56 <glguy> can I? or can anyone?
14:25:02 <fasta> anyone
14:25:16 <glguy> I doubt it...
14:26:22 <apfelmus> fasta: mh, not quite. it does kind of work in reverse, and you have to evaluate all previous actions. but the problem is that the state is "evaluted" to (((...)+1)+1)+1, i.e. evaluating the action to WHNF merely builds a big computation for the state.
14:26:22 <fasta> It's obviously linear when you take Int to mean Int32 :)
14:26:25 <temujin> ?src zipWidth
14:26:26 <lambdabot> Source not found. Do you think like you type?
14:26:31 <glguy> ?src zipWith
14:26:31 <jethr0> hmm, sorting is kinda instrumental here. otherwise you have to keep a map/set of seen items
14:26:31 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
14:26:31 <lambdabot> zipWith _ _      _      = []
14:26:48 <glguy> the binary tree set would have the same complexity
14:26:53 <jethr0> everything is O(1) when it's bounded
14:26:55 <temujin> damnit... what the hell... ... oo I had a d in there
14:27:04 <slava> you can do this with expected time O(n)
14:27:07 <slava> using a hashtable
14:27:24 <glguy> wrong channel
14:27:25 <glguy> ;)
14:27:39 <slava> [d-_-b]: I want a function that receive a list of Int and returns True if they are all diferent or False if exists two or more equal elements... anyone helps me?
14:27:40 <dino-> heh, just read shapr's post about the state of Sweden.
14:28:08 <glguy> slava: re: hash tables B^D
14:28:21 <slava> surely haskell has hash tables.
14:28:29 <jethr0> also, one could apply the prime sieve...
14:28:29 <glguy> yeah, and they are in IO
14:28:58 <slava> you store your sequence in a hashtable, then see if the sequence has the same length as the number of entries in the hash.
14:29:01 <apfelmus> df :: Eq a => [a] -> Bool   is Œò(n^2)
14:29:01 <apfelmus> df :: Ord a => [a] -> Bool is Œò(n*log n)
14:29:01 <apfelmus> df :: [Int32] -> Bool is Œò(n)
14:29:37 <jethr0> apfelmus: everything is O(1) when it's bounded
14:30:13 <fasta> apfelmus: I don't see why that happens.
14:31:39 <SyntaxNinja> y0
14:31:40 <fasta> Hashtables can be implemented with DiffArray
14:31:50 <SyntaxNinja> hi CosmicRay
14:31:52 <pejo> slava, the hash table is for efficiency I presume? That would roughly be sizeof(input) + sizeof(hashtable) + sum of length of all chains?
14:32:18 <slava> assuming a good hash function, storing into a hashtable is O(1)
14:32:29 <fasta> expected time, right?
14:32:32 <slava> yes
14:32:44 <slava> since a 'good' has hfunction ensures each bucket has <2 entries
14:32:48 <fasta> I think you can also do it within O(n lg lg n)
14:33:39 <slava> factor version :-)  : contains-duplicates? [ hash-prune ] keep [ length ] 2apply < ;
14:33:49 <pejo> fasta, with bounded data you can sort in that time, so definitely.
14:34:03 <fasta> pejo: no, unbounded
14:34:36 <apfelmus> jethr0: huh? [Int32] is bounded? ah. you're bond to the bounds of the machine, eh? and "j..." stands for James "007" Bound, isn't it?
14:35:00 <joelr1> evening everyone!
14:35:01 <joelr1> dons: hi don! who are the people in the pictures?
14:35:11 <pejo> fasta, can you sort unbounded data in n*log(log(n)), or do you mean you have an algorithm that solves this problem in that time?
14:35:25 <fasta> pejo: the latter, I think
14:35:38 <jethr0> apfelmus: sry, i wasn't thinking straight.
14:35:58 <fasta> pejo: the former is obviously false
14:36:01 <Philippa> apfelmus: see "log [base two] n is 32"
14:36:55 <fasta> When you have Int32 and enough memory you can just use an array.
14:36:59 <apfelmus> jethr0: mh, actually you're right in the case of [Int32] because any list longer than 2^32 elements must yield False.
14:37:19 <jethr0> apfelmus: hmm, so we were both right :)
14:37:28 <apfelmus> jethr0: right :)
14:37:32 <vincenz> apfelstrudel
14:37:49 <jethr0> friede, freude, eierkuchen
14:39:22 <apfelmus> hey, hey, i don't take kindly to kitchen rivals. you should only eat apfelmus, not apfelstrudel or friede or stuff like that.
14:39:57 <jethr0> > let {ls = [1,2,3,1]; mp = foldl (\a b -> insert b () a) (empty :: IntMap ())} in size (mp ls) == length ls
14:39:57 <lambdabot>   Not in scope: `size'
14:40:12 <jethr0> not sure what complexity IntMap has, though
14:40:45 <fasta> jethr0: It's based on a tree
14:41:32 <jethr0> hmm, so not a hash, but O(log n) insert
14:43:33 <joelr1> anyone here who took part in the hackathon?
14:44:00 <sjanssen> IntMap is technically O(1) lookup, because the size of an Int is bounded
14:44:32 <sjanssen> joelr1: there is a whole channel full of them in #haskell.hac07
14:44:43 <joelr1> oh
14:45:21 <jethr0> having my own argument thrown back at me *ouch*
14:45:24 <sjanssen> joelr1: I think they've quit for the day, though.  Do you have a question?  I followed along a bit, so I might know
14:45:39 <joelr1> sjanssen: i wonder who the people are in the pictures
14:45:53 <sjanssen> joelr1: oh, I'd love to know that too
14:46:04 <joelr1> he
14:46:19 <joelr1> one photo is labeled but others aren't :D
14:49:39 <ClaudiusMaximus> > fix (0+)
14:49:40 <lambdabot>  Exception: <<loop>>
14:50:22 <jethr0> > fix (\f n -> if n <= 0 then 1 else n * f (n-1)) 6
14:50:24 <lambdabot>  720
14:50:44 <glguy> > fix ((1:) . scanl (+) . (1:))
14:50:45 <lambdabot>  Couldn't match `[a]' against `[[a1]] -> [[a1]]'
14:50:48 <glguy> bah
14:50:54 <glguy> > fix ((1:) . scanl1 (+) . (1:))
14:50:55 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
14:51:11 <jethr0> > take 10 $ fix (1:)
14:51:13 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
14:51:27 <glguy> > fix (const 1)
14:51:28 <lambdabot>  1
14:51:35 <ClaudiusMaximus> fix fix
14:51:38 <ClaudiusMaximus> oops
14:52:56 <jethr0> > fix (\x -> let ~(a,b) = x in (1,a))
14:52:58 <lambdabot>  (1,1)
14:54:46 <ClaudiusMaximus> > fix (\x -> let ~a = x in (0+a)) -- trying to calculate 0
14:54:47 <lambdabot>  Exception: <<loop>>
14:55:38 <notsmack> what's the wiki written in haskell?
14:55:51 <glguy> parser error
14:56:25 <jethr0> @google wiki written in haskell
14:56:27 <lambdabot> http://www.flippac.org/projects/flippi/
14:56:28 <lambdabot> Title: Flippi: a Wiki clone written in Haskell
14:56:38 <notsmack> bah, thanks jethr0
14:56:49 <jethr0> @notsmack
14:56:49 <lambdabot> :)
14:58:23 <conal> would be pretty neat to program our wiki in haskell
14:59:20 <notsmack> hmm, how'd that work?  does she use the closest command or something?
14:59:40 <conal> and also use its markup language as the markup language for haddock
15:00:01 <jethr0> conal: neat: yes, necessary: not really. mediawiki does a good job and i'd not be happy about another wiki moving.
15:00:09 <jethr0> would be nice to write one, though ^_^
15:00:35 <jethr0> notsmack: yes, editing distance up to three "typos"
15:00:40 <jethr0> @tape length
15:00:42 <conal> jethr0: yep -- moving would be a pain.  unless it was automated.
15:01:16 <nornagon> jethr0: what's the keyboard layout, though :)
15:01:22 <jethr0> somehow it never is, even though done by a bunch of computer nerds. but moving wiki's is strictly manual
15:01:27 <nornagon> @ttpe length
15:01:28 <lambdabot> forall a. [a] -> Int
15:01:49 <nornagon> see, t is nowhere near y for me :/
15:01:53 <jethr0> ... up to a distance of 3, unless there are closer alternatives
15:01:54 <conal> i sent a note to libraries@haskell.org last night about merging haddock's markup and the wiki's markup.
15:02:06 <nornagon> @tfpe
15:02:07 <lambdabot> not an expression: `'
15:02:14 <nornagon> @tfpe length
15:02:15 <lambdabot> forall a. [a] -> Int
15:02:19 <nornagon> oh, okay then.
15:02:24 <nornagon> @tfpo length
15:02:24 <lambdabot> Maybe you meant: todo type
15:02:32 <jethr0> @google edit distance
15:02:33 <conal> jethr0: maybe because the translation is too much of a hassle in most languages
15:02:33 <lambdabot> http://en.wikipedia.org/wiki/Levenshtein_distance
15:02:46 <nornagon> jethr0: ah, i see :)
15:02:54 <nornagon> @tpe length
15:02:55 <lambdabot> forall a. [a] -> Int
15:03:01 <nornagon> @te length
15:03:01 <lambdabot> Consider it noted.
15:03:06 <nornagon> oops.
15:03:32 <bd_> @help te
15:03:32 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
15:03:41 <jethr0> "in most languages", but surely not in haskell *g*
15:03:56 <nornagon> @help tell
15:03:56 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
15:05:53 <conal> jethr0: well, yeah :)
15:11:45 <sorear> @botsnack
15:11:45 <lambdabot> :)
15:11:54 <sorear> yay!
15:21:31 <jethr0> @yay
15:21:31 <lambdabot> Maybe you meant: faq map yarr yow
15:21:49 <koala_man> @yow
15:21:49 <lambdabot> I can't think about that.  It doesn't go with HEDGES in the shape of
15:21:49 <lambdabot> LITTLE LULU -- or ROBOTS making BRICKS ...
15:21:51 <allbery_b> @moo
15:21:51 <lambdabot> Maybe you meant: map more msg todo yow
15:22:14 <allbery_b> @help map
15:22:14 <lambdabot> map. #haskell user map
15:22:37 <sorear> @ask dons lambdabot didn't abort - how did you get it unstuck?
15:22:37 <lambdabot> Consider it noted.
15:22:43 <sorear> @map
15:22:43 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
15:23:02 * sorear 's eyes burn at the sight of "hawiki"
15:25:16 <jethr0> *argh*
15:26:00 <sorear> oh?
15:27:33 <jethr0> i already forget how cool that map is. this way you can see how far off an "acceptable" time schedule everyone in #haskell is!
15:27:49 <conal> I'd love for these maps to show more info, be zoomable, etc.  maybe we could start using frappr instead.
15:28:38 <bos> i thought frappr was all about cats.
15:29:17 <jethr0> yup, maybe using g**gle maps. /me looks up frappr...
15:33:53 <conal> there's a frappr map for LTU readers: http://lambda-the-ultimate.org/node/1080
15:33:53 <lambdabot> Title: Map of LtU readers | Lambda the Ultimate
15:36:52 <joelr1> folks, has anyone integrated haskell with c++?
15:38:06 <jethr0> joelr1: definitely NOT what you're looking for: http://haskell.org/hawiki/C_2b_2bFromHaskell
15:38:07 <lambdabot> Title: C++FromHaskell - The Haskell Wiki
15:38:15 <bd_> integrated how?
15:38:21 <nornagon> gr, what do guards look like in haskell?
15:38:22 <bd_> There's the FFI but that uses only C interfaces
15:38:37 <bd_> nornagon: f x | predicate x = bar ?
15:38:39 <jethr0> integrated as in Swig i'd guess
15:38:40 <sorear> foo time | time == 1 = bar
15:38:40 <joelr1> i have a c++ library with classes, etc.
15:38:46 <nornagon> bd_: ah, thx
15:38:47 <joelr1> need to wrap it with haskell
15:38:51 <newsham> you can always call non-method "C" functions which access C++ functions (might have to manually do name-mangling)
15:39:02 <wolverian> conal, I'm not very surprised the comments thread is all about different map projections.
15:39:06 <sorear> there's a page on the wiki now
15:39:14 <bd_> nornagon: if you want multiple guards you can do something like f x | pred = foo <optional newline(s)> | pred = bar
15:39:19 <bd_> nornagon: also, otherwise = True :)
15:39:21 <joelr1> for example, they expect me to subclass a certain class that implements callbacks
15:39:29 <sorear> http://haskell.org/haskellwiki/CPlusPlusFromHaskell
15:39:31 <lambdabot> Title: CPlusPlus from Haskell - HaskellWiki
15:39:34 <joelr1> aha!
15:39:38 <joelr1> thanks
15:39:48 <sorear> it's probably not 'complete'
15:41:24 <joelr1> sorear: this is just what i've been looking for, thanks!
15:41:36 <conal> oh.  i just noticed the link to http://www.frappr.com/haskellers
15:42:15 <joelr1> conal elliot?
15:42:31 <conal> yeah (but two "t"s)
15:42:47 <joelr1> yes, typo, my bad :D
15:42:56 <joelr1> famous people here!
15:43:46 <nornagon> bd_: afaik, otherwise != True; it's just that anything binds to 'otherwise' :)
15:43:57 <conal> joelr1: famous?
15:44:48 <sorear> nornagon: nothing binds in guards.
15:44:50 <joelr1> well, yes, functional reactive animation!
15:45:06 <joelr1> conal: that would be you, right? http://conal.net/
15:45:07 <lambdabot> Title: Conal Elliott's home page
15:45:23 <conal> joelr1: yeah.  thanks.
15:45:34 <SamB_XP> sorear: what about pattern guards!
15:45:45 <newsham> you can probably do method calls "manually" too..
15:45:52 <newsham> wait.. no, probably not.. nevermind.
15:46:04 <joelr1> from conal's homepage: I was in the Graphics Group of Microsoft Research during 1994-2002.  My last project there was a high-level language and optimizing compiler for computations on graphics processors, called Vertigo.
15:46:08 * joelr1 takes a bow
15:46:08 <newsham> you could write a small assembly stub for making method calls.
15:46:19 <bd_> nornagon: no, otherwise == True, according to the haddock for the prelude, IIRC
15:46:23 <nornagon> i see
15:46:27 <bd_> > otherwise
15:46:27 <nornagon> righty then :)
15:46:28 <lambdabot>  True
15:46:35 <newsham> (ie. on ia32 puts the "this" pointer into ECX(?) and then jumps to the target address)
15:46:37 <joelr1> newsham: i'll scratch my head over this. may be a moot point as the people may not have a library for mac osx
15:46:41 <bd_> why should it be anything else? :)
15:46:45 <nornagon> > map chr [32..1]
15:46:46 <lambdabot>  ""
15:46:51 <nornagon> map chr [1..32]
15:46:59 <nornagon> > map chr [1..32]
15:47:00 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ET...
15:47:16 <nornagon> oh.
15:47:20 <nornagon> > [32..1]
15:47:21 <lambdabot>  []
15:47:33 <SamB_XP> > ['\1'..'\32']
15:47:35 <lambdabot>  "\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SYN\ET...
15:47:42 <jethr0> > [32,31..1]
15:47:43 <lambdabot>  [32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,...
15:47:51 <newsham> ?type chr
15:47:53 <lambdabot> Int -> Char
15:48:14 <newsham> ?quickcheck \x -> chr x == fromEnum x
15:48:14 <lambdabot> Unknown command, try @list
15:48:21 <newsham> ?check \x -> chr x == fromEnum x
15:48:22 <lambdabot>  Couldn't match `Char' against `Int'
15:48:28 <nornagon> :t fromEnum
15:48:29 <newsham> ?check \x -> chr x == toEnum x
15:48:30 <lambdabot> forall a. (Enum a) => a -> Int
15:48:31 <lambdabot>  Exception: Prelude.chr: bad argument
15:48:55 <newsham> ?check \x' -> let x = x' `mod` 256 in chr x == toEnum x
15:48:56 <lambdabot>  OK, passed 500 tests.
15:48:57 <conal> joelr1:  i've mostly been doing non-cs stuff for the last few years, but now am back with focus.
15:49:02 <nornagon> ?check \x -> chr (x :: Char) == toEnum x
15:49:02 <lambdabot>  Couldn't match `Int' against `Char'
15:49:07 <nornagon> oops.
15:49:21 <joelr1> conal: what prompted your renewed interest?
15:49:43 <bos> conal: didn't you work with antony courtney?
15:50:17 <conal> joelr1: i don't know why the shift back.  maybe just accumulation of ideas.
15:50:21 <conal> bos: yes
15:50:40 <bos> he and i were roommates at various points as undergrads.
15:51:27 <joelr1> conal: that's awesome! i'm trying functional reactive trading. still scratching my head and trying to understand yampa, though. taking baby steps so far.
15:52:02 <conal> joelr1: wow.  where are you doing that?  and for fun or profit or what?
15:52:42 <bos> joelr1: i thought you'd abandoned haskell for erlang.
15:52:43 <conal> bos: where?
15:52:46 <joelr1> conal: http://wagerlabs.com/trading
15:52:47 <emu> ?check \l ->   l == (reverse (reverse (l::[Int])))
15:52:48 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
15:52:54 <bos> conal: trinity, in dublin.
15:53:04 <SamB_XP> bos: not forever
15:53:09 <joelr1> bos: why do people keep saying that? hmm :D i did for a while but now i'm back with a vengeance
15:53:11 <emu> ?check \l ->   l == (reverse (reverse (l::[Int])))
15:53:13 <lambdabot>  OK, passed 500 tests.
15:53:24 <SamB_XP> he just decided that *that* task was better for Erlang
15:53:35 <conal> bos: i didn't know antony was at trinity
15:54:01 <bos> yep.
15:54:34 <joelr1> conal: i'm trying to trade futures, i'm on a mac whereas all trading software is windows, i'm not satisfied with what i'm given either.
15:54:43 <joelr1> conal: i want elegance and power to experiment
15:54:49 <nornagon> hm, how do you get show :: Int -> [Char], but get it to display in octal?
15:55:06 <SamB_XP> what are futures?
15:55:06 <conal> joelr1: oh yeah -- now i remember your recent yampa email and the wagerlabs link
15:55:36 <joelr1> SamB: http://en.wikipedia.org/wiki/Futures_contract
15:55:37 <lambdabot> Title: Futures contract - Wikipedia, the free encyclopedia
15:56:02 <SamB_XP> ah
15:56:09 <nornagon> > showHex 12
15:56:11 <lambdabot>  <[Char] -> [Char]>
15:56:17 <nornagon> > showHex 12 ""
15:56:18 <lambdabot>  "c"
15:56:30 <joelr1> conal: i think i'm gonna have a tough go but i'm willing to take the risk for the sake of learning :-) last time i tried haskell i found lots of issues
15:56:55 <joelr1> dons said i found like 42 bugs in the ghc but i don't think it was _that_ many
15:57:03 <conal> joelr1: practical issues (tool problems)?
15:57:33 <nornagon> > showOct 12 ""
15:57:34 <lambdabot>  "14"
15:57:50 <joelr1> conal: let me dig up the most famous article on my blog (of all times) ... http://wagerlabs.com/2006/1/1/haskell-vs-erlang-reloaded
15:57:51 <lambdabot> Title: Tenerife Skunkworks&mdash;Trading & Technology
15:57:54 <xpika> > showBin 12 ""
15:57:55 <lambdabot>   Not in scope: `showBin'
15:58:02 <xpika> @hoogle bin
15:58:03 <lambdabot> Network.Socket.bindSocket :: Socket -> SockAddr -> IO ()
15:58:03 <lambdabot> Language.Haskell.TH.bindS :: PatQ -> ExpQ -> StmtQ
15:58:03 <lambdabot> System.Console.Readline.bindKey :: Char -> Callback -> IO ()
15:58:13 <xpika> @hoogle binary
15:58:13 <lambdabot> System.Win32.File.BinaryType :: type BinaryType
15:58:14 <lambdabot> System.Win32.File.sCS_32BIT_BINARY :: BinaryType
15:58:14 <lambdabot> System.Win32.File.sCS_DOS_BINARY :: BinaryType
15:58:18 <joelr1> conal: bugs and practical issues and inconveniences
15:59:12 <conal> joelr1: i'm glad you posted so people know what to fix.  thanks!
15:59:24 <joelr1> bos: i could use erlang but i'm trying to do something declarative as opposed to imperative
15:59:39 <joelr1> describe trading systems in terms of what i want as opposed to how i want to do it
15:59:41 <bos> joelr1: sure.
15:59:59 <bos> i've been wanting a typed network channel mechanism in haskell for a bit.
16:00:04 <joelr1> describe when to buy and sell as opposed to set up message handlers and return messages
16:00:14 <joelr1> bos: me too /channel/
16:00:15 <conal> joelr1: has something changed that prompted you to want to try haskell again?
16:00:41 <bos> joelr1: let me see if i can cobble something together.
16:01:10 <joelr1> conal: declarative vs. imperative, right above. erlang is all about setting up message handlers, for example. haskell is declarative. can be declarative. and trading systems look a lot like yampa robots.
16:01:43 <joelr1> conal: they react to external events and quotes and trades have a timeline as well. so yampa seems to fit like a glove. at a very first glance anyway.
16:01:46 <bos> i want to take a go at dusting off http://www-i2.informatik.rwth-aachen.de/old/Research/distributedHaskell/index.html
16:01:49 <lambdabot> Title: Distributed Haskell, http://tinyurl.com/y92mku
16:01:59 <joelr1> bos: cool!
16:02:02 <conal> joelr1: i hope it works out for you.  if not, let's hear about it!
16:02:42 <joelr1> conal: oh, you'll hear all about it for sure. i plan to blog about the process and i'll surely complain a lot :-)
16:03:26 <conal> joelr1: great
16:03:31 <joelr1> conal: i will be pleased to have you as a subscriber. and of course don't hold any comments back!
16:03:47 <joelr1> bos: what would be really cool is dusting off GdH!
16:03:56 <joelr1> alas, i think that's a pipe dream
16:03:59 <conal> joelr1: you bet.  is your blog on planet.haskell.org?
16:05:10 <joelr1> conal: no, it's not. i keep forgetting who i have to ask. plus, i post about trading in the context of haskell and outside.
16:05:33 <bos> joer1: gdh was broken by design, as i recall.
16:06:14 <conal> joelr1: okay.  then i'll subscribe directly.  if you want to get on p.h.o, email antti-juhani@kaijanaho.fi
16:06:56 <bos> the rForkIO model is just broken.
16:07:00 <joelr1> conal: cool. emailing!
16:11:27 <sorear> what was MathematicalOrchid's nick?
16:12:51 <conal> hey, everybody -- how about adding yourself to http://www.frappr.com/haskellers, so we can see where you are, etc?
16:13:55 <sorear> where on the page is the map?
16:14:03 <bos> frappr spams incessantly, i found.
16:14:23 <bos> maybe they've corrected their behaviour, but i found them obnoxious in the extreme.
16:15:26 <conal> bos: oh, yurk.
16:16:04 <bos> i can't guarantee that frappr is still so annoying, so ymmv.
16:16:13 <sorear> I can't figure out which image is the map... (elinks user)
16:16:41 <SamB_XP> sorear: don't even try to use frappr with elinks
16:16:50 <SamB_XP> it is basically google maps with pins stuck in it
16:17:20 <sorear> shouldn't I at least be seeing [APPLET] then?
16:17:31 <SamB_XP> google maps runs on javascript!
16:17:37 <SamB_XP> how could you not know this?
16:18:00 <SamB_XP> heh. applet!
16:18:43 <sorear> well duh.  fupplet's aren't widely supported enough. :)
16:18:59 <SamB_XP> what is a fupplet?
16:19:08 <SamB_XP> anyway applets are old-fashioned
16:23:16 <bos> @type shiftL
16:23:18 <lambdabot> forall a. (Bits a) => a -> Int -> a
16:24:06 <sorear> http://www.cs.chalmers.se/~hallgren/Thesis/main.html#wwwbrowser
16:24:08 <lambdabot> Title: HacWrite
16:24:30 <sorear> FUdget aPPLETs
16:24:46 <clanehin> if any yhc people are on, scons; scons clean; scons doesn't work for me, it asks if I have a working C compiler
16:25:18 <sorear> amazingly hard to find - google seems to have not indexed the word, even though it is linked to by an indexed page
16:29:53 <svref> Is there any ghc command-line switch like "--tell-me-WHERE-my-goddamned-fatal-error-is-coming-from" ?
16:30:59 <heatsink> svref: did the impossible happen?
16:31:03 <svref> ghc seems to have really good compile time errors, and almost non-existant run-time errors.
16:31:13 <svref> heatsink: yep: fromJust failed
16:31:23 <heatsink> oh, one of those... ick.
16:31:24 <wolverian> existent
16:31:46 * heatsink hasn't dealt with ghc runtime errors
16:33:03 <sorear> svref: don't use fromJust. ever.
16:33:22 <svref> sorear: because the error is impossible to track down?  :)
16:33:31 <heatsink> Wait... is this an error during compilation, or while your program is running?
16:33:33 <jcreigh> yeah...lately I've just been avoiding fromJust, and instead do something like fromMaybe (error $ "Undefined variable: " ++ var) (Map.lookup var env)
16:33:34 <sorear> svref: if you absolutely must, use -prof while compiling and +RTS -xs when running
16:34:02 <sorear> svref: because it destroys haskell's static error checking properies.
16:34:11 <jcreigh> which at least gives a meaningful error message.
16:34:25 <sorear> svref: if you wanted runtime errors, what are you doing learning Haskell? :)
16:34:39 <heatsink> svref: I'd suggest replacing each fromJust with a function that prints out a different message before it forces the value, using trace.
16:34:52 <sorear> oh, and those options are broken in 6.6 iirc - use 6.4.2 or HEAD
16:35:15 <sorear> I'd suggest replacing every use of fromJust with case.
16:36:00 <clanehin> fromMaybe . . . ?
16:36:03 <sorear> fbset -a 1024x768-74
16:36:26 * sorear loves focus
16:37:46 <svref> sorear apperantly has multiple installations running at the same time.  And I though I was a studmuffin to compile the 6 or so libraries I needed for a single version.
16:37:48 <lisppaste2> heatsink pasted "Type function in a class constraint?" at http://paste.lisp.org/display/34838
16:39:09 <sorear> yes, and I pull and recompile weekly. It takes <2 hours on my 2Ghz P4, and is almost completely automated. ./darcs-all pull && ./configure && make && su -c 'make install'
16:39:20 <heatsink> Apparently there are limits on how type constructors are partially applied.  I'd appreciate help on how to do that class definition.
16:39:49 <sorear> heatsink: type X a = Y -- is *not* a type constructor
16:40:18 <sorear> btw, what "class definition"?
16:40:57 <complaisant> hi anyone can give me a help with Data.Map i'll post a code in a sec
16:40:59 <complaisant> ?paste
16:40:59 <lambdabot> http://paste.lisp.org/new/haskell
16:41:22 <heatsink> d'oh! That's supposed to be instance.
16:41:48 <sorear> heatsink: was it mentioned before I joined?
16:42:01 <heatsink> I pasted it a few lines ago.
16:42:50 <heatsink> Hold on, I'll fix the line I got wrong...
16:43:26 <lisppaste2> complaisant pasted "help" at http://paste.lisp.org/display/34839
16:43:31 <lisppaste2> heatsink annotated #34838 with "instance definition" at http://paste.lisp.org/display/34838#1
16:43:49 <sorear> heatsink: (1) type synonyms can't be used in instances (2) partially applied type synonyms are forbidden, for termination reasons
16:44:13 <heatsink> Hmm, okay.
16:45:56 <tuukkah> sorear, do those hold for newtype too?
16:46:17 <sorear> no
16:46:22 <heatsink> So if I didn't have that extra type variable 'state', then I would have an acceptable instance declaration: instance Holds t => Holds [t] where ...
16:46:30 <sorear> yes
16:46:42 <heatsink> Can I have the extra type variable and still do the instance declaration?
16:47:37 <sorear> Switching to a newtype would work...
16:48:27 <sorear> and I can't see a better way atm
16:48:42 <heatsink> complaisant: Try putting type annotations on aux and aux2.  You may get a more informative error message.
16:49:13 <sorear> complaisant: don't use Map Int (Map Int foo) unless you have a specific reason - Map (Int,Int) foo is possible
16:50:16 <sorear> insert needs a value
16:50:24 <sorear> > M.insert "foo" M.empty
16:50:25 <lambdabot>  Add a type signature
16:50:28 <sorear> > M.insert "foo" "bar" M.empty
16:50:29 <lambdabot>  {"foo":="bar"}
16:50:39 <complaisant> k
16:51:09 <sorear> why do you use a curried map?
16:51:55 <heatsink> sorear: Thanks.  I'll try it with a newtype.
16:53:46 <complaisant> i used it so i can insert in a more simpler way like : insere l c m t = insert l (insert c Empty t)
16:54:20 <complaisant> where Empty is a data Marker = Black | White | Empty
16:55:57 <complaisant> sorear if i type ur code in my ghci version i get  " fromList [("foo","bar")] "
16:56:03 <sorear> your variable names are too short ... are l and c coordinates ?
16:56:25 <sorear> yes, lambdabot has a bit of magic to make thinks less verbose
16:56:39 <sorear> insert l c m t = insert (l,c) m t ?
16:56:47 <complaisant> yes
16:56:58 <complaisant> l & c stands for line / column
16:57:05 <complaisant> m = marker & t = tab
16:58:33 <sorear> curried: aux l c m t = insert l (insert c m (fromMaybe empty (lookup l m))) m
16:58:43 <sorear> uncurried: aux l c = insert (l,c)
16:59:04 <sorear> (eta-reduced by two variables)
16:59:59 <sorear> > let aux l c m t = insert l (insert c m (fromMaybe empty (lookup l m))) m in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" empty)))
17:00:06 <sorear> > let aux l c m t = insert l (insert c m (fromMaybe empty (lookup l m))) m in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" empty)))
17:00:06 <lambdabot>  Parse error
17:00:25 <sorear> > let aux l c m t = insert l (insert c m (fromMaybe empty (lookup l m))) m in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" empty))
17:00:26 <lambdabot>   Not in scope: `empty'
17:00:39 <sorear> > let aux l c m t = M.insert l (M.insert c m (fromMaybe M.empty (M.lookup l m))) m in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" M.empty))
17:00:40 <lambdabot>      Occurs check: cannot construct the infinite type:
17:00:40 <lambdabot>       a = Data.Map.Map...
17:01:02 <sorear> > let aux l c m t = M.insert l (M.insert c m (fromMaybe M.empty (M.lookup l t))) m in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" M.empty))
17:01:02 <lambdabot>      Occurs check: cannot construct the infinite type:
17:01:03 <lambdabot>       a = Data.Map.Map...
17:01:18 <sorear> > let aux l c m t = M.insert l (M.insert c m (fromMaybe M.empty (M.lookup l t))) t in aux 2 2 "foo" (aux 3 3 "bar" (aux 3 5 "quux" M.empty))
17:01:19 <lambdabot>  {2:={2:="foo"},3:={3:="bar",5:="quux"}}
17:01:31 <sorear> ^^^ that what you want, complaisant?
17:02:47 <complaisant> i want to create a new Tab with Marker = Empty given the bounds.. | createTab x y tab = ...
17:04:42 <complaisant> this is the game i'm doing http://jogos.aborla.net/k.php
17:04:46 <sorear> > let createTab x y = M.fromList [ (yc,M.fromList [ (xc,"empty") | xc <- [ 0 .. (x-1) ] ]) | yc <- [ 0 .. (y-1) ] in createTab 4 4
17:04:46 <lambdabot>  Parse error
17:04:48 <lambdabot> Title: Jogos On-Line - 4 em Linha
17:04:55 <sorear> > let createTab x y = M.fromList [ (yc,M.fromList [ (xc,"empty") | xc <- [ 0 .. (x-1) ] ]) | yc <- [ 0 .. (y-1) ] ] in createTab 4 4
17:04:56 <lambdabot>  {0:={0:="empty",1:="empty",2:="empty",3:="empty"},1:={0:="empty",1:="empty",...
17:05:07 <sorear> ^^^ that what you want?
17:06:38 <heatsink> sorear: I got an error about the "Coverage Condition" and I'm reading something on haskell-cafe about it.  What is the instance head?
17:06:48 <complaisant> yes . that's it something like that . i guessed comprehension lists might do it
17:07:47 <sorear> instance (Foo a) => Bar (Baz a) where
17:07:55 <sorear> NichardRixon: Baz a
17:08:04 <NichardRixon> what
17:08:21 <sorear> is the instance head in the example
17:08:30 <heatsink> I think you meant to address that to me :)
17:08:33 <NichardRixon> :(
17:08:47 <sorear> oh yes, sorry :)
17:09:19 <heatsink> got it, I'll try to understand what's going on now.
17:13:40 <sorear> @users
17:13:45 <sorear> @users
17:13:45 <lambdabot> Maximum users seen in #haskell: 315, currently: 278 (88.3%), active: 39 (14.0%)
17:13:53 <ClaudiusMaximus> quick question about hs-plugins - what effect does a module declaration in a plugin source file have?  beneficial? harmful? neither?
17:14:18 <sorear> huh? what's a module declaration?
17:14:29 <ClaudiusMaximus> module Blah where
17:14:36 <sorear> that's mandatory
17:14:46 <ClaudiusMaximus> ok
17:14:50 <ClaudiusMaximus> thanks :)
17:14:55 <sorear> h98 specifies that "" is shorthand for module Main(main) where
17:15:28 <sorear> in Haskell, every file has a module declaration - hs-plugins isn't needed for it to be mandatory.
17:32:34 <sorear> @seen
17:32:34 <lambdabot> Lately, I have seen bos and sorear.
17:32:46 <bos> all quiet.
17:32:47 <nornagon> @seen
17:32:48 <lambdabot> Lately, I have seen bos, nornagon and sorear.
17:33:20 <sorear> were you /msg'ing it?
17:35:49 <nornagon> sorear: no
17:36:24 <nornagon> hm, how do i get show '\SOH' to return "\\SOH" instead of "'\\SOH'" ?
17:38:55 <|shad0w|> escape the escapes ? \\\\
17:39:17 <e_e_coli> nornagon, your question reminds me of Linus complaining to Lucy that he's trying to say "brzazaza" but he can only say "brlalala"
17:39:41 <sorear> nornagon: init . tail
17:39:52 <sorear> > init $ tail $ show '\SOH'
17:39:56 <sorear> > init $ tail $ show '\SOH'
17:39:57 <lambdabot>  "\\SOH"
17:40:23 <sorear> I wish I knew what's going on with lambdabot... I can't reproduce it with sorear-lambdabot
17:41:41 <bd_> Just be sure to feed the bot before asking it any favors, it's worked for me :)
17:41:43 <bd_> :t id
17:41:45 <lambdabot> forall a. a -> a
17:41:46 <nornagon> e_e_coli: ... quite
17:41:49 <nornagon> bd_: heh
17:41:53 <bd_> bleh, worked on an empty stomach this time
17:41:55 <e_e_coli> what does "start of heading" mean in ASCII?
17:42:04 <nornagon> @bs
17:42:04 <lambdabot> Done.
17:42:07 <nornagon> :t init
17:42:08 <sorear> it's a teletype control.
17:42:08 <lambdabot> forall a. [a] -> [a]
17:42:16 <nornagon> > init [1..10]
17:42:17 <lambdabot>  [1,2,3,4,5,6,7,8,9]
17:42:21 <sorear> @help bs
17:42:21 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
17:42:22 <nornagon> ah, untail.
17:42:26 <sorear> @vs___
17:42:26 <lambdabot> Unknown command, try @list
17:42:29 <sorear> @bs___
17:42:29 <lambdabot> Unknown command, try @list
17:42:32 <sorear> @bs__
17:42:32 <lambdabot> Unknown command, try @list
17:42:34 <sorear> @bs_
17:42:35 <lambdabot> Maybe you meant: ask bf bug msg
17:42:39 <nornagon> @bot
17:42:39 <lambdabot> :)
17:42:40 <sorear> @bf
17:42:40 <lambdabot> Done.
17:42:45 <nornagon> how odd.
17:42:53 <sorear> what?
17:43:05 <nornagon> why's she saying "Done."?
17:43:30 <nornagon> @bf +++++++++++++++++++++++++++++++++++.
17:43:30 <lambdabot>  #
17:44:05 <nornagon> @bf ++++++[>+++++<-]>.
17:44:06 <lambdabot> Done.
17:44:08 <Eelis> man, i thought bot spamming was bad in ##c++, but it's absolutely *nothing* compared to what you Haskell lads are capable of
17:44:11 <nornagon> @bf ++++++[>+++++<-]>+++.
17:44:11 <lambdabot>  !
17:44:19 <nornagon> @bf ++++++[>+++++<-]>+.
17:44:20 <lambdabot> Done.
17:44:22 <nornagon> @bf ++++++[>+++++<-]>++.
17:44:29 <nornagon> @bf ++++++[>+++++<-]>++++.
17:44:29 <lambdabot>  "
17:44:52 <nornagon> @bf ,.
17:44:52 <lambdabot> Done.
17:44:54 <bd_> nornagon: no output?
17:44:58 <bd_> nornagon: also, there's /msg :)
17:45:10 <nornagon> aw, but i like spamming the channel :)
17:45:17 <bd_> tsk tsk
17:45:27 <sorear> there are much more effective ways
17:45:30 <sorear> @list-all
17:45:30 <lambdabot> babel provides: babel
17:45:31 <lambdabot> base has no visible commands
17:45:31 <lambdabot> bf provides: bf
17:45:31 <lambdabot> check provides: check
17:45:33 <lambdabot> compose provides: . compose
17:45:35 <lambdabot> dice provides: dice
17:45:37 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:45:38 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
17:45:40 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools
17:45:43 <lambdabot> elite provides: elite
17:45:43 <bd_> oh dear, no @more on this?
17:45:45 <lambdabot> eval provides: run let undefine
17:45:49 <lambdabot> Plugin `system' failed with: IRCRaised thread killed
17:46:01 <sorear> fortunately, there *is* a timeout.
17:46:38 <sorear> list-all is the semi-undocumented hook used to generate the page at @list
17:46:38 <e_e_coli> > ['\SOH']
17:46:39 <lambdabot>  "\SOH"
17:48:49 <bos> what's a good word to describe the number of elements of a tuple?
17:48:52 <bos> rank?
17:48:55 <e_e_coli> arity
17:48:57 <bos> i don't care for "size".
17:49:14 <bos> i'd have thought of arity as being a property of the tuple's constructor.
17:49:32 <nornagon> e_e_coli: needs one more \ ;)
17:49:32 <bos> but i suppose it works.
17:49:48 <e_e_coli> nornagon: d'oh :)
18:02:05 <nornagon> hm, how does one work with unicode characters in haskell? "\x2834" should be u+2834 BRAILLE PATTERN DOTS-356, but putStrLn "\x2834" shows just 4
18:02:19 <sorear> hah
18:02:26 <sorear> you don't
18:02:33 <nornagon> hmph :(
18:02:41 <sorear> or at least you have to do the utf-8 encoding yourself
18:02:49 <nornagon> > chr 0x2834
18:02:59 <sorear> @botsnack
18:02:59 <lambdabot> :)
18:03:01 <nornagon> > chr 0x2834
18:03:02 <lambdabot>  '\10292'
18:03:16 <sorear> haskell supports unicode fully
18:03:39 <nornagon> > putStrLn $ "\10292"
18:03:40 <nornagon> 4
18:03:41 <lambdabot>  <IO ()>
18:03:42 <sorear> it's just that the fine folks at glasgow think "encoding" means "down-casting to 8 bits"
18:03:54 <nornagon> :(
18:04:49 <sorear> I believe Bulat's "streams" replacement IO lib supports character encoding
18:05:19 <sorear> my vty does utf-8 automatically, including the neccessary terminal setup
18:06:14 <nornagon> :)
18:08:28 <nornagon> hm, what's an easy way to match case-insensitively with parsec? (for a specific parser)
18:08:52 <nornagon> i mean, i could do (string "U+" <|> string "u+"), but that's ugly
18:11:30 <sorear> ichar ch = satisfy (equating toLower ch)
18:11:42 <sorear> istring = sequence_ . ichar
18:11:49 <sorear> that easy enough?
18:11:50 <nornagon> :t sequence_
18:11:52 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
18:12:15 <sorear> for inst: [CharParser ()] -> CharParser ()
18:12:42 <sorear> which turns a list of parsers into a parser that parses each one in turn
18:13:14 <nornagon> hm.
18:13:26 <nornagon> monad trickery still confuses me :S
18:13:45 <nornagon> though i understand how monads work, a bit.
18:13:57 <augustss> I'd do 'istring = sequence . ichar'
18:14:18 <sorear> augustss: why?
18:14:26 <allbery_b> sequence_ discards the result
18:14:45 <allbery_b> ...you probably want to know what that string you just parsed is
18:15:05 <sorear> allbery_b: ichar returns ().  Does that really interest you?
18:15:08 <nornagon> allbery_b: doubtful
18:15:31 <nornagon> allbery_b: it's pretty obvious what string "foo" parses :)
18:16:24 <e_e_coli> ghci doesn't have that forall preamble to type annotations; is that hugs?
18:16:25 <allbery_b> oh sorry, misread what was ggoing on there
18:16:36 <allbery_b> yeh, sequence_ is preferab;e for that
18:17:03 <allbery_b> forall is ghc/ghci.  whether you get it depends on how you ask it
18:17:15 <e_e_coli> I'm using :t
18:18:59 <complaisant> does this err msg -> *** Exception: Map.find: element not in the map -> can b handled with monad error ?
18:19:14 <complaisant> monad error handles this kind of exceptions ?
18:19:20 <sorear> no
18:19:26 <complaisant> :\
18:19:30 <sorear> don't use find
18:19:35 <complaisant> ?
18:19:41 <complaisant> lookup ?
18:19:51 <sorear> partial functions are the bane of debuggability
18:20:07 <sorear> ?type Data.Map.Find
18:20:09 <lambdabot> Not in scope: data constructor `Data.Map.Find'
18:20:09 <sorear> ?type Data.Map.find
18:20:11 <lambdabot> Not in scope: `Data.Map.find'
18:20:20 <complaisant> ?type Data.Map.!
18:20:22 <lambdabot> parse error on input `Data.Map.!'
18:20:26 <complaisant> ?type !
18:20:27 <lambdabot> parse error on input `!'
18:20:29 <sorear> ?type (Data.Map.!)
18:20:30 <complaisant> ?type (!)
18:20:31 <lambdabot> forall a k. (Ord k) => Data.Map.Map k a -> k -> a
18:20:32 <lambdabot> forall e i. (Ix i) => Array i e -> i -> e
18:20:50 <sorear> why just 'Map'? There is no module named Map.
18:20:58 <sorear> Or is that from hslibs?
18:21:07 <allbery_b> ou want lookup
18:23:38 <complaisant> well i can allways convert my Map to a list & handle it there.. but it's not the ideal solution
18:26:32 <complaisant> argh... btw lookup do it
18:28:21 <nostrademons> > take 10 ['A'..]
18:28:22 <lambdabot>  "ABCDEFGHIJ"
18:28:51 <nostrademons> really, lambdabot is *far* more convenient than GHCI...
18:29:16 <sorear> *If* you've > ~5 commands, /msg exists
18:30:03 <tuukkah> > getLine
18:30:05 <lambdabot>  <IO [Char]>
18:31:49 <tuukkah> > Foreign.unsafePerformIO System.getArgs
18:31:50 <lambdabot>   Not in scope: `System.getArgs'
18:31:57 <nornagon> also local lambdabot is nice :)
18:32:14 <tuukkah> > Foreign.unsafePerformIO System.Environment.getArgs
18:32:14 <lambdabot>   Not in scope: `System.Environment.getArgs'
18:32:32 <tuukkah> nornagon, can you use it like ghci?
18:32:51 <nornagon> tuukkah: not without hsplugins, i fear :(
18:33:00 <nornagon> i usually have both ghci and lb open though
18:33:23 <tuukkah> i can wait for hsplugins for ghc 6.6 :-)
18:33:38 <nornagon> i want goa to work :(
18:33:48 <tuukkah> what's that?
18:33:56 <araujo> hello
18:33:56 <sorear> GHCi on acid
18:34:00 <sorear> @where goa
18:34:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
18:34:06 <sorear> hello araujo!
18:36:16 <tuukkah> i would like a better emacs mode
18:36:45 <nornagon> i would like a better vim mode ;P
18:37:00 <tuukkah> i could settle with yi or whatever
18:37:05 <nostrademons> i would like a better Eclipse plugin ;-P
18:37:38 <nostrademons> actually, I haven't tried EclipseFP in a long time, so it may be a better Eclipse plugin...
18:39:35 <tuukkah> we could gather a haskell choir of complaints :-)
18:42:23 <nostrademons> take 7 . cycle . map ("I want a better " ++) $ ["emacs mode", "vim mode", "Eclipse plugin"]
18:42:29 <nostrademons> > take 7 . cycle . map ("I want a better " ++) $ ["emacs mode", "vim mode", "Eclipse plugin"]
18:42:41 <sorear> @botsnack
18:42:41 <lambdabot> :)
18:42:46 <nostrademons> pooh.
18:44:24 <nostrademons> see, that was something ghci had no problem with...
18:44:26 <allbery_b> just try it again.  the bot seems to fall asleep at times
18:44:31 <nostrademons> > take 7 . cycle . map ("I want a better " ++) $ ["emacs mode", "vim mode", "Eclipse plugin"]
18:44:32 <lambdabot>  ["I want a better emacs mode","I want a better vim mode","I want a better Ec...
18:44:39 <nostrademons> heh, gets cut off anyway
19:00:43 <xpika> > [1..]
19:00:44 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
19:02:16 <xpika> @hoogle sleep
19:02:17 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
19:02:27 <allbery_b> @hoogle delay
19:02:27 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
19:02:27 <lambdabot> Network.Socket.NoDelay :: SocketOption
19:02:27 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
19:05:59 <goltrpoat> thought.  'numerical recipes' has done interesting things for C/C++ (im sure it did the same things for fortran, but that'd be before my time).  i think ive had to look it up for one thing or another once every six months for the past 10 years or so.  why don't we have a similar cookbook type publication for haskell?
19:06:12 <xpika> haskell is only the 42nd highest ranking on http://www.tiobe.com/index.htm?tiobe_index but it is one of the most popular changs on freenode.
19:06:56 <sorear> Does "purely functional data structures" come close?
19:07:24 <syntaxfree> "chris osasaki" almost sounds like a fictional name.
19:07:55 <xpika> sounds like japanese
19:07:58 <goltrpoat> sorear:  it talks about things that are a lot less.. interesting though.
19:07:59 <goltrpoat> hehe
19:08:24 * sorear has never actually read either
19:08:28 <xpika> is pfds a good book?
19:09:17 <goltrpoat> i don't own pfds -- i probably should have it, but i remember going over the table of contents and just not finding anything that i'd want insight on
19:09:33 <goltrpoat> not to say that it's a bad book by any means, a lot of people swear by it
19:10:36 <goltrpoat> just seemed like the topics it was discussing were things that i had either done as exercises, or had to do in production one way or another
19:10:45 <newsham> in FFI, I want to use some pointers as a "handle" (ie. i'll never peek inside of them).  but I still want haskell's type system to know about the different types.
19:10:52 <syntaxfree> xpika: it's a mixture of japanese and american that sounds like it's coming out from a bad "the matrix" rip-off.
19:11:07 <newsham> should I do:  "data _Foo = Foo; type FooHandle = Ptr _foo" ?
19:11:09 <syntaxfree> Chris Osasaki by day, by night Zeno, the Super Hacker.
19:11:11 <sorear> I keep reading it as okasaki
19:11:37 <goltrpoat> sorear:  http://citeseer.ist.psu.edu/27428.html
19:11:44 <sorear> iirc some eponymous-dna-replication-process guy
19:11:49 <goltrpoat> by "chris okasaki"
19:12:31 <sorear> newsham: no, because _foo is an unbound type variable :)
19:12:45 <sorear> I think in current Haskell _ is always lowercase
19:12:45 <newsham> err.. _Foo.
19:12:50 <sorear> @ty _Foo
19:12:51 <newsham> ok, so Foo_
19:12:51 <lambdabot> Not in scope: `_Foo'
19:12:56 <sorear> @ty Data._Foo
19:12:56 <goltrpoat> im guessing there will be a cage fight to the death at some point.  between chris osasaki and chris okasaki.
19:12:57 <lambdabot> Couldn't find qualified module.
19:13:02 <goltrpoat> whoever wins, gets to pick the consonant.
19:13:02 <sorear> @ty Data.Map._Foo
19:13:04 <lambdabot> Not in scope: `Data.Map._Foo'
19:13:08 <sorear> @ty Data.Map.Foo
19:13:08 <newsham> but do you understand what I mean?  is it legit to make up a dummy type and a Ptr to that dummy type?
19:13:09 <lambdabot> Not in scope: data constructor `Data.Map.Foo'
19:13:13 <sorear> @ty Data.Map._foo
19:13:14 <lambdabot> Not in scope: `Data.Map._foo'
19:13:15 <newsham> to represent an opaque handle?
19:13:17 <sorear> @ty Data.Map.foo
19:13:18 <lambdabot> Not in scope: `Data.Map.foo'
19:13:44 <sorear> ok, _Foo is treated as lowercase ... you'll need Ptr Foo
19:13:59 <newsham> data Foo_ = Foo_;  type Foo = Ptr Foo_
19:14:08 <sorear> and yes, phantom types are a large part of the reason for a higher kinded Ptr
19:14:21 <newsham> but in actuality in C,  typedef struct foo *Foo;
19:14:37 <newsham> ok
19:14:45 <newsham> just wanted to make sure its not gonna try to deref anything
19:17:51 <goltrpoat> anyway, re the book, i think i'm just going to keep using my blog as a means to construct clean examples of non-trivial problems in haskell, and once it reaches a certain critical mass, try starting to expand on those and see what happens when they get put together.
19:18:54 <goltrpoat> probably put together a wiki at that point and see if the people here with more expertise can make things cleaner.
19:21:23 <sorear> are you on p.h.o ?
19:22:04 <goltrpoat> p h what? :)
19:22:14 <notsmack> goltrpoat: org :-)
19:22:21 <notsmack> goltrpoat: (planet.haskell)
19:22:25 <goltrpoat> ohh right
19:22:48 <goltrpoat> i'm not, i figured i'd get to 10 posts or so before doing that
19:23:45 <goltrpoat> basically, haskell is ridiculously well suited to prototyping and illustrating algorithms.  so i want to sort of hammer on that.
19:26:35 <nostrademons> y'know, it's kinda ironic that the hardest thing about a type-inferencing algorithm is a.) printing error messages and b.) giving prettified names to variabes that remain in the type
19:27:11 <nostrademons> unification? easy.  constraint generation? not so hard.  but the pretty stuff is really difficult
19:27:14 <slava> you're writing a compiler?
19:27:18 <nostrademons> of course
19:27:53 <nostrademons> interpreter, actually, at the moment
19:27:55 <araujo> heya sorear
19:27:58 <nostrademons> compiler will come later
19:27:59 <bos> @pl \a b -> (compare a 1, compare b 1)
19:28:23 <bos> lambdabot go boom?
19:28:35 <nornagon> @botsnack
19:28:35 <lambdabot> :)
19:28:40 <nornagon> try again
19:28:48 <bos> @pl \a b -> (compare a 1, compare b 1)
19:28:48 <lambdabot> (. flip compare 1) . (,) . flip compare 1
19:28:54 <nornagon> she hates answering questions on an empty stomach.
19:28:54 <slava> nostrademons: at what point does the interpreter perform type inference?
19:28:55 <bos> ugh.
19:29:05 <bos> nornagon: :-)
19:29:44 <bos> be nice if there were arrows for tuples.
19:29:45 <goltrpoat> nostrademons:  hardest, really?  b) was more or less trivial for me, and a) happened just due to the THIH paper being written in a certain manner.  i remember spending a lot more time on just trying to figure out what was going on in the paper :)
19:30:23 <bos> THIH?
19:30:30 <goltrpoat> typing haskell in haskell
19:30:33 <bos> i hath a prothlem with thih.
19:30:37 <bos> ah.
19:31:11 <sorear> I've written a very short unifier ... i've also completely solved the error message problem :)
19:31:27 <goltrpoat> i had very little exposure to type theory before reading it, so it was a fairly odd experience.
19:31:43 <nostrademons> slava: right after parsing, before evaluation.  it's part of a REPL, the REPL prints both the type and value
19:31:53 <sorear> my unifier never fails without giving an *excellent* error message.
19:31:58 <slava> nostrademons: fair enough.
19:32:16 <goltrpoat> my unifier fails with giving some remarkably obfuscated messages.
19:32:19 <nostrademons> goltrpoat: I've been looking at THAH, but I'm starting with something much simpler.  basic Hindley-Milner, really, out of TAPL
19:32:40 <goltrpoat> nostrademons:  oh ok.. so no rank-2+ types, etc?
19:32:57 <nostrademons> nope, nor qualified types, predicates, records, or typeclasses
19:33:00 <nostrademons> may add those later
19:33:03 <sorear> mine does something quite simple ... it implements rank-1 + (->) + universal quantification + infinite types
19:33:07 <slava> nostrademons what is this for?
19:33:16 <goltrpoat> i should revisit this, really.  i don't think i had any clue what i was doing when i wrote mine.
19:33:17 <nostrademons> at the moment, personal edification ;-)
19:33:24 <nostrademons> maybe it'll grow into something useful eventually
19:33:40 <sorear> infinite types are a very cute trick
19:33:41 <neall> hello
19:33:45 <nostrademons> hello
19:33:49 <sorear> hello
19:34:10 <neall> How implementation a simple IO procedure in haskell ?
19:34:20 <sorear> huh?
19:35:18 <notsmack> neall:  like what?
19:35:49 <neall> notsmask: like, getchar() or putchar()
19:36:23 <sorear> you can't write getchar in haskell - it is a primitive operation
19:36:34 <sorear> (and why would you apply it to () ? )
19:36:40 <notsmack> sorear: heh
19:37:46 <goltrpoat> sorear:  i think neall was just quoting the c syntax as an example :)
19:37:51 <nostrademons> it's basically a callout through the C interface, isn't it?
19:38:02 <sorear> @src getChar
19:38:03 <lambdabot> getChar = hGetChar stdin
19:38:11 <nostrademons> @src hGetChar
19:38:11 <lambdabot> Source not found. My pet ferret can type better than you!
19:38:24 <sorear> @docs GHC.Handle
19:38:25 <lambdabot> GHC.Handle not available
19:38:29 <sorear> @source GHC.Handle
19:38:30 <lambdabot> GHC.Handle not available
19:38:35 <TSC> lambdabot is getting a bit argumentative
19:38:51 <nornagon> heh.
19:39:06 <araujo> getChar would be something equivalent to, getChar = ccall getchar
19:39:35 <sorear> ccall still exists?  I thought we used foreign import thesedays.
19:39:47 <araujo> Though ccall is a language cosntruct, instea dof a function.
19:40:12 <bd_> nostrademons: Actually, it's a lot more complex :)
19:40:20 <bd_> take a look at http://darcs.haskell.org/ghc-6.6/packages/base/GHC/IO.hs and http://darcs.haskell.org/ghc-6.6/packages/base/GHC/IOBase.lhs
19:40:23 <bd_> for the details
19:42:16 <bd_> nostrademons: the buffer managment in particular seems to be handled on the haskell side
19:42:17 <nostrademons> heh.  so, callout to C, plus a whole lot of buffering and IORef stuff
19:42:37 <bd_> http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Handle.hs relevant too
19:42:57 <araujo> nostrademons, ?
19:42:57 <bd_> which is where the foreign calls seem to be
19:43:57 <nostrademons> interesting
19:44:24 <nostrademons> "foreign import ccall safe "__hscore_PrelHandle_read" "
19:44:36 <xpika> is there any languages more advanced than haskell?
19:44:46 <allbery_b> define "advanced"
19:44:46 <sorear> shh!
19:44:55 <xpika> apart from the human ones
19:45:13 <sorear> neall: question suitibly answered?
19:45:20 <nostrademons> yeah, we really need to know what "advanced" means to answer that
19:45:31 <xpika> operates at the highest level of abstraction
19:45:47 <xpika> hmm
19:46:21 <xpika> that would make VM languages advanced.
19:46:50 <bd_> The VM is an implementation detail.
19:46:52 <sorear> what's a vm language?  All my languages have virtual memory.
19:46:53 <nostrademons> not necessarily - VM is an implementation technique
19:47:08 <xpika> "virtual machine"
19:47:09 <goltrpoat> cobol is quite abstract.  i don't know that this is a good metric.
19:47:10 <nostrademons> and virtual memory's an OS detail, sorear :-P
19:47:17 <bd_> There is an implementation of haskell that runs on Java, and another which runs on the bare processor; I'd argue that they're equally abstract.
19:47:18 <nostrademons> SQL is quite abstract too
19:47:29 <bd_> [prolog, anyone?]
19:47:42 <bd_> Unlambda's pretty abstract... :)
19:47:45 <goltrpoat> haha
19:47:48 * allbery_b would not call VM/CP all *that* advanced :>
19:47:52 <xpika> true to that
19:48:01 <nostrademons> if by "more abstract" you mean "more like pure math", then there's Epigram, Cayenne, JoCaml, etc..
19:48:10 <nostrademons> and of course lambda calculus, unlambda, etc.
19:48:28 <allbery_b> or in another direction, mathemtica, matlab...
19:48:33 <iulus> one could argue that 'math' is a language
19:48:38 <nostrademons> if by "more abstract" you mean "closer to the problem domain", there's make, SQL, Mathematica, HTML...
19:48:46 <xpika> not a computer programming language
19:48:55 <nostrademons> it's borderline
19:49:03 <nostrademons> lambda calculus is math and yet also a programming language
19:50:08 <sorear> by Math, I assume he means second-order classical logic with the "set-theory" and "numbers" libraries preloaded.
19:50:34 <iulus> really, I just meant the multitude of ways that mathematicians express ideas
19:50:45 <iulus> on paper
19:50:55 <goltrpoat> sorear:  you mean the whitehead and russell libraries preloaded :)
19:50:59 <iulus> which is not a programming language, true, so I rescind my comment.
19:51:48 <sorear> I've never heard of whitehead or russel theory.
19:52:03 <goltrpoat> sorear:  ??
19:52:08 <goltrpoat> principia mathematica?
19:52:37 <sorear> it's parsec not libdaan ... etc etc
19:52:41 <nostrademons> eh, sorear's right anyway.  we don't name libraries by their authors...
19:52:50 <goltrpoat> pfft.
19:52:56 <nostrademons> except for Darcs...
19:53:00 <goltrpoat> pmlib preloaded.  better? :)
19:53:23 <sorear> sure :)
19:53:30 <goltrpoat> hehe
19:55:57 <pbx> Wow, my IRC client sure is bad at parsing URLs embedded list literals... (/topic)
19:56:14 <pbx> s/list/in list/
19:58:29 <newsham> hrm..  ok, got my FFI stuff compiling, but it segfaults.
19:58:40 <newsham> one of the libs I'm linking in requires -lpthread.  could that cause problems?
19:58:46 <sjanssen> segfault--
19:59:15 <newsham> i can put code up if anyone is feeling adventurous in the help dept
20:00:32 <|shad0w|> gdb output ?
20:00:54 <iulus> can you test the foreign code seperate from the Haskell code? Does it segfault in those situations?
20:02:53 <bd_> newsham: GHC itself uses libpthread (even if you're not building for SMP), so that's not likely to be the problem in itself
20:03:16 <bd_> [though of course there could be other threading-related issues in themselves]
20:03:17 <newsham> Program received signal SIGSEGV, Segmentation fault.
20:03:17 <newsham> [Switching to Thread 16384 (LWP 8060)]
20:03:17 <newsham> 0x0807b418 in scheduleWaitThread ()
20:03:50 <newsham> NULL dereference,  0x807b418 <scheduleWaitThread+97>:      mov    %ebx,0x4(%eax)
20:03:56 <newsham> (gdb) p/x $eax
20:03:56 <newsham> $1 = 0x0
20:04:07 <bd_> is there an unsafe call that should be safe, perhaps?
20:04:15 <bd_> <-- isn't really a RTS internals hacker :/
20:04:30 <sieni> signals <3
20:04:32 <newsham> not sure what you mean re: unsafe.
20:04:56 <bd_> newsham: foreign calls can be either 'safe' or 'unsafe'; safe calls can reenter the RTS, unsafe ones must not
20:05:04 <bd_> if you don't specify they default as safe
20:05:05 <newsham> iulus: the foreign code when built stand-alone works fine.
20:05:21 <newsham> i started with a C program, then commented out some code and added back in the code from haskell.
20:05:29 <|shad0w|> what os
20:05:36 <newsham> linux.
20:05:45 <bd_> newsham: Is the C code thread-safe? does it use thread-local storage?
20:05:45 <|shad0w|> specifics bob
20:06:09 <newsham> bd: unknown.
20:06:15 <bd_> Are proper locks being maintained either in C or Haskell, if it's being accessed from multiple haskell threads?
20:06:24 <newsham> the lib internally uses threads so i imagine it is also thread safe.
20:06:25 <bd_> If it uses thread-local storage, try using forkOS?
20:06:35 <newsham> i'm not creating multiple haskell threads.
20:06:38 <bd_> or whatever that other primitive to ensure you're in a bound thread is
20:06:42 <bd_> oh, hm
20:06:48 <newsham> my code is really simple.
20:06:57 <newsham> if you want to look, its online:  http://www.thenewsh.com/%7Enewsham/x/silcffi/
20:06:58 <lambdabot> Title: Directory /~newsham/x/silcffi/
20:06:59 <bd_> scheduleWaitThread is in the RTS, isn't it...?
20:08:21 <bd_> newsham: missing include files; does it rely on an external library?
20:08:31 <newsham> yes, documented at top of .hs file
20:08:41 <bd_> oh XD
20:10:05 <sorear> newsham: are you writing a silc-plugin for lambdabot?
20:10:39 <newsham> sorear: i'm trying to hack something simple together.
20:10:53 <syntaxfree> lambdabot refuses to compile here.
20:10:57 <newsham> bd_: I updated the .c file with cmdline for building the C code standalone.
20:11:10 <syntaxfree> complains about lack of readline. but I have readline, and have updated to the latest one, and nothing.
20:11:12 <sorear> syntaxfree: you using 6.6?
20:11:17 <syntaxfree> Yes.
20:11:20 <newsham> sorear: I use silc often and having lambdabot around would be helpful.
20:11:21 <bd_> still building the library :)
20:11:30 <newsham> sorear: no, 6.6 doesnt run on my linux box.  segfaults :(
20:11:57 <sorear> newsham: look in the darcs-lambdabot, Plugin/IRC.hs -- that's the irc module, fairly small
20:12:15 <newsham> sorear: I have to get silclib working in haskell ffi first.
20:12:28 <complaisant> wx haskell to ghc 6.6 realesed?
20:17:33 * syntaxfree is running 6.6
20:18:00 <allbery_b> not sure it's been released, but the darcs version works with 6.6
20:18:48 <allbery_b> (darcs get http://darcs.haskell.org/wxhaskell)
20:18:50 <lambdabot> Title: Index of /wxhaskell
20:18:54 <bd_> last I tried building wxhaskell, it broke horribly on amd64
20:19:04 <bd_> [casting pointers to int considered harmful...
20:19:49 <TSC> I have got it to run on amd64, but some features misbehave badly
20:19:52 <sorear> yow
20:20:26 <newsham> too bad there's no standard typedef for an integer the same size as a ptr.
20:20:31 <newsham> uintptr
20:20:35 <sorear> intpt_t
20:20:45 <sorear> oh, beat me :)
20:20:55 <goltrpoat> where i'm from, casting pointers to int is considered a good way to get fired, not "harmful."
20:21:33 <bd_> newsham: void * not good enough for people? :/
20:21:43 <sorear> where I'm from, casting pointers to int is impossible by design :)
20:21:43 <newsham> bd_: sometimes not.
20:21:44 <complaisant> i'll try to work with ghc-6.4 then
20:21:52 <goltrpoat> sorear wins.
20:21:58 <sorear> unsafeCoerce#? what's that?
20:22:17 <bd_> newsham: hmm, link failure, undefined references to eg silc_client_send_channel_message using ghc -o cl clsilc.c cl.hs -L/usr/lib/silc-toolkit/ -I/usr/include/silc-toolkit/ -lsilc -lsilcclient -lpthread
20:22:45 <sorear> hm. do you maybe need -opL-foo?
20:22:46 <bd_> grepping /usr/lib/silc-toolkit/ for silc_client_send_channel_message comes up with nothing, checking the rest of /usr/lib
20:22:48 <sorear> hm. do you maybe need -optL-foo?
20:22:50 <bd_> hmm
20:23:05 <bd_> nope
20:23:13 <bd_> there's no error about libraries being missing
20:23:15 <bd_> just symbol errors
20:23:26 <bd_> using silc-toolkit 1.0.2 on gentoo
20:23:43 <SamB> well, "unsafeCoerce# :: String -> Int" won't do anything the least bit usefull... ever!
20:23:48 <newsham> undefined reference to "eg"?
20:23:52 <sorear> if grep fails completely, try find | xargs nm ...
20:24:01 <sorear> SamB: Int# !!!
20:24:22 <SamB> sorear: see.
20:24:29 <newsham> bd_: does the C code compile/link standalone properly?
20:24:29 <SamB> I told you it wouldn't be usefull.
20:24:46 <bd_> hmm, /usr/lib/silc-toolkit doesn't have the libs of interest (though they were apparently found in the default paths)
20:25:11 <newsham> should be /usr/local/silc/lib
20:25:27 <sorear> e.g. Lambdabot effectively has unsafeCoerce# through an array bug, but without unboxed types I've failed to exploit it.
20:26:28 <bd_> nm: /usr/lib/libsilc-1.0.so.2.4.1: no symbols
20:26:35 <bd_> newsham: I'm using the gentoo ebuilds
20:26:39 <sorear> nm --dy
20:26:55 <sorear> plain nm does debugging symbols for some silly reason
20:27:22 <bd_> hmm, both only seem to export internal C++ library symbols... might be a bug in the ebuild
20:27:24 <sorear> --dy [namic, but you don't have to type that] does dylanic-linker symbols
20:28:35 <newsham> looks like its dying after the first call to haskell code from C code, before the code returns to C.
20:28:58 <newsham> I even tried having it skip the first call to haskell (using the C code for it instead)..  same thing on the 2nd call
20:29:40 <sorear> newsham: do you use 'unsafe'?
20:29:44 <newsham> no.
20:30:23 <newsham> sorear: code's up if you wanna peek
20:30:55 <ClaudiusMaximus> newsham: where do you call hs_init()? to initialise the haskell runtime system...
20:31:47 <newsham> claud: i didnt.  :)
20:32:02 <ClaudiusMaximus> newsham: this is just about the minimum http://devel.goto10.org/filedetails.php?repname=maximus&path=%2Fhsext%2Fhsext%2Fbootstrap.c&rev=0&sc=0
20:32:05 <lambdabot> Title: DEVEL.GOTO10.ORG - maximus - Rev 159 - /hsext/hsext/bootstrap.c, http://tinyurl.com/wob98
20:32:13 <newsham> claud: thanks!
20:33:06 <newsham> my apologies.. i've done C from haskell before but never haskell from C..  I didnt even think that I might have to setup haskell's env
20:33:35 <newsham> where does HsExt_stub.h come from?
20:34:01 <ClaudiusMaximus> newsham: it's generated by ghc when you compile a file with foreign export
20:34:19 <newsham> ahh, I see.
20:34:49 <newsham> I dont see anything about _add_root or hsext_init in it
20:35:42 <ClaudiusMaximus> newsham: hsext_init is my foreign export
20:35:50 <newsham> ok.. thats what I was hoping
20:36:04 <newsham> yay! it works!
20:36:05 <newsham> thank you sir.
20:37:23 <ClaudiusMaximus> newsham: glad i could help :)   i had the same problem when i tried to write a pure-Haskell plugin for a C program, foreign export wasn't enough, i needed that bootstrap.c
20:43:59 <sorear> @users
20:43:59 <lambdabot> Maximum users seen in #haskell: 315, currently: 272 (86.3%), active: 29 (10.7%)
20:44:08 <sorear> @users fn:#haskell
20:44:09 <lambdabot> Maximum users seen in fn:#haskell: 304, currently: 0 (0.0%), active: 0 (NaN%)
20:44:10 <newsham> can I do   "newtype Foo = Ptr (); newType Bar = Ptr ()" ?
20:44:19 <sorear> no
20:44:19 <newsham> will the type system keep Foo and Bar separate?
20:44:43 <newsham> ok, so I need to keep the dummy types
20:44:48 <bd_> newsham: those have the same constructor, which isn't allowed :)
20:44:59 <bd_> and you need to unwrap/wrap them when going to anything which wants a Ptr
20:45:01 <sorear> newtype constructors must be distinct (you've declared one named Ptr)
20:45:15 <bd_> newtype Foo = FooP (Ptr ())
20:45:27 <bd_> newtype Foo = FooP { unFoo :: Ptr () }
20:45:45 <newsham> how do I cabalize this?
20:45:46 <sorear> also, you've defined a function named newType which pattern matches a Bar to ...
20:46:16 <bd_> newType :: (whatever Bar constructs) -> Foo ?
20:48:25 <newsham> are there options for telling cabal to build an FFI thing?
20:49:51 <sorear> yes
20:49:56 <sorear> @where vty
20:49:57 <lambdabot> I know nothing about vty.
20:50:48 <sorear> http://members.cox.net/stefanor/vty/vty.cabal
20:51:11 <SamB> @where+ vty http://members.cox.net/stefanor/vty/
20:51:12 <lambdabot> Done.
20:51:19 <sorear> 7 lines of C, to access TIOCGWINSZ ... very simple cabalized FFI lib.
20:51:58 <sorear> I just added options until cabal stopped complaining, I'm not sure all the ones in that file are needed...
20:53:11 <sorear> > case 2 of { 2 -> foo where foo = "foo" }
20:53:12 <lambdabot>  "foo"
20:58:51 <sorear> @bot
20:58:53 <sorear> @bot
20:58:57 <sorear> @bot
20:59:46 <glguy> nooooooo
21:00:02 <nornagon> ?bot
21:00:04 <nornagon> :(
21:00:09 <allbery_b> here we go again
21:00:40 <newsham> yay, cabalized
21:00:44 <sorear> my two latest fun additions:
21:01:19 <sorear> @help admin
21:01:20 <sorear-lambdabot> admin [+|-] nick. change a user's admin status.
21:01:28 <sorear> @activity 900
21:01:29 <sorear-lambdabot> 2*total 1*#haskell 1*nickserv
21:01:29 <nornagon> @admin + nornagon
21:01:30 <sorear-lambdabot> Not enough privileges
21:01:49 <sorear> @activity 900
21:01:49 <sorear-lambdabot> 4*total 1*nickserv 3*#haskell
21:01:53 <nornagon> ?help activity
21:01:54 <sorear-lambdabot> activity seconds. Find out where/how much the bot is being used
21:02:09 <nornagon> neat.
21:02:23 <nornagon> ?activity 10000000
21:02:23 <sorear-lambdabot> 6*total 1*nickserv 5*#haskell
21:02:28 <newsham> is there an easy way to let my program terminate when SIGINT is received?
21:02:38 <sorear> it's a sorted lines of #lines sent to each target
21:02:44 <sorear> someone, /msg lambdabot
21:03:15 <sorear> newsham: it should be automatic
21:03:37 <newsham> ahh, i know whats up.
21:03:41 <jcreigh> @activity 600
21:03:42 <sorear-lambdabot> 8*total 1*jcreigh 1*nickserv 6*#haskell
21:04:23 <sorear> @listservers
21:04:23 <sorear-lambdabot> freenode
21:07:50 <sorear> @bot
21:07:50 <sorear-lambdabot> :)
21:08:06 <manveru> :)
21:08:28 <sorear> maybe the reason I can't reproduce the netsplit problem is sorear-lambdabot doesn't have it? <wishful thinking>
21:08:29 <sorear> @bot
21:08:33 <sorear> @bot
21:08:51 <sorear> OTOH I can see stderr now.
21:08:52 <slava> you triggered the netsplit to test lambdabot?
21:08:53 <allbery_b> hm.  so it's not the parts, it's the joins?
21:08:57 <sorear> @bot
21:09:03 <slava> talk about testing changes in production... :)
21:09:39 <slava> was the netsplit caused by an ircd exiting due to a runtime type error?
21:10:35 <sorear> @bot
21:10:35 <sorear> dons must be right
21:10:35 <sorear> he said it was a deadlock
21:10:35 <sorear> I'm getting timeout errors
21:10:35 <sorear> but my CPU is at ~0
21:10:56 <sorear> LB is not dead!
21:11:14 <sorear> @bot
21:11:25 <sorear> the connection is wedged
21:11:35 <sorear> lambdabot> bot
21:11:36 <sorear> :)
21:11:39 <sorear> lambdabot>
21:11:50 <manveru> > "tooot"
21:11:52 <sorear> but lb has MULTIPLE SERVERS
21:11:59 <sorear> lb can still READ messages
21:12:04 <sorear> lb cannot WRITE
21:12:10 <sorear> this is a MASSIVE lead
21:12:15 <manveru> :P
21:12:59 <goltrpoat> ?yow
21:13:44 <goltrpoat> lambdabot can be ZIPPY the PINHEAD when she FEELS like it
21:13:52 <sorear> sorear-lambdabot and sorear-lambdabo2 are the *same process*
21:14:37 <manveru> hmm
21:14:45 <sorear> @bot
21:14:45 <sorear-lambdabo2> :)
21:14:50 <manveru> anybody can help me with something?
21:14:55 <sorear> sure
21:14:57 <manveru>     if channel == "haskot" then Nothing
21:14:58 <manveru>     else privmsg channel (unwords message)
21:15:11 <manveru> is there a 'unless' ?
21:15:24 <sorear> ?
21:15:40 <manveru> privmsg (channel (unwords message)) unless channel == "haskot"
21:15:40 <newsham> ?type unless
21:15:43 <sorear-lambdabo2> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:15:43 <allbery_b> if not (...) then ...
21:15:45 <newsham> ?type when
21:15:48 <sorear-lambdabo2> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
21:16:03 <slava> ?def unless
21:16:03 <sorear-lambdabo2> Maybe you meant: bf let
21:16:11 <slava> ?code unless
21:16:11 <sorear-lambdabo2> Maybe you meant: more todo vote
21:16:15 <slava> sorry
21:16:15 <manveru> :P
21:16:17 <TSC> @src unless
21:16:18 <sorear-lambdabo2> unless p s = if p then return () else s
21:16:28 <manveru> :|
21:16:32 <newsham> when/unless take a boolean and an action returning (), and runs that action when/unless the boolean is true.
21:16:38 <manveru> aight
21:17:00 <sorear> @activity 6000
21:17:00 <sorear-lambdabo2> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:17:09 <manveru> that seems to work :)
21:17:20 <sorear> but ... I never called any bytesstring stuff :)
21:17:23 <sorear> @activity 6000
21:17:24 <sorear-lambdabo2> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:17:54 <sorear> this is a sign
21:18:00 <SamB_XP> sorear: perhaps the State is empty somehow?
21:18:05 <sorear> laziness sucks
21:18:56 <SamB_XP> obviously, lambdabot should be built for profiling *AND* GHC should allow lambdabot to find the cost center stack of raised exceptions!
21:19:20 <sorear> note that there is not a single call to last in activity.
21:19:34 <SamB_XP> you just said that
21:19:37 <sorear> thus, something in the state must have become _|_
21:19:56 * allbery_b thought someone was getting that with an hs-plugins-less lbot the other day
21:19:57 <SamB_XP> you said that you had not touched ByteStrings
21:20:10 <slava> sorear: are there interactive inspector tools and such, like one can find for lisp or smalltalk?
21:20:16 <sorear> allbery_b: I was, with @eval
21:20:29 <SamB_XP> @eval id
21:20:32 <sorear> slava: yes.  ghci :sprint
21:20:35 <glguy> slava of reddit?
21:20:35 <sorear> @run id
21:20:36 <sorear-lambdabo2> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:20:48 <sorear> slava pestov, creator of factor
21:20:57 <SamB_XP> @seen me
21:20:58 <sorear-lambdabo2> I haven't seen me.
21:21:01 <SamB_XP> @seen you
21:21:01 <sorear> (known to me only through syntaxfree's comments)
21:21:02 <sorear-lambdabo2> I haven't seen you.
21:21:16 <SamB_XP> @quote who
21:21:17 <sorear-lambdabo2> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
21:21:29 <nornagon> @quote Oleg
21:21:30 <sorear-lambdabo2> Oleg says: The implementation of RSA on type level is left for future work
21:21:37 <SamB_XP> hahaha
21:21:39 <nornagon> @quote Oleg
21:21:40 <sorear-lambdabo2> Oleg says: The implementation of RSA on type level is left for future work
21:21:43 <nornagon> :(
21:21:49 <SamB_XP> what?
21:21:54 <nornagon> same one twice
21:21:54 <manveru> @quote nornagon
21:21:54 <sorear-lambdabo2> No quotes match. It can only be attributed to human error.
21:21:56 <SamB_XP> you wanted encrypted type signatures?
21:22:00 <newsham> sorear: is the Plugin/IRC.hs a new thing? how do the /IRC.hs and IRCBase.hs fit in?
21:22:10 <nornagon> @quote
21:22:11 <sorear-lambdabo2> newbcoder says: newbcoder is the best of them all
21:22:22 <SamB_XP> @quote ghc
21:22:22 <sorear-lambdabo2> ghc says: the eta-reduction property does not hold
21:22:27 <SamB_XP> !
21:22:40 <SamB_XP> sounds rather dire
21:22:48 <sorear> newsham: IRCBase contains types and whatnot, because plugins can't depend on other plugins.
21:22:49 <nornagon> heh
21:23:08 <SamB_XP> sorear: which is lameish
21:23:12 <sorear> IRC and Plugin.IRC are redundant, and a patch in the queue removes IRC
21:23:26 <SamB_XP> can plugins at least communicate with eachother?
21:23:30 <newsham> gotcha.
21:23:33 <bd_> SamB_XP: If we can't restore the eta-reduction property to its proper place within 48 hours ... *zoom in* graph reduction as we know it... will come to the bottom.
21:23:35 <SamB_XP> now?
21:23:42 <sorear> only through the core, using stantard interfaces.
21:23:48 <SamB_XP> bd_: what is this, Back to the Future?
21:23:57 <sorear> @listservers
21:23:58 <sorear-lambdabo2> freenode freenode2 offlinerc
21:24:06 <sorear> @listchans
21:24:06 <sorear-lambdabo2> #haskell freenode2:#haskell
21:24:10 <sorear> @seen #haskell
21:24:11 <sorear-lambdabo2> In #haskell I can see allbery_b, bd_, glguy, goltrpoat, manveru, newsham, nornagon, samb_xp, slava, sorear and tsc.
21:24:13 <bd_> I was thinking something more like indiana jones meets some generic sci-fi thing but that works too.
21:24:15 <sorear> @seen freenode:#haskell
21:24:15 <sorear-lambdabo2> In freenode:#haskell I can see freenode:allbery_b, freenode:bd_, freenode:glguy, freenode:goltrpoat, freenode:jcreigh, freenode:manveru, freenode:newsham, freenode:nornagon, freenode:samb_xp,
21:24:15 <sorear-lambdabo2> freenode:slava, freenode:sorear, freenode:sorear-lambdabo2 and freenode:tsc.
21:24:31 <sorear> @seen fn:#haskell
21:24:31 <sorear-lambdabo2> In fn:#haskell I can see nobody.
21:25:10 <allbery_b> so, now that you've pinged the channel.. :)
21:25:22 <SamB_XP> @ping #haskell
21:25:25 <sorear-lambdabo2> lexical error at character 'h'
21:25:30 <SamB_XP> @ping you
21:25:31 <sorear> I keep forgetting people have that feature :)
21:25:32 <sorear-lambdabo2> Not in scope: type variable `you'
21:25:42 <allbery_b> (well, not as bad as the other day when it did *everybody*)
21:25:53 <syntaxfree> > -- comment
21:25:54 <sorear-lambdabo2>  Parse error
21:26:02 <SamB_XP> allbery_b: everybody?
21:26:02 <allbery_b> hm, need a "how do you parse this command?" feature
21:26:03 <syntaxfree> > {- comment -}
21:26:03 <sorear-lambdabo2>  Parse error
21:26:05 <sorear> @listmodules
21:26:05 <sorear-lambdabo2> activity babel base bf check compose dice dict djinn dummy elite eval fact figlet free fresh ft haddock help hoogle instances irc karma localtime log more offlinerc pl pointful poll pretty quote
21:26:05 <sorear-lambdabo2> search seen slap small source spell state system tell todo topic type undo unlambda url version vixen where
21:26:13 <allbery_b> all 200+ IIRC
21:26:14 <syntaxfree> this channel does not implement literate haskell in its full form!
21:26:17 <SamB_XP> syntaxfree: you need an expression
21:26:23 <SamB_XP> >
21:26:28 <syntaxfree> > 2 {- oh yeah? -}
21:26:43 <SamB_XP> >
21:26:48 <SamB_XP> @botbot
21:26:49 <sorear-lambdabo2> Unknown command, try @list
21:26:54 <SamB_XP> >
21:26:58 <nornagon> @botd
21:26:59 <sorear-lambdabo2> Missing argument. Check @help <vote-cmd> for info.
21:27:07 <SamB_XP> >      please, talk to me!
21:27:08 <sorear-lambdabo2>  Parse error
21:27:18 <SamB_XP> >
21:27:33 <sorear> @activity 0
21:27:33 <sorear-lambdabo2> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:27:34 <syntaxfree> @yow
21:27:34 <sorear-lambdabo2> Couldn't find fortune file
21:27:36 <sorear> @activity 1
21:27:36 <sorear-lambdabo2> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:28:16 <nornagon> @activity 200
21:28:16 <sorear-lambdabo2> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:28:38 <sorear> @msg freenode:#haskell foo
21:28:54 <sorear-lambdabo2> Plugin `system' failed with: IRCRaised thread killed
21:29:09 <nornagon> @bot
21:29:10 <sorear-lambdabo2> :)
21:29:32 <sorear> sorear-lambdabot: @quit
21:32:09 <sorear> I have absolutely no idea what is going on.
21:32:19 <sorear> @echo
21:32:19 <sorear-lambdabo2> echo; msg:IrcMessage {msgServer = "freenode2", msgLBName = "sorear-lambdabo2", msgPrefix = "sorear!n=stefan@ip68-7-248-101.sd.sd.cox.net", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo"]}
21:32:19 <sorear-lambdabo2> rest:""
21:32:40 <sorear> sorear-lambdabot: @echo
21:37:33 <sorear> sorear-lambdabot: @list-all
21:39:16 <bos> @hoogle inRange
21:39:17 <sorear-lambdabo2> Ix.inRange :: Ix a => (a, a) -> a -> Bool
21:39:55 <syntaxfree> what is Ix again?
21:40:40 <allbery_b> ?doc Ix
21:40:40 <sorear-lambdabo2> Ix not available
21:40:41 <glguy> indexable type
21:40:45 <glguy> for array indexing
21:41:38 <syntaxfree> type or type class?
21:41:43 <syntaxfree> @info Ix
21:41:44 <sorear-lambdabo2> Ix
21:41:46 <glguy> its' a clas
21:41:52 <syntaxfree> @instances Ix
21:41:53 <sorear-lambdabo2> Couldn't find class `Ix'. Try @instances-importing
21:42:09 <syntaxfree> @instances-importing Data.Array Ix
21:42:10 <sorear-lambdabo2> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
21:42:17 <sorear> not only does @activity not use Data.ByteString.last, *no module* does ... at least not under that name ...
21:42:26 <glguy> > index (5,8) 7
21:42:38 <syntaxfree> why isn't (a1,a2,a3,a4,a5) an instance of Ix?
21:42:40 <glguy> 2
21:42:51 <glguy> syntaxfree: it is
21:42:57 <glguy> instance (Ix a1, Ix a2, Ix a3, Ix a4, Ix a5) =>
21:42:57 <glguy>          Ix (a1, a2, a3, a4, a5)
21:42:57 <glguy>   -- Defined in GHC.Arr
21:43:26 <syntaxfree> I don't understand how tuples index an array yet.
21:43:59 <glguy> it's any time that implements the typeclass, which includes a method for turning a element in the range to a zero indexed Int
21:44:07 <glguy> any type
21:44:16 <glguy> class (Ord a) => Ix a where
21:44:16 <glguy>   range :: (a, a) -> [a]
21:44:16 <glguy>   index :: (a, a) -> a -> Int
21:44:16 <glguy>   GHC.Arr.unsafeIndex :: (a, a) -> a -> Int
21:44:16 <glguy>   inRange :: (a, a) -> a -> Bool
21:44:18 <glguy>   rangeSize :: (a, a) -> Int
21:44:20 <glguy>   GHC.Arr.unsafeRangeSize :: (a, a) -> Int
21:44:23 <glguy>         -- Defined in GHC.Arr
21:44:28 <sorear> @src Ix
21:44:28 <sorear-lambdabo2> Source not found. You type like i drive.
21:44:31 <mbishop> flood!
21:44:38 <glguy> quiet you
21:44:43 <syntaxfree> what are arrays better than lists at?
21:44:45 <mbishop> D:
21:44:49 <syntaxfree> (other that enforcing fixed size, of course)
21:44:55 <allbery_b> performance
21:44:56 <glguy> syntaxfree: they are better at random access reading
21:44:59 <slava> O(1) random access, memory locality
21:45:11 <slava> in-place operations
21:45:11 <glguy> syntaxfree: linear time updates, constant time lookups
21:45:34 <syntaxfree> and lists are better at consing and cdr'ing?
21:45:45 <glguy> and changing length
21:45:52 <sorear> and laziness
21:45:55 <syntaxfree> lists should be called "stacks".
21:46:00 <sorear> arrays are always strict-tail
21:46:50 <syntaxfree> I've been seeing lazy lists in other languages. But are they really lazy lists or syntactic sugar over some limited form of coroutines?
21:47:20 <slava> maybe you can blog about how crappy they are
21:47:48 <glguy> does it really matter how they ar eimplemented if they have the same programmer facing results?
21:48:16 <syntaxfree> well, if lazily-evaluated lists are possible, then general laziness is one step ahead.
21:48:28 <sjanssen> what matters is whether a normal programmer can implement his own data structure
21:48:39 <syntaxfree> what sjanssen said.
21:48:58 <sjanssen> s/data/lazy data/
21:48:59 <sorear> syntaxfree: sicp.
21:49:24 <syntaxfree> I remember something that implemented lazy evaluation in Scheme. Is SICP it?
21:49:28 <sorear> they devoted an entire section to lazy lists.
21:49:41 <SamB_XP> even or odd?
21:50:01 <syntaxfree> oh. they implemented lazy lists.
21:50:31 <syntaxfree> I imagine a simple way of implementing lazy lists with continuations, but that's probably the most abstruse, stupid way of doing it.
21:50:58 <slava> you only need closures
21:51:01 <glguy> doesn't sound too hard... tail is a function that returns a new list containing the next element
21:51:11 <glguy> head is the functoin the returns the lists top element
21:51:12 <slava> exactly
21:51:23 <glguy> like IEnumerator in C#
21:51:25 <syntaxfree> glguy: that's what I thought.
21:51:31 <glguy> or any other language that does the same thing
21:51:50 <glguy> .Current is head, .MoveNext() is tail
21:51:57 <goltrpoat> syntaxfree:  you can relatively easily implement lazy lists in ocaml..  it's not exactly pleasant to use though
21:52:16 <goltrpoat> ive seen lazy list implementations in c++, etc.  not exactly pleasant in those cases either.
21:52:16 <syntaxfree> anyway, what sjanssen said some minutes ago.
21:52:25 <syntaxfree> can you use lazy lists to implement, say, lazy zippers?
21:52:37 <slava> you don't need to
21:52:38 <syntaxfree> (zippers = the things sigfpe uses in his CA comonad)
21:52:42 <slava> lazy zipping is trivial with closures
21:52:46 <syntaxfree> s/comonad/comonad article.
21:52:59 <syntaxfree> oh, no. the zipper /= zipping.
21:53:02 <sjanssen> I think a lazy list is sufficient to build any lazy data structure
21:53:22 <sjanssen> just box any lazy item in a singleton lazy list
21:53:27 <goltrpoat> once you have enough hackery to be able to manipulate thunks, zippers should be trivial, no?
21:53:48 <lispy> hi
21:53:52 <sorear> ih
21:54:00 <lispy> what are people working on these days?
21:54:05 <lispy> it's been a while since i was here
21:54:42 <notsmack> ?syad eseht no gnikrow elpoep era tahw
21:54:43 <sorear-lambdabo2> Maybe you meant: read slap
21:54:44 <syntaxfree> goltrpoat: yes, but if all you have is black-box lazy list, you'r√© 'not really manipulating thunks.
21:55:03 <syntaxfree> you're just using it as easy to use coroutines.
21:55:14 <syntaxfree> the "generators" in Python at least look like that to me.
21:55:16 <slava> coroutines are nothing like lazy lists
21:55:25 <slava> a generator is not a lazy list
21:55:31 <slava> because reading from the generator is a side-effecting operation
21:55:43 <slava> whereas one can iterate over a lazy list multiple times
21:55:59 <syntaxfree> maybe I'm having trouble visualizing a lazy list in a nonlazy environment, yes.
21:56:02 <slava> also C# IEnumerable is not a lazy list either for the same reason
21:56:21 <slava> syntaxfree: just think of a cons cell where the cdr is a lambda which produces another cons cell
21:56:27 <slava> forgetting memoization which is just an optimization
21:56:30 <glguy> slava: fine, but the differnce is nothing more than changing MoveNext to return a new iterator
21:56:39 <glguy> slava: and eschewing sideeffects on that functino
21:56:42 <syntaxfree> well, yes. that was my first intuition.
21:56:53 <slava> syntaxfree: that's all there is to lazy lists
21:56:57 <slava> plus memoization
21:57:35 <lispy> i love that the enum type in C# does not implement IEnumerable
21:58:25 <slava> in java, no two of String, StringBuffer, List, int[], Object[] implement a common sequence interface
21:59:05 <sorear> joy
21:59:14 <slava> joy rocks.
21:59:22 <syntaxfree> anyway.
21:59:24 <syntaxfree> gotta sleep now.
22:12:47 <Cale> http://programming.reddit.com/info/xu50/comments/cxumc
22:12:47 <sorear-lambdabo2> Title: "Why no one uses functional languages" (reddit.com)
22:13:01 <glguy> i just finished that one
22:13:47 <slava> i hope it didn't seem trollish. that WAS that title of the paper.
22:14:05 <glguy> nah, functional programming is out htis week
22:14:10 <Cale> slava: nah, the only trollishness about it was that it's a paper from 1998 ;)
22:14:12 <glguy> so it fit
22:14:46 <Cale> reddit is getting more and more crappy. This is actually one thing I didn't mod down.
22:14:56 <slava> submit stuff.
22:16:22 <Cale> Of the last 100 new articles, I've not modded down 11 of them, and modded up 6.
22:16:35 <glguy> reddit, old news, even qwe1234 has moved on ;)
22:16:50 <slava> hah
22:17:02 <glguy> i just checked, it's been 19 days
22:17:12 <Cale> 19 days since what?
22:17:14 <glguy> he posted
22:17:31 <brad_> does anyone else find System.Console.GetOpt tedious?
22:17:36 <glguy> grauenwolf still seeks to amaze us with his visual basic webapps though
22:17:56 <Cale> watch, he'll come back in a few weeks apologising profusely, and having learned a bit of Haskell
22:18:07 <glguy> brad_: it can be overkill if you only have a few options
22:18:26 <slava> can one have a heterogeneous list where all elements are instances of the same type class?
22:18:28 <brad_> yes, it seems like so much work just to gather command line args
22:18:33 <glguy> slava: yes
22:18:37 <Cale> slava: with existential types, yes
22:18:46 <slava> what does such a type declaration look like?
22:18:51 <glguy> data E = forall t . Show t => E t
22:19:06 <brad_> is lambdabot working again?
22:19:07 <mbishop> The trolls on reddit are classic
22:19:08 <slava> it seems to be that in Foo a => [a b], the 'b' is fixed right?
22:19:22 <Cale> and then  [E]
22:19:33 <slava> ok
22:19:50 <Cale> We don't have first-class existentials yet.
22:20:01 <slava> i read somewhere about existential types being undecidable, what does this mean? Type inference is equivalent to the halting problem?
22:20:03 <glguy> map (\x -> case x of E t -> show t)[E 1, E True]
22:20:03 <Cale> (and whether it would be a good idea in general is questionable)
22:20:24 <slava> Cale: the example i have in mind is a list of gui widgets, which are all paintable, receive events, etc.
22:20:30 <Cale> yeah
22:20:43 <slava> i'm just trying to understand how the stuff i typically do can fit in a type system like haskell's.
22:21:16 <Cale> You get most of the OO abstraction via existentials. In fact, if I was going to define OO programming, I would say that on some level it's the systematic use of existential types.
22:21:43 <Cale> However, it's never actually *necessary* to use existentials to get that abstraction.
22:21:47 <Cale> They just make it easier.
22:21:57 <Cale> The other option is explicitly passing around dictionaries.
22:22:01 <slava> well if the set of gui widgets is fixed, one can just use a sum type, right?
22:22:04 <slava> or that.
22:22:06 <Cale> yes
22:22:09 <Cale> that too
22:22:23 <SamB_XP> fixed????
22:22:33 <Cale> SamB_XP: constant
22:22:51 <sjanssen> incredulous reaction????
22:22:52 <Cale> Or were you questioning that on another level? :)
22:22:52 <glguy> data GuiElement = Button | Textbox | Picture
22:22:59 <SamB_XP> a different level
22:23:03 <glguy> heh :)
22:23:05 <SamB_XP> like, why would you be okay with that?
22:23:21 <SamB_XP> also, what about having more than one thing?
22:23:27 <slava> its not unimaginable that a gui toolkit could be designed around a small set of orthogonal abstractions
22:23:34 <brad_> is there a "point free" way to do this: map (\x -> "--" ++ x) (lines foo)
22:23:36 <slava> from which any widget you can think of can be constructed
22:23:43 <Cale> Maybe you have a higher-order set of GUI widgets such that instantiating them will give you all the variety you'll ever need :)
22:23:45 <allbery_b> @bot
22:23:45 <sorear-lambdabo2> :)
22:23:49 <brad_> i am writing a script to prepend a license file to a code file
22:23:51 <slava> Cale: jinx
22:23:55 <SamB_XP> wouldn't you at *least* need a GADT?
22:23:59 <glguy> brad_: map ("--" ++)
22:24:05 <brad_> thanks glguy!!
22:24:15 <SamB_XP> slava: don't you need a way of constructing them?
22:24:30 <Cale> SamB_XP: What would the type parameters be?
22:24:37 <slava> SamB_XP: i haven't thought this through, and i barely understand GADTs.
22:24:53 <SamB_XP> well, they'd have to do with what kind of input and output the widgets have
22:24:57 <glguy> instead of building lists, you could build composite structures: addButton >>> addTextbox >>> whatever
22:25:05 <sorear> good night...
22:25:05 <glguy> doesn't need to be a [GuiWidget]
22:25:06 <slava> i understand some specific concepts but don't really see how GADTs fit in with type inference and implementation of the language
22:25:14 <Cale> Okay, one example, a Widget type with just one data constructor, which takes values that describe how to draw the widget and handle events.
22:25:16 <slava> s/specific concepts/specific examples of GADT usage/
22:25:36 <Cale> Pretty much any widget could be reflected like that.
22:25:45 <ClaudiusMaximus> slava: in my project, i have a Data.Map of constructors (which all have the same type), the constructors return a Maybe Instance, where Instance is a record of functions
22:25:55 <slava> ok
22:25:59 <Cale> You still might not want to do it that way, but it's an option :)
22:26:01 <allbery_b> sure, but then you have runtime errors if you use the wrong widget
22:26:10 <slava> its like message passing OOP.
22:26:29 <glguy> ?bot
22:26:36 <Cale> allbery_b: right
22:26:51 <sorear> sorry, I need to sleep...
22:26:51 <glguy> *what is this, amateur hour?*
22:27:03 <Cale> and it's tough to debug, because you can't get at the widget tree explicitly
22:27:03 <slava> was that directed at me?
22:27:15 <allbery_b> lambdabot is stuck in netsplit-lockup again
22:27:16 <glguy> it's a Anchorman quote directed at not having a lambdabot :)
22:27:20 <slava> ah :)
22:27:46 <allbery_b> but sorear got to watch one happen to his bot too, and has more clues now as to what is broke
22:27:47 <ClaudiusMaximus> slava: message passing OOP is exactly the paradigm of the app my project is plugging in to, so i've got no problem :)
22:27:49 <allbery_b> n
22:28:03 <Cale> I wish reddit had options for automatic moderation
22:28:15 <sorear> @irc-connect freenode2 chat.freenode.net 6667 lambdabot-con2 Lambdabot
22:28:24 <sorear> @join freenode2:#haskell
22:28:24 <Cale> I don't even want to see anything containing the words "Agile" or "ASP.NET"
22:28:32 <Cale> automatic downmod
22:29:03 <sorear> @msg freenode2:#haskell foo
22:29:10 <slava> Cale: so was that nullity guy a one hit wonder or is he still working on his from scratch bootstrap of 20th century ring theory?
22:29:15 <allbery_b> your bots already quit, no?
22:29:25 <allbery_b> sorry, instances
22:29:27 <Cale> slava: I suspect he's still working on it.
22:29:34 <allbery_b> <-- sorear-lambdabot has quit (Remote closed the connection)
22:29:34 <allbery_b> <-- sorear-lambdabo2 has quit (Remote closed the connection)
22:29:45 <glguy> Prelude Data.Dynamic> map fromDynamic [toDyn 1, toDyn True, toDyn "string"] :: [Maybe Bool]
22:29:48 <glguy> [Nothing,Just True,Nothing]
22:29:52 <ytinasni> wasn't that nullity thing just a huge joke?
22:29:59 <slava> i liked his little diagram of the extended real line
22:30:03 <Cale> slava: It's not a *terrible* system, and he seems relatively aware of what's out there. He's concerned with describing the semantics of a strange type of optical computer.
22:30:29 <slava> where this computer must not produce runtime exceptions, or something?
22:30:31 <Cale> Still, it's not something which should have received any attention at all from BBC.
22:30:36 <sorear> allbery: When the split hit, my bot became mute but not deaf.  I was able to tell it to open another conection, that's where sorear-lambdabo2 came from.  I thought I could maybe do the same to dons' bot.
22:30:40 <slava> or be taught to schoolchildren
22:30:42 <Cale> Well, it would have to represent them specially.
22:30:56 <Cale> Well, yeah, I e-mailed him and apparently that was just a one-time thing.
22:31:02 <Cale> (probably just for BBC)
22:31:39 <ClaudiusMaximus> BBC as in British Broadcasting Corporation?
22:31:41 <allbery_b> oh
22:31:48 <allbery_b> thought you did that from yur local console though
22:31:59 <Cale> ClaudiusMaximus: yeah
22:32:01 <allbery_b> and your first instance wasn't actually responding
22:32:50 <slava> hi ramkrsna
22:32:54 <slava> ramza3*
22:33:36 <bos> lambdabot: hey!
22:33:41 <ramkrsna> slava, hi
22:33:48 <glguy> what's this business about fortress from Sun and Guy Steele?
22:33:50 <slava> sorry wrong greeting there
22:33:55 <glguy> I've seen two things about it today
22:34:05 <Cale> I actually felt pretty sorry for the guy, since most of the criticism was really stupid.
22:34:13 <bos> @spank lambdabot
22:34:22 <bos> err, hmm.
22:34:30 <bd_> ?botsnack
22:34:40 <allbery_b> bot's in netsplit lalaland
22:34:42 <bd_> ohdear.
22:34:53 <bos> how annoying. @pl must wait.
22:35:03 <Cale> bos: I found that Data.ByteString story pretty funny :)
22:35:44 <bos> Cale: yeah, it was really weird.
22:35:48 <Cale> @pl \f g x -> f x (g x)
22:35:49 <mbot> ap
22:36:05 <bos> @pl \x->zipWith (,) x (tail x)
22:36:05 <mbot> ap zip tail
22:36:19 <bos> @type ap zip tail
22:36:21 <mbot> forall a. [a] -> [(a, a)]
22:36:26 <bos> ooh, yummy.
22:36:34 <glguy> zip = zipWith (,)
22:36:42 <bos> sure.
22:37:02 <bos> but i haven't used ap enough times for it to stick in my head.
22:37:05 <brad_> thanks again for all the adivce and help, take care!
22:37:25 <Cale> > let fibs = 0 : 1 : ap (zipWith (+)) tail fibs in fibs
22:37:27 <mbot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:39:14 <ytinasni> > let fibs a b = a : fibs b (a+b)
22:39:14 <mbot>  Parse error
22:39:29 <ytinasni> gah, don't paste the newline too :(
22:39:41 <glguy> ytinasni: in fibs
22:39:42 <ytinasni> let fibs a b = a : fibs b (a+b) in (take 10 fibs)
22:39:48 <ytinasni> > let fibs a b = a : fibs b (a+b) in (take 10 fibs)
22:39:49 <mbot>      Expecting a function type, but found `[a]'
22:39:49 <mbot>       Expected type: [a]
22:39:49 <mbot>     ...
22:40:02 <glguy> fibs 1 1
22:40:07 <ytinasni> > let fibs a b = a : fibs b (a+b) in (take 10 (fibs 1 1))
22:40:09 <mbot>  [1,1,2,3,5,8,13,21,34,55]
22:40:33 <glguy> which works well if you have exponential amounts of time to wait in terms of the length of the list
22:40:37 <bos> @type ap
22:40:39 <mbot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
22:41:03 <Cale> bos: it might help to know that m = (e ->) in this case
22:41:05 <ytinasni> glguy: huh?
22:41:09 <glguy> ?type flip liftM2 id
22:41:11 <mbot> forall a2 r a. (a -> a2 -> r) -> (a -> a2) -> a -> r
22:41:24 <Cale> or, to put it in a way that a Haskell compiler will understand, m = (->) e
22:41:41 <glguy> ytinasni: I'm just being wrong
22:42:07 <ytinasni> ah, i was suddenly wondering whether my code was noob :)
22:42:18 <bos> Cale: i haven't come across (->) foo to grok it much yet.
22:42:30 <Cale> Well, let's substitute...
22:42:36 <Cale> m (a -> b) -> m a -> m b
22:42:42 <glguy> ?type flip liftM2 id
22:42:43 <mbot> forall a2 r a. (a -> a2 -> r) -> (a -> a2) -> a -> r
22:42:49 <glguy> oops
22:42:54 <Cale> = (->) e (a -> b) -> (->) e a -> (->) e b
22:43:15 <Cale> = (e -> (a -> b)) -> (e -> a) -> (e -> b)
22:43:23 <bos> ok.
22:43:24 <Cale> = (e -> a -> b) -> (e -> a) -> e -> b
22:43:41 <Cale> @djinn (e -> a -> b) -> (e -> a) -> e -> b
22:43:41 <mbot> Unknown command, try @list
22:43:45 <Cale> oh, right, hehe :)
22:44:08 <ytinasni> what does (should :) @djinn do?
22:44:16 <Cale> write code for a function of that type
22:44:47 <ClaudiusMaximus> > let phi = (1 + sqrt 5) / 2 ; fib n = floor (phi^^n / sqrt 5 + 1 / 2) in map fib [0..10]
22:44:48 <mbot>  [0,1,1,2,3,5,8,13,21,34,55]
22:44:50 <Cale> Technically, djinn is a theorem prover. The theorems it proves are Haskell types, and the proofs are programs.
22:45:22 <Cale> However, when I compiled lambdabot, I left it out.
22:45:58 <bos> @type ap zip tail
22:45:59 <mbot> forall a. [a] -> [(a, a)]
22:46:01 <Cale> What it would print is something like
22:46:09 <Cale> f a b c = a c (b c)
22:46:20 <bos> > ap zip tail [1,2,3]
22:46:21 <mbot>  [(1,2),(2,3)]
22:46:45 <bos> gnaargh. how come that typechecks with mbot, but a normal haskell interpreter complains?
22:46:49 <glguy> > liftM2 (/) sum genericLength [1,3,7,10] -- common example
22:46:50 <mbot>  5.25
22:47:02 <glguy> bos: :m + Control.Monad.Instances
22:47:07 <Cale> bos: import Control.Monad.Reader if using 6.4.x, and Control.Monad.Instances in 6.6
22:47:36 <bos> so i have ap, but not an instance declaration for the list monad?
22:47:50 <glguy> ((->)e) monad
22:48:03 <Cale> Yeah, unfortunately, that instance isn't in the Prelude
22:48:07 <bos> ah.
22:48:17 <bos> i must learn me that (->) e monad.
22:48:20 <Cale> also, maybe ap isn't available if Control.Monad isn't loaded
22:48:46 <Cale> essentially, the idea is that the "computations" in that monad are just functions which are waiting for one more parameter
22:48:52 <glguy> > ap [succ,pred] [3,6]
22:48:52 <mbot>  [4,7,2,5]
22:48:57 <Cale> "running" the monad is just applying the function
22:49:22 <Cale> > (do {x <- (10*); y <- (1+); return (x+y)) 5
22:49:22 <mbot>  Parse error
22:49:35 <Cale> > (do x <- (10*); y <- (1+); return (x+y)) 5
22:49:35 <bos> Cale: ok, thanks!
22:49:36 <mbot>  56
22:49:40 <Cale> like that
22:49:54 <Cale> It's handy to learn what the various monad functions do.
22:50:00 <Cale> join is particularly interesting
22:50:05 <bos> oh, sure.
22:50:12 <bos> i've only just got my feet wet, though.
22:50:23 <Cale> join x = do {y <- x; v <- y; return v}
22:50:37 <Cale> or, to simplify
22:50:44 <Cale> join x = do {y <- x; y}
22:51:01 <goltrpoat> i'm still trying to come up with a name for join . mapM
22:51:05 <slava> Cale: are monads used in algebraic topology?
22:51:10 <bos> @pl \x -> map (1`shiftL`) $ ap zip tail [0..x]
22:51:10 <mbot> map (1 `shiftL`) . ap zip tail . enumFromTo 0
22:51:16 <Cale> So what will happen is that x will get the parameter supplied, then its *result* will get that parameter again.
22:51:28 <bos> Cale: right.
22:51:32 <Cale> slava: Not in the part that I've learned, though I'm sure there are a few
22:51:41 <Cale> So, join f x = f x x
22:51:58 <Cale> slava: Functors are commonplace
22:52:09 <slava> yeah, i'm aware of that :)
22:52:25 <slava> i study lie group cohomology
22:53:22 <bos> @pl \x -> [(1`shiftL`i,1`shiftL`i*2) | i <- ap zip tail [0..x]]
22:53:22 <mbot> return . (((1 `shiftL` i, 1 `shiftL` i * 2) | i) <-) . ap zip tail . enumFromTo 0
22:54:07 <bos> Cale: thank you for the explanation.
22:54:10 <Cale> Metric completion is a monad, in a somewhat trivial way, seeing that T^2 = T.
22:54:12 <timthelion> so, let me get this strait. a monad is something that can be accessed with different results? so an IO monad is the same whatever it's evaluated value is making the function that returns it pure. but upon multiple evaluations of that monad you may get different results?
22:54:29 <slava> Cale: never thought of it that way
22:54:36 <slava> timthelion: no
22:54:49 <timthelion> slava: then what is a monad?
22:54:54 <Cale> timthelion: let me point you at my tutorial :)
22:54:58 <timthelion> ok
22:55:03 <slava> a type is a monad if it implement certain operations...
22:55:04 <glguy> bos: ?pl doesn't work on list comprehensions
22:55:12 <slava> you can think of them as providing a way to sequence operations
22:55:14 <Cale> http://haskell.org/haskellwiki/Monads_as_Containers
22:55:16 <mbot> Title: Monads as containers - HaskellWiki
22:55:38 <Cale> this takes a different perspective to the usual computation route, that I think is easier to grasp at first
22:55:53 <slava> timthelion: when you do IO in haskell, the list of IO operations is built up and your program actually evaluates to this list of operations, and /then/ they are performed
22:55:58 * timthelion is trying to learn haskell with the write yourself to scheme in 48 hours tutorial
22:56:34 * timthelion is stuck on the concept of >>
22:56:41 <timthelion> and >>=
22:56:51 <Cale> If you're more concerned with the IO monad
22:57:04 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
22:57:04 <mbot> Title: Introduction to IO - HaskellWiki
22:57:06 <glguy> a >> b   , given an a and a b, return a new value that when run, runs a, and the runs b
22:57:40 <Cale> To restate what glguy just said, if x and y are IO actions, then (x >> y) is the action that performs x, dropping the result, then performs y and returns its result
22:57:41 <bos> timthelion: if you're trying to learn haskell, start by playing with the Maybe monad.
22:57:47 <glguy> a >>= b  , given an a and a b, return a new value that when run, runs a, applies the result of that to b, and runs the results of applying the result of a to b
22:58:14 <Cale> The IO monad is probably the most complicated monad in existence.
22:58:25 <Cale> (Or at least in useful existence :)
22:58:41 <Cale> But it's not that bad.
22:59:00 <Cale> Basically, the monad operations are just ways to glue actions together.
22:59:07 <timthelion> hmm. from what I can tell from Cale's tut a monad is a funny name for a class :)
22:59:11 <bos> most monads are pure.
22:59:24 <Cale> timthelion: A very specific type of class.
22:59:45 <bos> gah, darcs pisses me off.
22:59:58 <Cale> class Monad m where
23:00:04 <Cale>    return :: a -> m a
23:00:15 <Cale>    (>>=) :: m a -> (a -> m b) -> m b
23:00:25 <Cale> Is the basic definition in the Prelude.
23:00:35 <Cale> Well, basically :)
23:00:38 <glguy> a monad must alsos obey the monad laws
23:00:41 <Cale> right
23:00:45 <glguy> but the compiler can't prove that for you
23:00:57 * timthelion doesn't really know that notation, maybe it would help if he had better than pre-calculus math under his belt?
23:01:03 <slava> return is a funny name, because it doesn't return a value FROM the monad, it wraps a value in the monad
23:01:10 <Cale> timthelion: that's the Haskell declaration
23:01:14 <goltrpoat> return is a terrible name.
23:01:17 <slava> timthelion: you don't need calculus to understand programming language syntax
23:01:19 <glguy> return creates an action that returns the value
23:01:20 <Cale> return is a great name :)
23:01:29 <Cale> hehe
23:01:39 <Cale> It's just mildly confusing to beginners
23:01:48 <zeeeeee> from the wikibook, we can do this: data T' = forall a. Show a => MkT' a; main = mapM_ (\(MkT' x) -> print x) [MkT' 5, MkT' (), MkT' True]
23:01:50 <bos> timthelion: really, just read the code for the Maybe monad and try to use it.
23:01:54 <Cale> If not return, I'd probably call it unit, which would be worse for beginners.
23:01:58 <glguy> especially when you show them callCC $ \ return -> examples
23:02:03 <goltrpoat> i was about to say unit
23:02:08 <slava> i like unit better than return.
23:02:16 <slava> i believe that is what category theorists call it.
23:02:18 <zeeeeee> but why can't we do this? main = let MkT' x = MkT' 0 in print x
23:02:21 <bos> you MonadPlus heretics!
23:02:25 <timthelion> glguy: in your definition of >>= what do you mean by apply?
23:02:29 <Cale> slava: yes, but you study lie group cohomology
23:02:33 <goltrpoat> which would arguably be better, since it wouldn't evoke incorrect associations with the return keyword in c/c++/etc
23:02:51 <glguy> > flip runCont id . callCC $ \ return -> return 1 >> return 2
23:02:52 <mbot>  1
23:03:28 <zeeeeee> seems silly to force us to do MkT' x <- return $ MkT' 0
23:03:30 <ytinasni> zeeeeee: because x isnt in scope at `print x`?
23:03:30 <glguy> bos: a >>= b is  do { x <- a; b x }
23:03:42 <Cale> timthelion: If f is a function and x is a value, then f x is "f applied to x"
23:03:50 <timthelion> return means push n ; jmp pop right?
23:04:05 <timthelion> Cale: ok
23:04:09 <Cale> If x is a value, then (return x) is the action which always returns that value.
23:04:17 <slava> ah
23:04:27 <bos> i hate python.
23:04:31 <Cale> If it occurs in the middle of a do-block, it's a noop
23:04:32 <slava> sort of like hitting a diagram with the Hom functor in the first slot turns things around. ;-)
23:04:39 <zeeeeee> ytinasni: that's not the error
23:04:43 <timthelion> Cale: so with >>= the right returns a function and runs it on the seccond one?
23:04:47 <bos> python's scoping rules are broken.
23:04:50 <zeeeeee> ytinasni: the error is: "My brain just exploded."
23:04:55 <zeeeeee> ytinasni: and i believe it is in scope.
23:05:02 <bos> i wrote a list comprehension: [x for x in foo]
23:05:05 <zeeeeee> (also: "I can't handle pattern bindings for existentially-quantified constructors.")
23:05:09 <bos> and it modified x in the surrounding scope!
23:05:11 <bos> broken.
23:05:18 <zeeeeee> (yet it seems to do so just fine in a monad)
23:05:20 * bos snuggles up to ghci.
23:05:22 <zeeeeee> (or lambda)
23:05:28 <glguy> a >>= (\ x -> b x)
23:05:30 <timthelion> is n y >>=  b c equal to $ n y . b c?
23:05:52 <Cale> timthelion: (x >>= f) will be an action, which when run, will first run x, then it will take the result of x, say, call it v, and compute f v, which will be a second action which will then be run
23:06:07 <Cale> The result of the computation is the result of that second action
23:06:18 <Cale> Let's take a simple example
23:06:32 <Cale> getChar is an action which gets a keypress from the user
23:06:37 <Cale> Its type is IO Char
23:06:38 <glguy> a >>= b    is   do { x <- a; y <- b x; return y } -- to extend it out one step further
23:07:04 <Cale> putChar is a function which takes a Char, and gives an action which prints that character on the screen
23:07:08 <timthelion> glguy: if return isn't c's then what is return/
23:07:13 <Cale> its type is Char -> IO ()
23:07:39 <Cale> note that the resulting action doesn't return an interesting value, just an empty tuple
23:07:47 <Cale> so we can combine these with >>=
23:07:53 <Cale> getChar >>= putChar
23:07:58 <zeeeeee> ytinasni: oh. i think i see your mistake. you thought i was defining MkT' in a let.
23:08:06 <Cale> will be an action which gets a character from the user, and prints it back
23:08:12 <timthelion> ok
23:08:14 <ytinasni> zeeeeee: yeah
23:08:31 <timthelion> so is it like
23:08:48 <timthelion> do c <- getChar
23:08:51 <glguy> > ( do { return 1; return 2; return 3 } ) :: Maybe Int
23:08:53 <timthelion> putchar c
23:08:57 <Cale> timthelion: exactly
23:09:04 <timthelion> ok
23:09:17 <glguy> ?bot
23:09:17 <mbot> :)
23:09:24 <Cale> the do-notation desugars into applications of >>=
23:09:28 <glguy> > return 1 >> return 2 >> return 3 :: Maybe Int
23:09:29 <mbot>  Just 3
23:09:49 <glguy> > fixed? {-
23:09:49 <mbot>  Unterminated nested comment
23:10:05 <Cale> x >> y = x >>= (\k -> y)
23:10:06 <Cale> or
23:10:11 <Cale> x >> y = x >>= const y
23:10:29 <Cale> basically, it just throws away the result of x, and does y regardless
23:10:32 <Cale> so it's like
23:10:37 <Cale> do {x; y}
23:11:05 <timthelion> Cale: if it is throwing the result of x away is it useless with pure functions and only used with IO?
23:11:26 <Cale> Well, yes, but you have to be working in some monad
23:12:06 <Cale> Basically, you're running x just for the side effects, regardless of which monad.
23:12:10 <timthelion> functions can't modify the global environment other than via return no?
23:12:30 <timthelion> Cale: oh, so there are monads other than IO that have side effects?
23:12:34 <Cale> well, yeah, but don't confuse that kind of return with the monadic return
23:13:00 <timthelion> Cale: link? (for monadic return)
23:13:05 <Cale> (in fact, it's better to use the term "evaluates to" or "results in" rather than "returns" for pure functions)
23:13:13 <timthelion> ok
23:13:14 <Cale> return :: (Monad m) => a -> m a
23:13:34 <Cale> You read that as, if m is a monad, then return takes values of type a and gives values of type m a
23:13:41 <Cale> So for instance, if m = IO
23:13:43 <Cale> the IO monad
23:13:50 <Cale> return takes a value, like 5
23:14:02 <Cale> and gives an IO action which just returns 5, all the time
23:14:04 <goltrpoat> i'd dispute the ">> is useless with pure functions" bit
23:14:43 <Cale> goltrpoat: that was strangely worded, but the idea is that the first parameter to >> is being run for effects, and that's true
23:14:47 <timthelion> goltrpoat: how so, isn't that the definition of pure? that it has no side effects
23:15:14 <Cale> goltrpoat is probably complaining because in most monads >> is in fact a pure function
23:15:22 <goltrpoat> :)
23:15:33 <Cale> and the monadic values are pure
23:15:38 <Cale> on some level
23:15:51 <Cale> The issue here is just which level you want to look at things
23:16:10 <Cale> If you look inside the comptuations, then in almost every monad except IO, there are no side effects.
23:16:19 <Cale> For example, in the list monad
23:16:22 <Cale> return x = [x]
23:16:27 <timthelion> I am someone who immediately zooms in to the atomic level until my head explodes
23:16:29 <Cale> x >>= f = concat (map f x)
23:16:40 <Cale> and yet
23:16:48 <Cale> > [1,2] >> "hello"
23:16:49 <mbot>  "hellohello"
23:16:56 <zeeeeee> oh, from the ghc manual: "You can't pattern-match on an existentially quantified constructor in a let or where group of bindings...Instead, use a case expression...The reason for this restriction is really an implementation one."
23:17:02 <Cale> >> actually does something somewhat interesting in this monad
23:17:09 <Cale> even though it's actually 'pure'
23:17:28 <timthelion> what?
23:17:32 * timthelion does not get that
23:17:55 <Cale> It's probably not terribly important
23:18:16 <timthelion> a list with 2 elements the first one 1 and the snd one 2
23:18:21 <Cale> zeeeeee: sorry I didn't point that out to you, I've been involved in this other conversation
23:18:22 <timthelion> thrown away
23:18:32 <Cale> The 1 and 2 are the "results"
23:18:49 <timthelion> and then a second expresion that evaluates to "hello"
23:18:49 <Cale> they're thrown away, and the elements of "hello" are returned
23:19:17 <Cale> > do { x <- [1,2]; y <- "hello"; return y }
23:19:18 <mbot>  "hellohello"
23:19:23 <zeeeeee> Cale: no worries; i just paste here so i have a record in my logs when i inevitably forget the answer again
23:19:28 <timthelion> >[3,4]>>"hi"
23:19:37 <Cale> put a space after the >
23:19:49 <timthelion> > [3,4]>>"hi"
23:19:50 <mbot>  "hihi"
23:20:05 * timthelion 's head explodes
23:20:19 <Cale> > [1,2] >>= (\x -> [x,x])
23:20:21 <mbot>  [1,1,2,2]
23:20:31 <Cale> > [1,2] >>= (\x -> [x,x*10])
23:20:32 <mbot>  [1,10,2,20]
23:20:45 <goltrpoat> > [1,2,3] >>= \a -> "abc" >>= \b -> return (a,b)
23:20:46 <timthelion> > 'h' : 2 : 3 : 4 : [] >> "hi"
23:20:46 <mbot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
23:20:47 <mbot>   add an instance declaration for (Num Char)
23:21:10 <timthelion> > [1, 2, 3] >> "hi"
23:21:11 <mbot>  "hihihi"
23:21:13 <Cale> timthelion: you can't mix types in a list
23:21:14 <timthelion> ok
23:21:14 <goltrpoat> (don't know if that'll cure or exacerbate the head explosion bit)
23:21:33 <timthelion> hmm
23:21:35 <Cale> > do { x <- [1,2]; y <- [x,x*10]; return y }
23:21:36 <mbot>  [1,10,2,20]
23:21:47 <Cale> This is just list comprehensions :)
23:22:09 <Cale> > [y | x <- [1,2], y <- [x, x*10]]
23:22:10 <mbot>  [1,10,2,20]
23:22:16 <ClaudiusMaximus> > let phi = (1 + sqrt 5) / 2 ; fibs r= (floor (r / sqrt 5 + 1 / 2)):(fibs (r*phi)) in fibs 1
23:22:17 <mbot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
23:22:39 <Cale> timthelion: starting to come together what's going on?
23:22:47 <timthelion> I have to think
23:22:56 <slava> me too.
23:23:03 <Cale> main = putStrLn "Hello, what is your name?"
23:23:03 <Cale>       >> getLine
23:23:03 <Cale>       >>= \name -> putStrLn ("Hello, " ++ name ++ "!")
23:23:10 <Cale> Here's a program in the IO monad
23:23:12 * ClaudiusMaximus is starting to understand more about monads too
23:23:50 <slava> Cale: what is the sugared form?
23:23:50 <Cale> But that might be a sidetrack, I'm not completely sure which bits are more confusing than others.
23:24:04 <Cale> main = do putStrLn "Hello, what is your name?"
23:24:15 <Cale>           name <- getLine
23:24:23 <Cale>           putStrLn ("Hello, " ++ name ++ "!")
23:24:32 <timthelion> now I am confused by lists :)
23:24:35 <Cale> okay
23:24:36 <timthelion> what does , do?
23:24:55 <timthelion> in do { x <- [1,2]; y <- [x,x*10]; return y }
23:24:59 <Cale> oh, if you haven't seen list comprehensions before, then I just made you more confused with that, rather than less
23:25:04 <Cale> oh
23:25:07 <Cale> oh, that
23:25:11 <Cale> [1,2] = 1 : 2 : []
23:25:20 <Cale> it's just a list with those two elements
23:25:20 <timthelion> I know that
23:25:33 <Cale> Er, which comma are you asking about then?
23:25:54 <timthelion> then why is it not 1 : 2 : 1*10 : 2*10
23:25:55 <Cale> [x,x*10] = x : (*10): []
23:26:16 <Cale> Because it's depth-first search
23:26:28 <Cale> if that helps
23:27:00 <Cale> To really see, we'll have to actually use the definition of bind
23:27:09 <Cale> x >>= f = concat (map f x)
23:27:18 <timthelion> so, an operator used on a list is like a "for each"
23:27:35 <Cale> yeah
23:27:38 <timthelion> ok
23:27:44 <ClaudiusMaximus> > let phi = (1 + sqrt 5) / 2 ; fibs r= (floor (r / sqrt 5 + 1 / 2)):(fibs (r*phi)) in map sum (inits (map (1/) (fibs phi))) -- approximations to the reciprocal Fibonacci constant
23:27:55 <Cale> x <- [1,2] there is like for each x in [1,2] ...
23:28:13 <ClaudiusMaximus> hmm
23:28:32 <ClaudiusMaximus> oops
23:28:40 <timthelion> [x]*10, for each element of [x] multiply by 10
23:28:49 <Cale> ClaudiusMaximus: not your fault
23:28:55 <Cale> timthelion: no
23:29:02 <Cale> however
23:29:17 <goltrpoat> timthelion:  x <- [1,2] produces, successively, the values 1 and 2, and assigns them to x.  y <- [x,x*10] produces, successively, the values x and x*10, and assigns them to y.  for each x.  then return y puts those in a list because we're in the list monad.
23:29:19 <Cale> > do { x <- [1,2,3]; return (x*10) }
23:29:19 <mbot>  [10,20,30]
23:29:28 <Cale> that will be like a map
23:29:35 <Cale> but you can't just write [1,2,3] * 10
23:29:36 <ClaudiusMaximus> Cale: ok, i'll defer to local ghci for now, though
23:29:58 <goltrpoat> timthelion:  the [1,2,3] >>= \a -> "abc" >>= \b -> return (a,b) example with producing all pairs x,y with x in [1,2,3] and y in ['a','b','c'] works the same way
23:30:00 <Cale> ClaudiusMaximus: lambdabot has a bug which causes it to go to sleep when there's a netwplit.
23:30:02 <Cale> split*
23:30:10 <timthelion> Cale: why ever not? do they not evaluate to the same thing?
23:30:29 <timthelion> Cale: that's the diff between <- and = then
23:30:30 <Cale> Well, if you defined an instance of Num for lists, you could do that
23:30:33 <Cale> right
23:30:55 <Cale> If you want to make local declarations in a do-block, you can use let
23:31:17 <timthelion> and what is the difference between a declaration and a <-
23:31:19 <Cale> > do { x <- [1,2,3]; let y = x * 10; z <- [5,6,7]; return (y + z) }
23:31:20 <mbot>  Parse error
23:31:23 <Cale> er
23:31:28 <Cale> > do { x <- [1,2,3]; let {y = x * 10}; z <- [5,6,7]; return (y + z) }
23:31:29 <mbot>  [15,16,17,25,26,27,35,36,37]
23:31:39 <Cale> without layout, it's a bit picky :)
23:31:55 <Cale> v <- x
23:31:59 <Cale> runs the computation x
23:32:05 <Cale> and binds the result to v
23:32:08 <Cale> let v = x
23:32:20 <Cale> defines v to be the same computation or other value as x
23:32:33 <Cale> for example
23:32:39 <Cale> main = do putStrLn "Hello, what is your name?"
23:32:39 <Cale>           name <- getLine
23:32:39 <Cale>           putStrLn ("Hello, " ++ name ++ "!")
23:32:47 <Cale> if instead of name <- getLine
23:32:55 <Cale> we wrote   let name = getLine
23:33:01 <Cale> then there would be a type error
23:33:10 <Cale> because  name  would be an action, not a string
23:33:30 <timthelion> now if we do name = getLine
23:33:46 <timthelion> then name1 <- name
23:33:56 <timthelion> then putStrLn ("Hello, " ++ name1 ++ "!")
23:33:59 <timthelion> we would be fine
23:34:02 <Cale> right
23:34:10 <timthelion> but if we have, not in a do
23:34:15 <goltrpoat> (name = getLine would have to be in a let block, but yes)
23:34:16 <timthelion> name = "hi"
23:34:21 <timthelion> then we can use name
23:34:23 <Cale> right
23:34:26 <timthelion> because it is a function
23:34:29 <timthelion> and not a ?
23:34:43 <Cale> it's an ordinary value, and not an IO action
23:34:47 <Cale> if we had
23:34:53 <Cale> name = return "hi"
23:35:09 <Cale> then that would make it an IO action, and we'd have to run it with <- to get "hi"
23:35:29 <ClaudiusMaximus> @hoogle (Fractional a) => [a] -> a -> [a]
23:35:36 <timthelion> can we do, putStrLn ("Hello, " ++ <- name ++ "!")
23:35:49 <Cale> no, there's no shorthand for running actions in-place
23:35:55 <timthelion> why not?
23:35:56 <Cale> Well, that's not quite true
23:35:57 <ClaudiusMaximus> ?hoogle (Fractional a) => [a] -> a -> [a]
23:35:57 <mbot> http://darcs.haskell.org/numericprelude/docs/html/NumericPrelude.html
23:36:08 <Cale> but no built-in syntax
23:36:13 <timthelion> ok
23:36:37 <Cale> there are functions like liftM2
23:36:47 <Cale> @type liftM2
23:36:48 <mbot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:37:08 <Cale> liftM2 f x y = do { v <- x; w <- y; return (f v w) }
23:37:41 <Cale> also, you can do funky things with a function called ap
23:38:03 <Cale> but for now, I just recommend running the actions you want to run explicitly until you get used to the distinction
23:38:13 <timthelion> ok
23:39:05 <Cale> It seems a bit heavier at first, but the ability to make that distinction is actually pretty useful.
23:39:07 <timthelion> so, having the return function at the end of an expression causes that expression to stop being just an expression but a function?
23:39:13 <Cale> You can write your own control structures.
23:39:31 <ClaudiusMaximus> is there a function like nub but that stops considering the rest of the (infinite) list when the first duplicate is found?
23:39:39 <timthelion> since expressions are pure, then does the parser cache the results?
23:39:40 <Cale> All that the return function does is turns a plain value into a monadic computation which always returns that value.
23:40:02 <timthelion> Cale: and the monadic value is what you need to run through <-
23:40:07 <Cale> right
23:40:12 <timthelion> got it
23:40:15 <Cale> For example, in the IO monad, (return 5) is the IO action with no side effects that returns 5 all the time
23:40:26 <Cale> and if we write something like
23:40:42 <goltrpoat> claudius:  something like nub' [] = []; nub' [x] = [x]; nub' (x:y:rest) | x == y = x:rest | otherwise = nub (y:rest) ?
23:40:50 <goltrpoat> er.  nub' (y:rest) rather
23:40:50 <Cale> main = do { putStrLn "hello"; return 5; putStrLn "whee!!" }, then both lines are printed
23:41:04 <Cale> return has no ability to control the flow of the program
23:41:14 <Cale> it's just a function which produces a certain type of action
23:41:28 <goltrpoat> claudius:  oh, sorry, i'm on crack.  nevermind.
23:41:31 <timthelion> so return in this case does not equal pop y ; push n ; jmp y
23:41:35 <Cale> right
23:41:46 <timthelion> interesting
23:42:12 <timthelion> I think this is the first language I have run into that that was not true for.
23:42:39 <Cale> This seems like it might be painful -- what if you want to jump out of the middle of a do-block? Well, it is painful at first, but reading the resulting code is easier.
23:42:47 <goltrpoat> timthelion:  there is literally nothing in common between the return keyword in c/c++ and return in haskell
23:42:57 <timthelion> so, do { return "hi" ; "hi"} returns a monadic value, or a non monadic "hi"
23:43:01 <goltrpoat> i'd try to avoid drawing any parallels
23:43:06 <Cale> If you have a do-block in the IO monad, it always runs to the end (or gets stuck in an infinite loop somehow)
23:43:35 <Cale> Every statement in a do-block *must* be a monadic action
23:43:41 <Cale> in the monad that you're using
23:43:51 <timthelion> ok
23:44:06 <timthelion> I think I will go to bed and hit the books some other day
23:44:06 <Cale> So that last line is probably a type error, unless you intended that to be in the list monad.
23:44:18 <timthelion> oh
23:44:19 <goltrpoat> cale:  unless it's in a nested let block :)
23:44:35 <Cale> goltrpoat: hm?
23:44:44 <goltrpoat> "every statement [...] must be a monadic action"
23:44:49 <Cale> well, okay, there are a couple of other statement forms
23:44:58 <timthelion> Cale: but in main = do { putStrLn "hello"; return 5; putStrLn "whee!!" } it evaluates to the last non nil value?
23:45:02 <Cale> a statement can be a let-block without an 'in'
23:45:05 <ClaudiusMaximus> goltrpoat: yeah, that's exactly what i worked out, minus the [] case, because my list is always infinite
23:45:21 <Cale> timthelion: in that case, when executed, it will return ()
23:45:25 <ClaudiusMaximus> goltrpoat: or something close enough
23:45:30 <Cale> because that's what the last putStrLn will return
23:45:36 <goltrpoat> claudius:  that's not nub though, it only looks at neighboring values
23:45:40 <Cale> but yeah
23:45:42 <timthelion> Cale: that's what I thought.
23:45:47 <Cale> it returns the return value of the last action
23:45:52 <timthelion> Cale: and not "return" but evaluate to :)
23:46:03 <ClaudiusMaximus> goltrpoat: true, but you worked out what i really meant (which was not nub)
23:46:07 <Cale> well, the do-block evaluates to an action
23:46:12 <timthelion> yes
23:46:14 <goltrpoat> claudius:  ah ok
23:46:28 <timthelion> always?
23:46:29 <ClaudiusMaximus> goltrpoat: let limit (x:y:zs) | x == y = [x] | otherwise = x:(limit (y:zs))
23:46:31 <Cale> yeah
23:46:41 <Cale> do-blocks always evaluate to the actions of some monadd
23:46:43 <Cale> monad*
23:46:58 <Cale> Sometimes it's not so easy to see that the values of some monads are actions
23:47:03 <timthelion> Cale: so is the return almost more like a cast, "cast this expresion to an action"
23:47:08 <Cale> for example, in the list monad, the actions are just lists
23:47:12 <Cale> right
23:47:21 <Cale> It's pretty close to that idea.
23:47:46 <goltrpoat> timthelion:  are you coming from a c++ background btw?
23:47:53 <timthelion> Cale: so does return mean "make a function that returns x"
23:48:01 <Cale> make an action that returns x
23:48:08 <Cale> actions are usually not functions
23:48:27 <Cale> For instance, getChar :: IO Char
23:48:34 <Cale> doesn't have a -> in its type
23:49:21 <timthelion> goltrpoat: I am 15, I first learned SNOBOL in 5th grade, and then moved on to LOGO, then C++, then JAVA, then C#, then python,then perl, then lisp.  I have never found a computer programing language that I have stayed with for more than 2 years
23:49:32 <Cale> cool :)
23:49:37 <timthelion> goltrpoat: I thought lisp was where it was at, then I got intrigued by haskel
23:50:01 <goltrpoat> (this is totally off topic, but what's wrong with treating constants of type a as functions from the empty set to a, anyway?  seems more consistent)
23:50:12 <Cale> Haskell is where most of the programming language researchers do their practical work at the moment.
23:50:28 <Cale> goltrpoat: not much, it's just that then everything is a function
23:50:34 <timthelion> Cale: most being 2 out of the 3?
23:50:47 <goltrpoat> timthelion:  ah cool.  well, hope you enjoy it.
23:50:49 <Cale> So the word function loses most of its meaning relative to 'value'
23:50:54 <Cale> timthelion: hehe
23:51:33 <Cale> I think there are more programming language researchers than that, but yeah.
23:51:48 <ClaudiusMaximus> > let limit (x:y:zs) | x == y = [x] | otherwise = x:(limit (y:zs)) ; phi = ((1 + sqrt 5) / 2); fibs r = (floor (r / sqrt 5 + 1 / 2)):(fibs (r*phi)) in last $ limit $ map sum (inits (map (\x -> (1.0::Double)/fromIntegral x) (fibs phi))) -- the reciprocal Fibonacci constant  (very off topic)
23:51:49 <Cale> Probably something like that proportion-wise.
23:52:53 <timthelion> I am highly interested in accessibility technology and by that I mean that, man is disabled in that he cannot fly, we build a plane.
23:53:29 <Korollary> That's a very negative outlook heh
23:53:29 <ClaudiusMaximus> mbot responds to a pm, but not in channel
23:53:53 <Cale> Well, it's true.
23:54:00 <timthelion> Korollary: how so? it's not like we can't build the plane
23:54:23 <Cale> We're also pretty much blind to most of the electromagnetic spectrum, but we build tools to see it.
23:54:36 <timthelion> that's why the plane, or the wheelchair or the glasses, or the computer(to me who can't handwrite), are so interesting
23:54:46 <timthelion> yes
23:55:10 <timthelion> but, say, rcirc because irssi wasn't good enough, that's not interesting
23:55:30 <timthelion> unless rcirc lets me do something I couldn't do reasonably with irssi
23:56:14 <Cale> maybe type and read unicode characters?
23:56:20 <mikael> uh, rcirc lets you tab-complete arbitrary words, and switch channels with iswitchb.  it's basically the copernican revolution of computing
23:56:28 <Cale> mikael: hehe
23:58:09 <timthelion> mikael: I use rcirc btw
23:58:11 <Cale> Haskell is nice from this perspective in that its type system lets you do things which are possibly too hard to do correctly without one, or with a less interesting type system.
23:58:57 <timthelion> it seems like the perfect language to write, not just a caluculator but a brain in
23:59:15 * goltrpoat peers at lambdabot intently
23:59:27 <ohmega> hm
23:59:36 <ohmega> utf-8 support in GHC 6.6 is really buggy
23:59:46 <Cale> Yeah, and it tends to be concise enough that you can manage to get reasonable amounts of work done entirely in your head while walking to get a coffee.
