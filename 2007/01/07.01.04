00:00:02 <glguy> ?hoogle a -> Dynamic
00:00:04 <lambdabot> Data.Dynamic.toDyn :: Typeable a => a -> Dynamic
00:00:11 <glguy> > (fromDynamic . toDyn) 3 :: Int
00:00:12 <lambdabot>  Couldn't match `Int' against `Maybe a'
00:00:16 <glguy> > (fromDynamic . toDyn) 3 :: Maybe Int
00:00:18 <lambdabot>  Add a type signature
00:00:43 <glguy> > (\x -> fromDynamic (toDyn x)) 3 :: Maybe Int
00:00:45 <lambdabot>  Add a type signature
00:00:50 <dons> > (fromJust  . fromDynamic $ toDyn (3:: Int)) :: Int
00:00:52 <lambdabot>  3
00:00:58 <glguy> OH
00:01:00 <dons> > (fromJust  . fromDynamic $ toDyn (3:: Int)) :: Bool -- heh
00:01:02 <lambdabot>  Exception: Maybe.fromJust: Nothing
00:01:06 <glguy> > (fromDynamic . toDyn) (3 :: Int) :: Maybe Int
00:01:07 <lambdabot>  Just 3
00:01:10 <glguy> ok
00:01:31 <dancor> i used a map for something that i now want to preserve order about
00:01:37 <dons> > (fromDynamic $ toDyn (3:: Int)) :: Bool -- get that in your types
00:01:38 <lambdabot>  Couldn't match `Bool' against `Maybe a'
00:01:47 <dons> > (fromDynamic $ toDyn (3:: Int)) :: Maybe Bool -- get that in your types
00:01:49 <lambdabot>  Nothing
00:01:49 <dancor> should i just throw an Int in with the values as a tuple?
00:01:52 <glguy> ?type \f xs -> foldl (toDyn . ap . fromDynamic) (return f) xs
00:01:54 <lambdabot>     Expecting a function type, but found `c'
00:01:54 <lambdabot>       Expected type: Dynamic -> b -> Dynamic
00:02:02 <glguy> missing fromJust
00:02:03 <dancor> or is there or should i make like an ordered map class
00:02:06 <dons> dancor: yeah, you could zip "haskell" [1..]
00:02:09 <glguy> ?type \f xs -> foldl (toDyn . ap . fromJust . fromDynamic) (return f) xs
00:02:11 <lambdabot>     Expecting a function type, but found `c'
00:02:11 <lambdabot>       Expected type: Dynamic -> b -> Dynamic
00:02:17 <dons> and then sort on the way out?
00:02:23 <dancor> ok
00:02:24 <glguy> I'll do this in query
00:02:26 <dons> glguy: is that a dynApply ?
00:02:34 <glguy> ?type dynApply
00:02:36 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
00:02:47 <dons> ?docs Data.Dynami
00:02:48 <lambdabot> Data.Dynami not available
00:02:50 <dons> ?docs Data.Dynamic
00:02:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Dynamic.html
00:03:21 <glguy> ?type foldl (fromJust . dynApply) (return (/)) [sum,genericLength]
00:03:23 <dons> > toDyn (ord) `dynApply` (toDyn 'x') :: Maybe Char
00:03:23 <araujo> hello
00:03:23 <lambdabot>     Expecting a function type, but found `b'
00:03:23 <lambdabot>       Expected type: Dynamic -> Maybe a
00:03:24 <lambdabot>  Couldn't match `Char' against `Dynamic'
00:03:37 <glguy> ?type foldl ((fromJust .) . dynApply) (return (/)) [sum,genericLength]
00:03:39 <lambdabot>     Couldn't match `Dynamic' against `m a'
00:03:39 <lambdabot>       Expected type: Dynamic
00:03:45 <dons> > fromDynamic (toDyn (ord) `dynApply` (toDyn 'x')) :: Maybe Chare
00:03:46 <lambdabot>   Not in scope: type constructor or class `Chare'
00:03:51 <dons> > fromDynamic (toDyn (ord) `dynApply` (toDyn 'x')) :: Maybe Char
00:03:52 <lambdabot>  Couldn't match `Dynamic' against `Maybe Dynamic'
00:03:59 <dons> ok go away!
00:04:05 <Korollary> lines and lines of type system abuse. There are kids around. Please.
00:04:33 <dons> ?src toDyn
00:04:34 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
00:04:38 <dons> mmm. tasty
00:04:40 <glguy> the dynamic typed kids do it all the time :(
00:04:53 <kzm> Morning!
00:04:56 <Korollary> they have poor upbringing.
00:05:18 <dancor> what is dynamic typing good for
00:05:30 <Korollary> there's a song that goes like that. Whoa!
00:05:43 <glguy> absolutely nothing!
00:05:46 <glguy> *say it again*
00:05:49 <dancor> maybe something like binding to postgres is less painful?
00:05:50 <vegaiW> dancor: for not caring about types
00:05:57 <araujo> dancor, scripting
00:06:01 <dons> > fromDynamic (fromJust (toDyn ord `dynApply` (toDyn 'x'))) :: Maybe Int
00:06:03 <lambdabot>  Just 120
00:06:25 <dancor> araujo: yeah but like what kind of things.  i do like using python.  but i don't have a good sense what i'm really getting when i do
00:06:30 <dons> its good for tagging values you lose the types of (i.e. when serialising to disk)
00:06:39 <dons> but usually existentials are safer/better
00:07:07 <Korollary> with a dynamically checked language, you don't have to wait till type systems evolve into what you could use to write some fancy stuff.
00:07:10 <dons> its not really a sensible way to make robust code though, since you delay all your errors till as late as possible
00:07:15 <araujo> dancor, For scripting as i said.
00:07:28 <vegaiW> if you enjoy the 'hacking' type of programming more than the 'thinking' type, languages with dynamic typing might just work a bit better
00:07:33 <dons> Korollary: so we're probably there now I think.
00:07:53 <Korollary> dons: there'll always be something else you can't do.
00:08:06 <Korollary> But perhaps you don't care.
00:08:15 <dons> given Typeable, I'm not sure (and maybe it doesn't matter?)
00:08:47 <Korollary> Well, without a type system. changing programs is easier, too. You don't have to think about what happens to the types.
00:09:01 <dons> yeah, easier to introduce new bugs  as well
00:09:13 <dancor> that's true.  less modifications to make
00:09:17 <Korollary> True. I am just listing the pros here.
00:09:33 <dancor> if some type is threaded thru many fcns and you want to change it
00:09:34 <glguy> dons: does dynApply or dynApp have anything to do with ap?
00:09:38 <dons> yeah, so you can write less robust programs maybe faster, but that doesn't win you the ICFP contest ;)
00:09:43 <dons> glguy: nope
00:09:57 <glguy> bah, you've sent me astray!
00:09:59 <dons> so to regain the safety, you have to fake a type system with unit tests anyway
00:10:02 <sjanssen> Korollary: I'd argue that changing programs is more difficult in with dynamic typing.  When do you know that your refactoring is correct?
00:10:12 <dons> sjanssen: you don't care though ;) that's the point
00:10:17 <Korollary> sjanssen: That's the human aspect of it. I am speaking in theory.
00:10:38 <dancor> how do you guys handle that kind of thing?  i guess with good use of 'type blah = <changeable thing>' you can minimizes the changes necessary
00:10:42 <glguy> dynamic typing would screw me whenever I change the parameter type of a big function
00:10:43 <dons> i'm glad when people send me lambdabot patches that at least the random code they send has to type check
00:10:48 <sjanssen> we should call static type checking "refactoring protection"
00:10:50 <dons> if it was dyn typed i'd be very scared of introducing new bugs
00:10:57 <glguy> not having the compiler notice that something is using the old type
00:11:35 <glguy> are functions Typeable?
00:11:50 <dons> yeah, monomorphic ones
00:11:51 <glguy> ?type toDyn (\x -> x + 1)
00:11:53 <lambdabot> Dynamic
00:12:00 <dons> > toDyn ord
00:12:02 <lambdabot>  <<Char -> Int>>
00:12:02 <glguy> so as long as that is Int -> Int?
00:12:12 <glguy> and not Num a => a -> a
00:12:38 <Korollary> hah. there are people in #ltu indeed
00:12:47 <dons> Korollary: given a type system post-typeclasses, with inference, I think the static typing guys start to win maybe ? :)
00:13:01 <dons> you do need a minimum level of sophisttication though to make it worth it
00:13:36 <Korollary> dons: static typing has already won in the industry if you consider usage.
00:13:41 <dons> yeah true
00:13:55 <dons> even without all the safety of a modern type system
00:13:56 <dancor> sophist-tication? ;)
00:14:02 <dons> or the inference
00:14:02 <Korollary> but the industry does dumb stuff so it's not a conclusive thing.
00:14:24 <dancor> yeah FP has lost right
00:14:39 <dancor> erlang is some kind of FP win but it's not static!
00:15:06 <dons> I encourage all bloggers to write their Haskell code without types, just to trick the ruby readers
00:15:10 <Korollary> FP fought? I am not sure it's been tested by the industry as much.
00:15:15 <sjanssen> "lost" is a bit harsh, the game is far from over
00:15:23 <dons> I thought it was jsut starting up
00:15:35 <dons> lisp lost, but thats not FP :)
00:15:41 <Korollary> It depends on how far you wanna go back. ML? Scheme?
00:15:46 * dons hunts around for some multiple cores
00:16:55 <dons> I wonder, can you *lose* once all the programming language researchers start working on your language? (OO in the 80s, pure FP in the 00s?) ...
00:16:56 * kzm wonders if dynamic typing might be a better match for object oriented programming.
00:17:03 <Korollary> OO had to wait 15 years to become mainstream.
00:17:12 <dons> I guess if they port all your features to C# and JAva, maybe
00:17:36 <Korollary> Enough people still do OO research I think.
00:17:53 <dons> its important, anyway, to distinguish impure, untyped lisp from pure, parallel haskell/erlang
00:17:54 <Korollary> Probably more OO research than FP research perhaps?
00:18:01 <dons> not sure, looking at POPL
00:18:09 <Adamant> Lisp is untyped?
00:18:10 <dons> the OO stuff is fading a bit (a lot?)
00:18:18 <dons> Adamant: ;)
00:18:20 <Korollary> The US universities are quite OO heavy I think.
00:18:44 <dons> yeah, they lag (think how long scheme held out , a decade after .au and europe switched to haskell/miranda)
00:18:53 <kzm> Korollary, here too - it's all Java nowadays.  At least they used to use Simula.
00:19:16 <Korollary> is haskell being taught in France?
00:19:21 <dons> and the influence of lisp in the US is kind of inexplicable, to my foreign eyes
00:19:30 <dancor> do you guys ever see issues with garbage collection preventing constant response/framerate for certain applications?
00:19:35 <Adamant> eh. Europe switched to Haskell because Prolog failed.
00:19:41 <dons> hehe
00:19:44 <kzm> You'd think universities would lead industry instead of trailing it, but it doesn't look that way.
00:19:53 <dons> dancor: hmm, maybe in something hard /realtime?
00:20:12 <glguy> ?type \f -> liftM2 f sum genericLength
00:20:14 <lambdabot> forall r a i. (Num a, Num i) => (a -> i -> r) -> [a] -> r
00:20:15 <kzm> dons: I think Lisp got its influence by being advocated by influential persons.
00:20:16 <dons> I've not noticed GC in any haskell app i've written though
00:20:23 <Korollary> kzm: They still think they lead the industry, and possibly do. Not doing FP, though.
00:20:26 <dons> kzm, you mean loud americans? :)
00:20:27 <pjd> dancor: incremental GC?
00:20:27 <kzm> Who will be Haskell's face on the news?
00:20:38 <dons> indeed
00:20:49 <vegaiW> kzm: part of the reason might be that companies tend to pay skillful people significantly more than universities
00:21:01 <kzm> Korollary, probably the difference between a good university and a poor one.
00:21:50 <kzm> vegaiW, not sure.  I think a university is an attractive workplace to many, even if the pay is lower.
00:22:10 <Korollary> kzm: It's not always so clean cut. Places like Stanford and Berkeley don't seem to be into FP much.
00:22:18 <Adamant> university is nice until politics and publish/perish factor in
00:22:51 <araujo> Korollary, they are mor einto java right? :-)
00:23:12 <Adamant> Berkeley does a lot of really good crypto/security research
00:23:13 <Korollary> Besides, CS is not just PLT. We don't even know how much FP affects the bottomline of a project.
00:23:49 <reppie> PLT?
00:23:56 <Korollary> prog lang theory
00:23:57 <kzm> Korollary, well - it was an overstatement of course.  But Standford and UCB could get away with it.  Here it's all about manufacturing worker ants for the industry.  The fairly non-existent industry, I might add.
00:23:57 <Adamant> Programming Language Theory
00:23:59 <dons> I think we have a couple of people here at Berkeley though, that've done Haskell there
00:24:47 <Adamant> Haskell has only limited relevance for a lot of crypto due to speed factors, even if it wins on correctness
00:25:27 <dons> I wonder if that's related to Galois' cryptol language
00:25:37 <dons> or is it an EDSL?
00:25:37 <kzm> Adamant, I can't off hand think of a use I have for crypto where I would value speed over correctness :-)
00:26:03 <Syzygy-> I, personally, from my crypto industry experience, DO value correctness over speed very highly.
00:26:08 <Adamant> kzm, I would agree with you, but crypto algorithms don't all run on desktops.
00:26:18 <Korollary> There are other reasons not to use haskell. I think crypto guys care about things like locking pages in memory, etc.
00:26:22 <Syzygy-> And I was building crypto for ARM processors in mobile phones.
00:26:28 <Adamant> zeroising stuff, yeah
00:26:48 <dons> Adamant: http://galois.com/cryptol.php (I've heard that cryptol is almost an industry standard for the military uses the galois guys work on)
00:26:50 <lambdabot> Title: Cryptol
00:27:09 <Adamant> Syzygy-, did you use Haskell or C+ASM?
00:27:20 <kzm> Actually, I'd think Haskell would be much better at isolating code than most other languages - looking at STM for instance.
00:27:29 <Korollary> I wouldnt miss if nobody used haskell for crypto. It's such a niche area.
00:27:32 <Syzygy-> We used C (no ASM - we did it all in C) - and had serious correctness issues.
00:28:21 * dons notes this is exactly what cryptol is supposed to address
00:28:23 <kzm> We should make a press release next time somebody breaks RFID passports, and claim that had the RFID chip been running Haskell, this wouldn't have happened.
00:28:41 <dons> heh
00:28:46 <Adamant> more nonsense press releases! :)
00:28:55 <kzm> That's what they  are for, you know.
00:29:03 <Korollary> Haskell helps you lose those thanksgiving lovehandles?
00:29:15 <dons> "gmail holes would have been obviated had they used a type system!"
00:29:26 <Korollary> gmail hole sounds like a curse.
00:30:16 <Korollary> A lot of xml tools could be written in haskell I think.
00:30:29 <Adamant> or even better, Lisp. :)
00:30:37 <Korollary> why better?
00:30:43 <dons> yeah, that's a bit of a hot area, now Ralf lammel et al are doing XML at MS
00:30:51 <Adamant> s-exps are similar
00:30:57 <dons> (and the XML workshops that are getting haskell papers written for them)
00:31:23 <dons> i.e. parsing and EDSLs  == Haskell's original (and still best?) niche
00:31:34 <Korollary> but s-exprs are not much of a headstart on haskell.
00:31:58 <Adamant> with SXML, you can manipulate XML like it's Lisp
00:32:06 <Adamant> sort of.
00:32:48 <Korollary> I am not sure I like lisp macros over something specifically written for xml manipulation.
00:32:59 <glguy> is there anyway something to this effect could be possible with Dynamic?
00:33:01 <glguy> foldl1 (\a b -> dynApp (toDyn ap) a `dynApp` b) [toDyn $ (return (/) :: ([Float] -> Float -> Float -> Float)),toDyn (sum :: [Float] -> Float),toDyn (genericLength :: [Float] -> Float)] ([1,3,10] :: [Float])
00:33:07 <dons> I note my irssi client has been up for 115 days, and its lambdabot friend has been up for almost 3 months now
00:33:09 <Adamant> eh, it's a matter of taste.
00:33:46 <vegaiW> not bad for a C program
00:34:06 <Korollary> probably the OS, which is also in C, has been up even longer.
00:34:09 <Adamant> why? FBSD boxes have been up for years at a time, and they're all
00:34:11 <Adamant> C
00:34:42 <dons> yeah, the OS has been up for 138 days, since the last power supply failure :)
00:34:45 <Korollary> It's the thing with meaningless quantities. uptime = 200 days. Is that good or bad? What are we talking about?
00:34:50 <Adamant> OpenVMS boxes are written in assembler and Bliss and C, and some have been up for a decade.
00:34:56 <vegaiW> I would claim that kernel/system developers put a little more emphasis on such things compared to chat client writers
00:35:05 <Adamant> fair eough
00:35:35 <Korollary> chat client writers are biased. They probably use it themselves for months and pissed off majorly when it crashes.
00:36:17 <dons> yeah, I was the same with the curses mp3 players I was using , that crashed.
00:36:24 <dons> good incentive to write one that doesn't
00:36:24 <Korollary> I wonder how many devs contribute to open source project that they themselves use regularly.
00:36:31 <Korollary> er
00:36:33 <kzm> You should measure uptime/programmer time
00:36:39 <Korollary> I meant don't use regularly
00:37:26 <Korollary> I wonder if there's a firefox dev whose favorite browser is opera and doesn't run firefox except for testing his changes.
00:37:28 <kzm> Korollary, I used to think we'd never have good GUIs, "office" suites, etc due to that.
00:37:31 <kzm> Yet here they are.
00:37:58 <Adamant> the atmosphere is changing with regards to UI's in open source.
00:38:03 <dons> just took longer to find people who cared enough
00:38:16 <Korollary> kzm: I suppose those who write openoffice, koffice, etc. use them.
00:38:19 <Adamant> it's a recognized problem, and the more motivated people are trying to learn how to do it right.
00:38:19 <dons> about not using latex/vi ;)
00:39:02 <Adamant> well, Novell, Red Hat, etc. all are doing usability testing on stuff like GNOME now.
00:39:27 <Adamant> which is big, because it's hard for individual programmers to do to real usability testing
00:40:03 <Korollary> or write manuals to be read by others not initimately familiar with the subject
00:40:21 <Adamant> yeah, that too. :)
00:41:01 <glguy> ?src readSTRef
00:41:02 <lambdabot> Source for this function is not available.
00:41:50 <Itkovian> Korollary: uptime being good or bad depends on what is done with the box. is it loaded, what apps are running, etc. so yeah uptime in itself is meaningless.
00:42:07 <glguy> high uptime means an outdated kernel ;)
00:42:23 <Itkovian> well, it depends on what you need the machine for.
00:42:28 <Adamant> or possibily an insecure one
00:42:39 <Adamant> as a result of the outdatedness
00:42:42 <glguy> depends if you need it to be secure, sure
00:42:54 <dons> readSTRef
00:42:55 <dons> readSTRef (STRef var#) = ST $ \s1# -> readMutVar# var# s1#
00:42:55 <glguy> if it's locked behind a private network, not as bad
00:43:17 <Itkovian> I think you like all your machines to be as secure as possible, since attacks can come from within the private network as well
00:43:18 <Adamant> yeah. you can run OpenVMS for 10 years like that because nobody knows how to attack it anymore and nobody cares.
00:43:42 <Adamant> Itkovian, that's more of a threat on an enterprise network.
00:43:56 <Adamant> if you secure your wireless, not much of one for home.
00:44:19 <glguy> "secure wireless" aka "IPSec over 802.11_"
00:44:27 <Adamant> WPA2 if you can swing it
00:44:45 <Adamant> that's plenty secure as far as I know.
00:46:45 <glguy> I used IPSec on mine previously when my router was an openbsd box and my laptop ran openbsd
00:46:58 <dons> me too
00:47:06 <glguy> (wpa[12] wasn't an option, and I needed a reason to use ipsecctl)
00:47:16 <dons> years ago now, maybe 4 yrs?
00:47:16 <Adamant> yeah. that's a driver support issue, though.
00:48:04 <glguy> other than that the wireless support was the best I've used outside of windows
00:51:13 <Adamant> yeah. WPA2 cards usually have a small crypto engine that handles the AES.
00:51:28 <Adamant> so, if WPA2 is supported, might be good to use that.
00:52:26 <Adamant> IPSec is fine, though.
00:52:34 <glguy> fortunately around my apartment complex, the only people that use encryption are those that paid for the SBC wireless DSL router that has encryption by default
00:52:38 <glguy> everyone else shares with me
00:58:02 <glguy> dons: i found your "> fromDynamic (8 `greater` 3) :: Maybe String" comment B^D
00:58:18 <dons> heh
00:58:26 <bakert> Stupid newbie module question.  I called my main module Main so I can runhaskell it.  But the file is called KingsToAces.hs.  How then do I import it into another module?  import Main is wrong because it doesn't search the file and import KingsToAces is wrong because that is not the name of hte module.
00:58:35 <bakert> Do I have to call the file Main.hs
00:58:36 <bakert> ?
00:58:48 <dons> it provides a 'main' function does it?
00:58:57 <bakert> yes
00:59:17 <bakert> perhaps i should put everything except that somewhere else?
00:59:25 <kzm> Isn't there a --main-is option to GHC?
00:59:34 <dons> it doesn't matter what you call the main module (you can leave off the module part too), but the non-main code should probably go in a nicer place
01:00:14 <kzm> Ah right.  Come to think of it, I never use Main as the file name.
01:00:27 <metaperl> if you were creating a data type for an email address, how could you validate the syntax of a string representing an email address. E.g. -  my_email = bob -- fails validation
01:00:39 <metaperl> "bob"
01:00:58 <bakert> kzm, how do you import your Main module into your tests, then?
01:01:12 <bakert> kzm, that is, if you have any and if you need to test anything in Main.
01:01:13 <dons> metaperl: you'd define a data type that only lets you build valid mail addresses
01:01:14 <kzm> bakert, hmm.. guess I don't? :-)
01:01:20 <dons> and maybe write a custom show function for printing them
01:01:31 <metaperl> oh!
01:01:52 <kzm> data EMail = EMail { user :: String, domain :: [String] } ?
01:01:58 <metaperl> data EMail_Address = { pre_at :: String, post_at :: String }
01:02:25 <metaperl> yeah, I like kzm's def better
01:02:25 <kzm> show_domain = intercalate "."  -- :-)
01:02:58 <metaperl> I guess you could writing parsing code for a fromString method for the email data type
01:03:01 <vegaiW> @hoogle intercalate
01:03:02 <lambdabot> No matches found
01:03:05 <vegaiW> I thought so :P
01:03:13 <metaperl> interpolate?
01:04:00 <glguy> why doesn't this work? data E = forall a . Show a => E a; mapM_ (\x -> case e of E t -> print t) $ [E "Test", E "Trip"]
01:04:10 <glguy> OH
01:04:12 <glguy> Nevermind
01:04:14 <glguy> case x
01:04:19 <glguy> (e was defined elsewhere)
01:04:26 <dons> metaperl: e.g.:
01:04:34 <dons> *Main> "bob" :@: "google.com"  :: EmailAddress
01:04:34 <dons> bob@google.com
01:04:34 <dons> *Main> "bob"  :: EmailAddress
01:04:34 <dons> <interactive>:1:0:
01:04:34 <dons>     Couldn't match expected type `EmailAddress'
01:04:36 <dons>            against inferred type `[Char]'
01:04:52 <dons> where we have:
01:04:52 <dons> data EmailAddress = String :@: String
01:04:53 <dons> instance Show EmailAddress where show (who :@: url) = who ++ "@" ++ url
01:05:03 <dons> now, you can add more structure to the left and right hand sides of the :@:
01:05:11 <dons> to prevent, say, "foo" vs "foo.org" statically
01:05:15 <metaperl> is : : an operator?
01:05:17 <dons> or to restrict 'who' to be something valid
01:05:24 <dons> in this case, :@: is the EmailAddress constructor
01:05:30 <dons> (an infix constructor)
01:05:47 <metaperl> @type (:@:)
01:05:49 <lambdabot> Not in scope: data constructor `:@:'
01:05:49 <dons> so all :@: does here is prevent people proving an email address missing a domain (note it still may be null)
01:05:53 <dons> metaperl: its defined there,
01:05:59 <dons> data EmailAddress = String :@: String
01:06:10 <dons> now, what kind of thing do you want to rule out?
01:06:32 <glguy> *Main> :t [E "Test", E 1]
01:06:32 <glguy> [E "Test", E 1] :: [E]
01:06:38 <glguy> I can't help but feel dirty
01:06:49 <metaperl> I think we have an issue already. kzm's def of an email address was more structural
01:06:52 <glguy> and slightly uneasy, like I shouldn't be allowed to do that
01:07:22 <metaperl> data Email_Address = { username :: String, domain = [String] }
01:07:24 <dons> kzm's is isomorphic to mine, but with worse syntax ;)
01:07:32 <dons> yeah, you might want to do that
01:07:41 <dons> you might even want a type to encode valid domains
01:07:54 <dons> say, only those that end in ".org" ".com" .edu" or some such :)
01:07:55 <metaperl> where are the docs on the : : infix operator?
01:08:14 <dons> no no, you can define your own infix constructors, thats all it is
01:08:22 <kzm> Hmm... and the FQDN should be case insensitive, too.
01:08:28 <dons> data T = a * b
01:08:29 <dons> vs
01:08:36 <dons> data T = Star a b -- same thing
01:08:54 <metaperl> yeah, there is something for Python called traits that allows for specification, validation, and initiation of data types... Neil Mitchell's reponse to "Idiomatic Haskell equivalent of "keyword arguments" to functions" is what got me thinking about this
01:09:01 <dons> so the general principle :define a data type with as much type information and structure as you wish to check statically
01:09:02 <kzm> And do you want to support UUCP bangpaths and % expansions, and...
01:09:17 <dons> ah, initialisation checking is easy, using smart constructors
01:09:32 <dons> i.e. you could call the Network.URI parseURI functions on start up
01:09:38 <dons> (on construction)
01:09:48 <metaperl> kzm - no, I was just using stereotypical email addresses as an example. not fully compliant ones of all sorts
01:09:49 <dons> and with a bit more work, you could even do that statically
01:10:07 <metaperl> I didnt know all that about data construction
01:10:39 <kzm> metaperl, I'm often dismayed by web pages that don't accept email addresses including a '+', for instance.
01:10:51 <kzm> So be liberal in what you accept?
01:10:53 <resiak> glguy: how _did_ you do that slightly dirty-looking thing?
01:11:04 <dons> data E = forall t . Show t => E t
01:11:12 <metaperl> kzm  - oh I'm just asking a question because I was wondering about how do this sort of thing in Haskell
01:11:21 <dons> (its ok, just lets you run the methods of class Show on things wrapped in an E)
01:11:35 <glguy> and since all you can do with a Show is return a String...
01:11:37 <dons> metaperl: for the super advaced checking thing, see the 'Solution to the Strings Problem' blog
01:11:49 <dons> about ruling out string injection errors statically using nicely structured types
01:11:50 <metaperl> oh ok
01:11:54 <glguy> i guess you can "shows" and "showPrec" too
01:11:57 <metaperl> wow
01:12:12 <dons> what do you think we spend all this time talking about types for? if not to rule out more bugs! :)
01:12:12 <glguy> dons: link?
01:12:17 <kzm> metaperl, like dons said: encode what you want to check statically in the type system, and check the rest in the constructors.
01:12:28 <dons> ?google strings problem in haskell tom moertel
01:12:32 <lambdabot> http://blog.moertel.com/articles/2006/08/15/solving-the-google-code-jam-countpaths-problem-in-haskell
01:12:32 <lambdabot> Title: Solving the Google Code Jam "countPaths" problem in Haskell
01:12:38 <glguy> dons: I read the article that you should prefix your unsafe strings with 'us' and your safe ones with 's'
01:12:38 <dons> its on the blog
01:12:46 <dons> heh
01:12:51 <dons> I guess that's one option
01:12:54 <glguy> I lawled
01:12:55 <glguy> ;)
01:13:16 <kzm> Putting it in the type system protects you against bugs in all your code, and in addition, helps you with developing algorithms to use it.
01:13:19 <dons> if I really cared I'd tag the nesting depth in the type, and check that (to work out how many quotes are needed). I think that's roughly what Tom suggests too
01:13:27 <glguy> because , he says , then you can *see* the bad code
01:13:48 <dons> we don't teach the right things in uni comp. sci degrees it seems
01:13:59 <dons> knowledge of type systems is maybe 30 years behind where its at
01:14:23 <dons> hands up if you were taught about polymorphism (parametric) in uni?
01:14:42 <glguy> we did templates in C++
01:14:51 <dons> wow
01:14:58 <dons> they can teach that? ;)
01:15:15 <glguy> and used ABCs in C++
01:16:55 <glguy> C++ templates are *close* to parametric polymorphism (without all that worrying about typechecking) right?
01:17:00 <dancor> what kind of image formats are there libraries fo
01:17:01 <dancor> r
01:17:14 <dancor> that i could hook into hopengl textures
01:17:45 <dons> check the libraries page
01:18:01 <dons> also, check Frag
01:18:11 <dons> it uses opengl and textures for the 3d game stuff
01:18:13 <dons> ?wiki Frag
01:18:14 <lambdabot> http://www.haskell.org/haskellwiki/Frag
01:18:36 <dancor> http://haskell.org/haskellwiki/Libraries_and_tools/Graphics is pretty bare
01:18:38 <lambdabot> Title: Libraries and tools/Graphics - HaskellWiki
01:19:29 <dons> better check the HOpenGL docs too
01:21:44 <OliverB__> I'm trying to build a small app with cabal, using the hsc preprocessor - does anyone know how to get it to add include paths for something like this? (the ghc options don't seem to apply)
01:22:06 <dons> yeah, gimme a sec..
01:22:36 <dons> include-dirs:        cbits
01:22:36 <dons> c-sources:           cbits/fpstring.c
01:22:45 <dons> includes:       zlib.h
01:22:45 <dons> that kind of thing
01:23:03 <dons> otherwise, check the hsc2hs section of the Cabal users guide
01:23:34 <dons> for external C libs, you need , ay:
01:23:34 <dons> extra-libraries: curses
01:24:40 <OliverB__> Ah, great. Hmm. Looked at the Cabal users guide, but didn't see more than a breif mention of hsc2hs
01:25:29 <OliverB__> Oh, it does mention it under the include dirs option, great :)
01:36:38 <dancor> frag has a little tga loader that looks godo
01:38:06 <OliverB__> I've used the gtk2hs stuff for image loading
01:48:49 <dons> ?users
01:48:50 <lambdabot> Maximum users seen in #haskell: 269, currently: 268 (99.6%), active: 33 (12.3%)
01:49:34 <ulfdoz> should I spent a clone? ;)
01:50:10 <sieni> should I shot the web?
01:51:32 <OliverB__> Don't worry I provide about 5 clones at any one time given this terrible connection :)
01:52:56 <magr> dons: thanks for adding rdtsc to the Haskell wiki.  I wanted to do that yesterday, and it was already there.
01:53:27 <magr> bringert: and thanks to you for hask-home.  great stuff
01:53:36 <dons> :) I used it immediately, so thought best to add it
01:55:39 <magr> yes, just found your page about Timing computation in cycles. Sometimes it's surprising how useful such a tiny package can be. I'm glad I took the time to cabalize it
01:56:22 <dons> yeah, works for CPAN/Perl. we can do it too
01:56:30 <dons> everything you use more than 3 x should be cabalised!
01:59:01 <pierre-> @where cabal-get
01:59:02 <lambdabot> cabal-get is now cabal-install, and is in Cabal's source tree
01:59:24 <pierre-> @where cabal
01:59:25 <lambdabot> http://www.haskell.org/cabal
02:00:07 <pierre-> @users
02:00:08 <lambdabot> Maximum users seen in #haskell: 269, currently: 269 (100.0%), active: 37 (13.8%)
02:14:29 <kzm> @where rdtsc
02:14:30 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/
02:15:18 <kzm> @botsnack
02:15:19 <lambdabot> :)
02:16:13 <kzm> how is the 'where' index built?
02:18:15 <arjanb> @help where+
02:18:15 <lambdabot> where+ <key> <elem>. Define an association
02:18:48 <kzm> @help where
02:18:49 <lambdabot> where <key>. Return element associated with key
02:19:14 <kzm> Perhaps a help query for either could return help text for both?
02:19:45 <magr> @where+ rdtsc http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/doc/
02:19:46 <lambdabot> Done.
02:19:52 <magr> @where rdtsc
02:19:53 <lambdabot> http://uebb.cs.tu-berlin.de/~magr/projects/rdtsc/doc/
02:19:57 <magr> better :)
02:25:21 <bakert> i love the fact that my random quote on dons' irc stats page is "i'm doing something dim but i'm not sure what" -- randomness gets it spot on.
02:25:27 <bakert> http://www.cse.unsw.edu.au/~dons/irc/haskell-07.html
02:25:28 <lambdabot> Title: #haskell @ freenode.org stats by dons
02:25:53 <bakert> that is my haskell level at this time - doing something dim and trying to work out what!
02:33:07 <bakert> ?hoogle String -> Float
02:33:08 <lambdabot> No matches, try a more general search
02:33:18 <bakert> ?hoogle String -> Maybe Float
02:33:19 <lambdabot> No matches, try a more general search
02:33:32 <bakert> Anyone know how I cast a String to a Float?
02:33:38 <bakert> ?hoogle [Char] -> Float
02:33:39 <lambdabot> No matches, try a more general search
02:33:42 <bakert> ?hoogle [Char] -> Maybe Float
02:33:43 <lambdabot> No matches, try a more general search
02:34:48 <OliverB__> > read "3.7654" :: Float
02:34:50 <lambdabot>  3.7654
02:35:05 <bakert> thanks OliverB__
02:35:11 <bakert> ?type read
02:35:13 <lambdabot> forall a. (Read a) => String -> a
02:35:35 <bakert> some more stuff for me to try and understand ... !
02:36:13 <OliverB> Have you run into typeclasses yet?
02:36:23 <bakert> sort of
02:36:45 <bakert> that does actually make a vague amount of sense to me.  i just haven't got used to forming thoughts of that kind!
02:37:18 <OliverB> Well, it just means that "read" is overloaded (by it's return type) for several types (those which implement the Read interface)
02:38:16 <bakert> gotcha.  right.  need to have a little read about Read i think.  thanks.
02:38:25 <OliverB> Heh, pays not to include a "main" in your library code... here I was going mad trying to work out why my main = putStrLn "hello world" wasn't working
02:40:04 <bakert> i was having trouble with that.  hence the amazing method "main_old_XXX" in my library module!
02:47:57 <kzm> magr: the docs refer to Rdtsc.Rdtsc, but it seems you moved things to System?
02:49:00 <kzm> And whaddayaknow - the next mail is the one from dons about moving it.  So it's all his fault?
02:49:14 <vegaiW> .spell haskel
02:49:18 <vegaiW> @spell haskel
02:49:20 <lambdabot> Haskel Haskell Haskel's hackle hassle
02:49:45 <vegaiW> On my lambdabot, that outputs nothing, even though the plugin is loaded and aspell installed. What might cause that?
02:50:05 <magr> kzm: yeah, blame dons!  but seriously, I forgot to update that. mompl.
02:50:20 <dons> oops . sorry
02:51:03 <kzm> Heh.  Want the darcs patch?
02:51:45 <bakert> ?type mkRegex
02:51:47 <lambdabot> Not in scope: `mkRegex'
02:52:27 <magr> kzm: fixed. check out the webpage again
02:52:54 <bringert> dons: I think I want to work on hackage, especially web interface stuff
02:53:06 <magr> kzm: unfortunately, the layout for the example is fucked up.  I blame our (old, buggy, crappy) webserver for that
02:53:12 <bringert> I was thinking that something like hask-home could be added to ross's interface
02:53:29 <bringert> to get haddock docs, maybe browsable highlighted source
02:53:53 <kzm> magr: I fixed the examples in the code and mailed you the (trivial) patch.
02:54:04 <bringert> installation instructions, news etc could be read from standard files like README, INSTALL, NEWS
02:54:40 <bringert> oh, I meant to say *at hac07*
02:54:54 <kzm> What do you think of Yitzchak's comments?
02:55:24 <bringert> this would make a homepage for every version of every haskell package
02:55:37 <dons> bringert: that sounds like a good idea, given your web hacking experience
02:55:38 <kzm> I mean, how safe is it to use rdtsc in programs?
02:55:47 <dons> kzm: to do what?
02:55:56 <bringert> the generated haddock could include links to the haddock for the dependencies
02:56:12 <kzm> Well - to output some numbers depending on a debuggin switch, for instance.
02:56:14 <bringert> README etc. could use wiki-like markup for nice html
02:57:05 <kzm> Will it not work/crash or what have you on particular systems?  Can the haskell library be safeguarded so that it won't trig nasty behavior?  Fallback to safer or more accurate mechanisms where applicable/necessary?
02:58:03 <dons> and the src
02:58:10 <dons> ?src foldr
02:58:12 <lambdabot> foldr k z xs = go xs
02:58:12 <lambdabot>     where go []     = z
02:58:12 <lambdabot>           go (y:ys) = y `k` go ys
02:58:22 <dons> kzm, yeah, a bit of cpp perhaps?
02:59:01 <kzm> dons - hmm, I'd prefer a runtime mechanism, for distributing binaries.
03:00:37 <dons> call error on the wrong arch? check it dynamically?
03:04:25 <pierre-> @src unfoldr
03:04:26 <lambdabot> unfoldr f b  = case f b of
03:04:26 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
03:04:26 <lambdabot>    Nothing        -> []
03:04:57 <magr> kzm: problem is, all dynamic techniques incur run-time overhead
03:05:11 <magr> and that's a problem when you try to measure performance!
03:05:37 <kzm> Certainly.
03:06:31 <kzm> But doesn't the FFI call already involve a function pointer or similar?  So it could be a matter of pointing that at the right function at initialization time?
03:12:00 <mq_mattr> hello all, I am getting some strange behavour form an `instance Ord X where` defn
03:12:34 <mq_mattr> when I define only < in the class instantiation, it accepts it, but gives stack overflow errors if I use > (or >=, etc).
03:13:09 <mq_mattr> Indeed, any that are not explicit in the defn give stack overflow error if you try them, but the compiler does not complain that I have left out class definitions
03:13:37 <mq_mattr> what are the mechanics of instance Ord X where that are causing this?
03:20:03 <eivuokko> Minimal definition for Ord is compare or <=
03:21:55 <pjd> eivuokko: doesn't Ord require Eq?
03:22:36 <pjd> in other words, shouldn't < together with Eq's == be enough?
03:22:41 <eivuokko> It could
03:22:50 <eivuokko> But it doesn't :)  See report.
03:23:29 <pjd> eivuokko: can you point me in the direction?
03:23:39 <eivuokko> haskell.org/onlinereport
03:23:48 <pjd> thanks
03:23:51 <sieni> eivuokko: :-D
03:23:58 <eivuokko> And there should be a bit about standard prelude or so
03:24:35 * allbery_b wonders if the separation of Ord and Eq relates to Eq being kinda fuzzy on floating point numbers
03:25:13 <sieni> I thought that equality of floating point numbers is quite well defined
03:25:48 <kolmodin> ?tell waern Såg att du fått tummen ur, fan va gött :D
03:25:49 <lambdabot> Consider it noted.
03:26:00 <matthew_-> but there exists x such that (x + 1) == x
03:26:22 <allbery_b> not really, no.  2.0 often ends up being 1.9999999999... or 2.00000000000000000001
03:26:41 <sieni> ?
03:27:18 <allbery_b> you could check logs from a couple days ago when floating point Eq was being discussed
03:27:19 <sieni> no it doesn't
03:27:29 <allbery_b> unfortunately I have to run
03:28:29 <pjd> eivuokko: oh, so it's because all the default Ord implementations (<, <=, =>, >) defer to the compare, which happens to defer to == and <=
03:28:40 <eivuokko> Yeah
03:28:41 <apfelmus> > 1.0 + 1.0*10^20 == 1.0
03:28:43 <lambdabot>  False
03:28:55 <pjd> any reason for that?
03:28:57 <apfelmus> > 1.0 + 1e-23 == 1.0
03:28:59 <lambdabot>  True
03:29:19 <kzm> > 1.0 + 1e20 == 1e20
03:29:21 <lambdabot>  True
03:29:39 <eivuokko> pjd, it is usefull to have default methods so that not everyone needs to implement full Ord.  There has to be some methods picked for it.
03:30:22 <eivuokko> Can't make it work with any one function implemented (without compiler magic), unfortunately.
03:31:07 <matthew_-> yep, floating point really should be banned. ;)
03:32:06 <eivuokko> That Eq/Ord reminds me...I can't find equivalence class proposal at haskell-prime trac, anyone remember if there's an argument against it?
03:35:34 <araujo> good morning
03:39:55 <pjd> eivuokko: why not define the default implementations cyclically?
03:42:59 <pjd> if i'm not mistaken, each operator can be defined in terms of any other (given ==)
03:44:13 <pjd> so you could define them as a chain, where any concrete definition makes the rest concrete
03:46:21 <pjd> am i missing something?
03:54:43 <dmhouse> Hrm. Generic code is still hard in Haskell.
03:55:16 * dmhouse might check out Typeable to see if there's a nice solution, but dynamic typing still seems like a hack.
03:56:48 <dons> can't get by with polymorphism? or one of the generic haskell libraries?
03:57:42 <dmhouse> I don't think polymorphism will quite do it without me adding hundreds of methods to my typeclass.
03:57:46 <dmhouse> Here's my scenario:
03:58:15 <dmhouse> I'm writing forum software using HAppS. There are several 'levels' of any forums, Forum, Thread, Post and User.
03:58:39 <dmhouse> (User is a level in the sense that you can add and delete them, and view them by viewing a page detailing their number of posts, etc.)
03:59:14 <dmhouse> I want to write, in a suitably generic way, a function for deleting these from the database.
04:00:15 <dmhouse> I have a typeclass set up that captures most of the common elements of these levels.
04:00:42 <lisppaste2> dmhouse pasted "Current ForumLevel typeclass" at http://paste.lisp.org/display/34130
04:00:47 <dmhouse> That's it currently.
04:01:10 <dmhouse> (Conversation is my name for Thread.)
04:06:08 <apfelmus> dmhouse: i wonder why you don't have
04:06:09 <apfelmus>   type Conversation ~= (ForumID, ConID)
04:06:09 <apfelmus>   type Post ~= (Int, Conversation)
04:06:09 <apfelmus> i mean, a post is tied to a particular conversation, you can't replace the conversation behind a post
04:07:48 <dmhouse> apfelmus: basically adding upward references to the datatypes? (E.g. storing the ID of the parent forum in a conversation.)
04:07:54 <apfelmus> the conversionation is an intrinsical property of the post, it's not a context in which you display a post
04:08:04 <dmhouse> No, true.
04:08:55 <apfelmus> dmhouse: yes. the upward ID is a property of the post. that the upward id is not displayed in an url or so doesn't change things.
04:10:16 <dmhouse> apfelmus: I did consider that, I think, but I liked the idea that the datatypes should store their entire children and not just references to their children, meaning that upward references would cause cyclicity, but it looks like storing upward references will make things a lot simpler here.
04:10:18 <dmhouse> Thanks.
04:11:12 <apfelmus> yes, this is true. but you will invariably get a graph and not a tree.
04:11:30 <benja_> hmm, does arrow syntax allow leaving off -< () ?
04:12:41 <apfelmus> i think you got trapped by the fact that a name (ForumId, PostId, ...) for some node in a graph (your forum portal so to speak) has no meaning on its own. it needs a "context", i.e. the graph it refers to.
04:14:40 <apfelmus> dmhouse: the point is that your graph has "non-uniform" nodes, i.e. some nodes have type Forum and some have type Post.
04:15:12 <dmhouse> Yeah.
04:15:35 <dmhouse> It is more of a tree with upward references than a graph, I think, though.
04:15:54 <apfelmus> well, that's the same :)
04:15:59 <syntaxfree> I haven't understood proc syntax yet.
04:16:10 <dmhouse> The relationship between a Conversation and a given Post is different to the relationship between a given Post and its Conversation.
04:16:51 <benja_> syntaxfree: ok :)
04:17:14 <syntaxfree> arrows in general creep me out.
04:18:26 <apfelmus> i mean a directed graph. so both relations are different edges. though "relation" is probably a word without meaning, that is the edges carry no data. it's just that the post needs a forum to be displayed and deleted properly.
04:19:06 <apfelmus> you just want that the post can access the data of the forum and vice versa
04:19:20 <dmhouse> apfelmus: would you advocate using a Graph datatype to store the forum database then? Or stick with inclusion for downward links and references for upward links? Or references everywhere?
04:20:55 <dmhouse> (Shout if I'm not making sense, this is mostly new vocabulary for me.)
04:22:54 <apfelmus> that's not an easy question but very worth pondering for a long time because a misdesign makes things difficult. it depends on what operations you need. on thing that is most certain is that you should make it a proper haskell data structure and not put it by default in some external database. but from your talk, i think that's something you intended anyway.
04:23:17 <apfelmus> the problem with Data.Graph is that your nodes are of different type.
04:25:17 <dmhouse> Well if I want to do pretty much anything with a Post I need its parent Conversation and Forum.
04:25:29 <dmhouse> That's the same for all levels of the hierarchy.
04:25:56 <apfelmus> but the other problem is to remove all forward and backward references when you update the graph (delete a user f.i.). that is you have to keep the references up to date, ensure that there are no dangling pointers. that's something the mutable implementations of Data.Graph already do for you.
04:27:25 <apfelmus> dmhouse: so you mean you don't know yet what you need, so you need everything to keep all paths open :) this is wise but doesn't help.
04:28:49 <dmhouse> apfelmus: no, I think I do actually need all the paths. E.g. when displaying a Post I'll obviously need its parent conversation and I'll need it's grandparent Forum, because I'll want to display a link back up to that.
04:29:39 <apfelmus> i suggest that you should get familiar with Data.Graph, just to open your mind and study how exactly the "reference up-to-date problem" is handled. reading the papers from martin erwig is preferred to the haddoc-only :)
04:31:21 <apfelmus> dmhouse: i'm not sure whether you really need this. i mean, displaying a forum topic means to traverse all its posts.
04:31:59 <ski> benja_ : i think not
04:32:12 <apfelmus> and i see no other means to display a post
04:33:35 <dmhouse> apfelmus: okay. So for viewing a given Conversation, we'd clearly need the downward references to print out the Posts. I'd like to have the upward reference too, though, because I'd like to display an HTML hyperlink to the parent forum.
04:33:49 <apfelmus> maybe it's instructive to think about what a "name" should denote (yeah to implement stuff, you need to know the semantics), should mean. how do i name a post?
04:34:12 <ski> .. recently i had a graph structure where nodes contained (not references to) their children, and the traversal function did "pointer-reversal" .. (couldn't handle cyclic graphs, though)
04:34:56 <apfelmus> a post can be named by: "Forumname.Topicname.Postindex". how do i find a post in the data structure?
04:36:00 <dmhouse> Okay, so you're suggesting store the name of the parent topic and forum in a post's name?
04:36:04 <apfelmus> well i have to go to "Forumname" then to the child "Topicname" and then to "Postindex". So, if i want to get the text or the smiley inside a post, i have to traverse these three things anyway
04:36:06 <dmhouse> That's basically storing upward references.
04:38:13 <ski> (in my structure the "reference up-to-date problem" was not a problem, since because of acyclicity, the references was unique)
04:38:33 <apfelmus> dmhouse: ah, now i see what you mean with upward references. of course! no, you don't store the upward references because you would have to update them. you just make sure that any function that neeeds to operate on a "post" will get the parent forum and topic as parameter.
04:39:09 <dmhouse> That's how it is currently.
04:39:40 <dmhouse> (And yeah, by 'reference', I didn't mean 'pointer to a memory address', sorry.)
04:39:51 <apfelmus> dmhouse: ok. so where's the problem? :)
04:40:26 <dmhouse> apfelmus: well, it's that generic delete I'd like to write.
04:41:01 <dmhouse> I've written a generic function that can take any of a forum, conversation, post or user and output a 'Are you sure you wish to delete this item?' page.
04:41:12 <dmhouse> (Keep in mind I'm writing for the web here.)
04:41:54 <ski> are you keeping the whole forums structure in memory as you process it ?
04:42:03 <dmhouse> Yes.
04:42:18 <ski> do you share parts of the stucture from several places ?
04:43:06 <ski> or just a simple tree-structure ?
04:43:37 <apfelmus> dmhouse: well, to delete a topic, you basically delete "Forumname.Topicname.*"
04:43:39 <dmhouse> If the user clicks 'delete' then we send a POST request to "/do-del-{user,forum,convo,post}". Among the post variables is the name of the item we wish to delete. But we'd also need some kind of context to specify exactly which item we're talking about (E.g. for deleting a post we need context of the parent forum and conversation.)
04:44:24 <dmhouse> ski: at the moment, it's basically a tree. data Forum { frmName :: String, frmConversations :: [Conversation] }, etc.
04:44:26 * apfelmus needs to eat, will be back soon
04:44:37 <dmhouse> (I'm actually using a Map instead of a list, but you get the idea.
04:45:14 <dmhouse> The challenge, then, is to generically interpret this context.
04:45:33 <dmhouse> Keep in mind that it has to be sent over HTTP, so we're reading the context from a String.
04:45:48 <ski> data Conversation = C { cnvName :: String, cnvParent :: Forum, cnvPosts :: [Post] }
04:45:52 <ski> ?
04:46:11 <dmhouse> At the moment only downward references are included.
04:46:25 <dmhouse> data Conversation = C { cnvName :: String, cnvPosts :: [Post] }.
04:46:47 <ski> yes .. i wondered if using upwards reference (though only locally) would be acceptable ?
04:46:57 <dmhouse> Cyclic structures are bad when you need to write them to disk. :)
04:47:06 * vegaiW mentions #happs and its urgent need for a lot of people :)
04:47:13 <ski> i didn't mean cyclic structures
04:47:20 <ski> i meant "pointer-reversal"
04:47:38 <dmhouse> ski: if a Forum includes a Conversation, which includes its parent Forum, which includes its children Conversations...
04:48:17 <dmhouse> Unless you're talking about something a bit cleverer than that, in which case I invite you to elaborate :)
04:48:41 <ski> yes, i am indeed talking about something cleverer than that ;)
04:48:48 <dmhouse> Hrm, maybe I could just throw away the downward references when I serialise.
04:49:26 * apfelmus munch, munch
04:49:37 <ski> basically, what i did was implementing a (very simple) adventure game
04:50:06 <apfelmus> dmhouse, the point is not to alter your data structure but the give the whole "qualified" name when specifying which post to delete
04:50:35 <ski> a world contains a current room, and a list of other worlds which are linked from the first
04:50:56 <ski> e.g.
04:51:17 <ski> foo = W "the foo room" [bar,baz]
04:51:33 <ski> bar = W "the bar room" [quux]
04:51:43 <ski> baz = W "the baz room" []
04:51:50 <ski> quux = W "the quux room" []
04:51:56 <dmhouse> apfelmus: yep, I think that approach will work. I'd just add a method to the typeclass, lvlQualName :: lvl -> cxt -> String.
04:52:10 <ski> now, when i walk from 'foo' to 'bar', i change so that
04:52:26 <ski> bar' = W "the bar room" [foo',quux]
04:52:33 <ski> foo' = W "the foo room" [baz]
04:53:03 <ski> i.e. i remove the link to 'bar' from 'foo', as i'm walking it, and also add the link to 'foo' into 'bar'
04:53:42 <apfelmus> dmhouse: ok. actually, i don't need why you need a two-parameter type class. you can encode the qualification via nested types.
04:53:47 <ski> the nice thing about this was that local state of each room could be kept inside the world graph, instead of in some external state, which references into it
04:53:59 <apfelmus> s/don't need/don't see
04:54:33 <dmhouse> apfelmus: the other approach that I think will work is using cyclic data structures, but throwing away the downward references on serialisation and putting them back in on deserialisation.
04:54:48 <ski> dmhouse : do you see ? .. no cyclic structures
04:55:06 <apfelmus> dmhouse: nonono, forget about encoding something in a data structure. (munch)
04:56:17 <dmhouse> ski: okay, what's the analogue with my forum structure?
04:56:19 <dmhouse> apfelmus: why?
04:57:22 <apfelmus> dmhouse: i have to eat, or I'll die :) prepare a simple example forum and we'll take the sokrates-road after i'm finished, ok ?
04:57:52 <malebri1> Why are there so much options in haskell?
04:58:05 <dmhouse> apfelmus: thankyou. :)
04:58:14 <malebri1> Just for Haskell Shell examples, there are 7 options in http://haskell.org/haskellwiki/Libraries_and_tools/Operating_system
04:58:16 <lambdabot> Title: Libraries and tools/Operating system - HaskellWiki, http://tinyurl.com/wpeo9
04:58:16 <ski> dmhouse : when you change the current "position" in your program, e.g. from a forum to a conversation, you can at that point put the forum as a substructure of the particular conversation (and prolly temporarily remove that conversation from the conversation, at the same time) .. and when moving back up, you change back
04:58:34 <malebri1> This makes it very hard to find which one is the most active...
04:58:36 <Philippa> malebri1: people get NIH, only haskell makes it quick enough to IH?
04:58:42 <ski> dmhouse : the point would be that one can avoid external references and "dangling pointers"
04:59:05 <malebri1> Philippa: sorry, NIH, IH?
04:59:11 <ski> Not Invented Here
04:59:12 <daniel_larsson> Not Invented Here
04:59:17 <ski> @wtf NIH
04:59:18 <lambdabot> Maybe you meant: bf ft wn
04:59:26 <ski> mh
04:59:26 <vegaiW> Knights who say Not Invented Here
04:59:44 * vegaiW quickly gives ski and daniel_larsson a shrubbery!
04:59:52 <daniel_larsson> :)
04:59:56 <bakert> Hi all.  Does haskell have a concept like atoms in erlang or ruby's Symbol?
05:00:05 * ski was about to start "We Want .. !"
05:00:26 <vegaiW> bakert: I suppose algebraic datatypes could fill that niche
05:00:29 <Philippa> bakert: that's what algebraic datatypes're for
05:00:55 <ski> bakert : not directly (if you include 'gensym') .. 'Unique' might be what you're after
05:01:02 <dmhouse> ski: I'm just trying to get my head around this. Would it involve writing code that persists across requests to the server?
05:01:06 <Philippa> ski: good catch
05:01:38 <bakert> aha!  so i want one of those data Bookmaker = WilliamHill | Corals | Ladbrokes things ... cool
05:01:39 <malebri1> Philippa: I still don't understood your message, you mean that in haskell it's easy to do things again?
05:01:51 <Philippa> yeah, and that often there's cause to try it
05:02:02 <Philippa> also, the shell-like thing'll be a case of a bunch of people all releasing their personal libs
05:02:21 <vegaiW> or for those particular problems, a clearly superior alternative hasn't been presented yet
05:02:35 <vegaiW> if it even exists
05:02:40 <psicho> hello all
05:02:54 <psicho> could somebody please tell me whats wrong with this little function ?
05:03:04 <psicho> halve l   | (length l `mod` 2)==0 = splitAt (length l `div` 2 ) l
05:03:18 <psicho> | otherwise = l
05:03:37 <dmhouse> ?type splitAt
05:03:39 <lambdabot> forall a. Int -> [a] -> ([a], [a])
05:03:42 <malebri1> Philippa: hum..
05:03:54 <dmhouse> psicho: the first guard will return a pair of lists, the second a list.
05:04:03 <ski> dmhouse : i'm not clear on how/where you intend to use it .. i was responding to the "need upwards references", "reference up-to-date problem" more or less
05:04:27 <dmhouse> psicho: by the way, there is a function:
05:04:30 <dmhouse> ?hoogle even
05:04:30 <lambdabot> Prelude.even :: Integral a => a -> Bool
05:04:31 <lambdabot> GHC.ConsoleHandler.ConsoleEvent :: data ConsoleEvent
05:04:31 <lambdabot> System.Console.Readline.setEventHook :: Maybe (IO ()) -> IO ()
05:04:39 <dmhouse> psicho: (the top one) that might be handy.
05:04:58 <psicho> aha so i need to change te otherwise part, right ?
05:05:07 <ski> dmhouse : my idea is a way to localizing state inside each node in the graph (instead of using some external state for storing it), and also to keep upward references
05:05:11 <vincenz> psicho: depends what you want to do
05:05:56 <psicho> split a list in half if the list is even-lengthed
05:06:05 <vincenz> psicho: and do what with the halves?
05:06:17 <psicho> nothing
05:06:32 <psicho> its just an exercise
05:06:34 <ski> dmhouse : and by "external state" i mean something like having a list (or map) (or 'ST' monad state) and keeping references into that .. not "external" as in external to your program
05:07:23 <dmhouse> ski: ah, so we only keep one node in memory at once?
05:07:36 <dmhouse> With links upward and downward that eventually describe the entire structure?
05:08:42 <ski> erm .. i was meaning to keep the whole structure in memory at once (though maybe you could optimize it like that)
05:09:10 <ski> dmhouse : did you understand my adventure game world example ?
05:09:16 <dmhouse> ski: yes.
05:09:30 <dons> ?users
05:09:31 <lambdabot> Maximum users seen in #haskell: 282, currently: 280 (99.3%), active: 33 (11.8%)
05:10:29 <ski> dmhouse : probably i haven't yet grasped exactly what your problem is
05:10:35 * apfelmus finished eating
05:10:44 <apfelmus> dmhouse: your example is ready?
05:11:07 <dmhouse> ski: no, I'm just not quite grasping how your technique applies to my situation, I think.
05:11:10 <dmhouse> apfelmus: give me a minute.
05:11:12 <apfelmus> ski: you're brilliant. i think you (re)invented zippers in your adventure game!
05:11:26 <dmhouse> Yes, I was thinking it sounds awfully like zippers.
05:11:31 <dmhouse> Although not quite the same.
05:11:31 <ski> apfelmus : yes, i did note that it was kind of zipper ;)
05:12:07 <ski> (if anyone would like to see the meagre code for it, just yell)
05:12:15 <dmhouse> apfelmus: ah, oops, I thought you said 'I'll prepare an example forum.' :) Hehe, two minutes.
05:12:50 <swiert> dons: How's your TMR article coming?
05:13:15 <fasta> What is "Illegal bang-pattern (use -fbang-patterns)"?
05:13:40 <fasta> I wrote a let without an "in"
05:13:41 <Philippa> you've got a ! in a pattern
05:13:42 <kosmikus> fasta: you probably used ! in a pattern
05:13:59 <fasta> kosmikus: yes, I did, but it should mean array indexing
05:14:02 <dons> swiert: getting there. the deadline is when? 19th?
05:14:10 <kosmikus> fasta: you cannot call functions in patterns
05:14:12 <apfelmus> dmhouse: can you make a new wikibook stub for zippers and put the word "adventure game" on it? i don't have time now, just to remind me. i think the adventure game makes a brilliant example.
05:14:27 <fasta> kosmikus: Ah, I see, I missed a ->
05:14:30 <dmhouse> apfelmus: will dol
05:14:34 <dmhouse> *do.
05:14:39 <fasta> kosmikus: thanks
05:14:40 <ski> apfelmus : btw, you and int-e for some time ago discussed blueprints / skeletons (in relations to invertible arrows) .. do you have any links to where this technique came from ?  (link on invertible arrows would be nice, too .. i just saw a lisppaste, i think)
05:15:26 <lisppaste2> dmhouse pasted "forum example" at http://paste.lisp.org/display/34140
05:15:34 <dmhouse> apfelmus: there we go.
05:16:03 <ski> (oh, no annotation of previous paste :/ )
05:16:21 <swiert> dons: Yep - the 19th.
05:16:28 <kosmikus> ski: there was an icfp paper this year. maybe that's where it comes from.
05:16:54 <ski> kosmikus : ty, i'll check .. (last year, itym)
05:17:23 <dons> swiert: ok. should be good
05:17:28 <dons> (the deadline :)
05:17:54 <apfelmus> ski: there was a page named "tying the knot" on the old hawiki and int-e got inspired from it for his blueprint idea. the invertible arrows arose from that, but they look like a dead end.
05:18:12 <apfelmus> kosmikus: paper title?
05:18:19 <apfelmus> dmhouse: ok, i'm listening
05:18:26 <kosmikus> ski: yes, last year of course ;)
05:18:33 <psicho> hm one more stupid question :D
05:18:59 <psicho> why does this function fail if i give it and empty list :( safetail (x:xs) = if length (x:xs)==0 then [] else xs
05:19:16 <dmhouse> psicho: because (x:xs) only matches on a non-empty list.,
05:19:24 <vincenz> what dmhouse said
05:19:28 <vincenz> besides
05:19:28 <dmhouse> psicho: use xs instead of (x:xs).
05:19:30 <vincenz> length is inefficient
05:19:38 <vincenz> it won't work for infinite lists
05:19:39 <psicho> why ?
05:19:47 <dmhouse> psicho: the best way is to use this:
05:19:47 <vincenz> safetail (x:xs) = if null xs then [] else xs
05:19:51 <ski> apfelmus : ok, ty
05:19:55 <vincenz> erm no
05:20:00 <vincenz> safetail xs = if null xs then [] else tail xs
05:20:00 <kosmikus> apfelmus: Programming Monads Operationally with Unimo
05:20:03 <dmhouse> Yeah, what vincenz said.
05:20:09 <dmhouse> apfelmus: what do you want me to explain?
05:20:14 <vincenz> or much more cleanly
05:20:19 <vincenz> safetail xs = drop 1 xs
05:20:26 <psicho> vincenz thanx man
05:21:50 <psicho> well still the same error: D
05:22:06 <dmhouse> psicho: make sure you use xs, not (x:xs) in the pattern.
05:22:21 <psicho> for this version  safetail (x:xs) = if null xs then [] else xs
05:22:26 <dons> ?let safetail xs = if null xs then [] else tail xs
05:22:28 <lambdabot> Defined.
05:22:32 <dons> > safetail "haskell"
05:22:33 <psicho> this errro Program error: pattern match failure: safetail []
05:22:34 <lambdabot>  "askell"
05:22:37 <vincenz> psicho: you're still patternmatching
05:22:40 <dons> > safetail [1..]
05:22:42 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
05:22:42 <vincenz> psicho: look at my second defioint
05:22:45 <dons> > safetail []
05:22:46 <lambdabot>  Add a type signature
05:22:46 <vincenz> safetail (x:xs) = if null xs then [] else xs
05:22:49 <vincenz> ack
05:22:53 <dons> > safetail [] :: [[Int]]
05:22:53 <vincenz> safetail xs = if null xs then [] else tail xs
05:22:55 <vincenz> that one
05:22:55 <lambdabot>  []
05:23:01 <vincenz> or safetail xs = drop 1 xs
05:23:10 <dmhouse> psicho: what's your precise code at the moment?
05:23:12 <vincenz> > let safetail xs = drop 1 xs in safetail []
05:23:14 <lambdabot>  Add a type signature
05:23:16 <dons> psicho: (x:xs) matches against lists of the form a : something, i.e. lists with at least one element
05:23:18 <apfelmus> dmhouse: sorry, i missed the link :) mh, unfortunate that you already included the qualified names, so let's ignore them. ok: i want to delete the post "Very" because it's not enough. what do you say?
05:23:30 <dons> so when you pass in [] as an argument, it matches nothing, and fails
05:23:33 <psicho> i dont wanna use drop
05:23:56 <dmhouse> apfelmus: well I'd start off by pointing out that 'Ish' is a shorter post, but hang on. :)
05:24:01 <dons> > let f [] = [] ; f (x:xs) = xs in (f [], f [1..]) -- so provide a base case
05:24:03 <lambdabot>  Add a type signature
05:24:15 <dons> > let f [] = [] ; f (x:xs) = xs in (f [], f [1..]) :: ([Int],[Int])
05:24:17 <lambdabot>  ([],[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
05:24:21 <dmhouse> apfelmus: 2 mins, just grabbing some soup.
05:24:53 <paolino> or , safetail [] = []; safetail  xs = tail xs ?
05:25:17 <dons> yeah, use decorators ;)
05:25:17 <bringert> does ross paterson hang out here?
05:25:25 <dons> bringert: don't think so
05:25:29 <dons> we should ask him to!
05:25:43 <bringert> I just sent him a list of suggestions for the web interface
05:25:52 <bringert> many of them are ideas from hask-home
05:26:07 <dons> does he have a repo up yet for the hackage src?
05:26:12 <bringert> I would like to be able to use the hackage web interface as the sole home page for all of my libraries
05:26:26 <dons> yeah
05:26:31 <dons> 'tis a good idea
05:26:32 <bringert> source is here http://ross-paterson.dyndns.org/~ross/hackage/src/
05:26:34 <lambdabot> Title: Index of /~ross/hackage/src
05:26:35 <bringert> but no repo
05:26:38 <dmhouse> apfelmus: I simply remove the first element from the list of posts in the Haskell.Cool conversation.
05:26:39 <lisppaste2> apfelmus annotated #34140 with "new forum" at http://paste.lisp.org/display/34140#1
05:27:19 <apfelmus> dmhouse: the rules changed :) go on, you must remove "Very"
05:27:36 <dons> you guys are weird :)
05:28:03 <fasta> Is there something like a pretty printer for Haskell code that works exactly like Lisp code usually is formatted?
05:28:20 <dons> ?pretty f [] = [] ; f (x:xs) = xs
05:28:21 <lambdabot>  f [] = []
05:28:22 <lambdabot>  f (x : xs) = xs
05:28:31 <dons> yeah, Language.Haskell.Pretty
05:28:49 <dmhouse> apfelmus: right, your point is that I need to use the entire qualified name?
05:28:56 <dons> well, I just ignored everything from 'works.*' in your question though, fasta :)
05:29:09 <fasta> ?pretty f [] = long_call long_argument another_argument another another another another another
05:29:10 <lambdabot>  f []   = long_call long_argument another_argument another another
05:29:10 <lambdabot>                  another
05:29:10 <lambdabot>                  another
05:29:10 <lambdabot>                  another
05:29:31 <fasta> On my display that's not really beautiful
05:29:41 <dmhouse> fasta: using a proportional font, yes?
05:29:43 <dons> pretty isn't the same as beautiful
05:30:01 <dons> we'd need @beautiful, which used HsColour and some nice formatting rules
05:30:14 <dons> @pretty is merely pretty
05:30:15 <lambdabot> "Parse error" at column 17
05:30:19 <dons> :)
05:30:20 <fasta> dmhouse: I am not a font specialist, I use Bitstream Monospace
05:30:48 <apfelmus> dmhouse: indeed. it's the responsibility of the delete request to give the entire path. your data has nothing to do with it and thus doesn't need to save any backward references.
05:30:51 <dmhouse> fasta: hrm, it's monospace, it should look okay.
05:30:55 <fasta> dons: I meant that when the length of the entire function call is longer than 80 chars, the arguments are layed out below each other
05:31:18 <fasta> (and I am sure there are lots of other cases)
05:31:30 <dons> what are you trying to do?
05:32:06 <dmhouse> apfelmus: Ah, of course :)
05:32:06 <fasta> dons: oh, well, I find I spend quite some time doing something that is a pretty easy for a computer to do.
05:32:21 <dons> ah ok. you want a good indenter for your editor?
05:32:37 <bakert> Does anyone have any experience of BrowserAction or know where there is some example code?  I just need a leg up to get started
05:32:41 <fasta> dons: that could solve the problem
05:32:42 <apfelmus> dmhouse: hang on, i think i've got a good annotate
05:32:44 <dons> the new vim has an indenter, iirc? but it would be a worthy task to sit down and write a good one (and not too hard)
05:32:55 <fasta> dons: for example I always do this:
05:33:31 <fasta> > let <newline> new_identifier at minimum indentation <newline> in <expression>
05:33:32 <lambdabot>  Parse error
05:33:39 <dmhouse> dons: haskell-mode for Emacs has a good indenter
05:33:55 <fasta> dmhouse: Acceptable, imho.
05:34:00 <fasta> dmhouse: not good
05:34:15 <dons> fasta: hmm. in vim it tends to get the indent after a let right (I think)
05:34:29 <fasta> dons: yes, Emacs does that too
05:34:35 <dons> anyway, script away! the tools are yours to shape as you see fit
05:36:12 <fasta> I was merely asking whether there was such a thing. Next time a newbie asks for an "interesting project" we should give him that. :)
05:38:20 * vincenz laughs at a blog artcle on java "Oh my, XXX is too hard in the compiler, let's invent a bytecode that does this dispatching at runtime so we don't have to do a littlte work in the compiler"
05:38:25 <vincenz> *rolls*
05:38:27 <vincenz> http://headius.blogspot.com/2007/01/invokedynamic-actually-useful.html
05:38:30 <lambdabot> Title: Headius: InvokeDynamic: Actually Useful?, http://tinyurl.com/ylogh5
05:39:02 <lisppaste2> apfelmus annotated #34140 with "data structure for typed qualified names" at http://paste.lisp.org/display/34140#2
05:39:44 <vincenz> apfelmus: why "Here"?
05:40:31 <apfelmus> vincenz: at the end of the path, i'm there. i mean i'm here. here at the end. ah, rats ... :)
05:40:48 <fasta> I wonder why is it that most of the code that's shown on "blogs" and in "papers" has very short function definitions. My code certainly only looks like that for the most trivial stuff.
05:40:59 <vincenz> apfelmus: () ?
05:41:18 <dmhouse> fasta: perhaps you don't break down your functions enough.
05:41:59 <fasta> dmhouse: I think I do
05:42:00 <apfelmus> vincenz: yeah, i'm right () :) no it's just to give it another name and to reduce ()-clutter a bit
05:42:35 <vincenz> what is it with dynamic people wanting to push everything into runtime, cause compilers are "difficult"
05:42:44 <vincenz> apfelmus: oki ;)
05:42:59 <dmhouse> apfelmus: then how would the generic delete look?
05:43:12 <kowey> http://www.loria.fr/~kow/tmp/FlagsAndSwitches.lhs  <-- anyone have better ways of doing the same thing?
05:43:56 <pjd> vincenz: isn't invokedynamic an efficiency thing?
05:44:14 <vincenz> pjd: check the second point in the summary at the end
05:44:41 <dmhouse> kowey: System.Console.GetOpt?
05:44:57 <kowey> dmhouse: also in use... but this is something to replace the ADT
05:44:57 <pjd> vincenz: hmm, that doesn't sound very conclusive
05:45:10 <kowey> dmhouse: the idea is that I want to have a function like getFlag and setFlag
05:45:23 <dons> kowey: how does it differ from GetOpt as is?
05:45:53 <kowey> well, it's not so much getopt, but what you use getopt with... the problem i have with just using something like
05:46:04 <kowey> data Flags = Foo String | Bar Int | Etc
05:46:12 <kowey> is that it's hard for me to write something like
05:46:16 <kowey> hasFlag Foo
05:46:31 <kowey> i'd have to write a separate hasFooFlag, hasBarFlag, and a getFooFlag, etc
05:46:33 <dons> ah yes.
05:46:48 <dons> I have some tricks for that, with partial application, `eem` and deriving Eq
05:46:50 <dmhouse> kowey: IIRC, list comprehensions rock for things like this.
05:46:53 <dons> `elem`
05:47:07 <dons> [ True |  Foo _ <- flags ]
05:47:12 <kosmikus> why would you use a union type for Flags?
05:47:12 <dmhouse> [ s | Foo s <- flags ]
05:47:19 <kosmikus> it's a record, isn't it?
05:47:31 <pjd> vincenz: http://www.artima.com/lejava/articles/dynamic_languages.html
05:47:33 <lambdabot> Title: Dynamic Language Support on the JVM
05:47:37 <kowey> wait, what's a union type?
05:47:50 <dons> kosmikus: the usual getopt thing uses a union,
05:47:52 <dmhouse> kowey: Either as opposed to tuples.
05:47:53 <dons>        ,Option ['u'] []       (NoArg Unbuffered)
05:47:54 <dons>             "The output is guaranteed to be unbuffered (see setbuf(3))."
05:47:54 <dons>        ,Option ['v'] []       (NoArg Invisible)
05:47:54 <dons>             "Displays non-printing characters so they are visible."
05:47:54 <dons>        ,Option []    ["help"] (NoArg Help)
05:47:56 <dons>             "Print this help message"
05:48:05 <dons> where   data Flag
05:48:06 <dons>         = Blanks                -- -b
05:48:06 <dons>         | Dollar                -- -e
05:48:06 <pjd> vincenz: according to that interview, the motivation is efficiency (and some definition of robustness)
05:48:06 <dons>         | Squeeze               -- -s
05:48:16 <kosmikus> dons: no, GetOpt doesn't force anything
05:48:30 <dons> ok ok . I've never seen anything *but* a unoin used there :)
05:48:47 <vincenz> pjd: I was just commenting on that specific blog
05:48:50 <kowey> hmm... list comprehensions!
05:48:54 <dons> and then parseOpts returning a list of flags that were set (or maybe a Set)
05:49:11 <kosmikus> I usually use something like "data Flags = Flags { foo :: String, bar :: Int, etc :: Bool }
05:49:16 <pjd> vincenz: as in commenting here on IRC, or on the actual blog?
05:49:37 <apfelmus> dmhouse: i'm not sure. actually it looks like your initial thought of a multi plarameter type class was right:
05:49:37 <apfelmus> delete :: Path p c  => p a -> [c] -> [c]
05:49:37 <apfelmus> i think one could rename "Here" to "Any" or "All" or "Star". So a value of type (ForumRef Any) specifies a forum and all of its children (topics, posts).
05:49:37 <kosmikus> and then use (Flags -> Flags) as the type in the Option's thing
05:49:49 <kowey> well kosmikus: it's because i want to just have a list of flags
05:49:53 <kowey> many of which are optional
05:49:55 <dons> kowey: hmm interesting.
05:49:59 <dons> kosmikus: ^^
05:50:02 <kowey> i could make a ginormous record, with lots of maybe
05:50:10 <kowey> but... yuck
05:50:16 <dons> kosmikus: do you have an example around?
05:50:21 <dons> how do you handle flags that aren't set?
05:50:31 <dmhouse> apfelmus: what's the Path p c mean? p is a path to a specific c?
05:50:35 <dons> and how do you do:    when (flag is on) $ do ...
05:50:36 <dons> ?
05:51:05 <fasta> dmhouse: I found some old code that illustrates it(and this is one of the simpler functions): http://paste.lisp.org/display/34143
05:51:28 <dons> I usually return a list of flags, and then: when (Unbuffered `elem` args) $ hSetBuffering stdout NoBuffering
05:51:38 <apfelmus> dmhouse: yeah, you have the instances (Path ForumRef Forum), (Path TopicRef Topic) and (Path PostRef Post). maybe "Path" is not a good name, but i don't know a better one.
05:51:46 <lisppaste2> kosmikus pasted "lhs2TeX GetOpt example" at http://paste.lisp.org/display/34144
05:52:24 <dmhouse> apfelmus: wouldn't the type have to be delete :: Path p c => p a -> EntireDatabase -> EntireDatabase?
05:52:46 <dons> ah intereting!
05:53:11 <dons> kosmikus: then you ask/get fields when you need to know if they're on?
05:53:42 <kowey> and how do you distinguish between a field being unset, as opposed to being set to the default?
05:53:43 <ski> dmhouse : do you keep track of one forum or several ?
05:54:01 <dons> kowey: I think you'd have to have a Maybe for that
05:54:11 <fasta> Right, the code of kosmikus seems more like actual Haskell code.
05:54:24 <kosmikus> dons: I just use the field selector
05:54:24 <kowey> (besides Maybe... i used to do it like that too, but then I got sick of extending my records and having lots of stuff to extend)
05:54:27 <dmhouse> ski: several forums, each with several conversations, each with several posts.
05:54:40 <dons> kosmikus: but you thread around the flags in a state value? runReader or some such?
05:55:12 <apfelmus> dmhouse: no. i mean the type is wrong anyway because delete cannot be parametric in a. so, you have something like
05:55:12 <apfelmus>   delete :: Child Forum a => ForumRef a -> Forum -> Forum
05:55:13 <kosmikus> dons: hand-written monads, I'm too stupid for the mtl
05:55:13 <apfelmus>   delete :: Child Topic a => TopicRef a -> Topic -> Topic
05:55:13 <apfelmus> so you gain more than just using delete on the entire database
05:55:31 <dons> anyway, this is nice. I'll have to try it (looks like a good way to directly populate a state from getopt, rather than an extra indirection via a flags list)
05:55:35 <kzm> I'm trying to run a process in the background, but redirect stdout/stderr to files.  I can do it (presumably) by using forkIO (hGetContents e >>= writeFile "out") or some such... but is there a simpler way?
05:55:55 <kowey> oh i see... it's the stuff you pass to getopt that's the interesting bit :-)
05:56:10 <kzm> Speicifically one that eliminates the beancounting of processes to make sure everythign has terminated properly?
05:56:25 <dons> kosmikus: you should probably submit a small patch to the GetOpt docs with an example of filling out a record :)
05:56:33 <dons> since the current docs only have a [Flag] example
05:57:00 <kosmikus> dons: didn't Tomasz once write a mail to the Haskell mailing list with a very similar idea?
05:57:25 <dons> very vaguely rings a bell, yes
05:57:47 <dmhouse> apfelmus: what do you mean by that last sentence?
05:57:47 <kzm> Hm.  I tend to do the flags thing, and *then* convert to a record.  Sounds like there is room for improvement...
05:57:56 <dons> kzm, if you care about termination, you might want to attach an MVAar, and have the thread write to it when done?
05:58:06 <dons> kzm, yeah, me too
05:58:28 <kosmikus> dons: http://www.haskell.org/pipermail/haskell/2004-January/013412.html
05:58:29 <kzm> Yes, that's what the docs suggest.  I was hoping there was an alternative runInteractiveCommand or something, that just redirected output.
05:58:30 <lambdabot> Title: High-level technique for program options handling
05:58:54 <kzm> Of course, I could just attach "> out 2> err" to the end of the command line? :-)
05:59:04 <apfelmus> dmhouse: i think (delete :: ... SomeRef a -> EntireDatabase -> EntireDatabase) is not adequate for it does not allow to delete particular parts for themselves anymore
05:59:05 <kosmikus> dons: I used this before the mail, but I thought since then that it's common knowledge ;)
05:59:20 <kzm> Or is there a simple way to link handles together (like pipes) from inside Haskell?
06:00:08 <dons> oh very nice. this kind of thing is why we need TMR :)
06:00:32 <dons> kzm, hmm. a Chan, with a thread reading and a thread writing?
06:00:33 <kosmikus> dons: yes, this would have made a perfect TMR article
06:00:39 <bakert> @paste
06:00:40 <lambdabot> http://paste.lisp.org/new/haskell
06:00:58 <lisppaste2> bakert pasted "Newbie still not quite getting the hang of monads" at http://paste.lisp.org/display/34145
06:01:03 <dons> I should put up some commentary on this on the wiki
06:01:05 <kowey> makes me wish i'd asked before getting rid of my big-old record :-)
06:01:08 <dmhouse> apfelmus: I'm not sure I follow, sorry. Given a path and the database it could happily delete the thing the path points to, no?
06:01:43 <bakert> Hi folks.  I'd really appreciate it if you'd look at my tiny paste and tell me what is obviously wrong with it.  Basically I have a "BrowserAction String" and I need to get it to be just a String but can't work out how to unwrap it.
06:02:04 <bakert> I thought the line "    (_, response) <- request r" was doing that.  But it seems not.
06:02:07 <kowey> kosmikus++ in any case, simple is good
06:02:07 <dmhouse> ?hoogle BrowserAction
06:02:07 <lambdabot> No matches found
06:02:34 <apfelmus> dmhouse: yeah. but what if you change the code to multiple forums? with EntireDatabase, you have to change the current definition of delete. with the other approach, you simply construct a new one that reuses the old.
06:02:37 <kosmikus> kowey: that might well be my very first karma point :)
06:02:38 <bakert> BrowserAction is in HTTP.Browser and it's a state monad for persisting cookies and the like when scraping web pages (at least i hope it is)
06:02:43 <kosmikus> @karma kosmikus
06:02:44 <lambdabot> You have a karma of 4
06:02:49 <bakert> sorry Network.Browser
06:02:50 <kosmikus> oh, I was too pessimistic
06:02:54 <bakert> to do with Network.HTTP
06:04:34 <bakert> My error is " Couldn't match `BrowserAction' against `IO'"
06:04:50 <bakert>  Couldn't match `BrowserAction' against `IO'
06:04:57 <nornagon> +
06:04:58 <bakert>  Expected type: BrowserAction t
06:04:58 <bakert>       Inferred type: IO ()
06:04:58 <bakert>     In the expression: putStrLn $ (rspBody response)
06:04:58 <bakert>     In the result of a 'do' expression: putStrLn $ (rspBody response)
06:04:59 <kowey> bakert: simpleReq is supposed to be IO?
06:05:07 <fasta> Lowest non-negative karma in the channel:
06:05:11 <fasta> @karma fasta
06:05:12 <lambdabot> You have a karma of 2
06:05:16 <fasta> Huh?
06:05:24 <fasta> Ok, I thought I had zero.
06:05:29 <bakert> kowey, well, for now it is just going to print the body of the response that comes back.  til i get that working!
06:05:59 <bakert> ultimately it is going to be a bit more complicate than that.
06:06:05 <dmhouse> apfelmus: So what type signature do you suggest? You gave two earlier.
06:06:20 <apfelmus> dmhouse: wait a moment, i'm rethinking things.
06:06:38 <dmhouse> apfelmus: good, because I don't really follow your current line of thought at all. :)
06:07:22 <kowey> bakert: what's the BrowserAction String, request r?
06:07:43 <ski> bakert : maybe you want 'liftIO . putStrLn $ rspBody response' ??
06:07:59 <apfelmus> dmhouse: well you may want a delete function that can delete posts from a collection of topics and a delete function that can delete posts from a collection of forums (and uses the former to perform its task)
06:08:03 <ski> (or maybe you don't want 'putStrLn' at all ..)
06:08:24 <kowey> well if you're just working with State for the first time
06:08:38 <kowey> maybe it's best not to worry too much about lifting and all that?
06:09:17 <kowey> I tend to use stuff like evalState, or execState
06:09:28 <dmhouse> apfelmus: I'd be happy with a delete function that deletes one specific item in the hierarchy, anything else is just multiple calls to that function.
06:09:53 <ski> dmhouse : with my approach, the primary 'delete' function would delete the "current" node, that you're standing at .. one could probably also delete nodes given a (relative or absolute) path, if wanted
06:10:18 <kowey> bakert: maybe one of those three functions (evalState, execState, runState) in Control.Monad.State are what you want
06:20:24 <kzm> http://software.complete.org/missingh/static/doc/System-Cmd-Utils.html -- anybody have any experience with this?
06:20:27 <lambdabot> http://tinyurl.com/wfqgr
06:20:47 <kzm> (Specifically to run processes with redirected stdout/stderr)
06:22:44 <bakert> ?hoogle liftIO
06:22:45 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
06:23:43 <lisppaste2> dmhouse annotated #34140 with "My formulation of class Path" at http://paste.lisp.org/display/34140#3
06:23:57 <dmhouse> apfelmus: ^^ slightly different from yours.
06:24:04 <bakert> kowey, ski, sorry i probably didn't make it very clear -- BrowserAction is some kind of reimplementation of a state monad, not an actual Control.Monad.State thing.  So I tink perhaps your functions don't work on it?
06:24:15 <bakert> it is from http://homepages.paradise.net.nz/warrickg/haskell/http/
06:24:16 <lambdabot> Title: Haskell HTTP Implementation
06:24:47 <bakert> i think i will have to read the docs some more and try and work out what the intended use is.  sadly there are no examples!
06:25:44 <bringert> bakert: yeah, that's not very good. are you using the version from http://www.haskell.org/http/
06:25:44 <kowey> bakert: from the example, it looks like you have to call browse on it
06:25:45 <lambdabot> Title: Haskell HTTP package
06:25:48 <ski> bakert : 'ioAction :: IO x -> BrowserAction x'
06:25:54 <ski> s/liftIO/ioAction/
06:25:56 <ski> try that
06:27:41 <bakert> ski, that loads which is a good step!  but when i call it it says: "No instance for (Show (BrowserAction ()))"
06:28:12 <bakert> "putStrLn $ browse $ rspBody response" gives "    Couldn't match `BrowserAction a' against `String'"
06:28:17 <ski> 'browse (simpleReq myAddr)' as kowey said
06:28:17 <bakert> hmm
06:28:37 <kowey> well, browse gives you something in IO, right?
06:28:46 <kowey> so you have to get the value out of the action, first
06:28:50 <ski> (or whatever your main function in the 'BrowerAction' monad that you want to run is)
06:28:57 <kowey> r <- browse $ rspBody response
06:31:31 <bakert> kowey, ski, "z <- browse $ rspBody response" gives "last statement must be an expression".  if i put in "putStrLn z" i get "    Couldn't match `BrowserAction a' against `String'"
06:31:52 <bakert> does that make any sense to you?  Sorry, I'm very new to this wrapping and unwrapping with Monads thing and I am making a bit of a hash of it!
06:32:08 <ski> don't put 'browse' in the 'do'-block for the 'BrowerAction' monad
06:32:15 <lisppaste2> dmhouse annotated #34140 with "As before, minus type errors." at http://paste.lisp.org/display/34140#4
06:32:24 <kowey> let's see what you've got so far :-)
06:32:29 <dmhouse> apfelmus: that's the same, but without the type errors. :)
06:33:12 <kowey> bakert: the monads thing will just 'click' one day... it's like learning riding a bicycle
06:33:18 <bakert> ski, what then do i put as the last line of simpleReq?  return z or z don't seem to work?  How do I get something out of there so I can "browse" it?
06:33:24 <ski> lisppaste2 : proxy error
06:33:30 <bakert> kowey, i hope that day is soon!
06:34:01 <ski> bakert : 'return (rspBody response)' i'd think
06:34:02 <dmhouse> ski: oh good, you're getting those too.
06:34:26 <kowey> bakert: i'm a little bit lost because your last paste dissapeared
06:34:46 <ski> bakert : you probably want to use 'browse' once, around the call to 'simpleReq' (or further up)
06:35:28 * ski still got bakert's paste here ..
06:35:33 <bakert> ski, kowey, wahey!  thanks guys i have something that works.  kind of.  perhaps you would be kind enough to help me understand it?!
06:35:46 <bakert> after (_, response) <- request r
06:35:58 <bakert> i just say "return (rspBody response)"
06:36:14 <bakert> i can then say "x <- browse $ simpleReq "http://bluebones.net/""
06:36:24 <bakert> and "putStrLn x"
06:36:30 <ski> right
06:36:42 <ski> since those 'do'-blocks are in different monads
06:36:46 <apfelmus> dmhouse: ok. damn, the proxy for the paste is down.
06:36:51 <dmhouse> apfelmus: if you're still around? lisppaste's broken, so http://pastebin.com/850944
06:37:01 <ski> the former in the 'BrowerAction' monad, and the latter in the 'IO' monad
06:37:06 <bakert> so what i want to understand is ... what is being unwrapped at the "(_, response) <- request r" level?
06:37:30 <ski> dmhouse : not lisppaste responded
06:37:33 <ski> s/not/now/
06:37:41 <bakert> it still has "BrowserAction" wrapped around it when it comes out of simpleReq, doesn't it?
06:37:51 <dmhouse> Okay, good, so http://paste.lisp.org/display/34140#4
06:37:55 <bakert> then i use browse to take it out of BrowserAction and put it into IO
06:38:06 <bakert> then putStrLn copes with IO side of things somehow.
06:38:08 <lisppaste2> apfelmus annotated #34140 with "almost generic delete" at http://paste.lisp.org/display/34140#5
06:38:14 <bakert> Or have I misunderstood that terribly?
06:38:36 <bakert> @paste
06:38:37 <lambdabot> http://paste.lisp.org/new/haskell
06:38:45 <delamon> bakert: where does simpleReq come from?
06:38:58 <kowey> bakert: heh! i was puzzling over 'after', wondering what 'after' did
06:39:08 <kowey> then i realised that that was English, not Haskell
06:39:16 <bakert> sorry simpleReq is my function.  new paste coming up.  kowey - sorry about the after thing forgot my quotes!
06:39:26 <lisppaste2> bakert pasted "Working but not understood simpleReq" at http://paste.lisp.org/display/34150
06:40:01 <bakert> so i think my main question is, what does the "<-" do in "(_, response) <- request r"
06:40:01 <bakert> ?
06:40:24 <bakert> if it isn't taking anything out of a monad why do i have "<-"
06:40:25 <bakert> ?
06:40:37 <delamon> bakert: ok. and what about `request' ?
06:40:45 <chr1s> hey all!
06:40:47 <ski> bakert : please "annotate" the paste next time ..
06:40:55 <chr1s> I'm trying to replace a substring in a string
06:41:04 <ski> (bakert : the old paste, i.e.)
06:41:06 <chr1s> I've hoogled for it, but couldn't find it
06:41:07 <bakert> delamon, request is a method from Network.Browser i think
06:41:22 <dmhouse> apfelmus: I don't see why you're putting so much emphasis on being able to delete more than one thing at once.
06:41:24 <bakert> ski, ok will do
06:41:27 <fasta> chr1s: how long is the string?
06:41:34 <chr1s> it's not hard to build, but there's probably a default method for it
06:41:35 <chr1s> fasta: not very long
06:41:46 <Saizan> ?type Network.Browser.request
06:41:50 <lisppaste2> apfelmus annotated #34140 with "deletions, now with masks" at http://paste.lisp.org/display/34140#6
06:41:52 <lambdabot> Couldn't find qualified module.
06:41:56 <bakert> request :: Request -> BrowserAction (URI, Response)
06:42:17 <fasta> chr1s: substrPS :: PackedString -> Int -> Int -> PackedString
06:42:18 <fasta> The substrPS function takes a PackedString and two indices and returns the substring of the input string between (and including) these indices.
06:42:26 <Saizan> ok, so you are taking (URI, Response) out of the BrowserAction monad
06:42:28 <chr1s> I'd like something like replace :: [a] -> [a] -> [a]
06:42:41 <chr1s> and another -> [a]
06:42:47 <delamon> bakert: Network.Browser doesn't have `request' ...
06:42:51 <fasta> chr1s: oh, never mind
06:42:55 <chr1s> fasta: would that work on ordinary strings too?
06:42:57 <fasta> chr1s: why not just use Regex
06:43:09 <chr1s> yes, that's good too
06:43:17 <bakert> delamon, oh sorry it must be Network.HTTP then
06:43:25 <fasta> chr1s: subRegex
06:43:25 <fasta> :: Regex	Search pattern
06:43:25 <fasta> -> String	Input string
06:43:25 <fasta> -> String	Replacement text
06:43:25 <fasta> -> String	Output string
06:43:27 <fasta> Replaces every occurance of the given regexp with the replacement string. \
06:43:31 <chr1s> I didn't know Regexes existed, thanks
06:43:33 <kowey> bakert: does Saizan's explanation cover it for you?
06:43:37 <delamon> Network.HTTP doesnt have it either...
06:44:07 <fasta> chr1s: I never used Regex, but it will probably work.
06:44:12 <delamon> bakert: besides, i've just played with Network.HTTP myself. everythin works fine...
06:44:22 <kowey> bakert: you're right, the <- "takes it out" of the monad, and the thing it takes out is a tuple
06:44:25 <fasta> chr1s: do you have the documentation installed locally?
06:44:40 <apfelmus> dmhouse: well the point is that this fits nicely into the type decomposition. this way, one can reuse (Forum a) for masks as well as the forum itself.
06:44:46 <kowey> bakert: since you're not interested in the first part of the tuple, you just matched it with (_, response)
06:44:47 <bakert> delamon, it is in the version of Network.Browser in front of me.  perhaps i have an old version.
06:44:57 <chr1s> fasta: cool, thanks
06:45:06 <chr1s> I mostly use hoogle
06:45:21 <delamon> bakert: i'm looking in http://www.haskell.org/http/api/Network-Browser.html
06:45:23 <fasta> I almost never use hoogle.
06:45:25 <bakert> kowey, Saizan, ok but hte type of simpleReq is
06:45:29 <bakert> simpleReq :: String -> BrowserAction String
06:45:40 <kowey> right
06:45:45 <apfelmus> dmhouse: otherwise, one has separate types for data and paths. but i think you can capture it with the following:
06:45:54 <kowey> well, if you look at rspBody
06:45:56 <bakert> and i would have thought that if i "unwrapped" from BrowserAction in there it would not appear in the type signature.  which i guess shows how little i understand these things!
06:46:22 <kowey> you see that if you do rspBody response, you get a String, right?
06:46:34 <bakert> right
06:46:36 <kowey> this might be confusing, because if you look in documentation, you see something like rspBody :: String
06:46:42 <kowey> but what that _really_ means
06:46:50 <bakert> yep
06:47:13 <kowey> is that rspBody is of type  Response -> String
06:47:32 <apfelmus> dmhouse:
06:47:32 <apfelmus> type Database = Forum (Map Int (Topic (Map Int Post)))
06:47:33 <apfelmus> type Path = Forum (Int, Topic (Int, Post))
06:47:33 <fasta> When GHC uses X MB of memory at some time, will it ever release that memory back to the OS (before the program terminates of course)?
06:47:34 <bakert> delamon, i think i might be using an old version then.  drat.
06:47:44 <kowey> ok, so we're good with the idea that rspBody response is a String, so the rest is simple
06:48:03 <fasta> Or more formally: is the memory usage of a GHC program monotonically non-decreasing?
06:48:17 <kowey> the "return" just puts that String into a BrowserAction monad... see?
06:48:33 <fasta> And finally, is there any Haskell implementation that doesn't have this weakness?
06:48:37 <bakert> kowey, i think i am just confused because i am thinking of "<-" as meaning "unwrap from monad and throw away" but the "return" seems to kind of "rewrap" in the same monad??
06:48:45 <kowey> exactly!
06:48:49 <dmhouse> fasta: err, doesn't monotonically nondecreasing = monotonically increasing? :)
06:48:51 <kowey> return means "wrap this into a monad"
06:48:56 <fasta> dmhouse: no
06:49:00 <kowey> or rather "the monad du jour"
06:49:06 <bakert> so a function can never get away from a monad once it has used it, that has to happen outside the function?  or could i somehow do away with "return"?
06:49:12 <apfelmus> dmhouse: maybe
06:49:12 <apfelmus> data Collection a b = Coll a (Map (In
06:49:15 <fasta> dmhouse: well, it depends on who you are asking
06:49:16 <apfelmus> rats
06:49:36 <dmhouse> fasta: remembering that f is monotonically increasing => (x1 <= x2 => f(x1) <= f(x2))
06:49:45 <dmhouse> Not <
06:49:50 <fasta> dmhouse: http://planetmath.org/encyclopedia/MonotonicallyNondecreasing.html
06:49:53 <lambdabot> Title: PlanetMath: monotonically nondecreasing, http://tinyurl.com/salpw
06:49:57 <kowey> bakert: i think you've got an interesting question there, but you could rephrase it?
06:50:10 <bakert> kowey, ok, here goes:
06:50:11 <vincenz> HOLY COW!
06:50:14 <vincenz> Any phd students here?
06:50:18 <Saizan> bakert: generally you can't escape from a monad, but some monads provides functions to do that
06:50:25 <vincenz> This is probably the most shocking story ever
06:51:06 <bakert> is it true to say that once i have  a do block in my function i must necessarily give out a return value wrapped in that monad.  if i do any unwrapping in my do block i have to "rewrap" at the end with a "return" statement.  right?
06:51:18 * bringert is a phd student
06:51:21 <kowey> well, return isn't always neccesary
06:51:24 <fasta> dmhouse: do you know the answer to my question?
06:51:31 <kowey> because some things "pre-wrap" their stuff in a certain monad
06:51:35 <vincenz> Some guy got a paper accepted at 2 different conferences.  The same paper, they were both accepted.  And now this is not the shocking part, the shocking part is that this duplicated paper is not even original content, but ripped text from other papers which were not attributed or referenced.  And it was accepted both times!  Now, only, postfactuum are they banned from IEEExplore with a banner message saying policy violation
06:51:35 <bringert> vincenz: what's the shocking story?
06:51:45 <kowey> bakert: consider getLine from the IO monad
06:51:50 <ski> bakert : you have to return *something* wrapped in the same monad, yes .. you don't always need to use 'return', though
06:51:51 <kowey> you don't have to do x <- getLine
06:51:52 <kowey> return x
06:51:56 <bakert> kowey, but if i have an unwrapped value i need to return then i have to "return" it.
06:51:57 <vincenz> bringert: if you have access to ieeexplore, search for "lawabni"
06:52:00 <kowey> because getLine already gives you an IO String
06:52:09 <kowey> bakert: right
06:52:17 <fasta> vincenz: what's shocking about that? I know another study where they tried to do this on purpose.
06:52:18 <boegel> vincenz: IEEExplore URL?
06:52:24 <dmhouse> fasta: no, sorry.
06:52:25 <sieni> fasta: I would say that a) the planet math definitions suck b) `monotonically' with (non-)increasing/(non-)decreasing is completely superfluous and c) the terms that should be used are (strictly) increasing/decreasing/monotone
06:52:40 <vincenz> boegel: just do an author search on lawabni
06:52:42 <vincenz> boegel: first 2
06:52:44 <boegel> fasta: I heard someone trying it with a computer-generated article full of gibberish
06:52:46 <bakert> kowey, ski, delamon, Saizan, thanks guys ... my haskell education carries on at an alarming rate in week 2!  thanks!
06:52:49 <vincenz> benc__: yeah :)
06:52:58 <kowey> have fun!
06:53:01 * kowey gets back to work
06:53:02 <vincenz> fasta: these were serious papers at reasonably serious conferences.  GLOBECOM and ISCC
06:53:08 <vincenz> The second one is supposedly reasonably good
06:53:13 <fasta> vincenz: The study I am talking about too
06:53:20 <vincenz> fasta: yeah but he was a phd student
06:53:28 <vincenz> and you can see on his homepage "expected to graduate in 2005"
06:53:32 <vincenz> but I guess he got kicked
06:53:41 <apfelmus> dmhouse: after all, i think your curent Path class does what it should, you can easily augment it with delete. ok, my time's up, i have to leave.
06:53:55 <fasta> vincenz: oh, sure that student needs another "career" now.
06:54:11 <dmhouse> apfelmus: thanks a bunch for your help, it's been excellent. :)
06:54:30 <vincenz> fasta: what's more shocking is the fact that both review processes led it through
06:54:33 <vincenz> talk about bad review
06:55:21 <apfelmus> dmhouse: "apfelmus, in strive for excellence" ;) bye, have a nice day!
06:55:38 <sipaliwini> hello, I am new here, how does it work to ask questions ? just fire away ?
06:55:46 <dmhouse> sipaliwini: yep.
06:55:47 <boegel> vincenz: I guess the pressure is just too high on reviewers... Lieven (in our group) has to review like 50 papers :/
06:55:54 <vincenz> boegel: http://ieeexplore.ieee.org/iel5/10511/33285/01577660.pdf?tp=&arnumber=1577660&isnumber=33285
06:55:57 <lambdabot> http://tinyurl.com/yz4r3v
06:56:02 <vincenz> boegel: ouch
06:56:10 <boegel> vincenz: and doing it thoroughly takes about 1h/paper... do the math
06:56:15 <vincenz> http://ieeexplore.ieee.org/iel5/10000/32117/01493787.pdf?tp=&arnumber=1493787&isnumber=32117
06:56:18 <lambdabot> http://tinyurl.com/sg4aq
06:56:20 <vincenz> boegel: 1h only??
06:56:35 * vincenz is thnking more like half a day to read up on related work if it's not directly your field
06:56:54 <vincenz> if not more
06:56:57 <vincenz> anyways
06:57:01 <vincenz> coffeebreak time with colleagues
06:57:04 <vincenz> andy, if you know him ;)
06:57:07 <vincenz> and praveen
06:57:08 <sipaliwini> ok, so I'm importing a C function into haskell, but I get varying behaviours depending of whether I redirect the output to a file or not
06:57:10 <ski> <apfelmus> data Collection a b = Coll a (Map (In
06:57:12 <ski> ?
06:57:15 <fasta> 1 hour to read a paper? It can't be an interesting paper then.
06:57:16 <boegel> vincenz: he is a fast reader... but he does it quite thoroughly... it would take me several hours probably
06:57:25 <sipaliwini> is that a sign of a known mistake ?
06:57:26 * vincenz nods
06:57:47 <boegel> vincenz: and that's an average... some papers are quite clearly not suited...
06:58:17 <fasta> I'd wish that people stopped publishing garbage.
06:58:19 <MarcWeber> Can I use profiling to get to know why my program doesn't return? I only get an empty .profile after "heap exhausted" ..
06:58:38 <ski> dmhouse : did your problem get solved ?
06:58:43 <fasta> Everyone should write like Knuth :)
06:58:52 <dmhouse> ski: almost, I'm just working towards it.
06:59:11 <ookk> is there a way to do IO Multiplexing in haskell? like the C select() ?
07:00:03 <ski> threads ?
07:00:45 <ookk> so i have to implement select() myself?
07:01:02 <ookk> its pretty essential to network programming to have a select()
07:01:18 <allbery_b> haskell seems to go more for lots of dedicated threads than for multiplexed I/O
07:01:40 <allbery_b> (haskell threads are light enough you should be able to get away with that)
07:02:06 <ookk> okay i havent read up on haskell threads
07:02:11 <pjd> ookk: in other words, the multiplexing happens under the hood
07:02:20 <ookk> what is the best way to synchronize threads?
07:02:33 <ookk> (in haskell)
07:03:11 * allbery_b thinks someone else will have to answer because he's not very familiar with it all yet
07:03:26 <MarcWeber> ookk Do you want the thread to wait for another?
07:03:53 <allbery_b> there are MVars for mutexes, and TVars for STM ("transactions")
07:04:28 * MarcWeber listens to allbery_b as he knows more..
07:04:45 <ookk> MarcWeber, i want to do something similar to the C select()
07:05:00 <ookk> MarcWeber, that is i have many sockets wich i can recv from
07:05:24 <malebria> Almost all projects in http://haskell.org/haskellwiki/Libraries_and_tools are abandoned.
07:05:24 <kolmodin> ookk: GHC will take care of that for you
07:05:26 <lambdabot> Title: Libraries and tools - HaskellWiki
07:05:45 <kolmodin> ookk: with lightweight threads and nonblocking handles
07:06:15 <ookk> kolmodin, but with nonblocking handles i have to poll, that uses lots of cpu time
07:06:16 <malebria> Is hIDE being developed?
07:06:32 <kolmodin> malebria: no, not currently
07:06:52 <allbery_b> MarcWeber: that's approximately all I know about it
07:06:58 <malebria> kolmodin: Is there a place where I can get a list of the active haskell projects?
07:07:14 <allbery_b> they exist, but how to use them?  I haven't had to look yet
07:07:15 <kolmodin> ookk: ghc will use select internaly, you just block
07:07:23 <pjd> ookk: you don't have to poll; the efficient select()/poll() multiplexing happens under the hood
07:07:31 <allbery_b> scary unsafePerformIO foo seems to be involved :/
07:07:43 <kolmodin> malebria: which active projects?
07:08:13 <kolmodin> pjd: thanks for the clarification
07:08:36 <ookk> pjd, so i can just use a common resource in my threads?
07:08:47 <pjd> "use a common resource"?
07:09:20 <ookk> pjd, like a database
07:09:41 <ookk> or an IOArray
07:09:45 <ookk> or whatever
07:09:56 <ookk> that many threads might want to write to
07:09:56 <allbery_b> that's where the mutexes and/or STM come in
07:10:18 <kolmodin> ookk: that's different from blocking on sockets
07:10:39 <ookk> kolmodin,  but thats what you would use select for
07:10:53 <ookk> you wait for a write signal from one of the sockets
07:11:04 <ookk> and then they get to write to the database or whatever
07:11:12 <pjd> ookk: that happens automatically
07:11:19 <allbery_b> and how does that protect your database, unless you've limited that to one thread already?
07:11:31 <pjd> MVars, STM and such are for higher-level inter-thread communication
07:11:48 <ookk> allbery_b, because everything comes in order with select
07:11:57 <ookk> allbery_b, you handle the requests one at a time
07:12:11 <pjd> ookk: that's what happens under the hood
07:12:23 <pjd> you don't have to worry about it
07:13:09 <allbery_b> oh right, you're currently doing the unithread stuff
07:13:27 <ookk> pjd, i dont think so? can i read from a database and then write back in a thread knowing that the value i read wont have changed...
07:13:50 <ookk> pjd, with select i dont have to worry about that because nothing can happen while i handle the requests
07:14:00 <ookk> beacuse select pops out the requests for me in order
07:14:17 <ookk> but if i in haskell fork a thread each time i get an accept i dont think that is possible
07:14:21 <pjd> ookk: select doesn't give you any guarantees about the database
07:14:45 <ookk> pjd, yes if my program is the only one using it
07:14:49 <allbery_b> pjd: but if he's got a singlethreaded app which is the only thing writing to the db, it's serialized
07:14:51 <pjd> ookk: Haskell's lightweight threading is not like operating system threads
07:14:55 <ookk> lets say IOArray instead of database
07:15:39 <pjd> ookk: for that, you use MVars, or STM, or similar (AFAIUI)
07:16:18 <ookk> yes and thats a shame because it would be much simpler with something like select()
07:16:23 <ski> ookk : http://www.haskell.org/ghc/docs/latest/html/hslibs/Select.html ?
07:16:24 <lambdabot> Title: 9.5. Select: Synchronous I/O multiplexing
07:17:05 <ookk> ski, doesnt say wich module it is in
07:17:23 <ookk> or where i can get the module Select
07:17:29 <pjd> ookk: select is completely orthogonal; i think you're thinking of cooperative multithreading (versus preemptive)
07:17:36 <ookk> i dont have that in my haskell distribution
07:18:14 <bakert> I've got a program that is going to login to a website, visit a few pages, and retain a little bit of data that it finds on these pages.
07:18:19 <ookk> pjd, basically, what i want do to is get the incomming requests in order and handle them in order
07:18:23 <ski> ookk : module 'Select' in package 'util
07:18:24 <ski> '
07:18:30 <ookk> pjd, without anything happening "in parallel"
07:18:39 <bakert> I can do this under the HTTP.Browser.BrowserAction monad.
07:18:41 <ski> 'gchi -package util' and then ':b Select' works fine here
07:18:48 <bakert> But I'm not sure exactly how to structure my code.
07:19:03 <ookk> ski, ah i missed that
07:19:08 <ookk> then my problem is solved
07:19:12 <ookk> i can use select
07:19:17 <pjd> ookk: haskell is referentially transparent, so the question of being "in parallel" becomes a bit moot
07:19:18 <ookk> ski, thx
07:19:18 <bakert> I can write one gigantic do block and then "unwrap" at the end.  But that would be pretty ugly.
07:19:39 <pjd> you don't get the same problems to begin with, that you get in impure/imperative languages
07:19:41 <bakert> I should really have a login function and a function for each of the bits of info i am going to grab.
07:19:41 <ski> @here select
07:19:42 <lambdabot> I know nothing about select.
07:19:44 <pjd> (with preemptive switching)
07:19:51 <ookk> pjd, well if i spawn two threads they will execute "in paralllel" ?
07:19:52 <ski> @where+ select http://www.haskell.org/ghc/docs/latest/html/hslibs/Select.html
07:19:53 <lambdabot> Done.
07:20:19 <bakert> So do I need a series of functions that are :: URI -> BrowserAction String
07:20:21 <pjd> ookk: the more important question is: can they interfere with one another?
07:20:44 <pjd> cooperative multithreading is a way of preventing a certain class of interference
07:20:53 <ski> ookk : http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/2005/lab2.html and http://www.cs.chalmers.se/Cs/Grundutb/Kurser/afp/2005/lab2-hints.html was partly about avoid having to collect the handles to pass to 'hSelect' manually
07:20:54 <bakert> How do I pass the Monad "in" to the second and subsequent functions?
07:20:56 <lambdabot> Title: Advanced Functional Programming - Laboration 2
07:21:09 <ookk> pjd, but then can if the read / write to for instance an IOArray
07:21:16 <bakert> Will that just happen behind the scenes?
07:21:19 <ski> ookk : maybe those are interesting in your case, dunno
07:21:33 <ookk> ski, thx
07:21:38 <ookk> will look into it
07:21:56 <pjd> ookk: sorry, i can't comment usefully on IOArray; still new to Haskell
07:22:23 <ookk> ok
07:22:33 <MarcWeber> Is there a fast way to get to know why a haskell program doesn't terminate ?
07:22:51 <bakert> MarcWeber, i get most traction with Debug.Trace.trace
07:23:00 <bakert> MarcWeber, but i'm new to this game.
07:23:03 <ski> ookk : otoh istr that ghc will not block the haskell process on the 'select' C call until all threads have called 'hSelect' (not sure, though) .. so you possibly don't need something like that laboration for doing it
07:23:04 <vincenz> re
07:23:19 <malebria> kolmodin: all of them, like in that page.
07:23:31 <vincenz> boegel: it also depends on how close it falls to your topic, of course
07:23:43 <ookk> ski, if i have select i wont need to use threads at all
07:24:03 <wolfgangbeck> i was told that support for select has been dropped from haskell
07:24:26 <boegel> vincenz: yes, very true... but Lievens knowledge is pretty broad :)
07:24:37 <bd_> wolfgangbeck: There are some functions in Control.Concurrent for waiting on Handles
07:24:39 <ski> ookk : no .. but for ease of coding, it might be nice to do so anyway .. at least fake threads like those in that laboration
07:24:47 <vincenz> boegel: nce :)
07:24:49 <vincenz> nice even
07:24:57 <vincenz> boegel: were you at eindhoven?
07:24:59 <bd_> wolfgangbeck: it's not exactly select, but since haskell threads are cheap you can just have a thread for each handle waiting on it
07:25:13 <bd_> wolfgangbeck: internally there's one thread doing select() or epoll() or something
07:25:23 <ookk> ski, hmm unknown package util
07:25:26 <ookk> ski, i guess i dont have it
07:25:39 <ookk> i use ghc-6.6
07:26:03 <boegel> vincenz: no, I wasn't :)
07:26:09 <boegel> vincenz: should I have been?
07:26:31 <vincenz> I don't know, I wasn't there ither
07:26:37 <boegel> oh, ok then ;-)
07:26:39 <wolfgangbeck> im just trying to do a timer lib with threads
07:27:19 <wolfgangbeck> btw, is there a way to add a type signature to a 'let' expression?
07:27:52 <bd_> wolfgangbeck: what threads are you waiting on? select is probably the wrong abstraction
07:27:53 <MarcWeber> bakert: I'll use this then..
07:28:06 <bd_> wolfgangbeck: and, you can evaluate an expression along these lines: (someVar :: SomeType)
07:28:24 <wolfgangbeck> i'm doing protocol stuff, you wait either for a message or a timeout, if the message does not arrive
07:28:26 <allbery_b> let foo :: Int -> Int; foo x = ... in ...
07:28:37 <wolfgangbeck> allbery_b: thx
07:28:54 <bd_> wolfgangbeck: you could fork a thread to use throwTo
07:29:15 <bd_> [in Control.Concurrent]
07:29:28 <wolfgangbeck> bd_: I'll have a look at it
07:32:20 <pjd> anyone have an idea about my earlier Eq question?
07:33:53 <pjd> Ord, even
07:34:21 <pjd> (why are Ord's comparison operations defined to make <= special, instead of circularly?)
07:34:31 <sipaliwini> where should I start looking if a C function invoked from haskell doesn't return the same thing depending on whether I redirect stdout to a file ?
07:34:42 <ski> (ookk : also see the comments under http://www.haskell.org/ghc/docs/latest/html/hslibs/Select.html#id296938)
07:34:44 <lambdabot> Title: 9.5. Select: Synchronous I/O multiplexing, http://tinyurl.com/tdtsh
07:36:36 <sipaliwini> also, why do printfs called within the C function get printed before putStrs that happen later in haskell ?
07:36:54 <sipaliwini> ouch sorry after
07:37:41 <sipaliwini> different buffering mechanisms or real execution order problems ?
07:39:01 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:39:03 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:39:04 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:39:04 <ski> i would guess buffering
07:39:08 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:39:19 <Botje> nok1z: no. fuck off.
07:39:19 <sipaliwini> ok
07:40:04 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:40:06 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:40:07 <nok1z> type this /server -m irc.quakenet.org -j redalert2
07:40:20 <psnl> who has ops these days?
07:40:38 --- mode: ChanServ set +o vincenz
07:40:40 --- kick: nok1z was kicked by vincenz (vincenz)
07:40:49 <vincenz> nok1z: stop spamming
07:40:55 <nok1z> big man
07:40:55 <psnl> go vincenz
07:40:59 <nok1z> u can kick
07:41:02 <nok1z> wow
07:41:17 --- mode: vincenz set +b *!*=RedAlert@*.in-addr.btopenworld.com
07:41:18 --- mode: ChanServ set +o shapr
07:41:19 --- kick: nok1z was kicked by vincenz (vincenz)
07:41:22 <shapr> thank you
07:41:25 * vincenz nods
07:41:30 --- mode: vincenz set -o vincenz
07:41:30 <Itkovian> hi shapr
07:41:34 <shapr> hoi Itkovian
07:41:43 <wolverian> I wonder how many people here typed that :)
07:41:54 <sipaliwini> hehe
07:42:03 <psykotic> hey guys, try pressing alt and f4 simultaneously! :)
07:42:04 <psykotic> hehe
07:42:10 -ChanServ(ChanServ@services.)- shapr!n=user@cs6625119-169.bham.res.rr.com ACCESS [#haskell] ADD psnl 39
07:42:17 <chessguy> 'morning haskellers
07:42:23 <Botje> hello, chessguy
07:42:24 <ookk> try pressing apple - Q :P
07:42:34 <chessguy> how goes
07:42:35 <norpan> another fun thing is to try the /disco command
07:42:41 <Botje> i'm wearing my java hat unfortunately :(
07:42:42 <shapr> psnl: You now have both the power and responsibility to kickban spammers :-)
07:42:47 <psnl> shapr: thanks, I guess
07:42:47 <chessguy> ewww.
07:42:57 <shapr> class Shapr throws ScreamingTantrum
07:43:11 <Nafai> Botje: Me, too.
07:43:36 <Botje> class Balmer extends Developer throws Chair
07:43:54 <ski> instance Operator Psnl
07:44:06 <vincenz> class Botje implements Developer extends Human throws Up
07:45:03 --- mode: shapr set -o shapr
07:45:42 <Botje> :)
07:45:51 -ChanServ(ChanServ@services.)- shapr!n=user@cs6625119-169.bham.res.rr.com ACCESS [#haskell] ADD sjanssen 39
07:46:24 -ChanServ(ChanServ@services.)- shapr!n=user@cs6625119-169.bham.res.rr.com ACCESS [#haskell] ADD arjanb 39
07:53:33 <paolino> can I use some construct to simplify
07:53:34 <paolino>     ps = concat ps'
07:53:34 <paolino>     (bs,ps') = unzip (map reposition cs)
07:53:34 <paolino> ?
07:55:59 <paolino> mmhh, pattern matching cannot invert uninvertible functions probably
07:57:14 <vincenz> concat . snd . unzip . map reposition $ cs
07:57:40 <paolino> I loos bs then
07:58:15 <fasta> (map reposition >>> unzip >>> snd >>> concat) cs (arrow style (yes, I know it's lame))
07:59:08 <fasta> paolino: it would help if you would provide a complete expression
07:59:22 <paolino> ok, I use that often, I was wondering if I could put the concat someway inside the pattern matching
07:59:57 <paolino> (bs, concat @ ) = .....
08:00:07 * paolino hides 
08:01:45 <paolino>     (bs,ps) = (id *** concat) >>> unzip (map reposition cs) ?
08:02:21 <fasta> @type (***)
08:02:23 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
08:03:12 <paolino> the other way around probably
08:03:46 <fasta> paolino: you need to put cs out of the map reposition expression
08:04:14 <paolino> ah
08:04:19 <ski> (bs,ps) = fmap concat (unzip (map reposition cs))
08:04:27 <ski> instance Functor ((,) a)
08:04:44 <ski> you could also use transformational pattern, i think
08:04:45 <fasta> ski: hmm, that's neat
08:06:02 <fasta> ski: I don't have that instance.
08:06:48 <ski> fasta : maybe it's in 'Control.Monad.Writer', not sure
08:06:55 <ski> > fmap (1+) (2,3)
08:06:57 <lambdabot>   add an instance declaration for (Functor ((,) a))
08:06:57 <lambdabot>     In the definition of ...
08:07:14 <paolino> ski , what transformational pattern is ?
08:08:19 <paolino> fmap concat would apply to both ?
08:08:59 <ski> paolino : hm, i don't recall if they implemented it in ghc or not .. with it one could write '(bs, ps ! concat) = unzip (map reposition cs)' (iirc syntax)
08:09:12 <paolino> ah
08:09:25 <paolino> that one I was looking for
08:09:39 * ski would prefer '(bs,inv concat ps) = unzip (map reposition cs)' or somesuch ..
08:10:00 <paolino> pattern matching for inversion
08:11:07 <ski> map f [                  ] = [  ]
08:11:08 <ski> map f (b ! f : bs ! map f) = b:bs
08:11:11 <pierre-> @where lambdabot
08:11:12 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
08:11:19 <ski> paolino : what would you like such ? :)
08:12:02 <paolino> map definition
08:12:24 <super> â¤´à§ÕÂº
08:12:32 <spiffy> @src map
08:12:33 <lambdabot> map _ []     = []
08:12:33 <lambdabot> map f (x:xs) = f x : map f xs
08:13:25 <paolino> anyway here it doesn't compile
08:17:38 <metaperl> paolino - are you xerox?
08:17:53 <paolino> I see some papers around, bu tnothing about implementation
08:18:20 <paolino> metaperl: when I reason I wish I was
08:18:37 <metaperl> I think xerox's name is paolino
08:18:51 <paolino> for the rest of time I'm happy be myself
08:19:00 <metaperl> lol
08:19:01 <paolino> yes it is
08:20:10 <vincenz> no
08:20:12 <vincenz> it's paolo
08:20:23 <paolino> my name anyway is not coming from my height
08:21:39 <paolino> some bad guys they called me like this to constraint my soul, I kept it as a lesson
08:23:55 <vincenz> seliopou: you do tai-chi?
08:24:04 <seliopou> I do not
08:24:07 * vincenz hmms
08:24:18 <vincenz> Your name is very similar to the name of a tai-chi stance :)
08:24:19 <metaperl> vincenz - why did you ask that?
08:24:25 <vincenz> And since I don't know how to write it, I asked
08:24:44 <vincenz> The pronounciation is more or less the same
08:27:07 <seliopou> the e is long
08:27:23 <vincenz> as it is in the tai-chi stance name
08:27:30 <seliopou> excellent :)
08:27:30 <vincenz> sihlio poo
08:27:42 * vincenz is reading pou in the french way :)
08:27:44 <pjd> vincenz: what's the translation of the name?
08:27:50 <paolino>  (bs,ps) = (id *** concat) $ unzip (map reposition cs)
08:28:09 <vincenz> pjd: you know chinese?
08:28:20 <seliopou> ?docs reposition
08:28:21 <lambdabot> reposition not available
08:28:29 <seliopou> whutz dat?
08:28:36 <pjd> vincenz: not to any significance, but i do tai chi :)
08:28:45 <vincenz> trying to remember :)
08:29:36 <vincenz> I guess bow and arrow
08:29:38 <vincenz> or false stance
08:29:44 <vincenz> can't remember
08:30:22 <pjd> ah, ok
08:30:23 <paolino> seliopou: it was an old thread
08:31:12 <vincenz> pjd: the stances we have are: horse, bow and arrow, rooster, cross-legged, false/empty, and one more
08:31:19 <vincenz> tier
08:31:21 <vincenz> tiger
08:31:54 <Tigge> what?
08:32:39 <pjd> ah! we pronounce it like sulibu
08:33:45 <seliopou> does anybody here have experience with yi?
08:33:51 <vincenz> pjd: that one yes
08:33:55 <vincenz> silly pooo
08:33:59 <pjd> 40-60 stance
08:34:04 <vincenz> if roughly translated
08:34:08 <vincenz> that's bow and arrow?
08:34:16 * vincenz thinks so
08:34:18 <pierre-> @users
08:34:19 <lambdabot> Maximum users seen in #haskell: 294, currently: 286 (97.3%), active: 45 (15.7%)
08:34:19 <wy> I'm writing a mark-scan garbage collector for a toy compiler. It's a bit strange that given different GC strategies, the number of cells collected is different. Is it normal in real systems?
08:34:33 <vincenz> no, it's not, bow and arrow is leaning forward, it's the other one
08:34:47 <vincenz> yeah, just called 40-60 :)
08:34:55 <chessguy> hmm, i thought we had cleared 300
08:35:00 <seliopou> wy: what are the different strategies?
08:35:01 <vincenz> @users
08:35:01 <lambdabot> Maximum users seen in #haskell: 294, currently: 286 (97.3%), active: 46 (16.1%)
08:35:16 <chessguy> didn't dons say that a few weeks ago?
08:35:33 <wy> seliopou: They are only different choices when to do the GC. All cells are fully marked in each GC.
08:35:53 <wy> seliopou: only different in time
08:37:10 <seliopou> That seems right, as reachability can change with time
08:38:25 <seliopou> > 294 / 45
08:38:29 <lambdabot>  6.533333333333333
08:38:31 <seliopou> er...
08:38:38 <wy> But why does the total number of collected cells differ?
08:38:39 <seliopou> > 45 / 294
08:38:41 <lambdabot>  0.15306122448979592
08:38:59 <seliopou> > 45 / 286
08:39:01 <lambdabot>  0.15734265734265734
08:39:12 <seliopou> At the end of the run you mean?
08:39:30 <wy> yes. at the end of an evaluation
08:40:02 <seliopou> Are you collecting at the end of every evaluation?
08:40:11 <qwr> hmm look log, yesterday lambdabot tell 304 maximum users seen
08:40:27 <seliopou> lambda bot totally lies
08:43:00 <ookk> why is there no util package in ghc 6.6? ghci -package util says "ghc-6.6: unknown package: util"
08:43:02 <mux> oh, my! I want my lambda revolution t-shirt
08:43:19 <wy> I collect after every certain number of allocations
08:44:15 <seliopou> so what changes in your strategies is the "every certain number"
08:44:30 <wy> yes
08:44:45 <paolino> generations fd cs = b@(generation fd cs) : generations fd b
08:44:46 <paolino> how do I write this in legal haskell ?
08:45:04 <vincenz> that doesn't make sense
08:45:21 <vincenz> generations fd cs = let b = generation fd cs in b:generations fd b
08:45:36 <seliopou> Ok, say there are 20 allocations in your program and each one immediately turns to garbage
08:45:37 * vincenz is speculating your intended meaning
08:45:56 <seliopou> In one strategy you collect every 5 allocations, and in another you collect every 6
08:45:57 <paolino> yes , that's the meaning
08:46:16 <wy> yes.
08:46:27 <vincenz> @pl let b = generation fd cs: generations fd b
08:46:27 <lambdabot> (line 1, column 43):
08:46:27 <lambdabot> unexpected end of input
08:46:27 <lambdabot> expecting variable, "(", operator, ":", "++", ";" or "in"
08:46:35 <seliopou> then in the first case you will collect every "cell" as you've been calling them
08:46:38 <vincenz> @pl let b = generation fd in cs: generations f b
08:46:38 <lambdabot> cs : generations f (generation fd)
08:46:49 <seliopou> in the second you will not collect the last two cells that you allocated
08:47:32 <vincenz> paolino: anyways, the sharing is not really that big of an issue, you don't have mutability so if you have a circular structure or not is observationally equivalent
08:47:39 <alexj__> @seen shapr
08:47:40 <lambdabot> shapr is in #scannedinavian, #unicycling, #haskell-blah and #haskell. I last heard shapr speak 1h 4m 44s ago.
08:47:54 <alexj__> shapr: yo
08:48:23 <alexj__> @seen dons
08:48:23 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 2h 47m 24s ago.
08:48:48 <metaperl> alexj__ - any comments about my link to that comment on XSLT?
08:49:28 <paolino> vincenz I do not understand what you asked lambdabot
08:49:51 <alexj__> metaperl.  I've been a bit delinquent on my mail.  I read it and planned to reply.  Hang on and let me answer it now.
08:50:25 <metaperl> yes - just answer to the Google group. not here.. no rush. just wondering
08:50:57 <vincenz> paolino: @pl
08:51:05 <vincenz> paolino: pointless, without internal variables
08:51:11 <wy> seliopou: I see. I need to do a GC at the end of the evaluation!
08:51:17 <vincenz> but I typoed the code
08:51:21 <vincenz> and then not to spam did it correctly in #oasis
08:51:55 <seliopou> If you want to make sure that you free up all the memory you can at the end of an evaluation, yes
08:52:18 <seliopou> Are you aware, though, that this isn't how most GCs work?
08:53:58 <wy> seliopou: I guess it's not. This is only a toy compiler though
08:54:11 <vincenz> runtime system you mean
08:54:28 <alexj__> metaperl: answered.  but as I was doing so I was not sure I understood your question.
08:54:34 <alexj__> if you want clarification let me know.
08:55:29 <metaperl> alexj__ - anyway, I am working on this style of dynamic HTML development. Please note the span tags in this html: http://pastebin.ca/304935  .. and then note lines 34-36 of this Haskell XML Toolbox code - http://rafb.net/p/L3oW8J40.html  ...
08:55:34 <paolino> vincenz: generations fd cs = cs:generations fd (generation fd cs)  ?
08:55:56 <vincenz> that was wrong
08:55:57 <wy> seliopou: How does advanced GCs work?
08:56:13 <vincenz> wy: generational copy collector
08:56:24 <metaperl> it keeps dynamic html generation with Haskell and not in an external language - HaskellDB on the backend and HXT on the front-end... it is based on my Perl module HTML::Seamstress which had a lot of functionality for dom-style dynamic html generation
08:57:02 <seliopou> I don't mean anything as complex as that vincenz
08:57:31 <vincenz> seliopou: then a simple copy collector
08:57:32 <alexj__> metaperl: the way happsis structured, you define ToElement for the result types of your handler functions.  You then style the resulting XML however you like in the XSLT.
08:58:00 <metaperl> I see
08:58:07 <seliopou> Every GC that I've run across waits until there is no free memory to either (a) collect, or (b) expand the heap
08:58:22 <alexj__> if you want to shift from HaXML to a different XML toolset, it is really straightforward.
08:58:26 <vincenz> seliopou: I know many that do some GC at allocation
08:58:28 <vincenz> well some
08:58:41 <vincenz> seliopou: ocaml's runtime system, does for instance, free a bit at each allocation afaik
08:58:45 <wy> vincenz: Thanks. I found it on wikipedia
08:58:52 <alexj__> take a look at the xml function in HAppS.Protocols.SimpleHTTP2
08:59:20 <vincenz> wy: look for "cheney"
08:59:32 <seliopou> There is a difference between some and the whole shebang
08:59:40 <alexj__> I mean xmlImpl.
08:59:47 <wy> vincenz:  I heard that LispWorks has a very advanced GC. Is that so today?
08:59:47 <alexj__> metaperl: do you see what I mean?
08:59:53 <metaperl> alexj__ - looking
09:00:03 <seliopou> Is the ocaml gc incremental?
09:00:04 <vincenz> wy: I fear I do not know lispworks
09:00:12 <vincenz> seliopou: most likely then
09:00:26 <alexj__> metaperl: this is the new HAppS.  If you are using the old code, you may want to upgrade.
09:00:44 <alexj__> the new happs gives you much more control over this sort of thing.
09:01:25 <seliopou> er.. rather I meant is it conservative?
09:01:28 <metaperl> alexj__ - i'm not using HaPPs. I was just touching base with my mentality on these sorts of things. I'm taking an HTML/CSS course now, so look forward to a redo of your webpages when I finish :)
09:01:44 <alexj__> :-)
09:02:00 <vincenz> seliopou: No, I do not think so
09:02:07 <alexj__> ok take a look at the example server code at the bottom of SimpleHTTP2
09:02:10 <vincenz> seliopou: I don't think it needs to be
09:02:50 <alexj__> eg this is what you are usig:  h "/status/"     GET   $ ok xml exampleGetVal
09:03:17 <alexj__> exampleGetVal has some type that the xml function converts to an XML output.
09:03:21 <vincenz> I wonder what kind of GC haskell has
09:03:44 <metaperl> alexj__ - it's ok man. XSLT is very hard for me to grok. and directory indexing is forbidden at happs.org so I'm d/ling it right now.. but dont waste your time on me.
09:04:06 <metaperl> alexj__ - talk to you later.
09:04:37 <alexj__> metaperl: http://happs.org/HAppS/src/HAppS/Protocols/SimpleHTTP2.hs
09:04:56 <metaperl> ok i'm there
09:05:05 <pierre-> alexj__: there's #happs chanell around
09:05:32 <alexj__> pierre: I didn't know that.  I am not a big IRCer.
09:05:36 <alexj__> thanks for the info!
09:07:11 <chr1s> I'm getting a cabal error, Unknown field "main-is"
09:07:29 <chr1s> would that be because my cabal's too old?
09:08:02 <sipaliwini> huhu, people were right not to answer, I suck
09:08:06 <sipaliwini> found the bug
09:09:18 <wy> vincenz: So cheney's is the "two space" GC
09:10:31 <paolino> is there an interruptable folding function ?
09:11:21 <mauke> yeah, foldr
09:11:38 <vincenz> wy: yep
09:11:45 <vincenz> wy: a simple copy-collector
09:12:02 <paolino> @type foldr
09:12:05 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
09:12:08 <lisppaste2> dmhouse annotated #34140 with "final generic delete" at http://paste.lisp.org/display/34140#7
09:12:24 <wy> vincenz: Is it better than mark-scan?
09:13:06 <dmhouse> ?tell apfelmus http://paste.lisp.org/display/34140#7 was my final sol'n.
09:13:07 <lambdabot> Consider it noted.
09:13:11 <paolino> mauke, where is the stop condition ?
09:13:17 <vincenz> wy: not familiar with mark-scan, how does it "free" memory to be reused?
09:13:41 <mauke> paolino: just have the function ignore its second argument
09:14:34 <wy> vincenz: It just put it into a "free" list
09:14:41 <vincenz> wy: oh right
09:14:50 <vincenz> wy: the advantage then is that basically you don't get fragmentation
09:14:54 <metaperl> @type const
09:14:56 <lambdabot> forall a b. a -> b -> a
09:14:56 <vincenz> wy: cause you compact your heap
09:14:59 <vincenz> with a cheney one
09:17:12 <wy> vincenz: Is two-space GCs still in use nowadays?
09:17:55 <vincenz> wy: not sure tbh
09:18:07 <vincenz> wy: seems like a simple enough system, without getting into the complexities of a generational one
09:24:13 <pejo> vincenz, ghc has a generational copying collector, Marlow has a paper about it on his homepage.
09:24:28 <vincenz> pejo: ah, thank you :)
09:25:26 <dmhouse> Why can't we have true existential types?
09:25:36 <dmhouse> Why do we have to wrap them in a data constructor?
09:25:54 <daniel_larsson> It's christmas?
09:28:10 <Syzygy-> If I want my function to bail out if one parameter is too small, what's a best way to do that?
09:28:20 <vincenz> Syzygy-: error
09:28:29 <Syzygy-> enumerate 2 = blah; enumerate n = recursion;
09:28:48 <Syzygy-> do I need to throw in an error case in the enumerate n or can I write a declaration of its ownfor that case?
09:28:57 <dmhouse> Syzygy-: bail out as in bring the program crashing down completely?
09:29:00 <vincenz> I was just kidding
09:29:03 <LPhas_> ?paste
09:29:04 <lambdabot> http://paste.lisp.org/new/haskell
09:29:17 <paolino> mauke: can you show me how to flodr this ?
09:29:17 <mauke> enumerate n | n < 2 = error "no bus no" | n == 2 = blah | otherwise = recursion
09:29:18 <paolino> converge sigma xs = let
09:29:18 <paolino>   check s [] = s
09:29:18 <paolino>   check s (x:[]) = s
09:29:18 <paolino>   check s (x:t@(y:_)) = if abs (x-y) < sigma then s else check (x:s) t
09:29:18 <paolino>   in
09:29:19 <vincenz> but yeah, hmm, bailing out of a recursive call would requrie some way sort of continuation
09:29:20 <paolino>   reverse $ check [] xs
09:29:40 <dmhouse> vincenz: or Maybe ;)
09:29:59 <vincenz> dmhouse: you still have to process them outwards
09:30:10 <dmhouse> Syzygy-: if it's a function that could fail, you've basically got two options. error, which issues a program wide error and stops execution (which is good for really exceptional cases, as it doesn't require you to change the type of your function), or Maybe.
09:30:13 <spiffy> well, im finally biting the bullet
09:30:18 * spiffy cracks open TAPL
09:30:19 <dmhouse> vincenz: yes, but it's do-able with continuations.
09:30:23 <dmhouse> spiffy: yay :)
09:30:24 <Syzygy-> Basically, I want to enumerate all binary trees with n leaves.
09:30:38 <Syzygy-> And if you ask for a binary tree without leaves, I want to call you an idiot.
09:30:42 <lisppaste2> LPhas pasted "hask-home doesn't work!" at http://paste.lisp.org/display/34164
09:30:43 <Syzygy-> Could do that with an empty list though
09:30:48 <dmhouse> Syzygy-: error, probably.
09:30:50 <vincenz> Syzygy-: list-monda
09:30:52 <vincenz> and fail
09:30:53 <spiffy> But I blame all of you for it coming to this, so expect some weird questions ;-)
09:30:53 <Syzygy-> Or if you ask for binary trees with negative numbers of leaves.
09:31:00 <vincenz> list-monad!!
09:31:01 <Syzygy-> Though empty list probably is the way to go.
09:31:05 <LPhas_> someone that knows hask-home could get an eye on my paste?
09:31:11 <mauke> paolino: sorry, I don't know how to foldr that
09:31:18 <LPhas_> i cannot manage to get an homepage for my lib
09:31:26 <LPhas_> and error message is not very illuminating
09:33:06 <ForumGoon120> so is a monad just a way of enforcing order of execution?
09:33:15 <dmhouse> Err
09:33:16 <vincenz> amongst other things
09:33:30 <vincenz> the identity monad for instance
09:33:31 <dmhouse> Yeah, if you like. I wouldn't say it's 'just' that, but okay.
09:33:33 <vincenz> but that's the simplest monad ever
09:33:45 <vincenz> no, the just monad introduces the concept of failure
09:33:47 <ForumGoon120> well what else is it besides a container?
09:33:49 <vincenz> erm, Maybe monad
09:34:02 <vincenz> ForumGoon120: nothing, a monad is just a container ;)
09:34:10 <vincenz> except that that concept has far-reaching consequences
09:34:13 <paolino> mhh
09:34:17 <ForumGoon120> like what?
09:34:24 <dmhouse> ForumGoon120: I'd say it's a way of capturing and making neater common properties of functions.
09:34:25 <vincenz> like you can build containers that enable failure
09:34:30 <vincenz> or containers that return multiple answers
09:34:41 <vincenz> or monads that carry along state transparently
09:34:43 <ForumGoon120> a container that returns multiple answers?
09:34:56 <ForumGoon120> isnt that the whole point of lists?
09:35:06 <allbery_b> lists *are* the containers he's talking about
09:35:12 <spiffy> and lists are a monad ;-)
09:35:29 <ForumGoon120> oh.. didnt know that
09:35:33 <dmhouse> ForumGoon120: I'd give http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html a read.
09:35:35 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
09:35:43 <Syzygy-> Booo-yah!
09:35:50 <ForumGoon120> haha nice :)
09:35:51 <vincenz> > do {x <- [1..5]; y <- [1..5]; return (x*y)}
09:35:52 <lambdabot>  [1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]
09:36:04 <Syzygy->     [Pair b b' | k <- [1..(n-1)], b <- enumerate k, b' <- enumerate (n-k)]
09:36:13 <Syzygy-> This ended up being my core list comprehension! Hah!
09:36:26 <Syzygy-> enumerate n being this for big enough n.
09:36:30 <vincenz> Syzygy-: cause of the nice list monad :)
09:36:34 <Syzygy-> Ayup!
09:36:42 <Syzygy-> Now to figure out how to write GraphML from Haskell.
09:37:10 <paolino> ForumGoon120: I suppose the best intuition depends on ones programming culture. I like "composition metaprogramming" as definition
09:37:25 <ndm> Syzygy-: i think a friend has already done that
09:37:28 <ndm> @where yam
09:37:29 <lambdabot> I know nothing about yam.
09:37:44 <ndm> @where+ yam http://www.cs.york.ac.uk/fp/darcs/yam
09:37:45 <lambdabot> Done.
09:38:11 <vincenz> ndm: now some peanut-butter
09:38:19 <vincenz> oh wait, that's jam
09:38:19 <ndm> Syzygy-: there might be a GraphML thingy in that, somewhere, although not sure
09:39:59 <glguy> hi d-rock
09:40:40 <paolino> ForumGoon120: and all the other definitions brought me somewhere far from understanding, but that's  me. I suppose anyone would disagree
09:41:20 <glguy> > [(a,b) | a <- [1..3], b <- [4,5]]
09:41:22 <lambdabot>  [(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
09:42:00 <Syzygy-> What I -really- want to write now is a bunch of vertices, and a function hasEdge :: Vertex -> Vertex -> Bool
09:42:06 <ForumGoon120> that blog has got me all confused.. i cant understand the syntax :(
09:42:07 <Syzygy-> And just get a GraphML-file out of it.
09:42:58 <spiffy> http://www.nomaware.com/monads/html/meet.html  is what started me out on understanding monads. That and actually using the State monad
09:42:59 <lambdabot> Title: Meet the Monads
09:44:04 <spiffy> O, and writing type signatures for my do-notation functions...and then thinking about what that really ment.
09:44:57 <spiffy> > :t do { return 1 }
09:44:58 <lambdabot>  Parse error
09:45:01 <spiffy> err
09:45:38 <paolino> @type return 1
09:45:41 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
09:45:56 <spiffy> thats the one.
09:48:52 <glguy> ?type (do{return 1})
09:48:54 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
09:49:01 <glguy> ^^ needs the parentheses
09:49:06 <glguy> HO
09:49:07 <glguy> oh
09:49:09 <glguy> you typed > :t
09:49:10 <glguy> nvm
09:49:34 <ForumGoon120> does haskell use lazy evaluation?
09:49:38 <glguy> :t do { return 1 }
09:49:40 <lambdabot> forall (m :: * -> *) a. (Monad m, Num a) => m a
09:49:40 <glguy> ForumGoon120: yes
09:49:50 <glguy> ForumGoon120: to be more specific it is "non-strict"
09:49:56 <ForumGoon120> non-strict?
09:50:22 <glguy> basically that most stuff is lazy
09:50:26 <spiffy> values arent computed until needed.
09:50:29 <glguy> but not as an absolute rule
09:50:48 <ForumGoon120> so they *could* be lazy but doesnt have to be?
09:51:02 <spiffy> usually they will be
09:51:05 <glguy> most everything is lazy by default
09:51:29 <glguy> it's like saying something is "non-negative" instead of saying postive beacause "positive" isn't inclusive enough
09:51:31 <ForumGoon120> cool... so you dont even have to do lambda lifting?
09:51:43 <glguy> ForumGoon120: watch:
09:51:51 <glguy> > True || (error "Not a bool")
09:51:53 <lambdabot>  True
09:51:58 <glguy> > False || (error "Not a bool")
09:52:00 <lambdabot>  Exception: Not a bool
09:52:10 <glguy> the error is only evaluated when it needs to be
09:52:15 <ForumGoon120> ah but the || operator is lazy in 99% of languages hehe
09:52:26 <mauke> > take 10 (map (^ 2) [1 ..])
09:52:28 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
09:52:41 <glguy> > length [error "not an element", error "also not"]
09:52:43 <lambdabot>  2
09:52:45 <mahogny> ForumGoon120, not strictly defined to be usually though. so in theory you programs might not always work on all implementations
09:52:56 <huschi_> i have installed haxml for ghc under linux. how can i also install it for hugs?
09:53:11 <huschi_> runhugs Setup.hs install doesn't work.
09:53:13 <ForumGoon120> ooh you have a haskell interpreter bot??
09:53:18 <glguy> ?bot
09:53:19 <lambdabot> :)
09:53:25 <ForumGoon120> True || False
09:53:31 <glguy> you need: "> "
09:53:37 <ForumGoon120> oh
09:53:39 <spiffy> @let fib = 1 : 1 : zipWith (+) fib (tail fib)
09:53:40 <lambdabot> Defined.
09:53:41 <ForumGoon120> > True || False
09:53:41 <glguy> think of #haskell has one big lhs file
09:53:43 <lambdabot>  True
09:53:46 <ForumGoon120> cool
09:53:46 <spiffy> >take 10 fib
09:53:51 <mauke> > fib
09:53:52 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:54:05 <Stinger_> I thought it was L.fib
09:54:13 <glguy> it used to be
09:54:19 <spiffy> lazy, infinite lists still scare me.
09:54:44 <spiffy> and I stick to copying them out of the wiki whenever a useful example comes up ;-)
09:55:01 <mauke> > sequence [fib, fullRange :: [Int]]
09:55:01 <lambdabot>  Couldn't match `Integer' against `Int'
09:55:43 <glguy> ?hoogle fullRange
09:55:44 <lambdabot> No matches found
09:55:50 <glguy> (did you just ?let that?)
09:56:04 <spiffy> ForumGoon120: learn to love lambdabot.
09:56:08 * glguy finds it: @let fullRange = [minBound :: Int .. maxBound]
09:56:20 <mauke> > fullRange :: [Char]
09:56:21 <lambdabot>  "\NUL\SOH\STX\ETX\EOT\ENQ\ACK\a\b\t\n\v\f\r\SO\SI\DLE\DC1\DC2\DC3\DC4\NAK\SY...
09:58:14 <ookk> where can i read more about Network.Socket ? I want to know more about what errors send can fail with
09:58:26 <Stinger_> > last fullRange :: Char
09:58:27 <lambdabot>  '\1114111'
09:58:59 <mauke> @docs Network.Socket
09:58:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html
09:59:23 <mauke> hah, great "docs"
09:59:35 <ookk> yeah that is the only information i can find
09:59:40 <ookk> and it just says the definition
09:59:50 <ookk> it just says send return an Int
09:59:59 <ookk> in C it returns -1 on an error
10:00:04 <ookk> and i try to catch that
10:00:08 <ookk> but it doesnt
10:01:57 <spiffy> does anyone know where to find "The CAML reference manual"?
10:04:48 <allbery_b> spiffy: presumably somewhere around inria.fr
10:05:08 <ookk> anyone has any experience with Network.Sockets?
10:05:35 <spiffy> im poking around without too much luck...ah well, not terribly important. Ill find it when i have more time
10:09:28 <mauke> spiffy: http://caml.inria.fr/pub/docs/manual-ocaml/manual008.html ?
10:09:29 <lambdabot> Title: The Objective Caml language
10:11:49 <ookk> is http://haskell.org/ghc/docs/latest/html/libraries/network/Network-Socket.html all there is??
10:11:51 <lambdabot> http://tinyurl.com/fkdb4
10:11:53 <spiffy> Im more looking for the spec for caml itself
10:12:10 <sieni> spec?
10:12:14 <ookk> it doesn't even say what some functions do
10:12:14 <sieni> lol
10:12:50 <mauke> spiffy: what spec?
10:13:45 <spiffy> err,sorry not the spec
10:14:08 <spiffy> too many things going on at once, afk for a bit
10:16:24 <ookk> anyone has an idea of what the arguments to throwSocketErrorIfMinus1_ are supposed to be?
10:16:39 <paolino> is it possible to couple a take n and takeWhile f so it stops when one of the two finishes ?
10:17:18 <ookk> takeWhile (condition) $ take n ?
10:17:22 <mauke> take n . takeWhile f
10:19:29 <lisppaste2> nmessenger pasted "Preventing bottom in a pure Slider Puzzle" at http://paste.lisp.org/display/34167
10:19:48 <paolino> mhh, it was not any complicate eh :P
10:20:28 <glguy> paolino: neither take nor takeWhile complain if they hit the end of a list before meeting their stopping condition
10:20:39 <glguy> > take 100 [1..4]
10:20:41 <lambdabot>  [1,2,3,4]
10:20:52 <glguy> > takeWhile (<100) [1..4]
10:20:54 <lambdabot>  [1,2,3,4]
10:21:26 <nmessenger> can anyone help me with my paste?
10:21:45 <ventonegro> wow, what a clueless guy: http://tratt.net/laurie/blog/entries/tail_call_optimization
10:21:46 <lambdabot> Title: Laurence Tratt's blog: Tail Call Optimization
10:22:05 <paolino> I see
10:25:49 <paolino> @src scanl
10:25:50 <lambdabot> scanl f q ls = q : case ls of
10:25:51 <lambdabot>     []   -> []
10:25:51 <lambdabot>     x:xs -> scanl f (f q x) xs
10:26:30 <lisppaste2> nmessenger annotated #34167 with "Show Puzzle instance, for convenience." at http://paste.lisp.org/display/34167#1
10:28:08 <nmessenger> Does anybody know how to make 'fromList [[1,2],[3]] = Nothing'?
10:31:37 <glguy> nmessenger: you'll have to be more specific about what you are trying to do
10:31:51 <glguy> unless fromList is from yoru code
10:31:56 <nmessenger> yep
10:31:58 <malsyned> glguy: it is
10:32:09 <nmessenger> http://paste.lisp.org/display/34167
10:32:54 <xic> any HAppS dudes here?
10:32:54 <malsyned> you could map ((== w) . length) across elems and then and it.
10:32:58 <twanvl> nmessenger: all ((==w) . length)?
10:33:19 <paolino> ?t uncurry
10:33:20 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
10:33:28 <paolino> @type uncurry
10:33:31 <lambdabot> forall c b a. (a -> b -> c) -> (a, b) -> c
10:33:46 <mbishop> @quote
10:33:47 <lambdabot> PaulGraham says: I get the impression that using [Haskell] would feel like reading a novel written by a literary critic.
10:33:58 <glguy> ?type elems
10:34:00 <lambdabot> forall e i. (Ix i) => Array i e -> [e]
10:34:09 <glguy> that's already a function (fyi)
10:34:12 <malsyned> nmessenger: I like twanvl's solution better than mine.  it's the same but shorter.
10:34:23 <glguy> but just compare the length of "elems" to the length you need
10:34:42 <vegai> PaulGraham: That's nothing compared to the feeling I get from using Arc!
10:35:09 <malsyned> so, fromList xs = if isValid p && all ((==w) . length) elems then...
10:35:12 <paolino> @type uncurry.(+)
10:35:15 <lambdabot> forall b c. (Num (b -> c)) => (b -> c) -> (b -> c, b) -> c
10:35:38 <glguy> malsyned: what if the list is too short, doesn't have h elements?
10:35:39 <paolino> @type uncurry (+)
10:35:41 <lambdabot> forall b. (Num b) => (b, b) -> b
10:36:10 <glguy> and shouldn't you check the length predicate before isValid?
10:36:31 <nmessenger> I should (||) isValid and the length check together, though, since evaluation order is undefined?
10:36:33 <malsyned> ug.  laziness still makes my brain twisty.  would reversing the sides of the && test be sufficient to prevent any attempt to evaluate listArray?
10:36:44 <glguy> nmessenger: the evaluation order is left ot right
10:36:45 <nmessenger> s/should/shouldn't/
10:37:18 <nmessenger> glguy, what?!  I thought order-of-operations was undefined in pure code?
10:37:31 <nmessenger> > True || undefined
10:37:33 <lambdabot>  True
10:37:35 <glguy> nmessenger: nope
10:37:40 <nmessenger> > undefined || True
10:37:41 <lambdabot>  Undefined
10:37:42 <glguy> ?src (||)
10:37:43 <lambdabot> True  || _ =  True
10:37:43 <lambdabot> False || x =  x
10:37:47 <glguy> that's why ^^
10:37:48 <nmessenger> blah
10:38:07 <glguy> it needs to know the first argument to know what to return
10:38:12 <qwr> > False || 42
10:38:13 <glguy> so ti has to evaluate it first
10:38:14 <lambdabot>   add an instance declaration for (Num Bool)
10:38:24 <nmessenger> thanks, guys
10:38:48 <glguy> > False || fromDynamic False (toDyn True)
10:38:50 <lambdabot>      The function `fromDynamic' is applied to two arguments,
10:38:50 <lambdabot>     but its type...
10:38:56 <glguy> > False || fromDyn False (toDyn True)
10:38:57 <lambdabot>  Couldn't match `Dynamic' against `Bool'
10:39:15 <glguy> > False || fromDyn (toDyn True) False
10:39:16 <lambdabot>  True
10:39:17 <glguy> > False || fromDyn (toDyn 1) False
10:39:19 <lambdabot>  Add a type signature
10:39:25 <glguy> > False || fromDyn (toDyn (1 :: Int)) False
10:39:27 <lambdabot>  False
10:39:32 <nmessenger> ?src toDyn
10:39:33 <lambdabot> toDyn v = Dynamic (typeOf v) (unsafeCoerce v)
10:39:41 <glguy> > False || fromDyn (toDyn (42 :: Int)) False -- for qwr
10:39:41 <nmessenger> ?src fromDyn
10:39:43 <lambdabot>  False
10:39:43 <lambdabot> fromDyn (Dynamic t v) def
10:39:43 <lambdabot>   | typeOf def == t = unsafeCoerce v
10:39:43 <lambdabot>   | otherwise       = def
10:39:59 <nmessenger> Cool!
10:40:48 <nmessenger> is typeOf cheap?
10:41:13 <glguy> dunno
10:41:16 <dmhouse> nmessenger: should be.
10:41:17 <malsyned> typeOf?!  I thought types weren't first-class values in Haskell.
10:41:25 <kpreid> > typeOf ""
10:41:27 <lambdabot>  [Char]
10:41:35 <nmessenger> > typeOf negate
10:41:36 <lambdabot>  Add a type signature
10:41:42 <kpreid> > typeOf ord
10:41:42 <vegai> @type typeOf
10:41:43 <allbery_b> ?doc Data.Typeable
10:41:43 <glguy> can't be polymorphic
10:41:43 <dmhouse> nmessenger: has to be monomorphic.
10:41:44 <lambdabot>  Char -> Int
10:41:45 <lambdabot> forall a. (Typeable a) => a -> TypeRep
10:41:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
10:41:57 <nmessenger> dmhouse, yes, LB told me that :P
10:42:00 <kpreid> malsyned: it's just a library!
10:42:06 <dmhouse> malsyned: this is a kind of tucked-away corner of Haskell.
10:42:13 <dmhouse> The basic premise is really simple:
10:42:15 <kpreid> malsyned: well, a library with deriving support in the compiler, but.
10:42:17 <glguy> > typeOf (ord :: Char -> Int)
10:42:20 <lambdabot>  Char -> Int
10:42:21 <pierre-> > typeOf typeOf
10:42:22 <dmhouse> class Typeable t where typeOf :: t -> TypeRep.
10:42:22 <lambdabot>  Add a type signature
10:42:35 <kpreid> dmhouse: and cast
10:42:41 <kpreid> @type cast
10:42:43 <lambdabot> forall b a. (Typeable b, Typeable a) => a -> Maybe b
10:42:51 <malsyned> is typeOf standard Haskell, or a GHC extension?
10:42:53 <dmhouse> Yeah, from there you get the typesafe 'cast' function.
10:42:58 <dmhouse> malsyned: standard Haskell.
10:43:02 <dmhouse> malsyned: well, ish.
10:43:17 <Cale> It's not defined by the standard, but it's written using standard things
10:43:17 <dmhouse> TypeRep is a magically extensible datatype, but the rest is just type classes.
10:43:20 <vegai> That looks like heresy or something.
10:43:33 <nmessenger> ?instances Typeable
10:43:33 <malsyned> seriously.  delicious heresy, but still.
10:43:34 <lambdabot> Couldn't find class `Typeable'. Try @instances-importing
10:43:48 <dmhouse> ?instances-importing Data.Typeable Typeable
10:43:49 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering, RealWorld, TyCon, TypeRep, s a
10:43:54 <Cale> Note, typesafe cast
10:43:55 <nmessenger> vegai, all one must do is instantiate Typeable
10:44:01 <dmhouse> > typeOf (typeOf True)
10:44:02 <lambdabot>  TypeRep
10:44:10 <dmhouse> vegai: or indeed derive it.
10:44:36 <vegai> fascinating.
10:44:37 <glguy> > fromDynamic $ dynApp (toDyn (ord :: Char -> Int)) (toDyn 'a') :: Maybe Int
10:44:39 <lambdabot>  Just 97
10:44:41 <nmessenger> is there a ?methods ClassName ?
10:44:48 <nmessenger> 'cause there should be.
10:44:55 <dmhouse> vegai: it's used in things like Data.Dynamics and Data.Generics.
10:44:58 <dmhouse> nmessenger: write it! :)
10:45:14 <vegai> So, as Haskell is the best imperative language, it is also the best dynamically typed language?
10:45:20 <nmessenger> totally
10:45:23 <dmhouse> nmessenger: my Instances.hs plugin should get you started.
10:45:24 <nmessenger> it's typesafe!
10:45:29 <glguy> ?src Either >>=
10:45:30 <lambdabot> Left  l >>= _ = Left l
10:45:31 <lambdabot> Right r >>= k = k r
10:45:37 <vegai> Oh, and I forgot best OOP language.
10:45:43 <glguy> ?src Maybe >>=
10:45:44 <lambdabot> Source for this function is not available.
10:46:16 <malsyned> is it possible to write new classes which are derivable?
10:46:39 * nmessenger is too scared to compile LB.  He uses Windows, LB depends on zlib, compiling on Windows is scary, etc.
10:46:41 <dmhouse> malsyned: no.
10:46:53 <dmhouse> Eww, Windows.
10:47:03 <glguy> technically, all the existing derivable classes are written in Haskell, right?
10:47:08 <glguy> (GHC is Haskell)
10:47:32 <dmhouse> glguy: technically, yes.
10:47:44 <glguy> but not without changing the compiler :)
10:47:54 <dmhouse> You still can't write new classes deriveable in GHC.
10:48:17 <dmhouse> You can write a compiler and make your classes deriveable in that, but not in GHC.
10:48:29 <chr1s> how do I read the contents of a list of filenames?
10:48:43 <dmhouse> chr1s: use getContents on each one.
10:48:50 <chr1s> I was thinking something like map `liftM` readFile r
10:48:58 <dmhouse> Yeah, almost.
10:49:01 <dmhouse> ?hoogle mapM
10:49:02 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
10:49:02 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
10:49:02 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
10:49:02 <kpreid> what you're looking for is mapM
10:49:04 <chr1s> that obviously doesn't work
10:49:04 <dmhouse> You've got the right idea though.
10:49:06 <chr1s> ok, cool
10:49:19 <dmhouse> ?src mapM
10:49:20 <lambdabot> mapM f as = sequence (map f as)
10:49:28 <kpreid> ?type sequence
10:49:30 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
10:49:31 <dmhouse> sequence takes a list of actions and executes them.
10:49:38 <chr1s> why doesn't map `liftM` work?
10:49:51 <kpreid> @type (map `liftM`)
10:49:53 <lambdabot> forall a b (m :: * -> *). (Monad m) => m (a -> b) -> m ([a] -> [b])
10:50:22 <kpreid> because by liftMing map, you get something that wants a function in the monad
10:50:26 <kpreid> it's just wrong
10:50:26 <glguy> ?type mapM readFile
10:50:28 <lambdabot> [FilePath] -> IO [String]
10:50:29 <apfelmus> @paste
10:50:30 <lambdabot> http://paste.lisp.org/new/haskell
10:50:32 <chr1s> ok
10:50:58 <chessguy_work> > mapM (*2) [1 2 3 4]
10:51:00 <lambdabot>   add an instance declaration for (Show (m [b]))
10:51:00 <dmhouse> apfelmus: say something that isn't a command to lambdabot.
10:51:11 <chr1s> thanks
10:51:16 <glguy> > mapM (\x -> [x,2*x]) [1..4]
10:51:19 <lambdabot>  [[1,2,3,4],[1,2,3,8],[1,2,6,4],[1,2,6,8],[1,4,3,4],[1,4,3,8],[1,4,6,4],[1,4,...
10:51:26 <apfelmus> dmhouse: huh?
10:51:27 <lambdabot> apfelmus: You have 1 new message. '/msg lambdabot @messages' to read it.
10:51:36 <dmhouse> apfelmus: there we go. :)
10:51:55 <chessguy_work> cute
10:51:58 <glguy> > mapM (*) [1..4] 5
10:52:00 <lambdabot>  [5,10,15,20]
10:52:02 <glguy> oh oh it's magic, you know
10:52:26 <glguy> </end singing>
10:52:45 * chessguy_work thanks goodness
10:53:31 <glguy> I guess the end was a bit redundant
10:53:47 <kpreid> hmmm
10:54:01 <kpreid> > sequence [(+1), (+2), (+3)]
10:54:03 <lambdabot>  Add a type signature
10:54:10 <glguy> > sequence [(+1), (+2), (+3)] 5
10:54:10 <kpreid> > sequence [(+1), (+2), (+3)] (10::Int)
10:54:12 <lambdabot>  [6,7,8]
10:54:13 <lambdabot>  [11,12,13]
10:54:16 <dmhouse> How do you pronounce things like '</signing>'? I've always said 'end signing', but I guess I may be in the minority there.
10:54:27 <kpreid> > map ($10) [(+1), (+2), (+3)]
10:54:29 <lambdabot>  [11,12,13]
10:54:32 <glguy> close signing or end signing works for me
10:54:49 <nmessenger> dmhouse, I usually say 'slash-singing'
10:55:00 <glguy> kpreid: bah, you are repeating the + too many times:
10:55:09 <glguy> > mapM (+) [1..3] 10
10:55:12 <lambdabot>  [11,12,13]
10:55:24 <Jaak> > map (10 $) $ map (flip (+)) [1..]
10:55:25 <lambdabot>   add an instance declaration for (Num ((a -> a) -> b))
10:55:30 * nmessenger struggles to understand that
10:55:31 <Syzygy-> ?index nub
10:55:31 <Jaak> mm
10:55:32 <lambdabot> Data.List
10:55:45 <dmhouse> nmessenger: it's all about the instance Monad ((->) a).
10:55:46 <lisppaste2> apfelmus annotated #34140 with "generic Maps" at http://paste.lisp.org/display/34140#8
10:55:47 <kpreid> remind me what that definition of 'swing' was?
10:55:49 <dmhouse> You can do funky things like that.
10:55:54 <glguy> > map ($ 10) $ map (+) [1..]
10:55:56 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
10:55:59 <dmhouse> kpreid: really, really weird.
10:56:04 <bd_> > [ x + 10 | x <- [1..3]]
10:56:05 <lambdabot>  [11,12,13]
10:56:16 <chessguy_work> ?src swing
10:56:17 <lambdabot> Source for this function is not available.
10:56:21 <chessguy_work> pft
10:56:21 <Jaak> oh
10:56:25 * chessguy_work breaks out the slapping rod and looks sternly at lambdabot
10:56:26 <Jaak> > map ($ 10) $ map (flip (+)) [1..]
10:56:28 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
10:56:28 <glguy> bd_: boring code can be typed in GHCi ;)
10:56:35 <bd_> bah
10:57:21 <Syzygy-> Wtf. I have 'import Data.List' at the beginning of my module, but yet nub isn't defined when I load it into GHCi.
10:57:23 <glguy> ?pl flip (+) -- is commutative, what's this flip business
10:57:24 <lambdabot> (+)
10:57:34 <glguy> ?index nub
10:57:35 <lambdabot> Data.List
10:57:54 <paolino> glguy , how I dinstinct with Either which condition (take  or takeWhile) won ?
10:58:32 <glguy> paolino: you don't?
10:58:41 * monochrom is back to wreak havoc!
10:58:52 <glguy> paolino: you'd have to write a different version of each that announced when it reached its goal
10:58:52 <dmhouse> apfelmus: fromJust . delete k is the generic delete, then?
10:59:03 * nmessenger throws some havoc at monochrom to wreak upon
10:59:20 <dmhouse> apfelmus: why bother with a Maybe codomain for delete? The usual delete semantics for a nonexistant member are to just return the original map.
10:59:59 <apfelmus> dmhouse: yes. it's a minor glitch because I want the base case (instance Map () m m).
11:00:24 <paolino> glguy but they should stop each other
11:00:49 <apfelmus> so every type can be thought of as a "set which stores itself". so you have to delete yourself out of yourself...
11:00:54 <monochrom> Most of the time when I want to delete, I don't want to know if the key exists.
11:01:30 <dmhouse> apfelmus: yeah, makes sense. It's nice. :)
11:02:18 <apfelmus> dmhouse: yes. it took me a while to realize that Forum and Topic and so on are just nested Map-types, i.e. Forum ~= Map k1 (Map k2 a)
11:02:29 <nmessenger> apfelmus, that sounds philosophical
11:02:55 <dmhouse> apfelmus: mine has the advantage that it allows me to store Posts in a Seq rather than a Map, but yours sure looks simpler :)
11:03:29 <apfelmus> you have the basic
11:03:29 <apfelmus>    delete :: Ord key => key -> Map key a -> Map key a
11:03:30 <apfelmus> and the only thing you want is to lift this harmless function to a nesting.
11:04:48 <paolino> bbl
11:05:26 <dmhouse> Hrm. If Map k1 (Map k2 a) ~= Map (k1, k2) a, shouldn't there be a generic instance something like instance (Map m k1 a, Map m k2 a) => Map m (k1, k2) a
11:05:31 <apfelmus> dmhouse: yes, Seq is more natural. and it's actually a good idea to split the delete fucntion into an extra class because the delete function doesn't mention the type a. the code i posted needs -fallow-undecidable-instances. maybe this can be remedied by splitting delete out, because one can then kick out the functional dependency.
11:06:58 <glguy> fundeps are needed when none of the functions in a typeclass refer to one of the type variables in the instance?
11:07:05 <apfelmus> dmhouse: no, the instance must read (Map m (Either k1 k2) a) because you can access elements in m either with keys of type k1 or with keys of type k2.
11:07:23 <dmhouse> glguy: they're needed most of the time when dealing with MPTCs.
11:07:30 <dmhouse> apfelmus: oh, true.
11:08:03 <dmhouse> apfelmus: I suppose you could just write an instance Map (Seq a) Int a, which would allow me to use Seqs with your stuff.
11:09:11 <apfelmus> dmhouse: yes, that should work. but i still recommend to split the deletable class out. kicking out the functional dependency makes the library more portable (Haskell').
11:09:43 <monochrom> fundeps are judgement calls
11:10:10 <apfelmus> a drawback of my approach is that you have to present Forum and Topic as functors, but that should not be the problem
11:10:11 <dmhouse> apfelmus: what, no fundeps in Haskell'?
11:10:33 <pierre-> is there any IOList library? just like IOArray, but not fixed size
11:10:47 <glguy> fundeps and funrollloops always sound so enjoyable
11:11:14 <apfelmus> while fundeps can be put to work, they are very difficult to implement right. so the commitees is looking for a simpler alternative
11:11:58 <apfelmus> it's no good if the Haskell' report takes 20 pages only to explain what the semantics of fundeps are.
11:12:12 <dmhouse> That's interesting.
11:12:24 <glguy> what is the alternative?
11:12:27 <malsyned> Is paste.lisp.org down for everybody?
11:12:29 <wilx`> Hm...
11:12:38 <wilx`> I don't think that is wrong...
11:12:48 <nmessenger> malebria, it'll probably be up in a minute
11:13:02 <wilx`> Sometimes complete but complex thing is better than dumbed down version :/
11:13:07 <apfelmus> glguy: one doesn't know. maybe assoiciated types
11:13:25 <sjanssen> pierre-: a library that provides growable arrays: http://www.haskell.org/haskellwiki/Library/ArrayRef#Using_dynamic_.28resizable.29_arrays
11:13:27 <apfelmus> *associated types
11:13:28 <lambdabot> Title: Library/ArrayRef - HaskellWiki, http://tinyurl.com/ycskov
11:15:18 <apfelmus> wilx: complex means complex to implement means compiler monopole.
11:15:31 <nmessenger> malebria, it's up now.
11:15:42 <dmhouse> apfelmus: that would delay the release date for Haskell' considerably, no? An open-ended search for a technology we still need to find, discuss, implement, test and make idiomatic?
11:16:46 <pierre-> sjanssen: oh, thank you
11:17:23 <wilx> apfelmus, there already is a implementation of fun deps in GHC, isn't there?
11:17:35 <wilx> And GHC is GPL licensed, is it not?
11:17:39 <wilx> So what's the deal?
11:17:41 <apfelmus> dmhouse yes. as far as i can remember, the Haskell' had a timeline. it looks like it was deleted because it's long overdue...
11:18:20 <dmhouse> wilx: you can't exactly cut-and-paste large portions of one project into another.
11:18:29 <sjanssen> I think Haskell' ought to have a story on either fundeps or ATs
11:18:43 <apfelmus> wilx: ghc is BSD3 i think.
11:18:50 <malsyned> can someone have a look at my paste and help me untangle my typing troubles?
11:18:50 <wilx> Even better.
11:19:06 <wilx> dmhouse, well, that depends on how well is the code written :)
11:19:07 <malsyned> except hang on, it didn't paste right.
11:19:35 <apfelmus> sjanssen: yes, some form of multi parameter type classes just must go in.
11:19:38 <twodogsandacat> hi all, has anybody installed WASH recently?
11:19:49 <monochrom> heh yeah what paste? :D
11:19:51 <lisppaste2> malsyned pasted "shufrep.hs with a typing error in it" at http://paste.lisp.org/display/34175
11:20:15 <apfelmus> wilx: well, hehe, you can look up yourself. tell me if you find it well written :D
11:20:25 <sjanssen> apfelmus: and MPTCs are nearly useless without fundeps
11:20:31 <lisppaste2> malsyned annotated #34175 with "Type error received" at http://paste.lisp.org/display/34175#1
11:21:04 <apfelmus> sjanssen: well, you can plug all but one of the multiple parameters into an associated type.
11:21:25 <sjanssen> right
11:21:33 <monochrom> malsyned: I don't get a type error.  I'm using ghc 6.6, ghci.
11:21:35 <sjanssen> in most cases, at least
11:21:59 <malsyned> oh, I'm using 6.4.2, that could have something to do with it.
11:22:01 <sjanssen> ie, cases where the fundep is t -> t_1 .. t_n
11:22:09 <apfelmus> sjanssen: sure. and that's exactly the problem :)
11:22:13 <glguy> ATs are supported in 6.[78] at the earliest?
11:22:31 <monochrom> Move {-# OPTIONS_GHC -fno-monomorphism-restriction #-} to the absolute top, see if that helps. (I am not sure.)
11:22:34 <sjanssen> glguy: I'd say so
11:22:57 <apfelmus> glguy: i don't know but i think they're already growing in HEAD. the haskellwiki has more info on that.
11:22:59 <malsyned> monochrom: yeah, that worked.
11:23:04 <glguy> ok
11:23:37 <monochrom> ghc 6.6 probably relaxes requirements for the placement of OPTIONS_GHC.
11:23:44 <malsyned> so, the monomorphism restriction can be gotten around by supplying explicit type declarations, right?
11:23:57 <dmhouse> malsyned: yep.
11:24:10 <monochrom> Yes.
11:24:33 <malsyned> is it reasonable to just use ghci's :type command with the restriction turned off in order to generate those declarations?
11:24:54 <monochrom> Yes, that's a lazy way :D
11:25:04 <sjanssen> malsyned: yes, you could do that
11:25:10 <malsyned> well, Haskell is a lazy language :-P
11:25:30 <sjanssen> malsyned: and if you use vim, there's a fancy little script to automate that process
11:25:38 <malsyned> Nothing for emacs?
11:25:51 <shapr> automate what?
11:25:59 <malsyned> btw, now that I've got that paste up, I'd be delighted if someone could comment on the quality of the code.  I'm pretty new to Haskell.
11:26:02 <nmessenger> shapr, type annotating
11:26:27 <sjanssen> shapr: dons has a little vim script that grabs the name the cursor is on and paste it's type sig
11:26:47 <shapr> Hm, wouldn't be too hard to hack up.. but I don't have time to do it today.
11:27:08 <shapr> You could steal the haskell-doc code to do it.
11:27:47 <sjanssen> shapr: the code to get the actual type signature is a standalone executable
11:27:55 <monochrom> It's short, therefore it must be good. :)  At certain places I would use the do-notation, which is longer but also more user-friendly.
11:28:09 <sjanssen> so all you have to write is the hook to call the program and yank the output
11:28:16 <monochrom> I use >>= when I'm lazy.
11:28:42 <glguy> if the whole thing can be written using >>= and >> without lambda expresions, I just >>= and >>
11:28:53 <nmessenger> I like (=<<) 'cause it works like a monadic ($)
11:29:06 <glguy> I use =<< when I have (.) in teh same line
11:29:13 <glguy> a =<< b . c =<< d
11:29:26 <glguy> so that everything flows one way
11:29:37 <nmessenger> yep
11:29:45 <monochrom> d >>= c >>> b >>= a   :D
11:29:45 <malsyned> Yeah, I'm still trying to make up my mind about do notation.  I thought it was great right up until a decent understanding of monads snapped into my brain, at which point I started realizing the functional-style implementation before I had worked out the do notation version.
11:30:19 <monochrom> True, if there are just two or three actions in sequence, just >>= them.
11:30:33 <glguy> ?type \a b c d -> d >>= c >>> b >>= a
11:30:36 <lambdabot>     precedence parsing error
11:30:36 <lambdabot>         cannot mix `(>>=)' [infixl 1] and `(>>>)' [infixr 1] in the same infix expression
11:30:41 <nmessenger> malsyned, do-notation confused me at first, but now that I'm more comfortable with its translation, I find it handy.
11:30:47 <glguy> ?type \a b c d -> d >>= c . b >>= a
11:30:49 <lambdabot> forall (m :: * -> *) a b b1 b2. (Monad m) => (b1 -> m b2) -> (a -> b) -> (b -> m b1) -> m a -> m b2
11:31:00 <malsyned> I think I ought to have used the State monad for the random number stream, rather than the (drop result rands) in 'tests', but I haven't bothered to grok the state monad yet.
11:31:00 <kzm_> I'm not sure I'd like to use >>= with conditionals.
11:31:12 <monochrom> It sounds like I made the right decision in introducing >>= before do.
11:31:22 <nmessenger> ?type \a b c d -> d >>= (c >>> b) >>= a
11:31:24 <lambdabot> forall (m :: * -> *) a c b b1. (Monad m) => (b -> m b1) -> (c -> m b) -> (a -> c) -> m a -> m b1
11:31:26 <shapr> sigfpe_: hiya!
11:31:41 <malsyned> Well this is interesting.  If I paste in the generated type signatures and then remove the monomorphism restriction, that same type error comes back.
11:32:04 <nmessenger> > typeOf (\a b c d -> d >>= (c >>> b) >>= a) == typeOf (\a b c d -> a =<< b . c =<< d)
11:32:05 <lambdabot>  Add a type signature
11:32:11 <nmessenger> :)
11:32:34 <dmhouse> sigfpe_: hey, wow, nice to see you in here, avid reader of your blog :)
11:32:59 <shapr> @quote sigfpe
11:33:00 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
11:33:00 <lambdabot> thing is.
11:33:13 <nmessenger> :D
11:33:14 <malsyned> monochrom: introduced >>= before do in what?
11:33:20 <glguy> ?type \a b c d -> runKleisli  (Kleisli a >>> pure (b >>> c) >>> Kleisli d)
11:33:22 <lambdabot> forall a b c (m :: * -> *) a1 b1. (Arrow (Kleisli m)) => (a -> m b) -> (b -> c) -> (c -> a1) -> (a1 -> m b1) -> a -> m b1
11:33:34 <monochrom> in some introduction I wrote recently.
11:33:42 <glguy> (not exactly the same, I know
11:33:54 <shapr> @users #haskell
11:33:55 <lambdabot> Maximum users seen in #haskell: 296, currently: 296 (100.0%), active: 54 (18.2%)
11:34:10 <nmessenger> glguy, semantically equivalent?
11:34:50 * nmessenger doesn't know what a Kleisli is.
11:34:56 <glguy> ?type \a b c d -> runKleisli  (Kleisli a >>> pure b >>> Kleisli (c >>> d)) -- this is almost the same, but it gives a an argument first
11:34:58 <lambdabot> forall a b (m :: * -> *) a1 b1 c. (Arrow (Kleisli m)) => (a -> m b) -> (b -> a1) -> (a1 -> c) -> (c -> m b1) -> a -> m b1
11:36:07 <glguy> ?type \a b c d -> runKleisli  (Kleisli (const a) >>> Klesli (b >>> c) >>> Kleisli d)
11:36:09 <lambdabot> Not in scope: data constructor `Klesli'
11:36:11 <monochrom> malsyned: do you also annotate things like "len :: (Num a) => a" ?
11:36:15 <glguy> ?type \a b c d -> runKleisli  (Kleisli (const a) >>> Kleisli (b >>> c) >>> Kleisli d)
11:36:17 <lambdabot> forall a a1 c (m :: * -> *) a2 b. (Arrow (Kleisli m)) => m a1 -> (a1 -> c) -> (c -> m a2) -> (a2 -> m b) -> a -> m b
11:36:44 <glguy> ?type \a b c d -> runKleisli  (Kleisli (const a) >>> Kleisli (b >>> c) >>> Kleisli d) undefined -- now it's the same, i don't know if there is a better way to deal with not using the run parameter
11:36:47 <lambdabot> forall a c (m :: * -> *) a1 b. (Arrow (Kleisli m)) => m a -> (a -> c) -> (c -> m a1) -> (a1 -> m b) -> m b
11:37:15 <nmessenger> undefined is a useful hammer :)
11:37:20 <glguy> a Kleisli arrow is a wrapped monad
11:37:24 <glguy> wrapped to be an arrow
11:38:01 <seliopou> ?docs Kleisli
11:38:02 <lambdabot> Kleisli not available
11:38:09 <seliopou> ?docs Arrow
11:38:11 <lambdabot> Arrow not available
11:38:12 <nmessenger> ?. docs index Kleisli
11:38:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:38:20 <malsyned> monochrom: oh, no I didn't.  Is the actual type of len and iter affecting the type inferences of the functions they are passed to via main?
11:38:31 <seliopou> ?docs Control.Arrow
11:38:32 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
11:38:47 <glguy> > runKleisli (Kleisli (\x -> [x+1,x+2]) >>> Kleisli (\x -> [x+2,x+4])) 1
11:38:50 <lambdabot>  [4,6,5,7]
11:38:54 <glguy> like using concatMaps
11:39:01 <glguy> for the list monad
11:39:07 <monochrom> Yes, they may be fixed as Integer.  That will look bad when you try to /
11:40:14 <malsyned> I added Num a => a to len and iter, to no avail.
11:40:25 <dmhouse> Is polymorphic recursion in H98?
11:40:28 <shapr> @seen yaxu
11:40:29 <lambdabot> I haven't seen yaxu.
11:40:31 <malsyned> tracking down type errors in long programs is tricky.
11:40:32 <shapr> hmm
11:40:49 <malsyned> is there any way to get ghc to dump some progress info while it's inferring?
11:40:52 <dmhouse> malsyned: you'll get better at it with practise.
11:41:30 * nmessenger wishes that ghci would load well-typed definitions even if there are ill-typed one.
11:41:32 <Igloo> malsyned: There are various -ddump-* options, but I'm not sure there's one for actually inferring
11:41:40 <Igloo> malsyned: -v9 is also very verbose
11:41:40 <nmessenger> *ones
11:42:18 <monochrom> Oh, I see.  In "tests", there is a local "result", and it is monomorphic now.  You need a type signature for that too.
11:42:40 <monochrom> Ha this is great, now I have to do that manually.
11:43:35 <malsyned> The monomorphism restriction isn't limited to top-level variables?
11:43:52 <glguy> malsyned: nope
11:44:05 <glguy> malsyned: anything that doesn't take arguments
11:44:14 <glguy> is eligible
11:44:33 <malsyned> oh!  man, that takes a lot of the fun out of building functions by composition.
11:44:35 <shapr> @quote sigfpe
11:44:36 <lambdabot> sigfpe says: Haskell is so strict about type safety that randomly generated snippets of code that successfully typecheck are likely to do something useful, even if you've no idea what that useful
11:44:36 <lambdabot> thing is.
11:45:01 <monochrom> The restriction applies to all definitions.  Actually it was designed with local ones in mind.
11:45:16 <monochrom> result :: (Num b, Enum b) => b    -- this will work.
11:45:42 <malsyned> What's its purpose?  Does it prevent potential infinite looping in the compilation process or something?
11:45:58 <monochrom> No, it prevents some situations of slow code.
11:46:03 <nmessenger> the inferrer can't *infer* polymorphic types, but the typesystem doesn't *prevent* them, AFAIK.
11:46:41 <monochrom> With too much polymorphisms, some CSE opportunities are lost.  That's all.
11:46:53 <nmessenger> ?define CSE
11:46:55 <lambdabot> Undefined.
11:47:02 <nmessenger> oops
11:47:07 <monochrom> common-subexpression elimination
11:47:10 <nmessenger> ah
11:47:22 <malsyned> ah.  this is why "proper" Ocaml style doesn't require as many type declarations?  because no polymorphic types?
11:47:23 <nmessenger> funny that @define corrects to @undefine
11:47:39 <monochrom> Sorry I though everyone knew code optimization jargons, since everyone indicates he/she is keen on PERFORMANCE.
11:47:51 <nmessenger> OCaml doesn't have polymorphic types?!
11:48:23 <malsyned> I don't think so.  Unless I got distracted by how cool Haskell was before I learned about them.  I was under the impression that that was one of the big differences between the type systems of the two.
11:48:32 <malsyned> anyone more knowledgeable to set the record straight?
11:48:37 <emu> ML type system is prenex polymorphism based
11:48:41 <monochrom> OCaml imposes a monomorphism restriction too.  This time it is because full polymorphism fixed with mutable variables is unsound.
11:48:59 <emu> well i can't speak about ocaml since i never bothered that much with that specific ml
11:49:03 <nmessenger> mutation! yuck!
11:49:07 <monochrom> s/fixed/mixed/
11:49:21 <malsyned> emu: nah, you're probably right.
11:50:33 <monochrom> My advice for shufrep.hs is actually less polymorphism, not more.  You can safely fix the types of certain things appropriately.
11:51:26 <monochrom> Also, you can probably fix "len" and "iters" as Int or Integer, and then at use sites use "fromIntegral len" etc. when you want to divide.
11:51:46 <malsyned> monochrom: yeah, you're probably right.  I do know the types on a lot of these things.  I've gotten into the habit of using -fno-monomorphism-restriction while writing the code, then going back and fixing the types later.
11:52:14 <emu> i almost never run into the monomorphism restriction. what are you doing so much of?
11:53:10 <malsyned> emu: short answer: floating-point division.  Long answer: among other things, building functions by composition, so that most of my function definitions don't have argument lists.
11:53:21 * xic ran into the monomorphism restriction when he was a newbie, and was totally baffled
11:53:37 * malsyned is a newbie, is pretty baffled himself
11:53:58 <xic> are they going to remove the monomorphism restriction in haskell'?
11:54:12 <glguy> it's there as a safety measure for you
11:54:16 * nmessenger did too, when using a top-level pattern bind to alias several functions
11:54:22 <glguy> not as a technical restriction...
11:55:17 <monochrom> take "songs x = sigma (\n -> x/n) 1.0 x" for example.  The most general type is "songs :: (Enum a, Fractional a) => a -> a".  I think that is too general and moreover there is a practical problem.
11:56:08 <malsyned> monochrom: what type signature would you recommend for that one?  and what's the practical problem?
11:56:16 <monochrom> The most general type signature almost forces the actual number type used to be Rational or Double.  The former is slower.  The latter has roundoff problems.
11:58:02 <malsyned> I'm not so concerned about numeric accuracy in this application.  but assuming I was, what would you recommend?
11:58:36 <sjanssen> Rational has 100% accuracy
11:58:57 <sjanssen> but it doesn't support sqrt, sin, etc.
11:59:05 <monochrom> I would opt for "songs :: (Integral a) => a -> a", or even just use Int.  Now I need to do division, but I can change the code to "songs x = sigma (\n -> fromIntegral x / fromIntegral n) 1.0 x".  There are corresponding changes to "sigma" too.
11:59:57 <monochrom> Actually maybe Double is not bad an idea here.
12:00:21 <monochrom> I think I have over-analyzed this. :)
12:00:34 * glguy doesn't the the benefit of a more restictive typesig on songs, 
12:00:36 <malsyned> monochrom: it's cool, I appreciate the effort.  thank you.
12:00:43 <glguy> but if you two like the idea, cool ;)
12:01:52 <malsyned> afk
12:06:56 <shapr> xic: Man, this is the Nth nickname you've had :-)
12:07:19 <xic> good evening shapr
12:07:25 <shapr> Shalom!
12:21:15 <malsyned> Is there a good, standard way to use the State monad to abstract out the process of walking down a list and consuming it?  I'm thinking specifically of getting an infinite list of random numbers and making sure that the code never uses the same index into that list twice.  Are there good examples of that kind of thing out there in the public domain?
12:22:30 <norpan> malsyned: yes, have the list as the state and have a function to take a random, modifying the state
12:23:27 <glguy> sounds like a long way to just using a RandomGen g => State g a
12:24:09 <glguy> getRandomR r = do { (x,g') <- gets (randomR r); put g'; return x }
12:24:32 <Excedrin> aren't most (all?) prngs periodic? I suppose if the period is very long, it doesn't matter in practice
12:25:26 <astrolabe> prngs have to be periodic if they only depend on a finite state
12:25:27 <malsyned> My reason for wanting to operate on a list, instead of a RandomGen directly, is so that I can supply test cases more easily.
12:25:46 <glguy> > length [1 :: Int ..] -- takes a long time to process all the ints
12:25:51 <lambdabot> Terminated
12:25:56 <metaperl> hey, what does the hs-libraries propety of a .cabal file mean/do?
12:26:21 <malsyned> Yay!  Now I have a project for learning about the State monad.
12:26:52 <metaperl> OK!
12:26:57 <metaperl> hey! Yay! OK!
12:27:02 <metaperl> anything else to say?!
12:27:09 <metaperl> heh
12:28:09 <glguy> malsyned: are you sure you aren't writting a big version of map?
12:29:07 <bd_> malsyned: mapAccumL perhaps?
12:29:36 <glguy> or zipWith
12:29:44 <malsyned> Not entirely sure, no.  The reason I didn't use map is that the amount of the list that is consumed depends on the contents of the list.
12:30:09 <malebria> I pretend to package a haskell program to debian, and maybe try to find a sponsor to upload it. The point is more studying debian package system than the generated package itself. However, it'd be good if I could package something usefull and maintain it. I was wondering about hscolour, anyone has a better idea?
12:30:30 <bd_> :t mapState f = mapAccumL (\acc x -> runState (f x) acc)
12:30:31 <lambdabot> parse error on input `='
12:30:41 <bd_> :t \f -> mapAccumL (\acc x -> runState (f x) acc)
12:30:43 <lambdabot> forall x a. (x -> State a a) -> a -> [x] -> (a, [a])
12:31:13 <bd_> oh, the pairs are reversed...
12:31:23 <malsyned> I'll have to think for a bit about whether mapAccumL will do what I want.
12:31:29 <bd_> :t \f -> mapAccumL (\acc x -> let (ret, acc') = runState (f x) acc in (acc' ret))
12:31:31 <lambdabot>     Occurs check: cannot construct the infinite type: t = (t1 -> t, y)
12:31:31 <lambdabot>       Expected type: (t1 -> t, y)
12:31:39 <bd_> :t \f -> mapAccumL (\acc x -> let (ret, acc') = runState (f x) acc in (acc', ret))
12:31:41 <lambdabot> forall acc x a. (x -> State acc a) -> acc -> [x] -> (acc, [a])
12:31:45 <bd_> there we go
12:32:12 <bd_> or of course mapM
12:32:39 <bd_> :t \f acc l -> runState (mapM f l) acc
12:32:41 <lambdabot> forall s b a. (a -> State s b) -> s -> [a] -> ([b], s)
12:32:58 <bd_> which is probably better than using mapAccumL really
12:33:15 <malsyned> yeah, I've got to read more about the State class.  Any good tutorials?
12:33:31 <bd_> :t \f acc l -> execState (mapM f l) acc
12:33:33 <lambdabot> forall s b a. (a -> State s b) -> s -> [a] -> s
12:33:39 <bd_> malsyned: nomaware? though that's not so much about state
12:33:56 <bd_> and, should be evalstate there really
12:34:12 <dmhouse> Is a -> (C b => b -> d) isomorphic to C b => a -> b -> d?
12:34:26 <dmhouse> My guess is 'yes'.
12:36:11 <monochrom> should I insert some explicit quantifiers first?  a -> (forall b. C b => b -> d) ?
12:37:58 <dmhouse> Well, that'd change the type.
12:38:02 <monochrom> GHC's forall-hoisting actually rewrites the former to the latter.
12:38:33 <dmhouse> Yes, that's true.
12:38:54 <monochrom> So, I appeal to authority: SPJ thinks they're isomorphic :D
12:39:01 <dmhouse> :)
12:39:12 <malsyned> What's the significance of forall?  aren't all type variables universally quantified by default?
12:39:29 <wolverian> you use it for existential types.. ;)
12:39:32 <dmhouse> malsyned: yes, but by using the forall keyword you can control scope.
12:39:51 <dmhouse> malsyned: e.g. (forall a. a) -> b is _not_ the same as forall a. a -> b
12:40:17 <monochrom> You use it for higher-rank, e.g., (forall x. x -> [x]) -> ...
12:40:37 <monochrom> Granted, that is also a way of expressing existential types.
12:40:43 <dmhouse> The former is a function whose input has to take every type, i.e. inside the function body any operation could legally be performed on the input.
12:40:56 <dmhouse> When combined with datatypes, forall yields existential quantification.
12:41:15 <dmhouse> Which is hopefully what http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types that page explains.
12:41:18 <lambdabot> http://tinyurl.com/f9umb
12:41:50 <malsyned> is forall a GHC extension?
12:42:12 <dmhouse> Yep.
12:42:16 <emu> when not used in prenex form
12:42:20 <dmhouse> http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification
12:42:22 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/8bwuf
12:42:38 <malsyned> wtf prenex?
12:42:47 <emu> well, the parser won't understand "forall" without the extension enabled
12:43:55 <apfelmus> i have some code and want short cut fusion. what's the right flag for ghc?
12:44:26 <glguy> Hugs> mapM_ (\x -> case x of E t -> print t) [E 1, E "two"]
12:44:27 <glguy> 1
12:44:27 <glguy> "two"
12:44:34 <emu> malsyned: the "forall" is implied to come prior to the type expression, normally
12:44:54 <malsyned> emu: thanks
12:44:57 <glguy> where: data E = forall t . Show t => E t
12:45:18 <dmhouse> malsyned: if you're interested in learning about existential types, I recommend that wikibooks page.
12:45:29 <dmhouse> For a class with no methods, is |class C a where| or |class C a| the correct form?
12:45:37 <emu> now i could be making a mistake here, but i think: forall a b. a -> b   <==>  forall a. a -> (forall b. b)
12:45:48 <dmhouse> emu: not true.
12:45:58 <kpreid> dmhouse: both work
12:45:59 <glguy> dmhouse: the examples I saw were: class C a where { }
12:45:59 <emu> see, a mistake
12:46:01 <kpreid> iirc
12:46:13 <dmhouse> emu: if you had a function with the second type, then you could do whatever you liked to the result.
12:46:53 <malsyned> do existential types introduce type unsafety?
12:46:53 <dmhouse> emu, i.e. that function has to return _|_
12:46:56 <dmhouse> emu: whereas for the first one, e.g. const satisfies that.
12:46:57 <dmhouse> malsyned: no.
12:47:30 <emu> hmm ok
12:47:46 <emu> i need to go re-read the rules about that
12:47:50 <dmhouse> emu: think about it like a game. The first type (which can be written forall a b. (a -> b)) says 'Give me types a and b, I'll give you a function from one to the other.' I.e. my choice of function is allowed to depend on both your choices for the type.
12:48:34 <dmhouse> The second one says 'Give me a type a. I'll give you a function from that type to a type which you can subsequently choose.'
12:48:51 <wolverian> dmhouse++
12:49:03 <dmhouse> I think I got that right.
12:49:13 <emu> it sounds reasonable, certainly
12:49:19 <dmhouse> Actually thinking about it, I don't think there are any functions with type forall a b. a -> b
12:49:30 <emu> @djinn forall a b. a -> b
12:49:32 <lambdabot> -- f cannot be realized.
12:49:38 <dmhouse> Clearly not, that's the type of unsafeCoerce.
12:49:57 <emu> @type const
12:49:59 <lambdabot> forall a b. a -> b -> a
12:50:08 <emu> ah
12:50:13 <apfelmus> Igloo: i have some code and want list fusion. what can i do?
12:50:55 <emu> @type (const :: forall a b . a -> b -> a)
12:50:57 <lambdabot> forall a b. a -> b -> a
12:51:06 <emu> @type (const :: forall a. a -> (forall b. b -> a))
12:51:08 <dmhouse> ?djinn forall a. a -> (forall b. b)
12:51:08 <lambdabot> forall a b. a -> b -> a
12:51:08 <lambdabot> -- f cannot be realized.
12:51:17 <emu> lambdabot seems to be lifting it
12:51:33 <dmhouse> emu: well what you said isn't what you wrote.
12:51:48 <dmhouse> Whenever you see (forall a. a), think _|_.
12:51:59 <emu> true, my original example was kinda dumb
12:52:07 <emu> since that is the type of unsafeCoerce =)
12:52:33 <dmhouse> emu: const written that way says 'Give me a type, I'll give you a function from that type to a function from any type you want to your original type.'
12:52:55 <dmhouse> Well, that's easy, I just ignore your second input and return what you originally gave me.
12:53:01 <emu> i was working off my (hazy) memory that prenex polymorphism permits "forall" on the RHS of ->
12:53:10 <thelsdj> ?djinn (a -> b) -> a -> b
12:53:11 <lambdabot> f a = a
12:53:18 <dmhouse> The other way of thinking about it is to say:
12:53:20 <glguy> I've heard prenex 10 times today, and never before
12:53:22 <dmhouse> ?type const "hi"
12:53:23 <glguy> what is prenex?
12:53:23 <lambdabot> forall b. b -> [Char]
12:53:31 <emu> uh, it's often called let-polymorphism
12:53:59 <bd_> ?djinn forall a b. a -> b
12:53:59 <lambdabot> -- f cannot be realized.
12:53:59 <dmhouse> So generalising, const :: forall. a -> (forall b. b -> a), which must be isomorphic to the const we know and love.
12:54:06 <emu> yea
12:54:22 <dmhouse> ?djinn forall a. a -> (forall b. b -> a)
12:54:22 <lambdabot> f a _ = a
12:55:42 <dmhouse> emu: so by a weird coincidence, forall a. a -> (forall b. b) and forall a b. a -> b are actually the same type, the only functions that inhabit them just constantly return bottom.
12:55:56 <dmhouse> But I don't _think_ it's true in general.
12:56:02 <dmhouse> I must say my confidence is now a little shaken.
12:56:37 <Philippa> emu: no, it's not. Let-polymorphism infers prenex types...
12:56:40 <_Stinger_> how are those two different?
12:56:56 <Philippa> basically it's when you can put all the foralls to the leftmost of the type
12:57:03 <emu> Philippa: exactly
12:57:09 <emu> that's what we're discussing
12:57:18 <emu> lifting "forall"s from the RHS of -> to the leftmost of the type
12:57:28 <Philippa> but let-polymorphism is a means for inferring prenex types rather than the same thin
12:57:29 <Philippa> +g
12:57:32 <SyntaxNinja> y0
12:57:41 <dmhouse> Philippa: so is <type expression> -> (forall b. b) always isomorphic to forall b. <type expression> -> b
12:57:47 <dmhouse> s/$/?/
12:57:49 <Philippa> dmhouse: no
12:57:56 <dmhouse> Philippa: good. :)
12:57:59 <Philippa> ...wait, lemme think
12:58:06 * emu chuckles
12:58:08 <Philippa> no, no it's not
12:58:26 <Philippa> and not just because of the obvious case where <type expression> contains a b ;-)
12:58:32 <dmhouse> Assuming b is free in <type expression>
12:58:34 <dmhouse> Heh, yeah.
12:58:50 <dmhouse> Err, <type expression> doesn't contain b freely is what I meant.
12:58:52 <Philippa> hmm. OK, yes, that one is. *But* that may not be the question you intend to ask?
12:59:25 <Philippa> and obviously this is assuming we're allowed to reorder type and term lambdas if we're in an explicitly-typed calculus
12:59:49 <dmhouse> So you can always lift foralls from the right of a ->.
12:59:59 <dmhouse> Or 'hoist', as the GHC user manual calls it.
13:00:04 <Philippa> yeah, it's the LHS that's interesting
13:00:12 <dmhouse> emu: sorry. :)
13:00:14 <emu> ok :)
13:00:32 <emu> if i was at home, i could have consulted a book to resolve it more easily
13:00:55 <dmhouse> Well, then you wouldn't be building your intuition, would you? :)
13:01:03 <dmhouse> And besides, who needs type theory books when you've got Philippa.
13:01:27 <bakert> hello folks.  my tests don't have a coarbitrary and i therefore get a compiler warning.  does that mean i really ought to have one?
13:01:39 <bakert> what do they do?
13:01:40 <emu> bakert: you could stick coarbitrary = undefined in =)
13:02:17 * emu adds coarbitrary to the list of things he needs to re-examine
13:02:23 <bakert> that's actually quite a good idea!  what is it for, though, do you know?
13:02:45 <emu> er, last time i read, i think it said something to do with functional types
13:02:48 * Syzygy- just wrote code to generate associahedra. Now only needto be able to write GraphML from it! :)
13:02:52 <dmhouse> Gah, I wish we had _actual_ existential types in Haskell.
13:02:53 <Syzygy-> Bwahahaha
13:03:01 <dmhouse> Rather than insisting we define a useless wrapper data type.
13:03:13 <emu> well, it does kind of kill type inference
13:03:29 <dmhouse> Ah, does it?
13:03:37 <dmhouse> Why?
13:04:01 <emu> makes it undecidable. as for the proof, best look that up =)
13:04:11 <bakert> Can anyone explain what coarbitrary is, or what it is for?
13:04:56 <bakert> ah perhaps i have found it: "Class method coarbitrary is used to generate random function values".  hmm.  what now?
13:05:21 <bakert> my life would be better if i  could understand this: "f you only want to generate random values of a type, you need only define method arbitrary for that type, while if you want to generate random functions over the type also, then you should define both class methods."
13:05:30 <emu> there is an example of a coarbitrary function for a tree
13:05:47 <bd_> bakert: if you're testing something like map, you need coarbitrary implementations for whatever types the map's function acts over, I guess
13:06:22 <bakert> i see.  it's for when i am testing not just things that do things to a type but also things that take functions that do things to a type???
13:06:34 <bakert> hmm .. i think i confused myself there.
13:06:41 <bakert> it's definitely to do with functions though!
13:08:20 <nmessenger> undefined is like a chainsaw for when you don't want to deal with trimming your bushes.  :D
13:09:17 <bakert> i think it would help if understood what a Gen was.  Is that a thing that generates instances of a type?
13:09:31 <_Stinger_> cause SWR changes depending on the freq and length?
13:10:16 <_Stinger_> er hmm wrong channel
13:10:56 * nmessenger reads "A Kleisli arrow is simply an arrow (ie. in Haskell, a function) aâm b where m is a monad." at <http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html> and almost dies from epiphany.
13:10:57 <lambdabot> http://sigfpe.blogspot.com/2006/06/monads-kleisli-arrows-comonads-and.html>
13:11:40 <nmessenger> (for those with a different charset, 'â' is ->)
13:14:58 <nmessenger> this is interesting:
13:14:59 <nmessenger> ?index Kleisli
13:15:00 <lambdabot> Control.Arrow, Control.Arrow
13:15:22 <nmessenger> listed twice
13:15:46 <dmhouse> Hrm.
13:15:54 <nmessenger> maybe type + constructor?
13:15:56 <dmhouse> Oh, wait, ?index, that's okay.
13:16:08 <dmhouse> nmessenger: sounds plausible.
13:16:37 <dino-> @paste
13:16:37 <lambdabot> http://paste.lisp.org/new/haskell
13:16:53 <dmhouse> nmessenger: the Kleisli type is used to adapt a Monad to an (Control.)Arrow.
13:17:09 <bakert> ?type eq1
13:17:11 <lambdabot> Not in scope: `eq1'
13:17:17 <bakert> ?search eq1
13:17:18 <lambdabot> Unknown command, try @list
13:17:22 <bakert> ?list eq1
13:17:23 <lambdabot> No module "eq1" loaded
13:17:33 <bakert> pleh.  anyone know what "eq1" is?
13:17:35 <dmhouse> bakert: what are you looking for?
13:17:41 <dmhouse> Or rather, where is it mentioned?
13:17:43 <dmhouse> ?hoogle eq1
13:17:44 <lambdabot> No matches found
13:17:50 * dmhouse has never heard of it.
13:17:56 <bakert> http://www.cse.unsw.edu.au/~dons/code/fps/tests/Properties.hs
13:18:17 <bakert> perhaps i am being thick and it is defined in there somewhere.
13:18:28 <bakert> I'm trying to get a handle on QuickCheck and how it is normally used.
13:18:45 <bakert> all this prop_ stuff is freaking me out.  underscores!
13:19:49 <dmhouse> bakert: perhaps QuickCheckUtils?
13:20:18 <dmhouse> bakert: indeed, it's here: http://www.cse.unsw.edu.au/~dons/code/fps/tests/QuickCheckUtils.hs
13:20:19 <bakert> doesn't look like it
13:20:20 <dino-> Crap, paste.lisp.org just stopped working for me. :o
13:20:20 <lambdabot> http://tinyurl.com/mwg5s
13:20:21 <bakert> oh
13:20:47 <bakert> thanks dmhouse
13:23:32 <olliej> how do i make lambdabot display the contents of IO String? (putStr obviously doesn't wok :-/)
13:23:39 <glguy> ?check \ (xs :: [Int]) -> (not . null) xs ==> foldr1 (+) xs == sum xs
13:23:40 <lambdabot>  Parse error in pattern
13:23:59 <glguy> ?check \ xs -> (not . null) xs ==> foldr1 (+) xs == sum xs :: [Int] -> Bool
13:24:01 <lambdabot>      Expecting a function type, but found `Property'       Expected type: [In...
13:24:03 <dino-> Anyone know another paste thingy I can use?
13:24:07 <glguy> ?check \ xs -> (not . null) xs ==> (foldr1 (+) xs == sum xs :: [Int] -> Bool)
13:24:08 <lambdabot>      Expecting a function type, but found `Bool'       Expected type: [Int] -...
13:24:12 <glguy> :-/
13:25:08 <glguy> ?check \ xs -> (not . null) xs ==> (foldr1 (+) xs == sum xs :: [Int] -> Property)
13:25:09 <lambdabot>      Expecting a function type, but found `Bool'       Expected type: [Int] -...
13:25:10 <dmhouse> dino-: pastebin.com?
13:25:48 <Excedrin> olliej: no IO
13:25:54 <dmhouse> ?check \xs -> foldr 0 (+) xs == sum xs
13:25:55 <lambdabot>   add an instance declaration for (Num (a -> a -> a))
13:26:05 <Botje> "no soap, IO"
13:26:10 <dmhouse> ?check \(xs::Int) -> foldr 0 (+) xs == sum xs
13:26:11 <lambdabot>  Parse error in pattern
13:26:20 <dmhouse> ?check \xs -> foldr 0 (+) xs == sum (xs :: Int)
13:26:22 <lambdabot>  Couldn't match `Int' against `[a]'
13:26:27 <dmhouse> ?check \xs -> foldr 0 (+) xs == sum (xs :: [Int])
13:26:28 <lambdabot>  Couldn't match `a -> a -> a' against `Int'
13:26:40 <dmhouse> Bleh. I never could work ?check.
13:26:51 <dmhouse> ?check \xs -> foldr (+) 0 xs == sum (xs :: [Int])
13:26:52 <lambdabot>  OK, passed 500 tests.
13:26:54 <dino-> dmhouse: thanks
13:27:05 <dino-> Ok, this paste: http://pastebin.com/851288
13:27:14 <dino-> I'm going through the Haskell/Continuation passing style wikibook.
13:27:31 <glguy> ?check \xs -> (not $ null xs) ==> foldr1 (+) xs == sum (xs :: [Int])
13:27:33 <lambdabot>  OK, passed 500 tests.
13:27:50 <dino-> And there's a line in the printSquare function that looks like: let k1 a = k (print a)
13:28:16 <dino-> I'm having trouble understanding what k1 and a are evaluating to here.
13:28:28 <glguy> ?type k1 a = k (print a)
13:28:31 <lambdabot> parse error on input `='
13:28:50 <glguy> k :: IO () -> a
13:29:02 <glguy> a :: Show t => t
13:29:13 <dino-> Sure, and (print a) :: IO ()
13:30:06 <dino-> But it looks funny to me, the looks-like-a-func-call on the left side of the = in a let
13:30:50 <glguy> this is an example of continuation passing style
13:30:51 <Jaak> > let f x = x + 1 in f 1
13:30:53 <lambdabot>  2
13:30:56 <glguy> so the k's are what to do with the results
13:31:42 <glguy> printSquare 4 id, the id is applied to the result of square
13:31:52 <dino-> So, k1 here is getting some Show
13:32:24 <glguy> square n k1 say, have square actually square n, and then pass teh result to k1
13:32:26 <dino-> Hm. Sorry to be dense. I don't know why it didn't look as ordinary as what Jaak just said.
13:32:42 <glguy> which, in this case, is will print the number
13:34:00 <dino-> So, as with any function, a is going to be bound to whatever k1 is called with. I get it now.
13:34:04 <glguy> let showSquare n k = let k1 a = k (show a) in square n k1; square n k = k (n ^ 2) in showSquare 4 id
13:34:10 <glguy> > let showSquare n k = let k1 a = k (show a) in square n k1; square n k = k (n ^ 2) in showSquare 4 id
13:34:11 <lambdabot>  "16"
13:34:18 <dino-> And then used with print
13:34:38 <glguy> you are passing the "future", what to do next
13:35:12 <nmessenger> typesafe gotos!
13:36:20 <dino-> Maybe part of my confusion with this particular example is too many a's in that function, between the type and the impl.
13:36:23 <apfelmus> augustss: ping
13:36:50 <jrockway> i have a quick ghci question... is there a way to use "data" without defining the type in a separate file?
13:36:58 <jrockway> i.e. just type data Foo = Bar | Baz etc.
13:37:10 <apfelmus> jrockway: unfortunately not
13:37:11 <nmessenger> exactly :)
13:37:12 <glguy> > flip runCont id . callCC $ \done -> (flip mapM [1..] $ \ i -> when (i > 7) (done "found it")) >> undefined
13:37:13 <dino-> glguy, Jaak, others: thank you!
13:37:15 <lambdabot>  "found it"
13:37:31 <olliej> >  do x <- catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch"); return putStrLn x
13:37:33 <lambdabot>      Expecting a function type, but found `a'
13:37:33 <lambdabot>       Expected type: IO t
13:37:33 <lambdabot>      ...
13:37:40 <jrockway> apfelmus: ok, thanks :)
13:37:53 <olliej> >  do putStrLn $ catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch")
13:37:54 <lambdabot>  Couldn't match `String' against `IO a'
13:38:05 <olliej> :t catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch")
13:38:06 <lambdabot> IO String
13:38:48 <olliej> :t do x<- catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch"); x
13:38:49 <lambdabot>     Couldn't match `IO' against `[]'
13:38:49 <lambdabot>       Expected type: IO t
13:38:58 <olliej> :t do x<- catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch"); putStrLn x
13:39:00 <lambdabot> IO ()
13:39:03 <Jaak> > catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch") >>= putStrLn
13:39:05 <lambdabot>  <IO ()>
13:39:06 <olliej> > do x<- catch (return $ show (fromJust (Nothing::Maybe Int))) (\x-> return "ouch"); putStrLn x
13:39:07 <lambdabot>  <IO ()>
13:39:15 <olliej> Jaak: ahh
13:39:16 <bd_> no IO in lambdabot :)
13:39:21 <olliej> Jaak: cheers
13:39:32 <olliej> bd_: :(
13:39:53 <bd_> olliej: for obvious reasons :)
13:39:54 <Jaak> your final works too
13:40:19 <nmessenger> olliej, you could also think of (=<<) as a monadic ($): 'putStrLn =<< bigIOStringExpression'
13:40:23 <olliej> bd_: someone with skill (eg. someone who isn't me) should write a fantabulous function that "magically" converts IO a to a
13:40:37 <nmessenger> ?type unsafePerformIO
13:40:39 <lambdabot> Not in scope: `unsafePerformIO'
13:40:42 <olliej> nmessenger: a true
13:40:45 <bfulgham> Aside from Darcs, are there any good examples of application-level programs written in Haskell that have publicly available sources?
13:40:46 <bd_> olliej: unsafePerformIO :)
13:40:47 <olliej> s/a/ah
13:40:54 <olliej> bd_: :p
13:40:56 <olliej> fine
13:41:04 <bd_> olliej: note: chances are it's not what you are looking for >.>
13:41:05 <olliej> someone smarter than me already has
13:41:28 <glguy> in general, you don't *want* IO a -> a
13:41:28 <olliej> :t unsafePerformIO
13:41:30 <lambdabot> Not in scope: `unsafePerformIO'
13:41:37 <olliej> glguy: well yes
13:41:43 <nmessenger> olliej, but, it's unsafe.  The IO will be perform whenever the pure code calls upon it, and due to optimizations and such, it could be repeated or not done at all.
13:41:44 <olliej> but it would be useful in lambdabot
13:41:49 <dino-> bfulgham: Haddock comes to mind.
13:42:00 <glguy> olliej: lambdabot intentionally does not allow IO
13:42:01 <bd_> olliej: not really; the reason IO is denied is for security reasons
13:42:12 <bd_> and so particularly unsafePerformIO is blocked
13:42:13 <nmessenger> It's best to keep I/O in IO :)
13:42:21 <olliej> :(
13:42:23 <glguy> > deleteFile "/home/dons/*"
13:42:24 <lambdabot>   Not in scope: `deleteFile'
13:42:24 <bd_> if dons wanted to run IO in lambdabot it wouldn't be too hard :)
13:42:34 <ski> 'unsafePerformIO' should be named 'promiseNoIO'
13:42:49 <glguy> ski: aka ST?
13:42:53 <bd_> unsafeInterleaveIO is more interesting and dangerous :)
13:43:01 <ski> glguy : 'ST' ?
13:43:10 <glguy> ST is like IO that does no IO
13:43:29 <bd_> and thus you can safely have runST :: ST (forall s. s) a -> a
13:43:30 <glguy> that's all that I meant
13:43:36 <nmessenger> StateTransformer, IO is a RealWorldTransformer
13:44:00 * bd_ wonders if there's a STVar RealWorld a -> IOVar a
13:44:07 <ski> no i meant like one should only call it on 'IO'-actions which are semantically 'return something'
13:44:18 <ski> (but may be implemented using state and what not)
13:44:27 <dino-> bfulgham: Some things are listed here: http://www.haskell.org/haskellwiki/Category:Tools
13:44:29 <lambdabot> Title: Category:Tools - HaskellWiki
13:44:32 <nmessenger> ski: in that case, just use 'something' :)
13:44:37 <glguy> ski: my comment was just that that was what ST is
13:44:46 <ski> nmessenger : note the comment in parens
13:44:52 <bd_> ski: Well, that's the idea behind ST; ST allows you to use mutable state, but prevents the overall usage from being impure
13:45:08 <ski> (e.g. implemented that way for efficiency .. or reuse of foreign library code)
13:45:25 <bd_> and if you need foreign libraries, you need unsafePerformIO, or a ffi call that's marked as pure
13:45:52 <ski> yes, i meant the former case, there
13:46:12 <bd_> well, with foreign libraries haskell can't prove it to be pure, so you need to use an unsafe function :)
13:46:19 <bd_> and thus it's up to you to prove it's pure
13:46:23 <bakert> ?src dropWhile
13:46:24 <lambdabot> Source for this function is not available.
13:46:30 <ski> implement a pure interface on top of an inpure FFI interface, using theOperationThatMustNotBeNamed
13:46:39 <nmessenger> no dropWhile?!
13:46:52 <nmessenger> ?src Data.List.dropWhile
13:46:53 <lambdabot> Source for this function is not available.
13:47:07 <ski> @hoogle dropWhile
13:47:07 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
13:47:08 <lambdabot> Data.PackedString.dropWhilePS :: (Char -> Bool) -> PackedString -> PackedString
13:47:19 <glguy> ?djinn (a -> Bool) -> [a] -> [a]
13:47:20 <lambdabot> f _ a = a
13:47:36 <dmhouse> Is there any good reason why we can't have ("blah" ++ s) patterns?
13:47:49 <nmessenger> (++) isn't a type constructor ?
13:47:49 <ski> dmhouse : views are not implemented
13:47:51 <glguy> ++ isn't a constructor
13:47:51 <dmhouse> Where blah is a string constant?
13:48:00 <bakert> I'll tell you why I'm looking for it.  I want to say "find the first element in a list that satisfies a predicate then make that the first element in the list and put all before it on the end"
13:48:00 <dmhouse> nmessenger, glguy: yes, I mean conceptually.
13:48:05 <ski> dmhouse : haskell is not a logic programming language
13:48:16 <bakert> something involving "cycle" perhaps?
13:48:18 <nmessenger> ah, so sugar for ('b':'l':'a':'h' : s) ?
13:48:19 <dmhouse> nmessenger, glguy: just like you can have (n+k) patterns.
13:48:28 <bd_> ski: why not? :)
13:48:34 <dmhouse> > let f (n+1) = n in (f 1, f 0)
13:48:35 <lambdabot>  Parse error in pattern
13:48:37 <ski> bd_ : which ?
13:48:41 <dmhouse> Gasp.
13:48:50 <dmhouse> Huh. Thought that should work.
13:48:51 <Philippa> nmessenger: more importantly it's not a /data/ constructor
13:48:57 <Philippa> type constructors build types, not values :-)
13:49:00 <bd_> ski: Why shouldn't haskell by a logic programming language :)
13:49:08 <dmhouse> ski: what's logic programming got to do with it?
13:49:10 <Philippa> dmhouse: (n+k) patterns're special case
13:49:14 <glguy> > let splits xs = [(a,b,c) | (a,b:bs) <- zip (inits xs) (tails xs)] in splits [1..4]
13:49:15 <lambdabot>   Not in scope: `c'
13:49:20 <bd_> ski: the List monad acts like it sometimes ;)
13:49:20 <ski> bd_ : maybe you want Curry or Escher ?
13:49:22 <glguy> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)] in splits [1..4]
13:49:24 <dmhouse> Philippa: precisely, I think "blah"++s would be useful too.
13:49:24 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
13:49:38 <bd_> ski: nah, I'm sure we can do better :)
13:49:42 <ski> bd_ : (or "Typed Logical Variables in Haskell", Ljunglöf and Claessen)
13:49:43 <nmessenger> Philippa, yeah, but dmhouse restricted "blah" to a constant, so sugar for this case doesn't seem TOO evil.
13:49:48 <bd_> hmm
13:50:07 <dmhouse> nmessenger: more importantly requiring a constant removes ambiguity.
13:50:25 <dmhouse> Currently the best we can do is f s | "blah" `isPrefixOf` s = let s' = drop 4 s in ...
13:50:27 <glguy> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)]; moveToFront pred xs = [b : (a ++ c) | (a,b,c) <- splits xs, pred b] in moveToFront (==2) [1..5]
13:50:29 <lambdabot>  [[2,1,3,4,5]]
13:50:37 <glguy> my pokemons, let me show you them!
13:50:40 <dmhouse> I want f ("blah"++s) = ...
13:50:42 <shapr> POKEMONS!
13:50:57 <ski> dmhouse : in logic programming, you can run predicates "backwards" .. and in Mercury, which has functions, too, you can run them backwards, too .. i'm almost sure that '"blah" ++ s' "pattern" works in Mercury, in fact
13:51:05 <glguy> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)]; moveToFront pred xs = listToMaybe [b : (a ++ c) | (a,b,c) <- splits xs, pred b] in moveToFront (==2) [1..5] -- bakert, for you
13:51:07 <lambdabot>  Just [2,1,3,4,5]
13:51:24 <bakert> oooh thanks glguy!
13:51:53 <glguy> bakert: splits is a good general function
13:52:10 <ski> xs `isPrefixOf` (xs ++ _) = True
13:52:10 <ski> xs `isPrefixOf`  _        = False
13:52:32 <nmessenger> pretty!
13:53:08 <dmhouse> > zip (inits [1..3]) (tails [1..3])
13:53:09 <bakert> ?hoogle splits
13:53:09 <lambdabot>  [([],[1,2,3]),([1],[2,3]),([1,2],[3]),([1,2,3],[])]
13:53:10 <lambdabot> No matches found
13:53:30 <bakert> where does splits live?
13:53:31 <glguy> bakert: no no, the one I defined in channel
13:53:36 <glguy> bakert: up a few lines
13:53:39 <dmhouse> bakert: he defined it using 'let'.
13:53:43 <bakert> ah sorry i get you!
13:53:47 <seliopou> isPrefixOf = (and .) . zipWith (==)
13:53:49 <seliopou> does that work?
13:54:05 <seliopou> > : t (and .) . (zipWith (==))
13:54:06 <lambdabot>  Parse error
13:54:07 <dmhouse> seliopou: yep.
13:54:11 <seliopou> :t (and .) . (zipWith (==))
13:54:13 <lambdabot> forall b. (Eq b) => [b] -> [b] -> Bool
13:54:19 <ski> > (and .) . zipWith (==) $ "foo" "foobar"
13:54:20 <lambdabot>      The function `"foo"' is applied to one arguments,
13:54:20 <lambdabot>     but its type `[Cha...
13:54:33 <nmessenger> ?src isPrefixOf
13:54:33 <lambdabot> isPrefixOf [] _          = True
13:54:34 <lambdabot> isPrefixOf _  []         = False
13:54:34 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
13:54:39 <seliopou> > (and .) . (zipWith (==)) $ "foo" "foobar"
13:54:40 <dmhouse> > ((and .) . zipWith (==)) "foo" "foobar"
13:54:40 <ski> > ((and .) . zipWith (==)) "foo" "foobar"
13:54:40 <lambdabot>      The function `"foo"' is applied to one arguments,
13:54:41 <lambdabot>     but its type `[Cha...
13:54:41 <lambdabot>  True
13:54:42 <lambdabot>  True
13:54:43 <nmessenger> too many points :P
13:54:51 <glguy> ("foo" == "bar", "whats" == "whats") -- what's the point?
13:54:54 <glguy> > ("foo" == "bar", "whats" == "whats") -- what's the point?
13:54:56 <lambdabot>  (False,True)
13:55:02 <glguy> lists already ahve Eq defined
13:55:02 <bakert> glguy, can i be really difficult now and explan what i really wanted?!
13:55:23 <glguy> bakert: I never give permission to ask questions :-p
13:55:25 <dmhouse> glguy: what does splits do?
13:55:26 <bakert> i want everything to stay "in order" as if it were a queue but the first item satisfying the predicate to be first.  sorry!
13:55:46 <glguy> bakert: and what did what I gave you do?
13:55:50 <bakert> like moving the pointer of the head of the list but not changing the list.
13:56:00 <glguy> oh, and throw away the rest?
13:56:04 <bakert> what you gave me moves the satisfying item to the front, doesn't it?
13:56:13 <bakert> no. no throwing away
13:56:16 <bakert> to use your example:
13:56:16 <glguy> or put the rest at the end
13:56:31 <bakert> (==2) [1,2,3,4,5] would be [2,3,4,5,1]
13:56:42 <bakert> or (==4) would be [4,5,1,2,3]
13:56:46 <bakert> sorry for being unclear!
13:56:51 <dmhouse> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)] in splits [1..5]
13:56:52 <glguy> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)]; moveToFront pred xs = listToMaybe [(b : c) ++ a) | (a,b,c) <- splits xs, pred b] in moveToFront (==2) [1..5]
13:56:53 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([1,2],3,[4,5]),([1,2,3],4,[5]),([1,2,3,4]...
13:56:53 <lambdabot>  Parse error
13:57:08 <glguy> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)]; moveToFront pred xs = listToMaybe [(b : c) ++ a | (a,b,c) <- splits xs, pred b] in moveToFront (==2) [1..5]
13:57:10 <lambdabot>  Just [2,3,4,5,1]
13:57:45 <bakert> tremendous!
13:57:54 <dmhouse> ?hoogle splitAt
13:57:55 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
13:57:55 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
13:57:55 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
13:58:02 <bakert> i'm not sure i get what splits does?
13:58:17 <dmhouse> > let splits xs = [(a,b,bs) | (a,b:bs) <- zip (inits xs) (tails xs)] in splits [1..5] -- bakert, this should explain ti
13:58:19 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([1,2],3,[4,5]),([1,2,3],4,[5]),([1,2,3,4]...
13:58:21 <nmessenger> look at its input and its output
13:58:31 <glguy> > let specificToYou pred xs = listToMaybe [(b:bs) ++ a | (a,b:bs) <- zip (inits xs) (tails xs), pred b] in specificToYou (==2) [1..5]
13:58:33 <lambdabot>  Just [2,3,4,5,1]
13:59:23 <dmhouse> > splitAt 0 [1..4]
13:59:24 <lambdabot>  ([],[1,2,3,4])
13:59:38 <bakert> what it's every possible breakdown of the list with a triple of before, item and after?
13:59:50 <glguy> yeah
14:00:07 <bakert> cool
14:00:30 <dmhouse> > let splits xs = [ (a,b,bs) | (a,b:bs) <- map (`splitAt` xs) [0..length xs]]
14:00:31 <lambdabot>  Parse error
14:00:36 <dmhouse> > let splits xs = [ (a,b,bs) | (a,b:bs) <- map (`splitAt` xs) [0..length xs]] in splits [1..5]
14:00:38 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([1,2],3,[4,5]),([1,2,3],4,[5]),([1,2,3,4]...
14:00:51 <dmhouse> Probably more efficient, inits and tails are quadratic IIRC.
14:01:04 <glguy> dmhouse: so is calling splitAt n times
14:01:11 <glguy> and tails is linear
14:01:32 <glguy> *and* all of the inits need not be calculated
14:01:38 <glguy> because the matching is on tails
14:01:46 <gvdm_other> what are lists implemented as? linked? arrays?
14:01:53 <glguy> singly linked lists
14:01:55 <dmhouse> gvdm_other: linked lists.
14:02:07 <nmessenger> data [a] = [] | a : [a]
14:02:19 <paolino> and no length calculation
14:02:35 <glguy> ?src inits
14:02:35 <lambdabot> inits []     =  [[]]
14:02:36 <nmessenger> data List a = Nil | Cons a (List a)
14:02:36 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
14:03:11 <olliej> nmessenger: and we can convert tht to classes as...
14:03:14 * olliej hides
14:03:14 <glguy> ?src tails
14:03:15 <lambdabot> tails []         = [[]]
14:03:16 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
14:03:38 <glguy> ?src splitAt
14:03:39 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
14:03:40 <nmessenger> olliej, isn't Functor the list-like class?
14:04:06 <olliej> nmessenger: no
14:04:09 <glguy> mapping splitAt doesn't reuse the previous work
14:04:14 <glguy> like tails does
14:04:15 <olliej> nmessenger: Functor is continuation
14:04:24 <olliej> Saulzar: !!!!
14:04:40 <paolino> is this acceptable ?
14:04:41 <paolino> converge t f xs = map fst . take t . takeWhile (uncurry f) $ zip xs (tail xs)
14:04:45 <glguy> I want my three wishes!
14:05:08 * mbishop rubs glguy's lamp
14:05:09 <dmhouse> olliej: 'continuation'?
14:05:10 * mbishop coughs
14:05:22 <malebria> Is GHC.ConsoleHandler just for windows?
14:06:06 <dmhouse> nmessenger, olliej: Functor f means f can be mapped over. That means, yes, lists, but also things like tuples.
14:06:22 <nmessenger> Ooh!
14:06:27 <dmhouse> And they need to support fmap id == id, fmap f . fmap g == fmap (f . g)
14:06:28 <nmessenger> ?instances Functor
14:06:29 <lambdabot> ((->) r), Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
14:06:37 <glguy> converge t f xs = head $ takeWhile ( \(a:b:_) -> f a b) $ take n $ tails xs
14:06:43 <dmhouse> Hrm, tuples should be in there.
14:06:47 <dmhouse> > fmap (+1) (2, 3)
14:06:48 <nmessenger> > (1) `fmap` (+1)
14:06:48 <lambdabot>   add an instance declaration for (Functor ((,) a))
14:06:48 <lambdabot>     In the definition of ...
14:06:49 <lambdabot>   add an instance declaration for (Num (a -> b))
14:06:49 <glguy> which I meant to make into a list comp
14:06:52 <dmhouse> Perhaps not.
14:06:53 <mauke> dmhouse: no, they shouldn't
14:06:55 <olliej> nmessenger: ah right
14:07:08 <olliej> nmessenger: sorry was thinking OO design pattern functor
14:07:20 <norpan> tuples have more than one type in them so that would be problematic
14:07:31 <dmhouse> mauke: instance Functor (a, a) where fmap f (x, y) = (f x, f y)
14:07:39 <mauke> I don't think that's legal
14:07:46 <mauke> type variables need to be distinct
14:07:48 <Excedrin> which OO design pattern functors equal continuations?
14:07:51 <dmhouse> Oh, true.
14:08:10 <dmhouse> Excedrin: err, a mixture of exceptions and GOTO, maybe.
14:08:13 <nmessenger> any dumb-person explanation as to why that is?
14:08:21 <olliej> Excedrin: ?
14:08:35 <nmessenger> @ mauke
14:09:20 <mauke> no idea, that's just how it is :-)
14:09:27 <dmhouse> > fmap 1 (+1)
14:09:28 <lambdabot>   add an instance declaration for (Num (a -> b))
14:09:53 <Excedrin> I thought the "OO design pattern" idea of "functor" is a class that supports overloaded function call operator
14:10:05 <mauke> that's not OO, that's C++
14:10:07 <norpan> fmap (+1) (+1)
14:10:07 <glguy> converge t f xs = head [y | (a:b) <- take n (tails xs), null b || f a (head b)]
14:10:12 <norpan> > fmap (+1) (+1)
14:10:12 <olliej> Excedrin: nope
14:10:13 <lambdabot>  Add a type signature
14:10:34 <olliej> Excedrin: Functor = function pointer with state == continuation/partial application/etc
14:10:50 <mauke> yep, definitely C++
14:10:54 <nmessenger> > (+1) `fmap` (+1) $ 3
14:10:56 <lambdabot>  5
14:11:04 <mbishop> Why are so many people all giggly about their OO? I don't see the benefits
14:11:10 <nmessenger> ((->) e) fmap is (.)
14:11:42 <dmhouse> Ah, that's it.
14:12:09 <Welcome_> > let splitAt' 0 xs = ([],xs); splitAt' n (x:xs) = first (x:) $ splitAt' (n-1) xs in splitAt' 3 "testing"
14:12:10 <lambdabot>  ("tes","ting")
14:12:41 <olliej> mauke: Functor isn't C++, it's an OO-ism
14:13:00 <olliej> mauke: or rather ann any language without partial applications/continuations builtin -ism
14:13:29 <Excedrin> olliej: Functor has nothing to do with OO; mauke's comment was regarding what I said, which is definitely C++ish
14:13:31 <nmessenger> by that definition, a Functor is a fancy name for a closure?
14:13:32 <weitzman> Is there unnecessary laziness in the following expression that hurts performance?
14:13:34 <weitzman> > let primes = 2 : [x | x <- [3,5..], all (\n -> x `mod` n /= 0) (takeWhile (\n -> n * n <= x) primes)] in length $ takeWhile (<10000) primes
14:13:35 <glguy> a design pattern a.k.a. a workaround
14:13:36 <lambdabot>  1229
14:14:03 <olliej> glguy: yup :D
14:14:09 <Saizan> nmessenger: afaik a functor in OO is an object used as a function in those language whare you don't have first class functions
14:14:13 <glguy> weitzman: Seive of Ero.....(can't spell it) ?
14:14:22 <paolino> glguy , can you put the right names there please, and I'm needing a part of xs as output ....
14:14:23 <dmhouse> Erastothenes?
14:14:25 <olliej> Saizan: ah, yes a much better way of putting it :D
14:14:58 <glguy> paolino: ?
14:15:07 <weitzman> glguy: Yeah. I was looking at the Project Euler problems, and I got to one where my sieve seems to be too slow to add up some of the lower primes
14:15:08 <glguy> converge t f xs = head [a | (a:b) <- take n (tails xs), null b || f a (head b)]
14:15:12 <Excedrin> Saizan: that's what I said, but olliej says it has to support state for things like partial application and continuations (I'm still fuzzy about how this helps implement continuations)
14:15:16 <mauke> > id
14:15:17 <lambdabot>  Add a type signature
14:15:35 <glguy> weitzman: I've got a 36meg file of the first 4 million primes
14:15:41 <glguy> weitzman: and I just load that up
14:16:18 <glguy> Data.ByteString.Char8 loads it fast
14:16:22 <Saizan> Excedirn: well, if you can pass functions around you can do continuations i think (i'm not very proficient in CPS)
14:16:23 <Excedrin> glguy: how long is the 4 millionth prime?
14:16:32 <dmhouse> > let tick (xs,y,[]) = (xs,y,[]); (xs,y,z:zs) = (y:xs,z,zs) in iterate tick ([],1,[2..5]) -- glguy: O(n)
14:16:33 <lambdabot>  Add a type signature
14:16:34 <weitzman> Since they say you should be able to compute any of the answers in less than a minute, and my hardware is pretty reasonable, I know I must not be doing something as efficiently as I could
14:16:34 <nmessenger> ?remember glguy I've got a 36meg file of the first 4 million primes
14:16:37 <glguy> Excedrin: aproximately 67 million
14:16:44 <glguy> so...8
14:17:02 <Excedrin> neat
14:17:13 <Excedrin> is the file ascii?
14:17:16 <Botje> weitzman: haskell just sucks at computing primes.
14:17:17 <glguy> yeah
14:17:30 <glguy> Botje: it's fast if you use the right functions though
14:17:33 <drain> ho ho!  8 digits per prime, 4 million primes, plus spaces/newlines, gives about 36 meg
14:17:33 <fridim_> Hi there.
14:17:36 <weitzman> My solution, if it were fast enough, would be this:
14:17:43 <nmessenger> Hello fridim_
14:17:43 <weitzman> > let primes = 2 : [x | x <- [3::Int,5..], all (\n -> x `mod` n /= 0) (takeWhile (\n -> n * n <= x) primes)] in sum $ takeWhile (<1000000) primes
14:17:47 <lambdabot>  -1104303641
14:17:48 <Botje> glguy: so what are the right functions? :)
14:17:51 <drain> 1 byte per digit/space
14:17:53 <weitzman> Hmm
14:18:08 <weitzman> > let primes = 2 : [x | x <- [3,5..], all (\n -> x `mod` n /= 0) (takeWhile (\n -> n * n <= x) primes)] in sum $ takeWhile (<1000000) primes
14:18:12 <glguy> http://www.polyomino.f2s.com/david/haskell/numbertheory.html
14:18:13 <lambdabot> Terminated
14:18:17 <dmhouse> > let tick (xs,y,[]) = (xs,y,[]); tick (xs,y,z:zs) = (y:xs,z,zs) in iterate tick ([],1,[2..5])
14:18:17 <lambdabot> Title: Basic Number Theory in Haskell
14:18:17 <paolino> glguy , I need all xs part until one of thos cond are satisfied , is that right ?
14:18:19 <lambdabot>  [([],1,[2,3,4,5]),([1],2,[3,4,5]),([2,1],3,[4,5]),([3,2,1],4,[5]),([4,3,2,1]...
14:18:25 <dmhouse> glguy: that one's O(n).
14:18:42 <glguy> dmhouse: sweet, but it doesn't the the same thing
14:18:49 <glguy> dmhouse: you cut the expensive operation out (inits)
14:19:06 <dmhouse> (Reversing the first list components would make it O(n^2) again, I suppose.)
14:19:14 <glguy> paolino: oh, I thought you just needed the value that satisfied f
14:19:26 <glguy> dmhouse: which is where I was
14:19:42 <dmhouse> glguy: yeah. Hrm, I wonder whether this simply can't be done?
14:20:05 <glguy> dmhouse: if you only reverse the one you need
14:20:07 <glguy> it's still linear
14:20:19 <dmhouse> True.
14:20:31 <dmhouse> But then, if you only need one, splitAt's linear too.
14:20:37 <glguy> right
14:21:07 <nmessenger> (\(xs,y,zs) -> (reverse xs,y,zs)) would make those two identity, right?
14:21:08 <dmhouse> You could do it quickly with Data.Sequence.
14:21:19 <dmhouse> nmessenger: yes, but make it O(n^2) again.
14:21:33 <glguy> but you don't have to reverse until you found the correct y
14:21:34 <dmhouse> reverse is O(n)
14:21:36 <glguy> so, no big deal
14:21:57 <dmhouse> I think it is.
14:21:57 <nmessenger> dmhouse, I realized that. I was just talking extensional equivalence.
14:22:17 <dmhouse> glguy: like I said, if you only wanted one, you'd use splitAt, so you clearly want the whole lot.
14:22:51 <glguy> dmhouse: but you need to search
14:22:55 <glguy> and then when you find the one you wanted
14:23:01 <glguy> reverse the first list in the tuple
14:23:38 <dmhouse> You're still talking finding only one.
14:23:42 <dmhouse> If you want only one, then:
14:23:58 <glguy> dmhouse: maybe I want half of them
14:24:06 <glguy> its still cheaper
14:24:19 <dmhouse> Yeah, I suppose so.
14:24:32 <glguy> actually, I don't want *any* of them, I was just giving bakert that function :-p
14:24:36 <dmhouse> :)
14:26:10 <paolino> glguy, I study your code tomorrow, good night
14:26:28 <paolino> and thanks all
14:27:30 <bakert> i need them all, though, yes!  they are my card players and they will be upset if they get kicked out of the game just because they are not sitting in the right place in relation to the dealer!
14:27:49 <glguy> > let makeEm [] = [] ; makeEm (x:xs) = ([], x, xs) : [(x:a,b,c) | (a,b,c) <- makeEm xs] in makeEm [1..4]
14:27:51 <lambdabot>  [([],1,[2,3,4]),([1],2,[3,4]),([1,2],3,[4]),([1,2,3],4,[])]
14:28:03 <glguy> bakert: no, you only needed the one you found
14:28:08 <glguy> bakert: not all of the combinations
14:28:27 <bakert> oh i see ... sorry yes you are right ... for the splits thing ... i thought you were talking about the whole function
14:30:39 <Excedrin> neat, it takes my computer 4.6 seconds to generate the 1st 4 billion primes
14:31:23 <glguy> Excedrin: using what method?
14:31:49 <bakert> blinking heck.  imagine going back in time with a laptop to 1822.  you could rule the world!
14:31:52 <Excedrin> sieve of Atkin
14:32:06 <glguy> lisp.paste the code?
14:32:08 <bakert> until you realised your plug didn't work
14:32:23 <bakert> but it'd be a good 2 hours
14:32:42 <Excedrin> http://www.thedjbway.org/scientific/primegen.html
14:32:44 <lambdabot> Title: the djb way: primegen
14:32:58 <zeeeeeee> is it standard convention/style to prefix record names with a namespace and an underscore?
14:33:11 <glguy> Excedrin: oh, c++?
14:33:26 <Excedrin> just C
14:33:41 <bakert> zeeeeeee, seems to be standard practice to do something like (for Header record): hdrName = foo, hdrValue = bar
14:33:55 <bakert> zeeeeeee, i didn't like that though so i put the record in it's own module
14:33:59 <bakert> then I get:
14:34:15 <_Stinger_> bakert : or be burnt as a witch for your devil box
14:34:22 <bakert> let x = Header { Header.name = foo, Header.value = bar }
14:34:27 <_Stinger_> actually 1822 no probably not ;)
14:34:32 <glguy> Excedrin: does that mean you had an array of 4 billion bools?
14:34:47 <bakert> you have to do import Header(Header(Header))) and import qualified Header to get it to work exactly nicely
14:35:10 <bakert> but if you are after a "standard" i think hdrName, hdrValue, hdrBaz type things is what you'll get
14:35:49 * nmessenger wishes for file-level submodules for more control over names.
14:36:13 <Excedrin> glguy: maybe? :)
14:36:22 <bakert> zeeeeeee, only place i've seen underscores in my (less than 2 weeks of) haskell investigations is in property asserting functions in QuickCheck.
14:36:32 <bakert> and they look wrong!
14:36:38 <nmessenger> Or even disambiguation based on type environment.
14:37:47 <nmessenger> lookup 'a' (empty :: Map Char Int) should *not* use Prelude.lookup!
14:39:06 <bakert> _Stinger_, no, that's 2007 in a few too many places in the world ...
14:39:10 <nmessenger> Wouldn't that solve needing different names/namespaces for all record accessors?
14:48:47 <glguy> what is lsr in OCaml?
14:48:53 <glguy> shift right?
14:49:33 <norpan> logic shift right?
14:50:08 <mauke> see http://caml.inria.fr/pub/docs/manual-ocaml/libref/Pervasives.html
14:56:05 <bakert> is there a function that gives the index (integer) of the first element in a list satisfying a predicate?
14:56:17 <Cale> @type findIndex
14:56:19 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
14:56:40 <mauke> @hoogle (a -> Bool) -> [a] -> Int
14:56:41 <lambdabot> No matches, try a more general search
14:57:10 <bakert> thanks Cale -- I didn't think of Maybe in my Hoogle search
14:58:51 <calvins> In http://syntaxfree.wordpress.com/2006/12/12/do-notation-considered-harmful/, the type of bind is given as (>>=) :: forall a b . m a -> (a -> m b) -> m b...
14:58:57 <lambdabot> Title: Do-notation considered harmful Â« Data.Syntaxfree, http://tinyurl.com/tlmrl
14:59:30 <calvins> what is the meaning of "forall a b", since "m a -> (a -> m b) -> m b" already seems to mean "for arbitrary a and b"?
14:59:39 <mauke> it's redundant
14:59:56 <calvins> oh, okay; thought i missed something..
14:59:58 <calvins> thanks
15:03:12 <bakert> ok folks i wrote my own version of moveToFront.  i'm surely it's vastly inferior but i'd be interested to know why.
15:03:15 <bakert> >  let x = [1,2,3,4,5,6,7,8]; Just i = findIndex (==6) x in (take (length x) $ drop i $ cycle x)
15:03:17 <lambdabot>  [6,7,8,1,2,3,4,5]
15:05:35 <nmessenger> I like the cycle.
15:05:45 <malebria> @paste
15:05:45 <lambdabot> http://paste.lisp.org/new/haskell
15:06:03 <bakert> i like cycle in general.
15:06:38 <lisppaste2> malebria pasted "Guards" at http://paste.lisp.org/display/34182
15:06:53 <Saizan> mmh take length x seems rather consuming
15:07:02 <malebria> Is there a reason to prefer one of the forms in the paste?
15:07:19 <glguy> bakert: yours doesn't work on infinite lists?
15:07:22 <glguy> > let specificToYou pred xs = listToMaybe [(b:bs) ++ a | (a,b:bs) <- zip (inits xs) (tails xs), pred b] in specificToYou (==2) [1..]
15:07:24 <lambdabot>  Just [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,...
15:07:28 <nmessenger> malebria, the second allow you to define a where clause over all guards
15:07:28 <glguy> :-p
15:07:36 <nmessenger> *allows
15:07:37 <glguy> doesn't really matter in such a small case
15:07:46 <glguy> I generally avoid length
15:07:50 <bakert> and it breaks when pred is never true ...
15:07:59 <bakert> but that could be fixed
15:08:59 <bakert> malebria, teste looks nicer but teste2 is how i've been writing them.  but don't listen to me ... i'm new to all this.
15:09:01 <malebria> nmessenger: you mean a where for each guard?
15:09:25 <nmessenger> > let f x | x == 1 = blah | x == 2 = blah - 1 where blah = 5 in f 2
15:09:26 <lambdabot>  4
15:09:37 <nmessenger> > let f x | x == 1 = blah | x == 2 = blah - 1 where blah = 5 in f 1
15:09:39 <lambdabot>  5
15:09:40 <malebria> I always wrote and read the form, now I'm seeing some code with the second one.
15:10:01 <malebria> Sorry, sad it wrong.
15:10:15 <nmessenger> No porblem :)
15:10:17 <malebria> I always wrote the second one, now I'm seeing the first one in some places.
15:10:20 <kowey> malebria: you referring to darcs?
15:10:41 <malebria> kowey: =D
15:10:44 <malebria> kowey: yes.
15:10:53 <kowey> i kinda wish there were a few | otherwise in there
15:11:00 <nmessenger> malebria, if you use the first style, you'd have to define 'where blah = 5' in both equations
15:11:08 <kowey> because the definitions are so long, that when you're just glancing at it
15:11:12 <kowey> you don't realise that there are other cases
15:11:14 <lisppaste2> malebria annotated #34182 with "Darcs" at http://paste.lisp.org/display/34182#1
15:11:55 <malebria> nmessenger: I got that... but in cases without where I don't see a motivation to use the first one.
15:12:30 <malebria> kowey: in this example the definition is not very long.
15:12:32 <bakert> malebria, one less line? ;)
15:12:57 <malebria> bakert: the first one has one line more.. =D
15:13:09 <lisppaste2> nmessenger annotated #34182 with "for bakert" at http://paste.lisp.org/display/34182#2
15:13:50 <nmessenger> precisely the same number of lines and bytes, just without the repeated pattern.
15:14:02 <malebria> nmessenger: That's how I'd write.
15:14:12 <malebria> nmessenger: I think it's more clear.
15:14:20 <nmessenger> Style choice.  Doesn't really matter so much.
15:14:43 <nmessenger> (in non-where-clause situations)
15:14:48 <kowey> http://www.darcs.net/darcs-unstable/PatchCommute.lhs <-- check out coalesce
15:14:59 <malebria> nmessenger: sure doesn't. But less things to read make it more easy to understand.
15:15:20 <nmessenger> malebria, agreed.
15:15:55 <bakert> me three.
15:16:09 <bakert> not much in it though
15:16:50 <malebria> kowey: but this is a different case, cause all pattern maches are different.
15:16:58 <nmessenger> coalesce is cool, though I wonder why it's not curried.
15:17:17 <nmessenger> and what mal said, too. :P
15:18:52 * glguy finishes his Haskell implementation of Seive of Atkins
15:19:29 * nmessenger is awed at glguy speed.
15:19:36 <glguy> :-p
15:19:45 <glguy> I assume you are poking fun
15:19:58 <Syzygy-> Hah!
15:20:00 * nmessenger was serious
15:20:09 <nmessenger> :P
15:20:09 <Syzygy-> http://mikael.johanssons.org/Brackets.hs
15:22:10 <lisppaste2> glguy pasted "uncleaned code, in case anyone cared" at http://paste.lisp.org/display/34185
15:23:29 <nmessenger> cleanliness doesn't matter so much, so long as it's pure :D
15:23:33 <kowey> malebria: http://www.darcs.net/darcs-unstable/Optimize.lhs <-- choose_order
15:23:50 <kowey> i'm not defending this as neccesarily a good way to do it, just showing examples where he uses that style
15:25:50 <bakert> glguy, one day i will understand your code and think it is good.  one day i too will write functions with nested where clauses.
15:25:58 <bakert> not yet, though.
15:26:10 <glguy> bakert: I only do that so that I don't have to keep passing the array reference around
15:26:21 * nmessenger is the king of nested where clauses
15:27:23 <bakert> where do you guys pick up all these things like runSTUArray (whatever that is) ... is there a great book or do you just read mailing lists obsessively, or whut?
15:27:47 <glguy> too much #haskell time
15:27:54 <bakert> there's so much in the libraries that i don't think to use - need to get some of it into my brain somehow.
15:28:25 <malebria> kowey: but each one do you prefer?
15:28:35 <kowey> i'm pretty ignorant myself, but reading other people's code helps
15:29:15 * nmessenger wonders at the curious mix of snake_case and camelCase in the darcs code.
15:29:20 <kowey> malebria: depends on context... i'm not a good enough haskeller to have an opinion (check out Whatsnew, btw, even though it's indented, it's basically the first case)
15:29:37 * bakert was also wondering about the underscores
15:30:13 <malebria> kowey: Whatsnew?
15:30:23 <kowey> nmessenger: there's a whole thread about it! http://darcs.net/pipermail/darcs-devel/2006-October/004828.html
15:30:25 <lambdabot> Title: [darcs-devel] Greetings and some questions
15:30:45 * sorear pokes ?seen
15:30:47 <kowey> malebria: yeah, the function whatsnew_cmd
15:31:06 <nmessenger> malebria, all the darcs code: http://www.darcs.net/darcs-unstable/
15:31:07 <lambdabot> Title: Index of /darcs-unstable
15:31:28 <malebria> nmessenger: I'm reading it.
15:31:48 <seliopou> somebody needs to give me something to hack on
15:31:49 <malebria> kowey: I greped for Whatsnew and nothing returned, that's why I asked. Next time I'll use -i.
15:31:58 <seliopou> I'm jonesin'
15:32:07 <_spydr_> anyone familiar with ghci on Intel OSX?
15:32:21 <kowey> selipou: http://bugs.darcs.net
15:32:24 <lambdabot> Title: List of issues - Darcs issue tracker
15:32:27 <kowey> seliopou, sorry
15:32:50 <seliopou> I am going to HIT THAT
15:33:16 <kowey> if you just want a quick fix: http://bugs.darcs.net/issue?%40search_text=&title=&%40columns=title&topic=6&id=&%40columns=id&creation=&creator=&activity=&%40columns=activity&%40sort=activity&actor=&priority=&%40group=priority&status=&%40columns=status&assignedto=&%40columns=assignedto&%40pagesize=50&%40startwith=0&%40sortdir=on&%40queryname=&%40action=search
15:33:20 <bakert> seliopou, there's no SOAP library for Haskell (something in HAIFA).  I know SOAP is disappearing but I could sure use it.
15:33:20 <lambdabot> Title: List of issues - Darcs issue tracker, http://tinyurl.com/y89tgl
15:33:49 <nmessenger> that's quite the URL.
15:33:57 <kowey> it's all our ProbablyEasy bugs
15:34:08 * nmessenger giggles at bakert
15:34:09 <seliopou> rofl, I am going to fix that ellipsis thing
15:34:19 <kowey> actually, already done
15:34:25 <glguy> ellipsis thing?
15:34:26 <kowey> it'll be going in this weekend
15:34:47 <Syzygy-> I should probably code up this GraphML printer I just did so it works with ... say ... Data.Graph and then put it somewhere sane.
15:34:53 <malebria> nmessenger: bakert: http://darcs.net/DarcsWiki/DeveloperFAQ
15:34:54 <lambdabot> Title: DeveloperFAQ - DarcsWiki
15:34:58 <seliopou> damnit!
15:35:02 <kowey> if you could make the amend-record edit description thing, that'd be cool
15:36:01 <bakert> nmessenger, seliopou, i'm serious!  i have to write an app at work and it needs to talk SOAP.  i'm going to be calling some other program from inside my haskell program if no one (including me) writes a SOAP library in the next 3 weeks!
15:36:23 <seliopou> I have no experience with SOAP unfortunately
15:36:38 <bakert> seliopou, it's just XML and HTTP
15:36:49 <malebria> kowey: I really would prefer whatsnew with otherwise
15:36:50 <bakert> (says he, who isn't implementing SOAP in haskell)
15:37:00 <seliopou> rof
15:37:14 <kowey> malebria: i think i could agree with that... it's hard to realise at first glance that there's another case above
15:37:28 <kowey> but in short code, maybe it's not so nice
15:37:45 <malebria> kowey: yes... What do you mean?
15:38:33 <kowey> actually, in short code, it probably doesn't make much difference, nevermind
15:38:38 <kowey> although, in a way
15:38:53 <kowey> if you don't have the otherwise, you could sort of see it as being the "normal" case
15:39:08 <malebria> kowey: You mean the last one?
15:39:09 <kowey> and all the things with guards are just there to siphon off the weirdos
15:39:37 <malebria> kowey: sorry, my english is not that good.
15:39:52 <nmessenger> ?remember kowey all the things with guards are just there to siphon off the weirdos
15:40:00 <seliopou> ?where darcs
15:40:01 <lambdabot> http://darcs.net/
15:40:10 <nmessenger> siphon off = remove
15:40:17 <malebria> and weirdos?
15:40:22 <glguy> finding the primality of [1..40000000] took 1:12 on my machine
15:40:23 <nmessenger> weird things
15:40:26 <nmessenger> :)
15:40:28 <kowey> sorry about that!
15:40:30 <glguy> so not as fast as the C code
15:40:32 <kowey> anyway, off to bed
15:40:32 <malebria> =D
15:40:59 <drain> ARFENHOUSE
15:41:12 <nmessenger> yay arfenhouse!
15:41:31 <mauke> what the
15:41:35 <sorear> ?seen freenode:drain
15:41:35 <lambdabot> freenode:drain is in #haskell. I last heard freenode:drain speak 36s ago.
15:41:48 <dons> moin
15:41:52 <dons> ?users
15:41:53 <lambdabot> Maximum users seen in #haskell: 296, currently: 285 (96.3%), active: 46 (16.1%)
15:41:58 <seliopou> O M G
15:42:00 <seliopou> darcs is huge
15:42:14 <sorear> you only just noticed? :)
15:42:31 <seliopou> I'm getting the repo for the first time right now
15:42:44 <nmessenger> the authors file is 4.5M   8)
15:42:46 <sorear> did you use --partial ?
15:42:50 <seliopou> no
15:42:52 <seliopou> should I?
15:43:03 <sorear> how many patches is it trying to get !?
15:43:04 <glguy> do you want to have a full revision history?
15:43:10 <seliopou> Heh 4000 - 2
15:43:17 <seliopou> Heh 4000 - 32
15:43:30 <bakert> it is pretty quick with --partial
15:43:47 <sorear> get coffee, take a nap, or just help newbies for a few minutes
15:44:19 <sorear> (it's much faster with partial but IME it causes a lot of future hassle, esp. if you're hacking)
15:44:35 <nmessenger> newbie-helping is fun.  (says the newbie)
15:44:36 <seliopou> Ok, I'll ride this one out
15:45:10 * seliopou wonders if its unzipping the patches now, or it is going to do that later
15:45:28 <sorear> darcs gives a fatal error when you try to do a full get on a partial source, leaving you to clean up the mess ... annoying.
15:45:43 <sorear> seliopou: are you sure the patches are zipped ?
15:45:55 <sorear> the extension will lie, check with file
15:46:01 <seliopou> looks like <timestamp>-<something>-<hash>.gz
15:46:07 <sorear> file(1) - one of my favorite tools
15:46:19 <sorear> darcs uses .gz as a plain text extention
15:46:24 <seliopou> heh
15:46:26 <seliopou> gotcha
15:46:30 <sorear> (or as gzip, sometimes)
15:46:51 <nmessenger> is file(1) some kind of magic sniffer?
15:46:56 <sorear> yes
15:47:22 <bakert> file is cool.  i like, "ASCII English text, with very long lines, with overstriking" (for a mysqldump file)
15:47:22 * nmessenger realizes that LB should have an @man
15:47:47 <bakert> but my list of programs worked on gives " ASCII Java program text, with CRLF line terminators" which is definitely NOT correct!
15:47:51 <mauke> fun.hs: ASCII Java program text
15:48:03 <bakert> ah ... same prob!
15:48:17 <sorear> file is ancient
15:48:23 <mauke> probably because of import
15:48:23 <seliopou> This wasn't that bad, it's almost done applying the patches
15:48:28 <sorear> and slightly rotted
15:48:48 <sorear> 4.2BSD iirc, maybe older
15:49:07 * sorear checks his copy of The UNIX Programming Environment
15:49:32 <bakert> from "BUGS" on the man page: "file  uses  several  algorithms that favor speed over accuracy, thus it
15:49:32 <bakert>        can be misled about the contents of text files.
15:49:32 <bakert> "
15:49:32 <nmessenger> wouldn't it depend on some kind of /etc/magic file?
15:50:12 <bakert> gosh, the magic file doesn't support regexes
15:50:16 <bakert> it IS old!
15:50:51 <sorear> file predades me
15:50:55 <bakert> !
15:50:57 <mauke> "ironographidly"
15:51:23 * nmessenger laughs, then is confused
15:51:46 <lightstep> bakert, how would regexes help?
15:52:26 * nmessenger finally understands mauke's joke, probably
15:52:54 <bakert> lightstep, to determine what language a source file is in, that kind of thing.
15:52:58 <bakert> from "BUGS": The program doesnât grok FORTRAN.  It should be able to figure  FORTRAN
15:52:59 <bakert>        by  seeing  some  keywords  which appear indented at the start of line.
15:52:59 <bakert>        Regular expression support would make this easy.
15:53:13 <mauke> nmessenger: could you explain it to me?
15:53:15 <bakert> (oop, ugly copy and paste -soz)
15:53:34 <sorear> wow, 1973
15:54:09 <lightstep> simple binary strings seem good enough for this detection. or if fortran case-insensitive?
15:54:12 <mauke> nmessenger: I'd also be interested in your explanation of objuromopy, gastylemma and hydropology :-)
15:55:02 <nmessenger> mauke, I presumed "ironographidly" was RE: sorear "predades", 'd' is the wrong graph, but "pre-dads" works.
15:55:02 <wolverian> heh. "This manual page, and particularly this section, is too long." -- file(1) BUGS
15:55:15 <bakert> lightstep, i wasn't really saying it was useless without regexes just that it would have bound to have been written with support for them any time after the Perl era.  so it must be old (1973 is pretty old!)
15:55:16 <sorear> but anyway, seliopou, file CAN tell the difference between darcs patches and gzipped files.
15:55:27 <seliopou> k
15:55:52 <mauke> nmessenger: actually, I'm just running http://rafb.net/p/iYpQtZ85.html on /usr/share/dict/words
15:55:53 <lambdabot> Title: Nopaste - No description
15:56:46 <mauke> w00t, it just generated "Dictifierlawl"
15:56:49 <lisppaste2> glguy annotated #34185 with "sieve of atkins" at http://paste.lisp.org/display/34185#1
15:57:03 <glguy> pay no mind... just cleaning up to show to a friend
15:57:05 * seliopou walks away while the beast builds
15:57:05 <sorear> oh, that's a dissociator?
15:57:28 * sorear has lost most of his Perl
15:57:28 <mauke> is that what it's called?
15:57:45 <Saulzar> Heh, now I know why firefox? Or some web program always calls haskell files "Main.hs: ASCII Java program text"
15:58:12 <sorear> M-x dissociated-press --- the canonical dissociator (an Emacs command)
15:58:28 <shapr> Saulzar: why?
15:58:40 <mauke> "unfolderry"
15:58:46 <Saulzar> That's the output of the unix command "file"
15:59:13 <shapr> Saulzar: so it is
16:00:04 <sorear> @karma ikegami
16:00:05 <lambdabot> ikegami has a karma of 0
16:00:16 <ikegami--> hello
16:00:53 <bakert> what's karma?
16:01:04 <lightstep> @dict karma
16:01:05 <lambdabot> Supported dictionary-lookup commands:
16:01:05 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
16:01:05 <lambdabot> Use "dict-help [cmd...]" for more.
16:01:07 <shapr> @karma bakert
16:01:08 <glguy> stuff that makes you feel special
16:01:08 <lambdabot> bakert has a karma of 0
16:01:11 <shapr> @karma shapr
16:01:12 <lambdabot> You have a karma of 34
16:01:14 <shapr> w00
16:01:19 <sorear> @karma dons
16:01:19 <lambdabot> dons has a karma of 109
16:01:23 <glguy> see, shapr is special
16:01:24 <nmessenger> ?karma nmessenger
16:01:24 <lambdabot> You have a karma of 1
16:01:26 <Mynstral> I'm pretty knew to haskell, but I have what seems (to me) like an odd problem.  I have a program generating a very long list and it segfaults after running for a while (and correctly calculating all previous values).
16:01:29 <shapr> and dons is even MORE special!
16:01:29 <nmessenger> yay 1!
16:01:35 <glguy> ?karma
16:01:36 <lambdabot> You have a karma of 12
16:01:38 <sorear> @kayma
16:01:38 <lambdabot> You have a karma of 8
16:01:40 <shapr> nmessenger++ -- CAPTAIN LAMBDA!
16:01:48 * nmessenger did something evil the other day, watch this!
16:01:53 <shapr> @karma nmessenger
16:01:53 <mauke> Mynstral: that is weird
16:01:53 <lambdabot> nmessenger has a karma of 2
16:01:55 <evil_nmess> nmessenger++
16:02:01 <Mynstral> Is segfault typical behavior for a program that runs out of memory, perhaps?  It doesn't seem like it should be doing that either.
16:02:02 <shapr> evil_nmess: Hey, that's not fair!
16:02:15 <sorear> Mynstral: no
16:02:17 <shapr> Mynstral: segfault is atypical
16:02:31 <nmessenger> ?karma nmessenger
16:02:31 <lambdabot> You have a karma of 2
16:02:33 <Mynstral> I thought it would be with what little I know of the language.
16:02:39 <sorear> Mynstral: can you @paste the code?
16:02:41 <sorear> @past
16:02:41 <lambdabot> http://paste.lisp.org/new/haskell
16:02:43 <Mynstral> Sure.
16:02:54 <shapr> Mynstral: In five years I've gotten one segfault.
16:03:14 <sorear> I've gotten many more, but I've been trying.
16:03:41 <seliopou> god, i got a segfault out of the mutable arrays like 2 years ago
16:03:43 <seliopou> during icfp
16:03:44 <sorear> > array (0::Int,maxBound) [(0,'x')]
16:03:45 <seliopou> :(
16:03:46 <lambdabot> Terminated
16:03:50 <sorear> > array (0::Int,maxBound) [(3,'x')]
16:03:51 <lambdabot>  internal error: EVACUATED object entered!
16:03:53 <lambdabot>     Please report this as a bug to...
16:03:56 <lisppaste2> Mynstral pasted "segfaulting sieve" at http://paste.lisp.org/display/34187
16:04:07 <sorear> try that in GHCi, get a segfault
16:04:10 <bakert> got to go to sleep folks it's midnight here, thanks once again for all your help ...
16:04:22 <mauke> sorear: is that a known bug?
16:04:26 <sorear> (lambdabot uses runplugs, which is different for some reason)
16:04:31 <sorear> mauke: yes
16:04:36 <sorear> known and old
16:04:40 <sorear> >1 week
16:05:16 <sorear> as compared to my Xserver crash bug which is known >4 yrs.  *whine* *whine*
16:06:07 <Excedrin> glguy: if I wanted to use your sieve to output primes in ASCII, what would I need to change?
16:07:00 <sorear> Mynstral: at what number does it crash?
16:07:08 <mauke> I have a nearly 2-year-old bug in g++
16:07:40 <glguy> Excedrin:
16:07:44 * sorear is running mynstral's code in ghci ... 800k and counting
16:07:48 <glguy> let primes4000000 = primes 4000000    in print $ take 10 $ [a | (a,True) <- assocs primes4000000]
16:07:53 <sorear> 1m
16:08:54 <sorear> 1.4m (now compiled)
16:09:22 <Mynstral> hold --- phone
16:09:37 <_Stinger_> the? what do I win?
16:09:49 <sorear> modified your code to print every 1k'th prime
16:14:12 <Mynstral> Sorry about that.
16:15:00 <Mynstral> I was doing a take on primes and the last value displayed was 65951029
16:15:17 <glguy> Mynstral: what are you using to generate them?
16:15:19 <sorear> if you try it again, do you get the same result?
16:15:41 <sorear> I reached 3m in GHC-HEAD compiled code
16:15:43 <Mynstral> That should be array element 3893350 if my math is right.
16:16:03 <dons> Mynstral: what implemementation?
16:16:12 <Mynstral> I'm using GHCi.  I don't know if it's reproducible.  Last time it ran for at least 7 hours before segfault
16:16:38 <sorear> what version ?
16:16:53 <sorear> (and BTW ghc -O2 is *much* faster than ghci)
16:16:59 <Mynstral> dons: implementation?  I'm using 6.4.2
16:17:18 <glguy> does STUArray s Int Bool use 1 byte per Bool?
16:17:21 <dons> ah ok. there was an array bug that was removed in ghc 6.6
16:17:29 <dons> I'd try ghc 6.6 (compiled) (for speed)
16:17:33 <sorear> dons: its list code
16:17:38 <sorear> see the paste
16:17:39 <glguy> {-# OPTIONS_GHC -O2 #-}
16:17:41 <glguy> does that work?
16:17:42 <dons> oh ok. better try ghc 6.6 still
16:18:00 <dons> if its reproducible there, its *defintitely* a bug, and should be reported
16:18:06 <sorear> <lisppaste2> Mynstral pasted "segfaulting sieve" at http://paste.lisp.org/display/34187
16:18:09 <glguy> I generated primes up to 60million on my system in 1.5 minutes...
16:18:10 <dons> all pure code, not doing FFI or anything evil, that segfaults, is a bug
16:18:35 <sorear> glguy: <stares>
16:18:47 <glguy> sorear: go on?
16:19:03 <sorear> in 3:10 with mynstrel's code I've only reached 7m
16:19:13 <glguy> last line:
16:19:14 <glguy> 41,59915111,59931779,59948711,59965133,59982289,59998223]
16:19:17 <sorear> or were you using optimized, non-lazy-list code
16:19:31 <glguy> sorear: http://paste.lisp.org/display/34185#1
16:19:34 <Excedrin> glguy: is this with the sieve code you pasted? is it possible to speed it up?
16:19:38 <glguy> sorear: I just wrote that and am playing with it
16:19:53 <dons> ndm, you didn't mention TH in the context of macros
16:19:54 <glguy> Excedrin: you mean 4 billion in seconds like your C code?
16:20:03 <sorear> I'm also using drop ... laziness foo
16:20:03 <Excedrin> glguy: yes
16:20:04 <dons> ndm, despite it being used for code generatoin techniques (?)
16:20:06 <Mynstral> sorear: He's using atkins while I'm using eratosthenes; his should be much faster
16:20:36 <glguy> Excedrin: I'd ahve to profile when I got home, but I can't imagine shaving down *that* much
16:20:47 <dons> http://programming.reddit.com/info/x2pw/details
16:20:50 <lambdabot> Title: Does Haskell need macros? (reddit.com)
16:21:12 <glguy> ?fptools Data.Array.ST
16:21:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array/ST.hs
16:21:27 <sorear> glguy: you are using long strict-tail lists of Integers - somehing like ByteString might make this faster
16:21:54 <glguy> sorear: in which function?
16:22:05 <glguy> OH
16:22:09 <glguy> it's using INTEGER
16:22:10 <glguy> one second
16:22:13 <glguy> lets try int
16:22:23 <Mynstral> glguy: How long would it take your implementation of that algorithm to simply check for primality on a single number (say 999999937 for example)
16:22:50 <glguy> Mynstral: as written, ti would have to generate all primes up to that number first
16:22:54 <Excedrin> probably longer than a primality testing algorithm
16:23:20 <glguy> I'm timing with Int now as my array indexer
16:23:54 <Mynstral> glguy: That's ok.  I have a different implementation I'd like to check against yours for speed.
16:24:02 <sorear> glguy: 4 bibbion and two isn't prime :)
16:24:22 <glguy> ok, I generate up to 60mil in 1 minute now
16:24:33 <glguy> shaved off 30 seconds
16:25:14 <sorear> idiot question: using -O2 ?
16:25:24 <glguy> I'm using {-# OPTIONS_GHC -O2
16:25:25 <glguy> does that work?
16:25:32 <sorear> yes
16:25:42 <sorear> should , anyway
16:27:23 <sorear> glguy: try using STUArrays
16:27:29 <glguy> i am using them
16:28:16 <nmessenger> ?pl \x y -> map (\op -> x `op` y) [(+),(-)]
16:28:17 <lambdabot> flip flip [(+), (-)] . (map .) . flip . flip id
16:28:35 <nmessenger> um, isn't (flip . flip) identity?
16:28:49 <glguy> ?type (flip . flip)
16:28:50 <lambdabot> forall a b c. (b -> a -> c) -> b -> a -> c
16:29:01 <glguy> ?type (flip . flip id)
16:29:03 <lambdabot> forall b c a. a -> b -> (a -> b -> c) -> c
16:29:20 <mauke> ?. djinn type (flip . flip id)
16:29:22 <lambdabot> f a b c = c a b
16:29:30 <nmessenger> wait, no that's (flip flip f)
16:30:49 <glguy> is there some -funbox-strict-fields or something I could try?
16:31:39 <sorear> you might try making the array size a constant
16:31:42 <mauke> -funbox sounds fun
16:32:04 <sorear> (to allow optimization of your explicit bounds checks)
16:32:05 <glguy> sorear: I'm compiling with primes4000000 = primes (60000000 :: Int)
16:32:14 <glguy> so it knows what the value will be..
16:32:22 <glguy> should I not parameterize on the upper limit?
16:32:23 <sorear> is primes exported?
16:32:31 <glguy> toplevel
16:32:33 <glguy> all in one file
16:32:40 <sorear> use module Main(main) where, see if that makes a difference
16:32:59 <sorear> also look at unsafe{Read,Write}Array
16:33:11 <glguy> where would I fit those in?
16:33:19 <sorear> I expect the latter will make a *huge* difference
16:33:27 <sorear> ?type unsafeReadArray
16:33:29 <lambdabot> Not in scope: `unsafeReadArray'
16:33:43 <glguy> but give me an example in my code where I could do that
16:33:47 <glguy> ?hoogle unsafeReadArray
16:33:48 <lambdabot> No matches found
16:35:02 <sorear> replace the readArray with unsafeReadArray or whatever it's called, and writeArray with unsafeWriteArray
16:35:25 <glguy> module Main (main) where
16:35:27 <glguy> no efect
16:36:16 <Mynstral> How can I pass arguments to a compiled program (anything like C argv kind of stuff?)
16:36:25 <dons> getArgs
16:36:32 <Mynstral> Thanks
16:36:35 <sorear> ?hoogle unsafeRead
16:36:36 <lambdabot> No matches found
16:36:42 <dons> main = do [one,two,three] <- getArgs ; print three
16:36:48 <glguy> readArray marr i = do (l,u) <- getBounds marr unsafeRead marr (index (l,u) i)
16:36:57 <glguy> so unsafeRead and unsafeWrite just do bounds checking
16:37:24 <glguy> but that shaved maybe 1 second off
16:38:39 <sorear> you only gained 1 second by dropping bounds checking ?
16:38:41 <glguy> sorry, don't do bounds
16:38:42 <glguy> yeah
16:38:51 <glguy> i need to profile :)
16:38:57 <glguy> I don't think that was the slowdown
16:43:05 <glguy> pop quiz, what flags turn on profiling?
16:43:42 <bd_> -p, -auto{-all}?
16:43:56 <bd_> --enable-{executable|library}-profiling in cabal
16:44:18 <bd_> helps that I used these last night :)
16:44:52 <alexj__> is there a way to catch arbitrary exceptions outside the IOMonad as long as you return a pure value?
16:44:58 <glguy> -prof -auto-all , run with -RTS +prof, lets see what happens
16:45:06 <bd_> glguy: +RTS -p :)
16:45:14 <alexj__> shapr: am trying to implement the error handling we just discussed.
16:45:26 <sorear> unsafePerformIO (but you better mean it about returning a pure value)
16:45:28 <bd_> alexj__: Catching the bottom you mean? It's possible, but I don't know if it's safe
16:45:30 <lightstep> alexj__, you can do it with deepSeq and unsafePerformIO
16:45:32 <bd_> something like
16:45:33 <sorear> Either is much safer
16:45:43 <bd_> ... yeah, unsafePerformIO + catchIO
16:45:50 <bd_> better to use MonadError
16:46:36 <alexj__> I want to catch when the user does something like (head [])
16:47:15 <alexj__> and send back 500
16:47:45 <bd_> alexj__: catching something precisely like that can only be done (not very safely) with unsafePerformIO and etc, but - I don't know if this  will catch all forms of the bottom (certainly it won't catch nontermination)
16:47:49 <bd_> however
16:47:52 * allbery_b rather wishes more of those exceptions actually used MonadError, so things *can* be caught without having to do them in IO.  except of course that then you're forced to provide a MonadError context of some kind... feh
16:47:52 <bd_> [] <- something
16:47:57 <bd_> failed matches with that can be caught
16:47:58 <xic> alexj__: are you the head boss of happs?
16:48:07 <sorear> sending back 500 is far better done in the IO monad
16:49:02 <glguy> users don't take head [], programmers do
16:49:09 <sorear> (you mean HTTP 500 'Internal server error?')
16:49:11 <emu> how does the ghc gc interact with multiple threads
16:49:17 <sorear> badly
16:49:37 <sorear> iirc it stops 'em all and then runs in a single thread
16:49:47 <emu> that would explain some behavior
16:49:47 <AStorm> :P
16:49:56 <bd_> sorear: multithreaded collection's not implemented yet?
16:50:05 <sorear> so if you have a 500-core machine, you'll be spending a LOT of time with 1 core in GC and 499 idle
16:50:12 <AStorm> Huh, that's almost as broken as Python's threading
16:50:23 <sorear> bd_ not yet, iirc it's an intern's assignment
16:50:42 <bd_> ic
16:50:45 <alexj__> xic: yes I am the head boss of happs
16:51:17 <alexj__> sorear: the user provides a handler for some server activity.  if the handler has an error I want to send back a 500 and not fail to send a response.
16:51:55 <mbishop> didn't I hear about MSR funding the SMP/multithread stuff?
16:52:21 <xic> alexj__: cool. is it possible to use happs without persistent state, only with in-memory state?
16:52:46 <alexj__> yes.  you just need a null saver.
16:52:55 <alexj__> not easy in the default config.
16:52:59 <alexj__> but possible if you really want it.
16:53:12 <alexj__> the other approach is maintain state in /tmp
16:53:20 <alexj__> which is probably the way to go.
16:53:33 <xic> alexj__: ok. is it possilble to use a regular database?
16:53:35 <alexj__> persistent state costs you almost nothing in terms of perfomanc.
16:53:43 <alexj__> xic: yes.
16:53:47 <dons> mbishop: yeah, MS is funding some of the researchers working on smp and data parallell haskell. gives us a good head start :)
16:53:51 <alexj__> mutjida is doing so.
16:54:08 <alexj__> so the answer on catching exceptions?
16:54:18 <xic> alexj__: is the happs server also meant to serve static images?
16:54:41 <alexj__> foo f = f 1`catch??` serverError
16:54:46 <bd_> alexj__: if you create a bottom sequenced into IO, you can `catchIO` it. For example: catchBottom b f = (b `seq` return b) `catchIO` f
16:54:57 <bd_> but I don't know if this is completely safe
16:55:01 <bd_> better than nothing though
16:55:17 <Botje> @pl \x -> isLetter x || isSpace x
16:55:17 <lambdabot> liftM2 (||) isLetter isSpace
16:55:25 <Botje> ooh :)
16:55:38 <alexj__> bd: ok
16:55:53 <alexj__> xic: yes you can serve static images with HAppS.
16:56:11 <alexj__> take a look at the example fileserver code in HAppS.Protocols.SimpleHTTP2
16:56:14 <bd_> alexj__: note that this only catches bottom in the outermost... thingy. I think someone mentioned deepSeq...?
16:56:17 <bd_> :t deepSeq
16:56:19 <lambdabot> Not in scope: `deepSeq'
16:56:20 <xic> alexj__: but is the performance ok?
16:56:40 <alexj__> a test of an earlier version beat apache.  but have not tested recently.
16:57:17 <xic> interesting
16:57:22 <alexj__> bd: I'd like to catch bottom inside the MACID monad.
16:57:37 <bd_> alexj__: You can use unsafePerformIO with that
16:57:38 <alexj__> the MACID monad is a state monad.
16:58:18 <sorear> is it IO-based?
16:58:22 <bd_> MACID is based on STM, isn't it?
16:58:31 <alexj__> yes.
16:58:38 <alexj__> catchEv is really catchSTM
16:58:44 <sorear> you can catch exn's in STM
16:58:55 <sorear> catching bottom is done using evaluate
16:58:57 <bd_> pureCatchBottom b f = unsafePerformIO $ (b `seq` return b) `catchIO` \e -> return $ f e
16:59:03 <alexj__> it doesn't appear to be working.
16:59:11 <bd_> :t evaluate
16:59:13 <lambdabot> Not in scope: `evaluate'
16:59:30 <sorear> :t Control.Exception.evaluate
16:59:32 <lambdabot> forall a. a -> IO a
16:59:35 <alexj__> I am in STM but catchSTM appears not to be catching (read "asd"::Int)
16:59:59 <alexj__> perhaps it is really a bug in my code.
17:00:02 <sorear> did you force evaluation?
17:00:13 <sorear> use evaluate or (ick) return $! x
17:00:45 <alexj__> rspErr parts req = rsp parts req `catchEv` (Right . sresult 500 . show)
17:00:46 <glguy> OMG!!
17:00:56 <alexj__> rsp is runServerParts
17:01:10 <glguy> primes to 60million in 10 seconds
17:01:15 <bd_> hm actually
17:01:22 <bd_> Prelude System.IO.Unsafe System.IO> let pureCatchBottom b f = unsafePerformIO $ ((b `seq` return b) `catch` \e -> (return $ f e))
17:01:26 <bd_> Prelude System.IO.Unsafe System.IO> pureCatchBottom undefined Right
17:01:28 <bd_> *** Exception: Prelude.undefined
17:01:31 <bd_> why doesn't that work...?
17:01:36 <glguy> wait, 7 seconds
17:01:38 <glguy> sorear: I found it
17:01:51 <alexj__> sorear: does that make sense?
17:01:58 <glguy> ^ 2 is SLOW AS SHIT
17:02:45 <glguy> instead of doing 6 (^2), I do let x' = x * x; y' = y * y
17:02:50 <glguy> and use x' and y' three times each
17:03:10 <glguy> and it shaved 50 seconds :)
17:03:24 <sorear> yay CSE!
17:03:24 <glguy> ?type ( (^), (^^), (**))
17:03:27 <lambdabot> forall a b a1 b1 a2. (Integral b, Num a, Integral b1, Fractional a1, Floating a2) => (a -> b -> a, a1 -> b1 -> a1, a2 -> a2 -> a2)
17:04:05 <sorear> glguy: try factoring out mod n 12, that's being computed a lot
17:04:15 <sorear> nm, idiot me
17:04:17 <glguy> oh yeah, ok
17:04:19 <glguy> OH
17:04:22 <glguy> yeah, they are different
17:04:25 <glguy> I made taht mistake too
17:04:26 <dons> glguy: why not a shiftL ?
17:04:30 <glguy> i need to rename those
17:04:39 <dons> > 1 `shift` 7 :: Int
17:04:39 <glguy> dons: shiftL is * 2
17:04:41 <lambdabot>  128
17:04:57 <glguy> I need squared
17:04:59 <dons> oh, me scrolls up and sees "^ 2" above "*"
17:05:05 <dons> :}
17:05:15 * glguy renames the 3 different n's
17:05:38 <dons> its a good idea to check the generated C if you start caring about which primops are used
17:05:38 <lightstep> toggle can be implemented with modifyArray
17:05:51 <glguy> where is modifyArray?
17:05:57 <glguy> i only know modifySTRef
17:06:01 <glguy> or modifyIORef
17:06:05 <lightstep> i'm not sure it's there
17:06:06 <sorear> yeah, maybe you'll be able to do a xor toggle
17:06:08 <shoffsta> is it possible to pattern-match several patterns in a lambda-expression?
17:06:16 <shoffsta> ie. is there a nicer syntax for '\x -&gt; case x of (y:_) -&gt; ...; y -&gt; ...'
17:06:24 <glguy> shoffsta: only with a case
17:06:29 <shoffsta> oh, thanks
17:06:35 <glguy> ?hoogle modifyArray
17:06:37 <lambdabot> No matches found
17:08:08 <bfulgham> How can one add additional include directories to those typically searched by Cabal's build system?
17:08:09 <Excedrin> modifyArray arr i f = readArray arr i >>= \y -> writeArray arr i (f y)
17:08:22 <glguy> toggle a = writeArray sieve a . not =<< readArray sieve atoggle a = writeArray sieve a . not =<< readArray sieve a
17:08:26 <glguy> oops
17:08:27 <glguy> toggle a = writeArray sieve a . not =<< readArray sieve a
17:08:31 <Excedrin> from apfelmus's mail to haskell@
17:08:40 <glguy> that's what I had ^
17:10:21 <glguy> up to 2 billion in 30 seconds now
17:11:01 <glguy> to go to Excedrins 4 billion, i'd need unsigned ints
17:11:06 <glguy> (how do you do that in haskell?)
17:11:10 <gvdm_other> where is this code?
17:11:13 <glguy> > maxBound :: Int
17:11:15 <lambdabot>  2147483647
17:11:16 <gvdm_other> so that I may peer at it
17:11:25 <glguy> OH
17:11:26 <glguy> nevermind
17:11:27 <glguy> lol
17:11:29 <sorear> > maxBound :: Word32
17:11:31 <lambdabot>  4294967295
17:11:41 <glguy> > 10^9 :: Int
17:11:43 <lambdabot>  1000000000
17:11:50 <glguy> > 4 * 10^9 :: Int
17:11:52 <lambdabot>  -294967296
17:12:05 <dons> > maxBound :: Word64
17:12:06 <glguy> does STUArray Word32 Bool exist?
17:12:07 <lambdabot>  18446744073709551615
17:12:14 <gvdm_other> unsigned treated as signed?
17:12:22 <dons> > maxBound :: Integer --  ;)
17:12:23 <lambdabot>   add an instance declaration for (Bounded Integer)
17:12:24 <lambdabot>     In the expression: ma...
17:12:28 <gvdm_other> I didn't think Haskell treated ints like that
17:12:30 <sorear> glguy: Ix a => STUArray a Bool exists
17:12:40 <lisppaste2> glguy annotated #34185 with "xisting sieve code" at http://paste.lisp.org/display/34185#2
17:12:54 <sorear> STUArray is polymorphic in the index
17:13:35 <glguy> ok then I'll time 4 billion with word32 indexing
17:13:55 <glguy> 51 meg mem usage for the array :)
17:14:32 <glguy> isn't there already a shootout program to do this?
17:14:43 <sorear> @where shootout
17:14:43 <lambdabot> http://shootout.alioth.debian.org/
17:14:51 <glguy> 1:20 for 4bil
17:15:07 <glguy> so... since I've started, my final time is about the same, but I've gone from 60 mill to 4 bil
17:15:28 <Excedrin> shootout has to do sieve of Eratosthenes
17:15:34 <glguy> oh
17:16:31 <Excedrin> http://shootout.alioth.debian.org/gp4/benchmark.php?test=nsieve&lang=ghc&id=3
17:16:33 <lambdabot> Title: nsieve Haskell GHC #3 program | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Comput ..., http://tinyurl.com/y4wbx4
17:16:58 * ptolomy wonders when the shootout folks will start using the 6.6 code.
17:17:19 <dons> its on there now
17:17:23 <dons> we can use 6.6 today
17:17:26 <Excedrin> why is the other nsieve an "interesting alternative program"?
17:17:30 <dons> time to submit some updated entries!
17:17:48 <dons> Excedrin: it should say at the bottom somewhere (probably not the same algo)
17:18:51 <Excedrin> it says, "NOT ACCEPTED: Is this a bitset?"
17:19:24 <dons> oh, did we get disqualified?
17:20:13 <sorear> yes
17:20:22 <dons> ah, it is a bitset. it shouldn't have been disqualified
17:20:28 <dons> (taht was the whole point)
17:20:35 <sorear> IOUArrray a Bool is a bitset, and nsieve specifies unpacked array.
17:20:48 <sorear> in the problem description
17:21:03 <dons> "boolean flags (don't use bit flags)"
17:21:14 <dons> it uses boolean flags
17:21:15 <dons> no?
17:21:23 <dons> that the compiler happens to use rules to turn into bits
17:21:33 <dons> *sigh*
17:21:40 <lightstep> so you have to use Word8 and encode truth values with that?
17:22:15 <AStorm> Idiocy :P
17:22:15 <dons> the current valid version is doing the same thing, just slower
17:22:19 <glguy> is there a better way to write this?
17:22:20 <glguy> primesList = 2:3:[a | (a,True) <- assocs $ primes 60000000]
17:22:28 <dons> arr :: IOUArray Int Bool
17:23:20 <dons> sorear: seems to me this asks for an array of Bool, no:
17:23:22 <dons>   * create a sequence of M boolean flags (don't use bit flags)
17:23:22 <dons>   * for each index number
17:23:22 <dons>       + if the flag value at that index is true
17:23:22 <dons>           o set all the flag values at multiples of that index false
17:23:24 <dons>           o increment the count
17:23:32 <dons> (doesn't matter if ghc knows how to unbox and pack)
17:23:40 <dons> it does matter that you *can't* explicitly use Bits
17:24:00 <AStorm> Go bash them, yah.
17:24:03 <dons> so, the current valid entry is valid, and so is the one that is disqualified
17:24:14 <dons> (since athey all jsut use a sequence of M boolean flag)
17:24:15 <AStorm> I wonder why some other shootout problems Error out.
17:24:21 <dons> missing libraries, probably
17:24:26 <dons> no mtl?
17:24:44 <dons> anyway, we should just resubmit cleaned up versions of these. explaining why they're valid
17:24:59 <AStorm> k-nucleotide ran out of memory...
17:24:59 <dons> (no wonder the haskell ranking dropped, people randomly disqualify code htey don't understand :(
17:25:09 <dons> yeah, we've a better bytestring version for that
17:25:14 <dons> ?wiki Shootout
17:25:15 <lambdabot> http://www.haskell.org/haskellwiki/Shootout
17:25:16 <dons> is the place to start
17:26:39 <AStorm> But why no mtl?
17:27:01 <AStorm> and I wonder why fasta failed
17:27:05 <AStorm> Looks like it works :P
17:27:09 <dons> Isaac installed ghc 6.6 from src, but failed to build the extra libs
17:27:42 <bfulgham> The debian box should have everything you need for 6.6 on it.  If you are missing a library, just let me know what it is.
17:27:51 <dons> hey :)
17:27:55 <dons> yeah, the debian box is fine
17:28:07 <dons> the gentoo box is missing mtl (and I've told Isaac about that)
17:28:16 <bfulgham> I'll ask Isaac to bump the Gentoo box with the MTL stuff.
17:28:34 <dons>    
17:29:06 <dons> I'll try to submit some updated entries during the hackathon next week
17:29:18 <glguy> dons: which arrays store bools  packed ?
17:29:19 <dons> I've got some nice 6.6+bytestrings  entries lying around
17:29:33 <dons> glguy: UArray a Bools
17:30:02 <bfulgham> Cool!  I'll try to run the Debian box tonight or so, then pick up the revisions.  The recent Linux Kernel update screwed up the process accounting stats in /proc which invalidated some measurements, so I've switched it off until they build a new kernel image with the patch.
17:30:10 <dons> glguy:     unsafeAt (UArray _ _ arr#) (I# i#) =
17:30:11 <dons>         (indexWordArray# arr# (bOOL_INDEX i#) `and#` bOOL_BIT i#)
17:30:11 <dons>         `neWord#` int2Word# 0#
17:30:20 <ptolomy> I know that I submitted a Bytestring k-nucleotide version..
17:30:25 <dons> bfulgham: huh
17:30:59 <ptolomy> Oh, there it is.
17:31:17 <ptolomy> "ghc-6.6: failed to create OS thread: Cannot allocate memory"
17:44:00 <dpiponi> http://cgi.ebay.com/1857-Monads-illustrated_W0QQitemZ320054350656QQihZ011QQ
17:44:03 <lambdabot> Title: eBay: 1857 Monads illustrated (item 320054350656 end time Jan-25-07 08:39:24 PST ..., http://tinyurl.com/yb5bl3
17:45:42 <glguy> Excedrin: are you sure you searched up to 4 billion?
17:45:59 <glguy> (since that would take a minimum of 488meg for the array)
17:46:36 <Excedrin> 50847534 primes up to 1000000000.
17:46:52 <Excedrin> Overall seconds: approximately 1.797985.
17:47:08 <sorear> The shootout should be more like the ICFP... every month they publish a problem and the md5sum of the input, collect entries, and publish the fastest from each language.
17:48:03 <Excedrin> it uses about 1MB
17:48:14 <glguy> oh, what method is it using then
17:49:33 <dons> dpiponi: hehe
17:52:34 <malebria> Is there a place with comparison between functional (and maybe non-functional) languages?
17:52:45 <malebria> In a very sintatic way.
17:53:20 <dons> syntactic comparision? there must be plenty out there in google land
17:53:42 <dons> its the semantics that matter though ;)
17:54:01 <malebria> dons: Not just syntatic, but the use, like what each is good for...
17:54:03 <malebria> pro/cons
17:54:20 <ptolomy> malebria: Hmm.. the diversity of syntax in either group makes such a comparison difficult.. so do the ongoing "Is X a functional language?" battles
17:54:29 <dons> the internets is full of people discussing this stuff :)
17:54:52 <dons> there's no great authority though
17:54:58 <monochrom> "pros/cons" are cheap comparisons.
17:54:59 <malebria> dons: I'm searching.. At first I tried comparison with lisp, haskell and scheme.
17:55:14 <Excedrin> glguy: does it need the entire array in memory during the entire run? I'm looking over this code and it looks like it holds a constant size array
17:55:17 <dons> lisp < scheme < haskell -- there you go!
17:55:17 <malebria> monochrom: sure they are, but they give some ideas of the cheap thoughts..
17:55:27 <dons> soley due to how they influenced each other
17:56:20 <monochrom> A certain language does not offer mutable variables.  Is this a pro or a con?
17:56:31 <dons> monochrom: which one?
17:56:42 <dons> Prolog?
17:56:43 <malebria> dons: I've read that blub text, and wondered about the differences between lisp and haskell.
17:57:01 <malebria> http://www.paulgraham.com/avg.html
17:57:02 <lambdabot> Title: Beating the Averages
17:57:02 <monochrom> I am trying to illustrate how bogus "pro" and "con" are.
17:57:04 <dons> static typing, and about 30 years of language development (that's a lot of features in the end)
17:57:21 <dons> lisp is like haskell crica 1980
17:57:28 <monochrom> I am also beginning to suspect that the cliche "the right tool for the right job" is a cheap shot.
17:57:46 <malebria> monochrom: not all of them are as cheap as this.
17:57:57 <dons> you could read, http://programming.reddit.com/goto?id=u719
17:58:00 <lambdabot> Title: On the Expressive Power of Programming Languages - Felleisen (ResearchIndex)
17:58:09 <malebria> dons: but in this text it cites about lisp macros as if they were a very hard thing to learn...
17:58:11 <dons> which gives some clues to a formal approach to creating a 'blub' hierarchy
17:58:18 <monochrom> Oh, certainly, when I was ten years younger, I thought they were not cheap.
17:58:28 <malebria> So hard that he could not describe it without 160 pages of introduction..
17:58:56 <ptolomy> Macros have their uses, but (in my view) they are mostly used to hack together features that are missing from the underlying language.
17:58:57 <malebria> monochrom: this is a very cheap one.
17:59:26 <dons> http://programming.reddit.com/goto?id=x2pw   :)
17:59:29 <lambdabot> Title: Neil Mitchell's Haskell Blog: Does Haskell need macros?
17:59:56 <Adamant> can Haskell even have macros if it wanted them?
18:00:06 <Adamant> I thought statically typed languages couldn't do them.
18:00:28 <jcreigh> Template Haskell exists.
18:00:38 <lightstep> ptolomy, you can say that LogicT is a poor man's nondeterminism engine
18:00:39 <ptolomy> Adamant: caml4p does it pretty well.
18:00:42 <Adamant> right, but that's not real macros, to my understanding.
18:00:58 <newsham> are any of the parsec bits accessible from lambdabot?
18:00:59 <Muad_Dib> Adamant: then what is a real macro?
18:01:08 <Adamant> a Lisp-style one
18:01:16 <lightstep> and that ReaderT cover up for the lack of dynamic scope
18:01:21 <Adamant> either CL or a syntax one.
18:02:15 <lightstep> Muad_Dib, a real macro system allows you define-record-type
18:02:17 <Excedrin> what? C preprocessor macros don't count?
18:02:17 <sorear> Haskell has macros
18:02:18 <jcreigh> umm...if "macros" means "lisp macros", then no, Haskell doesn't have them. :)
18:02:26 <sorear> {-# OPTIONS_GHC -cpp #-}
18:02:34 <sorear> {-# OPTIONS_GHC -pgmF m4 #-}
18:02:45 <Adamant> Excedrin, heck no. :)
18:03:07 <sorear> Haskell has macros - they're called HOFs.
18:03:08 <allbery_b> > Text.ParserCombinators.Parsec.testParser (Text.ParserCombinators.Parsec.char 'a') "a"
18:03:09 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.char'
18:03:34 <sorear> except, thanks to purity things only get evaluated once
18:03:40 <allbery_b> guess not
18:03:45 <newsham> pffftt.. HOFs are evaluated at runtime.
18:03:59 <allbery_b> > Text.ParserCombinators.Parsec.testParser (Text.ParserCombinators.Parsec.Char.char 'a') "a"
18:04:00 <sorear> {-# OPTIONS_GHC -O2 #-}
18:04:00 <lambdabot>   Not in scope: `Text.ParserCombinators.Parsec.Char.char'
18:04:25 <Philippa> sorear: now write me a function that does pattern-matching based on a constructor it's passed
18:04:26 <sorear> anyway, HOFs are better than macros because macros cause code bloat.
18:04:51 <Adamant> maybe. but Lisp has HOFs and real macros.
18:05:02 <sorear> (and CPU time is less valuable to me than disk space)
18:05:02 <Philippa> yeah, but lisp's strict
18:05:11 <Philippa> so you can't do as much with HOFs alone in it
18:05:23 <newsham> "macros cause code bloat"
18:05:25 <lightstep> macros cause code bloat? do you mean source or object code?
18:05:30 <sorear> object code
18:05:40 <Adamant> that is an interesting point. what does laziness buy you with regards to higher order functions?
18:05:49 <lightstep> then optimize for space. or use runhaskell
18:05:58 <newsham> adam: you can define control flow.
18:06:08 <monochrom> some macros are really HOFs needing laziness.
18:06:08 <Philippa> yep
18:06:11 <Excedrin> laziness is addictive
18:06:13 <lightstep> (which doesn't save object files)
18:06:15 <Philippa> in haskell you can write this and it works:
18:06:27 <newsham> in lisp you resort to macros to avoid evaluation when defining control flow
18:06:34 <Philippa> iff con tru fals = case con of {True -> tru; False -> fals}
18:06:47 <sorear> I know someone who works at a certain household-name company ... they use macros, and the binary of they're flagship (web) product is >4 *G* B
18:07:05 <newsham> sorear: well that proves it.  QED.
18:07:10 <Philippa> ...they have to've done something pretty fuckwitted there
18:07:13 <newsham> proof by single example.
18:07:22 <lightstep> Philippa, the equivalent of case is in the standard library of Smalltalk-80, which is strict. so laziness is not requires
18:07:25 <lightstep> *required
18:07:54 <newsham> light: in smalltalk wont tru and fals be evaluated before invoking iff?
18:08:07 <Philippa> lightstep: Smalltalk-80 has blocks, no? That being not far off laziness
18:08:16 <malebria> dons: thanks for the links.
18:08:20 <malebria> Good night.
18:08:22 <Adamant> I thought blocks were just closures
18:08:27 <lightstep> yes, they rely on not having eta-reduction
18:08:34 <Philippa> Adamant: right. *unevaluated* ones
18:08:37 <monochrom> mapM_ is a hof in Haskell and a macro in Lisp.  I prefer the former because it requires less education to achieve the same thing.
18:09:13 <newsham> .. there are still times i want stuff evaluated at compile time...
18:09:18 <Adamant> eh, I find Lisp and macros easiers to wrap my head around than some of the Haskell stuff.
18:09:19 <Philippa> (and yes, you can indeed build laziness in lisp by wrapping all your values in lambdas and passing something in to force them)
18:09:22 <_spydr_> anyone familiar with ghci on Intel MacBook?
18:09:24 <lightstep> monochrom, do you mean for-each?
18:09:25 <dons> and you stay in the host language. all the usual tools work, the type system works, and so on
18:09:35 <newsham> adam: perhaps thats due to more experience with lisp?
18:09:38 <monochrom> I mean mapM_.
18:09:41 <Philippa> "some of the haskell stuff" presumably includes some active research topics, no?
18:09:53 <Adamant> newsham, probably. I also think mathematical maturity is a factor
18:09:57 <lightstep> monochrom, then which list macro?
18:10:07 <Philippa> Adamant: yours, or the languages'?
18:10:08 <Adamant> i.e., the better you are at math, the more Haskell appeals.
18:10:08 <newsham> defining iff, when, mapM_, forM_, etc.. is really not very complicaed at all
18:10:11 <monochrom> Sorry, I don't know lisp terminologies.
18:10:12 <Adamant> Philippa, mine
18:10:24 <Adamant> I'm improving slowly.
18:10:44 <nornagon> ?src iff
18:10:45 <lambdabot> Source for this function is not available.
18:10:49 <nornagon> ?src mapM_
18:10:50 <lambdabot> mapM_ f as = sequence_ (map f as)
18:10:57 <lightstep> monochrom, i'd expect "bind" and "return" to be procedures. then mapM_ can be defined as a procedure too.
18:11:23 <nornagon> ?src sequence_
18:11:23 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:11:24 <newsham> ie:   loop 0 act = return (); loop n act = do { act; loop (n - 1) act }
18:11:31 <newsham> not a lot of math involved there.. easy to understand
18:12:02 <newsham> ?src repeatM_
18:12:03 <lambdabot> Source for this function is not available.
18:12:06 <newsham> ?src repeatM
18:12:06 <lambdabot> Source for this function is not available.
18:12:40 <newsham> ?src replicateM_
18:12:41 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
18:12:51 <newsham> ?src replicate
18:12:52 <lambdabot> replicate n x = take n (repeat x)
18:13:14 <dons> repeatM_ is forever
18:13:16 <newsham> not math intensive
18:13:20 <dons> forever a > a > forever a
18:13:25 <dons> =
18:13:30 <dons> >>
18:14:27 <nornagon> ?let a ^-^ b = "lol"
18:14:28 <lambdabot> Defined.
18:14:42 <monochrom> ^-^ is a cute face not lol.
18:14:52 <Adamant> yeah. I need to sit down with Hugs and work stuff when I get the chance, which will not be anytime soon.
18:15:02 <newsham> > 0 ^-^ "x"
18:15:04 <lambdabot>  "lol"
18:15:44 <newsham> > repeatM 3 (Just 2)
18:15:45 <lambdabot>   Not in scope: `repeatM'
18:15:55 <newsham> > replicateM 3 (Just 2)
18:15:57 <lambdabot>  Just [2,2,2]
18:16:14 <Excedrin> Adamant: your idea about math might be right, but I'm a mathematical cretin and I like Haskell. Haskell has actually inspired me to learn more math
18:16:22 <_spydr_> I'm trying to use the data keyword in ghci and I keep getting tis error:
18:16:24 <_spydr_> Prelude> data Pair a b = Pair a b
18:16:24 <_spydr_> <interactive>:1:0: parse error on input `data'
18:16:25 <_spydr_> Prelude>
18:16:37 <_spydr_> am I doing something wrong?
18:16:45 <monochrom> Sorry, can't do that in ghci.
18:16:58 <newsham> cant do data in ghci can you?
18:17:01 <dons> _spydr_: you have to define data types in a file
18:17:01 <_spydr_> is there a reason?
18:17:03 <dons> and :load/:reload them
18:17:05 <newsham> put it in .hs file and load it
18:17:06 <_spydr_> ahh
18:17:09 <Adamant> Excedrin, I have no idea, it's just a guess. "Functional" languages in general are doing that for me.
18:17:13 <augustss> ghci isn't quite up to that yet
18:17:22 <_spydr_> so an external file could be loaded to get teh desired effect then?
18:17:28 <monochrom> Yes, the reason is no one has time to implement more features into ghci.
18:17:31 <augustss> you'd have to go back to 1992 and use hbi to do that :)
18:17:32 <dons> since you're sitting in a top-level do block, defining new data values on the fly isn't going to play very nice
18:17:32 <newsham> spy: yup
18:17:36 <dons> augustss: hehe
18:17:41 <_spydr_> thx
18:18:06 <monochrom> This is great.
18:18:09 <Adamant> what is the usually preferred Haskell interpreter?
18:18:11 <Adamant> Hugs?
18:18:17 <monochrom> I prefer ghci
18:18:21 <dons> data T = T Int ; let x = T 8 ; data T = T [Int] ; case x :: T of T xs -> tail xs -- oh no!
18:18:25 <dons> ghci these days
18:18:40 <newsham> ghci4life
18:19:08 <newsham> that would make good finger tatoos.  on one hand "ghci" on another "life"
18:19:09 <monochrom> hugs is too fast
18:19:28 <dons> oh yeah, hugs is damn fast ;)
18:19:35 <dons> what with those raw src libraries :}
18:19:42 <Adamant> one of the things that conceptually jars me with ghci is the :command deal.
18:19:56 <monochrom> I just refer to startup time.
18:20:57 <nornagon> there's about 1 second difference.
18:21:49 <Adamant> ah. hugs does the same thing.
18:21:58 <monochrom> I am used to lengthy startup times of programs.  I ask for firefox and it takes a couple seconds, during which I ask for other programs.  But hugs is instantaneous and confuses my multitasking habit!
18:22:25 <monochrom> I am just kidding.
18:22:50 <sorear> I'm used to the instant gratification of compiled C programs.  The GHC RTC is too slow for me, never mind GHCi.
18:22:56 <sorear> *RTS
18:23:25 <sorear> runhaskell - forget it, I ghc --make my Setup.lhs's.
18:23:35 <lightstep> use jhc then. it'll cut off all the unnecessary stuff, and compile to plain C
18:23:39 <newsham> used to the instant gratification of building binaries?
18:24:00 <Adamant> ok. I know Haskell interpreters are in the IO monad. is that why they use the ':command' deal for operating on things?
18:24:05 <monochrom> I have a ghc-compiled program and it's instantaneous startup too.
18:24:15 <sorear> monochrom: ooh?
18:24:17 <dons> Adamant: what do you mean "for operating on things" ?
18:24:45 <newsham> i think he's complaining about having to use colon for :load and :type and such?
18:25:07 <sorear> apparently it's been a while, my GHC-made noop runs in 0.005s
18:25:13 <Adamant> dons, well, say I have a Scheme REPL. if I want to load a Lisp file, I do (read-lisp-file "/blah/foo")
18:25:25 <dons> ah right. no, you're not in a lisp/scheme top level
18:25:34 <Excedrin> Adamant: :load (et all) isn't a function
18:25:36 <monochrom> Yeah, 0.005s or thereabouts.  I feel it is fast enough for startup.
18:25:40 <dons> it could be made to look like that though
18:25:44 <Adamant> right, I'm trying to understand how the interpreter works.
18:25:47 <dons> i.e. run ghci-api and call the functions directly
18:25:53 <sorear> Somehow I thought it was more like 0.3s
18:26:28 <lightstep> haskell is different from lisp by not being an operating system
18:26:29 <sorear> OTOH, runhaskell takes 0.65s - *far* too long
18:26:41 <newsham> > Just "goofing" ^-^ Right 12345
18:26:43 <lambdabot>  "lol"
18:27:01 <monochrom> Yeah, ghci and runghc are slower.
18:27:13 <kpreid> @type (^-^)
18:27:15 <lambdabot> Not in scope: `^-^'
18:27:19 <kpreid> @type (L.^-^)
18:27:21 <lambdabot> Couldn't find qualified module.
18:27:33 <kpreid> > typeOf (^-^)
18:27:35 <lambdabot>  Add a type signature
18:27:39 <emu> most lisp systems provide similar shortcuts, for example, allegro has :load too
18:27:47 <dons>   ("load",  keepGoingPaths loadModule_, False, completeHomeModuleOrFile),
18:27:50 <kpreid> >Nothing ^-^ Right 0
18:27:55 <kpreid> > Nothing ^-^ Right 0
18:27:57 <lambdabot>  "lol"
18:28:06 <kpreid> > undefined ^-^ undefined
18:28:08 <lambdabot>   Not in scope: `^-^'
18:28:16 <kpreid> wha?
18:28:26 <dons> the joys of @undefine
18:28:29 <kpreid> ah
18:28:36 <newsham> > 1 ^-^ 1
18:28:37 <dons> someone playing silly buggers
18:28:37 <lambdabot>   Not in scope: `^-^'
18:29:09 <kpreid> dons: btw, I noticed that @let doesn't overwrite old definitions for a name
18:29:16 <dons> yeah
18:29:24 <dons> I suppose it could do that
18:29:31 <emu> sorear: runhaskell has to compile/load the file
18:29:33 <dons> (keep its own map, rewrite the file every time)
18:29:34 <Adamant> ah. so, I can just call the Haskell functions that read and load files, etc. and just ignore the :command commands.
18:29:40 <kpreid> @let x 0 = 1
18:29:41 <lambdabot> Defined.
18:29:43 <kpreid> @let y = 2
18:29:45 <lambdabot> Defined.
18:29:49 <kpreid> @let x 1 = 3
18:29:50 <lambdabot> <local>:3:0:     Multiple declarations of `L.x'     Declared at: <local>:1:0 ...
18:29:52 <sorear> emu: I know, I want faster turnaround
18:30:03 <emu> sorear: work in ghci?
18:30:04 <sorear> if only GHCi started up faster
18:30:26 <emu> what are you using, a pentium I?
18:30:45 <newsham> one laptop per child, emu
18:30:46 <sorear> P4 2Ghz
18:30:54 <lightstep> ghci takes lots of time to start up
18:31:11 <emu> sure, you only start it once per day though
18:31:13 <newsham> http://www.laptop.org/
18:31:15 <lambdabot> Title: One Laptop per Child
18:31:20 <sorear> echo :q | time ghci  -->  0.64s user
18:31:36 <dons> yeah, I get 0.51
18:31:39 <dons> hugs is 0.16
18:31:52 <lightstep> i get 0.97
18:31:58 <emu> you can take a profiler to that if you want, but, 0.64s once per day is well... small time?
18:32:19 <emu> > 0.64 / (3600*24) * 100
18:32:19 <monochrom> I don't think anyone is seriously complaining or resenting.
18:32:21 <lambdabot>  7.407407407407407e-4
18:32:25 <sorear> emu: I run GHCi as a user program, its not my OS yet.
18:32:34 <sorear> Linux boots too slow!
18:32:44 <emu> what, you're not booting ghci?!
18:32:44 <dons> maybe we should have ghci-server start from /etc/rc
18:32:45 <newsham> emacs boot slowly too
18:32:47 <Adamant> Robson!
18:32:49 <emu> linux init=/usr/bin/ghci
18:32:50 <lightstep> i run ghci to do some computation or to check a type, then instinctively close it
18:33:12 <sorear> ghci-server is *not* the solution.
18:33:24 <sorear> there must be some reason it takes soooo long
18:33:27 <dons> how about not loading base on start up
18:33:28 <emu> yea i run ghci from within my emacs session which runs all day ...
18:33:32 <monochrom> the solution is to implant a ghc chip in your head
18:33:32 <lightstep> ghci-server is lim sup
18:33:34 <dons> (yeah, the dynamic linker)
18:34:15 <monochrom> imagine, you will be able to write pages and pages of haskell code on paper and it will compile the first time!
18:34:23 <sorear> am I the only one who thinks programs should start quickly?
18:34:37 <lightstep> only clients
18:35:19 <sorear> DECENTRALIZE!
18:35:19 <newsham> why bother compiling it if you already know its right?
18:35:35 <monochrom> because you're shipping the code.
18:36:27 <emu> if you want a fast starting ghci, ghc is right there
18:36:51 <monochrom> I am actually glad that we sometimes forget the bottomline of delivering an executable program.  It is not very relevant.
18:37:01 <emu> maybe a ghcq, for "ghc query"
18:37:47 <lightstep> newsham, to distribute your superflous Olegs to the rest of the world
18:37:49 <dons> mm, I think I might write a little ghci server. just forks on login, and resets on 'quit'
18:37:59 <dons> could save me 5 seconds a day
18:38:23 <emu> better time how long it takes to write it so that you know when you've finally gone positive on the savings
18:38:45 <jcreigh> GNU screen FTW. :)
18:38:45 <dons> I know how to writ eit already though (after writing a lambdabot-server)
18:38:51 <dons> so should be pretty easy
18:39:04 <monochrom> how do you fork ghci?
18:39:16 <dons> from .xsession
18:39:34 <dons> it'll fork ghc-server. then ghci is just an alias to call into hte ghc-server process
18:39:43 <monochrom> are you not making ghci fork itself?
18:39:55 <dons> no
18:40:10 <dons> anand when you quit, it could even quit ghci, and restart it in the background
18:40:15 <dons> so its ready for next time you need it
18:40:28 <monochrom> Excellent!
18:40:48 <dons> so basically it'll behave just like ghci, but have already started it in the background for you
18:41:02 <monochrom> GHCi is quit.  Long live GHCi?
18:41:43 <newsham> why not just fire up a normal ghci as part of your X login?
18:41:52 <newsham> i'm not seeing what building a custom program to do this is buying you
18:42:03 <dons> since if you quit ghci you've lost the advantage
18:42:08 <dons> you want  it to restart in the background
18:42:21 <newsham> while : ; ghci; done
18:42:29 <dons> now if we save 1 sec per ghci process, x 300 people in this channel
18:42:37 <newsham> while : ; xterm -e ghci; done
18:42:40 <dons> that could be 3000 seconds a day...
18:43:25 <newsham> put that into yer xinitrc?
18:43:31 <monochrom> You have a girlfriend and you don't want her to say "why can't I make this ghci window go away, why does it keep coming back to haunt me" when she happens to work on your computer. :D
18:43:38 <lightstep> you can do better: implement @type with ghc -ddump-types
18:43:43 <dons> monochrom: exactly
18:43:49 <lightstep> this also saves computer time
18:43:54 <dons> just run ghci-server as a daemon, and ghci talks to it
18:43:59 <newsham> if your girlfriend doesnt appreciate ghci, time to get another?
18:44:00 * sorear thinks making the expensive part of ghci-startup optional is a better idea
18:44:03 <dons> lightstep: ah good idea
18:44:28 <newsham> dons: seems a heavy handed replacement for 15 char sh script
18:44:36 <dons> sorear: how about dumping the ghci image after loading the base libraries to disk
18:45:08 <jcreigh> alias ghci='screen -S ghci -dR ghci'
18:45:18 <jcreigh> *ghci :)
18:45:34 <dons> yeah that's just about it.
18:45:37 <newsham> how about implementing detach/reattach for X sessions
18:45:41 <newsham> so you have presistence
18:45:44 <newsham> and never have to quit ghci?
18:45:55 <monochrom> Solaris has done that.
18:46:02 <jcreigh> or -xR if you want to attach the same ghci in multiple places instead of forcing a detach somewhere else.
18:46:03 <dons> but it needs to restart ghci in the background
18:46:03 <monochrom> Except no one uses Solaris.
18:46:09 <newsham> general solution instead of one-off
18:46:15 <emu> i remember reading about something called "xmove" which did that
18:47:13 <dgriffi3> you could try freenx
18:47:23 <newsham> screen -S ghci -dR sh -c "while : ; ghci; done"
18:48:03 <monochrom> The Solaris scheme is pretty cool.  You insert your smartcard at a workstation and that logs you in.  (You can add a password stage too.)  Then you start your programs and open your windows.  Then you just remove your smartcard and you're out.  Then you move to another workstation and everything is there!
18:48:10 <augustss> @quote
18:48:10 <lambdabot> merus says:  Mathematics is totally full of women.
18:48:26 <newsham> Xnest?
18:48:51 <monochrom> I don't know what it's called.
18:49:52 <emu> we have one Sun Ultra 10 runnign SunOS 5.something.  I think the reason why it's still running is nobody knows the root password to shut it down anymore, and so we just forget it exists.
18:50:09 <Excedrin> you can use xvnc to do that
18:50:09 <newsham> its solaris, just own it up ;-)
18:50:23 <monochrom> ha
18:50:48 <dgriffi3> monochrom: sunrays can do that
18:51:01 <monochrom> Yeah, they're Sun Rays.
18:51:05 <newsham> emu: http://www.metasploit.com/projects/Framework/
18:51:06 <lambdabot> Title: The Metasploit Project
18:51:23 <newsham> point'n'click solaris owning.
18:52:01 <ianh> @paste
18:52:01 <lambdabot> http://paste.lisp.org/new/haskell
18:54:21 <Excedrin> Xnest is neat
18:56:44 <glguy> Excedrin: the algorithm for atkins sieve I found seems to need the whole array
18:56:54 <glguy> Excedrin: but maybe there is a way to partition the problem...
18:57:31 <Excedrin> glguy: if you don't mind reading C, you should take a look at primegen
18:57:38 <glguy> Excedrin: link?
18:57:40 <glguy> C is fine
18:57:56 <Excedrin> http://cr.yp.to/primegen.html
18:57:56 <iah> hello, #haskell
18:58:08 <iah> I'm writing a continuation-based web server, and I've run into a bit of a problem
18:58:41 <iah> I'm trying to make a function 'embed' that takes a web page, and makes it run "atomically"
18:58:44 <iah> that is
18:59:00 <iah> if you call a page in the embedded page, only that page is replaced, not the entire thing
18:59:05 <lisppaste2> ianh pasted "continuation fun" at http://paste.lisp.org/display/34197
18:59:16 <iah> i have a version that kind of works
18:59:43 <iah> but the thing is, the exit continuation for each embedded block only remembers the output of the embeds above it
18:59:58 <iah> if you run the code in that paste, you'll see what I mean
19:00:06 <iah> and I'm not sure how to fix that
19:02:56 <iah> I'm not even sure if it's possible using just monads
19:04:48 <iah> it seems like there should be some sort of hackery involving laziness by which I could get it to work
19:04:51 <glguy> Excedrin: all I can say is 'wow'
19:04:56 <iah> but I'm just not smart enough to see it
19:13:37 <seliopou> iah: just use the PLT web server :P
19:14:06 <iah> seliopou: but it's not in haskell
19:14:20 <iah> hehe
19:14:22 <seliopou> iah: it's already written
19:15:34 <seliopou> I don't think I understand the problem you're describing, but good luck finding an answer
19:15:49 <iah> thanks
19:15:50 <seliopou> oh
19:15:52 <seliopou> I see
19:16:07 <seliopou> you make a send call in the middle of the page, yes?
19:16:54 <iah> a send call?
19:17:16 <seliopou> in the PLT web server, you use send/suspend to send a response and capture the current continuation
19:18:01 <seliopou> so you're executing a page, and you come across one of these calls
19:18:05 <seliopou> so what's your problem now?
19:19:14 <iah> well, the Page monad carries around an exit continuation, which is called when you're done rendering the page
19:19:36 <iah> usually this is just set by a call/cc when you start rendering
19:19:52 <iah> but in the embed, it updates it with the current continuation
19:20:15 <iah> but the problem is the current continuation doesn't include any of the stuff after the embed
19:20:34 <newsham> trying out irssi.
19:20:50 <iah> I'm trying for more of a seaside-ish interface than this plt one, I guess
19:21:34 <iah> send/suspend isn't composable
19:22:24 <seliopou> not familiar with seaside
19:22:31 <seliopou> and I unfortunately must go now
19:22:33 <seliopou> again, good luck
19:36:59 <sorear> @seen
19:37:00 <lambdabot> Lately, I have seen newsham, pkhuong and sorear.
19:37:03 <sorear> @users
19:37:03 <lambdabot> Maximum users seen in #haskell: 296, currently: 268 (90.5%), active: 33 (12.3%)
19:37:51 <glguy> bah
19:39:00 <ClaudiusMaximus> :t check
19:39:02 <lambdabot> Not in scope: `check'
19:41:23 <ClaudiusMaximus> ?help check
19:41:24 <lambdabot> check <expr>
19:41:24 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
19:41:42 <ClaudiusMaximus> ?hoogle QuickCheck
19:41:44 <lambdabot> Test.QuickCheck :: module
19:41:44 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
19:42:03 <ClaudiusMaximus> ?docs Test.QuickCheck
19:42:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
19:44:47 <ClaudiusMaximus> :t sortBy
19:44:49 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
19:45:01 <ClaudiusMaximus> ?src Ordering
19:45:02 <lambdabot> data Ordering = LT | EQ | GT
19:45:46 <ClaudiusMaximus> > let o a b = LT in sortBy o "qxmsoaiuqzieotyjgna"
19:45:48 <lambdabot>  "qxmsoaiuqzieotyjgna"
19:45:55 <ClaudiusMaximus> > let o a b = GT in sortBy o "qxmsoaiuqzieotyjgna"
19:45:57 <lambdabot>  "angjytoeizquiaosmxq"
19:46:23 <ClaudiusMaximus> > let o a b = EQ in sortBy o "qxmsoaiuqzieotyjgna"
19:46:25 <lambdabot>  "qxmsoaiuqzieotyjgna"
19:52:44 <nornagon> > let o a b = LT in sortBy o [1..]
19:52:48 <lambdabot> Terminated
19:58:24 <ClaudiusMaximus> :t compare
19:58:26 <lambdabot> forall a. (Ord a) => a -> a -> Ordering
19:58:58 <Cale> @help check
19:58:59 <lambdabot> check <expr>
19:58:59 <lambdabot> You have QuickCheck and 3 seconds. Prove something.
19:59:13 <Cale> That use of the word "prove" grates on my ears.
19:59:52 <ClaudiusMaximus> are there any docs describing how QuickCheck works?
20:00:00 <JKnecht> the imperative is generally.
20:01:34 <OliverB> Cale, Perhaps it should be "disprove something"? :)
20:02:07 <Cale> Yeah, I suppose you can prove that a property fails.
20:03:39 <bd_> @check id
20:03:41 <lambdabot>  Add a type signature
20:03:46 <bd_> @check id :: Bool -> Bool
20:03:47 <lambdabot>  Falsifiable, after 1 tests: False
20:05:00 <bd_> @check \a b -> (not a) && (not b) == not (a || b)
20:05:01 <lambdabot>  Falsifiable, after 1 tests: True, False
20:05:55 <glguy> ?check \a -> id ==> id
20:05:57 <lambdabot>      Expecting a function type, but found `Bool'       Expected type: Bool,  ...
20:05:59 <iah> @check \a b -> (not a && not b) == not (a || b)
20:06:00 <bd_> > ((not True) && (not False), not (True || False), (not True) && (not False) == not (True || False))
20:06:01 <lambdabot>  OK, passed 500 tests.
20:06:02 <lambdabot>  (False,False,False)
20:06:02 <glguy> ?check \a -> id a ==> id a
20:06:04 <lambdabot>  OK, passed 500 tests.
20:06:07 <allbery_b> mmm, precedence
20:06:12 <bd_> oh
20:06:26 <bd_> @check \a b -> ((not a) && (not b)) == (not (a || b))
20:06:27 <lambdabot>  OK, passed 500 tests.
20:06:31 <bd_> bleh
20:06:42 <bd_> I guess it makes sense usually
20:06:45 <glguy> trying to prove demorgans?
20:06:54 <bd_> 500 tests ought to be enough ;)
20:07:07 <sieni> for everybody
20:07:16 <bd_> [does quickcheck try to avoid duplicating tests?]
20:07:17 <glguy> ?scheck \a b -> ((not a) && (not b)) == (not (a || b))
20:07:19 <lambdabot>   Completed 4 test(s) without failure.
20:07:32 <glguy> you want scheck with bool arguments
20:07:35 <ClaudiusMaximus> ?help scheck
20:07:36 <lambdabot> scheck <expr>
20:07:37 <lambdabot> You have SmallCheck and 3 seconds. Test something.
20:08:05 <ClaudiusMaximus> ?docs Test.SmallCheck
20:08:06 <lambdabot> Test.SmallCheck not available
20:08:12 <ClaudiusMaximus> ?docs SmallCheck
20:08:13 <bd_> ?where smallcheck
20:08:13 <lambdabot> SmallCheck not available
20:08:14 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
20:08:18 <iah> smallcheck isn't in the standard library :(
20:09:41 <glguy> ?scheck \a -> id a ==> id a
20:09:42 <lambdabot>   Completed 2 test(s) without failure.  But 1 did not meet ==> condition.
20:10:10 <bd_> :t (==>)
20:10:11 <lambdabot> Not in scope: `==>'
20:10:17 <bd_> oh, implies?
20:10:21 <glguy> yeah
20:10:42 <bd_> so it's complaining because the LHS was never False?
20:10:53 <glguy> no, it's complaining because once, it was
20:10:54 <bd_> ?scheck \a b -> (b && a) ==> a
20:10:55 <lambdabot>   Completed 4 test(s) without failure.  But 3 did not meet ==> condition.
20:10:59 <bd_> oh
20:11:33 <iulus> ?check \a b -> (b && a) ==> a
20:11:34 <lambdabot>  Arguments exhausted after 351 tests.
20:11:45 <Saizan> how can (b && a) not meet a?
20:12:08 <Saizan> s/meet/imply/
20:12:15 <bd_> ?scheck \f g l -> (map (f . g) l) == (map f $ map g l)
20:12:16 <lambdabot> Add a type signature
20:12:26 <bd_> ?scheck \f g l -> (map (f . g) l :: [Int]) == (map f $ map g l)
20:12:27 <lambdabot> Add a type signature
20:12:27 <iah> when it says "did not meet ==> condition" I think it means that the implication was vacuously true
20:12:36 <iah> that is, b && a was false
20:12:38 <bd_> ?scheck \f g l -> (map ((f :: Int -> Int) . g) l :: [Int]) == (map f $ map g l)
20:12:39 <lambdabot> Add a type signature
20:12:43 <bd_> :/
20:12:55 <bd_> ?scheck \f g l -> (map ((f :: Int -> Int) . g) (l :: [Int])) == (map f $ map g l)
20:13:01 <lambdabot> Done.
20:13:04 <iah> ?scheck \a -> False ==> a
20:13:05 <lambdabot> Add a type signature
20:13:05 <bd_> ... done?
20:13:18 <iah> ?scheck \a -> False ==> (a :: Bool)
20:13:20 <lambdabot>   Completed 2 test(s) without failure.  But 2 did not meet ==> condition.
20:13:35 <bd_> what's "done" supposed to mean? XD
20:13:41 <iah> haha
20:13:43 <Saizan> :D
20:13:44 <bd_> ?check \f g l -> (map ((f :: Int -> Int) . g) (l :: [Int])) == (map f $ map g l)
20:13:46 <iulus> ?scheck \_ -> True ==> True
20:13:48 <lambdabot>  OK, passed 500 tests.
20:13:48 <lambdabot> Add a type signature
20:13:52 <ClaudiusMaximus> :t sort
20:13:54 <lambdabot> forall a. (Ord a) => [a] -> [a]
20:13:54 <iulus> ?scheck \_ -> True ==> True :: Bool
20:13:55 <lambdabot> Couldn't match `Bool' against `Property'
20:14:25 <Saizan> ?scheck \(_:: Bool) -> True ==> True
20:14:26 <lambdabot>  Parse error in pattern
20:14:31 <iah> ?scheck (\_ -> True ==> True) :: Int -> Bool
20:14:32 <lambdabot> Couldn't match `Bool' against `Property'
20:14:36 <iah> ?scheck (\_ -> True ==> True) :: Int -> Property
20:14:38 <lambdabot>   Completed 13 test(s) without failure.
20:14:53 <iulus> ?src Property
20:14:54 <lambdabot> Source for this function is not available.
20:15:48 <bd_>  ?src is only for prelude I thought?
20:16:03 <iulus> could be, I'm not too familiar with the all-powerful lambdabot
20:16:12 <bd_> iulus: it's a new feature too :)
20:16:14 <iulus> so, I thought I'd give it a shot.
20:16:15 <Saizan> it's quite new after all
20:16:20 <bd_> 2-3 days I think?
20:16:21 <iah> ?src ContT
20:16:21 <lambdabot> Source for this function is not available.
20:16:27 <iah> ?src runContT
20:16:28 <lambdabot> Source for this function is not available.
20:16:31 <iah> :(
20:16:34 <ClaudiusMaximus> ?src Ord
20:16:35 <lambdabot> Source for this function is not available.
20:16:41 <bd_> :i ContT
20:17:07 <Saizan> it has only short definitions
20:17:19 <iulus> ?src map
20:17:20 <lambdabot> map _ []     = []
20:17:20 <lambdabot> map f (x:xs) = f x : map f xs
20:17:25 <bd_> runContT (ContT f) final = f final -- that's not short? :)
20:17:47 <iah> ?src id
20:17:48 <lambdabot> id x = x
20:17:54 <bd_> ?src liftM6
20:17:55 <lambdabot> Source for this function is not available.
20:17:58 <bd_> ?src liftM
20:17:58 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:18:01 <bd_> ?src liftM2
20:18:01 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
20:18:05 <iah> ?src ap
20:18:06 <lambdabot> ap = liftM2 id
20:18:10 <glguy> ?type flip runContT return . callCC $ \done -> forM_ [1..] $ \i -> if i > 10 then done () else print i
20:18:12 <lambdabot> Not in scope: `forM_'
20:18:36 <bd_> glguy: forM_ is new in ghc 6.6; lambdabot is on 6.4
20:18:44 <glguy> yup
20:18:44 <bd_> since hsplugins don't yet work on 6.6
20:18:48 <glguy> yup
20:18:50 <bd_> use flip mapM_
20:18:53 <iah> ?type flip runContT return . callCC $ \done -> mapM_ (\i -> if i > 10 then done () else print i) [1..]
20:18:55 <lambdabot>     Couldn't match `ContT () m' against `IO'
20:18:55 <lambdabot>       Expected type: ContT () m b
20:18:56 <glguy> yup
20:19:13 <bd_> use lift
20:19:13 <iah> ?type flip runContT return . callCC $ \done -> mapM_ (\i -> if i > 10 then done () else liftIO $ print i) [1..]
20:19:15 <lambdabot> forall (m :: * -> *). (Monad m, MonadCont (ContT () m), MonadIO (ContT () m)) => m ()
20:19:30 <glguy> there it is
20:20:13 <bd_> :t runContT
20:20:14 <lambdabot> forall r (m :: * -> *) a. ContT r m a -> (a -> m r) -> m r
20:20:26 <bd_> hm, isn't there a derived instance Monad m => MonadCont (ContT a m)?
20:20:39 <bd_> meaning it ought to prove that MonadCont need not be in that signature...
20:20:54 <glguy> ?type callCC
20:20:56 <lambdabot> forall (m :: * -> *) a b. (MonadCont m) => ((a -> m b) -> m a) -> m a
20:21:08 <iah> I don't think ghc bothers to figure that out until later
20:23:55 <drain> why has common lisp fallen into disfavor
20:24:50 <glguy> when was it 'in favor'?
20:25:30 <drain> ... for a long time?
20:25:40 <drain> 1954 or something
20:25:42 <Korollary> whose favor?
20:25:59 <drain> discerning programmers
20:26:02 <glguy> I think that the same lispers that loved lisp then are the ones that do now
20:26:16 <Korollary> who exactly are they? We're talking about an unpopular language here.
20:26:38 <drain> it's about as popular as haskell
20:26:54 <Korollary> so hard to measure at this level.
20:27:22 <drain> been very popular in the AI community for some reason
20:27:33 <glguy> no, it's appearted to be popular
20:27:39 <iah> its popularity derivative is different from haskell's though
20:27:45 <glguy> because it was used in a paper years ago
20:27:50 <JKnecht> disfavor by whom?
20:27:53 <iulus> Has anybody tried F# ?
20:27:54 <drain> if a language originally specified in 1958 is still around now, it has definitely had its days
20:28:04 <JKnecht> I have.
20:28:07 * qwr uses kawa. its quite lisp...
20:28:09 <glguy> ?protontorpedo
20:28:09 <drain> I mean people wouldn't bother standardizing it unless it was very popular
20:28:10 <lambdabot> Im wondering if there are uncharted business waters that haskell can enable, even if it is simply by not accepting norms
20:28:22 <glguy> ?protontorpedo
20:28:23 <lambdabot> ok so say I ftp files from some 50 remote servers now, and then read them inot mysql, then ftp back to an ohter 50 servers some info they read into thier informix db
20:28:25 <dino-> iulus: Not me. Allergic to Microsoft stuff.
20:28:37 <drain> iah: what do you mean, what is the difference?
20:28:41 <drain> (demographically)
20:29:03 <iah> haskell is gaining in popularity, while lisp is pretty constant or maybe even falling
20:29:13 <glguy> ?protontorpedo
20:29:13 <drain> oh, yes
20:29:14 <lambdabot> evaluation seems ideal for banks who want to know global balances etc.
20:29:18 <iulus> dino-: I'll admit, I'm rather partial toward C# as a language to use at work (I'd rather use that then Java)
20:29:18 <drain> that's what I'm talking about
20:29:33 <drain> I mean it's a great language
20:29:39 <drain> lisp is
20:30:07 <drain> is it just the large number of parentheses
20:30:09 <AStorm> Haskell is even greater :-)
20:30:16 <dino-> It would be fair to say that I strongly dislike Java too.
20:30:19 <AStorm> No parentheses and purity included.
20:30:23 <drain> I don't like java either very much
20:30:37 <glguy> its not a functional language, functional languages are gaining popularity
20:30:37 <drain> I mean I know it pretty well since I have had to program in it for most of my school assignments
20:30:47 <AStorm> No need for useless editor-OSes for self promotion
20:30:50 <shapr> I was employed to do Java for years.
20:30:53 <glguy> it doesn't typecheck at compile time
20:31:25 <AStorm> It's not a problem of the language that it doesn't typecheck
20:31:27 <drain> common lisp has the compiler macros though
20:31:33 <AStorm> It's the problem of the programmers :P
20:31:47 <drain> you can write typed common lisp code if you want
20:31:48 <dino-> I should also be fair to Java and say that it's not so much the Java itself that disappoints me, it's the OO.
20:32:07 <drain> you dislike OO?  I think of that as a strength of java
20:32:10 <iah> java's implementation of OO, or OO in general?
20:32:16 <dino-> iah: in general
20:32:22 <iah> every used smalltalk?
20:32:24 <iah> *ever
20:32:39 <dino-> No, but I feel like I've lost my oo faith hanging with these dudes. :D
20:32:41 <AStorm> True classes are only in certain FP languages :>
20:32:52 <iah> haha
20:32:55 <iulus> that's why we have the class system now
20:33:02 <drain> that depends on what you call a true class, what is your meaning?
20:33:03 <iulus> FP'ers are obviously the best
20:33:05 <Saizan> well, better OO then procedural, but all that naming your types, assigning thing to places, it just gets in the way of your thinking :)
20:33:10 <iulus> then comes the OO class
20:33:18 <iulus> then the peons, the scripting language class
20:33:21 <iulus> or something like that.
20:33:35 <drain> ... there's nothing wrong with some scripting languages
20:33:38 <AStorm> I'd kill you for "scripting language class" :>
20:33:47 <AStorm> Haskell IS my scripting language :P
20:33:54 <drain> !
20:33:59 <iulus> I'm just kidding, I like 'em, too.
20:34:03 <nornagon> haskerl?
20:34:14 <AStorm> No, Haskell.
20:34:22 <iulus> many menial tasks have been simplified away through the aid of perl
20:34:28 <nornagon> anyway, I write my scripts in asm!
20:34:30 <nornagon> :O
20:34:37 <drain> I learned python instead of perl for a scripting language
20:34:38 <AStorm> I can type import Text.Regex, thank you very much
20:34:39 <Saizan> haskell has regex built in the syntax too :D (with the right preprocessor)
20:34:42 <dino-> Also, I see where stuff has been going, like the Java annotations and aspect-oriented. It seems like every new feature added adds to the cry for help that it's become.
20:34:49 <iah> yes
20:35:08 <iulus> drain: I would've, but my boss said, "Learn perl."
20:35:13 <AStorm> The only nice thing in Java are the interfaces
20:35:19 <AStorm> and that's also unneeded
20:35:23 <nornagon> i was a perl fanatic until i discovered ruby
20:35:34 <drain> lol iulus it was exactly that way with me, I was doing a software engineering seminar and the professor in charge told me to work in python
20:35:57 <iah> the best part about OO is that the only things you need to know about whatever object you're manipulating are the messages it responds to
20:36:12 <iah> in haskell, if you want that kind of polymorphism, you have to make a typeclass
20:36:13 <dino-> I read about the aspect stuff, particulary the style where it can modify classes at runtime to add/remove methods. How does that not scare the shit out of people.
20:36:13 <qwr> ruby is quite nice for some stuff
20:36:20 <AStorm> I was a language fanatic until I discovered I can program in almost anything (except machine code and certain assemblers) given a month or two of time
20:36:20 <iah> but in OO it's built in everywhere
20:36:24 <iah> and that can be nice sometimes.
20:37:02 <iah> AStorm: I was a language fanatic until I found Haskell :)
20:37:29 <drain> I'm learning Lisp better so that I can write a language extension Ive been thinking about
20:37:33 <AStorm> :>
20:37:33 <olliej> real men write in COBOL
20:37:34 <drain> a certain kind of message passing between objects
20:37:38 <olliej> ;D
20:37:50 <drain> I can do that with macros
20:37:51 <AStorm> Real Men write on paper. In math.
20:38:15 <AStorm> I can't do that well enough, I'm afraid :/
20:38:21 <olliej> in pen -- you only need pencils/rubbers if you make mistakes
20:38:25 <iah> real men write machine code directly to memory using magnets
20:38:25 <olliej> hehe
20:38:37 <AStorm> iah, not funny
20:38:40 <drain> I always write my math in pen olliej
20:38:43 <olliej> iah: i use the power of my mind to modify the magnetic field
20:38:52 <olliej> drain: i don't. because i suck :D
20:38:56 <drain> I like the smoother ride of a pen rather than the scratchiness of a pencil
20:39:09 <drain> and I make plenty of mistakes, but I cross them out instead of erasing them
20:39:14 <AStorm> I prefer Haskell to math. I wonder why...
20:39:14 <olliej> drain: though when i think about it, it's been a long time since i've done pure maths
20:39:19 <nornagon> i just wrote a short shell script to read my mind and figure out the program i want.
20:39:42 <olliej> AStorm: because haskell compilers are less prone to mistakes than we are?
20:39:45 <drain> what does it say, nornagon?
20:39:56 <AStorm> Well, my math type inference works quite fine
20:40:02 <nornagon> drain: "lol."
20:40:03 <dino-> There have been some things I read (I think dons wrote something about this recently), about how monads allow you construct language features that you need, as opposed to them being designed into a language or you're SOL. It's very very cool.
20:40:29 <AStorm> Just the operators, you know, - vs +, and Haskell can't fix that... or can it?
20:40:54 <drain> what does SOL stand for
20:41:03 <AStorm> ?acronym SOL
20:41:04 <lambdabot> Unknown command, try @list
20:41:07 <AStorm> :/
20:41:11 <jcreigh> "sadly" out of luck. :)
20:41:33 <iah> wikipedia says "shit outta luck"
20:41:50 <AStorm> You know what the quotes meant...
20:42:05 <iah> doh
20:42:09 <iah> now I do :/
20:42:35 <drain> dino-: in lisp you get direct access to the compiler to make language features
20:42:54 <AStorm> In Haskell, the compiler is smarter than you and can read mind.
20:43:03 <AStorm> You don't need the direct access to it.
20:43:10 <nornagon> heh
20:45:00 <qwr> the lisp macros give you a bit more freedom. and no sanity checking.
20:45:38 <drain> they can make an efficient new language though instead of using runtime functions
20:45:56 <drain> no runtime loss of efficiency when you use a macro
20:46:37 <glguy> ?protontorpedi
20:46:38 <lambdabot> how does haskell compare to c++?
20:46:50 <drain> favorably
20:46:55 <glguy> ?protontorpedo
20:46:56 <lambdabot> scheme, lisp, php, python, perl, tcl, al banned
20:47:37 <AStorm> Except when they're not :P
20:47:49 <jcreigh> I really should attempt a large project in some sort of lisp. All the lispniks sing macros's praises, and I've always wondered what the fuss was all about.
20:48:06 <AStorm> They aren't really necessary in a sane language
20:48:09 <drain> I'm not a lispnik.. yet
20:48:13 <AStorm> in lisp, they are
20:48:20 <AStorm> otherwise you'd drown in the parentheses
20:48:28 <AStorm> Even with a good editor.
20:48:30 <iah> a lot of haskell projects use cpp...
20:48:34 <drain> nah the parentheses are not a problem
20:48:46 <glguy> ?protontorpedo
20:48:47 <lambdabot> whera re the end user apps?
20:48:47 <drain> well they are a problem
20:48:50 <AStorm> Also, function implementation used to be slooooow
20:48:53 * allbery_b has done macroey stuff in elisp.  that's more than enough, thanks
20:48:59 <drain> it's not now, optimized lisp is fast
20:49:03 <glguy> ?protontorpedo
20:49:04 <lambdabot> cmon Im asking cool questions
20:49:23 <allbery_b> of course, then there are the folks who think I really want to mess with ASTs... :/
20:49:33 <jcreigh> Yeah, lisp people don't really beleive in lambda...they don't even have a special syntax for it. :)
20:49:45 <drain> lisp barely has a special syntax for anything
20:49:57 <drain> you know though it would be very easy to make lisp have haskell syntax for lambdas
20:50:14 <AStorm> instead of defun? :P
20:50:24 <dons> pity it doesn't have a type system, or purity. ah well
20:50:26 <sieni> drain: like (\ x y z -> body)?
20:50:30 <dons> gimme an smp runtime now!
20:50:31 <qwr> jcreigh: macros are mostly about creating small dsl's. monads allow similar staff... and i'm not really sure which is better ;) but every other language i've used seems to be weaker
20:50:43 <drain> you could just say (defmacro \ (&rest body) `(lambda ,@body))
20:50:50 <drain> and then you could use backslash notation for lambdas
20:51:01 <jcreigh> qwr: "other" than a Lisp-family language or "other" than Haskell?
20:51:02 <sieni> qwr: macros aren't _that_ necessary, when you have lazy evaluation
20:51:13 <qwr> jcreigh: other than lisp/haskell
20:52:12 <drain> jcreigh though... lisp was _based_ on the lambda calculus so you can't say that just because they don't have a neat built in syntax like haskell they don't use it
20:52:12 <iah> qwr: ruby isn't bad in that regard
20:52:21 <iah> you can evaluate blocks in the context of different objects
20:52:45 <sieni> drain: what do you mean "was based on lambda calculus"
20:52:55 <glguy> Lisp requires macros to define your own control structures
20:52:59 <drain> I mean that Alonzo Church's lambda calculus was the foundation for lisp
20:53:02 <glguy> Haskell gives you that for free
20:53:02 <AStorm> It IS lambda calculus, though untyped and impure
20:53:23 <drain> common lisp can be typed depending on how you write your program
20:53:41 <glguy> the type annotations on methods are for optimization, not type checking thoug
20:53:43 <AStorm> It's not really enforced.
20:53:46 <glguy> what typing are you refering to
20:53:48 <drain> apparently you can get speed benefits from adding type signatures to stuff
20:53:53 <sieni> drain: lisp (or any other language) didn't have proper lexically scoped closures until *drumroll* Scheme.
20:54:17 <drain> argh scheme I was forced to learn that, but I don't like it compared to common lisp
20:54:26 <AStorm> Blah. I prefer lack of closures, in BASIC style :P
20:54:27 <glguy> yeah, the naming conventions are too reasonable
20:54:33 <AStorm> (actually, CRM114 :P )
20:54:48 <drain> I don't know so much about the truth of your words.. ?  are you saying common lisp doesn'thave lexically scoped closures?
20:54:52 <Philippa> unlike lisp, lambda calculus isn't introspective - you have data must be code rather than code is data
20:55:06 <sieni> drain: no, I'm saying they were taken to common lisp from scheme
20:55:18 <drain> ok
20:55:25 <Philippa> what with scheme predating common lisp
20:55:40 <AStorm> But not all lisp.
20:56:12 <glguy> it's a shame that CL decided to go with Lisp-2, separate namespace for variables and functions
20:56:24 <drain> why is that a shame?
20:56:26 <glguy> just for the sake of compatibility with committee languages
20:56:50 <drain> I kind of like it, it means I can have arguments to functions that are named "list"
20:56:57 <sieni> drain: and lisp is from 1950s and scheme from 1970s, so I would say it's inaccurate to say that Lisp was based on lambda calculus.
20:57:04 <AStorm> drain, total mess!
20:57:05 <drain> which is part of I'm working on now
20:57:22 <glguy> drain: proper lexical scoping should allow you to shaddow the function list
20:57:29 <dgriffi3> drain: even on exams? do you not run into space problems?
20:57:32 <dino-> Hey, I have a question that this seems like a good group for.. Are there any functional scripting languages?
20:57:45 <glguy> and it makes it harder to return and use functions cleanly
20:57:50 <AStorm> Haskell IS a scripting language too :P
20:58:01 <drain> sieni lisp WAS based on lambda calculus, try wikipedia--scheme is just one "theoretically pure" incarnation of it
20:58:24 <glguy> (apply and (funcall are unnecessarily awkward
20:58:30 <AStorm> dino-, define scripting language
20:58:38 <glguy> and so is the #' prefix
20:58:53 <dgriffi3> drain: ignore me was reading something from sometime ago
20:58:58 <drain> in some implementations of CL you don't need to put the #' prefix
20:59:07 <glguy> that's not defined by the standard?
20:59:42 <drain> I'm not sure what the standard says but I gather that depending on your common lisp implementation, you can use #' or leave it out
20:59:50 <dino-> AStorm: Not necessary to compile (or magically compiles to bytecode with an interpreter, like Perl). No or less strict typing. Basically something you can crank out small things with.
20:59:55 <drain> for example in SBCL which I am using now I can leave it out if I want
21:00:07 <AStorm> dino-, hmm... Let's see.
21:00:17 <qwr> dino-: scheme dialects. ruby allows also somewhat functional code
21:00:23 <AStorm> or Python
21:00:28 <dino-> qwr: Isn't Ruby highly OO, though?
21:00:30 <iah> even though there's no such thing as a function in ruby
21:00:37 <AStorm> It is, but you don't have to use that :P
21:00:39 <dino-> That's the thing, I'm trying to retreat from objects.
21:00:43 <qwr> dino-: depends how you use it
21:01:01 <drain> why would you want to avoid using objects?  they help you organize your thoughts
21:01:14 <AStorm> Disorganise, force false structure :P
21:02:03 <AStorm> Though I'd like some nicer syntax for defining Monads, more like OO
21:02:13 <AStorm> (for holding various state)
21:02:24 <qwr> dino-: and you can write haskell scripts that run on hugs
21:02:27 <glguy> AStorm: like newtype?
21:02:35 <AStorm> More than that
21:02:46 <AStorm> With "methods"
21:02:56 <bd_> AStorm: You can build a monad around state
21:03:08 <iah> you can use a state monad and gets
21:03:10 <AStorm> a monad is a state
21:03:13 <AStorm> :>
21:03:14 <bd_> newtype MyMonad m = MM (StateT MyState m) deriving (Monad)
21:03:14 <dino-> qwr: As in, the runhugs with #! in the source?
21:03:16 <iah> x <- gets nameOfField
21:03:29 <qwr> dino-: iirc yes
21:03:32 <bd_> write private lifting functions and accessors
21:03:33 <AStorm> But that doesn't parse like a monad, more like function application
21:03:39 <AStorm> a Monad is something opaque
21:03:42 <AStorm> :P
21:03:53 <bd_> ?past4
21:03:54 <lambdabot> http://paste.lisp.org/new/haskell
21:03:54 <bd_> ?paste
21:03:55 <lambdabot> http://paste.lisp.org/new/haskell
21:04:07 <dino-> And yeah, I was already 1/2 suspecting that there were probably some scheme things that would work as a 'lighter' scripting language.
21:04:29 <drain> objects are good....
21:04:32 <AStorm> bd_, huh? I mean something which is totally opaque
21:04:44 <AStorm> So I don't have to know names like "gets" or anything
21:04:48 <lisppaste2> bd_ pasted "simple example of opaque monad state" at http://paste.lisp.org/display/34203
21:05:01 <AStorm> Just one operator, which is usually . in OO languages
21:05:04 <bd_> that's Reader actually
21:05:08 <AStorm> (though that's taken)
21:05:10 <bd_> but same thing
21:05:20 <bd_> if you're looking for something like
21:05:30 <bd_> someObject `someOperator` SomeAnnotation
21:05:32 <bd_> that's not a monad
21:05:43 <bd_> you could do something like
21:05:47 <bd_> (.!.) = flip ($)
21:05:51 <bd_> and use it as a record accessor
21:05:58 <AStorm> Hmm, hmm!
21:06:08 <nornagon> :t flip ($)
21:06:10 <lambdabot> forall b b1. b1 -> (b1 -> b) -> b
21:06:14 <AStorm> But how would I know record names?
21:06:15 <bd_> AStorm: but that's silly :p
21:06:25 <bd_> AStorm: Well, they're functions really
21:06:32 <bd_> AStorm: so they're part of the API
21:06:51 <AStorm> I mean something which passes a "dictionary" of "methods"
21:06:52 <bd_> you can export them as just functions, not record accessors, I think
21:07:10 <bd_> AStorm: That sounds like you're trying to force structure on without a good reason :)
21:07:13 <bd_> There's OOHaskell
21:07:14 <bd_> but
21:07:18 <bd_> i've never felt the need to use it
21:07:26 <AStorm> Accessible like: thatObject *> "someStupidFunction" parameterOfIt
21:07:27 <glguy> http://etymon.blogspot.com/2006/04/what-is-object-oriented-programming.html#comments
21:07:30 <lambdabot> Title: Etymon: What is Object-Oriented Programming, http://tinyurl.com/y63vqh
21:07:38 <bd_> AStorm: someStupidFunction thatObject parameterOfIt
21:07:46 <AStorm> bd_, I don't really know the name of it
21:07:47 <AStorm> :P
21:07:54 <bd_> AStorm: ?
21:07:58 <bd_> you have a string there
21:08:00 <bd_> I mean
21:08:01 <AStorm> the name may be invalid
21:08:01 <Excedrin> isn't OO deprecated?
21:08:12 <glguy> ?quote Excedrin isn't OO deprecated?
21:08:13 <lambdabot> No quotes for this person. That's something I cannot allow to happen.
21:08:13 <bd_> AStorm: Why allow it to be invalid?
21:08:20 <glguy> ?remember Excedrin isn't OO deprecated?
21:08:26 <AStorm> Internet-alike interfaces
21:08:29 <bd_> AStorm: eh?
21:08:56 <bd_> AStorm: I'd just marshall things at the border between the program and the internet
21:08:59 <nornagon> ?quote deprecated
21:08:59 <lambdabot> Excedrin says: isn't OO deprecated?
21:09:11 <bd_> incomingCommand "someCommand" someObject = someCommand someObject
21:09:15 <glguy> ?quote lisp
21:09:16 <lambdabot> qwe1234 says: lisp is yet another half-assed run-of-the-mill scripting language. absolutely *no different* from something like php in any significant way worth mentioning.
21:09:21 <bd_> incomingCommand err _ = reportError $ "Bad method: " ++ err
21:09:22 <AStorm> bd_, well, but I'd love to fish out some named function from some "state"
21:09:31 <bd_> AStorm: you can do it, but it'd be ugly
21:09:37 <AStorm> Load them into it from file, like plugins
21:09:44 <glguy> dons: did qwe1234 honor #haskell with his presense, or were those taken from reddit?
21:09:48 <jcreigh> hey, isn't qwe1234 that troll on reddit?
21:09:49 <bd_> AStorm: You'd need a (Map String Dynamic)
21:10:03 <iah> that's where oo is really nice
21:10:03 <AStorm> Hmm... can that take random functions?
21:10:05 <Excedrin> from reddit
21:10:08 <bd_> AStorm: I strongly suggest avoiding that if at all possible :)
21:10:13 <bd_> AStorm: it can; it does typechecking at runtime
21:10:24 <iah> but I'm not sure it's necessary
21:10:26 <AStorm> Yeah, how would I do plugins otherwise?
21:10:38 <AStorm> yi isn't necessarily readable to me
21:10:45 <bd_> AStorm: If they have a consistent type
21:10:52 <bd_> they'd be a lot more useful
21:10:55 <bd_> er
21:10:57 <bd_> easier anyway
21:11:01 <AStorm> Easier, yes
21:11:09 <AStorm> They have semi-consistent type, you see
21:11:26 <bd_> it's hard to think of a case where Dynamic would be useful for plugin function types, since there's only a finite number of places to convert it back
21:11:28 <AStorm> each plugin would have to add its own runtime checks
21:11:35 <AStorm> I'd love to abstract that out of them
21:11:46 <bd_> but yeah, plugins are the one place where it could be useful
21:11:53 <bd_> or well
21:11:55 <bd_> one of the few
21:13:15 <AStorm> I'll try various approaches to the problem, anyway.
21:13:42 <AStorm> Other than that, is there some nice INI-style file parser/writer I don't have to write?
21:13:52 <dino-> I guess I can agree that some of the motivations for OO are important, but they're not exclusively available in OO languages.
21:14:17 <glguy> from the link i posted earlier: That leaves us with a single definition.
21:14:17 <glguy> Object Oriented Programming is any programming based on a combination of subtype polymorphism and open recursion
21:14:47 <AStorm> This means C is OO :P
21:14:55 <AStorm> (mostly)
21:15:08 <bd_> C doesn't have subtype polymorphism
21:15:10 <dgriffi3> AStorm: i think http://software.complete.org/configfile has the ini stuff you are looking for
21:15:11 <glguy> how does C support open recursion?
21:15:12 <Excedrin> except for the lack of subtype polymorphism
21:15:12 <lambdabot> Title: ConfigFile
21:15:14 <bd_> or, really, any polymorphism
21:15:36 <AStorm> infinite struct polymorphism? :>
21:15:42 <glguy> Open recursion. Another handy feature offered by most languages with objects and classes is the ability for one method body to invoke another method of the same object via a special variable called self or, in some langauges, this. The special behavior of self is that it is late-bound, allowing a method defined in one class to invoke another method that is defined later, in some subclass of the first.
21:15:48 <olliej> bd_: through the creative abuse of functions pointers :D
21:15:48 <glguy> Types and Programming Lanauges, Benjamin C. Pierce, 2002, MIT Press, pg 227.
21:15:49 <bd_> AStorm: that doesn't dispatch functions based on the type
21:15:58 <bd_> olliej: >.>
21:16:03 <AStorm> dgriffi3++
21:16:15 <emu> that's not a hallmark of OO languages, it's too specific
21:16:35 <olliej> bd_: i made a set of macros that supported polymorphism+class defs in C once.  It was.. um.. fragile... but it worked
21:16:50 <bd_> olliej: Isn't that how C++ got started?
21:16:55 <AStorm> That's how C++ (yuck) was implemented first
21:17:07 <olliej> bd_: they used a preprocessor, not pure cpp macros
21:17:29 <dgriffi3> also for plugin stuff in general you could look at http://www.cse.unsw.edu.au/~dons/hs-plugins/ although I have never used it myself
21:17:29 <emu> cfront
21:17:30 <lambdabot> Title: hs-pluginsDynamically Loaded Haskell Modules
21:17:35 <olliej> bd_: my macro cludge started looking like an attempt to implement OO cobol  in C
21:17:47 <bd_> olliej: Why is this in C, again? :)
21:17:54 <olliej> emu: yup :D
21:18:00 <iah> objective-c is pretty much a macro hack over C, and it's very usable
21:18:05 <bd_> AStorm: note that hs-plugins does not work in ghc 6.6 at the moment
21:18:11 <olliej> bd_: we had assignment that was meant to be implemented in pure C
21:18:14 <bd_> oh
21:18:26 <olliej> bd_: and was being very "OO" at the time
21:18:32 <AStorm> bd_, well, it's probably portable enough, so...
21:18:42 <olliej> bd_: eventually i rewrote the entire thing in half the time in pure C
21:18:55 <bd_> AStorm: yeah, it's probably going to be ported to ghc 6.6 soon enough, but not quite yet :)
21:19:18 <AStorm> Hmm, maybe I'll try that... :D
21:19:23 <olliej> bd_: dealing with anything that fragile becomes really frustrating once you realise you don't need polymorhpism anywhere
21:19:52 <olliej> iah: obj-c is the frankenstein combination of small talk and C
21:20:02 <AStorm> Powered by OpenStep
21:20:10 <olliej> there are two distinct type systems
21:20:13 <olliej> ahem
21:20:21 <olliej> obj-c is a good and wonderful language
21:20:24 <AStorm> Type in Obj-C? You must be joking.
21:20:25 * olliej looks shifty
21:20:31 <AStorm> There are just messages.
21:20:35 <olliej> AStorm: obj-c is dynamically typed
21:20:41 <olliej> AStorm: yes
21:20:46 <AStorm> Untyped, actually.
21:20:50 <olliej> AStorm: that's because it's smalltalk
21:21:07 <AStorm> It
21:21:16 <olliej> AStorm: obj-c is strongly typed
21:21:20 <AStorm> It's an uglier version of it, right?
21:21:29 <olliej> right until you abuse it in C
21:22:02 <olliej> AStorm: what makes obj-c ugly is the fact that it's really two languages in a single file (or function :O)
21:22:27 <emu> and one of them is not LaTeX?
21:22:46 <AStorm> one is Obj-C, the other is C
21:22:54 <emu> literate ObjC, that sounds like a pile of fun
21:23:07 <AStorm> Three languages - triple maintainer fun!
21:23:20 <emu> it's almost like "modern" web development
21:23:33 <olliej> hehe
21:23:45 <emu> javascript,html,css,php
21:23:56 <emu> oh, sql too
21:24:04 <olliej> emu: and none of them implemented exactly the same way
21:24:04 <AStorm> s/php/anything else/
21:24:11 <AStorm> s/sql//
21:24:24 <bd_> haskell,xslt,html,css ;)
21:24:25 <AStorm> (hidden by some DB interface)
21:24:35 <olliej> emu: which means implementing them is a matter of consulting the spec, and then seeing what other browsers do
21:24:51 <olliej> emu: and then choosing which you follow
21:24:52 <emu> and then doing something subtlety different
21:24:53 <AStorm> And JavaScript is just evil :P
21:24:54 <olliej> hurrah!
21:25:29 <olliej> emu: well every browser other than ie has a problem -- we can follow the spec or we can follow ie
21:25:37 <AStorm> haskell -> xhtml+css
21:25:39 <emu> that's why you should only use languages with formally specified denotational semantics!
21:25:42 <olliej> it's becoming more possible nowadays to ignore ie, and just follow spec
21:25:48 <xpika> and theres more (HTML IE stand. , HTML FF standard) ..
21:26:08 <olliej> unfortunately the w3c don't actually write unambiguous standards
21:26:18 <qwr> JavaScript lacks a good implementation ;)
21:26:19 <AStorm> They do that good enough.
21:26:25 <AStorm> qwr, you mean Opera? :P
21:26:29 <olliej> i've had hour long discussions on what should happen in certain cases of svg
21:26:40 <olliej> AStorm: you mean webkit right?
21:26:41 <olliej> :D
21:26:50 <AStorm> olliej, that too
21:27:11 <olliej> AStorm: not that i'm in anyway biased of course :D
21:27:17 <AStorm> SVG has just one problem - nothing supports it correctly
21:27:39 <olliej> AStorm: the reality is opera does an exceptionally good job of svg
21:27:56 <olliej> it's just that even we have like 10x the market share
21:27:56 <AStorm> Except it doesn't support animation, transforms, lighting, uh...
21:28:17 <olliej> AStorm: opera doesn't support animation? really? are you sure?
21:28:27 <AStorm> I am, entirely.
21:28:29 <emu> frankly, i'm quite sick of web "programming" so i hope i don't have to get back into it
21:28:32 <olliej> AStorm: i'm fairly sure they support transforms
21:28:35 <qwr> olliej: and stupid sites tell that you shall get adobe plugin into opera ;)
21:28:42 <qwr> for svg
21:28:50 <olliej> qwr: 1) the sites are stupid
21:29:04 <AStorm> 2) opera is stupid too
21:29:10 <olliej> qwr: 2) too many svgs exist which are invalid at a fundamental level
21:29:10 <AStorm> 3) nobody is smart nowadays
21:29:39 <xpika> 4) except me
21:29:40 <AStorm> 4) svg is unsupported anywhere except W3C
21:29:44 <olliej> dammit
21:29:47 * qwr was especially happy about that suggestion on linux
21:30:02 <AStorm> xpika, 3 implies that 4 is false :P
21:30:03 <olliej> n) some servers insist on using text/xml-svg
21:30:11 <olliej> instead of text/xml+svg
21:30:31 <shapr> svg > flash
21:30:31 <olliej> anyhoo ffx supports bits of svg
21:30:39 <olliej> webkit supports more
21:38:16 <olliej> however svg support in webkit is still a "Download and built it yourself" feature
21:38:16 <olliej> problems in w3c specs: they hardly ever define how to deal with error states
21:38:16 <olliej> or edge cases
21:38:16 <AStorm> Because that "can't happen"
21:38:16 <AStorm> If it's an error, you might as well show a message box ;-)
21:38:16 <olliej> AStorm: in javascript -- var b = ['(','-',')']; b[1] = b; var str = b.toString();
21:38:17 <olliej> logically you should throw a stack overflow type exception (except JS doesn't have stackoverflow exceptions :-/)
21:38:17 <AStorm> Is that infinite recursion?
21:38:17 <olliej> yes
21:38:17 <olliej> except ffx doesn't, they terminate once they reach a var they've already encountered
21:38:17 <olliej> this means the toString impl has to maintain a hashset of all visited objects as it recurses
21:38:17 <olliej> errr...
21:38:17 * olliej stops ranting
21:38:17 <AStorm> As I already said, JavaScript should be banned. :P
21:38:17 <olliej> i suggest haskell, but they wouldn't listen
21:38:17 <olliej> :D
21:38:17 <ClaudiusMaximus> is it possible to call Haskell code from an application written in (say) C?  moreover, the Haskell code would need to be able to call functions exported from the C code...
21:38:17 <emu> Haskript
21:38:17 <shapr> emu: mmm!
21:38:17 <shapr> ClaudiusMaximus: yup
21:38:17 <AStorm> ClaudiusMaximus, yes and yes
21:38:17 <AStorm> Second, through FFI
21:38:17 <ClaudiusMaximus> shapr, AStorm:  how easy is it?  how would i go about the first?
21:38:17 <dino-> Huh, appears that I already have guile installed here.
21:38:26 <AStorm> Hmm, the first one... there was something.
21:39:03 * olliej goes back to actual work
21:39:21 <AStorm> GreenCard maybe?
21:40:13 <AStorm> Well, FFI is simple enough.
21:40:38 <shapr> Yeah, FFI
21:41:13 <AStorm> GreenCard is more for Haskell from C
21:41:25 <emu> > 1 :+ 2
21:41:27 <lambdabot>  1.0 :+ 2.0
21:41:41 <emu> > let _ :+ i = 1 :+ 2 in i
21:41:42 <lambdabot>  2.0
21:41:45 <ClaudiusMaximus> http://www.haskell.org/greencard/downloads/greencard-latest/goals.html  << says C to Haskell is only useful for callbacks
21:41:48 <lambdabot> http://tinyurl.com/yy24ko
21:42:02 <emu> thats not ghc's ffi necessarily
21:42:37 <AStorm> It is mostly useful for callbacks
21:42:49 <AStorm> Why would you want to write your app mostly in C anyway?
21:43:13 <ClaudiusMaximus> AStorm: i wouldn't, someone else might, and have already written the app
21:43:22 <olliej> AStorm: because it's an assignment in C, and you need to write enough C to obscure the Haskell?
21:43:32 <AStorm> :P
21:43:39 <emu> just rewrite it in haskell!  you'll probably eliminate 100 memory leak related bugs
21:43:43 <AStorm> Then you write a Haskell -> C compiler
21:43:52 <AStorm> (or use GHC)
21:43:58 <AStorm> then clean the code up
21:44:09 <olliej> AStorm: or a haskell to .net compiler, and then experience the joy of language interoperability!!!!
21:44:19 <emu> i have heard of compilers which generate human-readable C.  but not seen any.
21:45:04 <AStorm> The only problem is garbage collection.
21:45:14 <AStorm> Either you use it, or do region inference
21:45:18 <olliej> emu: from haskell? scary-- dealing with  laziness obscures it somewhat
21:45:19 <jcreigh> AStorm: the compiler-generated C code that I've seen has been incredibly dense and unreadable, such that it would be pretty hard to "clean the code up".
21:45:29 <ClaudiusMaximus> emu: there's 66016 lines in the C source code, it would take a while to rewrite...
21:45:48 <AStorm> Maybe not really
21:45:58 <emu> 10:1 c:haskell lines ratio=)
21:46:03 <AStorm> Maybe you just want to rewrite buisness logic and call the rest as FFI
21:46:16 <AStorm> (which is mostly simple)
21:46:19 <emu> im pretty sure ghc supports being called from C
21:46:30 <emu> ghc-generated libraries
21:48:43 <ClaudiusMaximus> hmm, some context: http://grrrr.org/ext/py/
21:48:46 <lambdabot> Title: py/pyext - python script objects
21:50:05 <AStorm> emu, you mean foreign export?
21:50:18 <emu> i dont recall
21:52:05 <AStorm> Yes, you do.
21:52:11 <AStorm> ?where ffi
21:52:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
21:54:12 <sorear> @seen
21:54:13 <lambdabot> Lately, I have seen astorm, bfulgham_, bosse, claudiusmaximus, emu, jcreigh, olliej, shapr and sorear.
21:54:15 <sorear> @users
21:54:15 <lambdabot> Maximum users seen in #haskell: 296, currently: 261 (88.2%), active: 33 (12.6%)
21:54:55 <AStorm> Count me out ;-)
21:57:07 <shapr> SHAZAM!
21:58:33 <ClaudiusMaximus> AStorm: cool, foreign export exists, but "the first call to hs_exit() is after the last call to hs_init()" might be a minor annoyance
22:00:29 <dons> you're programming in C, its all annoyances
22:01:27 <olliej> dons: now now, C is good for some things.  For instance if you are writing a haskell copmiler for a new platform... :D
22:01:33 <mbishop> @remember dons you're programming in C, its all annoyances
22:02:14 <Excedrin> 66016 lines of C is only 2200 lines of Haskell, just rewrite it
22:03:33 <metaperl> @remember Excedrin 66016 lines of C is only 2200 lines of Haskell, just rewrite it
22:05:52 <ClaudiusMaximus> another more significant annoyance would be that the host app has a heavily state-based paradigm, but i'd be happy with statelessness to start with
22:06:51 <emu> aha Cale, flagging the bad links on reddit again
22:07:20 <Cale> I'm really fed up with it
22:07:35 <Cale> We need a new reddit for nonidiotic people only.
22:08:09 <metaperl> @remember Cale We need a new reddit for nonidiotic people only.
22:08:39 <mbishop> heh, we really do
22:09:47 <Cale> People post articles about *colour coordination* on programming reddit. No matter how interesting such an article might be, I don't think it requires all that many brain cells to determine that it has nothing to do with programming.
22:10:23 <Excedrin> I made a reddit for nonidiotic people and invited all of my friends; they all like, but then they banned me.
22:10:23 <ClaudiusMaximus> a programming reddit with type (of user) inference system?
22:11:00 <araujo> hello
22:12:53 <emu> this boxy types paper looks interesting
22:13:21 <emu> ClaudiusMaximus: it would have to be appropriately supported with annotations!
22:26:26 <shapr> hej bosse
22:34:53 * shapr &
22:54:59 <Excedrin> will Haskell' become Haskell 07 (or whatever, aka the next version of the standard)?
22:55:23 <Cale> Yes. It hasn't been decided what to call the final version
22:55:28 <Cale> Probably 1.6
22:55:34 <Cale> Or whatever year
22:58:49 <ClaudiusMaximus> which library do i need to link with to avoid " Bar.c:(.text+0x1c): undefined reference to `hs_init' " (and many other undefined symbols)?
22:58:57 <ClaudiusMaximus> (doing linking with gcc)
22:59:50 <Cale> link with ghc?
23:00:24 <ClaudiusMaximus> Cale: what if i eventually want to compile to a shared object (i seem to recall ghc doesn't support this yet)?
23:00:34 <ClaudiusMaximus> Cale: linking with ghc works, btw
23:01:04 <Cale> Um, I'm not sure, I've never built a shared object.
23:04:13 <Cale> hs_init is provided in HsFFI.h. I'm not sure what the library to link in is called though.
23:05:15 <ClaudiusMaximus> Cale: ghc -v tells me all the libraries, it seems
23:05:22 <Cale> ah, cool
23:05:26 <ClaudiusMaximus> Cale: and there are rather a large number...
23:07:09 <drain> i think i prefer data encapsulation to method encapsulation
23:14:21 <ski> glguy : re OO, http://mumble.net/~jar/articles/oo.html , http://community.schemewiki.org/?object-oriented-programming might be interesting
23:14:22 <lambdabot> Title: Object-Oriented
23:14:34 <glguy> noted :), bookmarking
23:19:35 <ski> "ob-ject: to feel distaste for something  Webster's Dictionary" - Modern Compiler Implementation in ML
23:19:43 <ski> hm
23:19:51 <ski> @all-dicts object
23:19:53 <lambdabot> *** "Object" gcide "The Collaborative International Dictionary of English v.0.48"
23:19:53 <lambdabot> Object \Ob*ject"\, v. i.
23:19:53 <lambdabot>    To make opposition in words or argument; to express one's
23:19:53 <lambdabot>    displeasure; -- usually followed by to; as, she objected to
23:19:53 <lambdabot>    his vulgar language. --Sir. T. More.
23:19:55 <lambdabot> [156 @more lines]
23:20:47 <sieni> ski: yes, that was funny, when I saw it in the book ;-)
23:27:16 <ski> ("stack: an orderly pile or heap" is quite fitting)
23:28:09 <Korollary> Is there a language named Closures?
23:28:29 <Korollary> (looking at the table at the scheme wiki)
23:29:59 <Korollary> Woah. ocaml's compare is totally uncool.
23:30:31 <Korollary> val (>=) : 'a -> 'a -> bool
23:31:03 <ClaudiusMaximus> i now have a C program that loads shared library that runs haskell code, and it works
23:31:08 * ClaudiusMaximus boogies
23:31:13 <glguy> Korollary: because you have to call it twice?
23:31:27 <sjanssen> Korollary: are those tyvars constrained somehow?
23:31:27 <Korollary> glguy: No. (twice? why?)
23:31:32 <Korollary> sjanssen: nope
23:31:41 <nornagon> :t (>=)
23:31:41 <sjanssen> wow, how does that even work?
23:31:42 <glguy> a >= b , b >= a
23:31:43 <lambdabot> forall a. (Ord a) => a -> a -> Bool
23:31:51 <Korollary> That is why I said uncool.
23:32:02 <glguy> to determine GT, EQ, LT
23:32:03 <Korollary> "mutable structures are compared by contents. Comparison between functional values raises Invalid_argument. Comparison between cyclic structures does not terminate."
23:32:11 <glguy> oh
23:32:30 <nornagon> ouch, mutable? :(
23:32:48 <sjanssen> ah, so you can't implement special behavior for your own types?
23:32:55 <Korollary> you can
23:33:25 <xpika2> @where arrows
23:33:25 <lambdabot> http://www.haskell.org/arrows/
23:33:43 <Korollary> There's an Ordered type ML functor.
23:33:56 <drain> i have an idea of a "configurable layer"
23:34:03 <Korollary> actually, more than one!
23:34:10 <Korollary> http://caml.inria.fr/pub/docs/manual-ocaml/libref/Set.OrderedType.html
23:34:12 <lambdabot> http://tinyurl.com/y6s98x
23:34:19 <Korollary> and
23:34:21 <Korollary> http://caml.inria.fr/pub/docs/manual-ocaml/libref/Map.OrderedType.html
23:34:23 <lambdabot> http://tinyurl.com/y52ufv
23:34:24 * sjanssen doesn't know much about O'Caml, so he'll stop asking questions :)
23:34:44 <Korollary> Why do they have two functors for Map *and* Set?
23:35:28 <Korollary> anyways, I was looking for such a functor and see how comparison was defined between integers, etc. That's when I saw that >= in ocaml is magic.
23:35:53 <ClaudiusMaximus> ?check a*b == b*a
23:35:55 <lambdabot>   Not in scope: `a'
23:36:12 <ClaudiusMaximus> ?check \a b -> a*b == b*a
23:36:13 <lambdabot>  Add a type signature
23:36:13 <Excedrin> there's a lot of magic stuff in OCaml
23:36:23 <ClaudiusMaximus> ?check \a::Float b::Float -> a*b == b*a
23:36:24 <lambdabot>  Parse error
23:36:34 <sjanssen> is the language not expressive enough to provide a non-magic overloaded >= ?
23:36:49 <ClaudiusMaximus> ?check (\a b -> a*b == b*a) :: Float->Float->Bool
23:36:51 <lambdabot>  OK, passed 500 tests.
23:37:44 <sjanssen> ?check (\a b c -> a + (b + (c :: Float)) == (a + b) + c)
23:37:46 <lambdabot>  Falsifiable, after 10 tests: 3.75, 7.111111, -5.5
23:38:11 <bd_> fp inaccuracy :)
23:38:13 <Korollary> sjanssen: It's type couldnt be constrained, so I guess not. I suppose you would be have to produce different >='s for everything that needed comparing.
23:38:34 <thartman> in ghci, I'd like to ":def" a command that just does ":r" and runs a function.
23:39:01 <sjanssen> Korollary: functions with different names?  Could one still write polymorphic code w/ comparisons?
23:40:09 <dons> ?yow
23:40:11 <lambdabot> And furthermore, my bowling average is unimpeachable!!!
23:40:50 <Korollary> sjanssen: You can by using a functor again.
23:41:08 <dons> ?users
23:41:09 <lambdabot> Maximum users seen in #haskell: 296, currently: 260 (87.8%), active: 35 (13.5%)
23:41:34 <Korollary> sjanssen: for instance, that Set module uses a functor to produce function definitions per custom comparison functions.
23:42:17 <dons> ah, now that's right, ghci-server...
23:42:48 <dons> thinking more about our earlier discussion, I'd like to sit on top of screen
23:42:51 <thartman> ?check (\a b c -> a + (b + (c :: Float)) == (a + b) + c)
23:42:52 <lambdabot>  Falsifiable, after 18 tests: 1.8333334, -0.8333333, -1.0
23:43:06 <dons> and perhaps check for existing ghci/screen sessions. reusing them if they're there, otherwise, forking a new ghci.
23:43:13 <thartman> wow, that's pretty amazing... what do I have to import to be able to do that in ghci?
23:43:26 <Korollary> ?index check
23:43:27 <lambdabot> Control.Concurrent.STM, Test.QuickCheck, Debug.QuickCheck
23:43:27 <dons> import Test.QuickCheck
23:43:36 <dons> (you'll need -package QuickCheck installed)
23:43:55 * dons wishes he had ghci-server running...
23:43:55 <Korollary> it's in base in 6.6, right?
23:44:05 <dons> nope. in the extra libs bundle
23:44:08 <Korollary> ah
23:44:25 <sjanssen> ghci-server?
23:44:41 <Korollary> a la emacs-server?
23:45:03 <Korollary> mod_ghci ?
23:45:11 <thartman> how do I install package quickcheck? apt-get? ghci flag?
23:45:13 <dons> thartman: like so:
23:45:15 <dons> Prelude Test.QuickCheck> :m + Test.QuickCheck
23:45:16 <dons> Prelude Test.QuickCheck> :t check
23:45:16 <dons> check :: (Testable a) => Config -> a -> IO ()
23:45:16 <dons> Prelude Test.QuickCheck> :t defaultConfig
23:45:18 <dons> defaultConfig :: Config
23:45:21 <dons> Prelude Test.QuickCheck> check defaultConfig (\x -> not (null x) ==> reverse (reverse x) == (x :: [Int]))
23:45:24 <dons> OK, passed 100 tests.
23:45:30 <Korollary> thartman: what version of ghc?
23:45:32 <dons> if you don't have QuickCheck, you can grab it from your apt or haskell.org/ghc's extralibs bundle
23:45:44 <dons> sjanssen: yeah, an idea to run a ghci daemon in the background
23:45:46 <sjanssen> dons, thartman: or use the quickCheck function
23:46:04 <dons> which restarts ghci in the background, so that "ghci" gives you a ready-to-go sessoin
23:46:13 <dons> rather than waiting 0.6s for ghci to load
23:46:30 <dons> i started writing a little daemon, but a lot of it duplicates screen functionality
23:46:33 <Korollary> dons: are you trying to invalidate your need?
23:47:28 <Korollary> I think ghci-server could be useful with eclipsefp. Unless they already have something like it.
23:51:02 <Korollary> actually, a ghc-server could speed up compilation of large projects
23:52:05 <dons> dibblego++ http://www.workingmouse.com/research/IntelliJIdea%2DHaskell/
23:52:07 <lambdabot> Title: Workingmouse: Where you find the Java People!
23:53:31 <Korollary> hah
23:53:39 <Korollary> with lambdabot source in the screenshots
23:54:39 <dons> hah!
23:55:13 <dons> lambdabot's got a seriously twisted monad stack, thanks to Heffalump
23:55:52 <dons> oh, and cabal highlighting. good stuff
23:56:15 <kfish> twisted monad stack -- i noticed that
23:56:27 <kfish> i was wondering if that was normal for real haskell code ...
23:56:40 <dons> nah, it was an amusing game
23:56:46 <kfish> phew :-)
23:56:52 <dons> i know of no program with such a stack
23:56:55 <kfish> (hi, happy new year btw)
23:56:57 <glguy> what's the stack?
23:57:06 <dons> basically various people == Heffalump and TheHunter, wanted to play GHC games
23:57:39 <kfish> glguy: a pretty random mix of state, reader and writer Ts
23:57:42 <Korollary> @seen TheHunter
23:57:43 <lambdabot> I haven't seen TheHunter.
23:57:56 <dons> this kind of thing:
23:57:57 <dons> -- lbIO return :: LB (LB a -> IO a)
23:57:57 <dons> -- CPS to work around predicativiy of haskell's type system.
23:57:57 <dons> lbIO :: ((forall a. LB a -> IO a) -> IO b) -> LB b
23:57:57 <dons> lbIO k = LB . ReaderT $ \r -> k (\(LB m) -> m `runReaderT` r)
23:58:23 <dons> the binding to Error handles signals and our own custom DynExceptions,
23:58:24 <dons>   throwError (SignalCaught e) = io $ evaluate (throwDyn $ SignalException e)
23:58:24 <dons>   m `catchError` h = lbIO $ \conv -> (conv m
23:58:24 <dons>               `catchDyn` \(SignalException e) -> conv $ h $ SignalCaught e)
23:58:24 <dons>               `catch` \e -> conv $ h $ IRCRaised e
23:58:37 <dons> all of it I'd replace with just a StateT I think...
23:59:20 <glguy> wow
23:59:23 <dons> I think originally Heffalump planned to have separate *types* for connected and un-connected states
23:59:28 <dons> and to just play type games all over
23:59:56 <dons> in practice we don't care, and only really rely on the Module abstraction (each module is run in its own state)
