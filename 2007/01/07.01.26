00:00:06 <pstickne> She's in my calculus II as well. Aber sie is zu Jung fu"r mich :( (and how bad did I butcher that?)
00:00:17 <Korollary> you didnt
00:00:21 <Korollary> s/is/ist
00:00:24 <shapr> Jag tror att det finns inte ... eller...
00:01:05 <shapr> Men min flickvänn är så ung...
00:01:33 <shapr> How old are you anyway?
00:01:41 <magnus--> shapr: Are you a swede in the US (like me)?
00:02:12 <shapr> magnus--: Nej, jag kommer från Alabama, den svensk del av Alabama, naturligtvis.
00:02:15 <earthy> he used to be a usanian in seden. :)
00:02:21 <earthy> +w
00:02:25 <astrolabe> If I want to use a fold on a really long list, is foldl' the only one that will ever work?
00:02:26 <shapr> I'm from the Swedish part of Alabama.
00:02:47 <arcatan> there's a Swedish part in Alabama? :o
00:02:48 <magnus--> shapr: Hehe, that's funny.
00:03:03 <earthy> hey, there's a dutch part in michigan... why not? :)
00:03:26 <shapr> arcatan: ei ole :-)
00:04:33 <magnus--> shapr: Does anyone speak Swedish there daily?
00:04:51 <astrolabe> hmmm. foldr must work sometimes, because you can construct id with it.
00:05:00 <shapr> Here in Alabama? Well, I call my girlfriend in Stockholm...
00:05:33 <magnus--> She taught you Swedish?
00:05:57 <shapr> I've been trying to find some Swedish speakers here in Birmingham, I think I'll get a t-shirt that says "SNÄLLA PRATA SVENSKA MED MIG"
00:06:23 <Adamant> "speak Swedish with me"?
00:06:38 <shapr> Nej, jag bodde i Boden tre år, och stockholm flera månader.
00:06:44 <earthy> you're not using utf-8, ar you?
00:06:46 <sieni> magnus--: No, I think he learnt that while living in Boden :-)
00:06:46 <shapr> Adamant: yup, "PLEASE SPEAK SWEDISH WITH ME"
00:06:55 <sieni> oops, he told you that already
00:06:58 <shapr> earthy: I thought I was, I've fixed that now.
00:07:07 <shapr> Nu Ã¤r det bÃ¤ttre.
00:07:08 <magnus--> Shapr: Ah, now I remember! You're the guy who was in Boden. I thought you were a Swede
00:07:09 * earthy sees questionmarks
00:07:13 <earthy> yup. that's better. ;)
00:07:16 <shapr> magnus--: yes :-) we've spoken before
00:07:27 <sieni> magnus--: He's American-Swedish-American of sorts right now
00:07:30 <Adamant> shapr, I just understood the "med mig" me
00:07:33 <Adamant> *part
00:07:43 * earthy didn't get the sn?lla part
00:07:49 <shapr> snÃ¤lla = please
00:07:57 <earthy> the 'prata svenska med mig' is clear. :)
00:08:21 <magnus--> I'm still worse, I'm a Swede married to a Chinese and we're both living in the US
00:08:26 <earthy> but that's because 'praten' is dutch for 'to talk', 'met' is dutch for with, 'mij' is dutch for 'me'
00:08:38 <earthy> and dutch and swedish are quite a bit apart, but not *that* far. ;)
00:08:49 <Adamant> yeah. I know none of these languages, I just have a feel for Germanic constructions.
00:08:50 <sieni> there's no word for "snäll" in English (or in French for that matter)
00:08:50 <shapr> earthy: Swedish is sort of like Dutch, German, and a bit of French.
00:09:08 <magnus--> SnÃ¤ll = Kind
00:10:09 <magnus--> sort of anyway
00:10:27 <arcatan> swedish is quite easy, anyway
00:10:42 <shapr> arcatan: But you learned it in school!
00:10:45 <arcatan> yeah
00:10:53 <shapr> It's one of your two national languages.
00:10:54 <earthy> if you get past the throatdisease that is it's pronunciation. ;)
00:10:56 <magnus--> All the Finns hate Swedish
00:11:06 <shapr> I don't know why, I like both Swedish and Finnish.
00:11:07 <arcatan> and it was easier to learn than english or french
00:11:09 <sieni> magnus--: o.O
00:11:25 <earthy> (oh, I shouldn't say that... dutch sounds more like a throatdisease to foreigners ;))
00:11:41 <shapr> That scary Nijmegen 'g' sound.
00:11:49 * ski 's heard that about danish ..
00:12:15 <earthy> yeah, but danish is perfectly easy to understand once you know dutch and swedish
00:12:43 <earthy> I actually get along quite admirably when trying to understand spoken danish
00:12:48 <shapr> Danish and Norwegian are very similar to Swedish. I could understand Lemmih when I met him in Cambridge.
00:13:02 <magnus--> We think danes speak with porridge in their mouth in sweden
00:13:07 <earthy> ofcourse, I lose track from time to time due to not knowing any swedish
00:13:11 <shapr> Or a potato :-)
00:13:11 <Adamant> eh, this chat is reminding me of the truth of a statement I heard long ago.
00:13:26 <Adamant> Q: What do you call someone who only knows one language?
00:13:32 <Adamant> A: An American
00:13:46 <sieni> magnus--: I thought Danish is just Swedish spoken with a hot potato in the mouth
00:13:51 * Adamant only speaks horrible French
00:14:04 <magnus--> sieni: yeah, it's probably both. Potato and porridge
00:14:18 <sieni> Adamant: that's not strictly true, since most Americans don't even know English
00:14:24 <shapr> Adamant: I was born and raised in Alabama. Alabama's reputation is not entirely true.
00:14:39 <Adamant> shapr, I'm in Georgia
00:14:44 <Adamant> I know. :)
00:14:45 <shapr> Cool, whereat?
00:14:50 <Adamant> Savannah area
00:15:09 <shapr> We gotta have a Southern FP gathering.
00:15:11 <vegai> Adamant: also the French and Brits generally speak just one language, I think
00:15:18 <vegai> Germans too?
00:15:23 * nmessenger took French in high school and has "studied" Japanese informally.  He can converse in neither
00:15:24 * vegai throws out stereotypes everywhere!
00:15:33 <Adamant> sieni, we speak American!
00:15:40 * nmessenger grabs a stereotype
00:15:49 <Adamant> shapr, I'd come
00:15:55 <magnus--> nmessenger: I studied french too for 6 years, and I can't understand a thing they say on the news anymore
00:16:04 <Adamant> NC might be a good place to hold it or Atlanta
00:16:04 <shapr> Finnish stereotypes are fun. I remember when I went drinking with my friend Erno Kuusela in Helsinki...
00:16:22 <nmessenger> magnus--, I catch a noun or verb here and there, but nothing coherent
00:16:35 <magnus--> nmessenger: exactly
00:16:58 <shapr> I have Swedish audio books on CD that I play in my car.
00:17:03 <tennin> any idea when gtk2hs will have a new 6.6-buildable release?
00:17:11 <shapr> oh no! ON-TOPIC!
00:17:21 <tennin> =O
00:17:28 <shapr> Hm, I thought I heard dcoutts say something about that recently.
00:17:36 <nmessenger> *gets torches and pitchforks*
00:17:55 <shapr> tennin: Have you tried the latest from the darcs repo?
00:18:09 <shapr> tennin: btw, you're taller in person than on IRC
00:18:11 <tennin> yeah, couldn't get it to build on Windows
00:18:25 <earthy> go wxhaskell. that works with 6.6. :)
00:18:36 * earthy ducks
00:18:37 <tennin> haha... thanks?
00:18:45 * shapr grins
00:18:47 * tennin adds "buy IRC platform shoes" to his to-do list
00:18:57 * shapr laughs
00:19:18 <shapr> I'm too silly, I should probably sleep...
00:19:56 <nmessenger> shapr, is "too silly" even *defined* for you? :P
00:20:22 <magnus--> you don't need it to be if you use lazy evaluation
00:20:35 <nmessenger> shapr is non-strict!
00:20:37 <vegai> possible fix: implement instance TooSilly Shapr
00:20:43 <shapr> nmessenger: Probably not...
00:20:48 <shapr> vegai: Yes! Good Idea!
00:21:18 * nmessenger wonders what methods TooSilly would specify
00:21:22 <shapr> nmessenger: Have you been reading my HaWiki quotes or something?
00:22:25 <nmessenger> shapr, maybe, I don't remember, but I was linked to an old lambdabot quotes repo once.
00:23:35 * nmessenger visits HaWiki
00:41:12 <dcoutts__> tennin: http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.exe
00:41:29 <dcoutts__> that works on windows, it's the installer for the latest release candidate
00:41:34 * dcoutts__ -> GHC HQ
00:41:41 <shapr> yay!
00:41:54 <shapr> GHC HQ has nice couches.
00:41:59 * dcoutts__ downs tea and departs
00:45:08 <boegel> hmm, I'm really interested in the "Haskell performance analysis" thread on the Haskell mailinglist... I think me (and Itkovian, if willing) could really contribute to this
00:46:25 <dons> was that the test case thread?
00:46:33 <dons> wanting more comprehensive testing of performance?
00:47:02 <dons> if the nightly testsuite printed performance measurements, we'd probably start tuning things pretty quickly
00:47:06 <boegel> dons: yeah
00:47:13 <dons> numbers are needed to make any progress
00:47:23 <boegel> dons: nightly testsuite? of GHC?
00:47:37 <boegel> dons: numbers and a way to interpret them
00:47:40 <boegel> believe me :-)
00:48:10 <boegel> I work with numbers all day long, a staring at raw data won't learn you scratch ;-)
00:48:34 * shapr hugs boegel 
00:49:08 * boegel bites shaprs ear
00:50:03 <earthy> didn't mrchebas do the PAPI stuff?
00:50:28 <shapr> boegel: Hey, you've got a girlfriend, she won't like you being so friendly.
00:50:46 <earthy> he presented some 10% average speedup due to some RTS changes he devised
00:50:57 <boegel> shapr: she not here now, is she? :P
00:51:05 * shapr calls Joke and complains
00:51:13 <dons> boegel: more like reporting summaries of nofib program running times
00:51:15 <boegel> earthy: url to paper?
00:51:21 <dons> comapred with maximum/minima and previous days
00:51:29 <boegel> shapr: damn, you even recall her name? stalker!
00:51:36 <earthy> no paper yet, afaik
00:51:43 <shapr> Kirsten made the point that nofib isn't representative of actual use.
00:51:45 <earthy> but I'll ask him when he comes into the office
00:51:51 <shapr> boegel: You've mentioned her often enough!
00:51:53 <boegel> dons: that would help yes, but HPC metrics don't show you everything...
00:51:58 <boegel> shapr: heh, well, ok :-)
00:52:05 <dons> what did you have in mind?
00:52:43 <boegel> shapr: exactly, we need a _good_ Haskell benchmark suite, which uses various exciting, different and often used features of Haskell
00:52:54 <dons> the main point (as a developer who likes to write fast code) is that i can't get anything done unless i have some regular supply of numbers about performance
00:53:02 <earthy> boegel: and it needs to be H'98 or H'
00:53:06 <dons> then you start thinking about the speed, and trying to make the numbers smaller :)
00:53:09 <dons> its a motivating tool
00:53:10 <boegel> dons: tuning based on performance number on a small number of machines can lead to performance degradation on other machines
00:53:12 <shapr> That probably means you need to instrument a few of largest Haskell apps you can find.
00:53:17 <earthy> so that it can be used on more than just GHC
00:53:19 <boegel> earthy: yep, standard code
00:53:36 <dons> well. hmm. we have hackage now
00:53:41 <dons> that's a good suite of source
00:53:42 * earthy thinks the solutions to the shootout may help as well
00:53:46 <dons> nearly 100 packages up there
00:53:57 <dons> yeah, simonM wanted the shootout programs into nofib
00:54:11 <shapr> dons: What about a popcon-style package?
00:54:38 <boegel> earthy, dons: a standardized benchmark suite of representative Haskell programs is what we need, where-ever they come from
00:54:47 <dons> right
00:54:48 <shapr> I'd be happy to have my computer run benchmarks for an hour from 4am to 5am every morning.
00:55:05 <boegel> dons: what is Hackage exactly? latest versions of Haskell libraries?
00:55:17 <earthy> well, nofib already is a somewhat standardized benchmark suite
00:55:40 <boegel> shapr: to do it thoroughly, you'd need some dedicated computers, doing nothing else than performance measurements/analysis
00:55:50 <boegel> earthy: yes, but outdated?
00:56:00 <dons> cpan for haskell, http://hackage.haskell.org/packages/archive/pkg-list.html
00:56:09 <dons> all new packages should appear there soon enough
00:56:14 <dons> rather than random entries on the wiki
00:56:16 <earthy> so, nofib needs to be packaged, put on hackage, and developed. ;)
00:56:30 <dons> yeah
00:56:32 <boegel> dons: that's all written in Haskell?
00:56:32 <dons> that would do it
00:56:36 <dons> yeah
00:56:38 <dons> of course!?
00:56:45 <shapr> boegel: I think it's better to have a hackage package so users can install it on their computer and submit benchmarks along with hardware/OS details.
00:56:57 <dons> right
00:57:29 <boegel> dons: ok, I thought maybe some stuff was just proxies to existing libraries (I've lost the exact term)
00:58:03 <dons> oh bindings?some things are. but note that hackage is only some 5% of existing haskell libs
00:58:08 <boegel> shapr: sounds good... like the SPEC performance database (on which I did quite some analysis stuff lately, hence my interest)
00:58:10 <dons> there's 100s more on the wiki list
00:58:22 <boegel> dons: ok, cool
00:58:46 <boegel> dons: and making a standarized benchmark suite from them would make Hackage more popular beyond a doubt
00:59:19 <dons> i don't doubt hackage will become popular though :) its in alpha stage now
00:59:31 <dons> but once we redirect 'libraries' link on haskell.org to point to haskell
00:59:35 <boegel> my HRay program could also serve as a benchmark, although it's horribly slow
00:59:35 <dons> to hackage, you'll have no choice!
00:59:51 <boegel> dons: yep :-)
00:59:57 <boegel> this sounds really interesting...
01:00:09 <dons> boegel: hey, seen hpaste.org?
01:00:14 <boegel> ok, if I would want to start a wiki page for this, where woudl I do i? hawiki?
01:00:20 <shapr> Nah haskellwiki
01:00:24 <shapr> hawiki is frozen
01:00:25 <boegel> dons: I read the mail, but haven't look at it
01:00:32 <boegel> shapr: oh, sorry :-
01:00:36 <dons> ?paste <-- get you some paste code now!
01:00:37 <lambdabot> http://hpaste.org (Haskell pastebin)
01:00:42 <dons> no more lisppaste round here ;)
01:00:43 <shapr> Ashley Yakely is the wiki guy now.
01:00:49 <boegel> dons: cool
01:00:57 <dons> also, hpaste is available from hackage , :)
01:02:11 <shapr> bok gour
01:02:25 <gour> shapr: bok. when you plan to come here?
01:02:36 <shapr> Not as soon as I'd hoped.
01:02:47 <gour> any estimation?
01:03:18 * shapr thinks
01:03:48 <shapr> I'm estimating in the fourth quarter of 2007.
01:04:11 <gour> ok, enough time for us to get ready ;)
01:04:43 <dons> hehe, http://riftor.g615.co.uk/content.php?view=51&type=1
01:04:44 <lambdabot> Title: Riftor's Home
01:04:51 <dons> 'Concurrent bubble sort in Haskell'
01:05:02 <shapr> gour: Nearly enough time for me to learn conversational Hrvatska. Hey, have you seen this nifty site I'm helping with? http://www.zbornica.com/
01:05:03 <lambdabot> Title: Dobro Do&scaron;li u Zbornicu
01:05:18 * gour is looking
01:05:42 <shapr> My friend wants to use PHP because she can easily find help with that when I'm too busy, but I want to use HAppS...
01:05:46 <gour> shapr: np. people are speaking english here, or at least undestand it somewhat
01:06:31 <gour> shapr: how did you come in contact with this project?
01:07:14 <shapr> I've had a Croatian friend for the last fifteen years, she moved back to Croation recently.
01:07:23 <gour> i see...
01:07:35 <Adamant> Cro Cop!
01:07:37 <gour> so, you're sharing some cro karma ;)
01:07:49 <shapr> :-)
01:10:03 <shapr> dons: I wonder if he'd extend it to support smp.
01:10:45 * shapr thinks about literal bubble sorting on liquid cooled hardware.
01:11:01 <xpika2> how can i call a C function in haskell?
01:12:21 <shapr> xpika2: http://www.haskell.org/hawiki/FfiTutorial
01:12:22 <lambdabot> Title: FfiTutorial - The Haskell Wiki
01:13:13 <xpika2> thankyou shapr
01:13:41 <shapr> xpika2: C'mon, you're in the .au, aren't you spose to say cheers?
01:13:48 * shapr indulges in continental stereotyping!
01:14:55 <TSC> Crikey, that's bloody stereotypical, mate!
01:15:04 <xpika2> i dont play stereotyping games
01:15:25 <shapr> xpika2: I should write one, I bet it'd sell well.
01:15:33 <dons> xpika2: for example, to call the strtod function,
01:15:34 <dons> foreign import ccall unsafe "static stdlib.h strtod" c_strtod
01:15:35 <dons>     :: Ptr CChar -> Ptr (Ptr CChar) -> IO CDouble
01:15:44 <boegel> dons: so how about this Haskell benchmark suite effort? I'm willing to help somewhat if I can find the time
01:15:45 <dons> you just give it a type, and 'foreign import' it
01:15:47 <shapr> TSC: hehe
01:16:05 <dons> boegel: i'd make some queries on haskell-cafe and glasgow-haskell-users
01:16:09 <dons> to find out what SimonM had in mind as well
01:16:14 <dons> then do something like cabalise nofib
01:16:16 <dons> get it public
01:16:22 <dons> start accepting contributions
01:16:30 <dons> or have it on d.h.o
01:16:45 <earthy> ah, mrchebas is writing on the 10% increase for ICFP
01:17:03 <earthy> so the paper isn't done yet
01:17:05 <dons> the new rts perf counting is pretty important, i suspect
01:17:12 <dons> since that's the one part we tend not to be able to tune
01:17:18 <dons> libraries, compiler optimisatoins, we all ahve access to
01:17:21 <earthy> yeah, the PAPI stuff was very very important
01:17:32 <dons> but whether the rts is doing a good job, hard for anyone but Simon to know :)
01:17:32 <boegel> dons: d.h.o. ?
01:17:34 <earthy> it gave him accurate branch misprediction information
01:17:54 <earthy> dons: mrchebas was at cambridge oct-dec last year
01:17:55 <dons> boegel: darcs.haskell.org, darcs repo hosting for the core devs
01:17:58 <dons> yeah
01:18:21 <dons> ?where unify
01:18:22 <lambdabot> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
01:18:26 <earthy> the RTS trick is in pointer tagging
01:18:30 <dons> i'd like to see that get packaged up too ^^
01:18:44 <boegel> dons: I think starting with a new suite instead of building on an old, out-of-date one like nofib would be better...
01:18:48 <earthy> the important tag is 'has this thunk been evaluated or not'
01:19:06 <dons> boegel: well, there's a lot of reasonable programs in nofib though
01:19:06 <earthy> just having that tag and using it improves speed by roughly 10%
01:19:29 <dons> yeah. very nice
01:19:31 <boegel> dons: and building a database of performance data (like SPEC, see http://www.spec.org/osg/cpu2000/results) could be very interesting indeed
01:19:35 <lambdabot> Title: SPEC CPU2000 Results
01:19:37 <boegel> dons: oh, ok...
01:19:50 <dons> boegel: you need to gather community views and support.
01:20:02 <boegel> dons: yeah, sure, no way I can pull this on my own
01:20:08 <dons> start by asking the mailing list, getting some views, then we know where to go next
01:20:11 <dons> right.
01:20:12 <dons> i could maintain the repo
01:20:13 <boegel> I don't have the time nor knowledge for it
01:20:20 <dons> and would be able to contirib a fair bit
01:20:33 <dons> but if you want to start off the 'testing the waters' phsae
01:20:36 <dons> that would be good :)
01:20:50 <boegel> dons: okay, that's cool... I think me and Itkovian could atleast bring in some advice, if not even non-HPC performance analysis
01:21:12 <boegel> which will be helpfull, see my papers ;-)
01:21:22 <dons> duncan's at GHC HQ today actually, talking about performance issues
01:21:38 <dons> we've got some tight byte copying loops in binary that need to go faster
01:21:48 <dons> and the core code in ghc is perfect. the native gen holds things up
01:22:08 <dons> so this effort is timely
01:23:05 <boegel> dons: btw, what's up with HWN? The latest issue was 9-1 if I'm correct...
01:23:32 <Itkovian> boegel.
01:23:33 <Itkovian> hi
01:23:35 <boegel> Itkovian.
01:24:23 <dons> yeah, i've been travelling in europe
01:24:29 <dons> so should be one before monday
01:24:42 <dons> (back in .au now, and jet lag pretty much gone :)
01:25:03 <dons> it'll be a bonus issue, with popl and hackathon news
01:25:50 <xpika2> in the haskell ffi tutorial what does RTS stand for?
01:26:08 <dons> runtime system
01:26:08 <Korollary> the runtime system
01:26:43 <dons> the support code for memory allocation and scheduling that is hooked into your compiled haskell code
01:31:13 <boegel> dons: ok, be sure to include the stuff about HaBench (unless you have a better name for a Haskell Benchmark Suite)
01:31:15 <Itkovian> boegel: I think the graphs are still not as I want them ...
01:31:25 <boegel> Itkovian: should I come over?
01:31:32 <Itkovian> yeah baby :-)
01:31:39 <dons> get a room!
01:31:44 <Itkovian> haha
01:31:53 <boegel> if you drop the baby, I'll consider it
01:31:53 <Itkovian> we maintian distance
01:31:59 <Itkovian> of at least 40 cm
01:32:00 <dons> very professional
01:32:22 <Itkovian> yes.
01:32:30 <dons> ice cream time!
01:32:36 * dons disappears to the kitchen
01:32:37 <Itkovian> mmmmmmmmmmm
01:32:45 <amiddelk> ice cream :S
01:33:33 <amiddelk> if I stick my head out of the window I turn into an ice cream myself...
01:34:21 * dons <3 summer
01:34:35 <dons> mwhahaha
01:34:45 <amiddelk> :'(
01:34:55 <boegel> @where nofib
01:34:55 <lambdabot> I know nothing about nofib.
01:35:17 <boegel> dons: summer? dude, it's like 2?C over here, shut up!
01:36:13 <dons> hahaha!
01:36:23 <dons> yeah, i was in oxford last week. :(
01:36:29 <dons> too cold. fly south!
01:37:11 <int-e> but there's snow ;)
01:37:41 <Itkovian> anybody perchance an excel chart wizard?
01:38:06 <Korollary> How can people read philosophy...
01:38:26 <merus> Korollary: With a grain of salt.
01:38:39 <Itkovian> merus: with a truck of salt you mean
01:39:13 <Korollary> Does salt make you more patient?
01:39:15 <merus> Eh, anything more than a healthy skepticism tends to be dogmatic.
01:44:54 <boegel> Itkovian: here I am, to the rescue!
01:45:34 <boegel> dons, earthy, Itkovian, shapr: http://www.haskell.org/haskellwiki/HaBench
01:45:35 <lambdabot> Title: HaBench - HaskellWiki
01:48:41 <dons> ok. looks good
01:48:51 <dons> i'd try to get SimonM's input , he's had ideas on this
01:49:39 <dons> also, microbenchmarks comparing basic taskas against C would be useful
01:49:47 <dons> the bytecopying comparisions to C in binary were really useful
01:54:51 <JohnMeacham> jhc now has a mailing list - http://www.haskell.org/mailman/listinfo/jhc
01:54:52 <lambdabot> Title: jhc Info Page
01:55:57 <JohnMeacham> @seen musasabi
01:55:58 <lambdabot> musasabi is in #ghc, #haskell-blah and #haskell. I last heard musasabi speak 20h 49m 57s ago.
01:58:47 <musasabi> hello
01:59:17 <dons> mm, balzac,  http://companiontotheoldfoodie.blogspot.com/2006/08/balzac-on-coffee.html
01:59:19 <lambdabot> Title: The Companion to The Old Foodie: Balzac on Coffee., http://tinyurl.com/2wa35s
01:59:42 <dons> he goes kind of nuts eating coffee on an empty stomach . funny guy :)
02:01:49 <IceBear> hi there, i'd like to learn a new language. I decided that some functional programming would be a nice exercise for my brain and maybe even provide me with some nice tools to work with. But which language to start with? Why Haskell and not Erlang ... or XXX???
02:02:50 <nornagon> I liked erlang to start with.
02:02:54 <nornagon> Also Clean.
02:02:56 <roconnor> Because Haskell has one of the most expresive type systems available.  And type reduce bugs in programs.
02:02:57 <dons> haskell has a type system :) so more fun things to do
02:03:13 <dons> so yeah, erlang with more fun
02:03:21 <dons> but you could learn both!
02:03:26 <dons> simultaneously!
02:04:08 <dons> the main modern choices are either erlang or haskell, and since the communities overlap, either would be ok. though you'll not understand haskell by knowing erlang, you will understand erlang, knowing haskell
02:04:42 <nornagon> haskell seemed insurmountable to me until i tried erlang, then clean.
02:05:08 <dons> but clean's even harder? those uniquness types make monads seem easy
02:05:11 <roconnor> nornagon: oh interseting.  Perhaps my knowledge of ML helped me learn Haskell.
02:05:58 <nornagon> i didn't actually get very far into either of the languages.
02:06:16 <nornagon> but they helped me a lot in understanding some of the concepts behind FP
02:06:35 <fasta> Does anyone have implemented a Queue or knows where I get one?
02:06:47 <dons> fasta: yeah, in edison
02:06:50 <dons> ?where edison
02:06:50 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
02:07:01 <fasta> dons: Constant time amortized operations?
02:07:11 <dons> no idea. check the docs
02:07:38 <dons> IceBear: so to get started, grab ghc from http://haskell.org/ghc and visit http://haskell.org for docs and tutorials
02:07:39 <lambdabot> Title: The Glasgow Haskell Compiler
02:07:52 <wolverian> http://www.ec-petition.eu -- "Petition for guaranteed public access to publicly-funded research results"
02:07:55 <lambdabot> Title: Petition for guaranteed public access to publicly-funded research results
02:07:56 <dons> > map (\x -> x ^ 2) [1..] -- IceBear, and have a lambda!
02:07:58 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
02:08:00 <wolverian> (sorry, a bit spammish :)
02:09:42 <IceBear> thank you, i hear that Erlang is used more in "real-life" ... is that true? and why would that be?
02:10:06 <dons> probably they have around the same usage
02:10:12 <dons> haskell is used in a lot of university projects
02:10:17 <dons> erlang is used in the telcoms industry
02:10:33 <IceBear> are there main differences between haskell compilers?
02:10:47 <dons> the speed, and the number of language extensions and libraries they support
02:10:48 <musasabi> Erlang has better error handling. Haskell has niftier features.
02:10:55 <dons> ghc and hugs are the main systems
02:11:02 <IceBear> musabi: like what?
02:11:06 <nmessenger> IceBear: they all do Haskell98 well, but GHC offers many interesting (optional) extensions.
02:13:56 <matt__r> and hugs goes like the clappers
02:14:24 <matt__r> nhc is still around as well
02:14:45 <nmessenger> "like the clappers"?
02:14:55 <matt__r> it is an interesting research compiler since it is more "manageable" than ghc - although that is a subjective judgement
02:15:07 <earthy> nmessenger: ancient expression
02:15:09 <matt__r> things that go like the clappers are fast
02:15:13 <matt__r> speedy
02:15:14 <matt__r> quick
02:15:40 <nmessenger> matt__r: I had surmised that, I just hadn't heard the expression and wondered where it came from.
02:15:41 <matt__r> "I just got a V8 donk, and it goes like the clappers"
02:15:44 <earthy> derived from the 'clappers' that were sent round in cases of alarm in cities a couple of hundred years ago
02:15:54 <dons> matt__r: hehe
02:16:01 <Adamant> wot's a donk?
02:16:23 <matt__r> btw: I don't have a V8, I have a 1ltr, 3 cylinder little put-put mobile
02:16:30 <dons> hehe
02:16:37 <matt__r> but it goes like the clappers too :)
02:16:46 <nmessenger> ?all-dicts donk
02:16:47 <earthy> adamant: a donk is 'any mid-'70s ride with a sloping tail'
02:16:48 <lambdabot> No match for "donk".
02:16:57 <matt__r> donk = engine
02:17:12 <xic> guys, what ever happened to MegaMonad?
02:17:16 <earthy> this emphasises the engine bay
02:17:33 * earthy prefers the Volvo 740 he owns
02:17:51 <matt__r> programmers have the best cars
02:18:05 <earthy> well, best, best
02:18:12 <matt__r>  I love mine cos it is the closest I get to going outside :)
02:18:18 <earthy> it's good again, after having spent most of the weekends of 2006 fixing it up
02:18:31 <matt__r> if it had air conditioning, I would never need to interact with weather
02:18:36 <earthy> engine rebuilds tend to take time
02:18:42 <earthy> airco? I took that out
02:18:47 <earthy> it has heating though. :)
02:19:14 <earthy> anyway, on with the fasta shootout benchmark
02:19:19 * earthy thinks he is on to a faster version
02:19:25 <earthy> that is still quite idiomatic
02:20:52 <xic> Is Data.Map ByteString a faster and better then Data.Map String a?
02:20:53 <brainly-green> does haskell have anything like lisp's "write" method
02:20:59 <fasta> dons: Have you ever used Edison?
02:21:08 <boegel> earthy: would you be contributing to HaBench?
02:21:17 <boegel> JohnMeacham: this might interest you
02:21:18 <brainly-green> for outputting a wide variety of data structures in a uniform way, that can be read back in to create the original data structures
02:21:20 <boegel> @wiki HaBench
02:21:21 <lambdabot> http://www.haskell.org/haskellwiki/HaBench
02:21:41 <brainly-green> that is, does haskell have anything like Lisp's "read/write" methods
02:21:57 <swiert> brainly-green: they're called "read/show" in Haskell.
02:22:45 <brainly-green> swiert how powerful are they--if you defined an arbitrary type, let's say a tree type, could you show it and read it back in without a hitch?
02:23:03 <matt__r> brainly-green: yep
02:23:14 <nmessenger> @check (\x -> read (show x) == x) :: Int -> Bool
02:23:16 <lambdabot>  OK, passed 500 tests.
02:23:22 <nmessenger> @check (\x -> read (show x) == x) :: [Int] -> Bool
02:23:24 <lambdabot>  OK, passed 500 tests.
02:23:32 <matt__r> nmessenger: now that is cool
02:23:36 <Saizan> brainly-green: yes, you just need to derive the Read and Show classes
02:23:41 <earthy> boegel: I would be contributing to the shootout, initially. ;)
02:23:41 <nmessenger> try with some other type there
02:23:42 <JohnMeacham> ah. very interesting.
02:24:15 <brainly-green> ok
02:24:22 <boegel> earthy: ok, but you could be our man-on-the-inside regarding the shootout
02:24:23 <nmessenger> matt__r: praise goes to lambdabot :)
02:24:44 <JohnMeacham> boegel: nofib has some neat stuff in it. be sure to have a reasonably large 'Haskell 98 only' set of benchmarks. ghcisms snuck into a lot of the nofib benchmarks and no one noticed...
02:25:02 <nmessenger> @check (\x -> read (show x) == x) :: Either String Int -> Bool
02:25:04 <lambdabot>   add an instance declaration for (Arbitrary (Either String Int))     In the ...
02:25:19 <fasta> dons: Without hierarchical modules in Haskell you could just put a symbolic link to some guy's library, include it in the search path and be done. Now, you cannot just refer to only the directory with the module you need. You need to refer every single directory in that module. Another way to "solve" this problem  is to install the library, but this makes improving the library more difficult, since you need to setup
02:25:19 <fasta> your environment first, s.t. it can load in the first place.
02:25:22 <boegel> JohnMeacham: excuse my ignorance, but what's ghcisms?
02:25:57 <JohnMeacham> boegel: GHC-isms, as in ghc specific stuff.
02:26:35 <boegel> JohnMeacham: ah ok... I'll add that (and multiple Haskell compilers) to the idea list
02:26:57 <JohnMeacham> well, also it was that the testing framework was very ghc specific, it basically only ran within the ghc source tree so nofib couldn't be separated out. I have the start of a test suite for jhc in the 'regress/' directory.
02:27:07 <boegel> which Haskell compilers (which are usefull) are there out there, besides GHC?
02:27:36 <boegel> JohnMeacham: ok, so nofib is GHC only?
02:28:10 <JohnMeacham> pretty much every compiler has a mode similar to 'ghc --make', so just let the user specify an arbitrary command line for the compiler to use like 'jhc -v -flint $< -o $@'  or 'ghc --make $< -o $@'
02:28:52 <boegel> JohnMeacam: which other compilers besides GHC and JHC should we consider?
02:28:59 <JohnMeacham> boegel: no, I mean, most of the code is easily made portable, but the testing framework is very ghc specific.
02:29:23 <boegel> JohnMeacam: the testing framework of GHC itself (using nofib) ?
02:29:41 <JohnMeacham> boegel: yeah, whatever was in the repo when I pulled my copy.
02:30:34 <boegel> JohnMeacham: ah, ok, but we would probably want to build our own test framework
02:30:58 <JohnMeacham> yeah.
02:31:30 <boegel> JohnMeacan: can I add you the the contributors list? as?
02:31:40 <JohnMeacham> don't worry about any compiler specific stuff, you shouldn't need to hard code any into it.
02:32:11 <JohnMeacham> sure, I will be interested in following it and getting some real benchmarking will be very good for jhc.
02:32:36 <brainly-green> it's fair to say that, at least for now, common lisp has a lot more libraries than haskell
02:32:38 <brainly-green> right
02:32:59 <brainly-green> more features
02:33:12 * yaarg wonders how many of those libraries actually worked and/or are actively maintained
02:33:19 <fasta> How would you load e.g. Edison? Edison has two branches with Data, so, AFAIK, you can't load it when you load directories only.
02:33:44 <JohnMeacham> sure, lisp has a lot more shortcomings that need libraries to work around. :)
02:34:00 <fasta> brainly-green: can you name 5 good libraries?
02:34:25 <fasta> I mostly saw crap (at least for the things I was interested in)
02:34:38 <brainly-green> well, apparently there's a haskell in lisp
02:34:40 <yaarg> yup, it's true
02:34:42 <brainly-green> and there's allegro prolog
02:34:48 <boegel> JohnMeacham: ok, added you and your suggestions :-) thanks!
02:35:03 <yaarg> i love lisp but it's just not a practical language like haskell these days
02:35:06 <fasta> brainly-green: and does this haskell in lisp work?
02:35:07 * yaarg shrugs
02:36:01 <brainly-green> I don't know
02:36:21 <fasta> Using "hey you can use Prolog in Lisp" as one of your best arguments shows your arguments are weak or you are not rational.
02:36:45 <JohnMeacham> it would be cool if it could benchmark how long the compilers take to compile the code as well.
02:36:52 <brainly-green> I don't have strong arguments myself, those are just the things that made me think
02:37:20 <brainly-green> and I've read stuff by the guy who owns gigamonkeys indicating that common lisp is intended as a practical language
02:37:47 <fasta> I think Scheme is a better language than Haskell, but lack of good tools make me go for Haskell. (Haskell also lacks tools, though)
02:37:49 <Adamant> you can use either language for practical stuff.
02:37:49 <brainly-green> I'm not being confrontational, just comparing the state of the 2 languages
02:38:17 <brainly-green> I know a little of both and I am going to choose now which to learn a lot more of, I think I'm going with common lisp because of the more tools available
02:38:25 <Adamant> let me put it this way, neither Haskell or Common Lisp is exactly common in industry at this point in time.
02:38:42 <Adamant> whatever their respective merits.
02:38:43 <brainly-green> I don't care about industry this is for an academic project
02:38:54 <boegel> earthy: I added you to the HaBench page... are you ok with that?
02:38:59 <fasta> I wonder whether the code in "industry" is actually good.
02:39:06 <nmessenger> brainly-green: Haskell is good because its a lot harder to write C code in it than Common Lisp
02:39:19 <nmessenger> *than in Common Lisp
02:39:43 <Adamant> the biggest problem with "writing C code" is memory safety, and both Haskell and Common Lisp effectively solve that.
02:39:51 <nmessenger> Er, so I would believe anyway.  I've no lisp experience.
02:40:07 <fasta> Common Lisp has SLIME which is a big plus.
02:40:14 <brainly-green> in my view, haskell advantages over CL:  type system + pure functional, haskell disadvantages: non-uniform syntax, no macros
02:40:33 <Adamant> Haskell is lazy, too
02:40:34 <brainly-green> and then libraries/features which CL looks like it has more of
02:40:44 <nmessenger> ?google Does Haskell need macros?
02:40:47 <lambdabot> http://neilmitchell.blogspot.com/2007/01/does-haskell-need-macros.html
02:40:47 <lambdabot> Title: Neil Mitchell's Haskell Blog: Does Haskell need macros?
02:40:55 <brainly-green> yes I've read that article
02:41:17 <JohnMeacham> non-uniform syntax?  lazyness obviates the need for macros actually in most all cases.
02:41:22 <fasta> I find it a bit odd that Neil wrote that article, since AFAIK, he didn't write tons of macros in e.g. Common Lisp.
02:41:46 <fasta> How can you answer the question if you lack the experience?
02:42:26 <brainly-green> however much you "don't need" macros, a lack of them means that you can't define your own syntax so easily, the language is not as "living" as it could be
02:42:39 <brainly-green> just in my opinion
02:42:50 <JohnMeacham> I used to be a scheme-head, I have also been a sather-head, a c++-head and a C ninja. but I think I will make my home here.
02:43:09 <nornagon> :)
02:45:00 <fasta> Now, when Oleg would write such an article....
02:45:18 <apfelmus> huh, there are other languages besides Haskell?
02:45:25 <fasta> :)
02:45:27 <JohnMeacham> haskell has great support for defining your own constructs, you just don't notice nor does it need a special macro thing because it is sort of the standard way to use the language.
02:45:36 <nmessenger> Adamant, brainly-green: what I meant was that while pure, no-side-effect code is natural in both languages, side-effect-ful stuff must be more explicit in Haskell (from what I've seen; again, no lisp experience).
02:46:11 <matt__r> dons: you back yet?
02:46:24 <brainly-green> well like the loop macro in common lisp, how could you do that in haskell?  could you do it?
02:47:00 <nmessenger> brainly-green: yes, there are some functions that hook together IO actions.
02:47:06 <brainly-green> it's pretty useful and concise for a lot of things you need to do with loops, but it's also its own separate language
02:47:21 <boegel> yo BCoppens: add yourself to the HaBench contributors list (and help out, of course)
02:47:25 <boegel> @wiki HaBench
02:47:25 <lambdabot> http://www.haskell.org/haskellwiki/HaBench
02:47:39 <brainly-green> it's not just a loop of declarative statements, it has a lot of special syntax like "collecting"
02:47:54 <apfelmus> :t sequence
02:47:55 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
02:47:56 <michaelw> oh, that fits, sort of
02:48:01 <apfelmus> :t foldM
02:48:03 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
02:48:07 <michaelw> so, how again do people time haskell snippets without tripping over lazy evaluation?
02:48:49 <apfelmus> michaelw: mh? what do you mean?
02:49:05 <nmessenger> michaelw: timing?  Hmm, possibly with profiling?
02:49:38 <kowey> michaelw: personal exprience is to just time the whole thing from the outside
02:49:44 <BCoppens> morning boegel
02:49:46 <michaelw> apfelmus: say I have a function withCPUTime :: a -> IO (a,Time).  to make the measurement meaningful I must ensure that the argument is evaluated
02:49:50 <nmessenger> or something like a timeToPerform :: IO () -> IO Double function?
02:49:53 <BCoppens> boegel: is that related to your research or so?
02:50:00 <kowey> michaelw: this may not be the best advice, but i also work by disabling bits and then subtracting from the total time
02:50:13 <roconnor> @type evaluate
02:50:14 <lambdabot> Not in scope: `evaluate'
02:50:23 <roconnor> @hoogle evaluate
02:50:23 <lambdabot> Control.Exception.evaluate :: a -> IO a
02:50:24 <lambdabot> Test.QuickCheck.evaluate :: Testable a => a -> Gen Result
02:50:27 <michaelw> roconnor: Control.Exception.evaluate is not good enough
02:50:37 <roconnor> you need normal form?
02:50:46 <brainly-green> oh also prettiness, haskell is prettier than common lisp
02:51:14 <apfelmus> michaelw: i just use ghci with :set +s +r and evaluate single functions
02:51:15 <michaelw> roconnor: yes, fully evaluated, and printing it out (my current band aid) sucks :/
02:51:19 <brainly-green> too many parentheses is bad and you don't want prefix notation ALL the time
02:51:41 <nmessenger> brainly-green: how familiar are you with Haskell syntax?
02:51:50 <brainly-green> and that can't be fixed cleanly with macros
02:51:51 <michaelw> kowey: yeah, but you still need to ask for the result, otherwise Haskell won't be doing much :)
02:51:57 <nmessenger> you know of sections and the like?
02:52:24 <nmessenger> michaelw: easy then, just type it in ghci :P
02:52:25 <roconnor> we need a normalize function added.  It doesn't seem so unreasonable.
02:52:28 <michaelw> apfelmus: I'd rather not depend on ghci
02:52:50 <brainly-green> I don't know the term "section," no, but a few months ago (round October) I wrote a bunch of little stuff experimenting with haskell
02:52:54 <brainly-green> I know what it looks like
02:53:03 <michaelw> I remember something like deepSeq, but it seems that never took off
02:53:06 <kowey> michaelw: oh yeah, right... i found when working with lists that it's helpful to take their length
02:53:09 <apfelmus> michaelw: why not? ghic can load compiled .o files
02:53:21 <apfelmus> *ghci
02:53:30 <kowey> michaelw: but i still don't have a good grasp of this, so listen to the others instead of me :-)
02:53:34 <michaelw> apfelmus: I don't want users to install ghc, I'd rather just distribute a binary
02:54:04 <nmessenger> michaelw: so you want end-user-facing code snippet timing?
02:54:06 <michaelw> kowey: not good enough, if the list element kick off a potentially long computation, and you never ask for its result
02:54:09 <apfelmus> ah, you don't need the timing for tuning running time
02:54:52 <michaelw> nmessenger: yes, as i said. i want a function withCPUTime :: a -> IO (a, SomeTimeType)
02:55:08 <brainly-green> just to emphasize I was counting appearance as an _advantage_ for haskell
02:55:08 <apfelmus> you just want to show the user how long he had to wait?
02:55:28 <gotaku> Is there a good haskell mode for Vim?
02:56:02 <nmessenger> brainly-green: yeah, and I'd agree, but appearance is rather subjective.
02:56:05 <michaelw> apfelmus: I want to collect the time and pipe it through gnuplot eventually
02:56:48 <kowey> gotaku: i use this one http://computerscience.nl/people/arthurvl/haskell.vba (don't forget to turn off cindent)
02:57:15 <thedward> gotaku: my version of vim came with a haskell syntax file
02:57:52 <apfelmus> michaelw: ok, you want to spit out times automatically. mh, maybe the profiler can do? but anyway, there is
02:57:53 <apfelmus> ?hoogle getCPUTime
02:57:54 <lambdabot> CPUTime.getCPUTime :: IO Integer
02:58:34 <Itkovian> boegel: I think I'm scratching the graph idea ... it will be too tough to do with all the positive and negative combinations
02:58:34 <Elifant> Does anybody has idea of small haskell lib? just to practise in Haskell? Something that is simple enough for me but too simple to implement for others? :)
02:58:49 <michaelw> apfelmus: i am using that, the real problem is to keep the WHOLE evaluation to NF within two calls to getCPUTime, otherwise the measurement is not meaningful
02:58:53 <earthy> drat.
02:59:43 <apfelmus> withCPUTime x = do { t1 <- getCPUTime; evaluate x; t2 <- getCPUTime; return $ (x, t2-t1); }
03:00:03 <apfelmus> ah, sorry, evaluate doesn't do deepSeq
03:00:07 <michaelw> apfelmus: I had exactly that. but it is not good enough.
03:00:10 <michaelw> precisely
03:00:26 <kowey> Elifant: maybe not a library, but the darcs project could use some help
03:01:26 <kowey> Elifant: http://bugs.darcs.net/issue388 <-- this is my favourite thing to suggest to new developers
03:01:37 <lambdabot> Title: Issue 388: darcs amend-record should allow you to edit metadata - Darcs issue tr ...
03:01:38 <michaelw> apfelmus: evaluate (if x==x then x else x), but ugh... :(  and it depends on ghc being dumb and Eq-ness being strict, and I can easily imagine a non-strict ==
03:02:03 <kowey> Elifant: http://bugs.darcs.net/issue161 <-- oops, i meant this
03:02:08 <lambdabot> Title: Issue 161: Enable amend-record to change patch name, description and author. - D ...
03:02:12 <earthy> dratterdiedrat. prescaling to int doesn't work.
03:02:18 <apfelmus> michaelw: i think you can have   deepEvaluate x = catch (x `deepSeq` return x) throw
03:02:24 <Elifant> kowey: hm... I haven't even use darcs...
03:02:27 <apfelmus> ?hoogle deepSeq
03:02:28 <lambdabot> No matches found
03:03:36 <apfelmus> ?src deepSeq
03:03:36 <lambdabot> Source not found. Are you on drugs?
03:03:53 <michaelw> apfelmus: Unless somebody has deepSeq instances for much of standard lib, this will be a lot of work (I am using maps and arrays)
03:04:13 <nornagon> "one two three" -> ("one","two three") ?
03:04:24 <nornagon> by which i mean, is there a function that does that?
03:04:26 <michaelw> hmm, can drift generate deepSeq?
03:04:38 <blackdog> greetings, earthlings.
03:04:43 <apfelmus> michaelw: afaik, deepSeq is a normal function like seq
03:05:02 <nornagon> ?hoogle String -> (String,String)
03:05:03 <lambdabot> No matches, try a more general search
03:05:03 <Elifant> nornagon: span (/= ' ')
03:05:07 <nornagon> :t span
03:05:09 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
03:05:11 <michaelw> nornagon: break Char.isSpace
03:05:15 <Elifant> > span (/= ' ') "one two three"
03:05:17 <lambdabot>  ("one"," two three")
03:05:33 <nornagon> > break Char.isSpace $ "one two three"
03:05:35 <lambdabot>  ("one"," two three")
03:05:42 <Elifant> > let (a, b) = span (/= ' ') "one two three" in (a, tail b)
03:05:44 <lambdabot>  ("one","two three")
03:05:46 <kowey> Elifant: other things on my wishlist are a port of the Zen toolkit to Haskell (maybe not small) and a TeX parser
03:05:55 <michaelw> apfelmus: are you sure? :)
03:06:05 <nornagon> Elifant: not quite; i want to make it eat all whitespace
03:06:08 <nornagon> lexeme-style
03:06:11 * Elifant goes to read about what Zen is...
03:06:20 <michaelw> kowey: a TeX parser is not an easy thing if you want to do it right
03:06:31 <Elifant> nornagon: so give another example
03:06:51 <kowey> michaelw: i fear as well... /me is overambitious for others
03:06:57 <nornagon> Elifant: sure. "one\n      two\tthree" -> ("one","two\tthree")
03:07:14 <michaelw> nornagon: look at Parsec, it has a whitespace lexer
03:07:25 <nornagon> michaelw: i was hoping for something lighter-weight.
03:07:55 <apfelmus> michaelw: i think GHC implements it and it has been proposed for Haskell'. but i don't know in which module it resides
03:08:05 <michaelw> nornagon: define lightweight.  parsec means minimal code-writing for you
03:08:28 <michaelw> apfelmus: I didn't find it either, but i will look more after lunch
03:08:36 <nornagon> michaelw: i'm fine with writing code; i just don't really want to bring parsec into it.
03:08:43 <nornagon> maybe i should look into regex stuff.
03:09:24 <nmessenger> :t (\(x:xs) -> (x, unwords xs) . words
03:09:27 <lambdabot> parse error (possibly incorrect indentation)
03:09:33 <nmessenger> :t (\(x:xs) -> (x, unwords xs)) . words
03:09:35 <lambdabot> String -> (String, String)
03:09:55 <nornagon> > (\(x:xs) -> (x,unwords xs)) . words $ "one two three"
03:09:57 <lambdabot>  ("one","two three")
03:09:58 <nmessenger> (compresses whitespace into one space)
03:10:05 <nornagon> > (\(x:xs) -> (x,unwords xs)) . words $ "one two               three"
03:10:07 <lambdabot>  ("one","two three")
03:10:22 <nornagon> > (\(x:xs) -> (x,unwords xs)) . words $ "one two         \t\n\n      three"
03:10:22 <Saizan> > let (a, b) = span (/= ' ') "one two three" in (a, dropWhile Char.isSpace b)
03:10:24 <lambdabot>  ("one","two three")
03:10:25 <lambdabot>  ("one","two three")
03:11:11 <kowey> Elifant: http://www.cs.chalmers.se/~markus/FM/ <-- if you like the Zen idea, this is probably nice to look at
03:11:14 <lambdabot> Title: Functional Morphology
03:11:33 <Itkovian> boegel: lunch
03:11:46 <boegel> Itkoyep!
03:12:18 <earthy> hm.
03:12:31 <nmessenger> > (\(x,y) -> (x, dropWhile (==' ') xs)) . break (==' ') $ "one\t two   three"
03:12:32 <lambdabot>   Not in scope: `xs'
03:12:39 <nmessenger> > (\(x,y) -> (x, dropWhile (==' ') y)) . break (==' ') $ "one\t two   three"
03:12:40 <lambdabot>  ("one\t","two   three")
03:12:59 <nmessenger> (==' ') -> isSpace if you like
03:13:33 <Saizan> > Char.isSpace '\t' -- i tought it was like \s
03:13:35 <lambdabot>  True
03:13:42 <Saizan> nad it is
03:13:48 <Saizan> *and
03:13:59 <nmessenger> yeah, I meant if you want that behaviour, change it.
03:14:09 <nornagon> i do thanks
03:14:11 <earthy> *right*
03:14:18 <earthy> see, I knew it could be done.
03:14:20 <nornagon> s/o/o,/
03:14:56 <Elifant> kowey: if I've found right Zen, then I have to learn OCaml to port toolkit to learn Haskell :)
03:15:09 <nornagon> now i'll go turn it into a function that also parses "\"foo bar\"" and "[1 2 3 4 5]" :)
03:15:18 <nornagon> i think maybe i should just use regexes.
03:15:40 <earthy> that's a speedup of a factor 3
03:15:44 <Elifant> nornagon: or 'reads'
03:15:49 * nmessenger is reminded of a newbie's blog post with a similar problem to nornagon's
03:16:10 <kowey> Elifant: two more ideas... one thing i would also love to see is a friendly all-in-one maybe graphical interface to the ghc profiling stuff
03:16:22 <nornagon> Elifant: hm...
03:16:28 <kowey> (this is a project which involves finding lots of libraries and using them!)
03:17:02 <kowey> Elifant: another thing maybe is to see if there is a library idea lurking around in the 'safe strings' blog posts, see http://blog.moertel.com/articles/2006/10/18/a-type-based-solution-to-the-strings-problem
03:17:02 <Elifant> kowey: then I need a definition of "friendly all-in-one" interface
03:17:05 <lambdabot> Title: A type-based solution to the "strings problem": a fitting end to XSS and SQL-inj ..., http://tinyurl.com/uv94m
03:18:11 <apfelmus> i don't know, but safe strings are weaker than Text.Html
03:18:59 <kowey> Elifant: http://hal.inria.fr/docs/00/08/87/87/PDF/haskell01-kow.pdf <-- in section 5.2.1 of this paper, i suggest one (maybe vague?)
03:19:13 * nmessenger finds that post: http://blogs.nubgames.com/code/?p=15
03:19:16 <lambdabot> Title: Nub Games Â» Haskell &#8212; First Impressions
03:19:54 <nmessenger> but nornagon, if your parser is adding more crazy cases, I'd seriously consider Parsec.
03:20:23 <nornagon> nmessenger: *nod*
03:20:52 <nornagon> > matchRegex (mkRegex ".+") "foobar"
03:20:53 <lambdabot>   Not in scope: `mkRegex'
03:21:06 <nornagon> > Text.Regex.matchRegex (Text.Regex.mkRegex ".+") "foobar"
03:21:07 <lambdabot>   Not in scope: `Text.Regex.mkRegex'
03:21:11 <nornagon> :(
03:21:44 <nornagon> i guess i'll just use parsec then
03:21:57 <nmessenger> nornagon: ever used it before?
03:21:59 <nornagon> yeah
03:22:21 <nornagon> you might've noticed some questions about scheme in here before :)
03:22:35 <nornagon> from me, that is.
03:25:17 <fasta> Can anyone tell me how to load Data.Edison.Seq.SimpleQueue without installing Edison in a simple way?
03:30:07 <earthy> hm. that's strange. the strict bytestring is faster for the fasta benchmark than the lazy bytestring, by a factor of about 2
03:30:35 <earthy> and it seems that walking a searchtree *doesn't* speed up finding the base
03:32:23 <JohnMeacham> what is the canonical homepage of the Data.Binary and zlib projects? like, what should I put in the jhc docs.
03:34:41 <csci> !paste
03:34:41 <hpaste> Haskell paste bin: http://hpaste.org/
03:35:32 <csci> I'm not sure why it's not shown, but I have a problem using ".", could someone please take a look http://hpaste.org/118
03:36:09 <earthy> ?where binary
03:36:10 <lambdabot> http://darcs.haskell.org/binary
03:36:13 <earthy> ?where zlib
03:36:13 <lambdabot> darcs get http://haskell.org/~duncan/zlib
03:37:20 <nmessenger> csci: fib is a function, fst takes a tuple, you might pass some args to fib so it results in a tuple
03:38:04 <csci> But I thought with the dot you can combine functions to new ones?
03:38:24 <nmessenger> > (fst .) . (undefined :: (Ord k, Num a, Num k) => k -> M.Map k a -> (a, M.Map k a))
03:38:25 <lambdabot>  Add a type signature
03:38:31 <csci> i.e. I'd like to have fib' = fst . fib and then : fib' bra bla
03:38:44 <nmessenger> try (fst .) . fib
03:39:35 <nmessenger> the problem is the arity, 'fib x' results in a function so 'fst . fib = fst (fib x)' which doesn't type.
03:40:21 <csci> nmessenger: yes, right
03:40:24 <csci> I see
03:40:38 <csci> but why does (fst .) . fib work?
03:40:41 <csci> (fst .) . fib :: (Ord a, Num a1, Num a) => a -> Map a a1 -> a1
03:41:06 <nornagon> :t (fst .) .
03:41:08 <lambdabot> parse error (possibly incorrect indentation)
03:41:14 <nornagon> :t (.) (fst .)
03:41:16 <lambdabot> forall a b a1 a2. (a2 -> a1 -> (a, b)) -> a2 -> a1 -> a
03:41:18 <nmessenger> fib gets an x, it results in a function.  That function is passed to (fst .), which attaches 'fst' to its result
03:41:56 <csci> ah ok
03:42:01 <csci> thanks for the explanation
03:43:37 <Saizan> (fst .) . fib = \x -> (fst .) (fib x) = \x -> \y -> fst ((fib x) y) = \x y -> fst (fib x y)
03:45:28 <nmessenger> succinct and precise, but sometimes natural language helps in understanding
03:45:39 <earthy> wow
03:45:45 <earthy> this is weirding me out no end
03:46:52 <earthy> performance in Haskell truly is a dark art
03:49:28 <dancor> how do you guys usually do unit tests on new modules
03:49:43 <dancor> there is nothing like python's if __name__ == '__main__' thing is there?
03:50:02 <dancor> or can you just throw a main in any file
03:50:19 <dancor> and it will only get made if that file is a primary target to ghc --make
03:51:05 <dancor> actually i see HUnit now
03:51:38 <nmessenger> dancor: do you know of QuickCheck?  It's probably better for pure code.
03:52:35 <dancor> nmessenger: i'll look at that too
03:53:05 <nmessenger> @check (\xs -> reverse (reverse xs) == xs) :: [Int] -> Bool
03:53:07 <lambdabot>  OK, passed 500 tests.
03:53:53 <matthew_-> > let f x = (x [1,2], x ['a', 'b']) in f reverse
03:53:54 <lambdabot>   add an instance declaration for (Num Char)
03:53:55 <lambdabot>     In the list element: 1
03:55:15 <earthy> why the *hell* does using a searchtree work for C but not for Haskell? :)
03:58:57 <xpika2> my gcc doen't like my ghc generated code, i get errors like: Fibonacci_stub.c:15: error: cannot convert âCapability*â to âStgClosure*â
04:00:11 <matthew_-> > let (f x = (x ['a','b'], x [1, 2])) :: forall a . (a -> a) -> ([Char], [Int]) in f reverse
04:00:11 <lambdabot>  Parse error
04:00:12 <matthew_-> agh
04:01:41 <JohnMeacham> searchtree?
04:05:06 <araujo> morning
04:05:17 <matthew_-> ok, this is clearly just a syntax issue, how should I write this?
04:05:18 <matthew_-> > let f x = (x ['a','b'], x [1, 2]); f :: (forall a . a -> a) -> ([Char], [Int]) in f reverse
04:05:19 <lambdabot>  Parse error
04:06:54 <int-e> earthy: hmm. because the probabilities for most entries is very small, perhaps
04:07:26 <int-e> earthy: (note that the best tree would be balanced by probability, not by size)
04:08:41 <JohnMeacham> shouldn't it be forall a . [a] -> [a] ? not that that would cause a parse error
04:08:55 <nmessenger> also Ord a?
04:09:02 <nmessenger> no, nvm
04:09:06 <earthy> int-e: I know, but just generating the tree as is done in the C version *slows* *down* the fasta code by 50%
04:09:29 <bringert_> dcoutts, Igloo: What's the difference between http://urchin.earth.li/darcs/igloo/inflate/ and http://haskell.org/~duncan/zlib/  ?
04:09:31 <lambdabot> Title: Index of /darcs/igloo/inflate
04:09:42 <int-e> earthy: hmm. did you paste the code anywhere?
04:09:49 <earthy> nah
04:09:56 <earthy> I can though
04:10:00 <matthew_-> JohnMeacham: quite. It's the syntax I can't get write.
04:10:06 <int-e> I'd like to have a look at it.
04:10:14 <matthew_-> JohnMeacham: agh, right. not write!
04:11:54 <JohnMeacham> do you need -fglasgow-exts ?
04:11:55 <boegel> BCoppens: the HaBench proposal has somewhat todo with my research, yes
04:11:55 <earthy> ah, fuck. that one's wrong
04:12:20 <boegel> BCoppens: but a lot of people seem to think there is a need for a Haskell Benchmark Suite, so gathering thoughts on the subject seemed like a nice idea...
04:12:44 <matthew_-> JohnMeacham: yes. but I thought lambdabot had that anyway
04:13:01 <ndm> boegel: nofib is already the haskell benchmark suite, if thats not sufficient why not work starting from that
04:13:15 <hpaste>  earthy pasted "tree for choosing base slows code down" at http://hpaste.org/120
04:13:17 <boegel> ndm: yes, I agree... see the wiki
04:13:18 <int-e> matthew_-: before it evaluates anything the expression is parsed by a parser that only understands haskell 98
04:13:20 <boegel> @wiki HaBench
04:13:21 <lambdabot> http://www.haskell.org/haskellwiki/HaBench
04:13:41 <boegel> ndm: but it seems it's a bit out-of-date, and contains some GHC-specific code
04:13:59 <boegel> ndm: but you're right, it seems like a good place to start from
04:14:14 <ndm> boegel: sounds like a fantastic idea, exactly what i need for my super-optimisation work :)
04:14:31 <int-e> matthew_-: the Plugs module does that. the reason is a long history of tricking it into running funny code like   0:scanl1 (+) 1 xxx   (which printed the fibonacci numbers at one point)
04:14:46 <ndm> boegel: definately a good idea to keep them Haskell 98, then allow specialised variants for GHC etc with unboxing - so everyone can play
04:15:01 <matthew_-> int-e: ahh, thanks
04:15:14 <ndm> boegel: i was more just wondering why you couldn't call it nofib? since everyone knows what nofib is already, and no point having two competing benchmarks
04:15:37 <earthy> because nofib is tied to ghc
04:15:44 <earthy> which you don't want
04:16:06 <ndm> earthy: why is it tied to GHC?
04:16:13 <int-e> earthy: I'd blame lazyness.
04:16:20 <int-e> earthy: and try a custom strict tree.
04:16:25 <earthy> int-e: yeah
04:16:40 <ndm> earthy: the current version, but if you want to move forward with a new benchmark, i'd rather it was called nofib, otherwise you end up with two benchmark suites, if you call the new one nofib then you nicely kill nofib
04:17:26 <Igloo> bringert_: Duncan't is a zlib binding, mine is Haskell code
04:17:44 <earthy> ndm: true enough
04:18:00 <apfelmus> how about nonofib. i mean no, nonofib is not nofib
04:18:36 <ndm> plus if you don't name it nofib, then when doing performance analysis in a paper everyone will ask "you used HaBench, why not nofib"
04:18:37 <rahikkala> If nonofib is not nofib, what is fib?
04:18:45 <earthy> int-e: using data BinTree = Node !(Char,Double,Double) !BinTree !BinTree
04:18:49 <earthy> doesn't help one bit
04:18:51 <bringert_> Igloo: ah, thanks. I thought it was, but there was so much Haskell code in it, and I couldn't find any foreign imports at first glance.
04:19:31 <earthy> b'sides which: the frequencytree is evaluated only once, and then matched strictly in chooseBase'
04:19:38 <bringert_> Igloo: there's an almost-clash of your guys' module names
04:19:53 <earthy> using that BinTree
04:20:18 * earthy is going to blame having 2 comparisons
04:20:27 <bringert_> rahikkala: nofib is called nofib because it is not a fibonacci benchmark
04:20:45 <Igloo> bringert_: Heh, looks like it's all in Stream.hsc
04:20:53 <bringert_> Igloo: yeah
04:21:07 <Igloo> bringert_: That's bad, because there should be a complete clash. The spec must be too ambiguous
04:21:39 <bringert_> :-)
04:21:53 <JohnMeacham> oddly enough, the benchmarks on the lanugage shootout page arn't much better than fibonacci when it comes to real programming. nofib has a lot of real and non-trivial programs in it, which is very nice. if it could get a compiler independent driver and cleaned up independently from ghc.. that wousd be nice.
04:22:09 <int-e> earthy: hmm. data Tree = Single !Char | Node !Double Tree Tree | Leaf !Double !Char !Char
04:22:38 <int-e> earthy: based on the proposal on the wiki; the idea is that the Double marks the point that splits the left from the right.
04:22:48 <bringert_> haha, Java code looks funny when typeset with lhs2tex
04:23:20 <bringert_> all the dots become function composition rings
04:23:30 <matthew_-> s/ when typeset with lhs2tex//
04:23:32 <matthew_-> ;)
04:23:53 <int-e> earthy: missing two strictness annotations in Node of course.
04:24:01 <apfelmus> int-e, earthy: i don't get what the fasta should do, the problem description is awfully short. can you help me?
04:24:37 <earthy> oh, it outputs 3 strings.
04:24:45 <earthy> but, read the code that's in the paste
04:25:07 <apfelmus> i hoped to avoid that.
04:25:17 <earthy> the first string is trivial, and I don't see much of a speedup: you just generate a replicated string
04:25:21 <apfelmus> paste? or haskellwiki?
04:25:24 <boegel> ndm: ok, sounds like a good suggestion... My reason for renaming it was to make it clear: HaBench is a new benchmark suite (which will probably partially/fully include nofib), and it should become _the_ Haskell Benchmark Suite
04:25:30 <int-e> apfelmus: generate a bunch of random numbers, and find the appropriate letter in a frequency table, that's the difficult part.
04:25:35 <JohnMeacham> no. don't strictify those.
04:25:38 <boegel> ndm: besides, I think nofib is quite old, is it not? or is it still updated?
04:25:40 <earthy> the second and third strings are weighted random generated
04:26:01 <ndm> boegel: yes, and i see the logic, but if it isn't called nofib then anyone submitting benchmarks for anything will _have_ to run nofib as well, despite it being a waste of time
04:26:09 <apfelmus> int-e: ah. interval tree?
04:26:12 <earthy> but really, the haskell code is 55 lines or some such
04:26:17 <int-e> apfelmus: basically.
04:26:30 <ndm> boegel: plus by renaming it to nofib, you become the haskell benchmark suite automatically :)
04:26:48 <earthy> however, the interval-tree approach to finding the right value by weight slows the code down as compared to the linear search
04:27:02 <int-e> earthy: why do you have two comparisons?
04:27:13 <earthy> int-e: look at the tree.
04:27:27 <xpika> has anyone got rlwrap to work with ghci?
04:27:29 <earthy> it doesn't have the chars in the leafs
04:27:42 <earthy> I'm improving on that as we speak
04:27:54 <int-e> earthy: oh you have a ternary tree, sort of.
04:27:59 <earthy> sort of
04:28:10 <JohnMeacham> boegel: I think whenever anyone needs to use it, they pull out the last copy, modify it to suit their needs, use it to benchmark their thing, then throw it away. but by no means should one start from scratch, there are some pretty sweet benchmarks in there, like 'gzip' implemented in pure haskell, a whole strictness analysis pass of a compiler,  a quantum mechanics simulator and other _real_ stuff. if anything, more task
04:28:10 <JohnMeacham> s like that need to make it into the language shootout.
04:29:12 <JohnMeacham> I mean, the infrastructure around nofib is bitrotting, but the tests themselves are superb.
04:33:23 <apfelmus> mh, the c++ version of fasta uses simple linear search
04:33:24 <earthy> hm. using data BinTree = Node !Double !BinTree !BinTree
04:33:24 <earthy>              | Leaf !Char
04:33:24 <earthy>              | NilTree
04:33:38 <earthy> and chooseBase' (Leaf c) p = c
04:33:38 <earthy> chooseBase' (Node b left right) p
04:33:38 <earthy>         | p < b     = chooseBase' left p
04:33:38 <earthy>         | otherwise = chooseBase' right p
04:33:44 <beelsebob> any germans in here... what would a german call a blue tit?
04:33:51 <earthy> doesn't help one bit.
04:34:08 <beelsebob> erq! why all the strictness in there?
04:35:10 <JohnMeacham> off to bed. got work in 5 hours.
04:35:22 <apfelmus> beelsebob: http://dict.leo.org => Blaumeise
04:35:43 <boegel> JohnMeacham: ok, understood. So that means I'll make sure those tools make in the new benchmark suite (whatever it's) called
04:36:09 <earthy> beelsebob: the strictness is due to wanting this to go *FAST*
04:36:14 <boegel> ndm: maybe it's a good idea to call it nofib 2.0 or something... the idea would be to replace the old nofib and extend it
04:36:41 <beelsebob> earthy: read Olaf's paper, he has convincing evidence that speed problems in Haskell are usually because people are doing things too strictly
04:36:45 <beelsebob> not too lazily
04:36:45 <apfelmus> earthy: for linear search, it certainly pays off to sort the probabilities in decreasing order
04:36:46 <BCoppens> boegel: nice idea, but I'm not advanced enough in haskell to do that sort of thing =)
04:37:07 <apfelmus> beelsebob: pointer to the paper?
04:37:13 * beelsebob goes hunting
04:37:18 <JohnMeacham> my current regression/benchmark driver is here, the actual tests are cherry picked from nofib and the shootout sort of randomly http://repetae.net/repos/jhc/regress/regress.prl
04:37:36 <earthy> beelsebob: oh, true enough, but the strictness here neither hurts nor helps
04:37:40 <earthy> or so it seems
04:37:44 <earthy> which is weirding me out
04:37:46 <beelsebob> apfelmus: arse, not on his webpage yet, I'll poke you in a bit when he does
04:38:00 <apfelmus> ok, thank you
04:38:15 <beelsebob> earthy: in which case I'd suggest unstricting it to make other algorithms faster, and to make the code clearer
04:38:23 <JohnMeacham> probably beacuse the optimizer is realizing they are strict anyway. compile with -fext-core to see what it is doing.
04:38:35 <ndm> boegel: that suits me perfectly, nofib 2.0 is exactly the right name
04:38:58 <earthy> the thing is that the tree formulation is *slower* than the linear search
04:39:00 <earthy> and I don't get it.
04:39:23 <earthy> and significantly slower at that
04:39:43 <beelsebob> more memory being thrown about?
04:39:45 <earthy> look at http://hpaste.org/120#0 for the lazy tree code
04:39:52 <boegel> ndm: ok, cool, thanks for your suggestions :-) I posted stuff on HaskellCafe/GH-users too to get more respons
04:39:53 <earthy> beelsebob: why would there be?
04:40:01 <michaelw> beelsebob: Blaumeise
04:40:09 <boegel> BCoppens: neither am I, but you help maintain the thingie ;-)
04:40:10 <JohnMeacham> how many times does it search? you have to search at least n / log n  times before building a tree is worth it, and even then the constant factor is quite large.
04:40:11 <beelsebob> earthy: because you're actually having to allocate it to build the tree
04:40:26 <boegel> beelsebob: can you give an url to that paper?
04:40:29 <apfelmus> earthy: btw i guess that the benchmark guys will disqualify the tree solution. most of the other languages use linear search
04:40:40 <BCoppens> boegel: =)
04:40:42 <earthy> the C version uses the tree solution. :)
04:40:44 <beelsebob> boegel: not yet -- as I said to apfelmus he appears not to have it online yet
04:40:53 <earthy> well, binary search in an array, but still
04:41:03 <beelsebob> boegel: it should be available when it's decided what gets into IFL last year
04:41:23 <apfelmus> erathy: why don't they get disqualified?
04:41:37 <earthy> johnmeacham: the tree sizes are 4 and 15, respectively
04:41:45 <bakert> I have a record type with four numeric fields.  I'd like to be able to add them together.  What's the right way to do that?
04:42:20 <bakert> r { 1, 2, 3, 4} + r {5, 6, 7, 8} = r { 6, 8, 10, 12} -- that kind of thing
04:42:24 <boegel> beelsebob: ok, I think that paper should be mentioned on the nofib 2.0 page too
04:42:26 <earthy> the binary search tree formulation fixes the amount of comparisons
04:42:54 <bakert> ?src (+)
04:42:55 <lambdabot> Source not found. My pet ferret can type better than you!
04:43:05 <earthy> apparently, on average, this fixed amount of comparisons is *larger* than when doing linear search in such a short list.
04:43:14 <beelsebob> boegel: sure, the paper is mostly not about that -- that's only the introductory material, it's mostly about a tool that can be used to test when you could make something less strict
04:43:22 * boegel poofs off
04:43:36 <apfelmus> earthy: it doesn't look like the binary tree gets build according to probabilities. look, with a chance of 27%, the linear search in iub stops immediately.
04:43:59 <AStorm> bakert, just derive Integral on it... but that might be hard :P
04:44:00 <earthy> hm. point.
04:44:04 <apfelmus> earthy: you'd need a huffman tree
04:44:25 <earthy> let's see if the C version gets any faster using linear search. :P
04:44:27 <bakert> AStorm, does that imply a whole bunch of other operations?  Perhaps I just need to write a function that does the addition.
04:45:13 <AStorm> Yes, that would be the simplest :P
04:45:25 <AStorm> ?type (+)
04:45:26 <lambdabot> forall a. (Num a) => a -> a -> a
04:45:58 <AStorm> So "just" Num.
04:47:25 <bakert> Thanks AStorm.  I think that's probably overkill so I'll create a function.  These things are not really Nums.
04:47:57 <apfelmus> earthy: also, i think that vanilla Strings are faster on output than ByteStrings
04:48:18 <apfelmus> because you can fuse writeFile with the String generation code
04:48:38 <apfelmus> but i don't know how exactly ByteStrings do this
04:50:44 <apfelmus> i also got the impression that unfold is not a good producer for fusion
04:51:33 <apfelmus> :t GHC.Exts.build
04:51:34 <lambdabot> forall a. (forall b. (a -> b -> b) -> b -> b) -> [a]
04:52:06 <apfelmus> earthy: ^^ this should enable fusion for building the sequence
04:53:17 * CloudiDust is wondering how to parse chars which may be escaped ones, using parsec.
04:53:26 <apfelmus> but most likely, the 'split' function prevents fusion
04:53:35 * earthy nods
04:53:53 <earthy> and there's no real way around it unless you carry around the current charcount
04:54:53 <apfelmus> the problem is to fuse [[a]] and ghc's rules don't handle this and are inadequate for that
04:55:37 <apfelmus> if you are really desperate, you can try to find the equivalent System F type for [[a]] and base fusion on that.
04:55:50 <apfelmus> i mean to hand code the fusion
04:56:27 * earthy nods
04:56:27 <apfelmus> @systemF [[a]]
04:56:28 <lambdabot> Unknown command, try @list
04:56:48 <earthy> in essence splicing in the current charcount and generating an extra \n every 60 chars
04:57:36 <apfelmus> @tell dons i'd like to have a lambdabot plugin that shows the SystemF equivalent of a type, i.e. that takes a type and prints the type of it's fold function
04:57:37 <lambdabot> Consider it noted.
04:58:18 <apfelmus> earthy: yes. but there might be a way to keep the current syntax by switching to a different list type
04:58:22 <earthy> okay
04:58:29 <apfelmus> in essence, that's what fusion does
04:58:38 <earthy> *ha*
04:58:49 <apfelmus> instead of working with List a = [a], you work with List a = forall b. (a -> b -> b) -> b -> b
04:58:49 <earthy> the C code gets (very slightly) faster by going to linear search
04:59:44 <apfelmus> earthy: i suspected so. the point is that big probabilities in the front will terminate the linear search very quickly
05:00:26 <apfelmus> a minor tweak is to (sort (`on` sub) iub) in the code.
05:00:49 <apfelmus> don't write down sort, just reorder the list elements so that the benchmark committee doesn't notice
05:01:45 <apfelmus> i.e. homosapiens = [ ('a', 0.3 ...), ('t', 0.30...), ('c', 0.197..), ('g', 0.197)]
05:03:21 <apfelmus> > let average xs = sum $ zipWith (*) [1..] xs in average [0.3,0.3,0.197,0.197]
05:03:22 <lambdabot>  2.279
05:03:30 <apfelmus> @let average xs = sum $ zipWith (*) [1..] xs
05:03:31 <lambdabot> Defined.
05:03:43 <int-e> earthy: I found that the speed is almost the same with lists as with the tree, is that right?
05:03:43 <apfelmus> > average [0.3,0.197,0.197,0.3]
05:03:45 <lambdabot>  2.485
05:03:59 <earthy> int-e: almost
05:04:05 <earthy> a very slight difference
05:04:39 <int-e> > let avg = liftM2 (/) sum (fromIntegral . length) in avg [0.3,0.197,0.197,0.3]
05:04:41 <lambdabot>  0.2485
05:05:28 <int-e> earthy: ok. My strict tree is slightly faster than your Data.Tree code but still slower than using the list directly.
05:05:58 <earthy> ookay, I'm still having trouble understanding the performance thing.
05:06:22 <apfelmus> :t liftM2 (/) sum
05:06:24 <lambdabot> forall a. (Fractional a) => ([a] -> a) -> [a] -> a
05:06:41 <apfelmus> :t liftM2
05:06:43 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:07:48 <apfelmus> int-e: i don't mean the mean :) i mean the average number of steps in the linear search
05:07:50 <hpaste>  int-e annotated "tree for choosing base slows code down" with "(fasta) using custom tree, balanced by frequency" at http://hpaste.org/120#1
05:08:08 <int-e> apfelmus: ah
05:09:09 <apfelmus> > liftM2 (/) average (average . sort) [0.3,0.197,0.197,0.3]
05:09:10 <lambdabot>  0.9234485321441843
05:09:17 <int-e> oh, is there a library function for  elemIndex (minimum dsts) dsts  ?
05:09:30 <apfelmus> > 1 - liftM2 (/) average (average . sort) [0.3,0.197,0.197,0.3]
05:09:31 <lambdabot>  7.655146785581568e-2
05:09:51 <apfelmus> sorting in linear search means a speedup of 7%
05:10:06 <int-e> apfelmus: but it's not allowed to do that
05:10:44 <apfelmus> ok. but then it's futile to bother with the tree anyway
05:10:54 <earthy> *WTF*?!
05:11:12 <apfelmus> because the tree solution does even more "sorting" than simple sorting
05:11:16 <int-e> apfelmus: it would be a big win if the lists weren't almost sorted :)
05:11:26 <int-e> apfelmus: but it does that only once
05:11:27 <earthy> explicit type annotations have large impact on performance?
05:11:46 <int-e> earthy: oh. they could have.
05:11:55 <earthy> they do!
05:12:06 <apfelmus> earthy: yes, reducing polymorphism helps
05:12:09 <earthy> I was experimenting with making the probabilitylists cumulative
05:12:16 <int-e> earthy: if the function is too large to be inlined.
05:12:33 <earthy> thereby shaving a subtraction from the chooseBase iteration
05:12:37 <apfelmus> int-e: what is done only once?
05:12:59 <earthy> this just bought me a 15% speedup
05:13:39 <earthy> however, the speedup turns into a 50% slowdown by merely removing a type annatotion...
05:13:42 <augustss> earthy: type annotations can help performance, but mostly when you don't have optimization on
05:13:50 <earthy> err. 25% slowdown
05:13:55 <earthy> yeah, but this is with -O3
05:14:06 <int-e> earthy: oooh. the random numebr generator works with Integer otherwise, I suppose.
05:14:17 <huschi> is there any function that separates an absolut path to a file into the path and the filename?
05:14:20 <int-e> earthy: in fact just adding  im :: Int  is enough to get that speedup
05:14:22 * SamB thinks augustss overestimates GHC
05:14:31 * earthy nods
05:14:37 <SamB> GHC isn't very good with overloading
05:15:01 <augustss> SamB: well, I have no idea when this particular type annotation did
05:15:12 <apfelmus> earthy: the - speedup is fine. but you don't need cumulative stuff if you use
05:15:13 <apfelmus> chooseBase = let x = p - f in if x < 0 then ... else ...
05:15:13 <earthy> int-e: you're right.
05:15:37 <SamB> oh, is it Int/Integer here?
05:15:45 <apfelmus> because x < y reduces to (x -y) < 0 in machine code
05:16:13 <augustss> Oh, well Int vs. Integer can change semantics, of course ghc woth do that on its own
05:16:14 <SamB> apfelmus: eh. depends on the machine
05:16:33 <earthy> ofcourse not, but it doesn't seem to be the whole story
05:16:34 <SamB> augustss: yeah ;-)
05:16:53 <earthy> or maybe it is
05:16:56 <SamB> so what happens when you do :: Integer?
05:17:09 <apfelmus> SamB: maybe. but i think on ppc and x86 you can only <0.
05:17:22 <augustss> x<y doesn't turn into (x-y)<0 on any popular machines anymore
05:17:44 <earthy> yup, the Int/Integer thing fucked me up
05:17:46 <SamB> actually, even here on x86, there is a "cmp" opcode that does the subtraction without storing the result
05:17:56 <augustss> ppc and x86 both have compare instructions and condition code
05:18:31 <SamB> (it sets the same flags though)
05:18:31 <fasta> What's a good name for removing a node and all the edges around it from a graph? Disconnect?
05:18:56 <earthy> right. so. that was *very* enlightening. *and* I managed to shave a few cycles off
05:18:58 <SamB> tearOut
05:19:22 <fasta> I know there's an established name for it, I am just not completely sure whether it's disconnect.
05:19:27 <apfelmus> so i am mistaken? ah, you mean there is a comparison that performs subtraction but does not export the result.
05:19:29 * SamB is just making things up
05:19:31 <earthy> performance in Haskell is quite non-compositional.
05:19:32 <bakert> fasta, elide???
05:19:44 <SamB> hmm. elide sounds cool...
05:19:50 <int-e> fasta: I'd say 'delete'.
05:19:57 <astrolabe> > let readIntFromPair str = int where (int,a) = read str in readIntFromPair "(5,'a')"
05:19:58 <lambdabot>  Add a type signature
05:20:02 <bakert> delete is better.
05:20:04 <bakert> than elide.
05:20:08 <bakert> but elide is a good word.
05:20:10 <SamB> earthy: well... why do you think it is that they say "functional programmers know the value of everything but the cost of nothing"?
05:20:13 <astrolabe> How do I make this function polymorphic on a?
05:20:19 <apfelmus> augustss: by the way, in Sytem.Random, the random :: .. (Int,..) and next :: ... (Int ...) have very different performance
05:20:36 <apfelmus> random is some ten times slower
05:20:40 <earthy> samb: yup. :)
05:20:51 <SamB> astrolabe: isn't it already?
05:20:56 * earthy has a new and deepened understanding of that now
05:21:04 <astrolabe> SamB: It won't compile
05:21:18 <SamB> @type let readIntFromPair str = int where (int,a) = read str in readIntFromPair
05:21:20 <lambdabot> forall a b. (Read (a, b)) => String -> a
05:21:22 <augustss> I think System.Random is a bad interface anyway.  But I don't have a better proposal
05:21:25 <astrolabe> SamB: or if it does, I have picked a bad example :)
05:21:45 <SamB> astrolabe: it sure seems to compile
05:22:05 <astrolabe> hmmm
05:22:06 <apfelmus> augustss: it's not that bad. the problem is that heavily splitting the generator is not a good idea.
05:22:06 <SamB> but the way you tried to run it didn't work, because the overloading couldn't be resolved
05:22:33 <astrolabe> SamB: thanks, I'll have to mull.
05:22:37 <augustss> apfelmus: the split operation is impossible to implement well for many generators
05:22:51 <SamB> augustss: what is "well"?
05:23:22 <apfelmus> yes, unfortunately. are there any generators that support it at all?
05:23:32 <augustss> SamB: you want the two generators from split to be as independent as possible
05:23:40 <SamB> the requirements to date on the "split" operation are not very much right now...
05:24:25 <int-e> earthy: -funbox-strict-fields helps.
05:24:44 <augustss> apfelmus: There is a good generator that I have meant to implement that I think could do an OK split.  It's a modern version of the L'Ecuyer's generator (like the one we use now, i.e., the one I write 20 years ago).
05:25:27 <apfelmus> interesting. i guess the haddock contains further pointers?
05:25:28 <int-e> earthy: (helps my code that is) but it's still slower than the plain list.
05:25:28 <augustss> SamB: If there are no requirements on split, it's easy to implement. :)
05:25:31 <earthy> int-e: not if you're stuck with Integer :)
05:25:37 <SamB> augustss: there are some
05:25:55 <int-e> earthy: I'm not ;)
05:26:13 <SamB> @doc System.Random
05:26:14 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
05:26:48 <augustss> SamB: I know.  The generators are supposed to be disinct.  Which is an incredibly weak thing.
05:27:42 <beelsebob> http://pozorvlak.livejournal.com/43810.html <-- anyone fancy contributing
05:27:44 <lambdabot> Title: pozorvlak: Haskell, guarantees and pusillanimity
05:28:03 <augustss> So split could deliver two generators the will generate the same stream, but offset by one.  which is just sucky
05:28:07 <apfelmus> augustss: concerning the interface, one could split the next operation into
05:28:07 <apfelmus> evolve :: RandomGen g => g -> g  and fetch :: (Random a, RandomGen g) => g -> a
05:28:08 <astrolabe> Does randomR really return a sample from a uniformish distribution?
05:28:34 <SamB> augustss: yes
05:28:40 <augustss> astrolabe: well, it depends on the generator
05:28:52 <SamB> augustss: but for the purposes we usually use it for, is that a problem?
05:29:01 <apfelmus> augustss: but the problem is that the size of a determines you much you need to evolve. Perhaps it is best to make the generator a comonad?
05:29:38 <astrolabe> augustss: I heard someone say it just uses 'mod' on the full range random no.
05:29:41 <SamB> augustss: in what way?
05:30:15 <astrolabe> @src randomR
05:30:16 <lambdabot> Source not found. Wrong!  You cheating scum!
05:30:21 <augustss> SamB: I don't know how split is usually used, so I can't tell
05:30:29 <astrolabe> where is the source for random?
05:30:51 <SamB> astrolabe: you could go to the haddock and follow that link
05:30:56 <MarcWebe1> Does jhc have its own packaging tool such like ghc-pkg ?
05:31:05 <astrolabe> SamB Thanks again
05:31:08 <SamB> MarcWebe1: tool?
05:31:18 <SamB> it lets you build things based on cabal files...
05:31:41 <brainly-green> wow, publib.boulder.ibm.com is slow
05:31:53 <augustss> astrolabe: the standard generator most (all?) Haskell systems provide is OK for non-serious use.  You get a uniformish distribution.
05:31:56 <MarcWebe1> SamB: I'm more interested in how to register install packages for jhc ..
05:32:13 <astrolabe> augustss: thanks.
05:32:15 <apfelmus> augustss: contrived. we'd have to make an associated data type instance of a class comonad
05:32:26 <SamB> @where jhc
05:32:27 <lambdabot> http://repetae.net/john/computer/jhc/
05:32:47 <MarcWebe1> SamB: You'r right. I should start reading docs
05:33:01 <augustss> apfelmus: lol, and I want is random numbers :)
05:33:16 <SamB> http://repetae.net/john/computer/jhc/using.html
05:33:18 <lambdabot> Title: Using jhc
05:33:21 <SamB> that is the documentation
05:33:40 <SamB> actually, it comes with JHC too
05:33:58 <SamB> and much of it is the usage output from jhc itself
05:33:59 <edwinb> beelsebob: you made a sensible comment! Is that allowed on livejournal?
05:34:14 <beelsebob> edwinb: hehe, what, no flame?
05:34:26 <apfelmus> augustss: :) nobody wants to buy comonads, i'm near to shut down my business
05:34:53 <SamB> notice how those gray boxes at the bottom all start by mentioning an unrecognized flag or option?
05:35:18 <augustss> apfelmus: You need to slip them into the next ghc dist.  get people hooked
05:35:18 <astrolabe> SamB: I tried the haddock website, but I can't see anything relevent.  Could you give me another clue please :)
05:35:50 <SamB> astrolabe: upper-right corner?
05:36:16 <SamB> next to "Contents" and "Index"
05:37:03 <SamB> @doc System.Random
05:37:04 <astrolabe> SamB: on this page? http://cvs.haskell.org/Hugs/pages/libraries/base/System-Random.html#v%3ArandomR
05:37:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
05:37:08 <lambdabot> http://tinyurl.com/yu3z9j
05:37:09 <SamB> yeah, that page
05:37:11 <apfelmus> augustss: yes, good idea. i'll wrap them into a bundle with random numbers. so you get the comonads for "free", mhehe
05:37:25 <SamB> no, wait...
05:37:27 <SamB> sorry.
05:37:32 <astrolabe> SamB: That's weird
05:37:41 <SamB> I wasn't looking at the start of the URL ;-)
05:37:44 <astrolabe> I got a special version without source code :)
05:38:06 <SamB> those ones might be made with an older version of haddock or something
05:38:17 <SamB> (or without the special flag, I guess)
05:38:20 <astrolabe> ah
05:39:01 <apfelmus> i have to go. bbl!
05:39:16 <SamB> anyway, when you want haddocks for stdlib, @doc is the way to go ;-)
05:39:25 <SamB> though maybe it is actually spelled @docs
05:40:41 <astrolabe> @karma+ SamB
05:40:42 <lambdabot> SamB's karma raised to 23.
05:40:46 <SamB> hmm, why don't they specify StdGen more?
05:41:05 <astrolabe> This is odd
05:41:13 <astrolabe> randomR :: RandomGen g => (a,a) -> g -> (a,g)
05:41:13 <astrolabe>   -- | The same as 'randomR', but using a default range determined by the type:
05:41:13 <SamB> what is?
05:41:21 <SamB> oh
05:41:37 <SamB> that is talking about random
05:41:53 <astrolabe> Yeah, so is it in the wrong place?
05:42:05 <earthy> hm. generating the strings per 60 chars is slower.
05:42:10 <SamB> no...
05:42:13 <SamB> it is before random
05:42:15 <astrolabe> Ah I see
05:42:38 <SamB> I have to go now
05:42:56 <astrolabe> I don't blame you.  Bye
05:44:12 <brainly-green> grr I have narrowed it down to 5 professors that I can email to ask about an independent study, based on their research interests
05:44:17 <brainly-green> how do I select which one to email
05:44:29 <ndm> brainly-green: the one with the funniest name
05:44:46 <brainly-green> I guess that would be "Osterweil"
05:45:33 <brainly-green> no I need a better criterion than that, but it would be impolite to email more than 1 of them, wouldn't it
05:46:05 <ndm> brainly-green: pick the one that seems the nicest person
05:46:14 <brainly-green> I haven't had a class with _any_ of them
05:46:23 <brainly-green> never talked to em
05:46:28 <Botje> pick the one with the fluffiest chair.
05:46:30 <ndm> do you know anyone who has
05:46:40 <ndm> Botje: bad plan, that means they sleep through your meetings
05:46:44 <brainly-green> probably I do
05:46:59 <brainly-green> well I'm not looking for meetings so much as just someone to make it official
05:47:12 <astrolabe> augustss: ping
05:47:14 <brainly-green> I have an idea and I'm not sure that I'd want much in the way of supervision, and I'm an undergrad
05:47:30 <brainly-green> should I go with the one who looks the most distinguished?
05:47:51 <brainly-green> might look good on a resume if I have no other criteria
05:48:05 <astrolabe> Go for the biggest beard
05:48:34 <ndm> brainly-green: generally thats not a great idea, the most distinguished usually have less time, less desire to do supervision - and a good supervisor is always handy to have
05:49:05 <astrolabe> ndm: On the hand, 'if you want something done, ask a busy person'.
05:49:35 <ndm> astrolabe: busy /= distinguished
05:49:37 <bakert> walk past their office and try and sneak a fleeting glimpse.  could at least eliminate some.
05:49:38 <psnl> beard size is good
05:49:38 <astrolabe> Because busy people are the ones who actually do stuff
05:49:46 <astrolabe> nem: true
05:49:47 <brainly-green> however I do have one additional factor
05:49:53 <psnl> extra points if its white
05:49:53 <astrolabe> er ndm
05:49:59 <brainly-green> namely, today is Friday, the semester starts on Monday, and course registration ends a week after that
05:50:10 <psnl> brainly-green: flip a coin
05:50:11 <brainly-green> so it would be optimal not to spend a lot of time walking around offices
05:50:27 <brainly-green> oh and I'm 100 miles away from all those offices until Monday
05:50:27 <astrolabe> brainly-green: google them, and see who appeals
05:50:41 <bakert> brainly-green, surely whoever you email is only going to arrange a meeting anyway?
05:50:43 <brainly-green> yeah I checked up on their research, narrowed it down
05:50:45 <yaarg> i'd meet them in person tbh
05:50:53 <earthy> okay, enough on the fasta
05:50:58 <yaarg> (if possible of course)
05:51:23 <bakert> does your university have a "rate-your-lecturer" scheme?
05:51:40 <brainly-green> there's always ratemyprofessor.com
05:51:42 <brainly-green> I could try that
05:51:45 <bakert> imperial college's are usually borne out by them in person.
05:51:56 <bakert> (their own one i mean, i don't know ratemyprofessor)
05:52:04 <astrolabe> Where should I raise it if the implementation of a standard library function doesn't do what it should?
05:52:14 <brainly-green> well we rate our professors in course evaluations but students do not have access to that
05:52:20 <yaarg> well i've known professor who were great giving lecturers but not so good one-to-one
05:52:25 <bakert> brainly-green, that's not much use.
05:52:34 <bakert> yaarg, yeah i thought of that but it's still a good indicator
05:52:54 <yaarg> i've never seen a scheme in whcih students can see ratings
05:53:24 <astrolabe> I'm not sure students should give ratings.
05:53:37 <astrolabe> It's ok if they are keen, but ...
05:53:42 <brainly-green> well who else is going to rate their lecturing performance astrolabe
05:54:01 <augustss> astrolabe: pong?
05:54:01 <brainly-green> otherwise there wouldn't be much incentive for them to lecture well
05:54:11 <astrolabe> brainly-green: No idea, but that doesn't refute my point
05:54:26 <brainly-green> except altruism
05:54:27 <yaarg> well in decent universities most are keen..
05:54:42 <ndm> astrolabe: fix it, which one?
05:54:43 <chessguy> 'morning, haskellers
05:54:48 <therp> http://www.ratemyprofessor.com/Funniest.jsp :)
05:54:50 <lambdabot> Title: RateMyProfessors.com - Funniest Ratings
05:54:51 <astrolabe> brainly-green: I believe most people try to do their job well, but that if you try to measure that, you degrade their performance.
05:54:59 * mux wonders if he should buy "basic category theory for computer scientists" or "types and programming languages" by benjamin c. pierce, or both
05:55:09 <astrolabe> ndm: randomR
05:55:14 <earthy> go for tapl first. :)
05:55:23 <yaarg> lol @ funniest ratings
05:55:42 <astrolabe> ndm: it uses this:
05:55:55 <mux> earthy: easier to start with?
05:55:58 <ndm> mux: have you read category theory for Haskellers?
05:56:01 <astrolabe> randomIvalInteger (l,h) rng
05:56:01 <astrolabe>  | l > h     = randomIvalInteger (h,l) rng
05:56:01 <astrolabe>  | otherwise = case (f n 1 rng) of (v, rng') -> (fromInteger (l + v `mod` k), rng')
05:56:01 <mux> yep
05:56:09 <mux> ndm: I even successfully did the exercises
05:56:15 <ndm> mux: neat :)
05:56:21 <mux> not that it's such an achievement
05:56:24 <mux> but it filled me with pride :-P
05:56:59 <mux> so you guys would recommend me to go with TAPL first?
05:57:05 <mux> it's a bit expensive
05:57:17 <ndm> mux: i have heard very good things about TAPL
05:57:40 <ndm> mux: but remember there are libraries, the cheap way of getting books
05:57:51 <huschi> i've got a list of strings. i want to sort it end remove the duplicates.
05:57:57 <mux> yeah, but since I can afford it these days, I'll grab a copy
05:57:59 <huschi> what's the best way to do this?
05:58:03 <ndm> huschi: nub . sort
05:58:05 <huschi> using sort and nub.
05:58:09 <mux> but it's still annoying to buy a book more than $50 =)
05:58:10 <astrolabe> I think TAPL is ok (from the first ~10 chapters) somethings are left a bit vague to me, but I'm a mathmo.
05:58:10 <therp> mux: I got TAPL from my university library.
05:58:21 <ndm> huschi: you can get better performance with: map head . group . sort
05:58:33 <huschi> ndm: that seems good.
05:58:34 <mux> I've heard good things about "basic category theory..." in LtU
05:58:34 <huschi> thx.
05:58:39 <ndm> huschi: but in general its too much effort, but is O(n log n) vs O(n^2)
05:58:57 <therp> mux: er, I meant that as a recommendation :) TAPL is expensive and you better have a look at it, because imho it is a specialized book and not everyone will need it.
05:58:59 <ndm> huschi: i have that defined as snub in a module I use in all my projects
05:59:31 <huschi> ndm: have you defined more effective code there?
05:59:35 <mux> therp: sounds like a good idea to check first indeed, thank you
05:59:37 <pejo> mux, tapl should be readable to most people without a math degree, if they want to learn. People have expressed that category theory is somewhat less applicable short term. :-)
05:59:46 <huschi> ndm: and what about using Data.Set?
06:00:08 <therp> mux: the thing is different for SICP.. everyone benefits from reading SICP:)
06:00:15 <mux> SICP?
06:00:18 <huschi> ndm: setToList . mkSet i mean.
06:00:19 <therp> @google SICP
06:00:22 <lambdabot> http://mitpress.mit.edu/sicp/
06:00:22 <lambdabot> Title: Welcome to the SICP Web Site
06:00:22 <chessguy> ?where SICP
06:00:23 <lambdabot> http://mitpress.mit.edu/sicp/
06:00:31 <earthy> dons awake yet?
06:00:31 <psnl> TAPL is a easyish read, BCT is insanely tough going
06:00:40 <chessguy> ?localtime dons
06:00:41 <lambdabot> Local time for dons is Sat Jan 27 00:56:54 2007
06:00:53 <earthy> ah, on a friday night. I guess not. ;)
06:00:55 <ndm> huschi: almost definately slower, but feel free to try it
06:00:59 <chessguy> no fair, it's already the weekend there
06:01:08 <earthy> that is, probably out drinking somewhere. ;)
06:01:19 <mux> psnl: insanely tough, even for someone who tends to deal with maths ok?
06:01:48 <chessguy> err, i forget, what does TAPL stand for?
06:02:00 <pejo> mux, there's an online version of SICP avail iirc. There has been discussions whether it is the right way to introduce people to the subject though.
06:02:00 <mux> types and programming languages
06:02:05 <psnl> mux: I'm not a maths guy myself, but I do a very theory based CS course
06:02:12 <chessguy> is it haskell-based?
06:02:15 <mux> pejo: ok
06:02:24 <therp> chessguy: types and programming languages
06:02:30 <psnl> mux: I think that if you are a mathamatitan its easier
06:02:33 <earthy> ah, the sources gave me the answer I wanted.
06:02:33 <pejo> mux, but you're not exactly a beginner when it comes to programming, and you know Haskell already.
06:02:39 <mux> psnl: ok so you probably can handle those things better than I, so I'll probably have a *hard* time with BCT
06:02:56 <mux> I'll start with TAPL
06:03:03 <psnl> yeah
06:03:04 <astrolabe> TAPL is based on ML iirc, SICP is scheme
06:03:11 <mux> pejo: yeah I'm programming since quite a long time, but I'm very weak when it comes to theory
06:03:33 <chessguy> hmm, that might not be bad, i could rewrite his ML examples in haskell
06:03:34 <mux> thanks a bunch for all the advices, guys
06:03:42 <pejo> astrolabe, worse, O'caml!
06:03:50 <mux> this channel really is the king of the IRC channels.
06:03:52 <astrolabe> chessguy: yes you could
06:04:17 <astrolabe> It is a very nice channel.
06:04:40 <chessguy> #haskell is one of the very best things about haskell
06:04:43 <mux> @karma+ #haskell
06:04:44 <lambdabot> #haskell's karma raised to 5.
06:08:03 <brainly-green> awright I think I know who I'd like to email--only problem is the guy may have way too much credentials to take on an undergrad independent study
06:08:21 <Adamant> ok, kinds are kind of types of types. would allowing kind manipulation give Haskell any more useful power?
06:08:22 <brainly-green> he's a senior "golden core" member of IEEE, I don't know if I have a chance
06:08:27 <therp> yes, #haskell is nice. I wonder why nobody has yet told lambdabot to evaluate a very cryptic @pl expression that will result in "#haskell rules"
06:08:52 <astrolabe> brainly-green: you don't if you don't ask him
06:08:57 <brainly-green> oh, another criterion I forgot
06:09:09 <brainly-green> are they even present, or are they travelling
06:09:37 <pejo> Adamant, Sheard has something written about extensible kinds. http://web.cecs.pdx.edu/~sheard/papers/GADT+ExtKinds.ps
06:09:48 <brainly-green> wouldn't want a prof who'll be gone for a few months
06:10:05 <paolino> is it still usable the edison library ? it  looks a bit dated ?
06:11:25 <int-e> map chr $ scanl1 (+) [35,69,-7,18,-8,-6,7,0,-76,82,3,-9,-7,14] -- for therp
06:11:27 <int-e> > map chr $ scanl1 (+) [35,69,-7,18,-8,-6,7,0,-76,82,3,-9,-7,14] -- for therp
06:11:29 <lambdabot>  "#haskell rules"
06:11:32 <paolino> docs are made on 4.0 and there is no cabal interface
06:13:05 <therp> int-e: I was starting to wonder why nobody was up for that challange :). that's pretty cryptic, thank you :)
06:13:20 <matthew_-> Adamant: yes, you're moving into the realm of dependent types, though Sheard's work on Omega is Index types which is nearly as powerful but has a simpler compilation step
06:13:44 <matthew_-> Adamant: there are many many very useful properties that it allows to to model in the type system which you currently can't
06:17:02 <earthy> now *that's* interesting
06:17:37 <earthy> if I make the 'fastest' GHC version conform to the 'rule' that you aren't allowed to pre-convert to int ranges
06:18:02 <earthy> then it suddenly is only 10 or so percent faster than the Data.ByteString version
06:20:28 <int-e> earthy: yes, it's strange.
06:24:33 <ndm> earthy: what are you refering to?
06:25:40 <int-e> ndm: http://www.haskell.org/haskellwiki/Shootout/Fasta#Current_best_entry_.28Haskell_GHC_.233.29 I think.
06:25:42 <lambdabot> Title: Shootout/Fasta - HaskellWiki, http://tinyurl.com/vznau
06:31:14 <tomh-> hello
06:31:29 <tomh-> anyone can explain me how to have a method return 2 results?
06:31:54 <int-e> tomh-: return a pair
06:31:54 <xic> twice x = (x, x)
06:32:00 <tomh-> ah just a tuple
06:32:01 <tomh-> ok
06:32:09 <chessguy> tomh-, you could do it in a list, or a tuple, or some other combination data structure
06:32:19 <tomh-> i think a tuple is the one i need
06:32:21 <chessguy> s/combination/composed/ i guess
06:32:52 <tomh-> and in the type definition i also just do a (a,b) as last one?
06:33:30 <sjanssen> tomh-: yeah
06:33:34 <tomh-> kk
06:33:49 <fasta> How do I build the profiling libraries for a library?
06:33:54 <chessguy> well, it could be (a,a)
06:33:59 <chessguy> depends what you're returning
06:34:15 <sjanssen> fasta: runghc Setup.hs configure --enable-library-profiling
06:34:15 <fasta> runhaskell Setup.hs --help doesn't give an option to do so.
06:34:32 <fasta> sjanssen: thanks
06:36:48 <tomh-> damn this assignment is real hard :/
06:37:07 <int-e> fasta: try runhaskell Setup.hs configure --help  to get a list of options for configure
06:37:11 <mux> fasta: I think -p works
06:37:15 <chessguy> tomh-, whatcha got?
06:37:21 <mux> at least this is what I use for FreeBSD's hs-fps port
06:37:32 <tomh-> have to build a compiler
06:37:36 <tomh-> in haskell
06:37:44 <chessguy> i'm bored with this stupid javascript problem anyway
06:37:49 <chessguy> to compile what?
06:37:52 <tomh-> java
06:37:56 <allbery_b> ewww
06:37:59 <chessguy> ewww
06:38:03 <tomh-> i rather do JS than haskell :P
06:38:11 <chessguy> @karma- java
06:38:12 <lambdabot> java's karma lowered to -17.
06:38:17 <tomh-> heh thats what our teacher came up with :P
06:38:23 <chessguy> i hope it's at least a subset of java
06:38:26 <tomh-> ye
06:38:27 <chessguy> not like the entire language
06:38:28 <tomh-> not all
06:38:29 <ndm> tomh-: Haskell can be compiled to JS
06:38:40 <tomh-> ofcourse it can
06:38:49 <tomh-> but i rather write JS :P
06:38:51 <chessguy> do you have an actual specification of the problem somewhere?
06:38:54 <fasta> tomh-: he means that it works _today_.
06:39:02 <tomh-> chessguy: sure but its dutch
06:39:05 <mux> @karma C
06:39:06 <lambdabot> C has a karma of 2
06:39:12 <chessguy> that won't help much
06:39:20 <astrolabe> @karma C++
06:39:21 <vegai> @karma Cpp
06:39:21 <lambdabot> C++ has a karma of -2
06:39:22 <lambdabot> Cpp has a karma of 0
06:39:23 <ndm> @karma+ C -- because of -fvia-C
06:39:25 <lambdabot> C's karma raised to 3.
06:39:26 <astrolabe> heh
06:39:32 <vegai> @karma- C++ -- because.
06:39:33 <lambdabot> C++'s karma lowered to -3.
06:39:36 <tomh-> its very specific theory
06:39:50 <chessguy> theory?
06:39:52 <vegai> @karma haskell
06:39:54 <lambdabot> haskell has a karma of 20
06:39:54 <tomh-> you can download the entire book of our course if you are interested
06:40:03 <ndm> @karma Haskell
06:40:04 <lambdabot> Haskell has a karma of 9
06:40:06 <chessguy> tomh-, in english or dutch?
06:40:10 <tomh-> english
06:40:12 <sieni> @karma haskell
06:40:12 <lambdabot> haskell has a karma of 20
06:40:19 <chessguy> link?
06:40:23 <sieni> very nice that karma is case sensitive
06:40:34 <tomh-> http://www.cs.uu.nl/docs/vakken/gont/diktaat.pdf
06:40:35 <chessguy> @karma Chessguy
06:40:36 <lambdabot> Chessguy has a karma of 0
06:40:38 <sieni> HasKell++
06:40:40 <chessguy> @karma chessguy
06:40:40 <lambdabot> You have a karma of 3
06:40:42 <tomh-> written by D. swierstra
06:40:47 <sieni> @karma HasKell
06:40:47 <tomh-> he is famous here
06:40:48 <lambdabot> HasKell has a karma of 1
06:40:50 <tomh-> i think
06:40:58 * Eelis wonders what it is with Haskell people and their love for automated channel flooding
06:41:01 <chessguy> tomh-, thanks. so what part of the compiler are you working on now?
06:41:17 <tomh-> doing local variables of a java method
06:41:31 <roconnor> HasKell--
06:41:34 <chessguy> Eelis, don't be such a party-pooper
06:41:37 <roconnor> @karma HasKell
06:41:38 <lambdabot> HasKell has a karma of 0
06:41:42 <roconnor> wow
06:41:46 <roconnor> I didn't know that worked
06:41:53 <roconnor> C++
06:41:56 <roconnor> @karma C
06:41:57 <lambdabot> C has a karma of 3
06:42:00 <roconnor> heh
06:42:01 <chessguy> tomh-, do you have a specific problem?
06:42:01 <Eelis> chessguy: i'm not pooping. i'm merely curious.
06:42:09 <allbery_b> special cased for obvious reasons :)
06:42:15 <tomh-> ye im modifying the data structure of my algebra
06:42:17 <chessguy> Eelis, we like playing with our bot
06:42:21 <tomh-> and it gives me errors :P
06:42:24 <vegai> there are more important things to be annoyed about than channel flooding :)
06:42:26 <tomh-> *** Because        : unification would give infinite type
06:42:33 <chessguy> tomh-, are you using happy?
06:42:38 <tomh-> happy?
06:42:39 <tomh-> no
06:43:16 <chessguy> ?where happy
06:43:16 <lambdabot> http://www.haskell.org/happy/
06:43:34 <chessguy> i don't know if you'd be allowed to do that
06:44:07 <tomh-> no dont think so
06:44:43 <tomh-> luckily i dont have to pass this assignment
06:44:58 <tomh-> i just do it to minimize the impact on my final grade
06:45:30 <paolino> are GADT already working in GHC ?
06:46:27 <allbery_b> you need some -f... option to enable them but yes
06:46:32 <chessguy> tomh-, ok, can you post the cod that's giving you that error?
06:46:34 <chessguy> !paste
06:46:34 <hpaste> Haskell paste bin: http://hpaste.org/
06:46:53 <tomh-> i fixed it already
06:47:01 <tomh-> now i got an error which is much and much worse
06:47:04 <paolino> @docs DADT
06:47:04 <lambdabot> DADT not available
06:47:12 <paolino> @docs GADT
06:47:12 <lambdabot> GADT not available
06:47:23 <paolino> @go GADT
06:47:24 <tomh-> the only way to check whats going on is to make all methods undefined
06:47:25 <lambdabot> http://lambda-the-ultimate.org/node/1132
06:47:26 <lambdabot> Title: GADT&#039;s revisited | Lambda the Ultimate
06:47:27 <tomh-> till it works
06:47:35 <tomh-> or till its broken
06:47:55 <fasta> @karma-- haskelldebugging
06:47:56 <lambdabot> haskelldebugging's karma lowered to -1.
06:48:00 <allbery_b> ghc manual section 7.5
06:48:16 <chessguy> tomh-, here's something else you might try
06:48:18 <chessguy> ?where hat
06:48:18 <lambdabot> http://www.haskell.org/hat/
06:48:44 <allbery_b> http://www.haskell.org/ghc/docs/latest/html/users_guide/gadt.html
06:48:45 <lambdabot> Title: 7.5. Generalised Algebraic Data Types (GADTs)
06:48:53 <tomh-> ah thats nice
06:49:02 <fasta> chessguy: hat is a toy
06:49:08 <tomh-> but i have a 2.15 hour deadline ~
06:49:16 <chessguy> disclaimer: i've not played with hat myself
06:49:17 <tomh-> no time to figure out how to intergrate it
06:49:27 <chessguy> tomh-, then pastebin some of your code
06:50:00 <paolino> thanks allbery_b
06:50:06 <tomh-> ye hold on
06:50:09 <allbery_b> I played with hat.  never actually got it to work; it's missing too many things.
06:50:30 <tomh-> but i doubt you are in the mood to see where it errors :P
06:50:32 <brainly-green> the other thing I haven't mentioned
06:51:03 <brainly-green> is I have over 5 pages of single spaced text that I want to use as a proposal
06:51:08 <chessguy> tomh-, you might be surprised
06:51:11 <brainly-green> so whoever I email, they have to be willing to read through that
06:51:24 <brainly-green> this could be a strike against me
06:51:28 <tomh-> http://hpaste.org/121
06:51:30 <tomh-> thats the type
06:51:34 <tomh-> i have to fix
06:52:23 <chessguy> wha
06:52:26 <chessguy> that's a type?
06:52:28 <tomh-> told you
06:52:29 <tomh-> ye
06:52:37 <chessguy> of what?
06:52:39 <tomh-> the normal type its supposed to be is
06:52:40 <tomh-> *** Does not match : JavaAlgebra (Env -> Code) (Env -> Code) (Env -> Code) (Env -> Bool -> Code)
06:52:50 <tomh-> a algebra function or so
06:53:14 <chessguy> sounds like your code is in desparate need of refactoring
06:53:30 <tomh-> this is how my teacher wants it..
06:54:28 <tomh-> http://hpaste.org/121#1
06:54:34 <tomh-> below is the type its supposed to match
06:59:28 <chessguy> wow, i suspect you're way over my head
07:00:31 <sjanssen> tomh-: oh dear god
07:00:37 <tomh-> i dont understand a shit of this either :P
07:01:27 <tomh-> thats what happened when i tried to have it return 2 results instead of one
07:02:10 <Saizan>  that type is kind of crazy
07:02:15 <chessguy> kind of?
07:02:24 <Saizan> ok, totally :D
07:02:43 <tomh-> ye
07:02:49 <tomh-> and i have to figure out whats wrong
07:02:51 <Saizan> and, those "," are tuples? you can omit the parens?
07:03:06 <tomh-> i dunno
07:03:11 <paolino> needs a monadic rifle
07:03:17 <tomh-> the first type is the one haskell generated
07:03:25 <tomh-> cause it didnt match the 2nd one
07:03:30 <sjanssen> new rule: a type signature should not require matching paren higlighting to understand
07:04:05 <chessguy> lol
07:04:09 <matthew_-> mmm. Fortress got round that by using lots of unicode parens.
07:05:12 <Saizan> ah, right, the parens are there, it's just so long i couldn't parse them :O
07:05:24 <xic> how would i have a State + Reader + IO monad?
07:05:52 <mux> StateT + ReaderT + IO
07:05:59 <mux> if I'm not mistaken
07:06:01 <Saizan> StateT a ReaderT b IO c?
07:06:12 <xic> why not the other way around?
07:06:23 <Saizan> like?
07:06:31 <xic> ReaderT a StateT b IO c?
07:06:39 <mux> it's the same
07:06:39 <paolino> same
07:07:08 <Saizan> mmh it's semantically different, right?
07:07:09 <mux> well except that your lift's will be a bit different when implementing the instances for MonadState, MonadIO etc
07:07:24 <xic> man monads are a bitch :\
07:07:58 <Saizan> have you read sigfpe on monad transformers?
07:08:06 <xic> don't think so
07:08:29 <xic> i'm already using ReaderT a IO b, and it's working ok i think, but now i also need State
07:09:17 <kowey> xic: but that's the nice part; you can upgrade (almost) painlessly
07:09:55 <xic> but won't IO need to be lifted twice?
07:10:07 <Saizan> true
07:10:25 <kowey> well, that's why All About Monads suggest that you write a personal lifter
07:10:48 <xic> what about arrows?
07:10:49 <kowey> so that next time you add more to the stack, you just change that
07:10:56 <mux> yeah, you write an instance of MonadIO for that purpose
07:10:58 <mux> don't you?
07:11:12 <mux> and then you just use liftIO for your monad
07:11:12 <paolino> :t liftIO
07:11:14 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
07:11:25 <kowey> oh! (thanks for teaching me something new)
07:11:41 <mux> same for get/ask/... and MonadState
07:12:19 <paolino> @instances MonadIO
07:12:21 <lambdabot> ContT r m, ErrorT e m, IO, RWST r w s m, ReaderT r m, StateT s m, WriterT w m
07:12:39 <paolino> yep, StateT is there
07:12:51 <mux> oh, so you don't even have to do anything
07:12:54 <mux> neat
07:13:33 <mux> @instances MonadState
07:13:34 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
07:15:08 <Saizan> so i can directly write something like  do { x <- get; y <- ask; print (x,y) } ?
07:15:22 <Saizan> scary.
07:15:37 <mux> I think so
07:15:50 <paolino> liftIO $ print (x,y)
07:16:00 <Saizan> ah, right
07:16:56 <xic> @type do {x <- get; y <- ask; liftIO $ print (x, y) }
07:16:58 <lambdabot> forall s r (m :: * -> *). (MonadReader r m, MonadIO m, Show (s, r), MonadState s m) => m ()
07:17:19 <mux> monads are the best thing since sliced bread
07:17:43 <paolino> and snow
07:17:54 <matthew_-> in fact, class (SlicedBread m, Snow m) => Monad m where ...
07:18:38 <mux> heh
07:19:22 <paolino> @type liftIO $ ask `ap` get
07:19:24 <lambdabot>     No instance for (MonadReader (s -> b) IO)
07:19:24 <lambdabot>       arising from use of `ask' at <interactive>:1:9-11
07:19:28 * allbery_b thought Serena Williams already did that
07:19:48 <allbery_b> (sports joke/pun)
07:20:38 <chessguy> allbery_b, did what?
07:20:41 <paolino> @type liftIO $ ask `ap` get $ "paolino"
07:20:42 <lambdabot> Top level:
07:20:43 <lambdabot>     Couldn't match `[Char]' against `s -> IO a'
07:21:11 <allbery_b> <-- metaperl has quit ("One day I'm going to find that peer and reset her connection")
07:21:12 <paolino> @type liftIO $ ask `ap` get $ print "cucu"
07:21:14 <lambdabot> Top level:
07:21:14 <lambdabot>     Couldn't match `IO ()' against `s -> IO a'
07:21:42 <paolino> @type liftIO $ ask `ap` get $ print
07:21:44 <lambdabot>     No instance for (MonadState s ((->) (s -> IO ())))
07:21:44 <lambdabot>       arising from use of `get' at <interactive>:1:18-20
07:21:48 <paolino> bah
07:22:45 <araujo> morning
07:26:33 <fasta> I think tomh-'s type was generated by a tool.
07:27:42 <chessguy> fasta, what makes you think that?
07:30:03 <sjanssen> fasta: are you calling tomh-'s professor a tool?
07:30:47 <fasta> sjanssen: no, but I don't believe that's the type his professor wants him to use.
07:31:08 <paolino> We are still not in "matrix"
07:31:30 <fasta> chessguy: The algebra approach is taught to undergraduate students in a certain course.
07:34:00 <chessguy> algebra approach?
07:34:50 <fasta> chessguy: Hmm, it appears it's not auto generated.
07:35:17 <fasta> chessguy: only the original type had meaningfull names.
07:37:20 * pjd_ read about codata/corecursion
07:37:25 <pjd_> wow
07:39:14 <pjd_> am i right in guessing that while David Turner's definition of total functional programming segragates them from data/recursion, Haskell (for example) embeds both?
07:39:39 <pjd_> "segregates codata/corecursion/... from data/recursion/...", that is
07:40:57 <pjd_> (does the question make any sense?)
07:41:27 <Pete_I> not to me :/
07:42:41 <pjd_> (the paper i read: http://www.jucs.org/jucs_10_7/total_functional_programming)
07:42:44 <lambdabot> Title: (D. A. Turner) Total Functional Programming
07:43:33 <Botje> +away
07:43:42 <Botje> argh :)
07:47:39 <dylan> does darcs have something like a .. ~/.darcs/pref/boring file?
07:49:25 <pjd_> . o O (is the recursion/corecursion duality related to dynamic programming?)
07:50:46 <trurl_> you can use 'darcs setpref boringfile ...', maybe that helps you
07:51:08 <beschmi> dylan: your ~/.darcs/boring is used instead of the default one when you create/get a new repo
07:54:06 <tomh-> if i have a result with a tuple and i want it to be undefined
07:54:16 <tomh-> do i need to do (undefined,undefined) ?
07:54:41 <dylan> beschmi: thanks
07:54:57 <bakert> If I have "sumT <- sumTransactions account" where sumTransactions :: Account -> IO Either String Double
07:55:11 <bakert> How do I "get at" the Double in sumT
07:55:14 * allbery_b thinks that type needs some parens
07:55:17 <bakert> Which is currently Right 2.66
07:55:30 <bakert> for example
07:55:36 <allbery_b> use Right as a pattern match
07:55:47 <ToRA> (Right val) <- sumTra....
07:55:53 <bakert> If I say "Right sumT <- sumTransactions account"
07:56:17 <bakert> I get an error.  But that's the right approach?  So the error is caused by something else?
07:56:27 <Saizan> you have to use parens
07:56:33 <Saizan> (Right sumT)
07:56:36 <bakert> ah!
07:56:37 <kpreid> er, no.
07:56:52 <Saizan> however if it happens to be a Left something
07:57:04 <Saizan> you have a failed pattern match at runtime
07:57:17 <kpreid> > do (Right x) <- [Right "a"]; return x
07:57:19 <lambdabot>  ["a"]
07:57:22 <kpreid> > do Right x <- [Right "a"]; return x
07:57:24 <lambdabot>  ["a"]
07:57:33 <kpreid> > do Right x <- [Left "a"]; return x
07:57:33 <lambdabot>  Add a type signature
07:57:40 <kpreid> > do Right x <- [Left "a" :: Either String String]; return x
07:57:41 <lambdabot>  []
07:58:02 <allbery_b> it's in IO, though,, so the fail becomes an exception
07:58:09 <kpreid> a failed pattern match in do syntax invokes 'fail' for that monad
07:58:09 <norpan> it will not pattern match fail, it will MonadError fail
07:58:23 <kpreid> norpan: no
07:58:29 <bakert> I see.
07:58:30 <allbery_b> it pattern match fails, which is trtanslated to the fail action for the monad
07:58:34 <norpan> yeah
07:58:37 <norpan> that's what i meant
07:58:48 <norpan> it will not error fail, it will MonadError fail
07:58:59 <kpreid> norpan: MonadError is something different.
07:59:11 <kpreid> @type fail
07:59:12 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:59:22 <allbery_b> MonadError is a more structured and better behaving version of the same thing, but this uses the lower level stuff
07:59:30 <kpreid> now perhaps fail *should* be in MonadError, but it isn't
07:59:41 * allbery_b invokes Cale...
07:59:45 <norpan> ah yes, monaderror i mptc
07:59:46 <norpan> is
08:00:20 <bakert> Thanks guys it works now.  I still get freaked out when compiling = working.  But it seems to happen a lot with Haskell.
08:00:54 <norpan> compiling often = working because a lot of the run time errors in other languages are compile-time errors in haskell
08:05:31 <fasta> How can I stop a computation in ghci? Using C-c doesn't work
08:05:59 <allbery_b> it should, unless you're on freebsd and didn't grab my patch
08:06:54 * paolino justifies Snow constraint on Monad class http://catenova.org/~paolino/p1000353.jpg 
08:07:25 <fasta> allbery_b: it doesn't work here (Linux)
08:07:43 <paolino> which patch ?
08:08:22 <allbery_b> the one that fixes readline.  for whatever reason ghci runs in raw mode without it --- not only no line editing but also no signals
08:08:53 <allbery_b> (well, ""fixes".  I sent it to haskell@ on 2006-12-31)
08:09:33 <allbery_b> the maintainer of the fbsd port has fixed it properly for the upcoming 6.6 update, btw
08:10:03 <paolino> allbery_b: 6.6 on freebsd is ever scheduled ?
08:10:09 <allbery_b> yes
08:10:41 <allbery_b> it's been on hold because ports was in slush (semi-freeze) for a couple months while they worked bugs out of 6.2
08:11:07 <allbery_b> (from early October until early January)
08:13:49 <paolino> I have some missing constraint errors compiling with 6.6 which do not show up compiling  with 6.4.2, is that coherent ?
08:15:31 <allbery_b> 6.6 added those, yeh
08:15:43 <allbery_b> there was some discussion on -cafe@ a couple weeks back IIRC
08:16:29 <allbery_b> 6.6 is trying to avoid some possible infinite loops in type unification that 6.4 let through
08:16:56 <tomh-> i need that
08:17:04 <tomh-> i just have such error
08:17:07 <syntaxfree> there are two things I can do right now: I can try and hack hpaste into a bulletin board system, or I can learn about functional dependencies. Which one should I tackle first?
08:17:13 <tomh-> *** Because        : unification would give infinite type
08:17:13 <glguy> > map (flip mod 9 . (*2)) [0..9]
08:17:15 <lambdabot>  [0,2,4,6,8,1,3,5,7,0]
08:17:15 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
08:18:29 <allbery_b> tomh- that's not an inifnite loop, it knows exactly what's going on there.  infinite loop means compilation never terminates, not terminates in error
08:18:37 <glguy> > map ((subtract 1) . flip mod 9 . (+1) . (*2)) [0..9]
08:18:39 <lambdabot>  [0,2,4,6,-1,1,3,5,7,0]
08:18:42 <tomh-> oh ok
08:19:30 <allbery_b> 6.6 tries to catch some of the cases that can lead to such nonterminating compilation, and is a little more restrictive than it "needs" to be --- but then, doing it right means solving the halting problem
08:19:56 <paolino> allbery_b: I had to put a constraint on a function with no apperent reason :/
08:20:49 <paolino> just because it uses a datatype with that constraint ?
08:21:02 <allbery_b> I saw the discussion but don't really understand --- I'm not a type systems wizard, or even an apprentice
08:21:18 * allbery_b also needs to go get ready for work :/
08:22:06 <paolino> happens almost every day
08:25:22 <chessguy> 'morning, glguy
08:25:33 <glguy> good morning to you
08:27:55 <chessguy> augh, i killed the conversation
08:28:08 <hpaste>  kaloskai pasted "breaking up a list" at http://hpaste.org/122
08:28:14 <kaloskai> I just wrote this simple function, but it seems clunky. Maybe I should be using foldl, but I don't see a neat way to do it.
08:29:01 <syntaxfree> xhtml shouldn't use "<<".
08:29:07 <syntaxfree> << looks like it's flip (>>)
08:29:54 <glguy> You don't have to use "xhtml"
08:29:57 <Saizan> ?type groupBy
08:29:59 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
08:29:59 <glguy> you can use xslt
08:30:19 <syntaxfree> XSLT is like a xml transformation language, right?
08:30:23 <malebria> What's the right way to convert Double to CDouble
08:30:24 <malebria> ?
08:30:38 <Igloo> realToFrac
08:30:54 <hpaste>  glguy pasted "mod10check" at http://hpaste.org/123
08:31:06 <malebria> Igloo: thanks.
08:31:20 <malebria> What about datatypes deriving Enum to Int?
08:31:27 <Botje> @pl \a b -> a - b < 5
08:31:28 <lambdabot> flip flip 5 . ((<) .) . (-)
08:31:32 <Botje> ew :)
08:31:52 <malebria> And Int to CInt?
08:33:28 <pbx> I don't understand the type signature of hpaste!
08:33:29 <lambdabot> pbx: You have 1 new message. '/msg lambdabot @messages' to read it.
08:35:29 <chessguy> > groupBy (\x y -> y-x <= 5) [1,2,3,7,15,16,21,35]
08:35:37 <lambdabot>  [[1,2,3],[7],[15,16],[21],[35]]
08:36:06 <chessguy> hmmm
08:36:49 <chessguy> ?src groupBy
08:36:50 <lambdabot> groupBy _  []       =  []
08:36:50 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:36:50 <lambdabot>     where (ys,zs) = span (eq x) xs
08:38:29 <kaloskai> interesting
08:43:21 <Saizan> ?src span
08:43:22 <lambdabot> Source not found. stty: unknown mode: doofus
08:43:28 <Saizan> ?src break
08:43:28 <lambdabot> break p =  span (not . p)
08:43:48 <Saizan> you are evil!
08:43:52 <pjd_> span p xs = (takeWhile p xs, dropWhile p xs)
08:44:27 <pjd_> "==", even
08:44:59 <pjd_> in other words, split xs at the first element for which p is false
08:45:03 <Saizan> that seems quite wasteful
08:45:54 <pjd_> it's not actually implemented that way
08:46:05 <pbx> Would it be kinda correct to say that Haskell functions only take one argument, and that a "two-argument" function is really a function that takes one argument and returns a function, which takes one argument and returns your result?
08:46:19 <Igloo> yes
08:46:49 <kaloskai> even more than kinda, if I understand correctly
08:51:54 <bd_> :t runReader
08:53:54 <paolino> monadic function -> environment -> result
08:56:42 <chessguy> @bot
08:57:19 <chessguy> ok, who killed LB
08:58:12 <AStorm> ?ping
08:58:29 <AStorm> bd_, you killed her! You bastard!
08:58:30 <AStorm> :P
08:58:47 <paolino> the question is , who resurrects it :P
08:59:21 <pbx> Igloo, kaloskai : Thanks.  I came here asking about that yesterday, but it didn't quite click until I heard this one-arg idea described in reference to Ocaml.
08:59:22 <bakert> put your tongues away please gentlemen
09:02:36 <chessguy> did kaloskai's list problem get solved?
09:03:13 <chessguy> kaloskai, ^^
09:05:28 <hpaste>  glguy pasted "basicAuth for new api" at http://hpaste.org/124
09:06:43 <pjd_> pbx: it's generally known as "curried form", by the way
09:07:06 <pjd_> pbx: most languages in the Haskell/ML family use it
09:09:15 <pbx> pjd_: I'm familiar with the term (though I couldn't tell you the difference between currying and partial application), but strictly speaking when you say "curried form" what are you referring to? The original function? Its type signature? A function returned by a function after partial application?
09:10:54 <pjd_> pbx: more or less, "function in curried form" -> "function that takes one arg at a time, returning intermediate functions"
09:11:32 <pbx> OK, thanks.
09:11:58 <koala_man> how would one go about implementing a dynamic programming algorithm? are there some memoisation possibilities, or should you use/fake an array?
09:12:00 <kaloskai> chessguy: not solved yet
09:12:15 <pjd_> so, "currying" is the process of taking a function of multiple parameters (IOW, in normal/uncurried form), and converting it to curried form
09:12:18 <chessguy> kaloskai, i thought my groupBy solution would work, i don't know why it didn't
09:12:29 <AStorm> pjd_, now that was circular :P
09:12:46 <AStorm> currying: f x y => f (x,y)
09:12:46 <pjd_> AStorm: right, just pinning down the vocabulary :)
09:12:50 <kaloskai> I think it's because 7 - 1 > 5, but 7 - 3 < 5
09:13:05 <kaloskai> groupBy compares to the 1, and I compare to the 3
09:13:11 <pjd_> AStorm: that's uncurrying, i think
09:13:12 <shapr> Good morning #haskell!
09:13:17 <AStorm> pjd_, ah, right
09:13:17 <bringert_> kosmikus: if I want to add lots of tokens that should be formatted as keywords in lhs2TeX, is there an easier way than to write lots of "%format public = "\mathbf{public}" etc?
09:13:28 <AStorm> Rotate the arrow pi radians
09:13:33 * bringert_ wants to typeset Java using lhs2TeX
09:13:36 <chessguy> oh, hmm
09:14:17 <amiddelk> bringert_: might take a while for kosmikus to respond. He's on his way home from the netherlands to germany
09:14:24 <bringert_> ah
09:14:27 <amiddelk> maybe you better pm him
09:14:46 <syntaxfree> o4r @tell him.
09:14:51 <chessguy> bot's down
09:15:18 <bringert_> amiddelk: I thought the netherlands was right next to germany :-)
09:16:10 <kowey> AStorm: my roundabout way of remembering which is which is that the language is named after "Haskell Curry"; and that the f x y is the style we like best, so forcibly, it would be the curried one, not the other way around
09:16:43 * kowey shows off how shallowly he understands things
09:16:56 <AStorm> Hmm, writing a Java -> Haskell compiler could be fun :P
09:17:20 <amiddelk> bringert_: yes that's true. But I have to go somewhere tonight that's less than 10 km away from here but still takes 40 minutes to get there... I almost could be faster there by foot instead of bus...
09:17:23 <chessguy> bringert_, the US is right next to Canada, too, but it's a loooong way from Dallas to Vancouver
09:17:31 <syntaxfree> a Haskell -> Java compiler would be more useful.
09:17:43 <AStorm> syntaxfree, impossible mostly
09:17:48 <AStorm> Would be awfully slow too.
09:17:52 <syntaxfree> @type curry
09:18:02 <AStorm> lambdabot is still dead
09:18:20 * shapr cries
09:18:35 <hpaste>  slowriot pasted "solveCase" at http://hpaste.org/125
09:18:36 <pejo> chessguy, but in the case of Holland the airport is almost as large as the entire country, area wise.
09:18:36 * xerox pats shapr 
09:18:40 <pejo> ;)
09:18:43 <bringert_> chessguy: european countries are a lot smaller than north american ones :-)
09:18:46 <bd_> @hoogle intercalate
09:18:48 <Nafai> shapr: What's wrong? :(
09:19:09 <shapr> lambdabot is dead :-(
09:19:10 <syntaxfree> @get-shapr
09:19:13 <shapr> see?
09:19:16 <Nafai> bringert_: A lot of European countries are smaller than North American states / provinces
09:19:19 <syntaxfree> wow. that was fast.
09:19:38 <shapr> hiya Mr Navarro
09:19:53 <shapr> How's code/
09:19:54 <shapr> ?
09:20:01 <shapr> Nafai: How's your script conversion?
09:20:24 <shapr> AStorm: Most of a Haskell -> JVM compiler has been written several times before.
09:20:28 <Nafai> shapr: Haven't gotten much further; I've been diverted to reading The Craft of Functional Programming
09:20:36 <shapr> Nafai: That's a worthwhile diversion.
09:20:44 <pejo> Nafai, how do you like it so far?
09:21:26 <slowriot> can anyone look at solveCase for me? Why does it expect an array of ints for putChar 'c'?
09:21:29 <Nafai> Pretty good, the first few chapters are really straight forward...The concepts are pretty easy for an experienced programmer
09:21:48 <AStorm> shapr, JVM != Java
09:21:55 <shapr> AStorm: true
09:23:23 <apfelmus> slowriot: what do you wan to do?
09:23:35 <slowriot> I want solve case to output 'c'
09:23:48 <slowriot> and create an array based on chars, which it doesn't use.
09:23:56 <slowriot> oh
09:23:58 <slowriot> I see
09:24:06 <Nafai> JVM != Java, but I think having something target the JVM vs. Java is more important, really
09:24:24 <slowriot> I could've put newarray <- array .....
09:24:30 <pbx> If I were going to buy one book on Haskell -- as a moderately experienced programmer who has not done much functional programming -- what might that book be?  (If this is an inflammatory FAQ then by all means redirect me...)
09:24:30 <slowriot> but that still doesn't fix it
09:25:58 <shapr> pbx: The two most commonly suggested books are SJ Thompson's 'The Craft of Functional Programming' and Paul Hudak's 'The Haskell School of Expression'
09:26:09 <AStorm> slowriot, an array? Why not a list?
09:26:30 <apfelmus> :t readLn
09:26:37 <slowriot> I'm going to be doing many slicing operations on it
09:26:40 <shapr> pbx: In my opinion, Hudak's book has some advantages in that it uses monads early on. Thompson's book has other advantages in that it doesn't require any knowledge of geometry or math to do the exercises.
09:26:46 <slowriot> so I want random access
09:26:54 <AStorm> slowriot, uh... Well. MArray it is then.
09:27:15 <slowriot> MArray, let's see what that is
09:27:44 <apfelmus> slowriot: mh, i wouldn't dabble with arrays. what exactly do you want to do?
09:28:13 <pbx> shapr: Thanks. I meant to mention that I didn't make it past Calculus I  :)
09:28:26 <shapr> pbx: Hudak's book is multimedia oriented, it teaches via simple graphics and music. But the means its code is a bit less portable and updated.
09:28:39 <apfelmus> slowriot: i mean your intention. which task do you expect your program to solve?
09:29:03 <slowriot> https://www.spoj.pl/problems/TOANDFRO/
09:29:53 <slowriot> I wasn't planning to alter the array after it had been set up. I would just jump through string several times, appending characters to the result, which would be represented with a list.
09:30:03 <fabiand> maybe a trivial question, but how can i return an Float when i divide to Ints?
09:30:35 <fabiand> (foo :: Int-> Int-> Float            foo x y = x / y)
09:30:39 <apfelmus> fabiand: use fromIntegral on the ints
09:30:52 <apfelmus> slowriot: you don't need arrays for that. not at all
09:31:19 <fabiand> apfelmus, ta - is working .. used fromInteger ... doo
09:31:27 <slowriot> The problem could be solved using only lists (200^2, no problem), but I think using an array would be faster.
09:31:46 <slowriot> apfelmus: what is your solution?
09:32:00 <AStorm> A decoder ring? :P
09:32:15 <shapr> Junior G-man?
09:32:16 <AStorm> That's a fun problem, yes.
09:33:54 <AStorm> slowriot, a linear solution using lists is also possible :>
09:33:56 <slowriot> the straightforward way to solve it would, for the first cols characters in the given string, jump cols characters at a time, appending each character it lands on onto a list.
09:33:59 <AStorm> Just undo the conversion.
09:34:16 <apfelmus> slowriot: if i tell, i'd steal you the task. i can only encourage you to solve it with nested lists [[a]].
09:34:32 <slowriot> okay, cool
09:34:34 <AStorm> Convert into a list of quintuples, then take each item from :>
09:34:40 <slowriot> I look into nested lists
09:34:46 <AStorm> apfelmus, ah, right :P
09:34:54 <AStorm> Can't use tuples, variable length.
09:35:15 <AStorm> Though it'd be much nicer, with pattern matching and all...
09:35:29 <AStorm> You could generate proper decoder given the tuple length.
09:35:32 <AStorm> :P
09:35:57 <AStorm> (but not w/o template haskell)
09:37:59 <apfelmus> actually, this problem is famous. when impose the condition that the algorithm must be online, a pure and strict language like ML or Lisp must take Omega(n^2 * log n) time, i.e. there is a logarithmic slowdown
09:38:05 <apfelmus> *imposing
09:38:30 <apfelmus> a lazy language can do in O(n^2)
09:38:33 <slowriot> that's a strange coincidince. This is the first problem I always solve when learning a new language.
09:39:12 <slowriot> wait...
09:39:14 <apfelmus> (i mean functional languages, that is)
09:40:07 <slowriot> apfelmus: so there is no linear solution? I already know of a quadratic solution.
09:40:20 <AStorm> Why n^2 when you can do linear? :P
09:40:26 <apfelmus> "linear" depends on your view
09:40:28 <AStorm> It's not THIS problem.
09:40:37 <slowriot> oh, okay
09:40:41 <AStorm> You just consume x characters at a time
09:40:53 <apfelmus> slowriot given n rows, you have n^2 characters, after all
09:40:55 <AStorm> and reorder at end. 2 reads -> O(k*2*n)
09:41:07 <AStorm> apfelmus, don't cheat :>
09:41:14 <AStorm> You have to read everything anyway.
09:41:21 <slowriot> yeah, okay
09:41:30 <apfelmus> cheat?
09:41:54 <AStorm> You're cheating the syntax. The smallest primitive there is a character.
09:42:18 <AStorm> Î©(n) it is.
09:42:31 <apfelmus> ? i say n = number of columns, and you say n = number of characters ?
09:42:37 <slowriot> I guess the list solution is pretty straightforward too.
09:42:41 <AStorm> Yes, the column is not a primitive.
09:42:56 <slowriot> I'm going to go for a run now, I'll solve it later. Thanks for the help.
09:42:56 <AStorm> You want to output not columns, but characters.
09:43:03 <slowriot> One more question, though
09:43:04 <AStorm> :-)
09:43:26 <slowriot> Why did it expect an "Array Int" for putChar?
09:44:04 <apfelmus> just forget the arrays :)
09:44:09 <slowriot> but... but...
09:45:26 <slowriot> Usually, when I get a compiler error, I like to know exactly what caused it.
09:45:47 <apfelmus> no doubt, you'll learn soon enough. it's just that arrays are not a data structure that fits the Haskell language.
09:46:04 <AStorm> Lists are.
09:46:11 <AStorm> Trees are too.
09:46:47 <apfelmus> arrays are vital in C or Pascal, but in Haskell, things are very different
09:47:32 <slowriot> okay, I'm going for a run now. later
09:47:43 <apfelmus> bbl
10:11:59 <Bonner83> join #haskell.de
10:15:04 <apfelmus> ?users
10:26:06 <AStorm> dons, whatever, please, resurrect lambdabot
10:44:18 <pbx> Never seen this place so quiet!
10:45:28 <apfelmus> (wisper) sshht! we're mourning for lambdabot.
10:45:48 <norpan>  
10:46:40 * apfelmus  
10:46:49 <pbx> apfelmus: You can't fool me. It's now clear that 290 of those 300 "users" were actually lambdabot itself.
10:46:50 <int-e> > 1
10:46:52 <lambdabot2>  1
10:46:59 <norpan> > 2
10:47:00 <lambdabot2>  2
10:47:19 <norpan> hmmm, has it always used two spaces?
10:47:32 <int-e> it's only one space, the other is from your client :)
10:47:36 <norpan> i mean, an extra space
10:47:53 <int-e> well, not always, but the reason is people doing CTCP with lambdabot :)
10:47:54 <allbery_b> I see only one
10:47:57 <allbery_b> I seelct only one
10:47:59 <int-e> > error "foo"
10:47:59 <lambdabot2>  Add a type signature
10:48:03 <int-e> > error "foo" :: Int
10:48:04 <lambdabot2>  Exception: foo
10:48:14 <int-e> well, something like that.
10:50:23 <apfelmus> pbx: Have you considered trying to match wits with a rutabaga?
10:52:12 <apfelmus> ?src lambdabot2
10:52:13 <lambdabot2> Source for this function is not available.
10:52:53 <apfelmus> oh, now she shows british disclipine. nice girl.
10:52:55 <apfelmus> ?botsnack
10:52:56 <lambdabot2> :)
10:53:33 * Botje ties lambdabot2 up
11:00:29 <glguy> ?seen dons
11:00:29 <lambdabot2> dons is in #haskell. I don't know when dons last spoke.
11:00:40 <glguy> lambdabot get lost in a netsplit?
11:01:39 <AStorm> No, dead.
11:01:57 <AStorm> All hanged
11:05:48 <pbx> I was asking about books earlier. I'm leaning toward SOE but noticed there's a new book out, and wondering if there are any opinions yet?  http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/
11:05:52 <lambdabot2> http://tinyurl.com/2xtkaj
11:13:07 <schtickle> so.. I heard Haskell is cool, and my friend was trying to explain to me about a Gonad but I could not get it. What's a Gonad
11:13:49 <emu> a monad with balls
11:13:57 <pbx> schtickle: It's related to input and output
11:14:01 <pjd_> pbx: i'm busy with SOE, and i think it's great
11:14:28 <Saizan> so, do we have Gonads tutorials?
11:14:30 <pbx> pjd_: Yeah. I like books "from the source" too. E.g. K&R.
11:14:35 <apfelmus> @where wikibook
11:14:35 <lambdabot2> http://en.wikibooks.org/wiki/Haskell
11:14:56 <AStorm> OMFG, it's Monad and not Gonad :-)
11:15:14 <AStorm> ?where monad
11:15:14 <lambdabot2> I know nothing about monad.
11:15:23 <AStorm> ?where YAHT
11:15:23 <lambdabot2> http://darcs.haskell.org/yaht/yaht.pdf
11:15:25 <apfelmus> http://en.wikibooks.org/wiki/Haskell/Monads
11:15:29 <AStorm> That should cover it.
11:15:31 <AStorm> :P
11:15:37 <schtickle> thanks everyone
11:16:12 <pbx> And I thought my input/output joke was so brilliant
11:17:48 <Excedrin> I laughed... inside
11:18:36 <pjd_> schtickle: monads basically let you implement your own evaluation schemes
11:19:17 <schtickle> cool
11:19:59 <pjd_> you can use them to implement I/O, implicit state, exception handling, exhaustive searching, and much more
11:20:04 <fasta> How can I make sure that trace output is always completely shown? Now, I sometimes get things like Noth *** Exception, instead of Nothing <more output>] for example.
11:20:41 <apfelmus> schtickle: in contrast, gonads are for producing more haskell addicts
11:20:44 <allbery_b> @hoogle hSetBuffering
11:20:45 <lambdabot2> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
11:21:00 <fasta> allbery_b: Does that influence trace?
11:21:01 <allbery_b> meh
11:21:24 <allbery_b> so did we lose both bots now or is it just dumb about hoogle?
11:21:31 <bd_> fasta: hmm... can you give an example which crashes trace in that way?
11:21:38 <allbery_b> anyway you probably want hSetBuffering to disable all output buffering
11:22:05 <allbery_b> on stdout and possibly stderr
11:22:15 <bd_> trace goes to stderr
11:22:15 <fasta> bd_: No, because reproducing the error without giving you tons of code is likely to be complicated.
11:22:18 <pbx> So nobody has heard of this new book by Graham Hutton?  I half expected him to just be here in the channel.
11:22:22 <bd_> fasta: hmm
11:22:27 <pbx> ?users
11:22:28 <lambdabot2> Maximum users seen in #haskell: 308, currently: 308 (100.0%), active: 19 (6.2%)
11:22:33 <bd_> fasta: how long is the string trace is producing, in total?
11:22:41 <chessguy> what book?
11:22:52 <fasta> bd_: < 500 chars, I guess.
11:22:56 <pjd_> chessguy: http://www.cs.nott.ac.uk/~gmh/book.html
11:22:59 <lambdabot2> Title: Programming in Haskell
11:22:59 <bd_> hmm
11:23:09 <pjd_> pbx: well, it's only been published this month, apparently :)
11:23:18 <pbx> Yeah, no reviews on Amazon yet.
11:23:25 <chessguy> oh, i've heard it mentioned on here before
11:23:34 <pjd_> the cover looks very shiny indeed
11:24:02 <fasta> http://www.cs.nott.ac.uk/~gmh/tautology.lhs <- academic code
11:24:02 <apfelmus> pbx: heard yes, but i can't look inside (without giving my intellectual property (=e-mail address) to jungle books)
11:24:15 <fasta> I wrote the same thing once, it's horribly slow.
11:24:53 <fasta> We (well, not me) need books that show how to efficiently write algorithms.
11:25:24 <AStorm> fasta, by default, stderr is unbuffered
11:25:33 <AStorm> So the problem is somewhere else.
11:25:38 <chessguy> mmm, efficiently write algorithms, or write efficient algorithms?
11:25:38 <AStorm> Is the app multithreaded?
11:25:40 <apfelmus> fasta: remember that it's inherent to the algorithm: 2^n tests for n variables
11:25:45 <AStorm> chessguy, both
11:25:54 <chessguy> i agree, but they are different
11:26:03 <fasta> apfelmus: no need to make it even more slower.
11:26:23 <apfelmus> fasta: i don't see what's wrong with it
11:26:27 <Excedrin> can't the compiler simply translate my O(hyper4(n)) function to something O(1)?
11:26:31 <Procyon> I'm trying to do a lookup table of string keys to function values.  is Data.map what I want?
11:26:49 <fasta> apfelmus: ++ ?
11:26:58 <xerox> Procyon: yes.
11:27:00 <apfelmus> Procyon: most likely. just use it
11:27:01 <bd_> !paste
11:27:02 <hpaste> Haskell paste bin: http://hpaste.org/
11:27:15 <fasta> AStorm: no
11:27:33 <hpaste>  bd_ pasted "fasta, how about using this?" at http://hpaste.org/126
11:28:31 <dylan> @tell sorear I think I found a vty bug
11:28:32 <lambdabot2> Consider it noted.
11:29:28 <fasta> bd_: Something like that might work, but I don't understand why Debug.Trace.trace wouldn't do that already.
11:29:46 <bd_> fasta: It probably shoves it all into hPutStrLn, which might buffer internally
11:30:00 <bd_> hSetBuffering only requires implicit hFlushes I believe
11:30:08 <bd_> not a requirement to not chunk data before handing it to the OS
11:30:26 <AStorm> ?where vty
11:30:26 <lambdabot2> I know nothing about vty.
11:30:35 <fasta> bd_: I will check whether it solves the problem.
11:31:22 <apfelmus> fasta: mh, sure you can replace ++ by difference lists. but only after you wrote it down
11:32:59 <fasta> bd_: It doesn't compile. (but thanks for the idea)
11:33:15 <fasta> bd_: nm
11:33:21 <bd_> fasta: hm?
11:33:27 <bd_> worked here...
11:33:38 <fasta> bd_: It does work.
11:33:47 <bd_> ah, good :)
11:34:17 <allbery_b> fasta: it influences all operations on a handle, regardless of how you did them (e.g. unsafePerformIO)
11:34:36 <allbery_b> exceptions go outside the framework and cause processing to abort without flushing output buffers
11:34:50 <fasta> allbery_b: what's "it"?
11:34:57 <bd_> hSetBuffering I guess
11:35:04 <fasta> I guessed that too
11:35:09 <allbery_b> yeh
11:35:31 <fasta> allbery_b: ok, so that's why hSetBuffering doesn't work?
11:35:35 <allbery_b> this behavior is part of the underlying I/O library, not really part of Haskell
11:36:20 <bd_> allbery_b: The I/O library for GHC is written in haskell :)
11:36:51 <fasta> Ok, one related thing.
11:37:07 <fasta> trace' "hi" (error "") gives the desired result
11:37:37 <fasta> But evaluating a variable with that value again, only gives "***Exception", not "hi".
11:37:47 <fasta> So, ghci should forget what it has done.
11:37:50 <bd_> ?
11:38:01 <fasta> Define foo =  trace' "hi" (error "")
11:38:02 <bd_> if you do let x = trace' "hi" undefined in (x, x)
11:38:07 <bd_> it's only going to evaluate it once :)
11:38:14 <bd_> if you're working in ghci just make an io-monad thing
11:39:02 <fasta> bd_: I know it only evaluates it once.
11:39:13 <fasta> bd_: That's the problem.
11:39:32 <bd_> trace' is bending the rules of haskell; it can't break them completely, though :)
11:39:49 <bd_> you'll have to explicitly break sharing by calling trace' more than once
11:39:51 <bd_> but even that's fragile
11:43:02 <allbery_b> bd_: doesn;t sit on top of stdio, but implements all its oddities?  seems wasteful
11:43:45 <bd_> oddities?
11:45:56 <bd_> allbery_b: http://darcs.haskell.org/ghc-6.6/packages/base/GHC/Handle.hs
11:47:22 <bd_> it helps avoid safe foreign calls, I think - calling into eg fwrite() could require spawning a temporary thread
11:55:39 <glguy> ?seen shapr
11:55:40 <lambdabot2> shapr is in #haskell. I don't know when shapr last spoke.
11:56:21 <pbx> Poor lambdabot2.
12:09:41 <fons> I'm having a problem creating a multiparameter class
12:16:42 <hpaste>  fons pasted "Multiparameter class problem" at http://hpaste.org/127
12:17:18 <fons> can someone have a look at that?
12:17:19 <shapr> glguy: You called?
12:17:42 <glguy> shapr: do you understand the SimpleHTTP2 stuff?
12:18:00 <glguy> where you want to answer questions about it :)
12:18:21 <glguy> and have you seen http://hpaste.org/124#1
12:21:15 * shapr looks
12:22:41 <shapr> I understand some of SimpleHTTP2, what questions do you have?
12:23:47 <svref> I'm optimizing.  my .prof file says that my big expensive function is entered 6 times.  I think it should be called once.  I'm new.  Should I trust that '6', or is the profiler likely wrong?
12:23:51 <glguy> musasabi: mentioned, before he went to bed, that he wrote a function "ifH matcher method parts"
12:24:00 <glguy> it would run the ServerPart s in parts
12:24:03 <glguy> if the matcher and method worked
12:24:13 <glguy> can you point me in the right direction to figure this out
12:24:18 <glguy> "mostly" on my own
12:24:26 <glguy> I'm trying to get more comfortable with the API
12:24:34 <glguy> (is hImpl a place to start looking?)
12:25:51 <shapr> svref: The profiler is probably right. Try putting the call to your function in a let statement for CSE
12:26:10 <shapr> glguy: looking
12:26:26 <svref> shapr: thx!
12:27:49 <shapr> glguy: I think you should look at ServerPart.ServerPart
12:27:53 <glguy> ok
12:28:09 <shapr> glguy: That is, HAppS.Protocols.HTTP.ServerPart.ServerPart
12:28:25 <glguy> ah, ok
12:30:54 <svref> next optimization question: Data.Map.findWithDefault is taking 70% of my cpu-time.  Is it time to replace the Data.Map with a hash table hidden behind unsafePerformIO ?
12:33:21 <shapr> brainly-green: Hi brainly-green, how's code?
12:33:45 <bd_> svref: Careful there, the semantics of Data.HashTable are quite different from Data.Map
12:34:08 <bd_> note to self: benchmark and release that pure hashtable I wrote some time ago...
12:34:26 <basti_> hi shapr
12:34:50 <svref> hmmm...
12:35:04 <brainly-green> hi shapr nm is happening u?
12:35:38 <brainly-green> oops "aol-speak" is that shunned here
12:35:58 <brainly-green> I'm a leper
12:35:59 <shapr> Well, I didn't understand what you said...
12:36:07 <shapr> hiya basti_
12:36:11 <brainly-green> nothing much is happening, how about you?
12:36:22 <shapr> Oh, I have a paying Haskell job, so I'm bouncy and coding :-)
12:36:32 <basti_> :)
12:36:33 <brainly-green> cool
12:37:13 <thartman> ?paste
12:37:13 <lambdabot2> http://paste.lisp.org/new/haskell
12:37:18 <brainly-green> what are you using it for
12:37:33 <shapr> For a web-dev framework.
12:37:36 <shapr> !paste
12:37:36 <hpaste> Haskell paste bin: http://hpaste.org/
12:37:54 <shapr> glguy just wrote that hpaste with the web app server I'm working on.
12:38:16 <shapr> I'm just one of the developers working on it.
12:38:34 <shapr> I'm happy that glguy was able to write hpaste in .. three days or so.
12:38:38 <shapr> Maybe it was four.
12:38:44 <CosmicRay> shapr!
12:38:49 <shapr> John!
12:38:53 <glguy> I didn't "release" for a week, but it was working in fewer days
12:39:06 * shapr hugs CosmicRay
12:39:09 <glguy> I still don't really understand it yet though ;)
12:39:10 <svref> http://paste.lisp.org/display/35959
12:39:15 <zarvok> question:  Is there a haskell equivalent to the ocaml String.escaped?
12:39:17 <shapr> CosmicRay: Your new home DSL is online!
12:39:24 <CosmicRay> shapr: it is!
12:39:31 <glguy> zarvok: that does?
12:39:46 <CosmicRay> zarvok: what does ocaml string.escaped do?
12:39:55 <CosmicRay> shapr: how goes it?
12:40:10 <shapr> CosmicRay: Code is good, and it's sunny outside so I'll have a good day unicycling too.
12:40:16 <CosmicRay> nice
12:40:27 <CosmicRay> what are you coding these days?
12:40:28 <shapr> CosmicRay: oh HEY, I had some interesting MAKE ideas, do you know if there's an irc channel for that community?
12:40:54 <shapr> I'm coding on HAppS and some legacy Python code for another client.
12:40:56 <zarvok> basically it escapes a string, so String.escaped "/\" is legal without escaping the \
12:41:05 <svref> what's #haskell.hr ?
12:41:09 <shapr> I met a Bulgarian artist while unicycling who wants me to do some consulting for him...
12:41:10 <CosmicRay> I've just pulled up the happs website and I very obviously need to read up about it
12:41:13 <shapr> svref: croatian
12:41:23 <shapr> hrvatska
12:41:26 <CosmicRay> zarvok: you may want the show  and read functions in haskell
12:41:36 <shapr> CosmicRay: oh oh, try my tutorial and tell me what sucks!
12:41:42 <zarvok> hmm, I can't show "/\" can I?
12:41:49 <svref> what happened to the #haskell option at lisp.paste.org?
12:42:08 <CosmicRay> zarvok: I am confused.  "/\" is certainly not a valid literal in a .hs source file
12:42:18 <shapr> > show "/\\"
12:42:20 <lambdabot2>  "\"/\\\\\""
12:42:22 <CosmicRay> zarvok: but surely the ocaml function doesn't adjust the lexer...
12:42:29 <wilx> > show "\"
12:42:29 <lambdabot2>  Improperly terminated string
12:42:32 <wilx> > show "\\"
12:42:33 <lambdabot2>  "\"\\\\\""
12:42:36 <wilx> Heh.
12:42:40 <zarvok> CosmicRay: yeah, I personally have no idea how it works, the question comes not from me but from an ocaml hacker I know who is trying to learn haskell
12:42:41 <shapr> Summat wrong there...
12:42:53 <zarvok> he assures me this is how ocaml works
12:43:05 <CosmicRay> shapr: is this your tutorial? http://happs.org/HAppS/doc/tutorial.html
12:43:07 <lambdabot2> Title: HAppS Tutorial
12:43:21 <zarvok> there are so many other things wrong with that language, I wasn't super surprised :)
12:43:36 <shapr> CosmicRay: Here's the new tutorial: http://www.haskell.org/haskellwiki/HAppS_tutorial
12:43:37 <lambdabot2> Title: HAppS tutorial - HaskellWiki
12:43:45 <matthew_-> > show " "
12:43:46 <lambdabot2>  "\" \""
12:43:56 <matthew_-> mmm. showing a string is odd
12:43:59 <shapr> > "\"
12:43:59 <lambdabot2>  Improperly terminated string
12:44:05 <shapr> > "\/"
12:44:06 <lambdabot2>  Illegal escape sequence
12:44:07 <CosmicRay> show '\\'
12:44:11 <CosmicRay> > show '\\'
12:44:12 <lambdabot2>  "'\\\\'"
12:44:14 <matthew_-> > [' ']
12:44:16 <lambdabot2>  " "
12:44:20 <matthew_-> > show [' ']
12:44:22 <lambdabot2>  "\" \""
12:44:25 <matthew_-> eek
12:44:27 <CosmicRay> oh, I see.  lambdabot is already calling show on the result.
12:44:43 <CosmicRay> > "asdf"
12:44:44 <lambdabot2>  "asdf"
12:44:44 <wilx> > "\\"
12:44:45 <lambdabot2>  "\\"
12:44:49 <wilx> Hm.
12:45:27 <CosmicRay> shapr: urk, it requires TH!  IIRC, TH doesn't run on all the platforms I want to
12:46:11 <shapr> CosmicRay: It's okay, HAppS is moving to SYB
12:46:16 <CosmicRay> SYB?
12:46:22 <shapr> Scrap Your Boilerplate
12:46:30 <musasabi> more like HList.
12:46:38 <musasabi> I hope/think.
12:47:31 * Igloo has some half-patches to make TH work "everywhere". I should really finish them.
12:49:21 <CosmicRay> shapr: in 3.1.4, where do you get mimeTypes from?
12:50:00 <shapr> from Import HAppS, which may not be in the source yet :-)
12:50:36 <CosmicRay> shapr: and where does it get it from?
12:50:46 <CosmicRay> I ask because I have some mime types code in MissingH that could perhaps be shared
12:50:56 <musasabi> HAppS.Protocols.HTTP.Filetype, just a static list.
12:50:59 <shapr> HAppS.Protocols...
12:51:10 <musasabi> ah no.
12:51:13 <musasabi> *FileServe
12:51:23 <CosmicRay> shapr, musasabi: http://software.complete.org/missingh/static/doc/Data-MIME-Types.html
12:51:25 <lambdabot2> http://tinyurl.com/yoezxn
12:51:34 <CosmicRay> that code uses the system's mime.types
12:52:00 <musasabi> CosmicRay: does it work on windows?
12:52:11 <CosmicRay> musasabi: it should, if you have a mime.types file there.
12:52:32 <CosmicRay> in fact, I'm fairly sure it passes unit tests on windows.
12:53:23 <ptolomy> Is there an easy way to make 'connectTo' timeout sooner than it does when it can't connect?
12:53:37 <CosmicRay> ptolomy: are you referring to the socket function?
12:53:45 <ptolomy> CosmicRay: Yes.
12:54:51 <musasabi> CosmicRay: that looks nice, have to hook it up when we need better mimetype support.
12:54:52 <CosmicRay> ptolomy: I wonder of setting SO_RCVTIMEO or SO_SNDTIMEO (set socket(7) and setsockopt(2)) would do it
12:55:28 <sjanssen> @YOW!
12:55:28 <lambdabot2> Unknown command, try @list
12:55:32 <musasabi> ptolomy: just use a timeout combinator.
12:55:35 <shapr> @yow?
12:55:36 <lambdabot2> Hello...  IRON CURTAIN?  Send over a SAUSAGE PIZZA!  World War III?  No
12:55:36 <lambdabot2> thanks!
12:55:38 <shapr> whew
12:55:41 <sjanssen> @yow -- you are stupid, spell checker
12:55:41 <lambdabot2> It's OBVIOUS ... The FURS never reached ISTANBUL ... You were an EXTRA
12:55:42 <lambdabot2> in the REMAKE of "TOPKAPI" ... Go home to your WIFE ... She's making
12:55:42 <lambdabot2> FRENCH TOAST!
12:56:17 <NichardRixon> ...what
12:56:23 <musasabi> ptolomy: like withSafeTimeOut from http://happs.org/HAppS/src/HAppS/Util/TimeOut.hs
12:56:42 <CosmicRay> there is also a timeout in peter simons' threads/child library
12:56:55 <shapr> Speaking of which, has anyone here tried Postmaster?
12:57:36 <Nafai> Haven't heard of it
12:57:37 <Nafai> What is it?
12:57:43 <shapr> It's a pure Haskell SMTP server.
12:58:50 <glguy> ?pl ifH a b ss = h a b $ \() rq -> runServerParts ss rq
12:58:51 <lambdabot2> (line 1, column 12):
12:58:51 <lambdabot2> unexpected "="
12:58:51 <lambdabot2> expecting variable, "(", operator or end of input
12:58:59 <glguy> ifH a b ss = h a b $ \ _ rq -> runServerParts ss rq
12:59:08 <glguy> ?pl ifH a b ss = h a b $ \ _ rq -> runServerParts ss rq
12:59:09 <lambdabot2> ifH = flip flip (const . runServerParts) . ((.) .) . h
12:59:16 <glguy> oops
12:59:32 <glguy> ?pl \ _ rq -> runServerParts ss rq
12:59:33 <lambdabot2> const (runServerParts ss)
13:00:20 <xerox> ?pl flip flip f
13:00:21 <lambdabot2> flip flip f
13:00:36 <xerox> ?pl flip (flip f)
13:00:36 <lambdabot2> f
13:02:02 <bd_> @free flip
13:02:04 <lambdabot2> (forall x. f . k x = p (g x) . h) => f . flip k y = flip p (h y) . g
13:04:13 <shapr> CosmicRay: Do you know if there's any way to do IPv6 multicast across IPv4? That is, does either of 6over4 or 6to4 support multicast?
13:04:24 * araujo `offTo` univ
13:08:05 <dons> ?users
13:08:06 <lambdabot2> Maximum users seen in #haskell: 312, currently: 310 (99.4%), active: 33 (10.6%)
13:11:49 <malebria> dons: I've made a patch for that typeOf program, are you interested in it?
13:12:07 <dons> sure
13:12:42 <malebria> dons: the first point is the repetition of the token, to use it in emacs I have to remove the token after it's printed.
13:13:10 <malebria> dons: So I just removed the second print in the program. In vi is it hard to use it without repeating the token?
13:13:16 <malebria> dons: maybe it could be a parameter.
13:13:16 <dons> hmm
13:13:21 <dons> yeah
13:13:26 <dons> but test it in vim too
13:13:39 <dons> ?users
13:13:39 <lambdabot> Maximum users seen in #haskell: 322, currently: 308 (95.7%), active: 2 (0.6%)
13:13:55 <malebria> dons: I don't know anything about vim.
13:14:04 <malebria> dons: I can't even test it.
13:14:19 <malebria> I was wondering about packaging it to debian.
13:17:26 <sjanssen> malebria: that change breaks the vimscript
13:18:19 <malebria> sjanssen: but is it hard to change the script to adapt to that?
13:18:46 <sjanssen> malebria: I have no idea
13:19:02 <malebria> sjanssen: From the program's point of view it doesn't make much sense to repeat the input.
13:19:33 <sjanssen> this is true
13:19:54 <malebria> Is it quickcheck the best option for program check?
13:24:43 <shapr> malebria: I think so, but I often use HUnit instead.
13:24:59 <emu> emacs haskell-mode cvs should be able to insert type-annotations for you
13:25:35 <malebria> shapr: Is there a reason for choosing hunit?
13:26:08 <emu> QuickCheck checks declared properties with randomly generated data.  it is different from
13:26:13 <shapr> QuickCheck is difficult to use for IO stuff.
13:26:14 <emu> HUnit, which is programmed unit tests
13:26:22 <bd_> quickcheck is for testing properties... if you can't express something you want to test as forall a => P(a), then yo might want HUnit :)
13:26:44 <malebria> thanks..
13:26:47 <emu> or forall a. P(a) => Q(a)
13:26:53 <shapr> I'd use QuickCheck for everything if it handled IO well.
13:26:54 <malebria> I think HUnit is more what I want.
13:27:04 <malebria> I've just written a wrapper for libgpcl
13:27:18 <emu> ?check \s -> reverse (reverse s) == (s::[Int])
13:27:18 <malebria> www.cs.man.ac.uk/~toby/alan/software/gpc.html
13:27:18 <shapr> Of course, if QuickCheck handled IO well, everyone on #haskell would instantly have a job in the penetration testing industry.
13:27:20 <lambdabot>  OK, passed 500 tests.
13:27:24 <emu> ^ -- quickcheck
13:28:04 <Itkovian> hi shapr
13:28:08 <shapr> hoi Itkovian
13:28:14 <emu> ?check \s -> reverse (reverse s) == (s::[Int])   -- property: a reversed reversed list is the list itself
13:28:15 <Itkovian> long time no see :-)
13:28:15 <lambdabot>  OK, passed 500 tests.
13:28:34 <shapr> Itkovian: Come visit me in Alabama!
13:28:34 <Taral> @seen JohnMeacham
13:28:35 <lambdabot> JohnMeacham is in #haskell-blah and #haskell. I don't know when JohnMeacham last spoke.
13:28:38 <shapr> hiya Taral
13:28:42 <Taral> coi shapr.'
13:28:51 <Taral> I'm trying to get jhc to compile
13:28:54 <Itkovian> shapr: I think not. I need hot water to wash :-)
13:29:06 <shapr> coi taral .i ma nuzba
13:29:15 <JohnMeacham> sup?
13:29:26 <shapr> Itkovian: Alabama has lots of hot water.
13:29:33 <Itkovian> but not on tap
13:29:45 <shapr> Well, my shower works fine :-)
13:30:07 <Taral> it helps if I follow the instructions
13:30:17 <shapr> Taral: That would be too easy.
13:30:21 <Taral> lol
13:30:23 <Taral> and install fgl
13:30:26 <michaelw> emu: i ran into your runSTArray $ (...) vs. runSTArray (...)  bug
13:30:40 <michaelw> emu: did you report it?
13:31:01 <shapr> ma na cilre do
13:31:01 <Taral> drift is really lazy about imports
13:31:08 <Taral> I get 5 billion warnings about unused imports
13:31:28 <sjanssen> michaelw: "runST $" is a well known problem
13:31:35 <sjanssen> a bug report is not necessary
13:32:16 <bd_> what's the problem?
13:32:17 <Igloo> It's also not exactly a bug, and also fixed in the HEAD I think
13:32:20 <CosmicRay> shapr: I know almost nothing about multicast, sorry
13:32:43 <CosmicRay> Igloo: about that ghc threading thing....  how do you believe it's an hpodder bug if ghc is crashing while linking?
13:33:06 <CosmicRay> Igloo: also there's no real documentation of what I should do about it
13:33:13 <CosmicRay> other than stop using threads
13:33:38 <Taral> Igloo: runST $ is fixed in HEAD?!
13:34:10 <Igloo> CosmicRay: for arches that don't have the threaded RTS you'll have to either link without it or not build on those arches, depending on whether you really need it or not
13:34:27 <CosmicRay> Igloo: but what are those archs?
13:34:47 <Igloo> Taral: I think SPJ made it work but left-to-right only
13:35:03 <Taral> I never clearly understood why it didn't work in the first place.
13:35:12 <Igloo> CosmicRay: x86 and amd64 have the threaded RTS
13:35:23 <CosmicRay> igloo: and still, that's a workaround...  which I'm fine doing.  but at best, the bug should be split so there is still something open with ghc.  I maintain it's not a bug in hpodder, as hpodder is using ghc as ghc is documented
13:35:26 <CosmicRay> Igloo: and that's it?
13:35:29 <Taral> perhaps a RULE: ($) a b => a b would help?
13:36:00 <Igloo> CosmicRay: There should probably be a bug against ghc6 about it being missing on other arches, true, but not an RC one  :-)
13:36:03 <Taral> JohnMeacham: Why does jhc produce so many non-exhaustive case warnings?
13:36:03 <Igloo> CosmicRay: Yup
13:36:11 <sjanssen> Taral: RULE matching happens after type checking, so no
13:36:16 <Taral> :<
13:36:36 <CosmicRay> Igloo: yeah that's fair enough.  this behavior should at least be documented in the manpage for ghc, I'd say.
13:36:43 <JohnMeacham> Taral: what do you mean? when compiling jhc itself?
13:36:47 <Taral> yes
13:36:57 <Taral> lots and lots of "Warning: Pattern match(es) are non-exhaustive"
13:36:58 <CosmicRay> Igloo: so one other thing I'm not clear on... how does the lack of a threaded RTS impact forkIO and forkOS?
13:37:09 <bd_> Taral: What's this bug with runST vs runST $?
13:37:15 <Igloo> Taral: The reason it doesn't work is that ($)'s type variable needs to be instantiated to a polymorphic type
13:37:19 <Taral> bd_: runST $ will produce funny errors at you
13:37:44 <bd_> like what?
13:37:45 <Taral> Igloo: And it doesn't like that?
13:37:50 <Taral> bd_: Try it.
13:38:03 <Igloo> CosmicRay: I think it'll only cause problems if you need to keep doing other stuff while a C call happens
13:38:13 <bd_> ah
13:38:20 <Igloo> Taral: Allowing that in general makes type inference undecidable
13:38:24 <Taral> Igloo: Oh.
13:38:38 <CosmicRay> Igloo: with both forkIO and forkOS?  do they become functionally equivolent without the threaded rts?
13:38:40 <Igloo> as you never know if you need to instantiate with some polymorphism or not
13:38:52 <Taral> Perhaps some kind of early pre-typecheck inlining?
13:39:04 <JohnMeacham> Taral: some is autogenerated code, others are things I have not decided what to do with yet. run-time errors due to those are nice because they have the line number and everything attached, so I tend to leave them as non-exhaustive during development as the code is changing quickly and calls to 'error' would just obfuscate things.
13:39:14 <Taral> JohnMeacham: Oh.
13:39:26 <Igloo> CosmicRay: I can't remember the details OTTOMH
13:39:35 <Taral> autogenerated code should not leave case branches undefined.
13:39:39 <JohnMeacham> Taral: but some are things I actually need to fix.
13:40:28 <JohnMeacham> Taral: I know. DrIFT used to, I fixed a lot of them. i wish there were a NOWARNING pragma to make the compiler not generate warnings about certain things.
13:40:44 <Taral> is there one in jhc?
13:41:24 <JohnMeacham> Taral: actually, a whole lot of them are a bug in ghc now that I think about it. ghc doesn't recognize irrefutable patterns as ending a match.
13:41:50 <Taral> ah
13:42:32 <JohnMeacham> Taral: which is too bad, because they are perfect for this sort of thing, documenting when you _expect_ a function to always match in a lightweight way.
13:42:58 <dons> JohnMeacham: hmm, there's the -fno-warn* to stick in a GHC_OPTOINS pragma?
13:43:09 <dons> JohnMeacham: so, any thoughts on Int/64bits?
13:43:20 <dons> is there any H' proposal to set the size of Int properly?
13:44:00 <JohnMeacham> dons: yeah, but I don't want to do it module-wide.
13:44:01 <malebria> dons: to which e-mail must I send the patches to?
13:44:10 <Philippa> I can't help but think "properly" probably means "whatever C's int is"
13:44:15 <dons> malebria: dons@ on my website
13:44:17 <dons> ?where dons
13:44:17 <lambdabot> http://www.cse.unsw.edu.au/~dons
13:44:23 <dons> Philippa: yeah
13:44:25 <JohnMeacham> dons: the size of int is >= 30 bits. that is just right. any programs that assume otherwise are non-portable.
13:44:27 <dons> the ffi is another issue
13:44:30 <dons> Int -> CInt
13:44:34 <dons> doesn't work on amd64/ghc, I guess
13:44:52 <dons> JohnMeacham: ok, so binary assumes much greater > 30 bits :)
13:45:20 <JohnMeacham> in practice, other than the current buggy ghc, I highly doubt any compiler will ever make them anything other than 32 bits.
13:45:37 <dons> so your point is that people who rely on Int == 64 bits on 64 bit machines should lose over Int == 32 for binary?
13:45:40 <dons> maybe that's reasonable
13:45:51 <JohnMeacham> dons: in any case, the new Integer encoding seems to work quite well for Int too. faster and smaller.
13:45:57 <malebria> dons: I sent you some patches, most of them are not very important. One removes MVars, since waitForProcess should be enough.
13:45:58 <dons> cool
13:46:02 <dons> JohnMeacham: send it in!
13:46:07 <JohnMeacham> yeah, those people are writing buggy code to begin with.
13:46:14 <dons> malebria: ah you looking at the haskell version of the script?
13:46:21 <malebria> dons: and there are some style suggestions, if you don't like them, I'd like to talk about them with you.
13:46:25 <malebria> dons: sure!
13:46:26 <JohnMeacham> dons: will, but I actually have work-work stuff to do at the moment, will send it in later tonight.
13:46:26 <malebria> =D
13:46:34 <dons> JohnMeacham: cheers
13:46:51 <JohnMeacham> dons: check out my post about alignment stuff I just made on the list, we can do some cool stuff with those primitives.
13:46:57 <dons> malebria: why is Removed MVars -- waitForProcess should be enough enough ?
13:47:16 <dons> (maybe it is in this case, since ghci output is small..)
13:47:24 <dons> JohnMeacham: ok.
13:47:56 <malebria> dons: from what I understood, the MVars were there to wait for the process to finish.
13:48:12 <dons> for the forkIO's reading to finish, no?
13:48:16 <malebria> dons: and isn't this the point of waitForProcess?
13:48:17 <JohnMeacham> dons: BTW, what is the best mailing list to discuss Data.Binary stuff so the authors will see it, just the libraries one?
13:48:19 <dons> in case you've got -threaded on
13:48:31 <dons> JohnMeacham: yeah, libraries@ wil ldo
13:48:53 <dons> its mostly Ross, me, duncan and lennart kolmodin who'll want to see mail
13:50:06 <malebria> dons: but the forkIOs will be finished when the process if finished, no?
13:50:16 <dons> why?
13:51:08 <malebria> dons: because they're reading from the handle generated for the process.
13:51:47 <dons> if you don't force the input explicitly, the process finishing will chop off the output, and it won't get all read
13:51:55 <dons> maybe the MVars aren't needed, except on the smp runtime
13:52:20 <dons> anyway, the point was that this has been carefully adjusted to work so I get very worried if you remove things
13:52:41 <Excedrin> is the conversation about int size related to getLazyByteString ?
13:52:58 <malebria> dons: that's why I sent the patches to you, so that we could talk about it.
13:53:04 <dons> :)
13:53:15 <dons> Excedrin: nope. about Int serialisation in binary
13:54:03 <malebria> dons: but the input is closed.
13:54:34 <malebria> dons: doesn't hClose inp satisfy "force the input explicitly"?
13:54:36 <dons> the issue is: I know the old code works, and each thing, the forkIO and the MVar were added to lambdabot's popen to fix bugs.
13:54:44 <dons> so to remove them, i'd need some test cases to convince me
13:54:53 <dons> hClose doesn't force the input!
13:55:00 <dons> it just truncates, if it hasn't been all read
13:55:05 <dons> that's why the forkIO.
13:55:41 <dons> think: h <- openFile "foo" ReadWriteMode ; s <- hGetCotnents h ; writeFile "foo" (reverse s) -- bad!
13:56:01 <malebria> hum..
13:56:32 <malebria> hClose truncates the input?
13:56:52 <dons> it just closes the handle
13:56:56 <neonse> is there a JSON library for Haskell?
13:56:57 <dons> if you've not read everything, too bad
13:57:02 <dons> neonse: I *think* so
13:57:12 <dons> check http://haskell.org under 'libraries and tools'
13:57:14 <lambdabot> Title: Haskell - HaskellWiki
13:57:28 <dons> malebria: ok, your other patches, they break the vim script/
13:57:50 <malebria> dons: but can't the vim script change?
13:57:51 * dons ponders how to fix vim
13:58:15 <dons> this is the vim script:  :map ty :.!typeOf %^M
13:58:23 <sjanssen> dons: is there a "run shell command and paste output above" in Vim?
13:58:33 <dons> :.!
13:58:37 <sjanssen> .! is a filter, apparently
13:58:40 <dons> not above, that I know of
13:58:51 <dons> right filter.
13:59:18 <dons> malebria: how about a command line flag
13:59:19 <dons> --vim
13:59:25 <dons> which I can pass to typeOf
13:59:28 <dons> that does the old behaviour
13:59:46 <malebria> dons: yes, this is a good option.
13:59:50 <malebria> dons: or maybe --repeat
14:00:21 <dons> can you add that, and resend the patches, minus the popen clean up stuff?
14:00:32 <malebria> dons: read everything from what?
14:00:46 <dons> hmm?
14:00:53 <dons> ah , the Handle
14:00:55 <malebria> dons: ok, but I'd like to understand why that is needed.
14:01:11 <dons> i think it should be pretty easy to consturct a test case
14:01:19 <dons> where you lose input when you close early
14:01:34 <dons> and especially when you don't force the strings
14:01:35 <malebria> dons: I'm reading ghc doc here, but I can't get the functionality of hGetContents.
14:01:52 <dons> it lazily reads the input handle
14:01:53 <malebria> What's to force the strings?
14:02:01 <dons> forkIO (length )
14:02:06 <sjanssen> if the Haskell program doesn't demand the output from the forked process, couldn't you get deadlock in waitForProcess?
14:02:09 <malebria> hum..
14:02:16 <malebria> The output, you mean.
14:02:23 <dons> sjanssen: I think an exception gets thrown?
14:02:29 <dons> certainly something bad happens
14:02:44 <dons> we learnt the hard way in lambdabot
14:03:12 <dons> malebria: there's a nice thread on haskell-cafe about popen and the issues ivoleved
14:03:19 <dons> from decemer
14:04:25 <malebria> dons: I'll take a look.
14:04:51 <sjanssen> OS pipes have a maximum capacity, don't they?
14:05:13 <sjanssen> so a program writing to a pipe that isn't being read will block at some point
14:05:13 <dons> yeah
14:05:17 <dons> yep
14:05:23 <sjanssen> that is why the forkIO's are needed
14:05:33 <malebria> dons: But why did you chose runInteractiveProcess instead of runProcess?
14:05:52 <dons> http://www.cse.unsw.edu.au/~dons/code/newpopen/tests/Cat.hs
14:06:00 <dons> test case, sjanssen
14:06:09 <dons> malebria: legacy. it comes from a more general framework
14:06:35 <dons> malebria: here's a general replacement i've been working on, http://www.cse.unsw.edu.au/~dons/code/newpopen/
14:06:36 <lambdabot> Title: Index of /~dons/code/newpopen
14:06:52 <dons> it was in the context of this lib that the discussions came up on haskell-cafe@
14:06:57 <dons> or libraries@ (one of them)
14:07:42 <malebria> dons: this would make things much simpler...
14:08:47 <dons> why?
14:09:23 <malebria> dons: isn't this made to not need to use forkIOs and waitForProcess?
14:10:19 <dons> hmm, you still get Handles back
14:10:22 <dons> which you'll have to force
14:10:38 <dons> and ProcessHandle to wait on
14:11:28 <malebria> readProcess returns Either ExitCode String
14:11:44 <malebria> It treats the handles..
14:12:40 <dons> oh, you mean my readProcess. yeah. that's probably simpler
14:12:50 <dons> but its just the same code, wrapped up
14:12:57 <malebria> I just noticed that.
14:14:03 <malebria> But I still don't get why we need to wait for the handle to be read even using waitForProcess.
14:14:22 <malebria> I got the pipe maximum capacity thing sjanssen said, but how is this related?
14:14:40 <malebria> Is it to prevent ghci from writing too much?
14:14:59 <sjanssen> malebria: no, it's to ensure termination
14:15:15 * kolmodin has never been more tired. good night!
14:15:36 <malebria> sjanssen: is it because it's safer to wait for a MVar than to wait for the end of a process?
14:16:42 <NichardRixon> should there be a problem in Hugs if I try readFile a 1.3mb log?
14:16:47 <NichardRixon> ERROR - Garbage collection fails to reclaim sufficient space
14:16:47 <malebria> kolmodin: good night.
14:16:55 <sjanssen> say we're runProcessing this Haskell program: main = replicateM someHugeNumber (hPutChar 'x' stdout >> hPutChar 'x' stderr)
14:17:03 <dons> NichardRixon: yes. please use ghc for large data requirements
14:17:07 <NichardRixon> ah, ok
14:17:10 <dons> NichardRixon: in particular, I'd not use readFile at all
14:17:16 <NichardRixon> what would you use?
14:17:16 <dons> i'd use Data.ByteString.readFile
14:17:17 <sjanssen> that program will quickly fill up the pipe buffers
14:17:20 <NichardRixon> ok
14:17:20 <dons> (which may also work in hugs)
14:17:34 <sjanssen> so we need to demand the output to allow that program to terminate
14:18:02 <malebria> sjanssen: But we're just evaluating the output, getting it's length.
14:18:18 <NichardRixon> Undefined qualified variable "Data.ByteString.readFile"
14:18:29 <sjanssen> malebria: yes, evaluating the output's length is the same as demanding it
14:18:58 <dons> NichardRixon: yeah, in hugs bytestring works fine for > 2M at least
14:19:00 <dons> Data.ByteString> readFile "/usr/share/dict/words" >>= print . length
14:19:02 <dons> 2487232
14:19:07 <sjanssen> malebria: you do know that hGetContents is lazy, yeah?
14:19:08 <dons> in a fraction of a second
14:19:18 <dons> NichardRixon: ah maybe your hugs doesn't have fps?
14:19:19 <dons> ?where fps
14:19:19 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
14:19:20 <malebria> sjanssen: yes, I know... so this is to make it strict?
14:19:21 <dons> ^^ get it
14:19:26 <dons> malebria: yes
14:20:56 <dons> NichardRixon: let me know if you can't get it working. it should work quite well with a 1M file (i.e. trivial and fast)
14:20:58 <malebria> But what could happen if it's not strict? When we need the output the handle would already be closed and nothing will be read?
14:21:05 <dons> right
14:21:09 <NichardRixon> dons, ok, I'm just figuring out how to install this now
14:21:21 <dons> runhaskell Setup.hs configure --hugs --prefix=/my/home
14:21:23 <malebria> dons: but I'm using this version for a long time and it's working...
14:21:32 <sjanssen> and we have to read from stderr and stdout simultaneously, because one pipe could fill up causing the "executee" to block writing on that pipe while the "executer" blocks on the pipe that isn't being written
14:21:42 <dons> malebria: you'll only notice it if you try to read in data over a certai nsize
14:21:48 <dons> small strings you'll never notice
14:21:57 <malebria> hum..
14:22:09 <NichardRixon> what should /my/home be?
14:22:11 <dons> try the 'cat.hs' benchmark with your code
14:22:12 <glguy> dons: now that I've written basicAuth for the new HAppS API...
14:22:18 <glguy> dons: it's time to update hpaste :)
14:22:19 <dons> NichardRixon: well, where do you want to install the library?
14:22:25 <glguy> ?seen shapr
14:22:25 <NichardRixon> oh
14:22:25 <lambdabot> shapr is in #scannedinavian and #haskell. I last heard shapr speak 51m 25s ago.
14:22:26 <malebria> sjanssen: In readProcess just output is read.
14:22:34 <dons> NichardRixon: do you have root access? or install it as a local user?
14:22:41 <glguy> @tell shapr can you update HAppS on kakapo to darcs latest?
14:22:41 <lambdabot> Consider it noted.
14:22:49 <sjanssen> malebria: that sounds like a bug waiting to happen
14:22:50 <dons> malebria: yeah, that's a bug
14:22:52 <NichardRixon> Setup.hs: Cannot find compiler for ffihugs
14:23:02 <dons> the code is a partially written stub
14:23:08 <malebria> dons: the problem of the --vim option is that I was passing the options from typeOf to ghci.
14:23:18 <malebria> dons: so that users can specify -fglasgow-exts or -i...
14:23:26 <dons> NichardRixon: which hugs version do you have?
14:23:36 <sjanssen> malebria: users should put -fglasgow-exts in an OPTIONS_GHC pragma
14:23:47 <malebria> sjanssen: what about -i?
14:24:06 <sjanssen> I dunno
14:24:13 <malebria> This is another thing I don't understand very much. Which options can be in OPTIONS_GHC and which can not?
14:24:35 <NichardRixon> 20051031
14:24:44 <dons> ok. hmm. should work
14:24:47 <dons> that's the version I'm using
14:24:51 <huschi> how do you like the ghc error message "Expecting a function type, but found `w_a2DU'"?
14:24:52 <NichardRixon> should I have hugs in my path?
14:24:56 <NichardRixon> I just realized I don't
14:25:01 <dons> NichardRixon: yes!
14:25:04 <NichardRixon> I've just been using winhugs until now
14:25:15 <dons> huschi: sounds like a bug report :)
14:25:32 <huschi> dons: really.
14:25:33 <dons> huschi: since some internal desugarer symbol made it into the user error, by accident
14:25:49 <huschi> i should try to get it again.
14:25:52 <dons> I guess that's a tyvar inferred by the compiler
14:25:58 <dons> try adding a type annotation
14:26:20 <sjanssen> huschi: do you have a very large number of type variables in that expression?
14:26:32 <huschi> sjanssen: no. none.
14:26:34 <malebria> dons: isn't it better to leave type annotations as comments?
14:26:50 <dons> hmm. no!
14:26:53 <malebria> dons: Why?
14:27:06 <malebria> dons: Most of the cases they just make a function less general.
14:27:11 <malebria> dons: or they make nothing.
14:27:14 <dons> because if they're comments they're ignored. if they're explicit, they'll be machine checked
14:27:17 <NichardRixon> still can't find compiler for ffihugs :(
14:27:32 <dons> in this case its to improve error messages
14:27:35 <glguy> malebria: why not make your explicit type decls more generic
14:27:36 <dons> by naming a tyvar
14:27:40 <NichardRixon> nevermind
14:28:04 <malebria> glguy: If you don't use -fglasgow-exts, you can't write type declarations as general as the compiler infers them.
14:28:22 <huschi> i can't reproduce it a small program.
14:28:22 <dons> if you're going to put a type in a comment, you may as well put it in explicitly and have the comment machine checked
14:28:26 <glguy> malebria: if you depend on them being that generic, you should use -fglasgow-exts
14:28:31 <sjanssen> malebria: it's a very rare occasion that you can't write the typesig of a function
14:28:33 <dons> malebria: hmm??
14:28:45 <dons> you talking about rank-N types?
14:29:14 <huschi> oh. was wrong i could reproduce it.
14:29:54 <dons> its considered poor form not to write type decls for type level bindings anyway
14:29:58 <dons> since then your haddocks won't work either
14:30:14 <dons> we have a mechanism for machine checkeable documentation, its good to use it :)
14:30:20 <dons> s/top level/
14:30:20 <malebria> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021521.html
14:30:22 <lambdabot> Title: [Haskell-cafe] Type infer, http://tinyurl.com/2rdbk7
14:31:04 <NichardRixon> Setup.hs: Data\ByteString.hs: no cpphs (or GHC) preprocessor available
14:31:06 <NichardRixon> :(
14:31:15 <huschi> bla :: String -> String
14:31:15 <huschi> bla x = unwords $ [ ('#':) ]
14:31:19 <sjanssen> malebria: cases like this are quite rare
14:31:25 <dons> malebria: but that's an interaction with a -fglasgow-exts library
14:31:26 <huschi> this function brings the error.
14:31:45 <dons> hence the type requires -fglasgow-exts. This is the first such case of that, that I've seen
14:31:59 <malebria> My problem with writing them is because let's say I got a function with a type, and I annotate it's type. Then I change the function to a more general function, I'll have a less general function because of the anotated type.
14:32:04 <dons> [ ('#':) ]
14:32:09 <dons> huschi: ^^
14:32:13 <malebria> hm..
14:32:31 <dons> but you can annotate it with the more general type
14:32:37 <sjanssen> malebria: this is a potential problem.  Usually you insert your type signatures once you feel the code is stable
14:32:39 <dons> or use typeOf to infer the more general type.
14:32:55 <huschi> dons: i know it not type correct. i've got something similar and just forget the argument.
14:32:59 <malebria> Then I write another function and I infer the type, and annotate it. If I change the first function, and try to infer again, it'll not be as general as it could be because of the second function.
14:33:30 <malebria> Of course I'm talking about related functions.
14:33:51 <malebria> sjanssen: but then why not never use type signatures?
14:34:11 <dons> because you can't attach documentation to them. your type errors will be more obscure, and the code harder to understand
14:34:24 <sjanssen> malebria: to make sure that accidental modifications can't cause problems for clients of a module
14:34:56 <dons> yeah, if there are no type sigs at all, there's nothing to stop you changing the API completely, without realising it
14:34:58 <malebria> And what do you think about a situation where the infered type is very complex?
14:35:03 <emu> hmm, it seems stephen never incorporated the changes to allow haskell-mode to insert type-annotations
14:35:07 <dons> use a type synonym
14:35:10 <malebria> Should I simplify it to add a signature, or leave it very complex?
14:35:14 <dons> no
14:35:20 <dons> use a type synonym to name the complex part
14:35:39 <dons> recently I did :
14:35:40 <dons> type P a      = Ev PasteState Request a
14:35:41 <dons> type Paste    = P (Either Request String)
14:35:41 <dons> type PasteM m = P (Either Request (m Result))
14:35:51 <dons> so I could write types like:
14:35:51 <dons> handlePostNew :: Monad m => Chan PasteAnnounce -> () -> Request -> PasteM m
14:36:17 <malebria> glguy: "remember me" is nice now.
14:36:31 <dons> instead of:
14:36:32 <hpaste>  malebria pasted "types" at http://hpaste.org/130
14:36:33 <glguy> you made the original suggestion, right?
14:36:34 <dons> handlePostNew :: forall (m :: * -> *).  (Monad m) => Chan PasteAnnounce -> () -> Request -> Ev PasteState Request (Either Request (m Result))
14:36:42 <malebria> glguy: yes.
14:36:46 <glguy> malebria: thanks
14:36:47 <malebria> http://hpaste.org/130
14:36:52 <huschi> how can i search the bug database? i want to check whether the bug was already reported.
14:36:53 <malebria> glguy: I thank you.
14:37:02 <NichardRixon> dons: what does "Setup.hs: Data\ByteString.hs: no cpphs (or GHC) preprocessor available" mean?
14:37:04 <dons> ?bug <-- should have a search mechanism
14:37:04 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:37:11 <glguy> dons: I think you will like the way I'm implementing the new admin section now that I've added the functionality I needed to HAppS
14:37:17 <dons> NichardRixon: I think that means you have no ghc, nor cpphs on your machine
14:37:18 <glguy> much less of an afterthough / bolton
14:37:19 <malebria> dons: I'm using type sinonims.
14:37:22 <dons> you need cpp or cpphs, or ghc
14:37:23 <NichardRixon> I've got ghc 6.6
14:37:28 <dons> in your path?
14:37:39 <NichardRixon> well it found it several other places in the configure
14:37:47 <NichardRixon> configure: Using runghc found on system at: c:\ghc\ghc-6.6\bin\runghc.exe
14:37:56 <dons> for complex types, leaving the type sig off is asking for trouble, imo. since that's a complex api you need to maintain
14:38:03 <dons> for libraries, it would be critical
14:38:20 <malebria> dons: but my question was not about leaving it or adding it.
14:38:45 <dons> NichardRixon: is cpphs in your path?
14:38:47 <malebria> dons: it's about leaving it complex or simplifing it.
14:38:55 <Procyon> could someone peek at http://hpaste.org/131  I'm lost.  The error is at the end
14:38:57 <NichardRixon> dons, doesn't look like it
14:39:03 <dons> when you mean 'simplifying' do you mean, making it more monomorphic?
14:39:08 <dons> or just structurally simpler?
14:39:14 <dons> (as you get with type synonyms?)
14:39:15 <hpaste>  malebria annotated "types" with "Nested where" at http://hpaste.org/130#1
14:39:31 <dons> NichardRixon: could you perhaps install cpphs then?
14:39:32 <malebria> dons: making it more monomorphic.
14:39:33 <emu> Procyon: you haven't handled all cases in 'apply'
14:39:37 <dons> NichardRixon: but you've got ghc 6.6.
14:39:39 <dons> so just use that!
14:39:44 <dons> since it has bytestring already instealled
14:39:44 <NichardRixon> true
14:39:44 <Procyon> (Please critique lots.  I want stylistic tips in addition to fixing the bug)
14:39:47 <malebria> What do you think about this style of nested where clauses?
14:39:58 <dons> malebria: that seems the wrong thing to do
14:40:00 <malebria> These functions are only used by their parents.
14:40:05 <dons> why would you make it less polymorphic?
14:40:08 <Procyon> emu:  I'm not seeing what case I missed.
14:40:16 <malebria> dons: just for being more readable.
14:40:20 <emu> Int and Apply
14:40:29 <dons> but that changes functionality
14:40:48 <dons> I wouldn't do that. I'd just name the type signature (for the polymorphic one) with a synonym, if it wasn't readable
14:40:49 <emu> also i'd change that 'if' to a guard, personally, it's easier to read
14:40:58 <malebria> dons: that big thing pasted would become Set (Bool, Set (Int, Int)) -> Set (Bool, Set (Int, Int)) -> Set (Bool, Set (Int, Int))
14:41:10 <dons> which is begging for a synonym
14:41:14 <astrolabe> procyon: it is sometimes useful to turn up warnings when you compile.
14:41:18 <malebria> hum...
14:41:26 --- mode: ChanServ set +b *!*@ppp-69-236-158-230.dsl.pltn13.pacbell.net
14:41:27 <dons> type SetP = Set (Bool, Set (Int, Int))
14:41:34 <dons> SetP -> SetP -> SetP
14:41:49 <emu> why don't you write add (a:b:_) = instead of using !!
14:41:51 <Procyon> emu: ahh.  Int should never come up, or it's an error.  I can see apply (Apply) (Expr) needs to reduce it's first term
14:42:02 <malebria> About the nested where clauses, I always have doubt about this style decision.
14:42:09 <mbishop> I like how reddit is full of haskell links now :o
14:42:27 <Procyon> astrolabe: how do I do that, and can I do it when loading in ghci?
14:42:37 <Procyon> astrolabe: how do I do that, and can I do it when loading in ghci?
14:42:48 <emu> yes, -Wall
14:43:04 <emu> also :set -Wall should do it if you already started ghci
14:43:11 <astrolabe> Sorry, bad connection
14:43:46 <dons> mbishop: we need more high qualitiy ones though
14:43:56 <astrolabe> Procyon: your apply function doesn't seem to have a match for a value 'Apply Expr Expr'
14:44:06 <dons> "using monads and smp to take over the world" or something ;)
14:44:25 <emu> module SkyNet where
14:44:30 <dons> exactly
14:45:00 <sjanssen> malebria: you should consider denesting those where's :_
14:45:03 <sjanssen> :)
14:45:11 <astrolabe> Procyon: I don't know about ghci, but you could compile first to check
14:45:34 <malebria> sjanssen: denesting?
14:45:35 <astrolabe> I think the flag is -W, but I could be wrong.  Check the ghc docs
14:45:56 <bakert> How do you override the default behaviour of show and provide your own Thing -> String method for an ADT?
14:45:59 <sjanssen> malebria: break some of those off into top level functions, if possible
14:46:06 <bakert> just "where show x = ... " ?
14:46:11 <emu> bakert: don't derive Show.  instance Show Foo
14:46:18 <malebria> sjanssen: but they're only used by the parent's functions.
14:46:34 <bakert> emu, ah right.  "instance Show Foo where show x = ... " ???
14:46:38 <emu> yep
14:46:42 <malebria> sjanssen: I usually like this kind of code, but I haven't seem something like this is someone else's code.
14:46:43 <bakert> emu, thanks
14:46:43 <dons> bakert: newtype, and write an instance?
14:47:05 <bakert> dons, oooh clever.
14:47:13 <sjanssen> malebria: and do the nested functions really use variables from the outer functions?
14:47:21 <bakert> dons, that's a useful trick.
14:47:23 <astrolabe> Procyon: Also, in 'apply' you don't match 'Int Integer'.  Oh, you shouldn't use Int for a data constructor --- it is a built in type name.
14:47:44 <emu> constructors and type names are in different spaces though
14:48:14 <astrolabe> emu: I didn't know that, but it would confuse me anyway.
14:48:28 <astrolabe> Actually, I did know that :)
14:48:48 <sjanssen> bakert: it's generally a bad idea to override Show, it is best to write a separate function if you want pretty printing
14:48:58 <Procyon> I was using Expr_ tags on the constructors, but that got messy.
14:49:21 <astrolabe> Procyon: don't take my word as gospel.
14:49:27 <Procyon> annotated with fix and nicer add (a:b:_) notation.
14:50:38 <Procyon> It works now, although I'm not sure this is the best way to do this.  The parser returns Atoms even though the Evaluator just does lookups on them
14:51:10 <Procyon> I also don't know it breaking up Functions and Applications is the way to go... perhapse they are the same??
14:51:41 <malebria> sjanssen: no, they don't.
14:51:42 <bakert> sjanssen, i just want to lowercase the names.  still a separate function?
14:51:56 <malebria> sjanssen: do you think it's better to have nested functions only when there're common variables?
14:51:59 <Procyon> My brain just isn't thinking in haskell yet, so I'm really not confident in my code :-P
14:52:05 <sjanssen> malebria: I'd suggest flattening that out out
14:52:14 <sjanssen> just one "where" that holds all the internal functions
14:52:23 <malebria> hum..
14:52:34 <malebria> sjanssen: that's almost the same of have them all in top level.
14:53:43 <dons> you tend to get better code if you have you internal functions not too deeply nested
14:54:05 <dons> i rarely nest where clauses
14:54:06 <Procyon> That and I've never written an interpreter that handles partial evaluation.
14:54:18 <malebria> But then it's better to have them all in top level.
14:54:36 <dons> not really
14:54:40 <dons> since you want to keep the scoping
14:54:56 <dons> if they're really local to a particular top level function, there's no point making them top level
14:55:03 <malebria> Yes..
14:55:39 <malebria> And this conditions on the type infered are all related to the convertions I must make on the code (CDouble -> Double and others).
14:55:57 <malebria> Then it infers a lot of Real a or Fractional a because I used realToFrac
14:56:08 <malebria> Is there a better way to do conversions?
14:56:36 <dons> define a conversion function that is constrained to the types you wish to convert?
14:56:54 <dons> e.g. c2double :: CDouble -> Double ; c2double = real2frac
14:57:12 <Procyon> astrolabe: If I matched Int in apply, then all I could do is throw an error.  That's an illegal configuration for the tree.
14:57:43 <malebria> dons: this is what we were talking sooner, it makes it more monomorphic.
14:58:00 <dons> but that's what you just asked for!
14:58:11 <malebria> I asked for a better way to convert.
14:58:44 <dons> better in what way? I don't understand what the problem is here.
14:59:02 <dons> "09:52  malebria> Then it infers a lot of Real a or Fractional a because I used realToFrac"
14:59:02 <malebria> It would be good to have everything Real a, instead of some Real a (from Double -> CDouble) and some Fractional a (from CDouble -> Double).
14:59:04 <yaxu> are there any hsc users around? (haskell client for supercollider audio synthesis)
14:59:19 <dons> ok. so write c2double with a less constrained type
15:00:03 <malebria> But how could c2double be as generic as possible?
15:00:52 <dons> so on one hand you don't want it to be too generic? (Fractional b, Real a) => a -> b is too generic?
15:00:59 <dons> but CDouble -> Double is not generic enough?
15:01:07 <dons> is this a real problem? or are you just wondering?
15:01:45 <dons> if you really need a more constrained, yet still polymorphic, function over Fractionals (or Reals) you can happily write one
15:01:53 <malebria> I want it to be as generic as possible, and realToFrac is what's restricting...
15:03:29 <malebria> I would like to be more generic than (Fractional b, Real a) => a -> b
15:03:34 <dons> why does it need to be more generic? you seem to be using some very lowlevel code, so it will be difficult to wrie that to be very polymorphic.
15:03:43 <dons> how could it be more generic ?
15:03:45 <dons> a -> b ?
15:03:53 <dons> Num a , Num b => a -> b ?
15:04:32 <dons> what is the benefit? as you make things more abstract, there are less low level operations you can apply, since they break abstraction
15:05:51 <malebria> hum...
15:06:03 <malebria> I was wondering about Num a Num b
15:06:12 <dons> ?instances Num
15:06:13 <lambdabot> Double, Float, Int, Integer
15:06:19 <sjanssen> malebria: there aren't any instances of Fractional that aren't instances of Real
15:06:21 <malebria> things that can be converted from and to CDouble
15:06:46 <malebria> sjanssen: yes, that's why I'd like to have a more generic function.
15:07:09 <sjanssen> malebria: what is the type now?
15:07:37 <sjanssen> (Fractional b, Real a)=> a -> b?
15:07:40 <malebria> sjanssen: (Real a, Fractional b) => ...
15:07:42 <malebria> yes.
15:07:52 <malebria> Only because I use realToFrac
15:08:29 <sjanssen> this is the most polymorphic you can possibly get
15:09:19 <sjanssen> malebria: can you think of any concrete type you'd like to apply your function to that doesn't satisfy these constraints?
15:09:51 <malebria> sjanssen: Int
15:10:02 <malebria> I can convert Int to CDouble
15:10:12 <sjanssen> you can't convert CDouble to Int
15:10:12 <dons> > realToFrac (1 :: Int)
15:10:13 <lambdabot>  1.0
15:10:23 <sjanssen> you wanted both ways, right?
15:10:29 <malebria> sjanssen: yes, you're right.
15:10:36 <dons> you'd have to floor/truncate
15:10:49 <dons> since you're losing information
15:10:57 <malebria> yes, this is worse.
15:11:27 <dons> if you really wanted to cast CDoubles to Ints automatically, you coudl write a new class of your own, that encoded the rules for losing information
15:11:41 <dons> but it sounds like a dangerous thing to do
15:12:55 <malebria> yes, it's better to have a less polymorphic function.
15:14:22 <malebria> Is there a way to make the compiler give a warning if the type of the signature is not as generic as it could be?
15:14:36 <hpaste>  dons pasted "coerce, and lose informatoin" at http://hpaste.org/132
15:15:10 <sjanssen> dons: you probably don't want that fundep there
15:15:43 <sjanssen> you can't write "instance Coerce CDouble Double" and "instance CDouble Int" with it
15:16:01 <sorear> tell fodder
15:16:05 <dons> i tend to over constrain when hacking :)
15:16:15 <dons> sorear: why not ask for that in /msg ?
15:16:32 <dons> i.e. @messages :)
15:17:20 <malebria> It would be good to have a warning about not as generic as it could be types.
15:18:42 <sorear> dons: it doubles as announce-my-prescence :)
15:18:42 <malebria> Don't you think?
15:19:04 <heatsink> Graph library question: How come a self-edge is counted by the functions outdeg, suc, but not by indeg, pre?  For example, a node that only connects to itself has out degree 1 but in degree 0.
15:19:35 <emu> design decision
15:19:50 <astrolabe> seems odd
15:19:54 <emu> so you can add outdeg + indeg
15:19:59 <heatsink> Hm.  I'll have to work around it then.
15:20:05 <emu> it covers it in the paper somewhere
15:20:11 <nornagon> i want a quake-style ghci :P
15:20:16 <nornagon> quake console, that is
15:21:35 <Philippa> run a console window that does that and ghci in it?
15:21:49 <emu> ghci in quake?
15:22:10 <nornagon> Philippa: yeah, the first bit is the problem :P
15:22:12 <heatsink> malebria: Often you want a more-specific type though.  Personally I tend to make things too generic until I know what I don't need, then I make the type less generic.
15:22:12 <rahikkala> In frag?
15:22:42 <malebria> heatsink: hum..
15:23:26 * allbery_b initilly found himself envisioning an ide after the fashion of sysadmin doom...
15:26:27 <hpaste>  malebria pasted "Type error" at http://hpaste.org/133
15:26:55 <malebria> Now I see I don't know how to deal with types very much.
15:27:28 <heatsink> You don't need class constraints unless there's a free variable in the constraint.
15:27:54 <heatsink> so you can just say type Return = Set.Set (EnumClass, ....)
15:27:55 <sjanssen> malebria: those are not valid type synonyms
15:28:07 <malebria> =(
15:28:59 <sjanssen> your primary mistake is writing class constraints in those synonyms -- you can't do that
15:29:36 <musasabi> one can do a limeted form of that with GHC
15:29:36 <lambdabot> musasabi: You have 1 new message. '/msg lambdabot @messages' to read it.
15:29:52 <musasabi> *limited
15:30:41 <malebria> sjanssen: So I can't write a type synonym with class constraints?
15:31:19 <sjanssen> malebria: not in Haskell '98, musasabi says you can do a bit of it in ghc
15:31:32 <malebria> hum...
15:33:09 <musasabi> type Foo a = forall b. X b => Bar b a
15:33:48 <malebria> musasabi: thanks.
15:35:37 <heatsink> Is that existentially quantified?
15:36:29 <sorear> yes
15:36:55 <heatsink> interesting.
15:38:11 <musasabi> But something like "type Invalid a = Foo a => Bar a" is not allowed.
15:44:42 <malebria> Thanks for the chat.
15:45:04 <malebria> Good night.
15:58:22 <chessguy> 'evening, haskellers
15:58:44 <sorear> 'evening, chessguy
15:59:42 <Procyon> sorear++
16:04:14 <sorear> dylan: eh?
16:07:31 <sorear> dons: what happened to the bot earlier?
16:16:01 <chessguy> boy, #haskell's a happenin' place tonight
16:16:03 <dons> sorear: no idea
16:16:08 <dons> chessguy: you arrived late
16:16:12 <dons> it was far far too busy earlier
16:16:15 <mbishop> ?users
16:16:15 <lambdabot> Maximum users seen in #haskell: 322, currently: 296 (91.9%), active: 29 (9.8%)
16:16:25 <chessguy> figures
16:16:30 <chessguy> story of my life
16:16:36 <bakert> @localtime chessguy
16:16:37 <lambdabot> Local time for chessguy is Fri Jan 26 19:12:00
16:17:07 <bakert> the night is yet young
16:17:30 <chessguy> indeed, there's code yet to get written tonight
16:18:07 <sorear> @localtime dylan
16:18:09 <lambdabot> Local time for dylan is Fri Jan 26 19:14:23 2007
16:18:32 <bakert> So, error handling in Haskell.  I seem to have chains of Eithers going all the way up to the top where I either print the error message (Left) or the result (Right).  Is that normal?
16:19:01 <sorear> Either foo (Either bar (Either quux result)) ?
16:19:06 <bakert> no sorry
16:19:20 <bakert> i just mean chained through the functions.  probably threaded would be a better word.
16:19:24 <sorear> Either is good
16:19:33 <sorear> Make liberal use of the monad function
16:19:34 <sorear> s
16:19:40 <bakert> Right next to the db I am saying -> IO (Either String Account)
16:19:55 <bakert> then i pass that up through a few layers and in main or somewhere I print out errors or results.
16:20:10 <sorear> ooh.  if you're already using IO & sequencing, why not just throw exceptions?
16:20:13 <bakert> but it all seems a bit explicit.  lots of case statements in the intermediate levels and so on.
16:20:34 <bakert> sorear, probably because I don't know how!  I use catchSql in the db code.
16:20:48 <chessguy> @type error
16:20:50 <lambdabot> forall a. [Char] -> a
16:21:14 <sorear> bakert: Control.Exception.throw , Control.Exception.throwIO , Control.Exception.catch
16:21:16 <chessguy> err, not very revealing
16:21:17 <bakert> But then I want to do something with the error before it bubbles up to code that shouldn't know about databases.  So I return IO (Either String Account)
16:21:34 <bakert> sorear, thanks i'll check those out.
16:21:41 <sorear> bakert: there is a function that lets you modify errors
16:21:54 <sorear> @hoogle (Exception -> Exception) -> a -> a
16:21:55 <lambdabot> Control.Exception.mapException :: (Exception -> Exception) -> a -> a
16:22:02 <sorear> hoogle++
16:22:15 <sorear> would never have remembered that name
16:23:02 <bakert> So if you had a piece of code that got an "Account" from the database, you'd just have it -> IO Account
16:23:15 <sorear> yes
16:23:22 <bakert> Skip the Either and do some exception handling nearer the surface.
16:23:26 <sorear> yes
16:23:44 <bakert> yeah, i kind of figured but i was getting it working before.  now it works I want it to be better!
16:43:45 <dylan> sorear: Hey dude
16:46:06 <sorear> dylan: what kind of bug do you think you found?
16:46:34 <sorear> also, the lambdabot that took your message is not the lambdabot that is in #haskell now :(
16:46:37 <dylan> sorear: in urxvt, the char (0,0) is always empty
16:46:59 <dylan> when I run it inside screen, it's fine.
16:47:18 <sorear> fun
16:47:32 <dylan> I have a compile-able test case, if you like.
16:47:49 <sorear> sigh ... I expected sticking to ANSI meant I *wouldn't* have to deal with all these broken terminals ...
16:48:06 <dylan> urxvt is a really not-broken one, too.
16:48:29 <dylan> I use it because it is the least broken utf8 terminal.
16:48:38 <sorear> least broken?
16:48:39 <mbishop> I need to learn my types better...I know enough haskell to get the code to be right, but it clearly isn't right...because it always has type errors :/
16:48:46 * sorear stares in fear
16:48:57 <dylan> least broken.
16:48:59 <Excedrin> dylan: do you know how to disable or change the urxvt "enter special character" hotkey offhand?
16:49:02 <SamB> mbishop: what did you think type-errors were for?
16:49:10 <bd_> Excedrin: I think it's a compile option :/
16:49:12 <dylan> Excedrin: No, but I'd love to find out how.
16:49:47 <sorear> I've only tested vty in linuxconsole and minimally in Xorg xterm.
16:50:09 <sorear> I understand Jean-Phillipe Bernardy is using gnome-terminal
16:50:16 <bd_> might be --enable-iso14755 and --enable-frills (well, disable anyway)
16:50:17 <dylan> well, it does work fine in screen, but it's a show-stopper.
16:50:17 <mbishop> SamB: well I'm GLAD it gives an error, problem is I don't know how to fix the errors :/
16:50:28 <mbishop> which is why I need to learn my types better :\
16:50:29 <SamB> mbishop: ... oh
16:50:42 <sorear> dylan: does the UTF8 support in vty work?
16:50:52 <dylan> sorear: heaven't tried yet.
16:51:07 <dylan> bd_: make with the typing japanese into haver-client.
16:51:18 <chessguy> that's it. i'm writing a program on the level i can handle. tic-tac-toe, here i come!
16:51:22 <bd_> dylan: kay
16:51:34 * sorear installs urxvt
16:51:44 <bd_> fails completely
16:51:49 <bd_> konsole -> ssh -> screen
16:51:54 <bd_> utf8 locale
16:52:31 <dylan> I wonder why.
16:53:25 <Excedrin> oh wow, urxvt has searchable scrollback via M-s
16:53:47 <sorear> dylan: what's the debian package for urxvt called?
16:54:07 <Excedrin> rxvt-unicode maybe
16:54:20 <dylan> rxvt-unicode
16:54:59 <sorear> now installing ...
16:55:18 <sorear> I wish I didn't have to install every terminal emulator on the planet :(
16:56:11 <dons> Lemmih: it'd be nice to avoid the neWord# test for 0# going to Bool, wouldn't it
16:56:20 <dons> esp when we immediately reutrn 0# word anyway
16:57:12 <dons> Lemmih: hmm??          GHC.Base.False -> __word 3; GHC.Base.True -> __word 1
16:57:15 <dons> 3 / 1 ?
16:57:19 <sorear> yow!
16:57:26 <sorear> + on gnome-terminal
16:57:33 <sorear> Will use 246MB of disk space
16:59:51 <dylan> most of that is gnome-terminal
17:00:05 <chessguy> @yow!
17:00:05 <lambdabot> Are we having fun yet?
17:01:01 <chessguy> ?where yaht
17:01:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
17:02:53 <chessguy> ?hoogle loop
17:02:54 <lambdabot> Control.Arrow.loop :: ArrowLoop a => a (b, d) (c, d) -> a b c
17:02:54 <lambdabot> Data.Graph.Inductive.Example.loop :: Gr Char ()
17:02:54 <lambdabot> Data.Graph.Inductive.Example.loop' :: IO (SGr Char ())
17:03:15 <dons> mm, hackage is starting to look good, http://hackage.haskell.org/cgi-bin/hackage-scripts/recent-additions
17:03:18 <lambdabot> Title: HackageDB: recent additions, http://tinyurl.com/youl22
17:03:31 <Daveman> Hi Chessguy :)
17:03:39 <chessguy> yp
17:03:43 <chessguy> yo
17:04:14 <emu> how's hs-plugins coming
17:05:03 <dons> robreim's been hacking way at it
17:05:10 <emu> cool
17:06:33 <sorear> I'm a library maintainer ... should I get a hackage upload account?
17:07:56 <dons> if you have things to upload. though it might be easier to just pass me the url of a valid tarball that passes the 'check' phase
17:08:01 <dons> if you want stuff uploaded today
17:08:37 <NichardRixon> what is this "cl" that ffihugs.bat calls?
17:08:39 <NichardRixon> I can't figure it out
17:09:00 <sorear> NichardRixon: the MS C Compiler
17:09:07 <NichardRixon> oh, hrm
17:09:18 <NichardRixon> is there any way to make it use gcc instead?
17:09:19 <sorear> command line Visual C
17:10:00 <sorear> dylan: yow.  just checked urxvt ... very badly incompatibly with vty.  must check further.
17:10:32 <sorear> dylan: 2.1 plan is TERM support for bug avoidance - sounds useful here ...
17:10:46 <sorear> (currently there is *no* term specific dispatch)
17:11:36 <NichardRixon> wtf, I thought ghc had ByteString built in :(
17:12:04 <sorear> NichardRixon: ghc --version
17:12:22 <NichardRixon> 6.6
17:12:28 <sorear> NichardRixon: ghc has almost nothing built in, you need base for everything
17:12:33 <NichardRixon> oh
17:12:41 <sorear> NichardRixon: you don't have base ?!
17:12:47 <NichardRixon> I... don't know?
17:13:04 <Excedrin> I haven't played with TV+Phooey, does the "output" area update immediately as the user adds input?
17:13:46 <NichardRixon> sorear, there's an /imports/Data/ByteString folder
17:13:46 <dylan> sorear: wouldn't termcap be easier?
17:14:02 <NichardRixon> and ByteString.hi
17:14:13 <NichardRixon> hrm, maybe I need to import this :o
17:14:34 <dons> import Data.ByteString :)
17:14:40 <NichardRixon> yeah, I just figured that out :D
17:15:20 <NichardRixon> argh, now I have to qualify a bunch of stuff with List because it's all ambiguous :(
17:15:27 <dons> nope. go the other way
17:15:31 <NichardRixon> oh?
17:15:34 <dons> import qualified Data.ByteString as B
17:15:36 <dons> B.readFile
17:15:38 <NichardRixon> aha
17:15:38 <NichardRixon> thanks
17:16:23 <sorear> dylan: If I ever find the person who decided to add alternate-screen support to the Debian xterm termcap entry, I will make an effort to not come within arm's reach of him ...
17:18:30 <dylan> sorear: why?
17:20:54 <sorear> I consider the decision ... massively idiotic.
17:22:23 <dylan> why? doesn't xterm support alternate-screen?
17:23:13 <newsham> yay, binary serialization!
17:23:28 <sorear> I really want my screen to clear after editing a file full of copyable text, yes.
17:23:59 <sorear> there are a lot of things I consider stupid in /etc/terminfo.whatever
17:24:21 <dylan> my vim copies selections to x11, so..
17:24:39 <newsham> yay automatic derivation of Binary
17:24:52 <sorear> dylan: haha, urxvt doesn't even support ^[%G ! (reading source)
17:25:09 <dylan> sorear: what's that?
17:25:10 <sorear> (the xterm/linux standard for enable utf8)
17:25:15 <dylan> ah.
17:25:44 <sorear> I presume with urxvt utf8 is always enabled?
17:25:48 <dons> newsham: yeah, via two mechainsms, syb in ghci, or using DriFT
17:26:09 <dons> newsham: if you play with it, i'd welcome any feedback
17:26:10 <dylan> well, urxvt works best with the utf8 text I deal with. :-/
17:26:13 <sorear> Curiously, I see raw multibyte sequences in my testing.
17:26:35 <newsham> hmm.. last i used DriFT it couldnt parse some stuff (was using records)
17:26:35 <sorear> does urxvt require me to set some arcane environment variable for UTF8 support?
17:27:00 <dylan> how would rxvt know when env var a program running in it says?
17:27:04 <newsham> is drift more mature now?
17:27:47 <newsham> hey, new version of drift released
17:28:49 <chessguy> when i do ":l Foo" in haskell, how does it know what file to find it in?
17:28:57 <sorear> Foo.hs
17:29:09 <sorear> I think there's a search path...
17:29:09 <chessguy> and if there is no Foo.hs?
17:29:12 <sorear> -i
17:29:23 <sorear> chessguy: then it fails :)
17:29:31 <emu> and hierarchical modules are under a dir hierarchy
17:29:35 <sorear> :set -v
17:30:57 <newsham> so i've been looking at lispm's lately..  how come there's no cool integrated haskell environment like lispm and squeak have? ;-)
17:30:57 <chessguy> hm, so it *must* be in Foo.hs
17:31:00 <chessguy> that's kind of annoying
17:31:22 <sorear> dylan: are the urxvt sequences documented anywhere beside src/command.C ?
17:32:10 <emu> newsham: mm, yi is begging to be turned into one
17:32:19 <newsham> yi?
17:32:26 <emu> @where yi
17:32:27 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
17:32:27 <bd_> newsham: vi clone in haskell
17:32:41 <newsham> interesting.
17:33:08 <newsham> i like vi and all, but.. cursor addressed terminals are so 1980.
17:33:15 <NichardRixon> dons, wow, ByteString is so fast :D
17:33:26 <sorear> newsham: gvim!
17:33:44 <emu> newsham: there's a nice paper detailing the hs-plugins based architecture of it which is worth examining
17:34:06 <newsham> cool, downloading now
17:34:27 <emu> yi is a vi clone only insofar as that was what was emulated
17:34:29 <chessguy> is there a haskell interface to curses?
17:34:36 <emu> yes, yi uses it
17:34:44 <chessguy> where might i find it
17:34:50 <emu> @where hscurses
17:34:50 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
17:34:56 <chessguy> ty
17:35:19 <dylan> vty is better than curses. ;)
17:35:53 <newsham> i think i'd be interesting seeing a system built from the blit on up.
17:35:56 <dons> NichardRixon: your program runs faster now? :)
17:36:04 <sorear> newsham: ooh, like the amiga? :p
17:36:17 <newsham> *cough*
17:36:21 <newsham> not quite
17:36:55 <sorear> emu: yi *used* to use it ... about two weeks ago Jean-Phillipe Bernardy rewrote the UI layer to use vty.
17:36:59 <dylan> newsham: I'll use gui-only apps when they can all be used without a mouse. :)
17:37:37 <newsham> sorear: more like the CADR, genera, or www.squeak.org
17:37:38 <sorear> I agree with dylan ... but I prefer linux's handling of virtual consoles over ion's enough to mostly use the former :(
17:38:41 <dylan> I use dwm solely to have virtical splits.
17:39:26 <dylan> vertical splits are required when you have a wide-screen display.
17:39:44 <emu> it would be good to demonstrate the a statically typed system can have the same interactive capabilities and environment that a dynamically typed language can have
17:39:57 <sorear> dylan: ion has vertical splits too
17:40:10 <dylan> sorear: yes, but they shrink when in grid mode.
17:40:20 <mbishop> ratpoison has vertical splits
17:40:28 <sorear> what's grid mode?
17:40:31 <dylan> ratpoison doesn't have floating windows.
17:40:40 <emu> yea everything is maximized
17:40:49 <dylan> sorear: well, when I have four termins in a grid formation, weird things happen when I resize them
17:40:50 <mbishop> that's the way it should be :)
17:40:52 <emu> (which suits me)
17:41:01 * mbishop is waiting for a haskell wm
17:41:14 * dylan will rewrite dwm in haskell eventually.
17:41:19 * sorear wants a haskell ws
17:41:32 <sorear> wait .. dwm == dylan window manager ?!
17:41:37 <emu> the H window system
17:41:47 <dylan> No, dwm is dwm.suckless.org
17:42:07 <dylan> though technically I have diverged from dwm.suckless.org to such a degree I can't sync with its latest release.
17:42:11 <mbishop> dwm is from those plan9 loving freaks who made wmii
17:42:30 <dylan> my dwm has experimental dbus support....
17:42:52 <dylan> I think the dwm people would flip if they've seen the things I'm doing.
17:43:18 <mbishop> isn't that why they made dwm in the first place?
17:43:24 <mbishop> to get rid of all the fluff that made it into wmii
17:43:39 <Nafai> dylan: What are you doing with dbus?
17:43:44 <dylan> I dunno, I just like being able to pervert it to be perfect for me.
17:43:54 <dylan> Nafai: Right now, just updating the status text.
17:43:58 <NichardRixon> dons, yeah, it's instantaneous
17:44:05 <dylan> soon, all configution will be done via dbus.
17:44:08 <NichardRixon> in hugs, it would be several seconds :)
17:45:03 <NichardRixon> how come in B.map (\x -> B.snoc x ' '), ghc keeps telling me that 'x' is inferred as a char?
17:45:03 <Nafai> dylan: Cool.  I've been using dbus a bit in some of my programs lately
17:45:09 <mbishop> dylan: maybe if you didn't have to pervert it in C :P
17:45:10 <NichardRixon> I'm mapping over a bunch of bytestrings
17:45:25 <dylan> mbishop: If I had the time, I'd port it.
17:45:34 <dylan> mbishop: it's on my todo list, certainly.
17:46:35 <dylan> I can't quite go back to ion anymore, as I use tags a lot. :-/
17:46:42 <beschmi> NichardRixon: ByteString works with Word8, for Char you have to import Data.ByteString.Char8
17:47:00 <NichardRixon> beschmi, I already am
17:47:05 <dylan> (though the biggest problem with ion is the default keybindings)
17:48:28 <NichardRixon> I just can't figure out why the 'x' is inferred as a Char, when I'm mapping over a list of ByteStrings
17:49:12 <beschmi> B.map maps over a ByteString of Chars
17:49:21 <bd_> :t Data.ByteString.map
17:49:22 <lambdabot> (Word8 -> Word8) -> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
17:49:24 <bd_> :t Data.ByteString.Char8.map
17:49:26 <lambdabot> (Char -> Char) -> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
17:49:35 <dons> NichardRixon: ah, you're not using Data.ByteString.Char8
17:49:42 <dons> but note that snoc is pretty expensive!
17:49:51 <NichardRixon> oh :<
17:50:05 <dons> hmmmmm, does that even work? B.map (\x -> B.snoc x ' ')
17:50:09 <bd_> it shouldn't
17:50:11 <dons> doesn't look like it is properly typed?
17:50:16 <NichardRixon> why not?
17:50:17 <bd_> map can't change the bytestring length after all
17:50:21 <sorear> looks well typed to me!
17:50:22 <NichardRixon> hrm
17:50:26 <bd_> :t B.snoc
17:50:28 <lambdabot> Couldn't find qualified module.
17:50:32 <chessguy> !paste
17:50:32 <bd_> :t Data.ByteString.snoc
17:50:32 <hpaste> Haskell paste bin: http://hpaste.org/
17:50:34 <lambdabot> Data.ByteString.Base.ByteString -> Word8 -> Data.ByteString.Base.ByteString
17:50:34 <dons> sorear: hmm ?
17:50:43 <sorear> :t (\x -> Data.ByteString.snoc x 22)
17:50:44 <lambdabot> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
17:50:46 <NichardRixon> bd, it's Data.ByteString.Char8.snoc
17:50:52 <dons> sorear: B.map
17:50:58 <dons> :t Data.ByteString.map
17:51:00 <lambdabot> (Word8 -> Word8) -> Data.ByteString.Base.ByteString -> Data.ByteString.Base.ByteString
17:51:00 <bd_> :t Data.ByteString.Char8.snoc
17:51:01 <sorear> oh
17:51:02 <lambdabot> Data.ByteString.Base.ByteString -> Char -> Data.ByteString.Base.ByteString
17:51:05 <NichardRixon> dons, I'm just trying to add a space onto the end of each ByteString
17:51:09 <NichardRixon> Is there a better way to do that?
17:51:13 <sorear> I was only looking at the lambda part :)
17:51:18 <dons> ah ok. so you have a list of bytestrings?
17:51:18 <sorear> hey glguy!
17:51:22 <glguy> HEY!
17:51:29 <sorear> s/hey/hi/
17:51:30 <NichardRixon> dons, yeah, I just broke up one with B.words
17:51:41 <hpaste>  chessguy pasted "tictactoe" at http://hpaste.org/134
17:51:47 <dons> then map (\bs -> B.snoc bs ' ') (B.words xs)
17:51:52 <dons> not B.map
17:51:54 <NichardRixon> oh
17:51:57 <sorear> glguy: hpaste is unidentified
17:51:59 <chessguy> what's wrong with this? it doesn't like board1 = ...
17:52:05 <dons> you might be able to just intersperse ' ' though
17:52:06 <glguy> oops
17:52:08 <dons> and avoid the snoc
17:52:14 <NichardRixon> hrm
17:52:28 <NichardRixon> I was using B.intersperse, that might be why it was giving me problems before
17:53:00 <glguy> sorear: I started an actual admin section for hpaste
17:53:05 <dons> snoc won't be too bad on words though
17:53:20 <NichardRixon> argh, I don't understand why intersperse doesn't work :(
17:53:39 <dons> intersperse (singleton ' ')  (words x)
17:53:46 <ihope> What's a nice way to find the lowest non-negative integer not in a given list?
17:54:16 <NichardRixon> dons, what's singleton?
17:54:17 <dons> head . filter (< 0)  sort
17:54:26 <ihope> The mex, that is.
17:54:27 <dons> :t Data.ByteString.singleton
17:54:28 <lambdabot> Word8 -> Data.ByteString.Base.ByteString
17:54:32 <NichardRixon> oh :o
17:54:38 <dons> check the api docs
17:54:42 <NichardRixon> it works, thanks :)
17:56:48 <sorear> ihome: hmm. head . ([0..] \\) ?
17:57:00 <sorear> > head . ([0..] \\) $ [1,2,3]
17:57:02 <lambdabot>  0
17:57:06 <sorear> > head . ([0..] \\) $ [0,1,2,3]
17:57:07 <lambdabot>  4
17:57:11 <sorear> > head . ([0..] \\) $ [0,3,2,1]
17:57:13 <lambdabot>  4
17:57:17 <sorear> > head . ([0..] \\) $ [0,3,2,1,5]
17:57:18 <lambdabot>  4
17:57:23 <sorear> > head . ([0..] \\) $ [0,3,2,1,-2]
17:57:25 <lambdabot>  4
17:57:30 <ihope> > head . ([0..] \\) $ [6,2,7,9,0,2,6,1,3]
17:57:32 <lambdabot>  4
17:57:35 <ihope> Not bad.
17:57:43 <sorear> very slow, but nice :)
17:57:47 <NichardRixon> where's a good explanation for how the . syntax works?
17:57:54 <ihope> Is there anything faster?
17:58:04 <sorear> it's not syntax, it's a function! :)
17:58:04 <ihope> NichardRixon: (x . y) z = x (y z)
17:58:13 <NichardRixon> oh :o
17:58:18 <chessguy> .
17:58:18 <nornagon> :t (\\)
17:58:20 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
17:58:41 <ihope> I am sort of going after speed here.
17:58:52 <glguy> ?seen shapr
17:58:52 <nornagon> @src (\\)
17:58:53 <lambdabot> shapr is in #scannedinavian and #haskell. I last heard shapr speak 4h 27m 51s ago.
17:58:53 <lambdabot> (\\) = foldl (flip delete)
17:59:08 <glguy> @tell shapr could you update the HAppS library on kakapo?
17:59:09 <lambdabot> Consider it noted.
17:59:21 <nornagon> @src delete
17:59:22 <lambdabot> delete = deleteBy (==)
17:59:23 <newsham> ick.  somebody said BER/PER.
17:59:26 <nornagon> @src deleteBy
17:59:26 <lambdabot> Source not found. Just what do you think you're doing Dave?
17:59:57 <sorear> > ap zip . sort . filter (>= 0) $ [6,2,7,9,0,2,6,1,3]
17:59:58 <lambdabot>  Couldn't match `(->) [a]' against `[]'
18:00:05 <sorear> > ap zip tail . sort . filter (>= 0) $ [6,2,7,9,0,2,6,1,3]
18:00:07 <lambdabot>  [(0,1),(1,2),(2,2),(2,3),(3,6),(6,6),(6,7),(7,9)]
18:00:32 <sorear> > filter ((/=(-1)) . uncurry (-)) . ap zip tail . sort . filter (>= 0) $ [6,2,7,9,0,2,6,1,3]
18:00:34 <lambdabot>  [(2,2),(3,6),(6,6),(7,9)]
18:00:47 <sorear> > filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [6,2,7,9,0,2,6,1,3]
18:00:49 <lambdabot>  [(3,6),(7,9)]
18:01:02 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [6,2,7,9,0,2,6,1,3]
18:01:03 <lambdabot>  4
18:01:12 <sorear> ^^^ O(n log n) time
18:01:33 <ihope> Not bad at all, eh?
18:01:57 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ []
18:01:58 <lambdabot>  Exception: Prelude.head: empty list
18:02:03 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [1]
18:02:04 <lambdabot>  Exception: Prelude.head: empty list
18:02:07 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [1,2]
18:02:09 <lambdabot>  Exception: Prelude.head: empty list
18:02:13 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [1,2,3]
18:02:15 <lambdabot>  Exception: Prelude.head: empty list
18:02:17 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . map head . group . sort . filter (>= 0) $ [1,2,4]
18:02:18 <lambdabot>  3
18:02:30 <sorear> hmmm..
18:02:42 <ihope> That could be a problem.
18:03:01 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . ((-1):) . map head . group . sort . filter (>= 0) . (:999999) $ [1,2,4]
18:03:02 <lambdabot>   add an instance declaration for (Num [[a]])
18:03:07 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . ((-1):) . map head . group . sort . filter (>= 0) . (999999:) $ [1,2,4]
18:03:09 <lambdabot>  0
18:03:12 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . ((-1):) . map head . group . sort . filter (>= 0) . (999999:) $ [1,2,3]
18:03:14 <lambdabot>  0
18:03:18 <ihope> > group "Sheep Inn, a bubble sheet"
18:03:19 <lambdabot>  ["S","h","ee","p"," ","I","nn",","," ","a"," ","b","u","bb","l","e"," ","s",...
18:03:26 <sorear> > (+1) . fst . head . filter ((/=(-1)) . uncurry (-)) . ap zip tail . ((-1):) . map head . group . sort . filter (>= 0) . (999999:) $ [0,1,3,4]
18:03:28 <lambdabot>  2
18:03:28 <ihope> You can use nub for that, can't you?
18:03:38 <sorear> ihope: nub is O(n^2)
18:03:50 <ihope> Oh.
18:03:53 <sorear> map head . group . sort is O(n log n)
18:03:59 <ihope> I see,
18:04:37 <sorear> anyway my last version should work if all your numbers are smaller than 999999 :)
18:04:45 <ihope> Hmm...
18:04:57 <ihope> Why's it do that?
18:06:01 <ihope> You know, this map head . group . sort thing gives me sort of an idea. Sorted nubbing... well, that's pretty fancy stuff.
18:06:23 <sorear> ihope: IIRC it's in missingh ...
18:06:34 <sorear> dons: any thoughts on MissingH in @run ?
18:06:56 <ihope> MissingH?
18:07:26 <sorear> @where MissingH
18:07:27 <lambdabot> http://software.complete.org/missingh
18:08:27 <NichardRixon> is it possible to use ++ with ByteStrings?
18:08:43 <sorear> append iirc
18:08:56 <NichardRixon> oh
18:09:07 <sorear> NichardRixon: no. (++) *really* ought to be Monoid a => a -> a -> a , but isn't
18:09:14 <sorear> monomorphism--
18:09:55 <ihope> import Prelude hiding (++)
18:10:02 <ihope> That'll solve all your problems.
18:10:14 <sorear> import Prelude14
18:10:54 <ihope> Now, how's this: mex l = mex' 0 $ map head . group . sort $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n
18:11:20 <ihope> > let mex l = mex' 0 $ map head . group . sort $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n in mex [6,2,7,9,0,2,6,1,3]
18:11:22 <lambdabot>  4
18:12:33 <sorear> > let snub = map head . group . sort ; mex l = mex' 0 $ snub $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n in mex
18:12:34 <lambdabot>  Add a type signature
18:12:50 <sorear> > let snub :: Ord a => [a] -> [a] ; snub = map head . group . sort ; mex l = mex' 0 $ snub $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n in mex
18:12:52 <lambdabot>  Add a type signature
18:13:00 <sorear> MR--
18:13:18 <sorear> > let snub :: Ord a => [a] -> [a] ; snub = map head . group . sort ; mex l = mex' 0 $ snub $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n in mex [6,2,7,9,0,2,6,1,3]
18:13:20 <lambdabot>  4
18:17:13 <ihope> Now, can't map head . group be done better?
18:18:16 <dons> sounds like a groupBy ?
18:18:20 <dons> :t groupBy
18:18:21 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [[a]]
18:18:28 <dons> ah maybe not
18:18:46 <glguy> dons: if you darcs pull HAppS you'll need the latest HAppS
18:18:50 <dons> ok
18:18:55 <dons> hpaste you mean
18:19:00 <glguy> yeah, that
18:19:48 <glguy> I need to add a section to the readme explaining that you add your "username password" to the accounts.txt if you want to delete pastes
18:20:31 * ihope laughs evilly as he changes to a proportional font
18:20:39 <ihope> Hey, my guards don't line up!
18:21:20 * ihope does a ridiculous indentation hack
18:21:40 <ihope> Actually, it looks kinda nice this way
18:22:29 <ihope> > let snub :: Ord a => [a] -> [a] ; snub = map head . group . sort ; mex l = mex' 0 $ snub $ l; mex' n (x:xs) | n == x = mex' (n+1) xs; mex' n _ | otherwise = n in mex []
18:22:31 <lambdabot>  0
18:22:34 <ihope> How fun.
18:22:58 <chessguy> .woohoo
18:23:14 <chessguy> i think i have successfully come up with the most hideous implementation of tic-tac-toe imaginable
18:23:22 <ihope> chessguy: how nice.
18:23:31 * ihope attempts to create an elegant whatchamacallit
18:24:22 <chessguy> !paste
18:24:23 <hpaste> Haskell paste bin: http://hpaste.org/
18:24:33 <chessguy> well, i wanted it to be hideous, so i can refactor repeatedly :)
18:24:40 <ihope> And by whatchamacallit, I mean A002188.
18:24:58 <hpaste>  chessguy pasted "tictactoe" at http://hpaste.org/135
18:25:09 <chessguy> boo-yeah!
18:25:19 <mbishop> glguy: nice work on hpaste.org :)
18:25:48 <glguy> thanks, dons, sorear and Saizan all helped too
18:25:59 <ihope> chessguy: pff. Your program has to look like a tic-tac-toe board to work right, you know.
18:25:59 <glguy> shapr has been instrumental with HAppS and the server
18:26:08 <glguy> and bos31337 even donated the hostname
18:26:35 <ihope> A really big tic-tac-toe board, because the code will be made so small you can't see it. That's how coding works, isn't it?
18:26:52 * glguy remembers to also mention musasabi's help in understanding happs :)
18:26:53 <chessguy> ihope, that's one of the many many reasons it's so hideous :)
18:27:06 <ihope> The fact that it looks like a tic-tac-toe board?
18:27:40 <ihope> Also, what happened to readLine?
18:28:19 <sorear> ?
18:28:31 <sorear> :t System.Console.Readline.readline
18:28:33 <lambdabot> String -> IO (Maybe String)
18:28:38 <sorear> it's still there
18:29:00 <ihope> chessguy seems to be using liftM read getLine.
18:29:01 <chessguy> no, the fact that it DOESN'T look like a tic-tac-toe board
18:29:16 <chessguy> ihope, dude, the code's SUPPOSED to be bad
18:29:19 <ihope> chessguy: you mean programs are supposed to look like what they do?
18:29:23 <ihope> chessguy: well, yeah.
18:29:30 <chessguy> oh, the code?
18:29:38 <ihope> Yeah, the code.
18:29:51 <chessguy> looks like a tic-tac-toe board?
18:29:52 <newsham> you should have to drink each time the interviewer says "innovate" on channel9
18:29:55 <ihope> I said the code has to look like a tic-tac-toe board.
18:30:00 <chessguy> oh, lol
18:30:05 <chessguy> i mis-understood
18:30:09 <ihope> @hoogle ([a] -> a) -> [a]
18:30:10 <lambdabot> No matches, try a more general search
18:30:15 <chessguy> what's the difference between getLine and readLine?
18:30:17 <ihope> Still not there?
18:30:42 <ihope> chessguy: getLine gets "3" from the user and gives you "3". readLine gets "3" from the user and gives you 3.
18:30:50 <chessguy> ah
18:31:11 <chessguy> i ripped the basics of the front end off the guess-the-number thing in yaht
18:32:49 <chessguy> anyway, i want to go from...this....to a fully inter-active, curses-based, tournament-managing, variant-allowing tic-tac-toe game, complete with genetically evolved and otherwise artificially intelligent players
18:33:11 <ihope> Genetically evolved?
18:33:14 <chessguy> hmm, maybe with a web front-end too, or something
18:33:14 <ihope> It's tic-tac-toe.
18:33:47 <chessguy> yeah, my real interest is in applying genetic programming to chess
18:33:52 <chessguy> but i have to start somewhere
18:34:01 <ihope> You know, you really oughta be as clean as possible. No cruft, kipple or kludge.
18:34:26 <chessguy> huh?
18:34:26 <sorear> > 9^(3^9)
18:34:28 <lambdabot>  2266278581112553008814835871077874870685531150336951145099556930480608580627...
18:34:41 <chessguy> what's cruft, kipple, and kludge?
18:34:50 <chessguy> are you still speaking english?
18:34:50 <ihope> chessguy: yucky code.
18:34:59 <chessguy> oh it will be, eventually
18:35:09 <mbishop> cruft is a british word, if I'm not mistaken
18:35:23 * chessguy does 'cp TicTacToe.hs infant.hs'
18:35:24 <ihope> Cruft, kipple and kludge are pretty new words, or something. New in some sense, anyway.
18:35:30 <ihope> chessguy: :-)
18:35:51 <mbishop> kipple, no idea of it's origin, and kludge was sometimes spelled "kudge" or something like that, and typically means a dirty hack
18:36:22 <ihope> Cruft is a british word if mbishop's not mistaken, kipple was probably from some science fiction thing just like grok, and kludge was from some brand of printer or something.
18:36:25 <sorear> ?jargon cruft
18:36:27 <lambdabot> *** "cruft" jargon "Jargon File (4.3.1, 29 Jun 2001)"
18:36:27 <lambdabot> cruft /kruhft/ [very common; back-formation from {crufty}] 1. n. An
18:36:27 <lambdabot>    unpleasant substance. The dust that gathers under your bed is cruft; the
18:36:27 <lambdabot>    TMRC Dictionary correctly noted that attacking it with a broom only
18:36:27 <lambdabot>    produces more. 2. n. The results of shoddy construction. 3. vt. [from
18:36:28 <ihope> So in effect, I have no idea.
18:36:29 <lambdabot> [6 @more lines]
18:36:44 <sorear> @more
18:36:45 <lambdabot>    `hand cruft', pun on `hand craft'] To write assembler code for something
18:36:45 <lambdabot>    normally (and better) done by a compiler (see {hand-hacking}). 4. n.
18:36:45 <lambdabot>    Excess; superfluous junk; used esp. of redundant or superseded code. 5.
18:36:45 <lambdabot>    [University of Wisconsin] n. Cruft is to hackers as gaggle is to geese;
18:36:45 <lambdabot>    that is, at UW one properly says "a cruft of hackers".
18:36:47 <lambdabot>  
18:37:00 <chessguy> heh
18:37:08 <mbishop> I don't like the jargon files
18:37:08 <ihope> :-)
18:37:12 <chessguy> writing in haskell is the same as writing in assembler anyway, right? just ask the guys at microsoft
18:37:15 <mbishop> the ORIGINAL jargon files are good though
18:37:20 <mbishop> before ESR ruined them :/
18:37:24 <ihope> chessguy: it is?
18:37:26 <ihope> Hmm.
18:37:40 <chessguy> ihope, you gotta watch the channel9 video
18:37:44 <mbishop> Specifically, 'cruft' can mean redundant, old, or improperly written code which needs to be fixed, but tends to stick around. Large software projects invariably accumulate cruft. The concept can be compared to Philip K. Dick's idea of kipple.
18:37:59 <mbishop> yay wikipedia )
18:38:00 <ihope> Say, is there any completely non-portable library out there that gives access to all the Linux system calls nice and raw-ly?
18:38:01 <mbishop> :)
18:38:19 <sorear> glibc, man syscall
18:38:34 <ihope> And the word "kludge" was chosen because I couldn't think of another synonym. :-)
18:39:03 * ihope ponders his iterateList' function
18:40:08 * ihope ponders his new and improved iterateList' function
18:41:05 <mbishop> also, apparently cruft isn't british in origin, dunno where I heard that
18:41:05 <ihope> Oh, who needs pondering?
18:41:41 <xpika> when using gcc as a haskell backend is there any prerequisites to compilation apart from the added header files and libraries?
18:41:44 <ihope> > let iterateList f = iterate (iterateList' f) [f []]; iterateList' f xs = f xs : xs in iterateList' (\x -> sum x + 1)
18:41:45 <lambdabot>  Add a type signature
18:41:48 <ihope> ...
18:41:58 <xpika> Im getting erros such as  cannot convert âCapability*â to âStgClosure*â
18:41:58 <ihope> > let iterateList f = iterate (iterateList' f) [f []]; iterateList' f xs = f xs : xs in iterateList' (\x -> sum x + 1) :: [Integer]
18:41:59 <lambdabot>      Expecting a function type, but found `[Integer]'
18:41:59 <lambdabot>       Expected type: [I...
18:43:11 <ihope> > let iterateList f = iterate (iterateList' f) []; iterateList' f xs = f xs : xs in iterateList' (\x -> sum x + 1) :: [Integer]
18:43:12 <lambdabot>      Expecting a function type, but found `[Integer]'
18:43:12 <lambdabot>       Expected type: [I...
18:43:15 <ihope> Mmh.
18:43:31 <ihope> Oh, hmm.
18:43:36 <ihope> > let iterateList f = iterate (iterateList' f) []; iterateList' f xs = f xs : xs in iterateList (\x -> sum x + 1) :: [Integer]
18:43:38 <lambdabot>  Couldn't match `Integer' against `[a]'
18:43:48 <ihope> > let iterateList f = iterate (iterateList' f) []; iterateList' f xs = f xs : xs in iterateList (\x -> sum x + 1) :: [[Integer]]
18:43:49 <lambdabot>  [[],[1],[2,1],[4,2,1],[8,4,2,1],[16,8,4,2,1],[32,16,8,4,2,1],[64,32,16,8,4,2...
18:44:02 <ihope> Not bad. We just need to map head . tail it.
18:44:46 <sorear> what's it supposed to do?
18:44:52 <sorear> @users
18:44:52 <lambdabot> Maximum users seen in #haskell: 322, currently: 276 (85.7%), active: 27 (9.8%)
18:44:52 <ihope> > let iterateList f = map head $ iterate (iterateList' f) [f []]; iterateList' f xs = f xs : xs in iterateList (\x -> sum x + 1) :: [Integer]
18:44:54 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:45:45 <ihope> sorear: each element of the list is the function applied to the part of the list coming before said element.
18:46:04 <xpika> > map (2^) [1..]
18:46:05 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:46:09 <sorear> > scanl (flip (:)) "Hello World"
18:46:10 <araujo> hello
18:46:11 <lambdabot>  <[Char] -> [[Char]]>
18:46:18 <sorear> hello araujo
18:46:27 <sorear> > scanl (flip (:)) "" "Hello World"
18:46:28 <lambdabot>  ["","H","eH","leH","lleH","olleH"," olleH","W olleH","oW olleH","roW olleH",...
18:46:44 <ihope> sorear: scanl... hmm.
18:46:45 <araujo> hi there sorear :-)
18:46:52 <newsham> some valid points about monads being like asm programming on this ch9 thing
18:47:38 <xpika> > (tails.reverse) "Hello world"
18:47:40 <lambdabot>  ["dlrow olleH","lrow olleH","row olleH","ow olleH","w olleH"," olleH","olleH...
18:48:03 <ihope> sorear: also, I'm feeling a strong need to know what "sorear" means in Spanish...
18:48:07 <newsham> > map reverse $ (tails.reverse) "Hello world"
18:48:08 <lambdabot>  ["Hello world","Hello worl","Hello wor","Hello wo","Hello w","Hello ","Hello...
18:48:17 <sorear> > fix (map ((+1) . sum) . tail . scanl (flip (:)) "" . (1:))
18:48:18 <lambdabot>   add an instance declaration for (Num Char)
18:48:22 <sorear> > fix (map ((+1) . sum) . tail . scanl (flip (:)) [] . (1:))
18:48:24 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:48:31 <sorear> HAH!
18:48:37 <heatsink> do they have transcripts?
18:48:46 <newsham> > iterate (* 2) 2
18:48:48 <lambdabot>  [2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,262...
18:48:50 <NichardRixon> >:t fix
18:48:54 <NichardRixon> eh
18:48:55 <NichardRixon> :t fix
18:48:56 <lambdabot> forall a. (a -> a) -> a
18:49:21 <ihope> > let iterateList f = map head $ iterate (iterateList' f) [f []]; iterateList' f xs = f xs : xs in iterateList (\x -> product x + 1) :: [Integer]
18:49:23 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
18:49:42 <ihope> sorear: now see if you can translate that into... uh, that.
18:49:57 <sorear> > let iterateList f = fix (map (f . reverse) . tail . scanl (flip (:)) [] . (1:)) in iterateList (\x -> product x + 1)
18:49:59 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
18:50:27 <ihope> I take it that's more efficient, then.
18:50:29 <sorear> > let iterateList f = fix (map (f . reverse) . scanl (flip (:)) []) in iterateList (\x -> product x + 1)
18:50:30 <lambdabot>  [2,3,7,43,1807,3263443,10650056950807,113423713055421844361000443,1286493868...
18:50:47 <xpika> can ghc itself compile c--?
18:50:50 <ihope> Erm, I mean, uh.
18:51:27 <sorear> ihope: without memoization (read: mapAccumL) it's O(n^2) for anything serious.
18:51:42 <ihope> Am I sounding rude at all? The phrase "I take it" seems to be stuck in my mind recently.
18:52:06 <sorear> I failed to perceive rudeness
18:52:09 <chessguy> @type take
18:52:11 <lambdabot> forall a. Int -> [a] -> [a]
18:52:17 <chessguy> doesn't look rude
18:52:31 <sorear> <-- is *very* bad at identifying things like rudeness, esp. in his own speech
18:52:34 <xpika>  " I take it" :: Attitude
18:52:43 * glguy won't be speaking to ihope any longer
18:52:59 <sorear> instance IsString Attitude, whow
18:53:52 <chessguy> @type getLine
18:53:53 <lambdabot> IO String
18:53:56 <chessguy> @type readLine
18:53:57 <lambdabot> Not in scope: `readLine'
18:54:04 <chessguy> @hoogle readLine
18:54:04 <lambdabot> System.Console.Readline :: module
18:54:04 <lambdabot> System.Console.Readline.readline :: String -> IO (Maybe String)
18:54:04 <lambdabot> System.Console.Readline.setReadlineName :: String -> IO ()
18:54:38 <chessguy> huh? readline takes a string?
18:55:10 <heatsink> It might be a prompt.
18:55:19 <sorear> it is
18:55:29 <sorear> readline "lambdabot> "
18:55:35 <chessguy> aha
18:55:41 <sorear> ^^ from a piece of code I've seen
18:56:04 <newsham> what is this lambdabot of which you speak?
18:56:25 <chessguy> ?remember newsham what is this lambdabot of which you speak?
18:56:25 <lambdabot> Done.
18:56:33 <sorear> it's a multifunction multiprotocol haskell helper
18:57:56 <chessguy> ?wiki TicTacToe
18:57:57 <lambdabot> http://www.haskell.org/haskellwiki/TicTacToe
19:06:05 <RobHu> Is there anyone here who did the ICFP contest 06? I am trying to make a UM implementation, and I am sure I am decoding the operators incorrectly. For sandmark for me it starts 0,3,13,13,13,13,12 :(
19:07:46 <RobHu> In fact I get the same opcodes when running the codex!
19:08:24 <dons> RobHu: yeah, several did
19:08:30 <dons> we even have a page up, let me find it
19:08:36 <RobHu> dons: Thankyou :)
19:08:43 <dons> ah, here, http://www.cse.unsw.edu.au/~dons/um.html
19:08:43 <lambdabot> Title: Haskell UM
19:08:45 <dons> lots of UMs!
19:11:19 <heatsink> um...
19:13:17 <Nafai> I'm working on an UM implementation right now! :)
19:13:36 <Nafai> In python, though...writing it first in Python to understand the problem
19:14:15 <dons> it'd be interesting to see if you can get good performance out of it.
19:14:24 <chessguy> woohoo! TicTacToe is born!
19:14:25 <chessguy> http://www.haskell.org/haskellwiki/TicTacToe
19:14:27 <lambdabot> Title: TicTacToe - HaskellWiki
19:14:32 <Nafai> Doubt it :)
19:14:38 <dons> this was a particularly hard problem in haskell, as you really need raw access to memory
19:14:42 <chessguy> (naughts and crosses for those of you across the pond)
19:14:46 <dons> i should have a go using ffi stuff
19:15:11 <dons> chessguy: is it in 'Categories : Code' ?
19:15:16 <Nafai> Yeah, I'm still unsure of the best way to represent things
19:15:21 <dons> yeah, please categorise it, chessguy
19:15:27 <dons> Nafai: as low level as possible :)
19:15:28 <chessguy> umm, no. i don't know if it qualifies as real code yet :)
19:15:30 <chessguy> but ok
19:15:31 <dons> check the um page above for ideas
19:15:53 <dons> needs some refactoring , chessguy ! :)
19:15:57 <dons> too much copy and paste
19:16:13 <dons> chessguy: hmm, you need a TicTacToe monad!
19:16:15 * dons rolls one up
19:16:17 <chessguy> dons, that's the point
19:16:19 <chessguy> noooo!
19:16:22 <chessguy> i wanna do it
19:16:32 <dons> hehe ok
19:16:38 <dons> we'll i want to roll one too :)
19:16:46 <dons> you should reddit this when you're done, and its down to 15 chars
19:17:09 <chessguy> you didn't look at the features list, did you?
19:17:17 <dons>  curses-based interface
19:17:20 <dons>  web interface
19:17:27 <dons>  genetically-evolved players
19:17:28 <dons> :}
19:17:39 <chessguy> it'll be at least 40 characters
19:17:46 <dons> the world most over engineered tictactoe game? :)
19:18:06 <sorear> yea ... I couldn't get my theorem prover down below 590 :(
19:18:08 <chessguy> well, i really want to play with AI in chess using haskell, but i'm not there yet
19:18:29 <chessguy> so this is a way to get there, and have fun in the process
19:18:37 <dons> good idea!
19:18:53 <chessguy> and hopefully it will be useful to others as well
19:19:12 <mbishop> chess ai is a pretty tired subject, but then, I'm sure it's fun to learn
19:19:24 <mbishop> the challenge comes in trying to make a really efficient Go playing program :P
19:19:32 <chessguy> mbishop, that's only because everyone tries to do it the same way
19:19:54 <sorear> I want to make a AI program that just happens to be able to play chess.
19:19:56 <mbishop> not really, it's just that no matter the way, you can usually come up with the "winning forumula"
19:20:16 * JKnecht suddenly remembers to finish "behind deep blue"
19:20:25 <chessguy> winning formula?
19:20:27 <mbishop> Or like in GEB, the chess program that "jumps out" when it realises a stalemate, rather than checking over and over
19:22:11 <mbishop> A program to play chess is nice, but a program that is smart enough to know when it's lost is interesting :)
19:22:22 <chessguy> by the way, you realize the best explanation i've seen for the 'solution' to tic-tac-toe is like 10 lines of english
19:22:37 <chessguy> lots of programs know how to resign
19:22:45 <nornagon> @hoogle Char -> Char
19:22:47 <lambdabot> Char.toLower :: Char -> Char
19:22:47 <lambdabot> Char.toUpper :: Char -> Char
19:22:54 <nornagon> is there one that swaps case
19:22:54 <nornagon> ?
19:24:25 <nornagon> i guess (\x -> if isUpper x then toLower x else toUpper x)
19:29:51 <chessguy> dons, does a TicTacToe monad even make sense?
19:30:00 <dons> yeah
19:30:06 <dons> since you want to carry the board state around
19:30:12 <dons> and not thread it explicitly as you do currently
19:30:17 <dons> with the let b1 = ... b0
19:30:20 <dons> et b2 = ... b1
19:30:23 <dons> that's a state monad!
19:30:54 <nornagon> :t sequence
19:30:56 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
19:31:33 <nornagon> ichar c = (char c) <|> (char $ swapcase c) -- how do i define istring in terms of this?
19:33:33 <hpaste> you there?
19:33:54 <hpaste> test
19:35:41 <chessguy> hpaste,
19:35:42 <chessguy> hi
19:35:52 <dons> http://programming.reddit.com/info/115js/details
19:35:54 <dons> upmod!! :)
19:35:54 <lambdabot> Title: hpaste: online Haskell pastebin in 400 lines (reddit.com)
19:36:20 <glguy> lol, I'm going to wagger on 90% of the comments saying that 400 lines is too much
19:36:28 <dons> hehe
19:36:38 <xpika> what is the date today?
19:36:54 <dons> ?google what is the date today?
19:36:57 <lambdabot> http://www.ecben.net/calendar.shtml
19:36:57 <lambdabot> Title: Today Date and Time
19:41:29 <sorear> glguy: shoult the main page link to the admin functions?
19:41:45 <dons> nah
19:41:47 <glguy> sorear: probably not?
19:42:36 <sorear> ok
19:43:32 <sorear> dons: you still writing hpaste-client? if no, I'll do it
19:43:42 <dons> go for it
19:47:26 <chessguy> hpaste client?
19:47:53 <sorear> yeah!
19:48:16 <chessguy> you mean something to use instead of pasting to the browser
19:48:50 <sorear> yes
19:49:03 <sorear> dons: what is the preferred http lib atm?
19:49:07 <chessguy> doesn't seem like much point there
19:50:31 <dons> sure there is
19:50:34 <dons> darcs push A.hs
19:50:39 <dons> would do a paste!
19:50:52 <dons> having to go to my browswer is irritating
19:51:05 <dons> sorear: how about 'http' ?
19:51:06 <sorear> I was thinking more of FUSE...
19:51:11 <sorear> @where http
19:51:11 <lambdabot> http://www.haskell.org/http/
19:51:13 <dons> not portable
19:51:56 <dons> think darcs-ish, or at the minimum a 'paste-put A.hs' 'paste-get n'
19:52:02 <dons> command line tool i could call from vim
19:52:15 <dons> and paste annotate n Foo.hs
19:53:11 <glguy> does Haskell have an library functions for file watchers?
19:53:23 <glguy> (callbacks for filesystem events)
19:53:27 <sorear> @where hinotify
19:53:28 <lambdabot> http://haskell.org/~kolmodin/code/hinotify/
19:53:28 <sorear> yes
19:53:41 <dons> linux only though, again
19:54:07 <glguy> that's fine... but that could be a way for hpaste to interact with darcs...
19:54:30 <csci> Anyone having experience with Gtk2Hs? I've created a(nother) window which should block execution till some button is clicked (don't want to use a dialog). How do I do this (have not found any examples in gtk2hs itself or on the net)
19:54:35 <sorear> glguy: how does FUSE sound? muahahaha
19:54:55 <glguy> sorear: sounds like someone I don't know about
19:54:58 <glguy> ting*
19:55:00 <glguy> thing*
19:55:23 <sorear> glguy: HFUSE --> write linux filesystem drivers in haskell.
19:55:40 <sorear> vi ~/hpaste/33
19:56:08 <sorear> I think more like ~/hpaste/'subject', actually
19:56:12 <sorear> paste-on-close
19:56:28 <sorear> once created, files are RO
19:56:40 <glguy> interesting
19:57:04 <sorear> with special mount options, rm ~/hpaste/'Cheap Vicodin Now' or whatever
19:58:22 <sorear> I just accidentally C-u 1300000 n ... emacs is suprisingly fast on megabyte lines :/
20:00:18 <sorear> How do I fix Bot (??,18) ... the offending text is gone ...
20:17:00 <sorear> diff(Procyon,|Procyon|) = ?
20:17:23 <sorear> a uniqify convention I'ven't seen before?
20:19:10 <chessguy> hmmm, dons has a "simple state example" on the wiki that doesn't work
20:19:20 <dons> yeah?
20:19:26 <dons> urly?
20:19:27 <chessguy> http://www.haskell.org/haskellwiki/Simple_StateT_use
20:19:29 <lambdabot> Title: Simple StateT use - HaskellWiki
20:19:57 <dons> can you paste the non-working-ness?
20:20:00 <chessguy>  Ambiguous type variable `m' in the constraint:
20:20:00 <chessguy>       `MonadIO m' arising from use of `liftIO' at SimpleState.hs:26:5-10
20:20:00 <chessguy>     Possible cause: the monomorphism restriction
20:20:01 <dons> ?paste <--
20:20:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:20:10 <chessguy> sorry
20:20:11 <dons> hmm
20:20:22 <dons> ah, the type for 'io'
20:20:45 <sorear> MR--
20:20:48 <sorear> @karma MR
20:20:49 <lambdabot> MR has a karma of -2
20:20:50 <dons> hmm . works here..
20:20:53 <dons> you got ghc 6.6?
20:20:57 <chessguy> yes
20:21:16 <dons> $ ghci A.hs
20:21:17 <dons> *Main> :t io
20:21:17 <dons> io :: IO a -> StateT [Integer] IO a
20:21:25 <dons> can't reproduce it. more info please.
20:21:47 <chessguy> hmm
20:22:16 <chessguy> you're not running ghc with -fno-monomorphism-restriction by default or something?
20:22:47 <dons> nope
20:23:00 <chessguy> weird
20:23:18 <chessguy> i can pastebin the whole session
20:23:36 <dons> fails in hugs though
20:23:37 <dons> ERROR "A.hs":24 - Unresolved top-level overloading
20:23:37 <dons> *** Binding             : io
20:23:37 <dons> *** Outstanding context : MonadIO b
20:23:45 <dons> just add the above type to the line for 'io'
20:23:49 <dons> io :: IO a -> StateT [Integer] IO a
20:24:30 <kpreid> dons: you've checked your .ghci, right? :)
20:25:02 <chessguy> that fixed it
20:25:11 <chessguy> but why would your ghc infer the type and not mine
20:25:22 <dons> kpreid: i don't have a .ghci
20:25:28 <dons> but i've seen this bug before with hugs/ghci
20:25:37 <dons> and its apparently a difference in hugs from h98
20:25:45 <dons> but i don't know why your ghci isn't working
20:27:22 <chessguy> weirdness
20:27:31 <sorear> /# /msg hpaste !msg @slap sorear
20:27:36 <chessguy> anyway, is this something like what you're suggesting for the TicTacToe monad?
20:27:47 <chessguy> for the board?
20:27:53 <sorear> fun ... ERC sends unrecognized commands
20:28:06 <glguy> sorear: You either wanted !say
20:28:17 <glguy> sorear: or, !msg lambdabot :this and that
20:28:23 <glguy> the command is fairly primitive
20:28:33 <glguy> (as in you need the irc colon)
20:28:47 <sorear> !say :@slap sorear
20:29:11 <glguy> oh, you never sent hpaste the message i asked you to :-p
20:29:16 <sorear> this was supposed to be a silent (if failing) test ...
20:29:27 <glguy> !admin+ :sorear!n=user@ip68-7-248-101.sd.sd.cox.net
20:29:37 <sorear> ERC> /msg hpaste oh, you vant my pefix sting ...                        [19:34]
20:29:43 <glguy> no, early I said msg hpaste or the channel
20:29:46 <glguy> !say like this
20:29:47 <hpaste> like this
20:29:53 <glguy> !msg #haskell :or this
20:29:54 <hpaste> or this
20:30:12 <chessguy> what's the point of hpaste admins?
20:30:16 <sorear> what did I do wrong?
20:30:24 <glguy> sorear: you weren't added yet
20:30:31 <sorear> !say Taunting pasters!
20:30:31 <hpaste> Taunting pasters!
20:30:41 <glguy> glguy: msg the bot something
20:30:41 <glguy> [9:28pm] glguy: soI can admin+ you
20:30:51 <glguy> I said that to you in /msg but you didn't so I didn't :)
20:30:52 <sorear> glguy: I did msg the bot something
20:30:55 <glguy> oh
20:30:59 <glguy> then I missed it,
20:31:02 <sorear> the /msg above
20:31:11 <glguy> well i meant at that moment
20:31:12 <sorear> [19:34]
20:31:14 <glguy> when I was watching :)
20:31:17 <sorear> oh :)
20:31:30 <glguy> chessguy: hpaste admins can !quiet the bot
20:31:35 <sorear> !list-all
20:31:54 <glguy> like I said, the commands are limited and primitive :)
20:32:16 <glguy>    !msg !say !quit  !quiet  !verbose
20:32:37 <glguy> oh, and !paste
20:32:43 <sorear> no !ctcp ?
20:32:53 <glguy> I don't remember...
20:32:59 <sorear> !ctcp PING
20:33:21 <glguy> no, i took that out
20:33:25 <glguy> it was a channel wide command
20:33:29 <glguy> and I couldn't figure out a good reason for it
20:35:06 <sorear> glguy: the delete form doesn't work
20:35:13 <glguy> it doesn't?
20:35:23 <sorear> I try to delete paste 136 and    404 not found
20:35:27 <sorear> that's all
20:35:30 <glguy> OH
20:35:38 <sorear>                                                                              http://hpaste.org/admin/delete?result=bad entry id
20:35:41 <glguy> OHHH
20:35:58 <sorear> am I embarrasing you? sorry. :)
20:36:04 <glguy> one second, I broke it trying to add a different feature
20:37:05 <dons> reddit's watching, don't break things! :)
20:38:01 <chessguy> dons, is that state example something like what you had in mind for the TicTacToe monad?
20:38:03 <sorear> augustss: hehe.  hbi is google #91
20:38:14 <glguy> dons: the public facing picture is rosy
20:39:44 <dons> chessguy: hmm, maybe.
20:39:51 <dons> though you don't need StateT
20:39:58 <dons> i'd ensure your tictactoe logic is all pure
20:40:54 <chessguy> but i thought you said the point of the monad would be to maintain the state
20:41:51 <dons> right. it is pure though.
20:41:54 <dons> not a StateT over IO
20:42:01 <dons> so I'd just use a State for the processing
20:42:08 <dons> and feed in outside commands purely somehow
20:43:48 <chessguy> i'm not sure i understand the difference
20:44:04 <dons> you don't interleave IO into the tictactoe logic
20:44:18 <dons> but hack away!
20:44:20 <chessguy> oh, ok
20:44:35 <chessguy> one thing i was thinking was to have a type class Player
20:44:39 <glguy> dons: I'll wait to restart hpaste to load the new admin code until someone defaces, or until traffic subsides :)
20:44:56 <dons> right
20:45:02 <chessguy> with a function makeMove :: Board -> Move
20:45:29 <glguy> or, possibly, to remove sorear's test paste :)
20:45:37 <glguy> showing that delete doesn't work! :-D
20:46:12 <chessguy> and then trying to model both the human player and the artificial player that way, with the real player going to the io to get a move, and the artificial player having some algorithm it runs to pick the move
20:47:42 <chessguy>   hmm, that didn't even make sense to me
20:47:49 <hpaste> I have handled my 20,000th event
20:47:51 <sorear> chessguy: it made sense to me?
20:47:59 <sorear> chessguy: make :
20:48:11 <sorear> ai :: Monad m => foo -> m bar
20:48:17 <sorear> player :: foo -> IO bar
20:48:26 <sorear> parametricity guarantees purity
20:48:39 <sorear> but ai can still be used at player's type
20:49:19 <chessguy> but then ai and player can't be instances of the same typeclass
20:49:27 <chessguy> i think
20:49:30 <sorear> ?
20:49:33 <sorear> typeclass?
20:49:43 <sorear> is your code somewhere we can see it?
20:49:51 <chessguy> not yet, just in my head
20:49:55 <sorear> hpaste: how much read traffic are you geting?
20:50:11 <chessguy> but i said i was going to have a typeclass, and have both player and ai instantiate it
20:50:45 <hpaste> not much more than usual
20:50:50 <glguy> :-/
20:50:50 <Anon4888> is ()->t the same type as t?
20:51:10 <sorear> Anon4888: yes
20:51:13 <Anon4888> thx
20:51:28 <sorear> isomorphic anyways - they won't unify
20:51:40 <sorear> ignore the bottom behind the curtain
20:51:41 <Anon4888> oh ok that's what I was asking
20:52:28 <Anon4888> Shouldn't ()->t curry to t?
20:52:36 <chessguy> @quote bottom
20:52:36 <lambdabot> xerox says: I am really interested specifically in bottoms in this very moment.
20:54:11 <glguy> curry to t?
20:55:06 <Anon4888> sorry.  Suppose you have f:: ()->t, you could curry it to f::t by ... doing nothing?
20:55:19 <glguy> f () :: t
20:55:32 <Anon4888> ()::() ?
20:55:51 <Anon4888> is () a type or a value?
20:56:18 <Anon4888> > ()
20:56:19 <bd_> both >.>
20:56:20 <lambdabot>  ()
20:56:22 <bd_> :t ()
20:56:24 <lambdabot> ()
20:56:31 <Anon4888> ok thanks
20:56:49 <chessguy> is it the only thing that's both?
20:56:49 <bd_> data () = () deriving (Show, Eq, Ord, Read, Enum, Bounded)
20:56:56 <bd_> chessguy: no, you can define anotehr:
20:56:57 <Anon4888> But () is different than bottom?
20:56:58 <bd_> data Foo = Foo
20:57:03 <bd_> Anon4888: yep
20:57:05 <Anon4888> ok thx
20:57:08 <bd_> > let f () = "foo" in f undefined
20:57:10 <lambdabot>  Undefined
20:57:11 <bd_> > let f () = "foo" in f ()
20:57:13 <lambdabot>  "foo"
20:57:15 <chessguy> but it's the only thing that's defined as both
20:57:31 <bd_> chessguy: What do you mean?
20:57:52 <chessguy> defined in the language
20:57:53 <bd_> I don't know if there's another example in the standard prelude, but it's easy to define such types yourself
20:57:58 <bd_> I do it all the time with newtypes
20:58:20 <chessguy> hmm, ok
20:58:52 <Anon4888> So () is a singleton type... is there a nullary type?
20:59:10 <bd_> Not in haskell 98, but extensions support them
20:59:15 <bd_> 'tag types' they're called, I think
20:59:18 <bd_> data Foo -- like this
20:59:28 <Anon4888> ah ok thanks
20:59:45 <bd_> they're useful for doing mindingly complex stuff with the type system
21:02:12 <chessguy> ?hoogle State
21:02:12 <lambdabot> Control.Monad.State :: module
21:02:12 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
21:02:12 <lambdabot> Control.Monad.State.State :: newtype State s a
21:02:25 <glguy> pmf 1 point 0 minutes ago
21:02:25 <glguy> Real men paste their crap to reddit.
21:02:46 <chessguy> Control.Monad.State.State has two different types?
21:03:32 <glguy> State is a type
21:03:33 <glguy> and
21:03:41 <glguy> a constructor
21:03:47 <augustss> yo
21:03:58 <glguy> just like () :)
21:04:53 <chessguy> heh
21:05:05 <bd_> And IO!
21:05:11 <glguy> dons: 400 lines after white space was removed?
21:05:41 <dons> glguy: yeah
21:05:45 <glguy> 91 DiffHtml.hs     565 HPaste.hs      85 HPasteAdmin.hs     213 PasteBot.hs     145 PasteState.hs    1099 total
21:05:49 <glguy> that makes more sense :)
21:05:57 <chessguy> ?hoogle meet the monads
21:05:58 <lambdabot> Did you mean: Meet The Monads
21:05:58 <lambdabot> Prelude.undefined :: a
21:05:58 <lambdabot> Test.QuickCheck.Batch.bottom :: a
21:06:02 <chessguy> oops
21:06:06 <dons> and comments
21:06:07 <chessguy> @google meet th emonads
21:06:08 <lambdabot> No Result Found.
21:06:12 * chessguy sighs
21:06:18 <chessguy> @go meet the monads
21:06:33 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
21:06:44 <chessguy> @google meet the monads
21:06:59 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
21:07:00 <chessguy> that's weird
21:07:12 <dons> sometimes the network plays up
21:07:14 <dons> p
21:07:57 <chessguy> @google meet the monads
21:07:58 <lambdabot> http://www.nomaware.com/monads/html/meet.html
21:08:14 <chessguy> that's better
21:08:27 * chessguy strokes lambdabot lovingly
21:09:49 <glguy> does this do what I'm guessing it does? "^/diff(\?.*)?$"
21:16:37 <reilly> why would haddock choke on an .hs file that compiled succesfully?
21:18:47 <dons> reilly: hmm it uses some extensions?
21:18:52 <dons> or it has \ / funny chars in comments
21:20:17 <reilly> hpaste is unhappy, huh?
21:20:20 <glguy> hey! whats going on!!
21:20:29 <glguy> I'm getting a 503 on :80
21:20:43 <glguy> :8000 still working
21:20:47 <glguy> @get-shapr
21:20:48 <lambdabot> shapr!!
21:20:51 <glguy> ?seen shapr
21:20:51 <lambdabot> shapr is in #scannedinavian and #haskell. I last heard shapr speak 3h 15m 36s ago.
21:20:55 <glguy> whaaa
21:21:02 <glguy> hmm, back
21:21:06 <reilly> it's pretty vanilla.  There are files in HsJudy that aren't vanilla, but this isn't one of them
21:21:07 <dons> web page seems happy
21:21:11 <glguy> ok...
21:21:15 <glguy> ok i'm ok now..
21:21:16 <glguy> :)
21:21:20 <dons> :)
21:21:22 <glguy> DON"T PANIC
21:21:28 <dons> better check the logs
21:22:47 <reilly> i like that hpaste now has announce as an option, not silent
21:23:04 * glguy forwards appreciation to dons
21:25:29 <dons> the  unsafeCoerce#
21:25:34 <dons> reilly: is not haddock safe
21:25:49 <dons> so wrap it in #ifndef __HADDOCK__ I think
21:26:07 <dons> though there may be some other ways to work around it
21:26:16 <dons> acutally...
21:26:25 <dons> it could be the empty instance on line 23
21:29:05 <fraxtal> so i heard u enjoy category theory as light reading
21:29:26 <glguy> sorear: you can delete your paste now :-p
21:29:34 <glguy> I believe
21:29:42 <glguy> feel free to announce if I'm still wrong
21:31:38 * bd_ wonders how possible it'd be to create a disk database which would compose with STM...
21:34:02 <dons> hey fraxtal good to see you're making the same interesting observations you've been doing for the last 3 years
21:35:59 <fraxtal> haha what
21:36:18 <dons> 04.07.25:13:46:50 <fraxtal> how is functional programming better than imperitive programming?
21:36:28 <dons> so you've gained a phd in programming theory in the last 3 years? :)
21:36:35 <dons> or just kicked around
21:36:56 <dons> mm. in 3 years you could do so much!
21:37:11 <triple_> big brother at work :o
21:37:23 <fraxtal> heh
21:37:27 <dons> the logs are public
21:37:30 <dons> and in darcs!
21:37:35 <dons> ?where darcs-logs
21:37:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/darcs/
21:38:11 <bd_> darcs failed:  Failed to download URL http://www.cse.unsw.edu.au/~dons/irc/darcs/_darcs/inventory
21:38:22 <fraxtal> I've had to write pieces of junk in Matlab for the past year
21:38:29 <dons> i'll check that but note that 7 years of logs is some 500M...
21:38:36 <bd_> heh
21:39:01 * bd_ has noted an exponential progression in the size of his personal IRC logs over the past 4-5 years >.>
21:39:29 <dons> ?where+ darcs-logs darcs get http://www.cse.unsw.edu.au/~dons/code/irc-logs
21:39:29 <lambdabot> Done.
21:39:46 <dons> ?where+ darcs-logs darcs get --partial http://www.cse.unsw.edu.au/~dons/code/irc-logs
21:39:46 <lambdabot> Done.
21:39:49 <dons> !
21:48:38 * augustss gets really depressed about humanity some days.
21:52:50 * dons juggles lambdas for augustss 
21:52:54 <dons> look, no hands!
21:53:03 <augustss> :)
21:53:29 <augustss> ok, not all of humanity is lost
21:55:08 * augustss was just reading more idiots post on reddit.
21:55:54 <mbishop> just make sure you don't read digg
21:56:37 <augustss> with digg I have no expectations :)
21:59:33 <mbishop> Well I think you shouldn't have expectation about reddit anymore
22:00:52 <dons> we just have to start submitting pdfs from popl again
22:00:56 <dons> like we used to last year
22:01:21 <dons> that keeps the standard up, and drives away those with low tolerance for pdf (or, even better, ps!)
22:01:21 <bd_> ?where popl
22:01:22 <lambdabot> I know nothing about popl.
22:01:30 <dons> ?google popl
22:01:34 <lambdabot> http://www.cs.ucsd.edu/popl/07/
22:01:34 <lambdabot> Title: POPL 2007
22:01:45 <augustss> I just find the anti-intellectualism, anti-understanding attitude depressing.
22:02:18 <dons> yeah. there's always LtU I suppose
22:02:23 <dons> but its not as dynamic as reddit
22:02:33 <mbishop> dons: perhaps that's a good thing :)
22:02:50 <dons> reddit doesn't help us much by linking the programming subreddit from the top of the main page
22:03:18 <mbishop> I still say a nice happs server with a haskell reddit clone would be great :P
22:03:38 <dons> hehe. the lisppaste team fights back! http://programming.reddit.com/info/115js/comments
22:05:48 * dons looks for a good paper from popl to submit..
22:06:13 <bd_> :t GHC.Exts.split
22:06:14 <lambdabot> forall t. (GHC.Exts.Splittable t) => t -> (t, t)
22:06:23 <bd_> @hoogle Splittable
22:06:24 <lambdabot> GHC.Exts.Splittable :: class Splittable t
22:10:19 <NichardRixon> n <- liftM2 enumFromTo (Just 0) (rand (3,10))
22:10:31 <NichardRixon> is it possible to have something like this on the right side of a list comprehension?
22:11:43 <dons> you'd need a monad comprehension
22:11:47 <dons> unless its for lists
22:11:54 <dons> :t liftM2 enumFromTo (Just 0) (rand (3,10))
22:11:56 <lambdabot> Not in scope: `rand'
22:12:09 <dons> :t System.Random.random
22:12:10 <lambdabot> forall a g. (Random a, RandomGen g) => g -> (a, g)
22:12:32 <NichardRixon> what do you mean unless it's for lists?
22:13:02 <NichardRixon> and my rand function returns an IO Int
22:13:03 <dons> so you want to use liftM2 ... as a generator in a list comprehension?
22:13:22 <NichardRixon> that's what I'm hoping :<
22:13:26 <dons> (not possible if it does IO)
22:13:32 <dons> use mapM_
22:13:32 <dons> or mapM
22:13:47 <NichardRixon> how so?
22:13:52 <dons> generating randoms need not be in IO though
22:14:03 <NichardRixon> hrm
22:14:24 <NichardRixon> I was just using the default one that I read about
22:14:45 <dons> :t randoms (3,10) (mkStdGen 42)
22:14:47 <lambdabot>     The function `randoms' is applied to two arguments,
22:14:47 <lambdabot>     but its type `g -> [a]' has only one
22:15:01 <dons> > randomRs (3,10) (mkStdGen 42)
22:15:03 <lambdabot>  [10,10,8,5,7,10,9,10,5,6,8,6,7,9,3,4,10,10,4,3,9,3,7,9,7,5,5,5,10,9,3,6,9,3,...
22:19:30 <NichardRixon> dons, so that returns an array of Ints then?
22:19:42 <bd_> NichardRixon: a list
22:19:45 <bd_> :)
22:19:50 <NichardRixon> yeah, that's what I meant :P
22:19:51 <bd_> arrays aren't lazy in that way
22:19:56 <bd_> [alas!]
22:22:00 <dons> > listArray (0,99) (take 99 $ randomRs (3,10) (mkStdGen 42))
22:22:01 <lambdabot>  Exception: (Array.!): undefined array element
22:22:06 <dons> :}
22:22:16 <dons> > listArray (0,99) (take 100 $ randomRs (3,10) (mkStdGen 42))
22:22:18 <lambdabot>  array (0,99) [(0,10),(1,10),(2,8),(3,5),(4,7),(5,10),(6,9),(7,10),(8,5),(9,6...
22:23:29 <NichardRixon> >[ n*n | n <- [0..(randomRs (a,b) (mkStdGen 42))] ]
22:23:39 <NichardRixon> > [ n*n | n <- [0..(randomRs (a,b) (mkStdGen 42))] ]
22:23:40 <lambdabot>   Not in scope: `b'
22:23:44 <NichardRixon> bah
22:23:48 <NichardRixon> > [ n*n | n <- [0..(randomRs (3,10) (mkStdGen 42))] ]
22:23:49 <lambdabot>   add an instance declaration for (Enum [a])
22:23:49 <lambdabot>     In an arithmetic sequence: [...
22:23:55 <NichardRixon> what does that mean :(
22:24:13 <dons> > [ n * n | n <- randomRs (3,10) (mkStdGen 42) ]
22:24:14 <lambdabot>  [100,100,64,25,49,100,81,100,25,36,64,36,49,81,9,16,100,100,16,9,81,9,49,81,...
22:24:23 <NichardRixon> oh :o
22:24:31 <dons> > [ n * n | x <- [0..n], n <- randomRs (3,10) (mkStdGen 42) ]
22:24:32 <lambdabot>   Not in scope: `n'
22:24:57 <dons> > [ m * m | n <- randomRs (3,10) (mkStdGen 42), m <- [0..n] ] -- no idea what you want
22:24:58 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100,0,1,4,9,16,25,36,49,64,81,100,0,1,4,9,16,25,3...
22:25:09 <nmessenger> you want the squares from 0 to some random number in (3,10)?
22:25:13 <NichardRixon> yes
22:25:27 <NichardRixon> squares are just for example, but yeah
22:25:42 <NichardRixon> I want a random length sequential list
22:25:54 <Cale> > randomR (3,10) (mkStdGen 42)
22:25:56 <dons> :t replicate
22:25:56 <lambdabot>  (10,1720602 40692)
22:25:58 <lambdabot> forall a. Int -> a -> [a]
22:26:18 <nmessenger> > [ n * n | n <- [ 0 .. fst $ randomR (3,10) (mkStdGen 42) ]
22:26:18 <lambdabot>  Parse error
22:26:32 <dons> :t randomR
22:26:34 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:27:08 <dons> > [ n * n | n <- [ 0 .. fst (randomR (3,10) (mkStdGen 42)) ] ]
22:27:10 <lambdabot>  [0,1,4,9,16,25,36,49,64,81,100]
22:27:17 <dons> > [ n * n | n <- [ 0 .. fst (randomR (3,10) (mkStdGen 43)) ] ]
22:27:19 <lambdabot>  [0,1,4,9,16,25,36,49,64]
22:27:25 <dons> > [ n * n | n <- [ 0 .. fst (randomR (3,10) (mkStdGen 44)) ] ]
22:27:26 <lambdabot>  [0,1,4,9,16,25,36]
22:27:30 <nmessenger> oh, left out a ']'
22:27:40 <NichardRixon> ok, that makes sense now
22:28:00 <dons> > [ replicate n n | n <- randomRs (3,10) (mkStdGen 84) ]
22:28:01 <lambdabot>  [[6,6,6,6,6,6],[5,5,5,5,5],[9,9,9,9,9,9,9,9,9],[4,4,4,4],[9,9,9,9,9,9,9,9,9]...
22:28:41 <nmessenger> NichardRixon: instead of (mkStdGen 42), you should accept a generator as an argument, that way you can use a pure one (mkStdGen someNumber) or one bound in IO (newStdGen)
22:28:50 <nmessenger> :t newStdGen
22:28:51 <lambdabot> IO StdGen
22:28:52 <NichardRixon> ok
22:29:23 <dons> ?let rlist g = [ n * n | n <- [ 0 .. fst (randomR (3,10) g) ] ]
22:29:24 <lambdabot> Defined.
22:29:31 <dons> > rlist (mkStdGen 1)
22:29:32 <lambdabot>  [0,1,4,9,16]
22:30:03 <nmessenger> > rlist =<< newStdGen -- but LB doesn't do IO
22:30:04 <lambdabot>  Couldn't match `[]' against `IO'
22:30:49 <nmessenger> :t rlist
22:30:50 <lambdabot> Not in scope: `rlist'
22:31:02 <dons> not available in ghci yet.
22:31:08 <dons> i should get off my butt and make that work
22:31:40 * nmessenger is very grateful to dons butt for lambdabot's excellence so far.
22:32:13 <glguy> I can tell when I get a unique visitor by when they download hpaste.jpg :)
22:32:20 <sorear> dons: how do you feel about non-base libs in @run ?  someone needed a MissingH function earlier :)
22:33:03 <dons> hmm
22:33:05 <dons> hackage only
22:33:07 <nmessenger> why didn't 'rlist =<< newStdGen' work?
22:33:09 <dons> as an incentive!
22:33:16 <dons> :t newStdGen
22:33:17 <lambdabot> IO StdGen
22:33:21 <dons> that's why
22:33:23 <bd_> nmessenger: rlist isn't of type StdGen -> IO a ?
22:33:33 <nmessenger> ah, return, gotcha
22:33:37 <dons> yeah
22:33:43 <nmessenger> I always forget
22:33:44 <sorear> dons: unsafeIOtoST is in hackage :)
22:33:52 <dons> right. that too
22:33:56 <dons> i don't trust nuffin!
22:34:07 <sorear> glguy: side channel testing...
22:34:18 <glguy> ?
22:34:21 <NichardRixon> thanks everybody, it works so nicely now :)
22:35:02 <jtokle> i just tried a cabal install, but it doesn't seem to have copied all the files correctly
22:35:10 <dons> jtokle: what happened?
22:35:15 <dons> which package?
22:35:24 <dons> ?paste <-- perhaps put up the log here
22:35:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:35:47 <jtokle> when i try to import the new module (Sound.SC3), ghci complains
22:35:57 <jtokle> Hsc package: http://www.slavepianos.org/rd/f/207949/
22:35:58 <lambdabot> Title: rohan drape: hsc [207949]
22:36:16 <NichardRixon> wow, ghc just locked up on me
22:36:17 <NichardRixon> weird
22:36:19 <dons> can you put up a log of ghc-pkg output, what ghci says, and anything else relevant?
22:37:06 <jtokle> is that what the pastebin is for?
22:37:18 <dons> yeah
22:37:24 <dons> helping us help you :)
22:37:26 <jtokle> sure, one second...
22:37:28 <jtokle> :)
22:38:14 <glguy> dons: has hpaste announced any pastes since I changed the default?
22:38:27 <dons> a few yeah
22:38:30 <dons> but not so many..
22:39:08 <glguy> there haven't actually been many pastes in the last 8 hours either
22:39:29 <glguy> sorear: what is side channel testing?
22:40:48 <sorear> where I test a side channel ... in this case invalid URLs
22:40:58 <dons> right. that's what I guessed you were up to :)
22:41:02 <dons> i did that a few days ago
22:41:21 <glguy> sorear: any url not caught by one of the handlers is redirected to /
22:41:36 <dons> happs++
22:41:36 <sorear> I noticed :)
22:41:39 <jtokle> pasted, though it's not all that informative
22:41:59 <glguy> dons: I think that was hpaste's first kamra
22:42:02 <glguy> karma
22:42:02 <jtokle> build went OK, but the install portion seems not to have copied all the files to the install location correctly
22:42:05 <sorear> glguy: why isn't announce the default anymore ?
22:42:08 <dons> Test.hs:9:29: Not in scope: data constructor `Port'
22:42:17 <dons> jtokle:  you're missing the Network module
22:42:20 <dons> ?hoogle Port
22:42:21 <lambdabot> Network.PortNumber :: PortNumber -> PortID
22:42:21 <lambdabot> Network.PortID :: data PortID
22:42:21 <lambdabot> Network.PortNumber :: data PortNumber
22:42:26 <dons> (I think?)
22:42:27 * glguy defers the question to dons
22:42:35 * sorear aggrees with dons
22:42:39 <jtokle> Port is redefined in Sound.OpenSoundControl.UDP
22:42:44 <jtokle> at least, that's the port i was going for
22:42:44 <sorear> yow!
22:42:46 <dons> maybe you should import that?
22:42:51 <dons> Sound.OpenSoundControl.UDP ?
22:42:52 <glguy> !say ?karma
22:42:53 <hpaste> ?karma
22:42:53 <lambdabot> You have a karma of 0
22:43:00 <dons> heh
22:43:05 <jtokle> ghci can't find it -- same problem, i think
22:43:12 <dons> :m + Sound.OpenSoundControl.UDP
22:43:13 <dons> ?
22:43:53 <jtokle> Could not find module `Sound.OpenSoundControl.UDP':
22:44:09 <dons> is this your library/
22:44:22 <dons> i'm not familiar with it, so possibly you're not using the api correctly?
22:44:27 <dons> /home/joshua/.ghc/i386-linux-6.6/package.conf:
22:44:27 <dons>     Hsc-0.1
22:44:32 <dons> indicates that it is installed properly
22:44:38 <jtokle> it's possible -- i'm just trying it out
22:44:40 <dons> maybe ping the author?
22:44:48 <dons> seems like a simple issue though
22:45:23 <jtokle> well, when i list out the files in the install location, it seems conspicuously bare
22:45:38 <jtokle> the library defines an OpenSoundControl.hs and SC3.hs
22:45:48 <jtokle> both of which reexport modules in subdirectories
22:45:49 <dons> ah ok. maybe it doesn't export the UDB module
22:45:57 <dons> UDP.
22:46:04 <dons> better check Port is getting exported somewhere
22:46:05 <jtokle> i see the OpenSoundControl.hi and sC3.hi files, but no subdirectories in the install location
22:46:20 <dons> hmm. ok. possiby their .cabal file is wrong?
22:46:27 <dons> what version of cabal are you using, btw?
22:46:33 <jtokle> how do i check?
22:46:43 <dons> Cabal-1.1.6,
22:46:44 <dons> :)
22:46:45 <dons> that's ok.
22:46:46 <jtokle> 1.1.6
22:46:49 <jtokle> ah, right
22:46:57 <dons> hmm. try modifying the .cabal file for the SC* package to export all the other things
22:47:01 <dons> then rebuild and install
22:47:18 <dons> add the missing modules to the Exposed-modules:     line
22:47:25 <dons> in SC*.cabal
22:47:34 <jtokle> got it
22:52:09 <NichardRixon> argh, I don't understand how to use different generators for random numbers
22:52:23 <NichardRixon> rather, how do I avoid using mkStdGen with fixed numbers?
22:52:44 <NichardRixon> hrm, next...
22:52:50 <bd_> :t getStdGen
22:52:52 <lambdabot> IO StdGen
22:52:54 <bd_> :t newStdGen
22:52:56 <lambdabot> IO StdGen
22:52:58 <csci> Hello, how do I add a path in ghc under windows? My path is c:\program files\gtk2hs but maybe I have to pay special attention to quoting? Because ghc can't find the libs
22:53:03 <dons> ah finally, things get interesting! http://programming.reddit.com/info/1165m/comments
22:53:04 <lambdabot> Title: The monad behind every zipper (reddit.com)
22:53:09 <bd_> newStdGen in IO will grab you a new StdGen
22:53:18 <dons> csci: -i on the command line
22:53:19 <jtokle> that did it -- thanks dons
22:53:38 <dons> jtokle: cool. sounds like a library bug though
22:53:44 <dons> you could pass your chagnes back up stream to the author?
22:54:11 <csci> dons: Well, I know, but do I have to pay special attention to \ and spaces? It seemed I can't get it right :-|
22:54:19 <jtokle> yeah -- the modules were reexported, but cabal didn't notice
22:55:05 <dons> csci: hmm. quite possibly
22:55:12 <dons> jtokle: yeah, seems suspicious
22:55:26 <dons> i wonder if i could construct a test case. let's see..
22:55:26 <csci> tried a lot of combinations but nothing worked, ergo asking here for an example or sth like that
22:55:38 <dons> csci: is the gtk2hs library registered properly?
22:55:42 <dons> what does ghc-pkg output?
22:56:24 <csci> dons: it's not registered there. but I just used the native installer for windows.
22:56:52 <csci> dons: so i assume if i add the magic -i in the correct format to ghci it should(?) work, or?
22:57:02 <csci> (it was the same under linux)
22:57:11 <dons> hmm. maybe. it should be registered with ghc though
22:57:18 <dons> check with dcoutts or the other gtk2hs devs
22:57:52 <csci> ok, thanks
22:58:25 <dons> jtokle: when I build with a newer cabal the module B that is hidden, but reexported by module A is caught at compile time:
22:58:28 <dons> [1 of 1] Compiling A                ( A.hs, /usr/obj/cabal/A.o )
22:58:31 <dons> A.hs:2:4: Unknown module in export list: module `B'
22:58:37 <dons> so quite possibly updating cabal will catch this when you build the SC lib
22:58:42 <dons> and it really is a .cabal file bug
23:01:12 <jtokle> dons: the latest release at haskell.org seems to be 1.1.6.  is there a newer version?
23:01:21 <dons> the darcs version of cabal
23:01:24 <dons> 1.1.7
23:01:26 <NichardRixon> argh, I can't see how to update the random number generator without introducing IO
23:01:39 <dons> NichardRixon: fold the seed through the computation
23:01:51 <dons> so that on each iteration you take the next seed and feed it back into mkStdGen
23:01:58 <NichardRixon> hrm
23:01:58 <dons> and you only set the random set once in main
23:02:04 <dons> you got the code somewhere?
23:03:53 <NichardRixon> yes
23:04:13 <NichardRixon> rand g (a,b) = randomR (a,b) g
23:04:24 <NichardRixon> I just don't see how to use the value returned to do it the next time
23:04:28 <NichardRixon> I miss my mutable variables
23:05:37 <NichardRixon> n <- [0..fst (rand (3, 10) (3,10))]
23:05:52 <NichardRixon> barring the fact that that's wrong!
23:06:16 * dons hacks on simple folds and state monads
23:06:23 <nmessenger> ?paste a more complete example so we can look at it
23:06:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
23:06:31 <NichardRixon> yeah, ok
23:07:35 <nmessenger> also, 'randomR range gen' returns a '(randomValue, nextGen)' pair, so you can pass the nextGen into the next call to randomR
23:07:54 <NichardRixon> I saw that, but can't figure out how to work that in
23:08:12 <NichardRixon> http://hpaste.org/139
23:09:03 <glguy> > length $ show $ (maxBound :: Int)
23:09:05 <lambdabot>  10
23:09:34 <|Procyon|> What's the best emacs mode to be using for haskell, and is there a good ghci mode?
23:11:37 * nmessenger reads NichardRixon's code
23:12:31 <hpaste>  dons pasted "State Random" at http://hpaste.org/140
23:13:06 <dons> NichardRixon: so that's a (slightly elaborate) example of sticking the seed in a state monad and using that to get at a new random seed each time
23:13:15 <NichardRixon> huh, interesting
23:13:33 <dons> another way is to just fold the StdGen around, let me try that
23:14:16 <dons> unfold, I mean :)
23:15:34 <NichardRixon> let (r,g') = random g
23:15:38 <NichardRixon> ooh, that's a neat syntax
23:15:42 <NichardRixon> haven't seen it before
23:17:55 <bd_> > let fib 0 = 1; fib 1 = 1; fib (n+1) = fib (n - 1) + fib n in fib 5
23:17:56 <lambdabot>  Parse error in pattern
23:17:59 <bd_> hmm
23:18:09 <bd_> works in ghci :/
23:18:10 <hpaste>  nmessenger annotated "oh random :(" with "does this do what you want?" at http://hpaste.org/139#1
23:18:12 <hpaste>  dons annotated "State Random" with "unfoldr++" at http://hpaste.org/140#1
23:18:20 <dons> mm. this was born for unfoldr
23:18:43 <dons> bd_ yeah, n+k patterns don't prse in lambdabot's parser
23:19:25 <nmessenger> oh my!  I just realised that the random* return types match so very sexily with unfoldr
23:19:46 <dons> yeah
23:19:54 <dons> that's what I meant by the unfoldr++ :)
23:20:09 <dons> this is the definition of synergy :)
23:20:22 <NichardRixon> nmessenger, what's gen'?
23:20:31 <NichardRixon> oh wait
23:20:32 <NichardRixon> I see it
23:20:41 <nmessenger> the second generator, after... nevermind then ;)
23:23:26 <dons> NichardRixon: so are you on the road to lambda zen yet?
23:23:43 <dons> if not, imagine a lambda with no arguments. is it still a lambda?
23:23:51 <NichardRixon> of course!
23:24:07 <dons> very wise. you are on the correct path
23:24:20 <NichardRixon> well, more like I'm begging for alms by the side of the path
23:24:23 <dons> but what if no one is around to apply it?
23:24:24 <NichardRixon> but still :)
23:24:38 <|Procyon|> What should I do with pattern matches that can never be hit in order to remove -Wall warnings?  Throwing errors would cruft up all my type signatures... What is the common practice?
23:24:51 <dons> put _ -> error "can't happen" :)
23:24:54 <bd_> If a graph is reduced in a forest, and no one is around to pattern match the resulting WHNF, does it cause a space leak?
23:24:55 <NichardRixon> then the lambda need not exist and it is optimized away
23:25:03 <dons> (seriously, using _ = undefined is one way)
23:25:15 <dons> bd_ hmm!
23:25:37 <dons> ?remember bd_ If a graph is reduced in a forest, and no one is around to pattern match the resulting WHNF, does it cause a space leak?
23:25:37 <lambdabot> Done.
23:26:09 <sorear> |Procyon|: that way lies debugging nightmares.
23:26:19 <NichardRixon> nmessenger, one question
23:26:22 <csci> If I compile something with ghc (which also uses gtk etc) is it then static compiled (I'd think so with a program size of 7,5 MB), but want to be sure :)
23:26:27 <nmessenger> NichardRixon: yes?
23:26:28 <NichardRixon> how often does this code update the seed?
23:26:31 <sorear> |Procyon|: the correct approach is to refactor your types.
23:26:41 <dons> csci, yeah, statically linked
23:26:43 <sorear> csci: yes
23:26:46 <csci> thanks
23:26:49 <sorear> csci: unfortunately
23:26:52 <dons> you can strip the resulting binary back down to sane sizes if you want
23:26:58 <dons> and on mac os x you can dyn link everything
23:27:00 <glguy> has anyone used HAppS.Agent.SessionKeeper with the new API?
23:27:03 <csci> well, it's cool to give programms aorunf w/o a lot of libs
23:27:06 <NichardRixon> because it doesn't act like it's actually changing the value very much
23:27:06 <bd_> csci: it's dynamically linked to libc!
23:27:10 <sorear> 300k isn't "sane" in my book
23:27:15 <csci> bd_: under windows? ;-)
23:27:20 <bd_> perhaps not :)
23:27:25 <dons> 180k is reasonable, sorear
23:27:29 <Procyon_> sorear: Refactor, as in make only meaningful pattern matches type legal?
23:27:35 <dons> (that's a stripped hello.hs on linux)
23:27:40 <nmessenger> NichardRixon: well, newStdGen should split the global generator in IO, beyond that, I've no idea :D
23:27:42 <dons> you short of disk space?? ;)
23:27:46 <sorear> Procyon_: yes
23:27:55 <sorear> dons: no, I'm short of seek time and ram
23:28:12 <sorear> dons: every meg counts when you only have 384 of RA
23:28:19 <dons> nah
23:28:24 <dons> i've got 256..
23:28:55 <sorear> dons: if haskell was dynamically linked, the dozens of haskell programs I'd like to concurrently run could share a single set of rts pages - that'd be nice.
23:28:56 <dons> haskell should teach you to not worry about binary sizes either ;)
23:29:05 <dons> very true.
23:29:25 <dons> you could apply for a Summer of Code scholarship to port the dyn linking framework to linux/x86?
23:29:39 <dons> (seriously, or something else... start thinking about it . 5k US is a good summer job :)
23:29:40 <Procyon_> sorear: so, in the code you looked at, instead of data Expr = Apply Expr Expr; I should factor out a type ApplyableExpr so that Integers will never be a candidate for apply
23:30:53 <sorear> Procyon_: you're doing type inference, correct? so then integer *cannot* reach apply?  but yes, factoring out smaller types is the Normal Way
23:32:30 <Procyon_> right.  Integer cannot reach apply (except of course if I write a pathological case on purpose in ghci).  I would like it to compile with no warnings though, so I'll refactor.
23:36:48 <dons> ?users
23:36:48 <lambdabot> Maximum users seen in #haskell: 322, currently: 275 (85.4%), active: 16 (5.8%)
23:37:01 <dons> glguy: i'd like to transfer good stuff in hpaste across to the wiki
23:37:08 <jeeves_bond> Hi, am just learning Haskell but am coming across a weird error. When I put 'read "3.3"' into ghci it returns: '*** Exception: Prelude.read: no parse'
23:37:21 <bd_> > read "3.3" :: Int
23:37:22 <lambdabot>  Exception: Prelude.read: no parse
23:37:23 <glguy> dons: and I would appreciate your doing so
23:37:23 <bd_> > read "3.3" :: Float
23:37:24 <sorear> that's expected
23:37:25 <lambdabot>  3.3
23:37:25 <dons> we should put a litle disclaimer stating that all code goes into the public domain or some such (equivalent to the wiki license)
23:37:27 <nmessenger> add ' :: Double'
23:37:49 <glguy> dons: that's acceptable to me
23:37:50 <newsham> no port of vty to win32?
23:37:56 <dons> glguy: ok. i'll craft a patch
23:37:56 <sorear> jeeves_bond: that just means periods are illegal in integers
23:38:08 <nmessenger> jeeves_bond: ghci defaults to Int I think
23:38:18 <sorear> newsham: what makes you think a port even makes sense?
23:38:22 <sorear> newsham: btw, I
23:38:30 <sorear> 'm the person to convince :)
23:38:37 <newsham> sorear: because both systems support character based terminals?
23:38:39 <dons> jeeves_bond:
23:38:40 <glguy> dons: if it makes it easier for people learning Haskell, then I'd be flattered
23:38:40 <dons> Prelude> read "3.3" :: Double
23:38:41 <dons> 3.3
23:38:41 <dons> Prelude> read "3.3" :: Int
23:38:41 <dons> *** Exception: Prelude.read: no parse
23:38:50 <dons> i think its a great source for useful code
23:39:00 <dons> i never really appreciated how much stuff we churn out in this channel
23:39:01 <newsham> sorear: and people on windows also need to edit files?
23:39:17 <NichardRixon> > randomRs (0,20) mkStdGen(42)
23:39:18 <lambdabot>      The function `randomRs' is applied to three arguments,
23:39:18 <lambdabot>     but its type ...
23:39:23 <Vq^> > 1 :: Int
23:39:24 <lambdabot>  1
23:39:26 <sorear> I have never seen a terminal connected to a windows box or a terminal emulator connected to anything other then PuTTY ...
23:39:26 <Vq^> > 1 :: Double
23:39:28 <lambdabot>  1.0
23:39:29 <NichardRixon> > randomRs (0,20) (mkStdGen 42)
23:39:30 <lambdabot>  [14,12,7,4,17,10,18,5,9,0,0,6,0,11,2,7,8,4,9,0,17,12,0,1,1,1,9,17,17,6,1,14,...
23:39:38 <nornagon> nice
23:39:40 <nornagon> :t randomRs
23:39:42 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
23:39:44 <sorear> I didn't realize windows had any support for ANSI terminals.
23:39:55 <nornagon> sorear: it doesn't
23:39:56 <jeeves_bond> Hmmm, interesting. Thanks I'll find out why that's the case later :)
23:39:58 <newsham> sorear: ahh.  qed.
23:39:58 <Vq^> > 1 :: Num a => a
23:40:00 <lambdabot>  1
23:40:02 <nmessenger> > 1.0 :: Int
23:40:03 <lambdabot>   add an instance declaration for (Fractional Int)
23:40:04 <lambdabot>     In the expression: 1.0...
23:40:13 <Vq^> > 1 :: Fractional a => a
23:40:15 <lambdabot>  1.0
23:40:16 <nornagon> > toInteger 1.0
23:40:17 * dons watches 'Radar Men from the Moon'
23:40:18 <lambdabot>  Add a type signature
23:40:21 <nornagon> > toInteger 1.0 :: Integer
23:40:22 <lambdabot>  Add a type signature
23:40:23 <glguy> dons: I'm updating PasteState to use record syntax and to support a user session table for storing logins and whatever I come up with
23:40:28 <nornagon> > (toInteger 1.0) :: Integer
23:40:29 <lambdabot>  Add a type signature
23:40:32 <nornagon> :(
23:40:37 <newsham> nornagon: sure it does.
23:40:39 <Vq^> > 1.0 :: Num a => a
23:40:40 <lambdabot>   add (Fractional a) to the expected type of an expression
23:40:40 <lambdabot>     In the express...
23:40:49 <sorear> newsham: so you think it should simulate a terminal using windows API?
23:40:50 <nmessenger> > toInteger (1.0 :: Double)
23:40:51 <lambdabot>   add an instance declaration for (Integral Double)
23:40:51 <lambdabot>     In the definition of ...
23:40:53 <nornagon> newsham: ansi.
23:41:00 <newsham> norn: yup.
23:41:02 <bd_> > truncate (1.0 :: Double)
23:41:04 <lambdabot>  1
23:41:06 <Vq^> @type 1.0
23:41:08 <lambdabot> forall t. (Fractional t) => t
23:41:13 <newsham> sorear: would be nice for people who want to run yi.
23:41:16 <nornagon> newsham: try this in a windows terminal: echo -ne "\\e[42mhi!"
23:41:20 <sorear> I'ven't seen it ... how does it happen?
23:41:22 <Vq^> seems to be the most general
23:41:33 <nornagon> or whatever windows equivalent
23:41:49 <sorear> nornagon: does windows do TIOCGWINSZ ?
23:41:53 <nornagon> no idea
23:41:57 <nornagon> but i doubt it
23:41:58 <newsham> norn: i assume you mean in a cmd shell.  which doesnt support -ne in its echo.
23:42:11 <bd_> Windows has its own set of conio functions I thought?
23:42:12 <nornagon> the winxp terminal can't be resized in the <-> direction, last i checked
23:42:19 <nmessenger> an impressive acronym
23:42:21 <Vq^> does it support ansi escapecodes?
23:42:32 <sorear> nornagon: how does one measume the window size?
23:42:38 <newsham> sorear: no it doesnt.
23:42:47 <newsham> TIOCGWINSZ is unix.
23:44:06 <jeeves_bond> So, can any old imperative programming idiot (who's no mathematician) learn Haskell? Or is it for maths gurus only?
23:44:26 <sorear> anyone can try, we aren't elitist
23:44:28 <Vq^> jeeves_bond: we can
23:44:32 * glguy doubts anyone calls him a math guru
23:44:38 * Vq^ is an old stupid C coder
23:44:42 <newsham> sorear: does vty use ansi?
23:44:43 <nmessenger> it takes some unlearning, but I've found it rewarding
23:44:46 * glguy wonders if they call him any old idiot too ;)
23:44:48 <sorear> newsham: yes
23:45:04 <bd_> I knew nothing about category theory before I found Haskell. I still know nothing, but that doesn't stop me from happily chaining up monad transformers!
23:45:17 <newsham> hrmm.. so you didnt use curses or termcaps or anything?
23:45:21 <sorear> newsham: actually it uses ANSI + linux /\ xterm
23:45:22 <nornagon> bd_'s a freak tho
23:45:23 <dons> jeeves_bond: its just a programming language :)
23:45:32 <sorear> newsham: curses sucks.
23:45:33 <dons> jeeves_bond: you don't need to know Hoare logic to hack C ;)
23:45:43 <bd_> nornagon: :D
23:45:47 <dons> jeeves_bond: similarly, theory not required applies to haskell
23:45:47 <sorear> newsham: if I could use curses, I wouldn't have written vty.
23:45:50 <newsham> sorear: so does rewriting your library for each terminal.
23:45:51 <nornagon> curses is horrible
23:46:03 <nornagon> curses is pain
23:46:12 <newsham> you dont need curses, you can use termcaps
23:46:13 <sorear> newsham: ANSI rules the world!
23:46:22 <dons> jeeves_bond: actually, we have a lot of old C hackers kicking around here
23:46:23 * nmessenger curses curses
23:46:30 <sorear> newsham: termcap isn't just as bad?
23:46:34 <dons> lennart, for example, once the IOCCC 2 times I think
23:46:40 <newsham> sorear: they're two different things.
23:46:47 <dons> and he hacks haskell for a living :)
23:46:49 <sorear> e.g Debian woody doesn't come with termcap, calls it obsolete
23:46:52 <dons> s/won/
23:46:54 <newsham> curses is a library to optimize terminal updates
23:47:01 <sorear> @quote lennart
23:47:01 <nornagon> sorear: heh
23:47:02 <lambdabot> lennart says: the best way of debugging is to understand your code
23:47:11 <Vq^> sorear: it's replaced by terminfo i believe
23:47:17 <newsham> termcaps is just a library for translating a semantic to a particular terminal's code
23:47:26 <sorear> nornagon: I suppose you know what the state of Debian woody is :)
23:47:56 <newsham> vq: termios/termio are something different (those are unix specific)
23:48:06 <nornagon> sorear: as in, age measured in decades nowadays?
23:48:16 <newsham> or i suppose need not be unix specific, but are apis that are found on unix..
23:48:21 <sorear> newsham: and, if the job they did with xterm-debian's init string is characteristic, the terminfo maintainers are idiots.
23:48:36 <Vq^> newsham: why shouldn't they?
23:48:38 <sorear> oh yes, vty uses termios too
23:48:53 <newsham> sorear: termcaps has a database mapping capabilities to codes
23:49:02 <newsham> if you dont like the db, you can update it
23:49:07 <newsham> its not part of the code
23:49:20 <sorear> newsham: the same could be said about me fixing curses. :(
23:49:32 <dons> jeeves_bond: so I reckon, just grab ghc and get hacking!
23:49:44 <newsham> sorear: no, "fixing" curses is an architectural issue.
23:49:48 <dons> and you can always play with the FFI if you pine for manual memory management and pointers :)
23:49:52 <newsham> "fixing" a termcap db is just editing a db.
23:50:01 <nornagon> newsham: you're welcome to write one yourself
23:50:13 <newsham> *sigh*
23:50:15 <sorear> newsham: fixing termcap is a political issue.  Politics is harder than fixing curses, I believe.
23:50:23 <newsham> sorear: no its not.
23:50:36 <dons> sorear: there's no darcs repo for politics, and no maintainers
23:50:38 <newsham> man this argument is all over the place and none of the places are anywhere near factland.
23:50:40 <dons> so everyone runs their own fork
23:50:48 <dons> and no one merges patches back upstream
23:50:54 <dons> terrible development model
23:50:58 <nornagon> heh
23:51:02 <newsham> anyway..   so i wish there was a vty thing for windows.  i also wish vty wasnt specific to one terminal.
23:51:05 <newsham> EOF.
23:51:17 <sorear> ACK.
23:51:27 <dons> NAK
23:51:29 <nornagon> SYN
23:51:33 <sorear> SYN|ACK
23:51:46 <mbishop> RST
23:51:47 <nmessenger> WHY
23:51:53 <dons> ENOTCONN
23:51:57 * Vq^ is tempted to do an MCP EOL
23:52:07 <sorear> EOT
23:52:12 <Vq^> can't stop it...
23:52:13 <newsham> your URG pointer is all over my sliding window
23:52:22 <Vq^>           END OF LINE
23:52:41 <newsham> and your source route is loose
23:52:59 <sorear> some part of this needs to be @remembered
23:53:27 <NichardRixon> sleep time
23:53:42 <NichardRixon> my brain is feels like a salvadore dali painting
23:53:50 <NichardRixon> monads drooping all over the place
23:53:56 <Vq^> :)
23:54:10 <newsham> hello dahli
23:54:12 <NichardRixon> thanks for your help, don and nmessenger
23:54:21 <NichardRixon> s/dons/
23:54:37 <newsham> as it turns out "don" is dons name.
23:55:07 <mbishop> Donald
23:55:10 * glguy tries to imagine calling dons "Don" in person
23:55:14 <nmessenger> Always eager to help someone when I'm able.
23:55:28 <mbishop> McDonald
23:55:44 <newsham> O'McDonald?
23:56:42 <hpaste> I've handled 1000 requests since I last announced that I had hit 20000 :)
23:57:03 <dons> ok. good.
23:57:07 <newsham> > 1000 + 20000
23:57:09 <lambdabot>  21000
23:57:19 <nmessenger> glguy: are you !id-ing or does hpaste just do that?
23:57:27 <glguy> I'm doing that
23:57:30 <dons> glguy: i actually had people calling me 'dons' in Nice :}
23:57:33 <astrolabe> I'm visiting Oxford today.  Does anyone have ideas of good computer books I could buy?
23:57:46 <newsham> nice is nice
23:57:52 <jeeves_bond> Thanks for the help guys, I love the sound of just hacking away (Service provider crapped out, so only just got all your comments!)
23:57:53 <glguy> astrolabe: you want to buy my ideas?
23:58:15 <astrolabe> glguy: what's the going rate?
23:58:16 <dons> astrolabe: you could talk to the oxford guys
23:58:21 <dons> dcoutts, Igloo around?
23:58:34 <dons> know some good bookshops in oxford for CS stuff?
23:58:40 <glguy> astrolabe: I work on an auction model
23:59:16 <astrolabe> dons: there is an amazing technical bookshop there called blackwells.  It is vast, and seems to have most books :)
23:59:50 <jeeves_bond> It was just all the stuff on category theory on the wikibooks page that scared the crap out of me. Suppose I can learn that later. :)
