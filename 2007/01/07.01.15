00:13:53 <sorear> I finally think I understand @pl's modus operandi...  the level of accidental complexity is amazing.
00:31:32 <earthy> oleg's type trickery continues to amaze me
00:32:33 <glguy> which trick?
00:37:38 <earthy> this time it was the trick for adding constraints to a rank-2-polymorphic function
00:37:48 <earthy> type class constraints, that is
00:37:56 <dancor> are run{,Interactive}Process actually different
00:38:11 <dancor> or is it just semantic
00:38:19 <glguy> earthy: link?
00:38:32 <earthy> glguy: it was on the mailinglist, last friday
00:38:57 * dancor cannot decide if he meant semanticS or actually syntactic
00:39:16 <earthy> 'the mailinglist' being one of [haskell, haskell-prime, haskell-cafe, glasgow-haskell-users, glasgow-haskell-bugs]
00:39:37 <earthy> http://www.haskell.org/pipermail/haskell-cafe/2007-January/021306.html
00:39:39 <lambdabot> Title: [Haskell-cafe] MapTuple is possible and easy, http://tinyurl.com/ymuxzd
00:39:40 <earthy> there, that one. ;)
00:44:10 <Saizan> it feels scary to map a constructor/data to get the mapping of a function
00:56:05 <zeeeee> i have a question about my function: modifyFile f path = do contents <- BS.readFile path; contents `seq` BS.writeFile path $ f contents
00:56:36 <sorear> yes?
00:56:45 <glguy> the seq just caused the (:) to be evaluated
00:56:47 <sorear> (you shouldn't need the seq, btw)
00:56:48 <glguy> not the whole list
00:57:01 <zeeeee> right, it's left over (i remember sjanssen pointing this out earlier)
00:57:04 <sorear> glguy: what do you think BS. standa for
00:57:10 <zeeeee> :)
00:57:13 <zeeeee> i want to allow myself to throw exceptions
00:57:17 <zeeeee> from f
00:57:24 <sorear> ok
00:57:26 <zeeeee> and i would like the file not to be clobbered
00:57:27 <glguy> sorear: blargh
00:57:35 <sorear> :)
00:57:42 <zeeeee> unfortunately, as my program stands, the file is getting clobbered
00:57:43 <glguy> Thre aren't lazy bytestrings?
00:57:50 <zeeeee> i throwDyn MyEx
00:58:08 <sorear> zeeeee: you want to force the function before calling writeFile
00:58:12 <sorear> something like
00:58:30 <qwr> zeeeee: why don't you make f return IO something, if you want exceptions?
00:58:57 <sorear> qwr: imprecise exns, like array bounds errors
00:59:03 <zeeeee> qwr: i shouldn't need to be in IO to throw exceptions...
00:59:11 <sorear> you need to catch them for robustness' sake
00:59:42 <sorear> modifyFile f path = do contents <- BS.readFile path ; BS.writeFile $! f contents
00:59:45 <zeeeee> sorear: so i should f contents `seq` BS.writeFile?
01:00:19 <sorear> zeeeee: no, because the compiler will evaluate f twice that way
01:00:41 <sorear> zeeeee: $! is safe
01:00:44 <sorear> @src $!
01:00:44 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:00:46 <sorear> @src ($!)
01:00:47 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:00:59 <glguy> > seq (1 : undefined) 2
01:01:00 <lambdabot>  2
01:01:06 <glguy> seq doesn't really do much in this case
01:01:15 <sorear> glguy: these are bytestrings
01:01:16 <glguy> but does it cause the whole BS to eval?
01:01:21 <glguy> sorear: you didn't let me finish
01:01:27 <glguy> it's late I'm typing slower
01:01:34 <sorear> muahahaha
01:01:35 <zeeeee> sorear: oh, that brings up another question...is there some syntactic sugar like !contents <- readFile ... that does contents `seq` ...?
01:01:47 <sorear> zeeeee: why?
01:02:02 <sorear> bytestring.readfile isn't lazy
01:02:15 <zeeeee> sorear: well, i've seen these ! elsewhere (in data structure fields) but i'm not sure where else i can use them
01:02:22 <sorear> @src Data.ByteString.ByteString
01:02:23 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
01:02:31 <zeeeee> sorear: oh, i understand that...it's not for this case, but just a general question
01:02:36 <sorear> zeeeee: that's only place you can use them.
01:02:41 <sorear> (in H98)
01:02:54 <zeeeee> sorear: what about the ghc standard? :)
01:03:47 <sorear> in GHC function patterns can also use !
01:03:51 <sorear> like foo !x = bar
01:04:04 <zeeeee> ah
01:04:10 <sorear> needless to say, this causes problems with array!index = bar :)
01:04:35 <dancor> pretty printing a 2d array
01:04:39 <dancor> should i convert to a list?
01:04:41 <zeeeee> sorear: oh, i didn't know about that syntax for arrays..
01:04:51 <Jaak> @src seq
01:04:52 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
01:05:29 <sorear> zeeeee: it's not special syntax, it's just an operator named (!)
01:05:33 <dancor> @src concatMap
01:05:33 <lambdabot> concatMap f = foldr ((++) . f) []
01:05:52 <zeeeee> oh! i see :)
01:07:50 <dons> ?yow!
01:07:50 <lambdabot> UH-OH!!  I put on "GREAT HEAD-ON TRAIN COLLISIONS of the 50's" by
01:07:50 <lambdabot> mistake!!!
01:08:07 <dons> Jaak: seq is a primitive
01:08:07 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
01:08:18 <dons> 6 eh?
01:08:24 <dons> ?users
01:08:27 <lambdabot> Maximum users seen in #haskell: 303, currently: 278 (91.7%), active: 21 (7.6%)
01:10:39 <sorear> dons: running commentary: I've started seriously looking at the @pl module
01:10:50 <dons> ah nice
01:10:59 <dons> yes, step one should be to use Language.Haskell to parse it , I think
01:11:05 <dons> and then work out some new refacotrings
01:11:27 <dancor> it seems unduly hard to print a 2d array
01:11:34 <sorear> I've looked at language.haskell ... brain-explodey many constructors :)
01:12:45 <sorear> it's also occurred to me that there is a lot of commonality between the Yhc frontend and the @pl frontend
01:14:14 <dons> sorear: oh?
01:14:32 <dons> dancor: hmm, list comprehensions might be your friend there
01:15:05 <notsmack> > unlines $ map show test [[1,2,3],[4,5,6],[7,8,9]]
01:15:06 <lambdabot>   Not in scope: `test'
01:15:10 <notsmack> whoops
01:15:14 <notsmack> > unlines $ map show [[1,2,3],[4,5,6],[7,8,9]]
01:15:16 <lambdabot>  "[1,2,3]\n[4,5,6]\n[7,8,9]\n"
01:15:34 <sorear> massive desugaring, case reduction, many generic traversals  (actually any frontend, but Yhc seems the only one entering the library market)
01:16:04 <notsmack> though i guess you meant a real array :-)
01:16:12 <dancor> notsmack: yes, sadly
01:17:21 <dancor> it seems like converting to a list is no harder than printing
01:17:49 <ho_ho_ho> it looks more like a matrix rather than an array
01:17:55 <ho_ho_ho> beats me
01:22:26 <dancor> i guess i'll grab the vertical index range, then chop elems accordingly to get my list of lists
01:23:40 <Elifant> Hello all. I'm trying to parse string with parsec. String has form "some arbitrary text <<item 1>> more text <<another item>> text at the end". What I'm trying to get is [Text "some arbitrary text", Item "item 1", Text "more text", Item "another item", Text "text at the end"]. What is the prettiest way to do it?
01:24:17 <dancor> can items contain the string <<
01:24:26 <Elifant> no, they can't
01:24:43 <Elifant> and they are balanced for sure, for simplicity...
01:25:22 <Elifant> I've tried "many (anyChar); notFollowedBy (string "<<")" to get text blocks, but this doesn't work since I mixed "Parser Char" and "Parser String"
01:25:50 <Elifant> oops, many (anyChar; notFollowedBy (string "<<"))
01:26:04 <notsmack> Elifant: i had almost the exact same problem yesterday, and tried almost the exact same thing.
01:26:14 * notsmack is still thinking about it
01:31:00 <dons> sorear: any lambdabot patches on their way, or should i just bild with last nights stuff?
01:31:08 <sorear> urk, irssi learning curve...
01:31:12 <dons> hehe
01:31:30 * sorear was trying to ping the server
01:31:49 <sorear> dons: none really soon
01:32:06 <sorear> (and the next few will likely be @pl refactors)
01:32:31 <dons> ok
01:33:57 <alexj__> dons: just want to check in with you about http.
01:34:04 <earthy> Elifant: you're going about it the wrong way.
01:34:17 <earthy> notFollowedBy is for exceptional situations
01:34:32 <Elifant> I've found manyTill1, trying to use...
01:34:40 <Elifant> is this the right way?
01:35:01 <earthy> try to first tokenize the input string in characters and << and >> tokens
01:35:25 <sorear> dons: does hs-plugins eval use the native code generator or bytecode?
01:35:30 <earthy> then, on that token datatype (that distinguishes '<<' and '>>' from normal characters) define your parser
01:35:40 <dons> sorear: -fasm
01:35:48 <dons> alexj__: ah yes.
01:35:55 <dons> didn't get to hack on it for the hackathon
01:35:59 <dons> but worked on binary IO instead
01:36:03 <sorear> ooh interesting possibilities
01:36:17 <sorear> can fex. Java specialize functions at runtime?
01:36:18 <dons> however, I think we decided (with Bjorn) that taking apart HAppS http stuff is simpler than rewriting and fixing the existing 'http' package
01:36:26 <earthy> Elifant: check http://www.cs.uu.nl/people/daan/download/parsec/parsec.html for more info ;)
01:36:26 <Elifant> earthy: ye, it seems right. tnx.
01:36:48 <Elifant> earthy: it is already open :)
01:37:09 <dons> sorear: oh, do we need the time' library now?
01:37:15 <dons> what about on ghc 6.4.x ?
01:37:20 <alexj__> ok.  I believe that musasabi will be taking a crack at cleaning up some of the most recent http stuff over the next couple of days.
01:37:30 <sorear> oh
01:37:38 <sorear> I thought I checked...
01:37:46 <Elifant> earthy: but this string is just part of input, so have I to parse file using parsec, extract this string, lexify it and then parse it again? :)
01:38:27 <sorear> is time available as a separate package for 6.4?  or would it be better to rewrite the offending code using System.Time?
01:39:08 <dons> sorear: maybe
01:39:49 <dons> sorear: so i'll try to buidl, and let you know where it fails
01:39:53 <dons> Plugin/Activity.hs:9:7:
01:39:54 <dons>     Could not find module `Data.Time.Clock':
01:39:55 <dons> :)
01:40:05 <dons> maybe i can just install 'time though
01:40:07 <dons> ?where time
01:40:07 <lambdabot> I know nothing about time.
01:40:10 <dons> heh
01:40:18 <sorear> naw, it looks easy enough to fix
01:40:41 <sorear> rewriting using time gave me the opportunity to rethink the problem :)
01:42:15 <dons> ok. good
01:42:18 <dons> i'll wait then
01:42:52 <sorear> test-building...
01:45:52 <sorear> sent.
01:53:07 <earthy> elifant: yeah, you have to conceptually reparse the input
01:53:45 <earthy> however, due to the lazy nature of Haskell, the 'reparse' is just chained, so you really just run over the entire input just once
01:54:09 <earthy> anyway, time to help the students understand type inferencing
02:00:40 <psnl> earthy: got the tshirt?
02:03:41 <dancor> how do i include my own modules in ghci
02:05:41 <dancor> does it not take -i?
02:05:53 <dancor> no it does..
02:09:44 <dons> dancor: :l Foo.hs ?
02:10:26 <dons> sorear: so how do I put lambdabot in online mode now?
02:10:37 <dons> same as earlier this week? (is it just offline that changed?)
02:10:53 <sorear> dons: there should be a script named "online.rc"
02:11:21 <sorear> you'll need to create a "passwd.rc" with the contents "msg freenode:nickserv identify blahblah"
02:11:38 <dancor> dons: ah thanks
02:11:57 <sorear> then just ./dist/build/lambdabot/lambdabot -e 'rc online.rc'
02:12:09 <dons> ah ok
02:13:03 <dons> and offline mode?
02:13:15 <sorear> ./dist/build/lambdabot/lambdabot -e offline
02:13:19 <dons> cheers
02:13:26 <dons> better stick this in the readme.
02:13:46 <sorear> if you don't specify any -e options the bot will quit immediately (probably undesirable)
02:13:50 <dons> yeah
02:13:56 <dons> i think it should go into offline mode by default
02:18:18 <dons> sorear: so its 'rc online.rc' ?
02:18:31 <dons> not just say, -e online, to use the online.rc file?
02:18:47 <dons> i'd like lambdabot -e foo to just use foo.rc by default
02:18:56 <dons> we at least need to document the format of these rc files.
02:19:14 <sorear> it's just fed into the bot as offline-munged commands
02:19:33 <sorear> a lot like an .ircrc
02:19:36 <dons> what's the 'rc prefix in 'rc online.rc'
02:19:51 <sorear> the command
02:19:56 <dons> ah ok
02:20:00 <sorear> ./lambdabot -e yow runs @yow
02:20:05 <dons> ah right
02:20:09 <dons> so 'source' is now 'rc' ?
02:20:12 <sorear> yes
02:20:22 <dons> so why don't we need that for offline mode?
02:20:28 <dons> lambdabot -e offline
02:20:39 <sorear> because offline it itself a command
02:20:48 <dons> ah
02:21:08 <sorear> if you're feeling masochistic I suppose you could use -e 'rc /dev/fd/0' :)
02:25:11 <dons> sorear: hmm, so the passwd didn't run
02:25:16 <dons> ah well
02:26:03 <dons> ah maybe it did
02:26:06 <dons> just took a bit of time
02:26:07 <dons> ?version
02:26:07 <lambdabot> lambdabot 4p465, GHC 6.5 (OpenBSD i386)
02:26:08 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:26:16 <dons> ?src fmap
02:26:16 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
02:26:23 <dons> ?users
02:26:23 <lambdabot> Maximum users seen in #haskell: 286, currently: 285 (99.7%), active: 3 (1.1%)
02:26:28 <dons> oh, i had to zap the seen and vixen state
02:26:34 <dons> since the binary fomat changed too much
02:26:36 <sorear> right...
02:26:41 <dons> i'll need to reconstitute vixen later
02:26:53 <sorear> it connected to nickserv after autojoin was finished
02:27:01 <dons> ah ok
02:27:04 <sorear> (which incidentally is unbroken again)
02:27:05 <dons> so it takes a bit longer
02:27:08 <dons> great
02:27:11 <dons> ?seen lambdabot
02:27:11 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
02:27:14 <dons> ah good
02:27:17 <dons> that looks like everything
02:27:31 <sorear> @admin + sorear
02:27:32 <lambdabot> Not enough privileges
02:27:38 <dancor> unicycling!
02:27:57 <ohmega> yes unicycling! :)
02:27:57 <dons> yeah, i saw some other priv issues when I tried to @msg
02:28:03 <dons> @admin + sorear
02:28:03 <lambdabot> Not enough privileges
02:28:05 <dons> see
02:28:11 <dons> so maybe we have no admins..
02:28:29 <sorear> lambdabot starts up with 1 admin - the offline pseudo-user
02:28:48 <dons> but the rc file has a bunch of admin +'s
02:28:50 <sorear> iirc there are a bunch of 'admin + freenode:dons' in the rc file
02:29:00 <dons> yeah, which mm. didn't fire?
02:29:19 <sorear> oh looks like I forgot the servertags :)
02:29:39 <sorear> offlinerc:Cale, offlinerc:sorear, offlinerc:dons, etc.
02:30:18 <dons> ah
02:30:19 <dons> yeah
02:31:12 <sorear> patch sent.
02:32:27 <sorear> other feature to note:
02:32:33 <sorear> @activity 600
02:32:34 <lambdabot> 13*total 7*#haskell 3*#unicycling 1*sorear 1*nickserv 1*dons
02:32:45 <dons> mm?
02:32:46 <dons> ah
02:32:51 <dons> 1*dons eh?
02:32:57 <dons> so we can see who's privmgsing?
02:33:03 <dons> that's a bbit sneaky
02:33:07 <sorear> it works by target, not requestor
02:33:24 <dons> what's 600 ?
02:33:29 <dons> ?help activity
02:33:30 <lambdabot> activity seconds. Find out where/how much the bot is being used
02:33:40 <sorear> would it be a good idea to make it give a PRIVATE glomeration of all privmsgs?
02:33:49 <dons> maybe
02:33:54 <dons> but only for @privs I think
02:34:07 <sorear> @privs?
02:34:07 <lambdabot> Unknown command, try @list
02:34:30 <dons> only for those with admin powers
02:34:49 <sorear> you mean !admins, right ?
02:34:59 <sorear> not
02:35:21 <dons> well, those entiteld to get priv commands
02:35:31 <dons> i.e. @activity with privmsg stats should be privledged
02:36:12 <sorear> would it be better to make it silently choose, or make a special @activity-full?
02:36:30 <dons> either is ok
02:36:56 <sorear> I'll go with the latter.  less chance of inchannel fumbling.
02:48:08 <sorear> a couple patches have been sent ( @activity privacy, startup fixes )
02:48:49 <sorear> interesting feature combination: offline & online aren't exclusive - you can run a readline prompt while connected to the server
02:49:18 <sorear> It is 3am and I ought to sleep.  Going down for halt in 30s.
02:49:43 <dons> ok.
02:49:51 <dons> huhreally
02:49:54 <dons> that's super cool
02:50:03 <dons> so i can tweak the bot from readline?
02:50:05 <dons> and mess with its state?
02:50:13 <dons> like have it connect to things
02:50:16 <sorear> yes
02:50:21 <dons> very nice
02:50:23 <dons> sorear++
02:50:32 <sorear> it's all ordinary commands, nothing you couldn't do via irc
02:50:37 <dons> yeah
02:50:43 <dons> except i guess i always have privs
02:50:44 <sorear> but you don't have to worry about flood control
02:51:00 <sorear> and it's synchronous
02:52:29 <dons> hmm. something funny going on
02:52:32 <dons> 'exception' :/
02:52:38 <sorear> not again :(
02:52:43 <dons> yikes!
02:52:44 <dons> exception:
02:52:44 <dons> zsh: segmentation fault (core dumped)  ./lambdabot
02:52:55 <dons> i'll try rebuilding
02:53:28 * sorear wonders how long a full 'bot build takes on the 16-core bot host
02:53:44 <nornagon> dons: you going to any LCA stuff? :)
02:53:51 <dons> nah, i'm in .fr
02:53:55 <dons> so a bit hard to make it
02:53:59 <dons> otherwise i would
02:54:00 <mux> dons!
02:54:03 <dons> i note that desrt will be there
02:54:03 <mux> you're in .fr ?
02:54:04 <nornagon> :(
02:54:08 <dons> yeah , in Nice
02:54:13 <mux> ah, for the DAMP
02:54:13 <nornagon> what are you doing in .fr?
02:54:23 <mux> I would have given an arm and a leg to be able to come ethere
02:54:24 <dons> nornagon: so go see desrt, he's the HoP haskell OS guy
02:54:30 <nornagon> HoP?
02:54:32 <mux> I wanted to hear about simon's paper on parallellism
02:54:33 <dons> nornagon: yeah, for a conference
02:54:37 <nornagon> I met one haskell guy
02:54:37 <dons> the haskell Os
02:54:39 <sorear> oh it's a nick
02:54:41 <mux> dons: coming to Paris after that? :)
02:54:43 <dons> nornagon: also, ozone is there
02:54:53 <dons> mux, unfortunately no :(
02:54:59 <mux> too bad
02:55:00 <nornagon> dons: oh, that might have been the guy i met; is he speaking?
02:55:05 * sorear though desrt was something you ate after missing an e
02:55:12 <dons> I think both desrt and ozone are speaking
02:55:16 <dons> 'Ryan Lortie', iirc
02:55:26 <mux> will you attend to simon peyton jones conf?
02:55:29 <dons> kfish is there too I think
02:55:38 <nornagon> kfish? rly?
02:55:42 <dons> mux, yeah, I'll be there
02:55:45 <nornagon> i think he's living in .jp these days
02:55:46 <dons> nornagon: I think so
02:55:52 <dons> yeah, he's back in jan tho
02:55:53 <mux> lucky you
02:55:54 <dons> @seen kfish
02:55:55 <nornagon> but he might've come back
02:55:56 <nornagon> ah
02:55:57 <mux> $530
02:56:03 <nornagon> 'k :) I'll look out for him.
02:56:19 <dons> yeah, the talks have been good so far
02:56:21 <nornagon> dons: who's doing the "how FP matters to the kernel" talk? desrt?
02:56:25 <dons> John hughes talked about quickcheck
02:56:27 <nornagon> because i met him today :)
02:56:31 <dons> then we saw the erlang bitstream talk
02:56:38 <dons> very much like the new 'binary' library we're hacking on
02:56:45 <sorear> yeah ... when I figured out the how netsplit killed the bot my immediate reaction was @tell :)
02:56:46 <dons> duncan gave the bytestring fusion talk
02:56:52 <dons> sorear: heh
02:56:55 <dcoutts__> @arr
02:57:11 <dons> sorear: bot instability?
02:57:14 <dons> ah no bot. of course
02:57:42 <dcoutts__> @botsnack?
02:57:45 <sorear> dons: did you see Udo Stenzel's post wishing for a general StorableString?
02:58:03 <dcoutts__> sorear: I did, yeah, ask sjanssen he's done it already of course
02:58:17 <dons> sorear: haven't read through that
02:58:25 <dcoutts__> not that it's all the useful for UTF-whatever
02:58:28 <dons> ?version
02:58:37 <dcoutts__> it's fine for UTF-32 but not for 16 or 8
02:58:42 <lambdabot> lambdabot 4p469, GHC 6.5 (OpenBSD i386)
02:58:48 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
02:58:51 <sorear> @activity
02:59:02 <lambdabot> 3*total 2*#haskell 1*private
02:59:02 <dons> @msg foo
02:59:10 <dons> ok good.admin issues fixed
02:59:13 <dcoutts__> what we need is Data.PackedString.{UTF8,UTF16,UTF32}
02:59:28 <sorear> I also rearranged things so that /msg nickserv happened before the joins
02:59:41 <dcoutts__> and it should be fusible, and not too hard, it's just changing the read/write functions to also decode/encode
03:02:11 <dons> ?version
03:02:11 <lambdabot> lambdabot 4p469, GHC 6.5 (OpenBSD i386)
03:02:11 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:02:17 <dons> ?users
03:02:17 <lambdabot> Maximum users seen in #haskell: 286, currently: 278 (97.2%), active: 3 (1.1%)
03:02:32 <sorear> In a group musing session yesterday, it was proposed to create a newtype of LB, wrap only legitimate commands, and make @run do all the command work.
03:03:02 <dons> mm
03:03:14 <dons> so what does that give us?
03:03:33 <sorear> @unpl =<< pl
03:03:33 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
03:03:49 <sorear> no need to re-invent combinatory logic
03:03:55 <dons> ah ok
03:04:07 <dons> so that would expose the inbuilt LB commands to @run
03:04:10 <dons> you think?
03:04:19 <dons> I'm not sure I could get this to work when I tried it once before
03:04:25 <dons> but maybe there's a trick I'm not thinking of
03:05:28 <sorear> of course there is also @mapM_ (remember "ENOSPC" . show) [0..]
03:07:17 <dons> lunch time!
03:07:41 <sorear> where?
03:09:39 <bakert> good morning all.  having a problemette installing Network.FastCGI.  If I have fps installed it tells me "it was found in multiple packages: fps-0.8 base" but if I ghc-pkg unregister fps-0.8 then I get " cannot satisfy dependency fps-any"
03:09:41 <bakert> any ideas?
03:10:00 <bakert> ah hang on ... i bet i just remove the dependency from the cabal file, right?
03:10:03 <sorear> bakert: uninstall ghc-6.6
03:10:09 <sorear> or remove the dep
03:10:37 <bakert> I can't uninstall 6.6 I need the time stuff, and Text.XHtml
03:10:40 <sorear> Cabal for some weird reason has no Provides:
03:11:08 <bakert> ah yes it is behaving nicer now i have remove fps from depends.  sorry.  still getting used to cabal.
03:11:18 <sorear> you shouldn't have to
03:11:23 <bakert> oh
03:11:24 <sorear> cabal should have provides:
03:11:41 <bakert> oh i see "shouldn't" as in "in an ideal world"
03:11:53 <sorear> yeah
03:15:07 <bakert> have hit another block.  "error: fcgiapp.h: No such file or directory".  Do I need some general C files to make it work?
03:18:35 <bakert> Aha, it is provided by libfcgi-dev (on Ubuntu, at least).
03:47:13 <Hunter_wow> how do I stop "cycle"? It never returns to en empty( [] ) list . .
03:47:20 <Hunter_wow> *an
03:47:48 <notsmack> Hunter_wow: stop it?
03:48:19 <notsmack> > take 10 $ cycle [1,2,3]
03:48:21 <lambdabot>  [1,2,3,1,2,3,1,2,3,1]
03:48:42 <Hunter_wow> aha, yea, thanks a lot, that should do it!
04:03:20 <psnl> dcoutts_: any ideas about fixing a Bus error with gtk2hs on os X?
04:12:27 <earthy> psnl: I'm not mean. :)
04:12:36 <earthy> so, no, I don't have the t-shirt
04:22:14 <lisppaste2> Hunter_wow pasted "rotate a list" at http://paste.lisp.org/display/35366
04:22:47 <ndm> dcoutts_: and what do you want me to do with the beautiful and broken sample code with inputAdd using Gtk2Hs?
04:23:12 <ndm> dcoutts_: on the basis that if you fix it, i can write GuiHaskell, and our GUI users will smile muchly
04:23:35 <ndm> dcoutts_: (once you get back from your free holiday, of course)
04:23:54 <emk> Is there a way to uninstall the official MacOS X packages for Haskell?
04:26:51 <george--> Hunter_wow, what is nub?
04:28:08 <ndm> @src nub
04:28:08 <lambdabot> nub = nubBy (==)
04:28:09 <amiddelk> george--: nub is a function in the Data.List module that removes duplicates
04:28:14 <ndm> @src nubBy
04:28:14 <lambdabot> nubBy eq []             =  []
04:28:14 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
04:28:17 <george--> and rot is rotate? (the error refers to rot) the code refers to rotate
04:28:42 <Botje> too bad nub is slower than map head . group . sort
04:29:07 <Botje> (but that requires Ord, not just Eq)
04:29:09 <ndm> Botje: i have that defined as snub
04:29:22 <ndm> Botje: and i think it should be added to the standard libraries, so you should propose it!
04:29:28 <george--> Hunter_wow, tried: rotate :: (Eq a) => [a] -> [[a]]
04:29:32 <george--> in the definition?
04:29:48 <george--> it compiles atleast for me with that, i dont know if it does what you expect though
04:30:22 <Hunter_wow> george-- hmm, dont know, but used nub to take away all the extra list replicateM makes
04:30:56 <Botje> :t all (/=)
04:30:57 <lambdabot>     Expecting a function type, but found `Bool'
04:30:58 <lambdabot>       Expected type: a -> Bool
04:31:06 <Botje> dammit :(
04:31:08 <Hunter_wow> george-- but in second thought it will be wrong when I get a list with same 2 of the same element
04:32:45 <mq_mattr> any hac07 'ers with us?
04:32:56 <Igloo> mq_mattr: What's up?
04:33:02 <george--> well... i haven't really tried to nderstand the code... but the error can be solved with rotate :: (Eq a) => [a] -> [[a]
04:33:18 <mq_mattr> I am insanely jealous since dons posted his pics
04:34:17 <syntaxfree> existential types confuse me.
04:34:47 <mq_mattr> me too
04:34:50 <mq_mattr> :)
04:35:17 <Igloo> mq_mattr: On planet.haskell.org?
04:35:30 <mq_mattr> Igloo: yep
04:35:46 <syntaxfree> GADTs look pretty much like type classes to me as well.
04:35:50 <mq_mattr> I think - it appeared in my feeds, I didn't pay attention to where it came from
04:36:17 <mq_mattr> GADT's are a whole other thing - you need to sneak up on them
04:36:38 <mq_mattr> if you frighten them, they confuse you :)
04:36:43 <syntaxfree> the standard examples are somewhat silly.
04:36:45 <Hunter_wow> george-- true, it compiles now, thanks, just have to modify it a bit =)
04:37:57 <mq_mattr> syntaxfree: depends on what you need - if you have never hit the use cases (I hate that term, but can't think of a better on) in anger, they will seem silly, but they certainly have a use.
04:38:33 <syntaxfree> I think I need dependent types of some sort.
04:38:48 <syntaxfree> I'm trying to think up a way of doing my dissertation in Haskell.
04:39:03 <mq_mattr>  syntaxfree: what do you need dependent types for
04:39:05 <mq_mattr> ?
04:39:27 <syntaxfree> mathematically well-specified economic simulation models.
04:39:45 <syntaxfree> most simulation models in economics still follow a "Fortran" approach to it.
04:39:53 <mq_mattr> Igloo: can you tell me more about hac?
04:39:57 <syntaxfree> implementation too distant from specification.
04:40:32 <mq_mattr> syntaxfree: I think there is a long way you can go before you need dependent types
04:41:09 <syntaxfree> Haskell, for what I've seen so far, seems ideal to have an implementaiion that's very close to an abstract mathematical specification.
04:41:22 <mq_mattr> someone with more experience of them might give you different advice, but I would suggest you only consider exotic type system things once you find something specific you can't do without them
04:41:30 <syntaxfree> mq_math: well, sure. Good programs are written in languages with very few types altogether.
04:41:42 <syntaxfree> I've been stumbling into these since day one with Haskell :)
04:41:46 <syntaxfree> I just postponed it.
04:42:03 <Igloo> mq_mattr: We'll probably try and write something about it shortly
04:42:17 <mq_mattr> syntaxfree: You may well be right about Haskell being a good choice, but there are other considerations with a disertation - like what kind of expertise you have around you.
04:42:18 <emk> syntaxfree: Yeah, Haskell feels very mathematical.
04:42:45 <mq_mattr> a poor language becomes a good language if there is a guru sitting next to you
04:43:11 <syntaxfree> mq_mattr: well, I have been working on Haskell for the last six months, rather than my dissertation, and it seems painful to return to research now that  time is starting to press.
04:43:36 <syntaxfree> I mean, it's rather unexpected, in my area, to write dissertations about computer-based models.
04:43:37 <mq_mattr> I could make magic in VBA when a certain colleague was working and I could barely get going without him :)
04:43:51 <mq_mattr> sytaxfree: more info please
04:44:09 <syntaxfree> But somehow, I need to conciliate this bottomless enthusiasm for functional programming with the hard fact that I need to graduate at some point!
04:44:32 <mq_mattr> sytaxfree: computer/finance intersections are not completely uninteresting to me since I have a commerce degree and did some work on derivative models once
04:44:45 <syntaxfree> ah. I'm an economist trying to get my Masters and trying to get the pluck out of academia.
04:44:57 <mq_mattr> get the pluck?
04:45:00 <syntaxfree> I'm supposed to be working on something rather more theoretical.
04:45:14 <syntaxfree> pluck is an ersatz substitute for a rude expletive that rhymes with it.
04:45:35 <syntaxfree> Anyway, my original intention is to work with optimal contracts under assymetric information.
04:45:41 <mq_mattr> Isn't economics a fundamentally empical science?
04:45:46 <george--> ok, im writing a kinda mini-essay and i just wanted to check some terminology... if my program has some parts in IO monad and some parts not... the other parts can be referred to as 'pure' ? or is there an alternative or better word?
04:45:48 <syntaxfree> No, it isn't :)
04:46:00 <syntaxfree> in fact, empirical methods in economis are bolted-on and questionable.
04:46:10 <lisppaste2> Hunter_wow annotated #35366 with "rotate list, still dosent work" at http://paste.lisp.org/display/35366#1
04:46:15 <mq_mattr> george: pure is a good choice of terminology
04:46:36 <syntaxfree> I love econometrics, love the technical aspects of it, know more econometrics that about 9/10 of the profession, but it's really not "real".
04:46:38 <mq_mattr> syntaxfree: ahhh - I just read freakonomics
04:46:38 <george--> thank you
04:46:46 <mq_mattr> syntaxfree: thought it was crap
04:46:48 <george--> Hunter_wow, please explain in words what you want your function to do?
04:46:54 <syntaxfree> ah, yes. freakonomics is basically a bunch of fun econometric exercises.
04:47:08 <syntaxfree> They have little foundation in economic theory. I think it's pretty good, though.
04:47:12 <mq_mattr> syntaxfree: and they are very poorly done
04:47:21 <emk> syntaxfree: Which is weird, when you think about it. There's a lot of good empirical work being done in economics, but it doesn't seem to be thought very highly of.
04:47:26 <syntaxfree> Econometrics provides an unambiguous framework for statistical analysis with very limited data.
04:47:35 <Hunter_wow> george-- rotate [1,2,3] -> [[1,2,3],[2,3,1],[3,1,2]]             like that
04:47:50 <george--> right
04:47:56 <syntaxfree> emk: well, "economics", like "computer science", is a wide subject with a wide range of interests.
04:48:18 <syntaxfree> emk: from macroeconomic policy-making to deep game theory to etc. etc.
04:48:32 <syntaxfree> Basically, I'm kinda committed to writing about insurance contracts.
04:48:45 <syntaxfree> Insurance contracts have to be designed to cope with adverse selection, moral hazard, etc.
04:49:02 <mq_mattr> syntaxfree: yeah - but I thought none of the points in the book were well made.  I was willing to buy into his approach, but it never achieved the "proof" or even strong suggestion of his hypothsies
04:49:04 <emk> syntaxfree: The weirdest bit is that the policy folks don't seem to listen all that much to the empirical folks, at least in some parts of the world.
04:49:33 <mq_mattr> syntaxfree: my first degree was in actuarial studies, so I am very familiar with insurance contracts
04:49:46 <syntaxfree> There are good game-theoretical models of such, but at some point they start to make very bad assumptions so models are analytically solvable.
04:50:24 <syntaxfree> mq_mattr: well, that's kinda the other point of view. A computer program is one thing to some programmer working on an AS/400 in a big bank and to, say, Erik Meijer.
04:50:43 <syntaxfree> er, another thing to Erik Meijer.
04:51:18 <syntaxfree> emk: depends. Policy-making folks are going to enforce the kinds of policies they're already gonna to, because that's politics.
04:51:31 <george--> Hunter_wow, so, what your actual code does is just makes every possible combination of the input list contents
04:51:33 <syntaxfree> emk: but a lot of empirical estimation is done to decide on ammounts.
04:51:36 <george--> you get that too i assume (hope?)
04:51:46 <mq_mattr> syntaxfree: I know, I agree there are many points of view on the data, I just think that book does not uniformly present compelling material.  2 of the chapters are good, and the rest are a real stretch
04:51:50 <Hunter_wow> yea
04:52:02 <syntaxfree> if the Fed is wanting to raise the interest rate, no econometric model is gonna persuade them otherwise.
04:52:14 <syntaxfree> But they do a lot of simulations to see if they rase half a point, a full point, etc.
04:52:57 <syntaxfree> s/rase/raise.
04:53:26 <mq_mattr> syntaxfree: but none of the simulations mean anything since they are so full of untested (indeed plainly unreasonable) assumptions that the data you get out means nothing more than an educated guess would
04:53:28 <syntaxfree> anyway, I need to "sell" this project to my department.
04:53:56 <syntaxfree> mq_mattr: not really. stuff works out quite well, sp. in developed countries.
04:54:47 <syntaxfree> predictions break more for third world countries for a number of reasons -- not the least of which being that theoretical models are generally built by economists from developed countries looking at the kinds of problems they face.
04:54:55 <Hunter_wow> george-- but a bit less with nub. But when I make nub at it I might lose lists who should stay, but should be possible to solve with list comprehension somehow I think
04:55:03 <mq_mattr> syntaxfree: I don't mean taht they don't work, I mean they are no better than an educated guess
04:55:27 <syntaxfree> ah, they are. Educated guesses have trouble working with large-equation systems :)
04:55:44 <mq_mattr> syntaxfree: in fact, in many cases I would say they are just a codification of the economists 'educated guessing proccess'
04:55:47 <syntaxfree> anyway, I need to sell this project to my department, and I'd better make it as theoretically interesting as humanly possible.
04:55:55 <syntaxfree> I don't need "practical".
04:56:25 <syntaxfree> mq_mattr: You're starting out with a few mistaken epistemological positions, regarding economics.
04:56:43 <mq_mattr> syntaxfree: I don't mean to be down on economics, in fact I think research into economics is bloody vital exactly because of these points
04:56:53 <syntaxfree> Economics is both a success as an explanatory science and a failure as a control engineering discipline.
04:56:54 <mq_mattr> syntaxfree:  you may be right
04:57:22 <syntaxfree> Many people from the harder sciences have trouble seeing how this can be, as for them the connections (say, physics -> civil engineering) are direct.
04:57:40 <mq_mattr> syntaxfree: perhaps a better way to put it is that I am describing popular economics, not real economics?
04:58:20 <syntaxfree> hmm. have you read Krugman's "Pop internationalism"?
04:58:30 <syntaxfree> "Peddling prosperity" is good too, but it's a bit too long.
04:58:34 <mq_mattr> nope, tell me more
04:59:13 <syntaxfree> well, both books are basically the point of view of an academic economist denouncing "fake" economics cooked up to justify economic polciies.
04:59:29 <syntaxfree> Supply-side economics, strategic trade economics, etc. etc.
04:59:34 <mq_mattr> aha - they sound good
04:59:37 <syntaxfree> Too bad Krugman later became an antirepublican bot.
04:59:52 <mq_mattr> more like what I am interested in - critical analysis
05:00:04 <mq_mattr> what is 'antirepublican'
05:00:11 <mq_mattr> in oz that means you love the queen
05:00:15 <mq_mattr> :)
05:00:23 <allbery_b> US politics
05:00:26 <mq_mattr> aha
05:00:57 <mq_mattr> it always struck me a strange that the party names are so completely non-descriptive
05:01:05 <mq_mattr> us is already a democratic republic
05:01:07 <syntaxfree> Krugman is limited as a theoretician, but these two books are the best I know in pointing out to laymen that "real"economics is rarely easily connected to policy-making.
05:01:29 <syntaxfree> "Democracy" and "Republic" are subtle, but very different concepts.
05:01:38 <mq_mattr> enlighten me
05:02:02 <emk> Yay! ghc 6.6 installed and running!
05:02:10 <emk> Now to get gtk2hs building.
05:02:16 <syntaxfree> Anyway, to end the Krugman subject, for one, the very same general equilibrium models that have been used since the 70s to ground strongly market-oriented economics have been used in the 30s to defend USSR-level socialism.
05:02:44 <mq_mattr> I know they mean completely different things, but US is firmly planted in both and so the names seem strange
05:02:47 <syntaxfree> General equilibrium models have the deepest mathematics of all economics.
05:03:02 <mq_mattr> amk: yay for 6.6
05:03:20 <syntaxfree> (well, yes. dems wanto emphasize one thing -- more collectivist aspects -- and republicans want the state to manage what is common and leave the rest alone)
05:03:38 <mq_mattr> emk: I would love to hear from someone using ght2hs 'in anger'
05:03:46 <syntaxfree> GE models are this deep, deep formalization of the adamsmithian intuition of an invisible hand.
05:03:52 <allbery_b> mq_mattr: it's deliberately vague enough to let them not commit to a particular platform :)
05:03:55 <mq_mattr> s/ght2hs/gtk2hs
05:04:02 <emk> mq_mattr: I just want the Cairo bindings, because someone wrote a Haskell charting library that needs them.
05:04:18 <mq_mattr> emk - ah ok
05:04:24 <syntaxfree> under very strong assumptions of perfect competition and symetric information, market-based results are impressive.
05:04:32 <mq_mattr> emk: charting - you mean gnuplot stuff?
05:04:43 <emk> If I were building a GUI, I'd investigate wxHaskell first, because wxWidgets has rocked my world on C++ projects.
05:04:58 <syntaxfree> the argument from the 30s was, however, that there are too many monopolies, so socialism can employ the theoretical knowledge of how the invisible hand should be working and impose market-like results from above!
05:05:28 <syntaxfree> so, um, the very same theoretical frameworks can be used to ground quite different approaches to policy-making.
05:05:33 <emk> mq_mattr: Somebody wrote a really shiny Haskell charting library that called directly into Cairo.
05:05:44 <syntaxfree> that's what most noneconomists don't understand.
05:05:47 <mq_mattr> syntaxfree: can market driven approaches price intangibles without govt intervention
05:06:04 <mq_mattr> emk: allright, I am checking that out - what is it called
05:06:07 <george--> Hunter_wow, i cannot see a way to do this with nub to always work how you want...
05:06:12 <syntaxfree> mq_mattr: yes. the problem is that not everything has clear property rights.
05:06:27 <emk> syntaxfree: So it would be wise to be cautious about the claims of people with both agendas and economic models? :-)
05:07:01 <mq_mattr> syntaxfree: so you need some property model for air quality and things like that?
05:07:03 <syntaxfree> anyway, JM Keynes is basically right, Milton Friedman is basically right, Piero Sraffa is basically right, Robert Lucas is basically right, Greg Mankiw is basically right, etc.
05:07:24 <emk> mq_mattr: Don't remember the name. I'll google it again when I'm done getting gtk2hs to build.
05:07:25 <syntaxfree> They just start emphasizing aspects of the theory differently when they start using it to propose economic policies.
05:07:33 <leed> @doc MonadPlus
05:07:34 <lambdabot> MonadPlus not available
05:07:40 <mq_mattr> emk: cheers
05:07:45 <syntaxfree> mq_mattr: yes. The Kyoto protocol is a stab at a property model for air quality.
05:08:00 <mq_mattr> syntaxfree: you know, pl choice sounds like that
05:08:45 <mq_mattr> when someone tries to convince me ruby is my new religion, they just emphasise the good things it has a devalue the good things Haskell has
05:08:57 <syntaxfree> anyway, do you see how the very same model of how the invisible hand works in perfectly competitive markets can be used to justify entirely different pollicy models?
05:09:04 <mq_mattr> indeed
05:09:12 <emk> When building gtk2hs, I get:
05:09:14 <syntaxfree> the socialists emphasized how strong the perfect competition assumptions were.
05:09:14 <emk> tools/c2hs/base/general/Binary.hs:59:7:
05:09:15 <emk>     Could not find module `Data.FiniteMap':
05:09:35 <mux> maybe FM has been removed in GHC 6.6? it was deprecated before
05:09:37 <syntaxfree> and then they said "hey, but now that we know how the invisible hand works, we can get Central Planning to enforce i!"
05:09:59 <mq_mattr> emk: yep - its gone
05:10:02 <emk> mux: What should be used instead?
05:10:03 <syntaxfree> in the 70s, market-oriented economists trying to reduce government activism did the opposite.
05:10:13 <emk> gtk2hs is broken under DarwinPorts. :-(
05:10:17 <mq_mattr> good question
05:10:33 <syntaxfree> They emphasized how well-intentioned intervention efforts has disparate systemic effects.
05:10:40 <mq_mattr> check the gtk2hs lists/forums to see if anyone else has come accross this
05:11:11 <syntaxfree> Same theoretical model -- it's basically right, unless someone in symplectic manifold theory has screwed up  -- different policy proposals.
05:11:17 <emk> mq_mattr: It's not clear that the latest released version of gtk2hs is even expected to build with GHC 6.6. I probably need the Darcs version.
05:11:45 <mq_mattr> emk: yep - I think that's a good idea
05:11:53 <mq_mattr> emk: welcome to the bleeding edge
05:11:55 <mq_mattr> :)
05:12:28 <emk> Ah, Data.FiniteMap has been replaced by Data.Map.
05:12:36 <mq_mattr> all-right, that was a bit disingenuous, I implied I am at the bleeding edge, but I am actually in the comfy chair
05:13:21 <mq_mattr> emk: so the gtk2hs boys should have a fix for that - can't be a hark patch if the semantics are the same?
05:13:28 <syntaxfree> anyway, "I'm going to write a program that simulates stuff" doesn't cut it as a dissertation.
05:13:40 <syntaxfree> So I want to make it every bit as theoretically interesting as possible.
05:13:41 <emk> syntaxfree: More's the pity.
05:14:06 <mq_mattr> syntaxfree: really, you need to switch to a computing dept - that will easily fly in computing :)
05:14:06 <syntaxfree> Leave a very general framework open for further development.
05:14:26 <emk> And I suppose that including some gratuitous category theory won't work either (though it seems to in CS).
05:14:32 <syntaxfree> that means, all type declarations, no functions :)
05:15:06 <mq_mattr> emk: yeah - abstract nonsense is gold in dissertations :)
05:15:30 <syntaxfree> emk: it could, but first I have to explain what category theory is.
05:15:51 <syntaxfree> There is some research on category-theoretical reformulations of game theory, but no one at my school knows of it.
05:16:20 <emk> mq_mattr: Of course, the Haskell researchers have very nearly found the Holy Grail of CS: Their papers are both theory heavy and extremely practical.
05:16:20 <syntaxfree> I'd also have to learn a lot more about cat theory to prove Deep Theorems. I don't have the time anymore, and frankly I like to hack.
05:17:40 <syntaxfree> so basically I'm thinking of concocting a huge type model for assymetric information modelling.
05:17:40 <syntaxfree> I need every bit of cool type hackery I can fit into it.
05:17:40 <syntaxfree> :)
05:18:34 <mq_mattr> A Very Modal Model of a Modern, Major, General Type System
05:18:40 <mq_mattr> now that is a paper title :)
05:18:47 <mq_mattr> http://www.ccs.neu.edu/home/dherman/popl2007.html
05:18:49 <lambdabot> Title: POPL 2007: Preliminary Program
05:18:53 <mq_mattr> thanks to the little calculist
05:19:05 <syntaxfree> (then I'll have to write interminable chapters explaining what FP is, what types are, etc. etc.)
05:19:20 <emk> syntaxfree: The inductive inference people did some nice papers for machine learning along those lines: "Here's a set of typeclasses that correspond to very kinds of statistical models, etc."
05:19:23 <syntaxfree> FP paper ttitles are cool.
05:19:45 <emk> "Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire" may be the best.
05:19:55 <mq_mattr> an interesting sounding invided talk "Advanced Programming Languages in Enterprise Software: A lambda-calculus theorist wanders into an enterprise datacenter"
05:20:03 <bakert> ?paste
05:20:03 <lambdabot> http://paste.lisp.org/new/haskell
05:20:05 <syntaxfree> emk: oh. that's cool. I thought of doing something like that at some time, but I'm committed to insurance, for a variety of reasons not worth mentioning.
05:20:19 <syntaxfree> emk: "Theorems for free!" is the ultimate best.
05:20:31 <syntaxfree> I actually got attracted into Haskell because of that paper.
05:20:33 <pejo> mq_mattr, why would you waste yoru time writing nonsense in your dissertation?
05:20:36 <lisppaste2> bakert pasted "Save me from my retarded understanding of Text.XHtml" at http://paste.lisp.org/display/35370
05:20:43 <emk> Yeah, and gets cited all the time--those free theorems show up in a lot of later proofs.
05:20:59 <bakert> Anyone know how to combine the various functions of Text.XHtml without going insane?
05:21:07 <syntaxfree> I wish I coud publish a paper in crime economics called "Fuck tha police".
05:21:09 <bakert> I really am just being so thick about this one.
05:21:14 <mq_mattr> pejo: not really, abstract nonsense is a semi-joking term for tougher category theory stuff
05:21:36 <syntaxfree> I mean, "Fuck tha police!"
05:22:05 <bakert> with the first line: "fuck tha police coming straight from the underground young niggaz got it bad cuz they brown"?
05:22:07 <emk> syntaxfree: http://www.csse.monash.edu.au/~lloyd/tildeFP/II/
05:22:08 <lambdabot> Title: Inductive Inference
05:22:34 <bakert> (now i read that back i think i must have been mishearing the lyrics all this time)
05:22:42 <bakert> (cuz they down?)
05:23:00 <mq_mattr> bakert: sorry chap, I don't know anything about XHtml, but I love the paste name
05:23:14 <emk> syntaxfree: A nice example of building a general framework by getting the typeclasses right.
05:23:23 <bakert> mq_mattr, np.  it is dead dead simple but no amount of brackets can make my code work.
05:23:33 <bakert> mq_mattr, it causes great despair.
05:27:21 <mq_mattr> bakert: I had a quick look at XHtml, could you explain what the <<'s do?
05:28:19 <notsmack> mq_mattr: they specify that an element contains other content
05:28:31 <mq_mattr> aha!
05:28:45 <notsmack> p << stringToHtml "this would be in a <p>"
05:29:09 <bakert> i think my problem is that header acts differently to how i think it does.
05:29:16 <bakert> becuase "page t b = thediv << (p << "hello" +++ p << "goodbye")"
05:29:17 <bakert> works
05:29:18 <bakert> but
05:29:24 <bakert> page t b = header << (thetitle << t +++ thelink)
05:29:27 <bakert> does not
05:29:36 <apfelmus> apparently, << is just $
05:29:48 <notsmack> apfelmus: right.
05:29:49 <bakert> and they are the same if header and thediv act the same.  so they must not.
05:30:18 <mq_mattr> have you tried page t b = header << ((thetitle << t) +++ thelink)
05:30:55 <apfelmus> bakert: thelink has type (Html -> Html)
05:31:13 <notsmack> apfelmus++
05:31:26 <bakert> mq_mattr, i'm afraid that it gives t b = header << ((thetitle << t) +++ thelink)
05:31:29 <bakert> ignore that!
05:31:32 <bakert> wrong clipboard
05:31:42 <bakert> mq_mattr, it gives: No instance for (HTML (Html -> Html))
05:31:42 <bakert>       arising from use of `+++' at Trans.hs:33:22-48
05:32:05 <notsmack> bakert: i use "thelink noHtml ! [..."
05:32:31 <bakert> notsmack++
05:32:42 <bakert> i seeeeeeeeeeeee ... of course i was not giving it an argument
05:32:46 <bakert> i am a dullard
05:32:52 <bakert> noHtml is just the empty string?
05:33:22 <bakert> I must get better at understanding haskell error messages.
05:33:27 <notsmack> bakert: empty Html, it won't even open the tag up
05:33:36 <notsmack> <link /> instead of <link></link>, that is
05:34:49 <bakert> ahhhhh, that's better.  i do feel less like putting my fist through my monitor now.  thanks notsmack, apfelmus, mq_mattr
05:35:59 <mq_mattr> anyone know why thetitle is Html -> Html instead of String -> Html?
05:36:20 <apfelmus> bakert: putFistThroughMonitor has type IO (). therefore, it should be avoided :)
05:36:28 <notsmack> mq_mattr: a lot of those types seem to have been decided on autopilot
05:36:39 <mq_mattr> apfelmus: :)
05:37:18 <apfelmus> @users #haskell
05:37:18 <lambdabot> Maximum users seen in #haskell: 288, currently: 288 (100.0%), active: 30 (10.4%)
05:37:33 <mq_mattr> ohhh
05:37:37 <mq_mattr> ahhhh
05:37:44 <apfelmus> ?? wasn't that over 300 once?
05:38:00 <kzm> Could've sworn dons claimed that at one point.  Dons?
05:38:11 <notsmack> yes, it was
05:38:19 <Ulfalizer> no, it can't be. i alone am best!
05:38:32 <mq_mattr> maybe lambdabot had to be reset
05:40:14 <Ulfalizer> in that natural way that being best follows from pushing a channel to a new user count record..
05:40:26 <Ulfalizer> Pupeno_: damn you :(
05:45:50 <basvd> Hello, I'm looking for a blog article I read some time ago. It was about the fact that most object oriented database libraries made a fundamental design error: namely choosing a table row as the most primitive concept instead of the relation. The author described making a DSL in Haskell where relations formed the core. I can't find the blog anymore. Has somebody read it?
05:46:37 <wolfgangbeck> http://en.wikipedia.org/wiki/Object-Relational_impedance_mismatch?
05:46:40 <lambdabot> http://tinyurl.com/y25cma
05:47:37 <basvd> wolfgangbeck: that's interesting! but not the blog article I was looking for. Thanks anyway
05:49:03 <wolfgangbeck> there's a link at the end of the wikipedia article. http://enfranchisedmind.com/blog/archive/2006/06/17/142 talks about the functionl/relational impedance match
05:49:04 <lambdabot> Title: Enfranchised Mind  The Functional-Relational Impedance Match
05:49:29 <emk> basvd: I'd love to see the blog post you're thinking about. It seems odd, though, because a table row is supposed to be a relation.
05:50:21 <notsmack> emk: i'd say 'a relation is a table row' is more accurate
05:50:52 <yaarg> sounds like haskell db no?
05:51:03 <yaarg> his approach
05:51:31 <emk> badvd: Is that the blog post you were looking for?
05:52:10 <basvd> emk: oh yes thats it! thanks
05:52:15 <emk> yaarg: See also "Comprehending Queries" for a really nice model of a database as a functional program build from monads, combinators and catamorphisms.
05:52:46 <yaarg> i actually have that on my desk printed already ;)
05:53:02 <yaarg> in the to read pile
05:53:10 <basvd> a cool... going to print it out
05:53:28 <basvd> I'm off for coffee... thanks guys
05:55:45 <emk> yaarg: It's a really spiffy thesis, though a bit heavy on the category theory.
05:56:30 <emk> I read the whole thing through once, and now I'm going back and translating the category theory bits into Haskell to make sure I really grasp them.
05:58:55 <yaarg> emk: so i see and that sounds like a good way of understanding what is going on.
06:02:22 <emk> yaarg: If you have a solid enough grasp of catamorphisms (i.e., things built from foldr) and monads, it's possible to skim the first couple chapters on your first reading...
06:03:13 <yaarg> basvd: what is described in that blog post is pretty much haskell db so i recommend you check out their documentation to get a better feel of the approach.
06:04:14 <emk> yaarg: There's three major pieces to the author's approach. 1) All the loops in a database are just glorified folds, so you can optimize them by applying fold identities, etc.
06:05:05 <emk> 2) Any modern query language can be compiled into an intermediate language using a half-dozen monads.
06:05:05 <yaarg> emk: my category theory is rusty so won't be so easy for me
06:05:10 <yaarg> but i will get round to it soon enough
06:06:26 <emk> 3) All the optimized and indexed portions of a database can be treated as special-purpose combinators, which can be extracted from the monadic intermediate code by pattern matching.
06:07:17 <tphyahoo> I want something like...
06:07:21 <tphyahoo> take 5 ( foldl (flip (:)) [] [1..1000000] )
06:07:30 <tphyahoo> but it should finish fast, and return [5,4,3,2,1]
06:07:53 <tphyahoo> what I gave finishes slow and returns from the end of the list.
06:08:39 <emk> ( foldl (flip (:)) [] [1..1000000] ) looks like a "reverse" to me...
06:08:50 <tphyahoo> yes, I just wrote out the reverse.
06:09:05 <emk> :t foldl (flip (:)) []
06:09:06 <lambdabot> forall a. [a] -> [a]
06:10:04 <emk> tphyahoo: Can you just move the "take 5" inside? (reverse (take 5 [1..1000000]))
06:10:23 <tphyahoo> that works.
06:12:26 <tphyahoo> I guess what I'm really trying to understand is why take 5 (foldr (:) [] [1..1000000]) is fast, but when you do it with a foldl it seems to want to "consume" the whole list.
06:14:10 <tphyahoo> I thought I would be construcing (:) 1 [], then (:) 2 ((:) 1 []), then (:) 3 ( (:) 2 ((:) 1 []) ) and so on.
06:14:30 <tphyahoo> So I don't see why "take" doesn't see, ok, we have five elements now, we can stop.
06:17:43 <tphyahoo> ?src take
06:17:43 <lambdabot> take n _      | n <= 0 =  []
06:17:43 <lambdabot> take _ []              =  []
06:17:43 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
06:18:13 <tphyahoo> oh I think I see.
06:18:27 <tphyahoo> take doesn't stop recursing until it hits null.
06:18:43 <tphyahoo> I mean, till it hits nil.
06:19:04 <tphyahoo> with foldr, you hit nil right away, but with foldl you have to traverse the whole list.
06:19:50 <amiddelk> tphyahoo: the difference indeed has to be sought in foldl and foldr; take stopts after n gets below zero (see the first alternative)
06:20:55 <earthy> the problem with the foldl specification is that foldl has to run all the way to the [] of its argument *before* the cons can be pattern matched by the take
06:22:38 <earthy> 'foldl op nil list' should be thought of as 'build the left-associative expression that you get by replacing all conses in list by op and the null by nil'
06:22:54 <earthy> 'foldr op nil list' is then 'build the right-associative expression that...'
06:23:35 <earthy> however, the left-associative expression, when viewed as a tree, has as its top node the operation working on the *last* element in the list and the nil
06:23:43 <bakert> Does haskell have an implementation of select?
06:24:05 <earthy> whereas the right-associative expression, when viewed as a tree, has as its top node the operation working on the *first* element and the foldr on the tail
06:24:06 <wolfgangbeck> bakert: yes, but  it's deprecated
06:24:11 <bakert> select(2) I mean
06:24:16 <earthy> yes. ;)
06:24:28 <bakert> Does anything replace it?
06:24:34 <SamB> threads?
06:24:45 <wolfgangbeck> bakert: i was told to use threads instead
06:24:48 <bakert> Oh, it's like that is it? Thanks.
06:25:01 <Philippa> note that they're not OS-level threads
06:25:30 <lokojones> im reading about System.IO and system.IO.Unsafe because I wanted to read 2 Ints and 2 Floats, to pass them to a function
06:25:35 <lokojones> but im a bit confused
06:25:42 <lokojones> what function should I use for this?
06:25:43 <ookk> how does the binary and / or operators look in haskell?
06:25:43 <SamB> the RTS will call select(2) for you ;-)
06:25:58 <SamB> && and ||
06:26:17 <Philippa> lokojones: once you have the strings, pass them into read
06:26:23 <Philippa> if they're binary values, it's a bit harder
06:26:34 <wolfgangbeck> still, it's quite awkward to start a thread for every timer and having to kill it with throwTo just to stop it
06:26:35 <ookk> SamB, those are for booleans
06:26:40 <lokojones> Philippa: I want to read them through terminal
06:26:42 <SamB> ookk: oh. that kind of binary!
06:26:51 <SamB> I thought you meant "taking two arguments" ;-)
06:26:52 <Philippa> lokojones: yes. The conversion has nothing to do with IO
06:26:56 <SamB> .&. and .|.
06:26:58 <lokojones> so I guess you mean, just read them as strings and convert them into floats and Ints?
06:27:01 <Philippa> right
06:27:02 <SamB> from Data.Bits
06:27:05 <ookk> ok thx
06:27:05 * earthy nods
06:27:24 <earthy> or, if they are binary, do the appropriate conversion using Data.Bits
06:27:46 <earthy> or even use binary io
06:27:51 <earthy> but that's a bit hackish, still
06:28:18 <SamB> earthy: I don't know how to type in binary!
06:28:22 <earthy> samb: :)
06:28:25 <lokojones> Philippa: ok, thx
06:28:33 <SamB> I think, since he is reading from the terminal, he does not want binary io
06:28:38 <lokojones> Philippa: the right function for that is hGetLine, from system.io
06:28:40 <lokojones> no?
06:28:47 <earthy> almost
06:28:55 <earthy> if you already have a file handle: yes
06:29:16 <lisppaste2> ClaudiusMaximus pasted "type annotation query (couldn't match rigid variable)" at http://paste.lisp.org/display/35378
06:29:54 <lokojones> earthy: .. file handle :P?
06:29:59 <tphyahoo> thanks earthy, I saved what you wrote and am trying to build up an intuition around it...
06:30:00 <earthy> if not, use the prelude functions readFile and writeFile
06:30:17 <earthy> tphyahoo: I still don't have an intuition. :)
06:30:42 <yaarg> anyone know if hs-plugins is ghc 6.6 compatible yet?
06:30:46 <lokojones> Prelude> :t readFile
06:30:47 <lokojones> readFile :: FilePath -> IO String
06:30:55 <SamB> earthy: maybe he wants getLine?
06:31:08 <lokojones> I guess, not specifiyng any filepath, reads from stdin?
06:31:08 <SamB> he said "terminal" earlier
06:31:20 <earthy> lokojones: do { contents <- readFile "myInputFile"; handlecontents contents }
06:31:21 <lokojones> yes :P
06:31:25 <earthy> ah, stdin.
06:31:28 <bakert> What's the right module for date and time handling (specifically i want to go to and from representations of moments in time to the resolution of one minute)?
06:31:39 * mux wouldn't use the do notation for that :)
06:31:40 <earthy> do { contents <- getContents ; handlecontents contents }
06:31:48 <mux> readFile "foo" >>= handleContents
06:32:08 <lokojones> what would that do?
06:32:09 <bakert> s/representations/String representations/g
06:32:26 <SamB> why are we trying to read all of stdin?
06:32:43 <earthy> lokojones: do {contents <- getContents; handlecontents contents } is identical to  getContents >>= handlecontents
06:32:55 <lokojones> what do mean SamB ?
06:32:57 <earthy> samb: because that's simplest. :)
06:33:09 <earthy> lokojones: do you need your code to do interactive stuff?
06:33:15 <earthy> @type interact
06:33:15 <bakert> Data.Time.Clock doesn't seem like the right module?
06:33:20 <lambdabot> (String -> String) -> IO ()
06:33:40 <bakert> ah perhaps localtime?
06:33:48 <lokojones> earthy: I just need some initial values, to start the function
06:33:59 <earthy> then getContents is probably easiest.
06:34:07 <lokojones> what Im actually doing is creating a main
06:34:18 <earthy> it gives you all the input in an IO String
06:34:22 <lokojones> that has an import to my module, which has the function in it
06:34:37 <lokojones> and I want that main, to ask for the parameters I want to pass to the function
06:34:39 <earthy> the function is of type (Int,Int,Double,Double) -> SomeType ?
06:34:50 <earthy> (roughly)
06:34:55 <lokojones> algoritmoGenetico :: Int -> Float -> Float -> Int -> ([Float],Float)
06:34:58 <lokojones> thats the function
06:35:13 <lokojones> in my module
06:35:24 <earthy> right. and you want to ask the user for the values of those ints and floats
06:35:30 <lokojones> yep
06:36:10 <earthy> then something like
06:37:01 <lokojones> I heard something about that I shoudnt use Floats and use Double instead, but, for now, I just want it to work :)
06:37:34 <SamB> well, that is a completely independant issue
06:37:49 <SamB> ;-)
06:37:53 <lokojones> yes :P
06:37:56 <earthy> do { putStr "Hello user, input an int please> "; intStr <- getLine; putStr "Now another> "; intStr2 <- getLine; print (algoritmoGenetico (read intStr1) 0 0 (read intStr2); }  should work
06:38:30 <lokojones> umh, let me try
06:38:47 <lokojones> does that work only with prelude?
06:38:55 <earthy> that only uses the Prelude, yes
06:39:09 <earthy> you really don't want to be thinking about System.IO.Unsafe at this point. ;)
06:39:21 <earthy> that's where the daemons live.
06:41:03 <ADEpt> earthy: you need to change blocking mode, too, or under windows it will work in unexpected manner :)
06:41:17 <lokojones> earthy: that last ; doesnt go there
06:41:19 <lokojones> does it?
06:41:54 <ADEpt> lokojones: it doesn't hurt, either
06:42:19 <lokojones> Main.hs:5:177: parse error on input `;'
06:42:38 <Jaak> missing a )
06:42:57 <lokojones> oh yep
06:42:59 <lokojones> I see it
06:43:36 <lokojones> main = do { putStr "Hello user, input an int please> "; intStr <- getLine; putStr "Now another> "; intStr2 <- getLine; print (algoritmoGenetico (read intStr1) 0 0 (read intStr2)); }
06:43:40 <lokojones> this is how main looks now
06:43:41 <lokojones> but..
06:43:46 <lokojones> Main.hs:5:150: Not in scope: `intStr1'
06:44:19 <Jaak> makes sense
06:44:27 <lokojones> oh
06:44:31 <lokojones> I see it again
06:44:43 <lokojones> intStr and the other is intStr1
06:45:17 <lokojones> my brain doesnt work very well :P
06:46:27 <lokojones> it compiled
06:46:36 <lokojones> but running it, seems to make it wait for imput
06:46:43 <lokojones> without showing the message first
06:46:50 <lokojones> *input
06:47:02 <Jaak> try putStrLn
06:47:59 <allbery_b> you may want to look at hSetBuffering
06:48:14 <lokojones> it worked with putStrLn
06:48:48 <lokojones> thanks
06:48:57 <allbery_b> in particular, on unixy systems stdout is line-buffered, so you need to either (a) output whole lines (b) flush the output buffer before reads (c) use hSetBuffering to disable line buffering.
06:49:22 <bakert> Can I parse times with one of the Data.Time modules?
06:49:43 <lokojones> what putStrLn does is to send and EOL after writing
06:49:47 <lokojones> doesnt it?
06:50:24 <ClaudiusMaximus> ?src putStrLn
06:50:24 <lambdabot> putStrLn s =  do putStr s; putChar '\n'
06:50:48 <allbery_b> yes, putStrLn writes a whole line so it is output
06:51:15 <lokojones> ok, thats just what I want
06:51:27 <allbery_b> if you want to use putStr you need to either write a newline (in which case you might as well us putStrLn) or change buffering so you can output partial lines
06:52:11 <lokojones> ok
06:52:56 <kpreid> er, or explicitly flush
06:54:57 <dons> ?uptime
06:54:57 <lambdabot> uptime: 3h 56m 49s, longest uptime: 2d 3h 42m 19s
06:55:03 <dons> ?users
06:55:03 <lambdabot> Maximum users seen in #haskell: 298, currently: 298 (100.0%), active: 44 (14.8%)
06:55:08 <SamB> I hope that isn't the *real* definition of putStrLn
06:55:21 <ndm> SamB: no, the real one is probably a mapM
06:55:26 <ndm> (mapM_ to be precise)
06:55:35 <SamB> I was hoping for something atomic
06:55:53 <ndm> oh, for putStrLn, that is EXACTLY what it is
06:56:02 <ndm> SamB: atomic and strict? i.e. changing the semantics of Haskell?
06:56:05 <SamB> like putStrLn s = putStr (s ++ "\n")
06:56:17 <ndm> the second is much more efficient
06:56:22 <ndm> the original, i mean
06:56:28 <ClaudiusMaximus> ?src putStr
06:56:29 <lambdabot> putStr s  = hPutStr stdout s
06:56:31 <ndm> you don't pay O(n) twice
06:56:35 <ndm> ?src hPutStr
06:56:36 <lambdabot> Source not found. stty: unknown mode: doofus
06:56:38 <dons> SamB: that's the real one.
06:56:49 <SamB> okay...
06:57:08 <SamB> so... what prevents the newline getting seperated from the rest?
06:57:10 <Igloo> The underlying C functions don't give you atomicity
06:57:17 * allbery_b is not clear that that's true atomicity, either; it would depend on how hPutStr is implemented
06:57:22 <ndm> SamB: monads
06:57:23 <allbery_b> and ==Igloo
06:57:32 <SamB> ndm: in the presence of threads?
06:57:42 <dons> note that we use:
06:57:44 <dons> hPutStrLn h ps
06:57:44 <dons>     | length ps < 1024 = hPut h (ps `snoc` 0x0a)
06:57:45 <dons>     | otherwise        = hPut h ps >> hPut h (singleton (0x0a))
06:57:49 <ndm> SamB: ah, nothing - if you use threads and IO like that who knows what there is
06:57:49 <dons> in bytestring ;)
06:58:36 <ndm> doesn't the snoc do a new allocation, wouldn't the second pretty much always be chaper?
06:58:45 <dons> no, due to MVar locking of Handles
06:58:47 <ndm> snoc also does a copy
06:58:58 <dons> hence if the array is smaller, copying is more efficient than locking twice
06:59:00 <ndm> oh, so each hPut costst you a lock
06:59:01 <dons> we timed it
06:59:01 <allbery_b> ndm: at a guess, the 1024 test insures the current buffer's big enough
06:59:04 <dons> yeah
06:59:20 <dons> 1024 was the size, roughly, where copying stopped being cheaper than locking twice
06:59:21 <allbery_b> ah
06:59:26 <dons> but for most small strings, copying is way better
06:59:39 <allbery_b> yeh, locking is usually expensive
06:59:54 <ndm> why aren't handles STM?
07:00:08 <SamB> dons: I like yours
07:00:08 <allbery_b> how do you rollback a partial write?
07:00:18 <Igloo> STM is slower than the lower level stuff
07:00:25 <ndm> you go scrape the users brain, and pull the information back out
07:00:44 <ndm> ah, that explains it then if its slower
07:00:44 <dons> yeah, that's a good technique
07:01:12 * allbery_b recalls STM is still an open field and they're working on performance techniques...
07:01:36 <SamB> I don't really care if my putStrLns over 1024 work right...
07:01:41 <allbery_b> the POC was "this is easier, and a little slower; speed can come later, we see ways we can mpprove it already"
07:02:14 <ndm> SamB: the second you have a 1025 character string, you really really will!
07:02:38 <SamB> ndm: which I am outputting to stdout for debugging purposes?
07:02:40 <dons> we're talking about interleaved output right?
07:02:43 <dons> with multiple threads?
07:03:02 <dons> who cares? you're asking for trouble if you have multiple threads writing to a Handle, and expect no interleaving...
07:03:04 <SamB> well, *I* am talking about that on stdout
07:03:11 <SamB> maybe stderr
07:03:12 <ndm> SamB: maybe you are writing a Haskell analysis tool which generates predicates which are usually quite small, but sometimes get very big
07:03:59 <ndm> and remember than hPutStr also writes to files
07:04:32 <dons> but you just shouldn't have mutlitple threads writing to a Handle and expect squencing, without some other sync method
07:04:36 <dons> so I don't see what the issue is
07:06:22 * allbery_b agrees --- again, locking is expensive, it's not smart to force locking and synchronization when it might not be needed
07:06:46 <allbery_b> so the only locking I'd expect on handles is the minimum to keep two concurrent writes from trashing internal structures
07:06:58 <allbery_b> ^two^
07:08:22 <allbery_b> (e.g. if you have a concurrent program but only one thread ever writes to stdout, why force it to do unneeded synchronization?
07:09:24 <dons> exactly
07:11:59 * allbery_b is no expert on concurrency, but understands the basics because he might be called on to debug something and should therefore have at least a *little* clue...
07:12:11 <ClaudiusMaximus> what's the correct syntax for annotating the type of a polymorphic function argument?  "f w (x::(Blah a=> [a]))" doesn't work in ghci for "f :: (Blah a) => Flub -> [a]", things work fine without any annotation but i'm curious...
07:12:32 <ndm> ClaudiusMaximus: use :t and get the type of the thing, then add it back
07:13:24 <paolino> :t liftM concat.mapM
07:13:25 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
07:13:49 <ndm> ClaudiusMaximus: oh, like that, you need to add a forall, so you can refer to the same a in the body, and no need to specify Blah, i think
07:13:50 <paolino> @pl\ liftM concat.mapM
07:13:50 <lambdabot> fmap join . mapM
07:13:51 <ClaudiusMaximus> ndm: :t x gives me [SpecificBlah]
07:15:54 <dons> :t let f n = n in f ( 1 :: Num a => a)
07:15:55 <lambdabot> forall a. (Num a) => a
07:16:00 <dons> > let f n = n in f ( 1 :: Num a => a)
07:16:04 <lambdabot>  1
07:16:17 <dons> > let f n = n in f ([1] :: Num a => [a]) -- yeah?
07:16:18 <lambdabot>  [1]
07:16:41 <Baughn> :t (+++)
07:16:42 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
07:19:20 <ClaudiusMaximus> dons: i tried something like that, the error is:  Couldn't match the rigid variable `a' against `Sphere'   :  `a' is bound by the polymorphic type `forall a. (Raytrace a) => [a]'
07:19:34 <dons> sounds like you have too many constraints somewhere else
07:22:41 <bakert> ?paste
07:22:41 <lambdabot> http://paste.lisp.org/new/haskell
07:23:07 <notsmack> @check (fst . unzip) == (map  fst)
07:23:08 <lambdabot>   add an instance declaration for (Eq ([(b1, b)] -> [b1]))     In the definit...
07:24:19 <lisppaste2> bakert pasted "Trying to understand using two monads in one function." at http://paste.lisp.org/display/35382
07:24:45 <bakert> Hi folks.  I'd be really grateful if you'd help me out with this probably obvious problem.
07:25:10 <bakert> I have a CGI program that is getting the values of the form fields in a do {} block
07:25:56 <bakert> but inside that do block I need to call a function in IO.  Both inputForm and enterTransaction are stubs at the moment but I am trying to hook them up to the real world and this means they have to go in IO.
07:26:05 <jethr0> i've got a "StateT Int IO a" and i'm trying to do "n <- get", but get "No instance for MonadState Int IO". how can i lift "get" here?
07:26:13 <bakert> I'm at a loss to work out the syntax.
07:26:44 <lisppaste2> bakert annotated #35382 with "Slightly more correct version (!)" at http://paste.lisp.org/display/35382#1
07:27:08 <bakert> I guess really all I want to know is how to do a "do" inside a "do".
07:27:59 <jethr0> @hoogle liftIO
07:27:59 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
07:28:08 <earthy> @hoogle Lift
07:28:09 <lambdabot> Language.Haskell.TH.Syntax.Lift :: class Lift t
07:28:09 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
07:28:09 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
07:28:28 <earthy> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a
07:28:32 <earthy> that's the one
07:29:55 <jethr0> hmm
07:29:57 <jethr0> @paste
07:29:57 <lambdabot> http://paste.lisp.org/new/haskell
07:30:06 <lisppaste2> ClaudiusMaximus annotated #35378 with "new and exciting errors" at http://paste.lisp.org/display/35378#1
07:30:19 <lisppaste2> jethr0 pasted "transformers" at http://paste.lisp.org/display/35384
07:30:46 <hyrax42> ?index MonadIO
07:30:46 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
07:30:52 <jethr0> or do i have to use monadIO
07:31:53 <hyrax42> jethr0: my ?index was coincidental
07:32:08 <hyrax42> I don't even know what your question is, so don't take that as an answer
07:32:29 <jethr0> earthy: could you have a look at my paste. just doing "x <- lift get" didn't work...
07:34:35 <jethr0> ah, got it. i had to lift the "putStr", not the "get"
07:35:08 <ClaudiusMaximus> hmm, i think i've regressed in my understanding of type classes
07:35:55 <syntaxfree> @tell emk hey. thanks for the Inductive Inference pointer. I forwarded it to one of my statistics professors.
07:35:56 <lambdabot> Consider it noted.
07:36:14 <emk> Hey, no prob.
07:36:15 <lambdabot> emk: You have 1 new message. '/msg lambdabot @messages' to read it.
07:36:36 <earthy> claudiusmaximus: how's that?
07:36:46 * syntaxfree ponders .. chatting through @tell is higher-order chatting.
07:37:08 <ClaudiusMaximus> earthy: i thought i vaguelly understood them, now i vaguelly think i don't understand them
07:37:30 <emk> syntaxfree: That's only to be expected with a "lambdabot". :-)
07:37:54 <syntaxfree> yes, but imagine if a @tell bot returned all "status" messages like "consider it noted" to a private window.
07:38:15 <syntaxfree> imagine also that it manages two nicknames. one to notify you of your messages, when you return.
07:38:20 <emk> Is "natural transformation" just a fancy way of saying "a polymorphic function"?
07:38:24 <syntaxfree> it would be the type-safety or IRC chatting!
07:38:26 <syntaxfree> emk: no.
07:38:56 <syntaxfree> don't'ask me to explain what it is, though.
07:39:15 <syntaxfree> I'm stil digesting the cannonical example of dual vector spaces.
07:39:19 <emk> syntaxfree: Well, to be more precise, are all H-M polymorphic functions involving a functor natural transformations in the category Set?
07:40:47 <syntaxfree> :(
07:40:58 <syntaxfree> can I spout something mindless instead? :~
07:41:07 <emk> syntaxfree: :-)
07:41:19 <syntaxfree> Hey, Haskell needs some better project names.
07:41:25 <syntaxfree> "Template Haskell" is boring.
07:41:44 <syntaxfree> It's like Rails was called RubyMVC
07:42:02 <syntaxfree> "Parsec" is cool, and Monad as well. But why "Arrows"?
07:42:08 <syntaxfree> why not Zebus?
07:42:15 <dons> chatting through @tell is lazy chatting
07:42:29 <dons> its not higher order though, you can't pass @tell a function to do the chatting for you
07:42:45 <dons> it really just allocates a thunk for your question
07:42:46 <syntaxfree> dons: what does chatting have to do with functions?
07:42:48 <dons> which is demanded later
07:42:53 <syntaxfree> besides, looky.
07:43:17 <syntaxfree> @. tell elite this is higher-order chatting if i know any
07:43:17 <lambdabot> Consider it noted.
07:43:19 <emk> OK, "natural transformations" (fixing category Set) are any transformations that commute with "fmap".
07:43:29 <syntaxfree> hmm.
07:43:39 <syntaxfree> bad.
07:45:01 <syntaxfree> @help .
07:45:01 <lambdabot> . <cmd1> <cmd2> [args].
07:45:02 <lambdabot> . [or compose] is the composition of two plugins
07:45:02 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
07:45:27 <syntaxfree> @. elite tell dons Bah, This is not possible yet it seems.
07:45:28 <lambdabot> COn$ider It nOT3D.
07:45:32 <emk> Which means that we're talking about free theorems, which means that any polymorphic function F a -> G b where F and G are functors should be a natural transformation.
07:45:33 <TomMD> Can a function from on instance of a class call another function declared in the same instance of the class?
07:45:41 <TomMD> *one, not "on"
07:45:48 <syntaxfree> elite would chew the nickname to be told to.
07:45:49 <dons> yeah
07:45:49 <lambdabot> dons: You have 6 new messages. '/msg lambdabot @messages' to read them.
07:45:53 <jethr0> @hoogle MaybeT
07:45:54 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
07:46:07 <emk> Or am I just smoking something?
07:46:15 <jethr0> why is there not monad transformer for maybe?
07:46:21 <jethr0> *no
07:46:26 <emk> ?kind Functor
07:46:28 <lambdabot> Class `Functor' used as a type
07:46:31 <TomMD> dons: Is there anything special needed? ghc doesn't seem to like my case
07:46:34 * syntaxfree considers it NOT 3D.
07:46:38 <ClaudiusMaximus> i understand how this works:  "data Quux = Quux (Foo -> Bar -> Baz) ; makeOof :: Kerzap -> Quux ; makePow :: Zoof -> Quux", should I stick with this method (that I know i can get working without too much thinking, and extend easily) or is there a compelling alternative?
07:46:55 <paolino> This function hangs my program. Is there a theorical reason ?
07:46:56 <paolino> stream d1 d2  = do v <- getRandomR (d1,d2)
07:46:56 <paolino>                    z <- stream d1 d2
07:46:56 <paolino>                    return (v:z)
07:47:22 <syntaxfree> @. elite paste
07:47:23 <lambdabot> H7TP://pAztE.liSp.0R9/n3w/h45ke1L
07:47:57 <paolino> (I suppose it's related to the missing repeatM function)
07:48:26 <ClaudiusMaximus> > let x =  do {y <- x ; return y} in x
07:48:27 <lambdabot>   add an instance declaration for (Show (m a))
07:48:39 <ClaudiusMaximus> @undo let x =  do {y <- x ; return y} in x
07:48:39 <lambdabot> let { x = x >>= \ y -> return y} in x
07:50:22 <emk> syntaxfree: Assuming we're in category Set, then I think the following should be correct:
07:50:23 <paolino> it doesn't hang on liftM (take 3) $ stream 0 1 but on (replicateM 3 $ (liftM (take 3) $ stream 0 1)
07:50:26 <emk> type NaturalTransform = (Functor f, Functor g) => f a -> g a
07:50:30 <ClaudiusMaximus> @ . unpl undo let x = do { y <- x ; return y } in x
07:50:37 <ClaudiusMaximus> @. unpl undo let x = do { y <- x ; return y } in x
07:50:37 <lambdabot> let { x = x >>= \ y -> return y} in x
07:50:43 <syntaxfree> well, so far so good.
07:51:08 <syntaxfree> undo'ed is already in unpled mode.
07:51:12 <syntaxfree> this should be cool though.
07:51:34 <syntaxfree> @. pl undo do { y<-x; return (f y);}
07:51:34 <lambdabot> f `fmap` x
07:51:47 <emk> syntaxfree: But since either f or g can be the identity functor, that basically means that a H-M polymorphic function is more or less a natural transformation in category Set.
07:52:01 <syntaxfree> @.pl undo f x = do { y<-x; return (f x);}
07:52:01 <lambdabot> (line 1, column 15):
07:52:01 <lambdabot> unexpected "{"
07:52:01 <lambdabot> expecting variable, "(", operator or end of input
07:52:35 <syntaxfree> @. pl undo f x = do { y<-x; return (f x);}
07:52:35 <lambdabot> (line 1, column 21):
07:52:35 <lambdabot> unexpected "{"
07:52:35 <lambdabot> expecting variable, "(", operator or ")"
07:52:57 <ClaudiusMaximus> @redo foldl (+) [1..]
07:52:57 <lambdabot> foldl (+) [1 ..]
07:53:14 <jethr0> syntaxfree: isn't there a semicolon too many?
07:53:34 <syntaxfree> emk: maybe a trivial one, yes.
07:53:45 * paolino waves hands
07:53:54 <syntaxfree> that is scarily kinda saying that 3 is a function on the reals.
07:53:57 <syntaxfree> f x = 3 is one.
07:54:02 <syntaxfree> s/kinda/like
07:54:22 <syntaxfree> 3 is a real.
07:55:22 <syntaxfree> @. elite pl f a b c d = (a * b) ^ (c/d) - (a+d) `div` a (mod d (mod b (mod c)))
07:55:24 <lambdabot> f = 4p (Ap . (|IF+m2 (Liph7m2 (-)) .) . FLip fLIp (/) . (((.) . (.) . (^)) .) . (*)) (aP ((.) . (.) . ap . (Div .) . (+)) ((. ((flip /\/\OD .) . (. /\/\Od) . MoD)) . (.) . (.)))
07:55:34 <syntaxfree> oh boy. that's 3lite.
07:56:40 * syntaxfree can't help but wondering if leetspeak was ever used in earnest.
07:57:06 <TomMD> @paste
07:57:06 <lambdabot> http://paste.lisp.org/new/haskell
07:57:08 <SamB> some people are silly enough to do it, I think
07:57:55 <syntaxfree> not nowadays. even the bash.org circles use it ironically. but i think i've never seen it used non-ironically.
07:57:59 <lisppaste2> TomMD pasted "Class functions calling other functions" at http://paste.lisp.org/display/35388
07:58:12 <TomMD> Anyone see what I am missing this time?
07:58:37 <kpreid> syntaxfree: you're not looking in the right places
07:58:58 <syntaxfree> how lower than bash.org can it get?
07:59:11 <syntaxfree> I mean, I've been online since 1995.
07:59:17 <syntaxfree> I've done the IRC teen thing.
07:59:26 <syntaxfree> I **never** saw leetspeak used in earnest.
07:59:37 <emk> syntaxfree: I'm going to see if I can get "f x = 3" to commute with a suitable definition of fmap.
08:00:12 <kpreid> syntaxfree: actually, I just realized I'm confusing leetspeak with "u r" etc.
08:00:23 <emk> It's very categorical to think of 3 as a function from an initial object to the value 3, after all. :-)
08:00:43 <syntaxfree> kpreid: oh, that's aolspeak, I think.
08:01:04 <syntaxfree> I was very fond of "yr" for "you are", as per the post-beatnik poet d.a. levy
08:01:06 <SamB> syntaxfree: have you seen the horror known as "forums"?
08:01:23 <syntaxfree> SamB: sure, I even read /. sometimes.
08:01:29 <syntaxfree> Since my gf dumped me I have a lot of free time.
08:01:33 <SamB> syntaxfree: many forums are worse!
08:01:39 <maskd> syntaxfree: leetspeak is from the eighties
08:01:49 <SamB> some are, I think, bad enough for people to actually speak leet!
08:01:51 <TomMD> If anyone has a free moment I would be greatful for any help with http://paste.lisp.org/display/35388
08:02:14 <syntaxfree> gratitude often seduces more than greatness :)
08:02:30 <SamB> hah
08:02:39 <SamB> slight spelling issue ;-)
08:02:56 <syntaxfree> what error do you get?
08:03:38 <TomMD> It complains about "No instance for (DB m Int 9Int, Char))"
08:03:46 <TomMD> 9 == ( in that line.
08:03:57 <syntaxfree> 9Int?
08:04:06 <TomMD> It complains about "No instance for (DB m Int (Int, Char))"
08:04:11 <TomMD> there, darn keyboard
08:04:54 <syntaxfree> when compiling just that or when trying to use it?
08:05:25 <TomMD> It happens when compiling just that.  I am trying to compile/use a more complex version of that.
08:07:02 <TomMD> ooops, OK, so it works if I do include the "class Ord k => DB m k e | k -> m ..."  Anyone know of a good text for this syntax?  Wikibooks?
08:07:55 <syntaxfree> II don't'understand the class Blah = (Context)=> This thing | and this other  where syntax.
08:07:59 <paolino> > let stm = do {a <- get ;put (a+1);b <- stm;return (a:b)} in runState (replicateM 1 $ liftM (take 1) $ stm) 1
08:08:02 <syntaxfree> what is the | doing there?
08:08:03 <lambdabot> Terminated
08:08:28 <bakert> howdy folks.  i'm trying really hard to understand nesting of monads but i need a helping hand.
08:08:35 <TomMD> syntaxfree: that is basically why I came.  Someone here showed it to me a little while ago and I can't find text on it.
08:08:51 <bakert> i'm trying to write a CGI program which uses the CGI monad but also needs to do things in IO.
08:08:55 <wolfgangbeck> bakert: welcome to the club :-(
08:09:07 <syntaxfree> sounds like one of those fancy type system extensions I'm not aware of.
08:09:14 <syntaxfree> It doesn't look like GADTs or existential types.
08:09:18 <paolino> anyone can explain why that function hangs ?
08:09:18 <bakert> i've written a smaller version that shows my confusion.
08:09:21 <bakert> ?paste
08:09:21 <lambdabot> http://paste.lisp.org/new/haskell
08:09:24 <SamB> fundeps?
08:09:33 <SamB> aka functional dependencies?
08:09:58 <lisppaste2> bakert pasted "bakert is confused and would be grovellingly grateful if you help him out." at http://paste.lisp.org/display/35390
08:10:01 <syntaxfree> I thought Haskell+exts didn't have all-out fundeps.
08:10:15 <syntaxfree> GADTs were meant to implement a doable subset of fundeps.
08:10:17 <nickm445> hello everyone
08:10:28 <bakert> I really just need to know the syntax for the doit function.
08:10:29 <syntaxfree> and for everything else, go Epigram?
08:11:09 <TomMD> If I use these (are these fundeps?), then I get many instance conflicts, I need a way to specify which class instance to use at the time I use it.  Is that doable?
08:11:20 <syntaxfree> bakert: what's the error you get?
08:11:41 <bakert> syntaxfree, I get  Couldn't match expected type `CGIT IO' against inferred type `IO'
08:11:41 <bakert>       Expected type: CGIT IO t
08:11:41 <bakert>       Inferred type: IO String
08:11:57 <syntaxfree> well, I don't know this CGIT monad.
08:12:00 <bakert> for the do expression in "doit"
08:12:29 <bakert> CGIT monad transformer described here: http://www.cs.chalmers.se/~bringert/darcs/cgi-compat/doc/api/Network-NewCGI.html#t%3ACGIT
08:12:32 <lambdabot> http://tinyurl.com/y44tpy
08:13:00 <paolino> bakert maybe you need lift
08:13:01 <bringert> bakert: use liftIO
08:13:31 <bakert> what does that do for me?  takes the value temporarily out of IO, does something and then puts it back, right?
08:13:41 <bakert> So i need to do that in "doit"?
08:13:46 <bringert> @type liftIO
08:13:47 <lambdabot> forall (m :: * -> *) a. (MonadIO m) => IO a -> m a
08:14:01 <bringert> for you, liftIO :: IO a -> CGI a
08:14:25 <bakert> right ok that would be deeply good.
08:14:51 <bringert> you may need to import Control.Monad.Trans
08:15:04 <emk> syntaxfree: f x = 3 appears to be a natural transform, yes. :-)
08:15:18 <astrolabe> @hoogle liftIO
08:15:18 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
08:15:21 <emk> Let me paste in a code snippet.
08:15:39 <astrolabe> oops :)
08:17:07 <bakert> bringert, paolino, i'm not quite sure how to apply liftIO.  It takes one argument which is something in IO.  So can I say "liftIO $ y <- yyy" or is that nonsensical?
08:17:07 <lisppaste2> emk pasted "g x = 3 is a natural transform from any functor to K_3" at http://paste.lisp.org/display/35391
08:17:23 <bringert> bakert: y <- liftIO yyy
08:17:33 <bringert> yyy is something in IO
08:17:41 <syntaxfree> emk: btw, have you seen Charity?
08:17:49 <bringert> y <- yyy is not an expression at all
08:17:52 <bakert> ah yes sorry .. that was obvious
08:18:16 <emk> syntaxfree: I'm looking now.
08:19:28 <bakert> So liftIO says "take this thing in IO and instead make it in whatever monad this function is in instead".  Are there any other consequences or can I just call it when I want?  Where does the IO leak back out, if you know what I mean?
08:19:42 <emk> Anyway, since "f x = 3" is a natural transformation, if a degenerate one, this raises my earlier question: Are H-M polymorphic functions natural transformations over Set, or am I just confused?
08:20:05 <emk> s/over Set/in category Set/
08:20:52 <syntaxfree> is there a haskellwiki page with all type system extensions available in ghc in one place?
08:20:52 <bakert> bringert, if i say "y <- liftIO yyy" I getCouldn't match expected type `CGIT IO' against inferred type `IO'
08:20:52 <bakert>       Expected type: CGIT IO t
08:20:52 <bakert>       Inferred type: IO ()
08:20:53 <Philippa> CPO, not Set
08:21:13 <bringert> bakert: can you paste the code?
08:21:15 <bakert> IO () instead of IO String but essentially the same error.  Does that make any sense to you?
08:21:36 <bakert> bringert, http://paste.lisp.org/display/35390
08:22:19 <bringert> bakert: so, what do you want the type of doit to be?
08:22:31 <emk> Philippa: Ah, thanks. Is that the only mistake I was making?
08:22:42 <bakert> bringert, i'm not sure.  I would like main to be like this:
08:22:56 <bakert> I cannot determine whether this is the live or dev environment. Please correct config.php or contact bakert+ff@gmail.com
08:23:02 <bakert> (sorry!  wrong paste!)
08:23:02 <bringert> bakert: you are missing a runCGI
08:23:20 <bakert> bringert, yes, eventually main should be:
08:23:21 <bakert> main = runCGI $ handleErrors cgiMain
08:23:32 <bakert> so "doit" is kind of like "cgiMain"
08:23:49 <bakert> I was trying to create a cut-down version of my problem.  But perhaps I have just confused myself.
08:24:13 <emk> Philippa: I'm trying to build some intuition for category theory, but it's rough going at times.
08:24:33 <bringert> give doit a type signature, that way you should get a more understandable error message
08:24:39 <lisppaste2> bakert annotated #35390 with "Actual code that has the problem." at http://paste.lisp.org/display/35390#1
08:24:41 <bringert> bakert: note that main :: IO ()
08:25:56 <bakert> bringert, the problem in my actual code (see paste) is that inputForm must do IO (to get the current time).  It's the collision of CGI and IO in cgiMain that is just baffling me.
08:26:05 <bakert> any hint you can offer gratefully received.
08:26:46 <lisppaste2> bakert annotated #35390 with "The error message is ..." at http://paste.lisp.org/display/35390#2
08:26:54 <bringert> bakert: tsf <- liftIO $ timestampField "ts"
08:27:14 <bringert> bakert: give type signatures to all your top-level functions if you want better error messages
08:27:31 <bakert> ok i'll do both those things and see if i can make sense of it.  thanks so much!
08:27:33 <emk> syntaxfree: Charity looks interesting. Thanks!
08:27:57 <Masklinn> hello
08:28:01 <bakert> bringert, i think the problem is that i don't really understand what the CGI stuff needs the signatures to be.
08:28:02 <jethr0> hello
08:28:32 <bringert> bakert: yeah, you might need to know something about monads and possibly monad transformers
08:29:22 <bringert> basically, you should only need liftIO :: IO a -> CGI a when you want to do IO, and then runCGI :: CGI CGIResult -> IO () in main
08:32:01 <bakert> bringert, i see.  so the main bits of the program have a type of "CGI a" and use liftIO to keep the mucky IO stuff out of the signatures?
08:32:04 <astrolabe> emk: I'm not very sure about the application of category theory in CS, but is K3 a functor as you have defined it?
08:32:17 <bakert> It seems to compile now I have added liftIO and signatures so thanks a million.
08:32:21 <bakert> Now I have to make it actually work!
08:32:54 <astrolabe> Ah, maybe it is
08:33:13 <Philippa> emk: I believe that's the only mistake, BICBW
08:33:51 <emk> astrolabe: Well, it's my best approximation to a constant functor in Haskell. A constant functor's definition of fmap just throws away the function you pass it.
08:34:18 <emk> Philippa: Ah, many thanks. I finally feel like I'm starting to get a handle on this stuff.
08:35:43 <emk> astrolabe: It should, technically, satisfy all the rules for functors. And you generally need something similar to define F-algebras, etc., so it's pretty standard.
08:37:25 <jethr0> i have a function that generates a path in Control.Monad.State by keeping a list of unused positions. but i want to use only an "init" of that path. is there a good way to make "State Path" lazy?
08:38:23 <astrolabe> emk: I'm beginning to see it now.
08:39:14 <astrolabe> An odd thing about CS category theory for me is that it all seems to live in one category.
08:39:20 <bakert> So now I am abusing liftIO in some way it doesn't like:
08:39:20 <bakert>     if liftIO $ insertTransaction values
08:39:20 <bakert>         then p << successMsg values
08:39:20 <bakert>         else p << "Problem with db please talk to Tom"
08:39:32 <bakert> I can't do that?
08:39:40 <jethr0> :@paste
08:39:42 <jethr0> @paste
08:39:42 <lambdabot> http://paste.lisp.org/new/haskell
08:40:35 <lisppaste2> bakert annotated #35390 with "liftIO confusion" at http://paste.lisp.org/display/35390#3
08:40:48 <lisppaste2> jethr0 pasted "lazy state?" at http://paste.lisp.org/display/35394
08:41:06 <earthy> bakert: nope, because the result is in a monad
08:41:06 <beschmi> bakert: b <- liftIO $ ...; if b then ...
08:41:33 <bakert> ok.  so the principle is ok, just the syntax is wrong?
08:41:46 <earthy> bakert: no, the syntax is right, the principle is wrong. :)
08:42:07 <emk> astrolabe: I've seen the categories Set, CPO, Alg(...), and a few others used in CS papers.
08:42:09 <earthy> basically, you have an  insertTransaction values   that returns an IO Bool
08:42:16 <earthy> this you liftIO into some other m Bool
08:42:21 <earthy> however, it is still in a monad
08:42:28 <earthy> that means you cannot directly feed it to if
08:42:41 <earthy> you'll need to get the Bool out from under the monad first
08:42:46 <beschmi> bakert: you can't do that in IO either, but you can define your own ifM
08:42:52 <bakert> earthy, i see.  thanks.
08:43:05 <bakert> beschmi, thanks to you too
08:43:10 <bakert> getting there!
08:43:44 <emk> astrolabe: CS seems to use mostly "applied" category theory--lots of notation, few deep results.
08:44:57 * principle is wrong!
08:45:03 * principle wants to be right!
08:45:04 <beschmi> bakert: here are some definitions of things like ifM, whenM ... http://www.cse.ogi.edu/~hallgren/Programatica/tools/pfe.cgi?MUtils
08:45:09 <lambdabot> Title: MUtils, http://tinyurl.com/y3nv5l
08:45:20 <principle> emk: most of what I've seen from cat theory is notation, yes.
08:45:39 <principle> emk: what about physics? do you think they're exploiting CT to its full potential?
08:46:19 <emk> principle: Since my understanding of modern theoretical physics is even shakier than my understanding of category theory, I have no idea. :-)
08:47:59 <bakert> beschmi, thanks.
08:49:24 <emk> But I'm pretty happy about the use of category theory in CS: Some fairly trivial ideas in category theory seem to have very sweet consequences in computer science. And I have to like any branch of math that relies so heavily on "fmap"...
08:49:36 <bakert> so, is there a way of doing an unwrapping from a monad based on a case statement?
08:49:51 <bakert> what i mean is, can i say x <- case blah blah
08:49:53 <dons> if you expose the constructor for the monad
08:50:03 <dons> but use 'guard' or something
08:50:21 <dons> x <- foo >>= \v -> case v of ...
08:50:22 <dons>  ?
08:50:41 <bakert> ah yes that might be it.
08:51:19 <bakert> basically i have an "if" and depending on the result of the if i want to put the String from one of two IO String functions in there.
08:51:34 <bakert> i'll try your thing and see if i can make sense of it.  thanks dons.
08:53:03 <bakert> ah. no.  that always does foo and then takes an action based on the result of foo, right?
08:53:14 <dons> yeah
08:53:18 <dons> what do you want to do?
08:53:29 <bakert> what i want to do is to decide which monadic thing to unwrap based on a value.
08:53:38 <bakert> to be a bit clearer:
08:53:44 <dons> ok easy
08:53:47 <bakert> x <- getInput "x"
08:53:59 <dons> v <- case y of 1 -> getInput "x" ; _ -> ...
08:54:00 <dons> ?
08:54:09 <bakert> right yes that's it
08:54:37 <bakert> hmmm.  so i think my /real/ problem is that this is already inside a do block because i unwrap the initial y value higher up in the function.
08:54:50 <bakert> so i need more "do" in there?
08:55:30 <dons> not sure. need to see more code
08:56:12 <bakert> actually i think i may be being a doofus.  thanks for handholding let me see if i can get it working.
08:56:20 <bakert> goddamn this stuff warps my brain.
08:56:34 <bakert> even learning OO was not such a steep climb.
08:56:48 <bakert> (back when i knew nothing and OO was a great impenetrable mystery).
08:57:17 <bakert> (i'm thinking this means the rewards for the climb are big though so i suppose it is a good thing)
08:58:20 <dons> yeah, you'll understand OO better after this :)
08:58:34 <joelr1> howdy folks
08:59:02 <joelr1> is antti-juhani's (the planet haskell maintainer) around?
08:59:10 <beschmi> hey joelr1
08:59:43 <joelr1> beschmi: hi antti! the rss feed is at http://feeds.feedburner.com/TenerifeSkunkworks
09:00:05 <beschmi> sorry, i'm not antti ;)
09:00:26 <joelr1> beschmi: oops
09:00:28 <joelr1> ok
09:00:32 <joelr1> what's antti's handle?
09:01:37 <beschmi> don't think i ever saw him around here
09:01:44 <joelr1> oh, ok then
09:03:47 <dcoutts__> @seen heffalump
09:03:48 <lambdabot> I haven't seen heffalump.
09:03:52 <dons> joelr1: its 'ibid'
09:03:55 <dons> that you're looking for
09:04:05 <joelr1> ibid: ping
09:04:10 <dcoutts__> @seen Heffalump
09:04:10 <lambdabot> I haven't seen Heffalump.
09:04:15 <dcoutts__> fair enough
09:04:22 <joelr1> dons: yep, thanks! i'm in an tight bind, you see :-) i can't prove that i'm the owner of my blog :D
09:04:44 <dons> hehe
09:04:48 <joelr1> dons: antti's asking for proof to add my blog to planet haskell. maybe you can lend a hand ;-)
09:05:01 <bakert> wahey!  dons, beschmi, earthy, bringert -- thanks so much for crowbar-ing me out of my rut.  program is now working!
09:05:08 <dons> joelr1: yeah. I can do that
09:05:20 <dons> bakert: no problems. good work!
09:05:30 <dons> joelr1: ibid will be around sometime, and I'll tell him
09:05:33 <bakert> liftIO, eh?  crazy stuff.
09:05:34 <joelr1> dons: thanks in advance. also, the binary bits from the hackathon, are they in a repo someplace?
09:05:44 <dcoutts__> @where binary
09:05:44 <lambdabot> http://darcs.haskell.org/binary
09:06:11 <joelr1> dons: i saw deferred binary but didn't look deep enough to understand whether it's based on the new binary bits. is it?
09:06:16 <joelr1> dons: thanks again
09:07:27 <ibid> joelr1: pong?
09:07:37 <dons> its not based on binary at all
09:07:41 <joelr1> ibid: :D
09:08:01 <joelr1> dons: ibid does not believe me ;-)
09:08:29 <dons> ibid, joelr is Mr. Teneriffe skunk works
09:08:53 <joelr1> dons: oh, ok then. but the new binary bits do not derive automatically whereas deferred binary does, right?
09:09:12 <dons> deferred binary uses an SYB trick we came up with, yeah
09:09:20 <dons> but we can do the same -- its a fe minutes hacking :)
09:09:31 <dons> the big diff is that deferred binary is just like old binary, it reads from Handles
09:09:40 <ibid> dons: thanks, but you know my policy :)
09:09:43 <dons> whereas 'binary' is a bytestring serialiser for in-memory stuff
09:09:48 <ibid> however, i just figured out a way
09:09:56 <dons> joelr1: can you send ibid an email from your teneriffe address?
09:09:57 <ibid> whois connects the name with the domain :)
09:10:03 <dons> ah ok
09:10:04 <bakert> is there something like catMaybes that will take [Maybe String] and return "" for all the Nothings rather than eliding them?
09:10:10 <joelr1> ibid: let me oblige then. one sec.
09:10:16 <ibid> joelr1: not mecessary
09:10:26 <ibid> joelr1: whois lists your name for the domain
09:10:33 <ajack> hi, pretty new to haskell, can anyone gimme some help with getting elements out of tuples? so far all i can see is using the fst and snd functions - how do i get say the 10th one out?
09:10:43 <dons> pattern matching
09:10:48 <joelr1> ibid: ah, cool then
09:11:17 <jethr0> :t mapMaybe
09:11:18 <lambdabot> forall b a. (a -> Maybe b) -> [a] -> [b]
09:11:28 <fasta> > case (1,2,3) of (_,_,a) -> 3
09:11:28 <ibid> (the thing i want is that i can say that i added the blog in good faith and after some checking, if i ever get sued for copyright infringement:)
09:11:29 <lambdabot>  3
09:11:39 <joelr1> dons: at least i know the difference now. why wouldn't everyone use binary + bytestrings?
09:11:40 <fasta> ajack: see?
09:11:44 <joelr1> ibid: never thought of that!
09:11:49 <jethr0> :t maybe
09:11:50 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
09:12:05 <ajack> yeah fasta, thanks :D
09:12:13 <dons> joelr1: well, ndm has a specific need: to be able to seek on disk
09:12:16 <jethr0> map (maybe "" id) $ [Just "hello", Nothing, Just "world"]
09:12:20 <joelr1> dons: never mind, it's a silly question. i just think that for reading/writing records and such i would go with bytestrings
09:12:23 <dons> so he wants to parse from disk, and seek around in the file
09:12:23 <jethr0> > map (maybe "" id) $ [Just "hello", Nothing, Just "world"]
09:12:24 <lambdabot>  ["hello","","world"]
09:12:27 <dons> joelr1: agreed
09:12:30 <bakert> thanks jethr0 ... perfect
09:12:38 <ibid> joelr1: what i usually look for is for example the name of the author in the blog, or mail from the same domain. or ... :)
09:12:47 <dons> joelr1: so we're working very hard *right now* to get binary done this week
09:12:52 <dons> we've moved into performance tuning
09:12:54 <fasta> ajack: doing these "generic" things in Haskell is not something where Haskell 98 is suitable for.
09:12:55 <ibid> joelr1: whois is as good as those :)
09:13:01 <dons> and trying to get an erlang bitstream style layer on top
09:13:13 <dons> (went to a talk by the erlang bits guys todays)
09:13:14 <fasta> ajack: when you have >4 fields I recommend a real data type.
09:13:16 <joelr1> dons: are you gonna have SYB as well? i
09:13:23 <joelr1> ibid: makes total sense
09:13:26 <dons> yeah, deriving is just too useful
09:13:29 <dons> so you want it , I guess?
09:13:32 <fasta> ajack: "real" being either a newtype or a data type.
09:13:38 * joelr1 wants it, wants it, wants it!
09:13:38 <ibid> joelr1: can i list it under your real name (preferred), or do you want to use some pseudonym?
09:13:57 <dons> joelr1: ok. its my job for tomorrow
09:14:01 <joelr1> dons: imagine that: deriving + erlang bistream stuff
09:14:01 <dons> so you just serialising?
09:14:09 <dons> or writing structures for protocols?
09:14:15 <dons> since the latter is a bit more compelx , of course
09:14:23 <dons> since you're mapping a haskell type to some foreign structure
09:14:24 <joelr1> dons: you are just too good to me
09:14:27 <dons> serialising is much simpler
09:14:35 <dons> since we can pick the disk format we like
09:14:41 <dons> rather than try to map to some C-style struct
09:14:55 <joelr1> dons: i guess i would use erlang-style stuff for parsing protocols and deriving for mapping
09:15:21 <dons> right
09:15:25 <joelr1> dons: basically, erlang is very useful for protocols like exchange data feeds but you still need to serialize your data, for example
09:15:31 <dons> yeah
09:15:34 <ibid> joelr1: ...? ^^
09:15:34 <dons> so we think we can do both things
09:15:41 <joelr1> dons: to save them stock and other quotes
09:15:42 <dons> and almost as good as erlang (without the bit syntax, of course)
09:15:58 <joelr1> ibid: sorry about that, my name is fine
09:16:01 <dons> but talking to simon today, he's got a cunning plan for extended pattern guard syntax to do bit syntax
09:16:03 <ibid> joelr1: ok
09:16:10 <joelr1> ibid: i don't really have a pseudonym
09:16:28 <dons> joelr1: the benefit being that compiled haskell bit packing is giong to be better than interpreted erlang bit packing, I suspect
09:16:38 <joelr1> dons: hmm... it gets better and better
09:16:40 <dons> (and we don't have to hack the runtime to do it)
09:16:50 <pbx> Working through YAHT and have YA dumb question -- is this function point-free? If so, I'm not sure what the definition of "point-free" is...    func1 x = map (*x)
09:16:55 <joelr1> dons: yeah, i'm sure it will be faster
09:17:09 <ibid> joelr1: added, and running update
09:17:27 <joelr1> ibid: cool, thanks!
09:17:31 <jethr0> pbx: point free means it has no explicit arguments
09:17:32 <ibid> (with buncha other blogs)
09:17:33 <SamB> @all-dict point-free
09:17:34 <lambdabot> No match for "point-free".
09:17:38 <jethr0> @pl \x -> map (*x)
09:17:39 <lambdabot> map . (*)
09:17:50 <jethr0> this is point-free
09:17:54 <ibid> i have *no idea* why i suddenly got four requests in a couple of days when i normally get one a month
09:17:57 * bakert doesn't want to carry on with his program because he's only going to break it again and it's so nice when it works.
09:17:58 <joelr1> ibid: i write about non-haskell stuff like trading but then john goertzen writes about combines and kansas christmas :D
09:18:10 <joelr1> ibid: haskell is gaining in popularity!
09:18:21 <SamB> bakert: have we told you about darcs yet?
09:18:26 <pbx> jethr0: So I should send the YAHT author a correction then?  (That fn is given as a point-free solution to Exercise 7.1)
09:18:32 <joelr1> ibid: and i think people are finding it easier to use a meta-blog than to subscribe to all the blogs individually
09:18:39 <bakert> SamB, luckily i already use darcs at work with my python and other stuff.  So that one was nice and easy!
09:18:57 <ibid> joelr1: see http://planet.haskell.org/policy.html :)
09:18:58 <lambdabot> Title: Membership policy - Planet Haskell
09:19:15 <bakert> SamB, it's not so much that I am worried about losing the working version I'm just worried about getting into a hole that only something I've never heard of (a la liftIO) can get me out of!
09:19:30 <SamB> bakert: ah
09:19:31 <jethr0> pbx: well, it's "more" point-free than "func1 x as = map (*x) as", but less so than "func1 = map . (*)" (with which there might be monomorphism problems)
09:19:43 <ibid> dons: you too ^^
09:19:53 <bakert> SamB, 'tis the only way to learn though, i suppose.  so here we go ...
09:19:53 <pbx> It's point-lite!
09:20:00 <joelr1> ibid: aha, now i understand
09:20:00 <jethr0> yup
09:20:01 <ibid> dons: (seeing as i seem to recall you forwarding blogs my way more than once;)
09:21:08 <dons> ibdi, ok. very good.
09:21:17 <pbx> jethr0: So point-free isn't really an absolute term then?  (Writing "monomorphism" on vocab list..)
09:21:20 <ibid> (it's linked from the sidebar)
09:21:37 <jethr0> pbx: well, it is. it means there are no explicit arguments.
09:21:47 <nickm445> can anyone help me? i am a serious newbie to haskell. i need to write a program that will convert text from a file into a list of paragraphs then to a list of N-gram units.
09:22:05 <pbx> jethr0: OK, I'll send a correction to the YAHT author then. Thanks!
09:22:09 <jethr0> k
09:22:35 <dons> ibid, yeah, my theory is that planet haskell has reached the critical mass it needed for new bloggers who want to be seen in thecommunity, have to get themselves on it
09:22:48 <dons> also, putting planet haskell at the top of every blog section of the HWN might help ;)
09:22:54 <bakert> nickm445, what bit are you stuck on?
09:23:50 <dons> ?usres
09:23:50 <lambdabot> Maximum users seen in #haskell: 299, currently: 299 (100.0%), active: 41 (13.7%)
09:24:14 <nickm445> hi bakert i know how to read a file but its getting the text file broken down into the ngrams. so most of it lol.
09:24:58 <bakert> nickm445, i'm going to upset you now and tell you i don't know what an ngram is.  something to do with markov chain representations of language or something???
09:25:06 <bakert> (some vague idea i have picked up somewhere)
09:25:47 <dons> joelr1: any idea what kind of throughput you'll need on binary serialisation?
09:25:48 <jethr0> an n-gram is an n-tuple (in this case on chars or strings)
09:25:59 <dons> I need a number , say nMb/sec to aim for :)
09:26:37 <bakert> nickm445, so what is the output of this file-reading ngram program?
09:26:45 <malebria> Hello.
09:27:00 <malebria> dons: I'm wondering about packaging hs-plugins for debian, do you think it's a good idea?
09:27:03 <joelr1> dons: darn... let me think... say a quote is 8 bytes and i want to save 1mm quotes per second that's 8Mb per second?
09:27:25 <bakert> Is there a library anywhere that can read a date as a string into a date type?
09:27:49 <joelr1> dons: so maybe 10Mb/s is a good round number?
09:27:50 * SamB thought debconf was for package configurations, not a conference about debian!
09:27:53 <Igloo> malebria: It's already packaged (but waiting for the 6.6 version before it can be installed)
09:28:03 <joelr1> dons: i don't even know if that's possible with haskell or at all
09:28:15 <malebria> Igloo: nice, where can I get the package?
09:28:30 <malebria> hum... libghc6-plugins-dev
09:28:47 <dons> 8M/sec eh? I think we sit on about 4M, but we've not started tuning yet
09:29:12 <dons> and thats generating a word ize/edian portable binary file
09:29:19 <dons> so we could go host-order only and gain some more
09:29:25 <dons> besides a fair few other thing to do
09:29:29 <bakert> What i need is something that can do the reverse of formatTime from Data.Time.LocalTime.  do I need to write it?
09:29:34 <joelr1> dons: it's off the top of my head :D go x5 or go x10 :D
09:29:42 <dons> hehe
09:29:45 <dons> yeah ok.
09:29:56 <dons> 10 sounds a good point to aim for, I'm pretty sure we can get there
09:30:15 <joelr1> dons: thanks!
09:30:22 <dons> what kind of machine?
09:30:28 <joelr1> dons: who's working on it this week? i thought the hackathon is over
09:30:29 <bringert> bakert: I wrote it already
09:30:35 <joelr1> dons: oh, a lowe-end P166
09:30:44 <dons> joelr1: dcoutts and I are in Nice for a conference, hacking away on ti
09:30:47 <dcoutts__> joelr1: no chance!
09:30:50 <dons> and lennart is back home, still helping
09:30:50 <dcoutts__> not a P166
09:30:51 <joelr1> dcoutts__: hahaha
09:30:52 <bringert> bakert: it's not in the version of the time library that comes with ghc 6.6 though
09:31:07 <bakert> bringert, you lovely man.  can i download it/darcs get it from somewhere?
09:31:24 <bringert> bakert: darcs get http://darcs.haskell.org/packages/time/
09:31:25 <nickm445> for a 3-gram and the input being "the small cat sat near the small dog." i need to output a table like this: []-> [the], [the] -> [small], [the, small]  -> [cat, dog.], [small, cat]  -> [sat], [cat, sat]    -> [near] etc.,
09:31:26 <lambdabot> Title: Index of /packages/time
09:31:36 <bakert> bringert, thanks
09:32:20 <joelr1> dons: seriously, though, i have no idea. i have a 2Gb MacBook Pro, Core Duo, 2Ghz. i want to move to Core2 Duo, though, and i heard that x86-64 haskell is slower than x86-32. maybe we could say a 64-bit machine?
09:32:28 <nickm445> hard to explain
09:32:45 <dons> so I'm getting around 4M/sec on a 1.6Ghz 3y.o laptop
09:32:56 <dcoutts__> joelr1: I've got a 1.8GHz amd64 to test on...
09:33:37 <araujo> hi
09:33:39 <joelr1> dcoutts__: that should do well
09:33:45 <dons> yeah, this SYB deriving looks easy
09:33:46 <dons> like 20 lines
09:34:04 <joelr1> dons: i still have a long road ahead of me :) all that learning
09:34:42 <dons> well, no ghc rts bugs yet I hope, in "Joel v GHC, The Rematch!"
09:34:48 <nickm283> sorry got kicked off
09:35:21 <bringert> dons, dcoutts_, kolmodin: maybe my choice to use the Binary class for reading and writing the tar format was wrong, since Binary is geared more towards serialization, not external formats
09:35:33 <dons> right.
09:35:34 <dcoutts__> bringert: exactly
09:35:40 * sorear pokes @seen
09:35:42 <dons> but the layer on top we needd to write should do this
09:35:45 <DracoCepheus> i guess this has been asked before, but i do not know where to look.  import Parsec fails on WinHugs ... what to i do?
09:35:52 <dons> we talked about this today
09:36:02 <dcoutts__> bringert: we need a layering like we have already in H98 for Show/Read on top of ShowS/ReadS combinators
09:36:02 <dons> there's an issue with using Binary to do parsing of structures
09:36:05 <sorear> "import Parsec" ? yow, that's an old hugs
09:36:06 <dons> yeah
09:36:14 <dons> so like Parsec versus Show/Read
09:36:24 <dons> you're trying to do binary parsing using a Show-like system
09:36:26 <dons> which is tricky
09:36:30 <nickm283> so any ideas about ngrams
09:36:44 <bakert> nickm283, what's the output of the program got to be?
09:36:45 <dons> but you can layer on top of those string writing primitives, and get a combinator approach
09:36:46 <glguy> someone is putting their homework off
09:36:50 <dcoutts__> bringert: so ShowS/ReadS are the basic combinators for parsing and pretty printing arbitrary text formats, while Show and Read classes provide a specific format for all Haskell types.
09:37:07 <dons> yeah
09:37:10 <DracoCepheus> working thorugh the parsec tut: file:///c:/Documents%20and%20Settings/Willem/My%20Documents/haskell/parsec.html
09:37:15 <dons> Put/Get are the Binary equivalents
09:37:26 <DracoCepheus> sorry, the link i pasted is local ...
09:37:36 <nickm283> i need the N-gram units to a table, and write out the results to a file for checking.
09:38:08 <DracoCepheus> should I use a different notation to "import Parsec"?
09:38:49 <sorear> import Text.ParserCombinators.Parsec ?
09:38:49 <joelr1> dons: i'll drink to that /no rts bugs/
09:39:46 <DracoCepheus> yes that works
09:40:02 <DracoCepheus> but the parsec docs are old, it seems
09:40:11 <sorear> very old...
09:40:25 <dons> joelr1: so we're having dinner tonight with the erlang bitstream guys
09:40:29 <dons> we'll see what brains can be picked
09:40:37 <DracoCepheus> any idea where i can find better docs?
09:40:38 <joelr1> dons: cool :D did you read the paper?
09:40:47 <dons> yeah, i was at the talk
09:41:18 <joelr1> dons: ok. i think networking will be the next haskell frontier, personally
09:41:26 <dons> yeah, I think so
09:41:29 <joelr1> dons: too bad GdH is not up-to-date
09:41:33 <dons> at least, that's my secret plan
09:41:50 <dons> binary + multicore, our fronts in the War on Error
09:41:52 <sorear> It might be nice to have something like planet. for darcs commits...
09:42:25 <joelr1> dons: a beachhead
09:42:43 <dons> yeah :)
09:43:00 <nickm283> bakert do you think you can help. dont want to waste your time
09:43:31 <dons> you doing homework problems or something, nickm283 ?
09:43:39 <kolmodin> bringert: I would really like for Binary to be able to do general binary stuff, not only serialization
09:43:44 <kolmodin> bringert: what do you think is missing?
09:44:15 <dons> kolmodin: yeah. so you saw this idea for Binary == Read/Show, and then the parsec library is something else on top of the underlying Get/Put monads
09:44:15 <bringert> kolmodin: the Binary class can't do it, but I think the package is enough
09:44:16 <emk> Off-topic niftiness (seen on Raganwald): http://www.scottaaronson.com/democritus/lec9.html
09:44:17 <lambdabot> Title: PHYS771 Lecture 9: Quantum
09:44:29 <joelr1> kolmodin: what's general binary stuff?
09:44:36 <bringert> kolmodin: I'll rewrite tar and see
09:44:36 <dons> its really this Get and Put that you need to call from a parsec/pretty printer system
09:44:38 <SamB> joelr1: I don't think selling source code with no strings attached counts as making it "proprietary"
09:44:47 <bakert> bringert++ for time parsing lib
09:44:50 <emk> Among other things, it contains an excellent explanation of qubit.
09:44:57 <dons> SamB: but the src is closed now, right?
09:45:15 <joelr1> SamB: did i miss the beginning of this conversation?
09:45:19 <SamB> oh, wait...
09:45:23 <SamB> hmm...
09:45:27 <dons> bringert: yeah, so the instances of Binary aren't appropriate for 'tar'
09:45:36 <SamB> that is nasty! "apart from reselling..."
09:45:40 <nickm283> dons: yea. and cant do it for squat. you anything about ngrams
09:45:56 <SamB> hmm. there *is* a loophole, though...
09:46:02 <kolmodin> bringert: yeah, true, the Binary class is only towards serialization
09:46:04 <bringert> dons: and I'm thinking that I shouldn't make Binary instances for my reading and writing
09:46:05 <SamB> it doesn't say anything about giving it away for free!
09:46:11 <dons> bringert: yeah
09:46:13 <bringert> since that's not really serialization
09:46:21 <joelr1> SamB: ah, i see what you are objecting to. basically, i stopped modifying the GPL code base. the "proprietary" one has enhancements.
09:46:24 <dons> bringert: ince that's like trying to do parsing  with Show/Read instances
09:46:33 <bringert> yeah
09:46:33 <dons> which you'd never try to do
09:46:34 <kolmodin> bringert: but I hope that Get and runGet is what you need
09:46:39 <dons> you'd write a parser, and a pretty printer class
09:46:47 <dons> and then write Ppr instances for your writing
09:46:48 <bringert> kolmodin: I think so, expect for laziness
09:46:56 <kolmodin> bringert: great
09:46:58 <bakert> nickm283, well i was only going to try and prompt you into finding a solution plus add any insight that i could.  i'm a newbie at haskell myself of three weeks.  i'd guess the best plan would be to find a place where you are stuck and ask for very specific help?  the people on this channel are very generous with their time if you can form a specific question.
09:46:58 <dons> that use the Get and Put monads , but from different classes
09:47:05 <dons> or explicitly (i.e. putWord8
09:47:17 <dons> the laziness issue is fixed now (?)
09:47:20 <dons> since I removed ErrorT
09:47:39 <kolmodin> bringert: we could also write a unsafeGetLazyByteString which would not check the remaining size, that would make your library able to return the size lazely
09:47:40 <dons> nickm283: yeah, specific questions. in general we don't help with homework though, other than to guide
09:47:55 * SamB wants more category theory in his language soup
09:48:07 <kolmodin> bringert: or something like that. I have to look further into it
09:48:08 <bringert> kolmodin: I think it's not really unsafe enough to be called unsafe*
09:48:11 <alexj__> dons: is binary serialization the right model?  e.g. perhaps you want to load your large datastructure lazily.  I think dcoutts once sent me a lazy loader for Data.Map
09:48:21 <dons> yeah, we do that
09:48:22 <kolmodin> bringert: true, but you get the picture
09:48:26 <bringert> right
09:48:29 <dons> it encodes and decodes lazily
09:48:39 <nickm283> i understand what you are saying bakert. i will try be more specific.
09:48:48 <dons> bringert: so we'll tweak the docs to say, "Data.Binary is for serialisatoin of Haskell types"
09:48:51 <kolmodin> bringert: I'm actually at chalmers now, trying to print some papers
09:48:58 <joelr1> dons: we do that lazily, does that apply to Data.Binary?
09:48:59 <dcoutts__> alexj__: I did? oh ok :-)   I know I wrote one for c2hs's precompiled header binary files.
09:48:59 <alexj__> my point is that you may not want to load the whole data.map into memory.  you only want the pairs you actually need.
09:49:02 <dons> and then "use Data.Binary.Parsec/Data.Binary.Pretty" for writing and reading external formats
09:49:03 <bringert> kolmodin: I'm at home, got a cold
09:49:06 <kolmodin> but I forgot my keycard, had to ask a friend to open
09:49:09 <kolmodin> bringert: right
09:49:09 <dons> joelr1: yeah
09:49:18 <dons> encoding and decoding is lazy (it uses lazy bytestrings)
09:49:19 <kolmodin> (so do I, but I work anyway.. :))
09:49:25 <joelr1> dons: ok
09:49:28 <dcoutts__> alexj__: yes, in some apps that's a massive benifit, eg c2hs, where you only look up a few symbols from the C header file.
09:49:28 <sorear> alexj__: ndm is implementing that
09:49:29 <alexj__> dcoutts__: i attribute this idea to you.  I can't remember the details.
09:49:30 <dons> so e.g. lambdabot only laods things from its disk cache when you run some @command
09:49:46 <sorear> alexj__: DeferredBinary i think it was called
09:49:50 <SamB> oh, what a delightful turn of phrase: "shining beacon of stupid"
09:49:56 <dcoutts__> alexj__: we've got lazyPut, lazyGet
09:49:58 <kolmodin> annoying! my jobs are stuck in the printer queue and I can't leave the room to see what's wrong
09:49:59 <dons> ah you want to  just seek around on disk, alexj__ ?
09:50:11 * sorear advocates mmap(2)
09:50:33 <dcoutts__> sorear: want to make the mmap in the Data.ByteString work? :-)
09:50:33 <kolmodin> bye for now
09:50:44 <dons> work portably
09:50:50 <sorear> dcoutts__: sounds tempting
09:50:50 <dons> needs System.IO.Posix.mmap
09:50:56 <dons> and the win32 mmap is already in place
09:51:00 * SamB is reading planet haskell
09:51:00 <dcoutts__> sorear: we've got an impl for unix but none for win32 at the moment so we couldn't put it in the base lib
09:51:02 <alexj__> conceptually, I would like something that is not aware of disk structure.   for example, I might want to save/load over http.  I would need to structure the save urls for lazy loading of what is actually needed.
09:51:38 <sorear> windows has an MapViewOfFile, but IIRC it does dumb stuff like turn off cacheing.
09:51:43 <alexj__> dons: perhaps that is just an entirely different issue/application.
09:51:55 <dcoutts__> sorear: oh, ok there is a win32 mmap thing apparently so it's just a bit of work to allow the ByteString lib to use it or expose it
09:51:59 <bringert> should I write functions like
09:52:00 <bringert> writeTarArchive :: TarArchive -> ByteString, readTarArchive :: ByteString -> TarArchive
09:52:00 <bringert> or
09:52:00 <bringert> putTarArchive :: TarArchive -> Put (), getTarArchive :: Get TarArchive
09:52:22 <dcoutts__> bringert: probably the former
09:52:27 <sorear> dcoutts__: note that it has been >3 yrs since I touched the windows api
09:52:37 <alexj__> dons: actually the http load process would just use range headers to load lazily.
09:52:40 <dons>  writeTarArchive t = runPut (put t)
09:52:45 <joelr1> bringert: i agree with dcoutts__ cause that will enable one to ship a tar file over the network, for example
09:52:49 <dons> well, s/put/prettyprint/
09:52:57 <dcoutts__> bringert: so you can write them to disk immediately or spew them into a Put stream
09:53:11 <dons> alexj__: hmm
09:53:20 <bringert> ok, so the API will not expose any stuff from binary, that sounds good
09:53:25 <dons> yeah
09:53:37 <dons> just the underlying fast string append/Writer and Reader
09:53:40 <dcoutts__> bringert: there's almost no overhead to putting a lazy bytestring into a Put stream
09:53:43 <dons> s/Reader/reader
09:54:28 <bringert> dons: so, where do I find this Data.Binary.PrettyPrint?
09:54:31 <bringert> :-)
09:54:31 <dons> up to 17M/sec now , on the amd64 box, joelr1
09:54:36 <joelr1> dons: wow!
09:55:20 <dons> bringert: heh. so it would use the HughesPJ pretty printer combinators, for binary
09:55:23 <dons> roughly
09:55:30 <dons> or something like the erlang combintaors
09:55:38 <joelr1> dons: personally, i think that with data-parallel arrays (with fusion), new binary serialization and good solid networking haskell is gonna be unstoppable
09:55:40 <dons> and the reading would use parsec-like combinators for binary
09:55:52 <sorear> I see a long snakeing well-formatted chain of ['0', '1'] :)
09:55:55 <dons> yeah, its a fun time to work on this stuff
09:56:04 <joelr1> dons: at least in the kind of programming that i do :-)
09:56:12 <dons> ?users
09:56:13 <lambdabot> Maximum users seen in #haskell: 300, currently: 300 (100.0%), active: 43 (14.3%)
09:56:21 <sorear> yip!
09:56:44 <axem_06> hi
09:56:53 <dons> http://darcs.haskell.org/packages/hscom/
09:56:53 <dons> This is a FFI library for Microsoft COM.
09:56:54 <sorear> hi.
09:56:54 <lambdabot> Title: Index of /packages/hscom
09:57:04 <dons> ?where+ hscom http://darcs.haskell.org/packages/hscom/
09:57:04 <lambdabot> Done.
09:57:06 <axem_06> i have a problem with some haskell code, i was wondering if someone could take a look at it :)
09:57:07 <sorear> @users
09:57:07 <lambdabot> Maximum users seen in #haskell: 301, currently: 301 (100.0%), active: 45 (15.0%)
09:57:12 <joelr1> dons: i have much more time to work on stuff these days as i work part-time. unfortunately, trading takes the rest of time now and i keep putting programming off. no more, though.
09:57:39 <sorear> axem_06: sure, paste if if <=3 lines, @paste it if longer
09:57:41 <sorear> @paste
09:57:42 <lambdabot> http://paste.lisp.org/new/haskell
09:57:56 <joelr1> dons: i'm waiting for one of two brokers to set me up with the market data and trade execution api and once they do i can start moving with the market data handler
09:58:01 <axem_06> ill use paste/lisp, 1sec
09:58:21 <emk> Has anyway written a good matrix library for Haskell? I don't need actual _performance_, but the ability to work with NxM matrices, multiply them, etc., would be very good.
09:58:39 <bakert> thanks for your help today everyone.  bye
09:58:43 <lisppaste2> axem_06 pasted "ngram-help!" at http://paste.lisp.org/display/35404
09:58:51 <dons> mm. I wonder. check haskell.org under the libraries link, and under data structures or math
09:59:06 <sorear> I think that falls under the category of the compgeo lib I keep not getting around to writing :)
09:59:45 <axem_06> im not sure whats going on in line 79, it gets a type error
09:59:59 <axem_06> *** Type           : [String]
09:59:59 <axem_06> *** Does not match : Map [[Char]] [[Char]]
10:00:24 <emk> dons: Ah, it looks like there's two of 'em.
10:00:27 <emk> Thanks.
10:01:05 <sorear> axem_06: which line is 79? lisppaste doesn't number them.
10:01:11 <bringert> dons: like someone said yester day, maybe the Binary cleass should be in Data.Binary.Serialization or something, and the primitive stuff in Data.Binary
10:01:37 <axem_06> its the nextWord bit,
10:01:51 <ookk> how do i get haskell to format an Integer as a hexadecimal number?
10:01:52 <axem_06> line 79 is let resultList = (lookupMap (lastNWords 2 sentence) ["--dosearch--"] ngrams)
10:02:12 <trurl_> sorear: you can enable line numbers at the bottom
10:02:16 <sorear> ookk: showIntAtBase?
10:02:28 <ookk> sorear, which module is it in?
10:02:39 <sorear> trurl_: wow. how could I not notice...
10:02:43 <sorear> ookk: Numeric
10:02:55 <ookk> thx
10:03:19 <sorear> ookk: :br in ghci tells me there is a showHex function
10:03:25 <sorear> > showHex 127
10:03:26 <lambdabot>  <[Char] -> [Char]>
10:03:29 <sorear> > showHex 127 ""
10:03:31 <lambdabot>  "7f"
10:03:48 <ookk> even better
10:03:49 <ookk> just what i want
10:03:51 <ookk> thx guys
10:03:56 <sorear> yw
10:04:24 <yosemite> is there some conditional form in haskell like (cond ...) in scheme?
10:04:31 <sorear> almost
10:04:37 <sorear> you can fake it with:
10:04:43 <sorear> case () of _ | foo = bar
10:04:53 <sorear>               | baz = quux
10:05:07 <sorear>               | otherwise = furgle
10:05:38 <dcoutts__> yosemite: or if you're at the top level of a function then there's no need to fake it:
10:05:43 <DracoCepheus> can any LALR grammar also be parsed by an LL parser (ie. parsec)?
10:05:50 <dcoutts__> foo x | isBar x = ...
10:05:56 <dcoutts__>      | etc = ...
10:06:14 <axem_06> any ideas sorear?
10:06:37 <sorear> axem_06: what monad are you trying to use on L78 'do' ?
10:06:59 <sorear> axem_06: you're using the old-style reader (->) r, which is usually unintentional
10:07:47 <sorear> axem_06: nextWord's type has 3 args, but its definition only has two, so finalResult is assumed to be a function type
10:08:38 <sorear> is that the problem?
10:09:05 <SamB> @vera lalr
10:09:06 <lambdabot> No match for "lalr".
10:09:15 <SamB> @foldoc lalr
10:09:16 <bringert> dons, dcoutts__: getLazyByteString and putLazyByteString are pretty long names, and don't really say that just the bytes are output. how about get/putBytes? but then the question is what to do with get/putByteString
10:09:17 <lambdabot> *** "lalr" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
10:09:17 <lambdabot> LALR
10:09:17 <lambdabot>  
10:09:17 <lambdabot>         {Look Ahead Left-to-right parse, Rightmost-derivation}
10:09:17 <lambdabot>  
10:09:47 <dcoutts__> bringert: aye, we're not too attached to the names
10:12:55 <axem_06> im not sure, ill have a look, 1sec
10:13:00 <sorear> ok
10:13:11 <yosemite> dcoutts__: sorear: thanks!
10:14:49 <sorear> yw
10:16:04 <SamB> anyway parsec parsers are probably not LL...
10:16:23 <SamB> I mean, they aren't exactly context-free...
10:16:54 <axem_06> sorear: im not sure, im really not so familiar with haskell
10:17:07 <velco> they can parse LL(1) grammars.
10:17:12 <axem_06> what would you suggest i change?
10:18:13 <SamB> velco: certainly true...
10:18:15 <SamB> hmm.
10:18:16 <dcoutts__> joelr1: hmm, at the moment we're only getting about 3 MB/s tops
10:18:33 <joelr1> dcoutts__: didn't you just mention 17?
10:18:48 <dcoutts__> joelr1: the benchmark was wrong :-)
10:18:51 <sorear> axem_06: what is the Int parameter to nextWord intended to represent ?
10:19:01 <joelr1> dcoutts__: ah, ok then
10:19:21 <joelr1> dcoutts__: does this have anything to do with the perceived slowness of 64-bit ghc?
10:19:37 <dcoutts__> joelr1: maybe a bit, but only a smallish constant factor
10:19:50 <joelr1> dcoutts__: ok
10:19:51 <dcoutts__> joelr1: it's not going to be 10MBs in 32bit mode
10:20:03 <dcoutts__> joelr1: I can test, I have a 32bit chroot
10:20:04 <joelr1> dcoutts__: any reason?
10:20:14 <glguy> My Roflcopter goes dfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfdfe
10:20:15 <largos> could someone point me to intstructions for turning latex-based lhs files into pdfs?  google hasn't turned up anything of use :(
10:20:17 <dcoutts__> joelr1: we've only just begun to optimise it
10:20:32 <sorear> largos: pdflatex
10:20:43 <joelr1> dcoutts__: i mean, do you think it will never be 10mbs in 32-bit mode? it will always be less? not sure i understood
10:20:44 <axem_06> im not 100% sure,
10:21:08 <dcoutts__> joelr1: not sure yet, lemme find a reference...
10:21:14 <largos> sorear: I'll try pdflatex, but latex failed (I think I need a style file or something that defines the code regions)
10:21:32 <sorear> largos: did you run it on the right start file?
10:21:56 <largos> sorear: ah, probably not.  I'm only interested in one file out of the darcs repo
10:22:00 <sorear> largos: there is actually a thread on -cafe right now about someone trying to format darcs
10:22:06 <bringert> dcoutts__: I think the get/putLazyByteString should have nice names and be promoted rather than get/putByteString since they are more primitive and don't copy
10:22:25 <sorear> it was mentioned that you needed to start at the toplevel
10:22:29 <dcoutts__> bringert: get/putByteString don't copy either
10:22:38 <bringert> oh, right
10:22:47 <bringert> wait, why?
10:22:52 <largos> sorear: ok, I read part of that thread, but it looked like it was devolving into a discussion of haskell syntax vs. latex.  Thanks
10:22:59 <bringert> getByteString has to copy, right?
10:23:11 <dcoutts__> bringert: feel free to propose an api for the mid/lower layer below the Binary class, the equivalent of the ShowS/readS layer
10:23:28 <dcoutts__> bringert: getByteString has to copy if it crosses a chunk boundary
10:23:38 <dcoutts__> so if you've got 32k chunks...
10:23:44 <bringert> right
10:23:50 <dcoutts__> but put never copies
10:24:23 <ookk> is there a way to get the bits of an Word64 / Integer as a list?
10:24:33 <sorear> if you were reading a long lazy bytestring, does that copy, or does it adjust its chunk boundaries to fit the source string?
10:24:49 <sorear> ookk: yes
10:25:25 <ookk> sorear, without me having to write it myself?
10:25:25 <sorear> > showIntAtBase 124 (head . show) 2 ""
10:25:27 <lambdabot>  "2"
10:25:28 <dcoutts__> sorear: it'll use exactly the same chunk boundaries as the source
10:25:34 <sorear> > showIntAtBase 2 (head . show) 124 ""
10:25:35 <lambdabot>  "1111100"
10:25:41 <ookk> ah nice
10:25:45 <ookk> thx
10:25:50 <dcoutts__> sorear: it just uses take on the internal lazy ByteString
10:25:54 <sorear> dcoutts__: makes sense, just making sure you had thought of it :)
10:26:04 <dcoutts__> sorear: check the source
10:26:10 <dcoutts__> it's quite pretty :-)
10:26:17 <dcoutts__> getLazyByteString n = readN n id
10:26:28 <dcoutts__> which is even simpler than:
10:26:31 <dcoutts__> getByteString n = readN (fromIntegral n) (B.concat . L.toChunks)
10:26:50 <sorear> that's bad
10:26:56 <bringert> dons: how come Put no longer has a type argument? since it's a monad, couldn't return be useful once in a while
10:26:57 <dcoutts__> not really
10:27:02 <sorear> that will concat the whole file before reading any of it
10:27:19 <sorear> oh sorry nm
10:27:20 <dcoutts__> sorear: no, it only concats the bit you're getting
10:27:32 <dcoutts__> sorear: which is probably just one chunk so not even any copying
10:27:35 <sorear> dcoutts__: sorry, HOF confusion
10:27:53 <dcoutts__> np, readN isn't standard, it's in the lib there
10:28:01 <SamB> hmm.
10:28:36 * SamB no longer feels like answering DracoCepheus' question, even if he knew the answer
10:29:13 <glguy> has he asked one in a while? (I just got back)
10:29:47 * kolmodin is home
10:29:52 <jethr0> the question is badly posed. there's no such thing as LL and LALR. they have to constrained by the lookahead. but i don't know what the relation between LALR(n) and LL(m) with m>n is
10:30:03 <glguy> ?seen
10:30:03 <lambdabot> Lately, I have seen _mauricio_, axem_06, br1, bringert, dcoutts__, elpolilla, erg0t, fglock, glguy, gly, jethr0, joelr1, kolmodin, largos, lithyum, lleberg, ohmega, ookk, putter, samb, sebazzz,
10:30:03 <lambdabot> sorear, velco and xdie.
10:30:07 <emk> Hmm. Type-checking matrix multiplication in Haskell is rude.
10:30:25 <SamB> oh, he asked if all LALR grammars could be parsed with LL parsers like Parsec parsers... but he seems to be gone now...
10:30:25 <emk> I'm not sure I'd even want to think about generalizing to tensors.
10:30:26 <glguy> and is suited for a language with fullydependent types
10:30:38 <SamB> probably he meant LALR(1) and LL(1)
10:31:25 <SamB> though parsec parsers are obviously not constrained to be LL(1) parsers...
10:32:09 <kolmodin> using lambdabot's ?seen is an excellent way to ping a lot of people, quite annoying
10:32:10 <SamB> unless LL(1) is a lot more powerfull than I know...
10:32:15 <emk> glguy: Do you really need fully dependent types to do it? I mean, Frederik Eaton did it using Zero, Succ, etc., in regular Haskell.
10:32:22 <jethr0> parsec is LL(infinite) and can AFAIK parse any LALR grammar with bounded lookahead
10:32:22 <dcoutts__> kolmodin, aye. I agree.
10:32:35 <dcoutts__> kolmodin, see you later, we're out for dinner
10:32:43 <dcoutts__> kolmodin, oh I've got an improved benchmark.hs
10:32:49 * dcoutts__ -> off
10:33:16 <sorear> @. elite seen
10:33:17 <lambdabot> lA+3lY, I hAv3 $Een _/\/\AUri(Io_, 4xE/\/\_06, BR1, 8riN9ER+, 3|P0Li|la, EMk, 3rG0T, phg|0cK, g1guY, gLY, J37hr0, j031r1, K0lmoDIn, 1ArG0s, |i7HyUm, O|-|/\/\EGa, 00xK, Pu+73R, 5A/\/\8, s3BazsZ,
10:33:17 <lambdabot> soReAr AnD XDIE.
10:33:24 <sorear> that should be safe :)
10:34:24 <emk> sorear: Not so much, at least for me.
10:34:57 <paolino> is there a haskell.org darcs repository where I can keep my code ?
10:35:19 <glguy> The presentation will cover the key aspects of our design such
10:35:19 <glguy> as the use of GADTs to combine matrix and vector types, and the
10:35:19 <glguy> use of higher-rank types and staging (namely, Template Haskell)
10:35:19 <glguy> to closely approximate a dependent-type system. Then, we will
10:35:19 <glguy> give a demonstration of interactive use, and compare our system
10:35:20 <glguy> to existing systems in the areas of speed and usability.
10:35:32 <glguy> -- paragraph from a paper by frederick eaton
10:37:17 <TomMD> ?seen
10:37:17 <lambdabot> Lately, I have seen _mauricio_, br1, bringert, elpolilla, emk, erg0t, fglock, glguy, gly, jethr0, kolmodin, largos, lithyum, ohmega, ookk, paolino, putter, samb, sebazzz, sorear, tommd and xdie.
10:37:25 <glguy> ?losers
10:37:25 <lambdabot> Maximum users seen in #haskell: 302, currently: 296 (98.0%), active: 43 (14.5%)
10:37:45 <sorear> FTR, the command is spelled @users.
10:37:59 <bringert> can we try to to restrict the use of @seen? use @seen if you are looking for someone in particular
10:38:05 <glguy> I'm going to keep doing that until it catches on
10:38:34 <bringert> now my irc client alerts me every time my nick appears in the @seen list
10:38:35 * sorear goes to write a patch
10:38:39 <TomMD> bringert: sorry, I just figured ?seen would tell me what the command did.  I couldn't tell from the leet version.
10:38:48 <sorear> TomMD:
10:38:51 <sorear> @help seen
10:38:52 <lambdabot> seen <user>. Report if a user has been seen by the bot
10:39:07 <bringert> TomMD: no problem. the command should probably be fixed
10:39:37 <glguy> fixed?
10:39:45 <glguy> ?teen
10:39:46 <lambdabot> Lately, I have seen _mauricio_, br1, bringert, elpolilla, emk, erg0t, fglock, glguy, gly, jethr0, kolmodin, lithyum, ohmega, ookk, paolino, putter, samb, sebazzz, sorear, tommd and xdie.
10:39:54 <bringert> grr
10:39:59 <TomMD> presumably to require the <user> argument
10:40:03 <glguy> eww
10:40:09 <glguy> How is that "fixed"
10:40:15 <kolmodin> gdamnit!
10:40:19 <kolmodin> :D
10:40:22 * sorear is writing a patch now
10:40:27 <bringert> good
10:40:30 <emk> Because it will stop pinging me every 10 seconds when I trying to grok math.
10:40:51 <TomMD> who has admin to the lamdabot?  don...s?
10:41:02 <glguy> that... or just setting your highlighting to not include lambdabot...
10:41:04 <kolmodin> you can still allow the old behavior if you send it as a privmsg
10:41:06 <allbery_b> it's not so nice to wake up half the channel for no reason :)
10:41:12 <kolmodin> but not in a channel, please
10:41:16 <paolino> is there any server in the haskell world where people can keep their pfojects for free ?
10:41:36 <sorear> darcs.haskell.org
10:41:57 <sorear> note that the project registration daemon is human
10:42:11 <paolino> :)
10:42:27 <SamB> a real live daemon?
10:42:37 <paolino> consider it noted
10:42:54 <emertens> I dont know at what point i got disconnected, but I was saying: use an irc client that is configurable enogh not to have seen problems (like mIRC, say)
10:44:28 <paolino> sorear , is there a mail address where to ask ?
10:45:12 <bringert> paolino: you need to be known and trusted for that
10:46:00 <bringert> darcs.haskell.org is not really for general project hosting
10:46:02 * sorear wonders what the cutoff for known is
10:46:31 <daniel_larsson> sorear: having a project registered at darcs.haskell.org :)
10:46:52 <bringert> pretty much true actually :-)
10:47:26 <Lemmih> paolino: You can get server space on my box, if you want.
10:47:56 <paolino> thanks Lemmih, accepted
10:49:20 <sorear> I've got an ISP webhost, but the quota is less than a twentieth of my pop3 quota...
10:49:23 <bringert> htar now takes about 2x longer than BSD tar to untar darcs-1.0.7
10:50:03 <sorear> that's good?
10:51:01 <bringert> well, I just wrote it
10:51:18 <bringert> and it uses the brand new binary package
10:51:18 <sorear> good!
10:51:20 <allbery_b> emertens: so, we're all required to hack our clients to recognize and ignore @seen, for your convenience?
10:52:25 <allbery_b> (keep in mind that just turning off notification when one's nick is mentioned is *not* acceptable)
10:52:34 <pejo> bringert, using some bindings against some libtar or similar?
10:53:00 <bringert> pejo: no, plain haskell using the binary library
10:53:08 <bringert> i.e. lazy bytestring
10:54:52 <bringert> w00t! 10% faster than BSD tar
10:55:19 <bringert> for a tarball of 170 jpgs around 400 k each
10:55:24 <sorear> hurray!
10:55:36 <sorear> dons: @seen fixing patch sent.
10:55:42 <bringert> though htar doesn't handle timestamps and ownership right
10:56:06 <kolmodin> bringert: be careful with caching and stuff, so the tests get representative
10:56:16 <kolmodin> but yay!
10:56:17 * sorear suddenly realized he forgot to even try compiling the bot
10:56:23 <bringert> right, I re-rean. the first run took 10x longer
10:56:41 <sorear> dons: don't bother rebuilding yet :(
10:56:42 <bringert> 10% was after a few runs of both
10:56:47 <kolmodin> ok, very good then!
10:57:24 <bringert> it's not really fair, since they don't do the same thing yet, but I think it should be about the same
10:57:49 <kolmodin> they don't?
10:58:18 <bringert> some file types and metadata is not handled yet
10:58:26 <bringert> the C version is faster for small files and the Haskell version is faster for large files
10:58:31 <kolmodin> ah, ok
10:59:03 <kolmodin> so, unless you have tons of small files to untar I'd know which application I'd choose... :)
10:59:36 <bringert> most tarballs contain lots of small files though
11:00:16 <chessguy> greetings haskellers
11:00:22 <bringert> I meant archives containing small vs large files, I haven't tested different size archives
11:00:23 <kolmodin> oh, you mean that it depends on the size of the files inside the tarball, not the size of the tarball itself
11:00:28 <bringert> right
11:00:37 <sorear> greetings, chessguy
11:00:37 <kolmodin> oh ok
11:01:09 <bringert> for archives with small files the header parsing and meta data handling is more significant than the file writing
11:01:10 <ctkrohn> bringert: are you planning on adding more functionality to the GD bindings you wrote?
11:01:22 <axem_06> can anyone else help me with this, http://paste.lisp.org/display/35404
11:01:23 <bringert> ctkrohn: when I need them :-)
11:01:28 <axem_06> the problems on line 79
11:01:34 <bringert> ctkrohn: additions are welcome though
11:01:47 <ctkrohn> bringert: makes sense... I'm working on adding some stuff now actually
11:01:47 <sorear> ah, the bot compiles now :)
11:01:56 <jethr0> axem_06: how would we know where line 79 is
11:02:02 <ctkrohn> bringert: I'm using it to write a simple captcha
11:02:04 <kolmodin> bringert: is the lib online somewhere?
11:02:16 <axem_06> jethr0: tick 'show line numbers' on the bottom of the page
11:02:20 <kolmodin> lib/app
11:02:22 <jethr0> ah
11:02:23 <bringert> kolmodin: http://www.cs.chalmers.se/~bringert/darcs/tar/
11:02:24 <lambdabot> Title: Index of /~bringert/darcs/tar
11:02:38 <sorear> sorear-lambdabot: @seen
11:02:39 <sorear-lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
11:02:50 <jethr0> axem_06: and what error message do you get?
11:03:03 <kolmodin> bringert: ta
11:03:07 <axem_06> Type error in application
11:03:07 <axem_06> *** Expression     : lookupMap (lastNWords 2 sentence) ["--dosearch--"] ngrams
11:03:07 <axem_06> *** Term           : ngrams
11:03:07 <axem_06> *** Type           : [String]
11:03:07 <axem_06> *** Does not match : Map [[Char]] [[Char]]
11:03:15 <sorear> sorear-lambdabot: @quit
11:03:31 <resiak> Why is everyone obsessed with n-grams at the moment?
11:03:57 <axem_06> its for an assignment due in tonight, but it wont compile :'(
11:04:05 <jethr0> lookupMap :: [String] -> [String] -> NGram -> [String]
11:04:12 <sorear> dons: the patch has been fixed, tested, and resent.
11:04:34 <jethr0> return $ (lookupMap (lastNWords 2 sentence) ["--dosearch--"] ngrams)!!0 :: [String]
11:04:59 <jethr0> by taking the first element of the result from lookupMap you're returning "String" instead of "[String]"
11:05:12 <Philippa> sorear: y'know, complaining about "massively broken IRC clients" that happen to've been doing the same thing they've been doing for over a decade is excessively snarky
11:05:31 <jethr0> axem_06: oh, or is that list monad?
11:06:30 <ralf`> Where can I put stuff that I want to be always in the scope of import a
11:06:47 <Philippa> btw, does the patch have lambdabot PM the normal reply to the person asking as well?
11:06:49 <jethr0> axem_06: nm, i'm in my "making-errors-with-chance>0.5-mode" again...
11:06:54 <sorear> jethr0: it's a reader monad - the equation has two args, the type 3.
11:06:59 <jethr0> but it's kinda hard to review so much code at once
11:07:02 <sorear> Philippa: yes
11:07:06 <axem_06> i still get the same error :(
11:07:29 <bringert> Igloo: any chance you could update http://urchin.earth.li/darcs/ian/inflate/ to use cabal and compile on GHC 6.6?
11:07:33 <lambdabot> Title: Index of /darcs/ian/inflate
11:07:34 <sorear> further, it operates normally in private messages
11:07:37 <bringert> Igloo: or should I?
11:07:43 * jethr0 get's something to eat
11:07:48 <astrolabe> axem: does it not give a line number?
11:08:00 <Igloo> bringert: What's the problem with 6.6?
11:08:15 <sorear> fps?
11:08:18 <Igloo> bringert: That's what I've been using, but I might have forgotten to add a file or something
11:08:30 <bringert> Igloo: that might not be it, I just got an error compiling Test.hs
11:08:41 <bringert> Test.hs:25:70:
11:08:41 <bringert>     Couldn't match expected type `Data.ByteString.Lazy.ByteString'
11:08:41 <bringert>            against inferred type `Octets'
11:08:54 <Igloo> bringert: Ah, compile Foo.hs instead
11:09:11 <bringert> Igloo: Foo.hs:7:7:
11:09:12 <bringert>     Could not find module `Utils':
11:09:56 <Igloo> bringert: Ooops, I've pushed a patch to add it
11:10:10 <bringert> Igloo: I want to use inflate to implement -z for htar. is there anything missing for that?
11:10:47 <Igloo> For uncompression, it's almost there
11:11:10 <Igloo> Inflate decompresses the actual stream, and Foo.hs reads the gzip header and inflates the contents
11:11:29 <bos_> bringert: why aren't you just using zlib?
11:11:36 <Igloo> It doesn't read the footer, and if you concatenate 2 .gz files then it'll similarly ignore the second one
11:11:46 <bringert> bos_: portability
11:11:55 <Igloo> bos_: To avoid dependencies on C libs that might be hard to get on e.g. Windows
11:11:57 <bos_> zlib's not portable?
11:12:00 <bos_> ah.
11:12:13 <bringert> bos_: also, the joy of writing pure haskell
11:12:14 <sorear> Windows ships with libpng, which depends on zlip
11:12:16 <bos_> that's right, i forget that some people use windows :-)
11:12:36 <axem_06> jethr0: sorry i just got disconnected
11:12:51 <axem_06> jethr0: i tried what you suggested, but it came up with the same error
11:13:16 <sorear> Portability issues are probably best handled in dcoutts_'s code
11:13:30 <jethr0> nm, my brain's disconnected right now as well... also, i'm off to supper. maybe i'll have a look at it when i come back
11:14:04 <axem_06> ok, thanks for your help
11:15:43 <mgsloan> does (sequence_ . map) have some synonym? I seem to possibly remember something...
11:16:23 <Igloo> mapM_
11:16:31 <glguy> mapM_ is (sequence_ .) . map
11:16:46 <sorear> @src mapM_
11:16:46 <lambdabot> mapM_ f as = sequence_ (map f as)
11:17:01 <sorear> @pl sequence_ . map
11:17:02 <lambdabot> sequence_ . map
11:17:08 <sorear> @pl (sequence_ .) . map
11:17:08 <lambdabot> (sequence_ .) . map
11:17:16 <malebria> more than one . makes things very unreadable.
11:17:19 <mgsloan> ah, cool, thanks
11:17:37 <bringert> Igloo: ok, seems to work. thanks!
11:18:12 <bringert> Igloo: will you cabalize it, or should I?
11:18:16 <lisppaste2> mgsloan annotated #35086 with "main rewrite" at http://paste.lisp.org/display/35086#1
11:18:38 <mgsloan> doh, didn't actual mean for that to trigger irc
11:18:56 <glguy> ?unpl (sequence_ .) . map
11:18:56 <lambdabot> (\ d g -> sequence_ (map d g))
11:19:02 <Igloo> bringert: How about I tidy up the gunzip bit, put things in a sensible place in the module namespace and cabalise it tonight?
11:19:14 <bringert> Igloo: sounds good
11:19:29 <bringert> sorry, didn't mean to rush you
11:19:40 <bringert> do it whenever
11:20:13 <sorear> ?. pl unpl (sequence_ .) . map
11:20:14 <lambdabot> (sequence_ .) . map
11:20:23 <Igloo> No problem, I should do it soon while it's in my mind  :-)
11:21:13 <principle> http://www.randomhacks.net/articles/2005/12/03/why-ruby-is-an-acceptable-lisp
11:21:15 <lambdabot> Title: Why Ruby is an acceptable LISP, http://tinyurl.com/h63pv
11:21:32 <principle> discussions like that make me proud of the Haskell community.
11:21:33 <sandal> :) that's a pretty good article
11:21:47 <syntaxfree> the discussion is apalling.
11:22:24 <bringert> Igloo: it takes 2.2s to inflate darcs-1.0.7.tar.gz, which is 986k compressed. that's already acceptable for source tarballs
11:22:32 <bringert> well, on a pretty fast machine
11:22:45 <bringert> hmm, it would be nice to parallelize it
11:22:58 <sorear> muahahaha
11:23:21 <sorear> a zip file could easily be inflated in parallel
11:23:22 <Igloo> It doesn't parallelize sanely
11:23:25 <sandal> yeah, the comments get a little ranty
11:23:39 <sorear> but hey, I'll try and parallelize inflate
11:23:43 <syntaxfree> they're not ranty, they're just ...misguided.
11:23:49 <sorear> inventing algorithms is fun
11:23:56 <syntaxfree> I mean, people argue about petty details of syntax.
11:23:59 <bringert> Igloo: ah, right, hard to know where to start, and it uses that crazy window for back-references
11:24:01 <Igloo> Finding the start of the next block requires inflating the current one
11:24:05 <sandal> Hehe.
11:24:13 <sandal> LISP people are mean!
11:24:14 <sandal> ;)
11:24:18 <Igloo> Ah, yes, the last-32k-buffer too
11:24:28 <sorear> there are other ways to parallelize
11:24:52 <syntaxfree> some people actually said that Haskell's big advantages are pattern-matching, guards and list comprehensions.
11:24:57 <sorear> if you can keep tight synchronization, you could fex. run copying and decoding in parallel.
11:24:57 <syntaxfree> wtf?
11:25:04 <sandal> What is annoying is people with mediocre skills in both languages rant about how one is less capable than another
11:25:10 <syntaxfree> I mean, it seems people can't see beyond the syntax.
11:25:20 <SamB> syntaxfree: pattern matching is probably about as usefull as type checking!
11:25:26 <sandal> um... if I wanted regexen, I'd use Ruby, especially once Onigurama is core.
11:25:26 <sorear> Tu-ring! Tu-ring! Tu-ring!
11:25:36 <sandal> If I wanted list-comprehensions, I'd use python
11:25:40 <mgsloan> most languages are fairly equally capably
11:25:43 <mgsloan> *capable
11:25:43 <sandal> I mean, if that was my biggest goal
11:25:54 <mgsloan> (and no, i'm not going to mention turing...)
11:26:02 <seliopou> SamB: it's what makes type checking haskell possible!
11:26:03 <syntaxfree> pattern-matching is trivially replaced by nested ifs in any case I can think of.
11:26:17 <SamB> syntaxfree: oh?
11:26:28 <SamB> I'd like to see you write a haskell program without pattern matching ;-)
11:26:42 <SamB> syntaxfree: anyway the nested ifs are way longer
11:26:46 <syntaxfree> hehe. well, provided I have enough facilities to deal with types, mind you.
11:26:53 <seliopou> syntaxfree: think about using tuples without pattern matching
11:26:57 <mgsloan> depends on if you count taking apart ADTs/lists as pattern matching
11:27:01 <sorear> syntaxfree: try replacing the pattern matching in isJust
11:27:02 <syntaxfree> yes, at some point someone needs to write head (a:as) = a
11:27:09 <SamB> even Python supports pattern-matching for tuples ;-)
11:27:21 <sorear> irrefutable patterns are isomorphic to projections
11:27:23 <syntaxfree> yes, yes. you just need enough destructors.
11:27:36 <sorear> cases are isomorphic to generalized destructors
11:27:38 <mgsloan> guards are also in that whole nested if, and I never use list comprehensions :P
11:27:46 <sorear> you don't need isJust, but you do need maybe
11:27:57 <syntaxfree> when I began programming in Haskell, all my functions were in guards.
11:28:02 <syntaxfree> Now I almost never use them.
11:28:06 <sorear> I use list comprehensions occasionally.
11:28:18 <SamB> yeah, me too. ocassionally.
11:28:21 <syntaxfree> I use list comprehensions to concoct artificial examples/tests.
11:28:23 <mgsloan> I might use it for a particularly apt task
11:28:24 * glguy laughs to himself as he reads some of the comments that claim that ruby / lisp is a functional language on that "ruby as acceptable lisp" post
11:28:26 <mgsloan> but not all the time
11:28:30 <sorear> e.g. in vty is a 10-line solid block of list comprehensions
11:29:02 <sorear> the comprehensions handle all the mix of regularity and irregularity of the Linux keyboard escape codes easily
11:29:05 <sandal> I really like this community, as a complete n00b (to haskell) by the way
11:29:05 <syntaxfree> Anyway, people ooh'ing and aah'ing about guards don't even *dream* of program transformations.
11:29:05 <PaulAJ> I sometimes find myself composing up some mix of filter and map, and then translate into a LC
11:29:21 <syntaxfree> I think their head would just blow out watching @free
11:29:24 <mgsloan> Well, a true lisper would argue that everything is a subset, so naturally ruby is a lisp
11:29:27 <glguy> I rarely use if then else outside of do-notation
11:29:27 <sandal> A lot of us pre-rails rubyists are a little sad to see the signal dropping in our community
11:29:42 <pierre1> hello. How can i convert utf8 string to haskell string?
11:29:56 <syntaxfree> a Haskell string is just a list of chars.
11:29:56 <sorear> find a copy of UTF8.lhs
11:30:01 <syntaxfree> Use a list of the appropriate type.
11:30:04 <sorear> darcs has one
11:30:10 <glguy> Char is the appropriate type
11:30:17 <sorear> it *should* be in a library, but it isn't
11:30:40 <sandal> And it seems like this community still can freely and happily chat about esoteric language features :)
11:30:46 <sorear> muahahaha
11:31:18 <sorear> at that's *without* Oleg discovering IRC :)
11:31:18 <syntaxfree> no, really. these people's heads would immediately explode and their legs would spontaneously combust the moment they found out about comonads.
11:31:32 <sandal> Just pray no one writes LambdaRails.
11:31:48 <sandal> :)
11:31:52 <pierre1> sorear: thanks
11:31:54 <sorear> "Avoid success at all costs" --SPJ (?)
11:32:05 <syntaxfree> I pray that sigfpe remains reasonably obscure, lest we see a string of tragic inexplicable deaths in technological areas.
11:32:13 <pierre1> ?where darcs
11:32:14 <PaulAJ> > chr 65535
11:32:14 <lambdabot> http://darcs.net/
11:32:15 <lambdabot>  '\65535'
11:32:15 <syntaxfree> It'd be a true programmer genocide.
11:32:29 <sandal> I'm actually doing a talk in a couple months about community driven Ruby projects
11:32:30 <PaulAJ> How many bits does Char hold?
11:32:34 <sorear> 21
11:32:41 <sandal> and how to promote high signal in your community
11:32:49 <sandal> because it's becoming increasingly challenging
11:32:54 <sorear> of course it takes 32 to store
11:32:57 <PaulAJ> Does it map to Unicode or something?  Where can I read about Haskell and I18N?
11:33:19 <sorear> PaulAJ: worse. ISO 10646-1, which iirc is a superset of unicode.
11:33:20 <syntaxfree> can Haskell *ever* become "popular"?
11:33:39 <syntaxfree> Not popular as in widely used in deep industry projects, but widely talked about, if not widely used, like Ruby?
11:33:41 <sorear> > fromEnum (maxBound :: Char) -- PaulAJ, this is for you
11:33:42 <lambdabot>  1114111
11:33:52 <glguy> > chr (2^20)
11:33:53 <lambdabot>  '\1048576'
11:33:55 <sandal> syntaxfree: sure, all it takes is a high level framework
11:34:01 <sandal> syntaxfree: and clever marketing
11:34:05 <sorear> > char (2^21)
11:34:05 <lambdabot>   Not in scope: `char'
11:34:08 <sorear> > chr (2^21)
11:34:09 <lambdabot>  Exception: Prelude.chr: bad argument
11:34:11 <glguy> > logBase 2  1114111
11:34:12 <lambdabot>  20.087461546321563
11:34:15 <PaulAJ> Ahh, thanks.  I'm definitely going to have to read up on this.
11:34:21 <sandal> most Ruby/Rails hyper enthusiasts don't even know what Ruby is
11:34:31 <glguy> sandal: what is ruby?
11:34:36 <syntaxfree> it's not a matter of marketing. it's a matter of people grokking Truth and Beauty or not.
11:34:37 <sandal> They just hear it'll make there programmers 8000 times more productive
11:34:55 <sandal> syntaxfree: Well, you mean, good popularity
11:34:56 <pierre1> hmm, it seems utf8.lhs in darcs can convert unicode [Word8] to String... And i need to convert utf8 String to haskell String
11:35:11 <sorear> it's a crystalline form of aluminum(III) oxide doped with chromium(III) ions that absorb green and blue light
11:35:12 <PaulAJ> http://weblog.raganwald.com/2007/01/what-ive-learned-from-sales-part-i.html
11:35:12 <sandal> I don't think Ruby has reached large scale good popularity, because I think it's hard to do
11:35:14 <lambdabot> http://tinyurl.com/tqjgq
11:35:24 <sorear> pierre1: there's no such thing as a utf8 String
11:35:34 <PaulAJ> Is good advice on selling new (paradigm / language / lifecycle) into most programming shops.
11:35:36 <sandal> most folks don't care about truth and beauty.  Only hackers, artists, and philosophers do :)
11:35:38 <musasabi> Getting the high level web framework done is quite hard, or rather there is no clear picture what it should look like. Being adaptable but yet simple can be suprisingly complex with Haskell in that context.
11:35:59 <pierre1> sorear: but it seems that i get one with Network.CGI
11:36:04 <sorear> pierre1: if you got it from standard IO, then map fromEnum might work at String -> [Word8]
11:36:08 <sandal> Doesn't need to be a high level web framework
11:36:16 <sandal> in fact, it'd just put you next to Django and Rails
11:36:19 <sorear> pierre1: if you got it from standard IO, then map (fromIntegral . fromEnum) might work at String -> [Word8]
11:36:30 <PaulAJ> Don't sell vitamins, sell Aspirin.
11:36:32 <syntaxfree> musasabi: well, isn't the Rails approach just a lot of automatic code generation?
11:36:35 <sandal> but break out in another direction that encourages people to use the language at a superficial level
11:36:37 <sorear> @ty map (fromIntegral . fromEnum) :: String -> [Word8]
11:36:39 <lambdabot> String -> [Word8] :: String -> [Word8]
11:36:43 <sandal> then it's problematic
11:36:49 <sorear> @ty ((map (fromIntegral . fromEnum)) :: String -> [Word8])
11:36:50 <lambdabot> String -> [Word8]
11:36:53 <PaulAJ> If people don't have a headache, you can't sell them stuff to make them better.
11:36:55 <sandal> syntaxfree: metaprogramming is not code generation, really.
11:36:58 <pierre1> sorear: thanks, i'll try this
11:37:04 <sandal> but rails does a hell of a lot of both
11:37:14 <syntaxfree> sure, doing a high-level web framework in a "proper", type-safe way, with a great type model, all the right abstractions, etc. etc. is hard.
11:37:20 <PaulAJ> If you can show that your magic bullet will cure their headache then they will grab it.
11:37:25 <musasabi> syntaxfree: generating code is easy. getting people to understand Template Haskell that does black magick to generate code is harder.
11:37:27 <syntaxfree> TH makes it trivial to do a lot of code generation, though.
11:37:42 <syntaxfree> isn't it just a matter of handling the ASTs?
11:37:51 <PaulAJ> For which reason I suspect TH.  But we had that conversation yesterday.
11:37:53 <sandal> It's frustrating, Rails is great for it's Niche.
11:38:03 <sandal> but it's not a magic bullet by any means
11:38:21 <syntaxfree> Haskell is the Only Magic Bullet and Philip Wadler its Only Prophet.
11:38:23 <sandal> and it's frustrating that many folks assume to be any good, ruby libraries need to play with rails
11:38:28 <ralf`> How can I find out the search path for import?  I tried running ghc --make with -v.
11:38:32 * syntaxfree kneels in the direction of Glasgow and prays.
11:38:34 * ralf` is reading the ghc user's guide. 
11:38:36 <PaulAJ> While I have high hopes for HAppS, I think the web framework niche is a bit overpopulated.  We need to look for somthing esle.
11:38:37 <glguy> @hoogle Base
11:38:38 <lambdabot> Test.HUnit.Base :: module
11:38:38 <lambdabot> Text.Html.base :: String -> HtmlAttr
11:38:38 <lambdabot> Text.Html.basefont :: Html
11:38:44 <glguy> @hoogle+
11:38:44 <lambdabot> Numeric.showIntAtBase :: Integral a => a -> (Int -> Char) -> a -> ShowS
11:38:44 <lambdabot> Prelude.logBase :: Floating a => a -> a -> a
11:38:44 <lambdabot> Text.Html.codebase :: String -> HtmlAttr
11:38:49 <musasabi> syntaxfree: yes, but the code ends up complex because the combinators are quite low level.
11:39:13 <sorear> musasabi: then write better ones!
11:39:22 <sandal> PaulAJ: I don't think you need a killer app
11:39:30 <syntaxfree> I think the web framework problem isn't well understood, "mathematically".
11:39:39 <sorear> composability++
11:39:45 <sandal> though i'll be honest, I write absolutely no rails, and I make almost all my money from Ruby
11:39:49 <SamB> well, that is because the problem is not mathematical
11:39:49 <augustss> syntaxfree: there are no prophets left in glasgow to pray to
11:40:04 <sandal> but the only reason clients accept it is because Rails brought it into the 'acceptable business' fold
11:40:07 <PaulAJ> Cue joke about lack of 3 wise men and a virgin.
11:40:07 <sandal> for contracting
11:40:17 <syntaxfree> I make all my money teaching econometrics to snotty kids who think they're cool because they work in a stock broking company.
11:40:28 <sandal> But y'know, it's a tradeoff I'm not sure I'd make willingly
11:40:35 <musasabi> sorear: if there was unlimited time...
11:40:36 <syntaxfree> augustss: hmm. where is Wadler?
11:40:42 <PaulAJ> sandal: interesting point.  How do we make Haskell the same?
11:40:57 <pejo> syntaxfree, Edinburgh.
11:40:57 <augustss> syntaxfree: Phil is in Edinburgh now
11:41:07 <sandal> PaulAJ: you don't want to, if you care about your community! :)
11:41:08 <syntaxfree> PaulAJ: we get CEOs to understand a lot of abstract algebra first.
11:41:14 <syntaxfree> Then we gently introduce them to category theory.
11:41:21 <augustss> syntaxfree: but he was on the US east coast for quite a while after leaving glasgow
11:41:28 * mgsloan goes off to invent server calculus
11:41:33 <SamB> sandal: it won't be a problem if we indoctrinate everyone *first*
11:41:38 <syntaxfree> I still call humorously The Man From Glasgow.
11:41:50 <sandal> SamB: world domination eh?
11:42:01 <PaulAJ> mgsloan: its already called Pi calculus.  But I don't think the people who invented XML-RPC can spell Pi.
11:42:12 <augustss> Simon PJ was at Glasgow.  John Hughes was at Glasgow.
11:42:15 <syntaxfree> The Man from Glasgow is Wadler.
11:42:21 <augustss> John Launchbury was at Glasgow.
11:42:28 <SamB> PaulAJ: thats okay, I don't think I like those people anyway
11:42:30 <syntaxfree> Wise Men From Glasgow are FP theoreticians in general.
11:42:31 <sorear> Don't worry.  once I take over the world, my eugenics program will provide lots of people ready for Haskell.
11:42:43 <syntaxfree> augustss: of course. Peter also sent his disciples round the world.
11:42:56 <augustss> lol
11:42:59 <syntaxfree> (Peter as in St. Peter)
11:43:01 <mgsloan> hehe, yeah, that's the concurrent stuff.  Now we just need one mixing the reality of the application and the actual mathematical embodiment of a site :P
11:43:02 <sandal> idk, like I said, it's just really tough to insulate the 'core community' from the effects
11:43:17 <sandal> it's like, you don't want to shun success, especially when it gives you such benefits
11:43:27 <syntaxfree> sandal: the core community is insulated by academic credentials.
11:43:34 <sandal> but you don't want the proliferation of unskilled and crappy code and examples
11:43:40 <sandal> to devalue your comunity
11:43:43 <sandal> haha syntaxfree
11:43:55 <sandal> Sorry, that's not practical
11:44:01 <syntaxfree> no, really. it seems the average haskell n00b is halfway through his post-doctoral dissertation.
11:44:19 <sandal> Yes, but that only works when the community is as tight as it is
11:44:34 <sandal> This is what happens.. people who don't really know what they're doing write books
11:44:35 <PaulAJ> I think the world may pick up Erlang before it picks up Haskell.
11:44:45 <sandal> and people who *really* don't know what they're doing read those books
11:44:53 <sandal> and they think those folks are experts
11:44:55 <PaulAJ> On Reddit the two most common "Now I'm going to learn..." languages are Erlang and Haskell.
11:44:59 <sorear> O
11:45:01 <sandal> and this way, the core gets left behind
11:45:06 <sandal> :-/
11:45:25 <syntaxfree> PaulAJ: I've seen people who haven't programmed since the 80s talk about learning Haskell.
11:45:30 <sorear> I'm not sure where that O came from, keyboard glitch most llikely...
11:45:43 <syntaxfree> People whose last stint was writing statistical analysis code in Fortran.
11:45:44 <SamB> well, what we need to ensure is that the mathematical way of thinking becomes inseperable from the successful application of Haskell in the minds of bussinessmen
11:45:45 <sandal> Every language starts off small, esoteric, and special
11:45:50 <glguy> foldl ((. digitToInt) . (+) . (2 *)) 0 "100001111111111111111"
11:45:53 <mgsloan> PaulAJ: Worse things could happen :) Erlang seems nice because you can run it like a simulated world in your head
11:45:54 <glguy> > foldl ((. digitToInt) . (+) . (2 *)) 0 "100001111111111111111"
11:45:55 <lambdabot>  1114111
11:45:59 <SamB> in particular, the *thinking*
11:46:01 <PaulAJ> Agreed.
11:46:11 <sandal> SamB: that's why I'm learning Haskell
11:46:11 <syntaxfree> sandal: Haskell is deeply grounded in mathematics. That's what makes it different.
11:46:20 <sandal> to strengthen those ideals
11:46:26 <mgsloan> actually, seems like a good overview model for an OS (which erlang is, iirc)
11:46:29 <sandal> But hell, that's like saying LISP is esoteric
11:46:31 <sandal> LOGO is lisp
11:46:40 <SamB> LOGO is watered down
11:46:47 <sandal> Yeah
11:46:48 <mgsloan> internally functional externally objectional might just be ideal :P
11:46:50 <PaulAJ> In business "theory" is generally a dirty word.
11:46:51 <sandal> Exactly
11:46:54 <syntaxfree> I mean, seriously.
11:47:05 <PaulAJ> Bye.
11:47:06 <sandal> Rails is watered down ruby, for the most part
11:47:21 <syntaxfree> The day programmers at large find about map fusion, map fusion only, THOUSANDS of programmers are gonna SPONTANEOUSLY COMBUST.
11:47:25 <sandal> It's something that makes life easier, a lot easier
11:47:32 <sandal> for the problems it solves
11:47:42 <sandal> but abstraction is infinite
11:47:47 <syntaxfree> *Shoes* are gonna rain in the Silicon Valley from all the EXPLODING PROGRAMMERS.
11:47:54 <sandal> you can hide all of the things that make haskell what it is
11:47:57 <mgsloan> syntaxfree - nah, put into terms of foreach, map fusion is nothing
11:47:59 <SamB> syntaxfree: it will be worse if they find out about the stuff in Data.ByteString
11:48:02 <sandal> but people don't need to know that
11:48:16 <SamB> we don't *want* to hide those things
11:48:22 <syntaxfree> I'm picking a trivial example.
11:48:22 <sorear> syntaxfree: unfortunately you've passed the 512 char remember limit :(
11:48:33 <syntaxfree> haha. Can't you delete some of my bad quotes?
11:48:45 <syntaxfree> sorear: just quote me as syntaxfree2.
11:48:46 <sandal> Anyway, I'm just saying, it's good that this community is what it is.
11:48:53 <sorear> The IRC-server-enforced limit.
11:49:04 <sandal> But metaprogramming and the dynamicity of ruby, we would've thought that was a decent barrier to entry
11:49:07 <sandal> we were wrong :)
11:49:20 <syntaxfree> sorear: oh, I thought you meant the quote database. What do you mean?
11:49:35 <sandal> I guess there is that balance of not making it hard for people to learn things, but making it hard for people to run off and exploit their limited knowledge of a system
11:49:37 <newsham> i thikn he wants to put your quotes onto a single line for remember
11:49:41 <mgsloan> yeah, we've got the monad and syntax barriers
11:49:52 <sandal> now, if all it did was advance the individual's status, no problem
11:49:58 <bos_> the syntax barrier is trivially overcome.
11:50:02 <sandal> but at some point, it spills over
11:50:03 <sorear> if I send a :!sorear PRIVMSG lambdabot :@remember longer than 512 chars, rfc2813 says the server will truncate it
11:50:07 <SamB> sandal: we don't want to prevent people from exploiting limited knowledge, either!
11:50:13 <mgsloan> bos_ - true, but it weeds people out
11:50:15 <sandal> all of the barriers can be overcome, it's foolish to assume they can't
11:50:18 <sandal> (or won't)
11:50:25 <SamB> barriers?
11:50:26 <sandal> SamB: :)
11:50:31 <syntaxfree> maybe @remember should automaticall post to bash.org, qdb.us, or something like that.
11:50:43 <syntaxfree> we don't want to erect barriers.
11:50:48 <syntaxfree> We want to teach the world to sing!
11:50:53 <sandal> no.. I mean, existing barriers
11:51:02 <syntaxfree> La, la, la, lalala! La, la, la, lalala!
11:51:03 <SamB> silly
11:51:04 <sandal> if mathematical knowledge is a precursor, people can gloss over that
11:51:15 <SamB> @quote syntaxfree La, la, la, lalala! La, la, la, lalala!
11:51:16 <lambdabot> No quotes match. The more you drive -- the dumber you get.
11:51:21 <SamB> @remember syntaxfree La, la, la, lalala! La, la, la, lalala!
11:51:21 <lambdabot> Done memoising quote for `syntaxfree', if that is their real name...
11:51:22 <sandal> you don't need to know calculus to do basic physics, you just need algebra
11:51:25 <mgsloan> understanding of algebra is mostly what's needed
11:51:27 <syntaxfree> hahahaha.
11:51:40 <syntaxfree> mgsloan: most people don't understand algebra.
11:51:48 <sandal> hehe.  Sad but true
11:51:49 <mgsloan> yep
11:51:52 <SamB> sandal: ... I don't?
11:51:52 <syntaxfree> @quote SamB
11:51:53 <lambdabot> SamB says: I was just saying that encasing poeple in concrete is not the best solution to that problem
11:52:12 <syntaxfree> godamn, that's a good quote database :)
11:52:21 <newsham> you dont need to understand algebra to throw a ball, you just need an intuition of parabolic motion
11:52:24 <SamB> @quote
11:52:24 <lambdabot> earthy says: the haskell standard prelude is ... a treasure trove. ;) but it does require breaking your mind and reassembling the pieces to unlock the trove
11:52:39 <sandal> there you have it newsham
11:52:47 <sandal> Now that's the nature of abstraction.
11:52:54 <SamB> that one is surprisingly appropriate
11:52:54 <mgsloan> Well, its very possible you could learn algebra through haskell
11:52:55 <sandal> The trouble is
11:53:04 <mgsloan> algebra mucks up concepts, the way its taught
11:53:13 <SamB> mgsloan: hmm?
11:53:13 <sandal> no one throws a ball and says "Holy Shit, I'm doing awesome physics"
11:53:25 <sandal> mgsloan: I agree 100%
11:53:37 <glguy> ?unpl liftM2 (.) (.) . (.)
11:53:37 <lambdabot> (\ q -> (\ i j k -> i (j k)) >>= \ b -> (\ m n -> q (m n)) >>= \ a -> return (\ h -> b (a h)))
11:53:40 <sandal> But people do Rails and think it's Ruby
11:53:46 <sandal> the funny thing is, it *is* ruby
11:53:52 <glguy> normally, if you type:
11:53:54 <sandal> but that they're only living in the rails side of things
11:53:55 <newsham> ironically stephan hawkings knows physics better than almost everyone on the planet, but cannot throw a ball.
11:53:58 <sandal> so they miss out on a lot
11:54:04 <glguy> ?pl \f g x y -> g x `f` f y -- lambdabot does this:
11:54:04 <lambdabot> flip =<< ((flip . ((.) .)) .) . (.)
11:54:09 <syntaxfree> @quote
11:54:09 <lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
11:54:11 <sandal> the most excellent railsers I know are also very good rubyists
11:54:18 <glguy> which is ugly compared to the hand solved: liftM2 (.) (.) . (.)
11:54:18 <mgsloan> SamB - Well, math has been easy all my life, because I learned programming before
11:54:27 <glguy> ?type liftM2 (.) (.) . (.)
11:54:27 <SamB> mgsloan: hmm.
11:54:28 <syntaxfree> mgsloan: I used to think that.
11:54:28 <lambdabot> forall a c a1. (c -> a1 -> a) -> (a -> c) -> a -> a1 -> c
11:54:30 <sandal> but the community is beginning to not care if you understand the depths as long as it's got AJAX all over the place
11:54:33 <syntaxfree> At least in high school.
11:54:34 <glguy> ?djinn (c -> a1 -> a) -> (a -> c) -> a -> a1 -> c
11:54:35 <lambdabot> f _ a b _ = a b
11:54:40 <monochrom> No one knows what themselves are doing.
11:54:44 <mgsloan> yeah, i'm still in highschool :P
11:54:45 <SamB> sandal: eeek...
11:54:57 <glguy> ACK
11:55:02 <glguy> I missed a step
11:55:07 <SamB> syntaxfree: but Haskell actually *does* help with math
11:55:11 <syntaxfree> mgsloan: well, it prevented me to learning a lot of things properly because I kept thinking "this is easy, I know this from BASIC"
11:55:14 <sandal> So, i'm saying, be aware that technology, where status involves money and recognition
11:55:19 <mgsloan> only hard part of math was arithmetic...
11:55:26 <sandal> if people can throw a ball and say it's physics
11:55:28 <syntaxfree> of course, Haskell being basically executable mathematics..
11:55:32 <sandal> and think someone will believe them, they will
11:55:41 <SamB> mgsloan: mathematicians aren't very good at arithmatic either ;-)
11:55:43 <mgsloan> syntaxfree: true... I guess I grasped the concepts more fully than that though
11:55:45 <sandal> syntaxfree: as a math major, I've been totally thrilled about that aspect
11:56:02 <sandal> mgsloan: who needs arithmetic! ;)
11:56:06 <syntaxfree> @quote
11:56:06 <lambdabot> orbitz says: i don't know what the problem is, i'm typing fine, all you crazies are hiting the wron gbuttons everywhere
11:56:13 <newsham> > 1 + 1
11:56:14 <lambdabot>  2
11:56:23 <newsham> methinks haskell is a calculator
11:56:30 <syntaxfree> > foldl (+) [1,1]
11:56:30 <lambdabot>   add an instance declaration for (Num [a])
11:56:35 <mgsloan> heh, yeah, exactly.  I still don't actually fully know my arithmetic tables - do funny shortcuts and such
11:56:38 <syntaxfree> > foldl (+) 0 [1,1]
11:56:39 <lambdabot>  2
11:56:45 <sandal> any programming language can make a fine calculator :)
11:56:53 <SamB> mgsloan: why would you know the whole tables?
11:56:58 <syntaxfree> > take 2 $ scanl (+) 0 [1,1,...]
11:56:58 <lambdabot>  Parse error
11:57:00 <monochrom> It is ok to do something you don't know deeply; sometimes it's necessary too.  You don't know what you're eating, but you still have to eat.  However, it is also important to be modest about not knowing.
11:57:02 <SamB> I know how to fill them in, why would I memorize them?
11:57:02 <syntaxfree> > [1,1,..]
11:57:03 <lambdabot>  Parse error
11:57:10 <sandal> anyway, i'm off for a bit.  I meant the things I said as a compliment, and also something to think about
11:57:13 <mgsloan> I dunno.  That's why i don't
11:57:22 <sandal> never underestimate the power of idiocy en masse :)
11:57:33 <newsham> sandal: some get bogged down before they get to sum = foldl1 (+)
11:57:42 <SamB> sandal: it will have the typesystem to contend with, here!
11:57:46 <syntaxfree> seriously. a HARD RAIN of SHOES is gonna FALL the day the world "gets"  Haskell.
11:57:52 <mgsloan> sandal - yep, the community is good.  Hopefully an intransigent trait
11:57:57 <monochrom> The one thing that bugs me is some idiots say "I don't know and I'm proud of it!"
11:58:03 <SamB> the typesystem represents a significant barrier to idiots
11:58:09 <sandal> And i'm really agnostic, i think it's killer that a ton of web developers can do like, nice websites with some dynamic content easily with Rails
11:58:12 <mgsloan> oh yeah, i forgot that barrier
11:58:25 <syntaxfree> @quote
11:58:26 <lambdabot> astrolabe says: I guess missile launching would have to be in IO
11:58:29 <sandal> I just get annoyed when they complain that 3.days.from.now doesn't work when they use my reporting framework
11:58:30 <SamB> monochrom: I might say "I don't know, but I would really rather learn about X"
11:58:47 <sandal> so the spillover is what to be weary of.
11:58:57 <glguy> :t liftM2 (.) (flip (.)) . (.)
11:58:58 <lambdabot> forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c
11:59:03 <mgsloan> I had haskell doing tetration yesterday using only iterate and succ :P
11:59:05 <glguy> ?. djinn type liftM2 (.) (flip (.)) . (.)
11:59:06 <lambdabot> f a b c _ = a (b c) (b c)
11:59:13 <mgsloan> and !!
11:59:20 <SamB> mgsloan: not .?
11:59:20 <sorear> syntaxfree: why would the shoes go *up*?  wouldn't it be a rain of displaced concrete?
11:59:21 <glguy> ugh
11:59:22 <Hunter_wow> >:i isEven
11:59:27 <glguy> oh
11:59:36 <syntaxfree> sorear: because programmers are gonna explode all over.
11:59:54 <glguy> > liftM2 (.) (flip (.)) . (.) compare snd (undefined, 5) (undefined , 7)
11:59:54 <lambdabot>  Couldn't match `a2 -> (a1 -> b) -> a -> b -> c' against `Ordering'
11:59:57 <glguy> hm
11:59:59 * sorear doesn't know many programmers who stand on their heads
12:00:16 <syntaxfree> sorear: that's what the world has been doing all along with dysfunctional programming, though.
12:00:18 <SamB> wouldn't the shoes be overwhelmed by the concrete walls?
12:00:29 <glguy> > (liftM2 (.) (flip (.)) . (.)) compare snd (undefined, 5) (undefined , 7)
12:00:30 <lambdabot>  LT
12:00:34 <glguy> huzzah
12:00:40 <syntaxfree> concocting large systems with assorted pieces of wire and bubble gum instead of mathematically constructing them.
12:01:04 <syntaxfree> Hunter_wow: here, you want @info
12:01:05 <Nanar> hi
12:01:07 <syntaxfree> @info isEven
12:01:07 <lambdabot> isEven
12:01:13 <glguy> ?unpl (liftM2 (.) (flip (.)) . (.))
12:01:13 <lambdabot> (\ t -> (\ j k n -> k (j n)) >>= \ b -> (\ p q -> t (p q)) >>= \ a -> return (\ h -> b (a h)))
12:01:14 <syntaxfree> @thanks
12:01:14 <lambdabot> Unknown command, try @list
12:01:19 <glguy> ?. pl unpl (liftM2 (.) (flip (.)) . (.))
12:01:19 <lambdabot> (flip (.) >>=) . (. ((return .) . (.))) . (>>=) . (.)
12:01:21 <sorear> @info hellp
12:01:22 <lambdabot> hellp
12:01:24 <sorear> @info___
12:01:24 <lambdabot> Unknown command, try @list
12:01:25 <sorear> @info__
12:01:25 <lambdabot> Unknown command, try @list
12:01:26 <sorear> @info_
12:01:26 <lambdabot> Unknown command, try @list
12:01:27 <sorear> @info
12:01:28 <monochrom> I use barbed wires and banana-flavoured bubble gum. :)
12:01:28 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
12:01:32 <sorear> @_info
12:01:32 <lambdabot> Unknown command, try @list
12:01:38 <monochrom> Please don't spam.
12:01:42 <sorear> @infx
12:01:42 <lambdabot> bzzt
12:01:48 <glguy> ?losers
12:01:49 <lambdabot> Maximum users seen in #haskell: 307, currently: 304 (99.0%), active: 49 (16.1%)
12:01:50 <syntaxfree> ? redo . unpl f = (liftM2 (.) (flip (.)) . (.))
12:01:52 <Nanar> I did install HTTP module but when I try to use it I get: "Could not find module `Network.HTTP': it is a member of package HTTP-2006.7.7, which is hidden"
12:01:54 <monochrom> Please use /msg lambdabot to explore
12:01:55 <Nanar> any idea ?
12:01:56 <syntaxfree> er,
12:01:56 <sorear> @_nfo
12:01:57 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
12:01:58 <glguy> ?teens
12:01:59 <lambdabot> Lately, I have seen bos_, elpolilla, erg0t, fglock, glguy, hunter_wow, ingy, jgrimes, lleberg, mgsloan, monochrom, nanar, newsham, paolino, paulaj, pkhuong, putter, samb, sandal, sebazzz, sorear,
12:01:59 <lambdabot> stevan, syntaxfree and xdie.
12:02:00 <syntaxfree> ?. redo unpl f = (liftM2 (.) (flip (.)) . (.))
12:02:00 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}) "Parse error"
12:02:10 <mgsloan> hah
12:02:21 <glguy> liftM2 (.) (flip (.)) . (.) -- my hand unrolled: \f g x y -> g x `f` g y
12:02:23 <syntaxfree> OH NO. they KILLED lambdabot!
12:02:38 <syntaxfree> YOU KILLED LAMBDABOT. Mr. Lambdabot, talk to me, Howard!
12:02:51 <SamB> @bot
12:02:51 <lambdabot> :)
12:03:30 <lambdabot> Rumors of my demise have been greatly exaggerated.
12:03:32 <newsham> ?elite I'm alive!
12:03:33 <lambdabot> i'/\/\ alIV3!
12:03:38 <glguy> :t (.) (liftM2 (.) (flip (.))) (.)
12:03:39 <lambdabot> forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c
12:04:15 <syntaxfree> :t works now?
12:04:17 <lambdabot> parse error (possibly incorrect indentation)
12:04:22 <syntaxfree> cool.
12:04:25 <syntaxfree> :r
12:04:33 <glguy> :k Maybe
12:04:34 <lambdabot> * -> *
12:04:45 <mgsloan> ?. elite type (.) (liftM2 (.) (flip (.))) (.)
12:04:45 <syntaxfree> :k ofBlue
12:04:47 <lambdabot> forAL| 4 b c. (b -> 8 -> c) -> (4 -> B) -> 4 -> A -> C
12:04:47 <lambdabot> Not in scope: type variable `ofBlue'
12:05:12 <newsham> :module +System.Posix.Process
12:05:27 <syntaxfree> @quote
12:05:27 <lambdabot> BjarneStroustrup says: any verbose and tedious solution is error-prone because programmers get bored. [S 9.4 of C++, 2nd edition]
12:05:48 <sorear> @quote
12:05:48 <lambdabot> thetallguy says: Using and advocating Haskell is like being Calvin (and Hobbes). To you, it's alive, real, a true delight. To those who know better, it's a stuffed tiger.
12:05:59 <syntaxfree> hehehe.
12:06:18 <newsham> i was watching a video of someone using a symbolics lisp machine yesterday and they were showing how you just pint and click to retype an identifier
12:06:28 <newsham> and I was thinking "so thats why lisp programmers put up with such long names"
12:07:08 <syntaxfree> gah, only now I parsed The Tall Guy./
12:07:10 * mgsloan wonders why MIT courseware uses RM....
12:07:12 <newsham> some nifty features.. someone needs to make HaskellMachine dev environment
12:07:18 <syntaxfree> I kept trying to reads Theta All Guy
12:07:25 <mgsloan> LOL
12:07:30 <syntaxfree> and looking for the missing A.
12:07:51 <mgsloan> and here I've been reading yours Sin Tax Free
12:08:07 <newsham> must be nevada
12:08:25 * monochrom thetas all guys
12:08:31 <syntaxfree> I misread yours as "msgloan"  all the time.
12:08:45 * monochrom s all guys
12:08:47 <syntaxfree> it's really annoying, tab completion-wise.
12:08:50 <mgsloan> hah
12:08:54 <Hunter_wow> how do I div a list(xs/2) without getting "Error: Instance of Fractional Int required for definition of msort"
12:09:11 <syntaxfree> "MSG Loan" , see?
12:09:11 * glguy usually sees "m slogan"
12:09:15 <newsham> > 5 `div` 2
12:09:17 <lambdabot>  2
12:09:21 <Excedrin_> how does lambdabot's remember work?
12:09:33 <syntaxfree> > map (flip div 2) [1..15]
12:09:34 <lambdabot>  [0,1,1,2,2,3,3,4,4,5,5,6,6,7,7]
12:09:34 <glguy> well
12:09:49 <newsham> > let xs = "testing" in take (length xs `div` 2) xs
12:09:50 <lambdabot>  "tes"
12:10:00 <theorems_for_syn> bah.
12:10:02 <Excedrin_> @remember BjarneStroustrup Within C++, there is a much smaller and cleaner language struggling to get out.
12:10:02 <lambdabot> Done memoising quote for `BjarneStroustrup', if that is their real name...
12:10:13 <theorems_for_syn> "Theorems for Syntaxfree!"  was a good war cry.
12:10:19 <monochromorphixm> Interesting, apparently monochromorphism is exactly the length limit!
12:10:28 <theorems_for_syn> @quote
12:10:28 <lambdabot> madpickle says: Stuff costs more than it used to.
12:10:37 <glguy> I liked the nick: ninechars
12:10:45 <monochromorphism> haha
12:10:56 <theorems_for_syn> @quote monochrom
12:10:57 <lambdabot> monochrom says: Dilbert's substitutability principle.  A subclass's programmer should work as a drop-in replacement of his/her predecessor.
12:12:04 <augustss> @quote
12:12:05 <lambdabot> Miod says: [On the vax] How many processors come with a built-in instruction which computes polynomials of degrees up to 31?
12:12:14 * glguy goes searching for more functions to manually ?pl
12:12:15 <mgsloan> I've always thought of excedrin as a drug
12:12:18 <theorems_for_syn> @quote augustss
12:12:19 <lambdabot> augustss says: <wy> augustss: Wow. You win the IOCCC three times! <augustss> wy: i'm bad at C programming ;)
12:12:26 <monochromorphism> hahahaha that is a good VAX joke
12:12:30 <sorear> @quote quazimodo
12:12:30 <lambdabot> No quotes match. My pet ferret can type better than you!
12:12:33 <Hunter_wow> newsham cant see why yours are working and not mine
12:12:34 <mgsloan> augustss is a ship
12:12:37 <Excedrin> mgsloan: that's correct
12:12:48 <Hunter_wow> newsham paste code soon =)
12:12:49 <theorems_for_syn> @quote Ex cedrin
12:12:50 <lambdabot> No quotes for this person. Where did you learn to type?
12:12:51 <nickm283> hi everyone. what does tri0 mean
12:12:56 <theorems_for_syn> @quote Excedrin
12:12:56 <lambdabot> Excedrin says: 66016 lines of C is only 2200 lines of Haskell, just rewrite it
12:13:06 * augustss doesn't understand the VAX joke.
12:13:11 <sorear> nickm283: nothing?
12:13:13 <theorems_for_syn> that's not a good quote :(
12:13:35 <theorems_for_syn> nickm283 it's elite-speak for "trio" .
12:13:35 <monochromorphism> VAX was a CISC, the archetypical CISC.
12:13:41 <theorems_for_syn> A common formation is Jazz groups.
12:13:47 <theorems_for_syn> generally drums, bass and piano.
12:13:50 <nickm283> ah rite. i have a peice of code with 'mkTriMapS s = freqMap . concatMap tri0 where'
12:13:52 <Excedrin> mgsloan: I picked this nick based on an item lying on my desk at the time
12:14:09 <mgsloan> ah, huh. mine's based off my name
12:14:16 <mgsloan> I should get a better one but eh
12:14:17 <Excedrin> @quote BjarneStroustrup
12:14:17 <lambdabot> BjarneStroustrup says: Within C++, there is a much smaller and cleaner language struggling to get out.
12:14:19 <theorems_for_syn> mine comes from a Sonic Youth tune.
12:14:21 <glguy> nickm283: tri0 was defined by the person that wrote that function
12:14:26 <theorems_for_syn> @quote
12:14:26 <lambdabot> pesco says: "Scientists Reveal: Human Consciousness Stems From Two Files in Different Directories!"
12:14:27 <augustss> monochromorphism: I know.  I just don't get what the joke was.  The instruction are called POLYD and POLYF, btw.
12:14:28 <lisppaste2> Hunter_wow pasted "div table" at http://paste.lisp.org/display/35424
12:14:45 <glguy> ?quote nick
12:14:45 <lambdabot> erg0t says: lambdabot, tu nick seria el nombre ideal para un postre
12:14:55 <mgsloan> syntaxfree - ah, I figured it referred to lisp or something :P
12:15:05 <nickm283> cheers im useless
12:15:25 <theorems_for_syn> translating: lambdabot, your nick would be the ideal name for a dessert.
12:15:33 <theorems_for_syn> @spell dessert
12:15:34 <mgsloan> actually, i mostly figured it had something to do with context free parsers...
12:15:34 <lambdabot> dessert
12:15:52 <glguy> theorems_for_syn: questioning the spelling?
12:15:57 <theorems_for_syn> mgsloan: ah, yes. I picked it up while learning Scheme.
12:16:18 <syntaxfree> @quote nick
12:16:18 <lambdabot> xerox says: you know, befunge is probably the only language I've seen where you can run code pasted from IRC with the <nick> tags still in place ;-)
12:16:24 <monochromorphism> Perhaps if I built a processor that had an instruction COMPILE to compile C into machine code, you would get the joke.
12:17:04 <syntaxfree> @quote compile
12:17:05 <lambdabot> SyntaxNinja says: I think that the compiler authors will fly here from England just to kill me if I did that
12:17:13 <TomMD> @users
12:17:13 <lambdabot> Maximum users seen in #haskell: 310, currently: 310 (100.0%), active: 49 (15.8%)
12:17:20 <sorear> monochromorphism: wouldn't it be easier to build a processor with C as its machin language
12:17:23 <syntaxfree> YAY!
12:17:26 <TomMD> yep
12:17:31 <syntaxfree> we are the champions, my friends... na, na ...
12:17:46 <humasect> i have unicode working with GHC 6.6 great except japanese in identifiers and the Lambda unicode char () gives parse errors
12:18:10 <glguy> GHC thinks that lambda is \ ?
12:18:15 <humasect> yes
12:18:23 <humasect> why is this?
12:18:33 <glguy> because that's what \ is supposed to represent
12:18:33 <monochromorphism> It doesn't recognize unicode identifiers yet.
12:18:43 <syntaxfree> humasect: For Great Justice.
12:18:53 <humasect> mono: it works with symbols (mathematical) but not japanese normal characters
12:18:56 <glguy> move all zig!
12:19:08 <monochromorphism> Interesting.
12:19:08 <mgsloan> could have a preprocessor deal with unicode symbols
12:19:19 <humasect> hmm. =) so lambda is supported but treated as \? .. ?
12:19:25 * syntaxfree waits for someone else to come um with a <word> that mskes " All your <word> are belong to us"   funny in this context.
12:19:40 <humasect> mgsloan, hm yes. until compiler messages
12:20:20 <monochromorphism> All your s are belong to us?
12:20:25 <mgsloan> would probably be pretty difficult for other people to call functions which are named with japanese characters...
12:20:28 <syntaxfree> not funny, sorry.
12:20:37 <newsham> all your HSbase are belong to us
12:20:37 <humasect> japanese does have seperate char sets for "lower case" and "upper case" - so haskell98 should be no problem
12:20:48 <emk> DarwinPorts question: Is there any way to get GHC to use a -framework vecLib option?
12:21:01 <sorear> emk: -optL ?
12:21:03 <sorear> emk: -optl ?
12:21:10 <syntaxfree> " forall a : All your a are belong to us"  is overused enough that it may never be funny again.
12:21:18 <emk> sorear: Thanks!
12:21:18 <syntaxfree> We're left with the secondary quips.
12:21:25 <sorear> exist a . All your a are belong to us ?
12:21:33 <humasect> mgsloan: yup, exports would be regular ascii
12:21:43 <syntaxfree> gah, don't remind me. I don't understand existential types yet.
12:21:46 <mgsloan> oh, alright then :)
12:21:46 <humasect> 
12:22:00 <syntaxfree> anyway, explain existential types instead, then?
12:22:58 * mgsloan 's understanding of existential types is that they basically make what was before assumed explicit or slightly modified in meaning
12:22:58 <augustss> syntaxfree: existential types is a way of encapsulating exactly which type something is and forgetting about it
12:23:13 <glguy> (\(f :: forall a . a -> a) -> (f 'a', f 1)) id
12:23:16 <syntaxfree> ?
12:23:32 <monochromorphism> related to second-rank polymorphism
12:23:44 <syntaxfree> ?^2
12:23:45 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
12:23:46 <augustss> glguy: that's a universally quantified type
12:24:01 <mattam> they permit absrtaction of datatypes more pratically
12:24:03 <sorear> exactly dual to forall, and isomorphic to higher rank
12:24:06 <syntaxfree> of course I get universally quantified types.
12:24:14 <syntaxfree> :(
12:24:46 * monologue mode on
12:24:47 <augustss> sorear: existentially quantified types are just exactly dual of universal in a classical setting
12:24:54 * humasect tries upper case lambda
12:25:06 <DracoCepheus> hi there
12:25:09 <mattam> monoid = exists A, A * (A -> A -> A)
12:25:27 <syntaxfree> :(
12:25:45 <sorear> s/monoid/magma
12:25:55 <mattam> right
12:26:03 <monologue> Actually I think http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#existential-quantification is a good start
12:26:05 <augustss> syntaxfree: Have you tried making a data type with an "existentially" quantified type?
12:26:05 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
12:26:27 <glguy> data E = forall t . Show t => E t -- this?
12:26:37 <augustss> For example
12:26:39 <syntaxfree> monologue: I get nothing from that. Nothing.
12:26:45 <humasect> can i ask, should a lambda using the unichar be much different than eg.:  (x -> x ++ y) ?
12:26:46 <monologue> That's odd.
12:26:46 <DracoCepheus> why does this experssion fail?
12:26:47 <syntaxfree> I can parse none of it whatsoever.
12:26:48 <DracoCepheus> eval e = case e of {
12:26:49 <DracoCepheus>     Simple n -> n;
12:26:51 <DracoCepheus>     Mult x y -> eval(x) * eval(y) ;
12:26:53 <DracoCepheus>     Subtract x y -> eval(x) - eval(y);
12:26:53 <syntaxfree> It's like if I was reading it in russian.
12:26:54 <DracoCepheus>     Divide x y -> eval(x) div eval(y);
12:26:56 <DracoCepheus>     Term x -> eval (x);
12:26:57 <DracoCepheus>  }
12:26:59 <DracoCepheus> if a remove the Divide line it works
12:27:00 <DracoCepheus> Here are the definitions:
12:27:02 <DracoCepheus> data Expression
12:27:03 <DracoCepheus>     = Simple Integer
12:27:05 <DracoCepheus>     | Mult Expression Expression
12:27:05 <syntaxfree> I can make more sense of symplectic geometry than I can make sense of that.
12:27:06 <DracoCepheus>     | Divide Expression Expression
12:27:07 <augustss> DracoCepheus: STOP
12:27:08 <DracoCepheus>     | Add Expression Expression
12:27:09 <syntaxfree> I can make NO sense of it.,
12:27:09 <DracoCepheus>     | Subtract Expression Expression
12:27:11 <DracoCepheus>     | Term Expression
12:27:12 <DracoCepheus>     deriving (Eq,Show)
12:27:13 <mgsloan> monoid is basically just half a steroid
12:27:14 <DracoCepheus> type ExpType = Expression
12:27:14 <humasect> wai~
12:27:20 <syntaxfree> NO SENSE WHATSOEVER, NO SENSE NO SENSE NO SENSE!
12:27:26 <humasect> mgsloan: =D
12:27:29 <augustss> DracoCepheus: use @paste
12:27:35 * syntaxfree won against the flood.,
12:27:45 <sorear> @slap DracoCepheus
12:27:45 * lambdabot smacks DracoCepheus about with a large trout
12:27:46 <mattam> you want `div` instead of div
12:27:56 <monologue> DracoCepheus do you have a 16384x8192 screen of 42" ?
12:28:05 <syntaxfree> monologue: hahahahhaha
12:28:08 <humasect> =)
12:28:12 <monologue> If not then how do you think anyone can read your stuff?
12:28:15 <glguy> DracoCepheus's paste filled half my window
12:28:16 <DracoCepheus> ouch ...
12:28:23 <mgsloan> DracoCepheus: eval x `div` eval y, and don't paste big chunks into irc
12:28:26 <mgsloan> ?paste
12:28:26 <lambdabot> http://paste.lisp.org/new/haskell
12:28:28 <mattam> msgloan :)
12:28:35 <syntaxfree> what's the simplest fastest way of factoring megapixels into (3x, 4x) coordinates?
12:28:49 <DracoCepheus> sorry bout that
12:28:59 <glguy> (.) (liftM2 (.) (flip (.))) (.) div eval
12:28:59 <sorear> > sqrt ((4/3) * 1000000)
12:28:59 <DracoCepheus> using chatzilla
12:29:00 <lambdabot>  1154.7005383792514
12:29:03 <humasect> this _is_ correct, right?   (x  x ++ y)
12:29:08 <mattam> it filled all my small 14" screen :)
12:29:10 <syntaxfree> oh, x is supposed to be integer, of course.
12:29:16 <DracoCepheus> seemed so natural to paste ...
12:29:19 * syntaxfree has a 17"  flatscreen.
12:29:30 * humasect 13.3"
12:29:33 <mattam> your IRC client should have warned you
12:29:35 <sorear> > id &&& (*(3/4)) $ sqrt ((4/3) * 1000000)
12:29:36 <lambdabot>  (1154.7005383792514,866.0254037844386)
12:29:37 <mgsloan> DracoCepheus: no harm done, just unideal
12:29:48 <glguy> DracoCepheus: here you go: (.) (liftM2 (.) (flip (.))) (.) div eval x y
12:29:51 <sorear> > id &&& (*(3/4)) $ sqrt ((4/3) * 5000000) -- syntaxfree
12:29:52 <lambdabot>  (2581.988897471611,1936.4916731037083)
12:29:53 <humasect> > (x  x ++ y)
12:29:53 <lambdabot>  Illegal character ''\187''
12:30:03 <syntaxfree> I want exact.
12:30:06 <mgsloan> humasect: perhaps when you use the proper unicode it wants normal lambda syntax?
12:30:16 <mgsloan> > (x. x ++ y)
12:30:16 <lambdabot>  Illegal character ''\187''
12:30:18 <humasect> mgsloan: yes, i think this is my real question
12:30:28 <sorear> > id &&& (*(3/4)) $ sqrt ((4/3) * (1024*768))
12:30:29 <lambdabot>  (1024.0,768.0)
12:30:41 <Hunter_wow> any idea how I can define the unix function * in haskell (ie.  *.txt)
12:30:42 <sorear> that close enough to exact :)
12:30:54 <sorear> Text.Regex ?
12:30:54 <monologue> * is not a function.
12:30:58 <humasect> mgsloan: oh, now we get:         cannot mix `(.)' [infixr 9] and `(?)' [infixl 9] in the same infix expression
12:31:08 <glguy> > ap (,) (*(3/4)) $ sqrt ((4/3) * (1024*768)) -- ?
12:31:09 <lambdabot>  (1024.0,768.0)
12:31:19 <humasect> well it is the same parse message with any unichar in place of the lamb
12:31:20 <mgsloan> yeah, wouldn't expect it to actually work
12:31:27 <syntaxfree> parsec.
12:31:28 <humasect> =|
12:31:47 <syntaxfree> > star = do { x<-manychar; y<-" .txt" ; return (x++y) }
12:31:47 <lambdabot>  Parse error
12:31:51 <mgsloan> maybe request the feature?
12:31:58 <syntaxfree> bah, anyway, that in Parsec.
12:32:11 <syntaxfree> manychar is "many anyChar"
12:32:12 <humasect> http://hackage.haskell.org/trac/haskell-prime/wiki/UnicodeInHaskellSource  <-- claims support since 1 year ago
12:32:14 <lambdabot> Title: UnicodeInHaskellSource - Haskell Prime - Trac, http://tinyurl.com/yfvxzv
12:32:20 <DracoCepheus> `div` worked, thanks
12:32:23 <syntaxfree> humasect: in Haskell-prime, not GHC.
12:32:41 <humasect> read just below a little
12:33:03 * syntaxfree is overtalkative today.
12:33:15 <humasect> "GHC now ... "  and with 6.6 we can use -fglasgow-exts for all of the listed chars, except lamb
12:34:58 <mgsloan> hmm, very possible that they think it works, but it doesn't
12:35:03 <monologue> To continue with a previous dialogue, there was a time I didn't understand existential types, and that was when I had not thought of any use for it.  When later I asked myself "how would you do ____?", I looked at existential types and it suddenly made sense.  I do believe in some form of Piaget's theory in that one is sometimes not ready.
12:35:07 <humasect> ahh =)
12:38:13 <monologue> Jay Misra had a joke about someone trying to sell Indo-Arabic numerals to the Roman Empire.
12:38:39 <ph8> hi all, bit of a nooby question - how can i count the elements in a list?
12:38:46 <sorear> length
12:38:47 <ph8> length list?
12:38:49 <ph8> cheers
12:39:03 <sorear> jut a useful tip:
12:39:04 <mgsloan> ?src length
12:39:04 <lambdabot> Source not found. Wrong!  You cheating scum!
12:39:08 <mgsloan> :(
12:39:20 <sorear> what type would a function which measures a list have?
12:39:29 <spiffy> ?type length
12:39:30 <sorear> it takes a list, and returns a number
12:39:30 <lambdabot> forall a. [a] -> Int
12:39:36 <sorear> @hoogle [a] -> Int
12:39:37 <lambdabot> Prelude.length :: [a] -> Int
12:39:44 <spiffy> @src length
12:39:44 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
12:39:48 <sorear> hoogle is usegol
12:39:49 <spiffy> weird
12:40:19 <sorear> foldl' (const . (+1)) 0, if you must know
12:40:27 * mgsloan wonders if sorear intended that consonance
12:40:30 <mgsloan> heh
12:40:45 <glguy> ?fptools Prelude
12:40:45 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
12:40:53 <mgsloan> length [] = 0; length (x:xs) = length xs + 1
12:41:10 <mgsloan> the x in the second one could be _
12:41:24 <sorear> foldr!!
12:41:35 <dylan> hmm, I got this channel confused with another one. Oops.
12:41:36 <mgsloan> pattern matching!!
12:41:41 <glguy> genericLength           :: (Num i) => [b] -> i
12:41:41 <glguy> genericLength []        =  0
12:41:41 <glguy> genericLength (_:l)     =  1 + genericLength l
12:41:56 <sorear> glguy: you don't need the sig
12:42:04 <glguy> sorear: I'm pasting from GHC sources
12:42:09 <sorear> genericLength won't trip the MR
12:42:31 <glguy> sorear: I know it doesn't (because it takes an argument)
12:42:49 <syntaxfree> lambdabot's " wittiness " gets old fast.
12:42:59 <dylan> so, are there haskell bindings to dbus yet?
12:43:00 <sorear> besides, pasting is cheating :)
12:43:13 <glguy> sorear: I was more interested in how GHC defines it than anything else
12:43:44 <mgsloan> hmm, existential types are cool. the name and syntax is just scary
12:44:04 <syntaxfree> the " measure"  of a list for me is either its sum or its std. deviation.
12:44:23 <monologue> The name and syntax is perfect.
12:44:38 <sorear> dylan: would H/Direct count?
12:44:53 <mgsloan> i think count might be a better name for length
12:44:57 <dylan> that's a way of interfacing C?
12:44:57 <sorear> as a binding to all corba services
12:44:58 <DracoCepheus> `div` worked, thanks
12:45:04 <dylan> dbus is not corba
12:45:15 <mgsloan> frees it up for vector stuff, and such.  though i suppose that could be L n
12:45:15 <sorear> oh
12:45:27 <dylan> it's a lot .. nicer.
12:45:52 <syntaxfree> oh, my god. I'm balder than most Haskell hackers.
12:46:20 <glguy> There are bald haskell hackers?
12:46:44 <Igloo> Several are completely bald
12:46:51 <glguy> oh my
12:46:57 <sorear> you also speak more portugese then most haskell hackers
12:47:23 <mattam> syntaxfree: what's the std. deviation of a list ?
12:47:53 <glguy> heh, depends on which definition you are using
12:48:01 <syntaxfree> mean((x-mean(x))^2)
12:48:08 <glguy> that's one
12:48:11 <syntaxfree> that's variance, anyway.
12:48:18 <syntaxfree> std. deviation is the square root of that.
12:48:41 <mattam> i see, you're talkig about list of numerical values
12:48:43 <syntaxfree> glguy: what's another one? That's standard deviation. It's the standard.
12:48:52 <sorear> the  n-1 version
12:48:59 <glguy> yeah, what sorear said
12:49:03 <mgsloan> @let mean xs = sum xs / length xs
12:49:04 <lambdabot> <local>:2:17:     No instance for (Fractional Int)       arising from use of ...
12:49:10 <sorear> insert mumbo-jumbo about unbiased estimators
12:49:12 <syntaxfree> no, no. that's an unbiased estimator of a population standard deviation.
12:49:21 <syntaxfree> the standard deviation of a sample has no n-k factor.
12:49:23 <sorear> (which FTR I don't understand at all)
12:49:34 <syntaxfree> Completely different things.
12:49:43 <glguy> all I know is that my calculator, and my highschool math book defined it differently
12:49:49 <syntaxfree> The n-k formula is an estimator, the ordinary formula is a statistic.
12:49:56 <sorear> what's an estimator
12:50:10 <mgsloan> something that estimates?
12:50:15 <sorear> just because I can quote wikipedia doesn't mean I understand it
12:50:17 <glguy> "Given only a sample of values x1,...,xN from some larger population, many authors define the sample (or estimated) standard deviation by" (n-1 version) -- wikipedia
12:50:19 <syntaxfree> glguy: maybe you had the easy-to-use version. mean(x^2)-(mean(x))^2
12:50:30 <syntaxfree> glguy: well, that's just wrong.
12:50:41 <syntaxfree> the sample analog of a stochastic statistic should preserve moments.
12:50:52 <glguy> syntaxfree: fix the wikiality!
12:51:01 <syntaxfree> that's pop statistics bullshit.
12:51:05 * sorear feels dumb for once
12:51:45 <syntaxfree> well, I had an entire year of graduate-level statistics already, not to mention years of experience in econometrics.
12:53:46 <glguy> "However, consistent with widespread inconsistent and ambiguous terminology, the square root of the bias-corrected variance is sometimes also known as the standard deviation, (n-1 version)" -- Mathworld
12:55:40 * sorear tries to change the topic back to categorical arcana
12:55:47 <dylan> are there any haskell web frameworks that just map functions to URIs?
12:55:57 <syntaxfree> statistical analysis basically consists of treating samples as observations of random values.
12:56:32 <sorear> dylan: do you mean map URIs to functions?
12:56:55 <dylan> yeah
12:57:03 <dylan> without requiring a seperate webserver, that is
12:57:12 <dylan> something runs as a CGI/FastCGI.
12:57:27 * syntaxfree applauds Dylan
12:57:28 <sorear> like Network.FastCGI ?
12:57:34 <dylan> In my mind, a URI is a function.
12:57:44 <sorear> or HWS ?
12:57:58 <dylan> I also want to do this:
12:58:00 * humasect the first time of adding to GHC Trac
12:58:03 <glguy> > let xs = [1,3,7,10]; mean = liftM2 (/) sum genericLength in sqrt ( mean (map (join (*)) xs ) - mean xs )
12:58:04 <lambdabot>  5.873670062235365
12:58:35 <dylan> uri_action = require_authentication $ do ...
12:58:52 <syntaxfree> > let xs = [1,1,1,1,1]; mean = liftM2 (/) sum genericLength in sqrt ( mean (map (join (*)) xs ) - mean xs )
12:58:53 <lambdabot>  0.0
12:59:29 <sorear> dylan: look at Network.*CGI, it is a lot like that I hear
12:59:38 <syntaxfree> glguy: now, define a standardized score as [x - mean(x)]/std[x]
13:00:01 <syntaxfree> Chebyshev's inequality places an upper bound on the probability that the absolute value of that standardized score is k
13:00:08 <syntaxfree> (That upper bound is 1/k^ 2)
13:00:19 <syntaxfree> 1/(k^2), even.
13:00:28 <dylan> sorear: thanks
13:00:28 <glguy> (same thing in this case :) )
13:00:36 <sorear> powers commute
13:00:47 <syntaxfree> true.
13:01:01 <syntaxfree> i think you mean powers distribute over multiplication, right?
13:01:07 <syntaxfree> not commute.
13:01:13 <sorear> the set of power functions forms a commutative subgroup of R^R
13:01:17 <newsham> its more fun to commute
13:01:26 <glguy> I meant that ^ has precedence over /
13:01:26 <sorear> the set of power functions forms a commutative subgroup of invertable real->reals
13:01:28 <syntaxfree> oh, c'mon.
13:01:30 <glguy> but either way it worked
13:01:34 <syntaxfree> Face it, statistics is more directly useful ;)
13:01:51 <glguy> sure, if you needed to know that standardized score
13:01:58 <sorear> incidentally, this subgroup is isomorphic to nonzero reals under multiplication
13:01:59 <newsham> syntax: sure.  lies, damned lies and statistics.
13:02:08 <sorear> incidentally, this subgroup is isomorphic to Z (+) Z_2
13:02:08 <newsham> so mallable they can be useful to any political campaign
13:02:26 <sorear> where (+) is direct sum
13:02:32 <sorear> no, I don'
13:02:51 <sorear> t understant the difference between direct sums and direct products either.
13:02:52 <syntaxfree> newsham: because the average person understands nothing of it?
13:03:55 <sorear> @where lambdabot-complete
13:03:55 <lambdabot> http://mikael.johanssons.org/irssi/lambdabot-complete.pl
13:04:50 <humasect> would it be somewhat straightforward for one to submit a patch to 6.6 ? (is GHC well-accepting of user patches?)
13:05:09 <sorear> the're an open project
13:05:22 <sorear> worst that could happen is "no thanks"
13:06:12 <newsham> so pivotal (http://www.cs.kent.ac.uk/projects/pivotal/) looks interesting
13:06:14 <lambdabot> Title: Pivotal home page
13:06:26 <glguy> > let xs = [1,3,7,10]; mean = liftM2 (/) sum genericLength; stddev = sqrt . liftM2 (-) (mean . map (^2)) mean in stddev xs
13:06:28 <lambdabot>  5.873670062235365
13:07:21 <sorear> ?pl let mean = liftM2 (/) sum genericLength; stddev = sqrt . liftM2 (-) (mean . map (^2)) mean in stddev
13:07:21 <lambdabot> sqrt . liftM2 (-) (liftM2 (/) sum genericLength . map (^ 2)) (liftM2 (/) sum genericLength)
13:07:31 <humasect> sorear: okay, thanks =)
13:07:45 <humasect> newsham: has pivotal moved since 1 year, do you know ?
13:07:48 <glguy> bah, using ?pl is worse cheating than pasting from sources!
13:07:52 <newsham> no idea.
13:08:31 <sorear> Oh, I meant cheating wrt the #3 competition :)
13:09:23 <humasect> pivotal is a very exciting project
13:09:29 <newsham> do dons, dcoutts and lemmih still work on hide-2 (do they use it?)
13:10:00 <Igloo> There was talk after the hackathon of reviving it
13:10:30 <humasect> it is gtk(2hs), right?
13:10:38 <bos_> humasect: yes
13:11:15 <dr_strangelove> is there something like          zipWithN :: ([a] -> b) -> [[a]] -> [b]          ?
13:11:19 <humasect> i still have this visual of an application in a somewhat visual way for haskell programs, this is entirely possible (much more than many other langs)
13:11:32 <humasect> @hoogle ([a] -> b) -> [[a]] -> [b]
13:11:33 <lambdabot> No matches, try a more general search
13:11:44 <sorear> dr_strangelove: map . transpose?
13:11:50 <newsham> isnt that a map?
13:11:55 <newsham> ?type map
13:11:56 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
13:12:12 <sorear> ?pl \f = map f . transpose
13:12:12 <lambdabot> (line 1, column 4):
13:12:13 <lambdabot> unexpected "="
13:12:13 <lambdabot> expecting operator, pattern or "->"
13:12:16 <sorear> ?pl \f -> map f . transpose
13:12:16 <lambdabot> (. transpose) . map
13:12:20 <humasect> we can see that hoogle does not reverse compose
13:12:29 <glguy> > let xs = [1,3,7,10]; mean = liftM2 (/) sum genericLength; stddev = sqrt . (=<<) (liftM2 (-)) (. map (^2)) mean in stddev xs -- glguy factors out mean
13:12:30 <lambdabot>  5.873670062235365
13:12:34 <nickm283> can someone explain to me the Ord part of this line. ngram :: Ord a => [a] -> Map [a] [a]. i am a serious noob
13:12:45 <dr_strangelove> sorear, thanks I will try map and transpose ...
13:12:49 <sorear> > ((. transpose) . map) sum [[1,2,3],[5,6,7],[12,12,13]
13:12:49 <lambdabot>  Parse error
13:12:50 <humasect> type a is of Ordered class
13:12:50 <sorear> > ((. transpose) . map) sum [[1,2,3],[5,6,7],[12,12,13]]
13:12:51 <lambdabot>  [18,20,23]
13:12:53 <newsham> if a = [c] then  map :: ([c] -> b) -> [[c]] -> [b]
13:12:58 <kolmodin> dons: done further tuning on ross' code?
13:13:08 <glguy> > let xs = [1,3,7,10]; stddev = sqrt . (=<<) (liftM2 (-)) (. map (^2)) (liftM2 (/) sum genericLength) in stddev xs -- glguy factors out mean
13:13:10 <lambdabot>  5.873670062235365
13:13:52 <newsham> nickm283: it means that "a" must be something that can be compared for ordering (Ord)
13:14:03 <nickm283> thanks guys
13:14:04 <newsham> ?type (<)
13:14:05 <lambdabot> forall a. (Ord a) => a -> a -> Bool
13:14:27 <newsham> ?src Ord
13:14:27 <lambdabot> class  (Eq a) => Ord a  where
13:14:27 <lambdabot>     compare      :: a -> a -> Ordering
13:14:27 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
13:14:27 <lambdabot>     max, min         :: a -> a -> a
13:14:58 <newsham> Ord's can be comared for equality (they're also Eq's) and for less-than, greater-than
13:15:57 <kolmodin> dons: because it runs twice as fast when you integrated it into Put than when I ran it seperately
13:16:33 <sorear> @users #haskell
13:16:33 <lambdabot> Maximum users seen in #haskell: 311, currently: 311 (100.0%), active: 51 (16.4%)
13:16:47 <astrolabe> wow :)
13:16:59 <glguy> > join (***) sum (unzip (map (ap (,) (join (*))))) [1,3,7,10]
13:16:59 <lambdabot>      Expecting a function type, but found `t_a1RC'
13:17:00 <lambdabot>       Expected type: (b ->...
13:17:14 <kolmodin> dons: and about fast put of WordX, what about alignment? you can't address any byte, only every forth, for Word32, for example
13:17:16 <glguy> > join (***) sum (unzip (map (ap (,) (join (*)))[1,3,7,10]))
13:17:17 <lambdabot>  (21,159)
13:17:17 <sorear> glguy: it only counts if it is type correct :)
13:17:21 <glguy> lol
13:17:26 <glguy> I'm not done yet :-p
13:17:50 <nickm283> another q. with this line of code {ngram = mapify . takeWhile (atLeast) . map (take gramSize) . tails etc....} what would the mapify bit be referring to. i cant work it out. its not my code but the only help i could fiind regarding my project.
13:17:55 <glguy> > uncurry (-) $ join (***) sum (unzip (map ((,) =<< (join (*)))[1,3,7,10]))
13:17:56 <lambdabot>  138
13:18:02 <glguy> > sqrt $ uncurry (-) $ join (***) sum (unzip (map ((,) =<< (join (*)))[1,3,7,10]))
13:18:03 <lambdabot>  11.74734012447073
13:18:07 <sorear> kolmodin: dons hasnt been here for >2 hours, perhaps @tell would be better
13:18:08 <glguy> hmm
13:18:18 <kolmodin> sorear: maybe..
13:18:19 <kolmodin> :)
13:18:26 <sorear> glguy: it only counts if it is value correct :) :)
13:18:31 <glguy> oh
13:18:34 <glguy> right
13:18:39 <glguy> OH, no mean
13:18:47 <astrolabe> @hoogle mapify
13:18:47 <lambdabot> No matches found
13:18:57 <sorear> astrolabe: you want what?
13:19:06 <glguy> > sqrt $ uncurry (-) $ join (***) (liftM2 (/) sum genericLength) (unzip (map ((,) =<< (join (*)))[1,3,7,10]))
13:19:07 <lambdabot>  5.873670062235365
13:19:10 <glguy> bingo!
13:19:15 <astrolabe> [21:15] nickm283: another q. with this line of code {ngram = mapify . takeWhile (atLeast) . map (take gramSize) . tails etc....} what would the mapify bit be referring to. i cant work it out. its not my code but the only help i could fiind regarding my project.
13:19:18 <sorear> all these consequtive quits are depressing me
13:19:27 * sorear feels happy again
13:19:33 * sorear claps for glguy
13:19:39 <bos_> @seen
13:19:39 <lambdabot> Lately, I have seen astrolabe, bos_, dr_strangelove, elpolilla, gaal, glguy, gly, humasect, igloo, kolmodin, luqui, newsham, nickm283, ohmega, ohmega-, putter, sorear, stevan, timtoady, trurl_ and
13:19:39 <lambdabot> verga.
13:19:43 <bos_> @users
13:19:43 <lambdabot> Maximum users seen in #haskell: 311, currently: 308 (99.0%), active: 51 (16.6%)
13:19:51 <bos_> not too shabby.
13:19:56 <glguy> sorear: I was trying to not reuse any function... I need to change (join (*)) to (^2)
13:20:20 <sorear> glguy: of course you'll be obsolete when I finish my uber-genetic-algorithm-@pl :)
13:20:49 <kolmodin> bos_: please don't use that function. you just pinged half the channel
13:20:52 <monologue> glguy will not be obsolete.
13:21:40 <glguy> sorear: when ?pl can produce   (.) (liftM2 (.) (flip (.))) (.)     I'll be happy
13:22:04 <astrolabe> @type (.) (liftM2 (.) (flip (.))) (.)
13:22:04 * glguy doesn't like:
13:22:05 <lambdabot> forall a b c. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:22:12 <monologue> To obsolete glguy, you really need to write a program that learns Haskell.
13:22:15 <glguy> ?pl \f g x y -> g x `f` g y
13:22:15 <lambdabot> join . ((flip . ((.) .)) .) . (.)
13:22:17 <humasect> not shabby at all.
13:22:29 <glguy> pl's version isn't bad either
13:22:32 <glguy> I just like mine better
13:22:41 * glguy my having written it might be why)
13:22:43 <humasect> monologue: o_o..
13:23:13 <astrolabe> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
13:23:13 <lambdabot> f a b c _ = a (b c) (b c)
13:23:33 <astrolabe> I vote for djinn's :)
13:23:43 <nickm283> another q. with this line of code {ngram = mapify . takeWhile (atLeast) . map (take gramSize) . tails etc....} what would the mapify bit be referring to. i cant work it out. its not my code but the only help i could fiind regarding my project.
13:23:43 <glguy> lol, but it doesn't do the same thing
13:24:21 <monologue> mapify refers to some function someone has written.
13:25:01 <monologue> To add to that, it is not in the usual libraries.
13:25:19 <astrolabe> glguy: it doesn't?
13:25:36 * kolmodin feels ill and grumpy, time to go to bed. had an unusual short temper today, sorry about that. g'night!
13:25:58 <trurl_> astrolabe: no, since it doesn't use the 4th argument
13:25:58 <glguy> ?unpl (.) (liftM2 (.) (flip (.))) (.)
13:25:58 <lambdabot> (\ c -> (\ m n q -> n (m q)) >>= \ e -> (\ s t -> c (s t)) >>= \ d -> return (\ k -> e (d k)))
13:26:02 <astrolabe> glgut: ah, I see what you mean
13:26:02 <glguy> lol
13:26:11 <glguy> that wasn't so helpful
13:26:25 <glguy> ?. redo unpl (.) (liftM2 (.) (flip (.))) (.)
13:26:25 <lambdabot> (\ c -> do { e <- (\ m n q -> n (m q)); d <- (\ s t -> c (s t)); return (\ k -> e (d k))})
13:26:33 <astrolabe> @karma- unpl
13:26:33 <lambdabot> unpl's karma lowered to -1.
13:27:17 <astrolabe> should be  f a b c d = a (b c) (b d)
13:27:33 <glguy> :t \f g -> (. g) . f . g
13:27:35 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:28:15 <glguy> :t \f g -> (. g) . (. g) f
13:28:17 <lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
13:28:48 <bos_> kolmodin: which function?
13:31:16 <glguy> :t ap (.) (. f) (. g)
13:31:18 <lambdabot> Not in scope: `f'
13:31:18 <lambdabot>  
13:31:18 <lambdabot> <interactive>:1:16: Not in scope: `g'
13:31:21 <glguy> :t \f g -> ap (.) (. f) (. g)
13:31:23 <lambdabot> forall a b c. (a -> b -> c) -> (b -> b) -> a -> b -> c
13:31:27 <glguy> oops
13:31:42 <syntaxfree> @unpl (+)
13:31:43 <lambdabot> (+)
13:31:55 <sorear> you need a stronger type system!
13:34:07 <glguy> :t \f g -> ap (.) (flip id f) (. g)
13:34:08 <lambdabot>     Occurs check: cannot construct the infinite type: c = b -> c
13:34:08 <lambdabot>       Expected type: (b -> c) -> a -> b -> c
13:34:11 <glguy> uhg
13:34:26 <kolmodin> bos_: ?seen
13:34:56 <bos_> kolmodin: ok. it's a bit odd that it's enabled, if it's so antisocial.
13:35:29 <glguy> people really only seemed to start whining today
13:35:34 <monologue> Nothing is absolutely antisocial a priori.
13:35:53 <kolmodin> well someone is writing a patch for it as we speak. I hope. sorear, any progress?
13:36:04 <monologue> dons's philosophy is that you will make a good judgement call.
13:36:22 <monologue> my philosophy is that even "> 1+1" is antisocial.
13:36:31 <bos_> i'm all for making good judgment calls, but i prefer to have information in order to do so :-)
13:36:45 <bos_> i had no way of knowing that "seen" pings clients.
13:36:57 <bos_> short of reading the lambdabot code, that is :)
13:36:59 <SamB> it doesn't
13:37:07 <monologue> my usual advise is "always test it in /msg first"
13:37:07 <SamB> it *does* trigger highlights...
13:37:07 <glguy> it's only people who have their clients configured as such
13:37:11 <Philippa> it causes clients to go "ping!", that's not the same thing
13:37:19 <Philippa> SamB: and noises and notifications
13:37:27 <Excedrin> irc clients shouldn't beep :P
13:37:28 <bos_> i see.
13:37:46 <Philippa> yeah, but it's sufficiently common a piece of configuration that some people expect others to have it and see if their name's been mentioned while they're gone
13:37:59 <bos_> well, now you understand my confusion.
13:38:38 <kolmodin> well I've always been annoyed by it, my fever makes it worse :)
13:38:40 <Philippa> Excedrin: there're some good use cases for sound notification. Like when you're running a fullscreen app...
13:38:43 <monologue> For example earlier today sorear tried a command like 10 times before he got it right.  I really wanted to yell at him "why don't you use /msg to get it right first?"
13:39:00 <Philippa> yeah, that kind of thing is annoying
13:39:07 <bos_> i do most of my hoogling and such in private.
13:39:22 <glguy> I do hoogling in public where someone can say "Oh, you meant this"
13:39:49 <bos_> glguy: yeah, but you've been doing haskell for long enough that you'lll converge on an answer faster than me :-)
13:39:49 <monologue> After you get it right, you can show it in the channel, if you want to show it.
13:40:02 <glguy> or where someone newer than me can say, oh I didn't know about those functions
13:40:13 <bos_> yeah, that's very useful.
13:40:30 <glguy> seeing other people try stuff in channel taught me a lot
13:41:11 <monologue> When you write software, it's ridiculous to do a commit, even a shipment, without parsing and testing.
13:41:22 <humasect> parsing?
13:41:36 <monologue> checking for syntax errors
13:41:37 <glguy> yeah, i definitely don't recommend writing software in channel
13:41:49 <humasect> ah
13:41:50 <sorear> I do it in public because each time I'm absolutely convinced I'll get it right the next time :)
13:41:53 <glguy> lambdabot doesn't even understand data types
13:42:03 <glguy> (new ones that is)
13:42:10 <humasect> =)
13:42:21 <sorear> although it is rather embarrasing when I realize I forgot to build before sending off to dons...
13:42:22 <glguy> so you'll be stuck with tuples of various sizes
13:42:34 <bos_> you mean i can't just scrape my new web2.0 app from #haskell logs?
13:42:38 <monologue> But when you people use lambdabot you're doing exactly that.  Show something untested to the whole channel.  Make a million shipments, each trying to correct an error but still doesn't get it fixed.
13:42:44 <astrolabe> monologue: but sometimes you want to keep a copy part way through a complex change, in case you make a mistake.
13:42:59 <glguy> monologue: sounds like #haskell might be a little too hectic for you
13:43:32 <astrolabe> #haskell is pretty busy these days, but #haskell-overflow gets hardly any traffic
13:44:00 <humasect> glguy=)
13:44:02 <Philippa> monologue: sometimes showing something untested's appropriate
13:44:28 <Philippa> although I think it'd generally be a good habit for anything more than, say, 5 tokens to be tested in PM first
13:44:36 <monologue> Yeah
13:44:52 <sorear> sounds like what we really need is an irssi script that sends to lambdabot then to channel if correct
13:45:12 <Philippa> sorear: you might, not everyone's running irssi
13:45:39 <sorear> change $client arbitrarily
13:45:59 <glguy> ?pl \f h -> h . h f
13:45:59 <lambdabot> ap (.) . flip id
13:46:04 <sorear> local lambdabot current has a lambdabot -e 'foo' command
13:46:46 <Excedrin> Philippa: it only took me 6 minutes to notice that you said something, isn't that good enough?
13:47:34 <Philippa> Excedrin: you might not want notification, that's fine
13:47:40 <Philippa> don't presume to tell me how to run my client
13:47:54 <ctkrohn> hey, does anyone know if there are any freetype bindings for haskell?
13:48:02 <glguy> no one is telling you how to run your client, they are teling you to stop telling them how to use lambdabot :-p
13:48:15 <Philippa> and funnily enough, yeah, I've had situations where a 6 minute turnaround was too long
13:48:48 <monologue> If I don't tell them how to use lambdabot, who is going to?
13:48:55 <glguy> dons probably
13:49:13 <Excedrin> I'm used to IRC where people are far more hostile than #haskell, a beeping client would drive me insane
13:49:35 <syntaxfree> 7:36 PM  monologue: For example earlier today sorear tried a command like 10 times before he got it right.  I really wanted to yell at him "why don't you use /msg to get it right first?"
13:49:42 <syntaxfree> sometimes watching the errors is instructive.
13:50:05 <glguy> syntaxfree: in this case it was ?info____ ?info___ ?info__ ?info_ ?info
13:50:07 <glguy> :-D
13:50:12 <bos_> wow, i stirred up a hornet's nest. this place is much more mellow late at night.
13:50:17 <humasect> =)
13:50:35 <glguy> there's a lot of pent-up anger coming out ;)
13:50:50 <monologue> Yeah I have strong feelings about lambdabot spamming.
13:51:11 <bos_> seems there's a diversity of opinion on this matter.
13:51:53 <sorear> @localtime bos_
13:51:54 <lambdabot> Local time for bos_ is Mon Jan 15 13:49:45
13:52:16 <astrolabe> Can't the lambdabot responses be munged somehow?
13:52:36 <sorear> munging considered dirty and hackish
13:52:54 * glguy wonders what munging is
13:53:06 <sorear> @. elite seen
13:53:06 <lambdabot> |a73lY, i h4\/3 z3en 4S+ro1Abe, 80z_, c+xr0hN, ExCedRIn, gL9uy, 9ly, HUmaze(T, xo|mOdIn, Ma7+am, m0n0l09Ue, 0hmEG4-, fIliPPa, pU+TEr, 5Or34r, zYN74XfR3E 4nD +iM+oADy.
13:53:10 <astrolabe> sorear: I don't see why.
13:53:34 <syntaxfree> oh well. @seen really annoys me.
13:53:42 <sorear> @. rot13 seen
13:53:42 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "rot13"
13:53:48 <sorear> @list filters
13:53:48 <lambdabot> No module "filters" loaded
13:53:49 <sorear> @list filter
13:53:49 <lambdabot> No module "filter" loaded
13:53:56 <glguy> tsk tsk
13:54:23 <monologue> This is an instance of social, culture, protocol issues.  Every once in a while we need to discuss such an issue.
13:54:42 <glguy> glad we are getting it done early this year...
13:54:56 <sorear> lambdabot is polical, wow
13:55:06 <sorear> oh protocol
13:55:17 <astrolabe> we need a witch hunt
13:55:18 <glguy> speaking of socialists
13:55:28 <chessguy> i (usually) like seeing such playing around with lambdabot. it's instructive
13:56:28 <syntaxfree> beginners profit immensely from seeing the more experienced play with lambdabot, yes.
13:56:31 <astrolabe> repeated use of lambdabot filling the whole screen up with stuff makes the channel worse for me.
13:56:43 <syntaxfree> it's like sitting besides a more experienced coder and watch him work.
13:56:46 <Excedrin> '/ignore -pattern "Lately, I have seen" *
13:56:55 <astrolabe> But in moderation, I think anything's fine.
13:57:07 <glguy> Excedrin: blasphomy!
13:57:53 <glguy> Excedrin: besides, then everyone would write: Lately, I have seen : man, can you believe those people?
13:58:19 <syntaxfree> Lambdabot's cheekiness is getting tiresome.
13:58:29 <syntaxfree> It was funny for 15 minutes.
13:58:46 <sorear> "Lately, I have seen Excedrin--"
13:58:57 <chessguy> @seen
13:58:57 <lambdabot> Lately, I have seen astrolabe, bos_, chessguy, ctkrohn, excedrin, glguy, gly, humasect, jaak, mattam, monologue, ohmega-, philippa, putter, sorear, syntaxfree and timtoady.
13:59:02 <syntaxfree> GRRRRRR
13:59:03 <chessguy> ah
13:59:05 <glguy> LOL
13:59:17 <Excedrin> '/ignore -pattern "Lately, I have seen" lambdabot
14:00:22 <syntaxfree> @seen lambdabot
14:00:22 <lambdabot> Yes, I'm here. I'm in #scannedinavian, #unicycling, #jtiger, #perl6, #oasis, #darcs, #ghc, #gentoo-uy, #gentoo-haskell, #haskell.dut, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell
14:00:55 <glguy> does Excedrin's solution satisfy those with the complaint?
14:01:29 <syntaxfree> my client won't allow that.
14:01:39 <sorear> Anyone who likes Excedrin should @tell dons to reject the patch I sent two hours ago.
14:01:51 <sorear> s/Excedrin/\&'s solution/
14:01:52 <syntaxfree> besides, I like @seen nick
14:02:09 <sorear> syntaxfree: my patch doesn't break @seen nick
14:02:11 <Excedrin> @seen nick doesn't match that pattern
14:02:11 <lambdabot> I haven't seen nick.
14:02:20 <chessguy> nick who?
14:02:38 <glguy> ?poll
14:02:38 <lambdabot> Maybe you meant: poll-add poll-close poll-list poll-remove poll-result poll-show pl spell tell
14:02:43 <Excedrin> also, a nice munging solution is to embed "boldbold" in the string
14:02:52 <sorear> c'mon people...
14:02:58 <sorear> just wait a few hours
14:03:06 <Excedrin> who has nick highlighting and does't mind me triggering it?
14:03:11 <sorear> when dons wakes up @seen will be history
14:03:12 <sorear> me
14:03:12 <glguy> me
14:03:23 <Excedrin> glguy sorear
14:03:26 <Excedrin> triggered?
14:03:29 <glguy> yeah
14:03:36 <syntaxfree> Lately, I have seen a lot of Ruby articles at programming.reddit.com
14:03:45 <sorear> my nick highlighting only happens at the beginning of lines
14:03:52 <Excedrin> glguy: interesting, which client?
14:03:52 <sorear> ?id foo sorear
14:03:53 <lambdabot>  foo sorear
14:03:57 <sorear> no highlighht
14:03:59 <glguy> syntaxfree: which is why Excedrin's pattern only matched for lambdabot
14:04:02 <sorear> ?id sorear: foo
14:04:02 <lambdabot>  sorear: foo
14:04:03 <glguy> Excedrin mirc
14:04:03 <Excedrin> sorear: test
14:04:16 <sorear> highlight Excedtrin (not LB though)
14:04:23 <glguy> Excedrin: typically irssi though
14:04:32 <jethr0> there should be better documentation for the lambdabot commands...
14:04:35 <jethr0> ?list
14:04:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
14:04:41 <sorear> jethr0: better how?
14:04:45 <jethr0> @yhjulwwiefzojcbxybbruweejw
14:04:45 <lambdabot> "\""
14:04:45 <Excedrin> I guess mirc strips bold before matching nicks... it didn't at one time
14:04:46 <mgsloan> yeah, that's pretty crappy
14:04:58 <jethr0> explaining what they do
14:05:01 <sorear> @help help
14:05:01 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:05:06 <jethr0> @help yhjulwwiefzojcbxybbruweejw
14:05:06 <lambdabot> V RETURNS!
14:05:12 <sorear> jethr0: hows that?
14:05:19 <bos_> jethr0: what's that?
14:05:19 <jethr0> bad
14:05:24 <chessguy> looks like a polish word
14:05:24 <jethr0> i have no idea
14:05:25 <mgsloan> then maybe all the cruft should be removed...
14:05:30 <Excedrin> oh, the channel is +c, I guess the irc server is stripping bold
14:05:42 <jethr0> i seem to remember that it's a jpl interpreter or sth like that
14:05:52 <sorear> jpl ?
14:05:52 <mgsloan> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
14:06:05 <mgsloan> ?yarr
14:06:05 <lambdabot> Shiver me timbers!
14:06:19 <jethr0> a lot of cruft in lambdabot. for example, i've never seen @pretty being used (and i'm the author of the initial, horrible code)
14:06:31 <sorear> almost all the quote commands are partial applications of quote
14:06:31 <jethr0> @help protontorpedo
14:06:32 <lambdabot> protontorpedo is silly
14:06:34 <glguy> I've used ?pretty this last week
14:06:46 <mgsloan> ?pretty (1+2/3)
14:06:47 <lambdabot> "Parse error" at column 8
14:06:48 <sorear> jethr0: have you seen @pl ?
14:06:54 <mgsloan> ?help pretty
14:06:54 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
14:06:55 <glguy> to show explain how to do something to someone
14:07:02 <Excedrin> oh, so does quote also trigger highlights?
14:07:13 <Excedrin> @quote
14:07:14 <lambdabot> dmhouse says:  Wonderful, a year in the channel and I've still said nothing memorable. :)
14:07:16 <jethr0> ah, ok. there should be a history of used commands so that the maintainers can kick commands (temporarily) that haven't been used for months
14:07:20 <sorear> @quote sorear
14:07:20 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
14:07:20 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
14:07:21 <mgsloan> ?pretty foo=1+2/3
14:07:21 <jethr0> sorear: yes, i love pl
14:07:21 <lambdabot>  foo = 1 + 2 / 3
14:07:35 <sorear> jethr0: I meant the code :)
14:07:40 <lisppaste2> nickm687 pasted "error help" at http://paste.lisp.org/display/35436
14:07:42 <Excedrin> @quote is like highlight russian roulette
14:07:42 <lambdabot> No quotes for this person. I've seen penguins that can type better than that.
14:07:49 <sorear> it makes pretty look pretty
14:07:55 <glguy> why does lambdabot need to have fewer commands?
14:08:03 <glguy> what benefit does that provide?
14:08:24 <syntaxfree> for one, there are too many "databases".
14:08:25 <jethr0> @pretty do {x <- getLine; case x of | "hello" -> 0 | otherwise -> 1; putStrLn "world"}
14:08:26 <lambdabot> "Parse error" at column 29
14:08:34 <jethr0> @pretty do {x <- getLine; case x of "hello" -> 0 | otherwise -> 1; putStrLn "world"}
14:08:34 <lambdabot> "Parse error" at column 42
14:08:35 <syntaxfree> @quote and @where are useful.
14:08:35 <lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
14:08:38 <jethr0> grr
14:08:38 <syntaxfree> but there are many others.
14:08:39 <lisppaste2> nickm687 annotated #35436 with "error" at http://paste.lisp.org/display/35436#1
14:08:49 <sorear> glguy: lambdabot takes approximately forever to build
14:08:52 <mgsloan> @pretty foo = do {x <- getLine; case x of "hello" -> 0 | otherwise -> 1; putStrLn "world"}
14:08:53 <lambdabot> "Parse error" at column 48
14:09:03 <glguy> @pretty let length [] = 0; length (_:xs) = 1 + length xs
14:09:04 <lambdabot> "Parse error" at column 49
14:09:10 <glguy> @pretty let length [] = 0; length (_:xs) = 1 + length xs in length [1..10]
14:09:10 <lambdabot>  i = let length [] = 0
14:09:10 <lambdabot>          length (_ : xs) = 1 + length xs
14:09:10 <lambdabot>        in length [1 .. 10]
14:09:25 <jethr0> *brr*
14:09:41 <nickm283> can anyone help me with this error i cant figure it out. http://paste.lisp.org/display/35436
14:09:43 <jethr0> i have nothing against commands, but some are ancient and almost never used
14:10:17 <jethr0> nickm283: lots of people with that assignment today. what course is this for?
14:10:28 <bos_> nickm283: you need to pass a number as the first parameter
14:10:48 <glguy> mapGramsInFile (a:x) = Data.Map.union (ngramize NUMBER (words a)) (mapGramsInFile x)
14:10:57 <glguy> nickm283: fill in NUMBER?
14:13:09 <glguy> we were warned before winter break that the ngram assignment was out, and that people would be coming to #haskell in a couple weeks
14:13:13 <glguy> :)
14:13:25 <bos_> oh, that's hilarious
14:13:38 <glguy> by someone who didn't put it off till now :)
14:13:51 <bos_> it is a bit suspicious that someone could write a relatively complex module and then trip over such a trivial error :-)
14:14:18 <jethr0> nooo
14:14:59 <jethr0> it's suspicious to write 100s of lines of code all at once and then compile it the first time
14:15:10 <jethr0> kinda unusual in haskell
14:15:11 <glguy> bos_: if you are implying that people coming to #haskell asking questions about ngram code they didn't write suggests that they aren't the actual author
14:15:34 <glguy> I'm going to have to ask you to either show some proof, or retract your statement!
14:15:55 <bos_> glguy: i admit it. i cribbed that assertion from a "making random assertions on irc" pay site!
14:16:01 * jethr0 takes that as a joke/ironic statement and laughs
14:16:17 <glguy> jethr0: good call B^D
14:16:27 <bos_> for five bucks a month, i get to occasionally say something slightly mordant as if i thought it up!
14:16:30 <jethr0> close call
14:17:17 <glguy> "i wrote this function, but I can't remember what mapify does, can someone help?"
14:17:30 <sorear> add comments next time!
14:17:51 <huschi_> is there anything like "deepSeq" in haskell?
14:18:06 <jethr0> i've written a lot of code for a rather difficult beginner's assignment, but i have no idea how to interpret simple compiler errors
14:18:08 <jethr0> @hoogle deepSeq
14:18:09 <lambdabot> No matches found
14:18:09 <glguy> huschi_ : someone wrote a module that does it asa typeclass
14:18:18 <glguy> ?google haskell deepseq
14:18:19 <jethr0> huschi_: i think it might be in missingH
14:18:20 <lambdabot> http://research.microsoft.com/~simonpj/papers/not-not-ml/index.htm
14:18:20 <lambdabot> Title: Haskell is not not ML
14:18:29 <glguy> jethr0: I don't think that is correct
14:18:49 <sorear> @hoogle rnf
14:18:49 <lambdabot> Control.Parallel.Strategies.rnf :: NFData a => Strategy a
14:18:55 <jethr0> hmm
14:19:01 * glguy just doesn't remember seening deepseq stuff when he was looking through missingh, could be wrong
14:19:02 <sorear> rnf is the closest thing to deepSeq we have
14:19:03 <bos_> huschi_: look on google, there are a million copies.
14:19:23 <sorear> > rnf [1,2,3,4,5] `seq` 0
14:19:23 <lambdabot>   Not in scope: `rnf'
14:19:27 <jethr0> oh well
14:19:34 <sorear> > Control.Parallel.Strategies.rnf [1,2,3,4,5] `seq` 0
14:19:34 <lambdabot>   Not in scope: `Control.Parallel.Strategies.rnf'
14:19:38 <sorear> aw.
14:19:49 <jethr0> sorear: what does that do?
14:20:08 <sorear> jethr0: type Strategy a = a -> ()
14:20:17 <sorear> jethr0: rnf :: NFData a => a -> ()
14:20:20 * jethr0 has never worked with stragies before
14:20:24 <sorear> jethr0: rnf a = a `deepSeq` ()
14:20:34 <jethr0> hmm, nice
14:20:37 <sorear> jethr0: a `deepSeq` b = rnf a `seq` b
14:20:59 <sorear> I've only read the haddock, not worked with it.
14:21:01 <bos_> @type seq
14:21:03 <lambdabot> forall b a. a -> b -> b
14:21:18 <bos_> > [1,2] `seq` 3
14:21:19 <lambdabot>  3
14:21:28 <jethr0> [undefined] `seq` 4
14:21:34 <jethr0> > [undefined] `seq` 4
14:21:35 <bos_> > undefined `seq` 1
14:21:36 <lambdabot>  4
14:21:36 <lambdabot>  Undefined
14:21:48 <jethr0> hehe, just forces to normal form
14:22:05 <sorear> seq --> weak head normal form
14:22:11 <sorear> rnf --> normal form
14:23:26 <bd_> :t rnf
14:23:27 <lambdabot> Not in scope: `rnf'
14:24:21 <huschi_> i have a record type. what happens if i evaluate it using seq? are its components also evaluated?
14:24:23 <bos_> wow, i haven't thought about normal form in a long, long time.
14:24:40 <sorear> huschi_: not unless you use strict fields
14:24:45 <jethr0> also rhwnf and sSeq in Strategies
14:24:50 <chessguy> normal form for what?
14:25:00 <sorear> lambda calculus
14:25:03 <huschi_> sorear: that seems to be a good hint. thx.
14:25:05 <sjanssen> huschi_: no
14:25:05 <chessguy> oh
14:25:25 <bos_> chessguy: http://foldoc.org/?head+normal+form
14:25:26 <lambdabot> Title: Head Normal Form from FOLDOC
14:25:33 <chessguy> ty
14:25:41 <sorear> chessguy: an expression is in normal form if it contains no redexes (applications)
14:25:45 <bos_> a "redex" is a reducible expression, btw
14:26:14 <jethr0> @hoogle comparing
14:26:14 <lambdabot> No matches found
14:26:29 <jethr0> i thought comparing is in ghc 6.6 in some library
14:26:41 <sorear> it is
14:26:49 <sorear> lambdabot runs ghc 6.4
14:26:58 <chessguy> Wikipedia has a problem
14:26:58 <chessguy> Sorry! This site is experiencing technical difficulties.
14:27:07 <chessguy> ack! the sky is falling!
14:27:25 <mgsloan> they must have not got enough money from the donation drive
14:28:16 <mgsloan> should have that as a spoof "Sorry! This site is experiencing financial difficulties.  Donate here!"
14:28:48 <monologue> haha
14:29:40 <glguy> http://www.nysun.com/article/46707 -- I'd be laughing harder if this wasn't so sad for the peoples affected
14:29:41 <lambdabot> Title: Will Saudis Ban the Letter X'? - January 15, 2007 - The New York Sun
14:29:51 <jethr0> chessguy: works allright for me. are you in china :)
14:29:52 <sorear> QX ?
14:31:06 <jethr0> XXX
14:31:07 <bos_> nysun is written by lunatics.
14:31:11 <chessguy> not unless a tornado picked up my cube and put it there without me noticing
14:31:20 <chessguy> which i suppose i can't rule out
14:31:42 <chessguy> it works now
14:32:10 <sorear> I thought tornados could only safely transport people named Dorothy ?
14:32:14 <sorear> :)
14:32:40 <sjanssen> sorear: and her little dog too!
14:32:52 <glguy> bos_: I don't know anything about the nysun, but they seem to be the only people covering it
14:32:54 * jethr0 sing-songs "follow the yellow brick road" in an eerily high-pitched voice
14:33:05 <glguy> or inventing, who knows :)
14:33:14 <chessguy> you guys are really weird, you know that right? :)
14:33:40 <bos_> glguy: forall (articles in nysun), x => not x
14:33:55 <sorear> MY mom says weird is a virtue. so there. :)
14:34:08 <glguy> your mommy says you are special ?
14:34:28 <jethr0> we're all special people
14:35:12 <monologue> we're all weird people
14:41:55 <huschi_> has anybody ever noticed that the window timer in hgl runs to slow?
14:45:50 <mbishop> @seen samb
14:45:50 <lambdabot> samb is in #perl6 and #haskell. I last heard samb speak 1h 8m 42s ago.
14:45:59 <SamB> hmm?
14:46:05 <jethr0> do any of you see some kind of foldl or similar in this?
14:46:12 <jethr0> allDifferent' a b c = f [a,b,c]
14:46:14 <jethr0>     where f []     = True
14:46:15 <jethr0>           f (x:xs) = (all (x/=) xs) && f xs
14:46:40 <sorear> that's a fold on the tails
14:46:57 <glguy> > let allDifferent xs = and $ (zipWith (/=) `ap` tail) $ sort xs in allDifferent [1,2,3,4,5]
14:46:58 <lambdabot>  True
14:46:58 <jethr0> yes, so how'd that look?
14:47:02 <glguy> > let allDifferent xs = and $ (zipWith (/=) `ap` tail) $ sort xs in allDifferent [1,2,3,4,5,1]
14:47:03 <lambdabot>  False
14:47:09 <mbishop> SamB: playing with your ZMachine...or, trying to
14:47:20 <mbishop> it doesn't build, says it can't find Control.State.Monad
14:47:27 <jethr0> glguy: cool. thx
14:47:41 <SamB> mbishop: you mean Control.Monad.State?
14:47:50 <jethr0> that's list monad, right?
14:47:50 <mbishop> er yes
14:47:58 <SamB> maybe you need to install the extralibs?
14:48:14 <SamB> in particular the "mtl" package?
14:48:43 <jethr0> @hoogle ap
14:48:43 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
14:48:43 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
14:48:43 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
14:50:43 <jethr0> hmm, why doesn't this work?
14:50:52 <jethr0> > (zipWith (/=) `ap` tail) [1,2,3]
14:50:53 <lambdabot>  [True,True]
14:50:58 <newsham> > unsafePerformIO $ putStrLn "test"
14:50:59 <lambdabot>   Not in scope: `unsafePerformIO'
14:51:01 <jethr0> grr, my ghci does take it
14:51:38 <glguy> > let allDifferent = foldr (\x y -> (null x || head x `notElem` tail x) && y) True . tails in map allDifferent [[1,2,3,4,5],[1,2,3,4,5,1]]
14:51:40 <lambdabot>  [True,False]
14:51:50 <jethr0> No instance for (Monad ((->) [a]))
14:51:56 <Igloo> jethr0: :m + Control.Monad.Reader
14:51:59 <glguy> jethr0: that's because I used ap, either replace ap, or :m Control.Monad.Instances
14:52:09 <glguy> :m + rather
14:52:27 <jethr0> k, i have done a :m + Control.Monad already. but i'll try your suggestions
14:52:56 <mbishop> SamB: Hmm, that did seem to fix it, but now it complains about gtk, and trying to install libghc6-gtk-dev on debian gets angry (it wants < 6.4.2)
14:52:57 <glguy> > let allDifferent = foldr ((&&) . liftM2 (||) null (liftM2 notElem head tail)) True . tails in map allDifferent [[1,2,3,4,5],[1,2,3,4,5,1]]
14:52:58 <lambdabot>  [True,False]
14:53:14 <SamB> mbishop: you should probably just build your own
14:53:16 <jethr0> ahh, obfuscation
14:53:25 <mbishop> SamB: if I wasn't lazy, sure :P
14:54:10 * jethr0 doesn't quite understand what (zipWith (/=) `ap` tail) does. but then again i've never been on good terms with the reader monad
14:54:24 <glguy> > let allDifferent = all (\x -> null x || head x `notElem` tail x) . tails in map allDifferent [[1,2,3,4,5],[1,2,3,4,5,1]]
14:54:25 <lambdabot>  [True,False]
14:55:13 <sorear> it's not anything irreducibly monadic, it's exactly the Schoenfinkel S combinator
14:55:15 <glguy> jethr0: that last one with all is probably clearer than the fold
14:55:38 <jethr0> sure, but could you explain the reader monad thingy please?
14:55:47 <vincenz> .j oasis
14:55:57 <glguy> ap in reader is:  ap f g x = f x (g x)
14:56:02 <sorear> you mean @join ?
14:56:17 <vincenz> no
14:56:22 <vincenz> ./j
14:56:27 <vincenz> lambdabot is already there
14:56:29 <jethr0> ah, i forgot that again
14:56:31 <jethr0> thx
14:56:53 <jethr0> he meant "jethr0: @join" i think
14:57:04 <vincenz> no
14:57:05 <glguy> ap f g = do { a <- f; b <- g; return (a b) }
14:57:07 <vincenz> I typoed the . as /
14:57:22 <jethr0> oh :(
14:58:07 <glguy> ?src ap
14:58:07 <lambdabot> ap = liftM2 id
14:59:07 <glguy> ?type flip liftM2 id -- exactly the same in the reader monad, but specifically typed :)
14:59:08 <lambdabot> forall a2 r a. (a -> a2 -> r) -> (a -> a2) -> a -> r
15:00:12 <vincenz> @arr
15:00:12 <lambdabot> Shiver me timbers!
15:00:31 <vincenz> nostrademons: ah nice :)
15:01:05 <nostrademons> ?
15:01:13 <vincenz> nostrademons: I liked reading your comment on reddit regarding implementations for continuations
15:01:24 <vincenz> cps vs stack-overflow vs heap-based
15:01:27 <glguy> jethr0: (=<<) is also useful in reader:  (=<<) f g x = f (g x) x
15:01:29 <nostrademons> ah.  that was a long time ago, I think
15:01:33 <vincenz> yeah
15:01:34 <vincenz> quite a bit
15:01:36 <nostrademons> I don't remember everything I write ;-)
15:01:38 <vincenz> but it was a good summary
15:01:39 <dons> re.
15:01:39 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
15:01:41 <vincenz> I know the feeling
15:02:08 <jethr0> glguy: i think i'll need a little practice until i'll be using reader monad more frequently. it can be kinda brain-hurting
15:02:11 <dons> I'm sitting opposite Phil Wadler in the lobby of the hotel here :)
15:02:13 <sorear> people are getting very @tell-happy
15:02:19 <nostrademons> wow.  lucky, dons
15:02:22 <dons> I wonder if he brought his lambdaman shirt
15:02:36 <dons> heay nostrademons !
15:02:57 <dons> haven't seen you here for a while?
15:03:06 <jethr0> @pl \xs -> zipWith (/=) xs $ tail xs
15:03:06 <lambdabot> ap (zipWith (/=)) tail
15:03:09 <nostrademons> hey.  been hacking
15:03:09 <dons> how's code? you're working on a new language?
15:03:12 <sorear> how frequently is blahblah/haskell-07.html updated?
15:03:12 <nostrademons> yeah
15:03:18 <nostrademons> think Haskell with Python syntax
15:03:28 <nostrademons> blog: http://eve-language.blogspot.com/
15:03:29 <lambdabot> Title: Growing a Language
15:03:33 <dons> doesn't haskell have a python syntax already? ;)
15:03:36 <nostrademons> code: http://sourceforge.net/projects/eve-language
15:03:37 <lambdabot> Title: SourceForge.net: Eve Programming Language
15:03:47 <dons> ah, so with a type system?
15:03:55 <nostrademons> yeah, going for static typing to start
15:03:57 <dons> good good
15:04:08 <nostrademons> and starting at the very beginning (i.e. pure Hindley-Milner, no typeclasses)
15:04:17 <dons> so you're hoping for some pugs/perl6 style rapid dev?
15:04:18 <nostrademons> my goal is to work up to something nicer than Haskell, if that's possible
15:04:25 <dons> get the basic system up running very soon?
15:04:30 <nostrademons> I wanna play around with Mark Jones's qualified types...
15:04:34 <nostrademons> well, it's runnable now
15:04:36 <nostrademons> it just doesn't do much
15:04:39 <dons> cool!
15:04:52 <nostrademons> it's like a calculator.  numbers & booleans, very simple lambda expressions, at a REPL
15:05:16 <nostrademons> working on adding modules so you can write libraries in files and import them
15:05:35 <nostrademons> also trying to extend the type system with lists and other parametric types
15:05:40 <nostrademons> (yeah, I started *really* basic)
15:05:44 <sorear> dons:
15:05:46 <dons> wow
15:05:52 <dons> nostrademons: so is it just you hacking away?
15:05:59 <nostrademons> yeah, at the moment
15:06:00 <sorear> @users
15:06:01 <lambdabot> Maximum users seen in #haskell: 311, currently: 298 (95.8%), active: 46 (15.4%)
15:06:05 <dons> mm
15:06:07 <dons> cool
15:06:10 <sorear> forgot the command there :)
15:06:21 <dons> nostrademons: maybe you should rss your blog to planet haskell
15:06:25 <dons> so we can keep up to date?
15:06:31 <dons> just email 'ibid'
15:06:51 <nostrademons> hmm. might be a good idea
15:07:00 <jethr0> nostrademons: so, what's gonna be better than in haskell?
15:07:04 <dons> your more likely to get patches
15:07:18 <dons> since haskell people will know what your up to
15:07:23 <dons> and you're writing in haskell, right?
15:07:30 <nostrademons> yeah, for a bootstrap interpreter
15:07:37 <nostrademons> eventually plan to write it in itself
15:07:37 <dons> yeah
15:07:45 <dons> yeah, like perl6... :)
15:07:46 <nostrademons> actually, my plan is to have it *only* be a standard library..
15:08:02 <nostrademons> so the standard library includes a lexer, parser, typechecker, evaluator, compiler backend
15:08:03 <dons> mm. interesting idea
15:08:06 <dons> yeah
15:08:13 <nostrademons> and then the compiler itself is just a one-line composition
15:08:24 <nostrademons> well, with things like getArgs and stuff for command-line handling
15:08:25 <glguy> what is CSP?
15:08:33 <nostrademons> Communicating Sequential Processes
15:08:37 <nostrademons> Erlang-stuff
15:11:16 <glguy> nostrademons: do you have a recommendation of a .eve file I could look at to see what you intend for this to look like?
15:11:28 <glguy> or should I just read through .evetest files?
15:11:49 <nostrademons> heh.  the .evetest files are basically REPL transcript sections
15:12:04 <nostrademons> check in attic2 in SVN, that may include some sample stuff before I started over
15:12:17 <dons> its not in darcs?
15:12:25 <nostrademons> hosted on Sourceforge
15:12:26 <dons> bad karma for a haskell project ;)
15:12:35 <nostrademons> yeah, I know, but SF was easy to begin with
15:12:38 <dons> boo on sourceforge
15:12:39 <dons> yeah
15:12:42 <nostrademons> and to my knowledge, they don't support Darcs
15:12:47 <dons> right
15:13:01 <dons> only cause we don't ask
15:13:02 <nostrademons> okay.  attic2 wasn't it...
15:13:14 <sorear> dons: while trying to understand @pl, I had the idea of factoring out an entire parse-desugar pipeline into Lib.Haskell.*.  share the code between @pl, @undo, etc.
15:13:16 <dons> is eve pure?
15:13:20 <nostrademons> yeah
15:13:22 <dons> sorear: hmm.
15:13:25 <dons> interesting
15:13:29 <nostrademons> plan to keep it pure at least until it's bootstrapped
15:13:41 <nostrademons> I can cheat, since the bootstrap interpreter exists only to bootstrap the compiler
15:13:42 <dons> heh
15:13:54 <nostrademons> so I bolt IO onto the host interpreter and just have it pass the program text
15:14:07 <nostrademons> there it was.  trunk/attic/examples
15:14:09 <dons> monadic IO?
15:14:15 <dons> or impure iio
15:14:29 <nostrademons> umm.  haven't decided yet
15:14:34 <nostrademons> leaning towards Erlang-style IO
15:14:39 <nostrademons> all IO devices are processes
15:14:40 <sorear> impure IO can be hidden in a monad, at least if your language is lazy
15:14:48 <nostrademons> you perform IO by sending messages to processes
15:14:50 <sorear> data IO a = IO a
15:15:03 <sorear> data IO a = IO (() -> a)
15:15:04 <nostrademons> now, something I'd love to investigate is whether message-sending fits in a monad
15:15:10 <glguy> nostrademons: with parentheses around function arugments, do you support currying?
15:15:25 <sorear> nostrademons:
15:15:30 <sorear> @where PiMonad
15:15:30 <lambdabot> I know nothing about pimonad.
15:15:37 <sorear> @goog PiMonad
15:15:40 <lambdabot> http://tsukimi.agusa.i.is.nagoya-u.ac.jp/~sydney/PiMonad/
15:15:40 <lambdabot> Title: PiMonad - a network programming framework based on Pi-Calculus
15:16:04 <nostrademons> glguy: yeah.  it's like Nemerle: you put a ? in the argument position to indicate you want to curry on that argument
15:16:19 <glguy> oh, cool
15:16:28 <nostrademons> so cons(2, ?) returns a function that adds 2 at the head of any list
15:16:31 <glguy> I've looked at Numerle, but not long enough to know that ? worked like that
15:16:39 <nostrademons> that part's actually one of the few features that are implemented
15:16:44 <nostrademons> Nemerle uses _ as the character
15:16:46 <glguy> nostrademons: so... cons(?,2) works?
15:16:51 <glguy> or only in the tail?
15:17:13 <nostrademons> well, cons doesn't work (in the present implementation), but if I had lists implemented...
15:17:13 <glguy> well, that's a bad example, since 2 doesn't fit there
15:17:16 <nostrademons> actually, it'd be a type error
15:17:19 <nostrademons> heh ;-)
15:17:20 <glguy> yeah
15:17:25 <glguy> but:   f(?,x)
15:17:25 <glguy> ?
15:17:29 <nostrademons> yeah
15:17:34 <nostrademons> you can curry any argument position
15:17:48 <nostrademons> that was something I found annoying about Haskell.  have to use flip too often
15:18:10 <glguy> f(?,x,?) -- it could start to lead to some weird results though :)
15:18:23 <dons> yeah, there's some well known weird things with ? :)
15:18:25 <jethr0> for binary functions i like the `function` idiom
15:18:27 <dons> (it was proposed recently)
15:18:40 <vincenz> nostrademons: btw, if you want, I have a rather generic monad for tying alex to happy
15:18:50 <nostrademons> f(?, x, ?) = {| _x, _y| f(_x, x, _y) }
15:18:52 <glguy> the other issue might be that your functions need to know how many arguments a function has i suppose
15:18:57 <nostrademons> where the lambda notation is stolen from Ruby
15:19:01 <vincenz> nostrademons: including source-loc
15:19:03 <nostrademons> which stole it from Smalltalk
15:19:04 <glguy> f g = g x
15:19:04 <mgsloan> imho, `foo` syntax should work for all -arity functions
15:19:09 <glguy> that would be harder to implement
15:19:13 <mgsloan> and be kinda like method syntax
15:19:23 <nostrademons> how would it work on arity > 2 functions?
15:19:53 <mgsloan> (+) `foldr`0 [1,2..10]
15:20:05 <glguy> ( (+) `f` 0 ) xs
15:20:18 <nostrademons> vincenz: oh, interesting.  I think that it's working reasonably well now, but I wouldn't mind seeing it, in case it's applicable for something I wanna do later (like maybe better error reporting)
15:20:20 <paolino> @pl\ \a f b c g -> do {a <- f b;let c = g a;return c}
15:20:21 <lambdabot> (line 1, column 18):
15:20:21 <lambdabot> unexpected "{"
15:20:21 <lambdabot> expecting variable, "(", operator or end of input
15:20:31 <glguy> paolino: let { x = y}
15:20:41 <mgsloan> > ((+) `foldr`0) [1,2..10]
15:20:42 <lambdabot>  55
15:20:46 <mgsloan> hah
15:20:52 <vincenz> nostrademons: alright, I'll clean it up tomorrow
15:20:56 <jethr0> @. pl undo \a f b c g -> do {a <- f b;let c = g a;return c}
15:20:56 <lambdabot> (line 1, column 21):
15:20:56 <vincenz> (bit late atm)
15:20:56 <lambdabot> unexpected "{"
15:20:56 <lambdabot> expecting variable, "(", operator or ")"
15:21:04 <mgsloan> > (+) `foldr`0 [1,2..10]
15:21:04 <lambdabot>   add an instance declaration for (Num ([a] -> b))
15:21:05 <glguy> jethr0: let { x = y }
15:21:09 <sorear> @fixity 11 `foldr`
15:21:09 <lambdabot> Unknown command, try @list
15:21:13 <glguy> paolino, jethr0: emphasis on the {}
15:21:27 <nostrademons> sorear: thanks, I'll try to check out PiMonad when I get a chance
15:21:28 * sorear cranks the fixity to 11
15:21:29 <jethr0> yes, i though it was a problem with do
15:21:32 <nostrademons> hah
15:21:41 <glguy> @. pl undo \a f b c g -> do {a <- f b;let {c = g a};return c}
15:21:41 <lambdabot> (line 1, column 35):
15:21:41 <lambdabot> unexpected "{"
15:21:41 <lambdabot> expecting natural, identifier or "in"
15:22:03 <glguy> ?undo do {a <- f b;let {c = g a};return c}
15:22:03 <lambdabot> f b >>= \ a -> let { c = g a} in return c
15:22:08 <mgsloan> here at haskell, our fixity knobs go all the way to 11
15:22:11 <nostrademons> that really needs to be an easter egg in any language that supports user-defined fixities...
15:22:18 <glguy> 11 is louder than 10!
15:22:27 <nostrademons> maybe it should make the function spontaneously combust!
15:23:18 <glguy> is PiMonad something that could be used in "stable" code?
15:23:23 <paolino> glguy how is that different from { f b >>= liftM g} ?
15:23:25 <glguy> or is it a proof of concept sort of thing
15:23:28 <jethr0> markup boldness should depend on fixity and 11 should then blink :)
15:23:41 <vincenz> evening bringert
15:23:52 <bringert> hi
15:23:54 <glguy> paolino: what you wrote is: liftM g (f b)
15:24:39 <glguy> :t \f g b -> liftM g (f b)
15:24:41 <lambdabot> forall a1 r (m :: * -> *) t. (Monad m) => (t -> m a1) -> (a1 -> r) -> t -> m r
15:24:48 <glguy> :t \f g b -> f b >>= liftM g
15:24:50 <lambdabot> forall t (m :: * -> *) a1 r. (Monad m) => (t -> m (m a1)) -> (a1 -> r) -> t -> m r
15:25:42 <paolino> so there is no way I can take off that let c = g a ?
15:26:46 <glguy> paolino: what is your original question
15:27:22 <paolino> cleaning  a <- f b;let {c = g a};return c
15:27:24 <glguy> you want: do { a <- f b; return (g a) } ?
15:27:33 <glguy> or     liftM g (f b) ?
15:28:07 <glguy> or... do { a <- liftM g (f b); return a } ??
15:28:26 <glguy> (all of those are equivalent)
15:28:45 <paolino> ah
15:29:29 <paolino> ok, I mumble  a bit
15:30:49 <vincenz> nostrademons: ping
15:31:20 <vincenz> nostrademons: for the lexer, what I tend to do is have two very  generic rules, one for function-names, and one for operator regexps
15:31:46 <vincenz> nostrademons: and then I keep my lexer ultra portable and instead have a lookup table that maps specific names to either std operators or keywords, and have as default return value "identifier"
15:31:57 <paolino> csn <- liftM (take ap) $ collect i >>= choice i
15:31:58 <paolino> this looks haskell
15:32:01 <vincenz> or "generic operator"
15:32:18 <paolino> and compile ;)
15:33:44 <nostrademons> vincenz: yeah, I did that in a previous language (Ambrosia, which I never did put up).  mostly it's this way because Eve started with like 3 keywords and then I got careless and forgot to refactor.  I'll fix it sometime
15:33:48 <mgsloan> vincenz - that's what haskell does, i think
15:34:13 <vincenz> discussion moving to -> #oasis
15:34:36 <mgsloan> what's that/
15:35:00 <vincenz> a pl-agnostic pl-discussion channel
15:35:01 <mgsloan> nostrademons: partially ordered operator precedence :P
15:35:08 <mgsloan> oh, coolio
15:44:38 <paolino> also this I cannot simpilfy :/
15:44:39 <paolino> do td <- asks $ take.unKPath
15:44:39 <paolino>      liftM td $ gets aperture >>= stream
15:46:06 <monologue> Already simplest.
15:46:51 <glguy> ?pl asks (take . unKPath) >>= \td -> liftM td (gets aperture >>= stream)
15:46:51 <lambdabot> asks (take . unKPath) `ap` (stream =<< gets aperture)
15:47:28 <paolino> :t ap
15:47:29 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
15:48:48 <jethr0> @pl fromEnum x - fromEnum '0'
15:48:48 <lambdabot> fromEnum x - fromEnum '0'
15:49:16 <glguy> (- fromEnum '0') . fromEnum
15:49:25 <glguy> ?pl \x -> fromEnum x - fromEnum '0'
15:49:25 <lambdabot> subtract (fromEnum '0') . fromEnum
15:49:37 <glguy> ah, yeah (-  ... ) doesn't do subtraction
15:49:43 <jethr0> i was thinking sth like "liftM2 (-) fromEnum x 0", but it's not good for my brain
15:50:07 <jethr0> and wouldn't be shorter
15:50:08 <glguy> liftM2 (-) (const (fromEnum '0')) fromEnum 0
15:50:16 <glguy> if you wanted liftM2
15:50:23 <jethr0> hehe
15:50:33 <glguy> where the last 0 is x
15:51:41 <glguy> ?pl \ f g x y -> g x `f` g y
15:51:41 <lambdabot> join . ((flip . ((.) .)) .) . (.)
15:51:45 <huschi_> ?src subtract
15:51:45 <lambdabot> subtract x y = y - x
15:51:46 <glguy> or:
15:51:59 <glguy> (join . ((flip . ((.) .)) .) . (.)) (-) fromEnum '0' x
15:52:17 <jethr0> yup, another example why it's called pointLESS and not pointFREE
15:54:34 <huschi_> programing in haskell seems a bit frustrating. i'm missing searching for errors :(
15:55:08 <glguy> try using fewer explicit type declarations
15:55:15 <bd_> huschi_: Use Dynamic liberally :)
15:55:16 <sorear> @remember huschi_ programing in haskell seems a bit frustrating. i'm missing searching for errors :(
15:55:16 <lambdabot> Done memoising quote for `huschi_', if that is their real name...
15:55:21 <emu> more unsafePerformIO!
15:55:28 <bd_> unsafeCoerce ftw
15:55:30 <sorear> unsafePerformIO is for wimps
15:55:34 <bd_> or GHC.Prim.raise#
15:55:45 <bd_> that's a fun one
15:55:54 <sorear> use unsafeAt etc
15:56:12 <sorear> get hs-plugins and use eval liberally
15:56:13 <huschi_> i'm also using unsafePerformIO for memoizing. but no errors want to show up.
15:56:34 <bd_> sorear: unsafeAt?
15:56:48 <huschi_> @hoogle unsafeAt
15:56:48 <lambdabot> No matches found
15:57:15 <glguy> it array indexing without bounds checking
15:57:16 <sorear> I forget exactly what it's called
15:57:18 <glguy> it is
15:57:29 <glguy> yes? no?
15:57:35 <sorear> yes
15:57:52 <bd_> ah
15:58:10 <mbishop> it's called C
15:58:11 * mbishop hides
15:58:44 <huschi_> oh no, my remembered quote has a typo: programing with only one m.
15:58:54 <sorear> don't worry
15:58:55 <bd_> I don't know, raise# seems to more reliably segfault. I mean, with unsafeAt, you might occasionally hit a safe index.
15:59:03 <sorear> @quote orbitz
15:59:03 <lambdabot> orbitz says: i don't know what the problem is, i'm typing fine, all you crazies are hiting the wron gbuttons everywhere
15:59:12 <sorear> @quote quazimodo
15:59:12 <lambdabot> No quotes match. My pet ferret can type better than you!
15:59:34 <sorear> we have plenty of habitually bad typists here
15:59:45 <sorear> so many I was driven to write:
15:59:49 <sorear> @help nazi-on
15:59:49 <orbitz> i'm th eonly one taht seem to be abel to really type
15:59:49 <lambdabot> spell <word>. Show spelling of word
16:00:01 <emu> perhaps we need static typing checking
16:00:14 <glguy> I hope to one day be important enough to need a bluetooth cell phone headset on at all times
16:00:22 <sorear> funny, I forgot the help :(
16:00:26 <sorear> @nazi-on
16:00:26 <lambdabot> Spelling nazi engaged.
16:00:32 <sorear> Be very careful
16:00:46 <huschi_> who's the spelling nazi?
16:00:47 <lambdabot> Did you mean Nazi, Nazis, Nani, Nari or NZ?
16:00:47 <emu> it's wabbit season?
16:00:51 <sorear> @nazi-off
16:00:52 <lambdabot> Spelling nazi disengaged.
16:01:09 <nostrademons> clearly, he meant the spelling NZ
16:01:12 <syntaxfree> whoa.
16:01:15 <nostrademons> beautiful country
16:01:28 <glguy> sorear: @uber-nazi-on (it kicks you instead of correcting you)
16:02:00 <sorear> glguy: would be nice, but the 'bot isn't an op here.
16:02:13 <glguy> and that command doesn't exist, but both could change ;)
16:02:16 <koala_man> what's the difference between Int and Integer?
16:02:24 <huschi_> in germany where i live nazis are also doing gramatic errors on their banners on their demonstrations.
16:02:25 <sorear> Integer is unbounded
16:02:26 <bd_> koala_man: Integer is unbounded
16:02:36 <syntaxfree> http://blog.moertel.com/articles/2005/03/25/writing-a-simple-ruby-evaluator-in-haskell
16:02:39 <lambdabot> Title: Writing a simple Ruby evaluator in Haskell, http://tinyurl.com/yzhgp7
16:02:41 <syntaxfree> whoa.,
16:02:44 <glguy> Int uses the hardwares native int type
16:02:55 <koala_man> how do I convert from one to the other?
16:03:01 <sorear> fromIntegral
16:03:09 <jethr0> > fromIntegral (4::Int) :: Integer
16:03:10 <lambdabot>  4
16:03:10 <glguy> so a 32-bit and 64-bit processor will hae different upper and lower boundson Int
16:03:26 <sorear> Int is required to have at least 29 bits
16:03:43 <sorear> so if you use numbers smaller than 256 million, Int is safe
16:03:46 <jethr0> any idea why 29?
16:03:54 <SamB> hmm?
16:03:57 <SamB> 29?
16:03:58 <sorear> leave room for tag bits, I guess
16:04:02 <SamB> are you sure it isn't 30 bits?
16:04:04 <bd_> hm, is darcs.haskell.org down?
16:04:05 <Stinger_> nostrademons yeah but its not too good to visit cause of the civil war
16:04:10 <sorear> maybe it is 30
16:04:19 <SamB> perhaps you forgot to include the sign bit?
16:04:20 <olliej> sorear: 29 sounds familiar
16:04:22 <sorear> I haven't memorized the report recently
16:04:29 <bd_> The finite-precision integer type Int covers at least the range [ - 229, 229 - 1].
16:04:32 <bd_> er
16:04:35 <bd_> 2^29
16:04:47 <SamB> see?
16:04:50 <SamB> sign bit ;-)
16:04:50 <sorear> ah, tat's a 30-bit range
16:04:56 * sorear is wrong
16:05:07 <olliej> bd_: -229 vs. -2^29 -- a negligible difference :D
16:05:21 <glguy> > showIntAtBase 2 intToDigit (maxBound :: Int) ""
16:05:22 <lambdabot>  "1111111111111111111111111111111"
16:05:31 <sorear> > length it
16:05:32 <lambdabot>   Not in scope: `it'
16:05:38 <sorear> awww
16:05:40 <olliej> > length $ showIntAtBase 2 intToDigit (maxBound :: Int) ""
16:05:41 <glguy> > ap (,) length $ showIntAtBase 2 intToDigit (maxBound :: Int) ""
16:05:42 <lambdabot>  31
16:05:42 <lambdabot>  ("1111111111111111111111111111111",31)
16:05:51 * sorear hides
16:06:05 <SamB> why hideth thou?
16:06:15 <Anon4888> So it's 1 bit to flag overflow
16:06:15 <sorear> pl-crazies
16:06:27 * SamB speaks archaic yoda ;-)
16:06:32 <olliej> sorear: :D
16:06:47 <huschi_> Anon4888: the 32nd bit is for the sign
16:06:49 <jethr0> Anon4888: wouldn't that rather be sign?
16:06:54 <glguy> pointfree code is a matter of life and death when you are trying to get your version out there before the other guy ;)
16:07:16 <Anon4888> Ints in haskell are modulo 2^32?
16:07:19 <olliej> > length $ showIntAtBase 2 intToDigit (minBound :: Int) ""
16:07:20 <lambdabot>  Exception: Numeric.showIntAtBase: applied to negative number -2147483648
16:07:24 <olliej> :(
16:07:31 <emk> Does Haskell have a standard "split" operator that can split a sequence on a specified element, or on elements matching a predicate?
16:07:33 <glguy> > ap (,) length $ showIntAtBase 2 intToDigit (- minBound :: Int) ""
16:07:35 <lambdabot>  Exception: Numeric.showIntAtBase: applied to negative number -2147483648
16:07:38 <emk> Hoogle is not being helpful.
16:07:40 <mgsloan> > maxBound :: Int + 1
16:07:41 <lambdabot>  Parse error
16:07:45 <sorear> Anon4888:  not necessarily
16:07:59 <Cale> emk: span, break
16:08:00 <mgsloan> > (maxBound :: Int) + 1
16:08:01 <lambdabot>  -2147483648
16:08:02 <olliej> glguy: isn't -min int == min int?
16:08:05 <jethr0> Anon4888: more or less, they are modulo 2^(machine width). that's what Integer is for
16:08:15 <Anon4888> What about Int?
16:08:22 <glguy> olliej: yeah
16:08:24 <Anon4888> Is there a difference between Int and Integer?
16:08:29 <olliej> Anon4888: yes
16:08:35 <huschi_> Anon4888: Integer is unbounded.
16:08:38 <olliej> Integer is arbitrary precision
16:08:39 <mbishop> Integers have arbitrary precision
16:08:40 <Anon4888> ok thx
16:08:54 <Anon4888> Reading about too many languages at once ... they get jumbled :)
16:09:09 <glguy> > ap (,) length $ showIntAtBase 2 intToDigit (- ((minBound :: Int) + 1)) ""
16:09:10 <lambdabot>  ("1111111111111111111111111111111",31)
16:09:16 <bd_> well, on my system anyway Integers are limited to something on the order of 256^(2^30) :)
16:09:31 <sorear> The results of exceptional conditions (such as overflow or underflow) on the fixed-precision numeric types are undefined;
16:09:37 <mgsloan> > abs (minBound :: Int)
16:09:38 <lambdabot>  -2147483648
16:09:44 <mgsloan> read em and weep
16:09:53 <sorear> an implementation may choose error (_|_, semantically), a truncated value, or a special value such as infinity, indefinite,
16:09:56 <Anon4888> bd_, have you verified this?
16:09:56 <sorear> etc
16:10:12 <koala_man> how do I get a line number out of "Program error: pattern match failure: step_v1565 instOrd_v29 9 9 instNum_v32 instNum_v32 4"?
16:10:16 <sorear> in other words, maxBound + 1 isn't specified.
16:10:24 <mgsloan> look at my LB interaction very carefully  ^
16:10:33 <mbishop> I think the standard says Int has to be at least 2^29
16:10:37 <bd_> Anon4888: Well, any more and it'll run out of address space :)
16:10:39 <mbishop> or something like that
16:10:45 <sorear> koala_man: that kind of symbol comes from happy, look in your .y files
16:10:47 <jethr0> mbishop: 2^29 + sign bit
16:11:07 <koala_man> sorear: from whatnow?
16:11:31 <sorear> you were'nt using happy? oh...
16:11:37 <koala_man> it's from hugs
16:12:01 <sorear> well turn on -Wall and look at all the places it mentions refutable patterns
16:12:02 <Anon4888> bd_: true
16:12:25 <emk> Cale: Ah, thanks! Those will be good building blocks.
16:12:37 <mgsloan> > sgn $ abs $ minBound :: Int
16:12:38 <lambdabot>   Not in scope: `sgn'
16:12:44 <glguy> signum?
16:12:50 <koala_man> I must say I kind of miss exception stack traces
16:12:57 <mgsloan> > abs $ minBound :: Int
16:12:58 <lambdabot>  -2147483648
16:13:06 <sorear> Integers are limited to 2^32^(2^32)
16:13:07 <jethr0> hehe
16:13:25 <glguy> koala_man: the kind you get when you surrender to eager evaluation of your arguments?
16:13:25 <sorear> because data Integer = J# Int ByteArr#
16:13:32 <mgsloan> only number to ever have a negative absolute value...
16:14:03 <jethr0> @free abs
16:14:04 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Num a) => a -> a\n"
16:14:20 <koala_man> glguy: yes
16:14:54 <Anon4888> @type Nat
16:14:55 <lambdabot> Not in scope: data constructor `Nat'
16:15:01 <Anon4888> Does haskell have an unsigned type?
16:15:09 <syntaxfree> You can't have a function called "do", right?
16:15:21 <Anon4888> @src Nat
16:15:21 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
16:15:22 <mgsloan> @let do = 4
16:15:22 <lambdabot>  Parse error
16:15:26 <mgsloan> i guess not
16:15:29 <bd_> Anon4888: Data.Word has some
16:15:45 <bd_> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
16:15:47 <lambdabot> http://tinyurl.com/y2v567
16:15:59 <mgsloan> Anon4888: there's C-equivalent data types
16:16:27 <Anon4888> Ok, but it doesn't have an unbounded Natural type?
16:16:34 <Anon4888> Thanks
16:16:56 <jethr0> if only it did and the prelude functions used it...
16:17:09 <bd_> @hoogle Natural
16:17:10 <lambdabot> Text.ParserCombinators.Parsec.Token.natural :: TokenParser st -> CharParser st Integer
16:17:10 <lambdabot> Text.ParserCombinators.Parsec.Token.naturalOrFloat :: TokenParser st -> CharParser st (Either Integer Double)
16:17:19 <bd_> what typeclass are you referring to?
16:17:36 <mgsloan> data Nat = Succ Nat | Zero
16:17:39 <mgsloan> there ya goo
16:18:01 <bd_> data Nat = Zero | Succ NAt deriving (Enum, Ord, Eq)
16:18:05 <bd_> :)
16:18:19 <mgsloan> hmm, does Ord work right for that?
16:18:28 <mgsloan> same for enum..
16:18:33 <jethr0> Succ a > Zero
16:18:43 <sorear> data Nat = One | TwoX Nat | TwoXP1 Nat
16:18:55 <mgsloan> Succ  (Succ Zero) > Succ Zero ?
16:19:05 <sorear> == Succ Zero > Zero
16:19:06 <jethr0> nope
16:19:10 <sorear> == True
16:19:37 <bd_> mgsloan: Hmm
16:19:38 <bd_>     Can't make a derived instance of `Enum Nat'
16:19:40 <bd_>       (`Nat' has non-nullary constructors)
16:19:44 <jethr0> mgsloan: the automatically derived instances only operators only work on the "first layer" constructors
16:19:51 <mgsloan> ah, yeah, enum makes no sense
16:20:20 <Anon4888> sorear: Nats start at 0 :)
16:21:00 <mgsloan> see, this is why LB (and ghci in general) needs declarations - so we can mess with this
16:21:17 <sorear> mgsloan: that wouldn't be hard to add
16:21:20 <bd_> Ord works at least
16:21:24 <cjeris> @pl \x -> (f x) >> (g x)
16:21:24 <lambdabot> liftM2 (>>) f g
16:21:26 <jethr0> Anon4888: there's some debate about that. at least in my math lectures different profs would be using N/{0} and N+{0}
16:21:46 <cjeris> jethro: some of them are wrong :D
16:21:49 <sorear> Actually my Nat is a monoid
16:21:58 <monologue> I have a cheap plan for adding declarations to ghci
16:22:05 <sorear> monologue: eh?
16:22:10 <Anon4888> jethr: I've never encountered that debate :)
16:22:17 <jethr0> monologue: well, declarations work inside "let" anyways
16:22:19 <sorear> monologue: cheaper than how runplugs does it
16:22:20 <sorear> ?
16:22:35 <monologue> using the ghc api, you could mimic ghci and more, since you're using the same tools ghci uses
16:22:59 <jethr0> Anon4888: i think in algebra 0 was part of the nats and in analysis it wasn't. but i was never the most proficient mathematician so...
16:23:40 <jethr0> > let {f :: Int -> Bool; f = (<4)} in f 5
16:23:41 <lambdabot>  False
16:24:00 <huschi_> is it possible to annotate a function so that is doesn't produce errors with -Wall?
16:24:12 <monologue> So, we do that.  We use the ghc api to write a ghci clone.  We add this functionality.  We maintain an internal .hs file.  Every time you type in a declaration, the clone adds it to the internal .hs file, and reload it.
16:24:40 <Anon4888> jethr: Wikipedia agrees with you... Notes that counting typically starts at 1 in number theory
16:24:43 <Lemmih> huschi_: Yes, put '{-' before it and '-}' after it.
16:24:43 <sorear> monologue: that's exactly how ?let works
16:24:50 <Anon4888> Not sure how I missed that :)
16:24:54 <huschi_> Lemmih: :)
16:25:02 <jethr0> monologue: are you aware of hs-plugins
16:25:05 <mgsloan> well, this is CS, counting starts at 0
16:25:17 <sorear> huschi_: put {-# OPTIONS_GHC -w #-} at the beginning of the file
16:25:18 <monologue> I am too dumb to learn hs-plugins
16:25:32 <sorear> monologue: please stop feeding my ego
16:25:50 <jethr0> @let f :: Int
16:25:50 <lambdabot> <local>:2:0: Not in scope: `f'
16:25:51 <huschi_> sorear: that is for the file?
16:25:56 <monologue> I am the smartest computer in the world.
16:25:58 <sorear> huschi_: yes :(
16:26:53 <sorear> monologue: lambdabot keeps a State/L.hs file. ?let appends text to the file. > does runplugs 'import L ; foo'
16:28:39 <monologue> someone can dig into the ghc api and contrive a way to avoid a file altogether
16:28:57 * jethr0 votes for monologue
16:29:11 <monologue> such a method is more suitable for running ghci on a cell phone
16:29:37 <mgsloan> yeah, someone needs to
16:30:12 <monologue> but since no one plans to run ghci on a cell phone for the next ten years, there is no rush :)
16:33:10 <allbery_b> hm.  the N800 strikes me as not being too far off from running it :)
16:33:31 <SamB> allbery_b: it is a bit tricky to type on those tiny pads...
16:40:25 <dgriffi3> i thought that the N800 didn't have a keypad
16:41:19 <adaptable> Touchscreen keypad...
16:45:41 <jethr0> which do you think is faster? using "foldl (\a b -> a++[b])" or "reverse $ foldl (\a b -> b:a)"?
16:46:09 <jethr0> independently of using foldr
16:46:39 <huschi_> jethr0: the second one.
16:46:46 <sjanssen> the first is O(n^2)
16:46:50 <newsham> ?vixen
16:46:50 <lambdabot> <undefined>
16:46:56 <newsham> ?vixen
16:46:57 <lambdabot> <undefined>
16:47:01 <sorear> newsham: dons killed it
16:47:02 <jethr0> @vixen what's your name
16:47:03 <lambdabot> <undefined>
16:47:09 <jethr0> she's broken
16:47:10 <sorear> newsham: blame the hackathon
16:47:20 <newsham> ?fact hackathon
16:47:20 <lambdabot> I know nothing about hackathon
16:47:29 <seliopou> @hoogle (=:=)
16:47:29 <lambdabot> Did you mean: (=:=)
16:47:30 <lambdabot> Prelude.undefined :: a
16:47:30 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
16:47:40 <sorear> newsham: they incompatibly changed the regex format when they switched to the new binary
16:47:55 <sorear> newsham: dons had to delete vixen's brain
16:47:59 <glguy> ?version
16:48:00 <lambdabot> lambdabot 4p469, GHC 6.5 (OpenBSD i386)
16:48:00 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
16:48:01 <jethr0>  let @hoogle f = "Did you mean: " ++ f
16:48:22 <glguy> so what was accomplished at the hackathon?
16:48:26 <jethr0> oohh? poor vixen
16:48:39 <sorear> glguy:
16:48:40 <sorear> @seen
16:48:41 <lambdabot> Lately, I have seen adaptable, dgriffi3, glguy, huschi_, jethr0, mbishop, mgsloan, newsham, pkhuong, riastradh, seliopou, sjanssen and sorear.
16:48:48 <sorear> @slap me
16:48:48 * lambdabot beats up sorear
16:48:52 <sorear> @users
16:48:52 <lambdabot> Maximum users seen in #haskell: 311, currently: 282 (90.7%), active: 42 (14.9%)
16:49:02 <glguy> ?losers
16:49:02 <lambdabot> Maximum users seen in #haskell: 311, currently: 282 (90.7%), active: 42 (14.9%)
16:49:09 <sorear> 311 - they changed the seen format too!
16:49:30 <jethr0> @paste
16:49:30 <lambdabot> http://paste.lisp.org/new/haskell
16:49:39 <glguy> did they have any luck with hs-plugins and 6.6?
16:49:45 <sorear> no
16:50:18 <jethr0> lisp-paste is down again
16:50:24 <glguy> surprise!
16:51:27 <jethr0> which do you prefer?
16:51:36 <jethr0> uniq []     = []
16:51:36 <glguy> lisp paste
16:51:38 <jethr0> uniq (x:xs) = x:uniq (filter (x/=) xs)
16:51:39 <jethr0> uniq' xs = reverse $ foldl f [] xs
16:51:39 <glguy> oh
16:51:41 <jethr0>     where f a b = if b `elem` a then a else b:a
16:51:53 <mbishop> lambdabot: you shut your whore mouth!
16:52:03 <sorear> jethr0: I prefer:
16:52:08 <sorear> uniq = nub
16:52:13 <jethr0> obviously
16:52:15 <glguy> map head . group . sort
16:52:39 <jethr0> glguy: that does something completely different
16:52:51 <glguy> well... your two functions do different things too
16:52:52 <seliopou> @hoogle local
16:52:53 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
16:52:53 <lambdabot> Distribution.Simple.Configure.localBuildInfoFile :: FilePath
16:52:53 <lambdabot> Distribution.Simple.GHCPackageConfig.localPackageConfig :: IO FilePath
16:52:54 <jethr0> sorear: i'm doing all the exercises in "craft of functional programming"
16:52:59 <glguy> jethr0: so pick the one that does what you want
16:53:09 * jethr0 thinks they both do the same
16:53:17 <sorear> they don't
16:53:25 <newsham> > nub "removes a lot of useful information"
16:53:25 <jethr0> why not?
16:53:25 <glguy> OH
16:53:26 <lambdabot>  "removs altfuin"
16:53:28 <glguy> the reverse
16:53:32 <sorear> uniq picks the first equivalent object
16:53:40 <sorear> uniq' picks the last equivalent object
16:54:01 <newsham> uniq' = reverse.uniq.reverse ?
16:54:02 <sorear> by order of the High 98, nub takes the first
16:54:03 <jethr0> k, would using foldr help?
16:54:07 <sorear> newsham: yes
16:54:20 <sorear> jethr0: no
16:54:35 <sorear> jethr0: what I just said is true iff you use foldr
16:54:52 <sorear> jethr0: since you used foldl I was wrong and uniq == uniq'
16:54:58 * jethr0 doesn't understand.
16:55:00 <jethr0> hehe
16:55:01 <newsham> > (reverse.nub.reverse) "removes a lot of useful information"
16:55:02 <lambdabot>  "vseul frmation"
16:55:31 <jethr0> nub seems to take from the tail as well
16:55:54 <Anon4888> @src nub
16:55:55 <lambdabot> nub = nubBy (==)
16:55:55 <newsham> > nub "abcdefedcba"
16:55:55 * allbery_b was amused to misread the numb result as "removes all the fun"...
16:55:56 <lambdabot>  "abcdef"
16:56:05 <Anon4888> @src nubBy
16:56:05 <lambdabot> nubBy eq []             =  []
16:56:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
16:56:07 <jethr0> hahaha
16:56:13 <newsham> > (reverse.nub.reverse) "abcdefedcba"
16:56:14 <lambdabot>  "fedcba"
16:56:39 <jethr0> ah, you were double reversing before. k
16:57:13 <jethr0> so, which of the two version do you prefer. the supposed library code uses variant a. but then again using folds is supposed to be better than explicit recursion...
16:57:28 <newsham> > backwards f = reverse.f.reverse in backwards nub "abcdefedcba"
16:57:29 <lambdabot>  Parse error
16:57:50 <jethr0> let
16:57:52 <sorear> > (map fst . filter (not . uncurry elem) . ap zip (tail . tails)) "removes a lot of useful information"
16:57:53 <lambdabot>  "vseul frmation"
16:58:16 <newsham> sorear: much more intuitive
16:58:49 <jethr0> yup, "self-explanatory" is the term i'd use
16:59:50 <Anon4888> @src zip
16:59:50 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
16:59:50 <lambdabot> zip _      _      = []
17:00:02 <Saizan> well it's quite simple this tipe
17:00:03 * sorear hopes newsham and jethr0 were kidding
17:00:17 <Saizan> time
17:00:40 <pbx> (Is there an equivalent to lambdabot's '@src' in either ghci or hugs?)
17:00:58 <pbx> Hm, :info in ghci?
17:01:04 <sorear> cd lambdabot
17:01:05 <sorear> ghci
17:01:09 <sorear> :l Main
17:01:15 <sorear> online ["src"]
17:01:17 <sorear> :)
17:01:43 <monologue> No, src is special to lambdabot
17:04:31 <newsham> methinks it would be nice if lambdabot utils were split into String -> String utils and IrcMessage -> LB () (or whatever the return type is) commands
17:04:46 <syntaxfree> 10:53 PM  allbery_b was amused to misread the numb result as "removes all the fun"...
17:04:56 <syntaxfree> That's Common Lisp you're thinking of.
17:05:28 <newsham> thpeaking with an uncommon lithp
17:05:55 <jcreigh> isn't there a joke programming language named "LITHP"?
17:06:00 <sorear> yes
17:06:03 <newsham> yeth?
17:06:05 <nornagon> heh.
17:06:11 <sorear> @goog lesser known programming languages
17:06:14 <lambdabot> http://www.physics.uwo.ca/~harwood/humor10.html
17:06:14 <lambdabot> Title: The lesser known programming languages.
17:06:36 <ihope> "Find the type error in the following Haskell expression: if null xs then tail xs else xs" http://www.e-pig.org/downloads/epigram-notes.pdf
17:06:51 <nornagon> tail [] == ?
17:06:51 <ihope> I find myself suddenly liking Epigram.
17:07:06 <newsham> > tail []
17:07:07 <lambdabot>  Add a type signature
17:07:13 <newsham> > tail [] :: [Int]
17:07:14 <lambdabot>  Exception: Prelude.tail: empty list
17:07:23 <jcreigh> there isn't any type error, is there? It would just blow up at runtime, right?
17:07:29 <newsham> yup
17:07:32 <glguy> ihope: that technically istn't a type error though...
17:07:36 <jethr0> "In fact, the language generally requires more C- statements than machine-code statements to execute a given task." :)
17:07:42 <nornagon> > if null [] then tail [] else []
17:07:43 <lambdabot>  Add a type signature
17:07:52 <nornagon> > if null [1] then tail [1] else [1]
17:07:53 <lambdabot>  [1]
17:08:00 <nornagon> no type error.
17:08:02 <ihope> Apparently that's a type error in Epigram, or something.
17:08:08 <jethr0> epigram is great, but i still have to get myself to like 2d editing
17:08:28 <monologue> "type" is multi-valued
17:08:29 <glguy> the data type declarations are 2d, but the bulk of the language didn't seem to be
17:08:31 <jethr0> glguy: depends how far your definition of type goes. in dependent typing that could well be a type error
17:08:44 <jethr0> > if null [] then tail [] else []
17:08:44 <glguy> jethr0: sure, but they said "Haskell expression"
17:08:44 <lambdabot>  Add a type signature
17:08:54 <glguy> jethr0: and types in Haskell are defined a certain way
17:08:57 <newsham> > do { x <- tail []; let y = 3; return (x+y) } :: Maybe Int
17:08:57 <lambdabot>  Parse error
17:09:11 <monologue> Oh haha, then that's cheap.
17:09:17 <jethr0> tail is a stupid partial function, but i agree, i overread the "haskell expression" part
17:09:34 <glguy> newsham: you might need: let { y = 3}
17:09:53 <monologue> "find the type error in the following Perl code: x = "1" + 2 "   hahaha that will start a whole flame war
17:09:55 <newsham> > do { x <- return $ tail []; let {y = 3}; return (x+y) } :: Maybe Int
17:09:55 <lambdabot>  Couldn't match `Int' against `[a]'
17:10:14 <newsham> > do { x <- return $ tail []; let {y = 3}; return (head x+y) } :: Maybe Int
17:10:16 <lambdabot>  Exception: Prelude.tail: empty list
17:10:36 <ihope> Well, supposedly there's some way to actually run Epigram stuff.
17:10:41 <ihope> An interpreter, maybe.
17:10:43 <glguy> monologue: in perl's type system, that's not a type error :)
17:10:44 <glguy> right?
17:10:51 <ihope> Does Perl have a type system?
17:10:57 <ihope> :-)
17:10:57 <sorear> perl has dynamic types
17:10:59 <newsham> > do { let {x=head[]}; let {y = 3}; return (x+y) } :: Maybe Int
17:11:00 <lambdabot>  Exception: Prelude.head: empty list
17:11:05 <jethr0> ihope: yes there is even an editor for it AFAIR
17:11:07 <sorear> haskell has dynamic dependant types
17:11:21 <sorear> tail [] is a runtime type error
17:11:44 <newsham> hrmm.. isnt there a way to have the failing operation indicate Nothing to the Maybe do-block?
17:11:50 <sorear> yes
17:11:51 <Anon4888> "dynamic dependant types"?
17:11:55 <glguy> sorear: rather than just a runtime error?
17:11:57 <jcreigh> It seems like tail (and, eg, fromJust) are cases of "Don't do that, then". It's fairly easy to avoid their use, and don't really seem like a major problem to me.
17:11:57 <sorear> do Just x <- foo
17:12:01 <glguy> Haskell doesn't have runtime type errors
17:12:11 <sorear> sure it does.
17:12:21 <sorear> I just like to stare into isomorphisms.
17:12:29 <ihope> sorear: I think you'll want do x <- foo there.
17:12:37 <sorear> why?
17:12:38 <ihope> Unless foo is a Maybe (Maybe something).
17:12:46 <glguy> ihope: he is using it as a filter
17:12:46 <seliopou> newsham: you have to do something like do { [x] <- take 1 xs ; return x }
17:12:47 <jethr0> jcreigh: yes and no. dependent typing is a huge step forward though
17:12:53 <sorear> oh right
17:12:55 <seliopou> and add the type annotation
17:12:59 <newsham> jcreigh: yah, i wish there was documentation that pointed out those things though.
17:13:15 <allbery_b> the only way to trap the error from head is to run it in IO and use catch, IIRC
17:13:18 <glguy> > let cm xs = do { Just x <- xs; return x } in cm [Just 1, Nothing, Just 2, Nothing]
17:13:19 <lambdabot>  [1,2]
17:13:21 <newsham> seliopou: ahh, only happens on the pattern matching lhs?
17:13:27 <jethr0> > do {x <- []; return x}
17:13:28 <lambdabot>  Add a type signature
17:13:29 <sorear> newsham: CORRECT
17:13:32 <seliopou> yes, I believe so
17:13:38 * sorear loathes caps lock
17:13:41 <jethr0> > do {x <- []; return x} :: [Int]
17:13:42 <lambdabot>  []
17:13:47 <seliopou> if a pattetn match fails, then the monad's fail is called
17:13:59 <ihope> So I download the Windows binary, and lo and behold, two .bat files.
17:14:00 <sorear> @src Maybe fail
17:14:00 <lambdabot> fail _      = Nothing
17:14:17 <seliopou> > do { [x] <- take 1 [] ; return x } :: Maybe Int
17:14:17 <lambdabot>  Couldn't match `Maybe' against `[]'
17:14:18 <ihope> One gives an error message, the other does who knows what.
17:14:25 <newsham> ?src Error fail
17:14:25 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
17:14:26 <seliopou> Hmmm
17:14:35 <sorear> ?src (Error e) fail
17:14:35 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:15:13 <jethr0> > do { [x] <- (Just $ take 1 []) ; return x } :: Maybe Int
17:15:14 <lambdabot>  Nothing
17:15:15 <allbery_b> ?src MonadError fail
17:15:16 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
17:15:38 <ihope> Hey, a .exe!
17:15:44 * jethr0 is a bit ambivalent about LBs new cheekyness.
17:16:05 <syntaxfree> I'm already tired of it.
17:16:09 <syntaxfree> It was funny for 15 minutes.
17:16:09 <nornagon> me too :(
17:16:14 <jethr0> dito
17:16:23 <SamB> @cheek-off
17:16:23 <lambdabot> Unknown command, try @list
17:16:38 <mgsloan> yeh, especially because it's just its own stupidity that prevents it from finding the def
17:16:58 <sorear> @help poll
17:16:59 <lambdabot> poll provides: poll-list poll-show poll-add choice-add vote poll-result poll-close poll-remove
17:17:02 <sorear> @help poll-add
17:17:02 <lambdabot> poll-add <name>             Adds a new poll, with no candidates
17:17:07 <syntaxfree> @poll-list
17:17:07 <lambdabot> ["Written_a_compiler_or_interpreter?","jabberName"]
17:17:16 <sorear> @help vote
17:17:16 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
17:17:27 <sorear> @help choice-add
17:17:27 <lambdabot> choice-add <poll> <choice>  Adds a new choice to the given poll
17:17:38 <sorear> @help  poll-show
17:17:39 <lambdabot> poll-show <poll>            Shows all choices for some poll
17:17:47 <syntaxfree> @poll-add Should lambdabot's cheekiness be phased out?
17:17:47 <lambdabot> usage: @poll-add <poll>   with "ThisTopic" style names
17:17:48 <mgsloan> @poll-add cheeky-off
17:17:48 <lambdabot> Added new poll: "cheeky-off"
17:18:00 <mgsloan> :P
17:18:04 <syntaxfree> @choice-add cheeky-off Yes
17:18:04 <lambdabot> New candidate "Yes", added to poll "cheeky-off".
17:18:08 <nornagon> @vote cheeky-off Yes
17:18:08 <lambdabot> voted on "Yes"
17:18:12 <syntaxfree> @choice-add cheeky-off No
17:18:12 <lambdabot> New candidate "No", added to poll "cheeky-off".
17:18:20 <mgsloan> @vote cheeky-off Yes
17:18:20 <jethr0> this interface is a bit complicated, why not use "@poll-add <name> <options>" and maybe keep @choice-add anyways...
17:18:20 <lambdabot> voted on "Yes"
17:18:23 <sorear> @vode cheeky-off Yes
17:18:23 <lambdabot> voted on "Yes"
17:18:31 <jethr0> @vote cheeky-off Yes
17:18:31 <lambdabot> voted on "Yes"
17:18:36 <nornagon> @poll-show cheeky-off
17:18:36 <sorear> @vode cheeky-off Yes
17:18:36 <lambdabot> ["No","Yes"]
17:18:36 <lambdabot> voted on "Yes"
17:18:37 <mgsloan> jethr0: yeah, rather bad design
17:18:42 <syntaxfree> @choice-add Add @cheeky-off, @cheeky-on flags similar to @nazi-on
17:18:42 <lambdabot> usage: @choice-add <poll> <choice>
17:18:45 <glguy> @vote cheeky-off Yes
17:18:46 <lambdabot> voted on "Yes"
17:18:50 <mgsloan> should just have one poll running, too, so you don't have to specify which
17:18:51 <syntaxfree> @choice-add AddFlag
17:18:52 <lambdabot> usage: @choice-add <poll> <choice>
17:19:05 <syntaxfree> @choice-add cheeky-off AddFlag
17:19:06 <lambdabot> New candidate "AddFlag", added to poll "cheeky-off".
17:19:22 <syntaxfree> @choice-add MakeItAbuseCowboyNeal
17:19:22 <lambdabot> usage: @choice-add <poll> <choice>
17:19:36 <syntaxfree> @choice-add cheeky-off MakeItAbuseCowboyNeal
17:19:36 <lambdabot> New candidate "MakeItAbuseCowboyNeal", added to poll "cheeky-off".
17:19:38 <jethr0> the good old cowboy
17:19:46 <sorear> @help poll-result
17:19:46 <lambdabot> poll-result <poll>          Show result for given poll
17:19:48 * jethr0 runs over to slashdot to see the latest polls
17:19:50 <seliopou> @vote cheeky-off Yes
17:19:50 <lambdabot> voted on "Yes"
17:19:54 <sorear> @oll-result cheeky-off
17:19:54 <ihope> @help nazi-on
17:19:55 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=0, Yes=7
17:19:55 <lambdabot> spell <word>. Show spelling of word
17:20:02 <ihope> ...What?
17:20:08 <ihope> @help nazi-on
17:20:08 <lambdabot> spell <word>. Show spelling of word
17:20:09 <sorear> it's a Bug
17:20:11 <ihope> Hmm.
17:20:12 <syntaxfree> @vote cheeky-off yes
17:20:12 <lambdabot> "yes" is not currently a candidate in this poll
17:20:18 <sorear> @nazi-on
17:20:18 <lambdabot> Spelling nazi engaged.
17:20:19 <syntaxfree> @vote cheeky-off Yes
17:20:19 <lambdabot> voted on "Yes"
17:20:29 <jethr0> helo, speling Nazi
17:20:30 <syntaxfree> I'd better not make mistakes now.
17:20:30 <lambdabot> Did you mean hello, he lo, he-lo, helot or help?
17:20:42 <syntaxfree> mah seppling chucker works grate.
17:20:43 <lambdabot> Did you mean MA, ma, MAG, MASH or Mach?
17:21:04 <nornagon> I have perfect spelling and grammar.
17:21:11 <jethr0> that nazi-function is absolutely no good in IRC where noone ever spells anything correctly
17:21:13 <lambdabot> Did you mean Nazi, Nazis, Nani, Nari or NZ?
17:21:21 * sorear wields his impeccable diction!
17:21:22 <jethr0> @nazi-off
17:21:22 <lambdabot> Not enough privileges
17:21:27 <sorear> @nazi-off
17:21:27 <lambdabot> Spelling nazi disengaged.
17:21:27 <jethr0> *bother*
17:21:40 <Adamant> @nazi-on
17:21:41 <lambdabot> Not enough privileges
17:21:48 <sorear> I copied it from vixen-on
17:22:02 <sorear> which says -- could be noisy
17:22:36 <Anon4888> So does LB have tamagotchi features built in?
17:22:46 <jethr0> i guess it could. would be nice though when the channel gets slow, but for now vixen is dead :(
17:23:12 <mgsloan> ?nazi foobar
17:23:12 <lambdabot> Maybe you meant: nazi-off nazi-on arr ask fact faq map part wiki yarr
17:23:25 <mgsloan> ?. nazi vixen hello, vixy
17:23:25 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "nazi"
17:23:50 <jethr0> mgsloan: vixen is dead and there's no such command as @nazi
17:23:56 <mgsloan> ah
17:23:59 <sorear> @spell foobar
17:23:59 <lambdabot> foobar
17:24:02 <sorear> @spell foobarbaz
17:24:02 <lambdabot> foobars foobar barbs forbears forbear's
17:24:17 <ihope> @vixen Hello, world!
17:24:17 <lambdabot> <undefined>
17:24:19 <jethr0> @spell wysiwyg
17:24:20 <lambdabot> WYSIWYG Sig siege soggy swig
17:24:20 <ihope> Hmm.
17:24:25 <ihope> :-)
17:24:29 <sorear> @spell nazi
17:24:30 <lambdabot> Nazi Nazis Nani Nari NZ
17:26:27 <syntaxfree> vixen is dead?
17:26:35 <syntaxfree> THEY KILLED VIXEN!
17:26:54 <ihope> @vixen-on
17:26:54 <lambdabot> Not enough privileges
17:26:57 <ihope> Grah.
17:26:57 <syntaxfree> WHY OH WHY?
17:27:10 <sorear> syntaxfree: do you have /lastlog ?
17:27:20 <ihope> @spell helo, speling Nazi
17:27:21 <lambdabot> hello he lo he-lo helot help
17:27:22 <syntaxfree> I don't think so.
17:27:29 <syntaxfree> @google conversation os x
17:27:30 <lambdabot> http://homepage.mac.com/philrobin/conversation/
17:27:31 <lambdabot> Title: Conversation : Home
17:27:32 <syntaxfree> that's my client.
17:27:54 <ihope> @spell This is spelled correctly.
17:27:54 <lambdabot> This is spelled correctly.
17:28:00 <ihope> Wow!
17:28:09 <ihope> @spell This is not spelled corrrectly.
17:28:09 <lambdabot> This is not spelled corrrectly.
17:28:15 <ihope> Gasp!
17:28:22 <jethr0> *rrr*
17:28:27 <sgillesp1e> hello
17:28:29 <sorear> syntaxfree: 2 word explanation: hackathon binary.
17:28:29 <ihope> @spell Thiis is not spelled correctly.
17:28:29 <lambdabot> This Thais Thous Thus Thia's
17:28:34 <ihope> Hmm.
17:28:41 <sorear> @karma sorear
17:28:41 <lambdabot> You have a karma of 12
17:28:41 <ihope> sgillesp1e: ello
17:28:43 <sgillesp1e> the haskell type system is really getting to me...I need serious help
17:28:46 <sorear> @spell sorear++
17:28:46 <lambdabot> sorer soarer sourer so rear so-rear
17:29:04 <sorear> @karma foo
17:29:04 <sgillesp1e> where can i pastebin?
17:29:04 <lambdabot> foo has a karma of -1
17:29:05 <jethr0> sgillesp1e: how can we help?
17:29:06 <ihope> sgillesp1e: what's the problem you're having?
17:29:10 <sorear> @spell foo++
17:29:10 <lambdabot> foo++
17:29:13 <sgillesp1e> I'll show you
17:29:13 <sorear> @karma foo
17:29:13 <lambdabot> foo has a karma of -1
17:29:16 <jethr0> lisp-paste might still be down
17:29:17 <sorear> aw
17:29:18 <jethr0> @paste
17:29:18 <lambdabot> http://paste.lisp.org/new/haskell
17:29:18 <ihope> @paste
17:29:18 <lambdabot> http://paste.lisp.org/new/haskell
17:29:23 <sorear> @spell @spell foo
17:29:26 <jethr0> yup
17:29:28 <ihope> I like http://pastebin.ca/
17:29:35 <sorear> @spell @spell foo
17:29:38 <sorear> @bot
17:29:38 <lambdabot> :)
17:29:43 <sgillesp1e> proxy error
17:29:44 <ihope> @bo
17:29:44 <lambdabot> :)
17:29:48 <sorear> @spell @bot
17:29:52 <syntaxfree> @. elite karma shapr
17:29:52 <lambdabot> $h4pr |-|4$ A K4R/\/\4 0F 34
17:29:55 <ihope> sgillesp1e: pastebin.ca says that?
17:30:09 <sgillesp1e> nope, i got it
17:30:10 <sgillesp1e> thanks
17:30:53 <jethr0> @. elite spell 3l1t3
17:30:54 <lambdabot> 3l1t3
17:31:04 <sgillesp1e> http://pastebin.ca/318031
17:31:12 <ihope> @spell 3l1t3
17:31:12 <lambdabot> 3l1t3
17:31:15 <sgillesp1e> if i try to run that method i get a bunch of errors
17:31:46 <sgillesp1e> no instance for...
17:31:50 <jethr0> sgillesp1e: you might want to put ".0" behind all your dividends. do you want floating point or integral division?
17:31:55 <mgsloan> @. elite spell ma
17:31:56 <lambdabot> mA
17:31:58 <ihope> sgillesp1e: you probably want `div` instead of /
17:32:12 <sgillesp1e> div might sound better
17:32:30 <ihope> `div` is integer division, / is... uh, non-integer division.
17:32:40 <ihope> Just like ^ and ^^ and **.
17:32:44 <sgillesp1e> that sounds good
17:33:22 <ihope> Actually, what's the point of ^^, again?
17:33:35 <Excedrin> syntaxfree: that client looks pretty sweet
17:34:41 <sgillesp1e> what if i want floats
17:34:53 <SamB> > 2 ^^ (1%2)
17:34:53 <lambdabot>   add an instance declaration for (Integral (Ratio a))
17:34:53 <lambdabot>     In the definition ...
17:34:58 <SamB> hmm...
17:35:05 <syntaxfree> excedrin: yes, it's very pleasing to use.
17:35:08 <allbery_b> :t (^^)
17:35:09 <SamB> > (1%2) ^^ (-1)
17:35:09 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
17:35:10 <lambdabot>  2%1
17:35:16 <jethr0> (fromIntegral cal / 20.0)
17:35:24 <syntaxfree> it also should be very scriptable with applescript, except I never learned that godamn "natural" language.
17:35:25 <sgillesp1e> alrighty
17:37:12 <sgillesp1e> well that certainly helped a lot
17:38:32 <sgillesp1e> I've been having loads of problems with types lately, it will take me a while to get used to
17:38:49 <sgillesp1e> in general in haskell, is it considered good style to always do type signatures?
17:38:58 <Botje> yes
17:39:05 <ihope> It's certainly not bad style.
17:39:09 <Igloo> At the top level, yes
17:39:11 <Botje> I find writing type signatures before functions helps me
17:39:18 <ihope> They're like comments.
17:39:24 <Igloo> But machine checked!
17:39:59 <ihope> Yeah!
17:40:07 <sgillesp1e> it seems like you would get a better abstraction if you let it infer for you
17:40:39 <ihope> Well, you can always take the type it infers and put that into the source.
17:40:46 <mgsloan> Dunno about 'abstraction'. Flexibility maybe.  Declaring your types improves error messages, though
17:41:10 <mgsloan> inferences can kind of cascade into a mondo error message unless you declare your types :P
17:41:43 <ihope> > let self x = x x; self :: ((((a -> a) -> a) -> a) -> a) -> a in 3
17:41:44 <lambdabot>      Expecting a function type, but found `a'
17:41:44 <lambdabot>       Expected type: ((a -> a) ...
17:41:47 <ihope> Hmm.
17:41:52 <jethr0> sgillesp1e: you can always make the type more general when you're finished
17:45:10 <sgillesp1e> i see
17:45:26 <sgillesp1e> so now i'm having this problem
17:45:36 <sgillesp1e> calculatePoints::(Fractional b, integral a) => a -> a -> a -> b
17:45:45 <sgillesp1e> Points.hs:3:32: malformed class asserti
17:45:56 <jethr0> Integral
17:46:01 <sgillesp1e> aaah
17:46:02 <sgillesp1e> thanks
17:48:13 <ihope> Woot, I have the thingy!
17:49:04 <allbery_b> .oO { TMI }
17:49:10 <ihope> Now the question is how it works.
17:52:31 <jethr0> which thingy
17:54:38 <mgsloan> haskell should have taken miranda's duplicate variables in pattern matching
17:55:34 <mgsloan> it provides a nice parallel to => stuff (you may have multiple constraints on the same identifier)
17:55:56 <mgsloan> or rather facilitated by the same identifier
17:56:29 <OliverB> Hmm, you can use guards for that if you need..
17:56:33 <ihope> The Epigram thingy is working, I think.
17:56:36 <mgsloan> true
17:56:47 <mgsloan> but that's less elegant :P
17:56:58 <OliverB> Otherwise, a potential source of lots of bugs from unintended duplicate names..
17:57:13 <mgsloan> true, though the typechecker might help
17:57:21 <mgsloan> that is a good point...
17:58:32 <jethr0> k, good night
18:01:16 --- mode: ChanServ set +b *!*@ppp-71-128-92-216.dsl.pltn13.pacbell.net
18:02:54 <ctkrohn> anyone know of any freetype bindings for haskell?
18:03:06 <mgsloan> ah, apparently there are issues with _|_ as well
18:08:33 <Botje> @pl \l -> (head l, takeWhile isPrime $ scanl1 (+) l)
18:08:34 <lambdabot> liftM2 (,) head (takeWhile isPrime . scanl1 (+))
18:15:23 <Botje> @pl \x -> (isPrime $ snd x) && (snd x < 1000000)
18:15:23 <lambdabot> ap ((&&) . isPrime . snd) ((< 1000000) . snd)
18:16:31 <Igloo> OK, why does adding an unused parameter to a type make my code 4 times faster?
18:16:43 <Botje> ?
18:17:36 <Igloo> "data St s = ..." results in code 4 times faster than "data St = ..."
18:17:37 <seliopou> :t liftM2
18:17:38 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
18:17:58 <Botje> sigh, projecteuler.net is dead :/
18:20:56 <int-e> Botje: seems to work here
18:24:35 <Botje> well, deadish
18:25:56 <Botje> yay, 46% genius
18:26:06 <Botje> just a few more points away from geniosity!
18:27:00 <seliopou> I tried registering an account there a few weeks ago and the confirmation step did not work
18:27:10 <seliopou> I came to the same conclusion as Botje
18:27:43 <Botje> well, there's periods where it works flawlessly
18:27:53 <Botje> and then there's periods where their site just goes AWOL
18:31:00 <TSC> Yeah, I've noticed that too (and a friend experienced the signup problem)
18:31:35 <glguy> I had 100%, but I've fallen back down to 95%
18:31:41 <glguy> I used to be more activing in keeping up
18:31:59 * int-e forgot his password *g*
18:33:31 * araujo back
19:26:12 <sorear> tell fodder
19:27:37 <Saizan> netsplit?
19:27:42 <glguy> ?bot
19:27:43 <lambdabot> :)
19:27:52 <glguy> all the important people are on this side of it if it is
19:28:02 <sorear> @users
19:28:02 <lambdabot> Maximum users seen in #haskell: 311, currently: 277 (89.1%), active: 35 (12.6%)
19:28:03 <glguy> (is lambdabot netsplit proof now?)
19:28:18 <sorear> yeah right
19:28:29 <sorear> just because I sent a patch...
19:28:37 <glguy> oh, I thought you said you figured it out
19:28:43 <sorear> it'll find some other way to break
19:31:38 <Saizan> do you know if there's some preprocessor that takes the src of a function (limited to non-pattern matching ones maybe) and transforms it in a lambda?
19:31:59 <sorear> transforms how?
19:32:08 <notsmack> anybody know how to set padding on a gtk2hs widget?  "set vbok [boxChildPadding := 12]" doesn't seem to work
19:32:16 <notsmack> *vbox
19:32:19 <sorear> like pl?
19:32:19 <sjanssen> @unpl (f . g) x
19:32:19 <lambdabot> (f (g x))
19:32:33 <glguy> ?unpl f . g
19:32:33 <lambdabot> (\ c -> f (g c))
19:32:35 <sjanssen> @unpl f . g -- better
19:32:35 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 5}: Unterminated end-of-line comment
19:32:45 <sjanssen> bug!
19:33:06 <Saizan> yeah like unpl but that resolves function definitions too
19:33:25 <Saizan> ?unpl flip f
19:33:25 <lambdabot> (\ b c -> f c b)
19:33:30 <Saizan> it does.
19:33:30 <sorear> like inlining ?
19:33:40 <Saizan> uhm yes
19:34:04 <glguy> only in specific cases
19:34:34 <OliverB> notsmack: Not sure - the way I always figured layout issues out was by making a little mock up in glade
19:34:35 <Saizan> the fact is that to undestand the ((->) r) monad i often converts all to lambdas and it is all very clear then
19:38:34 <Saizan> so having the function in lambda form one can easily attach a step-by-step evaluator etc..
19:40:35 <notsmack> OliverB: ah, it typechecks with "set vbox [boxChildPadding canvas := 12]"
19:40:44 <Saizan> not very interesting for people who beats ?pl by hand i suppose :)
19:41:35 <sorear> ?pl is pretty stupid
19:41:36 <lambdabot> is pretty stupid
19:42:26 <sorear> it uses a fully greedy optimizer, makes heavy use of list monad *and* nub, etc etc.
19:42:44 <glguy> I'm a lot better at creating pointfree code than reading it ;)
19:43:03 <iulus> "write-only code"
19:43:08 <sjanssen> sorear: last night I was going to convert pl to a ReaderT Bool [] a
19:43:21 <sjanssen> but when I saw the nub I just went to bed
19:43:33 <sorear> heh
19:43:40 <glguy> what's this nub that you both mentioned?
19:43:42 <glguy> wrt to ?pl
19:43:53 <sorear> it is very old crufty code
19:44:06 <sorear> lacks a good deal of type safety
19:44:38 <sjanssen> glguy: it combines list monad constructs with nub to get unique results
19:44:48 <sjanssen> it just feels ad-hoc
19:44:51 <glguy> oh
19:44:56 <sorear> as opposed to Plugin/Log which doesn't use the preprocessor - it declares the extensial dictionaries and whatnot by itself
20:02:45 <TomMD> @users
20:02:46 <lambdabot> Maximum users seen in #haskell: 311, currently: 271 (87.1%), active: 29 (10.7%)
20:03:08 <Korollary> ?botsmack
20:03:08 <lambdabot> :)
20:03:28 <glguy> ?teens
20:03:29 <lambdabot> Lately, I have seen glguy, korollary and sorear.
20:03:42 <Korollary> I think sorear is a teen
20:03:49 <glguy> ?losers
20:03:49 <lambdabot> Maximum users seen in #haskell: 311, currently: 270 (86.8%), active: 29 (10.7%)
20:03:54 <Korollary> ew
20:03:58 <Korollary> That's unacceptable
20:04:34 <sorear> Korollary: you don't need to think :)
20:04:53 <Korollary> I don't? My therapist says otherwise.
20:06:26 <Saizan> is there an automatic way to remove a package installed with cabal?
20:06:54 <sorear> nope
20:07:16 <sorear> the Cabal consensus is that uninstall is bad because "what if it fails"
20:07:18 <sorear> bah.
20:07:43 <sjanssen> you can ghc-pkg unregister to make GHC forget about the package
20:07:47 <Saizan> ah, nice :D
20:07:49 <sorear> I recommend not installing anything with cabal until they figure out what they are thinking
20:08:08 <sorear> instead use ./Setup.hs register --inplace
20:08:27 <Saizan> well what is the reccomended procedure to replace a package with a newer version?
20:08:38 <pbx> I'm working on adding Haskell colo(u)ring to my pastebin via HsColour -- is there a public pastebin that uses it now?  It would be handy to test against.
20:08:53 <sorear> (1) delete the old version (by hand of course)  (2) install the new one
20:09:12 <sjanssen> I think ghc-pkg unregister should be enough
20:09:29 <sjanssen> of course the actually library cruft remains
20:09:31 <sorear> sjanssen: my hard drive is not infinite...
20:09:50 <Saizan> ok, as i guessed..
20:10:08 <sjanssen> sorear: mine is
20:10:11 <sjanssen> it's awesome
20:10:24 <sorear> it still boggles my mind that the cabal powers-that-be consider uninstall harmful
20:11:48 <Saizan> by the way i have the same problem installing packages by sources in linux, but i just don't uninstall..
20:12:15 <glguy> many packages allow for: make uninstall
20:12:35 <glguy> but I imagine this isn't news ;-)
20:12:48 <Saizan> yeah, but what if i deleted the sources?
20:13:00 <glguy> screwed
20:13:32 <notsmack> redownload, unpack, configure, make uninstall
20:14:14 <allbery_b> ...assuming you can find that version, since "make uninstall" in a later version may not DTRT
20:14:46 <notsmack> sure
20:15:03 <allbery_b> (usually by erroring out halfway through on a file that the old version didn't have)
20:15:09 <pbx> No public pastebins using hscolour?
20:15:22 <sjanssen> pbx: not that I know
20:15:43 <sjanssen> pbx: paste.lisp.org uses it's own synhl
20:15:56 <pbx> sjanssen: Yeah, I took a look at their code :)
20:16:20 <shapr> shazam!
20:16:31 <sjanssen> pbx: haskell.org wiki uses hscolour
20:16:32 <pbx> I'm kind of surprised that a language with a 30Kloc channel bot and an implementation of Perl 6 doesn't have a self-hosted pastebin though!
20:16:42 <pbx> sjanssen: Ah, that's helpful
20:16:54 <sjanssen> pbx: lisppaste works well enough, I guess
20:17:04 <pbx> It's nice.
20:17:17 <allbery_b> given how often lisppaste is down, maybe it should
20:17:21 <shapr> pbx: It's been considered, but pastebin isn't as important as stuff like webdev.
20:17:55 <shapr> Wouldn't be hard to write though.
20:18:28 <glguy> shapr: using HAppS?
20:18:34 <pbx>  I haven't used Happs but I'm assuming it provides most of the pieces.
20:18:37 <sorear> part of the problem I imagine is getting a good short URL.
20:18:56 <pbx> hpaste.com is available.
20:19:06 <pbx> (I run dpaste.com)
20:19:07 <glguy> what is more important is having pastes announced in channel
20:19:09 <sorear> how do we get a .com?
20:19:13 <shapr> glguy: sure!
20:19:17 <sorear> we're not a for-profit institution!
20:19:32 <glguy> .com doesn't have restrictions on who can buy one...
20:19:41 <pbx> sorear: We've come a long way since the '80s...
20:19:58 <shapr> I make a profit from Haskell...
20:19:59 <sorear> yes. I wasn't alive at any point in the 80's.
20:20:03 <Saizan> paste.yi.org?:)
20:20:13 <shapr> sorear: I missed the sixties... barely :-)
20:20:18 <sorear> muahahaha!
20:20:23 <sjanssen> I'm sure one could get paste.haskell.org
20:20:32 <glguy> shapr: if you were to write it in HAppS, how would you store the pastes? one file per? in memory?
20:20:33 <shapr> sjanssen: Yeah, good idea
20:20:41 <pbx> sorear: I'm just saying that .com restriction hasn't been in effect for a loooong time.
20:20:43 * shapr thinks
20:20:43 <glguy> shapr: HaskellDB to mysql ? etc
20:20:47 <sorear> I'd like short identiers.
20:20:54 <sorear> paste.yi.org/23
20:21:01 <pbx> Yeah. I just use integer PKs.
20:21:03 <sorear> cycle through the same 100 urls.
20:21:15 <shapr> glguy: I'd start out with the simplest solution that could possibly work (all in memory) and improve the implementation if needed.
20:21:20 <augustss> @yow
20:21:20 <lambdabot> Loni Anderson's hair should be LEGALIZED!!
20:21:23 <sorear> I do *not* want /display/, or even rafb's /p/
20:21:27 <shapr> hej augustss
20:21:36 <sjanssen> sorear: you manually type in paste urls often?
20:21:37 <augustss> Hej!
20:21:44 <sorear> we don't want or need to store the pastes for long...
20:22:01 <allbery_b> > 26 ^ 3
20:22:02 <glguy> shapr: what about announcing pastes to channel?
20:22:02 <lambdabot>  17576
20:22:08 <pbx> FWIW I keep 'em for 30 days.  That's only about 3M of SQLite DB (vacuumed nightly).
20:22:08 <allbery_b> hm, not what I intended
20:22:11 <allbery_b> 36 ^ 3
20:22:14 <shapr> glguy: talk to lambdabot?
20:22:16 <allbery_b> > 36 ^ 3
20:22:17 <lambdabot>  46656
20:22:18 <sjanssen> glguy: lambdabot!
20:22:24 <allbery_b> 000 .. zzz
20:22:34 <glguy> sorear: ok, so how would you notify lambdabot
20:22:41 * glguy isn't arguing that these things are impossible
20:22:46 <Saizan> lambdabot asks, i think
20:22:52 <sorear> sure
20:23:16 <shapr> I'd use an RSS feed, and get lambdabot to read that.
20:23:18 <sjanssen> glguy: you could run a webserver within the lambdabot process
20:23:19 <sorear> lambdabot connects to the.pastebin/nph-notify or whatever
20:23:32 <glguy> ew... HTTP polling?
20:23:39 <sjanssen> with communication via standard inter-thread mechanisms
20:23:46 <Saizan> glguy: yeah, AJAX is based on that :D
20:23:55 <glguy> it is based on polling?
20:24:00 <Saizan> yes
20:24:02 <shapr> the ajax trickle feed might be a better approach
20:24:03 <sorear> glguy: with a nph-notify approach you can have server push
20:24:11 <Saizan> all chats, polls
20:24:34 <shapr> but if you poll a single file with a unix timestamp, and get the content of the RSS feed whenever that unix timestamp is "new" it won't use much bandwidth, and it'll be easy to implement.
20:24:36 <sorear> or we could have the pastebin running in lambdabot :)
20:24:54 <shapr> hm, yeah... has anyone tried to combine lambdabot and happs?
20:25:03 <sorear> shapr: you want lambdabot to start a connection *once a second* ?
20:25:13 <sorear> shapr: I've compiled lambdabot
20:25:17 <Saizan> so we get happs with hs-plugins
20:25:31 <sjanssen> shapr: does happs have a "forkWebServer :: IO ()" function?
20:25:54 <shapr> sorear: Nah, not once a second, I think that's too often.
20:25:55 <sorear> while we're here - how does a @paste-more sound ?
20:25:55 <sjanssen> if so, I'd say it's trivial
20:26:07 <pbx> I'm off.  Good luck on the pastebin project :)
20:27:31 <Saizan> however we can also keep a persistent connection and have the server send data, it's not supported aside from Opera but we have a bot, not a browser
20:29:33 <sorear> Saizan: I have very old CGI books that describe a server push method that works on "all" browsers - nph + mime-multipart
20:30:19 <Saizan> nph?
20:30:26 <sorear> non parsed header
20:30:40 <SamB> ????
20:30:43 <sorear> a nph-cgi script runs with stdout directly connected to the socket
20:30:48 <SamB> oh
20:31:03 <sorear> regular cgi sents to the server, which mungs the output into valid http
20:31:08 <allbery_b> normally webservers stick some extra header foo onto cgi output.  NPH means the CGI does all the work, bypassing the server
20:31:40 <allbery_b> which lets you do somet hings that are normally impossible without hooking the server
20:31:48 <Saizan> uhm yeah, like using .pl script without CGI
20:34:14 * notsmack set up a HAppS hscolour test for pbx, but he's gone
20:34:25 <Saizan> used it to work around some strict hosting rules until i found that the .htaccess directives restrictiong me were reversible in subdirectories :)
20:38:47 <shapr> notsmack: Oh, where's the test?
20:40:10 * glguy feels cheated, he was going to use this as a mini project to learn more about HAppS
20:41:08 <sorear> @where happs
20:41:08 <lambdabot> http://happs.org
20:42:27 <shapr> glguy: Go fasta :-)
20:42:46 <shapr> glguy: That is, now's your chance do it fast and you can beat everyone else to the punch!
20:43:22 * shapr wishes to purchase sealand citizenship 
20:43:34 <bos31337> @seen dons
20:43:34 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 5h 8m 30s ago.
20:43:38 <SamB> too bad we can't kick people for leaving like that!
20:44:06 <glguy> I'm still downloading the necessary libraries
20:44:10 <glguy> haxml and happs are installed now
20:44:14 <glguy> getting hscolor
20:44:59 <shapr> SamB: leaving like what?
20:46:06 <SamB> oh, wait... he did say he was leaving...
20:46:12 <sorear> bos31337: it is 4am in dons' zone
20:46:30 <shapr> @time dons
20:46:33 <lambdabot> Local time for dons is Tue Jan 16 15:44:19 2007
20:46:35 <SamB> anyway sometimes people leave without warning when people are working on their question...
20:47:16 <sjanssen> SamB: yep, can be frustrating
20:47:36 <sorear> shapr: PADL
20:48:08 <SamB> sealand -- is that a guard platform off of the UK's coast?
20:48:09 <sorear> shapr: <dons> may be in austrailia, but Don Steward is in Nice
20:49:00 <SamB> screen is wierd like that
20:49:18 <sjanssen> sorear: dons misspelled his own name?
20:50:15 <sorear> sjanssen: Stewart :)
20:50:39 <sorear> although I'm flattered you trust me over the name's owner
20:50:51 <sjanssen> and it wasn't even a quote was it?
20:51:03 * sjanssen is a bit off
20:51:11 * shapr is really off
20:51:13 <SamB> heh
21:02:31 <Z4rd0Z> how to read (b -> c) -> a b c?  specifically the a b c
21:02:47 <sorear> that 'arr' ?
21:02:55 <Z4rd0Z> yes
21:03:07 <sorear> a is a type of kind (yes I know it is confusing) * -> * -> *
21:03:11 <sorear> like (->)
21:03:28 <sorear> so a b c is a applied to b and c
21:03:29 <sorear> it
21:03:36 <sorear> is just a type function
21:04:15 <Korollary> 'a' could be Data.Map.Map for instance where b is the key type and c is the value type.
21:04:55 <Ulfalizer> Z4rd0Z: you can read it as "takes a 'b -> c' function and returns an 'a' of b c. read about 'data' declarations and you'll probably understand where it comes from.
21:05:34 <sorear> ... or (->) (the typefunction that makes function types) ... or State (makes state-monadic-values) ... etc
21:06:00 <glguy> shapr: in the tutorial for happs, are the changes to the app state in "app" atomic?
21:06:24 <Z4rd0Z> thanks, I'll reread about 'data'
21:06:54 <notsmack> shapr: oh, http://70.101.76.11:8000/test
21:07:19 <notsmack> hah, now he's gone!
21:07:25 <shapr> glguy: As far as I know, everything is atomic in HAppS. It's hard to get out of STM when you're using HAppS.
21:07:42 <glguy> ah, its stm? nifty
21:07:54 <notsmack> (nevermind, not off in that sense)
21:09:18 <shapr> notsmack: looks cool!
21:10:17 <notsmack> shapr: thanks, did it for a blog system i'm working on.  it's a modified hscolour to output a Text.XHtml chunk
21:14:53 <sorear> yow .. type level fst ...
21:22:05 <glguy> woot, i got far enough with happs to where I can go to /new , save a paste, and go to /NUMBER and have it load a paste back up
21:22:14 <glguy> (using ids mod 100)
21:22:35 <glguy> when I try to quit Happs... it kind of blows up though
21:22:43 <glguy> and the state gets corrupted
21:22:58 <notsmack> glguy: huh, i've never seen my state get corrupted
21:23:03 <glguy> on windows?
21:23:06 <notsmack> ah.
21:23:11 <notsmack> ;-)
21:23:29 <glguy> my OpenBSD box has been down the last few days
21:23:51 <glguy> no telling what the guys were I went to college are doing to it
21:24:32 <glguy> (It's my computer, but I left it at the fraternity as a fileserver for the house)
21:34:15 <emu> playing... the OpenBSD drinking game?
21:35:44 <glguy> drink every time it crashes? no, that would take too long to get drunk
21:35:54 <glguy> the last time it was down they added more harddrive
21:35:58 <glguy> so I'm hoping it's a positive thing
21:46:27 <glguy> anyone know the significance of "the" in "thetitle" "thediv" "thespan" in Text.XHtml?
21:47:20 <Shimei> Has anyone here taken a look at that new Fortress language from Sun? I find it interesting how it has "traits" which seem awfully similar to type classes.
21:47:20 <Korollary> heh
21:52:02 <glguy> :-( lisp paste has a low grade captcha now :-(
21:52:50 <Elifant> Hello all. I wrote parser (using Parsec) for some language, which produce AST. I also implemented pretty-printing (using HughesPj) of this AST. All is fine. But now I want to add coloring to output using ANSI ESC sequences. How can I do it? I can't add sequences to text directly, because text width will then be calculated incorrectly by HudgesPj.
21:56:25 <Elifant> glguy: I think this is just to avoid name clashes
21:56:56 <mgsloan> Shimei - it seems to have lots of interesting stuff
22:01:25 <Shimei> mgsloan: I'm reading through the tutorial slides right now. "Functional methods" seemed interesting. Object methods with the same syntax as function calls. I wonder if that will be a maintenance difficulty at all.
22:01:35 <quazimodo> @spell
22:01:35 <lambdabot> No word to spell.
22:01:40 <quazimodo> @spell fatr
22:01:41 <lambdabot> fart Farr fa tr fa-tr fate
22:01:43 <mgsloan> ya
22:01:44 <quazimodo> awsome
22:01:49 <mgsloan> time to go
22:01:55 <quazimodo> @spell yagoogoly
22:01:55 <lambdabot> googly Gogol cagily giggly gigolo
22:02:07 <quazimodo> best spelling module ever
22:04:09 <bos31337> @hoogle parsec
22:04:10 <lambdabot> Text.ParserCombinators.Parsec :: module
22:04:10 <lambdabot> Distribution.Setup.parseCleanArgs :: [String] -> [OptDescr a] -> IO (Int, [a], [String])
22:04:10 <lambdabot> Distribution.Setup.parseConfigureArgs :: ConfigFlags -> [String] -> [OptDescr a] -> IO (ConfigFlags, [a], [String])
22:08:10 <glguy> ?fptools Text.XHtml.Strict
22:08:10 <lambdabot> Text.XHtml.Strict not available
22:08:19 <glguy> ?fptools Data.Char
22:08:19 <lambdabot> http://darcs.haskell.org/packages/base/Data/Char.hs
22:08:50 <glguy> where is the for attribute?
22:09:05 <glguy> <label for="someid">some text</label>
22:09:15 <sorear> never heard of it
22:09:26 <sorear> @pl \fix -> let a = 3 in a
22:09:26 <lambdabot> ($ const 3)
22:09:36 <sorear> @pl \fixx -> let a = 3 in a
22:09:37 <lambdabot> const 3
22:09:48 <sorear> hah! found my first @pl bug
22:09:57 <LoganCapaldo> woah
22:10:23 <LoganCapaldo> This bug brought to you by the letter x
22:10:31 <sorear> it's suprisingly easy to find bugs when trying to first understand a piece of code
22:10:35 <quazimodo> and by the number 3
22:10:36 <sorear> it's shadowing
22:10:48 <sorear> pl desugars let using fix
22:11:01 <CloudiDust> Greetings Everyone. I'm new to Haskell. I encountered a problem when I was doing the Miller-Rabin Test. I repeats the test several times on a given number. As the algorithm itself depends on random numbers, I have to perform the operations in IO monads. The problem is that inside the monad the || operator seemed no longer lazy. Even when I could tell the number is not prime during some round of test, I have to finish it entirely before getting the result
22:11:22 <sorear> CloudiDust: please don't send messages longer than 512 chars. it just doesn't work.
22:11:44 <CloudiDust> Thanks.
22:11:46 <sorear> yes, IO is strict
22:12:12 <sorear> right now you have a millerRabin :: Integer -> IO Bool ?
22:12:28 <CloudiDust> ya.
22:12:31 <glguy> It seems like a weird oversight to just forget the for attribute... I wonder if it has a different name
22:12:41 * glguy tried "thefor"
22:12:47 <sorear> so instead it would be better to do   millerRabin :: Integer -> State StdGen Bool
22:13:03 <sorear> or millerRabin :: RandomGen g => Integer -> State g Bool
22:13:20 <CloudiDust> State Monad is not Strict?
22:13:21 <sorear> now you can use split to obtain many random number generators
22:13:38 <sorear> a single thread of random number state must be strict
22:14:00 <sorear> but by using Random.split you can effectively stay lazy
22:14:08 <sorear> woah
22:14:31 <CloudiDust> Oh, I'll try it out. Thanks a lot. :)
22:14:36 <bd_> I thought Random.split wasn't very good, wrt the quality of the randomness?
22:14:47 * sorear just found his blind spot on the giant hanging indent on CloudiDust's comment ... woah
22:14:58 <svref> @help paste
22:14:58 <lambdabot> paste. Paste page url
22:15:15 <glguy> xhtml probably missed it because Text.Html missed it
22:15:16 <sorear> bd_: according to the QuickCheck site, that is true *for ancient versions of Hugs*
22:15:19 <bd_> ah
22:15:27 <sorear> old hugs had:
22:15:35 <sorear> split gen = (gen, variant gen)
22:15:38 <bd_> I was thinking of something like MaybeT (State StdGen) ()...
22:15:52 <sorear> also see:
22:16:01 <sorear> @wiki New monads/Random
22:16:01 <lambdabot> http://www.haskell.org/haskellwiki/New monads/Random
22:16:05 <Elifant> glguy: strAttr "for" "value"
22:16:10 <sorear> (bad link)
22:16:18 <glguy> Elifant: yeah, that's my current workaround
22:16:36 <glguy> Elifant: I'm just search through the sources before I move on
22:16:42 <sorear> http://haskell.org/haskellwiki/New_monads/MonadRandomSplittable
22:16:43 <lambdabot> Title: New monads/MonadRandomSplittable - HaskellWiki
22:17:02 <bd_> -- no statistical foundation for this! <-- from stdSplit, heh
22:19:20 <lisppaste2> svref pasted "ignore" at http://paste.lisp.org/display/35457
22:22:13 <sorear> good night
22:29:09 <jcreigh> wow, it looks like gcc will optimize way certain types (tail?) of recursion.
22:30:24 <Korollary> It's been doing that for a while I think.
22:33:13 <dancor> what is the right datastructure for a branching history
22:33:34 <jcreigh> it's news to me. I was messing around and noticed that my naive recursive factorial had turned into a loop with -O2. Pretty cool.
22:33:34 <dancor> data Hist = Hist (M.Map Move Hist)
22:34:19 <dancor> but then i think it is hard to keep track of where you are in the history
22:35:13 <dancor> for linear history i just use a list that i add to and init to undo
22:35:54 <dancor> i think i need to pass the current node around and allow nodes to refer to their parents
22:37:23 <dancor> is that easy/therightthingtodo in haskell
22:38:23 <bd_> dancor: Have you looked into zippers?
22:38:39 <bd_> I've only skimmed the literature on the topic but I think it's pretty much what you're trying to do
22:38:50 <bd_> ?where zippers
22:38:51 <lambdabot> I know nothing about zippers.
22:39:12 <quazimodo> hah, i installed vnc on my brothers pc
22:39:15 <dancor> yeah right lambda bot you mynx
22:39:17 <quazimodo> i keep messing with his games ;)
22:39:27 <dancor> s/my/mi
22:39:41 <Saizan> ?goog haskell wikibook zipper
22:39:43 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Recursion
22:39:55 <bd_> http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf
22:39:58 <bd_> looks relevant
22:40:05 <bd_> the wikibook is a stub :/
22:40:49 <Saizan> yeah :\
22:41:23 <Saizan> seen the link reading about arrows..
22:43:23 <bd_> the basic idea though is that you represent a tree centered at your current location
22:43:23 <dancor> what is :> in data Cxt e a = Nil | Cxt e a :> Turn a (Tree a a)
22:43:29 <bd_> rather than at the root
22:43:37 <bd_> dancor: it's the constructor, which is an operator
22:43:39 <bd_> that's the same as
22:43:52 <bd_> data Cxt e a = Nil | (:>) (Cxt e a) (Turn a (Tree a a))
22:46:46 <dancor> comonads  (head explodes)
22:50:45 <dancor> i would think that i should store the whole tree and the path to the 'current' state
22:51:18 <dancor> what's this about storing the subtree from the current state.  i don't see how you have enough info to jump up (i.e. back in time; undo) then
22:52:23 <dancor> since i don't understand the paper i guess i'll just go with  data Hist = Hist (M.Map Move Hist) [Move]
22:52:25 <bd_> dancor: You store the subtree, and the path back to the root; that way you can sort of reassemble the tree when you need to move through it
22:52:42 <bd_> It's sort of implicit though
22:52:52 <dancor> bd_: but don't you lose the branches above you?
22:53:10 <bd_> dancor: no, because you have a reference to the subtree above you; which has a reference to the subtree above, etc etc
22:53:25 <bd_> so if you want the root you just follow it to the top:
22:53:35 <bd_> findRoot t@(Nil :> _) = t
22:53:43 <bd_> findRoot (c :> _) = findRoot c
22:53:46 <bd_> findRoot Nil = Nil
22:54:27 <dancor> what does Cxt stand for
22:54:30 <bd_> context
22:54:36 <bd_> The Cxt type holds both the context of the tree above it, and the full tree below it
22:54:46 <flux-> may I suggest the name Ctx?-)
22:54:53 <bd_> So whenever you move down the tree, you store your entire old tree:
22:55:17 <dancor> flux-: heh don't worry i'll come up with something very descriptive for my small mind for me
22:55:24 <bd_> hmm
22:55:32 <bd_> wait a sec, what's that Turn doing there... :)
22:55:56 <ski> bd_ : are you sure you want '_' in the second equation for 'findRoot' ?
22:56:31 <bd_> ski: Oh, right, we need to reassemble the tree, right? XD
22:56:46 <bd_> though you could get cute with laziness in the mutators I suppose
22:57:43 <bd_> *reads the slides*
22:58:09 <ski> data Tree a = Empty | Node a (Tree a) (Tree a)
22:58:11 <ski> data Cxt a = Top | FromLeft a (Cxt a) (Tree a) | FromRight a (Tree a) (Cxt a)
22:58:17 <ski> would that work ?
22:58:49 <ski> up :: Cxt a -> Maybe (Cxt a)
22:58:51 <bd_> Yeah, the Turn is an alias for an Either like that
22:58:59 <ski> up Top = Nothing
22:59:14 <bd_> data Cxt e a = Nil | Cxt e a :> Turn a (Tree e a)
22:59:23 <bd_> type Turn x y = Either (x, y) (x, y)
22:59:55 <bd_> so when we move up we just replace the appropriate branch of the tree
22:59:58 <bd_> as in:
23:00:39 <bd_> hmm
23:04:10 <bd_> okay, I confused myself now XD
23:04:47 <ski> up :: (Cxt a,Tree a) -> Maybe (Cxt a,Tree a)
23:04:53 <ski> up (Top,_) = mzero
23:05:01 <ski> up (FromLeft a parent right,child) = return (parent,Node a child right)
23:05:06 <ski> up (FromRight a left parent,child) = return (parent,Node a left child)
23:05:38 <bd_> that makes sense
23:05:46 <dancor> do you think this context thing is much better than having the whole tree and the path to the current one
23:05:48 <bd_> these slides got too cute with ... everything
23:05:56 <bd_> dancor: depends on how you'll be accessing it
23:06:01 <dancor> i guess my idea has duplication that could get out of sync
23:06:12 <dancor> because mine won't be binary
23:06:28 <dancor> and not all possible paths will exist
23:06:38 <bd_> zippers can be extended beyond just binary trees
23:06:48 <dancor> yeah of course
23:06:48 <bd_> just instead of FromLeft have From <direction>
23:06:51 <ski> downLeft :: (Cxt a,Tree a) -> Maybe (Cxt a,Tree a)
23:06:55 <ski> downLeft (parent,Nil) = mzero
23:07:03 <ski> downLeft (parent,Node a left right) = return (FromLeft a parent right,left)
23:07:08 <ski> downLeft (parent,Node a left right) = return (FromRight a left parent,right)
23:07:12 <LoganCapaldo> they can be extended to pants AND jackets
23:07:33 <dancor> to the joy of many a fashionite
23:07:39 <ski> the 'Cxt a' is the path to the current subtree
23:07:40 <bd_> dancor: What kind of application is it for?
23:08:01 <dancor> maintaining history in a go game
23:08:11 <dancor> where you allow saving of variations
23:08:20 <bd_> ah
23:08:23 <bd_> neat
23:08:30 <bd_> sounds like a zipper would be applicable
23:08:45 <ski> bd_ : does that look workable ?
23:09:05 <bd_> ski: I think so. These slides got a bit too cute with their variables so it's tough to see what's going on :)
23:09:20 <ski> (er .. of course the last equation belongs to 'downRight' ..)
23:09:32 <bd_> :=| :> and :< get confusing after a while
23:10:00 <bd_> dancor: data Ctx k a = Nil | From k (Ctx k a) (Tree a)
23:10:04 <bd_> er
23:10:06 <bd_> dancor: data Ctx k a = Nil | From k (Ctx k a) (Tree k a)
23:10:26 <ski> what's 'k' ?
23:10:33 <bd_> the label for the edges
23:11:15 <bd_> data Tree k a = Tree { annotation :: a, subtrees :: Data.Map.Map k (Tree k a) }
23:11:17 <bd_> or something
23:11:36 <ski> hm .. i should think over zippers again, sometime .. e.g. in relation to my adventure game
23:11:54 <ski> (i used something zipper-like there)
23:12:01 <bd_> incidentally, is there a gentle introduction to delimited continuations somewhere?
23:12:13 <ski> hahahah !
23:12:14 <bd_> Just something which explains what shift and reset do... I'm drowning in theory here XD
23:13:17 <ski> reset (C[shift k. E])  =  reset (let k x = reset (C[x]) in E)
23:13:25 <ski> roughly
23:13:33 <bd_> What are C and E?
23:13:41 <ski> 'E' is any expression
23:14:01 <bd_> and... what's that period? XD
23:14:16 <ski> 'C' is a context (not containing 'reset', in this case)
23:14:40 <bd_> okay, and why is k x never used in the RHS?
23:15:02 <ski> 'E' is an expression which may have 'k' as free variable
23:15:09 <bd_> oh
23:15:35 <bd_> so uh
23:15:51 <bd_> ... can I have a more intuitive explanation, please? XD
23:16:14 <ski> 1 + reset (10 + shift k. k 100)
23:16:22 <ski> 1 + reset (let k x = reset (10 + x) in k 100)
23:16:35 <ski> 1 + reset (reset (10 + 100))
23:16:42 <ski> 1 + reset (reset 110)
23:16:46 <ski> 1 + reset 110
23:16:49 <ski> 1 + 110
23:16:52 <ski> 111
23:17:01 <ski> and
23:17:08 <ski> 1 + reset (10 + shift k. 100)
23:17:18 <ski> 1 + reset (let k x = reset (10 + x) in 100)
23:17:24 <ski> 1 + reset 100
23:17:27 <ski> 1 + 100
23:17:30 <ski> 100
23:17:31 <ski> er
23:17:33 <ski> 101
23:17:45 <ski> now, note
23:17:57 <ski> 1 + reset (10 + shift k. k (k 100))
23:18:04 <ski> 1 + reset (let k x = reset (10 + x) in k (k 100))
23:18:21 <ski> 1 + reset (reset (10 + reset (10 + 100)))
23:18:28 <ski> 1 + reset (reset (10 + reset 110))
23:18:28 <bd_> so... shift replaces the next-outermost reset with its return value, passing it the argument which completes... hmm
23:18:38 <ski> 1 + reset (reset (10 + 110))
23:18:43 <ski> 1 + reset (reset 120)
23:18:47 <ski> 1 + reset 120
23:18:51 <ski> 1 + 120
23:18:54 <ski> 121
23:19:11 <bd_> I think I sort of understand.
23:19:35 <bd_> is reset the same as promptP in http://www.haskell.org/pipermail/haskell/2005-April/015769.html ?
23:19:36 <lambdabot> Title: [Haskell] Zipper as a delimited continuation
23:20:09 <ski> 'shift' captures (and removes) the current continuation, up-to the nearest (dynamically) enclosing 'reset' .. the 'reset' is not removed, but is included in the captured delimited continuation
23:20:16 <ski> (other variants exist)
23:20:40 <ski> i think 'promptP' (and friend ?) is one of these variants
23:21:30 <bd_> oh, yes, it has it up at the top, missed it when I was scanning...
23:21:40 <bd_> okay, I think I sort of understand shift/reset now anyway
23:21:42 <bd_> thanks :)
23:21:43 <ski> yes, at least it is a generalization .. possibly slightly different semantics in the single-prompt case, as well
23:21:56 <ski> hm, wait a moment
23:22:00 <bd_> now let's see if I can figure out how it's applied to zippers...
23:22:52 <ski> http://community.schemewiki.org/?composable-continuations-tutorial
23:22:57 <lambdabot> http://tinyurl.com/yy2eux
23:23:20 <ski> that shows another application, as well (turning internal iteration into external iteration)
23:25:28 <bd_> ahhh
23:25:42 <bd_> that's starting to make a lot of sense now :)
23:32:42 <bd_> hmm, downside of zippers-as-continuations is you can't easily go backwards
23:32:45 <bd_> well
23:32:52 <bd_> unless the traversal function allows it I guess
23:33:08 <bd_> but then you've got a zipper traversal function being turned back into a zipper
23:34:17 <ski> can you explain zippers-as-continuations ?
23:34:34 <bd_> continuations-as-zippers rather
23:35:32 <bd_> the idea is you have zome generic data structure with a traversal function - this is of the form traverse :: (Monad m) => (Term -> m (Maybe Term, Direction)) -> Term -> m Term
23:36:03 <bd_> the first parameter is a guidance function - the traversal function supplies it a term, and it returns an optional new value to replace it with, and a direction to go in next
23:36:18 <bd_> then you pass in a term to traverse and hey presto.
23:36:34 <bd_> by using delimited continuations, it's possible to invert this into a zipper structure
23:36:36 <ski> what is 'Term' ?
23:36:59 <bd_> Some recursive data structure
23:37:01 <bd_> their example was:
23:37:07 <bd_> > data Term = Var String | A Term Term | L String Term
23:37:07 <bd_> >             deriving (Eq,Show)
23:37:08 <lambdabot>  Parse error
23:37:08 <lambdabot>  Parse error
23:37:09 <ski> does the provided function walk in a direction, or does 'traverse' do that ?
23:37:25 <bd_> traverse does the walking, but the direction to go in is returned from the function traverse calls
23:37:30 <bd_> (that's the Direction argument)
23:37:48 <ski> and the 'Maybe Term' is for replacing subtree ?
23:37:51 <bd_> yeah
23:37:59 <ski> before or after recursive descent ?
23:38:09 <ski> or does replacing inhibit descent ?
23:38:51 <bd_> looks like it decides where to go next after replacing the subtree
23:38:59 <bd_> but that depends on the traversal function
23:39:16 <bd_> it would be possible to write a traversal function which behaved differently, I expect
23:39:46 <bd_> although I wonder if this is truly as general as it can be in this paper as-is...
23:39:47 <ski> (i'm just wondering if a more general traversing function type would be appropriate)
23:40:33 <bd_> well the real workhorse is zip'term :: (Monad (CC r m), Monad m) => ((term -> CC r m (Maybe term, dir)) -> term -> CC r m term) -> term -> CC r m (Zipper r m term dir)
23:40:53 <bd_> I'm wondering if perhaps the two terms could be seperate - that is, one to represent the structure as a whole
23:41:04 <bd_> and one which the traversal function gives the direction function
23:41:39 <bd_> on the other hand you could apply faster (?) manipulations over whole subtrees when needed this way
23:41:43 <ski> hm, it returns a 'Zipper
23:41:44 <ski> ' ?
23:41:53 <bd_> ski: it's a type alias over a continuation
23:42:42 <Azmo> i have a 2-line program. could someone compile it and tell me what output they get?
23:42:49 <Azmo> import Control.Concurrent
23:42:50 <Azmo> main = do tid <- forkIO $ (print 1) ; yield ; killThread tid ; putStrLn "2"
23:43:07 <bd_> you extract the continuation, pass it the direction and new value, and then you get back your new zipper at the new location
23:43:15 <Azmo> i certainly get surprised by my output..
23:43:22 <bd_> Azmo: it's undefined, certainly?
23:43:47 <Azmo> does not work in GHCi btw, i just get the correct output there
23:43:54 <bd_> there is no correct output :)
23:43:55 <Azmo> bd_: how so?
23:43:57 <ski> bd_ : what operations are provided on a 'Zipper r m t d' ?
23:44:33 <bd_> Azmo: I get the same output for both :) No guarentees over thread ordering without explicit lock primitives, period.
23:44:46 <Azmo> there are bounds to the possible outputs, if the output was "1111" would that be ok? :]
23:45:16 <Azmo> it is not a matter of ordering, the output i get should not be possible.
23:45:44 <bd_> ski: the paper doesn't define a library-level set of primitives, it just has a few demo things (if you see liftIO (print ...) in things it's not really an accessor :)
23:45:54 <bd_> > zip'move dir (Zipper term k) =
23:45:54 <lambdabot>  Parse error
23:45:55 <bd_> >     liftIO (print dir >> print term) >> k (return (Nothing,dir))
23:45:55 <lambdabot>   Not in scope: `dir'
23:45:57 <bd_> Azmo: ?
23:46:00 <bd_> Azmo: I get 1\n2\n
23:46:12 <bd_> with the newlines actual newlines in my terminal ofc
23:46:16 <Azmo> i get "1212". did you compile it? what compiler?
23:46:18 <ski> bd_ : http://cs.ioc.ee/~tarmo/tsem05/uustalu0812-slides.pdf ?
23:46:30 <bd_> Azmo: GHC 6.6
23:46:36 <bd_> ski: http://www.haskell.org/pipermail/haskell/2005-April/015769.html
23:46:36 <lambdabot> Title: [Haskell] Zipper as a delimited continuation
23:46:50 <Azmo> GHC 6.6 here too. i don't get it :/
23:46:58 <bd_> Azmo: hmm, what platform? Are you building for SMP/
23:46:58 <bd_> ?
23:47:05 <Azmo> win2k
23:47:17 <Azmo> SMP ??
23:47:39 <bd_> I guess not. Hm.
23:48:02 <bd_> If you get 1212 from that program... well, that shouldn't happen, the IO subsystem has all the necessary locking
23:48:18 <Azmo> hm...
23:50:16 <Azmo> bd_: i suppose you are not running windows?
23:51:12 <bd_> I don't have GHC installed on my windows machine, no
23:51:34 <Azmo> could be a windows-bug.
