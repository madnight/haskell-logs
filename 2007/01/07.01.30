00:02:31 <Korollary> robreim: that path looks wrong. I'd have thought that any *.o would be under a lib dir.
00:03:41 <lispy> wkh: it's a nice upgrade from Java, but I'm hesitant to say it rocks :)
00:04:06 <lispy> wkh: at least after some of the strange debugging sessions i had while using it
00:04:07 <robreim> Korollary: what lib dir would it be using under windows? I thought it all goes under the ghc installation directory like that?
00:04:16 <wkh> lispy: sigh, the tools need a lot of work, yes
00:04:21 <wkh> as do the docs and the standard libs
00:04:26 <wkh> still a lot of potential
00:04:36 <Excedrin> if you like Haskell but need/want Java libraries/IDE/debugger/profilers/etc look at CAL
00:05:34 <notsmack> hmm, so i've got my _stub.h and _stub.o, but gcc is failing on undefined references to rts_lock, base_GHCzi..., etc, what library do I need to link in?
00:06:42 <lispy> wkh: try this for instance.  Create a trait Counter, then extend that trait as FooCounter and BarCounter.  In the Counter trait create one variable and provide a protected method to increment that variable and a protected method to access it.  Then in FooCounter create a public incFoo that calls the proctected method.  Create as similar incBar function in BarCounter.  Now 'mixin' both FooCounter and BarCounter in some compeletly
00:06:42 <lispy> unrelated class and call their respective public methods and print out the value of the foo and bar counts as you do it
00:07:20 <wkh> lispy: if you think you've found a bug, could you report it?
00:07:38 <lispy> is it a *bug*?
00:07:45 <lispy> i've reported the other bugs i found
00:08:45 <lispy> when i did the above, as part of a "real" program, i found that incFoo and incBar were incrementing the same value
00:10:00 <lispy> and right now i'm going to sleep
00:10:16 <lispy> but it would be interested if you tried it and got different or similar results
00:10:30 <notsmack> anybody awake who's used FFI exports?
00:10:32 <wkh> ok
00:10:58 <lispy> wkh: if you try it, please /msg me with the results, otherwise i may not see it
00:11:06 <wkh> ok
00:13:12 <hyrax42> ugh
00:13:28 <hyrax42> programming without tuples
00:13:30 <hyrax42> :/
00:14:59 <robreim> ?where CAL
00:14:59 <lambdabot> I know nothing about cal.
00:18:08 <xpika2> @index mouse
00:18:09 <lambdabot> bzzt
00:18:29 <Excedrin> http://labs.businessobjects.com/cal/
00:18:33 <lambdabot> Title: The Open Quark Framework for Java and the CAL Language
00:19:42 <robreim> thanks
00:29:13 <dons> has anyone here used CAL?
00:30:42 <Excedrin> dons: yes, but not too much
00:31:48 <notsmack> figured it out.  link it with ghc, as the ghc FFI docs say.  (in case some future log-finding googler is curious)
00:32:20 * dons waves to the googlers of the future!
00:32:23 <dons> hey guys! :)
00:32:41 <dons> I wonder if they're waving back..
00:34:15 <Excedrin> dons: does googlebot hit the logs?
00:34:37 <dons> I'd imagine so, they certainly come up in the logs
00:34:43 <dons> sorry, in the search
00:34:45 <notsmack> i've ended up here before, but can't remember if it was ~nef
00:34:46 <dons> for 'haskell' terms
00:36:29 <Excedrin> http://www.google.com/search?hl=en&q=site%3Atunes.org%2F%7Enef%2Flogs%2Fhaskell+irc
00:36:31 <lambdabot> Title: site:tunes.org/~nef/logs/haskell irc - Google Search, http://tinyurl.com/3as9ka
00:36:38 <Excedrin> that's pretty useful
00:38:41 <narain> hi all, haskell newb here doing some graphics programming in haskell
00:38:51 <narain> what's a good type to represent 3d vectors?
00:39:13 <narain> i could make tuples of 3 components
00:39:28 <narain> but i'd also like to be able to use list functions like sum, zip etc
00:40:24 <narain> is that possible?
00:41:40 <notsmack> narain: i'd suppose you could make a data type for it, then make that type an instance of Num...
00:41:56 <narain> that's what i'm doing now
00:41:58 <Excedrin> narain: why wouldn't you be able to use zip?
00:42:19 <dons> yeah, something like data RGB = RGB !Word8 !Word8 !Word8
00:42:25 <dons> then you could zip up lists of those values.
00:42:26 <narain> if my type is a tuple and zip works with lists...?
00:42:36 <notsmack> dons: ! == strict?
00:42:43 <dons> though you might want to use bytestrings or arrays if the data quantity is going to be large?
00:42:46 <dons> opqdonut: yeah.
00:42:52 <dons> sorry, notsmack tab misfire
00:42:58 <notsmack> haha
00:43:33 <xpika2> dons. what irc client do you use?
00:43:51 <dons> irssi
00:44:18 <narain> dons: i dont have huge amounts of data though
00:44:50 <dons> ok. so lists of vectors maybe? hard to tell without more info
00:45:27 <narain> i'd like to be able to say (+) = map (+) $ zip
00:45:42 <narain> to add two vectors
00:45:44 <dons> ah right. so you want a Num instance for your type
00:45:51 <dons> yeah, that's reasonable, and been done before
00:46:06 <Saizan> i think he wants something like  zip (0, 1, 2) (3, 4, 5) == [(0,3),(1,4),(2,5)]
00:46:10 <narain> yes
00:46:12 <dons> instance Num MyVector where a + b = zipWith (+) a b
00:46:55 <narain> right, so my question is, won't that require MyVector to be a list type?
00:47:17 <notsmack> for that exact example yeah, but you don't want MyVector to be a list type.
00:47:54 <Saizan> i think it's better to pay a little more keystrokes in the instance of Num and have your own custom type
00:48:11 <notsmack> > zipWith (,) [0,1,2] [3,4,5] -- for example...
00:48:12 <lambdabot>  [(0,3),(1,4),(2,5)]
00:49:04 <narain> ok... i was just wondering if there wasn't some way i could make use of all the list functions in the Prelude
00:49:11 <narain> but if not i can live with that
00:49:43 <notsmack> narain: sure, make it a list.  but that's not what you want.
00:50:56 <bringert> hi dons
00:51:20 <narain> right, then i don't have as much type checking and no guarantees that i have exactly 3 components
00:51:26 <narain> meanwhile "type Vector3 a = (a,a,a)" makes "map (2*) myVector3" out of the question i guess
00:51:54 <narain> so i suppose it's better to take the latter route and a little more keystrokes
00:52:26 <nmessenger> write a mapTriple f (x,y,z) = (f x, f y, f z)
00:52:27 <notsmack> i'd be surprised if it were that many more even
00:52:32 <notsmack> nmessenger: exactly
00:53:04 <notsmack> narain: anything prelude-like you'd want to do should be a one liner; just write it as you need it
00:53:25 <narain> nmessenger: i'll do that
00:53:45 <narain> notsmack: that's true
00:53:57 <narain> well thanks everyone
00:54:31 <narain> one last thing...
00:54:37 <notsmack> lists are unsafe for your application /because/ of everything you can do with them
00:54:45 <matthew-_> narain: you could make your vector an instance of fmap
00:54:52 <narain> if i want scalar multiplication e.g. 2 * (1,2,3) = (2,4,6)
00:55:08 <Saizan> marain: make it an instance of Functor if you are going to write mapTriple, instance Functor Vector3 where fmap = mapTriple
00:55:10 <nmessenger> s/mapTriple/fmap/ in an (a,b,c) Functor
00:55:22 <narain> that doesn't fit with the type of * :: a -> a -> a
00:55:58 <narain> i'll have a look at fmap and Functor, thanks
00:55:59 <nmessenger> narain: 2 could be desugared via 'fromIntegral' in the Num instance to '(2,2,2)'
00:56:35 <nmessenger> (fromInteger maybe?  /me doesn't remember the Num interface)
00:56:51 <narain> nmessenger: you're right, but say it's 2.5
00:56:55 <Saizan> or you can write a  s .* v = fmap (*s) v
00:57:01 <narain> fromInteger :: Integer -> a
00:57:13 <pjd_> narain: Functor is the general class for structures that can be mapped over
00:57:39 <notsmack> narain: C++ programmer, by any chance? :-)
00:58:17 <narain> notsmack: i've enjoyed using c++'s operator overloading several times, yes :)
00:59:46 <Saizan> but scalar product is quite different from standard vector product
01:00:24 <narain> pjd_: thanks
01:01:56 <narain> Saizan: depends on what you mean by "standard vector product"
01:02:14 <narain> dot product doesn't fit with * :: a -> a -> a
01:02:47 <narain> cross product does but i wouldn't call that standard, and it only works for 3-vectors
01:03:35 <Korollary> I believe there are one or two linear algebra libs
01:03:39 <matthew-_> narain: I have a vector library in haskell you can look at / use if you want
01:03:40 <matthew-_> !paste
01:03:41 <hpaste> Haskell paste bin: http://hpaste.org/
01:04:47 <narain> Korollary: i'd rather not pick up a big linear algebra package
01:04:51 <hpaste>  matthew-_ pasted "Some vector type functions" at http://hpaste.org/195
01:06:00 <matthew-_> I think for performance reasons I avoided making it an instance of Functor - but I'm not sure now.
01:07:18 <Korollary> narain: No, but you could get ideas from them.
01:07:35 <hpaste>  matthew-_ annotated "Some vector type functions" with "and some uses of them" at http://hpaste.org/195#a1
01:07:46 <narain> matthew-_: not sure why you wrote it that way or not sure if there would be a performance hit?
01:08:09 <nmessenger> For performance reasons?  There's a penalty for using typeclasses?
01:08:24 <matthew-_> err, I had a much more general "Vectoid" type class with varying number of elems and varying elem type
01:08:26 <narain> Korollary: that's true
01:08:57 <matthew-_> ghc wasn't always able to work out the ground type at the call site and so extra work was needed at run time
01:09:03 <matthew-_> hence the performance hit
01:09:29 <matthew-_> in my case I only ever need 3D vectors with Doubles so it's better to write it out in full.
01:09:39 <narain> ah... so would there be a significant penalty if i wrote everything in terms of fmap?
01:09:50 <narain> even if i'm only using 3-vectors as tuples?
01:09:51 <matthew-_> no, fmap's ok I think
01:09:58 <matthew-_> :t fmap
01:10:00 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
01:10:24 <matthew-_> ahh, so you'd want the a and b to be Doubles
01:10:45 <matthew-_> mmm. if ghc can work out that they're always going to be doubles then it should be able to optimise the same.
01:11:14 <matthew-_> I'm not that familiar with the internals of ghc though - this is just from what I've seen. I'm sure others here know much more
01:11:55 <narain> matthew-_: that sounds good enough for me though, i'm not working with huge datasets at the moment
01:12:30 <matthew-_> ahh right. Of course, refactoring these things is really really easy
01:12:51 <matthew-_> so you could still start with fmap and Functor and if it's not fast enough there should be little that you have to change
01:13:03 <matthew-_> provided suitable use of type aliases and modules etc etc
01:13:58 <narain> matthew-_: re modules: i guess i'll learn as i go along :)
01:14:07 <narain> type aliases i know from SML
01:19:51 <pjd_> stupid question:  how do you do data/type declarations in ghci?
01:21:27 <Korollary> You can't.
01:21:39 <Korollary> Just load a file, edit it and reload via :r.
01:21:53 <pjd_> :(
01:22:00 <notsmack> pjd_: imagine you're in an IO block, sort of
01:22:16 <pjd_> notsmack: yeah, i know that part
01:22:38 <pjd_> i was hoping for some kind of :declare command
01:23:22 <pjd_> hmm, how hard would that be to implement?
01:34:53 <Slarba> hello
01:37:03 <Slarba> Donner :)
02:00:12 <dcoutts> Lemmih, you rang?
02:01:12 <dcoutts> @tell Pseudonym swiert already wrote a tic-tac-toe GUI with Gtk2Hs and it's included in the Gtk2Hs demo collection
02:01:13 <lambdabot> Consider it noted.
02:03:06 <dcoutts> dons, landed in the fps-unstable branch I presume.
02:04:44 <dcoutts> @tell Pseudonym mind you, that version wouldn't obfuscate so nicely since it uses more long names :-)
02:04:45 <lambdabot> Consider it noted.
02:05:00 <dons> there's two repos (3 if you count base). its in the stable branch, not the streams branch
02:05:09 <dcoutts> oh ok
02:05:11 <dons> i'll merge streams into stable after the next tag
02:05:16 <dons> which should be soon enough
02:05:20 <dcoutts> yay
02:06:52 <huschi> @hoogle IO Day
02:06:52 <lambdabot> No matches, try a more general search
02:07:19 <dons> hmm, System.Time maybe?
02:07:30 <AStorm> @hoogle Time
02:07:31 <lambdabot> System.Time :: module
02:07:31 <lambdabot> Time :: module
02:07:31 <lambdabot> System.Locale.TimeLocale :: ([(String, String)] -> [(String, String)] -> [(String, String)] -> String, String -> String -> String -> String -> String -> TimeLocale)
02:10:00 <pjd_> my, what big a signature you have
02:10:28 <huschi> pjd_: you meant me?
02:10:48 <pjd_> no, TimeLocale :)
02:11:17 <huschi> dons: but that doesn't return a day from Data.Time.Calendar.
02:11:38 <huschi> it looks like if i have to write a conversion function on my own :)
02:16:11 <dcoutts> dons, good email on the CString api changes
02:19:53 <Saizan> ?hoogle Serializable
02:19:54 <lambdabot> No matches found
02:29:53 <dcoutts> dons, appart from do notation, do we need monads for serialisation? I thought we needed them for string pools etc, but that's not true.
02:30:25 <dcoutts> ie so we could use StateT SrtingPool Put
02:30:43 <dcoutts> but that'd still use () as the return
02:42:38 <kzm> dcoutts, how about things like hDecode, where you need to keep track of the length of the serialized object?
02:42:59 <kzm> (Hmm.. I suppose that should be h*En*code)
02:43:06 <dcoutts> kzm, you mean lazyPut ?
02:43:27 <kzm> perhaps I do.  I haven't had time to look at it since Hac.  Do I?
02:44:04 <dcoutts> lazyPut finds the length of the thing, write out the length and then the data
02:44:37 <dcoutts> it works by just doing a nested encode, finding the length of the resulting stream and then flushing that stream into the main stream.
02:44:55 <dcoutts> I don't think that needs >>=
02:46:14 <kzm> I don't think that's it.  I wanted to do some mixing of seeks and encoding - I think the problem was that hDecode would slurp the entire remaining stream, or something.  (The details have been pushed to deeply on my mental stack ATM.)
02:46:50 <dcoutts> oh, yeah, that.
02:47:10 <dcoutts> I'm not sure it's related
02:47:18 <dcoutts> you're talking about getting anyway
02:47:27 <kzm> Hmm.  Reading your nested encode comment, I now find it sounds like the same :-)
02:48:07 <kzm> Anyway - it seems this does not apply.  Right.
02:48:36 <kolmodin> it's an interesting problem. Put runs in ~constant space except for doing lazyPut where it has to hold the hole nested string in memory
02:50:16 <dcoutts> yep
02:50:30 <kzm> Is anybody attacking the shootout problems, btw?
02:50:55 <dcoutts> kolmodin, have you looked at ndm's idea for putting the data much later in the file?
02:51:23 <dcoutts> it seems that'd save much more IO, since you don't have to skip but retain the data (which means it'll be in memory anyway)
02:51:29 <xpika2> does anyone here use the program screen?
02:52:03 <kfish> xpika2, yeah ...
02:52:04 <dcoutts> kolmodin, for that to work really well we need lazy bytestring to be a rope
02:52:37 <p_d> I use screen
02:52:46 <xpika2> do you ctrl-a <num> to switch windows?
02:53:06 <kfish> xpika2, if i have more than 2, yeah
02:53:29 <p_d> I never have more than 2, so just ctrl-a n
02:55:15 <kfish> i usually have 3 -- one for vim, one for ghci, one for a shell -- best IDE ever ;-)
02:55:29 <xpika2> what about one for IRC ?
02:56:07 <kfish> xpika2, good point, lambdabot is an essential part of any IDE
02:56:09 <p_d> I just have one for IRC, one for guile for arithmetic.. univ assumes anyone using IRC is a bot and bans, so I have to ssh out for it.
02:56:25 <xpika2> unless you have
02:56:28 <xpika2> @where goa
02:56:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
02:57:33 <xpika2> do you also use rlwrap?
02:57:45 <p_d> yes, for ocaml top level
02:58:09 <xpika2> it doesnt work for ghci :(
02:59:20 <p_d> is there a paste bin out there with haskell hilighting?
02:59:28 <xpika2> yes
02:59:36 <xpika2> http://hpaste.org
02:59:47 <xpika2> made specially and running on happs to boot!
03:00:57 <xpika2> @paste
03:00:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:01:07 <p_d> great thanks
03:01:45 <p_d> so I'm a haskell newb
03:01:51 <p_d> working on a scheme compiler to learn
03:02:21 <p_d> was able to use SYB for one of my transformations
03:02:23 <kolmodin> dcoutts: no, I haven't looked at ndm's idea
03:02:27 <p_d> but the others it doesn't seem general enough for
03:02:32 <kolmodin> dcoutts: is it on the ml?
03:02:38 <p_d> http://hpaste.org/196
03:02:51 <p_d> any ideas on how to eliminate boilerplate on the findclosvar?
03:02:53 <dcoutts> kolmodin, he posted something about it I think.
03:02:56 <p_d> (that's just a snippet of the code)
03:03:34 <p_d> Guh, left out the actual transformation
03:03:58 <kolmodin> dcoutts: ok, I'll try to look into it after work
03:04:14 <p_d> hm, no, findclosvar just isn't a transformation, but it still needs boilerplate elimination
03:04:21 <dcoutts> kolmodin, but the basic idea is simple, instead of a length prefix, make it a pointer to a different offset in the file, then you can put the actual data at the back of the file, so when you load, you can defer reading the tail of the file where the lazy data gets dumped
03:05:04 <dcoutts> kolmodin, so you'd do a linear read of the first part of the file and then scattered reads of the tail as things get forced
03:07:15 <dcoutts> kolmodin, constructing such a file is harder of course, since it can't be constructed linearly anymore
03:33:04 <Saizan> ?docs Data.ByteString
03:33:04 <lambdabot> Data.ByteString not available
03:37:47 <Saizan> if i want to dump a part of an infinte structure as a specific format (es. and infinite [[Int]] to a ppm), should i use Data.Binary?
03:40:50 <dcoutts> Saizan, no, Data.Binary is for serialising Haskell structures, not external formats
03:41:13 <dcoutts> dons, methinks we should change the name to Binary.Serialisation
03:41:57 <fasta>  
03:41:58 <fasta> data Foo = Foo {a::Int}
03:41:58 <fasta>          | Bar {b::Maybe Int}
03:41:58 <fasta>  
03:41:58 <fasta> g e@Foo{} = b e
03:41:58 <fasta>  
03:42:06 <fasta> Why does this even compile in the first place?
03:42:27 <fasta> AFAIK, this should be caught at compile time.
03:42:34 <Saizan> so the user can't control the serialization format, right?
03:43:32 <int-e> fasta: why? all the types fit.
03:43:53 <fasta> int-e: the types can fit, but it's complete non-sense.
03:44:30 <int-e> fasta: no, it defines g as forcing e and resulting in bottom ...
03:45:17 <int-e> fasta: that's perfectly normal Haskell code ;)
03:45:28 <fasta> int-e: I don't like Haskell bottoms.
03:45:49 <narain> <clueless-noob> so i can say x :: Foo = Foo {} and it will compile? i find that surprising. </clueless-noob>
03:46:53 <fasta> int-e: It should say: "Dear user, you are matching a value made by constructor Foo, but you can't call b on such a value. Please try again".
03:47:26 <int-e> fasta: it could give a warning maybe. I think it should compile.
03:47:47 <Saizan> fasta: if b is const "foo" you can :)
03:48:48 <fasta> int-e: Ok, whether it compiles is something you can discuss (since sometimes you want to change something to a program and don't care about some things you are not using).
03:49:11 <fasta> int-e: otherwise, I think every efficient test that can be implemented statically should be included.
03:49:25 <dons> Saizan: well, you can control the format to some extent, by writing your own types and instances
03:49:35 <dons> but that's a fairly special case
03:50:01 <dons> you can certainly have a go... or use the primitives from the get and put layer underneath
03:50:32 <Donner> fasta: Use g Foo{b = x} = x, and you get the same result. If you get bottom on the first pattern matching or on the second does not matter.
03:51:20 <Saizan> dons: is there some documentation? or i just use haddock on the sources?
03:51:38 <fasta> Donner: yes, but I argue that that's not a good thing.
03:51:59 <fasta> Multi-line IRC input is pretty nice, btw. Can irssi also do that?
03:54:02 <Donner> fasta: Every pattern matching has an implicit catchall calling "fail". If you do not want running into this langugae generated bottom, catch all cases youself.
03:55:57 <Donner> g Foo{b = Maybe x} = x; g Foo{a = x} = x
03:56:22 <fasta> Donner: I fail(heh) to see why defining the current behaviour has anything to do with what I said.
03:57:14 <Donner> What do you want? Calling a function with values outsite the domain of this function is erronous.
03:57:24 <fasta> Donner: It's not erronous at compile time.
03:57:29 <fasta> Donner: that's the problem.
03:57:51 <fasta> Donner: I made that example above to illustrate that.
03:57:51 <Donner> Functions with limited domains are perfectly legal.
03:58:04 <fasta> Donner: ...
03:58:30 <fasta> Donner: how did you understand the example I posted?
03:58:40 <Donner> Take Prelude.head as an example. Do you want a compile time error every time?
03:59:29 <fasta> Donner: when it's possible to detect statically, yes.
04:00:27 <fasta> The nice thing about Haskell is that you can destroy some code, compile it, see where it breaks and fix it.
04:00:38 <fasta> This model doesn't work in this case.
04:02:00 <kolmodin> dcoutts: yeah, I heard about that idea
04:02:19 <mnislaih> hiya kolmodin
04:03:02 <dons> Saizan: there's some docs, but I'd first try to just use Binary to do it
04:03:12 <dons> write your own instances for your types that pack it the way you need to
04:03:17 <dons> if its simple ,that'l work
04:05:02 <Donner> fasta: You need "assertions" like thos in Spark?
04:10:14 <kolmodin> hia mnislaih
04:10:57 * kolmodin is at work
04:11:01 <kolmodin> I'll check back later
04:11:09 <kolmodin> *poof*
04:11:15 <mnislaih> dons, got a second ? I wanted to show you something
04:11:37 <mnislaih> I was looking at how hs-plugins does type safety for dynamically linked code
04:12:13 <mnislaih> we are doing something quite similar in the ghci debugger, but more like proof-carrying code
04:12:24 <dons> ah ok. yeah?
04:12:24 <mnislaih> maybe you want to look at it
04:12:27 <dons> sounds nifty
04:12:39 <dons> i'm just bout to head to bed, but if you want to mail me your ideas...
04:12:40 <mnislaih> we are doing 'type reconstruction' of untyped heap values
04:12:50 <dons> ah!
04:12:53 <mnislaih> yep, I'll send you a draft paper
04:13:21 <dons> yeah, please do
04:18:23 <xpika2> is there a way to write x <- list ; y <- list       like        (x,y) <- (list,list)
04:19:26 <wilx|wrk> Humm, add return?
04:19:36 <wilx|wrk> (x, y) -> return (list, list)?
04:19:53 <dons> :t (x,y) <- liftM2 (,) (return 1) (return 2)
04:19:54 <wilx|wrk> Err <- of course.
04:19:55 <lambdabot> not an expression: `(x,y) <- liftM2 (,) (return 1) (return 2)'
04:20:03 <dons> :t do (x,y) <- liftM2 (,) (return 1) (return 2) ; return (x,y)
04:20:05 <lambdabot> forall a a1 (m :: * -> *). (Num a, Num a1, Monad m) => m (a, a1)
04:20:24 <dons> :t do (x,y) <- liftM2 (,) getChar getChar ; return (x,y)
04:20:26 <lambdabot> IO (Char, Char)
04:20:32 <dons> xpika2: like that?
04:21:03 <dons> TMTWWTDI!! :)
04:21:09 <dons> s/W/O/ oops
04:21:26 <xpika2> dons: yep like that
04:21:40 <dons> night all! happy hacking
04:21:43 <xpika2> what does your acronym stand for?
04:21:50 <dons> that's the old perl motto
04:21:59 <xpika2> oh ok
04:22:01 <dons> There's More Than One Way To Do It
04:22:02 <xpika2> i know that one
04:22:03 <xerox> > do (x,y) <- liftM2 (,) [1..3] [4..6]; return (x,y)
04:22:04 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:22:19 <dons> special
04:22:41 <kowey> > liftM2 (,) [1..3] [4..6]
04:22:43 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
04:22:47 <dons> a zippy zip.
04:22:56 <xerox> cartesian product
04:23:06 <dons> ah yes. list monad fun fun
04:23:10 <xerox> > sequence [[1..3],[4..6]]
04:23:12 <lambdabot>  [[1,4],[1,5],[1,6],[2,4],[2,5],[2,6],[3,4],[3,5],[3,6]]
04:46:13 <bakert> What's the best way to format a ClockTime as a String?  I need a 2007-01-30 type representation not the show default.
04:49:31 <kowey> bakert: i think WASH has an iso8601 formatter, as does darcs
04:49:46 <bakert> thanks
04:49:48 <kowey> (although maybe that's just overkill)
04:50:09 <bakert> (could be, all the formatting functions i can find work on calendar time which i'd rather stay away from)
04:54:55 <roconnor> TimeLib seems much better than the standard time library
04:55:01 <roconnor> (although I've never used it)
04:55:10 <roconnor> oh
04:55:20 <roconnor> as of GHC 6.6, it is the standard time library
04:55:24 <roconnor> that's good ;)
04:57:00 <bakert> I'm using 6.6's System.Time but it doesn't seem to have a way to turn a ClockTime into an ISO 8601 (yyyy-mm-dd ...) format String.
04:57:10 <kowey> roconnor: ah, you mean Data.Time instead of System.Time?
04:57:38 <bakert> ?hoogle ClockTime -> String
04:57:39 <lambdabot> No matches, try a more general search
04:59:09 <roconnor> yes Data.Time
04:59:51 <kowey> bakert: note the new Data.Time.LocalTime.formatTime
05:02:49 <roconnor> @hoogle iso
05:02:50 <lambdabot> System.Locale.iso8601DateFormat :: Maybe String -> String
05:02:50 <lambdabot> Char.isOctDigit :: Char -> Bool
05:02:50 <lambdabot> Network.Socket.AF_ISO :: Family
05:05:26 <xerox> > System.Locale.iso8601DateFormat Nothing
05:05:27 <lambdabot>   Not in scope: `System.Locale.iso8601DateFormat'
05:06:16 <bakert> kowey, so does Data.Time replace System.Time?
05:06:27 <bakert> Or are they equal for the moment?
05:06:28 <roconnor> what happens when you show a UTCTime?
05:06:51 <roconnor> bakert: my limited understanding is that Data.Time replaces System.Time.
05:06:53 <bakert> i'm using toUTCTime and formatCalendarTime now.
05:06:56 <kowey> bakert: i confess that i just learned of its existence today
05:06:59 <bakert> !
05:07:18 <kowey> but it looks like it gets it more right... System.Time has a bad habit of completely disregarding the locale, despite the doc
05:07:38 <bakert> goddamn we need to decimalise the date system.
05:07:42 <kowey> (i mean, it's fine if it disregards it, but it claims to use local conventions when it doesn't, at least in ghc 6.4)
05:08:14 <roconnor> bakert: see julian dates
05:08:30 <roconnor> today is 2454131.0464
05:08:42 <bakert> let's just all move to epoch millis.
05:08:45 <bakert> What time is it?
05:08:47 <bakert> 23789794827184789124789
05:08:50 <bakert> oh.  thanks.
05:08:52 <roconnor> OTOH, it is a bit unclear if julian days start a noon, or midnight UTC.
05:08:52 <bakert> !!!
05:09:11 <roconnor> http://aa.usno.navy.mil/data/docs/JulianDate.html
05:09:12 <lambdabot> Title: Julian Date Converter
05:09:13 <gotaku> What monads should I absolutely know?
05:09:13 <bakert> i was born at -8938293280
05:09:28 <kowey> i've always wondered what it would be like if we did away with timezonezs and just shifted our business hours accordingly
05:09:29 <bakert> that kind of thing.  great
05:09:35 <bakert> especially for people born in 1970.
05:09:35 <kowey> timezonezs?!
05:09:45 <bakert> there will be no timezones once i am dictator.
05:09:50 <sieni> kowey: it would be nice, if everybody used EET
05:09:53 <bakert> (of the world)
05:10:34 <kowey> :-)
05:10:40 <pjd_> gotaku: define "should absolutely know"
05:10:53 <bakert> hello malebria i have just declared myself dictator of the world.  it's going quite well.
05:10:59 <sieni> pjd_: define "define"
05:11:27 <pjd_> sieni: define, v.: determine the nature of
05:11:31 <pejo> gotaku, Mark P. Jones has a good article from some summerschool in 95 on his homepage.
05:12:18 * SamB thinks he's had a dream featuring killall -9
05:12:28 <malebria> Good morning.
05:12:32 <pjd_> gotaku: it will generally depend on what you aim to do :)
05:12:55 <SamB> bakert: has anyone asked you to do some dictation yet?
05:13:17 <bakert> you are the first to suggest such a thing, and thus you shall be shot at dawn.
05:13:48 <SamB> I didn't ask you to do any dictation!
05:13:57 <SamB> therefore, you should not do any dictation!
05:14:14 <bakert> don't make excuses reactionary pig dog!
05:14:25 <bakert> guards!
05:14:46 <SamB> stop with the dictation
05:18:04 <gotaku> I'm still having trouble with the State monad...
05:18:15 <SamB> oh?
05:18:19 <SamB> what kind of trouble?
05:18:21 <bakert> What's the flag to tell ghci to look in a particular directory for source file?  --hs-source-dirs???
05:18:28 <SamB> -i, I think
05:18:45 <SamB> not positive
05:18:45 <roconnor> what is EET?
05:18:46 <gotaku> I'm trying to create a list of random Ints but I can't seem to figure out how.
05:19:06 <SamB> gotaku: well, you'll need an RNG.
05:19:27 <SamB> @doc System.Random
05:19:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
05:19:32 <SamB> did you want to use that?
05:20:30 <roconnor> Random number generation in Haskell is a fun-filled monadic adventure.
05:20:41 <kfish> gotaku, a randomly generated list of ints as part of the state?
05:20:46 <dylan> if bakert is to be a dictator, he should change his name to Richard Potato.
05:20:48 <bakert> SamB, thanks.
05:20:57 <bakert> dylan, why Richard Potato?
05:21:09 <sehute> Interested in a few lines of functional-ish programming in Python? http://deadbeefbabe.org/paste/3482
05:21:15 <dylan> bakert: because's it is the long form of Dick Tater.
05:21:25 <dylan> *because.'
05:21:52 <bakert> I see.
05:22:12 <SamB> sehute: why does it say "twisted pastebin" at the top? it isn't at tm.com!
05:22:21 <sehute> SamB: No idea
05:22:24 <kowey> (and his children, would be tater tots, obviously... hmm maybe not everybody had those at school lunch)
05:22:26 <bakert> Like the mummy and daddy potato who want their child to marry a King Edward and not John Motson/John Madden.
05:22:34 <bakert> Because he is a Common Tater.
05:22:39 <sehute> SamB: I found the url in the topic of #python
05:22:41 <SamB> maybe twisted.web comes with a pastebin...
05:22:49 <gotaku> I'm trying to thread StdGen through a recursive list building function.
05:22:58 <SamB> gotaku: okay
05:22:59 <gotaku> Just to try and figure out how State works.
05:23:02 <bakert> (hmm that is a culturally specific joke requiring a famous commentator from the region of the jokee).
05:23:13 <SamB> gotaku: that should be fairly simple
05:26:43 <kfish> sehute, http://gnosis.cx/publish/programming/charming_python_13.html (and also 16, 19) -- referenced from http://gnosis.cx/TPiP/
05:26:47 <lambdabot> Title: CHARMING PYTHON #13 (20000155) -- Functional Programming in Python --
05:26:47 <SamB> sehute: oh, hmm, it says it is powered by nevow...
05:28:25 <roconnor> gotaku: have you seen MonadRandom?
05:28:30 <sehute> kfish: Cool, thanks! :)
05:28:39 <roconnor> http://haskell.cs.yale.edu/haskellwiki/New_monads/MonadRandom
05:28:40 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
05:29:20 <gotaku> roconnor, I'm just trying to figure out how State works.
05:29:41 <roconnor> ah okay
05:30:16 <kowey> gotaku: is there something in particular that's tripping you up?
05:30:30 <kowey> gotaku: one thing that got me early on was the runState function
05:30:57 <SamB> sehute: is map5 supposed to be calling map4?
05:31:06 <xpika2> > ((concatMap (\(x,y)-> [x,y]) .) . zip) "Ionyual" " w o l "
05:31:07 <lambdabot>  "I own you all "
05:32:05 <kowey> gotaku: another source of confusion is between the thing we're passing around and the State monad itself (i like to call the former a 'ticket' and just avoid the word State)
05:32:25 <qwr> @pl (\(x,y)-> [x,y]) .)
05:32:25 <lambdabot> (line 1, column 19):
05:32:25 <lambdabot> unexpected ")"
05:32:25 <lambdabot> expecting white space or simple term
05:32:32 <qwr> @pl (\(x,y)-> [x,y])
05:32:32 <lambdabot> uncurry ((. return) . (:))
05:32:40 <SamB> I would call  the former the state and the latter State
05:33:13 <xpika2> it became bigger
05:33:27 <kowey> (in real code, i sometimes use Status and State)
05:33:43 <xpika2> @pl (\x-> [x])
05:33:43 <lambdabot> return
05:34:37 <xpika2> concat $ zipWith (\x y-> [x,y]) "Ionyual" " w o l "
05:34:39 <xpika2> > concat $ zipWith (\x y-> [x,y]) "Ionyual" " w o l "
05:34:40 <lambdabot>  "I own you all "
05:34:58 <xpika2> @where merge
05:34:59 <lambdabot> I know nothing about merge.
05:35:04 <xpika2> @hoogle merge
05:35:05 <lambdabot> Data.Graph.Inductive.Internal.Heap.merge :: Ord a => Heap a b -> Heap a b -> Heap a b
05:35:05 <lambdabot> Control.Concurrent.mergeIO :: [a] -> [a] -> IO [a]
05:35:05 <lambdabot> Text.ParserCombinators.Parsec.Error.mergeError :: ParseError -> ParseError -> ParseError
05:35:32 <fasta> *** Exception: Module main:Foo was not loaded under debugging mode. Enable debugging mode and reload it
05:35:33 <fasta> Sure... but how?
05:37:14 <fasta> (This is when I try do use the :breakpoint feature of 6.7 )
05:38:03 <xpika2> night all!
05:40:04 <fasta> Never mind
05:44:39 <gotaku> I'm confused how the recursion should tie in.
05:44:59 <bakert> @localtime xpika
05:45:19 <bakert> doh
05:45:27 <kowey> gotaku: maybe you could pastebin a rough example what you're trying to get
05:46:10 <kowey> gotaku: i would personally avoid confusing myself trying to mix State with recursion, maybe something simpler would be better for this
05:59:00 <chessguy> 'morning haskellers
06:00:56 <malebria> dons: Just sent you a patch for typeOf
06:03:52 <chessguy> @type (=<<)
06:04:10 <chessguy> ?hoogle (=<<)
06:04:51 <chessguy> @bot
06:05:20 <notsmack> lambdabot: wake up!
06:05:32 <notsmack> @botsnack
06:06:05 <pjd_> (=<<) :: (Monad m) => (a -> m b) -> m a -> m b
06:06:06 <gotaku> Bah, I gave up and just made a none monadic function that generates a random list of Ints.
06:06:25 <sehute> SamB: No, it was a bug in map5 :( yield doesn't seem to work well after all
06:06:30 <sehute> SamB: well spotted
06:07:20 <sehute> oh well, I'm off for now
06:07:23 <sehute> be well
06:08:56 <kowey> gotaku: ok, it'll make more sense later (also I think we should be able to show you how to _use_ State without neccesarily having to understand it)
06:08:58 <malebria> Is there a circular list data type in the libraries?
06:09:02 <malebria> Or somewhere else?
06:09:48 <roconnor> > cycle [1,2,3]
06:10:16 <sieni> or even
06:10:29 <sieni> > let x = [1,2,3] ++ x in x
06:11:02 <malebria> This is good.
06:11:05 <malebria> But not very good.
06:11:22 <malebria> > cycle [1, 2, 3] == cycle [2, 3, 1]
06:11:37 <sieni> it's EXTREMELY good ;-)
06:11:46 <chessguy> ?src cycle
06:11:50 <chessguy> oops
06:11:52 <roconnor> cycle [1,2, 3] === 1:(cycle [2,3,1])
06:12:15 <pjd_> malebria: termination?
06:12:23 <malebria> roconnor: sure, but it'd be good to have cycle [1, 2, 3] == cycle [2, 3, 1]
06:12:29 <fasta> How can I force a sub value in the ghci breakpoint feature?
06:12:37 <fasta> Or force the whole thing?
06:12:49 <malebria> pjd_: No, I just want a data type that works like this.
06:12:50 <roconnor> malebria: that doesn't seem possible in any language.
06:13:05 <malebria> roconnor: not using infinite lists.
06:13:13 <malebria> [1, 2, 3] == [3, 2, 1]
06:13:17 <pjd_> malebria, roconnor: Richard Kieburtz's codata/corecursion paper defines one
06:13:18 <roconnor> what operations do you want to do on this data type?
06:13:23 <malebria> [1, 2, 3] == [3, 1, 2]
06:13:24 <chessguy> haskell has sets
06:13:32 <malebria> chessguy: I need order.
06:13:52 <malebria> Is it circular list, the right name for it?
06:13:55 <chessguy> well then [1, 2, 3] != [3,1,2]
06:14:03 <chessguy> ohhh
06:14:08 <chessguy> sorry, now i see what you're saying
06:14:10 <malebria> chessguy: =D
06:14:14 * chessguy shuts up
06:14:40 <bd_> cycle [1,2,3] == drop 2 (cycle [2,3,1]) ?
06:14:43 <malebria> And I'd like [1, 2, 3] == [3, 2, 1] also.
06:14:50 <bd_> malebria: Data.Set?
06:14:55 <roconnor> suppose I give you an x such taht x == [1,2,3] == [2,3,1]
06:15:02 <malebria> bd_: 12:10 < malebria> chessguy: I need order.
06:15:04 <roconnor> what would you like to do with such an x?
06:15:11 <sieni> malebria: do you want to be able to add stuff in your lists?
06:15:21 <malebria> I want to use it to model polygons.
06:15:29 <malebria> The contour of a polygon is of this data type.
06:15:40 <malebria> sieni: not much.
06:16:21 <chessguy> doesn't seem like it would be that hard
06:16:33 <sieni> just make an abstract datatype or something
06:16:58 <malebria> sieni: Yes, I'm going to do it.
06:17:01 <chessguy> define 'cycles xs' to give all the rotations of the list (so it's [[a]])
06:17:05 <roconnor> malebria: so what operations do you want to do?
06:17:16 <malebria> sieni: I just asked cause maybe this was already done.
06:17:28 <malebria> roconnor: not much, the main point is really instance Eq
06:17:42 <roconnor> ah yes
06:17:58 <chessguy> and then circularList1 == circularList2 iff circularList2 is a member of 'cycles circularList1'
06:18:02 <malebria> http://209.85.165.104/search?q=cache:G2ykGjsFOkkJ:www.cs.nott.ac.uk/~nhn/TFP2006/Papers/27-GhaniHamanaUustaluVene-CyclicStructuresAsNestedDatatypes.pdf+haskell+clist&hl=en&ct=clnk&cd=2
06:18:06 <hyrax42> ?hoogle (a -> a -> Ord) -> a -> a -> a
06:18:13 <roconnor> so you will want to newtype lists, and define your own equaltiy function.
06:18:18 <chessguy> hyrax42, the bot's down
06:18:27 <chessguy> malebria, does that make sense?
06:18:35 <hyrax42> how can I be expected to work like this!?
06:18:46 <chessguy> hyrax42, shameful, isn't it
06:18:46 <dino-> hyrax42: heh
06:19:19 <fasta> Never mind, again.
06:19:20 <malebria> chessguy: sure.
06:19:33 <chessguy> although, O(n) equality checking isn't exactly ideal
06:19:52 <pjd_> malebria: if you can assume no duplicate vertexes, you could represent it simply as a list starting at some minimum vertex
06:20:23 <pjd_> (where "minimum" is defined pretty arbitrarily)
06:21:08 <robreim> ?where zlib
06:21:21 <chessguy> robreim, bot's doewn
06:21:24 <chessguy> *down
06:21:28 <robreim> oh :)
06:21:38 <roconnor> of course, if we are talking about polygons in the real plane, then you never want to use equality comparision anyways.
06:21:40 <malebria> pjd_: yes, that's a possibility too.
06:21:56 <malebria> pjd_: but I'll always have to check list == reverse list
06:22:37 <pjd_> malebria: you could normalize that too
06:22:43 <chessguy> i don't think you're going to get less than O(n) equality checking
06:23:09 <malebria> chessguy: O(n) is very good.
06:23:27 <twanvl> robreim: darcs get http://haskell.org/~duncan/zlib
06:23:32 <malebria> I think it's impossible to do Eq of any data type with less than O(n)..
06:23:47 <chessguy> malebria, good point
06:23:54 <pjd_> won't checking against cycles be n^2?
06:24:22 <robreim> twanvl: yeah, found it. Thanks :)
06:24:27 <malebria> pjd_: I think it's n^2
06:24:27 <roconnor> pjd_: I think you can do it in O(2n)
06:24:29 <chessguy> for a list of n items, there are n different cycles
06:24:57 <chessguy> and so you just have to check whether a second list is one of those n cycles
06:24:58 <roconnor> keep rotating one list until their inital points match (upto n)
06:25:16 <chessguy> O(2n) is O(n), roconnor :)
06:25:22 <dcoutts_> robreim, it's in hackage now too
06:25:23 <roconnor> yes.
06:25:25 <pjd_> roconnor: right, but then you're no longer using a straightforward "member of" test
06:25:28 <hyrax42> how do you enable pattern guards
06:25:36 <roconnor> pjd_: ah
06:25:51 <malebria> I think I'll write Data.CList then.
06:26:02 <chessguy> pjd_, look, take a list, say [1,2,3,4,5]
06:26:30 <pjd_> chessguy: even that rotation scheme is still N^2 worst case
06:26:44 <chessguy> ohh, i see
06:26:57 <malebria> I think it's O(n)
06:26:57 <chessguy> becase you have to check the list against each list in the list of lists
06:27:01 <chessguy> say that 10 times fast
06:27:14 <pjd_> the ones that do better involve clever exploitation of shared substructure... i forget the name, but several compression algorithms use the technique, IIRC
06:27:16 <malebria> Actually 3n
06:27:24 <chessguy> well, it's not n^2
06:27:27 <roconnor> newtype CList a = CList (List a) ?
06:27:34 <pjd_> anyway, with normalization, it's trivially O(n)
06:27:36 <chessguy> because any time the first element isn't the same, you throw that list out right away
06:27:41 <dcoutts_> @tell ndm the gtk2hs threaded rts demo prog is working fine in windows
06:27:52 <dcoutts_> arg! no lambdabot!
06:28:10 <malebria> roconnor: data CList a = Nill | Cons a CList
06:28:30 <roconnor> hmm
06:28:37 <pjd_> chessguy: right, and what if all the elements are equal? :)
06:28:40 <dancor> why don't you see more letter reuse like:   f :: Handler h => h -> ..   f h = ..
06:28:49 <pjd_> or half of them
06:29:10 <pjd_> or you have a long list of two elements, alternating
06:29:16 <dancor> the a,b stuff seems not that far from violating do-not-number-things-that-should-not-be-numbered
06:29:19 <fasta> What do you think of the ghci debugger?
06:29:26 <malebria> So the worst case is O(n^2)?
06:29:27 <roconnor> malebria: any reason not to use newtype?
06:29:34 <fasta> (I think it's worthless.)
06:29:38 <chessguy> i assume we're talking about distinct members
06:29:59 <fasta> You can't even force a value, you can only force it to get its type.
06:30:01 <chessguy> malebria, is that right?
06:30:07 <malebria> roconnor: List a == [a]?
06:30:16 <malebria> chessguy: I'm wondering...
06:30:33 <roconnor> oh right, newtype CList a = CList [a]
06:30:42 <chessguy> malebria, can any member of a circular list appear more than once in the list?
06:30:56 <pjd_> malebria: yeah, then it's between 1n and 2n (non-O-notation)
06:31:34 <malebria> chessguy: I don't think so.
06:31:38 <chessguy> so let's see: cycles [1,2,3,4,5] =  [[1,2,3,4,5],[2,3,4,5,1],[3,4,5,1,2],[4,5,1,2,3],[5,1,2,3,4]]
06:31:51 <malebria> pjd_: the worst case?
06:32:02 <chessguy> what's the worst case for the list we want to compare to this?
06:32:54 <pjd_> malebria: 2n, if you the comparison starts at the pessimal offset
06:32:56 <malebria> chessguy: I think it can have repetition.
06:33:07 <malebria> pjd_: yes, you're right.
06:34:01 <malebria> @let cycles list = tail $ zipWith (++) (tails list) $ inits list
06:34:09 <dancor> can   f x = a x >> b x   be point-free-ized?
06:34:33 <dancor> actually can't \bot tell me
06:34:42 <dino-> dancor: bot is sick
06:35:33 <xerox> join ((>>) .) . (. a) . b -- wild guess
06:35:33 <chessguy> hm, lambdaweb is down too
06:35:50 <xerox> Wrong..
06:36:37 <dancor> so basically nothing simple
06:36:43 <xerox> liftM2 (>>) a b
06:36:57 <xerox> liftM2 (>>)
06:37:19 <xerox> Simple enough.
06:41:33 <dancor> hm xerox, :t liftM2 (>>)   is   m1 (m a) -> m1 (m b) -> m1 (m b)
06:41:37 <malebria> roconnor: yes, it's a possibility.
06:42:15 <dancor> > (liftM2 (<<) putStr putStrLn) "hi"
06:42:16 <xerox> dancor: right
06:42:52 <mnislaih> anyone who can speak Turkish around ?
06:43:28 <bd_> dancor: m1 matches (t ->)
06:44:00 <dancor> No instance for (Monad ((->) String)) arising from use of `liftM2' at a.hs:3:4-9
06:44:07 <dancor> that's what ghc says
06:44:23 <xerox> :m + Control.Monad.Reader
06:44:26 <njd> @hoogle sendMsg
06:45:00 <dancor> thanks
06:45:06 <xerox> you're welcome.
06:45:12 <bd_> hmm
06:45:34 <dancor> so is   import Monad   just synonymous to   import Control.Monad
06:45:50 <sjanssen> dancor: not quite
06:46:12 <sjanssen> Monad is the legacy module for compatibility with Haskell '98
06:46:36 <dancor> hm so why is Reader needed
06:46:38 <dancor> there
06:47:04 <fasta> I wonder how old legacy code will be in 2020. 3 days?
06:47:15 <bd_> dancor: it exports the instance for Monad (->).
06:47:22 <sjanssen> the "instance Monad ((->) a)" is in Control.Monad.Reader
06:47:47 <dancor> so is using liftM2 (<<) here considered cool or obfuscatory
06:48:06 <sjanssen> dancor: if you have a recentish compiler release you can import Control.Monad.Instances instead
06:48:08 <dancor> i guess it's nice to specify one less arg for f
06:48:08 <bd_> can't it be both? ;)
06:48:13 <sjanssen> dancor: somewhat obfuscatory
06:48:33 <dancor> k
06:48:37 <fasta> dancor: The more you name your stuff in domain names, the easier it's to understand.
06:49:12 <fasta> dancor: Well, that holds for me, at least.
06:49:15 <chessguy> fasta, what do you mean by 'domain names' here?
06:49:27 <bd_> I've been using liftM* a lot lately for tree-walking stuff. I do wish Data.Generics could change from (SomeType x) to (SomeType y)....
06:49:57 <fasta> chessguy: When you are building a chess engine, you name your board chessboard, and not matrix.
06:50:03 <xerox> bd_: doesn't fmap does exactly that?
06:50:06 <dancor> when ppl have an instance of a class do you typically make the class the last arg of its fcns?
06:50:10 <chessguy> fasta, ok
06:50:11 <Jaak> > liftM2 (>>) undefined (*) 2 5
06:50:21 <fasta> chessguy: same with computations
06:50:31 <dancor> class Handler h where myFcn :: h -> .. -> ..    or .. -> h -> ..
06:50:31 <fasta> chessguy: For example: I have a function called ignore.
06:50:47 <dancor> Handler h =>
06:51:02 <njd> @docs connectTo
06:51:06 <fasta> chessguy: it returns the graph as it were, but doesn't contain the node given in its paramter.
06:51:15 <fasta> parameter*
06:51:15 <njd> @users
06:51:30 <chessguy> fasta, ok
06:51:41 <bd_> xerox: not quite, I have to do some transformations along the way...
06:51:42 <pjd_> f = return (>>) `ap` show `ap` show
06:51:49 <xerox> dancor: you want to make the more likely to change arguments last
06:51:53 <fasta> I also find that using composition makes your code less easy to debug.
06:52:11 <fasta> Essentially you need access to the intermediate values.
06:52:16 <bd_> xerox: more precisely, it all has to happen in a state monad :/
06:52:17 <fasta> That's a tools problem.
06:52:20 <Syzygy-> @type return (>>) `ap` show `ap` show
06:52:32 <pjd_> return (>>) `ap` show `ap` show :: (Show a) => a -> [Char]
06:52:58 <Syzygy-> Lambdabot doesn't do type lookups anymore?
06:53:17 <Syzygy-> ?index ap
06:53:21 <bd_> lambdabot is dead :/
06:53:25 <bd_> ?botsnack
06:53:26 <Syzygy-> Awwwwwwww. :(
06:53:29 <fasta> lambdabot is on strike.
06:53:30 <Syzygy-> ?botsnack
06:53:42 <chessguy> it demands more lambdas
06:53:46 <bd_> Syzygy-: She's not being fooled by our bribes anymore...
07:23:45 <ski> @botsmack
07:24:17 <fasta> Nice misspelling you got there.
07:24:32 <sjanssen> @yow
07:25:16 * earthy sniffs
07:25:18 <earthy> no lambdabot love
07:25:20 <sjanssen> The BOT has gone MISSING in a bowl of BANANA PUDDING
07:25:38 <bakert> ?tell god The BOT has gone MISSING in a bowl of BANANA PUDDING
07:25:38 <gotaku> What's template haskell?
07:26:00 <bakert> gotaku, some kind of bit-dynamic-at-runtime version.  not sure exaclty
07:26:08 <fasta> gotaku: something rather impopular and underdocumented.
07:26:37 <fasta> gotaku: There's a research paper you can read to get the idea.
07:27:03 <earthy> template haskell is an extension to haskell that allows you to generate haskell at compiletime
07:27:35 <gotaku> I see.
07:27:36 <earthy> that is, you can inspect the program that is being compiled using haskell functions and generally modify it's ast
07:28:07 <malebria> That rotation definition from yesterday is wrong...
07:28:26 <malebria> It gives rotation [] = [] instead of [[]]
07:28:32 <gotaku> The explaination of the Reader monad and the example given in the All About Monads article is horrible...
07:30:13 <pjd_> gotaku: syntax macros for Haskell, in other words
07:30:46 <earthy> pjd_: not really, as it doesn't allow you to change the parser
07:31:13 <pjd_> well, neither do the (syntax) macros in lisp
07:31:13 <fasta> AFAIK, the authors of the TH paper admit that it's less flexible than Scheme macros.
07:31:16 <pjd_> for example
07:32:36 <pjd_> fasta: due to Haskell's rich syntax, or a TH limitation?
07:33:09 <fasta> TH limitation, IIRC.
07:33:31 <fasta> It was >8 months ago, that I read it.
07:35:20 <njd> @users
07:40:45 <chessguy> njd, no bot
07:40:48 <profmakx> i`ve got a strange problem with darcs under freebsd 6.2-release. darcs get works for lambdabot, yi and others but darcs pull complains because it gets 404 pages for some files (_darcs/format)
07:44:21 <kowey> profmakx: what version of darcs is this?
07:45:34 <profmakx> kowey  1.0.8 as well as 1.0.9rc2
07:45:58 <profmakx> whereas 1.0.8 is from the ports tree and I compiled 1.0.9 this morning
07:51:19 <kowey> profmakx : that sounds quite odd... could you send a report to bugs@darcs.net ?
07:52:03 <gotaku> Is there a helper function to print an IO String to the screen?
07:53:23 <gotaku> Uhh, I forgot about how >>= worked.
07:53:24 <profmakx> kowey: okay, i will do that
07:53:33 <sjanssen> gotaku: there is putStrLn :: String -> IO ()
07:53:43 <edwinb> foo str = do x <- str; putStrLn x -- would do it
07:53:53 <fasta> gotaku: getLine >>= putStrLn
07:54:06 <gotaku> Yes, I remembered.
07:54:41 <edwinb> Oh yes, people who can think in terms of '>>=' will find a neater way ;)
07:55:23 <sjanssen> join . fmap putStrLn $ getLine
07:57:02 <fasta> sjanssen: What fmap instance is selected?
07:57:11 <fasta> or Functor instance, I mean
07:57:26 <fasta> Monad a?
07:57:26 <kpreid> @type fmap putStrLn
07:57:37 <fasta> The bot is _dead_.
07:58:03 <kpreid> !type fmap putStrLn
07:58:10 <swhask> forall (f :: * -> *). (Functor f) => f String -> f (IO ())
07:58:35 <kpreid> !type join . fmap putStrLn
07:58:37 <swhask> IO String -> IO ()
07:59:24 <kpreid> @type \f g -> join . fmap f $ g
07:59:27 <kpreid> !type \f g -> join . fmap f $ g
07:59:29 <swhask> forall a (f :: * -> *) a1. (Monad f, Functor f) => (a1 -> f a) -> f a1 -> f a
08:00:03 <fasta> !type join
08:00:04 <kpreid> !type =<<
08:00:05 <swhask> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:00:07 <swhask> parse error on input `=<<'
08:00:12 <kpreid> !type (=<<)
08:00:13 <swhask> forall b (m :: * -> *) a. (Monad m) => (a -> m b) -> m a -> m b
08:00:33 <kpreid> fmap and join get you >>= again
08:00:35 <fasta> !info putStrLn
08:00:35 <swhask> putStrLn
08:05:01 <gotaku> What is ReaderT supposed to do?
08:05:29 <kpreid> !type ReaderT
08:05:31 <swhask> forall a (m :: * -> *) r. (r -> m a) -> ReaderT r m a
08:05:57 <kpreid> add an environment
08:06:15 <kpreid> that is, a value which can be retrieved at any time within the monad
08:08:04 <gotaku> Can the value be updated?
08:08:24 <bd_> gotaku: it can be updated locally, as in: local (const "foo") someComputation
08:10:51 <gotaku> Is there a somewhat large gtk2hs program I can look at?
08:11:04 <gotaku> Something alitle more complicated the the included demos.
08:11:47 <dcoutts_> gotaku, http://www.cs.kent.ac.uk/projects/pivotal/downloads.html
08:19:53 <sjanssen> fasta: if you're still wondering, instance Functor IO is used in my example
08:20:00 <gotaku> What's a finite map?
08:20:46 <sjanssen> a data structure that associates keys with values
08:21:59 <sjanssen> gotaku: if you're referring to the module Data.FiniteMap, it has been deprecated.  You should use Data.Map instead
08:25:24 <blsecres> does anyone know if the pages at http://cvs.haskell.org/Hugs/pages/libraries/ are available for cvs/darcs readonly checkout or as a tar file from somewhere?
08:27:57 <foof> diff [] b = []
08:28:04 <foof> diff x:xs b = if find x b then diff xs b else x : diff xs b
08:28:24 <bringert> blsecres: you mean the actually html files?
08:28:27 <jlouis> gotaku, a function f : X -> Y, where X is a finite set
08:28:29 <hpaste>  beelsebob pasted "Spot the type error" at http://hpaste.org/197
08:28:32 <blsecres> bringert: yes
08:28:40 <beelsebob> anyone see what the hell I've done wrong there?
08:28:46 <bringert> blsecres: they might be included in binary Hugs distributions
08:28:50 <foof> Why is that a parse error?
08:28:59 <bakert> If I have data Foo = Bar | Baz, how can I get Bar from "Bar"?  With read?
08:29:07 <bringert> blsecres: or you could build your own from a Hugs source tarball I suppose
08:29:28 <jlouis> bakert, read :: Foo, I presume
08:29:29 <blsecres> bringert: that'd require a working haddock wouldn't it?
08:29:30 <bringert> foof: no ( ) around pattern
08:29:33 <bringert> blsecres: yes
08:30:04 <foof> bringert: Ah, that was it, thanks!
08:30:13 <bakert> jlouis, so exact syntax would be: (read "Foo" :: Foo) or ((read "Foo") :: Foo) or ???
08:30:51 <foof> Also, is there a more idiomatic way and/or standard definition of set difference?
08:31:03 <blsecres> I'll just mirror them with wget I guess
08:31:19 <chessguy> can a record contain a function as a member?
08:32:22 <bakert> chessguy, yes i am pretty sure i do that in places
08:33:28 <jlouis> chessguy, sure!
08:33:51 <jlouis> bakert, you'll have to try it. I can't remember the parser straight out of my head ;)
08:33:55 <chessguy> something like data Foo = Foo { bar :: a -> b, ... }
08:34:36 <bakert> chessguy, yes with brackets not sure if they are necessary
08:34:46 <bakert> data Foo = Foo { bar :: (\a -> b) }
08:34:53 <bakert> oh and a backslash for "lambda"
08:35:05 <bakert> as i've written it above
08:35:13 <chessguy> mmm, why do you need the backslash?
08:35:25 <bakert> not sure
08:35:27 <bakert> maybe you don't
08:35:30 <chessguy> oh, that should say bar :: A -> B
08:35:37 <bakert> that's how i write all my anonyous functions
08:35:51 <chessguy> well, i don't want them to be anonymous
08:36:03 <bakert> ah yes that's a good point.
08:36:07 <bakert> i'm getting mixed up
08:36:10 <bakert> it's the type sig that goes there
08:36:16 <bakert> so Thing -> Donkey
08:36:21 <bakert> not (\a b -> c)
08:36:23 <bakert> apols
08:36:26 <chessguy> right, if you really want to produce donkeys :)
08:36:29 <bakert> right
08:36:30 <bakert> !
08:37:31 <bakert> read comes from deriving Show, right?
08:38:34 <bakert> nope, you have to derive Read, too. that's why my read wouldn't work!
08:38:34 <Igloo> deriving Read
08:39:06 <bakert> Thanks Igloo, i just worked it out!
08:39:38 <Igloo> That'll teach me to glance away from IRC for a minute  :-)
08:39:55 <bakert> ;)
08:40:42 <Saizan> you don't even need Show :)
08:41:12 <dcoutts_> Igloo, do you know how ghc does the split .o files on win32? It works for base and a couple other big libs, but I can't make it work for my own lib.
08:41:34 <Igloo> dcoutts_: The build instructions tell you not to do it on Win32
08:41:49 <dcoutts_> Igloo, I don't mean split-objs
08:42:01 <bringert> kosmikus: in lhs2TeX, is there a way to achieve the following without using ^ and ^^? In Java code, I want an identifier followed by ( or < to not have space between them, and > followed by identifier should have space between. Currently only Ident< is handled they way I want
08:42:02 <dcoutts_> Igloo, I mean the >64k relocs problem
08:42:27 <Igloo> Oh, no idea then
08:42:39 <dcoutts_> Igloo, in ghc-6.4.2 there's HSbase.o (0 size) and HSbase1.o HSbase2.o and HSbase3.o
08:43:15 <dcoutts_> Igloo, and the base package file refers to all three, but when I do the same, ghc-pkg complains that the corresponding libHSfoo.a files don't exsit.
08:43:31 <kosmikus> bringert: that's not so easy
08:43:48 <dcoutts_> Igloo, some how ghc-6.6 doesn't need that, but I still get the same problem with gtk, though perhaps that's because gtk is bigger than base
08:44:18 <bringert> kosmikus: ok, thanks
08:44:44 <dcoutts_> Igloo, you were saying that split-objs don't work? because they do. it works for me.
08:45:07 <Igloo> I didn't say it doesn't work, I said it suggested you don't use it
08:45:09 <bringert> kosmikus: some other minor issues: I think normal polycode doesn't put enough space before { in haskell code
08:45:12 <dcoutts_> Igloo, ok
08:45:40 <kosmikus> bringert: true, but I think Ralf likes it that way for some reason, so I never changed it.
08:45:56 <bringert> kosmikus: also, underscores in identifier names (italic) are very small
08:46:11 <Igloo> dcoutts_: "Doing so reduces binary sizes for statically-linked binaries, but on Windows it dramatically increases the time taken to build the libraries in the first place."
08:46:21 <Igloo> dcoutts_: From http://www.haskell.org/ghc/docs/latest/html/building/winbuild.html
08:46:22 <bringert> kosmikus: and sometimes a bit too far from the letters, but I guess that is a font problem
08:46:32 <kosmikus> bringert: that's easy to change, I think
08:46:50 <kosmikus> bringert: "too far from the letters" could even be a screen resolution problem?
08:46:59 <bringert> kosmikus: for the { I'll just add %format { = "\hspace{2pt}\lbrace" then, if there isn't a better way
08:47:12 <dcoutts_> Igloo, that's true, it does take a long time to build, but that only happens once, it's a benefit for the users.
08:48:23 <Igloo> The assumption might be that if you're following the instructions you're building for dev reasons, otherwise you'd use the installer
08:48:29 <bringert> kosmikus: I doesn't look like a resolution problem, it rather seems to be that the italic font doesn't take into account that the lower-right corner of the letter is further to the left than the upper-right one
08:48:36 <bakert> How can I use a TimeDiff from System.Time without having to supply all the fields down to picoseconds just to say "add 30 days"?
08:48:46 <bringert> kosmikus: that makes the distance from the lower-right corner to the underscore quite large
08:49:10 <kosmikus> bringert: it never looked strange to me
08:49:20 <dcoutts_> Igloo, I'm not building ghc, I'm trying to make Gtk2Hs work in GHCi on Windows.
08:50:03 <dcoutts_> Igloo, I hit this bug: http://www.haskell.org/ghc/docs/latest/html/users_guide/bugs.html#bugs-ghci
08:50:12 <dcoutts_> I'm trying to follow the advice, but can't make it work
08:50:18 <dcoutts_> "The workaround is to split up the .o files that make up your package into two or more .o's, along the lines of how the "base" package does it."
08:51:38 <dcoutts_> the base package does indeed have several HSbase${N}.o files and one libHSbase.a and that seems to work for base (I mean ghc-pkg doesn't complain when I re-register base) but it complains for other packages that do the same thing
08:51:55 <bringert> kosmikus: I guess it's not a big deal: http://www.cs.chalmers.se/~bringert/tmp/underscore.png
08:52:16 <dcoutts_> Igloo, because normally ghc-pkg likes the libHS${pkg}.a and HS${pkg}.o to match.
08:52:37 <dcoutts_> I can't see anything different in the package files I'm registering to get this different behaviour
08:53:46 <kosmikus> bringert: ok, it's not good for the r_ combination
08:54:44 <cjeris> try adding an italic correction \/ before the underscore?
08:57:29 <kosmikus> italic correction *inserts* space, doesn't it?
08:57:47 <cjeris> oh, is it always positive?  nm :)
08:58:39 <Lemmih> dcoutts_: How close is gtk2hs to a release?
08:59:18 <dcoutts_> Lemmih, very close, I'm going to do another RC ASAP, but I'm stumbling on getting it working in windows with GHCi.
08:59:23 <bringert> yeah, that added space
08:59:34 <bringert> and lhsTeX generated \Varid{var}\;\/\anonymous ;{}
08:59:49 <edwinb> any hackagey people about?
08:59:56 <beelsebob> Data.FiniteMap got replaced with Data.Map didn't it?
09:00:05 <bringert> when I wrote var{-"\/"-}_
09:00:24 <dcoutts_> Lemmih, why do you ask?
09:02:40 <kosmikus> bringert: the \; is even more space
09:03:01 <kosmikus> bringert: you can alway say %format var_ = "... something better ...", of course
09:03:10 <bringert> ah, of course
09:03:20 <bringert> what would something better be? negative hspace?
09:03:25 <bringert> hackety hack
09:03:30 <Lemmih> dcoutts_: I'm having on hIDE again.
09:03:36 <Lemmih> *hacking
09:03:47 <ProfTeggy> Moin
09:04:36 <dcoutts_> Lemmih, oh, cool.
09:05:17 <dcoutts_> Lemmih, keep me posted, I want to do some GUI stuff for that, like the live directory/module view
09:06:56 <bringert> %format var_ = "var\hspace{-1pt}\_" makes it look nicer
09:07:59 <cjeris> what if the variable name ends in uppercase A or something?
09:08:52 <shapr> wargh
09:09:22 <bringert> cjeris: M_ looks quite strange without hspace hacks
09:10:20 <bringert> gotta go, kosmikus and cjeris thanks!
09:10:28 <ohmega> hi shapr :)
09:11:53 <shapr> hiya ohmega
09:12:59 <edwinb> are people encouraged to upload their stuff to hackageDB these days?
09:13:06 * edwinb is so behind the times with this fancy technology stuff
09:14:02 <beelsebob> excellent, the pimp appears to be working :)
09:17:26 <chessguy> can i brainstorm about a little mini-project i've been thinking about for a little while now?
09:18:45 <dcoutts_> Igloo, seems that this reloc problem doesn't exist in ghc-6.6, so I'll just tell people who want to use GHCi that they need 6.6. So I'll not trouble you further on that account. :-)
09:19:05 * dcoutts_ just got Gtk2Hs 0.9.10.6 working in GHCi on Windows
09:19:24 <chessguy> hmm, maybe i should wait to bring it up until there's more activity on the channel
09:19:42 <dcoutts_> the GHCi cairo demo works nicely, and you can re-init the gui multiple times without problem (unlike wxwidgets)
09:20:23 <dcoutts_> hmm, let me rephrase that: Oh yes!
09:20:40 * dcoutts_ expects a new RC announcement soon
09:24:41 <shapr> chessguy: bring it up!
09:25:00 <shapr> I wonder, should I drop all of my ScannedInAvian domain names and get sha.pr instead?
09:25:12 <xic> dcoutts_: what about that promised xmas release?
09:25:28 <chessguy> well, i want a simulator for certain types of monte carlo problems
09:25:40 <chessguy> i have 3 problems in particular right now that i'm looking at
09:26:04 <bakert> shapr, i bet you have problems.  just try a whois on a .pr domain
09:26:12 <dcoutts_> xic, I already fessed up to not making that, though I did get a pre-release out before xmas
09:26:17 <bakert> it gives you a link to an ASP web page that is a 404.
09:26:21 <shapr> bakert: I just looked into that, I think I can do it.
09:26:27 <bakert> shapr, nice idea though.
09:26:43 <bakert> What country is pr?
09:26:45 <bakert> peru?
09:26:48 <shapr> Puerto Rico
09:27:04 <JKnecht> which technically is not a country
09:27:04 <xic> dcoutts_: yeah, thanks for that, but is the release that you were initially planning going to eventually come out?
09:27:09 <chessguy> basically the problem involves a saystem (in these cases, one system is a warehouse, one is an airport, and one is a store), and an entity (order, airplane, and person, respectively) which enters the system for a while, then exits
09:27:26 <chessguy> s/saystem/system/
09:27:51 <dcoutts_> xic, sure, we've had one RC, the second RC is nearly out and then the final should follow some days later. Have you tried the latest RC ?
09:27:59 <bakert> well, puerto rico have a rubbish domain name administrator that much is clear.
09:28:06 <xic> dcoutts_: i don't think so
09:28:19 <shapr> My real question is whether sha.pr is easier to remember and associate with me.
09:28:29 <dcoutts_> xic, http://haskell.org/gtk2hs/gtk2hs-0.9.10.5.tar.gz (or .exe for win32)
09:28:30 <edwinb> get it anyway ;)
09:28:33 <edwinb> it's a great domain name
09:28:45 <chessguy> i want the simulator to have a bunch of random entities enter the system, and exit, while accumulating statistics about how long the entity spends at different points within the system
09:28:45 <shapr> :-)
09:28:52 <xic> dcoutts_: cool. i just remember that gtk2hs wouldn't work with a threaded ghci
09:29:01 <bakert> scannedinavian is pretty memorable.  sha.pr perhaps less so in general, although moreso for #haskellites
09:29:02 <dcoutts_> xic, fixed.
09:29:17 <dcoutts_> xic, that's what I've just been testing, on linux and windows.
09:29:17 <chessguy> shapr, does that make any sense?
09:29:19 <JKnecht> naw, shaeericson.com or .org best bets
09:29:20 <bakert> it is pretty groovy being only 6 characters though
09:29:30 <xic> dcoutts_: awesome!
09:29:39 <shapr> chessguy: You want a simulator.
09:29:46 <shapr> chessguy: Sounds like fun to me.
09:29:48 <chessguy> shapr, yes
09:30:05 <chessguy> i'm trying to figure out where the monads are in all this
09:30:23 <shapr> I'd build the simulator as an interpreter.
09:30:33 <chessguy> interpreter?
09:30:49 <shapr> Then you could stack monads to build the interpreter, and things like statistics collection would be another layer.
09:30:55 <malebria> Does quickCheck call arbitrary to generate the random values?
09:31:06 <chessguy> interpreting the system and entity structures?
09:31:07 <shapr> malebria: yes
09:31:24 <malebria> shapr: hum..
09:32:40 <shapr> chessguy: It may not be the best approach, but it'd probably work.
09:33:07 <vincent_> anyone interested in explaining to a total newbie what to do about "module `Data.Array' is a package module"?
09:33:25 <shapr> vincent_: What's the problem?
09:33:35 <Igloo> malebria: I made a trac report re your main:... hgpc problem, BTW
09:33:46 <chessguy> vincent_, paste your code: http://hpaste.org
09:33:58 <vincent_> kk, thanks
09:34:06 <chessguy> shapr, did i mention i'd like to write this by the end of the week? :)
09:34:36 <shapr> chessguy: I don't think that would be too challenging.
09:34:44 <chessguy> maybe for you :)
09:34:55 <shapr> aw c'mon
09:34:59 <shapr> Jump in and attack it!
09:35:50 <Igloo> vincent_: Use ":m +" rather than ":l", possibly
09:36:54 <thartman> where is docu for what the angle brackets are doing in "olds <- glob $ logdir </> base <.> "*.gz""
09:36:57 <thartman> >
09:37:10 <thartman> some kind of string function, but I don't understand it. or file globbing?
09:37:53 <shapr> Those are custom operators.
09:38:00 <malebria> Igloo: so it's a Cabal bug?
09:38:29 <shapr> thartman: They appear to be utility functions for selecting files from directories.
09:38:32 <Igloo> malebria: I'm not sure what sort of bug it is, so I filed it  :-)  (in the GHC bug tracker ATM)
09:38:49 <malebria> Igloo: ok, thanks.
09:39:02 <dancor> is there any sense of a default value
09:39:15 <thartman> ok so maybe in System.Path.Glob ... I'll look around.
09:39:17 <dancor> like default :: Int = 0?
09:39:25 <dancor> and default :: String = ""
09:39:35 <dancor> well default :: List [a] = []
09:39:41 <Igloo> dancor: No, although you could make one with a class
09:39:51 <sjanssen> dancor: mempty from Data.Monoid may be close
09:40:32 <dancor> sjanssen: are Int's alreday Monoid's?
09:40:46 <sjanssen> dancor: not by default
09:41:01 <sjanssen> because there is more than one reasonable value for mempty
09:41:10 <shapr> Oh, top level .pr domain names are $1000 USD per year. never mind then.
09:41:35 <Igloo> Wow
09:41:40 <sjanssen> mempty = 0; mempty = (+) and mempty = 1; mempty = (*) are both valid definitions
09:42:20 <allbery_b> Monoid.mempty and MonadPlus.mzero are both close but have other implications you probably don't want to deal with.  better to define your own class
09:42:59 <trurl> thartman: they seem to come from an external library: http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php
09:43:20 <allbery_b> class Defaultable where...; instance Defaultable Int where...; instance Defaultable String where...
09:43:57 <dancor> s/empty(?= = \()/append/g
09:44:02 <beelsebob> anyone here have a clue when IFL 06 are going to finish reviewing?
09:44:11 <allbery_b> although somethinmg to think about there is whether you want to also allow some kind of automatic handling, and if so what it would mean in different Defaultable instances
09:44:38 <edwinb> beelsebob: I was wondering the same...
09:44:59 <allbery_b> actually I would then sit down and think about what I'm trying to do that wants that kind of behavior to start with; might be a better way to do it (like use Maybe instead)
09:45:02 <edwinb> I was beginning to wonder if my spam filter had got overactive ;)
09:45:33 <thartman> trurl: thanks, I see.
09:49:00 <xic> is there something like a function and :: (a -> Bool) -> (a -> Bool) -> (a -> Bool)?
09:50:57 <kaol> @hoogle (a->Bool) -> (a->Bool) -> (a->Bool)
09:51:44 <Igloo> liftM2 (&&) in the reader monad
09:52:21 <xic> and' f1 f2 x = (f1 x) && (f2 x)
09:53:09 <arjanb> @pl and' f1 f2 x = (f1 x) && (f2 x)
09:53:24 <kaol> !type liftM2 (&&)
09:53:29 <swhask> forall (m :: * -> *). (Monad m) => m Bool -> m Bool -> m Bool
09:54:40 <beelsebob> edwinb: well, we had the head of the review panel here on the day that they were meant to be sending out emails
09:54:48 <beelsebob> so we're reasonably certain that they're late
09:54:51 <beelsebob> the question is how late
09:57:43 <edwinb> beelsebob: they were due on the 15th weren't they?
09:57:55 <beelsebob> edwinb: yeh
09:58:23 <edwinb> I'm just hoping my response didn't manage to reduce the scores they'd given ;)
09:58:33 <beelsebob> heh
09:58:36 <beelsebob> ditto
09:58:41 <beelsebob> didn't quite know what to write
09:58:52 <beelsebob> didn't know how much extra guff they wanted
09:59:00 <thartman> Igloo: did you mean that  && is specific to the reader monad? looking at the docu, seems not to be.
09:59:09 <beelsebob> what were your pre-review results then edwinb?
09:59:39 <edwinb> All three papers people here submitted had two clear accepts and one tend to accept
09:59:56 <edwinb> maybe they got too many papers they liked...
10:00:01 <beelsebob> looks like it
10:00:01 <edwinb> what were yours?
10:00:04 <beelsebob> mine got that too
10:00:06 <edwinb> heh
10:00:21 <beelsebob> olaf's got two clear accepts and "this reviewer fell of his perch/forgot to review it"
10:00:23 <Igloo> thartman: No, liftM2 (&&) in the reader monad (r ->) has the type (and behaviour) wanted
10:00:44 <edwinb> They must have been full of christmas cheer this year or something
10:00:49 <beelsebob> heh
10:05:26 <chessguy> hmm, suppose i have a bunch of functions (or possibly monads), and i want each of them to be able to decide which one it should pass its return value to. is that a continuation?
10:07:40 <PaulAJ> chessguy: Certainly sounds like it
10:08:04 <PaulAJ> Or is it just a bunch of nested function calls?  Where does the decision come from?
10:08:29 <chessguy> from within a function call, dependent on what's passed to it
10:08:47 <chessguy> but once it calls the next function, it's done
10:09:03 <PaulAJ> Is the thing that gets passed in the next function?
10:09:31 <chessguy> hmm?
10:09:37 <PaulAJ> Or is it more along the lines of "if b then f1 x else f2 x"
10:10:02 <chessguy> more like an assembly line, where each point on the assembly line decides which point it should go to next
10:10:11 <PaulAJ> do you say f arg1 arg2 cont = ..... cont x
10:10:21 <chessguy> i don't have any code yet
10:10:23 <chessguy> i'm still planning
10:10:41 <Spark> anyone use gnome and know what the memory footprint of a typical desktop with a bunch of common apps running?
10:10:46 <pjd_> chessguy: normal recursion should suffice
10:11:01 <PaulAJ> It sounds maybe more like a state machine then.  Of course you do get tail call optimisation: if f x is the last call then it gets compiled as JMP f rather than JSR f
10:12:46 <PaulAJ> Continuation passing style (CPS) means that instead of returning from a function, you tell the function (via an extra argument) what function to call next.
10:13:09 <PaulAJ> Are you any wiser now?
10:13:31 <chessguy> hmm, but i don't want each service point to tell the next service point what to do. rather, i want it to look at the object it's passed and decide what to do
10:14:02 <PaulAJ> Thats just normal recursion.  Can you tell us a bit more about what you are planning to do?
10:14:16 <PaulAJ> i.e what problem are you trying to solve?
10:14:35 <chessguy> sure, i'm thinking about how to write a monte carlo simulator to solve certain types of problems
10:14:59 <chessguy> where an object enters a system and spends time at various points within the system before exiting
10:15:21 <PaulAJ> Monte-carlo = randomness, so you are presumably going to have a random number generator to pass around as well.
10:15:38 <chessguy> that will be involved as well, yes.
10:16:03 <chessguy> for that though, i may just wrap everything in a state monad and keep the RNG there
10:17:09 <PaulAJ> One way to start would be to wrap up the RNG in a StateT monad, along with an arbitrary state parameter.  That separates your RNG stuff from your object pinball stuff.
10:17:14 <edwinb> it sounds just like a fold to me... maybe there is something more complicated going on
10:17:29 <chessguy> one example would be a warehouse which gets an order for a bunch of products
10:17:43 <PaulAJ> Well, of course you could just generate the list of states, and fold over that.
10:17:58 <chessguy> and it sends a robot around collecting products off the shelves
10:18:16 <PaulAJ> So you want to simulate the robot?  What about stock keeping?
10:18:25 <chessguy> both
10:18:36 <koala_man> how do you check if an element is a member of a list?
10:18:38 <PaulAJ> Are we headed towards a discrete event simulator here?
10:18:45 <chessguy> PaulAJ, yes
10:18:45 <PaulAJ> koala_man: elem
10:18:50 <koala_man> thanks
10:19:36 <PaulAJ> Hmm.  I've done some of that, composing ContT on top of StateT for a scheduler, and then building the equivalent of CVar out of IORef.  A bit painful, but doable.
10:19:58 <PaulAJ> You need this if one thread in your simulation needs to wait on something else.
10:20:57 <paolino> @instances Num
10:21:11 <PaulAJ> My first cut at this is owned by my employer, so I can't release it.  I've been working on an independent implementation that does transactions, but I'm a bit stuck a the moment.
10:21:18 <Hunter_wow> is really http://hpaste.org/new the correct paste link?
10:21:26 <koala_man> is there a clever way to split a list in two, with elements matching a function in one and the rest in another? like filter, only returning the refuse as well
10:21:29 <chessguy> Hunter_wow, yes.
10:21:33 <Hunter_wow> ok, thx
10:21:34 <PaulAJ> partition
10:21:42 <chessguy> PaulAJ, hmm. ok
10:21:44 <koala_man> yay, thanks
10:21:46 <PaulAJ> @type partition
10:22:16 <PaulAJ> koala_man: you would profit from reading the standard libraries.
10:22:23 <koala_man> probably
10:22:29 <chessguy> PaulAJ, in my case, i think the system and the object entering it are going to have to have some kind of record or typeclass instances
10:22:43 <chessguy> but i haven't worked out exactly what they should look like
10:22:45 <hpaste>  Hunter_wow pasted "Remove a list" at http://hpaste.org/198
10:23:20 <PaulAJ> Start with data.  Only go to class if you find significant commonality.
10:23:32 <chessguy> ok, fair enough
10:23:49 <PaulAJ> BTW, is Lambdabot on line?  Or have I just got the syntax wrong?
10:23:51 <sjanssen> Hunter_wow: what are you trying to do?
10:23:58 <chessguy> but as general as i'm trying to make it, there should be siginificant commonality
10:24:08 <chessguy> LB is offline
10:24:22 <Hunter_wow> I tried to make my question a bit easier then it is right now. Need to get rid of an list ^^
10:24:27 <PaulAJ> Again, I'd suggest making your first cut specialised.  Then go back and try to figure out the general case.
10:24:38 <sjanssen> Hunter_wow: "get rid of"?
10:24:46 <sjanssen> Hunter_wow: do you want to get the first item in a list?
10:24:46 <chessguy> good idea
10:24:59 <chessguy> it looks like Hunter_wow wants a fold
10:25:07 <chessguy> but his problem description is too vague
10:25:29 <Hunter_wow> yea, I can make a new questions that make sense :P
10:25:30 <kowey> lambdabot2 in other channels is still alive... is there a way to bring her in?
10:25:47 <chessguy> someone with privileges can do @join #haskell
10:25:55 <chessguy> shapr, ping
10:25:59 <sjanssen> I believe I have privileges
10:26:18 <chessguy> sweet
10:26:19 <chessguy> @bot
10:26:19 <lambdabot2> :)
10:26:27 <PaulAJ> @type partition
10:26:32 <lambdabot2> forall a. (a -> Bool) -> [a] -> ([a], [a])
10:27:11 <PaulAJ> : partition even [1..10]
10:27:19 <paolino> I have this function wich produces what I need but , I need also the last of it. How I avoid the 'last' function call ?
10:27:20 <paolino> partials = tail . scanl (\(s,_) (z,a) -> (s+z,a)) (0,undefined)
10:27:32 * PaulAJ tries to remember how to get lambdabot to evaluate something
10:27:46 <paolino> > <space> func
10:27:46 <lambdabot2>  Parse error
10:27:46 <swhask>  Parse error
10:27:56 <paolino> > 1+1
10:28:00 <lambdabot2>  2
10:28:06 <swhask>  2
10:28:08 <chessguy> > partition even [1..10]
10:28:10 <lambdabot2>  ([2,4,6,8,10],[1,3,5,7,9])
10:28:10 <PaulAJ> > partition even [1..10]
10:28:11 <lambdabot2>  ([2,4,6,8,10],[1,3,5,7,9])
10:28:12 <swhask>  ([2,4,6,8,10],[1,3,5,7,9])
10:28:14 <swhask>  ([2,4,6,8,10],[1,3,5,7,9])
10:28:15 <chessguy> :)
10:28:16 <sjanssen> who runs swhask?
10:28:58 <chessguy> hm, good question
10:29:44 <sjanssen> swhask: @part #haskell
10:31:05 <hpaste>  Hunter_wow pasted "Remove a list again" at http://hpaste.org/199
10:31:56 <sjanssen> Hunter_wow: you can't just turn a list into a single element
10:32:31 <thartman> :t liftM
10:32:32 <lambdabot2> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
10:32:37 <thartman> maybe this question is overly vague but... is every function also a monad?
10:32:51 <chessguy> Hunter_wow, reply :: Code -> Code -> (Int, Int)
10:32:55 <thartman> in the sense that it can be used as the second arg in liftM, liftM2 and friends?
10:33:09 <sjanssen> thartman: type constructors are Monads, not functions
10:33:40 <sjanssen> liftM takes a normal function, and "lifts" that function into any given monad
10:33:46 <paolino> liftM raise non monadic functions in the monad
10:34:02 <thartman> ?paste
10:34:02 <lambdabot2> http://paste.lisp.org/new/haskell
10:34:22 <sjanssen> !paste
10:34:23 <swhask> Not enough privileges
10:34:23 <hpaste> Haskell paste bin: http://hpaste.org/
10:34:27 <allbery_b> what of ((->) r)?
10:34:36 <Failure02> can i make my own datatype inherit Control.Parallel.Strategies.NFData somehow?
10:35:06 <sjanssen> allbery_b: ((->) r) (which is a type constructor) is the monad there
10:35:31 <sjanssen> Failure02: you have to write the instance yourself
10:35:46 <allbery_b> I think I'm trying to say that with that, every function becomes a monadic value
10:36:32 <Failure02> sjanssen: it will be easier for me to just lift out the values, than to that, won't it?
10:36:32 <sjanssen> allbery_b: that is closer
10:36:56 <sjanssen> Failure02: perhaps
10:37:19 <syntaxfree> I have this behaviour that feels monadic to me, and I can think of clear interpretations for bind and return, but I'm not sure of what's the data type to be instanced as a member of Monad.
10:37:25 <sjanssen> I'm just pointing out that monads aren't values
10:38:08 <syntaxfree> the basic idea is that when a computation is going to be performed -- when a function is going to be applied -- first one looks in a Map (as in Data.Map) to see if the results for that argument is already stored.
10:38:44 <sjanssen> so you want a memoization monad?
10:39:03 <syntaxfree> This should be a "parameterized" monad somehow, since one wants to supply the Map variable to "bind" so computations can be performed, so (..)
10:39:19 <syntaxfree> um, yes, I want a memoization monad. Don't tell me they've already done one! ;)
10:39:54 <syntaxfree> Well, do tell me.
10:39:59 <sjanssen> I'd say: newtype MemoMonad k v a = MemoMonad (State (Map k v) a)
10:40:18 <sjanssen> and if you're using GHC, tack a "deriving Monad" on the end
10:40:49 <syntaxfree> hmm.
10:41:03 <hpaste>  thartman pasted "is every function on one arg also a monad?" at http://hpaste.org/202
10:41:05 <syntaxfree> I don't know the State monad well yet! I've been using IORef whenever forced to.
10:41:14 <syntaxfree> that is, when using OpenGL.
10:41:18 <bos> is there a module for reading config files?
10:41:28 <sjanssen> maybe the function you're memoizing ought to be in it too?
10:41:30 <syntaxfree> Maybe I should learn. is State written in Haskell?
10:41:31 <bos> the State monad is trivial.
10:41:39 <sjanssen> syntaxfree: yes, it is
10:41:41 <vincenz> thartman: welcome to the reader monad
10:41:43 <sjanssen> @src State
10:41:57 <bos> it's just a single piece of state, with get and put actions to read and write it.
10:42:13 <syntaxfree> oh. rather polymorphic, it is.
10:43:00 <syntaxfree> @haddock
10:43:12 <thartman> vincenz: but that was just Control.Monad, not the reader monad.
10:43:27 <thartman> yet people seem to refer to it as the reader monad... confused...
10:43:45 <bd_> type Reader e a = e -> a
10:44:04 <vincenz> blatant self-advertisement.  Check out my comment on #haskell : http://programming.reddit.com/info/11x14/comments/c11xvg
10:44:07 <thartman> at any rate, the liftM2 I used in my code was only imported from ControllMonad.
10:44:14 <allbery_b> Control.Monad contains generic monad operations
10:44:29 <bd_> instance Monad (Reader e) where ...
10:44:32 <allbery_b> liftM2 can be used with any monad:  Reader, IO, [], Either String, etc
10:45:39 <goltrpoat> so.. let's say class C a b where foo :: a; data Weird a b = (C a b) => W a b; weird a = W foo a.  why does :t weird give weird :: (C a b1, C a b) => b1 -> Weird a b1?  b is not.. like.. actually used anywhere.
10:45:45 <allbery_b> welcome to typeclasses :)
10:47:12 <goltrpoat> and needless to say, it fails to compile if i assign that type to 'weird' explicitely
10:47:22 <vincenz> Feel free to comment on my comment :)
10:47:58 <goltrpoat> or give it the more sensible type of weird :: (C a b) => b -> Weird a b
10:49:34 <vincenz> blegh
10:49:44 <vincenz> someone posted a rather cynical comment to my comment
10:49:56 <vincenz> which on top is untruthful
10:50:41 <Slarba> but hey fellas... can you tell the type of breasts? :D
10:50:59 <Slarba> Prelude> :t (.)(.)
10:50:59 <Slarba> (.)(.) :: (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
10:51:07 <Slarba> amazing.
10:51:20 <glguy> (o)(o)
10:51:23 <shapr> bos: MissingH has a ConfigParser
10:51:26 <glguy> I like mine more like that
10:52:17 <bos> shapr: yeah, found it. it's been split out of MissingH.
10:52:21 <chessguy> glguy, there are probably herbal supplements you could take for t hat
10:52:29 <shapr> I think that if you're trying to use Haskell to find the type of breasts, you probably don't have an actual value to compare against ;-)
10:52:56 <vincenz> shapr: you on reddit?
10:53:00 <Slarba> shapr :))
10:53:08 <vincenz> shapr comment on : http://programming.reddit.com/info/11x14/comments/c11xvg  ?
10:53:12 <shapr> vincenz: Nah, they broke my account somehow.
10:53:34 <vincenz> :/
10:54:53 <shapr> vincenz: Kungtotte's comment is so general that it doesn't say anything and is hard to measure.
10:55:37 <vincenz> it's rather cynical
10:55:45 <shapr> For all community there exists this comment...
10:55:46 <vincenz> I gave soem counter examples to his overgeneraliztation
10:56:00 <vincenz> shapr: sure and on a coarse enough level, all animals are alike
10:56:04 <bos> contributing to reddit flamewars considered harmful :-)
10:56:07 <shapr> Yup :-)
10:56:09 <vincenz> shapr: but at that level of generalization nothing interesting can be said
10:56:14 <shapr> vincenz: I totally agree.
10:56:17 <vincenz> bos: hardly flamewar :)
10:56:26 <vincenz> bos: I try to keep it constructive
10:56:31 <vincenz> #ocaml is a known source of pain
10:56:36 <shapr> So rather than argue with him, I suggest that you continue to contribute positively to your communities :-)
10:56:38 <vincenz> even to people in #ocaml, one of whom I used to be
10:56:38 <goltrpoat> \forall Community. \exists Person. Person \in Community, Person \in Asshole.
10:57:06 <goltrpoat> (corollary:  \forall Community. \Asshole \cap \Community \neq 0)
10:57:39 <bos> jeez, i wish ConfigFile didn't depend on MissingH.
10:58:30 <Slarba> huh damn cold out there... -28.1C
10:58:37 <goltrpoat> jesus.
10:58:53 <vincenz> goltrpoat: ?
10:58:58 <goltrpoat> (re cold)
10:59:22 <vincenz> that is cold
10:59:38 <vincenz> Slarba: how can you live like that?
11:00:21 <thartman> slarba: where?
11:00:35 <shapr> Tornio?
11:00:49 <shapr> Slarba: puhutko suomea?
11:02:05 <goltrpoat> i remember trying to learn finnish when i was 18 or so, and the only thing ive retained since then is 'haista paska'
11:02:07 * glguy wonders if there are webpages that gizmo *hasn't* posted to reddit http://programming.reddit.com/info/11xib/comments
11:02:34 <shapr> reddit is the slashdot of... well.
11:02:42 <vincenz> shapr: nah, that's not true
11:02:44 <vincenz> slashdot is utter trash
11:02:48 <goltrpoat> which makes it very difficult to maintain a conversation
11:02:52 <vincenz> reddit has interesting posts at times
11:03:45 <goltrpoat> slashdot has gotten quite amazingly bad in the last five years or so
11:03:50 <vincenz> yah
11:04:07 <vincenz> lots of reposts or completely pointless articles with tons of really crappy comments following it
11:06:12 <shapr> LtU went downhill too.
11:06:22 <shapr> But I wonder, maybe those websites have not changed, but we have?
11:06:35 <Botje> haskell programmers don't change.
11:06:38 <Botje> they can't :P
11:06:49 <vincenz> Botje: bah, get into your monad
11:06:53 * shapr grins
11:07:05 <vincenz> heh
11:07:10 <vincenz> that'd be a cool name for a car "monad"
11:07:16 <allbery_b> haskell programmers don't change value, they just become higher order?
11:07:26 <vincenz> allbery_b: we move to the type-system
11:07:36 <vincenz> allbery_b: oleg being @ nirvana
11:07:41 <shapr> heh
11:07:43 <rahikkala> Functional programmers don't ever change, they just build a new copy of themselves and GC the old one
11:07:52 * shapr clones himself
11:08:24 <vincenz> drop 100000 $ repeat self
11:08:30 <vincenz> reminds me of the movie "the prestige"
11:08:37 <Botje> hh
11:08:39 <Botje> shh
11:08:42 <Botje> don't give it away
11:08:50 <Botje> I saw it friday :)
11:09:20 <vincenz> map kill $ take 99 $ replicate 100 self
11:09:24 <vincenz> :D
11:09:47 <xic> shapr: have you used hinotify?
11:09:51 <Botje> vincenz: that's not entirely correct
11:10:10 * goltrpoat :: Coffee -> Code
11:10:13 <Botje> remember the "i'll never know if ..." at the end?
11:10:20 <vincenz> goltrpoat: you always produce the same code?
11:10:28 * vincenz :: Coffee -> m Code
11:10:33 <goltrpoat> for the same values of coffee, yes.
11:10:43 <syntaxfree> hahaha.
11:10:54 <syntaxfree> that's bash.org material if I ever heard it!
11:11:06 <goltrpoat> hehe
11:11:27 <vincenz> bash.org?
11:11:28 <goltrpoat> (clearly, Coffee is a comonad)
11:11:48 <vincenz> oh?
11:11:48 <shapr> xic: Nah, but the author hangs out here.
11:11:54 <vincenz> c Coffee -> Code?
11:12:02 <xic> shapr: what's his nick?
11:12:19 <xic> @seen kolmodin
11:12:23 <syntaxfree> @remember goltrpoat  (clearly, Coffee is a comonad)
11:12:48 <syntaxfree> @remember goltrpoat  (clearly, Coffee is a comonad)
11:12:54 <syntaxfree> lambdabot, my man, wake up.
11:12:59 <AStorm> vincenz, you should rather be a monad transformer:
11:13:08 <goltrpoat> vincenz:  type Coffee = Beverage a; instance Comonad Beverage where ...  goltrpoat :: Coffee -> Code
11:13:31 <xic> @seen kolmodin
11:13:31 <AStorm> vicenz :: Cup Coffee -> (Cup Empty, IO Code)
11:13:31 <vincenz> goltrpoat: type Coffee = Beverage a makes no sense
11:13:35 <AStorm> *vincenz
11:13:51 <goltrpoat> vincenz:  how so?
11:13:54 <AStorm> Cup is a Monad
11:14:03 <vincenz> goltrpoat: where does the 'a' come from ?
11:14:27 <goltrpoat> pick one? :)
11:14:37 <vincenz> no seriously that's not valid afaik
11:14:53 <xerox> xerox :: RWST [Book] Notebook (MVar (HList Things)) IO a
11:15:33 <goltrpoat> vincenz:  oh, i don't mean a as an actual tyvar
11:15:53 <goltrpoat> as in, you'll have to pick a type
11:15:58 <vincenz> Oh!
11:16:01 <AStorm> Hmm, how would one return two transformed monads at once?
11:16:06 <vincenz> type Coffee = Beverage Hot
11:16:14 <vincenz> AStorm: hmm?
11:16:23 <vincenz> AStorm: 'transformed monads'?
11:16:30 <AStorm> I mean you transform one, and return something more
11:16:38 <AStorm> As in state transformer.
11:17:00 <vincenz> you man how do you stack monad transformers?
11:17:25 <AStorm> No, I want to have two separate monads as function return
11:17:34 <AStorm> but one of them is transformed
11:17:38 <vincenz> that makes no sense
11:17:49 <AStorm> Think "consumer+producer" pattern
11:17:50 <shapr> Ya know, I think Tanenbaum is right, but I think microkernels are not the right approach. I think type checking can fix the problem without any runtime impact.
11:18:02 <vincenz> AStorm: you'll have to amplify, I can't read your mind
11:18:04 <vincenz> (yet)
11:18:13 <AStorm> The function consumes something (transforms some monad), and produces something too
11:18:28 <vincenz> erm
11:18:33 <vincenz> monad transformations are purely in the type-system
11:18:39 <vincenz> it's not a runtime thing
11:18:40 * glguy thinks AStorm is misusing the transform verb
11:18:49 <vincenz> AStorm: might want to read up on monad transformers
11:18:50 <AStorm> Ok, well, s/transform/mangle/
11:18:55 <vincenz> AStorm: give us an example
11:18:57 <AStorm> I mean like change it
11:19:01 <vincenz> change -what-?
11:19:05 <glguy> it!
11:19:17 <glguy> !paste
11:19:17 <AStorm> Example: AStorm :: Cup Coffee -> (Cup Empty, IO Code)
11:19:17 <swhask> Not enough privileges
11:19:18 <hpaste> Haskell paste bin: http://hpaste.org/
11:19:29 <glguy> !version
11:19:30 <swhask> lambdabot 4p269, GHC 6.4.2 (Darwin Power Macintosh)
11:19:30 <swhask> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:19:31 <vincenz> AStorm: that's not a monadic action
11:19:33 <AStorm> Something which would do something like that, but maybe w/o the stupid tuple
11:19:36 <AStorm> Yes it is.
11:19:37 <vincenz> AStorm: that's a simple function, and the IO code is not executed
11:19:40 <AStorm> Cup = monad :P
11:19:44 <glguy> @bot
11:19:49 <vincenz> AStorm: then it's DEFINITELY not monadic
11:19:52 <AStorm> ?botsnack
11:20:01 <vincenz> AStorm: the output is not in a monad
11:20:07 <glguy> who runs swhask?
11:20:09 <Slarba> vincenz, thartman, shapr... I live easily. Just a matter of clothing :D
11:20:13 <Slarba> shapr: puhun suomea juu :)
11:20:20 <vincenz> Slarba: :)
11:20:35 <vincenz> AStorm: maybe:
11:20:43 <chessguy> ?quote monad
11:20:44 <vincenz> Coffee -> Cup (Empty, IO Code)
11:20:50 <vincenz> @quote denotational
11:20:52 <vincenz> @bot
11:21:08 <chessguy> hmm, it was here
11:21:09 <AStorm> vincenz, hmm, but that would mean something else, wouldn't it? :P
11:21:26 <goltrpoat> mmm.. code in a cup.
11:21:27 <AStorm> I'd rather just change the cup AND produce IO too
11:21:50 <vincenz> AStorm: then you need to use a monad transformer, put it on top of the IO and liftIO your IO actions
11:21:51 <AStorm> s/cup/Coffee/
11:21:53 <glguy> f :: Cup -> (Cup, IO ())
11:22:01 <goltrpoat> i still like the idea that i produce the same code for the same values of coffee.
11:22:03 <glguy> f /= monad
11:22:09 <AStorm> vincenz, hmm... Sounds nice. Where can I read up more on these?
11:22:09 <vincenz> glguy: ..ic
11:22:16 <Slarba> shapr: not Tornio... Oulu :)
11:22:16 <glguy> vincenz: I'm guessing
11:22:21 <vincenz> AStorm: any text on monads should also talk about transformers
11:22:23 <vincenz> @where monads
11:22:27 <vincenz> bot is down :/
11:23:37 <sjanssen> !paste
11:23:38 <swhask> Not enough privileges
11:23:38 <hpaste> Haskell paste bin: http://hpaste.org/
11:24:16 <hpaste>  sjanssen pasted "MemoMonad" at http://hpaste.org/203
11:24:22 <sjanssen> syntaxfree: ^^^
11:25:15 <Slarba> firePlace :: Wood -> IO Heat <3
11:25:20 <glguy> !stop using hpaste's command prefix :)
11:25:20 <swhask> Maybe you meant: show slap
11:25:27 <glguy> !slap swhask
11:25:27 <swhask> Not enough privileges
11:25:39 <glguy> > True
11:25:42 <swhask>  True
11:26:00 <vincenz> heh
11:26:16 <vincenz> I learned something new today as I pondered answering on reddit and googling first to know I wasn't wrong.  I was wrong... you can have virtual operators in c++
11:26:29 <chessguy> !show slap
11:26:29 <swhask> "slap"
11:26:32 <xic> of course
11:26:42 <chessguy> !show slap glguy
11:26:42 <swhask> "slap glguy"
11:26:54 <vincenz> !show show
11:26:54 <swhask> "show"
11:26:57 <vincenz> !show !show slap
11:26:57 <swhask> "!show slap"
11:27:08 <PaulAJ> How do you paste in the pastebin?
11:27:10 <vincenz> @bot
11:27:11 <sjanssen> @botsnack
11:27:11 <lambdabot2> :)
11:27:11 <lambdabot2> :)
11:27:18 <vincenz> @where monads
11:27:18 <lambdabot2> http://www.nomaware.com/monads/html/index.html
11:27:20 <PaulAJ> She's twins!
11:27:22 <vincenz> AStorm: check that liink
11:27:23 <glguy> echo test
11:27:23 <chessguy> @slap swhask
11:27:24 * lambdabot2 slaps swhask
11:27:24 <glguy> !echo test
11:27:27 <swhask> Not enough privileges
11:27:32 <resiak> mubot?
11:27:38 <vincenz> AStorm: ?
11:27:43 <glguy> If I see not enough privileges again, I'm going to punt that bot :)
11:27:54 <sjanssen> who runs swhask?
11:27:55 <chessguy> !echo test
11:27:56 <swhask> Not enough privileges
11:27:58 * chessguy waits...
11:28:07 * glguy kicks chessguy
11:28:08 <chessguy> noooooooooo
11:28:11 <chessguy> i'm not a bot!
11:28:18 <vincenz> Why do we need swhask ?
11:28:36 <PaulAJ> How do you paste stuff in the pastebin?
11:28:37 <glguy> lambdabot2: @bot
11:28:37 <lambdabot2> :)
11:28:40 <glguy> @bot
11:28:40 <lambdabot2> :)
11:28:42 <sjanssen> swhask doesn't run with a recent/default permissions list, so I can't @part
11:28:52 --- mode: ChanServ set +o vincenz
11:28:54 --- kick: swhask was kicked by vincenz (vincenz)
11:28:55 <araujo> hello!
11:28:56 --- mode: vincenz set -o Vq^
11:28:58 --- mode: vincenz set -o vincenz
11:29:01 <vincenz> there we go
11:29:16 <glguy> @echo better?
11:29:16 <lambdabot2> echo; msg:IrcMessage {msgPrefix = "glguy!n=eric@unaffiliated/glguy", msgCommand = "PRIVMSG", msgParams = ["#haskell",":@echo better?"]} rest:"better?"
11:29:20 * PaulAJ spots the "new" link on the hpaste page.
11:29:21 <glguy> ?version
11:29:21 <lambdabot2> lambdabot 4p344, GHC 6.5 (OpenBSD i386)
11:29:21 <lambdabot2> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:29:33 <glguy> PaulAJ: Yup, you are permitted to make new pastes
11:30:11 <vincenz> glguy: that's your page right?
11:30:21 <glguy> vincenz: yeah
11:30:31 <chessguy> yikes, that's quite an echo
11:30:45 <vincenz> glguy: mind i I give you a suggestion?
11:31:03 <glguy> Suggestions are always welcome, sometimes I even use them
11:31:04 <fincher> does the author of http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html hang around here?
11:31:07 <lambdabot2> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
11:31:38 <vincenz> glguy: well I really like the font and layout and all.  But I would suggest using a slightly smaller font so you can fit more lines on a page iin the listing of pastes
11:31:52 <shapr> fincher: yes
11:32:00 <fincher> shapr: who is it?
11:32:02 <shapr> fincher: But he's not here now.
11:32:06 <fincher> shapr: ah, ok.
11:32:08 <glguy> vincenz: that's something I could play with
11:32:12 <fincher> what's his nick?
11:32:20 <Excedrin> swhack seems to belong to kpreid
11:32:24 <shapr> fincher: Did you have some questions or suggestions about that post?
11:32:25 <Excedrin> er, swhask
11:32:38 <shapr> Excedrin: Yeah, it's for #swhack
11:32:53 <glguy> vincenz: like so?
11:33:06 <fincher> shapr: no, just wanted to let the author know that for me and a friend of mine and a friend of his, (i.e., at least three people) that was the essay that got monads to "click" for us.
11:33:13 <goltrpoat> so.. any ideas about my type constraints question from earlier?  class C a b where foo :: a; data Weird a b = (C a b) => W a b; weird a = W foo a  gives weird :: (C a b1, C a b) => b1 -> Weird a b1 in ghci, and i can't tell where the C a b constraint is coming from
11:33:33 <shapr> fincher: Yeah, same for a bunch of people who were not helped by other monad tutorials.
11:33:43 <vincenz> glguy: actually, I liked the bold nicks, but the 20 or so posts barely fit on my page
11:33:52 <hpaste>  PaulAJ pasted "Discrete event simulation with transactions" at http://hpaste.org/204
11:34:02 <vincenz> glguy: ah bit better already :)
11:34:05 <fincher> shapr: just wanted to make sure he got some appreciation :)
11:34:08 <sjanssen> goltrpoat: how is foo defined?
11:34:23 <shapr> fincher: But I've already told him that you and several others who were not helped by all the other tutorials were helped by that one. And because of that, he's improved and expanded that post somewhat. I think it also encouraged him to write more tutorials.
11:34:40 <goltrpoat> sjanssen:  it isn't
11:34:45 <glguy> if anyone has an opinion about the appearance of the front page of hpaste.org, now is the time to see that your browser renders it well :)
11:34:51 <fincher> shapr: good!  I'll have to look into his other tutorials, in that case.
11:35:00 <beschmi> fincher: you can leave a message for him ;) @tell dpiponi ...
11:35:05 <sjanssen> goltrpoat: then how do you get to the typechecking stage?
11:35:07 <PaulAJ> I'm seeking help with my discrete event simulation code.  I'm struggling with the types of some continuations.
11:35:10 <shapr> fincher: You mean stuff like "You could have invented spectral sequences." ?
11:35:27 <goltrpoat> sjanssen:  not following.  C a b is a class that defines foo :: a
11:35:29 <sjanssen> goltrpoat: if foo isn't defined, the program should fail with "Not in scope: `foo'"
11:35:41 <sjanssen> goltrpoat: ah, I missed that part
11:35:48 <fincher> shapr: never even heard of those :)
11:36:43 <sjanssen> goltrpoat: that is the behavior I'd expect
11:37:08 <goltrpoat> sjanssen:  why?  'b' doesn't appear anywhere on the RHS of that type
11:37:27 <vincenz> glguy: want a screenshot?
11:37:38 <glguy> vincenz: what platform?
11:37:43 <vincenz> ubuntu/firefox
11:37:51 <glguy> vincenz: does it look ok?
11:37:59 <glguy> vincenz: or are you showing something that needs fixing?
11:37:59 <vincenz> well yes and no
11:38:03 <vincenz> since you only have 20 entries
11:38:07 <glguy> 25
11:38:10 <vincenz> it's rather lame you still have a scrollable page
11:38:18 <glguy> ?
11:38:21 <shapr> What's scrollable?
11:38:21 <vincenz> I mean, if you include the logo, and the buttons at the bottom
11:38:25 <vincenz> vertically scrollable
11:38:34 <vincenz> screenshot coming
11:38:40 <glguy> you need a bigger monitor :)
11:38:49 <vincenz> 1400x1050 is not small
11:38:58 <glguy> ok... you need to change your font dpi :-p
11:39:09 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/Screenshot.png
11:39:59 <glguy> vincenz: that looks like a sideeffect of what fonts you have installed
11:40:15 <vincenz> for the rest I really like the font :)
11:40:23 <vincenz> just yeah, tad big :)
11:40:30 <goltrpoat> sjanssen:  'weird' is b -> Weird a b, and then a and b are constrained by (C a b), so (C a b) => b -> Weird a b would make sense.  it's adding an extraneous constraint in the form of C a b1 though
11:41:00 <sjanssen> goltrpoat: the extra constraint is due to the "foo"
11:41:05 * vincenz hopes the hacker that be do not take too much info from that screenshot
11:41:24 <allbery_b> PaulAJ: what is the problem?  what error(s) are you getting, where?
11:41:51 <shapr> vincenz: Or you could use my approach, which is to remove the gnome taskbar, gnome menubar, firefox bookmarks bar, and window manager bar.
11:42:03 <sjanssen> goltrpoat: also, Hugs rejects this program
11:42:26 <goltrpoat> sjanssen:  right, i figured it might be assuming foo :: C a <something else entirely>, although then i'm not sure how to type that function at all
11:42:37 <vincenz> shapr: eww
11:43:31 <goltrpoat> er.  not foo :: C ..., you see what i mean though.
11:43:38 <shapr> vincenz: Well, look at the window decoration bar, how many of those pixels are actually useful for you?
11:44:00 <PaulAJ> allbery_b: I'm trying to get orElse and retry to work.  The tsRetry field in the transaction state is supposed to store a continuation:
11:44:01 <vincenz> shapr: plenty
11:44:27 <sjanssen> goltrpoat: if you include the inferred type declaration, the program doesn't compile
11:44:47 <PaulAJ> for a simple transaction I call it using callCC, as in the "atomic" function.  For a nested transaction (i.e. the first one in "orElse") I call it with the second transaction.
11:44:48 <goltrpoat> sjanssen:  right
11:44:54 <dino-> Sounds like how I have my gvim configured too: without the silly toolbar.
11:44:58 <PaulAJ> Does this make sense?
11:45:05 <dino-> If it's worth doing in vim, it's worth doing without the mouse.
11:45:13 <goltrpoat> sjanssen:  including the inferred type declaration assigns something specific to b
11:45:16 <PaulAJ> It follows the nested transaction semantics in STM.
11:45:23 <sjanssen> goltrpoat: the type inferred is a valid one, but I'd say that the Hugs behavior is correct: this program should be rejected
11:46:31 <PaulAJ> I've tried a lot of variations on the theme, but I can't figure out the right combination of monad types.  tsRetry should be a SimT action (i.e. in the outer simulation thread) I think.
11:46:57 <chessguy> @pl bind f x = concat (map f x)
11:46:58 <lambdabot2> bind = (=<<)
11:47:41 <vincenz> grr
11:47:53 <goltrpoat> sjanssen:  should i just make foo :: b -> a, or can you think of a way to force the b?
11:47:55 <vincenz> dino-: how do ou turn off the toolbar?
11:48:15 <vincenz> dino-: guioptions=-T still leaves the iconbar, and doing "set toolbar=" in my .vimrc doesnt' accomplish anything
11:48:21 <vincenz> although it does at runtime
11:49:18 <dino-> I have 'set guioptions-=T'
11:49:23 <goltrpoat> er.. make foo :: b -> a, and write W (foo a) a instead of W foo a, i mean
11:49:38 <vincenz> oh -=T
11:49:38 <vincenz> duh
11:50:13 <vincenz> dino-: -=m too?
11:50:23 <dino-> vincenz: That, I don't have. That's for menus?
11:50:28 <vincenz> yeah
11:50:33 <vincenz> pretty spiffy
11:50:38 <vincenz> you just get a window with grey zones
11:50:48 <dino-> I guess I have to admit that, once in a blue moon, I may use the Syntax menu to manually pick a highlighting scheme for some file.
11:51:05 <dino-> But maybe I should stop being a sissy and do it with :set syn...
11:51:15 <vincenz> http://homes.esat.kuleuven.be/~cpoucet/Screenshot.png
11:51:56 <dino-> BTW, that new tab feature of Vim doesn't really impress me. It's had buffers and splitting for ages. Not sure what the hype is over tabs.
11:52:09 <vincenz> dino-: I actually like it
11:52:13 <vincenz> buffers aren't my thing
11:52:15 <dino-> Maybe I should give it a shot then.
11:52:22 <vincenz> and I shortcutted it
11:52:35 <vincenz>     map <C-Tab> gt
11:52:35 <vincenz>     map <C-S-Tab> gT
11:52:35 <vincenz>     imap <C-Tab> gt
11:52:35 <vincenz>     imap <C-S-Tab> gt
11:52:42 <vincenz> add a ^[ in front of the second two
11:52:47 <vincenz> to leave insert mode
11:53:34 <dpiponi> Talking of vim, have you tried vimshell?
11:53:38 <vincenz> o.O
11:53:39 <vincenz> vimshell?
11:53:48 <dpiponi> Lets you run a shell in vim
11:53:49 <shapr> dino-: I've turned off just about everything in emacs - http://www.scannedinavian.com/~shae/shaescreen.png
11:54:00 <dpiponi> http://www.wana.at/vimshell/
11:54:00 <vincenz> dpiponi: WOO
11:54:07 <dino-> I have not, but I do use `set -o vi`
11:54:11 <vincenz> dpiponi: finally!  At last the one thing I always said "that might be one reason why I want haskell"
11:54:12 <dino-> And occasionally vifm
11:54:13 <shapr> I like eshell in emacs.
11:54:16 <dpiponi> I coudln't get it to build.
11:54:28 <gotaku> If monads weren't bad enough... monad transformers are even worse.
11:54:35 <vincenz> gotaku: nah, they're better :)
11:54:44 <chessguy> @pl bind f x = flip $ concat (map f x)
11:54:45 <lambdabot2> bind = ((flip . join) .) . map
11:54:59 <dino-> gotaku: I understand them so far as adaptering a monad to work closely with another. Does that sound reasonable?
11:55:00 <vincenz> dpiponi: it's only for console vim?
11:55:24 <dino-> The thing that scares me more is the arrow business.
11:55:45 <beschmi> shapr: do you use colortheme? i need a new one (http://shim.haskellco.de/trac/shim/wiki/ShimHowto)
11:55:49 <lambdabot2> Title: ShimHowto - shim - Trac
11:56:02 <vincenz> dino-: what is 'set - vi'
11:56:02 <shapr> beschmi: Yeah, I use several different color themes, depends on my mood.
11:56:09 <gotaku> I'm really having trouble reading code written by other people.
11:56:17 <shapr> gotaku: So write your own!
11:56:26 <vincenz> shapr: eh, I wish I could map emacs to my brain but I can't
11:56:31 <dino-> vincenz, shapr: Your screenshots look great. I may have to ditch the menus too from my editor.
11:56:34 <shapr> vincenz: Well, use what works for you.
11:56:55 <gotaku> I use the oceandeep color scheme.
11:56:56 <shapr> vincenz: We should all switch to Yi anyway.
11:57:00 <dino-> vincenz: set <hyphen letter o> vi
11:57:08 <vincenz> dino-: I figured that much, what does it do?
11:57:08 <dpiponi> Do lots of people think about monads in terms of 'taint'?
11:57:26 <shapr> dpiponi: Only Nanevski that I'm aware of...
11:57:40 <dpiponi> I've seen people casually mention thiongs like 'now this value is tainted by the IO monad'...
11:57:42 <vincenz> dpiponi: thanks to cale, we all think of them like a box of chocolates, a nice container )
11:57:49 <dino-> vincenz: Makes bash use vi style editing instead of emacs style.
11:57:57 <vincenz> dino-: oo
11:58:02 <shapr> dpiponi: Speaking of which, your most recent post made we wonder if you could figure out how to implement nanevski's possibility and necessity in terms of monads and comonads.
11:58:06 <dpiponi> I have a theory that taint might be a better way for beginners
11:58:13 <vincenz> dpiponi: how do you edit anyways?
11:58:23 <vincenz> erm
11:58:24 <vincenz> wrong person
11:58:24 <dpiponi> I edit with vim
11:58:27 <vincenz> dino-: how do you edit?
11:58:29 <dino-> heh. If I give you this box of apples, and for every apple...
11:58:37 <shapr> dpiponi: Sounds reasonable, I think it's worth trying.
11:58:51 <paolino> what does it mean taint ?
11:59:00 <shapr> paolino: It's dirty, wash it off.
11:59:04 <dino-> vincenz: The modes work (but have no visual feedback), so i for insert, esc to cancel
11:59:09 <dino-> etc..
11:59:11 <dpiponi> I think you can think of IO, Writer and even [] as a form of 'taint'
11:59:14 <vincenz> dino-: how do you enter edit mode then/
11:59:47 <dino-> vincenz: Sitting at a command like, type something, then press ESC. And it will be in command mode.
11:59:58 <dino-> So, I guess by default it's in edit mode at every new prompt.
12:00:01 <dpiponi> paolino: the idea is that once something becomes tainted or unclean you can never get it clean again
12:00:08 <gotaku> I'm currently reading the Monad Transformers Step by Step paper and while it's a good paper I'm still having trouble with it.
12:00:18 <paolino> stained ?
12:00:31 <shapr> gotaku: Did you figure out the other monads after Maybe before reading that?
12:00:53 <dpiponi> paolino: taint is a better word because it has religious connotations of a clear separation between clean and unclean :-)
12:01:13 <fincher> shapr: I found that understanding the Maybe and List monads was also very important in making them click.
12:01:26 <shapr> fincher: I agree.
12:01:46 <shapr> gotaku: Have you read this already? --> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
12:01:48 <lambdabot2> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
12:01:59 <gotaku> Reading haskell code is like trying to reverse engineer machine code for me.
12:02:25 <fincher> shapr: Understanding the Maybe and List monads made me understand that monads are about tying different kinds of functions together (partial functions and functions with multiple return values, respectively) instead of accomplishing any number of other purposes for which they're pressed into service.
12:02:46 <shapr> Well, monads are just an abstraction.
12:02:49 <dino-> It goes along with how some monads are one-way. Values can go in only.
12:02:58 <shapr> So whatever purpose they accomplish is also what they're about.
12:03:05 <dpiponi> gotaku: I find recursive code can be hard to read sometimes. If you knew what something did, then the code would tell you what it did, but that's no help :-)
12:03:10 <vincenz> I'm going to be on the bike monad
12:03:17 <shapr> I'm going to be on the unicycle monad.
12:03:37 <fincher> shapr: well, I'd say that they're an abstraction for sequencing, on which other, more abstract abstractions can be built.
12:03:46 <shapr> Yeah, I agree with you there.
12:03:54 <fincher> shapr: it's just that those more abstract abstractions confuse the very simple abstraction that monads accomplish.
12:04:01 <fincher> at least initially.
12:04:08 <gotaku> dpiponi, Recursive code is fine... that isn't the problem.
12:04:12 <shapr> One important point is that monads are very predictable in their composition.
12:04:54 <fincher> dpiponi: so when are you going to write "You could have invented Arrows"?
12:05:00 <shapr> I think the hard part of monads is that you really can describe them in three minutes, but that won't show you all the cool things they can do.
12:05:21 <dpiponi> I haven't yet figured out what arrows are good for.
12:05:27 <fincher> dpiponi: me neither!
12:05:34 <dino-> That's one very important thing I got from Cale's document (apples, blueberries). You get down to where you're writing map and join in terms of >>= and return, and it can all stop being specific to your data type.
12:05:39 <dpiponi> I found something I thought they were good for - but found comonads did a better job
12:05:55 <shapr> What about swierstra & duponcheel's arrow based parsers?
12:06:07 <fincher> dpiponi: but since you're the reason (efficient cause, in aristotelian-speak) why I understand monads, I figure you can might be able to do that for Arrows as well :-P
12:06:19 <fincher> dpiponi: yeah, I don't understand comonads, either.
12:06:22 <dpiponi> I've not read the arrow parsing papers - I probably ought to
12:06:22 <paolino> yampa ?
12:06:47 <beschmi> hi waern
12:07:21 <shapr> Arrow parsing beats up on monadic parsing.
12:07:37 <dpiponi> fincher: check out applicative functors: http://www.cs.nott.ac.uk/~ctm/IdiomLite.pdf
12:07:58 <chessguy> shapr, i agree with what you said about the hard part of monads. you really have to wade right in and start using them
12:08:01 <dpiponi> Applicative functors are like monads but not quite...
12:08:34 <czanonie> hey -- does happy provide any sort of automatic lexing, or is that handled by alex?
12:08:38 <shapr> chessguy: Yeah, like lambda calculus... easy to define, but useful for many things.
12:08:52 <chessguy> i still haven't figured out what the big deal about LC is
12:08:55 <dpiponi> ...I found it a really interesting exercise to read up on applicative functors because even though I feel I understand monads that paper made me know what it feels like not to understand them again
12:09:40 <shapr> chessguy: Haskell is a thin (but significant) layer on top of LC.
12:09:55 <shapr> Gee, there's so much to say about LC it's hard to start in any particular place.
12:10:30 <chessguy> well, most languages could pretty much say that, couldn't they? can't any turing-complete language be expressed in LC?
12:10:47 <shapr> Sure, but representation is a tool in itself.
12:10:59 <shapr> It's no fun to do math with roman numerals.
12:11:00 <phb2> hm, anyone know if there is any (online) resource on like, how to synthesize functions from specifications (using induction)? (I'm reading Birds book, but I can't really grasp it :( )
12:11:20 <chessguy> and it is fun to do programming with LC?
12:11:22 <gotaku> What's a functor?
12:11:39 <fincher> gotaku: depends on who you ask.
12:11:48 <edwinb> of course it's fun to program in LC! :)
12:11:56 <dino-> shapr: Are you saying that Haskell is like programming almost directly in math notation?
12:11:59 <shapr> chessguy: LC lends itself to particular flavors of programming.
12:12:12 <shapr> dino-: Some people say that's true.
12:12:17 <chessguy> dino-, duh :)
12:12:29 <edwinb> inside GHC it's just polymorphic lambda calculus. The rest is "just" syntactic sugar...
12:12:33 <edwinb> Ahem. Just...
12:12:34 <shapr> dino-: But I'm just saying that Haskell's style makes somethings easier to express.
12:13:13 <dino-> Hey, sorry if it was a silly question. I have very little math education. :/
12:13:28 <chessguy> GHC :: Maybe Sugar -> LC
12:13:48 <shapr> dino-: I have less, I'm sure :-)
12:14:00 <shapr> dino-: That's why I can't answer your question.
12:14:20 * resiak oO( Did anyone work Maybe Sugar into the Coffee discussion earlier? )
12:14:35 <edwinb> Just Milk, please
12:17:07 <czanonie> Anyone want to shed some light for me onto parsing in Happy? Does it lack an automated parse generator, and in that case, must I use alex?
12:18:13 <psnl> czanonie: difference between parsing and lexing
12:21:08 <qwr> hmm. yi seems to not love DEL key
12:21:16 <qwr> YIKES: tried to put nongraphic
12:23:00 <Excedrin> is a type like data Bar = B Foo Foo; data Foo = A | B | C; represented internally by GHC as a byte?
12:23:03 * qwr . o O ( something with xterm and vty? )
12:24:36 <czanonie> psnl: err, i mean -- Lexing in happy.
12:25:27 <bd_> Excedrin: B (reallyLongComplexPossiblyNonTerminatingComputation) C :)
12:25:33 <emu> what's syntactic saccharine?
12:25:49 <beschmi> czanonie: you need alex er
12:25:50 <bd_> data Bar = B !Foo !Foo could theoretically be represented with a double-word.
12:26:08 <bd_> I don't know if GHC actually packs it quite that tight.
12:27:07 <bos> @hoogle foldl'
12:27:08 <lambdabot2> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
12:28:13 <araujo> czanonie, just code your lexer function
12:28:58 <Excedrin> bd_: how can I check?
12:29:16 <bd_> Excedrin: not sure :/
12:29:18 <czanonie> araujo: alex isn't preferred over a huge overloaded function?
12:29:22 <bd_> <-- isn't really a GHC hacker
12:29:35 <bd_> I think there's a flag to dump the raw Cmm somewhere, but I don't know which it is :/
12:30:04 <edwinb> I usually end up hand coding a lexer, but alex is probably better
12:30:54 <psnl> I normally write ut stuff for alex
12:30:57 <AStorm> bd_, -ddump-cmm
12:31:26 <AStorm> Or something like that, I'll check my bash history :P
12:32:27 <AStorm> Haskell really needs a benchmark like Python's timeit
12:32:51 <bd_> nofib?
12:33:02 <AStorm> No no... it's for user code
12:33:06 <AStorm> it's not a language bench.
12:33:17 <araujo> czanonie, Haskell makes that kind of stuff easy
12:33:30 <araujo> i don't think you end up with too huge functions
12:34:13 <AStorm> Like quickcheck is for testing.
12:34:59 <AStorm> Well, it would be simple to extend QuickCheck with iteration timing :-)
12:35:07 <edwinb> Hand coded lexers are small, but I think I'd have more faith in one generated by alex than one I wrote myself
12:36:25 * araujo would porbably be afraid too if he were using other language instead :-)
12:36:27 <AStorm> That would cover most uses. Another would be just timing a certain code snippet.
12:37:06 <AStorm> (not necessarily QuickCheck-enabled)
12:37:15 <syntaxfree> http://japple.blogspot.com/2007/01/how-many-functions-are-there-of-type.html
12:37:17 <lambdabot2> Title: Everyone Else is Crazy, http://tinyurl.com/yujtyx
12:37:25 <syntaxfree> I don't understand what he means by "continuous" there.
12:38:26 <bd_> @hoogle (a -> a -> Ord) -> [a] -> a
12:38:27 <lambdabot2> No matches, try a more general search
12:38:35 <bd_> @hoogle (a -> a -> Ordering) -> [a] -> a
12:38:35 <lambdabot2> Data.List.maximumBy :: (a -> a -> Ordering) -> [a] -> a
12:38:35 <lambdabot2> Data.List.minimumBy :: (a -> a -> Ordering) -> [a] -> a
12:38:59 <dino-> I can't even read some of that. What does this mean: f _|_ =/= _|_
12:39:17 <bos> @pl \m (k,v) -> Map.insert k v m
12:39:17 <lambdabot2> (`ap` snd) . (. fst) . (((Map .) .) .) . flip (flip . insert)
12:39:39 <bos> mmm, crunchy.
12:39:43 <allbery_b> I don't see the problem: a discontinuous function would have some value v for which f v /= _|_ (the discontunuity)
12:40:03 <allbery_b> discontinuity
12:44:39 <Botje> dino-: it means f is not strict
12:46:00 <dino-> Botje: Ok. Thank you.
12:46:02 <ndm> anyone here off to BCTCS?
12:50:02 <beschmi> hi mnislaih
12:51:16 <bos> @pl \x -> (reverse . dropWhile isSpace . reverse) x
12:51:16 <lambdabot2> reverse . dropWhile isSpace . reverse
12:51:25 <bos> hmph :-)
12:51:36 <mnislaih> hey beschmi
12:51:43 <beschmi> hope you had backups for everything important
12:51:46 <mnislaih> I got me a new macbook
12:52:04 <vincenz> mnislaih: I hate you
12:52:12 * mnislaih lost almost everything and 200€ paying some guy to try and recover it
12:52:21 <mnislaih> I am selling the old one
12:52:24 <Botje> bos: concat $ init group
12:52:27 <mnislaih> 2 hard drives are enough
12:52:32 <Botje> bos: concat . init . group ? :)
12:52:52 <Botje> but that assumes there will always be spaces at the end, hrrm
12:53:13 <mnislaih> beschmi: how's hacking ?
12:53:18 <bos> Botje: right
12:53:40 <bos> Botje: what i need is an equivalent of python's rstrip
12:53:41 <beschmi> mnislaih: i can't push patches from stable to shim-debugger anymore, too many resolved conflicts in there
12:54:19 <beschmi> mnislaih: don't have much time for hacking in the next 10 days
12:54:21 <mnislaih> can I help with that ?
12:54:37 <mnislaih> I will find some time this weekend
12:55:02 <beschmi> mnislaih: have to do some things for my thesis until i go skiing on saturday
12:55:20 <beschmi> mnislaih: i don't think there is anything we can do
12:55:58 <beschmi> mnislaih: i fear we have to start with the stable repo again and rerecord the patches
12:56:48 <beschmi> mnislaih: i can do that tomorrow if you don't mind, i tried letting darcs run for more than 12 hours until i killed it
13:00:31 <mnislaih> I will take a look at the differences between the two versions
13:00:44 <mnislaih> maybe we should try to factor them apart, they shouldn't be that big
13:02:11 <mnislaih> it's mainly related with the handling of Sessions and some API changes in ghc-api, r
13:04:03 <mnislaih> uhm. Anyone who can read Turkish around ?
13:04:16 <bos> what's "module M" in a module's export list supposed to do?
13:04:39 <allbery_b> re-exports the entire module
13:04:51 <bos> that's what i thought, but i don't see it behaving the way I'd expect.
13:05:12 <bos> does it export the module's contents in the exporting module's namespace?
13:05:26 <bos> i.e. i have "module Config (module Data.Map) where ..."
13:05:28 <allbery_b> I think so
13:05:39 <bos> should I be using Config.lookup or Config.Data.Map.lookup?
13:05:47 <bos> neither one actually works in ghci for me, hence my confusion.
13:05:48 <sjanssen> bos: Config.lookup
13:05:52 <allbery_b> but, well, not sure --- hvae seen it a lot, haven't actually played with it
13:06:59 <bos> ok, it's a ghci bug.
13:07:19 <allbery_b> seems to work for me
13:07:29 <bos> eurh, not a ghci bug.
13:10:51 <hpaste>  bos pasted "my re-export conundrum" at http://hpaste.org/205
13:11:17 <bos> if i import Argh into another module, how do i perform a lookup on foo?
13:14:28 <newsham> ?bot
13:14:29 <lambdabot2> :)
13:14:42 <newsham> ?hoogle Char -> Int
13:14:43 <lambdabot2> Char.digitToInt :: Char -> Int
13:14:43 <lambdabot2> Char.ord :: Char -> Int
13:15:20 <paolino> bos , modules importing Argh are not seeing foo ?
13:15:20 <chessguy> > digitToInt 'c'
13:15:21 <lambdabot2>  12
13:15:35 <chessguy> heh
13:16:27 <bos> paolino: no, they're not seeing the Data.Map that i think I'm re-exporting
13:16:57 <hpaste>  glguy pasted "trimming end spaces" at http://hpaste.org/206
13:18:05 <bos> glguy: nice
13:18:09 <glguy> :-p
13:18:24 <glguy> and clear :)
13:18:41 <bos> yes :-)
13:19:03 <glguy> I love folds that return functions
13:19:11 <newsham> > map digitToInt "0123456789abcdef"
13:19:12 <lambdabot2>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]
13:19:21 <newsham> its almost as if they planned it that way
13:19:26 <siti> glguy: "1" is a function ;)
13:19:42 <newsham> > let 1 = 2 in 1
13:19:43 <lambdabot2>  1
13:20:04 <siti> lol
13:20:09 <bos> > let 1 x = x * 2 in 1 2
13:20:10 <lambdabot2>  Parse error in pattern
13:20:15 <bos> oh well.
13:21:01 <bos> glguy: did you construct that fold yourself? second-order folds mess with my head.
13:21:55 <allbery_b> huh.  looks like a bad interaction between exporting modules and import qualified
13:22:12 <allbery_b> if I do it unqualified, :browse-ing my test module shows all the stuff in Data.Map
13:22:32 <allbery_b> if I do it qualified, :browse says nothing
13:22:39 <siti> I hope you can't do > repeat 5 ?
13:22:59 <sjanssen> > repeat 5
13:23:00 <lambdabot2>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
13:23:04 <siti> ok :D
13:23:06 <siti> luck
13:23:08 <siti> lucky*
13:23:09 <bos> allbery_b: interesting
13:23:11 <sjanssen> siti: lambdabot is smart enough to truncate
13:23:16 <siti> yep
13:23:24 <bos> @pl \x->(head x, tail x)
13:23:25 <lambdabot2> liftM2 (,) head tail
13:24:01 <AStorm> bos, list is a monad too
13:26:10 <Botje> :t (,)
13:26:11 <lambdabot2> forall b a. a -> b -> (a, b)
13:26:53 <Botje> it's just using the ((->) r) monad
13:27:06 <gotaku> How do i run a subprocess?
13:27:11 <glguy> bos: that was by hand
13:27:29 <glguy> bos: I'm point freeing it now (by hand) it looks sweet ;)
13:27:41 <allbery_b> @hoogle runInteractive
13:27:42 <lambdabot2> System.Process.runInteractiveCommand :: String -> IO (Handle, Handle, Handle, ProcessHandle)
13:27:42 <lambdabot2> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
13:28:43 <bos> glguy: you are teh crazy :-)
13:28:44 <allbery_b> hm, tried to test in my ghc buidl, got a pointer allocation error.  tim to update it, methinks
13:29:11 <allbery_b> ghc 6.7 that is
13:29:41 <newsham> bos: do nested loops mess with your head?
13:30:11 <bos> newsham: no.
13:30:16 <glguy> cleanEnd xs = foldr aux (const []) xs id
13:30:16 <glguy>   where aux ' ' = (. (. (' ':)))
13:30:16 <glguy>         aux x   = flip id . (x :) . ($ id)
13:30:19 <glguy> bos: ^
13:30:29 <bos> glguy: wow
13:30:36 <matthew-_> so what's going to be new in 6.7 then?
13:30:48 <newsham> bos:  let carryfor init vals f = foldl f init vals
13:30:54 <glguy> > let cleanEnd xs = foldr aux (const []) xs id where aux ' ' = (. (. (' ':))); bux x   = flip id . (x :) . ($ id) in cleanEnd "this is a test    "
13:30:55 <lambdabot2>  Add a type signature
13:31:02 <newsham> then     caryfor 1 [1..5} (\x y -> ... )
13:31:03 <glguy> hmm
13:31:04 <sjanssen> matthew-_: 6.7 is the devel branch, 6.8 will be the actual release
13:31:09 <newsham> and its just a bunch of nested loops
13:31:28 <glguy> > let cleanEnd xs = foldr aux (const []) xs id where aux ' ' = (. (. (' ':))); aux x   = flip id . (x :) . ($ id) in cleanEnd "this is a test    "
13:31:29 <lambdabot2>  "this is a test"
13:31:29 <gotaku> What's the difference between runProcess and runInteractiveProcess?
13:31:37 <sjanssen> matthew-_: it looks like associated types will be in 6.8
13:31:44 <newsham> fold = loop with a carried variable (accumulator)
13:32:11 <newsham> writing it out in more traditional "for" loop format might make it clearer if you're from the imperative camp (like I am)
13:32:14 <matthew-_> sjanssen: right. any crazy magic new funky optimisations?
13:32:17 <sjanssen> matthew-_: most likely ghci debugger
13:32:27 <matthew-_> ?where associated types
13:32:28 <lambdabot2> I know nothing about associated.
13:32:43 <sjanssen> @google associated type synonyms
13:32:44 <lambdabot2> http://www.cse.unsw.edu.au/~chak/papers/CKP05.html
13:32:44 <lambdabot2> Title: Research Papers of Manuel Chakravarty
13:32:49 <matthew-_> thanks
13:33:03 <bos> gotaku: runInteractiveProcess gives you stdin, stderr, stdout
13:33:08 <sjanssen> matthew-_: data parallel Haskell might be in 6.8
13:33:09 <newsham> sum = 0; for val in [1..5] : sum += val; return sum   ==>  carryfor 0 [1..5] (\x y -> x + y)
13:33:18 <siti> who needs a terminal / webbrowser when you have lambdabot :D
13:33:42 <matthew-_> sjanssen: mmm. that won't help me though ;)
13:34:09 <siti> my biggest issue with ghc/gtk2hs is I can't do os level threads in gtk2hs :(
13:34:19 <newsham> carryfor 0 [1..5] (\accum val -> accum + val)
13:34:30 <matthew-_> jhc works on whole program optisations doesn't it? Is there any noise on pulling those into ghc? Or is ghc going to remain open-world ?
13:36:36 <Notostraca> Anyone know the basics of HGL?
13:36:51 <Notostraca> Or something considered better for 2d stuff
13:37:34 * allbery_b builds new ghc, now with 119 more patches!
13:38:16 <Notostraca> Or better yet, is there any news on ycr2js?
13:38:44 <beschmi> matthew-_:  i don't think so, it's a completely different intermediate language (GRIN).
13:39:13 <beschmi> matthew-_:  another cool thing in 6.7/6.8 is the ghci debugger
13:39:13 <matthew-_> ahh... I can see how that would be a problem ;)
13:39:26 <glguy> it's a shame that ((->) r) isn't an instance of MonadTrans
13:39:32 <siti> that's very cool having a debugger :D
13:39:35 <matthew-_> mmm. I'll have to have a look at that.
13:39:39 <siti> that will help so many people learn I think
13:39:42 <glguy> ?instances MonadTrans
13:39:43 <lambdabot2> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
13:39:55 <matthew-_> It's certainly a shame to be forced to do debugging via println
13:39:57 <sjanssen> glguy: that'd cause all sorts of overlapping instance issues
13:40:09 <glguy> sjanssen: :-(
13:40:36 <fasta> beschmi: Did you use it?
13:40:39 <fasta> beschmi: I did
13:41:03 <mnislaih> fasta: any comments/suggestions ?
13:41:14 <fasta> mnislaih: you wrote it?>
13:41:14 <beschmi> fasta: yes, i even found a bug using it for the first time
13:41:21 <matthew-_> is it as good as the eclipse java debugger ?
13:41:29 <fasta> matthew-_: hahaha
13:41:32 <fasta> matthew-_: of course not
13:41:33 <matthew-_> can you do dynamic code replace?
13:41:36 <mnislaih> well matthew-_ .. no way !
13:41:45 <matthew-_> dynamic value modifications?
13:41:56 <beschmi> fasta: in my code and in the ghci code ;)
13:41:58 <mnislaih> you can replace IOVars and such
13:42:04 <matthew-_> cool
13:42:07 <sjanssen> matthew-_: "modification" is a dirty word in #haskell :)
13:42:12 <matthew-_> sure
13:42:24 <fasta> mnislaih: Is there any point in me explaining to you what's wrong with it?
13:42:38 <matthew-_> err - I dunno - I'd think that within an IORef it would be safe -ish
13:42:46 <mnislaih> fasta: yes, I guess
13:42:58 <mnislaih> fasta:  I am very interested
13:43:23 <mnislaih> it is only a prototype right now
13:43:35 <mnislaih> so there is a lot of room for improvement
13:44:18 <mnislaih> fasta: I wrote parts of it
13:44:29 <matthew-_> is there an emacs interaction mode for it?
13:44:42 * matthew-_ considers going and finding the thing rather than annoying #haskell with questions
13:44:47 <beschmi> mnislaih: *g*
13:44:55 <fasta> mnislaih: ok, well, I was debugging pure code, and wanted to know the value of something. Unfortunately, it contained some subvalue that had not been evaluated yet. Ok, I thought, just grab the "variable" and ask for that subvalue. The result is something like "Hey, if you want to get the type of this expression "do complicated stuff" (yes, I did manage to find how to do that with the "documentation" in Trace). So, g
13:44:55 <fasta> etting the value seems to be impossible.
13:45:03 <beschmi> matthew-_: we're working on it
13:45:15 <dons> morning all
13:45:30 <mnislaih> fasta: you can seq things using :print
13:45:30 <fasta> Another thing: I want to know the bindings in effect _just_before_ I get *** Exception..
13:45:32 <glguy> morning
13:45:37 <fasta> mnislaih: no
13:45:41 <fasta> mnislaih: That doesn't work
13:45:42 <mnislaih> take a look at the documentation  ! :)
13:45:46 <Notostraca> G'day
13:45:51 <fasta> mnislaih: I tried it.
13:45:56 <mnislaih> it is in the ghc manual
13:46:19 <mnislaih> the second wish, intercepting exceptions, is not possible yet
13:46:19 <glguy> > Event 30348 of TxContext HAppS.Protocols.HTTP.Request
13:46:19 <lambdabot2>  Parse error
13:46:24 <fasta> mnislaih: I had a value Foo <un evaluated value>.
13:46:36 <mnislaih> yrs
13:46:42 <fasta> mnislaih: I got the unevaluated value out of it via a function bar.
13:46:42 <mnislaih> yes fasta that is not a problem
13:46:55 <fasta> mnislaih: Then I did seq <the value> <the value>
13:47:05 <mnislaih> we have worked a lot to support that situation, the manual shows how to do it
13:47:37 <mnislaih> http://www.haskell.org/ghc/dist/current/docs/users_guide/ghci-debugger.html
13:47:39 <lambdabot2> Title: 3.8. The GHCi debugger, http://tinyurl.com/2nxab2
13:47:47 <fasta> mnislaih: why doesn't the way I described it work?
13:48:01 <fasta> mnislaih: I could extract the type of the unevaluated stuff, though.
13:48:17 <fasta> mnislaih: also the UI never indicated that I could get the actual value of the thing.
13:48:17 <mnislaih> because it was not only unevaluated, but insufficiently typed
13:48:48 * glguy wonders how something could be insufficiently typed at runtime
13:48:58 <fasta> mnislaih: So, you are saying that if I first got the type, then annotated the seq <value> <value> thing with that type, it should work?
13:49:02 <mnislaih> maybe we should improve the UI, but there is a message about that
13:49:08 <mnislaih> "This is an untyped, unevaluated computation. You can use seq to
13:49:08 <mnislaih> force its evaluation and then :print to recover its type"
13:49:17 <fasta> mnislaih: right, I could get the type
13:49:24 <fasta> mnislaih: I couldn't get the value
13:49:37 <fasta> mnislaih: that's all that message communicates, or my English is _really_ bad.
13:49:50 <monochrom> mnislaih: "goberned" typo, should be "governed", in that page :)
13:49:57 <mnislaih> thanks :)
13:50:03 <yip> @seen kolmodin
13:50:03 <lambdabot2> kolmodin is in #haskell and #haskell.se. I don't know when kolmodin last spoke.
13:50:04 <sjanssen> morning dons, did you see that lambdabot is being a zombie?
13:50:24 <matthew-_> presumeably you can use the debugger to alter the behaviour of the program? eg try to eval an infinite list etc?
13:50:25 <chessguy> ?seen dons
13:50:26 <lambdabot2> dons is in #haskell. I last heard dons speak 5m 10s ago.
13:50:26 <fasta> mnislaih: so, why doesn't seq <the value> <the value> works?
13:50:55 <mnislaih> because the value is already WHNF,
13:50:58 <dons> hmm
13:51:11 <mnislaih> seq only forces partially, not completely.
13:51:17 <dons> good old lambdabot2. that version is indestructable
13:51:31 <chessguy> dons, it's been up and down too
13:51:32 <beschmi> hmm isn't seq x x always equivalent to just x
13:51:36 <fasta> mnislaih: Are you saying that <the value> as in my example is already in WHNF?
13:51:42 <fasta> mnislaih: That doesn't make sense.
13:51:48 <sjanssen> beschmi: yes, it is
13:51:52 <monochrom> Yeah, "seq (Foo undefined) ..." will not dig into the undefined.
13:52:01 <fasta> monochrom: I know that.
13:52:04 <sjanssen> unless Foo is a newtype
13:52:09 <fasta> monochrom: my example didn't do that.
13:52:13 <kolmodin> yip: hi
13:52:19 <sjanssen> or undefined is in a strict field
13:52:34 * kolmodin just got home from a workshop
13:52:50 <dons> http://programming.reddit.com/info/11zam/comments
13:52:52 <lambdabot> Title: Haskell: too hard, or just hard enough? (reddit.com)
13:53:11 <glguy> dons: that mailing list ruby v haskell thread made it to reddit
13:53:14 <yip> kolmodin: hello! are you the author of hinotify?
13:53:21 <monochrom> I see.
13:53:22 <dons> glguy: yeah, not sure if that's good or bad. the comments seem good
13:53:33 <glguy> dons: I was quite surprised
13:53:38 <kolmodin> yip: yes, that's me
13:53:53 <dons> hehe, random blog: "I've decided not to use Lisp at all, instead I've wrote a
13:53:53 <dons> little parse in Haskell"
13:53:59 <dons> we win!
13:54:06 <mnislaih> :)
13:54:28 <fasta> data Foo = Foo {bar::Int}
13:54:28 <fasta>  
13:54:28 <fasta> The complete value is: a = Foo <something unevaluated>
13:54:28 <fasta> I do seq (bar a) (bar a)
13:54:28 <fasta>  
13:54:29 <fasta> Why wouldn't that work? AFAIU, you misunderstood.
13:54:39 <kolmodin> yip: do you find it useful? I'd love some feedback
13:54:49 <yip> kolmodin: cool. have you thought about portable inotify alternatives, that will work on freebsd or windows?
13:55:27 <kolmodin> yip: sorry, it only works on linux kernels 2.6.13+ or something like that
13:55:35 <kolmodin> yip: windows does not have anything similar
13:55:40 <Igloo> fasta: Do you mean   seq a (bar a)   ?
13:55:48 <kolmodin> yip: as far as I've heard, I'm not a windows user myself
13:56:01 <kolmodin> yip: don't know about *bsd
13:56:26 <fasta> Igloo: Actually, I didn't. So, that might be where the problem is.
13:56:29 <Notostraca> Okay, as a Haskell newbie, I'm trying to understand this:
13:56:30 <kolmodin> yip: I've heard that beos has had notification support since 199* something, but they don't support GHC :D
13:56:32 <yip> kolmodin: mono project has something called FileSystemWatcher that uses inotify on linux, some api on windows, and some kqueue thing on freebsd, and falls back to polling as a last resort
13:56:32 <Notostraca> http://haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Draw-Text.html#2
13:56:34 <lambdabot> http://tinyurl.com/33qdel
13:56:48 <fasta> Igloo: is seq (bar a) (bar a) incorrect?
13:56:55 <kolmodin> yip: yeah, it would be really nice to extend to other platforms
13:57:05 <glguy> !paste
13:57:06 <hpaste> Haskell paste bin: http://hpaste.org/
13:57:09 <Heffalump> fasta: well, it's probably not very useful
13:57:10 <Notostraca> Thing is, I don't know how to setTextColor
13:57:25 <kolmodin> yip: but the inotification support remains the same. you can always add another layer on top which abstracts over implementations/platforms
13:57:36 <dons> mnislaih: http://programming.reddit.com/info/11zcc/details
13:57:37 <lambdabot> Title: The new GHCi debugger: breakpoints for Haskell (reddit.com)
13:57:39 <Igloo> fasta: That says "When asked to evalaute (bar a) to WHNF, first evaluate (bar a) to WHNF
13:57:54 <Heffalump> and then throw away the result and reevaluate bar a
13:57:57 <Heffalump> (probably)
13:57:59 <mnislaih> !
13:58:18 <monochrom> "seq (bar a) ..." should dig to the int part, from my understanding, which is probably what fasta expects too.  If it doesn't, I'm surprised.
13:58:30 <fasta> monochrom: right
13:58:31 <fasta> The value of seq a b is bottom if a is bottom, and otherwise equal to b. seq is usually introduced to improve performance by avoiding unneeded laziness.
13:58:31 <Igloo> fasta: i.e. just (bar a) would be just as good. Yours will either be identical or will use more time and memory
13:58:32 <Cheery> Hi mortals, is there a way to make it show lambdas in ghci?
13:58:36 <yip> kolmodin: yeah, the api looks good. i actually have a few questions about it, but first: why did you decide to call the module System.INotify and not System.Linux.INotify or something?
13:58:45 <dons> > (\x -> x) :: Int -> Int
13:58:48 <lambdabot>  <Int -> Int>
13:58:51 <dons> Cheery: like that?
13:58:55 <Heffalump> monochrom: but there's no reason that the first (bar a) would be in the same place as the second (bar a)
13:59:01 <fasta> Igloo: well, the debugger doesn't support that.
13:59:04 <dons> (its usually easier to just use :t to see the type)
13:59:05 <Cheery> dons: well, yes.
13:59:09 <dons> :t \x -> x
13:59:11 <lambdabot> forall t. t -> t
13:59:12 <Igloo> fasta: Doesn't support what?
13:59:17 <yip_> kolmodin: yeah, the api looks good. i actually have a few questions about it, but first: why did you decide to call the module System.INotify and not System.Linux.INotify or something?
13:59:25 <monochrom> Heffalump: that does not contradict my expectation.
13:59:32 <xpika> quit
13:59:35 <Cheery> It tends saying: No instance for (Show (a1 -> a1))
13:59:43 <dons> right.
13:59:45 <fasta> Igloo: The debugger shows a set of bindings. One of these bindings was l = SomeConstructor <some unevaluated value>
13:59:50 <dons> import Text.Show.Functions
13:59:55 <kolmodin> yip_: the libary is still very young and as far as I know it has quite few users
13:59:56 <Cheery> I tried this: map (+) [1,2,3]
13:59:58 <Cheery> :)
14:00:01 <fasta> Igloo: I extracted the value from it using a record accessor.
14:00:07 <dons> :t map (+) [1,2,3]
14:00:08 <kolmodin> yip_: it's not too late to change that or the api
14:00:08 <lambdabot> forall a. (Num a) => [a -> a]
14:00:10 <Cheery> dons: thanks.
14:00:15 <dons> > map (+) [1,2,(3::Int)]
14:00:15 <fasta> Igloo: but the "value" still showed <unevaluated value> with some message.
14:00:17 <lambdabot>  [<Int -> Int>,<Int -> Int>,<Int -> Int>]
14:00:28 <mnislaih> fasta:  I = Foo (_t1::Int)
14:00:35 <mnislaih> and then you can do seq _t1 ()
14:00:36 <chessguy> what in the world?
14:00:39 <mnislaih> and :print _t1
14:00:45 <chessguy> functions derive show now?
14:00:54 <kolmodin> yip_: also, it will simply not show on windows installations as there is no point of installing it there. so why call it .Linux if you only can see it on a linux system?
14:01:01 <Igloo> fasta: bar is the accessor? If so, that seq expression you showed above wasn't getting evaluated
14:01:01 <fasta> mnislaih: And what will the result be in that case?
14:01:16 <fasta> Igloo: bar is the accessor.
14:01:20 <mnislaih> or you could do :print l
14:01:29 <fasta> Igloo: I evaluated in the debugger.
14:01:30 <kolmodin> yip_: I try to make the users of the library aware of that it only exists on the linux platform by the docs
14:01:36 <fasta> it*
14:01:36 <mnislaih> and get the contents of l after the evaluation of bar l
14:01:38 <chessguy> > (+) 1
14:01:40 <lambdabot>  Add a type signature
14:01:49 <chessguy> > (+) (1 :: Float)
14:01:51 <lambdabot>  <Float -> Float>
14:01:54 <yip_> kolmodin: fair enough. i noticed that there doesn't seem to be a way to close the inotify file descriptor, like you would do in c, close(fd);
14:02:08 <chessguy> is this a 6.6 thing? or an hs-plugins thing? or what?
14:02:23 <fasta> mnislaih: Ok, so you are saying that just normally evaluating it "as usual" should work?
14:02:25 <kolmodin> yip_: that could be added
14:02:32 <fasta> mnislaih: If that's the case, there's a bug somewhere.
14:02:32 <monochrom> Hmm!  Does the debugger cover up its tracks?  I.e., if it evaluates something (upon interactive request, not normal program flow), it unwinds the evaluations afterwards?
14:02:34 <dons> Cheery: its a lambdabot extension, we just have an instance for functions
14:02:34 <kolmodin> yip_: remember that it's still 0.1 :)
14:02:48 <dons> s/chessguy/
14:02:56 * chessguy is feeling quite Cheery today, thanks :)
14:03:13 <yip_> kolmodin: ok :) i have a question about the user action that is executed in response to an inotify event. they are run in a seperate thread, right?
14:03:25 <kolmodin> yip_: so far, yes
14:03:47 <yip_> kolmodin: are all of them run in the same thread, or does each get it's own thread?
14:03:51 <kolmodin> yip_: I'm planning on adding a non threaded way too, but the interest for the library has been quite little
14:04:26 <kolmodin> yip_: eumm. let me check
14:05:15 <Cheery> Hmm, here ghci tends to say <function>
14:05:23 <kolmodin> yip_: all events share the same thread, which actually makes sence
14:05:38 <Cheery> maybe it's ok, since I learned a way to see the type description. :)
14:05:47 <kolmodin> yip_: as I can't guarantee the order they would be executed if they where separate threads
14:05:57 <fasta> mnislaih: As for other ideas: I would like to go back and forward in "time".
14:06:39 <yip_> kolmodin: so if event A happens, then A's handler starts running, and then if event B happens while A's handler is still running, then B's handler will wait until A's handler finished running and only then itself start?
14:06:39 <chessguy> fasta, you'll need a trans-flux capacitor
14:06:50 <kolmodin> yip_: correct
14:07:05 <fasta> chessguy: No, it has already been done before.
14:07:14 <Cheery> But hey! I want to know yet one thing, there has seemed to be some activity around Haskell by public.
14:07:20 <mnislaih> fasta yes, that would be very nice. That is something that I would really like to have and certainly thougth about
14:07:21 <Slarba> holy s*it cheery
14:07:30 <mnislaih> thought*
14:07:33 <Cheery> Do you know why?
14:07:47 <kolmodin> yip_: I'm planning on adding another way of getting the events, without threading. that way you could decide yourself how you'd like it
14:07:55 <fasta> dons spams reddit?
14:07:55 <Cheery> lol, Slarba, terve!
14:08:08 <bos> there's no join on threads in Control.Concurrent?
14:08:13 <bos> how odd.
14:08:17 <yip_> kolmodin: ok cool, but the way it is now seems to be pretty optimal for me at least =]
14:08:25 <kolmodin> yip_: but you're like the fifth user to say anything about the library :)
14:08:47 <fasta> Anyway, writing a good debugger probably takes years.
14:08:52 <kolmodin> yip_: ok, I'll see what I can do. maybe this week, if you're lucky :D
14:09:07 <Cheery> fasta: it may also be not worth it.
14:09:16 <kolmodin> yip_: I'd probably accept patches, if they look nice.... :)
14:09:37 <Cheery> at least osdev -guys tend to think like that.
14:09:43 <fasta> Cheery: it depends on what the life span of the human race is.
14:10:06 <bos> woo! i can make ghci crash.
14:10:19 <fasta> bos: that's quite easy
14:10:27 <fasta> bos: just hand it a wrong .so library
14:10:29 <bos> that's a bit depressing.
14:10:34 <yip_> kolmodin: i don't think i see a need for anything to be changed :)
14:10:39 <bos> oh, i'm doing this all from my own code.
14:10:54 * allbery_b thought all that took was deriving unsafeCoerce
14:11:02 <kolmodin> yip_: I take that as a compliment :)
14:11:15 <fasta> Even if the project doesn't use a library, it still crashes on it.
14:11:21 <Cheery> fasta: Well, by the time when you make a good debugger, you would have fixed thousand programs.
14:11:22 <fasta> That's a bit wrong.
14:11:24 <Cheery> without it.
14:11:49 <fasta> Cheery: not everyone should write his own complete software stack.
14:12:00 <fasta> (I do end up doing this in some cases)
14:12:06 <Cheery> and after doing the debugger, it may not be so useful.
14:12:29 <Cheery> Especially in haskell I can think what kind of pain it may be debugging code since things are declarative and lazy. :D
14:12:31 <fasta> Claiming that a programming environment doesn't need a debugger is ridiculous.
14:12:35 <yip_> kolmodin: as you should. another question though: i think i noticed that you did your own implementation of OneShot, manually removing the watch after an event, instead of just passing the flag through. or am i mistaken?
14:12:55 <fasta> Cheery: Haskell is _not_ declarative.
14:13:03 <Philippa> fasta: definitions vary
14:13:09 <fasta> Philippa: Oh, sure.
14:13:20 <Philippa> it's declarative if you think declarative means more than "logic language"
14:13:21 <pejo> Cheery, why would declarative be a problem?
14:13:24 <Cheery> fasta: could you explain that debugger and not declarative -thing?
14:13:41 <Cheery> pejo: because source code being so much different than resulting code.
14:13:43 <fasta> Mathematics is declarative sometimes.
14:14:21 <Philippa> laziness is the problem
14:14:22 <kolmodin> yip_: OneShot automatically removes the watch on the linux side, correct. that also means that the responce to the event in the haskell side isn't needed. not removing it would lead to a memory leak
14:14:34 <monochrom> I think the current ghci debugger is in the right direction, i.e., to hell with "lines", breakpoints are attached to subexpressions.
14:14:35 <fasta> Cheery: I am not in the mood, but try programming something non-trivial (e.g. >4K LOC)
14:14:43 <pejo> fasta, even wikipedia clumps together logic programming languages and functional ones, as declarative languages.
14:14:44 <Cheery> pejo: causing it's possibly hard to interpret where is the problem from binary.
14:15:10 <monochrom> The next thing on the wish list is: stepping :)
14:15:12 <yip_> kolmodin: hm...
14:15:13 <Cheery> fasta: what is that non-trivial you could think of?
14:15:16 <Philippa> Cheery: the debugger can be built on top of an interpreter if it comes to that, no biggie. And even without that, the main reason the object code's so odd is just framework-building
14:15:26 <fasta> pejo: I am not maintaining those Wikipedia pages, obviously :)
14:15:35 <Adamant> lol. "declarative" == buzzword.
14:15:45 <fasta> Adamant: :)
14:16:37 <kolmodin> yip_: OneShot removes the response in haskell land the first time it's called. the event thus contains rm_watch, which is defined as 'modifyMVar_ em (return . Map.delete wd)'
14:16:37 <monochrom> Someone should also use the GHC API to hook this debugger to a GUI, so that everyone can act snobbish and say things like "I never use the mouse". :)
14:16:38 <pejo> fasta, I'm not sure I understand  your criterias for selecting information. You refute Sabry defining what a pure functional language is in JFP which is a highly respected journal, but use wikipedia when it supports your arguments, and you refute it when you don't maintain the pages.
14:17:05 <kolmodin> yip_: that is, only removing the event response that just was called as it won't be called again
14:17:33 <fasta> pejo: When did I refute that? Could you post the URL?
14:17:42 <Philippa> Adamant: nope, it's been around rather longer than its current buzzword usage
14:18:00 <monochrom> I think every programmer in the world understands lazy evaluation just fine. XD
14:18:14 <Philippa> you have low values of "just fine" :-)
14:18:15 <yip_> kolmodin: very interesting. my new understanding raises some more questions
14:18:32 <pejo> Philippa, or "every".
14:18:32 <fasta> Cheery: Transform the ElGamal problem to e.g. a coloring problem.
14:18:34 <ndm> monochrom: i already intend to hook this debugger to a mouse
14:18:45 <fasta> Cheery: that will sure keep you busy for a few days.
14:19:11 <Adamant> Philippa, declaritive means what people want it to mean. really, there are just languages with more abstraction ability than others.
14:19:12 <Philippa> pejo: or high values of "programmer", perhaps
14:19:22 <Cheery> I will add it to list. :)
14:19:28 <fasta> pejo: ?
14:19:49 <Hunter_wow> I have 2 lists(as input). And I whant it to become +1(Int) when one element exists into both lists. Example: lists [1,2,3] [2,3,4] = 2 (2,3 is in both)
14:20:05 <Hunter_wow> any ideas for that?
14:20:08 <allbery_b> ?hoogle union
14:20:10 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
14:20:10 <lambdabot> Data.IntMap.union :: IntMap a -> IntMap a -> IntMap a
14:20:10 <lambdabot> Data.IntSet.union :: IntSet -> IntSet -> IntSet
14:20:25 <ndm> ?hoogle length
14:20:26 <lambdabot> Prelude.length :: [a] -> Int
14:20:26 <lambdabot> Data.PackedString.lengthPS :: PackedString -> Int
14:20:26 <lambdabot> Foreign.Marshal.Array.lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
14:20:28 <Philippa> Adamant: so basically you're complaining about it being a cluster concept. The notion certainly makes sense when you look at typical logic languages and query languages
14:20:31 <ndm> (the other half of the question)
14:20:37 <pejo> fasta, no, I don't keep logs.
14:20:54 <Philippa> I wouldn't say SQL has a high abstraction ability, but it's declarative
14:21:02 <Hunter_wow> yea, guess union should do it, thx
14:21:05 <Cheery> fasta: thanks.
14:21:08 <Cheery> and good night.
14:21:44 <Adamant> Philippa, when you write in a functional or logic language, you're still writing in a specialized language and declaring what you want, just as I declare what I want when I write imperative code
14:21:51 <fasta> pejo: well, then I doubt that you remember what I said.
14:22:28 <kolmodin> yip_: we might have to take them another day, I have to get up pretty early tomorrow :) don't hesitate to mail me or ask at #haskell-cafe
14:22:34 <kolmodin> yip_: kolmodin@dtek.chalmers.se
14:22:56 <kolmodin> yip_: I also try to be available here as often as I can
14:22:56 <yip_> kolmodin: ok i need to think some more about this stuff more anyway, have a good one!
14:22:58 <ihope> Hey, I just got a stupid idea!
14:23:10 <Philippa> Adamant: Sure. A good rule of thumb would be that being forced to give a list of instructions suggests you're not working declaratively as per the term's actual meaning
14:23:19 <kolmodin> yip_: you too! nine to get some feedback! good night :)
14:23:21 <Philippa> knowing how to declare an imperative doesn't change that
14:23:26 <Adamant> if you want to say declarative is "language that reduces easily to a mathematical abstraction", that's cool
14:23:32 <ihope> Introduce people first to Unlambda, then to Haskell.
14:23:42 <chessguy> @go unlambda
14:23:47 <lambdabot> http://www.madore.org/~david/programs/unlambda/
14:23:47 <lambdabot> Title: The Unlambda Programming Language
14:23:57 <Adamant> a shit sandwich to make people appreciate caviar?
14:24:09 <dons> ihope: but there's a pure and lazy unlambda now
14:24:15 <dons> anyone remember the url?
14:24:17 <SamB> Adamant: I still think I'd rather have peanut butter and jelly!
14:24:27 <Adamant> SamB, well, it is THAT TIME
14:24:42 <Philippa> Adamant: I'm actually referring to the title of a paper...
14:24:53 <ihope> dons: Lazy K?
14:25:01 <dons> ah yes
14:25:17 <Adamant> what is a "list of instructions"?
14:25:18 <chessguy> if you're going to learn unlambda, you may as well learn BF
14:25:50 <Adamant> funny, that sounds like pretty much all programs
14:26:19 <Hunter_wow> ok, wasent union at all =(
14:26:42 <ihope> chessguy: BF is yucky.
14:26:52 <chessguy> ihope, and unlambda's not?
14:26:53 <Adamant> I get the idea that you shouldn't, say, have to muck with memory management when you're trying to outline what you want code to do
14:27:04 <ihope> chessguy: 'course it's not! It's functional!
14:27:12 <ihope> BF is just eeq.
14:27:14 <ihope> s/q/w/
14:27:18 <Philippa> Adamant: if you think all programs are lists of instructions, you're trying to treat all languages as imperative
14:27:48 <monochrom> Everyone understands macro expansion.  Understanding macro expansion is understanding 99% of lazy evaluation.  Haskell is a macro language that leaves room for compilation and code optimization.
14:28:02 <SamB> ihope: you do realize that unlambda is impure, I hope?
14:28:11 <ihope> SamB: yes.
14:28:11 <fasta> The composition operator is equivalent to a list of instructions in some sense.
14:28:11 * chessguy shudders
14:28:24 <yip_> haskell is also impure
14:28:40 <fasta> Haskell encourages to be pure.
14:28:50 <dons> at least we can tell from the type which is which.
14:28:50 <yip_> =)
14:29:01 <yip_> not always.... unsafePerformIO
14:29:06 <monochrom> ?type Debug.Trace.trace
14:29:08 <dons> you're not allowed to use that
14:29:08 <lambdabot> forall a. String -> a -> a
14:29:12 <dons> without proof!
14:29:13 <fasta> dons: there was some way to subvert the type system, as you know better than me.
14:29:14 <monochrom> Very pure, that. :)
14:29:16 <yip_> "unsafe" doesn't mean "wrong" :D
14:29:20 <Adamant> Philippa, so I'm not listing instructions when I declare values?
14:29:26 <ihope> Haskell is impure, but only a little.
14:29:28 <SamB> yip_: true... but haskell dose not have an impure I/O mechanism as the only way to do I/O
14:29:30 * glguy tries playing with Dzorak
14:29:42 <ihope> And everybody calls it pure.
14:29:48 <dons> good thing it is culturally biased in favour of referential transparency
14:29:56 <matthew-_> surely it's a required part of existing in the world which is not 100% written in haskell
14:29:56 <dons> so if you go breaking that, everyone kicks you
14:29:57 <Philippa> Adamant: right. You personally might choose to interpret the declarations as instructions, but that's you
14:30:09 <ihope> You know, I wonder how many people try do do I/O using unsafePerformIO because they can't figure out the IO monad...
14:30:16 <Adamant> but I'm telling the computer what values to store
14:30:17 <SamB> you can't write a pure program that does I/O in unlambda
14:30:22 <Adamant> that's not an instruction?
14:30:25 <Philippa> You might be
14:30:26 <Philippa> I'm not
14:30:27 <monochrom> The whole universe is a pure wave function.  Just ask any physicist.
14:30:31 <dons> ihope: not many I reckon, cause they need to know to import System.IO.Unsafe first
14:30:37 <dons> which is probably a clue they're doing something wrong
14:30:41 <dons> it doesn't come up much here
14:30:48 <Philippa> you're doing the equivalent of arguing everything in any programming language is an object
14:30:52 <ihope> Adamant: declaring a constant isn't really much of an instruction.
14:31:02 <bos> is it possible to join on a thread in haskell, or do i need to use an MVar?
14:31:04 <ihope> It's only executed once.
14:31:22 <Philippa> ihope: it isn't even that. It's the interpreter that chooses to treat it as one. It's just plain data
14:31:24 <monochrom> everything in a category is an object. XD
14:31:24 <Adamant> I guess what I am getting at is math, imperative programming, etc. are all just languages
14:31:24 <dons> bos, use the MVar to wait?
14:31:26 <ihope> And that's when the program is first loaded.
14:31:29 <bos> dons: right
14:31:41 <dons> ?users
14:31:42 <bos> dons: i'm used to thread libraries where there's a join action :-)
14:31:42 <lambdabot> Maximum users seen in #haskell: 322, currently: 299 (92.9%), active: 24 (8.0%)
14:31:43 <Philippa> Adamant: so? That doesn't invalidate categorisations
14:31:50 <chessguy> ?where history
14:31:51 <lambdabot> I know nothing about history.
14:32:01 <dons> bos, hehe
14:32:01 <Adamant> but what makes a language "more declarative"?
14:32:04 <chessguy> anybody have the link to the recent paper about the hsitory of haskell handy?
14:32:05 * glguy predicts a long recovery time
14:32:06 <Adamant> declarative to who?
14:32:13 <dons> chessguy: its linked from the front page of haskell.org
14:32:19 <chessguy> ah, nice
14:32:44 <dons> ?where+ history http://research.microsoft.com/~simonpj/papers/history-of-haskell/index.htm
14:32:45 <lambdabot> Done.
14:32:51 <Philippa> Adamant: I already gave you an answer
14:33:10 <Adamant> no, you defined imperative programming as being less declarative.
14:33:20 <dibblego> the fact that its order of execution is unspecified perhaps
14:33:26 <Adamant> sorry if I'm being dense.
14:33:30 <chessguy> someone trying to tell me haskell was invented by Nasa
14:33:34 * chessguy rolls his eyes
14:33:44 <dons> chessguy: that's hilarious
14:33:49 <Philippa> if the bulk of a typical program is declarations, the language is probably declarative
14:33:49 <dons> at least it wasn't the NSA
14:33:55 <Philippa> oh, or Java.
14:34:08 <dibblego> like those Apache Ant build files have no order of execution specified, then people use the "depends" attribute to basically force order of evaluation (sound familiar?)
14:34:15 <fasta> I think it were the Illuminati.
14:35:06 <gotaku> What are some well built haskell utilities I can pull apart?
14:35:33 <monochrom> lambdabot
14:35:56 <dons> gotaku: darcs? pugs? you want big or small?
14:36:11 <gotaku> lamdabot is probably too complicated for me.
14:36:30 <matthew-_> dibblego: that reminds me. I've been meaning to write a saner version of gnu Make in haskell for a while. Any takers?
14:36:54 --- mode: ChanServ set +o dons
14:36:58 --- topic: set to '["The Haskell programming language: the lambda revolution will be declared!","http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]' by dons
14:37:05 --- mode: ChanServ set -o dons
14:37:07 <gotaku> Define saner.
14:37:09 <dibblego> matthew-_, I'd like to write Apache Ant in Haskell, then have build.hs instead of build.xml - it's the same thing, just more functional and in a proper language
14:37:16 <Igloo> dons: What changed?
14:37:22 <dons> added the history link
14:37:34 <dons> and tweaked the slogan
14:37:58 <dibblego> you could call CABAL exactly that, but I think it can be more generally abstracted
14:38:08 <dons> matthew-_: yeah, a purely functional gnu make for arbtirary projects would be cool
14:38:14 <dons> it could have a proper list library for string hacking
14:38:23 <dons> instead of gnu makes $(filter ... and so on
14:38:39 <matthew-_> dibblego: ahh, I hate ant in that you manually specify depends. I love the way in make you just specify transformers and it can work out how to glue them together to get to the target from the current state#
14:38:51 <dibblego> matthew-_, yep, that's my point :)
14:38:52 <Philippa> Adamant: you may find it helps to think of "a foo language" as "a language that supports programming in a foo style"
14:39:05 <dibblego> matthew-_, I also think that library dependency management can be done better
14:39:17 <Philippa> (under which definition lisp is an almost anything language except for typeful and perhaps safe)
14:39:24 <Adamant> fair enough.
14:39:29 <beschmi> dons: seems to be the goal of omake, but i never tried it: http://omake.metaprl.org/index.html
14:39:31 <lambdabot> Title: The OMake build system
14:39:31 <beschmi> The OMake language is functional: functions are first-class and there are no side-effects apart from I/O.
14:39:52 <dons> yeah, that's the idea
14:40:04 <fasta> There's also Conjure written in Scheme.
14:40:10 <dons> make is really a graph traveral system
14:40:10 <fasta> Not mature, IIRC.
14:40:14 <dons> so should be pure
14:40:18 <matthew-_> mmm. The OMake makes me guess it's written in OCaml ?
14:40:24 <dons> gotaku: check the applications page on haskell.org
14:40:51 * kolmodin disconnects his brain. good night. \c -> c undefined
14:41:09 <dons> night kolmodin
14:41:20 <kolmodin> g'night dons
14:41:48 <beschmi> matthew-_: yes
14:42:15 <matthew-_> well clearly it's rubbish then, I don't know why #haskellers even suggested it! :-P
14:42:41 * mbishop hugs ocaml
14:42:58 * matthew-_ apologies for the outburst
14:42:58 <AStorm> ?botsnack
14:42:59 <lambdabot> :)
14:43:27 <chessguy> ocaml--
14:43:33 <monochrom> ocaml++
14:43:38 <AStorm> sleep :: AStorm Thinking -> AStorm Sleeping
14:44:26 <matthew-_> right, well I'll take a look at OMake then and gather some ideas. Last time I tried to write this I had much less knowledge of Haskell so am hoping things might turn out better this time!
14:44:32 <matthew-_> anyway, must sleep. nn
14:48:45 <dcoutts> g'night dons
14:49:33 * chessguy quit tired of sitting around at work doing nothing
14:50:08 <dcoutts> @tell siti you can do OS level threads now with ghc/gtk2hs, at least you will be able to do so with the second release candidate in a couple days time.
14:50:09 <lambdabot> Consider it noted.
14:52:10 <monochrom> yippee
14:52:42 <dons> dcoutts: see Simon's serialisation numbers?
14:52:50 <dcoutts> dons, yeah
14:53:00 <dcoutts> I didn't get a feel for absolute performance though
14:53:10 <dcoutts> only relative to existing
14:53:14 <dons> yeah
14:53:29 <bos> nice, though
14:53:55 <bos> damn, multithreaded programming in haskell is NICE.
14:54:37 <monochrom> You just have to compete with Java. :)
14:54:38 * bos has a little concurrent program going, just from reading the Haddock for Control.Concurrent
14:54:59 <sjanssen> bos: wait till you try STM
14:55:00 <dcoutts> dons, the GC is interesting
14:55:10 <xpika> can someone implement the folling simple lisp continuation in haskell http://en.wikipedia.org/wiki/Continuation
14:55:11 <lambdabot> Title: Continuation - Wikipedia, the free encyclopedia
14:55:20 <dcoutts> dons, and we're not doing bounds check combining yet...
14:55:22 <brainly-green> how can I express selection without repetition in EBNF
14:55:30 <bos> sjanssen: i've written an STM implementation in python. it's much nicer in haskell :-)
14:55:46 <dcoutts> dons, I'm surprised the read time was so good, we've not optimised it yet at all have we?
14:55:47 <brainly-green> like if I wanted to select from "a" and "b" without repetition, the EBNF expression would be "" | "a" | "b" | "ab" | "ba"
14:55:52 <bos> STM: java < python < haskell
14:55:53 <brainly-green> but clearly this is impractical for lager number of symbols
14:56:15 <brainly-green> *a larger
14:56:17 <sjanssen> bos: of course it's nicer.  Nothing stops the python program from calling launch_nuclear_missiles() :)
14:56:25 <bos> sjanssen: zigackly.
14:56:35 <dcoutts> kolmodin, any insights on the question of how to do the string pool elegantly?
14:56:39 <dcoutts> and efficiently
14:57:08 <monochrom> xpika: it involves a mutable variable.  how would you like it cooked?
14:58:29 <xpika> ioref ?
14:59:17 <monochrom> I will use Control.Monad.Cont and an IORef.
14:59:33 <xpika> sounds yummy
14:59:57 <xpika> but a bit impure
15:00:03 <bos> oh, now that's interesting.
15:00:40 <dons> dcoutts: only a little bit
15:01:23 <dons> do we need an IORef?
15:01:27 <dons> StateT Cont ? :)
15:01:34 <dons> ContT State ?
15:01:43 <dcoutts> dons, huh? what do we need state for?
15:02:01 <dons> dcoutts: talking to monochrom :)
15:02:08 <dcoutts> ok :-)
15:02:09 <dcoutts> dons, btw, this IsString discussion is interesting. For the pattern matching it's going to be pretty horrid if it has to work by == on unpack/toString when we can do efficient == to start with.
15:02:15 <dons> hmm
15:02:29 * dons reads up
15:02:39 <dons> and tries to avoid a cat determined to close my laptop lid
15:02:49 <dcoutts> "I don't like the idea of having Eq as a superclass of IsString.
15:02:49 <dcoutts> It's a gratuitous constraint."
15:02:56 <dcoutts> "Sure, you can't
15:02:56 <dcoutts> use IsString for pattern matching quite as easily, but that's
15:02:56 <dcoutts> intentional."
15:02:57 <dons> hmm
15:02:58 <dcoutts> !!!
15:03:10 <Igloo> It can't work by unpack as it doesn't know about unpack
15:03:36 <dcoutts> Igloo, we'd make ByteString an instance of IsString, right?
15:03:41 <monochrom> xpika: actually, is it the example with (set! i (+ i 1)), or is it the example with abortable_procedure?
15:03:47 <dcoutts> and then we could use "literal" patterns
15:03:48 <Igloo> Yes, but you'd only tell it about pack to do so
15:04:05 <dcoutts> but they'd be checked by == on the toString version
15:04:08 <dcoutts> ie sloow
15:04:11 <astrolabe> Is that ghci debugger usable at the moment?
15:04:15 <Igloo> There isn't a toString
15:04:37 <dcoutts> Igloo, oh, sorry, perhaps I'm greatly confused
15:04:38 <Igloo> Pattern matches just cause an Eq a constraint
15:04:39 <twanvl> Are there any plans to have a ByteString that supports Unicode?
15:04:40 <xpika> monochrom: the first one
15:04:57 <dcoutts> Igloo, yes, ok I see, so it will use == on ByteString
15:05:00 <monochrom> ok
15:05:03 <Igloo> Yup
15:05:04 <dcoutts> twanvl, yep
15:05:06 <dons> twanvl: yeah, but needs someone who knows the code and really cares to step up
15:05:15 <dcoutts> Igloo, ok, my mistake, too much wine :-)
15:05:18 <dons> or the ability to get a paper out of it, whichever comes first :)
15:05:29 * dcoutts reckons it'd be easy
15:05:50 <Igloo> Ah good, dcoutts has just volunteered  :-)
15:05:51 <dcoutts> especially if one doesn't do non-fusible implementations
15:06:00 <dcoutts> hah hah hah, no.
15:06:15 <dcoutts> I've volunteered a Msc student
15:06:29 <dcoutts> well, I've proposed it as a Msc student project
15:06:38 <twanvl> I have thought about it myself, but doing it space-efficiently is hard.
15:06:38 <Igloo> dcoutts: BTW, any chance we can have an unstable cabal branch (1.4 or 2.0 or whatever)
15:06:39 <Igloo> For API changes
15:06:53 <dcoutts> Igloo, you mean a release or a darcs branch ?
15:07:00 <Igloo> A darcs branch
15:07:42 <dcoutts> Igloo, do you want a branch for the current stable and then continue in 'head', or do you want to branch a new dev version and leave the current?
15:07:47 <beschmi> astrolabe: the basic functionality was pretty stable for me
15:08:28 <Igloo> dcoutts: I just want somewhere we can make the API changes that want to be made, I don't care about the details
15:09:12 <bos> sjanssen: i'd like to try to finish off the SOC stuff you did with ropes and such, but i don't really know where it stands.
15:09:45 <bos> i have a different rope implementation based on boehm's original paper, but i prefer yours :-)
15:09:52 <astrolabe> beschmi: do you mean ghci in general or the debugger in particular?
15:10:18 <dcoutts> Igloo, I'll add a Cabal-branches/1.1.6 and then you can dump things in head
15:10:43 <beschmi> astrolabe: the debugger in HEAD as of two weeks ago
15:10:48 <Igloo> dcoutts: OK, cool, thanks!
15:11:19 <dcoutts> Igloo, oh, actually I've already done that
15:11:35 <dcoutts> Igloo, we've got darcs.haskell.org/cabal-branches/*
15:11:47 <dcoutts> with 1.1.4 and 1.1.6 atm
15:11:53 <gotaku> Are there any bindings for SDL?
15:11:55 <dcoutts> Igloo, so fire away with the head
15:11:57 <astrolabe> beschimi: thanks!
15:11:57 <dcoutts> gotaku, yep
15:12:15 <dcoutts> gotaku, check the libraries page on haskell.org
15:12:17 <Igloo> Cool
15:12:20 <Igloo> Thanks
15:12:23 <dcoutts> np
15:12:28 * dcoutts having done nothing at all
15:12:57 <shapr> matthew_-: Have you seen sane gnu make clone named "maak" and written in Haskell?
15:12:57 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
15:14:19 <shapr> @tell sorear yeah, kakapo kills processes that take up too much ram/cpu. My virtual server is a highly limited service.
15:14:20 <lambdabot> Consider it noted.
15:16:28 <dcoutts> shapr, hmm, can we steal maak code for use in Cabal ?
15:18:04 <dons> shapr: url? is it on haskell.org's development page?
15:18:10 <gotaku> Can I install hsSDL on windows
15:18:13 <gotaku> ?
15:20:09 <dons> Lemmih: do you know? ^^
15:20:31 <daniel_larsson> dons: http://www.cs.uu.nl/wiki/Trace/MaakBuildSystem
15:20:34 <lambdabot> Title: Trace / Maak Build System
15:20:53 <daniel_larsson> if you asked about maak, maybe i misunderstood )
15:21:19 <dons> any source available?
15:21:59 <dons> morning Pseudonym
15:22:33 <daniel_larsson> dons: https://svn.cs.uu.nl:12443/repoman/info/maak
15:22:43 <Lemmih> gotaku: I'm not sure.
15:22:45 <dons> svn! for shame ;)
15:23:08 <Pseudonym> G'day.
15:23:08 <chessguy> tut tut!
15:23:18 <Lemmih> gotaku: It should be possible with cygwin.
15:23:42 * dcoutts recommends mingw+MSYS over cygwin
15:23:54 <sorear> hello
15:23:55 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:24:00 <sorear> @messages
15:24:00 <lambdabot> shapr said 9m 41s ago: yeah, kakapo kills processes that take up too much ram/cpu. My virtual server is a highly limited service.
15:24:25 <bos> @pl either (const True) (const False)
15:24:26 <lambdabot> either (const True) (const False)
15:24:33 <sorear> bos: isLeft
15:24:40 <sorear> @hoogle isLeft
15:24:41 <lambdabot> No matches found
15:24:44 <shapr> dcoutts: Yeah, I asked the author about stealing maak for Cabal, and he said he'd likely start maintaining it again if cabal picked it up.
15:24:52 <sorear> hmm.  must've been in lambdabot only
15:25:02 <bos> sorear: isLeft isn't standard :-(
15:25:08 <dcoutts> shapr, hmm, we should investigate
15:25:16 <bos> Data.Either is very tiny and not especially useful :-(
15:25:26 <ihope> @index isLeft
15:25:27 <lambdabot> Graphics.HGL.Window, Graphics.HGL.Core, Graphics.HGL, Graphics.SOE
15:25:38 <chessguy> ?help index
15:25:38 <lambdabot> index <ident>. Returns the Haskell modules in which <ident> is defined
15:25:40 <ihope> isLeft (Left _) = True; isLeft _ = False
15:25:51 <bos> @index isRight
15:25:52 <lambdabot> bzzt
15:26:01 <bos> huh.
15:26:16 <bos> time to subscribe to libraries@
15:26:23 <shapr> dcoutts, dons: http://www.scannedinavian.com/~shae/maak-trunk.tar.bz2
15:26:56 <dcoutts> shapr, tell me more about it, what's the 10 second description?
15:27:02 <shapr> It's a DAG.
15:27:20 <shapr> dcoutts: http://www.cs.uu.nl/wiki/Trace/IntegratingSoftwareConstructionAndSoftwareDeployment
15:27:24 <lambdabot> Title: Trace / Integrating Software Construction And Software Deployment, http://tinyurl.com/yr9jny
15:27:28 <shapr> Eelco Dolstra
15:27:49 <dcoutts> shapr, yeah, I read that. It didn't speak to me.
15:28:02 <dcoutts> I could read the paper, but I'm trying to release Gtk2Hs :-)
15:28:13 <shapr> ah ok
15:28:20 <shapr> In that case, let's talk about it after you're done :-)
15:28:22 <gotaku> Why does GHC take so damn long to uninstall on windows?
15:28:44 <shapr> dcoutts: How about, it'll probably specifically designed to fix the "configurations" problem in cabal?
15:29:17 <shapr> gotaku: You could profile the uninstallation process and fix it so that it won't affect you or anyone else in the future.
15:29:37 <shapr> Hej Lennart
15:29:40 <dcoutts> shapr, hmmm.
15:30:41 <bos> @hoogle left
15:30:42 <lambdabot> Control.Arrow.left :: ArrowChoice a => a b c -> a (Either b d) (Either c d)
15:30:43 <lambdabot> Prelude.Left :: a -> Either a b
15:30:43 <lambdabot> Control.Arrow.leftApp :: ArrowApply a => a b c -> a (Either b d) (Either c d)
15:30:57 <sorear> bos: ?
15:31:20 <bos> sorear: thinking about the Either equivalent of fromJust
15:31:34 <sorear> bos: fromRight.
15:31:41 <bos> @hoogle fromRight
15:31:41 <sorear> @ty Data.Either.fromRight
15:31:42 <lambdabot> No matches found
15:31:44 <lambdabot> Not in scope: `Data.Either.fromRight'
15:31:49 <bos> yeah, doesn't exist.
15:31:56 <sorear> ok, I guess *that* is a lb extension too :)
15:32:02 * bos was reading the Data.Either source :p-)
15:32:31 <sorear> hehe.
15:33:42 <dons> shapr: so I hear you've written a nethack clone?
15:33:52 <dons> is it in darcs? there's been two or three guys asking about it
15:34:06 <shapr> dons: Nah, wasn't me. It was dark, aka Richard Braakman, and it was long years ago.
15:34:22 <dons> ah
15:34:23 <sorear> I started writing a nethack clone, but gave up, *mutable state nightmares*
15:34:28 <shapr> I just keep a local copy of neary every chunk of Haskell source I've seen, so I still have it around.
15:34:29 <yax1> urp, nethack
15:34:48 <yax1> one big terrible productivity problem
15:34:51 <sorear> dons: the incremental syntax highlighting conbinators aren't doing to well
15:34:57 <sorear> yax1: erc is worse!
15:35:23 <sorear> dons: I seem to be failing at the "Channel Hughes" spell. :)
15:35:28 <yax1> the emacs irc client?
15:35:35 <sorear> yax1: True
15:35:45 <yax1> heh
15:39:28 <chessguy> one last request for brainstorming suggestions before i start hacking on some code. if i were to code some kind of assembly line, where each point of service in the assembly line had to decide what point of service the product should go to next, how would you all recommend modelling that in haskell?
15:39:28 <augustss> Hej Shae
15:39:40 <yip_> dcoutts: did i hear correctly that threads will work properly with gtk2hs?
15:40:04 <dcoutts> yip_, well, you're allowed to shoot yourself in the foot, that's what's new.
15:40:14 <yip_> dcoutts: great!
15:40:39 <dcoutts> yip_, as in you can use OS threads but then it's your responsibility to make sure you don't call GUI stuff in more than 1 OS thread - ever.
15:40:48 <gotaku> When is the new version of gtk2hs coming out/
15:40:49 <gotaku> ?
15:40:51 <dcoutts> not just 1 at a time, only 1.
15:41:11 <sorear> *gulp*
15:41:28 <sorear> how did they create *that* dumb restriction!
15:41:29 <dcoutts> gotaku, soon, I'm building & testing the windows version of the 2nd RC at the moment
15:41:37 <dcoutts> sorear, blame win32
15:41:47 <dcoutts> sorear, on X11 it's only restricted to 1 at a time.
15:41:53 <astrolabe> dcoutts: That's good.
15:42:12 <chessguy> hmm, no comments?
15:42:21 <bd_> Is there a runInGUIThread :: IO a -> IO a?
15:42:24 * Igloo looks bemused at the idkwtok in c2hs
15:42:24 <yip_> dcoutts: what about gdk_threads_enter/gdk_threads_leave?
15:42:24 <sorear> chessguy: how about CPS?
15:42:29 <sorear> bd_: yes
15:42:40 <bd_> ah, okay
15:42:51 <sorear> chessguy: have each stage call the appropriate next stage tail-ly
15:43:02 <sorear> bd_: of course it's not called that :)
15:43:07 <chessguy> sorear, wouldn't that be more like each service point telling the next service point where to send the product when it's done?
15:43:09 <lypanov> ruby sucks
15:43:10 * sorear checks thae Name
15:43:18 <chessguy> that = CPS
15:43:23 <dcoutts> yip_, aye, that's the 1 thread at a time solution, we're going with the 'post to main thread' solution at the moment and provide postGUISync and postGUIAsync which you have to call to do GUI stuff if you're not in the main GUI thread.
15:43:46 * lypanov wonders if haskell is any better
15:44:02 <yip_> dcoutts: 'post to main thread' raises some kind of event in the main thread?
15:44:02 <lypanov> anyone using the cococa bindings?
15:44:27 <dcoutts> yip_, yep, postGUISync :: IO a -> IO a
15:44:43 <sorear> lypanov: duh haskell is better, if you want a different answer ask on #ruby :)
15:45:03 <sorear> lypanov: seriously I haven't tried ruby
15:45:17 <sorear> lypanov: it still looks like "structured befunge" to me
15:45:27 <lypanov> sorear: i'm learning scala atm
15:47:07 <yip_> dcoutts: hm... i don't understand
15:47:24 <sorear> yip_: it creates a high priority idle callback
15:47:38 <sorear> yip_: don't ask me why that's possible from an arbitrary thread
15:48:37 <yip_> sorear: the returned value is ignored?
15:48:56 <sorear>     +postGUIAsync action = do
15:49:02 <sorear>     +  idleAdd (action >> return False) priorityDefault
15:49:29 <sorear> yip_: of course -how do you expect to get a value from an async call?
15:49:31 <sorear> OR,
15:49:31 <bd_> sorear: probably just so you can do things like that :)
15:49:36 <yip_> sorear: i see... so shouldn't that be postGUISync :: IO a -> IO () ?
15:49:55 <sorear> yip_: *no*, that's *A*synchronous
15:50:04 <sorear>     +postGUIAsync :: IO () -> IO ()
15:50:08 <sorear> or,...
15:50:17 <sorear>     +postGUISync :: IO a -> IO a
15:50:25 <sorear>     +  resultVar <- newEmptyMVar
15:50:30 <sorear>     +  idleAdd (action >>= putMVar resultVar >> return False) priorityDefault
15:50:37 <sorear>     +  takeMVar resultVar
15:50:46 <sorear> which DOES return a value ...
15:51:06 <sorear> dcoutts: so why is idleAdd legal in arbitrary threads?
15:51:12 <yip_> ok it all makes sense, but if idleAdd is thread safe, then maybe there are some more functions that also are?
15:51:42 <sorear> yip_: ask dcoutts - I don't even *use* gtk (2hs or otherwise)
15:51:55 <yip_> sorear: oh, ok.... you should :)
15:53:08 <sorear> gtk programs usually fail for me, "cannot open display" or similar :)
15:53:43 <sorear> @users
15:53:44 <lambdabot> Maximum users seen in #haskell: 322, currently: 288 (89.4%), active: 40 (13.9%)
15:54:05 <yip_> sorear: it's time to finally purchase that vga monitor
15:54:21 <yip_> sorear: and if not, then there is that text version of gtk :P
15:54:47 <eckhart> hi
15:55:23 <eckhart> i've a question regarding currying
15:55:26 <sorear> I do too have a 1024x768 monitor.  fbconsole beats xterm's ...
15:55:38 <sorear> eckhart: so many people do ...
15:55:44 <ihope> eckhart: "ask away" seems to be the motto of most IRC channels.
15:55:53 <sorear> eckhart: all functions take 1 arg.
15:55:56 <SamB> what combination of spices produces the best flavour?
15:56:11 <sorear> eckhart: multi-argument functions are a figment of your imagination.
15:56:20 <Pseudonym> SamB: That's easy.  Emacs and Perl.
15:56:23 <sorear> eckhart: as are zero-argument functions.
15:56:25 <ihope> eckhart: so yeah, unless you want us to just guess at the question, you better ask it.
15:56:36 <Pseudonym> They're also the best pizza toppings.
15:56:38 <eckhart> sorear just answered it
15:56:45 <SamB> Pseudonym: I can't eat those!
15:57:05 <Pseudonym> Why not?  I thought you could do everything with Emacs and Perl!
15:57:14 <ihope> sorear: good guess! :-)
15:57:17 <SamB> ihope: there aren't so many questions about currying
15:57:25 <SamB> Pseudonym: um, not eating!
15:57:26 <ihope> I guess that's true.
15:57:36 <ihope> What about questions about monads?
15:57:36 <SamB> I'm sure they have support for imaginary eating
15:57:41 <eckhart> my question was whether currying is some special concept or that it's just everywhere
15:57:46 <Pseudonym> Actually, Perl isn't good for currying.
15:57:46 <gotaku> Why doesn't something like this work?
15:57:47 <gotaku> http://pastebin.com/871664
15:57:58 <gotaku> I get a type error.
15:58:00 <Pseudonym> You want Hindley, Milner and turmeric.
15:58:27 <dons> heh
15:58:32 <sorear> eckhart: *technically* GHC has multi-arg functions, but it's just an optimization hack.  Currying is mandatory in the language spec.
15:58:33 <eckhart> because in high school it's explained as if there is a "currified" and an "uncurrified" version
15:59:01 <ihope> What ever happened to dependent typing?
15:59:02 <Pseudonym> The "uncurrified" version, in Haskell, is just a function which accepts a tuple/
15:59:07 <ihope> (a,b) -> c
15:59:11 <Pseudonym> ihope: Don't you like GADTs?
15:59:17 <sorear> eckhart: where are you from?  you mean there is a country forward enough to teach FP in high scholl?!
15:59:31 <eckhart> sorear: sorry, meant university
15:59:36 <Igloo> gotaku: What error?
15:59:37 <eckhart> sorear: from germany
15:59:45 <dons> sorear was about to relocate to europe...
15:59:52 <sorear> Where I'm from, computer class skips programming and teaches people how to point at proprietary software and drool
15:59:57 <ihope> gotaku: the problem is "in" is a keyword, so it can't be used as a variable name.
16:00:00 <ihope> I think.
16:00:04 <dibblego> sorear, in school?
16:00:21 <ihope> Pseudonym: are GADTs like dependent typing?
16:00:28 <SamB> sorear: I thought people were born knowing how to drool
16:00:30 <eckhart> the problem is that they explain it as if a -> (a -> a) and a -> a -> a are different things
16:00:30 <sorear> dibblego: Ambiguous parse error.
16:00:37 <SamB> people must be getting stupider than I thought!
16:00:49 <Pseudonym> ihope: It gets you some of the way there.
16:00:52 <ihope> eckhart: the weirdos...
16:00:53 <eckhart> so it made me wonder when hugs translated the first to the second
16:01:01 <dibblego> sorear, you computer class, is it school or university? and where are you from?
16:01:14 <ihope> Yeah, the only difference between a -> (a -> a) and a -> a -> a is that one has parentheses and the other doesn't.
16:01:22 <SamB> i.e., no difference
16:01:29 <sorear> dibblego: High school (focus on learning disabilities BTW), San Diego
16:01:35 <Pseudonym> ihope: A dependent type is a type that's predicated on a dynamic value.  GADTs let you choose an instance for a polymorphic type variable based on a constructor.
16:01:49 <Pseudonym> ihope: So it is dependent typing, just not all of it.
16:01:57 <SamB> sorear: do these disabilities include a pathalogical inability to drool?
16:02:40 <chessguy> ?where Gtk2Hs
16:02:41 <lambdabot> http://haskell.org/gtk2hs/
16:02:45 <dons> sorear, you thinking about university yet?
16:02:53 <sorear> Actually I think it's more whining and mac-worshipping ... <exaggeration-->
16:03:30 <chessguy> sorear, you're in high school?
16:03:31 <sorear> dons: haha. every time I go there a overload forces my brain to backtrack ...
16:03:34 <sorear> chessguy: yes
16:03:36 <eckhart> anyway, that answered my question completely, thank you
16:03:49 <chessguy> heh. i thought you were old
16:03:49 <eckhart> good night
16:03:59 <Pseudonym> Night.
16:05:22 <Saizan> so a zero argument function is a 1-arg that has yet taken one argument?
16:05:44 <ihope> Saizan: that would be a simple value.
16:05:45 <sorear> Saizan: a zero argument function is a value
16:06:20 <Saizan> but having both functions and values is quite annoying
16:06:38 <ihope> Saizan: a function is a value.
16:06:47 <dibblego> lol
16:07:21 <qwr> you can write () -> blaah to. but it wont make much sense in haskell ;)
16:07:36 <Saizan> mmh that doesn't go along with 0 argument functions don't exist
16:07:44 <qwr> in ml with side-effects it's usual though
16:07:45 <SamB> do you honestly know that there are non-functions?
16:07:55 <Pseudonym> qwr: Actually, that makes a LOT of sense in Haskell.
16:07:59 <Pseudonym> Because it's not a CAF.
16:08:01 <SamB> how do you know everything isn't just newtyped functions?
16:08:21 <Pseudonym> I use that trick to avoid space leaks occasionally.
16:08:56 <yip> sorear: here we go! http://zemljanka.sourceforge.net/cursed/screenshots/demo_rozdily.png
16:08:59 <lambdabot> http://tinyurl.com/lal2
16:08:59 <Saizan> SamB: mmh interesting, so all 1-arg functions are HOF
16:09:47 <SamB> Saizan: you never know!
16:10:17 <sorear> Saizan: there's a different equally consistant view
16:10:33 <Saizan> as?
16:10:38 <sorear> Saizan: everything is a function.  so called values are 0-arg functions.
16:10:43 <SamB> unless of course you cheat and look at the compiler output or sources
16:11:44 <bos> i have a taste question.
16:11:49 <sorear> yip: AAAHHH! my world!!
16:11:58 <bos> i have a function with a signature String -> String -> String -> String -> String -> IO String
16:12:09 <bos> the first 3 arguments are usually constant.
16:12:18 <Saizan> sorear: that doesn't fit too well with currying, i found myself trying to un-eta-reduce on the return value!
16:12:19 <Pseudonym> bos: That's a good start.
16:12:21 <sorear> can we add a lambdabot regex for .*have.*question.* -> Ask away!!
16:12:24 <bos> is it "better" to uncurry the first 3 arguments?
16:12:26 <Pseudonym> You did the right thing by putting them first.
16:12:50 <Pseudonym> You want to put "less const" arguments later than "more const" ones.
16:12:58 <bos> sure.
16:13:00 <Pseudonym> Is this function recursive?
16:13:09 <bos> no.
16:13:20 <bos> the first 3 args are a url, user name, and password.
16:13:22 <Pseudonym> In that case, it's up to you.
16:13:29 <Pseudonym> If they logically belong together.
16:13:51 <Pseudonym> So user name and password definitely belong together.
16:13:56 <Pseudonym> "Credentials" or something.
16:13:57 <gotaku> Why won't this compile? http://pastebin.com/871672
16:13:58 <bos> i don't like the long chain of (String ->), because it's easy to get the typing wrong.
16:14:13 <bos> so it statically typechecks, but explodes at runtime.
16:14:13 <Pseudonym> Another option is to use newtypes liberally.
16:14:20 <bos> yeah.
16:15:04 <Pseudonym> If they semantically belong together, I'd consider putting them in a structure.
16:15:35 <bd_> bos: data Context = C { cUsername :: String, cPassword :: String, cURL :: String} ; type ThingyM = Reader Context
16:15:40 <bd_> and do eg username <- asks cUsername
16:15:43 <Pseudonym> Newtypes are useful because you can promote them later.
16:15:53 <Saizan> ?type runInteractiveProcess
16:15:54 <Pseudonym> So your URL might, some day, become a Network.URI.
16:15:55 <lambdabot> Not in scope: `runInteractiveProcess'
16:16:03 <Saizan> ?hoogle runInteractiveProcess
16:16:04 <lambdabot> System.Process.runInteractiveProcess :: FilePath -> [String] -> Maybe FilePath -> Maybe [(String, String)] -> IO (Handle, Handle, Handle, ProcessHandle)
16:16:19 <bos> Pseudonym, bd_: thanks.
16:16:31 <Saizan> gotaku: you need to pass the outher argumets to runInteractiveProcess
16:16:36 <Saizan> *other
16:17:06 <edwinb> I see ghc has tastefully decided you want to run gnugo instead of test.exe in that message
16:17:23 <xpika> how can i liftIO writeIORef to a ContT?
16:17:33 <Pseudonym> No problem, and thanks for asking a question on taste. :-)
16:17:44 <SamB> xpika: with some parentheses
16:17:49 <Pseudonym> Appreciation of the finer things is rare.
16:17:50 <xpika> yep
16:17:56 <bd_> SamB: I prefer $ myself... :)
16:18:34 <gotaku> Saizan: Uhh... Oh. I forgot about the rest of them.
16:18:48 <xpika> what would the type signiture be?
16:19:33 <xpika> lifted_writeIORef :: IORef a -> a -> ContT (IORef a) IO () ?
16:20:17 <monochrom> lifted_writeIORef :: IORef a -> a -> ContT r IO ()
16:20:55 <monochrom> The r parameter will be instantiated when someone uses runContT; you cannot constrain it yet.
16:21:02 <bd_> lifted_writeIORef :: MonadIO m -> a -> m ()
16:21:05 <bd_> er
16:21:10 <Pseudonym> :t writeIORef
16:21:10 <bd_> lifted_writeIORef :: MonadIO m => IORef a -> a -> m ()
16:21:12 <lambdabot> Not in scope: `writeIORef'
16:21:18 <Pseudonym> Errr... yeah.
16:21:24 <Pseudonym> However, one suggestion.
16:21:50 <Pseudonym> Rather than lifted_writeIORef, I wonder if you're better off expending the energy on abstractions which aren't so generic.
16:22:10 <Pseudonym> Rather than write lifted_writeIORef, write getMyData instead.
16:22:23 <Pseudonym> Whatever your application-specific data is.
16:24:48 <hpaste>  monochrom pasted "translate from wikipedia continuation ex 1" at http://hpaste.org/207
16:25:09 <monochrom> that is for xpika
16:26:03 <bos> :type waitForProces
16:26:11 <bos> @type waitForProcess
16:26:12 <lambdabot> Not in scope: `waitForProcess'
16:26:14 <monochrom> xpika: you can also manually enter the commands inside main.
16:26:21 <bos> @type System.Process.waitForProcess
16:26:23 <lambdabot> System.Process.Internals.ProcessHandle -> IO GHC.IOBase.ExitCode
16:29:15 <xpika> monochrom: thanks!
16:29:15 <sorear> dons: to what extent is yi intended to become an extensible editor? (as opposed to merely an upgradable editor)
16:30:36 <xpika> monochrom: what does \k -> k() do?
16:31:03 <bd_> xpika: invokes its argument (of type () -> a) with ()
16:31:16 <bd_> not a very useful function really :)
16:31:24 <bd_> @djinn (() -> a) -> a
16:31:25 <lambdabot> f a = a ()
16:31:39 <bd_> @. . unpl pl djinn (() -> a) -> a
16:31:40 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "SrcLoc"
16:31:45 <bd_> @. pl djinn (() -> a) -> a
16:31:46 <lambdabot> f = id
16:31:51 <bd_> oO
16:32:02 <dons> sorear: without a base on ghc-api, not really
16:32:13 <sorear> bd_: ($ ())
16:32:13 <dons> so its just 'modifiable' really
16:32:17 <dons> as is
16:32:30 <bd_> sorear: yeah, I'm just wondering why lambdabot came up with that
16:32:34 <sorear> dons: it doesn't have to be runtime extensible to be extensible
16:32:35 <bd_> it seems... obviously wrong
16:32:44 <bd_> @pl f a = a ()
16:32:44 <lambdabot> f = id
16:32:53 <bd_> :t \a -> a ()
16:32:55 <lambdabot> forall t. (() -> t) -> t
16:33:00 <bd_> :t id :: (() -> t) -> t
16:33:02 <lambdabot>     Couldn't match the rigid variable `t' against `() -> t'
16:33:02 <lambdabot>       `t' is bound by the polymorphic type `forall t. (() -> t) -> t'
16:33:04 <sjanssen> pl doesn't parse () correctly
16:33:05 <bd_> bug?
16:33:06 <bd_> ah
16:33:08 <Pseudonym> @pl \a -> a ()
16:33:09 <lambdabot> id
16:33:11 <sorear> @pl \a -> a ()
16:33:12 <lambdabot> id
16:33:18 <sorear> gah?
16:33:24 <sorear> @pl ($ ())
16:33:24 <lambdabot> flip id
16:33:28 <Pseudonym> ?free f :: (() -> a) -> a
16:33:29 <lambdabot> g . f = f . (.) g
16:33:33 <dons> pl really needs to move to Language.Haskell
16:33:36 <sjanssen> pl needs to use a real Haskell parser
16:33:47 <dons> Thomas just didn't know about it.
16:33:49 <sorear> @pl \a -> a $ ()
16:33:49 <lambdabot> id
16:33:56 <sorear> @pl \a -> a $ foo
16:33:56 <lambdabot> ($ foo)
16:34:14 <sorear> methinks pl can't parse ()
16:34:16 <sorear> @pl ()
16:34:17 <lambdabot> ()
16:34:21 <sorear> @pl foo ()
16:34:22 <lambdabot> foo
16:34:24 <dibblego> > let r = foldl (flip (:)) [] in [1..10]
16:34:26 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
16:34:29 <dibblego> > let r = foldl (flip (:)) [] in r [1..10]
16:34:31 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
16:35:45 <sorear> dons: what I mean is, with lambdabot adding most new features is extremely easy - just drop a file in Plugin/ and edit Modules, and recompile.  Is it wanted for yi to have that flavor of extensibility?
16:35:48 <xpika> @pl "im noobie"
16:35:48 <lambdabot> "im noobie"
16:36:07 <dons> sorear: for the dev plugins, yeah, same idea
16:36:13 <dons> but we don't have any dev plugins for yi yet really
16:37:16 <sorear> Ideally I want syntax highlighting as a plugin.  (I don't think font-lock-mode is wired in...)
16:37:33 <sorear> of course I'll write it monolithic first and refactor later
16:37:49 <sorear> can't have anyone beating me to my promised karma :)
16:38:07 <vincenz> dons: hi!
16:38:15 <sorear> hI!
16:38:18 <vincenz> dons: seen my post
16:38:21 <vincenz> on reddit?
16:38:32 <dons> no?
16:38:44 <dons> you think i just sit around reading reddit all day? ;)
16:38:50 <vincenz> hmm, yes?
16:40:13 <dons> which comment? do you have a url?
16:40:32 <Igloo> No, we think you sleep all day and sit around reading reddit all night
16:40:36 <Igloo> Crazy Australians
16:40:40 <dons> heh
16:41:12 <newsham> whats the proper way to #ifdef haskell code for a platform?
16:41:29 <vincenz> http://programming.reddit.com/info/11x14/comments/c11xvg
16:41:31 <lambdabot> Title: Google is not a programming teacher (reddit.com)
16:41:45 <Igloo> Oh, that reminds me - a friend e-mailed to say he's been looking at Haskell again after seeing the FP/Haskell buzz on reddit
16:42:01 <Igloo> (the bad news is he's looking at lisp too, but you can't have everything  :-)  )
16:42:31 <dons> heh
16:43:29 <newsham> why is that bad news?
16:43:43 <newsham> haskell stands up well against lisp.
16:43:53 <newsham> could be a lot worse :)
16:45:00 <Igloo> newsham: I don't think there are per-platform CPP defines built in
16:46:17 <newsham> ghc user guide says os_HOST_OS=1
16:46:28 <newsham> but ghcplatnform.h says "These TARGET macros are for backwards compatibily... DO NOT USE!"
16:47:19 <newsham> oh, nevermind... wrong macros.
16:47:24 <Igloo> Doh, quite right, I was checking for TARGET ones which obviously wouldn't exist
16:47:41 <ptolomy> @pl f x y = length x + length y
16:47:42 <lambdabot> f = (. length) . (+) . length
16:47:50 <Igloo> $arch_HOST_ARCH will do what you want, with the disclaimer that doing so is evil etc etc  :-)
16:48:00 <Igloo> Oh, and that it's GHC only AFAIK
16:48:08 <sorear> TH? :p
16:52:03 <monochrom> xpika: think of it as:  k <- readIORef refcont; run (k ()).  I read the continuation from the variable, then execute it.
16:52:10 <bd_> hmm
16:52:15 <bd_> @pl f x y = length x + length y
16:52:16 <lambdabot> f = (. length) . (+) . length
16:52:26 <bd_> @pl should use arrow ops: curry (uncurry (+) . (length *** length))
16:52:27 <lambdabot> should use arrow ops : curry (uncurry (+) . (length *** length))
16:53:16 <bd_> @check \x y -> (length x + length y) == curry (uncurry (+) . (length *** length)) (x :: [Int]) (y :: [Int])
16:53:18 <lambdabot>  OK, passed 500 tests.
16:53:42 <dons> ?where MissingH
16:53:42 <lambdabot> http://software.complete.org/missingh
16:55:16 <newsham> does bulat irc?
16:55:16 <sorear> bd_: we know.
16:55:25 <bd_> :)
16:56:45 <sorear> I can't find him on /mode #haskell -b
16:56:51 <dons> bulat's back!
16:57:13 <dons> its been so empty on the mailing list :)
16:57:26 <newsham> not enough imperative haskell in your diet?
16:57:45 <monochrom> empty?  I thought the recent "how did you stumble upon haskell" thread has heated the mailing list up a bit.
16:57:51 * sorear mails Bulat a replacement SHIFT key
16:58:13 <dons> ?remember bulat it's very like higher education in Russia - no one really teaches you at our colleges so you should either learn yourself or die
16:58:14 <lambdabot> Done.
16:58:50 <newsham> in soviet russia you dont get higher education, higher education gets you
17:00:02 <sorear> c'mon, if bulat wants to write hand optimized code he shouldn't use haskell
17:00:15 <sorear> haskell is all about optimizing uber-naive code
17:00:30 <sorear> like head [0..]  -- takes forever literally coded in C
17:00:31 <monochrom> That is because russian colleges have a high admission standard, basically they admit you because you can learn by yourself.
17:01:22 <monochrom> The moral: More reason for "avoid success".
17:01:41 <Philippa> wow, bulat needs a 1:1 code:comment ratio to understand his own code two years later?
17:01:56 <monochrom> Heh, next year it's 1:2
17:01:56 <sorear> -- la la la la
17:02:06 <sorear> bulat's going senile !?
17:02:13 <mbishop> @yow
17:02:14 <lambdabot> Bo Derek ruined my life!
17:02:15 <dons> 1:1 is a good ratio!
17:02:17 <edwinb> hmm, 10 bulat messages in a row, am I up to it at this time of night?
17:02:23 <dons> if you want other people to contribute...
17:02:26 <Philippa> right
17:02:34 <Philippa> you shouldn't need it for your own code...
17:02:34 <dons> edwinb: they're short and fun though
17:02:40 <dons> he's getting back in the loop :)
17:02:44 <monochrom> I guess it depends on which part of Haskell you use.
17:02:49 <dons> Philippa: depends on how many ContT (StateT (IO .. ))  you have ;)
17:02:53 <sorear> edwinb: my mailsystem went into autmatic flood protection mode!!
17:02:56 <edwinb> Philippa: my own code might as well have been written by someone else 6 months later, I find...
17:02:58 <dons> heh
17:03:01 <newsham> int naturals() { struct nstate *nstate = malloc(sizeof *nstate); nstate->val = 0; nstate->next  = nstate_next; return nstate; }
17:03:01 <emu> -- You are not expected to understand this code
17:03:08 <monochrom> For example Oleg's code need 1:3 for the rest of us :D
17:03:19 <xpika> monochrom: in ghci when i type (contref, test) <- run defines run test >>= print
17:03:29 <newsham> int nstate_next(struct nstate *s) { return s->val ++; }
17:03:33 <xpika> i get Couldn't match expected type `()' against inferred type `Int'
17:03:37 <Philippa> dons: that may be a suggestion you should've written a wrapper that puts things in more domain-specific terms :-)
17:03:43 <edwinb> I'm just getting back into hacking on ivot after a few months and generally thinking "Which cowboy wrote this rubbish?"
17:03:46 <newsham> int head(struct nstate *gen) { return gen->next(); }
17:03:47 <edwinb> er, ivor
17:03:50 <Philippa> heh
17:03:50 <newsham> sorear: doesnt take forever.
17:04:01 <newsham> gen->next(gen);  of course :)
17:04:06 <Philippa> yeah, one of the reasons I don't write much code is I have an aversion to writing code that makes me think "ick"
17:04:15 <sorear> newsham: <sorear> like head [0..]  -- takes forever literally coded in C
17:04:15 <sorear>  
17:04:22 <Philippa> it tends to make me say a lot of other things ending in "ck" a few months later
17:04:23 <sorear> newsham: emphasis on *literally*
17:04:35 <newsham> sorear: I just showed C code that doesnt take forever
17:04:38 <newsham> qed.
17:04:40 <sorear> newsham: now go and rewrite that to return a linked list.
17:05:02 <newsham> isnt it a likned list?  the link operatin is gen->next(gen);
17:05:08 <sorear> newsham: if you allow yourself to optimize at all, 0, "qed"
17:05:14 <emu> newsham: whatsit do on empty list?
17:05:35 <dons> I want to see Bulat's take on Data.Binary!
17:06:05 <newsham> emu: gException = "stopIteration"; longjump(gExceptionHandler, 1);   probably :)
17:06:13 <sorear> I wonder if on Bulat's keyboard SHIFT is labelled CYRILLIC
17:06:27 <allbery_b> mommy, bulat's giving me a headache again... :}
17:06:44 <newsham> whatever the iteration protocol says it should do upon end of iterator.
17:07:10 <monochrom> xpika: I see.  I guess entering things manually kills some polymorphism that is needed later.
17:07:24 <newsham> come on, this isnt rocket science.
17:11:20 <monochrom> More details:  (run defines) returns a tuple, the 2nd component (test) has polymorphic type ContIO s Int = ContT s IO Int.  Later when you "run test", s can become Int to please "run".  But at the ghci prompt, s is fixed as () prematurely.
17:11:20 <newsham> generators (coroutines) arent that hard to build in C if you want em.
17:11:29 <sorear> must ... focus ... on ... yi+synhl
17:11:54 <sorear> AHH - 14 messages in one delivery!
17:11:55 <newsham> i sent "yi" patches to jean-philippe.  its building yi-gtk on win32 now
17:12:02 <newsham> and it works
17:12:14 * sorear curses the 10-message limit in debian-exim
17:12:15 <chessguy> ?hoogle randomRs
17:12:17 <lambdabot> Random.randomRs :: (Random a, RandomGen b) => (a, a) -> b -> [a]
17:12:17 <lambdabot> System.Random.randomRs :: (Random a, RandomGen g) => (a, a) -> g -> [a]
17:12:26 <sorear> newsham: jyp isn't the de jure maintainer
17:12:41 <Philippa> "yes! we hate category theory!!! :)" <- I'm tempted to point out one of Kirsten's commonly-used nicks in response...
17:12:44 <sorear> newsham: he should forward the patches, but ffr send them to dons
17:12:49 <sorear> ?
17:13:14 <newsham> my original patches werent ready for prime time.. but jyp had some that helped out
17:13:20 <newsham> so i leave it to jyp to submit them
17:13:57 <dons> my girlfriend bought herself a Go board. I think this is a good sign
17:14:10 <sorear> Philippa: /whois^-1(Kirsten Chevalier) \\ ["Binkley"]
17:14:58 <sorear> @localtime jyp
17:15:09 <Cale> dons: awesome, do you play?
17:15:17 <tessier_> Have there been any video games written in Haskell?
17:15:19 <edwinb> Clearly it's time for a #haskell collaborative go AI effort
17:15:20 <dons> not yet! but looks like I will be soon enough :)
17:15:24 <tessier_> Seems like I saw one once...
17:15:24 <dons> tessier_: Frag?
17:15:26 <dons> ?where games
17:15:27 <lambdabot> I know nothing about games.
17:15:35 <Philippa> sorear: Binkley isn't the only nick Kirsten uses
17:15:39 <mbishop> ?where frag
17:15:39 <lambdabot> http://www.haskell.org/haskellwiki/Frag
17:15:46 <dons> ?where+ games http://haskell.org/haskellwiki/Libraries_and_tools/Games
17:15:46 <lambdabot> Done.
17:16:01 <sorear> Philippa: I got that from your message ... what are the non-Binkley nicks?
17:16:15 <Philippa> amongst others, catamorphism
17:16:16 <sorear> CategoryTheory sounds a bit implausible :)
17:16:25 <dons> Philippa: oh, didn't now that
17:16:33 <xpika> games are difficlut to write in haskell because they are so state centered.
17:16:34 <dons> oh, hang on, I did
17:16:48 <dons> xpika: really? they're not that hard...
17:16:58 <dons> since state is kind of well understood in haskell
17:17:08 <sorear> xpika: programs are difficult to write in haskell, period. :)
17:17:10 <Pseudonym> It depends on the game.
17:17:12 <dons> heh
17:17:14 <Cale> tessier: yes, but nothing really really serious. Frag looks like a good start on an FPS, and it's a decent proof of concept, but needs work before it would really be fun.
17:17:30 <newsham> http://journals.cambridge.org/action/displayAbstract;jsessionid=55095F12907C51DE059EB8C26365196A.tomcat1?fromPage=online&aid=185137
17:17:33 <lambdabot> Title: CJO - Abstract, http://tinyurl.com/23ysom
17:17:39 <newsham> haskell in space
17:17:39 <chessguy> wow, now there's a URL
17:17:47 <dons> tinyurl++
17:17:50 <tessier_> Cale: I ask because I made a posting on slashdot about Haskell:
17:17:52 <Philippa> sorear: ah, that'd be why your obsession with the ivory tower? :-)
17:17:58 <dons> tessier_: oh? url...
17:17:59 <chessguy> heh. i had someone try to tell me today that haskell was invented by NASA
17:18:11 <Cale> chessguy: hahaha
17:18:19 <newsham> O'Nasa?
17:18:20 <mbishop> oh god
17:18:26 <sorear> Philippa: I don't get it ...
17:18:27 <tessier_> http://slashdot.org/comments.pl?sid=219610&cid=17818768
17:18:29 <mbishop> slashdot? and I thought programming.reddit.com was bad
17:18:29 <lambdabot> Title: IBM's Chief Architect Says Software is at Dead End
17:18:50 <tessier_> This multi-core thing is going to be a big boon for Haskell if the Haskell community knows how to play it right.
17:19:00 <tessier_> You all need to chime in here on this /. thread. :)
17:19:09 <chessguy> newsham, is that paper available somewhere, newsham?
17:19:21 <ludwig-> tessier_: cool. i've modded you up
17:19:25 <tessier_> ludwig-: Thanks!
17:19:48 <ludwig-> np. more people need to see that :)
17:20:12 <hpaste>  monochrom annotated "translate from wikipedia continuation ex 1" with "(no title)" at http://hpaste.org/207#a1
17:20:15 <emu> cause /. is world-influencing
17:20:35 <monochrom> xpika: that small change will make things easier for manual use
17:20:41 <tessier_> emu: When your world is tech it is.
17:21:11 <newsham> http://citeseer.ist.psu.edu/603515.html
17:21:12 <lambdabot> Title: Haskell in Space - An Interactive Game as a Functional Programming Exercise (Res ...
17:21:45 <Lemmih> Some Hac07 pictures: http://picasaweb.google.co.uk/lemmih/Hac07
17:21:47 <lambdabot> Title: Picasa Web Albums - David - Hac07
17:21:49 <dons> hmm, the first larger haskell program I wrote was a maze-like pacman game
17:21:49 <Cale> Ssshh! We don't want popularity!
17:22:01 <dons> where cops chased bear drinking monkeys around a maze
17:22:06 <dons> ah, 1999, so much fun
17:22:20 <dons> i wonder if that code is around somewhere
17:22:28 <emu> bear drinking?
17:22:38 <dons> yeah, the monkeys had to collect jugs of beer
17:22:44 <newsham> ouldnt bear to drink another drop
17:22:45 <emu> that sounds excellent
17:22:49 <dons> and that gave them the power to smack down the police
17:22:54 <dons> i think it was a bit undergraduate ;)
17:22:58 <xpika> good work monochrom! :)
17:23:29 <monochrom> thanks
17:24:06 <mbishop> tessier_: Your name is Tracy? and you're a dude? O_o
17:25:35 <tessier_> mbishop: Yep
17:25:56 <mbishop> tessier_: that's gotta suck
17:26:13 <tessier_> mbishop: Not really. Nobody has even mentioned it since I was in Jr High school.
17:26:17 <tessier_> You are the first person in years.
17:26:19 <vincenz> what are implicit parameters?
17:27:07 <mbishop> tessier_: I've noticed the nick (in #emacs), and recognized it from Neuromancer, but didn't know your name till I clicked on your slashdot spam :P
17:27:09 <Pseudonym> Evil.
17:27:14 <Philippa> vincenz: I'd say they're the spawn of satan, except they're actually the spawn of someone who thinks they're a bad idea
17:27:26 <vincenz> no seriousyl
17:27:28 <vincenz> -what- are they
17:27:36 <emu> special...variables?
17:27:54 <vincenz> example?
17:28:06 <beschmi> Lemmih: nice photos. it's such a shame that the hall was to dark
17:28:07 <Pseudonym> They're "false gods" and therefore you need not concern yourself with them.
17:28:11 <emu> i only used that in CL
17:28:13 <vincenz> ...
17:28:16 <vincenz> I still don't know anything more
17:28:20 <sjanssen> vincenz: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
17:28:21 <sorear> > let bar = ?foo in let ?foo = 1 in bar
17:28:21 <vincenz> Apparently they exist in haskell
17:28:21 <lambdabot>  Parse error
17:28:23 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
17:28:27 <tessier_> ghc is parallelizing now isn't it?
17:28:31 <sorear> what, no implicit parms in LB!?
17:28:33 <vincenz> ah, thanks ;)
17:28:41 <vincenz> dynamically scoped vars :)
17:28:43 <sorear> vincenz: ghci -e 'let bar = ?foo in let ?foo = 1 in bar'
17:28:44 <emu> dynamically-bound
17:28:45 <vincenz> or parameters
17:28:46 <sjanssen> sorear: the pre-parser can't handle them
17:28:56 <emu> ie. special variables (from Common Lisp)
17:28:59 <vincenz> thx
17:29:06 <vincenz> so just like parameters in mzscheme
17:29:48 <emu> so, anyone give the debugger a whirl
17:30:11 <monochrom> fasta gave the debugger a whirl.
17:30:44 <dons> beschmi: are Lemmih's photos up?
17:31:05 <beschmi> <Lemmih> Some Hac07 pictures: http://picasaweb.google.co.uk/lemmih/Hac07
17:31:07 <lambdabot> Title: Picasa Web Albums - David - Hac07
17:31:37 <mbishop> (Most of the following, stil rather incomplete, documentation is due to Jeff Lewis.)
17:31:40 <mbishop> I'll say, "stil"
17:33:00 <allbery_b> hrm.  ghc HEAD won't build for me.  Linker.c:1327:0: error: 'misalignment' undeclared
17:34:08 <sorear> ouch?
17:34:15 <sorear> allbery_b: @machine
17:34:58 <hpaste>  dons annotated "translate from wikipedia continuation ex 1" with "prettier contT" at http://hpaste.org/207#a2
17:36:30 <allbery_b> hm?  Mac OS X (PPC)
17:36:47 <pbx> Is it just me or is reddit chock-full-o-Haskell right now?
17:37:15 <dons> we have the techology!
17:37:18 <sorear> conversely too
17:37:26 <Excedrin> reddit is always chock-full-o-Haskell
17:37:30 <sorear> Haskell is chock-full-o-reddit links
17:37:48 <hpaste>  allbery_b pasted "ghc HEAD unhappy" at http://hpaste.org/208
17:38:04 <pbx> Hm. Maybe it's that phenom where you learn a new word and then everybody is "suddenly" using it.
17:40:25 <allbery_b> yep, darwin-specific code.  last I checked nightly bulds weren't being done for darwin/osx...
17:41:12 * Igloo is pretty sure that is just missing an oc->
17:42:17 <hpaste>  allbery_b annotated "ghc HEAD unhappy" with "oc->misalignment?" at http://hpaste.org/208#a1
17:43:13 <allbery_b> yeh, just got there, as paste says.
17:48:04 * allbery_b looks up bug reporting foo, but will build/test before firing
17:50:37 <pbx> Speaking of stuff found on reddit, I really liked this post: http://neilbartlett.name/blog/?p=11    It would be a cool thing to mention if there were some kind of weekly news outlet for Haskell where it could be posted... ;)
17:50:40 <lambdabot> Title: Neil&#8217;s point-free blog » Blog Archive » Haskell: Too Hard, or Just Hard  ...
17:50:57 <pbx> (Nice trunc!)
17:52:27 <chessguy> ok, suppose i have two lists of numbers, where the length of the second list is equal to the sum of the first. if the first list is [x,y,z,...], i want to group the first x numbers of the second list into a list, the next y numbers into another list, and so on. suggestions?
17:55:02 <monochrom> pbx: dons's Haskell Weekly News has a "blog noise" section.
17:55:22 <dons> pbx, yeah, it'll be in today's HWN
17:55:28 <chessguy> actually...i think i've got it
17:55:29 * dons loads up on caffeine
17:55:42 <calvins> Is there an easy way of rewriting "do exists <- doesFileExist filename; if exists then ... else ..." without needing to create the temporary 'exists'? I'd like to do "if .. then .. else", but can't of course, because doesFileExist returns m Bool rather than Bool.
17:56:00 <chessguy> @type take
17:56:02 <lambdabot> forall a. Int -> [a] -> [a]
17:56:11 <calvins> i know about when and unless, but  I need both the then and the else...
17:56:43 <monochrom> So quickly?
17:56:51 <pbx> "today's HWN" -- that sounds nice!
17:57:46 <chessguy> @unpl g (x:xs) ys = (take x ys) : (g xs (drop x ys))
17:57:46 <lambdabot> g (x : xs) ys = (take x ys) : (g xs (drop x ys))
17:57:56 <chessguy> @pl g (x:xs) ys = (take x ys) : (g xs (drop x ys))
17:57:57 <lambdabot> g = fix ((`ap` tail) . (. head) . ap ((.) . ap . ((:) .) . take) . (. drop) . flip . ((.) .))
17:58:04 <chessguy> lovely
17:58:13 * mbishop hides
17:58:16 <chessguy> why didn't i think of that?
17:58:42 <chessguy> does that look like the right iea though?
17:58:46 <pbx> dons: Just needling you for no reason. You appear to be a rather hardworking fellow.
17:59:05 <mauke> > mapAccumL (flip splitAt) "foo bar baz" [2,3,4]
17:59:06 <lambdabot>  ("fo",["o bar baz","",""])
17:59:29 <allbery_b> calvins: could liftM the if-then-else, perhaps (but that does the same thing really)
17:59:36 <mauke> :(
17:59:57 <beschmi> @type when
17:59:59 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
18:00:18 <chessguy> let g [] _ = []; g (x:xs) ys = (take x ys) : (g xs (drop x ys)) in g [2,3,4] [1..10]
18:00:22 <chessguy> > let g [] _ = []; g (x:xs) ys = (take x ys) : (g xs (drop x ys)) in g [2,3,4] [1..10]
18:00:23 <lambdabot>  [[1,2],[3,4,5],[6,7,8,9]]
18:00:38 * chessguy pats himself on the head
18:00:42 <beschmi> calvins: when also takes a bool, you have to define your own whenM, ifM, unlessM if you need them
18:01:32 <calvins> allbery_b: thanks, was hoping there's an ifM that i just didn't find in hoogle.
18:03:05 <calvins> beschmi: my bad, yeah, when and unless aren't related..
18:03:10 <mauke> > flip (mapAccumL ((uncurry (flip (,)) .) . flip splitAt)) [2,3,4] [1..10]
18:03:11 <lambdabot>  ([10],[[1,2],[3,4,5],[6,7,8,9]])
18:03:43 <chessguy> mauke, i prefer the non-obfuscatory version :)
18:03:50 <mauke> it's not really obfuscated
18:03:54 <chessguy> (is that a word?)
18:04:17 <mauke> it's just mapAccumL splitAt except you need two flips around splitAt
18:04:31 <chessguy> that's ok, i like my version :)
18:04:35 <chessguy> @type mapAccumL
18:04:37 <lambdabot> forall y acc x. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
18:04:49 <chessguy> acc?
18:04:52 <chessguy> what the heck?
18:05:00 <chessguy> accumulator?
18:06:08 <jcreigh> @src mapAccumL
18:06:09 <lambdabot> mapAccumL _ s []        =  (s, [])
18:06:09 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
18:06:09 <lambdabot>    where (s', y ) = f s x
18:06:09 <lambdabot>          (s'',ys) = mapAccumL f s' xs
18:07:12 <mauke> yep
18:08:51 <jcreigh> > mapAccumL (\acc x -> (acc*x, x)) 1 [1..5]
18:08:52 <lambdabot>  (120,[1,2,3,4,5])
18:09:19 <jcreigh> I guess it's map and foldl at the same time.
18:10:11 <mauke> > mapAccumL (\acc n -> let (x,y) = splitAt n acc in (y,x)) [1..10] [2,3,4]
18:10:13 <lambdabot>  ([10],[[1,2],[3,4,5],[6,7,8,9]])
18:10:54 <chessguy> mauke, do you really consider that superior to the version i gave?
18:11:16 <chessguy> serious question. i'm still learning
18:11:18 <sorear> @users
18:11:19 <lambdabot> Maximum users seen in #haskell: 322, currently: 281 (87.3%), active: 47 (16.7%)
18:12:05 <mauke> I don't think it's superior; just an alternative
18:12:12 <chessguy> ok
18:13:05 <heel3k> what is the difference between "Num a => a -> a" and "Num -> Num"?
18:13:23 <allbery_b> the latter is illegal?
18:13:23 <chessguy> the second one is illegal
18:13:26 <sorear> Num -> Num uses a nonstandard type called Num
18:13:32 <chessguy> Num is a typeclass, not a type
18:13:46 <sorear> Num a => a -> a is a function from any type of number to itself
18:13:53 <allbery_b> you'd have to unload the Prelude to define that nonstandard type...
18:14:41 * glguy_ got a flat tire this evening :-(
18:15:10 <jcreigh> aw, that sucks. I hope it wasn't raining or something while you put the spare on...
18:15:11 <glguy_> My trunk is too small to hold the wheel
18:15:23 <glguy_> it was just below zero wind chills
18:15:28 <glguy_> but I'd prefer that to rain
18:15:32 <jcreigh> zero F or zero C?
18:15:35 <glguy_> F
18:15:38 <jcreigh> ah
18:15:48 <jcreigh> well, maybe I shouldn't have said anything. :)
18:16:11 <mbishop> Cars are inefficient
18:16:35 <glguy_> I don't drive a car to be efficient :)
18:16:54 <glguy_> Computers are not intelligent :-D
18:17:23 <sorear> allbery_b: why is the second illegal?
18:17:27 <sorear> it's not here
18:17:39 <monochrom> computers are not efficient
18:17:52 <glguy_> it is cold today in missouri
18:17:56 <monochrom> laptops are a bit less guilty
18:18:22 * glguy_ wonders why we are enumerating facts
18:18:39 <chessguy> @pl take n (drop n r)
18:18:40 <lambdabot> take n (drop n r)
18:19:13 <allbery_b> sorear: you can define that with Prelude's numeric foo in scope?
18:19:42 <sorear> allbery_b: yes
18:20:00 <monochrom> Nothing in our civilization is efficient.  We should just go back to prehistoric times.  If you want to program in Haskell you can do so in your head.  Algebra of Programming FTW.
18:20:09 <dons> ndm, I note that NotePad 4 (?) now supports haskell (?)
18:20:15 <allbery_b> so you don't get an error if you name a type the same as a typeclass?  that seems somehow nonoptimal
18:20:18 <dons> for those win32 retro hackers
18:20:33 <sorear> how can notepad support haskell?
18:20:45 <Botje> it can edit them.
18:20:49 <glguy_> does that mean 8 space tabs?
18:20:57 <Philippa> dons: sure you don't mean TextPad 4?
18:21:06 <sorear> Botje: I can use notepad to edit *anything*.
18:21:14 <monochrom> In what sense does NotePad support Haskell?
18:21:15 <dons> http://the.bloggidity.com/2007/01/notepad-v40.html
18:21:17 <lambdabot> Title: Bloggidity: Notepad++ v4.0
18:21:21 <Philippa> sorear: not a binary file with a ^Z part way through
18:21:28 <dons> maybe that's something else entirely?
18:21:37 <dons> ah looks like it
18:21:56 <NichardRixon> huh, I just got around to making a notepad++ style for haskell
18:22:01 <NichardRixon> was my work already done for me?
18:22:05 <dons> maybe?
18:22:13 <dons> we should put notes about this on the dev page on haskell.org
18:22:15 <NichardRixon> >:(
18:22:16 <sorear> I still don't get how a editor can support a language.
18:22:16 <monochrom> OK, NotePad++ /= NotePad.  C++ /= C.
18:22:26 <sorear> NotePad-- Notepad-- notepad--
18:22:34 <dons> sorear: syntax highlighting, as i'm sure you can guess ;)
18:22:34 <sorear> tyvm. :)
18:23:04 <NichardRixon> sorear, in this case it might also mean that it supports function listing
18:23:08 <dons> NichardRixon: want to add some notes on NotePad + + here, http://haskell.org/haskellwiki/Libraries_and_tools/Program_development#Editor_support
18:23:10 <lambdabot> Title: Libraries and tools/Program development - HaskellWiki, http://tinyurl.com/y6kosp
18:23:24 <NichardRixon> because np++ supports a function list for at least c/c++
18:23:47 <glguy_> did the xcode plugin for Haskell ever get released?
18:23:59 <NichardRixon> glguy, it was all over reddit I think
18:24:22 <dons> glguy_: I'm almost certain that it hasn't been release (!)
18:24:27 <dons> metaperl!!
18:24:28 <NichardRixon> ha, the menu system on notepad-plus.sf.net is completely retarded, but it makes me laugh
18:24:53 <sorear> np--
18:25:50 <sorear> @users
18:25:51 <lambdabot> Maximum users seen in #haskell: 322, currently: 279 (86.6%), active: 47 (16.8%)
18:26:14 <monochrom> It is not retarded.  It is just funny.
18:28:23 <pbx> NichardRixon: Weren't the reddit links just to the HWN item that said, "where should I release this thing?"
18:28:31 <NichardRixon> could be, I never read them
18:28:53 <sorear> when is HWN expected next?
18:29:25 <dons> about 3 hours
18:29:38 <dons> or less
18:29:51 <chessguy> @karma np
18:29:52 <lambdabot> np has a karma of 0
18:29:57 <sorear> I was, er, counting on your v/^dons: /d to kick in :)
18:30:20 <mbishop> ?where hwn
18:30:21 <lambdabot> http://sequence.complete.org/
18:30:56 <sorear> seriously, Data.Binary and all that fun dons-hacky stuff matters a lot more than HWN.  don't pay attention to my whining.
18:31:01 <chessguy> i think we should place bets: which will happen first, the next release of gtk2hs or HWN?
18:31:09 <monochrom> Hahahahahahaha
18:31:22 <monochrom> @remember chessguy i think we should place bets: which will happen first, the next release of gtk2hs or HWN?
18:31:22 <lambdabot> Done.
18:31:36 <dgriffi3> @seen jre2
18:31:37 <lambdabot> jre2 is in #haskell-blah and #haskell. I don't know when jre2 last spoke.
18:32:02 <monochrom> that was too funny :)
18:33:10 <chessguy> @quote HWN
18:33:11 <lambdabot> chessguy says: i think we should place bets: which will happen first, the next release of gtk2hs or HWN?
18:33:15 <chessguy> @quote HWN
18:33:15 <lambdabot> chessguy says: i think we should place bets: which will happen first, the next release of gtk2hs or HWN?
18:33:17 <chessguy> bah
18:33:24 <chessguy> @quote gtk2hs
18:33:25 <lambdabot> scodil says: dcoutts: rad. i'm actually using gtk2hs quite a bit now. its one of those deals where I'm writing prototype software for people who aren't really paying for it, so it will end up being
18:33:25 <lambdabot> the production software, so you'll probably be getting emails in 5 years asking "what is haskell and how do I install it?"
18:33:33 <sorear> @quote
18:33:33 <lambdabot> spj says: it looks like hopscotch! (referring to a funny notation for lists)
18:33:48 <pbx> @protontorpedo
18:33:48 <lambdabot> is there going to be a better dns server in haskell?
18:33:58 <pbx> Sweet.  G'night all!
18:34:13 <sorear> night!
18:38:31 <dons> Botje: around?
18:39:24 <hpaste>  dons pasted "Botje's cold" at http://hpaste.org/209
18:41:39 <beschmi> neat, just found that there is a quickcheck command in isabelle. you can search for counterexamples before trying to prove a theorem
18:42:41 <sorear> dons: do you think it would be more productive to get non-incremental highlighting working first?  I already know approximately what to do for the full case...
18:45:11 <dons> sorear: yeah
18:45:16 <dons> anything is better than nothing!
18:46:04 <sorear> ok
18:46:47 <xpika_> whats the difference between IO and IO t
18:47:18 <sorear> xpika_: IO has kind * -> *, forall t. IO t has kind *
18:47:26 <sorear> xpika_: IO has kind * -> *, forall t. (IO t has kind *)
18:47:30 <Philippa> IO is a type constructor, IO t is a type
18:47:31 <glguy> sorear: incremental highlighting for Yi?
18:47:40 <sorear> glguy: BWHAHAHHAH!
18:47:48 <sorear> glguy: you want some?
18:47:56 <glguy> I've never run Yi before
18:48:15 <sorear> glguy: by BWHAHAHHAH I of course meant MUAHAHAHAHAHAHA
18:48:55 <glguy> Other than Haskell script-ability and being written in Haskell, are there other motivating factors for Yi?
18:49:14 <hpaste>  dons annotated "Botje's cold" with "Botje: unfoldr++" at http://hpaste.org/209#a1
18:49:30 <sorear> glguy: it's cool
18:49:31 <dons> @tell Botje http://hpaste.org/209#a
18:49:32 <lambdabot> Consider it noted.
18:49:50 <dons> glguy: vimscript sucks?
18:50:09 <xpika_> sorry i meant 't IO'
18:50:13 * glguy isn't trying to make a case against Yi, just looking to hear some of the sweet feature you had in mind :)
18:50:16 <xpika_> error:  Couldn't match expected type `IO' against inferred type `t IO'
18:50:21 <xpika_> unless they are the same
18:50:48 <sorear> glguy: full ghci integration. strong typing. easier to extend.
18:50:51 <sorear> @wiki Yi
18:50:52 <lambdabot> http://www.haskell.org/haskellwiki/Yi
18:51:04 <sorear> ^^^ the big why-we-want-it list
18:51:16 <glguy> cool, thanks
18:52:04 * sorear is experimenting with not immediately reading messages that do not contain 'sorear'
18:55:01 <beschmi> g'night
18:56:22 <araujo> hi!
18:56:25 <araujo> helllo
18:56:31 <sorear> hi.
18:58:54 <sorear> @localtime dylan
18:58:56 <lambdabot> Local time for dylan is Tue Jan 30 21:54:34 2007
18:59:04 <chessguy> hola araujo
18:59:27 <xpika_> @localtime xpika
19:00:13 <sorear> @tell dylan you can pull vty anytime ... the fix is long since done, just waiting for dons to get back on the hackage thingy before posting
19:00:14 <lambdabot> Consider it noted.
19:00:58 <araujo> hola chessguy
19:01:00 <araujo> :-)
19:01:09 <chessguy> como te va?
19:02:49 <araujo> chessguy, todo bien, llegando d ela univ
19:02:51 <araujo> :-)
19:06:42 <chessguy> que divertido
19:06:46 <chessguy> ?localtime araujo
19:06:48 <lambdabot> Local time for araujo is Tue Jan 30 22:59:35
19:07:37 <chessguy> asiste a una clase esta noche?
19:08:02 <mbishop> no comprende!
19:10:58 <dgriffi3> did hs-plugins get working with GHC 6.6? there seems to be more talk of Yi in the last couple of days
19:11:14 <sorear> yes, and yes, but unrelated
19:11:16 <chessguy> yes, just today i think
19:11:26 <dgriffi3> ahh
19:11:29 <sorear> yi works w/o hsplugins
19:11:43 <dgriffi3> hmm
19:11:44 <dylan> @tell sorear thanks
19:11:45 <lambdabot> Consider it noted.
19:11:50 <sorear> hs-plugins support in yi is bettably bitrotted
19:11:51 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
19:11:58 <sorear> @clear-messages
19:11:59 <lambdabot> Messages cleared.
19:12:00 <dgriffi3> oh
19:12:06 <dylan> @clear-messages
19:12:07 <lambdabot> Messages cleared.
19:12:27 <sorear> just don't confuse @clear-messages with @purge-notices :p
19:12:33 <dgriffi3> I thought that was one of the goals, extensibility through haskell, like elisp
19:12:49 <sorear> dgriffi3: extensible /= dynamic.
19:12:59 <dgriffi3> a good point
19:13:00 <allbery_b> that's supposed to involve ghc-api, thoug, not hs-plugins?
19:13:04 <sorear> I want an AOT compiled editor, and extensible is a big plus.
19:13:11 <hpaste>  dons annotated "Botje's cold" with "even faster" at http://hpaste.org/209#a2
19:13:18 <dgriffi3> sorear: AOT?
19:13:20 <sorear> allbery_b: hs-plugins uses old yi as a motivatng example
19:13:41 <sorear> dgriffi3: ahead of time.  used by the GCJ folks as an antonym to JIT.
19:14:07 <dgriffi3> i see
19:14:08 <dons> @tell Botje  http://hpaste.org/209#a2
19:14:08 <sorear> thought it might be in general usage...
19:14:08 <lambdabot> Consider it noted.
19:15:23 <dgriffi3> wikipedia does not have an entry for it
19:30:00 <newsham> so I can rebuild a lambdabot module and the changes will be available without me restarting the whole bot?
19:31:39 <csci> @tell csci Test ;-)
19:31:40 <lambdabot> You can tell yourself!
19:31:50 <mbishop> @yow
19:31:51 <lambdabot> Disco oil bussing will create a throbbing naugahyde pipeline running
19:31:51 <lambdabot> straight to the tropics from the rug producing regions and devalue the
19:31:51 <lambdabot> dollar!
19:33:40 <sorear> newsham: no, you need to relink and restart
19:34:02 <newsham> hmm.. wasnt the point of the yi/lambdabot paper that its dynamic w/o restart?
19:34:11 <sorear> newsham: lambdabot is extensible - if it wasn't you'd need to rewrite the whole bot every time you wanted to change something
19:34:20 <sorear> newsham: yes.  but that paper is *old*
19:34:45 <sorear> newsham: hs-plugins has only just un-bitrotted.
19:34:46 <newsham> I dont buy the "rewrite the whole bot each time.." thing :)
19:35:09 <newsham> *nod* (hs-plugins)
19:35:50 <allbery_b> I thought the only thing LB used hs-plugins for was @run
19:36:04 <sorear> allbery_b: that's true *now*
19:36:07 <sorear> well almost
19:36:10 <sorear> @check :)
19:36:10 <lambdabot>  Parse error
19:36:24 <newsham> so will lambdabot be more dynamic again in the future (post hs-plugins restoration)?
19:36:28 <newsham> or are those days gone?
19:36:30 <sorear> newsham: yes!!
19:36:40 <newsham> cool.
19:36:46 <araujo> chessguy, si
19:36:50 <sorear> newsham: dons doesn't seem to like restarting the bot :)
19:36:52 <araujo> chessguy, de noche asisto a clase
19:36:55 <sorear> @uptiem
19:36:55 <lambdabot> uptime: 5h 45m 9s, longest uptime: 2d 3h 42m 19s
19:37:01 <newsham> sorear: nor should he :)
19:37:05 <sorear> once, m stood for months
19:37:06 <chessguy> ah
19:37:36 <sjanssen> I thought lambdabot stopped using hs-plugins before 6.6
19:37:48 <sorear> sjanssen:
19:37:51 <sorear> @version
19:37:52 <lambdabot> lambdabot 4p494, GHC 6.5 (OpenBSD i386)
19:37:52 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
19:37:53 <sjanssen> 6.6 being the GHC version that broke hs-plugins
19:37:53 <vincenz> @remember Krishnamurthi If you've ever seen a monad, that is to know what true pain and suffering is. If that's the best answer these functional guys can give us about state they deserve what they get and more.
19:37:54 <lambdabot> Done.
19:37:57 <sorear> ^^^ before 6.6!
19:38:46 <sorear> so now lambdabot will be able to upgrade, muahahaha
19:38:47 <sjanssen> so what do the hs-plugins compatibility issues have to do with lambdabot?
19:38:59 <newsham> @reload
19:38:59 <sorear> sjanssen: lambdabot is stuck in the past
19:38:59 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
19:43:39 <bd_> sjanssen: @run is broken on ghc 6.6
19:43:59 <sjanssen> bd_: right, because of hs-plugins
19:44:18 <bd_> that's what they have to do with lambdabot :)
19:44:28 <bd_> also several of lb's deps no longer compile on 6.4, last I checked
19:44:55 <newsham> i have lamdabot built in 6.4
19:45:06 <bd_> hmm
19:45:08 <sjanssen> I was trying to refer to dynamic plugin loading.  I don't think the lack of this feature has anything to do with hs-plugins issues
19:45:11 <newsham> there's a separate cabal file, and i think it needed minor tweaking to run
19:45:38 <bd_> newsham: yeah, I mean one of the external packages it needed required a package only in 6.6. It was a while ago though, so I don't remember exactly which it was...
19:46:23 <newsham> i had some minor headaches with zlib, but i don tthink thts the one you're talking about
19:54:04 <newsham> sent patch to Quote module to dons.
19:54:08 <newsham> he maintains right?
19:54:15 <sorear> right
19:54:37 <sorear> newsham: you can always find the current maintainer in a file named _darcs/prefs/email
19:54:53 <sorear> in any darcs project
19:55:16 <sorear> just use darcs send, it's all wonderfully automatic :)
19:55:29 <newsham> $ ls _darcs/prefs
19:55:29 <newsham> ./  ../  binaries  boring  defaultrepo  motd  repos
19:55:46 <sorear> oh right...
19:55:53 <newsham> except 1) it isnt recorded, and 2) i have a ton of hacks in my tree
19:56:09 <sorear> http://www.cse.unsw.edu.au/~dons/lambdabot/_darcs/prefs/email
19:56:21 <sorear> it's only on the server
19:56:40 <sorear> newsham: darcs send lets you pick and choose. very nice.
19:56:49 <sorear> also, record whenever possible.
19:57:31 <newsham> no thanks, my tree is a hack port.  i plan to start fresh and throw away the first try
19:57:36 <newsham> no recording here.
19:58:16 <sorear> record is like maintaining a CHANGES_MADE_HERE, only 10x easier
19:58:42 <newsham> yah, i started goofing with darcs yesterday.
19:58:57 <newsham> seems nice
20:03:20 <heel3k> can i define functions in the interactive interpreter of hugs?
20:03:32 <sorear> ?
20:03:38 <sorear> you can in ghci ...
20:03:43 <glguy> not hugs
20:04:05 <heel3k> all defs need to be in a file in hugs?
20:04:09 <dons> yeah
20:04:10 <heel3k> and loaded?
20:04:11 <sorear> you can make local funs, but those are only good for one expr
20:04:11 <heel3k> thanks
20:04:13 <dons> or else be local
20:04:17 <dons> > let f x = x + 2 in f 7
20:04:19 <lambdabot>  9
20:04:20 <sorear> let f x = x + x in f 4
20:04:27 <sorear> hehe.
20:04:56 <heel3k> or lambdas right? (\x -> x + 2) 7
20:05:04 <sorear> yes
20:05:22 <heel3k> let is just like lisp's let?
20:05:26 <heel3k> in this example?
20:08:23 <dons> yeah
20:08:24 <sorear> dons: ping wrt mail
20:08:33 <dons> hmm?
20:08:34 <sorear> "something that would give me better performance but still allow some nice"
20:08:36 <chessguy> ok, i've got the first part of this monte carlo simulator working. now i can simulate people arriving at a store randomly, but according to a particular distribution
20:08:49 <dons> sorear: subject?
20:09:03 <sorear> Stumble on haskell
20:09:13 <sorear> this guy chose haskell for its high performance
20:09:22 <sorear> (in the declarative category)
20:09:42 <dons> Chad?
20:09:43 <sorear> erhm, misread...
20:09:46 <sorear> yea
20:10:09 <dons> there's so much traffic on -cafe now I can hardly keep up
20:10:53 <Thomas2> man, there's so much traffic here I can hardly keep up
20:11:05 <allbery_b> "Oh no, we've become Popular!"
20:11:08 <chessguy> i was thinking of getting off the mailing list and just checking the archives frequently, but the mailing list is the only way you can really take part
20:11:09 <Thomas2> does haskell really have high performance compared to lisps & MLs?
20:11:23 <sorear> dons: heh.  I get 10x more list crud than spam crud.
20:11:31 <sorear> maybe more like 5x but still
20:11:49 <dons> Thomas2: certainly
20:11:55 <sorear> Thomas2: haskell has VERY high performance compared to perl and python, a common source
20:12:00 <dons> its native compiled, has a huge range of optimisations
20:12:09 <dons> you can typically get to 1.5x C
20:12:13 * allbery_b gets more mail from the freebsd lists than -cafe.  neither compares the torrent of spam he gets
20:12:15 <dons> at least if you use the right libs
20:12:31 <dons> if you use threads, you can leave most languages in your wake
20:12:31 <sorear> comparable to ML, vastly superior to lisp
20:12:35 <chessguy> *cough, cough* fps *cough*
20:13:00 <dons> yeah, lisp is a very different story
20:13:34 <dons> there's some fun optimisations in ghc that just can't be done in an impure language
20:13:40 <dons> like general array fusion
20:13:46 <Thomas2> ah, didn't think too much about that
20:14:14 <dons> Thomas2: haven't you noticed the performance in the Haskell you've written?
20:14:16 <chessguy> hmm, is it because of its purity or its strictness?
20:14:22 <dons> chessguy: purity
20:14:31 <SamB> hmm, supposedly someone has developed nanochips, which will supposedly allow moore's law to continue?
20:14:34 <dons> the transformations are invalid in the presence of side effects
20:14:40 <chessguy> err, i didn't mean strictness, i meant laziness of course
20:14:48 <jcreigh> if you want to know if GHC is doing a certain optimization, how would you find out? In C, I would look at the generated assembly and figure it out. I don't have anything specific in mind, I'm just wondering about the general case.
20:14:57 <dons> jcreigh: you -ddump-simpl-stats
20:15:06 <dons> or -ddump-simpl-iterations
20:15:17 <sorear> -ddump-simpl --- high level
20:15:21 <dons> (there's other -ddump-* flags to turn on and off specific things, and to note what optimisations are happening)
20:15:24 <sorear> -ddump-stg --- log level
20:15:34 <sorear> -ddump-asm --- uber low level
20:15:37 <Thomas2> dons: nope, the haskell we've written is godawful slow
20:15:45 <dons> Thomas2: you use -O
20:15:50 <dons> and ByteStrings instead of lists?
20:16:01 <Thomas2> I only really play with a couple of examples.
20:16:02 <dons> Thomas2: be sure to pop up for a perf. consultancy if you need it :)
20:16:04 <allbery_b> yay, ghc HEAD building libraries.
20:16:13 <sorear> Thomas2: the haskell I write is very very very fast.  even still, the brain is the bottleneck.
20:16:16 * allbery_b wonders if it'll throw a pointer error when he runs it again
20:16:41 <Thomas2> and there's no way any functional language is going to run fast when you keep a massive table and update it all the time
20:16:45 <dons> Thomas2: here's a fun little example I wrote earlier today,
20:16:46 <dons> main = B.putStr . B.unlines . map (B.pack . show) . sort . unfoldr parse =<< B.getContents
20:16:49 <dons> parse !x | Just (n,y) <- B.readInt x = Just (n,B.tail y)
20:16:52 <dons>          | otherwise                 = Nothing
20:16:52 <dons> i'd be interested to see that in OCaml
20:17:02 <dons> Thomas2: ah yes
20:17:05 <dons> it depends on the app
20:17:15 <dons> (though you could always wrap a mutable table if you need to...)
20:17:27 <Thomas2> yeah, that might be a good idea, but a lot more work
20:17:34 <Thomas2> we don't really care about the performance much :-)
20:17:39 <dons> yeah :)
20:17:45 <sorear> Thomas2: remember list update is O(n), each
20:17:58 <dons> but as a rule, if you're not say, 2-4x faster than python, you're doing something wrong
20:17:59 <sorear> tries (Data.IntMap) are O(log n) update
20:18:13 <xpika_> is let j = 3  equivalent to j <- return 3 ?
20:18:25 <xpika_> in a monad
20:18:27 <sorear> xpika_: yes, if you follow the monad laws
20:18:33 <sorear> xpika_: also that's do sugar
20:19:07 <sorear> xpika_: also, let j = 3 can have more polymorphism than j <- return 3
20:20:04 <sorear> > do { let { p = (+) } ; return ((3 `p` 4 :: Int) `seq` (3.0 `p` 4.0)) } :: [Double]
20:20:05 <lambdabot>  Couldn't match `Double' against `Int'
20:20:15 <sorear> > do { let { p x y = (+) x y } ; return ((3 `p` 4 :: Int) `seq` (3.0 `p` 4.0)) } :: [Double]
20:20:16 <lambdabot>  [7.0]
20:20:18 <sorear> damn MR
20:20:27 <dgriffi3> sorear: is there a reason IntMap uses tries?
20:20:34 <sorear> > do { p <- \x y -> (+) x y ; return ((3 `p` 4 :: Int) `seq` (3.0 `p` 4.0)) } :: [Double]
20:20:35 <lambdabot>  Couldn't match `[]' against `(->) a'
20:20:45 <sorear> > do { p <- return (\x y -> (+) x y) ; return ((3 `p` 4 :: Int) `seq` (3.0 `p` 4.0)) } :: [Double]
20:20:47 <lambdabot>  Couldn't match `Double' against `Int'
20:20:49 <hpaste>  chessguy pasted "Is there a more...haskell-ish way to do this?" at http://hpaste.org/210
20:20:49 <sorear> see, less poly
20:21:01 <sorear> dgriffi3: yes. they are fast.
20:21:50 <sjanssen> sorear: technically Data.IntMap's lookup/insertion operations are O(1_
20:21:50 <chessguy> so the final result is a [[Int]], where each list is a group of people that arrive in the same minute. each person is represented by a random number which gives how long it's going to take them to check out
20:22:41 <chessguy> the number of people arriving per minute, and the amout of time it takes a given person to check out follow the same distribution
20:24:00 <xpika_> sorear: i see, the let allows to define functions aswell as retrun data
20:28:27 <Thomas2> chessguy: you could assign something to \n -> liftM (map distribution . take n . randomRs (0, 9)) newStdGen
20:28:57 <Thomas2> then you'd be able to get lists of numbers with your distribution by L <- (function above) n
20:29:00 <glguy> chessguy: your combine looks like a mapAccumL
20:29:07 <Thomas2> rather than having to tail it to drop the one's you've used
20:29:44 <chessguy> hmmm. why is the liftM needed there?
20:29:57 <Thomas2> erm, because newStdGen is monadic
20:30:00 <chessguy> glguy, someone successfully wrote it in terms of mapAccumL, but it looked really messy
20:30:10 <Thomas2> the others operate on its return value
20:30:21 <chessguy> oh, right
20:30:54 <chessguy> at least, i thought it looked messy
20:31:04 <glguy> :t mapAccumL (\ys n -> (drop n ys, take n ys))
20:31:05 <lambdabot> forall a. [a] -> [Int] -> ([a], [[a]])
20:31:30 <glguy> :t \xs ys -> snd $ mapAccumL (\ys n -> (drop n ys, take n ys)) ys xs
20:31:32 <lambdabot> forall a. [Int] -> [a] -> [[a]]
20:31:48 <Thomas2> you have to admit that's not so clear
20:31:58 <glguy> chessguy: I'd argue that what I wrote is a lot clearer than yours
20:32:04 <chessguy> really?
20:32:16 <chessguy> i thought what i wrote was really clear
20:32:26 <glguy> it focuses on the intent instead of muddying that up with the traversal
20:32:31 <dons> > unfoldr (Just . random) (mkStdGen 42) :: [Int]
20:32:32 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
20:32:37 <dons> i just love that code :)
20:32:46 <Thomas2> hmm, why not waitingTimes = mapM (function above) arrivals
20:32:51 <Thomas2> that would clean it up a lot methinks
20:33:21 <glguy> chessguy: you should definitely generate the two lists separately
20:33:39 <Thomas2> if you generate all the other lists seperately you don't need combine
20:33:43 <glguy> replicateM numIntervals (randomRIO (0,9))
20:33:58 <Thomas2> :t replicateM
20:33:59 <bos31337> @hoogle buffer
20:34:00 <lambdabot> System.IO.BufferMode :: data BufferMode
20:34:00 <lambdabot> Network.Socket.RecvBuffer :: SocketOption
20:34:00 <lambdabot> Network.Socket.SendBuffer :: SocketOption
20:34:00 <lambdabot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
20:34:15 <glguy> :t replicateM 10 (randomRIO (0,9))
20:34:17 <lambdabot> forall a. (Random a, Num a) => IO [a]
20:34:18 <bos> @hoogle BufferMode
20:34:19 <lambdabot> System.IO.BufferMode :: data BufferMode
20:34:32 <Thomas2> don't think replicate does it
20:34:42 <chessguy> i still don't see why glguy's implementation is clearer
20:34:53 <Thomas2> for each element of the list he wants to generate a new list of that length
20:35:05 <bos> does anyone run ghci under emacs?
20:35:14 <glguy> chessguy: of combine?
20:35:38 <sorear> box: yes
20:35:45 <chessguy> Thomas2, well, i could probably map yourFunction list
20:35:50 <chessguy> glguy, yes
20:35:56 <bos> sorear: i find that stdout has no buffering set, so performance sucks
20:36:05 <bos> sorear: do you see this?
20:36:05 <sorear> oh
20:36:07 <sorear> no
20:36:15 <chessguy> Thomas2, or something like it
20:36:15 <sorear> nor have I looked :(
20:36:26 <glguy> chessguy: how about this:
20:36:43 <glguy> :t mapAccumL (\ ys n -> splitAt n ys)
20:36:45 <lambdabot> forall a. [a] -> [Int] -> ([a], [[a]])
20:37:01 <glguy> :t mapAccumL (flip splitAt)
20:37:02 <lambdabot> forall a. [a] -> [Int] -> ([a], [[a]])
20:37:25 <Thomas2> chessguy: mapM methinks
20:37:31 <Thomas2> and I think that's the nicest solution so far
20:37:36 <glguy> combine xs ys = snd $ mapAccumL (flip splitAt) ys xs
20:37:38 <chessguy> Thomas2, yes
20:38:18 <chessguy> @pl combine xs ys = snd $ mapAccumL (flip splitAt) ys xs
20:38:18 <lambdabot> combine = (snd .) . flip (mapAccumL (flip splitAt))
20:38:46 <glguy> >  ((snd .) . flip (mapAccumL (flip splitAt))) [1,3,6] [1..]
20:38:48 <lambdabot>  [[2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,2...
20:39:16 <chessguy> ?hoogle mapAccumL
20:39:17 <lambdabot> List.mapAccumL :: (a -> b -> (a, c)) -> a -> [b] -> (a, [c])
20:39:18 <lambdabot> Data.List.mapAccumL :: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
20:39:20 <glguy> > splitAt 3 [1..10]
20:39:22 <lambdabot>  ([1,2,3],[4,5,6,7,8,9,10])
20:39:36 <chessguy> you're using Data.List.mapAccumL right?
20:39:40 <glguy> yeah
20:40:39 <chessguy> hmm, something's wrong
20:40:42 <glguy> chessguy: splitAt is returning the arguments backwards
20:40:50 <glguy> from how I wrote that
20:40:59 <glguy> :(
20:41:09 <chessguy> so your implementation is wrong?
20:41:12 <glguy> right
20:41:28 <glguy> i just need to flip it around
20:41:49 <chessguy> i think i'll stick with my implementation
20:42:43 <glguy> combine xs ys = mapAccumL aux ys xs
20:42:43 <glguy>   where aux ys n = let (a,b) = splitAt n ys in (b,a)
20:42:55 <glguy> that's still clearer than explicit recursion :-p
20:43:32 <chessguy> and i still don't like it
20:43:46 <chessguy> i guess i just like explicit recursion
20:43:49 <chessguy> that's how i think
20:43:51 <glguy> that's fine, some of the standard functions take some getting used to
20:45:04 <glguy> > snd $ mapAccumL (\ys n -> let (a,b) = splitAt n ys in (b,a)) [1..] [1,3,5]
20:45:06 <lambdabot>  [[1],[2,3,4],[5,6,7,8,9]]
20:45:31 <glguy> ?hoogle (a,b) -> (b,a)
20:45:32 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
20:46:04 <allbery_b> @pl \(a,b) -> (b,a)
20:46:05 <lambdabot> uncurry (flip (,))
20:47:13 <chessguy> @hoogle mapM
20:47:14 <lambdabot> Prelude.mapM :: Monad m => (a -> m b) -> [a] -> m [b]
20:47:14 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:47:14 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
20:47:45 <chessguy> @hoogle liftM
20:47:46 <lambdabot> Monad.liftM :: Monad a => (b -> c) -> a b -> a c
20:47:46 <lambdabot> Control.Monad.liftM :: Monad m => (a1 -> r) -> m a1 -> m r
20:47:46 <lambdabot> Monad.liftM2 :: Monad a => (b -> c -> d) -> a b -> a c -> a d
20:48:13 <chessguy> hmm, are Monad.liftM and Control.Monad.liftM the same?
20:48:38 <allbery_b> Monad is just the Haskell98 name for Control.Monad, I think
20:49:02 <chessguy> so Control.Monad is better
20:50:18 <jcreigh> hmm, it looks like "product . filter (\a -> (a `mod` 2) == 1)" is not that same as "foldr (*) 1 . filter (\a -> (a `mod` 2) == 1)" as far as optimization is concerned.
20:51:49 <chessguy> @type  liftM (map distribution . take n . randomRs (0, 9)) newStdGen
20:51:51 <lambdabot> Not in scope: `distribution'
20:51:51 <lambdabot>  
20:51:51 <lambdabot> <interactive>:1:31: Not in scope: `n'
20:52:10 <chessguy> @type  \n -> liftM (map distribution . take n . randomRs (0, 9)) newStdGen
20:52:11 <lambdabot> Not in scope: `distribution'
20:52:46 <sorear> minimal synhl for yi is type correct
20:53:01 <chessguy> @type  \n -> liftM (map (*2) . take n . randomRs (0, 9)) newStdGen
20:53:03 <lambdabot> forall a. (Random a, Num a) => Int -> IO [a]
20:55:10 <hpaste>  glguy annotated "Is there a more...haskell-ish way to do this?" with "like any of this?" at http://hpaste.org/210#a1
20:55:49 <hpaste>  chessguy annotated "Is there a more...haskell-ish way to do this?" with "Much improved but not quite working" at http://hpaste.org/210#a2
20:55:54 <glguy> chessguy: you Main becomes: print =<< mapM nums =<< nums numIntervals
20:56:21 <sorear> ultraminimal synhl *works* in yi
20:57:00 <chessguy> heh
20:57:03 <chessguy> that's insane :)
20:57:24 <glguy> nums n = replicateM n (distribution `liftM` randomRIO (0,9))
20:58:38 <chessguy> well, i don't even need combine, then
20:58:49 <glguy> nope
20:59:00 <glguy> I just didn't finish deleting everything
20:59:10 <glguy> ^A ^C ^ V :)
20:59:30 <allbery_b> he's doing it again...
20:59:36 <allbery_b> @quote true.haskell
20:59:36 <lambdabot> No quotes match. Do you think like you type?
20:59:39 <allbery_b> hm
20:59:49 <allbery_b> @quote collapsed
20:59:50 <lambdabot> No quotes match. I've seen penguins that can type better than that.
21:00:06 <glguy> @quote 2
21:00:07 <lambdabot> dons says: home pcs will never need more than 1024 cpus
21:00:11 <glguy> @quote 2
21:00:12 <lambdabot> kyevan says: my skull is already mostly duct tape. And I'm only on page 25 of YAHT!
21:00:16 <glguy> @quote two
21:00:17 <lambdabot> shapr says: I have hugged binkley on two different continents, no chat bot there.
21:00:20 <glguy> oh well
21:00:26 <glguy> @quote true haskell
21:00:27 <lambdabot> No quotes for this person. You type like i drive.
21:00:28 <allbery_b> @quote melted
21:00:29 <lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
21:00:32 <glguy> there it is!
21:00:36 <chessguy> lol
21:00:45 <glguy> allbery_b: did you know that was my quote when you went looking?
21:00:50 <allbery_b> yes
21:00:52 <glguy> :-p
21:00:54 <allbery_b> hence the "doing it again"
21:01:04 <glguy> ahhh
21:01:17 <glguy> I don't read all the lines, just enough to come to the conclusions I want to
21:03:49 <glguy> allbery_b: would you consider that a fault ? :)
21:04:41 <glguy> the melting at least
21:05:00 <chessguy> hmm, this would get a lot messier if the two distributions were different
21:05:28 <glguy> why?
21:05:47 <chessguy> well, i guess i'd just have a second function like nums
21:05:57 <Thomas2> or parametrise it with the distribution
21:06:00 <chessguy> yes
21:06:01 <Thomas2> that's not too bad
21:06:40 <glguy> chessguy: you'd just write a more extensible version of distribution
21:06:49 <glguy> and then parameterize nums like Thomas2 said
21:06:59 <chessguy> what do you mean 'more extensible'?
21:07:24 <glguy> something that took a list like: [(2,0),(3,1),(4,2),(1,3)]
21:07:29 <glguy> describing the distribution
21:07:50 <chessguy> ah
21:08:27 <sorear> dons: my copy of yi can now make every foo in the buffer red!!
21:09:21 <jcreigh> :set hlsearch<cr>/foo
21:09:29 <jcreigh> hey, works for me too! GD&R
21:09:57 <glguy> chessguy: you could start using MonadRandom in that case, fromList is quite useful -- http://haskell.org/haskellwiki/NewMonads/MonadRandom
21:09:59 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
21:10:09 <sorear> @seem dpms
21:10:10 <lambdabot> I haven't seen dpms.
21:10:38 <glguy> chessguy: fromList MonadRandom m => [(element, Rational)] -> m a
21:10:50 <glguy> m element
21:10:51 <glguy> *
21:11:43 <chessguy> ok, well that's good enough progress for me to catch a couple hours' sleep. thanks!
21:20:21 <dons> its a good day for opensource; Lemmih fixes hs-plugins, sorear adds syntax highlighting to yi
21:20:32 <base_16> :)
21:20:33 <glguy> open sores software?
21:21:08 <jcreigh> does anybody seriously use yi? (for example, does anybody hack on yi using yi?)
21:21:25 <dons> no.
21:21:29 <bos> @pl \(a,b)->(a, f b)
21:21:30 <lambdabot> second f
21:21:31 <dons> they could, and have done in the past (I used to)
21:21:45 <dons> yi with syntax highlighting should make a reasonable drop in replacement for vim
21:21:47 <bos> @hoogle second
21:21:48 <lambdabot> Control.Arrow.second :: Arrow a => a b c -> a (d, b) (d, c)
21:21:58 <jcreigh> oh, is yi modeful?
21:22:09 <bos> > second (1+) (1,2)
21:22:11 <lambdabot>  (1,3)
21:22:11 <dons> no. it supports different editors via lexer plugins
21:22:14 <base_16> jcreigh: "A principle of Yi is that any behaviour can be programmed, so there exist vi, vim, emacs, mg, nano, joe and ee frontends to Yi."
21:22:19 <dons> so one that it supports is vim, another is emacs
21:22:28 <dons> modes are just lexers that can throw to each other
21:22:37 <dons> a modeless editor is stateless lexer
21:22:58 <dons> i.e. no overloading ;)
21:23:45 <sorear> unfortunately the combinators aren't coming along as well as the core
21:23:49 <base_16> i still can't get the thing to build, but i'm probably screwing it up
21:24:24 <sorear> you have to write your highlighter as a DFA
21:25:11 <sorear> also, different editors have different display styles
21:25:17 <sorear> (not as well supported)
21:25:17 <dons> sorear: ideally we'd like them to be as simple as the lexer combinators
21:25:25 <dons> it should really be possible to plugin in the haskell.x and use that
21:25:34 <desrt> dons; ctags?
21:26:22 <sorear> dons: the problem is that every combinator system I can think of is unsalvagably higher order
21:26:50 <sorear> i've got nice highlighting compbinators, but since it uses functions in the state, it can't do the equality early exit
21:27:15 <dons> the highlighting scripts should really look like lexers
21:27:27 <sorear> so, not arbitrary contextfree?
21:27:38 <dons> too complex
21:27:47 <dons> token based highlighting is still better than regexes
21:28:01 <dons> since you can just drop in your lexer defns straight from alex
21:28:11 <dons> or from published grammars
21:28:26 <glguy> dons, what was the Cont ex from wiki about?
21:28:35 <glguy> just an exercise?
21:28:37 <sorear> dons: ah great.  will (do homework then) study how to crack open alex and get at the Ints inside.
21:28:45 <dons> glguy: yeah. just cleaning it up a bit
21:29:03 <dons> sorear: the Haskell.x in the tarball I sent you can do this
21:29:21 <dons> you can lex a line , and it records the state its in at the end of each line
21:29:43 <dons> you memorise that , and feed it back to the lexer to re-lex the line
21:29:45 <sorear> dons: my system is line agnostic so it has to worry about intra-token spaces.  if that can't be made to work, then ...
21:30:12 <sorear> ie. "have seen wher" - where, whern, ?
21:30:13 <dons> the visual haskell paper describes how to take apart an alex lexer to support line-at-a-time highlighting
21:30:26 <sorear> ok.
21:31:06 <sorear> currently I'm trying to do character at a time highlighting
21:31:13 <dons> ok
21:31:35 * sorear has had bad experiences with C-u 9999999 <self inserting character>
21:31:46 <sorear> emacs and vi handle 10 mchar lines *poorly*
21:32:18 * jcreigh tries 99999ix<esc> in vim....
21:32:23 <glguy> so do programmers
21:32:25 <sorear> I don't like to effectively crash my editor with a typo...
21:32:31 <jcreigh> hmm, you're right, long lines are slow. :)
21:33:05 <glguy> maybe, don't highlight lines longer than 1 million chars?
21:33:05 <allbery_b> hm.  nvi seems happy with 99999ix^[
21:33:05 <sorear> and yi has no C-g (yet)
21:33:30 <allbery_b> 6 9s and it's a little slow :)
21:33:30 <sorear> glguy: arbitrary cutoff? ick!
21:33:52 <allbery_b> (only a little, interestingly enough)
21:34:22 <jcreigh> allbery_b: vim just doesn't like long lines, I guess.
21:34:39 <glguy> sorear: is that what you say when lambdabot reports "Terminated"? :)
21:35:58 <jcreigh> well, the editor could support some standard interrupt key. Or prompt: "This is taking a really frikkin' long time. Continue? (y/n)"
21:36:04 <dons> Lemmih: so the testsuite runs for you on linux?
21:36:06 <dons> with 6.6?
21:36:44 <dons> Lemmih: its erroring for me, but i'll need to investigate further
21:36:46 <dons> base_GHCziBase_unpackCStringzh_closure
21:36:49 <sorear> how do we plan on supporting HEAD? a branch of our own? conditional compilation?
21:36:58 <hyrax42> glguy: are the pastes in hpaste entirely memory resident?
21:37:00 <sorear> not at all?
21:37:05 <sorear> hyrax42: yes
21:37:16 <glguy> hyrax42: yes, they live gzipped in memory
21:37:17 <dons> hyrax42: yes, but compressed
21:37:19 <sorear> hyrax42: but they are saved to dsik as will
21:37:34 <glguy> and they are written gzipped to disk
21:37:46 <Pseudonym> What you want is for highlighting to gracefulloy degrade as the line gets longer!
21:37:48 <hyrax42> yeah, I saw they are GZByteString... what lib is that from?
21:37:48 <dons> Lemmih: the patches are applied
21:37:57 <dons> hyrax42: it uses zlib
21:37:58 <dons> ?where zlib
21:37:59 <lambdabot> darcs get http://haskell.org/~duncan/zlib
21:38:01 <Pseudonym> Hmm.  Serious network laggage there.
21:38:14 <glguy> hyrax42: "GZByteString" is from hpaste
21:38:21 <hyrax42> oh ok
21:38:29 <dons> its just a newtyped ByteString, to note that it is in  a special format
21:38:34 <hyrax42> just poking around the source, though I know nothing of happs
21:38:36 <glguy> newtype GZBytestring = GZ B.ByteString
21:38:54 <glguy> hyrax42: the magic happens in PasteState.hs
21:39:07 <glguy> hyrax42: and that file doesn't require you to know HAppS
21:39:13 <glguy> (though it might help)
21:40:05 * allbery_b darcs records and darcs sends his little bugfix, hoping he's doing it right...
21:41:12 <hyrax42> ?index Serialize
21:41:12 <lambdabot> bzzt
21:41:55 <glguy> defined in HAppS.MACID.Serialize
21:42:01 <hyrax42> ah
21:42:04 <dons> Lemmih: same error on OpenBSD, so the testsuite isn't running for me with an out-of-the-box 6.6.
21:42:23 <glguy> Serialize is the typeclass for serializable things in HAppS
21:42:40 <glguy> Binary is the typeclass for binary serializable things in Data.Binary
21:42:59 <sorear> Lemmih, dons: need a Linux 2.6/glibc 2.6/GHC 6.6|HEAD tester?
21:43:11 <sorear> *glibc 2.3.x
21:43:36 <Lemmih> dons: What fails? (I might blame the testsuite, it's horrible)
21:43:52 <sorear> @quote Lemmih
21:43:52 <lambdabot> Lemmih says: inv2004: Haskell isn't like all the other mainstream languages. You really need to read a tutorial.
21:43:57 <sorear> @quote Lemmih test
21:43:57 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
21:44:04 <Lemmih> Btw, my code has some bugs which the testsuite doesn't catch.
21:45:02 <dons> Lemmih: running 'gmake' in the top level fails with missing symbols in base
21:45:12 <dons> does that work for you? i.e. configure ; build ; install ; make
21:45:27 <dons> yeah, the tessuite is kind of brutal
21:46:21 <sorear> dons: pulled 4 patches, testsuite succeeds too instantly for comfort
21:46:27 <sorear> ./Setup.lhs test
21:47:17 <sorear> make check?
21:47:58 <Lemmih> sorear: Yes.
21:48:01 <xpika_> @seen monochrom
21:48:02 <lambdabot> I saw monochrom leaving #haskell 3h 11m 20s ago, and .
21:48:10 <sorear> dons, Lemmih: two find warnings, nothing more serious
21:48:15 <dons> huh
21:48:21 <sorear> on my system
21:48:25 <dons> really, so lots and lots of tests run with OK ?
21:48:37 <dons> can you paste the results please?
21:48:42 <sorear> uh wait I think I forgot to configure or anything like that
21:48:46 <dons> um
21:48:50 <dons> :)
21:48:55 <sorear> what do I need to do before check?
21:49:08 <dons> build and install cabal style
21:49:35 <sorear> Setup.lhs: Warning: The field "hs-source-dir" is deprecated, please use hs-source-dirs.
21:49:36 <Lemmih> dons: Five failures, eight ignored, rest ok.
21:49:53 <Lemmih> (The failures aren't my fault)
21:50:01 <sorear> dons: do I have to install, or is register --inplace enough?
21:50:06 <dons> Lemmih: can you paste that? hpaste.org
21:50:12 <dons> sorear: hmm. i'd install
21:50:16 <sorear> until uninstall exists, I'd rather not
21:50:28 <dons> Lemmih: is it posisble you didn't send me all the patches?
21:50:39 <sorear> it compiles!
21:50:44 <dons> sorear: it just dumps a lib in ~/lib/plugins-1.0
21:50:49 <hpaste>  Lemmih pasted "hs-plugins: make check" at http://hpaste.org/211
21:50:53 <sorear> Lemmih: did you record 4 patches?
21:50:56 <dons> so ghc-pkg unregister ;rm -rf ~/lib/plugins*
21:51:23 <Lemmih> dons: Yeah, that may be.
21:51:25 <dons> Lemmih: could you check that the default repo builds and runs on your box?
21:51:33 <sorear> stefan@stefans:/usr/local/src/hs-plugins$
21:51:36 <dons> www.cse.unsw.edu.au/~dons/code/hs-plugins
21:51:55 <sorear> dons: *** Exception: /usr/local/lib/plugins-1.0: createDirectory: permission denied (Permission denied)
21:52:01 <sorear> that's with --user
21:52:10 <dons> maybe you didn't reconfigure?
21:53:03 <sorear> nm, --help says prefix is a different matter entirely
21:53:18 <jcreigh> what's with all these people pushing Haskell as a good multi-core language? Isn't single-core correctness enough?
21:53:20 <sorear> testsuite is much slower now :)
21:54:38 <hpaste>  sorear pasted "make check results" at http://hpaste.org/212
21:54:58 <dons> jcreigh: hmm? i've got 16 cores, i like using forkIO to use them up :)
21:55:05 <dons> ah ha
21:55:08 <dons> Lemmih++
21:56:00 <jcreigh> dons: I just think that buggy, unmaintainable programs are currently a much bigger problem that ineffcient use of multiple cores.
21:56:04 <sorear> dons: it still passes my make check
21:57:08 <Lemmih> dons: Be aware that the code is still broken.
21:57:14 <dons> Lemmih: right
21:57:26 <dons> jcreigh: sure. doesn't mean i don't want my 16 cores in use
21:57:32 <dons> cores are important
21:57:44 <dons> fewere bugs are also important
21:57:56 <dons> both in the one language, mwhahaha :)
21:58:14 <dons> Lemmih: ok. good. its running
21:59:21 <dons> sorear: can you pull the new patch?
21:59:50 <sorear> dons: I can't pull more
21:59:55 <sorear> dons: is 8 enough?
22:00:41 <Lemmih> 8 ought to be enough for everybody.
22:00:45 <dons> yeah
22:01:20 <sorear> dons: I've a "solution" for the FastBuffer incremental characterwise highlighting ... how do you feel about randomized algorithms?
22:01:58 <dons> um.. hy?
22:02:03 <dons> why. seems a bit unusual?
22:02:21 <dons> i'd really like to just drop in the hscolour or haskell.x lexer :}
22:03:05 <glguy> Remember, there is no 'i' in Team America
22:03:33 * sorear goes to read vhaskell paper
22:03:54 <Lemmih> Anyone got shim working?
22:05:24 <dons> 'ugly fix' , heh, no one said linkers were pretty :)
22:05:57 <sorear> Lemmih: yes
22:06:05 <sorear> @where vshaskell
22:06:05 <lambdabot> I know nothing about vshaskell.
22:06:06 <dons> from vim?
22:06:08 <sorear> @where vhaskell
22:06:09 <lambdabot> I know nothing about vhaskell.
22:06:14 <sorear> @where visualhaskell
22:06:15 <lambdabot> http://www.haskell.org/visualhaskell/
22:06:39 <dons> ok. let's have the appropriate amount of fun!
22:06:49 <dons> hs-plugins is working (just) with ghc 6.6 on linux and opebsd x75
22:06:55 <dons> um, yeah, that thing
22:07:11 <glguy> x75, eh?
22:07:20 <Lemmih> sorear: How do you start the shim server?
22:07:27 <dons> i shouldn't have such a big lunch
22:07:28 <glguy> that's h275 in openbsd terms
22:10:58 <sorear> Lemmih: M-x shim
22:13:03 <sorear> dons: aw. testsuite fails on 6.7
22:13:34 <sorear> dons: typical error: +Main: Ix{Int}.index: Index (124) out of range ((0,6))
22:14:16 <kolmodin> dcoutts: nope, haven't looked into string pools yet
22:20:21 <dons> sorear: yeah, .hi parser changed
22:20:23 <xpika> > do forkIO $ putStrLn "hello world"
22:20:25 <lambdabot>   Not in scope: `forkIO'
22:20:35 <dons> we could provide that I guess, but its in IO
22:22:51 <allbery_b> hm, it occurs to me that maybe ghc-api should be used (and if it doesn't export a useful function to deconstruct .hi files, it should)
22:23:08 <glguy> I hope I live long enough to enjoy this :-) http://scienceblogs.com/thescian/2007/01/more_user_interface_eye_candy.php
22:23:10 <lambdabot> Title: The Scientific Indian : More User Interface Eye Candy, http://tinyurl.com/2vfe2g
22:23:50 <allbery_b> seems better than chasing .hi file formats from outside
22:24:29 <dons> yeah
22:26:21 <sorear> night
22:26:49 <xpika> g'night
22:27:04 <sorear> I just read the vhaskell paper ... it seems even vs does line based highlighting!
22:41:30 <dons> yep, line based
22:47:59 <dons> $ darcs get /home/dons/code/yi
22:47:59 <dons> Copying patch 666 of 666... done!
22:48:25 <ulfdoz> evil! ;)
22:49:59 <sieni> \,,/
22:50:39 <dons> heh
22:50:49 <allbery_b> bah :)
22:52:07 <ulfdoz> Was someone bored enough to write an LP-Solver in a weak moment?
22:58:11 <newsham> ?hoogle insertLookupWithKey
22:58:12 <lambdabot> Data.IntMap.insertLookupWithKey :: (Key -> a -> a -> a) -> Key -> a -> IntMap a -> (Maybe a, IntMap a)
22:58:12 <lambdabot> Data.Map.insertLookupWithKey :: Ord k => (k -> a -> a -> a) -> k -> a -> Map k a -> (Maybe a, Map k a)
22:58:54 <xpika> @where yi
22:58:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
23:01:09 <dons> xpika: note that yi is very unstable at the moment
23:01:13 <dons> i'm not even sure it builds :)
23:01:28 <dons> but at least it does colours and line wrapping now, and supports gtk
23:01:32 <xpika> :(
23:01:43 <dons> hey. its good! 30 patches a day can't be bad
23:01:49 <xpika> maybe i should darcs an older verion?
23:02:11 <dons> yeah, or take one of the tarballs
23:02:12 <xpika> im up to patch 100
23:02:20 <dons> who knows, maybe the darcs version builds
23:02:53 <dons> the codes really getting polish a lot, so i'm hopeful we can get a new release out soon, with 95% of basic vim
23:02:59 <dons> and enough emacs to be usable
23:03:16 <xpika> woot
23:03:18 <ulfdoz> chrchr
23:03:46 <narain> :t (>>=)
23:03:48 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
23:04:08 <xpika> quote Yi should include GHCi
23:04:10 <xpika> like emacs includes a elisp interpreter.
23:04:16 <dons> yeah
23:04:21 <dons> bigger project though
23:04:23 <xpika> why not embed ghc?
23:04:28 <dons> it does already
23:04:31 <dons> see the paper
23:04:42 <dons> but ghci would be nicer, since its a bit lighter
23:04:42 <xpika> it should use ghc as the interpreting language
23:04:50 <dons> it does
23:04:56 <dons> to some extend..
23:05:05 <xpika> ok
23:05:17 <xpika> do you know how can i run frag in fullscreen mode?
23:05:46 <dons> nope, seems a reasonable thing to be able to do though
23:05:50 <dons> have a peek around the code
23:06:00 <dons> if you work anything out, add some comments :)
23:06:06 <xpika> i should add it as a patch
23:07:37 <xpika> the monad is simply fullscreen
23:10:18 <newsham> ok, if I just did a "darcs pull" and it applied two patches and I want to undo those do patches, how do I do that?
23:10:29 <newsham> I tried "darcs rollback" and that didnt seem to do the trick
23:12:54 <allbery_b> unpull?
23:13:09 <newsham> yah, i think thats what i want, except now its tryin gto ask me 400 quesitons :)
23:13:19 <newsham> win darcs doesnt work that well :\
23:17:21 <newsham> cool, now it goes out to lunch anytime i do something on this repository
23:18:02 <xpika> newsham: I believe the command is revert
23:18:36 <allbery_b> revert undoes local changes, not pulled patches
23:18:44 <xpika> oh ok.
23:21:43 <newsham> i dont see how i can do this without it asking me for all 400 patches
23:22:02 <newsham> when i try '-t something' or '-p something' it seems to go out to lunch until i kill it and remove the lock file
23:23:20 <newsham> at this point its easier to start again
23:30:53 <abz> does anyone know if a nice way to do a map of a map?
23:32:10 <abz> other than map (\(SomeConstruction a) -> map (\SomeOtherOtherThing a b -> ....) a) xs
23:33:46 <newsham> abz: what are you trying to do and why?
23:34:16 <abz> I'm trying to make this map (\(FL sCQ) -> map (deFA (\originalSCQ newQuantity -> (originalSCQ,value newQuantity))) sCQ) scq look nicher
23:36:25 <newsham> dons: jeanphilippe's patches removed the Vty dependency (when not being used), but i think your latest merge put them back?
23:37:59 <Donner> abz: map (map  (deFA (\x y -> (x, value y))) . unFL) sCQ
23:38:39 <Donner> abz: What does "deFA" do? It seems strange.
23:43:33 <dons> newsham: maybe, it was probably wrong.
23:43:38 <dons> sorear needs to sort that out
23:44:27 <newsham> I think its Buffer.hs relying on Yi.Vty (Attr)
23:45:01 <newsham> sorear awake?
23:46:46 <abz> Donner: thanks, deFA :: (a -> b x -> r) -> (FA a b x -> r) is a WASH thing
23:47:06 <abz> deFA g (FA a bx) = g a bx
23:49:51 <dons> newsham: send a patch!
23:50:20 <newsham> I did send a patch.
23:50:36 <xpika> do i specifically need hsplugins to install Yi ?
23:51:42 <dons> I don't think so
23:51:45 <dons> check the .cabal file
23:51:54 <dons> note that hs-plugins works now on 6.6! :)
23:51:56 <newsham> i dont see it listed i nthe cabal
23:51:58 <dons> robreim: ^^
23:52:15 <dons> i'll need to sort out the last issues, generate some haddocks, and get it into hackage soon
23:54:20 <robreim> eh what what?
23:55:43 <dons> you can check Lemmih's patches out of the repo now
23:55:52 <dons> 90% or so of the testsuite seems to run
23:56:00 <dons> :D
23:58:46 <Donner> abz: map (map doinside . unFN) dSC where doinside = deFA (\x y -> (x, value y))
