00:15:53 <beschmi> any emacs+haskell users here? i'm planning to release a haskell emacs mode soon and i need some testers
00:16:07 <beschmi> there is a howto at http://shim.beschmi.de/trac/shim/wiki/ShimHowto now
00:16:09 <lambdabot> Title: ShimHowto - shim - Trac
00:16:10 * sorear raises hand
00:16:34 <nornagon> boo, hiss, etc.
00:17:24 <sorear> how much does it require X? ...
00:17:53 <sorear> in this context I think X == super fancy faces
00:18:18 <kolmodin> morning!
00:18:21 <kolmodin> hi beschmi
00:18:27 <sorear> morning.
00:18:36 <beschmi> sorear: should work fine without X if you don't miss the overlays
00:18:41 <beschmi> hi kolmodin
00:19:01 <sorear> what are overlays?
00:19:12 * sorear is not an emacs archhacker
00:19:31 * sorear is not an emacs programmer even
00:19:39 * beschmi isn't either ;)
00:20:22 <beschmi> i think it's showing quicktips if you place the mouse over some text
00:20:23 <sorear> oh, so I'm expected to know as a mere user what overlays are... /me feels dumber
00:20:32 <beschmi> (error locations here)
00:20:48 <merus> That Steve Yegge knows where his towel is.
00:20:58 <merus> He put Haibane Renmei on the top of his top 10 anime list.
00:22:03 <beschmi> sorear: no i meant that i don't know what overlay means (exactly) too ;)
00:22:27 <sorear> ok :)
00:22:54 <beschmi> just tested, underlining errors works without X
00:23:30 <sorear> beschmi: you have a terminal that supports underlining !?
00:23:36 <sorear> mine only does color
00:24:28 * sorear uses the linux-console and does not like being ignored
00:25:02 <sorear> Shim/ExprSearch.hs:211:21: Not in scope: data constructor `TyApp'
00:25:11 <sorear> and a bunch of similar errors
00:25:26 <sorear> all things that sound like they belong in a haskell ast
00:25:28 <beschmi> you're using ghc HEAD?
00:25:43 <sorear> beschmi: yes
00:25:55 <sorear> it's my default compiler
00:26:02 <sorear> I have 6.6 and 6.4.2 available
00:26:03 <beschmi> i got another branch that works with head, just have to bring it up to date
00:26:29 <sorear> how badly did they break compatibility :(
00:27:10 <sorear> btw, the ghc version dep is not mentioned in either the builddepends or the wikipage
00:27:29 <sorear> or, rather, it's not specific enough about ==6.6
00:27:48 <beschmi> they added haddock comments to the ast and did some other changes, so the ast changed a lot
00:28:23 <sorear> and you are a mere ghcapi client?
00:28:55 <sorear> will shim-6.6 explode if I have HEAD .hi's lying around in my project dir?
00:28:58 <beschmi> i only use what's exported, but nearly everything is exported
00:29:25 <blackdog> beschmi: it looks pretty interesting and almost exactly what i was looking for. if ghc extras ever finish building on my machine, i'll have a bit of a play.
00:29:42 <beschmi> i'm not sure, but it's better if you use the same compiler you use for compiling your projects
00:31:01 <beschmi> sorear: http://shim.beschmi.de/shim-debugger
00:32:45 <sorear> I just put in the clarification, hope you don't mind ppl taking advantage of [ Edit this page ] :)
00:33:03 <sorear> beschmi: 405
00:33:05 <sorear> beschmi: 404
00:36:06 <sorear> File mode specification error: (file-error "Cannot open load file" "shim")
00:36:25 <sorear> that appeared in my echo area when I visited Foo.Bar
00:37:26 <beschmi> have you changed the path in (add-to-list 'load-path "~/emacs/shim/")
00:37:26 <sorear> I've lost types-on-hover!
00:37:32 <newsham> > let f = (scanl (*) 1 [1..] !!) in f 5
00:37:34 <lambdabot>  120
00:37:45 <sorear> beschmi: I copied the whole block into the end of .emacs
00:38:17 <sorear> oh wait I didn't install.
00:38:26 <sorear> does that explain the error?
00:38:38 <beschmi> you have to replace  "~/emacs/shim/" with the toplevel dir of the repo (or just symlink to ~/emacs/shim)
00:38:55 <sorear> I'd still like to know where my echo area "return :: Monad m => a -> m a" went
00:39:01 <sorear> beschmi: /doh
00:39:47 <sorear> and my types are back too
00:39:56 <sorear> guess the error-in-hooks tripped something
00:40:16 <newsham> has anyone ported ghc to emacs yet?
00:40:42 <sorear> ported?
00:40:50 <sorear> we have inf-haskell
00:41:05 <newsham> ghc runs under win32, linux, *bsd, osx, etc..
00:41:10 <sorear> but somehow I think ghc will be machine code for the forseeable future :)
00:41:10 <newsham> why not the emacs operating system?
00:41:32 <beschmi> sorear: seems like you don't see the notes at all in the linux console
00:41:34 <sorear> newsham: I think yhc would be a better bet.
00:41:46 <sorear> beschmi: notes == everything ?
00:42:05 <newsham> super-meta-hyper-h for haskell
00:42:06 <beschmi> sorear: notes = GHC error messages
00:45:13 <newsham> has anyone write bitblit / bitmap layer primitives in haskell?
00:45:37 <sorear> newsham: yes
00:45:41 <sorear> newsham: see house
00:45:54 <sorear> newsham: they "wrote graphics primitives in haskell"
00:45:59 <newsham> i thought house uses gtk or tkined
00:46:05 <newsham> err.. tk.
00:46:19 <beschmi> sorear: darcs get http://shim.beschmi.de/shim-debugger should work now
00:46:21 <sorear> house is an operating system, tk doesn't run under it
00:46:21 <lambdabot> Title: Index of /shim-debugger
00:46:38 <sorear> Compilation failed:  1 error  0 warnings  1 info
00:46:49 <sorear> how do I find the error? M-[np] does nil.
00:47:07 <sorear> nm
00:47:16 <sorear> -+  Errors (1)
00:47:16 <sorear>  `-- Bad interface file: /usr/local/lib/ghc-6.7/imports/Test/QuickCheck.hi
00:47:16 <sorear>          mismatched interface file versions: expected 6060, found 6070
00:47:36 <sorear> I configured shim with -w /usr/bin/ghc-6.6; what gives?
00:47:46 <sorear> which ghc is a 6.7 btw
00:48:00 <beschmi> M-p/n only works with errors that have a location in the file
00:48:14 <sorear> makes sense
00:48:26 <sorear> do I need to tell shim what ghc to use at runtime?
00:48:59 <beschmi> yeah, it calls ghc to find out the libdir
00:49:17 <sorear> how do I tell it to use /usr/bin/ghc-6.6?
00:49:36 <beschmi> i have to make it configurable (i just set PATH when i use different GHC version)
00:52:19 <sorear> I made the obvious change on Shim/Hsinfo.hs:143 - will that work?
00:52:49 <newsham> hmm.. the house paper gives a whole sentance to the subject
00:52:49 <beschmi> it should
00:53:14 <newsham> "The Gadgets implementation relies on a few simple graphics primitives that we have implemented in Haskell by writing to the linear frame buffer interface through the VBE interface."
00:53:39 <sorear> newsham: there was also something about haskell being fast enough to XYZ
00:53:57 <sorear> yippie!!! Compilation successful:  0 errors  0 warnings  1 info
00:54:08 <beschmi> cool
00:54:18 <sorear> C-c C-h
00:54:40 <newsham> "enough, we were able to implement the graphics primitives in Haskell, with decent performance, and our Haskell implementation for parsing, decompressing and rending GIF images was fast enough to let us use House to present our slides at ICFP 2005" on web page?
00:54:49 <sorear> ooh C-c C-d looks uber-cool
00:55:54 <sorear> beschmi: unless it does something *really* stupid like unlink(2) my source code, you can expect a lot of karma points when I get back to lambdabot hacking.
00:56:25 <sorear> (right now it's just "cute trick" because I haven't used it)
00:56:33 <newsham> you backed up your code in some source code management util right?
00:56:40 <sorear> yes
00:56:54 <newsham> so unlink not such a threat :)
00:57:22 <blackdog> still doesn't buy you many wow points :)
00:57:36 <blackdog> there was a dilbert cartoon for a backup program, actually...
00:57:37 <sorear> so, evil grin, what happens if you use C-c C-d on Jim Appel's program with unprintable types?
00:57:51 <newsham> not as bad as enumerating all your files, then renaming them all so that the contents are all still there but with different filenames
00:58:06 <blackdog> i think they'd only got as far as deletion... :)
00:58:49 <newsham> (recursively, depth first, of course)
00:59:06 <beschmi> sorear: i hope it doesn't. i'm not sure if all the features make sense, it only became stable enough for me to use about a week ago.
00:59:31 <sorear> beschmi: what does shim-debugger do?  the footer is ... not helpful.
01:00:42 <beschmi> sorear: shim-debugger is just a branch we (me and mnislaih) are working on to add support for the ghci debugger
01:00:58 <sorear> *neato*
01:00:59 <beschmi> sorear: what do you mean with the footer "..."
01:01:18 <sorear> the part below the directory listing
01:01:30 <sorear> it's the same description as regular shim
01:01:36 <sorear> hence assumed content-free
01:01:55 <beschmi> ok, i should change that
01:03:13 <sorear> Wow. M-w C-y doesn't work between mg sessions.  Who'd've guessed.
01:04:14 <sorear> Is there any way more convienient than C-x C-c yes C-j C-p C-j to force emacs to reload ~/.emacs ?
01:04:49 <beschmi> M-x eval-buffer ?
01:05:11 <sorear> oh, I forgot to use emacs for editing it :)
01:06:39 <blackdog> am getting assertion failed from shim.el - plusp length
01:06:55 <sorear> dcoutts__: have you seen shim?
01:07:20 <sorear> beschmi: shim doesn't explode on stepcut's haskell-xmpp ... large nasty piece o code
01:08:09 <sorear> for some reason it takes about a second to answer each C-c C-t
01:08:10 <beschmi> blackdog: anything in /tmp/shim-log (i should disable that in the default build)
01:08:33 <blackdog> shim started and accepted connection
01:08:43 <beschmi> sorear: it recompiles the file, there's a lot of room for optimization
01:09:14 <sorear> beschmi: oh. you mean like memoizing the result of C-c C-k? :)
01:09:22 <dcoutts__> sorear: shim? who/what is that?
01:09:44 <sorear> dcoutts__: beschmi's uber-cool ghc-api-emacs uber-cool integration
01:09:59 <dcoutts__> sorear: oh I see. No I've not seen it.
01:10:22 <dcoutts__> though I have heard of it (apart from the name)
01:10:30 <sorear> dcoutts__: like, C-c C-d to auto-insert inferred type signatures.
01:10:36 <dcoutts__> nice
01:10:38 <sorear> C-c C-t to print them
01:10:53 <blackdog> and when i do C-c tab, i get "shim-socket not running"
01:11:45 <beschmi> blackdog: you can start the shim binary with "shim /tmp/shim-io" and then use shim-connect in emacs
01:12:03 <beschmi> then you see at least if it explodes somehow
01:12:07 <sorear> blackdog: does M-x shim work?
01:12:27 <blackdog> no
01:12:30 <sorear> aww
01:13:02 <beschmi> blackdog: i mean M-x shim-connect instead of M-x shim
01:13:03 <blackdog> hm
01:13:09 <blackdog> yeah, that works
01:13:26 <blackdog> although the shim process is bitching about no description file being found
01:14:07 <beschmi> can you paste the error message somewhere?
01:14:39 <blackdog> is a oneliner, so: shim: No description file found, please create a cabal-formatted description file with the name <pkgname>.cabal
01:15:13 <sorear> oh, right, cpp doesn't work :)
01:15:26 * sorear just tried feeding lambdabot through shim
01:16:25 <beschmi> ah, ok. it's a message from cabal when shim searches for the cabal file. it's expected
01:17:04 <sorear> oops
01:17:10 <sorear> I just killed *shim-io*
01:17:11 <beschmi> if you use extensions: CPP in the cabal file most things should work
01:17:19 <sorear> doeuble assertion failure!
01:17:33 <sorear> beschmi: was that for me?
01:17:54 <beschmi> sorear: yeah
01:18:07 <sorear> hehe.  will send to dons
01:18:38 <sorear> but it already says extensions: CPP
01:18:47 <beschmi> oh, it's already there
01:18:54 <sorear> does shim support packages with multiple executables?
01:19:26 <beschmi> it just uses the library options (if there is one) or the options from the first executable
01:19:39 <sorear> lambdabot has a very ... interesting build system, I'm not suprised it broke
01:19:42 <sorear> beschmi: oh.
01:20:05 <sorear> beschmi: lambdabot is the *second* executable - and the first uses no extensions.
01:20:11 <sorear> beschmi: (first is BotPP)
01:20:47 <apfelmus> ski: ping
01:20:53 <beschmi> i see, which file have you opened and is there any way for shim to find out that it belongs to the lambdabot executable?
01:21:11 <sorear> beschmi: Plugins/Xmpp.hs
01:21:38 <sorear> (I'm trying to merge stepcut's jabber interface)
01:22:20 <blackdog> beschmi: any chance of some comments/basic hacking doc for what goes where?
01:23:43 <beschmi> blackdog: i should start a hacking page at the wiki
01:24:18 <blackdog> good idea :)
01:25:10 <beschmi> blackdog: shim listens on a unix domain socket, since emacs doesn't support that, there is a shim-udproxy that proxies stdin/stdout to the socket for emacs
01:25:21 <blackdog> ok.
01:25:44 <blackdog> that's the stuff i'm happy to ignore, although i'm very happy you've written it.
01:26:41 <blackdog> i'm more interested in what the cycle is - shim.el asks questions of some kind, and shim answers them, basically?
01:26:45 <beschmi> haskell and emacs communicate via s-expressions, haskell parses/prettyprints  them and emacs justs reads and prints them
01:26:45 <blackdog> what's sent back and forth?
01:27:45 <beschmi> emacs does (async) requests and shim (the haskell program) answers
01:28:44 <beschmi> the Sexp parser/prettyprinter is an Shim.Sexp and the shim main loop is in Shim.Shim
01:28:54 <beschmi> s/an/in/
01:29:17 <beschmi> the ghc-api stuff is in Shim.Hsinfo
01:29:30 <blackdog> ok. so, currently, what are the limitations?
01:29:43 <blackdog> you can only expand code from other, complete and correct source files, i assume?
01:29:49 <beschmi> the emacs stuff (shim.el) is mostly adapted from slime (the lisp mode)
01:30:10 <beschmi> blackdog: yeah, most things only work with correct source files
01:30:34 <sorear> yow!   |-- Not in scope: type variable `forall'
01:31:04 <tuukkah> dcoutts__, do you know what it would take to get gtk2hs compiled with profiling support?
01:31:12 <blackdog> ok. if i do C-c tab on something like "foo =", it seems to go off into the never-never
01:31:15 <blackdog> any idea why?
01:31:30 <blackdog> is this basically trying to insert every visible identifier?
01:32:03 <sorear> beschmi: why doesn't it like forall?
01:32:13 <sorear> beschmi: do I need to add another extension?
01:33:03 <sorear> beschmi: I just re-ran C-c C-k and:
01:33:04 <sorear> Evaluation aborted: "exception: exit: ExitFailure 1"
01:33:58 <beschmi> sorear: i fear you have to add all the needed extensions
01:34:21 <beschmi> sorear: they are much more fine grained than -fglasgow-exts in ghc-options
01:34:35 <beschmi> blackdog: i'm testing it right now
01:34:42 <sorear> beschmi: the exception came so fast shim couldn't have compiled everything ...
01:35:45 <sorear> Unexpected error while trying the second compile: "buffer needs preprocesing; interactive check disabled":  1 error  0 warnings\ 17 infos
01:36:10 <blackdog> C-c tab works fine on import, but not on foo=List.<C-c tab> either
01:36:12 <sorear> ah, it worked
01:37:09 <sorear> beschmi: does shim handle -pgmF ?
01:37:23 <sorear> it seems to be choking on the botpp directives
01:37:54 <beschmi> sorear: what's does -pgmF do?
01:38:09 <sorear> custom preprocessor
01:38:40 <sorear> lambdabot has a program (BotPP) which generates plugin boilerplate from PLUGIN Xmpp directives
01:38:45 <beschmi> i don't think it does. so lambdabot is a nice testcase
01:39:35 <beschmi> blackdog: if you have import qualified Data.List as List at the top, it should work
01:40:13 <beschmi> blackdog: and does ma C-c Tab work?
01:40:47 <blackdog> ma?
01:41:03 <blackdog> the qualified version doesn't seem to help
01:44:26 <blackdog> but i do get different results when it's qualified
01:44:39 <blackdog> it doesn't give me a list of choices, but it doesn't loop, at least.
01:44:58 <beschmi> blackdog: i just discovered a bug. it goes into an endless loop if the file doesn't exist (not saved yet)
01:46:44 <blackdog> ok. am going offline for a day or so, but i'll darcs update when i get back
01:47:06 <blackdog> i'm interested in adding some other functionality, but it looks like a good base
01:47:37 <beschmi> cool
01:48:30 <sorear> beschmi: is there any way you can make shim not explode if I accidentally try to kill \*shim(-io)?\*
01:49:33 <paolino> @instances MonadState
01:49:34 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
01:51:24 <beschmi> sorear: there should be a way to make the shim-io buffer invisible, i'll try to find a way
01:51:40 <sorear> beschmi: why does every process need a buffer?
01:51:56 <sorear> beschmi: surely whatever implemets comint uses raw processes
01:52:04 * sorear is not an emacs exprt
01:53:21 <beschmi> i use the store everything until i have a complete request/answer, but that should work just as well with strings instead of in a buffer
01:53:29 <beschmi> use the buffer ...
01:56:57 <beschmi> sorear: i have to leave for an hour or so, i have submitted a ticket for the shim-io thing, if you find anything else, please do so too
01:57:41 <sorear> C-c C-t on (all I can say now is type class method) deadlocks at 0% cpu
01:57:52 <sorear> oh sorry
02:03:43 <Svrog> when marshaling values to and from c, is there any reason to for example use CInt or CFloat instead of Int and Float?
02:04:22 <sorear> Int and Float are not required to be the C types
02:04:29 <Svrog> the ffi addendum to the haskell 98 report mentions that Int and Float are both considered basic foreign types
02:04:44 <Svrog> in section 3.2
02:05:09 <sorear> for instance on a 16-bit platform, CInt would be 16 bit but Int is required by H98 to have at least 30 bits
02:05:28 <sorear> (so Int would be software 32bit, effectively CLong)
02:07:13 <Svrog> hmm.. so why does the addendum then mention Int and Float as basic foreign types and why does it require haskell implementations that implement ffi to be able to pass values of types such as Int, Float, Bool, etc between haskell and the "external context" as function arguments and results?
02:07:41 <sorear> I believe Int corresponds to the C type HsInt, etc etc.
02:08:01 <sorear> CInt is a C int, Int is some C type.
02:08:08 <Svrog> ah
02:08:28 <Svrog> i thought HsInt was also a C int?
02:08:38 <sorear> I imagine Int et al are required to facilitate C-side marshalling.
02:08:56 <Svrog> yeah
02:09:01 <sorear> Svrog: if HsInt was a C int, what would its purpose be?
02:09:15 <sorear> Svrog: HsInt is a C-side typedef iirc.
02:09:27 <Svrog> hmm.. good point
02:09:39 <musasabi> sorear: that ghc 7zip available somewhere?
02:09:39 <lambdabot> musasabi: You have 1 new message. '/msg lambdabot @messages' to read it.
02:10:03 <sorear> I'll try and upload it
02:10:20 <sorear> it is 180% bigger than my documented quota, however
02:11:32 <Svrog> so then to marshall c values the best way is to use CInt and similar types and then create haskell wrappers around the imported c functions, rather than just directly exposing imported functions and using standard haskell types?
02:11:52 <sorear> Svrog: the first way is the usual way
02:11:59 <Svrog> cool, just wanted to make sure
02:12:03 <sorear> I don't know about "better"
02:12:04 <Svrog> thanks
02:12:14 <sorear> musasabi: I have a massively asymetric connection
02:12:21 <sorear> `ghcfull.7z' at 3647512 (12%) 67.6K/s eta:6m [Sending data]
02:12:35 <sorear> as compared to 670k/s downlink...
02:13:12 <sorear> darcs took 5 mins of cpu time, 2.5 hrs of wall time.  amazing.
02:13:50 <musasabi> sorear: ok.
02:24:02 <Svrog> does the latest version of ghc in the repository support bytestring literals yet?
02:24:27 <sorear> iirc no
02:24:31 <Svrog> oh
02:24:34 <sorear> packAddress "foo"# works
02:24:50 <sorear> but that's hardly a bytestring literal :)
02:24:57 <Svrog> heh
02:25:35 <Svrog> what happened to that patch that added bytestring literals? hasn't been accepted yet?
02:25:45 * sorear doesn't know
02:26:45 * sorear goes to sleep.  good night!
02:26:57 <Svrog> night sorear
02:33:47 <apfelmus> kowey: ping
02:34:00 <kowey> apfelmus: hi
02:34:38 <apfelmus> hi! what do you you think about the current chapter titles?
02:34:53 <apfelmus> ("Wider theory", "Haskell Performance")
02:35:41 <kowey> Haskell Performance is quite clear
02:35:59 <kowey> Wider Theory... hmm... sure that makes sense
02:36:45 <kowey> do you think these will support new sub-chapters you might have in mind?
02:36:53 <apfelmus> indeed, "Wider Theory" is very wide ...
02:37:31 <kowey> is there a narrower name that would cover these topics?
02:37:37 <kowey> Formal Haskell?
02:37:54 <apfelmus> well, the titles fit but i think they are to dull
02:38:35 <kowey> Haskell Performance might become something like Faster and Smaller
02:38:49 <kowey> the problem is that it has to be somewhat short, and clear at the same time
02:40:41 <apfelmus> clarity can be circumvented by adding an introductory subchapter whose title says what's going on, i.e. a subchapter entitled "Help, my program is so slow!"
02:40:50 <ski> apfelmus : pong
02:41:42 <kowey> actually, the introduction could just be the chapter page itself
02:41:54 <apfelmus> ski: hi! can you elaborate on your adventure game? i have some very bad feeling about it
02:42:08 <kowey> right now, the chapter pages just redirect to the first sub-chapter, but they could also be themselves content-ful
02:42:22 <apfelmus> kowey: ? there is an extra chapter page besides the table of contents
02:42:25 <apfelmus> ?
02:42:50 <kowey> http://en.wikibooks.org/wiki/Haskell/Haskell_Performance <-- is a redirect
02:43:09 <apfelmus> ah, ok
02:43:22 <tuukkah> if we were to extend haskell with our own syntax, would we want to use haskell-src, haskell-src-exts, patch ghc, or something else?
02:44:11 <apfelmus> kowey: but they cannot be accessed from the main page, can they?
02:44:57 <kowey> we could change the titles, so that instead of === Haskell Performance ===, you would have === [[Haskell Performance]] ===
02:45:18 <kowey> but maybe thisn't such a good idea, because users won't realise that they can click there...
02:46:30 <apfelmus> yes. i think this would introduce blue color, too
02:47:13 <ski> apfelmus : the world is a graph of rooms, connected by passages, with a current room .. this is represented as a tree with the current room at the root, and passages to the neighbouring rooms, etc (no backlinks)
02:47:22 <ski> apfelmus : when walking down a link/passage, i add to the new room a link to the old room (with the link to the new room removed) .. the good thing is that i can store local state inside the rooms .. the bad thing is that i can't model cyclic graphs
02:47:51 <ski> (if you want to look at the code, just tell)
02:48:26 <apfelmus> ski: ah, ok, that's what i suspected: you can't model cyclic graphs / DAGs. it's quite restrictive for an adventure game, isn't it?
02:48:42 <ski> yes .. a bit
02:48:59 <ski> (but, i can have two-directional links)
02:49:21 <ski> (s/two-/bi/)
02:50:10 <apfelmus> ski: yes, those are not a problem because there are still only two rooms to deal with.
02:51:40 <ski> the approach has similarities to pointer-reversal
02:52:15 <ski> (if implemented in Clean, possibly it would actually be pointer-reversal in-place update)
02:52:52 <ski> so, i guess the problem with cyclicity is the nonlinearity
02:54:37 <apfelmus> ski: yes. due to persistence, one cannot replace one object in multiple locations without replacing the locations themselves
03:46:47 <araujo> morning!
03:48:01 <fasta> Is there a version of assert that is more lazy?
03:48:48 <fasta> It seems quite wrong that using assert changes the semantics of a program.
03:51:01 <ibid> i'm not sure that a lazy assert makes sense
03:51:22 <fasta> Even more annoying is that GHC and Hugs have a different opinion as to what the answer of my program is.
03:51:39 <fasta> GHC thinks there's an index out of of bound.
03:51:47 <fasta> Hugs returns the correct answer.
03:52:05 <ibid> hmm, actually it could make sense, but it would require changes in the runtime system
03:52:26 <ibid> namely, attach asserts to thunks, and when the thunk is forced, check the value against the assert
03:52:27 <fasta> ibid: yes, it makes sense, since it
03:52:35 <fasta> 's a computation I could do.
03:52:42 <ibid> huh?
03:52:47 <fasta> ibid: and if I can do it, a computer can do so too.
03:54:37 <fasta> But this is hugely annoying.
03:54:43 <ibid> fasta: there are cases where i can't figure out sense to it
03:54:57 <ibid> for example, asserting that a value's length is bounded
03:55:14 <ibid> the assertion requires the forcing of the list up to the bound at least
03:55:15 <fasta> ibid: yes, infinite values are a problem
03:55:33 <ibid> fasta: no infinite values involved here
03:55:43 <ibid> (necessarily)
03:56:09 <ibid> s/is bounded/is shorter than a given bound/
03:56:20 <paolino> anyone can tell me why there is the functional dependence in the MonadState class ?
03:56:21 <paolino> http://www.nomaware.com/monads/html/statemonad.html
03:56:22 <lambdabot> Title: The State monad
03:56:22 <ibid> so, assert length list < 32
03:56:31 <ibid> requires evaluating list to at least depth 32
03:56:52 <fasta> paolino: try to write the same interface without functional dependencies and you know.
03:57:23 <paolino> class Monad will complain ?
03:58:44 <matthew-_> so it says "m uniquely determines s". where m is a type constructor and s is a type
03:58:44 <fasta> paolino: I didn't do that exercise myself, but I have a pretty good idea of the reason and it's best if you check for yourself.
04:00:20 <fasta> Is there any other Haskell system that supports the standard libraries and common extensions?
04:00:24 <matthew-_> without it, you could write instance MonadState (State Bool) Int where
04:00:27 <fasta> (besides GHC and Hugs)
04:02:46 <fasta> It appears there's an off by one error somewhere in GHC.
04:03:56 <matthew-_> ...although, my description is wrong.
04:04:03 <matthew-_> ...as is my example. Grr
04:14:36 <matthew-_> right. so it prevents you writing instance MonadState Foo Bar where... and instance MonadState Foo Baz where...
04:14:41 <jethr0> !paste
04:14:41 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
04:15:43 <jethr0> can someone help me with monad transformers?
04:16:19 <jethr0> i wrote a tree monad and would like to stack a StateT on top, but somehow i'm not quite getting it right...
04:16:34 <matthew-_> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers perhaps?
04:16:36 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
04:17:22 <kolmodin> I can't compile lambdabot, I get 'Ambiguous type variable `a' in the constraints' for all uses for the Binary library
04:18:05 <kolmodin> anyone else got that too?
04:18:37 <jethr0> matthew-_: thx, i've been there, kinda.
04:18:41 <hpaste>  jethr0 pasted "tree monad" at http://kakapo.scannedinavian.com:8000/18
04:19:31 <jethr0> i've got my tree monad and would now like to do something like "evalStateT (Leaf 0 >> get >>= return) 0"
04:20:38 <jethr0> but i'm quite unsure how to proceed
04:20:57 <kolmodin> jethr0: so you got your tree monad working and want to stack a StateT with it?
04:21:06 <jethr0> yes
04:21:15 <jethr0> so that i can enumerate leaves for example
04:21:21 <kolmodin> ok
04:21:33 <jethr0> i've already done that with "mapTree", but now i'd like to use my monad directly...
04:21:41 <kolmodin> sure
04:24:47 <kowey> jethr0: the wikibook monad transformer talk page has a comment with a simple example embedding IO in StateT
04:24:50 <kowey> http://en.wikibooks.org/wiki/Talk:Haskell/Monad_transformers
04:25:21 <jethr0> k
04:25:31 <kowey> maybe if you replaced liftIO with lift, and IO with Tree, it will become clearer
04:25:43 <jethr0> i'm just unsure how to call the "return" of my Tree monad. would "lift return" work?
04:25:51 <kolmodin> so you want to produce a new tree, corresponding to an enumeration?
04:26:25 <kolmodin> hia gour
04:26:32 <jethr0> kolmodin: for example i'd want the tree "Branch (Leaf "hello") (Leaf "world")" to become "Branch (Leaf 0) (Leaf 1)"...
04:26:47 <gour> kolmodin: hi.
04:27:35 <paolino> fasta: it just compiles
04:28:06 <fasta> paolino: paste the code
04:28:25 <fasta> paolino: try to use it first, btw.
04:28:36 <fasta> paolino: I think you will see that it doesn't work then.
04:28:43 <hpaste>  jethr0 annotated "tree monad" with "" at http://kakapo.scannedinavian.com:8000/18#2
04:28:44 <lambdabot> Title: tree monad - hpaste
04:29:12 <jethr0> this ^ is the code that's working just fine as "State a (Tree a)"
04:29:24 <paolino> eh
04:29:26 <jethr0> and now i'd like to use the same code in a "StateT a Tree b"
04:29:35 <jethr0> eh, s/(Tree a)/(Tree b)/
04:30:51 <jethr0> like "runStateT (tree >>= f) (0,empty)"
04:32:31 <paolino> jethr0: I just did that passage in my shuffle module
04:32:35 <paolino> :P
04:33:02 <jethr0> shuffle mode?
04:33:15 <paolino> all I did is rewrite the signatures
04:33:48 <paolino> adding MonadState to the contexts
04:34:18 <paolino> and putting m in place of "State s" in the outputs
04:35:02 <paolino> => State s a   in
04:35:03 <paolino> (MonadState s m) => m a
04:35:37 <jethr0> hmm
04:35:45 <paolino> nowit works in both cases
04:35:54 <jethr0> k, could you paste that code please?
04:36:54 <paolino> http://catenova.org/~paolino/clusterer/Lib/shuffle.hs
04:37:55 <paolino> I had to generalize the run0 function so that I can pass it the right evaluator
04:37:55 <paolino> (evalState or evalStateT)
04:39:00 <astrolabe> jethr0: I found this paper helpful in understanding monad transformers.  (I've forgontten them now :(  )  http://web.cecs.pdx.edu/~mpj/pubs/composing.html
04:39:01 <jethr0> paolino: have you seen MonadRandom on the wiki?
04:39:01 <lambdabot> Title: Composing Monads
04:39:22 <jethr0> http://haskell.org/haskellwiki/New_monads/MonadRandom
04:39:24 <lambdabot> Title: New monads/MonadRandom - HaskellWiki
04:40:45 <jethr0> astrolabe: thx, i need all the papers i can get, since my brain doesn't seem to be quite optimally structured for monad transformers :)
04:41:13 <astrolabe> jethr0: I suspect if it was, you'd have to be locked up for your own safty.
04:41:22 <jethr0> hehe
04:42:11 <paolino> jethr0: I have my vision of them: move arguments from function level to type level
04:42:46 <xpika2> can someone explain to the reason why my  /usr/lib/ghc-6.6/package.conf seems to be all one line?
04:43:19 <astrolabe> xpika2: looking at a unix file on a windows machine?
04:43:34 <xpika2> i think its the other way around
04:43:40 <astrolabe> Ah
04:43:56 <xpika2> which is why im confused
04:45:10 <paolino> http://catenova.org/~paolino/clusterer/Lib/shuffle.hs
04:45:13 <paolino> sorry
04:45:21 <apfelmus> kowey: http://en.wikibooks.org/wiki/Talk:Haskell
04:45:30 <paolino> http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
04:45:32 <lambdabot> Title: Monad Transformers Step by Step
04:45:53 <kowey> apfelmus: yeah... maybe it's worth just archiving some of the stuff
04:46:18 <paolino> jethr0: that one is very easy
04:46:39 <kolmodin> xpika2: it's saved to disk using 'show', which makes everything appear on one line
04:46:52 <jethr0> paolino: thx, i'll have a look
04:47:35 <kolmodin> jethr0: your mapTreeS solution doesn't use the fact that Tree is a monad
04:48:03 <jethr0> kolmodin: that's what i wrote. and since my mapTreeS is exactly what my monad does, i'd like to use the monad instead of mapTreeS
04:48:27 <apfelmus> kowey: yes. you may want to keep the section structure, but archiving comments on finished edits from say 2-3 months ago is a good idea.
04:48:33 <jethr0> so "runStateT (tree >>= f) 0" instead of "runStateT (mapTreeS f tree) 0"
04:48:59 <kolmodin> jethr0: your monad doesn't do proper traversal
04:49:09 <jethr0> kolmodin: why not?
04:49:16 <jethr0> not ordered, you mean?
04:49:43 <kolmodin> it doesn't to one branch first and then the other, it does both in parallel
04:50:18 <jethr0> kolmodin: yes, it could be written differently to solve this. but right now i'm just trying to get to compile :)
04:50:38 <astrolabe> It looks as though to get a hardcover SICP, I have to order it from America :(
04:51:44 <kowey> jethr0: would it be enough to lift tree? (lift tree >>= f) [i'm not really paying attention, so i don't know what this would actually do]
04:52:21 <jethr0> kowey: neither do i, i'll try, but if not i'm going to read these fine papers/tutorial first to get an idea what i want
04:53:01 <jethr0> astrolabe: i'm ordering books from the US all the time. mostly it's cheaper than buying locally even though there are $9 shipping costs
04:54:15 <astrolabe> jethr0: where are you?
04:54:41 <jethr0> germany
04:54:52 <astrolabe> ta
04:54:54 <jethr0> but i'd think that those $9 would be similar for all destinations
04:55:05 <jethr0> ta?
04:55:11 <astrolabe> Probably for me at least.  I'm in England
04:55:29 <astrolabe> ta = thank you (but informal)
04:55:43 <fatalis> that's ty
04:55:48 <jethr0> but astonishingly there are no cheap, used SICPs availabe at amazon. usually you can get these books in the US for <$20
04:55:55 <astrolabe> fatalis: no it isn't
04:56:03 <jethr0> you're welcome
04:56:21 <fatalis> ta means bye
04:56:42 <kowey> (do people actually say it? like 'tah'? or is it supposed to be something like 'thanks alot' abbreviated?)
04:57:04 <jethr0> la-di-da
04:57:30 <astrolabe> 'ta ta' is used for goodbye sometimes here (in England).  'ta' is used for thankyou.
04:57:59 <astrolabe> kowey: they actually say it, but mostly older people these days perhaps.
04:58:36 <kowey> i see
04:59:29 <fatalis> why do you think your local slang belongs on irc anyway
04:59:42 <astrolabe> http://www.urbandictionary.com/define.php?term=ta
04:59:44 <lambdabot> Title: Urban Dictionary: ta
04:59:59 <astrolabe> fatalis: because I choose to use it.
05:00:31 <kowey> eh, think  of it as an emergence of 'net-english' (or one of many net-englishes)
05:02:16 <fatalis> what if I chose to talk in my regional language too
05:02:22 <fatalis> would that be alright?
05:02:47 <fatalis> I mean, so what if no one understands, I *chose* to do it
05:02:58 <fatalis> it's my choice, bastards
05:03:02 <astrolabe> fatalis: feel free
06:03:38 <augustss> anyone here?
06:04:13 <apfelmus> augustss: mh?
06:04:38 <augustss> just seems everyone is leaving
06:04:49 <apfelmus> ?users
06:04:50 <lambdabot> Maximum users seen in #haskell: 311, currently: 282 (90.7%), active: 21 (7.4%)
06:07:10 <apfelmus> it's just that the enter/leave messages are more visible when nobody is talking. also, if everybody suddenly leaves, it's Colloquy that just crashed :)
06:09:56 <augustss> True, there was a 45 minute lull in the conversation.
06:10:39 <vegai> Has anyone succeeded in building ghc-6.6 on x86/solaris?
06:13:22 <yax1> if i have a big complicated function 'f -> Int -> Int' and call it in two parts of my program with the same parameter, will the result be calculated twice or cached somehow?
06:13:54 <augustss> it will be calculated twice
06:14:47 <augustss> you need to cache it yourself
06:14:54 <yaxu> ok, but if i do "x = f 4" then ...  ok
06:15:43 <augustss> if you use a let expression it will be computed once
06:15:49 <EvilRanter> I seem to recall reading that x `seq` f x only calculated x once. is that true?
06:16:24 <Ytinasni> EvilRanter: any use of the same value twice evaluates it only once
06:16:43 <yaxu> just to be clear, if i do "x = f 4" then i could use x multiple times with it only being calculated once?
06:16:46 <EvilRanter> Ytinasni, but not if it's a complex expression?
06:16:49 <Ytinasni> yes
06:16:56 <augustss> yaxu: that's right
06:17:04 <EvilRanter> (f x) `seq` g (f x) calls f twice, then
06:17:04 <yaxu> thanks, i'm just clearing out some conceptual wooliness
06:17:20 <Ytinasni> evil: if you write `let x = blah in ...use x multiple times...` x is evaluated only once
06:17:46 <augustss> Not that the Haskell standard says anything about this, but this is what all implementations do.
06:17:57 <EvilRanter> ok, i see
06:18:10 <Ytinasni> if you write it as `...use blah multiple times...`, blah is evaluated every time it is used (ignoring optimisation here)
06:18:26 <Ytinasni> augustss: it doesnt?
06:18:56 <Ytinasni> i'm curious now :D
06:19:00 <augustss> No, the Haskell standard says very little about operational samantics
06:19:45 <augustss> Even the title makes sure you're not locked down to using lazy evaluation.
06:19:57 <augustss> It says "non-strict"
06:20:13 <EvilRanter> so a suitably cunning implementation could identify more complicated expressions that would be suitable for caching
06:20:17 <EvilRanter> ?
06:20:28 <augustss> That would be perfectly fine.
06:21:10 <yaxu> i suppose it also pre-cache all possible parameters for all the functions
06:21:11 <augustss> And a poor implementation might decide to re-evaulate the expression every time you use a variable.
06:21:28 <augustss> yaxu: That would be fine too.
06:21:29 <yaxu> and running a program would just be a case of doing some lookups
06:21:47 <augustss> yaxu: it's difficult for large domains
06:21:52 <augustss> like, infinite
06:21:54 <EvilRanter> that'd be the naive implementation that worked entirely on LTR substitution...
06:22:03 <yaxu> augustss: yes :)
06:23:22 <augustss> yes, substitution is a fine way to evaluate Haskell
06:23:30 <yaxu> you'd just need a universe big enough to store all the numbers, and a fast lookup function across that universe
06:23:32 <augustss> Not the most efficient, but still
06:24:47 <augustss> Haskell allows a lot of leeway for the implementor.  I like that.
06:25:26 <yaxu> would Haskell' reduce this kind of leeway?
06:26:05 <augustss> Not that I'm aware of
06:27:09 <yaxu> someone said something about Haskell' being about feeding implementation back into the standard, i suppose that means extensions to the language by implementors rather than details of the implementation itself
06:27:57 <augustss> That's feeding extensions back, yes
06:28:26 <augustss> I think we have enough sensible people doing Haskell' to leave the semantics alone :)
06:28:50 <apfelmus> augustss: aye, what about the monomorphism restriction? afaik, it arose from entirely operational details
06:29:13 <augustss> apfelmus: yes, there are some warts
06:29:38 <augustss> polymorphic seq is another one
06:29:44 <apfelmus> :)
06:30:24 <augustss> The MR could be lifted.  And maybe it will be.
06:30:41 <augustss> Polymorphic seq I think we're stuck with :(
06:31:09 <apfelmus> i find it's very unfair to have the monomorphism restriction in the standard while not having the guarantee that lets are not floated across \ambdas
06:32:34 <augustss> yes, i mostly agree
06:33:54 <apfelmus> yes. either there are time & space remains unstandardized or the most critical things get included as well
06:34:14 <apfelmus> <strike>there are</strike>
06:35:57 <augustss> I'd like to see some space and time document as an appendix.  something that is recommended, but not mandated.  then each implementation could say how well it adheres to that
06:36:00 <fasta> What functions can cause: Ix{Int}.index: Index (4) out of range ((1,2))?
06:36:13 <augustss> !
06:36:18 <fasta> Only !?
06:36:24 <fasta> Or also (//)?
06:36:36 <augustss> Yeah
06:36:44 <augustss> and probably others too
06:36:45 <Philippa> augustss: heh, I'm reminded of the look you get on some people's faces when you talk about looking for "space-time leaks" in haskell code. Like they just grokked what we mean by "unsafe"... :-)
06:38:33 <yaxu> > lcm 0 3
06:38:41 <lambdabot>  0
06:38:51 <augustss> looking for a leak in the space-time continuum
06:38:53 <apfelmus> augustss: yes. preferably, the appendix can be turned on by a compiler flag. so, if you write a program according to the standard, you can chose between: "predictable outcome" and "predicatble outcome + (somewhat) predictable space & time"
06:44:52 <hpaste>  ski annotated "tree monad" with "TreeT" at http://kakapo.scannedinavian.com:8000/18#3
06:44:53 <lambdabot> Title: tree monad - hpaste
06:45:20 <ski> bah, jethr0 left
06:46:31 <EvilRanter> heh. I like how the bots work together on that.
06:46:49 <fasta> I get this impression of Haskell' piling feature on feature
06:49:58 <Philippa> it piled on proposals, but that's not the same thing
06:51:50 <fasta> What is the modus operandi for Hat/
06:53:36 <fasta> Nm
06:55:33 <pejo> fasta, hard to know which features are good if one never tries them out though.
07:03:39 <astrolabe> I agree that it would be nice if there was a written standard for haskell time and space efficiency (in big O terms).
07:04:19 <astrolabe> Failing that, it would be nice if the compiler documentation said was theirs was.
07:04:31 <astrolabe> It all seems a bit unofficial as it is.
07:06:02 <augustss> it is
07:07:10 <fasta> Haskell 98 is essentially undefined
07:07:24 <fasta> There are no complete formal semantics for it.
07:07:53 <apfelmus> to a human, this doesn't make a difference
07:08:27 <fasta> If you are writing a compiler, having formal semantics around seems to help
07:09:07 <apfelmus> ok
07:09:29 <augustss> fasta: there's no formal H98 semantics, but despite this I'd say H98 implementations differ less than implementations for most languages
07:10:45 <fasta> Do H98 implementations differ more than Java implementations?
07:10:58 <pejo> augustss, how's SML from that perspective, do the implementations differ a lot?
07:11:24 <fasta> SML has formal semantics, so one would expect less differences.
07:11:25 <augustss> SML would be the exception to my statement
07:11:41 <fasta> How about Scheme?
07:12:11 <augustss> fasta: I don't have enough Scheme experience to tell
07:12:13 <pejo> I constantly feel like I should learn a lot of programming languages. Boggle.
07:12:30 <EvilRanter> in my experience, SML flavours vary more than Haskell ones
07:12:44 <pejo> EvilRanter, semantics wise?
07:12:49 <EvilRanter> yeah
07:13:27 <EvilRanter> not for the actual core language, but they seem to like doing such things as multiple files in as many different ways as possible
07:13:29 <EvilRanter> IIRC
07:13:53 <pejo> "multiple files in as many places as possible"?
07:14:23 <apfelmus> pejo: it suffices to learn Haskell. all other languages arise from the right monad
07:15:59 <EvilRanter> pejo, I mean, the way they deal with their equivalent of haskell's "import"
07:16:44 <astrolabe> Maybe the do notation should be generalised to pre-monads.  You can compose them without problems.
07:17:36 <astrolabe> Also (>>)
07:19:17 <KaboemII> Is it possible to put more tekst lines in comment? like /*    */ in java  ?
07:19:22 <fasta> hat-trans: /usr/local/include/hat-2.05/Data/Array/MArray.hx: openFile: does not exist (No such file or directory)
07:19:35 <fasta> Anybody with a clue of why I get this message?
07:19:49 <astrolabe> KaboemII:  /- hello -/ iirc
07:19:53 <fasta> KaboemII: {- -}
07:19:55 <EvilRanter> KaboemII, {- ... -}
07:20:04 <astrolabe> KaboemII: ignore me!
07:20:21 <KaboemII> thanks a lot , astolabe  I iwll do that :p
07:20:27 <astrolabe> :)
07:21:01 <astrolabe> I wonder why each language feels it has to have it's own comment characters.
07:21:13 <fatalis> I wonder too, astrolube
07:21:37 <KaboemII> prolog and java has the same :)
07:22:05 <opqdonut> well, theres /* and // for c-style languages, # for scripting languages and -something for some
07:22:14 <opqdonut> so not that many in the end
07:22:24 <KaboemII> the /- -/ doesn't work here , {- -} works
07:22:28 <astrolabe> matlab has '%'
07:22:37 <velco> fortran has C ;)
07:22:40 <EvilRanter> postscript also uses %
07:22:40 <opqdonut> yeah, % in tex too
07:22:44 <astrolabe> KaboemII: yeah sorry, I misremembered
07:22:52 <KaboemII> np
07:22:55 <opqdonut> and dos batch has REM :D
07:23:08 <EvilRanter> VB uses Rem and '
07:23:15 <velco> probably COBOL has COMMENT ...
07:23:24 <EvilRanter> SML uses (* *)
07:23:42 <velco> pascal uses { }
07:24:20 <EvilRanter> perl uses # and "=begin COMMENT ... =cut"
07:24:30 <EvilRanter> (or just =pod...=cut)
07:25:43 <ski> KaboemII : Prolog has '%' as eond-of-line comment
07:26:12 <KaboemII> but /* */ also works
07:26:12 <yaxu> english uses () and footnotes
07:26:25 <KaboemII> we have to unite , the brotherhood of the comment  ! We exist to make comment consistent!
07:26:29 <koala_man> I use muttering
07:27:56 <ski> KaboemII : yes '/*','*/' is (nonnesting) block comment
07:28:04 <ski> astrolabe : 'pre-monads' ?
07:32:53 <twanvl> > let {(/*)=($);(*/)=($);ignored=0}    in     foldr (+) /* ignored */ [1..5]
07:32:54 <lambdabot>  15
07:34:26 <KaboemII> :o
07:36:46 <EvilRanter> I think that qualifies as a Never Do This.
07:37:06 <Saizan> we should have comments available in the repl
07:38:36 <augustss> Saizan: We should have many things available in the repl
07:38:59 <Saizan> like getComments map == "map f [x1..xn] = [f x1..f xn]"
07:41:40 <xerox_> twanvl: that's not really ignored
07:42:03 * twanvl is evil
07:42:03 <xerox_> > 2 + {- hmm -} 2
07:42:05 <lambdabot>  4
07:42:07 <xerox_> that is.
07:42:15 <paolino> uhm, directory/filenames must start uppercase in a haskell hierarchy  ?
07:42:30 <xerox_> paolino: yeah
07:43:12 <paolino> wtf
07:43:20 <Bison> hello
07:43:21 <paolino> :D
07:43:35 <paolino> I have to redo the all naming
07:43:50 <xerox_> use a shell script^W^W^Wan haskell program
07:43:56 <EvilRanter> it's to allow the sytem to differentiate between the dots in f.g and Control.Monad
07:44:29 <Bison> lets say i have data Foo = Bar | HH String
07:44:41 <paolino> darcs will get nervous
07:44:51 <Bison> now if i have [Bar, HH "rara"]
07:45:20 <Bison> how can i test to see if i have an HH String in the list?
07:45:36 <xerox_> paolino: oooh.
07:45:56 <paolino> Bison, list can hold only one type
07:45:57 <Botje> Bison: create a function that returns true if pattern matched against HH _
07:46:06 <Botje> return false for other values
07:46:11 <paolino> ops
07:46:13 <Botje> then use any thatfunction list
07:46:34 <Bison> alrighty
07:46:43 <EvilRanter> Bison, any isHH list where {isHH (HH _) = True; isHH _ = False}
07:46:48 <EvilRanter> dang, beaten to it
07:46:55 <augustss> Bison: not $ null [ () | HH _ <- yourList]
07:47:12 <EvilRanter> wow. augustss wins.
07:47:27 <Botje> ah, i was wondering about that :)
07:48:53 <xerox_> or use Maybe and catMaybes
07:49:16 <uccus> Bison: happy?
07:50:37 <uccus> guys, has MathematicalOrchid (wiki id) been spotted on IRC?
07:54:18 <emk> http://www.haskell.org/haskellwiki/GSLHaskell_on_MacOS_X
07:54:19 <lambdabot> Title: GSLHaskell on MacOS X - HaskellWiki
07:55:01 <emk> Some instructions for any other MacOS users who want to get GSLHaskell running for numeric computations.
07:57:40 <uccus> @tell dmhouse Haskell/Category theory rocks.
07:57:40 <lambdabot> Consider it noted.
08:02:14 <emk> uccus: Yes, it does. It also tends to hurt my head a bit. :-)
08:04:57 <astrolabe> ski: pre-monads are Functors with a return function satisfying return.f = map f . return
08:05:48 <astrolabe> ski: from page 3 here http://web.cecs.pdx.edu/~mpj/pubs/RR-1004.pdf
08:06:02 <EvilRanter> so they've got return but no bind?
08:06:12 <astrolabe> EvilRanter: right
08:08:06 <ski> astrolabe : ah, interesting
08:11:17 <ski> (i had wondered if that construction had any particular name)
08:11:57 <astrolabe> I find it an interesting paper.
08:12:41 <xerox_> leed always make my emacs load jp packages...
08:12:56 <ski> yes .. (when i saw http://web.cecs.pdx.edu/~mpj/pubs/composing.html i thought it was one i had already read)
08:12:57 <lambdabot> Title: Composing Monads
08:14:00 <xerox_> lots of points-free-reduction in that code :D
08:14:06 <xerox_> s/code/paper/
08:15:37 <astrolabe> Yeah.  I find all this stuff really difficult.
08:16:12 <xerox_> proofs
08:17:02 <astrolabe> proofs?
08:17:09 <xerox_> Those are proofs
08:17:11 <EvilRanter> proofs!
08:17:54 <xerox_> The evaluator coded with monad comprehension is pretty nice.
08:18:37 <astrolabe> xerox: you are reading it about 1000 times faster than me.
08:19:03 <emk> astrolabe: Don't worry, you'll get faster. :-)
08:19:20 <astrolabe> emk: I'm getting older and slower :(
08:19:54 <emk> Well, so are we all, but the monad stuff goes quicker once you internalize the basics.
08:20:36 <xerox_> astrolabe: I'm skipping through because I need to study other things, but I've saved it for later reading. Thanks for the pointer.
08:20:57 <astrolabe> True: I'm ok with a lot of simple monad stuff.
08:21:10 <astrolabe> xerox: how are your courses going?
08:21:18 <xerox> they're over :)
08:21:31 <astrolabe> xerox: no new ones this term?
08:21:48 <xerox> there is this little pause due to the universiad
08:22:12 <astrolabe> ah
08:22:23 <xerox> ?spell olympiad
08:22:25 <lambdabot> Olympiad Olympiads Olympias Olympia Olympian
08:22:59 <xerox> we just had the Olympiads here, but there is no snow...
08:23:35 <xerox> that's better, so one can concentrate on studying without getting angry because he can't go to skiing/snowboarding (:
08:24:11 <astrolabe> Did you take part?
08:24:50 <xerox> no, I'm not olympic level, I think :)
08:32:23 <xerox> (but I like snow sports, you do not?)
08:33:01 <astrolabe> xerox: I've never tried them (except snowball fights :) )
08:33:14 <xerox> yay, I think that counts, hehe.
08:33:30 <yaxu> is snowman building a sport?
08:33:34 <astrolabe> I think I've missed out.
08:33:56 <xerox> yaxu: depends on the artistic quality of the snowman, prolly
08:34:02 <astrolabe> possibly one of those sports you need judges for.
08:35:02 <apfelmus> augustss: ping
08:35:25 <augustss> yep
08:36:19 <apfelmus> concerning seq, i always wanted to ask why Haskell has no strictness annotations in the types, i.e. like (foo :: !Int -> Int)?
08:36:49 <vegai> apfelmus: are you sure it doesn't?
08:37:13 <apfelmus> > let foo :: !Int -> Int; foo x = x in foo 1
08:37:14 <lambdabot>  Parse error
08:37:49 <augustss> apfelmus: I'm not sure why.  It was never in the design space as far as I can remember.  It's also kind of weird, because you mix types with evaluation.
08:38:14 <vegai> apfelmus: ghc clearly recognizes that as a strictness annotation
08:38:18 <KaboemII> what does that "!" mean in !Int ?
08:38:29 <vegai> apfelmus: perhaps it just doesn't make any sense when used like that?
08:38:41 <vegai> I mean, how can an Int be lazy?
08:38:48 <augustss> vegai: you can only use ! with types in data declaration
08:39:08 <vegai> yes, that's much better articulated :)
08:39:36 <EvilRanter> would the point of, say, f::!Int -> Int be to force the evaluation of the argument before evaluating the function?
08:39:38 <apfelmus> augustss: i find it entirely reasonable. and i even think it's the most natural way to express what you want. see, !Int is like an unboxed (unlifted) integer and those have to be strict by default
08:39:41 <xerox> Int takes its time to get out of a floor, for example
08:39:41 <augustss> vegai: But ! makes sense in signatures too, some languages have them
08:40:48 <augustss> apfelmus: but you have to be careful.  E.g., are Int and !Int interchangable or different types?
08:40:49 <vegai> hmm, I suppose.
08:41:33 <augustss> If they are different types then I have no problem with it, but then it's not as convenient.
08:41:53 <apfelmus> augustss: lazy :: !Int -> Int; force :: Int -> !Int. Of course, lazy is kinda weird, but ironically, ghc 6.6. introduces just that
08:41:56 <augustss> Also, !a would be another abomination
08:41:58 <EvilRanter> what'd be a -> !a?
08:42:10 <apfelmus> more general force :: a -> !a
08:42:18 <apfelmus> force :: forall a . a -> !a
08:42:27 <EvilRanter> apfelmus, would force = (id $!)
08:42:27 <EvilRanter> ?
08:42:51 <apfelmus> EvilRanter: kind of. except for the types
08:42:57 <augustss> Well, before I can say anything else, I'd have to know what ! means
08:43:10 <EvilRanter> (or indeed (force x = seq x x))
08:43:30 <augustss> if !Int means unlifted int, then a function Int->!Int must terminate?
08:43:40 <xerox> force = join seq
08:43:55 <EvilRanter> ?type join
08:43:56 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
08:43:59 <augustss> xerox: seq x x ==== x
08:44:08 <xerox> augustss: four!
08:44:19 <augustss> They are very equal :)
08:44:40 <EvilRanter> doesn't the seq force evaluation of x, tho?
08:44:50 <apfelmus> augustss: sure, mixing ! with polymorphic stuff etc. needs thinking to make it sound. but i think it's possible.
08:44:50 <apfelmus> but let's give ! a meaning. do you know Ralf Hinze's dissertation on strictness analysis?
08:44:52 * EvilRanter is just confused now
08:45:02 <xerox> `join seq' disappears in a puff of logic.
08:45:03 <augustss> EvilRanter: only when the seq expression is evaluated
08:45:24 <augustss> So 'seq x x' means exactly the same as x.
08:45:27 <astrolabe> EvilRanter: I think only enough to prove it isn't bottom
08:45:33 <EvilRanter> ah. well, surely that'd apply to our hypothetical "force", too?
08:45:39 <augustss> Because they both evaluate x when the expression gets evaluated
08:45:52 <apfelmus> augustss: (i think i can shorten the discussion if you do)
08:47:00 <apfelmus> ?paste
08:47:01 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
08:47:02 <augustss> apfelmus: Sorry, I've not read Ralf's dissertation.  But I'm sure you can make sense of !
08:48:35 <apfelmus> augustss: i think it's best not to make sense of !, but to make sense of the inverse.
08:48:36 <apfelmus> ah, actually it's like strict ML with those fancy $-suspensions
08:49:16 <augustss> Which I also found a bit dodgy.  :)
08:49:16 <apfelmus> so imagine you are in a strict language with the usual semantics involving _|_
08:49:24 <uccus> I have a newbie question... anyone has time?
08:49:38 <augustss> uccus: go ahead
08:50:02 <apfelmus> augustss: then, the domain for Int looks like the paste coming below
08:50:04 <uccus> apart from laziness/strictness... what are the principle differences between ML and Haskell?
08:50:21 <EvilRanter> monads. non-broken polymorphism.
08:50:23 <augustss> apfelmus: I know what it looks like
08:50:31 <astrolabe> haskell's syntax is nicer from what I've seen
08:50:55 <EvilRanter> the main thing that made me go "ooh, that's so much better" is the non-broken polymorphism, actually
08:51:02 <augustss> uccus: ML allows side effects without it showing up in the type.  Haskell doesn't
08:51:34 <uccus> I understand monads are a difference as I know type-classes were one of the "innovations", but what do you mean by non-broken polymorphism?
08:51:37 <EvilRanter> from using ML, I remember thinking "it'd be so much nicer if there was some way types were marked as "numeric", or "ordered"..."
08:52:14 <apfelmus> augustss: ok :) now, you simply take those strict Ints and define
08:52:15 <apfelmus> data Up Int = Up Int
08:52:16 <augustss> apfelmus: the Int domain looks the same in ML and Haskell
08:52:17 <EvilRanter> ML's ad-hoc polymorphic functions are a hack
08:52:18 <hpaste>  apfelmus pasted "boxed integers" at http://kakapo.scannedinavian.com:8000/19
08:53:00 <augustss> EvilRanter: overloaded they call them :)
08:53:08 <uccus> umm.. you see.. I don't know ML.. could you explain a bit speaking in Haskell?
08:53:10 <EvilRanter> whatever. it's a horrific hack.
08:53:15 <apfelmus> augustss: yes, they look the same. but for the discussion of "unboxed", this is in somewhat detrimental
08:53:20 <augustss> EvilRanter: Except for the weird equality types.
08:53:35 <ski> doesn't Clean have strictness annotations in type signatures ?
08:54:00 <augustss> ski: yes, I seem to remember it does
08:54:13 <uccus> I took TAPL out of the library and subsequently the sequel as well.. it seemed to imply ML module system is a wonder
08:54:19 <EvilRanter> uccus, they have Eq, Ord, and Num, but you can't use them explicitly. Eq is guessed as with Haskell's "deriving", and Ord and Num can only be used with hte builtin types
08:54:52 <uccus> but I don't _know_ what benefits they offered... so... could you explain?
08:55:12 <augustss> uccus: The ML module system is pretty cool.  But rather complex.
08:55:17 <pejo> Speaking of broken polymorphism - isn't one of the identified cases where problems with principal types in Haskell for type classes?
08:55:19 <EvilRanter> Haskell's typeclasses are such a logical solution to this brokenness, that I thought them up independently after playing with ML for a couple of weeks when i was 16. :P
08:55:43 <ski> uccus : one cool thing is that you can parameterize a module on argument modules
08:55:57 <uccus> evilranter: I can imagine it had no type classes,.. so what were the benefits?
08:56:08 <EvilRanter> none that I know of. I prefer haskell.
08:56:09 <EvilRanter> :P
08:56:33 <yaxu> if i wanted to have floats and ints in the same array, would the best way be to use Either ?
08:56:38 <uccus> ski: like I will supply a sorting module with my custom ordering?
08:56:46 * ski nods
08:57:00 <augustss> pejo: I think you can get principal types back with the right definition of contexts.  Didn't H98 fix the problem?
08:57:08 <uccus> but that's very, very doable in Haskell!
08:57:18 <EvilRanter> i think you can achieve everything you want parameterized modules for with Haskell fairly easily. you might need fundeps
08:57:33 <augustss> uccus: There are more compelling examples.
08:57:47 <uccus> what was there that we _can't_ do in Haskell? caveats that make an ML programmer go... umm... I'll stick to ML?
08:58:00 <pejo> augustss, isn't the discovery after 98?
08:58:11 <EvilRanter> you can't be a smug Cantabrigian
08:58:19 <augustss> pejo: It was known before H98
08:58:22 <ski> uccus : there's an OCaml example at http://caml.inria.fr/pub/docs/manual-ocaml/manual004.html, 'tseems
08:58:24 <lambdabot> Title: The module system
08:58:31 <Codex_> uccus: what about side effects. You cant do them (without monads)...
08:58:41 <uccus> augustss: complelling as in "needs a lot of workarounds"?
08:59:08 <augustss> uccus: Of course you can do anything in Haskell.  But certain modularization isn't as convenient as in ML
08:59:13 <apfelmus> augustss: so you have 2 integers: the unboxed Int (in our strict language) and the boxed (Up Int). the point is that (Up) is lazy and creates a suspension, i.e. (Up _|_ \neq _|_)
08:59:17 <uccus> Codex_: but doesn't Haskell benefit from a clearer way of reasoning about?
08:59:20 <ski> uccus : if you want to have several different orderings you need to kludge around with 'newtype', in haskell
08:59:23 <Adamant> can you do eager evaluation in Haskell?
08:59:33 <ski> (but, there probably are better examples ..)
08:59:49 <uccus> lol. I'm after the better examples!
09:00:18 <apfelmus> augustss: in the end, we have
09:00:18 <apfelmus> force :: Up Int -> Int    and    lazy :: Int -> Up Int
09:00:24 <uccus> Adamant: that's pretty much the current discussion, you can, and how to specify more accurately
09:00:55 <augustss> Adamant: you can do eager, but it's more painful
09:01:15 <uccus> Adamant: exactly how do you want to evaluate eagerly. it turns out that a way of controlling eagerness often has performance benefit (or does it?)
09:01:28 <EvilRanter> apfelmus, but how does force work?
09:01:31 <musasabi> EvilRanter: parametrized modules would be very nice for Haskell.
09:01:53 <Adamant> well, I am thinking that Haskell does a lot of neat things
09:01:55 <uccus> musasabi: does it conflict with any fundamental design goals?
09:02:01 * augustss has wished for parametrized modules a lot lately.
09:02:05 <apfelmus> EvilRanter: well, it's simply (force (Up x) = x). the only point is that (Up) has some magic in it
09:02:09 <Adamant> laziness, isolating IO in a monad, etc.
09:02:10 <EvilRanter> does (force x) always evaluate x, even if the context of (force x) gets the value immediately discarded?
09:02:12 <musasabi> uccus: I don't think so.
09:02:30 <yaxu> > [Left (1 :: Int), Right 1.2]
09:02:32 <lambdabot>  [Left 1,Right 1.2]
09:02:33 <augustss> musasabi: yes, it does.
09:02:39 <Adamant> but is doing things the Haskell way always a net benefit?
09:02:42 <musasabi> augustss: how?
09:02:55 <uccus> Adamant: of course not.
09:03:00 <apfelmus> EvilRanter: conerning that, force does not really behave any different from seq.
09:03:09 <augustss> musasabi: the Haskell module system is only about name space control at the moment.  that would no longer be the case with parametric modules.
09:03:12 <Adamant> for instance, if you're doing some IO intensive code, wouldn't it be more natural to code it in something other than a pure functional language?
09:03:30 <musasabi> augustss: but that is no longer true with overlapping instances.
09:03:40 <EvilRanter> musasabi, it seems to me you could do similar things with a class in place of the parameterised module
09:03:42 <Adamant> just from a development time perspective
09:03:43 <apfelmus> Adamant: no, because this situation should not arise :)
09:03:48 <astrolabe> Adamant: I wouldn't say so.
09:03:51 <augustss> musasabi: I don't regard overlapping instances as something that is in Haskell
09:04:03 <uccus> Adamant: I think you are missing the point. if you want to do IO intensive code, choose your fav non-functional language to do that
09:04:08 <musasabi> EvilRanter: the types get too complex and it is quite painful to write.
09:04:12 <Adamant> ok, I must be
09:04:15 <Adamant> what is the point?
09:04:18 <augustss> Adamant: writing IO code is actually very nice in Haskell
09:04:31 <musasabi> uccus: Haskell is nice for IO code.
09:04:32 <augustss> Adamant: because statements are first class
09:04:32 <astrolabe> IO in haskell is very nice in my opinion.
09:04:33 <EvilRanter> > import My.ParameterisedModule (ParameterisedModuleClass); instance ParameterisedModuleClass () where { <<your "parameter module" here>> }
09:04:34 <lambdabot>  Parse error
09:04:50 <uccus> Adamant: I and not contradicting any of the other guys here
09:05:06 <sorear> tell fodder
09:05:07 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
09:05:17 <apfelmus> augustss: for !, one simply changes naming: (Up Int) will be called Int and Int will be called !Int
09:05:27 <uccus> Adamant: what I'm saying is, monadic IO requires a lot more thinking about how to sequence your IO
09:05:55 <augustss> apfelmus: But then Int will not be the Int that haskell has now
09:06:06 <uccus> Adamant: but it has other benefits. a lot of current research is going into concurrency. and frankly I think Haskell is the best language of choice for that.
09:06:31 <musasabi> Erlang is quite nice for concurrency.
09:06:33 <uccus> Adamant: check out the work of STMs...
09:06:42 <augustss> apfelmus: Current Int in Haskell has no element that corresponds to Up _|_
09:07:04 <apfelmus> augustss: no, it's exactly the same. currently, we have access to (Up _|_), but not to _|_
09:07:32 <musasabi> with Haskell concurrency is still a bit hard.
09:07:44 <musasabi> (if robust solutions are needed)
09:07:56 <augustss> apfelmus: well, if you claim some domain elements are not accessible then I could agree
09:08:11 <vegai> Is hs-plugins portable? Will we ever see it on yhc?
09:08:36 <sorear> vegai: I think the API is portable - the implementation no way.
09:08:38 <augustss> apfelmus: But I'd like a more rigorous argument.  Does Ralf's thesis have it?
09:09:10 <sorear> it does fun stuff like foreign import rts functions iirc
09:09:11 <uccus> random thought: I always thought records should be strict.
09:09:34 <uccus> random thought: would neatly divide the semantics.
09:10:05 <augustss> uccus: making record strict would be un-haskellish :)
09:10:30 <uccus> :) only if you mean Haskell is the flagship lazy language
09:10:49 <augustss> uccus: well, it is :)
09:11:09 <apfelmus> augustss: well, the accessibility is my thinking but it arose naturally to me when reading Ralf's thesis. he introduces (Up) quite early, on page 5. i think it's enough to just read the introduction
09:11:25 <uccus> and (+++) :: !Int -> !Int -> !Int is very "Haskellish", I suppose ;)
09:12:12 <uccus> or the unboxed tuples! ;)
09:12:19 <emk> Is there a standard Haskell library for Erlang-style message passing?
09:12:40 <vegai> sorear: I'm also thinking that YHC's architecture might allow to accomplish the same thing somehow easier
09:12:40 <augustss> Haskell is lazy, so having things lazy by default is the "right way", in my opinion
09:13:13 <augustss> emk: There is a channel abstraction
09:13:29 <uccus> and... what about unboxed tuples?
09:13:42 <sorear> vegai: yes, the interface could be cloned easily
09:14:05 <augustss> emk: Control.Concurrent.Chan
09:14:15 <emk> augustss: Thanks!
09:14:21 <sorear> ideally System.Eval.Haskell and friends would be in a compiler-switched library like the proposed Core
09:14:28 <astrolabe> uccus: unboxed tuples are a necessary evil for when performance is important.
09:15:14 <uccus> :( that was my whole point! the necessary evil exists! so why not embrace it! :(
09:15:35 <apfelmus> augustss: well, i think the rigorous argument is the following: take any data type, like Int. call it (Up Int) and call every element (Up 1), (Up 2), (Up _|_) and so on. now, introduce a new least element _|_ and augment every function by (f _|_ = _|_). QED
09:15:37 <astrolabe> because it's evil?  :)
09:15:44 <pejo> Heh, what is evil in this context, strict evaluation, unboxed values, or something else?
09:16:02 <uccus> pejo: everything 8-)
09:16:12 <astrolabe> yeah, I think.
09:16:34 <augustss> apfelmus: and what happens with non-flat domains, e.g., list
09:16:44 <sorear> ooh that sounds like a functor
09:17:30 <uccus> non-flat domains is a complicated name for recursively defined algebraic data types?
09:17:35 <augustss> uccus: I'm not sure the necessary evil is really necessary
09:18:43 <uccus> augustss: I don't intend to start "this language vs. that language" crap, but what makes Clean so fast?
09:18:44 <augustss> uccus: recursive data types is an example of a non-flat domain
09:18:54 <apfelmus> augustss: ah. but it doesn't matter. take any constructor, like Unary and say it Unary _|_ = _|_. Then, it's unimportant whether you first lift by the new _|_ and then take the fixed point or whether you first take the fixed point and then lift.
09:18:58 <emu> non-flat refers to the lattice of well-definedness
09:19:10 <emk> augustss: It looks like Control.Concurrent.Chan might be a useful starting point for building Erlang-style semantics, but it doesn't have a pattern-matching "receive" construct.
09:19:29 <augustss> uccus: I'm not sure what makes it so fast.  they have put a lot of work into their compiler. :)
09:19:53 <uccus> augustss: my limited knowledge of denotational semantics makes me come up with only recursive datatypes. can you give me some other examples?
09:19:55 <augustss> emk: you'd have to get an item, pattern match, and put it back if it was the wrong one
09:20:11 <glguy> Some of Clean's performance comes from prevasive strictness annotations
09:20:31 <uccus> that makes strictness a necessary evil, as claimed
09:20:37 <apfelmus> uccus: maybe http://en.wikibooks.org/Haskell/Denotational_semantics helps?
09:20:41 <emk> augustss: And then scan down the queue for something which did match... Erlang's quite happy to receive out-of-order.
09:20:48 <uccus> apfelmus: I thought I read it :(
09:20:48 <augustss> uccus: well, just 'data T = X Bool | Y Int' would have several levels
09:20:52 <uccus> okay, checking
09:21:27 <augustss> emk: yeah, you might want to take Chan and munge it into something different :)
09:21:27 <paolino> what I have to put in the build-depends field of cabal file to use Control.Monad  in my modules ?
09:21:38 <Kaboem> What's wrong with this : data Boom a = Knoop Boom a Boom a | Blad a
09:21:47 <sorear> Kaboem: precedence
09:22:07 <sorear> data Boom a = Knoop (Boom a) (Boom a) | Blad a
09:22:24 <sorear> the first def was a kind error
09:22:48 <paolino> is 'base' is not enough ?
09:22:56 <xerox> mtl
09:23:00 <sorear> paolino: base is enough
09:23:18 <sorear> paolino: mtl has Control.Monad.*, but base has Control.Monad itself
09:23:29 <sorear> @docs
09:23:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
09:23:32 <xerox> @go how to write an haskell program
09:23:34 <lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
09:23:34 <uccus> augustss: apologies.
09:23:34 <lambdabot> Title: How to write a Haskell program - HaskellWiki
09:23:58 <sorear> ^^^^ on the libs page, there should be a what-package next to each module
09:23:59 <augustss> uccus: apologies?
09:24:00 <apfelmus> augustss: by making data constructors strict in _|_ (which is not our beloved (Up _|_)), non-flat domains are no problem
09:24:06 <paolino> ok
09:24:16 <augustss> apfelmus: hmmm, ok
09:24:34 <uccus> augustss: so the only flat domain in a lazy language are things like enumerations?
09:24:52 <augustss> uccus: yes
09:25:20 <uccus> but things like Either make very uninteresting non-flat domains, is there a different term for these?
09:25:49 <augustss> uccus: with Int, Char, and Integer being enumerations too
09:25:59 <earthy> there's a lot of things that make clean so fast
09:26:02 <augustss> uccus: I dunno if it has a name
09:26:16 <uccus> augustss: I understand. even Integer would be flat, right?
09:26:21 <earthy> one of the most important ones is simple: very good strictness handling
09:26:23 <augustss> uccus: yes
09:26:27 <apfelmus> augustss: in the end, we get strict semantics in _|_ and lazy semantics in (Up _|_). and we can introduce the unboxed integers !Int (= Int#) which just look like we know it
09:26:31 <uccus> sorry you've already told that
09:26:40 <earthy> *everything* in the standard libs has strictness annotations
09:26:46 <earthy> and there's good strictness inference
09:27:04 <paolino> sorear , now it fails on Random, which should be in the base
09:27:23 <uccus> related, but off-topic: uniqueness can be inferred?
09:27:32 <earthy> uccus: partially, yes
09:27:33 <sorear> paolino: Random was moved to System.Random ; a compatibility alias can be found in 'haskell98'
09:27:40 <uccus> does GHC do that?
09:27:49 <earthy> uniqueness? not that I know
09:27:57 <earthy> Clean does, ofcourse
09:27:57 <uccus> would it help?
09:28:12 <earthy> possibly, although I think strictness helps more
09:28:23 <augustss> earthy: but in Clean you give uniqueness annotation in the types
09:28:25 <uccus> ok. understood.
09:29:00 <earthy> augustss: you don't need to do so for everything, IIRC
09:29:13 <earthy> but it's been a while since I've done much Clean
09:29:15 <uccus> augustss: Clean documentation seem to imply uniqueness is more important than strictness in Clean, though it might be because it's unique to Clean
09:29:41 <augustss> earthy: I think you're right.  as long as the right primitives have the uniqueness annotations
09:30:07 <uccus> besides, Wadler is so excited about linear logics... thought it might be more important than I think (ponders)
09:30:26 <augustss> uccus: uniqueness is good for update in place.  But Haskell can do that too, e.g., in the ST monad.
09:30:39 <pejo> uccus, the man has a reasonable track record. ;)
09:30:47 <uccus> :)
09:31:05 <augustss> But not enough work has been spent in GHC to make the ST code fast
09:31:20 <sorear> augustss: ST makes it harder for the compiler to interleave operations ... it forces single threadedness
09:31:35 <uccus> sorear: I thought it was a good thing
09:31:35 <sorear> (digusted musing, not observation)
09:31:46 <pejo> augustss, are you actively working on ghc, or just fixing things that you need for work?
09:31:48 <augustss> sorear: true, but you could still do a good job.
09:32:01 <augustss> pejo: I just fix things I need for work.
09:32:16 <sorear> uccus: what if you have 2 arrays?  then uniqueness types are 2-threaded, monads are 1-threaded.
09:32:19 * augustss would like to be able to write C code in the ST monad and get C speed.
09:33:04 <earthy> sorear: not necessarily true
09:33:05 * sorear still thinks uniqueness types are disgustingly low level and instead we should find a better replacement for the monad abstraction
09:33:20 * augustss agrees
09:33:37 <uccus> can only be decided by experimentation
09:33:58 <earthy> well, the great big experiment hits that GHC does almost as well as Clean
09:34:04 <earthy> hitns
09:34:06 <earthy> hints
09:34:10 <earthy> (damn my typing)
09:34:21 <uccus> earthy: which big experiment?
09:34:23 <earthy> that would suggest that uniqueness doesn't gain you quite as much as you'd like
09:34:33 <sorear> monads save your life every day, like seatbelts.  I'd rather have an airbag.
09:34:41 <sorear> (less broken bones, etc)
09:34:57 <earthy> uccus: you can get almost any program to be as vast in GHC (6.6) as you can get in Clean
09:35:01 <earthy> fast
09:35:18 <sorear> can clean make programs as vast as ghc? :)
09:35:20 <glguy> ?shootout
09:35:21 <lambdabot> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=all
09:35:27 <earthy> sorear: yes, it can. ;)
09:35:30 <uccus> earthy: by heavy strictness annotations?
09:35:43 <earthy> uccus: by judicious use of seq and unboxing
09:35:51 <earthy> Clean just makes it a shitload easier
09:35:53 <sorear> earthy: without CPP-style macro expansion?
09:35:58 <uccus> but... that's... so... unhaskellish!
09:36:03 <sorear> that's vast with a v!
09:36:16 <earthy> sorear: yes, even without CPP macro expansion :)
09:36:26 <earthy> never saw clean 0.5, did you? :)
09:36:52 <earthy> (to be fair, clean started out as in intermediate language to use in the compilation of miranda)
09:36:55 <sorear> earthy: never seen any up close :(
09:37:08 <uccus> sorear: can you please please look at the current scorecard of the shootout?
09:37:30 <sorear> I figured it was hard to bead a compiler that statically links most of an OS with every executable.
09:37:31 <augustss> holy crap!  Icon is above ghc?
09:37:32 * emu is pretty happy with GHC's performance in the ST monad
09:38:01 <sorear> We need a better shootout.
09:38:01 <emu> also toggling -O2 gave me even more gains, when I was already satisfied
09:38:24 <uccus> sorear: I think you mean we need a better shootout score ;)
09:38:25 <sorear> Announce a problem, wait one week, publish fastest solution received in each language.
09:38:26 <apfelmus> augustss: a formulation of strictness with !-annotations would have the benefit that the strictness can be tracked throw functions that where not intended to do so. f.i. i think that simply supllying an (!Int) to a foldl would be equivalent to (foldl')
09:38:38 <hpaste>  yaxu pasted "Is this sane?" at http://kakapo.scannedinavian.com:8000/20
09:39:05 <augustss> apfelmus: Yes, there would be advantages, no doubt.
09:39:27 <chessguy> pardon my split personality
09:39:50 <yaxu> in particular, i'm putting two types in the same list using Either
09:40:03 <yaxu> seems long winded when the types are of the same class
09:40:16 <uccus> yaxu: that's the standard way of doing it, as far as I understand
09:40:17 <yaxu> making subDuration seem odd
09:40:39 <yaxu> uccus: ok fair enough :)
09:40:42 <apfelmus> augustss: and it can be used to restore parametric seq :: !a -> b -> b. the trick is that we don't have a force :: forall . a -> !a
09:41:12 <augustss> yaxu: Why do you have the type Structure?  I mean the Split between Structure and Substructure.
09:41:36 <uccus> confusion: why is it told that seq breaks parametricity? parametricity in what sense?
09:41:37 <allbery_b> yaxu: so, why not just have an Atom be a possible element of a Structure, instead of using the Either?
09:41:42 <apfelmus> i mean no force :: forall a . a -> !a, only
09:41:43 <apfelmus> force :: Seq a => a -> !a
09:41:50 <earthy> anyway, dblhelix is the one to pressure about this stuff. ;)
09:42:07 <augustss> apfelmus: hmmmm, ok.  sounds interesting
09:42:14 <yaxu> allbery_b: you mean merge the Atom and Structure data types?
09:42:19 <apfelmus> uccus: foo :: a -> b -> b. may not inspect it's first argument.
09:42:35 <uccus> inspect?
09:42:48 <augustss> uccus: use in any way
09:42:56 <uccus> but seq does... always?
09:42:57 <allbery_b> not merge, incorporate --- at least if it's useful to manipulate Atoms by themselves.
09:43:07 <apfelmus> uccus: "force". look, (bar :: a -> b) must be _|_ because of its type
09:43:07 <allbery_b> data Atom = ...
09:43:23 <allbery_b> data Structure = Atomic Atom | ...
09:43:38 <allbery_b> (pick some sensible constructor name there)
09:43:52 * augustss agrees with allbery_b 
09:43:58 <allbery_b> introducing an Either just seems like an overly verbose way of doing that
09:44:17 <uccus> apfelmus: I'm sorry I didn't get your argument. I see no (a -> b) here.
09:44:43 <uccus> it's a -> (b -> b), right?
09:45:05 <yaxu> allbery_b: yes that seems much cleaner, i'll try that out thanks!
09:45:43 <apfelmus> uccus: yes, but this is not very different. look, you are supposed to be apply to supply any a. i mean, foo may not inspect whether a is an Int are a Bool or something like that.
09:46:10 <sorear> what, it can't be unsafeCoerce# ?
09:46:12 * sorear ducks
09:46:29 <uccus> I understand that. but seq means you have to, regardless of what its type means?
09:46:42 <augustss> uccus: you can prove that any function you can define in pure lambda calculus with type 'a->b->b' cannot use its first argument.  This is not true for seq.  This means than some properties that hold for pure lambda calculus no longer hold with seq.
09:46:51 <uccus> yep!
09:46:55 <uccus> understood!
09:47:15 <emu> pure -- simply typed
09:47:26 <uccus> so that's what it means by 'breaking parametricity'?
09:47:47 <augustss> uccus: and these properties and good one.  for instance they are used to prove that the foldr/build transformation in ghc is correct
09:48:01 <uccus> can (a -> a) in general have any other inhabitant than id?
09:48:10 <uccus> augustss: I understand that
09:48:12 <apfelmus> uccus: _|_
09:48:17 <augustss> uccus: it refers to Reynold's parametricity theorem.  a.k.a. theorems for free
09:48:48 * uccus hates bottoms popping up everywhere
09:48:53 <yaxu> allbery_b++
09:49:13 <augustss> yes, we need to keep _|_ reigned in.  just like IO
09:49:25 <uccus> fair enough
09:49:53 <uccus> so, apart from bottom, which is common to all the types, the only other member of (a -> a) [unconstrained] is id?
09:50:00 <augustss> yes
09:50:12 <ski> @free a -> b -> b
09:50:13 <lambdabot> Extra stuff at end of line
09:50:31 <augustss> @free seq
09:50:33 <lambdabot> f . seq x = seq (g x) . f
09:50:42 <apfelmus> augustss: and i think that with !, you don't need a polymorphic seq anyway. for every monomorphic type you know beforehand, a type class (Seq) is enough as you don't have to annotate extra class contexts in a monomorphic setting. in the critical case where your function is polymorhpic (like foldl'), you just don't introduce anything because the strictness is provided by the unboxed type (like !Int) supplied.
09:50:57 <uccus> and (a -> b -> a) only has const? apart from _|_?
09:51:05 <augustss> uccus: yes
09:51:28 <uccus> any other "canonical" inhabitants for types?
09:51:41 <uccus> (a) has _|_ and _|_ only?
09:51:48 <augustss> yes
09:51:58 <uccus> so, any other?
09:52:10 <apfelmus> uccus: (a -> a -> a) ~= Bool
09:52:10 <augustss> a->a->a has exactly two (non-bottom) inhabitants
09:52:20 <uccus> fix?
09:52:31 <emu> thats (a->a)->a
09:52:33 <apfelmus> @type fix
09:52:35 <lambdabot> forall a. (a -> a) -> a
09:52:49 <paolino> does dist directory be under darcs ?
09:52:52 <uccus> a->a->a has const and id?
09:53:02 <uccus> nope, that doesn't really...
09:53:10 <augustss> btw, uccus, note that the free theorem for seq is not true
09:53:11 <ski> > let f = id; g = const () in (f . seq x) ()
09:53:12 <ski> > let f = id; g = const () in (seq (g x) . f) ()
09:53:12 <lambdabot>   Not in scope: `x'
09:53:13 <lambdabot>   Not in scope: `x'
09:53:25 <ski> > let f = id; g = const (); x = undefined in (f . seq x) ()
09:53:27 <lambdabot>  Undefined
09:53:32 <ski> > let f = id; g = const (); x = undefined in (seq (g x) . f) ()
09:53:33 <lambdabot>  ()
09:53:34 <uccus> a->a->a has one member (const id)
09:53:35 <allbery_b> paolino: not that I've ever seen in a darcs repo
09:53:44 <uccus> what's the other one?
09:53:47 <allbery_b> it's created by the cabal infrastructure
09:53:56 <allbery_b> when you build
09:53:57 <EvilRanter> @pl \x y -> x
09:53:57 <lambdabot> const
09:54:01 <EvilRanter> @pl \x y -> y
09:54:01 <paolino> uccus: but docs are builded there
09:54:02 <lambdabot> const id
09:54:03 <augustss> uccus: a->a->a can return the first or second argument
09:54:27 <emu> tru and fls
09:54:28 <allbery_b> the docs are gnerated from the source
09:54:36 <apfelmus> augustss: in short, i think that with !-annotations, the call-site must specify the strictness and not the callee.
09:54:36 <allbery_b> generated files are not normally stored in the repo
09:54:37 <uccus> @type (const id)
09:54:39 <lambdabot> forall a b. b -> a -> a
09:54:44 <uccus> aah
09:54:48 * uccus ducks
09:55:01 <ski> :t flip const
09:55:03 <lambdabot> forall a b. b -> a -> a
09:55:07 <paolino> ok
09:55:08 <apfelmus> uccus: why, just take a = b
09:55:23 <augustss> @djinn a->a->a
09:55:24 <lambdabot> f _ a = a
09:55:40 <ski> @djinn a -> Either a a
09:55:41 <lambdabot> f = Left
09:55:47 <uccus> sad
09:55:50 <augustss> lol
09:55:58 <EvilRanter> @type asTypeOf
09:55:59 <lambdabot> forall a. a -> a -> a
09:56:09 <augustss> uccus, so I think (.) is the only element of that type
09:56:27 <ski> @djinn (forall a. (a,a) -> a) -> Bool
09:56:28 <lambdabot> f _ = False
09:56:37 <ski> bah
09:56:46 <EvilRanter> the bot cheated
09:56:52 <augustss> djinn doesn't understand forall at all
09:56:58 <uccus> what's the type of the s combinator again?
09:57:02 <glguy> > 16 ^ 3
09:57:04 <lambdabot>  4096
09:57:08 <ski> i thought it was supposed to be as relevent as possible, or something like that
09:57:09 <uccus> s x y z = (x z) (y z)?
09:57:19 <ski> yes
09:57:20 <uccus> how do I ask lambdabot?
09:57:25 <apfelmus> >
09:57:26 <augustss> :t \ f g x -> (f x) (g x)
09:57:27 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t1 -> t) -> t1 -> t2
09:57:31 <emu> @djinn ((p->q)->p)->p
09:57:31 <lambdabot> -- f cannot be realized.
09:57:53 <apfelmus> @help
09:57:54 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
09:58:05 <augustss> @djinn (t1 -> t -> t2) -> (t1 -> t) -> t1 -> t2
09:58:06 <lambdabot> f a b c = a c (b c)
09:58:12 <apfelmus> @list -- uccus
09:58:13 <uccus> @djinn (a -> b -> c) -> (a -> b) -> (b -> c)
09:58:13 <lambdabot> No module "-- uccus" loaded
09:58:14 <lambdabot> -- f cannot be realized.
09:58:28 <apfelmus> @list
09:58:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:58:37 <uccus> thanks
09:58:55 <uccus> argh. no doc which does what
09:59:13 <ski> @djinn (Not p -> NotNot p) -> NotNot p
09:59:14 <lambdabot> f a b = void (a b b)
09:59:23 <ski> @djinn ((p -> q) -> NotNot p) -> NotNot p
09:59:23 <lambdabot> f a b = void (a (\ c -> void (b c)) b)
09:59:29 <emu> @type void
09:59:30 <lambdabot> Not in scope: `void'
09:59:44 <apfelmus> @help version
09:59:45 <lambdabot> version/source. Report the build date, ghc version and darcs repo of this bot
09:59:55 <ski> void :: Void -> a
09:59:56 <apfelmus> uccus: /query lambdabot
10:00:03 <augustss> @djinn-env
10:00:04 <lambdabot> data () = ()
10:00:04 <lambdabot> data Either a b = Left a | Right b
10:00:04 <lambdabot> data Maybe a = Nothing | Just a
10:00:04 <lambdabot> data Bool = False | True
10:00:04 <lambdabot> data Void
10:00:04 <uccus> ok
10:00:06 <lambdabot> type Not x = x -> Void
10:00:07 <ski> void v = case v of { }
10:00:08 <lambdabot> type NotNot a = Not (Not a)
10:01:11 <augustss> ski: stupid H98 doesn't allow case v of { }.  It should :)
10:01:18 <ski> agree
10:01:35 <augustss> well, it doesn't allow 'data Void' either
10:01:44 <ski> (but, iirc, 'data Void' isn't H98 either .. correct ?)
10:01:55 <ski> ok
10:01:57 <apfelmus> augustss: you can always use undefined :)
10:02:04 <ski> cheating !
10:02:05 <augustss> both should be allowed.  I argued for it, but no one listened
10:02:29 <augustss> apfelmus: undefined is not the right thing
10:02:47 <apfelmus> case v of {}=/= undefined ?
10:02:51 <augustss> you can always use undefined for everything
10:03:21 <apfelmus> ?
10:03:33 <EvilRanter> @type undefined
10:03:34 <lambdabot> forall a. a
10:03:41 <augustss> apfelmus: well, i'd like what i write to be valid in a language without bottom
10:03:47 <EvilRanter> so @djinn could just reply "undefined" to everything
10:03:49 <ski> 'void' is logically vvalid, 'undefined' isn't
10:04:03 <augustss> exactly
10:04:42 <augustss> EvilRanter: I should make an improved djinn that always answers undefined
10:05:19 <apfelmus> ah, you mean foo :: Void -> Int; foo v = case v of {}. i see. but Void = (forall a . a) with rank-2-types
10:06:02 <augustss> forall a . a is one way to write the empty type, yes
10:06:13 <ski> church encoding
10:06:29 <pejo> augustss, why is it an advantage to have code you write valid in a different language?
10:06:30 <augustss> In a language with data types I like 'data Void'
10:07:56 <augustss> pejo: because I prefer not to use bottom.  It's never really what you want, but it's something we live with at the moment.  So by writing it in a way that's valid without bottom I can see that I've not introduced bottom just by mistake.
10:08:51 <apfelmus> augustss: mh, that's something for physicists :) after all, you have the creation / annihilation operators a :: n -> Succ n; and a' :: Succ n -> n ...
10:09:01 <apfelmus> and it all started with Void
10:09:56 <apfelmus> pejo: a strongly normalization language is "more logical"
10:11:58 <augustss> apfelmus: I don't like a'.  Not if we have Zero
10:12:14 <pejo> apfelmus, and more terminating?
10:12:31 <ski> apfelmus : hm .. wouldn't the value / continuation duality be more alike creation / annihilation ?
10:12:40 <apfelmus> pejo: as in "terminator", yes :)
10:13:28 <apfelmus> ski: that's for fermions...
10:13:51 <apfelmus> for it's only dual not multi
10:14:10 <ski> hm .. can you elaborate on what you mean ?
10:15:44 <apfelmus> ski: well, fermions can only take the quantum states 0 and 1 (in the Fock space), just like A and (A -> b -> b). but there is no 2 or so
10:16:12 <apfelmus> augustss: Zero?
10:17:28 <ski> do you mean '(A -> b) -> b' ?
10:19:10 <apfelmus> err, of course.
10:22:46 <mauke> today I rediscovered Catalan numbers
10:30:21 * glguy wonders why the topic has an explicit type declaration
10:31:00 <augustss> huh?
10:31:05 <Saizan> @. run topic-tell #haskell
10:31:07 <lambdabot>  ["The Haskell programming language: get yourself some cognitive dissonance!"...
10:31:34 <ndm> that is even more horrible that it used to be!
10:31:38 <augustss> ah
10:31:46 <ndm> the " and [] are quite horrible on their own
10:31:55 <augustss> i think that's appropriate for a strongly types language ;)
10:32:08 <Saizan> someone complained about the topic formatting, so dons dediced to make it typecheck :D
10:32:28 <ndm> dons made the wrong decision, that just shows that Haskell is too stupid to produce natural language
10:32:35 <psnl> http://darcs.haskell.org/haskell-prime-report/report/haskell-report-html/exps.html <- why the "Haskell 98" header?
10:32:37 <lambdabot> Title: The Haskell 98 Report: Expressions, http://tinyurl.com/23jekm
10:32:39 <ndm> i.e. it doesn't have an unwords function
10:32:59 <ndm> psnl: they are slowly changing bits of it, one by one
10:33:12 <TomMD> Are there any plans to make the darcs project registration not require a human operator?
10:33:14 <ndm> my question is why the ugly lambda background for the HTML version, its very 1995's
10:33:19 <ndm> TomMD: no
10:33:36 <ndm> TomMD: unless you have a haskell.org account, in which case you can be your own human operator
10:33:49 <TomMD> That works for me.
10:37:35 <emertens> !paste now with 25% more columns
10:37:36 <hpaste> Haskell paste bin: http://kakapo.scannedinavian.com:8000/
10:39:15 <fatalis> kinda ugly, though
10:39:38 <emertens> complaints can be submitted in .dpatch format
10:41:07 <fatalis> nobody's complaining, it's an observation
10:42:48 <emertens> Saizan: rety
10:42:51 <emertens> retry
10:43:22 <Saizan> not related to columns
10:43:22 <emertens> i disabled the filter permanently
10:48:50 <emertens> annotationId used to be computed before saving the annotation
10:52:50 <kolmodin> ndm: how is your Catch application comming along, I think two days has passed since we spoke about it last time :)
10:57:46 <sorear> tell fodder
11:07:07 <glguy> slow day
11:07:14 <Axioplase> Hi. how comes when I declare some vars in a file, they aren't accessible from inside a function declared in the same file ?
11:07:20 <Axioplase> argh.. wrong chan sorry
11:07:48 <glguy> what channel was that meant for?
11:07:55 <sorear> @seen Axioplase
11:07:56 <lambdabot> Axioplase is in #haskell. I last heard Axioplase speak 35s ago.
11:08:02 <mauke> or rather, what language? :-)
11:08:24 <sorear> apparently, a top secret one.
11:08:25 <sorear> 11:04 -!-  channels : #haskell
11:08:44 <allbery_b> just not one high class enough to have lambdabot :)
11:08:46 <mauke> hmm, could be php, python or javascript
11:08:53 <mauke> (implicit scoping)
11:09:08 <sorear> are any of those secretive enough to have +s ?
11:09:13 <mauke> no, wait; javascript is just broken, not implicit
11:09:57 <EvilRanter> could be perl, too
11:10:03 <sorear> /help mode says I meant +p, sorry
11:10:37 <mauke> no, perl has explicit scoping
11:10:53 <EvilRanter> with -Mstrict it does
11:11:23 <mauke> even without strict you won't get implicitly local variables
11:11:33 <sorear> python?
11:11:37 <EvilRanter> are they implicitly global?
11:11:43 <mauke> yes
11:11:48 <EvilRanter> i always use strict, so I wouldn't know
11:11:53 <sorear> python's variables are implicitly local if written to
11:12:04 <sorear> I always use haskell, so I wouldn't know :)
11:12:39 <mauke> 'strict' doesn't disable implicitness; it just requires the use of full names for globals
11:14:06 <glguy> ?teens
11:14:07 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
11:14:12 <glguy> lol
11:14:33 <earthy> ?seen
11:14:34 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
11:14:37 <earthy> whea
11:14:46 <earthy> neat
11:14:47 <earthy>  :)
11:14:48 <Botje> aw, that's mean
11:15:30 <glguy> yeah, sucks that people made dons change that
11:15:35 <sorear> hey, if dons gets to make excuses about coding drunk, I get to make excuses about coding while unhealthily frustrated :)
11:15:46 <augustss> What happens with these massively broken clients?
11:15:51 <sorear> augustss: they beep.
11:15:56 <glguy> people that use clients that don't support /filter
11:16:00 <augustss> bah.
11:16:09 <glguy> and then they complain about it for a whole day
11:16:35 <sorear> so I sent a patch, and vented into a string literal.
11:17:03 <augustss> we can't cater for all broken software out there
11:17:10 <sorear> now they can complain about lambdabot's attitude problems :)
11:17:38 <monochrom> How about passing @seen through @elite ?
11:17:43 <augustss> sorear: lambdabot has a great attitude
11:17:58 <glguy> monochrom: that works fine: @. elite seen
11:18:04 <glguy> so if anyone wants that output, they can generate it
11:18:08 <monochrom> I mean implicitly
11:18:11 <glguy> ew
11:18:13 <mauke> @. elite teen
11:18:14 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "teen"
11:18:30 <earthy> @. elite teens
11:18:30 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "teens"
11:18:33 <glguy> lol
11:18:37 <earthy> what the?
11:18:41 <sorear> it prrobably won't work.
11:18:57 <sorear> @. elite seen
11:18:58 <lambdabot> du3 70 t|-|3 exI$74nC3 Of m4zsIV3LY bROKen IR( C|IEN+5, i wi1| N0t anSw3R you in (|-|aNNE|.
11:19:12 <earthy> works perfectly. :)
11:19:14 <allbery_b> composition doesn't do edit distances
11:19:26 <sorear> composition doesn't fudge targets
11:20:22 <pejo> sorear, why not have lambdabot silently respond in private?
11:20:59 <glguy> why not have people properly configure their irc clients?
11:21:04 <glguy> these are good questions
11:21:25 <monochrom> why not have people think before they use lambdabot?
11:21:35 <glguy> why not have people properly configure their irc clients?
11:21:38 <allbery_b> because he wants to tweak folks who think it's inappropriate to have to reprogram their clients to live with lb
11:21:54 <arcatan> how the irc clients are broken?
11:22:40 * allbery_b *wants* to know when someone pings him.  just not when @seen does it
11:23:43 <allbery_b> and no, it's not quite ppropriate for "oh, there's a special bot here,m I need to find out how to specially filter it"
11:23:44 <monochrom> why not have people configure their irc clients to automatically discard abusive things and pass through legit things?
11:23:51 <glguy> ?google xchat /filter
11:23:54 <lambdabot> http://www.preshweb.co.uk/linux/scripts/xchat-filter-messages/
11:23:54 <lambdabot> Title: XChat Filter Messages (Perl script for xchat)
11:24:06 <monochrom> ?google computational undecidability
11:24:09 <lambdabot> http://en.wikipedia.org/wiki/Decision_problem
11:24:09 <lambdabot> Title: Decision problem - Wikipedia, the free encyclopedia
11:24:10 <allbery_b> and no, it's not quite appropriate for "oh, there's a special bot here, I need to find out how to specially filter it"
11:24:25 <arcatan> what's wrong with seen?
11:24:49 <glguy> maybe we could just have a ?seen-opt-out
11:24:55 <glguy> I'd submit that patch
11:24:56 <arcatan> I mean, don't people want to know if someone is looking for them
11:25:04 <allbery_b> without parameters it announces everyone it's seen active in the past <x> time (4 hours?)
11:25:16 <arcatan> oh
11:25:20 <sorear> pejo: it does reply in private - when you say @seen, the bot harrases you in channel and sends private messages with the real answer.
11:25:20 <allbery_b> with a channel parameter it announces everyone present in the channel
11:25:30 <allbery_b> (or used to)
11:25:34 <sorear> allbery_b: 15 minutes for @seen  (@users is the 4h one)
11:25:46 <sorear> allbery_b: still does, but the same filter applies
11:25:54 <sorear> @seen #haskell
11:25:57 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
11:26:19 <sorear> (as 6 lines of usernames appear in window 8)
11:27:36 <monochrom> "Avoid success at all cost" is word of wisdom.  OK maybe not "at all cost".
11:29:49 <sorear> ok, who's up for dismantling #haskell? :)
11:30:18 <monochrom> I am, so soon as shapr and dons approve me to scare away newbies.
11:30:53 <monochrom> s/so/as/
11:33:15 <glguy> sorear: lol, when did you change to n=root? :-D after yesterday?
11:33:49 <augustss> and were are all the newbies anyway?  i've not seen any newbie questions in days
11:34:04 <mbishop> @protontorpedo
11:34:05 <lambdabot> I got some info b 4 about how lazy eval makes macros not needed please expand...
11:34:23 <psnl> @keal
11:34:24 <lambdabot> intuitive != imperative
11:34:24 <Korollary> that's a legitimate question
11:34:53 <monochrom> yes absolutely.
11:35:10 <sieni> @sieni
11:35:11 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
11:35:17 <sorear> @smerdyakov
11:35:17 <lambdabot> Unknown command, try @list
11:35:20 <augustss> @keal
11:35:20 <lambdabot> write an algorthim that generates the correct responses for a phone survey based on number of rings whether answered how quickly hung up on and the mood of the receiver
11:35:28 <sorear> @quote smerdyakov
11:35:29 <lambdabot> No quotes match. I feel much better now.
11:35:29 <monochrom> Recall: there is no illegit question, just illegit people.  prontotorpedo was illegit.
11:35:59 <augustss> @protontorpedo
11:36:00 <lambdabot> what is the best absolute beginner utorial for haskell?
11:36:04 <Korollary> yeah but that context is not captured by a single quote.
11:36:17 <monochrom> right. I saw the context.
11:36:17 <sorear> glguy: after yesterday.  I want to see how long it takes for me to be banned/killed.
11:36:51 <sorear> I've heard stories of this Smerdyakov guy - maybe we should try and get him back?
11:37:46 <Korollary> Would it be better if every bit of syntactic sugar in haskell was implemented using TH instead?
11:38:01 <sorear> hehehe
11:38:31 <monochrom> Too many $()'s
11:38:32 <vegai> sorear: You should be using Standard ML for everything
11:38:35 <sorear> liskell + TH + some crazy mixfix scheme = haskell?
11:38:53 <sorear> vegai: I'm too lazy.
11:39:04 <ctkrohn> sorear: haha, I used to hang out on a different IRC channel where he frequented... smart guy
11:39:14 <ctkrohn> big fan of SML though its true
11:40:13 <Axioplase> mauke: yep, that was (hated) php scoping problem...
11:41:15 <mauke> @karma+ psychic debugging
11:41:16 <lambdabot> psychic's karma raised to 1.
11:41:23 <mauke> argh
11:41:24 <mauke> @karma- psychic
11:41:25 <lambdabot> psychic's karma lowered to 0.
11:41:28 <freakazoid> Wow, by number of people in the channel Haskell is almost 80% as popular as Python
11:41:38 <Korollary> we're just more social
11:41:42 <freakazoid> Oh
11:41:47 <augustss> Korollary: how could you implement the syntactic sugar in TH?  TH has the same syntax inside the brackets as regular haskell
11:41:48 <Korollary> feel the karma love
11:41:51 <earthy> and effective. ;)
11:42:05 <monochrom> You don't need a channel to learn Python.
11:42:20 <freakazoid> Dammit, hype the language
11:42:34 <Korollary> augustss: actually, I don't even know TH. I was asking in principle.
11:42:58 * earthy wonders if that is true however
11:43:04 <augustss> Korollary: So currently the answer is that it would be impossible to do it in TH. :)
11:43:20 <earthy> TH allows one to do transformations on the parsed haskell
11:43:25 <earthy> not change the parsing
11:43:30 <augustss> right
11:43:39 <freakazoid> Kind of like macros in CL or Scheme?
11:43:43 <earthy> you'd need syntax macros for that.
11:43:53 <Korollary> can you transform >>='s into do notation with TH?
11:44:02 <earthy> no
11:44:09 <augustss> sometimes i wish for syntax macros.  but most of the times i'm thankful there are none
11:44:17 <earthy> you can transform >>='s into the parsed version of do notation
11:44:32 <earthy> which is >>='. :P
11:45:04 <earthy> yeah, syntax macros look like a good idea
11:45:08 <sorear> augustss: How about user defined (lazy, higher-order, polymorphic) mixfix functions ... if could die
11:45:14 <earthy> until you start using them in large programs
11:45:14 <ctkrohn> hey, I'm trying to build takusen on my machine but keep getting an error: Could not find module `Distribution.Compat.FilePath': it is hidden (in package Cabal-1.1.6).  I just installed the latest cabal... any idea on what could be going on?
11:45:33 <augustss> earthy: actually, that's not true.  TH has special constructors for do.
11:45:46 <sorear> ctkrohn: apparently takusen forgot to declare a dependency on cabal?
11:45:49 <earthy> it does?
11:45:56 <earthy> I wouldn't expected it to
11:45:58 <earthy> +have
11:46:08 <augustss> sorear: mixfix, maybe.  very maybe
11:46:14 <sorear> ctkrohn: cabal is the only build system that actually does something about undeclared dependencies.
11:46:18 <ctkrohn> sorear: so should I just add cabal to the "requires" line or whatever in the .cabal file?
11:46:21 <earthy> I'd have expected TH to be above the level of sugar
11:46:32 <ctkrohn> build-depends line, rather
11:46:38 * sorear goes and adds an alias for cabal-does-something-about-undeclared-deps
11:46:45 <augustss> earthy: TH pretty much just parsed haskell
11:46:55 <sorear> ctkrohn: that's what I'd try first
11:46:57 <earthy> much like in Language.Haskell then
11:47:04 <earthy> (which is somewhat icky to deal with)
11:47:25 <augustss> sometimes I wish I could make my own binding constructs.  that's when i want macros
11:47:27 <sorear> ctkrohn: (beware, maturish software doesn't usually break in only one place ...)
11:47:38 <sorear> augustss: binding, like \ ?
11:47:41 <ctkrohn> sorear: ok so now the line looks like "Build-Depends:  base, mtl, time, cabal" but it's still not working
11:47:49 <augustss> sorear: and <-
11:48:05 <sorear> ctkrohn: changes to .cabal are only visible after reconfiguring
11:48:23 <ctkrohn> well the thing is, it won't even let me do runghc Setup.hs configure
11:48:30 <ctkrohn> thats wheret he error appears
11:48:34 <sorear> oh
11:48:51 <sorear> in that case, ghc-pkg expose cabal
11:49:00 <sorear> no idea why it was hidden...
11:49:28 <ctkrohn> it says it can't find package cabal... weird, since I just installed it
11:49:36 <ctkrohn> er, wait a second
11:49:38 <sorear> augustss: I had an idea a while back.  I'm pretty sure \ itself can be typed using implicit params and dependent types
11:50:05 <sorear> ctkrohn: you might need to specify cabal-1.1.6 - I haven't used that command in a while
11:50:18 <ctkrohn> alright... I'm going to play around with things for a second
11:50:23 * augustss shudders at the thought of implicit params
11:51:00 <augustss> sorear: let's not make something simple like \ into something complicated. :)
11:51:02 <sorear> augustss: something like \ :: |~| name :: String -> ((?name :: a) => b) -> (a -> b)
11:51:39 <augustss> sorear: it is cute, I admit :)
11:51:45 * sorear has never written a pi-abstraction before, and probably mangled it beyond recognition
11:53:00 <freakazoid> Is there no Sep2006 package of hugs for Debian or Ubuntu?
11:53:13 * sorear checks
11:53:16 <freakazoid> the latest package appears to be from March 2005
11:53:45 <augustss> but it's not quite the right type, I mean, name is not a String
11:54:08 <sorear> augustss: you don't want perl barewords as a type, do you? :)
11:55:01 <freakazoid> or should I be using GHCi instead of hugs?
11:55:03 <augustss> sorear: I don't want \ (or something like it) to be broken down any further at all
11:58:53 <Korollary> freakazoid: get ghc if you don't have a particular reason to use hugs
11:59:14 <freakazoid> Korollary: Ok I will thanks
11:59:30 <freakazoid> Korollary: I was just looking for an interactive environment and didn't realize GHC had one
11:59:55 <augustss> ghci is nicer than hugs in most ways
12:00:06 <augustss> ghci is still deficient, imo
12:01:06 <Korollary> augustss should hack on ghc some
12:01:33 <augustss> Korollary: I'm waiting for my overloaded string hack to be merged
12:02:08 <sorear> ghci (debian) is much newer ... hugs is too old to run just about anything beyond h98, ghci-6.6 is new enough to be slightly incompatible with much software (most commonly manifesting as "cannot satisfy dependency: fps-any")
12:02:19 <augustss> and then i need to clean up my record shorthand patch
12:02:39 <Korollary> augustss: what's an overloaded string?
12:02:49 * freakazoid compiles ghc6 6.6-3 for Edgy
12:02:50 <sorear> "foo" :: ByteString i beelieve
12:02:55 <augustss> Korollary: overloaded string literals
12:03:06 <sorear> like :t 1 is Num a => a
12:03:11 <augustss> "foo" :: (IsString a) -> a
12:03:11 <sorear> "foo" is String a => a
12:03:18 <Korollary> ah I get it
12:03:38 <augustss> class IsString a where fromString :: String -> a
12:03:48 <Korollary> so what methods does this class have?
12:03:51 <sorear> instance IsString [Char] where fromString = id
12:03:58 <augustss> yep
12:03:58 <sorear> instance IsString ByteString where fromString = pack
12:04:10 <sorear> hmm
12:04:25 <sorear> class IsString a where fromString :: Addr# -> a
12:04:30 <sorear> instance IsString ByteString where fromString = packAddress
12:04:31 <sorear> ?
12:04:45 <freakazoid> ghc6 has a build dependency on ghc6?
12:04:47 <augustss> Addr#?  that looks horrible
12:05:10 <allbery_b> freakazoid: ghc is written in ghc, yes.  you need some version of ghc to build from source
12:05:19 <sorear> freakazoid: no, ghc6 should build with ghc5.04
12:05:24 <freakazoid> should I use 6.4, build 6.6, install it, then build again?
12:05:30 <sorear> freakazoid: no!
12:05:32 <mauke> instance (IsChar a) => IsString [a] where
12:05:38 <freakazoid> sorear: ok I have 6.4 available
12:05:44 <sorear> freakazoid: make does a full bootstrap automatically
12:05:44 <allbery_b> better is to install a binary package :)
12:05:50 <augustss> mauke: yes, for H98 you'ds need that
12:05:51 <sorear> freakazoid: don't "build again"
12:05:57 <freakazoid> sorear: oh, I should have guessed that
12:06:06 <freakazoid> allbery_b: I would, if there were one for edgy
12:06:19 <sorear> freakazoid: there is one binary to rule them all
12:06:21 <allbery_b> alien :)
12:06:30 <sorear> freakazoid: Linux/i386, any distro
12:06:43 <allbery_b> turn an rpm into a deb, go nuts
12:06:52 <freakazoid> sorear: but porting a debian package to ubuntu is typically trivial
12:06:57 <sorear> freakazoid: Edgy doesn't have 6.6?
12:06:59 <freakazoid> sorear: and I prefer not to install stuff that's not in packages
12:07:05 <sorear> freakazoid: 6.6 is in debian unstable
12:07:07 <freakazoid> sorear: Oh maybe I should have checked feisty
12:07:11 <sorear> freakazoid: has been for months
12:07:16 <freakazoid> I only checked edgy-backports
12:07:24 <freakazoid> sorear: Yes, i'm compiling the Debian source package on Edgy
12:08:14 <freakazoid> Oh, 6.6 is in Feisty
12:08:38 * freakazoid ponders... upgrade to Feisty or backport it
12:08:46 <sorear> what is feisty?
12:08:53 <freakazoid> next release of Ubuntu
12:11:53 <mahogny> plz stop using lame name for distros. numbers oughta be enough for everyone :(
12:12:02 <freakazoid> I don't name them
12:12:08 <mahogny> no. but they do :/
12:12:21 <freakazoid> it's 6.11, but good luck finding anything by that via google
12:12:39 <mahogny> you type in their url. bypass google :)
12:12:40 <freakazoid> they're alphabetical, and it's a hell of a lot easier to do searches by lame names
12:13:03 <freakazoid> their web site is not the only site that talks about ubuntu
12:13:18 <freakazoid> anyway Debian does the same thing
12:14:04 <mahogny> cancer easily spreads. anyway, it kind of defeats the purpose of version numbers. they might as well stick to one scheme
12:14:15 <sorear> @google "Debian 3.0"
12:14:19 <lambdabot> http://www.debian.org/
12:14:20 <lambdabot> Title: Debian -- The Universal Operating System
12:14:39 <freakazoid> I'm not gonna argue about it
12:14:47 <sorear> not as convincing as I thought it would be :(
12:15:05 <SyntaxNinja> w00t
12:15:15 <sorear> ok good.  we could do with fewer non-haskell debates here :)
12:15:26 <jcreigh> Debian does version numbers and code names.
12:15:35 <freakazoid> just like Ubuntu
12:15:42 <SyntaxNinja> I don't think I've ever heard of anyone using Debian's version numbers :)
12:15:42 <jcreigh> 3.1 is sarge, 4.0 will be etch.
12:15:43 <freakazoid> woah, Jason
12:15:46 <freakazoid> I didn't know you were into Haskell
12:15:57 <jcreigh> freakazoid: heh, it's a small world.
12:17:30 <freakazoid> is it fairly easy to export a C interface with GHC?
12:17:43 <freakazoid> I want to call Haskell code from Python using ctypes
12:18:13 <mahogny> you have to call a few RTS functions to call haskell code IIRC. otherwise rather simple
12:18:13 <sorear> freakazoid: have you seen MissingPy
12:18:22 <dcoutts> @yarr!
12:18:22 <lambdabot> Well me 'earties, let's see what crawled out of the bung hole...
12:18:29 * dcoutts is back in Oxford
12:18:34 <sorear> freakazoid: it's a high level 'direct' Haskell <-> Python interface
12:18:42 <freakazoid> sorear: awesome
12:18:42 <glguy> dcoutts: wb
12:18:43 <_matthew-> how would you go about tracking down a memory leak?
12:18:48 <sorear> wlcome back!
12:18:53 <sorear> _matthew-: top(1)
12:18:56 <freakazoid> sorear: though it's a bit scary to me when the top hit for the name is the Debian package of it
12:19:01 <dcoutts> @tell dons I've got a writeN/writeN rule firing, at least in an experimental context
12:19:02 <lambdabot> Consider it noted.
12:19:11 <dcoutts> sorear, glguy: ta :-)
12:19:12 <matthew-_> err, yeah, I *know* it's a memory leak
12:19:15 <freakazoid> Oh, but the docs appear to be reasonably complete
12:19:32 <sorear> freakazoid: the author of MissingMy is a gopherhead and doesn't do WWW. that's why it's not on google.
12:19:39 <glguy> memory leak rather than a space leak?
12:19:46 <freakazoid> sorear: Ok that's weird.
12:19:47 <matthew-_> what's the difference?
12:20:01 <glguy> one is due to not deallocating things
12:20:06 <glguy> one is due to not evalutating things
12:20:14 <matthew-_> mmm. could be either
12:20:24 <matthew-_> I suspect the latter though
12:20:30 <freakazoid> sorear: this looks like the equivalent of boost.python
12:20:31 <dcoutts> matthew-_, I saw a great POPL paper all about how to identify space leaks in garbage collected languages. Someone should implement it for Haskell to help us with space leaks caused by too much or too little strictness.
12:20:36 <glguy> one is a side-effect of lazy evalutation, the other is a bug in the compiler
12:20:38 <freakazoid> sorear: And I am guessing it only works with CPython
12:21:03 * dcoutts is just back from PADL/POPL and bursting with ideas
12:21:05 <freakazoid> sorear: the reason I wanted to use ctypes is because I want to support PyPy
12:21:09 <pejo> dcoutts, have a name or author handy for it?
12:21:25 <dcoutts> pejo, lemme check the proceedings...
12:21:26 <sorear> @seen CosmicRay
12:21:27 <lambdabot> I saw CosmicRay leaving #haskell-blah, #darcs and #haskell 1d 21h 28m 29s ago, and .
12:21:43 <glguy> dcoutts: since you were gone, check out what changed :)
12:21:44 <glguy> @paste
12:21:45 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
12:22:09 <matthew-_> glguy: ok so assume it's not a ghc bug. How would I find the space leak?
12:22:15 <dcoutts> pejo, "Cork: dynamic memory leak detection for garbage-collected languages" by Maria Jump.
12:22:29 <augustss> matthew-_: profile!
12:22:30 <dcoutts> glguy, oh a new paste site?
12:22:39 <matthew-_> ok, am doing as we speak
12:22:39 <glguy> yep
12:22:49 <dcoutts> nice, does it use happs? :-)
12:22:51 <sorear> yep
12:22:56 <dcoutts> cool
12:23:10 <dcoutts> written by shapr?
12:23:15 <sorear> hah.
12:23:19 <augustss> matthew-_: you should read some of the heap profiling papers to get an idea how to go about it
12:23:31 <matthew-_> ok.
12:23:31 <dcoutts> sorear, by you an glguy ? I'm just guessing.
12:23:36 <glguy> dcoutts: me :)
12:23:42 <dcoutts> glguy, cool.
12:23:42 <SyntaxNinja> @shapr-get
12:23:43 <lambdabot> Unknown command, try @list
12:23:44 <jcreigh> freakazoid: MissingPy looks like it can call Python from Haskell, but not Haskell from Python: http://quux.org:70/devel/missingpy/README
12:24:01 <augustss> matthew-_: not that you have to read the papers, but it makes it easier
12:24:04 <sorear> SyntaxNinja:
12:24:09 <sorear> @get-shapr
12:24:10 <lambdabot> shapr!!
12:24:13 <glguy> dcoutts: sorear has been nudging me in his perfered directions through patches and subtle hints
12:24:25 <dcoutts> hia SyntaxNinja, btw you can thank your colleagues for a nice evening the other day. I'm putting up your add to show to my students :-)
12:24:33 <freakazoid> jcreigh: Ah, that would be the opposite of what I'm looking for... I want to talk back and forth via the C calling convention since ctypes supports that in both directions
12:24:43 <dcoutts> glguy, so do you do much with happs generally?
12:24:45 <sorear> Lisppaste has been moving further and further away from links-awareness...
12:24:47 <matthew-_> augustss: I really don't mind reading papers - normally good for the brain ;)
12:24:50 <freakazoid> jcreigh: and every non-toy Python implementation supports ctypes
12:25:03 <pejo> dcoutts, thank you. Interesting.
12:25:05 * freakazoid quietly makes the true scotsman fallacy
12:25:06 <SyntaxNinja> dcoutts: will do
12:25:06 <jcreigh> ctypes is the Python FFI?
12:25:12 <freakazoid> jcreigh: yes.
12:25:30 <sorear> are there toy Python implementations?
12:25:35 <freakazoid> not sure, any more
12:25:36 <augustss> matthew-_: http://www.cs.york.ac.uk/fp/profile.html
12:25:38 <lambdabot> Title: Tracing and Profiling
12:25:38 <sorear> it seems like a rather big language...
12:25:53 <freakazoid> now that PyPy is at 35% of CPython performance and IronPython has passed 1.0
12:25:53 <kolmodin> dcoutts: home, sweet home?
12:26:07 <matthew-_> augustss: tnx
12:26:13 <pejo> dcoutts, (I'll read it tomorrow, but I'll blindly ask anyways) can one reason about spaceleaks now, for a given piece of code?
12:27:09 * glguy remember not to forget Saizan's contribs either
12:27:21 <glguy> dcoutts: this is my first HAppS app
12:27:34 <sorear> ooh glguy it's all nice and columny
12:28:24 <sorear> @seen dons
12:28:25 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 1d 9h 43m 8s ago.
12:28:51 <freakazoid> jcreigh: I should have just asked Google rather than being lazy: http://www.cse.unsw.edu.au/~chak/haskell/ffi/ffi/ffise3.html is what I was looking for
12:28:52 <lambdabot> Title: 3 Foreign Declarations
12:29:06 <freakazoid> thanks, lambdabot
12:29:15 <sorear> freakazoid: @google
12:29:25 <freakazoid> we need you in #sbay.org so Ian stops yelling at me for pasting URLs with no description
12:29:25 <glguy> sorear: yeah.. I caved
12:29:26 <sorear> muahahaha
12:29:28 <dcoutts> pejo, no, but one can pin down with reasonable precision which bit of the code is at fault
12:30:05 * dcoutts -> out
12:30:23 <sorear> freakazoid: you want lambdabot to join #sbay.org ?
12:30:33 <sorear> that can be arranged easily
12:30:40 <freakazoid> sorear: thanks, but it might offend Ian
12:30:51 <freakazoid> sorear: Or heather, who owns the bot that's already in there
12:31:06 <glguy> inferiority complex?
12:31:09 <freakazoid> sorear: Perhaps lambdabot could confer its talents onto xteddy
12:31:24 <dcoutts> oh sorry I didn't see you there, I got a writeN/writeN rule to fire for "putWord8 w1 >> putWord8 w2"
12:31:29 <dcoutts> kolmodin, ^^
12:31:29 <sorear> oh, so xteddy is the python program? :)
12:31:45 <freakazoid> sorear: I would be surprised if it were written in Python
12:31:50 <dcoutts> kolmodin, now I'm really off, talk later if you're still awake :-)
12:32:18 <glguy> sorear: you use "elinks"?
12:32:27 <sorear> glguy: tRUE
12:32:38 <freakazoid> heh. text mode.
12:32:39 * sorear LOATHES cAPS-lOCK
12:32:42 <glguy> how does that relate to lynx and links?
12:32:47 <freakazoid> sorear: so disable it
12:32:51 <sorear> glguy: fork
12:32:59 <sorear> glguy: fork of fork, fork
12:33:07 * glguy banished his capslock key and called in a new control key
12:33:23 <glguy> sorear: but cygwin doesn't have an elinks package :(
12:33:27 <sorear> how does one do that with the linux keyboard stack ?
12:33:30 <freakazoid> my friend turned caps lock into enter to help with his RSI and disabled enter
12:33:38 <glguy> sorear: its easy with X11
12:33:42 <freakazoid> apparently his right pinky has problems
12:33:46 <kolmodin> dcoutts: that's great!
12:33:48 <glguy> sorear: and with *BSD it is easy to change on the console
12:33:59 <kolmodin> dcoutts: ay!
12:34:02 <pejo> dcoutts, ah, hm. So it's more of a debug aid, than help for the optimizer?
12:34:03 <allbery_b> it's not actually much harder to change for console on linux
12:34:15 <klapmuetz> sorear: elinks is awesome, do you use hooks?
12:34:20 * glguy doesn't run linux boxes
12:34:36 <sorear> klapmuetz: what's hooks?
12:34:40 <kolmodin> in the meanwhile when dcoutts is gone, maybe someone can help me identify this haskell ninja?... :D http://picasaweb.google.com/kolmodin/Hackathon2007/photo#5022569626657009714
12:34:43 <lambdabot> Title: Picasa Web Albums - Lennart Kolmodin - Hackathon 2007, http://tinyurl.com/ywl998
12:34:59 <freakazoid> glguy: did you run out of excuses for complaining about lack of support? ;-)
12:35:05 <klapmuetz> sorear: like some of my most visited sites will be modified and they look nicer.
12:35:13 <glguy> freakazoid?
12:35:38 <freakazoid> glguy: never mind, you can even run linux binaries I would imagine
12:35:40 <allbery_b> man loadkeys
12:36:06 <freakazoid> glguy: though it must annoy you when things depend on the GNU userland
12:36:20 <glguy> freakazoid: because of cygwin?
12:36:21 <fatalis> lo donkeys
12:36:33 <freakazoid> glguy: Oh
12:36:44 <freakazoid> glguy: You use Windows?
12:36:54 <glguy> freakazoid: windows, OSX and OpenBSD and netbsd
12:37:06 <freakazoid> glguy: I was referring to bsd
12:37:18 <glguy> freakazoid: no, I don't have issues staying away from GNU userlang
12:37:19 <glguy> d
12:37:39 <freakazoid> to run straight Linux binaries on Windows you'd need to use uhhhh colinux
12:37:57 <glguy> to run them in OpenBSD, you just use the linux_emulation
12:38:00 <freakazoid> glguy: not even gmake? ;-)
12:38:01 <glguy> built into openbsd
12:38:02 <freakazoid> glguy: Yeah
12:38:07 <glguy> freakazoid: I have gmake installed
12:38:12 <freakazoid> HAH!
12:38:16 <glguy> ?
12:39:05 <freakazoid> or by "I don't have issues" mean "I don't care about"
12:39:05 <glguy> I just don't care for any of the linux distros that I've tried, I don't have a GNU hate complex
12:39:12 <freakazoid> glguy: oh
12:39:23 <freakazoid> glguy: then I have nothing to make fun of you about
12:39:57 <glguy> eric:2$ sudo pkg_add -r elinks
12:39:58 <freakazoid> I ran FreeBSD on my Libretto SS1010 becuase Linux wouldn't work with the floppy drive
12:40:00 <glguy> and now i have elinks :)
12:40:19 <sorear> I run linux, but personally I like ghci better
12:40:27 <freakazoid> ghci > Linux?
12:40:35 * freakazoid didn't realize it was an OS ;-)
12:40:49 <freakazoid> wow, GHC is still compiling
12:40:55 <allbery_b> next it'll be /vmghci :)
12:41:00 <freakazoid> I clearly need a faster computer
12:41:12 <glguy> freakazoid: it has been run without an OS before
12:41:20 <matthew-_> mmm. I think the space/memory leak has been spotted and attributed to a co-developer ;)
12:41:53 * freakazoid needs a Core 2 Duo or an Opteron or something
12:42:00 * freakazoid has the last Pentium 4 ever made
12:42:53 <glguy> sorear: can elinks use unicode linedrawing chars?
12:43:24 <sorear> glguy: it uses linedrawing chars, dunno if unicode
12:43:45 <sorear> glguy: full IBM-extended-ascii box drawing, not the chessy vt100 stuff
12:43:49 <glguy> mine is using |, + and -
12:43:53 <glguy> am I missing something?
12:44:18 <sorear> glguy: 'o', [+] Terminals, look at the settings for your terminal type
12:44:43 <sorear> eg. type field
12:44:52 <sorear>          
12:45:01 <glguy> ok
12:45:06 <sorear> ok, I think utf8 just ate my line...
12:45:08 <glguy> sorear: hpaste.ath.cx:8000
12:45:12 <sorear> did you see anything?
12:45:35 <glguy> I have that menu open
12:45:48 <sorear> glguy: where is .cx?
12:46:04 <glguy> sorear: I don't know, but it's provided by dyndns.org
12:46:05 <sorear> @vera cx
12:46:07 <lambdabot> No match for "cx".
12:46:37 <sorear> Wikipedia: .cx is the country code top-level domain (TLD) for Christmas Island.
12:46:54 <sorear> area 51 mi^2
12:46:56 <allbery_b> M-x what-domain RET cx RET :)
12:47:16 <sorear> population 1493
12:47:21 <sorear> and they have a TLD !?
12:47:36 <glguy> sorear: I fixed the line-drawing
12:47:59 * allbery_b thinks selling domains is their main source of income :)
12:48:29 <heatsink> Much like tonga?
12:48:31 <sorear> glguy: good!  w/o a linux console, how?
12:48:45 <glguy> I switched to VT100
12:48:54 <glguy> I'm using PuTTY
12:49:34 <sorear> oh
12:49:42 <sorear> so you only have single boxes?
12:49:55 <glguy> oh, yeah, I didn't get to enable mode 2
12:50:04 <p-f> if I have the following: showlen lst = (show theLen) ++ " rawr " ++ (show theLen) where theLen = length lst, will it evaluate theLen twice or will it only evaluate it once and use the same value for both occurences?
12:50:21 <sorear> once
12:50:24 <mauke> the latter
12:50:32 <p-f> thanks :)
12:50:50 <mauke> showlen lst = theLen ++ " >:3 " ++ theLen where theLen = show (length lst)
12:50:54 <glguy> sorear: now I have double boxen
12:50:57 <sorear> p-f: H98 specifies twice, but in practice every implementation memoizes 0-argument functions
12:51:21 <mauke> sorear: whoa, where does it say that?
12:51:39 <sorear> I think it's call-by-name in the spec ... i've only heard it
12:51:44 <p-f> mauke: much better indeed, but it was just a random example to see how the evaluation worked
12:51:51 <augustss> sorear: yes, where does it say that?  I doubt it
12:51:52 <heatsink> Related question: why do these two functions have different performance when partially applied? let {slowFunction x y = g (f x) y; fastFunction x = g (f x)} in ...
12:51:59 <glguy> sorear: I enabled UTF8 i/o, and mode 2 lines
12:52:43 <mauke> is this the fabled eta-reduction?
12:54:05 <sorear> heatsink:
12:54:16 <sorear> @goog full laziness ghc user manual
12:54:18 <lambdabot> http://www.cs.mu.oz.au/research/mercury/information/comparison_with_haskell.html
12:54:18 <lambdabot> Title: The Mercury Project: Comparing Mercury and Haskell
12:54:24 <sorear> @goog full laziness ghc user guide
12:54:25 <lambdabot> http://www.cs.mu.oz.au/research/mercury/information/comparison_with_haskell.html
12:54:26 <lambdabot> Title: The Mercury Project: Comparing Mercury and Haskell
12:54:35 <psnl> @hoogle [[a]]->[a]
12:54:36 <lambdabot> Prelude.concat :: [[a]] -> [a]
12:54:42 <sorear> be nice if it worked...
12:55:25 <hpaste>  glguy pasted "HTML idea" at http://kakapo.scannedinavian.com:8000/21
12:55:48 <glguy> sorear: do you think that looks better or worse (and is more or less appropriate) in a text environment
12:55:58 <heatsink> Should I look in the user guide for "full laziness" then?
12:56:02 <glguy> from the CSS pov they are the same
12:56:07 <sorear> I *know* I saw a discussion of partial let floating and lambda splitting ing the manual...
12:57:20 <sorear> glguy: is that supposed to replace:
12:57:25 <sorear>      * Nick:glguy
12:57:25 <sorear>      * Title:HTML idea
12:57:25 <sorear>      * 1 minute ago
12:57:28 <glguy> yeah
12:57:45 <hyrax42> glguy: (non-confrontationally) is the haskell paste thingy an exercise or intended to replace lisppaste
12:57:56 <glguy> hyrax42: replace
12:57:58 <augustss> heatsink: yes, the users' guide has some info on full lziness etc
12:58:06 <sorear> glguy: I think it looks worse
12:58:11 <glguy> sorear: ok
12:58:16 <glguy> I'll just add a space
12:58:44 <hyrax42> glguy: for #haskell only?
12:59:00 <glguy> hyrax42: that's the current scope
12:59:08 <hyrax42> cool
13:00:05 <hyrax42> any nifty features planned?
13:00:42 <sorear> not yet
13:00:57 <glguy> If you have ideas, now is a great time to suggest
13:01:17 <glguy> hpaste remembers who you are if you want it to
13:01:25 <glguy> that's about all it does in addition
13:01:38 <hyrax42> kk
13:02:03 <sorear> lambdabot needs a @gtodo which works for any project
13:02:12 <glguy> some people don't like how it looks... but I'm no graphic artist
13:02:25 <glguy> so someone else will probably have to come up with a decent look if that is going to change
13:02:27 <hyrax42> glguy: hehe
13:02:44 <hyrax42> glguy: so long as you've made it nicely CSSable I'm sure it'll get fixed
13:02:47 <sorear> oh, yes, as an elinkser I've been pressuring glguy to make it very elinks freindly.
13:02:49 <Kaboem> does someone knows what this mean : - Last generator in do {...} must be an expression
13:02:55 <sorear> Kaboem: yes
13:03:10 * heatsink found the full laziness thing in the GHC faq
13:03:10 <glguy> Kaboem: do { x <- y } BAD
13:03:15 <sorear> Kaboem: usually, it's a makes-you-feel-stupid indentation slip
13:03:16 <glguy> do { x <- y; return x } GOOD
13:03:38 <glguy> also, do can't end in a "let"
13:03:50 <sorear> hpaste looks perfect in elinks.  just a little more perfect than lisppaste.
13:04:11 <hyrax42> hm what is the name of that really pretty pastebin thing
13:04:34 <hyrax42> I checked the RoR one which was my guess, but it didn't look as good as the one I had in mind
13:05:04 <Kaboem> That identation thing is really stupid:(
13:05:11 <sorear> hyrax42: also hpaste aims to be easy on manual url-typing
13:05:26 <sorear> hyrax42: hpaste has no /display/ and uses numbers mod 100
13:05:30 <mauke> @hoogle (a -> a) -> a -> [a]
13:05:31 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
13:05:31 <lambdabot> List.deleteBy :: (a -> a -> Bool) -> a -> [a] -> [a]
13:05:31 <lambdabot> List.insertBy :: (a -> a -> Ordering) -> a -> [a] -> [a]
13:05:42 <Kaboem> Or I don't know how it really works and why It's like that.
13:05:42 <hyrax42> sorear: meaning?
13:05:47 <glguy> I'm going to change the bot reported URLs to use hpaste.ath.cx
13:06:10 <glguy> just on length merits
13:06:20 <mauke> Kaboem: rule of thumb: always start a new line after "do", "where", etc
13:06:41 <Kaboem> k ty mauke
13:06:51 <sorear> hyrax42: hpaste.ath.cx:8000/54.  not /display/54, not /display/38354 .
13:06:55 <glguy> the old URL still works
13:07:01 <sorear> (not that we have 38kpastes)
13:07:26 <Saizan> :8000 kills this a bit
13:07:40 <jcreigh> hmm...what about using, eg, base 36 as ids?
13:07:53 * sorear goes to hack gtodo
13:08:09 * glguy would love to ditch :8000
13:08:32 <hyrax42> glguy: runnin on home machine?
13:08:40 <glguy> hyrax42: running on shaprs server
13:08:48 <hyrax42> oh ok
13:09:03 <hyrax42> why can't it be port 80 then?
13:09:03 <glguy> hpaste.ath.cx just points to kakapo.scannedinavian.com
13:09:11 <glguy> hyrax42: he's using 80
13:09:29 <glguy> Soon, this will be a commercial site advertising the software and services of Shae Matijs Erisson (resume).
13:09:38 <hyrax42> should still be posible?
13:10:42 <hpaste>  glguy annotated "announce test" with "announce test" at http://hpaste.ath.cx:8000/4#10
13:11:15 <glguy> ?tell shapr I'm still using kakapo, I just used a dyndns alias
13:11:16 <lambdabot> Consider it noted.
13:12:23 <sorear> glguy:      ,("paste",      const "Haskell pastebin: http://hpaste.ath.cx:8000/new")
13:12:29 <sorear> correct?
13:12:46 <glguy> yeah
13:12:52 <glguy> !paste
13:12:52 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
13:13:02 <glguy> that'll be shorter, and more obvious
13:14:11 <sorear> what? !paste vs. @paste ?
13:14:26 <glguy> ?
13:14:29 <glguy> no, the new url
13:14:30 <sorear> anyway patch sent
13:15:21 <glguy> dons is going to get angry with me :)
13:15:40 <glguy> I did the !paste to make sure my change worked
13:16:01 <sorear> glguy: why dons angry with you?
13:16:08 <glguy> i keep changing urls
13:16:20 <glguy> this one should be pretty stable though
13:16:27 <glguy> first I moved to a more stable computer
13:16:32 <sorear> .... until you fix the 8000!
13:16:32 <glguy> and now I have a short hostname
13:16:35 <glguy> next is the port
13:16:49 <glguy> just need to convince shapr to give up 80 :)
13:16:50 <jcreigh> if the IDs are mod 100, doesn't that mean that if you're, for example, reading old logs, the links will be broken?
13:16:58 <sorear> jcreigh: yes?
13:17:19 <freakazoid> is it really necessary to save space?
13:17:22 <jcreigh> ...that doesn't seem like a feature. :)
13:17:40 <freakazoid> just encode the content of the paste in the url ;-)
13:18:22 <sorear> it'd data compression
13:18:33 <freakazoid> that sentence didn't parse
13:18:36 <sorear> hpaste.ath.cx stores the encoder dictionary
13:18:45 <sorear> s/it'd/it's
13:18:56 <jcreigh> heh, yeah, I guess you could think of it that way.
13:19:00 <freakazoid> but it's a sliding window
13:19:08 <Saizan> if 80 is on happs too we should hack happs till the point where you can have many wepapps indipendently loadable by the same server, and then we can share the port :)
13:19:22 <sorear> Saizan: great idea
13:19:33 <sorear> would people stop having great ideas?
13:19:41 * freakazoid stopped long ago
13:19:42 <sorear> I haven't finished generalizing todo yet!
13:19:52 <Saizan> :D
13:20:39 <glguy> WHOA elinks has mouse support
13:20:52 <sorear> glguy: yes
13:20:54 <glguy> my scroll wheel works too
13:20:55 <sorear> glguy: I love it
13:20:59 <glguy> right mouse too
13:21:02 <sorear> glguy: It works on the console too!
13:21:13 <glguy> I clicked on the checkbox
13:21:16 <glguy> and it changed
13:21:31 <heatsink> (:
13:21:42 <sorear> > cycle " :)"
13:21:43 <lambdabot>  " :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :)...
13:21:58 <Kaboem> someone is happy :)
13:22:03 <sorear> lambdabot does my autotyping :)
13:22:13 <LoganCapaldo> > fix (":) " ++)
13:22:14 <lambdabot>  ":) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) :) ...
13:22:52 <Saizan> @src cycle
13:22:52 <lambdabot> cycle [] = undefined
13:22:53 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
13:23:06 <sorear> aka
13:23:12 <sorear> cycle = fix . (++)
13:23:17 <freakazoid> that makes me want to write a MOO in Haskell
13:23:20 <augustss> > concat $ replicate 10 " :( "
13:23:20 <sorear> cycle = concat . repeat
13:23:22 <lambdabot>  " :(  :(  :(  :(  :(  :(  :(  :(  :(  :( "
13:23:29 <freakazoid> what's he using for an interpreter?
13:23:34 <glguy> sorear: mouse 3 and 4 don't do back and forward :(
13:23:35 <Saizan> ?type fix (++)
13:23:36 <sorear> freakazoid: runplugs
13:23:37 <lambdabot>     Expecting a function type, but found `a'
13:23:37 <lambdabot>       Expected type: [a] -> [a]
13:23:45 <freakazoid> @google runplugs
13:23:47 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
13:23:51 <sorear> heh
13:23:56 <sorear> in the LB repo
13:24:35 <sorear> runplugs uses the GHC API to do most of the heavy lifting, so GHCi to a first approximation
13:24:47 <freakazoid> does it fork for each expression?
13:24:51 <sorear> freakazoid: yes
13:24:54 <freakazoid> oh
13:25:05 <sorear> > array (0 :: Int, maxBound) [(2,'x')]
13:25:08 <lambdabot> Terminated
13:25:10 <sorear> > array (0 :: Int, maxBound) [(3,'x')]
13:25:11 <emk> "The Haskell Road To Logic, Maths And Programming": Do people like it?
13:25:12 <lambdabot> Terminated
13:25:15 <sorear> > array (0 :: Int, maxBound) [(4,'x')]
13:25:16 <lambdabot>  internal error: EVACUATED object entered!
13:25:17 <lambdabot>     Please report this as a bug to...
13:25:28 <sorear> Terminated is lb-speak for segmentation fault, btw.
13:25:45 <allbery_b> huh, I though it was a timeout
13:25:49 <augustss> > array (0 :: Int, maxBound) [(4,'x')]
13:25:51 <sorear> all three of those errors were fatal for runplugs
13:25:51 <lambdabot>  internal error: END_TSO_QUEUE object entered!
13:25:51 <lambdabot>     Please report this as a bu...
13:25:57 <freakazoid> sorear: that's the same basic technique I use to run untrusted Python code
13:25:57 <sorear> allbery_b: either.
13:25:59 <glguy> > length [1..]
13:26:04 <lambdabot> Terminated
13:26:07 <sorear> allbery_b: Terminated means no output
13:26:14 <augustss> Seems the ghc runtime needs some more checks
13:26:17 <freakazoid> sorear: Only I use a persistent interpreter that's owned by whoever holds a reference to it
13:26:17 <sorear> allbery_b: It could be SIGSEGV or SIGXCPU
13:26:24 <freakazoid> sorear: for a multiuser system
13:26:29 <sorear> SIGXCPU is timeout
13:26:41 <augustss> > array (0 :: Int, maxBound) [(4,'x')]
13:26:44 <lambdabot> Terminated
13:26:55 <sorear> augustss: yep, what I just did is bypass bounds checking w/o unsafe functions.
13:27:16 <sorear> augustss: lb doesn't have unboxed type support, but if it did code injection would be easy
13:27:37 <freakazoid> should probably be chrooted as well just for good measure
13:27:39 <sorear> augustss: it's a simple matter of integer overflow in malloc (4 * arraysize)
13:27:46 <freakazoid> though that requires running something as roo
13:27:49 <freakazoid> t
13:27:50 <augustss> sorear: well, this a clearly a bug.  has it been reported
13:27:57 <augustss> ?
13:28:05 <LoganCapaldo> let a = [1..] in let length a = "Infinity" in length a
13:28:06 <sorear> augustss: on the channel, many times by me.
13:28:20 <sorear> augustss: ppl keep saying it's been reported on trac
13:28:26 <sorear> augustss: I should check
13:28:32 <emk> Zippers are very clever.
13:28:36 <sorear> agreed.
13:28:44 <LoganCapaldo> > let a = [1..] in let length a = "Infinity" in length a
13:28:46 <lambdabot>  "Infinity"
13:29:14 <sorear> LoganCapaldo: youknow you can declare multiple bindings in one let ...
13:29:16 <glguy> length [(1::Int)..] == maxBound
13:29:19 <augustss> > let a = [1..] in let length a = 1/0 in length a
13:29:21 <lambdabot>  Infinity
13:31:49 <sorear> augustss: ticket #229
13:31:55 <sorear>    Opened 3 years ago
13:32:01 <augustss> lol
13:32:05 <augustss> that's bad
13:32:44 <sorear> X.org has a 5-yr-old crash bug that has effectively stopped me from learning HOpenGL
13:33:33 <LoganCapaldo> I like say let in let better than { } ;)
13:33:49 <sorear>   10/13/06 06:22:40: Modified by igloo
13:33:49 <sorear>      * milestone set to 6.8.
13:34:34 <augustss> LoganCapaldo: no need for { }
13:34:38 <sorear> I suppose THAT is atleast good news...
13:34:58 <augustss> > let a = [1..]; length a = 1/0 in length a
13:35:00 <lambdabot>  Infinity
13:35:01 <LoganCapaldo> > let a = 1; b = 2 in a + b
13:35:03 <lambdabot>  3
13:35:20 <LoganCapaldo> but the semicolons ;)
13:35:38 <jcreigh> well, in code you can use layout.
13:35:39 <augustss> shorther than "in let"
13:36:55 * LoganCapaldo would prefer let a = 2, b = 3 in a + b
13:37:14 <augustss> it's the one line let that's the cause of the rule that makes Haskell almost impossible to parse
13:37:14 <LoganCapaldo> I guess I could always do let (a, b) = (1, 2) in a + b
13:37:47 <LoganCapaldo> augustss, how do you mean?
13:38:09 <Igloo> You can do let a = 2; b = 3 in a + b
13:38:27 <Igloo> Oh, you said that above
13:39:02 <augustss> there's a lexical rule that says that an implicit '}' is inserted so that a parse error is avoided (i forget the exact wording)
13:39:21 <augustss> that rule is almost impossible to implement correctly
13:39:30 <augustss> No one has, as far as I know.
13:39:32 <LoganCapaldo> Aha
13:39:44 <LoganCapaldo> that does sound like a pain in the rear
13:40:11 <Igloo> The rule itself is a bit vague, as the grammar doesn't differentiate between lexing and parsing
13:40:18 <augustss> what's implemented works for all non-pathological examples
13:40:50 <LoganCapaldo> What would a pathological example look like
13:40:55 <LoganCapaldo> ?
13:42:12 <sorear> stuff like case 2 of 2 -> 3 == 3 == 3
13:42:22 <sorear> that needs to parse as
13:42:28 <sorear> (case 2 of 2 -> 3 == 3) == 3
13:42:31 * allbery_b finds the evil in sec. 2.7
13:42:35 <allbery_b> eeeew
13:42:36 <sorear> since 3 == 3 == 3 is a parse error
13:42:48 <LoganCapaldo> gah
13:42:50 <sorear> since (==) is infix (nor l|r)
13:42:55 <augustss> "The side condition parse-error(t) is to be interpreted as follows: if the tokens generated so far by L together with the next token t represent an invalid prefix of the Haskell grammar, and the tokens generated so far by L followed by the token "}" represent a valid prefix of the Haskell grammar, then parse-error(t) is true."
13:43:19 <sorear> I think it is safe to say no haskell implementation does fixity resolution during *lexing*.
13:44:05 <augustss> sorear: especially not since you need to consult other modules to resolve fixity
13:44:49 <sorear> now, imagine a set of mutually recursive modules.
13:45:10 <LoganCapaldo> You can have mutually recursive modules!?!?
13:45:13 <augustss> they need to be compiled as a group
13:45:21 <augustss> LoganCapaldo: yes
13:45:22 <allbery_b> via a hack, yes
13:45:26 <allbery_b> .hs-boot
13:45:36 <SamB> LoganCapaldo: according to the Report, yes
13:45:36 * LoganCapaldo is starting to think Haskell is not as clean as he original supposed
13:45:38 <augustss> allbery_b: that is how ghc implements it
13:45:43 <SamB> with a hack, yes...
13:45:44 <sorear> LoganCapaldo: in H98 - GHC doesn't properly implement it however
13:45:55 <allbery_b> yeh, that's ghc's implementation
13:45:57 <SamB> most things don't implement it well, do they?
13:46:18 <ndm> kolmodin, almost done on Catch - a few more theorems and its finished
13:46:26 <sorear> is there a haskell 98 implementation?
13:46:39 <augustss> sorear: you mean a correct one?
13:46:44 <SamB> complete and correct?
13:46:46 <SamB> probably not
13:46:53 <augustss> no, I doubt that
13:47:15 <jrockway> that's why it's best to always make one implementation the standard, microsoft style :) then at least one implementation is correct by definition
13:47:30 <ndm> there is none that implements recursive modules properly
13:47:38 <sorear> jhc?
13:47:38 <ndm> other than perhaps jhc which is lacking in lots of other ways
13:47:44 * allbery_b wonders if h' should do something about some of this
13:47:48 <augustss> and none that does the lexing right
13:47:52 <SamB> jrockway: are you implying that it is critically important to have a complete implementation of every standard?
13:48:06 <allbery_b> not sure what it could do about recursive modules, but maybe it could remove the weirdball insert-} thing
13:48:07 <ndm> SamB: it does seem at least a sensible goal...
13:48:10 <sorear> h' should just mandate that implementations solve the halting problem.
13:48:26 <SamB> ndm: it would be nice if the standard would at least make that practical
13:48:26 <sorear> that way there will be no question about the existance of implementations.
13:48:32 <jcreigh> @pl \f -> length . filter f
13:48:32 <jrockway> yeah, what's the point of standards if you can't use them?
13:48:32 <SamB> sorear: heh
13:48:32 <lambdabot> (length .) . filter
13:48:35 <augustss> allbery_b: recursive modules is not difficult.  you just need to compile them as a group
13:48:47 <SamB> jrockway: well, so you can agree on the parts you do implement?
13:48:53 <jcreigh> I still can't believe there's no "count" function in Data.List...
13:48:55 <sorear> just use lo:b !
13:49:12 <SamB> augustss: good luck figuring out how to get GHC to do that
13:49:35 <LoganCapaldo> ?type (length . filter)
13:49:37 <lambdabot>     Expecting a function type, but found `b'
13:49:37 <lambdabot>       Expected type: (a1 -> Bool) -> [a]
13:49:46 <kolmodin> ndm: very nice to hear. is the source somewhat in order to try? last time you said that I probably couldn't find the right bits and pieces :)
13:49:47 <glguy> ?type (length .) . filter
13:49:48 <augustss> SamB: I've heard Simon PJ say something about biting the bullet on that one day
13:49:49 <lambdabot> forall a. (a -> Bool) -> [a] -> Int
13:49:49 <SamB> what if the linkage graph is basically one big SCC?
13:49:58 <SamB> in the program itself
13:50:07 <SamB> wouldn't that be, uh, kinda slow?
13:50:18 <SamB> er. import graph...
13:50:18 <sorear> SamB: the linkage graph of lambdabot is 2 SCCs
13:50:20 <twanvl> Maybe the standard should say that recursive imports are only allowed if all the names used have a type signature
13:50:30 <augustss> SamB: sure, but then it's a mess you've made yourself :)
13:50:44 <SamB> twanvl: this has been discussed
13:50:50 <sorear> Modules imports everything except Main, everything except Main imports Lambdabot, Lambdabot imports Modules
13:50:52 <LoganCapaldo> glguy, How do do that? <g>
13:50:58 <SamB> I don't think anyone objected, either
13:51:03 <LoganCapaldo> Practice?
13:51:13 <glguy> LoganCapaldo (f .) . g   is a common pattern
13:52:07 * sorear didn't know LoganCapaldo was a function :)
13:52:09 <ndm> kolmodin, alas its still just as messy as ever - although i did spend friday refactoring
13:52:12 <SamB> see, even if GHC supported merging SCCs, that wouldn't be practical in a lot of cases
13:52:22 * augustss tries to avoid mutually recursive modules.  But sometimes it's just the best way to break things up.
13:52:28 <ndm> kolmodin, i gave my supervisor a strong commitment to next thursday for an internally released version
13:52:52 <SamB> so I think people would still be sticking {-# SOURCE #-} pragmas in their imports
13:53:30 <sorear> shim should support automatic writing of .hs-boots!
13:53:44 <glguy> OK, so what's next on my hpaste todo list?
13:53:44 <SamB> though if we went ahead with that typesigs on exports thing, yeah, that would mean no .hs-boot
13:53:48 <glguy> I'm bored
13:53:49 <ndm> Yhc has partial support for mutually recursive modules, not enough for it to actually work
13:53:53 <augustss> Even rthe current handling of hs-boot in ghc is broken
13:54:04 <SamB> augustss: yeah
13:54:05 <LoganCapaldo> @pl (\p -> foldl 0 (\s x -> if p x then s + 1 else s))
13:54:05 <sorear> glguy: cookie stylesheet selection
13:54:06 <lambdabot> foldl 0 . join . (flip .) . (. (1 +)) . flip . (if' .)
13:54:10 <sorear> :)
13:54:11 <SamB> it is kind of sensitive!
13:54:17 * LoganCapaldo blinks
13:54:22 <glguy> sorear: elaborate on that one again
13:54:25 * sorear is keeping a todo-list, until dons takes gtodo
13:54:40 <sorear> glguy: how familiar are you with mediawiki
13:54:53 <augustss> SamB: ghc --make doesn't work on ghc itself because of the broken hs-boot
13:55:07 <glguy> sorear: how much did you know about .cx this morning
13:55:07 <LoganCapaldo> Actually that would be easier if true and false were functions
13:55:08 <SamB> ouch!
13:55:49 <sorear> I wish Haskell used Church encoding for AlDTs.
13:56:02 * nmessenger lambdabot ?pl \b t f -> if b the t else f
13:56:08 <sorear> if'
13:56:11 <SamB> sorear: I don't!
13:56:18 * SamB shudders at the thought
13:56:19 <nmessenger> er, /msg heh-heh
13:56:49 <glguy> sorear: link to a description of this functionality?
13:56:53 <SamB> it might be nice if there was a simple way to make a function to project into a church encoding
13:57:22 <LoganCapaldo> let true = \x y -> x ; false = \x y -> y in (x < 3) x 2
13:57:28 <augustss> SamB: but the church encoding is beautiful
13:57:44 <augustss> and with some type abstractions you can hide it
13:57:45 <SamB> I was shuddering at the CPU cycles this might waste
13:57:50 <sorear> nmessenger: /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/03.05.19:19:30:39 * ozone ickserv identify zxcmn7
13:58:14 <augustss> SamB: it's just a matter of implementing certain functions efficiently
13:58:14 <nmessenger> sorear, bwuh?
13:58:18 <sorear> you're lucky it was lambdabot
13:58:48 <glguy> sorear: what about a diff command?
13:58:54 <augustss> SamB: and what makes you think the church encoding is much worse than what we have now? :)
13:59:14 <sorear> ./03.05.19:19:30:39 * ozone ickserv identify zxcmn7
13:59:14 <sorear> ./03.05.19-19:30:39 <ozone> hmm
13:59:14 <sorear> ./03.05.19-19:30:50 * Pseudonym knows ozone's password!
13:59:14 <sorear> ./03.05.19-19:30:54 <ozone> grr
13:59:22 <nmessenger> nickserv squatters should be shot
13:59:28 <dons> ?yow!
13:59:28 <lambdabot> ... the HIGHWAY is made out of LIME JELLO and my HONDA is a barbequeued
13:59:29 <lambdabot> OYSTER!  Yum!
13:59:36 <sorear> hi!
13:59:44 <dons> man that was a long flight
13:59:44 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
13:59:44 <augustss> howdy, dons!
13:59:56 <dons> hey augustss
13:59:57 <sorear> dons: I'm now rewriting @todo to support MULTIPLE PROJECTS!
13:59:57 * nmessenger hopes ozone changes his/her password quickly
14:00:06 <dons> so	hmm!
14:00:20 <SamB> sorear: neato
14:00:27 <SamB> it doesn't work very well as it is, clearly...
14:00:30 <allbery_b> that seems t have been in 2003, if I parse the datestamp right, so it's a bit late now :_)
14:00:40 <nmessenger> *changed, then
14:00:41 <SamB> I apparantly wrote it for some unkown reason a while back...
14:01:05 <sorear> anyway: dons: hpaste has moved again
14:01:10 <SamB> again!
14:01:13 <SamB> !paste
14:01:14 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
14:01:14 <glguy> sorear: are there any algorithms for doing diffs already that you know of (in haskell)
14:01:22 <sorear> glguy: yes
14:01:31 <dons> does darcs use one?
14:01:37 <SamB> scandinavian went down?
14:01:42 <dons> and Pseudonym has written some fancy diff in haskell, iirc
14:01:53 <allbery_b> no, it's a cname
14:01:54 <glguy> HPASTE.ATH.CX is an ALIAS
14:02:05 <glguy> technically it's an A record
14:02:15 <Kaboem> Where and when do you use haskell?
14:02:15 <glguy> because dyndns.org doesn't support cnames
14:02:17 <glguy> that I know of
14:02:24 <sorear> glguy: kakapo.scannedinavian.org is an A too
14:02:32 <glguy> sorear: right
14:02:38 <sorear> kakapo.scannedinavian.org. 604800 IN    A       65.254.53.221
14:02:52 <SamB> ah.
14:03:01 <nmessenger> hpaste.ath.cx takes me to the scannedinavian front page
14:03:03 <SamB> so @paste still gives a valid URL?
14:03:04 <sorear> hpaste.ath.cx.          14400   IN      A       65.254.53.221
14:03:11 <sorear> SamB: yes.
14:03:11 <SamB> nmessenger: that doesn't sound nice!
14:03:19 <sorear> SamB: soon it will give a shorter one!
14:03:30 <allbery_b> sadly a records can't contain ports
14:03:48 <sorear> dyndns has a http-proxy service iirc
14:03:54 <glguy> sorear: oh?
14:04:04 <allbery_b> it can send you to scannedinavian but can't redirect your port 80 to port 8000
14:04:09 <sorear> it's called WebHops or something silly like that
14:04:13 <glguy> sorear: i just found it
14:05:49 <SamB> don't HTTP clients usually send the domain name along with their request anyway?
14:05:56 <glguy> yeah
14:06:10 <sorear> that's how vhosts work
14:06:16 <sorear> oh duh
14:06:17 <glguy> shapr could do a redirect if he wanted
14:06:34 <glguy> based on the hostname
14:06:50 * sorear adds this to todofile
14:07:57 <jcreigh> yes, the Host header is required in HTTP 1.1, I believe.
14:08:06 <allbery_b> yeh
14:13:31 <hyrax42> it could be set up rather easily with pound, probably
14:15:26 <dons> ?users
14:15:27 <lambdabot> Maximum users seen in #haskell: 311, currently: 292 (93.9%), active: 44 (15.1%)
14:16:38 <glguy> for a diff algorithm, does it make sense to use an LCS function, return the left1 left2 shared_middle right1 right2, and then recurse on left1/left2 and right1/right2
14:17:04 <glguy> until there is no shared_middle
14:20:58 <TSC> There must be lots of literature on diff algorithms
14:22:17 * bos31337 has a partially written Rope type implemented on top of ByteString now
14:22:30 <bos31337> O(1) append
14:25:12 <dons> heya bos31337
14:25:23 <dons> bos31337: you should talke to sjanssen about the rope stuff
14:25:31 <dons> he was looking into that for his summer of code projet
14:25:42 <dons> also, audreyt and the pugs crew would be interested, i think (they were in the past anyway)
14:26:29 <bos31337> yeah, i saw sjanssen's SOC application
14:27:11 <bos31337> the only tricky bit about ropes is understanding the balancing algorithm
14:27:14 <sorear> Idea - @tell and @todo are symmetric enough to merge in the presence of nick identity information
14:27:26 <bos31337> as usual, the haskell code is much clearer than the C or STL implementations :-)
14:29:07 <bos> @seen sjanssen
14:29:07 <lambdabot> sjanssen is in #ghc, #gentoo-haskell, #haskell.hac07, #haskell-overflow, #haskell-blah and #haskell. I last heard sjanssen speak 17h 43m 13s ago.
14:29:56 <ihope> How sane is an instance of Num expected to be?
14:30:08 <sorear> ihope: ringy
14:30:09 <bos> depends on what you want to do with it.
14:30:32 <ihope> sorear: so it's just expected to be a ring, pretty much?
14:30:38 <sorear> I think so
14:30:42 <ihope> 1+1 is allowed to be 0, and all that?
14:30:52 <sorear> ihope: Z_2 is a ring
14:31:02 <bos> dons: congrats on the award for the padl paper!
14:31:10 <nornagon> > let 1+1=0 in 1+1
14:31:11 <lambdabot>  0
14:31:25 <glguy> > listArray ((0,0),(1,1)) [1..]
14:31:26 <sorear> nornagon: (+) isn't a ring method
14:31:27 <lambdabot>  array ((0,0),(1,1)) [((0,0),1),((0,1),2),((1,0),3),((1,1),4)]
14:31:52 <sorear> it's a let binding :)
14:32:11 <sjanssen> bos: is your code online?
14:33:10 <nornagon> sorear: ... ring?
14:33:21 <sorear> nornagon: doh, Num
14:33:34 <nornagon> :t (+)
14:33:36 <lambdabot> forall a. (Num a) => a -> a -> a
14:33:50 <sorear> not in your line!
14:34:11 <ihope> @index Word
14:34:12 <lambdabot> Data.Word, Foreign, GHC.Exts
14:34:29 <ihope> Good, it is a type. Is it pretty much an unsigned Int, then?
14:34:35 <ihope> @docs Data.Word
14:34:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Word.html
14:34:38 <nornagon> > let { a+b=0 :: (Num a) => a -> a -> a } in 1+1
14:34:39 <lambdabot>        add (Num (a -> a -> a)) to the expected type of an expression
14:34:40 <lambdabot>       or...
14:35:00 <sorear> ihope: yes
14:35:07 <sorear> ihope: Word is unsigned int
14:35:21 <nornagon> > let { (a+b=0) :: (Num a) => a -> a -> a } in 1+1
14:35:22 <lambdabot>  Parse error
14:35:26 <nornagon> yay.
14:35:34 <sorear> ihope: Data.Word also has equivalents to (u)int{8,16,32,64}_t
14:36:03 <Saizan> > let { (+) = (\_ _ -> 0) :: (Num a) => a -> a -> a } in 1+1
14:36:05 <lambdabot>  0
14:36:13 <ihope> Fun.
14:36:31 <hyrax42> hm
14:36:41 <p-f> haskell.org says the following on read :: Read a => String -> a: The read function reads input from a string, which must be completely consumed by the input process.  Could someone explain to me what the "must be completely consumed by the input process" bit actually means please? I guess I'm lacking the context in which to interpret that phrase
14:37:03 <sorear> > read "23foo"
14:37:04 <lambdabot>  Add a type signature
14:37:08 <sorear> > read "23foo" :: Int
14:37:09 <lambdabot>  Exception: Prelude.read: no parse
14:37:10 <ihope> p-f: it means the whole thing has to be what was read, not just the first part of it.
14:37:16 <sorear> the foo is not consumed, hence erro
14:37:23 <ihope> "23foo" parses as 23 with "foo" left over.
14:37:25 <hyrax42> you can have lazy ropes ?
14:37:35 <nornagon> > readS "23foo" :: [(Int,String)]
14:37:36 <p-f> ahh, thanks
14:37:36 <ihope> read requires there to be no leftovers.
14:37:36 <lambdabot>   Not in scope: `readS'
14:37:49 <nornagon> > reads "23foo" :: [(Int,String)]
14:37:51 <lambdabot>  [(23,"foo")]
14:38:13 <ihope> > readPrec "23foo" :: Int
14:38:14 <lambdabot>   Not in scope: `readPrec'
14:38:28 <nornagon> > readsPrec "23foo" :: [(Int,String)]
14:38:29 <lambdabot>      Expecting a function type, but found `[(Int, String)]'
14:38:29 <lambdabot>       Expected ty...
14:38:31 <nornagon> er.
14:38:36 <nornagon> > readsPrec "23foo"
14:38:36 <ihope> I don't know what I'm doing, do I?
14:38:37 <lambdabot>  Couldn't match `Int' against `[Char]'
14:38:40 <sjanssen> hyrax42: such a thing could be implemented
14:38:44 <nornagon> :t readsPrec
14:38:46 <lambdabot> forall a. (Read a) => Int -> ReadS a
14:38:51 <sorear> @src ReadS
14:38:52 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
14:38:55 <sorear> @src ReadS a
14:38:56 <lambdabot> Source not found. My mind is going. I can feel it.
14:38:58 <sjanssen> hyrax42: my rope implementation is strict though
14:39:00 <ihope> > readsPrec 0 "23foo"
14:39:00 <lambdabot>  Add a type signature
14:39:06 <ihope> @type readsPrec 0 "23foo"
14:39:07 <lambdabot> forall a. (Read a) => [(a, String)]
14:39:08 <sorear> type ReadS a = String -> [(a,String)]
14:39:10 <hyrax42> sjanssen: I ask because the paper refers to a lazy-ish IO idea for a rope representing a file's contents
14:39:32 <hyrax42> sjanssen: did you finish it?
14:39:41 * ihope ponders a Natural type, but decides to use Integer instead
14:40:25 <ihope> It's not entirely obvious how to define a nimber type, now, is it?
14:40:30 <sorear> ihope: Natural isn't a ring.  We have no Semiring class :( :( :(
14:40:42 <ihope> Natural isn't a ring, but the nimbers are.
14:41:08 <sorear> what are nimbers?
14:41:14 <sjanssen> hyrax42: the functionality is complete, but I think it needs benchmarking and polishing
14:41:17 <ihope> Of course, an actual nimber type would require... uh, well, it's impossible, so one has to go with the nimbers less than omega^omega^omega.
14:41:27 <dons> bos,cheers. wouldn't have been possible without someone's PAckedString code ;)
14:41:39 <hyrax42> sjanssen: yeah benchmarking is what I was wondering about
14:41:42 <ihope> sorear: nimbers are the ordinal numbers with arithmetic defined in a weird way.
14:42:03 <ihope> You have things like 1/2 = 3.
14:42:13 <ihope> And 2 and 3 are square roots of each other.
14:42:29 <ihope> And everything is its own opposite.
14:42:34 <sorear> yow, almost as bad as Z[11] :)
14:43:20 <ihope> Integers mod 2, plus everything else.
14:44:20 <sjanssen> dons: your paper earned an award?
14:44:28 <dons> sjanssen: yeah!
14:44:32 <dons> 'most practical paper' :)
14:44:40 <sjanssen> nice title
14:44:41 <matthew-_> which paper? Is it on your site yet?
14:44:50 <dons> we got some euros, and a certificate, and some photos :)
14:44:55 <dons> geek celebrity ;)
14:45:03 <dons> matthew-_: yeah, 'Rewriting Haskell Strings'
14:45:30 <matthew-_> ahh, cool - it didn't change after the draft then?
14:45:46 <dons> only a few things
14:45:49 <dons> the final version is up now
14:46:30 <matthew-_> cheers, and congrats
14:46:41 <dons> thanks!
14:47:29 <sjanssen> dons: is the award online somewhere?  might make a nice reddit post
14:47:39 <dons> heh
14:47:40 <augustss> dons: congrats!
14:47:41 <Korollary> dont do that
14:47:47 <Korollary> @dons++
14:47:48 <lambdabot> Unknown command, try @list
14:47:51 <Korollary> dons++
14:47:52 <dons> sjanssen: the award is mentioned on the fps page
14:47:53 <psnl> dons: well done
14:48:00 <_roconnor> @karma+ dons
14:48:00 <lambdabot> dons's karma raised to 114.
14:48:26 <yaxu> @karma+ dons
14:48:26 <lambdabot> dons's karma raised to 115.
14:48:49 <dons> ok. this is just silly :P
14:49:01 <dons> but nice that a haskell paper took out the 'practical' award, eh!
14:49:14 <ihope> Aye.
14:49:54 <nornagon> dons-- How dare you bring the horrors of practicality to that which is pure!
14:50:12 <NichardRixon> :D
14:50:18 <dons> hehe.
14:51:23 <ihope> Wait, 115?
14:52:08 <nornagon> no, 114.
14:52:25 <sorear> @karma
14:52:25 <lambdabot> You have a karma of 17
14:52:28 <sorear> @karma glguy
14:52:29 <lambdabot> glguy has a karma of 40
14:52:34 <sorear> @karma audreyt
14:52:35 <lambdabot> audreyt has a karma of 70
14:52:38 <ihope> @karma
14:52:38 <lambdabot> You have a karma of 3
14:52:40 <nornagon> @karma
14:52:41 <lambdabot> You have a karma of 5
14:52:41 <ihope> Aww.
14:52:46 <dylan> @karma
14:52:47 <nornagon> \o/
14:52:47 <lambdabot> You have a karma of 2
14:52:59 <sorear> @karma don
14:53:00 <lambdabot> don has a karma of 0
14:53:09 <augustss> @karma
14:53:10 <lambdabot> You have a karma of 3
14:53:12 <nornagon> dylan++
14:53:17 * sorear thought even typos of dons might have karma
14:55:06 <ihope> @karma dosn
14:55:06 <lambdabot> dosn has a karma of 0
14:55:11 <ihope> @karma dnos
14:55:11 <lambdabot> dnos has a karma of 0
14:55:16 <ihope> Hmm.
14:55:20 <ihope> @karma ihope_
14:55:21 <lambdabot> ihope_ has a karma of 0
14:55:28 <ihope> Mmh.
14:55:53 <sorear> @karma DonStewart
14:55:54 <lambdabot> DonStewart has a karma of 0
14:55:59 <ihope> Well, I oughta get working on that nimber thing.
14:56:10 <ihope> @karma Donald Bruce Stewart
14:56:11 <lambdabot> Donald has a karma of 0
14:56:17 <ihope> Hmm.
14:56:22 <augustss> ihope: and post something when it's done.  i wanna see it
14:56:36 <ihope> augustss: will do.
14:57:10 <ihope> The first question is how I should represent one of these nimbers. Should I use that one notation?
14:57:16 <augustss> ihope: and we can put it on reddit ;)
14:57:44 <ihope> Cantor normal form, I mean.
14:58:13 <ihope> Or should I use place values or whatever those are called?
14:58:35 <ihope> I guess Cantor normal form is easiest.
15:00:14 <ihope> data FL a = FLCons a !(FL a) | FLNull -- this is a finite list, right?
15:00:28 <sorear> yes
15:00:39 <sorear> and a strict one at that :)
15:00:41 <hpaste>  glguy pasted "First work towards diff" at http://hpaste.ath.cx:8000/22
15:00:53 <ihope> Do finite lists get any lazier?
15:01:01 <sorear> [1..1000000000] is finite list, but you'll have trouble representing it.
15:01:07 <sorear> ihope: sure
15:01:17 <sorear> ihope: e.g trie arrays could work
15:02:04 <ihope> Um... well, using FL there won't kill anyone, will it? :-)
15:02:24 <ihope> Hopefully none of my lists will be ridiculously huge.
15:02:38 <sorear> oom_killer hits!  oom_killer kicks!
15:02:43 <bd_> ihope: is it necessary to use that rather than just []?
15:02:45 <sorear> You die.
15:02:57 <emk> @karma
15:02:58 <lambdabot> You have a karma of 1
15:02:59 <ihope> bd_: um... no.
15:03:00 <bd_> sorear: But wait! Your amulet of garbage collection glows!
15:03:11 <ihope> Good idea.
15:03:14 <nornagon> sorear: \o/
15:04:08 <bd_> ihope: and, would Data.Array be useful?
15:04:23 <ihope> bd_: maybe.
15:04:46 <ihope> Essentially, I want to express all the ordinal numbers less than omega^omega^omega.
15:04:57 <syntaxfree> aren't Arrays pretty much the default data structure in other languages?
15:05:13 <bd_> ihope: well, I'm not sure how would would define such a number, so... :)
15:06:41 <augustss> ihope: buy more memory
15:07:02 <syntaxfree> or try to start a distributed project  la Gimps.
15:07:19 <ihope> augustss: if Integer lets you express all the integers, I can express all the ordinal numbers less than... uh, that.
15:08:15 <syntaxfree> I'm thinking you can't express as many integers with Data Nat = Zero | Succ Nat as you can with hardware-based Ints.
15:08:31 <ihope> Well... um...
15:08:42 <sorear> syntaxfree: sure you can, with a sufficiently good optimizing compiler :)
15:08:45 <augustss> ihope: as long as you don't want all of them at the same time :)
15:08:50 <astrolabe> ihope: what operations do you want on them?
15:08:55 <sorear> syntaxfree: fix Succ
15:09:03 <ihope> augustss: that would indeed need lots of memory.
15:09:03 <sorear> try repr'ing THAT as an Integer
15:09:03 <sjanssen> sorear: that'd be a damn smart compiler :)
15:09:12 <syntaxfree> :)
15:09:13 <ihope> astrolabe: addition and multiplication to start.
15:09:27 <syntaxfree> I wish there were Haskell Machines.
15:09:34 <ihope> sjanssen: any quantum first-order logic theorem prover should do.
15:09:43 <dons> we have haskell virtual machines instead
15:09:49 <syntaxfree> hehe.
15:09:57 <ihope> astrolabe: after addition and multiplication, it'd be polynomials.
15:10:00 <astrolabe> ihope: interesting.
15:10:05 <syntaxfree> dons: is there any way I can compile lambdabot without readline?
15:10:23 <sorear> syntaxfree: delete OfflineRC from the plugins list
15:10:35 <syntaxfree> sorear: um. in Config.hs?
15:10:41 <sorear> syntaxfree: no wait that will make the bot completely unusable :(
15:10:41 <astrolabe> polynomials of ordinal degree, or with ordinal coefficients?
15:11:03 <ihope> Polynomials with ordinal coefficients.
15:11:05 <sorear> syntaxfree: in Plugins/OfflineRC.hs, find readline "lambdabot> " and hack there
15:11:07 <syntaxfree> I have a perfectly good readline in /usr/local/bin, but Cabal or whatever the installer is refuses to see it.
15:11:15 <augustss> ihope: do nimbers have a notion of inverse?
15:11:22 <sorear> you have readline in */bin !?
15:11:31 <sorear> it should be in */lib
15:11:35 <ihope> Of course, if I can't figure out polynomials, I'll have to stick with square roots and reciprocals and things.
15:11:36 <syntaxfree> oh yeah.
15:11:39 <ihope> augustss: those are polynomials.
15:11:44 <sorear> and readline cabal is a cabal package
15:11:48 <sorear> (extralibs I think)
15:11:53 <ihope> ax - 1 = 0
15:12:06 <astrolabe> nimbers aren't polynomials are they?
15:12:08 <syntaxfree> Mingus:~ syntax$ ls /usr/local/lib/*readline*
15:12:08 <syntaxfree> Mingus:~ syntax$
15:12:16 <augustss> ihope: hmmm.  i was just wondering how to make 'instance Num Nimber'
15:12:28 <astrolabe> but they are contained in a field iirc
15:12:30 <syntaxfree> I have 4.3, 5.0 and 5.2
15:12:35 <ihope> astrolabe: no, but you can define polynomials over nimbers.
15:12:45 <syntaxfree> (nothing came up in the paste because "/usr/local" got read as a command.
15:12:52 <ihope> augustss: division isn't needed for Num, you know.
15:12:57 <astrolabe> augustss: I've done CGT games generally.
15:13:16 <augustss> ihope: I know.  I was referring to additive inverse
15:13:16 <astrolabe> Which form an abelian group
15:13:20 <ihope> Also, nimber addition is conventiently equivalent to nimber subtraction, so that's the same as ax + 1 = 0.
15:13:27 <sorear> syntaxfree: readline, as cabal knows it, is a cabal package not a dylib.
15:13:31 <ihope> Oh, additive inverse? Every nimber is its own additive inverse.
15:13:42 <syntaxfree> sorear: hmm. Now I'm confused.
15:13:45 <augustss> ihope: oh, that's handy
15:13:50 <ihope> Yep.
15:14:06 <augustss> and is there a natural mapping from Integer to Nimber?
15:14:13 <ihope> augustss: not really.
15:14:26 <ihope> After all, in the nimbers, 1 + 1 = 0.
15:14:28 <syntaxfree> gah, I don't even have */Plugin/OfflineRC.hs
15:14:31 <astrolabe> Once you have CGT games, you can define nimber :: Integer -> CGTGame
15:14:40 <sorear> syntaxfree: how old is your bot?
15:14:42 <augustss> ihope: that's fine
15:14:47 <astrolabe> at least on the positive ones
15:14:47 <ihope> Of course, you could translate directly.
15:14:49 <syntaxfree> 4.0?
15:14:57 <sorear> syntaxfree: oldish bots have it in ./IRC.hs
15:15:01 <syntaxfree> 4.0.1
15:15:07 <sorear> @where readline
15:15:08 <lambdabot> I know nothing about readline.
15:15:13 <syntaxfree> hmm. maybe I should get a current source distribution.
15:15:25 <dons> hmm, we should really get Josef Svenningsson's blog on planet haskell
15:15:25 <syntaxfree> hacking on oldish source will get messy.
15:15:32 <ihope> Well, I guess direct translation is pretty easy.
15:15:34 <augustss> astrolabe: where is your CGT code?
15:15:41 <ihope> The new numbers just won't work the same as the old ones.
15:15:50 <syntaxfree> dons: does Planet Haskell have a formal process?
15:15:57 <dons> yeah, you mail ibid
15:16:03 <dons> see the page, it has details for the process
15:16:05 <syntaxfree> I was never told what were the "rules" to get listed.
15:16:07 <syntaxfree> Yes, I'm listed.
15:16:08 <ihope> The nimbers have a characteristic of 2, which pretty much makes them greatly incompatible with the integers, which have a characteristic of 0...
15:16:17 <syntaxfree> I don't know how much off-topic stuff I can post before being unlisted.
15:16:22 <dons> oh, josefs actually links to planet haskell on his pasge
15:16:58 <syntaxfree> sorear: er, how do I get a new-ish copy of the lambdabot sources?
15:17:06 <astrolabe> nimber x | x < 0 = error "neg nimber"; nimber 0 = 0; nimber (n+1) = nimber n + star
15:17:11 <sorear> @where lambdabot
15:17:12 <lambdabot> Right here! Seriously, though: http://www.cse.unsw.edu.au/~dons/lambdabot.html
15:17:34 <syntaxfree> @vote-list
15:17:35 <lambdabot> Unknown command, try @list
15:17:41 <syntaxfree> @help vote
15:17:41 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
15:17:46 <syntaxfree> @poll-list
15:17:47 <lambdabot> ["Written_a_compiler_or_interpreter?","cheeky-off","jabberName"]
15:17:48 <sorear> syntaxfree: your extralibs bundle didn't include readline?
15:17:58 <sorear> @poll-results jabberName
15:17:59 <lambdabot> Poll results for jabberName (Open): Network.Protocol.Xmpp=0, Network.Xmpp=0
15:18:04 <syntaxfree> sorear: maybe. my new ghci is broken too.
15:18:10 <nornagon> @poll-results cheeky-off
15:18:11 <lambdabot> Poll results for cheeky-off (Open): MakeItAbuseCowboyNeal=0, AddFlag=0, No=0, Yes=8
15:18:12 <syntaxfree> what happened to the cheeky-off poll?
15:18:17 <sorear> syntaxfree: you on fbsd?
15:18:19 <astrolabe> augustss: sadly, I did it for a generalisation of CGT to take values in a general poset rather than {Win,Loss}, and it was my first haskell code ever, so you don't want to see it.
15:18:22 <syntaxfree> OS X.
15:18:27 <allbery_b> huh
15:18:30 <allbery_b> readline works fine here
15:18:35 <syntaxfree> Mingus:~ syntax$ uname -a
15:18:36 <syntaxfree> Darwin Mingus.local 7.9.0 Darwin Kernel Version 7.9.0: Wed Mar 30 20:11:17 PST 2005; root:xnu/xnu-517.12.7.obj~1/RELEASE_PPC  Power Macintosh powerpc
15:18:42 <syntaxfree> yeah. readline works for most stuff here.
15:18:44 <sorear> syntaxfree: where did you get ghc?
15:18:51 <augustss> astrolabe: ripe for a rewrite, eh?
15:18:57 <syntaxfree> but since I upgraded to 6.6, ghci is broken.
15:19:06 <syntaxfree> Runs, but no backspace/esc/up-key, etc.
15:19:08 <malebria> @pool-results Written_a_compiler_or_interpreter?
15:19:09 <lambdabot> Poll results for Written_a_compiler_or_interpreter? (Open): No=3, Yes=7
15:19:10 <astrolabe> augustss: give me a mo, and I'll try to knock something up.
15:19:10 <allbery_b> binary from haskell.org/ghc, or macports?
15:19:11 <syntaxfree> even rlwrap won't fix that.
15:19:22 <syntaxfree> source.
15:19:28 <allbery_b> odd
15:19:31 <syntaxfree> haskell.org/ghc has binaries only for 10.4
15:19:33 <mauke> @vote Written_a_compiler_or_interpreter? Yes
15:19:33 <lambdabot> voted on "Yes"
15:19:54 <syntaxfree> @vote cheeky-off Yes
15:19:54 <lambdabot> voted on "Yes"
15:19:56 <sjanssen> @vote Written_a_compiler_or_interpreter? Yes
15:19:57 <lambdabot> voted on "Yes"
15:19:57 <allbery_b> hm.  in what language?
15:19:59 <augustss> @vote Written_a_compiler_or_interpreter? Yes
15:20:00 <lambdabot> voted on "Yes"
15:20:13 <augustss> Can I vote multiple times? :)
15:20:22 <syntaxfree> I don't like the current picture for lambdabot.
15:20:30 <augustss> @vote Written_a_compiler_or_interpreter? Yes
15:20:31 <allbery_b> otoh I did do a control file parser in haskell which might count as an interpreter of sorts
15:20:31 <syntaxfree> I'd prefer lambdabot to be a cute pet like Dust Puppy.
15:20:31 <lambdabot> voted on "Yes"
15:20:43 <syntaxfree> lambdabot does look like Dust Puppy when I do this:
15:20:45 <syntaxfree> @get-shapr
15:20:45 <lambdabot> shapr!!
15:20:51 <sjanssen> hmm, that should probably be fixed
15:20:57 <dons> heh
15:21:23 <syntaxfree> I'd like to have my own get-diego.
15:21:30 <allbery_b> @vote Written_a_compiler_or_interpreter? Yes
15:21:31 <lambdabot> voted on "Yes"
15:21:38 <ihope> Now, the problem with a combinatorial game datatype is doing ZFC in Haskell.
15:21:46 <sorear> well it's get-shapr not get-shae, so ...
15:21:46 <dcoutts> dons, you're back!
15:21:50 <dons> dcoutts: yeah
15:21:55 <dons> just landed a couple of hours ago
15:22:02 <syntaxfree> get-syntaxfree is just ugly.
15:22:05 <allbery_b>  @vote Written_a_monad_tutorial? No_and_I_dont_plan_to :)
15:22:06 <orbitz> dons: are you arms tired?
15:22:12 <orbitz> @get-syntaxfree
15:22:12 <lambdabot> Unknown command, try @list
15:22:15 <dons> heh
15:22:19 <syntaxfree> I'd like to change my nickname, but I guess I'm stuck with it.
15:22:35 <sorear> there's also no get-dons
15:22:42 <merus> ihope: Oooh!  That sounds like fun.
15:23:01 <syntaxfree> I have no idea of how open source development works.
15:23:11 <ihope> merus: I called it a problem for a reason.
15:23:13 <sorear> ZFC == Zeremello-Frankle + Axiom of Choice? what does that have to do with games?
15:23:29 <merus> ihope: Set can't be turned into a monad, I don't think :(
15:23:38 <syntaxfree> games as in game theory?
15:23:39 <dcoutts> dons, for the writeN/writeN I got it working using an integrated Put monad rather than Put = Writer Builder
15:23:43 <merus> ._____.;
15:23:44 * sorear is good at mangling names, esp. non-anglo-american ones
15:23:46 <dons> ah good
15:23:51 <ihope> Also, astrolabe: star + star is not the nimber 2.
15:23:51 <dcoutts> dons, since that allows rules on the >>
15:23:57 <dons> dcoutts: so one less level of indirection/inlining?
15:23:59 <ihope> syntaxfree: combinatorial game theory.
15:24:02 <dons> meaning more stable matching?
15:24:05 <syntaxfree> ahh. I see.
15:24:20 <dcoutts> dons, perhaps that too, but basically no lambdas since a direct >> not >>=
15:24:24 <dons> ah ok
15:24:25 <dons> yes
15:24:31 <syntaxfree> if I ever fix/change something significant in lambdabot -- something that's nontrivial -- do I send back into the repository?
15:24:36 <dons> but what about the  f (>> g (>> h i) issue
15:24:49 <syntaxfree> I mean, hell, if I change vixen to act like a bad rap-rocker or something.
15:24:51 <sjanssen> syntaxfree: most definitely
15:24:55 <dons> where things aren't in the form (f >> g) >> (h ..
15:25:06 <dcoutts> dons, no problem, eventually it's either left or right associative without lambdas
15:25:06 <sorear> dons: bundle sent, fixing build
15:25:11 <syntaxfree> so, um, basically, there's someone who reviews changes.
15:25:13 <sjanssen> syntaxfree: as long as the change is an improvement :)
15:25:18 <dons> syntaxfree: right.
15:25:22 <sorear> just watch out
15:25:24 <dons> you have to get the maintainer to agree
15:25:25 <syntaxfree> oh.
15:25:31 <sorear> you send too many good patches, and
15:25:32 <dons> so if you do lots of stuff, you need to talk  to the maintainer first
15:25:37 <dons> and build confidence
15:25:38 <sorear> they stop reading
15:25:40 <sorear> 'em
15:25:41 <dcoutts> dons, I've only got a mockup for the rules though, no full impl yet so we'll see if it really works out
15:25:44 <dons> its a social process
15:25:45 <ihope> Well, I oughta get back to actually doing this nimber stuff.
15:25:47 <dons> sorear: right ;)
15:25:51 <syntaxfree> I see.
15:25:54 <dons> if you send enough good stuff, they stop reading
15:25:59 <dcoutts> dons, kolmodin, anyway g'night!
15:26:00 <dons> then you insert your trojans
15:26:06 <dons> night dcoutts
15:26:12 <syntaxfree> Heh. I'm not really thinking of trojans.
15:26:16 <syntaxfree> I'm thinking of get-diego.
15:26:18 <sorear> so 20 good patches + 1 slip = dead bot
15:26:27 * sorear has done this
15:26:29 <dons> sorear: you've had experience of tihs?
15:26:31 <dons> :)
15:26:36 <dons> and then you better fix it quick
15:26:54 <dons> or you end up back at square 1 for a week or so, were all the patches get reviewed again
15:26:54 <syntaxfree> so, besides sorear, who else is hacking on lambdabot these days?
15:27:02 <dons> me
15:27:06 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/07.01.07:18:27:43 <shapr> All over freenode, weeping is heard as lambdabot stays gone for MINUTES!
15:27:07 <dons> darcs changes will tell you
15:27:07 <syntaxfree> well, not you!
15:27:13 <dons> we've had nearly 100 contributors over the years though
15:27:16 <syntaxfree> dons: don't you ever get tired of this?
15:27:19 * merus needs a copy of _On Numbers and Games_
15:27:22 * sjanssen writes a lambdabot patch here and there
15:27:26 * sorear loves having the logs on a local disk
15:27:28 <dons> yeah, sjanssen too
15:27:36 <dons> syntaxfree: tired of what? patches? no!
15:27:37 <dons> never!
15:27:41 <ihope> merus: and Winning Ways?
15:27:44 <syntaxfree> reviewing code!
15:27:45 <dons> more patches for all!
15:27:53 <syntaxfree> Mingus:~ syntax$ darcs changes  http://www.cse.unsw.edu.au/~dons/lambdabot
15:27:53 <syntaxfree> Changes to http:/www.cse.unsw.edu.au/~dons/lambdabot:
15:27:53 <syntaxfree> Can't find changes prior to:
15:27:53 <syntaxfree> Tue Jun 27 19:09:39 BRT 2006  dnavarro@gmail.com
15:27:53 <syntaxfree>   * Initial Revision
15:27:53 <lambdabot> Title: Index of /~dons/lambdabot
15:27:56 <dons> nah, its like reading the news
15:27:57 <syntaxfree> oops. paste too long. sorry.
15:27:58 <merus> ihope: I'd never heard of Winning Ways.
15:28:09 <ihope> Winning Ways for your Mathematical Plays?
15:28:15 <dons> maybe cause i also teach coding, it doesn't seem so bad.
15:28:20 <sjanssen> syntaxfree: dons is actually a strange lifeform that feeds on patches
15:28:23 <merus> Yeah, Wiki has enlightened me.  I need a copy of that too.
15:28:26 <dons> i wish my students would send me darcs patches
15:28:42 <dons> instead of asking me to look at their code after class
15:28:42 <syntaxfree> it sounds like an annoying role, reviewing patches.
15:28:43 <merus> Also, enough free time to read them both.
15:28:59 <dons> syntaxfree: well, maybe if you didn't care about the project
15:29:21 <hpaste>  glguy annotated "First work towards diff" with "working diff code" at http://hpaste.ath.cx:8000/22#1
15:29:31 <dons> sjanssen: that's true. i feel bad if i don't have new patches in my mailbox every morning
15:29:33 <syntaxfree> I'd rather hack on someone else's project that maintain a repository I think.
15:29:36 <dons> then i have to go code up my own!
15:29:45 <syntaxfree> Then again, maintainers get most of the glory I guess :)
15:29:56 <astrolabe> augustss: I'm embarassed, I'm very rusty with them, I'll have something in a while.
15:30:22 <dons> sorear: so you want to hack up Oleg and Shan's implicit configurations for lambdabot?
15:30:27 <dons> instead of this .rc file stuff
15:30:29 <dons> ;)
15:30:30 <syntaxfree> sorear: I didn't understand what you said a while ago about lambdabot seeing readline as a Cabal package, not  a dylib.
15:30:59 * merus is irked that his uni library lacks a copy.
15:31:06 <merus> But not surprised.
15:31:11 <syntaxfree> import System.Console.Readline( readline, addHistory )
15:31:12 <syntaxfree> ahh.
15:31:17 <syntaxfree> Ok, now I see.
15:31:31 <dons> its probably easier to get readline on your box, than work around that
15:31:34 <syntaxfree> what should be the type of Readline.readline?
15:31:42 <syntaxfree> dons: I have readline. I can't get ghc to see it.
15:31:55 <syntaxfree> :t System.Console.Readline.readline
15:31:57 <lambdabot> String -> IO (Maybe String)
15:32:01 <allbery_b> oh
15:32:09 <allbery_b> you have the readline in /usr/lib?
15:32:10 <syntaxfree> > IO Just "Hello"
15:32:11 <lambdabot>   Not in scope: data constructor `IO'
15:32:12 <allbery_b> it's duff
15:32:17 <syntaxfree> :t IO (Just Hello)
15:32:18 <lambdabot> Not in scope: data constructor `IO'
15:32:19 <lambdabot>  
15:32:19 <lambdabot> <interactive>:1:9: Not in scope: data constructor `Hello'
15:32:34 <syntaxfree> :t IO (Just "Hello")
15:32:35 <lambdabot> Not in scope: data constructor `IO'
15:32:38 <allbery_b> it's not really readline; it's editline renamed, and is missing most of what the real readline does
15:32:42 <syntaxfree> isn't IO a data constructor? :(
15:32:50 <syntaxfree> allbery: /usr/local/lib
15:32:50 <dons> yeah
15:32:55 <dons> ?src IO
15:32:55 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
15:33:06 <syntaxfree> well, it *is* a data constructor, damnit.
15:33:16 <syntaxfree> :t print (Just "Hello")
15:33:18 <lambdabot> IO ()
15:33:34 <allbery_b> :t System.IO.IO (Just "Hello")
15:33:35 <lambdabot> Not in scope: data constructor `System.IO.IO'
15:33:38 <syntaxfree> maybe I should just change replLoop to undefined
15:33:39 <allbery_b> o well
15:34:11 <sorear> syntaxfree: comment out addHistory, and change readline to Just `fmap` getLine
15:34:30 <sorear> :t getLine
15:34:32 <lambdabot> IO String
15:34:36 <sorear> ok good
15:34:55 <syntaxfree> ah, yes.
15:36:17 <syntaxfree> well, anyone wants to volunteer as administrator of Maurabot?
15:36:22 <syntaxfree> it will hang out only in #haskell.br
15:36:24 <syntaxfree> (if it ever compiles)
15:36:57 <syntaxfree> uhh. Config.hs is quite different from last time I saw it.
15:37:38 <syntaxfree> oh, it's in IRCBase.hs
15:37:48 <sorear> what would $( diff muarabot lambdabot ) be? portugese?
15:38:07 <syntaxfree> sorear: just something to test/hack on
15:38:45 <syntaxfree> Config.hs changed a lot! Where are the IRC server, channel, nickname, etc. settings?
15:39:07 <sorear> syntaxfree: online.rc
15:39:17 <sorear> syntaxfree: all that's been made into ordinary commands
15:39:30 <syntaxfree> ahh.
15:39:34 * sorear away, reason: X, reason: xpdf, reason: Implicit configurations
15:39:40 <syntaxfree> cool.
15:40:32 <dons> sorear: oops
15:40:46 <dons> i was only semi-joking
15:40:58 <dons> but you could perhaps evaluate the practicality of using that system
15:41:07 <kolmodin> bos: is your rope implementation online somewhere?
15:42:58 <syntaxfree> bah, it's still complaining about Setup.hs: cannot satisfy dependency readline-any
15:43:05 <syntaxfree> I think I need to remove it in the configure script.
15:43:08 <syntaxfree> Any pointers?
15:43:16 <sorear> oh, you'll need to delete it in lambdabot.cabal
15:44:03 <syntaxfree> jesus. I want to give up. It wants zlib now.
15:44:27 <ihope> Did I say I was working on the nimber thing?
15:44:41 <merus> ihope: yeah.
15:45:26 <ihope> I'll let you do it, if you want. :-P
15:46:41 <merus> ihope: don't know enough about nimbers.
15:46:52 <merus> or, for that matter, haskell.
15:48:47 <merus> About the biggest thing I can do in haskell at the moment is teach it the Boolean algebra rules so I don't have to write out proofs by hand.
15:48:49 <merus> =/
15:50:08 <sorear> @where zlib
15:50:09 <lambdabot> darcs get http://haskell.org/~duncan/zlib
15:50:27 <syntaxfree> I have zlib, ghc doesn't know about it.
15:50:32 <syntaxfree> I'm pretty much giving up/
15:50:39 <sorear> ^^^ easy to install, requires 6.6 now (unrecord the most recent patch for 6.4)
15:51:12 <sorear> zlib is overloaded - as a cabal package it means dcoutts_' binding to zlib :: CLibrary
15:52:58 <dons> zlib's pretty easy to get going
15:53:03 <dons> its just a standard cabal build
15:55:06 <sjanssen> syntaxfree: you have the Haskell library zlib, or you have the C library?
15:55:12 <glguy> how do I use qualified operator names?
15:55:17 <syntaxfree> I have the .dylib
15:55:18 <glguy> (!) in Array and XHtml are conflicting
15:55:26 <kolmodin> that's it for me, good night!
15:55:42 <sjanssen> syntaxfree: the zlib we're referring to is a separate thing
15:55:59 <dons> night kolmodin
15:56:31 <sjanssen> syntaxfree: it is a wrapper of the C zlib library
15:56:36 <allbery_b> foo Array.! bar
15:56:38 <nmessenger> glguy: (Array.!) yourArray yourIndex, or yourArray Array.! yourIndex
15:57:11 <sorear> uh, what are you using Array for?
15:57:22 <nmessenger> or foo ! bar where (!) = (Array.!) ;-)
15:57:23 <glguy> sorear: memoizing in my lcs
15:57:27 <sorear> ok
15:57:34 <glguy> the algorithm seems to work
15:57:39 <glguy> now I'm going to add a page to hpaste
15:57:41 <glguy> to see it in action
15:57:51 <sorear> {-# MEMOIZE #-} would be so much easier ...
15:58:34 <syntaxfree> sjanssen: gah. I'm tired of hacking for today. I'm going to sleep.
15:59:45 <dons> its on my todo list to make 6.6 and lambdabot a bit easier to work with
15:59:46 <dons> and fix goa
16:06:10 <rc-1> http://mathworld.wolfram.com/TuppersSelf-ReferentialFormula.html
16:06:11 <lambdabot> Title: Tupper's Self-Referential Formula -- from Wolfram MathWorld
16:07:47 <nmessenger> wait, so this function plots a picture of itself?!
16:08:03 <rc-1> yes
16:08:42 <rc-1> know how he found it?
16:08:48 <nmessenger> how?
16:09:28 <ihope> Trial and error, of course.
16:09:42 <maskd> you can draw everything with this formula
16:09:42 <lambdabot> maskd: You have 1 new message. '/msg lambdabot @messages' to read it.
16:10:09 <ihope> It cheats!
16:10:16 <nmessenger> maskd, so it depends on the bounds for x and y?
16:11:15 <ihope> nmessenger: there's a reason for the huge n.
16:11:34 <nmessenger> What notation is being used for 'n'?  I'm not familiar with it.
16:11:53 <allbery_b> some sort of godel numbering of the formula itself?
16:12:38 <nmessenger> allbery_b, probably a goedel numbering of a bitmap image representation of it.
16:12:42 <allbery_b> ...or just of pixels, yeh
16:12:44 <rc-1> wasnt sure, so couldnt figure out what was going on
16:13:17 <astrolabe> augustss: still about?
16:13:24 * allbery_b suspected from the huge number input that it was an encoding of the result
16:13:34 <maskd> http://reddit.com/info/yxxw/comments/cz06u
16:13:37 <lambdabot> Title: This is by far the most mind-blowing mathematical function I have ever seen. (re ...
16:13:41 <glguy> http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=0&toId2=1
16:14:48 <astrolabe> how do leave a message for someone?
16:14:54 <ihope> @message
16:14:54 <nmessenger> astrolabe, @tell
16:14:54 <lambdabot> Maybe you meant: messages messages?
16:14:59 <ihope> Or that.
16:15:17 <nmessenger> @help tell
16:15:17 <lambdabot> tell <nick> <message>. When <nick> shows activity, tell them <message>.
16:15:31 <astrolabe> ihope: thanks
16:16:16 <astrolabe> !paste
16:16:18 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
16:18:52 <hpaste>  astrolabe pasted "Initial CGT code" at http://hpaste.ath.cx:8000/23
16:19:15 <ihope> Wow...
16:19:29 <syntaxfree> @tell lambdabot he doth complaineth too much.
16:19:30 <lambdabot> Nice try ;)
16:19:44 <syntaxfree> @vote cheeky-off Yes
16:19:44 <lambdabot> voted on "Yes"
16:19:52 <astrolabe> @tell augustss: Just a sketch http://hpaste.ath.cx:8000/23
16:19:53 <lambdabot> Consider it noted.
16:19:57 <glguy> no comments on the url I posted? http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=0&toId2=1
16:20:32 <allbery_b> lighten the colors a bit
16:20:40 <syntaxfree> so, how do I get the Haskell bindings for zlib / readline anyway?
16:20:40 <glguy> not about the colors :-p
16:20:44 <allbery_b> it's distractingly garish as is :)
16:20:45 <glguy> that's definitely not done
16:21:41 <Pseudonym> I must say, that formula is a nice piece of function minimisation.
16:21:42 <syntaxfree> The colors should at least be consistent.
16:22:22 <yaxu> http://wellstyled.com/tools/colorscheme2/index-en.html # good for choosing colour schemes
16:22:25 <lambdabot> Title: [ws] Color Scheme Generator 2
16:22:31 <Pseudonym> It's be cooler if n was encoded in the image, though.
16:22:36 <syntaxfree> Color Scheme?
16:22:41 <syntaxfree> Like Scheme but in Colour?
16:22:42 <allbery_b> as someone reading it, it seems the common blank linme ought to be "ignored" and the diffs merged.  as a programmer, I'm not sure there's a good way to do that
16:22:46 <syntaxfree> It should fit well
16:22:51 <syntaxfree> with my Color Computer.
16:22:55 <allbery_b> diff schemes are no good at semantics :)
16:23:06 <ihope> astrolabe: that nimber function isn't... well, it doesn't work, I think.
16:23:07 <glguy> should I do whole line colors or what I'm showing now?
16:23:14 <yaxu> syntaxfree: all identifiers are hues
16:23:25 <syntaxfree> yaxu: hehehe
16:23:30 <facenew> OT: a 30-min movie mocking kim jong il and his secret agent buying something from china: http://www.youtube.com/view_play_list?p=EE52D9ED01495685
16:23:31 <lambdabot> Title: YouTube - Broadcast Yourself.
16:23:31 <ihope> star n has star x where x < n as the options for both players.
16:23:51 <astrolabe> ihope: your right!
16:24:03 <astrolabe> you're
16:24:24 <astrolabe> curses! :)
16:24:38 <syntaxfree> ncurses?
16:25:25 <nornagon> vte man
16:25:27 <nornagon> er
16:25:28 <nornagon> vty
16:25:48 <astrolabe> ihope: nimber (n+1) = CGTRep [nimber n] [nimber n]?
16:26:13 <astrolabe> Ah no, it's worse than that
16:27:51 <syntaxfree> real men use paper!
16:27:51 <syntaxfree> glass ttys are for weenies!
16:27:53 <astrolabe> nimber (n+1) = CGTRep less less where less = map nimber [0..n]
16:28:46 <ihope> astrolabe: sounds right.
16:29:32 <astrolabe> ihope: my bedtime.  Feel free to fix the code :)
16:38:33 <psnl> " thread blocked indefinitely" <- this implies that all threads are blocked, right?
16:43:41 <dons> ?uptime
16:43:42 <lambdabot> uptime: 1d 23h 49m 23s, longest uptime: 2d 3h 42m 19s
16:50:11 <dons> http://sequence.complete.org/node/258 mmm
16:50:13 <lambdabot> Title: A simple TCP server | The Haskell Sequence
16:50:15 <dons> mrd++
16:50:19 <dons> @seen mrd
16:50:19 <lambdabot> I haven't seen mrd.
16:52:21 <dons> here we go, http://programming.reddit.com/info/zmmy/comments
16:55:06 <Kaboem> sorry thing was disconected sudenly, what does the @ mean?
16:58:47 <Kaboem> ex.:
16:58:47 <Kaboem> dereference :: PrologEnv -> Int -> PrologData
16:58:47 <Kaboem> dereference r@(Env _ heap) var  =
16:58:47 <Kaboem>     dereference2 (lookup heap var) r var
17:00:13 <Cale> Kaboem: r is bound to whatever  (Env _ heap)  matches
17:00:15 <nmessenger> > (\(list@(head:tail)) -> (list, head, tail)) [1,2,3]
17:01:31 <glguy> aww, screw colors for now :-p http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=0&toId2=1
17:01:51 <Cale> In general  var@pat  will match pat, and bind any variables inside it, as well as binding the entire matched piece of data to var
17:07:10 <nmessenger> is LB asleep?
17:08:05 <allbery_b> @Bot
17:08:08 <allbery_b> huh
17:08:17 <allbery_b> where'd the titlecase come from :/
17:08:33 <allbery_b> ...wakey wakey...
17:08:43 <dons> ?bot
17:09:51 <allbery_b> @bot
17:10:06 <lambdabot> :)
17:10:23 <sorear> tell fodder
17:10:27 <sorear> @version
17:10:32 <lambdabot> lambdabot 4p476, GHC 6.5 (OpenBSD i386)
17:10:34 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:10:42 <sorear> @paste
17:10:43 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
17:10:59 <sorear> hm, what happened to the bot?
17:11:12 <allbery_b> not sure
17:11:37 <glguy> anyone know what VNC listener viewer listens on?
17:11:56 <sorear> 7900 i think
17:12:31 <sorear> vnc               5900/tcp   # Virtual Network Computer display 0
17:12:38 <glguy> oh, if you hover over it
17:12:42 <glguy> it says: listening on 5500
17:12:44 <sorear> from /usr/share/nmap/nmap-services
17:13:02 <allbery_b> vnc server listens on 5900+displaynum
17:13:08 <glguy> 5500 is when you are listening for a server connection
17:13:28 <allbery_b> 5800+x is micro web server w/java applet
17:14:18 <allbery_b> yeh, vnc faq says listener is 5500+x
17:14:26 <allbery_b> no, just 5500
17:15:22 <sorear> too bad @last doesn't work
17:20:39 <sorear> @users
17:20:42 <lambdabot> Maximum users seen in #haskell: 311, currently: 282 (90.7%), active: 5 (1.8%)
17:20:44 <sorear> @bot
17:20:45 <lambdabot> :)
17:20:48 <sorear> @activity
17:20:49 <lambdabot> 2*total 2*#haskell
17:20:52 <sorear> @activity 999
17:20:53 <lambdabot> 15*total 7*private 7*#haskell 1*#gentoo-uy
17:22:24 <emk> My Haskell program is eating an infinite amount of core...
17:22:45 <sorear> ok...
17:22:54 <emk> I'm guessing that it's leaving too many thunks uncomputed. :-(
17:23:02 <dons> done some profiling?
17:23:08 <emk> dons: Working on it.
17:23:11 <dons> if not, compile with -prof -auto-all -O
17:23:13 <sorear> dons: what happened to the bot?
17:23:18 <glguy> sorear http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=0&toId2=1
17:23:19 <dons> and run with +RTS -p
17:23:22 <dons> sor	not sure...
17:23:49 <sorear> idiot
17:23:51 <sorear> stefan@stefans:~/lb-sorear$ links http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=0&toId2=1
17:23:54 <sorear> [1] 9733
17:23:57 <sorear> [2] 9734
17:23:59 <sorear> [3] 9735
17:23:59 <allbery_b> heh
17:24:17 <glguy> ?
17:24:24 <allbery_b> unquoted &s
17:24:58 <sorear> glguy: it looks like colorized diff output.
17:25:05 <sorear> s/diff -u
17:26:03 <sorear> if you're asking whether it looks good, then yes
17:27:17 <sorear> http://hpaste.ath.cx:8000/diff?fromId=17&toId=17&fromId2=1&toId2=1   --->    Error reading from socket
17:36:17 <Procyon> Hello.  Haskell noob here.  I have a question involving an approach to implementing a trivially type inferring language for Genetic Programming.
17:36:32 <sorear> nice
17:36:50 <sorear> type inference is easy and elegant in very simple cases
17:37:01 <Procyon> I want a language that is basically an SKI combinator language
17:37:02 <sorear> @join #haskell.br
17:37:16 <sorear> Procyon: I implemented a type infering ski
17:37:59 <sorear> http://members.cox.net/stefanor/fixtypes
17:38:28 <sorear> just a self-education experiment, rather more complicated than it needs to be...
17:38:31 <Procyon> sorear: page not found
17:38:31 <merus> sorear: 404
17:38:47 <sorear> try again, I uploaded it about 10s ago
17:39:14 * sorear goes to de-obfuscate the unifyer from the 590 character curry-howard prover
17:39:25 <Procyon> Since I want to operate on typed values, can I embed the language in haskell and use it's type inferrence, or should I write my own type inferrence?
17:40:09 <sorear> sure
17:40:19 <sorear> embedding it in haskell is easy
17:40:26 <sorear> (at least with GADT)
17:40:28 <sorear> !paste
17:40:29 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
17:40:50 <nmessenger> > let s = ap; i = id; k = const in (s i i) (s i i)
17:40:51 <lambdabot>      Occurs check: cannot construct the infinite type: a = a -> b
17:40:52 <lambdabot>       Expec...
17:41:50 <hpaste>  sorear pasted "simple embedding of simply-typed ski" at http://hpaste.ath.cx:8000/24
17:42:24 <sorear> nmessenger: nice try. fixtypes above is the only known strongly typed lc that allows that.
17:43:01 <sorear> Expr> s
17:43:01 <sorear> (a -> b -> c) -> (a -> b) -> a -> c
17:43:01 <sorear> Expr> sii(sii)
17:43:01 <sorear> a
17:43:26 * sorear can't help bragging ...
17:43:56 <emk> dons: How accurate is GHC's profiler?
17:45:35 <Procyon> Ok, given the type of ski, lets say I have a list of typed primitives (+, -, 0, 1, 'a') I would like to use in my parse tree.  Can I, if I embed the type inferrence, easily choose from the functions in this list whos types unify to a legal type for their position in the tree?
17:46:14 <sorear> probably not
17:46:35 <sorear> the haskell unifyer is not well reflected into haskell's value layer
17:46:41 <Procyon> :)  So I'm writing my own type inferrence then...  *sigh*
17:46:47 <sorear> it's easy!
17:46:55 <sorear> i've done it 3 times already!
17:47:34 <sorear> there is a very natural expression of unification as an induction on the structure of types
17:47:41 <Procyon> -> haskell noob here.  Writing "guess my number" is easy at this point...  Type unification breaks my brain.
17:47:42 <sorear> I'll de-obfuscate it for you
17:48:01 <Procyon> k
17:48:14 <Procyon> I would much appreciate that
17:48:25 <sorear> beware, when I wrote this code I was focusing on character count
17:48:48 <sorear> a theorem prover in 590 characters is impressive but not very enlightening
17:48:53 <Procyon> hehe
17:51:19 <Procyon> sorear: http://members.cox.net/stefanor/fixtypes/ is no longer giving me a 404.  It's now giving me a null page.  FYI
17:53:00 <sorear> i'm not teribly suprised, I have 30M of data and a 10M quota, it probably got truncated
17:53:09 <Procyon> :)
17:53:11 * sorear deletes his 28MB of ghc history
17:53:32 <sorear> re-upload of fixtypes started
17:53:48 <Procyon> There it is
17:54:14 <sorear> but I wrote fixtypes to prove that a type system extension (fixpoint types) was feasable
17:54:32 <sorear> it's a lot more complicated than a unifier w/o fixpoint types would be
17:55:22 <sorear> (OTOH it's much faster - rephrasing HM as a graph algorithm guarantees polynomial time, while the tree version is exponential)
17:56:22 <sorear> so, is the universe of logic made of propositons?
17:56:37 * sorear gets a lot of humor from typos
17:56:51 <Procyon> (I was about to ask that.. since I will be doing random trees, hitting on exponential cases that break the traditional type inferrence algorithm will likely be common)
17:57:34 <sorear> it might be possible to graft a occurs check onto the fixtypes unifyer,
17:57:56 <sorear> but I haven't touched that code in months, its motivation accomplished.
17:58:12 <sorear> undocumented, unrefactored, prob. twice as long as it needs to be.
17:58:29 <sorear> It did get me into HWN however
17:58:32 <sorear> @quote sorear
17:58:33 <lambdabot> sorear says: ghc's map fusion is provably incorrect
17:58:34 <sorear> @quote sorear
17:58:35 <lambdabot> sorear says: ghc's map fusion is provably incorrect
17:58:38 <sorear> @quote sorear inf
17:58:39 <lambdabot> sorear says: Haskell is amazing. I'm still working on my infinite-types unifier, and in a day I've added sums, products, and lambda abstractions, refactored the code until there was a net *decrease*
17:58:40 <lambdabot> in LOC, and helped man #haskell all at the same time. This'd take me a week in C, no doubt.
18:00:27 <emk> Are there any tutorials talking about how to optimize Haskell code for munging (say) 100,000+ data records?
18:01:06 <sorear> not iirc
18:01:21 <Procyon> ski_unification.hs:146:40:
18:01:21 <Procyon>     No instance for (Monad ((->) (Data.Map.Map Char FullType)))
18:01:21 <Procyon>       arising from use of `liftM2' at ski_unification.hs:146:40-45
18:01:21 <Procyon>     Probable fix:
18:01:21 <Procyon>       add an instance declaration for (Monad ((->) (Data.Map.Map Char FullType)))
18:01:21 <Procyon>     In the first argument of `liftM2', namely `(liftM2 apply)'
18:01:23 <Procyon>     In the second argument of `(>>)', namely `liftM2 (liftM2 apply) funsym funsym'
18:01:25 <Procyon>     In the list element: (schar '`') >> (liftM2 (liftM2 apply) funsym funsym)
18:01:40 <emk> I really want to use Haskell for this project, but there's going to be an ocean of data...
18:01:59 <sorear> Procyon: IRC servers impose draconian rate limiting on anything longer than 5 lines, @paste is recommended
18:02:09 <emk> 25% of the speed of C would be acceptable performance.
18:02:28 <sorear> emk: under the right conditions ... a throwaway haskell program of mine munged 10GB of data in 30s
18:02:32 <Pseudonym> emk, I think it largely depends what you're doing.
18:02:43 <sorear> it was much faster than the perl version
18:02:48 <mauke> Procyon: sounds like a missing import Control.Monad.Reader
18:03:16 <Pseudonym> From my database server hacking days, I know full well that how long it takes to munge terabytes of data largely depends on what the data is and what you want to do with it, regardless of the language.
18:03:35 <emk> Right now, I'm reading in 125,000 one-line data records (dates and a few floats), parsing them, and dumping them again. I'm getting about 1,000 records/second.
18:04:00 <sorear> emk: use ByteString for parsing, use -O (makes a BIG difference)
18:04:20 <Pseudonym> Yes, that's important.  Standard I/O is the cause of a lot of Haskell performance issues.
18:04:26 <emk> I'm already using -O. :-(
18:04:40 <Pseudonym> Avoid using lazy-stream-of-char as strings.
18:04:42 <Procyon> sorear: adding an import for Control.Monad.Reader fixed it.  Thx
18:04:54 <emk> Actually, it seems like "read" and "show" are killing me at the moment.
18:06:11 <sorear> emk: read is DEATH
18:06:13 <emk> Pseudonym: Is it OK to to use a lazy [String] (or [ByteString]), and map a function over it? My program runs as a filter.
18:06:21 <sorear> emk: yes
18:06:31 <Pseudonym> Sure.
18:06:37 <emk> So it's just the String itself that shouldn't be lazy.
18:07:00 <sorear> emk: infact that's a quite typical pattern - my 300MB/s filter was interact $ unlines . concatMap tails . lines
18:07:15 <sorear> (with appropriate bytestring qualifications)
18:07:40 <emk> sorear: OK, so "unlines . map f . lines" is a reasonable thing to do.
18:08:01 <emk> How much can I trust the profiler, by the way?
18:08:20 <Pseudonym> You can trust the profiler perfectly.  It's never wrong.
18:08:28 <Pseudonym> It's occasionally useless, but never wrong.
18:08:36 <emk> If function A is creating lazy thunks, and B is forcing them, who gets charged?
18:08:38 <Pseudonym> Adding cost centres usually fixes the uselessness.
18:09:28 <emk> And would I be better off using parsec than read?
18:09:51 <emk> (Sorry for all the questions; I'm just trying to get a feel for how to build this sort thing.)
18:09:59 <Pseudonym> Nah, that's cool.
18:10:11 <Pseudonym> OK, function A gets charged for its own thunks.
18:10:19 <Pseudonym> I think what you're asking, though, about call graphs.
18:10:36 <Pseudonym> You really need cost centres, BTW, because of higher-order functions.
18:10:53 <sorear> emk: Parsec forces you to use [Char]  -->  SLOW
18:11:02 <Pseudonym> Imagine what a Haskell call graph looks like.
18:11:12 <Pseudonym> Everything at the top is IO's bind method.
18:11:22 <Pseudonym> And lots of things call foldr, which then calls other things.
18:11:27 <sorear> use readInt, a special ByteString function.
18:11:29 <Pseudonym> Higher-order functions tend to be "bottlenecks".
18:11:46 <sorear> it is rumored readInt was created for the shootout.
18:11:46 <syntaxfree> people are using #haskell-blah to discuss Haskell!
18:12:05 <Pseudonym> Take them out and shoot them with Arrows!
18:12:23 <emk> sorear: How should I write a filter that reads a ByteString from standard input, splits it into lines, munges them, joins them, and writes them to standard output?
18:12:27 <syntaxfree> :t readInt
18:12:29 <lambdabot> forall a. (Num a) => a -> (Char -> Bool) -> (Char -> Int) -> ReadS a
18:12:36 <syntaxfree> ?
18:12:36 * allbery_b was thinking we had #haskell-blah and #haskell-overflow kinda confused, yeh :)
18:12:51 <allbery_b> of course I also wasn't that helpful :/
18:12:59 <syntaxfree> isn't #haskell-overflow for pastes?
18:14:00 <sorear> :t Data.ByteString.readInt
18:14:02 <lambdabot> Not in scope: `Data.ByteString.readInt'
18:14:04 <sorear> :t Data.ByteString.readInteger
18:14:06 <lambdabot> Not in scope: `Data.ByteString.readInteger'
18:14:35 <sorear> :t Data.ByteString.Char8.readInt
18:14:36 <dons> emk, how about getContents >>= unlines. munge . lines
18:14:37 <lambdabot> Data.ByteString.Base.ByteString -> Maybe (Int, Data.ByteString.Base.ByteString)
18:15:11 <syntaxfree> hmm.
18:15:29 <emk> dons: Doesn't that run over String, not ByteString? I've got serious performance issues.
18:16:12 <syntaxfree> :t Data.ByteString.Char8.lines
18:16:14 <lambdabot> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
18:16:38 <dons> emk
18:16:39 <dons> import qualified Data.ByteString.Lazy.Char8 as L
18:16:39 <dons> main = L.putStr . L.unlines . map L.reverse . L.lines =<< L.getContents
18:16:51 <dons> no, it uses the bytestring IO functions
18:16:55 <Pseudonym> :t Data.ByteString.Lazy.Char8.getContents
18:16:57 <emk> dons: Ah. Very slick!
18:16:57 <lambdabot> IO Data.ByteString.Lazy.ByteString
18:17:03 <syntaxfree> wait.
18:17:11 <syntaxfree> does ByteString have its own getContents?
18:17:14 <dons> it dooes
18:17:19 <Pseudonym> Now if only we had a ByteString version of Read, we'd be set.
18:17:21 <dons> and readFile, and the rest
18:17:26 <syntaxfree> hmm.
18:17:30 <dons> Pseudonym: yeah
18:17:32 <Pseudonym> We could call it ReadBS, which sounds a lot like my RSS feed.
18:17:35 <dons> well, we at least have Binary now
18:17:43 <dons> which is sort of like read for bytestrings
18:17:46 <dons> and show. all in one
18:17:49 <sorear> emk: infact that's a quite typical pattern - my 300MB/s filter was interact $ unlines . concatMap tails . lines
18:17:57 <dons> we could do read/show the same way
18:18:06 <syntaxfree> sorear: I'm getting deja vu.
18:18:24 <sorear> dons: remember interact
18:18:27 <dons> yeah :)
18:18:38 <dons> i did write it, you know ;)
18:18:54 <sorear> not only was the haskell version faster, it was shorter (than the perl)
18:19:15 <sorear> not bad for a throwaway filter.
18:19:19 * sorear is a fps convert
18:19:19 <dons> I think lazy bytestrings would almost always be faster than perl, modulo regex code
18:19:26 <dons> since they're compiled, and often fusible
18:19:27 <Pseudonym> I'm not shocked.  For some applications, Perl strings are less efficient than Haskell Strings.
18:19:28 <emk> ?type interact
18:19:30 <lambdabot> (String -> String) -> IO ()
18:19:34 <dons> so you're essentially scripting C-level block IO
18:19:40 <sorear> emk:
18:19:51 <sorear> @type Data.ByteString.Char8.Lazy.interact
18:19:53 <lambdabot> Couldn't find qualified module.
18:19:58 <dons> ?type Data.ByteString.Lazy.Char8.interact
18:20:00 <lambdabot> (Data.ByteString.Lazy.ByteString -> Data.ByteString.Lazy.ByteString) -> IO ()
18:20:23 <emk> dons: Thanks for the ByteString help! I think that should get my filter's performance up to acceptable levels.
18:20:31 <dons> interact f = putStr . f =<< getContents
18:20:32 <sorear> we need to ditch the module hierarchy!
18:20:48 <dons> emk, hope so. paste the code if it isn't
18:20:51 <emk> My data sets will soon get obscenely large, so it's good to tune now.
18:20:51 <LoganCapaldo> foldr . [File] -- A folder of files
18:20:57 <dons> but yeah, for string based IO, use bytestrings, always
18:20:58 <syntaxfree> we need to have a "hide"  statement.
18:21:02 <sorear> ARRRGH!
18:21:09 <syntaxfree> hide { Prelude.map, Prelude.reverse}
18:21:15 <sorear> syntaxfree:
18:21:23 <sorear> import Prelude hiding (map, reverse)
18:21:24 <mauke> import Prelude hiding (map, reverse)
18:21:33 <syntaxfree> oh. cool.
18:21:35 <mauke> GET OUTTA MY HEAD CHARLES
18:21:36 <dons> yeah, you can hide all the stuff you want anyway
18:21:40 <syntaxfree> but isn't the Prelude implicitly imported?
18:21:50 <mauke> only if it's not explicitly exported
18:21:52 <allbery_b> I thinkk that has to be the first import to override
18:21:53 <mauke> er, imported
18:21:56 <dons> import Prelude hiding (...)
18:22:59 <dons> sorear: yeah, even my naive 'reverse lines' code does 20M/s without even trying
18:23:07 <syntaxfree> I guess one should be glad we have modules at all.
18:23:23 <dons> its io bound
18:23:25 <Pseudonym> Hardly.  A dumb module system can be worse than no module system.
18:23:32 <Pseudonym> Not that Haskell's module system is dumb.
18:23:32 <sorear> ooh
18:23:34 <Pseudonym> It's just kinda limited.
18:23:38 <syntaxfree> how so?
18:23:45 <Pseudonym> Java is a good example of a dumb module system,.
18:23:50 <sorear> finally a computer part that I have better than dons!
18:23:58 <syntaxfree> I don't know Java.
18:24:04 <Pseudonym> Good on you.
18:24:15 <syntaxfree> so I was told.
18:24:16 <sorear> I thought java was also a expression language
18:24:20 <syntaxfree> How is their module system?
18:24:31 <Pseudonym> Class == module, package == component.
18:24:39 <Pseudonym> That's it, pretty much.
18:24:41 <syntaxfree> hmm.
18:24:57 <Pseudonym> Any finer structure has to be handled with design patterns and crap.
18:24:58 <syntaxfree> we have Directory == Module hierarchy.
18:25:15 <syntaxfree> that always smells bad to me.
18:25:18 <Pseudonym> Nested modules would be a nice start.
18:25:47 <syntaxfree> what is a "package" anyway?
18:25:50 <Pseudonym> Recursive modules which have to be typechecked together is a pretty serious bug IMO.
18:26:07 <syntaxfree> parameterized modules would be fun.
18:26:19 <Pseudonym> The other main problems with Haskell modules are that you have limited control over what gets exported.
18:26:34 <sorear> Procyon: still here?
18:26:38 <syntaxfree> Pseudonym: I can't really see why people care.
18:26:50 <Pseudonym> I care!
18:26:53 <syntaxfree> Why people care to hide data constructors in order to enforce their functional counterparts.
18:26:53 <Procyon> sorear: yes.  Digesting.
18:27:12 <syntaxfree> I mean, just trust your damn users. Am I wrong?
18:27:13 <sorear> I've finished commenting my inductive unifier, if you're still interested.
18:27:15 <Pseudonym> syntaxfree, that makes sense for enforcing namespaces.
18:27:26 <Pseudonym> Yes, I think you're wrong.
18:27:28 <syntaxfree> hmm.
18:27:36 <Pseudonym> If you leak information, your abstract data type isn't abstract.
18:28:00 <sorear> Procyon: I've finished commenting my inductive unifier, if you're still interested.
18:28:08 <syntaxfree> why do I want abstract data types to be enforced abstract?
18:28:19 <Procyon> sorear: verry much so
18:28:21 <syntaxfree> In CS 101 we used to do abstract data types in scheme.
18:28:37 <Pseudonym> Yes, and it relied on programmer diligence, right?
18:28:38 <dons> hey, i did ADTs in Haskell, in cs1011
18:28:39 <syntaxfree> We just trusted people to do "inc" and not "cons" on list-based naturals.
18:28:47 <dons> heh
18:28:54 <Pseudonym> In the real world, clients can't be trusted.
18:29:07 <Pseudonym> It's not that they'll break anything.  It's that your next upgrade will break THEIR code.
18:29:17 <Pseudonym> Yes, you can say "sucks to be you".
18:29:17 <syntaxfree> can't they just go back to source and unhide the data constructor if they want to?
18:29:17 <hpaste>  sorear pasted "commented inductive unifier (from Short theorem prover)" at http://hpaste.ath.cx:8000/25
18:29:22 <emk> Hmm, read and show are definitely my major performance headaches.
18:29:31 <Pseudonym> And your customers will be royally annoyed at you.
18:29:31 <mbishop> this is why you keep your ability to code a secret, and code only for yourself
18:29:32 <mbishop> :P
18:29:32 <dons> please don't read / show !
18:29:37 <Pseudonym> And buy from somewhere else.
18:29:49 <dons> emk, so what kind of parsing/serialisation are you doing?
18:30:05 * syntaxfree always thought that ADT referred to *algebraic* data type.
18:30:30 <emk> dons: Records consisting mostly of comma-separated floating point numbers, with some other stuff thrown in.
18:30:31 <Pseudonym> One of the most important lessons I learned only by writing commercial software is that every piece of code that you release, you implicitly support in some way.
18:30:31 <sorear> nowadays I say AlDT or AbDT
18:30:39 <Pseudonym> Even if it's fending off crank emails.
18:30:46 <syntaxfree> only now I struck the connection to the stuff we did in Scheme.
18:30:48 <Pseudonym> That's still time you spend "supporting" the unsupported code.
18:31:03 <dons> emk, sounds like no need for read/show then
18:31:07 <dons> maybe some readInt ?
18:31:17 <sorear> Pseudonym: and your code will become massively popular when you least expect it ... see vty
18:31:18 <dons> but keep the rest as bytestrings, or build a structure directly
18:31:20 <emk> dons: Is there a readFloat?
18:31:23 <syntaxfree> Pseudonym: you were saying earlier, Java enforces one type class per module?
18:31:27 <Pseudonym> sorear: More like DOS.
18:31:28 <dons> nope, unforuntately
18:31:34 <Pseudonym> Which is still popular despite being deprecated.
18:31:43 * allbery_b learned that by setting some code loose in the wild and receiving a phone call from Germany 6 years later when he'd abandoned it
18:31:47 <Pseudonym> syntaxfree: Yup.
18:31:51 <dons> so for the float you'd have to read . unpack
18:31:54 <syntaxfree> jesus.
18:32:03 <syntaxfree> can you at least have several modules per file?
18:32:08 <Pseudonym> Nope.
18:32:15 <emk> dons: I think the float reading is actually the bottleneck...
18:32:15 <syntaxfree> that's insane!
18:32:32 <syntaxfree> I mean, that's   a conspiracy of IDE salesmen!
18:32:35 <sorear> emk: float reading is very generic
18:32:44 <Pseudonym> syntaxfree, it's actually not that insane if you understand Java as a language for writing small pieces of portable code in.
18:32:54 <Korollary> not necessarily small
18:33:02 <Pseudonym> Small enough.
18:33:05 <syntaxfree> preferably not defining your own type classes?
18:33:28 <Korollary> well, in practice people do blow it out of proportion and produce monsters
18:33:34 <Pseudonym> Oak was designed for running code on digital set-top boxes.  Java adapted that for web browsers.
18:33:57 <Pseudonym> It gives you a reasonably full programming language that lets you run untrusted code.
18:34:03 <Pseudonym> That's actually quite a valuable thing, IMO.
18:34:18 <Pseudonym> The trouble is that Java is used for things that it wasn't designed for.
18:34:36 <Pseudonym> It wasn't designed for programming-in-the-large.
18:35:10 <syntaxfree> define programming in the large?
18:35:46 <Pseudonym> That's hard to capture.  A large mouse is incomparable to a large elephant.
18:35:48 <syntaxfree> <large>programming</large>
18:36:59 <syntaxfree> I didn't think Java's origins were the browser applets themselves.
18:37:07 <syntaxfree> I thought these were just an early application.
18:37:27 <Pseudonym> Java's origins are Oak.
18:37:30 <LoganCapaldo> If you hang a sign "The Large" over your building, and you program in it...
18:37:54 <Pseudonym> A large compiler is also incomparable to a large data processing application, I think.
18:38:00 <syntaxfree> what about HotJava? It was a desktop application supposedly written in Java.
18:38:05 <Pseudonym> Yup, I used that.
18:38:28 <syntaxfree> I can still remember the sound of my hard drive thrashing as HotJava ran.
18:38:31 <Pseudonym> I was seriously impressed how it managed to firewall off dynamically loaded code written in the same language.
18:38:41 <Pseudonym> Yeah, well, I ran it on a high-end Sun at the time.
18:38:51 <allbery_b> java was originally intended for embedded programming for small appliances, then for small web applets.  use as an application programming language came later
18:39:00 <syntaxfree> I can still remember.
18:39:29 <Pseudonym> Now mind you, I am pleased that programmers have a choice of languages to develop in now.
18:39:39 <Pseudonym> "We could do this in Visual Basic... OR Java!"
18:39:40 <syntaxfree> do they?
18:39:47 <allbery_b> I just wish it were a better choice
18:39:50 <Pseudonym> Me too.
18:39:58 <syntaxfree> Visual Basic's visual editor window is fun!
18:40:03 <Pseudonym> And I also fear for what's happening in education.
18:40:06 <syntaxfree> it's like drag-and-drop programming.
18:40:16 <Pseudonym> People are being turned out who know Java and nothing else.
18:40:21 <syntaxfree> drag a microsoft word ocmponent here, an excel component there and tie together with minor scripting.
18:40:43 <syntaxfree> Pseudonym: I know a CS school here turning out people who know Prolog and nothing else :)
18:40:53 <Nafai> Java is depressing
18:41:00 <Pseudonym> Mind you, I don't fear that much.  I'm in the job market at the moment, and people who CAN do anything else are sufficiently rare that I can theoretically have my pick of the good jobs.
18:41:04 <Nafai> Especially since it is what I do all day every day
18:41:20 <syntaxfree> I'm thinking of sending out a resume to Jane St. Capital.
18:41:20 <Nafai> At work
18:41:25 <Pseudonym> I feel for you.
18:41:31 <syntaxfree> of course, I have no formal CS education, but I *am* an economist.
18:41:40 <Pseudonym> Unclean!
18:41:44 <p-f> Pseudonym: University of Sherbrooke, as far as I've seen, is turning into a Java-factory too
18:42:09 <Pseudonym> Mind you, before it was Java, it was something else.
18:42:24 <syntaxfree> why can't Java compile to native code yet?
18:42:27 <p-f> well, we've had c++ and java so far, although there is one class where we will use scheme (and I've heard that some of the AI classes use something along the lines of lisp)
18:42:28 <syntaxfree> Is it a technical decision?
18:42:29 <Pseudonym> A friend of mine refers to his late-80s CS degree as "Bachelor of Pretenting That COBOL is Structured".
18:43:07 <allbery_b> syntaxfree: there are a few java native compilers out there, including gcj
18:43:14 <sorear> syntaxfree:
18:43:22 <allbery_b> native *libraries* are still somewhat uncommon
18:43:36 <Pseudonym> Most of the better VMs do JIT, of course.
18:43:45 <sorear> ignore me.  why does C-j have to be next to C-k?
18:43:55 <allbery_b> heh
18:43:57 <p-f> speaking of java libraries, it's amazing how inconsistent they can be... getSize, size, getLength, length and so forth
18:44:01 <Pseudonym> Who needs to type C-j and C-k anyway?
18:44:06 <Pseudonym> What are you using?  WordStar?
18:44:07 <allbery_b> emacser!
18:44:21 <sorear> Pseudonym: irssi, C-k cancels a message
18:44:32 <sorear> Pseudonym: ASCII is the only reason I care about C-j
18:44:39 <Pseudonym> p-f: Same argument can be levelled at many systems.
18:44:46 <mbishop> Is there a way to get a random number without having to mess with IO () from randomRIO and such?
18:44:51 <Pseudonym> Haskell libraries don't exactly shine in that regard.
18:44:57 <sorear> Pseudonym: and then there are those people who insist VM+JIT is better than native code.
18:45:14 <p-f> I don't know about Haskell, I'm still at the reading-my-first-tutorials stage
18:45:17 <LoganCapaldo> mbishop, StdGen or some such
18:45:18 <syntaxfree> I was saying..
18:45:22 <syntaxfree> anyway, did anyone answer my VM question?
18:45:27 <Pseudonym> sorear: It is, for some definition of "better".
18:45:32 <sorear> mbishop: randoms, MonadRandom, MonadSupply, MonadRandomSplit, my unpublished RandomComonad, take your pick...
18:45:44 <dons> mbishop: yeah, there's a few ways
18:45:46 <dons> :t randoms
18:45:47 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
18:45:48 <Pseudonym> VM+JIT lets you run untrusted code, as previously mentioned.
18:45:49 <allbery_b> <allbery_b> syntaxfree: there are a few java native compilers out there, including gcj
18:46:03 <sorear> Pseudonym: ever heard of typed assembly language?
18:46:05 <sorear> Pseudonym: ever heard of typed assembly language?
18:46:08 <mbishop> I don't understand the whole "make your own generator" thing
18:46:08 <NichardRixon> wtf
18:46:08 <Pseudonym> Yes.
18:46:09 <syntaxfree> the school where I went for my bachelor's  (in economics) taught Scheme in the introductory CS courses.
18:46:11 <Pseudonym> And proof-carrying code.
18:46:14 <sorear> C-j vs C-k again
18:46:22 <dons> > randoms (mkStdGen 42)
18:46:23 <lambdabot>  Add a type signature
18:46:29 <dons> > randoms (mkStdGen 42) :: [Int]
18:46:31 <lambdabot>  [-1673289139,1483475230,-825569446,1208552612,104188140,84572631,-1284852847...
18:46:32 <Pseudonym> JVM is almost typed assembly language as it is.
18:46:36 <dons> > randoms (mkStdGen 42) :: [Word32]
18:46:37 <lambdabot>   add an instance declaration for (Random Word32)
18:46:37 <lambdabot>     In the expression: rand...
18:46:42 <syntaxfree> Stufdents complained about not being taught anything real.
18:46:43 <mbishop> dons: why 42?
18:46:46 <sorear> Pseudonym: or better yet - untrusted haskell w/o unsafeFoo can be compiled by a trusted compiler.
18:47:03 <dons> mbishop: that's the seed. feel free to create the seed however you wish
18:47:06 <syntaxfree> Since they also used Dr. Scheme in very slow pentiums, they think Lisp can't be used for anything real.
18:47:14 <sorear> Pseudonym: example: lambdabot :)
18:47:21 <Korollary> mzscheme is slow indeed
18:47:28 <Pseudonym> syntaxfree: And back in my day, it's "why are we learning this Miranda thing when we could be learning something useful, like Pascal?"
18:47:34 <sorear> Haskell is great.
18:47:39 <mbishop> mzscheme isn't ment to be fast :P
18:47:45 <Pseudonym> And before that, it was "Why are we learning this Pascal thing when we could be learning something useful, like Fortran?"
18:47:46 <syntaxfree> Pseudonym: yay. Miranda?
18:47:49 <Korollary> then they should mean it some day.
18:47:53 <syntaxfree> haha.
18:48:03 <sorear> Haskell is sooo slow (for naive code at least) that it shocks you out of believing performance == productivity.
18:48:09 <syntaxfree> is Fortran that MULTIPLY 6 BY 5 language?
18:48:11 <Pseudonym> syntaxfree: Yes!  I learned Miranda in first year!
18:48:15 <allbery_b> that's COBOL
18:48:19 <Pseudonym> Hard to believe now.
18:48:24 <syntaxfree> that's crazy.
18:48:34 <syntaxfree> (the MULTIPLY 6 BY 5 language)
18:48:40 <sorear> almost sounds more like INTERCAL to me
18:48:46 <Pseudonym> Fortran is the one where you can change the value of 4.
18:48:48 <LoganCapaldo> fortran is the language with i j and k must be integers
18:48:49 <sorear> PLEASE GIVE UP
18:48:54 <allbery_b> FORMAT (100) 11HHELLO WORLD
18:48:56 <syntaxfree> heheh. really?
18:49:00 <allbery_b> or something
18:49:04 <sorear> LoganCapaldo: REAL I ?
18:49:07 <allbery_b> too long ago
18:49:22 <nmessenger> DON'T DO ANYTHING
18:49:22 <mauke> God is real (unless declared integer).
18:49:38 <syntaxfree> mauke: I never got that.
18:49:39 <Pseudonym> syntaxfree: In Fortran, everything is passed by reference.  So if you call F(4) in a loop, and F changes the value of its argument...
18:49:43 <syntaxfree> Is that programmable?
18:49:46 <sorear> LoganCapaldo: there is this arcane language called perl, it today uses implicit typing
18:49:47 <LoganCapaldo> sorear, isn't it an integer by default though then?
18:49:52 <syntaxfree> Pseudonym: oo.
18:50:38 <emk> dons: If I wanted to write readFloat for byte strings, where should I start looking?
18:50:41 <allbery_b> you could use IMPLICIT to change what implicit type was gien to variables starting with various letters
18:50:57 <syntaxfree> heh. I see where hungarian notation comes from.
18:51:52 <dons> emk, well you have access to the individual bytes for the floats, so hmm, i suppose you could even make an ffi call to a C function to do it
18:52:01 <dons> e.g scanf or something
18:52:08 <dons> rather than roll your own
18:52:10 * dons tries this...
18:52:17 <sorear> dons: wouldn't scanf be slower?
18:52:17 <mauke> not scanf :(
18:52:32 <mauke> you want strtod()
18:52:33 <syntaxfree> dons: still talking about random numbers?
18:52:37 <sorear> heh
18:53:18 <LoganCapaldo> wait byte strings as in strings like "2.7" or byte strings as in write(8, (char *)(2.7)) ?
18:53:47 <emk> LoganCapaldo: Data.ByteString.
18:53:55 <LoganCapaldo> ah ok
18:54:08 <syntaxfree> bytestrings should really be called bytestreams.
18:54:25 <mauke> whoa, I hope (char *)2.7 doesn't compile
18:54:29 <sjanssen> syntaxfree: but Data.ByteString really isn't a stream
18:54:41 <LoganCapaldo> mauke, it would
18:54:45 <syntaxfree> what is a stream?
18:54:53 <LoganCapaldo> but I should have wrote (char *)&a_value
18:55:02 <LoganCapaldo> where a_value = 2.7
18:55:07 <LoganCapaldo> if I wanted to actually do somthing
18:55:15 <allbery_b> actually it doesn't compile; int can be cast to pointer, float/double can't
18:55:19 <mauke> LoganCapaldo: try.c:2: error: cannot convert to a pointer type
18:55:39 <LoganCapaldo> it would have if I hadn't screwed up :)
18:56:31 <syntaxfree> *yawn*
18:56:48 <LoganCapaldo> Could always union { double x; char *y } z; z.x = 2.7; write(8, z.y)
18:56:49 <mauke> (double []){ 2.7 }
18:57:04 <sorear> LoganCapaldo: *CRASH*
18:57:14 <mauke> as in write(1, (double []){ 2.7 }, sizeof 2.7);
18:57:26 <sorear> union { double x; char y[8] } z; z.x = 2.7; write(8, z.y)  // much better
18:57:29 <syntaxfree> this C stuff is making my head hurt.
18:57:37 <mauke> what's the point of using a union there?
18:57:37 <LoganCapaldo> at least we hope it would crash
18:57:39 <sorear> <-- ex C programmer
18:57:43 <LoganCapaldo> :)
18:57:46 <mauke> write takes a void *
18:57:47 <LoganCapaldo> to be evil
18:58:01 <syntaxfree> I'm not smart enough for C. That's why I use Haskell.
18:58:01 <jql> nothing like C to get the bitwise juices flowing
18:58:06 <allbery_b> C seems designed to make heads hurt
18:58:06 <sorear> (unsafeCoerce# (2 :: Double) :: Int)
18:58:21 <syntaxfree> hmm.
18:58:43 <syntaxfree> @quote c
18:58:44 <lambdabot> dons says: so i suspect dynamically typed langs, that just work (bugs and all) will always be more popular with the masses since most people don't understand bug theory ;)
18:59:03 <sorear> @quote gcc
18:59:04 <syntaxfree> @quote
18:59:04 <lambdabot> pjdelport says: [on qwe1234:] It must be a drag, being the sole beacon of sanity in a field where all the established researchers are unanimously insane.
18:59:04 <lambdabot> JaffaCake says: gcc is getting smarter, so we need to hit it with a bigger stick
18:59:27 <emk> dons: I see there's a bunch of C interface functions for strict byte streams. But if I'm working with a lazy byte string split up with lines, what's the best way to get at the underlying data to parse the float?
18:59:38 <syntaxfree> @quote gcc
18:59:39 <lambdabot> cjeris says: i have a little perl script that aliases gcc -freduced-suckage to ghc
18:59:49 <syntaxfree> @quote gcc
18:59:49 <lambdabot> JaffaCake says: gcc is getting smarter, so we need to hit it with a bigger stick
18:59:54 <dons> hmm, how do I convert a CDouble to a Double
19:00:03 <sjanssen> emk: what format are your floats in?
19:00:14 <sorear> dons: fromRational . toRational? :)
19:00:15 <sjanssen> emk: do you need to handle 1.0e10 ?
19:00:16 <syntaxfree> is CDouble an instance of Num?
19:00:28 <dons> realToFrac
19:00:35 <sorear> @instances-importing Num Foreign.C.Types
19:00:37 <lambdabot> Couldn't find class `Foreign.C.Types'. Try @instances-importing
19:00:42 <sorear> @instances-importing Foreign.C.Types Num
19:00:43 <lambdabot> CChar, CClock, CDouble, CFloat, CInt, CLDouble, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CTime, CUChar, CUInt, CULLong, CULong, CUShort, CWchar, Double, Float, Int, Integer
19:00:53 <sorear> @instances-importing Foreign.C.Types Real
19:00:54 <emk> sjanssen: Nothing that complicated. But there's many millions of them, so it needs to be fast.
19:00:55 <lambdabot> CChar, CClock, CDouble, CFloat, CInt, CLDouble, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CTime, CUChar, CUInt, CULLong, CULong, CUShort, CWchar, Double, Float, Int, Integer
19:01:01 <sorear> @instances-importing Foreign.C.Types RealFloat
19:01:02 <lambdabot> CDouble, CFloat, CLDouble, Double, Float
19:01:33 <syntaxfree> @instances-importing Foreign.C.Types Integral
19:01:35 <lambdabot> CChar, CInt, CLLong, CLong, CPtrdiff, CSChar, CShort, CSigAtomic, CSize, CUChar, CUInt, CULLong, CULong, CUShort, CWchar, Int, Integer
19:01:41 <syntaxfree> Char??
19:02:31 <nmessenger> > ord 'a'
19:02:33 <lambdabot>  97
19:02:48 <sorear> syntaxfree: Char =usually= Word8
19:03:04 <sorear> s/Char/CChar (aka char)/
19:03:44 <allbery_b> (char) is often used as a word8 type in C, yeh
19:04:21 <allbery_b> (because it is)
19:05:39 <dons> !hpaste: url
19:06:22 <allbery_b> !paste
19:06:23 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
19:06:28 <allbery_b> hpaste: url
19:06:29 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
19:06:35 <allbery_b> doesn't like mixing them though :)
19:06:53 <sorear> hehe
19:07:04 <sorear> @paste
19:07:04 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
19:07:26 <dons> hpaste.ath.xs xs I guess?
19:07:33 <dons> grr. wifi slow slow
19:07:49 <sorear> the servers are one and the same, yes
19:07:56 <dons> ah ok
19:08:04 <allbery_b> the .cx addr points to scannedinavian, yeh
19:08:12 <sorear> patch in queue btw
19:08:24 <hpaste>  dons pasted "readDouble" at http://hpaste.ath.cx:8000/26
19:08:49 <sorear> dons: there's a diff feature now too
19:09:06 <dons> its very very nice stuff
19:09:10 <hpaste>  sjanssen pasted "hackish readDouble" at http://hpaste.ath.cx:8000/27
19:09:13 <dons> should announce it on haskell-cafe today...
19:09:24 <dons> sjanssen: hackish?
19:09:27 <dons> ah right
19:09:29 <dons> hackish but pure
19:09:37 <emk> dons: Oooh. Once I can get rid of that read Float, this thing is going to scream...
19:10:01 <dons> the error conditions returned by by strtod are horrible
19:10:05 <sjanssen> dons: this pure version will work in .Lazy too
19:10:23 <dons> yes, good point
19:10:38 <dons> whereas you'd have to fromChunks my version
19:10:52 <sjanssen> but it isn't quite right: readDouble "1." == Nothing
19:11:05 <sorear> who writes that? :)
19:11:34 <TomMD> @users
19:11:35 <lambdabot> Maximum users seen in #haskell: 311, currently: 281 (90.4%), active: 24 (8.5%)
19:11:41 <emk> dons: Assuming I've got one huge lazy ByteString, is there any way to convert the individual lines to strict ByteStrings?
19:11:50 <dons> yeah, gimme a sec ...
19:12:23 <sorear> map (S.concat . L.toChunks) . L.lines   ?
19:12:24 <sjanssen> emk: toStrict (LPS xs) = Data.ByteString.concat xs
19:12:36 <sorear> LPS is exported!?
19:12:57 <sjanssen> sorear: from Data.ByteString.Base, I believe
19:13:03 <sorear> oh
19:13:21 <emk> dons: Thank you, by the way, for this help! It looks like I will be able to use Haskell for this project, which makes me very happy!
19:13:35 * sjanssen is surprised he didn't know about the toChunks function
19:15:33 <syntaxfree> http://www.tbray.org/ongoing/When/200x/2007/01/20/On-Linking
19:15:38 <lambdabot> Title: ongoing &#xb7; On Linking
19:15:42 <syntaxfree> that should *not* be on programming.reddit.com
19:16:16 <LoganCapaldo> I thought that was going to be about Linking as in the phase of compiling
19:16:25 <LoganCapaldo> I got very dissapointed when I clicked that link
19:16:28 <emk> sjanssen: Ah, thanks for the other version of readDouble!
19:17:37 <sjanssen> syntaxfree: when I saw the headline, I figured it'd be about the other kind of linking
19:17:44 <syntaxfree> me too.
19:19:16 <hpaste>  dons annotated "readDouble" with "map readDouble over a lazy bytestring" at http://hpaste.ath.cx:8000/26#1
19:19:30 <dons> emk, how's that?
19:20:02 <dons> makes me think we should have a binding of bytestrings to well known C string functions
19:20:05 <dons> just for those who know the api
19:20:18 <emk> dons: Dynamite!
19:20:19 <dons> hey, we could even map errors to Maybes
19:21:00 <dons> that was harder than it should have been though. we need a library!
19:21:01 <dons> :)
19:21:13 * sorear mutters something about the cost of catching SIGSEGV
19:21:15 <dons> if you have to ask the library author for the code, that's the sign its time to package something up.
19:21:18 <dons> sorear: hehe
19:21:41 <dons> sorear: yeah, i'm not saying its the most haskellish way to manipulate strings
19:21:45 <dons> but it would be cheap
19:22:20 <dons> emk, you can elaborate on this to return the rest of a bytestring, and any leading Double, of course
19:22:32 <emk> dons: Yup!
19:22:46 <emk> I'll have performance numbers in a minute or so...
19:23:04 * dons hopes C behaves
19:23:36 <dons> glguy: around?
19:23:40 <glguy> yeah
19:23:46 <glguy> just wandered back
19:23:49 <dons> how hard would it be to turn identifiers in hpaste to links to their library defn
19:23:53 <dons> a la haskell wiki's markup
19:24:02 * sorear adds this to hpaste.todo
19:24:02 <glguy> let me check
19:24:03 <dons> you take the haddock data base for this purpose
19:24:24 <LoganCapaldo> that would be totally awesome
19:24:27 <dons> (we could follow the plan used by haskell.org, maybe even steal the database)
19:24:42 <dons> and then tweak HsColour to wrap known identifiers in <a href=.>
19:24:46 <sorear> I *love* scripting
19:24:47 <sorear> stefan@stefans:~$ upload hpaste.todo
19:24:51 <dons> maybe its even easier than that
19:24:51 <Elifant> hello all. please, say, is "case (func a) of { fa -> ... do something with fa ...}" fully equivalent to "... where fa = func a" or not? If yes, why people ever use "case of" form?
19:24:52 <sorear> easy as that.
19:25:05 <dons> Elifant: same thing, basically
19:25:10 <glguy> dons: hscolour support anchors at some level
19:25:11 <dons> you use 'case' to pattern match explicitly
19:25:15 <glguy> I'll turn on support and see what happens
19:25:19 <dons> ah yes
19:25:35 <sorear> http://members.cox.net/stefanor/hpaste.todo - the list I've been keeping
19:25:43 <Elifant> dons: is there any reason to use "case of" form? performance or something?
19:25:47 <sjanssen> Elifant: the case match is a strict match and the where is lazy
19:25:51 <dons> sometimes its clearer
19:26:06 <dons> and yes, using where is like using 'let', its a lazy bind to the result
19:26:06 <glguy> sorear: announce to specific user?
19:26:10 <dons> (usually waht you want anyway)
19:26:17 <sorear> dons: btw: current project: nick identity.  <xerox> @link edi
19:26:30 <Elifant> sjanssen says it is strict, dons says it is lazy...
19:26:48 <sorear> glguy: have hpaste send a privmsg to someone other than #haskell
19:26:58 <sorear> (if it can be made non-abusable ...)
19:27:03 <glguy> sorear: any idea on abuse
19:27:03 <glguy> yeah that
19:27:06 <Elifant> oops, I misunderstood. "case of" is strict, "where" is lazy?
19:27:10 <allbery_b> yes
19:27:19 <dons> sorear: nice idea
19:27:33 <LoganCapaldo> Bah, don't need case or let (\fa -> ... do something with fa ...) (func a)
19:27:36 <sorear> dons: which one?  the upload script?
19:27:42 <dons> the @link edi
19:27:42 <LoganCapaldo> ;)
19:27:46 <sorear> LoganCapaldo: that's monomorphic
19:27:47 <dons> i like user-extensible data bases
19:27:49 <dons> they seem to 'just work'
19:27:53 <dons> like @quote or @where
19:28:05 <dons> distribute your cognition! :)
19:28:11 <LoganCapaldo> sorear, it is? Fascinating
19:28:16 <LoganCapaldo> Some many little corners
19:28:16 <sorear> I'd like to see lambdabot become much more of a community integration tool.
19:28:19 <emk> dons: Yow, that's a nice speedup!
19:28:51 <Elifant> how to write "where" which is fully equivalent to "case of", i.e. is stict?
19:29:07 <emk> dons: Many thanks for helping me get the speed up...
19:29:28 <mbishop> is there a way to get Char -> String? I want to append a char (over and over) to a string
19:29:29 <sorear> emk: dons did a paper at padl on bytestring performance.
19:29:33 <glguy> dons: hscolour doesn't seem to support that
19:29:35 <sorear> mbishop: (:[])
19:29:37 <Elifant> mbishop: ['a']
19:29:39 <emk> sorear: Yeah, I saw that.
19:29:41 <sorear> > (:[]) 'a'
19:29:42 <lambdabot>  "a"
19:29:49 <glguy> dons: so I'd have to figure something else out
19:29:50 <sorear> @quote SamB
19:29:50 <lambdabot> SamB says: Because sliced bread gives horribly uninformative error messages?
19:29:57 <dons> emk, is it fast enough now?
19:29:58 <sorear> @quote eat.a.comment
19:30:00 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
19:30:06 <LoganCapaldo> @hoogle Char -> String
19:30:07 <lambdabot> Network.URI.escapeURIChar :: (Char -> Bool) -> Char -> String
19:30:10 <dons> glguy: hscolour is pretty easy to hack, the src is fairly clean
19:30:26 <glguy> dons: alrighty, so what is this haddock database you mentioned?
19:30:35 <emk> dons: Well, it just dropped my number one cost center to third place at 12.9%.
19:30:37 <sorear> haddock or hoogle?
19:30:45 <dons> right, so i think haddock can generate data bases of links or some such
19:30:56 <emk> dons: So it's definitely getting into the ballpark.
19:30:58 <dons> which is used on mediawiki
19:31:08 <dons> emk, ok.. good.
19:31:25 <emk> If I could replace "show" with the new binary dumper, would that give another speedup?
19:31:34 <dons> right, so what do you need to do?
19:31:38 <dons> dump a Double to a bytestring?
19:31:47 <dons> or some other types?
19:32:06 <emk> dons: Wasn't there a new Binary/IO library under development lately?
19:32:10 <dons> (as you can see, parsing and pretty printing of the bytestring types is in its early stages..)
19:32:14 <dons> emk, yes.
19:32:27 <dons> its good for packing custom data types into lazy bytestrings, quickly
19:33:07 <dons> ?where binary
19:33:07 <lambdabot> http://darcs.haskell.org/binary
19:33:09 <emk> dons: There's no particular reason I need to output my data as strings, except for human consumption. A fast binary serialization library would be an acceptable alternative to dumping strings...
19:33:19 <dons> ok.
19:33:32 <dons> so you could write the result as a binary file?
19:33:47 <dons> what types will you need to be able to write oyu?
19:33:49 <dons> ouy?
19:33:54 <dons> grr
19:34:02 <dons> ok. so maybe the jet lag is kicking in now
19:34:16 <emk> dons: Yup. I'd just need to dump the standard types: floats, strings and stuff like that.
19:34:28 <dons> we'd have to write instances for floating point types
19:34:42 <dons> i don't have a portable implementation for that yet, but we could surely write one
19:34:57 <dons> also, of course, pack . show works
19:35:03 <emk> dons: For my immediate purposes, I could just dump the raw non-portable bytes.
19:35:32 <dons> ok. /me thinks
19:35:47 <emk> Is the Binary library efficient enough for streaming large amounts amounts of data in and out of programs?
19:35:50 <robreim> dons: is hs-plugins working with ghc 6.6 now?
19:36:01 * sorear listens
19:37:25 <emk> dons: I don't need an output solution right away--I'm just interested in whether the Binary library is the way to go, long-term, once I want to scale to a few million records.
19:37:44 <dons> sounds reasonable, yes.
19:38:02 <dons> how many meg?
19:38:07 <emk> For now, I can just snarf all my data into core and do the analysis. That way, I'm only dumping conclusions, not intermediate data.
19:38:12 <dons> 10M .. 1G? should be fine
19:38:19 <dons> i've not tried much larger than that
19:38:32 <dons> robreim: :(
19:38:45 <emk> dons: It will take me a little while to get over 1G. :-)
19:38:46 <dons> binary should be efficient enough for large data yes
19:39:06 <dons> for words we can do ~150M/s writing
19:39:17 <dons> and proportionally slower for more complex types
19:39:32 <robreim> dons: I'm pretty keen to have hs-plugins working. If you let me know what needs to be done I'm more than happy to do it...
19:39:35 <dons> that's into a bytestring in memory, of course.
19:39:47 <dons> robreim: hmm.
19:39:55 <dons> ok. i'll see if i can put up the spec for the port
19:40:07 <emk> dons: I'm trying to use Haskell + GSLHaskell as a faster replacement for Matlab,Octave, etc., for exploratory data analysis.
19:40:42 <emk> dons: 150M/s is definitely plausible.
19:41:59 <emk> My dream here is to getting scripting language ease-of-use, but with better abstractions and solid performance for custom code.
19:43:21 <sorear> emk: hehehe.
19:43:27 <sorear> emk: I had the same idea.
19:44:07 <sorear> emk: When I next lose interest in LB, I will modify hslife to use runplugs as its user interface, rather than the current ad-hoc scripting language.
19:45:44 <emk> http://shootout.alioth.debian.org/gp4/benchmark.php?test=all&lang=ghc&lang2=gcc
19:45:47 <lambdabot> Title: Haskell GHC benchmarks | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/2vdkpl
19:46:08 <emk> It looks like Haskell runs at 1/2 to 1/3 the speed of C, except on String intensive benchmarks.
19:46:22 <sorear> emk: about my experience...
19:46:42 <sorear> emk: tell me: time writing code / time running code
19:46:49 <sorear> <=> 1 ?
19:46:59 <Elifant> is "case (length a) of {l -> l*2}" equivalent to "l*2 where l = id $! length a"?
19:47:29 <sorear> Elifant: (*2) is strict so yes
19:47:44 <emk> sorear: I'm trying to prototype computationally intensive algorithms, so it could go either way, depending on what I find.
19:47:44 <sorear> Elifant: (id $!) is always equivalent to (id $)
19:48:00 <Elifant> sorear: hm.... strange...
19:48:13 <sorear> emk: once you know what you are trying to do, you can always rewrite it in C.
19:48:33 <sorear> Elifant: id $! x = x `seq` id x = x `seq` x = x
19:48:42 <sorear> Elifant: id $! x = x `seq` id x = x `seq` x = x = id x = id $ x
19:48:48 <emk> sorear: Exactly. Or just rent some more CPUs, if that makes more sense.
19:48:50 <sorear> id is strict
19:48:55 <hpaste>  dons annotated "readDouble" with "showDouble and readDouble for bytestrings" at http://hpaste.ath.cx:8000/26#2
19:49:07 <dons> emk, so that adds a packed showDouble as well
19:49:22 <sorear> a function f is strict if f _|_ = _|_.  id doesn't "force evaluation", but it is strict: id _|_ = _|_
19:49:22 <dons> to pack a Double into a bytestring (will be faster than pack . show, i think)
19:49:44 <Elifant> > take 2 (id $ repeat 'a')
19:49:46 <lambdabot>  "aa"
19:49:51 * glguy realizes that his algorithm can't handle diffing things that are identical
19:49:52 <glguy> fixing
19:50:06 <Elifant> > take 2 (id $! repeat 'a')
19:50:08 <emk> sorear: But I needed to hit at least 1/4th the speed of C to be able to consider Haskell seriously. Thanks to dons, it looks like it's a go.
19:50:08 <lambdabot>  "aa"
19:50:22 <emk> dons: Thank you once more! This has been a huge help for me.
19:50:46 <dons> i'd hope to actually reach C speed for this bytestring stuff
19:50:56 <dons> at least gcc without -O should be doable
19:51:10 <sorear> emk: Personally I don't notice the runtime of Haskell programs - run, Alt-F6, help a newbie, Alt-F2, it was done ten minutes ago :)
19:51:52 <Elifant> sorear: and what if I replace "*2" with some complex computation?
19:52:25 <dons> sjanssen: any thoughts on serialising Doubles portably, in Binary?
19:52:38 <dons> could we use this trick to pack them as bytes?
19:52:45 <dons> i.e. a fast pack . show
19:52:50 <sorear> Elifant: my knowledge fails, that's what happens :)
19:53:24 <sorear> dons: how about IEEE 754 little endian? you could specialize it to unsafeCoerce# on 90% of deployed computers
19:54:29 <dons> ok, i'm pretty happy with that, summing 1M 'pi's in 4s, via stdin/stdout
19:54:31 <dons> using a 1 liner..
19:54:45 <dons> $ time cycle test | head -1000000 | ./sum2
19:54:45 <dons> 3141592.650056
19:55:00 <emk> dons: Sweet!
19:55:09 <TomMD> How does one specify no event? As in: if boolVal then func else "nothing"  - or in a case statement.
19:55:09 <dons> using L.interact $ showDouble . sum . map readDouble . L.lines
19:55:22 <dons> can anyone hack that up in python and test ?
19:55:45 <dons> > case True of True -> "yes" ; _ -> "no"
19:55:46 <lambdabot>  "yes"
19:56:02 <dons> > if True then "yes" else "no"
19:56:03 <lambdabot>  "yes"
19:56:23 <allbery_b> TomMD: what is func's return type?
19:56:26 <dons> > if True then toUpper 'x' else '@'
19:56:27 <lambdabot>  'X'
19:56:31 <TomMD> Perhaps I am not phrasing the question well...
19:56:55 <allbery_b> you just specify some useless value.  it has to typecheck with the other leg of cthe conditional though
19:57:20 <glguy> yea, diff a a doesn't crash now :)
19:57:21 <emk> dons: Half the Haskell examples on the Great Language Shootout are using String for DNA munging, and run at ~5% of the speed of C. The non-string benchmarks are ~50% of the speed of C.
19:57:43 <allbery_b> String sucks for speed
19:57:47 <dons> emk, oh oops. i had my cpu clocked down, 1M doubles in 1.783 total
19:58:02 <dons> emk, yeah, and *none* actually use bytestrings
19:58:10 <emk> dons: As a rule of thumb, Python will get 1/15th to 1/25th of the speed of C for this sort of stuff.
19:58:37 <dons> ok. i'd expect between 1/1 and 1/3 C
19:59:04 <emk> dons: Those are some nice numbers on summing pi there.
19:59:22 <dons> yeah, quite good i think. and didn't have to optimise anything.
19:59:26 <dons> that's the point of fast libraries though!
19:59:31 <dons> the work is done for you :)
19:59:58 <emk> dons: Perl will sometimes dip as low as 1/75th the speed of C for big arrays of numbers, because it tends to store even integers on the heap...
20:00:36 <dons> well, we have a compiled language here as well, so that helps a bit
20:00:38 <allbery_b> perl, python, etc. aren't used for speed.  they're used because it's easier to write programs
20:00:51 <emk> ...and Ruby is painfully slow, and will remain that way until someone writes an actual VM.
20:00:55 <dons> yeah. so yay for compiled one liners!
20:01:27 <dons> its a nice feature of haskell that we had several compilers before we had any interpreters :)
20:01:34 <dons> funny pointy headed haskell hackers
20:01:47 <emk> allberry_b: Well, that's why I'm looking for a high-level language that can actually do math at a reasonable speed. :-)
20:01:59 <Elifant> dons: can I replace "case (length s) of {l -> some_complex_computation l}" with "some_complex_computation l where l = id $! length s"? I need to fully save behaviour (and strictness) of source code, but I don't like this trick with "case of".
20:02:05 <emk> Haskell compiler technology scales me.
20:02:10 <Gambit> I've never heard of haskell, could someone give a brief description
20:02:20 <allbery_b> emk: fortran }:>
20:02:28 <dons> Gambit: check haskell.org
20:02:34 <dons> all the introductory material is there
20:02:35 <bd_> > case undefined of _ -> "ok"
20:02:36 <lambdabot>  "ok"
20:02:41 <bd_> > case undefined of l -> "ok"
20:02:42 <lambdabot>  "ok"
20:02:50 <emk> allbery_b: Yeah, 'cause I so want to write catamorphisms in Fortran. ;-)
20:02:51 <Gambit> k
20:02:52 <bd_> Elifant: as you can see here, case used in that manner doesn't force it anyway :)
20:03:08 <bd_> Elifant: You probably want: length s `seq` some_complex_computation l
20:03:14 <dons> Elifant: how about:   l `seq` some_complex_computation l where l = length s
20:03:20 <bd_> Elifant: err,
20:03:28 <dons> yeah. or a bang pattern on the argument to some_complex..
20:03:41 <Elifant> some_complex_computation $! l where l = length s may be?
20:03:42 <bd_> some_complex_computation $! length s
20:04:06 <emk> dons: Once again, many thanks for helping get the speed up!
20:04:15 <Elifant> so this trick with case is totally useless?
20:04:26 <dons> emk, its a nice problem. feel free to ask me for more tips and tricks on this
20:04:33 <dons> it points out things that i need to put in libraries ;)
20:04:43 <dons> Elfin this csae yes :)
20:04:52 <dons> you'd actually need to pattern matchin the I# constructor to force it :)
20:04:57 <dons> so just use $!
20:05:03 <dons> f $! length s
20:05:19 <Elifant> then I don't understand author of code...
20:05:25 <dons> now, why do you need to evaluate the length before running the computation? an optimisatoin ?
20:05:41 <Elifant> I think so. it isn't my code, it's from HughesPJ
20:06:13 <bd_> avoiding a space leak of some sort?
20:06:39 <Elifant> how does it help to avoid leak?
20:06:54 <CloudiDust> Hi all, I got a compile error when building hs-plugins (for lambdabot) with ghc 6.6, it reported parse error in typeable.hs (both 0.9.10 & 1.0-rc0), as a newcomer I could not figure out what happened. Could you help me please?
20:07:11 <allbery_b> hs-[plugins doesn't work with 6.6
20:07:25 <allbery_b> join the long line of folks bugging dons :)
20:07:37 <Elifant> ye, you are after me :)
20:08:10 <CloudiDust> oh, I know, thanks a lot :)
20:08:26 <dons> you need ghc 6.4.2
20:08:33 * dons hands you tickets in the queue
20:08:58 <robreim> How did the hackathon go anyway?
20:09:07 <Elifant> dons: you need priority queue :)
20:09:52 <dons> i need more cores
20:09:59 <dons> robreim: really good
20:10:05 <dons> for example:
20:10:07 <dons> ?where binary
20:10:08 <lambdabot> http://darcs.haskell.org/binary
20:10:15 <dons> pure binary serialiation for haskell! yay!
20:10:41 <dons> take that erlang! ;)
20:10:54 <dons> now we just need the bit packing layer and some pattern guard syntax :)
20:11:19 <dons> i'd like to use this to take apart network protocols very quickly
20:11:22 <dons> that's the plan, anyway
20:12:52 <robreim> Ooh nice :)
20:14:18 <robreim> lovely. Endianness and everything :D
20:15:47 <dons> yeah. so currently support is for the low layer (i.e. roll your own) and for the Binary class (a read/show for binary serialisation)
20:16:04 <dons> packing and unpacking external formats will need some parse combinators on top, i think
20:16:10 <dons> and bit handling
20:16:29 <dons> but there's enough there already to write a lazy 'tar' implementation, bjorn did this during the hackathon
20:17:22 <SamB> are we talking about getting darcs to use tarballs for its checkpoints?
20:17:31 <dons> hmm?
20:17:34 <robreim> that's dead sexy.
20:17:46 <dons> bjorn's stuff was in the context of hackage reading tarballs for .cabal file
20:17:53 <dons> info
20:17:54 <SamB> oh
20:18:05 <SamB> well I think tarball checkpoints would be nice, too ;-)
20:18:16 <dons> isn't that what darcs dist does?
20:18:47 <SamB> you know how darcs checkpointing works?
20:19:01 <SamB> those things you use with --partial?
20:19:07 <dons> ah sorry, you want those things zipped up
20:19:18 <SamB> yeah
20:31:34 * sjanssen thinks Oleg has it in for GADTs
20:32:10 <allbery_b> jealous? :)
20:33:24 <dons> well, at least he likes to show how things can also be encoded in type classes in h98 :)
20:33:40 <dons> which is often astonishing
20:33:41 <SamB> hmm, if lojban is regular, does that mean I can use regular expressions to parse it?
20:33:41 <bos> sjanssen: what happened with your SOC stuff last year?
20:34:24 <sjanssen> bos: you want the code? http://darcs.haskell.org/SoC/fps-soc/
20:34:26 <lambdabot> Title: Index of /SoC/fps-soc
20:34:34 * SamB goes to bed like a good boy
20:38:31 <TomMD> Humm, if you can't do record selection when there is an escaped type (using existential types here), then how can I update my record of a TVar
20:39:09 <bos> sjanssen: thanks. i see i was a few months late in implementing ropes :-)
20:39:29 <bos> sjanssen: have you made any effort to get this stuff into main fps?
20:40:17 <sjanssen> bos: I'm not sure that fps is the right place for the right stuff
20:40:34 <bos> true.
20:40:38 <sjanssen> especially since Data.ByteString.* has made it into the base package
20:41:01 <sjanssen> s/right stuff/rope stuff/
20:42:17 <bos> but finger trees haven't :-(
20:42:56 <bos> my rope code is a straight adaptation of the code from boehm's original paper. i was going to reimplement it using finger trees once i understood what was going on :-)
20:43:01 <sjanssen> bos: Data.Sequence has -- the slightly evil specialized version
20:43:18 <bos> ah.
20:43:41 <bos> what's the difference?
20:44:05 * sjanssen <3 Hinze-Paterson style finger trees
20:44:20 * sorear <3 memoization
20:44:42 <bos> <3 ?
20:44:42 <sjanssen> bos: it's derived from Data.FingerTree
20:45:28 <sjanssen> but instead of the general measurement/query mechanism, it only supports size measurements and indexing
20:45:39 <sjanssen> bos: read <3 as "heart"
20:46:11 <sorear> don't worry, I didn't know either until a couple days ago
20:46:13 <glguy> ?
20:46:55 <bos> i figured it was heart. i just don't know how to read it: does the FingerTree code have memoized lookups, or is that Sequence?
20:48:06 <sjanssen> bos: have you read Ralf Hinze and Ross Paterson, "Finger trees: a simple general-purpose data structure"?
20:48:35 <Pseudonym> I <3 (in Roman Numberals)
20:49:09 <sorear> glguy: neat!! diffs
20:49:19 <glguy> sorear: have you seen them in color?
20:49:25 <glguy> sorear: did you take a look at the code?
20:49:27 <sorear> huh?
20:49:30 <sorear> no
20:49:37 <sorear> they are in color
20:49:39 <bos> sjanssen: yes, i've read it.
20:49:52 <bos> the swiss army knife of functional data structures!
20:50:22 <sjanssen> bos: Data.FingerTree is nearly identical to the interface described in that paper
20:50:28 <bos> sjanssen: but my question related to why you described Data.Sequence as "slightly evil"
20:51:06 <bos> and i couldn't understand the answer you gave, because i couldn't tell which was the more specialised type from your description
20:51:18 <glguy> sorear: I just wanted you to see the code so you knew I wasn't calling diff -u :)
20:51:23 <sjanssen> Data.Sequence is the same thing with all the "swiss army" flexibility removed, with only deque operations supported
20:51:35 <bos> i see. thank you!
20:52:05 <sorear> glguy: hehe.
20:52:11 <bos> the deque behaviour is interesting, but i recall it was only one of about six different things they presented in the paper.
20:52:36 <bos> sjanssen: thank you for your patience. i've been chasing 4-year-olds around all day :-)
20:53:05 * glguy remembers to "add" diff code to darcs
20:55:44 <bos> sjanssen: it would be a shame to see your rope code rot unused.
20:56:03 <bos> did you get it to the point of being usable and benchmarkable?
20:57:10 <hyrax42> http://sequence.complete.org/node/258
20:57:12 <lambdabot> Title: A simple TCP server | The Haskell Sequence
20:57:22 <hyrax42> is it necessary to do a newTChan under atomically?
20:57:26 <sorear> no
20:57:32 <sorear> @index newTChanIO
20:57:33 <lambdabot> bzzt
20:57:36 <sorear> oh
20:57:44 <sorear> @index newTVarIO
20:57:45 <lambdabot> bzzt
20:57:48 <sorear> oh
20:58:00 <sorear> :t Control.Concurrent.STM.newTVarIO
20:58:02 <lambdabot> Not in scope: `Control.Concurrent.STM.newTVarIO'
20:58:07 <sorear> :t Control.Concurrent.STM.TVar.newTVarIO
20:58:09 <lambdabot> Not in scope: `Control.Concurrent.STM.TVar.newTVarIO'
20:58:16 <hyrax42> :t Control.Concurrent.STM.newTVar
20:58:17 <lambdabot> forall a. a -> GHC.Conc.STM (GHC.Conc.TVar a)
20:58:30 <sjanssen> bos: I believe it's usable
20:58:33 <hyrax42> ?
20:58:51 <hyrax42> sorear: you have me confused
20:59:16 <sorear> hyrax42: newTChanIO :: IO (TChan a) is in the HEAD docs
20:59:19 <sorear> use that
20:59:33 <sorear> esp. since atomically + unsafePerformIO = error
20:59:44 <hyrax42> oh I'm just asking about the usage in the post I linked
20:59:55 <hyrax42> cChan <- atomically newTChan
21:00:31 <hyrax42> I was unsure if the atomically is needed there or not
21:00:58 <dons> 
21:01:12 <hyrax42> dons: profound
21:01:28 <dons> oui
21:01:32 * glguy loves finding folds in seemingly complicated recursions
21:01:43 <sorear> dons: hehe. in lambdabot: getAnswer msg rest seenFM now
21:01:50 <sorear> I wonder what FM stands for?
21:01:56 <sorear> :)
21:02:01 <LoganCapaldo> loves seeing complicated recursions in folds
21:02:02 <glguy> finitemap?
21:02:15 <falconair> does haskell have a library for doing erlang type concurrent programming (actor model?) ?
21:02:44 <glguy> http://hpaste.ath.cx/~eric/hpaste/DiffHtml.hs -- follow function
21:03:13 <bd_> falconair: TChans can be abused to behave a bit like that...
21:04:08 <LoganCapaldo> this sounds like a job for an Actor monad
21:04:19 <sorear> PiMonad maybe?
21:04:19 <LoganCapaldo> (since monads solve everything ;) )
21:04:33 <falconair> bd_, is it accurate to think of STM as a very good potential solution to many problems with shared-state concurrency; but the actor model does away with shared-state completely...therefore requires no STM?
21:05:01 <sorear> @where rhaskell
21:05:02 <lambdabot> I know nothing about rhaskell.
21:05:24 <sorear> @where+ rhaskell http://www.informatik.uni-freiburg.de/~wehr/darcs/rhaskell
21:05:25 <lambdabot> Done.
21:05:37 <dons> finite map
21:05:50 <bd_> falconair: You could hide the usage of STM in a monad probably. The TChans would serve a purpose similar to the process IDs in erlang. The hard part then would be handling extracting only certain desired messages from the TChan...
21:05:52 <sorear> ^^^ I forget what exactly it is, but it also eliminates shared state - maybe it is the actor model
21:06:06 <bd_> you might be able to abuse Monad.fail for that though
21:06:21 <bd_> sorear: 403'd :)
21:06:45 <sorear> bd_: oh.  I got it from stefan@stefans:/usr/local/src/rhaskell$ cat _darcs/prefs/repos
21:07:21 <falconair> i don't have an actual project that requires haskell for concurrency ... i'm just wondering how haskell would compare to erlang if haskell implemented the same basic concurrency model (instead of comparing erlang's actors to haskell's shared state)
21:08:02 <sorear> idiot, I mis-spelled my own name in the IRC userinfo
21:08:38 <sorear> not Sefan anymore :)
21:09:02 <bd_> I'm thinking you could probably find some way to do receive $ (\(MessageConstructor arg) -> someResponse) <|> (\OtherConstructor -> someOtherResponse) ...
21:10:02 <LoganCapaldo> Couldn't you just receive $ (\message -> case message of ...)
21:10:36 <bd_> LoganCapaldo: Ah, but this would allow it to do nasty things with exceptions, skip that message, and look at the next one in the queue :)
21:10:44 <bd_> as erlang does
21:10:52 <LoganCapaldo> It would?
21:10:56 <bd_> probably
21:11:07 <falconair> erlang also claims to be able to do hundreds of thousands of concurrent processes, can haskell be made to do that?
21:11:10 <bd_> it'd be tricky to do it though
21:11:34 <bd_> falconair: haskell threads are quite cheap. I don't know how well hundreds of thousands work, but it should be easy enough to benchmark
21:11:43 <bd_> how will these threads be interacting? :)
21:11:54 <LoganCapaldo> Couldn't you force the type of the argument to receive to be a function that couldn't raise an exception (yes I sound like I'm making a monad :) )
21:12:02 <falconair> bd_ ... through message passing i suppose :)
21:12:51 <Korollary> There's such a benchmark at the shootout site.
21:12:59 <sjanssen> @where shootout
21:12:59 <lambdabot> http://shootout.alioth.debian.org/
21:13:12 <falconair> haskell usually seems to be the testbed for anything interesting, i'm surprised no one has built an actors library (like scala community has done)
21:13:14 <sjanssen> http://shootout.alioth.debian.org/gp4/benchmark.php?test=message&lang=all
21:13:17 <lambdabot> Title: cheap-concurrency benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer ..., http://tinyurl.com/njtgc
21:13:32 <sjanssen> falconair: note that Haskell is #3 there, right behind Erlang
21:13:57 <sorear> oh? what lang is "better" than Erlang?
21:14:18 * sorear isn't suprised a language designed for concurrency is higher than haskell, btw
21:14:18 <falconair> yeah, pretty good.  I'm surprised to see Mozart at the top, i wish those guys would make more of an effort to attract non-academics
21:15:19 <sorear> ooh, haskell beats erlang on code size!
21:15:21 <sjanssen> sorear: exactly.  The very fact that Haskell is right behind Erlang is cause for celebration
21:15:29 <falconair> memory too
21:16:06 <dons> i think we win in the other concurrency benchmark, iirc
21:16:09 <bd_> LoganCapaldo: <late> Any function can raise an exception. eg, undefined :)
21:16:28 <sjanssen> http://shootout.alioth.debian.org/gp4/benchmark.php?test=chameneos&lang=all
21:16:30 <lambdabot> Title: chameneos benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/lrhoa
21:16:48 <sjanssen> ^^^ the test dons mentioned
21:16:51 <LoganCapaldo> undefined isn't an exception, is it? :)
21:17:00 <dons> yeah
21:17:01 <dons> it is
21:17:04 <bd_> LoganCapaldo: it raises one
21:17:04 <dons> > undefined
21:17:05 <lambdabot>  Add a type signature
21:17:08 <dons> > undefined :: (O)
21:17:08 <lambdabot>   Not in scope: type constructor or class `O'
21:17:10 <dons> > undefined :: ()
21:17:11 <lambdabot>  Undefined
21:17:35 * LoganCapaldo was thinking more of throwError
21:17:35 <bd_> Control.Exception> try undefined
21:17:35 <bd_> Left Prelude.undefined
21:17:49 <bd_> @hoogle throwError
21:17:50 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
21:18:04 <sjanssen> LoganCapaldo: undefined isn't an exception in Haskell '98, but ghc treats it like one
21:18:29 <nmessenger> > throwError "blah" :: Maybe Int
21:18:30 <lambdabot>   add an instance declaration for (MonadError [Char] Maybe)
21:18:31 <lambdabot>     In the expres...
21:18:32 <LoganCapaldo> But I'll grant that you could throw a monkey wrench in the works with that
21:18:33 <sorear> ooh
21:18:36 <sorear> @karma+
21:18:37 <lambdabot> You have a karma of 17
21:19:08 <bd_> replicating erlang's message-passing system exactly is probably not the best approach anyway
21:19:20 <bd_> Use TChans and be happy, maybe? :)
21:19:22 <LoganCapaldo> Indeed
21:20:00 <bd_> If you want to make it absolutely solid, you could wrap STM and TChan in something which prevents non-local state
21:21:00 <sjanssen> STMified state doesn't seem so bad to me
21:21:34 <dons> the thing is, can erlang replicate all of haskell's concurrency mechanisms :)
21:21:50 <dons> haskell seems like a  bit of a concurrency playground, with all the fun systems we have
21:22:00 <dons> and now the new application level threads!
21:22:11 <dons> write your own custom scheduler, and have 100k threads :)
21:22:17 <sjanssen> dons: application level threads?
21:22:27 <dons> yeah, let me find the src
21:22:36 <dons> (on top of epoll, there was a talk at PADL)
21:23:37 <LoganCapaldo> Write your own scheduler? <g>
21:23:48 <LoganCapaldo> schedule :: [Thread] -> Thread
21:23:52 <LoganCapaldo> ?
21:23:52 <sorear> I'm kinda suprised the cheap concurrency benchmark doesn't just use lazy lists.
21:24:22 <sorear> map fusion could turn the whole thing into a single loop!
21:24:33 <dons> I think Li Peng is also doing an MS internship, with SimonM interested in replacing the whole concurrency framework, http://www.seas.upenn.edu/~lipeng/homepage/unify.html
21:24:34 <lambdabot> Title: Unifying events and threads
21:24:39 <sorear> hey - I think of lists as streams!
21:24:46 <dons> src here http://www.seas.upenn.edu/%7Elipeng/unify/unify-0.0.1.tar.gz
21:25:02 <dons> they had 64k threads running in their web server, iirc
21:25:09 <dons> we need to darcs package this stuff!
21:25:46 <sjanssen> dons: is it smp capable?
21:26:04 <falconair> dons, is there a paper which describes this?
21:26:35 <sjanssen> falconair: see the first link dons pasted
21:26:37 <dons> http://www.seas.upenn.edu/~lipeng/homepage/papers/lz06report.pdf
21:26:42 <dons> "A language-based approach to unifying events and threads", by Peng Li and Steve Zdancewic, April 2006.
21:26:50 <falconair> eh...didn't see the first link ,thanks :)
21:27:03 <dons> Steve gave a talk on this in Nice, and was very impressive. the code is nice too
21:27:06 <dons> i want some epoll!
21:27:46 <sorear> dons: Do you think of lazy lists as streams?
21:27:59 <dibblego> I think of streams as lazy lists
21:28:11 <sorear> I think cheap-concurrency could be made ... extremely optimizable
21:29:39 <luqui> can I use record syntax with gadts?
21:29:56 <luqui> or rather, regular data types written as gadts?
21:29:56 <sorear> yes!
21:30:01 <sorear> yes!
21:30:08 <luqui> in 6.6?
21:30:09 <sorear> data Foo where
21:30:30 <sorear> sorry forgot the syntax
21:30:39 <sorear> 6.6: unknown.
21:31:00 <LoganCapaldo> Hmm, if you did do erlangs concurrency model (and if Haskell optimizes tail calls) you could make the message send operator just call the body of process, etc. The whole thing would turn itself into a linear program
21:31:10 <LoganCapaldo> Or am I totally nuts?
21:31:37 <dons> http://programming.reddit.com/info/znkr/comments
21:31:39 <lambdabot> Title: Unifying events and threads for massively concurrent Haskell (pdf) (reddit.com)
21:31:39 <luqui>   Foo { val :: Bar } :: Foo
21:31:41 <dons> :)
21:31:53 <dibblego> data Foo = Foo{bar::Int}
21:32:06 <luqui> dibblego, asking about gadt syntax, but thanks :-)
21:32:40 <dibblego> oh
21:32:59 <sjanssen> LoganCapaldo: it'd work fine as long as your processes are nice enough to call send every once in a while
21:34:55 <sorear> :t Data.Map.lookup
21:34:57 <lambdabot> forall a (m :: * -> *) k. (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
21:35:58 <dons> sjanssen: yeah the application level threads run on top of smp
21:36:39 <dons> like the existing Control.Concurrent, but with more flexibility at the usre level (i.. rolling your own scheduler)
21:37:04 <bos> dons: you are a fountain of interesting pointers.
21:38:00 <dons> hey, i go to conferences :)
21:38:22 <bos> lucky you :-)
21:40:16 <glguy> bah, another HTML attribute found missing from Text.XHtml
21:40:21 <glguy> time to submit a patch
21:40:59 <dons> that's the way to get things done, glguy ! :)
21:41:29 <emu> so long as it's not BLINK
21:41:34 <glguy> disabled
21:43:24 <glguy> I use it to disabled the Diff button when there are no annotations
21:43:38 <glguy> to reduce the number of unnecessary diffs performed
21:43:46 <sorear> dons: bah. ghci is broken again.  ghc-6.6: could not execute: BotPP
21:43:46 <glguy> (you could still manually generate the url)
21:44:08 <sorear> it's in the curdir...
21:44:08 * glguy notes that elinks doesn't honor the disabled attribute
21:44:44 <sorear> oh wait that's the problem.
21:44:51 <sorear> nm
21:46:49 <sorear> oh swell, somethign broke and lambdabot consumed infinite space
21:47:33 <dfranke> at least it's only countably infinite.
21:50:34 <sorear> Main: caught (and ignoring) IRCRaised Data.Binary.Get.takeExactly: Wanted 8 bytes, found 0.. Failed reading at byte position 16
21:50:51 <sorear> no space warp, but yes error
21:54:10 <dons> format changed?
21:54:27 <sorear> I suppose that might've been vixenstate error
21:54:35 <dons> maybe one of the instances changed since you last linked
21:54:41 <sorear> since all I changed was in Karma
21:59:38 <glguy> Does HAppS ever clean up its state dir?
22:01:39 <dons> better ask on #happs :)
22:01:59 <glguy> but everyone in #happs is here :(
22:02:05 <glguy> plus more
22:02:09 <allbery_b> ...lazily, presumably :)
22:02:12 <Pseudonym> "But everything is in the Prelude!"
22:05:13 <bd_> @hoogle alloca
22:05:14 <lambdabot> Foreign.Marshal.Alloc.alloca :: Storable a => (Ptr a -> IO b) -> IO b
22:05:14 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
22:05:14 <lambdabot> Foreign.Marshal.Array.allocaArray :: Storable a => Int -> (Ptr a -> IO b) -> IO b
22:05:37 <glguy> is "ofter" a work in the UK influenced countries?
22:05:43 <glguy> ?spell ofter
22:05:44 <lambdabot> ofter
22:05:49 <glguy> word*
22:06:04 <dons> i'm not sure that's a word...
22:06:08 <dons> you mean perhaps 'more often' ?
22:06:19 <jql> sounds like a heavily accented after
22:06:21 <glguy> it's apparently a word
22:06:22 * dons guesses wildly
22:06:29 <jql> more of a queen's after
22:06:31 <dons> ?web1913 ofter
22:06:32 <lambdabot> *** "Ofter" web1913 "Webster's Revised Unabridged Dictionary (1913)"
22:06:33 <lambdabot> Ofter \Oft"er\, adv.
22:06:33 <lambdabot>    Compar. of {Oft}. [Obs.] --Chaucer.
22:06:34 <glguy> I'm just trying to pinpoint what region uses it
22:06:53 <dons> well, if its good enough for Chaucer..
22:07:01 * allbery_b has certainly encountered "oftener" in some varieties of Commonwealth-influenced English; ... yeh that
22:07:15 <jql> If Chaucer is the only reference, I'd not use it in real life. :)
22:07:16 <araujo> hola!
22:08:10 <bd_> @hoogle Ptr a -> IO a
22:08:11 <lambdabot> No matches, try a more general search
22:08:35 <dons> hmm, is that poke . peek / :)
22:08:48 <dons> :t Foreign.poke
22:08:50 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> a -> IO ()
22:09:02 <sorear> dons: liftM2 (>>=) peek poke?
22:09:05 <dons> :t Foreign.peek
22:09:06 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO a
22:09:14 <dons> ah , peek
22:09:21 <dons> yes, of course
22:09:25 <bd_> ah, right :)
22:09:27 <sorear> :t liftM2 (>>=) Foreign.peek Foreign.poke
22:09:29 <lambdabot> forall a. (Foreign.Storable.Storable a) => GHC.Ptr.Ptr a -> IO ()
22:09:37 <bd_> <-- is looking at adapting the haskell IO manager to use epoll
22:09:42 <bd_> or well ghc
22:09:53 <dons> ah, you saw the earlier epoll references?
22:09:56 <bd_> yeah :)
22:09:58 <bd_> I was surprised, there's very little black magic there.
22:10:02 <dons> better talk to SimonM
22:10:03 <sorear> wow I got my multi-monad reader madness right
22:10:08 <bd_> SimonM?
22:10:13 <sorear> JaffaCake
22:10:24 <dons> since there's a plan for this already, I think
22:10:28 <sorear> or if you leave #haskell, Simon Marlow
22:10:37 <Saizan> if i have instance Read a => Class a,  and  instance Read a => Class (a,a)  do they count as overlapping instances?
22:10:44 <allbery_b> no
22:10:45 <bd_> dons: ah
22:10:48 <sorear> undecidable even!
22:11:33 <allbery_b> hm?
22:11:33 <sjanssen> Saizan: both of those instances are overlapping and undecidable on their own
22:11:54 <Saizan> sjanssen: ..how?
22:12:42 <sorear> dons: first skeletal support for nickeq sent ... establishes API, makes Karma use it, allows @karma xerox|edi
22:12:53 <sjanssen> Saizan: I should've said "potentially overlapping".  instance Read a => Class a will overlap any instance for a type that also instances Read
22:13:29 <sjanssen> "instance SomeClass a => OtherClass a" is, in general, bad news
22:13:59 <sorear> the idea of |-separation is that eventually you'll be able to say @tell oneguy|otherguy something one or the other needs to see
22:14:25 <glguy> ?hoogle disabled
22:14:26 <lambdabot> No matches found
22:14:35 * glguy checking for naming clashes
22:22:25 <sorear> dons: so ... security implications of @link.
22:22:37 <glguy>  @link?
22:22:54 <sorear> random ppl shouldn't be able to @link dons and get 118 karma!
22:23:02 <dons> hmm
22:23:07 <sorear> glguy: command/subsystem I'm working on
22:23:10 <dons> well, i'm not sure we even need this feature .. :)
22:23:17 <glguy> oh, karma linking?
22:23:19 <dons> since i don't understand what problem it solves
22:23:48 <glguy> people that regularly use nick, nick_ and nick__ would have one karma count?
22:23:50 <dons> some of these new features seem complex to me :)
22:23:53 <sorear> dons: some subsets of the feature are more useful than the general thing
22:23:56 <dons> and if they're complex, people won't use them ;)
22:24:13 <sorear> e.g. adhoc rules, freenode2:foo is linked to freenode:foo
22:24:20 <glguy> ah
22:24:29 <dons> do we have an example of how to connect to mulitple servers?
22:24:36 <dons> i.e. an rc file, or some documentation/
22:24:52 <dons> or conecting the same bot twice to freenode?
22:24:56 <sorear> dons: er, connect twice?
22:25:04 <dons> so lambdabot and lambdabot2 could be the same running bot instance?
22:25:26 <sorear> dons: that's a goal of multiserver
22:25:53 <dons> document document document though :) things are appearing faster than I know how to use them .
22:26:03 <dons> which is good, of course
22:26:07 <sorear> so instead of one @irc-connect command, have two.  /me is currently oblivious to any way of documenting that.
22:26:38 <dons> the commentary
22:26:53 <sorear> idea: comment: ! You can have as many irc-connect commands as you want
22:27:30 <dons> what does irc-connect do though? have i even used that? /me gets the feeling the src is moving too fast
22:27:46 <sorear> @help irc-connect
22:27:47 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
22:28:13 <sorear> e.g. @irc-connect freenode chat.freenode.net 6667 lambdabot Lambda_Robots:_100%_Loyal
22:30:35 <dons> well, i'd be inclined to keep things simple
22:30:38 <dons> the simpler the better
22:30:46 <sorear> I've also done a tiny amount of Jabber study... in Jabber, nicks are only meaningful in the context of one channel.  there are globally valid JIDs, but the mapping from nicks to JIDs is only available to ops.
22:32:01 <sorear> in my Current Plan, there are open polynicks (I'm making this far to complicated...) like *lambdabot, and you can @tell *lambdabot to send to any bot maintainer.
22:32:30 <sorear> a type of note Todo is added which doesn't autodelete, and *poof* Plugin/Todo.hs is subsumed
22:33:35 <sorear> eg. @todo sorear put up that file,  @todo *hpaste add library docs linking
22:36:13 <dons> hmm, but do we *need* these fancy features?
22:36:41 <dons> i'd be more interested in stabiity issues than yet more features
22:37:36 <glguy> ?seen
22:37:37 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
22:38:04 <sjanssen> huh?
22:38:07 <lambdabot> Take that, puny human.
22:38:10 <dons> see that? what's going on theere.
22:38:14 <dons> and when did that sneak in.
22:38:29 <sorear> Take that ... ? no clue.
22:39:01 <dons> seriously, i don't really like that message, and don't understand what the problem was in the first place..
22:39:04 <sorear> Due to the ... ? I sent it after mass protests from people who thought the bot was pinging them.
22:39:12 <dons> either it should be disabled, or it should be fixed
22:39:26 <dons> the "... ?" /
22:39:35 <dons> oh, all the nicks
22:39:42 <dons> well, why not just disable that command then
22:39:48 <allbery_b> the problem is bare ?seen blasts out nicks in a way that triggers clients set to listen for nicks.  some of us consider that behavior impolite at best; apparently, we are "broken"
22:39:51 <dons> keep it simple
22:39:54 <dons> yeah
22:39:59 <dons> but who needs that feature anyway?
22:40:07 <sorear> it makes perfect sense in /msg though...
22:40:17 <dons> well, disable it in channel
22:40:19 <dons> don't print the msg
22:40:24 <dons> silence is golden
22:40:47 <dons> i'm all for not being annoying :)
22:40:54 <Pseudonym> Actually a better answer would be to /msg back to the person issuing the request.
22:40:55 <glguy> ?src oh?
22:40:56 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
22:41:00 <glguy> dons ^^
22:41:00 <Pseudonym> Best of both worlds.
22:41:10 <dons> glguy: yeah, that was a bit silly too :)
22:41:18 <sorear> Pseudonym: that's what it does.
22:41:21 <dons> there's a few of these i'll clean up
22:41:22 <lambdabot> And your little dog, too!
22:41:35 <dons> sorear: and is that you msging the bot all the time?
22:41:39 <dons> since its a bit of an overuse ;)
22:41:42 <sorear> no
22:42:32 <sorear> and ... @activity-full isn't pointing any fingers.
22:42:34 <dons> sometimes it feels like lambdabot is taking over
22:42:54 <lambdabot> That command wouldn't have worked, too, if it wasn't for you meddling kids!
22:43:13 <dons> hmm.
22:43:21 <hpaste> I can do that too
22:43:53 <dons> maybe i'm jetlagged, or maybe lambdabot needs a good kick in the repos
22:44:10 <sjanssen> heh
22:44:18 <sjanssen> I agree that the @seen response is overly snarky
22:44:45 <sorear> Pseudonym: be careful, @seen is a rat
22:44:50 <sorear> @seen Pseudonym
22:44:51 <lambdabot> Pseudonym is in #haskell-blah and #haskell. I last heard Pseudonym speak 1m 57s ago.
22:45:08 <sorear> right at the time of the That command ... !
22:45:45 <hpaste> some-clown pasted some-dumb-paste at find-it-yourself
22:45:48 <glguy> ;)
22:45:58 <dons> heh
22:46:00 <sorear> Now I know why @seen tracks /msgs.
22:46:19 <Pseudonym> :-)
22:46:55 <dons> one thing, sorear, is when a new comman is introduced, to demonstrate it a few times in channel, so people learn how it works
22:47:06 <dons> do this as often as you need, to make sure people know :)
22:47:12 <glguy> or at least make sure that COMMMANDS gets regenerated
22:47:21 <blackdog> dons: deliberate gospel quote?
22:47:22 <glguy> so that I can discover it by tabing
22:47:24 <Pseudonym> The sock puppet command was actually the third that I added.
22:47:32 <Pseudonym> After @join and @hello.
22:47:39 <glguy> @hello
22:47:40 <lambdabot> Maybe you meant: help tell
22:47:41 <blackdog> are you at last our functional messiah?
22:47:43 <Pseudonym> The bot isn't so useful without @koin.
22:47:44 <Pseudonym> @join
22:47:51 <Pseudonym> Yeah, I don't think hello is there any more.
22:47:58 <Pseudonym> It just said "hello world".
22:48:03 <sorear> it's still in the code
22:48:08 <sorear> Plugin.Hello
22:48:12 <glguy> !id hello world
22:48:13 <hpaste> hello world
22:48:26 <sorear> !id notice the lack of a responce
22:48:26 <glguy> I need to come up with some clever commands :)
22:49:02 <hpaste> notice the lack of response
22:49:11 <Pseudonym> What I'd _like_ to do is have a closed monad in which everything runs.
22:49:20 <Pseudonym> And instead of "
22:49:22 <sorear> wow, even hpaste is making typos now
22:49:25 <glguy> sorear: hpaste had to spellcheck your command first
22:49:28 <Pseudonym> commands", make everything an expression.
22:49:41 <Pseudonym> > seen ["dons"]
22:49:42 <lambdabot>   Not in scope: `seen'
22:49:43 <Pseudonym> That sort of thing.
22:49:51 <sorear> I wanted that too
22:50:08 <glguy> if commands were exposed to ">"
22:50:14 <glguy> then you'd have to break the line between io
22:50:20 <glguy> and otherwise...?
22:50:29 <Pseudonym> There is no IO in @eval.
22:50:42 <glguy> I just mean that commands like @seen
22:50:49 <glguy> would need access to the state?
22:50:52 <sorear> if you newtype IO as LBC, and only export LBC commands that are safe, then ...
22:50:53 <Pseudonym> Sure.
22:50:55 <glguy> for > seen you to work
22:51:18 <sorear> 10:47p, bedtime=10:00p :(
22:51:26 <Pseudonym> But that's okay.
22:51:33 <dons> i'd like that too
22:51:33 <glguy> oh ok
22:51:34 <Pseudonym> Implementations of commands would be allowed to look inside the state.
22:51:37 <dons> but don't have a good scheme for hacking it in
22:51:41 <Pseudonym> The eval interpreter itself would not.
22:51:46 <dons> though we've though a bit about it over the years
22:51:51 <Pseudonym> Yeah.
22:51:59 <Pseudonym> Anyway.
22:52:02 <Pseudonym> Gotta go.  Nytol!
22:52:21 <dons> yeah, plane flights are too long. /me crashes instead
22:52:34 <richcollins> a -> b -> c is the same as (a -> b) -> c right?
22:52:41 <glguy> nope
22:52:46 <glguy> a -> (b -> c)
22:52:50 <sjanssen> dons: have you already removed the in channel @seen response?
22:53:11 <twanvl> !id > 1+1
22:53:12 <richcollins> glguy, So you have a function applied to a that returns a function?
22:53:32 <richcollins> i.e. a higher order function
22:53:46 <glguy> richcollins: right, that's called currying
22:53:54 <richcollins> hrm
22:54:07 <glguy> (+) :: Num a => a -> (a -> a)
22:54:17 <nmessenger> richcollins, yep, but (a -> b) -> c takes a *function* from a to b, and returns a c.
22:54:18 <glguy> (+) 1 :: Num a => a -> a
22:54:24 <richcollins> then how is this (a->b) -> [a] -> [b] not (a -> [b]) -> [a]
22:54:35 <richcollins> err
22:55:05 <richcollins> ((a -> b) -> [b]) -> [a]
22:55:38 <allbery_b> where did you find that?
22:55:38 <glguy> that means given a function that takes a function a -> b and returns a [b]
22:55:40 <glguy> return a [a]
22:56:24 <glguy> (a -> b) -> [a] -> [b] means: given a function a -> b, return a function [a]->[b]
22:56:36 <richcollins> right maybe that is a typo then
22:56:39 <richcollins> http://www.haskell.org/tutorial/functions.html
22:56:40 <lambdabot> Title: A Gentle Introduction to Haskell: Functions
22:56:42 <richcollins> that is map
22:57:03 <glguy> richcollins: what section is the typo in?
22:57:13 <richcollins> (a->b) -> [a] -> [b]
22:57:24 <richcollins> unless map returns a function, not a value
22:57:25 <glguy> :t map
22:57:27 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
22:57:36 <glguy> richcollins: that is the correct type of map
22:57:45 <glguy> map takes a function that operates on an element
22:57:53 <glguy> and returns one that operates on lists of that element
22:57:54 <richcollins> so it returns a function [a] -> [b]
22:57:58 <glguy> right
22:57:59 <richcollins> ah ok
22:58:11 <richcollins> I thought map was the function that operated on the lists
22:58:12 <richcollins> gotcha
22:58:23 <glguy> > ( map (+1) ) [1,2,3,4]
22:58:25 <lambdabot>  [2,3,4,5]
22:58:29 <richcollins> meaning I thought you gave map a list and a function
22:58:34 <richcollins> and it returns a list
22:58:35 <glguy> > map (+1) [1,2,3,4]
22:58:37 <lambdabot>  [2,3,4,5]
22:58:42 <glguy> richcollins: it is
22:58:53 <nmessenger> richcollins, it means the same, but the arg order is reversed from what you said.
22:59:12 <glguy> > let for = flip map in for [1,2,3,4] (+1)
22:59:13 <lambdabot>  [2,3,4,5]
22:59:29 <nmessenger> 'map f' is a function from lists to lists, 'map f xs' is a list
22:59:37 <richcollins> ah ok
22:59:58 <glguy> because: (map f) xs    is the same as    map f xs
23:00:23 <richcollins> what is the term used in haskell for specialization, generics, multiple dispatch ... etc in other languages?
23:00:23 <nmessenger> function application has strong fixity
23:00:42 <nmessenger> typeclasses?
23:00:53 <richcollins> basically polymorphism based on argument types
23:01:06 <nmessenger> :t (+1)
23:01:08 <lambdabot> forall a. (Num a) => a -> a
23:01:10 <LoganCapaldo> parametric polymorphism?
23:01:17 <nmessenger> :t (+1) (5 :: Int)
23:01:19 <lambdabot> Int
23:01:23 <nmessenger> :t (+1) (5 :: Double)
23:01:25 <lambdabot> Double
23:01:41 <Ytinasni> :t (+1) 5
23:01:42 <lambdabot> forall a. (Num a) => a
23:02:01 <nmessenger> "for all types 'a' in the 'Num' class"
23:02:02 <richcollins> LoganCapaldo, That sounds good
23:02:14 <LoganCapaldo> :t (1 :: Int) + (2 :: Double)
23:02:16 <lambdabot>     Couldn't match `Int' against `Double'
23:02:16 <lambdabot>       Expected type: Int
23:03:01 <nmessenger> > read "5" :: Int -- also polymorphic on return types!
23:03:02 <lambdabot>  5
23:03:05 <nmessenger> > read "5" :: Double
23:03:06 <lambdabot>  5.0
23:03:24 <nmessenger> :t read
23:03:26 <lambdabot> forall a. (Read a) => String -> a
23:03:52 <glguy> hpaste, url
23:03:53 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
23:03:55 <nmessenger> "for any type 'a' in the 'Read' class, 'read' turns a 'String' into an 'a'"
23:04:54 * glguy wonders
23:05:01 * LoganCapaldo wonders if read "5" :: Int is all that much better than readInt "5"
23:05:13 <glguy> is that the same as:  String -> (exists a . Read a => a)
23:05:14 <LoganCapaldo> Either way you end up writing the function
23:05:31 <nmessenger> LoganCapaldo, it's better if you want to write code that works for any readable type.
23:05:40 <LoganCapaldo> Oh I guess if you have more context its less typing actually
23:05:45 <allbery_b> the benefit is that Haskell can derive Read for types containing types already in Read
23:05:48 <glguy> LoganCapaldo: and in most code the Int can be determined from context
23:06:16 <allbery_b> e.g. data Foo = Foo Int deriving (Read) -- I can now read a Foo
23:06:19 <nmessenger> LoganCapaldo, and if you have less context, it can be used in more places :P
23:06:49 <nmessenger> > read "Just ['w','o','w']" :: Maybe String -- don't know if this works
23:06:50 <lambdabot>  Just "wow"
23:07:09 <allbery_b> ?src String
23:07:10 <lambdabot> type String = [Char]
23:07:13 <LoganCapaldo> Wait
23:07:19 * nmessenger waits
23:07:19 <allbery_b> I would expect it to hande either representation
23:07:24 <LoganCapaldo> Read is defined for Maybe
23:07:28 <LoganCapaldo> thats pretty brilliant
23:07:35 <nmessenger> @instances Read
23:07:37 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
23:07:40 <LoganCapaldo> err Maybe is an isntance of Read I mean
23:07:44 <LoganCapaldo> (not defined for maybe)
23:08:31 <LoganCapaldo> > read "Just 23" :: Maybe String
23:08:33 <lambdabot>  Exception: Prelude.read: no parse
23:08:39 <nmessenger> richcollins, question answered?
23:08:42 <allbery_b> I think it's actually derived
23:08:42 <LoganCapaldo> Darn
23:08:53 <LoganCapaldo> Not quite the result I was hoping for
23:09:04 <allbery_b> > read "Just \"23\" :: Maybe String
23:09:05 <lambdabot>  Improperly terminated string
23:09:08 <allbery_b> oops
23:09:13 <allbery_b> > read "Just \"23\"" :: Maybe String
23:09:15 <lambdabot>  Just "23"
23:09:25 <glguy> LoganCapaldo: you expected it to return an incorrect answer?
23:09:33 <allbery_b> strings require quotes, or [Char] syntax.
23:09:49 <glguy> > read "Just         \"23\"      " :: Maybe String
23:09:49 <LoganCapaldo> What I really wanted was read "23" :: Maybe String, vs. read read "23" :: Maybe Int
23:09:51 <lambdabot>  Just "23"
23:10:03 <LoganCapaldo> the first would return Nothing, the second Just 23
23:10:03 <nmessenger> "abc" is sugar for ['a','b','c'] is sugar for 'a':'b':'c':[]
23:10:13 <richcollins>  f
23:11:53 <nmessenger> :t \s -> case reads s of {[(x,_)] -> Just x; _ -> Nothing}
23:11:55 <lambdabot> forall a. (Read a) => String -> Maybe a
23:12:17 <LoganCapaldo> nmessenger, yeah like that :)
23:12:26 <richcollins> is there an interactive haskell interpreter?
23:12:35 <allbery_b> ghci and hugs
23:12:38 <LoganCapaldo> theres at least two
23:12:50 <bd_> @hoogle (a -> Bool) -> [a] -> ([a],[a])
23:12:50 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
23:12:51 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
23:12:51 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
23:12:52 <glguy> lambdabot: ?
23:12:53 <lambdabot> Maybe you meant: . activity activity-full admin all-dicts arr ask b52s babel bf botsnack brain bug check choice-add choose clear-messages compose devils dice dict dict-help djinn djinn-add djinn-clr
23:12:53 <lambdabot> djinn-del djinn-env djinn-names djinn-ver docs dummy easton echo elements elite eval fact fact-cons fact-delete fact-set fact-snoc fact-update faq figlet figlet' flush foldoc fortune fptools free
23:12:53 <lambdabot> freshname ft gazetteer get-shapr ghc girl19 google gsite gwiki help hitchcock hoogle hoogle+ id index instances instances-importing irc-connect jargon join karma karma+ karma- karma-all keal kind
23:12:54 <nmessenger> :t \s -> case reads s of {[(x,_)] -> return x; _ -> fail "no parse"} -- even better
23:12:55 <richcollins> any recommendations for OS X?
23:12:56 <lambdabot> learn leave let list listall listchans listmodules listservers localtime localtime-reply lojban map messages messages? more msg nazi-off nazi-on offline oldwiki palomer part paste pl pl-resume
23:12:57 <allbery_b> ...with limitations, e.g. noo top level definitions
23:12:59 <lambdabot> pointful pointless pointy poll-add poll-close poll-list poll-remove poll-result poll-show pretty print-notices protontorpedo purge-notices quit quote rc read reconnect redo remember repoint run
23:13:02 <lambdabot> forall (m :: * -> *) a. (Read a, Monad m) => String -> m a
23:13:03 <glguy> whoa
23:13:04 <lambdabot> [3 @more lines]
23:13:14 <allbery_b> yow
23:13:19 <nmessenger> @yow!
23:13:20 <lambdabot> You mean now I can SHOOT YOU in the back and further BLUR th'
23:13:20 <lambdabot> distinction between FANTASY and REALITY?
23:13:28 <LoganCapaldo> @nobotsnack
23:13:29 <lambdabot> :)
23:13:39 <nmessenger> @badbot
23:13:40 <lambdabot> Unknown command, try @list
23:13:40 <glguy> ?tell dons lambdabot: ?   -- causes lambdabot to list nearly all of the commands to channel, many lines
23:13:41 <lambdabot> Consider it noted.
23:13:42 <LoganCapaldo> lol
23:13:57 <nmessenger> @slap yourself
23:13:57 <lambdabot> why on earth would I slap yourself
23:14:09 <glguy> ?protontorpedo
23:14:09 <lambdabot> can I build something that lets laptop users sync contacts and client dta over the net?
23:14:10 <dfranke> @slap ChanServ
23:14:11 * lambdabot beats up ChanServ
23:14:13 <LoganCapaldo> Poor yourself
23:14:29 <glguy> richcollins: I use ghci on os x
23:14:29 <LoganCapaldo> LOL
23:14:35 <LoganCapaldo> ?protontorpedo
23:14:35 <nmessenger> anyway, did you see the monadic version, LoganCapaldo?
23:14:36 <lambdabot> wat is lazy evaluation?
23:14:50 <glguy> richcollins: it's an overnight install with macports (formerly darwinports)
23:14:52 <allbery_b> ghci is generally preferred around here, as hugs is rather out of date
23:15:00 <LoganCapaldo> nmessenger, monadic version of what?
23:15:07 <allbery_b> lots of useful extensions it doesn't do
23:15:11 <richcollins> ah good.  I already have ghc
23:15:17 <nmessenger> LoganCapaldo, the maybeRead function
23:15:28 <allbery_b> <nmessenger> :t \s -> case reads s of {[(x,_)] -> return x; _ -> fail "no parse"} -- even better
23:15:46 <nmessenger> @let readM s = case reads s of {[(x,_)] -> Just x; _ -> Nothing}
23:15:47 <lambdabot> Defined.
23:15:59 <allbery_b> lets you choose your poison:  Maybe, Either String, [], even IO to get an actual exception
23:16:09 <nmessenger> > readM "blah!" :: Either String Int
23:16:10 <lambdabot>  Couldn't match `Either String Int' against `Maybe a'
23:16:11 <LoganCapaldo> Mmm deliciously monadic
23:16:25 <nmessenger> @undef
23:16:25 <glguy> nmessenger: wouldn't readM use return and fail?
23:16:26 <lambdabot> Undefined.
23:16:39 <nmessenger> @let readM s = case reads s of {[(x,_)] -> return x; _ -> fail "no parse"}
23:16:39 <lambdabot> Defined.
23:16:45 <LoganCapaldo> it would, unless he made a boo boo ;)
23:16:59 <nmessenger> glguy, yep.  dumb command history :P
23:17:13 <nmessenger> > readM "blah!" :: Either String Int
23:17:15 <lambdabot>  Left "no parse"
23:17:20 <LoganCapaldo> Thats ok I tried to tab complete monadic before
23:17:31 <nmessenger> > readM "blah!" :: IO Int
23:17:32 <lambdabot>  <IO Int>
23:17:43 <nmessenger> (would cause an exception)
23:17:46 <allbery_b> not so useful in lambdabot :)
23:17:49 <glguy> :t readIO
23:17:51 <lambdabot> forall a. (Read a) => String -> IO a
23:18:01 <glguy> that one exists :)
23:18:19 <LoganCapaldo> Is there a readM in Control.Monad or some such?
23:18:20 <glguy> readLn = readIO =<< getLine
23:18:22 <nmessenger> ?hoogle (Monad m, Read a) => String -> m a
23:18:23 <LoganCapaldo> seems like a good idea
23:18:23 <lambdabot> Prelude.error :: String -> a
23:18:24 <lambdabot> Debug.Trace.trace :: String -> a -> a
23:18:38 <glguy> ?src readLn
23:18:38 <lambdabot> readLn =  do l <- getLine; r <- readIO l; return r
23:18:47 <LoganCapaldo> esp. since you could use it to implement readIO, readMaybe, etc.
23:18:47 <nmessenger> @karma- @hoogle
23:18:47 <lambdabot>  @hoogle's karma lowered to -1.
23:18:54 <allbery_b> there are some arguments as to whether using monads like that is a good idea (vs. using MonadError)
23:19:18 <allbery_b> some feel "fail" doesn't belong in generic monads
23:19:19 <LoganCapaldo> I see he said, not really seeing :)
23:19:40 <richcollins> if map returns a function that takes a list as an arg and returns a list, why can't I call map (+1) without the list to get a function?
23:19:42 <allbery_b> ask Cale about it sometime if you want the full rant :)
23:19:54 <allbery_b> yyou can
23:19:57 <LoganCapaldo> You can
23:20:03 <hpaste> *channel spam* "Haskell paste bin, now with 50% more diff capabilities"
23:20:04 <nmessenger> richcollins, you *can*, but the repl can't print the function
23:20:07 <allbery_b> I[m betting you get an error about no instance for (Show ...)
23:20:08 <richcollins> ah ok
23:20:17 <richcollins> right makes sense
23:20:18 <allbery_b> which means that ghci doesn't know how to disply functions
23:20:19 <LoganCapaldo> map (+1) -- Its been "called" and returned the function
23:20:29 <richcollins> No instance for (Show ([a] -> [a]))
23:20:34 <allbery_b> right
23:20:35 <richcollins> right no type def for show
23:20:59 <allbery_b> it's easy enough to define a trivial instance for Show for functions, just oto prove something happened
23:21:19 <nmessenger> > show (typeOf (map (+(1::Int)))
23:21:20 <lambdabot>  Parse error
23:21:21 <glguy> > map (+ (1 :: Int) )
23:21:23 <lambdabot>  <[Int] -> [Int]>
23:21:32 <richcollins> Is the AST stored in any Haskell implementations?
23:21:34 <LoganCapaldo> type Function = a -> b deriving Show ;)
23:21:51 <LoganCapaldo> (Not that that would work)
23:22:04 <glguy> especially since "type" can't "derive"
23:22:25 <nmessenger> instance Typeable a => Show a where {show x = "<" ++ show (typeOf x) ++ ">"}
23:22:35 <LoganCapaldo> data (->) a b deriving Show? ;)
23:23:03 <LoganCapaldo> Oh wait, data Function a b = (->) a b deriving Show
23:23:14 <glguy> ?src Typeable.show
23:23:15 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
23:23:30 <allbery_b> ?src Typeable show
23:23:31 <lambdabot> Source not found. Where did you learn to type?
23:23:43 <LoganCapaldo> Not that (->) is really a constructor for functions
23:23:54 <glguy> ?instances Monad
23:23:55 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
23:23:58 <nmessenger> LoganCapaldo, 'tis!  Just abstract.
23:24:29 <LoganCapaldo> Its a constructor for *types* of functions isn't it though?
23:24:37 <LoganCapaldo> Not for the functions themselves?
23:24:37 <allbery_b> :t (->)
23:24:39 <lambdabot> parse error on input `->'
23:24:43 <allbery_b> :k (->)
23:24:45 <lambdabot> ?? -> ? -> *
23:24:56 <nmessenger> Ah, yes, type constructor, you already knew
23:24:57 <sjanssen> LoganCapaldo: -> is a type constructor
23:24:58 <allbery_b> it's a metaoperator on types, hence it has a kind
23:25:00 <glguy> :t (->) Int Int
23:25:02 <lambdabot> parse error on input `->'
23:25:11 <allbery_b> (not a type)
23:25:11 <glguy> :k (->) Int Int
23:25:13 <lambdabot> *
23:25:45 <LoganCapaldo> :k ([])
23:25:47 <lambdabot> * -> *
23:26:03 <LoganCapaldo> :k (Maybe)
23:26:04 <nmessenger> :k [] Int
23:26:05 <lambdabot> * -> *
23:26:06 <lambdabot> *
23:26:08 <glguy> > read "\"abc\"" :: [] Char
23:26:10 <lambdabot>  "abc"
23:26:25 <LoganCapaldo> LOL
23:26:40 <LoganCapaldo> Haskell is consistent in the silliest ways some times :)
23:26:49 * nmessenger thinks the list type constructor should be called 'List'
23:27:11 * LoganCapaldo agress with nmessenger
23:27:20 <LoganCapaldo> What about tuples though?
23:27:27 <LoganCapaldo> do they still get to be (Int, Double), etc?
23:27:33 <allbery_b> :k (,)
23:27:35 <lambdabot> * -> * -> *
23:27:42 <allbery_b> :k (,,)
23:27:44 <lambdabot> * -> * -> * -> *
23:27:57 <nmessenger> Tuple2, Tuple3, Tuple4?  Maybe not.
23:28:08 <allbery_b> > (,,) 3 4 5 :: (Int,Int,Int)
23:28:09 <lambdabot>  (3,4,5)
23:28:13 <LoganCapaldo> read "(1,\"abc\")" :: (,,) Int String
23:28:16 <hpaste>  glguy annotated "First work towards diff" with "completed diff code" at http://hpaste.ath.cx:8000/22#2
23:28:31 <LoganCapaldo> > read "(1,\"abc\")" :: (,,) Int String
23:28:32 <lambdabot>      `(,,) Int String' is not applied to enough type arguments
23:28:32 <lambdabot>     Expected k...
23:28:36 * nmessenger wonders if anybody's ever used higher-kinded partially-applied tuples in any type expressions
23:28:43 <LoganCapaldo> doh
23:28:47 <LoganCapaldo> > read "(1,\"abc\")" :: (,) Int String
23:28:48 <lambdabot>  (1,"abc")
23:29:24 <LoganCapaldo> read "(1,\"abc\")" :: 2-Tuple Int [Char] ;)
23:29:36 <glguy> the only lines I didn't change in my diff code were the empty lines and the "where" lines :)
23:30:58 <LoganCapaldo> let Tuple2 = (,) in read "(1,1)" :: Tuple2 Int Int
23:31:22 <LoganCapaldo> > let Tuple2 = (,) in read "(1,1)" :: Tuple2 Int Int
23:31:23 <lambdabot>   Not in scope: type constructor or class `Tuple2'
23:31:26 <allbery_b> let can't create types/type constructors
23:31:39 <nmessenger> 'List' would be easier to visually unify with fmap's 'f' for someone unfamiliar with the [] type sugar.
23:31:49 <LoganCapaldo> I guess it would have to be type Tuple2 a b = (,) a b
23:33:52 <nmessenger> Is there a syntax for infix type constructors other than (->)?  The same as the (:!) syntax for data constructors?
23:34:48 <int-e> nmessenger: in Haskell 98, no. GHC supports :... style infix type constructors.
23:35:07 * nmessenger tries 'type a :* b = (a,b)' in a scratch file
23:35:28 <int-e> probably needs -fglasgow-exts (but I'm not really sure)
23:36:12 <LoganCapaldo> data a :* b = a :* b -- Lets really have some fun
23:36:22 <nmessenger> int-e, it was accepted, with a warning
23:36:53 <nmessenger> type a :+ b = Either a b -- :)
23:38:52 <LoganCapaldo> oooo :(
23:39:14 <LoganCapaldo> :t displays it like (:*) t [Char]
23:39:16 <lambdabot> Not in scope: `displays'
23:39:17 <lambdabot>  
23:39:17 <lambdabot> <interactive>:1:9: Not in scope: `it'
23:39:24 <LoganCapaldo> what's the point of that?
23:39:34 <LoganCapaldo> oops
23:40:17 <nmessenger> LoganCapaldo, not many people playing with type-level syntax sugar, so I'd guess it'd be not well supported
23:40:30 * nmessenger wants type-level sections!
23:41:08 <nmessenger> Hmm, but (:?? b) would require a type-level flip, wouldn't it?
23:41:36 <LoganCapaldo> data a :* b = a :* b has to be the vaguest declaration ever <g>
23:41:54 <nmessenger> just as vague as 'data (a, b) = (a, b)' :P
23:42:54 <LoganCapaldo> data [a] = [] | [a] | [a,a] | [a,a,a] | ...
23:43:34 <nmessenger> [x,y,z] is sugar for x:(y:(z:[]))
23:43:42 <LoganCapaldo> Yes I know :)
23:43:53 <nmessenger> so you'd only need 'data [a] = [] | a : [a]'
23:44:07 <nmessenger> or 'data List a = Nil | Cons a (List a)'
23:45:45 <LoganCapaldo> data [a] = [] | [ fix (a,) ] ;)
23:45:54 * nmessenger ponders the semantics of a type-level flip
23:46:42 <int-e> type Flip t a b = t b a
23:46:43 <LoganCapaldo> Is T a b isomorphic to T b a?
23:47:24 <nmessenger> Ah!
23:47:42 <int-e> nmessenger: but you'll run into trouble with kinds sooner or later I think.
23:47:49 <LoganCapaldo> int-e, stop it, you're scaring me :)
23:47:55 <Jaak> > 1 + 1:(2:(3:[]))
23:47:56 <lambdabot>  [2,2,3]
23:48:54 <nmessenger> Jaak, expecting 'map (+1)'?
23:48:59 <Jaak> no
23:49:42 <Jaak> [1,2,3] is not quite same as 1:(2:(3:[]))
23:50:00 <nmessenger> add another level of parens and it should be
23:50:06 <Jaak> yea
23:50:06 <int-e> but it's the same as (1:2:3:[])
23:50:24 <vegai>  "It's OK to figure out murder mysteries, but you shouldn't need to figure out code. You should be able to read it." - Steve C McConnell
23:50:34 <vegai> how does that sound to the Haskell crowd? :)
23:50:51 <sieni> if it was hard to write, it should be hard to read as well!!!1!
23:51:27 <nmessenger> If it's a hard problem, it'll take pondering, regardless of language.  Haskell makes stuff concise, though, so fewer places to jump to while pondering.
23:51:56 <LoganCapaldo> > fix (1,) -- I wonder how the infinite type error will look
23:51:56 <lambdabot>  Parse error
23:52:07 <nmessenger> > fix ((,) 1)
23:52:08 <lambdabot>      Occurs check: cannot construct the infinite type: a = (a1, a)
23:52:08 <lambdabot>       Expe...
23:52:09 <LoganCapaldo> Parse error?
23:52:23 <astrolabe> Sometimes an algorithm is innately difficult.  The code should be as clear as possible thought.
23:52:29 <int-e> vegai: some algorithms are inherently tricky.
23:52:29 <astrolabe> *though
23:52:41 <astrolabe> int-e: :)
23:53:12 <LoganCapaldo> Why can't you say (1,)? Come on, thats a perfectly cromulent section
23:53:30 <nmessenger> LOGAN WANTS MORE SUGAR!
23:53:40 <LoganCapaldo> :t (\x -> (1,  x))
23:53:42 <lambdabot> forall a b. (Num a) => b -> (a, b)
23:53:48 <int-e> :t (,) 1
23:53:49 <lambdabot> forall a b. (Num a) => b -> (a, b)
23:53:55 <int-e> :t flip (,) 1
23:53:56 <lambdabot> forall a b. (Num b) => a -> (a, b)
23:53:59 <nmessenger> (,) is not quite an operator, so no section
23:54:18 <LoganCapaldo> Hmmmm
23:54:25 <LoganCapaldo> > (1 `,`)
23:54:26 <lambdabot>  Parse error
23:54:29 <int-e> > (1 `(,)`) -- syntax error.
23:54:29 <lambdabot>  Parse error
23:54:32 <LoganCapaldo> drat
23:54:54 <nmessenger> 1 `(`(+)`)` 2 -- :P
23:55:01 <LoganCapaldo> > let f = (,) in (1 `f`)
23:55:02 <lambdabot>  Add a type signature
23:55:37 <LoganCapaldo> > let f = (,) in (1 `f`) :: (Num a) => b -> (a, b)
23:55:38 <lambdabot>  Add a type signature
23:55:46 <LoganCapaldo> I did!
23:55:50 <int-e> @type let f = (,) in (1 `f`)
23:55:51 <nornagon> :t (,)
23:55:52 <nmessenger> > let (:+) :: a -> b -> (a,b); (:+) = (,) in (1 :+)
23:55:52 <lambdabot>  Parse error
23:55:52 <lambdabot> forall a b. (Num a) => b -> (a, b)
23:55:53 <lambdabot> forall b a. a -> b -> (a, b)
23:55:57 <int-e> use @type :)
23:56:21 <int-e> or :t, right.
23:56:21 <vegai> nmessenger, int-e: on the other hand, things such as rev = foldl (flip (:)) -- easy to read?
23:56:41 <vegai> rev = foldl (flip (:)) [] -- of course :)
23:56:42 <int-e> vegai: that depends :)
23:57:03 <LoganCapaldo> @djinn a -> (a, b)
23:57:04 <lambdabot> -- f cannot be realized.
23:57:05 <int-e> vegai: once you've wrapped your head around the varios folds this doesn't take much thinking to verify.
23:57:15 <int-e> *various
23:57:20 <nornagon> :t (,)
23:57:22 <lambdabot> forall b a. a -> b -> (a, b)
23:57:43 <nmessenger> LoganCapaldo, monomorphism restriction on the local 'f', so 'f' itself needs an explicit signature
23:57:50 <nornagon> > let (,) = (:) in (1,2,[])
23:57:51 <lambdabot>      Constructor `(,)' should have 2 arguments, but has been given 0
23:57:52 <lambdabot>     When...
23:58:10 <nornagon> > let (,) = (:) in 1,2,[]
23:58:11 <lambdabot>  Parse error
23:58:12 <nmessenger> ',' is not an operator character, yes?
23:58:20 <LoganCapaldo> @type (\x -> (x, undefined)) :: a -> (a, b)
23:58:21 <int-e> vegai: it's probably quicker to understand than the equivalent 3 lines of code for an accumulating reverse. (if you really understand foldl, that is)
23:58:21 <nornagon> oh, okay then.
23:58:22 <lambdabot> a -> (a, b) :: forall a b. a -> (a, b)
23:58:43 <LoganCapaldo> Yes! bow to whim! ;)
23:58:51 <nornagon> :t (\x -> (x,undefined))
23:58:53 <lambdabot> forall a a1. a -> (a, a1)
23:58:58 <LoganCapaldo> s/whim/my whim/
23:59:38 <LoganCapaldo> @type (\x -> (x, undefined:undefined)) :: a -> (a, b)
23:59:40 <lambdabot>     Couldn't match the rigid variable `b' against `[a1]'
23:59:40 <lambdabot>       `b' is bound by the polymorphic type `forall a b. a -> (a, b)'
23:59:49 <LoganCapaldo> hehe
