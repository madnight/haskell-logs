00:00:46 <glguy> why don't you just tell the firewall to block the port
00:00:53 <glguy> you are doing it on freebsd , right?
00:01:07 <sorear> huh?
00:01:18 <glguy> to cause your netsplit
00:01:29 <sorear> debian unstable , no local firewall
00:01:34 <glguy> ew
00:01:54 <glguy> and people still use this "debian"?
00:02:07 <sorear> but connect was a noop too, so I couldn't cause joins starting from disconnected servers
00:11:04 <sorear> heh. It seems QSem isn't async-exception-safe.
00:11:16 <sorear> (looking at the source code)
00:11:34 <sorear> maybe that's why lamdbabot deadlocks on netjoins
00:11:53 <sorear> ^^^ my first ENTER accident in >1 week!
00:13:14 <sorear> @bto
00:13:15 <sorear-lambdabot> Maybe you meant: bf bug ft
00:13:25 <sorear> @list-all
00:13:25 <sorear-lambdabot> activity provides: activity
00:13:25 <sorear-lambdabot> babel provides: babel
00:13:25 <sorear-lambdabot> base has no visible commands
00:13:25 <sorear-lambdabot> bf provides: bf
00:13:25 <sorear-lambdabot> check provides: check
00:13:27 <sorear-lambdabot> compose provides: . compose
00:13:29 <sorear-lambdabot> dice provides: dice
00:13:31 <sorear-lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:13:33 <sorear-lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
00:13:35 <sorear-lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools
00:13:38 <sorear-lambdabot> elite provides: elite
00:13:40 <sorear-lambdabot> eval provides: run let undefine
00:13:43 <sorear-lambdabot> Plugin `system' failed with: IRCRaised thread killed
00:13:51 * sorear supposes this test should be done in msg
00:14:20 <sorear> @bot
00:14:21 <sorear-lambdabot> :)
00:14:36 <sorear> @bot
00:14:37 <sorear-lambdabot> :)
00:14:43 <sorear> @list-all
00:14:44 <sorear-lambdabot> activity provides: activity
00:14:44 <sorear-lambdabot> babel provides: babel
00:14:44 <sorear-lambdabot> base has no visible commands
00:14:44 <sorear-lambdabot> bf provides: bf
00:14:46 <sorear-lambdabot> check provides: check
00:14:48 <sorear-lambdabot> compose provides: . compose
00:14:50 <sorear-lambdabot> dice provides: dice
00:14:52 <sorear-lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
00:14:54 <sorear-lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
00:14:56 <sorear-lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools
00:14:58 <sorear-lambdabot> elite provides: elite
00:15:02 <sorear-lambdabot> Plugin `system' failed with: IRCRaised thread killed
00:15:09 <sorear> oh duh the reason it didn't work in private was I was using the wrong nick
00:17:16 <sorear> @Bot
00:17:19 <sorear> @botsnack
00:17:28 <sorear> sucess! I've killed it!
00:17:46 <sorear> @tell dons The netsplit bug has been found, and it's in base.
00:17:56 * sorear feels like an idiot 
00:19:20 <mgsloan> congrats.  Perhaps that many people leaving caused concurrency problems with multiple state changes?
00:20:31 <mgsloan> hmm, nevermind, probably unlikely
00:20:35 <sorear> mgsloan: no, it was a problem with joins... all the business caused timeouts, which are harmless, but...
00:20:42 <sorear> it tickled a bug in base
00:21:01 <sorear> the 'base' that is distributed with GHC
00:21:06 <mgsloan> ahh, yikes
00:21:40 <sorear> Control.Concurrent.QSem.waitQSem, despite the appearance of being a concurrency primitive, is *not* async-exception-safe.
00:21:45 <Cale> Is the old concurrency interface written in terms of STM yet?
00:21:55 <sorear> Cale: no.
00:22:06 <Cale> Probably not if it has problems like that :)
00:22:10 <sorear> MVars all the way down.
00:22:37 <mgsloan> mentalguy has a good post on concurrency methods - http://moonbase.rydia.net/
00:25:43 <Cale> I'm fairly convinced that STM is a good basic framework to build other abstractions on.
00:28:04 <mgsloan> yep.  He mentioned that that problem at the end is much easier with STM than the others.
00:28:26 * sorear goes to write an e-mail to dons ... I miss @tell
00:28:29 <mgsloan> Still, interesting to look at the solutions, and issues they solve
00:28:53 <sorear> it's all ruby to me :(
00:29:17 <sorear> (ruby as analogous to greek here)
00:29:23 <mgsloan> heh yeah :) He likes ruby, but he likes haskell too
00:29:52 <mgsloan> and C++ for that matter... Or, at least, uses it and is guru-like
00:29:53 <sorear> I don't know if I'd like ruby, but now, I don't know it
00:32:27 <Cale> I don't think you could properly implement STM as a library for Ruby.
00:32:53 <Cale> It would have to be at the compiler level.
00:33:03 <Cale> (er, interpreter :)
00:34:27 <mgsloan> yeah, looks like his fastthread lib has an 18kb C file :P
00:36:39 <Cale> Well, this would go deeper than that
00:36:52 <Cale> you can't allow anything with side effects to occur in an atomic block
00:37:51 <Cale> So it really does need to be a language feature, if the language doesn't already have control over things like that.
00:38:13 <mgsloan> I wouldn't be super surprised if it did
00:38:50 <velco> what should happen in std haskell if I index an array out of its bounds ?
00:39:10 <sorear> your program stops
00:40:41 <velco> so, I'll have to check array acceses like, for example,  arr i a = if inRange (bounds a) i then Right (a!i) else Left "foo" ?
00:40:58 <velco> (or with Either)
00:41:07 <velco> err, or with Maybe
00:41:09 <sorear> right.
00:41:19 <sorear> *in standard haskell*
00:41:47 <sorear> In GHC you can use Control.Exception.catch to trap out-of-bounds exceptions.
00:41:47 <Cale> I don't think the new array libraries do anything to offset this.
00:41:57 <Cale> Oh, well, yes, you can do that, at least.
00:42:07 <Cale> But for the IArray interface, that's a pain.
00:42:29 <velco> yeah, I find this easier than having potentially unevaluated error calls deep down some data structure ...
00:42:41 <Cale> That's true
00:43:08 <xpika> on my local machine, with Darcs, I did a rollback and it created an undo patch. how do i then apply that undo patch
00:43:13 <Cale> The easiest way to avoid that sort of problem is to try to use higher order functions on arrays as much as possible.
00:46:48 <Cale> xpika: it should have applied that patch to the local repository
00:47:24 <dibblego> ?where yaht
00:47:50 <Cale> It leaves the old patch in as well.
00:48:29 <Cale> (I don't know exactly how darcs works, but I sure hope it is able to perform the optimisation that P P^(-1) = id
00:48:35 <Cale> )
00:49:37 <Cale> However, the distinction becomes important if there's a patch in between.
00:51:51 <Cale> I find it interesting that we use similar notation for kinds now as were used for type variables before.
00:54:15 <Cale> Heh,  color ::= VERMILLION | PUCE | LAVENDER
00:54:43 <Cale> (from SPJ's book on implementing functional programming languages)
01:08:56 <Cale> Oh, this is interesting. Miranda allowed repeated variables in patterns.
01:10:05 <Cale> noDups [] = []; noDups [x] = [x]; noDups (x:x:xs) = noDups (x:xs); noDups (x:y:ys) = x : noDups (y:ys)
01:10:39 <Cale> It would test for equality in cases where a variable was repeated.
01:10:56 <Vq^> looks nice
01:11:41 <Cale> Miranda and early versions of Haskell and Gofer had some interesting features
01:11:58 <Vq^> until you rebind (==)
01:12:02 <sorear> how did miranda handle equality? ML-style eq-types?
01:12:15 <Cale> I'm not sure. Probably something like that
01:13:17 <Cale> Also some later versions of Miranda and early versions of Haskell had non-free types. You could define automatic transformations which would be applied to normalise datastructures.
01:13:33 <Cale> For example, in defining a sorted-list type.
01:13:51 <Cale> (which you could still pattern match against!)
01:16:10 <mgsloan> would that also allow stuff like guaranteed terminating lists?
01:16:26 <Cale> We already have those.
01:16:42 <mgsloan> bah :P
01:17:02 <Cale> Or rather, we still have those :)
01:17:29 <Cale> (Add strictness annotations)
01:22:23 <Cale> PHPlint makes me want to cry.
01:22:24 <mgsloan> well, then they either terminate or are _|_
01:22:29 <Cale> mgsloan: right
01:22:39 <Cale> You can never prevent nontermination altogether.
01:22:41 <mgsloan> well, that's no good ;P
01:22:45 <sorear> Epigram?
01:22:48 <mgsloan> I know, halting rule and such
01:23:02 <Cale> Okay, yeah, you can provide proofs of termination which the compiler checks :)
01:23:35 <sorear> I think we should (a) invent a better monad syntax (b) eliminate fix but not mfix.
01:24:05 <Cale> why?
01:24:06 <sorear> Epigram-a-likes adopt (b) but not (a), and few use them ..
01:24:30 <sorear> better range of static checking options ...
01:24:38 <Cale> I suppose if you really really care that programs all terminate.
01:25:02 <sorear> Once, I didn't care about segfaults.
01:25:33 <Cale> True, it's nice to know, but I'd want a reasonable level of inference there.
01:26:01 <sorear> agreed.
01:26:05 <Cale> I'm sure there are some programs for which the termination proof breaks down into evaluating the thing by hand.
01:27:07 <Cale> Also, there are lots of cases where I might have a proof of termination, but I don't want to be bothered telling the compiler about it.
01:27:27 <sorear> unsafeFix will be provided :)
01:27:42 <sorear> esp. for things like foldr, if they aren't builtin.
01:28:02 <Cale> For example, let's say I write a Newton's method root finding algorithm and then apply it for finding nth roots.
01:28:16 <Cale> I can't prove that it terminates in general. What's the type?
01:28:45 <sorear> you can't? even with knowledge of the function class?
01:29:07 <sorear> granted, I wouldn't want to codify that much of calculus in any proof system
01:29:17 <Cale> It doesn't terminate in general.
01:29:52 <sorear> not in general, but roots it does...
01:29:57 <sorear> s/for roots
01:30:06 <Cale> for nth roots, yes
01:30:10 <DracoCepheus> hi i am new to haskell
01:30:17 <sorear> good
01:30:27 <sorear> beats only having old people
01:30:31 <DracoCepheus> working thru yaht.pdf
01:30:31 <sorear> how can we help?
01:30:45 <DracoCepheus> how can i make this point free?
01:30:47 <DracoCepheus> func1 x = map (\y -> (*y) x)
01:30:55 <DracoCepheus> or can it not be done
01:30:56 <notsmack> @pl  func1 x = map (\y -> (*y) x)
01:31:08 <notsmack> where's lambdabot?!
01:31:14 <Cale> probably sleeping
01:31:21 <Cale> @pl  func1 x = map (\y -> (*y) x)
01:31:21 <sorear-lambdabot> func1 = map . (*)
01:31:22 <notsmack> @botsnack
01:31:22 <sorear-lambdabot> :)
01:31:50 <Cale> Well, that's your answer, anyway :)
01:31:57 <DracoCepheus> ok
01:31:59 <Cale> How might we think of that on our own?
01:32:59 <Cale> map is being applied to the function which takes a number y, and returns the product of y and x (that's a little awkwardly written)
01:33:24 <Cale> func1 x = map (\y -> x*y)
01:33:29 <Cale> that's clearer
01:33:52 <Cale> we can rewrite the lambda term to begin with
01:34:05 <Cale> func1 x = map (x*)
01:34:21 <Cale> or  func1 x = map ((*) x)  if you'd prefer
01:34:46 <DracoCepheus> i prefer prev
01:35:25 <DracoCepheus> i guess i forget that map is simply a function ... ;-)
01:35:44 <DracoCepheus> so the point free version is quite easy to read
01:36:03 <Cale> yeah
01:36:16 <Cale> func1 = map . (*)
01:36:33 <Cale> working from  func1 x = map ((*) x)
01:36:48 <Cale> because  (f (g x)) = (f . g) x
01:36:55 <Cale> and then you can delete the x from both sides
01:37:12 <Cale> (eta-reduce, to use the technical term)
01:37:48 <DracoCepheus> thanks for the help
01:37:56 <Cale> no problem :)
01:38:03 <Cale> Feel free to ask lots of questions
01:40:53 <Cale> sorear: on our last point, another cool thing you can do is take some complex polynomial, like product over k = 0 to n-1 of (x - e^(i pi k/n)), and make a plot, for various points in the complex plane, as to which root Newton's method ends up getting attracted to.
01:41:15 <sorear> Cale: I've already done that
01:41:26 <Cale> You end up with some nice fractals :)
01:41:51 <sorear> infact, I think I wound up reporting a bug in Simon Tatham's nr fractal generator :)
01:52:27 <lisppaste2> paolino pasted "parsing error" at http://paste.lisp.org/display/35098
01:53:32 <paolino> hi, I get this parsing error on second "where" , why ?
01:53:48 <Cale> It's at the same depth as adder is
01:53:56 <Cale> indent it by one more space
01:54:26 <paolino> mmh, what is the rule ?
01:54:51 <Cale> Basically, things which are inside other things should start on a later column
01:55:18 <Cale> This 'where' is intended as part of the declaration of 'adder'
01:55:27 <Cale> So it should be indented more.
01:56:01 <Cale> Similarly (where you got it right), 'inside' and 'first' are on the same level, as two lines of the where clause
01:56:26 <paolino> and then the rest I can put it wherever I want , keeping the level ?
01:56:41 <Cale> If you want things on the same level, line them up
01:56:52 <Cale> If you want something inside something else, indent it more
01:57:15 <paolino> but ... first where was ok ??!!
01:57:31 <Cale> right, it's indented by 2 relative to positions
01:57:35 <Cale> which it is a part of
01:57:51 <paolino> ah right , thanks
01:58:10 <Cale> The actual rule is pretty complicated, and actually allows to to get away with lining up things which are actually inside one another, but I wouldn't recommend it.
01:58:57 <Cale> Basically the intent is generally that it's used like this.
01:59:12 <Cale> One important point comes up in the indentation of if-then-else
01:59:52 <Cale> If you split it over more than one line, the right way to do it is to indent the 'then' and 'else' more than the 'if' and line them up.
02:00:16 <Cale> if foo
02:00:18 <Cale>    then bar
02:00:21 <Cale>    else quux
02:00:39 <Cale> Or
02:00:43 <Cale> if foo then bar
02:00:49 <Cale>        else quux
02:01:08 <Cale> (provided that foo is short enough)
02:01:59 <paolino> I can understand two dimensions syntax has some drawbacks
02:02:16 <Cale> It's nice to read
02:02:28 <Cale> It's a small amount more work to write
02:03:25 <Cale> But if you look at it another way, you usually indent things a certain way anyway, this just takes away a little freedom in that choice in exchange for not having to type braces and semicolons.
02:03:40 <paolino> sure, I come from python, in haskell there is more freedom, but sometimes I err
02:04:19 <Cale> Yeah, I think Haskell's rule as to determining how far things are indented is slightly different
02:04:42 <paolino> also , in pyhon I was making mistakes when changing old code, here I go nicer
02:04:49 <Cale> The column for a block is set by the first non-whitespace character after the keyword introducing that block.
02:05:12 <kowey> http://en.wikibooks.org/wiki/Haskell/Indentation <-- could this be useful?
02:06:47 <Cale> More is allowed by the indentation rule than I think most people would be happy with. (That is, it allows things which people would consider bad formatting)
02:08:14 <Cale> hehe "Naturally enough, your Haskell compiler is unimpressed, because it thinks that you never finished writing your if expression, before charging off to write some other new statement, oh ye of little attention span."
02:09:21 <paolino> looks like the lining you showed me for if is necessary only inside the do block
02:10:03 <paolino> anyway, it's the way I use everywhere
02:10:04 <sorear> correct
02:10:39 <Cale> well, it's only *necessary* in the do-block, but it's considered bad style not to follow it everywhere
02:11:36 <Cale> Lining up nested things where you can get away with it doesn't do any service to someone reading the code.
02:12:30 <Cale> Well, there are certain expressions where it might be okay, for example, long chains of >>> in an arrow expression, or a large composition of functions with each line starting with .
02:13:12 <paolino> mmh it's my code  it is silly, I track the number of times an elem is in a positions in the same list :/
02:13:37 <paolino> I should take some coffee :P
02:13:55 <paolino> * one position
02:14:07 <Cale> I sort of wondered what that was doing :)
02:14:27 <jethr0> paolino: how can it be in the same position several times?
02:15:00 <Cale> jethr0: I think that's the point
02:15:36 <paolino> probably I was thinking in 4 dimensions, or I wasn't thinking at all
02:16:45 <jethr0> hehe
02:17:58 <jethr0> *grr* when i start oo present my cpu usage goes WAY up, followed by my deafening fan and stays up :(
02:25:45 <paolino> ever tried sqeak ?
02:26:02 <jethr0> yes
02:26:08 <kowey> i played with scratch last night... what fun! (and subtle typing by shapes)
02:26:54 <paolino> very cpu and fan intensive also
02:27:11 <kowey> if you have a little brother or sister with curiosity about programming... i'd be interested to see how Scratch works for them
02:27:36 <jethr0> is scratch related to squeak?
02:28:26 <kowey> i think Scratch is implemented in Squeak
02:28:29 <paolino> I have three children , but I don't know when/how give them access to a computer
02:28:34 <jethr0> k
02:29:08 <paolino> but you gave me the "how" probably
02:29:10 <Heffalump> anyone familiar with visual haskell?
02:29:15 * jethr0 'd have problems with giving access to the internet
02:30:09 <Heffalump> at what age?
02:30:10 <paolino> jethr0: I will teach them using elinks for browsing
02:30:26 <paolino> 2-4-6
02:30:34 <paolino> ehm 3-5-7
02:30:42 <paolino> time passes
02:30:47 <jethr0> > map (+1) [2,4,6]
02:31:06 <dcnstrct> I'm a noob who wants to look at some well written  Haskell code with decent documentation.  What do you people suggest I read ?
02:31:27 <paolino> > map (+1) [2,4,6,36]
02:31:34 <jethr0> @wiki Category:Code
02:31:35 <sorear-lambdabot> http://www.haskell.org/haskellwiki/Category:Code
02:31:53 <jethr0> although many of those aren't documented at all :(
02:32:38 <paolino> haskellers document only things they are not able to do :P
02:33:40 <dcnstrct> I want to look at some code that is used in production somewhere, not quiz answer submissions.  Is darcs a mess ? I guess I could start there
02:35:33 * sorear mutters something about lambdabot
02:35:51 <kowey> i've been told that the darcs code is "not that clean"... but it is very real world
02:36:06 <kowey> plus you get to see the idea of using the user's manual as literate code comments
02:36:42 <kowey> otherwise, what about pugs, or some of the haskell web stuff, like hope?
02:37:17 <dcnstrct> web stuff sounds good, I learned Ruby by studying rails, does Haskell have a web framework that is a clear winner ?
02:37:21 <dcnstrct> is that it hope ?
02:37:25 <dcnstrct> I'll check it out
02:37:34 <jethr0> dcnstrct: production code tends to be not so easy to read for beginners (due to many advanced concepts used), but haskell code also tends to be cleaner/shorter than in many other languages
02:37:47 <jethr0> it can be cryptic though :(
02:38:10 <jethr0> @where hope
02:38:11 <sorear-lambdabot> http://hope.bringert.net/
02:38:12 <dcnstrct> jethr0, well I liked I'm not a complete noob, I've been buying up and reading all the haskell books I can find for about 6 months now, but I'm a noob at writing haskell.
02:38:15 <kowey> this might help too: http://www.haskell.org/haskellwiki/How_to_read_Haskell
02:38:16 <sorear-lambdabot> Title: How to read Haskell - HaskellWiki
02:38:18 <dcnstrct> s/liked/lied
02:38:43 <dcnstrct> I've been reading lots of small example code, I want to look at a big app now
02:38:48 <dcnstrct> hope sounds cool
02:39:02 <jethr0> dcnstrct: k, that's different then
02:45:54 <bakert> Is there a haskell equivalent of getopt?
02:46:08 <sorear> ?docs System.Console.GetOpt
02:46:09 <sorear-lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Console-GetOpt.html
02:46:10 <Heffalump> yes, called roughly that
02:46:30 <bakert> Fab.  Thanks.
02:52:14 <bakert> How do I inline a monad "unwrapping"?  I think it's something to do with =<< but I would really appreciate it if you help me through a simple case.
02:52:24 <bakert> i am getting the program name and putting it in a string
02:52:28 <bakert> like this:
02:52:32 <bakert> name <- getProgName
02:52:47 <bakert> print ("Usage: " ++ name ++ " [filename]")
02:52:53 <bakert> Can I do that in one line?
02:52:58 <dmhouse> Use fmap.
02:53:13 <dmhouse> fmap (\nm -> print $ "Usage: " ++ nm ++ " [filename]") getProgName
02:53:15 <dibblego> is Database.HDBC the de facto for accessing a RDBMS?
02:53:18 <bakert> is that like a lift type operation?
02:53:23 <dmhouse> Although the explicit do-notation is probably clearer in this instance.
02:53:27 <jethr0> getProgName >>= \name -> print ...
02:53:30 <bakert> dibblego, i have used it and found it good.
02:53:40 <dmhouse> Oh, wait, print isn't pure, my bad.
02:53:44 <dmhouse> Do what jethr0 said.
02:53:46 <Heffalump> dibblego: I use HSQL
02:54:42 <jethr0> @. pl undo do {name <- getProgName; print ("Usage: " ++ name ++ " [filename]")}
02:54:43 <sorear-lambdabot> print . ("Usage: " ++) . (++ " [filename]") =<< getProgName
02:54:45 <bakert> so what is actually happening in jethr0's version?  we're saying run getProgName and treat the result as being in "name" for the duration of this inline function?
02:54:55 <jethr0> :)
02:55:08 <bakert> wow that's crazy pointfree thingy is it?
02:55:28 <dmhouse> bakert: something like that. m >>= f will 'extract' the value from the monadically wrapped value m, then run it through the function f, which should have a monadic result.
02:55:29 <jethr0> yes, but i don't like multiple (.)s
02:55:33 <dmhouse> ?type (>>=)
02:55:36 <sorear-lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
02:56:14 <bakert> i see.  so my "next" function must return something wrapped up in the original monad i unwrapped from with >>=
02:56:14 <bakert> ?
02:56:19 <sorear> yes
02:56:19 <jethr0> ha, in this case it's not even multiple (.)s, but just concatenation
02:56:40 <dmhouse> bakert: So getProgName >>= \name -> print ... will run the getProgName action, extract its value from the IO wrapper (just like doing name <- getProgName), then run it through the \name -> print ... function.
02:57:04 <jethr0> and "print" already returns a value inside the IO monad, albeit IO ()
02:57:10 <jethr0> ?type print
02:57:12 <sorear-lambdabot> forall a. (Show a) => a -> IO ()
02:57:26 <bakert> great.  so this eliminates the need for me to write "do" at the beginning of the function, too, because the ordering is implicit in what i've written?  or i still need "do"?
02:57:36 <jethr0> nope
02:57:41 <jethr0> don't need it
02:57:48 <paolino> mmh, how can it be that
02:57:49 <paolino> f x = g x compiles and
02:57:49 <paolino> f = g gives types problem ?
02:57:51 <dmhouse> You don't need 'do' if what follows is a single line.
02:57:59 <dmhouse> paolino: using existentials anywhere?
02:58:03 <sorear> paolino: monomorphism restriction?
02:58:07 <jethr0> monomorphism restriction?
02:58:14 <bakert> ok thanks guys that's very helpful.  i may understand this stuff yet!
02:58:16 <paolino> monothing yes
02:58:31 <paolino> no, dmhouse
02:58:49 <dmhouse> paolino: if you write f = g, the MR says that f should be assigned a monomorphic type, because it doesn't 'look like' a function (it has no arguments on the LHS).
02:58:57 <dmhouse> You can get rid of it by writing an explicit type signature for f.
02:59:38 <paolino> uhm , does it apply only to one arg functions ?
03:00:00 <dmhouse> It applies to when you have an expression like 'f = g' where it doesn't look like f takes any arguments.
03:00:05 <sorear> there's any other kind? :)
03:00:07 <dmhouse> Just give it a type signature :)
03:00:40 <paolino> f x y = g x y sectioned to
03:00:41 <paolino> f x = g x
03:01:03 <dmhouse> The latter should be fine, MR shouldn't apply there, I don't think.
03:01:15 <sorear> @quit *Yawn*
03:01:20 <paolino> that was my question
03:03:57 <paolino> what f = g can it be when not a function  ?
03:04:19 <quazimodo> @src divMod
03:04:34 <quazimodo> ??
03:04:40 <quazimodo> lambdabot ignoring?
03:04:41 <paolino> @bot
03:04:50 <quazimodo> @helloooo?
03:04:59 <dmhouse> ?botsnack
03:05:15 <quazimodo> methinks there needs to be a bot-reset-button
03:05:33 <paolino> on dons machine ?
03:05:34 <dmhouse> lambdabot's been breaking quite a lot recently.
03:05:45 <quazimodo> no, on the channel
03:05:48 <quazimodo> just a public button
03:06:05 <quazimodo> it could be placed here ---------------------------------> |  Button  |
03:06:48 <paolino> probably lambdabot is just not reding the messages
03:06:58 <quazimodo> i still think the button is a good idea...
03:07:19 * jethr0 presses the newly appeared button
03:08:43 <paolino> mmhh a controllambdabot bot is needed then, which pkill -hup the friend
03:08:44 <gour> new Trac will use pygments (http://pygments.pocoo.org/) for syntax high. but it looks there is no support for haskell. anyone know if there is some?
03:14:28 * quazimodo Smashes jethr0 in the head, DONT PRESS MY BUTTON!
03:15:20 * jethr0 presses the button again without quazimodo seing.
03:16:01 * quazimodo pokes jethr0 in the eye, without him seeing
03:16:44 * jethr0 is blind and can't see anything *tumbles around the channel*
03:16:59 <quazimodo> only 1 eye you ass
03:17:07 <quazimodo> you can still see some stuff
03:19:43 <jethr0> *ah* it burns...
03:47:16 <xic> how many idle light weight threads can i realistically have?
03:49:06 <bakert> The Jehovah's Witnesses did not want to know about my haskell program.
03:49:09 <bakert> They have gone.
03:49:13 <ohmega> :)
03:50:21 <jethr0> xic: in the shootout version they had 500 i think (http://haskell.org/haskellwiki/Shootout/Cheap_concurrency)
03:50:40 <xic> hm... that's it?
03:50:43 <jethr0> so that should be a lower bound
03:50:56 <xic> well i mean mostly idle threads
03:50:59 <jethr0> in the paper on STM i seem to remember them speaking of a lot more
03:51:39 <jethr0> @index everything
03:52:32 <paolin1> how to sign
03:52:33 <paolin1> swap a i j = a // [(i,a!i),(j,a!j)]
03:52:33 <paolin1> for generic a = IArray Int b?
03:54:11 <jethr0> paolin1: huh?
03:54:51 <bakert> he gone.
03:55:41 <paolin1> swap :: (Array Int a) -> Int -> Int -> (Array Int a)
03:55:56 <jethr0> ah
03:56:09 <paolin1> but then it fails on DiffArrays
03:56:23 <ohmega> that won't swap your elements though
03:56:44 <paolin1> a typo sorry
03:57:25 <paolin1> I should call it testcompilersmartness :P
03:59:03 <paolin1> swap :: (IArray b) => (b Int a) -> Int -> Int -> (b Int a)
03:59:04 <paolin1> swap a i j = a // [(j,a!i),(i,a!j)]
03:59:04 <paolin1> ?
03:59:24 <fasta> paolin1: If you don't give a type to it should inference the most general type. (this isn't completely true, but I never had a problem with it)
04:00:19 <ohmega> maybe it works better if you import IArray hm
04:00:52 <paolin1> this is the import in the module
04:00:53 <paolin1> import Data.Array.IArray
04:00:53 <paolin1> import Data.List
04:00:53 <paolin1> import Data.Array.Diff
04:00:57 <paolin1> :D
04:01:13 <fasta> paolin1: you don't need to import IArray
04:01:23 <fasta> paolin1: it's already exported by Data.Array.Diff
04:01:28 <paolin1> ok
04:02:03 <paolin1> does it export also Data.Array ?
04:03:05 <fasta> paolin1: You can see for yourself in the documentation, but the answer is no, IIRC.
04:05:08 <paolin1> ok
04:05:24 <fasta> Can I profile a program in ghci?
04:06:39 <jethr0> which flag in ghc do i need to derive (Data,Typeable)? (scrap your boilerplate)
04:07:20 <jethr0> "... deriving (Data)" => "Not in scope: type constructor or class `Data'"
04:08:51 <jethr0> ah, maybe glasgow-exts...
04:10:37 <jethr0> or not :(
04:22:44 <ski> if 'fst (x,y) = x' and 'snd (x,y) = y' are 'beta'-rules, and '(fst p,snd p) = p' is an 'eta'-rule, then what would '(fst p = fst q) /\ (snd p = snd q) => (p = q)' be called ?
04:25:29 <paolin1> eta-beta ?
04:27:15 <Baughn> Delta?
04:28:33 <xic> is there a gzip compress function?
04:28:34 <ski> i think 'delta' is usually used for more ad-hoc rules, like for primitives like addition
04:29:22 <Baughn> I just picked it because it's between beta and eta. Actually, I have no idea what these classifications are about - anyone got a link to somewhere that does?
04:30:30 <velco> http://en.wikipedia.org/wiki/Lambda_calculus
04:31:01 <Baughn> xic: There's a nice bytestring-zlib binding linked from http://www.cse.unsw.edu.au/~dons/fps.html
04:31:12 * xic looks
04:32:40 <paolin1> ops, ski I thought it was a joke, sorry
04:33:20 <xic> Baughn: nice, thanks!
04:35:31 <Baughn> velco: Math! It burns!
04:36:16 <ski> hm .. it seems in some sense the latter rule is a variant on 'eta'
04:37:00 <ski> c.f. with the corresponding rule for implication, '(forall x. f x = g x) => f = g'
04:38:51 <ski> (.. which is usually called 'extensionality' .. and that WP page mentions that 'eta' (for implication) is equivalent with 'extensionality')
04:39:56 * jethr0 is super-amazed by "scrap your boilerplate"
04:40:06 <jethr0> i had no idea all of this was already in ghc.....
04:43:41 <xpika> is there any way to write out a list comprehension in full?
04:44:00 <jethr0> "in full"?
04:44:00 <mahogny> like?
04:45:04 <xpika> [ [a+b] | a<-[1,2] , b<-[1,2] ]
04:45:09 <xpika> > [ [a+b] | a<-[1,2] , b<-[1,2] ]
04:45:43 <Botje> > do { a <- [1,2]; b <- [1,2]; return [a+b] }
04:45:57 <Baughn> > 1 + 2
04:45:59 <Botje> \bot went tits up again :(
04:46:34 <jethr0> xpika: what do you mean "in full" (without using the "absent" lambdabot)
04:46:44 <xpika> that works
04:47:00 <xpika> botje's works
04:47:21 <jethr0> k
04:47:44 <Baughn> Mm. List monad, I suppose?
04:48:01 <Botje> yes.
04:48:54 <Botje> Baughn: also, earlier versions of haskell allowed generic monad comprehensions
04:48:59 <Botje> not just list comprehensions
04:49:03 <Baughn> But how can it tell which monad to use?
04:49:06 <Botje> but they were too hard for newbies
04:49:08 <Botje> types.
04:49:49 <jethr0> @. type undo do { a <- [1,2]; b <- [1,2]; return [a+b] }
04:50:11 <Baughn> ..figures. Return-type polymorphism is.. interesting , I guess.
04:50:23 * jethr0 thinks lambdabot should ping himself constantly and "reboot" if not responsive...
04:50:29 <ski> Baughn : just as with overloaded anything, in many cases how you use it will determine which overloaded variant you want .. otherwise you either get generic overloaded operations .. or say explicitely with type signatures/asriptions which variant you want
04:51:21 <ski> [1,2] >>= \a -> [1,2] >>= \b -> return [a+b]
04:51:36 <ski> (s/asriptions/ascriptions/)
04:52:35 <paolin1> jethr0: that's self referencing the bugs
04:53:35 <jethr0> paolin1: partially true. but one of the problems is that lambdabot hangs up on some splits (just as some clients do) and unless someone fixes that, adding some kind of timeout seems like a pragmatic solution
04:53:35 <fasta> "The program hp2ps converts a heap profile as produced by the -h<break-down> runtime option into a PostScript graph of the heap profile. "
04:53:46 <jethr0> although i agree that it's an inherently ugly approach
04:53:48 <fasta> Where can I find the -h<break-down> option?
04:53:55 <fasta> I can't see it anywhere in the documentation.
04:55:15 <astrolabe> fasta: eg  -hc
04:55:40 <fasta> astrolabe: What does the meta variable <break-down> mean here?
04:55:44 <paolin1> jethr0:  then rebooting every 10 minutes from OS should be fine
04:55:55 <astrolabe> fasta: in this case, it is 'c'
04:56:02 <fasta> astrolabe: yes, I got that part
04:56:18 <fasta> astrolabe: what are the other values of
04:56:23 <jethr0> paolin1: *ach*. so what's your proposition on fixing this?
04:56:25 <fasta> astrolabe: <break-down>?
04:57:09 <astrolabe> the letter (eg c) determines whether the heap usage is broken down by closure, or history, or whatever.
04:57:28 <xpika> is anyone here using mac?
04:57:49 <fasta> astrolabe: ah, it are options to hp2ps?
04:58:06 <astrolabe> fasta: no
04:58:38 <fasta> astrolabe:  I haven't found the -h option in the documentation, so I am guessing here. It would be much more useful to me if you could point me at it.
04:59:18 <astrolabe> fasta, section 5.4.1 here http://www.haskell.org/ghc/docs/latest/html/users_guide/prof-heap.html
04:59:56 <astrolabe> (sorry, I wasn't being awkward, it was taking me some time to find the right place)
04:59:59 <jethr0> xpika: yes
05:00:16 <fasta> astrolabe: hmm, I guess I was just looking in the wrong place.
05:00:31 <fasta> astrolabe: a few hyperlinks wouldn't hurt.
05:00:35 <fasta> astrolabe: thanks
05:03:27 <fasta> astrolabe: This should be fine then? ./Main +RTS -p -hc -RTS
05:04:24 <astrolabe> um, moment
05:04:47 <fasta> (It doesn't work, so it probably isn't.)
05:04:49 <astrolabe> remove the -p I think
05:04:51 <paolin1> jethr0:  A parallel process bot is the best approach I can think of. A bot testing the unresponsivity of lambdabot looking at the channel log, rebooting lambda  when there are too many (one ?) unanswered request in a time span. Don't know if killing ghci processess would unhang it
05:05:54 <astrolabe> fasta: also, make sure you have compiled with -prof -auto-all or something similar
05:06:14 <fasta> astrolabe: it does work
05:06:16 <jethr0> paolin1: hm
05:06:28 <astrolabe> fasta: hooray!
05:06:50 <astrolabe> fasta: space leak?
05:06:52 <fasta> astrolabe: unfortunately, it's not producing anything
05:07:04 <astrolabe> fasta: what works?
05:07:23 <fasta> astrolabe: I have no clue of what's going on in my program. It should terminate within a second :(
05:07:38 <fasta> astrolabe: it produces a file called Main.hp
05:07:45 <fasta> astrolabe: it's empty and stays empty
05:07:45 <astrolabe> fasta: ah
05:07:56 <paolin1> jethr0:  servers without OS interaction are not reliable nowadays. (Leaving out Erlang maybe)
05:08:02 <astrolabe> fasta: is it a complicated program?
05:08:24 <fasta> astrolabe: I don't consider it complex, but apparently it is.
05:08:34 <astrolabe> fasta: how long is it?
05:08:43 <jethr0> hm, lambdabot can/could be controlled on the console as well as from irc
05:08:58 <fasta> astrolabe: it has lots of dependencies.
05:09:06 <fasta> astrolabe: on non-public code.
05:09:07 <xpika> how much memory does osx use?
05:09:42 <astrolabe> fasta: how long is it without the dependencies?
05:09:53 <fasta> astrolabe: 7 lines :)
05:10:01 <astrolabe> @paste
05:10:24 <astrolabe> ah: who will rid me of this turbulent bot ?!
05:10:32 <paolin1> paste.lisp.org/new/haskell
05:10:48 <astrolabe> paolin1: thanks
05:11:03 <astrolabe> fasta: could you paste the code there?
05:11:19 <fasta> astrolabe: yes, but I don't think it will help
05:11:31 <astrolabe> @bot
05:11:32 <fasta> astrolabe: I just need to know what the program is doing.
05:11:43 <jethr0> xpika: doing what?
05:11:47 <astrolabe> fasta: Have you used debug.trace?
05:11:50 <lisppaste2> fasta pasted "some code" at http://paste.lisp.org/display/35119
05:12:20 <fasta> astrolabe: I did in other programs, but now, I have little idea where to look.
05:12:29 <jethr0> xpika: right now i'm using 850mb while mainly using mozilla.
05:13:05 <astrolabe> fasta: well, you could put a trace on each of your '=' in main
05:14:08 <fasta> astrolabe: I prefer a real-time heap profile.
05:14:53 <astrolabe> fasta: good luck then
05:15:10 <bakert> is there a "split" function i can use on strings in the standard libraries?
05:15:25 <paolin1> splitAt
05:15:42 <bakert> that wants an int though, doesn't it?  i want to supply a Char to split on
05:15:51 <bakert> if you see what i mean
05:16:05 <jethr0> bakert: it's not in the std libs. it will be, in the meanwhile look at missingH
05:16:08 <jethr0> @where missingH
05:16:17 <jethr0> *damn lambdabot*
05:16:20 <bakert> split 'x' "helxlox" --> ["hel", "lo"]
05:16:33 <astrolabe> bakert: break?
05:16:36 <paolin1> splitAt.index ?
05:18:24 <jethr0> break and span do something like that, but split only once instead of at every occurrence
05:18:36 <bakert> astrolabe, splitAt is kind of close.
05:18:52 <bakert> astrolabe, sorry break is kind of close.  splitAt is too but that isn't what you suggested!
05:19:04 <astrolabe> bakert: :)
05:19:08 <bakert> paolin1, that only splits once though right?
05:19:16 <bakert> jethr0, having a look at missingH now
05:19:35 <bakert> do you know wher ein there it might be?
05:19:51 <paolin1> splitAt (index c) is inefficient , you can reimplement it with a foldM in Cont or from scratch
05:19:51 <jethr0> sa c = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==' '))
05:19:57 <jethr0> sa c = takeWhile (not . null) . unfoldr (Just . (second $ drop 1) . break (==c))
05:20:52 <bakert> woah!  it's that unfoldr thing again -- going to have to read up on that one.
05:21:04 <jethr0> *hmm* readable haskell code...
05:21:17 <paolin1> never so an unfoldr !
05:21:28 <paolin1> saw
05:21:58 <jethr0> it should be in the std, IMO. funnily Data.ByteString has such a split function
05:22:07 <Botje> bakert: unfoldr (Just . splitAt 4) [1..]
05:22:15 <Botje> ponder that code for a while :)
05:22:34 <bakert> :( my brain hurts ... but that's a good thing :)
05:22:55 <Botje> that means you're using it ;)
05:23:15 <fasta> astrolabe: about that space leak.... I am almost sure I have one, but now atleast I get a profile.
05:23:31 <fasta> astrolabe: Unfortunately, my computer feels like a 286 now.
05:24:07 <astrolabe> fasta: I find them very difficult to track down (I'm not very experienced)
05:24:35 <astrolabe> But the first thing I do is to print off all the top level heap profiles.
05:27:39 <bakert> hmm ... that split doesn't seem to like multiple instances of the delimiter in a row ... drops the rest of the list if it sees two in a row ... if i understood it i'd debug it!  maybe i will write a naive recursive one ...
05:28:29 <jethr0> bakert: oh ja, i see why it does that :(
05:28:49 <bakert> you're the only one out of us two!
05:28:51 <jethr0> stupid code
05:29:10 <bakert> i am writing one with an accumulator.  is that just dumb?
05:29:25 <jethr0> if there are two delimters in a row, it will result in an empty return string which is then seen by "takeWhile (not . null)" which drops anything that follows
05:29:29 <jethr0> no
05:29:34 <fasta> astrolabe: I see two cost centres, but they both have the same color?
05:30:15 <jethr0> although you could accumulate outside of the function "f xs = ["string"] ++ f rest"
05:30:36 <jethr0> which is not tail recursive as yours probably is
05:31:18 <bakert> yes mine is.. i think
05:31:29 <bakert> but i seem to have developed a nasty habit:
05:31:35 <bakert>     | otherwise = scenes xs ((init acc) ++ [last acc ++ [x]])
05:31:56 <bakert> is there a nicer way of saying "all the sublists except the last one plus the last one with an element added"
05:31:58 <bakert> ?
05:32:16 <bakert> i now have two routines that do that (scenes and split)
05:32:28 <jethr0> tail (inits xs) ++ [x] ?
05:32:30 <bakert> actually i think scenes is a special case of split
05:32:41 <jethr0> if only lambdabot were here :(
05:32:49 <astrolabe> fasta: That's odd.
05:32:51 <paolin1> :'(
05:33:09 <fasta> astrolabe: uhm, I think I know the problem.
05:33:14 <jethr0> forget my previous code
05:33:18 <fasta> astrolabe: I had an expression [1..]
05:33:27 <fasta> astrolabe: I assumed that it would be partially consumed
05:33:33 <fasta> astrolabe: I think I was wrong.
05:33:37 <fasta> astrolabe: Oops :)
05:33:44 <astrolabe> fasta :)
05:33:46 <bakert> jethr0, hell i don't know what i'm worrying about ... i better fix the bits that don't work first!
05:33:54 <fasta> astrolabe: I need to verify it though
05:33:56 <jethr0> hehe
05:37:20 <fasta> astrolabe: ok, the profile changed, but still it's horribly wrong.
05:37:45 <bakert> is [1..] the infinite list of integers?
05:38:01 <bakert> ignore me .. yes!
05:39:17 <spiffy> hello
05:41:55 <astrolabe> hello spiffy
05:42:03 <fasta> @type [1..]
05:42:11 <fasta> ?type [1..]
05:42:20 <bakert> lambdabot - he dead.
05:42:25 <fasta> yes, I forgot.
05:42:39 <bakert> easily done
05:42:52 <manveru> Prelude> :t [1..]
05:42:54 <manveru> [1..] :: (Num t, Enum t) => [t]
05:43:08 <spiffy> I was wondering if theres anyone here who uses eclipseFP on windows
05:45:39 <fasta> spiffy: why would eclipseFP work differently on Windows then on e.g. Linux?
05:46:10 <spiffy> fasta: Havent run it on linux. So i dont know if it does.
05:46:24 <fasta> spiffy: I did.
05:46:54 <fasta> spiffy: I can recommend you _not_ to spend any minute on it unless you are going to develop it.
05:47:01 <spiffy> really
05:47:42 <fasta> I looked a few months ago, or so, and I can't imagine it to be vastly better now.
05:48:25 <spiffy> Well, all id really need it to do is launch ghci and do nice syntax highlighting
05:48:45 <spiffy> actually thats all I need any haskell IDE to do.
05:50:19 <fasta> spiffy: then I can recommend Emacs (it's what I use). Vim is more responsive, but I never used it for any real Haskell program.
05:51:13 <spiffy> hmmm ive only really used emacs for emacs + slime...does it take much to setup for haskell?
05:51:36 <fasta> spiffy: I would say no
05:52:36 <xpika> @src unfold
05:53:22 <Saizan> just installa haskell-mode
05:56:15 <spiffy> whats the general process for installing haskell-mode
05:56:43 <spiffy> o wait
05:56:47 <spiffy> it has an install page
05:56:49 <spiffy> ignore me
06:03:31 <jethr0> is () == _|_ in haskell (in regards to type extent)?
06:05:07 <astrolabe> I don't think so
06:05:17 <astrolabe> I don't know what 'type extent' means
06:05:23 <velco> IIRC, the members of the () type are () and _|_
06:07:04 <jethr0> forget it. i should sleep more. i meant undefined
06:08:45 * jethr0 's mind is boggled that one can generate terms in haskell itself using "scrap your boilerplate"
06:28:31 <bakert> Is it possible to do ungreedy regexes with Text.Regex or do I need to install some perl-compatible regex lib?
06:31:08 <bakert> Hmm .. no ungreedy in posix.  Does anyone know of a perl compatible regex library for Haskell?
06:35:35 <Saizan> ?where regex-pcre
06:36:13 <Saizan> http://darcs.haskell.org/packages/regex-pcre/
06:36:32 <bakert> thanks Saizan
06:36:37 <Saizan> np
06:42:18 <bakert> is there a version of last that takes an int for how many you want off the end?
06:42:34 <bakert> take and reverse?
06:46:00 <mahogny> bakert, never seen any other combo for it
06:46:22 <bakert> lastN n x = reverse (take n (reverse x)) -- ???
06:46:30 <mahogny> works
06:46:36 <bakert> fair enough!
06:46:47 <bakert> i always expect there to be a better answer than what i know!
06:46:53 <bakert> (still very new at haskell)
06:47:00 <emk> Hmm. What's a good place to start learning about catamorphisms?
06:47:13 <bakert> see -- that's the kind of question that lets me know how little i know!
06:47:22 <emk> I'm just poking at the banana paper right now.
06:48:44 <emk> bakert: I'm trying to understand the paper "Comprehending Queries" (which apparently inspired Microsoft's new query framework), but the math is still a bit tough for me.
06:49:11 <emk> So I'm looking for some concrete examples in other papers, in hopes of being less confused. :-)
06:49:45 <bakert> And good luck to you.  I should be writing my masters paper but instead I'm writing a program to produce index cards of my fiancee's screenplays!
06:50:23 <bakert> (so she can shuffle around the structure of the scenes.)
06:50:38 <Jaak> revtake n = fst . foldr f ([], n) where f x ~(xs, m) = if m == 0 then (xs, m) else (x : xs, m `seq` m - 1) -- could work too (not tested)
06:50:49 <bakert> What is microsoft's new query framework, then, or haven't you figured that out yet emk?
06:50:51 <Jaak> prolyl slower :P
06:51:19 <bakert> I think I am going to try and learn a Haskell operator per day.
06:51:23 <emk> bakert: http://msdn.microsoft.com/data/ref/linq/
06:51:24 <bakert> Today I am going to do ~
06:51:38 <bakert> As it has turned up a few times and I have no idea what it does.
06:52:14 <bakert> hmm ... it's not a function?
06:52:19 <emk> bakert: LINQ basically a port of some Haskell ideas to C# and VB. It's a database query system based on monads.
06:52:28 <bakert> ah
06:52:48 <bakert> interesting.  i hope never to return to the world of C#
06:52:53 <emk> bakert: Frankly, I'm not much interested in Microsoft's version, but the underlying monadic framework sounds promising.
06:52:54 <bakert> with or without monads!
06:52:54 <Jaak> http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
06:53:16 <bakert> thanks Jaak just what i need
06:54:00 <bakert>  ~ is for performance reasons then?
06:54:24 <emk> bakert: But to understand the Haskell version, I'm going to need to improve my category theory a bit... :-/
06:55:19 <bakert> emk, i need to work out what category theory IS!  i love that haskell is throwing so many new things at me ... so different to learning another java/c#/ruby/perl/python/etc. i just hope i can cope
06:55:46 <bakert> even lisp and erlang were nothing like this.
06:56:08 <Jaak> not really
06:56:16 <bakert> oh
06:56:24 <emk> bakert: I'm taking Haskell one small bite at a time, and writing lots of programs as I go. :-)
06:56:25 <Jaak> let say you have something like id' = foldr f ([], ()) where f x (xs, _) = (x : xs, ())
06:56:43 <Jaak> it wont work on infinite lists
06:56:55 <bakert> oh ok
06:57:09 <bakert> so it is to warn the compiler not to attempt the impossible. ??
06:57:11 <Jaak> id' = foldr f ([], ()) where f x ~(xs, _) = (x : xs, ()) -- that does
06:57:37 <Jaak> no, it's to make stuff lazy :P
06:57:41 <bakert> OK!
06:57:50 <bakert> I think i'll read that page again later in a quiet room!
06:58:42 <bakert> for now my index cards program nnnnneeearly works.  i must finish it and get back to "intelligent betting".
06:59:38 <emk> For some reason, Haskell really helps me to "think in math."
07:00:17 <mahogny> a friend of mine found induction proofs really easy to learn by refering back to haskell :)
07:05:16 <bakert> i need to wrap a list of string in an html table.  two columns.  can i do it with some kind of map?
07:06:02 <bakert> actually ignore me it's not that simple.
07:08:14 <emk> mahogny: For me, it seems to work in general. Any kind of math is easier when my brain is in Haskell mode.
07:09:07 <emk> Since math is both valuable and difficult, this gives me a reason to love Haskell.
07:18:27 <emk> Hey, map is both a catamorphism and an anamorphism. Cute.
07:48:31 * syntaxfree wanders in whistling
07:53:02 <fasta> Is forkProcess non-blocking?
07:57:38 <lisppaste2> velco pasted "Why the error is caught only once ?" at http://paste.lisp.org/display/35134
07:58:27 <xic> ok, i've played around with the Reader monad. now how can i combine it with IO?
07:58:49 <allbery_b> ReaderT over IO?
08:00:00 <xic> how do i do that?
08:04:57 <allbery_b> @go monad transformers step by step
08:05:16 <allbery_b> @bot
08:05:23 <allbery_b> wakey wakey...
08:05:26 <allbery_b> feh
08:06:03 <astrolabe> We need lambdabot to be more robust
08:06:39 <Stinger> !bot
08:07:23 <astrolabe> xic: You could read this http://www.nomaware.com/monads/html/index.html
08:07:35 <xic> astrolabe: yeah, sort of trying that
08:08:00 <astrolabe> I didn't find it easy
08:08:17 <scriptdevil> my default gtk2hs install location is in /usr/lib/gtk2hs/imports/gtk/.... and ghc is /usr/lib/ghc-6.6/imports/... how do i mix both?
08:08:53 <allbery_b> if you installed it properly then ghc-pkg should know where to look for it
08:09:46 <scriptdevil> it is installed all rite.. the package manager in archlinux did it for me..
08:10:10 <allbery_b> ghc-pkg list to see what package(s) comprise gtk2hs, then pass those as -package argumets to ghc,or use ghc --make
08:11:13 <scriptdevil>     ALUT-2.0, Cabal-1.1.6, GLUT-2.0, HGL-3.1, HUnit-1.1, OpenAL-1.3,
08:11:15 <scriptdevil>     OpenGL-2.1, QuickCheck-1.0, X11-1.1, base-2.0, cgi-2006.9.6,
08:11:15 <scriptdevil>     fgl-5.2, (ghc-6.6), haskell-src-1.0, haskell98-1.0, html-1.0,
08:11:15 <scriptdevil>     mtl-1.0, network-2.0, parsec-2.0, readline-1.0, regex-base-0.71,
08:11:15 <scriptdevil>     regex-compat-0.71, regex-posix-0.71, rts-1.0, stm-2.0,
08:11:15 <scriptdevil>     template-haskell-2.0, time-1.0, unix-1.0, xhtml-2006.9.13
08:11:23 <scriptdevil> so.. not there
08:11:24 <scriptdevil> :(
08:11:59 <astrolabe> scriptdevil: you could try /msg ing dcoutts
08:12:16 <scriptdevil> whats that?
08:12:26 <allbery_b> I'd ask the maintainer f the archlinux package
08:12:40 <allbery_b> (or at least check for a FAQ for the archlinux package)
08:12:45 <astrolabe> dcoutts is a user on #haskell, /msg is a private irc message.
08:12:47 <xinming> hmm, anyone here would give me a clue on how to solve the sudoku please?
08:12:52 <xinming> hmmm,
08:12:55 <xinming> btw.
08:13:18 <xinming> I mean use my codes. I can't finish the last function.
08:13:42 <xinming> I'll show you the url
08:13:45 <allbery_b> so google shows me a postinstall that should have registered gtk2hs with ghc-pkg.
08:14:28 <xinming> http://caibird.3322.org:8080/pub/sudoku/
08:14:39 <xinming> Please check the url there.
08:14:58 <xinming> I don't know how to finish the last function. >_<
08:15:13 <xinming> and yet the most important one.
08:22:50 <leed> ?past
08:23:09 <xinming> lisppaste2: url
08:23:09 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
08:23:32 <leed> thanks
08:28:21 <lisppaste2> xinming pasted "Sudoku in haskell" at http://paste.lisp.org/display/35140
08:28:22 <xinming> leed: Done.
08:28:46 <xinming> Or you can get it from http://caibird.3322.org:8080/pub/sudoku/sudokus.hs
08:30:59 <lisppaste2> lee pasted "Trouble about State in YAHT chap9" at http://paste.lisp.org/display/35141
08:33:45 <leed> I have some trouble when try code in YAHT chap9, about State
08:34:34 <Saizan> leed: for the first error on line 23 you missed the State contructor
08:35:15 <Saizan> returnState a = State (\st -> (st, a)) -- this should be correct
08:35:19 <xic> how would i make a function f :: X -> Int, that can take either a String or ByteString? i think i need to use type classes
08:35:42 <Saizan> xic: you need them :)
08:35:48 <xinming> anyone here would help. :-/
08:36:14 <Saizan> leed: same error on line 27
08:36:58 <leed> Saizan, yes, line 23 fixed
08:37:01 <Saizan> xinming: your problem is with haskell or with the logic of the program?
08:37:38 <leed> the same don't work at line 27 :-(
08:37:49 <leed> maybe i do some thing wrong...
08:38:19 <Saizan> maybe it's a precedence problem
08:38:37 <Saizan> try with:  bindState m k = State $ \st ->
08:40:34 <leed> Saizan, more error
08:40:51 <xinming> Saizan: with the logic of solving the sudoku.
08:40:56 <leed> I mean, this cause more error
08:41:12 <xinming> Saizan: I wrote that. But I don't know how to solve the sudoku. >_<
08:41:17 <Saizan> leed: ok, was kind of a guess :)
08:41:20 <xinming> maybe the last function I should write
08:44:21 <xic> how can i detect when a network Handle is closed by the other computer
08:44:21 <xic> ?
08:44:32 <SamB_XP> hmm.
08:44:54 <SamB_XP> well... step 1, see how it works with BSD sockets?
08:46:46 <xic> ouch :\
08:46:51 <SamB_XP> (you know, the standard API for sockets -- the one that even Windows nominally uses)
08:47:00 <SamB_XP> well. maybe there is another step 1!
08:47:08 * xic hopes so
08:48:00 <jethr0> > 4 `asTypeOf` (head ([]:: [Int]))
08:48:14 <jethr0> 4
08:48:19 <lisppaste2> velco pasted "Why the error is caught only once ?" at http://paste.lisp.org/display/35143
08:48:49 * sorear pokes @seen
08:49:04 <SamB_XP> but, I must point out that there are probably far more resources about using the BSD sockets api than there are about Haskell networking!
08:49:13 <jethr0> recently i've seen xinming, Saizan, xic, SamB_XP, jethr0 and sorear
08:49:30 <SamB_XP> jethr0: you aren't a lambdabot
08:49:39 <jethr0> my name is emily
08:49:52 <sorear> jethr0: @seen dons
08:49:57 <allbery_b> heh
08:50:22 <jethr0> I've seen dons 6 hours and 50 minutes ago.
08:51:00 <velco> I've seen dons 6 hours and 67 minutes ago.
08:51:27 <jethr0> velco: @version
08:51:31 <lisppaste2> Saizan annotated #35141 with "bindState for leed" at http://paste.lisp.org/display/35141#1
08:51:44 <Masklinn> hello #haskell
08:51:47 <jethr0>  /tell dons the velco bot has a remainder problem with minutes in @seen
08:52:14 <SamB_XP> jethr0: @vixen you are so cute!
08:52:15 <jethr0> Consider it noted.
08:52:27 <Saizan> can someone check my annotation? i just got it to typecheck without thinking much about semantic
08:52:33 <jethr0> not as cute as haskellers
08:52:36 <SamB_XP> jethr0: @tell dons to do something about that lag stuff
08:52:44 <jethr0> Consider it noted
08:52:56 <sorear> what lag stuff?
08:53:12 <sorear> I found the netsplit problem about 8 hours ago...
08:53:36 <jethr0> sorear: you mean _THE_ netsplit problem?
08:53:49 <SamB_XP> > filter isLetter ['\0'..]
08:53:57 <sorear> uh, how many were there? and how old is this one?
08:54:15 <jethr0> ['a'..'z']++['A'..'Z']
08:54:32 <syntaxfree> @pl f (a,b) = [a,b ]
08:54:52 <jethr0> afaik, there's been a netsplit problem in lambdabot for at least a year. but i'm not working on LB so i wouldn't know
08:55:05 <syntaxfree> where's \bot?
08:55:10 <leed> Saizan, thank you, it works now
08:55:15 <jethr0> Terminated
08:55:36 <sorear> anyway, the JOIN messages confuse lambdabot into generating a TOPIC flood, most of which time out, and would you believe Control.Concurrent.QSem isn't async exception safe?  Instant corruption.
08:55:53 <jethr0> :(
08:56:08 <Saizan> leed: those errors are in YAHT too? maybe we should report this
08:56:16 <jethr0> must have been hard word figuring _that_ out
08:56:26 <jethr0> work
08:56:26 <sorear-lambdabot> f = uncurry ((. return) . (:))
08:56:44 <jethr0> > 4 `asTypeOf` (head ([]:: [Int]))
08:58:02 <sorear> that wasn't a lambdabot bug, my whole internet connection was lagging :(
08:58:33 <SamB_XP> xic: hmm.
08:58:41 <kowey> leed, Saizan: either edit the wiki, or send patches to the darcs repository
08:58:47 <SamB_XP> it looks like you will get an EOF eventually
08:59:21 <sorear_> again ... this is annoying.
08:59:44 <xic> SamB_XP: right, but my problem is that i'm not reading/writing to the Handle all the time, i do lots of waiting, and i don't want to wait for nothing if the Handle has already been closed
09:00:03 <SamB_XP> xic: what sort of waiting?
09:00:49 <xic> SamB_XP: i'm using STM and i'm blocking using it's "retry"
09:00:57 <leed> Saizan, yes, I got this YAHT copy a few days ago
09:01:44 * leed check out YAHT at http://darcs.haskell.org/yaht/yaht.pdf
09:03:03 <kowey> leed: one observation is that YAHT uses type State st a = st -> (st, a), which is quite different from newtype State st a = State (st -> (st, a))
09:03:17 <sorear> @activity 9999 <-- another bug, must fix
09:03:17 <sorear-lambdabot> 0*total
09:03:40 <leed> Saizan, BTW, I'll post correct code on http://paste.lisp.org/display/35141
09:04:31 <sorear> @activity 9999
09:04:32 <sorear-lambdabot> Plugin `activity' failed with: IRCRaised Data.ByteString.last: empty ByteString
09:09:02 <leed> kowey, I know, but at page 128 this changed
09:09:32 <dmhouse> Afternoon everyone. :)
09:10:25 <kowey> leed: i see what's going on now
09:10:37 <kowey> functions like bindState were meant for the _old_ definition of State
09:11:01 <kowey> I think Hal was doing it two stages, first using the type State st a = ... version to help you get the overall idea what was going on
09:11:24 <kowey> and then passing to the official State monad, using typeclasses
09:12:58 <kowey> if you want to get mapTree working using the "official" State, you can replace `bindState` with >>=
09:13:30 <kowey> (perhaps some of these choices could be reconsidered to avoid creating these kinds of confusing situations)
09:19:29 <leed> kowey, yeah, I agree
09:20:35 <xic> any happs experts?
09:20:58 <Saizan> so no bug in YAHT? just a little confusion by using code of a version of the state monad with another?
09:22:23 <kowey> i think that's the case
09:23:08 <kowey> confusingly, they are both called "State"
09:23:51 <kowey> maybe the simplest thing is to rename the first "State" to something else, like "S"
09:24:28 <Saizan> but even the first is meant to be a "state monad"
09:25:02 <sorear> xic: yes #haskellers, not now.
09:25:12 <sorear> iirc shapr is on the list...
09:25:14 <Saizan> maybe one should make the difference more explicit, but i haven't read YAHT till chap9 so..
09:25:39 <Saizan> s/difference/passage/
09:26:12 <lisppaste2> leed annotated #35141 with "Fixed example code about State monad  in YAHT Chap9" at http://paste.lisp.org/display/35141#2
09:26:19 * sorear wonders if do ns is taking the day between Hac07 and PADL completely off
09:26:35 <kowey> actually, renaming it isn't quite going to work so well
09:27:00 <kowey> YAHT sort of "builds up" the idea of State monad... and on that page 128, it says
09:27:46 <kowey> something to the effect of "now that we know it's a monad, we'd like to make it an instance of the monad class" (paraphrasing)
09:27:56 <kowey> "but it just doesn't work"
09:28:01 <leed> Saizan, after use "newtype State ..." instead of "type State ...", YAHT doesn't say how to change returnState etc.
09:28:43 <kowey> leed: it's actually on page 128
09:28:57 <kowey> in the instance declaration of the State monad
09:29:04 <xic> sorear: it doesn't seem possible to have more then one header with the same name
09:29:15 <kowey> returnState has become return; bindState has become >>=
09:29:49 <Saizan> now that i read it, it's in the paste too :)
09:29:50 <kowey> he also rewrites mapTree using do notation
09:29:53 <leed> kowey, oh
09:30:40 <kowey> so, i don't think there's much to fix here... probably having you come to the channel to discuss this was the most productive thing
09:31:20 <leed> kowey, I need to rewrite mapTree
09:31:35 <kowey> i'd recommend a very light rewrite
09:31:50 <kowey> just replacing your `bindState` with >>=, and your returnState with return
09:31:54 <kowey> that should do it
09:32:05 <kowey> then you can compare with Hal's do notation version
09:35:37 <leed> kowey, thanks you, after I do these replaces, they works perfectly
09:36:08 <kowey> yay!
09:36:09 <sorear> xic: huh? that sounds like it might be an happs question, and I am definitely not on the list.
09:36:25 <xic> sorear: oh sorry
09:36:59 <velco> anyone could help me figure out why I can only catch exceptions once ?
09:37:13 <sorear> sure
09:37:16 <velco> http://paste.lisp.org/display/35143
09:38:02 <sorear> ok, what is the observed behaivor?
09:38:38 <velco> *Main> f
09:38:39 <velco> *** Exception:  : foo: user error (baz)
09:38:57 <velco> I wanted to see a "bar" there too.
09:39:32 <velco> what I ultimately want to achieve is get some trace to where the exception occured.
09:40:07 <velco> i..e outremost handlers add annotations to possibly already annotated rethrown exceptions.
09:41:16 <sorear> @src userError
09:41:16 <sorear-lambdabot> Source not found. It can only be attributed to human error.
09:42:00 <dmhouse> How does annotateIOError work? Does it replace the annotation or concatenate them?
09:42:03 <glguy> ?bot
09:42:03 <sorear-lambdabot> :)
09:42:09 <glguy> netsplit death?
09:42:14 <sorear> yes
09:42:38 <glguy> Have you yet determined what happens to the bot that kills it?
09:42:41 <sorear> fortunately, I've figured out how it happens, and while I can't think of a solution, maybe donns can.
09:43:07 <velco> it says "Adds a location description .. to an IOError"
09:43:28 <sorear> glguy: JOIN flood -> lambdabot gets confused and generates a TOPIC flood -> lots of timeouts -> data corruption because...
09:43:48 <sorear> glguy: Control.Concurrent.QSem.waitQSem is *not* async exception safe.
09:44:01 <glguy> TOPIC flood?
09:44:17 <velco> hmm, indeed, if it replaces the annotatio that would explain things ...
09:44:23 <sorear> it responds to every JOIN it receives with a TOPIC
09:45:18 <glguy> TOPIC is used to change the channel topic?
09:45:38 <sorear> velco: according to http://darcs.haskell.org/ghc-6.6/packages/base/System/IO/Error.hs, annotate replaces the message
09:46:22 <sorear> glguy: TOPIC is also used to fetch the topic
09:46:45 <Saizan> why fetch the topic on others join?
09:46:46 <sorear> glguy: lambdabot thinks it is joining, and wants to know what the topic is on this new channel
09:46:51 <velco> sorear: dmhouse: thanks.
09:47:16 <glguy> sorear: I'm not sure I understand why it interprets a JOIN like that
09:47:40 <sorear> it's not checking *who* joined
09:47:47 <Saizan> aaah
09:48:11 <Saizan> sorear: and is difficult to check it?
09:48:23 <sorear> fixing *that* would be easy. but the async exception problem would stay to bite again.
09:49:02 <Saizan> well, you should check who is joining anyway
09:49:53 <sorear> back in the day, sends didn't timeout, so lb would lag 2 seconds for every person joining in a split... was this observable?
09:59:52 <araujo> morning
10:00:17 * sorear waves
10:05:01 <glguy> ?yow
10:05:01 <sorear-lambdabot> Couldn't find fortune file
10:05:44 <sorear> sorry
10:06:01 <sorear> Emacs 22 doesn't have yow quotes :(
10:07:02 <sorear> ?quote
10:07:03 <sorear-lambdabot> pzpz says:  i can't see how anyone can use a laptop without the nipple
10:09:41 <paolino> is this function a fold ?
10:09:42 <paolino> mult [] _ = []
10:09:42 <paolino> mult (n:ns) e = replicate n e ++ concat (map (mult ns) [e..e+n])
10:09:54 <sorear> yes
10:10:25 <sorear> no wait maybe not
10:10:48 <glguy> what is it supposed to do?
10:11:13 <sorear> mult [] _ = [] ; mult (n:ns) e = replicate n e ++ concat Map (mult ns) [e..e+n]
10:11:17 <sorear> mult [] _ = [] ; mult (n:ns) e = replicate n e ++ concatMap (mult ns) [e..e+n]
10:11:41 <paolino> ehm it not really the function I use, I rewrite a random one with the same subfunctions
10:11:56 * shapr boings!
10:12:03 <sorear> that function is untypeable
10:12:16 <sorear> the second arg must have type fix a. [a]
10:12:17 <paolino> nah, it compiles
10:12:31 <sorear> doh, map :(
10:12:38 <paolino> *Main> :t mult
10:12:39 <paolino> mult :: [Int] -> Int -> [Int]
10:12:40 <glguy> ?type \(n:ns) e -> replicate n e ++ concat (map (mult ns) [e..e+n])
10:12:42 <sorear-lambdabot> Not in scope: `mult'
10:12:52 <glguy> oops
10:13:00 <sorear> ?let mult [] _ = [] ; mult (n:ns) e = replicate n e ++ concatMap (mult ns) [e..e+n]
10:13:01 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:13:09 <glguy> in
10:13:11 <glguy> mult
10:13:18 <glguy> oh, i see what you did
10:13:26 <sorear> ?type let mult [] _ = [] ; mult (n:ns) e = replicate n e ++ concatMap (mult ns) [e..e+n] in mult
10:13:28 <sorear-lambdabot> [Int] -> Int -> [Int]
10:14:30 <glguy> that can't be a fold without concating the results
10:14:47 <glguy> and since you'd have to concat at the end
10:14:56 <sorear> ?type let mult [] = \_ -> [] ; mult (n:ns) = let sub = mult ns in \e -> replicate n e ++ concatMap sub [e..e+n] in mult
10:14:59 <sorear-lambdabot> [Int] -> Int -> [Int]
10:14:59 <glguy> I think tha it wouldn't work
10:16:03 <paolino> it's not a fold, right ?
10:16:12 <glguy> foldr sub (const []) ?
10:16:19 <glguy> oh, no
10:16:30 <sorear> ?type op n sub [] = \e -> replicate n e ++ concatMap sub [e..e+n] in foldr op (\_ -> [])
10:16:30 <sorear> ?type op n sub [] = \e -> replicate n e ++ concatMap sub [e..e+n] in foldr op (\_ -> [])
10:16:30 <sorear> @Bot
10:16:30 <sorear> grr, connection lagging
10:16:32 <glguy> since you are using mult inside
10:16:56 <sorear-lambdabot> Maybe you meant: ft let vote yow
10:16:56 <sorear-lambdabot> parse error on input `='
10:16:56 <sorear-lambdabot> parse error on input `='
10:17:02 <sorear> ?type op n sub [] = \e -> replicate n e ++ concatMap sub [e..e+n] in foldr op (const [])
10:17:04 <sorear-lambdabot> parse error on input `='
10:17:07 <glguy> ?src foldr
10:17:07 <sorear-lambdabot> foldr k z xs = go xs
10:17:07 <sorear-lambdabot>     where go []     = z
10:17:07 <sorear-lambdabot>           go (y:ys) = y `k` go ys
10:17:15 <sorear> ?type op n sub = \e -> replicate n e ++ concatMap sub [e..e+n] in foldr op (const [])
10:17:18 <sorear-lambdabot> parse error on input `='
10:17:21 <sorear> ?type let op n sub = \e -> replicate n e ++ concatMap sub [e..e+n] in foldr op (const [])
10:17:23 <sorear-lambdabot> [Int] -> Int -> [Int]
10:18:05 <sorear> ?type let op n sub = liftM2 (replicate n) (concatMap (sub . (e+)) . enumFromTo 0) in foldr op (const [])
10:18:07 <sorear-lambdabot> Not in scope: `e'
10:18:47 <shapr> Yay code!
10:18:54 <sorear> ?type let op n sub = liftM2 (replicate n) (concatMap sub . flip map [0..n] . (+)) in foldr op (const [])
10:19:24 <sorear> @bot
10:19:27 <Igloo> sorear: Why did you paste the -fwarn-tabs commit message yesterday, BTW?
10:19:35 <sorear_> ?type let op n sub = liftM2 (replicate n) (concatMap sub . flip map [0..n] . (+)) in foldr op (const [])
10:20:30 <glguy> \ e -> replicate y e ++ go ys =<< [e..e+y]
10:20:34 <sorear-lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `[a1]'
10:20:34 <sorear-lambdabot>     In the first argument of `liftM2', namely `(replicate n)'
10:20:34 <sorear-lambdabot> :)
10:20:36 <sorear-lambdabot>     Couldn't match expected type `a2 -> r' against inferred type `[a1]'
10:20:36 <sorear-lambdabot>     In the first argument of `liftM2', namely `(replicate n)'
10:20:38 <glguy> needs to be factored to: y `k` go ys
10:20:45 <glguy> that seems feasible
10:20:52 <sorear_> PEP 666
10:21:26 <glguy> \ e -> replicate y e ++ go ys =<< [e..e+y]
10:21:35 <glguy> foldr (\ e -> replicate y e ++ go ys =<< [e..e+y]) (const [])
10:21:49 <glguy> ?type foldr (\y rest e -> replicate y e ++ go ys =<< [e..e+y]) (const [])
10:21:50 <sorear-lambdabot> Not in scope: `go'
10:21:50 <sorear-lambdabot>  
10:21:50 <sorear-lambdabot> <interactive>:1:40: Not in scope: `ys'
10:21:59 <glguy> ?type foldr (\y rest e -> replicate y e ++ rest =<< [e..e+y]) (const [])
10:22:01 <sorear-lambdabot>     Couldn't match expected type `[a]' against inferred type `a -> t'
10:22:01 <sorear-lambdabot>     In the second argument of `(++)', namely `rest'
10:22:08 <glguy> ?type foldr (\y rest e -> replicate y e ++ (rest =<< [e..e+y])) (const [])
10:22:10 <sorear-lambdabot> [Int] -> Int -> [Int]
10:22:13 <glguy> done and done
10:22:29 <glguy> (did you already finish while I was doing this?)
10:22:41 <sorear> ?pl foldr (\n sub e -> replicate n e ++ concatMap sub [e..e+n])  (const [])
10:22:42 <sorear-lambdabot> foldr (ap ((.) . ap . ((++) .) . replicate) (flip ((.) . (=<<)) . ap enumFromTo . (+))) (const [])
10:23:18 <glguy> > foldr (\y rest e -> replicate y e ++ (rest =<< [e..e+y])) (const []) [1..3] 4
10:24:22 * sorear ought to get @run using ghci instead of runplugs
10:24:29 <glguy> paolino: now you have our answers
10:24:33 <glguy> yes, it is a foldr
10:24:37 <paolino> gulp !
10:25:34 <glguy> Prelude> foldr (\y ys e -> replicate y e ++ (ys =<< [e..e+y])) (const []) [1..3] 4
10:25:37 <glguy> [4,4,4,4,4,4,5,5,5,6,6,6,5,5,5,5,5,6,6,6,7,7,7]
10:26:32 <sorear> now see how short that is? :)
10:26:39 <glguy> ?quote lines
10:26:40 <sorear-lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
10:27:03 <glguy> The moral of the story is that if you are doing explicit recursion, you are probably doing something wrong! B^D
10:27:51 <nostrademons> all explicit recursion, or just explicit recursion on lists?
10:27:55 <sorear> @src foldr
10:27:55 <sorear-lambdabot> foldr k z xs = go xs
10:27:55 <sorear-lambdabot>     where go []     = z
10:27:55 <sorear-lambdabot>           go (y:ys) = y `k` go ys
10:28:09 <nostrademons> often, I find it a little tedious to define folds on data types with 6+ constructors apiece
10:28:19 <sorear> explicit recursion, like unsafePerformIO, should be isolated as much as possible.
10:29:01 <sorear> nostrademons: in my 590 character theorem prover, I was able to shave a good 20 characters by defining a fold on my type of prepositions.
10:29:20 <sorear> (just an interesting datum)
10:29:30 <nostrademons> interesting
10:29:49 <sorear> granted, my fold function was called 'g'
10:30:03 <nostrademons> heh
10:30:14 <paolino> mmhh, shame that my function is monadic, I cannot translate
10:30:24 <nostrademons> I'm thinking through my evaluator and typechecker and not really seeing how I could collapse them into a fold...
10:30:27 <sorear> why not?
10:30:32 <sorear> :t foldM
10:30:34 <sorear-lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
10:30:52 <glguy> foldM is foldl for Monads
10:30:57 <nostrademons> would need to define that over the expression data type...
10:31:05 <sorear> foldr can also be used monadically
10:31:22 <glguy> sure, but foldM does the binding for you
10:31:23 <paolino>   run [] _ = return $ []
10:31:24 <paolino>   run (n:ns) x = do
10:31:24 <paolino>     hs <- sample n ys
10:31:24 <paolino>     rss <- mapM (run ns) ys
10:31:24 <paolino>     return $ hs ++ concat rss
10:31:28 <sorear> sequence, for example, is foldr (liftM2 (:)) (return [])
10:31:53 <sorear> ok, step 1, get rid of do!
10:32:07 <paolino> poor do :/
10:32:08 <glguy> this one is easy
10:32:16 <paolino> I do
10:32:45 <sorear> run [] _ = return [] ; run (n:ns) x = liftM2 (\hs rss -> hs ++ concat rss) (sample n ys) (mapM (run ns) ys)
10:33:17 <paolino> liftM2 (++) (sample n ys) (liftM concat (mapM (run ns) ys)
10:33:32 <glguy> 12:29  paolino>   run [] _ = return $ []
10:33:32 <glguy> 12:29  paolino>   run (n:ns) x = do
10:33:32 <glguy> 12:29  paolino>     hs <- sample n ys
10:33:32 <glguy> 12:29  paolino>     rss <- mapM (run ns) ys
10:33:32 <glguy> 12:29  paolino>     return $ hs ++ concat rss
10:33:34 <glguy> errr
10:33:37 <glguy> \x xs -> sample x ys >>= \hs -> mapM xs ys >>= \rss -> return (hs ++ concat rss)
10:33:56 <glguy> foldr (above) (return [])
10:34:39 <glguy> ?pl \x xs -> sample x ys >>= \hs -> mapM xs ys >>= \rss -> return (hs ++ concat rss)
10:34:39 <sorear-lambdabot> (. ((. ((return .) . (. join) . (++))) . (>>=) . flip mapM ys)) . (>>=) . flip sample ys
10:34:42 <glguy> ew
10:35:02 <paolino> I should have guessed
10:35:19 <glguy> anything that recurses on a list (n:ns)  and only uses   ns to recurse can be rewritten as foldr
10:35:37 <sorear> foldr (\n (sub,ys) x -> (liftM2 (++) (sample n ys) (liftM concat (mapM sub ys), x:ys)) (\_ -> return [])
10:35:53 <glguy> oh, I missed the 'x' var
10:35:55 <sorear> :t \sample -> foldr (\n (sub,ys) x -> (liftM2 (++) (sample n ys) (liftM concat (mapM sub ys), x:ys)) (\_ -> return [])
10:35:57 <sorear-lambdabot> parse error (possibly incorrect indentation)
10:35:59 <glguy> so that woudl need to be added
10:36:16 <glguy> sorear: this won't typecheck, too many free vars
10:36:34 <sorear> :t \sample -> fst . foldr (\n (sub,ys) x -> (liftM2 (++) (sample n ys) (liftM concat (mapM sub ys), x:ys)) ((\_ -> return []),[])
10:36:35 <glguy> I thought
10:36:36 <sorear-lambdabot> parse error (possibly incorrect indentation)
10:36:40 <glguy> unless you replaced
10:36:55 <sorear> :t \sample -> fst . foldr (\n (sub,ys) x -> (liftM2 (++) (sample n ys) (liftM concat (mapM sub ys), x:ys))) ((\_ -> return []),[])
10:36:57 <sorear-lambdabot>     Couldn't match expected type `t1 -> t'
10:36:57 <sorear-lambdabot>            against inferred type `(a, b)'
10:37:14 <sorear> :t \sample -> fst . foldr (\n (sub,ys) x -> (liftM2 (++) (sample n ys) (liftM concat (mapM sub ys), n:ys))) ((\_ -> return []),[])
10:37:16 <sorear-lambdabot>     Couldn't match expected type `t1 -> t'
10:37:16 <sorear-lambdabot>            against inferred type `(a, b)'
10:37:41 <sorear> :t \sample -> fst . foldr (\n (sub,ns) x -> (liftM2 (++) (sample n ns) (liftM concat (mapM sub ns), n:ns))) ((\_ -> return []),[])
10:37:43 <sorear-lambdabot>     Couldn't match expected type `t1 -> t'
10:37:43 <sorear-lambdabot>            against inferred type `(a, b)'
10:39:31 <bos31337> @pl \f (Foo x) -> f x
10:39:32 <sorear-lambdabot> (line 1, column 9):
10:39:32 <sorear-lambdabot> unexpected "x"
10:39:32 <sorear-lambdabot> expecting operator or ")"
10:39:43 <bos31337> hrng.
10:39:53 <sorear> :t \sample -> fst . foldr (\n (sub,ns) -> (\x -> liftM2 (++) (sample n ns) (liftM concat (mapM sub ns)), n:ns) ((\_ -> return []),[])
10:39:55 <sorear-lambdabot> parse error (possibly incorrect indentation)
10:39:59 <sorear> :t \sample -> fst . foldr (\n (sub,ns) -> (\x -> liftM2 (++) (sample n ns) (liftM concat (mapM sub ns)), n:ns)) ((\_ -> return []),[])
10:40:01 <sorear-lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> [a] -> m [a1]) -> [a] -> a -> m [a1]
10:40:12 <sorear> that look good?
10:40:54 <paolino> the pure one has that ..... =<<
10:41:07 <Saizan> uhm, between explicit recursion and this foldr i'll use the former :)
10:41:20 <paolino> :)
10:41:27 <glguy> bah, sorear is just tyring to fit it on one line
10:41:32 <glguy> foldr doesn't me fugly
10:41:44 <glguy> mean
10:42:05 <sorear> besides, you don't have to stick to just foldr.
10:43:01 <sorear> ?let foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)
10:43:02 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
10:43:14 <sorear> yes, I know that's a foldr too
10:44:18 <sorear> :t let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in \sample -> fst . foldr (\n (sub,ns) x -> (liftM2 (++) (sample n ns) (liftM concat (mapM sub ns), n:ns))) ((\_ -> return []),[])
10:44:21 <sorear-lambdabot>     Couldn't match expected type `t1 -> t'
10:44:21 <sorear-lambdabot>            against inferred type `(a, b)'
10:45:00 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in \sample -> fst . foldr (\n (sub,ns) -> (\x -> liftM2 (++) (sample n ns) (liftM concat (mapM sub ns)), n:ns)) ((\_ -> return []),[])
10:45:02 <sorear-lambdabot> forall (m :: * -> *) a a1. (Monad m) => (a -> [a] -> m [a1]) -> [a] -> a -> m [a1]
10:45:43 <paolino> ok, my func is a fold for experts
10:46:00 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in    \sample -> fst . foldrxs (\x xs sub -> liftM2 (++) (sample x xs) (liftM concat (mapM sub xs)))
10:46:02 <sorear-lambdabot>     Couldn't match expected type `(->) a' against inferred type `[]'
10:46:02 <sorear-lambdabot>     Probable cause: `liftM2' is applied to too many arguments
10:46:09 <paolino> with lambdabot
10:46:26 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in    \sample -> foldrxs (\x xs sub -> liftM2 (++) (sample x xs) (liftM concat (mapM sub xs)))
10:46:28 <sorear-lambdabot>     Couldn't match expected type `(->) a' against inferred type `[]'
10:46:28 <sorear-lambdabot>     Probable cause: `liftM2' is applied to too many arguments
10:47:42 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in    \sample -> foldrxs (\x xs sub -> liftM2 (++) (sample x xs) (liftM concat (mapM sub xs))) (\_ -> return [])
10:47:44 <sorear-lambdabot>     Couldn't match expected type `(->) a' against inferred type `[]'
10:47:44 <sorear-lambdabot>     Probable cause: `liftM2' is applied to too many arguments
10:47:55 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in  foldrx -- \sample -> foldrxs (\x xs sub -> liftM2 (++) (sample x xs) (liftM concat (mapM sub xs))) (\_ -> return [])
10:47:57 <sorear-lambdabot> Not in scope: `foldrx'
10:48:01 <sorear> @ty let {foldrxs fun z [] = z ; foldrxs fun z (x:xs) = fun x xs (foldrxs fun z xs)} in  foldrxs -- \sample -> foldrxs (\x xs sub -> liftM2 (++) (sample x xs) (liftM concat (mapM sub xs))) (\_ -> return [])
10:48:03 <sorear-lambdabot> forall t t1. (t -> [t] -> t1 -> t1) -> t1 -> [t] -> t1
10:49:19 * sorear gives up
10:52:04 <bos31337> is there a way to get darcs to remember my email address?
10:52:09 <sorear> yes
10:52:19 <bos31337> it's not mentioned in the man page, alas.
10:52:32 <sorear> # for the benefit of darcs
10:52:34 <sorear> export EMAIL='stefanor@cox.net'
10:52:58 <sorear> (from /home/stefan/.bashrc)
10:53:04 <bos31337> thanks.
10:53:47 <allbery_b> also ~/.darcs/author, as Full Name <email@addr>
10:53:47 <sorear> also, run echo 'my_email_address' > _darcs/prefs/email in all your repos to allow darcs send to work.
10:54:08 <sorear> allbery_b: thanks
10:54:18 <bos31337> allbery_b: nice, thanks!
10:55:09 <emk> unfoldr is fun. :-)
10:56:07 <paolino> uhm, I have a problem now. This is my old function
10:56:08 <paolino> f g a = accum (\s i -> g s i) a (indices a, indeces a)
10:56:08 <paolino> but g now become monadic  and my head dosn't cope with it
10:56:14 <lisppaste2> Hunter_wow pasted "Data types" at http://paste.lisp.org/display/35159
10:57:23 <allbery_b> Hunter_wow: you need parentheses
10:57:50 <allbery_b> e.g. re (Num a), re (Add a b)
10:59:26 <Hunter_wow> aha, will check
11:00:45 <monochrom> why does g become monadic?  because you change it to be monadic?
11:01:32 <paolino> yes with (RandomGen g)   => .....   State g
11:02:29 <paolino> but in the array there go evalState (g s i) ...
11:03:00 <Saizan> f a = get >>= \g -> accum (\s i -> g s i) a (indices a, indeces a) -- maybe
11:03:20 <Saizan> f a = get >>= \g -> return $ accum (\s i -> g s i) a (indices a, indeces a) -- better
11:03:38 <monochrom> No one has generalized accum to monadic functions.  I guess you could roll your own.
11:04:08 <paolino> I suspected that
11:04:29 <paolino> with ! and // operators ?
11:04:31 <monochrom> It is unclear what the semantics would be.
11:05:14 <moconnor> @pl foo x = 3
11:05:14 <sorear-lambdabot> foo = const 3
11:05:33 <paolino> monochrom I dont want to store monadic result in the array
11:05:38 <moconnor> @ty const
11:05:40 <sorear-lambdabot> forall a b. a -> b -> a
11:06:00 <Jaak> @free const
11:06:02 <sorear-lambdabot> f . const x = const (f x) . g
11:06:17 <lisppaste2> Hunter_wow annotated #35159 with "paranteses fixed - still error" at http://paste.lisp.org/display/35159#1
11:06:41 <sorear> you don't need to generalize accum to monadic functions, like foldr the existing accum can handle them
11:06:59 <shapr> I wonder what Thomas Jaeger is doing these days.
11:07:00 <sorear> sorry spoke a little too soon
11:07:00 <allbery_b> yep, you need to use show
11:07:04 <shapr> @seen TheHunter
11:07:05 <sorear-lambdabot> I haven't seen TheHunter.
11:07:13 <shapr> lambdabot: @hello
11:07:26 <sorear> shapr: lambdabot's been netsplit.
11:07:27 <paolino> mmhh, it dosnt thread the state like in foldr
11:07:30 <monochrom> If you use // many many times, performance will suffer.  But it is precise in semantics.
11:07:33 <shapr> ah
11:07:41 <shapr> I want to switch to xmpp :-(
11:07:49 <sorear> I have finally found the problem, however.
11:08:04 <sorear> does freenode even do xmpp?
11:08:08 <allbery_b> re (Num a) = show a -- or something
11:08:15 <shapr> The IRC protocol was awesome in 1989 when I started using it, but I am very frustrated at it these days.
11:08:17 <allbery_b> you can't just concatenate a number with a string
11:08:31 <Hunter_wow> xmpp is not xampp right?.
11:08:41 <sorear> do non-graphical xmpp clients exist? or will I have to write my own?
11:08:41 <shapr> Nej
11:08:44 <shapr> xmpp == Jabber
11:08:47 <monochrom> I said the same thing about some other programming languages :)
11:08:48 <Hunter_wow> aha,k
11:08:49 <allbery_b> like politics and sausage, you don't want to see how it's made :)
11:08:55 <shapr> Lots of text-only jabber clients.
11:08:59 <paolino> accum is not powerful enough
11:09:51 * sorear goes to write a fastish accumM
11:10:17 <paolino> well , in my case I can produce different generators to feed , but that's not general
11:10:37 * shapr goes to write a fascist accumM!
11:10:40 <shapr> ok, not really.
11:10:45 <shapr> But at least you'd know it was strict.
11:11:19 <sorear> :t accum
11:11:21 <sorear-lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> Array i e -> [(i, a)] -> Array i e
11:11:38 <paolino> I wonder why there isn't a fold for Array
11:12:03 <sorear> :t accumArray
11:12:05 <sorear-lambdabot> forall e a i. (Ix i) => (e -> a -> e) -> e -> (i, i) -> [(i, a)] -> Array i e
11:13:24 <monochrom> Use lots of //'s for the moment.  It's slow but its meaning is clear.  After you understand what you're doing, there is an unsafeFreeze-unsafeThaw trick to make it go fast.
11:16:31 <Hunter_wow> allbery_b sorry but I cant find where I should place the "show" in the funcction. Do you think you can show me?  http://paste.lisp.org/display/35159#1
11:17:50 <pafcu> What's the easiest way to output binary data? I want to write an Int and a String in the form <4-byte int><string>
11:18:09 <pafcu> How do I output the Int in binary?
11:18:47 <Saizan> Hunter_wow: re (Num a) = "" ++ show a
11:19:34 * allbery_b was off getting lunch, sorry
11:19:50 <allbery_b> [14:05] <allbery_b> re (Num a) = show a -- or something
11:20:00 <monochrom> I don't know about easiest.  I would consider Foreign.Storable and System.IO.hPutBuf
11:20:08 <Jaak> this "" ++ looks very much like java
11:20:12 <allbery_b> not sure what the empty string was doing there, unless you were hoping for a Perlish autoconvert
11:20:19 <monochrom> Also Foreign.Marshall
11:20:54 <monochrom> Hey, x=1+1 looks like Java too!
11:20:55 <Hunter_wow> yea its a Perlish thing
11:21:40 <monochrom> Also Int may be 8-byte.
11:22:02 <Hunter_wow> and => re (Num a) = "" ++ show a    gives "error:  Type : Expr -> [Char]  *** Does not match : Expr -> [String]"
11:22:31 <Jaak> change type to
11:22:34 <Jaak> re :: Expr -> String
11:22:39 <allbery_b> oh, right.  you seem to be returning strings everywhere, did you really want the return type to be [String]?
11:23:09 <monochrom> The "Goal" part points towards [String]
11:23:17 <Hunter_wow> yea
11:23:20 <allbery_b> (in Haskell, String is [Char])
11:23:37 <monochrom> Consider ["+"] ++ re a ++ re b
11:23:54 <Hunter_wow> but it should be [String]
11:24:11 <monochrom> The moral is: [[Char]] != [Char]   but it's too obvious :)
11:24:18 <allbery_b> then you need to refigure all of those because they currntly generate String, not [String]
11:24:42 <monochrom> :type ["+"]
11:24:53 <allbery_b> :t let a = 5 in "+" ++ show a
11:24:55 <sorear-lambdabot> [Char]
11:24:58 <Hunter_wow> aha, ok
11:25:12 <monochrom> :t ["+"]
11:25:14 <sorear-lambdabot> [[Char]]
11:25:23 <monochrom> see?
11:26:30 <allbery_b> haskell has distinct types for single characters (Char) and strings of characters ([Char], otherwise known as String)
11:26:52 <allbery_b> hm.
11:26:55 <allbery_b> ?src String
11:26:56 <sorear-lambdabot> type String = [Char]
11:27:58 <monochrom> re (Num a) = [ show a ]
11:29:49 <monochrom> paolino must have been trying my unsafeFreeze suggestion and crashed his computer
11:30:08 <monochrom> or perhaps frozen his computer hehe
11:36:04 <moconnor> Is there a way to print the type of something from my program, when it's not running in ghci?  I'm dreaming of something like trace, but for types.  Or something like show_type :: a -> String.
11:36:29 <bd_> The type is known statically, you could load the module of your program in ghci and ask it
11:37:22 <bd_> failing that look into http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Typeable.html
11:37:23 <sorear-lambdabot> http://tinyurl.com/ylclo5
11:37:26 <notsmack> you could do it the lambdabot way
11:37:40 <bd_> you'll need to derive Typeable though - type data is otherwise not generally known at runtime
11:37:43 <notsmack> which i guess just queries ghci?
11:38:23 <bd_> Prelude Data.Typeable> show $ typeOf (undefined :: [(String,Integer)])
11:38:23 <bd_> "[([Char],Integer)]"
11:38:44 <bd_> for custom datatypes you must derive Typeable, naturally
11:39:04 <moconnor> bd_: thanks!
11:40:14 <bd_> :t typeOf
11:40:16 <sorear-lambdabot> forall a. (Typeable a) => a -> TypeRep
11:40:18 <bd_> hmm
11:40:24 <bd_> > show $ typeOf typeOf
11:40:32 <bd_> wait, that won't work
11:40:45 <bd_> > show $ typeOf ((+)::Int -> Int -> Int)
11:40:56 <bd_> ?botsnack
11:40:57 <sorear-lambdabot> :)
11:40:58 <bd_> > show $ typeOf ((+)::Int -> Int -> Int)
11:41:04 <bd_> tsk, didn't work this time
11:41:14 <monochrom> typeOf (typeOf :: Int -> TypeRep)   that will work but begs the question
11:41:41 <bd_> All the interesting types are polymorphic anyway :)
11:43:11 <allbery_b> > 3
11:43:16 <allbery_b> ?bot
11:43:17 <sorear-lambdabot> :)
11:43:31 <allbery_b> no >-eval in this lbot
11:43:35 <allbery_b> @run 3
11:43:35 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
11:44:23 <bakert> oh my god i am so bored of if within do.  how thick must i be not to have taken it in yet.
11:44:47 <bakert> baaack to the wikibooks indentation page again.
11:45:37 <bakert> it's something to do with having two lines in the else.
11:46:13 <Saizan> how you indent the second?
11:46:20 <bakert> ?paste
11:46:21 <sorear-lambdabot> http://paste.lisp.org/new/haskell
11:46:37 <lisppaste2> bakert pasted "Goddamn indentation i am a moron" at http://paste.lisp.org/display/35165
11:46:49 <bakert> code is wrong
11:46:55 <bakert> but i've not got that far.
11:46:56 <bakert> !
11:47:07 <bakert> maybe i am too tired for haskell at the moment ...
11:47:12 <seliopou> :t get
11:47:14 <sorear-lambdabot> forall (m :: * -> *) s. (MonadState s m) => m s
11:47:15 <allbery_b> you need another do forthe else
11:47:22 <allbery_b> that is, ... else do ...
11:47:22 <bakert> aha!
11:47:28 <bakert> because i have another <-
11:47:29 <bakert> ?
11:47:36 <seliopou> :t do { n <- get ; return () }
11:47:36 <bd_> I tend to prefer case in do-blocks, the layout rules seem a bit less weird.
11:47:38 <sorear-lambdabot> forall (t :: * -> *) t1. (MonadState t1 t) => t ()
11:47:39 <bd_> But that's just me
11:48:28 <allbery_b> well, because if is not itself monadic so you need to open another monadic expression (eother a do-block or something involving monadic operators) --- you used <- so you need a do-block
11:49:58 <bakert> i see.
11:50:01 <allbery_b> (more precisely if is not part of do-syntax, so an if-expression constitutes an "escape" from the the do-block containing it)
11:50:30 <allbery_b> just as if you wanted to do monadic stuff inside a function *argumnt* inside a do-block you would need another do-block
11:50:47 <allbery_b> e.g. y <- doSomething (do ...)
11:50:50 <bakert> right.  i thought i was just messing up the original do-if thing which is what stopped me from thinking what else might be going on.  an interesting pitfall.  thanks folks.  and it's only 2 hours since i last promised myself only to ask really hard questions not stoopid ones.
11:51:39 <allbery_b> *shrug* the problemhere is that "do" is magic syntax, so it behaves a bit oddly
11:51:46 <bakert> so if i used a >>= instead of the <- i wouldn't need a do.  the do and the <- are a linked together thing.
11:52:04 <allbery_b> this iss where it starts to pay to learn how to do things with >>= and return instead f do-notation
11:52:04 <bakert> i guess i knew that already.  but it's nice to firm it up in my brain.
11:52:11 <allbery_b> right
11:52:54 <bakert> yes, when i can get >>= to work i like it much more.  but i haven't quite understood it yet.  i know it is sequencing the operations and that it is infix and i can look up the type but i still get confused about where the argument goes and daft things like that.
11:53:01 <bakert> i will get there!
11:53:09 <allbery_b>  @undo is your friend
11:53:16 <bakert> what does that do?
11:53:21 <allbery_b> @undo do { x <- f y; return x }
11:53:22 <sorear-lambdabot> f y >>= \ x -> return x
11:53:27 <bakert> (or undo ;))
11:53:33 <bakert> ah i see
11:53:35 <bakert> clever.
11:53:43 <bakert> i should use that!
11:54:09 <allbery_b> (there's also @redo to convert an expression using >>= intoa do-block)
11:54:09 <bakert> thanks allbery_b
11:54:10 <Syzygy-> @undo do { a <- f x; b <- g y; c <- h w; return a:b:c:[] }
11:54:10 <sorear-lambdabot> f x >>= \ a -> g y >>= \ b -> h w >>= \ c -> return a : b : c : []
11:54:19 <bakert> golly.
11:54:26 <Syzygy-> @. redo undo do { a <- f x; b <- g y; c <- h w; return a:b:c:[] }
11:54:26 <sorear-lambdabot> do { a <- f x; b <- g y; c <- h w; return a : b : c : []}
11:54:38 <bakert> cripes.
11:55:45 <bakert> @undo do { y <- f acc ; return (y ++ [x]) }
11:55:45 <sorear-lambdabot> f acc >>= \ y -> return (y ++ [x])
11:55:50 <bakert> hey hey!
11:56:00 <allbery_b> for real brain twisting you can combine with pointfree...
11:56:19 <Saizan> @. pl undo do { y <- f acc ; return (y ++ [x]) }
11:56:20 <sorear-lambdabot> (++ [x]) `fmap` f acc
11:56:21 <bakert> no don't start on the pointfree.  every time i think i see a place to use it i replace my $s with .s and it all breaks!
11:56:44 <Saizan> :D
11:56:46 <notsmack> haha
11:56:47 <bakert> pointfree is going to have to be for another day!
11:56:52 <allbery_b> ons trick with pointfree is you need Control.Monad.Reader for some of the tricks it uses
11:57:39 <allbery_b> (specifically, it likes to treat ((->) r), the type of functions taking a single argument, as a monad and use monady tricks)
11:57:48 <monochrom> how could anyone learn do-notation without also learning >>= ?
11:58:09 <bakert> monochrom, by copying like a monkey and hoping it works!  that's how i did it anyway!
11:58:09 <Saizan> however when you have  m >>= \x -> return . f x   you can replace with liftM f m
11:58:17 <allbery_b> (this generalizes because every function is secretly a function taking a single arghument and returning if necessary a function taking the next argument...)
11:58:19 <humasect> file name does not match module name `Main' -- is this a linking issue ? Main.hs was not changed. nothing at the top of the .hs file
11:58:57 <kpreid> humasect: the file with nothing at the top is assumed to be Main
11:58:57 <bakert> is it me or does everything i write in haskell just shrink and shrink and shrink when i work out how i should really be doing it.  when does it stop?!!
11:59:01 <allbery_b> several of the tutorials are kinda light on the whole do vs. >>= thing
11:59:10 <allbery_b> @quote collapse
11:59:11 <sorear-lambdabot> No quotes match. Are you on drugs?
11:59:14 <allbery_b> hm
11:59:19 <Saizan> @quote lines
11:59:20 <sorear-lambdabot> qwe1234 says: so, to summarize: laziness per your definition is a form of syntactic sugar that saves one or two lines of code while making programs slower.  whoop de doo
11:59:20 <allbery_b> @quote 2-line
11:59:20 <sorear-lambdabot> No quotes match. The more you drive -- the dumber you get.
11:59:24 <humasect> kpreid: related problems with this on google is an error before "module Main where' is parsed
11:59:30 <allbery_b> @quote 2.lines
11:59:31 <sorear-lambdabot> glguy says: in true Haskell form, after I realized what I was actually doing... all my functions melted down to about 2 lines each
11:59:34 <allbery_b> there is is
11:59:41 <monochrom> I don't understand humasect's question.  I can't reproduce the problem.
12:00:10 <bakert> yes, only i actually replace my entire 10 line functions with single lines or half lines in the calling functions.  i hope to discover something i am doing cannot be reduced to about four words sometime soon!
12:00:12 <allbery_b> it's nto a hard-and-fast rule, but it's very common
12:00:54 <humasect> this is just ghc --make Main , then chasing modules from Main it drops this error.
12:01:27 <allbery_b> humasect: maybe one of your other files is missing "module Foo where..." ?
12:01:37 <bakert> can i get this undo thing anywhere else or do you have to publicly humiliate yourself and use it here?? ;)
12:01:41 <monochrom> ghc --make Main  means   ghc --make Main.hs
12:01:46 <allbery_b> so when ghc hits it it tries to stick it in module Main (sincew there's no module declaration) and complains
12:01:46 <humasect> hmm
12:01:51 <humasect> monochrom: yep
12:02:07 <humasect> allbery_b: ohh, interesting. investigating
12:02:09 <kpreid> bakert: you can talk with lambdabot in private messages, or you can run your own locally, or you can run GOA
12:02:12 <allbery_b> lambdabot accepts /msg (freenode requires your nick to be registered)
12:02:26 <bakert> what's GOA?
12:02:27 <allbery_b> or there's http://lambdabot.codersbase.com
12:02:28 <sorear-lambdabot> Title: Lambdabot Web Interface
12:02:35 <allbery_b> @where GOA
12:02:36 <sorear-lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
12:02:42 <kpreid> oh, right
12:02:47 <allbery_b> "ghci on acid",a way to hook lambdabot into ghci
12:03:00 <bakert> that sounds a bit crazy
12:03:01 <allbery_b> (you have to build a local lambdabot first)
12:04:01 <bakert> i'll stick to the private message thing til i am a bit more adept i think.  thanks so much folks.  a whole world of undo-ing opens up!
12:04:29 <humasect> all modules are correctly described and declared
12:04:46 <monochrom> I still can't reproduce the problem. :)
12:05:26 <monochrom> deletia all *.hi files and try again.  at least a clean start.
12:05:37 <humasect> yep tried it
12:05:51 <humasect> can it be a conflict? would it try to pick up these .hsc files ?
12:05:57 <humasect> -v isn't telling
12:06:20 <monochrom> you have .hsc files?
12:06:23 <humasect> yes
12:06:32 <monochrom> how come... did you write them?
12:06:38 <humasect> yes
12:07:57 <monochrom> They are suspects then.  Likely the "if no module declaration then it's module Main" rule applies.  (I don't know for sure.)  Except this time it's harder to check by a human since .hsc is a mess.
12:08:46 <humasect> it is clean here so far, with #include and #const only , the hsc files i've checked and seem perfectly normal (as it was working minutes ago)
12:09:33 <velco> is sequence [a, b, c ... etc] the same as do a >>= b >>= c ?
12:10:06 <bd_> :t sequence
12:10:08 <sorear-lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
12:10:12 <velco> umm, no
12:10:16 <bd_> returns the result values in an array :)
12:10:18 <velco> oh,yes.
12:10:22 <velco> list,
12:10:25 <monochrom> Let me see what a .hsc looks like
12:10:28 <bd_> and doesn't chain results from one to the next
12:10:48 <bd_> a >>= b >>= c <-- would be foldl1 (>>=) [a, b, c], I think
12:10:49 <bd_> :t foldl1
12:10:52 <sorear-lambdabot> forall a. (a -> a -> a) -> [a] -> a
12:10:54 <bd_> :t foldl
12:10:57 <sorear-lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
12:11:13 <bd_> ?run foldl1 (++) ["a", "b", "c"]
12:11:14 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:11:34 <allbery_b>  @run  requires hs-plugins
12:11:35 <allbery_b> @version
12:11:36 <sorear-lambdabot> lambdabot 4p0, GHC 6.7 (Linux i686 2.00GHz)
12:11:36 <sorear-lambdabot> darcs get
12:11:39 <monochrom> hmm hsc files!  not hc files!  I don't know hsc files...
12:11:43 <bd_> bleh, that really needs to be fixed :/
12:11:52 <allbery_b> hsc files are FFI foo, use hsc2hs to convert them
12:12:09 <bd_> <-- tried building lambdabot for 6.4 a while ago, found some of the dependencies no longer build for ghc 6.4
12:12:13 * allbery_b wonders if dons got hs-plugins working yet...
12:12:25 <humasect> these hsc files become nearly identical hs files, only with #line pragmas and some constants from C headers .. nothing fancy at all
12:12:28 <allbery_b> yeh, the "official" lambabot runs on ghc6.5
12:13:13 <allbery_b> (so hs-plugins still works if you import a single file from ghc6.4; ghc6.6 broke more stuff)
12:14:55 <monochrom> I see.  So your hsc files also have proper "module XXX where" declarations?  Then I really don't know.
12:14:57 <bd_> I thought it was a change in a C header somewhere, as well as a .hi format change?
12:15:10 <humasect> okay i've reproduced it
12:15:12 <allbery_b> 6.5 changed Typeable.h; 6.6 changed the .hi format
12:15:33 <allbery_b> the former can be worked aroundby using 6.4's Typeable.h
12:16:27 <humasect> 6.6's hi format prevents hs-plugins 0.10 from working ?
12:18:11 <humasect> i do not understand this behavior : importing a module by itself gives a real and actual error to fix within it, but along with others it gives this Main module name issue...
12:18:11 <allbery_b> yes, you get an array access error at runtime because the file format changed.  (unless 0.10 was released last night in which case maybe dons fixed it like he promised to :)
12:18:21 <humasect> =) ok
12:20:00 <monochrom> The latter is unfortunate.  Maybe a bug.  Maybe a feature.
12:20:14 <humasect> to prevent it in the future, would i have to perhaps exclicitly export symbols from a module ?
12:20:21 <humasect> (would it help?)
12:21:19 <monochrom> There are many good reasons to list exports.  This should not be one of them :)
12:22:37 <humasect> =) hm, all of them are used outside of the module anyway. i think this is a bug for sure, i can type anything into this module which Main includes and get the same 'module does not match name Main' error
12:23:10 <monochrom> s/includes/imports/  ?
12:23:31 <humasect> correction
12:24:01 <monochrom> It is a compiler bug then.
12:24:23 <humasect> shucks
12:25:12 <allbery_b> hey, you scored your first compiler bug!  isn't that the next stage after writing a monad tutorial?
12:25:14 <allbery_b> :)
12:25:37 <monochrom> that is black humour
12:27:26 <humasect> =)
12:27:50 <Cale> @quote audreyt
12:27:51 <sorear-lambdabot> audreyt says: I think wiki in the original Hawaiian means "I can't find any damned thing"
12:27:53 <Cale> @quote audreyt
12:27:54 <sorear-lambdabot> audreyt says: I think wiki in the original Hawaiian means "I can't find any damned thing"
12:27:58 <Cale> @quote autrijus
12:27:59 <sorear-lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
12:28:01 <Cale> @quote autrijus
12:28:01 <sorear-lambdabot> autrijus says: Mechanical and super-natty! Inspect the result and *if* happy; freeze, sell and get some sleep!
12:28:03 <humasect> i will return with info/workaround and perhaps enough to submit to a/the tracker
12:28:03 <Cale> hmm
12:28:13 <Cale> Not the quotes I was looking for
12:28:16 <Cale> @version
12:28:16 <sorear-lambdabot> lambdabot 4p0, GHC 6.7 (Linux i686 2.00GHz)
12:28:17 <sorear-lambdabot> darcs get
12:28:20 <Cale> errrr
12:28:29 * sorear pokes @seen
12:28:44 <Cale> 4p0?
12:28:49 <sorear> Cale: the 4p0 and 6.7 are both lies
12:29:03 <Cale> hehe
12:29:19 <sorear> Cale: the number after the p is extracted from _darcs, but I don't have a _darcs in my builddir for safety reasons
12:29:35 <Cale> safety reasons?
12:29:50 <Cale> What could happen?
12:29:51 <sorear> Cale: the 6.7 is the version number of `which ghc`, but that doesn't matter because I used -w /usr/bin/ghc-6.6 to configure
12:30:01 <sorear> darcs recording my State/ changes
12:30:05 <Cale> oh
12:30:09 <Cale> okay
12:31:22 <sorear> 4p461
12:31:23 <Korollary> where's dons anyway?
12:31:45 <sorear> @seen dons
12:31:45 <sorear-lambdabot> dons is in #haskell. I don't know when dons last spoke.
12:31:58 <ndm> Korollary: last time i saw him he was going off to catch a plane to go to PADL
12:31:59 <sorear> he hasn't been here for ~24h
12:32:03 <pejo> Isn't it POPL soon, with conferences around it?
12:32:07 <Korollary> ah
12:32:07 <sorear> oh doh
12:32:14 <ndm> pejo: yeah, its a popl side conference
12:32:40 <sorear> never occured to me that dons might have to TRAVEL on the day between Oxford and Nice :)
12:33:12 <pejo> sorear, hm, "When dons moves, time stops"?
12:33:20 <notsmack> @instances Monad
12:33:21 <sorear-lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
12:34:07 <sorear> beware that a few of those have nontrivial contexts
12:34:44 * allbery_b observes that ((->) r) is the source of some of the more unreadable @pl output :)
12:35:07 <sorear> oh. I use (->) r by hand.
12:37:52 * allbery_b isn't quite that 'l33t yet :)
12:38:54 <glguy> I use (->) by hand sparingly
12:38:59 <glguy> actually, I use it a lot at first
12:39:03 <glguy> and then when I read over my code
12:39:08 <glguy> I wonder how anyone else would be able to read it
12:47:28 <yac> can anyone help me with an assignment i have to make ngrams from a string?
12:47:41 <glguy> didn't you get this assignment a long time ago?
12:48:09 <yac> just before xmas break
12:48:15 <glguy> yup
12:48:21 <yac> i only just found out about here
12:48:28 <glguy> your classmates have been through
12:48:33 <yac> lol
12:48:48 <yac> wat did u tell them ;)
12:48:48 <glguy> "ngram" isn't really a universal term, is it?
12:48:55 <glguy> To ask specific questions
12:49:06 <yac> hmm fair point
12:49:38 <yac> right
12:49:51 <glguy> the best way to to try to write something, and when you can't figure it out:
12:49:53 <glguy> lisppaste2: url
12:49:53 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
12:49:59 <xic> Cale: hey... do you remember where that flapjax video was?
12:50:02 <glguy> and the nsee if someone can get you back on track
12:50:14 <kilimanjaro> What's nsee? :)
12:50:23 <yac> i see
12:50:50 <glguy> kilimanjaro: a secret language
12:51:03 <newsham> is it possible to have two modules which are mutual dependant on each other?
12:51:12 <newsham> (if so, how do you avoid import loop?)
12:51:31 <mgsloan> I don't think you can
12:51:40 <mgsloan> compiler people were a bit lazy
12:51:48 <glguy> if they are mutually dependent, they belong in teh same module (might be the logic)
12:51:52 <humasect> i cannot find a workaround for this error ...
12:52:12 <mgsloan> I think SPJ wrote a paper on how to do it, and how it really gunks things up for the compiler :P
12:52:12 <newsham> glguy: works well on paper, but when you're trying to plug something into someone elses code, not always feasible
12:52:25 <ph8> hello yac :)
12:53:04 <yac> hehe hey
12:53:16 <yac> where to start...
12:53:37 <kilimanjaro> It's much easier to perform modular analyses when they aren't mutually recursive
12:54:36 <yac> so i need this function to be of the form
12:54:37 <yac> > ngram :: String -> [[String]]
12:54:46 <kilimanjaro> What is an ngram?
12:55:00 <kilimanjaro> Is this part of glguy's secret language?
12:55:07 <yac> no, its a way of analysing a sentence
12:55:09 <glguy> part of some homework assignment
12:55:29 <glguy> > map (take 2) $ tails $ words "part of some homework assignment"
12:55:33 <psnl> yac: let me guess, dur.ac.uk?
12:55:43 <glguy> ?bot
12:55:43 <sorear-lambdabot> :)
12:55:47 <glguy> ?run map (take 2) $ tails $ words "part of some homework assignment"
12:55:48 <yac> usually :)
12:55:48 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
12:56:07 <yac> wat does that do glguy?
12:56:13 <yac> exactly?
12:56:19 <glguy> it should make the bot evalutate it
12:56:24 <yac> oh
12:56:31 <glguy> Normally we have lambdabot, and lambdabot does amazing things for us
12:56:39 <yac> i see
12:56:42 <glguy> but the great netsplit of (this morning?) took her down
12:57:04 <Heffalump> and now we just have a pale imitation instead?
12:57:05 <yac> ah netsplits, they came and leave nothing in their wake
12:57:20 <glguy> [["part","of"],["of","some"],["some","homework"],["homework","assignment"],["ass
12:57:23 <glguy> ignment"],[]]
12:57:33 * glguy things that those are "ngrams"
12:57:36 <glguy> thinks*
12:57:41 <yac> almost
12:57:43 <paolino> what is a netsplit ?
12:57:54 <yac> the sentence is would come out
12:57:55 <glguy> paolino: when two IRC servers fall in love
12:58:07 <glguy> paolino: sometimes they get together and marry
12:58:09 <glguy> and they join
12:58:13 <glguy> and become
12:58:13 <glguy> one
12:58:24 <glguy> but then the forces of the Internet get too strong
12:58:28 <glguy> and tear them aparrt
12:58:43 <glguy> and the children (us) get stuck in the custody of one of them
12:58:50 <psnl> yac: you seem to have left the homework late
12:58:51 <glguy> its a messy divorce
12:58:56 <kilimanjaro> irc is basically this ghetto distributed protocol and so you actually end up having two separate networks from one just because both sides think that the other is no longer available
12:59:07 <yac> [[part, of], [some], [of, some], [homework], [some, homework], [assignment]
12:59:25 <yac> massively late
12:59:38 <kilimanjaro> Actually, I like glguy's explanation much better than mine
12:59:55 <glguy> and when the IRC networks make up with each other, they share the kids
13:00:00 <glguy> but lambdabot hates this
13:00:04 <psnl> yac: wanting something to generate a list of words?
13:00:05 <monochrom> Sometimes a server runs away with another.
13:00:06 <glguy> and throws a tantrum, and refuses to speak
13:00:21 <yac> more a list of a list of strings
13:00:24 <monochrom> Some servers cheat on their marriage.
13:00:35 <glguy> "man in the middle"
13:00:38 <yac> for example
13:00:38 <glguy> some call it a three way
13:00:48 <emk> > let iterate' f = unfoldr (\x -> Just (x,f x)) = take 5 (iterate' (+) 0)
13:00:48 <sorear-lambdabot>  Parse error
13:01:01 <yac> "the small cat sat"
13:01:04 <yac> comes out
13:01:06 <emk> > let iterate' f = unfoldr (\x -> Just (x,f x)) in take 5 (iterate' (+) 0)
13:01:17 <yac> 	[]            -> [the]
13:01:18 <yac> 	[the]         -> [small]
13:01:18 <yac> 	[the, small]  -> [cat, dog.]
13:01:18 <yac> 	[small, cat]  -> [sat]
13:01:18 <yac> 	[cat, sat]    -> [near]
13:01:26 <centrinia> data ThreeWay = ThreeWay Man Man Woman
13:01:33 <glguy> emk: (+) takes two arguments
13:01:37 <Botje> centrinia: what about Man Woman Woman?
13:01:37 <centrinia> That's a Man in the middle. :)
13:01:43 <Botje> or Woman Woman Woman?
13:01:54 <centrinia> That works. :D
13:02:02 <monochrom> Cat Cat Dog
13:02:05 <emk> glguy: Ah, thanks!
13:02:12 <emk> > let iterate' f = unfoldr (\x -> Just (x,f x)) in take 5 (iterate' (+1) 0)
13:02:13 <glguy> for me, it's mostly : Whatever Man [Woman]
13:02:26 <psnl> yac: do you know ph8?
13:02:33 <yac> yes
13:02:36 <glguy> does he go by ph8 in class?
13:02:50 <psnl> glguy: I dread to imagine
13:02:55 <yac> no he doesnt
13:02:59 <glguy> :-/
13:03:12 <yac> psnl i take it u've done this haskell work?
13:03:17 <k1l4m4nj4r0> err
13:03:35 <glguy> k1l1m4nj4r0: your nick is too leet for me
13:03:43 <psnl> yac: well, I did paul's assignment last year
13:03:52 <glguy> ?. elite slap k1l1m4nj4r0
13:03:52 <sorear-lambdabot> /Me s|Ap$ K1l1M4Nj4R0
13:04:02 <glguy> lambdabot: can't improve on it
13:04:04 <yac> u mean ur 3rd year?
13:04:15 <yac> or taht u finished it before jan 1st?
13:04:22 <psnl> yac: 3rd year
13:04:25 <yac> ah right
13:04:31 <yac> was it hard last year?
13:04:44 <newsham> ?. unpl . elite pl (\x -> 1 + x)
13:04:45 <sorear-lambdabot> (\ a -> 1 + a)
13:04:57 <psnl> I would have prefered to have done this year's, which is more interesting
13:05:00 <k1l1m4nj4r0> glguy: To be honest, I dislike even having to use a nick. I would prefer to just have my name, but through some unfortunate turn of events there have been others before me with that same idea
13:05:27 <yac> all i want to do is pass haskell and never touch it again
13:05:36 <monochrom> hahaha
13:05:51 <glguy> move on to move useful languages like Java?
13:05:53 <monochrom> Haskell is easy to pass.
13:06:21 <monochrom> If you forget everything else, Haskell is easy.
13:06:24 <yac> wat happens after doesnt matter
13:06:27 <kilimanjaro> I'm glad I learned FP through Scheme before Haskell
13:06:56 <monochrom> If you plan to "let me write it in C then translate to Haskell" it's doomed.
13:07:14 <paolino> is haskell taugth in universities ?
13:07:15 <monochrom> The same can be said about "let me write it in English then translate to Chinese".
13:07:15 <kilimanjaro> Haskell has so much stuff going on that it's easy to feel overwhelmed. Scheme has so little that you feel underwhelmed.
13:07:26 <shapr> @elite shapr
13:07:27 <sorear-lambdabot> $|-|4Pr
13:07:28 <humasect> =)
13:07:29 <ph8> it is in ours paolino :)
13:07:31 <yac> i have nothing against the langauage its just not for me
13:07:32 <newsham> ?quote yac all i want to do is pass haskell and never touch it again
13:07:33 <sorear-lambdabot> No quotes for this person. You speak an infinite deal of nothing
13:07:38 <kilimanjaro> paolino: At least in some. I know it is taught at Oxford and UT Austin
13:07:40 <newsham> ?remember yac all i want to do is pass haskell and never touch it again
13:07:41 <sorear-lambdabot> Not enough privileges
13:07:45 <centrinia> I am a math major, Haskell seems more "natural" to me than Scheme.
13:07:46 <Cale> xic: sure
13:08:02 <thedatabase> hello folks.... I have a n00b question or two
13:08:06 <Cale> http://download.microsoft.com/download/9/4/1/94138e2a-d9dc-435a-9240-bcd985bf5bd7/Shriram.wmv
13:08:07 <sorear-lambdabot> http://tinyurl.com/rh7zz
13:08:08 <kilimanjaro> centrinia: I am a math major, and I disagree.
13:08:20 <monochrom> I have nothing against just-pass-and-forget either.  I am suggesting how to pass.
13:08:22 <kilimanjaro> But that's because I learned Scheme before knowing anything but calculus
13:08:26 <xic> Cale: thanks
13:08:29 <centrinia> infiniteDeal = deal : infiniteDeal;
13:08:29 <thedatabase> i'm looking at the randoms function in System.Random
13:08:37 <shapr> yac: Don't you want to be a good programmer?
13:08:42 <newsham> thedb: ask.
13:08:49 <thedatabase> randoms  g      = (\(x,g') -> x : randoms g') (random g)
13:08:55 <thedatabase> what if i were to write:
13:08:57 <Cale> I'm a math major, and I found Haskell meshes better with my way of thinking about computation than almost any other (practical) language out there.
13:09:00 <yac> of course i would shapr
13:09:23 <thedatabase> randoms2 g = let (x,g') = random g in x : randoms2 g'
13:09:34 <psnl> yac: um, do you want a function that takes a list of words and gives all possible phrases?
13:09:37 <Cale> Lazy evaluation by default is huge for me.
13:09:46 <thedatabase> is threading the generator using let inferior in some way to using the lambda?
13:09:54 <humasect> 3 haskell
13:09:58 <Cale> Referential transparency and equational reasoning also
13:09:58 <psnl> yac: and who do you have as project manager for seg?
13:10:19 <yac> my project manager is sarah and stuart
13:10:19 <kilimanjaro> Cale: Right, but for any person, it depends on their background. If I had not been programming since 7th grade I am sure that my opinions would differ.
13:10:32 <sorear> ?remember yac all i want to do is pass haskell and never touch it again
13:10:32 <sorear-lambdabot> Done memoising quote for `yac', if that is their real name...
13:10:41 <shapr> yac: Haskell is likely to give you a great improvement in your programming. The things it teaches probably won't be taught in any other of your classes.
13:10:46 <sorear> how'd remember become a privileged command?
13:10:49 <yac> i see
13:11:02 <Cale> I'd been programming since 4th grade, but I was still not as comfortable with anything as I was with Haskell right off the bat.
13:11:07 <glguy> Haskell is likely to make you hate other programming languages because you'll have to put up with their bullshit...
13:11:13 <sorear> ?list quote
13:11:13 <newsham> thedatabase:   (\x -> x + 1) 5    is very much like   let x = 5 in x + 1
13:11:14 <sorear-lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
13:11:18 <glguy> that's how it feels doing C# at work now
13:11:21 <Cale> glguy: right
13:11:38 <shapr> yac: You'll be able to kick ass, take names, and have lots of time left over for going out to the pub.
13:11:49 <xic> how can i detect if a network Handle has been closed by the other computer?
13:11:53 <Cale> Being in mathematics, I was pretty used to not putting up with any such bullshit at all.
13:12:01 <glguy> it's like doing derivatives with the limit definition in Highschool instead of using the powerrule
13:12:07 <Cale> (So programming was becoming tedious)
13:12:09 <yac> psnl: wat i want to do is make a function that takes a string and uses data.map to map its 1st 2 words to the 3rd
13:12:18 <paolino> mmh, they are going to hate jour java code if you are a haskeller
13:12:26 <yac> then move on to the 2nd and 3rd word and maps it to the 4th
13:12:28 <Cale> Haskell has much less BS than most other languages (It still has some, but it's not so bad)
13:12:35 <kilimanjaro> Where Haskell really saves tedium over scheme is primarily syntax and the extensive, standardized libraries.
13:12:38 <thedatabase> newsham:  thanks....! that's what I hoped.  I have a follow up question....
13:12:49 <Cale> It would be nice if I could write product [1,1..] and have it give 1 :)
13:13:06 <shapr> Where Haskell really saves tedium over C is primarily... I don't think I have enough free time today to finish that statement.
13:13:09 <Cale> (in a way more general than rewrite rules)
13:13:17 <Cale> but I don't really care that much about that
13:13:18 <thedatabase> before reading the System.Random defn of randoms, I naively thought i should use the State monad to thread the state
13:13:33 <Cale> shapr: hehe
13:13:41 <newsham> thedb: not so naive.. thats a reasonable thing to do.
13:13:48 <yac> so for example the sentence "the small cat sat" gives out 	[]            -> [the]
13:13:48 <yac> 	[the]         -> [small]
13:13:48 <yac> 	[the, small]  -> [cat, dog.]
13:13:48 <yac> 	[small, cat]  -> [sat]
13:13:48 <yac> 	[cat, sat]    -> [near]
13:14:03 <shapr> yac: For pastes more than three lines it's polite to use a pastebat.
13:14:05 <shapr> pastebot
13:14:08 <newsham> (you could also use the IO variants in Random which thread the state internally in the IO monad)
13:14:10 <yac> oops sorry
13:14:12 <shapr> @paste
13:14:12 <sorear-lambdabot> http://paste.lisp.org/new/haskell
13:14:19 <kilimanjaro> Cale: Did you know a functional language prior to learning Haskell?
13:14:25 * sorear wields the +5 Pastebat!
13:14:28 <Cale> kilimanjaro: I knew scheme
13:14:29 <glguy> yac: do you have specific questions?
13:14:31 <monochrom> I first use the "words" function to split a string into a list of words.
13:14:32 <centrinia> My first experience with Haskell was pretty pleasant. I made a Fibonacci number generator in less than half an hour, and it ran as concurrent threads because of GHC 6.6. That really got me interested. :)
13:14:34 <thedatabase> newsham:  I got as far as generating a single sample using State, as:
13:14:36 <newsham> thedb: the Random module gives you the primitives so that you can do it in several ways
13:14:37 <kilimanjaro> Cale: How familiar with it were you?
13:14:50 <monochrom> But no one will listen.
13:15:04 <Cale> Reasonably so. I'd taken a course that used it.
13:15:09 <psnl> yac: so you want to take n words, look them up in a map, then add each result to the existing n words.
13:15:18 <Cale> I could probably have written a compiler with it.
13:15:22 <yac> its hard to have a specific question because i know what i need to do just dont know how to get there
13:15:24 <shapr> sorear: scary :-)
13:15:31 <newsham> thedb: this tutorial uses rand as its example for the state monad: http://www.nomaware.com/monads/html/statemonad.html
13:15:31 <Cale> (but I hadn't)
13:15:34 <sorear-lambdabot> Title: The State monad
13:15:40 <shapr> centrinia: cool!
13:15:43 <yac> pretty much psnl
13:15:44 <kilimanjaro> To be honest, I'd rather write a compiler in Haskell
13:15:52 <shapr> @quote compiler
13:15:52 <sorear-lambdabot> lennart says: Even though I'm largely responsible for making CPP available in a Haskell compiler I think it's an abomination.  It should be avoided
13:16:08 <Cale> hehe
13:16:09 <shapr> @quote a compiler
13:16:09 <sorear-lambdabot> No quotes for this person. Take a stress pill and think things over.
13:16:11 <shapr> hmm
13:16:12 <thedatabase> newsham: sorry hope you don't mind if I just paste my code.... I'm actually sampling floats:
13:16:18 <newsham> ?paste
13:16:19 <sorear-lambdabot> http://paste.lisp.org/new/haskell
13:16:23 <newsham> please use the paste site
13:16:26 <sorear> kilimanjaro: you know what John Meacham's learn-haskell program was, right?
13:16:28 <thedatabase> getAny :: Sampleable -> State StdGen Float
13:16:38 <centrinia> shapr, my first Haskell program actually performs on par with most C implementations of Fibonacci generators. :)
13:16:41 <kilimanjaro> sorear: I have no idea
13:16:53 <Cale> The examples in All About Monads suck. It's unfortunate, because the rest of the content is so good.
13:16:55 <monochrom> Sometimes it's a waste of time to help on #haskell because whatever hint or answer I give is washed away by many people preaching to the choir.
13:16:56 <centrinia> But then again, I did use the matrix powering with Strassen multiplication. :D
13:16:59 <sorear> a haskell compiler, jhc
13:17:12 <thedatabase> getAny fn = do { g <- get; (x,g') <- return $ fn g; put g'; return x }
13:17:31 <kilimanjaro> If I could write a Haskell parser, I could write a Haskell compiler :)
13:17:33 <thedatabase> my question is:  how to iterate this?
13:17:45 <sorear> replicateM ?
13:17:46 <ndm_> kilimanjaro: you think you could write a type checker?
13:17:52 <ndm_> kilimanjaro: if so, Yhc needs you!
13:18:02 <sorear> ndm: I've written four
13:18:04 <shapr> centrinia: wow!
13:18:12 <psnl> yac: have you looked at http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html ?
13:18:12 <glguy> thedatabase: x <- return y   is: let x = y
13:18:13 <sorear-lambdabot> http://tinyurl.com/uywvm
13:18:18 <ndm_> sorear, so a fifth wouldn't really be a big deal?
13:18:18 <newsham> thedatabase: there are some generic looping structures that are defined over all monads in Control.Monad
13:18:23 <shapr> Cale: Fix it!
13:18:27 <kilimanjaro> I'd write one in prolog
13:18:47 <Cale> shapr: It's editable?
13:18:48 <kilimanjaro> Actually, I've never written a type checker before
13:18:49 <newsham> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
13:18:49 <shapr> Cale: sigfpe's "You could have invented Monads" has communicated the ideas to several people for which I'd given up hope.
13:18:50 <sorear-lambdabot> http://tinyurl.com/ykyqfl
13:18:57 <shapr> Cale: Sure, ask him.
13:19:09 <shapr> I've swapped emails with the author.
13:19:10 <yac> psnl: i have taken a look at it yes
13:19:38 <glguy> thedatabase: or: do { (x,g') <- gets f; put g'; return x}
13:19:39 <kilimanjaro> Ok, so really what sI should say is that I could write an unoptimizing compiler for a dynamically typed functional language with ease
13:19:52 <glguy> unoptimizing?
13:20:01 <glguy> would that make it intentionally slower?
13:20:02 <Cale> shapr: yeah, we really need some examples and documentation on the *right* way to use monad transformer.
13:20:03 <Cale> s
13:20:07 <newsham> replicateM 10 (getAny id)
13:20:28 <kilimanjaro> glguy: No serious analyses, just a sequence of naive transformations
13:20:29 <psnl> yac: assuming you have built a map with a bunch of words and phrases as keys and the words that come next as values.....
13:20:43 <shapr> Cale: What do you think of sigfpe's monad transformer tut?
13:20:46 <Cale> also, the problem with those examples is mostly that they overuse the Cont monad
13:20:52 <Cale> Oh, I don't think I've seen it.
13:20:54 <kilimanjaro> glguy: I guess I should have said "non-optimizing"
13:21:04 <Cale> Does he newtype everything?
13:21:07 <glguy> kilimanjaro: yeah, I knew what you meant, but I'm bored
13:21:22 <shapr> What's the recent version of cabal? 1.1.6?
13:21:29 * shapr is hacking on the HAppS tutorial
13:21:40 <glguy> shapr: send it my way when you are done
13:21:51 <glguy> shapr: I've used the old tutorial before, but only casually
13:21:58 <psnl> yac: then you can look up the next word, and get a list of new phrases.
13:22:06 <humasect> why is this not working
13:22:09 <centrinia> Has anyone written a DSL before?
13:22:26 <yac> psnl: i think the best way to go about this is: how do make a function that takes a string (a sentence) looks at the 1st 3 words, maps the 1st 2 words to a the 3rd. Then it does the whole process on the same sentence minus the 1st word
13:23:01 <thedatabase> newsham: ahhh --- thanks very much!  This is very helpful
13:23:15 * sorear is off to remove the dependency of @run on hs-plugins
13:23:21 <thedatabase> I was having fits trying to crowbar 'iterate' inside my do block
13:23:23 <Cale> shapr: If it's this one: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html, that's a fine description, but it doesn't really show how they ought to be used.
13:23:24 <sorear-lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
13:23:35 <shapr> glguy, bakert: I'm throwing bits online, feel free to critique - http://www.haskell.org/haskellwiki/HAppS_Tutorial
13:23:37 <sorear-lambdabot> Title: HAppS Tutorial - HaskellWiki
13:23:55 <newsham> thedb: you could also write your own, ie:  foreverM_ act = do {act; foreverM_ act}
13:23:55 <shapr> Cale: Extend/fix!
13:23:57 * sorear misread 'critique' as 'cringe'
13:23:57 <Cale> I should take one of the comments I wrote on reddit and turn it into a short tutorial on using monad transformers.
13:23:58 <sjanssen> sorear: GHC API instead?
13:24:15 <shapr> sorear: heh, you can cringe if you really feel like it =)
13:24:16 <sorear> sjanssen: KISS.  ghc -e
13:24:21 <monochrom> I want to advise psnl that Fresco's question is a bit unclear.
13:24:36 <Fresco> hmm it is a bit dense
13:24:39 <sjanssen> sorear: oh, good call :)
13:24:53 <newsham> iterateM act = do { x <- act; xs <- iterateM act; return (x : xs) }
13:24:54 <sorear> besides, it's quite easy to force ghc to segfault, and we wouldn't want lambdabot to die too. :(
13:25:05 <fridim> is there some simple haskell applications I could look to learn ?
13:25:07 <psnl> yac: um, I think (based on a quick read of the assignment ages ago) that you are supposed to have a two stage thing. one stage should read in tons of data and build a map of phases to next words.. and the second pharse should make valid sentances from them and a few starting words.
13:25:59 <thedatabase> newsham:  excellent.... locating/writing the 'fnM' version to use fn inside a do block:  seems like I've been missing a fairly major piece of the puzzle!  thanks again...
13:26:04 <Fresco> ok sounds about right
13:26:20 <pejo> ndm, doesn't yhc have a typechecker already?
13:26:49 <Fresco> maybe i'm going about it wrong
13:26:58 <sjanssen> sorear: this is a problem: ghc -e 'Foreign.unsafePerformIO (print 10)'
13:27:32 <sorear> sjanssen: I plan on regexing out *unsafe*
13:27:39 <newsham> thedb: its really cool realizing that you can write your own control flow constructs
13:27:42 <Fresco> psnl: thats basically it
13:27:43 <sorear> sjanssen: that way, I can allow ST :)
13:28:02 <shapr> fridim: Are you just starting with Haskell?
13:28:15 <sjanssen> sorear: ST could be allowed in the current design, import Control.Monad.ST hiding (unsafeIOToST)
13:28:35 <glguy> iterateM m x = do { x' <- m x; xs' <- iterateM m x'; return (x':xs') }
13:29:03 <fridim> shapr, i've done some tutorials
13:31:01 <shapr> fridim: What would you like to do next? Do you have any specific sort of application you want to write?
13:31:17 <fridim> yes
13:31:27 <fridim> In fact I would like to write a tar clone in haskell
13:31:31 <shapr> oh cool
13:31:42 <shapr> You should check out Bulat Ziganshin's compression and stream libraries.
13:32:18 <fridim> I've started it in C (for training) using the Huffman code
13:32:37 <shapr> Have you tried to write a Huffman coder in Haskell?
13:32:41 <fridim> But I guess it would be much easier in haskell
13:32:47 <sjanssen> fridim: I think there was some hacking on a tar clone at the Hackathon
13:32:48 <fridim> not yet.
13:32:50 <shapr> Some parts easier, some parts harder :-)
13:33:05 <velco> yay for huffman coders in haskell
13:33:15 <shapr> For me, the huffman code would be the fun part.
13:33:33 <shapr> fridim: Have you tried #haskell.fr?
13:33:42 <sjanssen> huff is a fun algorithm
13:33:45 <newsham> glguy: oops, I guess I meant repeatM
13:34:21 <sjanssen> http://user.it.uu.se/~pergu/huffman.hs is my fairly speedy implementation
13:34:36 <sjanssen> for huffman decoding
13:35:02 <fasta> Is anyone familiar with a .stat file as produced by GHC?
13:36:07 <shapr> Those are the profiling outputs?
13:36:16 <fasta> Or more concrete: what does INIT, MUT, RP and EXIT mean exactly?
13:36:19 <fasta> shapr: yes
13:36:34 <thedatabase> newsham: I'm sure it will be cool!  Thanks for getting me 1 step closer..... sigfpe's tutorial was great, but this is definitely a major block I can put in place now...
13:37:03 <newsham> glad I could assist
13:38:17 <conal> Hi all.  There's a lively thread on cabal-dev: http://www.haskell.org/pipermail/cabal-devel/2007-January/thread.html ("Why is there a cabal file at all").  It's probably of wider interest than the cabal-dev subscribers, as it addresses safety & DSELs.
13:38:18 <sorear-lambdabot> Title: The cabal-devel January 2007 Archive by thread, http://tinyurl.com/yn9gx3
13:38:18 <thedatabase> thanks glguy also --- just saw your iterateM (was busy stuffing my face with omelette and beans); very instructive....
13:38:21 <humasect> what do i do about my module issues? am i doing something wrong? is --make not recommended for projects with many files ?
13:39:34 <sjanssen> humasect: what are your module issues?
13:39:48 <humasect> <no location info>: file name does not match module name `Main'
13:40:08 <ndm_> conal: yes, i've seen it ;)
13:40:19 <humasect> Main.hs is ... module Main where  ... import Something ... that's it
13:40:19 <conal> hi neil!
13:40:35 <ndm_> conal: i agree with you that if a .cabal file flows towards turing complete, Haskell would be hte only sensible choice
13:40:41 <fasta> shapr: ?
13:40:53 <sorear> humasect: some other module is missing a module header
13:40:54 <sjanssen> humasect: and you're running ghc --make Main?
13:40:56 <ndm_> but i hope that it will never come even close to that
13:41:12 <humasect> sor: checked, all are perfect (didn't have this error some hours ago)
13:41:16 <humasect> sjanssen: yep
13:41:17 <Fresco> if i wanted to take a String and make a list first 3, would 'x = take 3 words x' work fine?
13:41:31 <Botje> Fresco: take 3 (words x)
13:41:34 <Botje> or take 3 $ words x
13:41:36 <sorear> I hope that some sort of usable taint mechanism is developed, so that unsafePerformIO can be banned.
13:41:41 <Fresco> ok right thanks
13:41:49 <ndm_> sorear, it would be easy in Yhc...
13:41:50 <conal> ndm_: it could also get more complex than Haskell without being Turing complete. I hope it doesn't get to that!
13:41:50 <sjanssen> humasect: that should work.  You must have something strange going on
13:41:52 <psnl> > take 3 $ words "my dog has no nose"
13:42:02 <psnl> oh damn, no lambdabot
13:42:08 <sorear> @bot
13:42:09 <sorear-lambdabot> :)
13:42:15 <ndm_> conal: agreed, if it stays simple a .cabal file is best, if it doesn't then a custom DSL is best
13:42:15 <Fresco> but say i wanted to do this again but not including the 1 word of string?
13:42:17 <sorear> it just doesn't have runplugs.
13:42:19 <Cale> haha, that's awesome, hugs is the first hit on google for hugs
13:42:20 <humasect> sjanssen: i've tried everything i could think of , even commenting all code
13:42:32 <complaisant> anyone knows how to make GHCi work with wxhaskell in a macosx system? .. how can i include the package wx in the packets ghci imports ?
13:42:32 <ndm_> conal: so i guess the question is how complex will cabal files get...
13:42:32 <complaisant> ghc-6.6: unknown package: wx
13:42:32 <conal> sorear: usafePerformIO all about getting around the taint mechanism called "IO".
13:42:35 <ndm_> Cale: are you logged in?
13:42:51 <ndm_> Cale: google searches now personalise themself based on yoru past searches etc.
13:43:05 <Cale> ndm_: ah, even logged out it seems to be the case though
13:43:12 <ndm_> @google hugs
13:43:13 <sorear-lambdabot> http://www.haskell.org/hugs/
13:43:13 <sorear-lambdabot> Title: Hugs 98
13:43:20 <sorear> @google happy
13:43:21 <ndm_> Cale: indeed it is, wow!
13:43:21 <sorear-lambdabot> http://happytreefriends.atomfilms.com/
13:43:21 <sorear-lambdabot> Title: Happy Tree Friends
13:43:33 <sorear> well, a month ago, Happy was #5
13:43:41 <fasta> What does INIT, MUT, RP and EXIT mean exactly in a .stat file?
13:43:42 * allbery_b 's last build of wxzhaskell on osx / ghc6.6 resulted in virtuedesktops crashing and a program that exited immediately
13:43:49 <ndm_> @google hoogle
13:43:50 <sorear-lambdabot> http://haskell.org/hoogle/
13:43:50 <shapr> fasta: I don't remember, but I've seen a mailing list thread by Simon Marlow describing those.
13:43:50 <sorear-lambdabot> Title: Hoogle
13:43:51 <complaisant> @yahoo haskell
13:43:51 <sorear-lambdabot> Unknown command, try @list
13:44:11 <Fresco> but if i want to recursively go thru the string and take 3 of its words but each time dropping the starting word?? how would i go about it then?
13:44:13 <ndm_> when i first wrote hoogle, the number 1 result for Hoogle was a bondage site
13:44:19 <Cale> Does hugs support newtype-deriving? (I'm lazy)
13:44:27 <conal> ndm_: or slightly different: how much complexity is inherent in the problem domain?
13:44:27 <sjanssen> Cale: I don't think so
13:44:27 <shapr> Fresco: Do you know how to do that for just a boring list?
13:44:31 <Cale> okay
13:44:32 <complaisant> allbery_b : lol
13:44:44 <humasect> must i try cvs ghc ?
13:44:49 <conal> ndm_: (since they could stay simple by fiat, at the cost of dissatisfied users)
13:44:52 <Fresco> shapr: not really no
13:44:53 <allbery_b> (that was with the app fixer)
13:44:54 <sorear> cvs ghc is massively obsolete
13:44:58 <humasect> *darcs
13:45:07 <ndm_> conal: i guess those two questions are the same, but also how much complexity is in 99.9% of the problem - since not everyone has to use cabal
13:45:07 <complaisant> ?paste
13:45:07 <sorear-lambdabot> http://paste.lisp.org/new/haskell
13:45:20 <sjanssen> humasect: you've got to be making some simple mistake
13:46:08 <humasect> sjanssen: i can't see where it is, i know that ghc checkout would replace <no location info> with a filename. not like that is a huge gain
13:46:12 <humasect> there are only 4 files
13:46:20 <Fresco> shapr: but i can understand how that might be similar
13:46:48 <conal> ndm_: and the question is broader than Cabal for me.  Cabal is a symptom.
13:47:02 <sorear> humasect: one of your files has no 'module' line, or the 'module' line isn't the first
13:47:08 <ndm_> conal: how do you mean? you mean you want safe DSL's in general?
13:47:26 <conal> ndm_: yes.
13:47:48 <humasect> sorear: ok i've just isolated to load in ghci, i get the same error. the first code line is 'module Name where'
13:47:49 <seliopou> :t ask
13:47:51 <sorear-lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
13:47:53 <seliopou> @hoogle ask
13:47:54 <sorear-lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:47:54 <sorear-lambdabot> Control.Monad.Reader.asks :: MonadReader r m => (r -> a) -> m a
13:47:54 <sorear-lambdabot> Distribution.Extension.TemplateHaskell :: Extension
13:47:56 <shapr> Fresco: If you can do that to a list, you can then figure out how to turn your inputs into the right kind of list, and you're done!
13:47:59 <conal> Haskell is so close to being a safe as well as fun & useful language.  and then we throw it away! :(
13:48:09 <psnl> Fresco: split it into two tasks... dropping the first word, taking the next three
13:48:17 <sjanssen> conal: throw it away how?
13:48:36 <sorear> I propose to provide a compiler option that disables unsafePerformIO, array, accumArray, unsafeCoerce#, etc..
13:48:37 <ndm_> conal: really, Yhc can give that all back to you with maybe 3 or 4 days hacking
13:48:41 <fasta> ndm_: you also don't know the meanings of the abbreviations in a .stat file?
13:48:47 <Fresco> ok, can drop the 1st word with 'tail' right?
13:48:56 <psnl> aye
13:48:59 <ndm_> fasta: nope, but if you give me the abbrevs there is a chance i might know some
13:49:05 <fasta> What does INIT, MUT, RP and EXIT mean exactly in a .stat file?
13:49:07 <sjanssen> sorear: array and accumArray should be fixed rather than tossed
13:49:19 <conal> sjanssen: by allowing in unsafe operations and not having a simple bullet-proof way to regain safety where it's important.
13:49:20 <psnl> Fresco: or drop ;-)
13:49:21 <sorear> yeah, like that'll ever happen :(
13:49:32 <ndm_> sorear, why not a runtime flag rather than a compile time flag - otherwise things like stale .hi's etc can go bad
13:49:32 * fasta can't imagine he is the first one using it with >200 people in the channel
13:49:32 <Fresco> ok
13:49:44 <fasta> @lusers
13:49:44 <sorear-lambdabot> Maximum users seen in #haskell: 295, currently: 293 (99.3%), active: 44 (15.0%)
13:49:59 <ndm_> fasta: no idea, i can guess at init and exit, but not hte exact semantics
13:50:03 <conal> sorear: sure.  that's a start.  and transitively (won't link with unsafely compiled modules)
13:50:04 * allbery_b has no idea what a .stat file is
13:50:10 <fasta> ndm_: yes, I can guess too. Thanks
13:50:27 <ndm_> conal: you still need unsafePerformIO etc, you just need to disallow unsafe operations within unsafePerformIO etc.
13:50:29 <sorear> ndm: see Data.ByteString ... every unsafePerformIO would need a conditional
13:50:30 <Cale> sjanssen: someone ought to implement it, it's probably one of the most valuable extensions with respect to the amount of work that's likely required to implement it.
13:50:52 <conal> ndm_: for example?
13:51:11 <sjanssen> Cale: I agree
13:51:14 <ndm_> conal: Data.ByteString, lots of unsafePerformIO which is safe, mutable variables etc.
13:51:38 <conal> ndm_: how do you know it's safe?
13:51:40 <humasect> okay, i think i have found the problem
13:51:47 <Fresco> how about "take 3 $ tail $ words n"   ?????
13:52:04 <allbery_b> :t tail
13:52:06 <sorear-lambdabot> forall a. [a] -> [a]
13:52:24 <Botje> Fresco: what of it?
13:52:32 <conal> ndm_: for instance, could someone pull a buffer overflow attack?
13:52:34 <ndm_> conal: readIORef etc is always safe, readFile/writeFile is not, unless you are doing it from a disk location you have "permission" on
13:52:38 <psnl> Fresco: would work
13:52:44 <humasect> one can use ghc -i<dir> but only 1-level deep. this is the "bug"
13:52:51 <ndm_> conal: no, not with Yhc, possibly suitably hardened - but thats not much work
13:52:56 <Fresco> ok, but how i recursively do it till the end of the list?
13:52:57 <sorear> ideally, we would make it so that system libraries can use unsafePerformIO freely
13:52:58 <humasect> if it is more than one level then module names are not correct
13:52:58 <lisppaste2> complaisant pasted "wxHaskell" at http://paste.lisp.org/display/35179
13:53:01 <sjanssen> ndm_: readIORef is not always safe
13:53:07 <complaisant> help
13:53:11 <ndm_> sjanssen: with the type bug?
13:53:14 <conal> ndm_: i think i see what you mean.   safe like java.
13:53:19 <ndm_> conal: exactly
13:53:27 <sjanssen> ndm_: right.  You can define unsafeCoerce with it
13:53:37 <sorear> readIORef is not referentially transparent.
13:53:38 <sjanssen> well, I suppose readIORef is safe
13:53:47 <ndm_> sjanssen: yes, but unsafeCoerce is actually safe, as long as your compiler is segfault free with unsafeCoerce's
13:53:48 <sjanssen> it's newIORef that is unsafe
13:54:06 <sjanssen> ndm_: I think that is an unrealistic expectation
13:54:07 <conal> ndm_: i guess so.  though maybe we could do even better.  (while java couldn't).  using something like runST or proof-carrying code.
13:54:12 <ndm_> sjanssen: and Yhc is safe in that manner, so it doesn't matter - you can allow arbitrary unsafeCoerce
13:54:16 <sorear> ndm_: what use do you have for unsafePerformIO . readIORef ?
13:54:31 <psnl> Fresco: do you want to split the list up into four word blocks?
13:54:40 <ndm_> conal: that requires you remove unsafeCoerce and unsafePerformIO etc.
13:54:59 <sorear> Parametricity has already given us ST and shortcut deforestation, I don't want to lose any functional properties
13:55:02 <Fresco> 3 word blocks
13:55:02 <ndm_> sorear, i don't, but i am using unsafePerformIO today, as it happens (all over the place), but only when reading to an already open handle so its safe
13:55:11 <sjanssen> ndm_: I'd really prefer that my compiler doesn't have to check a type tag for every constructor inspection
13:55:20 <sorear> reading to an open handle? huh?
13:55:51 <Fresco> in a string: take the 1st 3 words: then drop the 1st word of the string and take the next 3 until the end
13:55:52 <sjanssen> ndm_: by safe do you mean "free from segfaults", or "referentially transparent"?
13:56:05 <ndm_> sjanssen: it can do crazy things, but not unsafe - free from segfaults and bad IO style interaction
13:56:22 <ndm_> sjanssen: but crazy = consume time and memory, computer garbage - not delete files etc
13:56:32 <Botje> Fresco: let w = words string in zipWith someFunction w (drop 1 w) (drop 2 w)
13:56:36 <conal> one perspective on unsafePerformIO is that it's there for what we haven't yet figured out how type-check the programs we want.  an example of figuring out how to is runST.
13:56:41 <ndm_> sorear: reading from an open handle, but using unsafePerofrmIO to do it
13:56:44 <Botje> where someFunction takes three separate words as input
13:56:48 <Botje> and does something with it
13:56:52 <sorear> yow!
13:56:56 <ndm_> conal: my code i've been writing today would not benefit from types
13:56:57 <psnl> Fresco: so ["a" "b" "c" "d" "e" "f" "g"] becomes [[b,c,d], [d,e,f]] ?
13:57:00 <sjanssen> ndm_: so referentially transparent is not part of your definition of safe
13:57:05 <conal> ndm_: yeah?
13:57:18 <Fresco> yes
13:57:19 <humasect> not fiex
13:57:20 <ndm_> sorear, http://www.cs.york.ac.uk/fp/darcs/binarydefer/Data/Binary/Defer.hs - lots of unsafePerformIO
13:57:21 <sorear-lambdabot> http://tinyurl.com/y23jxr
13:57:23 <conal> ndm_: think of type-checking as proof-checking.
13:57:25 <Fresco> psnl: yes
13:57:35 <Fresco> but ther is also an [a,b,c] block
13:57:42 <Fresco> to start with
13:57:44 <sorear> ndm_: why don't you use unsafeInterleaveIO?
13:57:48 <ndm_> conal: that above link as well, it uses unsafePerformIO to get operational semantics, not denotational semantics
13:57:49 <conal> ndm_: maybe types would help, but you don't know what types to use.
13:57:53 <ndm_> sorear, that seems way too hard
13:57:56 <ndm_> conal: no, they can't
13:58:24 <sjanssen> ndm_: it looks like most of those unsafePerformIO's could be unsafeInterleaveIO
13:59:01 <ndm_> sjanssen: i suspect so too, but i definately no what unsafePerformIO does...
13:59:09 <psnl> Fresco: why not write a function that splits a list into a list of four element lists?
13:59:25 <sjanssen> ndm_: unsafeInterleaveIO isn't tricky
13:59:31 <conal> ndm_: i maybe be saying something simpler that you think.  here's my argument.  if you're sure your code is safe, then you can prove it, and if you have a powerful enough type system, then you proof can be expressed and type-checked.  Those are the types i mean.
13:59:35 <sorear> @src unsafeInterleaveIO
13:59:35 <sorear-lambdabot> unsafeInterleaveIO (IO m)
13:59:36 <sorear-lambdabot>   = IO ( \ s -> let
13:59:36 <sorear-lambdabot>            r = case m s of (# _, res #) -> res
13:59:36 <sorear-lambdabot>         in (# s, r #))
13:59:47 <sjanssen> I'm pretty sure that it's defined as "unsafeInterleaveIO m = return (unsafePerformIO m)"
13:59:55 <sorear> it's not that complicated
14:00:00 <Fresco> psnl: why 4 elements??
14:00:13 <psnl> three elements
14:00:13 <sorear> ndm: unsafeInterleaveIO is potentially faster
14:00:15 <sjanssen> ndm: is that a darcs repo?  I'll send you a patch if you'd like :)
14:00:15 <ndm_> conal: but the problem is i can prove the code safe, just not with the operational semantics i want...
14:00:20 * psnl is mildly drunk
14:00:24 <Fresco> oh
14:00:30 <ndm_> sorear, i may try and work that in once i've got it finished
14:00:39 <sorear> ndm: unsafePerformIO is marked {-#NOINLINE#-}, unsafeInterleaveIO is {-#INLINE#-}
14:00:43 <conal> ndm_: i'd like to hear more.
14:00:51 <Fresco> psnl: i dont really get wat u mean
14:00:57 <ndm_> conal: i want to defer reading of data until later
14:01:06 <sorear> ndm_: make formal operational semantics!  Improve the type system!
14:01:32 <ndm_> conal: but the type system doesn't deal with ordering and timings, its a denotational semantics, doesn't deal with details like order/memory etc
14:01:37 <ndm_> sorear, that sounds like fun...
14:01:49 <conal> ndm_: i think i'm getting it.  the one wired in evaluation strategy (call-by-need) isn't working out for you.  right?
14:01:49 <norpan> operational semantics would be a good thing for haskell
14:01:55 <psnl> Fresco: would it help to have a function to split things into groups of three?
14:02:06 <ndm_> conal: in principle you could, but you need to take Hsakell's type system in directions no one else wants it to go in
14:02:30 <ndm_> conal: yes, pretty much - call-by-need + IO monad which is serialisation of actions in order
14:02:53 <conal> ndm_: maybe they would want to if you wrote up your example clearly, found related examples, and proposed an elegant general solution.
14:02:58 <Fresco> psnl: possibly and then make another function that uses it?
14:03:05 <sorear> ndm: load the whole file page-lazily, then use pure decoding?
14:03:08 <conal> ndm_: not necessarily all by yourself!
14:03:14 <psnl> Fresco: yeah
14:03:15 <sorear> e.g foreign import "mmap"
14:03:24 <sorear> mmap uses load-by-need
14:03:35 <ndm> sorear, i guess mmap might work, but has no cacheing
14:03:40 <sorear> mmap is uber-cool
14:03:42 <Fresco> i'll give it a go psnl
14:03:43 <sorear> ndm: !?
14:04:12 <ndm> sorear, can you walk over a mmap buffer purely?
14:04:13 <conal> ndm: i already sold on wanting to extend the range of evaluation strategies, as a general problem.  Ditto for garbage collection, which i see as dual to evaluation.
14:04:16 <sorear> on MY computer, all executeables are mmaped.  all libraries, too.  libc *is* cached.
14:04:37 <ndm> conal: i'm not, I like the H98 type system - forall seems overkill to me
14:04:40 <sorear> ndm: yes, sure - coerce it to an IArray
14:04:54 <ndm> unsafePerformIO seems simpler...
14:05:06 <sorear> that's the dark side talking
14:05:06 <dons> ?yow!
14:05:06 <sorear-lambdabot> Couldn't find fortune file
14:05:10 * dons waves from Nice
14:05:11 <sorear> dons: hi
14:05:13 <conal> ndm: there's an irony though.  you want simple types and then you want to use unsafePerformIO to get around typing.
14:05:19 <conal> dons: hi!
14:05:21 * ndm waves back from York
14:05:35 <dons> its warm in Nice and sunny :)
14:05:36 * conal waves from Seattle
14:05:37 <dons> well, it was
14:05:43 <sjanssen> dons: did you see my note on the binary/Integer issue?
14:05:47 <conal> conal: it's snowing here.  pretty!
14:05:50 <dons> sjanssen: haven't seen it yet
14:05:51 <ndm> conal: not type checking, the code is all in the IO monad - i want to get around serialisation of IO
14:05:51 <dons> just got online
14:05:55 * allbery_b waves from Pittsburgh
14:05:57 <conal> (i just said that to myself!)
14:06:00 <dons> sjanssen: summary?
14:06:03 <ndm> dons: i also did the deriving stuff you suggested using SYB
14:06:14 <dons> oh!
14:06:15 <sjanssen> dons: the Integer instance is architecture portable
14:06:16 * waern waves from Gothenburg
14:06:20 <sorear> dons: are you aware that current lambdabot doesn't typecheck?
14:06:21 <dons> sjanssen: it is?
14:06:27 <dons> sorear: hmm no?
14:06:29 <sjanssen> s/is/isn't
14:06:40 <dons> sjanssen: ah right. yes, I suspect as much
14:06:47 <sorear> dons: no. binary-0.2 uses Either ParseError a, lambdabot wants a.
14:07:01 <dons> ah , we tweaked that
14:07:12 <conal> ndm: by getting around typing, i just mean using IO a as if it were a.
14:07:12 <sorear> I've fixed it (and sent), hopefully I didn't create doppelganger patches
14:07:13 <dons> yes, Lemmih added the ParseError stuff
14:07:27 <sorear> I've also found the netsplit bug
14:07:29 <ndm> conal: partly, but thats not the actual reason
14:07:32 <dons> oh good!
14:07:41 <sorear> tell was down so I used email :)
14:08:07 <conal> ndm: it's not your motivation.  it's the spin i put on your solution.
14:08:19 <sorear> I think the netsplit bug is a bug in the base package.  A documentation bug at the very least.
14:08:21 <conal> ndm: which, i gather, you don't like.
14:08:33 <sorear> "Do not ever killThread a thread blocked in waitQSem"
14:08:46 <ndm> conal: i'm just saying that haskell's type stuff is a million miles off expressing what i want - you'd need one more like Hume
14:09:06 <ndm> but that unsafePerformIO and unsafeCoerce aren't unsafe, and Yhc could still be safe and allow them happily
14:09:19 <conal> ndm: gotcha.  thanks.
14:09:26 <conal> (looking up Hume)
14:09:52 <fasta> What does "scavenged" and "not scavenged" means in garbage collection?
14:10:07 <ndm> embedded functional language, can express operational semantics in types - like time bounds etc
14:10:10 * conal wishes he'd thought to use /me like the cool kids do.
14:10:22 <sorear> fasta: it has to do with incremental GC
14:11:17 <therp> doesn't scavenged mean that it's garbage collected=its memory is freed=disposed.
14:11:26 <therp> I don't see any connection to incremental GC
14:12:27 <sorear> in incremental gc, objects can be traced, untraced, or freed.  in monolithic gc objects can be live or freed.
14:12:48 <conal> ndm: how about a note to the haskell list saying something about Hume, like "shucks, i thought haskell's type system was pretty great, but we can't do what Hume can do.  here's an example....  Can anyone think of a way to do that in Haskell or some variant of Haskell?"
14:13:16 <Philippa> conal: some things it really /can't/ do
14:13:24 * sorear reads a scroll of Summon Oleg
14:13:33 <conal> Philippa: which can't?
14:13:46 <conal> sorear: good call.
14:14:00 <conal> put out some Oleg bait
14:14:03 * ndm thinks even Oleg can't encode operational properties in the type system
14:14:09 <Philippa> conal: Haskell's type system
14:14:21 <Philippa> it's a bit hard when the language doesn't specify them
14:14:34 <xic> Philippa: do you know anything about Network?
14:14:45 <conal> Philippa: gotcha.
14:14:56 <Philippa> I don't think you can encode linearity either without effectively building an interpreter
14:14:58 <sorear> someday, I will write a 386 emulator in the type system, thereby proving that Haskell's type system can encode everything GHC can do.
14:15:11 <Philippa> xic: The module? I've probably forgotten most of what I've known
14:15:32 <xic> Philippa: do you know how to detect if a network Handle has been closed by the client?
14:16:15 <conal> ndm/Philippa: so invisibility of operational semantics is perhaps the core issue here.
14:16:16 <sorear> xic: you read, and see if you get an exception
14:16:49 <ndm> conal: its a choice, and i think its a good one
14:17:06 <conal> ndm: invisibility is?
14:17:08 <xic> sorear: yeah, but i want to be notified immediately when the disconnect happens, i don't want to have to wait until i read/write
14:17:15 <newsham> xic: not sure in hsakell, but in standard unix apis, a closed handle will select for reading, but will return zero bytes when read on the read side.  on the write side, writes will result in SIGPIPE being delivered to the process
14:17:25 <Philippa> conal: it's generally advisable most of the time
14:17:33 <ndm> conal: that the operational semantics of haskell are abstracted out in most of hte language
14:17:41 <ndm> (apart from MR which is just ugly)
14:17:54 <conal> Philippa: most of the time.
14:17:59 <sorear> xic: if at any time you're not reading, it's probably a bug in your code.
14:18:17 <conal> ndm: and yet it pinches sometimes, doesn't it.
14:18:38 <sorear> xic: what if the server sends a message?  nasty lag
14:18:43 <monochrom> if the client has closed: hGetChar, hGetLine, hWaitForInput throws EOF exception; hGetBuf and hGetBufNonBlocking returns 0.
14:18:45 <Philippa> I'd go so far as to say that operational awareness belongs in something not unakin to the IO monad
14:18:49 <conal> ndm: i'm assuming you mind using unsafe* like i do, but maybe a false assumption.
14:18:54 <xic> sorear: "nasty lag" is intentional
14:18:55 <ndm> conal: no, we have special backdoors exactly for this purpose occasionally
14:19:03 <monochrom> I just experimented them to death a few days ago.
14:19:10 <ndm> conal: i don't mind using it, as long as the interface is referentially transparent and its hidden away
14:19:19 <ndm> i.e. the user should not be able to tell you used unsafePerformIO
14:19:45 <xic> monochrom: those won't work for me... i need to somehow be notified about a disconnection, without having to explicitly read/write
14:20:20 <monochrom> hWaitForInput is a suitable choice.
14:20:21 <conal> ndm: that's my goal also when i use it.  but then we get arguments like the one about Cabal.
14:20:30 <newsham> xic: why?
14:20:39 <emk> What are the good choices for Haskell query languages?
14:20:47 <emk> I need to store a lot of data and analyze it.
14:21:15 <newsham> xic: dont think the unix socket apis allow that..  they provide the data as a stream and you dont get close notification until you hit th eend of the stream
14:21:21 <conal> Philippa: and then use unsafe* or not?
14:21:21 <xic> newsham: the client connects to my server. now the server needs to do a monster calculation and return the result to the client. but i want to abort the calculation if the connection is closed in the middle
14:21:37 <conal> Philippa: (something akin to unsafe*)
14:22:00 <sorear> xic: still, you should be reading
14:22:05 <newsham> xic: I assume your code for reading requests is in a separate thread for performing the long calculation?
14:22:19 <newsham> if so, then just start reading the next request and if it gets EOF, cancel the current request
14:22:19 <sorear> network programming involves concurrency
14:22:22 <xic> newsham: yes
14:22:29 <xic> newsham: i mean no
14:22:38 <Philippa> conal: and then go back to the type system having inserted the info in the first place. Slight problem: in this case, return is your fiend
14:22:47 <newsham> if you dont have a separate thread, then how do you anticipate stopping the current computation?
14:23:12 <xic> newsham: that's my problem
14:23:12 <monochrom> Method A.  The calculation polls hWaitForInput or hReady once in a while.
14:23:20 <newsham> seems like the simple answer is to separate out the request loop from the computation thread
14:24:05 <monochrom> Method B.  A second thread waits indefinitely for hWaitForInput.  If get EOF exception then kill the calculation thread.
14:24:08 <mattam> conal: what's the Cabal argument ?
14:24:12 <conal> Philippa: i don't get your meaning.  inserted which info?
14:24:41 <conal> mattam: the thread "Why is there a Cabal file at all?" on cabal-dev, archived here: http://www.haskell.org/pipermail/cabal-devel/2007-January/thread.html
14:24:42 <sorear-lambdabot> Title: The cabal-devel January 2007 Archive by thread, http://tinyurl.com/yn9gx3
14:25:09 <sorear> @ask dons how vehemently would you oppose > 2 + 2 using ghci rather than runplugs?
14:25:09 <sorear-lambdabot> Consider it noted.
14:25:13 <xic> monochrom: hm...
14:25:16 <xic> monochrom: hReady?
14:25:35 <monochrom> Have you read System.IO lately?
14:25:49 <conal> sorear: you're running your own lambdabot?
14:26:12 <dons> sorear: I'd oppose it a *lot*
14:26:12 <sorear-lambdabot> dons: You have 1 new message. '/msg sorear-lambdabot @messages' to read it.
14:26:13 <xic> monochrom: thanks, i'll give hReady a shot
14:26:13 <sorear> conal: sorear-lambdabot is mine.
14:26:34 <dons> sorear: since that's about 10 exploitable holes right there if you do that
14:26:53 <monochrom> ?src System.IO.hReady
14:26:53 <sorear-lambdabot> Source not found. You type like i drive.
14:27:04 <monochrom> ?src hReady
14:27:04 <sorear-lambdabot> Source not found. I feel much better now.
14:27:10 <newsham> dons: then we will have access to sorear's box
14:27:11 <Philippa> conal: the aim is to make the type system operationally-aware, right? The main problem in which is getting operational info into the type system in the first place
14:27:14 <monochrom> hReady h 	=  hWaitForInput h 0
14:27:21 <conal> sorear: an additional lambdabot?  is dons's dead?
14:27:29 <newsham> ?seen lambdabot
14:27:30 <sorear-lambdabot> lambdabot is in #haskell. I don't know when lambdabot last spoke.
14:27:33 <Philippa> conal: as once we've got it there, recombining it as we build up functions is already doable
14:28:03 <conal> Philippa:  thanks.  now i'm following you.
14:28:22 <sorear> @quit
14:28:53 <dons> i'll apply the patches in the morning. time for bed!
14:28:55 <dons> night all
14:29:12 <newsham> wow dons, i thought you were up early
14:29:17 <newsham> guess you are just up late
14:29:23 <sorear> @localtime dcoutts
14:29:25 <lambdabot> Local time for dcoutts is Sat Jan 13 22:26:47
14:29:25 <dons> i'm in .fr
14:29:26 * psnl wonders if the two lambdabots will fight
14:29:30 <newsham> ah, i see
14:29:34 <sorear> dons is in dcoutts's zone
14:29:36 <conal> night dons
14:29:40 <newsham> bon soir
14:29:45 <dons> bon soir!
14:29:48 * dons departs
14:30:03 <shapr> g'nite dons
14:30:13 <dcoutts__> yeah, g'night folk
14:31:42 <ph8> ?t splitter
14:31:42 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
14:32:25 <conal> dcoutts__: g'night
14:37:06 <conal> does anyone know how to persuade haddock to create web references to other libraries (base, etc) rather than local libraries?  i'm getting ready to release some libraries, but the haddock docs are full of links to my local file system.
14:37:33 <Heffalump> I'm fairly sure it has options to do this, but I've never used them.
14:39:40 <newsham> xic: one thing you should be aware of -- its possible to half-close a socket.
14:39:51 <newsham> ie. i can connect to your server, send a requestion, close the sending side, then read the response.
14:40:00 <newsham> s/requestion/request/
14:40:32 <sorear> which should not be confused with the fact that hGetContents will semi-close a socket...
14:40:33 <Fresco> psnl: i've made a function that takes the 1st 3 words of a string
14:41:00 <xic> newsham: is this haskell or specific, or sockets in general?
14:41:12 <Fresco> but now i need to make a function that takes the same string but continually drops the 1st word?
14:41:26 <Botje> 22:54 < Botje> Fresco: let w = words string in zipWith someFunction w (drop 1 w) (drop 2 w)
14:41:43 <Fresco> oooooooooo
14:41:46 <Botje> 22:54 < Botje> where someFunction takes three separate words as input
14:41:47 <Fresco> sorry didnt see
14:42:21 <newsham> xic: thats a BSD socket API thing (and a TCP thing)
14:42:33 <Botje> > let w = words "foo bar baz qux quux quuux blort" in zipWith (\x y z->x++y++z) w (drop 1 w) (drop 2 w)
14:42:34 <lambdabot>      The function `zipWith' is applied to four arguments,
14:42:35 <lambdabot>     but its type `(...
14:42:43 <newsham> see man 2 shutdown
14:42:48 <Botje> ehm
14:42:51 <Botje> gorramit
14:43:03 <Botje> > let w = words "foo bar baz qux quux quuux blort" in zipWith3 (\x y z->x++y++z) w (drop 1 w) (drop 2 w)
14:43:04 <Saizan> zipWith3?
14:43:05 <lambdabot>  ["foobarbaz","barbazqux","bazquxquux","quxquuxquuux","quuxquuuxblort"]
14:44:19 <xic> newsham: is it because the data sits in some OS buffer waiting to be read by the program?
14:44:45 <newsham> no, its because TCP lets you mark the end of file in both directions with a "FIN", independantly.
14:44:50 <Fresco> > function1 n = let w = words n zipWith splitter n w (drop 1 w) (drop 2 w)
14:44:51 <lambdabot>  Parse error
14:45:03 <Fresco> botje you mean like taht?
14:45:12 <Botje> Fresco: yeah, except you use zipWith3 instead of zipWith
14:45:15 <Botje> as Saizan pointed out
14:45:23 <Fresco> where splitter gives out 3 separate words
14:45:27 <Fresco> ok cool
14:45:36 <Botje> Fresco: and you missed an "in" somewhere
14:45:48 <newsham> xic: thikn of a socket sort of like a pair of one-way communication channels that are bundled together
14:45:48 <Botje> and actually, the words already splits it for you..
14:45:57 <newsham> each channel can EOF independantly
14:46:05 <newsham> err..  s/socket/TCP connection/
14:46:10 <Botje> splitter will already receive three separate words as input
14:46:22 <Fresco> oh ok
14:46:24 <newsham> its not like a phone line where their both active or both closed
14:47:33 <newsham> xic: here's another option, if you can modify the protocol, add a new NOP message type from server to client.  have your server periodically send a NOP message to the client and se that to detect if the client closes down
14:47:47 <xic> newsham: no can do, protocol is http
14:47:50 <newsham> (if you dont control the protocol than obviously that isnt an option)
14:49:04 <Fresco> ooo almost right
14:49:17 <newsham> i thikn there is a way to detect if the write side closed down without writing.. trying to remember the details.
14:49:20 <Fresco> thanks botje
14:49:26 <Botje> Fresco: you're welcome :)
14:49:46 <Botje> (you can replace drop 1 w with tail w, but it's more uniform this way)
14:49:52 <newsham> hmm.. no actually I dont think there's gonna be an easy way to do that.
14:50:07 <ndm> Botje: they have different semantics!
14:50:10 <ndm> > drop 1 []
14:50:11 <xic> newsham: what happens when the "stop" button is pressed on the browser, it probably closes both sides, right?
14:50:12 <lambdabot>  Add a type signature
14:50:15 <ndm> > drop 1 ""
14:50:16 <lambdabot>  ""
14:50:21 <ndm> > tail []
14:50:22 <lambdabot>  Add a type signature
14:50:26 <Fresco> k
14:50:26 <ndm> > tail ""
14:50:28 <lambdabot>  Exception: Prelude.tail: empty list
14:50:38 <Botje> well, yeah.
14:50:38 <newsham> xic: not sure.
14:50:47 <Botje> "assuming the input contains at least two words"
14:50:49 <seliopou> @src drop
14:50:49 <lambdabot> drop n xs     | n <= 0 =  xs
14:50:49 <lambdabot> drop _ []              =  []
14:50:49 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
14:50:59 <Botje> which is the whole point of processing it
14:51:33 <ndm> Botje: fair enough, i used to have a Dr Haskell rule drop 1 => tail, before realising...
14:51:55 <newsham> xic: familiar with the ethereal network monitor?  www.ethereal.com.  you could run tests in your browser and watch.
14:52:08 <xic> newsham: is it free?
14:52:11 <newsham> yup
14:52:15 <Fresco> botje: if i were wanting to take each one of those strings in the list, is it possible to use Data.Map to make the 1st 2 words to the 3rd?
14:52:28 <Fresco> *map not make
14:52:49 <Botje> Fresco: sure
14:52:51 <newsham> (just beware, observed behavior might not be universal :)
14:52:59 <Botje> map accepts pairs as keys too
14:53:05 <Fresco> if u see what i mean
14:53:14 <Fresco> ah right
14:53:33 <Fresco> so i would make a new function that uses the one just made?
14:54:15 <seliopou> @instances functor
14:54:16 <lambdabot> Couldn't find class `functor'. Try @instances-importing
14:54:28 <newsham> xic: I think they renamed it recently to this: http://www.wireshark.org/
14:54:29 <lambdabot> Title: Wireshark: The World's Most Popular Network Protocol Analyzer
14:55:02 <sjanssen> seliopou: capitalization is important
14:55:29 <newsham> ?src [] fmap
14:55:29 <lambdabot> fmap = map
14:55:35 <newsham> ?src Maybe fmap
14:55:36 <lambdabot> fmap _ Nothing       = Nothing
14:55:36 <lambdabot> fmap f (Just a)      = Just (f a)
14:55:50 <newsham> ?type fmap
14:55:52 <seliopou> sjanssen: Seems a bit silly
14:55:52 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
14:56:22 <sjanssen> seliopou: well, if you write "functor" in your Haskell program, it won't work
14:56:43 <newsham> > 'i' == 'I'
14:56:44 <lambdabot>  False
14:57:10 <Botje> Fresco: you can use zip3 too, that just returns a list of triplets
14:57:12 <sjanssen> but yes, lambdabot could uppercase the class name automatically.  I'd say that's reasonable
14:57:20 <Botje> which you can then use in eg a foldr, to populate the map
14:57:32 <Fresco> ok, i'll try to see if helps
14:58:30 <Fresco> hmmm zipWith3 is better
14:59:46 <newsham> anyone awake that is familiar with lambdabot src?
15:00:02 <seliopou> :t join fmap
15:00:03 <lambdabot> forall b. (b -> b) -> b -> b
15:00:18 <seliopou> > join fmap (+1) 1
15:00:19 <lambdabot>  3
15:00:29 <Fresco> i'm not entirely sure how to use Data.Map, is it just function i can use anywhere or do i have to say it in the signature taht i need a map?
15:00:33 <seliopou> > join fmap (^2) 2
15:00:34 <lambdabot>  16
15:00:39 <Fresco> *functions
15:00:51 <sjanssen> newsham: what's your question?
15:01:09 <newsham> sjanssen: I have an IO action that takes IO callbacks as arguments.
15:01:26 <psnl> Fresco: you have to import it, then you just have a pile of functions that give you maps or take maps as arguments or whatever
15:01:27 <Botje> Fresco: import qualified Data.Map as M
15:01:49 <newsham> so something like:  do { ioCb <- lbIO (\cont -> cont cb); io $ func ioCb }
15:01:57 <Fresco> yeah i've been given what i need to import
15:02:08 <newsham> sjanssen: which is valid, except my cb takes parameters.
15:02:10 <Botje> the way you usually use a Map is start with an empty one, then add elements
15:02:16 <Botje> folds are ideal for this
15:02:28 <Fresco> ah right
15:02:32 <newsham> and I dont understand how to use lbIO with something that will be taking more parameters when called back
15:02:33 <seliopou> @hoogle lift
15:02:34 <lambdabot> Control.Monad.Trans.lift :: (MonadTrans t, Monad m) => m a -> t m a
15:02:34 <lambdabot> Text.ParserCombinators.ReadPrec.lift :: ReadP a -> ReadPrec a
15:02:34 <lambdabot> Language.Haskell.TH.Syntax.lift :: Lift t => t -> Q Exp
15:02:50 <newsham> sjanssen: if thats not very clear, I can provide concrete code
15:04:58 <newsham> > M.insert "life" 42 M.empty
15:05:00 <lambdabot>  {"life":=42}
15:06:06 <norpan> null and empty should go into a class i think
15:06:20 <newsham> > M.insert "life" 42 M.empty M.\\ M.fromList [("this", 1), ("that", 2)]
15:06:22 <lambdabot>  {"life":=42}
15:07:18 <newsham> > M.insert "life" 42 M.empty `M.union` M.fromList [("this", 1), ("that", 2)]
15:07:20 <lambdabot>  {"life":=42,"that":=2,"this":=1}
15:07:30 <Fresco> botje: to write a function that maps the values in each of the strings of the list would this signature suffice
15:07:31 <Fresco> > mapize :: [String] -> map
15:07:32 <lambdabot>   Not in scope: `mapize'
15:07:38 <newsham> > (M.insert "life" 42 M.empty `M.union` M.fromList [("this", 1), ("that", 2)]) ! "life"
15:07:39 <lambdabot>  Couldn't match `Array i e' against `Data.Map.Map [Char] a'
15:07:46 <newsham> > (M.insert "life" 42 M.empty `M.union` M.fromList [("this", 1), ("that", 2)]) M.! "life"
15:07:48 <lambdabot>  42
15:08:25 <Botje> Fresco: yes
15:08:31 <Fresco> yay
15:09:37 <Fresco> you have to start off with an empty one then begin adding values?
15:10:16 <newsham> you dont have to, you can use M.fromList for example
15:10:21 <allbery_b> :t M.fromList
15:10:23 <lambdabot> Couldn't find qualified module.
15:10:27 <allbery_b> oh well
15:10:30 <newsham> but starting with an empty map is a reasonable approach
15:10:33 <allbery_b> :t Data.Map.fromList
15:10:35 <lambdabot> forall a k. (Ord k) => [(k, a)] -> Data.Map.Map k a
15:10:49 <newsham> > M.fromList [("this", 1), ("that", 2)]
15:10:49 <Fresco> k ta
15:10:51 <lambdabot>  {"that":=2,"this":=1}
15:11:14 <shapr> bakert: Hey, have you had a chance to look at the HAppS tutorial?
15:11:15 <newsham> > M.fromList [("this", 1), ("that", 2)] M.! "this"
15:11:17 <lambdabot>  1
15:12:07 <Saizan> shapr: has recently changed?
15:12:27 <Saizan> s/has/has it/
15:12:55 <newsham> > M.fromList (zip (words "this is a test") [1..]) M.! 2
15:12:55 <shapr> Saizan: Yeah, I'm changing it now - http://www.haskell.org/haskellwiki/HAppS_Tutorial
15:12:56 <lambdabot> Title: HAppS Tutorial - HaskellWiki
15:12:57 <lambdabot>   add an instance declaration for (Num String)
15:14:28 <newsham> > (M.fromList (zip (words "this is a test") [1..])) M.! "test"
15:14:30 <lambdabot>  4
15:14:42 <bakert> shapr, no where is it?
15:14:48 <shapr> bakert: http://www.haskell.org/haskellwiki/HAppS_Tutorial
15:14:49 <lambdabot> Title: HAppS Tutorial - HaskellWiki
15:15:15 <bakert> shapr, cool.  will give it a once over.
15:15:25 <shapr> Thanks, I know it's not done, but I look forward to your feedback.
15:16:55 <Fresco> :e
15:16:59 <Fresco> oops
15:17:44 <shapr> Fresco: :eeeek!
15:17:49 <Fresco> ??
15:18:05 <shapr> I was just making up new ghci commands :-)
15:18:23 <Fresco> hehe
15:21:48 <rjs> Does Haskell have a function or operator like LISPs "apply" function?
15:23:02 <newsham> > ($) (+ 1) 2
15:23:04 <lambdabot>  3
15:23:07 <newsham> like that?
15:23:21 <rjs> I think that might be it
15:23:24 <rjs> thanks
15:23:42 <newsham> its not really needed...  you get application for free
15:23:45 <newsham> > (+ 1) 2
15:23:46 <lambdabot>  3
15:24:14 <rjs> > $ + [1, 2]
15:24:15 <lambdabot>  Parse error
15:24:23 <rjs> dang :-)
15:24:29 <vincenz> that will never owrk
15:24:30 <vincenz> ever
15:24:31 <newsham> you want to take a function and a list and take the arguments from the list and ues them as parameters?
15:24:48 <newsham> > let plus [a, b] = a + b in plus [1, 2]
15:24:49 <lambdabot>  3
15:25:20 <newsham> > let binApply f [a, b] = f a b in binApply (+) [1, 2]
15:25:21 <lambdabot>  3
15:25:31 <newsham> something like that?
15:26:11 <trane> what is the 'in' for
15:26:16 <newsham> (are you sure you need to take args from a list?  perhaps its your lisp experience making you try something lispish)
15:26:22 <rjs> probably
15:26:23 <newsham> let <binding> in <expr>
15:26:31 <trane> ah
15:27:12 <rjs> I have two Strings args I want to convert to Int, then apply an Int -> Int -> Int function to the result
15:27:38 <rjs> so I thought I'd map read over a list of the String arguments
15:28:01 <rjs> but I'm guessing there's a more Haskellish way to do this?
15:28:15 <newsham> > let binStrOp f a b = f (read a) (read b) in binStrOp (+) "1" "5"
15:28:17 <lambdabot>  6
15:28:45 <Fresco> mapise n = n.fromList [(take 2 n), (tail n)]
15:29:13 <Fresco> taht isnt correct use of fromList is it??
15:29:43 <newsham> rjs: you could use   let [a,b] = map read args   I suppose, but map seems like overkill for 2 args
15:29:55 <vincenz> Fresco: what is "n."
15:30:14 <Fresco> n is a [string] its wat is passed into the function
15:30:22 <vincenz> Fresco: so why is it "n.fromList"?
15:30:27 <vincenz> it should be "Map.fromList"
15:30:31 <vincenz> if you included the Data.Map module as Map
15:30:34 <Fresco> hmm feck
15:30:35 <vincenz> erm, imported
15:30:37 <Fresco> yeah i did
15:30:44 <vincenz> import qualified Data.Map as Map?
15:30:51 <newsham> > let binOp f [a,b] = f (read a) (read b) in binOp (+) ["1", "2"]
15:30:53 <lambdabot>  3
15:31:07 <vincenz> @type mapise n = Map.fromList [(take 2 n), (tail n)]
15:31:09 <lambdabot> parse error on input `='
15:31:16 <vincenz> @type let mapise n = Map.fromList [(take 2 n), (tail n)] in mapise
15:31:18 <lambdabot> Couldn't find qualified module.
15:31:20 <Fresco> i did it like import Data.Map(Map, toList, empty, insertWith, findWithDefault, showTree, fromList)
15:31:32 <vincenz> Fresco: then you don't need the "n." bit
15:31:35 <vincenz> Fresco: either way, it won't work
15:31:41 <Fresco> i see
15:31:47 <vincenz> the type of fromList is [(k,a)] -> Map k a
15:31:50 <vincenz> so you need a list of tuples
15:32:01 <vincenz> you have apparently a list of lists
15:32:04 <vincenz> specifically, a list of two lists
15:32:13 <vincenz> tuples are not interchangeable with lists
15:32:16 <vincenz> they are distinct types
15:32:19 <Fresco> i see
15:32:21 <newsham> or perhaps:   > let binOp f args = let [a,b] = map read args in f a b in binOp (+) ["1", "2"]
15:32:30 <vincenz> tuples are heterogeneous but fixed size, lists are homogeneous but non-fixed size
15:33:02 <vincenz> in fact you have many different tuple types
15:33:08 <vincenz> @type ('a', 1.1)
15:33:08 <rjs> I suppose I could just use let ... in ... for just two arguments
15:33:10 <lambdabot> forall b. (Fractional b) => (Char, b)
15:33:32 <Fresco> i have a list of strings (each string has 3 words). I'm trying to take each element of the list in turn and map the 1st 2 words onto the 3rd
15:33:32 <vincenz> Fresco: I hope that helped a bit
15:33:44 <Fresco> yeah i have a little better understanding
15:33:49 <newsham> you might want to define   binOp f args = error "just two args"     as an alternate case.
15:33:50 <vincenz> Fresco: ok
15:33:56 <vincenz> Fresco: so step 1: get the words from the string
15:34:03 <vincenz> Fresco: imagine some functoin that does
15:34:10 <vincenz> [String] -> [(String, String, String)]
15:34:11 <Fresco> well i have a fucntion alrady
15:34:12 <vincenz> that seems to be step one
15:34:19 <Fresco> liek this
15:34:34 <Fresco> let w = words n in zipWith3 (\x y z->x++" "++y++" "++z) w (drop 1 w) (drop 2 w)
15:34:44 <Fresco> where n = the string
15:34:49 * vincenz nods
15:34:53 <vincenz> Fresco: there is an easier way
15:34:56 <Fresco> ?
15:34:59 <vincenz> wait
15:35:01 <vincenz> what does this do?
15:35:02 <Fresco> k
15:35:04 <vincenz> this makes strings again
15:35:10 <Fresco> eg
15:35:19 <Fresco> let w = words "hello my name is fresco" in zipWith3 (\x y z->x++" "++y++" "++z) w (drop 1 w) (drop 2 w)
15:35:20 <vincenz> > let [a,b,c] = words n in (a,b,c)
15:35:21 <lambdabot>   Not in scope: `n'
15:35:38 <vincenz> > let foo n = let [a,b,c] = words n in (a,b,c) in foo "abc def ghi"
15:35:40 <lambdabot>  ("abc","def","ghi")
15:36:02 <vincenz> I'm assumiing each string has -exactly- 3 words
15:36:14 <Fresco> its not quite wat i'm trying to do
15:36:24 <vincenz> then you might have to explain more clearly :/
15:36:25 <Fresco> one sec
15:36:27 <emk> Wow. foldr is really powerful...
15:36:56 <newsham> emk: as powerful as a loop with an accumulator
15:37:30 <newsham> v = init; for x in xs { v = f(v, x); } return v
15:37:38 <emk> newsham: More so, because it has a bunch of useful mathematical identities over compound expressions.
15:37:42 <Fresco> the string you enter (eg "w1 w2 w3 w4 w5") will come out ["w1 w2 w3", "w2 w3 w4", "w3 w4 w5"]
15:37:53 <vincenz> oh
15:37:54 <vincenz> ok
15:38:02 <emk> It turns the actual recursion/iteration into a black box.
15:38:08 <Fresco> now i want to map w1 w2 to w3
15:38:09 <vincenz> Fresco: but why remake a string
15:38:16 <Fresco> and the same for the others
15:38:29 <vincenz> and your func doesn't dow hat you want
15:38:34 <vincenz> I assume you want to keep going with this moving window
15:38:41 <vincenz> @type scanl
15:38:43 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
15:38:55 <Fresco> moving window?
15:38:59 <vincenz> Fresco: well
15:39:06 <Botje> map (take 3) $ tails $ words s
15:39:11 <vincenz> ["w1 w2 w3", .....,"w10 w11 w12"
15:39:18 <vincenz> and so forth
15:39:25 <Botje> but that kind of sucks for the end, bleh.
15:39:28 <Fresco> yes
15:39:43 <vincenz> Botje: nah, just add a filter
15:39:59 <vincenz> Fresco: why do you remake them into a string just to unwords them after?
15:40:01 <vincenz> seems inefficient
15:40:06 <vincenz> just keep it as a [[String]]
15:40:11 <vincenz> aka a list of 3-element lists
15:40:23 <Fresco> alright
15:40:29 <vincenz> then you can do
15:40:52 <Fresco> so i need to change the 1st function to output [[string]]?
15:41:03 <vincenz> > concatMap (\[a,b,c] -> [(a,c), (b,c)]) $ [["w1", "w2", "w3"],["w2","w3","w4"]]
15:41:05 <lambdabot>  [("w1","w3"),("w2","w3"),("w2","w4"),("w3","w4")]
15:41:19 <vincenz> and then map.FromList
15:41:22 <vincenz> Map.fromList
15:41:26 <vincenz> or in your case, fromList
15:42:32 <Fresco> hmmm
15:42:37 <Fresco> the thing is
15:43:00 <Fresco> i need to map the first 2 words to the 3rd in each slot
15:43:18 <vincenz> Fresco: that's what I did
15:43:51 <vincenz> w1->w3, w2->w3
15:44:27 <Fresco> yeah but it needs to be more w1 and w2 together map to w3
15:44:31 <Fresco> not separately
15:44:46 <vincenz> define "together"
15:44:53 <Botje> (w1,w2)->w3
15:44:57 <Fresco> yes
15:44:59 <vincenz> Botje: let him speak
15:45:13 <vincenz> > map (\[a,b,c] -> [((a,b),c)]) $ [["w1", "w2", "w3"],["w2","w3","w4"]]
15:45:14 <lambdabot>  [[(("w1","w2"),"w3")],[(("w2","w3"),"w4")]]
15:45:19 <vincenz> > map (\[a,b,c] -> ((a,b),c)) $ [["w1", "w2", "w3"],["w2","w3","w4"]]
15:45:21 <lambdabot>  [(("w1","w2"),"w3"),(("w2","w3"),"w4")]
15:45:28 <Fresco> so if you looked up w3 you would get (w1, w2)
15:45:32 <vincenz> @quote vincens homework
15:45:33 <lambdabot> No quotes for this person. It can only be attributed to human error.
15:45:36 <vincenz> @quote vincenz homework
15:45:37 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
15:45:58 <Fresco> i'm not giving you my homework
15:46:09 <Fresco> theres 1 bit of it i cant do
15:46:12 <vincenz> Fresco: the second function does what I want
15:46:14 <Botje> @pl -> \[a,b]->(a,b)
15:46:14 <lambdabot> (line 1, column 1):
15:46:15 <lambdabot> unexpected "-"
15:46:15 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
15:46:15 <vincenz> er
15:46:16 <vincenz> you want
15:46:19 <Botje> @pl \[a,b]->(a,b)
15:46:19 <lambdabot> (line 1, column 2):
15:46:20 <Saizan> > let w = words "hello my name is fresco" in M.fromList $ concat $ zipWith3 (\a b c -> [(a,b), c] ) w (drop 1 w) (drop 2 w) -- you can skip the 3-lenght-list construction
15:46:20 <lambdabot> unexpected "["
15:46:20 <lambdabot> expecting pattern
15:46:21 <lambdabot>  Couldn't match `(String, String)' against `String'
15:46:30 <Botje> @pl \[a,b] -> (a,b)
15:46:31 <lambdabot> (line 1, column 2):
15:46:31 <lambdabot> unexpected "["
15:46:31 <lambdabot> expecting pattern
15:46:33 <vincenz> Saizan: wrong type
15:46:42 <Saizan> > let w = words "hello my name is fresco" in M.fromList $ concat $ zipWith3 (\a b c -> [((a,b), c)] ) w (drop 1 w) (drop 2 w)
15:46:44 <lambdabot>  {("hello","my"):="name",("my","name"):="is",("name","is"):="fresco"}
15:46:49 <Botje> @pl's parser just sucks .. got it
15:46:49 <lambdabot> (line 1, column 19):
15:46:50 <lambdabot> unexpected "."
15:46:50 <lambdabot> expecting variable, "(", operator or end of input
15:46:54 <bd_> @pl \l -> if length l /= 2 then error "bad input" else ((l !! 0), (l !! 1))
15:46:55 <vincenz> Saizan: remove the list and concat
15:46:55 <lambdabot> ap (flip if' (error "bad input") . (2 /=) . length) (liftM2 (,) (!! 0) (!! 1))
15:47:05 <Fresco> omg saizan
15:47:16 <bd_> Botje: pattern matching can be difficult to pointlessify
15:47:27 <vincenz> > let w = words "hello my name is fresco" in M.fromList $ zipWith3 (\a b c -> (((a,b), c)) ) w (drop 1 w) (drop 2 w)
15:47:29 <bd_> in general it can't be done actually, but many builtin types support it
15:47:29 <lambdabot>  {("hello","my"):="name",("my","name"):="is",("name","is"):="fresco"}
15:47:29 <Fresco> its exactly like that!
15:47:35 <vincenz> Fresco: that's what I just showed you
15:47:39 <Fresco> oh
15:47:41 <vincenz> Fresco: after you had pieced the different pieces together
15:47:43 <Saizan> vincez: ah sure, it was needed with (a,c),(b,c) :)
15:47:52 <vincenz> Saizan: notice my second solution ;)
15:48:25 <Saizan> yeah :)
15:48:26 <newsham> vincenz stole my homework
15:48:51 <Fresco> thanks very much
15:49:20 <Fresco> saizan, vincenz and botje - that was the one bit that was really killing me in this project
15:49:24 <Fresco> thanks you
15:49:57 <rjs> How do you use read in a let ... in statement to get it to output the correct type?  I found "read str::Type" somewhere in the documentation, but in my program it seems to leave the Strings as Strings.
15:50:21 <Heffalump> can you give a slightly longer example of your problem?
15:50:24 <Saizan> <Fresco> so if you looked up w3 you would get (w1, w2) <-- this worries me a bit, the kay of the Map should be (w1,w2) or w3?
15:50:37 <Saizan> s/kay/key/
15:50:42 <rjs> let base = read baseStr:: Double
15:50:50 <rjs>      height = read heightStr ::Double
15:50:56 <rjs> in areaTriangle base height
15:51:13 <Heffalump> and what's the type of areaTriangle?
15:51:22 <rjs> Double -> Double -> Double
15:51:31 <rjs> the compiler complains that base and height are typed [Char]
15:51:33 <Heffalump> you're sure? (it has an explicit type signature?)
15:51:37 <rjs> yes
15:51:44 <Fresco> no its as you had it first
15:51:47 <Heffalump> I don't think you should need the :: Double either, then.
15:52:04 <Fresco> i was flipping it around to make it clear that w1 and w2 come together
15:52:17 <Saizan> oh ok
15:52:23 <Heffalump> can you put enough of your code so that I can reproduce this in a pastebin?
15:52:44 <rjs> uhm, should I just copy and paste it here?
15:52:55 <Botje> @paste
15:52:55 <lambdabot> http://paste.lisp.org/new/haskell
15:54:35 <lisppaste2> rjs pasted "read problem" at http://paste.lisp.org/display/35193
15:55:24 <Fresco> nn all thanks for your help
15:55:59 <Saizan> rjs: you need a show to convert Double to String
15:56:00 <Botje> > read "1234\n" :: Int
15:56:02 <lambdabot>  1234
15:56:20 <Botje> > read "1234\n" :: Double
15:56:22 <lambdabot>  1234.0
15:56:35 <Heffalump> rjs: what Saizan said :-) Your inputs are fine, it's complaining about your output.
15:57:06 <rjs> oh, the output of areaTriangle has to be converted back to string
15:57:08 <rjs> d'oh
15:57:12 <Heffalump> you need to read the error message more carefully. "Expected type" is referring to what the context wants, i.e. here the (++) needs a String as its second argument (because in turn its own result is passed to putStrLn)
15:57:26 <Heffalump> "Inferred type" is referring to what the expression itself seems to be.
15:59:49 <rjs> thanks all
16:00:13 <Saizan> > read "    4  \n  " ::Int -- didn't know that read skips whitespaces
16:00:14 <lambdabot>  4
16:01:17 <bd_> Saizan: it's technically a proper haskell expression parser... provided you only use constructors. That's the idea anyway.
16:04:00 <Saizan> bd_: ah, very much like lisp
16:05:16 <bd_> Yes, but, this won't work:
16:05:20 <bd_> > read "4 + 4" :: Int
16:05:22 <lambdabot>  Exception: Prelude.read: no parse
16:05:27 <bd_> unfortunately :)
16:05:59 <jmorrison> You can probably get quite far using GADT constructors
16:06:00 <sjanssen> bd_: fortunately, I'd say
16:06:21 <bd_> Well, I suppose allowing nontermination in such things might have interesting results :)
16:06:22 <allbery_b> you might want to look at reads instead
16:06:23 <sjanssen> I'd rather read doesn't do runtime evaluation
16:06:27 <allbery_b> reads "4 + 4" :: Int
16:06:33 <allbery_b> > reads "4 + 4" :: Int
16:06:34 <lambdabot>  Couldn't match `Int' against `[(a, String)]'
16:06:40 <bd_> > reads "4 + 4" :: [(Int, String)]
16:06:42 <lambdabot>  [(4," + 4")]
16:06:46 <allbery_b> > reads "4 + 4" :: [(Int,String)]
16:06:48 <lambdabot>  [(4," + 4")]
16:06:56 <allbery_b> feh
16:07:00 <bd_> > reads "44" :: [(Int, String)]
16:07:02 <lambdabot>  [(44,"")]
16:07:06 <bd_> > reads "4 4" :: [(Int, String)]
16:07:07 <lambdabot>  [(4," 4")]
16:07:10 <bd_> ic
16:07:38 <allbery_b> it returns a list because sometimes there can be ambiguous parses; it returns all the possible parses so you can decide which to take
16:09:09 <Saizan> > reads "44 " :: [(Int, String)] -- is this enough ambiguos?
16:09:11 <lambdabot>  [(44," ")]
16:09:21 <Saizan> no :D
16:11:14 * allbery_b doesn't know what an ambiguous parse would be, actually
16:11:52 * allbery_b jsut quoting documentation
16:13:36 <newsham> allberry: E -> E + E; E -> number.   then   1 + 2 + 3 has ambiguous parses
16:13:49 <newsham> because it could be (1 + 2) + 3   or 1 + (2 + 3)
16:14:29 <sjanssen> newsham: can you think of any examples in existing Read instances?
16:14:43 <newsham> i'm not well versed in Read.  i just know the basics
16:14:49 <Saizan> mmh
16:14:52 <newsham> sorear: thanks for help.  got stuff compiling.
16:15:16 <Saizan> well with nested Either and without parens?
16:16:30 <Saizan> > reads "Right Right Left 1"
16:16:31 <lambdabot>  Add a type signature
16:17:21 <sjanssen> Saizan: the parens are required, I think
16:17:59 <Saizan> sjanssen: right
16:18:24 <bd_> > reads "Right Right Left 1" :: Either () (Either () (Either () Int))
16:18:25 <lambdabot>  Couldn't match `Either () (Either () (Either () Int))' against `[(a, String)]'
16:18:34 <bd_> > reads "Right Right Left 1" :: [(Either () (Either () (Either () Int)), String)]
16:18:36 <lambdabot>  []
16:19:18 <Saizan> > reads "Right Right Right 1" :: [(Either () (Either () (Either () Int)), String)]
16:19:20 <lambdabot>  []
16:20:04 <bd_> > reads "Right (Right (Left 1))" :: [(Either () (Either () (Either () Int)), String)]
16:20:06 <lambdabot>  []
16:20:26 <bd_> > show (Right (Right (Left 1)) :: Either () (Either () (Either
16:20:26 <lambdabot>  Parse error
16:20:26 <bd_>              () Int))
16:20:28 <bd_> er
16:20:33 <bd_> > show (Right (Right (Left 1)) :: Either () (Either () (Either () Int))
16:20:33 <lambdabot>  Parse error
16:20:39 <bd_> > show (Right (Right (Left 1))) :: Either () (Either () (Either () Int))
16:20:40 <lambdabot>  Couldn't match `Either () (Either () (Either () Int))' against `String'
16:21:32 <malebria> show (Right (Right (Left 1)) :: Either () (Either () (Either () Int)))
16:21:36 <malebria> > show (Right (Right (Left 1)) :: Either () (Either () (Either () Int)))
16:21:36 <bd_> > reads "Right Right Left 1" :: Either () (Either () (Either Int Int))
16:21:37 <lambdabot>   add an instance declaration for (Num ())
16:21:37 <lambdabot>  Couldn't match `Either () (Either () (Either Int Int))' against `[(a, String)]'
16:21:41 <Saizan> > reads "(Right (Right (Right 1)))" :: [(Either () (Either () (Either () Int)), String)]
16:21:43 <lambdabot>  [(Right (Right (Right 1)),"")]
16:22:02 <bd_> > reads "Right Right Left 1" :: [(Either () (Either () (Either Int Int)), String)]
16:22:04 <lambdabot>  []
16:22:33 * sjanssen reminds everyone of /msg lambdabot
16:23:01 * sorear hates ircii's keyboard support
16:24:55 <newsham> sorear: go irssi?
16:25:30 * sorear probably will...
16:26:05 <Svrog> how do all the different ffi preprocessors compare?
16:26:21 <Svrog> there's half a dozen of them - having a hard time deciding what to use heh
16:26:43 <sorear> they don't all compare
16:26:56 <Svrog> what do you mean?
16:27:08 <sorear> H/DIRECT won't do any good if you're trying to bind curses
16:27:19 <Svrog> oh
16:27:26 <sorear> (not that you need to bind curses, Stefan Wehr's done it already)
16:28:51 <Svrog> well im mostly after some easy way to handle c structs from haskell code - if it wasnt for that id just declare a few foreign imports and thats it
16:30:28 <Svrog> im tempted try hsc2hs just cause it comes with ghc unlike the others
16:30:28 <mauke> the only one I've used is hsc2hs
16:31:41 <sorear> I haven't used any, but my needs so far have been very limited, accessing ioctl(TIOCGWINSZ).
16:31:54 <Svrog> fair enough
16:36:55 <newsham> same, i've been just raw ffi so far.
16:37:35 <Svrog> same here - but i havent had to access c structs from haskell before - not sure how to go about that with raw ffi
16:37:57 <Svrog> or at least i can't think of a clean way to do it
16:38:11 <newsham> sorear: what is  (command msg) supposed to look like in LMain.received?  (String)
16:41:17 <newsham> oh, blah, I see..
16:42:30 <sorear> a lot of the code esp. in Base really belongs in IRC.
16:42:36 <newsham> *nod*
16:42:42 <newsham> I can accomodate.. I just thought it menat sometihng else
16:45:40 <jmorrison> Anyone here familiar with OOP design, Java style?
16:46:13 <jmorrison> Question: how do you design differently in Haskell?
16:48:34 <Svrog> that question is a bit vague - could you be more specific?
16:49:20 <emk> jmorrison: Haskell is very strong at what a Java developer would think of as "generics" (and a C++ programmer as "templates"), but weak at polymorphism.
16:49:51 <Saizan> emk: weak? think of typeclasses
16:50:09 <pejo> emk, f x = x, that's a pretty polymorphic function to me.
16:50:19 <Svrog> yeah, i wouldn't say haskell is weak at polymorphism
16:50:20 <jmorrison> Svrog: Well, when I'm doing Java, I'm thinking of pieces and connecting data flows, but from what i've seen so far, haskell is more thinking in pipelines
16:50:20 <emk> Saizan: That's the equivalent of generics, not run-time polymorphism in the OO sense.
16:50:58 <koala_man> are there any texts on how to design large architectures in haskell?
16:51:04 <jmorrison> emk, if i recall existentials do proper polymorphism
16:51:07 <genbie> anyone knows how i can paste code? i am trying lisp.org but apparently the server is not working
16:51:25 <Saizan> emk: i see typeclasses as the equivalent of interfaces, and for runtime dispatch you can use existential types, even if you have very less need for it in a functional language
16:51:26 <Svrog> jmorrison: you can still think exactly like that in haskell
16:51:35 <emk> jmorrison: Mostly, yeah, depending on what you're thinking about.
16:52:33 <velco> for "runtime dispatch" one could use ordinary closures.
16:52:55 <pbx> I'm poking along learning Haskell and have a pronunciation question -- if were trying to say (to myself
16:52:56 <newsham> a
16:52:59 <pbx> fibGen :: Int -> Int -> Int -> Int
16:53:00 <emk> jmorrison: Still, if you really have multiple levels of subtyping relationships, with each level adding new functions, O'Haskell might be easier than hacking it up with existentials and/pr dictionaries.
16:53:24 <pbx> Would that be... fibGen has type int to int to int to int ?
16:53:41 <sorear> genbie: rafb.net is also accepted here
16:53:42 <jmorrison> emk: I would be breaking idiom, though. Haskell has a reason for doing things its way.
16:54:34 <pbx> (I'll be adding a Haskell colorizer to dpaste.com one of these days...)
16:54:49 <genbie> sorear thanks i was just looking at it!
16:57:19 <pejo> jmorrison, if it was O'Haskell you wouldn't. The subtyping is there for doing .. subtypy things.
16:57:32 <emk> jmorrison: Oh, don't get me wrong; I adore Haskell. There are good reasons why Haskell's subtyping support is relatively weak (true subtyping screws up type inference of H-M polymorphic types), so it's one design option that's harder to use in Haskell.
16:57:43 <genbie> can someone take a quick look at this type error marked by (*****) please? http://rafb.net/p/ap10SI54.html
16:57:44 <lambdabot> Title: Nopaste - No description
16:58:54 <genbie> yeh i didn't enter a description because the error messages were also past
16:59:38 <pbx> No pronunciation tips for me?  Sorry my comments came in a little weirdly, got a little twitchy with the Return key.
16:59:59 <emu> that is fine
17:00:12 <twanvl> genbie: (reverse text) is not an IO action
17:00:13 <emk> Many subtyping designs can be expressed as typeclasses with a bit of creativity (just like the STL uses templates everywhere but no inheritance).
17:00:39 <genbie> twanvl case must return an IO action?
17:00:50 <emk> pbx: Well, some of us learned Haskell from written materials, so we don't know how to pronounce it either. :-)
17:01:12 <jmorrison> Suppose I'm wanting to do combinators that plug together a possibly branching pipeline of transforms, requests are fed in at one end and flow through
17:01:13 <twanvl> it is inside a do block (of type IO), so yes. You probably want to add return
17:01:17 <mauke> genbie: readLines has to, because it uses getLine
17:01:20 <jmorrison> that would be Arrows?
17:01:21 <emk> jmorrison: OK.
17:02:07 <genbie> ah ok, so everytime i use do i must make sure the last thing is an action?
17:02:09 <emk> jmorrison: Yeah. There might be a couple of other ways to approach it, but Arrows are in the standard library and they're a good fit for that sort of thing.
17:02:43 <emk> genbie: Yeah. You can always write "return thing" as your last line to get a value in the monad.
17:02:45 <pbx> emk: In the "Haskell for C programmers" tutorial right after the example I grabbed (and pasted here) it actually gives the pronunciation, pretty much as I guessed. Whew. Initially I was also confused by the lack of distinction between "in" and "out" params, but once I got to the partial function application examples that started to make more sense :)
17:02:55 <jmorrison> Hmm. I'm basically doing a selftutorial by trying to port this: http://www.restlet.org/
17:02:57 <mauke> genbie: not quite, you can use "do" for more than just IO :-)
17:02:58 <lambdabot> Title: Restlet - Lightweight REST framework for Java
17:03:14 <jmorrison> it's very Java-ish, but it feels like it's trying to be functional
17:03:20 <twanvl> As for the first error, unlines expects a pure String, not an IO String. Either use "do {...; l<-readLines; let c=unlines l;...}" or use "liftM unlines (readLines [])"
17:03:48 <genbie> ok! i just started learning yesterday os i am new with this.. i will try it now
17:03:56 <emk> jmorrison: A good Haskell design can be really, really beautiful.
17:04:00 <genbie> thanks twanvl, mauke emk
17:04:20 <emk> But there isn't always a trivial mapping from an OO design...
17:04:53 <jmorrison> emk: and scary. there's haskell stuff I've looked and said "ok, this goes into there and it does that and what the frag? brain explodey" and it's all a couple lines long
17:05:43 <sorear> jmorrison: the probability of brain explosion is inversely proportional to the line count
17:05:47 <emk> jmorrison: It forces my brain to slow *way* down and pay attention to each little bit. :-) But I usually learn something pretty interesting when I do.
17:06:22 <emk> jmorrison: It's why I like to use Haskell for math--it shifts my brain into the right "mode."
17:06:31 <sorear> e.g. lambdabot is >30k lines and quite tame.
17:06:33 <jmorrison> although on the other hand, I really like the bit where you can read the type signature and go "oh yeah, it does that"
17:06:41 <pejo> emk, (the rank n polymorphism is troublesome to infer as well, and probably a bunch of other extensions too).
17:06:53 <sorear> jmorrison: have you seen @djinn?
17:07:03 <sorear> @djinn (a -> b) -> (b -> c) -> (a -> c)
17:07:04 <lambdabot> f a b c = b (a c)
17:07:14 <jmorrison> ehh?
17:07:26 <quazimodo> how would a good programmer do this -> y = reverse (take 4 (reverse (getDigits x))), x is an integer
17:07:43 <sorear> on the subject of being able to tell what a function does by looking at its type - that's automatable.
17:07:48 <quazimodo> getDigits returns a list of integers
17:07:56 <emk> pejo: Yeah, but subtyping is the worst, unless you give up on getting the "best" types, and start looking for the "simplest" (which may be much less general).
17:08:00 <Heffalump> @free map
17:08:02 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
17:08:34 <Heffalump> lambdabot really ought not to be encouraging people to put $ next to names, it breaks TH
17:08:46 <pejo> emk, I don't see why putting in type annotations for subtypes would be worse than for any other extensions.
17:09:04 <sorear> given that you can keep inference with existentials (I've done it), has it been proven that subtyping breaks inference?
17:09:19 <emk> pejo: The H-M typing algorithm used by Haskell needs to "unify" the types of different expressions.
17:09:27 <pejo> (And lots of people seem to put in type signatures in their code anyways, even when the principal type can be easily inferred).
17:09:46 <emk> pejo: But subtyping replaces each unification (cheap and easy) with a constraint (a total pain).
17:09:59 <emk> You wind up with exponentially horrible types.
17:10:27 <pejo> emk, if you go down the path of infering the principal type, yes.
17:10:34 <emk> pejo: O'Haskell solves this very nicely, though. It just goes ahead and does a unification anyway, making the inferred type much less general.
17:11:15 <Svrog> are there any hsc2hs tutorials?
17:11:31 <sorear> what would subtyping look like? I'd like to try and implement it, thus proving somone wrong (possibly including me).
17:11:49 <pejo> @google Polymorphic subtyping in O'Haskell
17:11:54 <lambdabot> http://linkinghub.elsevier.com/retrieve/pii/S0167642302000266
17:11:55 <lambdabot> Title: ScienceDirect - Science of Computer Programming : Polymorphic subtyping in O'Has ...
17:12:31 <emk> pejo: Regular Haskell is pretty fond of principal types, as far as I can tell. :-) I think the O'Haskell folks made a clever decision when they discarded them, but it might not be uncontroversial.
17:12:47 <emk> sorear: Take a look at O'Haskell and the related papers.
17:13:20 * sorear is still riding the ego-boost from first class existentials and inductive types
17:14:28 <pejo> emk, I think it's rather well known exactly when that type system doesn't infer the principal type in O'Haskell.
17:14:54 <sorear> random aside: is there any relationship between functional reactive programming and reactive objects?
17:15:28 <emk> pejo: Yeah, but there's not a really strong model for what kinds of programs it actually types in a reasonable fashion, other than "Well, it doesn't seem to do weird things in practice."
17:20:09 <pejo> emk, Faxn has an article about that at Haskell Workshop in .. hm, 2003 maybe.
17:20:23 <pejo> emk, "Haskell and Principal Types".
17:20:26 <emk> pejo: Thanks! I'll take a look.
17:21:06 <genbie> no luck here :-(.. i am having "String vs. IO String" error http://rafb.net/p/duK4gx90.html
17:21:07 <lambdabot> Title: Nopaste - Couldn&#039;t match `[String]&#039; against `IO [String]&#039;
17:21:34 <pejo> emk, I'm not sure that constraint solving is that horrible though.
17:22:27 <sorear> oh, fun, this is exactly the implicit coercions project I'd been "working" on...
17:22:54 <emk> pejo: I might be wrong, but my understanding was that subtype constraints tended to be a bit annoying, because there really isn't much to "solve." Apparently, they just pile up.
17:23:39 <mauke> genbie: contents <- readLines [] ... writeFile filename (unlines contents)
17:23:58 <emk> pejo: But constraints in general, yeah--there's a lot of good literature on that. There's even the Chameleon project, which is a constraint-based typechecker for Haskell+extensions.
17:23:59 <pejo> emk, so let the inference pass generate constraints, and solve  them afterwards?
17:25:17 <genbie> mauke thanks! what was the difference? contents can not be treated a Styring until **after(( the action??
17:25:33 <emk> pejo: As I understand it, the problem is that the lists of constraints is just disgustingly huge--way more than a programmer would ever want to see, and potentially exponential. H-M inference really does like that central unification.
17:25:35 <pejo> emk, just for the record - if you actually need something *more* general than what is inferred in O'Haskell, you can just put a type annotation there with the "correct" type.
17:25:51 <mauke> genbie: no, unlines takes a list of strings, but readLines returns an IO list of strings
17:26:37 <emk> pejo: Oh, yeah. I love the O'Haskell solution--it appeals to my sense of pragmatism. It just doesn't seem as rigorous as many of the other Haskell type system extensions, at least to me.
17:26:41 <genbie> mauke yes... but in both cases i was applying "unlines" to contents?
17:27:06 <mauke> genbie: no, your code tried to apply unlines to (readLines []) and bind "contents" to the result of that
17:27:47 <mauke> my change binds "contents" to the result of readLines [], which gives us a list of strings we can call unlines on
17:27:49 <genbie> mauke yes sorry.. i mean the trick is in "bind".. contents becomes a String after the action?
17:27:58 <mauke> yeah, pretty much
17:28:04 <mauke> the general pattern is: something <- IO something
17:28:16 <genbie> ah ok thanks
17:28:27 <pejo> emk, as for the huge lists - unless it's horribly slow (might not be in practice), the only problem is when you have a type error. And that is an area we definitely need more research on. :-)
17:28:45 <emk> (Yum. Banana brackets are tasty...)
17:29:50 <genbie> mauke the strange thing is that i tried to use an intermediate value (contents2) in contents2 <- unlines (contents) and it did not wortk!
17:30:08 <emk> pejo: I wouldn't complain in the least if somebody merged O'Haskell's extensions into Haskell. I'm just not sure that everybody else would agree!
17:30:10 <glguy> wtf, my tea bag filled up with air
17:30:20 <newsham> sorear: around?
17:30:32 <emk> genbie: What's the type of "contents" in that expression?
17:30:44 <genbie> String
17:30:48 <mauke> genbie: yes, because (unlines contents) is not an IO action
17:30:51 <pejo> emk, oh, that would be controversial I bet.
17:30:55 <sorear> newsham: yes
17:31:16 <newsham> sorear: its responding on silc now.  but evals (> expr) are broken:  fd:14: hClose: resource vanished (Broken pipe)
17:31:19 <emk> So (unlines contents) is a [String], but "<-" is expecting "IO something".
17:31:21 <newsham> know what I should be looking at?
17:31:22 <jmorrison> Question... Conceptually, what does it mean that type Foo is an instance of Arrow? In Monad, it appears to mean the data being passed through it are that type.
17:31:32 <mauke> genbie: you could say 'let contents2 = unlines contents'
17:31:54 <emk> genbie: You could also write "contents2 = return (unlines contents)".
17:32:00 <emk> s/=/<-/
17:32:05 <genbie> mauke why it has to be an IO action if it is just a an intermediate statement?
17:32:06 <newsham> jmorrison: Foo is something that transforms an input to an output
17:32:08 <sorear> newsham: do you have a program named './runplugs' ?
17:32:16 <emk> ontents2 <- return (unlines contents)
17:32:21 <mauke> genbie: because you used <-
17:32:22 <genbie> thanks emk
17:32:25 <newsham> sorear: appears not.
17:32:56 <emk> genbie: Because "<-" wants a value in the monad. You can either stuff it in with "return", or use the special "let"-inside-"do" syntax.
17:32:56 <newsham> jmorr: arrows transform inputs to outputs, perhaps with internal state.
17:33:03 <sorear> djinn, hoogle, ft, unlambda, run, bf, require external programs in the current directory
17:33:07 <genbie> ah ok!
17:33:10 <genbie> thanks!
17:33:18 <newsham> sorear: are those packaged with lambdabot or separate?
17:33:26 <emk> genbie: Yeah, it only looks like variable assignment. :-)
17:33:33 <sorear> if you used the cabal build system, they can be found in e.g. ./dist/build/hoogle/hoogle
17:33:59 <newsham> so do I have to copy them all to a common directory? ie. dist/build/lambdabot
17:34:03 <jmorrison> newsham: so Foo is a function type?
17:34:12 <newsham> jmorrison: not necessarily a function, but could be.
17:34:23 <newsham> jmorrison: the transformation may involve side effects
17:34:35 <sorear> newsham: yes :(  (or symlink)
17:34:40 <newsham> sorear: thanks!
17:35:25 <sorear> you still might not have a runplugs, I understand that one is built in a funny way
17:35:27 <jmorrison> newsham: how does the internal state get into arrows then? They look as if they just plug functions together
17:35:28 <emk> jmorrison: Arrows are more general than functions--they can be any exotic thing which implements the right interface (and obeys the arrow identities). Functions are just the most obvious and common kind of arrow.
17:35:53 <jmorrison> emk: example please
17:36:10 <newsham> $ for fn in */*; do test -x $fn -a -f $fn -a $fn != 'lambdabot/lambdabot' && ln -s $fn lambdabot; done
17:36:18 <glguy> hmmm, does anyone know how to change the font in mIRC?
17:36:25 <emk> jmorrison: One sec...
17:36:42 <newsham> jmorrison: for example, the kleisli arrow is based on any monad.
17:36:56 <newsham> so for example it could be a State monad, or an IO monad.
17:37:22 <emk> jmorrison: It's probably easier just to worry about the function arrows for now. That's what I do. :-)
17:37:37 <newsham> Kleisli m a b   (ie.  Kleisli IO Int Int)
17:37:46 <newsham> would represent  Int -> IO Int
17:38:07 <newsham> you recognize that IO Int has "internal state"  right?
17:38:50 <newsham> as an example the Kleisli arrow that reads a string from stdin, converts it to an integer and adds it to its input parameter.
17:38:55 <dancor> where can i learn how to do socket stuff in haskell
17:38:55 <jmorrison> yeah, int to IO int means consume int, do some background stuff and come up with another int from whatever
17:39:00 <glguy> ?bot
17:39:01 <lambdabot> :)
17:39:59 <dancor> i dled some HTTP.hs thing that uses its own Connection type which it makes an instance of Stream, but then i saw something that said Streams were not the best way
17:40:24 <sorear> newsham: so silc-lambdabot is working now?
17:40:30 <emk> dancor: I know there's some high-level discussion of Haskell web server design in "Tackling the Awkward Squad".
17:40:33 <newsham> sorear: in a very hack-ish way, yes
17:40:51 <sorear> I was getting a little suprised at the speed :)
17:41:12 <newsham> I replaced IRCBase.hs and IRC.hs completely, and I'm constructing some IRC-style unparsed strings so that IRC-specific code can parse it
17:41:18 <dancor> what do you guys do for your socket programming
17:41:19 <newsham> and I only handle one channel, and PRIVMSG
17:41:28 <newsham> sorear: but its a start
17:41:57 <dancor> is haskell still working that out?  should i go with python or ocaml or something
17:42:19 <dancor> for now
17:42:50 <beschmi> dancor: http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
17:42:52 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
17:43:27 <dancor> emk: thanks grabbed that paper
17:44:20 * sorear looks at dancor and points at lambdabot
17:44:45 <glguy> sorear: everyone knows that lambdabot is just a screen scraper for mIRC
17:47:13 <newsham> Failed to load interface for `ShowQ':
17:47:21 <newsham> do I have to have the plugins in a particular location?
17:48:18 <sorear> newsham: look at the 'build' file ... I don't know the full explanation having never gotten @run working :)
17:48:21 <emk> ?hoogle socket
17:48:22 <lambdabot> Network.Socket.socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
17:48:22 <lambdabot> Network.Socket :: module
17:48:22 <lambdabot> Network.Socket :: data Socket
17:48:40 <emk> dancor: Looks like Network.Socket is where to start...
17:48:48 <newsham> oh, build, huh :)
17:48:56 <glguy> > flip runState 3 $ runKleisli (Kleisli (const (put 4)) >>> Kleisli (const (modify (+1))) >>> Kleisli (const get) >>> (*2) ^>> Kleisli return) ()
17:48:58 <lambdabot>  (10,5)
17:50:13 <newsham> Kleisli (\x -> do {y <- readLine; return $ (read y) + x})
17:52:00 * glguy wonders if lambdabot could generate a list of the people who haven't said word in the channel since lambdabot started watching
17:52:15 <sorear> very easily
17:52:37 <glguy> ?losers
17:52:38 <lambdabot> Maximum users seen in #haskell: 303, currently: 271 (89.4%), active: 35 (12.9%)
17:52:41 <sorear> the @users active is more-recently-than-4-hrs
17:52:52 <sorear> the @seen #haskell is more-recently-than-15-mins
17:53:10 <newsham> filter (not. (find "something")) $ map seen users
17:53:21 <sorear> in principle, lambdabot could be extended with typed composition and ramble ramble
17:54:08 * jmorrison types the people as either IRC a => a -> IO a or a -> IO ()
17:54:48 <sorear> In lambdabot, you are a Message.Nick .
17:55:31 <Saizan> i'm not a type! i'm a free man!
17:56:36 <sorear> the people who haven't spoken yet are thunks
17:57:13 <jmorrison> that even sounds insulting
17:57:39 <newsham> nobody said reality was pleasant
17:58:15 <sorear> ?remember Saizan i'm not a type! i'm a free man!
17:58:15 <lambdabot> Done memoising quote for `Saizan', if that is their real name...
17:59:04 <newsham> you are more than the cartesian product of your constituent types
17:59:13 <jmorrison> If the quote is memoized, does that mean it doesn't need to be recalculated if it's called again?
17:59:33 <Saizan> @quote saizan
17:59:34 <lambdabot> No quotes match. Take a stress pill and think things over.
17:59:39 <Saizan> @quote Saizan
17:59:40 <lambdabot> Saizan says: yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
18:00:44 <newsham> computer programmers are wild and crazy people
18:00:45 <Saizan> jmorrison: it doesn't need me to rewrite it :)
18:01:29 <newsham> saizan returns different values each time invoked
18:03:25 <Saizan> i try to :)
18:07:44 <jmorrison> bye all
18:08:30 <SamB> hmm, ubuntu is nice. at least one of my sisters can use it without much help ;-)
18:09:44 <dancor> emk: yeah i'm on my way!  thanks
18:10:06 <wolverian> SamB, my mom finds it easier to use than windows. :)
18:10:31 <SamB> a friend of mine said something like that, too...
18:11:43 * SamB wonders which OS his sister will end up using more
18:12:41 <master_bater> how old is she?
18:12:47 <SamB> She is supposed to have a Windows 98 system of her own on a KVM with this computer my friend gave me which I installed ubuntu on (mainly because it was the easiest thing to find an install CD for)
18:13:03 <SamB> hmm...
18:13:10 <SamB> she is almost 17
18:13:14 <master_bater> nice
18:13:16 <master_bater> got pics?
18:13:24 <SamB> heh
18:14:31 <SamB> If I had some, I might let you see them, but I don't think you would like them very much
18:14:39 <master_bater> :(
18:14:44 <master_bater> that's not a nice thing to say
18:15:05 <SamB> I'm not saying that she is ugly...
18:15:29 <SamB> maybe I am misunderstanding why you would want to look at pictures of a 16-year-old...
18:15:54 <newsham> if I have a src tree from darcs, and I delete a directory, what do I do to recover that directory?
18:15:56 <SamB> but, she doesn't dress like normal people ;-)
18:16:14 <sorear> newsham: darcs revert
18:16:21 <SamB> she is like a geek or something
18:16:27 <newsham> how do I specify just the one directory to revert?
18:16:48 <SamB> (is it at all surprising that my sister would be something like a geek, considering the channel?)
18:17:47 <SamB> note that she is not a computer geek
18:18:04 <newsham> yay!  eval working
18:18:21 <bd_> newsham: cp -a _darcs/pristine/dir dir ?
18:18:35 <SamB> newsham: probably you say darcs revert that/one/directory
18:18:59 <newsham> yah, revert -a <dir> worked
18:19:15 <sorear> I usually just don't delete things :)
18:19:24 <SamB> you know what is really annoying?
18:19:37 <SamB> if you do find -name '*.hs' | xargs rm
18:19:53 <SamB> then you have to make darcs rebuild _darcs/pristine
18:20:10 <SamB> which is especially annoying for a --partial repository!
18:20:32 <SamB> (if the repository is --partial, you might as well just grab another one and pull your patches!)
18:21:33 <sorear> SamB: -ok rm '{}'
18:21:41 <sorear> but you knew that ?
18:22:02 <SamB> sorear: if I am typing stuff, I don't usually have to worry about spaces in filenames!
18:22:21 <beschmi> SamB: i hate that too (all _darcs files showing up in find, grep, etc)
18:23:15 <newsham> samb: I said 'doctor, it hurts when I do *this*' and he said "dont do that!"
18:26:16 <SamB> newsham: that isn't the problem!
18:26:28 <newsham> fgrh() { find . -name '*.hs'|grep -v "_darcs"|xargs grep "$@"; }
18:26:29 <SamB> anyway, I didn't mean to do that ;-)
18:26:48 <SamB> so why is everyone telling me the *right* way to do what I did by accident?
18:27:08 <newsham> i'm not telling you
18:27:29 <dancor> SamB: please stumble more correctly in the future
18:27:54 <SamB> I don't remember what I meant to type
18:28:09 <SamB> but it wasn't "*.hs"
18:28:15 <sorear> *.hi ?
18:28:22 <SamB> that is the only thing I can think of
18:28:25 <newsham> ?help
18:28:25 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:28:28 <newsham> ?list
18:28:29 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:28:54 <SamB> anyway, it was really only a minor annoyance. because the repository was not a --partial repository ;-)
18:29:00 * sorear hates the way GHC names files using the basename of your source ... makes completion/globbing harder
18:29:18 <SamB> I can't see how else it should do it!
18:29:20 * sorear loves Cabal and dist/build/yank/yank-tmp/
18:29:27 <SamB> oh, that
18:29:34 <SamB> well it still uses the basename of your source...
18:29:56 <sorear> oh right, basename includes dir...
18:30:18 <SamB> well. at least, the basename still ends up in the name...
18:30:25 * SamB doesn't know if basename includes dir or not
18:30:37 * sorear runs basename(1)
18:30:52 <sorear> er, man 1 basename
18:30:59 <sorear>        basename - strip directory and suffix from filenames
18:31:06 <SamB> it doesn't do a good job
18:31:12 <SamB> naesten@hydrogen:~/hacking/zsnes/dos/src% basename hello/world.cpp
18:31:12 <SamB> world.cpp
18:31:43 <SamB> now, the ZSNES stuff is irrelevant, as basename doesn't use the file (there is no such file ;-)
18:32:24 * SamB wonders why his scroll wheel doesn't work...
18:32:34 <sorear> in what environment?
18:32:40 <SamB> Debian...
18:32:56 <SamB> it is a USB mouse, too...
18:33:05 * sorear is amazed by the 10+ layer linux keyboard stack ... it's thicker than the network stack!
18:33:21 <SamB> the keyboard doesn't go so fast as the network, you know
18:33:41 <sorear> I mostly meant X11/xterm v. X11 native v. console etc
18:33:49 <SamB> people can't type more than a couple hundred chars a minute!
18:34:03 <SamB> er, words
18:34:15 <sorear> a thousand simultaneous typing contests? :)
18:34:52 <SamB> you would run out of slots to plug in video cards!
18:35:39 <SamB> I do think the stack gets a bit deep at times ;-)
18:36:10 <newsham> ?babel en fr red
18:36:12 <lambdabot>   rouge
18:36:14 <sorear> *** ERROR: Driver stack overflowed
18:36:31 * sorear wonders when hugs became his OS
18:36:48 <SamB> heh
18:36:51 <newsham> there are many vehicals and many drivers
18:37:08 <SamB> and many people who do not know how two spel
18:37:24 <newsham> http://www.google.com/
18:37:25 <lambdabot> Title: Google
18:37:44 <newsham> bot only does that for public messages?
18:38:19 <sorear> newsham: bot only runs contextual handlers of any kind for public (ie not sent to lambdabot) messages
18:38:37 <newsham> i see
18:38:51 <newsham> my handler is pretending everything is a private message right now :)
18:42:04 <newsham> ?wikipedia atari
18:42:06 <lambdabot> No Result Found.
18:42:14 <newsham> none of my wikipedia searches ar eworking
18:42:24 <sorear> someone should fix that
18:42:50 <sorear> SamB wrote it long ago, it broke shortly thereafter
18:43:03 <sorear> (he says)
18:43:42 <newsham> aha
18:43:58 <newsham> well i wasted a perfectly good day playing with this..  time to do sometihng else..
18:44:03 <newsham> appreciate all the help you offered, sorear.
18:46:51 <SamB> actually...
18:47:06 <SamB> I merged the wikipedia stuff from a virtual clone of my google module
18:47:46 <SamB> probably it should be un-merged?
18:48:11 <sorear> so [ there was nothing, SamB writes google, Someone forks google creating wikipedia, SamB merges to make Search ] ?
18:48:19 <SamB> yeah
18:48:21 <SamB> exactly
18:49:59 <SamB> hmm, what Protocol should I be using for my Logitech USB mouse?
18:50:21 <sorear> "ImPS2"
18:50:29 <sorear> /dev/input/mics
18:50:36 <sorear> /dev/input/mice
18:50:51 <SamB> thats kinda what I was thinking too...
18:51:09 <SamB> except according to mouse(4x), it is spelled with a / before the 2
18:51:28 * sorear is no man(1)
18:55:36 <dancor> is it a good idea to maintain game state on server and client and just pass delta info.  and if the client even seems fishy then yell at it
18:56:44 <SamB> how would yelling help?
18:57:04 <sorear> best solution: don't create a reward for cheating (eg. public highscores)
18:57:05 <dancor> debugging?
18:57:22 <SamB> ah
18:57:31 <SamB> what sort of game?
18:57:35 <dancor> dr mario
18:58:08 <nostrademons> sorear: if you eliminate the reward for cheating, you often eliminate the reward for *playing*
18:58:43 <SamB> for emulated games, my understanding is that you usually just transfer input events and run the emulators in lockstep
18:58:45 <sorear> *stump*hm
18:58:48 <dancor> heh yeah maybe simplest is a better descr than best
18:59:15 <SamB> of course, they probably better be the same emulator...
18:59:32 <lucca> never trust the client software, for it is in the hands of the enemy.
18:59:38 <bd_> SamB: One can still generate input events fradulently
18:59:41 <SamB> and good luck dealing with high-latency connections
18:59:47 <sorear> the simplest approach is to transfer input events and an abstract screen description ... the canonical instantiation of this pattern is the nethack telnet serve
18:59:57 <SamB> bd_: but how will anyone know?
19:00:13 <SamB> sorear: well. that works nicely if you actually have a server ;-)
19:00:20 <bd_> SamB: They won't, that's the point :)
19:00:36 <SamB> and if by "abstract" you mean "mpeg 2", or something...
19:01:03 <SamB> Dr. Mario is a two-player game
19:01:18 <SamB> and you could just as easily generate fraudulent input events using a *real* NES
19:01:36 <dancor> yeah i just want to protect state
19:01:49 <dancor> there is no way to stop all kinds of cheating
19:01:58 <SamB> if by "fraudulent" you mean "not having a one-to-one corrospondence with the buttons depressed by the player"
19:02:00 <dancor> and i certainly don't want to rule out bots playing anyway
19:02:15 <SamB> I would like to see a bot play Dr. Mario
19:02:20 <sorear> sure.  try and cheat on a telnet go server :)
19:02:45 <SamB> I think it would be easier with the MPEG, though
19:02:47 <dancor> sorear: the computer still destroys me at go, so i could inflate my rating
19:03:19 <SamB> also, bots aren't considered cheating in nethack ;-)
19:03:42 <sorear> the problem is that MPEG would probably consume a lot of dancor's bandwidth ...
19:03:48 <SamB> yeah ;-)
19:04:25 <sorear> if you can assume Dr. Mario, I assume you could say "Sprite 32 at (34,74)"
19:04:26 <dancor> oh yeah another thing i was considering was decentralizing games
19:04:59 <dancor> i guess that involves revealing ips and it's hard to know a game really went down the way it was said to have afterward
19:05:04 <SamB> sorear: what if sometimes it was actually not Dr. Mario?
19:05:06 <SamB> but some other game?
19:05:10 <xic> why did i have to add a type signature when creating a TArray?
19:05:28 <SamB> dancor: how were you going to see who won?
19:05:37 <sorear> because newArray and {write,read}Array are both overloaded
19:05:54 <sorear> same reason (show.read) never works
19:06:06 <dancor> SamB: doing that well becomes complicated enough that i'll probably just stay centralized at least for now
19:06:12 <sorear> SamB: hence implication.
19:06:12 <xic> yeah, but i later used the array in STM monad, shouldn't type inference work?
19:06:22 <sorear> no
19:06:33 <sorear> @src MArray
19:06:33 <lambdabot> Source not found. Do you think like you type?
19:06:48 <sorear> anway class MArray a e m | a -> e m
19:06:54 <SamB> I was more wondering how anyone was going to figure out who won?
19:07:05 <SamB> except by reading the screen?
19:07:11 <sorear> that is the type of array fixes the monad but not vice versa
19:07:35 <sorear> you could do better with whole program closed type classes, but that's not Haskell
19:24:39 <newsham> ?. tinyurl list
19:24:39 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "tinyurl"
19:24:46 <newsham> ?. tiny-url list
19:24:48 <lambdabot> http://tinyurl.com/jz56b
19:25:48 <sorear> that's also on my todo list - make all command-parsing equivalent.
19:25:56 <sorear> rather lowly
19:26:17 * sorear has *finally* found the solution to the netsplit problem
19:26:23 <newsham> a noble spirit embiggens the smallest man
19:26:52 <sorear> Failed to interpret sentence.
19:27:09 <newsham> ?. elite . tiny-url list
19:27:11 <lambdabot> H7+P://TiNYurL.coM/JZ56b
19:28:04 <newsham> sorear: http://en.wikipedia.org/wiki/Culturally_significant_phrases_from_The_Simpsons#Cromulent
19:28:06 <lambdabot> http://tinyurl.com/ynh7kx
19:28:27 <Nafai> newsham: Was that one of Homer's fortune cookie fortunes?
19:28:40 <newsham> its the town motto
19:29:31 <Nafai> Oh
19:29:36 <Nafai> Geez, I should know that.
19:31:12 <newsham> ?fact chessguy
19:31:13 <lambdabot> chessguy: is not cheeseguy
19:31:55 <sorear> oh, interesting, curry's paradox is w
19:32:28 <newsham> does lambdabot keep the State/* files up to date or only at checkpoints/quit?
19:32:43 <sorear> @flush
19:32:44 <lambdabot> Not enough privileges
19:32:53 <sorear> only at checkpoints/quit
19:33:10 <sorear> fortunately, this being haskell, segfaults are almost unheard of
19:33:32 <sorear> and @quit is unnecessary because lambdabot catches SIGINT
19:33:52 <SamB> sorear: it is hart to send SIGINT over IRC
19:34:25 <sorear> sure you can.
19:34:40 <sorear> /msg dons please killall -2 lambdabot
19:34:47 <newsham> /msg samb ^ASIGINT^A
19:48:21 <newsham> would be cool if you could mix evaluation with lambdabot commands.
19:49:24 <sorear> what are you imagining?
19:50:05 <sorear> . {run (join(++))} users ?
19:50:22 <sorear> (of course lambdabot's quoting isn't that powerful)
19:53:56 <newsham> ?let colatz m = takeWhile (/= 1) (iterate (\n -> if n `mod` 2 == 0 then n `div` 2 else 3*n+1) m)
19:53:57 <lambdabot> Defined.
19:54:01 <newsham> > L.colatz 25
19:54:03 <lambdabot>  [25,76,38,19,58,29,88,44,22,11,34,17,52,26,13,40,20,10,5,16,8,4,2]
19:56:09 <newsham> > map (length.colatz) [1..20]
19:56:11 <lambdabot>  [0,1,7,2,5,8,16,3,19,6,14,9,9,17,17,4,12,20,20,7]
19:57:18 <newsham> sorear: what i am imagining is a cmd that fetches a series of stock data, and some eval code to perform operations like adjust prices to be in EURO (based on a forex series of usd v. eur)
19:58:06 <newsham> let s = Lb.stock "vfinx"; e = Lb.forex "eur" in zipWith (*) s e
19:58:14 <newsham> like such
19:59:18 <sorear> imagine a LBC monad (newtype'd IO), populated only by lambdabot commands
19:59:31 <newsham> yes.  that would be delightful.
20:00:04 <sorear>  > Lb.recentusers :: TimeDiff -> LBC [Nick]
20:00:20 <newsham> well, almost.. until someone does replicateM_ 100000 (LBC.dot LBC.elite LBC.arr)
20:00:38 <sorear> newsham: laziness!
20:00:59 <newsham> ?. elite arr
20:01:00 <lambdabot> A|-|oY MatEYs
20:01:35 <sorear> also, buried in Plugin.hs (i think), is a line that clips channel output from @run to 80 character
20:15:42 <sorear> @google ghc 6.4.2 library docs
20:15:45 <lambdabot> http://hackage.haskell.org/trac/ghc/query?status=new&status=assigned&status=reopened&group=priority&type=bug&order=id&desc=1
20:15:45 <lambdabot> Title: Custom Query - GHC - Trac
20:15:47 <sorear> @google ghc 6.4.2 library
20:15:50 <lambdabot> http://rpmfind.net/linux/RPM/mandriva/devel/2007.0/i586/media/contrib/release/hs-plugins-0.9.11-0.20051120.2mdk.i586.html
20:15:50 <lambdabot> Title: hs-plugins-0.9.11-0.20051120.2mdk.i586 RPM
20:15:56 <sorear> @google ghc 6.4.2 library documentation
20:15:59 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/955
20:15:59 <lambdabot> Title: #955 (more object-code blow-up in ghc-6.6 vs. ghc-6.4.2 (both with optimization) ...
20:23:47 <jethr0> http://haskell.org/ghc/docs/6.4.2/
20:23:48 <lambdabot> Title: Index of /ghc/docs/6.4.2
20:24:12 <jethr0> or rather tp://haskell.org/ghc/docs/6.4.2/html/libraries/index.html
20:24:16 <jethr0> *ht
20:24:41 <sorear> sorry, forgot to mention I found it
20:24:48 <jethr0> nm
20:25:03 <jethr0> i ain't doing anything sensible anyways
20:25:14 * sorear is current staring into the ancient ruin that is the 0.29 user's guide
20:27:29 <jethr0> hehe, quite ancient
20:28:41 <jethr0> the "system" library was kinda limited back then
20:28:55 <sorear> You might be able to write a better quicksort than the one in the HBC library, but it will take you much longer than typing `import QSort'. (Incidentally, it doesn't hurt if the Someone Else is Lennart Augustsson.)
20:29:27 <sorear> they deleted the parenthetical in the current version ...
20:30:10 <sorear> the writing style is very different between .29 and 6.6
20:30:35 <jethr0> hbc?
20:31:05 <jethr0> nm, i remember
20:31:10 <sorear> I don't.
20:31:20 <sorear> (I know however)
20:31:50 <jethr0> hbc is kinda deprecated though, methinks
20:32:46 <jethr0> > 4 asTypeOf (undefined :: Int)
20:32:46 <lambdabot>   add an instance declaration for (Num ((a -> a -> a) -> Int -> a1))
20:32:47 <lambdabot>     In t...
20:32:57 <jethr0> > 4 `asTypeOf` (undefined :: Int)
20:32:59 <lambdabot>  4
20:33:34 <jethr0> those "scrap your boilerplate" papers got me totally confused about the separation of type system and the rest :)
20:33:52 <sorear> need insight?
20:34:13 <sorear> <-- author of a SYB-using library
20:34:19 <jethr0> hmm. i'm pretty happy with the papers although i'll need some time to digest them
20:34:24 <jethr0> ah
20:35:18 <jethr0> sorear: any ideas why the serializing and generating stuff isn't in Data.Generic? weren't they useful/general enough?
20:37:44 <sorear> what do you mean?
20:38:18 <sorear> gunfoldl, gfoldl, readConstr, and toConstr are sufficient for (de)serialization
20:38:28 <jethr0> the stuff from the 3rd paper. data2bits and automatically generating instances
20:38:44 <jethr0> yes, i meant the functions using those
20:39:01 <sorear> what a coincidence.  aformentioned library was genericserialize.
20:39:11 <jethr0> hehe
20:39:14 * sorear hasn't read the third paper
20:39:48 <jethr0> yup, i remember someone talking about that in here. so that was you ^_^
20:41:54 <jethr0> sorry, i meant the second paper. but in there they have a more or less generic serialize (although i'm not sure how well it handles built-in types (Int, ...))
20:42:10 <jethr0> sorear: where's your library at?
20:42:19 <sorear> @where genericserialize
20:42:20 <lambdabot> I know nothing about genericserialize.
20:42:46 <sorear> [finding url...]
20:43:49 <jethr0> so, did you implement the ideas from the second paper or have you gone beyond that?
20:44:22 <sorear> don't remember anything that fancy in the second paper ... probably I never read it
20:45:10 <sorear> @where+ genericserialize http://members.cox.net/stefanor/genericserialize/
20:45:11 <lambdabot> Done.
20:45:14 <jethr0> wasn't very fancy.
20:45:17 <jethr0> thx
20:45:52 <sorear> mine was trying to provide a library of compatible serializers, using SYB to handle non-specific cases
20:46:11 <sorear> all I have is a nearly complete r5rs sexp serializer
20:46:51 <sorear> SamB was working on a YAML backend, but gave up when confronted with the abstractness of Data.Map
20:47:23 <sorear> I've put the project into indefinite hibernation, pending the arrival of a good idea or a user.
20:47:58 <jethr0> what's lacking in your version and why did you go via sexps?
20:48:38 <sorear> relative to what? and seemed like a good choice for a first backend
20:49:01 <ttmrichter> @src Array
20:49:02 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:49:10 <ttmrichter> Oops.  Forgot to /msg that.
20:49:14 <jethr0> no idea, just an interesting choice for a haskeller :)
20:49:18 <ttmrichter> Sorry.
20:49:22 <jethr0> np
20:49:59 * sorear points out that ttmrichter's apology was longer than his spam and lambdabot's put together :)
20:50:34 <jethr0> exactly
20:50:35 <sorear> actually I've never seriously used a lisp...
20:51:19 <ttmrichter> Define "seriously"....
20:51:40 <jethr0> wholeheartedly?
20:51:49 <jethr0> fanatically
20:51:52 <allbery_b> maybe "not elisp"?
20:52:05 <sorear> P(me using language X for a language-neutral new project) > 0
20:52:37 <sorear> I've learned scheme, but only done a couple training projects.
20:52:50 <jethr0> using-scheme-for-more-than-one-project?
20:53:16 <jethr0> it's a pity that haskell doesn't allow dash and question mark in function names
20:53:20 <sorear> if so, I've lost all material evidence :)
20:53:44 <sorear> (which isn't suprising, given all the secondhand hard drives I use)
20:53:46 <jethr0> well, dash is maybe not such a pity
20:54:16 <jethr0> backups, backups, bac^C client disconnected
20:54:18 <allbery_b> underscore works serviceably well.  question mark I can live without
20:54:50 <jethr0> question mark is a nice way in scheme to denote predicates imo. and underscores are ugly somehow
20:55:17 <jethr0> but i agree that dashes would at least visually collide with the concept of the infix operator "-"
20:55:17 <sorear> really-p
20:55:18 * allbery_b is less than fond of camelCase, ut in a laguage where case can be significant he rolls with it and deals
20:55:25 <allbery_b> ==sorear :)
20:55:28 <jethr0> hmm, i like the scheme way better
20:56:00 <jethr0> yes, camelCase is kinda an abomination
20:56:09 <jethr0> especially when mixed with uppercase acronyms
20:56:39 <sorear> for me, camelCase is even worse by the whole natural-conditioning thing
20:56:41 <allbery_b> ruby uses the foo?  convention as well, albeit somewhat inconsistently since as of 1.8 at least there are no convenience functions to let users define boolean attributes.  (otoh it was trivial to add such via metaprogramming...)
20:56:50 <sorear> camelCase --> windows api
20:58:35 <jethr0> sorear: yes, but windows api is aggravated by the polish notation thingy as well as near-infinite-length names
20:59:22 * allbery_b thinks they overreacted slightly to creat()...
20:59:29 <jethr0> haha
20:59:50 <jethr0> ritchie's one and only regret ^^
21:00:03 <sorear> i thought that was ken's
21:00:11 <jethr0> i always mix them up, sry
21:00:50 <sorear> I'm fine with two-character 'cp', but did they really need to make 'mkfs' so short? :)
21:01:22 * sorear is auditing Control.Concurrent.Chan for async exception safety
21:01:24 * allbery_b has actually *used* a KSR33, so has some sympathy for them
21:02:38 * jethr0 hates "chkfs"
21:03:16 <jethr0> sorear: is there a way to write sensible tests for that or how are you auditing?
21:03:49 <sorear> ok, there are 3 blocking calls ... what happens if an exception is received here? ...
21:04:06 <jethr0> what kind of exception
21:04:11 <lisppaste2> glguy pasted "does this seem like a bad way to check if two segments intersect?" at http://paste.lisp.org/display/35209
21:04:41 <sorear> I'd much rather trust the concurrency abstractions to be correct, but <overreact> SPJ has lost my trust for today </overreact>...
21:05:57 <sorear> oh, nm, I can't sanely implement what I need in terms of Chan
21:06:46 <sorear> jethr0: ThreadKilled, mostly
21:08:08 <jethr0> glguy: i'm too tired to understand your code right now. but i'd do it by intersecting the implied lines and checking whether the intersectin (if any) lies within the segments
21:08:59 <jethr0> sorear: i've never worked with concurrency in haskell yet. so i can't be of much help there :(
21:09:00 <glguy>  jethr0: but I don't think that's much simpler, and has more edge cases for colinear segments
21:09:11 <glguy> that's why I tried this route
21:09:30 <glguy> using the cross product to determine if the points are on either side
21:09:45 * sorear draws a picture
21:09:51 <sorear> consider --- |
21:10:15 <sorear> the endpoints of the right segment are on either side of the left segment
21:10:33 * sorear is also too tired to understand code he didn't write
21:10:47 <glguy> and the end points of the left segment are not
21:10:58 <glguy> so since both tests didn't pass
21:11:01 <glguy> they don't intersect
21:11:19 <glguy> segmentsIntersect s1 s2 = f s1 s2 && f s2 s1
21:11:27 <glguy>                                 ^^
21:11:30 * sorear sets mode: -programmer +mathemetician
21:11:35 <jethr0> yup, i remember having written it similarly in the past as well
21:12:09 <sorear> how does it cope with coincident segments?
21:12:19 <jethr0> but you have to check this from the perspective of both segments, right?
21:12:48 <glguy> jethr0: right
21:12:53 <jethr0> sorear: cross product with null vector possibly
21:13:10 * allbery_b notes glguy's arrows don't line up with much of anyting in his proportional font :)
21:13:43 * sorear sets mode: +programmer -mathemetician
21:13:48 <glguy> sorear: my solution considers coincident segments intersecting
21:13:53 <sorear> looks sane
21:14:08 <sorear> (the idea, not the code)
21:14:24 <glguy> I didn't know what to call the functions :)
21:14:47 <jethr0> glguy: in your place i'd write a function crossProduct a b just to clarify what's going on
21:14:51 <glguy> yeah
21:16:58 <jethr0> you could define that on Point and also define a subtraction for Point (i.e. :-:)
21:17:05 <Anon4888> glguy: I think there are two algorithms usually used, and this is one of them
21:17:20 <glguy> I'm going to start a course on Computational Geometry on Tuesday
21:17:27 <glguy> so I'm just playing around with some stuff beforehand
21:17:28 <Anon4888> signum = sign of?
21:17:31 <glguy> yeah
21:18:14 <Anon4888> If you actually need to find the intersection, then you usually solve for parameters s,t and test for intersection by checking that they're both 0...1
21:18:27 <glguy> right
21:18:34 <glguy> in this case I didn't need ot know where
21:18:37 <glguy> so I scraped that idea
21:19:50 <lisppaste2> glguy annotated #35209 with "new names" at http://paste.lisp.org/display/35209#1
21:20:31 <Anon4888> Does signum return -1,0,1 ?
21:20:35 <sorear> yes
21:20:36 <glguy> yeah
21:20:40 <sorear> on Int etc
21:20:54 <sorear> on Polynomials it does something completely ridiculous
21:20:56 <glguy> I'm using x == - y    so that if one is 0, the other must be
21:21:14 <sorear> on Complexes it returns x / |x|
21:21:49 <glguy> > signum $ 1 :+ 2
21:21:51 <lambdabot>  0.4472135954999579 :+ 0.8944271909999159
21:22:14 <Anon4888> That's not the desired behavior if one is 0, right?  But you just don't care because they're floats?
21:22:33 <sorear> > signum 0 :: Complex Double
21:22:35 <lambdabot>  0.0 :+ 0.0
21:23:37 <Anon4888> Actually that could cause a significantly incorrect result if they're collinear and disjoint, couldn't it?
21:24:12 <glguy> Main> segmentsIntersect (Segment (Point 0 0) (Point 1 1)) (Segment (Point 0 1) (Point 1 2))
21:24:12 <glguy> False
21:24:29 <sorear> "significantly incorrect"?  booleans carry the discrete topology!
21:24:31 <lisppaste2> jethr0 annotated #35209 with "untested" at http://paste.lisp.org/display/35209#2
21:24:57 <Anon4888> significantly incorrect meaning incorrect in a way that matters
21:26:06 <Anon4888> as opposed to a situation where the two line segments interesect but do not properly cross
21:26:07 <jethr0> ups, s/-/|-|/g in annotation
21:26:12 <glguy> "notIntersecting"?
21:26:49 <jethr0> glguy: forgive me if the naming is bogus
21:27:04 <jethr0> i tend to make more mistakes in this channel than anywere else, EVER
21:27:04 <Anon4888> e.g:  segmentsIntersect (Segment (Point 0 0) (Point 1 0)) (Segment (Point 3 0) (Point 4 0))  gives true, right?
21:27:25 <glguy> Anon4888 yeah
21:27:29 <jethr0> huh?
21:27:36 <sorear> don't worry, we're just a bunch of fascist pedants
21:28:09 <glguy> Anon4888: good point
21:28:31 <glguy> so , not x == - y, but check that one is 1 and the other -1?
21:28:56 <jethr0> sorear: but it's really annoying how massively wrong i am again and again on this channel whereas normally i tend to mean what i say.
21:30:33 * jethr0 is off to bed. i'll be back with more correct/helpful answers/comments tomorrow ^_^
21:30:35 <jethr0> night
21:30:56 <sorear> bye
21:31:10 <Anon4888> The problem is that segmentsIntersect (Segment (Point 0 0) (Point 2 0)) (Segment (Point 1 0) (Point 3 0)) shoudl return true
21:31:28 <Anon4888> So you'd have to look at something other than the cross-products to resolve things I think
21:31:54 <glguy> Anon4888: fortunately in my application, that will never occur
21:32:26 <glguy> I want to take a set of polygons, a start point and a finish oint
21:32:36 <glguy> and find the shortest path from start to finish
21:32:45 <glguy> without passing through a polygon
21:32:47 <Anon4888> in the interiors ?
21:32:51 <Anon4888> oh exteriors
21:33:12 <Anon4888> You writing pathing for a game?
21:33:28 <glguy> nope, just playing with a problem I saw on the course website
21:33:33 <glguy> in advance of the course
21:33:39 <glguy> seeing what I can figure out on my own
21:34:20 <Anon4888> do you have efficiency concerns?
21:34:52 <glguy> I'll probably worry about that after I get something working
21:35:04 <Anon4888> sounds good :)
21:41:43 <sorear> @users
21:41:44 <lambdabot> Maximum users seen in #haskell: 303, currently: 253 (83.5%), active: 19 (7.5%)
21:43:29 <newsham> hrm
22:08:58 <Z4rd0Z> when I pass the -static flag to ghc, I still get dynamically linked executables.  I've tried this on both FreeBSD and Linux
22:12:00 <sorear> -optL-static ?
22:12:19 <sorear> no matter what *I* do I get statically linked executables :(
22:14:55 <Z4rd0Z> hmm, still dynamic
22:17:02 <allbery_b> what's beingllinked dynamically?  do you have the static version of thelibrary?  (linux distributions in particular often make the static libc a separate package, although fbsd should always have a static libc)
22:17:31 <sorear> debian: you need libfoo-dev
22:18:08 <sorear> not like I'd know, I have no use for giant memory-hogging static programs :)
22:18:13 <Z4rd0Z> allbery_b: I'm just trying with a simple hello world program.  I do have the static libraries installed
22:22:40 <allbery_b> hm, on fbsd at least even -optL-static doesn't actually pass on -static
22:24:30 <allbery_b> actually it looks like -optL-static isn't treated as a flag for the linker; ghc -v reports "Hsc static flags: -static"
22:24:41 <Z4rd0Z> I found it.  -optl-static
22:25:06 <allbery_b> that looks better, yeh
22:25:26 <allbery_b> ldd: foo: not a dynamic executable
22:27:24 <allbery_b> and it looks like -static (as distinct from -optl-static) affects only haskell's own libraries (i.e. /usr/local/lib/ghc-*/libHS*)
22:27:45 <sorear> I still wonder why you want a static executable
22:28:05 <sorear> atleast on Linux, haskell libs are mandatorily static :(
22:28:20 <sorear> and non-haskell libs are available everywhere
22:28:20 <allbery_b> on freebsd at least, you get libgmp shared, and you may not want to force others to install it from ports
22:28:39 <sorear> ports doesn't have transitive installs!?
22:28:48 * sorear is used to apt-get
22:28:50 <allbery_b> it does but that assumes you're creating a port
22:29:35 <allbery_b> if you're just creating a binary to give to someone, they'd have to install gmp from ports to run it
22:29:47 <allbery_b> (ot that I recommend doing things that way, but I can certainly see it)
22:30:22 <sorear> doesn't ports have something like auto-apt?
22:31:47 <Z4rd0Z> sorear: I want to be able to create a standalone executable that I can run anywhere with no dependencies
22:32:10 <allbery_b> you can use "make search" for that, I think.  but you do not necessarily want to have to do that
22:33:05 <sorear> good luck.  I have used three different processor architectures and at least 5 ABIs, on destop-type computers alone.
22:33:46 <allbery_b> well, in particular one reason you'd want to avoid shlibs on linux+fbsd:  create a binary which runs on both
22:34:26 <allbery_b> build on linux, static so you don;t have to figure out how to get a linux libgmp.so on freebsd (there might be a port for that, or might not)
22:34:39 <sorear> one reason you'd WANT shlibs: create a binary that runs on both.  (I thought they had compatible dynamic linkers but incompatible syscalls)
22:35:07 <Z4rd0Z> well, I figure I'll have to have separate executables for different OSes
22:35:36 <allbery_b> no, you can't dynamic-link a freebsd .so into a linux executable on freebsd
22:35:49 <allbery_b> you need the linux .so
22:36:49 <allbery_b> thus there are a bunch of ports which just install linux shared objects from rpms (or etc. --- these days there are also linux-base ports based ondebian, etc.) into the linuxulator
22:37:28 <sorear> what ever happened to source code?
22:37:40 <sorear> ./configure && make && su -c 'make install'
22:37:47 <allbery_b> the linkers are compatible, the symbols typically are not --- glibc and bsd libc are very different beasts, for one
22:38:47 <allbery_b> that's usually what ports does.  the linuxulator, well, some commercial linux programs don't come with source, and you'd like to be able to run those under emulation (oracle used to be the stress test for the linuxulator...)
22:41:24 <sorear> is linuxulator basically like UML, personalities, WINE, or something completely different?
22:42:44 <allbery_b> personalities, mostly.  the kernel loader recognizes linux (or, on appropriate architectures, Tru64, etc.) executables and sets a flag which switches the syscall handling and path handling (paths try /compat/$emulation/... before /...)
22:43:18 <DracoCepheus> > 2 + 3
22:43:19 <lambdabot>  5
22:43:56 <allbery_b> if the recognition fails there's a way to mark an executable as requiring a specific emulation
22:44:35 <sorear> heh.  "if recognition fails."  stuff like the 45-byte true?
22:45:42 <allbery_b> probably.  I think static linux executables are another example, last I checked (which was a while ago so may be out of date) linux emulation checking looked for an ELF "interpreter" field referencing ld-linux.so.*
22:47:43 <allbery_b> (which was itself a change on the linux side some years back to make *its* ABI emulation foo more reliable, back when people needed iBCS2 emlation to run commercial programs from unixware or sco)
22:49:00 <sorear> heh. we have so few arch/oses now...
22:49:30 <allbery_b> <-- worked on linux iBCS2 BITD
22:49:39 <sorear> BITD
22:49:41 <sorear> ?
22:49:44 <allbery_b> "back in the day"
22:50:03 * sorear activates psychic nm!
22:50:44 <allbery_b> I used SCO at work so had the ability to test stuff and track down un(der)documented behaviors that commercial programs relied on
22:51:44 <sorear> I assume this was perfectly innocent hackery, not like the DOS/Windows intimacy I've heard of?
22:52:55 * allbery_b isnot sure what you're referring to, but nothing illegal was involved and most of the behaviors were just UNIX vs. Linux quirks
23:02:48 <master_bater> i want to learn japanese
23:02:52 <master_bater> but how?
23:05:46 <glguy> ?docs Data.Map
23:05:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
23:06:32 <DracoCepheus> how do i make this point free?
23:06:34 <DracoCepheus> > func2 f g l = filter f (map g l)
23:06:34 <lambdabot>  Parse error
23:07:35 <sorear> ?pl func2 f g l = filter f (map g l)
23:07:36 <lambdabot> func2 = (. map) . (.) . filter
23:08:17 <sorear> there are less extreme degrees of pointlessness
23:08:17 <DracoCepheus> what does pl do ?
23:08:22 <sorear> ?help pl
23:08:23 <lambdabot> pointless <expr>. Play with pointfree code.
23:08:45 <DracoCepheus> interesting
23:08:48 <sorear> > func2 f g = filter f . map g  -- this also works
23:08:49 <lambdabot>  Parse error
23:09:00 <sorear> @type let func2 f g = filter f . map g in func2
23:09:02 <lambdabot> forall b a. (b -> Bool) -> (a -> b) -> [a] -> [b]
23:09:18 <sorear> @type let func2 = liftM2 (.) filter map in func2
23:09:20 <lambdabot> (Bool -> Bool) -> [Bool] -> [Bool]
23:09:27 <DracoCepheus> can everything be point free
23:09:32 <sorear> yes
23:10:05 <allbery_b> sometimes t's more trouble than it's worth though
23:10:08 <sorear> \ nam -> (a) (b)  ==  ap (\nam -> (a)) (\nam -> (b))  -- this is the basic rule
23:10:59 <sorear> extreme point free programming is called the combinatory logic, or the SKI-calculus after the three most commonly used primitives
23:11:16 <sorear> S a b c = a c (b c) ; K a b = a ; I x = x
23:11:42 <sorear> but I can be written as (S K K)
23:11:57 <norpan> @pl \a b c -> a c (b c)
23:11:58 <lambdabot> ap
23:12:09 <sorear> In haskell, S is a special case of ap, which you will often see in pl output.
23:12:41 <sorear> @pl f a b c d e = a (b d) (c e)
23:12:42 <lambdabot> f = ((flip . ((.) .)) .) . (.)
23:14:26 <DracoCepheus> is ap and $ the same?
23:14:33 <sorear> not quite
23:14:37 <sorear> @ty ap
23:14:39 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
23:14:40 <sorear> @ty ($)
23:14:41 <lambdabot> forall b a. (a -> b) -> a -> b
23:15:02 <sorear> for instance, in the special case of functions:
23:15:07 <DracoCepheus> ah i did not get to the monad section of yaht.pdf yet
23:15:15 <sorear> > (\x -> x * 2) $ 12
23:15:17 <lambdabot>  24
23:15:28 <allbery_b> ap is something of an odd use of monads
23:15:47 <allbery_b> the specific monad is "functions of a single argument", otherwise known as ((->) r)
23:15:53 <sorear> monads are just like rings or topological spaces, just abstract structures with a few laws, nothing to be afraid of
23:16:03 <sorear> > (\x -> x * 2) $ 12
23:16:04 <lambdabot>  24
23:16:15 <sorear> > (\n -> (\x -> x * 2)) `ap` (\n -> 12)
23:16:16 <lambdabot>   add an instance declaration for (Show (t -> a))
23:16:32 <sorear> > ((\n -> (\x -> x * n)) `ap` (\n -> 12))  5
23:16:33 <lambdabot>  60
23:16:52 <allbery_b> (of course, the way haskell deals with function arguments, *all* functions are functions of a sinle argument; f a b c = ... is secretly f = \a -> \b -> \c -> ...
23:17:04 <allbery_b> which is how partial function application works)
23:17:05 <sorear> @check \n -> ((\n -> (\x -> x * n)) `ap` (\n -> 12)) n == (\n -> n * 12) n
23:17:06 <lambdabot>  Add a type signature
23:17:14 <sorear> @check (\n -> ((\n -> (\x -> x * n)) `ap` (\n -> 12)) n == (\n -> n * 12) n) :: Int -> Bool
23:17:16 <lambdabot>  OK, passed 500 tests.
23:17:18 <jcreigh> sorear: it seems like telling people who are scared of monads that they're "just like rings or topological spaces" is not going to make them feel any better. :)
23:17:37 * allbery_b knows fvck-all about rings or topological spaces
23:17:39 <DracoCepheus> i have to agree ... ;-)
23:18:52 <ttmrichter> How about telling them they're just monsters?
23:19:30 <allbery_b> there are more fun monsters in haskell, though:
23:19:33 <allbery_b> @quote Help!
23:19:34 <lambdabot> SamB_XP says: I once saw it eat a comment (:[{- Help! -}])
23:19:48 * ttmrichter vaguely remembers seeing a tutorial that treated them that way.
23:20:41 <ttmrichter> I do think this is one of the things slowing up the adoption of FP, though.  A lot of ideas are explained in terms of pure mathematics (lambda calculus, monads, GADTs) and not in terms of practical uses.  This makes it a bit impenetrable for the average newbie.
23:20:46 <DracoCepheus> can someone explain the steps (maybe using SKI) to reduce func2 f g l = filter f (map g l) to the free point expression?
23:20:51 <jcreigh> pah. All the "Monads are like bad analogies" tutorials did nothing for me.
23:22:08 <DracoCepheus> sorry i think i mean 'point free expression' ...
23:22:15 <sorear> sure.
23:22:18 <sorear> @src (.)
23:22:19 <lambdabot> (.) f g x = f (g x)
23:22:45 <sorear> filter f (map g l) == (filter f) ((map g) l)  (by associativity)
23:22:59 <DracoCepheus> ok
23:23:04 <sorear> (.) (filter f) (map g) l  (RHS -> LHS)
23:23:44 <DracoCepheus> the (.) means composition?
23:23:46 <sorear> func2 f g l = (.) (filter f) (map g) l  -->  func2 f g = (.) (filter f) (map g)  (eta reduction)
23:23:50 <sorear> yes.
23:24:06 <DracoCepheus> ok
23:24:22 <sorear> func2 f g = (.) (filter f) (map g)    -->   func2 f g = filter f . map g   (infix syntax)
23:24:50 <sorear> as for the fully pointfree form .... that I'm not so sure of :)
23:25:02 <DracoCepheus> that's ok
23:25:48 <allbery_b> @unpl (filter .) . map
23:25:49 <lambdabot> (\ d g -> filter (map d g))
23:25:54 <sorear> <musing> I know pl works using a large table of rewrite rules like these ; I wonder if it could be modified to give super-verbose output?
23:26:05 <DracoCepheus> why does this expression not work
23:26:06 <allbery_b> hm,not quite
23:26:07 <DracoCepheus> (filter f).(map g) l
23:26:10 <sorear> <musing> @paste-more command
23:26:11 * allbery_b still a beginner :)
23:26:18 <allbery_b> draco: precedence
23:26:33 <allbery_b> (filter f . map g) l
23:26:49 <DracoCepheus> it is the one i tried to get to the point free exp.
23:26:53 <allbery_b> haskell's precedence rules take some getting used to
23:27:40 <DracoCepheus> , i guess application has higher precedence ...
23:27:42 <allbery_b> @pl \f g l -> filter f (map g l)
23:27:42 <lambdabot> (. map) . (.) . filter
23:28:06 <jcreigh> yeah, function application has really high (highest?) precedence.
23:28:09 <sorear> application has precedence 10, which isn't even *available* for user defined operators.
23:28:28 <sorear> I believe . is 9
23:28:31 <DracoCepheus> this is what i wanted ... ((filter f).(map g)) l
23:28:34 <DracoCepheus> thanks
23:28:50 <sorear> Haskell is also fairly unique in having numbered precedence levels.
23:29:17 <sorear> anyway, the :info command in GHCi will tell you what the precedence of an operator is
23:29:23 * allbery_b thinks he sees how that pointfree expression works, maybe
23:30:11 <sorear> generally, trying to pointfree anything with more than two arguments will just result in a mess
23:30:31 <sorear> @quote flip-s
23:30:31 <lambdabot> fishkandy says: xpika, apparently pl also doubles as the command for producing an unintelligible flip-stream :-)
23:41:59 <ttmrichter> What is the ... point ... of pointfree style supposed to be again?  Is it a purity debate issue or is there a practical benefit to it?
23:42:10 <lisppaste2> glguy pasted "woke up to try out my plan for the shortest path algorith" at http://paste.lisp.org/display/35222
23:42:27 * glguy notes that this has not been optimized at all and has ideas
23:42:37 <allbery_b> it's more amenable to optimization, I think
23:42:49 * sorear has written O(n^3) shortest path algos
23:43:09 * sorear wishes gpm treated : as a word character
23:43:34 <ttmrichter> Oh, I see.  That makes sense.  Thanks, allbery_b.
23:43:45 <allbery_b> (that is, it's easier to apply mathematical reasoning to a pure, pointfree expression to optimize it)
23:43:58 * allbery_b thought gpm could be configured
23:44:11 <sorear> It's also easier ... naming variables is hard. :)
23:45:15 <ttmrichter> Not from this old warhorse's standpoint.
23:45:17 <ttmrichter> Decoding executable line noise (which is what most pointsfree code looks like to me at this stage) is far more difficult.  ;)
23:45:49 <allbery_b> right, gpm -l $characters (can include ranges)
23:45:51 <sorear> there's slightly pointfree, and there's very pointfre
23:46:21 <sorear> foo x = a (b (c (d (e (f (g (h (i (j (k (l x)))))))))))
23:47:27 * allbery_b generally does simple pointfree stuff but avoids the fancier stuff (as a rule, ap and flip are warning signs :)
23:47:48 * glguy uses flip for cases like: flip runCont id . callCC $
23:47:55 <allbery_b> mostly because flip tends to occur in stampeding gerds, and ap I havent' fully figured out yet
23:48:02 <allbery_b> *herds
23:48:05 <glguy> when hedoesn't have evalCont = flip runCont id    -- handy
23:50:02 <sorear> allbery_b: thanks!
