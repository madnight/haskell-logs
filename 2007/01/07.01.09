00:00:19 <zeeeeee> manveru: yaht is pretty comprehensive with the core language, if that's the point you're currently at
00:00:19 <manveru> well, i found a whole lot of different tutorials
00:00:22 <zeeeeee> but it may be too slow
00:00:51 <manveru> but somehow they all expect me to know stuff already
00:01:14 <manveru> so now i just scavange some code and change it... seeing what happens
00:01:27 <zeeeeee> manveru: yeah, don't use the 'gentle' introduction or 'teach yourself ... 48 hrs'
00:01:42 <manveru> hehe
00:01:44 <iah> somebody should really rename the "gentle" introduction to something more correct
00:01:51 <zeeeeee> i personally felt the functional core language stuffs was easy to pick up; the thing that hurt me was monads
00:01:54 <manveru> i actually tried the gentle...
00:02:03 <zeeeeee> iah: the author should :)
00:02:07 <manveru> but hell, i had no idea what to do with it
00:02:09 <iah> ?where yaht
00:02:10 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:02:15 <astrolabe> manveru: which bits are giving you problems?
00:02:27 <manveru> astrolabe: what to do with the code they write
00:02:33 <manveru> ghci doesn't run it
00:02:40 <zeeeeee> iah: there's also "http://www.ps.uni-sb.de/~duchier/python/continuations.html"
00:02:42 <lambdabot> Title: Continuations Made Simple and Illustrated
00:02:43 <astrolabe> I meant of the language
00:02:47 <goltrpoat> zee:  eh?  i liked write yourself a scheme in 48 hours
00:02:48 <zeeeeee> what bastards
00:03:04 <manveru> astrolabe: uh, uhm... dunno
00:03:18 <manveru> for example...
00:03:23 <manveru> let x = 10
00:03:24 <astrolabe> manveru: you need to put definitions into a file and load them into ghci
00:03:25 <manveru> vs
00:03:26 <manveru> x = 10
00:03:39 <astrolabe> manveru: ah yes :)
00:03:51 <manveru> i know let from lisp
00:03:58 <astrolabe> I'd recommend you work through yaht
00:04:00 <manveru> but no actual source seems to use it
00:04:20 <Korollary> yes, yaht is quite step by step
00:04:25 <zeeeeee> goltrpoat: its first chapter introduces the IO monad but doesn't explain it at all...
00:04:28 <astrolabe> let has a couple of different meanings in haskell
00:04:36 <iah> "where" is a popular alternative to let, which is maybe why you don't see it much
00:04:38 <zeeeeee> ...which would be fine, if the second chapter didn't throw you even deeper into monads...
00:04:49 <zeeeeee> ...with parsec, an EDSL, no less
00:04:53 <Korollary> try the metatutorial page in the wiki
00:05:35 <zeeeeee> manveru: where == let; perhaps you've seen the former
00:05:42 <mgsloan> > let 1 + 2 = 5 in 1 + 2
00:05:43 <lambdabot>  5
00:05:43 <zeeeeee> iah: er, sorry
00:05:48 <mgsloan> tee hee
00:05:59 <manveru> zeeeeee: i think so, yeah
00:06:05 <astrolabe> zee: that's not quite true
00:06:29 <iah> > a where a = 2
00:06:29 <lambdabot>  Parse error
00:06:37 <iah> > let a = 2 in a
00:06:39 <lambdabot>  2
00:07:02 <iah> let yields an expression; where doesn't
00:07:03 <manveru> astrolabe: another thing was that it took me quite some time to grok that haskell requires indentation
00:07:13 <mgsloan> let is used in expressions, where used on function declarations
00:07:13 <manveru> (except someone wants that fugly format)
00:07:23 * drrho is away: cinema
00:07:27 <zeeeeee> manveru: hmmm...does this have something to do with expressions
00:07:29 <zeeeeee> oh
00:07:43 <mgsloan> You can actually use brackets, but most people prefer white-space layout
00:07:45 <astrolabe> manveru: right.  I'd hope that would be explained in any tutorial.
00:08:00 <manveru> i mean, with python it's popular :)
00:08:14 <manveru> eventually i did read it somewhere
00:08:23 <manveru> they said it requires 8 spaces or something
00:08:30 <manveru> works fine with 2 though...
00:08:37 <astrolabe> manveru: most people choose to use the indentation form, but it's optional.
00:09:20 <manveru> yeah
00:09:26 <iah> i don't think the number of spaces matters
00:09:47 <astrolabe> manveru: right, it is to do with whether the start of things are aligned vertically, or shifted left or right rather than the actuall indentation used.
00:09:49 <manveru> well, i got a phobic against too many brackets and semicolons since PHP
00:10:12 <zeeeeee> details, details... :)
00:10:18 <manveru> :P
00:10:21 <astrolabe> @learn
00:10:21 <lambdabot> http://www.haskell.org/learning.html
00:10:41 <Cale> manveru: I recommend Yet Another Haskell Tutorial
00:10:42 * manveru should read more instead of reading only code
00:10:47 <Cale> @where yaht
00:10:47 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
00:10:50 <manveru> Cale: i'm at it
00:10:53 <Cale> ah, okay
00:11:04 <astrolabe> manveru: yeah, haskell is different enough that that is a good idea.
00:11:08 <Cale> Right, someone suggested it, I missed that :)
00:11:22 <astrolabe> Cale: everyone did ;)
00:12:01 <manveru> astrolabe: well, last thing i learned was dylan and smalltalk... little useful documentation but tons of code
00:12:16 <manveru> so i'm a bit in that habit now :)
00:12:48 <manveru> hmm
00:12:57 <astrolabe> yeah.  hmmmm!
00:13:00 <manveru> one question though before i stop working on that ircbot
00:13:27 <manveru> privmsg h s = do write h ("PRIVMSG " ++ chan) s
00:13:38 <manveru> this only passes the first word
00:13:51 <manveru> coming from
00:13:52 <manveru> eval h x | "!id " `isPrefixOf` x  = privmsg h (drop 4 x)
00:14:19 <vincenz> Lol, on a blog regarding someone wanting to learn haskell "On the down side, let’s see… well, the logo is pretty ugly."
00:14:23 <manveru> i'm not totally sure what this line does
00:14:41 <astrolabe> manveru: you are starting with pretty advanced examples
00:14:50 <iah> well, the | is a guard
00:15:03 <iah> it says, here is a function of two arguments, h and x
00:15:06 <mgsloan> which one? seems like it should pass the full string
00:15:21 <mgsloan> I mean, looks like it works to me
00:15:29 <manveru> well
00:15:37 <manveru> eval h "!quit"                    = write h "QUIT" ":Exiting" >> exitWith ExitSuccess
00:15:37 <iah> if "!id " is a prefix of the second, call privmsg with the handle and the second argument, except without the first four characteres
00:15:38 <astrolabe> maybe if the second word has 4 letters or fewer.
00:15:46 <manveru> this one works, and i know how it works
00:15:58 <iah> s/characteres/characters
00:16:10 <manveru> (or at least i like to imagine i knew :)
00:16:28 <mgsloan> :)
00:16:40 <manveru> hmm
00:16:51 <mgsloan> eval h "!quit" = (write h "QUIT" ":Exiting") >> (exitWith ExitSuccess)
00:16:55 <manveru> iah: alright, but why doesn't it write more then...
00:17:07 <mgsloan> a bit of parenthization
00:17:32 <manveru> mgsloan: >> means... do after?
00:17:38 <mgsloan> both sides of >> return IO actions, which are executed in sequence
00:17:46 <mgsloan> yep, in the context of IO it does
00:18:03 <iah> manveru: i'm not sure why it doesn't write more
00:18:14 <manveru> hmh
00:19:05 <manveru> actually
00:19:10 <manveru> it passes the string
00:19:18 <manveru> > PRIVMSG #rubyforce foobar foo
00:19:19 <manveru> :manveru!n=manveru@pq120.opt2.point.ne.jp PRIVMSG #rubyforce :!id foobar foo
00:19:19 <lambdabot>   Not in scope: `foo'
00:19:27 <mgsloan> haha
00:19:27 <manveru> lambdabot: sorry
00:19:33 <iah> :D
00:19:41 <goltrpoat> she can handle it
00:19:53 <manveru> so let's see...
00:20:14 <manveru> hPrintf h "%s %s\r\n" s t
00:20:22 <manveru> that interpolates s and t to the %s positions
00:20:34 <manveru> and sends it to IO h
00:21:23 <manveru> maybe the problem is the %s
00:21:32 <iah> does it need to be escaped at all?
00:21:33 <manveru> doesn't that mean the whole string?
00:21:50 <iah> it should
00:21:56 <manveru> hmm
00:22:00 <manveru> i can try with ++
00:22:53 <manveru> however, it puts the right stuff on the CLI...
00:23:06 <manveru> maybe some problem with the IRC-protocol
00:23:15 * manveru checks how IRC does multiword
00:24:09 <iah> yeah, printf = hPrintf stdout i imagine
00:24:16 <goltrpoat> oh, i vaguely remember something about this
00:24:20 <goltrpoat> from 12 years ago or so.
00:24:24 <goltrpoat> don't you need a : up front?
00:24:28 <manveru> yeah
00:24:29 <goltrpoat> eg PRIVMSG :multiword sentence
00:24:30 <manveru> that's it :)
00:24:55 <goltrpoat> cool :)
00:24:59 <manveru> however, i try to reuse the usual NICK and USER write...
00:25:08 <manveru> and that doesn't work well with multiword :)
00:25:14 <goltrpoat> ah
00:27:00 <manveru> if that works would be cool :)
00:27:11 <manveru> yay!
00:27:56 <manveru> thank you guys
00:28:30 <manveru> let's write my first type-signature...
00:28:36 <iah> :)
00:28:49 <manveru> privmsg :: Handle -> String -> IO ()
00:28:56 <manveru> :P
00:30:30 <manveru> ok...
00:30:37 * manveru gotta go home
00:31:08 <iah> bye manveru
00:33:33 <benja_> > runListT (lift (return [1,2]) >> (putStrLn "foo" >> putStrLn "bar"))
00:51:40 <therp> do we already have a hoogle keyboard shortcut for emacs? I just wrote one
00:57:27 <astrolabe> ndm is the person to ask, but I think he's at the hackathon
01:00:35 <Masklinn> 'morning
01:03:12 <moconnor> I think I just had an epiphany.  The reason functions that return functions don't have to include parens in the type signature is b/c foo :: a -> b -> c is the same as foo :: a -> (b -> c).  That is, foo taking two arguments and returning a third is the same as foo taking one argument and returning a function that takes another argument and then a result.  Is that about right?
01:06:58 <therp> well, asking whether the community is interested in publishing is more effort than publishing.. so http://clemens.endorphin.org/weblog/archives/2007-01.shtml#e2007-01-09T09_57_26.txt
01:07:06 <Lemmih> moconnor: Yes.
01:08:06 <iah> :t flip
01:08:07 <lambdabot> forall c a b. (a -> b -> c) -> b -> a -> c
01:13:26 <Masklinn> moconnor > yeah that's pretty much the point of having currying built in the core language
01:14:07 <Masklinn> and that's why you can call any function with arity `n` with only `n-k` parameters and it will return another function with arity `k`
01:14:11 <Masklinn> in haskell
01:14:33 <Masklinn> (with 0 <= k <= n of course)
01:15:02 <Masklinn> that's also why one can consider that Haskell functions only ever take a single parameter
01:15:06 <Masklinn> and return a single value
01:15:43 <Masklinn> functions of arity > 1 being built from functions of arity 1 returning other functions of arity 1 until the final calculation (and value) is reached
01:28:16 <Andris> :type fixM
01:28:43 <iah> ?type mfix
01:28:44 <lambdabot> forall (m :: * -> *) a. (MonadFix m) => (a -> m a) -> m a
01:28:54 <Andris> thanks :)
01:28:57 <iah> :)
01:29:07 <Andris> iah: what is the naming convention?
01:29:19 <iah> I'm not really sure
01:29:24 <iah> sometimes it's blahM
01:29:26 <iah> sometimes mblah
01:29:36 <Andris> one of them must be Hungarian
01:29:44 <Andris> I wonder, what is the other one :)
01:31:40 <kosmikus> perhaps m... is used for class methods, whereas ...M is used for "derived" functions?
01:32:43 <iah> oh, that's true
01:32:50 <iah> mfix, mplus, mzero...
01:32:58 <iah> for MonadFix and MonadPlus
01:34:55 <iah> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html#3
01:34:58 <lambdabot> http://tinyurl.com/y25qsm
01:35:13 <iah> A postfix 'M' always stands for a function in the Kleisli category: The monad type constructor m is added to function results (modulo currying) and nowhere else.
01:35:24 <iah> A postfix '_' changes the result type from (m a) to (m ()).
01:35:33 <iah> A prefix 'm' generalizes an existing function to a monadic form.
01:37:02 <Andris> iah: aha, now I remember reading that
01:41:30 <dcoutts> @seen sorear
01:41:53 <notsmack> @botsnack
01:41:54 <lambdabot> :)
01:43:30 <zeeeeee> dons: in yi, there's a function 'eventToChar' with the comment: "This should be gotten rid of, eventually. Do this to enable using Alex lexers. OTOH, we should screw Alex and do proper typing.OTOH, we should screw Alex and do proper typing."
01:44:00 <zeeeeee> i was wondering if you might know what that comment is about; if jyp knows, how do i reach him?
01:45:00 <zeeeeee> @seen jyp
01:45:00 <lambdabot> I saw jyp leaving #haskell 1d 12h 1m 25s ago, and .
01:50:13 <iah> does anyone have an example of how mfix is useful?
01:59:03 <iah> ?src IO mfix
01:59:04 <lambdabot> mfix = fixIO
01:59:08 <iah> ?src fixIO
01:59:09 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
01:59:15 <iah> ?src [] mfix
01:59:15 <lambdabot> mfix f = case fix (f . head) of
01:59:15 <lambdabot>            []    -> []
01:59:15 <lambdabot>            (x:_) -> x : mfix (tail . f)
02:00:05 <matthew_-> ahh! so that's how you look up instances!
02:00:36 <iah> :)
02:00:50 <iah> ?src (->) mfix
02:00:51 <lambdabot> mfix f = \ r -> let a = f a r in a
02:04:08 <matthew_-> is there an "in english" explanation of where instance Monad (->) is useful ?
02:05:50 <matthew_-> ?src (->) (>>=)
02:05:50 <lambdabot> f >>= k = \ r -> k (f r) r
02:05:58 <iah> i use join with (->) sometimes
02:05:59 <matthew_-> -- seems quite strange and/or terrifying
02:06:01 <iah> :t join (*)
02:06:02 <lambdabot> forall a. (Num a) => a -> a
02:06:14 <iah> > join (*) 5
02:06:15 <lambdabot>  25
02:06:26 <matthew_-> yep, I've seen that before and been puzzled...
02:06:42 <iah> ?type join
02:06:43 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
02:07:14 <matthew_-> yes, but why thinking about numbers monadically ?
02:07:27 <iah> so in the ((->) b) monad, that's (b -> b -> a) -> b -> a
02:07:45 <iah> ?src join
02:07:45 <lambdabot> join x =  x >>= id
02:08:14 <Syzygy-> ?pl join (*)
02:08:15 <lambdabot> join (*)
02:08:49 <Syzygy-> (->) b is (b ->) isn't it?
02:08:51 <Andris> > join not True
02:08:51 <lambdabot>  Couldn't match `Bool -> a' against `Bool'
02:09:02 <Syzygy-> > join not otherwise
02:09:03 <lambdabot>  Couldn't match `Bool -> a' against `Bool'
02:09:04 <Andris> > join and True
02:09:05 <lambdabot>  Couldn't match `[Bool] -> a' against `Bool'
02:09:10 <iah> yeah, except sections don't work on type constructors
02:09:24 <tphyahoo> While learning monads, I started pronouncing >>= as "rang rang eek". (right angle, right angle, equal)
02:09:31 <iah> because allowing (-> a) would just be strange
02:09:41 <iah> tphyahoo: haha
02:09:44 <Syzygy-> iah: No it wouldn't. That's just normal dualization...
02:09:47 <tphyahoo> :)
02:09:48 * Syzygy- uses that all the time.
02:10:11 <iah> Syzygy-: whoa, you can do that?
02:10:14 <Syzygy-> Well .. not in programming necessarily .. but in my algebra it's one of the central points.
02:10:21 <iah> oh
02:10:22 <Andris> > join (&&) True
02:10:24 <lambdabot>  True
02:10:36 <iah> > join (++) "hello! "
02:10:37 <Syzygy-> iah: Are you familiar with dual vectorspaces?
02:10:37 <lambdabot>  "hello! hello! "
02:10:45 <Syzygy-> Those are just (V -> k)
02:11:24 <Syzygy-> ?src ((->) Int) join
02:11:24 <lambdabot> Source not found. You speak an infinite deal of nothing
02:11:51 <iah> src isn't part of a typeclass
02:11:53 <iah> er
02:11:54 <iah> join
02:11:57 <iah> ?src join
02:11:57 <lambdabot> join x =  x >>= id
02:12:29 <Syzygy-> ?src (>>=)
02:12:29 <lambdabot> Source not found. Take a stress pill and think things over.
02:12:35 <Syzygy-> ?src [] (>>=)
02:12:35 <lambdabot> m >>= k     = foldr ((++) . k) [] m
02:12:53 <Syzygy-> ?src Maybe (>>=)
02:12:53 <lambdabot> (Just x) >>= k      = k x
02:12:53 <lambdabot> Nothing  >>= _      = Nothing
02:12:54 <Andris> ?src IO (>>=)
02:12:55 <lambdabot> m >>= k     = bindIO m k
02:13:07 <Andris> ?src bindIO -- native? :)
02:13:08 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
02:13:20 <Andris> ?src bindIO
02:13:20 <lambdabot> bindIO (IO m) k = IO ( \ s ->
02:13:20 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
02:13:26 <Andris> oh
02:13:43 <Andris> are these # about unboxed values?
02:13:57 <iah> it's a strict tuple, i think
02:14:21 <Andris> then why are they graphically depicted as boxes? :)
02:14:44 <matthew_-> I thought you couldn't be lazy and unboxed
02:14:57 <matthew_-> so the unboxedness also implies strict. no?
02:15:00 <iah> you can't -- unboxed values are strict
02:15:02 <iah> yeah
02:15:51 <Andris> any other consequences except strictness? performance?
02:16:22 <iah> well it's one fewer level of indirection
02:16:45 * iah hasn't used unboxed values much
02:16:58 <Andris> but observationally it's just like strict value, that's it?
02:17:16 <matthew_-> I use strict fields in ADTs a lot in order so as to be able to unbox them for performance reasons
02:17:34 <Andris> aha
02:18:02 <iah> yeah, ghc will auto-unbox strict fields in some cases
02:18:39 <matthew_-> esp with the -funbox-strict flag ;)
02:18:58 <Andris> so no need to care about them manually?
02:19:12 <Andris> except in FFI, I guess
02:20:09 <norpan> i thought # meant unboxed too
02:20:30 <Andris> oh, found this: http://citeseer.ist.psu.edu/jones91unboxed.html
02:20:38 <matthew_-> yes. it does. the -ddump-simple stuff certainly uses # to mean unboxed
02:20:50 <Andris> it mentions two restrictions on unboxed
02:21:31 <Andris> actually 3
02:22:24 <iah> ah, here
02:22:25 <iah> http://www.haskell.org/ghc/docs/latest/html/users_guide/primitives.html#unboxed-tuples
02:22:27 <lambdabot> Title: 7.2. Unboxed types and primitive operations, http://tinyurl.com/y59rbr
02:22:43 <iah> "Unboxed tuples are used for functions that need to return multiple values, but they avoid the heap allocation normally associated with using fully-fledged tuples. When an unboxed tuple is returned, the components are put directly into registers or on the stack; the unboxed tuple itself does not have a composite representation."
02:23:02 <Andris> cool
02:23:35 <Andris> like values in Scheme?
02:24:45 <ibid> no. scheme values are boxed
02:25:32 <Andris> then what was their value (no pun intended)?
02:26:42 <Andris> I meant something like this: http://citeseer.ist.psu.edu/ashley94ecient.html
02:27:55 <Andris> could not be values/call-with-values done in Haskell using unboxed tuples and CPS?
02:28:29 <iah> you don't need unboxed tuples for that
02:28:45 <norpan> unboxing is just an optimization
02:31:41 <ibid> Andris: unboxed values are what lie in the boxes. they are a (deliberately) exposed implementation detail
02:32:58 <iah> by using unboxed values, you are sacrificing flexibility for speed
02:33:40 <iah> for example, you can't do [Int#]
02:34:00 <Andris> yes, because List is polymorphic
02:34:25 <Andris> but wasn't the whole idea of call-with-values optimization?
02:34:39 <Andris> I never really understood why it was needed
02:34:57 <Andris> as the same goal can be achieved with lambdas
02:35:14 <Andris> and application, of coures
02:35:34 <sieni> ecient?
03:04:31 <tphyahoo> would it be possible to build a haskell in scheme in 48 hours?
03:04:57 <iah> tphyahoo: maybe, but only if your name is simon
03:05:01 <tphyahoo> :)
03:05:16 <tphyahoo> it's actually more or less built on c, right?
03:05:52 <iah> GHC is written in haskell
03:06:04 <tphyahoo> bootstrapped with....
03:06:05 <iah> the runtime system is in C though
03:06:12 <earthy> as are jhc and yhc, right?
03:06:39 <iah> I'm not sure how it was bootstrapped, actually
03:06:41 <iah> maybe via hugs?
03:06:44 <earthy> no
03:07:07 <iah> earthy: how'd they do it?
03:07:13 <earthy> I'd guess by hand
03:07:41 <iah> seems like a lot of work
03:08:24 <earthy> or possibly from miranda
03:08:29 <tphyahoo> kind of like, how was multicellular life bootstrapped.... nobody knows.
03:08:51 <iah> ah, I bet it was bootstrapped from miranda
03:09:05 <earthy> oh, the simons know
03:09:48 <earthy> and compiling a simple compiler from scratch by hand isn't all that hard
03:09:51 <tphyahoo> :src take
03:09:57 <earthy> just takes time
03:09:59 <tphyahoo> ?src take
03:09:59 <lambdabot> take n _      | n <= 0 =  []
03:10:00 <lambdabot> take _ []              =  []
03:10:00 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
03:10:48 <tphyahoo> > take 3 [1,2]
03:10:50 <lambdabot>  [1,2]
03:11:22 <tphyahoo> ?src zipwith
03:11:23 <lambdabot> Source not found. That's something I cannot allow to happen.
03:11:27 <tphyahoo> ?src zipWith
03:11:27 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
03:11:28 <lambdabot> zipWith _ _      _      = []
03:12:45 <tphyahoo> > take 2 zipwith (+) [1,2,3] [1,2,3]
03:12:45 <lambdabot>   Not in scope: `zipwith'
03:12:51 <tphyahoo> > take 2 zipWith (+) [1,2,3] [1,2,3]
03:12:52 <lambdabot>      The function `take' is applied to five arguments,
03:12:52 <lambdabot>     but its type `Int ...
03:13:06 <tphyahoo> > take 2 ( zipWith (+) [1,2,3] [1,2,3] )
03:13:07 <lambdabot>  [2,4]
03:13:58 <iah> > take 2 . join . zipWith (+) $ [1..]
03:13:59 <lambdabot>  Couldn't match `[b] -> a' against `[c]'
03:14:15 <tphyahoo> > take 2 $ zipWith (+) [1,2,3] [1,2,3]
03:14:16 <lambdabot>  [2,4]
03:14:22 <iah> > take 2 . (join (zipWith (+))) $ [1..]
03:14:24 <lambdabot>  [2,4]
03:15:03 <iah> ?pl join $ zipWith (+)
03:15:04 <lambdabot> join (zipWith (+))
03:15:20 <tphyahoo> what does ?pl do?
03:15:34 <iah> ?help pl
03:15:34 <lambdabot> pointless <expr>. Play with pointfree code.
03:15:53 <dcoutts> @pl \x y z -> x (y z)
03:15:53 <lambdabot> (.)
03:15:54 <iah> ?pl f a b c = c b a
03:15:55 <Jaak> @pl f x = x
03:15:55 <lambdabot> f = flip (flip . flip id)
03:15:55 <lambdabot> f = id
03:16:25 <iah> ?check \x -> join (zipWith (+)) x == map (*2) x
03:16:26 <lambdabot>  Add a type signature
03:16:42 <iah> ?check (\x -> join (zipWith (+)) x == map (*2) x) :: [Int] -> Bool
03:16:43 <lambdabot>  OK, passed 500 tests.
03:16:48 <Jaak> @pl \x -> x + x -- heh
03:16:49 <lambdabot> join (+)
03:16:55 <tphyahoo> ?help join
03:16:56 <lambdabot> join <channel>
03:17:08 <tphyahoo> :h join
03:17:13 <tphyahoo> :info join
03:17:19 <iah> ?src join
03:17:19 <lambdabot> join x =  x >>= id
03:17:23 <iah> ?hoogle join
03:17:23 <lambdabot> Monad.join :: Monad a => a (a b) -> a b
03:17:24 <lambdabot> Control.Monad.join :: Monad m => m (m a) -> m a
03:17:24 <lambdabot> Data.PackedString.joinPS :: PackedString -> [PackedString] -> PackedString
03:17:41 <iah> ?. do src join
03:17:42 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "do"
03:17:55 <tphyahoo> ?info return
03:17:56 <lambdabot> return
03:18:01 <iah> ?. redo src join
03:18:02 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
03:18:11 <tphyahoo> ?src return
03:18:11 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
03:18:23 <iah> the source of return depends on the monad instance
03:18:26 <iah> ?src [] return
03:18:27 <lambdabot> return x    = [x]
03:18:59 <iah> ?src IO return
03:18:59 <lambdabot> return x    = returnIO x
03:19:04 <iah> ?src Maybe return
03:19:04 <lambdabot> return              = Just
03:19:18 <tphyahoo> but there's no generalized case.
03:19:24 <tphyahoo> interesting.
03:20:16 <iah> ?redo \x -> x >>= id
03:20:16 <lambdabot> \ x -> do { a <- x; id a}
03:20:31 <iah> ?. pl redo x >>= id
03:20:31 <lambdabot> (line 1, column 4):
03:20:31 <lambdabot> unexpected "{"
03:20:31 <lambdabot> expecting variable, "(", operator or end of input
03:20:50 <ulfdoz> tphyahoo: Perhaps, because it is specific to the implementation of the class Monad.
03:21:05 <dcoutts> @seen ndm
03:21:05 <lambdabot> I saw ndm leaving #haskell.hac07, #ghc, #haskell-overflow, #haskell-blah and #haskell 16h 52m 39s ago, and .
03:21:41 <tphyahoo> ulfdoz: you mean, to each monad. right?
03:21:52 <ulfdoz> tphyahoo: yes.
03:22:33 <dcoutts> @tell ndm here's your gtk2hs build: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.4-ghc-6.6-gtk-2.10.zip you need to edit *.package.conf, setting ${GTK_BASE_PATH} and ${pkglibdir} appropriately
03:22:33 <tphyahoo> the monad classes appear not to be "linked" in any kind of way involving inheritance or composition. only that they obey the monad laws.
03:22:34 <lambdabot> Consider it noted.
03:23:12 <iah> tphyahoo: that's correct
03:23:26 <iah> (and i think you mean monad instances)
03:23:46 <ohmega> is pointfree always considered better? most examples seem more non-obvious to me in pointfree style
03:24:06 <iah> ?pl \f (a, b) -> (f a, f b)
03:24:07 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
03:24:23 <ohmega> right
03:24:25 <iah> in other words, definitely not :)
03:24:44 <ohmega> ?pl \x -> x+x+x
03:24:44 <lambdabot> (+) =<< join (+)
03:24:55 <ohmega> that also seems worse
03:25:15 <iah> it's at least a little comprehensible if you know about the ((->) a) monad
03:25:29 <iah> but yeah, \x -> x + x + x is better
03:26:20 <iah> or sum . replicate 3
03:26:25 <iah> or even (*3) :)
03:26:41 <iah> pl isn't smart enough for that though
03:26:52 <ohmega> it was just a random example from the wiki ;)
03:27:34 <ohmega> ?pl \x y z -> f (g x y z)
03:27:34 <lambdabot> ((f .) .) . g
03:27:38 <ohmega> that's kind of cool syntax
03:27:59 <therp> ?pl \x y z -> y z
03:28:00 <lambdabot> const id
03:28:14 <therp> interesting
03:29:33 <tphyahoo> is it possible to dissect the lambdabot?
03:29:41 <tphyahoo> :src :src
03:29:42 <iah> ?pl f a b c d = a b (c d)
03:29:42 <lambdabot> f = ((.) .)
03:30:19 <iah> ?where lambdabot
03:30:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
03:30:37 <iah> the source is on that site
03:30:47 <tphyahoo> ?help where
03:30:48 <lambdabot> where <key>. Return element associated with key
03:33:28 <iah> ?unpl ((.) .)
03:33:28 <lambdabot> (\ d g b c -> d g (b c))
03:33:42 <iah> ooh, not bad
03:34:14 <iah> ?unpl ((.).(.))
03:34:14 <lambdabot> (\ i b c f -> i (b c f))
03:34:42 <iah> ?unpl (. return) . (:)
03:34:42 <lambdabot> (\ d g -> ((:)) d (return g))
03:34:43 <sieni> ?unpl ((.)(.))
03:34:43 <lambdabot> (\ b c e f -> b c (e f))
03:34:57 <ohmega> ?unpl :-)
03:34:57 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}: Parse error
03:35:21 <iah> ?unpl a &&& b
03:35:22 <lambdabot> (a &&& b)
03:35:33 <iah> ?unpl (. (f .)) . (.)
03:35:34 <lambdabot> (\ i l e -> i (f (l e)))
03:38:16 <pbx> Really boring Haskell question: I finally got 6.4.2 installed on my FreeBSD box; but there's something wonky with terminal settings as ^D and ^H produce, well, stuff that looks like that instead of actually working. Is there a .ghcirc or similar hook for tweaking this?  Searches have not been very productive so far...
03:38:42 <sieni> is it compiled against readline?
03:39:12 <iah> pbx: i remember there being some problem with the freebsd port and readline
03:39:19 <iah> you could try searching the irc logs
03:40:00 <pbx> iah: thanks
03:40:45 <pbx> Given that it's not urgent I think I'll just sit on it (or use hugs) until the 6.6 port is ready.  http://www.mail-archive.com/haskell@haskell.org/msg19685.html
03:40:46 <lambdabot> Title: Re: [Haskell] (CLARIFICATION) ghci readline support on FreeBSD: simple p
04:35:56 <masklinn> #quote
04:35:59 <masklinn> @quote
04:36:12 <masklinn> ?quote
04:36:12 <lambdabot> Baughn says: I think I'm beginning to understand this language. I just defined 1+1=3.
04:36:17 <masklinn> ?quote
04:36:18 <lambdabot> ski says:  "please talk to your son or daughter about parametric polymorphism"
04:36:22 <masklinn> ?quote dons
04:36:23 <lambdabot> dons says: Don "If it ain't pure, it ain't functional" Stewart
04:37:35 <Lemmih> ?keal
04:37:36 <lambdabot> are you saying i am MegaMonad?
04:47:49 <ski> (masklinn : that quote was actually not from me .. taken from a person on usenet)
04:48:01 <kowey> ooh neat, haddock just grew a "Source code" button
04:53:38 <vincenz> woo
04:53:46 <vincenz> 1 day, 7 users in haskell.dut...well...6 and lambdabot
04:54:28 <augustss> ?users
04:54:28 <lambdabot> Maximum users seen in #haskell: 299, currently: 280 (93.6%), active: 28 (10.0%)
04:54:42 <vincenz> 10% activity rate
04:54:44 <Lemmih> .dut?
04:54:46 <vincenz> dutch
04:55:06 <vincenz> for the .nl'ers and flemish .be'ers
04:57:18 <hyrax42> kowey: where?
04:57:36 <kowey> hyrax42: look at the Haskell libs, any module on top
04:57:53 <hyrax42> ?doc prelude
04:58:05 <hyrax42> ?docs Prelude
04:58:05 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
04:58:12 <kowey> next to "Contents | Index"
04:58:18 <hyrax42> I see it
04:58:20 <hyrax42> nice
04:58:36 <hyrax42> would be slightly nicer if you could jump straight to defn of a function
04:58:56 <hyrax42> which would need source in some html form, so might as well syntax colour it while you're at it
05:01:53 <bakert> Anyone used Network.HTTP?  Do you know how to send parameters in a POST request?  I put it in rqBody to no avail.
05:06:32 <bakert> ?seen bringert
05:06:36 <kzm> How do people debug concurrent programs?
05:06:53 <earthy> kzm: by proving properties and inspecting traces.
05:07:15 <kzm> Hmm... -prof? Or are there better ways?
05:07:27 <bakert> @seen bringert
05:07:27 <lambdabot> I saw bringert leaving #haskell.hac07 and #haskell 4h 36m 8s ago, and .
05:07:28 <Botje> kzm: -prof is for profanity :)
05:07:52 <kzm> Thank, but I already have that :-)
05:09:04 <kzm> My concurrent program is slightly slower (wall clock) on two CPUs than on one.
05:09:21 * kzm sighs.
05:10:17 <earthy> and that surprises you?
05:10:19 <kzm> Oh, -s
05:10:39 <kzm> Well, I'd expect it to be take 50-100% of the time.
05:10:48 <earthy> more chances for synchronization overhead
05:11:04 <earthy> plus, if the problem is mostly sequential anyway, the context switches only eat time
05:11:18 <earthy> (yes, there are limits to parallelizability)
05:11:24 <kzm> I'm using TChans, btw.  The problem is quite parallel, I think.
05:11:41 <earthy> you think or you know? :)
05:11:54 <kzm> Hmm... all threads refer a common data structure - does it matter whether it's a thunk or fully evalutated?
05:12:20 <kzm> Yes, I think I know.  You think I don't? :-)
05:12:22 <augustss> kzm: it will get evaluated on demand
05:12:36 <kzm> Right - so there's nothing to be gained from explicitly evaluating it, then.
05:12:59 <kzm> Wish I had a 4-cpu box to test on as well.
05:13:01 <augustss> kzm: no
05:13:14 <augustss> kzm: or very, very little
05:13:28 <kzm> Anyway -s output shows that work is shared fairly evenly among a handful of threads, so perhaps it's not so bad.
05:18:15 <kzm> With TChan, is there any kind of flow control?  Or will it fill to arbitrary size?
05:18:43 <kzm> Perhaps I should use an MVar instead?
05:24:09 <wolfgangbeck> kzm: the doc says 'unbounded' somewhere
05:24:23 <kzm> Hm. Okay.
05:24:24 <wolfgangbeck> kzm: so I'd guess there is no flow control
05:24:44 <augustss> wolfgangbeck: you'd have to make your own
05:25:31 <wolfgangbeck> unbound = your bugs will show only show up in extreme circumstances
05:26:32 <wolfgangbeck> can't find a function that tells how big a TChan queue is
05:27:01 <xpika> does my idea constructor synonyms sound appealing to anyone?
05:28:22 <xpika> also are there any preprocessors for that kind of thing?
05:54:08 <bakert> I worked out my POST problem (well, I cheated and used formToRequest but same difference)
06:02:39 <xpika> is there anything faster than a UArray?
06:03:07 <kzm> an unevaluated thunk?
06:03:08 <kzm> :-)
06:03:30 <kzm> (Generally, UArrays are fast.  Get an extra percent by using unsafeAt)
06:03:36 <xpika> ** googles thunk
06:04:02 <kzm> (perhaps I should have said 'expression'?)
06:04:10 <Spark_> i thought a thunk was a wrapper around legacy code
06:04:12 <Spark_> in general
06:05:48 <bakert> What's the simplest way to replace all commas in a String?
06:06:03 <bakert> I've found subRegex and I could use filter but there must be something nicer!
06:06:10 <bakert> (maybe not)
06:06:31 <wolverian> list comprehensions, I suppose, but filter is pretty simple as it is.
06:06:39 <earthy> > map (\x -> if x == ',' then '!' else x) "this, is, a, test,"
06:06:40 <lambdabot>  "this! is! a! test!"
06:06:46 <wolverian> er, yeah, map, not filter.
06:07:43 <earthy> but, bakert, you have underspecified what you want. :)
06:07:58 <bakert> I want to turn "3,000.00" -> 3000.0
06:08:07 <bakert> First step, remove any commas!
06:08:38 <earthy> owh, yeah, that's filter (!= ',')
06:08:55 <bakert> > filter (\x -> x /= ',') "3,000"
06:08:56 <lambdabot>  "3000"
06:08:59 <bakert> huzzah!
06:09:06 <earthy> > filter (/= ',') "3,000.00"
06:09:07 <bakert> ok i'll make a little function called replace
06:09:07 <lambdabot>  "3000.00"
06:09:13 <bakert> ooooh your one is better
06:09:21 <resiak> > (read $ filter (/= ',') "3,000.00") :: Float
06:09:22 <lambdabot>  3000.0
06:09:22 <bakert> i need to learn that trick.
06:09:32 <earthy> it's called 'slicing'
06:09:51 <bakert> it's all tied up with that "." stuff that i haven't quite got around to yet.
06:10:02 <bakert> need to get the idioms in
06:10:20 <bakert> resiak, earthy, wolverian, thanks!
06:11:15 <mgdm> I like it how for many of these problems it seems that you get 10 responses within seconds each shorter than the last :)
06:11:16 <earthy> bakert: do you know anything about Unix shell pipelines?
06:11:30 <bakert> yeah.
06:11:43 <bakert> i do really get it.  it's more a case that i don't think to do it like that.  do you know what i mean?
06:12:25 <earthy> cat file | sort | uniq    is roughly   uniq . sort . readlines
06:12:26 <bakert> i think i need to read more haskell code.  i was reading "things to avoid" this morning on haskell.org and that was helping.
06:12:58 <earthy> yes, reading more helps
06:21:33 <hayleyk100> hi does anyone know how to convert a text file into a table in haskell?
06:22:05 <Lemmih> table?
06:22:09 <pitecus> what is a table?
06:23:20 <chessguy> pitecus, usually has 4 legs, chairs around it, food on it...
06:23:38 <hayleyk100> for exmple if a sentence was read in that said " the house was red and had a blue door" it would insert it and break it down into .....
06:23:48 <hayleyk100> begin [the].....
06:24:02 <hayleyk100> until the last item has been read
06:24:22 <pitecus> insert what where?
06:24:33 <chessguy> > words "the house was red and had a blue door"
06:24:34 <pitecus> and what is an item? a word?
06:24:34 <lambdabot>  ["the","house","was","red","and","had","a","blue","door"]
06:24:37 <chessguy> is that what you mean?
06:24:45 <hayleyk100> yes thankyou
06:24:53 <chessguy> that's a list, by the way
06:25:15 <bakert> >words "what: about punctuation;^^%*I\""
06:25:21 <pitecus> doesnt have any chairs around, so clearly isn't a table
06:25:24 <hayleyk100> have you heard of N Grams
06:25:40 <bakert> > words "what: about punctuation;^^%*I\""
06:25:41 <lambdabot>  ["what:","about","punctuation;^^%*I\""]
06:25:46 <chessguy> bakert, bah, just filter it first
06:25:52 <kowey> hayleyk100: you sound like a statistical NLP guy
06:25:57 <chessguy> or after, if you want. that's not an issue
06:25:59 <bakert> chessguy, just wondered how it treated it ...
06:26:25 <chessguy> it uses spaces for the delimiter
06:26:30 <bakert> i see that now!
06:26:46 <hayleyk100> no i'm a student and very stuck on a projecti just wanted to know if anyone had any ideas
06:27:12 <pitecus>  let xs = words "the house was red and had a blue door" in zip xs (tail xs)
06:27:12 <pitecus> [("the","house"),("house","was"),("was","red"),("red","and"),("and","had"),("had","a"),("a","blue"),("blue","door")]
06:27:21 <pitecus> that gives you bigrams
06:27:26 <chessguy> bakert, there are similar functions to break on other delimiters
06:27:34 <bakert> interesting
06:28:31 <bringert> that was easy homework
06:28:54 <bringert> hi bringert_
06:29:05 <bringert_> hello
06:29:55 <vincenz> @quote vincenz.*homework
06:29:55 <lambdabot> No quotes match. This mission is too important for me to allow you to jeopardize it.
06:30:04 <vincenz> @quote homework
06:30:04 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
06:30:05 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
06:30:11 <vincenz> @quote vincenz*homework
06:30:12 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
06:30:16 <vincenz> @quote vincenz.homework
06:30:16 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
06:30:29 <vincenz> grr
06:30:42 <earthy> @quote homework
06:30:43 <lambdabot> dons says: [In reference to <joelr1> did you guys know that #ocaml has 37 members and #erlang has 34 vs. 202 on #haskell?] I think part of the #haskell success comes from the approach that we all
06:30:43 <lambdabot> know each other, it's not a homework channel like #java. We created a community of peers, working on the overall goals of the community. That's why people keep coming back
06:30:44 <bakert> hello bringert -- are you the bringert that maintains the HTTP.Browser module?
06:30:54 <vincenz> @quote vincenz homework
06:30:55 <lambdabot> vincenz says: sure, give us your homework and we'll email it straight to your teacher :)
06:31:02 <vincenz> ah, regexp interface is gone
06:31:11 <bringert> bakert, yes, me and bringert_
06:31:22 <resiak> Your clone grew a tail?
06:31:25 * earthy laughs
06:31:37 * bringert_ tries to check
06:31:47 <bakert> bringert, thanks for that i am using it currently -- i have a couple of teensy patches to send you shortly
06:31:51 <bringert_> the chair keeps spinning around when I try to turn
06:32:05 <bakert> @quote vincenz.*homework
06:32:05 <lambdabot> No quotes match. And you call yourself a Rocket Scientist!
06:32:10 <bakert> oh
06:32:28 <chessguy> haha
06:32:29 <bringert_> bakert: ok, sounds good
06:32:36 <chessguy> smart-alec bot
06:32:43 <vincenz> Who! We surpassed #haskell.fr in #haskell.dut
06:32:48 <vincenz> in 1 day :)
06:32:55 <bakert> what is #haskell.dut?
06:32:59 <vincenz> dutch
06:32:59 <bakert> dutch?
06:33:14 <kowey> :-)
06:33:20 <kowey> 1/3 of #haskell.fr are from the same lab
06:33:46 <kowey> oh well... i guess we're doing ok, for the land of ocaml
06:33:49 <bakert> i thought the dutch called themselves something altogether different?  shows what i know
06:33:56 <bakert> nederlander or something
06:34:01 <vincenz> bakert: you don't get it
06:34:06 <vincenz> bakert: it's related to the language, to be country-independent
06:34:07 <bakert> vincenz, you are damn right!
06:34:13 <vincenz> so it's both for the belgians and the nederlanders
06:34:33 <bakert> vincenz, oh ... some belgians speak dutch.  they go in for their languages there i know that.
06:34:42 <bringert_> bakert: it needs more docs for sure
06:34:45 <bakert> vincenz, so what is dutch for dutch?
06:34:47 <vincenz> bakert: I'm one of those and started the channel
06:34:59 <vincenz> bakert: and it's not that "some belgians speak dutch"
06:35:08 <vincenz> half of belgium speaks flemish which is nearly isomorphic to dutch
06:35:11 <bakert> bringert, yeah i had trouble working out a POST request because the example only does GET!
06:35:12 <vincenz> it's like uk and us english
06:35:13 <pitecus> hi kowey. I think I know you...
06:35:31 <vincenz> what did you think they spoke in belgium? belgian???
06:35:33 <kowey> pitecus: hi! from where?
06:35:38 <bakert> vincenz, flemish i knew about but i never knew it had that relationship to dutch.  something new every day, etc.
06:35:43 <pitecus> ACL in Sydney
06:35:45 <vincenz> bakert: it's the same language
06:35:51 <vincenz> bakert: just like "american" and "english"
06:35:58 <kowey> oh!
06:35:59 <bakert> vincenz, don't all the belgians want to rename it #haskell.flem?
06:36:01 <bakert> !
06:36:17 <vincenz> bakert: it was .be and I didn't want .nl (I started it, I'm belgian) .dut is the official code for the language
06:36:55 <bringert_> or like hindi and urdu
06:37:03 <bringert_> except those use different scripts
06:37:48 <bakert> bringert, hindi and urdu are the same?  crazy i never knew that and here i am with an A-level that is part Urdu.
06:38:39 <kowey> pitecus: what kind of stuff do you work on?
06:38:48 <bringert_> bakert: I don't know either of them, but yeah, they're said to be the same except for the script and load words
06:39:08 <bringert_> similiar to the serbian/bosnian/croatian situation I guess
06:39:17 <bringert_> the differences are mostly political
06:39:20 <pitecus> kowey, Treebank-based grammar acquisition and such
06:39:38 <bringert_> but you can make some people quite angry by pointing that out
06:39:42 <chessguy> Treebank?
06:39:54 <pitecus> kowey, Djame Seddah used to work at our lab
06:40:14 <bringert_> pitecus: are you a phd student?
06:40:22 <pitecus> yeah
06:40:44 <bringert_> how many computational linguistics (etc) phd students are here?
06:40:52 <pitecus> chessguy, treebank is a collection of syntactic parse trees
06:40:53 <bakert> Regular expressions with all the \\ escaping are unpleasant.  Has anyone got a nicer way?
06:40:53 <bringert_> I know kowey, pitecus and me
06:41:11 <chessguy> pitecus, hmm. sounds interesting
06:41:30 <bringert_> bakert: write a preprocessor :-)
06:41:31 <kowey> pitecus: but you're not now in Dublin? (i've narrowed you down to about 4 people, I think :-) )
06:42:03 <bakert> bringert_, that sounds like too much work.  I'm a day behind as it is.  Learning haskell as you go doesn't do much for deadline hitting!
06:42:09 <pitecus> kowey, I am still in dublin
06:42:40 <bringert_> bakert: what's the project?
06:43:37 <bakert> bringert_, I'm writing a reconciliation system that visits a bunch of web pages, checks our balances and various other things and stores them in a db.  Later it will be able to compare it's findings with the main system and report any discrepencies.
06:43:50 <bakert> So we don't lose lots of money and not notice ;)
06:43:59 <pitecus> kowey, that might help you: http://computing.dcu.ie/~gchrupala
06:44:01 <kowey> aha! (google) well hi again, and hi to the dublin-connection (sorry for the chatter, #haskell /me goes back to work)
06:44:01 <lambdabot> Title: Grzegorz Chrupała @ DCU
06:44:06 <bringert_> bakert: nice
06:44:19 <bringert_> bakert: I'm sorry the HTTP docs are so lacking
06:44:36 <bakert> Well, it sounded dull when I thought of doing it in python.  So I made it more fun by learning haskell at the same time!
06:45:05 <bakert> Unfortunately I am going to need to do SOAP before the end.  But I am postponing that horror as I think there is no Haskell SOAP lib.
06:45:34 <bakert> Perhaps I'll write it and publish it, but only if I have time.  Otherwise I'll have to call some commandline app or something grotesque like that!
06:46:53 <bakert> docs are fine, as far as they go.  i'm just glad there was something out there at all!
06:47:16 <bakert> wouldn't have wanted to write all that myself to scrape 23 web pages.
06:47:36 <bringert_> didn't someone work a a SOAP lib?
06:47:57 <bringert_> bakert: it uses SOAP to talk to an existing system?
06:48:12 <bakert> there's some half-formed thing as part of some other lib i think.  i feel like it's called HNESIA or something (but that's probably erlang affecting my brain)
06:48:28 <bringert_> HAIFA
06:48:31 <bakert> bringert_, yeah, SOAP to an existing and totally unchangeable public 3rd party thing
06:48:47 <bakert> HAIFA yes that's it.  more israel than database!
06:49:00 <bringert_> bakert: if it's only a single call, you could fake it I guess
06:49:50 <bringert_> so HAIFA doesn't work?
06:49:59 <bakert> one or two calls to two different systems.  either i will fake it with a teensy app in python/ruby/something and call that in some crappy way from haskell or i will go mad and write a beautiful SOAP library for haskell that only I will ever use because SOAP sucks.  All depends on the boss.
06:50:04 <bringert_> I've never had to use SOAP, so I haven't tested it
06:50:37 <bakert> HAIFA's web page is VERY circumspect about the SOAP part ... it sounds like something that was never finished from what they say.  I will give it a go before giving up on it altogether.
06:54:10 <bakert> Is there any regex stuff for haskell that recognizes \d ?
06:54:17 <bakert> Or is it [0-9] only?
06:54:38 <bakert> Or is it [0-9] only
06:54:41 <bakert> (oop)
06:57:50 <allbery_b> there's a regex-pcre package you can install
06:58:10 <bakert> allbery_b, thanks.  i guess i should just go with the standard library for the sake of a teeny thing like that.
06:58:17 <bakert> just me being picky.
06:58:40 <bakert> One thing I am curious to know is, is there a nice little dead-simple web framework like web.py for haskell?
06:59:18 <bakert> I need to create a one-pager that just alllows 4 inputs and puts the result in a db.  Just need the most unfeatureful web app lib in the universe.
07:03:11 <wolfgangbeck> bakert: perhaps http://homepages.paradise.net.nz/warrickg/haskell/http/ ?
07:03:14 <lambdabot> Title: Haskell HTTP Implementation
07:08:26 <ClaudiusMaximus> @hoogle unfold
07:08:28 <lambdabot> List.unfoldr :: (a -> Maybe (b, a)) -> a -> [b]
07:08:28 <lambdabot> Data.List.unfoldr :: (b -> Maybe (a, b)) -> b -> [a]
07:08:28 <lambdabot> Data.Tree.unfoldForest :: (b -> (a, [b])) -> [b] -> Forest a
07:08:46 <ClaudiusMaximus> @hoogle unfoldM
07:08:47 <lambdabot> No matches found
07:16:22 <kowey> bringert: do you think Aarne Ranta would have any interest in a demo of GenI? (he's visiting next Monday)
07:16:41 <kowey> (we're being asked if we'd like to meet him, so i'm wondering if it'd be appropriate that i propose such a demo)
07:17:09 * kowey assumes he's not on #haskell
07:17:47 <allbery_b> > let unpe xs = unpe' xs []; unpe' [] rs = rs; unpe' ('\\':'d':xs) rs = unpe' xs (rs ++ "[0-9]"); unpe' ('\\':'w':xs) rs = unpe' xs (rs ++ "[0-9a-z_]"); unpe' ('\\':x:xs) rs = unpe' xs (rs ++ "\\" ++ [x]); unpe' (x:xs) rs = unpe' xs (rs ++ [x]) in unpe "_\\d\\w*"\
07:17:47 <lambdabot>  Parse error
07:17:55 <allbery_b> > let unpe xs = unpe' xs []; unpe' [] rs = rs; unpe' ('\\':'d':xs) rs = unpe' xs (rs ++ "[0-9]"); unpe' ('\\':'w':xs) rs = unpe' xs (rs ++ "[0-9a-z_]"); unpe' ('\\':x:xs) rs = unpe' xs (rs ++ "\\" ++ [x]); unpe' (x:xs) rs = unpe' xs (rs ++ [x]) in unpe "_\\d\\w*"
07:17:57 <lambdabot>  "_[0-9][0-9a-z_]*"
07:18:19 <allbery_b> (quick thinmg to map \d and \w to standrd regexes :)
07:19:25 <flux__> > let unpe xs = unpe' xs []; unpe' [] rs = rs; unpe' ('\\':'d':xs) rs = unpe' xs (rs ++ "[0-9]"); unpe' ('\\':'w':xs) rs = unpe' xs (rs ++ "[0-9a-z_]"); unpe' ('\\':x:xs) rs = unpe' xs (rs ++ "\\" ++ [x]); unpe' (x:xs) rs = unpe' xs (rs ++ [x]) in unpe "\\\\d"
07:19:26 <lambdabot>  "\\\\d"
07:19:53 <flux__> hm, unexpectedly, it works :-)
07:20:11 <allbery_b> you didn't notice the '\\':x:xs case? :)
07:20:31 <flux__> I didn't really read it over, just made the first assumption ;-)
07:21:07 <kowey> bringert: sorry for the random thinking aloud, nevermind :-)
07:23:04 * allbery_b is prone to dumb mistakes, but that's not normally one of them
07:33:24 <bakert> ?hoogle Double -> Int
07:33:25 <lambdabot> No matches, try a more general search
07:33:32 <bakert> ?hoogle Fractional -> Int
07:33:33 <lambdabot> No matches, try a more general search
07:33:40 <bakert> ?hoogle Fractional a => a -> Int
07:33:41 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:33:41 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:33:41 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:34:01 <bakert> > floatDigits 200.0
07:34:03 <lambdabot>  53
07:34:09 <bakert> hell that's not what i want!
07:34:10 <allbery_b> ?hoogle (Fractional a, Integral b) => a -> b
07:34:11 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
07:34:11 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
07:34:11 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
07:34:14 <allbery_b> !
07:34:19 <allbery_b> :t truncate
07:34:20 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
07:34:34 <allbery_b> ?hoogle (RealFrac a, Integral b) => a -> b
07:34:35 <lambdabot> Prelude.ceiling :: (RealFrac a, Integral b) => a -> b
07:34:36 <lambdabot> Prelude.floor :: (RealFrac a, Integral b) => a -> b
07:34:36 <lambdabot> Prelude.round :: (RealFrac a, Integral b) => a -> b
07:34:41 <bakert> round 200.0
07:34:46 <bakert> > round 200.0
07:34:47 <lambdabot>  200
07:34:53 <bakert> > round 200.7
07:34:54 <lambdabot>  201
07:34:56 <bakert> cool
07:34:59 <bakert> that will do nicely
07:35:26 <bakert> thanks allbery_b
07:37:24 <bakert> ?hoogle (a -> Bool) -> a -> b -> c -> d
07:37:26 <lambdabot> No matches, try a more general search
07:42:56 <Axioplase> Hi !
07:46:49 <sjanssen> @yow
07:46:49 <lambdabot> I have many CHARTS and DIAGRAMS..
07:47:12 <sjanssen> bakert: a function with that type will always result in _|_
07:47:53 <bakert> sjanssen, my ideas were a bit half-formed when I did that search.
07:47:57 <bakert> I seem to have the pattern:
07:48:04 <sjanssen> perhaps you mean (a -> Bool) -> a -> b -> b -> b
07:48:04 <bakert> case blah of
07:48:10 <bakert>    Nothing -> return Nothing
07:48:37 <bakert>     (Just x) -> return $ superblah x
07:48:41 <Axioplase> what would be a *simple* GUI to read/write text in a window ?
07:48:45 <bakert> I was looking for a way of saying that in one line.
07:48:46 <jethr0> fmap f x
07:48:53 <jethr0> fmap superblah x
07:49:16 <sjanssen> bakert: fmap or maybe are two good possibilities
07:49:55 <sjanssen> bakert: and you're in some sort of monad, right?
07:49:58 <Cale> Axioplase: using which library?
07:50:28 <bakert> sjanssen, i am.  basically i am visiting a website to do various things if any fail i might as well stop but if they don't then do the next one until i end up with four results.
07:50:54 <bakert> i am in the BrowserAction monad which is a State monad alike from HTTP.Browser
07:51:05 <bakert> and i have that pattern of code in three places.
07:51:08 <Axioplase> Cale: whatever is easy
07:51:22 <bakert> so i was thinking about how to make things conciser (is that a word?)
07:51:31 <earthy> more concise
07:51:31 <sjanssen> more concise, I think
07:51:50 <bakert> i wrote that first but i replaced it with conciser because it was conciser!
07:51:57 <earthy> more concise. :)
07:52:00 <sjanssen> bakert: do you know how the fail function behaves in this monad?
07:52:18 <bakert> sjanssen, i don't even know what the fail function is.  week 3 of haskell!
07:52:24 <bakert> :(
07:52:24 <sjanssen> @type fail
07:52:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
07:52:53 <sjanssen> bakert: the Monad class has a concept of failing actions
07:52:56 <bakert> does that give me the ability to return a String error message up to the top.  That would be good.  "Nothing" is not that informative.
07:52:57 <bakert> ?
07:53:23 <sjanssen> in the IO monad (fail "yikes") will result in a program that raises a "yikes" exception
07:53:38 <bakert> (i am going to owe so much to the karmic #haskell pool soon that i will have to spend ten years on here explaining monads, once i understand them)
07:53:59 <bakert> sjanssen, ok so that's cool.  i they have to "catch" at the top to stop that halting my program right?
07:54:14 <sjanssen> bakert: right
07:54:20 <bakert> so i should probably "fail" not "Nothing" for when the website is down or something unexpected like that.
07:54:22 <vegai> bakert: that's how the rest of us got stuck here, too
07:54:30 * vegai bangs on the walls
07:54:42 <bakert> vegai, lol*
07:54:48 <sjanssen> bakert: sounds like a good plan to me
07:54:59 <bakert> * = i know lol is out of fashion with non-teenagers, but i did lol!
07:55:16 <Cale> Axioplase: well, Gtk2Hs is probably the best-supported GUI library. However, at the moment, the release for 6.6 hasn't yet happened.
07:55:31 <bakert> sjanssen, wicked.  what about my original thing of the recurring case statements?
07:55:31 <Cale> Axioplase: there's WxHaskell too, that's not so bad.
07:55:39 <vegai> the release candidate version of gtk2hs seems to work okish, however
07:55:40 <bakert> sjanssen, fmap or maybe you said
07:55:48 <bakert> i will look into those.
07:56:03 <dcoutts> vegai, what platform did you try it on?
07:56:08 <bakert> do i need "return fail" or can i just "fail"
07:56:13 <sjanssen> bakert: fmap is like map for lists, but generalized to all sorts of containers
07:56:21 <vegai> dcoutts: arch linux
07:56:22 <sjanssen> bakert: just fail "some message"
07:56:28 <Axioplase> Cale: ok, then I'll give a try to gtk2hs I guess
07:56:33 <vegai> dcoutts: though I didn't do anything complex
07:56:41 <sjanssen> @type fmap -- apply a function to all items in a container
07:56:42 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
07:56:47 <dcoutts> vegai, what ghc & gtk+ version bte?
07:57:00 * dcoutts is trying to get some idea of our test coverage
07:57:12 <dcoutts> bte/btw
07:57:19 <vegai> gtk2-2.10.6-1, ghc-6.6
07:57:26 <dcoutts> vegai, ta
07:57:41 <ndm> dcoutts, hpc?
07:57:46 <SimonRC> Hands up everyone who didn't know that local fixity declarations were allowed.
07:58:04 <dcoutts> ndm, hpc? we're talking about the latest gtk2hs rc
07:58:05 <vegai> You should've known; you're a Simon
07:58:13 <SimonRC> vegai: ???
07:58:21 <vegai> SimonRC: just a local joke, nevermind ;)
07:58:22 <ndm> dcoutts, haskell program coverage, to see what test coverage you have
07:58:34 <dcoutts> SimonRC, when you say local, you mean local to a module, not local to a decl ?
07:58:40 <dcoutts> ndm, ah I see
07:59:00 <dcoutts> ndm, that might be handy, can one combine results from several test progs?
07:59:08 <ndm> dcoutts, yes
07:59:19 <dcoutts> ndm, I should look into that some time then
07:59:20 <ndm> dcoutts, it was very much designed to do that
07:59:37 <dcoutts> good, because gtk2hs is a very wide & flat api
07:59:46 <dcoutts> it's hard to get good coverage
08:00:11 <Cale> Axioplase: okay, http://darcs.haskell.org/gtk2hs/demo/hello/World.hs shows how to set up a simple window with a button on it.
08:00:14 <ndm> and automated GUI testing is a pain
08:00:32 <Cale> It shouldn't be too hard to extend that to having a textbox in it.
08:00:35 <malebria> dcoutts: What's the difference between --enable-mozilla, --enable-seamonkey and --enable-firefox?
08:01:00 <malebria> dcoutts: is there a way to get all apis?
08:02:00 <SimonRC> dcoutts: no i mean that you can actually have e.g. infixl declarations inside a where clause
08:02:39 <dcoutts> malebria, no, it builds against only one, if you ask for several then it just picks one.
08:03:20 <dcoutts> malebria, they're not all necessarily binary compatible and they pull in different shared libs so you can only really build against one
08:03:28 <malebria> dcoutts: the package generated is always mozembed, right?
08:03:33 <dcoutts> malebria, yep
08:03:46 <Axioplase> Cale: thanks. I was reading the gtk2hs blog's documentation
08:03:49 <malebria> dcoutts: wouldn't it be better to generate three packages, or this is not possible?
08:04:16 <bakert> So, no one knows of a haskell equivalent to ruby's webbrick or something like web.py?
08:04:23 <earthy> nope.
08:04:37 <Cale> Axioplase: dcoutts here is the guy to talk to if you have any trouble with Gtk2Hs :)
08:04:39 <dcoutts> malebria, it seems like overkill. And usually it doesn't really matter which it get's built against. It'd also cause problems for apps that want to depend on the mozembed haskell package.
08:04:41 <earthy> HappS is somewhat more fullfeatured. ;)
08:04:42 <bakert> there's a project for me when i know my way around a bit better.
08:04:47 <vegai> bakert: HAppS is not like either of those, but might help you anyway
08:05:10 <malebria> dcoutts: but isn't it bad to have three versions of the same package with different functions?
08:05:13 <bakert> vegai, sounds good.
08:05:29 <dcoutts> malebria, they don't have different functions, the Haskell API is always the same.
08:05:49 <dcoutts> it just gets linked with different C libs (though they also provide the same C api)
08:06:10 <malebria> dcoutts: hum.. ok then.
08:06:15 <dcoutts> it's just 4 different potential implementations of the same stable C api
08:06:38 <malebria> dcoutts: I'm trying to build with --enable-mozilla in debian sid, and I have mozilla installed, but I'm getting:
08:06:44 <dcoutts> generally you should go with the one with the latest security fixes, so that's probably firefox
08:06:45 <malebria> checking for MOZILLA_MOZEMBED... configure: error: Mozilla requirement not met. Perhaps you need to install mozilla or mozilla-devel
08:06:49 <malebria> I have mozilla-dev installed.
08:07:02 <dcoutts> malebria, does it provide a .pc file ?
08:07:10 <dcoutts> that's what we need
08:07:20 <malebria> dcoutts: I have to search for that. Is it mozilla.pc?
08:07:48 <dcoutts> malebria, pkg-config --list-all | grep moz
08:08:11 <dcoutts> malebria, for example on my system I get seamonkey-gtkmozembed and firefox-gtkmozembed
08:08:32 <pejo> dcoutts, happen to know offhand if there is anything more recent than the book by Sestoft et al. that gives a reasonable overview of PE?
08:08:36 <dcoutts> malebria, locate gtkmozembed.pc
08:08:38 <malebria> dcoutts: ok, I'll search for it.
08:09:07 <dcoutts> pejo, I don't, I think after that it's just reading papers
08:09:16 <malebria> http://packages.debian.org/cgi-bin/search_contents.pl?word=gtkmozembed.pc&searchmode=searchword&case=insensitive&version=unstable&arch=amd64
08:09:18 <lambdabot> Title: Debian -- Debian package contents search results, http://tinyurl.com/yj4n23
08:09:27 <malebria> icedove and libxul
08:09:28 <vegai> dcoutts: btw, if you care about gtk2hs platforms... I'm currently building gtk2hs-0.9.10.3 on x86/solaris
08:09:32 <vegai> and ghc6.6
08:09:54 <dcoutts> vegai, oh, interesting. tell me if it works out. I can only test sparc/solaris
08:10:01 <Botje> @pl \(x1,y1) (x2,y2) -> (x1`div`10 == x2`div`10) && (y1`div`10 == y2`div`10)
08:10:03 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. ((. (`div` 10)) . (==) . (`div` 10))) . flip . (((.) . (&&)) .) . (. (`div` 10)) . (==) . (`div` 10))
08:10:07 <pejo> dcoutts, someone needs to write a good overview of the field. *cough*
08:10:09 <Botje> that's horrible.
08:10:22 <dcoutts> pejo, aye
08:10:45 <malebria> dcoutts: is it libxul?
08:11:00 <dcoutts> malebria, that'd be --enable-xulrunner I think
08:11:01 <vegai> dcoutts: seems like solaris has converged with linux rather well. I'd be surprised if it acted differently in this regard
08:11:29 <dcoutts> vegai, aye, I'm using solaris 9 with lots of old package
08:11:50 <malebria> dcoutts: enable-xulrunner is a replacement for enable-mozilla?
08:12:11 <dcoutts> malebria, right, you can build against mozilla, firefox, seamonkey and xulrunner
08:12:39 <malebria> dcoutts: it seems to me that xulrunner is the only one available in sid. This should be in ./configure --help and in INSTALL.
08:12:40 <dcoutts> malebria, though I'd only really recommend firefox & seamonkey at this point due to security issues
08:12:46 <malebria> This option.
08:13:01 <pejo> dcoutts, thanks though.
08:13:11 <dcoutts> malebria, I just added xulrunner info to INSTALL actually
08:13:18 <malebria> dcoutts: =D
08:13:36 <malebria> dcoutts: it's strange that debian doesn't have and iceweasel-gtkmozembed.pc...
08:13:43 <dcoutts> malcolmw, yes, that's odd
08:13:47 <dcoutts> oops
08:13:59 <dcoutts> malebria, ^^ sorry, tab completion on irc names
08:14:52 <bos_> @users
08:14:53 <lambdabot> Maximum users seen in #haskell: 304, currently: 300 (98.7%), active: 39 (13.0%)
08:15:05 <bos_> wow, big crowd this morning.
08:15:13 <malebria> dcoutts: I'm doing a debian package of it.
08:15:24 <malebria> dcoutts: In author I should put your name, right?
08:15:26 <glguy> ?users
08:15:26 <lambdabot> Maximum users seen in #haskell: 304, currently: 300 (98.7%), active: 40 (13.3%)
08:15:29 <glguy> wow
08:15:30 <dcoutts> malebria, of gtk2hs you mean?
08:15:31 <glguy> ?users
08:15:31 <lambdabot> Maximum users seen in #haskell: 304, currently: 300 (98.7%), active: 40 (13.3%)
08:15:59 <dcoutts> malebria, yeah, me and axel, see http://haskell.org/gtk2hs/development/#authors_and_acknowledgements
08:16:01 <lambdabot> http://tinyurl.com/ycs6n2
08:16:30 <mgdm> I'm about to go back to Haskell after a wee while, but using the book "The Haskell Road to Logic and Programming" - does anyone have any comments on that book, out of interest?
08:17:53 <vegai> mgdm: I see that book as a way to learn math rather than Haskell
08:17:54 <bakert> @localtime bos_
08:17:55 <lambdabot> Local time for bos_ is Tue Jan  9 08:13:13
08:18:34 <dcoutts> malebria, apparently the mozilla-dev package from stable contains mozilla-gtkmozembed.pc
08:18:48 <malebria> dcoutts: the one from stable yes.
08:18:56 <mgdm> vegai: That's one of the objectives, I want to get back into maths and learn Haskell while I'm doing it - I was wondering if I'd end up missing out on parts of Haskell that I should know about
08:18:57 <vegai> mgdm: but then again, I know a bit of Haskell already and none of math ;)
08:19:00 <bos_> mgdm: what are you trying to do with haskell?
08:19:08 <bos_> ok.
08:19:14 <dcoutts> malebria, perhaps you can ping the firefox/iceweasle maintainers to see why it's missing the .pc files
08:19:21 <Cale> vegai: I actually agree, and I have a BMath degree :)
08:19:42 <beelsebob_> @vixen asl?
08:19:42 <lambdabot> 19/f/California
08:19:59 <beelsebob_> @vixen do you like dcoutts... that way?
08:19:59 <lambdabot> yah, i like
08:20:24 <Cale> It is a decent book, but probably a little boring if you already know the math in it.
08:20:29 <dcoutts> @slap lambdabot
08:20:29 * lambdabot smacks lambdabot about with a large trout
08:20:47 <beelsebob_> ohhh... that's my module
08:20:50 <beelsebob_> but less rude
08:20:55 <mgdm> Cale: I don't, which is handy :)
08:21:00 <Cale> okay :)
08:21:12 <vegai> I have that one on my todo-list as well
08:21:28 <mgdm> Also most of the stuff in there seems to be things that were never covered in the maths I did at uni
08:21:56 <vegai> it's not hard, but requires a sort of self-discipline I don't currently have
08:22:41 <mgdm> vegai: The reason I'm finally doing it is because of a New Year's resolution to improve self discipline :)
08:22:56 <Axioplase> dcoutts: hum.. with gtk2hs, I quite dont get how to make a multiline text entry. Isn't it entry I should use ? (I don't get how to set its height)
08:23:22 <dcoutts> Axioplase, for multi-line text you need the TextView and TextBuffer
08:23:33 <dcoutts> the Entry is a simple one line thing
08:23:51 <Axioplase> Ha. I missed the textView..
08:23:56 <vegai> mgdm: good luck with that ;)
08:23:58 <malebria> dcoutts: I don't know that much about mozilla and pkg-config even to ask them why it's missing.
08:24:07 <therp> hm. I have no clue what to do when core lint rejects desugared code.. hm
08:24:17 <mgdm> I've had the book for a year now and not done anything with it
08:24:53 <vegai> heh, same here
08:25:02 <dcoutts> malebria, well the main point is that most packages these days have the .pc file which allows other apps to use pkg-config to get the right gcc clflags and libs to be able to compile&link against them
08:25:17 <dcoutts> malebria, eg there are ones for gtk+ and all the gnome and X stuff
08:25:40 <malebria> dcoutts: but maybe they think that the xulrunner one is enough for mozilla/firefox/seamonkey...
08:25:55 <dcoutts> malebria, but that only allows you to link to xulrunner, not the others
08:26:18 <malebria> dcoutts: I can't find libsvg-cairo. Do you know a file name to search?
08:26:45 <dcoutts> malebria, you'll see if you run: pkg-config --cflags --libs xulrunner-gtkmozembed
08:27:22 <dcoutts> malebria, it might not be packaged for debian any more, it was only transitional, I need to update it to use rsvg instead. So if we can't find it don't worry.
08:28:02 <malebria> dcoutts: so you think I should package without --enable-svg-cairo ?
08:28:11 <dcoutts> malebria, yes
08:28:11 <bakert> Is -- a comment in a cabal file, too?
08:28:16 <dcoutts> bakert, yes
08:28:44 <bakert> ta
08:29:32 <dcoutts> malebria, in the next release that haskell package will use >=librsvg-2.16
08:29:59 <bakert> hmm that didn't help.  trying to build HaXml.  Complains that Unknown field hs-source-dirs.  Any ideas?
08:30:27 <malcolmw> bakert: use cabal to build HaXml, rather than the makefiles
08:30:31 <dcoutts> bakert, what version of ghc and cabal? I suspect your cabal version is too old
08:31:06 <bakert> dcoutts, how can i tell what version of cabal?
08:31:13 <dcoutts> ghc-pkg list Cabal
08:31:25 <bakert> 1.0
08:31:39 <bakert> is that bad
08:31:40 <bakert> ?
08:32:09 <daniel_larsson> 1.1.7 here, so sounds old
08:32:27 <malebria> dcoutts: it there an --enable-soegtk option?
08:32:39 <therp> are there any instructions on how to interpret GHC core lint output?
08:32:46 <malebria> dcoutts: Or it's implicit?
08:32:57 <dcoutts> malebria, no, that's automatic it can always build
08:33:18 <bakert> Can I use ghc-pkg to update my version of Cabal?
08:33:37 <ndm> bakert: windows or linux?
08:33:54 <ndm> @where windows
08:33:55 <lambdabot> I know nothing about windows.
08:34:01 <bakert> ndm, linux
08:34:12 <ndm> http://www-users.cs.york.ac.uk/~ndm/projects/windows.php
08:34:13 <lambdabot> Title: Neil Mitchell - Windows Packages
08:34:26 <ndm> bakert: that page has instructions on how to do it at the bottom of the page, should work on linux as well
08:34:42 <bakert> ndm, dcoutts, thanks!
08:34:43 <ndm> the gray box right at the bottom
08:35:07 <ndm> (although i totally couldn't figure how to update cabal on Hugs!)
08:44:37 <clanehin> ndm: is this correct, yhc doesn't import orphan instances?
08:44:51 <ndm> clanehin: no idea... - should it?
08:44:54 <bakert> ndm, thanks the instructions worked.
08:45:41 <clanehin> Control.Monad.Fix imports an orphan instance from Control.Monad.Instances, and in fact I think all of Control.Monad.Instances are orphans
08:46:12 <malebria> dcoutts: I got a error in make, so I think it's a problem with ./configure
08:46:15 <ndm> do they show up in the .hi file?
08:46:23 <malebria> dcoutts: ghc-6.6: unknown package: mtl
08:46:25 <bakert> What's regex-compat-any?
08:46:32 <ndm> Yhc should just import everything from the .hi file, the question is does it get that far?
08:46:46 <dcoutts> malebria, ah yes, configure doesn't yet check for the existance of the mtl package
08:46:55 <dcoutts> malebria, so that's also a dep
08:47:13 <dcoutts> malebria, libghc6-mtl-dev
08:47:16 <JaffaCake> can someone else try http://hackage.haskell.org/trac/ghc, it's hanging for me
08:47:17 <lambdabot> Title: GHC - Trac
08:47:26 <clanehin> ndm, I'm looking . . .
08:47:28 <dcoutts> JaffaCake, ok here
08:47:33 <JaffaCake> thanks
08:47:38 <ndm> fine for me too
08:47:45 <JaffaCake> right, must be a problem here then
08:48:33 <malebria> dcoutts: I know. Are you going to add this to configure?
08:48:47 <dcoutts> malebria, yes, but if you install it, it'll work
08:49:05 <bakert> ?hoogle regex-compat-any
08:49:05 <lambdabot> Hoogle Error: Parse Error: Unexpected character '-compat-an'
08:49:05 <dcoutts> the workaround is easy, but yes I'll fix it
08:49:14 <bakert> ?hoogle Data.ByteString.Char8
08:49:15 <lambdabot> No matches, try a more general search
08:49:19 <malebria> dcoutts: I just added this to deps.
08:49:28 <clanehin> ndm, I'm not sure exactly how hi files work, but everything is a NEED, it doesn't seem to export anything itself
08:49:43 <clanehin> I mean syntax wise, I'm not 100%
08:50:13 <clanehin> at the least, there is no reference to the instances that I need
08:50:14 <malcolmw> clanehin: if yhc is like nhc98, then it will not export an instance of a Prelude class for a Prelude type, unless you force it with the -prelude option
08:50:15 <ndm> clanehin: me neither, to be honest - do the instances show up in Control.Monad.Instances ?
08:50:16 <bakert> Is Data.ByteString.Char8 a new innovation?
08:50:29 <dcoutts> bakert, relatively new yes, since ghc-6.6
08:50:31 <ndm> malcolmw: what about non-prelude instances?
08:50:43 <malcolmw> non-prelude instances should be fine
08:50:44 <LPhas> hi dcoutts
08:50:52 <ndm> bakert: Hoogle doesn't search package names, but i guess it could - Data.ByteString is too new to be in Hoogle yet
08:50:56 <clanehin> ndm, what do you mean?
08:51:05 <dcoutts> LPhas, hi
08:51:21 <LPhas> dcoutts, i've a question for you
08:51:23 <bakert> dcoutts, drat ... 6.4.1 ... i guess i better upgrade.  Is there a debian/ubuntu repository anywhere?  Or does everyone just darcs it and build it?
08:51:25 <malcolmw> ndm: although I'm not certain
08:51:37 <ndm> clanehin: do the instances exported by Control.Monad.Instances show up in the .hi file for that
08:51:42 <LPhas> i'm try to bind something that makes lage use of gtk's datatypes
08:51:47 <dcoutts> bakert, for older ghc versions you can install the 'fps-0.8' package separately
08:51:53 <LPhas> lile gint, glist and so on
08:51:56 <clanehin> ndm, no that's the one I was just looking at
08:52:00 <bakert> dcoutts, hmm ... i thought i did that
08:52:02 <dcoutts> LPhas, right
08:52:14 <ndm> clanehin: are they in there? even as NEED clauses, i guess?
08:52:20 <LPhas> there's in gtk2hs avalaible functions to marshal those datatypes?
08:52:21 <bakert> perhaps i just need to tell the compiler that somehow?
08:52:27 <dcoutts> bakert, well if you've got fps-0.8 then you've got Data.ByteString etc
08:52:53 <dcoutts> LPhas, yes, that's mostly what gtk2hs's glib package does
08:53:00 <bakert> dcoutts, do i need to do anything when compiling to make it available or should it be there after a "sudo runhaskell Setup.lhs install"?
08:53:07 <ndm> clanehin: either Tom or malcolmw are likely to be the only ones who know about that kind of thing
08:53:10 <LPhas> dcoutts, ok thx
08:53:27 <dcoutts> LPhas, things like gint are trivial of course, but we do have support for GList and GSList and other more complicated things
08:53:39 <LPhas> maybe a day hmp3 will support ipod bwhawha
08:53:48 <LPhas> (i'm trying to bind libgpod)
08:53:59 <dcoutts> bakert, it should be there, run ghc-pkg list to see if fps is listed.
08:54:06 <clanehin> ok I'll look at adding -prelude
08:54:21 <malcolmw> clanehin: I suggest re-compiling Control.Monad.Instances with the -prelude flag
08:54:27 <ndm> clanehin: i believe that does some other weird stuff, -prelude is a very special flag...
08:54:27 <bakert> dcoutts, yeah it's listed
08:54:32 <bakert> fps-0.8
08:54:41 <bakert> curious
08:54:44 <clanehin> ndm, I'll see if I can get it to set anything on fire, then :)
08:54:51 <bakert> "Could not find module `Data.ByteString.Char8'"
08:55:26 <dcoutts> bakert, that is curious, try ghc-pkg describe fps-0.8
08:55:36 <dcoutts> bakert, see what modules it claims it exports
08:55:38 <bakert> when i try to compile HApps. Perhaps something to do with "cannot satisfy dependency regex-compat-any"
08:55:48 <bakert> i removed regex-compat from the list of dependencies.
08:55:51 <bakert> then i get that error.
08:56:27 <dcoutts> bakert, did you re-run the configure
08:56:28 <clanehin> malcolmw, that seems to work for the moment, thanks
08:56:34 <bakert> $ ghc-pkg describe fps-0.8 tells me it exposes Data.ByteString.Char8
08:57:05 <dcoutts> bakert, so you get that error when trying to build HApps? try adding fps to the list of deps
08:57:11 <bakert> dcoutts, configure won't complete with regex-compat in there.  With it in there it completes fine.  But build then fails with the Char8 error.
08:57:22 <bakert> dcoutts, where is the list of deps?  in the cabal file for happs?
08:57:29 <dcoutts> bakert, like you removed regex-compat from the list, just add fps to the list.
08:57:33 <dcoutts> yes the .cabal file
08:59:40 <bakert> aha!  seems to be working ... or at least, it's got further.  Thanks dcoutts
08:59:45 <dcoutts> np
09:00:22 <Axioplase> dcoutts: Can I show you a simple layout problem I have ?
09:00:29 <dcoutts> Axioplase, ok
09:00:37 <lisppaste2> Axioplase pasted "simple layout" at http://paste.lisp.org/display/34634
09:00:41 <malebria> ghc-6.6: unknown package: mtl (dependency of cairo-0.9.10.4)
09:00:52 <bakert> dcoutts, hilariously at some stage in the build it says: "Warning: Module `Data.ByteString.Char8' is imported, but nothing from it is used"!!!  but it is still going!
09:00:59 <malebria> dcoutts: even with libghc6-mtl-dev package installed.
09:01:11 <dcoutts> malebria, did you re-run configure?
09:01:38 <malebria> dcoutts: yes.
09:02:30 <malebria> dcoutts: ghc-pkg list shows mtl-1.0
09:03:09 <dcoutts> Axioplase, you need to play with the expand and fill packing properties of the big and small areas, you want the small one to not fill and not expand
09:03:13 <dcoutts> malebria, hmm
09:03:42 <Axioplase> dcoutts: ha. thanks..
09:03:57 <dcoutts> malebria, rm package.conf.inplace or make clean
09:05:33 <malebria> dcoutts: I've extracted the tarball to other place and I'm trying to build it again.
09:05:54 <malebria> dcoutts: but this is a bug, right?
09:07:20 <bakert> huzzah i have hello world running in HAppS.
09:08:42 <dcoutts> malebria, I don't think there is any bug. Certainly configure is missing the check for mtl, but I think the mtl vs mtl-1.0 issue is just an artifact of the build going wrong earlier due to missing mtl.
09:09:59 <dcoutts> malebria, when the cairo package was registered locally in package.conf.inplace, mtl was not resistered and so cairo got registered as depending on 'mtl'. If mtl-1.0 had been installed at the time then ghc-pkg would have registered cairo as depending on mtl-1.0
09:10:19 <kjdf> |
09:10:43 <dcoutts> malebria, sadly we have to register using --force anyway, so we miss out on a bit of error checking (like the fact that mtl isn't installed)
09:15:12 <malebria> dcoutts: but when I rerun configure shouldn't  it fix package.conf.inplace?
09:15:49 <dcoutts> malebria, perhaps it should, but at the moment only make clean does that.
09:15:56 <malebria> hum..
09:16:31 <malebria> dcoutts: This was what I asked if it's not a bug.
09:17:38 <dcoutts> malebria, I don't follow
09:19:59 <malebria> dcoutts: I asked if isn't it a bug not to change it when ./configure is rerun.
09:20:10 <dcoutts> hrm, maybe
09:20:30 <dcoutts> the more important bug is that configure doesn't check for mtl
09:20:38 <dcoutts> if it did you'd never run into the problem
09:21:24 <malebria> sure.
09:29:02 <mikael> hey, what's up with Control.Monad.State in ghc 6.6?
09:29:08 <mikael> (it doesn't exist)
09:30:20 <Lemmih> mikael: It's in 'mtl'.
09:30:57 <vincenz> Cale: PING!
09:32:02 <glguy> mikael: Gentoo?
09:32:21 <mikael> no, debian
09:32:34 <glguy> ah, maybe it breaks the extralibs into a second package also
09:37:18 <Igloo> mikael: You ned libghc6-mtl-dev
09:40:24 <Z4rd0Z> I'm trying to use the HSQL module, and the connect function returns an IO Connection, but the API commands all seem to want a Connection object
09:42:40 <bos_> Z4rd0Z: connect (blah blah) >>= \connection -> doStuff connection
09:43:02 <bos_> orbitz: do connection <- connect (blah blah); doStuff connection
09:43:18 <bos_> i meant "or", not "orbitz" :-)
09:43:26 <bos_> xchat being a bit too helpful.
09:43:37 <Z4rd0Z> oh, dammit, it's that whole IO monad thing
09:44:30 <bos_> yes.
09:44:44 <bos_> if something returns IO Foo, it needs to happen in the IO monad.
09:44:58 <Z4rd0Z> ok
09:45:38 <Z4rd0Z> If I can get past that, I might be able to get something done :)
09:49:00 <bos_> it's easy enough.
09:53:44 <Lemmih> It's funny (and somewhat ironic) that some people think monads are an unfortunate side-effect of have no side-effects.
09:53:53 <vincenz> heh
09:53:59 <vincenz> today I saw a case where monads would've been perfect
10:04:23 <bakert> thanks for your help today folks.  tomorrow, a fully working web app under HAppS.
10:05:29 <dmhouse> Can anyone think of propositions P and Q such that P implying Q would tell you that P is true?
10:05:29 <Axioplase> How can I test whether and handle points to a file or a directory ?
10:05:46 <dmhouse> This is part of something called Peirce's law, which I'm struggling to understand.
10:06:41 <sjanssen> Axioplase: a Handle can't point to a directory
10:06:48 <ibid> "would tell you" is ambiguous.  are you saying that P is an unknown proposition? but then why do i have to imagine a P such that ...?
10:06:50 <dmhouse> (Peirce's law: ((P -> Q) -> P) -> P; this is callCC by the C-H isomorphism.)
10:07:06 <dmhouse> ibid: I'm saying find statements P, Q, such that (P -> Q) -> P.
10:07:15 <dmhouse> So P implying Q forces P to be true, if you like.
10:07:28 <Axioplase> sjanssen: err. yes.. I meant a FilePath
10:07:51 <ibid> well, take P = true, Q = true for example
10:07:53 <Axioplase> looks like filtering with doesFileExist does the job
10:08:07 <ibid> dmhouse: remember that implication is not causality :)
10:08:12 <sjanssen> @hoogle doesDirectoryExist
10:08:12 <lambdabot> Directory.doesDirectoryExist :: FilePath -> IO Bool
10:08:27 <dmhouse> ibid: well, okay, that's a degenerate case. I'm looking for more interesting examples that might actually help me to see why Peirce's law is true.
10:09:00 <ibid> dmhouse: well, it's a propositional calculus formula, make up the truth table
10:09:42 <dmhouse> ibid: that's wonderful, but logical laws like that should be understandable when applied to real-world situations. I'm trying to understand why it's true.
10:09:42 <ibid> dmhouse: i think you are trying to make sense of it as if implication was causality. it isn't.
10:09:48 * dmhouse has to go to dinner anyway.
10:10:02 <ibid> dmhouse: why is false -> P true?
10:11:54 <ibid> dmhouse: your answer to that question might help me figure out what kind of a "why" you are looking for
10:14:23 <ibid> sleep, bbl
10:18:54 <vincenz> (P -> Q) -> P is not a valid statemen
10:19:04 <vincenz> (false -> true) -> false
10:19:07 <vincenz> true -> false
10:19:47 <emu> but that's ok for peirce's law
10:20:01 <vincenz> not if I understood dmhouse's explanaton
10:20:11 <emu> if you understand implication..
10:20:21 <vincenz> I do
10:20:27 <vincenz> and true -> false is not a valid implication
10:20:34 <vincenz> but It hink he forgot to put the extra -> P in his words
10:20:39 <vincenz> ((P -> Q) -> P) -> P is vlaid
10:20:42 <emu> right
10:30:41 <paolino> good evening, how I import two modules in hugs ?
10:31:57 <paolino> seems it has loaded them but I can access only one
10:33:27 <iulus> paolino: looks like :also might do what you want
10:34:18 <iulus> oh, I guess maybe not...
10:34:27 <paolino> it did load the second , but the first disappeard from the namespace
10:34:28 <glguy> I just demonstrated to my boss that when he gives me more interesting projects, he gets faster results
10:34:33 <glguy> now lets see if he learns
10:34:34 <glguy> ..
10:34:39 <dmhouse> vincenz: not quite
10:34:55 <dmhouse> vincenz: I was searching for statements P and Q such that (P -> Q) -> P is true.
10:35:02 <dmhouse> vincenz: then it should be the case that P is true.
10:35:12 <glguy> more peirce's law?
10:35:46 <dmhouse> vincenz: in other words, I should only be able to find a _true_ P such that (P -> Q) -> P.
10:39:03 <astrolabe> paulino: maybe import one into the other?
10:39:53 <iulus> spse P is false. Then P -> Q is true, so True -> False, which is a contradiction, so P is true, right?
10:39:53 <paolino> astrolabe, by loading a custom file you mean
10:42:45 <paolino> what is the complexity of nub ?
10:42:57 <iulus> @src nub
10:42:58 <lambdabot> nub = nubBy (==)
10:43:04 <iulus> @src nubBy
10:43:04 <lambdabot> nubBy eq []             =  []
10:43:05 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
10:43:34 <astrolabe> O(n^2)?
10:43:35 <Jaak> n^2 most likely
10:43:41 <sjanssen> paolino: O(n^2)
10:43:42 <dmhouse> iulus: I've seen proofs for the law, I understand them, but not _why_ the law is true or what it means.
10:44:24 <astrolabe> paulino: that would do it (too)
10:45:29 <malebria> dcoutts: it seems that plus.gif is not on htmldoc_DATA on Makefile.am
10:46:14 <emu> well there's only 2 variables
10:46:18 <paolino> nub $ take 300 $ randomRs (0,10::Int)  gives 75000 reductions
10:46:19 <paolino> nub $ take 3000 $ randomRs (0,10::Int) gives  750000
10:46:19 <paolino> what is wrong with this test on complexity ?
10:46:19 <emu> just try the combinations ;)
10:46:37 <emu> dmhouse: you are looking for an "Interpretation" and the standard interpretation for Propositional calculus is truth-tables
10:46:49 <iulus> dmhouse: I figured it out. spse ~p, then ~(p -> q), so ~(~p v q), (~~p ^ q), ~~p ^ ~p (contracition). Therefore, p.
10:47:11 <iulus> (I wouldn't be content until I figured it out)
10:47:15 <sjanssen> paolino: I don't think reductions are a reliable measurement
10:47:34 <iulus> Therefore, (p->q)->p  -->  p
10:48:13 <sjanssen> paolino: also, nub tends to perform better when there are few unique elements
10:48:37 <sjanssen> (ie, try randoms instead of randomRs)
10:48:39 <paolino> probably is O(n^2) on the worst case, where all elements are different
10:49:20 <sjanssen> yes.  Best case is O(n)
10:49:44 <paolino> when the different elements are k the complexity is O (k*n)
10:49:51 <sjanssen> and restricting your values to a finite range makes it O(k*n)
10:50:05 <paolino> ok
10:50:25 <glguy> nub implemented with a Set is n log n, right?
10:50:30 <glguy> n = length
10:50:35 <sjanssen> glguy: yes
10:51:00 <sjanssen> same as map head . group . sort
10:51:08 <glguy> but stable
10:51:24 <sjanssen> right
10:51:35 <paolino> thanks bbl
10:56:14 <glguy> http://programming.reddit.com/info/xmv7/comments/cxna5
10:56:15 <lambdabot> Title: Why programmers don&#39;t want to comment code (reddit.com)
10:57:12 <ndm> comments are not good
10:57:32 <astrolabe> ndm: oh yes they are
10:57:34 <ndm> comments are simply another form of redundancy when coding
10:57:46 <ndm> its much better to pick sensibly named functions etc
10:58:03 <ndm> then the code is the comment, and it won't evolve in a different direction from the code
10:58:23 <astrolabe> ndm: I agree that you should do your best with the type system and type/variable name choice
10:58:24 <ndm> comments are great for highlevel design decision documentation, pointing out pitfalls, but most comments are just pure crap
10:58:39 <ndm> for my A-level project we got marked on "number of comments"
10:58:43 <ndm> so i wrote a comment generator
10:58:45 <glguy> a = 1 -- assign the value 1 to a
10:58:48 <emu> stupid comments are easy to write
10:58:48 <astrolabe> ndm :)
10:58:49 <glguy> i don't see the problem
10:58:56 <ndm> for (int i = 0; i < n; i++)
10:59:08 <ndm>  // loop round with the variable i from 0 to n - 1
10:59:20 <astrolabe> A function should have a purpose that is easy to describe, doesn't mean the code will be brief.
10:59:25 <ndm> it literally did that over all the source code - everyone would happy
10:59:46 <ndm> astrolabe: yes, documentation a functions interface is handy
11:00:39 <shapr> I think that's why I like having both where and let, because some functions are easy to read when built top down, and other easy to read when built bottom up.
11:01:11 <ndm> i like let because it means you can translate Haskell into expressions, and still have Haskell at the end
11:02:19 <shapr> Darius Bacon suggested to me a contest for "code as literature."
11:02:29 <astrolabe> ndm: I think we are in agreement :)
11:02:54 <emu> i generally only use "let" with "do", it looks kinda awkward in functional code
11:03:09 <ndm> astrolabe: good good - i just think a lot of people believe more comments is better, when i think less is better, as long as they are the right ones
11:03:44 <astrolabe> Haskell type signatures are wonderful comments.
11:03:50 <shapr> Let can be mathy, "If things are setup this way, then this thing is neat to look at."
11:05:06 <astrolabe> Sometimes I explain the meaning of a variable, if the name isn't sufficient.
11:05:28 <astrolabe> But I take your (ndm's) point about duplication
11:05:28 <ndm> i name most local function f..h
11:05:42 <ndm> and most variables x..z, a..e, m..n
11:05:49 <ndm> and o, if i feel like it
11:05:54 <ndm> makes names almost irrelevant :)
11:06:24 <emu> normalize your variable names: a, a', a'', a''', a''''
11:06:31 <astrolabe> ndm: I think that can be sensible for CS type coding, but for physics and engineering, there is often a better name.
11:06:57 <ndm> astrolabe: possibly, although i do overuse f..h quite a bit
11:07:10 <astrolabe> @slap ndm
11:07:11 <vegai> emu: seriously?
11:07:29 <astrolabe> @help
11:07:30 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:07:34 <astrolabe> @list
11:07:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:07:38 <emu> it gets a little sketchy when you get to a''''''''''''''''''
11:08:01 <Nafai> shapr: "Code As Literature"?
11:08:05 <astrolabe> Why isn't it slapping?
11:08:05 <Nafai> shapr: That's an interesting idea
11:08:06 <Philippa> ndm: I use t and ty an awful lot at the mo...
11:08:13 <Philippa> f,g and h are good for parms
11:08:28 <astrolabe> The naming scheme I hate most is  'i','ii','iii'
11:08:37 <Igloo> emu: You can RLE your variable names, e.g. a18
11:08:44 <vegai> myTemporaryVariableWhichDoesntMeanAnything
11:09:03 * resiak hands out Hungarian Notation
11:09:30 <astrolabe> That's all double dutch
11:10:30 * astrolabe looks at his code
11:10:42 <ndm> i never use a', it screws up my syntax hilighting
11:11:05 <Igloo> You could fix the syntax highlighting instead  :-)
11:11:15 <ndm> too much hassle...
11:11:20 <ndm> and closed source
11:11:37 <Igloo> No comment  :-)
11:11:43 <sjanssen> don't use a broken editor? ;)
11:11:47 <ralf`> question: How do you retrieve the current file?
11:11:50 <ndm> i use the worlds best editor
11:11:57 <ralf`> s/file/filename/ ?
11:12:03 <ndm> TextPad, for those who don't know :)
11:12:04 <ralf`> (current-filename) ?
11:12:06 <ralf`> (pwd)
11:12:07 <ralf`> ?
11:12:35 <Igloo> ralf`: Do you mean "What's the Haskell for pwd"?
11:12:48 <ralf`> yes.
11:12:53 <Igloo> @index getCurrentDirectory
11:12:54 <lambdabot> System.Directory, Distribution.Compat.Directory
11:13:00 <Philippa> ndm: I'd like that bug fixed too
11:13:11 <Philippa> really annoys the hell out of me, it's a great naming convention otherwise
11:14:04 <ralf`> Thx.
11:14:15 <astrolabe> ndm/philippa: you don't like emacs?
11:14:34 <glguy> emacs? textpad? but you already have vim installed...
11:14:50 <astrolabe> we don't :)
11:14:59 <glguy> weird
11:16:12 <newsham> http://img380.imageshack.us/img380/8558/punitionis8.jpg
11:16:20 <newsham> replicateM_ 500 (putStrLn "I will not throw paper airplanes in class."
11:16:41 <glguy> that was the first comment for that image on reddit
11:17:15 <newsham> i dont collective-blog
11:17:21 <astrolabe> looks like correct code though.
11:17:24 <nmessenger> putStrLn $ concat $ replicate 500 "I will not throw paper airplanes in class\n"
11:17:31 <nmessenger> :)
11:17:40 <Philippa> astrolabe: emacs would involve learning a completely new set of UI conventions
11:17:48 <glguy> putStrLn $ unlines $ replicate 500 "aaa"
11:17:59 <Philippa> there're some other things I suspect I'd come to dislike about it if I got good, too
11:18:33 <astrolabe> Philippa: true, but a text editor is a major part of any coder's life.  It is worth some effort.
11:18:44 <astrolabe> I'm sure there are.
11:19:07 <astrolabe> I like the fact that it is programmable, although I've never programmed it.
11:19:17 <Philippa> yes, I'd like programmability
11:19:19 <Philippa> but hey
11:20:10 <Philippa> gtg
11:23:38 <vegai> glguy: http://uncyclopedia.org/wiki/AAAAAAAAA ?
11:23:39 <lambdabot> Title: AAAAAAAAA! - Uncyclopedia
11:24:11 <shapr> I prefer the unicyclopedia.
11:25:16 <newsham> astrolabe: no, its not correct.  its all one line.  there are no newlines.
11:26:07 <shapr> newsham: You could collective-blog, want to be added to planet.haskell.org?
11:26:57 <bvd> Small question: I defined the type synonym: 'type Bhv i o = ...' and I defined the 'class Reactive s i o where ...' When I try to make an 'instance Reactive Bhv i o where ...' ghc complains with: 'Type synonym `Bhv' should have 2 arguments, but has been given 0'. When I replace the type synonym with a newtype it works but I would like to do it with a type synonym. Is this possible?
11:28:43 <stepcut> I want to create a page on the wiki about C++, but the wiki does not seem to like the ++ in the page name, any suggestions?
11:29:04 <shapr>  Cplusplus ?
11:29:08 <glguy> (++)C
11:29:10 <glguy> ?
11:29:11 <bvd> CPP
11:29:14 <shapr> SeePlusPlus ?
11:29:22 <glguy> D
11:29:35 <glguy> oh, you were serious?
11:29:49 <dmhouse> bvd: use (Bhv i o) in the instance.
11:30:18 <bvd>  Kind mis-match
11:30:18 <bvd>     Expected kind `* -> * -> *', but `Bhv i o' has kind `*'
11:30:41 <dmhouse> Oh, my mistake.
11:30:59 <dmhouse> bvd: wait, no.
11:31:01 <stepcut> bvd: that was my first thought, but then it might be confused with the other cpp (c pre-processor)
11:31:19 <dmhouse> bvd: did you mean to write a multi-parameter typeclass?
11:31:27 <stepcut> the old wiki let you escape the plus :-/
11:31:27 <bvd> yes
11:32:13 <dmhouse> bvd: what's the body of the typeclass like?
11:34:07 <bvd> dmhouse: http://paste.lisp.org/display/34641
11:34:15 <emu> > let c = "C++" in (c++) " sucks"
11:34:17 <lambdabot>  "C++ sucks"
11:35:07 <emu> > let c = "C++" in fix (c++)
11:35:08 <lambdabot>  "C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++C++...
11:35:09 <glguy> > fix ("C"++)
11:35:10 <lambdabot>  "CCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC...
11:35:21 <glguy> heh, emu and I were on the same track
11:35:35 <temujin> > let emu = "Nub" in (emu++) " emu"
11:35:37 <lambdabot>  "Nub emu"
11:35:37 <Jaak> > let c f = "C" `f` "++" in c (++)
11:35:39 <lambdabot>  "C++"
11:35:47 <newsham> > nub $ fix ("C"++)
11:35:51 <lambdabot> Terminated
11:35:53 <temujin> oooo
11:36:04 <temujin> > emu
11:36:05 <lambdabot>   Not in scope: `emu'
11:36:13 <temujin> does the bot not have a memory?
11:36:24 <dmhouse> bvd: I'd really expect that to work, let me go docs hunting.
11:36:26 <newsham> ?define ame = "totally"
11:36:26 <emu> @let c = "C++"
11:36:27 <lambdabot> Undefined.
11:36:27 <dmhouse> temujin: use ?define
11:36:27 <lambdabot> Defined.
11:36:33 <glguy> or ?let
11:36:38 <newsham> ?let ame = "totally"
11:36:38 <emu> > c
11:36:39 <lambdabot> Defined.
11:36:40 <lambdabot>  "C++"
11:36:42 <newsham> > L.ame
11:36:43 <lambdabot>  "totally"
11:36:43 <temujin> ?help define
11:36:44 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
11:36:46 <temujin> ?define
11:36:46 <lambdabot> Undefined.
11:36:50 <temujin> mmm
11:36:54 <temujin> define is undefined
11:37:44 <emu> > c++
11:37:44 <lambdabot>  Parse error
11:39:19 <bvd> dmhouse: Well it does work if I replace 'type Bhv i o = [IOAction i o]' with for example 'newtype Bhv i o = Bhv [IOAction i o]'. But maybe there exists some ghc extension?
11:39:56 <dmhouse> bvd: according to the GHC manual section 7.4.4.4, type synonyms have to be always fully applied, so it won't work. Sorry.
11:40:08 <dmhouse> I'm not sure why.
11:40:25 <temujin> :(
11:40:29 <temujin> so if you are in ghci
11:40:30 <bvd> dmhouse: Mmm ok thanks for looking! then I'm going to replace it with a newtype
11:40:36 <temujin> how do you exit the shell?
11:40:45 <glguy> ^D
11:40:47 <temujin> exit doesn't work, quit doesn't bye doesn't
11:40:50 <temujin> ahh ctrl-d
11:40:53 <glguy> logout
11:41:02 <temujin> damnit didn't try logout...
11:41:04 <temujin> tried shutdown
11:41:05 <temujin> hehe
11:41:17 <temujin> no logout doesn't work either
11:41:20 <dmhouse> temujin: :quit will do it, by the way.
11:41:29 <temujin> ahh so there are some :commands
11:41:36 <dmhouse> All GHCi commands are prefixed with ':'. Anything else is interpreted as Haskell.
11:41:42 <dmhouse> temujin: yes, such as :type.
11:41:47 <dmhouse> temujin: try :?
11:42:11 <temujin> cool cool :) switching to this channel has made me open up ghc again and try to figure it out
11:44:38 <glguy> OH, if you are in ghci
11:44:49 <glguy> the shell, and ghci are two diffrent things :-p
11:45:12 <glguy> ?jargon shell
11:45:13 <lambdabot> *** "shell" jargon "Jargon File (4.3.1, 29 Jun 2001)"
11:45:14 <lambdabot> shell n. [orig. {{Multics}} techspeak, widely propagated via Unix] 1.
11:45:16 <lambdabot>    [techspeak] The command interpreter used to pass commands to an
11:45:18 <lambdabot>    operating system; so called because it is the part of the operating
11:45:20 <lambdabot>    system that interfaces with the outside world. 2. More generally, any
11:45:22 <lambdabot> [17 @more lines]
11:45:50 <temujin> glguy uhm... you type ghci and you are sitting at Prelude>
11:45:52 <glguy> but I can see how GHCi could be considered one
11:45:58 <temujin> you are at the haskell interpreter
11:46:19 <temujin> wouldn't that kinda be the haskell shell?
11:46:22 <glguy> temujin: but bash is your "shell" (or whatever you use)
11:46:25 <glguy> kind of
11:46:31 <temujin> heh
11:46:33 <glguy> but that's misleading if you want to be able to ask questions
11:46:43 <dmhouse> It's more of a Haskell REPL.
11:46:52 <temujin> REPL?
11:46:54 <dmhouse> Shells tend to be about file manipulation, I guess.
11:47:01 <dmhouse> temujin: Read-Eval-Print Loop
11:47:06 <glguy> besides, ^D exists *nix GHCi
11:47:33 <glguy> and F6 and ^Z exists Windows GHCi
11:47:33 <temujin> shells allow you to talk to the kernel to do stuff... some of that is file manipulation
11:47:42 <glguy> (either of those + ENTER is the windows EOF)
11:52:32 <temujin> ahhh... the haskell for c programmers
11:52:39 <temujin> I should read that
11:53:45 <newsham> shells dont let you talk directly to the kernel.  they let you run commands and combine them together.  commands use the operating system services
11:55:41 <temujin> newsham never said directly... its an interface to the system that is running...
11:55:47 <temujin> the system is the kernel more or less
11:55:58 <flux__> isn't using fork, exec and open talking to the kernel?-)
11:56:02 <newsham> i beg to differ.
11:56:16 <newsham> flux: not a very full conversation.
11:56:17 <temujin> go on
11:56:27 <glguy> newsham: You are permitted to differ
11:56:32 <newsham> thank you sir.
11:57:24 <newsham> everything "talks to the kernel" in some way or another.  a program doesnt run without the cooperation of the kernel.
11:57:35 <newsham> but the system is definitely more than just the kernel.
11:58:41 <newsham> there are many kernel features which are not directly accessible in the shell in most systems.
11:58:46 <newsham> consider sockets.
11:59:01 <newsham> this is perhaps offtopic
11:59:29 <glguy> as I said, differentiation permitted :-p
11:59:44 <pejo> newsham, I think the zsh manual has some examples with a built in ftp-client, or similar.
11:59:45 <temujin> perhaps... never said the shell provides all functionality of the kernel at the command prompt either
12:00:09 <glguy> but isn't the *network* the computer?
12:00:34 <pejo> glguy, only if you buy a sun. *cough*
12:00:55 <temujin> hehe
12:01:47 * SamB_XP wonders why Amazon thought he would be interested in buying Windows Vista or Office 2007 -- especially the latter?
12:02:05 <newsham> > L.ame
12:02:06 <lambdabot>   Not in scope: `L.ame'
12:03:11 <Nafai> SamB_XP: You've looked at computer-related things.  Certainly all computer users want those!
12:03:14 <newsham> do ?let's get timed out?  or did someone remove that? :)
12:03:35 <glguy> anytime someone types something similar to ?undefine they all disappear
12:03:39 <newsham> oh
12:03:40 <SamB_XP> Nafai: the email claims I shopped at their software store...
12:03:42 <SamB_XP> oh!
12:03:53 <SamB_XP> I bought Sim City 3000 Unlimited, didn't I?
12:03:53 <newsham> glguy: seems rather accident prone
12:04:08 <glguy> newsham: I don't think that it's designed for production systems ;)
12:05:13 <newsham> but haskell is supposed to be more robust and secure.
12:05:50 <SamB_XP> but Windows Vista is a lot more expensive than SC3KU! also... Office is not a very fun game! especially with the flight sim gone!
12:05:57 <temujin> hehe
12:07:34 * SamB_XP rates Office 2007 Professional as "I hate it!"
12:08:04 <newsham> yah
12:08:06 <SamB_XP> aww. I can't tag it with "m$"
12:08:23 <newsham> i tried 2k7, sticking with officexp for now
12:08:46 <SamB_XP> I don't like MS Word a bit.
12:09:00 <SamB_XP> It likes to play games with my documents!
12:09:15 <svref> How squirrelly is Laziness?  If I have a graph with 1,000,000 nodes, all interconnected, will the GC throw away some of them anyway, knowing it can regenerate them later if it needs to?
12:09:31 <SamB_XP> no
12:09:36 <temujin> svref once its created its there right?
12:09:47 <temujin> till its used its not created
12:09:54 <SamB_XP> the GC would already have thrown out the closure that those were made from!
12:09:57 <svref> That would be the sane way, methinks.
12:10:12 <temujin> and once its there its never gone
12:10:19 <temujin> so... it stays ...
12:10:38 <svref> Makes sense.
12:10:52 <newsham> xp: i can get along with it when paid to.
12:10:52 <svref> Allright, that effects how I'm going to code.  THanks!
12:11:15 <SamB_XP> I won't venture to rate Vista, because that might actually be decent
12:11:49 <newsham> some things i like about vista some things I dont.
12:11:58 <newsham> its definitely pretty
12:12:39 <glguy> I installed Vista Ultimate from my MSDN subscription... i think I'll like it more when it is compatible with the software I use
12:12:46 <glguy> right now it isn't an option
12:13:02 <SamB_XP> which software is that?
12:13:14 <glguy> visual studio doesn't work well with it and my steam games dont all work well with it
12:13:19 <SamB_XP> !!!
12:13:22 <glguy> ghc wouldn't compile
12:13:25 <SamB_XP> Visual Studio!
12:13:35 <glguy> yeah, there is a new visual studio coming out that should be better
12:13:40 <SamB_XP> ah.
12:13:51 <SamB_XP> ... why did they not release it *before* releasing Vista?
12:14:30 <glguy> because it wasn't done?
12:14:42 <temujin> hehe
12:14:44 <SamB_XP> hah!
12:14:54 <temujin> I have rc2 installed on my vindos box
12:15:00 <glguy> and I don't know... are they selling Vista in stores yet?
12:15:02 <SamB_XP> so we are supposed to believe that they didn't use Visual Studio to make Vista?
12:15:06 <temujin> its great as long as I am only moving windows  around
12:15:14 <SamB_XP> or more to the point ... they want us to *know* that?
12:15:18 <glguy> SamB_XP: I think you should beleive that they didn't make vista *on* vista
12:15:33 <SamB_XP> I am going to assume they used FreeBSD to make Vista
12:15:35 <temujin> SamB_XP they use a stripped down version of the os and compiler at the developer stations :)
12:15:37 <SamB_XP> or OS X, maybe
12:16:19 <emu> of course they didn't use VS to make Vista
12:16:27 <emu> they wanted to get work done, so they used emacs (or vim)
12:16:45 <SamB_XP> okay, so they probably used emacs.exe or something...
12:17:05 <glguy> I doubt they used emacs. .. the source files are probably too big, combine that with the emacs footprint
12:17:14 <emu> Visual Studio is what they hand out to competitor software companies so that they get bogged down and can't keep up with MS
12:17:17 <glguy> and your cost of workstation ram becomes prohibitive
12:17:39 <emu> i've had months of scrolling logs kept in emacs buffers. i don't think that's a problem, dude.
12:17:42 <SamB_XP> glguy: source files too big?
12:17:48 <SamB_XP> why would they use big source files?
12:17:56 <glguy> Yeah, I said it, emacs couldn't do it
12:17:56 <glguy> ha!
12:18:18 <glguy> You are actually going to try to pick apart an argument that I'm stating as fact, hilarious
12:18:23 <SamB_XP> also, since when has MS worried about trivial issues like memory usage?
12:18:34 <SamB_XP> 640k ought to be enough for anyone!
12:18:36 <glguy> its fact SamB_XP , don't try to dispute
12:18:37 <emu> it can't possibly use more than Vista itself!
12:19:34 <SamB_XP> anyway, the only times Emacs gets out of hand for *me* are generally when I run things like...
12:19:40 <SamB_XP> > [1..]
12:19:45 <emu> i think glguy is referring to "factiness"
12:19:47 <SamB_XP> at an interactive prompt
12:19:57 <glguy> its part of the ircality
12:20:17 <SamB_XP> source files get too big for humans way before they get too big for Emacs
12:20:30 <emu> i've never actually found a file too large for Emacs to open
12:21:03 <SamB_XP> well, if scrolling was causing a 10-second delay, you might consider it to be so
12:21:14 <emu> i've opened 100MB files in emacs
12:21:33 <SamB_XP> oh. and when the *lines* are too long, that is the worst
12:23:16 <temujin> damn
12:23:24 <temujin> I think I crapped out ghc
12:24:18 <emu> > [1..] -- is only a problem for me when i'm on Windows, because ghci doesn't respond to C-c
12:24:51 <glguy> Mine responds, just not correctly
12:25:05 <SamB_XP> well, with Emacs, if you don't press C-c C-c quick enough, you get tons of text in the buffer
12:25:21 <emu> well sure, but that isn't a problem
12:25:44 <temujin> hehehe
12:25:46 <glguy> ?seen Cale
12:25:46 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
12:25:47 <zeeeeee> dons: in yi, there's a function 'eventToChar' with the comment: "This should be gotten rid of, eventually. Do this to enable using Alex lexers. OTOH, we should screw Alex and do proper typing.OTOH, we should screw Alex and do proper typing."
12:26:23 <temujin> I think I have to say... ide wise... visual studio 2005 has no peer currently
12:26:31 <temujin> I mean that in a good way
12:26:36 <emu> provided you are editing C# or something
12:26:45 <zeeeeee> i was wondering if you might know what that comment is about; if jyp knows, how do i reach him? are you referring to Lexers.hs? is that from Alex? i thought it was from CTK. and how would you do the lexing differently? by modifying Lexers.hs to use a instead of Char?
12:27:03 <zeeeeee> or haskell
12:28:00 <zeeeeee> ?seen dons
12:28:01 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 15h 12s ago.
12:28:31 <jethr0> zeeeeee: you could look in the darcs repo who created that comment :)
12:28:45 <zeeeeee> ?seen jyp
12:28:46 <lambdabot> I saw jyp leaving #haskell 1d 22h 45m 28s ago, and .
12:29:58 <shapr> emu: I think 2GB is the max size. I've opened 1.5GB or so, but it takes awhile to scroll around.
12:30:30 <flux__> shapr, how much memory do you have? ..
12:30:36 <emu> probably. someone needs to create dvd-iso-mode so there is motivation to raise that limit.
12:30:52 <shapr> flux__: At the time I had 512mb
12:30:53 <zeeeeee> ?users
12:30:54 <lambdabot> Maximum users seen in #haskell: 311, currently: 308 (99.0%), active: 41 (13.3%)
12:30:59 <flux__> shapr, did it page a lot?
12:31:01 <emu> why do people rag on emacs for RAM usage and then blab about Visual Studio? garbage
12:31:18 <emu> or perhaps, just trolls
12:31:23 <SamB_XP> emacs is far older
12:31:29 <flux__> I'm quite certain emacs doesn't mmap files or load them on-demand
12:31:47 <SamB_XP> Eight Megs And Constantly Swapping, and all that!
12:31:48 <emu> i'm quite certain that i've had running SLIME sessions for months and months with active work every weekday
12:32:00 <shapr> flux__: I was using xemacs, think that makes a difference?
12:32:13 <flux__> I think at some o
12:32:22 <SamB_XP> emu: slime throws out scrollback in its real interaction buffer?
12:32:23 <flux__> point emacs had the characters as a linked list..
12:32:26 <emu> no
12:32:34 <SamB_XP> ... seriously?
12:32:46 <flux__> well, lines should have more direct pointers
12:32:47 <emu> at any point i could hit M-< to go back to the very beginning
12:32:56 <flux__> but I don't know. it does feel quite wasteful.
12:33:09 <flux__> not much different from [Char]?-)
12:33:13 <SamB_XP> the "real" one being the one you *don't* look at?
12:33:24 <dmhouse> The only thing that takes ages on large buffers is big non linear things like regexps (font locking, buttonising, etc.)
12:33:31 <flux__> disclaimer: I'm an eager xemacser
12:34:01 <SamB_XP> dmhouse: or moving the scrollbar vast numbers of lines?
12:34:17 <dmhouse> SamB_XP: if it has to font lock as it goes, yes.
12:34:17 <emu> i don't use scrollbars so i couldn't say about that
12:34:19 <glguy> i was just trolling, but I felt that it was obvious enough that others would catch on
12:34:53 <glguy> i dont' really care what editor other people use or what language they use, etc
12:35:01 <dmhouse> SamB_XP: but I'll rarely scroll huge amounts using the scroll bars. I'll use C-s or C-<home> or C-<end>.
12:35:19 <SamB_XP> glguy: I thought you were claiming that MS used ridiculously large files or something
12:35:36 <glguy> it was all fairly incoherent
12:35:43 <SamB_XP> also I was forgetting how well emacs handles large files, since I don't have so many large text files ;-)
12:35:50 <emu> yes, MS has a kernel.cpp that is 2GB in size
12:35:58 <SamB_XP> !!!
12:36:07 <SamB_XP> oh. GB.
12:36:16 <dmhouse> SamB_XP: ?
12:36:21 <dmhouse> That's pretty damn large.
12:36:27 <SamB_XP> I would maybe have considered believing you if you said MB
12:36:36 <emu> they back it up on dvd
12:36:38 <wilx> How do you know it is true?
12:36:52 <SamB_XP> I'm going to assume emu is stretching the truth
12:36:52 <wilx> Or am I missing joke there?
12:36:55 <emu> it takes 10 days just to run the CPP on it
12:37:09 <dmhouse> I don't think sarcasm works very well in text-based media.
12:37:17 <SamB_XP> *maybe* if you include the size of the header files that *would* be processed if they didn't use precompiled headers!
12:37:31 <emu> what's the estimate on LoC in Vista?
12:37:35 <emu> 2 million?
12:37:42 <emu> 10?
12:37:42 <glguy> 2 many?
12:37:46 <SamB_XP> but, emu, you realize that MS knows how to use .h files, right?
12:37:58 <SamB_XP> and that precompiled headers are not exactly foreign to them, either?
12:37:59 <emu> just as well as they know how to use .dll files
12:39:10 <glguy> Does HXT.Arrow have support for state at all? I want to give a unique id to every node that matches a certain criteria
12:39:11 <flux__> I saw a comment saying how Steve Balmer (?) had earlier said how he knew IBM OS/2 was doomed to fail because the IBM message was how many lines the new version would have..
12:39:11 <emu> i wonder how many LoC++C 2GB would be
12:39:20 <flux__> ..and now Microsoft is dong the same with Vista.
12:39:32 <flux__> I haven't actually seen any Vista ads, though.
12:39:43 <emu> the consumer version is out later this month?
12:40:31 <glguy> sounds right
12:41:18 <emu> i'll be sure not to notice it or install it
12:46:07 <glguy> Anyone know how to use HXT's setUserState?
12:46:48 <SamB_XP> well, what is the type?
12:46:57 <glguy> setUserState:: IOStateArrow s s s
12:47:10 <SamB_XP> uh huh.
12:47:11 <glguy> = changeUserState const
12:47:19 <glguy> changeUserState		:: (b -> s -> s) -> IOStateArrow s b b
12:47:19 <glguy> changeUserState cf
12:47:19 <glguy>     = IOSLA $ \ s v ->
12:47:19 <glguy>       let s' = s { xio_userState = cf v (xio_userState s) }
12:47:20 <glguy>       in return (s', [v])
12:48:09 <SamB_XP> setUserState -< state -- I guess?
12:48:34 <glguy> is that like: returnA "guess" >>> setUserState?
12:48:51 <SamB_XP> I hope so.
12:49:21 <SamB_XP> No telling what it returns, though!
12:49:33 <glguy> i jsut meant that as a fragment
12:49:57 <SamB_XP> or, well, there is telling.
12:50:28 <SamB_XP> hmm.
12:50:39 <SamB_XP> the output is the same as the input, I guess...
12:56:37 <dmhouse> If I have modules A.B and A.C, and I want to import C from B, do I do 'import A.C' or 'import C'?
12:58:35 <araujo> mm
12:58:53 * araujo will have his first class of 'system II'
12:59:01 <araujo> within a few minutes ...
12:59:02 <araujo> mmm...
12:59:20 * araujo wonders if he would be able to get a haskell project there
12:59:24 <dmhouse> A.C, is the answer.
12:59:52 <araujo> probably not easy, in a java/vb land .. but i will battle :-P
13:00:03 <mahogny> Clean? :)
13:00:23 <araujo> mahogny, ?
13:00:35 <mahogny> araujo, java with extensions that almost make it a real language
13:00:41 <mahogny> interoperates with normal java
13:00:53 <mahogny> you'll prolly like it
13:01:04 <mahogny> not as good as haskell of course...
13:01:15 <Excedrin> are you talking about CAL?
13:01:19 <slava> clean is not java with extensions
13:01:44 <araujo> mahogny, clean? .... mm, isn't that the other purely functional lang?
13:02:06 <mahogny> maybe I mix up the name
13:02:22 <mahogny> but java with extensions might not be proper to say :)
13:03:07 <jethr0> does anyone have a better idea for the function "groupAscend" on http://www.haskell.org/haskellwiki/Haskell_Quiz/DayRange/Solution_Jethr0 ?
13:03:09 <lambdabot> Title: Haskell Quiz/DayRange/Solution Jethr0 - HaskellWiki, http://tinyurl.com/y8sg3s
13:03:29 <jethr0> i'm trying to find a nicer solution, but somehow i've got a programmers' block
13:03:31 * shapr hugs jethr0
13:03:41 <vincenz> jethr0: !
13:03:42 * jethr0 ghci's shapr
13:03:49 <jethr0> vincenz: !
13:05:19 * jethr0 is thinking of some nice, small project to teach /me monadic program design.
13:05:36 <jethr0> but for the moment i'm just looking for some nice and short examples
13:06:02 <dmhouse> jethr0! It's been a while.
13:06:46 <shapr> jethr0: How's the new place?
13:06:51 <jethr0> true, i tried to resist the temptations of this channel, but i guess now i'm back sinning again
13:07:00 <dmhouse> :)
13:07:04 <shapr> Hey, we're PURE, the rest of the world is sinning!
13:07:18 <araujo> yeah
13:07:19 <jethr0> shapr: i haven't got a new place yet. right now i'm at my parent's and looking for a nice job
13:07:25 <dmhouse> Gah, cyclic imports, the bane of modular design.
13:07:37 * araujo writes that down for trying to talk the professor into haskell
13:08:10 <dmhouse> But I'm learning to love seperate compilation in the context of GHCi.
13:08:12 <jethr0> dmhouse: i agree, somehow i always end up with a cyclic mess when trying to "modularize". *argh*
13:08:46 <jethr0> but i guess that's more a function of my intelligence than of modularity per se
13:09:26 <dmhouse> I wouldn't say that.
13:09:37 <dmhouse> It seems that interdepencies are among the natural orders of things.
13:09:45 <dmhouse> I'd love to see the cyclic imports bug solved.
13:10:05 <malebria> @hoogle a -> [a] -> Int
13:10:06 <lambdabot> No matches, try a more general search
13:10:35 <dmhouse> malebria: what do you want?
13:10:42 <Adamant> I have a question. who on here thinks "dynamically typed" = "untyped"?
13:10:59 <dmhouse> Adamant: dynamically typed = not type safe, at least.
13:11:18 <Adamant> if you do, please stop saying "untyped". you are going to give me a heart attack.
13:11:28 <SamB_XP> why?
13:11:30 <Adamant> dmhouse, fair enough
13:11:32 <malebria> dmhouse: \x -> length $ filter (== x)
13:11:33 <SamB_XP> it *does*
13:11:36 <johnnowak> dmhouse: Why does dynamically typed not mean type safe?
13:11:43 <malebria> sorry..
13:11:48 <dmhouse> malebria: ah, right. That's the best you get, I think.
13:11:56 <malebria> s/$/.
13:12:01 <Adamant> but a language can still be strongly typed without being statically typed
13:12:08 <malebria> dmhouse: Yes, that's what I thought.
13:12:20 <johnnowak> Adamant: aye
13:12:21 <jethr0> yeah, typing flame war!
13:12:23 * jethr0 jumps in
13:12:24 <emu> woot
13:12:36 <Adamant> well, I'm not trying to start a flamewar, seriously
13:12:42 * mbishop is a tad chilly, and warms himself by the flames
13:12:47 <emu> i want a static weakly typed system!
13:12:47 <Adamant> but untyped is just wrong
13:12:53 <Adamant> welcome to C. :)
13:12:54 * emu installs GCC
13:13:02 <mbishop> heh
13:13:04 <jethr0> "well, you have to differentiate between strong/weak, static/dynamic, dynamically/statically type safe, ..." :)
13:13:09 * araujo `offTo` univ
13:13:12 <dmhouse> johnnowak: because you can get crashes by inappropriate casting?
13:13:28 <johnnowak> dmhouse: plenty of dynamic languages don't allow casting
13:13:31 <SamB_XP> well, I say that dynamic typing doesn't count as having a type system
13:13:40 <dmhouse> johnnowak: define 'dynamic typing'.
13:13:49 <jethr0> i read somewhere that even assembly isn't untyped, so i guess most implemented languages have some kind of implicit "typing"
13:13:55 <johnnowak> dmhouse: runtime checking of types
13:14:08 <jethr0> based on machine bytes or some other atomic unit
13:14:08 <Adamant> Haskell's strong static typing system is interesting and worth tooting Haskell's horn about
13:14:13 <dmhouse> Oh, okay, not 'types are allowed to change'.
13:14:28 <SamB_XP> jethr0: you've been smoking too much MASM
13:14:35 <dmhouse> runhaskell is essentially a dynamically typed Haskell compiler.
13:14:43 <emu> dynamic typing by itself perhaps, but you can design a type system that involves dynamic checks for undecideable portions
13:14:44 <jethr0> dynamic typing = types are evaluated at runtime?
13:14:47 <johnnowak> dmhouse: the types associated with a certain symbol may change, yes, but only safely as a result of some action, not by casting
13:15:11 * jethr0 things scheme has dynamic strong typing, because at runtime expressions are strongly typed
13:15:18 <Adamant> right.
13:15:31 <SamB_XP> but no type system!
13:15:47 <Adamant> which is not the same as untyped
13:15:56 <SamB_XP> hmm.
13:15:57 <Codex_> Russel's paradox.
13:16:02 <vincenz> no
13:16:03 <SamB_XP> okay, so Inform is untyped then.
13:16:07 <vincenz> dynamic typing: values have types
13:16:08 <SamB_XP> along with BCPL
13:16:11 <vincenz> static typing: variables have types
13:16:11 <jethr0> many scheme implementations usually have a strict type system for optimizations AFAIK, the programmer/user just never get's to see it
13:16:51 <jethr0> vincenz: isn't that just another formulation for compiletime/runtime?
13:16:55 <SamB_XP> jethr0: yeah. I've thought of making one of those for my ICFP 2000 raytracer...
13:18:13 <johnnowak> when i think of "untyped", i think of something like certain forths where operations just treat data as bits and happily perform whatever you requested without compile time or runtime checks. i realize that's not necessarily the accepted definition.
13:18:14 <SamB_XP> I think that kind of typesystem forms a semilattice?
13:18:41 <SamB_XP> johnnowak: that does sound about like what I actually think of, too...
13:18:45 <SamB_XP> or, you know, C
13:19:04 <johnnowak> i think to call both Scheme and Forth untyped is missing a valuable distinction
13:19:11 * SamB_XP is teasing a little bit
13:19:15 <SamB_XP> yeah.
13:19:33 <johnnowak> well great, we're all in agreement! let's go have some coffee.
13:19:38 * glguy has now figured out how to move state around, and change state, but not how to use it
13:19:44 * mbishop is having some coffee right now
13:19:49 * SamB_XP doesn't like coffee
13:19:56 <SamB_XP> well actually I don't believe I've had it
13:20:01 <SamB_XP> but I shouldn't like it
13:20:08 <johnnowak> SamB_XP: the first 100 cups are not so great, but it gets better...
13:20:09 <jethr0> glguy: not sure i can help, but how exactly do you mean that?
13:20:17 * jethr0 neither
13:20:20 <glguy> I'm playing with IOStateArrow
13:20:31 <glguy> for HXT
13:20:33 <jethr0> *yuch*, that much for helping you
13:20:34 <Adamant> SamB_XP, thank you ensuring my sanity for the rest of the day. :)
13:21:06 <SamB_XP> but probably I will slip and call Python or Scheme or Perl untyped anyway, from time to time...
13:21:06 * temujin wishes he was served coffee by a hot female coworker
13:21:12 <temujin> mmmm
13:21:15 <temujin> coffeee
13:21:22 <SamB_XP> what is a quick way to say "lacking a type system"?
13:21:33 <Adamant> type-system-less?
13:21:37 <nornagon> weakly typed?
13:21:42 <nornagon> not typed?
13:21:43 <SamB_XP> nornagon: no!
13:21:51 <SamB_XP> C has a typesystem but doesn't use it well.
13:21:52 <jethr0> nooooo!
13:21:55 <nornagon> untyped?
13:21:57 <seliopou> dynamically tuped
13:22:00 <seliopou> typed
13:22:04 <SamB_XP> oooh!
13:22:06 <emu> the question is: how hard do you bang the keyboard when you type? softly or loudly?
13:22:07 <SamB_XP> dynamically tuped!
13:22:08 <jethr0> here we go again
13:22:16 <Adamant> dynamic tuples
13:22:24 <jethr0> untypefied
13:22:29 <Baughn> Lacking a type system.. unityped?
13:22:31 <nornagon> 'bad'?
13:22:40 <nornagon> :P
13:22:41 <jethr0> unusable?
13:22:41 <SamB_XP> ducktyped?
13:22:46 <emu> is haskell loudly typed?
13:22:47 <Baughn> detyped?
13:22:52 <nornagon> emu: lawl
13:23:03 <Baughn> emu: Just verbosely typed
13:23:04 <johnnowak> if it lacks a type system, it's untyped. the question is, what counts as a type system. :)
13:23:06 <emu> i have a clicky keyboard at home, so there it is
13:23:17 <Saizan> i'll vote for ducktyped
13:23:43 <Baughn> johnnowak: A system that limits what values a variable can take?
13:24:02 <Baughn> Hmm, asserts would count.. so a program can be typed even if the language isn't?
13:24:15 <nornagon> well sure
13:24:16 <Codex_> anything that solves russel's paradox counts as a type system.
13:24:22 <seliopou> Typed = programs can't get stuck
13:24:28 <nornagon> there are strongly typed languages written in C, right? :)
13:24:28 <jethr0> seliopou: huh?
13:24:54 <emu> Codex_: what about impredicative type systems?
13:24:57 <mahogny> dunno if I agree there. but it is certainly a sign of a good type system :)
13:25:05 <Axioplase> How am I supposed to cleanly quit a gtk2hs program from a subroutine ? Am I supposed to passe the id of the main window to destroy it ? Or does mainQuit suffice ?
13:25:16 <emu> anything that resolves Russell's paradox counts as a "predicative type system"
13:25:19 <Codex_> emu: what are those?
13:25:23 <jethr0> not being able to get stuck /= turing complete
13:25:27 <jethr0> or am i wrong here?
13:25:37 <seliopou> no
13:25:45 <johnnowak> Baughn: you don't need to limit what values a variable can have to be typed.
13:25:54 <glguy> ?seen Cale
13:25:54 <lambdabot> Cale is in #ghc, #haskell-overflow and #haskell. I don't know when Cale last spoke.
13:25:59 <Cale> hi
13:26:03 <seliopou> a program is stuck if you can no longer apply evaluation/reduction rules
13:26:03 <glguy> Hurray!
13:26:07 <johnnowak> Baughn: at least, i'd not think so, provided you check types whenever accessing it
13:26:22 <seliopou> So most static type systems guarantee that programs that are well typed can't get stuck
13:26:24 <jethr0> seliopou: i thought you meant the halting problem
13:26:32 <seliopou> languages like scheme just throw an error
13:26:32 <Baughn> johnnowak: That counts as limiting to me, so we don't disagree.
13:26:41 <lisppaste2> glguy pasted "Cale, a smidge of HXT Arrow help?" at http://paste.lisp.org/display/34656
13:27:00 <glguy> Cale: in the function faqItemToXml
13:27:07 <glguy> how do I make use of that state?
13:27:09 <seliopou> jethr0: not at all :P
13:27:19 <glguy> this can't be this complicated!
13:27:29 <Cale> In the second line?
13:27:36 <Cale> (of the proc)
13:27:44 <glguy> yeah, I want to use that state in s
13:27:47 <glguy> to add an attribute
13:27:52 <glguy> itemId = show state value
13:27:57 <jethr0> can i make a section with two ":" in it?
13:28:06 <glguy> > (1:2:) []
13:28:06 <lambdabot>      The operator `:' [infixr 5] of a section
13:28:07 <lambdabot>         must have lower precede...
13:28:07 <Cale> Try using -<< rather than -< in that line
13:28:08 <jethr0> (Nothing : Just 5 :) [] ?
13:28:17 <glguy> Cale: on line two?
13:28:31 <glguy> and that puts s in scope?
13:28:35 <Cale> line two of the proc, whichever line you want to depend on s
13:28:41 <sjanssen> jethr0: no, you can't
13:28:51 <Cale> I think it puts all the previous variables in scope, but I might be wrong
13:29:21 <glguy> HURRAY
13:29:23 <glguy> you did ti
13:29:29 <jethr0> grmpf
13:29:55 <Cale> glguy: It took me quite some time to work that out :)
13:30:04 <Cale> glguy: (the first time I ran into it)
13:30:08 <huschi> hi. i'm trying to run the examples from the soe-book. in Memo1.hs there is a call to unsafePtrEq, but i cannot find this function in the docs, what can i do?
13:30:15 <huschi> @hoogle unsafePtrEq
13:30:15 <lambdabot> No matches found
13:30:15 <Cale> It's documented in the GHC documentation.
13:30:20 <glguy> ok
13:30:39 <glguy> Cale: also... how might I fit in:   setUserState -< (x+1)
13:30:46 <glguy> arrows are sequential, right?
13:30:47 <glguy> not!
13:30:49 <glguy> are not!
13:30:51 <glguy> excuse me
13:31:02 * glguy has been drinking a lot of coffee today
13:32:44 <glguy> b <- changeUserState (\_ x -> x + 1) -< a returnA -< b
13:33:13 <glguy> that worked, but I don't know how i would have done ti with setUserState
13:34:01 <glguy> setUserState = changeUserState const
13:34:06 <Cale> I think setUserState doesn't return much of interest
13:34:08 <glguy> ?pl (\_ x -> x + 1)
13:34:08 <lambdabot> const (1 +)
13:34:16 <glguy> so...
13:34:40 <Cale> It just takes its input and sets the state to that
13:36:50 <glguy> Cale: I didn't think it would work because I didn't know if that line would run
13:36:56 <glguy> since nothing depended on it
13:37:01 <glguy>       setUserState -< s + 1
13:37:02 <glguy>       returnA -< a
13:37:04 <glguy> but this works
13:37:49 <Cale> I wonder how that desugars.
13:37:56 <glguy> ditto
13:38:17 <lisppaste2> glguy annotated #34656 with "working faqItemToXml" at http://paste.lisp.org/display/34656#1
13:38:46 <glguy> there is nearly zero documentation on how to do this (when you do a couple of quick google queries on HXT and state)
13:39:01 <Cale> huschi: hmm
13:39:49 <huschi> Cale: i only found it in the IOExts module of hugs but not of ghc.
13:40:03 <huschi> it is used for memoization.
13:40:08 <glguy> proc x -> f x -<< x+1   --    arr (\ x -> (f x, x+1)) >>> app
13:40:12 <shapr> glguy: trying to do what?
13:40:25 <glguy> shapr: pass state around in the HXT arrow interface
13:40:56 <glguy> getUserState HXT return two links in google, and both were haddock pages :)
13:41:14 <SyntaxNinja> @kosmikus++
13:41:16 <Cale> huschi: yeah, it's not a standard Haskell function
13:41:57 <huschi> Cale: and i also can't find something on memoization in the wiki.
13:43:05 <Cale> http://research.microsoft.com/Users/simonpj/Papers/weak.htm discusses a number of ways to get memo functions in GHC
13:45:36 <huschi> Cale: thx
13:46:37 <Cale> You can probably copy code directly out of that. At worst, you'll just need to figure out which modules to import.
13:47:40 <ray> freebsd needs a better haskell port maintainer
13:48:07 <Cale> indeed
13:48:49 <huschi> @hoogle withRGB
13:48:54 <Cale> We've had a few people in here complaining about how GHC doesn't work correctly on FreeBSD. (Readline support is disabled or broken)
13:49:31 <glguy> I thought that that was already resolved
13:49:36 <allbery_b> ports/107380
13:49:58 <allbery_b> I posted a quick hack to work around it; maintainer is working on a proper fix along with ghc6.6
13:50:09 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Utils.html#v%3AwithRGB
13:50:29 <Cale> (that's a link to documentation for withRGB)
13:50:49 <huschi> Cale: thx
13:52:40 <wolverian> Cale, thanks, the memoization paper looks very interesting!
13:56:42 * glguy wonders if there could be a way to write this without -<<
13:56:42 <glguy>       s <- getUserState -< x
13:56:42 <glguy>       setUserState -< s + 1
13:56:43 <glguy>       mkelem "item" (attrs s) [q,a] -<< undefined
13:58:20 <seliopou> unsafePerformIO question
13:58:51 <seliopou> The Awkward Squad paper suggested adding a noinline to anything that uses unsafePerformIO
13:59:05 <seliopou> is it necessary to add this to non functions?
14:00:04 <earthy> for the vimlovers: could you please test http://www.cs.uu.nl/~arthurvl/haskell.vim (an indent plugin, to be put in ~/.vim/indent/
14:00:07 <earthy> )
14:00:10 <huschi> Cale: now everything seems to wotk.
14:00:23 <Cale> huschi: cool
14:00:26 <Cale> seliopou: hm?
14:00:31 * earthy is off to drink one whisky and go to bed
14:00:48 <Cale> seliopou: especially so for nonfunctions, since they're likely only to be evaluated once
14:00:49 * shapr drinks Ginger Ale and works.
14:01:18 * jethr0 drinks sparkling water and tries to read his way through the haskell wikis
14:01:22 <SamB_XP> seliopou: it depends what you are doing!
14:01:32 <Cale> er, you likely only want them evaluated once
14:01:34 <seliopou> SamB_XP: of course
14:01:38 * mbishop sips his coffee and browses more sites
14:01:53 <Cale> but if they get inlined, the effects will occur potentially many times
14:01:55 <seliopou> I'm doing this:
14:02:02 <seliopou> args = unsafePerformIO getArgs
14:02:13 <seliopou> I think an inline here would be totally unnecessary
14:02:24 <earthy> anyway, please test. :)
14:02:28 <Cale> It shouldn't be too much of a problem. But why are you doing that?
14:03:08 <seliopou> So I'm taking a hint from the awkward squad paper, and I'm going to read in a file using unsafePerformIO
14:03:16 <seliopou> that file is specified by an argument to the program though
14:03:45 <Cale> I'd generally consider that a bad idea, but you can do it :)
14:03:54 <SamB_XP> ... me too.
14:04:12 <Cale> If you're using unsafePerformIO to read the file, you can get the args in the same do-block
14:04:13 <jethr0> "The conceptual difference is that monads naturally model semantic effects, whereas comonads naturally capture contextual effects."
14:04:19 <jethr0> can someone tell me what semantic effects are?
14:04:37 <seliopou> Cale: I'm aware, but I don't think that matters much
14:04:53 <huschi> isn't args a function? it's value is always the same.
14:04:59 <Cale> huschi: no it isn't
14:05:39 <huschi> but why? is there a possibility to change command line arguments during run time?
14:05:44 <glguy> yes
14:05:48 <glguy> ?hoogle withArgs
14:05:57 <Cale> It's potentially different every time the program runs, and there's withArgs.
14:06:18 <Cale> @type System.Environment.withArgs
14:06:19 <dmhouse> If I import a load of modules and wish to reexport them, do I have to explicitly put 'module X' in the export list or will it happen automatically?
14:06:20 <glguy> ?bot
14:06:24 <Cale> bah
14:06:28 <dmhouse> dons: ping
14:06:34 <dmhouse> Cale: mbot?
14:06:35 <Cale> @type System.Environment.withArgs
14:06:36 <mbot> forall a. [String] -> IO a -> IO a
14:06:36 <dmhouse> Hehe.
14:07:40 <seliopou> You guys are an overly cautious bunch
14:08:02 <allbery_b> ?bot
14:08:03 <mbot> :)
14:08:04 <Cale> unsafePerformIO should be called simonPerformIO
14:08:21 <Cale> :)
14:08:41 <dmhouse> Anyone know the answer to my module question? I have a feeling it got lost in the excitement.
14:08:58 <allbery_b> you need to explicitly re-export it
14:08:59 <SamB_XP> this is not the first proposal to include "simon" in the name of that function
14:09:06 <Axioplase> dcoutis there a socket library for Haskell somewhere ?
14:09:08 <jethr0> as did my question what semantic effects might be ^_^
14:09:22 <allbery_b> axioplase: Network?
14:09:30 <allbery_b> ?doc Network
14:09:30 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/network/Network.html
14:09:36 <Axioplase> allbery_b: thanks
14:09:36 <dmhouse> jethr0: where did you read that?
14:10:01 <jethr0> i think it's in both wikis. i pasted from the hawiki article on comonads
14:10:09 <Cale> dmhouse: you need to explicitly reexport them
14:10:22 <Cale> jethr0: Good question ;)
14:10:53 <jethr0> k, i thought there was still sth major i didn't get about monads, but i guess it's just a weird way to put it
14:11:03 <zeeeeee> is there a non-recursive let in haskell? e.g., i want to do let name = name person
14:11:13 <Cale> zeeeeee: no
14:11:49 <Cale> zeeeeee: also, shadowing identifiers is not considered good style, even where it's allowed
14:11:52 <zeeeeee> i guess i'll have to resort to cases...
14:12:06 <zeeeeee> yes mother :)
14:12:20 <Z4rd0Z> I'm happy I found http://research.microsoft.com/Users/simonpj/Papers/marktoberdorf/mark.pdf.  It has a good description of '>>='
14:12:20 <Cale> I can think of at least one serious lambdabot bug which arose from shadowing identifiers.
14:12:21 <mbot> http://tinyurl.com/ykx24p
14:12:23 <dmhouse> zeeeeee: let nm = name person
14:13:07 <jethr0> shadowing identifier is especially evil when refactoring. seemingly valid changes cause major havoc, that might even be type correct
14:13:36 <Cale> Z4rd0Z: I think that's just for the IO monad, no?
14:13:52 <Cale> But yeah, that description is generally the idea anyway.
14:14:18 <Z4rd0Z> you mean there's more? ;)
14:15:10 <jethr0> hehe
14:15:25 <Z4rd0Z> yeah, the section on monadic IO is what I was referring to
14:15:28 <glguy> shadowing is especially dangerous in Haskell since you typically don't have it
14:15:52 <glguy> at least that is the case when I code, I don't consider reassignments when looking at the code
14:16:01 <allbery_b> IO's probably the weirdest monad.  some of them are fairly simple:  Maybe is about the implext monad you can get (other than Identity)
14:16:07 <allbery_b> *simplest
14:16:30 <Cale> The list monad is slightly more complicated than Maybe, but also really simple
14:16:50 <jethr0> i'm still having difficulty with monads. by now i can more or less use them, but i'm still struggling with writing a sensible new monad on my own./
14:17:18 <jethr0> and it would take me quite a while to come up with all the monad/functor functions for ListM
14:17:40 <Cale> Most new monads you'd want are restrictions of things which you can get from monad transformers.
14:18:25 <glguy> Cale: it's becoming more apparent that what I want is a Monad ;)
14:18:26 <glguy>   = proc _ -> do
14:18:26 <glguy>       s <- getUserState -< undefined
14:18:26 <glguy>       setUserState -< s + 1
14:18:26 <glguy>       mkelem "item" (attrs s) [q,a] -<< undefined
14:18:29 <SamB> which is what is so nice about the newtype-deriving extension!
14:18:33 <Cale> Usually in practical work, you construct new monads by newtyping some stack of monad transformers, and then defining the base operations.
14:18:39 <Cale> yes
14:18:58 <jethr0> SamB: i think you can now automatically derive a newtype from monads, etc.
14:19:09 <jethr0> sry, i thought it was a question
14:19:18 <SamB> jethr0: hehe
14:19:18 <glguy> simply generating Xml doesn't make for an intersting HXT Arrow application ;)
14:19:19 <Cale> glguy: Well, all the arrows in HXT are in the ArrowApply class which means that they're really monads anyway
14:19:50 <Cale> glguy: I've never used the user state feature.
14:19:56 <SamB> me either
14:20:03 <jethr0> hmm, well i still am in a phase where stacking monads isn't quite my daily bread. but hopefully i'll be getting there some day
14:20:10 <glguy> I didn't know how else to number all of the item elements uniquely
14:20:17 <SamB> I think HXT should use typeclasses more
14:20:28 <SamB> so you don't have to have user state if you don't want it...
14:20:35 <glguy> SamB: it does
14:20:43 <glguy> SamB: there are 4 arrows you can use
14:20:47 <glguy> each one adds more state
14:21:00 <SamB> well, okay, where are the arrow transformers?
14:21:01 <jethr0> Cale: is there an example for that "deriving from monad transformer stack" somewhere?
14:21:09 <Cale> and all of them are secretly monads :)
14:21:14 <glguy> instance ArrowXml LA -- Defined in Text.XML.HXT.Arrow.XmlArrow
14:21:14 <glguy> instance ArrowXml (SLA s) -- Defined in Text.XML.HXT.Arrow.XmlArrow
14:21:14 <glguy> instance ArrowXml IOLA -- Defined in Text.XML.HXT.Arrow.XmlArrow
14:21:14 <glguy> instance ArrowXml (IOSLA s)
14:21:24 <Cale> jethr0: you could look at my Sudoku solver
14:21:37 <Cale> http://haskell.org/haskellwiki/Sudoku
14:21:38 <mbot> Title: Sudoku - HaskellWiki
14:21:44 <jethr0> Cale: i've glanced at it. but i'll risk another look
14:21:46 <jethr0> hx
14:21:48 <jethr0> thx
14:21:55 <Cale> newtype Sudoku a = Sudoku (StateT (DiffUArray (Int,Int) Int) Nondet a)
14:21:55 <Cale>     deriving (Functor, Monad, MonadPlus)
14:22:00 <Cale> that's the key point :)
14:22:11 <glguy> I use the IO to write out the resulting Xml
14:22:15 <glguy> I use the state to number nodes
14:22:30 <Cale> If you don't know much about DiffUArrays, don't worry, it's just an array of Ints
14:22:39 <Cale> Nondet is just the list monad in disguise
14:22:51 <glguy> using lambda-expressions instead of (:)
14:22:53 <jethr0> k
14:22:54 <Cale> (it just optimises a bit better in ghc)
14:23:40 <jethr0> so what does the deriving do? does it lift the NonDet monad operations automatically?
14:24:13 <Cale> Well,  StateT ... Nondet  is already an instance of Monad
14:24:32 <Cale> since this is a newtype, it's basically the same as the type it wraps
14:24:50 <Axioplase> Why would "import Parsec" fail when I run ghci on my file ?
14:25:04 <Cale> import Text.ParserCombinators.Parsec
14:25:12 <jethr0> i understand that, but doesn't the derivation give implementaions for ">>=", "return", ...?
14:25:15 <glguy> by default a newtype hids the type from its existing instances
14:25:16 <SamB> because Parsec is a very old name for the module?
14:25:20 <Cale> jethr0: yes, trivial ones
14:25:22 <Axioplase> thanks
14:25:28 <glguy> if you do newtype deriving, it allows that instance to pass through
14:25:44 <jethr0> aahh
14:25:51 <Cale> jethr0: basically, newtype-deriving just copies the existing implementations of typeclasses
14:26:21 <Cale> In fact, since at runtime, the values will be represented exactly the same way, it could even just use the old dictionary.
14:26:29 <nornagon> hm, is there any parsec token thingy that will read a float as a rational? i.e, "1.2" -> 6%5
14:26:36 <jethr0> so, it's just a way of saving some typing work like "data Sudoku ...; instance Monad Sudoku where ..."
14:26:39 <nornagon> > read "1.2" :: Rational
14:26:40 <mbot>  Exception: Prelude.read: no parse
14:26:54 <SamB> Cale: it does
14:26:58 <nornagon> > read "6%5" :: Rational
14:26:59 <mbot>  6%5
14:27:15 <nornagon> > toRational 1.2
14:27:16 <mbot>  5404319552844595%4503599627370496
14:27:19 <SamB> Cale: though obviously it would be nice to have a better spec than that ;-)
14:27:23 <jethr0> yeah
14:27:25 <dmhouse> Yay :) It compiles after much refactoring.
14:28:01 <dmhouse> > toRational (read "1.2")
14:28:02 <mbot>  Exception: Prelude.read: no parse
14:28:12 <dmhouse> > read "1.2"
14:28:12 <mbot>  Add a type signature
14:28:16 <dmhouse> > read "1.2" :: Float
14:28:16 <george> if i have a list of [IO String] i can sequence it to produce an IO [String]. how can i write that entire thing to a file?
14:28:17 <mbot>  1.2
14:28:25 <glguy> ?type sequence
14:28:26 <mbot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
14:28:37 <dmhouse> george: there's a writeFile or something like that.
14:28:41 <dmhouse> ?hoogle writeFile
14:28:41 <mbot> A Hoogle error occured.
14:28:43 <glguy> writeFile "name" (unlines mylist)
14:28:46 <dmhouse> Oh, lovely.
14:28:59 <dmhouse> :t toRational
14:29:08 <dmhouse> ?type toRational
14:29:09 <mbot> forall a. (Real a) => a -> Rational
14:29:14 <jethr0> :t writeFile
14:29:20 <SamB> writeFile "name" . unlines =<< sequence startingList
14:29:33 <dmhouse> ?instance Real
14:29:34 <mbot> Maybe you meant: instances instances-importing
14:29:36 <dmhouse> ?instances Real
14:29:37 <mbot> Double, Float, Int, Integer
14:29:37 <george> dmhouse, perfect ty
14:29:57 <glguy> george: are you generating the [IO String] wtih map?
14:30:01 <dmhouse> > toRational (read "1.2" :: Float)
14:30:02 <mbot>  5033165%4194304
14:30:04 <glguy> george: if so, you might need mapM
14:30:12 <nornagon> > toRational 1.2
14:30:13 <mbot>  5404319552844595%4503599627370496
14:30:21 <dmhouse> That's extremely weird.
14:30:27 <nornagon> > fromRational (6%5)
14:30:28 <mbot>  1.2
14:30:28 <nornagon> not really
14:30:29 <dmhouse> > toRational (1.2 :: Double)
14:30:30 <mbot>  5404319552844595%4503599627370496
14:30:31 <george> my IO String is generated from a replicateM of a function that produces an IO String
14:30:31 <george> =)
14:30:39 <dmhouse> ?type replicateM
14:30:40 <mbot> forall a (m :: * -> *). (Monad m) => Int -> m a -> m [a]
14:30:41 <xerox> % 5404319552844595/4503599627370496 //N
14:30:43 <mbot> xerox: 1.2
14:30:44 <nornagon> 1.2 can't be expressed properly as a double
14:30:54 <emu> don't you love FP
14:30:56 <dmhouse> george: that gives you IO [String] anyway, no need for sequence.
14:30:57 <xerox> % 5033165%4194304 //N
14:30:58 <mbot> xerox:
14:30:58 <mbot>                                     6
14:30:58 <mbot> Out::intm: Machine-size integer expected at position 1 in Out[4.1943 10 ].
14:30:58 <mbot> 5.033165*^6*Out[4.194304*^6]
14:31:24 <george> dmhouse: i put IO [String] in function type. it told me it was infact a type [IO String] i get no errors this way... who am i to argue?
14:31:40 <Cale> % 5033165/4194304 //N
14:31:41 <mbot> Cale: 1.2000000476837158
14:31:49 <dmhouse> george:  Sure you're not using replicate instead of replicateM?
14:31:56 <Cale> % N[5404319552844595/4503599627370496,50]
14:31:57 <mbot> Cale: 1.1999999999999999555910790149937383830547332763671875`50.
14:32:04 <nornagon> heh.
14:32:05 <zeeeeee> is there a way to do binding pattern matching on record names? e.g. let p { name = n } = person in n
14:32:24 <nornagon> > fromRational 6%5
14:32:24 <mbot>  Add a type signature
14:32:24 <dmhouse> zeeeeee: exactly that.
14:32:25 <xerox> zeeeeee: positional pattern matching will work
14:32:26 <george> > genSen :: Map [String] [String] -> Int -> [IO String]         > genSen x y = replicateM y genSenAux x
14:32:26 <mbot>  Parse error
14:32:28 <nornagon> > fromRational (6%5)
14:32:29 <mbot>  1.2
14:32:30 <zeeeeee> that should be: let { p { name = n } = person } in n
14:32:31 <emu> what you wrote
14:32:33 <xerox> oh.
14:32:38 <george> that is exact code
14:32:43 <zeeeeee> yay!
14:32:47 <george> genSenAux produces an IO String
14:32:52 <dmhouse> zeeeeee: no need for the braces, either.
14:33:11 <zeeeeee> dmhouse: how does that work?
14:33:22 <dmhouse> > let a = 5 in 10
14:33:23 <mbot>  10
14:33:26 <zeeeeee> oh
14:33:29 <zeeeeee> i thought you meant the inner
14:33:30 <jethr0> don't you need to write "Type{name=n}" instead of "p{name=n}"?
14:33:31 <glguy> george: what is genSenAux's type then?
14:33:32 <zeeeeee> gotcha
14:33:40 <dmhouse> jethr0: oh, true.
14:33:41 <emu> jethr0: constructor
14:33:51 <jethr0> sry, that's what i meant
14:33:51 <emu> not type
14:33:54 <george> > genSenAux :: Map [String] [String] -> IO String
14:33:55 <mbot>  Not in scope: type constructor or class `Map'
14:33:57 <dmhouse> let Constructor { field = x } = record in ...
14:34:06 <zeeeeee> jethr0: so i need p@(Person {name = n})?
14:34:12 <malebria> @paste
14:34:12 <mbot> http://paste.lisp.org/new/haskell
14:34:15 <dmhouse> zeeeeee: yeah
14:34:20 <jethr0> zeeeeee: if you need the "p"
14:34:26 <guest11> why
14:34:30 <zeeeeee> ok
14:34:56 <nornagon> I need me some infinite-precision rational numbers here, folks
14:34:56 <glguy> genSen x y = replicateM y (genSenAux x) -- missing parens?
14:35:04 <guest11> why
14:35:10 <SamB> nornagon: those are called irrational numbers!
14:35:16 <jethr0> nornagon: there's a list of libraries on the wiki, but there not in ghc AFAIK
14:35:24 <guest11> why
14:35:27 <nornagon> > (read "1.2") :: Rational
14:35:28 <mbot>  Exception: Prelude.read: no parse
14:35:31 <emu> > 1%2
14:35:33 <mbot>  1%2
14:35:33 <glguy> george: I think your replicateM is operating in the ((->)r) monad...
14:35:33 <guest11> why
14:35:35 <nornagon> ^- that's what I want
14:35:35 <guest11> why
14:35:37 <emu> that's infinite precision!
14:35:40 <guest11> why
14:35:43 --- mode: ChanServ set +o dmhouse
14:35:43 <SamB> 1.2 :: Rational
14:35:46 <SamB> > 1.2 :: Rational
14:35:46 <guest11> why
14:35:47 <dmhouse> guest11: stop that please.
14:35:47 <mbot>  6%5
14:35:56 <jethr0> could someone kick guest11 ?
14:35:56 <guest11> why
14:36:01 <shapr> dmhouse: please
14:36:04 --- kick: guest11 was kicked by dmhouse (Kicked by dmhouse)
14:36:04 <SamB> um, I think guest11 is another of those stupid bots
14:36:11 <george> glguy, getting a little too complicated for me
14:36:12 <shapr> thanks
14:36:13 <SamB> except this one doesn't even use multiple phrases
14:36:24 <glguy> george: you are missing parentheses
14:36:27 <glguy> like I showed you
14:36:28 <nornagon> SamB: i need to get them from strings in floating-point form
14:36:29 --- mode: dmhouse set -o dmhouse
14:36:32 <jethr0> i guess it's inquisitive in nature
14:36:32 <Cale> yeah, I think there was one called WikipediaGAST or something like that in #math the other day
14:36:35 <glguy> george: you are replicating in IM
14:36:36 <glguy> IO
14:36:39 <glguy> err
14:36:41 <nornagon> SamB: i need "1.2" -> 6%5
14:36:44 <dmhouse> I'm off, if he comes back, someone else will need to kick(ban) him.
14:36:45 <glguy> george: you are not replicateM-ing in IO
14:36:48 <SamB> nornagon: well... you could write a parser, or maybe steal Parsec's...
14:36:55 <nornagon> If parsec has one... :)
14:36:58 <glguy> > replicateM 3 (+1) 4 -- you are doign this
14:36:59 <mbot>  [5,5,5]
14:37:03 <SamB> @docs Text.Read
14:37:04 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
14:37:07 <nornagon> > toRational (1.2 :: Double)
14:37:08 <mbot>  5404319552844595%4503599627370496
14:37:17 <jethr0> nornagon: the problem is that if at any point you go via machine floating point numbers the precision is lost
14:37:28 <nornagon> jethr0: yes, i know
14:37:36 <jethr0> so, you'd have to parse doubles directly to rationals
14:37:37 <nornagon> i want parsec to spit out rationals
14:37:41 <glguy> genSen x y = replicateM y (genSenAux x) -- george use this and your type will be correct
14:37:42 <nornagon> instead of doubles
14:38:01 <george> genSen calls a function which definitely deals in IO
14:38:04 <jethr0> k, so take the part before the "." plus the part after the dot/10
14:38:06 <glguy> george: trust me
14:38:19 <glguy> just try it
14:38:28 <tuukkah> jethr0, not dot/10 but bot%10 !-)
14:38:33 <george> ok =)
14:38:51 <SamB> @hoogle read
14:38:51 <mbot> A Hoogle error occured.
14:38:55 <SamB> oh right.
14:39:23 <SamB> @docs Data.Numeric
14:39:23 <mbot> Data.Numeric not available
14:39:26 <emu> hoogle sounds like something out of Dr. Seuss
14:39:30 <SamB> @docs Numeric
14:39:30 <mbot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
14:39:41 <george> glguy, yeah that gives me an IO [String]
14:39:50 <nornagon> jethr0: 1.23
14:39:50 <zeeeeee> can i not write the following changeName function? data Person = NamedPerson { name :: String } | UnnamedPerson; changeName :: Person -> Person; changeName n p = p { name = n }?
14:39:53 <jethr0> frac = do {a <- many1 digit; char '.'; b<- many1 digit; return a+b%10}
14:39:56 <SamB> maybe Numeric.readFloat is what you want?
14:39:59 <jethr0> or something like that
14:40:11 <shapr> With this hoogle, I am frugal, search by type and not by string, with that skolem on my golem, I can find most anything!
14:40:13 <zeeeeee> ghc says 'name' is not in scope
14:40:25 * shapr follows emu's advice.
14:40:32 <nornagon> shapr: lol
14:40:47 <SamB> hmm, oh, but note that that only works on *positive* numbers
14:40:49 <jethr0> zeeeeee: that should work, unless i'm missing sth
14:40:52 <glguy> It's scary that: replicateM n (f x) is the same as sequence (replicateM n f x)
14:40:57 <george> saves a 'sequence' call =)
14:40:58 <zeeeeee> jethr0: well, not all Persons have names...
14:41:00 <jethr0> maybe it's the whitespace after "p"
14:41:11 <jethr0> ah, well then it won't ^_^
14:41:21 <zeeeeee> then how do i write such a function?
14:41:28 <glguy> ?type \f n x -> replicateM n (f x)
14:41:29 <mbot> forall (m :: * -> *) a t. (Monad m) => (t -> m a) -> Int -> t -> m [a]
14:41:32 <SamB> nornagon: you got that?
14:41:37 <glguy> ?type \f n x -> sequence (replicateM n f x)
14:41:37 <SamB> Numeric.readFloat
14:41:38 <mbot> forall t (m :: * -> *) a. (Monad m, Monad ((->) t)) => (t -> m a) -> Int -> t -> m [a]
14:41:46 <zeeeeee> do i need to explicitly say changeName p@(NamedPerson _) = ...
14:42:22 <jethr0> or "changeName p@NamePerson{}"
14:42:28 <zeeeeee> hm, that didn't seem to help..
14:42:35 <seliopou> @hoogle String -> IOError
14:42:36 <mbot> A Hoogle error occured.
14:42:41 <nornagon> SamB: right, it's pretty tricky to write something like that
14:42:42 <seliopou> o_O
14:42:50 <seliopou> @hoogle a -> a
14:42:51 <mbot> A Hoogle error occured.
14:42:51 <nornagon> which is why i was hoping parsec had one
14:42:54 <glguy> mbot is out of date wrt hoogle
14:42:55 <nornagon> it doesn't appear to
14:43:00 <allbery_b> backup mbot may not have a hoogle db
14:43:01 <SamB> nornagon: it has
14:43:08 <SamB> in the TokenParser thingy
14:43:08 <nornagon> SamB: oh?
14:43:12 <nornagon> does it?
14:43:13 <SamB> but it is annoying to get at
14:43:15 <jethr0> nornagon: did you see the parsec parser (untested) i posted a few minutes ago?
14:43:17 <nornagon> i haven't found it yet
14:43:21 <nornagon> jethr0: that fails
14:43:24 <SamB> so I'd juse use this one
14:43:26 <nornagon> jethr0: on e.g. 1.23
14:43:37 <tuukkah> jethr0, a+b%(10^floor log b)
14:43:47 <zeeeeee> oh, sorry - typo
14:44:03 <tuukkah> a+b%(10^floor (log b/log 10)
14:44:13 <nornagon> :((((
14:44:19 <nornagon> SamB: where's the one in parsec?
14:44:33 <jethr0> tuukkah: you're right. seems to be my error-night again :(
14:44:45 <SamB> hmm...
14:44:56 <tuukkah> % doesn't work there either, what's the name of the function or operator?
14:44:57 <mbot> tuukkah:
14:44:57 <mbot> ToExpression::sntx: Syntax error in or before "doesn't work there either, what's the name of the function or operator?".
14:44:57 <mbot>                                      ^
14:44:57 <mbot> $Failed
14:44:58 <SamB> Text.ParserCombinators.Parsec.TokenParsers or something?
14:45:14 <SamB> % 100!
14:45:15 <mbot> SamB: 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000
14:45:19 <jethr0> > 1+(4%10)
14:45:20 <mbot>  7%5
14:45:30 <nornagon> the % is in Data.Ratio, i think
14:45:40 <SamB> yes
14:45:46 <SamB> tuukkah: `mod`?
14:45:47 <tuukkah> ok
14:45:59 <SamB> > 25 `mod` 0x10
14:46:00 <mbot>  9
14:46:04 <sandal> hi, can anyone tell me how to install HUnit from source on GNU/Linux with ghc?  (specifically ArchLinux)
14:46:05 <tuukkah> no, i needed the import
14:46:34 <SamB> ah
14:46:34 <sandal> I'm new to Haskell, and want to go through tutorials and whatnot test-first when possible
14:46:41 * SamB doesn't know HUnit
14:46:46 * SamB only knows QuickCheck
14:46:54 <SamB> how many know HUnit?
14:47:02 * jethr0 has used hunit
14:47:06 * sandal looks up QuickCheck
14:47:08 <glguy> % Log[10]
14:47:09 <mbot> glguy: Log[10]
14:47:10 <jethr0> isn't it included with the ghc libraries?
14:47:14 <glguy> % Log[10,2]
14:47:16 <mbot> glguy: Log[2]/Log[10]
14:47:31 <jethr0> Test.HUnit
14:47:46 <sandal> hmm. let me try that
14:48:11 <sandal> yep, that did it
14:48:16 <sandal> thanks jethr0 !
14:48:24 <jethr0> np
14:48:34 <jethr0> first good, sensible and helpful answer i gave tonight
14:48:35 <sandal> I'm interested in HUnit because it's xunit based so it goes good with my Test::Unit experience from Ruby
14:48:45 <sandal> plus my old JUnit experience
14:48:48 <shapr> I've used HUnit
14:48:50 <emu> i always used quickcheck because its so damn cool
14:48:57 <sandal> But is there a strong case for QuickCheck?
14:48:57 <jethr0> sandal: hmm, quickcheck is also quite nice. definitely worth checking out
14:49:07 <sandal> I'm on the site now
14:49:09 <SamB> yeah, quickcheck is cool
14:49:24 <SamB> it saves having to make up silly test data
14:49:26 <shapr> sandal: HUnit demo using IO - http://www.scannedinavian.com/hope/entry/51
14:49:40 <emu> ?check \l -> l == reverse (reverse (l::[Int]))
14:49:42 <mbot>  Not in scope: `myquickcheck'
14:49:45 <emu> doh
14:50:05 <jethr0> SamB: well, that's debatable. unit testing shouldn't actually be done with random data. but then again i've lost a bit of confidence/zest into the whole testing business.
14:50:09 <sandal> oh right, Haskell has some really good type checking stuff.
14:50:17 <jethr0> i guess i'm just getting old and malcontent
14:50:21 <emu> mbot doesn't have the quickcheck plugin
14:50:22 <sandal> But yeah, my unit tests usually reflect use cases
14:50:31 <emu> right, and that may not probe dark corners
14:50:42 <emu> but... you do have to write Arbitrary instances for your own data structures
14:50:59 * glguy wonders how \l -> l == reverse (reverse (l::[Int])) could ever be automatically tested
14:50:59 <jethr0> emu: supposedly tests should be repeatable, i.e. not change their outcome w/o the code having changed
14:51:01 <sandal> true.  Probably useful to use in combination.
14:51:05 <glguy> (randomly)
14:51:13 <sandal> depending on what you have to work with first
14:51:18 <emu> jethr0: quickcheck prints out the failing case
14:51:28 <jethr0> i know, that was not my point
14:51:41 <pejo> jethr0, assuming the tests are psuedo-random, you cna just print out the seed.
14:51:41 <SamB> jethr0: yeah...
14:51:44 <jethr0> i was talking about the "automaticity" and reproducibility of testing
14:51:50 <SamB> a drawback...
14:51:57 <glguy> emu: the value of that test isn't "False" :)
14:52:00 <sandal> emu: I think the issue is that behavior based unit testing is not really about probing dark corners
14:52:11 <sandal> but codifying the expectations about the software
14:52:16 <emu> somewhat, but in practice you just keep track of failing cases
14:52:19 <sandal> both approaches have merit.
14:52:21 <Cale> There's also smallcheck which tends to get a lot of corner cases, using the idea that if a function is going to fail, it's pretty likely to fail on small values.
14:52:27 <sandal> I'll check out both of these tools, thanks!
14:52:34 <jethr0> tests should be written to cover ALL corner cases. but then again that's often unrealistic and quickcheck is a damn cool tool.
14:52:42 <emu> quickcheck is by far no proof of soundness
14:53:14 <Cale> Tests are a way to prove that things are incorrect, not that they're correct
14:53:30 <SamB> quickcheck works better than stupid tests I made up myself
14:53:50 <jethr0> Cale: well, if your tests reflect the specifications, you can prove that the specs were implemented (assuming your tests are correct and total)
14:54:06 <SamB> jethr0: maybe!
14:54:07 <shapr> sandal: I also extendend quickcheck to save failing test cases at one point. That covers the xUnit part of the idea.
14:54:23 <Cale> right, that's one good aspect about quickcheck is that it makes you think about what things your functions ought to satisfy
14:54:25 <sandal> shapr: not exactly.
14:54:37 <sandal> I still like to be able to take actual cases i am working with
14:54:46 <sandal> and code assertions for them
14:54:58 <sandal> if quickCheck can do that, maybe I'm sold :)
14:55:03 <Cale> and perhaps you'll write better programs if you're forced to consider their algebraic properties from time to time
14:55:03 <shapr> Hm, I could probably extend my extension to allow you to specify the 'failed cases' ahead of time.
14:55:13 <sandal> that'd be excellent
14:55:36 <dmhouse> What does Hom(... , ...) mean in category theory? I can't find it on Wikipedia.
14:55:45 <jethr0> sandal: it can
14:55:49 <sandal> A lot of the work I do is very much case dependent.  It doesn't matter if it's correct on a general level, at least not at the time I specify any given expectation
14:55:55 <emu> homomorphism
14:55:55 <shapr> dmhouse: Maybe homomorphism or homotype?
14:55:56 <Cale> http://en.wikipedia.org/wiki/Hom_functor
14:56:01 <sandal> jethr0: can you point me at an example?
14:56:22 <Cale> That defines them :)
14:56:34 <Axioplase> ?doc ParsecExpr
14:56:34 <mbot> ParsecExpr not available
14:56:52 <jethr0> i'll see if i can
14:57:37 <dmhouse> Cale: thanks.
14:57:52 <Cale> In general, Hom(A,B) is the set of morphisms f: A -> B
14:58:00 <jethr0> sandal: i think you can just write a property that tests a concrete case.
14:58:22 <sandal> alright, I'll try that out then
14:58:33 <jethr0> "prop_Test1 = value == 5", but as this is my error-night i'm not so sure anymore
14:58:37 <sandal> I'm going to work with HUnit at first since I'm taking my first steps
14:58:47 <Cale> but Hom(A,-) and Hom(-,B) are considered as functors in a nice way, and Hom(-,-) as a bifunctor. Here, - is used rather like a lambda abstraction.
14:58:51 <sandal> and it's a familiar form to me
14:59:07 <sandal> once I learn Haskell basics, I'll surely take a look at QuickCheck
14:59:14 <sandal> the generalized assertions sound awesome
15:02:41 <luqui> how do I convince Parsec to do indentation-based parsing?
15:03:02 <luqui> is there an established idiom for that?
15:03:13 <dmhouse> Cale: that's so much better than the entire Wikipedia article, which gives the formal definition but completely fails to provide me with any intuition.
15:03:13 <SamB> luqui: why would you want to do that with Parsec?
15:03:25 <sandal> hooray! I'm failing my first tests in Haskell!
15:03:27 <sandal> thanks guys
15:03:27 <SamB> is happy really *that* bad?
15:03:28 <luqui> what do you recommend instead?
15:03:31 <luqui> happy eh?
15:03:44 <jgrimes> I like happy
15:03:46 <SamB> best used with alex for lexing
15:04:05 * luqui ponders... he is pretty familiar with parsec
15:04:10 <luqui> but if happy is better somehow...
15:04:18 <SamB> parsec is cool
15:04:59 <nornagon> :)
15:05:06 <SamB> but it isn't so great with stuff like layout and tokenization...
15:05:09 <shapr> sandal: If you have any questions about that HUnit code on my blog, feel free to ask me.
15:05:30 <sandal> shapr: i missed the link
15:05:39 <shapr> sandal: http://www.scannedinavian.com/hope/entry/51
15:06:23 <luqui> okay, so suppose I use happy... how do I do that?
15:06:34 <luqui> (indentation-based parsing)
15:06:37 <luqui> I've never done that before
15:06:38 <sandal> sweet, I was just going to ask about how to run the tests without having to run ghci
15:07:12 <shapr> sandal: I use one button testing in emacs. More details if you use emacs too...
15:07:18 <sandal> vim
15:07:19 * glguy wonders why forM isn't paired with for
15:07:28 <sandal> should have no trouble binding that
15:07:32 <shapr> I keep meaning to try zero button testing with kolmodin's recent inotify Haskell binding.
15:07:37 <tuukkah> damn what's this = 10 ^ floor (log 1000 / log 10) == 100
15:07:53 <sandal> shapr: in ruby I use autotest
15:07:59 <shapr> What does autotest do?
15:08:09 <sandal> which continuously runs the tests whenever there are changes to the source in a project
15:08:09 <shapr> I've used Python and Java heavily, but not Ruby.
15:08:12 <shapr> ah
15:08:18 <sandal> runs the whole suite first
15:08:21 <shapr> That's pretty much what I want with the zero button testing.
15:08:23 <sandal> then a case for the file
15:08:28 <luqui> tuukkah, floating point troubles
15:08:35 <shapr> Though hooking darcs might be easier for my projects.
15:08:37 <sandal> and then individual assertions once it narrows down trouble
15:08:42 <luqui> I get log 1000 / log 10 == 2.9999999999999996
15:08:44 <shapr> sandal: way cool, I want that.
15:08:46 <sandal> which is pretty nice
15:08:53 <shapr> sandal: What brings you into the Haskell world?
15:08:55 <sandal> lets you know of typos *FAST*
15:09:00 <shapr> Yeah, I can believe it.
15:09:13 <sandal> Oh, taking a semester off of university
15:09:28 <sandal> I think it's good to learn a new language every year or so
15:09:32 <shapr> Yeah, I agree.
15:09:43 <sandal> So Haskell seems interesting and a lot of Rubyists are fond of it
15:09:49 <shapr> Though Haskell has held almost all of my attention the past five years.
15:10:00 <sandal> Ruby for about 2.5 for me
15:10:06 <sandal> Perl previous to that
15:10:09 <tuukkah> luqui, do you have in mind any safe way to get the number of digits of a number?
15:10:18 <jethr0> length . show
15:10:20 <sandal> but I learned C,C++,Python,and Java in between
15:10:23 * glguy wonders if this is considered bad style:
15:10:23 <glguy>     groupHead xs = for groupNames $ \groupName ->
15:10:24 <glguy>                      (groupName, [ys | (y:ys) <- xs, y == groupName])
15:10:26 <shapr> I learned Joy for awhile, and then some PostScript and Forth as part of that whole exploration.
15:10:44 <shapr> And I recently tried Aardappel, but couldn't get anything done with it.
15:10:44 <tuukkah> jethr0, that doesn't count :-)
15:10:47 <sandal> Haskell will be my first real jump into functional programming
15:10:56 <sandal> I mean, Ruby has some functional aspects to it for sure
15:10:59 <luqui> tuukkah, do you know it's an integer?
15:11:10 <sandal> foldr and foldl look very similar to our inject
15:11:10 <tuukkah> luqui, yes
15:11:15 <sandal> map is same as perl or ruby
15:11:19 <shapr> sandal: #haskell is a good place in my experience, I think you'll enjoy the community here.
15:11:26 <jethr0> tuukkah: also "truncate . log 10" or sth like that should really work
15:11:57 <sandal> Ruby's community is really good, so if a lot of Rubyists are also interested in Haskell, it speaks well of the language / community
15:12:01 <sandal> (to me)
15:12:20 <shapr> Yeah, I see what you mean.
15:12:26 <sandal> so i'm looking forward to it.
15:12:28 <luqui> tuukkah, you could do something like computing the difference in one digit...
15:12:40 <sandal> mostly interested in learning some new ideas and whatnot
15:12:55 <luqui> but that won't generalize
15:12:55 <luqui> hmm
15:13:01 <shapr> sandal: Yeah, that's what gets me into new things too.
15:13:17 <jethr0> > let len x = 1+(truncate $ log x / log 10) in len 20000
15:13:18 <mbot>  5
15:13:47 <luqui> > let len = 1+(truncate $ log x / log 10) in len 1000
15:13:48 <mbot>  Not in scope: `x'
15:13:57 <luqui> er
15:14:01 <luqui> > let len x = 1+(truncate $ log x / log 10) in len 1000
15:14:01 <mbot>  3
15:14:12 <jethr0> ups
15:14:15 <jethr0> log 1000 / log 10
15:14:17 <jethr0> > log 1000 / log 10
15:14:18 <mbot>  2.9999999999999996
15:14:37 <jethr0> maybe i should've read your comment on that "feature" earlier
15:14:42 <sandal> hmm. shapr
15:14:47 <sorear> ohh, mbot ...
15:14:48 <sandal> I tried your main = ... code
15:14:56 <sandal> and i got a compile error
15:15:01 <jethr0> isn't there a sensible "log" function around which you can give the base?
15:15:19 <jethr0> > logBase 10 1000
15:15:20 <mbot>  2.9999999999999996
15:15:30 <sorear> what happened to lb?
15:15:30 <jethr0> yeah
15:15:32 <sandal> saying the last statement in a do construct must be an expression
15:15:35 <luqui> d'oh
15:15:40 * luqui loathes floating point
15:15:46 <sandal> i will paste
15:16:03 <sorear> @seen lambdabot
15:16:03 <mbot> lambdabot is in #haskell. I don't know when lambdabot last spoke.
15:16:07 <allbery_b> http://paste.lisp.org/new/haskell please
15:17:08 <sandal> http://pastie.caboo.se/32189
15:17:13 <mbot> Title: #32189 - Pastie
15:17:21 <jethr0> let l x = if x < 1 then 0 else 1+(l (x/10)) in l 1000
15:17:24 <jethr0> > let l x = if x < 1 then 0 else 1+(l (x/10)) in l 1000
15:17:26 <mbot>  4
15:17:26 <luqui> let len x = until (\n -> 10 ^ n > x) (+1) 0 in len 1001
15:17:30 <luqui> > let len x = until (\n -> 10 ^ n > x) (+1) 0 in len 1001
15:17:31 <mbot>  4
15:17:35 <luqui> > let len x = until (\n -> 10 ^ n > x) (+1) 0 in len 1000
15:17:36 <mbot>  4
15:17:39 <jethr0> even better
15:17:39 <luqui> but that's cheating :-)
15:17:39 <allbery_b> looks like a netsplit happened to lambdabot, fwiw
15:17:45 <sandal> i just used like, a default call to ghc though
15:17:54 <sandal> ghc my_test.hs -o foo
15:18:08 <tuukkah> jethr0, once again something that doesn't count =)
15:18:09 <sandal> not sure if I need more than that
15:18:19 <sandal> or if there are some problems in the code
15:18:29 <luqui> tuukkah, i'm not sure if you're going to be able to do it with floating point
15:18:40 <tuukkah> still best this far is decimal a b = a%1 + (b % (10 ^ (length $ show b)))
15:18:42 <luqui> what are your constraints?
15:19:19 <tuukkah> luqui, basicly, do it in math and have it work in ghc
15:19:52 <luqui> where "in math" is defined as...
15:20:00 <nornagon> > parseTest (char '.') "."
15:20:02 <mbot>  Not in scope: `char'
15:20:06 <tuukkah> of course i'm just toying so there aren't any real requirements
15:20:07 <jethr0> well, for the original problem there's still the option of doing:
15:20:10 <sandal> oh wait
15:20:15 <allbery_b> sandal: what line number for the error?
15:20:18 <sandal> let me try something
15:20:28 * allbery_b thinks it's indentation, the statements int he do need to line up
15:20:36 <tuukkah> nornagon, does that decimal function help you anything?
15:20:40 <luqui> tuukkah, so there are some evil things you can do to check for that corner case
15:20:52 <sandal> my name for the testlist was wrong
15:20:53 <nornagon> tuukkah: nah, i'm doing some hack'ry with foldr
15:20:55 <sandal> but that didn't fix it
15:21:03 <sandal> it says 7:10
15:21:07 <luqui> but it would take some rigorous numerical analysis to do those evil things right
15:21:15 <allbery_b> right, it's the indentation
15:21:30 <allbery_b> changef the following lines to start at the same column as the "c <-" n line 7
15:21:32 <jethr0> frac = do {a <- many1 digit; b <- char '.'; c <- many1 digit; return . readRational $ a++b++c}
15:21:46 <nornagon> readRational, eh?
15:21:47 <shapr> sandal: http://www.scannedinavian.com/~shae/ProtoHunit.hs
15:21:48 <mbot> http://tinyurl.com/yxygld
15:21:49 <allbery_b> change the following lines to start at the same column as the "c <-" on line 7
15:21:51 <nornagon> ?type readRational
15:21:52 <mbot> Not in scope: `readRational'
15:22:15 <jethr0> nornagon: not sure how it's called, but someone said it was in Ratio or Numeric or whatever
15:22:22 <tuukkah> my calculator is able to do these things right, it must be using more clever algorithms
15:22:27 <shapr> sandal: That's a version of my blog entry that should work out of the box.
15:22:30 <sandal> shapr: got a forbidden
15:22:42 <shapr> urg
15:22:48 <sandal> ooh, allbery_b Haskell is indentation sensitive?
15:22:56 <shapr> ok, try again
15:22:58 <allbery_b> yes, it's called "layout"
15:23:09 <nornagon> jethr0: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html#t%3ARatio <- not there :/
15:23:10 <mbot> http://tinyurl.com/wymdg
15:23:17 <allbery_b> tuukkah: most calculators work in BCD internally, I think.  certainly HPs' did
15:23:32 <sandal> yuck
15:23:50 <allbery_b> you can use explicit braces and semicolons if you want
15:23:55 <sandal> that gave me a more helpful error though
15:24:01 <sandal> allbery_b: oh, hmm
15:24:07 <luqui> tuukkah, also with less precision it will get the answer right more often
15:24:13 <luqui> (paridoxically)
15:24:27 <shapr> Jag har ingen aning.
15:24:43 <tuukkah> i think the key is to know how much precision you have and not display more in results
15:25:04 <nornagon> > foldr (\f d -> (f + fromIntegral (digitToInt d))%10) "123"
15:25:05 <mbot>  Couldn't match `Char' against `Ratio b'
15:25:07 <tuukkah> that way toRational 1.2 comes out right
15:25:21 <nornagon> > foldr (\f d -> (f + fromIntegral (digitToInt d))%10) 0%1 "123"
15:25:22 <mbot>  Couldn't match `Char' against `Ratio b'
15:25:56 <nornagon> > foldr (\f d -> (f + fromIntegral (digitToInt d))%10) (0 :: Rational) "123"
15:25:56 <luqui> > foldr (\f d -> (f + fromIntegral (digitToInt d))%10) 0 "123"
15:25:57 <mbot>  Couldn't match `Char' against `Ratio b'
15:25:58 <mbot>  Couldn't match `Char' against `Ratio b'
15:25:59 <allbery_b> d is a ratio there, not a char
15:26:06 <luqui> oh
15:26:07 <nornagon> hmm.
15:26:07 <luqui> duh
15:26:08 <allbery_b> hm, wait
15:26:13 <jethr0> :t foldr
15:26:19 <nornagon> ?type foldr
15:26:20 <mbot> forall b a. (a -> b -> b) -> b -> [a] -> b
15:26:31 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d))%10) (0 :: Rational) "123"
15:26:31 <jethr0> foldr has switched args...
15:26:31 <mbot>    Occurs check: cannot construct the infinite type: b = Ratio b
15:26:32 <mbot>    Expe...
15:27:07 <nornagon> :/
15:27:19 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d))%10) 0 "123"
15:27:20 <mbot>    Occurs check: cannot construct the infinite type: b = Ratio b
15:27:20 <mbot>    Expe...
15:27:58 <jethr0> k, good night folks
15:28:16 <shapr> g'nite jethr0
15:28:30 <shapr> sandal: What's your current error?
15:29:20 <sandal> whoa
15:29:38 <sandal> a wild amont of undefined references in HUnit
15:29:42 <shapr> ??
15:29:55 <shapr> Can you paste the errors?
15:29:57 <sandal> i'll post code + errors
15:30:00 <shapr> ok
15:31:00 <sandal> actually, let me log onto IRC from within the virtual machine I'm working in so I don't have to keep swapping back and forth
15:31:19 <sorear> shapr: and I thought that only happened on humor sites!  (wrt SW)
15:32:52 <sandal> alright, that should make life easier
15:33:10 <sandal> http://pastie.caboo.se/32190
15:33:11 <mbot> Title: #32190 - Pastie
15:33:37 <allbery_b> use ghc --make ?
15:34:04 <Igloo> Or -package HUnit
15:34:09 * allbery_b notes you're' now losing indentation somewhere in your pastes
15:34:37 <tuukkah> > foldr (\d f -> (f + toRational (digitToInt d))*(1%10)) 0 "123"
15:34:38 <mbot>  123%1000
15:34:42 <tuukkah> phew
15:34:50 <sandal> ut oh, let me fix it
15:35:24 <sandal> actually, no need, allbery_b that works
15:35:30 <sandal> cool
15:35:44 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) (0%1) "123"
15:35:45 <mbot>  123%1000
15:35:46 <nornagon> oh damn
15:35:54 <allbery_b> Igloo's suggestion is "more correct"; --make forces ghc to work out the -package arguments etc.
15:35:55 <nornagon> somebody else came up with it before me :P
15:36:06 <allbery_b> heh
15:36:12 <tuukkah> but yours is much better
15:36:18 <nornagon> :P
15:36:35 <nornagon> i guess it'll coerce to the type of the second argument to foldr
15:36:41 <sandal> alright, I'll remember that allbery_b
15:36:57 <sandal> alright, now my next question would be
15:37:07 <tuukkah> nornagon, haskell isn't supposed to coerce
15:37:20 <tuukkah>  > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) 0 "123"
15:37:22 <sandal> can i put this main= part in a seperate file and just call it somehow?
15:37:29 <tuukkah> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) 0 "123"
15:37:29 <mbot>  0.123
15:37:44 <tuukkah> infer, though
15:37:48 <allbery_b> you'd want to rename it to something else, since main is "special"
15:37:53 <nornagon> tuukkah: eh, same thing
15:38:07 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) (0 :: Float) "123321524256536746732545"
15:38:08 <mbot>  0.12332152
15:38:08 <tuukkah> would that actually be defaulting in action
15:38:11 <allbery_b> but sure.  "module Tests (myTest) where" and then "import Tests" where you want to use it
15:38:16 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) (0 :: Double) "123321524256536746732545"
15:38:17 <mbot>  0.12332152425653675
15:38:26 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) (0 :: Rational) "123321524256536746732545"
15:38:27 <mbot>  24664304851307349346509%200000000000000000000000
15:38:41 <nornagon> > foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) (0 :: Rational) "5"
15:38:42 <mbot>  1%2
15:38:48 <sandal>  allbery_b but I want it to be main, actually
15:39:04 <tuukkah> my point is you could as well do it on the result
15:39:08 <allbery_b> "main" is the entry point, though
15:39:16 <sandal> alright
15:39:18 <sandal> so you're saying
15:39:21 <sandal> name it something else
15:39:25 <sandal> and call it from main
15:39:31 <allbery_b> you could also leave it as "main" but "import qualified Tests" and then refer to Tests.main
15:39:38 <tuukkah> > (foldr (\d f -> (f + fromIntegral (digitToInt d)) / 10) 0 "123") :: Rational
15:39:39 <mbot>  123%1000
15:40:03 <sandal> oh hmm... there is a test runner in for HUnit?
15:40:31 <sandal> http://pastie.caboo.se/32192
15:40:31 <mbot> Title: #32192 - Pastie
15:40:43 <sandal> that has the indentation fixed
15:40:48 <sandal> what i'd like to do
15:41:01 <sandal> is never write the main= part again
15:41:29 <sandal> so whatever is a good way to do that would make me happy
15:41:43 <allbery_b> right, so just call it doTests instead of main, or something
15:41:58 <sandal> sure, okay
15:42:13 <sandal> then I just stick that in a .hs file and import it?
15:42:18 <allbery_b> you can still make a stub main program to run it (main = doTests) or just leave it as is and run it from ghci
15:42:27 <allbery_b> you need to add a module header, like I said earlier
15:43:43 <sandal> sweet
15:44:02 <allbery_b> http://pastie.caboo.se/32194
15:44:03 <mbot> Title: #32194 - Pastie
15:45:22 <allbery_b> you need to call the file Tests.hs since haskell compilers use the module name to find the interface filename
15:45:27 <dcoutts> Axioplase, mainQuit suffices
15:45:44 <nornagon> dcoutts: scroll down ;P
15:45:56 <allbery_b> but then you can just "import Tests" and doTests will be available
15:46:08 <dcoutts> nornagon, oh, he got an answer did he? :-)
15:46:44 <nornagon> dcoutts: i meant more that the question was asked a forever ago; not that he already got an answer :)
15:47:08 <sandal> yeah, allbery_b that works.
15:47:12 <dcoutts> nornagon, keyword highlighting :-)
15:47:18 <sandal> now the trouble is, it can't see my tests=
15:47:27 <sandal> so do i need to past the testlist as an argument
15:47:39 <nornagon> dcoutts: ah, right :)
15:47:43 <sorear> @seen dons
15:47:43 <mbot> dons is in #haskell. I don't know when dons last spoke.
15:48:04 <dcoutts> sorear, that's because he's on a plane to the UK
15:48:16 <sandal> http://pastie.caboo.se/32196
15:48:16 <mbot> Title: #32196 - Pastie
15:48:20 <sandal> that's my Tests.hs
15:48:22 <dcoutts> should be here in 6 hours
15:50:10 * sorear realizes data-mining should be done in /msg :)
15:50:20 <sorear> oh duh
15:50:39 <sorear> lambdabot is not dead (freenode would've dropped the connection)
15:51:24 <sorear> maybe it fails netsplits because lambdabot has no locking and is multithreaded and netsplits cause dozens of concurrent mutatations to the same objects?
15:58:51 <sandal> hmm... this Tests.hs still doesn't quite work
15:59:11 <sandal> http://pastie.caboo.se/32198
15:59:11 <mbot> Title: #32198 - Pastie
15:59:24 <sandal> I figured i could pass the testList in
15:59:33 <sandal> but i may be defining the function incorrectly
15:59:39 <sandal> (infact, I'm sure I am)
16:00:19 <sandal> hehe, interesting choice of hello world program, a test runner :)
16:00:23 <shapr> :-)
16:00:52 <sandal> anyone see obvious problems with that code?
16:01:44 <sandal> I'm getting a parse error, so I know something I'm doing there is clearly some figment of my imagination when it comes to Haskell :)
16:02:23 <Cale> sandal: ensure that there are no tab characters in your file, for one
16:02:26 <allbery_b> line 5.  "runtests t" *what*?
16:02:42 * allbery_b thinks you lost a "= do", and some indentation
16:03:03 <Cale> oh, I'm also looking at the wrong file
16:03:13 <allbery_b> and what are you expporting from the module?  ("module Tests where")
16:03:23 <Cale> fails needs to be indented to the same spot as errs
16:03:30 <sandal> Cale: There are no tab chars on my computer. :)
16:03:37 <malebria> allbery_b: everything.
16:03:38 <sandal> well thats an exaggeration
16:04:03 <sorear> yeah, no 9's in ANY of your binary files would be interesting :)
16:04:04 <allbery_b> malebria: perhaps I should phrase that "what *should* you be exporting"
16:04:16 <sandal> hehe
16:04:21 * allbery_b thinks it's good to think about such things
16:04:31 <sandal> I'd like to export just runTests
16:04:35 <falconair> what's the best way of interfacing with GHCi (perhaps something like a GUI front-end) ... is there a way to take a string (haskell expression), send it to ghci, get back the result or meta data such as its type, perhaps access its environment?
16:04:41 <malebria> allbery_b: It's good for certain.
16:04:41 <sandal> and have it expect a TestList
16:04:49 <allbery_b> did you see my earlier paste?
16:05:03 <Cale> sandal: the problem in http://pastie.caboo.se/32198 is the indentation of fails
16:05:04 <mbot> Title: #32198 - Pastie
16:05:15 <sorear> falconair: lambdabot uses runProcess et al, there's also a GHC API now that you should look at
16:05:24 <Cale> oh, and the missing "= do"
16:05:25 <allbery_b> http://pastie.caboo.se/32194
16:05:26 <mbot> Title: #32194 - Pastie
16:05:47 <allbery_b> that can be modified easily to take a list of tests
16:05:56 <sandal> allbery_b: it was the blasted indention
16:06:03 <sandal> it now works
16:06:05 <shapr> yay
16:06:37 <sandal> SWEET! i've got a test runner
16:06:43 <sorear> shapr: yow.  And I thought that kind of thing only happened on humor websites.  (wrt blogpost)
16:07:02 * allbery_b knows better
16:07:03 <falconair> sorear: isn't 6.6 also supposed to have an api which parses and executes haskell expressions ... is that the same as GHC api?
16:07:04 <nornagon> @yow
16:07:11 <nornagon> ... whu?
16:07:13 <sandal> now, is there any way I can add like a ~/lib to ghc's loadpath?
16:07:20 <sandal> in the least painful way?
16:07:23 <TomMD> ?where paste
16:07:30 <nornagon> mbot died :(
16:07:48 <TomMD> when?
16:07:55 <nornagon> 11:02:02 -!- mbot [n=mbot@CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com] has quit [Remote closed the connection]
16:08:08 <tuukkah> ghc -i$HOME/lib
16:08:19 <sandal> tuukkah: yes, I know that works
16:08:24 <sandal> I want to make it permanent
16:08:35 <sorear> @bot
16:08:35 <sandal> is there an environment variable set by ghc
16:08:36 <sorear-lambdabot> :)
16:08:36 <shapr> sorear: heh, I guess not :-)
16:08:40 <tuukkah> well, it was painful to me to get that far :-)
16:08:48 <sandal> or should i just make an alias
16:09:09 <tuukkah> perhaps a script is less painful
16:09:57 <sandal> well yeah, i'd like to set it in my .bashrc
16:10:18 <sorear> @quit restart with +RTS -Ds
16:10:23 <shapr> TomMD: Are you the Dr Tom who used to live next to me in Mountain Brook?
16:10:28 <tuukkah> then you naturally want an alias or a function
16:10:38 <shapr> TomMD: Or is that Tom in Maryland?
16:10:50 <tuukkah> i hate to touch .bashrc because then i need to restart all shells
16:10:53 <sandal> tuukkah: some languages use an environment variable
16:11:14 <sandal> tuukkah: i was wondering if ghc had one, I'll poke around
16:11:23 <allbery_b> I don't see one
16:11:32 <sandal> tuukkah: or just do .~/.bashrc
16:11:45 <allbery_b> normally if you're going to do that you make a package instead, then you can use GHC_PACKAGE_PATH --- but there's a default user package path
16:11:57 <zeeeeee> when does haskell close the file that i read using readFile?
16:12:05 <sandal> allbery_b: alright, I'll alias the sucker
16:12:06 <sorear> when you finish reading it
16:12:31 <tuukkah> sandal, yeah, but it's still O(n) =)
16:12:41 <allbery_b> @go how to write a haskell program
16:12:42 <sorear-lambdabot> http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
16:12:42 <sorear-lambdabot> Title: How to write a Haskell program - HaskellWiki
16:13:10 <sorear> That page is so hard to find I wound up bookmarking it.
16:13:23 * sorear has a grand total of 5 of those
16:13:26 <lisppaste2> TomMD pasted "Replace structure element" at http://paste.lisp.org/display/34681
16:13:36 <allbery_b> there's an exmaple in there for creating a library package; you can then install it ith --user (to put it in the default user package path) and use -package Tests (or --make) for GHC to find it automatically
16:13:59 <TomMD> As in the paste, I have a stupid question about updating a single entry in a data structure
16:14:01 <sjanssen> TomMD: someFoo { elem_one = 10 }
16:14:21 <sjanssen> TomMD: note that this returns a new Foo
16:14:21 <TomMD> But will elem_two remain the same?
16:14:25 <bakert> is there any way to make Text.Html output XHTML instead of capitalised element names, etc.?
16:14:25 <allbery_b> yes
16:14:32 <sjanssen> there is no such thing as updating a data structure in Haskell
16:14:38 <allbery_b> that syntax tells it to produce a copy of someFoo with a new value for elem_one
16:14:46 <sjanssen> TomMD: yes, all the other fields will be the same as someFoo
16:14:47 <TomMD> sjanssen - I know, but that is the quickest way to communicate what I want.
16:14:53 <Eelis> i have a follow-up on TomMD's question. is there a similar construct for updating a single element in a list ?
16:15:02 <TomMD> good, wasn't sure about that sytax
16:15:16 <sandal> hmm... it is now searching the file, but --make isn't working now
16:15:16 <sjanssen> TomMD: good, good.  You can never be sure how experienced a person is
16:15:19 <sandal> can't find the module
16:15:42 <sandal> but -v shows it
16:15:46 <TomMD> * now for a much harder questions... please wait for paste... and thank you all...
16:16:33 * allbery_b doesn't really know how -ifoo works, you may need to manually compile it in that case
16:17:06 <allbery_b> if it's in the current directory it'll realiz it needs to build the .hi file, in an include path it may require you to compile manually to create the .hi file
16:17:34 <sandal> http://pastie.caboo.se/32201
16:17:35 <sorear-lambdabot> Title: #32201 - Pastie
16:17:43 <sandal> alright, no problem, let me try that
16:18:34 <sandal> no dice.
16:19:17 <sandal> with the .hi file living happily in ~/lib, same error
16:19:34 <sandal> I don't understand, this seems to be a pretty common concern
16:19:41 <sandal> how are third party libraries installed?
16:19:54 <sandal> it should be the same process, no?
16:23:06 <sandal> i'd be just as happy knowing how to install it rooted
16:23:08 <tuukkah> sandal, ghc --make does compile automatically for me
16:23:18 <sandal> or to know of a packaging method
16:23:33 <sandal> With something in ~/lib and something somewhere else that links against it?
16:23:40 <tuukkah> yes
16:23:57 <tuukkah> are you sure you have the alias and it's working?
16:24:35 <nornagon> hm, how do i write a parser that accepts "0.", ".0" and "0.0", but not "."?
16:24:36 <tuukkah> ie. you don't have -i ~/lib or -i~/lib or anything like that
16:24:39 <sandal> tuukkah: it says 'Locations searched: ~/lib/Tests.hs'
16:24:49 <nornagon> can't do many digit >> char '.' >> many digit; that matches "."
16:25:12 <sandal> which is there
16:25:13 <tuukkah> sandal, so you didn't use -i$HOME/lib which works...
16:25:27 <nornagon> has to be many digit >> char '.' >> many1 digit <|> many1 digit >> char '.' >> many digit, with 'try' peppered here and there
16:25:29 <sandal> let me try that
16:25:36 <Botje> nornagon: (char '.' >> many1 digit) <+> (many1 digit >> char '.' >> many digit) ?
16:25:38 <sandal> ~ has no good reason of not working :)
16:25:44 <tuukkah> it does have
16:25:55 <allbery_b> ~ is shell magic, programs don't understand it
16:25:55 <tuukkah> ~ is supposed to be expanded by the shell
16:26:04 <nornagon> Botje: <+>?
16:26:12 <tuukkah> and shell expands ~ only in the beginning of a word
16:26:18 <sandal> .bashrc should understand it
16:26:20 <sandal> no?
16:26:27 <sandal> hmm, maybe that's it
16:26:30 <sandal> but $HOME works
16:26:34 <sandal> so i'm good to go
16:26:37 <Botje> nornagon: ehh, <|>, even
16:26:40 <Botje> it's late
16:26:50 <tuukkah> now i don't like that -i dir doesn't work in ghc
16:26:54 <nornagon> Botje: ah, okay :) that works.
16:27:03 <nornagon> and even without 'try'. :)
16:27:09 <nornagon> thanks.
16:27:20 <Botje> nornagon: yes, because parsers may not backtrack after consuming input
16:27:38 <Botje> and the many1 digit complains if there isn't at least one digit, thus ruling out the "." case
16:27:43 <nornagon> Botje: yeah
16:28:11 <nornagon> but, hm. How do I bind the results of the manies into an outside do-block?
16:30:27 <allbery_b> use >>= \v -> to capture results and concatenate or etc. the variables
16:30:33 <sandal> nice.
16:30:36 <sandal> this seems to work well
16:30:40 <nornagon> needs to be something like (a, b) <- (char '.' >> many1 digit >>= \a -> return (0, a)) <|> do { a <- many1 digit ; char '.' ; b <- many digit; return (a,b) }
16:31:04 <nornagon> can you pattern match on the left of a <-
16:31:05 <nornagon> ?
16:31:13 <sorear> yes
16:31:14 <sandal> alias ghc='ghc -i$HOME/lib --make -o a.out'
16:31:28 <sorear> > do (x,y) <- Just (1,2) ; return x
16:31:33 <sorear> > do (x,y) <- Just (1,2) ; return x
16:31:38 <sorear> @botsnack
16:31:38 <sorear-lambdabot> :)
16:31:39 <sorear> > do (x,y) <- Just (1,2) ; return x
16:31:46 <nornagon> heh
16:31:51 <nornagon> stubborn bugger :P
16:32:30 <sorear> it shouldn't work because i don't have the whatnot for runplugs.  but it should at least give an error message...
16:33:29 <lisppaste2> TomMD pasted "STM Transaction Log" at http://paste.lisp.org/display/34685
16:33:59 <sandal> @help
16:33:59 <sorear-lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:34:04 <sandal> @help list
16:34:05 <TomMD> Fun with STMs, if anyone has a good model of STM operation in their head then I would love to hear from you.  The papers I've read didn't quite answer these.
16:34:05 <sorear-lambdabot> list [module|command]
16:34:05 <sorear-lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:34:14 <sandal> @help links
16:34:14 <sorear-lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:34:26 <sandal> :-/
16:34:34 <sorear> what do you want?
16:34:56 <TomMD> Its all in the paste http://paste.lisp.org/display/34685
16:35:10 <sandal> can't remember... the blog post my testrunner is based on
16:35:32 <sandal> Because I'm writing a post about my runner and wanted to attribute
16:36:03 <sorear> TomMD: as I understand it, replicate 4 "yes"
16:37:23 <sandal> got it
16:45:34 <seliopou> is there any way to specify the fail string for a do block?
16:45:46 <nornagon> "fail string"?
16:46:05 <seliopou> If a pattern match fails in a do block, the fail fuction for the monad is called
16:46:11 <sorear> no
16:46:18 <seliopou> fail takes a string, so I'm referring to that string
16:46:28 <seliopou> that suckds
16:46:29 <allbery_b> you could do the pattern match manually
16:46:32 <seliopou> sucks :(
16:46:55 <allbery_b> case xxx of pattern -> do_something; _ -> fail "oops"
16:47:45 <seliopou> allbery_b: I'm aware. It would have been sweet if you could just specify that string for the entire block
16:48:22 * allbery_b suspects if Calr were around he'd rant about how the h98 standard broke this along wth everything else when they killed monad comprehensions :)
16:48:30 <allbery_b> pretend I can type
16:48:36 <Botje> monad comprehensions?
16:48:39 * seliopou pretends
16:48:40 * allbery_b isn't sure he wants to summon :>
16:48:40 <seliopou> :P
16:48:43 <Botje> the mind boggles
16:48:55 <glguy> Monad comprehensions for the win
16:49:12 <allbery_b> when they killed monad comprehensions they killed MonadZero, which forced addition of fail for pattern matches in do blocks
16:49:15 <allbery_b> or something like that
16:49:40 <Botje> but there's still a MonadZero today
16:49:43 <Botje> or is that something different?
16:49:49 <glguy> if Arrow notation has taught us anything, it's that a special notation can depend on more than one typeclass
16:49:55 <allbery_b> there is a monadzero thing, but it's part of MonadPlus
16:49:58 <glguy> -<< requires ArrowApply
16:50:09 <allbery_b> so do notation can't depend on it
16:50:21 <allbery_b> (otherwise it could only be used with MonadPlus, not Monad)
16:50:48 <sorear> according to the Paper, -< automagically chooses between Arrow and ArrowApply ... too bad the implementation doesn't
16:51:05 <glguy> How do you mean?
16:51:43 <sorear> if the procedure mentions an arrow-bound name, it uses app.  otherwise, it doesn't.
16:51:49 <allbery_b> (MonadZero is a much lower bar than MonadPlus)
16:52:10 <sorear> "a new notation for arrows" didn't need -<<.
16:52:31 <tuukkah> so, with many monads you can in practice write do { ... } `mplus` fail "error"
16:53:24 <sorear> IMO monad comprehensions should be dependent on what you *use* ... [ x*2 | x <- y ] should be a mere Functor comprehension
16:53:58 <SamB> sorear: that would work if Monad was a subclass of Functor
16:54:03 <SamB> but it isn't
16:55:47 <allbery_b> hmf.  for some reason I thought they were (possibly the equivalence of fmap/join to >>=/return)
16:55:58 <nmessenger> @wiki The_Other_Prelude
16:56:51 <jcreigh> http://www.haskell.org/haskellwiki/The_Other_Prelude :)
16:56:52 <jcreigh> @bot
16:57:03 <SamB> allbery_b: too bad Haskell can't describe stuff like that adequately!
16:57:05 <sorear-lambdabot> http://www.haskell.org/haskellwiki/The_Other_Prelude
16:57:05 <sorear-lambdabot> :)
16:57:06 <sorear-lambdabot> Title: The Other Prelude - HaskellWiki
16:57:33 <sorear> sorry, my entire net connection was lagging :(
16:59:30 <Cale> I suspect -<< is there just because there's a more efficient translation for -<, or at least, that rewrite rules apply better to the result
16:59:40 <Cale> But that seems like sort of a bad reason
17:00:03 <Cale> It ought to be quite possible to determine when -<< is needed or not.
17:00:16 <sorear> the paper described a system where -< automatically determined if app was needed
17:00:24 <Cale> right
17:00:29 <sorear> anyway app is unimplementable for many arrows
17:00:46 <glguy> because Arrows are more general than monads
17:00:58 <sorear> Cale: what happened to mbot?
17:00:59 <Cale> Yes, ArrowApply means that your arrow is really a monad
17:01:00 <jcreigh> hmm, wait, why *isn't* "map :: (Functor f) => (a -> b) -> f a -> f b"? It's exactly the same in the case of lists, right?
17:01:12 <Cale> I may have killed it somehow :)
17:01:15 <sorear> jcreigh: you will regret that. :)
17:01:18 <glguy> ?bot
17:01:18 <sorear-lambdabot> :)
17:01:27 <glguy> lol, quite the variety today
17:01:41 <Cale> sorear: do you want mbot back here?
17:01:50 <jcreigh> no, really, I don't get it. Is there any reason?
17:02:00 <allbery_b> mbot fell overearlier, so sorear brought up his bot
17:02:02 <glguy> map is fmap on lists
17:02:02 <Cale> jcreigh: H98 process
17:02:11 * allbery_b did warn you :>
17:02:29 <Cale> map used to have that type
17:02:47 <Cale> but apparently there were too many polymorphism haters on the H98 committee.
17:03:16 <tuukkah> an issue with haskell is getting clear error messages
17:03:43 <jcreigh> Cale: ah
17:04:04 <tuukkah> monad comprehensions, functors etc. make it difficult to implementations to provide them
17:04:06 <Cale> So long as you include type signatures for top-level functions and values, I find the error messages are usually reasonably decent.
17:04:33 <Cale> ah
17:05:08 <jcreigh> is there some list of "things we're definitely going to change in Haskell-prime" somewhere?
17:05:08 <Cale> Yeah, part of the reason was that error messages related to functor and monad classes were potentially confusing to beginners.
17:05:27 <Cale> Haskell-prime is mostly a standardisation of what we already hav
17:05:28 <Cale> e
17:05:51 <sorear> HaskellTwo is the (now-defunct) project to fix all the errors in H98
17:05:59 <jcreigh> yes, but, eg, the monomorphism restriction. Does it stay or go?
17:06:22 <jcreigh> sorear: I thought that was called GHC. :)
17:06:23 <allbery_b> http://hackage.haskell.org/trac/haskell-prime ?
17:06:24 <sorear-lambdabot> Title: Haskell Prime - Trac
17:06:28 <sorear> Haskell' will probably be 500 pages long and unlearnable :(
17:06:43 <Cale> sorear: why?
17:07:02 <tuukkah> jcreigh, that's implementing the fixes =)
17:07:10 <sorear> adding ten thousand redundant features ...
17:07:25 <Cale> sorear: huh?
17:07:33 <Cale> Like what?
17:07:39 <Cale> Multiparameter typeclasses?
17:07:47 <nornagon> whee, finally:
17:07:48 <nornagon> > parseTest parser "#e1.2"
17:07:48 <nornagon> 6/5
17:08:12 <sorear> MPTCs, fundeps, ATs, GADTs, etc, etc.  we need at least one, but *all* is overkill.
17:08:50 <Cale> I can see with ATs and FunDeps how you might not want both
17:08:55 <sorear> I think McIlroy's criticism will prove very true...
17:09:01 <Cale> MPTCs are necessary for fundeps to make sense
17:09:10 <Cale> GADTs seem completely unrelated to that
17:09:26 <sandal> http://www.stonecode.org/blog/?p=101
17:09:27 <sorear-lambdabot> Title: Stone Code Weblog  Blog Archive  Haskell, first impressions (with sexy results ...
17:09:37 <sandal> that's the simple test runner I got running
17:09:37 <Cale> MPTCs + FDs are probably what's being standardised, no?
17:09:41 <sandal> thanks to the folks who helped
17:09:46 <sandal> and shapr for the example
17:09:46 <Cale> Are ATs going to get in?
17:11:51 <sorear> @irc-connect freenode-backupconn zelazny.freenode.net 6667 sorear-lambdabo2 Lambdabackup_tell_me_to_@join_in_case_of_split
17:12:38 <Cale> Although they're technically equivalent, ATs and FDs seem different enough forms of expression that wee might actually want both.
17:12:47 <Cale> s/wee/we/
17:13:05 <sorear> ack, dumb oversight makes second connection useless
17:15:57 <shapr> sandal: yay!
17:16:00 <shapr> sandal: Any more questions?
17:16:04 <raxas> sorear: do you think all math is overkill? it's too built on pile of redundant concepts
17:16:33 <sorear> In math, you can ignore extra features
17:16:36 <sandal> shapr: i'm happy that it runs
17:16:47 <shapr> :-)
17:16:53 <sandal> I think i'm now going to actually use it as I work through YAHT
17:16:54 <sorear> programming languages become unimplementable as the feature list grows
17:17:08 <shapr> sandal: Feel free to ask questions here on #haskell
17:17:27 <Cale> But everything which is going into H' must already have been implemented.
17:17:31 <sandal> thanks.  It's a good place.
17:17:58 <sorear> I'm talking new implementations, the kind that are so incomplete no-one else wants to hack on them.
17:17:59 <orbitz> can i force the evaluation of something that's lazy.  a situation where this might be useful would be if my application ahs some idle time it can use to precompute some values and then stor them for when they are finally ready.  Or would there be a more haskell way to do it?
17:18:01 <glguy> Cale: Do you think that Hugs will update to meet the H' standard?
17:18:20 <Cale> Will it even need to change significantly?
17:18:59 <glguy> I don't know
17:19:00 <Igloo> I think it intends to not meet the concurrency requirements, but to otherwise be H'
17:19:23 <shapr> orbitz: There's seq and DeepSeq
17:19:36 <shapr> orbitz: But memoization may be a better approach.
17:20:46 <raxas> sorear: i did coding in *many* languages for the past 30 years. you want believe what stuff is "implementable". but haskell makes me exalted about what's managable.
17:21:02 <sandal> does Haskell support a macro system?
17:21:13 <shapr> Template Haskell
17:21:34 <shapr> http://www.haskell.org/th/
17:21:35 <sorear-lambdabot> Title: Template Haskell
17:21:49 <sandal> neat. i'm looking at it.
17:21:53 <glguy> sandal: but you need that macrosystem a lot less than you would in Lisp
17:22:03 <sandal> is this in hugs / ghc
17:22:05 <shapr> Yeah, I agree with glguy, you rarely need the power of TH.
17:22:07 <shapr> sandal: GHC
17:22:19 <sandal> okay cool, i'm using ghc at the moment
17:22:37 <shapr> Wasn't there a recent blog entry about macro systems, what they're good for, and why Haskell doesn't need one so much?
17:22:39 <sandal> I'm coming from ruby, which doesn't have macros, but we have kickass support for building embedded DSL
17:22:52 <shapr> sandal: Haskell is pretty good at DSLs too.
17:23:01 <shapr> Have you seen Haskore or Dance?
17:23:11 <sandal> shapr: no, I'll take a look
17:23:15 <shapr> Or HaskellDB?
17:23:23 <sandal> I'm thinking of porting the Casting Spels in Lisp tutorial
17:23:36 <sandal> I did that with Ruby a while ago, and it was a fun exercise
17:23:57 <shapr> Heh, SPELs looks like Why's Poignant Guide
17:24:17 <sandal> shapr: that's maybe why I liked it
17:24:26 <sandal> _why is insane :)
17:24:35 <avnit> is there a way to create lists without commas, just with whitespace (kinda like lisp)
17:24:54 <shapr> avnit: Maybe with Applicative?
17:25:00 * shapr thinks..
17:25:03 <glguy> > words "a s d f"
17:25:13 <avnit> hsxml does it kinda ugly
17:25:13 <shapr> Didn't Conor's Idiom library do something like that?
17:25:31 <avnit> glguy: only works with string though, right?
17:25:34 <shapr> Well, ugly is a personal view..
17:25:34 <sandal> haskelldb looks pretty nice
17:25:35 <glguy> avnit: yeah
17:25:58 <sandal> I'm used to things like rake and ActiveRecord and whatnot, of course
17:25:59 <shapr> sandal: Yeah, I call HaskellDB a database 'unwrapper' because it exposes the set theory ops directly.
17:26:13 <shapr> sandal: It lets you do stuff like higher order queries.
17:26:27 <shapr> And I'm especially fond of type checked SQL queries.
17:26:47 <glguy> like C#'s LINQ?
17:27:05 <sandal> even my own DSL isn't terribly bumpy: http://ruport.infogami.com/Simple_Report_Example
17:27:05 <shapr> I don't know anything about LINQ.
17:27:06 <sorear-lambdabot> Title: Simple Report Example (Ruby Reports)
17:27:44 <sandal> shapr: mmh... yeah, that's pretty sweet, type checking on SQL
17:28:19 <glguy> I don't know Ruby, but can you just explain what this line does?
17:28:19 <glguy> log "preparing report", :status => :info
17:28:26 <glguy> and I'll try ot extrapolate from there?
17:28:57 <glguy> mainly the stuff at the comma and beyond
17:29:00 <sandal> Sure, it's using Ruby's logger to record the message with the status info
17:29:11 <shapr> Long ago I worked on 65kloc VB trust management application. Some of the SQL queries were totally insane.. pages and pages of code without any indentation or other non-required whitespace.
17:29:19 <sandal> those are just pseudokeyword arguments
17:29:19 <shapr> I wish we'd had HaskellDB then.
17:29:20 <allbery_b> :xxx is an "atom" (think Lisp 'xxx)
17:29:42 <avnit> it's like log ("preparing report" [("status", "info")])
17:29:49 <allbery_b> => acts like a comma, used for paired things
17:29:50 <shapr> :foo looks like keyword args in Python
17:29:51 <sandal> yes.
17:29:53 <glguy> oh
17:30:07 <sandal> it's an anonymous hash, to be exact
17:30:11 <allbery_b> yeh
17:30:31 <sandal> any symbols are close to atoms, i think
17:30:35 * allbery_b tries to shake brainfuzz loose and recall more ruby :/
17:30:39 <sandal> they're literally just named numbers
17:30:40 <shapr> I played with Ruby for a few weeks. The explicit end really bugs me though I loved the OO model.
17:30:55 <sandal> an object with a unique id and a string representation
17:31:02 <sandal> We want to get rid of them in Ruby
17:31:22 <sandal> since we just need to make Strings have an immutable representation
17:31:34 <sandal> 'freeze' the object
17:31:37 <tuukkah> i read about linq here: http://research.microsoft.com/~emeijer/Papers/ICFP06.pdf
17:31:46 <sandal> so if we just made : syntactic sugar for "something".freeze
17:31:50 <sandal> that'd do the trick
17:32:17 <sandal> But for now, symbols are handy for internal representation of things, as well as pseudo keywords
17:32:26 <shapr> tuukkah: Yeah, I keep meaning to read up on LINQ, but I have a paying Haskell job, and that's much more interesting.
17:32:34 <sandal> also, faster than just creating new strings all the time
17:32:42 <sandal> Potential source of memory leaks though. :-/
17:32:51 <shapr> Haskell doesn't leak memory, just space...
17:33:04 <allbery_b> and sometimes time :)
17:33:08 <shapr> Yeah, that too.
17:33:23 <shapr> You don't get many time leaks in C...
17:33:29 <shapr> Or do you? hmm...
17:33:30 <tuukkah> shapr, too bad :-)
17:33:41 <nmessenger> for (;;) {}
17:33:50 <shapr> SHAZAM!
17:33:51 <nmessenger> pretty big time leak
17:33:59 * nmessenger grows large.
17:34:04 * shapr turns nmessenger into CAPTAIN LAMBDA once again!
17:34:08 * shapr laughs
17:34:11 <sandal> ttp://www.oreillynet.com/ruby/blog/2006/04/nubygems_symbolic_starvation.html
17:34:18 <sandal> err
17:34:21 <sandal> http://www.oreillynet.com/ruby/blog/2006/04/nubygems_symbolic_starvation.html
17:34:22 <sorear-lambdabot> Title: NubyGems: Symbolic Starvation - O&#039;Reilly Ruby, http://tinyurl.com/y7ol9m
17:34:43 <sandal> I'm done ranting ruby, actually, I'll be biab, off to do more of this tutorial
17:34:59 <glguy> putStrLn . evalSudoku $ do { readSudoku xs; solve; showSudoku }
17:35:06 <glguy> an example of Cale's DSL for sudoku solving
17:35:07 <glguy> http://www.haskell.org/haskellwiki/Sudoku#Monadic_Non-Deterministic_Solver
17:35:11 <sorear-lambdabot> Title: Sudoku - HaskellWiki, http://tinyurl.com/y4lh72
17:35:31 <allbery_b> "nmessenger gros large" makes me think LAMBDA HULK SMASH!
17:35:38 <glguy> specifically the stuff inside do
17:35:57 <sandal> 21nice
17:35:59 <nmessenger> "You won't like me, when I'm pointful..."
17:36:03 <sandal> *nice
17:50:42 <sandal> is ghc easy enough to build on an intel based mac?
17:50:56 <sandal> I'm running it in a vm (ArchLinux) right now
17:51:20 <nornagon> i'd imagine so
17:55:36 <stepcut> sandal: http://hackage.haskell.org/trac/ghc/wiki/X86OSXGhc
17:55:37 <sorear-lambdabot> Title: X86OSXGhc - GHC - Trac
17:56:30 <sandal> yuck. ports systems
17:56:41 <sandal> If there was an OS X native one, I'd be all over it
17:57:07 <sandal> otherwise, I'll stick to Linux. :)
17:57:22 <allbery_b> er?
17:57:29 <sandal> I'd be happy with some basic compile from source instructions, if anyone knows of any.
17:57:38 <allbery_b> for one, there's a native intel build on the ghc download page (at the very bottom)
17:57:50 <allbery_b> if you want to compile from source, macports is the way to go
17:58:15 <sandal> No way.
17:58:22 <allbery_b> (think gentoo portage or freebsd ports --- the latter being what macports is modeled on)
17:58:22 <stepcut> sandal: if you have ghc already installed, then you can build from source doing ./configure && make && make install
17:58:25 <sandal> I do not use any of the OS X ports systems
17:58:31 <allbery_b> it's just a packages-from-source system
17:58:48 <sandal> allbery_b: I'm well aware of what macports, darwinports and fink are.
17:59:00 <sandal> And I've used ports in FreeBSD and portage
17:59:08 <sandal> I like ports / portage
17:59:16 <sandal> I do not like any of the OS X ports systems
17:59:33 <sandal> allbery_b: I'm not seeing that link, I see a PPC based package
18:00:06 <sandal> oh, found it
18:00:08 <allbery_b> at the very bottom?
18:00:32 <sandal> yup :)
18:01:02 <sandal> i was looking at an older release by accident
18:01:35 <sandal> stepcut: if I can get it installed via this package, I should be okay
18:01:39 <sandal> stepcut: but thanks!
18:03:41 <nornagon> hm, if i do { s <- sign }, then return either Left . s $ (some rational) or Right . s $ (some integer), I get an error
18:03:53 <nornagon> where sign returns either id or negate
18:04:16 <nornagon> is s somehow being forced into Rational a => a -> a ?
18:06:11 <bd_> nornagon: as a variable, s cannot be polymorphic
18:06:17 <nornagon> :(
18:06:26 <nornagon> why's that so?
18:06:54 <bd_> nornagon: how would it know which sign to evaluate?
18:07:11 <nornagon> the one relevant at the time of evaluation?
18:07:18 <glguy> Cale?
18:07:22 <shapr> stepcut: Hey, did you see the N800?
18:07:25 <bd_> sign :: (Integer -> YourMonad something) or sign :: (Double ->YourMonad something) ?
18:07:30 <bd_> they could be different functions
18:07:37 <bd_> and it won't know which until runtime
18:07:43 <bd_> which isn't allowed in haskell's typesyste
18:07:43 <bd_> m
18:07:50 <nornagon> so it should defer 'till runtime
18:07:54 <nornagon> oh.
18:07:54 <nornagon> darn.
18:07:55 <bd_> though if you expand the scope of sign a bit it'll work
18:08:06 <nornagon> how?
18:08:08 <bd_> if sign is of yupe YourMonad (String -> YourDataType) you should be fine
18:08:20 <bd_> that is
18:08:26 <bd_> Wrapper . read sort of thing
18:08:27 <nornagon> sign :: (Num a) => GenParser Char st (a -> a)
18:08:32 <glguy> ?seen
18:08:32 <sorear-lambdabot> Lately, I have seen allbery_b, bd_, glguy, nornagon, sandal, shapr and stepcut.
18:08:41 <nornagon> hum :(
18:08:48 <bd_> nornagon: yes, it'll try to resolve that to a specific instance of sign
18:08:49 <nornagon> i guess i'll just lower the scope of s
18:08:51 <bd_> at compile time
18:09:29 <shapr> @users
18:09:29 <sorear-lambdabot> Maximum users seen in #haskell: 290, currently: 283 (97.6%), active: 10 (3.5%)
18:09:30 <nornagon> *nod*
18:09:37 <nornagon> okay, i got it working then
18:10:21 <manveru> nornagon: you here?
18:10:31 <nornagon> heh
18:10:37 <manveru> :)
18:10:37 <nornagon> all us ruby guys are :)
18:11:04 <lisppaste2> glguy pasted "<- makes progress understanding proc notation" at http://paste.lisp.org/display/34698
18:11:21 <sandal> Sweet
18:11:34 <sandal> I got it working with no hassle on OS X
18:11:44 * araujo `backFrom` univ
18:11:47 <sandal> normal unix dance
18:14:32 <sandal> lets see if my test runner works okay here... :)
18:15:50 <sandal> sweet!
18:15:53 <sandal> sure doe.
18:15:54 <sandal> *does
18:17:38 <sandal> time to go back to OS X then I guess.
18:19:16 <shapr> rehi sandal!
18:19:34 <sandal> rofl. rehi to you too
18:19:45 * shapr boings cheerfully
18:22:17 <manveru> ?hoogle push
18:22:18 <sorear-lambdabot> No matches found
18:22:25 <manveru> ?hoogle drop
18:22:25 <sorear-lambdabot> Prelude.drop :: Int -> [a] -> [a]
18:22:26 <sorear-lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
18:22:26 <sorear-lambdabot> Data.PackedString.dropPS :: Int -> PackedString -> PackedString
18:25:28 <glguy> ?pl \s -> (mkelem "item" (attrs s) [q,a], undefined) -- flip (,) undefined . flip (mkelem "item") [q,a] . attrs
18:25:28 <sorear-lambdabot> flip (,) undefined . flip (mkelem "item" . attrs) [q, a]
18:28:53 <shapr> g'day kinetik_
18:29:10 <mbishop> no you're g'day!
18:30:03 <kinetik> hello
18:31:37 * shapr goes out for a sandwich, yay!
18:31:54 <sjanssen> with cojack?
18:32:20 <sjanssen> otherwise, don't bother
18:32:36 <shapr> Er, my sister is giving me a free sandwich.
18:32:48 * sjanssen is being goofy
18:33:43 * shapr is always goofy!
18:33:54 <shapr> Ok, not when I actually have Ritalin...
18:33:57 <allbery_b> how's mac & cheese with colby, bleu, and feta strike you?
18:34:01 <shapr> mmm!
18:34:08 <shapr> Ok, I really gotta go get a sandwich now.
18:34:16 * allbery_b overdid the bleu a bit, actually; it's a little *too* strong:)
18:34:35 <shapr> allbery_b: I like mutton cheese, gorgonzola, limburger, etc It can't get too strong!
18:34:53 <shapr> Though mutton cheese I have to do in small doses, otherwise I'd have to buy a new fridge.
18:35:04 <shapr> Gruyere is the best cheese in the world.
18:35:05 <sandal> hmm... my .bashrc hack with the alias does not seem to work from inside vim
18:35:12 <sandal> at least not on OS X
18:35:44 <allbery_b> export ENV=$HOME/.bashrc # maybe?
18:36:19 <allbery_b> although I thought bash ran .bashrc in noninteractive shells as well
18:36:54 <allbery_b> hm, info file says not.
18:36:58 <allbery_b> so do the ENV thing
18:37:48 <allbery_b> or $BASH_ENV instead of ENV, same thing but bash-specific ($ENV is used by ksh as well)
18:37:50 <nornagon> whee, my scheme parser now parses *most* of the full R5RS numeric tower
18:38:03 <nornagon> as a result of which it is horribly complex
18:38:09 <bd_> heh
18:38:22 <sandal> oh, i just realized
18:38:25 <bd_> Have you made the requisite Num and etc instances for your numeric type yet? :)
18:38:25 * allbery_b thought scheme was supposed to be simple...
18:38:29 <sandal> i'm going to want a keybinding anyway
18:38:30 <nornagon> it doesn't yet deal with #xf/e
18:38:56 <nornagon> the thing needs a refactor
18:39:03 <sandal> i'll just stick the command directly in the binding
18:39:09 <allbery_b> <- aside from elisp and (years ago) xlisp, hasn't actually used lisp/scheme since maclisp :)
18:41:01 <sandal> sweet
18:41:06 <sandal> all is well now :)
18:41:29 <sandal> <C-h> compiles and runs abitrary haskell
18:41:39 <sandal> including my ~/lib folder in the load path :)
18:42:58 <orbitz> does ghc not produce nearly as fast code on windows as it does on *NIX environments?  the same program take sa lot longe rot run on my work windows PC than on my little macbook
18:43:14 <sandal> map <C-h> :!ghc -i$HOME/lib/ --make -o hs.out % && ./hs.out<CR>
18:43:42 <allbery_b> how does your work windows pc's memory and processor compare to the macbook?
18:43:56 <orbitz> allbery_b: very comperable
18:44:04 <sandal> yea, if you have a core duo vs. a single processor
18:44:09 <sandal> it'll make a big difference
18:44:23 <orbitz> i'm dual on both
18:44:33 <sandal> hmm.
18:44:38 <orbitz> the code only hits one though doesn't it?
18:44:41 <sandal> maybe windows is being dumb about scheduling
18:44:45 <orbitz> it's not ocncurrent at all
18:44:45 <allbery_b> I would expect them to be comparable because it should be the same CPU type
18:45:11 <orbitz> the idfference is fairly streme too.  8 seconds to run on my macbook pro and abotu 33 seconds to run on my widnwos pc
18:45:19 <orbitz> compiling with ghc -O2
18:45:32 <sandal> yeah, but the scheduling seems pretty good on OS X
18:46:05 <orbitz> hrm, perhaps but i find it har do belive eh scheudling would result in soemthing that attrocious
18:46:28 <sandal> orbitz: Not so sure, it doesn't surprise me that windows is slower than *nix at anything
18:46:40 <sandal> there are so many factors to go into that
18:46:46 <orbitz> i might expect osem slowness, but th's abotu 4x slower
18:47:01 <orbitz> it's a 100 line program taht ismply solve a sudoku board, not quite rocket science
18:47:03 <jdroid-> orbitz: matching the speeds you wanted on your home comp?
18:47:09 <sandal> Of course, i'm not sure at all how well windows builds are maintained for ghc
18:47:10 <orbitz> yes
18:47:13 <bfulgham_> Does lambdabot include its own copy of Djinn?
18:47:18 <orbitz> perhaps i'll try hugs
18:48:02 <Excedrin> hugs will be slower
18:48:07 <allbery_b> I'd be pretty surprised if hugs mproved it since it's interpreted vs. compiled
18:48:07 <orbitz> drats
18:48:25 <Excedrin> orbitz: you compiled with -O2 on both platforms? what versions of ghc?
18:48:33 <orbitz> 6.6
18:48:46 <nornagon> bfulgham_: yes
18:48:54 <orbitz> i use the .msi that is on teh ghc website for windows, and whateve ri sin darwin ports for the ma
18:49:35 <orbitz> i'm running the windows stuf from inside cygwin as well, i don't think taht should really amount to any difference though
18:49:52 <allbery_b> in any case, you don't generate code for an OS, you generate it for a processor.  the libraries that interface to system services will differ, but hopefully you're only dong that for I/O
18:50:18 <Excedrin> orbitz: cygwin shouldn't matter, it sounds like a bug
18:50:18 <orbitz> allbery_b: my program is almost entirley CPU bound
18:50:19 <nornagon> allbery_b: um, x86 asm isn't portable linux->windows
18:50:21 <jdroid-> orbitz: how does it put the puzzles in memory? all in memory, then solve?
18:50:25 <nornagon> different OS interrupts.
18:50:31 <orbitz> yes
18:50:41 <Excedrin> orbitz: is your code available?
18:50:44 <allbery_b> nornagon: that's interfacing to system services, though
18:50:46 <orbitz> Excedrin: yup, one sec
18:51:01 <orbitz> haskell pastebin?
18:51:12 <int-e> @paste
18:51:13 <sorear-lambdabot> http://paste.lisp.org/new/haskell
18:51:14 <allbery_b> pure code shouldn't be using such interrupts, and I'd expect the generated code to invoke a support library for those instead of generating inline OS calls
18:51:16 <orbitz> thanks
18:51:28 <jdroid-> interesting you say 4x speed diff. when i'd compile things in windows vs. linux, i'd see roughly a factor of 4x diff which i blamed mainly on the filesystem because cleaning the dirs took roughly 4x as long on windows
18:51:31 <nornagon> allbery_b: right. :)
18:51:41 <allbery_b> (iespecially since, at lest on unix,many "system calls" are really librry wrappers for possibly complex interfaces)
18:51:44 <lisppaste2> orbitz pasted "sudoku solver" at http://paste.lisp.org/display/34702
18:51:48 <jdroid-> perhaps time it after io..?
18:51:55 <orbitz> it isn't prety code
18:52:19 <orbitz> jdroid-: the IO part takes a almos tno tiem at all
18:52:29 <orbitz> on both systems
18:55:06 <Excedrin> 9 seconds on my linux box
18:55:27 <chessguy> hi haskellers
18:56:17 <sorear> hi!
18:56:28 <chessguy> i saw (essentially) a lambda function in a surprising place today
18:56:58 <chessguy> in a perl script
18:57:11 <sorear> yeah, since v5 perl's had them
18:57:23 <sorear> my $func = sub { print "impure!!!" };
18:57:42 <chessguy> this was an anonymous sub actually
18:58:09 <sorear> all subs are anonymous
18:58:20 <jcreigh> chessguy: perl has map and filter (I think filter is spelled "grep")
18:58:25 <Excedrin> .... unless they're named
18:58:28 <chessguy> lol
18:58:31 <sorear> sub foo { } iirc is sugar for &foo =  sub { }
18:58:48 <SamB> sorear: so LISP functions -- are they anonymous too?
18:58:53 <SamB> or is that only scheme?
18:59:06 <chessguy> it was kinda cool to see something so weird and go 'oh, i know what that is', and continue merrily on my way
18:59:20 <orbitz> Excedrin: do you have a windows macein to test it on?
18:59:21 * sorear hasn't used perl in months ...
18:59:30 <allbery_b> *::foo = sub { ...} actually
18:59:36 <orbitz> Excedrin: actually i need ot give you teh input file don't I?
19:00:29 <chessguy> i'm using it hardcore now for the first time ever, really. it has some bite to it. a very different feeling from haskell, but it has a lot of usefulness, too
19:01:48 <jcreigh> chessguy: have it looked at Ruby at all? It has almost everything you want from Perl, minus a lot of the insanity. (List context, scalar context, weak typing, oh my!)
19:02:09 <jdroid-> if you're going to leave perl for another lang, might as well go to python
19:02:12 <chessguy> i'd be curious to see if haskell has anything like some of perl's HTML and WWW modules
19:02:13 * araujo has been tempted to look at ruby lately
19:02:28 * allbery_b likes ruby but is still somewhat weak in it
19:02:29 <araujo> Though ive found many haskeller choose python as the scripting language
19:02:35 <chessguy> ruby's a FP language, right?
19:02:44 <orbitz> no
19:02:44 * allbery_b has been doing perl for 10+ years though
19:02:45 <SamB> ???
19:02:45 <araujo> chessguy, OOP
19:02:46 <jcreigh> chessguy: kind of, not really. More like Smalltalk for dummies.
19:02:48 <Excedrin> orbitz: I have some test sudokus, I'll have to test windows later
19:02:53 <SamB> ruby is a ugly language!
19:02:57 <sorear> I do my scripting mostly in Haskell these days.
19:03:00 <orbitz> Excedrin: ok, let me know if you get anywher eplease
19:03:04 <SamB> it is like, uh, Smalltalk for Perl users
19:03:05 <allbery_b> ruby's kinda like the good parts of perl crossbred with smalltalk's OO system
19:03:06 <araujo> jcreigh, ST for dummies, hah, that's a good one
19:03:19 <jdroid-> SamB: that's a good analogy
19:03:25 <sorear> dons++ bos_++ Data.ByteString rocks!!
19:03:28 <Excedrin> chessguy: no
19:03:33 <Excedrin> SamB: jcreigh already said that
19:03:51 <jdroid-> ruby is interesting, but a lot of the things people say are great aren't actually useful in practice
19:03:55 <chessguy> orbitz: what are you working on?
19:03:58 <SamB> Excedrin: perl users != dummies
19:03:58 <araujo> SamB, that's kind of true ... though it is kind of a coincidence.
19:04:08 <jdroid-> i've had a hard time finding people using blocks in their code, but people tote it as though it's groundbreaking
19:04:17 <SamB> I meant, the syntax has so many sharp things in it
19:04:27 <araujo> Ruby was intended to be the ST for Unix.
19:04:29 <chessguy> i'm very impressed with some of perl's web-interactive modules
19:04:40 <chessguy> haskell would do well to take note
19:04:42 <orbitz> chessguy: figuring out why this ghc generated executabel runs helal slower on windows
19:04:44 <araujo> Or a Unixish ST , as i like to refer to
19:04:48 * allbery_b thinks many ruby users don't really "get" blocks
19:04:53 <Excedrin> SamB: I use Perl... how do you explain that?
19:04:57 <allbery_b> neat idea but they don't realy know how to use it
19:05:00 <jdroid-> araujo: i'm not sure that's accurate... i think it takes things from ST, but was intended to also be a fully object oriented scripting language in reaction to python not being full oo
19:05:06 <chessguy> orbitz: oh, i thought you were specifically playing with sudoku's
19:05:08 <SamB> Excedrin: you might be both a perl user and a dummy
19:05:15 <SamB> then again maybe you aren't a dummy
19:05:18 <chessguy> or whatever the heck the plural of that word is
19:05:29 <orbitz> chessguy: well the little problem that made me see this was a sudoku sover i wrote in haskell
19:05:35 <araujo> sorear, i hope Haskell can get better for scripting task. I have also tried to use it sometimes.
19:05:43 <Excedrin> chessguy: have you found perl -MCPAN -e shell, and http://search.cpan.org and such?
19:05:44 <sorear-lambdabot> Title: The CPAN Search Site - search.cpan.org
19:05:50 <chessguy> orbitz: aha. you should add it to the collection on the wiki
19:06:11 <chessguy> Excedrin: i know search.cpan well. not sure what the other is
19:06:13 <jdroid-> Excedrin: my main issue with perl is that it's too free with the syntax. i know a guy who writes it the perl way. another guy who writes it like c. people can write it like lisp. far too flexible
19:06:36 <Excedrin> SamB: all I know is, I like Perl and trying to learn Haskell makes me feel stupid. At the same time, I have a revulsion to Perl and the direction that Perl6 seems to be going seems insane to me
19:06:48 <sorear> arajuo: haskell is very good for what I've used it for so far - try writing 'interact $ unlines . concatMap tails . lines' in 1 line of non-obfuscated perl
19:06:55 <araujo> jdroid-, That's so accurate as your opinion. Because he tried to get a language that fit good into the unix model too. That's where the perlish taste comes from
19:07:02 <orbitz> chessguy: yes, i need to make it less like a pythong programmer trying to fumble his way thoruhg haskell though:)
19:07:11 <SamB> Excedrin: yeah.
19:07:16 <allbery_b> perl -MCPAN -e shell (aka the "cpan" command in 5.8) lets you search for and install perl modules from the command line
19:07:21 <SamB> I only hang out in #perl6 because I know haskell.
19:07:22 <allbery_b> hackage wants to go that direction
19:07:34 <orbitz> perl 6 isn't going to be strict is that true?
19:07:37 <chessguy> haskell and perl are both very cool, with very different strengths
19:07:55 <SamB> what, pray tell, *is* perls strength?
19:07:57 <allbery_b> orbitz: perl6 has some strictness and some laziness, as I understand it
19:08:06 <chessguy> allbery_b: seems pretty redundant, if you have access to cpan directly
19:08:07 <allbery_b> string manipulation and pattern matching
19:08:14 <SamB> allbery_b: it is?
19:08:49 <araujo> sorear, Not good for what ive tried to use it. shell scripting tasks.
19:08:54 <glguy> I thought that the strength was that it was unreadable
19:08:57 <Excedrin> Perl's strength is quickly hacking out a 30% solution, then moving on and returning later when you need some part of the remaining 70%
19:08:59 <araujo> sorear, that's why ive tried to get some haskell-shell projects going on
19:09:05 <allbery_b> what would you claim?  perl does best in things which reduce to string manipulation and pattern matching, less well in things like math and complex structures
19:09:19 <SamB> hmm.
19:09:24 <jdroid-> Excedrin: that can be done in python or ruby also
19:09:25 <glguy> and that you can't write maintainable code, so it encourages prototyping / throwaway code
19:09:27 <orbitz> i tend to use python for anything i consider less than a serious applicaiton
19:09:40 <araujo> Excedrin, And 3 months later, you forget the 80% of it :-P
19:09:42 <SamB> glguy: heh
19:09:48 <allbery_b> bah.  you can write maintainable code, too many people simply don't
19:09:56 <falconair> can ByteSring be used to process arbitrary binary files or is it best used with string (as in text)?  Does it make sense to process files that are huge, gigabytes, perhaps 100s of gigs (say, for something like Google's MapReduce)?
19:09:57 <allbery_b> just like you can write ecure PHP code, but...
19:10:05 <allbery_b> *secure
19:10:06 <SamB> is the Evil Mangler maintainable?
19:10:29 <jdroid-> araujo: true story. either 80% of it or you have to read someone elses perl and it makes no sense at all because of code like while(<>) { ... $_ ... }
19:10:34 * allbery_b recommends "Perl Best Practices" for serious perl programming
19:10:41 <glguy> some of PHP security issues can't be "worked around"
19:10:52 <glguy> like how it leaves all of apache's file handles open when you run a systeom command
19:10:59 <araujo> jdroid-, yes, reading somebody else code on perl is a torture :-P
19:11:00 <jdroid-> allbery_b: while you ahve a good point that you *can* write good code, the weakness in the language is that you also can write bad code
19:11:02 <orbitz> glguy: yummy!!!
19:11:06 <Excedrin> araujo: yes, after forgetting, you rewrite it, since there's no point in attempting to read what you wrote
19:11:09 * araujo tried years ago ... when he used to play with perl
19:11:16 <araujo> Excedrin, hah
19:11:25 <sandal> you can write bad code in any language jdroid-
19:11:27 <araujo> Excedrin, you come up with other hack :-)
19:11:29 <allbery_b> enh.  "You can write FORTRAN in any language" (and trust me, I've seen it in many languages)
19:11:39 <jdroid-> sandal: it's harder in other languages. python for example
19:11:54 <glguy> PHP lets you write hacks that take over port 80 without killing apache
19:11:54 <sandal> jdroid-: true enough, but it's still possible.
19:11:58 <sorear> falconair: That one-liner used Data.ByteString.Lazy and processed 10 Gbytes of IRC logs in ~40sec
19:12:15 <sandal> I think something like Ruby though, it benefits from its expressiveness
19:12:26 <sandal> much perl hackery unfortunately suffers
19:12:44 <sandal> People mistake TMTOWTDI with "Do it however the hell you want"
19:12:52 <falconair> sorear: wow! (which one-liner?)
19:12:58 <allbery_b> it's widely acknowledged that "petry mode" was a cute hack, but a mistake in terms of the language
19:13:04 <SamB> sorear: what kind of massive disk/RAM array did you need to get it to do that?
19:13:05 <Excedrin> http://www.underlevel.net/jordan/erik-perl.txt
19:13:07 <allbery_b> *poetry mode
19:13:32 <chessguy> FORTRAN (english), FORTRANo (spanish), je FOTRAN (french), der FORTRANISCH (german), etc.
19:13:33 <jdroid-> sandal: what do you consider ruby's expressiveness that other languages can't match?
19:13:47 <sandal> Reopening classes.
19:14:06 <jdroid-> yeah, that's a neat trick for sure.
19:14:33 <sandal> and i'd say metaprogramming, dynamicity, and reflection are easier in ruby than in many languages
19:14:36 <sorear> SamB: 10GB *out*, 200MB in.  384MB ram, a single 100Mby/s disk, which performs remarkably well on uninterrupted contiguous writes.
19:14:44 <allbery_b> not tat rubyites know how to use them, but blocks give you a form of lazy evaluation
19:14:46 <SamB> sorear: ... oh.
19:14:47 <jdroid-> metaprogramming? i don't think it's any better than python in that regard
19:14:51 <sandal> But i mean, something like smalltalk obviously is as poweful there.
19:14:58 <newsham> ?let ook = "its superman!
19:14:58 <sorear-lambdabot>  Improperly terminated string
19:15:03 <newsham> ?let ook = "its superman!"
19:15:04 <Excedrin> sandal: is that like "reopening" a structure in SML?
19:15:04 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
19:15:04 <araujo> allbery_b, that's ST
19:15:13 <sandal> Excedrin: not worked with SML
19:15:15 <newsham> > L.ook "its a bird, it's a plane!"
19:15:16 <sorear> newsham: nice try
19:15:34 <sorear> newsham: I don't have a working runplugs
19:15:35 <sandal> but you can do.  Class Integer; def +(other); 42; end; end
19:15:49 <SamB> > let look = "its superman!"
19:15:49 <sorear-lambdabot>  Parse error
19:15:53 <SamB> @let look = "its superman!"
19:15:53 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
19:16:16 <sandal> wait... maybe fixnum :)
19:16:20 <newsham> sorear: write a silc module yet? ;-)
19:16:26 <sorear> no
19:16:30 <sandal> >> class Fixnum; def +(other); 42; end; end
19:16:30 <sandal> => nil
19:16:30 <sandal> >> 1 + 2
19:16:30 <sandal> => 42
19:16:36 <sorear> ?list irc
19:16:37 <sorear-lambdabot> irc has no visible commands
19:16:40 <sorear> ?list IRC
19:16:40 <sorear-lambdabot> No module "IRC" loaded
19:16:44 <allbery_b> smalltalk has several stigmas attached to it; you can think of ruby as bringing smalltalk concepts where they would otherwise not be seen
19:16:47 <sandal> Obviously that's an aweful us
19:16:48 <sorear> ?list offlinerc
19:16:48 <sorear-lambdabot> offlinerc has no visible commands
19:16:57 <sorear> funny...
19:17:00 <Excedrin> sandal: ok, it's almost exactly the same then
19:17:09 <sorear> does list not list privileged commands?
19:17:18 <sorear> ?help irc-connect
19:17:19 <sorear-lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
19:17:23 <sandal> jdroid-: Python lacks what ruby has in that not everything is an object
19:17:32 <sandal> jdroid-: (for metaprogramming)
19:17:45 <SamB> sandal: of course everything is an object
19:17:48 <newsham> what's not an object?
19:17:50 <SamB> but not every type is a class
19:18:02 <e_e_coli> I'm following "YAHT"; the hSetBuffering function is rejected by GHC as "not in scope". Do I need to import something?
19:18:03 <sandal> jdroid-: i think the two are functionally equivalent, but having unbound methods, anonymous code blocks, etc
19:18:06 <sorear> everything in Haskell is an object too!
19:18:17 <newsham> >>> (1).__add__(2)
19:18:17 <allbery_b> System.IO I think
19:18:19 <sorear> e_e_coli: System.IO
19:18:19 <newsham> 3
19:18:20 <SamB> and worse, there are three or four kinds of classes, only two of which are distinguished by type!
19:18:23 <e_e_coli> thanks
19:18:32 <sandal> SamB: Type has a very different meaning in ruby
19:18:34 <jdroid-> i've had a hard time finding ways in which funcitonally they are different so i've resorted to things that i like about how i can express ideas
19:18:42 <e_e_coli> (you'd think the tutorial would mention this)
19:18:48 <jdroid-> while the open classes example is good, i like the generators in python quite a bit
19:19:02 <sandal> jdroid-: Yes, they're cool
19:19:03 <newsham> i wish generators were more general :(
19:19:07 <sandal> jdroid-: and list comprehensions
19:19:13 * araujo has been onto pure languages during the last few years.
19:19:14 <sorear> I wish everything was a generator
19:19:21 <allbery_b> mmm, Icon
19:19:24 <jdroid-> sandal: for sure. you can use select and map to get similar functionality, but it's not as elegant imho
19:19:24 <sandal> jdroid-: but Ruby's Enumerable+Enumerator+Generator surely are at least as good :)
19:19:26 <newsham> you cant write a generator which spans multiple functions (or calls itself recursively)
19:19:32 <araujo> Ive found them easier and more beauty
19:19:45 <sandal> newsham: you sure can
19:19:49 <sandal> newsham: via Enumerator
19:19:51 <chessguy> so, has haskell managed any modules like perl's web stuff?
19:19:57 <newsham> sandal: explain?
19:20:13 <chessguy> WWW::*, HTML::*, etc.
19:20:19 <sandal> you're looking for map_with_index
19:20:24 <sandal> or something like that, right?
19:20:25 <sorear> chessguy: define "like".  we've got http modules.
19:20:43 <allbery_b> generators spanning functions:  Proc?
19:20:53 <allbery_b> (used with generators)
19:20:55 <chessguy> anything analagous to HTML::TreeBuilder?
19:21:08 <newsham> no, def gen1() : for x in "abc" : yield x; gen2(); gen3();
19:21:16 <newsham> where gen2() and gen3() yield things themselves.
19:21:26 <sorear> that's easy in Haskell
19:21:37 <newsham> yes, super easy in haskell but not possible in python
19:21:44 <sandal> Oh... yeah, I see what you mean, multiple blocks
19:21:50 <allbery_b> oh, you're talking about python, not ruby
19:21:58 <sandal> no, ruby
19:22:04 <newsham> i'm talking python.
19:22:12 <sandal> ah. Okay
19:22:14 <chessguy> is anybody talking haskell? lol
19:22:24 * sorear *really* ought to be doing his homework, take care of the bot
19:22:28 <sandal> yeah, you're right newsham, that's something you can't do in Python, afaik
19:22:29 <allbery_b> heh
19:22:45 <newsham> so for example, the typical way you write cartesian product generator is with recursion, but you cant do that directly in python, instead you have to recursively nest generators (and have 1 generator for each recursion level)
19:22:46 <sandal> with Ruby, you can do it, but you'd need to do some hackery with procks
19:22:48 <sandal> *procs
19:23:19 <newsham> another thing I dont like is the assymetry between the caller of the generator and the callee (the generator itself)
19:23:21 <sandal> gen2() and gen3() could return procs
19:23:32 <newsham> one "yields" values and the other "next()"s values
19:23:33 <sandal> (in ruby)
19:23:57 <sandal> anyway, I'm going back to my haskell tutorial :)
19:23:58 <sandal> biab
19:24:20 <newsham> ruby people love badmouthing python, btw.
19:24:22 <nornagon> lambdabot should have a ?refactor
19:24:27 <nornagon> so you give it some code
19:24:28 <newsham> clearly proving that python is superior ;-)
19:24:33 <sandal> newsham: that's a misconception
19:24:34 <nornagon> and it turns it into a one-liner that does the same thing
19:24:50 <nornagon> but the one-liner is much shorter
19:24:58 <newsham> ?pl (\x y -> x * 2 + 3 * y + 5)
19:24:58 <sorear-lambdabot> flip flip 5 . ((+) .) . (. (3 *)) . (+) . (2 *)
19:24:59 <sandal> People who are not really into ruby but think Rails is the coolest thing since sliced bread like bashing Python
19:25:02 <nornagon> and more easily understood
19:25:04 <allbery_b> 'sokay, the core pythoners badmouth everything, proving python is worse than everything else :}
19:25:14 <sandal> And even there, it's a minority
19:25:18 <newsham> sandal: nah, i know some hardcore ruby people, they bash python.
19:25:18 <jdroid-> sandal: django is pretty neat too
19:25:20 <allbery_b> (not serious! although GvR makes me wonder sometimes)
19:25:28 <sandal> newsham: who?
19:25:34 <sandal> jdroid-: yeah, it definitely looks cool
19:25:41 <sandal> they have an awesome idea with their book
19:25:42 <jdroid-> sandal: different goals, but really neat
19:25:48 <sandal> that's how documentation should be done
19:25:50 <nornagon> sandal: Guido van Rossum
19:26:00 <newsham> sandal: here for example: http://www.matasano.com/log/421/python-is-the-lingua-franca-of-over-the-hill-hackers/
19:26:01 <sorear-lambdabot> Title: Matasano Chargen  Python is the &#8220;lingua-franca&#8221; of over-the-hill ha ..., http://tinyurl.com/y3occx
19:26:06 <newsham> (ie. dino + tqbf)
19:26:17 * allbery_b thinks someone got confused there
19:26:35 <allbery_b> GvR would not be a core rubyite badmouthing python...
19:26:47 <Excedrin> SML structure example: structure String = struct open String; val reverse = implode o rev o explode; end;
19:26:50 <sandal> newsham: I have to be honest
19:26:57 <sandal> I don't know any of these names
19:27:15 <sandal> and I've been to two RubyConfs, and represented RubyCentral in two different grants
19:27:19 <newsham> sandal: computer security community.
19:27:33 <sandal> alright, but those aren't core ruby community folks
19:27:49 <sandal> This is solidifying my point that the hype exists on the fringe.
19:28:18 <sandal> But this is a rant for another room.
19:28:20 <sandal> :)
19:28:55 <sandal> but for those interested, here's my stance from over a year ago, which has not changed
19:28:58 <sandal> http://www.oreillynet.com/ruby/blog/2005/12/ruby_is_not_a_religion.html
19:29:00 <sorear-lambdabot> Title: Ruby is NOT a Religion. - O&#039;Reilly Ruby, http://tinyurl.com/yay8t3
19:29:58 <sandal> newsham: it's unfortunate that some folks give that impression though.
19:30:50 <sandal> newsham: I think there are a lot of wonderful Ruby programmers with a little more maturity than that.
19:31:00 <sandal> newsham: many Rubyists are also haskell hackers :)
19:31:13 <manveru> :D
19:31:23 <allbery_b> there are folks who think X is a religion, for any language X.
19:31:30 <sandal> allbery_b: very good point
19:31:39 * manveru learns new languages as much as he can
19:31:40 <sandal> I think Erlang will become my religion
19:31:56 <allbery_b> unfortunately they're tusually the most visible "representatives" of their languages
19:32:31 <jdroid-> erlang was orbitz's religion for a while. i think he's looking for his next one.. :)
19:32:35 <sandal> Hopefully, the Haskell community will be able to ride out it's obscurity a little longer
19:32:47 <newsham> obscurity has its perks
19:32:49 * allbery_b considers languages to be tools, and tries to use the appropriate tool for any given job.
19:32:54 * Cale prays to lord Haskell Brooks Curry, hallowed be his name.
19:33:08 <sandal> Seriously, the Rails surge has done a lot for the legitamacy of my contracting work
19:33:08 <newsham> cale finds religeon
19:33:11 <manveru> Cale: i like indian food... does that count?
19:33:18 <sandal> I don't do rails, but people know what ruby is because of it
19:33:30 <Cale> Haha, not bloody likely :)
19:33:33 <jdroid-> sandal: it seems to me that haskell requires people to be smart enough that i think that quality will help kick off many of the extremists
19:33:35 <sandal> I do need to usually explain to them I don't necessarily need to build a web app or use a database, though :)
19:33:46 <Cale> manveru: hehe
19:33:48 <sandal> jdroid-: We used to think that in Ruby too
19:33:59 <manveru> yeah
19:34:06 <manveru> ruby was a peaceful land a year ago
19:34:07 <sandal> Once you folks have Haskell on Rails knocking at your door. (Or some other killer app)
19:34:15 <jdroid-> sandal: hmm... really? haskell requires knowledge of laziness, currying and other things that ruby doesn't seem to require
19:34:19 <sandal> You'll be in the same shoes
19:34:23 <mbishop> darcs isn't killer enough?
19:34:32 * manveru <3 darcs
19:34:37 <newsham> databases are awesome.  save yourself a few hours not having to design your own datastore in exchange they pay some guy to maintain a database for life.
19:34:41 <manveru> but you don't code in darcs...
19:34:50 <Cale> Learning Haskell makes people smarter :)
19:34:51 <allbery_b> given a sufficiently canned framework you could probably do "Haskell" in that framework without actually understanding it
19:35:02 <sandal> allbery_b: that's exactly my point
19:35:08 <sandal> so many folks think Ruby is Rails
19:35:18 <sandal> and wonder why 3.days doesn't work
19:35:23 <allbery_b> sandal: I know
19:35:24 <newsham> mbishop: darcs isnt that high visibility.  there are so many version management tools to choose from.
19:35:43 <araujo> Cale, or at least, we can presume so ;-)
19:35:49 <sandal> right, I'm not criticizing Haskell at all :)
19:35:53 <sandal> darcs is super nifty
19:35:59 <newsham> cale: or maybe it just seems like it since all the dumb people give up?
19:36:08 <chessguy> can haXml be used to build represent haskell programs as XML documents?
19:36:11 <sandal> I'm saying, wait until you get a framework that invites 'novice programmers' to your door
19:36:29 <newsham> chess: <prog>...haskell code here...</prog>
19:36:29 <sandal> Nothing bad in and of itself, but it sure does shake the community
19:36:34 <mbishop> jahova programmers?
19:36:49 <chessguy> newsham: mmm, not exactly what i had in mind
19:36:50 <Cale> newsham: well, that too, but I suspect that effect is a bit smaller for the time being.
19:36:51 <sandal> let me put it this way, 1.5 years ago, I couldn't find a single ruby book in Barnes in Nobles
19:36:59 <sandal> now there is a shelf there full of them
19:37:05 <glguy> Cale: I worked out that function desugared: getUserState >>> (((+1) ^>>> setUserState) &&& ((\s -> (f s,undefined)) ^>> app)) >>^ snd
19:37:14 <sandal> I'm lucky enough where I still know and have met most of the authors of those books
19:37:17 <Cale> glguy: cool
19:37:19 <sandal> Or at least know who they are
19:37:27 <sandal> but soon enough, i won't know any of them
19:37:33 <sandal> that makes me a little sad.
19:37:37 * manveru nods
19:37:42 <mbishop> a language doesn't always have to get popular...look at lisp :)
19:37:51 <manveru> hehe
19:37:51 <sandal> Lispers are lucky :)
19:38:04 <manveru> it's got the look
19:38:21 <sandal> But seriously though, I hack camping, ruport, and other random things all day and can get paid for it.  I don't need to touch rails
19:38:43 <sandal> the downside is again, getting lumped in with a community that appeared out of nowhere and is disconnected from the core
19:38:51 <sandal> I guess change is inevitable
19:39:06 <sandal> I'm actually excited to learn Haskell because it's still safe over here :)
19:39:15 <newsham> i wish xml would just go away :(
19:39:22 <manveru> :)
19:39:24 <allbery_b> the core Perl community felt that way when perl hit it big for web stuff
19:39:34 <jdroid-> i think part of ruby gaining attention as a scripting lang now is because it's not too different from languages people are used to like c, java or perl and still provides some new ideas like blocks and everything being an object (compared to popular langs)
19:39:37 <sandal> Yeah, I rode in after that hit in perl
19:39:44 <nornagon> ?quote type system
19:39:44 <sorear-lambdabot> No quotes for this person. That's something I cannot allow to happen.
19:39:51 <nornagon> ?quote "type system"
19:39:51 <sorear-lambdabot> No quotes for this person. I've seen penguins that can type better than that.
19:39:55 * allbery_b started with perl before the web stuff hit
19:40:00 <nornagon> ?quote * type system
19:40:00 <sorear-lambdabot> No quotes for this person. Your mind just hasn't been the same since the electro-shock, has it?
19:40:06 <allbery_b> ?quote type.system
19:40:06 <sorear-lambdabot> dons says: Java's type system is unsuitable for young children, the elderly or infirm of constitution
19:40:10 <nornagon> ?quote .* type system
19:40:10 <sorear-lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
19:40:10 <sandal> which is maybe why I never got deep into perl community
19:40:20 <nornagon> ouch.
19:40:26 <newsham> mmm broccoli
19:40:38 <sandal> jdroid-: it's not different on the surface
19:40:49 <sandal> I totally agree with that
19:40:50 <allbery_b> if there's a space it parses as user then pattern.  use . instead of space for multiword patterns
19:40:56 <sandal> advanced ruby is unique
19:41:18 <nornagon> @quote
19:41:19 <sorear-lambdabot> ihope says: Laziness is free, but it doesn't always pay off.
19:41:26 <sandal> maybe smalltalk compares, but I think it's going to be surprising to folks in other languages, even with equivalent functionality
19:41:40 <sandal> but for basic scripting
19:41:46 <jdroid-> rails came at a convenient time because people are finally realizing php is just a mess and were looking for other ways to do web pages while still avoiding java
19:41:56 <sandal> sure, we've stolen every cool library we can from C,Python,andPerl
19:41:59 <allbery_b> smalltalk has the stigmas of being considered slow and requiring a special environment to use
19:42:12 * manveru hugs GST
19:42:15 <sandal> and Ruby just sneaks in with Java via JRuby
19:42:16 <allbery_b> (never mind the truth, this is what most people think when they hear about it)
19:42:30 <manveru> well
19:42:34 <sandal> (Which i think is also true about python via Jython)
19:42:35 <newsham> ?seen alexj__
19:42:36 <sorear-lambdabot> alexj__ is in #haskell. I don't know when alexj__ last spoke.
19:42:44 <jdroid-> jython is basically dead.
19:42:50 <manveru> most people think of haskell as impossible to learn or understand...
19:43:06 <sandal> allbery_b: yeah, I think the latter is a setback, the Smalltalk environment
19:43:16 <manveru> when i first saw a snippet i thought WTF, this is a program?
19:43:19 <jdroid-> i think jruby is a neat idea, but it's got a ways to go. ruby itself seems well suited to interact with java.
19:43:25 <sandal> but probably not nearly as big a deal, infact, it has a lot of benefits
19:43:29 * allbery_b points to squeak as a counterexample of both
19:43:31 <chessguy> manveru: or as simply an academic language
19:43:37 <sandal> jdroid-: it's really moved fast lately
19:43:39 <newsham> manveru: thats what "two dozen short lessons" is for.
19:43:48 <sandal> Its almost compatible with 1.8 at this point
19:43:51 <manveru> newsham: i'm just reading it :)
19:43:54 <chessguy> @go two dozen short lessons
19:43:55 <sandal> doesn't hurt sun picked up the devs
19:43:56 <sorear-lambdabot> http://www.cs.ou.edu/cs1323h/textbook/haskell.shtml
19:43:56 <sorear-lambdabot> Title: Two Dozen Short Lessons in Haskell
19:44:07 <manveru> oh, there is a html-version?
19:44:12 <chessguy> hmm, i haven't seen that one yet
19:44:20 <sandal> Yes, Haskell does have the scariness factor still working for it
19:44:40 <manveru> i only gave it a try cause some ruby-guys didn't stop talking about it :)
19:44:44 <sandal> but as soon as someone goes and sticks a "y0u c4n pr0gr4m t00" framework on top of it, look it out
19:44:48 <sandal> *look out
19:44:48 <newsham> chessguy: your mom or your gf could understand it.
19:44:55 <sandal> manveru: same here
19:45:04 <sandal> I am a regular reader of anarchaia
19:45:09 <sandal> and I read all the Haskell articles
19:45:13 <manveru> sandal: exactly :)
19:45:22 <sandal> and I'm like, why am i reading these if I can't code in it
19:45:25 <chessguy> newsham: i'll be sure to recommend it to them
19:45:41 <sandal> found some free time, and decided, chris2 is a pretty smart dude, maybe there's something to look at here :)
19:46:04 <sandal> I'm having fun.  I'll post my unit tests for YAHT as i work through the exercises
19:46:25 * manveru tinkers on the irc-bot
19:46:33 <sandal> I also love math, so Haskell seems interesting in that regard
19:46:41 <newsham> > 1 + 2
19:46:55 <manveru> :P
19:46:59 <jdroid-> orbitz: mind sharing your experience with jruby at work?
19:47:07 <chessguy> where's the real lambdabot ?
19:47:16 <newsham> ?seen lambdabot
19:47:16 <sorear-lambdabot> lambdabot is in #haskell. I don't know when lambdabot last spoke.
19:47:59 <allbery_b> lambdabot lost its brain during a netsplit a couple hours ago
19:48:06 <chessguy> aha
19:48:21 <chessguy> and dons is off gallivanting about
19:48:55 <orbitz> sure
19:49:25 <orbitz> jruby experience wasn't particualy interesting, for th emost part it was slow  and it seems to use .equals in palce of == on some java code it was executing so it oculdn't competlely run some java code i wnated it to
19:49:29 <orbitz> tha's where i've left it at os far
19:50:24 <manveru> man, i love how smart the parser is :)
19:50:37 <manveru> ghc, that is
19:51:27 <newsham> ?elite i've gone crazy
19:51:27 <sorear-lambdabot> I'\/e gone CraZY
19:52:09 <Cale> If you want a neat language for interfacing with Java stuff, Scala seems pretty good at that. I haven't used it, but the language looks reasonably nice, and has some pretty cool features.
19:52:23 <chessguy> ?elite.vixen i've gone crazy
19:52:23 <sorear-lambdabot> Unknown command, try @list
19:52:47 <allbery_b> ?. elite vixen i've gone crazy
19:52:48 <sorear-lambdabot> HOW
19:52:57 <chessguy> lol
19:53:11 <Cale> ?. elite vixen asl
19:53:12 <sorear-lambdabot> 19/ph/c4|iphORnIa
19:53:26 <Cale> heh
19:53:28 <chessguy> lol
19:53:38 <chessguy> she's a phemale
19:54:19 <chessguy> ?. vixen elite asl
19:54:19 <sorear-lambdabot> Do you think you would pass a Turing test?  I have.
19:54:38 <nornagon> ?elite asl
19:54:38 <sorear-lambdabot> aSl
19:54:45 <nornagon> ?vixen aSl
19:54:45 <sorear-lambdabot> :)
19:54:57 <chessguy> weirdness
19:55:11 <jcreigh> I've failed Turing tests, multiple times. ("Enter the text that appears in the picture below...")
19:55:18 <allbery_b> heh
19:55:19 <sandal> How do i write this so it'll parse?
19:55:22 <sandal> ex35 = TestCase( assertEqual "Exercise 3.5",
19:55:22 <sandal>                     10, foldl max 0 [5,10,2,8,1] )
19:55:33 <sandal> oh wait
19:55:36 <sandal> i think i have it
19:55:38 <chessguy> ?remember jcreigh I've failed Turing tests, multiple times. ("Enter the text that appears in the picture below...")
19:55:38 <sorear-lambdabot> Not enough privileges
19:55:44 <chessguy> bah
19:55:47 <nornagon> :(
19:56:04 <sandal> rats, nope
19:56:07 <manveru> they say, you can write fortran in every language... somehow i doubt that for haskell :P
19:56:08 <sandal> had to remove that commo
19:56:12 <sandal> *comma
19:56:18 <e_e_coli> Hello. Idiom to loop through a list for IO side effects?
19:56:24 <sandal> got it
19:56:26 <e_e_coli> as in, print each of a list
19:56:32 <manveru> iterate?
19:56:36 <sandal> ex35 = TestCase( assertEqual "Exercise 3.5"
19:56:36 <sandal>                     10 (foldl max 0 [5,10,2,8,1]) )
19:56:41 <chessguy> e_e_coli: Hello. Complete sentence?
19:56:42 <sandal> that parses fine
19:56:43 <allbery_b> mapM print ?
19:57:05 <allbery_b> rather mapM_
19:57:13 <sandal> whohoo, and passes!
19:57:24 <e_e_coli> chessguy: Being efficient. Time only for brief clauses.
19:57:36 <sandal> man, I'm glad I learned inject
19:57:44 <chessguy> sandal: looks more like lisp than haskell
19:57:45 <sandal> otherwise these folds would be confusing
19:57:46 <allbery_b> yeh, well, don't be surprised if in yoda-speak people reply
19:58:09 <sandal> chessguy: I'm just solving problems in YAHT
19:58:19 <sandal> this is my first time ever writing any haskell code
19:58:28 <sandal> but if you have an improvement, I'd like to see it
19:58:29 <Saulzar> e_e_coli: mapM, sequence
19:58:48 <chessguy> are you using HUnit?
19:58:57 <sandal> chessguy: yes
19:59:08 <chessguy> ah, i haven't played with that
19:59:19 <sandal> Yeah, the syntax is grinding on me
19:59:34 <sandal> I tried really quicky to turn that mess into an assert_equal function
19:59:42 <sandal> but got hung up and decided to go back to it later
19:59:47 <chessguy> seems a little silly for such simple exercises
19:59:55 <sandal> what do you mean?
19:59:57 <sandal> the testing?
20:00:04 <chessguy> using HUnit, yes
20:00:09 <sandal> I do TDD.
20:00:15 <sandal> And i've never used HUnit
20:00:21 <sandal> so I'm really just testing the waters
20:00:24 <chessguy> what's TDD?
20:00:30 <jcreigh> test driven development
20:00:31 <sandal> test driven development
20:00:45 <sandal> I.e., I generally try not to write any code without tests first
20:01:06 <sandal> so i'm more experimenting with the framework than I am with the exercises
20:01:11 <sandal> good reference too.
20:01:18 <chessguy> well, if you're so enamored with one paradigm like that that you can't get away from it for such simple exercises, something's wrong
20:01:32 <sandal> chessguy: there is no need to be rude
20:01:41 <sandal> I look at it as killing two birds with one stone
20:01:48 <sandal> I could just type these in ghci, sure
20:01:49 <chessguy> sandal: i didn't intend it to be that way, my apologies
20:01:55 <sandal> but I've never done Haskell before
20:02:04 <sandal> and I've macroed these all out in vim
20:02:08 <sandal> so it's not really any work
20:02:14 <chessguy> i'm just saying, i'm sure TDD has its uses, but surely it's not this
20:02:37 <sandal> Tests will remind me of things like, how these things parse
20:02:46 <sandal> and are better than referencing text
20:03:19 <sandal> Obviously i'm not doing it to ensure map works as expected :)
20:03:22 <chessguy> that's what i'm saying though, you're dependent on this methodology
20:03:58 <sandal> Yes, that's true.  But two things
20:04:05 <sandal> 1) it's not a bad habit to have, in general
20:04:18 <sandal> and 2) it's helping me learn the language using concepts I already know
20:04:41 <sandal> I will probably check out QuickCheck soon, but for first steps, I've very happy with this
20:05:08 <sandal> and xunit based tests will be helpful for others who do TDD in Java, C++, Ruby, Python, Perl, etc
20:05:23 <chessguy> i guess getting tied to anything and trying to use it in every situation just makes me cringe
20:05:36 <sandal> chessguy: that's unfortunate
20:05:45 <sandal> I don't really see what I'm doing as that.
20:06:02 <sandal> But if you think so, i don't mean to annoy you
20:06:21 <chessguy> nah, i don't care. was mentioning it for your sake
20:06:35 <sandal> well you haven't said anything of substance beyond your opinion
20:06:59 <sandal> I'd *love* to see an example of these rewritten in a way more natural to Haskell
20:07:05 <sandal> and I'll post them when I'm done.
20:07:18 <chessguy> i never said i was giving you any more than my opinion
20:07:41 <sandal> alright, well then I guess I just disagree with you then.  No big deal
20:07:54 <chessguy> fair enough
20:08:12 <sandal> It'd be great as a tutorial to rewrite these in QuickCheck and then use the tests to refactor anything messy into more common idioms
20:08:15 <shapr> mmm, that was a lovely sandwich
20:08:26 <chessguy> and the way you wrote that last exercise is, in fact, the canonical way of doing it
20:08:29 <sandal> and then show the whole process as an article to help people learn
20:08:36 * shapr checks the scrollback
20:08:50 <shapr> oh my, dissent!
20:08:56 <chessguy> lol
20:09:29 <sandal> i'm really learning more about things like the parsing rules and stuff
20:09:35 <sandal> than I am about the exercise
20:09:47 <sandal> these are all just ways to call functions I'm already familiar with via ruby
20:10:19 <shapr> I actually wrote a TDD extension for QuickCheck.
20:10:24 <shapr> Long years ago.
20:10:38 <shapr> I wonder if the QuickCheck2 prerelease has my ideas integrated?
20:10:50 <sandal> ooh, shapr if you can dig that up, that'd be fantastic
20:11:09 <shapr> sandal: It's just what I described before, it saves failing cases for later reteest.
20:11:34 <shapr> It was a prototype that I was hoping would persuade the authors of QuickCheck to integrate that feature.
20:11:45 <sandal> yes, i'd like to have that code handy if you have it available
20:11:45 <shapr> It was also inspired by some smart stuff that Heffalump said.
20:12:16 <shapr> http://www.scannedinavian.com/~shae/qc-tdd.tgz
20:12:16 <sandal> Heckle for ruby (think it's a port of Jester) is an interesting approach to code coverage
20:12:33 <sandal> it reorders the parsetree, and if things *don't* break, you've got trouble in your tests
20:12:42 <shapr> Smallcheck is a recent addition to the subject that used to be only HUnit & QuickCheck.
20:12:50 <shapr> Yup, that's a port of Jester.
20:13:10 <shapr> jester is a really cool idea.
20:13:11 <sandal> ty.
20:13:12 <shapr> A test tester.
20:13:26 <shapr> If that code doesn't work or doesn't compile, tell me.
20:13:30 <sandal> yep, I use heckle and rcov for coverage
20:13:46 <sandal> Rcov just tells you what is actually being run
20:13:48 <shapr> But I already know it's fragile when it comes to associating failed test values with tests. I don't know how to fix that.
20:14:04 <sandal> and then heckle helps make sure that it's ensuring the code being run is actually being tested
20:14:25 <shapr> I think Smallcheck does that, but I haven't yet used Smallcheck, only read the announcement.
20:14:40 <shapr> I think I wrote an intro to QuickCheck too...
20:14:40 <sandal> overkill for the quick hack, great for more general stuff that's more broadly used
20:14:53 <shapr> Quick hacks rarely stay that way...
20:15:23 <sandal> yes, but I'm saying, rcov + heckle are overkill for a specific job :)
20:15:55 <shapr> Yeah
20:16:04 <sandal> as long as you've got some units covering the actual expectations, and some benchmarks when relevant for performance
20:16:08 <sandal> you're good to go
20:16:28 <sandal> but the old adage is the only code you need to test is the code you want to work :)
20:16:30 <shapr> Are you into partition testing and proof by exhaustion as well?
20:16:36 <shapr> Done anything with protocol fuzzing?
20:16:42 <sandal> Fuzzing is cool stuff.
20:16:45 <shapr> Yeah, I agree.
20:16:57 <shapr> Do you know about the Curry-Howard isomorphism?
20:17:04 <sandal> But I never have run into work serious enough where i thought it'd make a difference
20:17:05 <tieTYT2> is it true to say that all values are expressions and all expressions are values?
20:17:08 <shapr> That's like, the ultimate in TDD
20:17:20 <sandal> yes. :)
20:17:32 <tieTYT2> yes to me?
20:17:37 <sandal> But again, I'm really closer to BDD
20:17:42 <sandal> to shapr
20:17:54 <shapr> Hm, I've read about BDD, but forgot what it stands for...
20:18:04 <sandal> behavior driven development
20:18:06 <shapr> I got started with TDD long ago when it was first suggested on Ward's Wiki.
20:18:32 <sandal> now I've not gone as far with it as to use something like RSpec, but only because it's not core to ruby
20:18:36 <sandal> Test::Unit is
20:18:52 <nmessenger> tieTYT2: well, that'd work, but it's probably not what most would say.
20:18:58 <shapr> tieTYT2: I can't think of any cases where that's not true. But it depends on you using the vocabulary pedantically. "Procedure" technically means something with a side-effect, and "function" technically means no side-effect.
20:18:58 <glguy> Anyone got a recommendation for a good bitmapped programming font?
20:19:00 <sandal> But basically, I do a lot of very direct work
20:19:06 <sandal> and extract general programs from that
20:19:18 <tieTYT2> hm ok
20:19:25 <sandal> Usually i get things like "I need to get a summary report of this data"
20:19:26 <shapr> tieTYT2: Why do you ask?
20:19:43 <SamB> glguy: well, there is that one in the ROM
20:19:52 <SamB> ;-P
20:20:05 <augustss> howdy
20:20:06 <shapr> sandal: CH isomorphism is the ultimate answer to BDD. Have you played with any of the tools that generate Haskell and/or ML code from a proof?
20:20:06 <tieTYT2> cause my book said that a value is just an expression that can't be evaluated anymore
20:20:17 <shapr> hej augustss, hur mår du?
20:20:23 <tieTYT2> and then it said that 42 is an 'atomic' expression and that confused me
20:20:30 <sandal> oh that's right, CH is just 'every proof is a program'
20:20:33 <tieTYT2> and then it said that simple x y z =... simple is an expression
20:20:43 <shapr> sandal: and vice versa
20:20:49 <sandal> right
20:20:49 <augustss> shapr: bara bra
20:20:56 <nmessenger> tieTYT2, an 'expression', to be pedantic, is like a description of a value.  '1 + 2', '12 `div` 4', '3' are all expressions with the value '3'.
20:21:06 <sandal> No this is my first day  working with any Haskell at all
20:21:16 <sandal> and have not done ML
20:21:34 <tieTYT2> nmessenger: then how are all those things on the left also values?
20:21:37 <shapr> augustss: Jag har haft ingen mardröm av dig sedan... don't worry ;-)
20:21:44 <sandal> but yeah shapr, I typically use user stories and use cases to drive my tests
20:21:53 <sandal> and then any bug I encounter gets a test
20:22:09 <sandal> and then if I want to generalize stomething, the generalization gets a test
20:22:10 <sandal> etc
20:22:11 <nmessenger> tieTYT2, they're not, that's why I said 'It'd work' but it isn't *technically* accurate.
20:22:13 <SamB> so, is every logical framework a typesystem for some language?
20:22:39 <sandal> So I extract my coverage rather than do a lot of thought up front
20:22:45 <shapr> smart
20:22:49 <sandal> which I mean, for practical work, is ideal
20:22:51 <shapr> I'm not a fan of BDUF.
20:23:07 <sandal> It'd be different maybe if I had formal specs to work from
20:23:09 <tieTYT2> nmessenger: hm ok
20:23:11 <sandal> I never, ever do
20:23:15 <SamB> how about LDUF
20:23:21 <tieTYT2> thanks
20:23:22 <SamB> are you a fan of that, shapr?
20:23:25 <shapr> Little Design Up Front?
20:23:31 <SamB> exactly
20:23:35 * shapr thinks about that.
20:23:38 <sandal> i'd say that design emerges.
20:23:50 <nmessenger> tieTYT2, Expressions are values and applications between values.  Values, then, are a subset of expressions.
20:24:06 <shapr> It's good to think ahead, but it's bad to write things in concrete.
20:24:16 <sandal> shapr: good way of putting it
20:24:18 <shapr> Eisenhower said "Plans are useless, but planning is essential."
20:24:28 <sandal> but you also don't want to think *too* much up front
20:24:32 <augustss> well put
20:24:33 <shapr> yup
20:24:47 <sandal> a single misconception can be a project halter in that sense
20:24:52 <shapr> yup
20:24:58 <sandal> besides, coding is so much easier than thinking
20:25:01 <shapr> heh
20:25:02 <tieTYT2> ok thanks
20:25:07 <shapr> sandal: Not so much in Haskell.
20:25:09 <sandal> If i'm getting cornered by bad design
20:25:10 <shapr> The type system will bite you.
20:25:15 <sandal> my tests get up in my face
20:25:27 <shapr> Or just laugh... it does that to me.. for hours today.
20:25:29 <sandal> Yes, i've heard that and I believe it
20:25:39 <sandal> it seems like if you think a lot about the types
20:25:44 <sandal> hooking them together is easy
20:26:13 <sandal> but I'd imagine making major changes to types in a system, not so good an idea
20:26:20 <shapr> Fixing type errors in a Haskell program is really about refining my understanding of the problem.
20:26:36 <nmessenger> ?quote Logan
20:26:37 <sorear-lambdabot> No quotes match. It can only be attributed to human error.
20:26:41 <nmessenger> ?quote LoganCapaldo
20:26:41 <sorear-lambdabot> LoganCapaldo says: [caller id is] the unique identifier attached to every stack frame of course! (Isn't it?)
20:26:46 <augustss> major changes to types is easy, because you have types
20:26:48 <nmessenger> ?quote LoganCapaldo type
20:26:49 <sorear-lambdabot> LoganCapaldo says: I like constructing things with type errors. It lets me read the error and try and figure out what I'm really trying to do
20:26:56 <shapr> nmessenger: good quote
20:27:06 <nmessenger> I @remember'ed it. :)
20:27:19 <sandal> rofl, that's a nice quote
20:27:37 <shapr> sandal: One of the cool things about Haskell is that you can use the type system to do away with lots of tests.
20:28:06 <shapr> You can choose to build your program around very picky significant types, or you can ignore the type system completely, or anything imbetween.
20:28:09 <sandal> shapr: yes, I imagine so, but you know, a lot of the type tests people would do in Ruby are not necessary
20:28:15 <augustss> sandal: also, at least for me, thinking about types really clears and focussed my mind
20:28:35 <sandal> I always see really stupid tests like
20:28:42 <sandal> assert_kind_of String, foo
20:28:51 <sandal> and it's like, why are you doing that?
20:29:00 <sandal> No one cares whether that's a string
20:29:08 <sandal> that's the way the language is.
20:29:19 <shapr> One recent simple example is that I switched my wiki from being :: Data.Map.Map String String to being :: Data.Map.Map PageName PageContent
20:29:28 <sandal> I will learn through exploration how to use types as an advantage in Haskell
20:29:39 <shapr> Yeah, if you like BDD, you'll enjoy learning Haskell.
20:29:40 <sandal> but it'll be interesting since I'm so used to ducktyping
20:29:51 <shapr> Oh, typeclasses are much like ducktyping.
20:30:13 <Saulzar> The type signature of a function is often more clear than the code, to me
20:30:19 <nmessenger> class Duck a where quack :: IO ()
20:30:43 <nmessenger> (oops, didn't mention 'a' in 'quack'.  ah well)
20:31:25 <augustss> Type classes are really like the static version of duck typing.
20:32:20 <glguy> sandal: ruby doesn't have types so much as starting points, right?
20:32:27 * nmessenger is reminded of an article, something Oleg?
20:32:35 <sandal> Um, i'd not say that.
20:32:48 <sandal> I'd say types are defined by the messages objects accept
20:32:55 <glguy> since an instance of a type can change methods, add methods
20:33:00 <augustss> nmessenger: that's not very specific since Oleg has written about everything
20:33:16 <sandal> and the behavior in response to that message
20:33:21 <glguy> after instantiation they are separate things?
20:33:35 <sandal> An object in ruby is just an object
20:33:48 <sandal> A class definition is just an instance of the Class object
20:34:00 <glguy> right
20:34:00 <sandal> which is in of itself, an object
20:34:04 * nmessenger is reminded of an article that compares typeclasses to duck typing, and used the phrase '...but prevents that object from braying like a donkey!'
20:34:08 <sandal> So instantiation isn't meaningful.
20:34:23 <sandal> def(a="foo").something; 'hi'; end
20:34:37 <sandal> that defines the method something on the string "foo" stored in a
20:34:53 <sandal> An object is just and object and you can always just define methods on it
20:35:06 <sandal> So type really is only defined by what something can do
20:35:24 <glguy> right.. every object basically has its own type
20:35:34 <sandal> yes, maybe that's a good way to put it
20:35:47 <sandal> every object has a singleton
20:35:50 <shapr> This sounds like some of Luca Cardelli's work on defining OOP.
20:35:54 <sandal> which you can define methods on
20:36:29 * shapr throws lambdas
20:36:33 <sandal> hehe
20:36:53 <shapr> sandal: Do you read research papers much?
20:37:17 * nmessenger is thrown by shapr
20:37:25 * shapr yells SHAZAM!
20:37:32 <glguy> ?yow
20:37:32 <sorear-lambdabot> Couldn't find fortune file
20:37:52 * nmessenger turns blue
20:37:56 <shapr> I have to ask my artistic girlfriend to draw CAPTAIN LAMBDA!
20:38:07 <shapr> She likes to draw superheroes.
20:38:29 <glguy> shapr: how many girlfriends do you have?
20:38:31 <sandal> >> def (a="the").answer; 42; end
20:38:31 <sandal> => nil
20:38:31 <sandal> >> a.answer
20:38:31 <sandal> => 42
20:38:31 <sandal> >> a
20:38:34 <sandal> => "the"
20:38:39 <glguy> is there a musical one?
20:38:50 <shapr> glguy: Yeah, that's her.
20:38:55 <sandal> shapr: <shrugs> occasionally.
20:39:19 <shapr> She also draws, speaks English better than I do though Swedish is her native language, rides a unicycle, and does a bunch of other things.
20:39:20 <sandal> shapr: if they're mentioned on anarchia, or occasionally LtU or Neighborhood of Infinity
20:39:35 <sandal> *anarchaia
20:39:36 <shapr> Oh, I've written about some papers onto LtU!
20:39:41 <shapr> on*
20:39:55 <shapr> coi djul .i ma nuzba
20:40:22 <sandal> I tend to do a lot of direct hackery, so research papers I mostly read when I have spare time
20:40:31 <sandal> I'm a horrible academic
20:40:40 <sandal> (currently taking a semester leave)
20:40:42 <shapr> glguy: I just uploaded her most recent art from when she visited me recently. She drew a picture of her experience with Krispy Kreme =) http://www.scannedinavian.com/hope/image/139
20:41:16 <shapr> sandal: Well, I have no degree and have taken asymptotically zero CS classes, but the Haskell world is often easiest to access if you read a bunch of academic papers.
20:41:51 <sandal> yes, that's actually indirectly how I found it
20:41:56 <iulus> asymptotically zero?
20:42:10 <sandal> I mean, I read about some concept, like the other day, packrat parsing
20:42:16 <sandal> and I find myself reading some haskell
20:42:54 <shapr> iulus: I started programming when I was 11, but I took CS101 when I was 19. The teacher taught us how to write BASIC from the ROMs in some original IBM XTs. They were really old even then.
20:43:16 <dylan> I've never taken a single CS class.
20:43:25 <shapr> iulus: Since that's the only CS class I ever had, and I already knew far more than that, I'm never sure whether to count that as one or zero CS classes.
20:43:38 <iulus> haha, alright, I think I understand what you were saying, then.
20:43:58 <dylan> it's somewhat worrying that I have no paper saying I'm a good sysadmin/programmer, when friends younger than me do... but I have more credit hours in college than them...
20:44:36 <shapr> sandal: Packrat parsing is way cool.
20:44:42 <iulus> dylan: but you most likely probably have bosses/coworkers that say that
20:44:43 <sandal> Okay, what's a better idiom for this: fst(head(tail [(5, 'b'), (1, 'c'), (6, 'a')]))
20:44:45 <iulus> that's good enough.
20:44:59 <sandal> shapr: thinking of implementing a packrat parser in ruby for my reporting package
20:45:10 <dylan> iulus: "good enough", except it might mean I might get paid less.
20:45:13 <shapr> Hm, I think I've read about a packrat parser in Ruby already.
20:45:19 <sandal> if not, i'll do your basic recursive descent parser
20:45:26 <iulus> sandal: fst . head . tail $ [(5,'b'),(1,'c'),(6,'a')]
20:45:29 <shapr> dylan: Yeah, I've not gotten hired for one or two Haskell jobs because I have no degree.
20:45:29 <sandal> i think there are two, peggy and packrait
20:45:30 <dylan> iulus: not that I care; I just care about getting my college to tell me what credits I *need* to be a math major.
20:45:42 <sandal> *packrat
20:45:57 <shapr> I do care, if I had more money I'd pay other people on #haskell to write Haskell code =)
20:45:58 <sandal> packrat is old and dead
20:46:19 <sandal> and peggy would need a happier DSL for my needs
20:46:36 <sandal> I really want something which allows me to have a block centric parser with EBNF
20:46:37 <shapr> sandal: Try parsec in Haskell. Parser monads are *so* nice.
20:46:40 <glguy> sandal: do you know the !! operator?
20:46:40 <dylan> shapr: well, I'm working towards a degree, it's just not terribly practical. I am leaning towards a math degree as it is more interesting.
20:46:56 <glguy> fst $ [(5,'b'),(1,'c'),(6,'a')] !! 1
20:46:59 <sandal> so really, we need to take OOParser which hasn't been written yet
20:47:02 <iulus> dylan: go for both
20:47:04 <iulus> ;P
20:47:10 <sandal> and slam a packrat parser underneath it
20:47:12 <shapr> dylan: Yeah, I went for interesting classes too. That's why in six years I got zero degree. Also, I already knew computery stuff, why would I take classes in that subject?
20:47:16 <iulus> I'm about 5 months from a piece of paper that says I've done both.
20:47:23 <sandal> the OOParser experimental syntax is great
20:47:34 <sandal> shapr: parsec might be cool but I need a ruby parser
20:47:34 <nmessenger> sandal: case yourList of _:(x,_):_ -> x -- or pattern-matching in some other context
20:47:43 <dylan> shapr: even to graduate, I'll have to take a 'basic computer competency' class...
20:47:47 <shapr> sandal: Yeah, just saying you'll enjoy Parsec.
20:47:50 <sandal> glguy: what's the !! do?
20:47:51 <shapr> dylan: haha
20:48:04 <shapr> dylan: submit your homework in Haskell, please!
20:48:05 <glguy> sandal: !! is the list indexing function, startingat index 0
20:48:06 <iulus> > [0,1,2,3] !! 1
20:48:08 <sandal> and actually, what's the $ do
20:48:08 * shapr boings amusedly
20:48:17 <sandal> oh, alright, cool
20:48:27 <dylan> shapr: (and I did technically take intro to operating systems, which I wrote a boot text editor and passed it off as an operating system for the teacher. I did this in hopes of indirectly impressing the teacher's geeky daughter... that was a few years ago)
20:48:28 <sandal> yes, i actually did an example with that
20:48:29 <iulus> 'f $ x' is the same as 'f x'
20:48:35 <glguy> (x:_) !! 0 = x ; (_:xs) !! n = xs !! (n-1)
20:48:36 <shapr> dylan: haha
20:48:38 <sandal> alright, so why use the $
20:48:43 <sandal> clarity?
20:48:44 <iulus> it just gives function composition a different precedence
20:48:50 <nmessenger> sandal, low precedence, removes parens
20:48:51 <glguy> sandal: because parentheses stackup
20:48:53 <shapr> dylan: Mind if I quote that?
20:48:58 <sandal> oh, okay, great
20:49:11 <jcreigh> man, Parsec sure is handy.
20:49:17 <sandal> i've been getting tired of writing lisp over here
20:49:17 <jcreigh> @karma+ Parsec
20:49:18 <sorear-lambdabot> Parsec's karma raised to 2.
20:49:22 <sandal> that's what I was looking for :)
20:49:25 <nmessenger> foo(blah(blargh(barf(poo)))) == foo $ blah $ blargh $ barf $ poo
20:49:26 <dylan> shapr: sure. it could be better stated, but I took that operating systems class for the sole goal of trying to meet the daughter of the teacher... which didn't work.
20:49:38 <glguy> sandal: f (g (h x))  --> f . g . h $ x
20:49:40 <shapr> nmessenger: Now, can you rewrite that with the right number of (.) instead of ($) ? ;-)
20:49:49 <shapr> dylan: Funny story :-)
20:49:54 <nmessenger> s/$/./ except the last one
20:50:09 <nmessenger> :P
20:50:17 <shapr> nmessenger: hah! quick response!
20:50:20 <dylan> shapr: I also became the alpha geek in my LUG primarily to meet women. And that's how I met my fiancee :)
20:50:27 <shapr> dylan: wow
20:50:45 <shapr> I met my current girlfriend via my ex...
20:50:57 <dylan> I learned to program years ago to impress another girl I had a crush on...
20:51:09 <glguy> I met my girlfriend via her ex
20:51:23 <shapr> dylan: You gotta write your memoirs :-)
20:51:27 * shapr is entertained
20:51:29 <dylan> this makes me sound terribly weird.
20:51:33 <sandal> oh jeeze, thanks for the $ tip
20:51:39 <sandal> I hated those parens!
20:51:44 <shapr> dylan: It's okay, my memoirs are so weird most people think I'm lying.
20:52:16 <dylan> shapr: hehe. I remember you mentioning strange stories on ward's wiki.
20:52:23 <iulus> sandal: not a lisp fan? :P
20:52:25 <shapr> Oh no, what did I write?
20:52:38 * shapr looks
20:52:43 <sandal> Oh, I've not done enough lisp to know that
20:52:51 <dylan> mostly about name-changing and adhd drugs.
20:52:56 <sandal> I just think the syntax looks bad enough that larry wall made fun of it
20:53:07 <sandal> I'm sure it can be written nicer
20:53:14 <slava> what does larry wall know about nice looking syntax?
20:53:26 <sandal> slava: that's the funny part. nothing
20:53:33 <dylan> shapr: you're another person, much like Chris Double, that seems to always be in the same general area of the internet as me.
20:53:41 <shapr> dylan: Yeah... someday I'll show up in FL and tell you stories over beer.
20:53:49 <iulus> slava: haha
20:53:50 <shapr> Yeah, I'm surprised I haven't seen Chris Double on IRC.
20:53:59 <slava> chris double is frequently on irc
20:54:02 <dylan> shapr: I don't drink beer, but I'll down the tea.
20:54:08 <shapr> fair enough
20:54:26 <slava> he goes by doublec and he's in #concatenative right now
20:54:28 <dylan> Chris Double is a former member of a community I, nornagon, bd_, and some other people are/were members of.
20:54:34 <slava> i think that's the only channel he frequents
20:54:40 --- mode: ChanServ set +o shapr
20:55:07 <dylan> shapr: okay, okay, I'll drink beer!
20:55:19 <shapr> dylan: hah, was just inviting doublec :-P
20:55:22 --- mode: shapr set -o shapr
20:55:25 * shapr laughs
20:55:42 <shapr> dylan: What community is that?
20:55:57 <shapr> slava: Thanks for the info.
20:56:27 <dylan> shapr: the Creatures Community.
20:56:32 <shapr> The game?
20:56:34 <shapr> ohh
20:56:35 <dylan> yeah
20:56:38 <shapr> "norn"
20:56:45 <dylan> it spawned a massive online community.
20:56:47 <shapr> interesting
20:56:49 <dylan> we're still around, too.
20:56:54 <shapr> I read about it, but could never afford a copy.
20:56:59 <shapr> Seemed like fun.
20:57:44 <sandal> yes, these test cases look much better now with all the $$$$$ ! :)
20:57:51 <dylan> it is. Several people are writing an open source version now.
20:58:00 <shapr> sandal: 4. $Profit$!
20:58:09 <sandal> rofl
20:59:09 <sandal> http://pastie.caboo.se/32250
20:59:10 <sorear-lambdabot> Title: #32250 - Pastie
21:00:06 <iulus> did lambdabot disappear, so sorear-lambdabot is taking the duties, or what?
21:00:21 <bd_> ?botsnack
21:00:21 <sorear-lambdabot> :)
21:00:24 <iulus> lambdabot needed a vacation after all of her hard work?
21:00:24 <bd_> hmm
21:00:24 <nmessenger> ($) can cause odd errors if you, for example, use it on a two-arg function, so be wary.
21:00:44 <sandal> nmessenger: okay, thanks for the heads up
21:00:56 <shapr> dons is flying to the UK, so when lambdabot died, mbot showed up, then it died too, so sorear saved us!
21:01:10 <iulus> ah, okay.
21:01:17 * nmessenger wants to '>'!  *cries*
21:01:21 <iulus> for the hackathon, I suppose.
21:01:23 <bd_> > True
21:01:23 <shapr> yup
21:01:26 <bd_> aw
21:01:35 <sandal> yeah, i ended up using this:
21:01:37 <sandal> fst $ [(5,'b'),(1,'c'),(6,'a')] !! 1
21:01:47 <sandal> I think that's clearest to me what's going on
21:02:10 <shapr> sandal: There's fun Haskell-related stuff to read on http://planet.haskell.org/
21:02:10 <sorear-lambdabot> Title: Planet Haskell
21:02:14 <sandal> as long as it's not making anyone's eyes bleed
21:02:39 <shapr> sandal: Most people stack stuff up all on one side so it's easier to read, but if that works for you...
21:03:14 <sandal> shapr: example?
21:03:26 <sandal> oh, cool, is that an open agregator
21:03:28 <iulus> sharp: so how would you do it?   fst . (!!1) $ [(...
21:03:35 <allbery_b> > 2
21:03:37 <glguy> ew...
21:03:44 <allbery_b> oh right, plugin
21:03:47 <sandal> Because I'll add my feed for my haskell tag to it
21:03:49 <iulus> glguy: no, doesn't look good to me
21:03:53 <iulus> either
21:05:00 <shapr> hiya doublec!
21:05:05 <shapr> doublec: We were just talking about you.
21:05:05 <doublec> hi shapr!
21:05:19 <doublec> nothing too bad I hope :)
21:05:26 <shapr> Then slava mentioned you were on #concatenative, so I invited you.
21:05:46 <shapr> iulus: I'd probably use head instead of (!!1) but I'm not sure what I'd do instead of something like (!!2)
21:06:07 <sorear> head /= (!!1)
21:06:14 <allbery_b> pattern matching?
21:06:20 <sorear> lists are zero indexed
21:06:22 <shapr> sorear: er, right
21:06:23 <shapr> doh
21:06:42 <shapr> doublec: dylan just said you are/were part of the Creatures community as well and being interested in PLT.
21:07:26 <doublec> shapr, yep. I played around with creatures for quite a while
21:08:01 <shapr> I've never tried it. Is it anything like programming?
21:08:04 <dylan> doublec: And I'm the fellow that everyone always thought was you, because of your choice of using the language that bears my name. :)
21:08:08 <doublec> http://www.double.co.nz/creatures
21:08:08 <sorear-lambdabot> Title: Creatures Developer Resource
21:08:29 <sandal> shapr: so is there a better way to write that
21:08:37 <doublec> shapr, basically it's a virtual world with artificial agents and a programming language to interact with it.
21:08:38 <sandal> it doesn't look like folks agree  :)
21:08:48 <shapr> sandal: I'm not sure. I think I'll look at it again when I'm not sleepy.
21:08:55 <dylan> doublec: and you've been stalking me all these years! I read on the io-language homepage, patches submited by chris double! I read LtU, and I see Chris Double. I swear, you follow me on the internet. :)
21:08:56 <sandal> shapr: fair enough
21:09:05 <sandal> I'm just hoping it looks good enough for n00b code :)
21:09:07 <iulus> sandal: It's just a short line, I think that's about the best you are going to get on that one.
21:09:09 <doublec> hehe, I'm like that dylan - obsessive :)
21:09:21 <slava> he is stalking me too! his code keeps showing up in my project
21:09:52 <dylan> doublec: and I think I saw you on ward's wiki, too. And slashdot several years back.
21:09:56 <shapr> sandal: If it works, it's better than n00b code.
21:10:02 <sandal> rofl
21:10:11 <sandal> I should hope the bar is a little higher than that
21:10:26 <dylan> doublec: heck, on LtU, I read a comment describing Creatures, and it was you! :)
21:10:28 <doublec> most likely. I sometimes see old things I've done and don't realise I did it
21:10:34 <shapr> Well, sometimes people take quite some time to get to grips with the shift from procedural to purely functional. It sure took me awhile.
21:10:34 <iulus> sandal: you learned about '$', that's enough lesson for now, now work on something new instead of working on that line of code and you can learn something else
21:10:41 <sandal> I've not had any trouble with these trivial examples, except really getting my head around syntax, precedence and the way ghc parses
21:10:42 <sorear> in haskell, n00b code doesn't compile, let alone work.
21:10:56 <sandal> rofl iulus, very good point.
21:10:58 <shapr> dylan, doublec: Do you guys hang out on #ltu as well?
21:11:11 <dylan> I don't. I just read LtU for the articles.
21:11:35 <shapr> I just read it for the pictures.
21:11:36 <iulus> doublec: did you write a blog about that recently? Something about your code showing up in an old Haskell library?
21:11:40 <shapr> Wait, which magazine are we talking about?
21:11:42 <shapr> oops
21:11:55 <dylan> doublec: btw, are you aware of the brave hackers reimplementing the Creatures 3 engine?
21:12:00 <SamB_XP> yeah, really! nobody actually reads LtU for the articles! everyone reads it for the nude pictures!
21:12:04 <sorear> bos_, fps aka ByteString
21:12:09 <shapr> SamB_XP: I think that's the wrong magazine!
21:12:16 <iulus> SamB_XP: What! I'm going there right now! :P
21:12:21 * shapr laughs
21:12:32 <doublec> dylan, yes I've seen a couple of posts about it
21:12:45 <doublec> iulus, no, not me
21:13:14 <sorear> iulus: that was bos, original author of Data.ByteString
21:13:18 <SamB_XP> a lot of people seem to be finding their code in Prelude and in Data.List
21:13:30 <iulus> sorear: thanks.
21:13:36 <sorear> @go shock forgotten
21:13:37 <sorear-lambdabot> http://www.msnbc.msn.com/id/16399610/site/newsweek/
21:13:37 <sorear-lambdabot> Title: Celebrating the World's Forgotten Old Technologies - Newsweek: International Edi ...
21:13:56 <sorear> http://www.serpentine.com/blog/2007/01/01/the-shock-of-the-forgotten/
21:13:57 <sorear-lambdabot> Title: teideal glic deisbhéalach  Blog Archive  The shock of the forgotten, http://tinyurl.com/u9qd6
21:14:23 <sorear> s'pose its a bit too new for google :)
21:16:32 <sandal> can you define functions in ghci ?
21:16:40 <sorear> yes
21:16:48 <sandal> anything special you need to do
21:16:51 <Excedrin> let f x = x * 2
21:16:52 <sorear> > let foo x = foo
21:16:52 <sorear-lambdabot>  Parse error
21:16:55 <sandal> because it's giving me a partse error
21:17:00 <sandal> *parse error
21:17:13 <sorear> what did you enter?
21:17:17 <allbery_b> let ... should work
21:17:23 <bd_> > let foo x = foo in foo -- you mean?
21:17:25 <sorear> don't use 'in'
21:17:28 <bd_> oh
21:17:30 <bd_> right, in ghci
21:17:47 <sandal> let works
21:17:48 <sandal> thx
21:17:57 <glguy> >500#<'I will not throw paper airplanes in class.'
21:17:57 <sorear> yw
21:18:06 <sandal> span multiline?
21:18:29 <sorear> <greets dpiponi>
21:18:47 * dpiponi greets sorear in kind
21:18:47 <shapr> hiya dpiponi
21:19:04 <dpiponi> Hiya.
21:19:15 * shapr greets people in cruel!
21:19:19 <Excedrin> sandal: no, enter them in a file if that's the case, then use :load file.hs and :reload (both can be abbreviated, :l and :r)
21:19:28 <sandal> gotcha.  Lame
21:19:29 <sandal> :)
21:19:36 <dpiponi> Hey, does the universe already have too many Monad tutorials
21:19:44 * sandal misses irb a little
21:19:45 <sorear> yes
21:19:48 <shapr> dpiponi: Nah, write more!
21:19:59 <dpiponi> I had an idea for another one that is the simplest of all
21:20:29 <shapr> dpiponi: Go for it!
21:20:57 <dpiponi> I think you can motivate the entire definition of Monad through an interresting use of the identity monad
21:21:10 <shapr> Where do I contribute?
21:22:12 <dpiponi> Is this a contribution in beer?
21:22:17 <shapr> Hm.. ok!
21:22:22 <sandal> any command history for ghci
21:22:27 <sandal> or autocomplete?
21:22:28 * sorear is still trying to prove the hairy ball theorem ... I know about wikipedia but my way is more fun
21:22:29 <shapr> As long as it's not overly expensive beer.
21:22:41 <allbery_b> sandal: you could always grab the Shelllac framework and write one :>
21:22:51 <sorear> sandal: yes, and yes, 'out of the box'.
21:22:55 <allbery_b> ghci should have history via readline (uparrow/downarrow)
21:23:00 <sorear> just use version 6.6
21:23:04 <shapr> Do you like Dutch beer like Duvel? Or maybe Finnish beer like Lapin Kulta? I refuse to buy Koff though.
21:23:06 <sandal> no. I have that
21:23:08 <sorear> and don't use freebsd
21:23:11 <sandal> I mean, between sessions
21:23:14 <dpiponi> sorear: it's tricky to prove
21:23:25 <sandal> okay, the completion works fine
21:23:28 <sandal> I didn't even try it
21:23:48 <sandal> and I have history in a session
21:23:49 <shapr> At least the Koff brewery makes Battery. That's their one positive contribution to the world.
21:23:54 <sandal> but i'd like to have it between sessions
21:23:55 * shapr rambles sleepily
21:23:57 <sandal> like a bash history
21:24:05 <sorear> so far, I've seen that is is equivalent to 'any mapping of S^2 into itself with no fixed points is *not* homotopic to the identity mapping'.  Am I close?
21:24:26 <allbery_b> or get my fbsd patch of the mailing list :>
21:24:39 <nmessenger> ?quote fluxbox.list
21:24:39 <sorear-lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
21:24:40 <sorear-lambdabot> for your entire program.")
21:25:07 <dpiponi> If you can prove what you just said you can probably prove the hairy ball theorem
21:25:20 <SamB_XP> jcreigh: do you still feel like that?
21:25:34 <SamB_XP> dpiponi: does that have something to do with monads?
21:26:32 <sandal> mmh, | is very nice for conditionals
21:26:35 <dpiponi> That's algebraic topology and I don't know if monads mean much in that context. (They might, I just haven't heard about it though.)
21:27:13 <allbery_b> ghci doesn't enable readline's history feature,and I see no way to do it from .inputrc
21:27:15 <SamB_XP> dpiponi: oh. see, I thought maybe "hairy ball" was another alias for "monad", like "warm fuzzy thing"
21:27:24 <terabyte> hey
21:27:29 <SamB_XP> allbery_b: ... it doesn't?
21:27:31 <dpiponi> Oh no. Hairy balls are hairy balls.
21:27:46 <terabyte> Does anybody know how to configure kwrite to be the editor for hugs on linux?
21:27:46 <SamB_XP> it works for me!
21:27:50 <allbery_b> SamB_XP: not between sessions, i.e. like .bash_history
21:27:55 <SamB_XP> oh, that.
21:27:59 * shapr falls over asleep
21:28:01 * shapr &
21:28:03 <SamB_XP> that never works reliably for me anyway
21:28:11 <jcreigh> SamB_XP: I was mostly joking when I said that.
21:28:28 <SamB_XP> shell sessions are always overwriting eachother's history anyway
21:28:43 <jcreigh> but still, one of the cool things about Haskell is that most people who code in it seem to be smarter than me.
21:29:01 <allbery_b> bash is too stupid to handle that correctly, yeh.
21:29:03 * allbery_b loves zsh :>
21:29:26 <dpiponi> So who's going to port ghc or hugs to the iphone?
21:29:39 <iulus> how about to the TI-89?
21:29:47 * sorear chsh /usr/bin/ghci
21:29:49 <terabyte> Anyone? (know how to setup editor for hugs in linux)
21:29:53 <nmessenger> terabyte: can you set $EDITOR?
21:30:01 * nmessenger doesn't know
21:30:04 <terabyte> Not sure how that's done?
21:30:12 <dpiponi> TI-89 would do
21:30:35 <allbery_b> -Eeditor or $EDITOR
21:31:03 <allbery_b> export EDITOR=/usr/bin/nvi (substitute path to preferred editor)
21:31:16 * nmessenger doesn't have linux, but thinks that terabyte should edit ~/.bashrc or something.
21:31:43 <allbery_b> (if you use csh/tcsh:  "setenv EDITOR /usr/bin/nvi"... and consider using a real shell :> )
21:31:53 <terabyte> where should I type export editor=....
21:31:56 <terabyte> terminal?
21:32:04 <allbery_b> initially at the terminal
21:32:09 <terabyte> ok
21:32:42 <allbery_b> then put it in .profile (.bashrc is actually the wrong place for environment settings) so it'll be remembered for the future
21:33:08 <terabyte> ok that export command worked what next?
21:33:19 <allbery_b> hugs should now use the editor you specified
21:33:29 <terabyte> WOW
21:33:33 <terabyte> thankyou :D
21:33:59 * nmessenger grins at terabyte.  Sometimes things aren't so complicated ;)
21:34:11 <allbery_b> ($EDITOR is a standard convention on unixlike systems when programs want to use an editor)
21:34:20 <jcreigh> @hoogle getArgs
21:34:21 <sorear-lambdabot> System.getArgs :: IO [String]
21:34:51 <jcreigh> so, is it better to use the hierarchical module names? (Data.List vs List, Control.Monad vs Monad, etc.)
21:35:27 <glguy> ?docs Text.ParserCombinators.Parsec
21:35:28 <sorear-lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
21:35:30 <allbery_b> yes
21:35:30 <nmessenger> List, etc. are Haskell 98, but using the Hier names makes me feel warm and fuzzy.
21:35:59 <allbery_b> if you absolutely need Haskell98, use the short names.  but, well, Haskell's a lot nicer these days with things like that
21:40:44 <jcreigh> so that convention is fairly standard? by which I mean: works in both Hugs and GHC?
21:41:18 <nmessenger> Fairly standard as in bound for Haskell Prime, and yes, works in both.
21:41:29 <allbery_b> hugs understand it with -98 (which should be the default)
21:42:02 <allbery_b> hm, no , default is +98 (haskell98 only)
21:43:02 <sandal> ooh, piecewise functions
21:43:04 <sandal> fantastic
21:43:18 <glguy> ?bot
21:43:18 <sorear-lambdabot> :)
21:44:42 <glguy> > let groupMap f xs = map (f `ap` row) . nub . map head $ xs where row name = [item | (n:item) <- xs , n == name] in groupMap (,) [["a","b","c"],["b","c","d"],["a","e","f"]]
21:44:54 <glguy> ?run let groupMap f xs = map (f `ap` row) . nub . map head $ xs where row name = [item | (n:item) <- xs , n == name] in groupMap (,) [["a","b","c"],["b","c","d"],["a","e","f"]]
21:44:55 <sorear-lambdabot> Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
21:48:21 <sorear> glguy: nice try.  unfortunately, hs-plugins, and thus runplugs, and thus Plugin.Eval, doesn't work on 6.6.
21:48:42 <sandal> mmh, function composition
21:48:49 * sandal is in love.
21:49:13 <sandal> Totally pedestrian things, i'm sure.  But I like how much haskell honours math.
21:49:44 <glguy> sandal: Haskell challenge, run that command in your GHCi sesion and figure out why it works
21:49:48 <sorear> you actually figured out what '.' was just from the text-code?
21:49:54 * sorear is impressed
21:50:05 <glguy> sandal: you might need to type in GHCi   :m + Control.Monad.Instances
21:50:44 <glguy> :m + Control.Monad.Instances Control.Monad Data.List
21:50:46 <glguy> actually
21:51:12 <sorear> that is so inefficient looking
21:51:21 <glguy> sorear: you're up
21:51:47 <glguy> sorear: the order must be preserved is the only requirement
21:52:09 <glguy> relative order of grouped items, and order of appearance for group names
21:52:12 <sandal> glguy: i'm getting a parse error
21:52:29 <glguy> sandal: get rid of ?run
21:52:34 <sorear> let groupMap f = map (\(a:b) -> f a b) . nubBy ((==) `on` head) in groupMap (,) [["a","b","c"],["b","c","d"],["a","e","f"]]
21:52:35 <glguy> or the leading >
21:52:52 <glguy> on?
21:52:56 <sorear> nubBy should be *much* faster
21:53:02 <sorear> it's new in 6.6
21:53:06 <sorear> (on)
21:53:11 <glguy> sorear: what module
21:53:13 <glguy> ?index on
21:53:13 <sorear-lambdabot> bzzt
21:53:17 <sorear> Data.Function
21:53:25 <sorear> :t Data.Function.on
21:53:28 <sorear-lambdabot> forall b c a. (b -> b -> c) -> (a -> b) -> a -> a -> c
21:53:37 <glguy> Data.Function isn't standard in 6.6
21:53:53 <sorear> I have dons' 6.4 hoogle.txt, but :t uses my HEAD ghci
21:54:06 <glguy> oh, maybe standard in HEAD
21:54:11 <sandal> not working out for me :-/
21:54:16 <glguy> ?djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
21:54:16 <sorear-lambdabot> f a b c _ = a (b c) (b c)
21:54:50 <sorear> on f p x y = f (p x) (p y)
21:55:18 <sandal> I'm not ready for that code just yet. hehe
21:55:29 <glguy> I use: uncons f (x:xs) = f x xs
21:56:05 <glguy> sorear: yours eliminates the rows with duplicate groupnames?
21:56:10 <glguy> instead of merging them?
21:56:17 <sorear> oh
21:56:30 <glguy> nubBy is a good suggestion though
21:56:40 <glguy> err
21:56:41 <glguy> no
21:56:44 <glguy> for htis it wouldn't work
21:57:11 <glguy> [("a",[["b","c"],["e","f"]]),("b",[["c","d"]])]
21:57:17 <glguy> that would be the output for the given example
21:58:01 <sorear> ah
21:58:14 <sorear> let uncons (x:y) = (x,y)
21:58:30 <glguy> I use it as a parallel to uncurry
21:58:48 <sorear> let groupMap f = map (uncurry f) . multiMapToListMap
21:59:02 <glguy> ?index multiMapToListMap
21:59:02 <sorear-lambdabot> bzzt
21:59:04 <sorear> let groupMap f = map (uncurry f) . multiMapToListMap . map uncons
21:59:11 <sorear> I'm about to write it
21:59:14 <glguy> heh
21:59:25 <sorear> but it could have other uses
21:59:38 <glguy> and it would be order preserving?
21:59:49 <sorear> yah :(
22:01:48 <glguy> I think it could be done with a Data.Map.fromListWithKey
22:01:50 <sorear> ackh, no insertWith in Data.List
22:02:41 <glguy> sorear: the map values could be built up with (:)
22:02:47 <glguy> and reverse could be called at the end
22:02:54 <glguy> a constant-time slowdown
22:03:57 <glguy> fromListWith (++) . map (\(x:xs) -> (x,[xs]))
22:04:13 <glguy> might need flip (++) to make that reasonable
22:05:02 <sorear> I think changing the type of groupMap is a better approach :)
22:05:08 <glguy> to ?
22:06:45 <sorear> head is evil - use tuples
22:06:52 <sorear> alists are evil - use maps
22:07:11 <glguy> sorear: the source is a [[String]] as parsed by csvFile
22:07:16 <sorear> ouch
22:07:24 <glguy> from MissingH
22:09:31 <lisppaste2> glguy pasted "sorear, this is what I'm playing with" at http://paste.lisp.org/display/34718
22:10:24 <sorear> map (\((_,l),m) -> l : concat m) . M.toList . M.fromListWith (++) . zipWith (\n -> (,) n *** (:[])) [0..] . map (\(x:xs) -> (x,xs)) -- this should typecheck
22:10:45 <sorear> and it's wrong nm
22:10:48 <slava> what does that snippet do?
22:11:13 <sorear> slava: it's a really fancy way of writing 'id'
22:11:33 <sorear> you should have specified "*supposed* to do" :)
22:12:01 <glguy> [["a","b","c"],["b","c","d"],["a","e","f"]] -> [("a",[["b","c"],["e","f"]]),("b",[["c","d"]])]
22:12:29 <glguy> it's my mapGroup from the paste above
22:12:42 <glguy> when used with (,)
22:13:01 <mgsloan> I take it that -> in propositional logic has nothing to do with haskell's ->
22:13:06 <glguy> yeah
22:13:13 <glguy> input -> output
22:13:38 <mgsloan> yeah, yeah, I'm not THAT new :P
22:13:38 <sorear> mgsloan: they're the same thing.  See "curry-howard isomorphism"
22:13:42 <mgsloan> oh, really
22:13:54 <glguy> sorear cried ugly on my groupMap function and is rewriting it
22:13:57 <glguy> or was
22:13:58 <glguy> i dont' know
22:14:07 <sorear> a -> b means (a is inhabited) implies (b is inhabited)
22:14:42 <sorear> so the theorems of intuitionist logic and the terms of typed lambda calculus are the same
22:14:58 <sorear> so the theorems of intuitionist logic and the inhabited types of typed lambda calculus are the same
22:15:16 <sorear> and the proofs of intuitionist logic and the terms of typed lambda calculus are the same
22:15:36 <slava> sorear: so is that the shortest haskell implementation of glguy's groupMap? :)
22:15:51 <sorear> no, it's a long implementation of 'id'
22:16:25 * mgsloan has been surfing MIT OpenCourseWare :)
22:16:36 <sorear> it has an unfixable bug
22:17:45 <sorear> is anyone willing to run a lambdabot?
22:17:50 <glguy> is there a standard arrow for writing stream fuctions?
22:17:56 <glguy> that behave like maps
22:18:13 <sorear> in a sense, (->) is that
22:18:16 <glguy> xs >>> arr succ   -- behaving like   map succ xs
22:18:26 <sorear> but then all you can have is maps
22:18:32 <glguy> right
22:19:14 <glguy> is there something for that?
22:19:59 <sorear> It is 14 minutes after my bedtime. I am tired. My computer does not run while I sleep. Hence sorear-lambdabot will vanish *real soon now*.  Do not be alarmed.
22:20:05 <sorear> I dunno.
22:30:04 <Cale> > foldr (+) 0 [1..10]
22:30:08 <mbot>  55
22:30:29 <allbery_b> hopefully you spiked @yow this time :)
22:36:21 <brad_> ?src unfoldr
22:38:09 <allbery_b> ?src unfoldr
22:38:15 <allbery_b> hm
22:38:23 <allbery_b> ?list
22:38:24 <mbot> Maybe you meant: arr ghc url
22:38:42 <allbery_b> guess mbot doesn't have some stuff
22:38:53 <allbery_b> (not that surprising, ?src is pretty new)
22:39:36 <brad_> worked yesterday, was somewhat enamored with the functionality
22:40:34 <brad_> cest lavie
22:41:05 <allbery_b> lambdabot and sorear-lambdabot are both newer versions.  mbot is an older version
22:41:27 <mbot> Maybe you meant: arr ghc url
22:41:27 <mbot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:41:27 <brad_> is lambdabot not always present here?
22:41:38 <allbery_b> and @src was added in the past week
22:42:07 <allbery_b> lambdabot is present but broken at the moment; there was a netsplit earlier today, and netsplits make it hang for some reason
22:42:21 <brad_> netsplit?
22:42:25 <allbery_b> dons is en route to the UK for HAC07
22:42:50 <brad_> i hope he makes the trip safely, i rely on him to be my living debugger
22:42:55 <allbery_b> an IRC network consists of a bunchh of interlinked servers.  a netsplit is when one or more of the servers lose their connections to the others
22:43:27 <brad_> ah
22:43:36 <allbery_b> thereby isolating users on those servers untilt eh connection si reestablished.
22:43:47 <brad_> understood
22:44:24 <brad_> i have high expectations for seeing some good edits come out of the hackathon
22:44:37 <brad_> Network.HTTP could use some love
22:45:24 <allbery_b> (whena netsplit happens, users on the other side of the split show as logging off all at once.  sorear thinks lambdabot is trying to process those all at the samr time without locking and tripping over itself)
22:46:15 <mgsloan> should it even pay attention to em?
22:46:45 <allbery_b> yes, one of the modules tracks people coming and going, and another watches for people to join and checks for saved messages for them
22:46:48 <allbery_b> @seen
22:46:48 <mbot> Lately, I have seen allbery_b, atrix, brad_, drakemcsmooth, kasadkad, mgsloan, nmessenger and rutski.
22:46:53 <mgsloan> ah
22:46:59 <allbery_b> @seen sorear
22:47:00 <mbot> I haven't seen sorear.
22:47:08 <allbery_b> right, sorear left before mbot joined
22:47:08 <mgsloan> yeah, i suppose it maintains the counts too
22:47:29 <Saizan> is there an example of reading an xml to populate an haskell's list of records with HXT? i find only programs that create another xml
22:48:05 <allbery_b> @seen johnnowak
22:48:05 <mbot> I saw johnnowak leaving #haskell 5m 51s ago, and .
22:48:22 <brad_> @seen brad_
22:48:22 <mbot> You are in #haskell. I last heard you speak just now.
22:48:33 <bos__> @seen mbot
22:48:33 <mbot> Yes, I'm here. I'm in #haskell, #physics, ##engineering and #math
22:49:05 <mgsloan> should just have a netsplit detector
22:54:24 <mgsloan> oh, mbot == lambdabot? so lambdabot has a mathematica ext then?
22:56:12 <Cale> I wrote one. Though it occasionally gets stuck, and I haven't bothered to really look into why.
22:56:54 <mgsloan> ah, cool (though i don't actually like mathamatica all that much :P)
22:56:56 <nornagon> ?hoogle (Rational a, RealNum b) => a -> b
22:56:57 <mbot> A Hoogle error occured.
22:57:19 <sjanssen> we are all so lost without dons and his lambdabot :)
22:57:28 <nornagon> :)
22:57:36 <nornagon> how do I go Rational -> Double, then?
22:57:46 <sjanssen> @type fromRational
22:57:48 <mbot> forall a. (Fractional a) => Rational -> a
22:58:07 <mauke> > sqrt (fromRational (1%2))
22:58:08 <mbot>  0.7071067811865476
22:58:13 <nornagon> ah.
22:58:20 <nornagon> > sqrt (1%2)
22:58:21 <mbot>  add an instance declaration for (Floating (Ratio a))
22:58:21 <mbot>   In the definition ...
22:58:39 <Cale> I don't have hoogle installed.
22:58:48 <nornagon> hm, i forget how to go the other way >.>
22:59:13 <sjanssen> you want a Double -> Rational?
22:59:14 <Cale> > realToFrac (sqrt (1%2))
22:59:15 <mbot>  add an instance declaration for (Floating (Ratio a))
22:59:20 <Cale> > realToFrac (sqrt (1/2))
22:59:21 <mbot>  0.7071067811865476
22:59:26 <Cale> > realToFrac (sqrt (1/2)) :: Rational
22:59:27 <mbot>  6369051672525773%9007199254740992
22:59:34 <nornagon> sjanssen: yah
23:00:00 <sjanssen> nornagon: check out what Cale is laying down
23:00:08 <nornagon> oh
23:00:10 <Cale> > realToFrac (sqrt 2) :: Rational
23:00:13 <nornagon> ?type toRational
23:00:16 <nornagon> :)
23:00:24 <Cale> hmm
23:00:27 <nornagon> (toRational does it)
23:00:53 <Cale> I should upgrade
23:01:16 * Cale darcs pulls
23:01:48 <sjanssen> Cale: I think the most recent darcs patches are the reason that lambdabot isn't here right now
23:02:01 <allbery_b> no, the netsplit thing has been around for a while
23:02:12 <Cale> yeah, but the less recent ones are fixes to other problems which my copy has :)
23:02:15 <sandal> hmm
23:02:26 <sandal> is there a reason why this map implementation shouldn't work
23:02:27 <sandal> my_map f []  = []
23:02:27 <sandal> my_map f (x:xs) = f x : my_map f xs
23:02:34 <sjanssen> allbery_b: can you define a while?
23:02:52 <allbery_b> since I started coming here, a month or so back
23:03:01 <allbery_b> well before this current round of lbot hackery
23:03:10 <mauke> sandal: looks ok
23:03:19 <nornagon> ?src map
23:03:21 <nornagon> OSHI
23:03:31 <nornagon> > src map
23:03:31 <nornagon> map _ []     = []
23:03:31 <nornagon> map f (x:xs) = f x : map f xs
23:03:40 <nornagon> so you're bang on :)
23:03:43 <mgsloan> split detection and compensation could be added
23:03:45 <sjanssen> @type let my_map f []  = []; my_map f (x:xs) = f x : my_map f xs in my_map
23:03:50 <Cale> no bots
23:03:58 <Cale> I'm updating my copy
23:04:14 <sandal> but yuck, it gives me an non-exhaustive patterns err
23:04:17 <allbery_b> that definition works for me (locally in ghci)
23:04:35 <sandal> Prelude> map Char.isUpper "fOo"
23:04:35 <sandal> [False,True,False]
23:04:35 <sandal> Prelude> my_map Char.isUpper "fOo"
23:04:35 <sandal> [False,True,False*** Exception:
23:04:45 <nornagon> :O
23:04:57 <mauke> sandal: did you :reload?
23:04:59 <sjanssen> sandal: maybe you need to :reload ?
23:05:22 <allbery_b> hm, yes, I just got that too
23:05:39 <sandal> no... it fails in my tests
23:05:51 <sandal> well
23:05:54 <nornagon> then something's wrong with your tests
23:05:55 <sandal> throws an erro
23:05:58 <sandal> *error
23:06:05 <nornagon> because your implementation is identical to map's
23:06:07 <sandal> nornagon: I also tried ghci
23:06:26 <sjanssen> sandal: you must be doing something subtly wrong
23:06:41 <sjanssen> are you certain that your file contains exactly what you pasted earlier?
23:06:52 <allbery_b> ah.  works with defs in a file;; not with "let" in ghci
23:07:05 <allbery_b> at a guess, ghci can't combine "let"s
23:07:10 <nornagon> > let map f [] = [] ; map f (x:xs) = f x : map f xs in map (+1) [1,2,3]
23:07:10 <nornagon> [2,3,4]
23:07:16 <nornagon> works for me
23:07:20 <allbery_b> no, as in:
23:07:32 <allbery_b> *Prelude> let my_map p_ [] = []
23:07:35 <sandal> Prelude> let my_map f []  = []
23:07:35 <sandal> Prelude> let my_map f (x:xs) = f x : my_map f xs
23:07:35 <sandal> Prelude> my_map Char.isUpper "fOo"
23:07:35 <sandal> [False,True,False*** Exception:
23:07:40 <nornagon> oh, obviously
23:07:48 <allbery_b> right, that
23:08:00 * allbery_b can't cut&paste with curent setup, it's that or working keyboard :/
23:08:01 <mauke> duh
23:08:14 <sjanssen> sandal: join those lines, like nornagon's example
23:08:15 <mauke> sandal: two "let"s, two definitions
23:08:21 <nornagon> how's ghci supposed to work out you meant that that other scope is actually intended to be combined with the current scope?
23:08:25 <sandal> gotcha
23:08:28 <sjanssen> sandal: the second let throws out the old definition
23:08:47 <sandal> but i do not have these in my tests
23:08:54 <sandal> and they have the same error
23:09:04 <sjanssen> nornagon: it'd be annoying if ghci tried to do that sort of magic
23:09:27 <allbery_b> yeh, combining them works
23:09:53 <sandal> Prelude> my_map f (x:xs) = f x : my_map f xs
23:09:53 <sandal> <interactive>:1:16: parse error on input `='
23:10:02 <sandal> It's annoying it doesn't handle multi lines!
23:10:02 <sandal> ;)
23:10:14 <allbery_b> let my_map _ [] = []; my_map f (x:xs) = f x:my_map f xs
23:10:47 <sandal> that works
23:11:43 <sjanssen> sandal: it is considered best practice to write your defn's in a file, and then load that file in your favorite interpreter
23:11:54 <sandal> sjanssen: and that sucks :)
23:12:08 * sandal misses irb
23:12:40 <allbery_b> ghc-lib + Shellac :)
23:12:40 <sjanssen> sandal: once you're done with cutting/pasting code from tutorials, I don't think it will get in your way very often
23:12:43 <sandal> i think that's considered an interpreter that doesn't want to read more than one line, not intending to be rude
23:12:49 <sandal> sjanssen: it will.
23:13:08 <sandal> i'm used to writing entire classes interactively in ruby
23:13:19 <sandal> and being able to execute bits of my history
23:13:26 <sjanssen> how do you get them out of the interpreter?
23:13:37 <sjanssen> the classes you've written, that is
23:13:43 <sandal> Just print out the history from line m to n
23:14:36 <sandal> and I am mostly writing these on my own. not cutting and pasting
23:16:00 <bd_> ?paste
23:16:07 <bd_> aw
23:16:14 <mbishop> easier to just write in a text file, and :l thefile from hugs/ghci
23:16:19 <allbery_b> bot's down, cale is updating it
23:16:20 <sjanssen> lisppaste2: url
23:16:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:16:33 <mgsloan> bah, this is why ghci sucks
23:16:46 <allbery_b> or run ghci within emacs
23:16:54 <lisppaste2> bd_ pasted "trouble with comonads and 2-d cellular automata" at http://paste.lisp.org/display/34722
23:16:57 <Cale> I don't understand what's so hard about putting definitions in a text file.
23:17:20 <mgsloan> nothing, its just inconvenient and counterintuitive for new people
23:17:36 <bd_> I'm trying to find the right way to do a 2-dimensional cojoin sort of thing... ending up with something which makes no sense at all :)
23:17:41 <sjanssen> sandal: I can't imagine working like that.  Diff'rent strokes for diff'rent folks, I suppose
23:18:12 <sandal> Yeah, well I usually use a combination
23:18:21 <sandal> there is nothing wrong with loading a file
23:18:31 <sandal> like, you can easily do that with irb too
23:18:43 <sandal> but if I'm writing a damn two line function
23:18:47 <sandal> I need a file?
23:18:49 <sandal> That's insanity
23:18:58 <Cale> meh
23:18:59 <mgsloan> i mostly want ghci to take declarations so that i can mess with less-trivial parts of the langauge without making a dummy file, doing the old save/:reload cycle
23:19:00 <sjanssen> sandal: or a ;
23:19:02 <bd_> sandal: with ghci you can do let thing = thing
23:19:10 <sandal> yep, which runs one line :)
23:19:14 <Cale> Think of ghci as a debugger
23:19:34 <sandal> I'm sorry, I'm just used to having a more friendly interactive environment
23:19:40 <bd_> sandal: I suppose, but anything you can do with layouts you can do with { ; }...
23:19:43 <Cale> I could do without let even.
23:19:56 <Cale> (and did, for quite a while)
23:19:56 <sandal> bd_: as long as you do it with one line
23:20:17 <sjanssen> sandal: all programs in Haskell can be written in one line
23:20:20 <bd_> sandal: *Main> let f 1 = 2; f 2 = 1
23:20:26 <sandal> >> def foo(a)
23:20:26 <sandal> >>   a + 1
23:20:26 <sandal> >> end
23:20:26 <sandal> => nil
23:20:26 <sandal> >> foo(2)
23:20:28 <sandal> => 3
23:20:30 <bd_> oh, I see
23:20:31 <sandal> what's wrong with that>?
23:20:41 <sjanssen> ; is like a virtual newline, and { } is indentation
23:20:44 <bd_> unfortunately haskell's grammar makes that difficult to do sanely
23:20:53 <Cale> evens = 0 : map (+1) odds
23:20:56 <bd_> since you won't when to commit the statement until you see the next line
23:20:57 <sjanssen> bd_: I'd say impossible
23:21:01 <Cale> odds = map (+1) evens
23:21:10 <mgsloan> how do we do data types then? class declerations? instances?
23:21:20 <bd_> in fact, here's an example of ambiguity:
23:21:20 <sandal> <shrugs> Okay, I spose that makes sense then
23:21:24 <allbery_b> commit on a blank line
23:21:25 <bd_> f 4 <newline>
23:21:27 <sjanssen> you'd have to introduce some special terminator key
23:21:30 <bd_> is this invoking a function?
23:21:33 <bd_> or is it defining one?
23:21:39 <sandal> sure, why not have one
23:21:45 <bd_> the next line might be | foo = Bar
23:21:53 <bd_> or it might be putStrLn "Hello world!"
23:21:54 <sandal> ruby's is \, but it's only needed in ambiguities
23:22:11 <allbery_b> actually I'd use a submode for entering definitions
23:22:13 <mgsloan> bd - alright, so it depends on the stuff before.  Same with tons of stuff in other lagnauges
23:22:20 <allbery_b> :def
23:22:24 <allbery_b> enter your definitions
23:22:25 <allbery_b> :end
23:22:29 <bd_> mgsloan: *and* the stuff after
23:22:45 <sjanssen> sandal: with all the cases you'd need to type it, the interaction would degenerate into the same experience as switching to/from an editor
23:22:58 <mgsloan> example?
23:23:01 <sandal> okay, so the real issue is
23:23:06 <bd_> mgsloan: I gave one above :)
23:23:09 <sandal> We're dealing with a very different grammar than ruby
23:23:14 <sandal> I can respect that.
23:23:23 <sandal> But it's not like that doesn't suck :)
23:23:25 <mgsloan> that just depends on if you're within a do
23:23:33 <mgsloan> something that's before
23:23:33 <bd_> mgsloan: no, that was toplevel
23:23:40 <bd_> I'll paste an example
23:23:44 <sandal> It has many benefits outside of the interactive environment i'm sure
23:23:47 <Cale> If something is longer than a line, wouldn't you probably want to keep it?
23:23:50 <allbery_b> although the question then becomes what to do the *second* time you do that:  merge them replacing older definitions?  what if you have a syntax error?  what if you intoduce a tyep conflict?
23:23:51 <mgsloan> oh, you mean mixing expressions and declerations
23:24:14 <mgsloan> I'd think that you'd use, say, shift-enter to maintain the same decleration/expression
23:24:20 <sjanssen> lisppaste2: url
23:24:20 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
23:24:26 <sandal> you folks must not explore the language much through ghci
23:24:32 <mgsloan> with the side effect of auto-indentation
23:24:33 <allbery_b> (same thing came up the other day when someone asked about ghci doing partial reloads)
23:24:34 <sandal> see i mean, with irb, I live in it
23:24:41 <mgsloan> sandal - i want to.
23:24:42 <ray> sandal: i do all the time
23:24:52 <sandal> and yeah, if something is saveable, I just save it
23:24:53 <lisppaste2> bd_ pasted "ambiguity example" at http://paste.lisp.org/display/34723
23:24:55 <mgsloan> ray - you can, but its very limited
23:25:02 <bd_> mgsloan: take a look at that paste
23:25:03 <sandal> but a lot of times, I'm exploring
23:25:04 <ray> i do the editor thing
23:25:19 <lisppaste2> sjanssen pasted "tricky parsing" at http://paste.lisp.org/display/34724
23:25:23 <bd_> if I have to switch modes anyway, I'd like something where I can correct typos easily :)
23:25:26 <allbery_b> sandal:  another complication is type inference.  if I don;t assign type signatures to everything then a definition later on can change the type inferred for an earlier one
23:25:30 <mgsloan> bd_ - the layout rule determines that
23:25:40 <sandal> I mean, I'm complaining, but I have <C-i> mapped to ghci % in vim right now :)
23:25:43 <bd_> mgsloan: does it?
23:25:52 <mgsloan> yes
23:26:13 <bd_> oh, hm
23:26:17 <mgsloan> 'f 6' is not within f x
23:26:19 <sandal> so it's not like I figured out how to keep stuff in a file
23:26:38 <mgsloan> give it a few spaces in front, and it would be
23:26:39 <bd_> mgsloan: actually
23:26:42 <bd_> mgsloan: ghci accepts it :)
23:26:42 <sandal> i'm just saying, line editing would be nice, but mentioning the grammer / type inferences makes a lot of sense to me
23:26:47 <bd_> mgsloan: modulo the tpye error
23:26:49 <sjanssen> mgsloan: in bd_'s example, you have to look at a potentially infinite number of lines after "f 6" to see whether it's a defn. or application
23:27:05 <mgsloan> heh, lazy source stream...
23:27:12 <sandal> though, i still bet you can find tricky ways to do it
23:27:23 <sjanssen> if we're speaking about an interpreter that accepts both definitions and expressions
23:27:25 <sandal> I mean, why can't you just say, a line isn't done until I say it is?
23:27:28 <mgsloan> why, I mean, how could an application just be sitting in nowhere
23:27:45 <mgsloan> so? use shift-enter to continue entering the same expression/decl
23:28:15 <sandal> right, that'd be nice mgsloan
23:28:22 <mgsloan> sandal - you can, with ;, but then the code you're entering is one line :)
23:28:29 <sjanssen> sandal: that is theoretically possible.  Having said that, please do not ask me to program such a beast :)
23:28:29 <allbery_b> console applications don't grok shift-enter as different from enter
23:28:44 <ray> my main problem with ghci is the freebsd port's readline issue
23:28:47 <sandal> ; is for C and perl
23:28:48 <sandal> :)
23:28:49 <mgsloan> darn
23:28:56 <ray> and that's all the port's fault really, so i won't complain here
23:29:32 <mgsloan> i'd just ignore multiline then
23:29:52 <mgsloan> don't really need it.  I suppose it would be nice for experimenting with the layout rule
23:30:07 <sandal> mgsloan: I dislike the layout rule too :)
23:30:10 <allbery_b> ray: http://www.haskell.org/pipermail/haskell/2006-December/018954.html
23:30:19 <mgsloan> oh, layout rule is nice though :)
23:30:24 <sandal> but i mean, if I have so many nice things to say about my experience on my first day
23:30:26 <sjanssen> sandal: I guarantee you'll learn to love layout
23:30:29 <ray> allbery_b: i think you linked me to that earlier today, already :)
23:30:29 <sandal> I might as well complain a little too
23:30:38 <sandal> sjanssen: I highly doubt that
23:30:38 <allbery_b> also, ports/107380
23:30:44 <sandal> I hate it in python and I'll hate it her
23:30:46 <allbery_b> I mentioed it but provided no link
23:30:46 <sandal> *here
23:30:49 <sjanssen> sandal: what's the issue?
23:30:55 <ray> hm, then i guess i found it myself
23:30:56 <mgsloan> ours is much better than python's
23:30:57 <sandal> It's pointless and silly
23:31:03 <sjanssen> Haskell's layout rule is much more flexible
23:31:04 <sandal> A smarter parser is better
23:31:07 <mbishop> heh well haskell's layout and python's layout arent' the same
23:31:09 <mgsloan> it's pretty and nice
23:31:12 <mbishop> personally I like haskells
23:31:18 <ray> python's layout is just indentation
23:31:23 <sandal> sjanssen: yes, it's good to have the {;} option
23:31:23 <sjanssen> in fact, I don't even know Haskell's layout rule, because it's so natural
23:31:33 <mgsloan> yep, I'm fuzzy on the details
23:31:37 <ray> but they make you use both the layout and the colon, which sucks
23:31:41 <sandal> sjanssen: Yeah, but I'm learning them because it's not natural :)
23:31:43 * allbery_b finds haskell's layout rule liveable, whereas python's is just annoying
23:31:49 <sandal> yeah that is silly.
23:31:51 <mgsloan> but I pretty much never get in trouble with it
23:31:52 <mbishop> basically all haskell cares is that your expressions line up :P
23:32:01 <sandal> Maybe the trouble for me was
23:32:13 <sandal> it didn't bite me because I generally format my code decently
23:32:18 <sjanssen> the report says "Write what looks correct" in that section, as far as I know :)
23:32:19 <sandal> but then it jumped out and surprised me
23:32:32 <Cale> hrm, apparently I need a newer base package.
23:32:36 <sandal> if that's the case, I'm sure once i get past the details, it won't be a big deal
23:32:56 <sjanssen> sandal: did if/then/else bite you?
23:33:04 <allbery_b> cale: for what?
23:33:04 <sandal> I haven't used them :)
23:33:14 <sandal> using |
23:33:17 <allbery_b> I thought lbot worked with 6.4 with the 6.4 cabal file and fps 0.8
23:33:30 <sandal> a do declaration bit me, actually
23:33:33 <allbery_b> or with 6.6 and the 6.6 cabal file, but no plugins
23:33:36 <Cale> for regex-base-any, which is required for regex-compat, which lambdabot requires
23:33:42 <mbishop> layout bit me (especially do notation) until I realised what I had to do (which was basically just make the expressions match, and make else indented a space or two more than the opening if :P
23:34:00 <allbery_b> oh, the regex changes to ?quote.  *sigh*
23:34:02 <sandal> Yeah, which i suppose is good practice anyway
23:34:12 <sandal> I do not like enforced practice though
23:34:27 <sandal> which is my primary beef with having to stick definitions in a file and whatnot
23:34:32 <sandal> I like to choose my style
23:34:33 <ray> there's always semicolons
23:34:43 <sandal> with the damn semi-colons!
23:34:45 <sandal> :)
23:34:45 <mbishop> sandal: sounds like you should learn lisp :P
23:35:03 <sandal> Ruby is good enough
23:35:10 <sandal> But yeah, eventually, I should
23:35:22 <sandal> I know the little bits of it from like, Casting Spels
23:35:25 <allbery_b> someone did do monads in ruby at one point :)
23:35:37 <sandal> yeah, there are a few implementations out there
23:35:44 <ray> has anyone done monads in fortran, though
23:35:58 <mbishop> there's monads in scheme and common lisp too :P
23:36:04 <allbery_b> *snerk*
23:36:11 <sjanssen> can fortran simulate lambda?
23:36:19 <mgsloan> hey, I stick my monads wherever i want
23:36:21 <sjanssen> I think that is required
23:36:45 <ray> in theory!
23:36:57 <Cale> hmm, is lambdabot supposed to work with GHC 6.6 now?
23:37:01 <sandal> silly my_map isn't quite working in my tests
23:37:04 <sandal> yuck
23:37:07 <Cale> I could just install that if it is.
23:37:17 <allbery_b> hm, ghc6.4 has Text.Regex, which I think is what the regex-compat emulates
23:37:50 <allbery_b> lbot works with 6.6, but without plugins until dons finishes fixing hs-plugins
23:38:19 <allbery_b> sandal: not working how?
23:38:41 <sandal> http://pastie.caboo.se/32266
23:38:43 <sjanssen> Cale: yes, dons migrated to 6.6
23:39:02 <sjanssen> Cale: the most recent changes require an extra library or two
23:39:15 <sandal> type error
23:39:25 <sandal> Bool -> Bool -> t, against Bool
23:39:37 <sandal> durr
23:39:40 <sandal> commas
23:40:02 <sandal> got it
23:40:03 <allbery_b> yeh, just noticed that
23:40:15 <allbery_b> maybe you *should* switch to Lisp :)
23:40:19 <sandal> rofl
23:40:26 <mgsloan> as far as logic goes, I can't see how ((not x) or y) is x -> y
23:40:33 <sandal> [True True False] isn't even valid ruby
23:40:36 <sandal> i'm just tired I think
23:41:04 <sandal> wicked cool how easy it is to define map
23:41:14 <mgsloan> (ignore my last comment unless you know about formal logic... this isn't really super haskell relevant)
23:41:19 <ray> yeah
23:41:29 <sjanssen> sandal: want to see the one-liner?
23:41:40 <sandal> sure
23:41:55 <mgsloan> my_map = map
23:41:58 <sjanssen> @type \f -> foldr (\x xs -> f x : xs) []
23:42:03 <allbery_b> heh
23:42:11 <xerox> > [(x,y,(not x) || y) | x <- [True,False], y <- [True,False]]
23:42:15 <sandal> oh, that's just what I was writing in ruby
23:43:15 <sjanssen> shorter: \f -> foldr ((:) . f)
23:43:23 <sandal> >> def my_map(list); list.inject([]) { |a,e| a + [yield(e)] }; end
23:43:23 <sandal> => nil
23:43:23 <sandal> >> my_map([1,2,3]) { |x| x + 1 }
23:43:23 <sandal> => [2, 3, 4]
23:43:40 <mgsloan> [(True,True,True),(True,False,False),(False,True,True),(False,False,True)]
23:43:51 <sjanssen> shortest: foldr . ((:) .)
23:44:27 <sandal> sjanssen: that get's a little low on readability :)
23:44:30 <mgsloan> Ok, so if the first type is 'true' in some way, and the second type is false, then the result is false.... if the first type is 'false' in some way, then the result is still true
23:44:33 * mbishop likes to believe LOC is linked to penis size
23:44:37 <nornagon> heh
23:44:46 <sjanssen> sandal: and it's wrong :(
23:44:52 <mgsloan> whatever that 'result' might be
23:44:52 <nornagon> inversely proportionate, mgsloan
23:44:53 <nornagon> er
23:44:54 <nornagon> mbishop:
23:45:16 <nornagon> curses replacement in 150 loc -- HOTT
23:45:17 <sjanssen> flip foldr [] . ((:) .) -- is correct
23:45:33 <nornagon> ?unpl flip foldr [] . ((:) .)
23:45:44 <mgsloan> so i guess haskellers are pretty well off then :)
23:46:12 <allbery_b> mgsloan: remember in formal logic implication only works in one direction, so x -> y only asserts that y must be true when x is true, it says nothing about the case when x is false
23:46:26 <allbery_b> which is what (not x) or y says
23:47:18 <mgsloan> does it? it's defined when x is false
23:47:28 * allbery_b thinsk that's right... it's ben a while
23:47:50 <mgsloan> ah, well, I'm just learning this off of MIT's open course stuff
23:47:58 <sjanssen> False `implies` _ = True
23:48:07 <allbery_b> the table for -> is that it's false only when x is true and y is false
23:48:09 <mgsloan> or attempting to anyway, seems like really overcomplicated boolean ops :)
23:48:23 <sjanssen> True `implies` p = p
23:49:44 <sandal> Anyway, off to bed.  Here are the first 9 exercises from YAHT:
23:49:45 <sandal> http://pastie.caboo.se/32270
23:49:53 * allbery_b notes that it makes sense if you don't try to apply human logic to it, but "implies" carries that kind of baggage so it's difficult to look at it the right way
23:49:55 <mgsloan> a table matching and would make more sense to me - I don't understand why the cases which it 'says nothing about' are True
23:49:57 <sandal> thank you all for your help today
23:50:44 <allbery_b> think of a true result as saying "this is possible" and a false as "this is not possible"
23:51:12 <mgsloan> ah, got it i think then...
23:51:13 <allbery_b> if x is false, y can possibly be either true or false (so result is true for both) but if x is true, y must also be true
23:51:35 <allbery_b> so you get false only for x true, y false
23:51:46 <mgsloan> so iff is like and
23:51:52 <mgsloan> and if is like ->
23:53:07 <glguy> is there a better version of: deleteBy (const f) undefined xs
23:53:18 <mgsloan> if one thing, then another, else this statement is meaningless
23:53:38 <mgsloan> allbery_b / sjanssen - thanks for the help, I get it, i think
23:53:45 <bd_> glguy: filter (not . f) xs ?
23:53:54 <glguy> bd_: deleteBy only deletes the first
23:53:58 <bd_> oh
23:54:15 <bd_> <-- was only looking at the type there... :)
