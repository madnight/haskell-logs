00:00:52 <dons> the goal should be to get a clean, working and solid patch into the main branch
00:00:52 <sorear> interestingly, when (using darcs unrecord in a branch) I flattened all my changes, the giant patch (with all backtracking removed) was half the size of the current patch bundle.
00:00:56 <dons> without breaking anything
00:00:59 <benja_> know what you are ding! know what you are dong! always know what you are doing or you will go plong(k)!
00:01:09 <dons> heh
00:01:48 <sorear> dons: the GHCi debugger prints closures as '_t42'
00:02:12 <sorear> (not really like it matters specifically to you)
00:02:15 <dons> ok, haven't used it. hat would be the soln then
00:03:33 <thelsdj> is there any builtin function like 'take' but returns list until a given condition is met on an item? (i just wrote my own 'takeUntil' but wondering if i'm missing another way)
00:04:10 <sorear> Another thing that came for free out of my first try at separating IRC from the core, was two 'protocols' readline and rc-file, thus obviating the need for offline mode and State/passwd.
00:04:20 <sorear> ?type takeWhile
00:04:21 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:04:29 <sorear> ?type Data.List.takeWhile
00:04:30 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
00:04:35 <thelsdj> yep thats it
00:04:44 <sorear> > takeWhile (<'m')  "zyzxabg"
00:04:45 <lambdabot>  ""
00:04:48 <sorear> > takeWhile (>'m')  "zyzxabg"
00:04:50 <lambdabot>  "zyzx"
00:04:59 <sorear> > span (>'m')  "zyzxabg"
00:05:00 <lambdabot>  ("zyzx","abg")
00:05:00 <mauke> ooh, kirby!
00:05:46 <sorear> mauke: make sure the channel you meant to say that to received it
00:05:47 <thelsdj> sum (filter even (takeWhile (\x -> x <= 1000000) fibs))
00:05:48 <thelsdj> works great
00:06:51 <sorear> thelsdj: \x -> x <= 1000000  is better written as   (<= 1000000)
00:07:09 <sorear> that's a "section"
00:07:17 <thelsdj> ah true
00:07:18 <mauke> (>'_') is totally a kirby face
00:07:36 <thelsdj> ha that is kirby, i missed it
00:08:03 <sorear> i did too (sorry for false reminder)
00:11:28 <vegai> http://skindeep.logankoester.com/overcoming-coders-block
00:11:30 <lambdabot> Title: Skin Deep - Fathoming beauty through life, code and design on the web. Â» Blog A ...
00:13:12 <vegai> there's a real, bad problem. Sadly, the advice on that page aren't good
00:13:23 <dons> sorear: ok, that removal of offline mode sounds useful
00:13:27 <dons> i hope your testing...
00:13:35 <dons> we might want to set up some unit testing at some point...
00:16:20 <ytrewq2> does anyone get (the 'impossible' happened) when they start ghci through emacs?
00:16:57 <sorear> I've done minimal testing (on take 1) fairly often... take-1 currently always runs the readline interface, and shuts down when that interface is ^D-ed
00:17:43 <sorear> so I use ?irc-connect fn chat.freenode.net sorear-lambdabot ; ?msg fn:nickserv identify foobar  to enter 'online mode'
00:18:02 <sorear> (note that is a fake password)
00:23:45 <Cale> vegai: yeah, I just modded the article down, like most of the articles which aren't directly about programming techniques :)
00:24:11 <vegai> now that's just silly :)
00:24:18 <Cale> If an article doesn't have any snippets of source code in it, I'm probably going to mod it down.
00:25:58 <Cale> (on programming reddit)
00:26:30 <Cale> Not always, but there's a pretty strong correlation there
00:27:12 <vegai> my silly thing is that I downmod every article that is a pdf, or any article that only has documentation et al as ps/pdf
00:27:38 <dons> some pdfs are good though. a lot of very high quality content is only available via pdf..
00:27:43 <dons> particularly new research
00:27:46 <Cale> I love pdfs
00:27:56 <dons> i'll probably submit some pdfs during POPL
00:28:12 <Cale> They're usually nicer to look at than HTML.
00:28:37 <ytrewq2> pdfs would be better if there were ways to pass around URLs that pointed to the interior content...
00:28:37 <Cale> because they've usually been produced by LaTeX, and hence have undergone proper typesetting
00:28:47 <sorear> Cale: thats what I was going to say :)
00:29:00 <vegai> I just cannot read pdfs, at least not for fun
00:29:12 <vegai> (which includes learning)
00:29:23 <dons> if i was writing for the web though, i'd go with embedded latex math as .png
00:29:40 <dons> since as vegai says, pdf isn't what everyone wants to read, for a number of reasons
00:29:42 <Cale> TeX still has a few areas where it could be improved, for example, in avoiding columns of aligned whitespace between words in adjacent lines of text
00:30:08 <Cale> (that is, unintentional alignment of that sort)
00:30:29 <sorear> dons: *please* use alt text!  I'm an elinks user.
00:30:35 <benja_> @hoogle liftIO
00:30:35 <lambdabot> Control.Monad.Trans.liftIO :: MonadIO m => IO a -> m a
00:30:36 <Cale> But that's getting ultrapicky
00:30:58 <dons> we're off and running on 07 in the channel stats now, http://www.cse.unsw.edu.au/~dons/irc/
00:30:59 <lambdabot> Title: Haskell IRC Activity
00:31:07 <dons> sorear: don't worry, i live in w3m...
00:32:33 * Cale squints at vincenz.
00:32:55 <Cale> beat me by 1027 lines
00:33:28 <Cale> otoh, I used 132327 more words than he did
00:33:47 <dons> yeah, i think words count more than lines :)
00:34:31 <calvins_> happy new year to the best IRC channel on all the internets!!
00:34:41 <Cale> I wonder who has the largest words/line ratio?
00:34:45 <dons> Cale: hehe :)
00:34:57 <dons> calvins_: ^^
00:35:25 <sorear> I have a pecualiarly significant and extraordinarily irritating predisposition to the employment of particularly elongated words, which unfortunately depresses my achieved word count, especially in formal writings.
00:35:46 <mauke> Most used words: 1) Haskell  2) think  7) monad  9) function
00:36:00 <dons> yay
00:36:23 <thelsdj> hmm... [(a -> b -> b)] -> a -> b -> b
00:37:06 <dons> mm, a fold?
00:37:13 <psykotic> sorear: there's something to be said for sticking to mostly anglo-saxon diction.
00:37:24 <benja_> it speaks for #haskell that lambdabot is the most aggressive person here
00:37:29 <dons> heh
00:38:24 <benja_> dcoutts_ has quite a potty mouth. 0.0% words were foul language.
00:38:25 <benja_> Pseudonym also makes sailors blush, 0.0% of the time.
00:40:09 <Cale> :t \xs x -> foldr (\f g -> f x . g) id xs
00:40:10 <lambdabot> forall t a. [t -> a -> a] -> t -> a -> a
00:40:39 <Cale> or
00:41:26 <Cale> :t \xs x -> foldr (.) id (map ($ x) xs)
00:41:27 <lambdabot> forall a a1. [a1 -> a -> a] -> a1 -> a -> a
00:41:43 <psykotic> i foresee someone pushing lambdabot to the top of the obscenity rankings.
00:42:09 <Cale> I forsee that person being banned.
00:42:23 <Cale> :)
00:42:25 <psykotic> :)
00:42:29 * psykotic cowers in fear.
00:43:00 <dons> hehe
00:43:15 <mauke> repeat ("sh" ++ "it")
00:43:21 <dons> ?where obscenity
00:43:21 <lambdabot> I know nothing about obscenity.
00:43:30 <lambdabot> Wouldn't it be more civil just to remove their ?msg priviledges?  <plead plead>?
00:43:41 <dons> hehe. perhaps...
00:43:51 <dons> removing @msg altogether ..
00:44:20 <Cale> @whowasthat
00:44:21 <lambdabot> Unknown command, try @list
00:44:32 <Cale> :)
00:44:38 <sorear> well, there needs to be a reasonable replacement for @msg nickserv identify ...
00:44:55 <sorear> Cale: privmsg's are logged, @last lambdabot might do
00:45:05 <sorear> (somehow @last never works for me)
00:46:07 <Randroid> Wow. I expected #haskell to be dead as a doornail. I mean, just a couple of hours ago I was lying in a ditch in a pool of my own vomit, listening to the New Year fireworks going off.
00:46:20 <mr_tenor> instead of coding?
00:46:22 <syntaxfree> Been there, done that.
00:46:28 <benja_> tsss
00:46:48 <Randroid> Just kidding, actually. I didn't do crap this year. Not a big New Years Eve guy.
00:47:07 <psykotic> i spent new year's in an airplane over siberia. not much fun...
00:47:13 <Randroid> I *did* write code, but it was Ruby, not Haskell.
00:47:41 <mr_tenor> i've been trying ruby on for size... the syntax and whitespace rules feel awkward
00:47:56 <Randroid> mr_tenor: What whitespace rules?
00:48:07 <glguy> what about the complete lack of types?
00:48:16 <benja_> Randroid: it's good that we're tolerant and don't call writing Ruby code doing crap =]
00:48:22 <Randroid> hahha
00:48:52 <mr_tenor> randroid: well, a "do" needs to start on the same line as the thing owning the block, for one.
00:49:04 <mr_tenor> other stuf was getting to me, but i got sidetracked a few months ago
00:49:30 <Randroid> Well, does Haskell have a full fledged web app framework like Ruby on Rails or ASP.NET or even something like that abomination known as PHP?
00:49:44 <bakert> i like ruby.  do i get kicked for that?  i really don't like rails though.
00:49:58 <dons> psykotic: you've landed now?
00:50:06 <bakert> of course i don't actually understand haskell.
00:50:11 <Randroid> bakert: I didn't care much for Rails until recently. There's still a lot to gripe about.
00:50:18 <psykotic> dons: yeah
00:50:38 <dons> Randroid: WASH, and HAppS. but you'd have to define 'fully fledged'
00:50:39 <bakert> can you do pattern matching in guards on record syntax?
00:51:10 <dons> you can pattern match on records
00:51:13 <Randroid> dons: Yeah, that's a bit vague. I guess I'll take a look at those and make my own decision.
00:51:22 <benja_> hmm, let's see, I used to be a Python person. need to hold up some dignity here...
00:51:28 * benja_ kicks bakert for liking ruby
00:51:29 <Randroid> dons: I mean, 'fully fledged' is a bit vague.
00:51:34 <dons> there's a company in SF doing commercial stuff in WASH
00:51:37 <mr_tenor> the vim ruby plugin is really slow too :(
00:52:09 <dons> this was a demo of the WASH commercial wrok, iirc, http://www.braintreehemp.com.au/
00:52:20 <dons> notice the 'WASHsubmit' links
00:52:26 <benja_> bakert: you can do pattern matching on records everywhere you can do pattern matching :)
00:53:07 <Randroid> dons: Hm. Very odd-looking links, too.
00:53:28 <dons> that's tunable, of course :)
00:53:32 <dons> i think they're just using the defaults
00:53:46 * benja_ should learn more about Rails someday. but not today, and not tomorrow :)
00:54:17 <Randroid> dons: Did you notice the enormous base64 hidden field? I assume it's base64. Reminds me of ASP.NET's ViewState. Perhaps it has the same purpose.
00:55:51 <jcreigh> so...does that site do anything that couldn't be done with static HTML?
00:56:13 <nornagon> haha, i love learning haskell. It lets me feel vastly superior to all the python learners }:D
00:56:41 <thelsdj> i like making unreadable haskell code, and hoping it does what i want it to
00:56:49 <nornagon> :D
00:56:53 <thelsdj> head (filter (all (== 0)) (map (\y -> map (\x -> y `mod` x) [1..20]) [1..]))
00:57:05 <nornagon> :t all
00:57:06 <lambdabot> forall a. (a -> Bool) -> [a] -> Bool
00:57:19 <nornagon> ah, nifty
00:57:21 <benja_> @pl head (filter (all (== 0)) (map (\y -> map (\x -> y `mod` x) [1..20]) [1..]))
00:57:21 <lambdabot> head (filter (all (0 ==)) (map (flip map [1..20] . mod) [1..]))
00:57:30 <sorear> thelsdj: there are some good examples of unreadable code on the wiki
00:57:47 <thelsdj> this doesn't appear to ever finish so i'm not sure it actuallyd oes what i want it to
00:58:00 <nornagon> > head (filter (all (== 0)) (map (\y -> map (\x -> y `mod` x) [1..20]) [1..]))
00:58:02 <thelsdj> and doesn't actually give me the answer
00:58:04 <lambdabot> Terminated
00:58:12 <thelsdj> still needs a little work
00:58:21 <nornagon> evidently :P
00:58:27 <jcreigh> nornagon: while that may be true, I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement for your entire program.")
00:59:03 <thelsdj> its supposed to be a stab at solving euler project problem #5
00:59:05 <bakert> jcreigh, likewise - people keep replacing bits of my program with four letters!
00:59:09 <Randroid> While I like Haskell far better than Ruby or Python, I find that Ruby and Python programmers are as a whole much better than the usual corporate dillholes I work with. I mean, I write C# code all day for a living, and even in that abortion of a language I can code circles around my coworkers.
00:59:34 <sorear> http://haskell.org/haskellwiki/Obfuscation, or my personal try, http://haskell.org/haskellwiki/Short_theorem_prover (only the first part)
00:59:35 <lambdabot> Title: Obfuscation - HaskellWiki
01:00:11 <benja_> note in this context that the blub paradox states that if there's something better than haskell, it won't be discovered on this channel :)
01:00:28 <bakert> "only the first bit".  you mean you don't like the section on foogomorphisms???? ;)
01:00:31 <mauke> > foldl1 lcm [1 .. 20]
01:00:32 <lambdabot>  232792560
01:00:38 <mauke> PROBLEM SOLVED
01:00:48 <thelsdj> ha
01:00:49 <sorear> ClaudiusMaximus: wow that's stupid, the *entire history* of #haskell fits in 40MB for me
01:01:02 <integral> benja_: I guess that means epigram isn't the future :-(
01:01:27 <bakert> So, pattern matching on a record in a guard clause.  Help a newbie out.  If I have this record:
01:01:31 <Randroid> Well, benja_, I've found that while I like Haskell's structure and syntax better than any other language, Ruby and .NET seem to be a bit more mature in terms of libraries, IMHO.
01:01:32 <sorear> only the first bit == my explanation isn't very well obfuscated
01:01:38 <bakert> data Record = Record { foo :: Int, bar :: String }
01:01:43 <thelsdj> i wonder if my program might have eventually found that answer
01:01:45 <dons> benja_: yeah. we can at least see that epigram and Coq do some things that would be neat in haskell :)
01:01:52 <bakert> how do I get the bar bit out in a pattern match in a guard clause?
01:02:05 <bakert> (say i'm not interested in foo)
01:02:08 <sorear> Record{ bar = b }
01:02:36 <bakert> no space between name and { or is that irrelevant?
01:02:42 * glguy wonders if you can pattern match like that
01:02:59 <dons> not relevant
01:03:06 <dons> yeah, you can pattern match on record fields and name them
01:03:15 <nornagon> jcreigh: heh, i guess that's true :P
01:03:16 <glguy> bar = b? bar == b?
01:03:19 <sorear> that's my pet style, feel free to chose an incompatible one
01:03:27 <sorear> bar = b, one =
01:03:30 <bakert> what if you want to name them the same as they are called?  i guess you can't ...
01:03:32 <dons> useful, since you can add new fields to your type without changing your patterns
01:03:33 <nornagon> the one language where the phds outnumber the idiots 5:1
01:03:38 <sorear> bakert: you can
01:03:45 <sorear> I just like shorter names :)
01:04:36 <bakert> magic, at last my test function works ... now to roll it into the actual program.  thanks!
01:04:43 <sorear> yw.
01:06:37 <nornagon> say, does haskell have sdl bindings?
01:06:41 <nornagon> i guess sdl is C
01:06:43 <nornagon> so 'yes'
01:07:14 <Cale> yes in a stronger sense that someone's actually written those bindings
01:08:17 <dons> check the libraries page on haskell.org
01:08:33 <dons> or ask Lemmih (I think he's the author?)
01:09:55 <glguy> sweet, I learned something new about records today... time for bed
01:11:03 <nornagon> hm, yaht runs out of exercises as it gets towards the end... :(
01:11:18 <nornagon> i.e, the interesting stuff i hadn't already learned from the clean book.
01:14:13 <nornagon> ?where h-99
01:14:13 <lambdabot> I know nothing about h-99.
01:14:26 <nornagon> ?where+ h-99 http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
01:14:26 <lambdabot> Done.
01:17:36 <dons> ?bot
01:18:03 <lambdabot> :)
01:18:22 * sorear takes this as a cue to darcs pull
01:18:53 <dons> :)
01:19:42 <sorear> @help flush
01:19:43 <lambdabot> flush. flush state to disk
01:20:14 <sorear> @help fluhs
01:20:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:20:33 <nornagon> hm
01:20:46 <nornagon> erlang has this neat feature where you can reload code on the fly
01:20:51 <nornagon> without having to restart the app
01:21:01 <nornagon> does haskell have an analogous feature?
01:21:05 <sorear> yeah
01:21:11 <sorear> hs-plugins
01:21:15 <sorear> @help dynload
01:21:16 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:21:17 <integral> hs-plugins, but it's not quite 6.6 ready yet
01:21:20 <sorear> @help load
01:21:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
01:21:24 <nornagon> so why does lambdabot ever need to restart? :)
01:21:26 <dons> yeah, hs-plugins (not quite as sophisticated as erlang though)
01:21:27 <sorear> @list dynload
01:21:27 <lambdabot> No module "dynload" loaded
01:21:42 <sorear> I wonder that too
01:21:59 <dons> the current cabal build system doesn't support the dynamic build way
01:22:23 <dons> or, i just haven't been bothered to build it with hot reloading support for a few months
01:22:36 <nornagon> heh, the topic should be "Get yourself some cognitive dissidents!"... </gibson>
01:22:41 <dons> heh
01:22:53 <sorear> is ?topic-xyz still used?
01:23:02 <nornagon> ?topic-xyz
01:23:03 <lambdabot> Unknown command, try @list
01:23:05 <dons> nah, since you have to op the bot to change it now
01:23:21 <dons> probably still useful in non-#haskell chans
01:23:31 <wolverian> http://doc.gold.ac.uk/~ma503am/alex/hpeano is extremely cool
01:23:34 <lambdabot> Title: Peano curve weaves of whole songs | Alex McLean
01:23:51 <dons> my slashnet bot just went: 20:16  dons> ?uptime
01:23:51 <dons> 20:16  lambdabot> uptime: 2m 3d 7h 47m 7s, longest uptime: 2m 3d 7h 47m 7s
01:23:53 <dons> :)
01:23:55 <sorear> you weren't here
01:24:01 <sorear> ?
01:24:03 <dons> that's yaxu, btw, wolverian
01:24:32 <wolverian> yaxu?
01:25:13 <sorear> how's HWN?
01:25:15 <dons> the nick in this channel of Alex McLean
01:25:19 <wolverian> ah. thanks.
01:25:21 <dons> sorear: good :) should be an issue tomorrow
01:25:28 <dons> sorear: why?
01:25:53 <sorear> It wasn't quite seeming W
01:26:24 <dons> oh, it just missed the week of xmas
01:26:30 <dons> as most other publications do...
01:26:32 <dons> ;)
01:26:41 <sorear> hehe
01:26:47 <dons> last issue was 22nd, iirc
01:26:49 <dons> or 20th
01:33:45 <bakert> what's the list operation for "element number n and all after it"?
01:33:55 <bakert> like the opposite of take
01:33:56 <benja_> bakert: drop
01:33:59 <bakert> thanks!
01:34:03 <benja_> np
01:37:06 <Chad> any binary packages for gui toolkits available for ghc6.6 on Windows?
01:37:45 <Chad> everything I can seem to find requires 6.4.x :\
01:46:52 <quazimodo> hullo chaps
01:47:00 <bakert> hello
01:47:06 <bakert> how is notre dame?
01:47:14 <quazimodo> i think its spelled with a k
01:47:26 <quazimodo> kotre dame?
01:47:33 <quazimodo> kooty daym
01:47:56 <bakert> i think the bells have warped your mind quaz
01:48:25 <quazimodo> maybe
01:48:40 <quazimodo> suggest something for me to write in haskell
01:48:49 <quazimodo> im a noob and i cant really think of something useful to write :/
01:49:01 <bakert> i am also a noob and i am writing the card game Kings to Aces
01:49:09 <bakert> (it's like Gin Rummy, but a bit different)
01:49:23 <bakert> in order to find out good tactics with which to beat my mother in law
01:49:34 <bakert> If you are maths-y you might like www.projecteuler.com
01:49:52 <bakert> Or there are the (somewhat boring if you ask me, but I did do about 20 of them) 99 problems in Haskell
01:49:54 <dons> quazimodo: you could try to solve the euler puzzles, or the h99 ones?
01:49:59 <dons> ?where h-99
01:50:00 <lambdabot> http://www.haskell.org/haskellwiki/H-99:_Ninety-Nine_Haskell_Problems
01:50:05 <quazimodo> ERROR
01:50:06 <bakert> snap dons!
01:50:06 <psykotic> dons: have you seen pythonchallenge.com?
01:50:10 <dons> or the ruby quiz puzzles
01:50:18 <dons> ?google Haskell Quiz
01:50:19 <quazimodo> oo
01:50:20 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_Quiz
01:50:21 <lambdabot> Title: Haskell Quiz - HaskellWiki
01:50:24 <quazimodo> this 99 puzzles is from something else!
01:50:28 <dons> psykotic: oh, no? any good?
01:50:31 <quazimodo> ive seen it before
01:50:50 <psykotic> dons: easily the best out there, imo. but part of its charm is that it requires you to use a lot of the standard library..
01:51:15 <dons> ah yes.
01:51:16 <psykotic> it gets insanely difficult once you get to puzzle 15 or so.
01:51:27 <dons> we should have a look at that :)
01:55:19 <psykotic> a lot of the fun of some of the pythonchallenge.com problems is finding out exactly the problems you have to solve
01:55:25 <psykotic> and often there are layers within layers within layers
01:56:39 <psykotic> in a way it's more about puzzle solving that happens to use python and a lot of the python standard library. but i think it's a good way to get people using the language creatively. there are too many navel-gazing puzzles out there...
01:57:58 <goltrpoat> quick observation:  it'd be rather nice if pl supported arrow syntax
01:58:22 <goltrpoat> > pl \f (x, y) -> (f x, f y)
01:58:22 <lambdabot>  Parse error
01:58:26 <goltrpoat> @pl \f (x, y) -> (f x, f y)
01:58:26 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
01:58:28 <goltrpoat> but:
01:58:35 <goltrpoat> > (liftM2 (&&&) (. fst) (. snd)) (*2) (3,5)
01:58:38 <lambdabot>  (6,10)
01:59:13 <goltrpoat> er.  i mean, not the proposed arrow syntax, the stuff in Control.Arrow
01:59:35 <quazimodo> this is a dumb question but how do you guys map out your recursions?
01:59:48 <sorear> what do you mean?
01:59:51 <quazimodo> say for desk checking
01:59:55 <quazimodo> how do you draw it
02:00:09 <dons> hmm?
02:00:12 <psykotic> i don't draw anything, i just think by cases.
02:00:18 <dons> how do you visually represent recursion?
02:00:21 <quazimodo> yep
02:00:23 <sorear> draw?  I work entirely on the screen & my internal blackboard.
02:00:25 <quazimodo> i can sit and figure it out
02:00:38 <quazimodo> just thought it would be a good idea to ask in case there is an example already
02:00:50 <psykotic> i know people who think about recursion in terms of stack unwinding and such, but imo you should try not to do that and instead just focus on reasoning by cases and induction.
02:00:55 <dons> mm, well, Cale has one suggestion (for folds): http://cale.yi.org/index.php/Fold_Diagrams
02:00:59 <lambdabot> Title: Fold Diagrams - CaleWiki
02:01:01 <quazimodo> i think the reason i ask is that for example when we were taught basic desk checking there was a protocol and method making it easier
02:01:01 <bakert> i just do what the Little Schemer taught me (or was it SICP?) -- think of the terminating condition, then think of the one before that.
02:01:17 <dons> yeah, i just think of the base case, and the inductive step
02:01:39 <dons> f [] = ... ; f n = ... f (n-1) ..
02:01:40 <quazimodo> dons, well that is how i was going about it too
02:01:44 * sorear doesn't know about this 'desk checking' thing :(
02:02:07 <dons> what do you mean by 'desk checking'? i've not heard that term before
02:02:10 <quazimodo> sorear, it was taught to us in highschool software , it is just a method to hand check a basic algorithm
02:02:33 <sorear> oh, we use quickcheck here :)
02:02:47 <dons> heh
02:03:14 <psykotic> quazimodo, do you mean running a program by hand on sample inputs?
02:03:25 <sorear> ?check \x -> length ('a':x) == 1 + length x
02:03:27 <lambdabot>  OK, passed 500 tests.
02:03:29 <Cale> Basically, the reasoning you use to understand the evaluation of Haskell expressions is the same as that used to evaluate mathematical expressions. You substitute things according to equations.
02:03:30 <sorear> ?check \x -> length ('a':x) == length x
02:03:31 <lambdabot>  Falsifiable, after 0 tests: ""
02:03:47 <goltrpoat> psyk -- he means checking stuff on paper, methinks
02:03:48 <sorear> ?check \x y -> length (y:x) == 1 + length x
02:03:48 <lambdabot>  Add a type signature
02:03:55 <sorear> ?check \x y -> length ((y :: Char):x) == 1 + length x
02:03:56 <lambdabot>  OK, passed 500 tests.
02:04:00 <psykotic> goltrpoat, that could mean anything :)
02:04:05 <dons> ?check \n -> foldr (const (+1)) 0 [1..n] == (n :: Int)
02:04:07 <lambdabot>  Falsifiable, after 4 tests: -5
02:04:20 <goltrpoat> psyk:  oh, i missed the 'by hand' bit in what you said
02:04:24 <dons> ?check \n -> n >= 0 ==> foldr (const (+1)) 0 [1..n] == (n :: Int)
02:04:25 <lambdabot>  OK, passed 500 tests.
02:04:36 <dons> ?scheck \n -> n >= 0 ==> foldr (const (+1)) 0 [1..n] == (n :: Int)
02:04:37 <lambdabot>   Completed 13 test(s) without failure.  But 6 did not meet ==> condition.
02:05:28 <sorear> It's 2AM, I've got this vague idea like I should sleep...
02:05:41 <Cale> It's 5am, and I have a similar feeling
02:06:52 <quazimodo> sorry i was afk for a sec
02:06:59 <opqdonut> it's 12AM and i have a feeling i should wake up
02:07:02 <quazimodo> yeh to run a procedure by hand
02:18:47 <bakert> because i am getting so many functions with the same names as fields in my records, I'm thinking of prefixing all field names in my State record with s and in my Player record with p.  Is there any other solution that is commonly used?
02:19:15 <bakert> data State = State { sDiscard :: [Card], sRemaining :: [Card], sPlayers :: [Player] }
02:19:21 <bakert> is that just tooooo ugly?
02:19:51 <dons> not too bad
02:20:03 <dons> but you realise that field names are also accessor functions, yeah/
02:20:15 <bakert> ah yes.  that is really horrible.
02:20:32 <dons> oh?
02:20:33 <Oejet> Would making a module be overkill?  S.players,...
02:20:33 <bakert> I don't think i can bear "sPlayers state" and so on
02:20:43 <dons> yeah, players state
02:20:44 <dons> is much nicer
02:20:48 <bakert> Nice idea Oejet
02:20:51 <dons> or maybe State.players s
02:21:01 <dons> where you import the State module qualified
02:21:08 <bakert> a "." in there would definitely be good.
02:21:18 <bakert> yes yes this is much better
02:21:26 <bakert> now i just have to work out how to do it!
02:21:30 <bakert> (newbie alert)
02:21:35 <dons> well, you put your State data type in a new module
02:21:40 <dons> module State where
02:21:53 <dons> data State = State { discard :: [Card],  ...
02:21:57 <dons> then in another module:
02:22:02 <dons> import qualified State
02:22:08 <dons> and then you can refer to State.discard
02:22:10 <dons> and so on
02:22:26 <bakert> All my references to State itself will be State.State, though?
02:22:34 <dons> nope
02:22:50 <bakert> oh?
02:22:50 <dons> ah , you mean in the module that imports State, yes
02:22:52 <dons> unless you:
02:22:55 <dons> import State (State)
02:22:58 <dons> import qualified State
02:23:04 <bakert> that sounds good!
02:23:05 <dons> which gives you the type State unqualified
02:23:14 <dons> and any functoins qualified with State.*
02:23:38 <dons> the Data.Map module is often used this way
02:23:44 <bakert> or perhaps i will put all my record types in a module called Record and have Record.State and Record.Player (har har) and Record.discard and Record.players
02:24:01 <dons> yeah
02:24:02 <bakert> I think your way is neater though
02:24:49 <malebria> Good morning.
02:24:55 <bakert> Can I put more than one module in the same file or must they be in separate files?
02:27:41 <therp> must be separated
02:30:08 <bakert> thanks therp.
02:30:17 <bakert> Is "default" a reserved word of some type?
02:30:31 <therp> default is a keyword at least on toplevel
02:30:38 <bakert> hmm drat.
02:30:51 <therp> if it's reserved, I'm not sure. you'd have too look at the haskell report
02:30:57 <bakert> what's a good synonym for default?
02:31:10 <dons> dflt?
02:31:19 <dons> :)
02:31:43 <bakert> !
02:32:39 <bakert> hmm ... online dictionaries/thesauruses think default has a negative connotation that doesn't apply to computer scientists version of the word
02:33:29 <therp> I recently used the term default girl.
02:33:45 <bakert> i bet she was happy ;)
02:34:34 <bakert> (dict.org is giving me absconder or truant for default -- not much use)
02:35:03 <bakert> Player.start instead of Player.default???
02:35:06 <bakert> rubbish!
02:35:10 <bakert> Player.basic?
02:35:16 <bakert> Come on brain ...
02:35:24 <therp> .run?
02:35:26 <mbishop> init?
02:35:56 <dons> ah,like "defaulting on a loan payment"
02:35:59 <bakert> it's like a standard version of the player record which has sensible defaults so you can just alter the fields that aren't default.
02:36:03 <bakert> (dons, yeah)
02:36:17 <mbishop> stupid project euler making my brain hurt
02:36:35 <bakert> let player = Player.default { hand = x } -- that sort of thing
02:36:57 <mbishop> I still say "init" for "initial"
02:37:05 <mbishop> but I'm going to sleep, night :)
02:37:05 <bakert> i see what you're saying
02:37:09 <quazimodo> so does ++ perform a cat?
02:37:11 <bakert> night night
02:37:11 <mbishop> and happy new year :P
02:37:16 <bakert> hny also
02:37:20 <quazimodo> such as adding a new member to a list
02:37:48 <bakert> quazimodo, you mean does 5 ++ [1,2,3,4] == [5,1,2,3,4]???
02:38:01 <bakert> for that you need 5:[1,2,3,4]
02:38:08 <dons> > "cat" ++ "alogue"
02:38:09 <lambdabot>  "catalogue"
02:38:13 <bakert> (apols if this is all obvious and you are actually asking a different question!)
02:38:21 <quazimodo> then why does reverse2 (x:xs) = reverse2 xs ++ [x] work?
02:38:31 <bakert> because the x is in []
02:38:36 <bakert> which makes it a list of one element
02:38:42 <quazimodo> if it wasnt you would perform : ?
02:39:02 <dons> > let r [] = [] ; r (x:xs) = r xs ++ [x] in r "haskell"
02:39:03 <lambdabot>  "lleksah"
02:39:14 <bakert> you can do reverse2 (x:xs) = reverse2 x:xs but then it is in the wrong order
02:39:31 <quazimodo> reverse2 (x:xs) = reverse2 xs:x ?
02:39:36 <quazimodo> doesnt quite work
02:39:37 <quazimodo> :/
02:39:40 <bakert> no
02:39:41 <dons> > let snoc xs x = xs ++ [x] ; r [] = [] ; r (x:xs) = r xs `snoc` x in r "haskell"
02:39:42 <lambdabot>  "lleksah"
02:39:47 <bakert> it has to be a : [a]
02:39:53 <quazimodo> i see
02:40:00 <bakert> [a] : a doesn't work
02:40:03 <dons> ?type (:)
02:40:04 <lambdabot> forall a. a -> [a] -> [a]
02:40:41 <quazimodo> i was looking at that actually
02:40:56 <quazimodo> i guess i am still a little bit confused but i guess ill learn
02:41:25 <bakert> : is an operator that takes a single element and puts it on the front of a list
02:41:34 <bakert> ++ is an operator that joins two lists together
02:41:46 <bakert> > 1 : [2,3,4]
02:41:46 <quazimodo> the recursion has some things i dont know yet, some knowledge im missing so that i can construct a [1,2,...,n] or a (1,2,3,4..,n) etc
02:41:47 <lambdabot>  [1,2,3,4]
02:41:56 <bakert> > [1] ++ [2,3,4]
02:41:58 <lambdabot>  [1,2,3,4]
02:42:06 <quazimodo> ok bakert that makes sense to me
02:42:17 <quazimodo> and what was a () called?
02:42:23 <quazimodo> forgot the name
02:42:44 <bakert> well i always call it a tuple.  but in haskell it seems that they call (1, 2) a pair and (1,2,3) a triple and so on.
02:42:52 <quazimodo> thats it, tuple
02:43:13 <quazimodo> i forgot the name and was wracking my brain trying to remember it because i knew i had used it at uni for 2 years... annoyed i couldnt remember
02:43:31 <quazimodo> bbl thanks!
02:43:54 <bakert> i know it from python.  (bbl??)
02:44:35 <bakert> ah ... be back later
02:44:41 <bakert> took me a while that one
02:45:25 <bakert> Can I chain import statements on a single line anyhow?
02:45:38 <bakert> doesn't like import Card, System.Environment
02:46:41 <dons> yeah, with ;
02:46:46 <bakert> ah
02:46:49 <bakert> thanks
02:46:50 <dons> import IO; import List
02:46:55 <dons> but its not usual style
02:47:09 <bakert> oh i see
02:47:28 <bakert> i can just squish it up.  there's no special syntax to allow it.  ok - one line per import it is then.  fair dos.
02:47:30 <dons> there's no strong reason not to use it , though.
02:47:39 <bakert> one other thing.
02:47:48 <dons> yep, no special syntax for multiple imports
02:48:02 <bakert> this import qualified malarkey doesn't quite seem to be working for me how we intended.  if I do
02:48:05 <bakert> import State (State)
02:48:06 <bakert> and
02:48:10 <bakert> import qualified State
02:48:23 <bakert> I still get Not in scope: data constructor `State'
02:48:25 <dons> (btw, there's aslo:  import qualified State as Foo
02:48:38 <bakert> (ah, interesting, that could be very useful)
02:48:39 <dons> bakert: ah, you're just importing the type :)
02:48:45 <dons> import State (State(..))
02:48:52 <dons> imports the State type, and the State constructor
02:48:54 <bakert> oh lordy yes it is two different things i'd forgotten that
02:48:58 <dons> (and its fields too)
02:49:22 <bakert> so perhaps i should call the constructor New
02:49:26 <bakert> and do State.New
02:49:33 <bakert> instead of State.State, or more imports???
02:49:39 <bakert> would that be wildly unorthodox?
02:50:16 <bakert> am i weirdly reimplementing OO in haskell?
02:50:16 <bakert> !
02:50:23 <dons> New for a constructor would be a bit unorthodoc :)
02:50:26 <dons> x
02:50:55 <dons> consider this module, btw,:
02:50:56 <dons> module A where data A = A { a :: Int } deriving Show
02:51:04 <dons> it defines 3 distinct A's
02:51:13 <dons> a module, a type, and a value (the A constructor)
02:51:16 <dons> also a field 'a'
02:51:42 <bakert> I see.  it's just convention that makes the A = A both the same.  they are separate names/things.
02:52:08 <benja_> yup
02:52:13 <bakert> i can't help it -- i really like State.New { blah }
02:52:22 <benja_> you're a free programmer :-)
02:52:32 <bakert> i need to cure myself of it.  tell me how un-functional and un-pure a name it is!
02:52:39 <bakert> heap derision on it!
02:52:57 <benja_> it's a terribly un-functional and un-pure name! how can you even consider using that, you moron!
02:53:01 <benja_> glad to help.
02:53:02 <bakert> thanks!
02:53:19 <dons> we can do things like:
02:53:21 <dons> import A hiding (a)
02:53:21 <dons> import qualified A
02:53:22 <dons> main = print (A.a (A 7))
02:53:32 <dons> which imports the type and constructor, hides the field
02:53:36 <dons> then imports the field qualified
02:53:39 <bakert> oooh crazy.  like it.
02:53:44 <bakert> that's what I should do then.
02:54:08 <bakert> get it so that State constructor is imported as just State but field accessor functions qualified
02:54:38 <benja_> probably then it's easier to do it as
02:54:43 <benja_> import State (State)
02:54:51 <benja_> import qualified State
02:55:11 <benja_> rather than listing all the things to hide, that lists all the things to import :)
02:55:22 <bakert> but then I have to say State.State for the constructor (not the type, though)
02:55:42 <dons> or say, module State where data State = State { deck :: Int } deriving Show
02:55:43 <benja_> bakert: ah, import State (State(State)) I think :-)
02:55:44 <dons> and:
02:55:49 <dons> import State hiding (deck)
02:55:49 <dons> import qualified State as My
02:55:50 <dons> main = print (My.deck cards)
02:56:03 <dons> $ runhaskell B.hs
02:56:04 <dons> 7
02:56:20 <bakert> hmm ... but then all my import modules have to know all the field names ... so maybe State.State is better!
02:56:30 <bakert> (i have to agonise over these things - sorry!)
02:56:36 <benja_> or equivalently to what I just said, import State (State(..))
02:56:43 <dons> yeah,
02:56:44 <dons> import State (State(State))
02:56:46 <dons> import qualified State as My
02:56:47 <dons> main = print (My.deck cards)
02:56:52 <dons> :)
02:56:54 <bakert> oooh that looks good
02:57:13 <bakert> if a bit mental
02:57:15 <dons> that imports the State type and State constructor from the module State, unqualfied (phew!)
02:57:24 <dons> and then imports the deck field qualified with My.*
02:57:55 <dons> at this point its a good idea to remember the separate namespaces for modules, types and values :)
03:03:08 <bakert> i looked at namespaces.  basically they are separate enough that i get confused before the compiler does!
03:03:12 <bakert> so i stopped looking!
03:05:03 <benja_> bakert: what's confusing? :-) they're just separate :)
03:05:41 <bakert> well yes that's what i mean.  i can call quite a lot of things "State".  so it is more up to me to make sure i can make sense of my names than worrying about what it will or will not let me give the same name.
03:05:57 <bakert> the compiler is not restricting me, my feeble brain is!
03:06:02 <benja_> hm, ok :)
03:06:38 <bakert> I do like this import State (State(State))
03:06:47 <benja_> Java has the same concept, btw, it's just not considered good style to use it like in Haskell :)
03:07:07 <bakert> what same concept?
03:07:13 <benja_> separate namespaces
03:07:42 <vegai> you might like "import qualified"
03:07:48 <bakert> oh i see.  most languages have more than one.  apart from Scheme?
03:07:58 <bakert> six might be overkill, or it might not, i have no idea.
03:08:09 <bakert> import qualified is what i am using for everything else in State, vegai
03:08:20 <bakert> import State(State(State))
03:08:29 <benja_> package State; class Foo { class State {}  public State State() { State: while(true) { break State }  return new State(); } }
03:08:32 <bakert> is so I can get the constructor without having to call it State.State
03:09:01 <benja_> ...oh, and you can have a field State State; in the same class for good measure
03:09:16 <bakert> yes, perhaps when i am more familiar with haskell it won't seem confusing like it doesn't seem confusing in java!
03:09:35 <benja_> python only has one, too
03:09:37 <bakert> still there is an extra problem in haskell.
03:09:46 <bakert> if i say let foo = blah blah foo
03:10:00 <bakert> then the foo in there becomes self-referential (if you know what i mean), right?
03:10:13 <bakert> so i can't access another foo from another namespace (function names) out there.
03:10:14 <benja_> bakert: it probably won't be confusing because you'll know what's a package, what's a type and what's a constructor from the syntax -- like the compiler does :)
03:10:27 <benja_> bakert: the usual word is recursive :)
03:10:35 <bakert> oh yea
03:10:36 <bakert> !
03:10:49 <benja_> you can't access it from another package because you're using 'let'
03:11:05 <bakert> ok.  dumb question.  what's a package?!
03:11:17 <benja_> erm, I meant module, sorry
03:11:21 <bakert> ok!
03:11:25 <bakert> module i can cope with!
03:11:49 <benja_> I think packages are collections of modules in Haskell, like Control contains Control.Monad etc., but I'm not sure about that =)
03:12:18 <bakert> So, benja_, are you saying i SHOULDN'T be putting my State record in a State module and should instead be sucking it up and getting to grips with namespaces?
03:12:23 <allbery_b> yes; they're also currently specific to ghc
03:12:35 <benja_> (if you put it on the top-level in your module, rather than inside a let, then other functions / modules can access it, it being recursive isn't a problem :))
03:12:59 <benja_> bakert: putting your State record in a State module *is* sucking it up and getting to grips with namespaces :)
03:13:36 <bakert> oh!
03:13:38 <bakert> that's alright then!
03:13:44 <benja_> putting your StateType record with its MakeState constructor in a StateModule module is taking the easy way out where it's easy on your brain what is what ;)
03:14:46 <bakert> ok, well my State module is like this:
03:15:09 <bakert> @paste
03:15:09 <lambdabot> http://paste.lisp.org/new/haskell
03:15:18 <allbery_b> putting all the code and definitions that make up a State in a single module is encapsulation.  naming it consistently is good sense.  :)
03:15:27 <lisppaste2> bakert pasted "My State module" at http://paste.lisp.org/display/33820
03:15:57 <bakert> it's not very big
03:16:06 <bakert> but it does make life much easier on the other end
03:16:54 <benja_> :)
03:17:09 <bakert> so do we approve, or disapprove, of this use of the module system?
03:17:44 <quazimodo> i feel like growing chick peas but i cant be bothered to till up my garden :/
03:17:59 <quazimodo> a bit of refreshing o/t for ya guys
03:18:01 <benja_> bakert: I'm not sure why you're putting it in its own module, but other than being so short it looks like usual haskell :)
03:18:33 <bakert> i'm putting it in it's own module so that i can have a function called discard
03:18:34 <bakert> really
03:18:50 <bakert> and so i can have let temporary variables called remaining and discard and stuff like that
03:18:57 <bakert> without me getting confused
03:19:04 <benja_> oh, I see
03:19:22 <benja_> well, it's unusual, but why not if you like it :)
03:19:32 <bakert> i want to be normal ;)
03:19:47 <benja_> another option is to use a prefix for the fields
03:20:00 <allbery_b> I think it's more commoin to use prefixes for that and use modules for logical groupings
03:20:07 <bakert> ah
03:20:09 <bakert> prefixes
03:20:11 <bakert> what are they?!
03:20:15 <bakert> they sound good!
03:20:23 <benja_> bakert: low tech :-)
03:20:24 <benja_> data RenderContext k = RenderContext {  rcMatrix :: Matrix, rcScene :: Scene k, rcFade :: Double, rcColor :: Color, rcBgColor :: Color, rcFadeColor :: Color }
03:20:26 <bakert> or you just mean call the field statePlayers, stateBlah
03:20:31 <bakert> oh i don't like that so much
03:20:32 <benja_> yep
03:20:45 <bakert> perhaps i will lead the modularising revolution!
03:20:49 <benja_> :)
03:21:00 * allbery_b wonders if h' is considering some kind of better namespace control for this
03:21:14 <bakert> is h' the next version of haskell?
03:21:30 <allbery_b> field names being global is one of the recognized problem areas in haskell
03:21:34 <benja_> "haskell prime". yeah
03:21:43 <allbery_b> yes. haskell' (read "haskell prime"
03:22:16 <bakert> don't worry my boss is a mathematician -- i am always getting x' chucked at me in odd circumstances!
03:23:27 <allbery_b> it makes sense. but it's a pain at times.  unfortunately I suspect this isone of the areas where everyone has their own idea about how it ought to work and no alternate design has gained any traction :(
03:24:53 <bakert> I think the solution dons and benja_ and I have come up with is pretty cool.  I'll go with it for now.  Don't tell me about problems with Haskell though - this is still week 1 really and I still believe it might be perfect!
03:24:57 <bakert> ;)
03:25:44 * allbery_b kinda likes the low rent solution:  data Foo is Foo { a: Int; b: String } qualified F; -- F is actually in the module namespace, accessors are F.a and F.b
03:26:28 <bakert> mmm
03:26:37 <bakert> yes that's what i've done without the need for the extra file.
03:26:41 <bakert> probably better.
03:26:58 <bakert> and no need for those bonkers import State(State(State))) things
03:27:08 <allbery_b> no new keywords, no syntactic ambiguity, module namespace is used because it's where the compiler will look anyway
03:27:08 <bakert> What's the constructor, F.Foo?
03:27:15 <allbery_b> import syntaxc would need some way to deal, though
03:27:42 <allbery_b> the constructor would still be Foo
03:27:44 <bakert> ah i see ... this isn't something we CAN do ... it's something you'd LIKE to be able to do .. doh!
03:27:52 <bakert> yes, that would be sehr gut
03:28:26 <allbery_b> right, I'm noodling ideas for haskell'
03:28:34 <allbery_b> it needs to be thought out more though.
03:29:00 <allbery_b> it looks okay as stated, but then you get to "so how do I list these in export and import lists?"
03:30:23 <benja_> allbery_b: as F.a and F.b?
03:30:44 <benja_> oh, you could also have just F -- I see the problem
03:30:45 <allbery_b> also, qualifying only the accessors is arguably inconsistent.  and do we want to (for consistency) do "qualified [as F]" defaulting to (in this case) Foo?  considering that it is in the module namespace so yu lose the ability to have a module Foo?
03:31:44 <allbery_b> it's actually not a trivial problem to deal with, which is why it hasn't been dealt with except by stowing it in a separate module like you did :)
03:32:51 <bakert> yep, cheaty cheaty.  but hey, it works.
03:33:00 <allbery_b> (also, real consistency would put the "qualified" before the data constructor name, but I'm not sure that is a good idea syntactically)
03:34:09 <benja_> allbery_b: that's a question for the syntax czar :)
03:35:15 <allbery_b> it means you're committing to record syntax early; personally I think it makes more sense to make it part of the record syntax, e.g. Constructor '{' fields '}' [modifiers]
03:35:53 <allbery_b> maybe Constructor [qualified] '{' fields '}' ['as' name]
03:36:54 <benja_> allbery_b: what if there's more than one constructor?
03:39:23 <bakert> god i love $
03:39:31 <bakert> newState = nextPlayer $ discard $ putDown $ pickup state
03:39:33 <bakert> !
03:39:35 <bakert> what fun
03:40:02 <benja_> it's pretty important for readable code imho :)
03:40:23 <bakert> i thought i didn't mind brackets but it is definitely better.
03:40:36 <bakert> clearer.
03:40:52 <goltrpoat> i managed to use >>= and -> today.  in the same expression, no less.
03:41:21 <benja_> goltrpoat: by -> you mean lambda? :)
03:41:25 <goltrpoat> no
03:41:26 <bakert> man, i am so far away from knowing what >>= does that my best description would be: "it is the tongue of the monad monster"
03:41:32 <bakert> but i will get there!
03:41:33 <goltrpoat> i mean the flipped <- in do notation
03:41:45 <goltrpoat> and i meant =<<, not >>=, sorry
03:42:04 <benja_> oh, I didn't know that there was such do notation
03:42:05 <bakert> all greek to me!
03:42:09 <goltrpoat> anyway, just never used them in the wrong direction before.
03:42:12 <goltrpoat> hehe
03:42:25 <bakert> "succintness is power"
03:42:28 <benja_> does it work just like <- with the direction reversed?
03:42:38 <goltrpoat> > do { "hello" -> c; return c }
03:42:38 <bakert> s/succintness/succinctness/
03:42:38 <lambdabot>  Parse error
03:42:42 <goltrpoat> bah.
03:42:46 <goltrpoat> (yes)
03:42:51 <goltrpoat> @undo { "hello" -> c; return c }
03:42:52 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 1}) "Parse error"
03:43:07 <int-e> @undo do { "hello" <- c; return c }
03:43:07 <lambdabot> c >>= \ a -> case a of { "hello" -> return c; _ -> fail ""}
03:43:27 <goltrpoat> int-e:  no, i meant "hello" -> c
03:43:32 <goltrpoat> (c <- "hello", equivalently)
03:43:40 <goltrpoat> works in ghci
03:43:55 <goltrpoat> oh, crap.  forgot the do.
03:43:59 <benja_> hmm, =<< is sort of like $ for monadic values :)
03:44:01 <goltrpoat> @undo do { "hello" -> c; return c }
03:44:01 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 14}) "Parse error"
03:44:07 <goltrpoat> meh.
03:44:13 <bakert> can a function have an argument with the same name as itself?
03:44:22 <int-e> hmm. what kind of syntax is that?
03:44:25 <opqdonut> @undo do { "hello" -> c ; return c }
03:44:26 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 14}) "Parse error"
03:44:35 <allbery_b> benja_: each constructor would be independent, as they are now.  the same rules would apply, i.e. you could only use the same "as" if the resulting field names have the same types.
03:44:45 <opqdonut> goltrpoat: yeah that -> thing there isn't valid syntax
03:44:53 <goltrpoat> sure it is.
03:44:58 <goltrpoat> Prelude>  do { "hello" -> c; return c }
03:44:59 <goltrpoat> "hello"
03:45:06 <opqdonut> woah
03:45:34 <opqdonut> i thought <- was for monad stuff and -> for lambda exps
03:46:03 * allbery_b wonders how ghc is parsing that
03:46:54 <int-e> hmm, and why is it parsing that without extensions.
03:47:08 * benja_ wonders how ghc is typeclass-defaulting that
03:47:20 <int-e> It isn't valid Haskell 98.
03:47:45 <int-e> or "It's not"
03:47:53 <goltrpoat> what's difficult about parsing it?  lambda expressions are (char '\') $ many1 identifier $ reserved "->" etc
03:48:03 <goltrpoat> there's no danger of mistaking one token for the other
03:48:40 <allbery_b> but it's not syntactically valid there, according to haskell98
03:49:19 <goltrpoat> ah
03:49:26 <goltrpoat> is it a ghc extension then?
03:49:44 <allbery_b> apparently.  te question is, what extension, and how is it interpreting it?
03:50:15 <goltrpoat> works in both 6.4.1 and 6.6
03:50:20 * allbery_b notes that ghc doesn't seem to like "hello" -> c as a standalone expression
03:50:25 <allbery_b> huh
03:50:41 <Syzygy-> allbery_b: What would that expression mean?
03:50:53 * allbery_b has no idea
03:51:07 <Syzygy-> That may well be a reason it doesn't work.
03:51:08 * goltrpoat notes that ghc doesn't like c <- "hello" as a standalone expression either :)
03:51:11 <allbery_b> I was just trying to figure out how it was interpreting it
03:51:27 <int-e> allbery_b: as  c <- "hello"
03:51:37 <int-e> allbery_b: in the context of 'do'
03:51:46 <allbery_b> yeh
03:53:29 <int-e> haha.
03:53:32 <int-e> -- What is this next production doing?  I have no clue!  SLPJ Dec06
03:53:32 <int-e>         | infixexp '->' exp             {% checkPattern $3 >>= \p ->
03:53:32 <int-e>                                            return (sL (comb2 $1 $>) $ mkBindStmt
03:53:32 <int-e>  p $1) }
03:53:50 <allbery_b> heh
03:54:03 <goltrpoat> hehe
03:55:41 * allbery_b doesn't see anything relevant in the ghc manual, offhand
03:56:35 <_matthew_> so how's the hangover then?!
03:56:48 <wolverian> I slept just fine, thanks!
03:57:03 <quazimodo> hangovers are a figment of your imagination. If you dont believe in it, it wont exist
03:57:19 <opqdonut> quantum boozedynamics
03:57:28 <quazimodo> heh
03:57:44 * _matthew_ wonders if apostrophies are also a figment of his imagination ;)
03:58:25 <quazimodo> "if you observe a person with a hangover, they seem alot worse than if you hadnt watched them in the first place. this leads us to the conclusion that there are no observers in physics, just participants" :P
03:58:37 <opqdonut> :)
04:00:23 <lokojones> hi guys
04:00:27 <lokojones> happy new year :)
04:02:16 <lokojones> I had a little question...
04:02:29 <opqdonut> just ask
04:02:29 <lokojones> I know that if I have
04:02:31 <lokojones> [Float]
04:02:31 <goltrpoat> anyway, haskell98 or not, -> seems like a good idea.  makes certain things more readable
04:02:45 <lokojones> I access to the first float of the list with
04:02:48 <lokojones> x:xs
04:02:56 <lokojones> beeing x the first element, and xs the rest
04:03:03 <lokojones> but...
04:03:04 <quazimodo> goltrpoat, i think they ought to ave made it longer, i prefer->->>->>%%_->
04:03:15 <lokojones> what If I have [[Float]]
04:03:36 <lokojones> in this case, I have a list with two lists of floats
04:03:42 <opqdonut> lokojones: [x:xs]:ys
04:03:47 <lokojones> and I want to access the first element of each list
04:04:42 <lokojones> opqdonut: that would give me x with the first element of the first list
04:04:46 <lokojones> and ys with the rest...
04:04:48 <lokojones> no?
04:04:53 <lokojones> so I guess it should be
04:05:03 <lokojones> [x:xs]:[y:ys]?
04:05:09 <lokojones> or isnt that possible?
04:05:10 <opqdonut> lokojones: no, that isn't a list
04:05:15 <ClaudiusMaximus> @type map head
04:05:17 <lambdabot> forall a. [[a]] -> [a]
04:05:52 <opqdonut> lokojones: yeah that or make a recursive function, foo [x:xs]:ys = bar (foo ys)
04:06:08 <allbery_b> actually, I think that would work, just not be what he wanted
04:06:27 <opqdonut> allbery_b: oh yeah, y would be the second list
04:06:47 <Syzygy-> I'm not convinced [x:xs]:ys is right.
04:06:53 <lokojones> umh
04:06:59 <lokojones> i like the recursive solution
04:07:10 <lokojones> [x:xs]:[y:ys] sounds really strange :P
04:07:13 <allbery_b> syzygy-: why not?
04:07:35 <Syzygy-> Because i think it ends up screwing up the pattern matching, basically...
04:07:39 <opqdonut> > let foo [x:xs]:ys = x:(foo ys)
04:07:40 <lambdabot>  Parse error in pattern
04:07:42 <opqdonut> hmm
04:07:50 <opqdonut> err wrong
04:07:50 <allbery_b> parens
04:07:55 <opqdonut> yeah
04:08:03 <opqdonut> > let foo (x:xs):ys = x:(foo ys)
04:08:03 <lambdabot>  Parse error in pattern
04:08:05 <opqdonut> still
04:08:28 <allbery_b> let foo ([x:xs]):ys) = x:foo ys in ...
04:08:34 <allbery_b> er
04:08:38 <allbery_b> lose the first )
04:08:45 <allbery_b> let foo ([x:xs]:ys) = x:foo ys in ...
04:08:56 <opqdonut> > let foo ([x:xs):ys) = x:(foo ys)
04:08:57 <lambdabot>  Parse error
04:09:01 <opqdonut> > let foo ([x:xs]:ys) = x:(foo ys)
04:09:01 <lambdabot>  Parse error
04:09:06 <opqdonut> > let foo ((x:xs):ys) = x:(foo ys)
04:09:07 <lambdabot>  Parse error
04:09:08 <allbery_b> you need an "in ..."
04:09:09 <opqdonut> bah
04:09:20 <opqdonut> allbery_b: not in a top-level let
04:09:21 <allbery_b> > let foo ([x:xs]:ys) = x:foo ys in foo
04:09:22 <lambdabot>  Add a type signature
04:09:27 <opqdonut> > let bar = 3
04:09:27 <lambdabot>  Parse error
04:09:32 <opqdonut> oh i'm mistaken
04:09:42 <allbery_b> in ghci it's fine.  in lambdabot it's not
04:09:52 <lokojones> umh
04:10:00 <lokojones> doesnt lambdabot use ghci?
04:10:01 <opqdonut> > let foo ((x:xs):ys) = x:(foo ys) in foo [[1,2],[2,3]]
04:10:02 <lambdabot>  Non-exhaustive patterns in function foo
04:10:06 <allbery_b> it does, but it preparses
04:10:25 <opqdonut> > let { foo ((x:xs):ys) = x:(foo ys) ; foo [] = [] } in foo [[1,2],[2,3]]
04:10:26 <lambdabot>  [1,2]
04:10:29 <opqdonut> yep, works
04:11:01 <opqdonut> map head [[1,2],[2,3]]
04:11:04 <opqdonut> > map head [[1,2],[2,3]]
04:11:05 <lambdabot>  [1,2]
04:11:21 <Syzygy-> In that thingie, x is [1,2], xs is [2,3] and ys is [].
04:12:06 <quazimodo> i cant seem to get my head around the recursion and iteration, currying etc :(
04:12:20 <quazimodo> complete lack of practice i guess
04:12:25 <quazimodo> *cheesy grin*
04:19:37 <Syzygy-> > let foo ([x:xs]:ys) = x:ys in foo [[1,2],[3,4]]
04:19:38 <lambdabot>    Occurs check: cannot construct the infinite type: a = [[a]]
04:19:39 <lambdabot>    Expect...
04:21:19 <allbery_b> x:ys is mismatched
04:21:52 <opqdonut> yeah, becouase of []
04:22:10 <ClaudiusMaximus> @pl { foo ((x:xs):ys) = x:(foo ys) ; foo [] = [] }
04:22:10 <lambdabot> (line 1, column 1):
04:22:11 <lambdabot> unexpected "{"
04:22:11 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
04:22:29 <allbery_b> "do { ..."
04:22:30 <xerox> :t map head
04:22:31 <lambdabot> forall a. [[a]] -> [a]
04:22:39 <opqdonut> Syzygy-: and that would make a list [1,[3,4]] which is impossibla
04:23:14 <Z4rd0Z> what's the english translation of '->' ?
04:23:20 <xerox> `to' ?
04:23:28 <opqdonut> @pl let { foo ((x:xs):ys) = x:(foo ys) ; foo [] = [] } in foo
04:23:28 <lambdabot> (line 1, column 5):
04:23:29 <lambdabot> unexpected "{"
04:23:29 <lambdabot> expecting natural, identifier or "in"
04:23:32 * allbery_b would say "onto"
04:23:43 <opqdonut> Z4rd0Z: in what context
04:24:00 <allbery_b> @pl let foo ((x:xs):ys) = x:(foo ys) ; foo [] = [] in foo
04:24:00 <lambdabot> (line 1, column 40):
04:24:01 <lambdabot> unexpected "["
04:24:01 <lambdabot> expecting pattern or "="
04:24:01 <opqdonut> in a type, eg a -> b, "onto" or "maps to"
04:24:19 <xerox> > (\((x:xs):ys) -> (x,y)) [[1,2],[3,4]]
04:24:20 <lambdabot>  Not in scope: `y'
04:24:24 <Z4rd0Z> in a type declaration, like x -> x -> x
04:24:43 <xerox> Doesn't `onto' have a special meaning?
04:25:13 <Z4rd0Z> would the first 2 x's be the arguments and the final the return value?
04:25:27 <opqdonut> well, in mathematics mappings X -> Y are described as "X onto Y" or "X maps to Y"
04:25:28 <allbery_b> naively, yes
04:25:43 <goltrpoat> careful with 'onto' there, heh
04:25:55 <xerox> onto means surjectiv
04:25:56 <xerox> e
04:26:04 <xerox> Man I'm still too sleepy.
04:26:09 <opqdonut> :)
04:26:21 <allbery_b> in Haskell, since everything is curried, it's a little more interesting; you can "peel off" 'x ->'s by partial application
04:26:44 <allbery_b> which is why you write x -> x -> x instead of (x, x) -> x
04:26:53 <ClaudiusMaximus> @unpl map head
04:26:53 <lambdabot> map head
04:27:19 <ClaudiusMaximus> @pl map head
04:27:19 <lambdabot> map head
04:27:27 <Z4rd0Z> I've been able to grasp the currying part, but I get a little confused when I see something like x -> (x -> y) -> x
04:27:29 <allbery_b> > let foo :: Int -> Int -> Int; foo = (+) in foo 5
04:27:31 <lambdabot>  <Int -> Int>
04:27:37 <xerox> > let f [] = []; f ((x:_):xs) = x : f xs in f [[1,2],[3,4]]
04:27:39 <lambdabot>  [1,3]
04:28:11 <allbery_b> in x -> (x -> y) -> x, (x -> y) usually indicates a function from x to y as an argument
04:28:15 <velco> what's the most convenient/recommended way to do formatted IO in Haskell, something along the lines of printf and capable of working with ByteString (Text.Printf does not seem to) ?
04:28:41 <allbery_b> :t map
04:28:42 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:28:46 <xerox> Z4rd0Z: (->) is right-associative. Read a -> b -> ... -> z as a -> (b -> (... -> z))
04:29:11 <allbery_b> the first argumentof map is a function which will be applied to successive elements of [a] to produce [b]
04:29:28 <opqdonut> @djinn a -> Integer
04:29:28 <lambdabot> -- f cannot be realized.
04:29:40 <opqdonut> @djinn a -> Bool
04:29:41 <lambdabot> f _ = False
04:29:51 <opqdonut> @. pl djinn a -> Bool
04:29:51 <lambdabot> f = const False
04:29:56 <opqdonut> ^_^
04:30:09 <xerox> Actually (a -> b) -> [a] -> [b] means (a -> b) -> ([a] -> [b]) that is, given an argument of type (a -> b) map returns a function that given an argument of type [a] returns a value of type [b].
04:31:45 <xerox> People want to go to eat.. again.. gurgle.  See you later.
04:33:44 <nornagon> :t liftM
04:33:46 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
04:34:11 <Z4rd0Z> thanks as always for your fine help
04:34:14 <Z4rd0Z> g'nite
04:34:27 <nornagon> takes a function of type a1 -> r and lifts it to a function of type m a1 -> m r?
04:34:46 <nornagon> I'm going to ignore that scary kind stuff :)
04:34:56 <allbery_b> yep.  and if m is the list monad, it reduces to map
04:35:06 <nornagon> hmm
04:35:23 <nornagon> i think i'll ignore that for now :D
04:35:27 <allbery_b> heh
04:35:50 <allbery_b> :t map
04:35:51 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
04:35:55 <allbery_b> :t liftM
04:35:56 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
04:35:57 <nornagon> ah
04:35:59 <nornagon> i see :D
04:36:19 <allbery_b> now imagine the 'm's are replaced by ([])
04:36:23 <nornagon> :)
04:36:53 <nornagon> so map takes a function that turns as into bs, and returns a function that turns lists of as into lists of bs
04:37:06 <allbery_b> right
04:37:11 <nornagon> neat.
04:39:58 <opqdonut> :t fmap
04:39:59 <lambdabot> forall (f :: * -> *) b a. (Functor f) => (a -> b) -> f a -> f b
04:40:08 <opqdonut> even more generic :)
04:40:20 <nornagon> heh
04:40:40 <nornagon> ?hoogle (a -> b) -> f a -> f b
04:40:41 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
04:40:41 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
04:40:41 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
04:40:49 <nornagon> :(
04:42:27 <allbery_b> the current version of hoogle is a bit stupid about such things.  I understand the forthcoming hoogle4 will make it smarter
04:42:33 <opqdonut> :)
04:49:10 <nornagon> ?doc
04:49:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
04:49:20 <nornagon> ?doc Show
04:49:21 <lambdabot> Show not available
04:49:26 <Saizan> yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
04:49:33 <nornagon> lol
04:50:34 <Syzygy-> ?hoogle p -> q
04:50:34 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
04:50:35 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
04:50:35 <lambdabot> Control.Monad.Writer.tell :: MonadWriter w m => w -> m ()
04:50:48 <Syzygy-> ?hoogle foo -> bar
04:50:48 <lambdabot> Did you mean: Foo -> Bar
04:50:49 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
04:50:49 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
04:51:04 <allbery_b> @remember Saizan yesterday i was so drunk i was trying to typecheck the people at the party.. "what's your monad!?"
04:52:18 <vincenz> Heh, we were singing math songs on the way home from a party
04:52:43 <quazimodo> ARGH haskell is tricky!!
04:53:28 <goltrpoat> there once was a ring over Q..
04:54:40 <therp> luckily I managed to hide my nerd nature yesterday ;) .. from my personal experience you should stop telling stuff after admitting your CS major. otherwise you usually won't get her number..
04:55:32 <benja_> is (a, b -> c) the type of a function taking a tuple or the type of a tuple containing a function as its second element?
04:55:37 <vincenz> the only thing that can rectify saying you have a CS major is adding on "And an MBA"
04:56:39 <allbery_b> benja_: the latter
04:56:46 <allbery_b> the formwr is ((a, b) -> c)
04:57:02 <quazimodo> nextdigit (a,b) = a `divMod` 10
04:57:02 <quazimodo> somFunc x  = iterate nextdigit (x `divMod` 10)
04:57:02 <quazimodo> iterate_func x = [d|(a,d) <- someFunc x ]
04:57:06 <quazimodo> what is wrong with that?
04:57:10 <benja_> that's what I thought, but:
04:57:14 <benja_> @hoogle runWriter
04:57:15 <lambdabot> Control.Monad.Writer.runWriter :: (Writer w a -> a, w)
04:57:15 <lambdabot> Control.Monad.Writer.runWriterT :: WriterT w m a -> m (a, w)
04:57:18 <benja_> newtype Writer w a = Writer { runWriter :: (a, w) }
04:57:38 <benja_> is this a hoogle prettyprinting bug?
04:58:43 <goltrpoat> quazimodo:  wrong in what sense?
04:58:47 <goltrpoat> looks like it'll typecheck
04:58:51 <quazimodo> maybe i did it wrong
04:59:08 <quazimodo> i think the iterate_func x = [d|(a,d) <- someFunc x ] is wrong?
04:59:28 <nornagon> hm, in parsec, how do you match like char '\\' >> char '"', but return just the quote?
04:59:36 <goltrpoat> wrong in what sense though?  someFunc x evaluates to [(a,a)]
04:59:54 <nornagon> (or something else entirely, for use in thing such as char '\\' >> char 'n'
04:59:56 <nornagon> )
05:00:03 <goltrpoat> so iterate_func x could be written as iterate_func x = map snd (someFunc x)
05:00:11 <goltrpoat> if that's what you want, then it's perfectly fine :)
05:00:24 <quazimodo> goltrpoat, then it would work but ghci doesnt like it??
05:00:38 <nornagon> ?pl \x -> map snd (someFunc x)
05:00:38 <lambdabot> map snd . someFunc
05:00:42 <quazimodo> myLast.hs:30:29: Not in scope: `someFunc'
05:00:43 <quazimodo> Failed, modules loaded: none.
05:00:55 <nornagon> heh.
05:01:22 <nornagon> ?doc parsec
05:01:22 <lambdabot> parsec not available
05:01:26 <nornagon> ?doc Parsec
05:01:28 <lambdabot> Parsec not available
05:01:28 <goltrpoat> quazimodo:  works fine here
05:01:28 <nornagon> :(
05:01:28 <allbery_b> somfunc vs. someFunc?
05:01:34 <allbery_b> somFunc vs. someFunc?
05:01:38 <goltrpoat> quazimodo:  you do have 'someFunc' misspelled in the definition
05:01:46 <goltrpoat> i figured you were just typing it up though
05:01:55 <quazimodo> ergh :(
05:02:12 <quazimodo> cant believe a typo did that
05:02:14 <goltrpoat> hehe
05:02:22 <allbery_b> nornagon: I would think the >> would do what you want already
05:02:29 <quazimodo> and to think i used to mess around in javascript.. the one language where typos bite your nuts hard
05:02:38 <allbery_b> the result should be that of the last parser
05:02:49 <quazimodo> cant believe i didnt catch it too
05:02:51 <quazimodo> its toolate i think
05:04:20 <nornagon> allbery_b: it doesn't seem to, though :/
05:04:25 <nornagon> it seems to just return the \
05:04:28 <allbery_b> if you want to capture the first one instead, char '\\' >>= \l -> (char '"' >> return l)
05:04:33 <allbery_b> huh
05:04:40 <metaperl> any HXT users onboard?
05:04:56 <goltrpoat> quazimodo:  eh.  if all your problems are typo-related, you're rather well off :)
05:05:39 <quazimodo> why wouldnt this work
05:05:44 <quazimodo> iterate_func x = [d|(a,d) <- someFunc (reverse x) ]
05:06:05 <nornagon> :t reverse
05:06:06 <lambdabot> forall a. [a] -> [a]
05:06:11 <nornagon> it would.
05:06:49 <allbery_b> nornagon: it seems to work for me
05:06:57 <quazimodo> nornagon, it isnt work :/
05:07:00 <nornagon> hmm.
05:07:22 <nornagon> > [d|(a,d) <- reverse [1,2,3]]
05:07:23 <lambdabot>  add an instance declaration for (Num (a, b))
05:07:23 <lambdabot>   In the list element: 3
05:07:27 <allbery_b>  > parseTest (char '\\' >> char '"') "\\\""
05:07:30 <allbery_b>  '"'
05:07:42 <nornagon> :/
05:07:44 <quazimodo>  No instance for (Integral [a])  arising from use of `iterate_func' at <interactive>:1:0-11; Probable fix: add an instance declaration for (Integral [a]); In the definition of `it': it = iterate_func 1324
05:07:47 * nornagon looks at his code again.
05:08:02 <nornagon> > [d|(a,d) <- reverse [(1,2),(3,4)]]
05:08:04 <lambdabot>  [4,2]
05:08:07 <quazimodo> afaik that shouldnt happen :/
05:08:37 <nornagon> oh ah, it's because i'm using <|>, i think.
05:08:46 <quazimodo> ?
05:09:05 <nornagon> stringChar = (noneOf '"') <|> (char '\\' >> char '"')
05:09:35 <quazimodo> are you talking to me or alberry?
05:09:55 <nornagon> quazimodo: allbery.
05:10:25 <nornagon> > parseTest (many ((noneOf '"') <|> (char '\\' >> char '"'))) "\\\""
05:10:26 <lambdabot>  Not in scope: `char'
05:10:35 <allbery_b> nornagon: yep, your problemn is that noneOf eats the backslash.  reverse the alternatives
05:10:42 <nornagon> :)
05:10:44 <nornagon> thanks
05:11:27 <nornagon> oh, gr. Couldn't match expected type `[Char]' against inferred type `Char'
05:11:43 <allbery_b> noneOf "\""
05:11:49 <allbery_b> it's a String, not a Char
05:11:58 <nornagon> oh ah
05:12:09 <vincenz> ['"']
05:12:14 <nornagon> hmm.
05:12:48 <allbery_b> (vincenz's is another way to phrase it, since String is [Char])
05:13:03 <vincenz> just emphasizing the semantics, noneOf ... list of characters
05:14:57 <nornagon> hrm, still not working for some reason. *peers*
05:15:53 <quazimodo> ok nvm i get it
05:16:06 <quazimodo> obviously 1234 isnt [1,2,3,4]
05:16:17 <vincenz> > ['1'..'4']
05:16:18 <lambdabot>  "1234"
05:16:21 <nornagon> ... well no.
05:16:24 <vincenz> > ['1', '2', '3', '4']
05:16:25 <lambdabot>  "1234"
05:16:28 <vincenz> > [1, 2, 3, 4]
05:16:29 <lambdabot>  [1,2,3,4]
05:17:49 <nornagon> oh, it does work
05:17:58 <nornagon> i must've been quoting things wrong for my shell
05:17:59 <nornagon> :/
05:18:15 <nornagon> now, i wonder how to make it do \n and the like...
05:18:19 <allbery_b> quoting is always fun :)
05:19:21 <Templar2> anyone who can show how this one calculates the double(x*2):  double (x+1) = 2 + (double x)
05:19:29 <Templar2> would be nice to see the calculation with numbers...
05:19:30 <allbery_b> char '\\' >> escChar where escChar = case anyChar of 'n' -> return '\n'; ...
05:20:36 <opqdonut> Templar2: that'd probably need a "double 0 = 0" decl too
05:20:46 <Templar2> yea, its true
05:20:57 <Templar2> double _ = 0 . . .
05:21:10 <allbery_b> (the final case of that is c -> return c)
05:22:10 <Templar2> having really hard to understand how it calculates. It´s calling the function recursivly untill something?
05:22:35 <allbery_b> that's why you need double 0 = 0; it's the terminal condition
05:23:18 <Templar2> termal=? That it always comes to 0?
05:23:26 <nornagon> allbery_b: heh, i just wrote that and came back and saw your definition :)
05:23:41 <nornagon> although i made escChar a separate function, good idea to make it a sub-function thingy
05:23:54 <allbery_b> you cam rewrite "double (x+1) = 2 + (double x)" as "double x = 2 + double (x - 1)", and in fact Haskell rewrites it internally to that IIRC
05:24:18 <allbery_b> nornagon: actually the toplevel one is preferable, but multiline stuff in IRC is a pain
05:24:26 <nornagon> oh?
05:24:37 <nornagon> i mean, why's the toplevel one preferable?
05:24:52 <allbery_b> you're handling string parsing.  might you also want char parsing ('c' vs "sss")?  you'd want to reuse escChar in that case
05:25:02 <nornagon> i guess
05:25:09 <nornagon> good point :)
05:28:59 <quazimodo> wow
05:29:04 <quazimodo> haskell has a weird if structire
05:29:07 <quazimodo> structure even
05:30:01 <astrolabe> why weird?
05:30:44 <quazimodo> well the one i just saw was quite odd
05:31:17 <allbery_b> Templar2: is it clear now?  double (rewritten as I did for clarity above) calls itself recursively with a smaller number until it reaches the terminal condition (called with 0) at which point it returns 0.  which propagates up until all the recursive calls return
05:31:49 <astrolabe> quazimodo: it is quite different from 'if' in an imperitive language
05:31:58 <quazimodo> strolabe quite..
05:31:59 <opqdonut> Templar2: double (3) = 2 + double(2) = 2 + 2 + double (1) = 2 + 2 + 2 + double(0) = 6+0 = 6
05:32:04 <allbery_b> double 5 = 2 + (2 + (2 + (2 + (2 + (0)))))
05:32:14 <Templar2> allbery_b yea, I just made an test calculatio with the rewrite you gave me and it became mutch easier. Thanks a lot!
05:32:58 <allbery_b> aside: some people think "n+k patterns" (like your double (n + 1) example) shouldn't be used, precisely for this reason:  it's confusing
05:33:05 <allbery_b> much cleaere when rewritten as a normal pattern
05:33:27 <paolino> Productive 2007 to you , thinkers.
05:33:27 <paolino> Moving from Arrays to STArrays means code refactoring in the mean case ?
05:33:27 <paolino> Like datatype  containing Arrays are not portable to STArrays ?
05:33:30 <Templar2> yea
05:35:22 <vincenz> > let double = (*2) in double . double $ 3
05:35:23 <lambdabot>  12
05:41:30 <paolino> A datatype containing an STArray must be parametric on  the parameter of the ST monad also.
05:41:31 <paolino> How do I instantiate a data if I cannot know that argument ?
05:42:18 <dons> inside a runST
05:42:31 <dons> it's like the RealWorld argument to IO
05:43:33 <vincenz> dons: happy new year
05:45:40 <dons> :D
05:46:02 <nornagon> hm
05:46:08 <nornagon> :t readOct
05:46:09 <lambdabot> forall a. (Num a) => ReadS a
05:46:13 <dons> so, vincenz, your new year's resolution is to write some haskell projects in 2007? :)
05:46:22 <nornagon> :t readOct
05:46:23 <nornagon> readOct :: (Num a) => String -> [(a, String)]
05:46:23 <lambdabot> forall a. (Num a) => ReadS a
05:46:31 <nornagon> from ghci
05:46:36 <nornagon> anyway, why is there a [] there?
05:46:43 <nornagon> shouldn't it be just (a, String)?
05:47:24 <dons> > readOct "07 02 01 foo"
05:47:25 <lambdabot>  [(7," 02 01 foo")]
05:47:35 <nornagon> tried that :/
05:47:46 <nornagon> hmm
05:47:54 <nornagon> > readOct "[1,2,3]"
05:47:56 <lambdabot>  []
05:48:19 <nornagon> > readOct "1,2,3"
05:48:21 <lambdabot>  [(1,",2,3")]
05:49:47 <vincenz> dons: possibly :)
05:50:04 <vincenz> dons: Well I have four new year's resolutions, but maybe I could tack one on
05:50:07 * vincenz never knows what to code, however
05:50:09 <allbery_b> looks like it's using a general parser frameworkk where there can in theory be multiple possible parses, but in this case there is usually only one valid parse
05:50:29 <vincenz> dons: but I promised the solitary reader of my blog to code some more
05:50:34 <allbery_b> look at the definition of ReadS
05:51:21 <nornagon> :hoogle ReadS
05:51:28 <nornagon> @hoogle ReadS
05:51:29 <lambdabot> Prelude.ReadS :: type ReadS a
05:51:29 <lambdabot> Prelude.reads :: Read a => ReadS a
05:51:29 <lambdabot> Numeric.readSigned :: Real a => ReadS a -> ReadS a
05:52:39 <allbery_b> sorry, you actually have to go look at the docs to see the description of it :)
05:52:47 <nornagon> darn. :P
05:53:01 * allbery_b looked up readOct in:
05:53:05 <nornagon> ?pl \a -> a == '0' || a == '1'
05:53:05 <lambdabot> liftM2 (||) ('0' ==) ('1' ==)
05:53:06 <allbery_b> ?doc Numeric
05:53:06 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
05:53:15 <allbery_b> and folloed the link for ReadS
05:53:34 <nornagon> :t liftM2
05:53:36 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
05:53:40 <nornagon> eek
05:53:53 <nornagon> oh
05:54:01 <nornagon> liftM for functions with >1 argument
05:55:05 <nornagon> ?. unpl . pl \a -> a == '0' || a == '1'
05:55:05 <lambdabot> compose module failed: IRCRaised Parse error: "\\a"
05:55:38 <vincenz> dons: project suggestions are more than welcome
05:56:08 <allbery_b> ?. unpl pl \a -> a == '0' || a == '1'
05:56:08 <lambdabot> ((\ f -> '0' == f) >>= \ b -> (\ g -> '1' == g) >>= \ a -> return (b || a))
05:56:18 <nornagon> neat
05:56:20 <nornagon> :D
05:56:48 <allbery_b> lambdabot isn't smart enough to handle composition as an infix function, so you need to use t as a prefix (?. f g ...)
05:56:58 <nornagon> ah, okay
05:56:59 <allbery_b> use it
05:57:10 <nornagon> what if i want to compose more than two things?
05:57:19 <allbery_b> make . one of the things
05:57:25 <nornagon> sneaky.
05:57:43 <dmhouse> ?. elite . unpl pl \a -> a
05:57:44 <lambdabot> (\ a -> A)
05:57:58 <nornagon> elite?
05:58:05 <nornagon> ?elite foo
05:58:05 <lambdabot> phO0
05:58:05 <allbery_b> @elite foo bar
05:58:06 <lambdabot> phOo 8Ar
05:58:06 <nornagon> ah.
05:58:07 <vincenz> it makes better code
05:58:09 <vincenz> elite code :)
05:58:09 <dmhouse> ?elite it allows you to talk like this
05:58:10 <lambdabot> I+ 4|1Owz0rz yOU +0 7AlK 1IKE +His
05:58:10 <nornagon> hehe
05:58:21 <nornagon> should do you -> j00
05:58:28 <dmhouse> It does sometimes.
05:58:31 <dmhouse> ?elite you
05:58:32 <lambdabot> yOU
05:58:34 <nornagon> and transpose random characters
05:58:34 <dmhouse> ?elite you
05:58:35 <lambdabot> y0U
05:58:41 <dmhouse> It's got some randomness to it.
05:58:47 <nornagon> :)
06:06:14 <paolino> dons, my datatype is  data Foo = {i::Int,a::Array Int Int}
06:06:15 <paolino> if I move to data Foo s = {....,a::StArray s Int Int} ,the i field should go out ?
06:06:30 <dons> hmm, you're missing a constructor there
06:06:43 <paolino> sorry
06:07:06 <paolino> data Foo = Foo {i::Int,a::Array Int Int}
06:07:23 <paolino> data Foo s = Foo {....,a::StArray s Int Int}
06:07:36 <vincenz> dmhouse: any haskell project suggestions
06:08:25 <augustss> howdy
06:08:48 <vincenz> Happy new year
06:09:15 <wolverian> vincenz, a gnome bittorrent client!
06:09:21 <augustss> and to you
06:09:48 <dmhouse> Didn't someone already do a bittorrent client in Haskell?
06:09:54 <dmhouse> ?google bittorrent haskell
06:09:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/papers/CSL06.html
06:09:55 <lambdabot> Title: Rewriting Haskell Strings
06:10:40 <vincenz> wolverian: interesting is something different than 90% interface code
06:11:21 <wolverian> vincenz, true enough. it's not very exciting.
06:11:37 <wolverian> dmhouse, not a gui one, afaik.
06:11:46 <wolverian> (I just happen to need one that doesn't suck.)
06:12:19 <paolino> vincenz a neural net driven completer for line editing
06:13:45 * vincenz peers at paolino 
06:13:49 <vincenz> why neural net perse?
06:14:46 * vincenz is curious
06:14:54 <dmhouse> vincenz: what do you want to learn?
06:14:57 <vincenz> wolverian: why not use the standard bittorrent client?
06:15:03 <vincenz> dmhouse: Eh..
06:15:16 <vincenz> dmhouse: Right now get deeper into how to model semantics :)
06:15:30 * vincenz has been stuck on that
06:15:31 <dmhouse> vincenz: hardcore IO, FFI, STM, there's lots of different technologies you could learn, so pick a project that allows you to learn what you want.
06:15:52 <lisppaste2> metaperl pasted "ghc cannot find Data.FiniteMap when compiling... help please" at http://paste.lisp.org/display/33823
06:15:59 <dmhouse> metaperl: use Data.Map instead.
06:16:01 <syntaxfree> hardcore IO?
06:16:02 <augustss> vincenz: have you implemented any compiler or interpreter?
06:16:05 <wolverian> vincenz, the gui is horrid and the version in ubuntu doesn't support any kind of DHT.
06:16:07 <dmhouse> FiniteMap was deprecated about a million years ago.
06:16:09 <vincenz> augustss: yes,
06:16:24 <metaperl> oh FiniteMap was deprecated... ok thanks dmhouse
06:16:26 <vincenz> wolverian: there's one that's not too bad
06:16:43 <augustss> vincenz: for what language?
06:16:45 <metaperl> what is the fastest way to access the ghc docs on Data.Map?
06:16:50 <vincenz> augustss: miniML for instance
06:17:00 <dmhouse> metaperl: either ?docs Data.Map in this channel
06:17:03 <vincenz> no backend
06:17:06 <augustss> vincenz: what about a partial evaluator?
06:17:10 <metaperl> @docs Data.Map
06:17:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
06:17:16 <wolverian> vincenz, name? :)
06:17:19 <metaperl> k00L
06:17:20 <vincenz> augustss: haven't had time for that yet
06:17:23 <vincenz> :)
06:17:26 <vincenz> augustss: why?
06:17:32 <dmhouse> Or, as I've done, bookmark the contents to those docs in Firefox, give it a keyword (mine is 'hs'), and enable Find-As-You-Type.
06:17:33 <augustss> it's a project :)
06:17:36 <vincenz> augustss: Right now I'm stuck trying to model an imperative language with continuations :)
06:17:51 <vincenz> augustss: true enough but typically coding projects, unless they're purely for learning should do something useful :)
06:17:56 <dmhouse> Then to find docs for a module, I do Alt+D, hs, Enter, type Data.Map, Enter.
06:18:15 <paolino> vincenz: a trainable text completer can be a good base for a gui action completer
06:18:18 <vincenz> Well, to be more specific, how to prove equivalences..
06:18:29 <augustss> vincenz: i'd love a partial evaluator for haskell, but it's a large project
06:18:41 <wolverian> (I'm using Deluge now, but it has some bugs and the UI isn't as good as it could be.)
06:18:50 <vincenz> augustss: I guess the main issue, which I don't know much about (cause I'm not related with the literature) is deciding when to stop
06:18:57 <metaperl> construction is more cumbersome with Data.Map ... no listToFM function
06:19:10 <metaperl> oops
06:19:11 <metaperl> fromList
06:19:14 <metaperl> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html#15
06:19:16 <lambdabot> http://tinyurl.com/ykdr3x
06:19:18 <vincenz> augustss: btw, question about CS in pm
06:19:57 <vincenz> augustss: I think the ideal basis would be yhc as it's smaller
06:20:55 <psykotic> vincenz: if you want to get a quick overview of the field, you should read the survey paper by mogensen or the one by danvy.
06:21:28 <vincenz> psykotic: thx
06:21:45 <vincenz> psykotic: got a more concrete link/title?
06:21:51 <psykotic> let me find it, sec
06:22:22 <vincenz> thx
06:22:29 <nornagon> hmm
06:22:30 <nornagon> $ ./scheme "#o129"
06:22:31 <nornagon> Found value: Number 10
06:22:54 <nornagon> how do i get parsec to error out if it finds a character that doesn't belong in the parser (and isn't whitespace?)
06:23:12 <psykotic> mogensen and sestoft, "partial evaluation"
06:23:27 <psykotic> consel and danvy, "tutorial notes on partial evaluation"
06:24:06 <vincenz> thanks
06:24:11 <vincenz> psykotic++
06:24:45 <bakert> hi folks. wonder if you can help me with another newbie special.  i want to pattern match on both a specific part of a record and have the whole record available to me as a named variable in the function.  is that possible?
06:24:52 <bakert> play State { State.wildcards = [] } = state
06:25:15 <bakert> only of course it doesn't know what "state" refers to, but it should refer to the whole record.
06:25:22 <dons> bakert: yeah, using @
06:25:29 <nornagon> play s@State { ... } = s
06:25:37 <bakert> aha!  another thing i've never heard of.   oooh you people are useful.
06:25:50 <bakert> that's fab.  thanks!
06:26:01 <dons> > let f v@(x:xs) = v ++ xs ++ [x] in f "haskell"
06:26:03 <lambdabot>  "haskellaskellh"
06:26:18 <dons> same principle, but you add record matching
06:26:20 <psykotic> vincenz, interestingly, one of the simpler PE techniques, polyvariant specialization, works on imperative-style flow graphs
06:26:30 <bakert> got it.  thanks folks.
06:27:01 <nornagon> ?paste
06:27:01 <lambdabot> http://paste.lisp.org/new/haskell
06:27:44 <metaperl> @seen Cale
06:27:45 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 4h 22m ago.
06:28:11 <lisppaste2> nornagon pasted "How do I clean this up and get it to fail on bad digits?" at http://paste.lisp.org/display/33824
06:28:27 <nornagon> @channels
06:28:27 <lambdabot> Unknown command, try @list
06:28:38 <dmhouse> There's a #ghc?
06:28:50 <dons> yeah. for ghc dev
06:29:04 <paolino> dons, I use that record (with Array 's inside ) to track a state with  evalState.If I pass to STArray do I need a monad transformer?
06:29:41 <bakert> is there a haskell convention like putting ? on the end of function names for boolean functions?
06:29:43 <metaperl> @type lookup
06:29:45 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> Maybe b
06:29:49 <dons> paolino: sorry, i'm off to bed. I note there's an ST thread happening on the mailing list right now, but Cale might also be able to help :)
06:29:55 <metaperl> soI dont need Data.Map
06:29:56 <nornagon> bakert: tsk, you a ruby kid? :)
06:30:06 <dons> bakert: nope. though 'p' is often used for predicate functoin args
06:30:07 <dmhouse> bakert: not especially. Types tell us all we need to know.
06:30:09 <psykotic> nornagon, i think that started life as a scheme convention.
06:30:25 <dons> bakert: in general though, the types are better documentation ;)
06:30:25 <metaperl> > lookup 2 [(1,'a'), (2,'b')]
06:30:25 <bakert> i was thinking of something lispy, but yes i do like ruby!
06:30:27 <nornagon> ruby pulls a lot from scheme, to be sure.
06:30:27 <lambdabot>  Just 'b'
06:30:32 <dons> some boolean functions begin with 'is'
06:30:38 <dons> :t isSpace
06:30:40 <lambdabot> Char -> Bool
06:30:48 <dons> :t isPrefixOf
06:30:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> Bool
06:30:55 <nornagon> anyway, #haskell <- http://paste.lisp.org/display/33824
06:31:13 <dons> so you can then say: f x | y `isPrefixOf` x && isSpace y = ..
06:31:40 <Terabyte> Hey, wow big channel..
06:31:58 <bakert> it takes this many people to debug my code ...
06:32:11 <dons> bakert: so I'd encourage an isFoo for predicates
06:32:28 <bakert> dons - like it.
06:32:49 <dons> there are some exceptions, such as `elem` and `notElem`, also `null`
06:33:13 <metaperl> dons - your blog is not searchable... any issue with me copying it into a searchable format
06:33:26 <nornagon> `null`, eh?
06:33:36 <Terabyte> Looking for help with a list problem, could I PM sombody?
06:33:37 <dons> metaperl: and putting it where?
06:33:42 <nornagon> an infix function with one argument? :)
06:33:52 <dons> Terabyte: if its a haskell question, just ask away
06:33:58 <dons> nornagon: :)
06:34:02 <Terabyte> sure
06:34:06 <metaperl> at metaperl.com or livingcosmos.org (my domains)  ... using LaTeX or some other searchable document format
06:34:16 <dons> metaperl: html isn't searchable?
06:34:28 <dons> (I've uploaded a few to the haskell.org wiki already though)
06:34:40 <metaperl> googling for site:cgi.unsw.edu.au is not a good option
06:34:51 <dons> so if you wanted to put it on haskell.org, I'd be ok with that
06:35:23 <metaperl> how easy is it to make wikitext of it?
06:35:56 <nornagon> dons: before you run off to bed, can you have a quick peek at http://paste.lisp.org/display/33824 ?
06:36:04 <dons> metaperl: e.g. http://haskell.org/haskellwiki/Tutorials/Programming_Haskell/Introduction
06:36:06 <lambdabot> Title: Tutorials/Programming Haskell/Introduction - HaskellWiki, http://tinyurl.com/yyoppo
06:36:57 <dons> I'd really prefer any content go to haskell.org, metaperl, if you'd like to do that
06:36:59 <metaperl> oh nice. how hard was it to format text for that wiki
06:37:05 <dons> not too hard
06:37:12 <dons> pretty much unchanged, except for the code fragments
06:37:12 <Terabyte> I have a set of values, say.. R,G,B.. Is there any way to generate all possible combinations given the number of times this occurs.. so say... given R,G,B 1 would give [[R],[G],[B]].  R,G,B 2 would give [[R,R],[R,G],[R,B],[G,R]...[B,B]]
06:37:16 <dons> which are wrapped in<hasklel>
06:37:43 <dons> ?go permute list haskell
06:37:45 <lambdabot> http://www.informatik.uni-kiel.de/~mh/curry/listarchive/0066.html
06:37:46 <lambdabot> Title: Re: permute example from Sergio Antoy on 1997-07-04 (Curry mailing list)
06:37:51 <dons> bah
06:38:01 <Terabyte> see i tried [[x,y] | x <- [R,G,B] | y <- [R,G,B] ]
06:38:03 <dons> there's a good article on permutations on the wiki somewhere
06:38:18 <astrolabe> dons:it's not really permutations
06:38:19 <Terabyte> and obviously that works for 2... but how do you do it for any number of lists
06:38:39 <Terabyte> [[x,y.....n] | x <- [R,G,B] | y <- [R,G,B] |........]
06:38:40 <Terabyte> kind thing
06:38:46 <dons> yeah, so that's a zipN
06:38:52 <uccus_> Terabyte: what you are asking for is cartesian products
06:38:53 <dons> zip2, zip3 zip4 ...
06:38:55 <Syzygy-> Terabyte: It's not at all obvious that that works.
06:39:13 <Terabyte> oh rite
06:39:15 <augustss> Terabyte: sequence (replicate n [R,G,B])
06:39:16 <Syzygy-> I get [[R,R], [G,G], [B,B]] from your code.
06:39:33 <Terabyte> ah but you don't get all combinations
06:39:39 <Terabyte> you just get R,R G,G and B,B
06:39:42 <augustss> > sequence (replicate 3 "RGB")
06:39:43 <uccus_> there you go: i think augustss' solution is the one
06:39:49 <lambdabot>  ["RRR","RRG","RRB","RGR","RGG","RGB","RBR","RBG","RBB","GRR","GRG","GRB","GG...
06:39:53 <nornagon> :)
06:39:54 <Terabyte> oh rite
06:40:00 <Terabyte> one second let me try
06:40:04 <nornagon> :t sequence
06:40:06 <lambdabot> forall a (m :: * -> *). (Monad m) => [m a] -> m [a]
06:40:07 <dons> ?let lennart n = sequence (replicate n [LT,EQ,GT])
06:40:08 <lambdabot> <local>:5:41:     Ambiguous occurrence `GT'     It could refer to either `GHC...
06:40:15 <dons> oh weird
06:40:23 <Terabyte> WOW.. works :D thanks alot
06:40:26 <dons> ?let lennart n = sequence (replicate n [1,2,3])
06:40:27 <lambdabot> Defined.
06:40:34 <dons> > L.lennart 4
06:40:35 <lambdabot>  [[1,1,1,1],[1,1,1,2],[1,1,1,3],[1,1,2,1],[1,1,2,2],[1,1,2,3],[1,1,3,1],[1,1,...
06:40:40 <dons> > L.lennart 2
06:40:41 <lambdabot>  [[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]]
06:41:01 <nornagon> > L.lennart 0
06:41:02 <lambdabot>  [[]]
06:41:06 <dons> augustss++ very nice
06:41:09 <nornagon> > L.lennart -1
06:41:10 <lambdabot>  add an instance declaration for (Num (Int -> [[a]]))
06:41:21 <nornagon> NULLITY
06:41:22 * nornagon ducks
06:41:25 <dons> heh
06:41:55 <astrolabe> What does the 'L.' mean?
06:42:07 <dons> Local.* :) or Lambdabot.*
06:42:11 <nornagon> astrolabe: allows you to refer to things defined with ?let
06:42:23 <dons> just an idea we had for keeping ?let defined things in their own namespace
06:42:27 <uccus_> > [L.lennart n | n <- [2, 1, ..]
06:42:27 <lambdabot>  Parse error
06:42:28 <augustss> @type L.lennart
06:42:28 <astrolabe> How long do the definitions last?
06:42:29 <lambdabot> Couldn't find qualified module.
06:42:30 <uccus_> > [L.lennart n | n <- [2, 1, ..]]
06:42:30 <lambdabot>  Parse error
06:42:31 <vincenz> augustss++
06:42:41 <dons> they last till the next ?undefine
06:42:44 <uccus_> > [L.lennart n | n <- [2, 1, ...]]
06:42:44 <lambdabot>  Parse error
06:42:57 <augustss> dons: but you can ask for the @type :(
06:42:58 <uccus_> > [L.lennart n | n <- [1, 2, ..]]
06:42:58 <lambdabot>  Parse error
06:43:01 <nornagon> > [L.lennart n | n <- [2,1..]]
06:43:03 <lambdabot>  [[[1,1],[1,2],[1,3],[2,1],[2,2],[2,3],[3,1],[3,2],[3,3]],[[1],[2],[3]],[[]],...
06:43:05 <dons> no, its not loaded into ghci
06:43:11 <dons> it should do though, more patches
06:43:20 <uccus_> thanks nornargon
06:43:37 <dons> > L.lennart (7 :: Int)
06:43:38 <lambdabot>  [[1,1,1,1,1,1,1],[1,1,1,1,1,1,2],[1,1,1,1,1,1,3],[1,1,1,1,1,2,1],[1,1,1,1,1,...
06:43:43 <dons> > L.lennart
06:43:44 <lambdabot>  Add a type signature
06:43:54 <dons> > ord -- ah well
06:43:56 <lambdabot>  <Char -> Int>
06:44:01 <nornagon> > L.lennart 3.1
06:44:02 <lambdabot>  add an instance declaration for (Fractional Int)
06:44:14 <dons> :t replicate
06:44:15 <lambdabot> forall a. Int -> a -> [a]
06:44:22 <nornagon> > replicate 1
06:44:23 <lambdabot>  Add a type signature
06:44:30 <nornagon> > replicate (1 :: Int)
06:44:31 <lambdabot>  Add a type signature
06:44:35 <dons> the 'a'
06:44:36 <nornagon> oh.
06:44:38 <nornagon> right :P
06:44:43 <nornagon> > replicate 10 1
06:44:44 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
06:44:52 <dons> > \(x :: Int) -> replicate 2
06:44:53 <lambdabot>  Parse error in pattern
06:45:03 <uccus_> > [sequence (replicate n) "RGB" | n <- [2, 1..]]
06:45:04 <lambdabot>    Expecting a function type, but found `[m a]'
06:45:04 <lambdabot>    Expected type: [t -> ...
06:45:13 <dons> > \x -> let_=x::Int in replicate 2
06:45:14 <lambdabot>  Parse error
06:45:19 <uccus_> > [sequence (replicate n "RGB") | n <- [2, 1..]]
06:45:20 <lambdabot>  [["RR","RG","RB","GR","GG","GB","BR","BG","BB"],["R","G","B"],[""],[""],[""]...
06:45:35 <uccus_> > [sequence (replicate n "RGB") | n <- [1, 0..]]
06:45:35 <dons> > \x -> let _ = (x::Int) in replicate 2 x
06:45:36 <lambdabot>  [["R","G","B"],[""],[""],[""],[""],[""],[""],[""],[""],[""],[""],[""],[""],[...
06:45:37 <lambdabot>  <Int -> [Int]>
06:46:00 <uccus_> is that an infinite list?
06:46:11 <augustss> > [1, 0 ..]
06:46:13 <lambdabot>  [1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-16,-17,-18,-19,-20,...
06:46:18 <uccus_> > L.lennart -1
06:46:18 <lambdabot>  add an instance declaration for (Num (Int -> [[a]]))
06:46:23 <astrolabe> dons: lambdabot isn't replying to my /msg
06:46:24 <dons> > length [sequence (replicate n "RGB") | n <- [2, 1..]]
06:46:28 <lambdabot> Terminated
06:46:38 <uccus_> yeah
06:46:58 <augustss> > 1::Word32
06:47:00 <lambdabot>  1
06:47:05 <dons> astrolabe: you might need to be identified?
06:47:08 * nornagon prods people at http://paste.lisp.org/display/33824
06:47:15 <augustss> [2,1::Word32 ..]
06:47:23 <opqdonut> > liftM2 (++) "RGB" "RGB"
06:47:24 <lambdabot>  Couldn't match `[a]' against `Char'
06:47:35 <astrolabe> dons: I am, since about a minute ago
06:47:35 <augustss> > [2,1::Word32 ..]
06:47:35 <nornagon> > -65537 :: Word16
06:47:36 <opqdonut> > liftM2 (,) "RGB" "RGB"
06:47:36 <lambdabot>  [2,1,0]
06:47:37 <lambdabot>  65535
06:47:38 <lambdabot>  [('R','R'),('R','G'),('R','B'),('G','R'),('G','G'),('G','B'),('B','R'),('B',...
06:47:42 <nornagon> heh
06:47:44 <nornagon> ?bot
06:47:44 <lambdabot> :)
06:48:14 <dons> ?pl \x -> liftM2 (,) x x
06:48:15 <lambdabot> join (liftM2 (,))
06:48:26 <dons> > join (liftM2 (,)) "RGB"
06:48:28 <lambdabot>  [('R','R'),('R','G'),('R','B'),('G','R'),('G','G'),('G','B'),('B','R'),('B',...
06:48:32 <opqdonut> > liftM3 (,,) "RGB" "RGB" "RGB"
06:48:34 <lambdabot>  [('R','R','R'),('R','R','G'),('R','R','B'),('R','G','R'),('R','G','G'),('R',...
06:48:49 <dons> > join (liftM4 (,,,)) "RGB" -- I guess not
06:48:50 <lambdabot>  Add a type signature
06:48:51 <astrolabe> dons: sorry, I'm being stupid
06:48:55 <opqdonut> ?pl \x -> liftM3 (,,) x x x
06:48:55 <lambdabot> join (join (liftM3 (,,)))
06:48:58 <opqdonut> yep
06:49:31 <Axioplase> Hi
06:49:39 <dons> opqdonut: cute though
06:49:42 <uccus_> > join ["hi", "there", "everyone"]
06:49:43 <lambdabot>  "hithereeveryone"
06:50:35 <dons> > join (join (join (liftM4 (,,,)))) "RGB"
06:50:37 <lambdabot>  [('R','R','R','R'),('R','R','R','G'),('R','R','R','B'),('R','R','G','R'),('R...
06:50:50 <dons> there should be a joinN ;)
06:50:56 <dons> just for times like this
06:51:05 <lisppaste2> augustss annotated #33824 with "A suggestion" at http://paste.lisp.org/display/33824#1
06:51:19 <dons> ?let join3 = join . join . join
06:51:19 <uccus_> > length $ join (join (join (lifeM4 (,,,))) "RGB"
06:51:19 <lambdabot> <local>:6:22:     Ambiguous type variable `m' in the constraint:       `Monad...
06:51:20 <lambdabot>  Parse error
06:51:26 <dons> :t join
06:51:28 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
06:51:30 <dons> :t join . join . join
06:51:31 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
06:51:35 <nornagon> @botsnack
06:51:35 <lambdabot> :)
06:52:01 <nornagon> keep him well fed :)
06:52:02 <uccus_> > length join (join (join (liftM4 (,,,)))) "RGB"
06:52:03 <lambdabot>    The function `length' is applied to three arguments,
06:52:03 <lambdabot>   but its type `[...
06:52:08 <uccus_> > length $ join (join (join (liftM4 (,,,)))) "RGB"
06:52:09 <dons> ?let join3 :: (Monad m) => m (m (m (m a))) -> m a ; join3 = join . join . join
06:52:09 <lambdabot>  81
06:52:10 <lambdabot> Defined.
06:52:35 <uccus_> dons: how hard is it to define joinN?
06:52:41 <dons> > L.join3 (liftM4 (,,,)) "RGB"
06:52:43 <lambdabot>  [('R','R','R','R'),('R','R','R','G'),('R','R','R','B'),('R','R','G','R'),('R...
06:53:08 <dons> :t let join3 = join . join . join in join3 (liftM4 (,,,))
06:53:09 <lambdabot> forall (m :: * -> *) a1. (Monad m) => m a1 -> m (a1, a1, a1, a1)
06:53:35 <dons> > L.join3 (liftM4 (,,,)) getChar
06:53:37 <lambdabot>  <IO (Char,Char,Char,Char)>
06:53:39 <lisppaste2> augustss annotated #33824 with "BTW" at http://paste.lisp.org/display/33824#2
06:53:53 <nornagon> joinN = foldr (.) $ repeat join ?
06:53:54 <dons> > L.join3 (liftM4 (,,,)) id
06:53:55 <lambdabot>  Add a type signature
06:53:58 <dons> > L.join3 (liftM4 (,,,)) const
06:53:58 <lambdabot>  Add a type signature
06:54:00 <uccus_> can joinN be defined at all?
06:54:05 <nornagon> or rather, replicate n join
06:54:09 <dons> I think its in the same class as zipN or liftn
06:54:23 <uccus_> :type zipN
06:54:27 <augustss> joinN can be given a (non-overloaded) type
06:54:29 <dons> i.e. zip3 .. zip7
06:54:45 <augustss> s/can/can't/
06:54:46 <dons> so there is a zipN, augustss might have it handy ?
06:55:26 <augustss> I don't particularly like any on the zipN formulations
06:55:29 <nornagon> couldn't it just be a fold over a list of [join,join,join]?
06:55:30 <dons> I remember writing zipN was a John Hughes puzzle at a wg2.8 meeting
06:55:33 <dons> and Koen got it out
06:55:35 <uccus_> I don't understand... what type would joinN have?
06:55:36 <augustss> in Haskell
06:55:53 <opqdonut> joinN is easier than zipN, i'd say
06:55:57 <nornagon> :t join
06:55:58 <augustss> uccus_: you can't give it a type in Haskell, unless you play some overloading tricks
06:55:58 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m a) -> m a
06:56:08 <nornagon> :t join . join . join
06:56:09 <lambdabot> forall a (m :: * -> *). (Monad m) => m (m (m (m a))) -> m a
06:56:14 <opqdonut> i'd also say that zipN is nigh impossible
06:56:15 <opqdonut> :)
06:56:22 <uccus_> augustss: overloading tricks?
06:56:28 <dons> typeclass magic
06:56:51 <uccus_> dependent type?
06:56:51 <dons> pose it on haskell-cafe, joinN, and wait for Oleg to send you the soln
06:56:58 <opqdonut> :)
06:57:01 <uccus_> dons: :)
06:57:05 * nornagon needs a Parsec guy. :(
06:57:15 <dons> suggested title: "joinN is impossible"
06:57:19 <nornagon> hehe
06:57:20 <opqdonut> :D
06:57:33 <opqdonut> that ought to do the trick
06:57:49 <augustss> uccus_: a dependent type would work
06:57:50 <opqdonut> it's funny how certain types of people are so predictable :D
06:58:06 <dons> and show that we *need* it for joinN (liftN-1 (,,,N))
06:58:11 <uccus_> which Oleg by the way?
06:58:16 <dons> kiselyov
06:58:29 <uccus_> the one who wrote the 'Overlooked OO' paper?
06:58:41 <sieni> there's only one oleg
06:58:46 <psykotic> ramen
06:58:50 <sieni> you n00b ;-)
06:58:51 <dons> ask for the general version of: joinN (liftMN+1 (,N))
06:58:52 <psykotic> @oleg
06:58:53 <lambdabot> Defined.
06:59:02 <vincenz> bwahaha
06:59:08 <vincenz> sieni: nice reaction :D
06:59:19 <psykotic> @quote oleg
06:59:19 <lambdabot> emu says: olegarithmic
06:59:20 <dons> ?quote oleg
06:59:20 <lambdabot> emu says: olegarithmic
06:59:28 <psykotic> @quote oleg
06:59:29 <lambdabot> emu says: olegarithmic
06:59:34 <dons> ?quote micro
06:59:34 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
06:59:34 <Axioplase> *
06:59:35 <lambdabot> sing with me?
06:59:36 <psykotic> too bad. i was hoping for the NP one.
06:59:47 <augustss> http://www.brics.dk/RS/98/38/BRICS-RS-98-38.pdf
06:59:57 <psykotic> Oleg solves NP-complete problems in polynomial time... in the type system.
07:00:03 <dons> ?quote olegweek
07:00:04 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
07:00:21 <dons> ?quote metaolegs
07:00:21 <lambdabot> audreyt says: assembly would require metaolegs (or megaolegs)
07:00:40 <dons> ?quote Oleg cornered me
07:00:41 <lambdabot> No quotes match. Do you think like you type?
07:00:49 <vincenz> @quote denotational
07:00:49 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
07:00:53 <vincenz> dons++
07:00:55 <vincenz> nice
07:01:02 <psykotic> is the oleg now the recognized unit of type system hacking mastery?
07:01:08 <dons> ?quote ccshan
07:01:09 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
07:01:09 <lambdabot>  what you just said?"
07:01:09 <augustss> oh yes
07:01:22 <psykotic> augustss, i didn't know it had become lower case, like 'abelian' :)
07:01:37 <vincenz> psykotic: oleg can not be expressed in the current type system of lambda^3
07:01:43 <dons> ?quote Oleg.*implant
07:01:43 <augustss> psykotic: maybe it should be upper case
07:01:43 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
07:02:01 <dons> ?quote AshleyYakeley
07:02:01 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
07:02:18 <vincenz> (ps): brics in italy is a company of luggage
07:02:27 <dons> ?quote RSA.on.type.level
07:02:27 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
07:02:31 <psykotic> I heard that Oleg implemented Space Invaders in the type system.
07:02:43 <dons> ?quote OlegFacts
07:02:43 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
07:02:53 <vincenz> @quote a.*b
07:02:53 <lambdabot> qwe1234 says: i don't know about you, but i only use c++ because it gives static compile-time guarantees that assembly could never give.
07:02:58 * vincenz whistles
07:03:09 <dons> ?quote advanced.compiler
07:03:09 <lambdabot> Pseudonym says: "Assuming an advanced compiler, your code will be sent to Oleg who will implement it in the type system."
07:03:10 <nornagon> ?quote .*
07:03:10 <lambdabot> ghc says: foreign declaration uses deprecated non-standard syntax
07:03:25 <dons> ?quote milli-Olegs
07:03:25 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
07:03:27 <vincenz> @quote because[ ]*
07:03:27 <lambdabot> No quotes for this person. Wrong!  You cheating scum!
07:04:07 <augustss> Given that strength of the Haskell type system it wouldn't be that hard to write a compiler from some language into a Haskell type.
07:04:12 <Axioplase> ?quote lambdabot
07:04:13 <lambdabot> lambdabot says: [in #haskell] there are a lot of weirdos on here
07:04:26 <dons> augustss: mmm!
07:04:36 <nornagon> oh dear
07:04:39 <nornagon> :D
07:04:45 <psykotic> i'm sure that has already been done
07:04:50 <Axioplase> By the way, is Haskell's type system a Hindley-Milner one ?
07:04:55 <nornagon> yes
07:05:02 <psykotic> Axioplase, except... not really :)
07:05:05 <dons> well there's at least 2 turing machines in the type system
07:05:14 <dons> so you just have to target that
07:05:14 * uccus_ (the n00b) thought type systems too strong is bad for code health
07:05:27 <Axioplase> [15:58]      psykotic | Axioplase, except... not really :)
07:05:40 <Axioplase> argh.
07:05:58 <vincenz> uccus_: not if inferred
07:06:10 <augustss> psykotic: but there's still H-M somewhere in there behind the bells and whistles
07:06:10 <psykotic> maybe that's my personal take on it. even ignoring orthogonal extensions like typeclasses (which sit well with HM type inference), things like higher ranked polymorphism are rather non-HM like, i'd say.
07:06:29 <uccus_> is there a type system more general than HM that is completely inferrable?
07:06:30 <Axioplase> hum.. I see
07:06:51 <vincenz> psykotic: it's constraint-based
07:06:53 <augustss> uccus_: there's plenty
07:06:53 <vincenz> ?
07:07:01 <Axioplase> uccus_: The more general, the less decidable ?
07:07:07 <psykotic> vincenz, that doesn't say much :)
07:07:17 <vincenz> I was askig
07:07:20 <vincenz> +n
07:07:23 <uccus_> within Haskell? decidable?
07:07:25 <vincenz> psykotic: and merely as counterpoint to it being hm
07:07:44 <psykotic> well, HM can be expressed in terms of separate constraint generation and solution
07:07:50 <nornagon> augustss: btw, no, it doesn't fail on bad digits
07:08:06 <nornagon> parsing "#o129" returns Number 10
07:08:18 <vincenz> psykotic: true
07:08:20 <vincenz> hm
07:08:26 <augustss> uccus_: well, take the class system in Haskell(98), it's still a decidable extension to HM
07:08:44 <uccus_> HM + typeclasses ... = H98?
07:09:10 <psykotic> HM sexed-up with some native support for ADTs, i think
07:09:23 <psykotic> and probably something else
07:09:29 <augustss> nornagon: doesn't give Number 10, and a 9 left to parse?
07:09:38 <nornagon> um, possibly.
07:09:41 <uccus_> so no H98 program needs type annotations?
07:09:44 <nornagon> But shouldn't it throw an error?
07:09:55 <vincenz> uccus_: no there are a few corner cases
07:09:56 <nornagon> (what if I want it to?)
07:09:58 <augustss> uccus_: polymorphic recursion does
07:10:00 <vincenz> uccus_: take for instance (read . show)
07:10:00 * uccus_ is somewhat confused
07:10:02 <vincenz> er
07:10:03 <vincenz> erm
07:10:08 <vincenz> (show . read)
07:10:25 <syntaxfree> is "far removed" hyphenized?
07:10:27 <syntaxfree> "far-removed"?
07:10:36 <nornagon> syntaxfree: can be
07:10:42 <nornagon> depends on context
07:11:15 <uccus_> vincenz: that's only because read :: String -> a, a very weird type, right?
07:11:34 <syntaxfree> " This will allow most of the IO a beginner taking his first steps with Haskell should need, and isn't really that far-removed from the complete, monadic view."
07:11:39 <vincenz> uccus_: I wouldn't call it weird
07:11:40 <vincenz> but yeah
07:11:42 <psykotic> that shouldn't have hypen
07:11:50 <vincenz> +1
07:12:00 <syntaxfree> okie :)
07:12:00 <psykotic> if there was a noun after removed i think you'd need it for clarity
07:12:16 <psykotic> the far-removed thoughts
07:13:55 <psykotic> i'm also never sure about comma-separated adjectives. you can only do that if the second adjective is inconsequential, parenthetical, right?
07:14:23 <dons> hehe, the top 10 words used in the channel in 2007: state, Haskell, think, would, module, import, monad, forall, function, record
07:14:43 <psykotic> #11 is "yo my bitches"? oh wait, not a single word
07:14:44 <psykotic> :)
07:14:54 <augustss> The reason (show . read) needs a type signature has nothing to do with decidability, it because it's ambiguous.  But the reason polymorphic recursion needs a signature is because of decidability.
07:14:55 <dons> heh
07:15:01 <psykotic> is he gone now?
07:15:03 <vincenz> psykotic: you mean to ay, whenn it is an adjective
07:15:11 <dons> yeah, off to play ruby last I heard
07:16:28 * nornagon prods augustss 
07:16:31 <psykotic> vincenz, here's an example of what i mean. "There were two men in the room. The tall blue-eyed man sat down." would be correct, but I don't think "There were two men in the room. The tall, blue-eyed man sat down." would be, strictly speaking, because blue-eyed is essential in identifying which man i'm talking about in the second sentence.
07:16:35 <vincenz> augustss: what is polymorphic recursion?
07:16:41 <augustss> nornagon: yes?
07:17:01 <vincenz> psykotic: oh I was referring to far-removed but in this case, I still think the second is acceptable.
07:17:13 <nornagon> augustss: it does leave the 9 to be parsed, but i don't want it to; what would be the best way of going about making it throw some kind of error?
07:17:20 <psykotic> yeah, i think i'm citing some vague recollection of strunk and white which no-one likely respects in the real world.
07:17:38 <augustss> vincenz: when you have a recursive function and the recursive call is not at the same type as the definition
07:18:05 <vincenz> ah right
07:18:17 <vincenz> foo x = case x of Maybe y -> foo y
07:18:29 <augustss> for instance
07:18:34 <vincenz> (though I thought TCs would handle that just fine
07:18:56 <augustss> you can do it with TC
07:19:15 <vincenz> well if you don't you can't have a recursive call of a different type
07:19:32 <Axioplase> Does someone have an article about coroutines in haskell with call/cc ? all that I find is scheme related, and uses "set!"... (in a few words, can coroutines be implemented without a state ?)
07:19:33 <vincenz> or you'd have two differing definitions of a function
07:19:51 <psykotic> Axioplase, there's a neat way to do it using shift/reset. you can check out the pugs code for a specific example.
07:20:06 <augustss> nornagon: you could collect hexDigits in your many1 and the fail if the readXXX doesn't return what you expect
07:20:09 * psykotic pokes audreyt
07:20:51 <vincenz> Axioplase: read the end of my blog article: http://notvincenz.blogspot.com/2006/11/delimited-continuations.html
07:20:53 <nornagon> augustss: ah, so match on the snd of hexdigits?
07:20:54 <lambdabot> Title: lambda.oasis: Delimited continuations, http://tinyurl.com/yaj49t
07:20:55 <vincenz> :D
07:21:12 <nornagon> er, readHex
07:22:58 <augustss> Axioplase: have a look at http://www.cs.chalmers.se/~koen/pubs/entry-jfp99-monad.html
07:23:00 <lambdabot> Title: Koen Claessen - Publications
07:23:28 <augustss> Axioplase: it's not exactly co-routines, but simple proceses
07:23:52 <augustss> it's also a very nice paper :)
07:25:32 <Axioplase> ok thanks everyone, I'm to read those papers right now
07:28:06 <pejo> augustss, oh, about that online PE you wrote, how is the decision to stop taken?
07:28:26 <vincenz> pejo: link?
07:29:16 <pejo> vincenz, somewhere in the logs here, uh, in December.
07:29:21 * vincenz winces
07:33:00 <augustss> pejo: when there's nothing left to do :)
07:33:13 <vincenz> augustss: so what if you have an infiniloop
07:33:21 <augustss> then it loops
07:33:39 <pejo> augustss, oh, so termination isn't guaranteed?
07:33:59 <augustss> but the first language i wrote a PE for did not have the ability to make infinite loops
07:34:29 <augustss> and the second language it would probably correspond to generating infinite hardware,  so you don't want to do that anyway
07:34:46 <syntaxfree> isn't it always possible to synthetize an infinite loop from a finite loop?
07:34:50 <augustss> pejo: no, I didn't guarantee termination
07:34:55 <syntaxfree> for (i in 1:10) { i =1; }
07:38:34 <pejo> augustss, for bluespec?
08:03:48 <psykotic> syntaxfree, it's probably better to think in terms of primitive vs general recursion.
08:28:29 <ph8> can i have, a guard within a guard, or do i have to && things together?
08:28:39 <ph8> (in one guard)
08:28:59 <xerox> &&
08:29:24 <syntaxfree> && would be easier than nested guards anyway.
08:30:16 <ph8> yeh i guess
08:30:17 <ph8> ty
08:37:49 <benja_> there is also ','?
08:38:04 <benja_> or perhaps only if you activate pattern guards
08:43:05 <ph8> > -- Are these comments legal in lhs?
08:43:06 <lambdabot>  Parse error
08:43:14 <ph8> is that a no, or a lamdabot error
08:43:15 <ph8> ?
08:43:15 <opqdonut> > 3 -- yes
08:43:17 <lambdabot>  3
08:43:18 <ph8> coolio
08:45:03 <lisppaste2> ph8 pasted "Dastardly Type Errors (Are there any other kind?)" at http://paste.lisp.org/display/33825
08:46:57 <pesco> vincenz: My suggestion: Don't add finding out what to code to your resolutions. Because it will never stop.
08:48:19 <ph8> would anyone be able to help me with that evul type error? :/
08:48:21 <ph8> it's really weird
08:50:56 <vincenz> pesco: hmm?
08:50:59 <ph8> hmm. stumped i am
08:51:03 <vincenz> pesco: how's that?
08:52:08 <astrolabe> ph8: line 62 has 'last (last a)' which implies that a is a list of lists
08:52:13 <pesco> vincenz: Ah, I just remembered that I used to ask myself "What could I code...?" which, nowadays, I don't. Instead I'm drowning in stuff I ought to code sometime. ;)
08:52:39 <ToRA> ph8: (head a) needs to return a function (to have the argument theMap applied to it).  but a is bound to to a [[Char]]
08:52:43 <Stinger_> ph8 dont you need more arguments to repgen in 65?
08:53:08 <ToRA> i think you mean maybe "repGen (head a) theMap soFar" on ln 65
08:53:12 <vincenz> pesco: :D
08:53:12 <astrolabe> ph8: but line 68 seems to apply (head a) to some arguments.
08:53:21 <vincenz> pesco: I never have any projects :/
08:53:24 <Stinger_> ToRA yeah
08:53:24 <vincenz> At least not public onnes
08:53:25 <astrolabe> er I mean 65
08:53:32 * vincenz has some for his phd, but those are confidential
08:53:37 <lisppaste2> ph8 annotated #33825 with "Specifying head a as a [list]" at http://paste.lisp.org/display/33825#1
08:53:45 <wolverian> hm. why does the conjure TODO say linux has no sendfile(2)?
08:57:11 <Vq^> wolverian: maybe because it works differently / does something else in linux
08:57:39 <Vq^> wolverian: it doesn't seem to be covered by any unix-standard
08:59:24 <ph8> ah
08:59:29 <ph8> that's helped astrolabe, cheers
08:59:34 <ph8> it's just my composition that's messed up now
08:59:38 <ph8> (reverse . tail a . reverse ))
08:59:46 <ph8> that won't get the last element of a, will it? ;)
08:59:46 <wolverian> Vq^, perhaps. strange way to put it though.
09:00:05 <pejo> vincenz, isn't secret results.. hard to judge for the thesis commitee?
09:00:06 <wolverian> quick skim of the manpage seems similar to the fbsd one.
09:00:07 <vincenz> pesco: but yeah, sometimes I get something similar to you "so many things to do" ... leading to paralysis.... as we all know "the paradox of choice" :)
09:00:18 <vincenz> pejo: not results but frameworks/libraries
09:00:42 <vincenz> and if anything is patentable, we need to ask a patent before we publish
09:00:48 * vincenz is doing hsi phd at a research institute
09:00:53 <ToRA> > reverse.tail.reverse $ [1,2,3,5]
09:00:55 <lambdabot>  [1,2,3]
09:01:33 <astrolabe> ph8: did you see the comments from Stinger_ and ToRA?
09:01:58 <ph8> yes, all helped sort it - compiles now
09:02:04 <ph8> whether it's going to work is a different matter :)
09:02:10 <astrolabe> :)
09:02:54 <Vq^> wolverian: my manpage says "It should not be used in portable programs."
09:03:25 <wolverian> Vq^, yes. mine too. I don't see how that's relevant though.
09:03:41 <wolverian> (I mean, directly relevant, since the crux is comparing the fbsd and linux functions, not determining how portable they are.)
09:06:57 <joelr1> good day!
09:06:58 <Vq^> yeah, but maybe someone wrote it on BSD and read something like "sendfile(2) is bsd-only"
09:07:05 <Vq^> hello joelr1
09:07:15 <wolverian> Vq^, ah, good point. thanks.
09:07:29 <joelr1> has anyone used GdH?
09:17:38 <esap> Why are strict indexed categories needed to model type constructors of type theory in category theory? Wouldn't just using (restricted types of) functors be enough?
09:24:51 <ph8> >		Debug.Trace.trace ("One match for " ++ (show a) ++ " appending " ++ (show (head (reverse a))) ++ "(soFar = " ++ (soFar ++ ([head (reverse a)]))) ++ ")") $
09:24:56 <ph8> the brackets aren't out of alignmenton that arethey?
09:24:59 <ph8> it's not just me?
09:25:04 <ph8> hugs insists there's an out of place ) there
09:26:25 <tibbe> more ) than / I think
09:26:26 <ph8> ?type length
09:26:27 <lambdabot> forall a. [a] -> Int
09:26:28 * allbery_b ends up with -1 and agrees with hugs
09:26:28 <ph8> ?type count
09:26:31 <lambdabot> Not in scope: `count'
09:26:39 <tibbe> than ( *
09:26:40 <ph8> oh bugger
09:26:42 * ph8 looks again
09:26:50 <ph8> are you counting the one in quotes?
09:26:51 <pejo> ph8, it's not balanced, if that is why you're asking. The third ) from back closes the first one.
09:26:52 <ph8> ")"
09:26:56 <tibbe> no
09:27:03 <ph8> ah
09:27:04 <ph8> hmm
09:27:07 * ph8 scratches head like monkey
09:27:09 <allbery_b> not counting the quoted ones, no (but they'
09:27:14 <allbery_b> re also balanced so wouldn't matter
09:27:27 <tibbe> use a $ after Debug.Trace.trace and save you one () that needs counting
09:27:28 <esap> immediately after ] one extra parenthesis
09:27:30 <ph8> rofl
09:27:33 <ph8> i was counting the ( in quotes though
09:27:35 <ph8> <-- muppet
09:27:38 <tibbe> ie trace $ _string_
09:27:52 <ph8> cheers tibbe
09:28:07 <joelr1> dons: how come you like curses so much?
09:28:25 <allbery_b> that won't work right, trace takes 2 arguments and $ will cause it to have one
09:28:52 <allbery_b> (only one is shown there, but that's not relevant)
09:29:54 <tibbe> ah
09:29:59 <tibbe> thought there was just one
09:30:04 <tibbe> ?type trace
09:30:05 <lambdabot> Not in scope: `trace'
09:30:10 <tibbe> ?type Debug.Trace.trace
09:30:11 <allbery_b> :t Debug.Trace.trace
09:30:11 <lambdabot> forall a. String -> a -> a
09:30:12 <lambdabot> forall a. String -> a -> a
09:30:26 <ph8> eww
09:30:28 <ph8> indentation error :/
09:33:55 <syntaxfree> heh. digg uses wordpress now?
09:34:11 <syntaxfree> ah, just the blogs.
09:34:12 <syntaxfree> duh.
09:34:57 <syntaxfree> gah, wrong channel too.
09:35:02 <syntaxfree> didn't mean to say this here.
09:41:48 <lisppaste2> ph8 annotated #33825 with "repGen as it stands now - another weird type error?" at http://paste.lisp.org/display/33825#2
09:42:09 <ph8> i'm just trying to 'show' something, and it says i'm sending trace the wrong argument?
09:42:19 <ph8> it's probably got something to do with my use of !! but i don't know what :/
09:44:34 <allbery_b> well, for one thing, I suspect the "IO a" is from randomNo (random numbers are in IO)
09:44:42 <allbery_b> (usually)
09:45:20 <ph8> hmm
09:45:29 <ph8> does that mean i need to declare some magical return type somehow?
09:45:43 <ToRA> ph8: is there a missing $ at the end of the line?
09:45:45 <ph8> or use show on randomNo?
09:45:58 <ph8> ToRA: Atm it generates an unexpected ';' error when i put it in
09:46:26 <allbery_b> hm, actually, sinceyou also use it later, I'm unsure.  suppose I'd need to see where randomNo is coming from
09:46:28 <syntaxfree> ph8: it means you have to write functions that act on pure values, i.e. nonrandom numbers.
09:46:39 <ToRA> ph8: ah ok, what is the type signature for the "Debug.Trace.trace" function
09:46:42 <ToRA> ?
09:46:43 <syntaxfree> and *then* apply them to the random number in IO code via bind.
09:46:50 <syntaxfree> ph8: you need to separate concerns.
09:47:00 <opqdonut> :t Debug.Trace.trace
09:47:02 <lambdabot> forall a. String -> a -> a
09:47:16 * ToRA should have more faith in lambdabot
09:47:26 <allbery_b> also, I wonder what type randomNo actually has.  if it's not fully applied, you may have a function instead of a value...
09:47:49 <ToRA> the problem isn't directly with the random, it's with the fact that the debug.trace call hasn't enough arguments passed to it
09:48:06 <allbery_b> no, it's being used just like the others
09:48:14 <allbery_b> trace stringexp \n value
09:48:38 * allbery_b would prefer the value part be indented slightly, but layout probably doesn't require it
09:49:25 <ph8> i need to do what with binding pure values? :s
09:49:34 <allbery_b> hm, but it should have a $ before the expression, like the thers, yes
09:49:38 <allbery_b> *others
09:49:49 <ph8> presumably the io stuff was causing a weird error
09:50:02 <ToRA> oh
09:50:10 <ph8> syntaxfree: so would making another function getRandomNumber, returning randomNo <- randomRIO... solve the problem?
09:50:16 <ph8> or would that just be the same?
09:50:30 <ph8> readded the $ now
09:50:36 <allbery_b> unexpected ';' could be a layout issue
09:50:51 * allbery_b hopes you're not using tabs, they just cause confusion
09:51:15 <ph8> would i ? ;)
09:51:16 <ph8> i like tabs
09:51:22 <ph8> at least while you're making things
09:51:29 <ph8> i'd be happy converting them to spaces when something got published
09:51:35 <ph8> but it'll just consume time otherwise
09:52:10 <allbery_b> well, yes, except that getting tabs and spaces mixed up often leads to weird errors by confusing the layout parser
09:52:24 * allbery_b is not actually that fond of layout, precisely for that reason
09:53:11 * dylan sets expandtab for haskell files
09:53:18 <ToRA> ph8: if you want to use IO anywhere (i.e. the randomRIO function) you will need to put the return type of the entire function under IO (i.e. repGen :: [String] -> Map [String] [String] -> [String] -> IO [String]
09:59:33 <ph8> ty ToRA, will try that
10:00:07 <ToRA> it's not going to solve the initial type error, but it will help with the next problem you will face
10:00:13 <ph8> eep
10:00:24 <ph8> how do i go about solving that type error? any hints
10:00:30 <ph8> i keep missing off question marks :p
10:01:31 <Cale> whoa, what is repGen doing?
10:01:49 * dmhouse tries to wrap his head around Category Theory
10:01:58 <ToRA> so the "b -> b does not match IO a" type error needs the $ at the end of the Debug.Trace.trace line (8 lines from the bottom)
10:02:10 <ToRA> and then for the layout problem to be fixed
10:02:10 <joelr1> Cale: what is repGen?
10:02:16 <Cale> http://paste.lisp.org/display/33825#2
10:02:20 <vincenz> 18:46 < ToRA> ph8: if you want to use IO anywhere (i.e. the randomRIO function) you will need to put the return type of the entire function under IO (i.e. repGen :: [String] -> Map [String] [String] -> [String] -> IO [String]
10:02:23 <ph8> ERROR "Main.lhs":84 - Syntax error in expression (unexpected `;', possibly due to bad layout)
10:02:24 <xerox> dmhouse: you've got a book?
10:02:38 <ph8> but it's more than likely not due to bad layout?
10:02:41 <Cale> joelr1: apparently the function which ph8 is working on
10:02:45 <dmhouse> xerox: nope, just getting what I can from Wikipedia, a few papers and hawiki.
10:02:47 <ToRA> ph8: can you paste that
10:02:50 <ph8> i've seen that error multiple times and it's never been because of layout :p
10:02:51 <ToRA> and mark line 84
10:02:52 <joelr1> Cale: ok
10:02:52 <ph8> yup
10:03:01 <vincenz> oh
10:03:01 <vincenz> damn
10:03:04 <vincenz> Cale: talk about illegible
10:03:05 <dmhouse> Does the set of Haskell types with higher-order types as morphisms form a category?
10:03:08 <ToRA> vincenz: ???
10:03:14 <ph8> Cale: It's going to repeatedly generate the next word in a sequence, until the end of a sentence
10:03:18 <ph8> using NGrams
10:03:23 <dmhouse> (I know the standard category is with functions as morphisms, but I'm interested here.)
10:03:27 <ph8> en.wikipedia.org/wiki/N-Gram iirc
10:03:32 <vincenz> ToRA: was for joelr1
10:03:44 <ToRA> vincenz ah 'k
10:04:36 <ph8> 84 is *84*'ed tora
10:04:47 <ph8> just waiting for it to submit!
10:04:54 <Syzygy-> dmhouse: Higher order types means types of type * -> *, eh?
10:04:55 <fasta> If I import qualified Foo (bar);import Foo, why do I need to specify that I also want to hide bar from Foo?
10:05:08 <dmhouse> Syzygy-: err, yeah, I meant that :)
10:05:13 <vincenz> bwahaha: http://www.dilbert.com/comics/dilbert/archive/dilbert-20061231.html
10:05:17 <lambdabot> Title: Dilbert Comic Strip Archive - Dilbert.com - The Official Dilbert Website by Scot ..., http://tinyurl.com/y8qbk2
10:05:35 <lisppaste2> ph8 annotated #33825 with "New and exciting..." at http://paste.lisp.org/display/33825#3
10:05:38 <fasta> If this can't be specified, I am afraid I will need to add one more item to the Haskell list of flaws
10:05:47 <ph8> there we go ^
10:06:18 <dmhouse> fasta: well, because otherwise you'd be bringing bar into scope without qualification.
10:06:26 <dmhouse> Which is surely not what you want.
10:06:54 <Cale> ph8: the call to repGen is part of the previous line, make sure it's indented a little further
10:07:11 <ToRA> vincenz: ???
10:07:14 <ToRA> oops
10:07:17 <fasta> dmhouse: I mean that importing bar qualified should imply that I don't want to import it from that same module non-qualified
10:07:34 <fasta> dmhouse: in other words: the compiler should recognize this situation
10:07:38 <Cale> (it appears like it might be indented correctly here only because you put that *84* at the start of the line)
10:08:24 <ph8> oh my cale
10:08:27 <xerox> dmhouse: I don't think they form a category.
10:08:27 <ph8> if i add two spaces
10:08:31 <ph8> the error magically goes away
10:08:36 <Cale> indeed
10:08:43 <Cale> Actually, same goes for the other cases, though they won't give you problems because you're technically allowed to start it on the same line as the previous one
10:08:45 <ph8> that's a little bit naff
10:08:49 * ph8 shrugs
10:08:53 <ph8> i've done it with the others now for consistency :)
10:08:57 <Cale> (I think that's a dumb exception)
10:08:58 <ph8> and i've just won £10 in the lottery
10:09:00 * allbery_b did mention layout vs. function calls...
10:09:00 <ph8> bonza.
10:09:43 <xerox> dmhouse: oh, nevermind, my brain is off.
10:09:48 <dmhouse> fasta: well, to keep the specification simple, this way was chosen. I'd rather have a simple definition of the import keyword as something that brings in all names from the specified module into scope, with qualification if you asked for it.
10:10:12 <dmhouse> fasta: rather have that simple definition than a complex one that might save keystrokes but has a lot of esoteric corner cases, I mean.
10:10:34 <ph8> hmm
10:10:39 <ph8> now because i have IO [[Char]] as the return type
10:10:48 <ph8> | otherwise = Debug.Trace.trace ("Final soFar = " ++ (show soFar)) (soFar ++ ([last a]))
10:10:51 <ph8> doesn't satisfy the IO type
10:10:57 <ph8> is there a way around that?
10:11:02 <dmhouse> ?type return
10:11:04 <lambdabot> forall (m :: * -> *) a. (Monad m) => a -> m a
10:11:09 <ToRA> return []
10:11:13 <dmhouse> ph8: return throws a value into a monad.
10:11:17 <dmhouse> > return 4
10:11:18 <lambdabot>  add an instance declaration for (Show (m a))
10:11:19 <dmhouse> Err
10:11:24 <dmhouse> > return 4 :: Just Int
10:11:25 <lambdabot>  Not in scope: type constructor or class `Just'
10:11:29 <dmhouse> > return 4 :: Maybe Int
10:11:30 <dmhouse> Sorry.
10:11:30 <lambdabot>  Just 4
10:11:42 <ph8> danke
10:11:51 <xerox> dmhouse: just, what is the identity?
10:11:58 <dylan> > return 1 :: [Int]
10:12:00 <lambdabot>  [1]
10:12:24 <dmhouse> xerox: Identity?
10:12:36 <dmhouse> As in the tycon.
10:13:32 <xerox> To each object A is assigned an arrow 1_A : A -> A called "the identity on A". If f : A -> B, then f = f 1_A and f = 1_B f.
10:14:21 <dmhouse> Oh, good point.
10:14:31 <dmhouse> Identity : T -> Identity T for some T.
10:14:39 <dmhouse> Which is not T -> T.
10:15:21 <dmhouse> Wait, but they are isomorphic.
10:15:24 <dmhouse> Yeah, I think this works.
10:15:44 <dmhouse> You just have to interpret the notion of 'A equals B' as 'A isomorphic to B'.
10:16:52 <Syzygy-> Oh, so you work with the 'skeleton' of the types then?
10:17:01 <dmhouse> What do you mean?
10:17:23 <dmhouse> Module data constructor wrapping?
10:17:26 <dmhouse> *Modulo
10:17:36 * dmhouse will brb.
10:17:39 <Syzygy-> If you pick one representative for each isomorphism class of a category, you get (I think) a subcategory, or maybe just a collection of objects, consisting of representatives for isomorphism classes.
10:17:48 <Syzygy-> Point being that isomorphic is not the same as equals.
10:19:35 <vincenz> equality is overrated
10:19:45 <allbery_b> just ask floating point? :)
10:19:50 <vincenz> and in some case equality is not distinguisable from isomorphic
10:22:33 <Syzygy-> vincenz: And in quite a few others, there's a huge difference.
10:22:44 <xerox> f : X -> Y is an isomorphism if and only if there exist g : Y -> X for which both equations gf = 1_X and fg = 1_Y are true. Such g is called a two-sided inverse for f.
10:24:26 <Syzygy-> Ayup.
10:25:01 <vincenz> Syzygy-: for instance?
10:25:25 <Syzygy-> For instance when looking at subgroups of a given group, it makes a difference -which- subgroup even though they are isomorphic.
10:25:37 <Syzygy-> They'll (IIRC) be conjugate, but still different.
10:25:48 <Syzygy-> And may well have different quotients should they all be normal.
10:25:50 <vincenz> oh right
10:26:19 <Templar2> is it enougth to know list comprehenshion for the introduction functional programing course to pas?
10:26:34 <opqdonut> :D
10:26:36 * Syzygy- tends to take the stance "oh, they're just isomorphic, and we can do it all with abstract nonsense" in my workgroup. Alas, the group theorists know that this is not so and never hesitate to tell me I'm wrong.
10:29:39 <drain> I have a question not directly related to haskell but to algorithms/data structures in general
10:29:55 <drain> I have a bunch of events e_i that I want to associate with frequences f_i, and then from these I need to select any event e_i with probability f_i / S where S is the sum of the f's.  But also, I need to frequently increase or decrease the frequency for any given event.  I want to do any of these operations quickly, not taking O(n) time
10:29:55 <joelr1> does anybody know if fa.haskell (google group) can post back to the mailing lists?
10:30:29 <opqdonut> hmm a tough one
10:30:50 <xerox> In fact data Identity a = Identity a just adds a level of indirection, I think, you can define 1_X as ij where i : Identity X -> X and j : X -> Identity X.
10:30:51 <drain> I can put the ogive of the frequencies into an array and search for a randomized value from 1 to S, and that gives me lg n time for selection, but then it's not easy to change the probability of something
10:31:11 <opqdonut> drain: how about putting them into a tree as leaves
10:31:33 <opqdonut> and each inner node would contain the accumulated frequency of it's children
10:31:43 <opqdonut> that'd mean lg n selection and update
10:31:58 <opqdonut> if you catch my drift
10:32:11 <drain> how do you update in lg n using that?
10:32:38 <drain> hmm ok I see what you mean
10:32:55 <drain> you just increase all the frequencies on the path to the leaf
10:32:58 <opqdonut> yep
10:33:08 <drain> thanks
10:33:15 <opqdonut> you get how the selection works?
10:33:24 <drain> you just follow a path to the leaf
10:33:28 <opqdonut> random float [0,S] and then traverse
10:33:29 <opqdonut> yes
10:33:31 <drain> pick a randmo value r from 1 to S
10:33:39 <drain> same as I as doing with the array
10:33:45 <opqdonut> trees are always the solution when you want a compromise
10:33:47 <opqdonut> yes exactly
10:34:45 <shapr> yay! 2007!
10:35:06 <drain> ah but then it gets complicated if you want to add a new event
10:35:07 * vincenz woots shapr 
10:35:15 <opqdonut> drain: true, true
10:35:21 <joelr1> shapr: yo!
10:35:29 <opqdonut> but that's just balanced binary trees
10:35:42 <drain> yeah but a major pain to do right
10:35:45 <opqdonut> but you have to remember the sums when balancing
10:35:46 <opqdonut> yeah :)
10:35:57 <shapr> hiya joelr1
10:36:09 <opqdonut> i'd say use a ready btree implementation
10:36:10 <shapr> joelr1: What's up? Did you have a question for me?
10:36:41 <joelr1> shapr: nah, but i did appreciate finding a link to yampa+gadt on your blog
10:36:59 <shapr> hm, I thought I mentioned it once?
10:37:08 <shapr> oh, I see what you wrote now =)
10:37:12 <shapr> I misread.
10:37:19 <xerox> joelr1: you're the one packaging yampa+gadt?
10:37:22 <joelr1> shapr: i cleaned it up for ghc 6.6 and cabalized it. asked henrik if he wants the changes or if i should set up a darcs repo on my server. awaiting his reply.
10:37:27 <joelr1> xerox: yes, why?
10:37:32 <xerox> Ah, where is it? (:
10:37:57 <joelr1> xerox: nowhere yet. i asked henrik if he wants to publish or if i should. no reply yet.
10:38:12 <xerox> Ah, okye.
10:38:15 <joelr1> i really don't want to have a thousand repos bloom :D
10:38:25 <shapr> joelr1: Woo,where's the repo?
10:38:36 <joelr1> shapr: read, read, carefully!
10:38:50 <shapr> I did, I still want a copy of the repo =)
10:39:24 <shapr> Dang, I need to talk to SyntaxNinja... or other Galois rep
10:40:12 <joelr1> shapr: what for /galois/?
10:40:43 <shapr> I have just become aware of some Haskell work they have accomplished that I want to use now now now
10:41:13 <joelr1> shapr, xerox: i'll wait a couple of days for henrik and then will just make a small announcement of my repo. i want to experiment with yampa and trading systems
10:41:17 <joelr1> shapr: what's the work?
10:41:55 <Axioplase> Hum... I have some little trouble with a random generator.. I want to generate a list of random numbers. I use a State to get/put the current seed. "foo" returns such a random number. To get a list, I tried replicate n foo, but I always get the same number... How can I reevaluate foo ?
10:42:20 <ToRA> @type randoms
10:42:22 <lambdabot> forall a g. (Random a, RandomGen g) => g -> [a]
10:42:34 <Axioplase> ... thanks
10:42:41 <xerox> ?type next
10:42:43 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
10:43:09 <Axioplase> xerox: I used next...
10:43:29 <ToRA> with randoms you won't need to thread the generator around (or use state)
10:43:32 <joelr1> shapr: c'mon! tell me!
10:43:49 <ToRA> but you shouldn't really re-use the generator
10:44:12 <xerox> > map fst . iterate (next . snd) $ (0,mkStdGen 31337)
10:44:13 <lambdabot>  [0,1253918040,442897452,1534290608,654720615,731267292,1171086700,1612525813...
10:44:41 <ToRA> > randoms (mkStdGen 31337)
10:44:42 <lambdabot>  Add a type signature
10:44:46 <ToRA> \o/
10:44:56 <ToRA> > randoms (mkStdGen 31337) :: [Integer]
10:44:58 <lambdabot>  [873701589,-1832052184,-172134343,1714481743,-800653400,1592813986,-20345385...
10:45:16 <shapr> joelr1: Supposedly it will be open sourced in 2007 anyway, but lemme investigate whether I'm even sposed to know about it before I mention it :-)
10:45:35 <joelr1> shapr: hmm
10:45:38 <newsham> ?type next
10:45:39 <lambdabot> forall g. (RandomGen g) => g -> (Int, g)
10:45:51 <joelr1> shapr: would it be out of place to ask how you got hold of the information then? ;-)
10:46:06 <joelr1> shapr: whether you are supposed to have that information or not
10:46:17 <glguy> > let f g n = let (x,g') = randomR (1,n) g in (g',x) in snd $ mapAccumL f (mkStdGen 42) [1..10]
10:46:18 <lambdabot>  [1,2,2,3,2,2,5,8,4,6]
10:46:37 <shapr> I was trying to hire someone to do this same work, and then that person said that Galois had already gotten it done and would open source it later.
10:46:42 <jmorrison> who here knows much about STM?
10:47:12 <joelr1> shapr: wow! you are hiring?
10:47:16 <DeliQ> how can i cut a string in pieces of 1 char ?
10:47:22 <shapr> jmorrison: If you ask your STM question, you may find out!
10:47:35 <shapr> joelr1: Not me exactly, but HAppS has certain tasks that need doing.
10:47:43 <glguy> > map (:[]) "example"
10:47:45 <lambdabot>  ["e","x","a","m","p","l","e"]
10:48:00 <DeliQ> aaah glguy, ty!
10:48:15 <jmorrison> shapr: I'm wondering what its equivalent in SQL transaction isolation levels is.
10:48:29 <mauke> > [ [c] | c <- "example" ]
10:48:30 <joelr1> shapr: ok, so we are getting close to the the matter at hand :D are you actively using hAppS
10:48:31 <lambdabot>  ["e","x","a","m","p","l","e"]
10:48:51 <newsham> i'm using happs for something
10:48:51 <shapr> joelr1: Yeah, and I get paid to work on HAppS too.
10:49:16 <shapr> I wish I had more time to use HAppS, working on it is not quite the same.
10:49:16 <joelr1> shapr: wow! who pays?
10:49:17 <newsham> shapr: whats getting open sourced soon?
10:49:58 <shapr> newsham: Something Galois contracted out recently.
10:50:09 <joelr1> shapr: i'm thinking of this haskell trading platform (yes, again, i know) and i see it on top of happs since it has a web server. i would use the web server to get results.
10:50:25 <joelr1> shapr: so i'm interested in everything happs
10:50:39 <DeliQ> can you also do the same with large numbers ? say Int -> [Int]
10:50:52 <vegai> joelr1: me too!
10:51:28 <joelr1> vegai: what is your interest?
10:51:54 <Lemmih> jmorrison: Serializable.
10:52:22 <mauke> DeliQ: why do you need a list of 1-char strings?
10:52:37 <vegai> joelr1: currently blog software and secondarily, anything that might make some money in the future
10:52:53 <joelr1> vegai: cool
10:52:54 <DeliQ> i'm trying to solve this problem from project euler
10:53:04 <DeliQ> the sum of all the digits in 100!
10:53:06 <jmorrison> Thanks Lemmih
10:53:14 <joelr1> shapr: so who is funding happs development these days
10:53:28 <mauke> DeliQ: what's the problem id?
10:53:35 <DeliQ> dunno
10:53:36 <shapr> Same guy who's been funding happs forever, Alex Jacobson.
10:53:40 <vegai> joelr1: I'm trying to work on it in a way that I could later publish, for tutorial purposes. That makes the process a bit slower
10:53:40 <DeliQ> looking it up..
10:53:51 <DeliQ> mauke: 20
10:53:55 <shapr> Alex doesn't expect HAppS itself to make money, but he does have a bunch of really cool business ideas that he wants to put on top of happs.
10:54:04 <DeliQ> http://www.projecteuler.net/index.php?section=view&id=20
10:54:15 <lambdabot> Title: Project Euler
10:54:21 <mauke> DeliQ: you don't need a list of 1-char strings for that, only a list of chars
10:54:26 <joelr1> shapr: interesting. alex must work on wall st :D
10:54:53 <DeliQ> i thought just make a list 1 char string, and ask the sum of it
10:54:56 <jmorrison> I wonder if STM could be extended to use shared RAM, so that totally seperate processes could use it to communicate?
10:55:07 <mauke> DeliQ: a string _is_ a list of chars
10:55:08 <DeliQ> with some conversions
10:55:23 <mauke> and yes, that approach works
10:55:30 <DeliQ> mauke: i know idd... but 100! is a number...
10:55:42 <mauke> > show 42
10:55:43 <lambdabot>  "42"
10:55:51 <DeliQ> mauke: yup ty, i got your point :P
10:56:19 <mauke> @type Data.Char.digitToInt
10:56:20 <lambdabot> Char -> Int
10:56:27 <jcreigh> > sum $ map (\c -> (ord c) - (ord '0')) (show $ product [1..100])
10:56:28 <lambdabot>  648
10:56:39 <DeliQ> ;)
10:56:47 <mauke> > sum . map digitToInt . show . product $ [1..100]
10:56:48 <lambdabot>  648
10:57:40 <jcreigh> @type digitToInt
10:57:42 <lambdabot> Char -> Int
10:57:47 <jcreigh> cool, didn't know about that one.
10:58:22 <DeliQ> yup solved it ;)
10:58:24 <DeliQ> haha
10:58:29 <DeliQ> on to the next one :P
11:00:25 <newsham> > let sod = sum.map digitToInt.show in (sod.sod.sod) (5555^5555)
11:00:26 <lambdabot>  1
11:01:24 <DeliQ> newsham: lol
11:01:29 <mauke> @hoogle (Integral a) => Char -> a
11:01:30 <lambdabot> No matches, try a more general search
11:01:31 <xerox> cheater
11:01:38 <newsham> hmm.. correct answer is 5.  something's wrong
11:02:01 <mauke> > 5555^5555 :: Int
11:02:02 <lambdabot>  1232336107
11:02:26 <DeliQ> newsham: which problem is that ?
11:04:20 <newsham> > let sod = sum.map (fromIntegral.digitToInt).show in (sod.sod.sod) (5555^5555)
11:04:23 <lambdabot>  5
11:09:30 <DeliQ> hmm, maybe stupid question, but can you import more modules in one import statement :P
11:10:23 <Lemmih> No, you can't.
11:10:27 <allbery_b> you can do it indirectly by importing and re-exporting modules
11:10:45 <allbery_b> i.e. module M imports X, Y, and Z and re-exports them, then importing module M gets you all four
11:11:05 <DeliQ> allbery_b: hehe too much of a hassle :P
11:28:00 <DeliQ> sum . filter odd . takeWhile (<10^6) $ fibs -> 1089154
11:28:11 <DeliQ> can anybody verify this (problem 2 project euler)
11:28:53 <xerox> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . filter odd . takeWhile (<10^6) $ fibs
11:28:54 <lambdabot>  1089154
11:29:12 <DeliQ> ;)
11:29:56 <DeliQ> @type fibs
11:29:57 <lambdabot> Not in scope: `fibs'
11:30:15 <newsham> ?type let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . filter odd . takeWhile (<10^6) $ fibs
11:30:16 <lambdabot> forall a. (Integral a) => a
11:30:33 <newsham> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in sum . filter odd . takeWhile (<10^6) $ fibs :: Integer
11:30:34 <lambdabot>  1089154
11:30:48 <DeliQ> ghci yields fibs :: [Integer]
11:31:52 <DeliQ> ?type let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
11:31:53 <lambdabot> not an expression: `let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)'
11:32:09 <DeliQ> ?type let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
11:32:10 <lambdabot> forall a. (Num a) => [a]
11:39:39 <newsham> so did someone say they were doing trading stuff with yampa?
11:43:29 <syntaxfree> Jane St. people?
11:44:08 <svref> It seems to me that "any (==v) visited" gives stack overflow, and I don't see how, since v, visited are both computed beforehand (by seq) without problem...
11:44:30 <svref> also "visited" is length 2.
11:44:37 <sorear> seq only forces the head of a list
11:44:50 <sorear> > (1 : undefined) `seq` 2
11:44:51 <lambdabot>  2
11:45:00 <svref> so foldr1 on the list then?
11:45:33 <Syzygy-> > (any (==3) visited) `seq` 2 where visited = 1:undefined
11:45:33 <lambdabot>  Parse error
11:45:48 <Syzygy-> > let visited = 1:undefined in (any (==3) visited) `seq` 2
11:45:49 <lambdabot>  Undefined
11:45:50 <shapr> newsham: joelr1 said he wanted to do trading with yampa.
11:46:08 <metaperl> @seen Cale
11:46:09 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 1h 37m 10s ago.
11:46:29 <syntaxfree> would it be any easier/more efficient to implement a Haskell compiler in a Lisp machine?
11:46:42 <ph8> Program error: Prelude.!!: index too large
11:46:59 <ph8> presumably that means my code has specified an index that's too large, rather than there being a small cap on the size of index allowed?
11:47:00 <syntaxfree> shapr: there's a financial company putting ads asking for Haskell, OCaml and Erlang programmers. Jane St. Capital.
11:47:24 <sorear> no, because of Moore's law and the fact they stopped making Lisp Machines >1 decade ago. :(
11:47:30 <mauke> > [] !! 0
11:47:31 <lambdabot>  Add a type signature
11:47:36 <mauke> > [] !! 0 :: Char
11:47:37 <lambdabot>  Exception: Prelude.(!!): index too large
11:47:40 <allbery_b> ph8: you're indexing past the end of a list
11:48:29 <ph8> cool
11:48:35 <ph8> i was randomly doing 0<->length
11:48:37 <ph8> instead of length-1
11:48:46 <ph8> this may almost work shortly :) exciting!
11:49:02 <ph8> almost working is a definite progression from belching loudly at runtime
11:50:16 <sorear> generally, don't use !!,  there are better (and faster) functions for most purposes
11:50:22 <newsham> hmm.. this yampa paper (FRP) gives a decent intuitive overview of arrows
11:50:34 <ToRA> newsham: url?
11:50:58 <newsham> http://www.haskell.org/yampa/AFPLectureNotes.pdf http://www.haskell.org/yampa/
11:51:04 <ToRA> cheers
11:51:06 <syntaxfree> isn't xs !! n = take 1 (drop (n-1) xs) ?
11:51:18 <rashakil> no, that returns a list
11:51:27 <jcreigh> does anybody else type ":l foo.hs" at a bash prompt?
11:51:33 <syntaxfree> oh, of course.
11:51:34 <rashakil> yes
11:51:36 <syntaxfree> head (drop n xs)
11:51:55 <jcreigh> I supposed I could just alias ':l'='ghci' :)
11:51:55 <mauke> @pl xs !! n = head (drop n xs)
11:51:56 <lambdabot> (line 1, column 9):
11:51:56 <lambdabot> unexpected "="
11:51:56 <lambdabot> expecting variable, "(", "`", "!!", ".", operator or end of input
11:52:02 <jcreigh> *suppose
11:52:37 <syntaxfree> I type :r in assorted contexts.
11:52:43 <syntaxfree> When programming in R, for example.
11:53:00 <bakert> hello folks.  i'm trying to use "ordering" which seems to be part of "Data.Ord" but when I "import Data.Ord" I get "Could not find module `Data.Ord'".  Any idea why?  (This is in ghci, doing a :load)
11:53:02 <bakert> ?
11:53:11 <jcreigh> :m + Data.Ord
11:53:12 <dmhouse> ?index ordering
11:53:12 <lambdabot> bzzt
11:53:19 <allbery_b> heh
11:53:23 <dmhouse> ?hoogle ordering
11:53:24 <lambdabot> Prelude.Ordering :: data Ordering
11:53:31 <Lemmih> bakert: Data.Ord is new in GHC-6.6
11:53:31 <dmhouse> bakert: sure you don't mean that?
11:53:35 <dmhouse> And it's in Prelude.
11:53:38 <syntaxfree> you can't say "import Data.Ord" in ghci, but that's not his error message.
11:53:47 <syntaxfree> oh. Data.Ord is recent.
11:53:51 <bakert> ah
11:53:52 <rashakil> syntaxfree: pretty much, but !! checks for negative arguments and errors on them.
11:53:54 <bakert> i see
11:54:02 <bakert> i have 6.4.1
11:54:12 <dmhouse> rashakil: and for things like out of range indices, I think it's actually defined recursively.
11:54:21 <jcreigh> bakert: oh, sorry, misread your question, thought you were trying to import Data.Ord interactively in ghci.
11:54:40 <dmhouse> (x:_) !! 0 = x; (x:xs) !! n = xs !! (n - 1); [] !! _ = error "Out of range"
11:55:39 <dmhouse> And _ !! n | n < 0 = error "Negative index."
11:55:40 <rashakil> you forgot _ !! n | n < 0 = error "..."
11:55:46 <rashakil> or not
11:55:49 <shapr> @seen alexj
11:55:49 <lambdabot> alexj has changed nick to alexj_.
11:55:50 <lambdabot> I saw alexj_ leaving #haskell 1m 15d 9h 7m ago, and .
11:55:53 <dmhouse> :) I did, but then i remembered.
11:56:00 <shapr> @seen alexj__
11:56:00 <lambdabot> Last time I saw alexj__ was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavian and #unicycling
11:56:00 <lambdabot> 10d 19h 13m 21s ago, and .
11:56:35 <bakert> So does everyone mostly use 6.6?  Ubuntu's default package was this one.
11:57:08 <dmhouse> bakert: no, I'm still on whatever's in Apt, I believe.
11:57:11 <sorear> I use 6.4.2, 6.6, and HEAD - whichever isn't broken at any given time
11:57:23 <dmhouse> Oh, nope, apparently I am on 6.6.
11:57:26 <sorear> Debian uses 6.6
11:57:28 <host46> Question about currying, with some f::a->b->c I can (a `f`) or (`f` b) and get a new function which needs now only one parameter. So, if I have g::a->b->c->d how may I do a function with with b and c parameters that only needs now one parameter, a?
11:57:33 <syntaxfree> HEAD?
11:57:48 <dmhouse> host46: (g x y)
11:57:49 <sorear> darcs get ...
11:58:03 <rashakil> dmhouse: what?
11:58:06 <dmhouse> host46: disregard that.
11:58:13 <sorear> \a -> g a x y
11:58:16 <sorear> ?pl \a -> g a x y
11:58:17 <lambdabot> flip (flip g x) y
11:58:21 <dmhouse> Yeah, sorear's the best you can get.
11:58:27 <DeliQ> is there a more efficient version of palindrome s = s == reverse s ?
11:58:30 <dmhouse> `infix` notation applies only to binary functions, really.
11:58:39 <sorear> ap(==)reverse ?
11:58:52 <dmhouse> sorear: that's more efficient how? :P
11:58:54 <sorear> > ap(==)reverse "abcba"
11:58:55 <lambdabot>  True
11:59:03 <sorear> dmhouse: character count
11:59:07 <syntaxfree> host46: you want to know  if you can create sections from named functions using `fake operator` syntax?
11:59:10 <mauke> > (reverse >>= (==)) "abcba"
11:59:11 <lambdabot>  True
11:59:11 <dmhouse> DeliQ: I don't think so, it's necessarily O(n) I guess.
11:59:18 <dmhouse> DeliQ: unless you don't use lists.
11:59:36 <DeliQ> dmhouse: i guess so idd
11:59:38 <syntaxfree> > ( [1,2,3] `zipWith`) [3,4,5]
11:59:39 <lambdabot>  Couldn't match `a -> b -> c' against `[a1]'
11:59:51 <host46> My quiestion is simple, just how to isolate one parameter to left it for the currying trick
12:00:00 <syntaxfree>  > ( [1,2,3] `zip`) [3,4,5]
12:00:13 <host46> but as sorear said, with lambda it's ok
12:00:13 <dmhouse> syntaxfree: what are the extra parentheses for?
12:00:14 <syntaxfree> ahh. I think you want flip.
12:00:21 <DeliQ> dmhouse: theta(n)
12:00:29 <dmhouse> > [1,2,3] `zip` [3,4,5]
12:00:30 <lambdabot>  [(1,3),(2,4),(3,5)]
12:00:35 <dmhouse> DeliQ: what's the difference?
12:00:35 <syntaxfree> > > ( [1,2,3] `zip`) [3,4,5]
12:00:36 <lambdabot>  Parse error
12:00:45 <syntaxfree> dmhouse: I'm trying to use it as a section.
12:00:57 <syntaxfree> > ( [1,2,3] `zip`) [3,4,5]
12:00:59 <lambdabot>  [(1,3),(2,4),(3,5)]
12:01:01 <syntaxfree> works.
12:01:03 <dmhouse> > ([1,2,3] `zip`) [3,4,5]
12:01:04 <lambdabot>  [(1,3),(2,4),(3,5)]
12:01:18 <syntaxfree> host46: for example:
12:01:25 <syntaxfree> > (/) 3  2
12:01:26 <lambdabot>  1.5
12:01:26 <rashakil> DeliQ: if you reversed the list inline and kept a count of the number of elements so that you only reversed the first n/2 elements and then compared that with the first n/2 elements, you might be slightly more efficient... by about 1 month of computer technology improvements.
12:01:29 <DeliQ> theta(n) = not less, not more :P
12:01:32 <syntaxfree> > (flip (/)) 3 2
12:01:33 <dmhouse> host46: if you _really_ wanted to, you could you use flip like ?pl told you, but I think the lambda should do fine.
12:01:33 <lambdabot>  0.6666666666666666
12:01:46 <syntaxfree> > (3 (flip/)) 2
12:01:47 <lambdabot>     add an instance declaration for (Fractional ((a -> b -> c) -> b -> a -...
12:01:51 <host46> okis flip and lambda
12:01:58 <syntaxfree> er
12:02:09 <dmhouse> syntaxfree: that's not going to work.
12:02:16 <syntaxfree> > (3 (flip (/))) 2
12:02:17 <lambdabot>  add an instance declaration for (Num ((b -> b -> b) -> t -> a))
12:02:17 <lambdabot>   In the ...
12:02:20 <DeliQ> brb
12:02:21 <dmhouse> > let (\) = flip (/) in (3 \) 2
12:02:21 <lambdabot>  Parse error
12:02:35 <dmhouse> > let (//) = flip (/) in (3 //) 2
12:02:37 <lambdabot>  0.6666666666666666
12:02:51 <syntaxfree> (3 `flip (/)`) 2
12:02:54 <dmhouse> Nope.
12:03:01 <syntaxfree> > (3 `flip (/)`) 2
12:03:02 <lambdabot>  Parse error
12:03:15 <syntaxfree> bah, nevermind :)
12:03:33 <rashakil> ah, that would be cool feature :P
12:03:50 <dmhouse> > let (!-) = flip ($); (-!) = ($) in 3 !- flip (/) -! 2
12:03:51 <lambdabot>  0.6666666666666666
12:03:57 <DeliQ> dmhouse: omega(n) = at least n, O(n) = n at most, theta(n) = at least and at most n
12:04:13 <dmhouse> DeliQ: ah, right.
12:04:27 <syntaxfree> I once proposed using the euro symbol for that, dmhouse.
12:04:28 <dmhouse> DeliQ: is there one for the amortized (sp?) case?
12:04:33 <DeliQ> not that i know of
12:04:34 <syntaxfree> @quote syntaxfree
12:04:35 <lambdabot> syntaxfree says: I love lists of functions. They give me this warm mathematical feeling.
12:04:42 <syntaxfree> @quote syntaxfree
12:04:42 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
12:04:50 <syntaxfree> @quote syntaxfree
12:04:50 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
12:04:55 <syntaxfree> there it is.
12:05:21 <allbery_b> @quote euro
12:05:22 <lambdabot> syntaxfree says: one could use the euro symbol for left-associative $.
12:05:29 <allbery_b> we now have pattern quoting :)
12:05:37 <syntaxfree> cool.
12:05:43 <Cale> metaperl: hi
12:06:02 <dmhouse> Category theory still makes my head spin.
12:06:07 <sorear> @quote Bourbaki
12:06:07 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
12:06:09 <metaperl> Cale  -hi ...
12:06:10 <sorear> @quote Bourbaki
12:06:10 <lambdabot> syntaxfree says: <Bourbaki> the best thing i have ever read in economy is a statement of some guy "i have never met the homo oeconomicus" <syntaxfree> I have never met a catamorphism, either.
12:06:11 * shapr hugs Cale
12:06:21 <vincenz> hmm
12:06:21 <Cale> hello shapr
12:06:25 * metaperl hugs Cale
12:06:32 <syntaxfree> @quote head
12:06:32 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
12:06:36 <lisppaste2> ph8 pasted "This strips full stops, it appears - and it shouldn't! ?" at http://paste.lisp.org/display/33836
12:07:01 <metaperl> well anyway, I think before going any further with HXT, I am going to thoroughly document your HRSS... it's a bit off the mark for what I want to do.. but I think it would help me
12:07:09 <Cale> heh, I thought it was New Year's Day, but apparently it's Hug Cale Day.
12:07:17 * ph8 hugs Cale
12:07:21 <syntaxfree> @quote head
12:07:22 <lambdabot> ghc says: Malformed context in instance header
12:07:25 <vincenz> me hugs Cale
12:07:28 * vincenz hugs Cale
12:07:29 <metaperl> should I write it up for the Haskell wiki? I dont know the wikitext syntax
12:07:35 <syntaxfree> @quote head
12:07:35 <lambdabot> ghc says: Malformed context in instance header
12:07:40 * syntaxfree gives up.
12:07:42 <Cale> the haskell wiki uses the same syntax as wikipedia
12:08:11 <Cale> but sure, I was thinking of doing that myself
12:08:12 <syntaxfree> there should be a markdown plugin for mediawiki.
12:08:19 <allbery_b> you can use a regex, if you have a better idea of what you're looking for
12:09:15 <DeliQ> dmhouse: it can be proved that all sorting algorithms that use comparison, are omega(n log n), so comparison sorts are never going to get faster than omega(n log n)
12:09:20 <metaperl> pure is plain old vanilla arrow function I believe
12:09:22 <metaperl> @type pure
12:09:23 <lambdabot> forall (a :: * -> * -> *) c b. (Arrow a) => (b -> c) -> a b c
12:09:37 <metaperl> oh makes a pure function into an arrow
12:09:44 <Cale> pure = arr
12:09:52 * metaperl nods
12:09:53 <mauke> > let stripPunc w = filter (not . isPunctuation) w ++ if last w == '.' then "." else "" in stripPunc "Hello, world!"
12:09:55 <lambdabot>  "Hello world"
12:10:22 <DeliQ> dmhouse: just some background knowledge :P
12:10:51 <ph8> cheers mauke :)
12:11:02 <mauke> > (\w -> filter (\ch -> not (elem ch ".,\"!?")) w) "Hello, world!"
12:11:02 <ph8> didn't know isPunc existed
12:11:03 <lambdabot>  "Hello world"
12:11:08 <mauke> yours also works
12:11:09 <sorear> there's a very good explanation of the proof on wikipedia
12:11:22 <DeliQ> sorear: url ?
12:11:23 <glguy> > let stripPunc w = filter (not . isPunctuation) (init w) ++ [last w] in stripPunc "Hello, World!"
12:11:24 <lambdabot>  "Hello World!"
12:11:38 <metaperl> @ghc getArgs
12:11:38 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
12:11:43 <metaperl> @doc getArgs
12:11:43 <lambdabot> getArgs not available
12:11:46 <sorear> DeliQ: looking...
12:11:47 <syntaxfree> > let stripBy  = filter . not in stripBy (isAlpha) "123AB,C!"
12:11:48 <lambdabot>  Couldn't match `a -> Bool' against `Bool'
12:11:55 <mauke> ph8: btw, you can write that as filter (`notElem` ".,\"!?")
12:11:58 <dmhouse> ?hoogle getArgs
12:11:58 <lambdabot> System.getArgs :: IO [String]
12:12:01 <dmhouse> ?docs System
12:12:01 <lambdabot> System not available
12:12:12 <glguy> syntaxfree: (filter .) . not
12:12:19 <glguy> maybe?
12:12:20 <syntaxfree> @pl stripBy f s = filter (not . f) s
12:12:21 <glguy> hm
12:12:21 <lambdabot> stripBy = filter . (not .)
12:12:22 <syntaxfree> yes, yes.
12:12:26 <DeliQ> sorear: http://en.wikipedia.org/wiki/Comparison_sort#Performance_limits ??
12:12:48 <syntaxfree> I thought of "not" as having type (a->Bool)->(a->Bool)
12:13:04 <syntaxfree> it's just Bool->Bool it seems.
12:13:46 <sorear> DeliQ: http://en.wikipedia.org/wiki/Comparison_sort#How_many_comparisons_are_needed.3F
12:13:48 <lambdabot> http://tinyurl.com/y4ft3x
12:13:59 <DeliQ> ;)
12:15:43 <DeliQ> never knew big-O was Omicron :P
12:16:46 <ph8> where does isPunctuation come from?
12:16:56 <mauke> Data.Char
12:17:03 <mauke> @index isPunctuation
12:17:03 <lambdabot> bzzt
12:17:08 <mauke> :(
12:17:14 <ph8> @hoogle isPunctuation
12:17:15 <lambdabot> No matches found
12:17:22 <ph8> @hoogle isSpace
12:17:23 <lambdabot> Char.isSpace :: Char -> Bool
12:17:25 <ph8> hmm
12:17:36 <ph8> is it one of those ones you wished were there but aren't?
12:17:54 <mauke> it is there, lambdabot can use it
12:18:30 <sorear> ?index isPunc
12:18:30 <lambdabot> bzzt
12:18:31 <sorear> ?index isPunct
12:18:32 <lambdabot> bzzt
12:18:35 <sorear> ?index isPunctuation
12:18:36 <lambdabot> bzzt
12:18:44 <mauke> oh, it's new in 6.6
12:18:51 <ph8> ah
12:18:59 <syntaxfree> bzzt = bot zeally zeally tzied?
12:19:59 <vincenz> bzzt = bot zeriously zeally tired
12:20:00 <ph8> > stripPunc :: String -> String
12:20:00 <ph8> > stripPunc w = (filter (`notElem` ".,\"!?") w) ++ (if (last w) == '.' then "." else "")
12:20:00 <lambdabot>  Not in scope: `stripPunc'
12:20:01 <lambdabot>  Parse error
12:20:01 <ph8> doesn't work?
12:20:10 <ph8> presumably it's removing the fullstop then checking for a fullstop?
12:20:28 <wolverian> ph8, you have an extra ( or a missing ), whichever you prefer :)
12:20:33 <syntaxfree> (>>>) is something quite different from (>>) and (>>=).
12:20:37 <wolverian> er, no you don't.
12:20:39 <syntaxfree> Misleading name!
12:21:50 <mauke> ph8: how does it not work?
12:21:57 <ph8> presumably it's removing the fullstop then checking for a fullstop?
12:21:57 <allbery_b> "let ... in ..."
12:22:05 <ph8> but it's taking out the fullstop at the end of a string
12:22:15 <allbery_b> ah,nm
12:22:19 <newsham> > (arr (+ 3) >>> arr (+ 2)) 5
12:22:20 <lambdabot>  10
12:22:32 <mauke> > let stripPunc w = (filter (`notElem` ".,\"!?") w) ++ (if (last w) == '.' then "." else "") in stripPunc "no."
12:22:34 <lambdabot>  "no."
12:22:37 <mauke> works for me
12:22:58 <syntaxfree> newsham I just did that in a private window with lambdabot ;)
12:23:31 <ph8> Main> main
12:23:31 <ph8> Filtering the small cat sat near the small dog.
12:23:31 <ph8>  to the small cat sat near the small dog
12:23:32 <ph8> odd
12:23:35 <ph8> do you think there's a newline?
12:23:49 <syntaxfree> > foldr (>>>) (arr (const 5)) $ map arr [(+1), (*3), (-7)]
12:23:50 <lambdabot>  add an instance declaration for (Show (a1 c a))
12:23:52 <ph8> why doesn't it take the fullstop out of w first btw?
12:24:06 <mauke> what do you mean by "take out"?
12:24:11 <syntaxfree> > (foldr (>>>) (arr id) $ map arr [(+1), (*3), (-7)]) 10
12:24:12 <lambdabot>  add an instance declaration for (Num (c -> c))
12:24:12 <lambdabot>   In the list element: (- 7)
12:24:17 <mauke> values are never modified
12:24:19 <ph8> well to me, it seems to be filtering all the punctuation out, then checking to see if there's a fullstop on the end
12:24:24 <ph8> ah.
12:24:28 <syntaxfree> > (foldr (>>>) (arr id) $ map arr [(+1), (*3), (subtract 7)]) 10
12:24:29 <lambdabot>  26
12:24:33 <mauke> filter returns a new string
12:24:41 <metaperl> the documentation for runX lists it in 3 different places, but only has one hyperlink... why is that? http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/doc-index-R.html
12:24:44 <lambdabot> http://tinyurl.com/ygwus9
12:24:46 <ph8> so i think there's a newline on the end
12:24:48 <ph8> which is rubbish
12:25:04 <mauke> ?paste your program
12:25:04 <lambdabot> http://paste.lisp.org/new/haskell
12:25:09 <newsham> sf: what is scary is that those long cryptic strings are starting to make sense to me
12:25:10 <allbery_b> if you're not using something llike lines on the inptu, it'll have newlines, yes
12:25:45 <newsham> some days haskell reminds me of perl (but in a purer way :)
12:25:48 <allbery_b> typically you do lines . getContents to turn stdin into a list of lines, then process those
12:26:24 <syntaxfree>  > ((+1) *** (*3)) 5
12:26:33 <syntaxfree> > ((+1) *** (*3)) 5
12:26:34 <lambdabot>  add an instance declaration for (Num (b, b'))
12:26:49 <ph8> mauke: it reads from a text file (e-book) and runs stripPunc on what readFile pulls out
12:26:50 <newsham> is instance Arrow (->) ?
12:26:58 <syntaxfree> > ((+1) *** (*3)) (5,5)
12:27:00 <lambdabot>  (6,15)
12:27:00 <ph8> after a function to convert to paragraphs, which doesn't take out newlines as far as i'm aware
12:27:07 <newsham> > ((* 2) >>> (+ 1)) 5
12:27:08 <ph8> is there a way to strip newlines?
12:27:08 <lambdabot>  11
12:27:16 <newsham> i guess so
12:27:19 <ph8> altering that script for stripPunc, it doesn't seem to like \n
12:27:23 <nmessenger> ?instances Arrow -- newsham
12:27:24 <lambdabot> Couldn't find class `Arrow -- newsham'. Try @instances-importing
12:27:30 <syntaxfree> misleading operator names. *** is a paralell composition operator -- should be called (|||)
12:27:36 <nmessenger> newsham, nvm ;)
12:27:39 <allbery_b> send the result of readFile through the lines operator to get a list
12:27:51 <syntaxfree> @type (***)
12:27:52 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
12:27:53 <nmessenger> ?instances Arrow
12:27:54 <lambdabot> (->), Kleisli m
12:27:56 <mauke> ph8: well, I guess you could simply filter ('\n' /=)
12:28:03 <ph8> but then i won't be able to distinguish paragraphs?
12:28:31 <ph8> ?type filter
12:28:33 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
12:28:43 <mauke> or map (\c -> if c == '\n' then ' ' else c)
12:28:54 <allbery_b> hm?  if they're delimied by blank lines, you get empty strings between.  if each paragraph is a line, you get one list item per paragraph
12:29:14 <rahikkala> http://ari-rahikkala.livejournal.com/20490.html
12:29:15 <lambdabot> Title: ari_rahikkala: Who knows, perhaps some of it will rub off on me
12:29:19 <allbery_b> > lines "foo\nbar\n\nbaz quux\ngoop"
12:29:20 <lambdabot>  ["foo","bar","","baz quux","goop"]
12:29:41 <syntaxfree> instance Arrow (->) where
12:29:42 <ph8> ah but i'm using a paragraph function i really don't have any flexibility with
12:29:50 <ph8> i could make my own i suppose but i don't think that's what's intended
12:29:52 <syntaxfree> hmm.  how is that even allowed? (->) isn't  a type constructor.
12:30:03 <nmessenger> sf: oh yes it is. :)
12:30:17 <allbery_b> instance Monad ((->) r) where ...
12:30:45 <syntaxfree> hmm. what's the associated data constructor, then?
12:31:04 <allbery_b> \x -> ...
12:31:19 <nmessenger> except it can't be pattern-matched
12:31:25 * allbery_b pulled that out of his butt, he's not actually sure of it...
12:31:26 <newsham> > ((->) x x + 1) 3
12:31:27 <lambdabot>  Parse error
12:31:43 <newsham> > ((->) x (x + 1)) 3
12:31:43 <lambdabot>  Parse error
12:31:44 <syntaxfree> ((->) x (x+1)) 3
12:31:54 <nmessenger> The closest thing to a (->) constructor is name = defn
12:32:15 <ph8> what's elem do?
12:32:16 <ph8> ?type elem
12:32:18 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
12:32:23 <newsham> > ((x ->) (x + 1)) 3
12:32:23 <lambdabot>  Parse error
12:32:28 <ph8> > elem a
12:32:28 <nmessenger> > 'a' `elem` "abc"
12:32:29 <lambdabot>  Not in scope: `a'
12:32:30 <lambdabot>  True
12:32:34 <nmessenger> > 'q' `elem` "abc"
12:32:35 <lambdabot>  False
12:32:40 <newsham> > (x (-> x+1)) 3
12:32:40 <ph8> ah nice
12:32:41 <lambdabot>  Parse error
12:32:55 <kaol> > 0 `elem` [1..]
12:32:57 <ph8> > stripLines l = filter (\ch -> not (elem ch '\n')) l
12:32:59 <lambdabot> Terminated
12:32:59 <lambdabot>  Parse error
12:33:01 <ph8> how come that doesn't work then?
12:33:13 <nmessenger> '\n' isn't a list
12:33:14 <allbery_b> because '\n' is Char, you need a list
12:33:20 <nmessenger> you might want "\n"
12:33:30 <nmessenger> or even (== '\n')
12:33:31 <mauke> you might want /= '\n'
12:33:36 <allbery_b> and ch /= '\n' is better if you're just looking for \n
12:33:41 <mauke> <mauke> ph8: well, I guess you could simply filter ('\n' /=)
12:33:44 <allbery_b> heh
12:34:14 <ph8> woo hoo, filtering works as expected now
12:34:18 <ph8> i don't understand '\n' /=
12:34:23 <ph8> dunno what it means
12:34:26 <allbery_b> it's a section
12:34:37 <nmessenger> operator section 'argument is not a newline'
12:34:42 <allbery_b> with an infix operator, you can prespecify one of the arguments
12:34:43 <newsham> > (/= 3) 3
12:34:44 <jcreigh> ph8: ('\n' /=) = (\c -> '\n' /= c)
12:34:44 <lambdabot>  False
12:34:45 <newsham> > (/= 3) 4
12:34:47 <lambdabot>  True
12:35:11 <ph8> oo
12:35:26 * nmessenger likes operator sections
12:35:31 <allbery_b> you can do either side; with a commutative operator like /= it doesn't matter which you use
12:36:05 <allbery_b> so (x /=) is the same as (/= x), but the same does not go for e.g. (/) which isn't commutative
12:36:20 <allbery_b> (and then there are syntactic issues with using sections on (-))
12:36:25 <newsham> > (/ 3) 5
12:36:26 <lambdabot>  1.6666666666666667
12:36:29 <newsham> > (3 /) 5
12:36:30 <jcreigh> > filter (`elem` "aeiou") "You can even do stuff like this"
12:36:30 <lambdabot>  0.6
12:36:31 <lambdabot>  "ouaeeouiei"
12:37:14 <fasta> Uh, why is: fmap f r@(<some pattern>) = r and fmap f r@(<some pattern>) = <some pattern> not the same?
12:37:22 <newsham> > nub "nubbed strings look very confusing after the first few characters"
12:37:23 <lambdabot>  "nubed striglokvycfahw"
12:37:51 <norpan> > nub "the quick brown fox jumps over the lazy dog"
12:37:53 <lambdabot>  "the quickbrownfxjmpsvlazydg"
12:38:12 <Syzygy-> > nub "now i even i would celebrate in words unapt the great
12:38:12 <lambdabot>  Improperly terminated string
12:38:14 <Syzygy-> > nub "now i even i would celebrate in words unapt the great"
12:38:15 <lambdabot>  "now ievuldcbratsphg"
12:38:27 <newsham> > sort $ nub "the quick brown fox jumped over the lazy dogs"
12:38:28 <lambdabot>  " abcdefghijklmnopqrstuvwxyz"
12:38:54 <nmessenger> > sort $ nub "jackdaws love my big sphinx of quartz"
12:38:55 <Syzygy-> > (\\ [a..z]) $nub "the quick brown fox jumped over the lazy dogs"
12:38:56 <lambdabot>  " abcdefghijklmnopqrstuvwxyz"
12:38:56 <lambdabot>  Not in scope: `z'
12:39:06 <Syzygy-> > (\\ ['a'..'z']) $nub "the quick brown fox jumped over the lazy dogs"
12:39:07 <lambdabot>  " "
12:39:10 <Syzygy-> Hah!
12:39:16 <Syzygy-> No .. wait ..
12:39:24 <Syzygy-> > (['a'..'z'] \\) $nub "the quick brown fox jumped over the lazy dogs"
12:39:25 <lambdabot>  ""
12:39:27 <Syzygy-> Hah!
12:39:55 <allbery_b> canonically "jumps over the lazy dog" :)
12:40:05 <mauke> fasta: because of types
12:40:14 * nmessenger prefers quartz sphinxes
12:40:19 <norpan> > all . map elem . nub "the quick brown fox jumped over the lazy dogs"
12:40:19 <lambdabot>    Expecting a function type, but found `[a]'
12:40:20 <lambdabot>    Expected type: a1 -> [a...
12:40:24 <Syzygy-> > nub "quartz sphinxes"
12:40:26 <lambdabot>  "quartz sphinxe"
12:40:32 * shapr too
12:40:40 <norpan> > all . map elem . nub $ "the quick brown fox jumped over the lazy dogs"
12:40:41 <lambdabot>  Couldn't match `a -> Bool' against `[[a1] -> Bool]'
12:40:45 <norpan> bah
12:40:49 <norpan> good night
12:40:58 <fasta> mauke: is that the long version of the reason why?
12:41:19 <newsham> ?define sameLetters a b = (sort $ nub a) == (sort $ nub b)
12:41:20 <lambdabot> Undefined.
12:41:23 <shapr> go natt norpan
12:42:30 <newsham> > let sameLetters a b = (sort $ nub a) == (sort $ nub b) in filter (sameLetters "het") $ words "the world will end"
12:42:32 <lambdabot>  ["the"]
12:42:47 <mauke> > let f = (\x@Nothing -> Nothing) :: Maybe a -> Maybe b in f
12:42:48 <lambdabot>  Add a type signature
12:42:55 <mauke> > let f = (\x@Nothing -> x) :: Maybe a -> Maybe b in f
12:42:56 <lambdabot>  1:8-46
12:42:57 <lambdabot>    Expected type: Maybe b
12:42:57 <lambdabot>    Inferred type: Maybe a
12:42:57 <lambdabot>   In a la...
12:43:49 <mauke> the problem here is that Nothing has the type forall a. Maybe a, but x is restricted to a specific 'a', which is not equal to the expected type 'b'
12:45:21 <lisppaste2> metaperl pasted "I think >>> binds tighter than $ but I'm not sure... HXT question" at http://paste.lisp.org/display/33838
12:45:28 <nmessenger> is this the MMR?
12:45:40 <nmessenger> (@mauke)
12:45:58 <dmhouse> Does anyone use Greencard anymore?
12:46:06 <mauke> nmessenger: no
12:46:13 <allbery_b> no, x is explicitly typed as Maybe a
12:46:33 <allbery_b> so it can't be Maybe b unless a can be unified with b
12:46:44 <allbery_b> whereas Nothing is a forall
12:48:04 <allbery_b> metaperl: the ":i" command in ghci tells you precedence
12:48:23 * metaperl tries
12:48:33 <nmessenger> the Nothing bound to x has type 'Maybe a', so typing the lambda as a '-> Maybe b' is invalid.  What about the first one that didn't reuse 'x' but returned a different 'Maybe'?
12:48:49 <nmessenger> er, a different 'Nothing'?
12:49:03 <allbery_b> :t Nothing
12:49:05 <lambdabot> forall a. Maybe a
12:49:26 <nmessenger> > \Nothing -> Nothing :: Maybe a -> Maybe b
12:49:27 <lambdabot>    Expecting a function type, but found `Maybe a'
12:49:27 <allbery_b> that can unify with the Maybeb in the type signature
12:49:27 <lambdabot>    Expected type: Mayb...
12:49:49 <nmessenger> ?type (\Nothing -> Nothing) :: Maybe a -> Maybe b
12:49:50 <metaperl> @doc Data.Arrow
12:49:50 <lambdabot> Maybe a -> Maybe b :: forall a b. Maybe a -> Maybe b
12:49:50 <lambdabot> Data.Arrow not available
12:50:00 <allbery_b> it's Control.Arrow
12:50:03 <metaperl> allbery_b - I'm trying to get the precedence of (>>>) which is in Data.. oh
12:50:04 <nmessenger> seems to work
12:50:05 <metaperl> :)
12:50:10 <metaperl> @doc Control.Arrow
12:50:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Arrow.html
12:50:27 <allbery_b> nmessenger: yes, that works.  but:
12:50:53 <metaperl> allbery_b - how can I start ghci and load in Control.Arrow
12:50:54 <allbery_b> ?ty (\x@(Nothing) -> x) :: Maybe a -> Maybe b
12:50:55 <lambdabot>   Couldn't match the rigid variable `b' against the rigid variable `a'
12:50:56 <lambdabot>    `b' is bound by the polymorphic type `forall a b. Maybe a -> Maybe b'
12:51:11 <allbery_b> x is bound to Maybe a
12:51:20 <nmessenger> yeah, for reusing the Maybe a 'Nothing'
12:51:27 <allbery_b> metaperl: :m +Control.Arrow
12:51:36 <metaperl> ok
12:51:38 <allbery_b> after starting it with no file
12:52:09 * allbery_b keeps a no-file ghci around and ":m +" and ":m -" modules as needed
12:58:49 <ph8> > last ""
12:58:51 <lambdabot>  Exception: Prelude.last: empty list
13:04:18 <emu> who wrote that wikibook on haskell denotational semantics?
13:04:48 <nmessenger> ?google haskell denotational semantics wikibook
13:04:51 <lambdabot> http://en.wikibooks.org/wiki/Haskell/Denotational_semantics
13:08:05 <nmessenger> the history page lists the user 'DavidHouse' as the original contributor
13:09:25 <dmhouse> nmessenger: that's me.
13:09:36 <dmhouse> But I believe it was apfelmus who wrote the article itself.
13:10:14 <emu> i heard that it was somebody who hangs out here
13:10:26 <dmhouse> http://en.wikibooks.org/w/index.php?title=Haskell/Denotational_semantics&oldid=668717 is as far as I got :)
13:10:28 <lambdabot> http://tinyurl.com/yj4rbm
13:11:05 * allbery_b gets a case-dependent filesystem set up ont he mac's external drive and pokes at ghc head again
13:11:46 <nmessenger> ah yes, that first diff is a doozy. :o)
13:13:35 * allbery_b never finished it; it hates HFS+
13:13:54 <allbery_b> (at least, the default case-independent one.  applying patches barfed)
13:14:21 <augustss> allbery_b: you need to do get --partial
13:15:22 <allbery_b> I did
13:15:46 <allbery_b> I've seen several repos so far where --partial was claimed to avoid a case-dependent patch and it didn't.
13:16:10 <allbery_b> last time I did the darcs foo on the freebsd box and copied the tree over to get around it.  now I have a case-dependent fs on the mac instead
13:19:28 <hyrax42> ?where hs-plugins
13:19:28 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
13:19:42 <Botje> ?seen ndm
13:19:43 <lambdabot> Last time I saw ndm was when I left #darcs, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell.hac07, #jtiger, #oasis, #perl6, #scannedinavian and #unicycling
13:19:43 <lambdabot> 10d 20h 37m 3s ago, and .
13:19:49 <Botje> :/
13:20:10 <Botje> i've got a suggestion for hoogle..
13:20:47 <nmessenger> Botje: you could @tell him.
13:20:59 <Botje> ah
13:22:04 <Botje> done
13:22:32 <nmessenger> Botje: I'm curious, what kinda suggestion?
13:22:44 <Botje> "Suggestion for hoogle: searching for a module name should proceed directly to that module (or at least include a link to it in the search results)"
13:23:10 <Botje> I've mapped hoogle to a keyword in my firefox, so I often try "hoogle Data.Map"
13:23:32 * nmessenger has the same.  He hearts firefox keywords
13:23:32 <Botje> the search results don't contain data.map, so I have to google instead of hoogle
13:23:58 <Botje> alternatively: is there a commandline query tool for haddock? (like perldoc, ri, ..)
13:24:08 <nmessenger> lambdabot
13:25:00 <nmessenger> oh, doc query?  Not that I know of.
13:25:11 <dmhouse> Hrm, that'd be nice.
13:25:35 <dmhouse> It would look up which module it's defined in, Ã  la ?index, then jump to that function's def'n in the Haddock docs for that module.
13:25:36 <Botje> yes, it'd save me a LOT of roundtrips editor-browser :)
13:26:01 <nmessenger> AH!  http://neilmitchell.blogspot.com/2006/12/hoogle-progress-hsman-features.html
13:26:04 <lambdabot> Title: Neil Mitchell's Haskell Blog: Hoogle Progress, HsMan features, http://tinyurl.com/yb5pcu
13:26:14 <nmessenger> HsMan maybe?
13:26:37 <shapr> or just use lambdabot
13:26:45 <shapr> @doc Prelude.head
13:26:45 <lambdabot> Prelude.head not available
13:26:59 <shapr> aww
13:27:01 <dmhouse> Sadly Hoogle 4's not out.
13:27:14 <nmessenger> shapr: LB gets you as far a @doc, but it'd be cool to have insta-doc text on the command line.
13:27:21 <shapr> Anyway, lambdabot can be used from the command line, and it includes haddock lookup.
13:27:48 <xpika> i think hoogle simply needs an im feeling lucky button
13:27:50 <shapr> I'd rather have it inside emacs and/or ghci.
13:28:12 <allbery_b> dons' blog had instructions for hooking LB into ghci
13:28:17 <dmhouse> I've got hoogle inside Emacs.
13:28:18 * nmessenger agrees violently with xpika
13:28:42 <dmhouse> And I came up with a way for linking LB and ghci, that's on the wiki IIRC.
13:29:03 <dmhouse> http://haskell.org/haskellwiki/Hoogle#Integrating_Hoogle_and_GHCi that one.
13:29:04 <lambdabot> Title: Hoogle - HaskellWiki
13:29:24 <nmessenger> Binaries?  *puppy-dog eyes*
13:30:15 <dmhouse> http://haskell.org/haskellwiki/Hoogle#Using_Hoogle_from_Emacs is Emacs/Hoogle integration
13:30:16 <lambdabot> Title: Hoogle - HaskellWiki
13:30:26 <dmhouse> Which, by a weird coincidence, I'm currently working on improving.
13:30:39 * earthy mutters 'vim' under his breath
13:31:25 <opqdonut> bah
13:31:31 * riczho screams Vim!!!
13:31:35 <earthy> and I have Ideas :)
13:31:43 <earthy> but that'll have to wait
13:31:53 <earthy> the gf comes first
13:33:32 <jmob> ghci's :i command is pretty cool for getting formation on a function
13:33:48 <earthy> yes, it is
13:33:55 <ph8> it sounds bad, but is there a way to stop exceptions being output?
13:33:56 <nmessenger> 'twould be why it's called info  ;P
13:34:02 <jmob> you could also be weird and use viper to get vi movement inside emacs
13:34:09 <dmhouse> ?docs Control.Exception
13:34:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Exception.html
13:34:11 <nmessenger> ph8: you could catch them.
13:34:13 <dmhouse> ph8: try that.
13:34:17 <ph8> danke
13:34:18 <nmessenger> ?type catch
13:34:19 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
13:34:26 <nmessenger> ?type Control.Exception.catch
13:34:27 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
13:34:35 <ph8> last throws the odd exception i don't want but is hard to avoid
13:34:36 <bakert> is there a standard flatten function?  can't find one in List.
13:34:55 <hyrax42> bakert
13:35:00 <hyrax42> join?
13:35:02 <Botje> concat
13:35:05 <ph8> so i can catch (last (last a)) ?
13:35:21 <ph8> argh
13:35:23 <ph8> it's in a guard
13:35:24 <mauke> > join ["all", "your", "base"]
13:35:26 <lambdabot>  "allyourbase"
13:35:28 <ph8> argh, it doesn't matter :)
13:35:41 <nmessenger> ph8: catch doAThing handleErrorIfItHappens
13:35:51 <metaperl> @seen Cale
13:35:51 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 1h 26m 6s ago.
13:36:15 <jmob> Is Cale still doing IRC lectures?
13:36:21 <bakert> thanks  Botje
13:36:25 <nmessenger> > catch (readLine :: Int) (\exception -> putStrLn "Bad User!  Not an Int!")
13:36:26 <lambdabot>  Not in scope: `readLine'
13:36:41 <ph8> idd nmessenger
13:36:46 <ph8> ?type last
13:36:48 <lambdabot> forall a. [a] -> a
13:36:49 <ph8> but last returns a char?
13:36:56 <ph8> which is producing a type error
13:37:11 <ph8> | (( (catch (last (last key)) (\e -> e)) /= '.') &&  ... is how it looks atm
13:37:24 <ph8> i'm thinking i might be able to change \e -> e to ()
13:37:24 <hyrax42> ?seen hyrax42
13:37:24 <hyrax42> irc lectures?
13:37:25 <lambdabot> You are in #haskell-blah and #haskell. I last heard you speak just now.
13:37:25 <mauke> @index eval
13:37:26 <lambdabot> bzzt
13:37:38 <metaperl> Cale IRC lectures? never heard of that...
13:37:46 <ph8>  Expected type: [[IO a]]
13:37:46 <ph8>       Inferred type: [[Char]]
13:37:47 <ph8> :/
13:37:48 <dmhouse> ph8: if you want the last two elements of a list, use drop (length s - 2) s
13:38:04 <jmob> metaperl: he did at least one a while ago
13:38:05 <ph8> dmhouse: i'm after the last character of a string, from a list of strings
13:38:16 <hyrax42> dmhouse: that'll need two traversals of the list, no
13:38:20 <dmhouse> ph8: oh, okay.
13:38:25 <ph8> :o)
13:38:25 <shapr> @seen shapr
13:38:26 <lambdabot> You are in #khjk, #fenfire, #scannedinavian, #unicycling, #haskell-blah and #haskell. I last heard you speak just now.
13:38:39 <nmessenger> ?paste your code ph8
13:38:39 <lambdabot> http://paste.lisp.org/new/haskell
13:38:49 <dmhouse> hyrax42: what do you suggest?
13:39:15 <ph8> @index evaluate
13:39:15 <lambdabot> Control.Exception, Test.QuickCheck, Debug.QuickCheck
13:39:20 <ph8> gonna try evaluate, two ticks
13:39:23 <hyrax42> pattern match on l@(x:y:[]) = l
13:39:32 <hyrax42> and otherwise recurse
13:39:57 <emu> i have info,type,location, and hoogle accessible from within my haskell emacs buffers (w/ghci running)
13:41:01 <dmhouse> hyrax42: what about in general?
13:41:05 <hyrax42> > let last2 [] = []; l@[x,y] = l; last2 (x:xs) = last2 xs in last2 [1..10]
13:41:06 <lambdabot>    Conflicting definitions for `last2'
13:41:06 <lambdabot>   In the binding group for: last2,...
13:41:17 <hyrax42> hrm
13:41:40 <emu> they are separated
13:41:59 <hyrax42> oh needs case?
13:42:01 <emu> you forgot a last2
13:42:01 <hyrax42> bleh
13:42:05 <nmessenger> l@(x:y:_) vs. (x:xs) ?
13:42:13 <dmhouse> > let last2 [] = []; last2 l@[x,y] = l; last2 (x:xs) = last2 xs in last2 [1..10]
13:42:14 <lambdabot>  [9,10]
13:42:16 <lisppaste2> ph8 pasted "RepGen Segment - Catching Exceptions" at http://paste.lisp.org/display/33842
13:42:20 <dmhouse> But in general...
13:42:22 <ph8> printing "" may be the wrong thing to do
13:42:29 <ph8> but i'm looking for a method that just ignores it, with no output
13:42:36 <hyrax42> dmhouse: oh
13:42:39 <hyrax42> woops
13:42:51 <dmhouse> ph8: paste the whole function, I doubt you need to use exceptions.
13:42:58 <hyrax42> and if you mean "last n" generally.. then what you did is all you can do
13:43:02 <hyrax42> unless you go for TH
13:43:06 <hyrax42> I suppose
13:43:10 <emu> return ()?
13:43:23 <dmhouse> Or a GADT list that encodes the length of the list in the type.
13:43:27 <lisppaste2> ph8 annotated #33842 with "Complete RepGen" at http://paste.lisp.org/display/33842#1
13:43:29 <emu> @type print ""
13:43:30 <lambdabot> IO ()
13:43:34 <emu> @type return ()
13:43:35 <lambdabot> forall (m :: * -> *). (Monad m) => m ()
13:43:44 <hyrax42> dmhouse: that's beyond my ken :/
13:44:20 <ph8> it seems to trigger at the end
13:44:24 <ph8> (of my entire program)
13:44:29 <ph8> which will be when... (sec)
13:44:39 <dmhouse> ph8: how could it come about that padKey is an empty list?
13:44:50 <dmhouse> Err, sorry *key is an empty list.
13:44:58 <dmhouse> Or a list where the last element is empty.
13:45:08 <ph8> key will be "" methinks
13:45:10 <dmhouse> I.e., what could cause last (last key) to be an error?
13:45:23 <ph8> which isn't null, right?
13:45:31 <ph8> so it's trying (last (last ""))
13:45:33 <dmhouse> key can't be "", you just told me it's a list of strings.
13:45:38 <ph8> > last (last "")
13:45:39 <lambdabot>  Couldn't match `[a]' against `Char'
13:45:44 <dmhouse> That doesn't make sense.
13:45:47 <ph8> hmm
13:46:01 <dmhouse> "" :: [Char], but if you apply last to something twice it has to have type [[t]] for some t.
13:46:10 <nmessenger> > last (last ["lazy","dogs"])
13:46:11 <lambdabot>  's'
13:46:15 <ph8> hmm.
13:46:24 * SamB remembers that he ought to implement the illumination algorithm for his raytracer before doing bounding volumes
13:46:34 <ph8> it might be happening at one of the other last's
13:46:37 <ph8> * lasts
13:46:51 <nmessenger> what is padKey's type?
13:46:54 <dmhouse> ph8: you didn't answer my question.
13:47:02 <dmhouse> I _very_ much doubt you should be using exceptions.
13:47:15 * nmessenger thinks likewise
13:47:16 <ph8> it was a bit of a lazy way out tbh
13:47:24 <ph8> i'm a bad man
13:47:31 * nmessenger kills ph8
13:47:53 <ph8> One match for ["W","Cable"] appending [""] (soFar = ["Project","Gutenbergs","The","Flower","of","the","Chapdelaines","by","George","W","Cable",""])
13:47:53 <ph8> main: Prelude.last: empty list
13:47:55 * nmessenger feels sorry, revives him
13:47:56 <ph8> that's the last two lines of output
13:48:07 <ph8> cheers, nothing like a bit of ressurection to clear the sinuses
13:49:23 <ph8> confuzzling to debug
13:50:32 <dmhouse> ph8: well, that's because you're not thinking about your function.
13:51:07 <nmessenger> ph8: so 'a' is a key into 'theMap', and 'soFar' is an accumulator?  What does 'padKey' do?
13:51:21 <dmhouse> What does the whole function do?
13:52:42 <ph8> it uses genNext to repeatedly generate/predict the next word in a sentence using ngrams
13:52:55 <bakert> crap newbie question if you don't mind.  i have two lists, x and y and i want to delete everything in x from y.  what's the standard way?  something with map and delete?
13:52:58 <ph8> for example, i gave it a null input (or input that isn't indexed like 'foo foo') to produce the sentence above
13:53:09 <Syzygy-> bakert: y \\ x work?
13:53:13 <nmessenger> ?type (\\)
13:53:14 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:53:15 <ph8> if i gave it "the flower" i may get "the flower of the chape..." as output
13:53:18 <Syzygy-> > [1,2,3,4] \\ [2,3,4,5]
13:53:19 <lambdabot>  [1]
13:53:19 <ph8> (up to sentence end)
13:53:20 <bakert> wow new crazy syntax.  love it.
13:53:25 <bakert> thanks folks
13:53:35 <bakert> what's the \\ operator called?
13:53:38 <therp> bakert: that's a regular infix operator
13:53:40 <Syzygy-> It isn't that crazy. It's modelled on \setminus
13:53:41 <ph8> nmessenger: Padkey ensures 2 string keys
13:53:44 <ph8> ["Foo", "Bar"]
13:53:49 <dmhouse> bakert: it's a nice exercise to think about what the definition would be for (\\).
13:53:55 <ph8> if it's given ["Bar"] it'll convert it to ["", "Bar"]
13:53:55 <nmessenger> ?google n-gram
13:53:56 <dmhouse> bakert: tip: it involves filter and elem.
13:53:58 <lambdabot> http://en.wikipedia.org/wiki/N-gram
13:54:24 <bakert> dmhouse, ah think you've given it to me there ... let me go check
13:54:29 <lisppaste2> ph8 annotated #33842 with "Example N-Gram Output" at http://paste.lisp.org/display/33842#2
13:54:44 <svref> What's a good strategy for instancing Eq for cyclic data?
13:55:12 <dmhouse> svref: can you figure out the periodicity?
13:55:30 <svref> I don't think so ... they're arbitrary graphs.
13:56:20 <dmhouse> Oh, right, I see what you mean.
13:57:04 <dmhouse> And I don't really know. I'm sure I could come up with a naive algorithm but it sounds like one of those classic problems there's going to be a ready-made algorithm for.
13:57:18 <nmessenger> ph8: first change I'd make: since (last (last key) /= '.') is a common subexpression, I'd give it a name like 'endOfSentence' in the where clause.  Doesn't help your bug though.  I've not yet finished reading the code.
13:58:23 <svref> Maybe I could keep a set of data I've visited, and not re-compute those node's equality.
13:58:40 <svref> This old lisp hacker thinks == shouldn't allocate heap though.  :)
13:58:55 <ph8> thing is, it works as expected but ends on an exception - which isn't nice
14:00:05 <nmessenger> ph8: I gotta go, but try changing (\e -> print "") to (\e -> return "")
14:00:49 <nmessenger> or, return '' (whichever is the correct type)
14:01:00 <nmessenger> wait, that doesn't make sense
14:01:32 <ph8> cheers dude
14:01:39 <malebria> Good night.
14:01:41 <nmessenger> later
14:03:57 <bakert> dmhouse, "mapdeletething x y = filter (\a -> not $ a `elem` y) x"' -- that took a while!
14:04:40 <dmhouse> bakert: :) x \\ y = filter (`notElem` y) x is the precise definition, I believe.
14:05:06 <lisppaste2> metaperl pasted "are record accessors global functions?" at http://paste.lisp.org/display/33844
14:05:45 <allbery_b> yes, they are
14:06:08 <metaperl> allbery_b - ok thats why line 67 of this paste http://paste.lisp.org/display/33844 .. can make use of the record accessor defined at line 23 then
14:13:07 <ph8> @hoogle hputstr
14:13:07 <lambdabot> IO.hPutStr :: Handle -> String -> IO ()
14:13:07 <lambdabot> IO.hPutStrLn :: Handle -> String -> IO ()
14:13:19 <ph8> @hoogle stderr
14:13:19 <lambdabot> IO.stderr :: Handle
14:13:20 <emu> its return () not return ""
14:13:30 <ph8> ty
14:14:04 <ph8>     Couldn't match `IO a' against `Char'
14:14:04 <ph8>       Expected type: [[IO a]]
14:14:04 <ph8>       Inferred type: [[Char]]
14:14:11 <ph8> >	lastLastChar = catch (last (last key)) (\e -> return ())
14:14:13 <metaperl> @seen Cale
14:14:13 <lambdabot> Cale is in #oasis, #ghc and #haskell. I last heard Cale speak 2h 4m 27s ago.
14:14:26 <metaperl> 2 hours away from IRC --- this is unthinkable
14:14:53 <allbery_b> heh
14:15:06 <dmhouse> ?ask ndm when Hoogle 4's due because http://neilmitchell.blogspot.com/2006/12/hoogle-progress-hsman-features.html looks really, really cool and I want to write the Emacs integration right now :)
14:15:06 <lambdabot> Consider it noted.
14:18:07 <ph8> can anyone tell me how to read from argv in haskell?
14:18:12 <ph8> command line args
14:18:15 <norpan> getArgs
14:18:22 <mauke> ?type getArgs
14:18:23 <lambdabot> Not in scope: `getArgs'
14:18:31 <allbery_b> ?index getArgs
14:18:32 <lambdabot> System.Environment
14:18:56 <ph8> ?type System.Environment.getArgs
14:18:56 <ph8> ty
14:18:57 <lambdabot> IO [String]
14:18:58 <bakert> import System.Environment; args <- getArgs -- then you have list of arguments called args
14:20:51 <ph8> and is exit valid for ending program execution?
14:20:55 <ph8> e.g. if the args are in a bad format
14:21:08 <mauke> @hoogle Int -> IO a
14:21:08 <lambdabot> Foreign.Marshal.Alloc.allocaBytes :: Int -> (Ptr a -> IO b) -> IO b
14:21:19 <allbery_b> ?hoogle exit
14:21:20 <lambdabot> System.Exit :: module
14:21:20 <lambdabot> System.exitFailure :: IO a
14:21:20 <lambdabot> System.exitWith :: ExitCode -> IO a
14:21:39 <ph8> ty
14:37:24 <metaperl> if anyone is bored and wants to follow a huge chain of type inferences... then look at this for me.. otherwise I email Cale and wait: readDocument :: Attributes -> String -> IOStateArrow s b XmlTree
14:37:39 <metaperl> per this: http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_arrow/Text-XML-HXT-Arrow-ReadDocument.html#v%3AreadDocument
14:37:41 <lambdabot> http://tinyurl.com/yybvmz
14:37:55 <ph8> ?type exitWith
14:37:56 <lambdabot> Not in scope: `exitWith'
14:38:01 <ph8> ?type System.exitWith
14:38:02 <lambdabot> forall a. GHC.IOBase.ExitCode -> IO a
14:38:06 <metaperl> I do not understand the expression IOStateArrow s b XmlTree
14:38:07 <ph8> how can i instiate a type of ExitCode?
14:38:14 <ph8> * instantiate
14:38:42 <allbery_b> ?doc System.Exit
14:38:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Exit.html
14:38:52 <xerox> metaperl: click on it
14:38:53 <ph8> i want to pass the correct error code though
14:39:05 <allbery_b> click on it
14:39:14 <metaperl> click on what?
14:39:14 <ph8> have done
14:39:20 <allbery_b> read it.
14:39:24 <ph8> what am i looking for?
14:39:28 <ph8> i don't see any examples
14:39:30 <xerox> metaperl: on what you don't understand, IOStateArrow I presume
14:39:50 <allbery_b> um.  I shouldn't think you would need them
14:40:04 <metaperl> ok I will type up my confusion... hold on
14:40:43 <lisppaste2> metaperl pasted "ph8, here's an exitfailure exapmle" at http://paste.lisp.org/display/33846
14:40:46 <ph8> ty
14:40:47 <xerox> I conjecture that your answer is two clicks away.
14:41:12 <metaperl> ok, my confusion is outlined in great detail here: http://rafb.net/p/MgG8OZ34.html
14:41:13 <lambdabot> Title: Nopaste - No description
14:42:17 <xerox> Is that past cut?
14:42:19 <xerox> *paste
14:42:32 <ph8> exitWith (exitFailure (-1))
14:42:33 <metaperl> I fixed it up: http://rafb.net/p/1uOPjU49.html
14:42:34 <ph8> is wrong alledgedly
14:42:35 <lambdabot> Title: Nopaste - No description
14:42:41 <ph8> ?type exitFailure
14:42:41 <metaperl> It is an email I wrote to cale but did not send
14:42:42 <lambdabot> Not in scope: `exitFailure'
14:42:43 <ph8> ?type ExitFailure
14:42:44 <lambdabot> Not in scope: data constructor `ExitFailure'
14:42:48 <ph8> ?hoogle ExitFailure
14:42:49 <lambdabot> System.Exit.ExitFailure :: Int -> ExitCode
14:42:49 <lambdabot> System.exitFailure :: IO a
14:42:53 <ph8> ah
14:42:55 <metaperl> ph8, did you get my paste for you?
14:43:00 <xerox> metaperl: the very last line misses something important.
14:43:02 <ph8> yes thanks!
14:43:24 <ph8> Main.lhs:27:30: Module `System.Exit' does not export `ExitFailure'
14:43:26 <ph8> is it a new feature?
14:43:57 <xerox> Namely "= IOSLA { runIOSLA :: (s -> a -> IO (s, [b])) }".
14:43:59 <metaperl> The expression "IOStateArrow s b XmlTree" confuses me
14:44:11 <Lemmih> ph8: ExitCode(ExitFailure)
14:44:23 <metaperl> you mean the XIOState aspect?
14:44:32 <ph8> @hoogle ExitCode
14:44:33 <lambdabot> System.Exit.ExitCode :: data ExitCode
14:44:33 <lambdabot> System.Process.getProcessExitCode :: ProcessHandle -> IO (Maybe ExitCode)
14:44:34 <Lemmih> metaperl: 'IOStateArrow s' is the arrow.
14:45:08 <metaperl> oh so that could be written (IOStateArrow s)
14:45:12 <ph8> ty lemmih
14:45:28 <metaperl> oh so that could be written (IOStateArrow s) b XmlTree
14:45:48 <Lemmih> metaperl: Yes.
14:45:53 <metaperl> and the arrow would be of type (IOStateArrow s) from b to XmlTree
14:45:58 <allbery_b> better is to import ExitCode (..) from it, or just import everything --- not like it's a big module filled with cnflicts (like, say, Data.Map)
14:46:01 <Lemmih> metaperl: Exactly.
14:46:51 <metaperl> ok... do you know what "n" stands for in this tpe signature ---root :: [a n XmlTree] -> [a n XmlTree] -> a n XmlTree
14:47:17 <xerox> IOStateArrow s.
14:47:29 <metaperl> no, that would be a
14:47:34 <metaperl> the type of the arrow
14:47:48 <xerox> Then is just general on the type of the input
15:00:33 <shapr> Yow!
15:00:46 <augustss> Yow!
15:00:49 <augustss> @yow
15:00:50 <lambdabot> Hello?  Enema Bondage?  I'm calling because I want to be happy, I
15:00:50 <lambdabot> guess ...
15:00:51 <mbishop> @yow
15:00:52 <lambdabot> UH-OH!!  I think KEN is OVER-DUE on his R.V. PAYMENTS and HE'S having a
15:00:52 <lambdabot> NERVOUS BREAKDOWN too!!  Ha ha.
15:02:03 * shapr boings cheerfully
15:02:09 <LoganCapaldo> ?. elite yow
15:02:09 <lambdabot> Yo\/\/! n0W \/\/3 c4N 8ec0ME al(ohOLi($!
15:02:44 <LoganCapaldo> lambdabot must be the only bot in all of IRCdom with a command composition command
15:03:14 <shapr> probably so
15:03:34 <Igloo> Nope, I wrote one for some eggdrop stuff before lambdabot even existed
15:03:53 <newsham> ?. . . . . .
15:03:53 <lambdabot> compose module failed: IRCRaised Parse error: "Not"
15:06:43 <ph8> is there any sort of built in trim type function, to take the empty strings from a list of strings, or should i use filter?
15:07:04 <newsham> ?type null
15:07:05 <lambdabot> forall a. [a] -> Bool
15:07:14 <Lemmih> > filter (not.null) ["Hello","","World"]
15:07:15 <lambdabot>  ["Hello","World"]
15:08:30 <Cale> hi
15:10:28 <shapr> \. yow
15:13:24 <Lemmih> woy ./
15:13:39 <vincenz> woy wot?
15:16:22 <araujo> Monadic New Year everyone!
15:16:41 <shapr> yay!
15:17:01 <shapr> hoi RemiTurk
15:17:14 <RemiTurk> hi shapr
15:17:32 <RemiTurk> and a happy new year to everyone
15:18:03 <velco> is there any clever trick to use data type with unary/binary/etc/not-nullary constructors as an instance of Ix ?
15:18:40 <velco> as if all the ctors were nullary as far as Ix is concerned.
15:19:30 <augustss> velco: no
15:19:36 <augustss> not that I know of
15:19:48 <augustss> I have often wished for a way
15:20:16 <velco> well, I've got some kludge in mind ...
15:21:45 <velco> like mainaining mapping between ctors and anither Ix-able type with an aux array or similar structure, but I don't like it much
15:27:18 <ph8> ?type words
15:27:20 <lambdabot> String -> [String]
15:27:47 <ph8> so, if i map words across a [[char]], i'll get [[[char]]]
15:27:57 <Axioplase> ?type runCont
15:27:58 <lambdabot> Not in scope: `runCont'
15:28:08 <Axioplase> ?type Control.Monad.Cont.runCont
15:28:10 <lambdabot> forall r a. Control.Monad.Cont.Cont r a -> (a -> r) -> r
15:29:01 <Axioplase> ph8: yes
15:29:26 <xerox> ph8: just type :t map words in GHCi
15:30:52 <Axioplase> ?type liftM
15:30:53 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
15:33:04 <Axioplase> is there a difference between "callCC \k -> if A then B else C" and "if A then callCC \k ->B else callCC \k-> C" from a contination point of view ?
15:41:17 <ph8> ?type filter
15:41:18 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:41:34 <ph8> to filter [[a]], i map filter across it right?
15:41:39 <ph8> getting some weird behaviour
15:42:28 <bakert> ph8, does filter on a list of lists run the filter against each list, rather than each element of each list?
15:42:35 <bakert> i would have thought so
15:42:48 <ph8> so yes then :)
15:43:00 <Axioplase> ph8: well, depends on what you want to do...
15:43:50 <ph8> i think i need to do some clever lambda stuff
15:43:52 <ph8> which is a bit above me
15:44:08 <ph8> well, or make a new function :)
15:45:01 <ph8> wow
15:45:03 <ph8> worked first time :)
15:45:45 <augustss> velco: you can, of course, define your own Ix instance for your data type
15:46:52 <lisppaste2> velco pasted "ugly Ix" at http://paste.lisp.org/display/33850
15:47:07 <velco> yeah, I'm trying something ...
15:47:35 <Axioplase> is there a loop function for monads ? so that foo becomes foo;foo;foo;...
15:48:07 <velco> btw, that paste with main being ``main = print z'' segfaults ghc 6.6 ..
15:48:34 <allbery_b> mapM / forM, replicateM, ...
15:48:37 <Igloo> Axioplase: I don't think there's a library function for that, no
15:48:44 <augustss> velco: is that no thing in each constructor something you want, or is it just for Ix?
15:48:54 <velco> just for Ix
15:49:04 <augustss> velco: then there
15:49:11 <augustss> then there is a neater way
15:49:12 <lightstep> Axioplase, fix . (>>)
15:49:17 <Axioplase> thanks
15:50:25 <lisppaste2> augustss annotated #33850 with "no" at http://paste.lisp.org/display/33850#1
15:50:45 <velco> oh, thanks.
15:50:58 <Axioplase> lightstep: err.. in what module is fix ?
15:51:11 <lightstep> Control.Monad.Fix
15:51:12 <allbery_b> ?index fix
15:51:12 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:51:23 <augustss> Igloo: btw, did you recieve my ghc patch this time?
15:51:40 <Axioplase> thanks
15:52:56 <Igloo> augustss: Yup, thanks. Just being slow discussing it with the Simons due to holidays
15:53:23 <augustss> Igloo: no problem, I just wanted to know it didn't fall into the spam bucket
15:53:32 <Igloo> *nod*
16:05:33 <dons> moin
16:05:48 <dons> ?users
16:05:48 <lambdabot> Maximum users seen in #haskell: 309, currently: 283 (91.6%), active: 45 (15.9%)
16:06:00 <astrolabe> hi dons
16:07:42 <nornagon> moin dons :)
16:11:12 <Axioplase> is total recursion compulsory for backtracking ? (I'm trying to sort a list with backtracking)
16:12:22 <ph8> >	where
16:12:22 <ph8> >	firstResult <- repGen a theMap []
16:12:26 <ph8> can i not do that in where's ?
16:13:17 <xerox> No.
16:13:24 <ph8> bugger
16:15:10 <dons> its monadic, you need to explicitly order when it is evaluated in a do block
16:18:28 <allbery_b> where is for local definitions
16:40:27 <svref> Data.Set is useless without requiring Ord, right?
16:41:38 <lightstep> yes
16:41:40 <svref> Is there some way to provide two implementations of a function, one if its called on an Ord type, and another if its called on a non-Ord type?
16:42:20 <pbx> Question from an ignorant non-Haskell programmer -- where are most people here getting initial exposure Haskell?  University? Personal study?
16:42:36 <svref> pbx: Personal study (and IRC :)
16:42:42 <pbx> heh
16:43:03 <lightstep> svref, not in simple haskell - you need some weird reflection stuff. usually libraries provide two functions, like sort and sortBy
16:43:05 <pejo> pbx, right in this channel a lot of people seem to have taken some fp course in university.
16:43:08 <Saizan> blogs :D
16:43:52 <svref> Saizan: you paste me your links please?
16:43:58 <quazimodo> i read a bit about lazy evaluation... seems like a good idea for the most part
16:44:08 <quazimodo> surprised it isnt used in most other languages
16:44:27 <Saizan> the first time i've read of haskell was on defmacro.org
16:44:59 <Saizan> which i founded on digg iirc
16:45:01 <mattam> quazimodo: most other languages are at a lower level of abstraction.
16:45:05 <pejo> quazi, it has a couple of problems as well.
16:45:26 <svref> The first time I read about Haskell was when a guy on #ocaml took me aside and said I was learning the wrong language.
16:45:58 <lightstep> quazimodo, it forces you to use some abstract type for interaction with the external world (which you may consider a good thing)
16:46:06 <quazimodo> pejo, that is why i mentioned for the most part, but the pros outweigh the cons significantly?
16:46:07 <dons> heh http://ari-rahikkala.livejournal.com/20490.html
16:46:09 <lambdabot> Title: ari_rahikkala: Who knows, perhaps some of it will rub off on me
16:46:15 <pbx> svref: That's funny. A double-agent!
16:46:16 <dons> haskell gets the ladies
16:46:34 <quazimodo> lightstep, that is why the IO is not taught early on is it?
16:46:40 <lightstep> yes
16:46:41 <dons> svref: really. wow.
16:46:49 <dons> we have moles in #ocaml?
16:47:09 <pejo> quazi, shrug, depends on your goals.
16:47:45 <dons> quazimodo: laziness simplies a lot of coding tasks, since you can write a general, infinite structure and just use as much as you need, at the same time though, it complicates reasoning about space usage
16:47:58 <dons> hence there's quite sophisticated heap / space profilers with most haskell systems
16:48:13 <emu> have people considered using different mathematical symbols for = and == in the output of lhs w/latex?
16:48:17 <svref> dons: yeah, he disabused me of some notions that had led me to disqualify Haskell in language search.
16:48:18 <pejo> (There is nothing preventing a design of a strict functional language with a good type system, including monads).
16:48:25 <pbx> I think I've asked this before, but what do you use for a pastebin here?  (I run a pastebin site but the colorizer has no Haskell mode...)
16:48:26 <rahikkala> dons: I thought nobody would notice that :p
16:48:47 <emu> lisppaste2: urk
16:48:48 <emu> lisppaste2: url
16:48:49 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
16:48:57 <pejo> dons, good you said it, makes me not alwyas being the bad guy saying it's hard to reason about lazy evaluation. :P
16:49:00 <dons> rahikkala: hehe :)
16:49:08 <pbx> emu: Thanks. I don't need to use it, I was just curious.
16:49:16 <dons> its hard to reason about lazy eval, but not impossible :)
16:49:19 <pbx> svref: What were those misconceptions?
16:49:42 <dons> i don't seem to have any trouble with it these days. Cale pointed out though, that if you program haskell as if it was strict, you'll get some funny notions about memory usage
16:50:16 <svref> pbx: "haskell has no side-effects", which pretty quickly leads to it being useless outside of Uni
16:50:48 <pbx> Ah
16:50:49 <bos> you just have to perform an action on the infinite ladies inside the IO monad.
16:50:59 <newsham> "you need a phd to perform IO"
16:51:12 <pbx> So a monad is like gonad but... mo?
16:51:23 <pbx> It's all becoming clear.
16:51:37 <newsham> phonetic distance != semantic distance
16:51:57 <pejo> dons, well, I'm fine with (high) memory usage, as long as it's predictable.
16:52:01 <emu> newsham: does the converse apply?
16:52:04 <newsham> one two, won lost.
16:52:08 <Cale> I'd even make the claim that learning to reason about lazy evaluation is exactly as hard as learning to reason about strict evaluation.
16:52:11 <emu> "you perform IO, you get a phd"
16:52:16 <newsham> fruit flies like a banana, time flies like an arrow.
16:52:26 <newsham> converse of?
16:52:54 <newsham> emu: i dont know if that misconception holds
16:53:00 <newsham> err.. is common..
16:53:05 <Cale> It's just that most programmers have already learned to reason about strict evaluation while they were learning their first programming language, and were not confronted with another kind of evaluation until they learned Haskell, so they find that a sticking point.
16:53:20 <mattam> Cale: isn't lazy evaluation harder because less local ?
16:54:00 <pejo> Cale, if it isn't hard to reason about lazy evaluation, space leaks shouldn't be a problem from program transformations.
16:54:37 <Korollary> Mmmm. Infinite ladies.
16:54:48 <emu> ladies = repeat lady
16:55:01 <Cale> Well, it's "less local" in one sense.
16:55:03 <newsham> infinite turtles (all the way down)
16:55:28 <Korollary> sadly, maximum ladies diverges.
16:55:48 <dons> mmm haskell junkie:
16:55:49 <dons> "  I need to have my dose of Haskell everyday :-) But, I have not always access to a computer. So, I
16:55:52 <dons>   have created a widset to allow me to read the blogs from Planet Haskell on my mobile phone."
16:55:54 <newsham> ladies have high constant overheads
16:55:58 <dons> that's alphecar
16:56:28 <Korollary> That's not healthy
16:56:49 <bos> boy, ocaml is phenomenally ugly.
16:57:00 --- topic: '["Get yourself some cognitive dissonance!", "Haskell - the language of ICFP winners 3 years running", "Logs: http://tunes.org/~nef/logs/haskell/"]'
16:57:00 --- topic: set by dons on [Fri Dec 08 21:02:10 2006]
16:57:06 <Korollary> It's somewhat ugly. You can get used to it.
16:57:10 <ski> bos : how so ?
16:57:18 <Cale> whee
16:57:25 <bos> it has all this extra syntax hanging off it.
16:57:30 <dons> it took 4 years to get the haskell syntax right, I guess the ocaml guys wanted to work on their code generator instead :)
16:57:58 <Korollary> I think F# has haskell style offside rules for the let blocks now.
16:57:59 <bos> lots of little dangling tick marks, 4-level nesting of "let rec", etc.
16:58:09 <Cale> and in the process of improving syntax, we came up with typeclasses :)
16:58:23 <dons> starting about here: http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg00011.html and going for the next 4-5 years, its all syntax
16:58:32 <lambdabot> Title: Nested Comments in Haskell
16:58:34 <mattam> ocaml inherits from SML syntax i think
16:58:35 * dons offers praise to the syntax addicts of the early 90s
16:58:39 <tennin> is F# still active?
16:58:46 <mbishop> F# is quite active
16:58:52 <mbishop> in fact it's just a wee baby really
16:59:08 <Cale> http://www.informatik.uni-kiel.de/~curry/listarchive/0017.html
16:59:09 <emu> sml is a lot cleaner
16:59:11 <lambdabot> Title: Re: Curry from Philip Wadler on 1996-12-19 (Curry mailing list)
16:59:25 <Korollary> hmm, how is sml that much cleaner?
16:59:30 <emu> yea i could never stand this in a functional language: let rec foo x = match x with ....
16:59:54 <dons> Cale: exactly. though there's an earlier ref on the haskell list too
17:00:08 <Cale> dons: yeah, that's the first google hit I got for it
17:00:29 <emu> Korollary: well it has a formal semantics, which is nice.  but also the syntax has lots less weird crap.
17:00:58 <dons> ah, 1992, http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg00737.html
17:00:59 <lambdabot> Title: Literate comments
17:01:07 <dons> ?where+ wadlers_law http://www.cse.unsw.edu.au/~dons/haskell-1990-2006/msg00737.html
17:01:08 <lambdabot> Done.
17:01:10 <emu> though, mutually recursive functions have to be placed together, which is somewhat annoying
17:01:42 <dons> mmm. should put up a haskell.org wiki page for this..
17:01:43 <shoffsta> I want to declare a class instance like: 'instance (Num a) => Show a where ...'
17:01:50 <shoffsta> but ghc gives me an error:
17:01:53 <shoffsta>     Illegal instance declaration for `Show a'rn        (The instance type must be of form (T a b c)rn         where T is not a synonym, and a,b,c are distinct type variables)
17:01:59 <shoffsta> why is that?
17:01:59 <emu> that requires incoherant instances and overlapping
17:02:44 <emu> you could add -fglasgow-exts, though i am confused how you go about planning to implement such an instance
17:03:18 <shoffsta> oh, well, I wasn't planning on doing this for 'Num' and 'Show', just as a short example to illustrate the problem
17:04:00 <shoffsta> hmm... with -fglasgow-exts, I still get the error:
17:04:01 <shoffsta> Constraint is no smaller than the instance headrn      in the constraint: Num a
17:04:36 <shoffsta> but -fallow-undecidable-instances makes it work. hmm
17:04:40 <kpreid> yes
17:05:00 <kpreid> it is potentially-undecidable because ghc has no proof that the process will terminate
17:05:17 <shoffsta> why is that?
17:05:53 <dons> ?wiki Wadlers_Law
17:05:54 <lambdabot> http://www.haskell.org/haskellwiki/Wadlers_Law
17:06:59 <bulio> Just wondering, for a complete programming newbie, is haskell easier or harder to learn than say, python?
17:07:22 <dons> if you've never programmed before, probably not
17:07:33 <dons> haskell was (partially) designed as a newbie's programming language
17:07:40 <dons> and there are lots of resources for teaching it to non-programmers
17:08:08 <araujo> bulio, haskell is _very_ easy to learn than other langs. ; though probably harder to master.
17:08:22 <bulio> why is it so much easier, if I might inquire
17:08:26 <dons> bulio: some good references if you're starting out, http://haskell.org/haskellwiki/Learning_Haskell
17:08:28 <lambdabot> Title: Learning Haskell - HaskellWiki
17:08:30 <kpreid> shoffsta: read http://haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#instance-rules -- "These restrictions ensure that context reduction terminates: each reduction step makes the problem smaller by at least one constructor."
17:08:32 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/8bwuf
17:08:39 <dons> bulio: ah, it has very clear semantics, and doesn't tend to mix concepts
17:08:56 <dons>  so understanding what your code is doing is often simpler than less rigourously defined languages
17:09:17 <araujo> bulio, pure languages tend to be easier (imho) because it only imposes a well defined paradigm through all the language.
17:09:30 <araujo> Making the languages very compact.
17:09:31 <dons> features like pattern matching are quite intuitive too, and not present in most other languages
17:09:45 <dons> fac 0 = 1 ; fac n = n * fac (n-1)
17:09:55 <dons> (or whatever ;)
17:10:04 <bulio> alright, I'll give the site a look
17:10:06 <bulio> thyanks!
17:10:08 <dons> bulio: anyway, just dive in. there's lots of resources on haskell.org
17:10:16 <dons> > map (^2) [1..] -- and you can run code here!
17:10:18 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
17:10:41 <mbishop> I must say pattern matching in haskell is nice in that it doesn't need explicit "case x match blah" stuff
17:10:46 <dons> several people in this very channel are paid to teach beginner programmers too :)
17:10:54 <dons> so you get free tutors if you hang out here
17:11:03 <shoffsta> kpreid: ah, thanks!
17:11:06 <mbishop> dons isn't paid to be here, but he should be :P
17:11:14 <dons> mbishop: yeah, almost a killer feature for compiler transforms :)
17:11:26 <dons> rename (Let v e e') = ..
17:11:31 <dons> rename (App f x)  = ..
17:11:38 <dons> or interpreters
17:14:28 <dons> ?users
17:14:29 <lambdabot> Maximum users seen in #haskell: 309, currently: 277 (89.6%), active: 13 (4.7%)
17:14:37 <pbx> Another n00b question -- is "The Haskell School of Expression" a good intro?  I've found mixed reviews.
17:15:48 <dons> yeah, its good. (some say great). "The Craft of Functional Programming" is also good
17:16:15 <LoganCapaldo> Does it have a cover like this though? http://vividpicture.com/aleks/atari/forth.jpg
17:16:17 <dons> check the textbooks page for some other options
17:16:32 <dons> pbx: on haskell.org, yeah?
17:16:45 <dons> LoganCapaldo: that's pretty cool
17:16:47 <kpreid> LoganCapaldo: egad
17:17:02 <dons> or scary
17:17:07 <dons> I think more scary, the longer I look
17:17:09 <tennin> I remember being a bit disappointed by "...Expression" when I looked through it at the bookstore recently, but I've forgotten why exactly
17:17:34 <dons> i'd say "buy TaPL" :) but its not a haskell intro book
17:17:42 <pbx> Too bad, I like "classic" CS books like K&R or SICP
17:17:50 <pbx> dons: Thanks, found it
17:18:56 <shapr> Speaking of awesome books, my copy of Art of Science & Engineering has shipped!!
17:19:01 * shapr boings furiously
17:19:01 <pejo> (If you like TaPL you'll like Attapl too, I bet).
17:19:33 <shapr> pbx: I think #haskell is the best Haskell course yet.
17:20:11 <pbx> shapr: Seems like a nice channel.
17:20:43 <shapr> Yeah, I like #haskell
17:21:14 <shapr> In the interests of full disclosure, I also started #haskell... so any complaints can probably be directed to me :-)
17:21:26 <pbx> But don't talk like that, or you'll have people camping out here asking things like "SIMPLE QUESTION HOW DO I MAKE A WEB SIGHT IN HASKELL
17:21:29 <tennin> Did TAPL always have the same brick wall cover?
17:21:45 <dons> tennin: yeah, I think so
17:21:52 <dons> at least it has for the last 3 or 4 years..
17:21:52 <shapr> We've had one or two of those "CAN I BUILD A WEBSIGHT" guys over the years.
17:22:05 <dons> shapr: almost all of  them were gschuett though ;)
17:22:11 <dons> ?protontorpedo
17:22:12 <lambdabot> is haskell better than APL or perl or clisp?
17:22:22 <shapr> @keal
17:22:23 <lambdabot> where can i find opensource schematics of Linus Torvalds' x86 clone?
17:22:24 <dons> mm, anyone know how to get tab completion of lambdabot commands in irssi?
17:22:43 <dylan> dons: yes
17:22:47 <dylan> one sec
17:22:56 <dons> ooh
17:23:02 <velco> make the bot register with nicks corresponding to all the commands ...
17:23:03 <mbishop> @protontorpedo
17:23:03 <lambdabot> The things I dotn get about relatinal databases is that they take wrok to maintain
17:23:07 <dons> velco: heh
17:23:34 <shapr> pbx: dons collected the most, um, 'challenged' user quotes in commands like protontorpedo and keal.
17:23:49 <dons> :)
17:24:55 <shapr> Not that I haven't had my own challenged moments...
17:25:22 <nornagon> @protontorpedo
17:25:22 <lambdabot> paul graham said static typing is a problem for macros building
17:25:32 <dylan> dons: you need to edit ~/.irssi/config
17:25:37 <pbx> shapr: Oh yeah, I've seen that in action here...
17:25:41 <shapr> pbx: So how'd you find Haskell and #haskell?
17:25:46 <pbx> ?keal
17:25:46 <lambdabot> i use an 8088
17:26:05 <dons> dylan: edit it in what way?
17:26:17 <dylan> dons: that is what I am trying to remember
17:26:20 * dons pokes around
17:26:31 <dylan> and the ssh connection to my irssi instance is lagged all to hell
17:26:50 <pbx> shapr: It just kept showing up in my web/blog searches.  I'm a Python programmer.  I think I was digging around trying to figure out if Python stole list comprehensions from Haskell or Erlang :)
17:27:55 <dons> pbx, I think they took list comprehensions from the researchers of the late 80s, most of whom became haskell guys
17:27:57 <shapr> Were you at EuroPython 2004?
17:28:04 <Jaak> dons: /help completion might help
17:28:05 <pbx> Nope.
17:28:16 <shapr> Oh, your name sounded familiar, I thought I might have met you there.
17:28:44 <dons> Jaak: ah nice!
17:28:47 <dylan> replaces = ( { text = ".)"; replace = ":)"; }, }
17:28:47 <dons> Jaak++
17:29:45 <pbx> OK Haskell folks, thanks for all the info. I'll be back another day.
17:29:52 <shapr> Come back soon!
17:29:57 <shapr> I went from Python to Haskell myself.
17:30:16 <shapr> Just a few years earlier.
17:30:31 <dylan> I went from perl to scheme to perl to ruby to perl to python to perl to ocaml to erlang to ocaml and finally to haskell....
17:30:58 <dylan> I think I tried about nine differetn times to learn ocaml, and finally I got it...
17:31:04 <dylan> haskell wsa a lot easier.
17:31:22 <dylan> man, it's not nice not being able to see what I type until a few seconds after....
17:31:29 <dons> ok. cool. that works nicely Jaak
17:31:32 <dons> ?source Data.List
17:31:32 <Lunchy> I'm having a hard time giving up perl too...trying to learn haskell at the moment...started a week or two ago
17:31:33 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
17:31:44 <shapr> Lunchy: Got any questions?
17:32:08 <Lunchy> tons, but probably can't think of them right now...althogh I'm having trouble with a little program
17:32:22 <shapr> ?
17:32:33 <Jaak> dons: np, it only shows how superior irssi is over other irc clients :P
17:32:37 <Lunchy> I'm tryin to recursivly print a directory tree, but it runs down one directory leaf and stops
17:32:47 <shapr> @paste
17:32:47 <lambdabot> http://paste.lisp.org/new/haskell
17:32:50 <Jaak> id love to be able to script it in other languages than perl, tho'
17:32:50 <Lunchy> care to see a pastbin?
17:32:53 <shapr> Can you pastebin the code?
17:33:00 <Lunchy> sure, one sec
17:33:30 <Lunchy> just don't laugh at me! ;) http://paste.lisp.org/display/33859
17:33:40 <dons> mm, so I can do, for example, h.o        http://haskell.org
17:33:42 <lambdabot> Title: Haskell - HaskellWiki
17:34:26 <dons> so now I just analyse my logs, find out what words I use the most, and short cut them :)
17:34:31 <dons> productivity!
17:35:00 <dylan> Jaak: superior in features, yes... code quality is another issue entirely...
17:35:36 <bd_> Lunchy: printThing doesn't continue into xs when itsDir is true
17:35:48 <allbery_b> clearly we need an IRC client in Haskell :)
17:35:53 <Jaak> is the source that bad?
17:35:56 <dons> hircules :)
17:36:02 <shapr> hircules!
17:36:03 <Jaak> never gave it a look
17:36:18 <newsham> allberry: please make it like zenirc
17:36:23 <allbery_b> heh
17:36:30 <dylan> Jaak: it relies on undefined behavior of the C language
17:36:34 <dons> its a 2 week project to take hmp3's curses interface, and a chunk of lambdabot, and combine them into yet another irc client :)
17:36:39 <bd_> Lunchy: http://paste.lisp.org/display/33859#1
17:36:40 <shapr> dons: My prediction for 2007 is that lambdabot and yi will merge and become the core of the new emacs community.
17:36:44 <dons> basic functionality is a 10 minute job
17:36:49 <dons> shapr: heh
17:36:58 <shapr> Hey, Perl6 did it.
17:36:59 <Lunchy> lol, I KNEW it'd be something lame like that
17:37:15 <Lunchy> I've been staring at this and tinkering for a day or two
17:37:19 <bd_> Lunchy: :)
17:37:31 <bd_> Lunchy: you might want to use mapM_ to avoid the explicit recursion
17:38:12 <dons> mmm. function composition, $ grep '<dons>' * | sed 's/.*dons..//' | concat | words | sort | uniq -c | sort -r | head
17:38:15 <dons>   28867 the
17:38:18 <dons>   20426 a
17:38:20 <dons>   19338 to
17:38:23 <dons>   11807 you
17:38:25 <dons>   11234 in
17:38:34 <dons> now to work out what would be reasonable to alias
17:38:35 <Lunchy> bd_: cool thanks, I'll look into that
17:39:01 <dons> hehe,    4471 ->
17:39:36 <newsham> dons: how very http://plan9.bell-labs.com/cm/cs/doc/84/kp.ps.gz
17:39:45 <dons>    1867 ::
17:40:00 <bd_> Lunchy: also, you can use pattern matching in a monad: [recDir] <- getArgs - the error message in IO isn't too useful though
17:40:17 <dons> btw, that concat/words stuff is from h4sh, the list binding to the shel
17:41:11 <Lunchy> bd_: pattern matchin in a monad?  I'm lost :)
17:41:29 <bd_> Lunchy: main = do [recDir] <- getArgs
17:41:32 <bd_> instead of recDir !! 1
17:41:51 <bd_> note however, that the error message if the arguments isn't a list of exactly one element, is less than helpful usually
17:41:54 <Lunchy> I saw an example that was doing that, but I didn't understand what it was doing
17:43:02 <bd_> Lunchy: it's stating that getArgs returns a list of one element, and puts that element into recDir. Of course, if getArgs returns something different, it'll break.
17:43:48 <Lunchy> oh, I see now, that makes sense
17:44:50 <dons> > let [x] = take 1 "haskell" in x
17:44:52 <lambdabot>  'h'
17:45:00 <dons> > let [x] = take 2 "haskell" in x
17:45:01 <lambdabot>  Irrefutable pattern failed for pattern [x]
17:45:14 <dons> > let (x:_) = take 2 "haskell" in x
17:45:15 <lambdabot>  'h'
17:45:18 <Lunchy> what did you mean by "in a monad"
17:46:49 <dons> Lunchy: in this case, I think he meant that you match on the left hand of a <-
17:47:09 <dons> which is the monadic bind operator (binding the result of evaluating a monadic actoin to a value)
17:47:16 <dons> i.e.  args <- getArgs
17:47:19 <Lunchy> ah, gotcha
17:47:20 <dons> or c <- getChar
17:47:30 <newsham> [x] <- getArgs
17:47:30 <dons> then change that to a more structured pattern match
17:47:41 <dons>  [file,opt,x] <- getArgs
17:47:56 <bd_> downside to this of course is your error messages can be much less user-friendly :)
17:48:10 <newsham> you can catch the pattern match exception, no?
17:48:13 <dons> in haskell we have both construction and destruction built in to the language.
17:48:13 <Lunchy> yea, I'm just playin around tryin to learn, so now worries :)
17:48:20 <dons> most OO guys just get by with construcion only
17:48:34 <dons> > Just 7 -- Just is a constructor
17:48:35 <bd_> newsham: true, but `catchIO` is ugly :/
17:48:36 <lambdabot>  Just 7
17:49:14 <dons> > let f (Just x) = x ; f Nothing = error "nothing" in f (Just 2) -- and reverse construction in pattern matching on data
17:49:15 <lambdabot>  2
17:49:24 <dons> why every language with constructors doesn't also have pattern matching, I don't know
17:49:39 <dons> since it is just so obvious and powerful, once you've got tags/constructors on data
17:50:22 <dons> so you can write interpreters like this:
17:50:23 <dons> eval (IntE n)       = return n
17:50:23 <dons> eval (OpE op e1 e2) = liftM2 op (eval e1) (eval e2)
17:50:23 <dons> eval (VarE x)       = do
17:50:23 <dons>     env <- ask
17:50:25 <dons>     return $ maybe (error "undefined variable") id (M.lookup x env)
17:50:28 <dons> :)
17:50:45 <dons> where we pattern match and branch on each pattern. Any OO guys want pattern matching?
17:50:53 <bd_> :t maybe
17:50:54 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
17:50:55 <Lunchy> yes please
17:51:35 <newsham> eval arg = case arg of ....
17:51:35 <dons> and just for competion, here's the let binding:
17:51:36 <dons> eval (LetE x e1 e2) = do
17:51:37 <dons>     env <- ask
17:51:37 <dons>     v   <- eval e1
17:51:37 <dons>     local (M.insert x v) (eval e2)
17:51:43 <newsham> its cool, but not THAT cool.
17:52:16 <goltrpoat> dons:  think the 'in defense of pattern matching' link mentions the main objection that OO folk would have to pattern matching, it comes across as an encapsulation-breaking mechanism
17:52:26 <goltrpoat> think = i think
17:52:31 <dons> write, if you could get at hidden fields, no?
17:52:36 <lisppaste2> Axioplase pasted "Continuations, sorting, what do I do wrong ?" at http://paste.lisp.org/display/33862
17:52:39 <dons> which just goes to show.. well, something broken :)
17:52:41 <bd_> Which is where you don't export your constructors :)
17:53:24 <dons> yeah, we don't export constructors in haskell too
17:53:29 <newsham> bd: i dont think private scope is an issue.  you would only use the pattern in places where the constructor is exported
17:53:36 <dons> e.g. for the Dynamic type, (one that comes to mind)
17:53:40 <newsham> (ie. in friend functions)
17:54:12 <bd_> Yes, my point is not to export the constructor (and thus allow pattern matching) except in areas where one should have access to such 'private' members
17:55:06 <goltrpoat> dons:  basically, it comes across as switching on the concrete type of an interface object, which is a rather non-OO way of doing things.  so then there's the question of whether or not that's an inherent flaw in the OO methodology
17:55:14 <dons> :)
17:55:58 <Korollary> This is an interesting post regarding OO: http://etymon.blogspot.com/2006/04/what-is-object-oriented-programming.html
17:56:00 <lambdabot> Title: Etymon: What is Object-Oriented Programming, http://tinyurl.com/y63vqh
17:56:14 * dons is glad at least a few languages have clean, orthogonal data structures
17:56:55 <dons> data Tree a = Leaf a | Node (Tree a) (Tree a) ; f (Leaf a) = a ; mytree = Node (Leaf 1) (Leaf 2)
17:57:08 <dons> structures that are simple to build, take apart and define
17:57:14 <dons> its what data should be
17:57:32 <dons> first class data!
17:57:35 <Korollary> He makes the point that classes in some OO languages (perhaps unnecessarily) double as module systems.
17:58:10 <goltrpoat> dons:  heh.. and all it takes, at least in your example, is concise syntax for type unions
17:58:32 * sorear pokes ?seen
17:58:43 <Korollary> ?seen ?seen
17:58:43 <lambdabot> I haven't seen ?seen.
17:58:44 <dons> goltrpoat: yeah, we want unions, recursive types, and pattern matching
17:59:02 <dons> and paramaterised types
17:59:34 <dons> i.e. everything up to week 4 of a "Principles of Prog Lang" undergrad course...
17:59:38 <goltrpoat> hehe
17:59:42 <nornagon> Maybe (Maybe (Maybe (Maybe Int)))
17:59:45 <nornagon> :D
18:00:20 <dons> if only there was a license you had to get before you were allowed to publish a new programming language
18:00:35 <Korollary> then we would bicker about the license requirements
18:00:47 <sorear> wouldn't that have discouraged the Haskell Committee?
18:00:48 <dons> a minimum competency test, where Wadler et al review your understanding of programming languages before you get your license
18:00:50 <Korollary> (do aussies spell it license?)
18:00:51 <goltrpoat> as a side note, template specialization in c++ is a kind of pattern matching, and you can have unions (see boost::variant)
18:00:56 <goltrpoat> no recursive types though
18:00:59 <dons> ?spell license
18:01:00 <lambdabot> license
18:01:25 <dons> goltrpoat: yeah, I noticed boost::variant a few days ago. good on them!
18:01:28 <nornagon> ?spell aoeaoeulgdi,.pi
18:01:29 <lambdabot> Alkaid alleged aloud leagued opaqued
18:02:03 <pejo> Korollary, hm. That was rather good.
18:02:37 <dons> or, we should send a copy of TaPL to the ruby, python and java designers ;)
18:02:50 <allbery_b> PL competency test?  I can see it now... the only thing that would ever get Larry Wall and Guido van Rossum to agree on something regarding PL :p
18:02:50 <dons> (the perl6 guys already have their own copy :)
18:03:31 <pejo> allbery_b, lots of people in here don't seem to think subtyping is necessary, or all that useful.
18:03:32 <Korollary> (License (noun) is the US spelling. UK spelling is licence.)
18:03:42 <pejo> allbery_b, so even those who do know tapl disagree.
18:03:57 <allbery_b> er?
18:05:58 * allbery_b was referrinng to the aforementioned's diametrically opposing views
18:06:05 <pejo> allbery_b, "PL competency test" - and that leading to someone agreeing.
18:06:20 <allbery_b> ...and assuming the natie of the agreement would be "licensing sucks, lets' start open source PL licensing"
18:08:58 <dylan> huh. Data.Traversable doesn't do a mapM_
18:09:10 <dylan> only a mapM
18:09:20 <dons> is that just a sequence_ map ?
18:09:32 <dons> oh, I see forM
18:09:33 <dons> interesting
18:09:55 <dons> dylan: but it does do mapM
18:09:55 <dons> forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
18:09:56 <dons> {-# INLINE forM #-}
18:09:56 <dons> forM = flip mapM
18:10:14 <sorear> dons: why does Seen strip usermodes itself? shouldn't IRC.nick do that?
18:10:30 <dons> no idea
18:10:45 <dons> clean up the code as you see fit. and send me some patches!
18:10:53 <dons> (esp. if they're unrelated to your big changes...)
18:10:54 <dylan> why would I want to flip mapM?
18:11:13 <sorear> forM_ short_list $ do lots_of_code
18:11:13 <dons> forM [0.100] $ \x -> do some 100 line block of code ?
18:11:20 <olliej> :t forM
18:11:22 <lambdabot> Not in scope: `forM'
18:11:26 <dons> its in 6.6
18:11:49 <dylan> I'd prefer map notation.
18:11:53 <dylan> but I'm used to map from perl...
18:11:57 <emu> Korollary: its a nice post.  i wonder why he restricts the 2nd criteria to "late binding of a self parameter".  generalize that, and you get CLOS and Slate.
18:12:28 <dylan> 100-line block of code should have a name and be a function. :)
18:12:40 <olliej> :t for
18:12:41 <lambdabot> Not in scope: `for'
18:12:46 <olliej> lame-o
18:12:51 <emu> try iterate
18:12:54 <olliej> ah
18:12:57 * olliej is a moron
18:13:07 <Korollary> emu: I don't know clos. Is there no self in clos?
18:13:16 <emu> actually, the closest thing to forM for lists is map
18:13:24 <olliej> yeah
18:13:33 <olliej> emu: was just thinking
18:13:37 <emu> Korollary: it's multiple dispatch, all positional parameters are late-bound and method selected on
18:17:14 <Korollary> emu: Oh, I think he was just going for the common bit.
18:17:34 <Saizan> is open recursion a synonim of polimorphic recursion?
18:18:58 <shoffsta> Is there a command-line option in ghci equivalent to specifying ':set -i/library/path'?
18:19:03 <shoffsta> I need to run ghci trough haskell, and thus can't use ':set -i/library/path'
18:19:36 <dons> -i/ibrary/path
18:19:37 <goltrpoat> saizan:  it's just the ability for methods of an object to call other methods of the same object
18:20:05 <goltrpoat> ie the self or this keyword
18:20:27 <Saizan> oh, ok
18:20:33 <allbery_b> shoffsta:  at a guess, -i/library/path :)
18:21:00 <shoffsta> dons: ah! it works, thanks
18:23:54 <robreim> wow, that was tedious; for some reason running make on the gtk2hs source under wine fails to compile most of the files. copying and pasting the failed command works fine though. So I just spent the last hour or so copying and pasting lines from gtk2hs' build
18:25:05 * Korollary pours robreim a drink
18:25:38 <robreim> cheers
18:27:23 <sorear> GHC has too many passes.  I just spent half an hour fixing undefined symbol errors, and right when that's done - type errors...  What if GHC could resolve all undefined symbols to undefined and run the type checker anyways?
18:28:46 <Philippa> this may be a hint to code in smaller chunks
18:29:05 <Philippa> also, sometimes doing that'd let things type that then won't type later when you supply an implementation
18:29:45 <sorear> yes, but at least it would give you *some* of the type errors
18:30:14 <Korollary> and those errors may change afterwards
18:30:19 <Philippa> yep
18:30:27 <Philippa> doing it by hand shouldn't cost you that much time anyway
18:31:30 <Philippa> and really, undefined symbols make me want to go "ick" anyway. Usually there's a better trivial implementation than undefined
18:31:41 <goltrpoat> it'd also make the type errors that do get through, a lot less useful
18:31:43 <Philippa> (id, const something...)
18:31:46 <Korollary> does ghc report all undefined symbols at once?
18:32:10 <sorear> yes
18:33:06 <sorear> Philippa : it would be treated as Prelude.undefined only for the purpose of generating type errors.  It shouldn't generate an object file if symbols are missing.
18:34:23 <Korollary> those messages could be useful for parts of the module that don't depend on those symbols.
18:34:39 <goltrpoat> the thing is that if there's a type error somewhere in the binding group, that can be "fixed" by assigning some type to your undefined symbol, then type inference will happily do it
18:35:58 <sorear> yes, I know
18:36:16 <sorear> but the alternative is getting no type errors at all
18:36:38 <sorear> (because the typechecker currently is not run if there are undefined symbols)
18:40:57 <bdash> olliej: hahaha!
18:41:47 <bradee-oh> olliej: ha!
18:43:16 <bradee-oh> bdash: ha!
18:43:22 <sorear> yes! Seen compiles again
18:50:57 <mgsloan> operator precedence system in haskell seems rather arbitrary
18:51:26 <mgsloan> only 10 levels
18:54:31 <dons> you'd prefer arbitrary levels? :)
18:55:09 <dons> (yes, sometimes 10 isn't enough. but not all that often. most complaints seem to be that there's no -1)
18:55:23 <Korollary> and then you'd need -2?
18:55:25 <kpreid> I wonder if it was designed that way to allow normal parsers to handle the precedence
18:55:38 <sorear> It still ain't context-free.
18:55:46 <mgsloan> dons - yep, I wanna do prec level 5.5 :)
18:55:50 <dons> but I guess 10 levels is enough for most people.
18:55:56 <dons> some want fractional levels too, yes
18:56:27 <sorear> I want to directly specify the partial order.
19:01:23 <goltrpoat> there were some inter-module issues with the partial order idea
19:02:41 * shapr boings
19:05:07 <dylan> dons: using that MVar locking thing for my slang binding, I end up with "thread blocked indefinitely" errors
19:05:17 <emu> what do you boing?
19:05:48 <dylan> I'm a bit confused as to how that can happen..
19:06:56 <bd_> dylan: Does it call back into haskell?
19:07:07 <dylan> Nope
19:07:39 <dons> dylan: hmm, usually a fragment of code inside a withMVar trying to take its own lock
19:07:55 <dons> withMVar mv $ \t -> do something ;          something ... ; x <- readMVAr mv
19:08:08 <dylan> I should use the type system to discover that.
19:08:36 <Nafai> Hey shapr
19:08:49 <dylan> make all foreign imported things have a newtyoe of IO, and have my withMVar function unwrap them.
19:11:33 <dylan> Or a simple regexp.
19:11:47 <dylan> but the newtype thing is probably safer in the longrun
19:19:07 <dylan> ooooh no
19:19:16 <dylan> random characters appear on the screen
19:20:55 <Korollary> easy on zoloft
19:21:26 <dylan> I think slang might use thread local storage...
19:28:05 <shoffsta> in the haddock documentation for takusen, I see a class declaration like thus: 'class ISession sess => Statement stmt sess q | stmt sess -> q where ...'
19:28:13 <shoffsta> what does the part after the '|' mean?
19:28:44 <bd_> For any stmt and sess, there is at most one q which makes a valid instance, I think.
19:29:05 <bd_> that is, the type of q depends on and can be determined with just stmt and sess
19:29:12 <bd_> it's called functional dependencies
19:29:17 <shoffsta> ah, i see
19:30:07 <dons> The Haskell Weekly News (first for 2007) is now online, http://sequence.complete.org/hwn/20070102
19:30:09 <lambdabot> Title: Haskell Weekly News: January 02, 2007 | The Haskell Sequence
19:30:15 <dons> including new libraries, and Haskell jobs!
19:36:01 <psnl> job, I think
19:36:30 <Axioplase> isn't it possible to do an IO within a Cont ? (without redifining my own instance)
19:36:33 <dons> :)
19:36:50 <dons> also on reddit, http://programming.reddit.com/info/wonq/details   .. hint hint
19:36:51 <lambdabot> Title: Haskell Weekly News: typesafe physical dimensions and beautiful concurrency (red ...
19:37:17 <bd_> Axioplase: You can use ContT to composite Cont and IO into one monad
19:37:48 <dons> yeah, like bd_ says
19:38:04 <sorear> lambdabot: ?bot
19:38:05 <lambdabot> :)
19:38:11 <bd_> just use runContT instead of runCont (from IO of course) and use lift or liftIO to convert IO into ContT IO.
19:38:35 <allbery_b> hrm, double ghc HEAD build problem.  stage1 errored out on a nonexistent gcc (4.0.1 OSX/ppc) option; stage2 tried to build anyway and promptly fell over
19:38:56 <Axioplase> bd_: well, I lifted my print, and I use runContT but it complains (shortened a bit) : "No instance for (Ord (IO r)) In the first argument of `runContT', namely `(consume 3)'"
19:39:06 <bd_> ?paste
19:39:06 <lambdabot> http://paste.lisp.org/new/haskell
19:39:21 <bd_> Could you paste the code there please?
19:39:33 <sorear> you can do lots of full stuff with ContT a IO, for instance fork :: ContT () IO (Maybe ThreadId) that returns twice.
19:39:34 <Axioplase> sure
19:39:39 <sorear> s/full/fun
19:40:10 <lisppaste2> Axioplase pasted "Cont + IO" at http://paste.lisp.org/display/33866
19:40:47 <Axioplase> ha.. seems to be because of the "id". It goes better when my cont is "print"
19:41:13 <bd_> oh, yes
19:41:16 <bd_> return :)
19:41:31 <bd_> since the final function needs to be in the outer monad
19:42:00 <Axioplase> but isn't Cont the outer one ?
19:42:17 <Axioplase> which means that I should liftIO the print...
19:42:23 <sorear> IO is always outermost
19:42:48 <Axioplase> ha.
19:42:57 <sorear> .. since (e.g.) IOT [] would multi-thread the world
19:43:42 <bd_> that'd be a neat trick if you could pull it off though - but how would it work if you had more than one machine running one of those?
19:43:52 * sorear wonders if IOT could be written using Concurrent Haskell
19:44:23 <dons> where each runIOT forks a thread?
19:44:43 <dons> it'd have to be run from IO to start with though
19:44:58 <sorear> where e.g. lift ([1,2]) forks in IOT []
19:49:05 <dons> oh nice, i've got my own del.icio.us tag someone added, "haskell programming, tutorial-wD[D[Driting aussie"
19:49:21 <dons> lots in that category I guess  :}
19:50:12 <sorear> D[D[D ?
19:50:36 <dons> slow wifi missing irssi's esc timeout
19:53:52 * allbery_b sighs.  wtf is ghc using a win32 gcc option?
19:57:34 <allbery_b> ...answer:  because I'm a poopyhead :/
20:04:36 <sorear> Lambdabot has compiled
20:05:40 <Axioplase> Should I say *one* thing before going to bed, it would be "forget the do notation when trying to understand the Cont monad. The bind operator makes it *so* easier to understand"
20:05:51 <Saizan> @hoogle (a -> Maybe b) -> [a] -> [b]
20:05:52 <lambdabot> Maybe.mapMaybe :: (a -> Maybe b) -> [a] -> [b]
20:06:20 <glguy> Axioplase: why is that?
20:06:38 <dons> so	good sign
20:07:17 <Axioplase> glguy: because then one writes the continuation _after_
20:07:23 <dylan> I think, I shall give up on slang and use sorear 's new vty pacakge.
20:07:39 <sorear> Because this is Haskell, I can just blindly fix the type errors and I don't have to think about whether my fixes make sense. :)
20:07:59 <sorear> OK I did a *little* thinking
20:08:05 <Axioplase> glguy: like this : (callCC $ \k k x) >>= myCont
20:09:13 <glguy> hmm, what ever works for you then :) that seems more confusing to me than the do way
20:09:49 <glguy> and is \k k x supposed to be \k -> k x?
20:09:54 <Axioplase> yes, indeed :) though I find this clearer, for I "see" myCont become the "k"
20:10:09 <Axioplase> glguy: yes, I typed to fast. 5 am.. really need to sleep...
20:10:27 <glguy> good night :
20:10:29 <glguy> )
20:13:57 <sorear> mad idea: @paste-more command
20:17:35 <nornagon> ?doc Numeric
20:17:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Numeric.html
20:18:56 <nornagon> ?hoogle digitToInt
20:18:57 <lambdabot> Char.digitToInt :: Char -> Int
20:28:33 <bos_> golly, documentation for regexps in haskell is thin.
20:30:05 <dons> support is good though. just grab Text.Regex.*
20:30:34 <bos_> i see there's also Text.Regexp.Lazt
20:30:36 <nornagon> hm, in an algebraic type, can you specify typeclass restrictions on certain data constructors?
20:30:38 <dons> there's also pcre, posix, and more
20:30:39 <nornagon> i.e, data Foo = Int (Num a) => a | Real (Fractional a) => a
20:30:39 <bos_> s/t/y/
20:30:48 <dons> http://darcs.haskell.org/packages/regex-posix/
20:30:50 <lambdabot> Title: Index of /packages/regex-posix
20:31:02 <dons> ?docs Text.Regex.Posix
20:31:03 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex-Posix.html
20:31:22 <bos_> ooh, ?docs is my new best friend. after dons, that is.
20:31:29 <augustss> nornagon: yes, with the right extenion turned on
20:31:44 <dons> e.g. for bytestrings, http://haskell.org/ghc/docs/latest/html/libraries/regex-posix/Text-Regex-Posix-ByteString.html
20:31:47 <lambdabot> http://tinyurl.com/y2msu5
20:31:49 <nornagon> augustss: and which extension would that be? :)
20:31:53 <dons> (which is what I'm now using in lambdabot forregexes)
20:31:59 <nornagon> (And is that the right syntax?)
20:32:12 <dons> ?docs Text.Regex.Posix.ByteString
20:32:13 <lambdabot> Text.Regex.Posix.ByteString not available
20:32:18 <augustss> nornagon: with ghc it's -fglasgow-exts
20:32:19 <dons> have to update lambdabot's cache
20:32:27 <nornagon> augustss: *nod*
20:32:33 <bos_> dons: do i need to snarf the darcs repo for that, then?
20:32:46 <augustss> nornagon: and I find the GADT syntax the easiest to use for this
20:32:58 <dons> bos_: nope, should be installed with your GHC 6.6
20:33:02 <bos_> dons: never mind, found it.
20:33:12 <nornagon> augustss: what's it look like?
20:33:12 <bos_> i hate asking questions that i can answer myself with grep.
20:33:12 <dons> (if you're using ghc 6.4.x, you get Text.Regex (the regex-compat package only)
20:33:18 <augustss> data Foo where { Int :: (Num a) => a -> Foo; ... }
20:33:29 <bos_> so these are posix regexps, and not perl-compatible ones, i take it.
20:33:52 <nornagon> augustss: Is that a glasgow extension thingy?
20:34:06 <dons> bos_: there's also perl ones, in regex-pcre
20:34:11 <dons> but its a 3rd party package
20:34:16 <bos_> i see.
20:34:16 <dons> ?where regex-pcre
20:34:17 <lambdabot> http://darcs.haskell.org/packages/regex-pcre/
20:34:29 <bos_> and these all go back and forth to the system libraries via c-arrays?
20:34:30 <nornagon> ah, hm. No Show instance for Fractional, obviously. :/
20:34:31 <dons> also a binding to the tcl regex libs, iirc
20:34:47 <dons> bos_: some of them do (there's a pure haskell one in there as well)
20:34:52 <dons> Text.Regex.Lazy is pure haskell, iirc
20:35:16 <augustss> nornagon: you can also use regular syntax: data Foo = forall a . Num a => Int a
20:35:19 <dons> the bytestring posix one is pretty good, since bytestrings can be passed to C without copying
20:35:31 <dons> bos_: but the pcre lib would be even more efficient, if you're using lots of regexes
20:35:35 <dons> on large data
20:35:40 <bos_> seems that the pcre one can use ByteStrings, tool
20:35:48 <newsham> ?paste
20:35:48 <lambdabot> http://paste.lisp.org/new/haskell
20:35:49 <bos_> augh, "too", not "tool".
20:35:55 <dons> ?where+ regex-tre http://darcs.haskell.org/packages/regex-tre/
20:35:56 <lambdabot> Done.
20:36:07 <dons> ?where+ regex-parsec http://darcs.haskell.org/packages/regex-parsec/
20:36:07 <lambdabot> Done.
20:36:09 <dons> ^^ pure haskell
20:36:24 <dons> ?where+ regex-dfa http://darcs.haskell.org/packages/regex-dfa/
20:36:24 <lambdabot> Done.
20:36:25 <dons> also pure haskell
20:36:27 <bos_> hmm. is six answers better than one? :-)
20:36:31 <dons> :)
20:36:36 <dons> we have the libraries!
20:38:02 <bos_> whoa. i'm reading the Data.ByteString docs, and I see "Original GHC implementation by Bryan O'Sullivan." what?
20:38:23 <bos_> i have no recollection of writing that.
20:38:38 <dons> of PackedString
20:38:44 <dons> in 1996 or so? or earlier?
20:38:48 <bos_> i guess.
20:38:54 <bos_> i just thought i'd, you know, remember.
20:39:00 <dons> ByteString took some of the api and ideas from PackedString :)
20:39:01 <dons> thanks!
20:39:10 <bos_> well, hooray for me!
20:39:16 <dons> ?source Data.PackedString
20:39:17 <lambdabot> http://darcs.haskell.org/packages/base/Data/PackedString.hs
20:41:46 <Korollary> how is the new regex performance?
20:42:31 <dons> the TRE one is very very good, iirc
20:42:44 <bos_> hmm, i sense will partain's hand in this, too.
20:42:45 <dons> you get fastest-on-the-shootout perf, I think (using non-copying bytestrings)
20:43:10 <glguy> Has the shootout been updated for GHC 6.6?
20:43:26 <dons> the amd box has ghc 66 (debian)
20:43:29 <dons> but it lags behind
20:43:35 <dons> we've submitted some 6.6 entries for the gentoo box
20:43:39 <dons> but it doesn't have ghc 6.6 yet
20:44:27 <lisppaste2> adam pasted "scheme_parser" at http://paste.lisp.org/display/33871
20:44:35 <sorear> these people who compare generational GC to malloc/free sicken me
20:44:39 <bos_> the package names aren't very descriptive. is TRE the Tcl library?
20:44:54 <sorear> comparing malloc/free to mark/sweep is fine
20:45:13 <sorear> comparing generational manual to generational gc is fine
20:45:55 <dons> bos_: yeah
20:46:05 <dons> you'll need tre.h installed, irc
20:46:31 <bos_> i see. it's written by the same guy who wrote Text.Regex.Lazy. guess he was having an otherwise slow spring.
20:46:52 <SamB_XP> sorear: what is wrong with comparing them?
20:47:13 <SamB_XP> doesn't generational make better use of RAM, usually?
20:47:20 <sorear> you should only vary one variable what comparing things
20:47:29 <dons> yeah, the author is TuringTest here
20:47:34 <dons> ?seen TuringTest
20:47:35 <lambdabot> I haven't seen TuringTest.
20:47:37 <dons> gues he's been usy
20:47:46 <sorear> dons: I have State/lambda but not Plugin/Lambda.hs
20:47:48 <glguy> hmm.. that scheme parser makes a distinction between a list and a dotted-list
20:47:57 <sorear> (you might want to delete the former)
20:48:02 <dons> sorear: ah ok. yep
20:48:13 <sorear> prelude.lam, too
20:50:26 <sorear> besides clearing out the autojoin and changing the nick, do I need to do anything else before activating --online?
20:50:26 <dons> done.
20:50:42 <dons> the State/passwd file?
20:51:50 <sorear> online test of first patchbundle of take 2 has begun...
20:51:54 <lisppaste2> newsham annotated #33871 with "changed spacing" at http://paste.lisp.org/display/33871#1
20:52:06 <sorear> oh ... exception: end of file.
20:52:31 <dons> did you change the nick?
20:52:36 <dons> in config.hs?
20:52:45 <dons> hmm, and any proxy?
20:53:35 <sorear> no proxy, changed nick
20:53:52 <sorear> oh, wait, didn't rebuild after changing nick
20:55:05 <sorear> Wow.  I changed the nick, thus invalidating Config, IRC, Lambdabot, all the plugins, gotta love cross module optimisation :)
20:55:14 <dons> heh
20:55:23 <dons> we could stick Config.hs in a State/config file...
20:55:26 <dons> and load it on start up
20:55:29 <dons> not a bad idea realy.
20:55:30 <bos_> dons: do people mostly use the lazy bytestrings?
20:55:40 <sorear> no
20:55:44 <dons> bos_: I think they're preferred, since they have better complexity
20:55:57 <dons> some use cases need strict byte arrays though
20:56:07 <bos_> sure.
20:56:19 <sorear> lambdabot uses only strict bytestrings (for nicknames, etc)
20:59:01 <sorear> that's odd... it's responding in actions but not words. (got no response from @help)
21:01:09 <bos_> dons: the bytestring paper is well written.
21:06:17 <dons> bos_ thanks :) historical note: we wrote much of it in #haskell-overflow :)
21:06:32 <dons> open source research papers!
21:06:39 <bos_> heh heh.
21:06:59 <bos_> is #haskell-overflow where people go when they need to actually do stuff? :)
21:07:31 <dons> yeah, long(technical) conversatoins. been a bit quiet of late though
21:07:39 <dons> too much xmas merry making, I guess
21:07:48 <Cale> Hmm... that immediate mode graphical user interfaces talk is actually pretty interesting. He's noticed that a much less abstract way of handling the construction and display of UI widgets can actually manage to have a more declarative feel.
21:08:38 <bos_> this is the phooey stuff?
21:08:46 <Cale> http://www.mollyrocket.com/video/imgui.avi
21:08:59 <Cale> It was posted on programming reddit
21:09:55 <Cale> Some of the downsides of his approach might be handled by usage of a combinator library, but perhaps that's just reiinventing the Hughes Arrow.
21:10:07 <Cale> -i
21:15:41 <bos_> dons: ghc didn't have programmer-specified rewrite rules back in the day. what a nice feature to have!
21:18:34 <dons> hehe
21:18:45 <dons> yeah, its fun for library authors
21:26:18 <bos_> i gather from some of the conversation that passed earlier that someone has benchmarked the thicket of regexp libraries.
21:26:28 <bos_> but i don't see any references to same in google.
21:27:02 <bos_> oh, now i see them.
21:31:19 <psykotic> cale: there are issues with casey's imgui stuff though.
21:31:28 <bos_> hmm, regex-pcre wants fps >= 0.7
21:32:17 <bos_> is 0.7 present in ghc 6.6? i don't see an entry in the output of ghc-pkg -l
21:33:12 <psykotic> cale: i think a lot of people use his approach when dealing with UIs that very directly visualize and manipulate data models. but something simple like a listview with sorting on columns is suddenly very very annoying to do with that approach.
21:33:50 <psykotic> when you have an intermediate representation of the rows of the listview it's easy to do something like sorting, but when you have everything munged together in one pass it's not really feasible.
21:34:55 <Cale> Well, it ends up being the application's problem
21:35:17 <psykotic> yes
21:35:24 <allbery_b> bos_: it's in ghc6.6, as part of base
21:36:06 <bos_> allbery_b: thanks.
21:36:17 <bos_> i need to beat regex-pcre over the head, then.
21:36:27 <psykotic> in any case it's pretty easy to combine rm and im guis seamlessly. for instance, you can have child windows/elements of a rmgui that just forward everything to an imgui
21:36:52 <allbery_b> edit the .cabal file, replace fps >= 0.7 with base >= 2.0
21:37:07 <bos_> yep.
21:37:26 <dons> allbery_b: yep
21:37:35 <bos_> allbery_b: thanks!
21:38:40 <bos_> in all my feverish tutorial and blog reading, i haven't seen much of anything about the pragmatics of getting and installing packages, or using neato whizzy stuff like Data.ByteString. i sense fertile soil.
21:40:15 <allbery_b> yay, got ghc build fixed (I think)
21:40:44 <allbery_b> yep, chewing on stage2 now
21:47:35 <dons> http://programming.reddit.com/info/wozq/details
21:47:36 <lambdabot> Title: Brief introduction to the Haskell foreign function interface (reddit.com)
21:48:40 <dons> mm :)
21:48:41 <dons> lambdabot> help src
21:48:41 <dons> src <id>. Display the implementation of a standard function
21:48:41 <dons> lambdabot> src ap
21:48:41 <dons> ap = liftM2 id
21:48:49 <dons> easy pesay
21:49:00 <bos_> are there any tours of the standard libraries? that would be an interesting thing to have. "here's this Data.ByteString thing you may not know about, and here's why you should care about it"
21:49:23 <dons> there's Zvon's guide to the (old) h98 libraries
21:49:26 <dons> but nothing for the new stuff yet
21:50:05 <bos_> right.
21:50:24 <bos_> but that's more like haddocky stuff, is it not?
21:50:41 <dons> yeah
21:51:04 <bos_> i was thinking more like a colloquial tour for people who didn't (a) write the library or (b) hasn't camped on haskell-cafe since forever :-)
21:51:41 --- mode: ChanServ set +b topaz*!*@*
21:51:51 <robreim> Yay for HWN!
21:52:05 <bos_> yes, yay for hwn!
21:52:21 <jcreigh> @src map
21:52:21 <lambdabot> Maybe you meant: arr ghc url
21:52:34 <jcreigh> ah, not live yet?
21:52:37 <glguy> ?fptools Prelude.map
21:52:38 <lambdabot> Prelude.map not available
21:52:40 <glguy> ?fptools Prelude
21:52:41 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
21:52:43 <dons> not lieve yet
21:53:06 <glguy> ah
21:53:11 <glguy> new extension on its way?
21:53:14 <dons> yeah
21:53:24 <robreim> with all this dedication to the haskell community I'm amazed you have time to write software like bytestring and lambdabot and still get work done, dons. Just how much sleep DO you get each night? :P
21:53:25 <dons> just populating its data base now
21:54:02 <dons> robreim: 7.5 hours or so :P
21:54:30 <Korollary> dons is actually not a single person. It's like Nicolas Bourbaki.
21:54:30 <robreim> I see. So you just move so quickly that time slows down via relativity, eh?
21:55:21 <bd_> robreim: dons' brain supports lightweight threading, clearly
21:55:32 <robreim> heh
21:55:37 <dons> I live in the future, that helps ;)
21:55:39 <dons> ?time dons
21:55:40 <glguy> let cStyleFor init pred next f = init >> cStyleWhile pred (f >> next) where cStyleWhile pred f = let aux = pred >>= flip when (f >> aux) in aux
21:55:42 <lambdabot> Local time for dons is Tue Jan  2 16:48:27 2007
21:55:53 <dons> so I always have an extra 12 hours on most of you guys ;)
21:55:57 <mauke> wow
21:56:17 <glguy> dons: could you tell me tomorrows winning lottery numbers??
21:56:21 <mauke> how's life in the future? any flying cars?
21:56:43 <robreim> actually, doesn't that mean that you've lost 12 hours? Since those in the US would still have 12 extra hours to get whatever work they need to do before they reach your time?
21:57:00 <olliej> dons: you have a lot more than 12 hours
22:21:44 <shapr> Is there a debian package for gtk2hs?
22:23:17 <shapr> What's the recommend approach for installing gtk2hs these days?
22:23:50 <dons> follow the README/cabal? but I suspect there's a deb
22:25:06 <reppie> http://people.freebsd.org/~ssouhlal/stuff/1149008426366.jpg
22:25:08 <reppie> err
22:25:11 <reppie> wrong window
22:25:13 <reppie> pls ignore
22:25:18 <shapr> dons: yay! http://carwash.cs.nott.ac.uk:992/~lyh/debian/
22:25:20 <lambdabot> Title: Debian Repository &ndash; Liyang on the IntarWeb
22:25:35 <shapr> It's amazing how many times I should just read the instructions...
22:25:42 <mauke> ah, 4chan
22:25:45 <shapr> (and yet, fail to do so)
22:26:29 <glguy> reppie: what channel did you mean to send a picture of an asian woman in a bikini urinating on the street while hundreds look on and take pictures?
22:26:55 <reppie> heh
22:26:56 * shapr didn't want to know that
22:27:52 <shapr> liyang: Are the gtk2hs debs for ghc6.6?
22:30:01 <shapr> I think I need to build from source.
22:31:22 <robreim> shapr: there's a pre-release of gtk2hs next version which should work on 6.6 at http://haskell.org/gtk2hs/gtk2hs-0.9.10.3.tar.gz . It's in its testing phase so I guess let dcoutts know if you have any problems.
22:31:32 <shapr> ah, thanks.
22:33:40 <shapr> dons: Hey, did you see the "limits of implicit parallelism" paper?
22:43:21 <mauke> hs-plugins doesn't want to build :(
22:43:29 <mauke> AltData/Typeable.hs:450:0: parse error (possibly incorrect indentation)
22:44:44 <allbery_b> no ghc6.6 support
22:45:21 <glguy> what is it that 6.6 doesn't support?
22:45:48 <mauke> allbery_b: ah, thanks
22:47:15 <mauke> now it fails with  Rebuilding dependencies ... Could not find module `Language.Haskell.Hsx': use -v to see a list of the files searched for (imported from System/Plugins/Parser.hs)
22:47:20 <mauke> rm: cannot remove `depend': No such file or directory
22:47:20 <mauke> make[2]: *** No rule to make target `depend', needed by `libHSplugins.a'.  Stop.
22:47:42 <robreim> 6.6 just has a different .hi format which hs-plugins can't yet understand (or so is my understanding)
22:49:54 <allbery_b> two issues:  the .hi fil format changed, and Typeable.h is missing some definitions used by hs-plugins (hence the parse error in Typeable.hs; it's an unexpanded cpp macro)
22:50:24 <mauke> btw, that was 0.9.10
22:50:34 <mauke> the darcs version seems to build
22:50:46 <allbery_b> people who work around the cpp issue (by using the Typeable.h from ghc6.4) get smething which builds but then fails at runtime with invalid array indices in th .hi parser
22:52:36 <allbery_b> Hsx is the haskell-src-exts package, fwiw
22:55:44 <mauke> $ ./a.out
22:55:44 <mauke> 7
22:55:49 <mauke> w00t!
22:56:26 <dons> allbery_b: yes. since the .hi file parser needs tweaking
22:56:33 <dons> ah /me reads up
23:05:44 <robreim> is the literate preprocessor that comes with ghc a separately executable program?
23:07:00 <dons> yeah, unlit, iirc
23:07:40 <robreim> great, thanks
23:07:44 <dons> ?bot
23:08:12 <lambdabot> :)
23:08:31 <dons> ?help src
23:08:31 <lambdabot> src <id>. Display the implementation of a standard function
23:08:33 <dons> ?src foldr
23:08:33 <lambdabot> foldr k z xs = go xs
23:08:34 <lambdabot>     where go []     = z
23:08:34 <lambdabot>           go (y:ys) = y `k` go ys
23:08:36 <dons> :)
23:08:47 <dons> ?src finally
23:08:47 <lambdabot> Source for this function is not available.
23:08:51 <dons> ?src finally_
23:08:51 <lambdabot> Source for this function is not available.
23:08:58 <bd_> ?src unsafePerformIO
23:08:58 <lambdabot> Source for this function is not available.
23:09:00 <bd_> tsk
23:09:14 <dons> ?src try
23:09:15 <lambdabot> try a = catch (a >>= \ v -> return (Right v)) (\e -> return (Left e))
23:09:28 <dons> yeah, there's a few missing, but the h98 stuff is there (mostly)
23:09:33 <dons> I'll just add more as I go
23:10:23 <dons> ?src Bool
23:10:23 <lambdabot> data Bool = False | True
23:10:26 <mq_mattr> dons: you have inspired a t-shirt
23:10:31 <dons> apparently!
23:10:34 <dons> yay for blogs :)
23:10:49 <mq_mattr> it is a fine thing - but I am not sure about the shirt itself
23:10:49 <dons> ?src (!!)
23:10:50 <lambdabot> xs     !! n | n < 0 = undefined
23:10:50 <lambdabot> []     !! _         = undefined
23:10:50 <lambdabot> (x:_)  !! 0         = x
23:10:50 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:10:53 <bd_> what t-shirt is this?
23:10:58 <dons> i'd prefer something on black
23:11:02 <mq_mattr> http://www.cafepress.com/l_revolution
23:11:37 <mq_mattr> I think nerd-shirst need to be understated
23:11:52 <mq_mattr>  no need to declare your pov that loudly
23:12:00 <mq_mattr> although, I guess this is a revolution
23:12:01 <dons> yeah, I'd go for back with a little lambda + "Join the revolution" or something
23:12:41 <dons> "When the revolution comes, side effects will be first against the wall"
23:13:46 <hyrax42> what we talking about
23:13:54 <hyrax42> does lb have a recap function?
23:13:58 <hyrax42> ?recap
23:13:59 <lambdabot> dummy module failed: IRCRaised Prelude.read: no parse
23:14:14 <bd_> ?where logs
23:14:14 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
23:14:22 <hyrax42> now that's an unfriendly error message
23:14:30 <bd_> ?help recap
23:14:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
23:14:39 <nmessenger> ?list dummy
23:14:39 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools
23:14:46 <shapr> someone called?
23:14:52 <shapr> whoops, false alarm.
23:14:58 <bd_> hyrax42: http://ircbrowse.com/channel/haskell/20070102 scroll to bottom :)
23:15:00 <lambdabot> Title: Meme haskell IRC Log 2007/01/02
23:15:13 <shapr> oooh, source code database!
23:15:28 <nmessenger> shapr: does your computer make loud noises or something when someone get-shapr's?
23:15:33 <dons> ?src id
23:15:33 <lambdabot> id x = x
23:15:46 <dons> brought to you by the power of bytestrings :)
23:15:48 <shapr> Nah, it just woofs quietly.
23:16:01 <mauke> ?. djinn type id
23:16:03 <lambdabot> f a = a
23:16:26 <dons> ?. src id
23:16:27 <lambdabot> Source for this function is not available.
23:16:32 <dons> ?. pl src id
23:16:33 <lambdabot> id = id
23:16:35 <dons> :)
23:16:42 <hyrax42> ?src head
23:16:42 <lambdabot> head (x:_) = x
23:16:43 <lambdabot> head []    = undefined
23:16:51 <bd_> ?id
23:17:07 <bd_> ?id test
23:17:08 <lambdabot> test
23:17:09 <bd_> ic
23:17:38 <bd_> ?id ACTION tests
23:17:39 * lambdabot tests
23:18:40 <dons> hmm
23:19:04 <mq_mattr> peeps: I am having a little trouble with the edison docs
23:19:12 <mq_mattr> anyone use edison much?
23:19:44 <mauke> ?id VERSION
23:19:55 <mauke> haha, oh wow
23:21:04 <dons> i have to fix that now :/
23:21:21 <mauke> wait, why am I getting VERSION replies?
23:22:09 <psykotic> lamdabotnet
23:22:14 <mauke> all from dircproxy, ircII or bitchx. oh, and riece/emacs
23:22:17 <psykotic> lambda, even
23:23:47 <dons> ?bot
23:24:14 <lambdabot> :)
23:24:16 <dons> bd_, can you try again?
23:24:31 <mq_mattr> ?bot
23:24:32 <lambdabot> :)
23:24:32 <bd_> sure, one sec
23:24:45 <bd_> ?id ACTION tests
23:24:45 <lambdabot>  ACTION tests
23:24:49 <bd_> oO
23:24:51 <bd_> leading space?
23:25:10 <bd_> I don't know if all clients will be fully robust against that...
23:25:36 <mauke> ?id â½
23:25:37 <lambdabot>  â½
23:25:49 <dons> yeah, you can still type in crazy stuff
23:25:55 <dons> but everyone wil get annoyed at you :)
23:26:54 <dons> lambdabot's in a happy place these days
23:27:06 <dons> the code is nice (fairly much), its solid and does some cool things.
23:27:07 <dons> yay!
23:27:27 <dons> its actually a pleasure to hack on
23:28:04 <mauke> someone should fix mbot too :-)
23:28:20 <dons> the patches are in the repo
23:28:48 <Cale> mauke: hm?
23:29:05 <mauke> the ?id CTCP trick
23:29:16 <Cale> what's that?
23:29:19 <dons> Cale: missing leading space on @id
23:29:28 <Cale> oh
23:29:34 <dons> Cale: also, that long standing space leak has been fixed (I think)
23:29:38 <Cale> cool
23:29:46 <Cale> I'll have to update my copy
23:30:00 <dons> also, @quote uses regexes now (still needs a little polish), and we have @src
23:30:05 <dons> @src const
23:30:06 <lambdabot> const x _ = x
23:30:12 <dons> ?quote Oleg
23:30:12 <lambdabot> Oleg says: The implementation of RSA on type level is left for future work
23:30:17 <Cale> @src foldr
23:30:18 <lambdabot> foldr k z xs = go xs
23:30:18 <lambdabot>     where go []     = z
23:30:18 <lambdabot>           go (y:ys) = y `k` go ys
23:30:24 <mauke> @quote a+
23:30:25 <lambdabot> ghc says: No explicit method nor default method
23:30:38 <Cale> that's an interesting implementation
23:30:59 <mauke> @quote **
23:30:59 <lambdabot> quote module failed: IRCRaised Text.Regex.Posix.regcomp: error in pattern
23:40:59 <dons> ?let test = 79
23:41:00 <lambdabot> Defined.
23:41:09 <dons> > map (*test) [1..10]
23:41:10 <lambdabot>  [79,158,237,316,395,474,553,632,711,790]
23:41:24 <dons> no need for L.* names on ?let defined values now
23:42:06 <mauke> ?let a + b = a - b
23:42:07 <lambdabot> Defined.
23:42:11 <mauke> > 2 + 2
23:42:11 <lambdabot> Terminated
23:42:52 <dons> ?undefine
23:42:53 <lambdabot> Undefined.
23:42:54 <dons> > 2+2
23:42:56 <lambdabot>  4
23:43:08 <mauke> why did that loop?
23:43:11 <dons> ?let plus a b = a + b
23:43:12 <lambdabot> Defined.
23:43:26 <dons> don't know what happened there :)
23:43:29 <dons> > plus 1 2
23:43:30 <lambdabot>  3
23:43:37 <dons> ?undefine
23:43:38 <lambdabot> Undefined.
23:43:50 <dons> ?let map = const reverse
23:43:50 <lambdabot> Defined.
23:43:59 <dons> > map toUpper "haskell"
23:44:00 <lambdabot> Terminated
23:44:00 <shankys_> Is anyone here familiar with the GHC API? I'm trying to do the equivalent of a ":set -i/path/to/proj" using the GHC API, but am having real trouble getting it working. I've been looking through the GHC source code, and I think what I want is to set something like importPaths in data DynFlags, but it really isn't documented well. Does someone know how I could do this or what option I need to set?
23:44:10 <dons> ah, so its mapping a compilation error (due to shadowing) to Terminated
23:44:13 <dons> ?undefine
23:44:13 <shankys_> ?paste
23:44:14 <lambdabot> Undefined.
23:44:14 <lambdabot> http://paste.lisp.org/new/haskell
23:44:31 <lisppaste2> shankys pasted "GHC API Problems" at http://paste.lisp.org/display/33885
23:44:59 <shankys_> There's some code I'm using that works, but I'm not sure how to extend it further to do what I need to do
23:51:28 <Cale> > 4 + 5
23:51:30 <lambdabot>  9
23:56:57 <robreim> Heh, without context seeing Cale putting 4 + 5 into lambdabot and knowing he's a mathmatician seems really amusing
23:57:37 <Cale> That's stretching the limits of my ability to calculate right there :)
