00:00:06 <Cale> ohmega: buggy, or just limited?
00:02:51 <ohmega> Ï† âˆ· forall a . a â†’ a
00:02:51 <ohmega> Ï† x = x
00:02:57 <ohmega> that does not typecheck here
00:03:11 <ohmega> put this on the line above though:
00:03:15 <ohmega> data X = X
00:03:26 <ohmega> then it works
00:03:38 <ohmega> strangeness :)
00:04:23 <ohmega> or replace Ï† with f and it will also work
00:05:11 <ohmega> also ghci will not parse Ï† correctly when i try to call it in ghci
00:05:29 <vegaiW> what character should that be? I'm seeing nothing
00:05:54 <ohmega> phi
00:06:02 <vegaiW> ah
00:07:04 <Cale> okay, sounds buggy :)
00:32:35 <pzpz> is there a method for doing m a -> a other than <- ?
00:33:16 <ohmega> you mean with >>= ?
00:33:21 <ibid> pzpz: not for general m
00:33:30 <ibid> pzpz: for particular m's there may be
00:33:42 <vegaiW> @type (>>=)
00:33:43 <mbot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
00:33:54 <ibid> <- is just syntactic suhar for >>=
00:34:49 <ohmega> f >>= (\x -> g x) is do { x <- f; g x }
00:34:51 <pzpz> well, i knwo that
00:34:58 <pzpz> i'm trying to do something like,
00:35:27 <pzpz> for example: ((+1) . (>>=)) (return 5)
00:36:53 <pzpz> i right now have no problem working monadically, or raising something to a monad
00:37:56 <pzpz> yet i'm lost on how to write a function that evaluates something monadically thats type isn't monadic
00:40:20 <pzpz> ie, getforme :: String
00:40:45 <pzpz> getforme = do { x <- getLine } ,..
00:40:45 <vegaiW> hmm... what are you trying to accomplish?
00:41:20 <pzpz> I could easily work monadically and perform: return x , yet if i wanted the type of getforme to be [String], i'm stuck
00:41:37 <vegaiW> couldn't it be IO [String]?
00:41:49 <pzpz> That's what I can do! :)
00:42:10 <vegaiW> ah, but the IO monad is supposed to prohibit from doing that
00:42:13 <pzpz> how do I mix monadic IO and non monadic IO to make that function String
00:42:58 <vegaiW> what is non-monadic IO?
00:43:17 <pzpz> me being stupid :(
00:43:32 <pzpz> i mean a function with a type that is not monadic
00:43:42 <pzpz> like, f :: Int -> (Int,Int)
00:43:53 <vegaiW> pure function
00:44:01 <pzpz> that's what you would call pure?
00:44:40 <vegaiW> well, I suppose the IO functions are pure too, they just don't look like that when the runtime does its thing with them
00:45:22 <pzpz> i still have no idea how to do something like my previous example though :)
00:45:27 <ohmega> pzpz: you probably want a function that runs the monad
00:45:44 <pzpz> ((+1) . (>>=)) (return 5)
00:46:36 <pzpz> ohmega: not really following you by "runs". something to wrap the evaluation of <- / >>= ?
00:48:54 <ohmega> you can do this with the IO monad (unless you use unsafe functions), but in general you want to have a run function for the monad. it will give some input state to the monad and return some output state and/or a return value. have a look at evalState for example
00:49:03 <ohmega> *you can't
00:50:30 <pzpz> ohmega: :(, thanks
00:52:15 <vegaiW> that's the point of the IO monad. It's not to make your life harder, but to ensure that IO things happen in a good order
00:52:21 <ohmega> pzpz: so when you write programs you start execution in the IO monad, where things are done imperatively (the outside world is imperative), and then you call pure functions from the imperative wold in IO
00:52:30 <vegaiW> if you could have a getforme::String, that couldn't be unsured
00:52:35 <vegaiW> *ensured
00:57:25 <ibid> pzpz: like they said.  the point of the IO monad is to force you to specify the order of IO actions. this is only possible if it is not possible to escape the IO monad
00:57:48 <pzpz> gotcha gotcha
00:58:40 <ibid> pzpz: of course, there *is* a way to escape from it, but you *will* shoot yourself in the foot with it, given the kind of questions you've been asking now :) (so i'm not going to tell you what it is)
00:59:12 <ibid> pzpz: even experts get it wrong often
00:59:40 <ohmega> it's good for debugging though
00:59:50 <ibid> for that, you can use trace :)
01:00:02 <ibid> which is sort of semi-safe :)
01:00:18 <pzpz> i'll remember your advice when i figure it out in the future then :)
01:00:27 <dcoutts> sjanssen, good work on the serialisation lib btw, today we'll do quickcheck tests for each instance to check that they round-trip correctly.
01:00:45 <pzpz> what
01:00:56 <pzpz> bah... what's the eta on haskell' ?
01:01:26 <ibid> pzpz: in 2006, i've heard said. of course, i last heard that a year ago :)
01:01:49 <pzpz> :(
01:02:08 <ibid> pzpz: relax. haskell98 was released in 1999 :)
01:02:13 <pzpz> how formalized is it?
01:02:20 <ibid> not more than h98
01:02:38 <Masklinn> good morning #haskell
01:02:46 <ibid> there is a (partial?) formal semantics for an ancient version of haskell
01:02:53 <ibid> but it's lunchtime, bbl :)
01:03:09 <Masklinn> nah it's 10AM where I am :p
01:03:20 <ibid> (11am)
01:03:40 <Masklinn> even 11am qualifies as morning anyway
01:03:45 <earthy> at least progress still seems to be made on haskell'
01:04:01 <Cale> pzpz: Does anything you're doing depend on Haskell' being released?
01:04:20 <ohmega> http://hackage.haskell.org/trac/haskell-prime/wiki/TimeLine
01:04:21 <mbot> Title: TimeLine - Haskell Prime - Trac
01:04:24 <Cale> pzpz: It's mostly intended to standardise what's already in GHC
01:04:40 <Cale> (and not even all of that)
01:11:23 <pzpz> Yah, i'm looking at it now
01:11:43 <pzpz> your'e right :)
01:12:48 <dcoutts> pzpz, ETA September
01:13:29 <mbishop> allbery_b: got that wireless card yet?
01:14:31 <earthy> dcoutts: I note you skillfully omit the year in that ETA. :)
01:17:25 * mbishop goes to sleep
01:20:21 <dcoutts> earthy, heh
01:25:24 <Andris> hmm, I just had a suspicion that Bool -> Bool is not isomorphic to Bool -> () -> Bool
01:25:53 <Andris> or even simpler, () is not isomorphic to () -> ()
01:26:11 <Andris> is currying flawed in presence of bottoms?
01:30:12 <Andris> well, the currying as such identifies (Bool, ()) -> Bool with Bool -> () -> Bool, so probably currying has no flaw
01:30:46 <Andris> it's just unintuitive that ((), ()) is not isomorphic to ()
01:34:19 <Andris> in other words, products do not form a monodi with empty product as a unit. where did I err?
01:35:24 <Cale> right
01:35:51 <Cale> The type ((), ()) has 4 values.
01:36:12 <Andris> ah, so I am not crazy
01:36:24 <Cale> The real unit with respect to product is the void type, which has only bottom as a value.
01:36:47 <Andris> is this somehow related to cartesian closed categories?
01:37:27 <boulez> is the type (->) left- or right-associative?
01:38:01 <Cale> right associative
01:38:20 <boulez> then is 'currying as such identifies (Bool, ()) -> Bool with Bool -> () -> Bool' correct?
01:39:18 <Cale> Well, yes.
01:39:26 <Cale> @type curry
01:39:27 <mbot> forall c b a. ((a, b) -> c) -> a -> b -> c
01:39:57 <boulez> OK, (A x B) -> C isomorphic to A -> (B -> C)
01:40:15 <boulez> duh
01:41:20 <Andris> ah, but cannot we save the isomorphism of ((), ()) and () by using strictness annotations?
01:41:50 <Cale> yeah
01:41:56 <Cale> You can define strict pairs
01:41:58 <dblhelix> Andris: yes by using smash products instead of the ordinary Haskell tuples which are lifted...
01:42:05 <Andris> ouch
01:42:19 <Andris> dblhelix: any reference?
01:42:19 <dblhelix> data Smash a b = Pair !a !b
01:42:23 <Andris> oh
01:42:24 <Andris> ok
01:43:35 <Andris> until now I had an impression that strictness annotations are mostly for optimization
01:44:10 <dblhelix> Andris: I guess they are
01:44:52 <Andris> but if I understood this correctly, Smash () () is isomorphic to ()
01:45:01 <Andris> while ((), ()) is not
01:45:07 <dblhelix> Andris: yes
01:45:12 <Andris> so it's a semantical difference
01:45:13 <Cale> How is that a smash product?
01:45:24 <Andris> I don't know :)
01:45:43 <Cale> oh
01:46:01 <Cale> er, yeah, it is.
01:46:41 <Cale> We're identifying (x,_|_) and (_|_,y) for all x and y.
01:48:14 <Cale> (in particular, with bottom)
01:48:51 <Andris> so I will need to be careful with curry
01:49:25 <earthy> yes, you need to be aware of the peppers that may be contained in it. :P
01:50:06 <ClaudiusMaximus> @type peppers
01:50:08 <mbot> Not in scope: `peppers'
01:50:12 <Cale> Andris: Slightly so.
01:50:13 <Andris> I wonder if there is a curcuma version of it :)
01:50:30 <Andris> Cale: yes, it rarely makes difference
01:51:51 <Cale> We usually just work with the curried version of everything.
01:52:42 <Cale> I wouldn't even think of f :: (a,b) -> c as being a function of two parameters. It's just a function of one parameter that happens to be a pair.
02:03:20 <dcoutts__> argh, xchat-gnome only lets one join listed channels, unlike say #haskell.hac07
02:04:41 <dcoutts__> however, it does let one join channels that get mentioned in a channel, like above :-)
02:05:41 <dcoutts__> so the workaround is to publicly complain
02:24:09 <Cale> dcoutts: huh?
02:24:22 <Cale> dcoutts: /join #haskell.hac07
02:44:53 <dons> moin!
02:44:59 * dons waves from the hackathon!
02:45:17 <Syzygy-> Hey hackathon!
02:45:19 <Syzygy-> *waves*
02:47:49 <dons> ?bot are you there
02:47:49 <lambdabot> :)
02:47:49 <mbot> :)
02:47:56 <dons> mbot: @part #haskell
02:53:01 <Masklinn> By the way dons, is there any kind of "live report" from the hackathon, or will there be a big report after that?
02:53:48 <bakert> hello folks.  today i'm doing something quite boring but i'm trying to find a nice functional way of doing it.
02:53:51 <bakert> form field validation.
02:54:21 <dons> Masklinn: I'll try and write something today :)
02:54:35 <Masklinn> dons > yay \o/
02:54:49 <bakert> i've got a bunch of strings.  some of which should be parseable to Double, others should be from a specific set of possible answers, etc.  and if it doesn't validate i'd like to be able to produce a useful set of error messages.  ideas?
02:55:00 <Masklinn> dons > has there been interesting stuff already?
02:55:11 <bakert> i'm not looking for the specific code, more a sensible approach to the problem.
02:55:23 <dons> yeah, we've got some serious hackage work happening, cabal improving, a new binary IO library almost done
02:55:28 <dons> lib crypto being split up
02:55:32 <dons> some work on the ghci debugger
02:55:35 <dons> heaps of stuff!
02:55:56 <dons> morning Masklinn
02:55:59 <bakert> in imperative land i would create an array, add an error message to the array for each failure, and if the array is empty at the end, valid, otherwise produce an error report from the array of error messages.
02:56:02 <dons> malcolmw: :)
02:56:06 <bakert> i suppose i could just do that?
02:56:32 <Masklinn> dons > what kind of work's being done on Cabal?
02:56:33 <dons> ?users
02:56:33 <lambdabot> Maximum users seen in #haskell: 315, currently: 284 (90.2%), active: 6 (2.1%)
02:56:34 <malcolmw> dons: how's hacking?
02:56:53 <dons> new high score! 315
02:56:56 <dons> malcolmw: great!
02:57:05 <dons> really happy with the new binary library
02:57:12 <dons> and hackage is getting some good attention
02:57:35 <Masklinn> bakert > no reason why you couldn't, or you zip each string with the validation operation, then map the execution of the validation on the string, and get a list of error messages out
02:58:01 <Salzh> #join linux
02:58:04 <malcolmw> new binary library?  Is that different from NewBinary? :-)
02:58:04 <bakert> zipping sounds nice.  i'll try that.
02:58:13 <bakert> thanks Masklinn
02:58:39 <bakert> i seem to be passing a lot of values around from my form (7, actually)
02:58:45 <bringert_> bakert: unfortunately I couldn't apply your patch, see e-mail
02:58:57 <dons> malcolmw: yeah
02:59:01 <dons> with a pure interface
02:59:06 <dons> much simpler
02:59:19 <Masklinn> dons > very nice to hear about hackage, mostly Cabal or mostly HackageDB and cabal-install?
02:59:24 <bakert> bringert_, oops.  i'll make you a proper one.
02:59:25 <dons> malcolmw: encode :: Binary a => a -> L.ByteString
02:59:25 <dons> decode :: Binary a => L.ByteString -> a
02:59:34 <malcolmw> dons: docs available?
02:59:35 <vegaiW> dons: dare I ask about hs-plugins?
02:59:38 <bringert_> bakert: can you make one with darcs?
02:59:40 <bringert_> muchs easier
02:59:49 <dons> ?where+ binary http://darcs.haskell.org/binary
02:59:49 <lambdabot> Done.
02:59:51 <bringert_> for me anyway :-)
02:59:55 <dons> malcolmw: ^^
03:00:01 <dons> its under very active dev today
03:00:06 <bakert> bringert_, will do.  as soon as i learn how!
03:00:12 <bringert> bakert: darcs record
03:00:18 <bringert> bakert: darcs send
03:00:24 <bringert> or darcs send -o file
03:00:36 <dons> malcolmw: the idea is to make this the new NewBinary :)
03:00:55 <dons> sjanssen: around?
03:01:14 <manveru> ?hoogle
03:01:15 <lambdabot> HOOGLE - Haskell API Search
03:01:15 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
03:01:15 <lambdabot>  
03:01:23 <malcolmw> The FlexibleInstances extension is mentioned - it is crucial?
03:02:21 <dons> I don't think so (?)
03:02:27 <dons> I'm going to get it running in hugs today , anyway
03:02:31 <dons> so we should be able to kill that off
03:02:45 <dons> have to ask kolmodin
03:03:01 <bakert> bringert, bringert_, that is coool.  is the target email the one on the web page or the one your replied from?  or doesn't it matter?
03:03:07 <malcolmw> I can't see any special overlapping instances or instances over type synonyms etc.
03:03:20 <bringert> bakert: either
03:03:26 <dons> malcolmw: yeah, might be legacy
03:03:56 <bakert> bringert, done.  that was fun.  what a good way to do it.
03:04:27 <dons> malcolmw: any comments on the concept? the api look ok?
03:04:40 <bringert> bakert: darcs send directly might not work if you don't have a local smtp server
03:04:41 <dons> (notice the pure interface :) no binary handle gunk
03:04:48 <malcolmw> dons: maybe the monad transformers require FlexibleInstances though
03:04:56 <bringert> bakert: what platform are you on?
03:05:37 <bakert> bringert, ubuntu linux.  seemed to work fine.  i'm fairly sure i am set up for commandline email.  maybe.
03:05:43 <malcolmw> dons: the interface looks nice and clean, yes.  Byte-oriented though, rather than bit-oriented like my original
03:05:52 <bringert> bakert: it tends to fail silently
03:06:16 <bringert> bakert: the e-mail goes to a local spool somewhere, but noone sends it from there unless you are running sendmail/postfix etc
03:06:36 <bringert> bakert: I haven't got anything yet
03:07:17 <bakert> bringert, what's the alternative?  send you a darcs diff?
03:07:36 <bringert> bakert: use darcs send -o file and send me the file
03:08:13 <bakert> bringert, ok.  thanks for hand holding!  sending it now ...
03:09:10 <tphyahoo> head ( let x = 1:x in x)
03:09:14 <tphyahoo> > head ( let x = 1:x in x)
03:09:16 <lambdabot>  1
03:10:04 <Masklinn> > take 20 (let x = 1:x in x)
03:10:06 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
03:10:34 <tphyahoo> > head 1:2
03:10:36 <lambdabot>   add an instance declaration for (Num [a])
03:10:49 <tphyahoo> I unerstand that failed because there was no nil at the end.
03:11:00 <tphyahoo> but how come the head (infinite list) succeeded?
03:11:03 <tphyahoo> there's no nil there either.
03:11:25 <ibid> no, the latter failed because there is no numeric literal to list conversion defined
03:11:25 <dons> you can take the head of an infinite list
03:11:25 <bakert> perhaps because it never finds that out???
03:11:40 <dons> @seen sorear
03:11:41 <lambdabot> I saw sorear leaving #haskell 4h 37m 40s ago, and .
03:11:45 <ibid> (that's what the Num [a] coment was about)
03:12:01 <Masklinn> @type (let x = 1:x in x)
03:12:02 <lambdabot> forall a. (Num a) => [a]
03:12:14 <Masklinn> this is why
03:12:28 <Masklinn> x is inferred as a list, the final nil is implied, more or less
03:12:37 <ibid> there is no final nil
03:12:41 <ibid> not even implied
03:12:44 <ibid> in the infinite list
03:12:55 <tphyahoo> danks masklinn and ibid :)
03:13:12 <ibid> there is nothing at the end of infinity :)
03:13:21 <tphyahoo> yes there is.
03:13:26 <tphyahoo> more infinity. :)
03:13:28 <Masklinn> lol
03:14:05 <tuukkah> ibid, did you see the question about gtk2hs nmu in debian?
03:14:14 <ibid> tuukkah: yes. no time.
03:14:41 <tuukkah> ok
03:14:44 <ClaudiusMaximus> dons: just checking, you got the @tell message about "-v" for 'make' options in hs-plugins-1.0rc0 ghc-6.4.2 causing MakeFailure the first time it is run on a given (previously uncompiled) source?
03:14:58 <Masklinn> ibid > I don't know, a list is still defined as a recusrive serie of conses that ends with a nil
03:15:08 <dons> ClaudiusMaximus: yesh -v will break things (I think)
03:15:10 <ibid> Masklinn: no, it's not
03:15:14 <dons> since we rely on their being no stderr output
03:15:36 <ClaudiusMaximus> dons: not possible to check return code and discard stderr?
03:15:38 <ibid> Masklinn: a list is either a recursive series of conses ended by a nil, or a corecursive series of conses
03:15:47 <bringert> bakert: pushed! thanks
03:16:08 <bakert> bringert, brillo!
03:16:09 <bringert> bakert: now it's got your e-mail and comments in the patch too
03:16:21 <bringert> which is better than the pure diff way
03:16:26 <bakert> ah yes.  very nice
03:16:28 <Masklinn> ibid > can't we consider that a corecursive serie of conses is a recursive serie of conses ended by a nil that's ever infinitely far from the current position?
03:16:32 <ClaudiusMaximus> dons: "-v" *does* break things - i've proved it in tests!
03:16:48 <Masklinn> I mean I know that there isn't any factual nil at the end since there is no end
03:16:53 <ibid> Masklinn: no. a recursive series is finite.
03:16:56 <dons> ClaudiusMaximus: yes, I agree :)
03:18:03 <Masklinn> ibid > i'll have to ask you what "corecursive" means then, since that seems to be the difference you make between finite and infinite list
03:18:08 <ibid> Masklinn: but yeah, if you are willing to bend the words enough to have "infinitely far" and "recursive" in the same sentence :)
03:18:27 <Masklinn> ibid > aren't words here for being bent?
03:18:49 <ibid> http://en.wikipedia.org/wiki/Corecursion
03:19:54 <Masklinn> ibid > mm ok. Strikes me as a made-up word specifically for that situation though
03:20:11 <bakert> Masklinn, that's what words areÂ¬!
03:20:35 <ibid> Masklinn: that article misses most of the context :)
03:20:37 <Masklinn> ibid > I mean you don't need corecursive functions to work on corecursive structures.
03:21:03 <Masklinn> ibid > I don't doubt it, but still you work on "corecursive" structures via the use of recursion
03:21:45 <Masklinn> (when you language is lazy of course)
03:23:21 <ibid> Masklinn: the problem here is that haskell makes no syntactic difference between recursion and corecursion
03:25:02 * Masklinn cries
03:25:06 <Masklinn> lambdabot is dead :/
03:25:27 <Jaak> uh... im getting "/tmp/ghc10854.hspp:21:1: lexical error" when trying to build lambdabot
03:25:30 <Pseudonym> @botsnack
03:25:32 <dons> no no
03:25:40 <dons> some big patches came in
03:25:46 <dons> ?bot
03:25:54 <vegaiW> the living dead
03:25:55 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
03:25:59 <Pseudonym> Do we have the hackathon to thank for these patches?
03:26:01 <lambdabot> :)
03:26:03 <ibid> Masklinn: basically, if you have no base case, it's not recursion
03:26:08 <dons> Pseudonym: nope, sorear
03:26:11 <dons> ?version
03:26:11 <lambdabot> lambdabot 4p453, GHC 6.5 (OpenBSD i386)
03:26:12 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:26:20 <dons> hopefully solves the deadlock issue we had in the last couple of days
03:26:21 <Pseudonym> sorear++
03:26:31 <dons> ?users
03:26:32 <lambdabot> Maximum users seen in #haskell: 315, currently: 283 (89.8%), active: 4 (1.4%)
03:26:38 <Jaak> > fix ('Î»':)
03:26:39 <lambdabot>  Improperly terminated character constant
03:26:46 <dons> no unicode yet
03:26:46 <Jaak> > fix ("Î»"++)
03:26:48 <lambdabot>  "\206\187\206\187\206\187\206\187\206\187\206\187\206\187\206\187\206\187\20...
03:26:49 <Jaak> aaw
03:26:59 <Jaak> :)
03:27:16 <Masklinn> dons > is there no hotswapping package or anything in haskell?
03:27:27 <Masklinn> (akin to Erlang's hotswapping)
03:27:41 <dons> Masklinn: yeah, hs-plugins does code hotswapping
03:27:55 <dons> not quite as sophisticated as erlang of course
03:27:59 <koala_man> is it common to say that tail-recursive algorithms are iterative?
03:28:25 <ibid> koala_man: no, but it's not unheard of either
03:28:38 <ibid> dons: couldn't lambdabot do the irssi /upgrade trick?
03:28:38 <Pseudonym> It mostly depends on the intent.
03:28:59 <Pseudonym> Some map-like list-to-list transformations can properly be thought of as "iterative".
03:29:06 <Masklinn> dons > yeah but hs-plugins doesn't work for the "core"
03:29:13 <ibid> dons: that is, dump state on some file and re-exec itself with arguments that tell it to read the state from the file
03:29:59 <Masklinn> dons > which is the best thing about erlang's hotswapping
03:30:01 <dons> Masklinn: yeah it does. when you have a minimal core
03:30:01 <ibid> dons: since file descriptors stay alive through exec, this will allow the bot to appear unchanged on irc
03:30:09 <dons> Masklinn: see 'dynamic applications from the ground up'
03:30:23 <dons> ibid, it could do that ,yes
03:30:24 <ibid> well, avoids the part-join cycle at least
03:30:27 <dons> i hacked it in previously
03:30:38 <dons> so that it could preserve open network sockets of a reboot
03:30:39 <therp> good morning everyone.
03:30:55 <Masklinn> dons > ooh, ok, I'll check that.
03:31:01 <ClaudiusMaximus> Masklinn: http://www.cse.unsw.edu.au/~dons/papers/SC05.html
03:31:02 <lambdabot> Title: Dynamic Applications From the Ground Up
03:31:06 <Masklinn> dons > and why don't you use it in lambdabot?
03:31:30 <dons> oh, we do, but I just haven't added back the plugin support since i changed the buidl system
03:31:36 <dons> just because i'm lazy
03:31:39 <Masklinn> dons > lol ok
03:31:48 <Masklinn> thanks for the clarification
03:42:53 <tphyahoo> can you define a "numeric literal to list conversion"? so, eg, > 1:1 evals in ghci?
03:43:56 <xpika> is there a way to run haskell directly from the std input?
03:45:27 <tphyahoo> xpika: pugs :)
03:45:58 <tphyahoo> sorry, that wasn't a very good answer.
03:46:30 <dons> xpika: yeah
03:46:37 <dons> echo '1+2' | ghci -v0
03:47:01 <xpika> oh sexy
03:47:34 <xpika> haskell scripting here i come
03:49:10 <wolfgangbeck> runhaskell? (not stdin, though)
03:50:25 <xpika> negative, close though
03:52:52 <dons> hack hack hack :)
03:53:21 <xpika> is there a way to load modules via this method?
03:53:29 <xpika> say import Char
03:53:42 <dons> yeah, hang on ..
03:54:06 <dons> $ echo ":m + Data.Char\ntoUpper 'x'" | ghci -v0
03:54:07 <dons> 'X'
03:58:05 <xpika> $echo 'hello'
03:58:10 <xpika> $ echo 'hello'
04:04:43 <Jaak> deamnit. i can't get the newest lambdabot to build
04:05:44 <dons> Jaak: what fails/
04:05:47 <dons> you have zlib installed?
04:05:52 <Jaak> it always fails with "/tmp/ghc17721.hspp:21:1: lexical error"
04:06:35 <Jaak> ah
04:07:42 <Jaak> noew zlib fails
04:08:02 <Jaak> "import: unable to open module file `/usr/lib64/ImageMagick-6.3.0/modules-Q16/coders/simple.la': No such file or directory."
04:08:08 <Jaak> which is just weird
04:09:33 <dons> huh?
04:09:37 <dons> lib64 e?
04:10:06 <Jaak> 64 bit os
04:14:06 <dancor> what is the best library to cut/paste to the x-windows cliboard
04:14:37 <manveru> hmm
04:14:41 <manveru> xpaste?
04:14:48 <manveru> nah, how was it called?
04:16:01 <dancor> oh xclip
04:16:02 <flux-> it is not a library, but xclip is very convenient from command line
04:16:08 <flux-> ..
04:16:12 <manveru> right, xclip
04:16:18 <dancor> ok how about the gtk clipboard
04:16:27 <manveru> no idea
04:16:31 <flux-> gtk has its own clipboard?
04:16:34 <dancor> yeah
04:16:38 <manveru> they got their own *
04:16:47 <dancor> e.g. ^c in firefox
04:16:58 <opqdonut> keep in mind that there are two clipboards in x
04:17:01 <manveru> but the x-clipboard still works there
04:17:04 <flux-> atleast xclip can access that
04:17:04 <opqdonut> see the xclip manual
04:17:20 <dancor> but i have to use the mouse to set the xclipboard
04:17:33 <manveru> not with xclip :)
04:17:44 <dancor> heh ok but i need to get urls out of firefox
04:17:52 <manveru> uh
04:17:53 <dancor> to the commandline
04:17:57 <dancor> where they are free
04:18:08 <manveru> without a mouse?
04:18:11 <dancor> i need to make a program to do this
04:18:12 <dancor> yes
04:18:27 <manveru> how do you know the url then?
04:18:33 <manveru> the current page?
04:18:39 <vincenz> dancor: isn't it simpler to use wget and parse the html?
04:18:41 <manveru> nth link on page?
04:18:58 <dancor> vincenz: so like stop using firefox?
04:19:08 <vincenz> dancor: if it's for a script..
04:19:11 <manveru> seems logical :)
04:19:14 <dancor> no it's for my life
04:19:17 <Jaak> dons: i managed to install zlib but i still get the same error
04:19:56 <dancor> my life has three clipboards: gnu screen, gtk, and x (which is the lamest for needing the mouse)
04:19:56 <Jaak> oh no, sorry
04:20:13 <dancor> i need to be able to sync them
04:20:24 <manveru> hmm
04:20:32 <manveru> sync the screen clipboard?
04:20:36 <SamB_XP> does wget offer to extract urls to stdout?
04:20:41 <manveru> you'd need a daemon for that
04:21:29 <dancor> i'll be pretty happy if i can get clipboard contents out of gtk apps without the mouse
04:22:18 <Jaak> bah
04:22:20 <manveru> no idea, sorry :|
04:22:45 * Jaak gives up
04:24:03 <dancor> i wish gtk2hs had clipboard fcns
04:24:21 <dcoutts__> dancor: me too, want to bind them for us?
04:26:00 <Masklinn> dancor, couldn't you use a simple python/ruby/perl script for that kind of stuff? (extracting urls from web pages and outputting them where you want)
04:26:37 <dancor> dcoutts__: uhh i can look into it, never done that
04:27:19 <dancor> Masklinn: yeah i tried pygtk but it wouldn't persist the clipboard oddly (i'm running gnome-clipboard-daemon and calling store()..)
04:27:47 <dancor> this would be funny if it actually compelled me to try ruby.  oh, and i'd rather die than use perl
04:28:13 <Masklinn> dancor > but... why do you need to get that stuff in the keyboard btw?
04:28:18 <SamB> you don't mind running perl programs I hope?
04:28:49 <dancor> SamB: i'm just kidding, yeah i run them
04:29:14 <SamB> good, because the Evil Mangler is written in Perl ;-)
04:29:35 <dancor> Masklinn: i'll be using a gtk app (like firefox) and want to get some text in there (like a url) into a text file without the mouse
04:30:19 <Masklinn> ok so you have text in your gtk app that you want to pull to a text file without using the mouse, did I get it right?
04:30:42 <SamB> wth? libc6 for use under Xen?
04:30:56 * SamB wonders why you'd need a special libc6 for that
04:31:17 <dancor> SamB: interesting.  i stopped using perl for things other than like regex-only <10line stuff a while ago.  perhaps i will fall in love again some day
04:31:36 <dancor> Masklinn: right
04:32:04 <SamB> the Evil Mangler is like a huge regex-intensive script to reorder pieces of assembler
04:32:24 <opqdonut> hehe
04:32:53 <Masklinn> dancor > any application I guess, not firefox specific?
04:33:14 <Masklinn> (cause if it's firefox specific you could just write a FF extension for that)
04:33:22 <Masklinn> (if none exists already, that is)
04:33:38 <SamB> it will also strip out the directives for code/data markers, rendering objdump output fairly useless
04:33:50 <SamB> (it does not go to any trouble to do this, however)
04:34:09 <dancor> Masklinn: i use enough gtk stuff that i think i should try to do a gtk general thing
04:34:42 <dancor> Masklinn: also i might be selecting text (with firefox caret, etc) not just urls
04:36:50 <dancor> my best bet might be to try to bind them for haskell or drop to c or try ruby, assuming there is something wrong with the python one
04:37:08 <dancor> i know i listed 3 best bets
04:41:42 <bakert> Say I have "data Thing = Cat | House | Piano"
04:41:49 <bakert> And s = "cat"
04:41:56 <bakert> How can I get a Cat from s?
04:42:39 <bakert> I have to write a function that explicitly maps them, right?
04:42:49 <bakert> namedThing "cat" = Cat
04:42:55 <bakert> namedThing "house" = House
04:42:56 <bakert> etc.
04:43:05 <bakert> There's no better way?
04:43:59 <dons> derive Show
04:44:04 <dons> and then map toLower
04:44:19 <bakert> dons, thanks!
04:44:28 <dons> data Thing = Cat | House | Piano derive (Read,Show)
04:44:38 <bakert> then i can read the string to get the thing?
04:44:48 <dons> namedThing (a:xs) = read (toUpper a : xs)
04:44:56 <bakert> and show the thing to get the string.  that's fab!
04:45:15 <dons> showThing a = let (a:xs) = show a in toLower a : xs
04:45:26 <bakert> dons, very neat capitalize/uncap too.  merci beaucoup
04:47:18 <bakert> ?hoogle toUpper
04:47:19 <lambdabot> Char.toUpper :: Char -> Char
04:49:44 <tphyahoo> > data Thing = Cat | House | Piano derive (Read,Show)
04:49:44 <lambdabot>  Parse error
04:50:10 <tphyahoo> can lambdabot not do data declarations?
04:50:36 <tphyahoo> > data Thing = Cat | House | Piano derive (Read,Show)
04:50:36 <lambdabot>  Parse error
04:51:11 <tphyahoo> oh, never mind, no good in ghci either.
04:57:11 <bakert> tphyahoo, it was a typo on dons' part.  should be "deriving" not "derive"
04:57:35 <bakert> but the sentiment was spot on.  i now have a case insenitive read:
04:57:40 <tphyahoo> does ghci not let you do data declations?
04:57:47 <vegaiW> it doesn't
04:57:51 <bakert> findThing (a:xs) = read (toUpper a : map toLower xs) :: Thing
04:58:08 <tphyahoo> bakert++
04:58:14 <bakert> go me!
05:20:12 <bakert> With ghci 6.4.1 I don't have Data.Time.Clock is that just because it is a very recent addition?
05:20:21 <bakert> Or am I doing something stupid?
05:31:22 <bakert> Does anyone know where I can get Data.Time.Clock for ghc 6.4.1 or do I need to bite the bullet and install 6.6?
05:33:28 <Igloo> You could try building the time package, but I don't know if it's meant to work
05:34:01 <xpika> 6.6 is good anyway, you can tab out Module names.
05:35:52 <bakert> building it as we speak.  "tab out Module names"?
05:37:08 <xpika> like i type :m + Monad.<Tab> and it gives me all the monad modules to choose
05:37:19 <bakert> ah.  nice.
05:38:41 <tphyahoo> xpika: from within ghci?
05:39:19 <xpika> yep, function names too!
05:40:37 <DapperDan2> Why is the result in this type IO Integer rather than just Integer? The HDBC docs say its just the number of rows affected? execute :: Statement -> [SqlValue] -> IO Integer
05:41:10 <dylan> Because finding out the number of rows affected requires state.
05:41:19 <wolfgangbeck> can somebody give me a simple example of Data.ByteSTring.split?
05:41:21 <bakert> DapperDan2, because it does IO.  If you repeat it in a week the result might not be the same.
05:41:24 <wolfgangbeck> i'm too stupid
05:41:52 <DapperDan2> OK, but how is that enforced by GHC/Hugs?
05:42:13 <bakert> DapperDan2, not sure what you mean?
05:42:27 <bakert> DapperDan2, the type of the function is Statement -> [SqlValue] -> IO Integer
05:42:48 <bakert> So you must give it a Statement and a list of SqlValues and it will give you back an Integer "wrapped" in the IO monad.
05:43:02 <DapperDan2> "wrapped"... hmmm
05:43:21 <bakert> that's how i think of monads ... i'm new to all this ... it may be a bad choice of word.
05:43:30 <DapperDan2> i'm new to this too.
05:43:57 <bakert> you can get the integer out by "unwrapping" it:
05:44:09 <bakert> i <- thingThatIsInIO
05:44:30 <bakert> then you can use it as a normal Integer in that function
05:44:31 <DapperDan2> i'll try and find a definition of <-
05:44:40 <bakert> :t (<-)
05:44:42 <lambdabot> parse error on input `<-'
05:45:12 <bakert> hmm ... not a function?
05:45:30 <bakert> anyway, that's the operator that allows you to "unwrap" a value from a monda.
05:45:33 <daniel_larsson> :t (>>=)
05:45:35 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
05:45:36 <bakert> s/monda/monad/g
05:46:14 <DapperDan2> sExecute :: Statement -> [Maybe String] -> IO Integer
05:46:28 <daniel_larsson> (>>=) unwraps the integer, and passes it to the next "statement"
05:47:37 <daniel_larsson> "<-" is part of the "do" syntactic sugar
05:47:47 <DapperDan2> ok
05:47:54 <DapperDan2> i remember it now
05:49:31 <DapperDan2> in sExecute, why Maybe String and not just String by itself? something to do with null strings?
05:49:52 <bakert> So, I'm building ghc 6.6 with ghc 6.4.1 -- at what stage should I uninstall 6.4.1?  After make but before make install?
05:50:55 <pejo> bakert, I know for sure they  coexist very nicely if they don't have the same prefix
05:52:23 <daniel_larsson> DapperDan2: Is that an SQL function? I don't know what that parameter is for, but might be to model SQL "NULL" values
05:52:50 <DapperDan2> its for the parameters to a prepared SQL statement in HDBC.
05:53:03 <DapperDan2> sExecute :: Statement -> [Maybe String] -> IO Integer
05:53:20 <DapperDan2> wondering why its not sExecute :: Statement -> [String] -> IO Integer
05:53:21 <daniel_larsson> ahh. Well, then I guess it is to model NULL values
05:53:35 <daniel_larsson> NULL != "" in SQL
05:53:35 <DapperDan2> ok i think i've got the hang of Maybe then
05:53:36 <bakert> yeah i think i remember that being the case.
05:55:01 <DapperDan2> for some reason clone :: Connection -> IO Connection seems like an easier way to understand how the IO monad works, because you expect to get a different Connection back every time you run clone, so you use >== or something to get at it after the clone call.
05:57:49 <malebria> > show [1, 2, 3]
05:57:50 <lambdabot>  "[1,2,3]"
05:58:02 <sehute> > map (+2) [1,2,3]
05:58:03 <lambdabot>  [3,4,5]
05:58:06 <malebria> > show ['a', 'b', 'c']
05:58:08 <lambdabot>  "\"abc\""
05:58:30 <malebria> How is the definition of show String in Haskell 98?
05:58:46 <malebria> instance Show String is not possible, right?
05:58:53 <malebria> Only instance Show [a]
05:59:07 <malebria> But the result is different in [Int] and [Char]
05:59:09 <xpika> > ['a','b','c']
05:59:11 <lambdabot>  "abc"
05:59:37 <xpika> the show is needed for the quotes around the string
05:59:54 <sehute> malebria: I'm not really sure. My best guess would be some langref. documentation, unless there's a chatty haskell-guru hanging around
06:00:03 <daniel_larsson> @src [] show
06:00:03 <lambdabot> Source not found. Just what do you think you're doing Dave?
06:01:03 <malebria> sehute: I'm trying to find it in GHC source.
06:01:03 <sehute> >map show ["me the money", 123, '1']
06:01:23 <malebria> sehute: you can't have a list with different types.
06:01:31 <sehute> ah, true
06:01:32 <Botje> malebria: i'd say there's only a show [Char]
06:01:41 <sehute> > map show ("me the money", 123, '1')
06:01:42 <lambdabot>  Couldn't match `[a]' against `(a1, b, c)'
06:01:49 <Botje> but show ['a','b','c'] == show "abc"
06:02:38 <malebria> Class show has a showList function..
06:02:44 <malebria> so it's defined in Show Char.
06:03:03 <malebria> Botje: instance Show [Char] is not haskell 98.
06:03:03 <sehute> > map show ("hi", [1,2,3])
06:03:04 <lambdabot>  Couldn't match `[a]' against `(a1, b)'
06:03:24 <Botje> malebria: but show :: a -> String
06:03:27 <malebria> sehute: you can't run map on tuples.
06:03:29 <sehute> why can't I map tuples?
06:03:32 <Botje> it seems rather pointless to run show on a string :)
06:03:45 <malebria> Botje: show is in the class Show.
06:03:53 <malebria> Botje: Which also defines showList
06:04:01 <malebria> @type showList
06:04:03 <lambdabot> forall a. (Show a) => [a] -> ShowS
06:04:05 <Botje> sehute: because tuples can have tifferent types
06:04:25 <Botje> (1,"nice doggy") is okay
06:04:33 <Botje> and you can't make a function that has varying arguments
06:04:35 <sehute> Botje: But can't functions take different types as well?
06:04:41 <sehute> Botje: aha, I see. Thanks
06:05:46 <sieni> Well, you can make disjoint union types
06:06:02 <sehute> sieni: I want to learn that. How do I do it?
06:07:17 <sieni> sehute: you can use Either or roll your own: http://www.zvon.org/other/haskell/Outputprelude/Either_d.html
06:07:19 <lambdabot> Title: Haskell : Either
06:07:24 <Botje> sehute: you could look into Hlist, too
06:07:40 <sehute> okay, thanks
06:09:55 <malebria> @ type (\f (x, y) -> (f x, f y))
06:10:06 <malebria> @type (\f (x, y) -> (f x, f y))
06:10:08 <lambdabot> forall b a. (b -> a) -> (b, b) -> (a, a)
06:10:21 <sehute> How is Haskell when it comes to game-programming? Fullscreen 2D and 3D graphics? I know there is some OpenGL support, but there seems to be two variants, which is confusing.
06:10:59 <malebria> > let maptuple = (\f (x, y) -> (f x, f y)) in maptuple show ("me the money", 123)
06:11:00 <lambdabot>   add an instance declaration for (Num [Char])
06:11:44 <malebria> How can I define maptuple to run on two different types?
06:12:13 <Botje> you can't.
06:12:13 <sehute> malebria: Either is one solution, if I understood sieni right
06:15:00 <Saizan> sehute: there's a quake-like 3D game in haskell called frag
06:15:12 <sehute> Saizan: thanks
06:15:21 <Saizan> ?where frag
06:15:22 <lambdabot> http://www.haskell.org/haskellwiki/Frag
06:16:04 <sehute> Wonder how the states are stored
06:16:57 <Saizan> haven't read the source, sorry :)
06:17:02 <sehute> I
06:17:09 <sehute> I'm reading the source now :)
06:18:59 <sehute> There's a structure called GameData and a structure called ObsObjState. Those seem to be central.
06:21:29 <Saizan> [15·08·09] <malebria> How can I define maptuple to run on two different types? <-- you need parametricity on typeclasses to do that i think, or emulate it with existentials
06:24:43 <sehute> It would be cool do do some type-acrobatics in order to use map with different types, but when I think of it, I guess it's one of the strengths of Haskell, not to allow that kind of thing, "normally".
06:29:26 <malebria> sehute: there's IORef, MVars, State Monads..
06:31:07 <malebria> Botje: why can't I?
06:31:43 <malebria> > let maptuple' = (\f g (x, y) -> (f x, g y)) in maptuple show show ("me the money", 123)
06:31:50 <malebria> > let maptuple' = (\f g (x, y) -> (f x, g y)) in maptuple' show show ("me the money", 123)
06:31:57 <lambdabot>   Not in scope: `maptuple'
06:32:06 <lambdabot>  thread killed
06:32:40 <malebria> > let maptuple' = (\f g (x, y) -> (f x, g y)) in maptuple' show show ("me the money", 123)
06:32:48 <lambdabot>  ("\"me the money\"","123")
06:33:11 <Botje> well, yeah
06:33:19 <Botje> but now you're not running the same function on the two tuple elements
06:33:34 <malebria> I konw, I was trying to do something as:
06:33:48 <conal> try (***)
06:34:07 <malebria> > let maptuple' = (\f g (x, y) -> (f x, g y)); maptuple f = maptuple' f f in maptuple show ("me the money", 123)
06:34:08 <lambdabot>   add an instance declaration for (Num [Char])
06:34:25 <conal> @type (***)
06:34:27 <lambdabot> forall (a :: * -> * -> *) c' c b' b. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
06:35:01 <conal> > (show,show) *** ("me the money", 123)
06:35:02 <lambdabot>   add an instance declaration for (Arrow (,))
06:35:03 <lambdabot>     In the definition of `mxo':...
06:36:20 <conal> hm.  not quite it.
06:36:30 <conal> oh yeah:
06:36:41 <conal> > (show *** show) ("me the money",123)
06:36:43 <lambdabot>  ("\"me the money\"","123")
06:37:39 <malebria> conal: the point is using just one show.
06:38:05 <conal> malebria: gotcha
06:39:24 <malebria> Ideally maptuple' show show should be equal to maptuple show ...
07:17:03 <pbx> Any reports from Hac07 yet?
07:25:54 <malcolmw> pbx: see @haskell.hac07 channel
07:26:29 <malcolmw> oops, #haskell.hac07 channel
07:27:26 <pbx> malcolmw: Yeah, I'm lurking there.  Just wondering if there have been blog posts etc.
07:29:02 <dons> there's been one
07:29:05 <dons> I'll get another out today
07:29:11 <dons> currently ndm is giving a Hat tracer demo
07:29:18 <dons> some of us are working on binary IO
07:29:44 <nornagon> dons: what happened with lb? :)
07:29:50 <dons> when?
07:29:58 <dons> (the deadlock stuff should be fixed now, I think)
07:30:45 <nornagon> the whole netsplit saga of '07.
07:32:40 <gour> dons: latest lambdabot wants zlib and zlib wants fps ?
07:33:04 <pbx> dons: Thanks! Sounds fun.
07:33:18 <dons> gour: yeah
07:33:37 <gour> dons: isn't fps in ghc-6.6 ?
07:35:08 <mauke> no, patch the zlib.cabal file and remove fps
07:35:33 <gour> ok
07:35:54 <dons> yeah
07:37:29 * ndm gave a hat demo, but barely worked
07:37:35 <ndm> at least 3 or 4 brand new bugs
07:37:40 <ndm> including hat crashing!
07:37:44 <Masklinn> @quote
07:37:45 <lambdabot> xDie says: <xDie> > 1.1.1.1.1.1.1.1.1.1.1.1 + 2.3
07:37:52 <Masklinn> @quote
07:37:53 <lambdabot> ghc says: Functional dependencies conflict between instance declarations
07:38:15 <glguy> I figured out how to keep myself from using the Internet all day at work
07:38:30 <glguy> I've adopted a really dark color scheme
07:38:33 <glguy> gray windows
07:38:39 <glguy> black backgrounds white text
07:38:54 <glguy> having the white backgrounded webbrowser open bothers my eyes
07:38:57 <glguy> so it stays closed
07:42:42 <bakert> I don't understand haskell at all.  Which is a shame.
07:42:47 <bakert> Anyone here used HAppS?
07:43:25 <bakert> Got any idea what I can do when it produces no output at all neither as an HTTP Response nor to the console when it was working fine yesterday?
07:43:38 <bakert> To debug my functions I mean.
07:45:42 <beschmi> bakert: did you try Debug.trace?
07:46:19 <bakert> yeah ... that doesn't show up either.  i guess it is never getting there.  but i don't understand why not.
07:49:34 <bakert> i've started writing it from scratch again and i already have it working.  should have done that instead of spending the last 2 hours trying to debug it.  fool.
07:49:37 <bakert> bakert--
07:52:12 <MarcWeber> Am I right that Data.Map isn't very portable right now? My hugs version does only have FiniteMap..
07:54:22 <ndm> MarcWeber: how old is your hugs?
07:54:35 <ndm> MarcWeber: Hugs has had Data.Map for years
07:55:48 <MarcWeber> March 2005
07:56:06 <MarcWeber> and. I had a typo Its there, right
08:00:13 <luqui> @join #perl6
08:00:14 <lambdabot> Not enough privileges
08:00:51 <luqui> hmm.
08:05:07 <dons> more hackathon photos http://cgi.cse.unsw.edu.au/~dons/blog/2007/01/12#hac07-day2
08:05:08 <lambdabot> Title: Haskell hacking
08:05:11 <dons> @join #perl6
08:05:16 <dons> luqui: did that work/
08:05:29 <luqui> yep, thanks
08:05:55 <mauke> @split #perl6
08:05:55 <lambdabot> Unknown command, try @list
08:06:09 <nornagon> @liftM #perl6
08:06:10 <lambdabot> No module "#perl6" loaded
08:06:14 <luqui> haha
08:06:17 <dons> hehe
08:06:27 <vincenz> dons: which one are you?
08:08:02 <earthy> he's the one behind the camera. :)
08:08:08 <earthy> the one shaking it. :)
08:08:14 <vincenz> :P
08:08:23 <dons> sorry, I didn't want to use the flash
08:08:30 <earthy> nah, no probs. :)
08:08:32 <dons> we've got some group photos somewhere too...
08:09:04 <dons> group photo!
08:09:04 <dons> http://haskell.org/haskellwiki/Hac_2007/GroupPhoto
08:09:06 <lambdabot> Title: Hac 2007/GroupPhoto - HaskellWiki
08:09:31 <earthy> great. no caption. :)
08:09:32 <bakert> bootiful
08:09:33 <vincenz> no names
08:09:47 <earthy> nice pic thouhg
08:10:19 * earthy can pinpoint ketil malde and dominic steinitz due to the pictures given just now
08:10:26 <dons> the captions are on their way
08:10:31 <vincenz> dons: which one are yo?
08:10:50 <dons> guy in the bottom row in black
08:10:56 <dons> in the middle
08:10:56 <vincenz> ah
08:10:58 <vincenz> next to binkley
08:11:19 <dons> yup
08:11:42 * Lemmih_ is on the right, front row.
08:12:22 <vincenz> igloo most left with dcoutts next to him
08:12:31 <Jaak> @pl let k x y = x; s f g x = f x (g x) in s k k
08:12:31 <lambdabot> id
08:12:34 <earthy> has anybody commented that Ian's head with beard looks like a giant capital lambda?
08:12:52 <mauke> @pl ap const const
08:12:52 <lambdabot> id
08:13:51 <tphyahoo> does lambdabot know any perl6, or was that all just horsing around?
08:14:37 <integral> #perl6 has a separate bot for running perl6 :)
08:14:45 <mauke> tphyahoo: huh, what do you mean?
08:15:07 <dcoutts__> tphyahoo: dons reckons it's possible, ask audreyt
08:15:09 <Syzygy-> tphyahoo: The pl isn't for perl, it's for pointless
08:15:31 <mauke> oh, that
08:15:45 <tphyahoo> I meant that @join #perl6  .... @split #perl6      stuff
08:16:01 <luqui> just horsing around...
08:16:15 <dcoutts__> sjanssen: the Binary Char instance fails for c >= '\65536'
08:16:26 <mauke> that made lambdabot join #perl6
08:16:42 <Syzygy-> tphyahoo: @ as well as ? is used to tell lambdabot that a command is coming.
08:17:01 <luqui> ? too?
08:17:10 <vincenz> ?bo
08:17:10 <glguy> ?bot
08:17:10 <vincenz> ?bot
08:17:10 <lambdabot> :)
08:17:11 <lambdabot> :)
08:17:11 <lambdabot> :)
08:17:19 <mauke> ?keal
08:17:19 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
08:17:27 <glguy> the ? is more convenient for me to type
08:17:33 <vincenz> @quote glguy
08:17:34 <lambdabot> glguy says: lol, making lambdabot fight your battles
08:17:35 <nornagon> ?help keal
08:17:36 <lambdabot> keal. Talk like Keal
08:17:40 <nornagon> ?keal
08:17:41 <lambdabot> just seeing how offtopic i could get everyone
08:17:43 <vincenz> @help palomer
08:17:43 <lambdabot> palomer. Sound a bit like palomer on a good day.
08:17:46 <vincenz> @palomer
08:17:46 <lambdabot> Hrmph
08:17:56 <vincenz> @help protontorpedo
08:17:56 <lambdabot> protontorpedo is silly
08:18:01 <nornagon> ?ghc
08:18:02 <lambdabot> ghc says: parse error in data/newtype declaration
08:18:13 * vincenz onces got an "Urkk" error from GHC :)
08:18:19 <vincenz> two days ago
08:18:19 <nornagon> @activity 900
08:18:20 <lambdabot> 174*total 1*#Haskell-blah 1*Samus_ 1*kzm_ 1*luqui 1*nickserv 1*pitecus 3*Lemmih_ 3*Saizan 4*xpika 5*Binkley 5*lome 22*benja_ 35*#haskell.hac07 38*#gentoo-uy 53*#haskell
08:18:34 <glguy> what does 900 mean?
08:18:37 <glguy> ?help activity
08:18:38 <lambdabot> activity seconds. Find out where/how much the bot is being used
08:18:48 <vincenz> seems it also lists pms
08:18:54 <vincenz> @activity 10000
08:18:55 <lambdabot> 176*total 1*#Haskell-blah 1*Samus_ 1*kzm_ 1*luqui 1*nickserv 1*pitecus 3*Lemmih_ 3*Saizan 4*xpika 5*Binkley 5*lome 22*benja_ 35*#haskell.hac07 38*#gentoo-uy 55*#haskell
08:19:16 <e_e_coli> ?botsnack
08:19:17 <lambdabot> :)
08:19:24 <glguy> ?help botsnack
08:19:25 <lambdabot> botsnack. Feeds the bot a snack
08:19:33 <mauke> @quote Urk
08:19:33 <lambdabot> ghc says: Urk! Inventing strangely-kinded void TyCon: :t{tc a5gUj} (* -> *) -> * -> *
08:19:49 <glguy> ?quote mauke
08:19:50 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
08:19:58 <Syzygy-> ?quote Syzygy-
08:19:59 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
08:20:05 <Syzygy-> Ooooooh! I'm quotable!
08:20:43 <dmhouse> ?quote dmhouse
08:20:43 <lambdabot> No quotes match. I've seen penguins that can type better than that.
08:20:56 <glguy> burn!
08:20:58 <dmhouse> Wonderful, a year in the channel and I've still said nothing memorable. :)
08:21:14 <vincenz> @remember dmhouse  Wonderful, a year in the channel and I've still said nothing memorable. :)
08:21:15 <lambdabot> Done memoising quote for `dmhouse', if that is their real name...
08:21:17 <glguy>   ?remember dmhouse Wonderful, a year in the channel and I've still said nothing memorable?
08:21:21 <glguy> bah,, you beat me
08:21:39 <kaol> @quote dmhouse
08:21:39 <vincenz> @quote dmhouse
08:21:39 <lambdabot> dmhouse says:  Wonderful, a year in the channel and I've still said nothing memorable. :)
08:21:39 <lambdabot> dmhouse says:  Wonderful, a year in the channel and I've still said nothing memorable. :)
08:22:13 <glguy> ?karma dmhouse
08:22:13 <lambdabot> dmhouse has a karma of 5
08:22:21 <Syzygy-> ?karma Syzygy-
08:22:22 <lambdabot> You have a karma of 1
08:22:27 * glguy wants tab-completion in Irssi for lambdabot commands
08:22:29 <Syzygy-> Wooo! One vanitypoint! Go me!
08:22:34 <Syzygy-> glguy: Just hack it up? :)
08:22:43 <glguy> Syzygy-: yeah, I'm going to have to
08:22:46 <dmhouse> Hehe, thanks vincenz, glguy. :)
08:22:52 <vincenz> ;)
08:22:58 <glguy> ?quote Syzygy-
08:22:58 <vincenz> @karma vincenz
08:22:58 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
08:22:59 <lambdabot> You have a karma of 18
08:22:59 <nornagon> glguy: just rewrite irssi in 150 LOC
08:23:07 <Syzygy-> Hehe
08:23:09 <nornagon> sorear did it for curses!
08:23:14 <glguy> ?karma
08:23:15 <nornagon> vty \o/
08:23:15 <lambdabot> You have a karma of 15
08:23:29 <Ugarte> Korollary: Working today?
08:23:38 <glguy> people give karma for the strangest things too
08:23:43 * earthy notes ;)
08:24:05 <earthy> obviously hacking on the haskell plugins for vim doesn't earn any. ;)
08:24:14 <Syzygy-> earthy++
08:24:16 <Syzygy-> There ya go.
08:24:31 <Syzygy-> earthy: At least nowadays karma given to me sticks. Wasn't always so :P
08:24:43 * Syzygy- used to be immune to karma.
08:24:48 <Syzygy-> Away.
08:25:11 <glguy> nmessenger is a big fan of ++ing himself :)
08:25:14 <glguy> you could try that route
08:26:46 <earthy> nah
08:27:00 <earthy> doesn't count, unless there's a -- as well. ;)
08:27:36 <e_e_coli> lambdabot++
08:27:55 <glguy> but I think I've convinced him that you can't ++ yourself by /nick changing now
08:28:13 <glguy> because when he would do it, I would ?karma- in privmsg, and when he'd check, the result would be teh same
08:28:14 <nornagon> ?karma
08:28:14 <lambdabot> You have a karma of 0
08:28:34 <nornagon> i was sure that was 2
08:28:47 <glguy> shows up as a 0 here
08:28:53 <glguy> ?quote nornagon
08:28:54 <lambdabot> No quotes match. You type like i drive.
08:29:09 <glguy> ?quote karma
08:29:10 <lambdabot> No quotes match. I feel much better now.
08:29:27 <glguy> ?quote ruby
08:29:28 <lambdabot> emertens says: screw ruby on rails, I'm using snakes on a plane
08:29:33 <nornagon> lol
08:30:07 <e_e_coli> lol
08:30:23 <vincenz> python on a plane
08:30:37 * glguy was emertens
08:31:08 <dons> ?users
08:31:09 <lambdabot> Maximum users seen in #haskell: 315, currently: 303 (96.2%), active: 47 (15.5%)
08:32:41 <tphyahoo> ?quote tphyahoo
08:32:42 <lambdabot> No quotes match. stty: unknown mode: doofus
08:33:00 <e_e_coli> ?karma nornagon
08:33:00 <lambdabot> nornagon has a karma of 5
08:33:21 <tphyahoo> ?quote perl6
08:33:22 <lambdabot> No quotes match. My pet ferret can type better than you!
08:33:29 <e_e_coli> ?quote quote
08:33:30 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
08:35:19 <glguy> bah, C#'s % is rem and not mod
08:35:23 <glguy> that's less useful
08:35:32 <glguy> > -1 `mod` 0
08:35:34 <lambdabot>  Exception: divide by zero
08:35:58 <glguy> > -1 `mod` 1
08:35:59 <lambdabot>  0
08:36:04 <glguy> > -1 `mod` 2
08:36:05 <lambdabot>  -1
08:36:09 <glguy> > -1 `rem` 2
08:36:09 <e_e_coli> ?source (>>)
08:36:10 <lambdabot> Not enough privileges
08:36:10 <lambdabot>  -1
08:36:14 <e_e_coli> :(
08:36:24 <glguy> OH
08:36:30 <glguy> (-1) `mod` 2
08:36:32 <glguy> > (-1) `mod` 2
08:36:33 <lambdabot>  1
08:36:43 <glguy> ?src Maybe >>
08:36:43 <lambdabot> Source not found. stty: unknown mode: doofus
08:36:48 <glguy> ?src Maybe >>=
08:36:49 <lambdabot> Source not found. Are you on drugs?
08:37:00 <e_e_coli> Hey, I *am* on drugs.
08:37:02 <glguy> ?src Either >>=
08:37:02 <lambdabot> Source not found. I feel much better now.
08:37:07 <glguy> ?src Either (>>=)
08:37:07 <lambdabot> Left  l >>= _ = Left l
08:37:08 <lambdabot> Right r >>= k = k r
08:37:09 <mauke> ?src >> Maybe
08:37:09 <lambdabot> Source not found. stty: unknown mode: doofus
08:37:16 <glguy> ?src Maybe (>>)
08:37:17 <lambdabot> (Just _) >>  k      = k
08:37:17 <lambdabot> Nothing  >>  _      = Nothing
08:37:30 <glguy> ?help src -- does it give any insight into the expected format?
08:37:31 <lambdabot> src <id>. Display the implementation of a standard function
08:37:38 <glguy> no
08:37:50 <e_e_coli> ?src (>>)
08:37:51 <lambdabot> m >> k      = m >>= \_ -> k
08:37:56 <e_e_coli> yay
08:37:58 <e_e_coli> thanks
08:39:16 <e_e_coli> I'm new here. Is it generally ok to ask lambdabot for such things in public, as long as there isn't a lot of talk going on?
08:39:55 <araujo> hello
08:40:50 <glguy> e_e_coli: as long as you have your lambdabot training certificate
08:41:37 * e_e_coli rumages around in his desk drawer
08:41:38 <e_e_coli> m
08:42:06 <e_e_coli> Well, in a past life, I contributed a module to infobot
08:42:22 <e_e_coli> back when i could tolerate perl
08:43:38 <kowey> ?query e_e_coli
08:43:39 <lambdabot> Unknown command, try @list
08:43:39 <kowey> oops
08:45:27 <paolino> hi, is (!! n).scanl  a limited foldl and, mainly if the result is a DiffArray, do I loose the good things of DiffArrays ?
08:45:49 <nornagon> :t scanl
08:45:50 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
08:45:57 <complaisant> ?paste
08:45:58 <lambdabot> http://paste.lisp.org/new/haskell
08:52:21 <glguy> paolino: trying to do a partial shuffle?
08:52:40 <paolino> no
08:53:06 <glguy> paolino: (!!n).scanl  is   foldl f x (take (n+1) xs)
08:53:23 <paolino> mmhh
08:53:23 <alexj__> bringert: yo!
08:53:29 <paolino> no
08:53:33 <bringert> hi alexj__
08:53:39 <glguy> > foldl (+) 0 $ take 10 [1..]
08:53:40 <lambdabot>  55
08:53:48 <alexj__> did my mail make sense?
08:53:54 <ventonegro> hi
08:54:02 <paolino> well, probably you are right
08:54:03 <glguy> > (scanl (+) 0 [1..]) !! 9
08:54:04 <lambdabot>  45
08:54:06 <glguy> > (scanl (+) 0 [1..]) !! 10
08:54:08 <lambdabot>  55
08:54:14 <glguy> oh, yeah, not +1 though
08:54:18 <ventonegro> does anybody uses haskell in an embedded environment
08:54:23 <ventonegro> ?
08:54:48 <glguy> paolino: what are you trying to do?
08:54:58 <alexj__> when shapr told me what you were thinking, it sounded great.  just wasn't sure how easy it was to structure the items that way.
08:55:42 <bringert> alexj__: well, understanding it completely requires some HAppS knowledge that I don't have. But it should be enough to get started trying to find students
08:56:12 <paolino> glguy , I paste the code in a while, I make a couple of experiment before
08:56:32 <alexj__> bringert: fair enough, the most important item there is something I figured you actually know more about ... the indexed sets.
08:57:37 <alexj__> I really want to be able to do relational operations on collections of hlist extensible records.
09:00:19 <bringert> alexj__: yeah, that would be nice. I wrote a pure haskell HaskellDB backend, but the back-end itself is not type safe. What you want would be somwthing like direct implementation of the HaskellDB API
09:00:32 <dmhouse> Is saying you have a natural transformation 1 -> T precisely the same thing as saying you have a morphism X -> T(X) for every X, or is there some subtle difference?
09:01:05 <bringert> alexj__: have you seen coddfish?
09:01:31 <alexj__> I wrote a typesafe relational implementation for normal haskell records in HAppS.DBMS.  But that was when I knew less haskell and I don't think the techniques would work with HList.
09:02:11 <alexj__> yes I looked at it a while ago.  If I remember it correctly, it did not do indexing.
09:02:16 <alexj__> so wasn't particular efficient.
09:04:49 <alexj__> looking at the paper again now.  I may be remembering something different.
09:05:10 <bringert> alexj__: master's thesis projects should be fairly substantial single tasks. not all of the tasks you list seem large enough, but some of them should be
09:06:16 <alexj__> bringert: I was actually thinking that most of these were substantially smaller.  Perhaps I lack a sense of scale.
09:06:27 <alexj__> I didn't realize we were talking master's thesis!
09:06:38 <bringert> ah
09:07:04 <bringert> what were you shoting for?
09:07:06 <bringert> shooting
09:07:42 <alexj__> these are just the things I want done.  I was hoping that most of them could be implemented relatively quickly and would be interesting to do.
09:07:57 <Philippa> some might make worthy undergrad projects?
09:08:22 <alexj__> I haven't been in academia since 1993 and I wasn't a computer science major so I really don't know.
09:09:05 <bringert> alexj__: ah, yes, shapr's e-mail doesn't say master's thesis. I was thinking about master's thesis, but of course the smaller tasks could be undergrad projects, or just on-the-side projects
09:09:19 <bringert> theses
09:09:38 <alexj__> my general strategy for anything that seems large is to refactor it into something smaller.
09:10:14 <alexj__> so if something on the list looks like a really large project, I will try to convince you to view it in a way that makes it a smaller project!
09:10:44 <bringert> yeah, that's a good plan. in the case of a master's thesis, breaking the task down into smaller chunks should be part of the task
09:10:44 <lisppaste2> paolino pasted "placer func" at http://paste.lisp.org/display/34899
09:11:45 <bringert> alexj__: I don't think any of them are too large, most are rather too small. So maybe I can view a bunch of then as a larger project :-)
09:12:29 <alexj__> the thing that is effectively a big block in terms of usability is the hlist stuff.  It is really hard for happs to adopt hlist without having XML generation, URLEncoded parsing, and collections support.
09:12:55 <alexj__> each of those tasks I think may be a reasonable size.  together it is a big project.
09:13:27 <alexj__> having only any subset of those three make hlist not really usable.
09:15:41 <bringert> sounds reasonable
09:15:42 <alexj__> I am game to work with you to composite the others into sufficient size blocks.
09:15:49 <paolino> glguy, if xs is prepared nicely , it's very probable that cs is ready after a small part of the folding
09:16:22 <alexj__> the hlist stuff is the one that seems necessarily a big block.
09:17:07 <bringert> alexj__: one issue with HList is programmer usability. The error messages aren't always great
09:17:20 <paolino> glguy: in other languages I would throw an exception in that case :/ , to stop it
09:17:53 <bringert> alexj__: the dynamic recompilation part could also be done with the ghc api
09:18:09 <bringert> alexj__: I have a proof of concept of that for CGI program
09:18:11 <bringert> s
09:19:03 <alexj__> ok I assumed hsplugins was the way to go but am totally willing to believe that the ghc API is the way to go.  I don't know enough to assess the merits.
09:19:06 <paolino> glguy if I use filter (complete cs) . scanl instead ?!?
09:19:20 <paolino> mah
09:20:03 <alexj__> bringert: re hlist, the error message issue is interesting.  I haven't used them so I didn't know.  In general, I find GHC error messages incredibly opaque so I'm not sure how much worse it can really be.
09:20:38 <bringert> alexj__: try using HaskellDB for some horrible error messages :-)
09:20:43 <bringert> I think HList is about the same
09:21:03 <alexj__> when I code, I usually just look at the line number and then iterate through possible fixes.
09:21:23 <dons> I think ghc-api would be reasonable
09:21:42 <bringert> alexj__: here's my ghc-api example: http://csmisc14.cs.chalmers.se/~bjorn/dynhs/examples/wiki/wiki.hs/Main
09:21:45 <lambdabot> Title: Main, http://tinyurl.com/yfqwsq
09:22:28 <bringert> shankys and shoffsta are writing a web framework on top of that
09:22:30 <alexj__> why would one choose ghc-api vs hsplugins?
09:23:02 <dons> ghc-api has access to the bytecode interpreter
09:23:09 <dons> so potentially you can write a faster 'eval' function
09:23:18 <bringert> exactly, no need to generate and load object files
09:23:19 <dons> it doesn't have a nice hs-plugins-like api yet though
09:23:24 <dons> but the hs-plugins api could be ported to ghc-api
09:23:32 <dons> and just use bytecode eval underneath
09:23:42 <bringert> I think you could use my code for that
09:24:07 <glguy> paolino: I'm back now
09:24:13 <bringert> some stuff's here: http://www.cs.chalmers.se/~bringert/darcs/dyn-cgi/DynHS/GHCUtils.hs
09:24:14 <glguy> paolino: if you still have a question, you can ask it
09:24:16 <Botje> is there a drschemee-like IDE for haskell?
09:24:16 <lambdabot> http://tinyurl.com/yctpxd
09:24:39 <paolino> glguy , seen the paste ?
09:24:44 <glguy> nope
09:24:48 <glguy> I was in a meeting
09:25:01 <alexj__> so what I want is to code to the hsplugins API and have someone else implement the hsplugins API on top of the ghc-api?
09:25:12 <paolino> http://paste.lisp.org/display/34899
09:25:23 <alexj__> is that a homework assignment or a master's thesis?
09:25:41 <bringert> alexj__: I don't think it's enough for a thesis
09:26:09 <glguy> paolino: ok, I see it
09:26:25 <bringert> alexj__: but it could probably be extended to one
09:26:29 <paolino> *ClusterCore> placer (3,2) [(0,1),(1,1),(2,1),(2,0),(1,0),(0,0)]
09:26:30 <paolino> [[2],[1,0]]
09:26:48 <dons> its a port of the original hs-plugins paper to ghc-api
09:27:02 <alexj__> the thesis verison is probably making it really nice for happs users.  For example, we probably want to end up with a happs binary that takes a app source directory as an argument to run a web service.
09:27:12 <bringert> right
09:27:18 <bringert> that sounds good
09:27:20 <paolino> it works, but the answer was ready after 3 elements
09:27:49 <bringert> it would also be nice to output sensible error messages (with references to the source code etc) when it fails to load
09:27:53 <glguy> paolino: Do you know the Cont monad?
09:28:12 <paolino> mmhh , should  I :/ ?
09:28:24 <glguy> it lets you exit a computation with a value
09:28:31 <alexj__> yup.  and we want the live service to keep running until the new code actually works.
09:29:07 <bringert> where works == loads, or you want to be able to test the new one first?
09:29:29 <paolino> glguy , can you pate an example, jumping out of a folding for a reached count ?
09:29:55 <glguy> k
09:30:11 <alexj__> I think works==loads AND is able to handle the preexisting state.
09:31:01 <mbishop> Nice pictures dons :P
09:31:03 <alexj__> I assume the production model is: developer debugging on dev box.  then testing on staging and then pushing to live.
09:31:15 <bringert> alexj__: sounds good.
09:31:49 <alexj__> staging means testing a transition from copy of the live server and seeing if it works.
09:32:41 <alexj__> the whole staging/live infrastructue of happs is something that needs to be developed.
09:32:56 <lisppaste2> glguy annotated #34899 with "jumping out" at http://paste.lisp.org/display/34899#1
09:33:00 <alexj__> when lemmih comes back from hac07, I intend to have him work on some of that.
09:34:25 <lisppaste2> glguy annotated #34899 with "repaste (missed a couple chars)" at http://paste.lisp.org/display/34899#2
09:36:22 <glguy> :t evalCont
09:36:24 <lambdabot> Not in scope: `evalCont'
09:36:28 <glguy> ?let evalCont = flip runCont id
09:36:29 <lambdabot> Defined.
09:36:30 <alexj__> bringert: so how do we get started here?
09:36:50 <bringert> alexj__: I'll start looking for suitable students
09:37:04 <glguy> > evalCont . callCC $ \done -> let f acc x | acc > 100 = done acc | otherwise = return (acc+x) in foldM f 0 [1..]
09:37:06 <lambdabot>  105
09:37:09 <bringert> alexj__: I just sent you a short e-mail
09:37:31 <alexj__> bringert: cool.  looking at coddfish.  more interesting than I remember.  Thank you.
09:37:52 <Saizan> alexj__: is HAppS.DBMS still developed? (i've read something like it's deprecated)
09:37:59 <bringert> alexj__: the fundeps are quite horrible though
09:38:35 <alexj__> bringert: ok then maybe I want my orginal idea of just having indexed sets.
09:38:47 <alexj__> Saizan: HAppS.DBMS is experimental.
09:39:13 <alexj__> I am using it in one of my projects right now.  I just want it to work with HList.
09:39:27 <bringert> alexj__: I guess you want to be able to say what is a key and what isn't. or should there be indexes on everything?
09:40:02 <paolino> glguy, so the accum function must be monadic ?
09:40:11 <alexj__> if you look here: http://happs.org/HAppS/src/HAppS/DBMS/Example.hs
09:40:34 <glguy> paolino: sure, but it can be trivially so
09:40:35 * glguy lunch
09:40:46 <alexj__> you will see a line like this :  --Specify how to index each record type
09:40:47 <alexj__> instance Record Item Properties where
09:40:49 <alexj__>     index = [Id=:itemId, Stock=:stock,Description=:description,Price=:price]
09:41:19 <alexj__> which basically says that you index Items on their itemId,stock, and price.
09:41:54 <alexj__> if I were to do it over, I would probably have the index function passed as an argument in creating the table.
09:42:14 <alexj__> but that is tircky.
09:42:23 <alexj__> tricky to do.
09:42:46 <mwc> What's the feature of SML that allows record types to share field names? Structurual subtyping?
09:43:12 <alexj__> the overall concept is that you wrap Data.Set with a bunch of Indexes for items in the Set.
09:44:57 <Willem> hello
09:45:24 <jethr0> Willem: hello
09:45:59 <Willem> i have done a course in caml light a few years ago
09:46:24 <Willem> is haskell and caml very different from each other?
09:46:49 <opqdonut> caml is closer to haskell than most other languages
09:46:56 <jethr0> hmm, i don't know caml very well. i guess the most pronounced difference is that haskell is non-strict where caml is by default strict
09:47:13 <mauke_> also, haskell is beautiful
09:47:17 <alexj__> bringert: did that explanation make sense?
09:47:30 <jethr0> which leads to further differences like reliance on monads in haskell
09:47:53 <Willem> well, i am a bit rusted on the terms
09:47:54 <alexj__> bringert: you don't want indexes on everything because that slows you down.  the type checker prevents you from doing ineffecient searches.
09:47:55 <bringert> alexj__: yeah, makes sense
09:48:17 <Willem> bu i do remeber i liked the functional idea a lot
09:48:39 <sjanssen> Willem: you should like Haskell then
09:48:39 <bringert> alexj__: that's what I figured. besides, not all the things necessarily have Ord etc
09:48:48 <Willem> went on to do a masters degree using c++
09:48:49 <jethr0> Willem: think of non-strict as "lazy" for now... so haskell evaluates a piece of data only if it's needed for the result
09:49:01 <jethr0> *brr*
09:49:13 <Willem> ok
09:49:35 <alexj__> Bringert: I actually made Index a class so you can define different sorts of indexes on different features of your type.  e.g. I defined a trivial TextIndex that has different operators than the Ord Index.
09:49:39 <jethr0> > take 10 [1..]
09:49:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
09:49:46 <Willem> anyway, i'd like to get back to functioanl programming...
09:50:08 <jethr0> in this example [1..] is the infinite list of all positive integers. and haskell can handle it because we only demand the first ten elements of it
09:50:19 <mauke_> > [1..]
09:50:21 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
09:50:35 <jethr0> i'd definitely recommend haskell. in the beginning it can be a bit challenging, but your caml background should help a lot
09:51:29 <Willem> what kind of reserach topics do haskell programmers focus on
09:51:49 <opqdonut> haskell :)
09:52:06 <Willem> ok
09:52:09 <jethr0> type systems, a lot. and functional data structures, ...
09:52:24 <mauke_> parallelization
09:52:34 <conal> cool applications!
09:52:39 <jethr0> @wiki Research_papers
09:52:39 <lambdabot> http://www.haskell.org/haskellwiki/Research_papers
09:52:41 <sjanssen> Willem: Haskell is very good at implementing symbolic manipulation programs.  Haskellers often write compilers, interpreters, and the like
09:53:01 <Willem> now we're talking
09:53:06 <conal> domain-specific languages
09:53:11 <sjanssen> Willem: have you heard of pugs?
09:53:19 <Willem> symbolic computation
09:53:28 <Willem> pugs ... ? nope
09:53:37 <jethr0> sjanssen: do you think so. i'm still a bit partial to lisp for symbolic manipulation. but then again, i might not be proficient enough in haskell yet ^_^
09:54:02 <sjanssen> Willem: it's the first implementation of Perl 6 (which has been vapor ware for years)
09:54:13 <sjanssen> and guess what?  pugs is written in Haskell
09:54:20 <Willem> ah .. done in haskell?
09:54:36 <Willem> yes
09:54:56 <jethr0> and quite readable as well, although it's quite a lot of code by now
09:54:57 <conal> hey guys: i'm looking for a shell hack for use with hscolour.  given a path, i want to create any implied directories that don't yet exist (before writing hscolour'd code into them).  any ideas?  pure shell preferred, though a haskell program would suffice.
09:55:21 <dons> mkdir -p will create missing dirs
09:55:26 <sjanssen> jethr0: pattern matching is highly useful
09:55:29 <dons> and dirname will give you the path to hand to mkdir
09:55:34 <Willem> so, haskell is a great tool for language research
09:55:36 <dmhouse> Gah, how does one do a new row in MediaWiki?
09:55:43 <Syzygy-> ?list
09:55:44 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
09:55:56 <conal> dons: awesome!  thanks.  :)
09:55:58 <sjanssen> jethr0: and algebraic data types
09:56:26 <jethr0> sjanssen: sure it is. i just think that lisp is absolutely great for symbol manipulation (albeit in a different way (i.e. untyped) than haskell)
09:56:38 <pejo> conal, and if mkdir doesn't take p you can iterate through the path with a for-loop, and mkdir them one by one.
09:57:15 <conal> pejo: thanks.
09:57:20 <pejo> Hm, maybe nobody uses Haskell on the platforms that have old mkdir's?
09:57:29 <Willem> well, i guess it depends what the symbols do
09:57:41 <dons> ?users
09:57:42 <lambdabot> Maximum users seen in #haskell: 315, currently: 300 (95.2%), active: 53 (17.7%)
09:57:52 <profmakx> phew
09:58:06 <Willem> what about something like solving mathimatical equations ... ?
09:58:14 <conal> 315 :)
09:58:16 <jethr0> definitely
09:58:50 <Willem> well, i think i'll give haskell a try
09:59:43 <paolino> ?users-trend
09:59:44 <lambdabot> Unknown command, try @list
10:00:02 <Willem> but, i do need an iteesrting problem to solve ...
10:01:18 <Willem> what problems are you guys working on at the moment
10:02:07 * sjanssen is hacking on a binary serialization library
10:02:40 * jethr0 is looking for an interesting problem. and, as always, trying to understand haskell better
10:02:57 <alexj__> willem: how about generating a supply of random numbers from the promiscously listening to the network card?
10:04:02 * jethr0 wouldn't think that to be cryptographically safe
10:04:18 <paolino> so, fuctions passed to callCC can use their only argument as a function to get out their computation ?
10:04:40 <jethr0> hmm, basically
10:05:11 <jethr0> the function passed to callCC get's its continuation as argument. calling the continuation will then "get out of the function"
10:05:19 <SimonRC> yes
10:05:22 <jethr0> hence the name "call with current continuation"
10:06:58 <jethr0> by saving the argument you can also write a loop (at least in scheme that works great, even though twisting your mind)
10:07:01 <SimonRC> Actually Haskell needs a little sugar for CPS.  Something like "x <-- foo; bar x" instead of "foo bar".
10:07:55 <jethr0> SimonRC: what do you mean "need"?
10:08:03 <Willem> anybody working on constraint satisfaction problems?
10:08:49 <SimonRC> Actually if you define "type CP a = forall b. (a -> b) -> b", then you could (almost) say "instance Monad (CP)".
10:09:10 <SimonRC> jethr0: well, it would make ugly-looking code tidier, like do-notation did.
10:09:38 <sjanssen> newtype Cont r a = Cont { runCont :: (a -> r) -> r }
10:09:52 <jethr0> SimonRC: well, CPS isn't suited that well for human coders anyways, and is most often created by transformation, so the "looks" might not be so important
10:09:57 <sjanssen> is that forall critical?
10:10:55 <paolino> Willem: a scheduling library with constraint satisfaction ?
10:11:19 <bd_> SimonRC: Isn't the cont monad enough sugar for CPS?
10:11:35 <Willem> paulino: are you working on one?
10:12:01 <paolino> no, I think is a useful work to be coded
10:13:10 <paolino> (to me it would be a lifetime project probably)
10:16:00 <paolino> or, the only application I met in real life where constraint programming would have paid
10:16:29 <paolino> *been paid
10:20:03 <dons> ?users
10:20:04 <lambdabot> Maximum users seen in #haskell: 315, currently: 298 (94.6%), active: 49 (16.4%)
10:22:25 <Saizan> if i have an array is safe to write in a index while reading from another concurrently?
10:22:40 <Masklinn> dons > are you checking if we passed a new milestone?
10:22:58 <Masklinn> dons > do you write stats to compare with the population of other language-related channels?
10:28:20 <newsham> morning.  FFI issue:  Unacceptable argument type in foreign declaration
10:29:26 <mauke> what did you do?
10:29:27 <dons> Masklinn: I did notice this morning that we did
10:29:41 <Masklinn> yeah I know, thus the remark
10:29:52 <Masklinn> I was wondering if you were checking for a new record :p
10:29:58 <newsham> mauke: this: http://www.thenewsh.com/~newsham/x/SilcClient.hs
10:30:04 <Masklinn> wouldn't it be possible to add a stats module to lambdabot?
10:30:12 <newsham> its complaining about my "wrapper" declarations.
10:30:25 <Masklinn> that way you could just check a page or something and see the new "milestones"
10:30:55 <newsham> particularly about the functions (like OnJoinFunc)
10:30:57 <Saizan> ?where #haskell
10:30:58 <lambdabot> I know nothing about #haskell.
10:31:01 <jethr0> is there a tutorial or at least some hints about comonads somewhere? i just don't seem to grasp them with the few papers available :(
10:31:08 <mauke> yeah, -> doesn't correspond to a C type
10:31:10 <Saizan> ?where lambdabot
10:31:11 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
10:32:10 <newsham> mauke: I've created callback functions in a similar manner in the past
10:32:23 <newsham> evidence: http://www.haskell.org/hawiki/FfiExample (see CBFunc)
10:32:24 <lambdabot> Title: FfiExample - The Haskell Wiki
10:32:26 <jethr0> or maybe some simple examples using comonads?
10:32:50 <newsham> oh!  I didnt FunPtr my decls elsewhere!
10:34:41 <newsham> the error was at a diff place than I thought.. my bad
10:36:30 <newsham> well it builds now!  but seg fault :(
10:36:48 <jethr0> how do you get to know anything about zippers and comonads without becoming a type system/category theory buff :((
10:37:28 <dmhouse> jethr0: you read a lot.
10:37:39 <e_e_coli> = you become a category theory buff
10:37:54 <dmhouse> jethr0: what's wrong with becoming a category theory buff anyway?
10:38:08 <jethr0> read what? all the papers and pages seem to imply profound previous knowledge
10:38:26 <dmhouse> jethr0: for an introductory article to CT, aimed at a Haskell programmer, with lots of Haskell code, http://en.wikibooks.org/wiki/Haskell/Category_theory
10:38:27 <newsham> how do I tell cabal to build C code with -g?
10:38:33 <dmhouse> I just wrote it, tell me what you think. :)
10:38:48 <jethr0> dmhouse: i'd love to, but i have a very limited recall for mathematical facts and usually forget the simple axioms before getting to the interesting stuff
10:39:04 <pejo> jethro, are you looking for reasonable type theory things, or trying to avoid it?
10:39:10 <jethr0> nice, i'll have a look
10:39:52 <jethr0> pejo: i'm trying to learn more applicable haskell stuff without dabbling too deep into type theory land....
10:40:22 <jethr0> i'm sure there are very nice applications for arrows, comonads, zippers, ... if only more people knew about them in a non-academic, more applicable way
10:40:37 <tphyahoo> dmhouse, your cat theory intro got me some reddit karma :)
10:41:01 <jethr0> "I" `elem` "more people"
10:41:19 <tphyahoo> oops, that was another paper.
10:42:13 <tphyahoo> http://www.cs.toronto.edu/~sme/presentations/cat101.pdf
10:42:18 <tphyahoo> pretty pictures.
10:42:22 <pejo> jethro, hasn't Oleg written something/much about Zippers? He's great at applying things.
10:43:33 <jethr0> pejo: i'll have another look, but i couldn't find the initial zipper paper anywhere
10:44:18 <pejo> jethro, oh, isn't that by Huet though?
10:44:19 <newsham> hrmm.. blah.. my FFI code was working when I exported my haskell functions directly, but I changed it so the haskell code passes callback functions into the C code.  The callback functions are getting called, but it looks like the arguments are getting mangled
10:44:35 <sm> morning all
10:45:25 <jethr0> pejo: i'll have another look in google
10:45:26 <pejo> jethro, http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
10:45:29 <lambdabot> http://tinyurl.com/u3rvp
10:46:10 <jethr0> damn I feel stupid... hadn't look thoroughly enough. thx pejo
10:50:01 <Syzygy-> Hmmmm.
10:50:13 <Syzygy-> Someone here was wishing lambdabot command completion earlier.
10:50:20 <newsham> I dont see how this crash could possibly happen given the type system.  :(
10:50:22 <Syzygy-> http://mikael.johanssons.org/irssi
10:50:24 <dons> Syzygy-: in irc?
10:50:29 <dons> yeah, I have some already too :)
10:50:30 <Syzygy-> For irssi
10:50:46 <dons> 12:24 ?s         ?source                                  no
10:50:46 <dons> 12:25 ?h         ?hoogle                                  no
10:50:46 <dons> 12:25 ?g         ?google                                  no
10:50:46 <dons> 12:25 ?u         ?users                                   no
10:50:46 <dons> 12:26 h.o        http://haskell.org                       no
10:50:48 <dons> 12:27 ?w         ?where                                   no
10:50:48 <lambdabot> Title: Haskell - HaskellWiki
10:50:53 <Syzygy-> This one picks the list off of the web at init, then patches into the tab-completion hardwiring to get hold of any prefix completion.
10:51:09 <Syzygy-> So I write @whe<tab> and get @where
10:51:36 <newsham> are you releasing lambdabot.irssi.conf ?
10:51:49 <Syzygy-> Nope.
10:51:50 <Syzygy-> Just a script.
10:52:17 <newsham> syz: your url is forbidden.
10:52:34 <newsham> mikael johanssons?  the basketball player?
10:52:38 <dons> Syzygy-: oh nice
10:52:59 <dons> newsham: his european cousin
10:53:04 <paolino> :t runCont
10:53:06 <lambdabot> forall r a. Cont r a -> (a -> r) -> r
10:53:30 <paolino> :t L.evalCont
10:53:32 <lambdabot> Couldn't find qualified module.
10:53:43 <paolino> :t evalCont
10:53:45 <lambdabot> Not in scope: `evalCont'
10:53:46 <Syzygy-> newsham: Try again...
10:54:04 <Syzygy-> newsham: Mikael Johansson is only in the top 10 first names and top 3 last names in Sweden, y'know...
10:54:10 <Syzygy-> It's a bit "John Smith" over it.
10:54:19 <dmhouse> jethr0: I didn't find that zippers paper to easy to grok, trees are complicated beasts. I got there in the end, though, albeit with many questions :) I think if you ping apfelmus, he was planning to write a zippers article based on lists for the Wikibook.
10:54:22 <newsham> syz: neat.
10:54:37 <Syzygy-> Whoa.
10:54:41 <Syzygy-> That's a bug I need to fix.
10:54:48 <newsham> oops!  my FFI problem: flipped two args in the C code :(
10:54:54 <jethr0> dmhouse: nice thx
10:55:25 <dmhouse> jethr0: I will warn you that my CT article isn't fully complete yet, but it should still be a nice introduction.
10:55:51 <Syzygy-> There.
10:56:06 <Syzygy-> It matched for @gazetteer before @tell on @te<tab>
10:56:10 <jethr0> i did some CT at university, but although i was fascinated i always had a hard time getting deeper into it
10:56:28 <Syzygy-> @tell glguy Tab completion in irssi with @ prefix: http://mikael.johanssons.org/irssi
10:56:29 <lambdabot> Consider it noted.
10:56:33 <Syzygy-> Hey sigfpe!!
10:57:00 <dpiponi> Hey sysygy, only dropping in for a short bit
10:57:03 <glguy> thanks!
10:57:04 <lambdabot> glguy: You have 1 new message. '/msg lambdabot @messages' to read it.
10:57:17 <dmhouse> glguy: you can use ?clear-messages to ignore that.
10:57:25 <Syzygy-> glguy: You are a bad, bad, BAD person.
10:57:26 * glguy just now got back from lunch
10:57:29 <glguy> ?
10:57:38 <Syzygy-> Due to your ideas, I forgot dinner -AND- neglected to grade homework.
10:57:43 <glguy> LOL
10:57:50 <Syzygy-> Bad glguy, BAD!
10:57:52 <Syzygy-> glguy++
10:57:53 <glguy> Syzygy-: What can I do... I'm a muse
10:57:54 <astrolabe> > 3
10:57:56 <lambdabot>  3
10:58:06 <Syzygy-> glguy: Hope you like my script at least. :)
10:58:10 <glguy> Forbidden
10:58:11 <glguy> You don't have permission to access /irssi/ on this server.
10:58:17 <glguy> 302
10:58:19 <glguy> 403
10:58:38 <Syzygy-> Oh buger.
10:58:41 <Syzygy-> Hang on.
10:59:06 <astrolabe> @where zipper
10:59:07 <lambdabot> I know nothing about zipper.
10:59:11 <astrolabe> !
10:59:21 <dpiponi> Hey jethr0, I sympathise with your problem when you say that papers on some stuff seem to imply profound previous knowledge
10:59:44 <glguy> paolino: evalCont = flip runCont id -- not in the std library or mtl
10:59:51 <glguy> paolino: evalContT = flip runContT return
11:00:33 <jethr0> dpiponi: thx. if i could at least get to a point of understanding i might even write a tutorial for posterity (as i did for template haskell), but if i don't even get the faintest idea how to use these ideas, even that becomes nearly impossible
11:00:43 <dpiponi> I have to work backwards. Start from a hint. Try to work out some details for myself. Then do a web search related to what I've just worked out.
11:00:53 <glguy> Syzygy-: now i get a 500
11:01:04 <glguy> (I assume... Internal Server Error)
11:01:40 <astrolabe> jethr0: specifically category theory?
11:01:41 <jethr0> @where+ zipper http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
11:01:42 <lambdabot> Done.
11:01:50 <astrolabe> jethr0: thanks
11:02:08 <dpiponi> jethr0: like the paper I mentioned here was over my head: http://sigfpe.blogspot.com/2006/11/variable-substitution-gives.html
11:02:11 <lambdabot> Title: A Neighborhood of Infinity: Variable substitution gives a..., http://tinyurl.com/y8cvgg
11:02:14 <jethr0> astrolabe: no, but many nice things in haskell are related either to CT or type theory, neither of which i'm a guru
11:02:38 <dpiponi> jthr0: But somehow I recognised enough bits to realise that the really simple code I was writing was the same thing
11:02:49 <astrolabe> I'm reading TAPL at the moment, which is ok.
11:02:50 <jethr0> thx
11:03:18 * jethr0 was too impatient for TAPL :(
11:03:19 <dpiponi> jethr0: 'cept I didn't have the fancy vocabulary.
11:03:23 <lisppaste2> paolino annotated #34899 with "exiting with callCC" at http://paste.lisp.org/display/34899#3
11:03:28 <Syzygy-> GAH!
11:03:38 <Syzygy-> I cannot get my apache to cooperate :(
11:03:56 <Syzygy-> Anyway, it's really at http://mikael.johanssons.org/irssi/lambdabot_complete.pl
11:04:51 <jethr0> paolino: yuch, what does that do?
11:05:03 <dpiponi> Syzygy-: When are you next going to put some math in your blog? Stop with the Apache already!
11:05:16 <Syzygy-> dpiponi: Once my winter nightmare stops.
11:05:21 <glguy> paolino: does that do what you wanted it to?
11:05:32 <paolino> yes
11:05:35 <Syzygy-> dpiponi: Since mid-December and up to beginning February, I'm pretty much baked when it comes to everything.
11:06:11 <dpiponi> Syzygy-: What happens Dec -> Deb?
11:06:25 <glguy> Syzygy-: how to i install this script?
11:06:33 <glguy> Syzygy-: I've not doen this before
11:06:39 <paolino> glguy ,like yesterday , if there is any "make it better", welcome
11:06:45 <Syzygy-> First, I had to stop doing maths in order to prepare for my Stockholm trip (holiday), then I was in Stockholm, with way too much to do. I got back from .se yesterday, today had me working through my homeworkstack, attending the colloquium, realizing that my lodgings in Paris though cheap had cats, and thus were unusable, organized funding for hotel, then hotel.
11:07:05 <Syzygy-> Tomorrow is the 40-year party for the local maths organization, then saturday more organisation stuff.
11:07:15 <mauke> put it in ~/.irssi/scripts
11:07:33 <Syzygy-> Sunday I go to Paris for a week-long conference for Gerstenhaber and Stasheff - MUCH A_oo-stuff happening there (*wheeeeee*)
11:07:42 <dpiponi> Syzygy-: Exciting life you live there!
11:07:50 <Syzygy-> Saturday after that I go back to Jena, then Sunday morning to Gothenburg to attend my grandfather's funeral.
11:07:54 <mauke> optional step: make a symbolic link to it in ~/.irssi/scripts/autorun/
11:08:05 <glguy> Can't locate LWP.pm in @INC (@INC contains: /h
11:08:10 <glguy> Syzygy-: what is LWP.pm
11:08:16 <Syzygy-> Funeral monday, travel back tuesday, hold examples class unprepared wednesday morning.
11:08:23 <Syzygy-> glguy: Standard Perl web library
11:09:11 <glguy> p5-libwww/ ?
11:09:14 <Syzygy-> Prepare crypto workshop for 9th graders wednesday-thursday. Hold crypto workshop friday, correct double set of homework saturday-sunday. Breathe monday, hold examples class tuesday and THEN I can start thinking about something else than what I absolutely need to do next to get through.
11:09:29 <Syzygy-> http://search.cpan.org/perldoc?LWP
11:09:32 <lambdabot> Title: LWP - The World-Wide Web library for Perl - search.cpan.org
11:09:53 <Syzygy-> It's in no way difficult to adapt the script to use a local file, or another web library.
11:09:54 <glguy> Syzygy-: ok, I'm just trying to figure out what openbsd's ports tree calls it :)
11:09:58 <jethr0> Syzygy-: you are a busy person
11:10:05 <Syzygy-> Ah. No idea, but libwww-perl looks right.
11:10:08 <glguy> ok
11:10:09 <Syzygy-> jethr0: I seem to get these crunches.
11:10:27 <Syzygy-> It was similar august-september - kept on travelling from vacation to conference to conference to conference....
11:10:51 <glguy> Syzygy-: it is
11:11:04 <Syzygy-> dpiponi: After the crunch, though, I'll have conference reports from Paris as well as A-infinity goodies lined up.
11:12:26 <glguy> speaking of grading, I used to grade for an intro to programming course (c++) for non-programmers
11:12:35 <Syzygy-> Oh joy.
11:12:35 <glguy> I'll never do it again
11:12:55 <dpiponi> By the way, this friend of mine has been piling up lots of good mathematical Haskell here: http://www.polyomino.f2s.com/david/haskell/articles.html
11:12:59 <lambdabot> Title: Haskell for Maths - Articles
11:13:00 <jethr0> glguy: let me guess, everyone got 0 points ^_^
11:13:16 <glguy> jethr0: some got a couple more than that, but it was bad
11:13:27 <dpiponi> Those articles don't seem widely known so I thought I'd give them a plug
11:13:28 <Syzygy-> dpiponi: Yeah, I've seen those. Based a little bit of what I wrote for the NumericPrelude on it.
11:13:40 <Syzygy-> They are linked from the wiki, aren't they?
11:14:36 <paolino> glguy, you think using a record as the accumulation is a good idea to have more clarity ?
11:15:20 <dpiponi> Not sure if they're linked. I'll have to have a look. The number of articles has been slowly creeping up and I think he may have a nice one on logic brewing up.
11:15:48 * Syzygy- pokes dpiponi. Be a good community member and link it now in case it isn't.
11:16:07 <Syzygy-> There is a page there for Haskell and mathematics anyway. It obviously belongs there.
11:16:14 <Syzygy-> and if you do it now, then it's done. :)
11:16:31 * dpiponi shouts "ouch, stop poking me, OK, OK"
11:16:40 <zeeeeee> anybody know how to get hare working in ghc-6.6?
11:18:15 <Syzygy-> Here, have a cookie when you're done. *cookie*
11:18:37 <dpiponi> Syzygy-: Here? That looks more foundations of CS than general math. http://www.haskell.org/haskellwiki/Mathematics
11:18:39 <lambdabot> Title: Mathematics - HaskellWiki
11:19:10 <dpiponi> Syzygy-: Aha! http://www.haskell.org/haskellwiki/Haskell_and_mathematics
11:19:12 <lambdabot> Title: Haskell and mathematics - HaskellWiki
11:19:19 <glguy> @bot
11:19:20 <lambdabot> :)
11:19:25 <Syzygy-> Told you it was there.
11:19:27 <Syzygy-> @botsnack
11:19:28 <lambdabot> :)
11:19:31 <Syzygy-> Hmmm. That's odd.
11:19:40 <Syzygy-> @bo completes to @botsnack before @bot
11:19:40 <lambdabot> :)
11:20:00 <Syzygy-> Oh. @bot is no command, but gets parsed to @botsnack
11:20:16 <glguy> Syzygy-: why does it add a space after the @ when I type: @<TAB> and then jumps between "@" and "@<next thing>"
11:20:20 <dpiponi> Sysygy-: I've not seen that page. Half of those links are to my own blog and I see some stuff on A-algebras!
11:20:21 <Syzygy-> dpiponi: Isn't it more of a library than a tutorial?
11:20:29 <Syzygy-> glguy: No idea.
11:20:55 <glguy> Syzygy-: oh, it only does it when I do "@<TAB>"
11:20:57 <Syzygy-> glguy: Oh. Wait. It's probably because the first item in the command list is the empty string.
11:21:01 <malsyned> is there a negation combinator for Parsec?  I notice that there is a "space" parser, but no "notSpace" parser and I'm wondering if there's a way to make one from "space" instead of saying notSpace = noneOf " \v\f\t\r\n"
11:21:02 <glguy> @
11:21:05 <dpiponi> Syzygy-: The other half are to your blog. We need more mathematicians using Haskell!
11:21:21 <Syzygy-> dpiponi: It was built a couple of months ago, and quickly populated by someone scouring our two blogs primarily. :P
11:21:24 <glguy> Syzygy-: looks like there are a couple blank lines, I'll play with the script
11:21:32 <Syzygy-> glguy: Please do.
11:21:54 <glguy> base has no visible commands
11:21:57 <glguy> fails on those lines i think
11:22:02 <newsham> ?seen sorear
11:22:02 <lambdabot> I saw sorear leaving #haskell 12h 48m 14s ago, and .
11:22:06 <Syzygy-> Yeah, that'd probably be it.
11:22:13 <dpiponi> Syzygy-: It is surprising that we don't see more mathematics in Haskell around the web.
11:22:13 <Syzygy-> Probably should add some next if /whatever/
11:22:20 <Syzygy-> dpiponi: Agreed. Deeply so.
11:23:25 <dpiponi> Syzygy-: I know a lot of people use things like gap and macaulay for specialised tasks . But for general purpose mathematical programming Haskell is hard to beat
11:23:29 <glguy> Syzygy-: what is Perl for: if $1 isn't empty, then push @commands, (split / /, $1);
11:24:12 <Syzygy-> next if $1 == ""; push ... ; (I guess. I'm really no guru)
11:24:25 <glguy> I know zero perl
11:24:52 <Syzygy-> dpiponi: I end up using gap for my A_oo-stuff. Mainly because I started talking to the people who build GAP and the package I'll be using, and got explanations from them.
11:25:07 <Syzygy-> That way I won't have to rebuild GAP in toto in Haskell before I can start working on my thesis research...
11:25:22 <Syzygy-> But I was very seriously considering doing just that for quite a while.
11:25:49 <dpiponi> Syzygy-: I wonder how hard it would be to wrap the underlying GAP libraries as Haskell functions
11:26:25 <Syzygy-> Probably not impossible. But we'd need well thought through data types on the Haskell end to make sure everything makes good sense.
11:26:48 <momo-17-boy> hello
11:27:27 <malsyned> push @commands, split( / /, $1) if $1;
11:27:51 <dpiponi> Syzygy-: Yeah. Sometimes you really want dependent types.
11:28:05 <Syzygy-> malsyned: Thanks!!
11:28:07 <malsyned> if $1 ne "" is actually better.
11:28:18 <dpiponi> Syszygy-: Like I'd like to be able to say that the type of x is Q[sqrt(3)], say
11:28:38 <malsyned> I think if $1 = "0", perl's weak typing will bite you in the ass with my first try.
11:28:58 <malsyned> Syzygy-: no problem.  Know anything about Parsec?
11:29:32 <Syzygy-> Hmmmm. That didn't take well. All of a sudden I can't complete at all.
11:29:43 <Syzygy-> Oh. Wait. Darn.
11:30:25 <Syzygy-> Doesn't help with @<tab> though.
11:30:43 <glguy> :(
11:31:15 <Syzygy-> malsyned: Alas, no.
11:31:22 <glguy> Syzygy-: do you need to reload irssi
11:31:28 <glguy> Syzygy-: or does the script clear @commands
11:31:45 <Syzygy-> malsyned: How do I throw out all "" and "[:whitespace:]" from an array?
11:31:46 <malsyned> Syzygy-: ok, np.  thanks.
11:31:53 <Syzygy-> glguy: I should suppose that it clears things out.
11:32:46 <malsyned> Syzygy-: do you want to throw out a single character of whitespace, or any number of whitespace characters?
11:32:55 <glguy>  foreach my $row (split /\n/, $cresp->content) {
11:32:55 <glguy>   $row =~ /.*provides:(.*)/;
11:32:55 <glguy>   push @commands, (split / /, $1) if $1;
11:33:04 <glguy> we don't want to add lines that fail the regex
11:33:16 <malsyned> grep { /^\s*/ } @array
11:33:21 <Syzygy-> And we also don't want to add non-words from the part that gets matched in $1.
11:34:28 <malsyned> er, @array = grep { /^\s*/ } @array;
11:35:06 <malsyned> that will remove all whitespace-only or null strings from an array.
11:35:22 <Syzygy-> Are the { } relaly necessary?
11:35:49 <malsyned> I forget.  I think they're part of grep's syntax, but it may have two syntaxen.  you know perl.
11:35:53 <newsham> if($row =~ /.*provides:(.*)/) { push @commands, (split / /, $1); }
11:35:59 <malsyned> you're right, the brackets aren't necessary.
11:36:08 <malsyned> grep(/^\s*/, @array)
11:36:17 <glguy> I'd be surprised if there wasn't a one-liner in perl for: gives me a list of all the words on each line after "provides:"
11:36:18 <malsyned> (the parens probably aren't necessary either.)
11:36:21 <newsham> you can test that the match succeeded.
11:36:42 <malsyned> glguy: there's a one-liner in awk for it
11:36:50 <newsham> you're grokkng cabals in perl?
11:36:53 <Syzygy-> malsyned: We're scripting irssi though...
11:37:01 <glguy> newsham: http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:37:03 <Syzygy-> newsham: No, the lambdabot COMMANDS file
11:37:10 <glguy> newsham: processing that so that we can tab complete them in irssi
11:37:13 <malsyned> so much for that plan, then.  what exactly are you guys trying to accomplish?  like, what's the ultimate goal?
11:37:24 <Syzygy-> malsyned: @ba<tab> => @babel
11:37:30 <Syzygy-> We're almost there - the script works mainly.
11:37:37 <Syzygy-> But @<tab> behaves weirdly.
11:37:42 <complaisant> ?paste
11:37:42 <lambdabot> http://paste.lisp.org/new/haskell
11:37:44 <newsham> what does your output need to be?
11:37:46 <glguy> because of the lines without commands
11:38:00 <glguy> newsham: whatever push creates, we need one of those full of commands
11:38:02 <Syzygy-> newsham: Tabcompletion code for irssi's tabcompleter matching on the lambdabot commands.
11:38:15 <Syzygy-> glguy: An array. :P
11:38:21 <newsham> curl http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS|sed 's/.*provides: //g') ?
11:38:42 <pejo> glguy, while(<>) { if (/^provides:(.*)/) { print "$1"; } }
11:38:49 <Syzygy-> newsham: Command line is not a perfect match, since irssi has an embedded perl interpreter.
11:39:16 <Syzygy-> pejo: That's what we're matching on now, but we need each command alone in a string in our array.
11:39:24 <lisppaste2> complaisant pasted "wxHaskell" at http://paste.lisp.org/display/34910
11:39:54 <newsham> append your list with split(/ /, $1)
11:40:18 <Willem> i notice with hugs i do not have to load the file every time
11:40:38 <Syzygy-> newsham: We now use
11:40:39 <Syzygy->  foreach my $row (split /\n/, $cresp->content) {
11:40:39 <Syzygy->   $row =~ /.*provides:(.*)/;
11:40:39 <Syzygy->   push @commands, (split / /, $1) if $1 ne "";
11:40:52 <glguy> Syzygy-: I fixed it
11:40:55 <Willem> when i change a function, and save the file and call the function again, the new version runs.
11:40:56 <Syzygy-> glguy: Do tell!
11:40:57 <glguy> $row =~ /.*provides: (.*)/;
11:41:00 <Syzygy-> Ah.
11:41:01 <glguy> space after :
11:41:09 <newsham> if($row =~ /.*provides:(.*)/) { push @commands, (split / /, $1); }
11:41:12 <glguy>  foreach my $row (split /\n/, $cresp->content) {
11:41:12 <glguy>   $row =~ /.*provides: (.*)/;
11:41:12 <glguy>   push @commands, (split / /, $1) if $1;
11:42:04 <Willem> does this behaviour work with main only?
11:42:42 <xic> how can i transfer the contents of a file directly to a Handle?
11:42:45 <Syzygy-> Mmmmmmmm. This script is funky!
11:42:59 <newsham> xic: what handle?
11:43:11 <glguy> Syzygy-: I'm also going to add ? support, since it's my prefix of choice ;)
11:43:24 <Syzygy-> glguy: Go ahead.
11:43:33 <xic> newsham: Handle from Network.accept
11:43:34 <Syzygy-> It should be reasonably easy anyway. :P
11:43:55 <malsyned> Syzygy-: you got it to work while I wasn't looking?
11:44:08 <Syzygy-> malsyned: glguy did.
11:44:26 <Syzygy-> For someone who has never seen perl before, he's remarkably good at debugging. :P
11:45:43 <newsham> xic: read contents from one handle write to another handle
11:45:49 <newsham> lambdabot needs farberisms: http://www.cs.arizona.edu/icon/oddsends/farber.htm
11:45:51 <malsyned> excellent.  That's a rare gift.  Most people I know, even people (like me) used to have had perl as a full-time job, can't come back up to speed very quickly.  Perl's got too many special cases.  It's nothing like riding a bike.
11:45:51 <lambdabot> Title: Farberisms
11:45:54 <newsham> ?farberism  anyone?
11:45:54 <lambdabot> Unknown command, try @list
11:46:09 <glguy> Syzygy-: done :)
11:46:14 <glguy> change:
11:46:17 <glguy>  return if $word !~ /([\@\?]).*/;
11:46:20 <glguy>  my $prefix = $1;
11:46:25 <glguy>  @matches = map { sprintf "%s%s", $prefix, $_ } @matches;
11:46:26 <newsham> malsyned: but you surely remember where to look for quick answers
11:46:28 <glguy> those lines i suppose
11:46:28 <pejo> glguy, are you reading a file and just want to find the provides:-line with that foreach-statement?
11:46:38 <glguy> pejo: yeah, but that is working now
11:46:43 <xic> newsham: but won't that read the entire contents of the file into memory, and only then start writing it to the handle?
11:46:48 <Syzygy-> newsham: Because lambdabot needs to be a generic fortune cookie monger? :P
11:47:30 <newsham> xic: you can loop over chunks of reads and writes.
11:47:50 <Syzygy-> glguy: Distribution point updated.
11:47:52 <newsham> @farberism
11:47:53 <lambdabot> Unknown command, try @list
11:48:28 <xic> newsham: hm... how do i know what chunk size to use?
11:48:40 <Willem> anyone wanna know what fibonacci 800 is ;-)
11:48:55 <newsham> xic: you would pick one.  for correctness, any will do.
11:49:07 <glguy> > let fibs = 1 : 1 : (zipWith (+) `ap` tail) fibs in fibs !! 800
11:49:09 <lambdabot>  1121023813016570197539221312040081070329432498024398917379911096096424176870...
11:49:10 <newsham> a typical guess for performance is 4096
11:49:18 <Syzygy-> glguy: Pfah! I was gonna do that!
11:49:32 <Syzygy-> Though, admittedly, not with `ap`.
11:49:41 <glguy> Syzygy-: 800th fib number is CTL+META+800 for me
11:49:44 <glguy> no sweat ;)
11:49:53 <Syzygy-> @type ap
11:49:55 <glguy> zero indexed, of course
11:49:55 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m (a -> b) -> m a -> m b
11:50:12 <xic> newsham: ok cool thanks
11:50:31 <Syzygy-> Why does that work with the `ap`?
11:50:36 <glguy> Willem: what is it?
11:50:37 <Syzygy-> What monad is it?
11:50:40 <glguy> Syzygy-: in ((->)e)
11:50:41 <resiak> @src ap
11:50:42 <lambdabot> ap = liftM2 id
11:50:44 <Hunter_wow> lamdba topic
11:50:46 <glguy> ap f g x = f x (g x)
11:50:55 <Hunter_wow> !topic
11:51:00 <Syzygy-> glguy: Ah.
11:51:00 <newsham> > (+) `ap` 3 2
11:51:02 <lambdabot>   add an instance declaration for (Num (t -> a -> a))
11:51:03 <glguy> ?src ((->)e) ap
11:51:03 <lambdabot> Source not found. I feel much better now.
11:51:12 <glguy> ?src Reader ap
11:51:12 <lambdabot> Source not found. You speak an infinite deal of nothing
11:51:19 <glguy> ?src Reader liftM2
11:51:20 <lambdabot> Source not found. You speak an infinite deal of nothing
11:51:22 <newsham> > (+) `ap` (+ 1) 2
11:51:23 <lambdabot>   add an instance declaration for (Num (a -> a))
11:51:25 <glguy> ?src liftM2
11:51:26 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
11:51:43 <glguy> ?. djinn type flip liftM2 id
11:51:43 <Willem> i disagrre with glguy
11:51:45 <lambdabot> f a b c = a c (b c)
11:51:51 <Hunter_wow> ./paste
11:51:52 <Willem> 69283081864224717136290077681328518273399124385204820718966040597691435587278383112277161967532530675374170857404743017623467220361778016172106855838975759985190398725
11:51:54 <glguy> Willem: you wanted the one before?
11:51:55 <Hunter_wow> =?
11:52:01 <glguy> > let fibs = 1 : 1 : (zipWith (+) `ap` tail) fibs in fibs !! 799
11:52:03 <lambdabot>  6928308186422471713629007768132851827339912438520482071896604059769143558727...
11:52:24 <Willem> ah ok
11:52:36 <glguy> lisppaste2: url
11:52:37 <lisppaste2> To use the lisppaste bot, visit http://paste.lisp.org/new/haskell and enter your paste.
11:52:52 <newsham> ?type ((+) `ap` (+ 1)
11:52:54 <lambdabot> parse error (possibly incorrect indentation)
11:52:57 <newsham> ?type ((+) `ap` (+ 1))
11:52:59 <lambdabot> forall a. (Num a) => a -> a
11:53:03 <newsham> ?type ((+) `ap` (+ 1)) 2
11:53:05 <lambdabot> forall a. (Num a) => a
11:53:10 <newsham> > ((+) `ap` (+ 1)) 2
11:53:12 <lambdabot>  5
11:53:23 <newsham> > ((+) `ap` (* 3)) 2
11:53:25 <lambdabot>  8
11:53:32 <newsham> > (2*3) + 2
11:53:34 <lambdabot>  8
11:53:40 <glguy> > (,) `ap` succ $ 7
11:53:42 <lambdabot>  (7,8)
11:53:58 <glguy> > liftM2 (,) pred succ 7
11:54:00 <lambdabot>  (6,8)
11:54:11 <Syzygy-> > succ `ap` (,) $ 7
11:54:12 <lambdabot>      Occurs check: cannot construct the infinite type: t = ((b1 -> t) -> b, b...
11:54:15 <glguy> > (,) =<< succ $ 7
11:54:17 <lambdabot>  (8,7)
11:55:00 <lisppaste2> Hunter_wow pasted "lookup" at http://paste.lisp.org/display/34913
11:55:45 <glguy> ?type enc xs (y:ys) = [fromJust (lookup xs n) | n <- xs]
11:55:47 <lambdabot> parse error on input `='
11:55:54 <glguy> ?type \ xs (y:ys) -> [fromJust (lookup xs n) | n <- xs]
11:55:56 <lambdabot>     Occurs check: cannot construct the infinite type: a = [([a], b)]
11:55:57 <lambdabot>       Expected type: [([a], b)]
11:56:23 <Willem> how can i time a function in hugs?
11:56:47 <glguy> Hunter_wow: you are calling lookup on a list
11:56:55 <glguy> so that list must be [(a,b)]
11:57:00 <pejo> glguy, while (<FILEHANDLE>) { if (regex) { ..}} would probably be a more idiomatic way in perl. (Sort of late reply, sorry).
11:57:02 <glguy> but you are looking up with that list
11:57:12 <glguy> Hunter_wow: did you mean to use ys?
11:57:14 <Syzygy-> pejo: We don't have a file though.
11:57:21 <Syzygy-> Not in the code discussed earlier.
11:57:31 <glguy> so, while <>
11:57:43 <Syzygy-> glguy: That supposes that we work with STDIN.
11:57:47 <glguy> OH
11:57:49 <Hunter_wow> whant to use it on the xs tuple
11:57:57 <Syzygy-> We were, however, working with a string, and thus the <> idiom won't work.
11:58:02 <pejo> Syz, or the parameter sent to the script, or similar.
11:58:08 <glguy> Hunter_wow: you can't lookup in an association list, with elements from one directly
11:58:14 <Syzygy-> pejo: Still no deal, since we have the data in a string.
11:58:15 <glguy> Hunter_wow: that doesnt' make sense, do you know what lookup does?
11:58:30 <pejo> Yeah, for the string it won't help. Silly format. :-)
11:58:32 <emu> Willem: :set +s, show # of reductions
11:58:40 <glguy> > 5 `lookup` [(1,'a'),(5,'b'),(10,'c')]
11:58:41 <lambdabot>  Just 'b'
11:58:44 <emu> not quite timing though :/
11:58:46 <Syzygy-> pejo: If we only had HTTP-fs it wouldn't be a problem. :P
11:59:07 <glguy> @matches = map { sprintf "%s%s", $prefix, $_ } @matches;   -- is there a better way to write this
11:59:07 <lambdabot> Unknown command, try @list
11:59:11 <glguy> without sprintf maybe?
11:59:11 <emu> ghci's :set +s will show timing
11:59:33 <Syzygy-> Probably as $prefix+$_ or something like that. Can't remember what string concatenation is in perl.
11:59:36 <wolverian> glguy, map { "%prefix$_" } @matches
11:59:39 <wolverian> er
11:59:42 <wolverian> s/\%/$/
12:00:05 <Syzygy-> I used sprintf back in the time where I knew what I wanted to prepend, and didn't have it stored off in a string...
12:00:22 <wolverian> or $prefix . $_
12:00:31 <Syzygy-> .
12:00:33 <Syzygy-> Right.
12:00:43 <wolverian> I just like using quotes, since it shows "this is a string!"
12:01:07 <Hunter_wow> glguy enc xs ys = [fromJust (lookup n xs) | n <- ys]     -> error: [[Char]] dose not match String
12:01:28 <Syzygy-> Fixed on my side.
12:01:31 <glguy> Hunter_wow: right, you are gettign a list, one for each element in ys
12:01:54 <glguy> > [n | n <- [1,2,3]]
12:01:55 <lambdabot>  [1,2,3]
12:02:00 <Hunter_wow> concat
12:02:46 <Hunter_wow> glguy yea, it works now, thanks!!
12:02:48 <glguy> enc xs ys = fromJust . (`lookup` xs) =<< ys
12:03:07 <glguy> enc xs = (fromJust . (`lookup` xs) =<<)
12:04:25 <glguy> ?type (=<<) . ((fromJust .) . flip lookup)
12:04:27 <lambdabot> forall (m :: * -> *) b a. (Monad m, Eq a) => [(a, m b)] -> m a -> m b
12:05:43 <glguy> > let demo = (=<<) . ((fromJust .) . flip lookup) in demo [('1',"one"),('2',"two")] "1221"
12:05:45 <lambdabot>  "onetwotwoone"
12:06:34 <glguy> ew, one of those () is unnecessary ;)  -- (=<<) . (fromJust .) . flip lookup
12:09:10 <glguy> ?. djinn type concatMap . (fromJust .) . flip lookup
12:09:12 <lambdabot> Cannot parse command
12:09:40 <zeeeeee> i seek advice on how to write my vty/curses app framework: i want to allow apps to install their own key handlers to be called by the main event loop. does that mean the handler should be Key -> IO () for maximum flexibility?
12:12:43 <zeeeeee> even ignoring the IO question, i'm not sure i'm taking the right approach so far - my app's whole state is one gigantic data structure, and the event handler currently is Key -> AppState -> AppState (each keypress results in an updated app state). i'm growing concerned about the performance or haskell-ness of this approach.
12:13:34 <zeeeeee> (this AppState, after being updated and remembered, is then passed onto a rendering function that draws it onto the screen)
12:14:01 <velco> internal error: evacuate: strange closure type 18016
12:14:05 <velco> ugh ...
12:14:18 <Cale> velco: looks like a GHC bug
12:14:30 <velco> yep
12:14:30 <Cale> zeeeeee: hmm, this is a framework for general apps?
12:14:44 <zeeeeee> Cale: yeah
12:16:06 <glguy> Syzygy-: you should @where+ your script
12:16:18 <zeeeeee> i guess the first question concerns types mostly, and the second concerns performance/state
12:17:15 <glguy> In perl, how does one sort an array?
12:17:52 <pejo> glguy, @articles = sort @files?
12:17:58 <astrolabe> Anyone know how the hackathon is going?
12:18:02 <glguy> oh, simple enough
12:18:03 <Cale> Key -> IO () doesn't sound like a terrible idea. I'm not completely sure how your framework looks though. How do you decide which thing handles which keypresses?
12:18:22 <velco> I get three different errors ...
12:18:23 <pejo> astrolabe, dons has some information on his blog, among with some pictures.
12:18:37 <astrolabe> pejo: thanks
12:19:30 <glguy> Syzygy-: @commands = sort @commands; -- I added that to the lambdabot-complete.pl
12:23:05 <zeeeeee> Cale: yeah, that's where things get more complicated. i have a tree of widgets that each can have a key handler, and there's a notion of 'focus'. there's also a top-level key handler. when a key is pressed, the key handler of the widget with focus is tried - if it doesn't catch this key, then try its parent's handler.
12:23:42 <zeeeeee> currently, everything is just lumped together in a gigantic AppState, including my application state, my widgets' states, etc.
12:23:44 <vincenz> @join #haskell.dut
12:24:33 <zeeeeee> i want to decouple them, but i'm not even sure this is possible due to haskell's type system
12:25:19 <mahogny> zeeeeee, I think it boils down to if you want to do a traditional GUI or a functional GUI. if you choose the former then I would expect a lot of IO everywhere
12:25:22 <zeeeeee> it means 2 things - i either have to resort to uglier measures, or i'm not being haskell-ish enough, with all this state-changing
12:26:11 <mahogny> zeeeeee, nothing stops you from making your own monad and then lifting though
12:26:19 <zeeeeee> mahogny: functional, but i've read up on these, and they don't deal with actually implementing the GUI system
12:26:31 <mahogny> might be faster with your own monad
12:26:38 <mahogny> but I'm not a speed guru when it comes to haskell
12:26:50 <zeeeeee> mahogny: what i mean is, they always built on top of an existing GUI system
12:27:05 <Syzygy-> @where+ lambdabot-complete http://mikael.johanssons.org/irssi/lambdabot-complete.pl
12:27:05 <lambdabot> Done.
12:27:21 <mahogny> well, I'm not too fond about these functional GUIs anyway. they seem to run into situations where they are hard to use
12:27:53 <therp> who remembers the Liskell thing I talked about last month? :>
12:28:04 <mahogny> someone did and asked about it
12:28:10 <mahogny> forgot who
12:28:15 <Syzygy-> @where lambdabot-complete
12:28:16 <lambdabot> http://mikael.johanssons.org/irssi/lambdabot-complete.pl
12:28:20 <Syzygy-> Hah!
12:28:30 <Syzygy-> glguy: There we go.
12:29:54 <Willem> in hugs i get this error
12:29:58 <Willem> ERROR file:.\First.hs:24 - Haskell 98 does not support extensible records
12:29:59 <Willem> ERROR - Hugs.Trex.insertField not in scope
12:30:25 <glguy> Syzygy-: good deal :)
12:30:30 <Willem> could be related to import IO in my code?
12:31:25 <xic> do you guys think that it's a design flaw of STM that you can only do atomic transactions as IO actions?
12:31:26 <malsyned> anybody in the room know their way around Parsec?
12:32:12 <bd_> xic: It's necessary; there's no other way to have a shared state to work on
12:32:13 <glguy> just ask your question
12:32:13 <Syzygy-> Is there some way to list all wheres that have been assigned to the bot?
12:32:27 <glguy> Syzygy-: look in the code?
12:32:30 <bd_> xic: If you were using ST, each thread would have an independent state, so there'd be no need for transactions
12:32:52 <xic> bd_: hm... i guess you are right... i will have to think about this a bit more
12:32:53 <Syzygy-> @list
12:32:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:33:30 <bd_> xic: remember, if you're not in IO, you're isolated from everything in the environment. this includes other threads
12:33:37 <Syzygy-> Doesn't seem that way. The module only exports @where+, @where and two synonyms to @what
12:33:40 <xic> bd_: right
12:33:42 <Syzygy-> Hrm. @where I meant.
12:33:56 <bd_> xic: and in ST you create an environment but keep it seperate from everything else
12:34:13 <bd_> so since the point of STM is to facilitate interactions between threads
12:34:22 <bd_> it's necessarily a wrapper around IO
12:34:36 <bd_> since you must have access to the real world to communicate between threads
12:34:58 <bd_> [the actual implementation of STM is aware of the IO implementation and does horrible speed hacks, though]
12:35:15 <glguy> http://www.cse.unsw.edu.au/~dons/lambdabot/State/where
12:35:46 <glguy> that's a .gz'd file
12:35:50 <glguy> without the extension
12:36:04 <glguy> with 636 lines in it
12:36:20 <glguy> which is probably why there isn't a command to list them
12:38:11 <glguy> ?yhjulwwiefzojcbxybbruweejw
12:38:12 <lambdabot> Exception: <<loop>>
12:38:25 <Syzygy-> ?yhjulwwiefzojcbxybbruweejw
12:38:26 <lambdabot> "\""
12:38:26 <Syzygy-> Hah1
12:38:31 <Syzygy-> I can write that command now!
12:38:36 <Syzygy-> @yhjulwwiefzojcbxybbruweejw
12:38:37 <lambdabot> "\""
12:38:41 <Syzygy-> Woohoo!
12:38:42 <glguy> ?slap Syzygy-
12:38:43 * lambdabot slaps Syzygy-
12:38:49 <Syzygy-> @slap glguy
12:38:50 * lambdabot slaps glguy
12:38:57 <glguy> @where wrong
12:38:57 <Syzygy-> (5 keypresses, mind you)
12:38:58 <lambdabot> http://adrinael.net/wrong.jpg
12:39:25 <Syzygy-> That's a seriously WEIRD pic.
12:39:59 <notsmack> Syzygy-: i find it terrifying
12:41:06 <Willem> how can i time a function in hugs?what does Unresolved top-level overloading mean?
12:41:11 <mahogny> zeeeeee, btw are you using the new vty lib?
12:41:27 <pbx> Racing == crashing.  It's part of the fun!
12:41:38 <glguy> for the spectator ;)
12:42:03 <mahogny> by symmetry of relation, crashing == Racing? :(
12:42:04 <glguy> someone pasted that into the channel, so I added it to ?where for the cases where someone is doing something (obviously) wrong
12:42:10 <Cale> hmm... if I was going to design a gui, I think I might try something using functional reactive programming.
12:42:13 <Willem> what does "unresolved top-level overloading" mean?
12:42:34 <Cale> Willem: that there are type variables which are never instantiated
12:42:36 <pbx> mahogny: No wonder I'm having a hard time learning Haskell!
12:42:49 <mahogny> :)
12:43:03 <glguy> winhugs ignores the system colors
12:43:04 <newsham> ?seen sorear
12:43:04 <lambdabot> I saw sorear leaving #haskell 14h 9m 19s ago, and .
12:43:09 <newsham> long nap
12:43:12 <glguy> so I have black on black text in winhugs :(
12:43:49 <Cale> Willem: well, :set +s will give you the number of reductions required, which is a good measure of time
12:44:24 <Willem> Cale: i am working through yaht.pdf
12:44:27 <Cale> (also, how many cells were used, and the number of garbage collections, which are not-as-good measures of memory use)
12:44:34 <Cale> Willem: cool
12:44:44 <Willem> cannot get my askForNumbers function to work using hugs
12:44:49 <Cale> okay
12:44:59 <Cale> @paste
12:44:59 <lambdabot> http://paste.lisp.org/new/haskell
12:45:11 <Cale> go there and paste your code and we'll have a look
12:45:22 <Willem> askNumbs = do
12:45:22 <Cale> Or are you using the book's code?
12:45:30 <Willem>     putStrLn "Enter a number (0 to stop)"
12:45:30 <Willem>     num <- getLine
12:45:30 <Willem>     if num == 0 then return []
12:45:30 <Willem>     else do
12:45:30 <Willem>         rest <- askNumbs
12:45:41 <Cale> oh, that site's down
12:45:44 <Cale> okay
12:45:46 <zeeeeee> mahogny: yes
12:45:53 <mahogny> zeeeeee, is it nice?
12:45:56 <zeeeeee> it's great :)
12:46:05 <mahogny> ok. maybe I should use that one later then :)
12:46:20 <therp> cale: have you had a look at the Liskell paper I sent you?
12:46:21 <Willem>         return (num:rest)
12:46:35 <Cale> Willem: one thing I immediately notice is that your if-then-else is misindented. The 'then' and 'else' should always line up, and start on a column later than the 'if'
12:46:46 <Willem> ok
12:47:00 <glguy> num is a string
12:47:03 <Willem> i guess that's it
12:47:06 <glguy> num can't be compared to 0
12:47:06 <psi_> hm
12:47:12 <psi_> i've been able to indent:
12:47:13 <Cale> right, that's the type error
12:47:18 <Cale> also, it's missing the return?
12:47:20 <psi_> if ...
12:47:23 <psi_> then ...
12:47:23 <glguy> readLn
12:47:25 <psi_> else ...
12:47:35 <glguy> \o/
12:47:37 <psi_> i.e, on the same column as if
12:47:42 <Cale> psi_: yeah, technically you can do that in some places, but in others it breaks
12:47:48 <Cale> (like in the middle of a do-block)
12:47:52 <glguy> ?where wrong
12:47:52 <lambdabot> http://adrinael.net/wrong.jpg
12:48:03 <psi_> i see
12:48:20 <psi_> heh
12:48:24 <Willem> Cale: it still does not work
12:48:46 <Willem> here it comes again
12:48:55 <Willem> askNumbs = do
12:48:55 <Willem>     putStrLn "Enter a number (0 to stop)"
12:48:55 <Willem>     num <- getLine
12:48:55 <Willem>     if num == 0
12:48:55 <Willem>         then return []
12:48:57 <Willem>         else do
12:48:58 <Cale> Willem: okay. Switch from getLine to readLn
12:49:00 <Willem>             rest <- askNumbs
12:49:00 <glguy> ?type getLine -- Strigns are not Nubmers
12:49:02 <lambdabot> IO String
12:49:02 <Willem>             return (num:rest)
12:49:06 <psi_> anyway, haskell mode indents on the same column as if
12:49:15 <Cale> or do something like
12:49:21 <Cale> let n = read num
12:49:31 <Cale> after the num <- getLine
12:49:52 <Cale> psi_: haskell-mode's indentation is really odd
12:50:16 <Cale> psi_: I disliked it enough to turn off smart indenting and go with simple instead
12:50:32 <psi_> ah, never tried simple
12:50:50 <Willem> great!
12:51:00 <Willem> the readLn did the trick
12:51:01 <Cale> simple just makes tab indent things normally, but it picks the tab stops contextually
12:51:27 <glguy> Willem: but do you understand why it worked?
12:51:57 <Willem> i guess readLn can read any type?
12:52:03 <Cale> The unresolved top level overloading came from the fact that it tried to treat 0 as a string
12:52:05 <Cale> yeah
12:52:13 <Syzygy-> Willem: Any type implementing Read I'd guess.
12:52:25 <Syzygy-> ?type readLn
12:52:27 <lambdabot> forall a. (Read a) => IO a
12:52:30 <Syzygy-> Yeah.
12:52:42 <glguy> readLn = readIO =<< getLine
12:52:54 <Syzygy-> ?src readIO
12:52:55 <lambdabot> Source not found. Just what do you think you're doing Dave?
12:52:57 <Willem> it is a strange error message
12:53:02 <Cale> Now, you actually can make it so that 0 can be interpreted as a string, by defining an instance of Num for String, but it's probably better not to do that :)
12:54:00 <Cale> The error messages in Haskell can be confusing at first. I find that GHCi's are usually a little bit better than Hugs', though I've noticed Hugs' error messages have been improving.
12:54:37 <Willem> i guess i'll get used to it
12:54:39 <Cale> Lots of the time, they'll use words that you don't know yet. The simplest way to deal with that is to ignore the words, and look at the line numbers. :)
12:54:51 <Willem> i have not downloaded ghc yet
12:54:59 <Cale> (Until you get a sense for what the words mean)
12:55:10 <psi_> Cale, i'm not noticing anything different with simple indent
12:55:17 <Cale> psi_: hmm
12:55:38 <Cale> You'll probably have to press tab at least once.
12:55:43 <psi_> it cycles through different indents, and still picks wrong ones sometimes
12:55:44 <Willem> thanks for all your help guys
12:55:50 <Cale> Willem: no problem
12:55:58 <Cale> Feel free to ask lots of questions :)
12:56:07 <Willem> i hope to be back 2morrow!
12:56:11 <Cale> cool :)
13:08:46 <Cale> dons: What's this polymer tool? I didn't know you were into computational chemistry :)
13:09:05 <vincenz> anyone know a gunnar?
13:09:29 <chessguy> a gunnar?
13:09:34 <vincenz> yeah
13:09:38 <vincenz> active guy on haskell ml
13:09:48 <chessguy> oh
13:13:56 <velco> ugh, when my C programs dump core, all is fine (and normal and expected), I can handle that, but when my haskell one does I'm completely lost.
13:14:20 <Cale> velco: are you using a development ghc?
13:14:55 <glguy> dumping core is a bigger deal in Haskell than C
13:15:30 <Cale> (In particular, it generally means there's a bug in your compiler)
13:15:53 <velco> Cale: nope, 6.6
13:16:09 <Cale> Though apparently by writing bad instances of Ix, you can create problems with unboxed arrays.
13:16:35 <xic> what about unsafe functions?
13:16:37 <psi_> it can also happen when you use the ffi
13:16:47 <Cale> well, yes, of course :)
13:16:55 <glguy> using unsafe functions is a bug in the programmer
13:16:57 <velco> no, no unboxed, no ffi
13:17:04 <velco> no usafe funcs
13:17:20 <Cale> hmm
13:19:25 <glguy> Cale: what features do you find to be particularly compelling in HEAD?
13:20:09 <Cale> http://article.gmane.org/gmane.comp.lang.haskell.glasgow.user/11192
13:20:12 <lambdabot> Title: Gmane -- Mail To News And Back Again, http://tinyurl.com/ycmwu7
13:20:26 <Cale> Number 3 there is a big one.
13:21:32 <Cale> I haven't used 6.7 in a while though. I actually uninstalled my old version of 6.7 the other day because it choked compiling lambdabot. Perhaps I should download a newer one.
13:22:04 <dmhouse> Evening everyone. :)
13:22:10 <glguy> due to a bug in 6.7?
13:22:35 <Cale> Probably, though the version I had was near the beginning of the cycle.
13:22:51 <Cale> (It was the first to have those type system extensions)
13:23:24 <Cale> So I didn't bother filing a report. Might be a good idea to try it with a new version though.
13:33:03 <xic> what's the best way to getFileExtension :: String -> String, like "/dir/file.jpg" -> "jpg"?
13:33:14 <dmhouse> ?where FilePath
13:33:14 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath
13:33:29 <xic> second best way?
13:33:31 <dmhouse> xic: use that. What you request is a non trivial task if you want portability too.
13:33:43 <dmhouse> xic: find everything after the last period?
13:33:51 <xic> dmhouse: yeah
13:34:49 <xic> but with these rules: if there's no period then result in empty string. if a '/' character appears after the last period, then result in empty string.
13:35:10 <dmhouse> xic: seriously, I'd just use FilePath.
13:35:20 <dmhouse> I think it's bundled in the latest GHC anyway.
13:35:33 <dmhouse> Oh, maybe not.
13:38:23 <velco> hmm, apparently I evaluate an expression  ``array (0, -1) []'' in my program, which triggers a crash
13:38:43 <velco> in a standalone testcase it does not crash, though.
13:38:52 <xic> @type array
13:38:54 <lambdabot> forall e i. (Ix i) => (i, i) -> [(i, e)] -> Array i e
13:38:59 <xic> array (0, -1) []
13:39:05 <xic> > array (0, -1) []
13:39:06 <lambdabot>  Add a type signature
13:39:23 <velco> > array (0, -1) [] :: Array Int Int
13:39:23 <Cale> > array (0, -1) [] :: Array (Int, Int) Int
13:39:24 <lambdabot>   add an instance declaration for (Num (Int, Int))
13:39:25 <lambdabot>  array (0,-1) []
13:39:26 <Cale> er
13:39:34 <Cale> > array (0, -1) [] :: UArray Int Int
13:39:36 <lambdabot>   Not in scope: type constructor or class `UArray'
13:40:03 <Cale> hmm
13:41:16 <dmhouse> Are there versions of the monad laws using join and return?
13:41:41 <glguy> > let aux a (b:bs) | b == '.' || b == '/'  = aux bs bs | otherwise = aux a bs; aux a [] = a in aux [] "http://www-users.cs.york.ac.uk/~ndm/projects/libraries.php#filepath"
13:41:43 <lambdabot>  "php#filepath"
13:41:45 <lambdabot> Title: Neil Mitchell - Haskell Libraries, http://tinyurl.com/hagza
13:41:46 <glguy> woot
13:42:15 <Cale> dmhouse: yeah, and fmap
13:42:28 <Cale> Those are actually the classical ones
13:42:57 <Cale> If you look up monad in a text on category theory, you'll get those
13:43:05 <xic> > let aux a (b:bs) | b == '.' || b == '/'  = aux bs bs | otherwise = aux a bs; aux a [] = a in aux [] ""
13:43:06 <lambdabot>  ""
13:43:11 <xic> > let aux a (b:bs) | b == '.' || b == '/'  = aux bs bs | otherwise = aux a bs; aux a [] = a in aux [] "."
13:43:13 <lambdabot>  ""
13:43:28 <glguy> > let aux a (b:bs) = if elem b "./" then bs else a in foldl aux [] "/home/glguy/this.that.theother"
13:43:29 <lambdabot>  Couldn't match `[Char]' against `Char'
13:43:32 <dmhouse> Cale: I tried translating from the Wikipedia page, but what I have seems a bit dubious.
13:43:33 <dmhouse> join . fmap . join = join . join . fmap
13:43:33 <dmhouse> join . fmap . return = join . return . fmap = id
13:43:52 <glguy> > let aux a (b:bs) = if elem b "./" then bs else a in foldl aux [] $ tails "/home/glguy/this.that.theother"
13:43:53 <lambdabot>   Non-exhaustive patterns in function aux
13:43:55 <dmhouse> I think it's the natural transformation notation that's confusing me.
13:44:05 <glguy> > let aux a (b:bs) = if elem b "./" then bs else a in foldl aux [] $ init $  tails "/home/glguy/this.that.theother"
13:44:07 <lambdabot>  "theother"
13:44:08 <Cale> Not quite, you might have misunderstood the notation for natural transformations, yeah
13:44:50 <xic> @type tails
13:44:52 <lambdabot> forall a. [a] -> [[a]]
13:45:16 <Cale> Look at the end of the section "Operations with natural transformations" on the wikipedia page for Natural transformation to see the definitions you're interested in
13:45:50 <dmhouse> Cale: yeah, that's what I was working from, but I need to think about it a bit more./
13:45:57 <glguy> > evalCont . callCC $ \skip -> let aux (b:bs) | elem b "./" = skip (aux bs) | otherwise = liftM (b:) (aux bs) in mapM aux (init (tails "/home/glguy/this.that.theother"))
13:45:58 <lambdabot>      Occurs check: cannot construct the infinite type: a = Cont a b
13:45:58 <lambdabot>       Exp...
13:46:04 <dmhouse> This is a nice exercise for improving my understanding, so don't tell me :)
13:46:27 <glguy> > evalCont . callCC $ \skip -> let aux [] = return []; aux (b:bs) | elem b "./" = skip (aux bs) | otherwise = liftM (b:) (aux bs) in mapM aux (init (tails "/home/glguy/this.that.theother"))
13:46:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = Cont a [a1]
13:46:28 <lambdabot>       ...
13:46:36 <Cale> I believe the first law is   join . map join = join . join
13:46:37 <emu> anyone think of a cool little expression to filter out every other element of a list?
13:46:59 <glguy> > evalCont . callCC $ \skip -> let aux [] = return []; aux (b:bs) | elem b "./" = skip (aux bs) | otherwise = liftM (b:) (aux bs) in mapM_ aux (init (tails "/home/glguy/this.that.theother")) >> undefined
13:47:00 <lambdabot>      Occurs check: cannot construct the infinite type: a = Cont a [a1]
13:47:00 <lambdabot>       ...
13:47:19 <glguy> > evalCont . callCC $ \skip -> let aux [] = return []; aux (b:bs) | elem b "./" = skip =<< aux bs | otherwise = liftM (b:) (aux bs) in mapM_ aux (init (tails "/home/glguy/this.that.theother")) >> undefined
13:47:21 <lambdabot>  "theother"
13:47:22 <dmhouse> emu: there's a lovely little pair of corecursive functions to do that, a great example of laziness.
13:47:24 <glguy> woot
13:47:41 <dmhouse> > let evens (x1:x:xs) =
13:47:42 <lambdabot>  Parse error
13:47:45 <Cale> and the second is  join . map return = join . return = id
13:47:49 <dmhouse> Err... sorry, hit RET too soon..
13:47:56 <Cale> er
13:48:01 <Cale> yes
13:48:50 <dmhouse> > let evens [] = []; evens [x] = [x]; evens (x:_:xs) = x : odds xs; odds [] = []; odds [_] = []; odds (_:x:xs) = x : evens xs in evens [1..10]
13:48:52 <lambdabot>  [1,4,5,8,9]
13:49:01 <dmhouse> Gah, not quite.
13:49:17 <Cale> The polymorphism in Haskell makes the translation of Î¼T the same as the translation of Î¼.
13:49:18 <emu> > let evens [] = []; evens [x] = []; evens (x:y:xs) = x:evens xs in evens [1..10]
13:49:20 <lambdabot>  [1,3,5,7,9]
13:49:25 <therp> http://clemens.endorphin.org/Prolog.lsk
13:49:36 <emu> i was just wondering if it could be done more neatly
13:49:39 <emu> its ok
13:49:42 <dmhouse> Ah, this is it:
13:49:50 <glguy> > let f (x:xs) = x : g xs; f [] = []; g (_:xs) = f xs; g [] = [] in f [1..10]
13:49:52 <lambdabot>  [1,3,5,7,9]
13:50:02 <twanvl> > let evens [] = []; evens [x] = []; evens (x:y:xs) = y:evens xs in evens [1..10]
13:50:04 <lambdabot>  [2,4,6,8,10]
13:50:14 <dmhouse> > let evens [] = []; evens (x:xs) = x : odds xs; odds [] = []; odds (_:xs) = evens xs in evens [1..10]
13:50:15 <lambdabot>  [1,3,5,7,9]
13:50:24 * glguy for the win
13:50:26 <dmhouse> One of the best pieces of code ever :)
13:50:40 <Cale> > let evens = 0 : map (+1) odds; odds = map (+1) evens in odds
13:50:42 <lambdabot>  [1,3,5,7,9,11,13,15,17,19,21,23,25,27,29,31,33,35,37,39,41,43,45,47,49,51,53...
13:51:16 <Cale> That's a different kind of evens and odds though :)
13:51:25 <glguy> > map head $ iterate (drop 2) [1..10]
13:51:26 <lambdabot>  Exception: Prelude.head: empty list
13:51:39 <glguy> > map head $ takeWhile (not . null) $ iterate (drop 2) [1..10]
13:51:41 <lambdabot>  [1,3,5,7,9]
13:51:45 <paolino> woo, much better than Fibonacci, thanks Cale
13:52:04 <ookk> > [2*n + 1 | n <- [0..5]]
13:52:06 <lambdabot>  [1,3,5,7,9,11]
13:52:26 <glguy> > [1,3..10]
13:52:28 <lambdabot>  [1,3,5,7,9]
13:52:41 <Cale> @let unfoldr' p f g = map f . takeWhile p . iterate g
13:52:42 <lambdabot> Defined.
13:52:47 <velco> > let o = 1 : [i + 2 | i <- o] in take 5 o
13:52:48 <lambdabot>  [1,3,5,7,9]
13:52:53 <dmhouse> > let pascal = iterate (\row -> zipWith (+) ([0] ++ row) (row ++ [0])) [1] in pascal !! 4
13:52:55 <lambdabot>  [1,4,6,4,1]
13:53:05 <Cale> > unfoldr' (not . null) head (drop 2) [1..10]
13:53:06 <dmhouse> My favouritest ever snippet of code :)
13:53:06 <lambdabot>  [1,3,5,7,9]
13:53:31 <velco> > let pt = [1] : [1 : (zipWith (+) x (tail x)) ++ [1] | x <- pt] in pt  !! 4
13:53:33 <lambdabot>  [1,4,6,4,1]
13:54:27 <Cale> > let pt = [1] : [1 : (ap (zipWith (+)) tail x) ++ [1] | x <- pt] in pt !! 4
13:54:29 <lambdabot>  [1,4,6,4,1]
13:54:40 <twanvl> > concat . zipWith ($) (cycle [const [],return]) $ [1..10]
13:54:41 <glguy> > let pt = [1] : [1 : zipWith (+) `ap` tail x ++ [1] | x <- pt] in pt  !! 4
13:54:41 <lambdabot>  [2,4,6,8,10]
13:54:42 <lambdabot>  Couldn't match `(->) [b]' against `[]'
13:55:00 <glguy> > let pt = [1] : [1 : zipWith (+) `ap` tail ++ [1] | x <- pt] in pt  !! 4
13:55:01 <lambdabot>  Couldn't match `[]' against `(->) [b]'
13:55:12 <glguy> > let pt = [1] : [1 : (zipWith (+) `ap` tail) x ++ [1] | x <- pt] in pt  !! 4
13:55:13 <lambdabot>  [1,4,6,4,1]
13:55:44 <Cale> > let evens xs = [x | (k,x) <- zip [0..] xs, even k] in evens "hello, world!"
13:55:46 <lambdabot>  "hlo ol!"
13:56:25 <Cale> @let indexFilter p xs = [x | (k,x) <- zip [0..] xs, p k
13:56:26 <lambdabot>  Parse error
13:56:27 <Cale> @let indexFilter p xs = [x | (k,x) <- zip [0..] xs, p k]
13:56:28 <lambdabot> Defined.
13:56:40 <Cale> > indexFilter even [1..10]
13:56:41 <lambdabot>  [1,3,5,7,9]
13:56:47 <Cale> > indexFilter odd [1..10]
13:56:49 <lambdabot>  [2,4,6,8,10]
13:58:30 <glguy> > transpose $ unfoldr' (take 3) (not . null) (drop 3) [1..20]
13:58:31 <lambdabot>  Couldn't match `Bool' against `[a]'
13:58:43 <glguy> > transpose $ unfoldr' (not . null) (take 3) (drop 3) [1..20]
13:58:45 <lambdabot>  [[1,4,7,10,13,16,19],[2,5,8,11,14,17,20],[3,6,9,12,15,18]]
13:59:01 <glguy> > transpose $ unfoldr' (not . null) (take 2) (drop 2) [1..10]
13:59:03 <lambdabot>  [[1,3,5,7,9],[2,4,6,8,10]]
13:59:56 <glguy> > transpose $ unfoldr' (const True) (take 2) (drop 2) [1..10]
14:00:00 <lambdabot> Terminated
14:00:14 <glguy> > head $ transpose $ unfoldr' (const True) (take 2) (drop 2) [1..10]
14:00:19 <lambdabot> Terminated
14:00:23 <glguy> > head $ head $ transpose $ unfoldr' (const True) (take 2) (drop 2) [1..10]
14:00:25 <lambdabot>  1
14:01:37 <e_e_coli> This is good: http://en.wikibooks.org/wiki/Haskell/Understanding_monads
14:01:41 <e_e_coli> thank you, author
14:04:10 <bd_> I found this one ... interesting: http://www.loria.fr/%7Ekow/monads/index.html
14:04:13 <lambdabot> Title: Of monads and spacesuits
14:04:23 <notsmack> is there a way to have ghc or similar desugar a monadic do-block for me?
14:04:24 <bd_> The analogy got a bit tortured when it got to the state monad though >.>
14:04:40 <glguy> notsmack: ?undo
14:05:01 <glguy> ?undo do { x <- a; y <- b x; return y }
14:05:01 <lambdabot> a >>= \ x -> b x >>= \ y -> return y
14:05:09 <glguy> ?. pl undo do { x <- a; y <- b x; return y }
14:05:10 <lambdabot> b =<< a
14:05:10 <notsmack> glguy: wow, perfect
14:05:15 <notsmack> @botsnack
14:05:16 <lambdabot> :)
14:05:54 <glguy> ?. redo . pl undo do { x <- a; y <- b x; return y }
14:05:55 <lambdabot> b =<< a
14:06:00 <glguy> ?. redo undo do { x <- a; y <- b x; return y }
14:06:01 <lambdabot> do { x <- a; y <- b x; return y}
14:08:05 <glguy> ?redo a >>= b
14:08:06 <lambdabot> do { c <- a; b c}
14:08:14 <glguy> ?redo a =<< b
14:08:14 <lambdabot> a =<< b
14:08:18 <glguy> :(
14:09:04 <notsmack> a >>= b == b =<< a?
14:09:08 <glguy> yeah
14:09:21 <notsmack> didn't know that
14:09:37 <glguy> infixr 1 =<<
14:09:40 <glguy> infixl 1 >>=
14:09:55 <glguy> infixl 1 >>
14:09:57 <glguy> but no <<
14:12:05 <glguy> anyone know how to make an arbitrary region clickable like an <a> tag?
14:12:20 <glguy> probably using an a tag and styles
14:12:36 <Masklinn> glguy > yeah usually
14:12:45 <notsmack> yep
14:12:59 <glguy> I just need a big squre, but can't figure out what styles to make that happen
14:13:00 <dmhouse> glguy: you can fake it using region:hover { cursor: pointer } and using javascript.
14:13:02 <Masklinn> glguy > display: block; set with/height, position the link on the page
14:13:12 <dmhouse> glguy: something like display: block would do better, though.
14:13:13 <dmhouse> Yeah.
14:13:34 <dmhouse> Also, position: relative, position: absolute or position: float if you need to position it somewhere weird.
14:13:35 <glguy> i thought that worked in firefox and not IE
14:13:47 <Masklinn> glguy > it works anywhere
14:13:51 <glguy> hmm
14:13:51 <glguy> ok
14:13:53 <glguy> I'll play
14:14:07 <Masklinn> glguy > oh, the hover thing? IE only accepts it on links yeah
14:14:14 <Masklinn> dmhouse > no position: float
14:14:25 <glguy> I mean the links where text isn't
14:14:33 <Masklinn> dmhouse > float is not a position ;) you have float left, right and none though
14:14:42 <Masklinn> glguy ?
14:14:49 <glguy> I'll mock something up and paste it
14:14:56 <dmhouse> Masklinn: sorry, it's been a while since I've done CSS.
14:15:02 <Masklinn> dmhouse > np :p
14:15:33 <Masklinn> glguy > IE has no problem with "empty" links, what it doesn't handle is links without href. Always use anon-empty href of MSIE won't recognize your links as links
14:15:42 <paolino> I have this class.
14:15:47 <paolino> class (Eq v) => Metrics  v where
14:15:47 <paolino>   (-|) :: v -> v -> Float
14:15:47 <paolino> but I want two instances for Float, can I parametrize it in some way for that ?
14:16:07 <dmhouse> paolino: use newtypes.
14:16:49 <paolino> only way ?
14:17:05 <dmhouse> Probably the best way.
14:17:57 <lisppaste2> glguy pasted "well.... that worked" at http://paste.lisp.org/display/34922
14:18:13 <paolino> mmh , it breaks my scheme, if there is another way, I'd like to try it
14:18:14 <chessguy> a ringing endorsement if ever i heard one
14:21:07 <newsham> ?seen sorear
14:21:07 <lambdabot> I saw sorear leaving #haskell 15h 47m 24s ago, and .
14:21:10 <bd_> paolino: if you want two different behaviors for float, you'll need different functions or different types
14:21:14 <bd_> how else can it tell them apart?
14:25:00 <dmhouse> Cale: would http://paste.lisp.org/display/34923#1 be a correct implementation of the HÎ· and Î·H operations?
14:25:51 <paolino> bd_ parametrize the class on a index ?
14:26:16 <bd_> an index? how so? Something like: f 1 x y?
14:26:25 <Cale> dmhouse: yes, modulo the typo :)
14:26:27 <bd_> haskell doesn't currently support dependent types, note
14:26:47 <dmhouse> Cale: great. :)
14:26:54 <dmhouse> Now on to conquer the monad axioms.
14:27:17 <paolino> class (Eq v) => Metrics  s v where
14:27:17 * glguy discovers that his link issue was a z-order issue
14:27:23 <paolino>   (-|) :: v -> v -> Float
14:27:23 <paolino> ??
14:28:21 <glguy> shit
14:28:31 <bd_> paolino: I don't know what you mean by parameterizing the class on an index. Also, the s there isn't bound in any of the type signatures below, haskell will not be able to determine which instance is in use.
14:28:35 <glguy> the arbitary block only works when background-color is set to "not transparent"
14:28:46 <bd_> paolino: How would you expect the syntax for using that operator to work?
14:29:48 * glguy makes silly mistake and solves it
14:30:32 <bd_> paolino: And, why not just add another operator to the typeclass?
14:32:37 <paolino> np, I was curious.
14:33:09 * mahogny is starting to get somewhere on his haskell symbolic math library ^_^
14:33:27 <astrolabe> mahogny: what does it do so far?
14:33:39 <paolino> data MK = Manhattan|Flier
14:33:40 <paolino> instance Metrics Manhattan Point where
14:33:40 <paolino>   (-|) (x1,y1) (x2,y2) = abs (x1 -x2) + abs (y1-y2)
14:33:40 <paolino> I thought something like this.
14:34:21 <mahogny> astrolabe, some simplifications. most of the code is to set up a suitable canonical order over the formulas to simplify the coding of the features I will add now
14:34:54 <astrolabe> Sounds cool
14:35:20 * mahogny will release it under bsd later on
14:36:56 <Excedrin> is there a "natural" way to deal with semi-structured data?
14:37:10 <mahogny> define semi-structured
14:37:32 <mahogny> any data handling is usually on a case-by-case basis if you ask me
14:38:54 <mahogny> Excedrin, actually, the way I see it, there is nothing like semi-structured, only lack of structure. so you grab what you have and make a suitable data structure given the algorithms you plan to apply
14:49:23 <mbishop> Someone suggest some names for my new kitten
14:49:42 <glguy> are you going to let it grow into a full-sized grouchy cat?
14:49:47 <glguy> or just keep it as a kitten?
14:49:59 <glguy> because I was thinking "dogfood"
14:50:06 <glguy> unless it was going to stay a kitten
14:50:08 <mbishop> gonna let it grow :)
14:52:06 <glguy> I loved my girlfriend's kitten
14:52:17 <glguy> but 3 years latter...
14:52:36 <glguy> I taught the cat not to scratch me by tricking it into running into a door
14:53:44 * mbishop whispers to his cat to stay away from glguy
14:54:16 <glguy> you could toss its cat toy down the stairs and it will jingle at the bottom
14:54:29 <mbishop> I don't have stairs
14:54:45 <glguy> so the cat would run down , grab the toy, and continue running into a room after a sharp turn
14:54:54 <glguy> so... close the door, go upstairs, toss the toy
14:54:59 <glguy> run run run bang
14:55:40 <glguy> I'll admit that in hindsight it was mean and I wouldn't do it again
14:57:18 <paolino> @class
14:57:19 <lambdabot> Unknown command, try @list
15:04:38 <paolino> how make data Line = Row|Col isomorpic to Bool ?
15:06:23 <paolino> Row = True
15:06:23 <paolino> Col = False
15:06:23 <paolino> ?
15:09:17 <malsyned> paolino: why make Line isomorphic to Bool?
15:10:35 <paolino> to have not Row = Col
15:13:40 <shapr> mbishop: What about 'kissa' which is Finnish for cat?
15:14:16 <shapr> mbishop: It's advantageous from a usability perspective as well, since cats perceive the SS sound most strongly from humans.
15:14:54 <rahikkala> Also, being a Finnish word it's awesome by definition
15:15:04 <shapr> hyvÃ¤Ã¤!
15:15:09 <bos_> paivaa!
15:15:18 <shapr> bos_: exactly!
15:15:22 <mbishop> kissa? how do you pronounce that? "KISS-UH"?
15:15:27 <shapr> kiss-ah
15:15:43 <shapr> and it's really kiss-sah
15:16:04 <shapr> In general, double consonants in Finnish are each put into their own syllable.
15:16:21 <sorear> @uptiem
15:16:22 <lambdabot> uptime: 11h 51m 15s, longest uptime: 2d 3h 42m 19s
15:17:42 * sorear pokes seen
15:17:45 <shapr> @seen
15:17:46 <lambdabot> Lately, I have seen azmo, benja_, bos_, cale, malsyned, mbishop, paolino, rahikkala, shapr, sorear and svnbot6.
15:18:13 <rahikkala> Hm, typo fixing?
15:18:18 <rahikkala> @unlp id
15:18:19 <lambdabot> Maybe you meant: help undo unpf unpl url
15:18:25 * rahikkala sees
15:18:36 <sorear> levenschtein distance
15:18:55 <sorear> whichever is closest, to a max of 3 edits, but only if unambiguous
15:19:35 <rahikkala> lambdabot++
15:22:28 <emu> where live the character encoding handling functions?
15:23:50 <sorear> scattered across the Internet
15:23:59 <sorear> they don't live in a single library
15:24:17 <sorear> everyone who uses them, copies the files into their own library
15:24:20 <sorear> depressing.
15:25:36 <sorear> http://members.cox.net/stefanor/vty/UTF8.lhs  -- I got this from darcs
15:27:27 <hyrax42> is there some movement to consolidating that stuff somewhere standard?
15:27:32 <scodil> how should I scan a list of a multi-constructor data type for an element made with a certain constructor? like I need to get the first Right value in a list of Eithers
15:27:47 <sorear> hyrax42: I wish
15:27:55 <emu> thanks
15:28:02 <scodil> using " case e of Right -> True ; Left -> False " as a predicate seems clumsy
15:28:20 <hyrax42> you could use either False True
15:28:28 <Cale> either (const True) (const False)
15:28:30 <hyrax42> > either False True $ Right 1
15:28:31 <lambdabot>      Expecting a function type, but found `Bool'
15:28:31 <lambdabot>       Expected type: a -> c
15:28:31 <lambdabot> ...
15:28:34 <hyrax42> oh do'hho
15:28:34 <sorear> scodil: yes, but it can't be done using only parametric polymorphism
15:28:51 <sorear> you need Data.Generics
15:28:54 <hyrax42> hm
15:28:57 <hyrax42> :t either
15:28:59 <lambdabot> forall c b a. (a -> c) -> (b -> c) -> Either a b -> c
15:29:00 <Cale> > either (const False) (const True) (Left 5)
15:29:01 <lambdabot>  False
15:29:05 <Cale> > either (const False) (const True) (Right 5)
15:29:07 <lambdabot>  True
15:29:14 <hyrax42> ah so you had it wrong first tiem Cale
15:29:19 <sorear> > map Data.Generics.Basics.toConstr [Left 'a', Right 4, Left '\BEL']
15:29:20 <lambdabot>   Not in scope: `Data.Generics.Basics.toConstr'
15:29:20 <hyrax42> you threw me off with argument order
15:29:23 <sorear> > map Data.Generic.Basics.toConstr [Left 'a', Right 4, Left '\BEL']
15:29:24 <Cale> I had it backwards relative to his
15:29:25 <lambdabot>   Not in scope: `Data.Generic.Basics.toConstr'
15:29:35 <scodil> ok, stepping back a bit, I've gotten this list (not an Either list) from getOpt. There's two options, one's a string and one's an Int. how can get I get these values out of the list of Options easily?
15:29:49 <sorear> > map Data.Generics.Basics.toConstr [Left 'a', Right 4, Left '\BEL']
15:29:50 <lambdabot>   Not in scope: `Data.Generics.Basics.toConstr'
15:29:55 <sorear> > map toConstr [Left 'a', Right 4, Left '\BEL']
15:29:56 <lambdabot>   Not in scope: `toConstr'
15:30:07 <sorear> What! Dons doesn't import SYB! :)
15:30:09 <scodil> getOpt insists on packaging the options into a multi-constructor data type and returns a list of this type
15:30:20 <Cale> scodil: right
15:30:33 <Cale> scodil: so you pattern match against that to determine which option you have
15:30:39 <sorear> ?index toConstr
15:30:40 <lambdabot> Data.Generics.Basics, Data.Generics
15:31:44 <scodil> right, like "(StringOption s) = find (\o -> case o of (StringOption _) -> True ; _ -> False) options
15:32:00 <scodil> is there an easier way? that doesn't involved two pattern matches?
15:32:19 <scodil> oops there's a maybe in there too
15:32:23 <scodil> which is what gets me
15:32:40 <scodil> because getOpt already handles optional options
15:32:46 <scodil> er, optional flags
15:33:05 <scodil> so I have to put a fromJust in there, which seems wrong
15:33:17 <Cale> OptArg means that the parameter to the option is optional
15:33:20 <Cale> not the option itself
15:33:38 <Cale> ReqArg means that the option requires its parameter
15:34:07 <zeeeeee> is there a tutorial for haxml?
15:35:33 <scodil> the list of options returned by getOpt.. is it in order in which the options were specified? or the order in which they were given on the command line?
15:37:53 <Cale> The order given on the command line, I'm fairly sure.
15:38:05 <ookk> anyone here used Logo? Is there a pattern matching feature in it like haskells "let f (x:xs) x" for instance?
15:39:12 <SamB_XP> heh
15:39:14 <scodil> so I have to use constructors of an ADT in order distinguish between arguments? what was wrong with chars?
15:39:23 <scodil> this seems like a needless use of a haskell feature
15:39:29 <Cale> ookk: I don't think so
15:39:43 <SamB_XP> scodil: ... you can't use Chars?
15:40:04 <Cale> scodil: This sounds like a needless use of the GetOpt library
15:40:11 <ookk> Cale, damn, logo is crappy :P
15:40:18 <Cale> If you only have a few simple parameters, you don't need GetOpt.
15:40:19 <ookk> Cale, wish they would teach haskell instead
15:40:39 <SamB_XP> ookk: ask them to at least get a real lisp, maybe?
15:40:39 <scodil> yeah I guess I don't need to use haskell either, but here I am
15:40:42 <complaisant> what function of wxhaskell creates the menu bar ?
15:40:54 <Cale> I didn't even know there were places that still taught logo.
15:41:10 <sorear> wasn't logo designed as a dumbed-down lisp for kindergarners?  (/me is mostly clueless about such things.)
15:41:14 <ookk> SamB_XP, i will recommend them Haskell for next years course
15:41:20 <Cale> sorear: yes
15:41:23 <ookk> sorear, yeah
15:41:32 <ookk> its so ugly use
15:41:41 <ookk> to use*
15:41:41 <glguy> ?arr
15:41:42 <lambdabot> I want me grog!
15:41:53 <glguy> poke
15:41:54 <glguy> ?seen
15:41:55 <lambdabot> Lately, I have seen arathorn, cale, complaisant, dmq, emu, glguy, hyrax42, khisanth, ookk, samb_xp, scodil, sorear and zeeeeee.
15:42:03 <SamB_XP> seriously, they could have just given us scheme with some turtle stuff!
15:42:04 <sorear> hi!
15:42:04 <glguy> ?losers
15:42:05 <lambdabot> Maximum users seen in #haskell: 315, currently: 291 (92.4%), active: 36 (12.4%)
15:42:17 <complaisant> ?winners
15:42:18 <lambdabot> Unknown command, try @list
15:42:27 <sorear> ?list seen
15:42:28 <lambdabot> seen provides: users seen
15:42:33 * Khisanth does not believe lambdabot
15:42:40 <glguy> ?slap Khisanth
15:42:41 * lambdabot beats up Khisanth
15:42:47 <glguy> lambdabot believes in you
15:42:57 * Khisanth clubs glguy with a baby seal
15:42:59 <ookk> Cale, you wouldnt happen to know how i call a function which i have passed as a paramter in Logo?
15:43:06 <rahikkala> @botsnack
15:43:07 <lambdabot> :)
15:43:16 <glguy> ?yow
15:43:17 <lambdabot> Boys, you have ALL been selected to LEAVE th' PLANET in 15 minutes!!
15:44:06 <hyrax42> ookk: at what level are you being taught logo?
15:44:20 <glguy> ?faq
15:44:21 <lambdabot> The answer is: Yes! Haskell can do that.
15:44:28 <ookk> hyrax42, university
15:44:31 <Cale> ookk: maybe try  apply fn args
15:44:46 <glguy> having autocompleted lambdabot commands helps me find all the commands I didn't know ;)
15:44:52 <sorear> glguy:
15:44:53 <sorear> @list
15:44:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
15:45:04 <glguy> sorear: where do you think that my autocomplete comes from?
15:45:09 <ookk> Cale, damn that is uggly :P
15:45:17 <glguy> @figlet
15:45:18 <lambdabot> usage: figlet <text>.
15:45:26 <sorear> uh, brute force search? :)
15:45:27 <ookk> Cale, does it expect the arguments as a list?
15:45:40 <glguy> sorear: tab-completion Syzygy- wrote the script, I helped edit a bit
15:45:40 <Cale> yes
15:45:46 <bd_> paolino: a bit late but how about manhattanDistance $ pt1 -| pt2 ? Where manhattanDistance takes the result out of a newtype.
15:45:50 <glguy> ?girl19
15:45:51 <lambdabot> nobody can catch me
15:46:05 <ookk> ? help "apply
15:46:06 <ookk> APPLY template inputlist
15:46:16 <ookk> Cale, apparently only works for a template?
15:46:25 <shapr> Where did girl19 start?
15:46:38 <sorear> oh TAB-completetion. now I'm interested.
15:46:54 <sorear> where can I get this?
15:47:05 <glguy> ?where lambdabot-complete
15:47:06 <lambdabot> http://mikael.johanssons.org/irssi/lambdabot-complete.pl
15:47:10 * sorear is interested in making it push-able
15:47:29 * sorear is procrastinating on new mouse batteries...
15:47:29 <glguy> ?id
15:47:49 <shapr> ?ego
15:47:49 <glguy> ?karma-all
15:47:50 <lambdabot> Maybe you meant: echo redo
15:47:50 <Arathorn> hia - does anyone happen to know why judy doesn't compile under g++ (rather than gcc)? (#haskell is the best collection of people likely to know about judy that i can think of :/)
15:47:50 <lambdabot>  "dons"                111
15:47:50 <lambdabot>  "audreyt"              57
15:47:50 <lambdabot>  "lambdabot"            42
15:47:51 <sorear> ?id hello! id! what'ya think it does!
15:47:52 <lambdabot>  "dcoutts"              38
15:47:53 <lambdabot>  "Cale"                 37
15:47:56 <lambdabot> [582 @more lines]
15:47:58 <lambdabot>  hello! id! what'ya think it does!
15:48:01 <shapr> Arathorn: haha
15:48:17 <Arathorn> uh oh :/
15:48:33 <shapr> Arathorn: It's just funny that you would consider #haskell the best collection of people to ask.
15:48:42 <pejo> Arathorn, because c++ isn't C? Could be a dozen of reasons, like using "new" as variable name for example.
15:49:18 <sorear> @more
15:49:30 <glguy> ?v
15:49:31 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:49:33 <sorear> lbcomp was Not Found.
15:49:34 <glguy> ?yhjulwwiefzojcbxybbruweejw
15:49:35 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
15:49:38 <shapr> Man, @more was really fragile.
15:49:48 <sorear> glguy: lambdabot-complete was not found
15:49:51 <sorear> shapr: how so?
15:49:54 <shapr> I wonder if anyone cleaned it up?
15:50:01 <shapr> I wrote @more, and it was not pretty code.
15:50:08 <shapr> But dons probably fixed it long ago.
15:50:21 <glguy> @vera
15:50:26 <glguy> ?help vera
15:50:27 <lambdabot> I perform dictionary lookups via the following 13 commands:
15:50:27 <lambdabot> all-dicts ... Query all databases on dict.org
15:50:27 <lambdabot> devils ...... The Devil's Dictionary
15:50:27 <lambdabot> easton ...... Easton's 1897 Bible Dictionary
15:50:29 <lambdabot> elements .... Elements database
15:50:31 <lambdabot> [9 @more lines]
15:50:49 <sorear> shapr: I've seen the current @more code and it took me over a week to figure out how it could work at all.
15:50:56 <shapr> oh dear
15:51:31 <sorear> do @more twice ... I couldn't figure out how the first didn't trample on the more-state
15:51:38 <sorear> (I have *now*)
15:52:11 <shapr> That may be the code I wrote :-) Like I said, it wasn't pretty.
15:52:17 <sorear> glguy: I got a 404
15:52:34 <glguy> sorear: I can ctcp send it
15:52:37 <glguy> i mean
15:52:38 <glguy> dcc
15:52:55 <sorear> what is this? a patch to lambdabot's offline?
15:53:12 <glguy> ?
15:53:35 <sorear> the tab-completion support.
15:53:55 <sorear> is it a patch that makes lambdabot's readline interface tabcomplete?
15:54:09 <pejo> sorear, it's an irssi script.
15:54:40 <lisppaste2> glguy pasted "lambdabot-complete.pl" at http://paste.lisp.org/display/34931
15:55:35 <sorear> ah, that kind of thing
15:56:53 <zeeeeee> oh, i found a great resource for not just haxml: http://www.cis.upenn.edu/~bcpierce/courses/advprog/schedule.html
15:56:54 <lambdabot> Title: CSE 399: Advanced Programming
15:59:48 <svref> So...my program's been running for 15 minutes now with no new output and slowly ramping up memory (29mb...).  Is it possible there's an infinate loop caused by lazyness?
16:00:03 <svref> Or all those auto-detected somehow.
16:00:11 <Cale> Laziness removes infinite loops, it doesn't tend to create them
16:00:37 <Cale> however, it's still quite possible that there's an infinite loop, or that you're building lots of unnecessary data structures
16:00:49 <metaperl> what is the latest word on automatic parallelisation of Haskell programs?
16:01:14 <sorear> also, if you have an infinite loop, laziness can easily turn constant space loops into memory leaking loops
16:01:41 <Cale> metaperl: http://research.microsoft.com/~simonpj/papers/ndp/ndp.pdf
16:01:52 <svref> Currently any loops are bad loops.  :^(
16:01:54 <Cale> sorear: well, yes
16:02:14 <zeeeeee> Cale: that's only data parallelism
16:02:30 <Cale> sure
16:02:40 <shapr> zeeeeee: low hanging fruit
16:02:44 <zeeeeee> yeah
16:02:45 <Cale> sorear: because parameters won't be forced, so you might be building up large expressions in them
16:02:56 <shapr> afaik, combinators can also be automatically parallelized, but it's not as easy.
16:03:10 <svref> Haskell seems emminiently ||-ible to me... like it was designed for that from the start...why else not having a "pointer-Eq" function?
16:03:13 <zeeeeee> the ghc manuals alluded to parallelism...lemme try to dig it up...
16:03:32 <Cale> svref: referential transparency
16:04:12 <zeeeeee> oh, just a link to http://www.macs.hw.ac.uk/~dsg/gph/
16:04:14 <lambdabot> Title: Glasgow Parallel Haskell
16:04:18 <sorear> haskell can be autoparrallelized, but it's not the default because (I'm told) it's usually a pessimization
16:04:27 <sorear> ?docs Control.Parallel
16:04:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel.html
16:04:29 <svref> Cale: referential transparency in unrelated IMO.
16:04:30 <shapr> I've seen people spell it "illuded" and that makes me want to grind bones in my teeth. I'm so glad people on #haskell can spell.
16:04:51 <sorear> shapr: have you seen @nazi-on?
16:04:54 <Cale> svref: A pointer equality test would break referential transparency pretty hard.
16:04:54 <shapr> svref: It's very related to parallelism.
16:05:25 <zeeeeee> smp == multicore?
16:05:27 <Cale> Probably why Haskell looks like it was designed for parallelism is because it was designed to preserve referential transparency.
16:05:30 <svref> How so?
16:05:31 <shapr> zeeeeee: Mostly, yes.
16:05:43 <zeeeeee> shapr: mostly?
16:05:51 <shapr> zeeeeee: smp is a superset of multicore.
16:05:55 <sjanssen> zeeeeee: symmetrical multi processing
16:05:59 <metaperl> I think prolog is most obviously parallizable
16:06:17 <metaperl> paralyzable?
16:06:20 <metaperl> :)
16:06:24 * shapr can't move!
16:06:24 <sorear> shapr: I added a command to lambdabot a couple days ago which spellchecks everything said in channel.
16:06:25 <metaperl> frozen stiff
16:06:27 <metaperl> lol
16:06:36 <shapr> sorear: cool!
16:06:51 <sorear> have you seen the darcs-graph :)
16:06:53 * metaperl casts a +10 spell of melt on shapr
16:08:50 * shapr blubs!
16:08:59 <shapr> sorear: Yeah, it's amazing.
16:09:06 <shapr> gruÃŸgott jethr0
16:09:17 <metaperl> @google darcs-graph
16:09:18 <lambdabot> http://www.cse.unsw.edu.au/~dons/darcs-graph.html
16:09:19 <lambdabot> Title: darcs-graph : graph commit activity of darcs repositories
16:10:53 <shapr> metaperl: The graph here - http://www.cse.unsw.edu.au/~dons/lambdabot.html
16:10:54 <lambdabot> Title: lambdabot
16:11:02 <jethr0> helau shapr
16:11:18 <shapr> carnival?
16:11:27 * jethr0 's still trying to wrap his head around the zipper. but at least i've got some kind of clue now
16:11:39 <shapr> jethr0: Zipper is a rubik's cube.
16:11:42 * metaperl sees
16:12:05 <shapr> Think of a Rubik's Cube where only one face is accessible at any time. Maybe a 15-16 puzzle is better?
16:12:28 <shapr> jethr0: So you rotate the data structure around to access any one part.
16:12:40 <jethr0> shapr, yes i've understood that aspect (which is really easy), but i'm still wrangling with where to apply it.
16:12:50 <jethr0> maybe i'll try it out on a simple list or a simple tree
16:13:50 <jethr0> i should perhaps reread that zipper-based filesystem paper to understand what exactly they did
16:14:13 <jethr0> shapr: so, what are you up to these days? any cool haskell projects?
16:14:31 <shapr> Yeah, I'm working on paying Haskell code right now.
16:14:54 <shapr> HAppS LLC
16:15:03 <shapr> But I've had an urge the last few days to write a programming puzzle...
16:15:18 <newsham> sorear: alive?
16:15:22 <shapr> jethr0: The simple puzzle is "given certain descriptions of traffic lights, find the best green waves."
16:15:34 <sorear> Ok. I want to cause a netsplit, and I don't think freenode will help me.  Apt-get has too many choices. any suggestions?
16:15:39 <sorear> newsham: yes.
16:15:50 <sorear> oops forgot a clause
16:15:51 <shapr> A German mathematician girl I dated introduced me to the idea of "green waves" in traffic.
16:16:07 <sorear> I want to set up a private network for lambdabot testing.
16:16:09 <newsham> sorear: irc mainloop -- read something, parse it into an IrcMessage (instance of Message) and pass it off to 'received' ?
16:16:12 <jethr0> shapr: that concept must surely exist in other languages/countries, no?
16:16:15 <svref> So I should analyze an infinate loop by...?...using System.Debug.trace????
16:16:19 <shapr> jethr0: I hadn't heard of it.
16:16:20 <sjanssen> shapr: green waves?
16:16:26 <shapr> jethr0: see?  ;-)
16:16:28 <sorear> newsham: yes.
16:16:33 <newsham> can I just define my own instance of Message, and call received with it everytime I get a message?
16:16:45 <jethr0> sjanssen: the concept of a certain speed at which you will pass all traffic lights when they are green
16:16:45 <shapr> sjanssen: Contiguous wave of green lights, available at a certain speed/route combination.
16:16:49 <newsham> also how does lambdabot communicate back?  I see methods for building commands, but i dont understand where the commands get sent
16:16:57 <sjanssen> shapr: oh, right
16:17:06 * sjanssen always tries to surf the green wave
16:17:08 <shapr> sjanssen: Heard of it before?
16:17:26 <sjanssen> shapr: I haven't heard the term, but I know what you mean
16:17:52 <shapr> Anyway, I think that would be a fun multi-language programming puzzle.
16:18:08 <sjanssen> difficult, I think
16:18:12 <jethr0> http://en.wikipedia.org/wiki/Green_wave
16:18:35 <jethr0> shapr: multi-language?
16:18:50 <newsham> sorear: I have bindings for silclib, but it has its own mainloop in C.  I get callbacks for each message.
16:19:21 <sorear> newsham: irc recieves message. irc passes message to recieved. received passes message to signal callbacks. signal callback in Plugin/Base.hs sends message to appropriate plugin. plugin returns list of strings to base.  base sends replies to Lambdabot.send.  Lambdabot.send sends messages (as IrcMessage monomorphically :() to irc. irc encodes messages and sends down wire.
16:19:26 <shapr> jethr0: Yeah, I was looking at the programming puzzles thread on LtU.
16:19:32 <sorear> oooh, that looks >512
16:19:50 <sorear> newsham: base sends replies to Lambdabot.send.  Lambdabot.send sends messages (as IrcMessage monomorphically :() to irc. irc encodes messages and sends down wire.
16:20:10 <sorear> newsham: shouldn't be a problem, as long as silc is threadsafe
16:20:23 <newsham> so how do I plug into the Lambdabot.send path?
16:20:31 <shapr> sjanssen: Given a grid where all lights are the same distance from each other, and all are timed the same, it should be easy to solve, yeah?
16:20:42 <sorear> newsham: the addServer does the trick
16:21:24 <sorear> I should note that currently all the protocols use the same type, IrcMessage.  proper polymorphic support is ... lacking.
16:22:06 <newsham> hrm.. they peek inside the IrcMessage?  cant just deal with Message?
16:22:14 <sorear> what ircd do people recommend?
16:22:15 <sjanssen> shapr: so you want to detect green waves?  (as opposed to generating light timings that have nice properties)
16:22:18 <newsham> crap.
16:22:31 <shapr> sjanssen: Yeah, though your suggestion sounds like fun too.
16:23:02 <sjanssen> shapr: I have a feeling that generating is way tougher
16:23:17 * sjanssen seems to remember a programming contest problem about this
16:23:35 <sorear> sjanssen: cops&robbers, ICFP '06?
16:23:59 <sorear> not extremely close, but similar enough for memory jogging ...
16:23:59 <sjanssen> sorear: a smaller problem, like an ACM one
16:24:30 <newsham> sorear: http://www.thenewsh.com/%7Enewsham/x/hbot/ is what I have so far.. goofing off with SilcMsg.hs...
16:24:32 <lambdabot> Title: Directory /~newsham/x/hbot/
16:24:44 <newsham> my message format is necessarily much different than IrcMsg
16:25:22 <shapr> sjanssen: Do you think green wave detection is simple enough to be a useful language comparison problem?
16:25:38 <sjanssen> shapr: yes, I think so
16:25:41 <sorear> newsham: btw, you have a 301 loop at thenewsh.com
16:25:59 <sjanssen> shapr: and once you pose the problem formally, I'll likely take a stab at it
16:26:56 <shapr> y0 fixie!
16:31:16 <newsham> are there modules that rely on the internals of IrcMessage?
16:31:26 <newsham> or can I just hack out the current one and call mine IrcMessage?
16:31:54 <sorear> newsham: that might work, but it would make your changes unmergeable.
16:32:20 <newsham> my initial goal is "working",  "clean" may come into play later.
16:32:30 <sorear> there's a very good chance the core will need to be changed to accomodate something as different as sirc.
16:32:36 <newsham> I dont want to hack at every existing module just to get something working
16:32:40 <shapr> It's a needed change. I want a lambdabot that handles IRC, Jabber, and SILC all at the same time!
16:32:44 <sorear> in that case, go ahead.
16:33:28 <sorear> newsham: yeah.  I so loved giving dons an 800-line atomic change to fix the old Nick == String assumption...
16:36:30 <sorear> hi!
16:36:41 <newsham> is there any reason why IrcMessage is passed instead of (Message a) => a other than history?
16:36:48 <newsham> (will that be an easy fix in the future?)
16:37:55 <shapr> \hello
16:38:02 <psnl> hey shapr
16:38:03 <shapr> \yow
16:38:11 <shapr> greetings psnl
16:38:57 <sorear> newsham: no.
16:39:24 <sorear> newsham: Message was an incomplete change in the deep past.
16:39:41 <sorear> newsham: the design space hasn't been completele explored...
16:39:52 <sorear> shapr: stty lcase attack? :)
16:40:25 <shapr> Just trying to figure out if \ would be a good command char.
16:40:26 <jethr0> sorear: is than a euphemism for "hack"?
16:40:30 <shapr> What do you think?
16:40:50 <jethr0> isn't pretty much any non-alpha-numeric char already a command char?
16:40:57 <sorear> reminds me too much of the horror of TeX :)
16:41:13 <shapr> I still haven't gotten into TeX.
16:41:21 <sorear> jethr0: not in all programs simultateously.
16:41:33 <sorear> mail responds to ~, lambdabot doesn't.
16:41:39 <jethr0> ah
16:41:47 <shapr> ~/
16:41:47 <jethr0> what is "mail"?
16:41:48 <shapr> ~?
16:41:55 <shapr> g'day quazi
16:41:57 * jethr0 hasn't been here long enough
16:42:03 * shapr doesn't know either
16:42:06 <emu> sorear: mm, write a better replacement typesetting engine in Haskell: go!
16:42:19 <sorear> jethr0: *faints* mail is The Standard E-Mail Client.
16:42:28 <shapr> oh, that mail
16:42:32 <sorear> jethr0: in the same way ed is the Standard Editor.
16:42:41 <shapr> and that "standard"
16:43:26 <sorear> newsham: <insert darcs plug>
16:43:37 <psnl> s/standard/older than you/
16:43:37 <jethr0> ah "mail"! i lacked some modern UI elements so i switched to a different client
16:44:20 * emu has to use a machine without "mail" or "sendmail" so he uses "emacs" to send mail.
16:44:25 <jethr0> standard == coded for the PDP-5
16:45:10 <sorear> I once had to use a system without vi or emacs ... ed isn't that bad once you've been using it for a week.
16:45:41 <psnl> no nano?
16:45:46 <shapr> sorear: terrifying
16:45:52 <sorear> hadn't heard of it at the time :)
16:45:56 * jethr0 is impressed. i guess you have to keep the code in your head then, as it certainly doesn't appear in the "editor"
16:46:11 * psnl might have cracked and built vim
16:46:19 <shapr> I used to use debug.com for asm programming, when I thought everyone did it that way.
16:46:24 <emu> ed may be preferable to nano
16:46:37 <sorear> I did too ... just not the thinking part :)
16:46:42 <emu> heh, i remember coding with debug.com
16:46:48 <sorear> except mine was a debug.exe
16:46:50 <emu> (when I couldn't get a86 working)
16:46:50 <sorear> DOS 7.1
16:46:54 <augustss> ed is the EDitor!
16:47:11 <sorear> lcc-win32 was such an improvement ...
16:47:26 * jethr0 thinks ed is a cheap compromise. why edit lines when you can edit characters...
16:47:42 <sorear> jethr0: I've written a character editor...
16:47:50 * edwinb was named after an editor
16:47:53 <emu> yes, char ed, for those 0 dimensional monitors
16:48:00 * sorear was once into kernel-writing...
16:48:34 <jethr0> yes, at least you know the code by heart after editing it with a character editor
16:49:06 <jethr0> finding typos and refactoring might be harder though
16:49:21 <emu> it's called "sed", actually
16:49:59 <sorear> cat > a.out  # the true hardcore's editor of choice.  be sure to enable Alt-Decimal, esp. if you have a hex or octal instruction set.
16:50:07 <edwinb> I once managed to break a machine badly enough to have to edit a startup script with sed. I've still no idea how I got into that mess.
16:50:16 <jethr0> sed works on "streams". i was thinking of "ed" working on characters, where you can only see one char at a time
16:50:29 <emu> sure, but "streams" in unix are one octet at a time
16:51:01 <sorear> not one ulimit -p at a time :)
16:51:05 * jethr0 has actually worked with cat and sed to edit files. on some stupid distro cd's that didn't bring ANY editor, and i was too stupid for "ed"
16:51:25 <jethr0> i actually like sed for screen scraping
16:51:31 <edwinb> being too stupid for ed may have been my problem
16:54:02 <sorear> I've done programming with nasm /dev/fd/0 ... remember to type your program twice
16:56:31 <jethr0> sorear: you seem to have done everthing masochistic there is to input programs
16:56:52 <jethr0> why do you need to type it twice onto the floppy? and doesn't that lack a filesystem then?
16:57:08 <Mynstral> My best is that I had a bad optical drive that would only read just enough of a Knoppix cd to boot and load ash with a limited file system mount and so I had to write my own version of ls using echo and globbing to even figure out that nothing else was mounted.
16:58:12 <sorear> I have very little macintosh programming experience.
16:58:53 <sorear> my hello world involved resedit (which for CODE is just a glorified hex editor) and a copy of the Motorola MC68020 Programmer's Reference Manual.
16:59:00 <jethr0> this is turning crazy. how would you write ls without a compiler?
16:59:12 <sorear> I assembled it by hand ...
16:59:28 <jethr0> ah, get out'a here
17:00:09 <Botje> jethr0: echo * can be used as crude alternative to ls
17:00:19 <Botje> since echo is often a shell builtin, as opposed to an external command
17:00:25 <jethr0> k, that i've even done myself
17:00:41 <sorear> I otoh have rewritten ls.
17:01:11 <Mynstral> Mine was a good bit more featureful than just 'echo *' though
17:01:24 <sorear> I was having boot problems (debian + 2.6.18 + lvm = nightmare) and needed to figure out what was going on...
17:01:34 <sorear> without anything beyond the initramfs.
17:01:45 <Mynstral> (it took arguments and if one was a directory it would display its contents!)
17:01:47 <jethr0> sorear: your tales are becoming more and more unbelievable ^_^
17:02:01 <sorear> as you can guess (oh wait I think it may have been an initrd), it was very minimal...
17:02:26 <sorear> fortunately, I could reboot using the old kernel, so I wrote a minimal ls in 50 lines of C.
17:02:40 <sorear> I don't remember thinking to use echo * :)
17:03:01 <Mynstral> "Hmm.. I can't turn on the light... I'll invent the flashlight!"
17:03:43 <sorear> I've always had that problem.
17:04:14 <augustss> When I built my first computer it only had switches.  So I had to use those to enter programs.  And then I wrote a monitor by hand so I could actually use a terminal.
17:04:24 <augustss> (I had built the terminal too.)
17:04:28 <sorear> Like a couple days ago I re-invented Earley's polynomial worst case regex parsing algorithm, when a timeout would have worked even better.
17:05:01 <sorear> probably wasted over an hour
17:06:24 <augustss> It took me a few years of hobby work before I had bootstrapped from using switches to having written a C compiler and OS.
17:07:46 <jethr0> well, at least now you have a firm understanding of the low-level issues *g*
17:08:15 <jethr0> was that pre-GNU-project?
17:08:40 <jethr0> or pre-BSD?
17:08:41 <augustss> oh yes.  about 1977-1980
17:09:20 <augustss> when you could still build a reasonable computer.  I designed and made the circuit boards myself
17:09:37 <sorear> I've designed processors, written emulators, a couple kernels, and two compilers... but I have none of the glue knowledge since no two were related systems :(
17:09:40 * jethr0 is impressed
17:10:17 <augustss> But I bought the CPU, of course.  And the other chips.
17:10:51 <Mynstral> It's not too hard to create a cpu...
17:10:52 <sorear> My father had plans to build a computer from scratch at age 10... alas they were interrupted by his father's fatal heart attack :(
17:11:54 <augustss> Mynstral: it's not hard to design a cpu, but making the silicon is impossible (for a layman)
17:12:16 <Mynstral> augustss: Just because it's an implementation of a design does not mean it's entirely silicon.
17:12:45 <sorear> oh, you weren't gonna buy a bunch of transistors :)
17:13:07 <augustss> no, but in the days i did this you had to buy a cpu to get a reasonable computer.  otherwise it would just be too big
17:13:09 <complaisant> anyone knows a WXhaskell site where there are no broken links of the example code like in the official site..?.. -.-
17:13:42 * jethr0 thinks that timing issues are gonna kill you for any kind of complex cpu you solder yourself
17:15:10 <SamB> jethr0: no. I mean, as long as you don't try to crank the Hz up too high.
17:16:00 * sorear notes lack of an M or even k :)
17:16:05 <augustss> I've used, and repaired, a computer that was built with transistors.  No IC.  I've used it a lot, in fact.
17:16:41 <sorear> hi chessguy!
17:16:49 <SamB> jethr0: anyway, who said it had to be complex?
17:17:13 <sorear> I've seen designs for a 121-tube computer
17:17:17 <jethr0> SamB: it was a contraint
17:23:43 <e_e_coli> ?src concat
17:23:44 <lambdabot> concat = foldr (++) []
17:23:47 <e_e_coli> :)
17:24:33 <e_e_coli> I was doing exercise four in "YOu Could Have Invented Monads". I didn't know about "concat", so I said foldr (++) []
17:24:43 <e_e_coli> so I feel like I'm getting somewhere
17:29:59 <newsham> in lambdabot what is MODULES?
17:30:18 <sorear> ?
17:30:25 <sorear> you mean in the Modules.hs file?
17:30:28 <newsham> see DynModules.hs for example
17:30:38 <newsham> also Modules.hs, yes
17:30:41 <sorear> it's a preprocessor directive
17:30:46 <sorear> see scripts/BotPP
17:31:15 <newsham> textual preprocessor?  or is this TH?
17:31:52 <sorear> textual preprocessor
17:32:23 <newsham> this is fairly confusing.  Not sure where I want to plug my code into this thing
17:32:50 <shapr> Whoa, I just had the most amazing idea for a contract programming business model! The ICFPc model!
17:33:16 <newsham> the IRC module has an "irc-connect" command.  is that used to create the first instance too, or just extra instances?
17:33:27 <sorear> first instance too
17:33:35 <newsham> where is the first instance created?
17:33:45 <sorear> does your pull have an /IRC.hs ?
17:33:51 <newsham> yah
17:34:05 <sorear> there are two separate kinds of IRC connections
17:34:16 <shapr> There are lots of printing companies that make money by being "last minute printers" such that if you need something done from Friday to Monday, you can pay them a big chunk of cash and they'll have it ready. I bet that would make a great business model for programmers too.
17:34:42 <sorear> the core /IRC.hs has zero or one connection, depending on --online.  this is created by LMain.onlineMain
17:35:03 <sorear> the plugin Plugin/IRC.hs has zero or more connections, all created by ?irc-connect.
17:35:17 <newsham> and the "addServer" stuff is responsible for making the connection?
17:35:39 <newsham> I did an update so I have Plugin/IRC.hs
17:35:53 <sorear> addServer just tells the core that there is a connection. it doesn't open sockets or anything like that.
17:35:59 <sorear> shapr: neat idea
17:36:27 <shapr> As long as you had one of the users handy to be part of the ICFPc weekend hack team, I think it'd work out fine.
17:36:35 <newsham> the only instance of "irc-connect" I see in the code is in IRC.hs
17:36:42 <shapr> Especially for people like me who have an attention span that lasts about three days...
17:37:39 <shapr> ibid: Hey, can you add http://japple.blogspot.com/ to Planet.Haskell?
17:37:41 <lambdabot> Title: Everyone Else is Crazy
17:40:01 * shapr hugs Cale 
17:40:11 <Cale> :)
17:40:32 <Cale> I'd just accidentaly closed my IRC client after closing about 20 or so copies of ooimpress.
17:41:14 <shapr> Why did you have so many open?
17:41:25 <shapr> micahcowan: Hiya, are you related to John Cowan?
17:41:41 <Cale> because I was translating the HSOE lecture slides into PDF
17:41:52 <Cale> http://cale.yi.org/index.php/Haskell_School_of_Expression_Lecture_Slides
17:41:54 <lambdabot> Title: Haskell School of Expression Lecture Slides - CaleWiki, http://tinyurl.com/yxmq8r
17:41:58 <micahcowan> shapr, well, my Dad and Grandfather are John Cowan. No relation to the XML and Unicode guy, if that's what you mean.
17:42:11 <micahcowan> (my brother's John Cowan also).
17:42:29 <sorear> I hope they are different John Cowans :)
17:42:37 <micahcowan> sorear, heh :)
17:42:39 <shapr> Oh. Well, I know the XML and Unicode guy, and he hangs out on #haskell sometimes, so I thought I'd ask.
17:42:42 <jethr0> micahcowan: in that case a simple "yes" would have sufficed
17:42:59 <shapr> Though I knew him as the lojban guy for years and years first.
17:43:04 <sorear> which one? would be better :)
17:43:05 <micahcowan> jethr0, well, yeah, but it would've been potentially fairly misleading
17:43:11 <Cale> btw, if anyone knows how to get mediawiki to preview PDF files, that would be neat.
17:43:12 <shapr> jethr0: Aww, I like those sorts of explanations, you know me :-)
17:43:54 <shapr> micahcowan: So, what brings you to #haskell? Lemme guess, you want to know about the Continuation monad?
17:44:09 <shapr> Actually, I have a real guess.. but that one is more fun.
17:44:39 <jethr0> "how do i get the 'String' out of 'IO String'"?
17:44:44 <micahcowan> Actually, I know zilch about haskell, just curious. Thinking about adding it to my toolbelt at some point. Not sure if that'll be soon, but figure I can find some fun facts by lurking.
17:44:59 <sorear> does any one here (other than micahcowan) actually know micahcowan?
17:45:09 <shapr> micahcowan: Ha! Lurking doesn't work so well on #haskell, people tend to get pried out of their shell...
17:45:16 <sorear> we love fun stuff
17:45:24 <zeeeeee> question: can i make a data structure from another library derive a certain class? e.g., haxml's CElem data types don't derive Show, but there's no reason why they can't (they're just trees that terminate in normal Showable types)
17:45:26 * shapr quickly introduces himself
17:45:29 <sorear> we love short obfuscated mind-blowing stuff
17:45:42 <shapr> micahcowan: Hi, I'm Shae Matijs Erisson, purveyor of bright and shiny mind toys!
17:45:48 <micahcowan> Baughn is at least aware of me, from ##c
17:45:56 <jethr0> zeeeeee: instance Show Type where ...
17:46:13 <Baughn> micahcowan: Yeah, but I count as a lurker..
17:46:14 <shapr> sorear: Ok, now that we've introduced ourself to each other, do I count as knowing Micah?
17:46:26 <sorear> I'm Stefan O'Rear, 16 yrs old and desperately looking for a way to shatter my ego :)
17:46:28 <micahcowan> Heh.
17:46:28 <zeeeeee> jethr0: but doesn't that require me to actually write the show code?
17:46:36 <shapr> Whyever would you want to shatter your ego?
17:46:50 <sorear> in a controlled environment :)
17:46:52 <shapr> oh
17:46:55 <shapr> Oh, I can see that.
17:46:58 <shapr> #haskell is a good place for that.
17:47:00 <jethr0> zeeeeee: yes, but that's not so hard. auto-deriving only works on declaration AFAIK
17:47:10 * jethr0 agrees
17:47:19 <zeeeeee> jethr0: well, that was my question :)
17:47:28 <shapr> micahcowan: Anyway, welcome to #haskell. Would you like the short tour?
17:47:35 <zeeeeee> it's not hard but tedious
17:47:36 <mbishop> btw shapr thanks for that suggestion, it's the best one for a cat name so far :)
17:47:41 <jethr0> ?list
17:47:41 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:47:47 <micahcowan> Heh, thanks, but no, I'll just watch for now. :)
17:47:56 <zeeeeee> especially for a whole module of such data types
17:47:59 <shapr> mbishop: Yay! I'm glad you like it :-) I like to combine usability with entertainment.
17:48:13 <shapr> micahcowan: Ok, feel free to ask questions or ask me for the tour at some point.
17:48:31 <micahcowan> Alright, thanks :)
17:48:43 <shapr> micahcowan: Interesting blog
17:49:27 <shapr> I usually google stalk people who visit #haskell, lots of neat people find their way here.
17:50:01 <newsham> stalker!
17:50:13 * shapr stalks newsham 
17:50:22 <shapr> Bah, I've stalked you before.
17:50:23 <SamB> he's using Haskell as a blog directory?
17:50:24 <SamB> er.
17:50:27 <SamB> #haskell?
17:50:35 * SamB should really start pronouncing those # things
17:50:48 <shapr> See, I don't get that. I don't speak things that I type.
17:50:49 <newsham> pound haskell
17:51:04 <shapr> There's no isomorphism between IRC chat and speech for me.
17:51:10 <SamB> well, see, if I don't pronounce it I'm liable to say Haskell instead of #haskell
17:51:15 <shapr> But maybe that's why I get shy in real life, and not on IRC.
17:51:17 <SamB> I mean, even typing!
17:51:47 <shapr> SamB: I understand, but that just doesn't work for me. I first noticed that years ago when Heffalump asked how to pronounce Goerzen, and I realized I'd never wondered.
17:52:01 <SamB> huh
17:52:17 <SamB> well, I hate to rob you of your explanation (okay, so maybe I don't actually), but...
17:52:23 <SamB> I too am shy in real life!
17:52:32 <SamB> and (I hope you noticed) not on IRC
17:52:40 <shapr> I had no idea!
17:52:42 <shapr> Ok, maybe a little.
17:52:57 <shapr> Hey, has anyone checked out the binary hac07 repo?
17:52:59 <SamB> ;-P
17:53:17 <sorear> very, very breifly.
17:54:19 <shapr> I wish Amazon wishlists would let you link the list to your blog as an active bookshelf.
17:54:20 <jethr0> g'night guys
17:54:33 <shapr> g'nite jethr0
17:54:44 <conal> later jethr0
17:55:04 <shapr> Speaking of fun people to stalk, conal has a bunch of neat pix...
17:55:08 * shapr grins
17:55:29 * conal blushes
17:55:51 <conal> i'm also interested in deriving at a a distance.  i have vague memory of there being some movement in that direction.  ring a bell, anyone?
17:56:07 <shapr> conal: Circle Burst is gorgeous.
17:56:21 <conal> shapr, which one is that?
17:56:30 <shapr> conal: Yup, there's TH deriving code, and bringert added support for deriving in a separate module.
17:56:36 <shapr> conal: http://conal.net/Artwork_Photos/
17:56:37 <lambdabot> Title: Conal Elliott Artwork Gallery
17:56:58 <shapr> Do you sell prints of any of those?
17:57:16 <conal> shapr: oh, that one.  it's three feet away from me, on the wall.
17:57:28 <conal> shapr: i don't but i'd sure like to.
17:57:41 <shapr> I love the shading in Circular Collage.
17:58:14 <conal> yeah -- that one was quite an inspiration.  quite a tricky mat job.  it's hanging in the kitchen.
17:58:35 <conal> tricky because the inner annular mat is beveled in both directions.
17:58:42 <shapr> Xorgon Rings is neat, I never expected to see so much complexity from just laying circles over each other like that.
17:59:00 <conal> and the inner mat & outer ones are at different distances from the background.
17:59:33 <conal> i was amazed when the six-pointed stars emerged in that design.
18:00:09 <shapr> I found those from the site of your partner, and I think she said all of those were generated from Pan. Is that right?
18:00:23 <Jessehk> Would it be crazy to ask if Haskell had the ability to get the inverse of a function?
18:00:30 <conal> shapr: yeah, all from Pan.
18:00:43 <conal> pure functional programming (no IO!)
18:01:02 <shapr> Jessehk: There are some arrows that can automatically generate the inverse of a function from the definition of that function.
18:01:08 <augustss> Jessehk: it's never crazy to ask
18:01:28 * shapr checks out the progress of Pajama
18:01:50 <augustss> Jessehk: but in general it's impossible
18:02:01 <Jessehk> hehe
18:02:04 <conal> shapr: there's a simpler xorgon rings picture i like better now: http://conal.net/Pan/Gallery/xorgonRings/with-center/cwdata/g.html .  it's a variant on the "seed of life" sacred geometry design (which i didn't notice at the time i made it).
18:02:07 <shapr> Hm, I may have to install JRE for firefox...
18:02:07 <lambdabot> Title: g.png, http://tinyurl.com/ykxk74
18:02:13 <Jessehk> It would just save me some typing. Not a big deal. :)
18:02:47 <conal> shapr: i haven't worked on pajama lately, but it's still important to me.  i'm going to factor it into pieces and release them.
18:02:48 <shapr> conal: I still like the original Xorgon Rings best out of all the variations linked there.
18:02:55 <conal> :)
18:02:59 <e_e_coli> inv f x = 1 / (f x)     :)
18:03:09 <shapr> It does remind me of Amish good luck symbols though.
18:03:13 <shapr> The last one..
18:03:24 <conal> shapr: the outer mat is fuzzy suede.
18:03:58 <rjbs> pastebot?
18:04:15 <shapr> @paste
18:04:16 <lambdabot> http://paste.lisp.org/new/haskell
18:04:29 <shapr> conal: Wah, this one is eye-searing - http://conal.net/Pan/Gallery/xorgonRings/cwdata/xorgon%20rings%20v.html
18:04:31 <lambdabot> Title: xorgon rings v.jpg, http://tinyurl.com/yftoql
18:04:40 <conal> shapr: setting up a print-selling e-shop would be a neat HAppS project.  I'm eager to try out HAppS, and recently realized that my current work will ti in nicely.
18:05:12 <shapr> Big changes in HAppS the last few days, we'll be releasing HAppS 0.9 as soon as I get the tutorial updated.
18:05:14 <conal> shapr: yeah.  and very fun when interactive.
18:05:29 <shapr> Speaking of which, I should stop chatting and go get food & energy drinks and go on a hack binge.
18:06:01 <conal> shapr: me, too.  i'm preparing a bunch of stuff for release.
18:06:17 <rjbs> That paste page isn't loading.  Here's another: http://nopaste.snit.ch:8001/9153
18:06:22 <shapr> Jessehk: http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
18:06:24 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
18:06:31 <glauber_sp> guys, does anyone work with Haskell and formal methods?
18:06:33 <rjbs> I think I am making a bone-headed mistake, but staring at it isn't helping.  I'd love to be told in what way I am an idiot.
18:06:46 <shapr> glauber_sp: Lots of people, for different values of formal methods.
18:06:55 <Jessehk> shapr: Thanks :) I'll take a look.
18:06:56 <sorear> yow! shapr, how can it handle arr?
18:07:03 <SamB> rjbs: oh, probably the same way as many of us!
18:07:16 <sorear> oh I suppose I could check myself
18:07:22 <shapr> sorear: Go for it!
18:07:33 <SamB> but, non-idiots have no intelligence whatsoever (for instance, trashcans!)
18:07:35 <shapr> rjbs: What's the problem?
18:07:59 <rjbs> My expectation is that "(cap (velocity 40) 59958492) 86400*5" should evaluate to 59958492
18:08:05 <rjbs> as it should never evaluate to greater than 59958492
18:08:22 <glauber_sp> shapr, hum, so algebraic methods and haskell =D
18:08:44 <sorear> rjbs: why do you use f(x) ?
18:08:54 <conal> rjbs: try parenthesizing 86400*5
18:08:54 <sorear> sorry f(t)
18:09:08 <conal> i'm guessing you meant it that way, from your spacing.
18:09:13 <rjbs> sorear: shotgunning in relation to previous problem. removing those parents didn't make a difference, but I'll drop them that way now
18:09:42 <rjbs> (cap (velocity 40) 59958492) (86400*5) => 1.728e7
18:10:13 <rjbs> (Which makes sense, since 1.728e7 is the unbounded velocity after five days at 40m/s/s)
18:11:26 <sorear> I think cap would be better expressed as:
18:11:44 <sorear> cap f c = min c . f
18:12:01 <xpika> @users
18:12:01 <lambdabot> Maximum users seen in #haskell: 315, currently: 276 (87.6%), active: 38 (13.8%)
18:12:56 <conal> rjbs: it's a subtle numeric thing, i think.
18:13:02 <jemfinch> anyone know of a good introductory paper on Haskell's Dynamic type?
18:13:36 <sorear> there is a good spjaper, forgot what it was called
18:13:46 <rjbs> sorear: that doesn't seem to help; :: (Float -> Float) -> Float -> (Float -> Float), with your definition
18:13:50 <shapr> jemfinch: scholar.google.com is probably faster.
18:13:50 <augustss> rjbs: just a general piece of advice: use Double, not Float
18:13:55 <rjbs> augustss: thanks
18:14:14 <jemfinch> shapr: ah, I always forget that that exists.
18:14:14 <shapr> glauber_sp: Have you asked Google?
18:14:17 <ho_ho_ho> no point using double if you don't need the extra size
18:14:20 <sorear> rjbs: that's the same type as your defn
18:14:32 <augustss> @type \ f c -> min c . f
18:14:33 <lambdabot> forall b a. (Ord b) => (a -> b) -> b -> a -> b
18:14:51 <rjbs> Ok.  Still, I get 1.7e7
18:15:30 <sorear> rjbs: because of currying, a -> b -> c and a -> (b -> c) are considered the same type.
18:15:32 <glauber_sp> shapr, not about this =) I just wanted to know which formal method do people from industry (those listed in the Haskell's site) use...
18:15:39 <rjbs> Yeah, that makes sense, of cousre.
18:16:03 <shapr> Oh, commercial Haskellers mostly use HUnit and QuickCheck, though some use Agda and other proof assistants.
18:16:05 <sorear> ?pl \f c -> min c . f
18:16:05 <lambdabot> flip ((.) . min)
18:16:09 <conal> rjbs: i tried it with the parens and got the answer you expected.
18:16:10 <sorear> ?pl \c f -> min c . f
18:16:11 <lambdabot> (.) . min
18:16:21 <rjbs> conal: boggle.  what did you evaluate, exactly?
18:16:27 <augustss> rjbs: what's wrong with 1.7e7?
18:16:33 <rjbs> augustss: It's greater than the cap.
18:16:34 <conal> rjbs: (cap (velocity 40) 5995849) (86400*5)
18:16:55 <conal> rjbs: or cap (velocity 40) 5995849 (86400*5)
18:16:55 <augustss> rjbs: no, it's not
18:17:12 <rjbs> augustss: ...
18:17:17 <rjbs> augustss: Wow, this has all been a typo.
18:17:35 <conal> rjbs: where was the typo?
18:17:44 <sorear> > 5995849 < 1.7e7 -- augustss:
18:17:45 <lambdabot>  True
18:17:56 <rjbs> conal: you are using 5995849; my code said 59958492
18:18:06 <augustss> > 59958492 < 1.7e7
18:18:07 <shapr> glauber_sp: For more information read the QuickCheck papers http://www.cs.chalmers.se/~rjmh/QuickCheck/, and check out http://www.cse.ogi.edu/~hallgren/Programatica/
18:18:07 <lambdabot>  False
18:18:10 <lambdabot> Title: QuickCheck: An Automatic Testing Tool for Haskell
18:18:23 <rjbs> I lost my dot. It was supposed to be 5995849.2
18:18:35 <shapr> glauber_sp: But that's just the beginning, you should also look at Runciman's Smallcheck, and some others that I can't think of off the top of my head...
18:18:41 <conal> rjbs: oops.
18:18:44 <rjbs> Sigh!  Well, thanks.  I learned some things. :)
18:19:26 <shapr> glauber_sp: One good example is that the QuickCheck accessory libs in GHC can be used to check associativity.
18:19:27 <conal> augustss: good catch!  i totally missed that.  the "spaniel" method at work.
18:19:39 <shapr> Warm, brown, and fluffy?
18:19:53 <Nafai> Hey shapr
18:19:59 <shapr> hi Nafai, how's Haskell?
18:20:00 <augustss> well, I have no clue what these mystery numbers are, so i just copy and paste
18:20:36 <conal> shapr: yeah & a debugging methodology
18:20:52 * shapr grins
18:21:11 <glauber_sp> shapr, I'll take a look at the sites and search google =) Thanks
18:21:32 <conal> i can't find the reference now.  it refers to debugging a program by explaining it in terms simple enough for your dog to understand.
18:21:32 <shapr> glauber_sp: Is that what you were asking?
18:21:42 <shapr> conal: http://portal.acm.org/citation.cfm?id=307824.307866 ?
18:21:45 <lambdabot> Title: Literate programming and the &ldquo;Spaniel&ldquo; method
18:21:58 <conal> shapr: probably.  was hoping for a free ref.
18:22:02 <shapr> Me too.
18:22:06 <shapr> I boycott for-pay refs.
18:22:12 <shapr> Mostly unwillingly...
18:22:41 <glauber_sp> shapr, I just want references to read and ppl to talk to. I'll start my master course and I want to study haskell and algebraic methods =)
18:22:48 <SamB> I'm totally willing to not pay ACM to look at things
18:23:04 <SamB> probably because I have essentially no money to pay them?
18:23:07 <Nafai> shapr: Unfortunatel, I haven't done much.  I've read the first few chapters of The Craft of Functional Programming
18:23:19 <glauber_sp> shapr, I've already studied a little of algebraic specification of ADT. Now I'm reading about Category Theory
18:23:23 <SamB> but, even if I did, it would just make me feel so dirty!
18:23:32 <shapr> SamB: That's what I said :-) I effectively boycott things that cost money, because I have none to spare.
18:23:59 <SamB_XP> I'd feel like some kind of buy-out
18:24:07 <shapr> as opposed to being a sell-out?
18:24:32 <SamB_XP> well, see, it isn't selling out if *you* pay *them* money!
18:24:40 <shapr> Good point
18:24:41 <SamB_XP> but it has the same negative stigma
18:24:51 <shapr> glauber_sp: Welcome to the world of spiffy software! I think you'll enjoy it :-)
18:24:59 <shapr> One day I'll get a degree too!
18:25:15 <shapr> I'd be happy with a bachelor's ... maybe I should try to clep out of some courses...
18:25:39 * shapr runs out to grab a sandwich
18:26:01 <SamB_XP> you should get a BS in Dirt
18:26:05 <SamB_XP> see, that spells BSD
18:26:32 <glauber_sp> shapr, thanks =) I enjoied things I've already read. I've written a java program to make an homomorfism from an algebraic specification to a Haskell program. I want to write it now using Haskell itself (happy and alex, I gues)
18:26:40 <mbishop> Cale: thanks for those PDFs :)
18:26:41 <SamB_XP> (you could minor in computational archaeology)
18:26:58 <Cale> mbishop: no problem
18:27:38 <glauber_sp> shapr, I've just finished my bachelor's course in Brazil.
18:27:53 <SamB_XP> glauber_sp: what an interesting major!
18:27:56 <glauber_sp> SamB, BSD? was it for me?
18:28:04 <SamB_XP> glauber_sp: no. shapr ;-)
18:28:18 <glauber_sp> SamB_XP, ha, ok =)
18:30:24 <sorear> ?topic-tell wierd#
18:30:25 <lambdabot> Do not know that channel
18:33:26 <sorear> ?topic-tell weird#
18:33:27 <lambdabot> Do not know that channel
18:34:19 <augustss> glauber_sp: use parsing combinators instead of happy & alex
18:34:44 <augustss> glauber_sp: it's more of haskell experience
18:35:03 <glauber_sp> augustss, parsing combinators? humm... let me google for it =) any references?
18:35:12 <sorear> parsec
18:35:19 <allbery_b> Text.ParserCombinators.Parsec
18:35:24 <SamB_XP> happy and alex can be nice, too, but you don't want to *generate* that
18:35:33 <sorear> ?docs Text.ParserCombinators.Parsec
18:35:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/parsec/Text-ParserCombinators-Parsec.html
18:36:51 <glauber_sp> hum, cool. I guess I need to read All about monads ehhe
18:37:55 <SamB_XP> you really need to learn monads for Happy and Alex, too, though ;-)
18:38:09 <sorear> monads are very cool
18:38:29 <sorear> > transpose $ replicateM 4 " #"
18:38:29 <glauber_sp> SamB_XP, cool. I really want to understand monads in deep
18:38:31 <lambdabot>  ["        ########","    ####    ####","  ##  ##  ##  ##"," # # # # # # # #"]
18:39:03 <sorear> not that useful, but an example of the "neat trick" catagory
18:39:04 <SamB_XP> sorear: what kind of function does that remind me of?
18:39:28 <SamB_XP> has something to do with MPEG 4 part 10, and a particular transform...
18:39:54 <glauber_sp> sorear, interesting =)
18:40:09 <sorear> SamB: DCT, those look like component waves if you squint at them right :)
18:40:22 <SamB_XP> sorear: no, *not* DCT
18:40:27 <SamB_XP> I said part *10*
18:40:38 <sorear> I don't speak MPEG :(
18:40:39 <SamB_XP> DCT is also in probably every other MPEG video type there is
18:40:50 <sorear> wavelet?
18:41:08 <sorear> those aren't wavelets ... wavelets don't repeat
18:42:11 <sorear> > map (\x -> if x then '#' else ' ') $ map and $ replicateM 4 [True,False,True]
18:42:12 <lambdabot>  "# #   # #         # #   # #                           # #   # #         # #...
18:42:50 <SamB_XP> http://en.wikipedia.org/wiki/H.264 -> http://en.wikipedia.org/wiki/Hadamard_transform -> http://en.wikipedia.org/wiki/Walsh_function
18:42:51 <lambdabot> Title: H.264/MPEG-4 AVC - Wikipedia, the free encyclopedia
18:46:53 <glauber_sp> guys, I gotta go now =) I'll read about monads and parsec. Thanks for the suggestion =) See you soon
18:46:58 <sorear> bye
18:47:06 <glauber_sp> bye =)
18:47:11 <glauber_sp> SamB_XP, bye =)
18:50:56 <kaalikas> hmm is it a feature that HGL don't know about bitmaps graphics?
18:51:06 <sorear> ?
18:51:27 <sorear> basically all graphics libs support bitmaps
18:52:03 * sorear doesn't really know about hgl
18:52:21 <kaalikas> hmm how? http://www.haskell.org/ghc/docs/latest/html/libraries/HGL/Graphics-HGL-Draw-Picture.html seems to have some ways to combine different shapes
18:52:24 <lambdabot> http://tinyurl.com/ykxgfx
18:52:36 <kaalikas> but i've not discovered anything more
18:52:58 <kaalikas> i could use X11 lib, but its a bit PITA
18:53:21 <kaalikas> or opengl... although opengl would really overkill
18:53:27 <kaalikas> and X11 is not portable
18:53:53 <sorear> how about Gtk2Hs?
18:54:25 <sorear> Graphics.UI.Gtk.*
18:56:26 <kaalikas> hmm it probably would work. although it does mostly things that i don't need - like all kinds of widgets ;)
18:57:03 <sorear> hehehe
18:57:45 <sorear> I don't know what you are trying to do, but I sometimes find it very helpful to have widgets for input...
18:57:59 <sorear> (on a real-time fractal flame renderer)
18:58:18 <kaalikas> i try to write some little maze game mostly for learning haskell
19:02:02 <laz0r> hi, is the > i have to write in front of every line a hugs specific thing or is it part of the language?
19:02:46 <sorear> what extension does your file have?
19:02:46 <allbery_b> you don't "have" to write it; it's "literate haskell" format
19:03:03 <laz0r> sorear: .lhs
19:03:04 <glguy> .lhs files need > before lines with code
19:03:05 <glguy> .hs do not
19:03:23 <laz0r> ah ok, ah ok, so lhs == literate haskell
19:03:24 <allbery_b> (basically means anything without a leading ">" is a comment / documentation)
19:03:24 <laz0r> ic
19:03:40 <laz0r> yeah, that would have benn my next question
19:03:50 <allbery_b> if you use the .hs extension you can write straight Haskell code
19:04:08 <glguy> with -- marking the rest of a line a comment
19:04:12 <glguy> and {- -} for blocks
19:04:21 <allbery_b> or {- -} for multiline or embedded comments
19:04:34 <glguy> and block comments nest
19:04:43 <glguy> {- {- -} -} is one comment
19:05:10 <allbery_b> there's also an alternate literate format for use with LaTeX:  blocks of code are surrounded by \begin{code} / \end{code} (on their own lines)
19:06:09 <allbery_b> which lets you write pretty documentation in LaTeX format
19:06:30 <laz0r> ok
19:06:48 <laz0r> i just started learning haskell, but ill keep that in mind
19:11:19 <zeeeeee> hi all, is there a date/time parser in haskell? i could only find http://www.cs.chalmers.se/~bringert/darcs/parsedate-2/ which depends on http://www.cs.chalmers.se/~bringert/darcs/time/ which has to be built into the base library
19:11:22 <lambdabot> Title: Index of /~bringert/darcs/parsedate-2
19:12:39 <sorear> > TOD 0 0
19:12:40 <lambdabot>   Not in scope: data constructor `TOD'
19:12:46 <sorear> > System.Time.TOD 0 0
19:12:47 <lambdabot>   Not in scope: data constructor `System.Time.TOD'
19:13:28 <sorear> aw, no Read ClockTime
19:14:18 <zeeeeee> sorear: no :)
19:14:29 <zeeeeee> sorear: but i was hoping for something more flexible
19:22:55 <xpika> when  i do   > (mapM putStrLn. replicate 5) "hello world"   -- i get a bunch of coins ( [(),(),()] )  at the end. how can i avoid this
19:25:28 <jcreigh> mapM_
19:25:41 <xpika> yay
19:25:50 <xpika> @src mapM_
19:25:51 <lambdabot> mapM_ f as = sequence_ (map f as)
19:26:00 <jcreigh> in general, foo_ throws away values.
19:26:01 <xpika> @src sequence_
19:26:02 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
19:26:07 <xpika> @src sequence
19:26:08 <lambdabot> sequence ms = foldr k (return []) ms
19:26:08 <lambdabot>     where
19:26:08 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
19:26:12 <xpika> ok
19:27:25 <sjanssen> @type foldr (liftM2 (:)) (return [])
19:27:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
19:28:09 <sorear> too bad the Bot doesn't have traverse :)
19:31:06 * sjanssen hasn't learned traversable yet
19:39:48 <araujo> helo
19:39:53 <luqui> here's a question:
19:40:03 <luqui> when you say:  id :: a -> a
19:40:13 <araujo> @type id
19:40:15 <lambdabot> forall a. a -> a
19:40:15 <luqui> is the a -> a referring to a *single* type, or a whole set of types
19:40:30 <araujo> check the forall
19:40:40 <luqui> yeah, it looks like a whole set...
19:40:44 <araujo> > id 12343
19:40:45 <lambdabot>  12343
19:40:54 <araujo> > id [1 .. 9]
19:40:55 <lambdabot>  [1,2,3,4,5,6,7,8,9]
19:41:10 <luqui> so is there a whole set of id functions, one that works on each type?
19:41:14 <glguy> forall types a, there exists a function a -> a
19:41:28 <sorear>  the single id function works on all types
19:41:36 <ytinasni> luqui: yes, and they all have the same name :)
19:41:53 <luqui> okay... I'm just trying to get this interpretation straight
19:42:13 <sorear> luqui: if you like concreteness, all types are represented by pointers, and id works on all of them because it doesn't dereference the pointer
19:42:14 <luqui> i.e., the reason that (\f -> (f 42, f "hi")) id doesn't work
19:42:20 <araujo> > let my_id var = var in my_id 67
19:42:22 <lambdabot>  67
19:42:26 <sorear> (tis is a slight simplification)
19:42:31 <luqui> > (\f -> (f 42, f "hi")) id
19:42:32 <liyang> It is the one and the same `id' function down at the STG machine level, right? I'd hope it is.
19:42:32 <lambdabot>   add an instance declaration for (Num [Char])
19:42:48 <sorear> oh
19:42:52 <luqui> sorear, that's an interesting view
19:43:43 <luqui> so the reason that doesn't work is that it picks "which" id function to pass to the lambda before passing it
19:43:48 <sorear> luqui: that's because anything bound by a lambda has a "monomorphic type"... I can implement it but not understand it :)
19:44:01 <liyang> luqui: I'm almost certain that's how it actually works. :)
19:44:12 <sorear> it's one of the silly restrictions needed for decidability
19:44:17 <luqui> > (\ (f :: forall a. a -> a) -> (f 42, f "hi")) id
19:44:18 <lambdabot>  Parse error
19:44:21 <SamB_XP> heh
19:44:25 <luqui> aww, no glasgow exts?
19:44:28 <glguy> forall doesn't go in type defs
19:44:29 <sorear> naw
19:44:31 <liyang> eh heh
19:44:38 <sorear> ?set -fglasgow-exts
19:44:39 <lambdabot>  Parse error
19:44:45 <sorear> ?set___
19:44:46 <lambdabot> Unknown command, try @list
19:44:48 <sorear> ?set__
19:44:49 <lambdabot> Unknown command, try @list
19:44:51 <sorear> ?set_
19:44:51 <lambdabot> Maybe you meant: let seen
19:45:03 <luqui> (what I typed works under ghci -fglasgow-exts)
19:45:19 <sorear> well this is runplugs
19:46:15 <liyang> glasgow-exts includes rank-2 types, so that would work...
19:51:25 <sorear> @activity 999999
19:51:25 <lambdabot> 1415*total 1*#gentoo-haskell 1*#scannedinavian 1*Samus_ 1*ToRA 1*complaisant 1*kosmikus 1*kzm_ 1*luqui 1*nickserv 1*pitecus 1*rahikkala 1*resiak 2*shapr 2*xDie 3*Lemmih_ 3*dmhouse 4*astrolabe 5*
19:51:26 <lambdabot> Binkley 5*Syzygy- 5*lome 6*#perl6 7*huschi_ 10*Saizan 10*glguy 12*Jaak 12*xpika 13*earthy 17*#haskell.dut 19*#Haskell-blah 24*e_e_coli 41*benja_ 53*#haskell.hac07 98*#gentoo-uy 122*sorear 930*#
19:51:26 <lambdabot> haskell
19:52:01 <sorear> @activity 999
19:52:02 <lambdabot> 1418*total 1*#gentoo-haskell 1*#scannedinavian 1*Samus_ 1*ToRA 1*complaisant 1*kosmikus 1*kzm_ 1*luqui 1*nickserv 1*pitecus 1*rahikkala 1*resiak 2*shapr 2*xDie 3*Lemmih_ 3*dmhouse 4*astrolabe 5*
19:52:02 <lambdabot> Binkley 5*Syzygy- 5*lome 6*#perl6 7*huschi_ 10*Saizan 10*glguy 12*Jaak 12*xpika 13*earthy 17*#haskell.dut 19*#Haskell-blah 24*e_e_coli 41*benja_ 53*#haskell.hac07 98*#gentoo-uy 122*sorear 933*#
19:52:02 <lambdabot> haskell
19:52:27 <allbery_b> gesundheit :p
19:52:27 <lispy> ?help activity
19:52:27 <sorear> okey, broken...
19:52:28 <lambdabot> activity seconds. Find out where/how much the bot is being used
19:52:33 <shapr> whoa cool
19:52:56 * shapr returns from SANDWICH LAND!
19:53:00 <shapr> er, anyway...
19:53:05 <lispy> shapr: subway? ;)
19:53:13 <sjanssen> eat fresh
19:53:23 <shapr> lispy: Actually, yes.
19:53:27 <sorear> @activity 0
19:53:28 <lambdabot> 0*total
19:53:29 <liyang> Have it your way!
19:53:30 <sorear> @activity 1
19:53:31 <lambdabot> 0*total
19:53:33 <sorear> @activity 1
19:53:34 <lambdabot> 0*total
19:53:35 <sorear> @activity 1
19:53:36 <lambdabot> 0*total
19:53:38 <sorear> @activity 2
19:53:39 <lambdabot> 0*total
19:53:41 <sorear> @activity 5
19:53:42 <lambdabot> 1*total 1*#haskell
19:53:43 <nornagon> @activity -1
19:53:43 <sorear> @activity 5
19:53:44 <lambdabot> 0*total
19:53:44 <lambdabot> 2*total 2*#haskell
19:53:47 <shapr> lispy: My sister manages a store, and when I have no money I go there and she gives me a free sandwich. I've been twice this week...
19:54:00 <lispy> shapr: oy!
19:54:05 <shapr> It's a good thing I remembered to send my bill recently...
19:54:15 <shapr> I won't be poor tomorrow!
19:54:21 <shapr> At least, not before I pay my bills.
19:54:23 <lispy> shapr: awesome
19:54:46 <lispy> i need to pay my tuition bill...then i'll be poor
19:54:56 <shapr> How much is tuition?
19:55:15 <lispy> i only take 4 credits a term, so i pay ~$2k every 3 months
19:55:17 <orbitz> a billion dollars
19:55:21 <shapr> Tuition in Sweden is hard to believe no matter how you look at it... it's either free, or it's 25% of every transaction.
19:55:57 <nornagon> heh
19:56:27 <shapr> nornagon: Ã¤r du svensk?
19:56:34 <nornagon> no
19:56:39 <nornagon> australian :)
19:56:49 <shapr> Talar du svensk?
19:57:10 <SamB_XP> four credits?
19:57:14 <SamB_XP> that doesn't sound like much!
19:57:17 <shapr> I'm not Swedish either. I'm Alabamian!
19:57:44 <shapr> It's funnier in Swedish, where you have Swedish = Svensk, Finnish = Finsk, and Alabamian = Alabamsk
19:58:03 * shapr gives up trying to make Swedish jokes in English and goes back to coding.
19:58:08 <nornagon> good plan
19:58:09 <shapr> @seen doublec
19:58:10 <lambdabot> I saw doublec leaving #haskell 1d 19h 10m 26s ago, and .
19:58:34 <nornagon> ... doublec is here?!
19:58:41 <shapr> He was.
19:58:52 <nornagon> he's eeeeverywhere, it seems
19:59:04 <shapr> Weren't you around when slava, dylan, etc started talking about Creatures and PLT?
19:59:11 <nornagon> yeah
19:59:59 <shapr> nornagon: So, you written much Haskell?
20:00:47 <nornagon> not a great deal, no
20:01:27 <shapr> How do you like it so far?
20:01:30 <sorear> yow.  System.Time.diffClockTimes is broken...
20:01:36 <nornagon> it's nice :) but confusing.
20:01:40 <nornagon> @yow
20:01:40 <lambdabot> Okay ... I'm going home to write the "I HATE RUBIK's CUBE HANDBOOK FOR
20:01:40 <lambdabot> DEAD CAT LOVERS" ...
20:02:16 <sorear> I found out why @activity is reporting soo much in the last minute ... it's a bug/misfeature in System.Time
20:02:31 <nornagon> @activity 60
20:02:32 <lambdabot> 1433*total 1*#gentoo-haskell 1*#scannedinavian 1*Samus_ 1*ToRA 1*complaisant 1*kosmikus 1*kzm_ 1*luqui 1*nickserv 1*pitecus 1*rahikkala 1*resiak 2*shapr 2*xDie 3*Lemmih_ 3*dmhouse 4*astrolabe 5*
20:02:32 <lambdabot> Binkley 5*Syzygy- 5*lome 6*#perl6 7*huschi_ 10*Saizan 10*glguy 12*Jaak 12*xpika 13*earthy 17*#haskell.dut 19*#Haskell-blah 24*e_e_coli 41*benja_ 53*#haskell.hac07 98*#gentoo-uy 122*sorear 948*#
20:02:32 <lambdabot> haskell
20:02:34 <nornagon> :O
20:02:46 <sorear> diffClockTimes doesn't give canonical time diffs, non-canonical time-diffs (<) incorrectly.
20:02:48 <shapr> nornagon: I found it to be unconfusing, which was about as difficult. I had to get a bunch of stuff untwisted in my head.
20:02:57 <shapr> sorear: fix it!
20:03:15 <sorear> you mean, in the library?
20:03:26 <shapr> yup
20:03:29 <shapr> What are you waiting for?
20:03:37 <sorear> * deep breath *
20:03:46 <shapr> C'mon, you're not the youngest person to file a patch against GHC.
20:04:01 <shapr> I think the youngest was phubuh who started patching stuff at the age of 14
20:04:16 <shapr> You're two years over already!
20:04:38 * master_bater feels old
20:04:57 <shapr> master_bater: Are you older than 0x23 ?
20:05:07 <master_bater> i'm 23 (decimal)
20:05:22 <shapr> ah poor reppie
20:05:25 * SamB_XP ix only 0x14
20:05:31 <master_bater> you remember me!
20:05:35 <shapr> Yup
20:05:37 <dylan> I'm 0x15
20:05:39 <shapr> Mr Refugee
20:05:45 <master_bater> :)
20:05:49 * jcreigh waits for some witty person to start using binary...
20:06:01 <shapr> I'm 00000ld
20:06:06 <SamB_XP> jcreigh: dude, we don't have any three-year-olds
20:06:07 * shapr snickers
20:06:35 <dylan> I'm 0b10101, also.
20:06:51 <dylan> heh, SamB_XP is younger than me!?
20:07:03 <SamB_XP> what? is that strange?
20:07:09 <shapr> I'm 0x23
20:07:24 <dylan> Everyone is further along at academic studies than me. Bleh. :(
20:07:34 <allbery_b> 0x2a
20:07:37 <master_bater> academic studies suck
20:07:47 <allbery_b> (but, academic studies?  er, not really)
20:07:49 <bos> in canonical gray code, i'm 061
20:07:49 <shapr> But I started #haskell when I was 0x1E
20:07:51 <dylan> not having a degree at 21 sucks.
20:08:00 * nornagon 0x11
20:08:02 * sorear proudly waves his knowledge of arcane mathematics!
20:08:02 <SamB_XP> hahaha
20:08:04 <shapr> dylan: I don't have a degree either.
20:08:17 <dylan> True.
20:08:23 <SamB_XP> I might be in my second official year of college now ;-)
20:08:29 <shapr> allbery_b: You win the old FPer award
20:08:29 <bos> simonpj became head of the cs dept at glasgow university without a phd.
20:08:35 <shapr> Yup
20:08:55 <SamB_XP> bos: how long did it take him to get one?
20:08:55 <sorear> shapr: System/Time.hsc says "canonicalize as late as possible to avoid errors caused by leap years." Yecch!
20:08:57 <dylan> I don't even have a bachelor's yet. :(
20:09:05 <shapr> bos: Though from what I hear, several universities were just dying to flat out GIVE him a PhD so they could claim him as an alumnus.
20:09:06 <bos> SamB_XP: he didn't.
20:09:12 <allbery_b> and no degree, and unlikely ever to get one despite working at a university
20:09:22 <SamB_XP> bos: I'm surprised nobody has given him one for free by now!
20:09:29 <emu> did you start out working part time towards a degree?
20:09:33 <shapr> SamB_XP: From what I've heard, they've been trying.
20:09:43 <SamB_XP> he doesn't *want* one?
20:09:52 <shapr> I think he doesn't *need* one.
20:09:59 <shapr> He's the foremost FP researcher in the world.
20:10:00 <SamB_XP> is he trying to set the world record for PhDs refused?
20:10:13 <emu> he doesn't want to be Dr. Jones
20:10:19 <master_bater> what's the point of phds anyway
20:10:20 <SamB_XP> heh
20:10:31 <shapr> master_bater: Um....
20:10:33 <shapr> Well
20:10:37 <emu> ... piled higher and deeper
20:10:47 <SamB_XP> oooh, nice comic!
20:10:51 <shapr> I've gotten snubbed by some PhDs who felt I wasn't as smart if I didn't have a PhD too.
20:11:14 <master_bater> shapr i wouldn't want to work with those kinds of people.
20:11:14 <SamB_XP> shapr: tell them you haven't gotten around to it yet!
20:11:18 <allbery_b> there is the school of thought that says that Ph.Ds are essentially a hoop to jump through to get tenure
20:11:26 <dylan> I've felt rather bad about my lack of academic achievement since being snubed by PhDs in another channel. :(
20:11:26 <sorear> shapr: yech. all these timestamp libs are massively overengineered.
20:11:41 <SamB_XP> anyway, I need to sleep
20:11:45 <master_bater> night
20:11:49 <allbery_b> ...and then the PhDs who react that way to try to prove their PhDs mean something :)
20:11:53 <SamB_XP> I am horrible at sleep
20:11:56 * sorear snubbs dylan without a phd
20:11:57 <SamB_XP> if it were a class, I'd
20:12:02 <bos> how do i undo a darcs add?
20:12:05 <SamB_XP> have like a D or an F or something
20:12:08 <shapr> dylan: Yeah, we're equal opportunity snubbists here on #haskell ;-)
20:12:08 <sorear> dylan: you happy now?
20:12:12 * shapr laughs
20:12:13 <dylan> bos: darcs remove
20:12:15 <emu> bos: unrecorded?
20:12:21 <bos> emu: yes
20:12:37 <shapr> dylan: But seriously, if you can learn stuff and share it with others, that's what's important.
20:12:48 <dylan> darcs remove is the inverse of darcs add, you'd need unrecord if you recorded it, which I doubt you did.
20:12:53 <emu> revert can get rid of unrecorded changes
20:13:05 <shapr> I've known several PhDs who a) couldn't seem to accomplish anything useful and b) couldn't seem to share what they knew. So I considered them useless.
20:13:38 <dylan> well, it's mostly about knowing people that technically know less than I do, that can get higher paying jobs. :(
20:13:51 <allbery_b> ...and have remarkably little common sense, to boot
20:14:09 <shapr> #haskell has an explicit "Steps of the Parthenon" policy.
20:14:25 <nornagon_> ?
20:14:49 <shapr> Philosophers used to hang out on the steps of the Parthenon and chat.
20:14:57 <iulus> ah
20:15:05 <iulus> I was confused for a bit
20:15:08 <shapr> You didn't need any qualifications, but you did need to be able to hold your own in discussion against others :-)
20:15:17 <master_bater> or get shit done!
20:15:18 <nornagon_> :)
20:15:20 <shapr> Right!
20:15:56 <shapr> Sort of like the Saturday Night Live approach to comedy.. if someone upstages you, you better try harder to be funny.
20:15:56 <clanehin_> where is this policy made explicit?
20:16:00 <dylan> But, a part of me wants a job teaching college students. So, I do have to get at least a master's for that. and I've wasted about 4 years in college so far.
20:16:03 <shapr> I think it's on the IRC channel page.
20:16:03 <dylan> well, not wasted.
20:16:11 <sorear> Tomorrow I'm going create a time lib that's not overengineered.
20:16:14 <shapr> sorear: yay!
20:16:17 <shapr> sorear: Why tomorrow?
20:16:23 <shapr> Oh, sleep?
20:16:33 <master_bater> because tonight is the night when two become one
20:16:34 <dylan> shapr: because his time lib will always be one day in the future.
20:16:35 <sorear> I have 2 hours and an essay do tomorrow.
20:16:38 <shapr> dylan: haha
20:16:42 <shapr> sorear: Oh, good point.
20:16:42 <iulus> unfortunately, they won't let you sit on those steps anymore
20:16:46 <sorear> I've done enough procrastinating for today :)
20:17:21 <shapr> iulus: That's too bad. I went to see the Parthenon a few years back. It was very... white.
20:17:32 <dylan> I'm glad I'm not the only one that writes software as a way of avoiding homework.
20:17:45 <iulus> shapr: my opinion: it's windy.
20:17:52 <clanehin_> I don't see that on the IRC page, I just see no making fun of newbees
20:18:10 <dylan> I failed *intermediate* algebra because I wrote a symbolic math calculator thing instead...
20:18:11 <shapr> clanehin_: Well, I'll talk to dons when he has time. Don is the man in charge of #haskell these days.
20:18:31 <shapr> dylan: We need classes for CODEpendents.
20:18:40 <clanehin_> I'd like to know the standard for "holding one's own" and the procedure for kicking someone who doesn't "hold their own"
20:18:43 <dylan> I'm just not good at doing boring stuff.
20:18:45 <emu> @tell sorear be sure to read this before writing a time library: http://naggum.no/lugm-time.html
20:18:46 <lambdabot> Consider it noted.
20:19:02 <shapr> clanehin_: Really it's about "be nice" and "contribute to the community"
20:19:24 <falconair> i read Grust's papers on Monad Comprehensions a while ago, while reading I was mentally replace "Monad Comprehensions" with "List Comprehensions."  However, since he is talking about mapping SQL to monads, can SQL be mapped to non-list like monads (state monad, io monad, etc.)?
20:19:27 <shapr> clanehin_: I banned one person who drove off newbies by being mean to them.
20:19:31 <dylan> hehe, "be nice" is the only rule in the IRC network I, nornagon, bd_, and kyevan come from. :)
20:19:46 <dylan> shapr: Smerdyakov?
20:19:49 <shapr> dylan: yup
20:20:08 <bd_> dylan: It's a bit tricky to enforce that rule at times though ;)
20:20:35 <shapr> I've banned three or four people total, mostly because of purely emotional arguments.
20:20:37 <emu> be nice, or else
20:20:44 <shapr> emu: Yeah, that's the quote.
20:20:54 <dylan> he's part of the reason I became a good ocaml programmer, though. I have a habit of when discovering a lout, learning more than them in order to ... embarass them publically...
20:21:10 <dylan> bd_: I think it works fairly well, don't you?
20:21:23 <shapr> Not me, I skipped out on learning SML because of Smerdyakov and Common Lisp because of rahul.
20:21:27 <bd_> dylan: usually :)
20:21:52 <shapr> clanehin_: What do you think of that policy?
20:22:08 <dylan> shapr: It was really great when I was able to call Smerdy on a fact about ocaml's implementation. :-)
20:22:15 <shapr> dylan: wow
20:22:29 <dylan> I know ocaml
20:22:35 <dylan> 's guts fairly.
20:22:37 <clanehin_> shapr, I like that policy.  "holding one's own" might sound a lot like, "be mean to newbies" to a lot of people's ears, though, was my main concern
20:22:38 <dylan> *well.
20:22:39 <shapr> I spent months trying to get Smerdy to be a good citizen.
20:22:40 <master_bater> i know kung fu
20:22:43 <iulus> dylan: and you could have been using all of this time to jump through hoops to get a degree :P
20:22:51 <dylan> iulus: Exactly!
20:23:00 <dylan> iulus: But it's more fun to attack mean people.
20:23:27 <clanehin_> shapr: also I figured I could hold my own in a conversation on the topic of whether people should be instructed to hold their own, as an example
20:23:28 <iulus> if that pleases you
20:23:56 <dylan> iulus: in the interim I also helped a lot of newbies.
20:24:10 <iulus> good for you
20:24:21 <iulus> I must admit, I wish I were a better teacher
20:24:26 <dylan> sharing knowledge should be right up there with finding food and sleeping.
20:24:28 <shapr> iulus: You can learn how
20:24:38 <shapr> dylan: Most people don't think that way.
20:24:43 <iulus> I try--I think I'm getting better
20:24:58 <shapr> I think I did a bunch of crappy teaching in my early years on #haskell
20:25:02 <dylan> shapr: that's fine. I won't share my fire with them, then, and they can freeze to death.
20:25:15 <iulus> I was a T.A. this semester for intro to programming
20:25:16 <dylan> survival of the nicest.
20:25:21 <shapr> My gf is not happy with my teaching style at all, but she is clear about what she doesn't like, so I'm getting better.
20:25:33 <shapr> dylan: heh, yes. I have a few good stories about survival of the nicest...
20:25:33 <iulus> it's frustrating for me to not be able to explain the simplest concepts to kids that actually want to know
20:25:53 <dylan> I keep getting told I'm good at explaining things.
20:25:56 <shapr> iulus: The easy way is to plagiarize... whenever you see a good way to explain something, steal it right there!
20:26:09 <iulus> haha
20:26:21 <dylan> one good thing to remember is too much information is going to hurt more than it helps, for most people.
20:26:33 <shapr> Yeah, "lies for teaching"
20:26:38 <iulus> unfortunately I don't hang around the Java world often, so that can be difficult at times with the more specific ideas
20:26:40 <dylan> Or just omissions.
20:26:57 <dylan> My father had the hardest time explaining math to me until I told him to stop explaining.
20:27:02 <shapr> heh
20:27:04 <dylan> explain to a point, and stop.
20:27:25 <shapr> My gf said something similar, "Don't try to explain to me, just tell me and let me ask questions."
20:28:09 <iulus> I'll remember that
20:28:16 <shapr> clanehin_: I think by 'hold their own' I mean 'is able to learn enough stuff to keep up'
20:28:27 <shapr> clanehin_: But maybe that's not part of anything.
20:28:31 * shapr thinks
20:28:35 * glguy returns
20:28:42 <glguy> what's this business about holding own?
20:28:49 * shapr holds onto glguy!
20:29:01 * glguy wonders what definition of own we are using ;)
20:29:07 <master_bater> pwn
20:29:09 <shapr> owned! er..
20:29:22 <bd_> glguy: I think it might have something to do with StablePtr...? ;)
20:29:38 <iulus> bd_: witty
20:29:41 <shapr> Hirvinen: I like your nick
20:30:16 <dylan> y'know, I don't think I can understand something until I can teach it to someone else.
20:30:31 <shapr> dylan: I think being able to write code to do something is one step beyond that.
20:30:49 <clanehin_> shapr: how about "you don't have to have qualifications to join, but have to converse with sincerity?"
20:30:51 <dylan> I can't understand without writing code, either.
20:30:57 <shapr> clanehin_: Oh, I like that.
20:31:19 <dylan> speaking of code, I need to finish rewriting my hacky pretty printer to use sorear's vty.
20:31:30 <shapr> And I need to finish the HAppS example code
20:31:34 <dylan> it's interesting it can be pure code now.
20:31:39 <nornagon> pretty printer?
20:31:46 <iulus> my math teacher in HS always had me code things I'd done it math... that always helped me.
20:32:09 <shapr> In high school we had Apple ][s
20:32:10 <dylan> nornagon: I define data structures for the widgets of haver-client and print them out to vty.
20:32:25 <nornagon> dylan: ah, neat.
20:32:29 <shapr> Our school bought a color display card for two of them and I got to install them =)
20:32:39 <bos> @hoogle getHostName
20:32:40 <lambdabot> Network.BSD.getHostName :: IO HostName
20:32:40 * shapr stops acting like a guy with a cane and goes to write code!
20:32:50 <dylan> nornagon: it's not a pretty printer combinator, but it's not bad. :)
20:33:24 <glguy> anyone know what ?pretty is actually for?
20:33:38 <dylan> ?pretty?
20:33:44 <robreim> What alternatives to the State monad might I want to look at? In particular, I'm having trouble with situations where I have functions of type [a -> StateT b IO c] which I need to pass to functions of type [IO c -> IO d]
20:33:44 <dylan> lambdabot command?
20:33:46 <nornagon> ?help pretty
20:33:46 <lambdabot> pretty <expr>. Display haskell code in a pretty-printed manner
20:34:14 <dylan> ?pretty (a (b c))
20:34:15 <lambdabot> "Parse error" at column 10
20:34:16 <robreim> erk, that second type should be (a -> IO c) -> IO d
20:34:23 <shapr> robreim: Do you already know liftIO?
20:34:30 <bos> @hoogle Socket
20:34:31 <lambdabot> Network.Socket :: module
20:34:31 <lambdabot> Network.Socket :: data Socket
20:34:31 <lambdabot> Network.Socket.socket :: Family -> SocketType -> ProtocolNumber -> IO Socket
20:34:39 <robreim> shapr: Yup. That doesn't work for this though.
20:34:43 <nornagon> ?pretty let map f []=[];map f (x:xs)=f x:map f xs in map toUpper "hi"
20:34:44 <lambdabot>  i = let map f [] = []
20:34:44 <lambdabot>          map f (x : xs) = f x : map f xs
20:34:44 <lambdabot>        in map toUpper "hi"
20:34:59 <dylan> Oh.
20:35:00 <bos> @hoogle SocketPrim
20:35:01 <lambdabot> No matches found
20:35:03 <glguy> ah, indenting
20:35:08 <glguy> (just noticed that in the source code)
20:35:40 <allbery_b> hm, comes the Oleg
20:35:54 * allbery_b prepares to be left going "whuh?" again...
20:36:24 <robreim> I have written a specialised lift function for the case: (IO a -> IO b) -> StateT s IO a -> StateT s IO b. But it's getting a little tiresome writing specialised lift operators. I'd like something a bit more generol.
20:36:26 <robreim> general even.
20:36:31 <bos> @hoogle socketToHandle
20:36:32 <lambdabot> Network.Socket.socketToHandle :: Socket -> IOMode -> IO Handle
20:37:06 <glguy> ?type mapStateT
20:37:08 <lambdabot> forall b (n :: * -> *) s a (m :: * -> *). (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
20:37:12 <allbery_b> hm, that was remarkably non-brain-frying
20:37:13 <glguy> ?type withStateT
20:37:15 <lambdabot> forall a (m :: * -> *) s. (s -> s) -> StateT s m a -> StateT s m a
20:37:34 <glguy> robreim: I think mapStateT is the closest thing in the library
20:38:19 <robreim> ?hoogle mapStateT
20:38:20 <lambdabot> Control.Monad.State.mapStateT :: (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
20:38:55 <bos> @hoogle hostname
20:38:55 <lambdabot> Network.HostName :: type HostName
20:38:56 <lambdabot> Network.BSD.hostName :: HostEntry -> HostName
20:38:56 <lambdabot> Network.BSD.getHostName :: IO HostName
20:40:00 <glguy> ?type lift
20:40:02 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:40:10 <bos> @hoogle AF_INET
20:40:11 <lambdabot> Network.Socket.AF_INET :: Family
20:40:11 <lambdabot> Network.Socket.AF_INET6 :: Family
20:40:45 <robreim> glguy: hmm. Yeah, that's pretty close...
20:41:13 <robreim> ?hoogle (m a -> m b) -> m (a,s) -> m (b,s)
20:41:14 <lambdabot> No matches, try a more general search
20:41:32 <bos> what's ~ mean in a pattern?
20:41:37 <glguy> lazy
20:41:43 <glguy> pattern matching
20:41:51 <bd_> let ~(x, a) = undefined in "ok"
20:41:54 <bd_> er
20:41:54 <bos> @type Network.Socket.Accept
20:41:56 <lambdabot> Not in scope: data constructor `Network.Socket.Accept'
20:41:57 <bd_> > let ~(x, a) = undefined in "ok"
20:41:59 <lambdabot>  "ok"
20:42:01 <bd_> > let (x, a) = undefined in "ok"
20:42:02 <lambdabot>  "ok"
20:42:03 <bos> @type Network.Socket.accept
20:42:05 <lambdabot> Network.Socket.Socket -> IO (Network.Socket.Socket, Network.Socket.SockAddr)
20:42:08 <bd_> ... oh, right
20:42:18 <bd_> > let f (x, a) = "ok" in f undefined
20:42:19 <lambdabot>  Undefined
20:42:21 <bd_> > let f ~(x, a) = "ok" in f undefined
20:42:23 <lambdabot>  "ok"
20:42:24 <bd_> bos: there you go :)
20:42:25 <bos> so a lazy pattern always matches, and you don't get an error until you use the result?
20:42:28 <bd_> yeah
20:42:38 <bos> ok, thanks!
20:43:18 <Cale> also, pattern bindings are lazy by default
20:48:36 <metaperl> lisppaste is down
20:48:46 <Cale> @paste
20:48:47 <lambdabot> http://paste.lisp.org/new/haskell
20:48:56 <Cale> yep, sure is
20:49:09 <Cale> It seems to do that
20:49:27 <metaperl> how can I get a printed representation for my List consisting of Lists: http://rafb.net/p/mqIcaL28.html
20:49:28 <lambdabot> Title: Nopaste - No description
20:49:55 <bos> @type Network.accept
20:49:57 <lambdabot> Network.Socket.Socket -> IO (GHC.IOBase.Handle, Network.BSD.HostName, Network.Socket.PortNumber)
20:50:04 <bos> @type Network.Socket.accept
20:50:06 <lambdabot> Network.Socket.Socket -> IO (Network.Socket.Socket, Network.Socket.SockAddr)
20:51:16 <allbery_b> show doesn't work?
20:52:02 <metaperl> the suggestion is to add an instance declaration for Show (Lis (Lis Integer, Lis Integer) 0> Lis (Lis Integer, Lis Intger)))
20:52:45 <glguy> cong = Cons ( empty_list :: (Lis Integer) , m )
20:52:55 <allbery_b> hm, that comma seems out of place
20:52:57 <glguy> cons takes two args
20:52:58 <metaperl> yes, but it wont show
20:53:03 <metaperl> no, it's right
20:53:09 <glguy> no
20:53:10 <allbery_b> you want a tuple?
20:53:13 <glguy> f (x,y)
20:53:16 <metaperl> empty_list :: Lis Integer
20:53:18 <bos> @hoogle Posix
20:53:18 <lambdabot> Text.Regex.Posix :: module
20:53:19 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
20:53:19 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
20:53:23 <metaperl> m :: Lis Integer
20:53:26 <bos> @hoogle posix
20:53:27 <lambdabot> Text.Regex.Posix :: module
20:53:28 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
20:53:28 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
20:53:30 <metaperl> cong :: Lis (Lis Integer))
20:53:32 <bos> @hoogle POSIX
20:53:33 <lambdabot> Text.Regex.Posix :: module
20:53:33 <lambdabot> System.Win32.File.fILE_FLAG_POSIX_SEMANTICS :: FileAttributeOrFlag
20:53:33 <lambdabot> System.Win32.File.sCS_POSIX_BINARY :: BinaryType
20:53:40 <bos> pardon my babble.
20:53:54 <glguy> metaperl: Cons takes two args
20:53:59 <allbery_b> metaperl: (,) does not separate function arguments, it's a tuple constructor
20:54:11 <metaperl> oh!
20:54:31 <glguy> metaperl: but yo uwill get a new arrow
20:54:33 <glguy> error
20:54:35 <allbery_b> you write f a b in Haskell where you'
20:54:41 <allbery_b> d say f(a, b) in some other language
20:54:58 <glguy> metaperl: you can't prepend an empty list ona list of Integers
20:55:10 <allbery_b> (which in HGaskell gets you a single argument which is a tuple)
20:55:16 <metaperl> glguy - no, I am making [ [], [1,2,3] ]
20:55:26 * allbery_b sighs --- missed one typo :/
20:55:29 <metaperl> [  [Int] ]
20:55:34 <glguy> metaperl: not there you aren't
20:55:45 <metaperl> glguy - yes, but I'm trying .... hmm
20:55:51 <glguy> cons empty (cons m empty)
20:56:42 <Cale> Or in the notation of your file,  cong = Cons Empty (Cons m Empty)
20:57:48 <glguy> (:) [] ( (:) [1,2,3] [] )
20:57:51 <glguy> > (:) [] ( (:) [1,2,3] [] )
20:57:52 <lambdabot>  [[],[1,2,3]]
20:58:39 <metaperl> >    (:) [4,3,2] []
20:58:41 <lambdabot>  [[4,3,2]]
20:59:03 <metaperl> > (:) []
20:59:04 <lambdabot>  Add a type signature
20:59:15 <metaperl> > (:) [] :: [Integer]
20:59:16 <lambdabot>      Expecting a function type, but found `[Integer]'
20:59:16 <lambdabot>       Expected type: [I...
20:59:28 <glguy> > (:) [] []  :: [Integer]
20:59:30 <lambdabot>  Couldn't match `Integer' against `[a]'
20:59:37 <glguy> > (:) [] []  :: [[Integer]]
20:59:39 <lambdabot>  [[]]
21:00:07 <metaperl> so now we have two things of type a
21:00:11 <metaperl> where a = [Integer]
21:00:18 <metaperl> I see
21:00:21 <glguy> ?
21:00:46 <glguy> 2 things?
21:01:17 <metaperl> what? (:) [] [] :: [[Integer] ] and (:) [4,3,2] [] :: [[Integer]]
21:01:18 <glguy> :t (:)
21:01:20 <lambdabot> forall a. a -> [a] -> [a]
21:01:45 <glguy> oh in that example
21:14:08 <metaperl> I figured it out and wrote it in my own words - http://rafb.net/p/H3kDwZ66.html
21:14:09 <lambdabot> Title: Nopaste - No description
21:15:05 <glguy> looks good
21:15:33 <metaperl> thanks :)
21:16:22 <glguy> if you want to play with Lisp-style lists, you could do: data Thing a = Null | Atom a | Cons (Thing a) (Thing a)
21:16:50 <metaperl> yeah, that means the second cons cell could have data in it (4 . 6) for instance
21:16:57 <metaperl> Cons (Atom 4) (Atom 6)
21:16:59 <glguy> yeah
21:17:03 <metaperl> weird stuff :)
21:17:12 <metaperl> good for assoc lists I suppose
21:17:18 <glguy> at which point it ceases to be a list
21:17:36 <newsham> sexpr parser isnt that hard either.
21:17:52 <sorear> hm, finishing the essay took less time then I thought...
21:17:52 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
21:17:53 <metaperl> @google write yourself a scheme in 48 hours
21:17:55 <lambdabot> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
21:17:56 <lambdabot> Title: Write Yourself a Scheme in 48 hours
21:18:05 <newsham> you could also write yourself a scheme parser (in 48hrs)
21:18:12 <sorear> parsing the entire numeric tower is rather annoying.
21:18:13 <newsham> err.. scheme interpretter
21:18:37 <sorear> does the 48hrs scheme correctly handle *all* the types of number?
21:18:40 <sorear> @messages
21:18:41 <lambdabot> emu said 59m 56s ago: be sure to read this before writing a time library: http://naggum.no/lugm-time.html
21:18:55 <newsham> sorear: depends on how much you can code in 48hrs I imagine.
21:19:34 <sorear> the genericserialize sexp parser has several pages of debugging-resistant spagetti dedicated to the numeric tower.
21:21:10 <newsham> you could make your own lisp dialect without paying attention to standards
21:21:18 <newsham> "<glguy> if you want to play with Lisp-style lists"
21:21:26 <Korollary> oh no. please no more lisp dialects.
21:21:47 <newsham> kor: eta / (x+eta) << 1
21:22:16 <newsham> whats another lisp dialect more or less
21:22:22 <glguy> newsham: I was going to type something else, but my attention fluttered off elsewhere
21:22:39 <newsham> glguy: s'ok, we're all ?pl here anyway
21:22:41 <sorear> oh... I thought scheme == r5rs
21:23:25 * glguy wonders if that scheme+48hours tutorial does continuations
21:26:15 <Korollary> ahah
21:26:36 <metaperl> I hear arc was going to be a great lisp
21:26:44 <Korollary> "In two weeks I am returning to India in a much better state to visit
21:26:44 <Korollary> the same clinic to deepen my studies into Eastern medicine, tantra and
21:26:45 <Korollary> yogic practice and merge them with my understanding of Taoist practice."
21:26:57 <Korollary> by the guy who wrote Qi.
21:27:56 <metaperl> what is Qi? (in this case)
21:28:28 <Korollary> http://www.lambdassociates.org/
21:28:30 <lambdabot> Title: Lambda Associates Home Page
21:29:20 <newsham> sorear: my silc api is IO, lambdabot runs in LB.  I can "io $ act" to run my IO in LB, but what do I do when I'm in a callback (which is IO) to invoke an LB?
21:34:10 <sorear> newsham: lbIO
21:34:20 <sorear> or the higher level function liftLB
21:34:49 <sorear> see LBState.hs for a good example - forkIO needs IO () , liftLB is used to make a forkLB :: LB () -> LB ()
21:35:43 <glguy> I think he means the other way..
21:37:23 <glguy> instead of using IO function in LB, he'll need to use LB functions in IO
21:37:27 <sorear> no - forkLB needs to pass its argument (a LB ()) to forkIO which takes IO ()
21:38:07 <nacho> b
21:38:13 <sorear> you can't use LB from IO.  but there is a function of type (up to CPS)  LB (forall a. LB a -> IO a)
21:38:23 <sorear> emu: cool
21:41:18 <sorear> @bot
21:41:18 <lambdabot> :)
21:41:26 <nacho> I'm playing with the parsec library and defined an Expression datatype for parsing different types from input. I'm struggling however with implementing a type class to aid in defining the methods for comparing/equating my types. My class keeps returning an error that the type constructor JBool (which I delcared in Expr) is undeclared.
21:41:55 <sorear> data Expr = ... | JBool | ...  -- ?
21:42:20 <sorear> JBool is a data constructor, expr is a type constructor. (in the example)
21:42:52 <sorear> @seen emu
21:42:53 <lambdabot> emu is in #haskell-blah and #haskell. I last heard emu speak 1h 22m 18s ago.
21:43:47 <nacho> sorear: yes, that's hwo it's been defined
21:43:59 <nacho> data Expr = JBool Bool | ...
21:44:21 <sorear> so JBool isn't a type constructor, it's a data constructor.
21:44:33 <nacho> I see.
21:44:40 <sorear> do you maybe want pattern matching rather than a type class?
21:45:09 <nacho> sorear: that's how I've implemented a bit, yet it seems a little messy
21:45:41 <sorear> messy, like quadratic explosion of foo (Bar x y) (Baz z) cases?
21:45:56 <nacho> yes :(
21:46:23 <sorear> usually, you can rearrange things such that _ _ is useful
21:46:32 <sorear> e.g in an Eq instance you can say
21:46:41 <sorear> (==) (A x) (A y) = x == y
21:46:42 <sorear> ...
21:46:48 <sorear> (==) _ _ = False
21:46:57 <sorear> where _ means "none of the above"
21:47:23 <nacho> ya :\
21:47:31 <sorear> actually, any name will do - patterns are matched from top down
21:47:47 <sorear> it's considered good style to use _ if you don't want to name the value
21:48:41 <sorear> also: you know about deriving(Eq,Ord,Show) ?
21:49:02 <nacho> Yup
21:49:38 <sorear> good
21:57:09 <nacho> I've implemented a (f :: Parser Expr), however, if I define { data Expr = Integer | Double } it alerts me that it couldn't match Expr against the inferred type Double, etc..
21:58:15 <nacho> Is it necessary to define a type constructor as I've done to work around this, ie. "data Expr = JDouble Double |..."  etc.etc?
21:58:53 <sorear> that's just part of the syntax
21:59:15 <sorear> data <type constructor> = <data constructor> args | <data constructor> args ...
21:59:45 <luqui> nacho, so yes
21:59:49 <sorear> data Expr = Integer | Double creates two data constructors 'Integer' and 'Double', each with zero arguments; like a C enum
21:59:52 <luqui> there are no untagged unions
22:10:51 <sorear> @bot
22:10:52 <lambdabot> :)
22:11:26 <nacho> Another annoying issue: when i'm writing these pattern matching functions (ie, handling a binary operation), I'd hate to have to duplicate a ton of paramaters when many of the types encapulated in the data type are members of ORd, Eq, etc
22:11:35 <brad_> ?src unfoldr
22:11:36 <lambdabot> unfoldr f b  = case f b of
22:11:36 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
22:11:36 <lambdabot>    Nothing        -> []
22:12:09 <xic> what do you guys like using for configuration files?
22:12:44 <nacho> but when I try do do binaryOp :: Ord a => (a->a->Bool) -> Expr ->Expr -> Expr, it complains that type a is a rigid variable.
22:17:11 <brad_> any news on the haskell hackathon?
22:17:24 <brad_> i almost write hackathong. thats a little cheeky
22:18:51 <brad_> guess no news is good news
22:19:11 <sjanssen> brad__: I imagine all the hackathoners are asleep right now
22:19:43 <sjanssen> I think it's 6 AM over there
22:19:52 <sorear> nacho: you want: binaryOp :: Ord a => (forall a. Ord a => a->a->Bool) -> Expr ->Expr -> Expr
22:20:04 <brad_> start clanging those pots and pans! time to GET UP AND CODE
22:20:39 <sorear> The hackathon wake schedule doesn't overlap my home-and-awake-schedule *at all*. :(
22:20:40 <sjanssen> brad_: /join #haskell.hac07 if you want to lurk a bit
22:20:45 <brad_> put on a pot of coffee and start fixing Network.HTTP. get hackage done. fix all my other bugs
22:21:30 <brad_> oh i better not bother them in #haskell.hac07, someone might toss me a well-placed "f$#k off"!
22:21:32 <sjanssen> sorear: I feel your pain, I only get 3 hrs overlap
22:22:51 <brad_> i would contribute to hac07 but i am a parasite and too stupid to boot.
22:23:34 <sjanssen> brad_: you have a year to study up for hac08 :)
22:23:57 <brad_> sjanssen - next year i will still be stupid and possible senile
22:24:02 <brad_> i will be 37 after all
22:24:24 <brad_> time for my logan's run moment
22:25:18 <brad_> oh well you have endured my drivel enough for one night
22:25:22 <brad_> byebye
22:26:31 <yip> what's some good haskell code to read?
22:26:45 <monochrom> GHC source code XD
22:28:22 <monochrom> There is stuff on the haskell wiki to read.  Look under the category "code".
22:38:26 <newsham> *sigh*
22:43:45 <nacho> sorear suggested that I use forall in my declaration of a method to avoid a rigid variable error, however, I can't seem to get it working either. binaryRo :: forall a. (Ord a) => (a->a->Bool) -> Expr->Expr->Expr , won't work.
22:48:43 <newsham> I dont understand how I can use my IO callbacks in the lambdabot LB monad.
22:54:44 <monochrom> The purpose of "forall a" is to empower you to mention "a" in the function body.  If you don't mention "a" in the function body, you are still not harnassing its power.
22:55:07 <monochrom> Example.  id :: forall a. a -> a; id x = (x :: a)
22:59:26 <nacho> monochrom: i see, however would one use "forall a" to represent an item in my pattern matching that's part of a type constructor,
22:59:43 <nacho> binaryRo f (JInteger a) (JInteger b) = JBool (f a b)
23:00:37 <monochrom> There is no type variable in "binaryRo f (JInteger a) (JInteger b) = JBool (f a b)"
23:01:44 <nacho> not even the a or b which are of an inferrable type?
23:02:16 <monochrom> "a" and "b" refer to values
23:02:34 <monochrom> If you don't see "::" there is no type mentioned at all.
23:03:44 <nacho> i'm stumped again :(
23:04:11 <monochrom> It is possible to write "binaryRo f (JInteger a) (JInteger b) = JBool (f (a::a) b)"  if that is what you mean.  Note that it is very self-confusing to use "a" to refer to two different things.
23:04:54 <monochrom> Perhaps I'll use my toy example again.  I love toy examples.
23:05:11 <nacho> I'm just trying to implement the function such that I can also implemement a, binaryRo f (JDouble a) (JDouble b) = JBool (f a b)
23:05:21 <monochrom> id :: forall a. a -> a; id a = (a :: a)    In "a::a" the two "a"s are very different things.
23:05:36 <nacho> agreed.
23:06:00 <monochrom> One of the "a"s does not refer to a type.
23:07:03 <monochrom> Now let me think about your situation.
23:08:15 <monochrom> data Expr = JInteger Int | JDouble Double | JBool Bool  ?
23:08:22 <nacho> yes
23:09:06 <nacho> Either one works alone, if both methods for Integer and Double exist it whines
23:09:39 <monochrom> Your forall needs to be about f rather than about binaryRo.  In other words you are trying to do 2nd-rank polymorphism.  binaryRo :: (forall a. (Ord a) => a->a->Bool) -> Expr -> Expr -> Expr
23:14:26 <monochrom> (Rerun)  Your forall needs to be about f rather than about binaryRo.  In other words you are trying to do 2nd-rank polymorphism.  binaryRo :: (forall a. (Ord a) => a->a->Bool) -> Expr -> Expr -> Expr
23:15:06 <nacho> I got it :) In my googling attempts I ran into something mentioning 2nd-rank polymorphism, but I didn't give it much attention. I'll head back to it later :)
23:16:18 <nacho> I am still having a parse error on input => :(
23:18:28 <monochrom> It's a very common desire.  "I am taking in a function parameter f :: a->Bool, I am using it twice, once as Int->Bool, and then once as Char->Bool"
23:19:08 <monochrom> In C++ you write a template in which a parameter is also a template.  Nested templates.
23:19:18 <monochrom> That's all 2nd-rank polymorphism is.
23:19:27 <nacho> ah, I see!
23:19:44 <nacho> binaryRo :: (forall a. (Ord a) => a->a->Bool) -> Expr -> Expr -> Expr
23:20:19 <nacho> i've been rearranging the syntax to try and dodge this "unexepe
23:20:29 <nacho> argh..
23:20:40 <monochrom> unexpected end of line :)
23:20:41 <nacho> "parse error on input `=>'",
23:21:07 <nacho> :)
23:21:14 <nacho> is that type declaration correct?
23:21:48 <monochrom> Yes.
23:22:12 <monochrom> Need to turn on -fglasgow-exts or something, mind you
23:22:23 <nacho> monochrom: that was what i was JUST doing :)
23:23:36 <monochrom> Yes, I'm using "Windows Remote Assistance" to monitor your progress.
23:24:33 <shapr> SHAZAM!
23:24:35 <nacho> usually I develop in *nix. you caught me after my videogame session :'(
23:24:46 <monochrom> Haha
23:25:07 <shapr> I wish lambdabot could handle multiline quotes.
23:25:19 <monochrom> Use /
23:25:35 <shapr> You mean /n?
23:25:58 <ski> nacho : your example seems to load fine here, in both hugs and ghci
23:26:13 <nacho> ski: it does now with -fglasgow-exts
23:26:23 <nacho> monochrom: thanks a ton.
23:26:24 <ski> ah, nice
23:26:33 <nacho> parsec is really neat :)
23:27:06 <monochrom> I mean: Haskell is brilliant / GHC is radiant / shapr is univalent / dons is conversant
23:28:00 <monochrom> (why is shapr univalent?  because he unicycles)
23:28:20 <Stinger_> oh, so he doesnt have one electron in his outer shell?
23:28:43 <monochrom> please don't try to be too scientific about it :)
23:40:47 <zeeeeee> is there a library with an efficient histogram implementation usable from pure code? (e.g. a ([a] -> [(a,Int)]) implemented in ST?) or other such problems that tend to favor imperative languages, e.g. reverse-permutation?
23:46:31 <xic> i imagine that openFile is implemented using fopen on unix?
23:47:29 <nacho> monochrom:  if I wanted that type declaration to also include members of Eq what would I have to do? Or is a seperate function required?
23:48:34 <monochrom> Doesn't (Ord a) already grant you (Eq a)?
23:49:30 <monochrom> But let's say,  myfunc :: (forall a. (Ord a, Show a) => a->a->Bool) -> Expr -> ...  is valid.
23:49:35 <nacho> monochrom: well, perhaps. when I through in Booleans it went kaput
23:49:50 <nacho> I did try that, i think...
23:49:54 <zeeeeee> is there any sort of 'hashable' class i can derive, so that i don't have to write my own hash functions? (furthermore, are there any hash functions beside hashint and hashstring in the stdlib?)
23:51:20 <nacho> oh i see, the type of || is rather strict.
