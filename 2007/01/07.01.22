00:00:14 <LoganCapaldo> undefined is fun
00:00:32 <nmessenger> aye!
00:00:36 <int-e> @type undefined :: a -> (a, b)
00:00:37 <lambdabot> a -> (a, b) :: forall a b. a -> (a, b)
00:00:53 <nmessenger> it doesn't exist, so it can have any type!
00:00:58 * nmessenger simplifies things a little
00:01:12 <nmessenger> :t let f = f in f
00:01:14 <lambdabot> forall t. t
00:01:42 <int-e> @type undefined :: Int#
00:01:44 <lambdabot> Not in scope: type constructor or class `Int#'
00:02:03 <int-e> sniff. but that wouldn't work because the kinds * and # don't match.
00:02:31 <nmessenger> # is a kind?
00:02:38 <int-e> @type undefined :: GHC.Prim.Int#
00:02:39 <lambdabot>     Couldn't match kind `#' against `*'
00:02:40 <lambdabot>     When matching the kinds of `GHC.Prim.Int# :: #' and `a :: *'
00:02:48 <int-e> :k GHC.Prim.Int#
00:02:50 <lambdabot> #
00:02:53 <int-e> in GHC it is
00:03:00 <int-e> it's the kind of unboxed types
00:03:12 * nmessenger never really understood the '#' thingy
00:03:42 <nmessenger> :k (# Int, Char #)
00:03:44 <lambdabot> (#)
00:03:59 <int-e> :l (->)
00:04:01 <int-e> :k (->)
00:04:03 <lambdabot> ?? -> ? -> *
00:04:09 <LoganCapaldo> @type let f = undefined in f + 2
00:04:11 <int-e> lots of confusion :)
00:04:11 <lambdabot> forall a. (Num a) => a
00:04:29 <LoganCapaldo> > let f = undefined in f + 2
00:04:31 <lambdabot>  Undefined
00:04:40 <nmessenger> @type undefined :: Num a => a -- even better LoganCapaldo :P
00:04:42 <lambdabot> Num a => a :: forall a. (Num a) => a
00:05:15 <LoganCapaldo> first day of classes in like 4 hours
00:05:19 <LoganCapaldo> good night
00:05:27 <LoganCapaldo> ;)
00:05:30 <nmessenger> 'night
00:07:32 * int-e found the comments in http://darcs.haskell.org/ghc/compiler/types/Type.lhs helpful to understand the various kinds (search for 'kind stuff')
00:07:53 * nmessenger reads
00:07:54 <int-e> well, the tree there in particular.
00:08:12 <int-e> because it explains the weird kind of (->)
00:09:00 <int-e> Hmm, I thought there were more comments there *g*
00:10:20 <nmessenger> :k forall a. a
00:10:22 <lambdabot> *
00:37:18 <nornagon> ?pl foo (Either a b) = a
00:37:19 <lambdabot> (line 1, column 18):
00:37:19 <lambdabot> unexpected "="
00:37:19 <lambdabot> expecting variable, "(", operator or end of input
00:38:00 <nmessenger> ?pl \(Left a) -> a
00:38:00 <lambdabot> (line 1, column 8):
00:38:00 <lambdabot> unexpected "a"
00:38:00 <lambdabot> expecting operator or ")"
00:38:02 <nornagon> ?pl \(Either a b) -> a
00:38:03 <lambdabot> (line 1, column 10):
00:38:03 <lambdabot> unexpected "a"
00:38:03 <lambdabot> expecting operator or ")"
00:38:11 <nornagon> oh
00:38:22 <nornagon> i guess it doesn't do pattern matching?
00:39:23 <nmessenger> ?pl \x -> case x of Left x' -> x'
00:39:23 <lambdabot> (line 1, column 25):
00:39:24 <lambdabot> unexpected ">" or "-"
00:39:24 <lambdabot> expecting variable, "(", operator or end of input
00:39:29 <nmessenger> ?pl \x -> case x of {Left x' -> x'}
00:39:29 <lambdabot> (line 1, column 17):
00:39:30 <lambdabot> unexpected "{"
00:39:30 <lambdabot> expecting variable, "(", operator or end of input
00:39:33 <nmessenger> apparently not
00:40:51 <nmessenger> ?hoogle Either a b -> a
00:40:52 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
00:42:00 <nmessenger> ?type either id undefined
00:42:01 <lambdabot> forall a b. Either a b -> a
00:42:34 <nmessenger> ?type (\(Left x) -> x) -- is probably better
00:42:36 <lambdabot> forall a b. Either a b -> a
01:00:59 <Masklinn> Good morning #haskell
01:01:39 <psnl> good morning
01:19:34 <dcoutts> dons, I was thinking of a couple lambdabot plugins,  a @desugar one, much like undo but more general, eg it'd do list comps. Also @unmtl to expand and simplify mtl monad transformers
01:20:21 <kolmodin> hah, I'd like unmtl :)
01:21:18 * kolmodin gets some coffee
01:24:26 <dcoutts> syntaxfree, btw, you're right. Data.ByteString.Lazy could well have been called Data.ByteStream
01:25:22 <dcoutts> kolmodin, @unmtl StateT ByteString (ContT [ByteString] IO) a
01:59:52 <psnl> is the history of haskell paper online?
02:03:58 <Korollary> http://haskell.org/haskellwiki/History_of_Haskell
02:04:00 <lambdabot> Title: History of Haskell - HaskellWiki
02:04:40 <Korollary> err
02:04:56 <Korollary> I have seen it myself, so it was online
02:05:09 <dcoutts> I think it may no longer be online
02:06:06 <psnl> dang
02:06:22 <int-e> psnl: http://www.haskell.org/pipermail/haskell-cafe/2007-January/021500.html
02:06:24 <lambdabot> Title: [Haskell-cafe] seq (was: Article review: Category Theory), http://tinyurl.com/2e4bc5
02:07:16 <psnl> dang, I was hoping to read it before wednesday
02:07:36 <psnl> oh well, thanks
02:09:11 <Syzygy-> Discovered last week that operads are monads. I -REALLY- have to do a writeup on 'operads for the functional programmer'.
02:09:27 <Korollary> what's an operad?
02:11:27 <kolmodin> dcoutts: exactly
02:37:59 <nornagon> for type constructors, can you make them infix operators in pattern matches using ``?
02:38:13 <nornagon> foo (a `mycons` b) = ..
02:38:59 <vincenz> Hello, does anyone know what kind of latex environment is used for displaying haskell code when using lhs -> latex
02:39:38 <swiert> vincenz: \begin{code} ... \end{code}
02:40:29 <vincenz> swiert: alright and what is the definition of this custom environment based on?
02:42:04 <swiert> vincenz: it's not based on any environment - it just tells the lhs2TeX preprocessor to convert the code to latex.
02:42:46 <vincenz> hmm, I think you might have misunderstood my original question.  Let me reformulate, I am curious what sort of environment is used in latex for displaying this code eventually.
02:43:08 <swiert> vincenz: are you using lhs2Tex?
02:43:20 <vincenz> swiert: no I am not
02:43:27 <kosmikus> vincenz: you can choose your own
02:43:40 <kosmikus> vincenz: there's no single right answer to your question
02:43:56 <vincenz> No, but there's probably a "pretty good' answer.
02:45:01 <kosmikus> vincenz: you could probably use some sort of verbatim environment, probably using fancyvrb.sty ...
02:45:03 * vincenz is mostly using align* for his structural rules, though not too happy as it tends to overconsume space, and for the pseudocodde, not sure if I should use a listings or stick to align and use the mathematical look.
02:45:20 <kosmikus> vincenz: there are also a couple of style files that provide code environments suitable for literate Haskell
02:45:36 <kosmikus> vincenz: but I haven't really looked at the much because lhs2TeX does what I want ;)
02:45:41 <vincenz> kosmikus: where might I find these? (and do they allow for pseudomathematical notation?)
02:46:55 * psnl giggles at the haskell naming scheme
02:47:27 <apfelmus> vincenz: http://haskell.org/haskellwiki/Libraries_and_tools/Program_development#TeX
02:47:30 <lambdabot> Title: Libraries and tools/Program development - HaskellWiki, http://tinyurl.com/y6kosp
02:47:39 <vincenz> Thank you
02:48:36 <nornagon> ?pl (\a b -> fromInteger a + b)
02:48:37 <lambdabot> (+) . fromInteger
02:48:48 <vincenz> And anyone have any suggestion for a better way to lay out \inference{} rules than with align*?
02:49:21 <nornagon> ?pl (\a -> a . fromInteger)
02:49:22 <lambdabot> (. fromInteger)
02:49:26 <vincenz> I know this is not a latex channel, but given the high density of CS phd students in this channel :)
02:52:09 <dcoutts> kosmikus, we might switch to Helium for the first practical in the Oxford FP course. We were thinking about it before but I also bumped into Jurriaan Hageat POPL and we talked about it.
02:52:32 <apfelmus> vincenz: i don't know. maybe you can look at the .tex source code for some paper involving inference rules?
02:52:32 <apfelmus> @google LaTeX for Logicians
02:52:35 <lambdabot> http://www.phil.cam.ac.uk/teaching_staff/Smith/LaTeX/
02:52:35 <kosmikus> dcoutts: nice :)
02:52:35 <lambdabot> Title: LaTeX for Logicians
02:52:40 <resiak> @where helium
02:52:41 <lambdabot> http://www.cs.uu.nl/research/projects/helium/
02:52:50 <vincenz> apfelmus: ah cool, just have to know where to look :)
02:53:08 <vincenz> apfelmus++ -- thanks
02:53:14 <resiak> dcoutts: Why, OOI?
02:53:20 <apfelmus> you're welcome :)
02:53:33 <dcoutts> resiak, excellent error messages
02:53:45 <resiak> ah, yes.  I've just seen that on theFeatures page :)
02:53:49 <dcoutts> kosmikus, aye, hopefully our teaching lab will switch to x86/linux so we'll not have to make llvm work on sparc/solaris :-)
02:54:33 <dcoutts> resiak, but only for the first practical since Helium isn't full Haskell so can't compile libs like wx/gtk etc
02:54:57 <resiak> Right, and you need that for your fancy l-systems :)
02:55:02 <dcoutts> @arr!
02:55:02 <lambdabot> Yo ho ho, and a bottle of rum!
02:56:08 <kosmikus> dcoutts: how was your talk?
02:56:47 <dcoutts> kosmikus, oh it went well I think. We won the best practical paper award which included 100 euros drinking money :-)
02:57:34 <kosmikus> already spent? :)
02:57:40 <dcoutts> of course!
02:57:49 <dcoutts> nice french food and wine for 3 :-)
02:58:05 <dcoutts> and we plotted our next paper(s)
02:58:09 <vincenz> par blue! ze french cheese iz very good
02:58:19 <kosmikus> dcoutts: congratulations
02:58:26 <dcoutts> vincenz, but of course! :-)
02:58:47 <dcoutts> kosmikus, ta, yeah I'm feeling quite enthused.
02:59:18 <dcoutts> kosmikus, we talked to some erlang people about binary serialisation / parsing which was interesting
02:59:43 <psnl> dcoutts: well done
03:00:07 <dcoutts> they have this nice pattern matching syntax for byte/bit strings which makes parsing binary formats/protocols a breeze
03:00:24 <dcoutts> psnl, ta
03:01:46 <psnl> the history of haskell papaer is cool
03:04:10 <dcoutts> psnl, where did you find it?
03:04:45 <psnl> int-e sent me a copy
03:04:51 <psnl> @karma+ int-e
03:04:52 <lambdabot> int-e's karma raised to 30.
03:05:03 <dcoutts> ah ok
03:05:47 <int-e> oh, cheap karma, thanks ;)
03:25:16 <psnl> is the term "embiguous" a typo, or a real word?
03:25:56 * psnl infers typo
03:38:29 <Masklinn> should be "ambiguous" I think
03:39:29 <Masklinn> psnl > you should use google as an orthograph checker. Or use a real one (a real one works better, but google is easy and usualy works fairly well).
03:40:03 <psnl> googling for research words is normally a fun process
03:42:29 <vegai> @spell ambiguous
03:42:29 <Masklinn> well it is fun for a few quite badly specified values of fun
03:42:30 <lambdabot> ambiguous
03:42:39 <Masklinn> @spell embiguous
03:42:40 <lambdabot> ambiguous ambiguously embargo's embargoes ambitious
03:42:43 <Masklinn> ooooh
03:42:47 <Masklinn> shiny
04:00:14 <syntaxfree> so, um, back to hacking.
04:00:27 <syntaxfree> how do I install zlib and readline bindings for ghc 6.6 again?
04:00:39 <syntaxfree> (btw, how do I get one specific file from a darcs repository?)
04:03:46 <kowey> syntaxfree: that feature doesn't exist yet (you mean retrieve a version of a specific file, right?)
04:04:18 <syntaxfree> the latest one will suffice.
04:04:29 <kowey> oh, then wget or cp should do
04:04:29 <syntaxfree> I don't need an arbitrary file.
04:04:50 <syntaxfree> hmm. you're right. Dummy me :)
04:05:18 <syntaxfree> I still don't have an intuitive feel for this darcs business.
04:05:47 <syntaxfree> I'm hacking on a local copy of lambdabot for personal use. If I ever manage to compil;e  it.
04:05:54 <kowey> http://en.wikibooks.org/wiki/Understanding_darcs <-- tries to transmit a mental model for darcs
04:06:32 <syntaxfree> there isn't a well-defined logic for maintaining my own changes and getting _some_ changes from the daily hacking the official lambdabot gets.
04:08:09 <syntaxfree> That is, I can't fork lambdabot and transfer features between two versions transparently. Maybe we should get a VCS that understands Haskell inside out.
04:08:12 <syntaxfree> (can look for a function and chase what it depends upon, etc.)
04:08:47 <syntaxfree> Yes,  I know Im asking for a lot.
04:10:08 <kowey> i personally would be happy if we solved the core patch theory stuff, and the engineering/robustness issues
04:10:14 <nornagon> @spell woolly
04:10:15 <lambdabot> woolly
04:10:36 <syntaxfree> I have only looked superficially at patch theory, but it sure looks like group theory.
04:11:10 <syntaxfree> anyway, I'm trying to do some lambdabot hacking as a first step into getting involved with some project.
04:11:15 <syntaxfree> If I could only get it to compile!
04:11:33 <syntaxfree> GHC doesn't know about readline and zlib here. I might need to install bindings.
04:11:55 <syntaxfree> I tried to remove readline dependencies manually from the source, but zlib seems harder to yank out.
04:11:59 <dcoutts> syntaxfree, yes, lambdabot now deps on the zlib and binary packages
04:12:08 <dcoutts> @where zlib
04:12:08 <lambdabot> darcs get http://haskell.org/~duncan/zlib
04:12:26 <dcoutts> syntaxfree, no need to yank it out, just download and install
04:12:50 <syntaxfree> it also seems i don't have something called Binary.
04:12:55 <beschmi> @tell sorear shim should work with lambdabot sources now without changing the cabal file
04:12:55 <lambdabot> Consider it noted.
04:12:56 <dcoutts> @where binary
04:12:56 <lambdabot> http://darcs.haskell.org/binary
04:13:03 <dcoutts> syntaxfree, ^^
04:13:11 <syntaxfree> :)
04:13:15 <syntaxfree> thanks!
04:13:21 <dcoutts> np
04:13:53 <dcoutts> syntaxfree, note that binary is still under development so lambdabot may or may not compile against the latest version of the binary package
04:14:23 <syntaxfree> ./Setup.hs configure sets up Cabal to use the ghc copy that is in /sw/bin
04:14:27 <syntaxfree> (that is, the Fink version)
04:14:36 <syntaxfree> I want it to use the one in /usr/local/bin
04:14:54 <syntaxfree>  /sw/bin/hsc2hs: line 18: /sw/lib/ghc-6.2/hsc2hs-bin: No such file or directory
04:15:04 <syntaxfree> oh well, that's a very broken ghc indeed.
04:15:13 <syntaxfree> I have 6.6 in /usr/local/bin
04:16:56 <syntaxfree> bah. Annoying.
04:17:01 <matthew_-> how can I ask lambdabot for the src of instance Monad [] ?
04:20:07 <dcoutts> syntaxfree, set the $PATH to have /usr/local/bin before /sw/whatever
04:20:42 <dcoutts> syntaxfree, or use ./Setup.hs --with-compiler="/usr/local/bin/ghc"
04:20:45 <dcoutts> erm
04:20:50 <dcoutts> ./Setup.hs configure --with-compiler="/usr/local/bin/ghc"
04:22:47 <syntaxfree> gah.
04:22:58 <syntaxfree> I both changed $PATH and did that.
04:23:05 <syntaxfree> it's STILL looking for hsc2hs in /sw/bin
04:23:09 <syntaxfree> hell.
04:24:15 <ivanm> I had lambdabot and GOA installed and setup on my computer, but recently lambdabot keeps crashing after loading all the plugins.  Any ideas why?
04:26:55 <syntaxfree> Patches from patch theory look like an abelian group to me.
04:28:09 <trurl_> matthew_-: if you find out, let me know :)
04:28:31 <kowey> syntaxfree: the #darcs folks might be interested, or the darcs-conflicts mailing list
04:28:52 <syntaxfree> I'm sure there's people there who know more group theory than I do.
04:28:58 <apfelmus> syntaxfree: patch theory as in quantum darcs? it's not very accurate. there is a paper from Daan Leijen et.al. about a more rigourous formulation
04:29:13 <syntaxfree> I've been learning it for two weeks now, so I'm kinda victim to the Zadeh principle here.
04:29:38 <dcoutts> syntaxfree, do you have hsc2hs installed in /usr/local/bin ? what does 'which hsc2hs' report?
04:29:44 <apfelmus> Zadeh?
04:30:07 <syntaxfree> wah, /sw/bin is still in $PATH.
04:30:20 <syntaxfree> Zadeh = Lofi Zadeh, the fuzzy logic guy.
04:31:37 <syntaxfree> oh. the Zadeh principle is the nails and hammer thing. When you have a hammer in hand, everything looks like a nail.
04:32:32 <apfelmus> what does Zadeh have to do with darcs?
04:33:08 <syntaxfree> that patches seem to form an abelian group, but that might just be because I'm struggling with group theory atm.
04:33:48 <syntaxfree> grrr.
04:33:50 <apfelmus> huh? Zadeh = fuzzy, abelian groups = non-fuzzy (no offense :)
04:34:06 <syntaxfree> Zadeh principle = "When you have a hammer in hand, everything looks like a nail."
04:34:16 <apfelmus> ah.
04:34:43 <syntaxfree> Anyway, I grr'ed at Cabal.
04:34:59 <syntaxfree> I can't change my $PATH variable! I used to know this!
04:35:09 <psnl> export PATH=newpath
04:35:13 <apfelmus> export $PATH=/usr/bin
04:35:18 <apfelmus> *PATH
04:35:37 <psnl> or PATH=/my/ghc cabal dostuff
04:35:49 <psnl> which only does it for the cabal command
04:36:09 <vincenz> or "cd newpath"
04:36:18 <ivanm> You might have to refresh.restart your terminal session
04:36:35 <psnl> favorite use of haskell?
04:36:37 <apfelmus> syntaxfree: well, the group aspect is there but not every patch has an inverse.
04:36:57 <vincenz> so it's a fuzzy group
04:37:06 <syntaxfree> haha.
04:37:11 * psnl is writing up bits of a talk on haskell
04:37:21 <syntaxfree> http://en.wikibooks.org/wiki/Understanding_darcs/Patch_theory
04:37:29 <syntaxfree> Patch property: Every patch must have an inverse
04:37:36 <apfelmus> it's wrong
04:37:38 <dcoutts> psnl, nice, where are you presenting?
04:37:44 <kowey> (note also the attempted category theory formulation of patch theory in the talk page)
04:38:06 <psnl> dcoutts: its part of my 3rd year project.
04:38:36 <kowey> apfelmus: do you have an example of a patch without an inverse?
04:38:48 <syntaxfree> compiling Codec/Compression/Zlib/Stream_hsc_make.c failed
04:38:48 <syntaxfree> command was: /usr/local/bin/ghc-6.6 -c Codec/Compression/Zlib/Stream_hsc_make.c -o Codec/Compression/Zlib/Stream_hsc_make.o
04:38:54 <apfelmus> kowey: delete file "hahahah"
04:38:56 <vincenz> Anyone know what a 'top' element is?
04:38:58 <syntaxfree> (this when trying to build zlib bindings for GHC)
04:39:19 <kowey> apfelmus: wouldn't its inverse be add file "hahahah"?
04:39:59 <kowey> (or rather deleting file probably translates to "remove file contents" + "remove file" --(inverse)--> "add file" + "add contents")
04:40:06 <apfelmus> kowey: ah, no wait, you're right. it's entirely fine to invert every patch. but you cannot compose arbitrary patches
04:40:29 <apfelmus> sorry for mixing those two
04:40:42 <vincenz> how would I get a top element from domain theory into haskell code?
04:40:46 <vincenz> Maybe a?
04:40:48 <vincenz> and use Nothing as top?
04:41:23 * kowey is relieved
04:41:32 <vincenz> kowey: tmi
04:41:40 <kowey> (i think the inverse thing is kind of... important)
04:41:48 <apfelmus> :)
04:42:58 * kowey will be relieved more discreetly next time
04:43:12 <dcoutts> syntaxfree, what was the error message for the zlib issue?
04:43:33 <syntaxfree> compiling Codec/Compression/Zlib/Stream_hsc_make.c failed
04:43:34 <syntaxfree> command was: /usr/local/bin/ghc-6.6 -c Codec/Compression/Zlib/Stream_hsc_make.c -o Codec/Compression/Zlib/Stream_hsc_make.o
04:43:50 <syntaxfree> ah, no, not that.
04:43:50 <syntaxfree> sorry :)
04:43:53 <dcoutts> ok so that is the command that failed, was there any error message?
04:43:57 <syntaxfree> well, yes, that.
04:44:04 <syntaxfree> no specific ghc error comes up.
04:44:12 <dcoutts> if you run that manually, does it report anything
04:44:31 <syntaxfree> ghc-6.6: could not execute: gcc
04:44:37 <syntaxfree> ah, of course.
04:44:40 <syntaxfree> gcc is in /usr/bin
04:44:43 <dcoutts> ah, perhaps you messed up your path too much :-)
04:45:15 <dcoutts> you probable want to use the default path and just prepend /usr/local/bin
04:45:42 <dcoutts> ie start a new terminal and : export PATH=/usr/local/bin:$PATH
04:46:01 <syntaxfree> *now* I got a GHC error.
04:46:01 <syntaxfree> !paste
04:46:01 <syntaxfree> @paste
04:46:01 <syntaxfree> paste!
04:46:01 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
04:46:01 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
04:46:03 * syntaxfree sighs
04:46:16 <syntaxfree> now I got an actual ghc error.
04:46:36 <musasabi> Was there a lambdabot plugin for watching darcs repos?
04:46:49 <hpaste>  syntaxfree pasted "zlib compilation error" at http://hpaste.ath.cx:8000/28
04:46:53 <vincenz> musasabi: yes
04:47:27 <musasabi> vincenz: what happened to it - at least lambdabot @list does not list it.
04:47:41 <dcoutts> syntaxfree, hmm, seems those constants are not declared in the zlib.h header file on your box.
04:47:44 <vincenz> musasabi: lambdabot is not compiled with it
04:47:55 <vincenz> musasabi: it's in there tho
04:47:57 <dcoutts> syntaxfree, could you email me your /usr/include/zlib.h
04:48:02 <syntaxfree> This is starting to frustrate me enough to want to give up.
04:48:15 <vincenz> musasabi: but it needs to be compiled with a specific path to watch, so it's not useful in the generic one-lambdabot-for-#haskell sense
04:48:17 <dcoutts> syntaxfree, you might be the first to build it on osx
04:48:30 <musasabi> ah.
04:48:43 <musasabi> thanks.
04:48:46 <vincenz> actually no, that's not true, you can add paths
04:48:53 <apfelmus> kowey: my thinking was that you can only append either "add file" and "delete file" to a repo
04:48:55 <vincenz> but yeah, by default it's not part of the build-process
04:48:59 <apfelmus> *and/or
04:49:27 <lisppaste2> syntaxfree pasted "zlib.h" at http://paste.lisp.org/display/35768
04:50:01 * syntaxfree wonders if there's a nice psychiatric diagnosis for people who give up when frustrated enough by details.
04:50:32 <nornagon> 'normal'
04:50:40 <vincenz> 'nornal'
04:51:10 <matthew_-> insufficiently stubborn?
04:51:17 <kowey> apfeulmus: right... the decomposition into add file + add its hunks makes the inverse thing more apparant?
04:51:45 <kowey> opps (s/apfeulmus/apfelmus/)
04:53:26 * ivanm still waiting if anyone can help him with his lambdabot errors
04:53:31 <apfelmus> kowey: maybe that's not what i mean. it's just that forall repos . Either (add file) (delete file)
04:54:14 <dcoutts> syntaxfree, so the issue is that you've got an older version of zlib, however it's easily fixed. Just comment out the references to Z_BLOCK, Z_RLE and Z_FIXED in Codec/Compression/Zlib/Stream.hsc
04:54:25 <dcoutts> syntaxfree, I'll see about making that more automagic
04:55:18 <kowey> apfelmus: i don't think i understand... hmm... anyway, better concentrate on article i'm writing :-)
04:55:25 <kowey> apfelmus: let's pick this up some other time
04:55:33 <apfelmus> kowey: ok.
05:06:22 <Itkovian> vincenz: addiciting game you pasted Friday
05:06:42 <vincenz> :D
05:07:15 * ivanm got sick of waiting and is going to bed
05:07:16 <Vq^> what game?
05:08:12 <Itkovian> http://novelconcepts.co.uk/FlashElementTD/
05:08:14 <lambdabot> Title: Flash Element TD | Novel Concepts
05:08:17 <Itkovian> that game
05:08:30 <Itkovian> vincenz: I fail to get over 850 points though
05:08:45 <vincenz> ouch
05:28:46 <vincenz> Itkovian: I got around 120-160k
05:28:57 <Itkovian> Ouch
05:29:13 <vincenz> or 20-30k when I play it cleanly
05:29:20 <Itkovian> ah
05:29:23 <Itkovian> but still ...
05:29:41 <vincenz> cleanly in the sense of... I go for tech upgrades instead of sticking to lowly cannons so I can maximimze research in interest
05:29:56 <vincenz> Itkovian: two big points 1) make sure not to overspend on the early levesl, what with interest, it's exponential..
05:30:05 <vincenz> Itkovian: 2) don't research too much tech
05:31:06 <Itkovian> I never research on tech, well, only the first game
05:31:36 <vincenz> Itkovian: make sure not to overbuy cannons
05:31:39 <bakert> Howdy folks.  How do you feel about leaving calls to Debug.Trace.trace in live code?
05:31:56 <vincenz> bakert: eww?
05:32:10 <Itkovian> I buy two the first levels
05:32:18 <bakert> vincenz, i thought you might say that.
05:33:04 <bakert> I guess I need to replace this:
05:33:05 <bakert> return (trace (seErrorMsg e) False)
05:33:12 <bakert> with something a bit nicer.
05:33:26 <bakert> Not quite sure how to proceed though.
05:33:50 <bakert> This is an app that gets run at the commandline so I could just output something to stderr and return False.
05:33:53 <bakert> somehow
05:34:35 <dblhelix> any ghc experts present?
05:36:17 <bakert> My db routine returns IO Bool.  Which makes doing anything with the error I have caught tricky.  perhaps I need to catch my exception at a higher level.
05:36:19 <vincenz> kosmikus: you're the lhs2tex dev?
05:37:08 <Lemmih> dblhelix: Asking your question might be a good way to find out.
05:37:17 <bakert> but then other modules need to know about db-related stuff like catchSql and seErrormsg.  I don't like that.  What would you guys do?
05:37:18 <dblhelix> Lemmih: true :)
05:37:40 <dblhelix> anyone know how to inspect the results of ghc's sharing analysis?
05:37:57 <bakert> I could return a Maybe I suppose.  I do seem to use them for just about everything.
05:38:16 <bakert> No actually that doesn't gain me anything.
05:38:36 <bakert> I need to return Success or Failure ErrMsg.  Perhaps an Either?
05:38:45 <bakert> Never used an Either.  Is that an appropriate use?
05:39:35 <bakert> Looks good.  Left True | Right "Error Message" ???
05:39:45 <bakert> Does that make sense?
05:40:35 <ToRA> by convention i think it's Left "error" | Right value
05:40:53 <vincenz> How come lhs2tex is tryng to look at tex code outside of a {code} environment...
05:41:24 <ToRA> bakert: (from the library docs - mnemonic: "right" also means "correct")
05:41:40 <bakert> ToRA, oh thanks.  But that's a legit use of it?  Even when I don't really have anything to say in the "correct" case?
05:42:22 <ToRA> bakert: no idea, I've only ever used Either when dealing with Parsec...
05:42:37 <ToRA> bakert: it sounds like you want an inverted Maybe data structure...
05:43:11 <dblhelix> vincenz: it also looks at \begin{spec}...\end{spec}, @...@, and |...|
05:43:20 <bakert> ToRA, that's about the size of it.  Either the INSERT INTO succeeded or I want an error I can print to stderr.
05:43:37 <vincenz> dblhelix: oh the | ..
05:43:41 <ToRA> bakert: Maybe errMsg = Just errMsg | Nothing
05:43:42 <vincenz> dblhelix: can I tell it to ignore |
05:43:42 <dblhelix> vincenz: and, of course, %...
05:44:00 <bakert> ToRA, oooh.  invertedly horrible.  is that haskellish?
05:44:01 <dblhelix> vincenz: no, but you can escape it with ||
05:44:05 <kosmikus> vincenz: no, you can't
05:44:17 <vincenz> doh
05:44:20 <bakert> ToRA, i really don't like that!
05:44:27 <ToRA> bakert: erm, well if you think "Maybe there's an error" then it makes some form of sense...
05:44:31 <dblhelix> or is that only inside |...|?
05:44:44 * vincenz has tons of |
05:44:48 <musasabi> "Either ErrMsg ()" is probably cleaner.
05:44:50 <vincenz> *** Error in file ./foo.lhs line 53:
05:44:50 <vincenz> `inline' is not defined;
05:44:50 <vincenz> perhaps you forgot to include "lhs2TeX.fmt"?
05:44:52 <bakert> ToRA, yeah but then it's like i'm calling the function because i'm interested in the error kind of.
05:44:52 <vincenz> ack
05:44:56 <vincenz> \mathlig{|}{\;|\;}
05:45:00 <vincenz> here is an example
05:45:06 <vincenz> it borks on that line
05:45:21 <bakert> musasabi, you mean Right () | Either "sql err msg" kind of thing?
05:45:44 <bakert> I think I prefer that despite the unnecessary value floating around.
05:45:51 <ToRA> i'd probably go with musasabi
05:45:52 <musasabi> bakert: yes. Right () = success, Left ErrMsg = error.
05:46:26 <bakert> musasabi, ToRa, vincenz, thanks for your help.  going to go stick an Either in there and get rid of my trace.  Thanks!
05:46:30 <musasabi> and easy to change if there is a value to be returned, and with one instance declaration a monad.
05:46:34 <kosmikus> vincenz: the error is what it says. you need to include either "polycode.fmt" (preferred with >=1.11) or "lhs2TeX.fmt" ...
05:47:11 <kosmikus> vincenz: Regardings the |'s, if you really have lots, then I don't have a really good solution for you. I can hack lhs2TeX to make the verbatim escape char configurable.
05:47:35 <kosmikus> vincenz: and the inline code escpae char as well.
05:47:42 <bakert> woah, do i not understand Either.  I can't have a type of:
05:47:58 <bakert> Double ->IO Either?
05:48:09 <bakert> Either is a typeclass not a type?
05:48:13 <ToRA> Double -> IO Either String ()
05:48:24 <vincenz> kosmikus: it'd be nice if you could just turn it off, like "I only want {code} environments, -don't- touch the rest".  I don't have a .lhs document but a .tex document, but I'd like to use lhs2tex to layout a particular piece of pseudocode
05:48:31 <bakert> ToRA, ah i see i give both possibilities.  thanks
05:48:51 <ToRA> may possibly need Double -> IO (Either String ())
05:49:19 <bakert> yeah looks like it.  thanks
05:50:31 <kosmikus> vincenz: if it's only one piece, then you can split your document into multiple parts and not run lhs2TeX on the parts that don't contain Haskell
05:51:01 <vincenz> perhaps
06:01:58 <rhican> i'm playing with some Haskell code, is Stack a standard type in haskell or should it be defined somewhere
06:02:36 <Lemmih> rhican: I don't think it's part of the standard libraries.
06:02:43 <dcoutts> Stack isn't standard but people often implement stacks with just and ordinary Haskell list
06:02:51 <dcoutts> and/an
06:02:55 <vincenz> blegh, faulty packages, installing lhs2tex screwed up my latex distro
06:03:30 <rhican> ah probably this line: newtype Stack = Stack [Integer]  (i'm completely new)
06:03:52 <vincenz> rhican: yep
06:04:15 <base3> hi there,
06:04:18 <rhican> would i be able to print it just with print( stackvar ) ? (i want to see what is happening)
06:04:39 <base3> i'm trying to compile something using ghc, which depends on a Cabal package
06:05:07 <dcoutts> rhican, in hugs or ghci, just typing the value will evaluate and print it
06:05:20 <base3> iirc correctly there is a way of getting ghc to manage all the library dependencies by itself?
06:05:38 <Lemmih> base3: --make?
06:06:02 <base3> thanx, yeah couldn't remember that
06:06:23 <rhican> dcoutts, tnx, though i'm looking for something that preferably isn't interactive
06:06:54 <dcoutts> rhican, well a standalone Haskell prog is just a Main.hs file that defines a main function
06:07:09 <dcoutts> rhican, however for devlopment the interactive mode is really good
06:07:43 <dcoutts> eg load hugs or ghci with the module you've been given and try: Stack [4,5]
06:07:50 <Masklinn> rhican > You need to tell Haskell that your type derives from `Show`, and that it can therefore be printed
06:08:07 <Masklinn> (if the declaration isn't there already I mean)
06:08:12 <rhican> dcoutts, k i'll try it when ghc finishes compiling
06:08:34 <Masklinn> If you have "newtype Stack = Stack [Integer] deriving (Show)" then you're ok, otherwise you need to add the last part.
06:08:51 <rhican> Masklinn tnx i'll try that
06:09:16 <Masklinn> You can try checking what happens if you don't put the last part in though, it's interesting ;)
06:16:20 <chessguy> 'morning, haskellers
06:18:46 <Itkovian> hi all, i've implemented the rdpmc call alike to the recently rleased rdtsc lib, but the values I'm getting are way too high... i.e., the call seems to take a number of instructions that's about three orders of magnitude too large.
06:27:34 <chessguy> > let contains _ "" = False; contains "" _ = True; contains (x:xs) (y:ys) = ((x == y && contains xs ys) || contains (x:xs) ys) in contains "na" "banana"
06:27:36 <lambdabot>  True
06:27:43 <chessguy> > let contains _ "" = False; contains "" _ = True; contains (x:xs) (y:ys) = ((x == y && contains xs ys) || contains (x:xs) ys) in contains "na" "minoa"
06:27:45 <lambdabot>  False
06:29:29 <Masklinn> there's a bug in your implementation chessguy
06:29:30 <Saizan> you should reverse the order of the base cases i think
06:29:43 <Masklinn> > let contains _ "" = False; contains "" _ = True; contains (x:xs) (y:ys) = ((x == y && contains xs ys) || contains (x:xs) ys) in contains "na" "minona"
06:29:44 <chessguy> i thought there was a bug too, but i thought minoa would prove it
06:29:45 <lambdabot>  False
06:29:50 <Masklinn> nah
06:29:56 <Masklinn> the bug is when it starts matching but can't end
06:30:12 <chessguy> oh, i was thinking of a different problem
06:30:18 <Masklinn> oh ok
06:30:31 <chessguy> i don't like the last case of contains
06:30:56 <Masklinn> @hoogle startsWith
06:30:59 <lambdabot> No matches found
06:31:02 <chessguy> > let contains _ "" = False; contains "" _ = True; contains (x:xs) (y:ys) = ((x == y && contains xs ys) || contains (x:xs) ys) in contains "man" "miranda"
06:31:10 <dcoutts> rhican, no probs
06:31:13 <mux> @hoogle isSubstringOf
06:31:16 <lambdabot> No matches found
06:31:18 <lambdabot>  thread killed
06:31:24 <Masklinn> @hoogle substring
06:31:26 <lambdabot> No matches found
06:31:26 <mux> @hoogle substring
06:31:28 <lambdabot> No matches found
06:31:30 <mux> heh.
06:31:32 <chessguy> anyway, it's not my code, it was suggested to me
06:31:36 <mux> I *know* it exists
06:31:43 <chessguy> @hoogle subString
06:31:45 <lambdabot> No matches found
06:31:49 <chessguy> @hoogle sub
06:31:50 <lambdabot> Text.Html.sub :: Html -> Html
06:31:50 <lambdabot> Prelude.subtract :: Num a => a -> a -> a
06:31:50 <lambdabot> Data.PackedString.substrPS :: PackedString -> Int -> Int -> PackedString
06:32:09 <mux> @hoogle isPrefix
06:32:13 <lambdabot> List.isPrefixOf :: Eq a => [a] -> [a] -> Bool
06:32:17 <mux> aaah, here it is
06:32:26 <mux> from this you can define isSubstringOf easily
06:32:33 <chessguy> anyway, i definitely don't like this code
06:32:40 <mux> any isPrefixOf (tails x)
06:32:44 <mux> or something
06:32:58 <Masklinn> by the way does Haskell support ++ patterns?
06:33:42 <kosmikus> Masklinn: no
06:33:45 <dgriffi3> @hoogle tails
06:33:46 <lambdabot> List.tails :: [a] -> [[a]]
06:33:47 <lambdabot> Text.PrettyPrint.HughesPJ.TextDetails :: data TextDetails
06:33:55 <mux> > tails "abcd"
06:34:02 <lambdabot>  ["abcd","bcd","cd","d",""]
06:35:04 <ndm> @seen dons
06:35:05 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7h 42m 40s ago.
06:35:34 <ndm> @tell dons I just talked Colin through creating a SmallCheck repo, and have just sent him a patch for a Cabal file
06:35:35 <lambdabot> Consider it noted.
06:36:14 <chessguy> ?localtime dons
06:36:16 <lambdabot> Local time for dons is Tue Jan 23 01:33:04 2007
06:37:03 <dcoutts> ndm, good work
06:37:19 <ndm> dcoutts, finally! have been trying to get this done for weeks
06:37:30 <Saizan> however that contains (bug fixed) is not a isSubStringOf, but rather a isOrderlyConteinedButNotNecessarilyContiguoslyIn
06:37:35 <chessguy> what's SmallCheck?
06:37:40 <ndm> hopefully we can have a Haddock/HsColour arangement for SmallCheck shortly as well
06:37:44 <ndm> (perhaps even a home page)
06:37:49 <dcoutts> that'd be nice
06:37:54 <ndm> chessguy: QuickCheck with enumeration instead of random testing - basically
06:37:58 <chessguy> Saizan, that's what i was trying to prove with my minoa example
06:38:22 <dcoutts> ndm, btw, kolmodin borrowed your syb binary code to do the same but for his binary lib
06:38:25 <ndm> chessguy: easier to write generators, better testing if you are working towards a proof, doesn't test the same range as quickcheck
06:38:32 <dcoutts> ndm, it works quite nicely
06:38:36 <ndm> dcoutts, cool :)
06:38:51 <ndm> dcoutts, i wanted to add the transitive closure property to it, but haven't had time yet
06:39:04 <dcoutts> ndm, what property?
06:39:07 <ndm> dcoutts - i think there is a common abstraction in there somewhere, which you could pull out and make it easier in future
06:39:08 <chessguy> ndm, meh, i was just messing around, not seriously coding. i don't even have haskell on this machi
06:39:10 <chessguy> ne
06:39:37 <ndm> dcoutts, imagine data Core = Core String [CoreData] [CoreFunc]
06:39:38 <dcoutts> ndm, I didn't look at the code in detail, I just noted that it was short :-)
06:40:01 <ndm> dcoutts, derive (undefined :: Core) would then derive for Core, and CoreData/CoreFunc etc transitively
06:40:11 <dcoutts> ndm, oh I see
06:40:12 <ndm> dcoutts, it was indeed - but took well over an hour to piece together
06:40:26 <ndm> handy for a big data sturcutre with lots of little things
06:40:29 <dcoutts> yeah
06:40:32 <ndm> and essential for Yhc.Core :)
06:40:35 <dcoutts> like an AST
06:40:36 <dcoutts> yep :-)
06:40:38 <ndm> indeed
06:40:43 <ndm> well, not quite essential
06:40:57 <ndm> I want to replace Yhc.Core with Data.Binary as soon as you release it
06:41:18 <dcoutts> ndm, right'o
06:41:39 <ndm> dcoutts, are you faster than hPutChar stuff?
06:41:49 <dcoutts> ndm, vastly
06:41:56 <ndm> dcoutts, wow!
06:41:58 <|Lupin|> Hi haskellers
06:41:59 <dcoutts> ndm, hPutChar takes the Handle lock every char
06:42:05 <ndm> dcoutts, ah, that explains it
06:42:07 <chessguy> hi |Lupin|
06:42:13 <ndm> dcoutts, even for reading?
06:42:18 <dcoutts> ndm, for serialisation we're getting between 10 and 150 MB/s
06:42:20 <dcoutts> ndm, yes
06:42:32 <|Lupin|> I'm looking for rticles on type-classes vs. parameterized modules as implemented in Caml. Any pointers, please ?
06:42:34 <chessguy> that's a big interval
06:42:36 <ndm> dcoutts, looks like my BinaryDefer library will have to be written on top of Data.ByteString then...
06:42:45 <ndm> * Data.Binary
06:42:48 <dcoutts> chessguy, yeah there are reasons
06:42:57 <dcoutts> it's all low level stuff
06:43:14 <dcoutts> ndm, do you need 2 passes ?
06:43:25 <dcoutts> for writing stuff out
06:43:45 <ndm> dcoutts, kind of - certainly need to do seeks etc on the file
06:44:02 <ndm> dcoutts, impossible to write as multiple passes even, come to think of it
06:44:25 <ndm> dcoutts, writing can be happily slow with DeferedBinary, the reading is what wants to be super-fast
06:44:25 <dcoutts> ndm, right, so that's a little hard when you are trying to produce a pure value and not hold the whole thing in memory at once
06:44:31 <dcoutts> sure
06:44:42 <ndm> writing expects to be fully strict and fully IO
06:44:54 <ndm> reading wants quick and pure (unsafePerformIO pure)
06:45:01 <ndm> are you quicker at reading on Hugs?
06:45:06 <dcoutts> no idea
06:45:14 <dcoutts> it compiles in Hugs, dunno about perf
06:45:15 <ndm> that would be interesting to see
06:45:39 <dcoutts> the tradeoffs for an interpreter are quite different I expect
06:45:41 <ndm> since Hoogle is developed in Hugs ;)
06:45:49 <ndm> yes, and no locking on the buffer
06:46:00 <dcoutts> code simplicity becomes most important I'd expect
06:46:14 <dcoutts> rather than designing things to inline/expand to perfect machine code :-)
06:46:49 <ndm> indeed - Hugs is a good performance test
06:47:08 <|Lupin|> I'm looking for rticles on type-classes vs. parameterized modules as implemented in Caml. Any pointers, please ?
06:47:11 <dcoutts> well, that's debatable for this kind of low level code
06:47:19 <ndm> true, but Hugs is fun :)
06:47:23 <|Lupin|> (for kowey, sorry)
06:47:26 <dcoutts> true
06:47:29 <ndm> (and what i develop in all day long)
06:47:44 <earthy> luping: look up stuff by oleg
06:48:01 <dcoutts> ndm, it's certainly a requirment that it compile with hugs, but making it perform well with hugs... it's not a priority.
06:48:13 <|Lupin|> earthy: okay, thanks.
06:48:14 <earthy> ?where oleg
06:48:14 <lambdabot> I know nothing about oleg.
06:49:30 <ndm> dcoutts, i can understand that - as long as it doesn't actually kill hugs with speed at 5/10 times slowdown over hPut is fine
06:49:34 <kowey> ?where+ oleg http://okmij.org/ftp/
06:49:35 <lambdabot> Done.
06:49:40 <kowey> (was that right?)
06:50:08 <ndm> ?where oleg
06:50:09 <lambdabot> http://okmij.org/ftp/
06:50:13 <ndm> kowey: yes
06:50:49 <dcoutts> ndm, I can't promise it, I don't have any intuition for how it'd compare to hGet/PutChar in Hugs. We'll have to see how it goes.
06:51:16 <ndm> dcoutts, fair enough - i guess if it really is that much faster with GHC DeferredBinary has to make the jump
06:51:27 <ndm> haskell.org would probably like a faster hoogle :)
06:51:32 <dcoutts> aye :-)
06:51:48 <ndm> (so i can index 100 times more stuff, evil laugh here)
06:53:05 <dcoutts> muwaha ha ha!
06:54:43 <ndm> i am always concerned that in text evil laugh and big snog are too close
06:54:56 <ndm> i guess the ha ha at the end helps
06:57:04 <chessguy> so what does haskell offer in place of default parameters? E.g., in certain languages (who will go unnamed), i could define a function to assume a default value for parameters which are left off
06:57:37 <earthy> chessguy: nothing. :)
06:57:57 <chessguy> hmm.
06:57:59 <earthy> however, you *can* use records
06:58:16 <earthy> where you define a record with default values
06:58:20 <chessguy> can't even overload like foo x y = blah; foo x = baz;
06:58:38 <earthy> and then call    f (default {onepar = newval})
06:59:12 <chessguy> hmmm
06:59:18 <apfelmus> chessguy: also, currying is your friend. foo x y = blah; simplefoo x = foo x defaulty
06:59:27 <earthy> and add a class Defaulting
06:59:40 <earthy> with one function     default :: a
06:59:40 <chessguy> interesting ideas
07:00:12 <earthy> and then instance Defaulting MyRecordType where default = MyRecord { firstpar = firstdefault; secondpar = seconddefault; }
07:00:15 <earthy> etc
07:00:48 <untubu> hola
07:01:04 <apfelmus> chessguy: it may also be that your function doesn't need defaults at all because you can factorize into smaller components that make sense by themselves
07:01:49 <chessguy> apfelmus, how so?
07:02:23 <earthy> usually defaults only make sense in configuration-like contexts, such as with userinterfaces
07:02:26 <apfelmus> depends on your code but is much worth considering. i currently don't have a concrete example.
07:02:53 <chessguy> apfelmus,ok, will think about it
07:03:23 <chessguy> i'm thinking about bringert's challenge on -cafe recently to simplify the http network api
07:03:37 <psnl> chessguy: thats a worthy thought
07:04:28 <apfelmus> chessguy: paste something?
07:04:32 <chessguy> it seems like a fairly easy project, which is good since i'm such a n00b, but i've been looking to get my hands dirty
07:04:40 <sjanssen> simonpj++ "Provoked by a discussion with Don Syme, and after some helpful conversations at POPL, I have finally written up a proposal for adding "view patterns" to Haskell."
07:04:50 <chessguy> apfelmus, i haven't done any code-writing yet
07:04:57 <apfelmus> :)
07:05:08 <chessguy> i'm still trying to find the existing api
07:05:14 <ToRA> sjanssen: there an url for that?
07:05:15 <apfelmus> sjanssen: hey, we get views?
07:05:31 <sjanssen> ToRA: do you subscribe to the haskell mailing list?
07:05:54 <apfelmus> the mail is 3 minutes old
07:05:59 <ToRA> sjanssen: ahh, there an url for that?
07:06:04 <ToRA> ;)
07:06:19 <chessguy> oh, here it is. http://www.haskell.org/http/api/Network-HTTP.html
07:06:33 * ToRA searches haskell.org
07:07:07 <sjanssen> ToRA: http://www.haskell.org/haskellwiki/Mailing_lists -- the haskell@haskell.org list is fairly low traffic, mostly announcements only
07:07:08 <lambdabot> Title: Mailing lists - HaskellWiki
07:07:14 <ToRA> kool
07:07:16 <ToRA> cheers
07:08:24 <|Lupin|> oleg seems to have nothing about type-classesAn parameterize modules
07:08:26 <chessguy> haskell-cafe is much more interesting, IMHO
07:08:38 <syntaxfree> interesting than?
07:08:39 <lambdabot> syntaxfree: You have 1 new message. '/msg lambdabot @messages' to read it.
07:08:45 <syntaxfree> haskell-cafe overflows me with coolness.
07:08:48 <matthew_-> mmm. So we get snoc as well as cons.
07:08:48 <syntaxfree> I can't keep track of it.
07:09:03 <chessguy> more interesting than just haskell
07:09:14 <syntaxfree> haskell@ is an odd list for me.
07:09:23 <syntaxfree> it's not really an announcement list. dunno.
07:10:17 <syntaxfree> Haskell Weekly News is in the right "size" for me at the moment.
07:10:40 <chessguy> hmm, this view pattern stuff looks really interesting
07:10:58 <syntaxfree> It has plenty of cool stuff, as well as selected portions for the bloggy noise.
07:11:04 <sjanssen> chessguy: yes.  I've always wanted views
07:11:43 * JKnecht has channel overload, need to get stuff done b4 more irc.
07:13:13 <glguy> ?seen
07:13:14 <lambdabot> Due to the existance of massively broken IRC clients, I will not answer you in channel.
07:13:25 <matthew_-> mmm. not to be confused with Scala's views!
07:13:26 <glguy> morning all
07:13:48 <glguy> hpaste, url still alive?
07:13:49 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
07:13:53 <chessguy> 'morning, glguy
07:13:54 <Saizan> 'views' as in the sql/dbms meaning of the term?
07:14:00 <earthy> |Lupin|: my bad: http://lambda-the-ultimate.org/node/1558
07:14:02 <lambdabot> Title: ML Modules and Haskell Type Classes: A Constructive Comparison | Lambda the Ulti ...
07:14:02 <chessguy> ?localtime glguy
07:14:03 <lambdabot> Local time for glguy is Mon Jan 22 09:10:52 2007
07:14:17 <earthy> Oleg isn't the only person do to advanced type trickery with type classes
07:14:29 <chessguy> wow, an active haskeller with a normal time zone
07:14:38 <chessguy> whereabouts are you anyway, glguy?
07:14:40 <Saizan> 'morning, even if my morning was 10 hours ago :)
07:14:48 <glguy> Saint Louis, MO
07:14:58 <chessguy> aha
07:15:03 <SemanticPhilosop> in the RTS there is a type HsInt - am I right in thinking that this is (on 32 bit machines) a "long"? - ie 32 bits and signed?
07:15:33 <chessguy> did anyone follow the recent discussion of http stuff on haskell-cafe?
07:15:33 <|Lupin|> earthy: many thanks !
07:15:42 <Igloo> SemanticPhilosop: All you are allowed to know is that it is an HsInt in C, and an Int in Haskell
07:16:34 <syntaxfree> What are the necessary steps to get a Haskell program compiled into a C program that can be compiled in a machine without ghc?
07:16:58 <Saizan> iirc a flag to ghc
07:17:05 <SemanticPhilosop> thanks - in which case I've unearthed a nice problem in the concucurrency
07:17:05 <syntaxfree> yes.
07:17:10 <syntaxfree> but it still requires a lot of dependencies.
07:17:21 <syntaxfree> I'd like to know what libraries I should package in.
07:17:25 <Igloo> syntaxfree: The simple answer if "you can't"
07:17:31 <Igloo> SemanticPhilosop: Oh?
07:17:37 <allbery_b> you also need a bunch of include files and static archives (libHS*.a in the ghc lib dir)
07:17:51 <syntaxfree> yes. iI don't know which include files these aren't, though.
07:18:01 <syntaxfree> Maybe there should be an utility that takes care of that.
07:18:14 <bd_> That functionality is only really meant for GHC porting, I think.
07:18:48 <SemanticPhilosop> yea - take a look at the implementation of getTicksOfDay
07:18:54 <allbery_b> and probably libgmp.*
07:20:28 <bd_> syntaxfree: why are you trying to do this, btw?
07:20:39 <syntaxfree> I'm not.
07:20:47 <syntaxfree> The thought crossed my mind that I might want to at some point.
07:20:51 <bd_> ah
07:20:51 <hpaste>   pasted "" at http://hpaste.ath.cx:8000/29
07:20:52 <Igloo> SemanticPhilosop: What about it?
07:21:07 <SemanticPhilosop> by my rough calculations it is wrapping round every 1.3 years - when that happens
07:21:28 <bd_> syntaxfree: the pure-C output is ratehr inefficient, I think. It doesn't get processed by the Evil Mangler, so certain optimizations are missing (such as tail calls :)
07:21:47 <syntaxfree> oh boy.
07:21:47 <SemanticPhilosop> the calculations in GHC.Conc are going to be incorrect and the RTS stall
07:22:01 <syntaxfree> so compile-to-C exists only in the interest of bootstrapping GHC?
07:22:07 <bd_> syntaxfree: yep
07:22:17 <bd_> syntaxfree: Probably *much* easier to get a native version of GHC
07:22:28 <syntaxfree> indeed.
07:22:52 <syntaxfree> interesting.
07:23:00 <SemanticPhilosop> ?
07:23:02 <SemanticPhilosop> \?
07:23:19 <bd_> the *real* solution would be to make GHC a cross-compiler, but it doesn't support that yet
07:23:22 <syntaxfree> I wonder how much of GHC had to be done in C before the singularity race started :)
07:23:41 <bd_> syntaxfree: I think it was bootstrapped from another haskell compiler/interpreter :)
07:23:56 <syntaxfree> oh. fun.
07:24:49 <bd_> Just like GCC, really :)
07:25:26 <chessguy> glguy, that last paste announcement doesn't look too good
07:25:35 <Igloo> SemanticPhilosop: Hmm, we probably should at least be subtracting from the start time so it doesn't break if you start a program just before a wrap
07:25:44 <syntaxfree> > "oh bitty box"
07:25:45 <lambdabot>  "oh bitty box"
07:26:27 <bd_> @hoogle getTicksOfDay
07:26:27 <lambdabot> No matches found
07:26:38 <psnl> syntaxfree: Ithe first ghc was written as a frontend to a LML compiler
07:26:46 <psnl> in LML, of course
07:26:56 <syntaxfree> hmm.
07:26:58 <bd_> LML?
07:27:04 <syntaxfree> so it basically was a haskell-to-lazyml compiler?
07:27:17 <SemanticPhilosop> think its a little more involved than that - its only 1.3 years with a 20ms scheduling interval, I fell over
07:27:51 <Igloo> SemanticPhilosop: Huh?
07:28:05 <SemanticPhilosop> this when I was looking to chaning that interval to be smaller
07:28:12 <psnl> syntaxfree: not really, it was a haskell frontend in the way gcc has frontends for everything.
07:28:28 <syntaxfree> I don't understand that.
07:29:05 <SemanticPhilosop> I'll work up a better bug report with some suggestions
07:29:08 <chessguy> apfelmus, still here?
07:29:12 <Igloo> OK
07:29:15 <apfelmus> yup
07:29:45 <psnl> there would have been some form of the lambda calcus used as an intermediate stage. all you have to do then is compile your language down to that language.
07:29:45 <dcoutts> ndm, want to test a Gtk2Hs win32 installer for me?
07:29:52 <chessguy> on http://www.b7j0c.org/content/haskell-http.html , the issue of the number of redirects is an interesting example of the default parameter thing we were talking about earlier
07:29:54 <lambdabot> Title: a wrapper for haskell's Network.HTTP
07:30:15 <ndm> dcoutts, yes :)
07:30:38 <dcoutts> ndm, ok, leme just check it's not going to trash your %PATH%... :-)
07:30:54 <chessguy> i think he should do httpGet = httpGetN redirectDepth -- and then count down to 0, instead of up. then if people WANT to specify a number, they can just call httpGetN directly with the extra parameter
07:31:09 * ndm likes his %PATH%
07:31:23 <syntaxfree> do you?
07:32:21 <chessguy> apfelmus, do you think there's a cleaner way to do this?
07:33:30 <apfelmus> chessguy: maybe Maybe is better :) i.e. httpGetN :: Maybe Int -> ...
07:33:30 <apfelmus> (Just n) means <= n redirects and Nothing means \infty many redirects allowed
07:33:59 <earthy> and httpGet = httpGetN Nothing
07:34:03 <apfelmus> yes
07:34:06 * earthy nodss
07:34:14 <earthy> sounds sane
07:34:36 <chessguy> hmm, do you really want to allow an infinite number of redirects?
07:34:48 <chessguy> i think that's the point
07:34:49 <apfelmus> well, it's sane but does not *sound* sane, Nothing = Infinity :)
07:35:21 <apfelmus> the question is not whether you want infinite redirects but whether you want them as default
07:35:22 <syntaxfree> @where binary
07:35:23 <lambdabot> http://darcs.haskell.org/binary
07:35:31 <apfelmus> or not
07:35:57 <chessguy> i would say no
07:36:16 <chessguy> so i would still suggest httpGet = httpGetN redirectDepth
07:36:23 <chessguy> err
07:36:25 <|Lupin|> earthy: Your article looks promising, thanks. But are you (or others) aware of a mor praticticallyoriented discussion ? Something like "pros and cons of typeclasses and parameterized modules" ?
07:36:30 <chessguy> so i would still suggest httpGet = httpGetN (Just redirectDepth)
07:36:48 <earthy> Lupin: well, I was looking for stuff by Oleg
07:36:57 <earthy> he *did* post about this on the haskell mailing list, IIRC
07:37:15 <earthy> however, people mostly just don't bother thinking about this too much.;)
07:37:35 <apfelmus> chessguy: i'd rather not. the problem is that there is no canonical choice for redirectDepth
07:37:38 <kowey> maybe some testimonials from Caml'ers in this channel?
07:38:20 <kowey> (sort of "coming from Caml, what are your likes/dislikes about typeclasses wrt parameterisable modules?")
07:38:30 <chessguy> but allowing infinite redirects can break working code
07:38:33 <syntaxfree> I wonder if a darcs get  transfers less data over the network than a download of the current tree.
07:38:33 <apfelmus> chessguy: it's like the question "which is the most interesting natural number?"
07:38:46 <apfelmus> chessguy: why?
07:39:04 <Saizan> 42
07:39:06 <chessguy> well, if there's some kind of redirect-loop on some stupid broken web server out there
07:39:35 <ndm> dcoutts, am heading out now, but message it and i'll try it when i get back - maybe an hour
07:39:43 <dcoutts> ndm, ok, ta.
07:39:51 <chessguy> having a default cap guarantees termination
07:40:25 <ndm> doesn't the W3C specify a cap?
07:40:33 <apfelmus> chessguy: i never encountered that. termination does not help because the code cannot return a String but must throw an exception
07:41:16 <chessguy> i'd rather throw an exception than get stuck in an infinite loop
07:42:54 <Saizan> you can just pick a huge Int if you want to guarantee termination, so that you will follow all sanely written redirects
07:43:16 <chessguy> Saizan, that's fine, my point is that the default should be finite
07:43:24 <apfelmus> chessguy: you can always use (httpGetN (Just 5)) if you want that. i think that a library may make canonical decision but not special ones.
07:43:32 <syntaxfree> > maxBound :: Int
07:43:33 <lambdabot>  2147483647
07:43:48 <apfelmus> the difference between maxBound steps and non-termination is negligible
07:43:56 <chessguy> i was just going to say that
07:44:15 <chessguy> i could see bumping it up to 20 or 25 maybe
07:44:46 <Saizan> yeah, huge for redirects is not *that* huge
07:45:01 <syntaxfree> I agree on  canonical x special decisions though.
07:45:39 <chessguy> so the default should be infinite?
07:45:47 <apfelmus> that's what i say
07:45:53 <syntaxfree> @where readline
07:45:53 <lambdabot> I know nothing about readline.
07:46:03 <syntaxfree> @google Haskell readline
07:46:05 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/shellac.html
07:46:05 <lambdabot> Title: Shellac
07:46:08 <chessguy> well you guys are certainly much more knowledgable than i am
07:46:16 <allbery_b> readline's in the base, I think
07:46:18 <syntaxfree> bah, where do I get the haskell Readline module?
07:46:21 <pejo> |Lupin|, do you want explicit comparisons, or just general discussions on pros and cons with typeclasses?
07:46:25 <syntaxfree> I don't have it.
07:46:32 <lucas_> hello everyone
07:47:00 <glguy> syntaxfree: System.Console.Readline
07:47:03 <apfelmus> chessguy: maybe. but you don't know whether this covers this particular case as well :)
07:47:04 <chessguy> the only other thing i would say is i'd rather not HAVE to pass any parameter (including Nothing) to specify the default number of redirects
07:47:04 <allbery_b> hm, no, not base.  extralibs bundle in 6.6
07:47:12 <syntaxfree> glguy: yes. I don't have it.
07:47:16 <syntaxfree> well, yeah.
07:47:21 <syntaxfree> I supposedly installed extralibs.
07:47:23 <ndm> anyone know where QuickCheck latest version is?
07:47:27 <ndm> the new one from Bjorn
07:47:30 <syntaxfree> I have GLUT and all.
07:47:53 <chessguy> so i would do httpGet = httpGetN Nothing
07:48:33 * uccus thinks finding releases is the greatest obstacle of Haskell programming
07:48:40 <Saizan> in this particular case i'd say that i've never seen anything like 10 redirects or more
07:48:47 <syntaxfree> it's time for a central repository, ain't?
07:48:56 <uccus> syntaxfree: exactly
07:49:03 <apfelmus> Saizan: i haven't even seen a redirect loop :)
07:49:11 <syntaxfree> :t System.Console.Readline.readline "word"
07:49:13 <lambdabot> IO (Maybe String)
07:49:19 <Saizan> apfelmus: that's true :)
07:49:19 <|Lupin|> pejo: Well... I think I'minterestedIn both...
07:49:37 <syntaxfree> :t getLine >>= \x -> Just x
07:49:39 <lambdabot>     Couldn't match `IO' against `Maybe'
07:49:39 <lambdabot>       Expected type: IO b
07:49:49 <lucas_> I am pretty new to haskell. I'm currently working through YAHT (Yet Another Haskell Tutorial). However, I am kinda stuck here. The goal is to get the character out of the following tuple: ((1, 'a'), "foo") using a combination of fst and snd. How do I first use fst and then snd on the tuple?
07:50:13 <syntaxfree> hmm. how do I get a trivial IO (Maybe String) just so that this thing will type again?
07:50:14 <chessguy> lucas_, where is the character in that tuple?
07:50:15 <uccus> snd . fst?
07:50:22 <chessguy> oh, sorry. mis-read
07:50:51 <syntaxfree> :t getLine >>= (\x -> Just x) >>= return
07:50:53 <lambdabot>     Couldn't match `IO' against `Maybe'
07:50:54 <lambdabot>       Expected type: IO b
07:51:19 <uccus> random thought: can a language omit character literals altogether? > head "a"
07:51:23 <lucas_> snd .  fst doesn't work
07:51:27 <syntaxfree> :t getLine >>= (+1) . read >>= return
07:51:29 <lambdabot> forall b. (Num (IO b), Read (IO b)) => IO b
07:51:41 <chessguy> > (snd . fst ) ((1, 'a'), "foo")
07:51:43 <lambdabot>  'a'
07:51:48 <syntaxfree> :t getLine >>= (\x -> Just x) >>= return
07:51:49 <lambdabot>     Couldn't match `IO' against `Maybe'
07:51:50 <lambdabot>       Expected type: IO b
07:51:54 <syntaxfree> :t \x->Just x
07:51:55 <kowey> lucas_: maybe you could play around with just fst and snd and see what happens
07:51:56 <lambdabot> forall a. a -> Maybe a
07:52:01 <ToRA> @type getLine >>= return.Just
07:52:02 * syntaxfree cries.
07:52:02 <lambdabot> IO (Maybe String)
07:52:17 <syntaxfree> wait, wait, wait. I'm confused now.
07:52:23 <syntaxfree> why does "return . Just" work?
07:52:27 <chessguy> > snd (fst ((1, 'a'), "foo")) -- should also work
07:52:29 <lambdabot>  'a'
07:52:30 <mux> :t getLine >>= return . Just
07:52:32 <lambdabot> IO (Maybe String)
07:52:50 <ToRA> syntaxfree: same as: getLine >>= return.(\x -> Just x)
07:52:57 <syntaxfree> yes.
07:53:00 <mux> :t getLine >>= \x -> return (Just x)
07:53:02 <lambdabot> IO (Maybe String)
07:53:04 <syntaxfree> But why is that even valid syntax?
07:53:06 <syntaxfree> :t (.)
07:53:08 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
07:53:24 <syntaxfree> Just isn't  (a->b)!
07:53:27 <syntaxfree> :t Just
07:53:29 <lambdabot> forall a. a -> Maybe a
07:53:33 <syntaxfree> ?
07:53:39 <allbery_b> Maybe a is a perfectly acceptable b
07:53:40 <syntaxfree> it's a data constructor!
07:53:42 <allbery_b> so is a, for that matter
07:53:49 <kowey> you don't see constructors as functions?
07:53:58 <kowey> > map Just [1,2]
07:53:59 <lambdabot>  [Just 1,Just 2]
07:54:04 <syntaxfree> oh boy.
07:54:06 <apfelmus> chessguy: you see, default values are difficult because there is no canonical choice. the choice must be to the programmer even if he doesn't want to choose. it's a fundamental problem. the only way is to invent some 'canonical' choice like Infinity. btw, this works for non-standard analysis, too, but this is another topic...
07:54:10 <syntaxfree> I've been writing wrapper functions by the dozens.
07:54:12 <allbery_b> there are some differences between constructors and functions but in large part they can be treated as the same
07:54:29 <dino-> lucas_: I'm curious, what did you try for that fst/snd thing? I'd like to see what error it was giving.
07:54:29 <mux> syntaxfree: heh, I've been doing that too in the past t:-)
07:54:59 <allbery_b> my guess is he didn't parenthesize
07:55:05 <lucas_> right
07:55:07 <lucas_> I didn't
07:55:10 <lucas_> and I didn't use the .
07:55:11 <allbery_b> > fst . snd ((1,'a'),"foo")
07:55:12 <lambdabot>  Couldn't match `a1 -> (a, b)' against `[Char]'
07:55:21 <allbery_b> > (fst . snd) ((1,'a'),"foo")
07:55:21 <dcoutts> allbery_b, I like to think of the difference being that constructors are functions that are bijections, ie you can use them in reverse without loss of information.
07:55:23 <lambdabot>  Couldn't match `(a, b)' against `[Char]'
07:55:27 <lucas_> I just thought if I wrote fst snd... fst would be applied to the tuple and then snd
07:55:35 <allbery_b> backwards, of course :)
07:55:48 <allbery_b> oh, also forgot the (.)
07:55:53 <syntaxfree> lucas_: (.) is function composition.
07:55:54 <allbery_b> (ou did that is)
07:56:04 <allbery_b> > (snd.fst) ((1,'a'),"foo")
07:56:05 <lambdabot>  'a'
07:56:08 <lucas_> yes
07:56:12 <allbery_b> > snd.fst ((1,'a'),"foo")
07:56:13 <lambdabot>  Couldn't match `a1 -> (a, b)' against `(a2, b1)'
07:56:15 <lucas_> one question tough
07:56:18 <lucas_> though
07:56:24 <lucas_> why does snd come first
07:56:34 <chessguy> it's function composition.
07:56:35 <allbery_b> application is right to left
07:56:36 <dino-> lucas_: Ok, I see. So it was really a parenthesis problem. The snd was trying to use fst (alone) as its argument.
07:56:46 <syntaxfree> lucas: think of it this way:
07:56:49 <syntaxfree> :src (.)
07:56:57 <lucas_> ok
07:56:59 <syntaxfree> @src (.)
07:57:00 <lambdabot> (.) f g x = f (g x)
07:57:04 <chessguy> like in math, (g o f) = g(f(x))
07:57:06 <syntaxfree> see?
07:57:19 <dino-> lucas_: f (g x) === (f . g) x
07:57:34 * roconnor grumbles that function application ought to be postfix
07:57:50 <dino-> @type (.)
07:57:52 <lambdabot> forall c a b. (b -> c) -> (a -> b) -> a -> c
07:57:53 <syntaxfree> dino-: why is that ==?
07:58:02 <syntaxfree> (.) is *defined* as that, it's not a mere theorem!
07:58:11 <syntaxfree> @free (.)
07:58:12 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
07:58:17 <dino-> syntaxfree: Sorry, misuse of symbology.
07:58:26 <lucas_> haskell looks really interesting (I've just found out about mapping and filtering and foldr-ing ;-))
07:58:34 <syntaxfree> dino-: yeah, I know.
07:58:50 <syntaxfree> I'm not very knowledgeable, so I love to nitpick. It's good for my ego :)
07:59:01 <mux> lucas_: warning, by the time you get to monads, all the other programming languages will look like toys, and it'll be impossible to come back :-)
07:59:09 <mux> haskell stole my naivety! :-(
07:59:18 * allbery_b pits syntaxfree against Oleg
07:59:31 <dino-> No no, it's good for you guys to be picky. I know very little, did not complete my college education.
07:59:42 <psnl> allbery_b: do you sell tickets to this fight?
07:59:44 <syntaxfree> I completed my college education ... in economics.
07:59:49 <pejo> Don't let your education get in the way of learning. :-)
08:00:00 <Saizan> mux: did it promise to marry you at least?
08:00:10 <mux> Saizan: not even
08:00:30 <syntaxfree> allbery_b: wait, wait. What category would I fight Oleg The Type Hacker in?
08:00:41 <Saizan> Type Hackery, off course
08:00:46 <psnl> mux: buy you dinner?
08:00:51 <syntaxfree> no, no.
08:00:53 <syntaxfree> this is no good.
08:01:00 <syntaxfree> I haven't even grokked existential types yet.
08:01:01 <mux> psnl: nah, it just left it at that
08:01:03 <mux> I feel raped
08:01:04 <syntaxfree> They just don't fit in my head./
08:01:18 <mux> I can't use an imperative without cursing anymore
08:01:23 <mux> +language
08:01:36 <allbery_b> well, he was arguably nitpicking about GADTs vs. typeclasses...
08:01:42 <syntaxfree> oh god. I went all the way into satisfying every dependency lambdabot had.
08:01:58 <syntaxfree> Now look at this:
08:02:01 <syntaxfree> allbery_b: hmm.
08:02:09 * mux notes they fixed the readline issues in GHC 6.6
08:02:12 <syntaxfree> @paste
08:02:13 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
08:02:44 <dino-> Is that new, that paste service?
08:02:49 <allbery_b> fbsd?  yeh, got that this morning from the bugtracker
08:02:52 <dino-> No more lisppaste
08:03:19 <allbery_b> yes, it's new.  between lisppaste tending to fall over on weekends and their new pseudo--captcha
08:03:35 <allbery_b> which apparently fails to be useful in some browsers
08:03:45 <allbery_b> (or usable)
08:03:57 <Saizan> mmh so, if i have instance Read a => Bar a where .. and instance (Read a,Read b) => Bar (a,b) where, they overlap and are undecideable i was told, but what ghc will do? pick the more specific?
08:04:16 <lucas_> foldr and foldl are quite confusing
08:04:17 <allbery_b> if it can figure out which is the most specific
08:04:23 <allbery_b> I think that's where the problem is
08:04:30 <mux> do you guys think that the new multi-core CPUs will finally kill C for good because it's too hard to parallelize a C program?
08:04:40 <psnl> no
08:05:00 <mux> of course, when I say kill C I don't totally eeradicate every single possible use
08:05:03 <allbery_b> most C hackers will continue to write single-threaded programs with no parallelization
08:05:10 <mux> it'll be hard to switch to something else than C for kernels
08:05:13 <hpaste>  syntaxfree pasted "mo' lambdabot woes" at http://hpaste.ath.cx:8000/30
08:05:31 <allbery_b> others will use threads and no other parallelization
08:05:37 <dino-> lucas_: I think they can be confusing, yeah. Very powerful.
08:05:41 <psnl> most OSes have n programs wating to run at once. A machine for doing one thing on is rare
08:05:53 <glguy> ?vixen
08:05:54 <lambdabot> <undefined>
08:06:06 <mux> psnl: right, but it's also true that fewer and fewer programs are CPU-bound
08:06:11 <Saizan> allbery_b: how can i determine if it can guess right? are there some docs on it?
08:06:12 <lucas_> So it's not too bad if I don't completely "get" folding?
08:06:19 <allbery_b> syntaxfree:  binary's in flux, the word is to darcs unrecord patches until it works
08:06:21 <dino-> Can somebody tell me what the === symbol is supposed to mean? I mean, how do you read it.
08:06:24 <dcoutts> mux, you know about the OS kernel written in Haskell I presume?
08:06:25 <mux> so it's not like running N programs will keep N CPUs busy
08:06:31 <mux> dcoutts: I have only heard about it
08:06:32 <psnl> mux: true
08:06:33 <allbery_b> Saizan: see "undecidable"
08:06:45 <mux> dcoutts: but people have been doing kernels in every language, even in Perl
08:06:46 <kowey> lucas_: folding made the most sense to me when i was first forced to use it
08:06:47 <glguy> dino-: in what context?
08:06:48 <allbery_b> beyond that, well, I'm no type hackery expert
08:06:53 <mux> most of those are funny, but useless
08:07:00 <mux> I can't say about the Haskell one
08:07:00 <kowey> lucas_: it replaced for loops for me that map couldn't
08:07:07 <syntaxfree> gah, I'm too frustrated to keep at this atm.
08:07:09 <glguy> dino-: it is often used as "is identical to"
08:07:11 <dino-> Well, when people type it here to explain somehting. I had the idea it's supposed to be the 3-bar equals from math.
08:07:13 <dcoutts> mux, well there you go, no need to C. Actually the Haskell one is designed for reliability / assurance.
08:07:15 <syntaxfree> Will keep trying later.
08:07:15 <kowey> so i wouldn't worry too much... it does 'click' eventually
08:07:42 * allbery_b is waiting for lbot and binary to stabilize a little before tryinmg to build it again
08:07:46 <mux> dcoutts: I have doubts that it'll be up-to-speed with any other C kernel, and unfortunately speed remains very important for a kernel
08:07:47 <psnl> mux: on this box, which is barely loaded, it normally finds two things to give to the cpu.
08:07:55 <kowey> lucas_: http://en.wikibooks.org/wiki/Haskell/List_processing <-- is another discussion on the topic
08:08:03 <lucas_>  foldl goes through the list left -> right and foldr right -> left? Is that the difference?
08:08:17 <psnl> mux: of course, if you buy 4 8 cored cpus, then its a different matter
08:08:25 * mux ponders committing a haskell kernel module into FreeBSD's CVS repo
08:08:25 <glguy> lucas_: yes
08:08:27 <glguy> ?src foldl
08:08:28 <lambdabot> foldl f z xs = lgo z xs
08:08:28 <lambdabot>     where lgo z []     =  z
08:08:28 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:08:29 <glguy> ?src folr
08:08:29 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
08:08:29 <mux> maybe for April 1st :D
08:08:30 <glguy> dr
08:08:34 <glguy> ?src foldr
08:08:35 <lambdabot> foldr k z xs = go xs
08:08:35 <lambdabot>     where go []     = z
08:08:35 <lambdabot>           go (y:ys) = y `k` go ys
08:08:38 <dcoutts> mux, yeah, for a general purpose OS, but for many applications the main concern is security and/or reliability.
08:08:45 <mux> dcoutts: nods
08:08:55 <glguy> lucas_: http://foldl.com http://foldr.com
08:08:57 <sjanssen> lucas_: also, foldr can consume the list lazily, and foldl has to consume the entire list
08:08:57 <lambdabot> Title: foldl.com
08:09:01 <mux> dcoutts: I believe an Haskell kernel could be very interesting for embedded appliances
08:09:09 <dcoutts> mux, yes, exactly
08:09:10 <mux> where you're not necessarily very concerned about perfs
08:09:19 <sjanssen> > foldr (||) True (repeat False)
08:09:21 <lambdabot>  Exception: <<loop>>
08:09:26 <syntaxfree> couldn't a Haskell kernel be interesting for dedicated numeric machines?
08:09:38 <syntaxfree> if it's supposed to be stable-but-slow..
08:09:52 <mux> I want the next Mars robot to run Haskell :-)
08:09:55 <mux> HRover
08:10:11 <lucas_> So why does foldr (-) 0 [1..3] yield 2 and not - 6?
08:10:18 <syntaxfree> oh. hpaste improves by the hour.
08:10:20 <syntaxfree> h-rad!
08:10:38 <syntaxfree> > foldl (-) 0 [1..3]
08:10:40 <lambdabot>  -6
08:10:52 <lucas_> So foldl goes through the list from right to left
08:10:54 <syntaxfree> foldr (-) 0 [1..3] is 1 - (2-3)
08:10:58 <glguy> foldr (-) 0 [1..3]  ->      1 - (2 - (3-0))
08:11:07 <syntaxfree> yes, that.
08:11:26 <syntaxfree> foldl (-) 0 [1..3] is (((1-2)-3)-0)
08:11:36 <glguy> foldl (-) 0 [1..3] ->  ((0 - 1) - 2) - 3
08:11:38 <syntaxfree> heavy parenthesis on the left.
08:11:44 <syntaxfree> that, too :)
08:11:55 <syntaxfree> don't listen to me, I'm stupid.
08:12:08 <glguy> foldl1 (-) [1..3] -> (1-2)-3
08:12:21 <glguy> foldr1 (-) [1..3] -> 1-(2-3)
08:12:25 <syntaxfree> anyone has any idea of how to compile lambdabot without vixen support?
08:12:46 <glguy> someone*
08:13:12 <syntaxfree> someone?
08:13:12 <lucas_> Ah I think I get it now
08:13:14 <glguy> not me :)
08:13:18 <syntaxfree> heh.
08:13:36 <syntaxfree> hpasste needs an "about" page.
08:13:51 <syntaxfree> "This is hpaste. It's written in Haskell. Haskell rocks."
08:13:51 <lucas_> foldl: initial value you supply goes on the left of the list and it works its way through from right to left and foldl puts its initial value on the left and works from right to left
08:14:14 <lucas_> oh sorry: foldr: inital value on the right; from left to right
08:14:55 <glguy> lucas_: a more complicated use of foldr in the "follow" function: http://hpaste.ath.cx:8000/22#2
08:15:03 <syntaxfree> > foldl (flip (:)) "!xob yttib ,ho"
08:15:05 <lambdabot>  <[Char] -> [Char]>
08:15:18 <syntaxfree> yay. that's a good lambdabot improvement.
08:15:24 <lucas_> I am not going to look at that now, my brain is being foldr-ed and foldl-ed
08:15:33 <syntaxfree> > foldl (flip (:)) ""  "!xob yttib ,ho"
08:15:34 <lambdabot>  "oh, bitty box!"
08:15:39 <dino-> Sorry to belabor this.. but a wikipedia article on math symbols has the 3-bar equals symbol as "is defined as." Is that the same thing that's meant around here when === is typed?
08:15:42 <lucas_> thanks anyway
08:15:43 <lucas_> ;-)
08:15:52 <kowey> oh!... actually, maybe using (-) and like functions is bad for teaching foldl / foldr
08:16:30 <kowey> because the user has to navigate both the fold directions and the function arg orders
08:16:32 <syntaxfree> lucas-: those are quite general patterns of computation. It's quite worth learning'em.
08:17:19 <glguy> sum (x:xs) = x + sum xs
08:17:19 <glguy> sum [    ] = 0
08:17:27 * syntaxfree is in a campaign to replace "Hello world!" with "Oh bitty box!" in computer lore.
08:17:36 <glguy> lucas_: does that recursive version of sum make sense to you
08:18:07 <lucas_> what's x and what's xs
08:18:18 <lucas_> value x goes into a list xs?
08:18:20 <glguy> x is the first element in the list
08:18:22 <glguy> xs is the rest
08:18:32 <kowey> (it helps to pronous xs like 'plural of x'; ex-es)
08:18:40 <kowey> *pronounce
08:18:45 <syntaxfree> > foldl (flip (:)) "" "erol retupmoc ni \"!xob yttib hO\" htiw \"!dlrow olleH\" ecalper ot ngiapmac a si sihT"
08:18:46 <allbery_b> it's pattern matching.  you pass it a list, the pattern deconstructs it into head (x) and the rest (xs)
08:18:47 <lambdabot>  "This is a campaign to replace \"Hello world!\" with \"Oh bitty box!\" in co...
08:18:53 <glguy> so, in [1,2,3,4] can be written    1:(2:(3:(4:[])))
08:19:08 <syntaxfree> (:) is a data constructor.
08:19:24 <glguy> lucas_: do you know what a singly-linked list is?
08:19:29 <dino-> @type (:)
08:19:31 <lambdabot> forall a. a -> [a] -> [a]
08:19:52 <lucas_> no
08:20:04 <syntaxfree> lucas-: like cons-lists in lisp.
08:20:08 <lucas_> I am still not getting foldr and foldl
08:20:16 <glguy> this is more basic
08:20:25 <glguy> fold[rl] build on this
08:20:31 <syntaxfree> a List is either the empty list [] or an element attached to a list.
08:20:43 <syntaxfree> data [a] = []  | a : []
08:20:50 <lucas_>  foldr (-) 0 [1,2,3] = 2. But why: 1 - 2 - 3 - 0 (working from left to right yields - 6)
08:20:55 <glguy> Haskell's lists use two functions (:) and []. (:) is a function that takes an element, and a list, and returns a new list with the element prepended onto the list
08:21:06 <glguy> lucas_: [] is the empty list, all lists end with this
08:21:16 <syntaxfree> so you have two or three operations here really.
08:21:44 <syntaxfree> anyway.
08:21:44 <lucas_>  sum (x:xs) = x + sum xs ... takes the first value of a list, adds the rest and goes on
08:21:49 <glguy> lucas_: foldr operates right to left, foldl left to right
08:21:55 <syntaxfree> yes.
08:21:59 <syntaxfree> @src foldl
08:22:00 <lambdabot> foldl f z xs = lgo z xs
08:22:00 <lambdabot>     where lgo z []     =  z
08:22:00 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
08:22:20 <syntaxfree> @src foldr
08:22:20 <lambdabot> foldr k z xs = go xs
08:22:21 <lambdabot>     where go []     = z
08:22:21 <lambdabot>           go (y:ys) = y `k` go ys
08:23:48 <sjanssen> you can think of foldr as the (:) [] replacer.  "foldr f n xs" replaces every link ((:), that is) in the list with f, and the [] at the end with n
08:23:58 <glguy> lucas_: what I wanted to get at is that foldr a b   replaces all of the (:) with a and the [] with b
08:24:18 <uccus> proves once again the best documentation of Haskell code is its source
08:24:32 <earthy> often true
08:24:35 <glguy> foldr (-) 0 (1:(2:(3:[])))   ->    (1-(2-(3-0)))
08:24:49 <syntaxfree> That source could better be written as the cannonical two-line definitions, methinks.
08:24:56 <syntaxfree> There must be some speed advantage to that.
08:25:19 <sjanssen> syntaxfree: yeah, I think the worker/wrapper is overkill here
08:25:26 <glguy> foldr f g (x:xs) = f x (foldr f g xs)  ;   foldr f g []  = g
08:25:53 <syntaxfree> notation is inconsistent from foldr to foldl as well.
08:25:54 <glguy> > foldr (:) [] [1,2,3,4]
08:25:55 <lambdabot>  [1,2,3,4]
08:25:58 <sjanssen> syntaxfree: GHC can optimize the 2 line definition into the worker/wrapper definition
08:26:08 <syntaxfree> why use infix notation for foldlr?
08:26:21 <syntaxfree> maybe @src picks code from the Evilly Mangled version.
08:26:28 <glguy> syntaxfree: saves on parentheses :)
08:26:44 <syntaxfree> only to squander on backticks!
08:27:22 <kilimanjaro> syntaxfree, I think the infix notation is just for exposition
08:27:50 <syntaxfree> the whole thing smells bad.
08:27:52 <resiak> Why is the worker/wrapper definition more efficient?
08:27:53 <glguy> foldl f g (x:xs) = foldl f (f g x) xs
08:27:53 <glguy> foldl f g [    ] = g -- right?
08:27:53 <kilimanjaro> since the list constructor is infix
08:28:14 <kilimanjaro> resiak, I don't think it is
08:28:50 <kilimanjaro> well, actually
08:29:04 <allbery_b> for a naive implementation it would be since you're not passing f around
08:29:25 <lucas_> okay, so now I think I've got how foldr works: foldr (-) 0 [4,8,7]:
08:29:34 <kilimanjaro> right, and in addition it can avoid using a "standard" calling convention if so desired
08:29:38 <lucas_> 4-(8-(7-0))
08:29:39 <sjanssen> resiak: the worker/wrapper avoids applying parameters that don't change over and over
08:29:39 <lucas_> ?
08:29:53 <resiak> sjanssen: Ah, that makes sense.
08:29:58 <sjanssen> resiak: but in practice, you shouldn't sweat it
08:30:16 <resiak> sjanssen: because ghc can do the transformation itself?
08:30:48 <sjanssen> resiak: I believe it can.  Even if it can't, the overhead is very small
08:30:58 <sjanssen> just pushing two extra pointers on a stack
08:32:05 <allbery_b> the Prelude is shared between ghc and hugs (and others?) though, so there's some point to making it nice for lesser compilers than ghc :)
08:33:30 <syntaxfree> at the cost of making it less didactic for newbies?
08:34:12 <vincenz> Am I correct to assume that a domain is basically a (Maybe a) forall a
08:34:19 <glguy> ?src foldl1
08:34:20 <lambdabot> foldl1 f (x:xs) = foldl f x xs
08:34:20 <lambdabot> foldl1 _ []     = undefined
08:34:27 <allbery_b> the didactic one is in the report
08:34:31 <allbery_b> ?where report
08:34:32 <lambdabot> http://www.haskell.org/onlinereport/
08:34:37 <fasta> 362 <- size of type in characters
08:34:42 <sjanssen> syntaxfree: the definition in the report and the definition used in the actual source don't have to be the same
08:35:08 <resiak> sjanssen: okay.
08:35:08 <allbery_b> now, whether @src should be taking from that instead of the actual one is another question, and one I can't answer
08:35:09 <syntaxfree> hmm. true.
08:35:17 * fasta  hopes the Haddock restriction of putting types in source code goes away
08:35:18 <allbery_b> (although I'd actually have preferred the former)
08:36:13 <syntaxfree> @free foldr
08:36:15 <lambdabot> (forall x. f . h x = k (g x) . f) => f . foldr h y = foldr k (f y) . $map g
08:38:10 <chessguy> that's a weird pattern
08:38:21 <chessguy> f . foldr h y? how does that match
08:40:03 <glguy> :t foldr
08:40:04 <lambdabot> forall b a. (a -> b -> b) -> b -> [a] -> b
08:40:18 <glguy> notice that the type of the result is the type of the second argument
08:42:11 <chessguy> hmm
08:42:22 * glguy notices that pastebin.com support prefixing a line with @@ to highlight it
08:42:34 <glguy> (and sets out to add this functionality)
08:42:42 <bos31337> interesting stuff from simonpj on haskell-cafe
08:43:28 <bos31337> http://hackage.haskell.org/trac/haskell-prime/wiki/ViewPatterns
08:43:30 <lambdabot> Title: ViewPatterns - Haskell Prime - Trac
08:44:24 <sjanssen> bos31337: yes, very interesting
08:44:27 <bos31337> @seen bringert
08:44:27 <lambdabot> I saw bringert leaving #haskell 23h 24m 43s ago, and .
08:44:43 * mux wonders if he could sustain freebsd cvs commit logs + haskellt-cafe
08:45:02 <bos31337> haskell-cafe is pretty low traffic
08:45:24 <mux> I think I'll try it then
08:45:30 <lucas_> why can't I do: square x = x * x in ghci? In the YAHT it says that that's how to make a function
08:45:31 <bos31337> you just have to be careful of the oleg bombs. one oleg message can absorb a brain for a full day.
08:45:41 <bos31337> lucas_: let square x = x * x
08:45:48 <bos31337> -> let <-
08:45:59 <lucas_> but I thought let was only used to create a "binding" inside a function like:
08:46:01 <fasta> lucas_: that is how you make a function, just not in ghci
08:46:13 <fasta> lucas_: if you learn further you will understand
08:46:16 <bos> lucas_: ghci's toplevel is a bit different
08:46:26 <lucas_> func x = let a = 2*2 in ...
08:47:13 <lucas_> so using let is *THE* way to make a function
08:47:23 <bos> lucas_: no, it's *a* way
08:47:31 <lucas_> but I can also use let to do: let ... in ...
08:47:46 <bos> if you're typing at the ghci prompt, it's the only way to do it, short of loading a source file
08:48:00 <lucas_> so in a source file I could say: square x = x * x
08:48:11 <bos> but inside a haskell source file, "let" just binds a local name in an expression, so ... yes, what you said
08:48:25 <lucas_> so what I said about let...in is valid in a source file
08:48:30 <bos> yes
08:48:35 <lucas_> good ;-)
08:48:40 <malebria_> How can I mix two monads, like State and IO?
08:48:44 <lucas_> I am really beginning to like haskell
08:49:02 <psnl> lucas_: stop now. you can't go back!
08:49:07 <mux> malebria_: with monad transformers, in your case with StateT
08:49:16 <malebria_> I'm searching about monad transformers, but I found only things related to other version of GHC, with modules that I can't find in GHC libraries.
08:49:29 <malebria_> mux: Do I need to install a package to use them?
08:49:39 <mux> no, it's provided with GHC
08:49:47 <bos> malebria_: http://sigfpe.blogspot.com/2006/05/grok-haskell-monad-transformers.html
08:49:50 <lambdabot> Title: A Neighborhood of Infinity: Grok Haskell Monad Transformers, http://tinyurl.com/y6w3jr
08:50:02 <sjanssen> malebria_: what version of GHC are you using?
08:50:18 <malebria_> http://www.haskell.org/ghc/docs/latest/html/base/Control.Monad.State.html#StateT
08:50:20 <lambdabot> http://tinyurl.com/2gabho
08:50:22 <malebria_> 6.6
08:50:25 <fasta> Don't you need mtl?
08:50:25 <kowey> i wonder how hard it would be to have newbie mode in ghci which behaves more like typing something in a source file than like in a do block
08:50:33 <fasta> I didn't have mtl in my 6.6.
08:50:38 <sjanssen> malebria_: you probably need to install mtl then
08:50:43 <fasta> Oh, wait, I did
08:50:46 <mux> you don't have mtl?!
08:50:48 <mux> ah
08:50:58 <fasta> mux: I didn't have them in 6.7
08:50:59 <sjanssen> mux: mtl isn't packaged with ghc anymore
08:51:05 <kowey> hmm... that might tricky with defining functions in pieces
08:51:09 <mux> well I have them in GHC 6.6
08:51:17 <mux> but maybe that's part of the extlibs tarball?
08:51:20 <bos> bah humbug, haxr and haxml don't want to share the love any more.
08:51:22 <fasta> mux: it is
08:51:29 <mux> that explains it then
08:51:36 <mux> the FreeBSD port always install the extra tarball
08:51:50 <glguy> f :: ByteString -> String ; f b = map (toEnum . fromEnum) (unpack b) -- ?
08:52:01 <malebria_> sjanssen: do you know where I can find the mtl haddock doc in debian?
08:52:21 <Igloo> You can't ATM
08:52:34 <Igloo> They are online, though
08:52:44 <dcoutts> glguy, or Data.ByteString.Char8.unpack
08:52:52 <glguy> ah, OK
08:53:22 <dcoutts> glguy, the .Char8 versions of ByteString and ByteString.Lazy provide a character/string view of a byte string
08:53:27 <glguy> would I see memory size gains from storing pastes in memory as ByteStrings over Strings?
08:53:35 <dcoutts> yes
08:53:43 <dcoutts> about 12 times
08:53:45 <glguy> and the Read and Show formats are the same?
08:53:49 <dcoutts> yep
08:53:57 <glguy> then its a no brainer :)
08:54:06 <emu> is it possible to statically link against libgmp just in case target system doesn't have it installed?
08:54:25 <fasta> glguy: is your paste service that popular? :)
08:54:32 <malebria_> Igloo: I'll report a bug about this, ok?
08:54:41 <glguy> fasta: I want to use the for speedups in processing
08:54:48 <dcoutts> emu, yeah, it's possible if you know how to make the linker do it. I don't recall how to do it but I think it's possible.
08:54:53 <Igloo> malebria_: If you like. I think there might even already be one
08:54:59 <fasta> glguy: the <>?
08:55:08 <emu> im not doing any arithmetic, maybe it could be excluded :/
08:55:14 <glguy> fasta: <> means diff?
08:55:24 <lucas_> another problem
08:55:42 <lucas_> I am currently working on a function fib (fibonacci sequence)
08:55:47 <glguy> fasta: is there a compelling reason for me to not use them?
08:55:47 <lucas_> let fib 1 = 1
08:55:49 <lucas_> np
08:55:50 <malebria_> Igloo: reportbug is not showing any.
08:55:52 <lucas_> let fib 2 = 2
08:55:53 <lucas_> np
08:55:55 <lucas_> but
08:56:02 <Igloo> malebria_: OK, it's probably against another package then
08:56:07 <lucas_> let fib n = fib (n-1) + fib (n-1)
08:56:10 <lucas_> works but
08:56:13 <Igloo> But they're all made from teh same code
08:56:13 <lucas_> if I sa
08:56:14 <sjanssen> lucas_: you're typing that into ghci?
08:56:15 <lucas_> y
08:56:17 <lucas_> yes
08:56:31 <lucas_> fib 4: ***Exception: stack overflow
08:56:36 <sjanssen> lucas_: each let you typed in shadowed the previous definition of fib
08:56:52 <glguy> fasta: I'm also going to add support for pastebin.com's "To highlight particular lines, prefix each line with a @@"
08:56:54 <lucas_> ah
08:56:55 <lucas_> I see
08:56:59 <lucas_> so I first have to make the general let
08:57:03 <lucas_> and then the special cases
08:57:05 <sjanssen> let fib 1 = 1; fib 2 = 2; fib n = fib (n-1) + fib (n-2) -- is what you want
08:57:06 <fasta> glguy: why not do something more fancy?
08:57:13 <chessguy> try this: let fib 1 = 1; fib 2 = 2; fib n = fib (n-1) + fib  (n-2) in fib 4
08:57:14 <glguy> fasta: ideas are always welcome!
08:57:19 <bos> how do i check out a particular version of the tree with darcs?
08:57:23 <fasta> glguy: why not let users click on a line to be highlighted?
08:57:29 <lucas_> *** Exception: <interactive>:1:4-12: Non-exhaustive patterns in function fib
08:57:43 <glguy> fasta: after the paste has been made?
08:57:48 <sjanssen> lucas_: however, the best thing to do is type your definitions into a file, and then load that file into ghci
08:58:12 <fasta> glguy: or during it (but that might be difficult)
08:58:15 <malebria_> Igloo: where do I find the doc online?
08:58:36 <glguy> fasta: and anyone can highlight and clear highlights?
08:59:12 <lucas_> this is weird
08:59:17 <fasta> glguy: people should only be able to highlight and clear their own, I guess.
08:59:20 <lucas_> I've got the following in fib.hs
08:59:24 <lucas_> fib n = fib (n-2) + fib (n+1)
08:59:25 <lucas_> fib 1 = 1
08:59:25 <lucas_> fib 2 = 2
08:59:29 <lucas_> When I try to import it
08:59:31 <lucas_> I get
08:59:36 <lucas_> fib n = fib (n-2) + fib (n+1)
08:59:36 <sjanssen> lucas_: the first case should be last
08:59:36 <lucas_> fib 1 = 1
08:59:36 <lucas_> fib 2 = 2
08:59:58 <Igloo> malebria_: http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
08:59:58 <lucas_> k
09:00:01 <lucas_> but if I do
09:00:03 <lucas_> fib 3 after loading it
09:00:08 <glguy> fasta: assuming a non-hostile environment, it could be useful if I was to paste some code as a teaching instrument, and then the person who I was explaining things to could highlight osmething they don't understand?
09:00:08 <lucas_> I get a stack overflow
09:00:28 <fasta> glguy: yes, but that would be done on a copy of the paste then.
09:00:38 <sjanssen> lucas_: you get a stack overflow because the base cases are after the recursive case
09:00:41 <chessguy> lucas_, that's because patterns are matched in top-down order, so that will always match the first case, and it will never see the base cases
09:00:46 <Masklinn> dudes
09:01:00 <glguy> far out
09:01:01 <lucas_> so the general case has to come first?
09:01:04 <Masklinn> that's because he's calling fib(n+1) instead of fib(n-1)
09:01:09 <Masklinn> it's not about case order
09:01:11 <malebria_> Igloo: thanks.
09:01:14 <sjanssen> lucas_: general case comes last
09:01:14 <lucas_> oh
09:01:15 <lucas_> yes
09:01:16 <dcoutts> @tell ndm that win32 installer is now available: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.4.exe
09:01:16 <lambdabot> Consider it noted.
09:01:17 <lucas_> ok
09:01:24 <chessguy> lucas_, last. and yes, you need n-1, not n+1
09:01:30 <lucas_> yeah
09:01:37 <lucas_> now it works
09:01:38 <ndm> dcoutts, thanks, just got back
09:01:39 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
09:01:40 <lucas_> fib 5 = 8
09:01:40 <lucas_> thanks
09:01:41 <chessguy> Masklinn, the case order will also affect it
09:01:51 <dcoutts> ndm, great :-)
09:01:54 <Masklinn> chessguy > I don't think so
09:01:55 <dcoutts> any other windows users want to help me test this Gtk2Hs Win32 installer ?
09:01:56 <mein_traum> http://mibssam.free.fr/
09:01:58 <lambdabot> Title: e-Mibssam
09:02:03 <glguy> dcoutts: I will tonight
09:02:05 <dcoutts> http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.10.4.exe
09:02:07 <dcoutts> glguy, ta
09:02:15 <chessguy> Masklinn, why wouldn't it?
09:02:17 <lucas_> what's Gtk2Hs?
09:02:21 <lucas_> GTK for Haskell for Win
09:02:26 <dcoutts> yep
09:02:40 <lucas_> I am not that advanced yet, I am afraid
09:02:41 <dcoutts> well for windows, linux, osx etc
09:02:48 * glguy encourages anyone with an opinion or idea on paste highlighting to chime in while the idea hasn't been set into code
09:02:56 <chessguy> > let fib n = (fib (n-1)) + (fib (n-2)); fib 1 = 1; fib 2 = 1 in fib 3
09:02:57 <lambdabot>      Warning: Pattern match(es) are overlapped
09:02:57 <lambdabot>              In the definition...
09:02:59 <ndm> lucas_: Gtk for all platforms with Haskell, Windows is just one variant
09:03:14 <dcoutts> glguy, ndm, btw the docs are still the old ones from the last release
09:03:22 <Masklinn> chessguy > and i thought wrong
09:03:30 <dcoutts> glguy, ndm, but if you find any other issues tell me
09:03:32 * Masklinn hides in shame
09:03:35 <lucas_> I've got to go now. Thanks so much for your help, I really really appreciate it. I might come back. see you guys ;-)
09:03:35 <ndm> dcoutts, it has docs? i never even checked...
09:03:47 <chessguy> Masklinn, bah, don't do that. we've all done the same thing at some point
09:03:50 <chessguy> certainly i have
09:03:50 <ndm> dcoutts, i can't choose not to install Gtk+
09:03:57 <dcoutts> ndm, correct.
09:04:06 <ndm> dcoutts, isn't that a worthwhile option?
09:04:14 <dcoutts> ndm, no!
09:04:32 <dcoutts> ndm, the whole point is that we bundle gtk so that it's harder to get a borked install
09:04:35 <ndm> dcoutts, plus it says requires 70Mb, but hte components only come to 22Mb
09:05:01 <dcoutts> ndm, size calculation is a bit odd because we include two builds of Gtk2Hs, for 6.4.2 and 6.6
09:05:15 <dcoutts> it's not clear how I can fix that sadly
09:05:29 <Saizan> nad if i have gtk installed yet?
09:05:46 <ndm> its relatively minor, its only because i'm low on disk space that i care about these things
09:05:48 <Saizan> "yet installed" maybe
09:05:56 <dcoutts> Saizan, if you have it already then you get another copy :-) it's only 6mb download
09:06:38 <dcoutts> ndm, so the 77 is the value if both builds were installed and 22 is if neither, but actually you'll always get one.
09:06:56 <ndm>     conflict: module `Graphics.UI.Gtk.Windows.WindowGroup' is present in multipl
09:06:58 <ndm> e packages: gtk-0.9.10, gtk-0.9.10.4
09:07:02 <glguy> how does one get a darcs.haskell.org account?
09:07:06 <ndm> dcoutts thats when trying to compile something
09:07:10 <dcoutts> ndm, what ghc version have you got ?
09:07:12 <ndm> glguy: ask Simon Marlow
09:07:15 <earthy> harlan:/usr/local/src/wxhaskell-0.10.1-pre/samples/wxcore arthurvl$ ./helloworlddyld: Symbol not found: __ZTI8wxThread
09:07:15 <ndm> dcoutts, 6.4.2
09:07:18 <earthy>   Referenced from: /usr/local/wxhaskell/lib/libwxc-mac2.5.3-0.10.1.dylib
09:07:20 <earthy>   Expected in: flat namespace
09:07:23 <earthy> hell and damnation.
09:07:25 <earthy> Trace/BPT trap
09:07:34 <dcoutts> ndm, hmm, I thought that ghc would ignore the hidden one.
09:07:41 <ndm> glguy: do you want to set up a new project? if you want to hack Yhc we fast-track creating accounts :)
09:07:54 <dcoutts> ndm, are you specifying -package gtk when you compile?
09:07:56 <ndm> dcoutts, should the new one be hidden, or the last one?
09:08:00 <glguy> ndm: bringert told me if I got one I could push my patches to packages/xhtml
09:08:04 <kowey> earthy: don't use the wxWidgets that comes with Tiger
09:08:16 <earthy> kowey: I know. :)
09:08:25 <ndm> glguy: yes, anyone can do anything to darcs.haskell.org with an account
09:08:27 <dcoutts> ndm, use ghc-pkg list, ghc-pkg automatically hides old versions when you register new ones.
09:08:30 <earthy> but it compiles so neatly up to the point where you want to use it
09:08:42 <ndm> dcoutts, yes, i pass -package gtk
09:08:42 <dcoutts> ndm, ghc-pkg list shows hidden packages in ()'s
09:08:43 * kowey sympathises
09:08:47 <earthy> kowey: do I still need to compile wxMac 2.6.3 statically?
09:08:49 <Igloo> @where ar
09:08:50 <lambdabot> I know nothing about ar.
09:08:55 <Saizan> mmh cabal installs under C:\Program Files\Haskell\ where this installer goes directly to C:\Program Files\ is there some specific reason?
09:08:57 <kowey> that was the whole reason I did the Unicode thing... jsut to make it work :-(
09:09:08 <Igloo> dcoutts: Did you say you'd written an ar in Haskell?
09:09:12 <dcoutts> ndm, then try either without -package gtk and rely on --make to find it, or use -package gtk-${ver}
09:09:14 <earthy> well, I have a feeling I can get around this somehow
09:09:15 <ndm> dcoutts, (gtk-0.9.10), gtk-0.9.10.4
09:09:15 <kowey> earthy: the standard darwinport works, so whatever they do :-p
09:09:16 <glguy> ndm: I think its just easier for him if I do that instead of submitting them to him all the time :)
09:09:22 <dcoutts> Igloo, yep, without the ranlib feature.
09:09:28 <Igloo> dcoutts: Where is it?
09:09:29 <ndm> glguy: he can add you to his authorised_keys file
09:09:30 <earthy> that was not the answer I was hoping for. ;)
09:09:31 <dcoutts> ndm, so that's right.
09:09:47 <glguy> ndm: I doubt that he wants me to be logging in as him :-p
09:09:50 * kowey guesses the answer is no
09:09:51 <dcoutts> Igloo, http://haskell.org/~duncan/Ar.hs or http://haskell.org/~duncan/Ar2.hs, can't recall which.
09:09:52 <Igloo> dcoutts: I was just looking to see how easy adding ranlib would be  :-)
09:10:02 <dcoutts> Igloo, call ranlib :-)
09:10:20 <dcoutts> Igloo, using my ar + calling ranlib is still much much faster than multiple calls to ar
09:10:21 <Igloo> dcoutts: That'll still use loads of RAM, won't it?
09:10:24 <ndm> glguy: 7 people regularly log in as me, was Simon Marlows suggestion
09:10:30 <glguy> ah
09:10:35 <dcoutts> Igloo, yes, but only once rather than 10 times
09:10:39 <ndm> dcoutts, without -package it still fails the same
09:11:07 <ndm> glguy: if you ever see a commit message deleting all of GHC, it wasn't me ;)
09:11:13 <dcoutts> ndm, I guess that's ghc's fault, I thought it had been fixed in 6.4.2 but apparently not
09:11:35 <dcoutts> ndm, I can't unregister old versions, that'd be rude.
09:11:39 <kowey> earthy: the portfile does not seem to compile it statically
09:12:00 <dcoutts> ndm, perhaps it didn't get fixed 'til 6.6
09:12:01 <ndm> dcoutts, even specifying -package gtk-.... it still conflicts
09:12:06 <kowey> the other thing is that they seem to use gcc-4.0 (as opposed to a more recent one)
09:12:08 <Saizan> dcoutts: how should i test it? i've compiled helloworld and it crashes with a not found libglib-2.0-0.dll
09:12:18 <dcoutts> ndm, !! I'm surprised.
09:12:38 <glguy> ByteStrings have O(1) random access?
09:12:55 <ndm> dcoutts, me too, just cleaning and rebuilding
09:13:02 <dcoutts> Saizan, hmm, can you tell me what your current %PATH% is ? The installer tries to set the path so it can find the dlls
09:13:06 <dcoutts> glguy, yes
09:13:12 <glguy> wonderful :)
09:13:41 <Saizan> @paste
09:13:42 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
09:14:08 <Igloo> ndm: Is the package you don't want to use hiddne?
09:14:16 <dcoutts> Igloo, yeah
09:14:29 <syntaxfree> I hate the term "random access".
09:14:32 <ndm> dcoutts, works a lot better now i've cleaned - suspect that was the issue
09:14:32 <syntaxfree> Random != arbitrary.
09:14:47 <ndm> Igloo: yes, but i think the old .o's were referencing the old version - so not too bad
09:14:49 <dcoutts> Igloo, he had gtk-0.9.10 and then registered gtk-0.9.10.4 which hid the old version 0.9.10
09:14:52 <ndm> dcoutts, C:\ghc\ghc-6.4.2\gcc-lib\ld.exe: cannot find -lxml2
09:14:54 <ndm> collect2: ld returned 1 exit status
09:15:03 <earthy> okay. back to building wxwidgets again.
09:15:05 <Nafai> syntaxfree: "non-sequential" instead of random, perhaps?
09:15:07 <syntaxfree> I think I can conceive of a data structure where picking a random element is cheap but getting the one you want isn't.
09:15:08 <dcoutts> ndm, oh, for glade, oops, that's my fault.
09:15:22 <ndm> @slap dcoutts
09:15:23 <syntaxfree> "Arbitrary access" is good.
09:15:23 <lambdabot> why on earth would I slap dcoutts
09:15:33 <syntaxfree> @slap
09:15:33 * lambdabot slaps
09:15:46 <syntaxfree> @slap lambdaot
09:15:46 * lambdabot beats up lambdaot
09:15:51 <bos> augh, "Could not find module `Text.XML.HaXml.Xml2Haskell': it is a member of package HaXml-1.13.2, which is hidden"
09:15:52 <dcoutts> ndm, heh, lambdabot likes me :-)
09:15:53 <syntaxfree> @slap lambdabot
09:15:53 * lambdabot smacks lambdabot about with a large trout
09:16:00 <syntaxfree> @slap shapr
09:16:00 * lambdabot beats up shapr
09:16:10 <bos> i get this even after "ghc-pkg expose --user HaXml-1.13.2"
09:16:48 * bos wonders what to do
09:16:51 <syntaxfree> @slap dcoutts
09:16:51 <syntaxfree> @yow
09:16:51 * lambdabot smacks dcoutts about with a large trout
09:16:52 <lambdabot> Has everybody got HALVAH spread all over their ANKLES??
09:17:09 <glguy> @tell sorear Weigh in on line highlighting when you get back online
09:17:10 <lambdabot> Consider it noted.
09:17:11 <dcoutts> oh :-( lambdabot doesn't like me that much
09:17:49 <ndm> dcoutts, installer bug? fixable?
09:18:09 <ndm> dcoutts, you might want to add a note somewhere to clean after a Gtk upgrade - not that anyone will read it, of course
09:18:45 <dcoutts> ndm, missing a xml2.lib or libxml2.a file in lib/
09:19:04 * earthy ponders
09:19:22 <earthy> the wxMac integrated in Tiger probably has a two-level namespace
09:19:39 <kowey> uh... that just went over my head
09:19:51 <kowey> (sorry, i'm really very ignorant about computers; just sort of muddle through)
09:20:13 <earthy> oh, you take the same stance I do. useful attitude, that. :)
09:20:20 <dcoutts> ndm, actually you're the only person who'll ever get that problem, since the previous installer didn't support ghc-6.4.2, only 6.4.1 and previous
09:21:16 <ndm> dcoutts, didn't you release the 6.4.2 installer to the mailing list? maybe not officially, but in response to me
09:21:32 <dcoutts> ndm, hrm, maybe
09:28:13 <Igloo> dcoutts: Looks like multiple calls to ar shouldn't be necessary with GNU ar if you use @file, incidentally
09:29:03 <dcoutts> Igloo, great, I couldn't see how to make it read a list from a file but perhaps I was not sufficiently persistent :-)
09:29:29 <Igloo> Well, I haven't tried it, but the manpage says it will work
09:30:45 <ndm> please please please can someone write runhaskell Setup all...
09:31:02 <emk> Notes on high-performance Haskell text munging, based on last night's IRC discussions:
09:31:07 <emk> http://www.randomhacks.net/articles/2007/01/22/high-performance-haskell#comment-237
09:31:10 <lambdabot> Title: High-Performance Haskell, http://tinyurl.com/ywg98e
09:31:35 <emk> Thanks to everyone who helped!
09:32:06 <Igloo> ndm: Won't cabal-install do that for you?
09:32:16 <ndm> Igloo: if it worked, perhaps
09:32:35 <ndm> Igloo: and certainly not for darcs repo's, yet
09:33:01 <glguy> any comments on a paste-bin link to re-announce a paste in channel? (for calling attention back to something at a later date)
09:33:37 <earthy> adding a note to the paste would do something like that, no?
09:33:57 <glguy> and would add a blank annotation
09:34:07 <glguy> which isn't terrible I gues
09:34:08 <ookk> guess in which language (first ["1]) = "1 is false? LOGO...
09:35:42 <fscking-hostile> ?
09:35:48 * Igloo is confused- why not just say the URL here?
09:36:14 <glguy> confused by me?
09:36:32 <Igloo> yes
09:36:41 <glguy> why have a bot in the channel announce them at all?
09:37:31 <glguy> I didn't know if that "feature" didn't exist because no one had bothered to add it before, or if it was unnecessary / unwanted
09:37:36 <glguy> I'm bored at work, thinking of things to add
09:37:44 <glguy> work with me here :)
09:43:46 <glguy> > head $ (listArray (0,1) [ (1:2:undefined), undefined ] // [ (1, 2 : (a ! 0) ]) ! 1
09:43:46 <lambdabot>  Parse error
09:45:00 <glguy> > head $ (listArray (0,1) [ (1:2:undefined), undefined ] // [ (1, 2 : (a ! 0)) ]) ! 1
09:45:01 <lambdabot>   Not in scope: `a'
09:45:29 <glguy> > let a = listArray (0,1) [ (1:2:undefined), undefined ] // [ (1, 2 : (a ! 0)) ] in head (a ! 1)
09:45:30 <lambdabot>  2
09:51:28 <dcoutts> Igloo, what's this about an IsString class? and modifying the Prelude?!
09:53:12 <ndm> dcoutts, it looked scary to me!!!
09:53:13 <bd_> Interesting. After rewriting the sum-file benchmark in the programming languages shootout to use Data.ByteString.Lazy.Char8, I see a signifigant drop in GC time, and a signifigant /increase/ in MUT time. There's overall savings, but wouldn't one ordinarily expect the MUT time to go down as well, since it's not following so many indirections?
09:53:22 <dcoutts> ndm, aye
09:53:24 <bd_> ?paste
09:53:24 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
09:53:59 <dcoutts> bd_, MUT? what's that exactly?
09:54:00 <Igloo> Oh, hadn't noticed it changed the Prelude; it probably shouldn't
09:54:10 <bd_> dcoutts: time spent actually processing, from +RTS -sstderr
09:54:40 <dcoutts> Igloo, aye, that's what I thought.
09:54:45 <bd_> http://hpaste.ath.cx:8000/31 <-- the code
09:55:02 <glguy> bd_: hpaste failed to announce that?
09:55:09 <glguy> !id test
09:55:10 <hpaste> test
09:55:10 <bd_> apparently :/
09:56:09 <hpaste>  glguy annotated "announce test" with "announce test" at http://hpaste.ath.cx:8000/4#11
09:56:17 <glguy> bd_: did you check "silent"?
09:56:39 <bd_> glguy: oh, oops XD
09:56:51 <bd_> must've been on autopilot with the remember me box
09:56:58 <bd_> I must try to get more sleep >.>
09:57:01 <glguy> bd_: you only have to remember box the first time
09:57:24 <malebria_> I'm loading a .hs file with GHCi and seeing the infered type with :type.
09:57:26 <glguy> if you want to start using a new nick, you can recheck it
09:57:37 <malebria_> I'm getting a type, but when I add the type signature to the source file, I get a compilation error.
09:57:44 <sjanssen> bd_: what is the total time change between the two versions?
09:57:48 <malebria_> Non-type variable argument in the constrant MonadState (Set.Set Object) m
09:57:50 <malebria_>  (Use -fglasgow-exts to permit this)
09:57:53 <malebria_> createObject0_1 :: (MonadState (Set.Set Object) m) => Int -> BasicParameters -> m ()
09:57:58 <malebria_> But I called ghci without -fglasgow-exts
09:58:01 <malebria_> Is this a bug?
09:58:22 <bd_> sjanssen: the MUT/GC time, or overall CPU time?
09:58:25 <ToRA> bd_: is it a big performance hit to swap the case BS.readI.... with a fst . fromJust . BS.readInt ?
09:58:34 <kolmodin> ndm: I wrote this code with your code as base: http://darcs.haskell.org/binary/tools/derive/BinaryDerive.hs
09:58:39 <kolmodin> ndm: took forever to write :)
09:58:41 <sjanssen> bd_: overall time
09:58:42 <bd_> ToRA: probably not, I just didn't think of that at the time :)
09:59:06 <bd_> sjanssen: 8s -> 6s with this dataset
09:59:10 <chessguy> i really want to get my hands dirty working on a real, hopefully useful, package, as a n00b. anyone gone any suggestions what i should work on?
09:59:23 <malebria_> chessguy: darcs?
09:59:26 <ToRA> bd_: ah ok
09:59:36 <bd_> the odd this is, the old one had 3.78s MUT, 4.32s GC; the new one is 5.86s MUT, 0.15s GC
09:59:41 <chessguy> malebria_, what about it?
09:59:48 <bd_> and I'm wondering why MUT went /up/
09:59:56 <sjanssen> bd_: the extra MUT may be the added indirections with the temporary lists created by lines and map
09:59:59 <bd_> when one would expect it to drop somewhat
10:00:09 <bd_> hmm
10:00:17 <malebria_> chessguy: is a useful package.
10:00:20 <bd_> isn't that all supposed to be fused away? :)
10:00:37 <sjanssen> bd_: the current fusion system can't fuse sum
10:00:43 <fasta> chessguy: you could implement more data structures.
10:00:45 <chessguy> malebria_, i'm looking for a project that needs some hacking on
10:00:46 <malebria_> I'm using dons script to infer type, but I can't compile with the infered types.
10:00:47 <bd_> oh
10:00:53 <malebria_> chessguy: darcs surely needs.
10:01:05 <chessguy> fasta, such as?
10:01:09 <malebria_> chessguy: bugs.darcs.org
10:01:15 * bd_ tries foldl1 (+)
10:01:19 <fasta> chessguy: Fibonacci heaps, I think
10:01:26 <sjanssen> bd_: same problem with foldl
10:01:37 <glguy> ?hoogle withMVar
10:01:38 <fasta> chessguy: disjoint set
10:01:38 <lambdabot> Control.Concurrent.MVar.withMVar :: MVar a -> (a -> IO b) -> IO b
10:01:39 <dcoutts> bd_, we're going to put the new bytestring implementation into ghc 6.6.1 it'll have the same api but the new fusion system, so you should gain a factor in that sumfile example
10:01:47 <sjanssen> bd_: no left folds can be fused
10:02:09 <dcoutts> sjanssen, though he's looking at bytestring functions, so they can be fused.
10:02:13 <chessguy> fasta, ok, i'll play around with those
10:02:14 <sjanssen> dcoutts: I don't think any stream fusion will fire in bd_'s case
10:02:30 <sjanssen> dcoutts: the things that need to fuse are the list functions sum and map
10:02:33 <chessguy> i'll have to figure out what they are first :)
10:02:54 <bd_> hm. foldr1 causes a stack overflow
10:03:08 <chessguy> oh, is disjoint-set the same as union-find?
10:03:10 <bd_> which I suppose is to be expected
10:03:13 <malebria_> So if I want the most generic definition I can't specify the type?
10:03:15 <fasta> chessguy: yes
10:03:23 <chessguy> ah cool
10:03:47 <malebria_> If I can't get a function with partition__ :: (MonadState (Set.Set a) t, Ord a) => (a -> Bool) -> t (Set.Set a)
10:03:47 <chessguy> that seems easy
10:03:56 <bd_> oh well, a 25% speed improvement *and* additional readability isn't such a bad result :)
10:03:59 <ndm> kolmodin, took me an hour on a train to get the original going - SYB is hard to use!
10:04:03 <malebria_> Why does GHCi infer it's type as this?
10:04:16 <glguy> ?docs Data.Char
10:04:16 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Char.html
10:04:27 <dcoutts> sjanssen, ah, yes, I think you're right. We need stream fusion for lists.
10:04:35 <sjanssen> dcoutts: yep :)
10:04:40 <ndm> kolmodin, i was going to layer a library on top to make it easier to write instances - would that interest you?
10:04:54 <dcoutts> sjanssen, I'm going to GHC HQ this Friday to discuss exactly that :-)
10:05:01 <ndm> kolmodin, i.e. it creates a nice simple AST, you walk the AST, the AST abstracts the complex bits away
10:05:03 <sjanssen> dcoutts: nice
10:05:06 <kolmodin> ndm: yes, it really would
10:05:12 <kolmodin> ndm: sounds perfect
10:05:14 <dcoutts> g'evening kolmodin
10:05:18 <ndm> kolmodin, ok, might try that tomorrow then
10:05:20 <kolmodin> hia dcoutts
10:05:23 <kolmodin> ndm: great
10:05:43 <ndm> (although this delays Catch even further ;))
10:05:49 <kolmodin> hah :)
10:06:01 <kolmodin> as long as you can keep your internal deadline :)
10:07:54 <sjanssen> glguy: any idea why "annotate this paste" might be hanging?
10:08:10 <glguy> sjanssen: no, but I can look
10:08:18 <glguy> !id up?
10:08:37 <sjanssen> glguy: actually, I think it's down entirely
10:08:44 <hpaste> up?
10:08:50 <glguy> sjanssen: I figured it out :)
10:09:03 <glguy> I learned a valuable lesson about screen
10:09:16 <hpaste>  sjanssen annotated "Why is MUT so high on the second code sample?" with "is this faster?" at http://hpaste.ath.cx:8000/31#1
10:09:21 <glguy> when you are in copy mode to view the scroll back
10:09:29 <glguy> the process is paused
10:09:32 <glguy> I didn't know that
10:09:36 <sjanssen> bd_: want to try that version ^^^
10:10:06 <svref> How do I print out a double to two digits precision?  E.g.  pi -> "3.1"?
10:11:31 <bd_> sjanssen: hm, about 1.2s faster :)
10:11:46 <bd_> sjanssen: though that might be cheating
10:12:11 <sjanssen> bd_: and that bang pattern might not be necessary, cutting out that ugly pragma
10:12:15 <sjanssen> bd_: cheating? why?
10:12:25 <bd_> too clever for the shootout? I don't know :)
10:12:28 <svref> why does floatRadix take an argument?
10:12:38 <bd_> I would've expected ghc to inline things like sum
10:12:44 <bd_> so it could do that sort of optimization
10:13:13 <sjanssen> bd_: the only restriction I remember is that the program should use a library int reading routine, not a hand rolled one
10:13:59 <sjanssen> ghc doesn't know how to fuse a left fold (like sum) with map
10:15:19 <sjanssen> bd_: there are plans to replace ghc's fusion with a more flexible system that can fuse left folds.  You might see it in GHC 6.8
10:15:34 <SyntaxNinja> w00t
10:15:51 <bd_> ah
10:16:01 <SyntaxNinja> @seen shapr
10:16:01 <lambdabot> I saw shapr leaving #scannedinavian, #unicycling and #haskell 2d 15h 13m 33s ago, and .
10:17:06 <svref> is the best algorithm for printing N digits of a float to do (show float), then take the string apart, carefully looking for (e3) and whatnot?
10:17:16 <dcoutts> sjanssen, ah yes, manually fusing the sum with the map
10:17:37 <emu> svref: printf?
10:17:58 <ndm> Yhc can fuse sum and map, with the appropriate super-optimiser attaached
10:17:58 <chessguy> @pl sing x = (length x) == 1
10:17:58 <lambdabot> sing = (1 ==) . length
10:18:09 <sjanssen> @hoogle showFFloat
10:18:10 <lambdabot> Numeric.showFFloat :: RealFloat a => Maybe Int -> a -> ShowS
10:18:13 <chessguy> cute
10:18:26 <sjanssen> svref: that function, or something else in Numeric might help
10:18:43 <bd_> sjanssen: I'm thinking of submitting a modified version to the shootout; how would you like to be credited? :)
10:18:48 <chessguy> @pl sing x = (foo x) == 1
10:18:48 <lambdabot> sing = (1 ==) . foo
10:19:13 <sjanssen> bd_: my real name, Spencer Janssen
10:19:22 <dcoutts> ndm, did you have a clear description of that? and have you seen Ohori's paper on lightweight fusion by 'fixpoint promotion' ?
10:19:33 <ndm> dcoutts, no * 2
10:19:50 <dcoutts> ndm, recently presented at POPL
10:19:59 <svref> I don't understand how "printf" exists in Haskell.  Does Haskell support variable arity?
10:20:04 <ookk> !paste
10:20:04 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
10:20:11 <dcoutts> ndm, if you have a good system you should write a paper on it
10:20:28 <sjanssen> svref: you can simulate it with some type class gymnastics
10:20:34 <hpaste>  bd_ annotated "Why is MUT so high on the second code sample?" with "final version?" at http://hpaste.ath.cx:8000/31#2
10:20:34 <rahikkala> svref: It does of you're Oleg
10:20:45 <rahikkala> http://okmij.org/ftp/Haskell/types.html#polyvar-fn
10:20:45 <dcoutts> ndm, my supervisor says one should "take a greedy approach to writing papers"
10:20:47 <lambdabot> Title: Haskell Programming: Types
10:20:49 <uccus> shootout rant: Gentoo Intel Pentium 4 Computer Language Shootout measuring only Full CPU time, Clean is in the 4th place, Haskell at 18th! with personal favorite Scala at 9th! [Scala runs of JVM!]
10:20:56 <sjanssen> ndm: aye, I'd like to know more about your secret fusion system
10:21:17 <uccus> s/of/on
10:21:24 <ndm> dcoutts, sjanssen i explained it to catamorphism at Hac 07, i will hopefully write it at some point :)
10:21:34 <malebria_> If I have a StateT [Int] IO Int function, and I want to call inside it a State [Int] Int function, what can I use?
10:21:34 * ndm is busy writing a different paper right now
10:23:25 <ToRA> malebria_: won't you need to promote the outer function to include IO in the sig too somewhere?
10:23:41 <svref> Thanks all!
10:24:42 <malebria_> ToRA: promote?
10:24:51 <ToRA> erm, change
10:25:44 <malebria_> ToRA: I though I could call a State [Int] Int from a StateT [Int] IO Int..
10:25:58 <ToRA> oh sorry
10:26:03 <ToRA> i misread your order
10:26:17 <ToRA> you're going the safe way :)
10:26:21 <malebria_> Yes..
10:26:27 <malebria_> But I don't know how to proceed.
10:27:57 <ToRA> i don't know off the top of my head
10:28:09 <ToRA> but i'll try and work it out for you unless someone beats me to it
10:28:23 <ToRA> i'm assuming you want the state to thread through?
10:29:01 <malebria_> Is like in a IO Int function calling a Int function.
10:29:45 <malebria_> I have a State [Int] Int function that I want to call from a StateT [Int] IO Int function.
10:30:22 <malebria_> I got to go now.
10:30:29 <malebria_> I'll come back later.
10:30:31 <malebria_> ToRA: Thanks.
10:30:34 <ToRA> 'k
10:30:56 <dcoutts> hia shapr, SyntaxNinja was after you
10:30:58 <shapr> y0
10:30:59 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
10:31:06 <glguy> shapr: yo
10:31:11 <sjanssen> \action -> do s <- get; let {(x, s') = runState action s}; put s'; return x :: (MonadState t1 t) => State t1 t2 -> t t2
10:31:17 <glguy> !id test
10:31:17 <hpaste> test
10:31:21 <shapr> glguy: hiya! ScannedInAvian workin for you?
10:31:22 <kolmodin> dons: there?
10:31:23 <sjanssen> aww, and I just solved malebria_'s problem
10:31:33 <glguy> shapr: wonderfully
10:31:34 <ToRA> @paste
10:31:35 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
10:31:35 <shapr> yay!
10:31:47 <glguy> !admin+ :shapr!n=user@cs6625112-203.bham.res.rr.com
10:31:51 <shapr> w00!
10:31:55 <glguy> shapr: type !id test
10:31:59 <shapr> !id test
10:31:59 <hpaste> test
10:32:02 <shapr> I got tha powah!
10:32:06 <glguy> !admin- :shapr!n=user@cs6625112-203.bham.res.rr.com
10:32:08 <glguy> try again
10:32:11 <shapr> !id test
10:32:17 <shapr> spiffeh!
10:32:17 <glguy> woot, worked on the first try
10:32:18 <hpaste>  ToRA pasted "StateT with State" at http://hpaste.ath.cx:8000/33
10:32:39 <glguy> shapr: I added a !quiet  and !verbose  toggle command pair to stop paste announces
10:32:47 <glguy> !admin+ :shapr!n=user@cs6625112-203.bham.res.rr.com
10:32:48 <ToRA> sjanssen...were you on the same kinda thought lines?
10:32:56 <glguy> admin+ doesn't persist yet, however
10:33:12 <sjanssen> ToRA: yes, my solution is nearly identical
10:33:14 <shapr> Have you tried SimpleHTTP2 yet?
10:33:35 <glguy> shapr: I have not
10:33:45 <glguy> shapr: doesn't mean I am not interested, however ;)
10:33:56 <shapr> We'd like to hear what you think about it.
10:34:12 <glguy> shapr: I need to figure out how it works first !
10:34:21 <shapr> Have you seen the wiki tutorial?
10:34:35 <glguy> I've seen it, need to read closer
10:34:55 <glguy> last time I looked I was panicking because my server was down and my code was stranded
10:35:36 <ToRA> @tell malebria_ http://hpaste.ath.cx:8000/33
10:35:36 <lambdabot> Consider it noted.
10:35:38 <shapr> I can understand that. I've been in that same panicky situation before.
10:36:04 <glguy> shapr: http://hpaste.ath.cx:8000/17/diff?from=0&to=1
10:36:06 <shapr> mmm, I upgraded my cable subscription, I like getting 1.5M from the nearby debian/unstable mirror.
10:36:18 <shapr> oh cool!
10:36:31 <SyntaxNinja> hi dcoutts
10:36:35 <SyntaxNinja> hi shapr
10:36:43 <shapr> SyntaxNinja! You were looking for me?
10:36:54 <SyntaxNinja> shapr: you can probably guess what I was going to tell you ;)
10:36:59 * shapr guesses!
10:37:03 <shapr> You got a Nokia 800!
10:37:05 <shapr> Am I right?
10:37:19 <shapr> And you've just starting porting GHC to it, yes?
10:37:58 <shapr> If you're porting GHC to it, stepcut sent me a lot of useful information on how he built GHC 6.5 for it, want me to forward the email to you?
10:38:25 <glguy> bd_: still there?
10:38:31 <Lemmih> shapr: Heya, what's the preferred way of performing IO in the Ev environment?
10:38:47 <psnl> shapr: you can run ghc on one of these phone things?
10:38:57 <SyntaxNinja> shapr: yes, I got the nokia :)
10:39:00 <shapr> With The Optimization Group's recent changes to Data.ByteString, binaries might be fast enough on the tablets.
10:39:02 <SyntaxNinja> I didn't port any ghc hehe
10:39:10 <SyntaxNinja> but I bet nhc or hugs would work pretty easily. who knows.
10:39:19 <shapr> Lemmih: I don't know, show me the code and I might?
10:39:41 <glguy> shapr: link to new tutorial again?
10:39:47 <SyntaxNinja> shapr: me & andy gill just did a voip-video chat w/ them.
10:39:59 <shapr> glguy: http://www.haskell.org/haskellwiki/HAppS_tutorial
10:40:00 <SyntaxNinja> man. google is damn smart to take over the jabber protocol.
10:40:00 <lambdabot> Title: HAppS tutorial - HaskellWiki
10:40:01 <dcoutts> shapr, heh "The Optimization Group" :-)
10:40:02 <bd_> glguy: hm?
10:40:03 <shapr> SyntaxNinja: Oh cool!
10:40:08 * cjeris ports GHC to an HP 48GX
10:40:25 <glguy> bd_: I was just going to say that your code make a good example of why diff could be useful http://hpaste.ath.cx:8000/31/diff?from=1&to=2
10:40:30 <shapr> dcoutts: Maybe 'cold fusion' would be a better group name =)
10:40:34 <glguy> bd_: for comparing your iterations
10:40:36 <dcoutts> shapr, oh yeah
10:40:48 <bd_> glguy: ah :)
10:40:57 <glguy> bd_: so thanks for providing me a better demo case
10:41:01 <dcoutts> shapr, next up is loops, currently our loops are terrible
10:41:03 <bd_> the bang pattern didn't really make a performance difference, for anyone who might be wondering
10:41:07 <Lemmih> shapr: I don't really have anything more complicated than the example in SimpleHTTP2.hs.
10:41:11 * shapr hOps hAppily
10:41:24 <shapr> Lemmih: Ah, have you seen the wiki tutorial?
10:42:02 <shapr> Alex says that IO can be executed in the list items. Does it not work for you?
10:42:26 * shapr just spent $150 on Ritalin
10:42:39 <shapr> I wonder if I can count that as a business expense...
10:43:08 <dcoutts> shapr, it's worth a go, can one count tea as a business expense?
10:43:16 * dcoutts can't work without tea
10:43:27 <shapr> Good point, if I can't work without it...
10:44:17 <Lemmih> shapr: In the list items of 'stdHTTP'?
10:44:36 <shapr> Yeah, I think so.
10:45:01 <glguy> shapr: how do I write the function aux such that: h "/([0-9]+)/([0-9]+)/plain" aux
10:46:20 <shapr> You want to match any prefix with a /plain postfix? hmm...
10:46:39 <glguy> shapr: for exmaple     /0/1/plain
10:46:49 <glguy> does that use the String -> [String] matcher?
10:49:12 <shapr> glguy: I'm trying it..
10:49:54 <Lemmih> shapr: I don't see how that's possible. The 'simple_io_result.hs' example executes IO in the result, I need to execute IO in the Ev monad. And 'blocking_io.hs' uses 'simpleHTTPIO' which doesn't exist anymore.
10:50:20 * Lemmih feels horribly ineffective.
10:57:36 <Lemmih> shapr: I'm almost done for the day. I'll poke you again tomorrow (:
10:58:29 <glguy> shapr: is XHtml string output xml_plain?
10:58:30 <glguy> xml?
10:59:12 <shapr> Lemmih: ok
10:59:57 <shapr> Lemmih: I'll be online earlier tomorrow.
11:00:23 <shapr> Lemmih: When is your day usually?
11:00:54 <Lemmih> shapr: I usually start working around 10am.
11:01:23 <shapr> Lemmih: ok
11:01:58 <Lemmih> shapr: You're in GMT-5, right?
11:02:28 <shapr> Yeah, I'll try to be online and awake by 14:00 your time.
11:03:29 <csci> Hello, after playing for two days with haskell my opinion is that deeper understanding of monads is not needed for *beginners*, i.e. for me the syntax of do ... a lot of IO operations is sufficient until I want to extend (?) some monads. Would you (the channel members) say that's right?
11:03:46 <shapr> csci: I agree.
11:04:14 <csci> shapr: Nice, so I'm on the right way. I really like the expressive power of the language...
11:05:22 <shapr> glguy: xml_plain is for outputting plain text, yeah. It started because plain won't render State types, only String. I don't exactly know why though.
11:05:40 <glguy> shapr: plain text aka HTML output?
11:08:25 <glguy> shapr: which example in the tutorial shows how to read values from the query string?
11:08:35 <glguy> old "getEvent" and "lookS"
11:31:03 <uccus> when is lazy foldl useful?
11:31:46 <sris> is it possible to use ghc to compile haskell on an intel based mac?
11:32:20 <apfelmus> uccus: never, i think
11:32:50 <uccus> apfelmus: I thought so
11:34:17 <sieni> sris: http://www.haskell.org/ghc/download_ghc_66.html#macosxintel
11:34:18 <lambdabot> Title: GHC: Download version 6.6
11:34:46 <sris> sieni: ah, thanks
11:38:49 <dcoutts> uccus, last = foldl (\a b -> b) (error "last []")
11:38:59 <dcoutts> uccus, you can't do that with foldl'
11:39:20 <csci> Quite a stupid question, but how do I load modules, e.g. Data.Array, while I'm in ghci?
11:39:32 <dcoutts> csci, :m + Data.Array
11:39:36 <dcoutts> > let last = Data.List.foldl (\a b -> b) (error "last []") in last [undefined, 1]
11:39:37 <lambdabot>  1
11:39:42 <dcoutts> > let last = Data.List.foldl' (\a b -> b) (error "last []") in last [undefined, 1]
11:39:44 <lambdabot>  Undefined
11:39:50 <dcoutts> uccus, see ^^
11:39:51 <csci> dcoutts: Ah, Thanks, I forgot the +
11:40:03 <uccus> @src last
11:40:04 <lambdabot> last [x]    = x
11:40:04 <lambdabot> last (_:xs) = last xs
11:40:04 <lambdabot> last []     = undefined
11:40:18 <uccus> dcoutts: which is faster?
11:40:37 <dcoutts> uccus, the direct definition is probably faster (though can't be fused)
11:41:26 <uccus> dcoutts: so basically foldl of a function that forgets something should be lazy, right?
11:41:35 <dcoutts> actually, that direct definition looks two along the list each time so isn't optimal
11:41:40 <dcoutts> uccus, right
11:41:45 <apfelmus> @type foldl (\a b -> b) (error "last []")
11:41:47 <lambdabot> forall b. [b] -> b
11:42:09 <dcoutts> uccus, you're right that almost all uses of foldl should actually be foldl' or foldr
11:42:26 <uccus> dcoutts: but if a function forgets something, it's probably not a good idea to use a fold anyway!
11:42:48 <apfelmus> > let last = foldl (\a b -> b) (error "last []") in last [1..5]
11:42:49 <lambdabot>  5
11:42:53 <dcoutts> uccus, the general rule of thumb is that if you're building a small strict value (eg an int) then use foldl', if you want to lazily consume the list and build some other lazy value then use foldr
11:43:30 <hpaste>  kowey pasted "not pretty enough..." at http://hpaste.ath.cx:8000/34
11:43:58 <uccus> dcoutts: understood. thanks.
11:45:36 * shapr hops frivolously
11:46:16 <uccus> kowey: you looking for list-monadic solution I suppose?
11:47:10 <kowey> uccus: perhaps... i just get the feeling i'm making this way more complicated than they should be
11:47:58 <hpaste>  sjanssen annotated "not pretty enough..." with "better?" at http://hpaste.ath.cx:8000/34#1
11:49:31 <kowey> sjanssen: hmm... that is prettier, though i'm not sure the hypothetical 'next guy looking at my code' will get it (then again, maybe by virtue of it being simpler?)
11:50:04 <kowey> oh wait
11:50:09 <sjanssen> I'd say my version is far more simple than the original solution
11:50:19 <uccus> kowey: I assure you it''s an easier read and conceptually clear
11:50:22 <kowey> right... /me tries adding in a couple more points
11:50:48 <sjanssen> yeah (\y -> (x, y)) might be more clear
11:51:25 <dcoutts> kowey, hoe about: [ (x,y) | x <- xs, y <- xs, x < y ]
11:51:29 <dcoutts> hoe/how
11:51:34 <uccus> does (x,) work?
11:51:43 <dcoutts> uccus, sadly not.
11:51:51 <kowey> dcoutts: that's the kind of thing i was thinking of!
11:52:13 <sjanssen> it isn't quite the same thing, the elements must be in Ord
11:52:14 <uccus> kowey: you didn't say anything about order!
11:52:31 <kowey> right, which is why i'm going with sjanssen's solution
11:52:49 <kowey> but my dream solution looked a lot like dcoutts
11:52:50 <dcoutts> kowey, mind you, your original solution was faster by about 1/2 since mine searches the whole cross product
11:53:41 <hpaste>  apfelmus annotated "not pretty enough..." with "higher order" at http://hpaste.ath.cx:8000/34#2
11:53:45 <uccus> as it's customary here in #haskell, can someone please provide a monadic solution?
11:54:45 <dcoutts> uccus, any list comprehension can be converted into a version in the list monad, just not as pretty.
11:55:09 <dcoutts> we need that @desugar or @monadcomp plugin :-)
11:55:11 <sjanssen> @pl \xs -> nub $ liftM2 (,) xs xs -- is close
11:55:12 <lambdabot> nub . join (liftM2 (,))
11:55:22 <dcoutts> @pl [ (x,y) | x <- xs, y <- xs, x < y ]
11:55:22 <lambdabot> [(x, y) | x <- xs, y <- xs, x < y]
11:55:34 <dcoutts> sadly pl can't do list comprehensions
11:55:42 <dons> morning all!
11:55:43 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
11:55:52 <dcoutts> g'morning dons
11:56:14 <kowey> (thanks all, morning dons)
11:56:20 <dons> how's code in merry old england, dcoutts ?
11:56:29 <dons> can we get this binary lib done in the next few days :)
11:56:51 <hpaste>  apfelmus annotated "not pretty enough..." with "higher order, comprehensively" at http://hpaste.ath.cx:8000/34#3
11:56:59 <dcoutts> dons, perhaps yes, but I also need to do a @desugar plugin for Friday :-)
11:57:10 <dons> oh?
11:57:24 <dcoutts> dons, well that or do it by hand for some examples
11:57:41 <chessguy> hey dons, have you played around with LB on a 64-bit architecture at all?
11:57:46 <dcoutts> dons, SPJ wants to look at fusing some list comps
11:57:47 <dons> dcoutts: oh, btw, someone was asking for Double parseing from bytestrings, for a work related tool, so I hacked up http://hpaste.ath.cx:8000/26#2
11:57:57 <dons> ah yes
11:58:08 <dons> chessguy: hmm. it's been done I think
11:58:16 <dcoutts> dons, ah libc's strtod
11:58:30 <dons> dcoutts: right.
11:58:42 <chessguy> oh? hs-plugins barfed out a really bizarre overflow error or something when i tried to do a simple evaluation like > 3
11:58:52 <dons> but it was very cheap to code these up, makes me thing there should in general be some quick and dirty bindings to libc parsing..
11:59:00 <dons> chessguy: hmm.
11:59:02 <chessguy> i don't have the machine handy, so i can't be more specific at the moment
11:59:11 <dons> ghc 6.4.x?
11:59:23 <chessguy> no, i upgraded to 6.6
11:59:32 <dons> hs-plugins won't like ghc 6.6 though
11:59:50 <chessguy> oh ok
12:00:35 <chessguy> hmm, did i rebuild with 6.6? i can't remember now
12:00:54 <chessguy> i know the build worked
12:01:13 <dcoutts> dons, so does strtod expect a 0-terminated string?
12:01:14 <sjanssen> dcoutts: desugaring list comprehensions could be a generalization of the existing code for @undo
12:01:27 <dcoutts> sjanssen, yes, that's what I was thinking too
12:01:39 <dcoutts> I suppose I should look at the code
12:02:10 <dons> dcoutts: yeah
12:02:16 <dons> I think...
12:02:20 <uccus> [f x
12:02:30 <dcoutts> dons, hmm that's annoying since we have to copy
12:02:37 <dons> right
12:02:53 <dons> i suppose we could create our own strntod
12:03:11 <uccus> [f x y | x <- xs, y <- ys, p x]... how does this look using do?
12:03:13 <dcoutts> how does the pure Haskell one work?
12:03:50 <vegai> dons: is there something hard in hs-plugins v ghc6.6, or have you just been very busy?:)
12:03:53 <uccus> do x <- xs; y <- ys; ... ; return (f x y)? what should I use in place of ...?
12:04:09 <kowey> liftM2 ?
12:04:14 <dons> vegai: the latter
12:04:36 <resiak> :t guard
12:04:38 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:04:39 <resiak> @type guard
12:04:41 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
12:04:41 <dons> dcoutts: we should look at serialisaing floating point types in Binary at some point
12:04:49 <dcoutts> dons, aye
12:04:52 <uccus> oh... thanx resiak
12:04:52 <kowey> (oh, in place of the "..."; sorry)
12:04:53 <dons> though how to do that portably i'm not sure
12:04:54 <resiak> oh, sorry. I didn't know lambdabot understood :t :/
12:04:59 <dons> pack . show works, I guess :)
12:05:06 <sjanssen> dons: toRational?
12:05:10 <resiak> uccus: I think it's guard, but I'm not very good at this stuff.
12:05:12 <dons> hmm?
12:05:12 <dcoutts> dons, at least there's a binary standard for that ieee whatever
12:05:18 <dons> ah ok
12:05:21 <dons> that helps
12:05:42 <dcoutts> dons, so it should just be a specific endian version of that
12:06:01 <dcoutts> and conveniently all modern machines use that binary rep natively
12:06:05 <dcoutts> (I think)
12:06:05 <dons> ?users
12:06:06 <lambdabot> Maximum users seen in #haskell: 312, currently: 312 (100.0%), active: 43 (13.8%)
12:06:14 <dons> hey ^^
12:06:18 <dcoutts> :-)
12:06:24 <dons> new local maxima, and hmm, 5 off the record, iirc
12:06:44 * dcoutts starts 5 clones
12:06:47 <dons> i should wake up at 7am more often
12:06:49 <dcoutts> hah
12:07:42 <uccus> resiak: guard works.
12:08:01 <resiak> uccus: yep, so I found in ghci.
12:08:59 <uccus> > let com xs ys = do x <- xs; y <- ys; guard (x + y < 5); return (x, y) in com [1, 2, 3] [1, 2, 3]
12:09:01 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(3,1)]
12:09:38 <resiak> How do I ask lambdabot for the @src for [a]'s guard implementation
12:09:46 <resiak> Also, who stole my '?'?
12:10:17 <uccus> now I know how to explain list monad to Java/C# programmers!
12:10:47 <syntaxfree> hwo?
12:11:21 <uccus> the for construct. in C#, foreach, in java, for( : )...
12:11:28 <dcoutts> dons, SPJ has posted his lightweight views/patterns proposal with slightly different syntax than he showed us before
12:11:37 <dons> ah ok. where's that? in the mailing list?
12:11:40 <dcoutts> aye
12:11:43 <dons> i'll get to that soon
12:12:01 <dons> uccus: hmm, yeah, like foreach perhaps, but more general?
12:12:19 <uccus> yes, not 'like' foreach, exactly foreach!
12:12:52 <uccus> kowey: can I put this somewhere in the Haskell Wikibook? good idea? really bad idea?
12:13:24 <dons> uccus: hmm, but the list monad isn't like foreach
12:13:37 <uccus> dons: how?
12:13:44 <allbery_b> @src [] guard
12:13:45 <lambdabot> Source not found. You type like i drive.
12:14:07 <kowey> uccus: try it... i'd rather the understanding monads chapter be focused though (e.g. Haskell-only)
12:14:10 <dons> ?src (>>=) []
12:14:10 <lambdabot> Source not found. Where did you learn to type?
12:14:14 <allbery_b> @src [] show
12:14:15 <lambdabot> Source not found. You speak an infinite deal of nothing
12:14:21 <allbery_b> @src [] (>>=)
12:14:22 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:14:22 <dons> ?src [] (>>=)
12:14:23 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:14:36 <resiak> Ah, see, I thought the list type was spelled [a]
12:14:41 <dons> ?src [] (>>)
12:14:41 <lambdabot> m >> k      = foldr ((++) . (\ _ -> k)) [] m
12:15:04 <dons> so you get folds and concat... i'm pretty sure foreach doesn't do that. ;)
12:15:12 <dons> foreach is more like `flip map`
12:15:27 <dons> ?let for = flip map
12:15:28 <lambdabot> Defined.
12:15:33 <dons> > for [1..10] show
12:15:34 <lambdabot>  ["1","2","3","4","5","6","7","8","9","10"]
12:15:39 <uccus> oh dons, have a look at http://haskeller.blogspot.com/ [my blog entry] it's somewhat entertaining (and dedicated to lambdabot)
12:15:41 <lambdabot> Title: Maybe Haskell
12:16:09 <syntaxfree> yay! new haskell blogs!
12:16:16 <syntaxfree> uccus: is it on planet haskell yet?
12:16:36 <uccus> syntaxfree: it should not go to planet haskell, not yet, I'm less than a newbie
12:16:58 <syntaxfree> me too, but I'm there :)
12:17:05 <syntaxfree> at least I flood out the christmas posts a little ;)
12:17:07 <uccus> syntaxfree: lol
12:18:02 * psnl keeps his blog quiet
12:18:05 <chessguy> > for [1..10] \x->x*x
12:18:06 <lambdabot>  Parse error
12:18:11 <uccus> syntaxfree: I read your blogs
12:18:15 <chessguy> > for [1..10] (\x->x*x)
12:18:16 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
12:18:20 <chessguy> nice
12:18:40 <dcoutts> Saizan, ah, I figured out why the prog failed to find the .dll
12:18:46 <syntaxfree> this is funny: http://mooseyard.com/Jens/2005/06/lesser-known-scripting-languages/
12:22:59 <uccus> well, for (as it stands now) it's pretty when nesting, but the list monad is cool (and so are nested foreach declarations)
12:23:24 <uccus> though I reckon return means yield (in C#)
12:26:00 <csci> I'm searching kind-of apply operator, but have found nothing in Data.List, e.g. <APPLY-OPERATOR> putStrLn [show (i, i^2) | i <- [0..20]]. It's a two-liner but I think there must be something predefined?
12:26:13 <dons> what is its type?
12:26:31 <dons> and what do you want it to do?
12:26:37 <dons> ?users
12:26:37 <lambdabot> Maximum users seen in #haskell: 313, currently: 313 (100.0%), active: 46 (14.7%)
12:26:59 <syntaxfree> csci: look at the types.
12:26:59 <csci> dons: apply f [list] would apply f to all elements of f successively
12:27:02 <syntaxfree> types shall enlighten you.
12:27:08 <dons> so its a map?
12:27:17 <dons> > [show (i, i^2) | i <- [0..20]]
12:27:19 <lambdabot>  ["(0,0)","(1,1)","(2,4)","(3,9)","(4,16)","(5,25)","(6,36)","(7,49)","(8,64)...
12:27:21 <dons> > map reverse [show (i, i^2) | i <- [0..20]]
12:27:22 <csci> yes, but without returning another list
12:27:23 <lambdabot>  [")0,0(",")1,1(",")4,2(",")9,3(",")61,4(",")52,5(",")63,6(",")94,7(",")46,8(...
12:27:27 <dons> ah, mapM_ ?
12:27:34 <dons> :t mapM_
12:27:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> [a] -> m ()
12:27:40 <csci> Umm, Maybe (new to lisp)
12:27:42 <syntaxfree> use :t here
12:27:45 <csci> argh, haskell ;-)
12:27:48 <syntaxfree> then use @hoogle
12:27:57 <csci> ah, never heard of, thanks
12:28:02 <dons> > mapM_ putStrLn [show (i, i^2) | i <- [0..20]]
12:28:04 <lambdabot>  <IO ()>
12:28:07 <dons> :)
12:28:29 <dons> its map, liftedinto a monad (hence the M) and throws away the result, (hence the _ suffix)
12:28:30 <syntaxfree> > sequence $ mapM_ putStrLn  [show (i, i^2) | i <- [0..20]]
12:28:31 <lambdabot>  Couldn't match `m a' against `()'
12:28:38 <dons> nope, sequence_ . map
12:28:44 <syntaxfree> hmm.
12:28:58 <dons> > sequence_ $ map putStrLn [show (i, i^2) | i <- [0..20]]
12:29:00 <lambdabot>  <IO ()>
12:29:20 <csci> (Sometimes, for me nearly always, haskell is damn difficult... ;-))
12:29:35 <syntaxfree> heh. "Information superhighway" is an anagram for "Hi-ho! Yow! I'm surfing Arpanet!"
12:29:38 <dons> there's also forM and forM_
12:29:41 <syntaxfree> csci: this is a hard example, since it involves IO.
12:29:47 <dons> forM_ [show (i, i^2) | i <- [0..20]] putStrLn
12:29:47 <syntaxfree> you should really separate concerns.
12:29:50 <syntaxfree> let IO to the end.
12:30:22 <uccus> csci: syntaxfree's advice is one of the most celebrated
12:30:26 <csci> I've done something with functional programming and even a small tcp/ip-server worked, so I thought printing out a list should be trivial... well...
12:30:44 <syntaxfree> csci: it is.
12:30:56 <syntaxfree> > print [show (i, i^2) | i <- [0..20]]
12:30:56 <csci> syntaxfree: for you ;-)
12:30:58 <lambdabot>  <IO ()>
12:31:05 <syntaxfree> lambdabot doesn't do IO.
12:31:09 <syntaxfree> but all you need is print.
12:31:12 <syntaxfree> print and interact.
12:31:14 <uccus> it's trivial. call putStr, and concat your list with "\n"s interleaved
12:31:18 <syntaxfree> all other IO is supperficial.
12:31:39 <csci> ah, ok
12:32:22 * syntaxfree goes whine about something in #haskell-blah
12:33:53 <shapr> I wonder when we'll see -fnottingham-exts
12:34:09 <syntaxfree> haha.
12:34:11 <syntaxfree> what would those be?
12:34:53 <glguy> > let pairs xs = [(a,b) | (a:as) <- tails xs, b <- as] in pairs [1..4]
12:34:54 <lambdabot>  [(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
12:35:03 <glguy> kowey: is that what you were doing?
12:36:16 <dr_strangelove> Is there a simple tutorial or example explaining how one can have a global program state? (I suppose I need state monads, but don't grasp it so far)
12:36:34 <kowey> glguy: yes, i think it is...
12:36:36 <kowey> how tempting!
12:36:43 <hpaste>  glguy annotated "not pretty enough..." with "my version" at http://hpaste.ath.cx:8000/34#5
12:36:49 <chessguy> dr_strangelove, you could look at dons' bot tutorial
12:37:34 <kowey> yes, i think i _will_ go with it... it doesn't seem any harder to understand than the (previous) winner; thanks!
12:37:48 <chessguy> http://www.haskell.org/haskellwiki/Roll_your_own_IRC_bot
12:37:50 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
12:37:57 <glguy> > filterM (\_->[False ..]) [1..3]
12:37:57 <dr_strangelove> chessguy, thanks
12:37:59 <lambdabot>  [[],[3],[2],[2,3],[1],[1,3],[1,2],[1,2,3]]
12:38:02 <glguy> kowey: ^^
12:38:13 <chessguy> that's a relatively simple example of threading the socket through the whole program
12:39:18 <uccus> I think -fnottingham-exts should be all those things proposed for Haskell' that the Glorious Haskell Compiler people thought 'too radical'
12:39:32 <dons> heh
12:39:52 <kowey> glguy: powerset... but... /me plays with ghci a bit
12:40:09 <glguy> kowey: right, I was just extending it
12:40:17 <uccus> dons: I'm not joking. things like http://haskell.org/haskellwiki/Class_system_extension_proposal
12:40:19 <lambdabot> Title: Class system extension proposal - HaskellWiki
12:41:12 <syntaxfree> boy, if they ever thought there are things considered too radical for Haskell''.
12:41:24 <syntaxfree> they = PHP programmers and suchlike.
12:42:00 <shapr> Someone once told me my collision detection didn't work. I told 'em they were getting on my NURBS.
12:45:16 <kowey> glguy: ahah! now i get it! thanks for the koan
12:45:27 <glguy> koan?
12:46:31 <kowey> you know, one of those zen riddles, like 'what is the sound of one hand clapping, etc' but with lambdas
12:50:02 <syntaxfree> which koan?
12:50:18 <syntaxfree> shapr: may I?
12:50:28 <kowey> syntaxfree: filterM (\_->[False ..])
12:50:43 <kowey> i mean, maybe it's obvious to you...
12:51:17 <syntaxfree> @info Bool
12:51:17 <lambdabot> Bool
12:51:23 <syntaxfree> @instances Enum
12:51:24 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
12:51:29 <syntaxfree> uhh.
12:51:31 <syntaxfree> Bool?
12:52:04 <uccus> @instances Ord
12:52:06 <lambdabot> (), Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, [a]
12:52:14 <syntaxfree> > compare True False
12:52:15 <opqdonut> > [False ..]
12:52:16 <lambdabot>  GT
12:52:16 <lambdabot>  [False,True]
12:52:20 <uccus> Bool? an Ord? how odd is that?
12:52:24 <syntaxfree> > compare False False
12:52:25 <lambdabot>  EQ
12:52:48 <syntaxfree> what's the command for reverse @instance?
12:53:12 <chessguy> i don't think there is one
12:53:25 <uccus> @src Bool Ord
12:53:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
12:53:39 <opqdonut> > [() ..]
12:53:41 <lambdabot>  [()]
12:53:42 <opqdonut> :)
12:53:49 <hyrax42> ?. docs index Bool
12:53:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
12:54:27 <syntaxfree> how does the Ord implementation for Either a b work>
12:54:30 <syntaxfree> s/>/?
12:55:07 <uccus> how do I see the source of Ord instance of Bool?
12:55:16 <uccus> [using @src...]
12:55:39 <hyrax42> ?help .
12:55:40 <lambdabot> . <cmd1> <cmd2> [args].
12:55:40 <lambdabot> . [or compose] is the composition of two plugins
12:55:40 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
12:56:35 <syntaxfree> @index Bool
12:56:35 <lambdabot> Data.Bool, Prelude
12:56:52 <uccus> @src Bool compare
12:56:52 <lambdabot> Source not found. I feel much better now.
12:57:04 <hyrax42> ?fptools Data.Bool
12:57:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Bool.hs
12:57:12 <shapr> syntaxfree: may you what?
12:57:27 <syntaxfree> @get-shapr
12:57:28 <lambdabot> shapr!!
12:57:31 <syntaxfree> that. :)
12:57:31 <shapr> WHAT?
12:57:34 <shapr> aiee
12:57:37 * shapr grins
12:58:03 <dylan> hmm
12:58:03 <hyrax42> syntaxfree: I assume that Left _ < Right _
12:58:12 <dylan> how can one turn a Data.Sequence.Seq into a list?
12:58:21 <hyrax42> > compare (Left 10) (Right 'z')
12:58:21 <uccus> but I want the source!
12:58:23 <lambdabot>  LT
12:58:24 <syntaxfree> > compare (Left 2) (Right 1)
12:58:25 <lambdabot>  LT
12:58:38 <syntaxfree> hmm.
12:58:40 <dons> ?src Ord (<)
12:58:41 <lambdabot> Source not found. stty: unknown mode: doofus
12:58:47 <syntaxfree> Yes, It's Either a b, not Either a a
12:58:48 <uccus> @src [] (>>=)
12:58:49 <lambdabot> m >>= k     = foldr ((++) . k) [] m
12:58:51 <chessguy> haha
12:58:56 * shapr grins
12:59:07 <uccus> this worked, so why wouldn't @src Bool compare?
12:59:11 <dons> ?src Ord
12:59:12 <lambdabot> class  (Eq a) => Ord a  where
12:59:12 <lambdabot>     compare      :: a -> a -> Ordering
12:59:12 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:59:12 <lambdabot>     max, min         :: a -> a -> a
12:59:15 <dons> ?src Bool
12:59:16 <lambdabot> data Bool = False | True deriving (Eq, Ord)
12:59:17 <dylan> @hoogle Data.Sequence.Seq a -> [a]
12:59:19 <lambdabot> No matches, try a more general search
12:59:31 <syntaxfree> ?src Enum
12:59:32 <lambdabot> class  Enum a   where
12:59:32 <lambdabot>     succ                     :: a -> a
12:59:32 <lambdabot>     pred                     :: a -> a
12:59:32 <lambdabot>     toEnum                   :: Int -> a
12:59:32 <lambdabot>     fromEnum                 :: a -> Int
12:59:34 <lambdabot> [3 @more lines]
12:59:44 <syntaxfree> oh. fromEnum is cool.
12:59:50 <syntaxfree> > fromEnum False
12:59:52 <lambdabot>  0
12:59:57 <syntaxfree> @more
13:00:04 <dons> very usefu
13:00:10 <syntaxfree> BAH. THAT HAS TO BE FIXED :(
13:00:15 <syntaxfree> ?src Enum
13:00:16 <lambdabot> class  Enum a   where
13:00:16 <lambdabot>     succ                     :: a -> a
13:00:16 <lambdabot>     pred                     :: a -> a
13:00:16 <lambdabot>     toEnum                   :: Int -> a
13:00:16 <lambdabot>     fromEnum                 :: a -> Int
13:00:18 <syntaxfree> @more
13:00:18 <lambdabot> [3 @more lines]
13:00:20 <lambdabot>     enumFrom                 :: a -> [a]
13:00:24 <lambdabot>     enumFromThen, enumFromTo :: a -> a -> [a]
13:00:28 <lambdabot>     enumFromThenTo           :: a -> a -> a -> [a]
13:00:28 <chessguy> lol
13:00:41 <syntaxfree> hmm. there's no concept of Zero though.
13:00:47 <syntaxfree> or Center.
13:01:06 <apfelmus> dylan: mmh, you'd have to use viewl
13:01:06 <syntaxfree> my trivial implementation of Enum would require only zero and succ.
13:01:50 <syntaxfree> (and pred)
13:02:06 <syntaxfree> @instances Enum
13:02:07 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
13:02:14 <syntaxfree> > fromEnum 2.5
13:02:16 <lambdabot>  2
13:02:33 <bos31337> @seen bringert
13:02:33 <lambdabot> I saw bringert leaving #haskell 1d 3h 42m 47s ago, and .
13:03:17 <bos31337> ghc's package system doesn't allow multiple versions of the same package to be installed, right?
13:03:55 <bos31337> or more to the point, it allows it, but seems to behave very strangely.
13:04:20 <apfelmus> dylan: ah, i knew it. the following works for Seq, too
13:04:20 <apfelmus> ?type Data.Foldable.toList
13:04:22 <lambdabot> Couldn't find qualified module.
13:04:37 <apfelmus> ?src Data.Foldable
13:04:38 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
13:04:50 <apfelmus> MARLEY
13:04:57 <apfelmus> ?src Data.Foldable
13:04:57 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
13:05:32 <dons> bos31337: it does, but only one can be visible without qualification
13:05:54 <dons> so you can happily install fp-0.1 through to fps-0.8
13:05:56 <dylan> apfelmus: well, let toList s = case viewl s of x :< s -> x : toList s; EmptyL -> [] is easy enough
13:06:14 <apfelmus> dylan: sure. but toList is easier :)
13:06:26 <dylan> isn't Foldable marked 'deprecated'?
13:06:30 <bos31337> dons: so i have to use import qualified, or an explicit -package?
13:06:36 <dons> explicit -package
13:06:41 <dons> -package fp-0.2
13:06:43 <bos31337> ok, thanks.
13:06:43 <dons> or so
13:07:05 <xerox> hiya dons, duncan told me you two were going to be nearby Italy in these first day of the year, is it going to happen soon?
13:07:20 <apfelmus> dylan: no. the predecessor to Foldable is deprecated, but i forgot its name
13:07:47 <bos31337> dons: is there a way to pass that -package in via cabal's Setup.hs?
13:09:08 <bos31337> (my motivation: i am trying to build haxr, and it requires haxml 1.13. i built haxml from darcs first, and it's incompatible with 1.13's api.)
13:14:47 <chessguy> i just had a really random thought. why aren't the monad laws enforce-able at the language level?
13:15:35 <therp> chessguy:  that would require theorem proving in a turing complete environment.
13:15:48 <bos31337> chessguy: that would require solving the halting problem.
13:15:57 <chessguy> hmm, good reason
13:15:58 <Botje> chessguy: because disproving them only needs one good value
13:15:59 <dons> bos31337: yeah, build-depends fps-0.123
13:16:06 <dons> explicitly state the version (I think that should work)
13:16:14 <Botje> whereas proving takes some more :)
13:16:34 <dons> chessguy: well, they could be given a strong enough type system
13:16:34 <apfelmus> chessguy: but dependent types can be used so that the compiler merely checks the programmer's proof
13:16:37 <dons> epigram...
13:16:49 <huschi> is there a function with a signature like "(a -> Bool) -> a -> Maybe a" or "Bool -> a -> Maybe a" which return Just a if the condition holds and Nothing otherwise in any of the libs?
13:17:00 <dons> ?hoogle (a -> Bool) -> a -> Maybe a
13:17:01 <lambdabot> No matches, try a more general search
13:17:17 <huschi> dons: i've already tried.
13:17:33 <dons> let f p x | p x = Just a | otherwise = Nothing
13:17:34 <chessguy> sounds trivial to right
13:17:57 <chessguy> @src if
13:17:58 <lambdabot> Source not found. Where did you learn to type?
13:18:13 <apfelmus> @pl \x y -> if x then Nothing else Just y
13:18:13 <lambdabot> (. Just) . flip if' Nothing
13:18:16 <chessguy> lambdabot: bight me
13:18:19 <huschi> but it's common pattern i think.
13:18:23 <chessguy> er, bite
13:18:36 <dons> huschi: yeah, it is
13:18:37 <dons> hmm
13:18:43 <huschi> and doing something like "if p x then Just x else Nothing" looks very ugly to mee.
13:18:44 <apfelmus> @pl \x y -> if x then Just y else Nothing
13:18:45 <lambdabot> flip flip Nothing . (. Just) . if'
13:18:50 <apfelmus> @type when
13:18:52 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
13:18:52 <chessguy> @src if'
13:18:53 <lambdabot> Source not found. Take a stress pill and think things over.
13:19:11 <dr_strangelove> how can I use Maybe in ghci? I get      "module `Data.Maybe' is a package module"    when typing    ":load Data.Maybe"
13:19:13 <dons> huschi: yeah, so define test p x = if p x then Just x else Nothing
13:19:13 <chessguy> flip flip?
13:19:23 <dons> :m + Data.Maybe
13:19:25 <apfelmus> dr_strangelove: :m +Data.Maybe
13:19:25 <dons> dr_strangelove: ^^
13:19:43 <dons> maybe something like test p x = if p x then Just x else Nothing
13:19:46 <dons> should go in Data.Maybe
13:19:58 <huschi> dons: i think so too.
13:20:04 <dons> needs a good name though
13:20:05 <huschi> why isn't it already there.
13:20:20 <dons> no one needed it enough to commit a patch
13:20:26 <chessguy> dons, someone pointed out today that a central repository for libraries and such is way overdue. is something like this in the works?
13:20:36 <dons> chessguy: yes. hackage
13:20:39 <dons> its beta level now
13:20:45 <dons> we have been up and downloading stuff at the hackathon to it
13:20:47 <chessguy> ?where hackage
13:20:48 <lambdabot> http://hackage.haskell.org/trac/hackage
13:20:56 <bos31337> hackage is the equivalent of CPAN.
13:21:08 <chessguy> ah, nice
13:21:30 <chessguy> are all the standard libraries and everything going to go there?
13:21:33 <Igloo> dons: I think I called that justWhen, and also had justUnless
13:21:38 <apfelmus> huschi: f p x = fmap (const x) $ guard p
13:21:43 <bos31337> as people contribute them.
13:21:45 <dons> Igloo: hmm
13:21:52 <dons> apfelmus: hehe :)
13:22:08 <apfelmus> f p x = guard p >> return x
13:22:09 <chessguy> and i hope there'll be darcs access too
13:22:16 <dons> ?pl f p x = guard p >> return x
13:22:17 <lambdabot> f = (. return) . (>>) . guard
13:22:19 <dons> :t f p x = guard p >> return x
13:22:21 <lambdabot> parse error on input `='
13:22:27 <dons> :t \p x -> guard p >> return x
13:22:29 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => Bool -> a -> m a
13:22:33 <huschi> apfelmus: guard p >> return x looks better.
13:22:40 <apfelmus> it's even more general :)
13:22:48 <Igloo> At least, I think that's the definition I had. It was so I could write unfoldr's in point-free style nicely
13:22:52 <dons> though its no longer (a -> Bool) -> a ?
13:23:15 <dons> :t \p x -> guard (p x) >> return x
13:23:16 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => (a -> Bool) -> a -> m a
13:23:24 <dons> there we go
13:23:34 <dons> ok, that's genuinely useful
13:23:43 <dons> Igloo: ah good idea!
13:24:03 <dons> ?pl \x -> guard (p x) >> return x
13:24:03 <lambdabot> ap ((>>) . guard . p) return
13:24:12 <dons> ?users
13:24:13 <lambdabot> Maximum users seen in #haskell: 321, currently: 316 (98.4%), active: 46 (14.6%)
13:24:16 <huschi> and whats a good name for this function?
13:24:17 <dons> hey!
13:24:21 <dons> new record for this channel
13:24:29 * chessguy cheers
13:24:41 * chessguy gives lambdabot on the back a clout round the head with a fresh copy of HydraIRC
13:24:43 <dons> huschi: so, guard*something?
13:24:48 <huschi> a question to the native english speaker i think.
13:24:49 <dons> since its a guard and a return
13:25:11 <apfelmus> didn't Igloo propose justWhen?
13:25:14 <dons> apfelmus: any suggestions for a nice name for this function?
13:25:19 <Anon4888> What windows IRC client should I use when MIRC dies?
13:25:21 <dons> yeah, but then you lift it into arbitrary monads
13:25:35 <dons> so just doesn't make sense for \p x -> guard (p x) >> return x
13:25:43 <dons> liftWhen ?
13:25:56 <apfelmus> returnWhen ?
13:26:05 <apfelmus> returnIf ?
13:26:07 <dons> though that seems a bit unintuitive
13:26:12 <dons> (i.e. that it might not return .. ;)
13:26:13 <apfelmus> rif ?
13:26:24 <huschi> rif looks like nub.
13:26:35 <apfelmus> yup
13:26:43 <Igloo> You want When rather than If so that the Unless variant is consistent
13:26:58 <Igloo> Or to not have the Unless variant, I guess
13:28:00 * Igloo would quite like a justWhen/justUnless even if there is a more general version, though, unless you find a truly fantastic name for the more general one
13:28:12 <huschi> will anybody send a patch to get this into Control.Monad or Data.Maybe.
13:28:29 <huschi> ?
13:28:41 <dons> huschi: i'm thinking about it.
13:28:52 <dons> the best way to start would be to query the libraries@haskell.org mailing list
13:28:53 <huschi> it was thought as a questing :)
13:29:03 <dons> asking for suggested names for the Maybe and Monad versions
13:29:09 <dons> particularly the latter
13:29:15 <chessguy> hmmm. i never new such a list existed
13:29:22 <dons> then if we get a good name, it gets submitted via the libraries submission process
13:29:25 <dons> and then comitted
13:29:56 <dons> the process is described here ,http://haskell.org/haskellwiki/Library_submissions
13:29:57 <lambdabot> Title: Library submissions - HaskellWiki
13:29:58 <huschi> dons: are you a native english speaker? then i would ask you to do this.
13:30:04 <dons> ok.
13:30:08 <huschi> thx.
13:30:08 <dons> i'll send out a mail today
13:30:23 <dons> for justWhen justUnless, and the lifted version
13:30:40 <chessguy> how active is libraries@ ?
13:30:47 <dons> huschi: can you /msg me your email, so I can cc you?
13:30:51 <dons> chessguy: fairly
13:30:54 <dons> sometimes very
13:31:03 <chessguy> more so than -cafe?
13:31:07 <huschi> yes. it's huschi@gmx.org
13:31:15 <dons> cheers
13:31:18 <dons> chessguy: nope
13:31:28 <dons> it really just the library geeks who hang out there
13:31:30 <chessguy> oooh, free email address. /me adds it to his spamtastic list
13:31:32 <dons> pondering names for things
13:31:37 <csci> does haskell have some kind of serialization like YAML for Ruby?
13:31:43 <chessguy> sounds like fun
13:31:49 <dons> Igloo: can I start committing untabing patches to base?
13:31:53 * chessguy always jumps at opportunities to increase his geekiness
13:32:00 <dons> since everytime i open up a file in base now, i feel icky
13:32:17 <huschi> chessguy: you meant me with the free email-address?
13:32:32 <chessguy> huschi, yes, just kidding
13:32:38 <Igloo> dons: I'm starting to collect images of bad tabs in the sources when I start to see them - only http://urchin.earth.li/~ian/tabs1.png so far (tabs in yellow)
13:33:22 <Igloo> dons: You'll get no argument from me if you go ahead and commit them
13:33:24 <dons> Igloo: you have something like:
13:33:26 <dons> syn match tabNasty display "\t"
13:33:26 <dons> hi link tabNasty Todo
13:33:26 <dons> syn match endspaceNasty display " *$"
13:33:26 <dons> hi link endspaceNasty Todo
13:33:30 <dons> ah yes
13:33:40 <dons> ok, then i might just do this.
13:34:10 <Igloo> Nah, I just search for tab and highlight search when I realise they're being inconsistently used
13:34:24 <dons> oh, i have it on by default :)
13:34:27 <Igloo> It may or may not be worth trying to get a concensus on the lists first
13:34:35 <dons> and the result is it looks like your .png all the time :)
13:34:45 <dons> yeah
13:34:50 <dons> ?users
13:34:50 <lambdabot> Maximum users seen in #haskell: 321, currently: 317 (98.8%), active: 46 (14.5%)
13:35:12 <Igloo> If so, searching for things like the above example and giving numbers on how many files use mostly tabs and how many mostly spaces might be useful
13:35:29 <dons> right
13:35:36 <Igloo> It's up to you   :-)
13:36:02 <dons> mm. the channel average in here is no 276
13:36:07 <dons> /now/
13:39:26 --- mode: ChanServ set +o dons
13:39:33 --- topic: set to 'putStr . unlines $ ["The Haskell programming language: Get yourself some cognitive dissonance!","http://haskell.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
13:39:48 --- mode: ChanServ set -o dons
13:41:26 <apfelmus> protest! i'd rather not have an impure subject!
13:41:52 <dons> hmm. good point..
13:42:17 --- mode: ChanServ set +o dons
13:42:38 --- topic: set to 'unlines ["The Haskell programming language: Get yourself some cognitive dissonance!","http://haskell.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
13:42:42 --- mode: ChanServ set -o dons
13:43:49 <huschi> dons: if you are suggesting the liftWhen function that shall go to Control.Monad maybe it's a good time to suggest a function with signature Monad m => m a -> m () as (>> return ()), too.
13:43:51 <resiak> Wasn't the point of the topic being a list that lambdabot can munge it?
13:43:51 <kolmodin> dons: bought some marmite... it tasts ... weird
13:44:00 <kolmodin> dcoutts: there?
13:44:31 <dons> kolmodin: marmite! ewww...
13:44:35 <kolmodin> hah :)
13:44:46 <dons> resiak: it used to be year
13:44:50 <dons> yeah. in read/show format
13:44:54 <dons> but we sort of don't bother now
13:45:03 <bos31337> kolmodin: the true marmite is vegemite.
13:45:03 <kolmodin> they didn't have the vegemite in stock currently
13:45:08 <bos31337> ah, ok :-)
13:45:09 <dons> :(
13:45:15 <resiak> Yeah, it always seemed a bit pointless
13:45:16 <kolmodin> I'll have to go back :)
13:45:16 <dons> this is a terrible affrontery
13:45:19 <kolmodin> another day
13:45:26 <dons> yeah!
13:45:32 <dons> so you had it on toast?
13:45:35 <resiak> I used to wish that you could use things like (\\) on the topic, but then just used /topic and left it at that
13:45:48 <kolmodin> dons: yeah, might have taken too much though :) very strong tast
13:45:50 <kolmodin> e
13:45:57 <dons> hehe
13:46:06 <kolmodin> dcoutts, dons: started to write a @unmtl, tests look good
13:46:12 <kolmodin> but the parsing is a big hack :)
13:46:12 <dons> oh, very good
13:46:15 <bos31337> the correct thickness of vegemite on toast or bread is 1 micron.
13:46:19 <dons> can you use Language.Haskell?
13:46:22 <dons> bos31337: right!
13:46:28 <dons> well, 1-3 microns
13:46:28 <kolmodin> dons: hmm, didn't think of that
13:46:30 <Igloo> You could change it to (\xs -> unlines xs) ["...   if you wanted it to be less pointless
13:46:43 <resiak> joke.popey.com etc.
13:46:48 <kolmodin> dons: I use parsec and whipped up some quick thing
13:46:50 <dons> is there some more fun munging of the string, we could do?
13:47:08 <dons> kolmodin: so does every haskell plugins ;)  we realy should jsut use Language.Haskell
13:47:18 <kolmodin> hah :)
13:47:43 <kolmodin> I'm not going to release it and put my name on it if it's too hackish :)
13:48:04 <kolmodin> I don't release code I can't show to my mother and be proud about it :D
13:48:17 <dons> heh
13:48:33 <chessguy> ?remember kolmodin I don't release code I can't show to my mother and be proud about it :D
13:48:34 <lambdabot> Done memoising quote for `kolmodin', if that is their real name...
13:48:43 <kolmodin> hah :)
13:49:05 <chessguy> you gotta watch what you say around here :)
13:49:07 <kolmodin> I bet the next hwn will have quite a few nice quotes :)
13:49:13 <kolmodin> chessguy: yeah, didn't think of that :)
13:49:37 <chessguy> @quote kolmodin
13:49:38 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
13:49:49 <chessguy> that's a good one too :)
13:50:01 <kolmodin> :)
13:50:10 <kolmodin> I think there is more.. :)
13:50:14 <chessguy> @quote kolmodin
13:50:14 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
13:50:16 <chessguy> @quote kolmodin
13:50:16 <lambdabot> kolmodin says: I don't release code I can't show to my mother and be proud about it :D
13:50:18 <chessguy> @quote kolmodin
13:50:18 <lambdabot> kolmodin says: I would rather lose my left arm than write it in Java
13:50:19 <chessguy> @quote kolmodin
13:50:20 <lambdabot> kolmodin says: I don't release code I can't show to my mother and be proud about it :D
13:50:21 <chessguy> @quote kolmodin
13:50:21 <lambdabot> kolmodin says: I don't release code I can't show to my mother and be proud about it :D
13:50:26 <dons> reminds me, we need a HWN issue!
13:50:36 <dons> a big POPL/PADL/DAMP/TLDI issue
13:50:42 * dons writes and hacks
13:50:43 <kolmodin> ?tell dons we need a HWN issue
13:50:43 <lambdabot> Consider it noted.
13:51:02 <kolmodin> what? :)
13:51:07 <kolmodin> don't give me that look
13:51:13 <chessguy> yeah, it's not-so-weekly these days
13:51:17 <dons> hey
13:51:17 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
13:51:23 <dons> it missed *1* week in the lsat 5 months I think
13:51:28 <dons> oh, and xmas
13:51:30 <glguy> anyone know how to use setCookie with HAppS 0.9?
13:51:30 <chessguy> oh really?
13:51:40 <chessguy> hmmm, i don't think i've been getting it
13:51:46 <chessguy> does it go out on -cafe?
13:51:54 <bos31337> chessguy: yes
13:51:59 <chessguy> weird
13:52:03 <bos31337> also programming.reddit.com, and sequence.complete.org
13:52:22 <chessguy> my apologies then dons.
13:52:28 <dons> $ ls 20061*.txt
13:52:28 <dons> 20061003.txt  20061019.txt  20061031.txt  20061114.txt  20061128.txt  20061212.txt
13:52:32 <dons> 20061010.txt  20061024.txt  20061108.txt  20061122.txt  20061205.txt  20061220.txt
13:52:59 <dons> $ ls 2007*.txt
13:53:00 <dons> 20070102.txt  20070109.txt
13:53:09 <apfelmus> for those who complain: due to lazy evaluation, 'weekly' means amortized intervals. it's not the haskell weekly SEQuence, after all.
13:53:16 <dons> :)
13:53:16 <bos31337> dons: i thought simonpj's view proposal was quite timely, considering your plans for bitstream parsing with Data.Binary :-)
13:53:22 <dons> yeah
13:53:31 <chessguy> hmm, so the 9th was the most recent
13:53:31 <dons> we talked with SPJ about this very thing in Nice
13:53:36 <dons> ches	right
13:53:39 <bos31337> no wonder it was so timely.
13:53:40 <dons> since on the 16th I was in Nice
13:53:53 <dons> and now on the 23rd I'm back home writing an issue ! :)
13:53:54 <kolmodin> 9th was the start day of hac07
13:53:58 <Axioplase> dons: POPL ?
13:54:04 <bos31337> need to get a haskell hacking job. this business of paying the bills is getting in the way.
13:54:12 <dons> Axioplase: yeah? the POPL conference
13:54:13 <kolmodin> and dons just got back home from europe
13:54:28 <kolmodin> so I think the lack of issues is ok ;)
13:54:45 <dons> hmm, so much has happened in the last 2 weeks
13:54:47 <chessguy> so it comes out on tuesdays? i have to figure out why i'm not getting it :(
13:54:51 <dons> the hackathon story has to go in too
13:54:55 <dons> chessguy: you on -cafe?
13:54:58 <chessguy> yes
13:55:17 <kolmodin> we should write a mini article "A tale of a Binary library"
13:55:49 <kolmodin> it was quite fast development, from the hac and from irc users
13:55:53 <dons> yeah
13:56:00 <dons> and the intergrated QC dev cycle
13:56:10 <dons> along with the benchmarking cyle, make it quite interesting
13:56:15 <dons> this is how fps developed as ewll
13:56:23 <kolmodin> coll
13:56:27 <kolmodin> err, cool
13:56:45 <dons> dcoutts and I talked about writing up a 'best practice library dev' guide along with the binary release
13:56:49 <dons> if we can get it out this week
13:56:56 <dons> which means, if we can get the Get monad tuned
13:57:20 <kolmodin> yeah, I think dcoutts had started, otherwise I'd done some yesterday
13:57:34 <dons> yeah, he'll be busy this week though
13:57:46 <dons> he has to show simon how to fuse concatMap by Friday
13:57:54 <dons> using streams.
13:58:34 <dons> fun times in lambda land!
13:58:49 <kolmodin> cool
13:59:10 <kolmodin> can we expect a significant speedup if this gets integrated into ghc somehow
13:59:19 <kolmodin> ?
13:59:33 <dons> hmm. well, that's the other thing. Simon also wants to see the core 2 core layer of binary
13:59:40 <bos31337> core 2 core?
13:59:43 <dons> since that should help tune the code generator for these fast loops
13:59:53 <dons> bos31337: the intermediate transforms on the Core language, ghc uses
13:59:58 <kolmodin> dons: yeah, I talked to dcoutts about that
13:59:58 <bos31337> oh, ok.
14:00:09 <dons> since you know, 150M/s is just not fast enough
14:00:14 <kolmodin> hah :)
14:00:14 <bos31337> it's true :-)
14:00:32 <dons> (simon also said he never thought we'd reach the point where things like branch prediction and memcpy speeds would matter...)
14:00:38 <pejo> dons, why is Friday magic for the fusion?
14:00:41 <kolmodin> well, dcoutts wrote the exact same app in haskell and in C, and the C program is still many times faster
14:00:56 <bos31337> sure, the C version should be about 30 times faster.
14:01:03 <dons> pejo: oh, on Friday dcoutts , rl and simon will all be in cambridge
14:01:19 <dons> bos31337: well, its about 3x faster so at the moment
14:01:21 <dons> but we should be able to do better, if ghc is willing
14:01:29 <kolmodin> bos31337: this is without lazyness, lists or anything. C compiles it down to 4 asm instructions, and so should ghc
14:01:47 <bos31337> that would be excellent.
14:01:50 <kolmodin> the tight loop, that is
14:01:52 <dons> yeah, we do wellm but there's about 3x as many instructions in the inner loop
14:02:25 <kolmodin> apparently the stm code was perfect, but something went "wrong" after that
14:02:40 <dons> the final core code is perfect, yeah
14:02:56 <kolmodin> stm, stg..
14:02:58 <kolmodin> heh :)
14:03:00 <dons> it unrolls the monad/monoid layer down to straight line imperative writes into memory
14:03:05 <dons> which is kind of amazing
14:03:22 <dons> but then that code turns into 12 asm instructions, instead of 4
14:03:43 <kolmodin> yeah, really cool
14:03:44 <dons> luckily, rl and simon know how to fix it.
14:03:54 <kolmodin> rl?
14:04:08 <dylan> is there a way to wait until a TVar is modified?
14:04:08 <dons> it helps having a program to show though, that actually exhibits the behaviour we want to improve
14:04:17 <dons> roman leschinskiy, our stream fusion co author
14:04:22 <kolmodin> oh, right
14:04:33 <bd_> dylan: atomically $ v <- readTVar v; guard (v /= oldValue) ?
14:04:46 <dylan> without doing that. :P
14:04:59 <dons> ?. pl undo do v <- readTVar v; guard (v /= oldValue)
14:04:59 <lambdabot> guard . (oldValue /=) =<< readTVar v
14:05:18 <dons> ?paste
14:05:18 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
14:05:19 <bd_> dylan: You have to do that :)
14:05:25 <dons> glguy: is that the wrong url? ^^
14:05:30 <pejo> dons, the asm instruction count - is that for ncg?
14:05:34 <bd_> dylan: You'll never observe it changing within a single atomically of course
14:05:40 <glguy> dons: that url works
14:05:42 <dons> pejo: yeah, though gcc does about the same
14:05:46 <bd_> dylan: so you need to read it once, then retry until it changes
14:05:46 <dylan> oh, wait a second. the guard is of the STM variety. I thought you were looping in IO.
14:05:48 <glguy> dons: http://hpaste.ath.cx:8000 is an alias
14:05:52 <bd_> dylan: no :)
14:05:53 <dons> glguy: hmm, but maybe i have a patch from sorear for this anyway
14:05:56 <bd_> mzero = retry, right?
14:05:59 <glguy> dons: likely
14:05:59 <dons> glguy: so hpaste is the preferred url?
14:06:07 <dons> glguy: why do we need the 8000 port?
14:06:08 <kolmodin> good night!
14:06:15 <dons> could it just be hpaste.ath.cx ?
14:06:17 <glguy> dons: hopefully shapr will have the 8000 fixed today?
14:06:21 <dons> ah ok
14:06:27 <dons> night kolmodin !
14:06:28 <glguy> dons: he would need to set up virtual hosts on his apache
14:06:34 <dons> ah
14:06:38 <glguy> dons: this is all possible, and he likes the idea, so it is a matter of time
14:06:41 <dons> ok
14:06:52 <dons> glguy: you should announce hpaste on haskell-cafe or haskell@
14:06:57 <dons> since its a cool new app :)
14:07:08 <glguy> dons: heh, let me finish the conversion to HAppS 0.9 first
14:07:11 <dons> glguy: also, how about putting the darcs repo url on the hpaste page somewhere
14:07:12 <glguy> almost there
14:07:20 <glguy> dons: way ahead of you
14:07:24 <dons> i.e. 'about' -- a link to the source ;)
14:07:24 <glguy> dons: it is on the page
14:07:49 <dons> can I darcs get the pastes?
14:08:00 <glguy> dons: you can darcs get the source
14:08:05 <dons> mm. i'd actually like a darcs push/ darcs pull mechanism to paste..
14:08:15 <dons> so then I wouldn't need to fire up my browswer
14:08:28 <glguy> dons: everyone would need an account to push
14:08:41 <dons> (i also wish I could do that for haskell.org's wiki)
14:08:44 <pejo> dons, so the problem lies before ncg/gcc?
14:08:53 <pejo> dons, (sorry about the late replies).
14:09:02 <dons> glguy: well, i'm thinking you could use daan's darcs-cgi interface
14:09:08 <glguy> dons: OH
14:09:09 <dons> which authenticates, and then darcs pushes
14:09:40 <chessguy> glguy, just when you think it's done, it's time to get back to work :)
14:09:44 <dons> so there's two things i'm dreaming about here: a) a darcs pull interface to pull all the src
14:09:50 <dons> all the pastes, I mean
14:10:01 <dons> and then a darcs push mechanmism for putting up a new paste
14:10:04 <chessguy> dons, will there be darcs access to hackage?
14:10:18 <dons> so then i could never leave the safety of ghc/vim/darcs for sending code to people in this channel :)
14:10:36 <bos31337> glguy: i just registered hpaste.org. let me know if you want me to point it somewhere.
14:10:38 <dons> chessguy: hmm? to the hosted repos?
14:10:43 <dons> bos31337: cheers!
14:10:55 <chessguy> to the hosted code, yes
14:11:05 <glguy> bos31337: awesome
14:11:13 <dons> i'd imagine so.
14:11:15 <pejo> dons, heh, writing your thesis in vim too?
14:11:20 <dons> of course!
14:11:24 <chessguy> lol
14:11:24 <dons> well, it was yi
14:11:28 <glguy> bos31337: point it at 65.254.53.221
14:11:33 <dons> but i never added enough syntax highlighting... :)
14:12:00 <bos31337> glguy: i can host, if you need space, too.
14:12:03 * dons gets the hpaste src
14:12:15 <bos31337> glguy: i'll let you know when i have the dns stuff set up.
14:12:26 <glguy> bos31337: actually, you could CNAME it to kakapo.scannedinavian.com
14:12:34 <bos31337> k
14:12:40 <glguy> bos31337: yeah, let me know, this is starting to get pretty sweet
14:12:46 <bos31337> it will take a few hours for the registrar to pull their thumbs out.
14:12:53 <glguy> of course ;)
14:13:26 <dons> great work guys
14:13:27 <bos31337> hey, if i'm not up to speed enough with haskell to contribute code yet, i can at least contribute $9 :-)
14:13:33 <dons> hehe
14:13:38 <dons> yay!
14:14:02 <dons> well, for those who don't know, bos already contributed some code...
14:14:18 <dons> $ grep Bryan fps/Data/*
14:14:18 <dons> fps/Data/ByteString.hs:-- Original GHC implementation by Bryan O\'Sullivan.
14:14:28 <dons> ;)
14:14:35 <sjanssen> oh!
14:14:39 * sjanssen had no idea
14:14:41 <dons> at least $9 worth
14:14:43 <bos31337> now the state of the art has gone a decade past me, and i'm rushing in 8 different directions to keep up :-)
14:15:04 <dons> its good to know we've invented some new techniques since 1994 though.
14:15:18 <psnl> @karm+ bos31337
14:15:18 <lambdabot> Maybe you meant: karma karma+
14:15:20 <dons> the fps src is old fashioned now, anyway. no bang patterns!
14:15:21 <psnl> @karma+ bos31337
14:15:22 <lambdabot> bos31337's karma raised to 1.
14:15:28 <bos31337> import qualified CategoryTheory as Aiiieeee
14:15:48 <dons> and it probably should be a Builder monoid in a lot of places
14:16:16 <pejo> bos, "Problems worthy of attack prove their worth by fighting back"
14:16:24 <bos31337> comparing PackedString to Data.ByteString is like toy paper boats vs the Millennium Falcon
14:16:48 <dons> well, i guess the Millennium Falcon was held together with glue and strictness
14:17:05 <bos31337> that sounds more like a description of an english boarding school.
14:17:20 <dons> heh
14:17:22 <pejo> (And the first implementation should definitely not be taken for granted, personally I rather make some tweaks to something existing rather than do it all from scratch).
14:17:45 <dons> I think we couldn't actually write this before the FFI,
14:17:46 <dons> foldl f v (PS x s l) = inlinePerformIO $ withForeignPtr x $ \ptr ->
14:17:46 <dons>         lgo v (ptr `plusPtr` s) (ptr `plusPtr` (s+l))
14:17:46 <dons>     where
14:17:46 <dons>         STRICT3(lgo)
14:17:49 <dons>         lgo z p q | p == q    = return z
14:17:51 <dons>                   | otherwise = do c <- peek p
14:17:54 * sjanssen wonders whether Data.ByteString has done the Kessel Run in less than 12 parsecs
14:17:54 <dons>                                    lgo (f z c) (p `plusPtr` 1) q
14:18:05 <dons> bos31337: so not surprising that the advent of the FFI changed the bytestring lib a lot
14:18:18 <dons> since its a more flexible interface to raw memory than we used to have
14:18:24 <dons> (i.e. more flexible by far than ST)
14:18:55 <dons> and rewrite rules didn't exist in '94 either
14:19:20 <SamB> I thought the millenium falcon was held together with chewing gum and ... whatever they call duct tape in Star Wars...
14:23:48 <bd_> @hoogle a -> a -> Bool
14:23:49 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
14:23:49 <lambdabot> Prelude.(<) :: Ord a => a -> a -> Bool
14:23:49 <lambdabot> Prelude.(<=) :: Ord a => a -> a -> Bool
14:27:22 <dons> ?where HAppS
14:27:22 <lambdabot> http://happs.org
14:27:32 <dons> glguy: where's the repo for happs we need?
14:27:41 <glguy> ?
14:27:52 <glguy> darcs get --partial http://happs.org/HAppS
14:28:01 <dons> ah ok
14:28:12 <dons> and we need hscolour 1.6 I presume, for hpaste?
14:28:18 <glguy> to build hpaste you need the latest hscolour, xhtml, and HAppS
14:28:21 <dons> right
14:28:28 <glguy> otherwise you won't have this weeks patches
14:28:35 <dons> ah ok
14:29:00 <glguy> hpaste runs on bleeding edge libraries ;)
14:29:14 <turol> i'm trying to use happy and get a strange error message:  "happy: parE"
14:29:21 <turol> which is not helpful at all
14:29:29 <turol> any ideas what might be wrong?
14:29:58 <bos31337> turol: don't use happy.
14:30:06 <bos31337> use Parsec instead. much nicer.
14:30:08 <dons> glguy, can I make the syntax highlighting prettier, more like: http://cgi.cse.unsw.edu.au/~dons/blog/2006/12/11#interpreters-with-reader-monads
14:30:09 <lambdabot> Title: Haskell hacking, http://tinyurl.com/y7wvnq
14:30:20 <dons> glguy: i.e. no using explicit bold , and using the hscolour css output?
14:30:38 <glguy> you are asking to change the css file?
14:30:42 <bos31337> dons: what do you use to present code in your blog?
14:30:53 <dons> hscolour :)
14:30:58 <bos31337> ah :-)
14:31:01 <dons> and i have a script that does the markup after i've written the article
14:31:20 <dons> glguy: ah ok maybe. i'm just hacking the hpaste src now
14:31:24 <bos31337> wordpress is driving me bananas. i'm about to write a literate haskell doodad with a little script, just like yours, no doubt.
14:31:28 <dons> (well, trying to get it to build with -Wall)
14:31:43 <dons> glguy: so if i submit a patch to change the css to look like the above like, would you accept it?
14:31:57 <glguy> dons: You'd have to add the CSS to the darcs repo first
14:32:04 <Igloo> turol: That looks like a happy bug; can you send a testcase for it to the list?
14:32:06 <dons> ok
14:32:11 <br1> what's GHC.Base.ZMZN ?
14:32:17 <dons> ()
14:32:26 <dons> Z-encoded left and right parens
14:32:52 <br1> and GHC.Base.Z0T ?
14:33:08 <dcoutts> dons, it's not that it's 12 asm instructions instead of 4, it's much worse than that
14:33:48 <dons> well, the stack checks and so on too ;)
14:33:52 <dcoutts> dons, I looked at it yesterday, it's two asm level procudures that call each other, and one calls the other indirectly!
14:34:01 <dons> br1: hmm, that's the 0 tuple
14:34:05 <dons> oh, my fault
14:34:07 <dons> ZMZN is []
14:34:11 <dons> and Z0T is ()
14:34:12 <dcoutts> dons, ie: jmp *(%esp)
14:34:17 <dons> mm
14:35:00 <dcoutts> dons, take a look as the .cmm produced for the byte copy loop in the MemBench.hs
14:35:03 <br1> @karma+ dons
14:35:04 <lambdabot> dons's karma raised to 115.
14:35:10 <dons> cheers
14:35:12 <dcoutts> you'll want to extract it out into a Loop.hs or something
14:35:21 <dcoutts> anyway, I'm off to bed
14:35:24 <dcoutts> g'night folks
14:36:03 <dons> ah ok
14:36:06 <dons> yes, night!
14:37:05 <glguy> UGH why is setCookieEx going into the IO monad
14:40:03 <Excedrin> could someone explain Oleg's latest email? "Even higher-order abstract syntax: typeclasses vs GADT"
14:41:00 <dons> it was an embedding of higher order abstract syntax into h98 + typeclasses, iirc
14:43:58 <turol> older happy works fine...
14:44:13 <turol> or at least gives a useful error message
14:44:16 <turol> where do i report it?
14:44:25 <svref> How do I redirect stderr to stdout from within a running Haskell program?
14:44:30 <dons> ?bug <-- turol
14:44:30 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:45:06 <dons> svref: hmm. hPutStr stderr ?
14:45:20 <dons> debug s = hPutStrLn stderr s
14:45:34 <dons> or I guess you can play games with dup2
14:45:42 <dons> but it wouldn't be portable
14:45:46 <dons> Igloo: any suggestions ^^
14:46:01 <svref> I want Debug.Trace.trace to go somewhere not /dev/null when I'm calling from a .cgi.
14:46:45 <svref> Maybe I could create a wrapper script...
14:47:05 <dons> right. , so that's a one liner
14:47:12 <dons> otherwise, define your own trace which writes to stdout
14:47:35 <svref> Isn't trace deep magic?
14:47:45 <dons> nah
14:48:03 <svref> how's it implemented then?
14:48:13 <chessguy> ?where Debug.Trace
14:48:13 <lambdabot> I know nothing about debug.trace.
14:48:20 <chessguy> @hoogle Debug.Trace
14:48:21 <lambdabot> No matches, try a more general search
14:48:25 <dons> import System.IO
14:48:26 <dons> import System.IO.Unsafe
14:48:26 <dons> mytrace :: String -> a -> a
14:48:26 <dons> mytrace string expr = unsafePerformIO $ do
14:48:26 <dons>     putStrLn stdout string
14:48:29 <dons>     return expr
14:48:29 <psnl> unsafePerformIO
14:49:17 <Igloo> dons: Can't think of anything that hasn't already been said
14:49:27 <svref> oO
14:49:42 <svref> Thanks.  Now I have enough rope!
14:49:46 <dons> its just runIO, nothing too scary
14:50:27 <dons> ;)
14:51:12 <bd_> ?src unsafePerformIO
14:51:13 <lambdabot> unsafePerformIO (IO m) = lazy (case m realWorld# of (# _, r #) -> r)
14:51:51 <bd_> as we can see here, unsafePerformIO constructs a new world and destroys it for the purpose of your debugging. Do you really want that on your conscience?
14:51:52 <dons> even the ugly stuff is clean in haskell!  ;)
14:52:07 <dons> hehe
14:52:21 <dons> ?remember bd as we can see here, unsafePerformIO constructs a new world and destroys it for the purpose of your debugging. Do you really want that on your conscience?
14:52:22 <lambdabot> Done memoising quote for `bd', if that is their real name...
14:52:26 <Igloo> It doesn't create a new world, it just keeps the old one around for a while
14:52:29 <chessguy> aww, dons beat me to it
14:52:43 <nornagon> needs more _ :(
14:52:45 <dons> Igloo: well, it makes a copy of the old world
14:52:52 <Igloo> So by using unsafePerformIO you're extending the life of the world!
14:52:53 <bd_> tsk, I be bd_ not bd :)
14:53:01 <dons> since presumably each realWorld# is actually a copy
14:53:17 <Igloo> dons: A copy in what sense? At runtime they don't exist to be copied
14:53:26 <bd_> dons: Once the world is copied, do the people in the copy not have as much right to live (and not be GC'd) as the originals?
14:53:34 <dons> no no, its a proper haskell value though, so its not a reference to any other realWorld# in use
14:53:37 <Igloo> And in Haskell they are immutable values
14:54:22 <dons> hmm, its a constant too, so i guess it could be said the real world always exists
14:54:35 <dons> and here we just bring the world into scope briefly
14:54:52 <dibblego> what's that story about the painter who gets further and further from the bucket?
14:54:57 <dibblego> or some keywords to find it
14:54:59 <Botje> dibblego: schlemiel
14:55:05 <dibblego> ah thanks
14:55:14 <Botje> joel (from .. on software) did an article on it some time ago
14:55:29 <Botje> speaking of which, I still have t oread his latest.
14:55:48 <dons> someone should write a metaphysical analysis of realWorld# and immutable worlds
14:56:10 <dons> that always exist somewhere ,but aren't always visible (or in scope)
14:56:17 <Botje> immutable worlds would be a key ingredient in predeterminism, I'd say
14:56:21 <dons> i'm sure there's some modal logic for describing this
14:57:12 * glguy goes home
15:00:56 <SamB> dons: I thought realWorld# was actually not a value at all
15:01:21 <SamB> that is, it doesn't take any registers or memory space to store it
15:02:07 <dons> right, its a strict value whos type is of unboxed kind, so it can always be reproduced if needed, and removed statically
15:02:08 <psnl> !hpaste
15:02:17 <dons> it can never be bottom
15:02:31 <dons> hpaste: url
15:02:31 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
15:03:33 <hpaste>  psnl pasted "error from gtk2hs" at http://hpaste.ath.cx:8000/35
15:03:50 <psnl> thats my latest bug
15:04:18 <sorear> tell fodder
15:04:19 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:05:10 <sorear> @seen glguy
15:05:11 <lambdabot> I saw glguy leaving #haskell 7m 55s ago, and .
15:07:52 <Axioplase> Is it possible to find "The church of the least fixed point" whithout an account on springer ?
15:08:55 * sorear checks what the bot was doing on Sep 30 2006
15:10:57 <sorear> Sep 30 2006 - no tunes logs!
15:11:01 <sorear> @where logs
15:11:02 <lambdabot> http://tunes.org/~nef/logs/haskell/ http://meme.b9.com/cdates.html?channel=haskell
15:12:26 <qwr> hmm. not really a problem at the moment... but if i write network code on linux i have to block sigpipe... with needs using System.Posix.Signals... with is not portable?
15:12:47 <qwr> s/with/which/
15:13:54 <qwr> and without blocking it whole process dies with sigpipe, when other end closes connection at bad moment
15:14:18 <qwr> fortunately i don't care about portability now :)
15:14:43 <sorear> sigpipe is a stupid hack - don't do anything about it, and if GHC dies, file a GHC bug.  this ought to be the kernel or rts concern, not yours.
15:15:57 <bd_> :t Data.HashTable.new
15:15:59 <lambdabot> forall val key. (key -> key -> Bool) -> (key -> Int32) -> IO (Data.HashTable.HashTable key val)
15:18:41 <dons> ?bug <-- qwr
15:18:42 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:18:56 <dons> report it here, might get fixed in the next 24 hours if you're timing is right :)
15:19:06 <dons> make sure you include some test code
15:19:11 <dons> and state the issue as clearly as you can
15:19:24 <dons> qwr: so yeah, as sorear says, file a bug :)  ^^
15:21:12 <sorear> what timezone is meme in?
15:22:06 <dons> west coast US
15:22:13 <sorear> same as CLOG?
15:23:52 <dons> oh, hmm . maybe not
15:25:06 <matthew-_> dons, the RULES pragma, is it just me or does this give you crazy power to change heavily the semantics of the rest of the code?
15:25:31 <matthew-_> i.e. there's no semantic checking that the rules don't violate the semantics of the code
15:25:45 <matthew-_> else there'd be no need for the rules, right? Or am I lost?
15:25:59 <sorear> matthew-_: there was a post on the list where some crazy used RULES to automatically change functions into their derivatives
15:26:08 <sorear> no, not Oleg
15:26:16 <brainly-green> humans can adapt to new user interfaces quickly--we can adapt to a new GUI very rapidly and to a scripting interface with a bit of effort
15:26:21 <sorear> anyway RULES is just for performance
15:26:34 <brainly-green> computer programs require a human to come in and manually change them, if you want them to adapt to a new interface
15:26:37 <sorear> there is a RULES that says map f . map g = map (f . g)
15:26:54 <matthew-_> sorear: sure. but there's no checking that the rules are sane at all - ghc will just blindly follow them
15:27:12 <matthew-_> so you could right RULES that say map f . map g = map (g . f) right?
15:27:17 <pejo> matthew, the responsibility to have correct rules falls on the programmer, yes.
15:27:19 <vincenz> brainly-green: thank you for preaching
15:27:19 <brainly-green> maybe we could enable computer programs to also have some kind of "common sense" about interfaces, so they wouldn't have to be configured
15:27:28 <matthew-_> right. thanks.
15:27:41 <brainly-green> that would be a really, really practical application of AI, if it could be done
15:28:00 <SamB> mathrick: um, no...
15:28:02 <SamB> er.
15:28:06 <SamB> matthew-_:
15:28:16 <matthew-_> the work that was done at hac07 with the optimisations of binary serialisation - was that mainly achieved (performance wise) through RULES ?
15:28:22 <SamB> I'm pretty sure the compiler at least typechecks rules!
15:28:24 <ndm> @seen dons
15:28:25 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 4m 33s ago.
15:28:44 <SamB> (otherwise how would it know whether the rule's type matched the situation?)
15:28:47 <matthew-_> SamB: you certainly hope. ;)
15:28:54 <ndm> SamB: really? i thought you could use the types to guide checking, i.e. they don't have to match perfectly
15:29:04 <ndm> SamB: although i guess they must be well-typed in themselves
15:29:07 <dons> matthew-_: it lets you extend the compilers optimisation range
15:29:14 <dons> and you are free to add unsafe optimisations
15:29:25 <vincenz> or unsemantic optimisation rules
15:29:26 <SamB> ndm: I'm pretty sure they have to be unifiable
15:29:27 <dons> there is some semantic checking
15:29:30 <vincenz> just like you can write code that is nonsense
15:29:33 <dons> since the left and right sides have to have the same type
15:29:35 <ndm> dons: SmallCheck has both a darcs repo and a Cabal file now!
15:29:39 <dons> yay!!
15:29:44 <dons> ndm++ persistence!
15:29:55 <vincenz> matthew-_: how is it any different from someone writing a function that does not do what you think it does
15:29:59 <dons> matthew-_: but yes, its terribly easy to add unsafe transformations
15:30:06 <ndm> dons: that was a lot of persistence, then going to his office and setting it up with Colin
15:30:10 <dons> i strongly encourage rules users to write QuickCheck properties for their rules
15:30:27 <brainly-green> to use a new interface, any human must understand, in some sense, what it is they are trying to do
15:30:27 <ndm> dons: what about StrictCheck properties?
15:30:30 <matthew-_> vincenz: oh indeed.
15:30:37 <ndm> dons: its really easy for rules to screw up strictness...
15:30:39 <dons> its less work than actually proving the rule sound, but its gives you 80% of the assurance ;)
15:30:40 <brainly-green> and they must be able to check reliably when they have done it
15:30:43 <dons> ndm, yeah
15:30:49 <dons> ndm, you can check that with QC though
15:30:56 <dons> ndm, just test data with bottoms inserted
15:30:57 <ndm> dons: using undefined?
15:31:00 <dons> yeah
15:31:01 <matthew-_> dons: re-quickcheck - I suppose it's one of those cases that quick check is idea for
15:31:03 <brainly-green> that is, they have to be able to determine when a sequence of their actions has accomplished a goal
15:31:16 <ndm> dons: Olaf has a tool, strictcheck that does it automatically, and even finds excess strictness in code etc.
15:31:20 <dons> matthew-_: yeap. QC caught bugs in rules fairly well in Data.ByteString
15:31:21 * vincenz peers at brainly-green 
15:31:23 <dons> ndm, oh!
15:31:25 <dons> havne't seen this
15:31:28 * ndm is using smallcheck for proofs
15:31:30 <vincenz> ndm: Olaf? Oleg--?
15:31:31 <dons> though i heard rumours from John Hughes
15:31:35 <ndm> Olaf Chital
15:31:39 <Pseudonym> Is it just me, or does "brainly green" sound like a spam subject line?
15:31:41 <vincenz> @google olaf chital
15:31:43 <ndm> @google Olaf Chital StrictCheck
15:31:44 <lambdabot> http://www.kuzbass.ru/moshkow/lat/LINUXGUIDE/user_guide_kirch.txt
15:31:44 <vincenz> Pseudonym: yeah
15:31:45 <lambdabot> Title: Olaf Kirch. Rukovodstvo administratora seti v OS Linux
15:31:46 <lambdabot> No Result Found.
15:31:51 <dons> heh
15:31:51 <glguy> back to work!
15:31:51 <brainly-green> brainly green sounds like soylent green
15:31:53 <pejo> Chitil, I hope?
15:31:54 <matthew-_> right, thanks. Interesting stuff. Nice paper btw dons - read it this morning. What year of your PhD are you in, can I ask?
15:32:01 <Pseudonym> Soylent green for zombies?
15:32:08 <dons> matthew-_: finishing my 4th year
15:32:11 <brainly-green> soylent green is a book and movie
15:32:12 <vincenz> matthew-_: ask him the forbidden question and what he wants to do after his phd
15:32:26 --- mode: ChanServ set +o vincenz
15:32:31 <dons> vincenz: no, the forbidden question is: so when do you finish?
15:32:34 <ndm> http://www.cs.kent.ac.uk/people/staff/oc/
15:32:36 <lambdabot> Title: Computer Science: Home page for O Chitil
15:32:36 <matthew-_> I'm guessing the forbidden question is when are you finished and what's the subject of your thesis?
15:32:38 <vincenz> dons: I know my date
15:32:40 <chessguy> you have to use unSafeAsk for that
15:32:44 <ndm> under Software
15:32:46 <dons> matthew-_: yeah ;)
15:33:03 <matthew-_> is 4 years normal for .au ?
15:33:09 <Pseudonym> You may know your date, but when do you finish?
15:33:15 <chessguy> i wonder, would it be bad practice to write something like Data.UnionFind in terms of Data.Tree ?
15:33:36 <ndm> chessguy: not if it works
15:33:38 --- mode: vincenz set -o vincenz
15:33:42 <brainly-green> now for a computer program to do the same thing that a human does (adapt to a new interface), the interface it interacts with will need to give some kind of feedback about everything it has done
15:33:43 <dons> ~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~[6~/win 33
15:33:48 <dons> grr
15:33:48 <shapr> dons: yow!
15:33:50 <ray> eek
15:33:54 <chessguy> @yow
15:33:55 <lambdabot> Will this never-ending series of PLEASURABLE EVENTS never cease?
15:33:55 <dons> wifi gone stoopid, sorry guys
15:33:57 <ndm> chessguy: do you have O inverse ackermans for UnionFind?
15:33:58 <Pseudonym> Stop trying to hack my IRC client!
15:33:59 <matthew-_> worse than brainly-green !
15:33:59 * ray sympathizes
15:34:13 <chessguy> ndm, have them?
15:34:20 <dons> brainly-green: this is a haskell language channel, please restrict yourself to on topic discussion :)
15:34:24 <vincenz> dons: what is /wini 33?
15:34:30 <vincenz> -i
15:34:41 <brainly-green> thanks for telling me dons but why do you think this is off topic, having not heard me out?
15:34:58 <nornagon> vincenz: switches to window 33
15:34:59 <ndm> chessguy: the time bounds for UnionFind are O(inverse ackermans), which is really tiny (less than 4 for all practial values). Do you get that time bound with your UnionFind?
15:35:04 <matthew-_> dons: in your paper, you mention that spj added further support for additional rules pragmas - what did that amount to?
15:35:04 <shapr> brainly-green: Dude
15:35:05 <vincenz> nornagon: of irssi?
15:35:09 <nornagon> yes
15:35:11 <dons> its not about haskell. if people have to actually ask for on topic, then you're not on topic...
15:35:11 <shapr> brainly-green: Do you know Haskell?
15:35:13 <vincenz> 33 windows ????
15:35:16 <chessguy> ndm, oh, i haven't written it yet
15:35:17 <ndm> chessguy: i tried to do that, briefly, but failed
15:35:26 <brainly-green> I have a beginner's knowledge of haskell
15:35:27 <nornagon> vincenz: sure
15:35:30 <dons> vincenz: hmm, i have 67 irssi windows open, I think ;)
15:35:31 <ndm> chessguy: if you do manage that, it would be very handy :)
15:35:32 <ray> if you think 33 is a lot you're not a serious irc user
15:35:40 <vincenz> dons: wow, for what purpose?  Do you code via irc?
15:35:45 <chessguy> is that amortized? and for which operation?
15:35:49 <nornagon> i only have 19 open atm, but i usually have more
15:35:54 <shapr> brainly-green: What about coding up your idea in Haskell, and then giving us a link to the source?
15:36:03 <ndm> chessguy: amortised = yes, union and find
15:36:07 <vincenz> shapr: in a darcs repo
15:36:10 <shapr> right
15:36:18 <chessguy> ok. i'll play around with it
15:36:26 <Pseudonym> Link to source is acceptable for one module if you don't know darcs yet.
15:36:26 <brainly-green> normally you talk about an idea before you implement it
15:36:34 <ndm> brainly-green: or blog post it - much better for giving out ideas, then post a link
15:36:46 <Pseudonym> Yeah, that's a good idea.
15:36:48 <ndm> plus blog posts can be shared more widely :)
15:36:54 <shapr> yup
15:37:03 <vincenz> meta-haskell conversation
15:37:03 <shapr> Like ndm's recent suggestion for -fnottingham-exts
15:37:06 <vincenz> :)
15:37:08 <dons> and less likely to incur 'off topic' complains in an irc channel, for exploratory stuff
15:37:16 <Pseudonym> Oh, no.
15:37:20 <matthew-_> brainly-green: not true. Linus didn't talk much before writing code, at least not publicly. Most of the time you don't know if it's going to work out, so just code first and then eval later.
15:37:23 <ndm> shapr: that wasn't me? i think
15:37:24 <Pseudonym> Haskell compiler flags will look like a who's who of the EU.
15:37:24 <chessguy> ndm, do you have any examples you were working off of? like what you would want the syntax to look like? or working (if not optimal) code?
15:37:30 <shapr> ndm: Ok I admit, it was me =)
15:37:43 * Pseudonym tries to think up some -fmelbourne-exts
15:38:00 <Pseudonym> There can't be -fsydney-exts, because they ban flags there.
15:38:04 <matthew-_> was anyone here at popl07 in addition to dons?
15:38:05 * vincenz adds the necessary -fpenis-exts
15:38:13 <shapr> vincenz: functional spam?
15:38:16 <brainly-green> I'm certainly not comparing myself to linus torvalds, but he did talk about what he was doing some
15:38:17 <ndm> chessguy: i just want union :: UnionFind -> UnionFind -> UnionFind, find :: UnionFind -> [a], same_set :: UnionFind -> a -> a -> Bool
15:38:28 <vincenz> shapr: seems rather contradictory
15:38:32 <brainly-green> plenty of projects started as emails or message board posts
15:38:35 * ndm has -superO
15:38:36 <emu> -fantastic-exts
15:38:40 <Pseudonym> brainly-green: A blog post would also be useful for people like myself who turned up half-way through the conversation.
15:38:43 <brainly-green> KDE for example
15:38:51 <ndm> originally started as -O11, for those people who have seen Spinal Tap
15:38:57 <shapr> brainly-green: Show us some code!
15:38:59 <chessguy> ndm, ok
15:39:00 <matthew-_> ndm: ;)
15:39:02 <shapr> ndm: haha
15:39:23 <dons> ndm heh!
15:39:24 <brainly-green> well it's clear nobody here wants to listen to this, though it's competely unreasonable to expect any code the instant someone presents you with an idea
15:39:29 <brainly-green> so I will go somewhere else
15:39:35 * matthew-_ wants to know what else is worth reading from popl07...
15:39:49 <ndm> brainly-green: ideas are always welcome, just blog posts are more accessible for a long flow of ideas
15:39:52 <Pseudonym> brainly-green: Hang on, now.  You've had a couple of suggestions which don't involve coding.
15:39:53 <Pseudonym> Right.
15:39:53 <dons> matthew-_: i'll have a comprehensive review done today, hoepfully
15:40:01 <dons> matthew-_: including damp, tldi and padl
15:40:08 <Pseudonym> For engineers, the best way to discuss things is to start with a technical whitepaper.
15:40:11 <dons> now, just have to go through my notes and the proceedings
15:40:15 <vincenz> dons: writing it down?
15:40:17 <Pseudonym> That's probably too formal for this, but you get the idea.
15:40:24 <matthew-_> dons: super. I have the proceedings for tldi and popl itself, but that's all
15:40:31 <ndm> brainly-green: for example i missed the start of your description, so can't read the whole thing, and IRC logs are horrible to read
15:40:51 <matthew-_> dons, did you see any of Byron Cook's talks ?
15:41:10 <dons> oh, were you in Nice? did I miss a chance to meet up?
15:41:10 <chessguy> wait, find UnionFind -> [a] ?
15:41:43 <ndm> chessguy: UnionFind -> a -> [a], i mean - given an element find its set
15:41:45 <matthew-_> dons, fraid not. I'm 1st year PhD and didn't go. So of the other PhDs, 2nd year+ and staff went though
15:41:53 <dons> ah right.
15:42:01 <vincenz> matthew-_: what topic?
15:42:14 <ndm> chessguy: UnionFind a -> a -> Set a, instead perhaps - UnionFind will definately need an "a" at least
15:42:14 <matthew-_> err, verification of termination of code
15:42:25 <vincenz> matthew-_: work with ndm then?
15:42:34 <chessguy> shouldn't it be union :: UnionFind a -> UnionFind a -> UnionFind a, find :: UnionFind a -> a -> [a], same_set :: UnionFind a -> UnionFind a -> Bool
15:42:42 <ndm> vincenz: ndm no longer does termination stuff, someone solved it (very well for Haskell)
15:42:48 <vincenz> ah right
15:42:59 <ndm> chessguy: yes, i was too lazy to write the "a" 's
15:43:05 <vincenz> ndm: vincenz finds it odd that others speak about themselves in third person
15:43:09 <matthew-_> vincenz: does termination proofs of Windows device drivers etc. Seems to mirror other things in many ways, including dependent types, ownership types etc. It's weird how different parts of computing are actually really close if you squint
15:43:26 <ndm> chessguy: plus its entirely possible those signatures aren't the best, but they do look plausible
15:43:37 <vincenz> matthew-_: ah right
15:43:46 <matthew-_> ndm: quick pointers to that work?
15:43:52 <ndm> chessguy: perhaps union :: UnionFind a -> a -> a -> UnionFind a
15:43:56 <vincenz> matthew-_: wait 'does', I was asking what -your- topic was
15:44:06 * matthew-_ tends to read most stuff he can get his hands on
15:44:07 <matthew-_> oh!
15:44:13 <ndm> @google giesl haskell termination
15:44:17 <lambdabot> http://www-i2.informatik.rwth-aachen.de/giesl/papers/RTA06-distribute.ps
15:44:20 <matthew-_> tnx ndm
15:44:45 <chessguy> oh, where the a's are the representatives of the sets?
15:44:50 <matthew-_> vincenz: sorry, I thought you meant Byron's stuff. I'm looking at concurrency, in particular through dependently typed languages
15:45:17 <ndm> matthew-_: see also http://www-users.cs.york.ac.uk/~ndm/downloads/refs-termination_checking_for_a_lazy_functional_language-21_dec_2004.pdf
15:45:21 <lambdabot> http://tinyurl.com/2zy999
15:45:30 <vincenz> matthew-_: ah ok
15:45:38 <chessguy> whew, thank goodness for tinyurl on that one
15:45:44 <ndm> chessguy: yes, i guess the UnionFind structure will be an efficient version of [[a]], and union will grab two sets and make them into one
15:46:19 <matthew-_> that 2nd one is just refernces yes?
15:46:33 <chessguy> hmm, i thought union was supposed to take two separate UnionFinds, and produce a new one
15:46:34 <matthew-_> slightly short paper ;)
15:46:51 <ndm> matthew-_: yes, from my first year presentation on termination - my PhD was originally termination + pattern safety
15:47:05 <matthew-_> ahh, what's the PhD on now?
15:47:08 <abz> whats the standard way or standard operator for doing reverse function composition?
15:47:10 <pejo> ndm, you started working on termination issues, and then someone solved it in the middle of your work?
15:47:11 <vincenz> matthew-_: hoogle :)
15:47:13 <shapr> abz: >>>
15:47:15 <SamB> termination is easy
15:47:20 <abz> thanks
15:47:22 <SamB> kill(2) works well
15:47:25 <shapr> @type (>>>)
15:47:27 <lambdabot> forall (a :: * -> * -> *) d b c. (Arrow a) => a b c -> a c d -> a b d
15:47:39 <matthew-_> vincenz: wow, is that from a theoretical or practical perspective?
15:47:55 <vincenz> matthew-_: no I was just kidding, but one of ndm's great works is hoogle
15:48:10 <matthew-_> ahh, sorry misread who said what
15:48:13 <ndm> matthew-_: http://www-users.cs.york.ac.uk/~ndm/projects/catch.php - the bottom 3 links on that page may give you some info, qualifying disertation has explanations of some of those references - if you want a quick overview
15:48:14 <lambdabot> Title: Neil Mitchell - Catch - Case Totality Checker for Haskell
15:48:29 <Pseudonym> I don't have any Great Works(tm).
15:48:34 <shapr> Pseudonym: except lambdabot
15:48:40 <vincenz> Pseudonym: then stick to Great Words
15:48:43 <Pseudonym> My contribution wasn't great.
15:48:49 <chessguy> @quote pseudonym
15:48:50 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
15:48:50 <ndm> pejo: well, i hadn't got on to it, and pattern matching seemed more useful in practice, so was kind of glad when i was the solution and was able to stick to one aspect
15:48:51 <Pseudonym> Oh, I know some great words, that's true.
15:48:55 <chessguy> @quote Pseudonym
15:48:55 <lambdabot> Pseudonym says: For some reason, I'm having trouble reconciling basic with "good API design".
15:49:01 <chessguy> there, that's a great work
15:49:01 <shapr> @quote Pseudonym
15:49:02 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
15:49:19 <SamB> @quote trippy
15:49:20 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
15:49:22 <SamB> @quote trippy
15:49:23 <lambdabot> Pseudonym says: Lazy evalution is really, really trippy.
15:49:25 <Pseudonym> Woo.
15:49:27 <SamB> @quote lazy
15:49:27 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
15:49:29 <Pseudonym> I didn't know about that.
15:49:34 <Pseudonym> @quote fortran
15:49:35 <lambdabot> ChrisKuklewicz says: Are there little known Haskell idioms for doing math? Is there an undocumented -funleash-fortran parameter?
15:49:42 <SamB> hehehehe
15:49:42 <shapr> @quote nym
15:49:43 <lambdabot> dons says: I think Pseudonym should submit some more @free patches, instead of breaking poor lambdabot. Why do we always hurt the ones we love?
15:49:59 <dons> yeah, new year's eve patch for regex matching
15:50:00 <chessguy> haha
15:50:00 * Pseudonym laughs
15:50:12 <Pseudonym> ?free fst
15:50:14 <lambdabot> f . fst = fst . $map_Pair f g
15:50:21 <dons> and iirc Pseudonym was on vacation over the new year period
15:50:39 <Pseudonym> Actually, I was technically unemployed.
15:50:50 <Pseudonym> I only got my new contract signed late last week.
15:50:58 <dons> wel, good thing its now signed
15:51:08 <shapr> 'unpaid vacation'
15:51:10 <Pseudonym> Yeah, so I can get back to haskell hacking instead of working.
15:51:18 <dons> :P
15:51:19 <matthew-_> anyone here going to be at discotech2007 (fmoods, coordination and something else)?
15:51:26 <Pseudonym> shapr: Not entirely.  I did get my leave paid out.
15:51:31 <shapr> oh!
15:51:39 <shapr> paid unemployment...
15:51:43 <Pseudonym> Yeah.
15:54:07 <dons> matthew-_: nice name for a conference :)
15:54:47 <chessguy> oh, is that a conference? i thought it sounded like the 2007 version of woodstock
15:54:53 <shapr> I thought so too.
15:55:16 <Pseudonym> Are they discussing discs or SCO?
15:55:50 <matthew-_> http://www.discotec07.cs.ucy.ac.cy/
15:55:52 <lambdabot> Title: DisCoTec07 - Home
15:55:59 <matthew-_> it's only slightly FP
15:56:18 <matthew-_> in fact, it's paradigm agnostic ;)
15:56:26 <vincenz> why didn't they hold it in ibiza?
15:56:29 <Pseudonym> All those suffixes on the domain name look like ASCII APL.
15:56:50 <Pseudonym> Or maybe a Haskell pipeline: cs . ucy . ac . cy $ xs
15:57:38 <chessguy> is Data.Tree reasonably efficient?
15:57:57 <sorear> where is Data.Tree ?
15:58:01 <sorear> not base
15:58:09 <vincenz> how can any Data.Tree ever be efficient or inefficient
15:58:10 <vincenz> it's a tree
15:58:19 <sorear> nm'
15:58:22 <vincenz> unless you mean 'a tree used as a map' with xxx balancing
15:58:30 <chessguy> uh
15:58:33 <matthew-_> data Tree a = Empty | Node (Tree a) a (Tree a) -- what more can you need ;-)
15:58:44 <Pseudonym> data Tree a = Node a [Tree a]
15:58:46 <Pseudonym> Even better.
15:58:47 * vincenz cheers for matthew-_ 
15:58:48 <chessguy> i assume it has functions attached to it for adding, removing, searching, etc.
15:58:52 <ndm> chessguy: to write a UnionFind in terms of?
15:58:54 <vincenz> Pseudonym: no, doesn't allow empty trees
15:59:03 <Pseudonym> Dammit.
15:59:06 <ndm> chessguy: would be horrible inefficient compared to a specialised version
15:59:16 <chessguy> ndm, sort of. i was going to use it as a model to write an InverseTree
15:59:22 <chessguy> if it's efficient
15:59:32 <vincenz> data MTree a = Node Maybe ( a [Tree a])
15:59:34 <therp> .oO("my Liskell screencast is about 1GB.. I wonder who would be willing to watch such a thing..")
15:59:34 <sorear> it's just a data structure
15:59:38 <vincenz> data MTree a = Node Maybe ( a, [Tree a])
15:59:44 <sorear> only operations have efficiencies
15:59:55 <sorear> no, operations have only bigohs.
15:59:57 <chessguy> sorear, http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
15:59:59 <lambdabot> http://tinyurl.com/2gwkse
16:00:08 <sorear> chessguy: saw it :(  15:55 < sorear> nm'
16:00:08 <chessguy> that's NOT just a data structure
16:00:10 <Kaboem> If I have this :
16:00:10 <Kaboem> test::[[Int]]->[Int]
16:00:10 <Kaboem> test (a:rest) = a ++ a
16:00:10 <Kaboem> What do I have to change to calc a ++ b (with b is the second element of that list? ) ? I can't get it right with that double list thing :(
16:00:11 <vincenz> chessguy: your question doesn't make sense
16:00:22 <vincenz> chessguy: if you need a tree, then how can you ever be more or less efficient, structurally you need a tree
16:00:34 <nornagon> dons: hey, haskell.vim
16:00:37 <nornagon> link me!
16:00:40 <vincenz> blegh
16:00:43 <matthew-_> I have a good implementation of an OctTree if you want it cheeseguy
16:00:46 <vincenz> Data.Tree is another faulty implementation
16:00:52 <dons> nornagon: hmm?
16:00:53 <vincenz> what is it with people and writing trees that can never be empty!
16:01:05 <nornagon> dons: dylan tells me you have a complex haskell.vim
16:01:10 <nornagon> i should like to see it
16:01:15 <sorear> vincenz: Either Tree Stump
16:01:19 <chessguy> vincenz, yeah, but the way the tree is implemented can greatly affect the algorithms that operate on the teree
16:01:21 <chessguy> *tree
16:01:30 <vincenz> chessguy: not much
16:01:32 <vincenz> chessguy: not in O-notation
16:01:42 <dons> i do. its findable from haskell.orgs' editors page, but earthy's new haskell.vim is much more complete
16:01:43 <vincenz> trees are pretty straightforward
16:01:45 <dons> i think it approaches emacs mode for features
16:01:51 <chessguy> whatever
16:01:55 <matthew-_> Tim Sheard does the most bizarre version of Tree in all his Omega papers
16:01:55 <dylan> Nifty!
16:02:02 <sorear> not a problem, shim is almost mature :)
16:02:12 <matthew-_> Yikes, you know you're in trouble when: "Things have been cleaned up to the point that this release has 40,000 fewer lines of code - but more functionality." -- next version of X.org
16:03:08 * sorear could probably write an Xserver more stable than X.org in 40klines  (slower, but who cares? X.org has 5y old crash bugs that affect real people like me.)
16:03:22 <shapr> sorear: Go for it!
16:03:24 <ptolomy> @pl eitherOne x = (x==3) || (x==2)
16:03:25 <lambdabot> eitherOne = liftM2 (||) (3 ==) (2 ==)
16:03:44 <vincenz> chessguy: I'd be interested if you had a counterexample
16:03:56 <sorear> I'm not looking forward to implementing the solid mass of special cases that is opengl.
16:04:08 <vincenz> chessguy: but when I think of tree, I typically think of pretty much:  data Tree a = Leaf | Node (Tree a) a (Tree a)
16:04:20 <Anon4888> That's a binary tree :)
16:04:23 <chessguy> ok, you beat your point to death already
16:04:24 * matthew-_ goes to bed.
16:04:27 <vincenz> Anon4888: riht
16:04:43 <vincenz> chessguy: that's not my intent, I really mean it, I'm interested in what you mean
16:04:52 <sorear> riht? that's a haskell tutorial? :)
16:05:00 <vincenz> I'm prolly missing something
16:05:05 <Anon4888> Leaf a
16:05:12 <Anon4888> :)
16:05:47 <sorear> Decisions are hard, lets do math!
16:06:07 <Anon4888> What do monads get you?
16:06:20 <vincenz> data Tree a = Tree (Maybe (a, Tree a))
16:06:28 <vincenz> Anon4888: a headache
16:06:34 <sorear> vincenz: that's a list!
16:06:44 <vincenz> sorear: a unary tree :)
16:06:44 <sorear> vincenz: is a unary tree a tree?
16:06:54 <glguy> ?pl return $ liftM (setLastNickCookie nick =<<) resp
16:06:55 <lambdabot> return (fmap (setLastNickCookie nick =<<) resp)
16:07:01 <vincenz> sorear: ask bamboo
16:07:14 <Anon4888> a unary tree is obviously a tree
16:07:20 <Anon4888> it says so right there
16:08:03 <chessguy> according to the link i gave, the trees there are monadic. i'm wondering the same thing as Anon4888, what's the link between a tree and a monad?
16:08:07 <vincenz> yeah just like "vegetarian meat"
16:08:19 <sorear> chessguy: trees are-a-kind-of monad
16:08:38 <chessguy> well, according to vincenz, one tree is the same as another, so why make them monadic?
16:08:52 <sorear> you referring to unfoldTreeM et al?
16:09:05 <sorear> almost all trees are monads
16:09:11 <sorear> even unary trees
16:09:14 <Thomas2> this is almost certainly the wrong channel but ... does anyone know if standard ML has logical operations hidden somewhere? I seem to have not, but not and or or ...
16:09:16 <sorear> instance Monad []
16:09:17 <vincenz> definitely unary ones
16:09:29 <chessguy> but why?
16:09:42 <vincenz> sorear: why 'almost'
16:09:50 <sorear> chessguy: join is flatten, that's why
16:10:08 <chessguy> ?hoogle flatten
16:10:08 <lambdabot> Data.Tree.flatten :: Tree a -> [a]
16:10:09 <lambdabot> Data.Graph.flattenSCC :: SCC vertex -> [vertex]
16:10:09 <lambdabot> Data.Graph.flattenSCCs :: [SCC a] -> [a]
16:10:25 <sorear> vincenz: almost is the safe thing to say when incompletely sure :)
16:10:30 <vincenz> :)
16:10:38 <Anon4888> @instance Monad
16:10:38 <lambdabot> Maybe you meant: instances instances-importing
16:10:44 <Anon4888> @instances Monad
16:10:46 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:11:06 <vincenz> horseradish, so tasty but oh so spicy
16:11:16 <vincenz> sorear: I thought all non-constrained containers were monads
16:11:36 <Anon4888> vincenz: As a rule of thumb, anything and everything is a monad
16:11:46 <vincenz> constrained in the sense in: (Ord a) => Set a
16:11:53 <vincenz> ..sense of..
16:12:15 <Excedrin> Thomas2: they're called 'andalso' and 'orelse'
16:12:35 <lisppaste2> ptolomy pasted "tiny life implementation" at http://paste.lisp.org/display/35798
16:12:44 <vincenz> Thomas2: heh, your sentence is very funky...how to parse "not and or or"
16:12:45 <vincenz> :D
16:12:52 <ptolomy> Any suggestions for neatenings?
16:12:59 <bd_> ptolomy: comonads! :)
16:13:00 <chessguy> Conway's life?
16:13:00 <sorear> vincenz: data Pair a = Pair a a .  show me instance Monad Pair, please.
16:13:01 <vincenz> ptolomy: whitespace?
16:13:14 <vincenz> hmm
16:13:14 <bd_> ptolomy: http://sigfpe.blogspot.com/2006/12/evaluating-cellular-automata-is.html
16:13:14 <vincenz> ok
16:13:17 <lambdabot> Title: A Neighborhood of Infinity: Evaluating cellular automata is comonadic, http://tinyurl.com/2e55ly
16:13:28 <sorear> ptolomy: @paste has moved btw
16:13:31 <vincenz> return = fix (join Pair)
16:13:36 * vincenz thinks
16:13:45 <ptolomy> Now I need to learn what a comonad is..
16:13:53 <vincenz> @type \f -> fix (join f)
16:13:54 <lambdabot> forall a. (a -> a -> a) -> a
16:13:57 <vincenz> nope
16:14:03 <sorear> vincenz: return can (must, if total) be join Pair
16:14:12 <sorear> vincenz: now define join.
16:14:24 <vincenz> you mean bind?
16:14:27 <vincenz> oh!
16:14:28 <sorear> it needs to commutatively turn a pair of pairs into a pair.
16:14:31 <vincenz> wait, I misread your statement
16:14:40 <vincenz> ok
16:14:47 <sorear> s/comm/assoc/
16:14:57 <vincenz> (Pair a b) >>= f = Pair (f a) (f b)
16:15:08 <sorear> vincenz: that's fmap
16:15:16 <vincenz> that's >>=
16:15:23 <sorear> OK, flip fmap
16:15:25 <vincenz> wait
16:15:33 <vincenz> no, it's not, you've got the innerpairs
16:15:47 <sorear> hint: x >>= return --> x
16:16:02 <vincenz> (Pair a b) >>= f = f a
16:16:06 <vincenz> there you go
16:16:12 <vincenz> you're guaranteed from return that a and b are always the same
16:16:36 <sorear> vincenz: getChar can't be made from return, but the monad laws still should apply to it
16:17:02 <vincenz> sorear: the rules of monad still hold
16:17:05 <vincenz> afaict
16:17:12 <vincenz> they just disregard the second value at all times
16:17:56 <sorear> > let jp (a,b) = a in jp . jp (((1,2),(3,4)),((5,6),(7,8)))
16:17:58 <lambdabot>  Couldn't match `a1 -> (a, b)' against `(a2, b1)'
16:18:00 <vincenz> sorear: anyways my original confusion (also due ot the fact that I'm tired) is that I orignally read : data Pair a = Pair (Pair a) (Pair a)
16:18:01 <sorear> > let jp (a,b) = a in jp . jp $ (((1,2),(3,4)),((5,6),(7,8)))
16:18:02 <lambdabot>  (1,2)
16:18:26 <sorear> > let jp (a,b) = a ; fp f (a,b) = (f a,f b) in jp . fp jp $ (((1,2),(3,4)),((5,6),(7,8)))
16:18:28 <lambdabot>  (1,2)
16:18:34 <sorear> whoa!
16:18:36 <qwr> sorear, dons: http://linux.ee/~mzz/ghcpipebug/
16:18:37 <lambdabot> Title: Index of /~mzz/ghcpipebug
16:18:37 <vincenz> ;0
16:18:39 <vincenz> ;)
16:18:42 <vincenz> \o/
16:19:08 * sorear tries to remember the other two
16:19:15 * vincenz waasn't sure it'd work tho
16:19:18 <ptolomy> Where is paste now-a-days?
16:19:24 <sorear> @paste
16:19:24 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
16:19:30 <sorear> !paste
16:19:31 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
16:19:47 <sorear> ^^^ same site, use it & give feedback to glguy
16:20:15 <sorear> > let jp (a,b) = a ; fp f (a,b) = (f a,f b) ; rp a = (a,a) in jp . rp $ (1,2)
16:20:17 <lambdabot>  (1,2)
16:20:22 <sorear> > let jp (a,b) = a ; fp f (a,b) = (f a,f b) ; rp a = (a,a) in jp . fp rp $ (1,2)
16:20:23 <lambdabot>  (1,1)
16:20:52 <sorear> join . fmap return should be id | m (m a) -> m (m a), right?
16:21:10 <ptolomy> Say, that paste is better.
16:21:25 <sorear> Parse error
16:21:27 <shapr> ptolomy: glguy wrote it a few days ago.
16:22:12 <Anon4888> sorear: there's a trivial Monad instance on Pair a a isn't there?
16:22:20 <qwr> http://linux.ee/~mzz/ghcpipebug/strace.txt
16:22:31 <qwr> strace about dieing vie SIGPIPE
16:22:35 <qwr> via
16:22:36 <sorear> Anon4888: vincenz just failed to find it
16:22:49 <qwr> where i report it?
16:22:49 <Anon4888> k
16:22:53 <sorear> Functor, yes.
16:23:13 <sorear> (and I do wish instance Functor (\a -> (a,a)) existed...)
16:23:21 <vincenz> ?
16:23:40 <sorear> OK, OK, /\
16:23:44 <vincenz> mine is rather trivial
16:23:48 <vincenz> return a = Pair a a
16:23:54 <vincenz> (Pair a b) >>= f = f a
16:24:08 <sorear> I'm holding him to totality
16:24:24 <vincenz> I'm going to hold myself to my bed
16:24:25 <sorear> vincenz: yours doesn't satisfy (join . fmap return == id)
16:24:47 <vincenz> you assume a given functor impl
16:24:54 <sorear> ?unpl join . fmap return
16:24:55 <lambdabot> (\ c -> (fmap return c) >>= \ d -> d)
16:25:03 <sorear> ?. undo unpl join . fmap return
16:25:04 <lambdabot> (\ c -> (fmap return c) >>= \ d -> d)
16:25:07 * vincenz points at fmap
16:25:15 <vincenz> fmap is nonreducible afaik
16:25:17 <sorear> vincenz: liftM then :)
16:25:23 <vincenz> liftM === fmap
16:25:30 <ptolomy> hpaste is a damn good ad for HApps.
16:25:34 <Anon4888> ah, didn't see the totality requirement
16:25:58 <vincenz> anyways, neither I knew about the totality requirement
16:26:48 * vincenz has to go to sleep, however
16:26:56 <sorear> @users
16:26:57 <lambdabot> Maximum users seen in #haskell: 321, currently: 296 (92.2%), active: 49 (16.6%)
16:26:58 <vincenz> sorear: feel free to @tell me a link to this totality req
16:27:00 <vincenz> @lusers
16:27:01 <lambdabot> Maximum users seen in #haskell: 321, currently: 296 (92.2%), active: 49 (16.6%)
16:27:24 <sorear> vincenz: @tell vincenz sorear made it up
16:27:30 <sorear> vincenz: undefined is boring
16:28:01 <vincenz> Anyways, goodnight
16:28:13 <sorear> @seen MathematicalOrchid
16:28:13 <lambdabot> I haven't seen MathematicalOrchid.
16:28:21 * dons grumbles about the lack of comments in hpaste
16:28:31 <dons> sorear: hmm, yeah, you think he hangs out here?
16:28:41 <dons> (i saw the wiki stuff)
16:28:41 <sorear> dons: he claims to have been here
16:29:24 <sorear> I don't buy it ... unless he lives on hackathon time and doesn't overlap my schedule, or last came before I joined ...
16:29:57 <dons> *shrug* not everyone is always right about everything ;)
16:30:24 <sorear> coments == the -- kind? or is this a program feature?
16:30:52 * sorear has never heard of comments in the specific context of a pastebin
16:31:12 <dons> in the src
16:31:38 <shapr> bos: Hey, can you point hpaste.org to 65.254.53.221 ?
16:32:07 <sorear> shapr: can you do a Host: dispatch on the kakapo server?
16:32:10 <lotus> who is MathematicalOrchid.
16:32:22 <shapr> sorear: Yup, it's done.
16:32:31 <sorear> lotus: a whining newbie who has wikis confused with mailing lists
16:33:18 <sorear> I'm almost tempted to refer him to smerdy or monochrom
16:33:24 <dons> yeah. i don't like the use of haskell.org as a mailing list
16:33:31 <shapr> Hey, monochrom > smerdy
16:33:40 <lotus> sorear: that's harsh
16:33:46 <lotus> shapr: WHAT?
16:33:56 <shapr> Did monochrom get banned or something?
16:34:00 * sorear wasn't sure if monochrom was kidding about wanting to start scaring newbies
16:34:03 <vincenz> shapr: you're saying monochrom is worse than smerdy?
16:34:09 <shapr> no, > means better than :-)
16:34:17 <vincenz> better at being worse :)
16:34:22 <shapr> Nah
16:34:22 <sorear> shapr: monochrom said he was waiting for permission to start scaring away newbies
16:34:25 <vincenz> yeah
16:34:29 * shapr shrugs
16:34:34 <shapr> If he isn't doing it...
16:34:35 <vincenz> sorear: smerdy is another whole other level
16:34:39 <sorear> shapr: he quoted wadler's "Avoid sucess at all costs"
16:34:51 <sorear> vincenz: I've only heard legends
16:34:58 <shapr> sorear: lucky you
16:35:08 <shapr> I dealt with him in private chat for months.
16:35:09 <allbery_b> define success
16:35:15 <vincenz> sorear: I've experienced it in first person, he singlehandedly ruined the ocaml community on freenode
16:35:19 <allbery_b> success like java?  AVOID
16:35:21 <vincenz> ruined/ruins
16:35:25 <shapr> allbery_b: I think wadler meant "Avoid bowing to the pressure that success can bring."
16:35:31 <allbery_b> yeh
16:35:39 <sorear> vincenz: ruined would've been worse
16:35:42 <allbery_b> that's kinda what I was getting at
16:35:45 <vincenz> sorear: yah
16:35:49 <sorear> vincenz: ruined would've meant his damage outlasted him
16:35:59 <shapr> sorear: I think it did/has/will.
16:36:00 <vincenz> sorear: it's one of the reasons that I hung around in #haskell much before I learned haskell, ask shapr
16:36:03 <allbery_b> ...of course, I'm uncertain Sun was handling Java any better by itself
16:36:48 * vincenz always wonders about people like that if they're like that oocly as well, and if so, how they function in society
16:36:54 <shapr> sorear: Smerdy advertised on the Haskell wiki that I had unfairly banned him and that it was negatively affecting his academic career.
16:37:08 <shapr> I was the admin and maintainer of the Haskell wiki at that time.
16:37:16 <dons> shapr: hey, I met smerdy at Nice
16:37:21 <vincenz> dons: oh and?
16:37:23 <shapr> and?
16:37:25 <dons> seemed quite normal in person :}
16:37:31 <shapr> I guess it's only online?
16:37:58 <dons> i only spoke to him briefly
16:38:06 <vincenz> online it's easier to forget you're dealing with people
16:38:09 <shapr> I couldn't find him at HW, I wonder if he was avoiding me.
16:38:19 * allbery_b has known a few people who were reasonable in person but somehow never quie figured out that anyone they were interacting with via computer could possibly be offended by their behavior, because it somehow wasn't "real"
16:38:56 <vincenz> allbery_b: makes you wonder if then they are nice irl just cause they fear of repercusion but are still nasty on the inside
16:39:06 <allbery_b> that also is possible
16:39:17 <jcreigh> that's pretty cynical.
16:39:22 <shapr> Yeah, bringert's quote of "not surviving must surely count as non-verbal communication" comes to mind.
16:39:27 <SyntaxNinja> too intimidated to be mean? a sad thought.
16:40:34 <dons> heya SyntaxNinja
16:40:44 <shapr> Smerdy is the only person I've interacted with online who made me want to go to their house and beat them up.
16:41:28 <SyntaxNinja> hi dons
16:41:38 <shapr> I hope I've never made anyone feel that way... hmm...
16:41:47 <huschi> i'm amazed. using monads makes it very easy to extend code.
16:41:51 <SyntaxNinja> shapr: I went to your house once, and your cat beat me up.
16:41:52 * vincenz looks at shapr and then his own white knuckles
16:42:04 <vincenz> SyntaxNinja: cat5?
16:42:07 <SyntaxNinja> meanest.cat.ever
16:42:07 <shapr> SyntaxNinja: Must have been someone else's house, I don't have a cat!
16:42:15 <shapr> Oh wait
16:42:17 <vincenz> oh, cat6!
16:42:17 <SyntaxNinja> heh
16:42:18 <shapr> That really did happen!
16:42:20 <Procyon> shapr: I have.. but it's one of the hazards of talking politics
16:42:21 <shapr> You mean MOGGIE
16:42:21 <SyntaxNinja> haha
16:42:22 <huschi> i tried to imagine how complicated my extension were without monads...
16:42:22 * allbery_b has a cat who might well do that
16:42:25 <dylan> I tend to associate the structure and syntax of ocaml with smerdyakov's personality....
16:42:25 <SyntaxNinja> MOOGIE!?!?
16:42:30 <shapr> Moggie
16:42:34 <vincenz> dylan: :D
16:42:36 <dylan> except one can get used to ocaml's syntax.
16:42:39 <SyntaxNinja> <kahn voice>Moogie</>
16:42:41 <shapr> dylan: Mind if I quote that? =)
16:42:41 <vincenz> dylan: especially the datacons are not first class bit
16:42:53 <dylan> shapr: sure
16:43:01 <shapr> @remember dylan I tend to associate the structure and syntax of ocaml with smerdyakov's personality....
16:43:01 <lambdabot> Done memoising quote for `dylan', if that is their real name...
16:43:07 <Igloo> shapr: Did your cat invent monads?
16:43:07 <vincenz> (fun x -> MyDataCons x)
16:43:15 <shapr> Igloo: No, but I'm sure he'd try to kill them.
16:43:38 <shapr> SyntaxNinja: Sofia saw Moggie recently, and in the ~2 years since I've not seen him, he's gotten older and meaner.
16:43:40 <SyntaxNinja> I went to Igloo's house once and he also didn't beat me up.
16:44:00 <SyntaxNinja> although he did make fun of my punting skills.
16:44:09 <vincenz> punting or punning?
16:44:21 <shapr> Bea had to grab Moggie with oven mitts and throw him into her office to keep the guests from getting scratched/bitten.
16:44:27 <SyntaxNinja> hah
16:44:29 <shapr> Oh, I enjoyed punting!
16:44:35 * Igloo went a meeelion miles to a stone's throw of SyntaxNinja's house, but didn't make it the last few yards
16:44:52 <shapr> sorear: If you put "65.254.53.221   hpaste.org" in your /etc/hosts file and then go to hpaste.org in a browser...
16:45:25 <glguy> hooray virtual hosts!
16:45:25 <Igloo> Actually, I did the same for shapr. But a slightly harder throw.
16:45:26 <SyntaxNinja> Igloo: yeah, I should have hosted a party or something; I was too busy :(
16:45:40 <qwr> http://hackage.haskell.org/trac/ghc/ticket/1114
16:45:41 <Igloo> I think we all were  :-)
16:45:42 <lambdabot> Title: #1114 (Socket code dies with SIGPIPE) - GHC - Trac
16:45:49 <shapr> glguy: As soon as bos points hpaste.org to kakapo's IP...
16:46:06 <shapr> Igloo: You came to my house?
16:46:12 <Igloo> SyntaxNinja: Well, I'll pop round some time once you move to Oxford with GC
16:46:16 <glguy> man... talk about a group effort...
16:46:17 <Igloo> shapr: To your country
16:46:22 <shapr> oh, when was that?
16:46:26 <shapr> HW?
16:46:28 <Igloo> ICFP 2002?
16:46:36 <shapr> 2003?
16:46:40 <shapr> You mean Sweden, yeah?
16:46:40 <Igloo> No, 2003, yes
16:46:43 <Igloo> Yes
16:47:07 <vincenz> Yes, 4, No, Yes, No
16:47:22 <shapr> That was pretty close... 13 hour train ride north, but then I moved to Stockholm later, so I think it counts.
16:47:30 <shapr> Igloo: But when will you come to visit me in Birmingham? =)
16:47:35 <Igloo> Oh, technically I came to your country twice, I guess, but only because you call countries states and continents countries  :-)
16:47:45 <shapr> heh!
16:47:53 <SyntaxNinja> Igloo: canada might be interested in your perspective ;)
16:48:12 * shapr grins
16:48:13 <vincenz> SyntaxNinja: not to mention mexico, or do we simply forget about them
16:48:18 <Igloo> Birmingham? That's only 70 miles up the M40!
16:48:22 * shapr snickers
16:48:23 <SyntaxNinja> vincenz: mexico doesn't care about Igloo
16:48:41 <shapr> Igloo: burmeenghayum, not buhmeengum
16:48:47 <Igloo> SyntaxNinja: If Russia is not in Europe then why should Canada be in the same continent as Portland?
16:48:55 <Pseudonym> What's 70 miles in real measurement?
16:49:05 <vincenz> > 70 * 1.6
16:49:06 <lambdabot>  112.0
16:49:08 <Pseudonym> ?google 70 miles in kilometres
16:49:09 <lambdabot> 70 miles = 112.65408 kilometers
16:49:11 <dons> ?google 70 miles in kms
16:49:14 <lambdabot> http://www.aboutscotland.com/duns/mansefield.html
16:49:15 <lambdabot> Title: Scottish Borders Bed and Breakfast Accommodation Mansfield Greenlaw
16:49:18 <dons> boo
16:49:22 <Igloo> It's 3.6508701e-12 parsecs, apparently
16:49:32 <dons> good to know
16:49:32 <Pseudonym> OK.  Well, that's an hour on an Australian freeway.
16:49:42 <sorear> c'mon, plancks are the only REAL unit.
16:49:50 <vincenz> that's less than an hour on european highways
16:49:50 <Pseudonym> True!
16:49:53 <sorear> s/s/ lengths/
16:49:58 <Pseudonym> ?google 70 miles in planck lengths
16:50:00 <lambdabot> http://en.wikipedia.org/wiki/Orders_of_magnitude_(length)
16:50:02 <Pseudonym> Damn.
16:50:12 <vincenz> @google planck in miles
16:50:14 <lambdabot> http://www.planck.com/intuitiveplanck.htm
16:50:14 <lambdabot> Title: intuitive Planck quantities
16:50:37 <xerox> "The Planck quantities are a system of natural units which arise purely from gravity and light. They don't depend on the mass of any one particular thing, like an electron or the universe."
16:50:49 <Pseudonym> Except there are different standards.
16:50:58 <Igloo> Miles are actually a very convenient unit for the UK, as you can pretend you'll average about 60 miles an hour assuming non-awful traffic, which makes the maths easier
16:51:01 <Pseudonym> Some choose G=1, some choose 8*pi*G = 1.
16:51:05 <vincenz> > 70*1.6 / (1.6e-35)
16:51:06 <lambdabot>  7.000000000000001e36
16:51:11 <vincenz> there you go
16:51:16 <vincenz> 7e36 plank lengths
16:52:04 <vincenz> Am I the only one that finds the 10^x factor between a mile and a planck length disturbing
16:52:05 <xerox> Tell me of the water of your planet, Muad-dib.
16:52:33 <vincenz> it's like a metric system based on miles
16:53:04 <SamB> that is kind of wierd
16:53:08 <slowriot> I have a list of actions that I want to execute. Apparently I can't match the list with (next, rest) though. It's the wrong type. Haskell expects IO (next,rest)
16:53:14 <slowriot> can I match that somehow?
16:53:18 <slowriot> oops
16:53:19 <SamB> miles being far larger than I can comprehend properly
16:53:29 <SamB> meters at least I can hold in my hand!
16:53:29 <sorear> augustss++ "Very cool!!!" :: ByteString
16:53:43 <SamB> sorear: wooooooo!
16:53:44 <xerox> slowriot: (this:next) = yourlist
16:53:48 <SamB> coooooolio!
16:54:02 <sorear> it's in HEAD now
16:54:09 <sorear> just darcspulled
16:54:09 <mauke> slowriot: do (next : rest) <- ioList; ...
16:54:24 <vincenz> Heh, this is -so- funny
16:54:25 <SamB> sorear: but does f :: ByteString -> Bool; f "yes" = True work?
16:54:29 <xerox> slowriot: also there is sequence :: Monad m => [m a] -> m [a]
16:54:34 <mauke> slowriot: er, wait ...
16:54:38 <slowriot> okay
16:54:39 <vincenz> in 1 year, ByteString will be the norm, and then everyone will be complaining about the lack of unicode in haskell :D
16:54:52 <SamB> vincenz: you surely jest
16:54:59 <sorear> SamB: not yet tried, but plausible based on patch description
16:55:00 <vincenz> tongue-in-cheekfully
16:55:00 * bd_ wants automatic string-to-bytestring conversion optimizations in GHC :)
16:55:03 <SamB> because by then someone will have got unicode implemented!
16:55:13 * sorear wants Data.ByteString.UTF8
16:55:54 <slowriot> mauke, the compiler accepts it
16:56:03 <chessguy> ?instances monad
16:56:04 <lambdabot> Couldn't find class `monad'. Try @instances-importing
16:56:04 <sorear> seems like a fun exercize, now that dons has taken all the fun out of lb-hacking with "let's focus on stability" :) :)
16:56:12 <chessguy> ?instances Monad
16:56:13 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:56:16 <dons> is the overloading patcch in the head now?
16:56:21 <dons> the string overlaoding patch
16:56:28 <dons> since there's lots of pattern guards I want to write with it..
16:56:29 <SamB> sorear: so have you stabalized the plugins build yet?
16:56:33 <jql> heh. first program I ever wrote in haskell was a char <-> utf8 transcoder
16:56:37 <jql> it's fun stuff
16:56:53 <Igloo> dons: Yes
16:56:58 <Igloo> dons: Pattern guards?
16:57:22 <nornagon> dons: um, the editors page on haskell.org looks pretty sparse
16:57:22 <sorear> dons: once we have 6.6 in hs-plugins, will HEAD be tracked as well?
16:57:38 <SamB> sorear: what!
16:57:48 <dons> hmm
16:57:52 <SamB> you mean they aren't going to commit to the same linker API?
16:57:58 * sorear thinks shim-debugger + lambdabot sounds nice
16:58:19 <SamB> we might have to tar and feather them if they break hs-plugins again!
16:58:23 <dons> f x  | "foo" <- take 4 bytestring = ...  -- happy :)
16:58:37 <dons> i.e. almost views
16:58:40 <SamB> ... unless it is ultimate breakage (the breakage to end all breakage)
16:59:02 <glguy> hpaste runs on the new HAppS api now
16:59:43 <Igloo> dons: Heh - and ITYM 3  :-)
16:59:48 <glguy> how do I tell darcs to include 1/2 of a change?
16:59:55 <glguy> it's grouping too much together
16:59:58 <glguy> when I do a record
16:59:59 <Igloo> glguy: You can't
17:00:00 <sorear> glguy: don't use -a
17:00:09 <glguy> -a?
17:00:24 <sorear> OH, so it makes hunks too big
17:00:35 <sorear> dons: don't apply the @seen patch I sent
17:00:42 <dons> hmm
17:00:47 <dons> when did you send it..?
17:00:49 <sorear> dons: sjanssen made the same change (which you applied)
17:00:54 <dons> ah yes.
17:00:57 <dons> spotted that
17:01:05 <dons> i just applied sjanssen , since it was first
17:01:32 <sorear> so, /mode darcs_nonexpert, should I kill my patch with unpull?
17:02:03 <dons> unrecord/ revert/ pull
17:02:03 <Igloo> Yup
17:02:11 <dons> you mean, your local change
17:02:14 <nornagon> dons: the only vim plugin that google is showing me is one by Arthur van Leeuwen
17:02:18 <Igloo> unrecord/revert == unpull
17:02:22 <dons> yeah, that's the best one
17:02:30 <nornagon> i see
17:02:41 <nornagon> the announce seems to be saying 'rudimentary'
17:02:41 <dons> ah ok
17:02:54 <dons> even if it isn't actually reversing a pull, eh?
17:03:13 <dons> i.e. a local record is killed with unpull
17:03:14 <Igloo> Yes, unpull doesn't care how the patch came into being
17:03:26 <sorear> Shall I pull this patch? (1/2)  [ynWvpxqadjk], or ? for help: darcs: <stdin>: hSetBuffering: unsupported operation (Illegal seek)
17:03:29 <dons> right. maybe it should be unpatch :)
17:03:30 <dons> unapply?
17:03:39 <sorear> it'd be nice if that didn't happen as often
17:03:39 <dons> sorear: try again
17:03:50 <Igloo> It's also called obliterate nowadays, I think
17:03:58 <dons> ah ok
17:04:01 <sorear> dons: I know, I'm used to it, just like I'm used to bsods under windows
17:04:07 <dons> so that's like unliterate/literate? :)
17:04:42 <augustss> yo
17:04:51 <sorear> hi
17:04:55 * glguy is going to reload hpaste on the new API, notify me if anything is broken (I'll be checking too)
17:05:00 <dons> hey augustss . i hear the string overloading patch has landed ?
17:05:08 <sorear> augustss: did you see my augustss++ ?
17:05:11 <augustss> has it?
17:05:17 <sorear> it has
17:05:20 <dons> glguy: hmm. ok. i've got some big refactoring patches on their way ... :)
17:05:28 <dons> i hope your recording ?
17:05:32 <sorear> 16:50 < sorear> augustss++ "Very cool!!!" :: ByteString
17:05:37 <glguy> dons: I just pushed the patch
17:05:38 <augustss> :)
17:05:51 <sorear> @karma augustss
17:05:52 <augustss> excellent
17:05:52 <lambdabot> augustss has a karma of 6
17:06:03 <sorear> It doubled your karma!
17:06:08 <augustss> lol
17:06:15 <augustss> doesn't take much, huh?
17:06:19 <dons> glguy: what's the best way to test hpaste locally?
17:06:31 <dons> glguy: and is that my irc bot tut I see in the src? :)
17:06:32 <glguy> dons: change "baseurl" and comment out the forkIO
17:06:33 <augustss> I'll clean up my next patch soon
17:06:43 <glguy> dons: you'll notice your name in the "LICENSE"
17:06:44 <dons> oh, what does the forkIO do?
17:06:49 <glguy> dons forks the bot
17:06:59 <dons> oh, you mean the irc bot?
17:07:06 <dons> right-o
17:07:43 <glguy> !paste
17:07:44 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
17:07:58 <glguy> the debugFilter is on right now, so there might be some slowdown (I odn't know)
17:08:07 <sorear> glguy: was there consensus earlier on changing !paste to /new?
17:08:23 <dons> i think sorear the url is soon to be hpaste.org anyway
17:08:27 <glguy> sorear: I didn't witness one
17:08:35 <glguy> sorear: but I don't remember it coming up at all
17:08:40 <glguy> sorear: so I might not have been around
17:08:55 <glguy> just remember talking to you about it briefly
17:10:13 <glguy> dons: did you pull down the changes?
17:10:16 <dons> glguy: how about a flag for web-only mode:
17:10:17 <dons> main = do
17:10:17 <dons>     args <- getArgs
17:10:17 <dons>     case args of
17:10:17 <dons>         []             -> mainWith id
17:10:19 <dons>         ["--web-only"] -> mainWith (forkIO (runBot ch))
17:10:25 <dons>     mainWith f = do
17:10:26 <dons>         ch <- newChan
17:10:26 <dons> ...
17:10:29 <glguy> dons: I'd accept that patch
17:10:47 <glguy> dons: but you might have it backwards....
17:10:52 <dons> i'm pulling your patches now, i'll do some testing , and send you off a bundle
17:10:56 <dons> ah ... yes :)
17:12:03 * dons drowsn in conflicts :)
17:12:37 <sorear> echo -e '50a\nAIR\n.\nw\nq' | ed PasteBot.hs
17:14:28 <glguy> dons: the HAppS change touched a lot of stuff... :(
17:15:48 <dons> its ok
17:16:10 <sorear> @localtime beschmi
17:16:12 <lambdabot> Local time for beschmi is Tue Jan 23 02:48:03
17:17:05 <shapr> @localtime bos
17:17:06 <lambdabot> Local time for bos is Mon Jan 22 17:13:51
17:17:21 <sorear> @tell beschmi shim is incompatible with my split-dirs setup :(  the preproc is only in the build dir
17:17:22 <lambdabot> Consider it noted.
17:17:23 * shapr boings
17:17:46 <shapr> @tell bos Could you please hpaste.org to 65.254.53.221 ?
17:17:46 <lambdabot> Consider it noted.
17:18:04 <shapr> Hm, I could do a 302 instead of a meta refresh...
17:18:31 <sorear> shapr: you can't embed happs in apache ? :) :)
17:18:47 <shapr> I could run happs instead of apache...
17:19:09 <glguy> shapr: I gave him the address
17:19:21 <shapr> spiffy
17:19:26 <glguy> shapr: and said to either make it a CNAME for kakapo.
17:19:31 <glguy> or to point it at that address
17:19:49 <shapr> Hm, will name based virtual hosting work if it's a CNAME?
17:20:23 <glguy> yes
17:20:30 <glguy> the browser doesn't know that it was a CNAME
17:20:34 <sorear> glguy: how about hiding the diff box if there are no annotations
17:20:55 <glguy> instead of disabling it for everyone but you?
17:20:58 <glguy> ok
17:21:02 <glguy> that was my original plan
17:21:15 <glguy> but some people dislike things appearing and disappearing
17:21:44 <sorear> if it's fine with everyone else, its fine with me (in this case)
17:21:57 <glguy> I don't think anyone else said anything
17:22:02 <glguy> Straw poll!
17:22:10 <glguy> your opinion counts if you are in channel
17:22:27 <dgriffi3> glguy: on what?
17:22:56 <glguy> what to do with the diffs when there are no annotations
17:22:58 <glguy> diffs form
17:23:03 <glguy> right now it disables the button
17:23:10 <glguy> but i could just not display it at all
17:23:13 <glguy> or something else
17:23:22 <glguy> I imagine that no one cares
17:23:27 <glguy> but i'm open to suggestion
17:23:34 <emk> @seen dons
17:23:35 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 7m 46s ago.
17:23:43 <glguy> don't bother him, he's doing a patch forme!
17:23:46 <glguy> :)
17:24:02 <dons> emk, yeah? quick!
17:24:08 <emk> dons: Thanks for your help last night! I'm writing up a bunch of read and show functions for ByteString, and will try to upload a package.
17:24:15 <dons> cool
17:25:19 <glguy> ok, sorear wins ;)
17:25:58 <slowriot> I'm still having problems with the io list stuff.
17:26:14 <slowriot> mind if I paste some code?
17:26:19 <sorear> !paste
17:26:20 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
17:26:38 <slowriot> what's that?
17:26:43 <sorear> @paste is slightly outdated ATM - address is valid but excessively long
17:26:44 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
17:26:49 * glguy brb
17:27:22 <slowriot> cases = (do cols <- getLine; chars <- getLine; return (read cols, read chars)) : cases						
17:27:22 <slowriot> solveCases list = do (next:rest) <- list;
17:27:22 <slowriot> 					 solveCase (do next);
17:27:22 <slowriot> 					 solveCases rest;
17:27:24 <slowriot> crap
17:27:25 <shapr> ooh, I should check the bandwidth usage on my server.. I wonder if it's gone way up from the pasting.
17:27:26 <sorear> slowriot: go to the site, paste your code, it temporarily webhosts the code so we don't have to keep scrolling our IRC windows to see it.
17:27:32 <hpaste>  slowriot pasted "io list" at http://hpaste.ath.cx:8000/37
17:27:45 <slowriot> pasted to the wrong place :)
17:27:50 <sorear> also hpaste likes tabs more than irssi
17:27:51 <sorear> 17:24 < slowriot> IIIII solveCases rest;
17:28:37 <sorear> slowriot: NEVER set 4-column tabs
17:28:49 <sorear> also the ; are redundant
17:28:53 <bd_> :t group
17:28:55 <lambdabot> forall a. (Eq a) => [a] -> [[a]]
17:29:02 <mauke> there's nothing wrong with 4-column tabs
17:29:06 <sorear> slowriot: Haskell tabs are 8-column
17:29:33 <slowriot> yeah, someone reccomended that I use spaces instead of tabs
17:29:35 <gotaku> I need an older version of GHC to build a new version correct?
17:29:53 <sorear> no, the same version works fine
17:30:01 <sorear> newer versions won't however
17:30:02 <shapr> gotaku: It takes the least time to install an already built binary. Is that an option?
17:30:24 <slowriot> case = was all on one line... are you sure the ; are redundant?
17:30:26 <sorear> slowriot: tabs are safe as long as you remember they are 8 spaces
17:30:33 <slowriot> (I know, I know... that line is too long)
17:30:34 <gotaku> Ubuntu only has 6.4
17:30:37 <hpaste>  bd_ annotated "io list" with "something like this?" at http://hpaste.ath.cx:8000/37#1
17:30:41 <slowriot> I haven't quite gotten used to haskell's indentation yet
17:31:14 <daniel_larsson> gotaku: You can use debian packages
17:31:46 <daniel_larsson> gotaku: Also, ubunto 7.04 has 6.6 if you don't mind running test releases
17:31:54 <hpaste>  bd_ annotated "io list" with "lazy version" at http://hpaste.ath.cx:8000/37#2
17:32:05 <glguy> we need a "EDIT / ANNOTATE THIS PASTE"
17:32:10 <glguy> so i don't have ot copy the content over
17:32:15 <hpaste>  bd_ annotated "io list" with "fixed lazy version >.>" at http://hpaste.ath.cx:8000/37#3
17:32:32 <slowriot> bd_: yeah, that's basically what I want
17:32:33 <bd_> unsafeInterleaveIO =/= unsafePerformIO :)
17:32:50 <hpaste>  glguy annotated "io list" with "using readLn" at http://hpaste.ath.cx:8000/37#4
17:33:28 <gotaku> Where are the debian packages?
17:34:08 <sorear> glguy: I've update the todo list, added an idea of mine and removed two that are being impl'd
17:34:29 <glguy> sorear: add a function to copy an annotation into the edit box
17:34:36 <glguy> sorear: I'm going to do that later
17:35:27 <slowriot> okay, so readLn automatically calls "read" on the input
17:36:04 <glguy> readLn = readIO =<< getLine
17:36:15 <glguy> readIO reports errors to screen
17:36:18 <glguy> directly
17:36:29 <glguy> instead of through error
17:36:40 <glguy> but don't worryabout that
17:36:48 <glguy> for beginning purposes it is the same
17:36:50 <slowriot> should the last line be "map solveCase cases?"
17:37:37 <slowriot> oh
17:37:38 <glguy> slowriot: doesn't need to be
17:37:38 <slowriot> nevermind
17:38:54 <slowriot> okay, thanks to all who replied
17:39:07 <daniel_larsson> gotaku: I don't recall where I picked them up, sorry. Switched to ubuntu 7.04 since then :/
17:39:39 <sorear> dons: see the mailing list - someone's complaining about the space waste of Erlang strings, and wants to know if Haskell can do better. I've already mentioned bytestrings, but only 1 para.
17:44:25 <sjanssen> sorear: blast! you beat me by 5 min.!
17:44:31 <slowriot> why was remains <- cases necessary?
17:44:34 <nornagon> ?djinn (a -> a -> a) -> a -> a -> a
17:44:35 <lambdabot> f a = a
17:44:51 <sjanssen> sorear: my reply to that post is eerily similar to yours
17:44:54 <nornagon> ?djinn (a -> a -> b) -> a -> b -> a
17:44:55 <lambdabot> f _ a _ = a
17:45:07 <nornagon> ha.
17:45:35 <bd_> nornagon: there's no other type which can satisfy that
17:45:40 <bd_> or rather, there's no a -> a -> b
17:45:50 <bd_> unless it's an evil unsafeSomethingOrOther
17:46:07 <bd_> [const unsafeCoerce?]
17:46:17 <sorear>  @djinn-add unsafeCoerce# :: a -> b
17:46:17 <nornagon> there's no a -> a -> b?
17:46:30 <glguy> ?where hpaste-todo
17:46:31 <lambdabot> I know nothing about hpaste-todo.
17:46:55 <sorear> http://members.cox.net/stefanor/hpaste.todo
17:47:01 <hpaste>  br1 pasted "Core case" at http://hpaste.ath.cx:8000/38
17:47:22 <bd_> :t const unsafeCoerce#
17:47:24 <lambdabot> Not in scope: `unsafeCoerce#'
17:47:26 <bd_> hmph
17:47:30 <bd_> well, makes sense :)
17:47:37 <bd_> nornagon: you could constain const unsafeCoerce# to that
17:47:47 <bd_> nornagon: but, just look at the signature - that function doesn't make sense
17:48:01 <bd_> nornagon: you're saying, given two objects of ANY type, you can produce one of another type
17:48:06 <bd_> the only pure function to do this returns the bottom
17:48:19 <glguy> sorear: which two were being implemented already?
17:48:22 <nornagon> *nod*
17:48:25 <bd_> @djinn a -> b
17:48:26 <lambdabot> -- f cannot be realized.
17:48:35 <sorear> glguy: port 80, Host: multiplexing
17:48:41 <glguy> oh, right
17:48:54 <bd_> nornagon: in short, you can't just create values out of thin air :)
17:49:03 <nornagon> right.
17:49:17 <sorear> undefined!
17:49:35 <bd_> That's the bottom :)
17:49:36 <sorear> _|_ :: a
17:49:44 <bd_> and as everyone knows, _|_ _ = _|_ :)
17:49:55 <hpaste> debugFilter off
17:50:21 <bd_> hmm
17:50:40 <bd_> > ((undefined :: Int -> Int -> Int) 0) `seq` 0
17:50:41 <lambdabot>  Undefined
17:50:47 <sorear> but _|_ /= \_ -> _|_
17:51:04 <bd_> sorear: quite :)
17:51:23 <augustss> but it should be
17:51:31 <augustss> equal
17:54:06 <Procyon> :t sqrt gives me "Floating" as a typeclass, but why doesn't it work if I have a data Val = Int Integer | Real Floating ? and how do I do what it's obvious I'm trying to do?
17:54:08 <lambdabot> parse error on input `,'
17:54:56 <augustss> Procyon: it's not obvious to me
17:55:36 <sorear> Procyon: data objects don't have default typeclasses
17:55:48 <augustss> Procyon: I'm assuming you're trying sqrt on Val.  What would you like to happen for the Integer?
17:55:56 <sorear> Procyon: if you want your variant to act like a number, you'll have to instance it yourself
17:56:18 <Procyon> augustss:  I'm writing a little interpreter.  I want a datatype that contains whether a token is an Atom, Number, List, etc... Int Integer works fine, but Real Floating fails me
17:56:34 <allbery_b> you can't use a class as a type.  data Floating a => Val = VInt Integer | VReal a -- might wrk
17:56:57 <allbery_b> not sure if you'd need to delve into GADTs to get that kind of control
17:57:10 * allbery_b is not quite clear on what you can get away with in H98 declarations
17:57:38 <augustss> Procyon: Maybe you want ... | Real Double
17:57:59 <Procyon> allbery: hmm.  so no simple way to constrain the constructor param to a float type, even though there exists a simple way to do it to ints, string and bools??
17:58:08 <augustss> allbery_b: I think your version is overly general
17:58:40 <augustss> Procyon: there's no simple way to restrict it to an Integral type
17:58:48 <Procyon> Real Double worked.  Thanks.
17:58:49 <allbery_b> probably
17:59:34 <augustss> Procyon: ok, so now I understand what you were trying to do :)
17:59:46 <Procyon> augustss:  data Val = Int Integer -- constrains the Int constructor to Integer, or am I all confused?
17:59:59 <kpreid> Procyon: Integer is a type. Floating is a type class.
18:00:12 <kpreid> Procyon: Float and Double are types, too.
18:00:26 <augustss> Procyon: yes, it makes it an Integer.  But there are other integral types in Haskell, like Int
18:00:45 <augustss> But Integer is a good choice
18:01:10 <augustss> And Double is a reasonable choice.  Maybe Rational, depending on what you want to do.
18:02:00 <Procyon> Is there a type anagolous to "Number" which contains all these types?  I'm not so sure I will be needing to differenciate on numbers in my interpreter, so implementing a very general type here might do me good.
18:02:28 <glguy> ?src num
18:02:29 <kpreid> no.
18:02:30 <lambdabot> Source not found. That's something I cannot allow to happen.
18:02:34 <glguy> oops
18:02:43 * glguy doesn't know what is being discussed and stays quiet ;)
18:03:13 <kpreid> Procyon: Pick the types with the best ranges for each kind of number...
18:03:15 <augustss> Procyon: There's no official Number type.  But I have an implementation somewhere.
18:03:29 <augustss> Called NoddyNumber
18:03:41 <sorear> Procyon: we have true reals, those supertype almost everything
18:04:10 <Procyon> ok... and matching on typeclass is not allowed, only type, correct?
18:04:29 <kpreid> Procyon: take as many of this list as you care to: Integer, Double, Ratio Integer, Complex Double
18:04:31 <sorear> ANN: lambdabot code loads in shim!
18:04:41 <glguy> what is shim?
18:05:15 <sorear> glguy: haskell-mode, only better.
18:05:27 <sorear> glguy: C-c C-t - autoinsert type signatures , etc
18:05:33 <nornagon> shim?
18:05:40 <nornagon> emacs people :(
18:05:47 <Procyon> sorear: what is the true real type and is it in the standard prelude?
18:06:12 <sorear> Procyon: it can store any real number you can construct, and no.
18:06:27 <sorear> sqrt(2) exactly, etc.
18:06:32 <Cale> sorear: oh?
18:06:39 <sorear> not just algebraics.
18:06:50 <sorear> Cale: reals | shim ?
18:06:52 <Cale> What's your representation?
18:07:14 <sorear> Cale: I didn't write any of them, mostly signed binary
18:07:38 <sorear> ... infinite lazy lists of digits
18:07:48 <Cale> okay
18:07:57 <Cale> Yeah, that's still not all reals of course.
18:08:05 <Procyon> sorear: so if you used that and did a show & sqrt 2, you get an infinite loop?
18:08:06 <sorear> Cale: it's like weak direct sums.
18:08:09 <augustss> Cale: that depends on your beliefs :)
18:08:23 <Cale> No, just on the definition of the real numbers
18:08:28 <sorear> Cale: sure it's missing elements, but it doesn't matter since all the elements you can construct exist
18:08:58 <augustss> Procyon: the standard show only shows a finite number of decimals, but you could have one that shows all
18:09:51 <Procyon> interesting.  I think I'll stick to Integer and Double for now, but I might have to check that library out.
18:10:05 <augustss> Procyon: using real numbers can be slow
18:10:26 <Cale> You can use Rational
18:10:28 <augustss> So Integer and Double are not too bad
18:10:39 <sorear> Haskell taught me one thing.  Speed is not important.
18:10:49 <Cale> which is arbitrary precision rationals, and that's more than you'll ever actually need for any physical application.
18:10:50 <augustss> Rational lacks a lot of functions in the standard libs
18:11:23 <Cale> Well, you can't take square roots and such of course.
18:11:25 <Procyon> augustss: right, I would assume that infinite precision reals are slow.
18:12:11 <emk> Does anyone know what Data.ByteString.Base.createAndTrim' is supposed to do?
18:12:14 <Cale> Still, you could write your own approximations to those functions, which get you within any desired epsilon fairly simply.
18:12:18 <sorear> emk: yes
18:12:28 <sorear> emk: bos, dons
18:12:33 <sorear> emk: bos, dons, sorear(?)
18:12:36 <emk> sorear: With the prime?
18:12:45 * sorear looks at source
18:12:56 <emk> The regular version is documented, but the prime version isn't.
18:13:23 <augustss> Cale: there are nice libraries for those, just not in the standard dist
18:13:34 <sorear> emk: ' is more flexible
18:14:27 <sorear> createAndTrim mx f = createAndTrim' mx (\p -> (0, f p, ())) >>= return . fst
18:14:33 <emk> sorear: I'm trying to find a function which will let me call snprintf repeatedly, until I guess a large enough value of N...
18:15:15 <emk> I'm trying to write some portable show functions for ByteString...
18:15:21 <sorear> emk: createAndTrim' is wanted then
18:15:27 <emk> Figured.
18:15:46 <sorear> emk: the source explains all, in its differences
18:15:55 <sorear> http://darcs.haskell.org/ghc-6.6/packages/base/Data/ByteString/Base.hs
18:15:59 <lambdabot> http://tinyurl.com/2zc826
18:16:02 <emk> Ah, thanks for the URL!
18:16:17 <emk> sorear: I was working from Haddock output...
18:16:27 <sorear> while you're there, how about adding haddock comments and sending a patch?
18:17:41 <sorear> hint: return a Bool as aux return (was-it-successful)
18:19:25 <emk> sorear: Actually, I think I need to pass out the corrected N, and then call my wrapper recursively with a large buffer size. But I think I can get this to run now.
18:19:26 <emk> Thanks!
18:20:10 <Procyon> thanks all
18:21:00 <sorear> emk: you mean snprintf is nice enough to tell you how big a buffer it needs? nice.
18:21:29 <sorear> nice. (reads man)
18:21:38 <emk> sorear: Actually, it depends on the platform. Some return -1, and let you keep guessing, and others tell you how many bytes they wanted to write.
18:21:56 <sorear> joy
18:21:57 <emk> sorear: You've got to handle both %(*#%&! cases in portable code.
18:22:29 <jcreigh> we need sjustmallocitformeiwillremembertofreeitokayprintf()
18:22:52 <emk> And then there's the occasional ancient system which just overflows the buffer anyway, and lets itself get rooted, because it aliased snprintf to sprintf. *gag*
18:22:54 <sorear> jcreigh: we have it
18:23:05 <sorear> jcreigh: man asprintf
18:23:25 * emk bangs head on table
18:23:26 <sorear> jcreigh: of course like all useful libc functions it's a gnu extension
18:23:43 <jcreigh> sorear: hey, cool, I didn't know about that.
18:27:19 <chessguy> you mean -1 isn't a buffer size?
18:32:40 <newsham> (size_t)-1 is definitely a buffer size
18:33:02 <sorear> you sure it isn't a parse error?
18:33:21 <jcreigh> sometimes I wonder what it was like on the ANSI C committee: "Naw, that would be too hard to implement. Pass the donuts."
18:34:17 <chessguy> ?remember jcreigh sometimes I wonder what it was like on the ANSI C committee: "Naw, that would be too hard to implement. Pass the donuts."
18:34:18 <lambdabot> Done memoising quote for `jcreigh', if that is their real name...
18:35:24 <sorear> wow, glguy seems to have discovered small records
18:35:34 <glguy> ?
18:35:51 <glguy> dons is submitting
18:35:58 <glguy> but I am trying to make one patch per feature now
18:36:25 <glguy> Trying to move out of "initial import" phase
18:38:56 <sorear> I see admin[+-] made it into hpaste much faster than lambdabot.
18:39:19 <sorear> lambdabot was here for 5 years before I added @admin [+-}
18:39:46 <dons> :)
18:40:06 <sorear> obviously, it is more useful in hpastebot :)
18:40:12 <dons> 'cause we're a diheh
18:40:23 <dons> blah blah
18:40:36 <dons> hpaste starts up nice and fast
18:40:52 <sorear> compared to what, lambdabot ?
18:41:01 <dons> yeah ;)
18:41:18 <sorear> focus on fixing hs-plugins!
18:41:25 <sorear> then I'll add DEMAND LOADING!
18:41:29 <sorear> Muahahahaha!
18:41:43 <sorear> Lazy startup, yeah!
18:41:53 * emk writes his own version of createAndTrim'
18:41:55 <dons> you fix it!
18:42:06 <dons> i've got blog articles to write!!
18:42:48 <dons> :P
18:44:01 <glguy> sorear: I added the admin commands so someone else could !quiet the bot
18:44:20 * sorear checks logs, robreim has taken baton I see
18:47:21 <sorear> @users
18:47:22 <lambdabot> Maximum users seen in #haskell: 321, currently: 282 (87.9%), active: 47 (16.7%)
18:47:31 <sorear> when'd that happen?
18:48:38 <dons> a couple of hours ago
18:48:41 <dons> hmm, about 5
18:49:54 <robreim> baton what what?
18:51:30 <sorear> robreim: person responsible for the fact hs-plugins doesn't work on >=6.6
18:52:23 <robreim> Haha. Well I can't be held responsible until someone explains to me what actually needs to be done :P
18:52:41 <robreim> I know of the vague ".hi format has changed" but I have no idea how it's changed or where to start looking.
18:53:23 <sorear> find bug, fix, repeat.
18:53:35 <sorear> beyond that I don't know either.
18:53:53 <bd_> mfix (\app -> findBug app >>= fixBug)
18:54:20 <glguy> mfix only runs the action once though...
18:54:27 <robreim> just a .hi spec or description or generation source code location would do.
18:54:51 <bd_> glguy: true, but it'll only converge on a bug-free program :)
18:55:00 <bd_> and, well, crashing with <<loop>> is a bug, after all.
18:55:26 <hpaste> !paste hpaste, now with 50% fewer diff forms
19:11:26 <dons> ?users
19:11:26 <lambdabot> Maximum users seen in #haskell: 321, currently: 283 (88.2%), active: 41 (14.5%)
19:25:52 <glguy> sorear: ?
19:26:01 <sorear> !
19:26:04 <sorear> glguy: !
19:26:36 <glguy> For the "annotation from here" feature... do you have an opinion on the interface?
19:26:45 <glguy> one link next to each paste?
19:26:50 <glguy> a form at the bottom?
19:27:55 <glguy> I'm thinking about pushing the "plain text" and "link to paste" links to their own line
19:27:57 <glguy> and adding it threre
19:28:57 <sorear> glguy: ? plain text and link to original are on separate lines
19:29:22 <glguy> :-p
19:29:30 <sorear> but adding a annotate-based-on link would make sense in that group
19:30:16 <sorear> it might be prudent to put Pragma: no-cache on the list page
19:30:33 <glguy> an HTML pragma?
19:30:40 <glguy> (is that a META tag)?
19:30:44 <sorear> HTTP
19:30:48 <glguy> oh, ok
19:30:50 <glguy> setHeader stuff
19:31:16 <glguy> setHeader "Pragma" "no-cache" ?
19:31:33 <sorear> I think so
19:32:04 <sorear> also prettier HTML would be nice :)
19:32:18 <glguy> you mean not all on one line?
19:32:19 <sorear> but I think that's more of a xhtml feature
19:32:22 <sorear> yea
19:32:48 <sorear> HughesPJ to the rescue!
19:33:14 <glguy> yeah, i just change from render to show
19:33:58 <beschmi> morning #haskell
19:33:59 <lambdabot> beschmi: You have 1 new message. '/msg lambdabot @messages' to read it.
19:34:03 <sorear> hpaste needs a brag page
19:34:06 <sorear> morning
19:35:06 <sorear> beschmi: with the help of some symlink-fu shim works on lambdabot.  Very slowly.
19:35:41 <sorear> it doesn't help that dons insists on putting a type signature on everything shim will consent to tell me the type of :)
19:36:13 <bd_> ?where shim
19:36:13 <lambdabot> I know nothing about shim.
19:36:31 <bd_> What's this shim thing? :)
19:36:48 <beschmi> @where shim shim.beschmi.de
19:36:49 <lambdabot> I know nothing about shim.
19:36:53 <sorear> stefan@stefans:/usr/local/src/shim$ cat _darcs/prefs/repos
19:36:53 <sorear> http://shim.beschmi.de/shim
19:36:56 <lambdabot> Title: Index of /shim
19:37:05 <sorear> beschmi: @where+
19:37:20 <beschmi> @where+ shim shim.beschmi.de
19:37:21 <lambdabot> Done.
19:37:26 <beschmi> sorear: thanks
19:37:40 <bd_> ah. neat
19:37:49 <beschmi> sorear: what do you mean by split-dirs setup?
19:38:24 <sorear> beschmi: lb-sorear (contains _darcs), test-lb-sorear (contains dist)
19:38:45 <sorear> lambdabot is evil enough to spontaneously write to files managed by darcs
19:38:59 <sorear> I don't want to record a patch modifying the State/ files
19:39:12 <sorear> so I separate the running from the recording.
19:39:13 <beschmi> ah, i see
19:39:50 <beschmi> so it can't find BotPP
19:40:00 <sorear> correct
19:40:07 <sorear> symlink-fu made it work
19:40:30 <sorear> this is a "bug" in lambdabot
19:41:43 <beschmi> @where+ shim http://shim.beschmi.de/
19:41:44 <lambdabot> Done.
19:43:50 <glguy>     liftM (liftM $ liftM (setHeader "Pragma" "no-cache")) $
19:43:50 <glguy>       ok html (val (listEntriesPage entries t)) () ()
19:43:57 <glguy> at some point you find yourself wondering
19:44:02 <glguy> "what am I doing wrong here"
19:46:04 <TomMD> How does one go about getting a new TypeRep Key # for making an instance of Typeable?
19:46:37 <sorear> TomMD: one doesn't
19:46:43 <sorear> TomMD: deriving(Typeable)
19:46:47 <TomMD> Damn, then I am a bit messed up.
19:46:55 <TomMD> OK, that makes it even easier!
19:47:14 <sorear> TomMD: if you absolutely must, look in Data.Typeable for the standard instances
19:47:24 <TomMD> Roger, thanks.
19:47:37 <sorear> TomMD: be careful, instance Typeable where carelessness + cast = unsafeCoerce#
19:48:39 <TomMD> It is a very simple use case: I just want to throw a dynamic exception to a thread which I am using as a regular event manager (need to expire a record? ok, just put it in the event list, the manager will wake at the right time and do the a -> IO () )
19:50:37 <glguy> sorear: Pragma: no-cache      is now sent in the headers for the list page (on live)
19:50:45 <glguy> I don't know if that specific header is right
19:50:48 <glguy> but its there
19:52:30 <allbery_b> actually that's the old HTTP/1.0 nonstandard extension
19:52:38 <jcreigh> Cache-Control: no-cache is probably the "right" way to do cache-hinting like that.
19:52:40 <allbery_b> HTTP/1.1 uses Cache-Control: no-cache
19:52:54 <glguy> ok, I'll fix that :)
19:52:58 <allbery_b> (or other settings which let you fine tune things if you really want)
19:53:02 <glguy> "Cache-Control" "no-cache" right?
19:53:09 <allbery_b> yeh
19:53:40 <allbery_b> might be worth sending both, although I hope nobody's still using HTTP/1.0
19:53:53 <glguy> if they are, they can stand to hit refresh
19:53:54 <allbery_b> BITD one had to send both to cover all the bases
19:54:04 <glguy> BITD?
19:55:11 <allbery_b> "back in the day"
19:55:15 <glguy> ohh
19:55:39 * allbery_b managed a web farm in the mid-80s, funfunfun
19:55:49 <allbery_b> sorry mid90s
19:55:56 * allbery_b can type, really *thwaps finfers*
19:57:17 <sorear> wasn't the web, like, only implemented in '91? :)
19:58:03 * allbery_b was managing a public access xenix box in the mid 80s.  web?  we barely had uucp back then :)
19:58:38 <shapr> The web wasn't really popular till 93 or so.
19:58:44 <shapr> At least, that was my perception.
19:59:20 <sorear> The web has been popular for as long as I've had a functioning memory. *sigh*
19:59:44 <Nafai> Hi shapr!
19:59:55 <shapr> My functioning memory starts before the Sinclair Spectrum I played with at age 11 or 12
19:59:57 <shapr> hiya Nafai
20:00:15 <shapr> sorear: Hey, you found Haskell long before you reached my age :-)
20:00:29 <shapr> Nafai: How's code?
20:00:50 <JKnecht> sorear I presume is 16
20:01:16 <sorear> just barely
20:01:19 <Nafai> shapr: Lemme see...Java at work, a bit of Python and shell at home.  Haven't found a use to get into Haskell just yet :(
20:01:37 <JKnecht> that was a pretty good call I think
20:01:40 <shapr> Nafai: aww
20:02:40 <Nafai> Yeah, I know :(
20:03:23 <shapr> Parsers are a good way to start.
20:03:24 <emk> The c-sources field in Cabal hates me.
20:03:54 <sorear> join the club
20:03:56 <emk> It seems to be completely ignored.
20:04:08 <emk> Which is strange, because it works fine for other packages on my system.
20:04:29 <sorear> I spent hours fighting with it for the 7 lines of C in vty
20:05:11 <sorear> Ultimate cabal trickery: VVV
20:05:12 <sorear> C-Sources:           gwinsz.c
20:05:12 <sorear> Include-Dirs:        .
20:05:12 <sorear> Install-Includes:    gwinsz.h
20:06:15 <Nafai> shapr: It's more of I haven't found a practical project that I "need" immediately that Haskell would be a good fit for
20:06:36 <Nafai> shapr: For example, this weekend I used Python to re-write the script I use to post things to my blog
20:06:46 <sorear> who cares about practical ... who needs lambdabot ...
20:07:03 <sorear> Haskell is IME fairly good for small scripty stuff
20:07:10 <LoganCapaldo> See you should've used Haskell to write that script :)
20:07:22 <sorear> I've had use for 'main = interact $ unlines . concatMap tails . lines'
20:07:35 <sorear> as sorear-Perl that was 8 lines
20:07:46 <sorear> as bytestringy haskell it was IO bound
20:09:43 <Nafai> I don't know that I could have easily written this: http://www.pastebin.ca/325357 in Haskell
20:11:14 * glguy looks at the link with disdain ;)
20:11:42 <Nafai> glguy: Cause it's not haskell?
20:11:52 <glguy> cause it's pastebin.ca ;)
20:11:55 <allbery_b> it's nt hpaste :)
20:11:56 <mbishop> because you didn't use his paste system :P
20:12:05 <glguy> it's not his paste though (I don't think)
20:12:10 <mauke> sorear: perl -nle '$s=$_; print substr($s, $_) for 0 .. length $s'  # 8 lines?
20:12:52 <Nafai> Oh, d'oh.
20:13:10 <Nafai> Sorry, I had forgotten about hpaste :(
20:13:16 <Nafai> I'm just used to using the other
20:14:11 <hpaste> hpaste, now with 30% "annotate this text" functionality
20:14:16 <glguy> more^
20:14:22 <lispy> hpaste?
20:14:25 <lispy> i want a demo
20:14:30 <glguy> !paste
20:14:31 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
20:14:38 <glguy> kind of a self guided tour atm
20:14:57 <emk> Is there any documentation anywhere on setting up unit tests with Cabal?
20:15:07 <lispy> can we get more contrasty colors?
20:15:12 <lispy> i have a hard time reading it
20:15:17 <beschmi> @where cabal-test
20:15:17 <lambdabot> http://darcs.haskell.org/~lemmih/cabal-test
20:15:27 <glguy> artistic concerns can presently be directed to dons
20:15:29 <bd_> mauke: import qualified Data.ByteString.Lazy.Char8 as BS; main = mapM_ (\line -> mapM_ BS.putStrLn $ BS.inits line) =<< liftM BS.lines BS.getContents ?
20:15:42 <bd_> if I understand that perl one-liner anyway
20:15:45 <LoganCapaldo> lispy, Isn't that a job for userContent.css? ;)
20:15:45 <lispy> dons: !!! more contrast on hpaste please !!!
20:15:58 <sorear> bd_: mauke was replying to me!
20:15:59 <lispy> LoganCapaldo: sounds good
20:16:07 <sorear> bd_: repeating for you
20:16:16 <sorear> I've had use for 'main = interact $ unlines . concatMap tails . lines'
20:16:32 <sorear> bd_: please do not ignore interact.
20:16:36 <bd_> oh
20:16:37 <dons> lispy: on the syntax highlighting?
20:16:39 <bd_> nevermind then :)
20:16:40 <sorear> there's a bytestring version too
20:16:42 <lispy> dons: aye
20:16:44 <dons> ok.
20:16:55 <beschmi> emk: cabal-test looks for properties in all your files and runs them with parallel quickcheck
20:16:59 <lispy> dons: lavender on white is not easy for me to read :(
20:17:23 <glguy> is there anyone where who doesn't understand the abbreviations "min" "hr" "d" instead of "3 hours ago"
20:17:25 <emk> beschmi: Thanks! I'll take a look.
20:17:32 <glguy> or "m" "h" "d"
20:17:35 <lispy> dons: otherwise, it's very cool
20:17:52 <shapr> glguy: You could have alt text for backup on those?
20:17:55 <lispy> is it a hope app?
20:18:01 <shapr> It's a HAppS app.
20:18:02 <glguy> shapr: <acronym> ?
20:18:26 <glguy> what's the other one aside from acronym
20:18:38 <shapr> abbreviation?
20:18:48 * glguy check the tags list
20:19:16 <dons> ?uptime
20:19:16 <lambdabot> uptime: 1d 3h 9m 42s, longest uptime: 2d 3h 42m 19s
20:19:25 <dons> glguy: ^^ another format
20:19:38 <glguy> !id uptime: 23 minutes
20:19:39 <hpaste> uptime: 23 minutes
20:19:52 <glguy> err
20:20:07 <glguy> !id uptime: 5 minutes
20:20:07 <hpaste> uptime: 5 minutes
20:21:02 * glguy finds <abbr>
20:21:30 <lispy> dons: <SiR> uptime: 1m 2d 20h 45m 57s, longest uptime: 1m 2d 20h 45m 57s
20:21:49 <lispy> dons: i think i'm over due for an upgrade :)
20:22:09 <dons> 15:18  lambdabot> uptime: 2m 25d 2h 49m 21s, longest uptime: 2m 25d 2h 49m 21s
20:22:11 <dons> ;)
20:22:56 <lispy> nice!
20:23:16 <lispy> what is silent?
20:23:23 <lispy> no notification to #haskell?
20:23:26 <sorear> lambdabot & su -c 'date -s 'now + 2 months
20:23:26 <glguy> right
20:23:32 <glguy> verbose is the oposite
20:23:34 <sorear> lambdabot & su -c 'date -s "now + 2 months"' ; uptime
20:24:15 <glguy> sorear: wrong virtual console...
20:24:17 <glguy> ;)
20:24:41 <sorear> !whatsnew
20:24:56 <sorear> !exec darcs changes | head -3
20:25:31 <sorear> !id Fool!
20:26:05 <glguy> * annotate from here and list format change
20:26:11 <glguy>  * fix no-cache header name
20:26:23 <glguy>  * Use nicer syntax highlighiting colours, and set stylesheet as a config value
20:27:02 <sorear> !uptime
20:27:09 * glguy offers up a karma to the person that first identifies which comment was not made by glguy
20:27:22 <glguy> 3 minute uptime now
20:28:02 <sorear> darcs pull says all three were emertens, nice try.
20:28:18 <glguy> tsk tsk, closer inspecting shows I skiped #3
20:28:21 <glguy> because it was a dup
20:29:34 <glguy> "annotate this text" is actually the first feature that I really wanted that lisp.paste.org didnt' have
20:29:43 <glguy> that I wanted when I would use paste.lisp
20:30:00 <glguy> (but i forgot about that until just now)
20:30:22 <dons> glguy: the 3rd comment
20:30:28 <glguy> dons++
20:30:34 <glguy> it was your comment though
20:30:38 <dons> :)
20:30:44 <glguy> so that is borderline cheating ;)
20:31:00 <dons> well, i don't see that in the rules!
20:31:07 <glguy> *borderline*
20:31:15 <glguy> we have an honor policy
20:31:18 <glguy> ;)
20:32:00 <emk> Is cabal really going to force me to build and install a test program if I use "c-sources"?
20:32:18 <sorear> emk: no
20:32:33 <csci> !aste
20:32:35 <csci> !paste
20:32:36 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
20:32:41 <emk> sorear: Well, I can't figure out how to get it to build an executable and leave it uninstalled.
20:33:14 <emk> I can't run my test harness with runhaskell, because it won't pick up the c-sources automatically.
20:34:21 <hpaste>  csci pasted "Small IO monad problem" at http://hpaste.ath.cx:8000/39
20:34:22 <emk> These tools do not fit together nicely for me once C sources get involved. :-(
20:34:42 <csci> Hi, it would be really nice if someone could help me with my problem posted by hpaste
20:34:56 <emk> I just want cabal to build an extra exe and leave it lying in the build directory.
20:35:38 <sorear> @where vty  <-- successful if extremely voodoo attempt to make cabal build a library with c sources
20:35:38 <sorear> emk: don't run install :)
20:35:38 <sorear> @bot
20:35:38 <sorear> lag sucks, I'm going back to homework
20:35:39 <lambdabot> http://members.cox.net/stefanor/vty/
20:35:39 <lambdabot> :)
20:35:44 <LoganCapaldo> csci, theres no reason to use filterM there
20:36:23 <csci> (<- beginner haskell user) so what Do you suggest?
20:36:27 <emk> sorear: OK, as long as there isn't some secret that everybody else knows which I'm missing. Thanks!
20:36:28 <hpaste>  glguy annotated "Small IO monad problem" with "no filterM" at http://hpaste.ath.cx:8000/39#1
20:36:42 <LoganCapaldo> csci: let only = filter (\(x:xs) x /= ".") list
20:36:59 <sorear> glguy: Hpaste needs a brag list.
20:37:14 <beschmi> filter (/=".") list
20:37:14 <csci> LoganCapaldo and glguy: Oh, Thanks.
20:37:28 <glguy> sorear: to explain why its different than the other services?
20:39:27 <hpaste> My ROFLCopter goes "soi soi soi soi soi soi soi soi soi soi"
20:41:36 <Korollary> glguy: the diff view is a bit hard to read. Perhaps the + and - should be in black.
20:42:03 <glguy> Korollary: maybe. my idea was that if you had colors, you didn't really need the symbols
20:42:12 <glguy> and if you didn't have colors, you'd still know what was going on
20:42:23 <glguy> with white the symbols became part of the colored bar
20:42:39 <Korollary> glguy: well, at least you ought to show that pink stands for -.
20:42:57 <Korollary> then you can drop the signs, yes.
20:43:09 <glguy> the signs are needed for sorear especially
20:43:16 <Korollary> The page also needs ajax and google checkout. And some flash.
20:43:27 <glguy> not as likely
20:43:48 <Korollary> is sorear a lynx user?
20:43:48 <glguy> I could add white box headers
20:43:59 <glguy> with a pink one and the from TITLE
20:44:05 <glguy> and a green one with the to TITLE
20:44:11 <sorear> elinks, get your forks straight! :)
20:44:18 <Korollary> holy cow, kiddo.
20:44:19 <glguy> like the boxes for nick, title, and ago
20:44:28 <glguy> hpaste is elinks approved
20:44:42 <csci> Beginner question: Could we say, that in "var <- some IO function" the arrow "removes" the IO type? (kind of)
20:44:42 <glguy> part of the unwritten charter
20:44:53 <mauke> csci: yes
20:45:01 <csci> mauke: Thanks
20:45:15 <sorear> Korollary: /me is trying to exxagerate his Console-User Persecution Complex
20:45:18 <mauke> csci: do you know any other programming language?
20:45:35 <csci> mauke: Some, Ruby, Java, C, bit of Scheme, Perl, C++
20:46:01 <csci> mauke: But "getting" the concept of monads is quite difficult ;-)
20:46:03 <mauke> heh, then why don't you start by understanding the IO system and working your way up to syntactic sugar like "do"?
20:46:34 <Korollary> up front investment like that saves a lot of confusion.
20:46:50 <LoganCapaldo> @undo do { x <- y; return x }
20:46:50 <mauke> you don't even need monads to understand IO in haskell
20:46:50 <lambdabot> y >>= \ x -> return x
20:46:51 <csci> Sounds quite good, will take a look at the wiki
20:47:13 <mauke> here's how it works: haskell itself is pure, so it can't do any IO
20:47:18 <csci> jup
20:47:45 <mauke> instead you build a data structure that describes the IO actions you want to perform, then let the runtime system interpret that structure
20:48:09 <csci> quite clear till here
20:48:21 <mauke> and the only way to do that is to bind it to the main symbol, because that's what's really executed
20:48:35 <csci> hmm, sounds reasonable
20:48:55 <sorear> Monads are just a way of letting the same functions (sequence, filterM, etc) work on a wide variety of abstractions.  just like Num lets you use the same functions on a variety of number types.
20:48:56 <LoganCapaldo> IO a is sort of like ([list of things to do], a)
20:49:00 <mauke> so all your program does is compute an "IO program" and return it to the haskell runtime, which then interprets it
20:49:19 <mauke> (note: this explanation isn't completely true, but it's very useful IMHO)
20:49:27 <csci> ahh, the last sentence is great!
20:49:37 <Korollary> many wonderful wonderful monad tutorials on the web
20:49:39 <mauke> it's just a mental model
20:49:46 <LoganCapaldo> so putStrLn "Hello" might return ([preceeding IO actions, print the string "Hello\n"], ())
20:49:55 <csci> Korollary: but also many quite bad ones ;-)
20:49:58 <LoganCapaldo> He said, oversimplifying
20:50:09 <Korollary> I actually didnt see a bad one.
20:50:13 <sorear> data O x = O [Action] x
20:50:17 <mauke> csci: next step: the building blocks of doing stuff
20:50:20 <csci> Korollary: depends on the viewer, I think :)
20:50:36 <Korollary> There's this army of haskell fanatics who find unjust words said about haskell and storm with elaborate comments.
20:50:36 <sorear> I is a wee bit more complicated, but still easy because haskell is higher-order
20:51:01 <csci> mauke: and by doing and <- I tell the system to execute the IO functions I've concatenated before?
20:51:09 <mauke> ignore <- for now
20:51:10 <sorear> csci: not at all
20:51:16 <sorear> csci: ignore do
20:51:27 <csci> ok
20:51:30 <mauke> csci: putChar is a function that takes a Char and returns an action that prints the char (when executed)
20:51:40 <sorear> csci: do and >>= just build bigger io actions from smaller io actions
20:51:55 <mauke> >> is a function that takes two actions and returns a compound action that performs them in order
20:52:12 <sorear> >>= is a higher order function more useful with input
20:52:17 <mauke> so: main = putChar 'h' >> putChar >> 'i' >> putChar '\n' -- prints "hi\n"
20:52:26 <sorear> mauke: exactly.
20:52:36 <csci> ok
20:52:38 <sorear> oops, got confused who was asking what ?
20:52:39 <sorear> oops, got confused who was asking what :)
20:52:53 <csci> *g* I'm still following ;-)
20:53:01 <sorear> csci: you can abstract this stuff of course.
20:53:07 <mauke> next step: input/reading stuff from the outside
20:53:16 <sorear> csci: return () does nothing, you know foldr, so:
20:53:26 <sorear> sequence_ = foldr (>>) (return ())
20:53:32 <sorear> performs a LIST of actions.
20:53:46 <sorear> main = sequence_ [ putChar 'h', putChar
20:53:48 <sorear> ... ]
20:53:56 <mauke> so far all we've done is to tell the system to perform actions for us, but we also need to handle input somehow
20:53:58 <csci> yes, ok
20:54:14 <csci> (to both ;-)
20:54:21 <mauke> getChar is a constant action that (when executed) reads a character and returns it
20:54:33 <mauke> (note: getChar isn't a function in Haskell)
20:54:39 <sorear> this is where things get a bit more complicated ... IO needs to be a continuation passing monad (to still be pure)
20:55:26 <sorear> main = getChar >>= putChar  -- echo a character
20:55:30 <mauke> (>>=) :: IO a -> (a -> IO b) -> IO b
20:56:00 <sorear> so it bundles an action, with somehing to do after we have the result, and returns a combined action.
20:56:12 <csci> yes
20:56:18 <sorear> follow?
20:56:19 <mauke> >>= takes an action m and a function f, and returns an action that (when executed) performs m, applies f to the result of that, then returns the result of running f's result
20:56:42 <csci> quite clear till now
20:57:02 <mauke> it's a bit weird because our data structure now contains a callback into haskell land
20:57:07 <sorear> this is higher order trickiness, we need to make sure you get it before going on...
20:57:33 <mauke> this callback can return any IO action it wants, and that determines what happens next
20:57:57 <csci> I think :) I got it
20:58:04 <sorear> main = getChar >>= \ch -> if (ch == 'a') then putChar 'z' else putChar ch
20:58:19 <sorear> ^^^ that reads a character, and prints it after changing a to z
20:58:41 <csci> yes
20:58:42 <mauke> getChar >>= \ch -> putChar (if ch == 'a' then 'z' else ch)
20:58:47 <mauke> huhu
20:59:10 <mauke> but the point is you can do totally different things in the two branches
20:59:35 <mauke> oh, and we need return
20:59:36 <csci> ...as long as the functions has the correct type to use the previous result
20:59:42 <mauke> right
20:59:47 <mauke> return :: a -> IO a
20:59:59 <sorear> return makes an action that does nothing.
21:00:04 <mauke> return simply wraps a value in a no-op action
21:00:10 <csci> so why do we need it?
21:00:15 <sorear> it is useful because it simplifies the control structures
21:00:31 <csci> do you have an example?
21:00:34 <mauke> let me think, there was a very good (and simple) reason :-)
21:00:38 <sorear> @src sequence_
21:00:39 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
21:00:50 <csci> ah I see
21:01:09 <sorear> sequence_ is much more naturally expressed if we can say what the result of sequencing 0 actions is.
21:01:25 <sorear> (I hope foldr isn't obfuscating this further)
21:01:36 <csci> No, not at all
21:01:49 <mauke> csci: how about a wrapper around getChar that turns 'a' into 'z'?
21:02:03 <mauke> ok, it's a silly example but I don't think you can write it without return
21:02:13 <sorear> so, like sequence_, we can define higher-level combinators.
21:02:21 <csci> mauke: I' m not quite sure what you mean
21:02:23 <sorear> @src liftM
21:02:24 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
21:02:33 <sorear> @. undo src liftM
21:02:33 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
21:02:50 <sorear> liftM f act = act >>= \v -> return (f v)
21:02:59 <allbery_b> undo isn't smart enough t o take a function like that
21:03:01 <mauke> csci: foo = getChar >>= \ch -> return (ch == 'a' then 'z' else ch)
21:03:15 <csci> mauke: ah, ok
21:03:32 <mauke> csci: instead of 'a' -> 'z' you could also have toLower or something more useful
21:03:38 <sorear> the power of IO is that it allows you to use the full power of FP to manipulate actions.
21:03:52 <sorear> for instance sequence_ above can be combined with map to make:
21:03:55 <csci> till here everything is quite clear but lots of new information :)
21:04:04 <sorear> mapM_ f lst = sequence_ (map f lst)
21:04:17 <sorear> mapM_ :: (a -> IO ()) -> [a] -> IO (a)
21:04:26 <hpaste> Opinions from those that have them (text users may miss the color change) http://hpaste.ath.cx:8000/39/diff?from=0&to=1
21:04:28 <sorear> mapM_ is what perl calls foreach.
21:05:04 <mauke> csci: do { x } is x.  do { a; ... } is a >> do { ... }.  do { x <- a; ... } is a >>= \x -> do { ... }.
21:05:10 <sorear> it uses a function to make an action from each element of a list, and combined them in sequence.
21:05:14 <csci> Yes, looks like: With map I generate a list of actions, then executed with sequence_
21:05:40 <sorear> csci: exercise: write a function putStr :: [Char] -> IO ()
21:05:56 <sorear> you only need 1 application
21:06:06 <csci> sorear: Give me a minute ;-) Hmmm...
21:06:18 <glguy> Korollary: that means you
21:06:52 <Korollary> glguy: ?
21:07:02 <glguy> I change the diff output
21:07:10 <csci> putStr str = sequence_ putChar str ?
21:07:12 <glguy> to try to address your concerns
21:07:16 <Korollary> oh ok
21:07:37 <mauke> csci: that looks wrong
21:07:45 <csci> argh
21:07:48 <csci> ok, a second
21:07:52 <mauke> csci: sequence takes only one argument
21:07:53 <Korollary> glguy: awesommetry
21:08:29 <csci> putStr str = sequence_ (mapM putChar str) ? I generate a list of actions using mapM and execute them using sequence_ ?
21:08:40 <sorear> almost
21:08:56 <csci> ok, let me think...
21:09:01 <LoganCapaldo> drop the M :)
21:09:12 <sorear> map generates a list of actions, since putChar :: Char -> IO () is a regular function
21:09:34 <csci> Ah Yes, i don't need mapM
21:10:22 <jcreigh> putStr = mapM_ putChar
21:10:38 <mauke> yeah, since mapM_ is sequence_ + map
21:10:46 <csci> ah, ok
21:11:12 <csci> So:  let pStr s = sequence_ (map putChar s)
21:11:23 <LoganCapaldo> @type (\str -> sequence_ (map putChar str))
21:11:24 <lambdabot> [Char] -> IO ()
21:11:30 <mauke> you win the prize!
21:11:33 <csci> ;-)
21:12:06 <LoganCapaldo> You can almost check your answers with @type :)
21:12:27 <csci> That was a great explanation. Thanks to all, esp. mauke and sorear!
21:12:37 <csci> Yes, my new friend, I think ;-)
21:12:37 <mauke> { \s -> sequence_ (map putChar s) } --> { \s -> (sequence_ . map putChar) s } --> { sequence_ . map putChar } --> { mapM_ putChar }
21:13:23 <mauke> csci: note that we still haven't said anything about monads :-)
21:13:34 <sorear> csci: puzzle = getChar >>= (\ch -> if (ch == '\n') then return [] else puzzle >>= (\st -> ch:st))
21:13:42 <sorear> what does that do?
21:13:42 <csci> Yes, that's funny.
21:13:46 <nornagon> ?where vty
21:13:47 <lambdabot> http://members.cox.net/stefanor/vty/
21:13:50 <csci> a second to think ;-)
21:14:06 <csci> it reads a line
21:14:23 <sorear> ding ding ding!
21:14:35 <Thomas2> lambdabot: @type find
21:14:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
21:14:36 <csci> but in a real nice way :)
21:14:38 <jcreigh> hmm, is it bad style to do something like "main = do cipher <- readFile "cipher1.txt" >>= return . map (chr . read) . split ',' ..."
21:14:59 <jcreigh> ie, have a medium sized expression on the RHS of <- in a do-block.
21:15:09 <sorear> jcreigh: no
21:15:14 <mauke> >>= return . is liftM
21:15:44 <emk> OK, so the best way to handle test cases under Cabal is just to bypass Cabal entirely, and use a standalone driver program, be it cabal-test or just a shell script.
21:16:14 <mauke> puzzle = do { ch <- getChar; if ch == '\n' then return [] else do { st <- puzzle; return (ch : st) } }
21:17:05 <emk> All of my pain was caused by thinking I could somehow do it "inside the system".
21:17:14 <sjanssen> emk: the projects I work with generally use a makefile
21:17:21 <sjanssen> or just "runhaskell Tests.hs"
21:17:50 <emk> sjanssen: "runhaskell" will puke pretty hard once there's some C source files involved. :-(
21:18:34 <mauke> let rec puzzle () = let ch = getChar () in if ch == '\n' then [] else let st = puzzle () in ch :: st, whee
21:18:56 <sorear> what's rec do again?
21:19:12 <sorear> :)
21:19:24 <LoganCapaldo> I think theres a flaw in that... strings aren't char list in ML are they?
21:19:29 <mauke> it changes the scoping to include its own definition
21:20:04 <mauke> LoganCapaldo: meh
21:20:12 <csci> Ok, Have to go to bed (6am here ;-)). Thanks again for all your help (you should make a tutorial out of it ;-)) and good night
21:20:28 <sjanssen> ML requires a special identifier for recursive bindings?
21:20:31 <Korollary> we're up to our eyeballs in tutorials
21:20:42 <LoganCapaldo> yes
21:20:44 <mauke> sjanssen: OCaml does, I don't know about SML
21:20:59 <sjanssen> mauke: that seems . . . stupid
21:21:03 <LoganCapaldo> OTOH you can say let puzzle () = use previous def of puzzle here
21:21:05 <Thomas2> hmm, SML doesn't
21:21:24 <mauke> let x = 0 in let x = succ x in let x = succ x in let x = succ x in x (* works in OCaml *)
21:21:31 <sorear> sjanssen: (letrec ((puzzle ...  thou durst diss LISP!
21:21:46 <sjanssen> sorear: indeed
21:21:49 <mauke> (labels ((puzzle ...
21:26:44 <sorear> @users
21:26:45 <lambdabot> Maximum users seen in #haskell: 321, currently: 293 (91.3%), active: 30 (10.2%)
21:28:14 <glguy> ?src snark
21:28:14 <lambdabot> Source not found. I feel much better now.
21:28:23 <glguy> heh
21:32:04 <newsham> fun with imperative code
21:32:06 <newsham> http://www.thenewsh.com/~newsham/x/imper.hs
21:34:57 <glguy> newsham: i += n = modifyIORef i (+n)  :-D
21:35:11 <sorear> glguy: all these -Wall patches ... dons actually runs the bot with -Wall -Werror
21:35:24 <newsham> glguy: yah, i'm using modifyIORef in the for updator
21:35:38 <glguy> I just mean, if you want your code to "look" like C
21:35:49 <newsham> oh you mean define those functions
21:35:54 <newsham> heh.. yah, why not
21:36:03 <sorear> newsham: wouldn't it be easier to just use `ap` everywhere?
21:36:15 <glguy> you could have   i =: n = writeIORef i n
21:36:16 <newsham> sorear: dunno, show me.
21:36:44 <sorear> oh wait ... not sure anymore
21:39:13 <glguy> it's pretty lousy that import HAppS imports single letter functions from HaXML
21:39:17 <glguy> like "t" and "e"
21:40:33 <glguy> ?seen dons
21:40:33 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 1h 9m 33s ago.
21:41:20 <newsham> I added =: and += to the code
21:41:58 <dons> glguy: ?
21:42:05 <glguy> for (i =: 0, withRef i (< 4), i += 1) (do  -- if for took a 3 tuple :)
21:42:07 * dons is busy hacking css
21:42:15 <glguy> dons: oh, cool
21:42:20 <glguy> dons: for hpaste
21:42:21 <glguy> ?
21:42:31 <dons> yeah
21:42:35 <glguy> even better!
21:42:38 <newsham> ooh, tuple.. yes
21:42:57 <glguy> to complete the illusion, you could use a <:
21:43:06 <glguy> I know that isn't too general
21:43:29 <newsham> no, I went down that path, its pointless.
21:43:35 <glguy> ok
21:43:36 <newsham> it makes sense to make syntax for updates
21:43:39 <newsham> but not for reads.
21:43:49 <newsham> because then you get different syntax for    x < y and x < 3
21:43:56 <glguy> right
21:44:09 <glguy> but you still have different syntax for i =: j
21:44:25 <glguy> where they are both iorefs
21:44:26 <newsham> updated with tuples
21:44:42 <newsham> yah, all reads have to be explicit.
21:44:57 <glguy> ok
21:44:58 <newsham> I dont want a :< and a < and a printRef and a print, etc..
21:45:39 <sorear> you guys are tempting me to write a nontrivial c/haskell polyglot...
21:45:40 <pitecus> D
21:45:40 <newsham> its pretty amusing how "normal" that looks now
21:46:45 <pitecus> Is it normal for GHC generated code to be 4 or 5 times slower than java?
21:48:06 <newsham> i'm tempted to write an imperative mandelbrot set prog
21:48:08 <sorear> depends, what is your problem domain?
21:48:09 <Korollary> it depends on what the two sources are doing
21:48:14 <sorear> pitecus: strings?
21:48:32 <pitecus> more like arithmetic
21:48:35 <sorear> !paste
21:48:36 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
21:48:42 <glguy> I can't help but to want: foreach (var,mklist) body = mklist >>= mapM_ ( (>> body) . (var =:) )
21:48:51 <sorear> pitecus: are you using Integer in haskell and int in Java?
21:49:15 <pitecus> sorear, I dont think so
21:49:28 <newsham> glguy: was keeping the code very simple cause its an example to my friend who is learning haskell
21:49:28 <sorear> how big is your code?
21:49:31 <pitecus> Actuallyy im using Integer in java and Int in Haskell
21:49:40 <newsham> (was talking about how iorefs could be used to do some imperative style stuff)
21:49:40 <pitecus> small im gonna paste it
21:49:42 <glguy> newsham: obviously not appropriate in this case :)
21:49:48 <sorear> pitecus: not in channel!
21:49:51 <bd_> pitecus: Are you using String?
21:49:51 <glguy> !paste
21:49:52 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
21:50:01 <newsham> (var =:) is interesting though :)
21:50:02 <hpaste>  pitecus pasted "slow code" at http://hpaste.ath.cx:8000/40
21:50:36 * glguy looks right paste pitecus' code and admires the pastebin ;-)
21:50:37 <pitecus> bd_, bytestrings
21:50:41 <glguy> past*
21:51:12 <glguy> pitecus: why do you have a do on the last line?
21:51:28 <sorear> pitecus: how big are your files?
21:51:43 <pitecus> sorear, quite nig
21:51:45 <pitecus> big
21:51:52 <sorear> pitecus: >100kb ?
21:52:36 <pitecus> about 7M
21:52:47 <pitecus> or more
21:52:54 * glguy votes for more
21:52:55 <sorear> pitecus: you should probably be using Data.ByteString.Lazy then
21:53:04 <pitecus> glguy, i dont get it, whats wrong with that do?
21:53:21 <sorear> pitecus: also giving a more specific type for hamming might help
21:53:23 <glguy> pitecus: unnecessary, the putstrln should just be indented 2 spaces
21:53:34 <glguy> pitecus: I didn't know if you knew it was unnecessary or not
21:53:40 <glguy> so I asked if there was a reason
21:53:45 <pitecus> sorear, reading the files doesnt take much as far as i saw
21:53:54 <sorear> ok
21:54:04 <pitecus> ok glguy
21:54:34 <glguy> is a single union more efficient than many inserts?
21:54:54 <sorear> glguy: in what type?
21:55:03 <glguy> Data.Map
21:55:08 <sorear> glguy: probably
21:55:42 <sorear> also don't mess with strictness annotations early
21:55:57 <sorear> pitecus: have you tried assigning monomorphic types?
21:56:07 <glguy> profiling?
21:56:30 <pitecus> sorear, making hamming ::  [Int] -> [Int] -> Int
21:56:34 <pitecus> no effect
21:56:42 <glguy> dons: feel free to back out my changes to the .CSS
21:56:57 <glguy> dons: if you have conflicts
21:57:16 <glguy> dons: the ones that were important are very small and I can add them back myself (the .fromLabel and .toLabel)
21:57:17 <sorear> pitecus: what about the others ... the fromIntegrals in meanDistance look suspicios
21:57:46 <newsham> i wish there was a good way I could support a deref operation.
21:57:58 <newsham> sorta like:   act *: var = readIORef var >>= act
21:58:07 <newsham> printf "foo %d" *:i
21:58:19 <pitecus> is there another way to use / with Ints, sorear ?
21:58:20 <newsham> but it breaks down for   printf "foo %d %d" *:i *:j
21:58:32 <newsham> > 25 `div` 4
21:58:34 <lambdabot>  6
21:58:47 <sorear> pitecus: sorry
21:59:57 <sorear> pitecus: It might be clearer if you used a state monad instead of all those mapAccumL's
22:00:18 <glguy> heh, but probably not faster
22:00:22 <glguy> ?
22:00:48 <dons> glguy: ah ok
22:00:53 <sorear> glguy: State can be easily replaced with IO, and Map with HashTable.  abstraction facilitates expirimentation.
22:00:57 <pitecus> sorear, I dont particularly like littering code with unncessary monads, but i guess its a question of taste
22:02:04 <glguy> LOL, NPR is talking about a "new service" that will allow insomniacs to chat with each other
22:02:16 <mbishop> they invented IRC?
22:02:19 <glguy> this lady thinks there needs to a a "chat service"
22:02:26 <pitecus> anyway the part of the code that runs slow is meanDistance, not reading and preparing the data
22:02:30 <sorear> pitecus: maybe, just maybe, it would be better to concat your lists of words before processing them?
22:02:35 <sorear> oh
22:02:36 <glguy> for people to "brainstorm and talk" at night
22:02:47 <glguy> mbishop: yeah, looks like it
22:03:19 <pitecus> sorear, if i concat them i can no longer calculate the hamming distance between sequences
22:03:36 * edwardk waves hello.
22:03:47 <glguy> size on ByteString is constant time operation?
22:04:21 <sorear> glguy: yes
22:04:28 * glguy ponders a /status page
22:04:37 <glguy> showing number of pastes, annotations, and size used
22:04:52 <sorear> pitecus: how do you know meanDistance is the bottleneck?
22:04:55 <glguy> etc
22:05:10 <edwardk> @seen ski
22:05:10 <lambdabot> I saw ski leaving #haskell 1d 8h 29m 28s ago, and .
22:06:07 <emu> isn't NPR like... for 70 yr old people
22:06:20 <emu> they are still living in the '60s, so give them a break
22:06:33 <pitecus> i extracted this from a bigger program, and it output some stuff after reading the files, it was very quick, then it took forever to calc the meanDistance
22:06:46 <sorear> pitecus: laziness!
22:07:00 <emu> laziness: more than just a way of life
22:07:13 <sorear> pitecus: before you calc the meanDistance, the files are only read, not processes
22:07:16 <sorear> pitecus: before you calc the meanDistance, the files are only read, not processed
22:07:26 <sorear> use the GHC profiler, it can handle this well
22:07:30 <glguy> isn't hamming distance usually more complicated than that?
22:07:36 <pitecus> Well they were processes coz i calculated some other stats on them
22:07:39 <LoganCapaldo> I'm going off the rails on a lazy train
22:08:35 <pitecus> Its the number of positions for which the corresponding symbols are different
22:08:43 <glguy> emu: I know you were joking, but I listen to NPR at night because they play BBC World Service
22:08:50 <glguy> emu: and I like the accents
22:08:52 <glguy> ;)
22:08:59 <mbishop> jolly good!
22:09:04 <emu> blimey
22:09:52 <mbishop> Heh XFiles is on, this characters name is Mr. Haskell :P
22:09:56 <glguy> righto
22:12:05 <dons> glguy: know how to add images in happs?
22:12:15 <dons> or haxml? i'd like a 'save' button, and have created a pretty one :)
22:12:31 <glguy> dons: I add them to /static/
22:12:40 <glguy> dons: and then reference them via XHTML
22:12:48 <glguy> using <input type="image"
22:13:51 <sorear> dynamic images?  activity graphs anyone?
22:16:22 <glguy> !lcs Not-The-Matrix Bit-matrix
22:16:23 <hpaste>  +B +i -N -o t -- -T -h -e - +m -M a t r i x
22:16:58 <glguy> I guess - makes a poor word spacer when also used as subtraction
22:17:23 <sorear> glguy: how does lcs compare with levenshtein?
22:17:23 <glguy> !lcs dons sorear
22:17:24 <hpaste>  +s -d o +r +e +a +r -n -s
22:17:34 <glguy> sorear: I don't know :)
22:17:53 <sorear> levenschtein is optimal but O(n^2) in the worst case
22:18:18 <glguy> my lcs is O(m*n) I believe..
22:18:42 <sorear> OK OK leven is O(mn) too
22:18:55 <sorear> leven is also really simple in Haskell
22:19:03 <glguy> sorear: did you look at my lcs?
22:19:08 <glguy> does it look like lambdabot 's leven?
22:19:09 <sorear> no
22:19:41 <glguy> lcs was the first thing to come to mind to implement diff... I'm sure there are more optimal solutions
22:19:41 <sorear> lambdabot's leven is an ugly mess noted as a "trivial transliteration from Erlang"
22:20:52 <glguy> I could cut mine in half by not taking one step to find the lcs, and one to backtrack
22:21:20 <glguy> since I don't think that it would actually duplicate the content, but point back
22:21:46 <sorear> your dp is spj's memofix
22:21:48 <glguy> to the existing bytestrings or whatnot
22:21:51 <glguy> yeah
22:21:58 <glguy> I copied that out of a mailing list posting
22:22:24 <sorear> beschmi++ C-c C-t
22:22:32 <glguy> do you see any reason not to merge the longest and follow steps?
22:22:44 <newsham> imperative mandelbrot set (ascii) http://www.thenewsh.com/~newsham/x/impermand.hs
22:23:12 <glguy> newsham: I wrote a one-liner haskell ascii mandlebrot set generator earlier this year :)
22:23:31 <glguy> took like 135 chars tho
22:23:48 <newsham> glguy: i have several small (not 1 liners)
22:23:56 <glguy> it was an ugly one liner
22:24:03 <glguy> I didn't know why it worked looking at the final result
22:24:47 <newsham> here's one that does pbms of mandelbrots, julias and moire patterns (and any other Float -> Float -> Bool functions)
22:24:50 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/mand3.hs.txt
22:25:15 <newsham> here's a smaller ascii one: http://www.thenewsh.com/%7Enewsham/x/machine/mand2.hs.txt
22:25:25 <newsham> (again mands, julias and moires)
22:25:53 <newsham> a bit bigger than 135 chars though
22:26:33 <dons> glguy: sent you my css patch
22:26:43 <dons> starts on getting us to look like the nice minimal paste systems
22:26:49 <dons> but i need to work out how to add little graphics yet
22:26:56 <newsham> glguy: where's your code at?
22:26:57 <sorear> How old is hpaste?
22:27:02 <sorear> @where hpaster
22:27:03 <lambdabot> I know nothing about hpaster.
22:27:03 <sorear> @where hpaste
22:27:04 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
22:27:05 <glguy> newsham: I don't have it laying aorund
22:27:10 <glguy> newsham: oh that?
22:27:13 <glguy> there :)
22:27:25 <newsham> hm?
22:27:30 <glguy> nvm ;)
22:27:33 <glguy> I'm lost
22:28:21 <newsham> the question is should I rewrite the language shootout C winner in imperative haskell?
22:28:35 <dons> or bytestring haskell...
22:28:41 <dons> the answer is, use the latter if possible
22:28:56 <dons> or you could use a nice dsl, i guess :)
22:29:44 <glguy> dons, is the bg supposed to be white?
22:29:51 <dons> yeah, for now...
22:30:10 <dons> i'm aiming for http://www.rafb.net/paste/
22:30:11 <dons> roughly
22:30:21 <dons> where the colours are in the header and footer
22:30:23 <dons> to frame the page
22:30:37 * sorear rewrites glguy's diff code using levenschtein
22:30:45 <dons> did you rebuild the server too?
22:30:50 <glguy> not yet
22:30:55 <newsham> edit the distance between us
22:31:43 <glguy> dons: rebuild/started
22:31:48 <newsham> such dynamic programming
22:32:40 <glguy> dons: does the title: label push down for you on NEW?
22:32:43 <newsham> when doing dynamic coding in haskell do you just let the memoizing/lazy evaluation keep track of the table?
22:32:51 <newsham> dynamic programming rather
22:33:02 <glguy> newsham: in hpaste's case, you use a lazy array
22:33:25 <glguy> dons: are you using that save button yet?
22:33:39 <glguy> or should I tie it in?
22:33:40 <newsham> does it matter if its lazy?  doesnt the whole array get evaluated anyway?
22:33:43 <glguy> (its pretty)
22:34:19 <glguy> newsham: by being lazy, you don't need to detect explicitly when to perform the calculation
22:34:20 <dons> you should tie it in if you can
22:34:23 <glguy> and when to look it up in the array
22:34:25 <dons> since i don't know how to
22:34:30 <glguy> I'm on it!
22:35:01 <newsham> i'm not sure i understand.. maybe i should just read the code :)
22:35:17 <dons> and yeah, i couldn't get the author/rmember/titleboxes to format properly
22:35:24 <dons> they're a bit squished
22:35:32 <glguy> ok, I'll look at it
22:35:41 <dons> i'd like them more across the page, on a single line, like http://pastebin.klfree.net/new
22:35:47 <newsham> glguy: where's hpaste at?
22:35:58 <dons> http://hpaste.ath.cx:8000/new
22:36:09 <glguy> newsham: I'm sure you could think of a command ot figure that out ;)
22:36:25 <dons> glguy: and then we can replace the 'hpaste' title with a nice little graphic, reddit style
22:36:29 <glguy> yeah
22:36:33 <glguy> I like nice little gfx
22:36:35 <LoganCapaldo> @where hpaste at
22:36:36 <lambdabot> http://www.scannedinavian.com/~eric/hpaste
22:36:37 <glguy> right sorear
22:36:40 <glguy> @paste
22:36:41 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
22:36:41 <glguy> !paste
22:36:42 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
22:36:44 <glguy> hpaste: url
22:36:45 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
22:37:08 <LoganCapaldo> @cut
22:37:08 <newsham> i'm not very creative
22:37:09 <lambdabot> Maybe you meant: bug ft let quit run
22:37:28 <dons> glguy: the image isn't visible yet?
22:37:33 <glguy> not yet
22:37:38 <glguy> next restart
22:38:17 <glguy> looks like I need to specify high and widdth :)
22:39:08 <newsham> glguy: the foldr aux end?
22:39:20 <glguy> newsham: look for "tabulate" and "dp"
22:40:01 <glguy> dons: found the fix for that form
22:40:25 <dons> cool
22:43:28 <sorear> night all
22:43:32 * glguy has verified that the save image is a labeled button in elinks
22:43:36 <glguy> night
22:43:40 <newsham> hmm.. so you only compute distances when you need them.. but..  because of the algorithm the whole table gets evaluated anyway..
22:43:46 <newsham> i'm still not sure i see why this is better.
22:43:49 <Saizan> oooh it's all mac os-ish now :O
22:43:52 <sorear>    author: _____________________ remember me: [ ] title: _____________________ silent: [ ] [ save ]
22:44:03 <sorear> right below the input box
22:44:06 <glguy> newsham: without the table, that has exponential run time
22:44:20 <dons> yeah
22:44:29 <newsham> what if you just construct the table with two nested foldls?
22:44:35 <dons> Saizan: mac-os ish?
22:44:45 <newsham> (ie. the way the algorithm is usually implemented in imperative code)
22:45:23 <Saizan> dons: well, it's white and blue and "clean"
22:45:27 <glguy> its usually implemented with a table in imperative code
22:45:34 <newsham> tab(x,y) only depends on tab(x', y') for x' <= x and y' <= y
22:45:35 <glguy> it's blue?
22:45:37 <dons> ah good :)
22:45:49 <newsham> glguy: yah, so an array with foldl's to update it?
22:46:05 <Saizan> glguy: links
22:46:20 <glguy> ah
22:47:20 <dons> looks like the view box goes off the right hand side of the page?
22:47:24 <dons> e.g. http://hpaste.ath.cx:8000/31
22:47:31 <newsham> foldl (\arr (x,y) -> ...) arrCoords   ?
22:48:28 <newsham> or are the arr updates just too expensive for that?
22:48:39 <dons> mm. hpaste looks very nic ein w3m
22:48:40 <glguy> dons: look again
22:48:52 <glguy> dons: we need a color
22:48:55 <glguy> my eyes hurt
22:49:06 <dons> ah yes, fixed
22:49:21 <dons> maybe color the view of the src a very light grey?
22:49:30 <dons> i.e. like in trac, http://hackage.haskell.org/trac/haskell-prime/wiki/ViewPatterns
22:49:31 <lambdabot> Title: ViewPatterns - Haskell Prime - Trac
22:49:37 <glguy> give me a hex code to try
22:49:52 <glguy> current code recorded
22:50:50 <glguy> like this?
22:50:52 <glguy> #ddd
22:50:57 <glguy> lighter?
22:51:03 <dons> but a bit lighter even. hmm,  #f7f7f7
22:51:12 <dons> (that's what trac uses)
22:51:17 <dons> i'd even go f8f8f8
22:51:17 <glguy> done
22:51:31 <dons> ah yes
22:51:33 <dons> that looks good
22:51:47 <glguy> we still need "less white" :)
22:51:53 <Saizan> i'd rather make the background darker
22:52:10 <dons> right. so the next step is to do a header i think
22:52:26 <dons> a ~1cm block of text and colour across the top
22:52:31 <glguy> the nick / title / age   conflicts with the links after it
22:53:17 <dons> argh, pink! green!
22:53:26 <dons> too much colour!
22:53:39 <dons> the bg should at least be hite...
22:53:52 <dons> white. think wikimedia or just about everywhere else ... reddit ...
22:54:19 <glguy> yellow!
22:54:22 <kolmodin> morning!
22:54:30 <dons> morning kolmodin
22:54:32 <glguy> ok, but we need less white, so help figure out something
22:54:40 <dons> a header!
22:56:08 <dons> but time for dinner.
22:56:12 <glguy> dons: now?
22:56:14 <kolmodin> morning dons
22:56:15 <dons> urk! pink!
22:56:16 <glguy> (the color)
22:56:22 <glguy> yea!!
22:56:26 <dons> clearly glguy has gone insane
22:56:35 <dons> hand back the keys to that darcs repo!
22:56:59 <dons> just leave it white, and we can do a nice pretty header later :)
22:57:20 <dons> its text, it should be clean and simple.
22:58:09 <dons> this looks quite ok, imo: http://hpaste.ath.cx:8000/25
22:58:39 <dons> ok. so a simple heade rgraphic coming up..
22:58:45 <glguy> phew
22:59:00 <dons> sneaky :P
23:03:53 <glguy> make the front page list also slightly gray?
23:04:20 <newsham> glguy: why is this worse?  http://www.thenewsh.com/%7Enewsham/x/diff.hs
23:04:48 <glguy> newsham: array updates are slow
23:05:17 <newsham> does your code eliminate table updates?
23:05:28 <glguy> yes
23:05:33 <newsham> (hope this doesnt come off as "your code sucks", i'm trying to understand this)
23:05:36 <glguy> all of the elements are assigned to a thunk
23:05:39 <glguy> right off the bat
23:05:58 <newsham> but all of the elements will have to be computed once in both your code and my code, no?
23:06:03 <newsham> thats th enature of dynamic programming.
23:06:06 <glguy> sure
23:06:24 <glguy> newsham: technically, you don't need a whole table
23:06:29 <glguy> newsham: you just need one row
23:06:31 <glguy> and a temp element
23:06:41 <glguy> I've written this as a nested fold
23:06:54 <int-e> newsham: yes but you'll copy the array with every update, too, while glguy's code (I guess) uses lazy evaluation to do the updates in place.
23:07:13 <glguy> int-e: the code in lcs down is mine, tabulate and dp are not
23:07:24 <newsham> :(  i dont understand.
23:08:48 <newsham> i guess first question, what is the "memo!" vs "memo"?
23:08:56 <newsham> is that some sort of strictness flag?
23:09:15 <hpaste> hpaste, now with 90% less color
23:09:30 <glguy> (memo !) is a section
23:09:35 <glguy> memo is an array
23:09:36 <newsham> oh, duh.
23:09:37 <newsham> heh
23:09:38 <glguy> ! is the index operator
23:09:41 <newsham> *nod*
23:09:51 <int-e> newsham: well, operationally speaking, replacing an unevaluated thunk by it's final value is the only in place update that you have in pure Haskell code, so the code tries to make all updates to the array of that kind.
23:09:57 <int-e> its.
23:10:03 <Saizan> http://en.wikipedia.org/wiki/Battle_of_Cannae <-- hey even wikipedia has a slghtly darker colour as background, that much white just hurts!
23:10:04 <lambdabot> Title: Battle of Cannae - Wikipedia, the free encyclopedia
23:10:29 <int-e> newsham: // can't do in place update because in general, you might still be using the previous array.
23:10:31 <newsham> inte: hmm. that sort of makes sense at a high level to me :)
23:10:48 <glguy> Saizan: the gray graphic behind stuff could be nice
23:10:50 <newsham> tangential: what about the ST arrays?
23:11:01 <glguy> Saizan: I'm working with dons on this, it's not done :)
23:11:08 <int-e> newsham: so that has to copy the array. (it'd need special compiler support to not copy.)
23:11:51 <Saizan> glguy: just wanting to back up the not-so-white faction :)
23:12:13 * glguy is expecting to be attacked over the blizzard ;)
23:12:29 <glguy> forgive me if I'm defensive :-D
23:12:35 <int-e> newsham: and ST arrays have mutable semantics and can only be used in the ST monad which only allows serial execution, so that the sharing problem doesn't arise.
23:12:51 <newsham> glguy: no problem.  i appreciate your comments.
23:13:01 <glguy> newsham: no no, about hpaste ;)
23:13:12 <newsham> inte: right.  so wouldnt ST arrays be good for this type of task?
23:13:28 <int-e> newsham: yes, they would certainly work nicely
23:13:47 <newsham> which type of updates would be more efficient on modern ghc?
23:14:06 <int-e> newsham: but the code would probably be uglier.
23:14:48 <int-e> I can't answer the last question.
23:14:51 <glguy> maybe we could generate something classy with pan
23:15:39 <dons> glguy: ok. simple logo sent
23:15:43 <newsham> and if you just wrote up the most obvious recursive solution to edit-distance?  it wouldnt memoize itself well?
23:15:47 <dons> i'll add some background texture to it
23:15:57 <glguy> ok
23:16:00 <beschmi> int-e: it's uglier http://www.abridgegame.org/repos/darcs-unstable/Lcs.lhs
23:16:23 <beschmi> int-e: but only a factor of 2-5 slower than gnu diff
23:16:32 <dons> so we just need to replace h1 "hpaste" with the img ref on each page
23:17:29 <int-e> newsham: Haskell (well, GHC) doesn't memoize automatically, it only combines some common subexpression. And without memoization you're off to exponential hell.
23:17:31 <glguy> http://hpaste.ath.cx:8000/static/hpaste.jpg
23:18:01 <dons> ok
23:18:09 <newsham> *nod*
23:18:14 <dons> you want me to do the title patch?
23:18:28 <glguy> I was going to take a page from css zen garden
23:18:31 <dons> ah hah. almost there
23:18:35 <glguy> and make the h1 actually be the image
23:18:43 <dons> yep
23:18:54 <glguy> do you know how that owrks offhand?
23:18:59 <glguy> or would you have to look it up also?
23:19:06 <dons> i'd have to look it up
23:19:47 <int-e> newsham: have DiffArrays been mentioned?
23:20:09 <glguy> ok, I'm almost there
23:20:56 <dons> yep
23:21:24 <newsham> nope
23:22:56 <glguy> what are the header dimensions
23:23:04 <int-e> newsham: DiffArrays are a compromise between pure code and ST code; they have O(1) updates (but access to older version gets slower). They'd improve your code, but the constant factor is rather large I think. ST arrays will fare better.
23:23:32 <int-e> newsham: I mean they'd improve the runtime of your code.
23:23:51 <newsham> its ironic that its really easy to add memoization to a pure function in an imperative language.
23:24:05 <dons> 377x27
23:24:25 <newsham> but you cant memoize a pure function in haskell because the state would make it non-pure
23:24:30 <newsham> (even though its really pure)
23:24:35 <int-e> newsham: it's also quite easy in Haskell, it's just done quite differently.
23:24:36 <newsham> maybe unsafePeformIO ?
23:24:50 <glguy> dons: now?
23:24:51 <dons> yeah
23:24:56 <newsham> inte: i mean I cant just do:   dist' x y = memoize dist x y
23:25:01 <dons> looking..
23:25:05 <newsham> whre I can do the moral equivalent of that in python easily
23:25:16 <glguy> dons: I might need to push the topnav "new" links down some
23:25:22 <dons> ok. good. maybe a 1em gap between the heading
23:25:25 <dons> and the 'new' text
23:25:47 <dons> looks nice!
23:25:47 <glguy> ?
23:25:52 <newsham> def memoize(f, *args): { if args not in cache : cache[args] = f(*args); return cache[args]; }
23:26:09 <glguy> dons: so hpaste is a fmap?
23:26:21 <dons> well, maybe it has some other type :) but it could be an fmap
23:26:46 <dons> yes, that looks good
23:26:51 <int-e> newsham: well, here's a horrible idea... memoize f = array (minBound, maxBound) [(x, f x) | x <- [minBound .. maxBound]]
23:27:23 <newsham> that doesnt work when f is defined recursively (like it is for edit distance)
23:27:41 <newsham> maybe there's a nifty recursive zipWith in here somewhere
23:27:47 <newsham> sorta like the memoized fibonacci sequence
23:27:53 <int-e> well, obviously you need to build in the memoizing into `fix` then
23:28:13 <int-e> let f = memoize f'; f' x = <your original code for f>
23:28:47 <newsham> hmm!  if you zipped together three streams, one that was lagged by 1 and one that was lagged by th elength of one of your strings
23:29:04 <newsham> you'd have all your state in the stream
23:29:11 <int-e> I wouldn't use the memoize as I proposed it, because it creates an array of impractical size. but you can refine the idea a lot by replacing the array by a tree
23:29:17 <dons> glguy: does hpaste.org work yet I wonder?
23:29:25 <glguy> I don't believe so
23:29:36 <int-e> (except for small types where the array is small)
23:29:46 <newsham> inte: in the case of dynamic proramming the full table isnt unreasonable (although as glguy pointed out you only really need the last row and the previous value in the current row)
23:29:53 <dons> oh, i see bos' registration has come through on whois
23:29:59 <int-e> newsham: right
23:30:43 <glguy> dons: give me a blank purple button?
23:30:49 <dons> ok
23:32:06 <dons> http://www.cse.unsw.edu.au/~dons/images/blank.jpg
23:34:23 <glguy> I think I can use a <button> and put text on that
23:34:30 <glguy> without modifying the image
23:34:46 <glguy> ugh, firefox is making the pre's too wide
23:42:17 <dons> glguy: you going to announce hpaste on haskell-cafe@ ?
23:42:35 <dons> people will be quite interested to see a quickly developed live web program :)
23:42:41 <glguy> do I just email haskell-cafe@haskell.org?
23:42:42 <dons> good advert for happs and haxml
23:42:45 <dons> yeah
23:42:50 <glguy> I  guess I could
23:42:52 <dons> with 'Announce : hpaste' for a subject
23:42:54 <lisppaste2> int-e pasted "memoizing an 'infinite' sequence" at http://paste.lisp.org/display/35808
23:42:58 <dons> and a blurb about it
23:43:02 <dons> int-e! for shame
23:43:08 <glguy> no love
23:43:16 <int-e> newsham: maybe you'll like that.
23:43:16 <dons> hpaste is here! http://hpaste.ath.cx:8000/
23:43:50 <int-e> but ... my bookmark!
23:43:58 <dons> hpaste: url
23:43:59 <hpaste> Haskell paste bin: http://hpaste.ath.cx:8000/
23:44:35 <hpaste>  dons pasted "memoising copy from lisppaste" at http://hpaste.ath.cx:8000/41
23:45:10 <dons> much prettier than lisppaste
23:45:13 <glguy> http://hpaste.ath.cx:8000/static/button.html
23:45:14 <dons> and strongly typed too!
23:45:14 <glguy> dons
23:45:32 <dons> cool
23:45:54 <amiddelk> care to explain the type signature of hpaste? ;)
23:46:21 <dons> its a functor!
23:46:32 <dons> like all good things
23:46:53 <amiddelk> i don't see the relation with a paste bin t.b.h.
23:47:06 <glguy> it's a container?
23:47:17 <dons> paste text -> containerised paste text in html
23:47:17 <dons> ?
23:47:20 <amiddelk> ah
23:47:46 <dons> maybe its an insert
23:47:46 * int-e looks for the 'fmap' button.
23:47:55 <dons> :t M.insert
23:47:56 <lambdabot> Couldn't find qualified module.
23:48:04 <dons> :t Data.Map.insert
23:48:06 <lambdabot> forall a k. (Ord k) => k -> a -> Data.Map.Map k a -> Data.Map.Map k a
23:48:17 <int-e> newsham: anyway, that's a nontrivial memoizing scheme for you :)
23:48:30 <dons> paste -> h a -> h a
23:48:31 <glguy> dons: http://hpaste.ath.cx:8000/41
23:48:34 <glguy> format button
23:48:52 <dons> nice!
23:48:56 <dons> much much nicer
23:49:09 <dons> are you planning other 'formats'?
23:49:25 <glguy> I wanted to leave that open
23:49:26 <glguy> also
23:49:29 <int-e> anyway, it's looking *much* better than 2 days ago :) nice work.
23:49:32 <glguy> I want highlighting
23:49:41 <glguy> @@ at the beginning of a line
23:49:46 <glguy> makes it a highlighted line
23:50:18 <glguy> the blank.jpg doesn't seem to be caching however
23:50:19 <dons> yeah, this looks very nice: http://hpaste.ath.cx:8000/41
23:50:37 <int-e> did anyone look at the code? ;)
23:50:45 <glguy> lol
23:50:50 <dons> it looks pretty, int-e
23:50:53 * glguy thinks we are missing the point of a pastebin
23:51:04 <glguy> int-e: yes, it was well suited to highlighting
23:51:10 <dons> make it nice to use, then the pastes will follow!
23:53:30 <dons> glguy: patch
23:54:31 <dons> mm, compare http://hpaste.ath.cx:8000/41 to http://paste.lisp.org/display/35808
23:54:49 <dons> we should have done this years ago!
23:54:50 <glguy> dons your patch is in now
23:55:16 <newsham> http://www.thenewsh.com/~newsham/x/diff3.hs
23:55:29 <newsham> using a list for the previous row
23:55:37 <dons> @paste
23:55:38 <lambdabot> Haskell pastebin: http://kakapo.scannedinavian.com:8000/new
23:55:43 <dons> ah need to change that
23:55:51 <glguy> dons: don't bother, right
23:55:54 <glguy> since hpaste.org is coming
23:55:59 <dons> ah ok
23:58:07 <glguy> dons: what exactly do I need to say to haskell-cafe...
23:58:17 <glguy> like "hpaste exists, yea!"?
23:58:28 <int-e> "resistance is futile ..."
23:58:35 <dons> yeah and the url, and any info on the implementation
23:58:40 <dons> built with happs and haxml
23:58:46 <dons> runs on a server, blah blah
23:58:59 <glguy> Through a wonderful colaboration of the members of #haskell, I am pleased to present *hpaste*
23:59:01 <dons> any details and lessons learnt
23:59:08 <dons> yeah, that kind of thing
23:59:08 <glguy> I might do this at work tomorrow
23:59:15 <glguy> sounds like I need to put thought into it
23:59:30 <dons> thanks to darcs  and irc for making collaboration easy!
23:59:42 <dons> well, it can be brief, or it can be detailed, and help others write similar things
23:59:47 <dons> seize the opportunity!
