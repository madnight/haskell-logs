00:05:47 * glguy wonders if using unionWith and fromList is better for a Map, or if using foldl' and insertWith is better..
00:05:48 <glguy> ?bot
00:05:49 <lambdabot> :)
00:05:57 <glguy> ?src Data.Map.unionWith
00:05:58 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:06:05 <glguy> ?src unionWith
00:06:06 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
00:06:12 <glguy> ?fptools Data.Map
00:06:13 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
00:06:28 <sorear> ?source
00:06:29 <lambdabot> Not enough privileges
00:06:43 <sorear> oh right, old bot :)
00:07:42 <lisppaste2> glguy annotated #35222 with "bit of cleanup" at http://paste.lisp.org/display/35222#1
00:08:07 <glguy> I should probably use a Data.Set instead of a list for my "open" list
00:08:51 <sorear> allbery_b++ /me double clicks on the url
00:12:24 <DracoCepheus> is there a way to use @pl in hugs?
00:12:50 <sorear> no
00:13:25 <sorear> there was a (iirc now bitrotted) package for @pl in ghci
00:14:26 <allbery_b> goa?
00:14:29 <allbery_b> @where goa
00:14:30 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
00:15:28 <allbery_b> building it is a bit of a pain though, you need to build a local lambdabot (itselff not quite trivial) first
00:22:57 <shapr> ttmrichter, jcreigh: sigfpe's "You Could Have Invented Monads" tutorial is good.
00:23:00 <sorear> @ty flip (runStateT . flip modifyMVar)  -- how original is this?
00:23:02 <lambdabot> Not in scope: `modifyMVar'
00:23:11 <sorear> @ty flip (runStateT . flip Control.Concurrent.MVar.modifyMVar)  -- how original is this?
00:23:13 <lambdabot>     Expecting a function type, but found `b'
00:23:13 <lambdabot>       Expected type: a1 -> StateT s m a
00:23:47 <sorear> @ty flip (flip Control.Concurrent.MVar.modifyMVar . runStateT)  -- how original is this?
00:23:49 <lambdabot> forall a. GHC.IOBase.MVar a -> StateT a IO a -> IO a
00:26:38 <ttmrichter> Yes, that's the one I used that finally made things gel, shapr.
00:26:51 <ttmrichter> The robotic factory one helped a bit too.
00:26:56 <ttmrichter> But "You Could Have" was the best of the lot.
00:27:08 <ttmrichter> And seeing monads implemented in languages I knew (Ruby and Python) also helped.
00:28:15 <shapr> Best research paper title I've seen in years: "A Very Modal Model of a Modern, Major, General Type System"
00:29:06 <sorear> hehe
00:29:13 <shapr> Assuming you know the song from "Pirates of Penzance"
00:29:30 <shapr> http://en.wikipedia.org/wiki/Major_General's_Song
00:29:33 <sorear> didn't know where it was from
00:30:23 <shapr> I have to start using animalcule in conversation.
00:31:32 <allbery_b> I think that was originally Pasteur
00:31:51 <shapr> Sure, but it's a good word.
00:39:36 <sorear> is there a good "should I report <arguably undesireable behaivor>?" page?
00:39:44 <sorear> (in the libraries)
00:40:07 <shapr> libraries mailing list?
00:40:09 <allbery_b> ?bug
00:40:10 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
00:40:24 <shapr> Yeah, use the tracker and/or report it on haskell-cafe?
00:40:28 <allbery_b> other than that, mailing list soudns like  goodplace to start
00:41:00 <sorear> if I'm going to ask the mailing list, I might as well just report it :)
00:41:08 <shapr> yup
00:42:16 <sorear> <thinks more> it falls under the category of combining-these-!unsafe-features-breaks-library-invariants
00:47:28 <sorear> where do you report library bugs?
00:47:47 <sorear> I see the GHC bug report pages...
00:49:30 * allbery_b sees "libraries" as a ghc bug category (in particular, a libraries/base ticket pops up first in "all bugs")
00:51:31 <sorear> should I also post to some list?
00:51:52 <sorear> oooh, component: hslibs/*
01:02:41 <sorear> goodnight.
01:45:53 <richcollins> darwinports seems to be failing - should I expect to see any output during the build step?
01:48:05 <allbery_b> no, it's typically silent
01:48:28 <allbery_b> (which is rather disconcerting if your'e used to freebsd ports...)
01:49:53 <richcollins> allbery_b, ah ok
01:49:58 <richcollins> just been running forever
01:50:32 <allbery_b> ghc?  it takes forever :)
01:51:23 <richcollins> ah ok
01:51:31 <richcollins> guess I will just let it run while I sleep
01:51:39 <richcollins> wonder why there isn't a dmg
01:52:06 <richcollins> Mac hardware is pretty homogenous afaik
01:52:14 <johnnowak> richcollins: compile with -d and it'll talk to you
01:52:25 <richcollins> johnnowak, ah hey there
01:52:32 <johnnowak> lo richcollins :)
01:52:52 <richcollins> johnnowak, thought I would see what all of the hubub is about ;)
01:53:16 <paolino> :t StateT
01:53:18 <lambdabot> forall a (m :: * -> *) s. (s -> m (a, s)) -> StateT s m a
01:53:26 <johnnowak> richcollins: best of luck. :)
01:53:33 <richcollins> heh
01:53:40 <allbery_b> there are dmgs for intel and ppc on the ghc downloads page
01:53:42 <richcollins> should be interesting to see if I can think functionally
01:53:50 <richcollins> allbery_b, hrm I must have missed them
01:53:59 <allbery_b> they're at the very bottom
01:54:14 <allbery_b> in particular, people always seem to miss the intel one that's the very last thing on the page
01:55:17 <richcollins> yep
01:59:44 <johnnowak> richcollins: i just use the binaries off the site. it's not exactly a quick build.
01:59:55 <richcollins> yeah that is what I am doing
01:59:59 <richcollins> I didn't run across them before
02:03:49 <richcollins> johnnowak, hrm does the binary still require configure and make?
02:04:29 <goltrpoat> what happened to GHood, anyway
02:04:31 <johnnowak> richcollins: i'm not sure why it would. if there's a makefile, did you try running make install?
02:04:41 <goltrpoat> or, well.. what happened to Hood, come to think of it
02:05:23 <richcollins> johnnowak, yeah looks like configure and make install is all that is required
02:12:25 <allbery_b> rich: patching thinsg to point to whatever install path you select
02:58:07 <paolino> good morning how I turn on syntax highlight in emacs haskell mode ?
02:59:50 <Heffalump> turn on the font-lock-mode bit
03:00:12 <Heffalump> (does that make sense given the instructions on the web page for how to set it up?)
03:01:12 <paolino> (add-hook 'haskell-mode-hook 'font-lock-mode)  ?
03:01:22 <Heffalump> yep
03:01:22 <paolino> this lime in .emacs should do ?
03:01:26 <Heffalump> I believe so
03:01:34 <Heffalump> I don't really understand emacs myself, though.
03:02:26 <nornagon> @remember paolino this lime in .emacs should do ?
03:02:27 <lambdabot> Done memoising quote for `paolino', if that is their real name...
03:03:53 <paolino> eh, ... but no syntax highlight
03:04:07 <Heffalump> you exited and restarted?
03:05:07 <paolino> yes
03:05:35 <paolino> no errors , but no effects.
03:06:06 <velco> M-x customize-variable global-font-lock-mode
03:07:24 <nornagon> M-x S-a A-c C-z make-everything-work-no-really-just-do-it
03:07:43 <Heffalump> paolino: sorry, I don't know then
03:09:04 <paolino> ok, now I have it, thanks. I'm a vim user on a new planet
03:09:22 <nornagon> vim ftw
03:10:22 <velco> somehow vim compared to emacs looks like C to Haskell to me ...
03:12:06 <nornagon> EDITOR WARS
03:12:43 <nornagon> (vim:emacs :: C:haskell => vim is faster than emacs)
03:13:40 <paolino> what specific to haskell commands I have now ?
03:14:14 <paolino> C-c C-z loaded hugs
03:14:20 <allbery_b> (add-hook 'haskell-mode-hook (lambda () (font-lock-mode 1)))
03:14:40 <allbery_b> the other won't work because font-lock-mode wants an argument in lisp mode
03:14:48 <allbery_b> (as distinct from command mode)
03:14:57 <allbery_b> elisp is a bit funky...
03:19:05 <paolino> is there a way to load the file in the interpreter ?
03:19:22 <paolino> or some functions
03:22:56 <allbery_b> position cursor at the end of that line, C-x C-e
03:24:06 <allbery_b> you could run the whole file with M-x eval-current-buffer but that is not necesatily a good idea
03:24:43 <efuzzyone> hi
03:25:50 <efuzzyone> i am a haskell newbie, if i use this 'roots 1.0 -20.0 1.0' i get an error but 'roots 1.0 (-20.0) 1.0' this works, where root finds the quadratic roots
03:26:45 <efuzzyone> is the latter the way functions should be called, if negative numbers are present?
03:26:46 <Jaak> > abs 1.0 -20.0
03:26:48 <lambdabot>  -19.0
03:27:12 <velco> efuzzyone: roots 1.0 -20.0 1.0 is the same as rots (1.0 - 20.0) 1.0
03:28:16 <efuzzyone> velco: ok, thanks
03:28:24 <allbery_b> negative numbers are kinda problematic
03:28:31 <Jaak> > max 1.0 -2.0
03:28:32 <lambdabot>   add an instance declaration for (Fractional (a -> a))
03:28:49 <Jaak> > (max 1.0) -2.0
03:28:50 <lambdabot>   add an instance declaration for (Fractional (a -> a))
03:28:57 <Jaak> > max (1.0 -2.0)
03:28:58 <lambdabot>  Add a type signature
03:35:02 <fuzz2> > 1
03:35:04 <lambdabot>  1
03:35:32 <arjanoosting> max 1.0 (-2.0)
03:35:40 <arjanoosting> > max 1.0 (-2.0)
03:35:41 <lambdabot>  1.0
03:36:08 <fuzz2> > instance (Num a, Num b) => Num (a, b) where
03:36:08 <fuzz2> > instance (Num b) => Num (a-> b) where
03:36:08 <fuzz2> >    f + g         = \x -> f x + g x
03:36:08 <fuzz2> >    f * g         = \x -> f x * g x
03:36:08 <fuzz2> >    abs f         = \x -> abs (f x)
03:36:08 <fuzz2> >    signum f      = \x -> signum (f x)
03:36:09 <lambdabot>  Parse error
03:36:09 <lambdabot>  Parse error
03:36:09 <lambdabot>  Parse error
03:36:09 <lambdabot>  Parse error
03:36:09 <lambdabot>  Parse error
03:36:11 <fuzz2> >    negate f      = \x -> negate (f x)
03:36:11 <lambdabot>  Parse error
03:36:12 <fuzz2> >    fromInteger i = \x -> fromInteger i
03:36:13 <lambdabot>  Parse error
03:36:15 <lambdabot>  Parse error
03:36:46 <fuzz2> > 1 + 3
03:36:48 <lambdabot>  4
03:36:57 <fuzz2> > 1 + 2
03:36:57 <fuzz2> > 2 + 5
03:36:59 <lambdabot>  3
03:36:59 <lambdabot>  7
03:37:40 <ClaudiusMaximus> @seen conal
03:37:40 <lambdabot> conal is in #haskell. I last heard conal speak 13h 45s ago.
03:40:58 <ClaudiusMaximus> @tell conal http://imagebin.org/6907 : an implementation in Pd+GridFlow of diskChecker from page 4 of eros.pdf
03:40:58 <lambdabot> Consider it noted.
03:46:05 <Jaak> @src liftM
03:46:05 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
04:06:02 <chr1s> hey all
04:06:18 <chr1s> I'm trying around with HaXML, but no luck yet.
04:07:10 <chr1s> For every xml-doc I'm trying to parse, I get the error "*** Exception: Parse error: in  file -  at line 1 col 1
04:07:13 <chr1s>     no toplevel document element
04:07:22 <chr1s> anyone experience with this?
04:08:03 <Heffalump> does it have a charset specifier?
04:09:21 <bakert> @seen shapr
04:09:22 <lambdabot> shapr is in #scannedinavian, #unicycling and #haskell. I last heard shapr speak 3h 3m 14s ago.
04:11:05 <ClaudiusMaximus> chr1s: no experience, but a random guess is that the xml-doc file is in some form of unicode with a byte order marker
04:12:54 <ClaudiusMaximus> chr1s: http://en.wikipedia.org/wiki/Byte_Order_Mark paragraph 4
04:12:56 <lambdabot> Title: Byte Order Mark - Wikipedia, the free encyclopedia
04:21:02 <fasta> What instance do I need fo write to satisfy MonadState (Sometype a b) (MaybeT (State s))?
04:21:12 <fasta> to write, even
04:21:53 <fasta> I get either coverage condition errors or kind mismatches with both things I tried.
04:28:06 <fasta> Hmm, I think I got the right type.
04:29:09 <astrolabe> Does anyone use HOpenGL?
04:30:34 <ClaudiusMaximus> astrolabe: i've played with it a little
04:30:37 <fasta> Hmm, ok, it appears to be correct.
04:31:08 <astrolabe> ClaudiusMaximus: Did you get it to work?  It all seems very old.  What platform are you using?
04:31:53 <Svrog> does the latest development version of ghc support bytestring literals yet?
04:32:02 <ClaudiusMaximus> astrolabe: gentoo linux with ghc-6.4.2 as provided by the distro (emerge'd with USE="opengl", as far as i can recall)
04:32:21 <fasta> Svrog: byte string literals?
04:32:34 <Svrog> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-ByteString.html
04:32:43 <astrolabe> ClaudiusMaximus: thanks
04:32:59 <ClaudiusMaximus> astrolabe: it worked, but i got disillusioned by the fact that mainLoop doesn't return, so i can't use it in ghci
04:33:07 <fasta> Svrog: AFAIK, Data.ByteString should now replace the String type already in the compiler.
04:34:21 <Svrog> i dont think that is the case yet - at least not in the current version
04:34:38 <astrolabe> ClaudiusMaximus: hmmmmm
04:35:25 <Svrog> someone mentioned there was a patch that adds bytestring literals to ghc so you dont have to convert them from strings
04:36:44 <Svrog> about a month ago or so - so i was just wondering if the patch has been added to the latest development version of ghc and if so how do i use bytestring literals? will "string"::ByteString work?
04:37:33 <fasta> Svrog: I don't know
04:38:40 <ClaudiusMaximus> astrolabe: http://tinyurl.com/yz9p7o  here's (part of) the source for a keyboard-controlled spinning hypercube, and here's a sample output  http://tinyurl.com/yhlgsh
04:38:43 <lambdabot> Title: DEVEL.GOTO10.ORG - maximus - Rev 140 - /polytopiary/visualisations/Polytopiary.l ...
04:42:25 <emk> jethr0: It's really obnoxious when "a-b" is an identifier, not a subtraction.
04:44:07 <fasta> Anyone got a link to the State monad with changing type?
04:46:33 <emk> fasta: What do you need, exactly?
04:47:17 <fasta> emk: I pass a value of type Foo () () to the runState function as state. But the state monad expects one of Foo Bar a
04:47:41 <emk> ?t runState
04:47:42 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
04:47:57 <emk> ?type runState
04:47:59 <lambdabot> forall s a. State s a -> s -> (a, s)
04:48:03 <fasta> emk: the first put inside the computation puts the Foo Bar a value in it
04:48:24 <astrolabe> Claudius maximus:  ooooh pretty!
04:48:57 <emk> fasta: The "s" is the state, and the "a" is the return type.
04:49:17 <fasta> emk: yes, I know. I have used the State monad many times.
04:49:30 <emk> OK, just checking. :-)
04:49:47 <fasta> emk: Oleg had a cool trick where you could _change_ the type between puts and gets
04:49:49 <emk> fasta: Use (Maybe Whatever), then.
04:50:16 <fasta> emk: nah
04:50:33 <emk> fasta: Yeah, so that won't work for you. Good luck.
04:52:43 <emk> I don't know of any way to get around the fact that the signature  of >>= will force both "s" to be the same within a single do block.
05:07:35 <paolin1> anyone can tell how asks work ?
05:08:03 <paolin1> first arg is an accessor to the env
05:08:08 <paolin1> second ?
05:08:15 <bd_> asks f = do { env <- ask; return (f env) }
05:08:39 <bd_> so for example you could use asks someFieldAccessor
05:08:45 <bd_> :t asks
05:08:47 <lambdabot> forall a (m :: * -> *) r. (MonadReader r m) => (r -> a) -> m a
05:08:59 <bd_> implied nicely by the type too :)
05:09:14 <paolin1> mmhh , if 'f' is monadic ?
05:09:22 <bd_> f is not monadic
05:09:39 <bd_> f just maps from the environment to the return type
05:09:49 <bd_> even in ReaderT f is not monadic :)
05:10:27 <paolin1> I'm in ReaderT , I have to sit down
05:10:39 <dons> hey all!
05:10:44 * dons waves from PADL
05:10:54 <dons> ?yow
05:10:55 <lambdabot> Finally, Zippy drives his 1958 RAMBLER METROPOLITAN into the faculty
05:10:55 <lambdabot> dining room.
05:11:07 <bd_> paolin1: the above type signature holds in all MonadReaders, including ReaderT :)
05:16:40 <paolin1> noone around, I pastecollect ps t = asks (run t) where
05:16:42 <paolin1>   run _ _ = return $ []
05:16:42 <paolin1>   run x (n:ns)= do
05:16:42 <paolin1>     hs <- lift $ sample n ys -- must lift !!
05:16:42 <paolin1>     rss <- mapM (flip run ns) ys
05:16:42 <paolin1>     return $ hs ++ concat rss
05:16:43 <paolin1>     where ys = subs $ (arra ps) ! x
05:16:59 <Svrog> hi dons
05:17:10 <paolin1> bd_ ,see run is monadic
05:17:43 <paolin1> in fact, does not type check
05:19:55 <paolin1> collect ps t = do
05:19:56 <paolin1>   ns <- ask
05:19:56 <paolin1>   run t ns
05:19:56 <paolin1> .....
05:19:59 <paolin1> this does
05:20:44 <bd_> paolin1: yes, those are not equivalent
05:20:56 <paolin1> bd_ , I cannot use asks here ?
05:20:57 <bd_> asks essentially wraps an implicit return around your function
05:21:11 <bd_> so if your function is monadic, you cannot use asks to invoke it directly
05:21:24 <bd_> what's t?
05:21:59 <paolin1> an Int
05:22:10 <paolin1> index of ps array
05:22:12 <bd_> is it the same for the entire monadic computation?
05:22:48 <paolin1> no,
05:22:48 <bd_> anyway
05:22:49 <paolin1> see ...  mapM (flip run ns) ys
05:23:04 <bd_> oh, I see
05:23:13 <bd_> since run returns a monad you have to use regulas ask
05:23:26 <bd_> asks is useful if your environment is a datatype, and you pass in an accessor function
05:23:49 <paolin1> ok, learned :)
05:23:50 <bd_> I suppose you could join (asks (run ...)) but that's just making things unclear
05:24:32 <paolin1> collect ps t = ask >>= run t
05:27:36 <bd_> yep
05:30:04 <paolin1> can I do StateT s1 (State s2)  a ?
05:31:18 <paolin1> s2 is needed by the library I'm using, but I need more state
05:31:27 <paolin1> for my code
05:33:10 <bd_> paolin1: yes, but, you'll need to lift to get at the inner State
05:33:32 <Svrog> night
05:35:56 <paolin1> wow , it's very incredible I understood that alone, should be I'm using random numbers and they are influencing my learning process :D
05:40:44 <bd_> :)
05:46:31 <malebria>     precedence parsing error
05:46:31 <malebria>         cannot mix `(&&.)' [infix 3] and `(&&.)' [infix 3] in the same infix expression
05:46:40 <malebria> The expression is:
05:46:51 <malebria> "object_type"  ==. object_type  &&. "initial_time" ==. initial_time &&. active
05:47:00 <malebria> Where ==. is infix 4
05:47:35 <malebria> Isn't it the same as: 1 == 2 && 2 == 2 && 2 == 3
05:47:44 <malebria> I'm getting this error in GHCi.
05:47:56 <paolin1> @pl\ lift.lift
05:47:57 <lambdabot> lift . lift
05:48:14 <paolin1> :t lift
05:48:15 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
05:48:36 <paolin1> :t lift.lift
05:48:38 <lambdabot> forall (t :: (* -> *) -> * -> *) (t1 :: (* -> *) -> * -> *) (m :: * -> *) a. (MonadTrans t, Monad (t1 m), MonadTrans t1, Monad m) => m a -> t (t1 m) a
06:24:52 <dmhouse> ?ask apfelmus whether it was him that promised to write the Zippers article for the Wikibook, I can't remember.
06:24:53 <lambdabot> Consider it noted.
06:26:09 <bakert> ?seen shapr
06:26:10 <lambdabot> shapr is in #scannedinavian, #unicycling and #haskell. I last heard shapr speak 5h 20m 1s ago.
06:26:38 <uccus> hiya folks
06:27:54 <uccus> ?seen kowey?
06:27:54 <lambdabot> I haven't seen kowey?.
06:27:56 <uccus> ?seen kowey
06:27:57 <lambdabot> kowey is in #haskell and #darcs. I don't know when kowey last spoke.
06:28:17 <kowey> uccus: hi
06:28:38 <uccus> hi... how's the meta-tutorial project going?
06:29:17 <kowey> well, some people have added some nice links, Cale's tutorials, for example
06:30:00 <kowey> there's also a few more 'practical haskell' type articles (shapr's happs thing ought to go in there somewhere)
06:30:15 <kowey> but otherwise, it hasn't exactly been exploding
06:30:19 <uccus> I was thinking... now that I'm somewhat versed in Haskell... which sections would you like me to contribute to?
06:30:34 <uccus> well, are there lots of tutorials out there anyway?
06:30:38 <dmhouse> The wikibook! :)
06:30:48 <uccus> well.. the wikibooks
06:30:52 <uccus> the wikibook
06:31:17 <dmhouse> uccus: http://en.wikibooks.org/wiki/Haskell/Notes_for_contributors#What_you_can_do
06:31:20 <lambdabot> http://tinyurl.com/vweof
06:31:26 <uccus> I would very much like to help.. it's just that.. I cannot find good topics
06:31:30 <kowey> it depends, the wikibook and the wiki can serve 2 diferent functions
06:31:58 <uccus> right... and somehow it's more confusing that way
06:32:02 <kowey> writing for the wiki is good because of the simple permissive license... and it's nice if you don't want to worry too much about how it fits into a wider context
06:32:25 <kowey> on the other hand, writing for the book is good, because you can work on assuring some semblance of structure
06:32:49 <uccus> say, I sort of ... yeah ... I have an initial text on thunks on the wiki... but should it actually go to the book?
06:33:04 <kowey> the book has quite a few articles imported from the wiki, which are being massaged to fit into the narrative whole
06:33:09 <dmhouse> uccus: how does it compare to http://en.wikibooks.org/wiki/Haskell/Laziness#Thunks_and_Weak_head_normal_form ?
06:33:12 <lambdabot> http://tinyurl.com/ykch9p
06:33:42 <kowey> don't feel shy about completely replacing something if you feel you've got better
06:34:10 <uccus> :( the book text is far better than mine :(
06:34:34 <uccus> ah. I don't seem to make myself very clear.
06:35:46 <uccus> see, suppose you are a newbie. where should you look? the book? the wiki? the old wiki? I shouldn't have written about thunks in the wiki because the wiki is not a place for those... you know... tiny details
06:36:16 <kowey> the wiki can give you a lot of information about a specific topic
06:36:17 <uccus> erm... what I mean to say is, as the wikibook is not really a book, there should be a very detailed glossary, don't you think?
06:36:29 <kowey> the book on the other hand aims to be a pedagogical tool
06:36:39 <kowey> it might not be one at the present stage,
06:36:55 <uccus> so yeah. how can I help? :)
06:37:01 <kowey> but the aim is for somebody to be able to pick it up, and read it "cover to cover", really getting something out of it
06:37:04 <kowey> hmm...
06:37:20 <kowey> well, one thing we're missing is a Haskell and Databases chapter
06:37:30 <kowey> that's the kind of thing i was hoping somebody on the wiki could write, and we could import
06:37:45 <kowey> concurrency would be an excellent topic to tackle
06:37:52 <uccus> which one? which database?
06:37:58 <vincenz> o.O
06:38:01 <kowey> and it's the kind of thing you might want a "book-style" on
06:38:05 <vincenz> They're building a jet-engine on chip
06:38:11 <uccus> yeah of course
06:38:27 <uccus> but which database library?
06:38:36 <kowey> i don't know which, i'm completely ignorant on the matter :-)
06:38:53 <kowey> it's like XML and GUI, you just have to pick one that looks reasonable and say "we'll do this one"
06:39:00 <kowey> "if you want another one, go see the wiki"
06:39:28 <uccus> hmm :) it's hard for a newbie to judge the relative merits of different libraries
06:39:42 <kowey> exactly,
06:39:46 <kowey> that's why we choose for them
06:39:47 <dmhouse> uccus: how about writing about concurrency then?
06:39:48 <uccus> I work mainly on XML, and I keep switching...
06:40:04 <uccus> concurrency... erm... I don't *know* much about it!
06:40:06 <dmhouse> uccus: with a focus on STM? It could be a really great chapter on a really interesting and moreover important topic.
06:40:09 <uccus> ahem
06:40:22 <dmhouse> uccus: what do you know about? :)
06:40:24 <kowey> our text on type classes could use a little loving, a think
06:40:36 <dmhouse> Or you can do what I do, learn about a topic in order to write the wikibook chapter on it. :)
06:40:41 <uccus> yay!! type classes, XML libraries, and Parsec
06:40:46 <kowey> oh, and the higher-order functions chapter is quite a stub
06:41:06 <uccus> really? I can do higher-order functions! [embarrassed]
06:41:16 <dmhouse> uccus: http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying. Go.
06:41:17 <dmhouse> :)
06:41:18 <lambdabot> http://tinyurl.com/uuqak
06:41:25 <kowey> actually, that's probably a pretty high priority!
06:41:30 <uccus> yep
06:41:33 <uccus> yes, sir!
06:41:38 <dmhouse> The difficulty with writing an early chapter, though, is that you can't assume much of the reader.
06:41:58 <kowey> only what s/he has seen in the previous ones
06:42:09 <dmhouse> Exactly.
06:42:24 <kowey> we spent a lot of time rearranging chapters because of unmet dependencies :-)
06:42:28 <kowey> i doubt we're done with taht
06:42:43 <dmhouse> But the more important thing is that we have something down there. We can always add in extra explanations if needed.
06:42:58 <kowey> right, this being a wiki, you don't have to worry about perfection
06:43:18 <ookk> What is the relation between Clean and Haskell?
06:43:23 <ookk> they seem similar
06:43:44 <dmhouse> I think Haskell was originally going to be an extension of Clean, but because Clean was commercialised, that wasn't possible.
06:44:17 <uccus> hmm... Haskell is the successor
06:44:24 <Philippa> dmhouse: that's Miranda you're thinking of, no?
06:44:25 <dmhouse> I'm not sure of the exact differences. I don't think Clean has typeclasses, which are a major design element in Haskell.
06:44:30 <dmhouse> Philippa: ah, probably.
06:44:34 <uccus> but, without uniqueness typing.
06:44:43 <ookk> Clean has strictness also?
06:44:47 <uccus> yes
06:45:12 <uccus> but (as far as I remember) no monads
06:45:47 <xerox> ☆☆☆
06:45:49 <ookk> ok so no do-notation then?
06:46:04 <vincenz> hey Philippa
06:46:22 <Philippa> hi vincenz
06:46:57 <fasta> "Can hurt performance in some other cases." <- understatement of the year ...
06:47:47 <kowey> fasta: http://en.wikibooks.org/wiki/Haskell/Strictness wants you! :-)
06:47:48 <uccus> ookk: I'm not sure. most probably no/
06:47:50 <dmhouse> kowey: we need to find someone to write about Graph Reduction.
06:48:15 <kowey> yeah, maybe importing the wikipedia article will cause something to happen
06:48:30 <kowey> sort of bait people with it, gross disatissfaction = quality
06:48:31 <dmhouse> It's referenced a lot from denotational semantics.
06:49:24 <fasta> "It is by the magic of thunks that laziness can be implemented." <- magic? I don't think so.
06:49:31 <uccus> kowey: umm... this is hard, Eric, I think most ideas related to "Higher order functions" was already introduced in "more about lists" :|
06:49:49 <paolin1> :t runReaderT (runStateT a b) c
06:49:55 <lambdabot> Not in scope: `a'
06:49:55 <lambdabot>  
06:49:55 <lambdabot> <interactive>:1:24: Not in scope: `b'
06:50:15 <fasta> dmhouse: for graph reduction I think a program illustrating it would be better, but I don't think anyone has the time to do so.
06:50:52 <uccus> kowey: forget what I said. it just means I have to build on those ideas.
06:51:26 <dmhouse> uccus: certainly some of the stuff from More about lists should be moved to the HOFs chapter.
06:51:26 <paolin1> :t forall a b c . runReaderT (runStateT a b) c
06:51:28 <lambdabot> Not in scope: `forall'
06:51:28 <lambdabot>  
06:51:28 <lambdabot> <interactive>:1:7: Not in scope: `a'
06:51:42 <dmhouse> I'm looking at MAL and it's explaning curried types, that's definitely not the write place for it.
06:52:07 <uccus> kowey: _and_ List processing... damn!
06:52:07 <paolin1> @pl\  runReaderT (runStateT a b) c
06:52:08 <lambdabot> runReaderT (runStateT a b) c
06:52:18 <kowey> uccus: also feel free to move things around! (you might want to take a look around and see how things tie together)
06:52:28 <kowey> there's probably a good chunk of redundancy in that book
06:52:41 <uccus> not a good idea. will mess up things faster than you can say 'mess up'
06:52:47 <uccus> yep
06:52:57 <kowey> acrete-and-cut :-)
06:52:59 <dmhouse> uccus: write what you want, then we can merge/delete/move bits as necessary.
06:53:03 <uccus> redundancy is not necessarily a bad thing
06:53:04 <dmhouse> That's probably the best tactic.
06:53:12 <uccus> dmhouse: okay
06:53:32 <dmhouse> Plus I prefer to write my own stuff more than try to merge with what someone else thinks. :)
06:53:45 <xerox> paolin1: (runReaderT .) . runStateT
06:53:51 <kowey> redundancy can work if you shift angles, "we've seen this in one context, now let's step back and look at it another way"
06:54:12 <kowey> or "we've seen these scattered throughout, now what happens if we gather them up and put them together as one central idea"
06:54:25 <xerox> paolin1: or let (.:) = (.) . (.) in runReaderT .: runStateT
06:54:34 <goltrpoat> fasta:  i was actually asking about the state of GHood earlier.  the project seems to be dead, but it seemed like a good idea, and on the VM side, it's probably about as good as you can get as far as a "program illustrating graph reduction" is concerned
06:56:09 <vincenz> xerox: nice
06:56:32 <vincenz> > let (...) = (.) . (.) in (+) ... (*)
06:56:34 <lambdabot>  Add a type signature
06:56:36 <vincenz> @type let (...) = (.) . (.) in (+) ... (*)
06:56:38 <lambdabot> forall a. (Num a) => a -> a -> a -> a
06:56:47 <vincenz> > let (...) = (.) . (.) in (+) ... (*) 2 3 4
06:56:48 <lambdabot>   add an instance declaration for (Num (t -> a -> a1 -> b))
06:56:54 <vincenz> > let (...) = (.) . (.) in (+) ... (*) $ 2 3 4
06:56:54 <lambdabot>   add an instance declaration for (Num (t -> t1 -> a))
06:56:56 <xerox> add parens
06:56:56 <vincenz> hmm
06:57:02 <vincenz> > let (...) = (.) . (.) in ((+) ... (*)) 2 3 4
06:57:05 <lambdabot>  10
06:57:20 <vincenz> ... is great :)
06:57:25 <dmhouse> Sweet.
06:57:44 <xerox> Special case of more general composition of n-arty function with unary one, which is the composition of n (.).
06:57:49 <xerox> n-ary
06:58:55 <vincenz> @type let (....) = (.) . (.) . (.) in (....)
06:58:56 <lambdabot> forall b c a a1 a2. (b -> c) -> (a -> a1 -> a2 -> b) -> a -> a1 -> a2 -> c
06:59:17 <vincenz> I think the ... case is more generally used than other ...'s tho
07:20:48 <efuzzyone> hi, i am trying to use the function 'ord' but it gives me error "not in scope"
07:20:54 <efuzzyone> what does this means?
07:21:07 <bakert> you need to import the module it is in
07:21:15 <bakert> ?hoogle ord
07:21:16 <lambdabot> Char.ord :: Char -> Int
07:21:16 <lambdabot> Prelude.Ord :: class Eq a => Ord a
07:21:16 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
07:21:23 <bakert> It's in Char
07:21:34 <bakert> so you need "import Char" at the top of your source file
07:21:51 <efuzzyone> bakert: thanks
07:21:55 <bakert> efuzzyone, np
07:22:00 <mauke> @index ord
07:22:01 <lambdabot> Data.Char
07:22:19 <bakert> ah.  so he needs to import Data.Char, mauke?
07:22:38 <mauke> depends; Char is the haskell98 module
07:22:56 <efuzzyone> is there any lamdabot like thing in the interpreter which can help?
07:23:08 <mauke> @where gao
07:23:09 <lambdabot> I know nothing about gao.
07:23:14 <efuzzyone> or something which opens up the doc for a function?
07:23:36 <wolverian> @where goa
07:23:36 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
07:23:50 * wolverian pets mauke
07:34:21 <vincenz> efuzzyone: there's a commandline lambdab-to
07:34:28 <vincenz> lambdabot
07:36:45 <pbx> Working through YAHT this morning... can anyone explain (or point me to an explanation) of why  these two are not equivalent? I thought that [a,b,c] list notation was just syntactic sugar for a:b:c:[] ?    http://dpaste.com/4663/
07:37:27 <mauke> precedence
07:37:38 <goltrpoat> (2:3:[])
07:37:52 <mauke> your second line parses as (foldr (+) 1 2) : 3 : []
07:37:55 <vincenz> function application binds tighter than :
07:38:27 <bakert> isn't (:) a function?
07:38:39 <mauke> yes, why?
07:39:07 <dylan> : is also a type constructor.
07:39:08 <bakert> " function application binds tighter than :"  -- it's actually because (:) is to the right of the other stuff, no?
07:39:21 <bakert> no
07:39:57 <dmhouse> _Prefix_ function application binds tighter than _infix_ function application.
07:40:02 <dmhouse> That's what vincenz meant.
07:40:05 <pbx> Excellent, thanks for the clarification!  I had actually tried parenthesizing, but did it wrong.
07:40:09 <bakert> i see.
07:40:12 <bakert> thanks dmhouse
07:40:30 <Jaak> > 1 : 2 : 3 : []
07:40:32 <lambdabot>  [1,2,3]
07:40:45 <Jaak> mhmhh
07:42:00 <Jaak> > (+1) 1 : 2 : 3 : []
07:42:01 <lambdabot>  [2,2,3]
07:50:51 <efuzzyone> how do i convert a string to int, putStrLn 2, doesn't work?
07:50:59 <sorear> read
07:51:01 <mauke> putStrLn (show 2)
07:51:02 <sorear> > read "3"
07:51:03 <lambdabot>  Add a type signature
07:51:08 <sorear> > read "3" :: Integer
07:51:10 <lambdabot>  3
07:51:17 <mauke> or simply print 2
07:51:18 <efuzzyone> thanks
07:51:50 <DracoCepheus> if i want to write a simple parser what should i learn first?
07:51:58 <Botje> parsec
07:52:14 <mauke> how to write your own monadic parser
07:52:24 <dmhouse> efuzzyone: you can actually just use print 2. print x = putStrLn (show x)
07:52:57 * dmhouse adds a fourth image to his category theory introduction
07:52:58 <sorear> my first parser wasn't even monadic ... hand-written CPS recursive descent.
07:53:08 <dmhouse> I think I'm becoming addicted to Inkscape.
07:53:10 <DracoCepheus> why must it be monadic?
07:53:17 <vincenz> dmhouse: yeah, it's quite nice
07:53:19 <mauke> because it's easier
07:53:26 <sorear> it became *much* more readable when I rewrote it using parsec
07:53:41 <DracoCepheus> CPS?
07:53:44 <efuzzyone> thanks dmhouse, i actually wanted to append the number to a string
07:53:49 <sorear> Continuation passing styl
07:53:56 <sorear> ?jargon cps
07:53:58 <lambdabot> No match for "cps".
07:54:05 <sorear> ?all-dicts cps
07:54:06 <lambdabot> *** "cps" wn "WordNet (r) 2.0"
07:54:07 <lambdabot> cps
07:54:07 <lambdabot>      n : the unit of frequency; one Hertz has a periodic interval of
07:54:07 <lambdabot>          one second [syn: {Hertz}, {Hz}, {cycle per second}, {cycles/second},
07:54:07 <lambdabot>           {cycle}]
07:54:08 <lambdabot> [22 @more lines]
07:54:18 <xerox> ?foldoc cps
07:54:19 <lambdabot> *** "cps" foldoc "The Free On-line Dictionary of Computing (27 SEP 03)"
07:54:19 <lambdabot> CPS
07:54:19 <lambdabot>  
07:54:19 <lambdabot>         1. Conversational Programming System.  An interactive extended
07:54:19 <lambdabot>         subset of {PL/I} from {Allen-Babcock} Corp in 1965.
07:54:21 <lambdabot> [8 @more lines]
07:54:27 <xerox> ?more
07:54:31 <lambdabot>  
07:54:35 <lambdabot>         ["Conversational Programming System under TSO (PBPO), Terminal
07:54:39 <lambdabot>         User's Manual", SH20-1197, IBM].
07:54:44 <vincenz> continuation passing style
07:54:45 <dmhouse> DracoCepheus: http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style but it's a whole other kettle of fish.
07:54:45 <lambdabot> Plugin `more' failed with: IRCRaised thread killed
07:54:47 <lambdabot> Title: Haskell/Continuation passing style - Wikibooks, collection of open-content textb ...
07:55:02 <dmhouse> You certainly don't need to learn it to learn parsing. Just learn Parsec or something similar.
07:55:24 <DracoCepheus> yes, but i am new to FP
07:55:27 <sorear> don't learn it for parsing.  I have regrets on not using parsec.
07:55:32 <DracoCepheus> scared of parsec ... :-)
07:55:36 <mauke> you'll learn a lot by writing your own parsec-style library :-)
07:56:27 <sorear> if full immersion isn't your cup of tea, I understand there is also a yacc clone (happy)
07:56:45 <vincenz> happy is quite nice
07:56:50 <vincenz> especially when defining your own monad
07:57:12 <DracoCepheus> yes, i know a bit of yacc
07:57:45 <DracoCepheus> do u think happy is easier to learn than parsec?
07:57:50 <vincenz> no
07:57:52 <vincenz> parsec is easier
07:57:59 <vincenz> but parsec is LL
07:58:04 <vincenz> which in some cases is less than idea
07:58:05 <vincenz> +l
07:58:25 <pejo> If you know flex/bison the step to alex/happy shouldn't be that far.
07:58:31 <vincenz> pejo: false and true
07:58:46 <vincenz> pejo: yes: it is much like flex/bison, but no, if you want anything meaningful you'll have to roll your own monad underneath it
08:00:27 <sorear> of course there are many others (ReadP, I've heard allusions to both an arrow parser and an applicative functor parser), but you'll get the most support with parsec.
08:00:32 <DracoCepheus> is ''rolling your own monad" a big part of FP, or is it a haskell thing?
08:00:47 <vincenz> monads are typical to haskell specifically
08:00:47 <sorear> haskell
08:01:05 * vincenz has a std monad he always uses for rolling alex-happy parsers
08:01:08 <vincenz> it's quite generic and nice :)
08:01:15 <sorear> you can implement them in any language, but they're only idiomatic here
08:02:16 <DracoCepheus> well, can someone give a one sentance description of what a monad is?
08:02:24 <vincenz> a monad is a container
08:02:39 <DracoCepheus> ok, but so is a list
08:02:43 <vincenz> yes
08:02:44 <vincenz> a list is a monad
08:02:48 <mauke> lists are monads
08:02:52 <vincenz> heh
08:02:54 <vincenz> this sounds like taoism
08:03:01 <vincenz> "the path that can be spoken is not the path"
08:03:07 <vincenz> or some other such vague sentence
08:03:51 <pejo> The monads probably show up in other languages too, but not that many have been designed after Haskell and gotten a large community.
08:03:51 <emk> www.haskell.org is really slow right now...
08:04:17 <emk> Is something wrong with the server?
08:04:27 <emk> ?hoogle regex
08:04:28 <lambdabot> Text.Regex :: module
08:04:28 <lambdabot> Text.Regex.Regex :: data Regex
08:04:28 <lambdabot> Text.Regex.Posix.regexec :: Regex -> String -> IO (Maybe (String, String, String, [String]))
08:05:11 <emk> Ah, now it's working.
08:10:04 <ndm> http://haskell.org
08:10:18 <ndm> http://darcs.haskell.org
08:10:23 <lambdabot> Title: Index of /
08:10:24 <ndm> do either of those links work for people?
08:10:59 <Jaak> darcs one does
08:11:00 <sorear> I can access {planet.,}haskell.org
08:11:02 <sorear> slowly
08:11:10 <Jaak> oh no, both do
08:11:12 <mauke> darcs works
08:11:16 <ndm> hmm, one of the Yhc buildbot's is dying trying to get from darcs
08:12:15 <ndm> it can't resolve the host for darcs.haskell.org
08:12:38 <vincenz> ndm++ -- for the sincerity of your blog post on hat
08:12:45 <ulfdoz> darcs.haskell.org is an alias for haskell.galois.com.
08:12:46 <ulfdoz> haskell.galois.com has address 69.30.123.197
08:12:46 <ulfdoz> darcs.haskell.org is an alias for haskell.galois.com.
08:12:46 <ulfdoz> darcs.haskell.org is an alias for haskell.galois.com.
08:12:57 <ulfdoz> It is not the dns.
08:13:01 <vincenz> o.O
08:13:16 <ndm> vincenz: thanks, its harder to be sincere when you have lunch with half of the hat developers every day...
08:13:23 <ndm> but i thought it was necessary
08:13:26 <sorear> I think I might fix lambdabot for 6.7 just so I can use the debugger :)
08:13:36 <ndm> its really neat
08:13:40 <vincenz> ndm: well keep on hacking :)
08:13:43 <pejo> ulfdoz, your ns might have it cached.
08:13:46 <ndm> i noticed that Pepe was doing quite a few "tricks" to get it to do things
08:13:53 <ndm> things like: x `seq` ()
08:14:04 <ndm> to evaluate x to WHNF before printing it
08:14:18 <ndm> so it looks like it has a small learning curver, but didn't seem much at all
08:14:21 <sorear> ndm: in the GHC User's Manual, those tricks are documented - are they still tricks?
08:14:28 <ulfdoz> pejo: It hasn't. I'm absolutely sure.
08:14:38 <ndm> sorear: i guess not, i haven't read the user manual
08:14:56 <ndm> they are a learning curve though
08:15:05 <sorear> I'm suprised it was updated so quickly...
08:15:17 <ndm> the manual?
08:15:23 <sorear> True
08:15:50 <ndm> Yhc has a manual on a wiki, the manual remains in very good shape that way
08:16:32 <pejo> ndm, you asked someone whether they wanted to write a type checker for yhc, doens't it have a typechecker already?
08:16:52 <ndm> pejo: yes, but its crap and confusing - we need a new one
08:17:13 <pejo> ndm, ahh, ok
08:17:31 <emk> Does anybody remember when Text.Regex was added to the standard Haskell libraries?
08:17:36 * sorear wonders how efficient his 5-line pattern-matching unifier would become with memoization
08:17:40 <vincenz> ndm: what's yhc written in?
08:17:56 <sorear> emk: haskell.org/ghc/docs/
08:17:56 <ndm> vincenz: Haskell
08:18:19 <sorear> you can access the 6.2, 6.0, ... 0.29 HTML docs, incl. library lists
08:19:55 <emk> sorear: It's down again. :-(
08:20:07 <emk> haskell.org is really flaky today.
08:22:59 <sorear> too bad hoogle doesn't give haddock output :(
08:23:30 <uccus> kowey: you there? any pointers on http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying?
08:23:34 <lambdabot> http://tinyurl.com/ybcvtw
08:23:37 <kolmodin> haskell.org seems offline
08:23:46 <sorear> fortunately, I have a local GHC source tree, so I can read the answer to: does threadDelay take microseconds or milliseconds?
08:23:47 <uccus> kolmodin: yeah
08:24:00 <ndm> sorear: what exactly are you asking for with hoogle?
08:24:04 <kolmodin> bummer :(
08:24:22 <kowey> uccus: reading it now
08:24:39 <uccus> kowey: instruct me where to insert exercises and which ones
08:25:00 <sorear> ndm: threadDelay , and the Haskell type system doesn't distinguish milli from micro
08:25:15 <uccus> kowey: you know, to make it more haskell-wikibook-like
08:25:16 <ndm> sorear: i meant in terms of hoogle
08:25:42 <emk> What's the best Haskell to use on the Mac, assuming I want access to lots of third-party libraries? Am I better off using DarwinPorts?
08:25:50 <sorear> maybe it does make more sense as a separate tool...
08:26:00 <emk> That seems to be the only way to get a lot of C-based libraries.
08:26:02 <uccus> kowey: and feel free to correct grammar/spelling things! English is not my native tongue!
08:26:05 <pejo> emk, better off and better off, darwinports are very easy to use.
08:26:13 <ndm> sorear: in Hoogle 4 haddock information is embedded in teh hoogle database
08:26:37 <sorear> oooh. /me can't wait for lambdabot to support Hoogle 4
08:26:59 <emk> pejo: OK, I'm building it in the background. Do you know whether I need to uninstall the standalone version of GHC first?
08:27:11 <paolino> @src Identity
08:27:12 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
08:27:13 <sorear> oh wait. I have a source tree and a reputation.  Is Hoogle 4 "stable" yet?
08:27:22 <emk> ndm: Oh, that's sweet.
08:27:24 <pejo> emk, unless you put darwinports in the same place as the other ghc, you shouldn't need to.
08:27:39 <emk> pejo: Thanks!
08:27:52 <ndm> sorear: do not use it! seriously alpha
08:28:19 <ndm> sorear: in fact, i think few people would even be able to figure out how to build it, and lots of stuff doesn't work at all
08:28:22 <kowey> uccus: i think the case-sensitivity point could be made a little bit more explicit
08:28:24 <ndm> but the haddock embedding does
08:28:38 <uccus> kowey: I thought the use-case makes perfect sense for currying too! double = map (2*) makes less sense to most people
08:28:42 <uccus> kowey: what do you mean?
08:29:19 <kowey> i agree that it's a good use case
08:29:32 <paolino> @src  (>>=):: Identity a -> (a -> Identity b) -> Identity b
08:29:33 <lambdabot> Source not found. I feel much better now.
08:29:39 <uccus> kowey: thanks!
08:29:48 <uccus> kowey: uses recursion too!
08:29:49 <kowey> well, it's not immediately obvious to the reader why case-insensitivity would be a problem
08:29:53 <sorear> @src Identity >>=
08:29:54 <lambdabot> Source not found. You speak an infinite deal of nothing
08:29:58 <uccus> okay, I see it
08:29:59 <kowey> maybe a little example would suffice
08:30:07 <uccus> @src Ordering
08:30:08 <lambdabot> data Ordering = LT | EQ | GT
08:30:22 <sorear> @src [] >>=
08:30:22 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
08:30:23 <kowey> (an example of what we'd like to happen when you sort without case)
08:30:26 <Jaak> @src Identity (>>=)
08:30:27 <lambdabot> m >>= k  = k (runIdentity m)
08:30:29 <uccus> I didn't know about the @src command...
08:30:38 <sorear> It's very new
08:30:47 <uccus> kowey: right. can you suggest something?
08:31:20 <uccus> kowey: or should it be as random an example as the current one?
08:31:34 <uccus> @src liftM2
08:31:35 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
08:31:46 <emk> Building GHC makes my iBook cry. :-(
08:31:54 <kowey> uccus: i didn't have any specific examples in mind; let's see what you come up with :-)
08:31:56 <notsmack> does gtk2hs not work with 6.6 yet?
08:32:13 <uccus> kowey: ok, be right back in a minute to work on it
08:32:26 <emk> notsmack: That's a really good question, because I just started building GHC 6.6 to get gtk2hs.
08:33:14 <sorear> gtk2hs works with 6.6
08:33:21 <sorear> (at least the darcs version)
08:33:29 <notsmack> right, just the darcs version
08:33:32 * sorear weekly compiles GHC-head
08:33:48 <emk> The darcs version of gtk2hs?
08:33:54 <uccus> @src toLower
08:33:54 <lambdabot> Source not found. The more you drive -- the dumber you get.
08:33:59 <Saizan> uccus: i would prefer source first and results after, and you could put something like  insensitivequicksort = quicksort insensitive
08:34:19 <notsmack> emk: yeah.  which i can't get to build
08:34:28 <uccus> Saizan: my plan is to demonstrate currying by that
08:34:36 <notsmack> ./configure: line 3805: syntax error near unexpected token `WIN32,'
08:34:45 <sorear> building GHC takes 90mins and takes my CPU to 2 C below the factory preset alarm threshold
08:34:45 <notsmack> wrong autoconf maybe?
08:35:16 <emk> sorear
08:35:43 <emk> sorear: Maybe I should open the window and put my laptop in the winter breeze, then. :-)
08:37:35 <emk> I hope that gtk2hs builds out of the box with DarwinPorts and plays nicely with DarwinPorts GHC, because it will take all day to build them.
08:37:47 <kowey> uccus: maybe as an exercise, you could get the reader to play with functions like Data.Ord.comparing
08:38:57 <kowey> another thing you could point out is that the inner functions (usual, insensitive, etc) could also be used in other contexts, e.g. nubBy, groupBy, etc
08:40:03 <emk> ?type nubBy
08:40:05 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
08:40:12 <kowey> oops!
08:40:22 <kowey> yes, not nubBy, then
08:40:51 <uccus> kowey: sure
08:41:31 <kowey> now finally some opinions about style
08:42:12 <kowey> i saw that YAHT has a policy of using "we-language" as opposed to "i and you language" (I am quite guilty of the latter)... and I think Hal is right about that
08:42:55 <kowey> it would probably be good to steer towards treating the reader as part of "us", we're taking this journey together sort of thing
08:43:06 <uccus> kowey: right
08:43:15 <kowey> (besides, it makes sense to use "we" over "I" since this there are so many authors)
08:43:31 <kowey> (i have written "I" many times; i need to fix that too :-) )
08:43:46 <notsmack> configure.ac:26: error: possibly undefined macro: AM_INIT_AUTOMAKE
08:44:03 <notsmack> anybody know what i'm doing wrong?
08:44:07 <kowey> also, it's really great that we're being friendly and enthusiastic!
08:44:15 <allbery_b> wrong version of autotools?
08:44:26 <kowey> but it helps also to moderate our tone a bit so the reader doesn't feel s/he's being patronised
08:44:33 <notsmack> allbery_b: could be, just tried 2.60 and 2.61...
08:44:38 <dmhouse> uccus: the 'Now, how do we use it?' section ends a bit abruptly. I'd insert a linking sentence in, something akin to 'We answer these questions in the following section.'
08:44:42 <allbery_b> need to run automake first?
08:44:57 <kowey> (i am also guilty of this heavy-handed friendliness; that's why i notice it!)
08:45:09 <uccus> dmhouse: consider it noted
08:45:26 * allbery_b is not very experienced with autotools but knows they have to be run in a particular order or things tend to go odd
08:45:39 <kowey> uccus: but don't worry too much about style stuff; that's the kind of thing that the community tends to fix by itself
08:45:40 <notsmack> hmm, same error with automake first
08:45:53 <allbery_b> aclocal; automake; autoconf
08:46:05 <allbery_b> possibly some other stuff in between
08:46:23 <allbery_b> autoreconf, in sufficiently recent versions of autoconf, should do motsly the right thing I think
08:46:24 <notsmack> allbery_b: thanks, aclocal fixed it
08:48:00 <allbery_b> yeh, aclocal gathers all the autoconf macros used by everything else, you will get errors if you don't run it first
08:49:01 <notsmack> ?where happy
08:49:02 <lambdabot> http://www.haskell.org/happy/
08:49:26 <kowey> in any case, uccus++ (it's a delight to see the wikibook pushing forward) [ consider maybe creating a wikibooks acct so that we know it's you editing the pages ]
08:49:36 <uccus> hehe, thanks
08:49:58 <uccus> ah! this reminds me! I already _have_ a wikibook account
08:52:02 <psnl> @remember conor If you're interested, or even if you've only been threatened by your supervisor
08:52:02 <lambdabot> Done memoising quote for `conor', if that is their real name...
08:53:51 * ndm contemplates giving a talk
08:54:06 <ndm> (i have to give one on thursday to my research group, but a FITA talk)
08:54:18 <psnl> on?
08:54:22 <leed> @where fromInt
08:54:22 <lambdabot> I know nothing about fromint.
08:54:35 <ndm> Play, a Scrap Your Boilerplate competitor
08:54:49 <ulfdoz> leed: fromInteger iirc.
08:55:11 <sorear> SYB has competitors?!  where can I find out more about Play?
08:55:38 <ndm> sorear, http://www.cs.york.ac.uk/fp/darcs/play/play.htm
08:55:41 <lambdabot> Title: Play With Your Boilerplate
08:55:43 <sorear> of course, "deriving(Data)" makes SYB superior to almost everything else :)
08:56:02 <ndm> sorear: Play has SYB instances, so deriving Data works just as well for Play
08:56:18 <leed> u1fdoz, thank you
08:57:46 * dylan just realized Scrap Your Boilerplate is a pun
08:58:18 <ndm> dylan: how do you mean?
08:58:34 <dylan> Do you know what a boilerplate originally meant?
08:58:49 <ndm> ah, got it!
08:58:53 <vincenz> ?
08:58:54 <ndm> never spotted that before
08:58:58 * psnl pats ndm 
08:59:17 <sorear> ndm: the paper you pointed me to has unbalanced '<' inside <PRE>
08:59:44 <sorear> fortunately the HTML is readable...
08:59:53 <ndm> sorear: yes, intentionally - getting rid of them is a pain when hand authoring
08:59:56 <ndm> sorear: which browser?
09:00:14 <sorear> elinks
09:00:28 <paolin1> mmhh, shouldn't be type of (>>=) (a->m b) ->(b->m c) ->(a -> m c) ?
09:00:33 <ndm> sorear: any normal browser should support it
09:00:53 <ndm> sorear: there is the issue that some browsers treat &amp; in a pre as literal text
09:01:10 <Philippa> paolin1: no, no it shouldn't
09:01:35 <Philippa> otherwise you couldn't do getChar >>= putChar, for example
09:02:17 * paolin1 's castle made of sand falls in the sea , eventually
09:02:21 <uccus> kowey: about your note... erm... I'm sorry I used compare there... but using (<) would completely destroy the example, don't you think? :)
09:02:56 <kowey> uccus: how so? (i might not be paying enough attention)
09:03:15 <kowey> i thought < works on anything you can compare
09:03:25 <paolin1> it's m b that sometimes is a function ?
09:03:38 <uccus> kowey: the point was to abstract away the comparison function... if you use (<), it will compare using the functions from Ord...
09:04:10 <uccus> kowey: the fault is mine, I used 'compare' instead of the passed function 'comparison'
09:04:18 <allbery_b> :t (>>=)
09:04:20 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m a -> (a -> m b) -> m b
09:04:39 <sorear> paolin1: that function is called >=> in GHC head
09:04:48 <uccus> kowey: now it's corrected... I guess I will have to change the note as well
09:04:52 <kowey> uccus: i thought (<) was defined in terms of compare?
09:05:15 <kowey> uccus: then again, this is a subtle technical point which might confuse the reader more than anything else
09:05:22 <kowey> so maybe it's worth removing the note
09:05:56 <uccus> kowey: umm... suppose you passed Strings... to sort, (<) will compare them using the compare in Ord String... but we don't want that here... for example, when we are doing a descending sort
09:06:11 <dylan> ndm: escaping html entities should be easy with a given text editor.
09:06:14 <ndm> kowey: you can define compare in terms of <, or < in terms of compare
09:06:19 <kowey> uccus: oh, i see what you mean now!
09:06:32 <ndm> dylan: it would be, but editing the source by hand its much easier to write the code as it is, rather than encoded
09:06:52 <paolin1> @src Maybe (>>=)
09:06:52 <lambdabot> (Just x) >>= k      = k x
09:06:53 <lambdabot> Nothing  >>= _      = Nothing
09:06:58 <uccus> kowey: so I guess the note should clarify this as well? or will it be too complicated?
09:07:05 <ndm> dylan: and it does pass as valid with the W3C validator, which surprised me a bit...
09:07:42 <paolin1> @src IO (>>=)
09:07:42 <lambdabot> m >>= k     = bindIO m k
09:07:51 <kowey> uccus: i think we can just remove the note.  sorry for that!
09:08:02 <uccus> no worries!
09:08:09 <uccus> I'll do it
09:08:47 <paolin1> @src [] (>>=)
09:08:47 <lambdabot> m >>= k     = foldr ((++) . k) [] m
09:09:33 <dylan> ndm: ah, in that case I'd write it to a file and just include it when done with some sed magic.
09:10:09 <ndm> dylan: yeah, that makes sense - this is in the repo though, so the generated version should go elsewhere, i'd guess
09:10:26 <paolin1> @src Reader (>>=)
09:10:26 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:10:48 <paolin1> @src Control.Monad.Reader (>>=)
09:10:48 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:11:14 <Philippa> paolin1: m b is something that yields a value of type b
09:11:30 <Philippa> so it's "sort of" a value, a bit like the way from something like C a thunk is "sort of" a value
09:12:02 <dylan> ndm: of course, I'm possibly pathological. I use templates for any complicated type of file I edit... Even on windows, I've used templates to generate registry entry files...
09:12:58 <paolin1> @italian yield
09:12:58 <lambdabot> Unknown command, try @list
09:13:09 <ndm> dylan: yeah, i can understand that approach, but you loose the immediateness of being able to link into the darcs repo directly - plus Html is simple enough (with the right css magic etc) to do it plain
09:13:34 <dylan> ndm: Then I just create virtual filesystems using FUSE. :)
09:14:20 <dylan> oh, for being in darcs. That's a problem. But you could just have a apply hook that builds stuff. (but for m4'd files in /etc/, a virtual filesystem is quite useful)
09:14:58 <dylan> I also have a very broken vfs for accessing and modify the contents of the X11 clipboard...
09:15:21 <ndm> hmm, my method seems simpler
09:15:33 <ndm> and all other browsers are more than capable of displaying it properly...
09:15:44 <dylan> My methods are often very complex, however result in me not having to think as much later.
09:15:53 <dylan> Or so I tell myself.
09:17:11 <dylan> I wonder, <pre> could be declared contain CDATA
09:17:20 <dylan> that would explain why it validates.
09:17:30 <paolin1> @src concatMap
09:17:30 <lambdabot> concatMap f = foldr ((++) . f) []
09:17:37 <allbery_b> dylan: sounds like you're reinventing plan9, poorly :)
09:19:29 <dylan> allbery_b: well, I do whatever is easiest at the time. I needed to keep screen's selection buffer in sync with X's, and screen doesn't like fifos.
09:20:01 <paolin1> is there a way to factor 'i' in
09:20:02 <paolin1> collect i >>= choice i   ?
09:20:27 <Botje> @pl \i -> collect i >>= choice i
09:20:27 <lambdabot> liftM2 (>>=) collect choice
09:21:27 * dylan cheers for @pl
09:22:18 <Botje> yes. @pl for president
09:22:26 <ndm> dylan: i did try and add CDATA tags,  but they didn't really work (can't remember why)
09:23:05 <sorear> play looks very neat
09:23:09 <paolin1> uhm , lifting >>= is too much for me :/
09:23:15 <dylan> ndm: nono, I mean, the contents of <pre> are treated as if they're in CDATA tags, just like <style></style>
09:23:42 <dylan> I'm too lazy to read the DTD though.
09:23:48 <ndm> dylan: yeah, i understand
09:23:54 <mauke> paolin1: don't worry, it's just the ((->) e) monad
09:24:16 <sorear> <nitpick> PlayEx is no better than SYB extension-wise because the form of rank-two types used by SYB can be uglily but automatically translated to MPTCs
09:25:46 <paolin1> mauke: how I import it ?
09:26:02 <mauke> import Control.Monad.Reader
09:26:13 * allbery_b notes, vis-á-vis syntaxfree's blogged debugger fun, that hat is a valiant attempt to do via source annotation what really needs to be built into the compiler
09:26:47 <paolin1> I have it already imported but that line doesn't type check anymore
09:26:49 <allbery_b> ...and even then could be problematic in a multithreaded program
09:26:55 <sorear> allbery_b: syntaxfree too?
09:27:01 <allbery_b> maybe I misremember
09:27:06 <sorear> ndm
09:27:12 <ndm> sorear:
09:27:29 * allbery_b slaps himself.  ndm
09:27:57 <paolin1>       Expected type: StateT (Nodes s) (ReaderT [Int] (State g))
09:27:58 <paolin1>       Inferred type: (->) Int
09:28:12 <allbery_b> anyway.  thought about how to do that robustly with source annotatin and got a major headache :)
09:28:21 <Jaak> Control.Monad.Cont ?
09:28:21 <paolin1> probably that @pl doesn't apply everywhere
09:28:30 <mauke> it should
09:28:32 <sorear> paolin1: you hace to use runStateT, you can't just apply a StateT to a value
09:28:50 <mauke> paolin1: did you forget the i?
09:29:00 <paolin1> yes
09:29:03 <mauke> liftM2 (>>=) collect choice i
09:29:24 * allbery_b should probably try to install hat just to see what it's doing
09:29:33 <ndm> sorear: the point is not to use less extensions (although that is a goal), the point is that the way the user interacts with it is much simpler - less extensions leak into the users world
09:29:39 <paolin1> :)
09:30:16 <paolin1> haskell is not clever, it forgot to add the variable
09:30:35 <ndm> sorear: plus the MPTC's can be translated into SPTC's for Play - something not in the document yet
09:30:37 <allbery_b> a little *too* pointfree :)
09:31:01 <uccus> kowey: you still there? can you have a look at the minor changes I made to the wikibook page?
09:31:22 <kowey> uccus: sure... i'll be a while though; trying to explain some monad stuff
09:31:37 <uccus> ok no worries
09:32:11 <sorear> ndm: yes.  my translation (BTW: is it common knowledge?) requires, among other thing, lambda lifting.  User simplicity is Good.
09:32:48 <ndm> sorear: not sure, there are lots of results in that area, i know very few of them
09:33:17 <notsmack> alright, another gtk2hs error:
09:33:22 <notsmack> Loading package gtk-0.9.10.4 ... linking ... <interactive>: /usr/local/lib/gtk2hs/HSgtk.o: unknown symbol `gtkzm0zi9zi10zi4_DataziTree_Node_con_info'
09:33:30 <ndm> sorear: allOver is the big win of my library, which isn't in SYB
09:40:59 <sorear> is putMVar interruptable if the MVar is empty?
09:41:20 <lokojones> probably the most stupid question ever asked on this channel, but: I have one Int and one Float. I want to do Int*Float and to get an Int, because I know it will always be exact numbers. How do I do this?
09:41:38 <sorear> fromIntegral
09:41:46 <dons> hehe. I have 97 Haskell libraries in my ~/src
09:41:54 <dons> how cool is that? :)
09:42:03 <lokojones> i've been trying all kind of things with fromIntegral
09:42:03 <sorear> > fromIntegral (2 :: Int) * (4.4 :: Float)
09:42:04 <lambdabot>  8.8
09:42:08 * ndm can't remember the command line flags to get my PhD working...
09:42:09 <sorear> btw, don't use Float
09:42:10 <lokojones> but what does fromIntegral return?
09:42:14 <mauke> > round ((2 :: Int) * fromIntegral (2.5 :: Float))
09:42:15 <lambdabot>   add an instance declaration for (Integral Float)
09:42:17 <dons> :t fromIntegral
09:42:18 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:42:26 <mauke> > round (fromIntegral (2 :: Int) * (2.5 :: Float))
09:42:27 <lambdabot>  5
09:42:30 <dons> some value of a type in the class Num
09:42:50 <uccus> @type liftM2
09:42:52 <lambdabot> forall r (m :: * -> *) a2 a1. (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
09:42:52 <sorear> Float is Considered Obsolete, use Double unless you're programming a PIC14F8
09:42:59 <uccus> @type liftM
09:43:00 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
09:43:09 <mauke> @src liftM2
09:43:10 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
09:43:21 <uccus> is liftM the same as map for lists?
09:43:28 <sorear> yes
09:43:28 <mauke> yes
09:43:35 <lokojones> round ((2 :: Int) * fromIntegral (2.5 :: Float))
09:43:38 <lokojones> doesnt work here
09:43:43 <mauke> liftM == fmap, which is map for lists and . for functions
09:44:04 <mauke> lokojones: yeah, I did it wrong first
09:44:09 <sorear> loko: the fromIntegral needs to be wrapped around the value of Integral type
09:44:10 <mauke> see my next line
09:44:16 <uccus> [devilish grin] can we re-write all liftM* functions with ap?
09:44:21 <sorear> Int is Integral, Float isn't
09:44:23 <sorear> uccus:yes
09:44:36 <sorear> uccus: Control.Applicative does exactly thaty
09:45:03 <uccus> about the . for functions issue... [sorear: yeah, I found it out when I was writing The Other Prelude page]
09:45:04 <mauke> @pl \f x -> return f `ap` x
09:45:05 <lambdabot> fmap
09:45:17 <lokojones> oh mauke, didnt see your second answer
09:45:17 <lokojones> thx
09:46:00 <Guest67763> @src ap
09:46:01 <lambdabot> ap = liftM2 id
09:46:22 <mauke> @pl \f x y -> return f `ap` x `ap` y
09:46:23 <lambdabot> liftM2
09:46:40 <sorear> @pl liftM2 const
09:46:40 <lambdabot> liftM2 const
09:47:04 <uccus> this... section on types, (.) :: (b -> c) -> (a -> b) -> (a -> c)... for it to be the fmap, we need (a ->) to be an instance of Monad
09:47:09 <uccus> is that Haskell98?
09:47:20 <sorear> sure
09:47:28 <sorear> instance Monad ((->) a) where ...
09:47:45 <uccus> so I can write, instance Monad (a ->) where...?
09:48:00 <sorear> no, sections aren't suported
09:48:10 <sorear> but,
09:48:15 <lokojones> I still dont get it mauke
09:48:16 <Botje> uccus: or you import Control.Monad.Reader, which already has that instance declaration
09:48:17 <lokojones> vanAMutar :: Int -> Float -> Float
09:48:18 <lokojones> vanAMutar tpoblacion mutan = round(fromIntegral(tpoblacion) * mutan)
09:48:19 <uccus> okay... but ((->) a) works?
09:48:23 <sorear> @instances-importing Control.Monad.Instances Monad
09:48:24 <lambdabot> IO, Maybe, []
09:48:25 <lokojones> why doesnt that work?
09:48:28 <sorear> uccus: yes
09:48:33 <sorear> @instances-importing Monad
09:48:35 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
09:48:37 <uccus> alright, thanks
09:48:47 <sorear> @src (->) (>>=)
09:48:48 <lambdabot> f >>= k = \ r -> k (f r) r
09:49:03 <mauke> lokojones: because fromIntegral should be applied to the Float (mutan), and you don't need the round there
09:49:19 <uccus> I must have misunderstood this issue then... wasn't there a discussion about type sections? why do we need it?
09:49:22 <sorear> @pl \ f k r -> k (f r) r
09:49:22 <lambdabot> flip flip id . (ap .) . flip (.)
09:49:41 <sorear> mauke: how do you expect to apply fromIntegral to a float?
09:49:47 <sorear> :t fromIntegral
09:49:49 <lambdabot> forall b a. (Num b, Integral a) => a -> b
09:49:50 <mauke> argh :(
09:49:53 <sorear> @instances Integral
09:49:55 <lambdabot> Int, Integer
09:50:04 <mauke> lokojones: sorry, I'm totally confused now
09:50:29 <lokojones> mauke: me too :P
09:50:42 <mauke> you said you wanted an Int back
09:50:46 <lokojones> this is a very confusing thing in haskell
09:50:48 <mauke> why does your function return a Float?
09:50:49 <lokojones> yes
09:50:49 <uccus> @pl let s x y z = x z (y z) in s
09:50:50 <lambdabot> ap
09:50:55 <lokojones> oh, shit sorry
09:51:02 <uccus> what does _that_ mean?
09:51:05 <lokojones> trying things, I forgot to put that Int back
09:51:29 <lokojones> vanAMutar :: Int -> Float -> Int
09:51:30 <lokojones> vanAMutar tpoblacion mutan = (tpoblacion * fromIntegral(mutan))
09:51:34 <lokojones> should this be ok now?
09:51:38 <sorear> @pl \ k f r -> k (f r) r
09:51:39 <lambdabot> flip flip id . liftM2
09:51:41 <shapr> @seen bakert
09:51:41 <lambdabot> I saw bakert leaving #haskell 1h 52m 28s ago, and .
09:51:45 <shapr> foo
09:51:46 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
09:52:04 <sorear> @pl \ f k r -> flip k (f r) r
09:52:05 <lambdabot> flip flip id . (ap .) . flip ((.) . flip)
09:52:13 <sorear> @pl \ f k r -> k r (f r)
09:52:13 <lambdabot> flip ap
09:52:43 <sorear> @src putMVar#
09:52:43 <lambdabot> Source not found. Do you think like you type?
09:52:57 <paolin1> mmhh , how I run sortBy on a monadic function ?
09:53:07 <sorear> you don't ?
09:53:15 <paolin1> :)
09:53:26 <lokojones> I've been working for days in this genetic algorithm
09:53:32 <lokojones> its funny that im now stuck with this
09:53:38 <mauke> > let vanAMutar :: Int -> Float -> Int; vanAMutar tpoblacion mutan = round (fromIntegral tpoblacion * mutan) in vanAMutar 2 0.5
09:53:40 <lambdabot>  1
09:53:40 <sorear> monadic functions can represent different values, which Just Won't Do for sorting
09:53:43 <lokojones> I actually dont understand what the Integral type is...
09:53:48 <newsham> do { l <- getTheList; return (sortBy something l) }
09:53:59 <sorear> or they can represent no values at all
09:54:00 <mauke> lokojones: I think I got it right this time :/
09:54:23 <lokojones> ill try :P
09:54:44 <allbery_b> Integral is a typeclass, not a type,  specifically, it represents Int (fixed-size machine ints) and Integer (infinite-precision)
09:55:12 <lokojones> ok
09:55:12 <uccus> @src Integral
09:55:13 <lambdabot> class  (Real a, Enum a) => Integral a  where
09:55:13 <lambdabot>     quot, rem, div, mod :: a -> a -> a
09:55:13 <lambdabot>     quotRem, divMod     :: a -> a -> (a,a)
09:55:13 <allbery_b> it's a way to let functions operate on either type the same way
09:55:15 <lambdabot>     toInteger           :: a -> Integer
09:55:31 <lokojones> we just saw classes a few days ago
09:55:38 <lokojones> so we hadnt seen anything about Integral yet
09:55:49 <lokojones> at university I mean
09:55:59 <dons> ?users
09:56:00 <lambdabot> Maximum users seen in #haskell: 303, currently: 297 (98.0%), active: 38 (12.8%)
09:56:05 <mauke> (Integral a) => a means "any integral type"
09:56:07 <dons> ?uptime
09:56:07 <lambdabot> uptime: 19h 27m 58s, longest uptime: 2d 3h 42m 19s
09:56:10 <uccus> it's not too hard a concept...
09:56:16 <mahogny> lokojones, just consider most interesting values to be integral :)
09:56:35 <lokojones> ok
09:56:40 <lokojones> thx one more time :P
09:56:41 <mattam> allbery_b: it's arbitrary not infinite.
09:57:21 <mauke> > last [0 ..]
09:57:26 <lambdabot> Terminated
09:57:26 <newsham> let infinite = arbitrary + 1
09:58:00 <uccus> in the context of computer science, infinite = arbitrary
09:58:05 <mattam> someone got me on that one yesterday
09:58:11 <newsham> uccus: are you sure?
09:58:22 <newsham> > 1.0 / 0.0
09:58:23 <uccus> newsham: of course I'm kidding
09:58:23 <lambdabot>  Infinity
09:58:24 <Philippa> uccus: no. If it's arbitrary, I pick 1...
09:58:43 <mauke> > 1 / 0 + 1
09:58:45 <lambdabot>  Infinity
09:58:47 <newsham> not so arbitrary
09:58:49 <ClaudiusMaximus> > 0.0 / 0.0 -- arbitrary
09:58:51 <lambdabot>  NaN
09:58:54 <ClaudiusMaximus> (in maths)
09:58:56 <sorear> Actually Int is infinite precision.  what's the last digit in the decimal expansion of 1?
09:59:01 <allbery_b> picky, picky :)
09:59:10 <mauke> > last (show 1)
09:59:12 <lambdabot>  '1'
09:59:15 <uccus> but thing about it, in computer science, you can't _have_ infinite anything!
09:59:32 <newsham> sorear: the last digit in the decimal expansion of the integer 1 is 1.
09:59:39 <newsham> here's a proof:
09:59:42 <newsham> > show 1
09:59:44 <lambdabot>  "1"
09:59:55 <allbery_b> only in systems.  in theory, well, haskell gets much of its power from infinite lists, no?
10:00:02 <psnl> allbery_b: nah
10:00:20 <lokojones> thx one more time :P
10:00:36 <lokojones> everything is working ok
10:01:07 <allbery_b> (actually a poor example as haskell is clearly systems because itactually exists :> )
10:01:08 <lokojones> with this, just finished recombination of elements in my genetic algorythm
10:01:10 <pejo> allbery_b, depending on the problem you can usually code lazy evaluation in a strict language.
10:01:25 <newsham> integers are precise
10:01:31 <pejo> Err, obviously you *can* code it, but it might not be that ugly.
10:01:34 <mattam> uccus: well, you can have infinite loops :)
10:02:01 <newsham> rationals are also precise
10:02:04 <uccus> mattam: do they run for an infinite amount of time?
10:02:13 <uccus> I was after rationals actually
10:03:03 <sohail> hi, how do you write a data type that takes in four arguments, where each pair of types is the same type?
10:03:03 <mattam> well, all other things being equal for infinite time, it could
10:04:01 <mattam> what's the point ?
10:04:05 <sorear> data Foo a b = Foo a a b b ?
10:04:08 <dons> sorear: can you resend your last patches, they're failing to apply for me
10:04:13 <dons> (corrupted format?)
10:04:14 <dons> $ darcs apply /tmp/rename-offlinerc_source-to-rc-_fixes-embarassing-collision_.dpatch
10:04:15 <sohail> sorear, thanks!
10:04:17 <dons> darcs: FastPackedString.tailPS: empty list
10:04:21 <uccus> the point is, newsham's last proof is faulty
10:04:28 <uccus> > show (1/3)
10:04:29 <lambdabot>  "0.3333333333333333"
10:04:55 * sorear is running darcs check ...
10:05:05 <uccus> how do I create the Ratio (1/3)?
10:05:08 <mauke> > last (show (1 - 1 / 3 * 3))
10:05:10 <lambdabot>  '0'
10:05:13 <uccus> 1 :% 3 that is
10:05:13 <sorear> 1 % 3
10:05:17 <dons> > 1 % 3
10:05:18 <lambdabot>  1%3
10:05:27 <sorear> dons: resent.
10:05:27 <uccus> > show (1 % 3)
10:05:29 <lambdabot>  "1%3"
10:05:29 <mauke> > 15 % 5
10:05:31 <lambdabot>  3%1
10:05:34 <newsham> uccus: how does that show a flaw in my proof?
10:05:34 <uccus> that's mean
10:05:50 <dons> much better, sorear
10:05:59 <dons> looks like some weird MS header or something got added
10:06:01 <uccus> that the last digit in expansion of... what was it? :lost:
10:06:14 <kowey> dmhouse: could we delete http://en.wikibooks.org/wiki/Existentially_quantified_types ?
10:06:19 <sorear> dunno why, I used darcs send both times...
10:06:24 <kowey> note that there is http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types
10:06:26 <lambdabot> http://tinyurl.com/f9umb
10:07:02 <sorear> anyway, that doesn't *fix* the netsplit problem, but it will greatly reduce the frequency
10:07:03 <newsham> uccus: right, show truncated the display of the decimal expansion after about 10 or 15 places.  that did not haappen with "show 1"
10:07:23 <uccus> newsham: yes, that was my point
10:07:25 <uccus> :)
10:07:31 <sorear> fixing the netsplit problem will require someone to rewrite Control.Concurrent.* to be async exception safe.
10:07:43 <newsham> the reason it didnt happen with "show 1" was because it had finished displaying the decimal digits.
10:07:55 <kowey> uccus: i like it (the higher order stuff)
10:07:59 <newsham> having showed the last one.
10:08:02 <uccus> the reason it should not happen for 1 % 3...
10:08:06 * kowey tweaks the intro language
10:08:06 <sorear> the question is: should the changes be (a) merged into base (b) created as separate modules (c) kept in lambdabot
10:08:20 <newsham> uccus: QED.
10:08:30 <uccus> thanks kowey... I will write the currying bit tomorrow if I find time
10:08:39 <guybrush981> Hello everybody, I have just read the http://haskell.org/haskellwiki/Stack_overflow entry and was a bit surprised about the behaviour of the fold functions. Since being used to eager evalution I naively assumed that foldl would always be safe to use and foldr the baddy. Now, while the wiki entry contains a nice one-line summary on when to use which fold, I wondered if there is a tool that could automatically warn about potenti
10:08:39 <guybrush981> uses of foldl/l'/r and other recursive functions?
10:08:40 <lambdabot> Title: Stack overflow - HaskellWiki
10:09:09 <mahogny> guybrush981, when memory starts running away, you know
10:09:15 <sorear> guy: you hit the 512 char limit
10:09:16 <newsham> sorear, dons: are you guys interested in some painful deconstruction to allow other chat formats?
10:09:23 <sorear> yes
10:09:37 * sorear quotes shapr's "it's a neccessary change"
10:09:42 <shapr> ?
10:09:54 <shapr> oh
10:09:57 <pejo> shapr, people quoting you - means you're famous!
10:10:16 <shapr> pejo: Or maybe that I talk so much, I end up saying some of the same stuff other people end up saying.
10:10:38 <psnl> shapr: seems doubtful.
10:10:38 <pejo> shapr, heh, going along the "millions of monkeys typing on internet"-string?
10:10:45 <Nafai> Hey shapr
10:10:51 <Nafai> pejo: Are you calling shapr a monkey?
10:11:04 <shapr> pejo: Look at my all-time IRC stats - http://www.cse.unsw.edu.au/~dons/irc/haskell.html
10:11:04 <lambdabot> Title: #haskell @ freenode.org stats by dons
10:11:09 <pejo> Nafai, no, I'm calling him famous!
10:11:14 <mauke> @shapr pejo
10:11:15 <lambdabot> why on earth would I slap pejo
10:11:27 * shapr grins
10:11:29 <shapr> hiya Nafai
10:11:44 <Nafai> How's it?
10:11:50 <shapr> Life is good.
10:12:22 <psnl> dons: dcoutts_ has quite a potty mouth. 0.0% words were foul language.
10:12:23 <psnl> Pseudonym also makes sailors blush, 0.0% of the time.
10:12:50 <jethr0> what's the std design pattern to use a random generator in state instead of io. where would i get a "random" seed?
10:12:50 * psnl thinks you have a rounding problem
10:13:11 <pejo> shapr, it's you and lambdabot who keeps this channel going!
10:13:19 <shapr> pejo: Or at least, we fill it up!
10:13:30 <jethr0> is it acceptable to do "seed = unsafePerformIO $ randomRIO ..." as it get's evaluated only once?
10:13:35 <newsham> jethr0: you would use a State monad, and you would pass in the initial generator when you runState the thing
10:13:51 <allbery_b> hm, so much for that test.  Data.Ord is not blessed :/
10:13:55 <newsham> you could create the initial generator with a seed value
10:14:25 <shapr> haha : lambdabot is a very aggressive person. He/She attacked others 126 times. /n Poor lambdabot, nobody likes him/her. He/She was attacked 57 times.
10:15:02 <jethr0> newsham: i'm aware of that. but then i'd need an IO path from "main" to whereever i'm calling runState. i was wondering if there was an accepted/nice solution for this
10:15:02 <shapr> Haskell is the most used word, but shapr is the 4th most used word! Yow!
10:15:21 <shapr> pejo: Ok, I believe you. In this limited area of #haskell, I am famous :-)
10:15:34 <jethr0> if i have to get a random number to runState i might (almost) just as well use IO instead of state in the first place
10:15:38 <emk> The "Stack Overflow" article on the Haskell Wiki is realy nice.
10:15:56 <newsham> what do you mea n"get a random number to runState"?
10:16:11 <newsham> you want to pick a random seed?
10:16:15 <shapr> The "most used words" says nice things about #haskell, 1.haskell 2.think
10:16:17 <jethr0> > let wpm = 10.0 in 1644392.0 / wpm / 60 / 24
10:16:18 <lambdabot>  114.1938888888889
10:16:30 <sorear> just invent a random number.  something like 389324984897389298 :)
10:16:41 <emk> jethr0: If you need a genuinely random sequence of numbers, you're already in IO. Purely random numbers aren't referentially transparent.
10:16:47 <jethr0> shapr: assuming 10 words per minute, you've been 114 days in the channel, typing steadily away :)
10:16:57 <shapr> amazing
10:16:59 <Botje> shapr: what does it say about "fatal brain asplosion"?
10:17:10 <shapr> Botje: Where's that from?
10:17:11 <pejo> jethro, "conversations are clusters".
10:17:14 <newsham> jethro: you can use "getStdGen" to use the builtin generator thats already been seeded
10:17:32 <jethr0> newsham: yes, i need a random seed so i don't get the same random numbers all the time
10:17:40 <jethr0> newsham: ah, thx a lot
10:18:19 <jethr0> emk: i'm kinda aware of that. i just have used IO always for random numbers and am now trying to refrain from that and use state instead.
10:18:54 <jethr0> pejo: yes, i just wanted to approximate how much 1.6M words are
10:19:16 <newsham> do { gen <- getStdGen; print runState <stateprog> g }
10:19:29 <newsham> $ afte rprint
10:20:23 <emk> ?hoogle getStdGen
10:20:24 <lambdabot> Random.getStdGen :: IO StdGen
10:20:57 <jethr0> hmm
10:23:09 <cinimod> can someone remind me where the repository for bytestring.lazy is?
10:23:20 <sorear> @where base
10:23:21 <lambdabot> http://darcs.haskell.org/packages/base/
10:23:34 <sorear> * 6.6 only
10:23:49 <guybrush981> mahogny, unfortunately memory might not start running away during the first tests of the function, only later when the call is buried deep inside some other code. And then the searching begins.
10:24:01 <mahogny> guybrush981, you are prolly right
10:24:07 <mahogny> which name do you prefer in math programs, asin or arcsin?
10:24:59 <cinimod> Hmmm that doesn't look right. dons was working on it a few days ago and I downloaded 0.2.
10:25:00 <emk> jethr0: do { gen <- Random.getStdGen; let (r,gen')::(Float,Random.StdGen) = (Random.random gen) in print r; }
10:25:09 <emk> ...will print the same number each time you call it.
10:25:12 <jethr0> i was negatively surprised when i found this beauty in "http://haskell.org/haskellwiki/Haskell_Quiz/Amazing_Mazes/Solution_Burton":
10:25:13 <lambdabot> http://haskell.org/haskellwiki/Haskell_Quiz/Amazing_Mazes/Solution_Burton":
10:25:14 <shapr> mahogny: arcsin!
10:25:18 <jethr0> getRandNum :: Int -> Int
10:25:20 <jethr0> getRandNum n = unsafePerformIO $ getStdRandom $ randomR (0,n)
10:25:25 <mahogny> shapr, but that takes more time to parse :)
10:25:26 <shapr> mahogny: asin makes me think of asinine
10:25:29 <mahogny> :o
10:25:38 <newsham> emk: no, if you stop ghci and restart it, you will get a new value next time
10:25:49 <mahogny> I guess I make it arcsin then
10:25:50 <allbery_b> hm.  2nd attempt:  its System.Time lacks the TOD constructor.  feh
10:26:04 <emk> newsham: Yeah, I know. But that doesn't do you any good in a running process. Random numbers just aren't referentially transparent.
10:26:21 <newsham> they are when you use the same generator each time
10:26:30 <newsham> if you want to get new values, you use a new generator
10:27:01 <newsham> if you're in the same ghci session, the standard generator is still the same for the whole session
10:27:01 <emk> newsham: But getting a new generator (with a random seed) isn't referentially transparent, either.
10:27:27 <jethr0> emk: as we are all aware
10:27:31 <emk> OK. :-)
10:27:35 <newsham> neither is running a program
10:27:56 <newsham> i'm not sure what your point is, forgive me.
10:30:05 <emk> newsham: I was just pointing out that asking for "random" numbers outside of IO didn't make very much sense, unless you passed in a generator (or an infinite list, etc.) from someplace that was in IO. Not a very exciting observation, I admit. :-)
10:30:37 <newsham> your program doesnt run except through main :: IO () anyway.   getStdGen is also an IO action.
10:33:12 <emk> newsham: Yes, I know. My program was pointing out an interesting property of getStdGen.
10:35:53 <glguy> ?bot
10:35:54 <lambdabot> :)
10:36:22 * glguy is stuck using Tor again :o[
10:36:33 * shapr gives more onions to glguy 
10:37:19 <glguy> Does a doublely keyed map exist as a library for Haskell?
10:37:33 <glguy> Ord a, Ord b => DoubleMap a b
10:37:50 <newsham> newsham@discover$ ./emkrand
10:37:50 <newsham> 0.20251527
10:37:50 <newsham> newsham@discover$ ./emkrand
10:37:50 <newsham> 0.2872988
10:37:51 <glguy> I dont' know what to call such a structure off-hand
10:38:03 <mahogny> hm. why not just use Map (a,b)?
10:38:13 <newsham> ?paste
10:38:13 <lambdabot> http://paste.lisp.org/new/haskell
10:38:25 <allbery_b> you want values to map to keys as well as keys to values?
10:38:30 <centrinia> ... and lexigraphically order (a,b)
10:38:35 <lisppaste2> newsham pasted "emkrand.hs" at http://paste.lisp.org/display/35272
10:38:45 <emk> How smart is GHC? Does it automatically transform, say, "map f (map g xs)" to "map (f . g) xs", or do any other deforestation?
10:38:58 <glguy> Basically, I want to update values efficiently, and find minimum values efficiently...
10:39:08 <Igloo> emk: It has rules for things like that, yes
10:39:10 <mahogny> emk, it does some transforms AFAIK but I can't tell if that one is in the list
10:39:35 <sorear> glguy: Glib has such objects under the name "relations"
10:39:39 <mahogny> glguy, (a,b) is the pattern I run into most commonly. I take it it is a fast method given the use
10:40:06 <mahogny> glguy, priority queue with references maybe?
10:40:12 <sorear> but glguy wants multiple orderings right?
10:40:14 <mahogny> O(1) to find minimum
10:40:16 <glguy> mahogny: exact
10:40:19 <glguy> ly
10:40:20 * sorear mutters something about treaps
10:40:26 <glguy> I was thinking min-heap
10:40:52 <sorear> a treap is both a binary tree and a min-heap
10:41:09 <glguy> Has anyone implemented that in Haskell as a library?
10:41:15 <mahogny> hm. I saw some paper about priority trees in haskell. they ended up using those very nasty other versions of performwtfio. that was scary
10:41:33 <mahogny> glguy, there are data structure libs for sure. can't tell if that one is in though
10:41:49 * sorear goes to look at new-collections
10:42:53 <fasta> glguy: Probably Edison has them
10:43:29 <glguy> Does that seem reasonable to need for an MST algorithm?
10:43:50 <fasta> glguy: I didn't read the context.
10:44:04 <fasta> glguy: Doesn'FGL
10:44:10 <mahogny> I take it Edison has been seriously coded so it can be used for MST
10:44:14 <glguy> I was playing with a minimum spanning tree algorithm
10:44:18 <fasta> glguy: Doesn't FGL have MST implemented?
10:44:33 <glguy> FGL?
10:44:42 <fasta> glguy: Functional Graph Library
10:44:50 <sorear> @where fgl
10:44:50 <fasta> glguy: libraries/fgl in darcs
10:44:51 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
10:44:59 <glguy> it might
10:45:28 <centrinia> glguy, so you want O(1) min finding?
10:46:01 <glguy> centrinia: yeah
10:46:13 <glguy> Maps do it in log n?
10:46:15 <sorear> note that Data.Set has O(log n) min finding, and is asymptotically as good as a heap for almost all purposes
10:46:23 <centrinia> Try mapping a linked list.
10:46:41 <centrinia> Well, Map (ListNode a)
10:46:43 <glguy> I need to be able to update it easily though
10:47:08 <centrinia> Well, updates are O(log n), and you won't get any better than that.
10:47:09 <sorear> Data.Set can delete and add arbitrary elements, again in log-time
10:47:36 <sorear> the most common type of heap (binary) has deletion in O(n)...
10:48:05 <glguy> Hmm, I suppose that I could go back to maintaining a parallel set
10:48:17 <centrinia> How about a threaded tree?
10:48:28 <glguy> and create a tuple for distance and node with compare comparing the distance
10:48:34 <centrinia> Those are not too difficult to implement given a Set.
10:48:41 <glguy> centrinia: I don't know of threaded trees
10:49:03 <centrinia> They are trees with each node containing a pointer to the previous and next nodes.
10:49:40 <centrinia> So, you can traverse it like a list, or modify it like a tree.
10:50:00 <centrinia> There is more work involved with each update (as you have to update those pointers).
10:50:08 <centrinia> But the pointer updates are only O(1).
10:50:32 <centrinia> If you have a special "head" node that points at the first element, you have O(1) min finding.
10:50:52 <centrinia> I'll write it up just for fun right now.
10:50:55 <sorear> centrinia: can't you traverse a regular tree in O(n)?
10:51:18 <centrinia> Yeah, but finding the first element takes O(log n) time. :(
10:53:14 <fasta> What's the difference between an IntMap and an IntSet?
10:53:24 <sorear> an intmap has value
10:53:30 <sorear> :k IntMap
10:53:31 <lambdabot> Not in scope: type constructor or class `IntMap'
10:53:32 <glguy> maps are key-value
10:53:35 <sorear> :k Data.IntMap
10:53:37 <lambdabot> Couldn't find qualified module.
10:53:38 <sorear> :k Data.IntMap.IntMap
10:53:40 <lambdabot> * -> *
10:53:44 <sorear> :k Data.IntSet.IntSet
10:53:46 <lambdabot> *
10:53:55 <newsham> what is "k"?
10:54:05 <sorear> (k)ind
10:54:08 <glguy> kind
10:54:15 <fasta> glguy: ok, I see
10:54:17 <newsham> ?k Maybe
10:54:17 <lambdabot> Maybe you meant: karma karma+ karma- karma-all keal kind . v
10:54:21 <newsham> :k Maybe
10:54:23 <lambdabot> * -> *
10:54:29 <newsham> hmm.. I didnt realize there were colon commands too
10:54:33 <sorear> :k Control.Monad.RWS.RWST
10:54:35 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
10:54:43 <nornagon> eek.
10:54:59 <newsham> how come :k is kind but ?k is ambiguous?
10:55:06 <sorear> don't worry, RWST has the longest type I know of
10:55:10 <fasta> glguy: I wrote an instance for MonadState for MaybeT, btw. (It's trivial if you know the answer, but well it was my first.)
10:55:13 <nornagon> : != [?@]
10:55:17 <sorear> newsham: :k isn't a command, it's a contextual
10:55:31 <newsham> is there a way to list all contextuals?
10:55:37 * sorear claps for fasta
10:55:38 <glguy> fasta: I ended up needing that also :)
10:56:08 <sorear> newsham: grep -lr contextual Plugin/*.hs is the best you'll get :(
10:56:15 <newsham> gotcha.
10:56:28 <fasta> sorear: I do wonder whether being this explicit about control flow is the right way.
10:56:33 <glguy> edisons associative collection library does what I want
10:56:48 <sorear> fasta: huh?
10:57:16 <fasta> sorear: I use MaybeT to do the equivalent of non-local control flow.
10:57:30 <sorear> oh right exceptions
10:57:40 <fasta> sorear: no
10:57:55 <fasta> sorear: exceptions can be used, but that's a hack.
10:58:16 <fasta> sorear: and you can use implement exceptions with a similar mechanism, probably.
10:58:25 <fasta> (if that's what you meant)
10:58:47 <sorear> I thought of exceptions as an abstract concept, which *could* be implemented using unwinding, or Either-class monads, or if-statements (uck), or...
10:59:18 <glguy> ?where edison
10:59:18 <lambdabot> http://www.eecs.tufts.edu/~rdocki01/edison.html
11:00:20 <emk> Whee! Free theorems are cool.
11:00:35 <sorear> emk: have you seen @free ?
11:01:06 <emk> Nope.
11:01:31 <emk> @free (a -> b) -> [a] -> [b]
11:01:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:01:41 <sorear> @free map
11:01:43 <lambdabot> f . h = k . g => $map f . map h = map k . $map g
11:01:46 <emk> Ah, thanks.
11:01:59 <sorear> @free (undefined :: a -> b -> b)
11:02:00 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:02:06 <sorear> @free const id
11:02:06 <lambdabot> Extra stuff at end of line
11:02:13 <sorear> @help free
11:02:14 <lambdabot> free <ident>. Generate theorems for free
11:02:20 <sorear> @help ft
11:02:21 <lambdabot> ft <ident>. Generate theorems for free
11:02:33 <norpan> @free concat
11:02:34 <lambdabot> $map f . concat = concat . $map ($map f)
11:02:46 <fasta> @free concat
11:02:47 <lambdabot> $map f . concat = concat . $map ($map f)
11:02:51 <sorear> @ft concat
11:02:53 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
11:02:54 <lambdabot>    forall x1 :: [[T1]].
11:02:54 <lambdabot>      map h1 (t1 x1) = t1 (map (map h1) x1)
11:03:02 <fasta> What's the point if it returns the same everytime?
11:03:20 <sorear> that's the whole point
11:03:28 <sorear> the theorems are always true
11:03:38 <sorear> beware:
11:03:40 <sorear> @ft seq
11:03:42 <lambdabot>  forall T1,T2 in TYPES. forall h1 :: T1 -> T2, h1 strict.
11:03:42 <lambdabot>    forall T3,T4 in TYPES. forall h2 :: T3 -> T4, h2 strict.
11:03:42 <lambdabot>      forall x1 :: T3.
11:03:44 <lambdabot>        forall x2 :: T1.
11:03:46 <lambdabot>          h1 (t1 x1 x2) = t1 (h2 x1) (h1 x2)
11:03:53 <fasta> sorear: I mean why does it return the same theorem
11:04:09 <sorear> @free seq
11:04:11 <lambdabot> f . seq x = seq (g x) . f
11:04:13 <mauke> whee, thinking in STM tickles
11:04:35 <emk> mauke: Unlike thinking in terms of locks, which just hurts.
11:05:20 <jethr0> @hoogle [Maybe a] -> [a]
11:05:21 <lambdabot> Maybe.catMaybes :: [Maybe a] -> [a]
11:06:49 <emk> @free sort
11:06:51 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Ord a) => [a] -> [a]\n"
11:07:12 <emk> @free tail
11:07:14 <lambdabot> $map f . tail = tail . $map f
11:07:41 <Jaak> @free tails
11:07:43 <lambdabot> $map ($map f) . tails = tails . $map f
11:07:46 <Jaak> @free inits
11:07:48 <lambdabot> $map ($map f) . inits = inits . $map f
11:07:53 <Jaak> oh, right
11:07:58 <jethr0> @test \f -> map f . tail = tail . map f
11:07:58 <lambdabot> Maybe you meant: let list tell
11:08:05 <jethr0> @check \f -> map f . tail = tail . map f
11:08:05 <lambdabot>  Parse error
11:08:21 <Jaak> ==
11:08:32 <jethr0> @check \f -> map f . tail == tail . map f
11:08:33 <lambdabot>   add an instance declaration for (Eq ([a] -> [b]))     In a lambda abstracti...
11:08:43 * jethr0 goes to chat with lambdabot in private
11:09:46 <Saizan> sounds like you are going to molest her.. :D
11:10:19 * allbery_b is tempted to ask @vixen about roofies
11:11:24 <jethr0> @vixen have i molested you?
11:11:24 <lambdabot> what about me?
11:11:35 <jethr0> see!
11:11:42 <jethr0> a clear no
11:22:12 <ktne> hello
11:22:31 <ktne> i'm not sure if this a proper channel to ask but i can't find proper info on a concept found in some "esoteric" langauges
11:22:36 <ktne> what's multidispatch?
11:23:05 <sorear> yow, you just called a core oo concept esoteric
11:23:28 <ktne> sorear "esoteric" in as you can find it only in esoteric papers
11:23:30 <sorear> that takes uncommon bravery
11:23:39 <ktne> you never get to read multidispatch in normal oop texts
11:23:55 <ktne> so i can't understand what that is
11:23:59 <sorear> All I know is that it's an OO concept...
11:24:04 <ktne> heh
11:24:16 <ktne> so then why you named it a "core oo concept" ?:)
11:24:28 <mauke> http://gigamonkeys.com/book/object-reorientation-generic-functions.html
11:24:30 <lambdabot> Title: Object Reorientation: Generic Functions, http://tinyurl.com/yl97fv
11:25:28 <sorear> yes! 3 days after finding the netsplit problem I've found a simple solution
11:27:53 <allbery_b> it is a core OO concept; it's just that it's usually not referred to that way
11:28:25 <emk> @free fold
11:28:27 <lambdabot> Extra stuff at end of line in retrieved type "Not in scope: `fold'\n\n"
11:28:34 <jethr0> ktne: multiple dispatch means that you don't just dispatch based on the first argument but on several
11:28:38 <emk> @free foldr
11:28:40 <lambdabot> (forall x. f . h x = k (g x) . f) => f . foldr h y = foldr k (f y) . $map g
11:29:00 <jethr0> ktne: single dispatch: method(class, a, b, c) dispatches only based on class
11:29:08 <glguy> @free Data.Map.fold
11:29:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
11:29:26 <glguy> ?bot
11:29:26 <lambdabot> :)
11:29:27 <jethr0> ktne: multiple dispatch: method(class, a, b, c) can call different "functions" depending on a,b,c
11:29:28 <sorear> oh, so multi-dispatch is like MPTCs
11:29:29 <ktne> jethr0 i was thinking about adding to my programming language a feature i call "where"
11:29:39 <jethr0> mptc?
11:29:46 <ktne> jethr0 where is a boolean condition that has to be met in order for a function to match a set of parameter
11:29:51 <allbery_b> multi-parameter type classes
11:30:12 <jethr0> ktne: sounds like a very general version of multiple dispatch
11:30:15 <ktne> jethr0 if it doesn't match the "where" condition then it cycles to other possible function overloads until it finds a match
11:30:47 <jethr0> ktne: based on types or on values?
11:30:49 <ktne> fun(a,b) where a>b
11:30:55 <ktne> on both types and values
11:31:08 <allbery_b> so, like haskell guards
11:31:10 <ktne> let fun(a,b) where a>b = something..
11:31:16 * sorear , against his better judgement, tries to recruit ktne
11:31:16 <dmhouse> Evening channel.
11:31:20 <ktne> let fun(a,b) where a<b = something...
11:31:40 <allbery_b> fun a b | a < b = ...
11:31:44 <ktne> if you call with fun(4,2) then it first checks the last defined function
11:31:44 <sorear> > let abs x   | x > 0 = x   | otherwise = (-x)  in abs 10
11:31:46 <lambdabot>  10
11:31:51 <sorear> > let abs x   | x > 0 = x   | otherwise = (-x)  in abs (-10)
11:31:52 <lambdabot>  10
11:32:03 <ktne> hmm, i see
11:32:13 <ktne> what about 2 functions called abs?
11:32:26 <jethr0> ktne: you need type classes for that in haskell
11:32:59 <ktne> well my planned feature cycles in all overloaded functions
11:33:38 <allbery_b> haskell uses typeclasses for overloading; it lets you place some sanity constraints on how you overload things
11:34:09 <ktne> so fun(4,2) first tries to call the last defined function (let fun(a,b) where a<b = something..) but fails and then it tries the next one (let fun(a,b) where a>b = something..) which succeeds
11:34:11 <allbery_b> to make it a little harder to end up with an overloaded function that does two very different and inconsistent things
11:34:21 <ktne> hmm
11:34:32 <ktne> the purpose of this feature in my case is to eliminate OOP
11:34:44 <allbery_b> typeclasses aren't really like OOP
11:34:51 <jethr0> ktne: and if you have overlapping predicates search order becomes relevant
11:34:54 * notsmack finally gets 'sequence'
11:35:09 <jethr0> > sequence [[1,2][3,4]]
11:35:10 <lambdabot>      The function `[1, 2]' is applied to one arguments,
11:35:10 <lambdabot>     but its type `[a]...
11:35:12 <glguy> ?src sequence
11:35:13 <lambdabot> sequence ms = foldr k (return []) ms
11:35:13 <lambdabot>     where
11:35:14 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
11:35:14 <jethr0> > sequence [[1,2],[3,4]]
11:35:16 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
11:35:17 <ktne> jethr0 yes they would be searched in reverse definition order
11:35:33 <glguy> > sequence [pred,succ] 5
11:35:35 <lambdabot>  [4,6]
11:36:04 <jethr0> > sequence [(+),(-)] 1 2
11:36:05 <lambdabot>      The function `sequence' is applied to three arguments,
11:36:05 <lambdabot>     but its type ...
11:36:13 <dmhouse> glguy: ooh! That's a nice application.
11:36:17 <jethr0> oohh
11:36:19 <dmhouse> > map ($ 5) [pred, succ]
11:36:21 <lambdabot>  [4,6]
11:36:38 <ktne> jethr0 by searching in reverse definition order you can add wrappers to existing "classes"
11:37:17 <jethr0> hmm
11:37:24 <ktne> redefine "class" functionality
11:37:38 <ktne> pseudo-classes there are just a bunch of functions
11:37:50 <matthew-_> gah, what is up with haskell.org?
11:37:57 <ktne> there are no proper classes, this mechanism is used for function selection
11:38:08 <glguy> matthew-_: seems down
11:38:37 <glguy> classes in OOP are the result of the mistake of putting data encapsulation and function namespacing together
11:38:39 <ktne> so if you have shape.draw and circle.draw, you actually define 2 functions named draw that implement functionality
11:38:51 <matthew-_> not necessarily true
11:39:04 <ktne> then the right draw function is called based on those "where" conditions
11:39:06 <sorear> well, take a look at haskell - you might be able to steal something
11:39:16 <ktne> sorear haskell seems overlycomplicated :)
11:39:23 <matthew-_> circle.draw can refer via super to shape.drap
11:39:33 <glguy> ktne: only because you do not yet understand it
11:39:45 <matthew-_> is there an instance Monad Bool ?
11:39:47 <ktne> matthew_- i have no super classes
11:39:55 <ktne> mattam since i have no classes
11:40:06 <sorear> forall a. Those who do not understand a are doomed to reinvent a, poorly.
11:40:08 <matthew-_> ktne: err, I was meaning in OOP
11:40:10 <ktne> mattam they are just functions with guards
11:40:19 <matthew-_> ahh yes
11:40:46 <sorear> matthew-: no. it would be a kind error.
11:41:04 <sorear> Monad needs (* -> *), Bool is (*)
11:41:33 * matthew-_ thinks hard about the contents of Control.Monad.Instances
11:41:58 <matthew-_> yeah ok.
11:42:26 <matthew-_> right. So I have a function f with some type and I want to put a conditional in front of it
11:42:31 <dmhouse> matthew-_: in other words, things like 'Maybe String' make sense, but 'Bool String' doesn't make any sense.
11:42:40 <matthew-_> Yes, I follow
11:42:55 <matthew-_> but I want do do this in as clean a way as possible
11:43:21 <matthew-_> actually, maybe I'm just utterly confused
11:43:29 <glguy> paste your initial inclination?
11:43:30 <araujo> hello
11:43:45 <matthew-_> @paste
11:43:45 <lambdabot> http://paste.lisp.org/new/haskell
11:44:08 * allbery_b is not sure what you're getting at but thinks it should be possible to wrap something in a monad which carries a condition around
11:44:26 <allbery_b> ...but that might not be the sane way to do it
11:44:34 <matthew-_> yeah - like maybe but with no value in just. hang on, paste coming
11:44:44 <lisppaste2> matthew-_ pasted "how to combine these and other similar functions sanely" at http://paste.lisp.org/display/35276
11:44:45 <allbery_b> (it'd help if I actually understood what you were trying to do :)
11:45:19 <matthew-_> I think I'm massively trying to overengineer this
11:45:51 <allbery_b> that kinda looks like a variant of Either to me
11:46:02 <allbery_b> Either Vector Vector, Left for false, Right for true
11:46:20 <glguy> matthew_-: and you want to chain these things together?
11:46:27 * glguy notes that Either Vector is not an instance of Monad
11:46:34 <matthew-_> I just want some automated way of sticking some bool in a function call which will control whether or not the function gets called
11:46:40 <allbery_b> yeh, you'd need to craft a monad instance for it
11:47:14 <allbery_b> Left v >>= _ = v, Right v >>= f = return (f v) -- I think
11:47:21 <glguy> This could be done easily enough with Cont
11:47:37 <allbery_b> (actually Left v >>= _ = Left v)
11:48:06 <allbery_b> although that assumes that the condition is in some sense an attribute of thevector
11:48:55 <glguy> matthew-_: f b f x = if b then f x else x
11:49:00 <allbery_b> which is in fact a big question mark; how the condition relates to the value controls how you implement
11:49:08 <glguy> matthew-_: why not just write a function for that
11:49:26 <matthew-_> glguy: that's what I'm trying to figure out
11:49:52 <glguy> matthew-_: can you show us a case where you would use this function you pasted
11:49:53 <ookk> is there any Int_64 datatype in haskell?
11:49:56 <glguy> that you are trying to clean
11:50:04 <glguy> Word64
11:50:14 <ookk> ok thx
11:50:23 <matthew-_> this is weird. In the last 3 years, writing a lot of Java, I've never really had to think about *what* I wanted. Return to haskell and suddenly I have to focus far more on what I actually want
11:50:24 <glguy> Data.Word.Word64
11:50:32 <ookk> thx :)
11:50:39 <dmhouse> matthew-_: good or bad? :)
11:50:53 * allbery_b suspects that's the way Java works, and explains the ad-hoc way the language has "grown" :)
11:51:05 <lisppaste2> matthew-_ annotated #35276 with "A use case" at http://paste.lisp.org/display/35276#1
11:51:06 <allbery_b> (features, not usage)
11:51:54 <Igloo> Data.Int.Int64 if you want a signed type
11:52:19 <glguy> matthew-_: what line in that example uses the conditioal application?
11:52:27 <matthew-_> dmhouse: I think that it takes a long time to get used to the fact that the power of haskell requires thought. With Java, designed for > 90% of the world's programmers, it's probably sensible that you're not allowed to think.
11:52:57 <matthew-_> glguy: line 6
11:53:19 <matthew-_> oh that's rubbish
11:53:22 <glguy> I think it is simply difficult to write correct solutions to problems
11:53:30 <glguy> you can hack something together in most langauges
11:53:33 <glguy> haskell included
11:53:34 <alkoma> ... that's sound like Bush :)
11:53:42 <newsham> matt: if you were speaking in a new foreign language you'd have to spend a lot more time thinking about what you were saying
11:54:09 <matthew-_> newsham: I would have to think *how* to express myself. Not *what* I wanted to express.
11:54:44 <allbery_b> it's not that you're not allowed to think, it's that it doesn't force you to think.  like forall vs. exists :)
11:54:56 <matthew-_> anyway, I think my entire problem here is non-existent and requires refactoring further up the chain.
11:55:04 <newsham> depends on how similar the grammar was to you rnative tongue
11:55:18 <newsham> if it was very different you would indeed be thinking about what you wented to express
11:55:29 <newsham> because it is tied to how you want to express it
11:55:35 <glguy> matthew-_: in that cases, I think you should not try to build the conditional aspect itno the function
11:55:51 <glguy> matthew-_: if cond then f x else x woudl be much clearer
11:55:53 <allbery_b> slapping something together can be useful, but is problematic when the slap-together becomes a permanent "solution".  otoh having to think produces better solutions that often stand up better in future, but are less likely to continue working if conditions change
11:55:58 <newsham> do you want to say "may a thousand flowers bloom" or "a bird in hand is worth two in the bush"?
11:56:00 <matthew-_> glguy: agreed. There's an obvious refactoring of that use case to avoid it.
11:57:06 * psnl grins, the second years have formed a facebook to bitch about haskell
11:57:33 <matthew-_> newsham: ?? ... err. Presumeably most languages have nouns, verbs, adjectives etc. Thus if you want to say "I am hungry" then it's just a matter of following the various rules of grammar for the given language
11:57:59 <newsham> "man shall not eat by bread alone"
11:58:14 <newsham> what are the semantics of that sentance?
11:58:18 <glguy> what is it called?
11:58:27 <matthew-_> newsham: but I agree, haskell and OOP may be so far apart that there is so little in common that those categories are not common
11:58:33 <newsham> does it mean that man also eats meats, vegetables and dairy products?
11:58:52 <newsham> or does it mean that a man needs more in his life than just sustenance
11:59:11 <matthew-_> newsham: I think weird sayings such as those are not sensible to compare languages though
11:59:30 <newsham> idioms are an important part of language.
11:59:42 <matthew-_> but surely that's an inversion of my point:
11:59:47 <allbery_b> enh.  he has a point that you can work out what the actual problem is and solve it, or you can treat symptoms
11:59:59 <matthew-_> you're trying to infer semantics from what's written
12:00:07 <pejo> allbery_b, it's nearly impossible to get it right the first time.
12:00:17 <allbery_b> sure
12:00:39 <allbery_b> I'm talking about approach
12:00:40 <matthew-_> whereas I'm saying ... I'm now confused and tired. I agree.
12:00:50 <newsham> i'm only saying that the reason you are more thoughtful in haskell is because you are unaccustomed to it and none of the languages you have used previously were that semantically close.
12:00:59 <pejo> allbery_b, I think you greatly under-estimate the Java development.
12:01:19 <newsham> you were probably equally pensive the first time you tried to use a for() loop
12:01:32 <matthew-_> newsham: yes, I guess so
12:01:52 <allbery_b> I'm actually not talking about Java in this case, but methodology.  (and I'm actually thinking of what I've seen in Perl...)
12:02:42 <matthew-_> maybe it's just 15 years of imperativeness, but the semantics of a for() loop seem several orders of magnitude simpler and more intuitive than so much of the bulk of haskell
12:02:46 <pejo> allbery_b, aren't you using the java development as an example?
12:02:56 <allbery_b> no, I kinda jumped tracks
12:04:15 <dmhouse> kowey: ping
12:04:25 <allbery_b> I think the point I was trying to make, somewhat poorly, is that Haskell tends to make you think about what;'s going on and therefore can direct you toward "treating the disease" instead of "treatingt he symptoms" --- although that's not really something you can control by choice of language or expression, really, more a matter of "since you haveto think about what ypou're doing anyway..."
12:04:27 <kowey> dmhouse: heya
12:04:44 <astrolabe> matthew-_: I agree, but I think the extra work for haskell is worth it.
12:04:54 <dmhouse> kowey: I think I'm going to send an email to the Haskell-cafe ML to get my category theory article reviewed. Any comments before I do?
12:05:10 <allbery_b> whereas at least some Java, and an awful lot of Perl, seems to be "I can slap together a quck fix" which tends to work more in favor of treating symptoms
12:05:18 <matthew-_> ewww, why is fromInteger part of Num?
12:05:31 <allbery_b> because Integers are Nums?
12:05:56 <kowey> dmhouse: i'm afraid not... i haven't yet sat down to read it properly :-)
12:05:57 <matthew-_> problem: I want to implement (-) for Vector. thought-path: where is (-) defined? Num. What else is in Num? Eww, fromInteger. That's a pain
12:06:03 <allbery_b> and more specifically becuse the *result* is expressed in terms of Num --- you were expecting String perhaps?
12:06:11 <allbery_b> ah
12:06:27 <kowey> dmhouse: and i suspect it would take me a while to do so (and understand), so it's probably worth sending the message now
12:06:39 <astrolabe> matthew: also * is in Num isn't it?
12:06:54 <astrolabe> @type (*)
12:06:56 <lambdabot> forall a. (Num a) => a -> a -> a
12:06:57 <matthew-_> astrolabe: yeah, but I could abuse semantics and implement cross product there
12:07:56 <matthew-_> so is there anyway that I can implement (-) or (+) such that I can apply it to Vector?
12:08:26 <glguy> Vector doesn't fit into Num
12:08:29 <astrolabe> matthew: Only 3d vectors in a space with a volume measure and an inner product have a cross product (roughley speaking).  Although, sometimes I think the numberlike haskell typeclasses should be revamped.
12:08:36 <dmhouse> kowey: okay, thanks.
12:09:04 <matthew-_> glguy: agreed. But (+) and (-) do fit with Vector.
12:09:21 <glguy> well... 2d vectors do
12:09:26 <glguy> > abs (1 :+ 2)
12:09:28 <lambdabot>  2.23606797749979 :+ 0.0
12:09:28 <astrolabe> matthew:  Maybe you should define (:+) and (:-) or something similar.
12:09:32 <glguy> > signum (1 :+ 2)
12:09:33 <lambdabot>  0.4472135954999579 :+ 0.8944271909999159
12:09:41 <allbery_b> hm.  if youre doing vectors, you could just define fromInteger n :: Vector as Vec n 0 0 or something, then ignore it
12:09:43 <matthew-_> astrolabe: mmm. You think (+) and (-) should be in a typeclass above Num?
12:09:55 <matthew-_> allbery_b: that's foul. ;)
12:09:57 <astrolabe> @type signum
12:09:59 <lambdabot> forall a. (Num a) => a -> a
12:10:05 <astrolabe> @type (:+)
12:10:07 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
12:10:28 <allbery_b> the other solutions are less foul?
12:10:49 <glguy> > 1 :+ 0 * 0 :+ 1
12:10:50 <lambdabot>      precedence parsing error
12:10:50 <lambdabot>         cannot mix `(:+)' [infix 6] and `(:+)' ...
12:10:56 <astrolabe> matthew: I think that naturally, vectors aren't Nums, but Nums have stolen '+' and '-' so we have to make do.
12:10:59 <glguy> > (1 :+ 0 )* (0 :+ 1)
12:11:01 <lambdabot>  0.0 :+ 1.0
12:11:26 <matthew-_> well, I've written about 3kloc with sumVectors and subtractVectors, I'm just thinking about trying to make (+) and (-) work... if haskell's not *good* enough to do it then I'll continue as I am... ;)
12:11:28 * matthew-_ ducks
12:11:49 * astrolabe fumes
12:12:18 <glguy> If you don't understand *why* it stops you, then I'm going to leave you curled up on the floor
12:12:22 <glguy> ;)
12:12:29 <matthew-_> I do understand
12:12:48 * matthew-_ promises to be less antagonistic
12:13:15 <allbery_b> actually, the organization of Num and friends is an area which is regularly discussed, because of things like this
12:14:17 <allbery_b> on the one hand, it'd be nice to refctor it so you could get e.g. (+) and (-) without other stuff; on the other hand, such refactoring can lead to excessive work needed to figure out what typeclasses you really want (take a look at (/) for example)
12:14:56 <dmhouse> allbery_b: this is where class aliases would be great.
12:15:09 <astrolabe> Maybe it would work to have a typeclass system based on algebraic structures.  + for an abelian monoid, - for an abelian group, * for a ring, / for a field.
12:17:28 * allbery_b recalls having to rewrite some code from Fractional to RealFrac to RealFloat as he worked out what operations it needed to support...
12:17:36 <matthew-_> are you allowed to declare the same function in multiple classes?
12:17:49 <glguy> no
12:19:01 <allbery_b> you can declare one class to be part of another, though (class Foo a => Bar a where ...)
12:19:35 <allbery_b> ^be part of^inherit from^
12:19:48 <Anon4888> but you can't go the other way:  class Foo a <= Bar a
12:19:56 <matthew-_> yep. tnx
12:21:10 <newsham> allberry "thinking about what is going on": that happens a lot in art when you're learning and not yet comfortable with your medium/instrument.
12:21:46 <newsham> you need to have a certain amount of fluency before you can focus on your message and not the mechanics of the medium
12:21:58 <johnnowak> the medium is the message.
12:22:28 <newsham> so why does julian bream seem to be saying something completely different than jimi hendrix?
12:23:04 <johnnowak> maybe you're listening to them differently.
12:23:07 * jethr0 is still lacking that fluency with monad transformers. but not much longer! :)
12:23:25 <newsham> jethr0: me too
12:24:02 <jethr0> i'm still trying to figure out what ST on top of Maybe would be like. but i guess trying it out and playing with it works better/faster than having it explained
12:24:20 <dmhouse> There's an STT?
12:24:36 <dmhouse> ?hoogle ST
12:24:37 <lambdabot> Control.Monad.ST :: module
12:24:37 <lambdabot> Data.Array.ST :: module
12:24:37 <lambdabot> Control.Monad.ST.ST :: data ST s a
12:24:42 <dmhouse> ?hoogle STT
12:24:43 <lambdabot> Control.Monad.ST.stToIO :: ST RealWorld a -> IO a
12:24:43 <lambdabot> Control.Monad.List.ListT :: m [a] -> ListT m a
12:24:43 <lambdabot> Control.Monad.List.mapListT :: (m [a] -> n [b]) -> ListT m a -> ListT n b
12:24:50 <glguy> nope
12:24:58 <dmhouse> jethr0: how can you stack ST on top of Maybe?
12:24:59 <glguy> or I don't know about it :)
12:25:00 <newsham> jethr0: you could add Just 1 and Just 2 and get and read state?
12:25:55 <jethr0> dmhouse: as i said i have no clue in this regard. i though ST was StateT and that one could transform on top of Maybe. maybe i just mean StateT...
12:26:11 <glguy> ST is IO without all the IO
12:26:13 <dmhouse> jethr0: ST is an alternative state monad.
12:26:23 <jethr0> ah, mixup then
12:26:31 <newsham> oh, ST.. err i was thinking State.  ignore me :)
12:26:32 <newsham> "If you ever have a problem, it becomes our problem the first time you call."
12:26:38 <newsham> oops mispaste
12:26:56 <glguy> State caries one value around, ST gives you an environment for mutable references
12:27:18 <jethr0> so, what is ST usually used for?
12:27:26 <newsham> imperative variables?
12:28:12 <glguy> ST is a subset of IO, iwth STRef, STArray and variants on those
12:28:18 <jethr0> i don't get it. maybe i'll have another (about the 100th) look at "all about monads"
12:28:27 <glguy> and you can "runST" to include such code in a pure function
12:28:38 <dmhouse> jethr0: you typically don't need to worry about ST. It's only used in imperative contexts.
12:28:39 <newsham> jethr0: are you familiar with State?
12:28:45 <jethr0> yes
12:28:57 <glguy> since ST doesn't interact with the user via filehandles, keyboard, sockets, etc
12:29:01 <glguy> you can run it and make it disappear
12:29:03 <glguy> IO is forever
12:29:12 <newsham> so in state you can get and set a single object (which might be a composite object)
12:29:21 <dmhouse> StateT s Maybe a is a computation that reads and writes some state of type s, might fail and returns a result of type a.
12:29:36 <newsham> in ST you can allocate (ie "declare") variables, fetch the value (by the handle you got when you declared it) or set the value
12:29:38 <jethr0> newsham: i've got a "State MyState Maybe a" right now and lots of code that does "r <- f; if isNothing r then ... else ..."
12:29:47 <OliverB> I've heard ST == State Thread
12:29:55 <dmhouse> OliverB: state transformer, I think.
12:29:57 <jethr0> so i was wondering if i could do StateT on top of Maybe and do this in a nicer way
12:30:02 <OliverB> ST isn't a monad transformer
12:30:16 <OliverB> If you're going to use ST it has to be bottom of the stack, like IO
12:30:22 <allbery_b> 'lazy functional state threads' is the paper ST is based on
12:30:25 <jethr0> k
12:30:29 <dmhouse> OliverB: no, it's the state transformer monad, because computations in it transform the state. :)
12:30:36 <dmhouse> jethr0: yes, you can.
12:30:48 <dmhouse> jethr0: care to paste your code?
12:30:55 <OliverB> ST is basically restricted IO, mutable memory without actual IO ...
12:30:57 <jethr0> dmhouse: see, and that's what i'll be figuring out over the next hours :)
12:31:11 <jethr0> @paste
12:31:12 <lambdabot> http://paste.lisp.org/new/haskell
12:31:13 <glguy> jethr0: to do what?
12:31:48 <lisppaste2> jethr0 pasted "trying to get more fluent with monads/transfomers" at http://paste.lisp.org/display/35285
12:32:13 <dmhouse> Woah, what's with all the qualified imports?
12:32:21 <jethr0> glguy: basically i just want to know so that i'm not as stupid when i need them as i'm right now
12:32:42 <jethr0> dmhouse: i was experimenting with that. maybe a bit OTT, but for rarely used functions it's quite nice
12:33:26 <dmhouse> ?hoogle rndPosPred
12:33:27 <lambdabot> No matches found
12:33:29 <newsham> > runStateT (do { x <- get; y <- return 3; return $ x + y}) 3 :: (Maybe Int, Int)
12:33:30 <lambdabot>  Couldn't match `Int' against `(a, s)'
12:33:50 <dmhouse> Oh, you define it.
12:34:22 <jethr0> sry it's not commented. it's kinda exploratory code
12:34:33 <glguy> > runStateT (do { x <- get; y <- return 3; return $ x + y}) 3 :: Maybe (Int, Int)
12:34:36 <lambdabot>  Just (6,3)
12:34:53 <matthew-_> is there something odd about defining infix functions in a type class? I'm getting "Invalid type signature" with a function of: (myFunc) :: a -> a -> a
12:35:18 <glguy> > runStateT (do { x <- get; let {y = 3}; return $ x + y}) 3 :: Maybe (Int, Int)
12:35:20 <lambdabot>  Just (6,3)
12:35:35 <dmhouse> ?instances MonadPlus
12:35:36 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
12:35:52 <newsham> > runStateT (do { x <- get; let y = Nothing; return $ x + y}) 3 :: Maybe (Int, Int)
12:35:52 <lambdabot>  Parse error
12:35:53 <glguy> newsham: you described MaybeT (State Int) Int
12:35:57 <OliverB> matthew-_: Are the brackets ok in type signatures like that?
12:36:00 <jethr0> > runStateT (do { x <- get; y <- Nothing; return $ x + y}) 3 :: Maybe (Int, Int)
12:36:01 <lambdabot>  Couldn't match `StateT Int Maybe' against `Maybe'
12:36:35 <matthew-_> OliverB: yeah I think so, pm lambdabot with ?src Num
12:36:59 <lisppaste2> dmhouse annotated #35285 with "rndPosPred with StateT" at http://paste.lisp.org/display/35285#1
12:37:06 <glguy> > runStateT (do { x <- get; y <- lift Nothing; return $ x + y}) 3 :: Maybe (Int, Int)
12:37:08 <lambdabot>  Nothing
12:37:27 <lisppaste2> dmhouse annotated #35285 with "forgot to change the type signature" at http://paste.lisp.org/display/35285#2
12:37:37 <dmhouse> jethr0: see ^^ that second one.
12:37:41 <glguy> jethr0: You should look up MonadRandom on the wiki
12:37:52 <glguy> jethr0: MonadRandom is a newtyped StateT and would make that better
12:38:11 <jethr0> glguy: k, i thought so already but was too lazy to check it out
12:38:14 <glguy> jethr0: that way you would not have to lift stuff
12:39:01 <jethr0> dmhouse: second one? you mean the MonadPlus instances?
12:39:16 <dmhouse> jethr0: I meant my second annotation.
12:39:28 <emk> GHC is rather slow to bootstrap on a PowerPC laptop...
12:39:29 <jethr0> k
12:40:15 <johnnowak> emk: it takes a few hours
12:40:22 <glguy> emk: that might be an understatement
12:40:26 <dmhouse> jethr0: the disadvantage is that all the rest of your functions have to be in StateT too.
12:40:36 <jethr0> dmhouse: thx, i've used something similar before but had forgotten about it.
12:40:53 <jethr0> disadvantage of what?
12:40:58 <glguy> dmhouse: not much of a disadvantage if you don't use explicit typing though
12:41:01 <dmhouse> Moving that one function to StateT.
12:42:39 <rjs> In Haskell's case expression, if you have multiple cases with the same case body, is there a shorter alternative to listing each of case and using a let/with statement?
12:42:39 <jethr0> ah, i had overlooked the StateT part and wondered how guard knew what to return ^_^
12:42:47 <jethr0> thx dmhouse, i'll play a bit with that
12:42:56 <dmhouse> jethr0: oh, because StateT s Maybe is a MonadPlus instance.
12:43:01 <jethr0> yes
12:43:26 <dmhouse> jethr0: I'm not sure actually using StateT will be that advantageous here.
12:43:34 <glguy> StateT passes the MonadPlus calls through
12:43:53 <jethr0> > case () of _ {4 > 5 || 3 < 2 -> code}
12:43:53 <lambdabot>  Parse error
12:43:57 <jethr0> although it's kinda a hack
12:44:14 <glguy> dmhouse: if he uses MoandRandom, he won't need to lift the functions manually, and if he doesn't use explicit typing, very little will change, no?
12:44:24 <jethr0> dmhouse: i agree. but at least i want to understand transformers so i can use them when i need them
12:44:31 <dmhouse> I think MonadRandom will be the nicest formulation.
12:44:39 <glguy> > case () of _ | otherwise -> 1
12:44:41 <lambdabot>  1
12:44:50 <dmhouse> glguy: well changing type signatures is probably a good thing, it means you know what's going on.
12:44:57 * dmhouse is a big fan of type signatures in code
12:45:11 <jethr0> yes, but i "need" a state monad anyways. so i'd have to transform the random monad or vice versa
12:45:17 <dmhouse> jethr0: yeah.
12:45:23 * glguy is lagged badly, forced to use Tor (fyi)
12:45:43 <glguy> MonadRandom *is* a StateT, just wrapped up
12:45:47 <jethr0> dmhouse: for production code i agree, but for manual refactoring it's not so nice. and since the compiler can produce most annotations it's kinda wasted time to write them
12:46:00 <jethr0> but i like annotations because then i have to think about what i'm actually trying to do :)
12:46:07 <dmhouse> jethr0: the problem is that in genMaze you have 'return []' if rndPosPred was Nothing.
12:46:08 <jethr0> ah, i see
12:46:31 <dmhouse> Which makes it hard to incorporate using StateT st Maybe everywhere.
12:46:36 <jethr0> dmhouse: yes, i've thought about that too. that's a problem i've come across before.
12:47:03 <jethr0> but one could wrap the function in "maybe [] id $"
12:47:53 <jethr0> still, it's all kinda hacked, so i'll work a little more until i'll become a guru and only write concise/correct/beautiful code
12:48:09 <dmhouse> I still think MonadRandom would be worth looking at.
12:49:05 <jethr0> sure, i'll definitely have a look
12:49:07 <jethr0> thx
12:51:17 <jethr0> how does the "<-" in "StateT a Maybe b" react to being presented with a "<StateT> Nothing"? does it go to mzero?
12:51:24 <glguy> jethr0: maybe [] id $ is: fromMaybe []
12:51:32 <jethr0> k
12:51:51 <dmhouse> jethr0: it'll cause the whole thing to go to Nothing.
12:52:04 <jethr0> that's what i though
12:52:06 <jethr0> t
12:52:18 <dmhouse> jethr0: actually it goes to fail "Pattern match failure", not mzero, but they're equivalent in Maybe.
12:54:17 <jethr0> so when i want to use "fromMaybe []", can i simply lift that to StateT? "liftM (fromMaybe []) $ (do ... :: StateT a Maybe b)"?
12:55:43 <glguy> I believe so
12:57:45 <dmhouse> No.
12:58:21 <dmhouse> Because the RHS is a monadic value in the monad StateT a Maybe.
12:58:32 <dmhouse> So its value will be the b, not the Maybe b.
12:59:09 <newsham> it would be nifty if you could mouse over parts of the program and have it pop up a hint telling you what the inferred type of th eitme was
12:59:23 <dmhouse> > liftM (map toUpper) (return "foo" :: StateT st Maybe String)
12:59:24 <lambdabot>   add an instance declaration for (Show (StateT st Maybe [Char]))
12:59:37 <dmhouse> ?hoogle runStateT
12:59:38 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
12:59:50 <ski> > liftM (map toUpper) (return "foo" :: StateT st Maybe String) `runStateT` ()
12:59:51 <lambdabot>  Just ("FOO",())
12:59:57 <dmhouse> > runStateT (liftM (map toUpper) (return "foo" :: StateT () Maybe String)) ()
12:59:58 <lambdabot>  Just ("FOO",())
13:01:45 <newsham> jethr0: another thing to consider is that you can use a block of maybe code inside of a State block.
13:01:57 <newsham> you dont necessarily have to mix them together
13:02:16 <jethr0> newsham: i've considered that
13:03:04 <newsham> also you might want something like Error to specify what the cause of failure was
13:03:40 <jethr0> yes, but that goes further into transformer territory and i'm not quite there yet...
13:05:10 <jethr0> k, i'll fetch a bit to eat
13:05:35 <glguy> ?type withStateT
13:05:37 <lambdabot> forall a (m :: * -> *) s. (s -> s) -> StateT s m a -> StateT s m a
13:05:37 <glguy> ?type mapStateT
13:05:39 <lambdabot> forall b (n :: * -> *) s a (m :: * -> *). (m (a, s) -> n (b, s)) -> StateT s m a -> StateT s n b
13:07:53 <ski> mapT :: (Monad m,Monad n) => (forall x. m x -> n x) -> (t m a -> t n a)
13:10:30 <sorear> ski: what are you calling that?
13:10:39 <sorear> (bad phrasing)
13:11:03 <sorear> I've written that before, called it metalift
13:11:30 <sorear> it's a lot like lift
13:11:46 <glguy> :t lift
13:11:48 <lambdabot> forall (t :: (* -> *) -> * -> *) a (m :: * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:12:10 <sorear> for instance (metalift lift) has type StateT s Identity a -> StateT s (Reader r) a
13:12:20 <ski> sorear : a MonadFunctor map
13:12:34 <newsham> funky monads
13:12:45 <ski> (or maybe 'FunctorMonad')
13:12:59 <ski> 'lift' is 'return' for 'MonadMonad'
13:13:18 <ski> lift :: id -> t
13:13:27 <ski> lift :: Monad m => id m -> t m
13:13:31 <ski> lift :: Monad m => m -> t m
13:13:34 <ski> lift :: Monad m => m a -> t m a
13:14:00 <ski> there should be a 'join' and 'bind' for 'MonadMonad', too
13:14:17 <ski> tjoin :: t . t -> t
13:14:26 <ski> tjoin :: Monad m => (t . t) m -> t m
13:14:33 <ski> tjoin :: Monad m => t (t m) -> t m
13:14:38 <ski> tjoin :: Monad m => t (t m) a -> t m a
13:15:16 <ski> i wonder whether (MonadMonad t,Monad m) => Monad (t m)
13:16:09 <ski> sorear : anyway .. in a sense i think something like 'liftT' above would be more basic than 'lift'
13:16:09 <sorear> in my system, MonadTrans t => MetaLift t
13:16:31 <ski> s//class/ ?
13:17:31 <glguy> that might be written: s//class/c
13:17:32 <glguy> and then he'd have to confirm
13:17:48 <ski> aha
13:17:54 <dons> evening all
13:18:00 <sorear> yes.
13:18:02 <ski> evening dons
13:18:05 <glguy> evenin'
13:18:06 <ski> wb sorear
13:18:36 * sorear is trying to get irssi startup scripts working ... and I can't start it without stopping first :)
13:19:07 <dons> ?users
13:19:07 <lambdabot> Maximum users seen in #haskell: 303, currently: 297 (98.0%), active: 39 (13.1%)
13:19:26 * glguy remembers that he has quit and join messages turned fof
13:19:36 * sorear connects 7 sorear-lambdabots (just kidding)
13:20:30 <jcreigh> glguy: I has them turned off for a while too, but it's just too confusing for me. People look at you funny when you address someone who just /quit. :)
13:20:37 <jcreigh> *had
13:20:44 <ski> sorear : and what do you have in your 'MetaLift' ?
13:20:55 <ski> just 'metalift' ?
13:21:02 <sorear> yes
13:21:22 <sorear> I'd rather have metalift *in* MonadTrans
13:21:34 <sorear> but that'd probably break too much
13:21:37 <ski> i'd rather have it lower than that
13:21:54 <ski> class FunctorFunctor t => MonadTrans t
13:21:56 <dons> i used to have them disabled
13:22:00 <ski> or something
13:22:07 <dons> buts they're useful for spotting spammers and trolls
13:22:12 <dons> once you memorise their ip addresses
13:23:07 <glguy> when I become a +o on #haskell, I'll turn them back on ;)
13:23:44 <sorear> we don't have +o's here, not for longer than a minute.  only +O's.
13:23:59 <glguy> you know what I meant :-p
13:24:55 <ski_> sorear : i think there's something useful/fun hiding in this ..
13:25:06 <sorear> me too
13:25:43 <sorear> I see requests about every three days for "I have State Int [Char], how do I use it as a StateT Int IO [Char] ?"
13:26:03 <ski_> i'm looking for an 'X' such that one can imagine 'instance (X t,Monad m) => Monad (t m)'
13:26:23 <sorear> with a standard stateToStateT :: State s a -> StateT s Identity a, and metalift, this is easy
13:26:33 <sorear> ski_: that class is called MonadTrans
13:26:38 <sorear> @src MonadTrans
13:26:38 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:27:03 <ski_> sorear : are you sure .. i've not seen to how define a monad with just that
13:27:05 <sorear> class MonadTrans t where (Monad m => Monad (m t))...
13:27:06 <ski_> ?
13:27:11 <ph8> ?t adjust
13:27:11 <lambdabot> Maybe you meant: tell time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
13:27:25 <ski_> class MonadTrans t
13:27:27 <sorear> every MonadTrans needs to define its own monad instance
13:27:27 <ski_>   where
13:27:38 <ski_>   lift :: Monad m => m a -> t m a
13:27:45 <sorear> you could imagine a uber-monadtrans where
13:27:54 <sorear> class UberMonadTrans t where
13:28:01 <ski_> i want a generic 'instance (X t,Monad m) => Monad (t m)' (or close)
13:28:02 <sorear>   lift :: Monad m => m a -> t ma
13:28:15 <sorear>   uberreturn :: Monad m => a -> t m a
13:28:32 <sorear>   uberbind :: Monad m => t m a -> (a -> t m b) -> t m b
13:28:49 <ski_> if i have 'data Foo m = forall t. MonadTrans t => F ...', i can't seem to get 'Monad (t m)' from that
13:28:51 <sorear> instance (UberMonadTrans t, Monad m) => Monad (t m) where
13:29:02 <sorear> ski_: right.
13:29:12 <sorear> what we *want* is,
13:29:13 <ski_> (assuming 'Monad m', of course)
13:29:35 <sorear> class (forall m. Monad m => Monad t m) => MonadTrans t
13:29:42 <ski_> yes
13:29:50 <sorear> but haskell's typeclasses are too weak to express that
13:30:13 <sorear> that could be expressed with explicit dictionary passing
13:30:20 <ski_> that would be nice for showing fixpointed types
13:30:30 <ski_> instead of 'ShowF' crap
13:31:24 <ski_> instance (forall a. Show a => Show (f a)) => Show (Fix f)
13:33:26 <ski_> sorear : though i suspect that one could add some more specific operations to "UberMonadTrans", instead of 'uberreturn','uberbind' ..
13:37:23 <augustss> überReturn...  I like it :)
13:37:35 <ski_> (:
13:37:43 <dons> hey augustss
13:37:51 <augustss> hey dons
13:38:16 <dons> I'm here in Nice for PADL and POPL, sitting next to dcoutts.
13:38:33 <dons> we had a nice dinner tonight with John Hughes and others, talking about quickchceck and fusion and bytestrings
13:38:36 <dons> all a lot of fun
13:38:44 <augustss> I'm here in Aruba, 28C, looking out at the beach.
13:38:51 <dons> oh very very nice
13:39:01 <augustss> nice, but not Nice ;)
13:39:02 <dons> yeah, its about 18 here
13:39:06 <ski_> where is Aruba ?
13:39:11 <dons> and the beach isn't sand in Nice
13:39:18 <augustss> Just off the coast of Venezuela
13:39:24 <dons> lovely food though, here.
13:39:34 <augustss> Yeah, can't beat the food
13:40:11 <dons> had some cherry sorbet after dinner. very good
13:40:20 <dons> how long are you in Aruba for?
13:40:59 <newsham> she had a rasberry sorbet, the kind you find in an icecream store
13:41:22 <sorear> @users
13:41:22 <lambdabot> Maximum users seen in #haskell: 303, currently: 293 (96.7%), active: 44 (15.0%)
13:41:23 <augustss> Oh, just here for 5 days.  going back Tuesday
13:42:49 <jcreigh> @help users
13:42:50 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in last 4 hours
13:43:20 <jcreigh> doesn't the "last 4 hours" seem a little long to count as "active"?
13:43:32 <bakert> yes
13:43:38 <ski_> @seen
13:43:38 <lambdabot> Lately, I have seen _matthew-, allbery_b, astrolabe, augustss, bakert, cmarcelo, dcoutts__, dons, gly, igloo, jcreigh, kolmodin, lumi, luqui, newsham, philippa, putter, sjanssen, ski_ and sorear.
13:43:44 <ski_> @help seen
13:43:45 <lambdabot> seen <user>. Report if a user has been seen by the bot
13:43:55 <bakert> ?seen bakert
13:43:56 <lambdabot> You are in #haskell. I last heard you speak just now.
13:43:59 <bakert> hee hee
13:44:00 <sorear> seen by itself uses 15mins
13:44:01 <ski_> 4 hours too ?
13:44:03 <sorear> @seen dons
13:44:04 <lambdabot> dons is in #ghc, #haskell.hac07, #haskell-overflow and #haskell. I last heard dons speak 3m 44s ago.
13:44:06 <ski_> ah
13:44:25 <sorear> there's also @activity, but it's broken now
13:44:46 <sorear> @help activity
13:44:47 <lambdabot> activity seconds. Find out where/how much the bot is being used
13:44:55 <ulfdoz> hrhr.
13:44:57 <sorear> @activity 60 -- in the last minute
13:44:58 <lambdabot> Plugin `activity' failed with: IRCRaised user error (Serial.readM: no parse)
13:44:59 <ulfdoz> ECHAN, sorry
13:45:05 <sorear> @activity 60
13:45:05 <bakert> in which case i take it back ... last 4 hours is ok for active.  it's a moving window rather than who is literally poised over their keyboard right now.  both would be even better of course but this is officially NOT a feature request.
13:45:06 <lambdabot> Plugin `activity' failed with: IRCRaised Prelude.head: empty list
13:51:27 <Fresco> can anyone help me with this line of code plz?
13:51:30 <Fresco> > mksentences (x:xs) =  (sentences (adjust x)) ++ mksentences xs
13:51:31 <lambdabot>  Parse error
13:51:50 <sorear> certainly
13:51:55 <Fresco> the 'adjust' fucntion doesnt seem to be carried out on x
13:52:18 <Fresco> 'adjust' is supposed to take out the '.' on a string
13:52:48 <sorear> > mksentences = concatMap (sentences . adjust)
13:52:48 <lambdabot>  Parse error
13:52:58 <sorear> (just a pointless refactor)
13:52:58 <Fresco> and sentences is like 'lines' but uses a full stop instead of new line
13:53:21 <sorear> so adjust :: [Char] -> [Char]  is filter (/= '.') ?
13:53:55 <Fresco> no sorry, it basic pattern matching
13:53:58 <Fresco> like
13:54:08 <Fresco> "mr." = "mr"
13:54:22 <sorear> does it only remove a '.' at the end?
13:54:28 <Fresco> pretty much
13:54:44 <Fresco> code is wat words should have their full stop removed
13:54:48 <jcreigh> so "m.r." = "m.r"?
13:55:27 <Fresco> well if that wat i put in then yes :)
13:55:50 <Fresco> all the code for adjust is pattern matching
13:56:26 <Fresco> sorear: what does that code you pasted do exactly?
13:56:56 <sorear> exactly the same as your code, just with a few simplifications
13:57:06 <jcreigh> Fresco: paste your (complete) code using the pastebot:
13:57:08 <jcreigh> @paste
13:57:09 <lambdabot> http://paste.lisp.org/new/haskell
13:57:11 <sorear> using the standard 'concatMap' function
13:57:15 <sorear> @src concatMap
13:57:15 <lambdabot> concatMap f = foldr ((++) . f) []
13:57:28 <Fresco> ok
13:57:32 <sorear> ok, maybe that's not very clear :)
13:57:42 <sorear> concatMap f [] = []
13:57:52 <sorear> concatMap f (x:xs) = f x ++ concatMap f xs
13:58:17 <glguy> adjust x = Map.lookupWithDefault x (Map.fromList [("mr.","mr"),("mrs.","mrs")])
13:58:21 <huschi> why not "concatMap f xs = concat (map f xs)"?
13:58:24 <Fresco> hehe
13:58:40 <lisppaste2> Fresco pasted "sentence, adjust mksentence" at http://paste.lisp.org/display/35293
13:58:52 <Fresco> i've posted it in
13:58:55 <Fresco> one sec
14:00:20 <sorear> I've upgraded cabal post-hackathon and now it's much more verbose.  Is it deliberate that I see the 2k-character command lines?
14:00:27 <Fresco> wat?
14:02:48 <glguy> > let split pred xxs | null a = [] | otherwise = a : split pred b where (a,b) = break pred $ dropWhile pred xxs in split (=='.') "this is. a test. of the. system"
14:02:50 <lambdabot>  ["this is"," a test"," of the"," system"]
14:03:10 <Fresco> :o
14:05:07 <Fresco> seems a little complicated for wat i want to do :S
14:05:12 <glguy> > let split pred xxs = unfoldr f xxs where f xs | null a = Nothing | otherwise = Just (a,b) where (a,b) =break pred $ dropWhile pred xs in split (=='.') "this is. a test. of the. system"
14:05:14 <lambdabot>  ["this is"," a test"," of the"," system"]
14:05:16 <glguy> ?pretty let split pred xxs = unfoldr f xxs where f xs | null a = Nothing | otherwise = Just (a,b) where (a,b) =break pred $ dropWhile pred xs in split (=='.') "this is. a test. of the. system"
14:05:17 <lambdabot>  i = let split pred xxs = unfoldr f xxs
14:05:17 <lambdabot>            where f xs
14:05:17 <lambdabot>                    | null a = Nothing
14:05:19 <lambdabot>                    | otherwise = Just (a, b)
14:05:21 <lambdabot>                    where (a, b) = break pred $ dropWhile pred xs
14:05:23 <lambdabot>        in split (== '.') "this is. a test. of the. system"
14:05:40 <jcreigh> Fresco: hmm...it's still a little unclear to me what you're trying to do.
14:06:01 <Fresco> basically, i want to break up a sting into its composite sentences
14:06:05 <Fresco> but
14:06:15 <Fresco> i dont want "mr." to create a new sentence
14:06:19 <jcreigh> oh, okay.
14:06:35 <chr1s> is it possible to let haskell explicitly memoize results for a function?
14:06:37 <Fresco> but for some reason the peace of code just doesnt do the 'adjust bit'
14:06:45 <chr1s> without keeping a state?
14:06:59 <jcreigh> Fresco: well, you have mksentences :: [String] -> [String]
14:07:13 <jcreigh> so the "x" in "(x:xs)" is a String
14:07:18 <glguy> Fresco: your adjust function would only work if the whole sentense was "mr."
14:07:21 <Fresco> yes
14:07:31 <Fresco> oh crap
14:07:37 <jcreigh> what glguy said. :)
14:07:54 <Fresco> hmm crap.
14:07:56 <glguy> Fresco: You need to parse the sentense into words first
14:08:02 <glguy> > words "like this for example"
14:08:03 <lambdabot>  ["like","this","for","example"]
14:08:34 <Fresco> i see
14:08:51 <jcreigh> > unwords . map reverse . words $ "Or this, for example"
14:08:53 <lambdabot>  "rO ,siht rof elpmaxe"
14:09:07 <jcreigh> so you just need to "map adjust" instead of "map reverse"
14:09:45 <glguy> no sense in unwords-ing them either
14:09:50 <glguy> since you are only going to do it again later
14:10:24 <jcreigh> glguy: hmm? He's trying to break it apart by "sentences".
14:11:22 <glguy> jcreigh: and, he's going to break those apart into worsd
14:11:34 <glguy> jcreigh: so unwords will only make it slower
14:12:52 <Fresco> so something like
14:13:00 <Fresco> unwords . map reverse . words $ n
14:13:01 * glguy &
14:13:19 <Fresco> oops but with adjust
14:14:00 <jcreigh> yeah, that will break them apart into words, map adjust over them, and then concat them back into a single string.
14:14:59 <jcreigh> ...if that's what you want. I hope this is just a learning example, because if you're *really* trying to parse sentences like this, it'll be "one more special case" till the day you die. :)
14:15:27 <Fresco> lol
14:15:38 <dons> ?yow #haskell
14:15:39 <lambdabot> DIDI ... is that a MARTIAN name, or, are we in ISRAEL?
14:15:53 <Fresco> to tell u the truth i'm just trying to not fail this project :(
14:15:53 <dons> are the lambdas getting funky?
14:16:08 <sorear> dons: just sent a patch which (yeah right) fixes the last remnent of the netsplit bug
14:16:18 <dons> hehe
14:16:23 <dons> sorear: yeah, I saw  great!
14:16:29 <dons> i'll reset the bot in a few mins
14:16:36 <sorear> random aside: why does #haskell.hac07 still exist?
14:16:47 <dons> oh, its turned into a bit of a hackers channel...
14:16:53 <dons> kind of like we used to use -overflow for
14:17:01 <dons> so we're stil just talking about the projects we're hacking on
14:17:07 <dons> feel free to drop by :)
14:17:17 <dons> maybe we should merge back to here
14:18:10 <Fresco> jcreigh: it tells me the types are right?
14:18:26 <Fresco> [Char] -> [Char] dosent match [String] -> [Char]
14:20:55 <jcreigh> Fresco: well, if you get a type mismatch, then no, the types aren't all right. :)
14:21:18 <jcreigh> you can ask GHCi (or Hugs) what the type of an arbitrary expression is:
14:21:27 <jcreigh> :t unwords . map reverse . words
14:21:29 <lambdabot> String -> String
14:21:41 <jcreigh> (which also works in-channel because lambdabot is so cool.)
14:23:49 <jcreigh> mksentences seems kinda weird in that it has type [String] -> [String], instead of String -> [String]
14:24:21 <jcreigh> nothing wrong with in and of itself, it just seems you're trying to split up a String, not [String], right?
14:26:09 <astrolabe> bah.  Cont is difficult.
14:26:28 <jcreigh> let's go shopping.
14:26:32 <jcreigh> :P
14:26:35 <astrolabe> good plan
14:34:16 <mahogny> there is no way to run a function that is located in a where class is there? from ghci
14:34:41 <fresco_> jcreigh: sorry could you just explain to me how the whole map thing works with relation to my function?
14:34:51 <jcreigh> :t map
14:34:53 <lambdabot> forall b a. (a -> b) -> [a] -> [b]
14:35:08 <jcreigh> > map toUpper "hello, world!"
14:35:10 <lambdabot>  "HELLO, WORLD!"
14:35:43 <fresco_> i see
14:35:45 <jcreigh> so I have [String], and some function String -> String, I can map that over [String]
14:36:11 <fresco_> i see
14:36:37 <jcreigh> and "adjust" has type String -> String. So we can say map adjust [ "Mr.", "Functional", "Programmer" ] and get [ "Mr", "Functional", "Programmer" ]
14:37:07 <fresco_> i see
14:37:23 <fresco_> gona try this out
14:37:53 <bakert> If I have a list of operators and a list of numbers, how can I form every possible list that uses each number once and only once?
14:38:05 <bakert> My brain just won't do it.
14:38:09 <bakert> :(
14:38:14 <jcreigh> "operators"?
14:38:44 <bakert> plus, minus, add and multiply.  but i'm more interested in the general tactic if you know what i mean
14:39:56 <bakert> how can i get a complete list of the possibilities.
14:41:00 <jcreigh> so, magicFunc [ (+), (*) ] [1,2,3] -> [ 1 + 2, 1 + 3, 2 + 3, 1 * 2, 1 * 3, 2 * 3 ] ?
14:41:52 <bakert> hmm actually i think the number of possibilities might be stupidly large
14:41:59 <bakert> but a basic example:
14:42:29 <bakert> magicFunc [Add, Sub] [1,2] -> [Add 1 2
14:42:33 <bakert> oops ignore that
14:42:52 <bakert> your example yes but mixing the operators up.
14:43:04 <bakert> so 1+2*3 should be possible too
14:44:40 <velco> number of possibilities Noperators^(Noperands-1)
14:44:53 <velco> at most
14:45:10 <fresco_> jcreigh: you mean something like this for my code
14:45:11 <velco> rather (Noperators + 1)^(Noperands - 1)
14:45:14 <fresco_> > mksentences (x:xs) =  unwords . map adjust . words x ++ mksentences xs
14:45:15 <lambdabot>  Parse error
14:45:29 <velco> in ordre to include an "empty" operator, so not all operands need be present
14:45:47 <bakert> velco, well that would be ok.  i'm talking about 4 operators and up to 4 numbers.
14:46:13 <bakert> thinking about it
14:46:54 <velco> and then generate all representations od a Noperandds-1 digin number is Noperators + 1 base
14:47:11 <jcreigh> fresco_: yeah, except there's a precedence issue. You need to say "(unwords . map adjust . words) x ++ mksentences xs"
14:47:55 <fresco_> ahh right ok
14:52:19 <fresco_> its beautiful when haskell works :P
14:53:41 <webus> hi
14:54:35 <bakert> fresco_, i hope to experience that some day
14:54:40 <bakert> :(
15:01:04 <OliverB> bakert, You should be able to do something relatively simple with list comprehensions
15:04:25 <bakert> OliverB, yes it feels like it should be simple but my brain refuses to work out what.  zip and map and blah it keeps saying.  but yes list comprehensions is a good idea.
15:04:30 <bakert> will think abou tthat for a bit
15:05:26 <OliverB> Well, list comprehensions are just wrappers on the usual list functions to make them look nice :)
15:07:10 <sorear> almost everything in haskell is syntax sugar
15:07:47 <dons> ?users
15:07:47 <lambdabot> Maximum users seen in #haskell: 303, currently: 281 (92.7%), active: 42 (14.9%)
15:10:24 * sorear suddenly realizes the real purpose of the hackathon - it got every arch-hacker into the same time zone
15:15:31 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers
15:15:33 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
15:15:52 <Cale> Anyone want to have a look over that before I reddit it?
15:19:14 <sorear> is Lambdabot a Good Example?
15:20:15 <mahogny> anyone has a rule of thumb when a .hs file becomes big enough to split the content?
15:20:44 <sorear> 200-400 lines
15:21:06 <sorear> when I feel the urge to add section headers :)
15:21:17 <mahogny> alright. I passed that limit long ago :P
15:21:31 <sorear> "as soon as I can"
15:21:52 <mahogny> each function here is so huge that they almost deserve files on their own :/
15:22:21 <sorear> hehe. do they have were-blocks or are they giant expresions? :)
15:22:27 <sorear> oh, were-blocks.
15:22:36 <bakert> is it a full moon?
15:22:39 <SamB> heh
15:22:39 <mahogny> both, and add helper functions shared with other huge functions
15:22:46 <SamB> a man who becomes a block?
15:22:57 <SamB> ... that isn't very intimidating!
15:23:08 <bakert> depends on what the block does
15:23:53 <mahogny> the function which does mathematica style pattern matching is soon growing over 100 lines alone :(
15:24:07 <mahogny> lucky I don't have to write /. in C
15:24:33 <SamB> doesn't /. already exist?
15:24:49 <mahogny> not here
15:24:56 <mahogny> I will call it something else though
15:26:16 <mahogny> it looks a bit messy to do the mathematica style {, ,...->... ,} in haskell. too much shit cluttering the code
15:26:46 <mahogny> unless I start adding my own -> symbol but I'm afraid of polluting the binop-space
15:27:01 <mahogny> should I be?
15:27:58 <Cale> http://programming.reddit.com/info/yfyr/comments
15:28:00 <lambdabot> Title: How To Use Monad Transformers (reddit.com)
15:28:03 <twanvl> no more worried than you are about polluting the normal namespace
15:28:24 <sorear> Cale: does lambdabot count as a good example of the pattern?
15:28:26 <mahogny> I am already worried about that. but there I can do some tiny prefixing at least :)
15:28:35 <Cale> sorear: I don't recall.
15:28:40 <Cale> sorear: Let me look
15:29:21 <Cale> ah, yeah, this doesn't look so bad
15:29:33 <twanvl> That is what qualified and hiding are for
15:29:53 <Cale> Though the fake instance of reader is a little distressing.
15:30:19 <mahogny> twanvl, yeah. but I'd still like to lower the probability of a clash to happen
15:30:39 <mahogny> since this is likely going to be used interactively in GHCi
15:30:48 <Cale> Also, it might be able to do better in creating a DSL rather than just having lots of lifted IO everywhere.
15:31:03 <Cale> (but it doesn't seem to do a terrible job of it)
15:41:38 <ski> hm .. if '(x,y)' is a pair, what is '()' called ?
15:41:53 <Igloo> unit
15:42:42 <ski> isn't 'unit' the type ?
15:43:26 <Igloo> It is also the type, yes
15:43:53 <sorear> unit is one of those ultra-cool ML names.
15:43:58 <ski> hm .. maybe 'nuple' will do
15:44:05 <tuukkah> 0-tuple, 1-tuple, ... n-tuple
15:44:06 <ski> sorear : 'ML' ?
15:44:18 <sorear> boring haskellers often call it 'nullary tuple'
15:44:22 <ski> (.. or 'zuple')
15:44:28 <sorear> ski: ML is a language
15:44:43 <ski> ah, that ML
15:45:00 <ski> val () : unit
15:46:00 * ski settles for 'nuple' for the time, hethinks
15:46:26 <Shuttt> bsr tlm
15:48:16 <Cale> I usually refer to it as the empty tuple.
15:48:49 <Cale> Possibly even more boring than "nullary" :)
15:49:09 <SamB> Haskell doesn't have 1-tuples, for some reason!
15:49:26 <sorear> sure it does, just not builtin :)
15:49:55 <jcreigh> why would you want a 1-tuple? Just for consistency?
15:50:04 <sorear> jcreigh: lifting?
15:50:12 <sorear> @src Identity
15:50:13 <lambdabot> newtype Identity a = Identity { runIdentity :: a }
15:50:23 <sorear> aw, Identity is a newtype
15:51:54 <SamB> heh
15:52:40 <jcreigh> sorear: "lifting"? I don't get it. How would a 1-tuple help there? If the answer is very complex, just forget it, and I'll believe you. :)
15:54:32 <sorear> jcreigh: (,) is lifted: (_|_,_|_) /= _|_
15:54:49 <sorear> jcreigh: (# , #) is not: (# _|_ , _|_ #) == _|_
15:55:25 <sorear> (x,) == x (using Python's notation) is false because (_|_,) /= _|_
15:55:50 <sorear> and don't tell me (/=) is strict :)
15:56:35 <SamB> but it *is*
15:57:23 <ClaudiusMaximus> > [1,2,3,4] /= [1,2,3,4,5,undefined]
15:57:24 <lambdabot>  True
15:58:13 <mauke> > [1,2,3,4] /= [1,2,3,4,undefined]
15:58:15 <lambdabot>  True
15:59:31 <ski> > undefine /= ""
15:59:32 <lambdabot>   Not in scope: `undefine'
15:59:34 <ski> > undefined /= ""
15:59:35 <lambdabot>  Undefined
15:59:40 <ski> > "" /= undefined
15:59:42 <lambdabot>  Undefined
16:01:59 <jethr0> i guess (/=) is defined as "[] /= (_:_) = True" or sth like that
16:02:06 <jethr0> > [] /= [undefined]
16:02:07 <lambdabot>  Add a type signature
16:02:11 <jethr0> > [] /= [undefined::Int]
16:02:12 <lambdabot>  True
16:03:03 <sorear> @src [a] (/=)
16:03:03 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
16:03:05 <sorear> @src [] (/=)
16:03:05 <lambdabot> Source not found. You speak an infinite deal of nothing
16:03:11 <sorear> @src (/=)
16:03:12 <lambdabot> x /= y = not (x == y)
16:03:16 <sorear> @src [] (==)
16:03:17 <lambdabot> []     == []     = True
16:03:17 <lambdabot> (x:xs) == (y:ys) = x == y && xs == ys
16:03:17 <lambdabot> _xs    == _ys    = False
16:03:42 <vincenz> ouch
16:03:44 <vincenz> lambdabot is harsh
16:04:13 <matthew-_> @paste
16:04:14 <lambdabot> http://paste.lisp.org/new/haskell
16:04:26 <jethr0> @src [] (/=)
16:04:26 <lambdabot> Source not found. I feel much better now.
16:04:46 <lisppaste2> matthew-_ pasted "what's wrong with this use of specialise?" at http://paste.lisp.org/display/35302
16:05:22 <matthew-_> I keep getting unmatchable type errors with the above (pasted) code
16:05:29 * sorear wonders if anyone else has but {me,dons} has noticed his lack of lb privileges with the error introduced yesterday
16:05:55 <SamB> sorear: I also noticed dons' lack of lb privileges -- does that count?
16:06:04 <matthew-_> agh, why is paste broken?!
16:06:05 <jethr0> i have, because you told me. but then again i haven't got any privileges - - - that i know of...
16:06:06 <sorear> matthew-_: all I get is a proxy error
16:06:18 <matthew-_> sorear: yeah, adding it was fine
16:06:23 <matthew-_> it's since broken
16:06:32 <jethr0> for me the paste is just not loading
16:06:52 <jethr0> matthew-_: your code broke the paste *gasp*
16:06:55 <jcreigh> might have to fall back to, eg, rafb.net
16:07:05 <mbishop> what about that one
16:07:08 <mbishop> dpaste or whatever
16:07:10 <jcreigh> rafb.net/paste, rather
16:07:20 <matthew-_> mmm. the error message has just changed...
16:07:34 <matthew-_> oh, maybe not. ok, will use rafb
16:07:53 <mbishop> yeah dpaste.com, and apparently the guy said he was gonna add haskell coloring soon
16:08:43 <matthew-_> http://rafb.net/p/xMk65V29.html
16:08:44 <lambdabot> Title: Nopaste - why do I get the error at top with this specialise
16:09:23 * matthew-_ hopes this one survives...
16:13:54 <matthew-_> err, any ideas folks?
16:14:26 * jethr0 doesn't know anything about SPECIALIZE
16:15:50 <zzctb> hi, why doesnt hugs like: sum [1,2,2] / length [1,2,2]? thanks.
16:15:52 * monochrom knows only how to locate SPECIALIZE in the parse tree produced by the GHC api :)
16:16:24 <mauke> zzctb: because length returns an Int, which is not what / takes
16:16:25 <jethr0> > (sum [1,2,2]) / (length [1,2,2])
16:16:26 <lambdabot>   add an instance declaration for (Fractional Int)
16:16:26 <lambdabot>     In the definition of `...
16:16:34 <OliverB> zzctb: / is for real number division, use `div` for integer division
16:16:52 <mauke> > let list = [1,2,2] in sum list / fromIntegral (length list)
16:16:54 <lambdabot>  1.6666666666666667
16:17:25 <jethr0> :t length
16:17:27 <lambdabot> forall a. [a] -> Int
16:17:30 <jethr0> :t (/)
16:17:32 <lambdabot> forall a. (Fractional a) => a -> a -> a
16:18:34 <jethr0> > let list = [1,2,2] in sum list / Data.List.genericLength list
16:18:35 <lambdabot>  1.6666666666666667
16:22:58 <ihope> Could one say that monads are epiphanic?
16:23:09 <sorear> @all-dicts epiphanic
16:23:10 <lambdabot> No match for "epiphanic".
16:23:13 <Botje> they're brain-asplodic, rather
16:23:31 * sorear check his copy of TAHD
16:23:38 <jethr0> tahd?
16:23:55 <jethr0> is that the successor book of TaPL?
16:24:42 <ihope> Botje: they're brain-asplodic right up until the point of epiphany.
16:24:48 <sorear> no "epiphanic" in The American Heritage Dictionary, 3rd ed.
16:25:10 * sorear still knows hot to use a paper dictionary
16:25:22 <sorear> that a bad thing? :)
16:25:24 <ski> jethr0 : AtTaPL, iirc
16:25:38 <notsmack> nor the official scrabble player's dictionary
16:25:41 <ihope> sorear: of course it is!
16:26:02 <jethr0> dictionaries are so 90s
16:26:03 <ihope> By the way, the word "sorear" looks very much like a Spanish verb...
16:26:32 <sorear> appearantly I need to lex my nick
16:26:36 <jethr0> tengo ningun idea que significa sorear
16:26:37 <ihope> Lex it?
16:26:56 <jethr0> seems like an antiquated synonym to "google"
16:27:05 <ski> ihope : what do you mean by 'epiphanic' ?
16:27:05 <ihope> Hot nick.
16:27:15 <ihope> As in that's one you're gonna have to drop...
16:27:20 <ihope> ...I think.
16:27:26 <ihope> ski: bicycle-like.
16:27:35 <ihope> Or... wait...
16:27:47 * ski stares blankly
16:27:48 <ihope> You know, it's one of those "eureka" things.
16:28:04 <i> I see.
16:28:35 <s-orear> appearantly there are a lot of illegal chars
16:28:53 <jethr0> @elite sorear
16:28:54 <lambdabot> 5oreaR
16:28:57 <jethr0> @elite sorear
16:28:57 <s-orear> I was trying for ('s',"orear") when freenode mangled it into s
16:28:57 <lambdabot> soRe4R
16:29:02 <\050> Hmm.
16:29:17 <jethr0> > splitAt 1 "sorear"
16:29:18 <lambdabot>  ("s","orear")
16:30:24 <ihope> Yo soreo, tú soreas, él sorea, nosotros soreamos, ellos sorean.
16:30:48 <jethr0> todos soreamos juntos
16:31:01 <sorear> If sorear is bad, stefano is worse.
16:31:13 <jethr0> yup
16:31:16 <ihope> You can't conjugate stefano...
16:31:20 <jethr0> nobody said sorear is bad
16:31:28 <jethr0> but you can "stefanar"
16:32:03 <ihope> Yo stefano todos los días.
16:32:44 <matthew-_> specialisation prevents inlining doesn't it?
16:34:02 <sorear> /nick 9a9baee9-f2c5-4c1c-a2c2-c6062b0335de
16:34:10 <jcreigh> heh
16:34:36 <sorear> why? + specializes to plusInteger#, which inlines to a strict GMP call
16:34:53 <matthew-_> oh ok
16:34:53 <sorear> specialization + inlining are pretty much what makes GHC code fast
16:34:54 <jcreigh> everybody should md5sum their full name and birth date/time and use that as their nick. :)
16:35:02 <matthew-_> mmm.
16:35:11 <sorear> uuidgen isn't good enough?
16:35:48 <af89a6f7-73ca-4d> aww, it truncates.
16:36:05 <sorear> You now you've been hacking haskell too long when: stefan@stefans:/usr/local/src/gtk2hs$ take 20 /dev/random | md5sum
16:36:13 <matthew-_> I was finding that pythag: sqrt (a^2 + b^2 + c^2) was > 10 times slower than sqrt (a*a + b*b + c*c) and I thought that was because of specialisation preventing inlining. but I could be really wrong
16:37:01 <matthew-_> the speed difference is definately right in that. what the cause is I'm not sure of.
16:37:29 <ihope> sorear: :-)
16:37:36 <matthew-_> but I've just spent about 4 hours refactoring some stuff into type classes and now find that the added polymorphism has made the critical path more than twice as slow
16:38:23 <jethr0> aren't type classes mainly resolved at compile time?
16:38:24 <sorear> specialization helps inlining - there is no way ghc can inline an indirect call
16:38:29 <Cale> jethr0: no
16:38:40 <Cale> You do have to weigh in the extra function calls necessary to use typeclasses.
16:38:43 <sorear> jhc OTOH can inline indirect calls...
16:39:01 <Cale> Yeah, it's possible to do so, if you don't mind doing whole-program optimisation.
16:39:03 <sorear> disclaimer: I've only read Boqist
16:39:10 <jethr0> hmm. in the third "scrap your boilerplate" paper i thought something was said about type classes having a faster lookup than (the prior) runtime solution...
16:39:57 <matthew-_> bother, so type classes can never be as fast, with ghc as non-type classes?
16:40:25 <sorear> sure they can
16:40:30 <sorear> use SPECIALIZE
16:40:42 <matthew-_> err, am doing
16:40:59 <Cale> There is the specialise pragma, yeah
16:41:15 <sorear> this isn't automatic because SPECIALIZE can cause code bloat ... i
16:41:31 <sorear> and code bloat --> L1 cache misses
16:41:45 <OliverB> Type classes are faster than a record of functions, for example... I think
16:42:45 <sorear> In GHC, type classes *are* records of functions - except that the compiler knows more about how to optimize them.
16:43:05 <OliverB> Since they're strict and some other reasons (or something like that)
16:43:28 <matthew-_> well I'm at a loss then
16:45:06 <matthew-_> http://rafb.net/p/HGmAYH58.html
16:45:07 <lambdabot> Title: Nopaste - this still isn&#039;t as fast as before...
16:45:47 <matthew-_> where before was Vector3 was not an instance of anything and the functions were written to work on it directly and it was hard coded to use Double
16:46:01 <matthew-_> (@paste still broken)
16:47:20 <matthew-_> I guess I'll have to get out -ddump-simpl to work out what's really going on...
16:50:11 <hyrax42> I thought typeclasses were resolved statically?
16:50:22 <hyrax42> *which instance thereof
16:53:13 <Cale> hyrax42: consider writing  sort :: (Ord a) => [a] -> [a]  putting it into a module and compiling that
16:53:34 <hyrax42> oh!
16:53:36 <hyrax42> woops
16:53:48 <hyrax42> ok but they're still not resolved at runtime, right?
16:53:56 <monochrom> Call sites are resolved statically.  Callees may be forced to stay polymorphic.
16:54:08 <hyrax42> ok
16:54:46 <monochrom> Hmm my statement is wrong.
16:55:01 * matthew-_ gives up and goes to bed
16:55:20 <Cale> sortThem :: (Ord a) => [a] -> [a]; sortThem xs = sort xs
16:55:20 <monochrom> But Cale's example is tell-tale.
16:55:43 <hyrax42> hmm
16:55:53 <Cale> (That second one's a stupid example, but shows that you might have to wait even longer :)
16:56:14 <Cale> Eventually, you have an actual list, and an actual instance.
16:56:22 <hyrax42> hm
16:56:29 <Cale> The dictionary for that instance is passed as a hidden parameter.
16:56:46 * hyrax42 wishes he knew more about the implementation
16:56:49 <Cale> [1,2,3,4,5] :: (Num a) => [a]
16:56:54 <Cale> isn't a fixed value
16:56:56 <Cale> it's a function
16:57:26 <Cale> Specifically, a function from a dictionary for Num, to an actual list.
16:57:59 <Cale> This is sort of unfortunate, because it defeats sharing at times.
16:58:20 <mattam> wdym ?
16:58:27 <monochrom> Lately I am seeing this translation first-hand because I'm playing with the GHC api and asking it to display parse tree details.
16:58:37 <mattam> the function can be applied to various dicts
16:58:44 <jethr0> > let a = [1,2,3,4] in (tail a :: [Int], tail a :: [Double])
16:58:44 <Cale> I kind of suspect that matthew-_'s code may be slower due to recomputing values which would otherwise be shared.
16:58:45 <lambdabot>  Couldn't match `Double' against `Int'
16:58:48 <hyrax42> what is a dictionary?
16:58:59 <monochrom> a record of functions
16:59:06 <Cale> hyrax42: a record consisting of the method implementations for the class
16:59:15 <hyrax42> oh concrete implement-- yeah that
16:59:19 <monochrom> a record of methods implementing a class instance
16:59:20 <Cale> mattam: functions don't memoise
16:59:40 <monochrom> Monomorphism restriction FTW!
17:00:11 * hyrax42 forgets what the monomorphism restriction is, after eternally enabling -fglasgow-exts
17:00:15 <vincenz> ftw=?
17:00:23 <Cale> The monomorphism restriction is mainly an annoyance to try to get you not to write code which loses performance by being polymorphic.
17:00:26 <hyrax42> vincenz: for teh win
17:00:27 <mattam> right, but that could be an interesting optimization for those
17:00:47 <Cale> hyrax42: it's still on with -fglasgow-exts
17:00:51 <hyrax42> oh really
17:00:52 <hyrax42> ok
17:01:00 <Cale> To turn it off, you need -fno-monomorphism-restriction
17:01:03 <hyrax42> but sort would not be allowed then?
17:01:11 <Cale> no, it's fine
17:01:15 <Cale> but if you wrote it like
17:01:23 <Cale> sort = ... point free code ...
17:01:31 <Cale> and didn't give it a type signature
17:01:35 <Cale> then it would complain
17:01:46 <hyrax42> hm
17:01:49 <hyrax42> what would be different?
17:01:50 <Cale> because it has the appearance of being a fixed value
17:01:54 <Cale> but ends up being a function
17:01:59 <hyrax42> oh hm
17:02:14 <Cale> This is a stupid example
17:02:17 <Cale> but consider something like
17:02:28 <Cale> big = product [1..10000]
17:02:41 <Cale> If this gets Num a => a as a type
17:02:48 <Cale> it will be recomputed in each place it's used
17:03:10 <Cale> The defaulting mechanism for Num helps prevent that.
17:03:26 <hyrax42> hmmmmm
17:03:34 <hyrax42> I see it, but I'll have to think about it more
17:03:56 <Cale> This is because it becomes a function from dictionaries to actual numbers
17:04:32 <jethr0> > [(*2), (+3)] `ap` [1,2,3]
17:04:33 <lambdabot>  [2,4,6,4,5,6]
17:05:23 * vincenz waves at jethr0 
17:05:52 * Cale spams http://programming.reddit.com/info/yfyr/comments some more :)
17:05:54 <lambdabot> Title: How To Use Monad Transformers (reddit.com)
17:05:57 <jethr0> huhu vincenz
17:07:11 * jethr0 is finally doing the exercises of "all about monads" and only now realizes how little practical experience he has with monads :(
17:07:42 <centrinia> Arrows generalize Monads. :)
17:08:19 <jethr0> then again there are those that say that arrows are too general
17:08:25 <jethr0> for many applications
17:09:49 * astrolabe mods up cales article
17:10:19 * matthew-_ has achived performance gains by using more specific types at call sites
17:11:18 * centrinia has achieved performance gains by using GHC-6.6 and its autoparallelization. 
17:11:35 * matthew-_ is using ghc 6.6 and has just 1 core
17:11:42 <matthew-_> ;)
17:11:52 <centrinia> I have two cores. It rocks. :D
17:12:48 <jcreigh> My computer has one core. I don't know how many cores I have. :)
17:13:37 <matthew-_> are you made by intel or amd?
17:13:40 <matthew-_> or sun?
17:13:55 <centrinia> He has two ARMs. ;)
17:14:01 <jcreigh> lol
17:14:07 <matthew-_> *grin*
17:14:07 <liyang> and two Thumbs
17:14:08 <hyrax42> Cale: thanks for that post
17:14:45 <liyang> maybe a couple of Palms too. >_>
17:15:25 <centrinia> I have a trillion Cells. :D
17:16:27 <matthew-_> centrinia : you must dissipate a lot of heat then ;)
17:20:49 <Cale> jethr0: Lots of the examples in All About Monads are pretty hard.
17:21:06 <Cale> It overuses the Cont monad and ContT monad transformer
17:21:06 <jethr0> yes, the forth exercise expected me to come up with:
17:21:28 <jethr0> "maybeToMonad Nothing = mzero; maybeToMonad (Just s) = return s"
17:21:43 <vincenz> jethr0: monadplus
17:21:46 <jethr0> even though that's not completely outside my abilities, it's not quite trivial to come up with
17:21:55 <OliverB> Yep, the Cont stuff just blew me out of the water when I saw it (then the easier monad transformer stuff later, was missed)
17:21:55 <vincenz> mzero = monadplus
17:22:02 <jethr0> vincenz: i know
17:22:23 <Cale> It's sad, because it's such a good tutorial otherwise.
17:22:37 <vincenz> nomaware is rather hard to grok at times
17:22:40 <OliverB> Would be great if just the ContT stuff was shifted to the end
17:22:49 <vincenz> too much code so if you don't know haskell well, it's hard to figure out what's going on
17:23:25 <jethr0> i'm quite happy that it exists ^_^
17:23:38 <jethr0> reading it for the 5th time or something like that
17:23:41 * vincenz grokked much more from yaht
17:23:45 <vincenz> and then writing my own monads
17:23:52 <vincenz> jethr0: remember icfp'05?
17:23:58 <vincenz> jethr0: that got me grokking monads
17:24:01 <jethr0> somehow i'm a very iterative person when things get complex. i can't understand everything at once, but have to try things out and come back later
17:24:10 <vincenz> jethr0: ibidem
17:24:11 <jethr0> hehe
17:24:58 <jethr0> vincenz: that for sure helped my haskell skills as well, although i got very p*ssed at this strange error occurring when reading from a lazy hGetContent
17:25:13 * vincenz had a date tonight :)
17:25:14 <jethr0> i still don't know what the problem was
17:25:45 <vincenz> jethr0: odd
17:29:17 <jethr0> vincenz: look what i found on "http://haskell.org/haskellwiki/Haskell_Quiz/Amazing_Mazes/Solution_Burton"
17:29:19 <lambdabot> Title: Haskell Quiz/Amazing Mazes/Solution Burton - HaskellWiki, http://tinyurl.com/y32mf9
17:29:27 <jethr0> getRandNum :: Int -> Int
17:29:29 <jethr0> getRandNum n = unsafePerformIO $ getStdRandom $ randomR (0,n)
17:29:36 <jcreigh> gah
17:29:38 <jethr0> *what a beauty*, hehe
17:29:42 <vincenz> Lol
17:29:51 <mauke> werks grate!
17:29:54 <jethr0> take that referential transparency
17:30:09 <jcreigh> what's wrong with randomRIO?
17:30:12 <jethr0> it seems to actually work (at least some times), which amazes me
17:31:10 <jethr0> jcreigh: that's hardly the biggest problem here
17:36:08 <OliverB> I made a little maze generator a while ago too :)
17:36:37 <jethr0> i'm still working on one, but am having a hard time. how did yours work in a sentence?
17:40:41 <OliverB> Can't quite remember. Something like, take a graph, pick two adjacent nodes (if they're not connected, add an edge)
17:41:50 <OliverB> Then the walls of the maze are where there are no edges
17:42:54 <jethr0> hmm
17:46:09 <jethr0> Cale: any idea what happened to @wiki Monads_as_computation ?
17:46:29 <jethr0> i mean to remember that such an article did exist previously
17:46:52 <monochrom> was it on the old hawiki and never moved over?
17:47:00 * jcreigh wonders why there's so many "Monads as X" documents floating around...
17:47:25 <monochrom> There are two reasons.
17:47:34 <jcreigh> It's only a matter of time until the "Monads as former US presidents" tutorial. :)
17:48:03 <monochrom> One reason is that people wanted help on monads.
17:48:19 <monochrom> The other reason is that monads are very general.
17:48:30 <allbery_b> [02:18] <jcreigh> pah. All the "Monads are like bad analogies" tutorials did nothing for me.
17:48:46 * allbery_b ought to @remember that
17:48:52 <sorear> has that been @remember'd yet?
17:48:57 <allbery_b> not that I saw
17:49:04 <sorear> @quote bad.anal
17:49:05 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
17:49:07 <sorear> @quote bad
17:49:08 <lambdabot> scodil says: you say sledgehammer like its a bad thing
17:49:09 * allbery_b did buffer search
17:49:10 <sorear> @quote bad.t
17:49:11 <lambdabot> scodil says: you say sledgehammer like its a bad thing
17:49:18 <allbery_b> @quote analogies
17:49:19 <lambdabot> No quotes match. I've seen penguins that can type better than that.
17:49:22 <centrinia> Monads considered difficult. :(
17:49:37 <sorear> @remember jcreigh pah. All the "Monads are like bad analogies" tutorials did nothing for me.
17:49:37 <allbery_b> @remember jcreigh pah. All the "Monads are like bad analogies" tutorials did nothing for me.
17:49:37 <lambdabot> Done memoising quote for `jcreigh', if that is their real name...
17:49:38 <lambdabot> Done memoising quote for `jcreigh', if that is their real name...
17:49:39 <allbery_b> oops
17:49:46 <sorear> oops
17:49:46 <allbery_b> is there a @forget?
17:50:00 <monochrom> Imagine you have to teach pre-historic hunters numbers and arithmetic.
17:50:17 <sorear> at the next sync I can push a patch that deletes the quote :)
17:50:27 <centrinia> Well, prehistoric hunters should know the natural numbers and addition.
17:50:34 <ttmrichter> And subtraction.
17:50:42 <allbery_b> ...up to 10
17:50:47 <allbery_b> maybe 20
17:50:57 <ttmrichter> The problem is that Monads are to us non-FP types more like division to pre-historics.
17:50:59 <monochrom> In no time you will have to collapse to "numbers as how many tigers you have killed today", "numbers as how many kids you have", ...
17:51:23 <sorear> monads are abstract objects, nothing more.
17:51:47 <ttmrichter> Yes.  And the way they're typically explained does not help those who want to apply them to non-abstract uses.
17:51:50 <ttmrichter> Hence the analogies.
17:52:00 <ttmrichter> Which I'll admit many don't do much for me.
17:52:11 <jethr0> my theory is that explaining them is hard, hence the gazillions of tutorials
17:52:14 <ttmrichter> But one of the secrets of human psychology is that we don't all respond to the same thing the same way.
17:52:21 <monochrom> Since numbers are so abstract (you can give me five fingers but you can never give me a five), you end up concretizing in all possible directions, and confusing more.
17:52:29 <jethr0> it's as with recursion: explaining it is hard, but once you've grasped it it's not such a big deal
17:52:55 <jethr0> or inductive proofs
17:53:06 <jcreigh> ttmrichter: I agree. When smart FP people talk about monads, I feel like I only know about simple addition, and someone is trying to introduce me to exponents.
17:53:07 <ttmrichter> jethr0: Exactly!  Now I grok monads, but it took reading about a dozen different explanations (and an implementation in Ruby) before I understood.
17:53:09 * centrinia gives monochrom a zero. Here. :)
17:53:19 <monochrom> On this note, I believe in Piaget's theory of learning, at least I believe the rough idea if not the details.
17:53:46 * jethr0 goes off to wikipedia...
17:54:04 <ttmrichter> Luckily for me I've already tried to implement something that Arrows are for so I immediately understood their relevance (after grokking Monads).
17:54:14 <ttmrichter> Otherwise I'd have hit Yet Another Haskell Learning Curve.  :)
17:54:30 * ttmrichter is still studiously avoiding GADTs, though.
17:54:36 <jethr0> i had a very hard time with inductive proofs, because it seemed that nothing was being proven. i think there's an element of "understanding" it once, and from then on just knowing that you've understood it :)
17:54:51 <sorear> all you need is:
17:55:24 <sorear> peano_axiom :: (forall n. p n -> p (Succ n)) -> p Zero -> (forall n. p n)
17:56:03 <centrinia> I'm reading the Joy of Cats. It is not a joyful experience. :(
17:56:07 <sorear> my mine boggles at the ability of haskell's curry-howard interpretation to express pure mathematics
17:56:20 <jethr0> monochrom: wikipedia's article is too long/convoluted for my attention span. what is piaget's theory of learning?
17:56:22 <sorear> (just don't nonterminate)
17:56:57 <allbery_b> GADTs aren't that difficult, really.  it just relaxes some "arbitrary restrictions" in haskell98
17:57:14 <sorear> oh
17:57:17 <centrinia> Transfinite induction. :D
17:57:19 <monochrom> You need to accumulate a large amount of relevant concrete experience before you're ready for an abstraction.
17:57:22 <sorear> duh
17:57:24 <centrinia> They do nonterminate. :)
17:57:29 <sorear> the Peano Axiom is a fold!
17:58:12 <centrinia> Is it a foldr or foldl?
17:58:28 <sorear> foldl is not a fold
17:58:51 <sorear> for fold == catamorphism
17:59:04 <sorear> for fold == banana
18:01:09 <monochrom> Oh, that's just one half.  The other half is: an abstraction you learn today is a bit of concrete experience you use to build the next level of abstraction tomorrow.
18:01:22 <ttmrichter> monochrom: Piaget is right -- for a subset of students.  Other students require the precise reverse.
18:01:49 <monochrom> I have taught many students and I have not see the reverse.
18:01:57 <jcreigh> oh, my ultra-barebones toy compiler would work if only the x86 had 3 or 4 times as many general purpose registers...
18:02:23 <ttmrichter> monochrom: Depends on the field.  I teach language.  There is a LARGE subset of language students who will not open their mouths until they're comfortable with the vocabulary and grammar items in question.
18:02:56 <ttmrichter> monochrom: Again, there is no "one true way" in any field of human endeavour -- including education.
18:02:57 <newsham> the GEOS "operating system" (if it can be called that) for c64 had an assembler that used macros to pretend that page zero (0-255) where registers.
18:03:26 <jethr0> just pretty slow registers
18:03:45 <monochrom> I think there is a way to fit that group of students to Piaget's theory.
18:03:51 <ttmrichter> I think "slow" is no longer PC.  "Differently-abled" registers or "special" registers.
18:04:02 <monochrom> Do you happen to have one such student's brain around so I can open and examine it?
18:04:20 <newsham> retarded registers
18:04:23 <ttmrichter> There are some I'd love to take the brains out of, yes.  But I just finished exams and won't see them again until March.
18:04:24 <jcreigh> in said compiler, I have "compile :: Expr -> State CState Reg" and "addOp :: Op -> State CState ()". Now, I hadn't actually expected that to work, but within a do-block in compile, I can say "addOp $ Add r ra rb" and go on and do other things. Why isn't there a type mismatch?
18:04:49 <sorear> @remember ttmrichter Do you happen to have one such student's brain around so I can open and examine it?
18:04:50 <lambdabot> Done memoising quote for `ttmrichter', if that is their real name...
18:04:55 <ttmrichter> I find it frustrating to teach a class in technical language and have people who refuse flat-out to use the language because they don't know it.
18:05:10 <monochrom> I think you blew the attribution, sorear.
18:05:11 <dibblego> ttmrichter, let it be their loss
18:05:13 <ttmrichter> Sorear: the quote is monochrom's....
18:05:32 <ttmrichter> I'm too serious to let it go.  I just resort to beatings and murders.
18:05:34 <allbery_b> jcreigh: as long as the "State CState" is the same, the final type (Reg vs. ()) only matters when the do-block produces a value
18:05:40 <sorear> I was trying to quote ttmrichter :(
18:05:53 <sorear> "special" registers :(
18:06:14 <jethr0> well, you kinda missed
18:06:38 <jcreigh> allbery_b: okay, thanks. Obviously my understanding is incomplete. I'll have to look deeper into the State monad to convince myself that this is the case.
18:06:58 <jethr0> ttmrichter: i'm not very happing using a language i don't feel comfortable in. but i love reading and watching series/movies in languages i have little clue of, so that kinda balances it
18:07:54 <sorear> @tell dons I erroneously @remember ttmrichter Do you happen to have one such student's brain around so I can open and examine it?
18:07:54 <lambdabot> Consider it noted.
18:08:14 <jethr0> ?list
18:08:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
18:08:16 <ttmrichter> @tell ttmrichter he's an idiot.
18:08:17 <lambdabot> You can tell yourself!
18:08:36 <ttmrichter> That is comedy gold potential....
18:08:50 <jethr0> @help yhjulwwiefzojcbxybbruweejw
18:08:50 <lambdabot> V RETURNS!
18:08:59 <jethr0> oh no, i remember
18:09:38 <allbery_b> jcreigh: it's not specific to State; what matters ina  do-block is that youre' in the same monad, not that you're always producing exactlyt he same typ within the monad
18:09:50 <jethr0> @check \a -> a == (reverse . id . reverse) a
18:09:51 <lambdabot>  Add a type signature
18:09:51 <dylan> is Graphics.X11 a relatively complete xlib binding?
18:10:55 <allbery_b> intermediates can produce any typpe within the monad (this is necessary, otherwise you could not e.g. do a <- readLine; putStrLn a!)
18:11:04 <allbery_b> or whatever that type is
18:11:07 * allbery_b is multitasking
18:11:12 <allbery_b> not type, function
18:11:16 <jcreigh> oh, *right*
18:15:54 <monochrom> I learned monads for real from Phil Wadler's paper.
18:16:30 <ttmrichter> I figured them out from the "assembly-line" analogy followed by "you could have invented" followed by seeing them implemented in a more familiar language (Ruby).
18:16:51 <ttmrichter> Of course I'm in my 40s, rendering me stupid.
18:16:59 <notsmack> you could have invented monads helped me the most
18:17:04 <ttmrichter> Some of the analogy ones -- lovers, monsters, etc. -- were stretched.
18:17:24 <jethr0> yes, i felt too much talked down to in those
18:17:37 <ttmrichter> notsmack: I agree.  Had I seen that one first I'd likely not have needed the assembly-line one.
18:18:24 <monochrom> He says, "Look at this evaluator, it fits the monads.  Look at this evaluator with counting, it fits the monads.  Look at this evaluator with exception, it fits the monads."  And before he continues with "evaluator with both counting and exception", I say, "nice, I see your point."
18:18:32 <monochrom> But that is not all.
18:18:34 <allbery_b> "you could hav invented" was the one that really did it for me, as well.  that, and actually playing with >>= instead of do-notation
18:20:04 <monochrom> One day, I was bored, so I cracked open Lawrence Paulson's ML book.  It's last couple of chapters developed a theorem prover.  As you may know, such a theorem prover consists of a parser, a substitution mechanism, and goal-directed (backward-inference) proof rules (called tactics).
18:20:40 <Saizan> "you could hav invented" explains what >>= actually do in those monads, and tells you that it does different things in every monad, and that the point of being a monad is just having >>= and return
18:21:12 <monochrom> But now you can guess what happened.  I looked at the parser and said "wow this fits the monads!"  Then I looked at the substitution mechanism and said "wow this fits the monads!"  Then I looked at the tactics and said "wow this fits the monads!"
18:21:29 <monochrom> That was when my conversion was complete.
18:23:42 <monochrom> I like the monsters, because I am one.
18:24:53 <sorear> the lack of (Infinity :: Integer) in Haskell is really starting to bug me...
18:24:56 <jethr0> nite everyone
18:25:30 <jcreigh> sorear: is that a joke, or is there seriously a reson to have that?
18:25:47 <sorear> heh. MY theorem prover has no tactics, and its parser is "deriving(Read)"
18:26:04 <sorear> jcreigh: replicateM infinity foo
18:26:34 <sorear> unfortunately, fix Succ won't do... and we want machine integers
18:27:17 <ttmrichter> In parsing, would Arrows help in doing lookforward and backtracking without the nigh-infinite amounts of heap that lookahead parsers typically consume?
18:27:34 <monochrom> If you try to implement a repeatM and think of its strictness, you may see what's difficult.  It is not the fault of the lack of an infinity.
18:28:15 <sorear> repeatM f = liftM2 (:) f (repeatM f)
18:28:33 <sorear> if I use a state monad, that is an unfold
18:28:59 <sorear> but anyway, repeat/replicate is IMO a false dichotomy.
18:29:06 <complaisant> can someone help me out with a problem i'm having with graphics.UI.WX ?
18:29:28 <notsmack> complaisant: only one way to find out
18:29:36 <complaisant> ?paste
18:29:36 <lambdabot> http://paste.lisp.org/new/haskell
18:29:48 <monochrom> You can swear by repeat and never use replicate.  That will eliminate the dichotomy.
18:30:59 <sorear> you've just shifted it - take/id
18:32:24 <monochrom> The trouble with replicateM infinity foo is not so much in the lack of infinity.
18:34:20 <monochrom> Suppose there is an infinity::Integer.  replicateM infinity foo may hang.  The strictness of >>= is, afterall, tricky.
18:35:07 <sorear> fix f x may hang
18:35:53 <sorear> what makes replicateM infinity worse than sequence . repeat?
18:36:52 <monochrom> OK.
18:37:10 <Philippa> ttmrichter: it sounds to me like you're having the kind of problem that's more about how you spec the parser than the combinator lib you use?
18:37:40 <monochrom> Back to the dichotomy.  It seems to me heretic to say it's a false dichotomy.
18:38:01 <ttmrichter> Oh, no, this is more about learning the use of technologies -- finding where they'd be useful come the time to spec, design, etc.
18:38:20 <Philippa> arrows gain over monads in that they can be more tightly restricted
18:38:39 <Philippa> monads all support higher-order computations, whereas an arrow has to be an instance of ArrowApply for that, for example
18:39:13 <sorear> monads *force* you to use higher-order computation
18:39:43 <sorear> even an ArrowApply can express non-functions
18:40:00 <Philippa> "even"? They're not far off being the same thing...
18:40:01 <lisppaste2> complaisant pasted "graphics.UI.WX" at http://paste.lisp.org/display/35313
18:40:22 <monochrom> even an ArrowApply can express monads.  sorry can't resist.
18:40:37 <kNt> here it is
18:40:39 <Philippa> though yes, it's often hard to get much interesting done with a monad without using >>= or join
18:40:40 <kNt> http://paste.lisp.org/display/35313
18:41:52 <complaisant> can someone help me out with a problem i'm having with graphics.UI.WX ? -> http://paste.lisp.org/display/35313
18:41:56 <mattam> @src replicate
18:41:57 <lambdabot> replicate n x = take n (repeat x)
18:44:18 <monochrom> I am as lost as the compiler is regarding Board and Var Board.
18:45:43 <monochrom> Why are you knowingly impersonating a Var Board value as a Board value?
18:47:32 <complaisant> -.-
18:48:05 <complaisant> problem is that i can't take of the Var construtor cos it's a Proproperty
18:48:11 <monochrom> I practice Type Oriented Programming (TOP).
18:48:33 <monochrom> What is "Var Board"?
18:49:21 <monochrom> What you have just stated may be a symptop rather than a problem.
18:49:35 <Cale> type Var a = IORef a
18:49:50 <Cale> from the WxHaskell documentation
18:50:21 <monochrom> Thanks.
18:50:49 <Cale> so envBoard is giving a Var Board
18:50:56 <complaisant> yep
18:50:59 <monochrom> What is "get" in "t0 <- get (envBoard env) value"?
18:51:02 <Cale> so you'll want to read the value out of it here
18:51:48 <complaisant> how can i take the Var Board from the tuple as being only a Board?
18:51:57 <Cale> Oh, t0 might already be what you need
18:52:11 <monochrom> Yeah, I'm wondering why you have t0 and not use it.
18:52:25 <Cale> A value of type Var Board is a mutable cell containing a board.
18:52:38 <monochrom> But I'd hate to not have you explicitly tell me you know what is "get".
18:52:39 <Cale> t0 should be the board which is in the cell when play runs
18:53:21 <Cale> get is part of WxHaskell's attribute system. It appears to be overloaded to allow it to work with IORefs.
18:53:22 <complaisant> well i don't quite know ;)
18:53:39 <complaisant> btw it worked out
18:53:46 <complaisant> as expected.
18:53:50 <complaisant> ty :)
18:54:11 <monochrom> See I face two choices.
18:55:02 <monochrom> I can just guess "use t0".  The result is you say "wow I don't know why but it works great thx".  That is equivalent to giving you fish.
18:56:04 <monochrom> Or I can inflict pain on you in hunting down the definition of "Var", the definition of "get", the definition of ...  and then a solution is deduced from knowing.
18:56:20 <monochrom> That is equivalent to showing you how to fish.
18:57:10 <monochrom> My difficulty is that the 21st century definition of "help" is give fish.
18:57:54 <complaisant> no way
18:57:59 <ho_ho_ho> i want me some fish
18:58:10 <ho_ho_ho> in no particular order
18:58:57 <newsham> ?babel en fr red
18:59:00 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
18:59:04 <newsham> why does that work sometimes and fail sometimes?
18:59:46 <monochrom> You got exactly "?babel en fr red" to work some time ago?
19:00:29 <Saizan> btw, rouge?
19:00:41 <monochrom> If you say, "well last time I didn't use 'red'", well that's some food for thought.
19:00:58 <Cale> Saizan: yeah
19:01:06 <mattam> somethings fishy around here
19:01:06 <notsmack> what's the status of building win32 .dlls from haskell?
19:01:21 <monochrom> Not good status.
19:01:56 <Cale> Perhaps you could use the FFI.
19:02:13 <monochrom> http://www.haskell.org/ghc/docs/latest/html/users_guide/win32-dlls.html  says bad news.
19:02:15 <Cale> Supposing that you can build a win32 DLL from C.
19:02:16 <lambdabot> Title: 11.5. Building and using Win32 DLLs, http://tinyurl.com/yhf3e2
19:02:46 <notsmack> monochrom: yeah, that's what i was reading
19:04:02 <monochrom> Hmm Cale how does it go?  Build a C DLL, but what should be inside?  Its entry point inits ghc rts, and we also link in some haskell .o's into the DLL?
19:04:40 <Cale> monochrom: I suspect it would look just like calling Haskell from C does.
19:04:42 <Saizan> is the HXT arrow interface good if i want to extract data from an XML document? all transformations seems to go from tree to tree, nothing to get informations out
19:04:52 <monochrom> OK I see.
19:05:02 <Cale> Saizan: there's plenty of stuff to extract data
19:05:20 <mbishop> there needs to be a Legell, haskell for lego mindstorms :P
19:05:24 <monochrom> Text.XML.HXT.Arrow.XmlArrow  extracts data
19:06:07 <monochrom> (e.g., are you an element?  what's your name?  are you a text node and what's your text? ...)
19:08:50 <Saizan> ooh, now i see, all the get* ones, thnaks
19:10:35 <newsham> mono: yah, it worked for me sometime this morning or yesterday evening
19:15:16 <SamB> mbishop: is there at least a GCC-based devkit out yet?
19:15:25 <SamB> like brickOS?
19:18:37 <mbishop> SamB: dunno? I used NQC for a while, it's C like, so...gross :)
19:18:49 <SamB> mbishop: I was assuming you meant for NXT?
19:18:52 <mbishop> but there is apparently a nice forth for mindstorms, it even runs on the brick tiself heh
19:18:54 <mbishop> no
19:19:02 <mbishop> I'm too poor to have an NXT :P
19:19:07 <SamB> I can tell you right now that the RCX is not going to be able to run Haskell very well!
19:19:12 <SamB> it only has 32k of RAM!
19:19:19 <mbishop> well, you don't have to run haskell ON the brick
19:19:26 <SamB> oh, thats not fun
19:19:34 <mbishop> really I think all you need to do is compile to bytecode for the h8/300
19:19:36 <SamB> that IR connection is not very reliable
19:20:38 <SamB> you write the Haskell VM that runs in 32k, and I'll get it to compile for the RCX ;-)
19:26:11 <SamB> or you could, you know, apt-get install brickos
19:26:38 <SamB> and just compile your own?
19:28:00 <mbishop> I think brickos is broken
19:28:03 <SamB> oh?
19:28:06 <SamB> what is the problem?
19:28:09 <glguy__> OK, discussion may resume, I have returned
19:28:12 <mbishop> most RCX stuff has been broken heh
19:28:21 <SamB> what do you mean "has been broken"?
19:28:37 <mbishop> a lot of it was never upgraded for mindstorms version 2, which uses a USB tower instead of serial
19:28:38 <SamB> my RCX seems fried so I can't actually test it at the moment...
19:28:43 <SamB> oh, that.
19:28:53 <SamB> that is a minor detail!
19:29:06 <mbishop> not for some things :P
19:29:08 <SamB> I think it is especially minor in Linux...
19:29:10 <SamB> oh?
19:29:23 <SamB> anyway, I have a serial tower ;-P
19:29:27 <mbishop> nqc still requires you to change some code by hand to get it to support usb :\
19:29:53 <SamB> doesn't linux have a driver that allows you to use the USB tower transparently?
19:30:23 <mbishop> It might now, but not when I was still messing with my mindstorms robot heh
19:30:30 <SamB> ah
19:30:45 <SamB> you should have bought in earlier
19:30:54 <SamB> then you would have had a serial port tower, and no trouble!
19:31:16 <mbishop> indeed
19:31:26 <mbishop> I should just sell it and get an NXT anyway :P
19:31:46 <mbishop> a good friend of mine wrote LiNXT, a perl script for talking to the NXT brick
19:31:54 <SamB> I had been waiting for something like mindstorms for years, so I saved up my allowance for a while to get it ;-)
19:34:31 <glguy__> ?bot
19:34:32 <lambdabot> :)
19:34:49 <glguy> ?spell coquod
19:34:51 <lambdabot> could coked couped cocked cooked
19:34:55 <SamB> mbishop: look at http://www.legoeducation.com/store/detail.aspx?by=6&pl=7&ID=390
19:35:09 <SamB> these have been available all along!
19:35:32 <SamB> you could have purchased one if you really wanted it!
19:35:46 <mbishop> SamB: server error
19:35:52 <SamB> hmm.
19:36:34 <SamB> anyway the product ID is W779713
19:37:07 <SamB> does http://www.legoeducation.com/store/detail.aspx?ID=390 work better?
19:37:21 <mbishop> nope
19:37:24 <SamB> huh
19:37:56 <SamB> well if you search on that ID, it brings up the IR tower...
19:41:15 <SamB> hmm, apparantly they still sell RCX 1.0!
19:41:18 * SamB covets
19:41:48 * SamB wonders if he could get a discount by sending in his broken RCX
19:42:02 <hu_hu_hu> RCX? the explosive?
19:42:10 <hu_hu_hu> nm
19:42:14 <hu_hu_hu> thats RDX
19:42:19 <SamB> the lego brick, silly!
19:42:31 <SamB> you know, the yellow one with a screen on it?
19:42:42 <SamB> it beeps when you push the green button?
19:42:57 <hu_hu_hu> no
19:43:24 <SamB> @google RCX
19:43:27 <lambdabot> http://www.rcx.com/
19:43:27 <lambdabot> Title: RCX The World's Ultimate Radio Control Expo
19:43:32 <SamB> @google lego RCX
19:43:36 <lambdabot> http://mindstorms.lego.com/
19:43:36 <lambdabot> Title: LEGO.com MINDSTORMS NXT Home
19:44:04 <hu_hu_hu> i played with legos when i was young, but i didn't need shmancy electronic counterparts
19:44:15 <SamB> hu_hu_hu: hmm?
19:44:21 <SamB> you didn't run it on a brick?
19:44:22 <glguy> fancy-shmancy?
19:44:29 <ho_ho_ho> correctly
19:44:35 <SamB> what *did* you run it on?
19:44:39 <ho_ho_ho> i just built them using the blocks
19:44:42 <ho_ho_ho> i didn't run it on anything
19:44:47 <SamB> oh, legos.
19:44:54 * SamB misread that as legOS
19:44:56 * glguy had two tubs of things from the original space set
19:44:57 <SamB> the OS
19:45:11 <SamB> for the RCX
19:45:30 <ho_ho_ho> i still have two boxes of legos
19:45:42 <ho_ho_ho> mixed in with toys from the mcdonalds happy meals and random junk i found
19:45:44 <glguy> I've got them stashed at my parents house
19:45:51 <ho_ho_ho> pretty sweet memories
19:45:55 <SamB> I live with my parents still
19:46:34 <SamB> (or possibly "again"?)
20:06:56 <sorear> @seen #haskell.hac07
20:06:57 <lambdabot> In #haskell.hac07 I can see beschmi, dons, igloo, kolmodin, kzm_, lemmih, psnl and sjanssen.
20:07:00 <sorear> @seen
20:07:01 <lambdabot> Lately, I have seen notsmack, sieni and sorear.
20:07:29 <sieni> lambdabot: don't blow my cover
20:07:53 <sorear> sieni: be greatful @activity is broken :)
20:42:33 <mattrepl_> anyone have an example of a "readUntil" function?  the type would be Handle -> String -> Float -> IO String, and it would read Chars from the Handle until the String is found or until the timeout (the Float parameter) is reached
20:43:05 <sorear> sure
20:44:25 <sorear> It'd probably be better to break down the problem more.
20:45:05 <sorear> you can write a readUntilStr :: Handle -> String -> IO String fairly easily
20:45:06 <mattrepl_> sure, what's getting me is mainly how to "loop" and check for a condition
20:45:14 <mattrepl_> *nod* did that
20:45:39 <sorear> now write (timeout :: Float -> IO a -> IO (Maybe a))
20:46:01 <sorear> oh wait
20:46:09 <sorear> what do you want readUntil to return?
20:46:19 <mattrepl_> String
20:46:27 <sorear> "" is a string
20:47:06 <sorear> our type system isn't strong enough to say *which* string, so I need additional input
20:47:27 <sorear> all input read before the timeout/stop condition?
20:47:43 <mattrepl_> it's the entire buffer of Chars up to the timeout or the matching of the String argument
20:48:23 <sorear> @src mergeIO
20:48:24 <lambdabot> Source not found. Do you think like you type?
20:48:49 <sorear> (I think that might be subtly wrong, don't take it as a suggestion)
20:49:18 <sorear> the chief difficulty is that if you read the string you want reading to stop.
20:49:34 <sorear> (correct?)
20:49:35 <mattrepl_> yup
20:50:44 <sorear> there is a disgusting hackish solution involving semi-closed handles which I will try to spare you...
20:50:58 <mattrepl_> heh, thanks  =)
20:51:57 <newsham> ?babel en fr red
20:51:58 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
20:52:00 <newsham> ?babel fr en rouge
20:52:02 <lambdabot>   red
20:52:54 <sorear> ok, this is the best I can come up with...
20:52:56 <sorear> @paste
20:52:56 <lambdabot> http://paste.lisp.org/new/haskell
20:54:39 <sorear> no I cant
20:55:00 <sorear> there must be some elegant solution...
20:55:29 <sorear> I can easily do readUntil :: Handle -> String -> Float -> (Char -> IO ()) -> IO ()
20:55:34 <sorear> ie with a callback
20:55:46 <sorear> but using mutable variables just seems ... wrong.
20:57:01 * sorear gives up and goes back to the yhc docs
20:57:17 <mattrepl_> thanks for trying
20:57:30 <sorear> hint: I was looking mostly at concurrency, which can do timeout easily
20:57:47 <mattrepl_> will do some hoogling
20:57:47 <sorear> asynch exceptions may also be useful
21:00:22 <mattrepl_> whaddya know: http://hackage.haskell.org/trac/ghc/ticket/980
21:00:24 <lambdabot> Title: #980 (timeout) - GHC - Trac
21:48:29 <jdrake> I am attempting to read documentation on 'groupBy' in Data.List but it is essentially telling me very little about how to actually use it. I am presuming that "groupBy :: (a -> a -> Bool) -> [a] -> [[a]]" means that the first argument is a sort of equality test, and the second is the list to be operated on. I am not sure of how the equality test works.
21:48:54 <sjanssen> @src groupBy
21:48:55 <lambdabot> groupBy _  []       =  []
21:48:55 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
21:48:56 <lambdabot>     where (ys,zs) = span (eq x) xs
21:49:08 <sjanssen> jdrake: does that help?
21:49:43 <jdrake> one moment
21:51:00 <jdrake> It is not especially helpful
21:51:07 <sjanssen> the tricky (and undocumented) thing about groupBy is that it performs the comparison with the first element of the group, not necessarily consecutive ones
21:51:39 <sjanssen> "how the equality test works" -- you get to supply the test, so it can work however you'd like
21:52:11 <jdrake> What I am essentially trying to do is split a string by spaces, so that "1 2" would be ["1":"2"] (or whatever the syntax for a list is)
21:52:17 <jdrake> I am not even sure if this is the right solution
21:52:32 <sjanssen> > words "1 2"
21:52:34 <lambdabot>  ["1","2"]
21:52:58 <sjanssen> @src words
21:52:59 <lambdabot> words s = case dropWhile isSpace s of
21:52:59 <lambdabot>     "" -> []
21:52:59 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
21:53:02 <sorear> sjanssen: h98 says the first arg to groupBy *must* be an equivalence relation, thus your observation is in fact unobservable. (And groupBy is much less useful)
21:54:27 <Saizan> is there an unproc tool?:)
21:54:36 <sorear> unproc?
21:54:40 <jdrake> What is that s' and s''?
21:54:43 <sorear> like undo for arrows?
21:54:51 <sjanssen> sorear: it ought to be documented in the haddocks, at least
21:54:52 <Saizan> yes
21:55:07 <sorear> there is a standalone arrow preprocessor, yes
21:55:17 <sorear> it's not integrated into the 'bot
21:55:54 <sjanssen> jdrake: s' and s'' are variables bound inside the function
21:58:36 <jdrake> If I have a function that returns IO String (getLine) and I want to use words, which takes a String, how can I get it to work?
21:58:45 <sorear> fmap
21:58:49 <sorear> aka liftM
21:58:53 <sorear> @ty liftM
21:58:55 <lambdabot> forall r (m :: * -> *) a1. (Monad m) => (a1 -> r) -> m a1 -> m r
21:59:10 <sorear> for instance, (a -> b) -> IO a -> IO b
22:00:28 <jdrake> This definition is confusing to me:  liftM :: Monad m => (a1 -> r) -> m a1 -> m r   What does the => part mean exactly?
22:00:40 <sorear> it's an overloaded function
22:01:02 <sorear> Monad m => means that m may be any type in the typeclass called "Monad"
22:01:11 <sorear> IO is a type in "Monad"
22:01:28 <sorear> therefore you can use liftM as (a -> b) -> IO a -> IO b
22:01:34 <sorear> Maybe is also in "Monad"
22:01:41 <sorear> therefore you can use liftM as (a -> b) -> Maybe a -> Maybe b
22:01:44 <sjanssen> jdrake: in English, I'd say, given that m is an instance of the Monad class, liftM :: (a1 -> r) -> m a1 -> m r
22:02:28 <jdrake> ok, so how exactly does this actually work in practice with this: words getLine
22:02:37 <sorear> fmap words getLine
22:02:44 <sjanssen> jdrake: and regarding your previous question, I'd recommend using do syntax here
22:02:46 <sorear> liftM words getLine
22:02:57 <jdrake> It is using do syntax
22:03:02 <sjanssen> do x  <- getLine; print (words x)
22:03:25 <sjanssen> is a little program to get a line and print the words as a list
22:03:48 <jdrake> This is the code I am attempting to get working: http://pastebin.ca/317014
22:04:23 <sorear> btw: paste.lisp.org is generally prefered here
22:04:49 <jdrake> I usually find that one to be slow to load
22:04:56 <jdrake> ok, I have it working
22:05:25 <sorear> good!
22:05:26 <jdrake> I am definitely having issues making the connection between liftM words getLine and liftM :: Monad m => (a1 -> r) -> m a1 -> m r
22:05:45 <Cale> liftM is sort of like map, only it works in general monads.
22:06:40 <jdrake> I am learning from "Write Yourself a Scheme in 48 hours", it seemed a reasonable source
22:06:46 <sgillespie> hello
22:06:54 <Cale> liftM f x = do { v <- x; return (f v) }
22:06:57 <Cale> basically
22:07:03 <Cale> sgillespie: hi
22:07:30 <sgillespie> so i'm trying to find a way to convert a char to int
22:07:39 <sorear> fromENum
22:07:41 <sgillespie> read doesn't like that idea very much
22:07:41 <sorear> fromEnum
22:07:47 <sorear> > fromEnum 'a'
22:07:48 <lambdabot>  97
22:07:50 <sorear> > fromEnum 'A'
22:07:51 <lambdabot>  65
22:07:53 <sorear> > fromEnum '~'
22:07:55 <lambdabot>  126
22:08:14 <sorear> alternatively:
22:08:22 <sgillespie> no...
22:08:24 <sgillespie> i mean
22:08:29 <sgillespie> '1' becomes 1
22:08:30 <sorear> > (read :: String -> Int) ['a']
22:08:32 <lambdabot>  Exception: Prelude.read: no parse
22:08:33 <sorear> > (read :: String -> Int) ['1']
22:08:34 <lambdabot>  1
22:08:37 <sorear> > (read :: String -> Int) ['12']
22:08:37 <zeeeee> when using readFile/writeFile, why does the file end up getting locked? (the error i get for trying to do 2 writeFiles on the same file is: "openFile: resource busy (file is locked)")
22:08:37 <lambdabot>  Improperly terminated character constant
22:08:40 <sorear> > (read :: String -> Int) ['4']
22:08:42 <lambdabot>  4
22:08:49 <sorear> zeeeee: laziness?
22:08:59 <sorear> zeeee: it's also in the Report
22:09:12 <jdrake> I think I am understanding how the syntax fits in together.
22:09:24 <jdrake> I should be good to continue
22:09:26 <jdrake> Thank you
22:09:29 <sorear> Implementations should enforce as far as possible, at least locally to the Haskell process, multiple-reader single-writer
22:10:09 <zeeeee> hmm
22:10:24 <sgillespie> (read :: String -> Integer) ['4']
22:11:33 <Saizan> with ">"
22:11:56 <zeeeee> sorear: from a user's perspective, then, it is unsafe to use writeFile multiple times
22:12:27 <sorear> zeeeee: I think so
22:13:03 <zeeeee> would it help to use openFile/hPut*/hClose? or will hClose behave identically?
22:13:21 <sorear> zeeeee: are you also using readFile ?
22:13:48 <zeeeee> sorear: yeah, my program reads all of a file, seq, writes back to same file, and repeats
22:14:04 <zeeeee> (repeats on same file)
22:14:43 <sorear> probably a bad idea ...  how do you do the seq'ing?
22:15:00 <sorear> Data.ByteString.readFile -- probably better
22:15:12 <zeeeee> c <- readFile path; c `seq` writeFile path (foo c)
22:15:17 <zeeeee> in a do
22:15:26 <sjanssen> not enough strictness
22:15:59 <zeeeee> sjanssen: what is that missing?
22:16:03 <sorear> that only forces the list to WHNF, you need full NF
22:16:19 <sjanssen> zeeeee: that will only force the first character
22:16:24 <sorear> foldr seq () c `seq` writeFile -- probably best
22:16:55 <sjanssen> last c `seq` writeFile -- is generally sufficient
22:18:51 <zeeeee> sorear: ah, so the point is that the bytestring will be constructed wholly/not lazily
22:19:03 <sorear> yes
22:19:21 <sorear> the whole file will be read at once
22:19:26 <sorear> in large chunks
22:23:28 <zeeeee> is this safe, then? c <- Data.ByteString.readFile path; c `seq` Data.ByteString.writeFile path (foo c)
22:23:44 <sjanssen> zeeeee: you don't even need the seq
22:24:12 <zeeeee> sjanssen: but wouldn't that potentially allow the writefile to clobber the file first?
22:24:38 <sjanssen> zeeeee: nope, the IO monad enforces the sequencing for us here
22:35:28 <glguy> Who puts the funk in funktion?
22:35:42 <jdrake> Are there any tutorials that are notable for the number of excercises they give for the tutee to do after a unit?
22:35:59 * glguy thinks YAHT has a couple in each section
22:36:05 <glguy> (but it's been a long time since I read it)
22:36:22 <glguy> All about Monads has exercises for Monads... but they get hard pretty fast
22:37:00 <glguy> ?seen
22:37:00 <lambdabot> Lately, I have seen glguy, jdrake, sjanssen, sorear and zeeeee.
22:37:26 <jdrake> WYaS48H gets a lot of stuff they build on, and explain, but I am not sure it is a good way for me
22:38:12 <glguy> sorear?
22:38:17 <sorear> yes?
22:38:39 <glguy> I was just looking at ?stats... don't you have anything better to do than compete with me for #3 on the most active list?
22:39:05 <sorear> I'm a high school student! I don't have a life!
22:39:32 <glguy> Oh... OK then
22:39:35 <Saizan> ?paste
22:39:35 <lambdabot> http://paste.lisp.org/new/haskell
22:39:46 <sorear> cool!
22:39:58 <sorear> if I try a little harder I'll pass dons!
22:40:07 <glguy> it always boggles me that people don't have paste.lisp.org/new/haskell memorized ;)
22:40:14 <lisppaste2> Saizan pasted "shouldn't this two be equivalent?" at http://paste.lisp.org/display/35335
22:40:29 <sorear> @paste and double click is faster than typing :)
22:40:30 <lambdabot> http://paste.lisp.org/new/haskell
22:40:41 <glguy> ah
22:40:55 <sorear> especially now that allbery_b++ has told me how to make ':' a word character in GPM
22:41:06 <glguy> GPM?
22:41:32 <sorear> I don't know what it stands for
22:41:35 <sorear> @goog GPM
22:41:38 <lambdabot> http://www.gpmracing.com.hk/
22:41:39 <lambdabot> Title: Chin Ngai
22:41:42 <glguy> Saizan: are you finding that those are not the same?
22:41:43 <lucca> heh
22:41:50 <lucca> probably the mouse daemon
22:41:53 <lucca> for text consoles
22:41:57 <glguy> OH
22:42:00 <sorear> ii  gpm                        1.19.6-24                  General Purpose Mouse Interface
22:42:06 <glguy> that's right, sorear is a friend of the console
22:42:22 <Saizan> glguy: yeah, the first returns [] and the second a non empty list, on the same input
22:42:51 <glguy> Saizan: I believe it has to do with having a unique copy of the list to work with from getChildren
22:43:01 <glguy> Saizan: I saw that come up when Cale was playing with HXT
22:43:10 <glguy> for his RSS reader
22:43:25 <sorear> @where hrss
22:43:25 <lambdabot> I know nothing about hrss.
22:43:30 <sorear> @where HRSS
22:43:30 <lambdabot> I know nothing about hrss.
22:43:42 <sorear> weird it was there earier
22:43:58 * sorear has modifyIORef verbosity (+1)
22:44:01 <Cale> hm?
22:44:04 <glguy> http://cale.yi.org/index.php/HRSS
22:44:05 <lambdabot> Title: HRSS - CaleWiki
22:44:20 <glguy> Cale: what was the reason that getChildren didn't sure its results well?
22:44:31 <Saizan> ah, so it's like in the first version the list gets consumed by the second line?
22:44:42 <glguy> share*
22:44:59 <Cale> it didn't?
22:45:06 <glguy> Maybe it wasn't you
22:45:16 <glguy> and I just associated it with you because you were doing all the stuff with HXT at the time
22:45:19 <glguy> that it came up in channel
22:45:26 <sorear> @where+ hrss http://cale.yi.org/index.php/HRSS
22:45:27 <lambdabot> Done.
22:45:42 <Saizan> http://paste.lisp.org/display/35335 <-- i'm finding this two behaving different
22:46:11 <glguy> Cale: also, a while back, you mentioned a couple things that using arrows instead of monads in HXT allowed for
22:46:20 <glguy> do you remember what that might have been offhand?
22:46:37 <Cale> Actually, it's purely a syntactic concern in HXT
22:46:43 <glguy> oh
22:46:44 <Cale> all the arrows in use are actually monads.
22:46:46 <sorear> if getChildren has side effects, those two would be different
22:47:15 <glguy> Cale: I thought you had managed to convince someone in the channel why using Arrows was a good thing in this case
22:47:30 <zeeeee> stupid question to which i just can't dig up an answer: how should i convert between strings and bytestrings?
22:47:32 <Cale> It's just the usage pattern
22:47:45 <Cale> most of the time in HXT, you spend forming long chains with >>>
22:47:53 <glguy> zeeeee: iirc:   map (toEnum . fromEnum)
22:47:55 <Cale> which is awkward with a monad
22:47:56 <sorear> zeeeee: Data.ByteString.pack
22:48:04 <glguy> oh yeah
22:48:05 <sorear> zeeeee: Data.ByteString.Char8pack
22:48:07 <sorear> zeeeee: Data.ByteString.Char8.pack
22:48:09 <Cale> (just because we don't have Kleisli composition in the libraries)
22:48:10 <zeeeee> sorear: but that's conversion with [Word8]
22:48:10 <sjanssen> @hoogle [Word8] -> ByteString
22:48:11 <lambdabot> No matches, try a more general search
22:48:17 <sorear> zeeee: nope
22:48:25 <sorear> @ty Data.ByteString.Char8.pack
22:48:27 <glguy> pack and unpack to and from Bytestrings
22:48:27 <lambdabot> String -> Data.ByteString.Base.ByteString
22:48:31 <sorear> @ty Data.ByteString.Char8.uppack
22:48:33 <lambdabot> Not in scope: `Data.ByteString.Char8.uppack'
22:48:33 <sorear> @ty Data.ByteString.Char8.unpack
22:48:35 <lambdabot> Data.ByteString.Base.ByteString -> [Char]
22:49:11 <sorear> Char8 is the same as byte, but uses a (truncating) Char interface
22:49:13 <zeeeee> ah! thanks
22:49:29 <zeeeee> btw, is Char not 8 bits?
22:49:41 <sorear> no
22:49:48 <sorear> Char is ISO 10646
22:50:00 <sorear> full 21-bit "unicode"
22:50:26 <glguy> but GHC doesn't handle it correctly?
22:50:27 <sorear> Char8 is a bit more convienient for text processing because you can say e.g. split '\n' rather than split 10
22:50:34 <lucca> characters and codepoints and grapheme clusters oh my
22:50:56 <sjanssen> glguy: GHC stores Char correctly, but the IO primitives ignore the higher bits
22:51:03 <glguy> that what it was
22:51:31 <sorear> also char is full UTF32 - very wasteful for ASCII or even chinese
22:52:05 <sjanssen> and this is somewhat recent.  I believe GHC 6.4 was the first release where Char wasn't a Word8 proxy
22:52:08 <Saizan> 32?
22:52:11 <glguy> but that is defined by the spec?
22:52:18 <sjanssen> sorear: not so bad after the list overhead
22:52:32 <sorear> hehehe. yeah.
22:52:36 <sjanssen> just a drop in the bucket, so to speak
22:52:55 <sorear> glguy: no. not the spec.
22:52:58 <sjanssen> glguy: the report says that Char is a Unicode code point
22:53:09 * sorear missed that part
22:53:34 <sjanssen> and is silent on issues of encodings during IO
22:53:37 <sorear> and 32 is the smallest power of two bits that can hold unicode's 20 bit glory
22:54:06 <sjanssen> sorear: http://haskell.org/onlinereport/basic.html#sect6.1.2
22:54:07 <lambdabot> Title: The Haskell 98 Report: Predefined Types and Classes
22:55:17 <glguy> Cale: did your recent MonadTrans posting to prog.reddit cover how stacking them in that manner makes it easier to refactor?
22:55:49 <Cale> Sort of
22:56:02 <Cale> I didn't actually go through a refactoring
22:56:42 <Cale> Maybe it doesn't get that across well enough, you tell me :)
22:56:52 <glguy> It seemed like you said at the beginning that this saves you from having to figure out how all the lifts that change
22:57:04 <glguy> but then I never felt like I was told why
22:57:12 <Cale> Well, the code outside this module is going to use the interface which you present.
22:57:20 <glguy> and no lifts
22:57:31 <Cale> Only the primitives of your language will have to have their lifts adjusted.
22:57:38 <zeeeee> sjanssen: for your soc, did you add encoders/decoders to fps for certain unicode encodings?
22:57:47 <Cale> (or their implementations reworked)
22:58:01 <Cale> that is, the functions being exported
22:58:08 <glguy> oh..
22:58:08 <Cale> so maybe I didn't make that clear enough
22:58:19 <glguy> I wasn't sure if the point was the isolation
22:58:20 <glguy> or
22:58:29 <Cale> For example, the external code which is using this monad won't have to change
22:58:30 <glguy> having the typeclasses for transparent passthrough
22:58:47 <glguy> ok
22:58:54 <sjanssen> zeeeee: unfortunately I didn't complete that part
22:59:00 <glguy> I see, you are saying that refactoring in this module
22:59:05 <glguy> won't affect code outside this module
22:59:12 <Cale> Well, the typeclasses are another point, regarding what to do if you want to have a second monad with the same interface, and share that external code.
22:59:18 <glguy> not that this will make it easier to refactor code outside of this module
22:59:26 <Cale> right
22:59:37 <Cale> Well, it saves you from refactoring the code outside the module
22:59:54 <glguy> righ
23:00:04 <Cale> Because without this idea, it would likely end up with lifts in it too.
23:00:15 <glguy> I think that i just had a preconception about what I was going to see
23:00:23 <glguy> and the got confused when you went in a different directly
23:00:26 <glguy> direction*
23:00:40 <Cale> I do need a better introduction perhaps :)
23:00:53 <Cale> and it would be good to make that idea clearer
23:01:16 <glguy> I think that the article addresses an under-documented concept of newtype aliasing
23:01:27 <glguy> so I was glad to see that as a focus
23:01:57 <glguy> under-documented from the prespective of people learning Haskell
23:02:47 <Cale> yes
23:02:56 <Cale> I've been meaning to write something about this for some time
23:03:18 <glguy> I think that covering Monad transformers without covering this makes them look harder than they shoudl be
23:03:25 <Cale> and some recent remarks I was getting from kawa on reddit spurred me on
23:03:43 <Cale> indeed
23:04:22 <Cale> Monad transformers are better confined to small bits of code, because they really can be confusing when you let them reign over large areas.
23:04:49 <sorear> what do you mean?
23:05:04 <sorear> Lambdabot is almost entirely monad transformer :/
23:05:21 <Cale> LB is a newtype
23:05:22 <glguy> newtyped stack of them
23:06:15 <Cale> You shouldn't actually be messing around with the raw transformers for very much code.
23:06:26 <sorear> ok
23:06:30 <Cale> Though I haven't looked very carefully at lambdabot
23:06:33 <sorear> makes more sense :)
23:06:52 <Cale> The LB dataconstructor should not occur too often, basically :)
23:06:59 <Cale> and it would be good not to export it
23:07:11 <Cale> (I haven't looked at what's actually done)
23:07:25 <sorear> the module that contains LB is far too large already...
23:07:33 <sorear> >800 lines
23:07:52 <Cale> There are some historical problems with lambdabot's monad design :)
23:08:11 * sorear is reading through the code of @pl ... scary
23:08:14 <Cale> At some point, they were trying to separate online from offline activity using the typesystem.
23:08:46 <sorear> at this point, there is no such thing...
23:08:52 <Cale> and there was some strange continuation-like things in there
23:09:07 <sorear> implicit params can still be found in @pl
23:09:13 <Cale> maybe Don or someone's cleaned it up
23:09:28 <sjanssen> implicit parameters?!
23:09:31 * sjanssen goes to gawk
23:09:34 <sorear> it's been cleaned up, but not a great deal
23:09:38 <ttmrichter> @source lambdabot
23:09:39 <lambdabot> Not enough privileges
23:09:41 <sorear> sjanssen: what about them?
23:09:54 <sorear> ttmrichter: @source is broken now.
23:09:55 <ralf`> how do you convert string to int?  eg. stringToInt :: String -> Int
23:10:01 <sorear> ralf`: reaf
23:10:02 <sorear> ralf`: read
23:10:05 <ralf`> or stringToInt :: String -> Maybe Int
23:10:07 <ralf`> thanks.
23:10:20 <sorear> reads
23:10:31 <sorear> > reads "23" :: [(Int,String)]
23:10:33 <lambdabot>  [(23,"")]
23:10:34 <sorear> > reads "2x3" :: [(Int,String)]
23:10:36 <lambdabot>  [(2,"x3")]
23:10:56 <sorear> > [ n | (n,"") <- reads "2" ] :: [Int]
23:10:57 <Cale> > reads "hello" :: [(Int, String)]
23:10:59 <lambdabot>  [2]
23:10:59 <lambdabot>  []
23:11:05 <sjanssen> sorear: I think they're a bit hackish
23:11:13 <sorear> yes
23:11:19 <Cale> Implicit parameters are evil :)
23:11:31 <Cale> Linear implicit parameters are *really* evil
23:12:50 <sorear> Implicit parms come very close to making lambda itself typeable...
23:13:00 <glguy> implicit parameters?
23:13:12 <sorear> glguy: it's in the user's guid
23:13:28 <sorear> @goog implicit parameters users manual ghc
23:13:31 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/307
23:13:31 <lambdabot> Title: #307 (Implicit Parameters and monomorphism) - GHC - Trac
23:13:33 <sorear> @goog implicit parameters user manual ghc
23:13:34 <lambdabot> http://hackage.haskell.org/trac/ghc/ticket/307
23:13:35 <lambdabot> Title: #307 (Implicit Parameters and monomorphism) - GHC - Trac
23:13:42 <glguy> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters.
23:13:44 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
23:13:46 <glguy> - the period
23:13:47 <sjanssen> sorear: this implicit parameter doesn't even look very necessary
23:13:58 <Cale> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#implicit-parameters
23:14:00 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
23:14:05 <Cale> yes :)
23:14:33 <ralf`> I'm also looking for something like python split.  Something with f "a.lkj.lkj" = ["a", "lkj", "lkj"]
23:14:42 <sorear> glguy: lambdabot deletes . on the end of urls
23:14:51 <ralf`> Of course, I could just code it up.
23:14:56 <sjanssen> sorear: I'm going to remove the implicit params in Plugin/Pl/Transform.hs if you haven't already
23:15:15 <sorear> ralf`: there have been *many* discussions on adding something like that to the libraries
23:15:22 <ralf`> Something like split :: String -> String -> [String]
23:15:37 <ralf`> In python, I'd say s.split('.')
23:15:37 <sorear> ralf`: no two people can agree on exactly what this function should do
23:15:41 <sorear> @quote bikeshed
23:15:42 <lambdabot> ConorMcBride says: So, taking Void to be the colour of the empty bikeshed ...
23:15:43 <Cale> hmm, have linear implicit parameters been removed?
23:15:48 <sorear> Cale:
23:15:50 <sorear> Cale: no
23:15:50 <mauke> ralf`: http://rafb.net/p/7MAYl686.html
23:15:52 <lambdabot> Title: Nopaste - No description
23:16:13 <Jaak> > splitRegex (mkRegex ".") "a.lkj.lkj"
23:16:13 <sorear> Cale: they've been removed from the user's guide in a vain attempt to get people to stop using them
23:16:14 <lambdabot>   Not in scope: `mkRegex'
23:16:17 <glguy> Ok, so I read that section of the user manual, and I don't see why you would want these...
23:16:37 <Jaak> bah
23:16:47 <Cale> glguy: basically, you don't
23:16:54 <glguy> when did they think someone might?
23:16:56 <Cale> glguy: they solve a bit of a non-problem
23:17:16 <glguy> least   :: (?cmp :: a -> a -> Bool) => [a] -> a
23:17:16 <glguy>   least xs = head (sort xs)
23:17:18 <glguy> omg
23:17:30 <Cale> When you write a whole bunch of code and then say *oops*, I forgot that I'd need such and such parameter.
23:17:51 <Jaak> ralf`: splitRegex (mkRegex "\\.") "a.lkj.lkj" should work if you have Text.Regex loaded
23:18:04 <glguy> Cale: oh, so its a bandaid?...
23:18:17 <newsham> http://ftp.linux.org.uk/pub/lisp/lispm/lispm-3.mov
23:18:23 <newsham> someone should make something like that for the haskells
23:18:41 * glguy looks at newsham
23:18:45 <Cale> Or you have a bunch of configuration data and you really can't be bothered passing it down to where it's needed.
23:18:56 <sorear> newsham: how well has newsham-lambdabot resisted SILC? :)
23:19:12 <newsham> sorear: still ticking.
23:19:27 <glguy> Cale: would this be a (bad) solution to needing unsafePerformIO for global IORefs?
23:19:41 <sorear> when regular parms aren't good enough, usually people today go straight to ReaderT
23:19:49 <sorear> glguy: yes
23:19:57 <sorear> glguy: it used to be used by lambdabot
23:20:02 <Cale> I think I'd consider unsafePerformIO worse, actually.
23:20:04 <Cale> But yeah
23:20:06 <Cale> similar
23:20:19 <sorear> glguy: lambdabot has no truly global state, only ReaderT and IORefs.
23:20:40 <glguy> :)
23:21:47 <glguy> but you could so: main = do ?globalRef <- newIORef 0
23:21:53 <Cale> newsham: that video just seems grey...
23:22:04 <glguy> or... main = do ref <- newIORef 0 ; let ?globalRef = ref
23:22:06 <kolmodin> morning!
23:22:08 <glguy> (or either?)
23:22:13 <sorear> morning!
23:22:35 <newsham> not all grey here.
23:22:40 <sorear> well, almost midnight here
23:23:59 <Cale> What codec is it using? mplayer says [ffqtrle] vfm: ffmpeg (QuickTime Animation (RLE))
23:24:25 <newsham> dunno.. i'm using qtalternative to view it in media player classic.
23:24:32 <newsham> quicktime should play it fine too
23:26:31 <ralf`> It's frustrating when I can't figure out the dependancies and the scope of import.
23:26:47 <sorear> -ddump-minimal-imports ?
23:27:13 <sorear> wow, remembered it correctly
23:27:39 <ralf`> I can neither load Text.Regex from Jaak's note nor load SplitBy from the working directory, which I cut and pasted from mauke's link above
23:28:05 <sorear> are you using --make with ghc?
23:28:15 <sorear> or are you using ghci?
23:28:19 <ralf`> Sometimes it helps when I leave out the first part.  e.g. just Regex.
23:28:34 <ralf`> sorear: Hold on.  Lemme try that.
23:28:46 <sorear> plain ghc -c Foo.hs requires a -package regex-base
23:28:47 <sjanssen> @where zlib
23:28:48 <lambdabot> darcs get http://haskell.org/~duncan/zlib
23:28:55 <mauke> ghci try.hs # works for me
23:29:11 <sorear> ghci, ghc --make :should work easily
23:31:59 <sorear> @seen TheHunter
23:32:00 <lambdabot> I haven't seen TheHunter.
23:33:27 <glguy> ?losers
23:33:28 <lambdabot> Maximum users seen in #haskell: 303, currently: 264 (87.1%), active: 21 (8.0%)
23:33:58 <mauke> ?shapr glguy
23:33:59 * lambdabot smacks glguy about with a large trout
23:35:15 <sorear> it's ?get-shapr
23:35:27 * ralf` is rereading the ghc users guide. 
