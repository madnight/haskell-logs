00:00:29 <edwardk> another thought is to move a lot of the parameters you have out of your Bat and Ball data representation and into type classes or something where they can be erased by inlining and not carried around everywhere
00:01:29 <sm> you mean like a Sprite type class ?
00:01:47 <edwardk> i.e. instead of Bat { batmaxspeed :: Int , ... } move to class Bat b where maxspeed :: b -> Int, then define an instance of Bat for your concrete Bat data representation that ignores its input and returns a constant max speed
00:02:20 <edwardk> when the compiler gets done with it, it will just return a constant, and it won't take up space or time to plumb it through
00:02:41 <edwardk> or yeah
00:02:49 <edwardk> a sprite class would probably work well too
00:03:10 <edwardk> then make both Bat and Ball instances of Sprite
00:03:54 <edwardk> you want to carry as little around as possible in each data type, lest updates be really slow
00:04:30 <sm> hmm.. why would updates be noticeably slower, from a few extra fields in a type ?
00:04:37 <sm> especially as I have only one instance of each ?
00:04:50 <edwardk> every update you do now has to unpack your Bat into 8 values, build a new thunk for one of them, and back all 8 back together.
00:04:58 <edwardk> er and pack
00:05:06 <edwardk> while most of those values never change
00:05:51 <edwardk> though the strictness annotations will probably do more for you than any of this other stuff
00:06:35 <sm> I figured most of the delay was sdl rendering the whole background every frame, and frame rate/event synchronization issues - not haskell processing. But time to profile
00:06:52 <sm> right.. so just ! for all these attributes eh
00:07:14 <edwardk> yeah
00:09:31 <sm> no visible difference there
00:09:57 <scodil> "Inferred type is less polymorphic than expected Quantified type variable `s' is mentioned in the environment"  is it just me or are there too many verbs in that sentence?
00:10:20 <edwardk> sm: heh, then your bottleneck is probably something you are doing w.r.t. SDL ;)
00:10:28 <scodil> oh wait nm there's supposed to be a newline
00:10:38 <scodil> anyway... what does that mean and how do i fix it?
00:10:38 <dblhelix> scodil: it's two sentences, actually
00:10:44 <dblhelix> scodil: ah, indeed
00:10:58 <dblhelix> scodil: depends on the context :-)
00:11:28 <Cale> scodil: are you using the ST monad?
00:11:29 <scodil> dirAndMag :: forall s d. (Dim d, Floating s) => Vec d s -> (Maybe (Vec d s), s)
00:11:30 <scodil> dirAndMag v = let n = norm v in ( if n == 0 then Nothing else Just (v /. n), n )
00:11:37 <scodil> that's all
00:11:50 <Cale> oh
00:12:05 <sm> ack.. I need to get the profiling libraries for SDL etc.
00:12:11 <scodil> with or without for forall bit. I was just swinging blindly there
00:12:32 <Cale> what's the rest of the error?
00:12:51 <sm> I wonder how to build with profiling
00:13:05 <scodil> wtf is up with the paste these days...
00:13:18 <scodil> oh sorry...nm
00:13:22 <sm> Setup.hs build -prof maybe
00:13:38 <Cale> actually, just delete the type signature and see what ghci infers
00:13:50 <Cale> and that'll probably give you a decent idea of what's wrong
00:14:10 <scodil> ok yeah i was going to paste the error but i'll try that
00:14:27 <Cale> (well, s/delete/comment out/)
00:16:01 <scodil> yeah ok some usage somewhere else is fixing one of the type variables
00:16:21 <edwardk> bbiab printing out a ton of stuff so i have something to read on the flight
00:17:25 <sm> ack.. more library building work.. I want to CODE haskell
00:18:14 <sm> yay.. there it goes
00:18:15 <scodil> why does it do that? I have a function that should be (a b -> a b -> b) and I use it somewhere with concrete type C, like (a C -> a C -> C) but then it complains that I've declared it to by polymorphic in b
00:20:58 <Cale> scodil: that shouldn't be the problem -- if it gives a "less polymorphic than expected" error then it has something to do with the definition itself
00:21:37 <scodil> bizarre.. I just added some signatures to some other functions and now its fine
00:21:55 <Cale> They might have become more polymorphic from you adding those signatures
00:22:00 <Cale> My guess is that it was norm
00:22:23 <scodil> yeah i think that did it
00:22:40 <Cale> Another thing you can do is just turn the monomorphism restriction off.
00:22:51 <Cale> It causes lots of strangeness like that.
00:24:02 <scodil> yeah i think that probably was it because when I added a signature to another function it complained about the monomorphism restriction until I added the other signature to the other function. I think maybe it fixed that type parameter as a way of satisfying the monomorpism restriction
00:30:23 <sm> ok.. indeed, 98% of time is spent in the display function
00:32:16 <sm> I wonder why it shows no detail below that
00:32:59 <sm> maybe because they're all FFI functions ?
00:45:32 <scodil> so if the ddump-simpl output says __inline_me infront of a function, but the function actually isn't inlined where it called, then its not going to be, right?
00:50:46 <JaffaCake> scodil: functions are only inlined if there could conceivably be some benefit from doing so... if the function is only applied to variables, it woin't be inlined, for example
00:52:33 <scodil> ah ok so it has nothing to do with eliminating the overhead of the function call
00:53:53 <scodil> if you see zipWith and map in your core, does that mean that the list was not fused/deforested/whatever? Or does that happen at a later stage?
00:58:49 <scodil> how can you tell when your maps/folds/zips are being fused?
00:59:25 <quicksilver> by looking at generated code
00:59:46 <quicksilver> I don't think any o fthe optimisation rules currently in GHC can fuse zips, though
00:59:48 <roconnor> for some reason that question sounds like the setup to some geeky joke.
01:01:00 <scodil> http://www.haskell.org/ghc/docs/latest/html/users_guide/rewrite-rules.html#id3159016   this says it can fuse zip and zipWith
01:01:02 <lambdabot> Title: 7.11. Rewrite rules, http://tinyurl.com/y7rk9g
01:01:47 <scodil> so if you look at the -ddump-simpl output and there's explicit references to Data.List.map and whatnot, then the list functions where not fused, correct?
01:01:55 <quicksilver> "but on one argument only; if both are good producers, zip will fuse with one but not the other"
01:02:12 <quicksilver> that's what I meant by not fusing zips, I think :)
01:02:26 <scodil> ah ok
01:03:38 <sjanssen> scodil: you want to look for the 'fold/build' rule firing
01:04:08 <sjanssen> -ddump-simpl-stats shows the number of times each rule is applied
01:05:59 <scodil> does the location of the functions to be fused matter? Like, if I import some functions from other modules and chain them in some maps and folds and stuff, will they still fuse?
01:06:57 <roconnor> scodil: I'm not an expert, but functions that are small enough (and non-recursive) will be inlined across modules
01:07:04 <roconnor> this will allow them to be fused
01:07:47 <roconnor> at least that is my understanding
01:09:00 <DRMacIver> Doesn't that depend to some extent on whether the source code for the modules is available? (I'm even less of an expert though)
01:09:21 <quicksilver> of course the function *used* in the 'map' doesn't need to be inlinable
01:09:29 <quicksilver> that can easily just be called
01:09:35 <roconnor> DRMacIver: the source of the small function is stored in the .hi file I think.
01:09:43 <quicksilver> the 'point' of the fusion is to eliminate the construction of the intermediate list
01:09:53 <quicksilver> not to elimination the function call
01:10:00 <quicksilver> (although that might happen too if it is inlinabel)
01:10:11 <DRMacIver> roconnor: ok.
01:10:29 <DRMacIver> Oops, true.
01:11:14 <quicksilver> the thing that needs to have source available is map itself (or foldr)
01:11:33 <quicksilver> so that the optimiser can "see" the (:) constructor being used
01:11:40 <quicksilver> and thus "see" that it is a good producer/consumer
01:16:34 * sm talks to SDL folk about how to speed that up
01:16:49 <roconnor> what is SDL?
01:17:38 <thoughtpolice> www.libsdl.org
01:18:24 <balodja1> what is the most conventional way of creating 'a -> m b' from 'a -> b' ?
01:18:39 <roconnor> ah
01:18:45 <opqdonut> balodja: return . f
01:18:50 <roconnor> we have SDL bindings?
01:18:56 <balodja> thanks
01:19:13 <scodil> i've seen the SDL bindings but they looked kind of dusty... sm do they work ok for you?
01:19:15 <sm> roconnor: sure.. hsSDL
01:19:19 <opqdonut> :t let f :: a->b in return . f
01:19:21 <lambdabot> Not in scope: `f'
01:19:21 <lambdabot>  
01:19:21 <lambdabot> <interactive>:1:26: Not in scope: `f'
01:19:22 <sm> I think they are a newer version
01:19:29 <sm> yes, working well so far
01:19:33 <opqdonut> :t return . (f :: a->b)
01:19:35 <lambdabot> Not in scope: `f'
01:19:41 <opqdonut> bah
01:19:48 <opqdonut> how did that work again?
01:20:03 <opqdonut> :t return . f?
01:20:05 <lambdabot> parse error (possibly incorrect indentation)
01:20:09 <opqdonut> :t return . ?f
01:20:11 <lambdabot> forall b (m :: * -> *) a. (Monad m, ?f::a -> b) => a -> m b
01:20:16 <opqdonut> there!
01:20:31 <DRMacIver> What on earth does ?f do?
01:20:33 <DRMacIver> :t ?f
01:20:35 <lambdabot> forall t. (?f::t) => t
01:21:07 <ADEpt> @source ?f
01:21:07 <lambdabot> ?f not available
01:21:12 <quicksilver> it's an implicit parameter
01:21:16 <DRMacIver> Oh
01:21:24 <quicksilver> it's a haskell extension which will break into your kitchen and eat all your cookies
01:21:35 <quicksilver> it's quite likely to sell your unborn children into the slave trade, too
01:21:41 <quicksilver> so its used it not recommended
01:21:48 <DRMacIver> Marvelous. I had too many cookies anyway.
01:21:54 <quicksilver> s/d it/ is/
01:21:58 <opqdonut> well, it's basically only useful in :type queries
01:23:18 <sm> roconnor, scodil: http://darcs.haskell.org/~lemmih/hsSDL/ is latest.. also on hackage
01:23:20 <lambdabot> Title: Index of /~lemmih/hsSDL
01:24:11 * sm builds an interesting-looking opengl game: roguestar
01:25:04 <profmakx> yay for haskell-games
01:25:34 * profmakx is planning on writing one too... very soon
01:26:20 <roconnor> profmakx: good way to make money.  That guy who wrote tower defence is rich!
01:26:23 <roconnor> ish
01:29:43 <profmakx> well i think it will be some kind of pet-project during my phd ;)
01:30:34 <sm> hah, tower defence is what reawakened my interest in games
01:31:22 <sm> that's a lot of fun! and I thought.. wtf, can haskell + some graphics lib do what flash in a browser can do ?
01:32:44 <sm> would anyone remember which emacs variable causes haskell-mode to scan every hs file in a directory when I visit one ?
01:41:03 <sm> hmm, that's rather cool
01:41:14 <sm> lots to learn from here I think
01:43:00 <sm> http://roguestar.downstairspeople.org/\
01:48:30 <sm> night all
01:48:43 <LeCamarade> sm: Night.
01:49:54 <hpaste>  LeCamarade pasted "Is This a Haskell Quine?" at http://hpaste.org/148
01:50:01 <LeCamarade> ^^
01:50:37 <LeCamarade> Glad hpaste is back.
01:51:43 <quicksilver> using file IO to read your own file is normally considered a big fat cheat
01:51:46 <quicksilver> quine-wise
01:51:50 <osfameron> yeah
01:52:02 <osfameron> though it's quite elegant
01:52:11 <LeCamarade> Oh, they want me to write it out?
01:52:22 <osfameron> in the way of Bart's response to the koan "What is the sound of one hand clapping?"
01:52:28 <LeCamarade> It only works under runhaskell/runghc.
01:52:34 <osfameron> to be honest, I think it's treating the quine problem with the respect that it deserves
01:54:22 <LeCamarade> Yeah. Only it really is a cheat to do something like #! /bin/cat
01:54:25 <LeCamarade> ;o)
01:54:38 <LeCamarade> This involves more.
01:55:16 <osfameron> well, using #!/bin/cat is a valid cat(1) quine, rather than a haskell quine
02:05:07 <sebell> Oh boy, I knew the one for J would be good: ".a=.'''".a=.'',q,q,~a#~1+a=q=.39{a.'
02:05:40 <norpan> osfameron: any text file is a valid cat(1) quine, right?
02:06:42 <osfameron> norpan: I guess so, might be the odd issue with system dependent newlines and unprintables?  dunno
02:07:48 <pitecus> how do i convert a lazy to a strict bytestring?
02:08:40 <quicksilver> pitecus: pack . unpack , but why woul dyou want to?
02:08:53 <norpan> http://www.muppetlabs.com/~breadbox/intercal/quine.html <- some people have far to much time
02:08:55 <lambdabot> Title: A Dissection of quine.i
02:09:33 <pitecus> quicksilver, i have stack overflow somwhere in my code and it looks like it might have something to do with lazy bytestrings...
02:11:15 <osfameron> norpan: nice
02:11:40 <quicksilver> pitecus: sounds unlikely, lazy bytestrings don't normally have a long enough spine. But, try it, then you have elminated the possibility
02:12:01 <pitecus> yup
02:39:09 <yakov> hi
02:39:33 <hpaste>  pitecus pasted "stack overflow" at http://hpaste.org/151
02:40:10 <pitecus> The code i pasted seems to cause stack overflow, but i don't understand how. Any hints?
02:43:11 <quicksilver> don't think that code could possible cause stack overflow, it doesn't contain any recursive calls
02:43:16 <quicksilver> maybe loadModelPtr is the culprit?
02:44:18 <hpaste>  pitecus annotated "stack overflow" with "loadModelPtr" at http://hpaste.org/151#a1
02:44:35 <pitecus> Unlikely too, quicksilver
02:46:27 <malcolmw> what about B.decode?
02:46:52 * quicksilver nods at malcolmw 
02:46:59 <quicksilver> yes, perhaps the decode instances then
02:47:11 <quicksilver> have you got an infinite loop there?
02:47:14 <pitecus> thats  Data.Binary.decode
02:47:23 <quicksilver> something that consumes no bytes but returns successfully
02:47:36 <pitecus> quicksilver, its not infinite, if i increase stack size it runs fine
02:47:47 <malcolmw> IntModel.fromByteString could be another culprit
02:48:26 <hpaste>  pitecus annotated "stack overflow" with "IntMode.fromByteString" at http://hpaste.org/151#a2
02:48:27 * malcolmw thinks like a free variable analyser
02:49:16 <pitecus> Im quite stumped..
02:49:18 <malcolmw> oh hold on, you already gave that.  (/me didn't read the comments)
02:50:24 <malcolmw> tried gdb, then seeing what it near the top of the stack?
02:50:36 <malcolmw> (when it crashes of course)
02:51:42 <pitecus> malcolmw, i ran it with +RTS -xc
02:51:51 <pitecus> the last line is this: <GramLab.Maxent.ZhangLe.Model.fromByteString,Main.predict,GramLab.Commands.runCommand,GramLab.Commands.defaultMain,Main.main>Stack space overflow
02:52:26 <malcolmw> ah
02:52:36 <malcolmw> doesn't look like a very big stack to me :-)
02:53:31 <pitecus> I don't get it
02:55:43 <malcolmw> what does your instance of Data.Binary.get look like for your Model type?  Maybe it has a foldl in it.
02:58:05 <pitecus>     get = return ModelData   `ap` B.get   `ap` B.get     `ap` B.get   `ap` B.get   `ap` B.get `ap` B.get
02:58:28 <pitecus> nothing much to worry about no?
02:58:50 <pitecus> All my get instances are just boilerplate
02:58:52 <malcolmw> and what types are the components, and what are their instance for D.B.get like...
03:00:25 <pitecus> there are a couple more instances: get = liftM2 T B.get B.get
03:00:29 <pitecus> and get = liftM5 TrainSettings B.get B.get B.get B.get B.get
03:00:43 <pitecus> the rest are IntMaps, Maps etc
03:01:45 <malcolmw> for IntMap, the instance of get = liftM IntMap.fromDistinctAscList get
03:02:21 <pitecus> is that a problem?
03:02:34 <pitecus> @src fromDistinctAscList
03:02:34 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
03:03:01 <malcolmw> I don't know, but it suggests that it must keep an accumulator to test for distinctness
03:05:11 <malcolmw> I've found the source, and it uses foldlStrict, so maybe not a problem after all
03:05:21 <pitecus> ya i just saw that too
03:07:17 <malcolmw> but i bet it is due to some other type using a lazy foldl deep within its instance
03:09:47 <pitecus> I wish looking for stack overflows didnt take half of my haskell programming time...
03:10:36 <osfameron> aren't there helpful stack traces and things?
03:11:02 <pitecus> osfameron, they dont look helpful to me...
03:39:19 <araujo> morning
03:42:10 <ajudem_me> hi, can you please help me?
03:43:19 <ivanm> with?
03:43:30 <hpaste>  ajudem_me pasted "unexpected" at http://hpaste.org/152
03:44:17 <ajudem_me> do you know what can it be?
03:44:53 <ivanm> yup
03:45:01 <ivanm> after otherwise, put in an = sign
03:45:05 <ivanm> that should fix it ;-)
03:45:08 <ajudem_me> yes!
03:45:19 <ajudem_me> I've found out at the moment you wrote it ;)
03:45:20 <ajudem_me> tnks =))
03:45:24 * ivanm is amazed that he could diagnose someones problem
03:45:27 <ivanm> ajudem_me: lol!
03:47:28 <ajudem_me> hmmm.. it still has another problem
03:47:52 <ajudem_me> it says that identificador is an undefinded variable
03:48:12 <ajudem_me> but I want it to have the incomming value!
03:48:49 <ajudem_me> why doesn't it work??
03:49:05 <quicksilver> ajudem_me: '==' doesn't bind new names
03:49:14 <quicksilver> ajudem_me: '==' compares existing names
03:50:34 <ajudem_me> quicksilver, so how can I do to access the value in identificador?
03:55:22 <quicksilver> there is no value in it
03:55:22 <quicksilver> because you haven't given it one
03:55:22 <quicksilver> so there is nothing to access :)
03:55:22 <dcoutts> pitecus: btw, not that it turned out to be useful, but for future reference you can convert between strict and lazy bytestrings using to/fromChunks and B.concat, though note that lazy -> strict involves copying the whole thing.
03:55:22 <quicksilver> dcoutts: is that any better than pack.unpack? ISTM that pack.unpack should fuse anyway
03:55:22 <dcoutts> I don't think it does fuse at the moment
03:55:22 <pitecus> ok dcoutts
03:55:22 <dcoutts> but in the next version it will
03:55:22 <quicksilver> ajudem_me: you have to consider the difference between binding and comparison
03:55:22 <quicksilver> ajudem_me: if x == (3,y) -- using some pre-existing y
03:55:22 <quicksilver> ajudem_me: case x of (3,y) -- binding a new y
03:55:22 <quicksilver> ajudem_me: in your particular case you could use a case expression, or you could actually 'embed' that pattern in the linha_p:resto partten you already use
03:55:22 <ajudem_me> quicksilver, of course! you're completly right! I'll access it through linha p ;)
03:55:22 <ajudem_me> tnks =)
03:55:22 <ajudem_me> (I would never be able to finish my work if it weren't for you guys in this channel!! ;))
03:55:22 <quicksilver> ajudem_me: you can expect my bill by Friday
03:55:22 <quicksilver> ajudem_me: ;P
03:55:53 <ajudem_me> lolol... =PP
03:55:58 <ajudem_me> but I was wondering...
03:56:03 <ajudem_me> what do you do for living?
03:56:12 <Jaggederest_> I asked google what to have for dinner... and it was right. Man haskell is giving me brain pain :)
03:56:23 <quicksilver> I'm a programmer.
03:56:41 <ajudem_me> quicksilver, yes.. but why do you come here? =)
03:57:42 <osfameron> meh.  apparently I want a mcdonalds,. that can't be right
03:57:45 <quicksilver> ajudem_me: because I find the conversations interesting
03:57:57 <osfameron> though... I could go and get a decent burger from Danny Rock...
03:58:04 <ajudem_me> quicksilver, oki =)
03:58:12 <quicksilver> ajudem_me: sometimes because I want help with my haskell, too
03:58:28 <ajudem_me> btw... is it possible to use "let" without the "in" ?
03:59:01 <Jaggederest_> osfameron: it told me spaghetti, and I had some sauce and noodles in the cupboard. prescient, I tell you
03:59:08 <DRMacIver> It is inside a do block. I'm not sure what it would mean outside of one.
03:59:52 <osfameron> Jaggederest_: heh ;-)
03:59:57 <pejo> ajudem_me, you might be looking for where instead of let.
04:00:29 <quicksilver> ajudem_me: no, the 'in' is part of the syntax
04:00:40 <quicksilver> except in do blocks, as DRMacIver observes
04:01:36 <ajudem_me> hmm.. I'm reading a tutorial called "a gentle introduction to haskell 98" but I can't find anything about do blocks there... where can I see how it works?
04:03:09 <quicksilver> it's about half way through, in the chapter on monads
04:03:22 <quicksilver> do blocks are not the solution to your problem, though :)
04:03:22 <ajudem_me> oh... ok...
04:03:39 <quicksilver> let me answer your question with a question: why do you want a 'let' without and 'in' ?
04:03:49 <quicksilver> what do you hope to acheive like that?
04:03:54 * osfameron had a pop at the "partition a number" a student mentioned yesterday.  It seemed non-easy
04:03:59 <dons> dcoutts: the single biggest bug report in xmonad atm is that cabal won't install over a running binary. any thoughts on why cabal would not want to do that?
04:04:06 <dons> dcoutts: so common that we have an faq, $ ghc-pkg list Cabal
04:04:07 <dons> /home/dons/lib/ghc-6.6/package.conf:
04:04:07 <dons>     Cabal-1.1.6, Cabal-1.1.7
04:04:09 <dons> grr.
04:04:12 <dons> http://xmonad.org/faq.html#config
04:04:13 <lambdabot> Title: xmonad : frequently asked questions
04:04:42 <dcoutts> dons: hmm
04:05:04 <quicksilver> osfameron: partition a number ?
04:05:04 <dcoutts> dons: check out the copyfile function I guess, see how it's working
04:05:08 <ajudem_me> quicksilver, I think someone taold me that was also a possible sintax..
04:05:08 <ajudem_me> dons tnks =)
04:05:39 <ajudem_me> hmmm... but I'm still with a problem (maybe monads can help)
04:05:39 <ajudem_me> how can I do something like this:
04:05:46 <ajudem_me> let (a,b) = c ??
04:05:54 <osfameron> quicksilver: as in 5 => [[5], [4,1], [3,2], [3,1,1], ... ]
04:06:02 <quicksilver> osfameron: ah *nod*
04:06:08 <quicksilver> ajudem_me: just like that
04:06:23 <osfameron> quicksilver: it's just a question of recursing and then concatenating the results appropraitely
04:06:32 <quicksilver> > let c = (3,4) in let (a,b) = c in a
04:06:34 <lambdabot>  3
04:06:44 <ajudem_me> quicksilver, hmm... but hugs says: Syntax error in expression (unexpected `(')
04:06:51 <osfameron> but then you get duplicates.  Anyway, I gave it 30 mins and got confused.  It was just a bit harder than I'd expected, I'll apply more thought to it later.
04:06:52 <dcoutts> dons: I suspect it is not doing the atomic rename dance
04:07:10 <ajudem_me> quicksilver, not lined up... sorry ;)
04:07:19 <dons> hmm. the issue is that xmonad reforks itself for dynamic restarting,so you have to be able to reinstall over it cleanly.
04:07:34 <dcoutts> dons: probably cabal should use it's own copy function that creates a temp file in the target dir, writes it and then atomically renames over the target file
04:07:40 <dons> hmm. yes.
04:07:50 <dcoutts> dons: check out what bsd install does
04:08:37 <dcoutts> dons: but this is a bit sophisticated for standard copyFile behaviour, so I think we can't just modify it's behaviour, we need a new function.
04:09:04 <dons> ah good idea. what does bsd install do  hm.
04:09:16 <dcoutts> dons: and while we're at it, we need to make open(Binary)TempFile work on all platforms, since this copy & rename needs to create temp files securely
04:09:52 <dcoutts> dons: this is also one of ndm's pet peeves ;-)
04:09:55 <dcoutts> hia ndm :-)
04:09:59 <ndm> dcoutts, indeed it is! hi dcoutts
04:10:11 <ndm> dcoutts, does Hugs really need to do high-security tempFile?
04:10:13 <dons> yeah cool. two against one. has to happen now ;)
04:10:21 <hpaste>  ajude_me annotated "unexpected" with "(no title)" at http://hpaste.org/152#a1
04:10:27 <dozer> is there a "Zen and the art of Haskell"?
04:11:12 <dcoutts> dons: this probably should go in the standard System.IO actually, this safe saving of files is important for text editors too
04:11:12 <dons> with time, dozer, with time.
04:11:22 <dons> yeah.
04:11:36 <dcoutts> dons: so that if the writing fails, we have not overwritten the old target file
04:11:36 <quicksilver> ajudem_me: yes, you can't use _ in an expression
04:11:44 <quicksilver> ajudem_me: _ is also only a binding form
04:11:53 <dcoutts> dons: it relies on rename being atomic, which it is on almost all platforms
04:11:56 <dozer> I think I just grocked monad transforms (StateT, ErrorT and friends)
04:12:05 <quicksilver> ajudem_me: perhaps the following rule of thumb would help you:
04:12:10 <quicksilver> ajudem_me: 1. Never use ==
04:12:25 <quicksilver> ajudem_me: 2. Never, ever, use == when a pattern match would do
04:12:28 <quicksilver> ajudem_me: :)
04:12:33 <dcoutts> dons: but we should probably trial any api in cabal first, before suggesting it for System.IO
04:12:58 <ajudem_me> quicksilver, but how can I do that?
04:13:24 <dons> dcoutts: certainly
04:13:50 <ajudem_me> quicksilver, in this case it would make a big mess....
04:14:01 <ajudem_me> quicksilver: very confusing, probably.. but I'll try
04:14:08 <hpaste>  quicksilver annotated "unexpected" with "something like this?" at http://hpaste.org/152#a2
04:14:21 <quicksilver> ajudem_me: put the binding in the pattern
04:14:39 <quicksilver> ajudem_me: if you find one pattern is too large + confusing, use a case statement to get layers of pattern matching
04:14:53 <quicksilver> case linha of (_,0,prg_tk:_:[]) ->
04:15:01 <quicksilver> erm linha_p
04:16:44 <ajudem_me> quicksilver: case of?? I though Haskell's case was the | something == other_thing = stm
04:17:24 <quicksilver> ajudem_me: no
04:17:36 <quicksilver> ajudem_me: well, that depends what you thing 'case' means
04:17:40 <quicksilver> ajudem_me: | is a guard
04:17:46 <quicksilver> ajudem_me: it's all about boolean expressions
04:17:57 <quicksilver> I would emphasise my earlier point. Rule 1: NEVER USE ==
04:17:58 <quicksilver> :)
04:17:58 <ajudem_me> ok... it's most like  where...
04:19:36 <quicksilver> anyhow, case is pattern matching
04:19:45 <quicksilver> | is boolean expression checking
04:19:55 <quicksilver> pattern matching is preferable when it is applicable
04:20:09 <ajudem_me> ok... I'll try
04:21:25 <quicksilver> ajudem_me: did you also see my annotation to your hpaste?
04:21:25 <DRMacIver> quicksilver: Why never use ==?
04:21:46 <quicksilver> DRMacIver: what I really mean is 'never use == when you could use a pattern match'
04:21:55 <DRMacIver> Wasn't that rule 2? :)
04:22:11 <quicksilver> DRMacIver: but if you are not experienced enoughu to know when you can and can't use a pattern match, never use == is a sensible guidelines
04:22:24 <quicksilver> DRMacIver: you really don't need == in haskell as often as you do in most other languages
04:22:45 <quicksilver> DRMacIver: as to 'why not', well it introduces Eq constraints, so you can't generalise your code to non-Eq situations
04:22:57 <quicksilver> and it looks ugly, and can be harder for the compiler to optimise
04:23:20 <quicksilver> and makes it harder to spot + catch incomplete matching
04:23:32 <quicksilver> (as can be caught with tools like 'catch')
04:32:45 <ndm> @karma+ quicksilver -- promoting catch :)
04:32:45 <lambdabot> quicksilver's karma raised to 4.
04:33:16 <ndm> (which gets released next Monday, woohoo!)
04:35:40 <beelsebob> what are the rules for what characters are allowed in an infix operator again?
04:36:18 <quicksilver> roughly, all the chars used in the build-in operators :)
04:36:23 <beelsebob> heh
04:36:40 <beelsebob> you can't use letters, even in the middle of them, can you?
04:37:08 <quicksilver> nope
04:37:19 <quicksilver> ! | # | $ | % | & | * | + | . | / | < | = | > | ? | @ \ | ^ | | | - | ~
04:37:26 <quicksilver> apparently
04:37:30 <quicksilver> plus the unicode ones, of course
04:38:27 <beelsebob> hmm
04:38:33 <opqdonut> and infix constructors need to start with a :?
04:38:49 <quicksilver> yup
04:42:27 <ajudem_me> quicksilver, yes! tnks =)
04:42:52 <quicksilver> ajudem_me: good :)
04:45:45 <ivanm> @seen LeCamarade
04:45:45 <lambdabot> LeCamarade is in #haskell. I don't know when LeCamarade last spoke.
04:48:48 <ivanm> @tell LeCamarade that quine looks pretty cool.... ghci throws a fit though ;-)
04:48:48 <lambdabot> Consider it noted.
04:50:24 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/153
04:50:34 <ajudem_me> any idea why this is wrong?
04:51:12 <LeCamarade> ivanm: *cough*
04:51:12 <lambdabot> LeCamarade: You have 1 new message. '/msg lambdabot @messages' to read it.
04:51:27 <ivanm> LeCamarade: oh, you are alive then...
04:51:41 <LeCamarade> Yeah. Spying, as always ... :o)
04:51:57 <LeCamarade> I use runghc/runhaskell for the quine.
04:52:14 <LeCamarade> Because I have to preserve the source file.
04:52:20 <ajudem_me> I look at it and it seems the same to me!
04:52:38 <LeCamarade> Which is passed as System.Environment.getProgName action.
04:53:13 <LeCamarade> In most other cases it probably won't work.
04:54:52 <kmb> I have an implementation question that I hope someone can help out with.  Say I have a fixed-size list: [1, 2, 3, 4, 5] that I want to treat as circular in a function in order to rotate one of the elements n positions.  So rotating the second element 2 positions would result in: [1, 3, 4, 2, 5], or rotating the fourth element 2 positions would result in: [1, 2, 4, 3, 5].  There are two cases: if the element can be moved w/o rotating and
04:55:24 <DRMacIver> Why not just create the infinite list [1, 2, 3, 4, 5, 1, 2, 3, 4, 5...]
04:55:33 <DRMacIver> >cycle [1, 2, 3, 4, 5]
04:55:43 <DRMacIver> > cycle [1, 2, 3, 4, 5]
04:55:44 <lambdabot>  [1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3,4,5,1,2,3...
04:56:03 <hpaste>  ajudem_me annotated "(no title)" with "(no title)" at http://hpaste.org/153#a1
04:56:21 <ari> kmb: We didn't get your whole message, it ended at "if the element can be moved w/o rotating and"
04:56:53 <quicksilver> ajudem_me: 'Int' is not 'Integer'
04:57:34 <quicksilver> ajudem_me: you could give sem_erro the correct type by including the type annotation
04:57:42 <quicksilver> sem_erro :: Correcto
05:00:57 <ajudem_me_ghost> sorry, the connection felt...
05:01:00 <ajudem_me_ghost> fall...
05:01:15 <ajudem_me_ghost> well... I'm not sure of the past tense of the verb to fall ;P
05:01:26 <ajudem_me_ghost> quicksilver, I think you said something =)
05:01:36 <quicksilver> :)
05:01:39 <quicksilver> fell
05:01:42 <quicksilver> ajudem_me: 'Int' is not 'Integer'
05:01:46 <quicksilver> ajudem_me: you could give sem_erro the correct type by including the type annotation
05:01:49 <quicksilver> sem_erro :: Correcto
05:02:01 <ajudem_me_ghost> oh... ok =)
05:03:39 <ivanm> LeCamarade: sorry for not replying just before... so, doesn't the quine work in an actual compiled program? :(
05:04:02 <quicksilver> ivanm: no, because it works by the hack of reading the file referenced at $0
05:04:13 <quicksilver> ivanm: in a compiled program that would be the executable code
05:04:20 <quicksilver> ivanm: it's not a quine in the traditional sense :)
05:04:24 <ivanm> ahhh
05:04:25 <ivanm> heh
05:04:36 <ivanm> unless you somehow have it read in the entire source at compile time :s
05:05:08 <DRMacIver> Hm.
05:05:14 <DRMacIver> You could do that, using template Haskell.
05:06:53 <LeCamarade> ivanm: Sorry for not replying right away. :o) No. I haven't even tried it. All I know is that if you put that quine in a file, and add the following shebang at the top, and then chmod the file executable, you have a quine.
05:07:10 <LeCamarade> #! /usr/bin/runghc
05:07:15 <LeCamarade> Or something. ^^
05:07:25 <LeCamarade> Much like a script.
05:07:33 <ivanm> *nod*
05:07:46 <LeCamarade> I was just fresh off doing the Ruby one, and I was starting to feel envious.
05:07:53 <LeCamarade> Ruby:
05:07:56 <ivanm> DRMacIver: heh, opensource at its finest
05:08:07 <LeCamarade> puts `cat $0`
05:10:14 <quicksilver> I continue to claim that use $0 is not a quine :P
05:10:24 <ivanm> heh
05:10:31 <ivanm> is $0 a unix command or something?
05:10:43 <ivanm> LeCamarade: is that the unix cat, or a ruby cat?
05:10:44 <opqdonut> ivanm: it means the name of the file being run
05:10:55 <opqdonut> ivanm: inside `` so it is shell
05:10:56 <opqdonut> i'd guess
05:11:06 <ajudem_me_ghost> help monad
05:11:10 <ajudem_me_ghost> @help monad
05:11:10 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:11:17 <ajudem_me_ghost> @help list
05:11:18 <lambdabot> list [module|command]
05:11:18 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:11:54 <ajudem_me_ghost> @help search monads
05:11:54 <lambdabot> search provides: gwiki google wikipedia gsite
05:12:03 <ivanm> opqdonut: ahhh
05:12:13 <ivanm> LeCamarade: so the ruby one is cheating then?
05:12:14 <ajudem_me_ghost> hmmm... lol... not getting it... how can I get information about monads??
05:12:49 <quicksilver> ajudem_me_ghost: there is material in your tutorial about half way through there is a chapter called 'monads'
05:12:59 <quicksilver> ajudem_me_ghost: and there are some good ones around on the web
05:13:01 <quicksilver> @go all about monads
05:13:03 <lambdabot> http://www.sampou.org/haskell/a-a-monads/html/
05:13:03 <lambdabot> Title: All About Monads
05:13:05 <DRMacIver> ajudem_me_ghost: These days? Throw a stone. You'll probably hit three explanations of what a monad is and at least one blog post explaining why it doesn't matter.
05:13:25 <quicksilver> ajudem_me_ghost: but.. to be honest I don't recommend trying to understand monads until you understand haskell a bit better
05:13:50 <ajudem_me_ghost> ohh... I was just wondering what was do for...
05:14:09 <DRMacIver> do is for pretending you're using an imperative language. :)
05:14:33 <quicksilver> that's only one thing you can use it for
05:14:34 <ajudem_me_ghost> ohhh!!!
05:14:44 <quicksilver> it's also for managing other kinds of interesting computation effect
05:14:48 <ajudem_me_ghost> It sounds good!!! LOL... back to C! ;P
05:14:50 <quicksilver> like failure and choice
05:15:22 <ajudem_me_ghost> well... my colleages didn't need monads to finish the work... I won't need it too, probably ;P
05:15:37 <DRMacIver> quicksilver: Well, monads are for various non-imperative things. But my point was more that do is an imperative looking syntax wrapped around the monadic operations.
05:16:10 <DRMacIver> i.e. I was answering "What is do for?" rather than "What are monads for?" :)
05:16:56 <opqdonut> a computation-theoretical look at quines might be interesting
05:17:07 <opqdonut> as in are they possible in all turing-complete languages
05:17:21 <DRMacIver> I think I read one (possibly on sigfpe's blog?) a while ago.
05:17:29 <LeCamarade> ivanm: Ruby people cheat all the time. We are the only fair people.
05:17:46 <JKnecht> Right.
05:17:52 <ivanm> LeCamarade: "we" as in haskell people?
05:18:01 <DRMacIver> opqdonut: Well you need some String handling and IO capability to do a Quine.
05:18:13 <opqdonut> DRMacIver: yes, given those
05:18:13 <DRMacIver> opqdonut: It doesn't make much sense to write a Turing machine quine for example.
05:18:22 <JKnecht> the others are cheaters.
05:18:35 <DRMacIver> The conclusion I remember is that there were some fairly mild conditions which guaranteed the existence of a quine
05:18:36 <LeCamarade> We don't just break into the shell in a function. For us a quine is one line long, because the langauge rocks, not because we have the `shell eat` operator. Yes, we the OCaml^H^H^H^H^H^H Haskell people.
05:19:01 <opqdonut> LeCamarade: could you give this oneliner haskell quine?
05:20:34 <LeCamarade> opqdonut: Well ...
05:20:44 <quicksilver> I don't think you need IO as such, to be a quine
05:20:56 <quicksilver> a quine is 'a program which, when run, produces its own source code'
05:21:08 <opqdonut> quicksilver: well yes, the io might be provided by the repl-loop :)
05:21:08 <quicksilver> I think a simple value of type String could be a haskell quine
05:21:14 <LeCamarade> quicksilver: Yeah. But you gotta print ...
05:21:16 <opqdonut> or that
05:21:21 <quicksilver> no, you don't have to print
05:21:29 <quicksilver> that's an IO-centric imperative view of a quine :)
05:21:34 <opqdonut> :D
05:21:40 <quicksilver> programs can be 'run' or 'evaluated' without printing anything
05:21:48 <quicksilver> their 'result' might be the top of the stack, or something
05:22:03 <Jaggederest_> return a string of their own source
05:22:09 <quicksilver> yes, quite
05:22:17 <Jaggederest_> "" ?
05:22:19 <opqdonut> quinte = fix eval :)
05:22:29 <opqdonut> quine even
05:22:41 <LeCamarade> getProgName >>= IO.openFile IO.ReadMode >>= IO.hGetContents >>= putStr
05:22:45 <quicksilver> Jaggederest_: no, because the quotation makrs are wrong
05:22:54 <LeCamarade> :oD Criticism not allowed.
05:22:58 <quicksilver> Jaggederest_: if the source is "", the result is "" rather that "\"\""
05:23:01 <LeCamarade> I'm not Australian.
05:23:25 <quicksilver> Jaggederest_: that is, the source of "" is two quotation marks, but the result is the empty string
05:23:46 <Jaggederest_> heh yes I thought of that, but depending on how it's output, it may display quoted
05:23:52 <Jaggederest_> cheating ;)
05:23:53 <ajudem_me_ghost> hmmm... sorry the ignorance, but what's quine?
05:24:08 <quicksilver> ajudem_me_ghost: A program which, when evaluated, produces as its only output its own source
05:24:10 <opqdonut> ajudem_me_ghost: a program that prints or produces it's own source code
05:24:24 <Jaggederest_> @quote stereo
05:24:24 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
05:24:35 <quicksilver> @go inurl:wikipedia program quine
05:24:36 <lambdabot> http://en.wikipedia.org/wiki/Quine_(computing)
05:24:37 <lambdabot> Title: Quine (computing) - Wikipedia, the free encyclopedia
05:26:06 <quicksilver> LeCamarade: "Note that programs which take input are not considered quines. This would allow the source code to be fed to the program via keyboard input, opening the source file of the program, and similar mechanisms."
05:26:28 <Jaggederest_> http://www.nyx.net/~gthompso/self_hask.txt
05:26:28 <quicksilver> Jaggederest_: "Also, a quine which contains no code is ruled out as trivial; in many programming languages executing such a program will output the code (i.e. nothing). Such an empty program once won the "worst abuse of the rules" prize in the Obfuscated C contest."
05:26:58 <Jaggederest_> yes I knew I'd seen that trick somewhere before
05:27:11 <LeCamarade> quicksilver: Oh!
05:27:15 <ajudem_me_ghost> and what's the point of all fuss arround quine?
05:27:46 <Jaggederest_> theyre hard to do. That link I set up has one...
05:28:00 <Jaggederest_> tis skeery. There be dragons?
05:28:05 <LeCamarade> But what they call the cat(1) quine is just #! /bin/cat, which takes input.
05:28:20 <quicksilver> LeCamarade: yes, and I wouldn't call that a quine
05:28:23 <quicksilver> LeCamarade: unless for a joke
05:28:29 <kmb> I have an implementation question that I hope someone can help out with.  Say I have a fixed-size list: [1, 2, 3, 4, 5] that I want to treat as circular in a function in order to rotate one of the elements n positions.  So rotating the second element 2 positions would result in: [1, 3, 4, 2, 5], or rotating the fourth element 2 positions would result in: [1, 2, 4, 3, 5].
05:28:31 <kmb> There are two cases: if the element can be moved w/o rotating and where the element must be inserted into the list at the front.  Is there an idomatic way to handle both of these cases in a function?
05:28:35 <quicksilver> ajudem_me_ghost: it's an interesting little challenge
05:28:36 <LeCamarade> :o(
05:28:42 <kmb> ari: thanks
05:28:48 <ajudem_me_ghost> quicksilver: and what languages can do it?
05:29:09 <Jaggederest_> all turing-complete ones, theoretically
05:29:11 <quicksilver> ajudem_me_ghost: all languages which are turing complete and can somehow output/return computed strings
05:29:40 <ajudem_me_ghost> hmmm... I know what's a turing machine... but I don't know whats a turing complete...
05:29:58 <Jaggederest_> can emulate a turing machine, roughly
05:30:08 <ivanm> is there anyway of calling getStdGen from a ghci prompt to get a new seed>
05:30:09 <ivanm> ?
05:30:20 <DRMacIver> > let rotate n = take 5 $ drop n $ cycle [1, 2, 3, 4, 5] in rotate 3
05:30:21 <lambdabot>  [4,5,1,2,3]
05:30:36 <DRMacIver> Hmm. That's not quite right.
05:30:41 <DRMacIver> > let rotate n = take 5 $ drop n $ cycle [1, 2, 3, 4, 5] in rotate 1
05:30:42 <lambdabot>  [2,3,4,5,1]
05:30:59 <DRMacIver> Oh, I guess it is.
05:31:31 <DRMacIver> Hm, but you wanted to rotate only one of the elements. Never mind.
05:32:20 <kmb> ivanm: > now <- CPUTime.getCPUTime
05:33:02 <kmb> ivanm: let x = Random.mkStdGen $ fromInteger now
05:33:04 <ivanm> oh, didn't know that I could just do foo <- bar straightaway in ghci
05:33:12 <ivanm> thanks kmb!
05:33:19 <kmb> ivanm: np!
05:34:09 <ajudem_me_ghost> well... cya =)
05:38:51 <Jaggederest_> > let start = [1, 2, 3, 4, 5] in let rotate x n = (take n start) ++ start !! x ++ (take (5 - n) start) in rotate 2 2
05:38:52 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
05:38:52 <lambdabot>       Expected...
05:39:12 <Jaggederest_> hmm. I think I broke my brain thinking about that
05:39:27 <kmb> :) that's how I've been feeling
05:39:58 <Jaggederest_> ah and that doesn't even work because you'd dupe.
05:42:51 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/154
05:43:29 <ajudem_me> does anyone knows? http://hpaste.org/154
05:45:06 <Jaak> deriving (Show) ?
05:45:18 <Jaak> or instance Show Stm where ...
05:45:48 <hpaste>  Jaak annotated "(no title)" with "(no title)" at http://hpaste.org/154#a1
05:47:30 <mauke> > let start = [1, 2, 3, 4, 5] in let rotate x n = (take n start) ++ [start !! x] ++ (take (5 - n) start) in rotate 2 2
05:47:32 <lambdabot>  [1,2,3,1,2,3]
05:47:41 <ajudem_me> Jaak, tnks a lot!
05:48:00 <Jaak> np!
05:52:58 <LeCamarade> @where hmp3
05:52:59 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
05:53:17 * LeCamarade is in the mood for monadic, purely-functional hack music.
05:56:38 <hpaste>  byorgey annotated "(no title)" with "(no title)" at http://hpaste.org/154#a2
05:56:50 * kfish wishes someone would add ogg123 support to hmp3 :-)
05:57:01 <byorgey> ajudem_me: if you want to customize the way Stm is displayed you could also do something like this
05:57:08 <ddarius> kfish: Do it.
05:57:35 <kfish> ddarius, i've been chatting to dons about it ...
05:57:54 <pitecus> is there some semi-efficient way to convert between Float and CFloat? realToFrac seems to go thru Rational which seems like overkill
05:58:05 * ddarius is considering looking at hmp3
05:58:17 <byorgey> hurrah for open-source!
05:58:25 <SamB_XP> kfish: wouldn't that having to kill mpg123?
05:58:31 <kfish> i'm the upstream maintainer for ogg123, and recently added patches for a remote (ie. via pipe) control interface, compatible with that of mpg321
05:58:42 <SamB_XP> pitecus: huh. good question...
05:58:57 <SamB_XP> @hoogle Float -> CFloat
05:58:58 <lambdabot> No matches, try a more general search
05:59:03 <pitecus> same for Int and CInt...
05:59:04 <kfish> SamB, perhaps both could be run in parallel, or as needed ... good question :-)
06:00:57 <SamB_XP> pitecus: in that case, I'm sure fromIntegral is your function
06:01:12 <pitecus> @src fromIntegral
06:01:12 <lambdabot> fromIntegral = fromInteger . toInteger
06:01:19 <SamB_XP> ah.
06:01:24 <pitecus> SamB_XP, Same issue
06:01:26 <SamB_XP> pitecus: don't worry, it has lots of RULES
06:01:44 <quicksilver> pitecus: fromIntegral should be fine
06:01:49 <SamB_XP> and realToFrac seems to as well
06:02:22 <ddarius> @seen dons
06:02:23 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 23m 55s ago.
06:02:33 <SamB_XP> "realToFrac/a->CFloat"    realToFrac = \x -> CFloat   (realToFrac x)
06:02:38 <quicksilver> yeah, looks like realToFrac has the rules
06:02:43 <SamB_XP> "realToFrac/CFloat->a"    realToFrac = \(CFloat   x) -> realToFrac x
06:02:57 <quicksilver> so it should optimise to a no-op in the right circumstances
06:02:57 <SamB_XP> "fromIntegral/a->CInt"    fromIntegral = \x -> CInt    (fromIntegral x)
06:03:05 <SamB_XP> "fromIntegral/CInt->a"    fromIntegral = \(CInt    x) -> fromIntegral x
06:03:09 <pitecus> cool
06:03:37 <pitecus> i assume makeing an alias such as foo=realToFrac doesnt affect the RULES?
06:03:42 <SamB_XP> all the other C types have similar rules (at least if it makes sense)
06:03:45 <SamB_XP> pitecus: of course
06:03:52 <SamB_XP> GHc would inline that in an instant
06:04:02 <pitecus> ok thats comforting
06:04:05 <pitecus> thanks
06:04:51 <SamB_XP> but I'm not sure what it will do if you try to *export* an alias
06:05:22 <quicksilver> it will inline things between modules if they look 'simple enough'
06:05:29 <quicksilver> I have no idea how the heuristics work
06:05:44 <quicksilver> but I would be very surprised if they failed on simple renaming
06:06:01 <pitecus> anyway i just provide short names withtin the module to reduce the clutter a bit
06:06:06 <SamB_XP> quicksilver: I'm just worried about what it would export as the RHS for inlining of foo
06:06:45 <SamB_XP> would it export fromIntegral (good), or fromInteger . toInteger (bad)?
06:07:05 <quicksilver> dunno :)
06:13:30 <roconnor> @go haskell socks
06:13:32 <lambdabot> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
06:13:32 <lambdabot> Title: Functional Graph Library/Haskell
06:14:06 <roconnor> I don't suppose there is a SOCKS implementation in haskell?
06:19:21 <ivanm> I accidentally ended a ghci session where I was using random values...
06:19:36 <ivanm> is it possible to set the random values to those I was using earlier?
06:19:48 <ivanm> since I can't seem to create StdGen values directly?
06:20:21 <quicksilver> you can mkStdGen 0
06:20:26 <quicksilver> and get a reproducible set of values
06:20:34 <quicksilver> (or your favourite variant of '0')
06:21:48 <LeCamarade> > (listArray (0, 5) [1 .. 5]) ! (4 / 2)
06:21:51 <lambdabot>  Add a type signature
06:22:07 <LeCamarade> > (Data.Array.listArray (0, 4) [1 .. 5]) ! (4 / 2)
06:22:08 <lambdabot>  Add a type signature
06:22:16 <LeCamarade> ^^ ?
06:22:30 <LeCamarade> Try that in Your Favourite REPL.
06:22:33 <Jaak> > (listArray (0, 5) [1 .. 5]) ! (4 `div` 2)
06:22:34 <lambdabot>  3
06:22:39 <Jaak> > 4 / 2
06:22:40 <lambdabot>  2.0
06:22:45 <LeCamarade> :oD
06:22:47 <Jaak> @type 4 / 2
06:22:49 <lambdabot> forall t. (Fractional t) => t
06:23:01 <quicksilver> it's wondering what instance of 'Fractional' is also an instance of 'Ix', I imagine
06:23:05 <ivanm> quicksilver: I had already used a random value that when instantiated gave me 120205445 7263
06:23:08 <quicksilver> it can't solve that without your help
06:23:09 <Jaak> error message couldnt be better :)
06:23:13 <ivanm> I used newStdGen
06:24:18 <bringert> dcoutts: the current versions of c2hs and cabal don't play nice together. cabal gives flags like --output-dir=dist/build --output=Speech/Nuance/Recognizer9/Core.hs to c2hs
06:24:55 <quicksilver> I don't know how to base a new randomgen on the internals of an old one
06:24:56 <bringert> dcoutts: and c2hs interprets that to mean that it should produce dist/build/Core.hs, instead of dist/build/Speech/Nuance/Recognizer9/Core.hs
06:25:01 <quicksilver> I'm not sure the API supports it
06:25:10 <ddarius> read
06:25:16 <quicksilver> in the case you want reproducability, you should use mkStdGen and store the seed :)
06:25:52 <ivanm> quicksilver: heh, yeah, its just that I forgot to do one test with it, and closed the ghci session
06:25:54 <ivanm> thanks anyway
06:26:08 <ddarius> ivanm: You can read in the numbers to make a StdGen
06:26:24 <dcoutts> bringert: use the latest darcs version of c2hs
06:26:29 <ivanm> ddarius: how?
06:26:34 <ddarius> > read "120205445 7263" :: StdGen
06:26:35 <lambdabot>  120205445 7263
06:26:43 <dcoutts> bringert: the changes I made to both c2hs and cabal are only in the darcs versions of each so far
06:26:59 <bringert> dcoutts: I am using the latest darcs versions of both
06:27:03 <dcoutts> hmm
06:27:27 <dcoutts> that's odd then
06:27:32 <ivanm> ddarius: thanks, didn't think of that!
06:27:49 <dcoutts> bringert: are you sure cabal is picking the right c2hs ?
06:28:30 <bringert> dcoutts: I only have one, and it is picking that
06:29:54 <bringert> dcoutts: here's a test for you:
06:30:02 <bringert> test.chs: {#fun pure sinf { `Float' } -> `Float' #}
06:30:08 <bringert> $ c2hs --output-dir=dist --output=Foo/test.hs math.h test.chs
06:30:12 <dcoutts> bringert: well, the place to look is in c2hs/toplevel/Main.hs in computeOutputName and where that function is used. Add some traces or some such. I'm afraid I've no time to play with it. I'm packing for a 3 week trip to the US.
06:30:25 <bringert> dcoutts: ah, ok, thanks.
06:30:39 <dcoutts> bringert: that kind of thing was just what I tried originally, so I don't know what's going wrong
06:30:47 <bringert> dcoutts: if you think you've fixed this already, maybe you just forgot to push it
06:31:01 <dcoutts> I've got no interesting local patches
06:31:15 <bringert> dcoutts: the simple test above produces dist/test.hs, not dist/Foo/test.hs
06:31:25 <bringert> dcoutts: I'll look at the code then
06:31:33 <dcoutts> the point of changing the c2hs treatment of --output & --output-dir was exactly to make that work, the dist prefix and all, with arbitrary depth of src subdirs
06:32:05 <bringert> dcoutts: when did you fix that?
06:32:19 <dcoutts> bringert: what you're describing is exactly the original behaviour
06:32:27 <dcoutts> bringert: about a month ago I think
06:34:03 <dcoutts> bringert: I'm looking for the patch that implemented the change
06:34:31 <MarcWebe1> Can someone explain when TIP is used (HList) ?
06:34:33 <Jaak> @pl \f -> liftM5 Foo f f f f f
06:34:34 <lambdabot> join (join (join (join (liftM5 Foo))))
06:34:43 <Jaak> ghh
06:37:31 <quicksilver> Jaak: if you're looking at the B.get code someone posted earlier, you can't actually do that
06:37:51 <quicksilver> Jaak: because the 'f' is then polymorphic, and lambda's bind monomorphically in haskell98
06:38:40 <bringert> dcoutts: I can't find any recent patch that mentions those flags
06:38:50 <dcoutts> bringert: no, me neither
06:39:17 <Jaak> i dunno. just wanted to see if there is little less tedious way to write all my data.binary get instances
06:40:05 <quicksilver> Jaak: derive
06:40:13 <quicksilver> Binary instances are derivable, I believe?
06:40:15 <quicksilver> ndm: ping?
06:40:29 <Jaak> that would be nice
06:40:30 <ndm> quicksilver: yes, they are
06:40:37 <ndm> @where derive
06:40:38 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/derive
06:40:46 <quicksilver> Jaak: there you are. ndm is the answer your prayers :)
06:40:57 <roconnor> crap, I'm going to have to write my own Haskell SOCKS implementation :(
06:41:10 <ndm> plus its in DrIFT
06:41:13 <pitecus> how bad is it to give up looking for stack overflow and just increase the stack size :-(
06:41:24 <Jaak> cool
06:41:29 <ndm> pitecus: well very rarely fix things
06:41:52 <quicksilver> ndm: pitecus has a weird stack overflow which looks like it lurks in teh Binary instance for some default type
06:42:05 <quicksilver> ndm: he gets an overflow on decode (or was it encode?)
06:42:17 <pitecus> quicksilver, on decode
06:42:22 <pitecus> i think
06:42:34 <ndm> pitecus: i'd throw it at dcoutts and get him to fix it
06:43:20 <dcoutts> bringert: ok, I must have dropped the patch somewhere, I can't see it either and the behaviour is still the old behaviour, just as you describe. I'm much confused.
06:43:32 <pitecus> ndm, i didnt quite manage to reduce it to a small example tho
06:44:23 <quicksilver> OMG, slashdot speak hits haskell@ mailing list
06:44:33 <quicksilver> subject: Haskell on Beowulf
06:44:48 * quicksilver replies instinctively with F1RST P0ST!!!111
06:45:32 <opqdonut> frist psot
06:45:36 <bringert> dcoutts: I know what it's like. I lost all the test cases for GHC stand-alone deriving.
06:45:53 <opqdonut> imagine a beowulf cluster of olegs
06:46:04 <dcoutts> opqdonut: what would the type of that be?
06:46:08 <quicksilver> opqdonut: WAAA! You just made my head explode.
06:46:28 <opqdonut> quicksilver: *krhmm* it's "MY HEAD ASPLODE!"
06:46:43 <opqdonut> dcoutts: the thought hurts
06:46:45 <opqdonut> :)
06:47:03 <dcoutts> quite :-)
06:53:25 <Syzygy-> Haskell on Beowulf? I really, really, REALLY need to get back to at least skimming the list.
06:53:39 <ketti> hello, there is no valid syntax analogous to: (\(a:_) -> a ; \[] -> 0) ?
06:54:00 <arcatan> Haskell on your Beowulf? It's more likely than you think
06:54:26 <opqdonut> > map (\x -> if null x then 0 else head x) [[1,2],[]]
06:54:33 <lambdabot>  [1,0]
06:54:40 <opqdonut> ketti: there ya go
06:54:49 <opqdonut> have to use guards or ifs i'm afraid
06:55:03 <quicksilver> or a case
06:55:07 <ketti> ok
06:55:25 <quicksilver> (\x -> case x of [] -> 0 ; (y:_) -> y)
06:56:06 <ketti> yes, id like a terser syntax thoug ^^
06:56:25 <ketti> (+h)
06:56:33 <quicksilver> so would I, occassionally
06:56:41 <quicksilver> but it doesn't bother me very often
06:57:09 <quicksilver> you could define the non-recursive list catamorphism
06:57:22 <hpaste>  dozer pasted "list x-product" at http://hpaste.org/155
06:57:35 <dozer> is there a cleaner way to code this up?
06:57:35 <ketti> well, i don't really need patternmatching on lists right now
06:57:45 <ketti> it is a general patternmatching i want
06:58:10 <quicksilver> :t \n nn l -> case l of [] -> n ; (x:xs) -> nn x xs
06:58:12 <lambdabot> forall t t1. t -> (t1 -> [t1] -> t) -> [t1] -> t
06:58:16 <kmb> I have an implementation question that I hope someone can help out with.  Say I have a fixed-size list: [1, 2, 3, 4, 5] that I want to treat as circular in a function in order to rotate one of the elements n positions.  So rotating the second element 2 positions would result in: [1, 3, 4, 2, 5], or rotating the fourth element 2 positions would result in: [1, 2, 4, 3, 5].
06:58:18 <kmb> There are two cases: if the element can be moved w/o rotating and where the element must be inserted into the list at the front.  Is there an idomatic way to handle both of these cases in a function?
06:58:37 <kmb> (posting again for anyone recently joining)
06:59:40 <ketti> cycle [1, 2, 4, 3, 5]
06:59:48 <quicksilver> dozer: sequence [["pig","dog","goat"],["one","two"],["england","france","germany"]]
07:00:00 <quicksilver> dozer: try that in your favourite haskell interpreter
07:00:41 <dozer> dang :)
07:01:28 <quicksilver> dozer: I leave the 'State numbering' part to you, because that's not really any different
07:02:10 <chrismbrown> kmb: surely if you move the fourth element it would become the first element? viz. [1,3,4,2,5] would become [2,3,4,1,5]?
07:02:49 <chrismbrown> kmb: i.e. moving the fourth element two positions
07:03:09 <dozer> quicksilver: so If I wanted to allow the same sort of mapping operations that my liftMx allows, I'd sequence and then map a foldl?
07:04:51 <quicksilver> dozer: I didn't look very hard at liftMx. Lt me look again
07:06:58 <quicksilver> dozer: yes, I think so
07:08:04 <pitecus> One more curious thing about the stack overflow bug: it only seems to happen when i compile with profiling turned on. Why could that be?
07:08:40 <quicksilver> the optimiser/strictness analyzer can remove some frames which they can't remove with profiling on, maybe?
07:09:35 <pitecus> so there is still some bug there, its just that the optimizer manages to fix it (unless profiling is no) right?
07:09:58 <dcoutts_> that's quite possible
07:09:58 <lambdabot> dcoutts_: You have 1 new message. '/msg lambdabot @messages' to read it.
07:10:22 <dcoutts_> foo = doSomeThing >> foo  is not tail recursive
07:10:32 <dcoutts_> but if you inline >> then it becomes tail recursive
07:11:00 <dcoutts_> so if you attach a profiling cost center to >> then you can't make it tail recursive any more
07:11:15 <dcoutts_> so that changes the stack use behaviour of the program
07:11:35 <pitecus> ok makes sense
07:13:58 <hpaste>  dozer annotated "list x-product" with "much nicer" at http://hpaste.org/155#a1
07:14:41 <dozer> quicksilver: seems to behave how I wanted - thanks for the help
07:14:56 <dozer> quicksilver: I can drop in any doCat func here and get what I want
07:15:45 <quicksilver> dozer: I suspect you want that foldl to be foldr
07:17:31 <dozer> in this case it works either way, but yes I think I do
07:18:58 <quicksilver> dozer: it won't produce different results since ++ is associative, but it will be faster
07:19:07 <quicksilver> you don't want to associate ++ to the left
07:19:28 <dozer> but if I replaced ++ with some arbitrary accumulator func e.g. Map.insert, it would bite me
07:23:20 <quicksilver> I'm not sure how Map.insert works behind the scenes
07:23:30 <quicksilver> it's not immediately obvious to me that foldr would be harmful there
07:33:46 <petekaz> Is there a quick way to see all of the tags in a darcs repo?
07:37:32 <hpaste>  pitecus pasted "Stack overflow: minimal example" at http://hpaste.org/156
07:38:07 <pitecus> I found a three liner which triggers the stack overflow
07:38:24 <quicksilver> nice work
07:38:26 <pitecus> When compiled with profiling
07:38:41 <quicksilver> dcoutts_: ping
07:38:54 <dcoutts_> quicksilver: pong
07:40:18 <quicksilver> dcoutts_: see pitecus' paste just above
07:40:27 <quicksilver> dcoutts_: looks like an issue in IntMap's binary instance?
07:41:56 <dcoutts_> instance (Binary e) => Binary (IntMap.IntMap e) where
07:41:57 <dcoutts_>     put = put . IntMap.toAscList
07:41:57 <dcoutts_>     get = liftM IntMap.fromDistinctAscList get
07:42:28 <dcoutts_> quicksilver: see if the problem is in IntMap.fromDistinctAscList
07:42:28 <petekaz> Where do I find the darcs repos of X11 and X11-extras?  I am trying to build the latest xmonad, but I get some errors that I presume are due to out of date libraries.
07:43:14 <pitecus> dcoutts_, we looked before and couldn't find any obvious problem..
07:43:33 <sjanssen> petekaz: use the released version of X11
07:43:37 <sjanssen> @hackage X11
07:43:37 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
07:43:43 <dcoutts_> pitecus: well the IntMap instance looks pretty innocent
07:43:47 <petekaz> I did.
07:43:50 <sjanssen> @where X11-extras
07:43:50 <lambdabot> http://darcs.haskell.org/~sjanssen/X11-extras
07:44:04 <petekaz> sjanssen: Operations.hs:185:9: Not in scope: `changeProperty32'
07:44:13 <petekaz> and Operations.hs:190:9: Not in scope: `unmapWindow'
07:44:20 <sjanssen> petekaz: if you're tracking darcs xmonad, you'll have to track darcs X11-extras.  You should always be able to stick with the released X11
07:44:28 <petekaz> ok.
07:44:29 <sjanssen> petekaz: yeah, you need darcs X11-extras
07:44:32 <petekaz> thanks.
07:44:38 <pitecus> should i submit a bug report somewhere and where if so?
07:44:46 <petekaz> I want to see if you guys fixed that weirdo vnc issue I was having.
07:46:02 <balodja> what is the fastest way of applying function 'f' n times to x?
07:48:04 <quicksilver> :t iterate
07:48:06 <lambdabot> forall a. (a -> a) -> a -> [a]
07:48:54 <quicksilver> :t \f -> (!!) . iterate f
07:48:55 <lambdabot> forall a. (a -> a) -> a -> Int -> a
07:49:46 <quicksilver> or, hmm, foldr (.) . replicate ?
07:49:47 <quicksilver> :)
07:49:50 <quicksilver> so many ways
07:50:04 * balodja needs only one :)
07:53:43 <shapr> @yow !
07:53:44 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
07:54:32 * araujo throws at shapr a monad transformer
07:55:12 <syntaxfree> what's the formula for "bind" in terms of "join" again?
07:55:13 <syntaxfree> @src join
07:55:14 <lambdabot> join x =  x >>= id
07:55:20 <syntaxfree> @src (>>=)
07:55:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
07:57:39 <ndm> @seen cdsmith
07:57:40 <lambdabot> cdsmith is in #haskell. I don't know when cdsmith last spoke.
07:57:54 <quicksilver> :t (>>=)
07:57:56 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
07:58:04 <ndm> @tell cdsmith there is an email for you in the GHC bug tracker, but you openned the bug without a CC email so they can't contact you about it
07:58:05 <lambdabot> Consider it noted.
07:58:18 <ndm> @tell cdsmith http://hackage.haskell.org/trac/ghc/ticket/1402
07:58:18 <lambdabot> Consider it noted.
07:58:21 <quicksilver> syntaxfree: you 'liftM' the function, apply it to m a
07:58:33 <quicksilver> syntaxfree: that gives you a result of type m m a
07:58:38 <quicksilver> syntaxfree: which you 'join'
07:58:43 <quicksilver> syntaxfree: erm, m m b
07:58:48 <quicksilver> syntaxfree:  is that the answer you wanted?
07:59:53 <quicksilver> :t \a f -> join . liftM f $ a
07:59:55 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => m a1 -> (a1 -> m a) -> m a
08:00:06 <quicksilver> syntaxfree: like so :)
08:01:44 <Itkovian> hi shapr
08:03:53 <dcoutts_> bringert: I'm pushing that c2hs path fix now...
08:04:13 <dcoutts_> bringert: I've tested it lightly, give it a spin
08:05:17 <bringert> dcoutts: pulling...
08:05:31 <bringert> dcoutts: sorry for delaying your trip :-)
08:07:47 <bringert> dcoutts: works great for me
08:07:49 <bringert> thanks!
08:08:14 <bringert> hi andygill
08:08:29 <andygill> hi bringert
08:08:54 <dcoutts_> bringert: great
08:10:05 <shapr> hoi Itkovian
08:10:20 * shapr throws a transformed monad back at araujo
08:10:34 <dmhouse> Morning all.
08:11:46 * Itkovian wishes he had a typed Python
08:14:01 <araujo> hah
08:14:16 <araujo> Itkovian, oh, i have been having the same thoughts lately
08:14:22 * araujo has been coding python
08:14:33 <chrismbrown> dmhouse: morning
08:29:11 <shapr> I like that serializable STM post by cdsmith.
08:29:27 <dmhouse> shapr: URL?
08:29:35 <shapr> http://cdsmith.wordpress.com/2007/05/27/snapshotting-a-neat-problem-and-solution-in-haskell/
08:29:38 <lambdabot> Title: Snapshotting: A neat problem and solution in Haskell  Sententia cdsmithus, http://tinyurl.com/2h6zk3
08:29:55 <shapr> I've also wondered about a simple way to serialize STM values.
08:33:15 <sjanssen> it's pretty easy if you have a tree and not a graph
08:34:23 * Itkovian goes to make dinner
08:35:54 <syntaxfree> http://resources.businessobjects.com/labs/cal/tutorial_calintro.html
08:35:57 <lambdabot> Title: CalIntro.cal, http://tinyurl.com/v324x
08:36:08 <syntaxfree> why is it, that given a reasonable, Haskelly language, designers choose to uglify the syntax?
08:36:13 <syntaxfree> why? why? why?
08:36:38 <shapr> I dunno.. I also question why the advertised so heavily on the Haskell mailing lists.
08:36:51 <sjanssen> shapr: yeah, this is a really clever technique
08:37:07 <dmhouse> syntaxfree: what on earth is that?
08:37:10 <sjanssen> higher kinded parametric polymorphism for the win!
08:37:24 <syntaxfree> it's a haskell-ish lazy, strictly typed language for the JVM.
08:37:32 <dmhouse> Oh, it's not Haskell. *Breathes*
08:37:37 <shapr> sjanssen: But I got the feeling that technique could be simplified one or two steps.
08:37:38 <syntaxfree> It can access Java libs and whatever. But it's really Haskelly.
08:37:44 * sjanssen doesn't understand why the cal guys didn't just write a JVM backend for ghc
08:37:58 <syntaxfree> trigs :: [Double -> Double]; trigs = [sin, cos, tan];
08:38:07 <syntaxfree> except for ob-semicolon.
08:38:19 <sjanssen> shapr: yes, the boilerplate is unsatisfactory
08:38:33 <sjanssen> hmm, I wonder if SYB can do this
08:40:53 <mdmkolbe|work> sjanssen: do what?
08:41:21 <syntaxfree> quit
08:41:45 <sjanssen> mdmkolbe|work: achieve this http://cdsmith.wordpress.com/2007/05/27/snapshotting-a-neat-problem-and-solution-in-haskell/ with less boilerplate
08:41:48 <lambdabot> Title: Snapshotting: A neat problem and solution in Haskell  Sententia cdsmithus, http://tinyurl.com/2h6zk3
08:44:13 <fbuilesv> Thanks whoever made it possible to use Emacs keystrokes in GHCi :D
08:44:30 <dmhouse> fbuilesv: why not use GHCi in Emacs?
08:45:02 <fbuilesv> dmhouse, not programming right now, just checking out some stuff real quick.
08:45:06 <mdmkolbe|work> sjanssen: I'm not sure if you can 'cast' to a type class (mkT, etc probably have the same problem), but other than that it would probably work.
08:45:23 <monochrom> fbuilesv: it's the gnu readline library :)
08:45:59 <sjanssen> mdmkolbe|work: yeah, I don't see a way to write generic traversals that change a thing's type
08:46:20 <fbuilesv> Well, that's the nice discovery for today :D
08:48:02 <mdmkolbe|work> sjanssen: if inject had type 'b -> STM ()' then this would be a generic monadic querey (I'm not familiar with STM so maybe that would be using it wrong)
08:49:07 <shapr> Man, Haskell still blows my mind on a regular basis, I love it!
08:49:37 <LeCamarade> O, Joy. Someone was having trouble grokking quickqort. He knows absolutely no Haskell. So I write out the Haskell version. He understands quicksort. And even thinks I'm using a fictional (simplified) notation.
08:49:47 <LeCamarade> Is Haskell God's own language, or what?
08:50:01 <quicksilver> hmm Cal is probably slower than haskell
08:50:08 <quicksilver> because the string literals are pink
08:50:14 <quicksilver> pink is not a fast colour
08:50:47 <mdmkolbe|work> @remember LeCamarade O, Joy. Someone was having trouble grokking quickqort. He knows absolutely no Haskell. So I write out the Haskell version. He understands quicksort. And even thinks I'm using a fictional (simplified) notation.
08:50:47 <lambdabot> Done.
08:50:51 <osfameron> quicksort is one of those algorithms which are easy to understand in Haskell :-)
08:51:10 <mdmkolbe|work> LeCamarade: which version did you use
08:51:28 <mdmkolbe|work> LeCamarade: bah, didn't mean to press 'enter' ignore that
08:51:45 <LeCamarade> mdmkolbe|work: :o)
08:53:31 <shapr> quicksilver: Red makes things go faster.
08:53:43 <quicksilver> shapr: right. They should have made the string literals red.
08:53:48 <shapr> Truly
08:53:48 <quicksilver> shapr: but not pink
08:54:03 <osfameron> red and black, to get logarithmic time
08:54:06 <sjanssen> do strings deserve red?
08:54:13 <sjanssen> maybe numbers should be faster?
08:55:12 <osfameron> numbers should be prettier
09:12:04 <fbuilesv> If I run "ghci" inside a directory like .../ghc-6.6.1/libraries/base/System I'll get a ghc panic for a Bad Interface file, but if I run it in any other dir it works. I'm guessing it's because it sees a lot of .hs files and no .hi, but does the error make sense in this case?
09:13:50 <mdmkolbe|work> fbuilesv: it's probably b/c ghci is seeing a .hi file from a differently version of ghc (or that the .hi file is out of sync with the .hs file)
09:13:51 <monochrom> Yes it makes sense.
09:14:32 <mdmkolbe|work> IIUC, ghci should build .hi files if it only sees an .hs file
09:14:42 <fbuilesv> Ok, wanted to make sure to send or not the bug report, thank you.
09:27:30 <tsdh> How can I import modules whose files reside in different directories than the cwd?
09:27:52 <cdsmith> shapr: if you're still there, thanks for the nice comment earlier.
09:27:52 <lambdabot> cdsmith: You have 2 new messages. '/msg lambdabot @messages' to read them.
09:28:14 <byorgey> tsdh: try the -i option to ghc.
09:28:35 <dmhouse> tsdh: import Foo.Bar -- the file "Foo/Bar.[l]hs" will be assumed.
09:28:52 <byorgey> tsdh: I presume other systems (Hugs, etc.) have similar options.
09:28:57 <tsdh> Ah, thank you both.
09:30:49 <byorgey> has anyone here worked on the Haskell wikibook?
09:32:37 <dmhouse> byorgey: I have, yes.
09:33:12 <byorgey> dmhouse: I was wondering if anyone was planning on writing the section on currying
09:33:42 <tsdh> dmhouse: Seems not to work. I have a file ~/tmp/UsePictures.hs which imports Craft2e.Pictures, ~/tmp/Craft2e/ exists and contains Pictures.hs and Pictures.lhs...
09:33:42 <dmhouse> byorgey: which chapter is that in?
09:33:51 <byorgey> dmhouse: I noticed it was missing and I thought I might take a stab at it -- but I wouldn't want to step on any toes!
09:34:08 <byorgey> dmhouse: http://en.wikibooks.org/wiki/Haskell/Higher-order_functions_and_Currying
09:34:10 <lambdabot> http://tinyurl.com/uuqak
09:34:21 <dmhouse> tsdh: contains both the .hs and .lhs? Why? And which error message does it say?
09:34:47 <byorgey> dmhouse: but I guess the point of a wiki is you don't have to worry about that... really I guess I wondered whether anyone has already had any ideas for it.
09:34:56 <dmhouse> byorgey: by all means, go ahead!
09:35:23 <dmhouse> byorgey: the only time I'd hold off is if an article was obviously in the process of being written, i.e. lots of significant edits in the past week by a single author.
09:35:57 <byorgey> dmhouse: ok, fair enough.  barring that I think I might give it a shot!
09:36:20 <tsdh> dmhouse: It says "    Could not find module `Craft2e.Pictures':" and it contains both because all examples of "the craft of functional..." are done in both literate and normal style.
09:37:27 <dmhouse> tsdh: okay. What comes after the colon? And does it say something like "Use -v to show the list of files searched for"?
09:37:54 <dmhouse> tsdh: for example, if I try to import a nonexistant module in GHCi, the following happens:
09:37:55 <tsdh> dmhouse: That's what's coming after the colon. ;-)
09:38:10 <dmhouse> *Main> :m Foo
09:38:11 <dmhouse> Could not find module `Foo':
09:38:11 <dmhouse>   Use -v to see a list of the files searched for.
09:38:22 <dmhouse> tsdh: right, then how about using -v to see a list of the files it's searching? :)
09:38:46 <fbuilesv> tsdh: are you typing it like "-iPathwithoutspaces"?
09:39:08 <dmhouse> fbuilesv: you shouldn't need an -i flag.
09:39:31 <dmhouse> Here's what happens after having done :set -v
09:39:32 <dmhouse> *Main> :m Foo.Bar
09:39:32 <dmhouse> Could not find module `Foo.Bar':
09:39:32 <dmhouse>   locations searched:
09:39:33 <tsdh> fbuilesv: I use C-c C-l from within emacs' file buffer and run-haskell.
09:39:36 <dmhouse>     Foo/Bar.hs
09:39:39 <dmhouse>     Foo/Bar.lhs
09:40:15 <dmhouse> tsdh: use :set -v in the GHCi buffer and then C-c C-l on the file again.
09:43:02 <monochrom> I'm wondering what is in Pictures.hs and Pictures.lhs.
09:43:12 <tsdh> Ah, ok. The cwd seems to be $HOME, so Craft2e/Pictures.hs is wrong. But if I use tmp.Craft2e.Pictures I get a parse error, I guess because modules have to start with an upper case letter.
09:43:31 <monochrom> Yes.
09:43:56 <dmhouse> tsdh: the module that you're loading with C-c C-l, which directory is that in?
09:44:14 <tsdh> dmhouse: in ~/tmp
09:46:34 <dmhouse> tsdh: hrm, I don't see any reason why it shouldn't work.
09:47:07 <dmhouse> tsdh: do the modules in the subdirectories have "module Craft2e.Pictures where" at the top?
09:47:54 <tsdh> dmhouse: No, the examples of the book only have e.g. "module Pictures where..."
09:48:28 <monochrom> That may be it.
09:49:00 <dmhouse> tsdh: ah. I'd expect an error like Subdir/Foo.hs:1:7: file name does not match module name `Foo', but still, that may be the cause.
09:49:42 <tsdh> Seems so. I guess the cleanest way to handle that would be adding this directory to the load path (-i) somehow.
09:49:48 <dmhouse> Yeah.
09:50:16 <dmhouse> The best way of doing that is probably to do {-# OPTIONS_GHC -iCraft2e #-} at the top of the file you're trying to load.
09:52:40 <tsdh> dmhouse: It doesn't work. Neither from within emacs nor "ghci UsePictures.hs".
09:52:43 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/157
09:53:14 <ajudem_me> can I do that? with the case and another pattern matching?
09:54:29 <mdmkolbe|work> ajudem_me: the second case of your function will never be called if you do it that way.  let me see if I understand what you want
09:55:17 <ajudem_me> mdmkolbe|work yes, I figured it out, now! ;)
09:55:18 <ajudem_me> tnks =)
09:55:49 <hpaste>  mdmkolbe|work annotated "(no title)" with "you can do it this way" at http://hpaste.org/157#a1
09:56:54 <tsdh> dmhouse: But "ghci -iCraft2e UsePictures.hs" works. It seems it doesn't recognize this special comment.
09:57:13 <dmhouse> tsdh: hmm. It also works if you do :set -iSubdir within GHCi.
09:57:54 <tsdh> dmhouse: Ok, then I'll use that. Thanks anyway.
09:58:39 <dmhouse> tsdh: yeah, sorry I couldn't be more helpful, I'm still not sure why the OPTIONS_GHC pragma didn't work.
09:59:43 <tsdh> dmhouse: Maybe because I have to give the full path (from $HOME) to -i. I'll try that.
10:00:13 <dmhouse> Nope, still doesn't seem to work.
10:00:41 <dcoutts> hia SyntaxNinja
10:00:48 <SyntaxNinja> y0y0
10:00:48 <dcoutts> SyntaxNinja: any word on the community server?
10:01:03 <SyntaxNinja> dcoutts: yeah, it's back online, I just need to get it reconfigured...
10:01:11 <dcoutts> ah great
10:01:20 <SyntaxNinja> my free time is very short lately due to getting married in 3 weeks!
10:01:28 <dmhouse> Oh cool; hpaste is back up.
10:01:33 <dcoutts> SyntaxNinja: if you're busy perhaps you can delegate
10:01:47 <dcoutts> SyntaxNinja: but not to me! I'm off to the US of A for three weeks. :-)
10:03:44 <SyntaxNinja> hehe
10:03:58 <SyntaxNinja> yeah, I can delegate as soon as I get someone else able to log in ;)
10:04:07 <SyntaxNinja> a bit of a delegation-bootstrapping problem
10:04:15 <SyntaxNinja> just a few minutes of work; I"ll get to it soon.
10:04:19 <SyntaxNinja> welcome to USA!
10:05:10 <dcoutts> heh, thanks :-)
10:05:34 <bringert> SyntaxNinja: good luck with the wedding!
10:05:45 <bringert> SyntaxNinja: say hi to anna
10:05:54 <LeCamarade> dcoutts: That's `U S and A' ;o)
10:06:04 <ndm> babies, weddings - everyone is far too grown up here...
10:06:25 <dcoutts> SyntaxNinja: yes, hope the wedding is great fun
10:06:49 <dcoutts> LeCamarade: erm United States *of* America? no?
10:06:53 <dcoutts> I'll be travelling to the middle of nowhere, otherwise known as South Dakota :-)
10:07:11 <bos> dcoutts: what's in SD for you?
10:07:17 <dcoutts> bos: family
10:07:21 <LeCamarade> dcoutts: Um, yeah. If you're not from Kazakhstan.
10:07:26 <dcoutts> heh
10:07:34 * LeCamarade realises he's the only one who watched that godawful comedy.
10:07:42 <dcoutts> I managed to miss that film, fortunately
10:07:51 * bos has family in south dakota, too.
10:07:51 <LeCamarade> dcoutts: Lucky you.
10:07:57 <dcoutts> poor LeCamarade :-)
10:08:28 <dcoutts> bos: oh yes? Mine are from Deadwood, small ex-gold mining town.
10:08:41 <LeCamarade> Sad you do laugh, even when you're wishing someone will just start training Kung-fu on him ... but this is for #haskell-blah ... :o)
10:09:43 <bos> dcoutts: deadwood is a very famous town now :-)
10:10:02 <dcoutts> heh, I suppose so. I never saw any of the tv show
10:10:44 <bos> i have a pile of inlaws in spearfish, about 15 minutes down the road.
10:10:45 <LeCamarade> Haskell hosting is a really delicate dance, I see. No GHC 6.6 anywhere. Some of use are already using HEAD ... :o)
10:12:13 <dcoutts> bos: oh yes, I know it.
10:12:39 <bos> yeah, it's almost the only place that's 15 minutes down the road from deadwood :-)
10:20:42 <ndm> @seen malcolmw
10:20:42 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 38m 17s ago, and .
10:21:05 <ndm> @karma- malcolmw -- changing the cpphs interface and breaking Yhc within a few minutes of me fixing Yhc on Windows!
10:21:05 <lambdabot> malcolmw's karma lowered to 0.
10:21:12 <ndm> too quick for us even to get a proper build out!
10:21:43 <sieni> spank him!
10:22:42 <ndm> @spank malcolmw
10:22:42 <lambdabot> Unknown command, try @list
10:23:19 <roconnor> @type scanl
10:23:23 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
10:23:37 <roconnor> > scanl (+) 0 [0..5]
10:23:39 <lambdabot>  [0,0,1,3,6,10,15]
10:23:55 <roconnor> > scanl (+) 0 [1..5]
10:23:56 <lambdabot>  [0,1,3,6,10,15]
10:24:12 <roconnor> > scanl (-) 0 [1..5]
10:24:13 <lambdabot>  [0,-1,-3,-6,-10,-15]
10:25:46 <roconnor> > scanl (-) 6 [1..5]
10:25:47 <lambdabot>  [6,5,3,0,-4,-9]
10:26:49 <roconnor> > scanr (-) 6 [1..5]
10:26:50 <lambdabot>  [-3,4,-2,5,-1,6]
10:27:11 <roconnor> > scanr (flip (-)) 6 [1..5]
10:27:12 <lambdabot>  [-9,-8,-6,-3,1,6]
10:31:36 <Jaak> > foldl (-) 6 [1..5]
10:31:37 <lambdabot>  -9
10:31:43 <Jaak> > scanl (-) 6 [1..5]
10:31:45 <lambdabot>  [6,5,3,0,-4,-9]
10:32:16 <fbuilesv> Can someone explain what does "non-backtracking limitation of the Maybe monad" means in http://www.haskell.org/all_about_monads/html/solution4.html ?
10:32:16 <lambdabot> Title: Solution to exercise 4
10:40:32 <dmhouse> fbuilesv: well, the list monad is often described as a backtracking monad, because of the semantics it has. However, I don't really understand it in that context.
10:40:48 <fbuilesv> dmhouse: What's exactly non-backtracking?
10:41:10 <fbuilesv> I can see the diff between mplus in [] and Maybe monads , but I don't get the backtracking part.
10:42:02 <dmhouse> fbuilesv: okay, are you familiar with the Sudoku format of puzzle?
10:42:34 <fbuilesv> Yes, I understand the mechanics
10:43:12 <fbuilesv> And I get backtracking in the "problem-solving" domain, but I don't get to see it in the Maybe's monad context
10:43:28 <dmhouse> Well the _list_ monad implements backtracking, essentially.
10:43:51 <DukeDave> Urm, could someone remind me where the hugs config file lives? :|
10:44:10 <DukeDave> (on a Linux system)
10:44:10 <dmhouse> If you were going to write a Sudoku solver, you'd do so in the list monad, using its backtracking semantics. (And there are such solvers available on the wiki.)
10:44:53 <roconnor> do { x <- (return 1) `mplus` (return 2); y <- (return 3) `mplus` (return 4); guard (even (x+y)); return (x+y)}::[Int]
10:44:55 <fbuilesv> I'm gonna take a look at those then, thank you.
10:44:56 <roconnor> > do { x <- (return 1) `mplus` (return 2); y <- (return 3) `mplus` (return 4); guard (even (x+y)); return (x+y)}::[Int]
10:44:57 <lambdabot>  [4,6]
10:45:03 <roconnor> > do { x <- (return 1) `mplus` (return 2); y <- (return 3) `mplus` (return 4); guard (even (x+y)); return (x+y)}::Maybe Int
10:45:03 <Saizan> fbuilesv: the point is that with the list monad you could have written grandParent s = parent s >>= parent because it's backtracking, instead with Maybe you need mplus
10:45:04 <lambdabot>  Just 4
10:45:11 <roconnor> what the
10:45:26 <roconnor> oops
10:45:35 <roconnor> I ment to guard on odd
10:45:40 <roconnor> > do { x <- (return 1) `mplus` (return 2); y <- (return 3) `mplus` (return 4); guard (odd (x+y)); return (x+y)}::Maybe Int
10:45:41 <lambdabot>  Nothing
10:45:46 <roconnor> > do { x <- (return 1) `mplus` (return 2); y <- (return 3) `mplus` (return 4); guard (odd (x+y)); return (x+y)}::[Int]
10:45:47 <lambdabot>  [5,5]
10:45:53 <TomMD> @type guard
10:45:55 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
10:46:21 <roconnor> So in this case the list monad gets both answers, but the Maybe monad doesn't get any
10:46:28 <roconnor> because the Maybe monad doesn't backtrack
10:46:47 <fbuilesv> roconnor: I just saw that too with some experimentation, thanks for the explanation guys :D
10:46:47 <roconnor> ... maybe this example is confusing
10:47:34 <fbuilesv> roconnor: the "print" in the last part of that example shows the difference between the  List and Maybe pluses as you just did.
10:50:24 <roconnor> Um, I just noticed for the first time that you cannot make sections out of minus
10:50:30 <roconnor> > 2 (+3)
10:50:31 <lambdabot>        add an instance declaration for (Num ((a -> a) -> a1))
10:50:31 <lambdabot>     In the expr...
10:50:42 <roconnor> > (+3) 2
10:50:44 <lambdabot>  5
10:50:47 <roconnor> > (-3) 2
10:50:48 <lambdabot>   add an instance declaration for (Num (t -> a))
10:50:48 <lambdabot>     In the expression: (- 3)...
10:51:12 <dmhouse> > (subtract 3) 2
10:51:13 <lambdabot>  -1
10:51:23 <roconnor> awsome
10:51:25 <dmhouse> > (+ (-3)) 2
10:51:26 <lambdabot>  -1
10:51:31 <dmhouse> > 2 - 3 -- :)
10:51:32 <lambdabot>  -1
10:58:42 <byorgey> roconnor: yeah, that is one of the few ugly things about Haskell syntax
10:59:17 <byorgey> roconnor: since the '-' character functions both as subtraction (a binary operator) and a unary negative sign for numeric constants
11:01:01 <byorgey> roconnor: IMO there should be a different symbol for negative integer constants (it's done by other languages, e.g. J (underscore) and Scheme (tilde))
11:02:10 <monochrom> > case undefined of ~1 -> "whee"
11:02:14 <lambdabot>  "whee"
11:04:57 <byorgey> > case 4 of ~(x,y) -> "hmm"
11:04:58 <lambdabot>   add an instance declaration for (Num (t, t1))
11:04:59 <lambdabot>     In the scrutinee of a cas...
11:05:19 <byorgey> 'scrutinee'!?
11:05:21 <sjanssen> > case 0 of ~(n+1) -> "whee"
11:05:21 <lambdabot>  Parse error in pattern
11:05:37 <sjanssen> no lazy n+k patterns?!
11:05:53 <sjanssen> > case 0 of (n+k) -> "whee"
11:05:53 <lambdabot>  Parse error in pattern
11:06:07 <sjanssen> oh yes, the preparser doesn't support n+k patterns
11:06:58 <byorgey> > case undefined of x -> "foo"
11:07:00 <lambdabot>  "foo"
11:07:15 <byorgey> > case undefined of ~x -> "foo"
11:07:16 <lambdabot>  "foo"
11:07:21 <byorgey> what's the difference?
11:08:18 <mauke> > case undefined of (x,y) -> "foo"
11:08:19 <lambdabot>  Undefined
11:08:22 <mauke> > case undefined of ~(x,y) -> "foo"
11:08:23 <lambdabot>  "foo"
11:08:34 <mauke> > case undefined of ~(x,y) -> [x, y]
11:08:35 <lambdabot>  Undefined
11:09:07 <byorgey> mauke: oh, I see
11:10:43 <dmhouse> byorgey: see http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching
11:10:46 <lambdabot> http://tinyurl.com/ykch9p
11:11:02 <monochrom> x, ~stuff, _  are all lazy.
11:11:17 <byorgey> dmhouse: thanks
11:11:37 <dmhouse> monochrom: true, but (x, y) is stricter than ~(x, y).
11:11:47 <monochrom> > case undefined of (x,y) -> "foo"
11:11:48 <lambdabot>  Undefined
11:11:52 <dmhouse> monochrom: so ~(x, y) is a "lazy pattern".
11:11:57 <monochrom> This completes the collection.
11:12:55 <byorgey> > case (length [1..5]) of ~(x,y) -> "foo"
11:12:55 <lambdabot>  Couldn't match expected type `Int' against inferred type `(a, b)'
11:13:06 <monochrom> It still has to type-check.
11:13:17 <byorgey> ah. indeed =)
11:13:22 <Ulfalizer> > (1-) 1
11:13:23 <lambdabot>  0
11:13:36 <roconnor> > scanl (+) 0 [1..5]
11:13:38 <lambdabot>  [0,1,3,6,10,15]
11:13:40 <byorgey> case Nothing of ~(Maybe x) -> "foo"
11:13:44 <byorgey> > case Nothing of ~(Maybe x) -> "foo"
11:13:45 <lambdabot>   Not in scope: data constructor `Maybe'
11:13:47 <roconnor> > scanr (+) (-15) [1..5]
11:13:48 <lambdabot>  [0,-1,-3,-6,-10,-15]
11:13:52 <byorgey> > case Nothing of ~(Just x) -> "foo"
11:13:53 <lambdabot>  "foo"
11:13:57 <byorgey> > case Nothing of (Just x) -> "foo"
11:13:58 <lambdabot>   Non-exhaustive patterns in case
11:14:00 <byorgey> aha
11:14:13 <roconnor> > scanl (+) (-15) [1..5]
11:14:14 <lambdabot>  [-15,-14,-12,-9,-5,0]
11:14:17 <dmhouse> > case Nothing of ~(Just x) -> "foo" ++ x
11:14:17 <byorgey> ok, I understand now, thanks all =)
11:14:18 <lambdabot>   Irrefutable pattern failed for pattern (Data.Maybe.Just x)
11:14:38 <dmhouse> Pfft. That should print "foo***Error: pattern match failure or something like that.
11:14:59 <roconnor> > scanl (-) (-15) [1..5]
11:15:00 <lambdabot>  [-15,-16,-18,-21,-25,-30]
11:15:05 <roconnor> > scanl (-) (15) [1..5]
11:15:06 <lambdabot>  [15,14,12,9,5,0]
11:15:10 <byorgey> dmhouse: well, I get the idea.
11:16:10 <monochrom> Buffering effect.
11:16:33 <byorgey> monochrom: eh?
11:17:09 <monochrom> That foo is not printed before the error message.
11:18:02 <dmhouse> monochrom: yes, indeed. IIRC lambdabot uses regexps on GHCi's output to determine what to say.
11:18:04 <dmhouse> E.g.:
11:18:09 <dmhouse> > undefined
11:18:11 <lambdabot>  Undefined
11:18:17 <dmhouse> Prelude> undefined
11:18:17 <dmhouse> *** Exception: Prelude.undefined
11:20:42 <eric_r> good evenings
11:22:28 <eric_r> some one could give me a forum address about haskell
11:22:30 <eric_r> ?
11:23:15 <dolio> There's comp.lang.haskell.
11:23:21 <dolio> You can access it via google groups.
11:23:35 <eric_r> thanks a lot
11:23:43 <monochrom> http://haskell.org/mailman/listinfo/haskell-cafe
11:23:44 <lambdabot> Title: Haskell-Cafe Info Page
11:23:47 <dolio> I think there's also a mirror for the mailing list.
11:23:49 <dolio> fa.haskell
11:24:08 <dolio> The haskell-cafe mailing list, that is.
11:25:42 <eric_r> do you know one in spanish too??
11:26:12 <dolio> Nope. Sorry.
11:26:25 <dolio> @seen lambdabot
11:26:25 <lambdabot> Yes, I'm here. I'm in #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #
11:26:26 <lambdabot> scannedinavian
11:26:47 <eric_r> well thanks a lot again
11:26:53 <sieni> nice linebreak
11:31:31 <gaal> hi. how do I prevent memoization of a function's result (and force its strict evaluation), for benchmarking purposes?
11:32:49 <ekidd> Good afternoon!
11:34:28 <dolio> gaal: That all depends, I suppose. What do you mean as far as the memoization? Haskell doesn't memoize functions, per-se.
11:34:57 <icarroll> @src fix
11:34:58 <lambdabot> fix f = let x = f x in x
11:35:08 <dolio> But if you bind the result of a function to an identifier and use that multiple times, it will share it (which some people call memoizing).
11:36:16 <dolio> But, if you do, say 'map (\_ -> foo bar) [1..100]' then 'foo bar' will likely be computed 100 times.
11:36:30 <gaal> okay; and if I want to make sure the function is computed n times, is (length $ replicate n f) good?
11:37:08 <gaal> ah, ok
11:37:19 <dolio> Well, no. That wouldn't work.
11:37:25 <gaal> why not?
11:37:52 <dolio> 'replicate n f' would compute f once, and then use that value to create a list of n values, I suspect.
11:37:53 <gaal> oh, I see.
11:38:03 <augustss> you don't need to compute f  AT ALL TO GET THE LENGTH
11:38:10 <Jaak> > length $ replicate 10 undefined
11:38:10 <dolio> And, yeah, that too.
11:38:12 <lambdabot>  10
11:38:14 <Jaak> > undefined
11:38:16 <lambdabot>  Undefined
11:38:18 <gaal> yes, yes.
11:38:26 <gaal> no need to shout :)
11:38:38 <augustss> it wasn't intentional :)
11:41:04 <dolio> What's the result type of f?
11:41:04 <icarroll> @hoogle (a -> a) -> a -> a
11:41:04 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
11:41:04 <lambdabot> Control.Monad.Reader.local :: MonadReader r m => (r -> r) -> m a -> m a
11:41:04 <lambdabot> Control.Monad.Writer.censor :: MonadWriter w m => (w -> w) -> m a -> m a
11:41:04 <monochrom> why do you absolutely want f evaluated 100 times?
11:41:07 <gaal> to make the benchmark a little less unreliable. Ideally I'd want f to run for say 15 CPU seconds and count how many fs it computed
11:41:08 <augustss> there is no way that is guaranteed to work
11:41:43 <gaal> f :: ByteString -> String, it's a hash function
11:42:00 <gaal> sha1 actually
11:42:08 <monochrom> Use seq cleverly.
11:42:24 <dolio> Control.Parallel.Strategies.rnf could help.
11:42:37 <monochrom> Note "cleverly". Some thinking and design required.
11:43:03 <dolio> 'rnf (map (\_ -> f b) [1..100]) `seq` ()' or something like that.
11:43:20 <dolio> Then when the () is demanded, the list has to be reduced to normal form first.
11:43:57 <dolio> rnf for lists demands the elements, too, right?
11:44:22 <monochrom> Test it with rnf [undefined, undefined, undefined].
11:44:45 <gaal> there is an instance for NFData a => NFData [a], fwiw
11:44:59 <dolio> Ah. Seems likely, then.
11:45:13 <Saizan> > rnf [undefined :: Int]
11:45:14 <lambdabot>  Undefined
11:45:37 <gaal> lambdabot has that in scope? weird.
11:47:03 <dolio> Actually, the '`seq` ()' in my example might be superfluous.
11:47:05 <monochrom> Neat.
11:47:10 <dolio> > rnf [1, 2, 3]
11:47:12 <lambdabot>  ()
11:47:23 <Jaak> @type rnf
11:47:24 <lambdabot> forall a. (NFData a) => a -> Done
11:47:35 <monochrom> Heh! seems like the `seq` () part is redundant. :)
11:48:07 <Heffalump> I would hope so!
11:48:25 <Heffalump> it's be an odd kind of deepSeq that didn't seq the top layer
11:49:06 <dolio> I was thinking rnf was 'NFData a => a -> a' for some reason. But I suppose that wouldn't work out.
11:49:54 <gaal> I also prepare some scaffolding (a 100k string) used as an arg for the benchmarked function. How do I make sure it's constructed before I take my first timing?
11:50:20 <gaal> (I'm in IO, of course)
11:50:33 <monochrom> print it out from IO.
11:50:48 <monochrom> rnf would also work
11:50:55 <Heffalump> rnf, print it out, compare it with itself
11:51:09 <monochrom> Compute its sha1 once :)
11:51:30 <gaal> I would have done data <- return "....." but the optimizer will shred that to bits :p
11:54:49 <monochrom> do { data <- return (undefined :: String); print "hello" }
11:54:53 <monochrom> > do { data <- return (undefined :: String); print "hello" }
11:54:53 <lambdabot>  Parse error
11:55:09 <monochrom> OH! data is keyword
11:55:14 <monochrom> > do { d <- return (undefined :: String); print "hello" }
11:55:22 <lambdabot>  <IO ()>
11:55:31 <monochrom> Compare with...
11:55:40 <monochrom> > do { print undefined }
11:55:41 <lambdabot>  <IO ()>
11:55:48 <monochrom> err nevermind
11:55:59 <dolio> > (undefined :: IO ())
11:56:00 <lambdabot>  <IO ()>
11:56:12 <monochrom> I was trying to say, "return x" will not force x.
12:05:49 <Procyon112> g'day
12:06:59 <drigz> movingMinima k = map minimum . takeWhile (\w -> length w == k) . map (take k) . tails
12:07:08 <drigz> does anyone know the O(n) version of that?
12:07:28 <drigz> i'm sure i was told it a while ago but forgot
12:08:56 <dblhelix> @src MonadPlus
12:08:56 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
12:09:10 <icarroll> @src mplus
12:09:10 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:09:11 <dblhelix> @src Control.Monad.MonadPlus
12:09:11 <lambdabot> Source not found. Take a stress pill and think things over.
12:09:21 <icarroll> oh noes!
12:09:24 <dblhelix> @src Control.Monad.mplus
12:09:24 <lambdabot> Source not found. I've seen penguins that can type better than that.
12:10:32 <drigz> @source Control.Monad
12:10:32 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
12:24:46 <RyanT5001> is there a way to make GHCi's output marginally colored?
12:24:58 <RyanT5001> (marginally meaning "just a little" :P)
12:25:08 <RyanT5001> in particular
12:25:11 <RyanT5001> i'd like to color the prompt
12:25:29 <RyanT5001> it's very difficult sometimes to tell when the last prompt was when it spits out 4 or 5 long errors
12:26:04 <RyanT5001> (specifics: i'm on linux, using gnome-terminal specifically)
12:27:24 <chrismbrown> RyanT5001: I'm not sure that would be easy. Why would you need that?
12:29:04 <RyanT5001> just wondering; when i have 2 or 3 screenfuls of errors, and i ":r" multiple times (i.e.: fix one error, reload, repeat), sometimes it's annoying to slowly scroll up looking for the last prompt
12:29:18 <RyanT5001> it's not even close to a big deal
12:29:41 <RyanT5001> i care at the "changing a config file" level of difficulty :P
12:29:50 <RyanT5001> sounds like that isn't the level it's at
12:30:05 <roconnor> @pl map return
12:30:05 <lambdabot> map return
12:30:22 <roconnor> @type map return
12:30:24 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> [m a]
12:30:54 <RyanT5001> @type sequence . map return
12:30:56 <lambdabot>     Ambiguous occurrence `sequence'
12:30:56 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
12:31:05 <RyanT5001> @type Control.Monad.sequence . map return
12:31:07 <lambdabot> forall a (m :: * -> *). (Monad m) => [a] -> m [a]
12:33:48 <chrismbrown> oh I see, actually that would be quite a funky feature
12:34:15 <chrismbrown> well, I guess if you really wanted to do it, you could hack the GHCi output in the GHC package with ghc-6.6.1
12:34:28 <RyanT5001> hm
12:34:28 <chrismbrown> somewhere will be the code for GHCi's output
12:34:41 <chrismbrown> but my guess is that it won't be quick
12:34:43 <RyanT5001> yeah
12:34:51 <RyanT5001> i'll leave it to the Yi and HIDE people :)
12:35:34 <chrismbrown> I wonder if you could write a little haskell script. Say you pipe the output of GHCi into a little parser in haskell which reads the output that ghci givesl and spits it back out colour coded
12:35:43 <RyanT5001> could work
12:35:47 <chrismbrown> but then you would need to retain the interactivity somehow with GHCi
12:35:51 <RyanT5001> yeah
12:36:02 <chrismbrown> I guess, you could have ghci running as a background thread
12:36:06 <RyanT5001> that'd basically be a getline hack, i think
12:36:12 <chrismbrown> yes!
12:36:18 <chrismbrown> or something along those lines...
12:36:23 <RyanT5001> yeah
12:36:26 <RyanT5001> actually
12:36:34 <RyanT5001> if you just hacked getline so that user input was always colored
12:36:38 <RyanT5001> that'd be plenty good
12:36:46 <chrismbrown> not sure I follow?
12:37:16 <RyanT5001> well if you colored all the characters echoed as a result of user input
12:37:27 <RyanT5001> then everything typed *in response to* a prompt would end up colored
12:37:45 <RyanT5001> which would have the same basic effect - there'd be a block of color on every prompt line
12:38:12 <nomeata> hi. Im trying to use happy, but I get: happy: parE when I run happy, and no output.
12:38:14 <chrismbrown> ok
12:38:18 <nomeata> any ideas?
12:38:28 <Botje> @pl \fibs -> 1 : scanl (+) 1 fibs
12:38:28 <lambdabot> (1 :) . scanl (+) 1
12:38:44 <Botje> @pl \x -> (show x) == (reverse $ show x)
12:38:44 <lambdabot> liftM2 (==) show (reverse . show)
12:38:49 <fasta> RyanT5001: I understand you are not using Emacs or VIM?
12:39:07 <Botje> > join (*) 5
12:39:09 <lambdabot>  25
12:39:42 <fasta> Is SHIM still under development?
12:39:52 <chrismbrown> fasta: SHIM?
12:39:53 <fasta> @where SHIM
12:39:53 <lambdabot> http://shim.haskellco.de/trac/
12:40:14 <chrismbrown> ah
12:40:16 <RyanT5001> fasta: i'm using emacs, but i'm not very proficient with it and haven't yet gotten it integrated with any haskell stuff
12:40:43 <chrismbrown> RyanT5001: you could knock up a LISP script to interact with GHCi
12:40:48 <fasta> RyanT5001: you can better spend some time on that if you want to work more efficient.
12:40:50 <chrismbrown> but LISP is evil! ;)
12:41:26 <fasta> LISP is an acronym used by people who haven't used Lisp.
12:41:29 <SimonRC> I am working with discrete space (Integer, Integer), and I will be using some transformations.  The transformations are limited so that right-angles remain right-angles, and any point within the space is mapped to another point within the space by any transformation, *or its inverse*.  What is a good representation for the transformations?
12:41:32 <chrismbrown> lol
12:41:51 <RyanT5001> fasta: i will do that soon, but i'm trying to hack out a program by the end of today :)
12:42:15 <fasta> RyanT5001: it's called "Haskell-mode" and you can apt-get it in Debian.
12:42:18 <opqdonut> SimonRC: i'd start with matrix representation
12:42:24 <SimonRC> opqdonut: ouch
12:42:27 <opqdonut> you'll just have to put restrictions on it
12:42:28 <opqdonut> :)
12:42:46 <RyanT5001> oh, fasta, i have that
12:42:50 <opqdonut> or then discretisized rotation and translation and theur compositions
12:42:52 <SimonRC> opqdonut: I can do that
12:42:53 <RyanT5001> i just don't know how to use it :P
12:42:56 <RyanT5001> i mean
12:43:01 <opqdonut> but discretisized rotation is kinda painful
12:43:01 <RyanT5001> i have fancy syntax hilighting and such
12:43:13 <RyanT5001> i'll figure it all out soon
12:43:14 <opqdonut> or is it? hmmmm
12:43:29 <opqdonut> bah
12:43:38 <SimonRC> it is basically rotation by 90 degrees, flips, tralation by 1 step in a cardinal direction, or compositions thereof I am working with.
12:43:41 <SimonRC> Sigh
12:43:48 <SimonRC> waitamo.....
12:43:54 <opqdonut> SimonRC: you're dealing with generalizes linear transformations or whatever theyre called
12:44:07 <opqdonut> (az+b)/(bz+c)
12:44:09 <opqdonut> or something
12:44:15 <Jaggederest_> Ryan: coolest part of haskell-mode is indentation, it works on a cycle, and will pre-fill likely guards
12:44:19 <SimonRC> no... there is no skewing
12:44:29 <opqdonut> SimonRC: yeah but inversion might work
12:44:33 <opqdonut> or somesuch transformation
12:44:35 <RyanT5001> opqdonut: yep, i'm using that
12:44:45 <opqdonut> you'll have to do the math's first
12:44:48 <opqdonut> RyanT5001: ??
12:44:54 <opqdonut> gah maths even
12:44:57 <RyanT5001> oh sorry, responded to the wrong person
12:45:02 <opqdonut> nw
12:45:05 <RyanT5001> Jaggederest_: yep, using that
12:45:23 <SimonRC> I don't actually *need* to represent the transformations as matrices... I could just represent them as pairs of functions (transformation and inverse)!
12:45:43 <sieni> SimonRC: are you just talking about isometries of the planar lattice Z x Z?
12:45:45 <SimonRC> aha, this channel caused me to get inspiration
12:45:55 <opqdonut> SimonRC: well yeah, but you'll probably want a way to construct them
12:45:58 <opqdonut> sieni: exactly
12:46:18 <SimonRC> functions not data structures
12:46:19 <SimonRC> .....
12:46:27 <SimonRC> sieni: less that that even... I am forbidding skewing
12:46:35 <sieni> skewing?
12:46:40 <SimonRC> so (x,y) -> (x, x+y) is forbidden
12:46:57 <SimonRC> even though it is Z^2 -> Z^2
12:47:21 <fasta> functions <-> data is the same.
12:47:57 <SimonRC> I am using these transformations to patch together bits of rectangular Z^2 space into a big non-Euclidean space.
12:48:31 <RyanT5001> what's the thing that automatically generates a function of a prescribed type?
12:48:37 <RyanT5001> genie?
12:48:40 <sieni> SimonRC: well, as an isometry I meant an isometry inherited from the regular plane
12:48:44 <SimonRC> RyanT5001: djinn
12:48:49 <RyanT5001> thanks
12:49:02 <SimonRC> sieni: ah, so not skewing?
12:49:12 <SimonRC> The transformations will represent how the different coordinate systems of the bits of space relate to one another
12:49:38 <SimonRC> It is inpired by the terrain engine of Dungeon Siege, though for different reasons.
12:50:02 <SimonRC> RyanT5001: "djinn" and "genie" are cognates.
12:50:35 <sieni> well (1,1) maps to (1,2), so the distance between the origin and (1,1) and the image of the origin (which is the origin) and (1,2) will change from sqrt(2) to sqrt(5), so it's not an isometry
12:50:39 <RyanT5001> SimonRC: right; i know that from D&D games :P
12:50:44 <SimonRC> sieni: ah, ok
12:51:05 <SimonRC> RyanT5001: heh.  Me, from Nethack.
12:51:59 <sieni> isn't that group something like (Z x Z) x (Z / 4z) x (Z / 2Z) (i.e. translations x rotations x flips
12:52:58 <SimonRC> no idea
12:53:14 <chrismbrown> say I have a function f : : Int -> [a]
12:53:42 <notsmack> chrismbrown: Int -> [a] ?
12:53:43 <chrismbrown> and I map f over some list, I also want its first parameter to be incremented each time, is there a way I can that without rewriting map?
12:54:22 <chrismbrown> err.. f :: Int -> a -> a
12:54:36 <notsmack> Ah.  That one can possibly be implemented.  :-)
12:55:17 <notsmack> chrismbrown: maybe "zipWith f [1..] list"?
12:55:30 <chrismbrown> oh
12:55:31 <chrismbrown> :)
12:55:34 <Binkley> or you can use mapAccumL or mapAccumR
12:55:51 <notsmack> @src mapAccumL
12:55:51 <lambdabot> mapAccumL _ s []        =  (s, [])
12:55:51 <lambdabot> mapAccumL f s (x:xs)    =  (s'',y:ys)
12:55:51 <lambdabot>    where (s', y ) = f s x
12:55:51 <lambdabot>          (s'',ys) = mapAccumL f s' xs
12:55:54 <DRMacIver> I always forget you can do [1..] to get a list of all natural numbers.
12:56:16 <opqdonut> krhm, [0..] to get all natural numbers
12:56:20 <opqdonut> :)
12:56:26 <DRMacIver> No comment. :)
12:56:28 <notsmack> DRMacIver: Counting numbers
12:56:30 <chrismbrown> @type mapAccumL
12:56:32 <lambdabot> forall acc x y. (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
12:56:40 <DRMacIver> I don't discuss religious issues like where the natural numbers start.
12:56:48 <sieni> 0
12:56:49 <DRMacIver> @pl \n -> [1..n]
12:56:50 <lambdabot> enumFromTo 1
12:57:08 <DRMacIver> @pl [1..]
12:57:08 <lambdabot> [1..]
12:57:09 <opqdonut> nice
12:57:19 <DRMacIver> @pl \n -> [n..]
12:57:19 <lambdabot> enumFrom
12:57:23 <opqdonut> :)
12:57:24 <nomeata> Is there a way to ask haskell to just type-check, but not compile the code, and dont complain if functions just have type signatures, but no code?
12:57:33 <DRMacIver> I don't think so.
14:56:35 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
14:56:35 --- topic: set by dons on [Sun May 27 19:49:12 2007]
14:57:05 <SamB> DukeDave: could you explain the purpose of your activities?
14:57:33 <mauke> @type let foo f l = fix (flip f l) in foo
14:57:34 <lambdabot> forall c b. (c -> b -> c) -> b -> c
14:57:47 <nomeata> If anyone is interested I can provide the complete program that produces this behaviour
14:58:28 <nomeata> ok, even matchin on a value that is _never_ passed to that function changes the behaviour
14:58:37 <nomeata> it seems it cuts of the first element of the return list
14:58:53 <mauke> @type let foo f l = let r = concatMap (f r) l in r in foo
14:58:55 <lambdabot> forall b a. ([b] -> a -> [b]) -> [a] -> [b]
15:00:03 <SimonRC> > let (huge :: Float) = 2 ** 99 in huge == huge + 1
15:00:03 <lambdabot>  Parse error in pattern
15:00:19 <SimonRC> > let { huge :: Float ; huge = 2 ** 99 } in huge == huge + 1
15:00:21 <lambdabot>  True
15:00:29 <SimonRC> Yay!
15:01:35 <DukeDave> SamB, sorry for the delay & thanks for replying.. The function ([a] -> b -> a) updates the internal state model (a) of my robot using new sonar readings (b)... But in doing so it needs to access its state history to do estimations based on previous maps :)
15:01:49 <mauke> > let huge :: Float; huge = 2 ** 99 in case huge of huge + 1 -> huge
15:01:49 <lambdabot>  Parse error in pattern
15:02:19 <mdmkolbe|work> > let huge :: Float; huge = 2 ** 99 in case huge of (huge + 1) -> huge
15:02:20 <lambdabot>  Parse error in pattern
15:02:26 <SamB> DukeDave: couldn't you include the recent history in the return value?
15:02:53 <mauke> d'oh. no n+k patterns
15:03:48 <DukeDave> Ah, to give f a type ([a] -> b -> [a]) ?
15:04:18 <hpaste>  nomeata pasted "pattern matching causes strange things" at http://hpaste.org/162
15:04:31 <nomeata> I have pasted the function in question.
15:05:46 <nomeata> (And I know it is quite ugly code)
15:06:49 <SamB> DukeDave: er, that's not exactly what I meant...
15:07:03 <stick_figure> Can one do inline pattern matching, ie say I have a variable with a Maybe value, and I want to deal with the Nothing and Just cases without writing another function?
15:07:03 <DukeDave> Heh, okay..
15:07:48 <SimonRC> stick_figure: case ... of ?
15:07:56 <DukeDave> How do you mean?
15:08:16 <stick_figure>  yeah, that's it, sorry to ask stupid questions
15:08:25 <Saizan> there's also maybe
15:08:37 <Saizan> > maybe 1 id (Just 2)
15:08:42 <lambdabot>  2
15:08:43 <mauke> 'maybe' is pattern matching in a box
15:08:50 <Saizan> > maybe 1 id Nothing
15:08:51 <lambdabot>  1
15:09:04 <beelsebob> @type maybe
15:09:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
15:09:16 <Saizan> yeah, but shorter many times
15:09:19 <beelsebob> ah, I see
15:09:45 <beelsebob> maybe 1 show Nothing
15:09:54 <beelsebob> > maybe 1 show Nothing
15:09:55 <lambdabot>   add an instance declaration for (Num String)
15:10:04 <beelsebob> oh, fail
15:10:09 <beelsebob> > maybe 1 read Nothing
15:10:10 <lambdabot>  1
15:10:20 <beelsebob> > maybe 1 read (Just "92487")
15:10:21 <lambdabot>  92487
15:10:23 <beelsebob> cool
15:10:37 <nomeata> oh well, its too late to debug compiler bugs. n8 everyone!
15:13:12 <sorear> hello.
15:13:13 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:13:17 <sorear> @messages
15:13:17 <lambdabot> ivanm said 14h 48m 19s ago: My original question was about why using lambdabot's commands, like @yarr!! didn't trigger the message, not appearing online
15:13:30 <slowriot> has anyone here tried building frag?
15:13:46 <sorear> dons, if anyone
15:13:49 <sorear> dons: ping?
15:14:30 <Saizan> mmh i built it quite some time ago ..
15:15:05 <DukeDave> Hey sorear, ddarius, if you're feeling like some fun you could always check out http://hpaste.org/161   ;)
15:15:17 <slowriot> When I try it, the modules all compile, but then I get this error: /usr/bin/ld: cannot find -lXmu
15:16:37 <Saizan> ah.. i was on windows..
15:17:35 <Saizan> ?where frag
15:17:35 <lambdabot> http://www.haskell.org/haskellwiki/Frag
15:18:51 <sorear> slowriot: you need to install X
15:19:09 <slowriot> sorear: where can I get that?
15:19:23 <ddarius> DukeDave: Probably not the answer you are looking for, but a crazy paper that covers what you want (in ridiculous abstraction) is Recursion Schemes from Comonads.  I think your function is a histomorphism or maybe a course-of-values one, I forget the details of them.
15:19:34 <sorear> slowriot: that response was a little too automatic.
15:19:38 <sorear> slowriot: you on windows?
15:19:57 <slowriot> sorear: nope, linux... ubuntu
15:20:35 <sorear> slowriot: Do you have a graphical environment?
15:20:38 <DukeDave> ddarius, interesting.
15:20:38 <slowriot> yeah
15:20:40 * DukeDave dies
15:20:46 <slowriot> GNOME
15:21:01 <SamB> slowriot: definately X
15:21:04 <sorear> slowriot: type 'locate libXmu' at a terminal.  where is it?
15:21:31 <slowriot> usr/lib
15:21:34 <DukeDave> Hey slowriot, whatcha trying?  I'm running Edgy Eft at the mo..
15:22:00 <sorear> slowriot: Older versions of Debian, and probably ubunto as well, put the X11 libs in /usr/lib/X11/ rat ... oh wait
15:22:39 <slowriot> DukeDave: trying to build frag.
15:23:18 <slowriot> DukeDave: Feisty Fawn
15:23:31 <sorear> slowriot: you need a symlink from /usr/lib/libXmu.so.6 to /usr/lib/libXmu.so ; you can get that from the dev package
15:23:48 <slowriot> okay, I'll get that
15:23:56 <sorear> libxmu-dev on debian sid
15:24:27 <sorear> it'll install a lot of other stuff you only need for C dev; don't be suprised by a multi hundred KB package
15:25:09 <hpaste>  int-e annotated "A need for 'fix' ?" with "how about this?" at http://hpaste.org/161#a1
15:26:01 <dainanaki> when someone gets the chance, could they explain datatypes to me?
15:26:10 <dainanaki> i'm really confused
15:26:46 <ddarius> Feisty Fawn here mit xmonad
15:27:13 <ddarius> dainanaki: What about them?
15:28:00 <dainanaki> ddarius, i really don't understand their declarations, constructors or how you use them in functions
15:28:40 <sorear> ddarius: what does mit mean in that context?
15:29:21 <dmead> with
15:29:24 <Procyon112> @seen chessguy
15:29:25 <lambdabot> I saw chessguy leaving #haskell 19h 14m 58s ago, and .
15:29:27 <dmead> mit = with
15:29:30 <Procyon112> @seen chessguy_work
15:29:30 <lambdabot> I saw chessguy_work leaving #haskell, #xmonad, #darcs, #haskell-soc and #haskell-overflow 11d 56m 38s ago, and .
15:30:12 <dmead> dainanaki, do you have a particular example?
15:30:34 <DukeDave> int-e, could I please have an address to send a complimentary cookie to :)
15:30:49 <DukeDave> Looks just right!
15:30:51 <dainanaki> how about the Maybe datatype or the Either datatype?
15:31:10 <dainanaki> i don't understand how they are used in a function
15:31:13 <dmead> hmm
15:31:18 <ddarius> dainanaki: When you declare, data TypeConstructor a = DataConstructor1 a Int | DataConstructor2 Char String it allows you to pattern match them, usually by writing multiple clauses of a function func (DataConstructor1 _ n) = n; func (DataConstructor2 _ s) = length s
15:31:19 <dmead> thats a bit harder cause it involves monads
15:31:31 <ddarius> dmead: ?
15:31:44 <dmead> doesn't it?
15:31:55 <weitzman> You don't really need to know monads to use Maybe, but it helps make you look cool
15:31:56 <ddarius> No (at one level)
15:32:01 <dmead> hehe
15:32:12 <dmead> i dunno
15:32:15 <dmead> i avoid monads at all costs
15:32:19 <dmead> at this point
15:32:32 <dainanaki> ddarius, could you do that a bit more in laymans terms and in a few steps?
15:32:49 <thoughtpolice> dainanaki: here's an example: data Click a = Silence | Clicked a. let's say this means this data can either 'click' or it can be 'silent.'
15:33:12 <thoughtpolice> (this is pretty contrived, but just try and follow in general)
15:33:19 <dainanaki> ok so far
15:33:25 <thoughtpolice> let us say you have a function,
15:33:26 <ddarius> Yes! The motto of Haskell, Avoid return at all costs!
15:33:28 <dainanaki> now how does that go into a function
15:33:28 <thoughtpolice> say
15:33:36 <dmead> ddarius, ha!
15:33:51 <dmead> dainanaki, i'll make you a little example
15:34:09 <dainanaki> ok
15:34:22 <thoughtpolice> functination :: Int -> Click
15:34:25 <thoughtpolice> er
15:34:26 <dmead> give me two min and i'll make it decent
15:34:27 <thoughtpolice> functination :: Int -> Click a
15:34:44 <thoughtpolice> for simplicity, here's something of what that function may look like
15:34:56 <thoughtpolice> functination 0 = Silence
15:35:00 <thoughtpolice> functination x = Clicked x
15:35:12 <thoughtpolice> (again, this is fairly contrived.)
15:35:36 <dainanaki> but it helps
15:35:57 <thoughtpolice> you are returning a type of 'Click' from the function, obviously. the way you return it given your constructors -- Silence or 'Clicked x' -- is just a way of telling what the data represents.
15:36:22 <ddarius> dainanaki: Just to add on the side, data Maybe a = Nothing | Just a
15:36:23 <ddarius> :t Just
15:36:25 <lambdabot> forall a. a -> Maybe a
15:36:34 <fasta> Juhaz: @src Maybe
15:36:41 <fasta> @src Maybe
15:36:41 <lambdabot> data Maybe a = Nothing | Just a
15:37:32 <thoughtpolice> dainanaki: your function always returns a 'Click'; the constructor is just a way of saying what *kind* of a click. either a silent one, or one that made a 'clicked noise' (if you want to think of it that way)
15:37:52 <dainanaki> oh!
15:37:55 <thoughtpolice> interestingly, this 'Click' type is identical to Maybe.
15:38:04 <dainanaki> ok, that makes sense
15:38:08 <thoughtpolice> as you should be able to tell now, I hope.
15:38:19 <dainanaki> yeah
15:38:32 <dainanaki> well what about when you want to do something like (3::Int)
15:38:49 <ddarius> > Just 3 :: Maybe Int
15:38:51 <lambdabot>  Just 3
15:39:04 <ddarius> > Nothing :: Maybe Int
15:39:05 <lambdabot>  Nothing
15:39:49 <dainanaki> ok
15:40:03 <ddarius> Yay Blade Launcher
15:40:28 <dainanaki> and what about how either side of the datatype has a different amount of variables?
15:40:41 <slowriot> sorear: to make a symlink, just type ln -s target link-name, right?
15:40:51 <thoughtpolice> dainanaki: you mean how each constructor can have a different amount of parameters?
15:40:54 <sorear> Apparently you can't redirect directly from multiple files in UNIX...
15:41:12 <dainanaki> right
15:41:21 <thoughtpolice> nothing; really. it just has to be a constructor of the datatype you need.
15:41:23 <thoughtpolice> for example
15:41:27 <thoughtpolice> say you have another function,
15:41:44 <sorear> slowriot: Yes ... but you really shouldn't be messing around in /usr
15:41:47 <thoughtpolice> gimme :: Click a -> Int
15:41:49 <fasta> sorear: zsh can, IIRC.
15:42:08 <sorear> slowriot: High risk of confusing the package manager
15:42:16 <thoughtpolice> you could do 'gimmie (Silence)' or you could do 'gimmie (Clicked 3)'
15:42:31 <thoughtpolice> it doesn't matter; your constructor is still apart of the 'click' datatype.
15:42:35 <dmead> ?paste
15:42:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:42:49 <gaal> anyone remember what doecument describes the meanings of names used by the typechecker (a, a1, t, etc.)? I thought I saw it in the GHC commentary a while ago but I can't find it.
15:42:55 <slowriot> sorear: I'm confused about your advice. I got the libxmu-dev package.
15:43:04 <hpaste>  dmead pasted "data constructor  example" at http://hpaste.org/163
15:43:22 <dmead> dainanaki, how a look at that
15:43:27 <thoughtpolice> of course, how the function itself deals with it is a different matter; in the case of gimmie you could just use a pattern match to return the inverse of 'functination'
15:43:29 <sorear> slowriot: In that case the symlink is already there
15:43:34 <gaal> or is it in the user guide or indeed in the report?
15:43:37 <sorear> slowriot: try and build frag?
15:43:38 <fasta> gaal: you mean in the source code?
15:43:40 <dainanaki> ok thank you
15:43:55 <dainanaki> how about either though?
15:44:00 <dainanaki> data Either a b = Left a
15:44:03 <dainanaki> | right b
15:44:05 <thoughtpolice> ?src Either
15:44:05 <lambdabot> Source not found. stty: unknown mode: doofus
15:44:09 <dmead> either is for conditional evaluation
15:44:10 <dainanaki> how might that be used?
15:44:10 <thoughtpolice> @src Either
15:44:10 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
15:44:11 <slowriot> sorear: /usr/bin/ld: cannot find -lXi
15:44:12 <gaal> fasta: I thought I saw a doc explaining it
15:44:14 <thoughtpolice> :/
15:44:21 <fasta> gaal: explaining _what_?
15:44:27 <dmead> dainanaki, usually right returns a result and left is an error
15:44:36 <dmead> i think
15:44:46 <dmead> like
15:44:50 <thoughtpolice> dainanaki: it's a way of saying something either had a end-result of 'Right' (correct) or 'Left' (err)
15:45:05 <dmead> so you have a pattern in some function
15:45:16 <dmead> that handles a result contained in the variable after right
15:45:22 <dmead> or an errors after left
15:45:28 <dmead> err
15:45:31 <sorear> slowriot:
15:45:32 <dmead> dyslexia...
15:45:38 <sorear> > "-Xi" == "-Xmu"
15:45:39 <lambdabot>  False
15:45:47 <sorear> you need a different library
15:45:53 <slowriot> libXi?
15:46:04 <gaal> fasta: explaining why :t sometimes uses a and b, while some other times a and a1, for example
15:46:07 <thoughtpolice> actually, that's just the general usage; you can use Either to represent the return of any two arbitrary data types; using the constructors to differentiate between a 'correct' or 'incorrect' is just a common way of using Either.
15:46:24 <sorear> libxi-dev
15:46:38 <thoughtpolice> but that's Either's purpose, anyway.
15:46:39 <slowriot> sorear: It originally said lXmu, now it's complaining about lXi
15:47:11 <sorear> slowriot: You fixed the lXmu problem by installing libxmu-dev.  Now you have a different problem.
15:47:16 <dmead> dainanaki, you not at the point i think to be using either... just try to get down regular constructors first
15:47:23 <dainanaki> so thoughtpolice, say somebody gave an incorrect type of value to a function, then you would use left to give an error or something?
15:47:38 <thoughtpolice> dainanaki: well no not necessarily; perhaps just an incorrect value
15:47:44 <thoughtpolice> or maybe a computation in your function went wrong
15:47:56 <dainanaki> dmead, well I'm trying to work through yaht, but i'm kind of stuck
15:48:03 <thoughtpolice> for example if 'f' say, needed to read a file
15:48:14 <dmead> dainanaki, forget about either for a while
15:48:23 <dmead> just understand the basic type system first
15:48:28 <thoughtpolice> you could use Either and represent if the file was there or not
15:48:29 <fasta> gaal: AFAIK, it just counts from t, t1, t2 ...
15:48:46 <fasta> gaal: things like "a" come from user input.
15:48:49 <thoughtpolice> dmead: either is one of the simplest and easiest to use data types I found.
15:49:01 <fasta> gaal: in which ghc reuses those names.
15:49:12 <thoughtpolice> same with Maybe. it's a very simple datatype that can be pretty useful.
15:49:19 <dmead> thoughtpolice, I agree but it's not basic newb information
15:49:19 <fasta> > :t \a v f  e w gf -> (a, gf)
15:49:20 <lambdabot>  Parse error
15:49:21 <gaal> fasta: but sometimes it uses a, b, c; sometimes a, a2..; sometimes t.
15:49:22 <dainanaki> plus, after that section is binary trees and recursive datatypes
15:49:46 <gaal> @type \a v f  e w gf -> (a, gf)
15:49:47 <fasta> gaal: Can you give an example that doesn't use builtins?
15:49:48 <lambdabot> forall t t1 t2 t3 t4 t5. t4 -> t -> t1 -> t2 -> t3 -> t5 -> (t4, t5)
15:49:50 <thoughtpolice> dmead: i 'pose
15:50:11 <dmead> dainanaki, take a look at my example
15:50:17 <slowriot> sorear: it worked. thanks
15:50:20 <dmead> and run zoosummary zoo in ghci
15:50:26 <dmead> "zoosummary zoo"
15:50:36 <dmead> or hugs will do
15:51:07 <dainanaki> dmead, after basic datatypes, then it gets into recursive ones and binary trees and such, so how do you propose i continue to learn haskell if the upcoming sections are built off of this part?
15:51:26 <dmead> just stay on it and try more examples if you don't get it
15:51:31 <thoughtpolice> dainanaki: I advise you just try and have fun with some datatypes.
15:51:34 <dainanaki> dmead, also, thanks for that example, i have looked at it and it is very helpful
15:51:44 <ddarius> Either is pretty fundamental as it corresponds to disjoint sums.
15:51:45 <dmead> np
15:51:55 <gaal> fasta: looking for one. I did see a a1 that I don't think I'd introduced once, but I can't remember where now :)
15:52:28 <ddarius> dainanaki: Do you know how functions work in Haskell more or less?
15:52:44 <slowriot> 3 fps :(
15:52:53 <thoughtpolice> dainanaki: you may want to look here -- http://en.wikibooks.org/wiki/Haskell/More_on_datatypes
15:53:08 <ddarius> Blech, dmead, why the many superfluous parentheses?
15:53:11 <dainanaki> ddarius, yeah i get functions quite well
15:53:25 <dmead> ddarius, habit from ml and lisp =/
15:53:36 <dainanaki> and i've built a few smaller programs using monads, but now i'm kind of hitting a wall
15:53:44 <ddarius> dainanaki: Are you familiar with BNF notation?
15:53:59 <dainanaki> ?
15:54:05 <ddarius> I'll take that as a no.
15:54:07 <dmead> :o
15:54:40 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/164
15:54:43 <ddarius> What -do- they teach programmers these days?
15:54:51 <dmead> hehe
15:54:53 <thoughtpolice> ddarius: who's 'they'?
15:54:54 <dmead> maybe he's just not there yet
15:55:03 <ajudem_me> do you know what's the problem with this code?
15:55:06 <dainanaki> i'm in high school, so if that is something above pre-cal or something i dunno
15:55:14 <dmead> ahh
15:55:29 <ddarius> dainanaki: I'm just poking fun at you, though BNF is pretty fundamental CS.
15:55:31 <thoughtpolice> dainanaki: haha don't worry about it. i'm a senior in hs and it's not really that complicated.
15:55:31 <dmead> usually people learn Haskell in junior  year i think of college
15:55:37 <sorear> dainanaki: I think your implication is false.
15:55:39 <dmead> so your doin good
15:55:50 <ajudem_me> where: http://hpaste.org/164
15:55:57 <dainanaki> well what does it stand for?
15:55:58 <ajudem_me> here, I mean:  http://hpaste.org/164
15:56:02 <dmead> dainanaki, bakcus normal form
15:56:04 <sorear> I'm in high school too
15:56:08 <ddarius> I think I learned Haskell in senior year or so.
15:56:12 <sorear> backus *naur* form
15:56:14 <ddarius> Of high school.
15:56:20 <weitzman> Do people usually learn Haskell in college?
15:56:24 <weitzman> I would think not
15:56:27 <dainanaki> sorear, different high schools
15:56:28 <dmead> o0
15:56:35 <dmead> weitzman, if they do at all it's in college
15:56:44 <dmead> usually.
15:56:57 <ajudem_me> ok... already find out...I've miswritten program
15:57:01 <sorear> dainanaki: Of course.  But all high schools in the US teach at approximately the same level
15:57:16 <sorear> almost all
15:57:22 <dainanaki> that is quite the assumption
15:57:40 <dainanaki> not in my experience
15:57:52 <ddarius> weitzman: I wasn't -taught- Haskell in high school.
15:57:56 <dmead> all decent US highschools teach the same thing
15:57:56 <weitzman> People who starting learning Haskell before college end up doing programming language or mathematical logic research, at least in my experience
15:57:59 <dmead> http://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form
15:58:00 <lambdabot> Title: BackusNaur form - Wikipedia, the free encyclopedia
15:58:04 <dainanaki> anyways, thats not important
15:59:48 <dmead> BNF is important :P
16:00:21 <dainanaki> well somehow i made it through two years of compsci in the IB program and we never covered it...
16:00:57 <sorear> ye gods.  what subjects WERE they teaching?
16:01:06 <thoughtpolice> grr. this is annoying; my code isn't binding to the port I want. :(
16:01:09 <weitzman> Computer science is a very broad subject. BNF is useful if you're into parsing or the study of formal languages and computability/complexity classes
16:01:19 <weitzman> There are other worthwhile things to study
16:01:36 <thoughtpolice> 'computer science is as much about computers as astronomy is about telescopes'
16:01:44 <weitzman> The complexity of specific algorithms, for example
16:02:13 <weitzman> I believe the AB compsci studies sorting algorithms and that kind of thing
16:02:17 <dainanaki> BNF doesn't look too complicated
16:02:22 <weitzman> It's not
16:02:32 <dainanaki> correct
16:03:03 <sorear> What is there to study about sorting?  I can't think of any non-heap sorting algorithms
16:03:08 <dainanaki> i came up with an algorithm that was a little faster than quicksort on my own, but it wasn't as good as a radix sort
16:03:30 <dmead> theres something on the frontpage at sourceforge thats supposed to be really fast
16:03:41 <dmead> better than quicksort or something for many applications
16:03:44 <weitzman> If you don't already have a lot of experience with algorithmic complexity analysis and the study of random algorithms, you can learn quite a lot from sorting
16:04:32 <dainanaki> wait so is BNF basically what datatypes are or something?
16:04:36 <weitzman> You got algorithms with different worst-case and average case performance, different kinds of memory usage patterns (in-place, good/bad memory locality, etc.)
16:04:37 <dmead> no
16:04:50 <dmead> dainanaki, it's a a notation thats related to why we use datatypes
16:05:23 <dmead> datatypes like that let us decide on a case or a function body
16:05:26 <dainanaki> ok
16:05:36 <dmead> it uses something called Unification to decide on a body
16:05:45 <dmead> you pass a function some paramters
16:06:00 <dmead> and the first in the assocative list that it matches to, gets called
16:06:31 <dainanaki> ok, simple enough i think
16:06:34 <dmead> right
16:06:47 <dmead> would you like some example problems to do?
16:07:06 <dmead> i have a bunch of them leftover my proff picked out of an ML textbook
16:07:09 <sorear> since when does dmead say "something called Unification" ? are you just simplifying it?
16:07:16 <dainanaki> yeah let me try some and see
16:07:25 <dmead> i'm just trying to simplify my explanation
16:07:41 <dmead> dainanaki, one sec
16:07:54 <sorear> ok, I was wondering what happened to you :)
16:08:14 <dmead> sorear, dainanaki is in highschool so i'm trying not to be a jackass and talk over him
16:08:18 <dmead> :P
16:08:46 <dainanaki> thank ye!
16:08:55 * sorear exercises his highschool prerogative to talk over dmead
16:09:09 <dansa> hello. Have you guys seen that "real-world haskell" book project? I wonder when the first chapter will come out, I'm looking forward to read it.
16:09:10 <dmead> lol what
16:09:12 <dmead> xD
16:09:32 <ddarius> dansa: All of the authors are here.
16:10:03 <dainanaki> lol
16:10:42 <dansa> cool, the book's goal is very interesting
16:10:58 <dmead> hey, just as an aside
16:11:04 <sorear> ?
16:11:09 <dmead> do the big  kids here put functional languages on their resume
16:11:17 <dmead> and do people even ask about it?
16:11:23 <weitzman> Resume's are a tricky thing
16:11:41 <dmead> i have an imperative section and a functional section
16:11:44 <ddarius> Some do some don't.
16:11:46 <dmead> i think it confuses hiring managers
16:11:50 <dmead> xD
16:11:54 <weitzman> I mention functional programming on mine, but for the most part I don't expect people reading my resume to know about it
16:11:55 <ddarius> I wouldn't bother with that distinction in a resume.
16:11:57 <ekidd> dmead: Yeah, I mention functional language stuff. Usually because I'm using the functional language to solve hard problems that are interesting in and of themselves. :-)
16:12:14 <dmead> ddarius, yea im finding out it's not worth the effort
16:12:20 <dmead> ekidd, cool cool
16:12:43 <dansa> I only say "please hire me" on my resume and hope that someone will be kind enough
16:12:54 <Binkley> dmead: I mention it because usually it either impresses people or they ignore it and there's no harm done
16:13:00 <weitzman> It saddens me that your resume has to get through a bunch of non-programmers before it gets to anyone who would be fit to judge your competence
16:13:08 <dmead> indeed
16:13:13 <dmead> i took a test today on java and C++
16:13:15 <weitzman> I really don't know what's the best way to arrange it
16:13:17 <Binkley> weitzman: depends on the company, and the best is when you already know someone at a company, so you can avoid it :-)
16:13:21 <sorear> @remember dansa I only say "please hire me" on my resume and hope that someone will be kind enough
16:13:21 <lambdabot> Done.
16:13:27 <dmead> hah
16:13:27 <dmead> yea
16:13:37 <dmead> this test... had a bunch of obscure shit on it
16:13:38 <dainanaki> i so want to work at google
16:13:42 <dainanaki> that would be the best
16:13:54 <weitzman> Binkley: Well, I've got another cheat I used. Got to a really, really well known school and use their career department resources :)
16:13:55 <ddarius> dainanaki: You might be surprised.
16:13:56 <dmead> dainanaki, get a PHD first?
16:14:17 <dainanaki> lol i know
16:14:24 <dmead> i know the grandchildren of one of the owners of SAP america
16:14:25 <dainanaki> it'll be a while
16:14:29 <dmead> and im trying to work on that contat
16:14:32 <ddarius> Yes, I think they have a word for this cheat... uh, um, oh yes! Networking.
16:14:33 <dmead> *contact
16:14:33 <dmead> ah ah
16:14:36 <dmead> indeed
16:15:28 <Binkley> dainanaki: I get emails from Google recruiters like once a week through LinkedIn, so I think your best bet is to set up a profile there :-)
16:15:33 <dainanaki> i have no contacts, but colleges seem to like me a lot because of test scores
16:15:54 <dmead> well thats good
16:16:08 <weitzman> Binkley: I set one up recently, but I'm not sure how I feel about it. I'm about to my first full-time position this fall and I don't want a web page saying "Hey, send me offers!"
16:16:21 <weitzman> s/to my/to start my/
16:16:29 <dmead> i just had an interview with a headhunting firm
16:16:32 <dmead> anyone every use one of them?
16:17:41 <weitzman> If I were an employer, I don't know how I would feel about my employees soliciting recruiters on the public internet
16:17:53 <Binkley> weitzman: it's pretty normal to have a profile there, because it has other uses as well
16:18:02 <Binkley> getting back in touch with people, making connections, etc.
16:18:09 <Binkley> I know lots of people who have jobs who have profiles there
16:18:34 <Binkley> not like I think it's all that useful, but I can't imagine any employer having a problem with employees using it
16:18:40 <lucca> weitzman: eh, some employers prefer that you sign in to things like linked in
16:19:59 <Binkley> @yow
16:19:59 <lambdabot> If I had a Q-TIP, I could prevent th' collapse of NEGOTIATIONS!!
16:20:24 <ddarius> They feel like they don't live in Japan (unless they do)
16:21:14 <Excedrin> headhunters are looking for heads because they don't have heads of their own
16:22:08 <dmead> hmmhmm
16:22:11 <dainanaki> :|
16:22:31 <dmead> i suppose it really depends on what job they hook you up with
16:23:36 <Excedrin> my experience with headhunters has always been sort of unimpressive; they didn't understand the position, skills, companies they were trying to place me at, etc
16:25:03 <dainanaki> dmead, any progress on finding those practice problems for me?
16:25:15 <dmead> yea, just cleaning it up
16:25:25 <dmead> i'll send you a file with the questions and one with the answers
16:25:34 <dainanaki> ok
16:25:50 <dmead> do you understand how to set ghci up with emacs?
16:26:12 <dainanaki> i already have ghci, not emacs though
16:26:14 <dmead> cause thats really the first thing IMO
16:26:18 <dmead> ah.
16:26:31 <ddarius> I don't know how to set up GHCi with emacs...
16:27:19 <Binkley> what do you mean by setting it up other than running it in a shell within emacs?
16:27:30 <dmead> yea
16:27:38 <dmead> ddarius, well your and all your VI pals are on crack :P
16:27:56 <Excedrin> but modes are goood
16:27:58 <dmead> Binkley, im referring to running ghci in a minor mode
16:28:03 <ddarius> That would explain why dons is so productive...
16:28:05 <weitzman> vi++
16:28:25 <Excedrin> vii
16:28:36 <dmead> :P
16:28:44 <Binkley> ah, I've never done that
16:28:45 <sorear> dmead: I'm using vi now, and I forgot *how* I set it up, but
16:29:00 <sorear> http://members.cox.net/stefanor/.emacs
16:29:02 <sorear> peruse away!
16:29:03 <dmead> http://taz.cs.wcupa.edu/~dmead/stuff/emacs.png
16:30:17 <dmead> dainanaki, heres the problems
16:30:18 <dmead> http://taz.cs.wcupa.edu/~dmead/code/Practice.hs
16:30:26 <dmead> theres one more i didn't have the info for
16:30:30 <dmead> but that should start you off
16:30:52 <dainanaki> thanks
16:32:03 <sorear> dmead: helpful?
16:32:30 <dmead> thats alot of tweaks :)
16:33:00 <sorear> dmead: Not a lot, it's all set up by the customization mechanism...
16:33:08 <dmead> ah
16:33:16 <dmead> do you still not use X?
16:33:19 <sorear> also, you can safely ignore everything starting with erc-
16:33:44 <sorear> stefan@stefans:~$ echo $TERM
16:33:44 <sorear> rxvt-unicode
16:33:52 <sorear> :)
16:34:40 <dmead> dainanaki, heres my answers
16:34:51 <ddarius> I have to agree with sorear; that seems like nowhere near the amount of hacks emacs people like to make
16:34:52 <dmead> it's the first haskell code i wrote but it's correct
16:34:53 <dmead> http://taz.cs.wcupa.edu/~dmead/code/PracticeAnswers.hs
16:35:52 <ddarius> summastion?
16:36:12 <dmead> typo
16:36:13 <ddarius> And in syntactical ways the code is non-idiomatic.
16:36:13 <dmead> ah ah
16:36:26 <dmead> yes
16:36:33 <dmead> its supposed to be non-haskell centric
16:36:52 <dmead> ie it has concepts that you need to read lisp ML and haskell
16:38:02 <dmwit> I guess I'd write most of those a little differently. =P
16:38:11 <dmead> fac is actually also valid ML code
16:38:32 <dmead> so is addone
16:38:56 <dmead> myflip would be except :: is cons in ML
16:41:47 <dainanaki> whoa, so you can do more than just x:xs?
16:41:56 <dainanaki> you can do x:y:xs?
16:41:59 <dmwit> Any constructor pattern at all.
16:42:07 <ddarius> dainanaki: You can nest patterns arbitrarily deep..
16:42:30 <dmwit> > [i | (Just (Just i)) <- [Just (Just 3), Nothing, Nothing, Just Nothing, Just (Just 5)]]
16:42:31 <lambdabot>  [3,5]
16:42:36 <ddarius> :t let f (Just ((x,3):ys) = x in f
16:42:37 <lambdabot> parse error on input `='
16:42:41 <dainanaki> hey well i didn't know that... that's very nifty
16:42:43 <ddarius> :t let f (Just ((x,3):ys)) = x in f
16:42:45 <lambdabot> forall t t1. (Num t1) => Maybe [(t, t1)] -> t
16:43:49 <ddarius> > catMaybes . map join $ [Just (Just 3), Nothing, Nothing, Just Nothing, Just (Just 5)]
16:43:50 <lambdabot>  [3,5]
16:45:31 <dmead> try and do some yourself thogh
16:45:34 <dmead> *though
16:45:37 <dmead> without looking :P
16:46:05 <dainanaki> i know, i know, i was just at a loss about that one
16:46:59 <dmead> oops, forgot to put myreverse on the answers
16:47:58 <ddarius> dainanaki: After you come up with your own answers, and look at his, you can look at source to some of them in the prelude.  You may be surprised.
16:48:18 <dmead> yea
16:48:29 <dmead> the ones in the prelude are done the haskell way
16:48:41 <dmead> or just better :)
16:49:42 <dainanaki> summastion was pretty easy
16:49:50 <ddarius> "Recursion: Just there so you can get rid of it." (Actually, haskell does that a lot...)
16:49:50 <dainanaki> so is addone
16:50:43 <dainanaki> yeah especially in lists
16:51:12 <Binkley> yes, explicit recursion is considered harmful :-)
16:51:32 <dmead> hmm
16:51:40 <dmead> i also have some problems from my lisp class i could translate
16:52:40 <SimonRC> gah!
16:52:54 <SimonRC> I have snuck an unwanted assumption into my program
16:53:17 <SimonRC> I was assuming each block of space could only be connected to each other block of space in at most one way.
16:53:31 <dmead> what are you working on?
16:53:32 <ddarius> Assumptions want to be wanted too.
16:53:39 <SimonRC> (This rules out some particularly silly things I could do.)
16:53:45 <Saizan> i'm very jealous when i read something like haskell/scheme/lisp class, here we get only java all the time..
16:54:02 <dmead> Saizan, maybe it's hiding someone
16:54:08 <dmead> *somewhere
16:54:12 <dmead> ask your department head
16:54:19 <SimonRC> I am currently making a model of a discrete space in which
16:54:39 <SimonRC> which is made of blocks of 2-d euclidean space stiched together
16:55:13 <dmead> :o
16:55:14 <dmead> sounds neat
16:55:25 <SimonRC> You should see my maze-generation plans
16:55:37 <Saizan> dmead: here most of the classes you have to follow are fixed when you decide you subscribe to uni (italy)
16:55:40 <SimonRC> BTW, I am using matrices, so flips are possible
16:55:48 <dmead> Saizan, ah
16:56:02 <dmead> Saizan, can you do an independent study perhaps?
16:56:13 <dmead> dainanaki, heres the original ML for those questions
16:56:14 <dmead> http://taz.cs.wcupa.edu/~dmead/code/project3.sml
16:56:14 <weitzman> Saizan: Do they use Java in your systems classes too? (i.e. operating systems)
16:56:35 <dmead> they do in mine
16:56:38 <dmead> but i didn't take it
16:56:42 <weitzman> That's dreadful
16:56:47 <SimonRC> I will try building a kleineschflache, of course.
16:56:53 <dmead> opted for lisp/ml instead
16:56:58 <dainanaki> thanks for the ml too
16:57:25 <dmead> np
16:57:32 <dmead> it's from like 2004 or 5 i think
16:57:55 <SimonRC> OTOH, I can mostly replace self-attached blocks with several seperate blocks, except where they are very small, but that would be a bad idea anyway
16:59:26 <dainanaki> how come myreverse can't be this:
16:59:32 <dmead> dainanaki, heres the lisp !
16:59:33 <dmead> http://taz.cs.wcupa.edu/~dmead/code/homework.lisp
16:59:41 <dainanaki> myreverse (x:xs) = myreverse(xs):[x]
16:59:58 <dmead> : is called cons
17:00:11 <dmead> the operation comes from memory management on old (like late 50s) lisp system
17:00:21 <dmead> it means you take a memory cell (one item)
17:00:26 <dmead> and connect it to a bunch of others
17:00:37 <dainanaki> ok
17:00:40 <SimonRC> dainanaki: and those () are unidiomatic
17:00:47 <SimonRC> the second ones, I mean
17:00:51 <dons> ?uptime
17:00:51 <lambdabot> uptime: 1d 23h 11m 51s, longest uptime: 17d 1h 16m 28s
17:00:52 <dainanaki> well i know what cons is
17:01:02 <sorear> @flish
17:01:15 <SimonRC> sorear: ???
17:01:21 <dainanaki> i'm just asking what i did wrong
17:01:41 <sjanssen> @flush
17:01:54 <sjanssen> @blush
17:02:00 <sjanssen> @slush
17:02:25 <SimonRC> dainanaki: cons returns the result of adding the left thing (a ingle item) to the beginning of the right thing (a list)
17:02:33 <dmead> dainanaki,  he means you should write it as (myreverse xs)
17:02:36 <chessguy> @bot
17:02:36 <lambdabot> :)
17:02:38 <dmead> instead of myreverse (xs)
17:02:54 <SimonRC> but that won't solve his problem
17:02:57 <dmead> right
17:03:03 <dmead> lets let him figure it out
17:03:15 <dmead> dainanaki, i'll give you a hint
17:03:25 <dmead> : must take a single item on the left
17:03:27 <dmead> and a left on the right
17:03:32 <dmead> item cons list
17:03:33 <chessguy> @type (:)
17:03:33 <dmead> x:xs
17:03:35 <lambdabot> forall a. a -> [a] -> [a]
17:07:33 * ndm hates writing abstracts...
17:07:43 <ddarius> hates chording...
17:07:47 <chessguy> ndm, just auto-generate them then :)
17:07:59 <dmead> big words = the win
17:08:20 <ndm> chessguy, i think Word's attempt at that is quite poor - anything better?
17:09:16 <chessguy> bah, just use a randomizer
17:09:18 <sorear> hello ndm
17:09:29 <ndm> hi sorear
17:09:31 <dmead> what about topic generator
17:09:35 <dmead> :p
17:09:44 <ndm> i have plenty of topics!
17:09:46 <dmead> maybe you could paste a few runs of that together
17:10:17 <ndm> i have to give a 40 minute presentation on Catch, Uniplate and Supero as part of my phd (each one gets a chapter in my phd)
17:10:31 <dmead> what are they?
17:10:33 <ddarius> Uniplate?
17:10:34 <sorear> Uniplate?
17:10:35 <ndm> i'm practicing talking extra fast in preparation :)
17:10:57 <ndm> @where+ uniplate http://www.cs.york.ac.uk/~ndm/uniplate/
17:10:57 <lambdabot> Done.
17:11:13 <ndm> Uniplate was previously Play
17:11:15 <ndm> i'm hoping to release Uniplate this week, if all goes well
17:11:16 <sorear> oh.
17:11:21 <ddarius> "Uniplate"?
17:11:30 <ndm> @where Catch
17:11:30 <lambdabot> http://www.cs.york.ac.uk/~ndm/catch/
17:11:47 <ndm> I still prefer Play :(
17:11:52 <dmead> ah
17:11:53 <dmead> neat
17:11:55 <sorear> Becauthor theory, it is no |()| resolves to ascerta RegItem
17:11:55 <sorear> uncursive examed arguments of the appropriate abstrall v, case x of
17:11:55 <sorear> possive power, imple defunction{Overving many examples a con and |cs|
17:11:55 <sorear> is style defunction unmoduced where are f c e = (on :: []) : [] which could be the selection.
17:11:59 <sorear> good enough?
17:12:05 <Binkley> @yow
17:12:06 <lambdabot> Xerox your lunch and file it under "sex offenders"!
17:12:17 <SimonRC> ??
17:12:18 <SimonRC> ?!
17:12:19 <lambdabot> Maybe you meant: . v
17:12:21 <ndm> Uniform boilerplate removal
17:12:23 <Binkley> I think Zippy generates better abstracts :-)
17:12:40 <ddarius> Not Uber?!
17:12:44 <dmead> lol
17:13:03 <ndm> i'm going for an abstract for derive :)
17:13:05 <sorear> ndm: why'd you change the name?
17:13:24 <dmead> @remember Becauthor theory, it is no |()| resolves to ascerta RegItem  uncursive examed arguments of the appropriate abstrall v, case x of possive power, imple defunction{Overving many examples a con and |cs|  is style defunction unmoduced where are f c e = (on :: []) : [] which could be the selection.
17:13:25 <lambdabot> Done.
17:13:36 <ndm> @quote Becauthor
17:13:36 <lambdabot> Becauthor says: theory, it is no |()| resolves to ascerta RegItem  uncursive examed arguments of the appropriate abstrall v, case x of possive power, imple defunction{Overving many examples a con
17:13:36 <lambdabot> and |cs|  is style defunction unmoduced where are f c e = (on :: []) : [] which could be the selection.
17:13:41 <Binkley> dmead, you didn't attribute the quote to anyone
17:13:45 <sorear> dmead: nick!
17:13:48 <dmead> oh
17:13:50 <dmead> xD
17:13:57 <sorear> AND NO COLON AFTER THE NICK
17:13:58 <ddarius> poke dons
17:14:22 <ddarius> sorear: You can hack the quote file.
17:15:26 <ndm> (note, some of my responses are coming up to 1 minute after i send them, and in random order - apologies if i'm not making any sense)
17:15:42 <sorear> ndm: dissociated-press generates pretty good abstracts, eh? :)
17:16:12 <ndm> sorear, my supervisor thought it was a better name - since Play could really be anything
17:16:22 <Binkley> yeah, a name like Play makes it hard to google for
17:17:07 <weitzman> The hardest thing to google for is things related to google
17:17:41 <dmead> dainanaki, hows it going?
17:17:48 <sorear> are you sure colin isn't secretly going to marketroid school?
17:18:38 <stick_figure> I'm having issues doing IO, I want to print something and then do input <- getLine, but I can't get the syntax right.  How do I work that out?
17:18:48 <ndm> marketing for droids?
17:18:48 <ndm> possible - my naming skills are minimal... - someone else named Catch
17:19:13 <dmead> stick_figure, need an example
17:19:19 <weitzman> @paste
17:19:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
17:19:25 <dmead> ^^
17:19:38 <chessguy> @type do { print "hello"; input <- getLine; print input; return ()" }
17:19:40 <lambdabot> lexical error in string/character literal at end of input
17:19:55 <chessguy> @type do { print "hello"; input <- getLine; print input; return () }
17:19:57 <lambdabot> IO ()
17:19:59 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/166
17:20:05 <weitzman> Is that return () considered in good taste?
17:20:10 <stick_figure> so it's clear that I'm doing something wrong there.
17:20:17 <Binkley> I don't consider it in good taste, anyway
17:20:42 <chessguy> weitzman, no
17:20:50 <stick_figure> I'm doing things in an imperative style and running into the whole String / IO String dichotomy.
17:20:52 <dmead> stick_figure, maybe you want the error monad?
17:21:00 <dmead> > error "this is an error"
17:21:01 <lambdabot>  Exception: this is an error
17:21:01 <ndm> sorear, "marketroid"?
17:21:22 <ndm> grr, my IRC is completely reordering my messages...
17:21:22 <dmead> is that like marketspeak?
17:21:32 <dmead> you have lag mate =/
17:21:44 <ndm> and delaying selective ones by up to a minute - sorry if i don't make any sense
17:22:05 <weitzman> Number your messages so everyone can reorder them :)
17:22:27 <dmead> lol
17:24:56 <chessguy> ndm, looks about like normal to me... :)
17:25:50 <stick_figure> Better question: why doesn't this: http://hpaste.org/167 do what I think it does?
17:26:52 <Binkley> stick_figure: what do you think it should do?
17:27:00 <stick_figure> Sorry, that sounds like I anticipate you to read my mind, but why doesn't that snippet print and read in the order I wrote it?
17:27:11 <Binkley> buffering
17:27:12 <weitzman> Does using putStrLn instead make it do what you think it does?
17:27:29 <Binkley> either use putStrLn instead, or
17:27:42 <stick_figure> Actually, yes, that fixes it.  Thanks :)
17:28:06 <Binkley> you can flush the appropriate file handles, but I forget what the Haskell function is for that
17:28:12 <Binkley> putStrLn is probably better anyway in this case
17:36:52 <Procyon112> chessguy: I did a bunch of work this weekend... I am *this close* to abstracting away data representation in typed and untyped terms.
17:37:14 <chessguy> oh? you mean a class Evolvable?
17:37:34 <Procyon112> chessguy: yup... playing with it.. it's real messy right now, but I may have it soon.
17:39:31 <Procyon112> chessguy: I've got my typechecker working on both Data.Tree and a hand-rolled binary tree... I need to factor out the Evolvable class now.
17:40:44 <chessguy> Procyon112, well, if you really want flexibility, your goal should be (at least) to be able to do both a tree-like structure and a list (a la vanilla genetic algorithms)
17:40:52 <Procyon112> chessguy: But this is for GP only.. non-evaluatable GA's, like bitstring encodings aren't going to work with this.
17:41:22 <Procyon112> chessguy: I'm almost thinking this is a "class Evaluateable"
17:42:43 <Procyon112> oh, and my brain melted trying to do a non-deterministic list inside a state monad...
17:42:53 <SimonRC> sigh, can't do any more work on this until root installs FGL
17:42:55 <SimonRC> zzzzzz
17:42:57 <Procyon112> I'm not that smart yet :)
17:43:02 <chessguy> lol
17:44:43 <Procyon112> sorear: Are there any strongly-normalizing type systems beyond System F?
17:45:02 <newsham_> anyone familiar with the TorDNSEL implementation (in haskell)?
17:45:11 <sorear> Procyon112: Absolutely.
17:48:15 <newsham_> http://archives.seul.org/or/talk/May-2007/msg00050.html
17:48:17 <lambdabot> Title: Testing a DNS-based exit node list?
17:48:28 <newsham_> whoever wrote this code knows haskell pretty well
17:49:43 * int80_h hiccups
17:50:39 <ariks> is it safe to upgrade a package with cabal by just doing the configure-build-install all over again?
17:57:53 <Binkley> ?quote
17:57:54 <lambdabot> <kfish> says: in mathematicsland, proofs are made of chocolate!
17:59:54 <newsham_> > 1+2
17:59:58 <lambdabot>  3
18:00:40 <emu> quot erat demonstrad yum
18:01:10 <Excedrin> newsham_: the code is apparently on some hidden service... is there a way to access it without tor?
18:02:13 <newsham_> http://users.lava.net/~newsham/x/tordnsel.tar.gz
18:02:28 <Excedrin> thanks
18:02:37 <newsham_> np.
18:02:39 <newsham_> ?seen dons
18:02:39 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 5m 51s ago.
18:06:09 <Excedrin> /c/c
18:06:11 <Excedrin> doh
18:09:01 <newsham_> does lennart kolmodin irc?
18:09:53 <SamB_XP> perhaps you are looking for kolmodin?
18:09:58 <SamB_XP> it seems that you are.
18:10:57 <newsham_> ?seen kolmodin
18:10:57 <lambdabot> kolmodin is in #xmonad, #haskell, #gentoo-haskell and #darcs. I last heard kolmodin speak 5h 17m 19s ago.
18:15:08 <stick_figure> Is there a Haskell equivalent of OcaML's List.iter for Monads?  I could write the recursive code, but I'd like to compact to just be iterating over a list constructed with the dot dot notation.
18:15:39 <newsham_> not sure List.iter.  like forM_ ?
18:15:47 <newsham_> ?hoogle forM_
18:15:47 <lambdabot> No matches found
18:15:50 <newsham_> ?type forM_
18:15:52 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
18:15:55 <stick_figure> sounds right.
18:17:10 <newsham_> forM_ "abcdef" (\ch -> putStrLn [ch])
18:17:45 <newsham_> prints the chars each on their own line
18:19:37 <newsham_> which means even if this code is correct, there could be more bugs like that in the package their using
18:19:51 <newsham_> oops, wrong channel
18:23:25 <stick_figure> How does one catch a Data.Map lookup failure?
18:24:04 <ddarius> :t Data.Map.lookup
18:24:06 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
18:24:18 <ddarius> @oldwiki NotJustMaybe
18:24:18 <lambdabot> http://www.haskell.org/hawiki/NotJustMaybe
18:26:33 * ddarius hacks his xmonad configuration again.
20:30:40 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
20:30:40 --- topic: set by dons on [Sun May 27 19:49:12 2007]
20:42:03 <dmwit> My regular expression simplifier is insufficient. =(
20:42:07 * dmwit goes googling
20:42:09 <ekidd> bd_: Thanks. I'll think about that!
20:43:39 <dmwit> Oh, hey!
20:43:48 <dmwit> ndm: ping
21:00:31 <sorear> dmwit: nil
21:00:54 <sorear> dmwit: you came at york midnight, more or less
21:01:01 <dmwit> Yeah, I figured.
21:01:07 <dmwit> (Since he wasn't on.)
21:01:09 <ddarius> dmwit: []
21:01:32 <dmead> hay guys
21:01:41 <sorear> hello dmead!!
21:01:50 <dmead> sup sup
21:01:52 <dmead> i'm wondering
21:02:01 <dmead> is there an FP toolkit for c++ or some junk
21:02:08 <ddarius> > ("dmead"!!)
21:02:10 <dmead> that'll let you simulate pattern matching and whatnot
21:02:10 <dibblego> is there a name for all 16 possible function outcomes of two boolean arguments?
21:02:22 <ddarius> dmead: Yes
21:02:24 <dmead> 16 you say?
21:02:32 <dibblego> of course, 2^4
21:02:39 <ddarius> Er for some of what you want
21:02:45 <dmead> 2^2
21:02:53 <dibblego> no, 2^4
21:03:01 <dmead> mmmmm
21:03:03 <ddarius> 2x2->2
21:03:14 <dmead> o0
21:03:23 <ddarius> (Bool,Bool) -> Bool
21:03:33 <dmead> if you have two booleans
21:03:37 <dmead> theres only 4 combinations
21:03:44 <dmead> in truth table terms
21:03:53 <ddarius> dmead: A -binary- Boolean -function-
21:03:58 <int80_h_> ControlMonad doesn't export forM in ghc 6.4.2. how would I be able to find where forM lives?
21:04:03 <dmead> ah.
21:04:06 <dmead> anyways
21:04:06 <dmead> yea
21:04:09 <dibblego> I can list 7 outcomes anyway; conjunction, exclusive disjunction, disjunction, negation of disjunction, biconditional/equality, implication, negation of conjunection
21:04:11 <dmead> ddarius, whats it called?
21:04:20 <dibblego> I'm wondering if the other 9 have names
21:04:33 <int80_h_> I mean, Control.Monad
21:04:37 <Korollary> you listed disjunction twice
21:04:41 <ddarius> There's Functional C++ I think it's called and some boost stuff
21:04:50 <dmead> ahh
21:04:51 <dmead> coo coo
21:04:51 <dibblego> Korollary, I don't see it
21:04:56 <Korollary> argh
21:05:00 <Korollary> exclusive disjuction
21:05:07 <dmead> oh
21:05:07 <ddarius> dibblego: Look at Common Lisp's library
21:05:10 <Korollary> it wrapped on my terminal
21:05:14 <ddarius> @google Hyperspec
21:05:26 <ddarius> Oh yeah.
21:05:32 <dibblego> ddarius, ok cheers
21:05:51 <int80_h_> hi hi :)
21:05:56 <dmead> dibblego, they all do
21:06:01 <dmead> but some of them aren't ever used
21:06:06 <int80_h_> how can I find where forM lives?
21:06:13 <dibblego> dmead, do you know those names?
21:06:19 <dmead> i know a few
21:06:23 <dmead> of the weird ones
21:06:26 <int80_h_> it seems not be to be exported by Control.Monad in ghc 6.4.2
21:06:33 <dmead> i had to use it for my theorem prover to do simplification
21:06:37 <dibblego> dmead, besides the 7 I listed?
21:06:40 <dmead> yea
21:06:44 <dmead> theres absolution
21:06:52 <dmead> or is it abduction
21:06:53 <dmead> i forget
21:07:02 <bd_> left identity and right identity, const true, const false...
21:07:08 <dibblego> absolution would be t, t, t, t I expect
21:07:12 <bd_> i don't know if those are commonly used terms
21:07:29 <dmead> absolution is...
21:07:46 <dibblego> perhaps I will write all 16 functions in Haskell and leave the unknown ones unnamed
21:08:01 <Korollary> Some of them are cursed and must not be named.
21:08:17 <ddarius> http://www.lisp.org/HyperSpec/Body/fun_boole.html#boole
21:08:29 <dmead> a V (a & c) = a
21:08:41 <dmead> is absolution
21:08:50 <int80_h> test
21:08:50 <dibblego> thanks
21:09:01 <ddarius> absolution?
21:09:02 <dmead> lets you eliminate the conjunct if one of them is equal to the  remaining disjunct term
21:09:32 <dmead> a V (b & c) = a when a == b or a == c
21:09:45 <dibblego> dmead, that's not a two-argument boolean function
21:09:47 <dmead> but thats not an atomic function
21:09:54 <dmead> yea =/
21:10:20 <dmead> maybe they don't all have names when you add the HOT
21:10:45 <dibblego> I'm going to write it in Haskell
21:10:56 <dibblego> I can't quite make sense of that Lisp page
21:11:00 <ddarius> Well some have names like constantly true
21:11:09 <dmead> what exactly are you trying to write?
21:11:21 <dibblego> Scala :)
21:11:34 <dmead> i mean
21:11:37 <dmead> whats your program do :P
21:11:48 <dibblego> something similar to QuickCheck
21:11:52 <dmead> ah
21:12:01 <dibblego> because ScalaCheck is broken
21:12:02 <ddarius> Anyways dibblego, your list is most significantly missing trivial cases
21:12:06 <dibblego> and it's annoying the hell outta me
21:12:21 <ddarius> i.e. const True, const False, first not, second not
21:12:37 <dibblego> ddarius, are they names used in logic?
21:12:52 <dmead> hold on dibblego i'll bust out a logic book
21:12:58 <dibblego> I'll write Haskell
21:13:08 <ddarius> I don't know if they really are named.  Certainly, not normally.
21:15:05 <dibblego> ?type Bool -> Bool
21:15:45 <Korollary> huh
21:16:38 <bos> @hoogle sized
21:16:55 <dmead> dibblego, you know theres alot more than just binary operations right?
21:17:09 <dibblego> dmead, of course
21:17:13 <bos> @yow
21:17:22 <bos> hm, lambdabot ist verklempt
21:17:22 <ddarius> No bot apparenty
21:17:24 <ed1t> @pow
21:17:28 <ed1t> heh
21:17:45 <dmead> hmm
21:17:54 <shoffsta> who maintains lambdabot these days?
21:17:56 <dmead> lets just figure it out
21:17:58 <pchiusano> hello
21:18:01 <dmead> and or not
21:18:03 * ed1t points at dons
21:18:08 <dmead> nand nor xor
21:18:10 <dmead> thats 6
21:18:18 <dibblego> dmead, not isn't one of them
21:18:21 <Jaggederest> if only we could debug lambdabot via IRC
21:18:26 <dibblego> dmead, I have listed all those already
21:18:35 <dmead> wheres your list again?
21:18:57 <dibblego> I can list 7 outcomes anyway; conjunction, exclusive disjunction, disjunction, negation of disjunction, biconditional/equality, implication, negation of conjunection
21:19:35 <ddarius> dibblego: I listed four more that are not included in that list.
21:19:36 <pchiusano> is there an isUppercasee function?
21:19:43 <ddarius> isUpper
21:19:51 <pchiusano> > isUpper 'a'
21:19:57 <ddarius> :: Char -> Char, use map if you want String -> String
21:19:57 <dmead> just say equivalence instead of biconditional
21:19:59 <dibblego> ddarius, yes, Haskell functions
21:20:23 <pchiusano> hum, what is with lambdabot?
21:20:27 <pchiusano> > 2 + 2
21:20:31 <ddarius> dmead: And inequality instead of exclusive disjunction
21:20:40 <dmead> ja
21:20:55 <pchiusano> :t 2
21:21:14 <pchiusano> hum, is lambdabot ill?
21:21:15 <dmead> in operator terms
21:21:16 <dmead> you have
21:21:38 <dmead> and xor or nor = -> nand
21:21:53 <dmead> thats it really
21:22:07 <dmead> you only actually need nand and nor or something
21:22:12 <dmead> to handle everything
21:22:25 <ddarius> You only nand (or equivalent nor)
21:22:38 <dmead> ah right
21:22:44 <ddarius> The Sheffer Stroke has applications to CS
21:22:49 <ddarius> Beyond the obvious ones
21:22:56 <dmead> sheffer stroke?
21:22:56 <dibblego> I was reading about that earlier
21:23:06 <whaleofconfusion> no I don't know why
21:23:27 <ddarius> http://en.wikipedia.org/wiki/Sheffer_stroke
21:24:21 <RyanT5001> is there a debian package for the haskell package binary
21:24:30 <RyanT5001> haskell package "binary"
21:24:32 <dmead> aha right
21:24:47 <bd_> libghc6-binary-dev I think
21:25:00 <sorear> @botsnack
21:25:01 <dmead> dibblego, usually when you want to do a prover type of thing
21:25:08 <sorear> @quit
21:25:10 <dmead> you make a normal form converted and work from there
21:25:19 <dmead> *converter
21:25:29 <whaleofconfusion> I, original kite bringer
21:25:36 <dmead> ie you don't need to handle all operations
21:25:52 <dmead> just take your input function and convert it to a normal form with one or two operators
21:25:55 <dmead> or three
21:27:09 <RyanT5001> ah, it's in unstable
21:27:15 <RyanT5001> as a rule, i don't mess with unstable packages :P
21:27:34 <RyanT5001> (setting pins and crap in apt is too much trouble when i can just darcs it)
21:27:37 <dmead> > "poops
21:30:26 <hpaste>  dibblego pasted "Logic" at http://hpaste.org/173
21:31:06 <shoffsta> I started blogging...
21:31:14 <shoffsta> and my first post is about Haskell!
21:31:21 <dmead> o rly?
21:31:26 <shoffsta> http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/
21:31:32 <shoffsta> ya rly :)
21:31:48 <shoffsta> And since we don't have a living lambdabot, the title is:
21:32:00 <dancor> i have /usr/include/SDL/SDL.h but SDL-0.4.0 can't find it.  what do i do
21:32:02 <shoffsta> Scientific.Dimension: Type Arithmetic and Physical Units in Haskell
21:32:17 <c_> in glorious proper capitlization!
21:32:25 <shoffsta> hehe
21:32:32 * c_ bookmarked, will read when head has a bit more room
21:32:38 <vagif> hello. Problem with hdbc-odbc. After installing latest version gives error on load: Failed to load interface for 'Database.HDBC.ODBC.ConnectionImpl'
21:32:47 <ddarius> Conkeror doesn't like Ajax
21:32:52 <shoffsta> c_: nice
21:33:02 <vagif> i had previous version 1.0.1 that worked fine
21:33:03 <shoffsta> I hope it will be of interest :)
21:33:42 <dmead> dibblego, http://taz.cs.wcupa.edu/~dmead/code/darcsweb/darcsweb.cgi?r=First%20order%20logic;a=headblob;f=/CNF.hs
21:34:07 <ddarius> shoffsta: Perhaps this soon will be the shirt for you: http://dirtymicrobe.com/products/your-crappy-blog/
21:34:22 <dibblego> why am I looking at this?
21:34:44 <dmead> because you don't need to handle all those cases
21:35:32 <dibblego> how do you know that?
21:35:49 <dibblego> why do you think I am even handling them? I merely want names
21:36:00 <dmead> because i've been doing this for the last year
21:36:06 <dmead> just trying to help :P
21:36:26 <dibblego> enthusiasm :)
21:36:28 <shoffsta> ddarius: heh... hopefully that'll change?
21:36:52 <ddarius> No comment.
21:36:59 <shoffsta> alright
21:37:11 <dmead> lol
21:37:21 <dmead> *order*
21:37:26 <syntaxfree> nonhaskell rant about to start in #haskell-blah in 60 seconds.
21:37:38 <dmead> gogoogog
21:37:53 <vagif> Hello, anyone using hdbc ?
21:38:16 <shoffsta> vagif: I have
21:38:28 <vagif> are you using latest version ?
21:38:57 <shoffsta> vagif: the last time I used it was about two months ago...
21:39:23 <vagif> yes, i used it before too. It was working ok
21:39:31 <vagif> but today i downloaded latest version
21:39:36 <vagif> and now it gives me error
21:39:40 <vagif>  Problem with hdbc-odbc. After installing latest version gives error on load: Failed to load interface for 'Database.HDBC.ODBC.ConnectionImpl'
21:39:40 <vagif> [21:32] ddarius: Conkeror doesn't like Ajax
21:40:06 <vagif> i'll switch to previous version probably
21:40:39 <shoffsta> alright... but make sure to tell the authors about the error
21:40:42 <ddarius> It doesn't hate it and it may also be the fact that I'm using xmonad as well.
21:42:07 <whaleofconfusion> hmm
21:48:53 <dancor> oh right export CPATH did the trick
21:53:10 <shoffsta> I just submitted my post to reddit: http://programming.reddit.com/info/1vzog/comments
21:53:24 <shoffsta> so vote it up, if you like it..
21:56:51 <jfredett> ...
21:56:55 <ioerror> I'm building a package with cabal and I can't seem to find a simple way to have it handle non .hs files that are required for the programs operation upon install (eg: /etc/myprog.conf and /etc/init.d/myprog). Am I missing something totally obvious?
21:58:13 <jfredett> okay- so I'm trying to install the unix-2.0 hackage package, and it doesn't come with instructions... :/
21:58:22 <jfredett> just a Setup.hs file
21:58:22 <sorear> yeah, cabal is not designed to handle things like that
21:58:51 <sorear> jfredett: We don't include instructions in each package because they are all installed in the same way.
21:58:58 <dmwit> jfredett: runhaskell Setup.hs configure
21:58:59 <sorear> Unless you see a README file
21:59:05 <sorear> runhaskell Setup.hs configure
21:59:07 <dmwit> then s/configure/build/ and s/configure/install/
21:59:11 <jfredett> Damnit! i put the configure on the wrong side
21:59:20 <jfredett> i'm a moron.
21:59:32 <dons> C is silly, having /= as a side effecting operator ;)
21:59:37 <jfredett> thanks guys
21:59:59 <ulfdoz> dons: Only for that reason? ;)
22:00:01 <sorear> dons: Worse yet, it has an asymetric type!
22:00:15 <sorear> the left argument has to be an lvalue.  what gives?
22:00:48 <jfredett> ahhh! asymmetry!
22:00:51 <dons> bizarre.
22:01:06 <dons> didn't those guys know about types?
22:01:24 <jfredett> ... Cabal is the most wonderful thing ever
22:01:26 <Korollary> They cared about other things, didn't know better, whatever.
22:01:35 * jfredett twitches
22:01:40 <jfredett> the packages just work--
22:01:44 <ddarius> jfredett: Not yet
22:01:44 <jfredett> it just-- installed
22:01:55 <jfredett> i didn't have to hack around it
22:01:59 <Korollary> I don't know how to install under /etc with cabal.
22:02:00 <ioerror> sorear, Is there a standard way to deal with that? It seems reasonable that if I am going to have cabal install my binary, it should be able to install something that isn't a binary as well, even if it isn't marked as a configuration file
22:02:12 <ddarius> Though I admit I was pleased by it when installing xmonad and its dependencies.
22:02:41 <jfredett> i think i might cry, thats the first time I've ever configured, built, and installed something without going through dependency hell
22:02:43 <jfredett> ...
22:02:55 <sorear> work++ just++
22:02:59 <dcoutts> dons: re: the bug nad found, can't look atm as I'm off to the US for 3 weeks :-)
22:03:08 <dons> dcoutts: righto
22:03:10 <jfredett> damnit- sorry sorear
22:03:11 <dons> dcoutts: you'll be offline?
22:03:11 <sorear> ioerror: autoconf and/or dpkg
22:03:21 <dons> dcoutts: i intend to give it to lennart anyway
22:03:27 <sorear> dcoutts can say more about why you want to avoid this :)
22:03:28 <dcoutts> dons: partly and mostly
22:04:07 <ioerror> sorear, I was thinking about using the make interface as that would allow for such flexibility but I figured this was just a dirty hack, not STOP
22:05:07 <sorear> ioerror: You want to use the OS's package manager if you install ANYTHING outside of /usr/local or /home
22:05:24 <sorear> ioerror: to do otherwise is impossible to be safe
22:06:26 <ioerror> I realize that, however, if my prefix is set to /usr/local/, it seems reasonable to not have to have dpkg involved for a build and install
22:07:05 <sorear> ioerror: Er, both of the paths you gave were ouside of /usr/local
22:11:55 <ioerror> You're right, I suck. Let me rephrase the question then. Were I to set prefix to be /usr/local/, is there a way to have cabal manage files other than binaries, such as config files or non haskell scripts?
22:11:55 <ioerror> It seems like the most simple answer might be to use Distribution.Make
22:18:29 <dmwit> > nubBy ((>1).gcd) [2..10]
22:18:41 <ddarius> No bot
22:19:11 <mauke> @bot
22:24:20 <notsmack> @botsnack
22:27:56 <sorear> notsmack: if it responds to anything it will be the @quit I sent an hour ago :)
22:28:02 <sorear> dons: @donssnack
22:31:46 <dons> network timeout
22:32:38 <ivanm> thanks dons!
22:33:35 <bos> hmm, that's interesting. i think System.FilePath is buggy on Macs.
22:34:02 <Korollary> @version
22:34:02 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
22:34:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
22:34:15 <Korollary> The bot hath returned.
22:36:33 <dmwit> Huh, check this:
22:36:34 <dmwit> ?seen ndm
22:36:35 <lambdabot> Last time I saw ndm was when I left #darcs, #dreamlinux-es, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #perl6, #scannedinavian, #
22:36:35 <lambdabot> unicycling and #xmonad 19d 6h 4m 13s ago, and .
22:36:38 <dmwit> 19 days!
22:36:55 <Korollary> its state is stale.
22:37:08 <dmwit> oh, right
22:37:26 <kolmodin> lambdabot left #kedja @ quakenet :/
22:37:33 <kolmodin> will she return?
22:37:41 <sorear> @help irc-connect
22:37:41 <lambdabot> irc-connect tag host portnum nickname userinfo.  connect to an irc server
22:38:01 <kolmodin> hmm
22:38:01 <sorear> @irc-connect quakenet irc.quakenet.net 6667 lambdabot LambdaBot
22:38:02 <lambdabot> Plugin `irc' failed with: IRCRaised getHostByName: does not exist (no such host entry)
22:38:08 <sorear> kolmodin: ?
22:38:24 <kolmodin> @irc-connect quakenet stockholm.se.quakenet.org 6667 lambdabot LambdaBot
22:38:24 <lambdabot> Not enough privileges
22:38:34 <sorear> @irc-connect quakenet stockholm.se.quakenet.org 6667 lambdabot LambdaBot
22:38:42 <sorear> @join quakenet:#kedja
22:38:54 <sorear> kolmodin: ?
22:39:02 <kolmodin> nope
22:39:25 <sorear> @listservers
22:39:26 <lambdabot> freenode quakenet
22:39:32 <sorear> @seen quakenet:#kedja
22:39:57 <kolmodin> I've got to prepare for work, brb
22:41:22 <dcoutts> bye folks!
22:42:13 <sorear> @join quakenet:#kedja
22:44:55 <dancor> i've just installed alex-2.0.1-r1 (portage stable) but when i try to build yi-vty-0.2 from hackage: Setup.hs: Yi/Syntax/Haskell.x: no alex preprocessor available
22:45:21 <dancor> i guess 2.0.1-r1 isn't recent enough?
22:45:50 <dancor> it's odd bc it's not listed as an explicit dependency
22:46:00 <sorear> dons: ping
22:46:19 <dons> pong
22:46:28 <sorear> dons: kill and restart the quakenet instance of lambdabot, kolmodin was just complaining
22:46:45 <mauke> haha, oh wow: substr(0.5,1)
22:46:45 <dons> ah i see.
22:47:07 <mauke> haskell did something to my brain. now code like that makes me wince.
22:47:41 <dons> kolmodin: fixed?
22:47:51 <dons> looks like it, V\228lkommen
22:47:52 <kolmodin> ah, now she's there!
22:47:53 <dolio> mauke: What does that do?
22:48:07 <dons> for some reason lambdabot doesn't like autojoining the quakenet channels
22:48:08 <kolmodin> sorear, dons: thanks a lot!
22:48:29 <mauke> dolio: converts 0.5 to a string, yielding "0.5", then gets the substring at offset 1, yielding ".5"
22:48:32 <LeCamarade> mauke: You think you're damaged? Me, I no longer write loops. Nobody tells you Haskell's dangers.
22:48:43 <dolio> mauke: Oh, of course.
22:48:49 <dolio> :)
22:49:35 <dancor> oh duh needed to reconfigure probably
22:52:08 <kolmodin> sorear: the topic is of a small party I'll have tonight, you're invited :D
22:52:27 <Korollary> sorear is grounded
23:02:42 <brainly-green> if unlambda provided some means of user-altering the ` character (the eval function), it would be a minimalist, yet potentially very powerful language
23:16:23 <dancor> i can't seem to find anything on syntax highlighting in Yi
23:16:43 <dancor> except for indirect implications that it exists
23:17:19 <dancor> yi-vty specifically
23:17:22 <Korollary> I thought the gtk version did it
23:17:26 <dancor> oh
23:17:49 <jbauman> http://www.linux.ie/articles/tutorials/vi3.php ?
23:17:51 <lambdabot> Title: Linux.ie :: vi Tutorial 3 (PDA Version)
23:19:26 <kolmodin> dons: btw, the binary homepage has been in need of small updates for a while
23:19:51 <kolmodin> dons: perhaps we could host it on haskell.org so it'd be easier for any of us to update?
23:20:00 <dancor> jbauman: are you saying that normal .vim files work?  that doesn't seem like it could be true with their ugly if endif constructs
23:20:12 <dons> kolmodin: yes, i think that would be a good idea, kolmodin
23:20:37 <kolmodin> good , I might look into that some day :)
23:20:45 <kolmodin> I'm about to go to work any minute..
23:20:53 <kolmodin> we're going to look at our new rooms, we're moving!
23:21:16 <dons> cool. to a nice new place?
23:21:38 <kolmodin> yeah, would that be ok with you?
23:21:44 <kolmodin> er...
23:21:51 <kolmodin> mixing of topics :D
23:21:59 <kolmodin> yes, we're moving to a new place :D
23:22:10 <kolmodin> and neither you nor I have any say in it :D
23:22:49 <kolmodin> dons: about the 'when'-issue in binary, I find it odd
23:22:54 <kolmodin> and unexpected
23:23:05 <dons> well, it makes sense, thought, right?
23:23:09 <kolmodin> yes :D
23:23:15 <dons> when b f >>= \_ -> ...
23:23:18 <dons> lazy haskell at play
23:23:21 <kolmodin> yeah
23:23:32 <kolmodin> I didn't think lazyness would bite in that way :)
23:23:46 <kolmodin> but sure, it makes sense
23:23:57 <kolmodin> good to know for future code review
23:24:08 <dons> we could modify the semantics of bind, to make it stricter, but i'm not sure what other effect that would have
23:24:53 <kolmodin> hmm..
23:26:39 <mjk> mauke: like this
23:26:48 <mjk> mauke: substr :: String -> Int -> Int -> String
23:26:54 <mjk> mauke: substr [] _ _ = []
23:27:05 <mjk> mauke: substr (x:xs) a b
23:27:15 <mjk> mauke: 	| a < 0													= []
23:27:23 <mjk> mauke: | b < 0													= []
23:27:29 <mjk> mauke: | b == 0												= []
23:27:35 <mjk> mauke: | a == 0 && b >= length (x:xs)	= x:xs
23:27:42 <mjk> mauke: | a > 0 && b > 0								= substr xs (a-1) b
23:27:49 <mjk> mauke: | otherwise											= x : substr xs a (b-1)	
23:28:28 <mjk> substr "0.5" 1 2
23:28:39 <mjk> result is ".5"
23:32:36 <Botje> mjk: please don't paste in the channel. use hpaste for that
23:34:01 <dancor> do you guys use yi or usually something else
23:36:36 <ivanm> dancor: emacs for teh win! ;-)
23:36:53 * ivanm pronounces the editor wars re-opened! :p
23:37:09 <thoughtpolice> emacs for life, yo.
23:39:05 <ivanm> "yo"?
23:39:22 <c_> yalla
23:41:09 <Korollary> yi is not full featured enough for me to stop using emacs yet
23:44:34 <mjk> Botje: sorry
23:45:42 <Botje> mjk: it's okay, but try to keep it in mind.
23:45:50 <Botje> mjk: did you have a question regarding that code?
23:46:39 <mjk> Botje: no, i write codes about substr
23:47:02 <Botje> I saw that :)
23:47:29 <Botje> you know you could have written that as a combination of drop and take, right?
23:47:33 <mjk> to mauke
23:48:09 <mjk> oh, i see
23:48:34 <mjk> drop 1 "0.5"
23:48:55 <Botje> > take 2 $ drop 1 "0.5"
23:48:57 <lambdabot>  ".5"
23:49:04 <Botje> (the > is important)
23:49:18 <aleator> Interesting.. If I change euler method into runge-kutta4 my code stops printing stuff to console, but still works.. Haskell is funny :)
23:49:45 <mjk> it's very clear
23:50:18 <Cale> aleator: Perhaps runge-kutta4 can't return part of the result lazily?
23:50:37 * Botje is working through TAOCP1
23:50:44 <Cale> (I'm not sure exactly what "stops printing to the console" means in this case)
23:51:04 * Botje should probably study for his exams, though
23:52:28 <aleator> Cale: Could be. Though I would expect it then to splurt out the results after end of computation though.. (Ie. it works as if putStrLn just stopped working)
23:52:38 <Cale> oh
23:52:45 <Cale> then how does your program still work?
23:53:13 <aleator> Well, it outputs to file(s) as usual.
23:53:28 <Cale> huh
23:53:50 <Cale> If you want to hpaste it, I'll have a look and see if I can see what's happening.
23:54:48 <aleator> Well. It is not really a problem yet, and it is rather large, but I'll put it up if you like.
23:56:16 <aleator> Ach.. Won't actually. Too much code :/. Lets see I can do a test case..
