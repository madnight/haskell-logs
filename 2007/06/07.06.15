00:02:39 <ClaudiusMaximus> Mr_Awesome: you need a single entry point, otherwise things will break; your entry point can be: foo :: IO(S->T->IO(), S->T->IO()) ; foo = do r <- newIORef []; return (f r, g r)  and elsewhere have f, g::IORef -> S -> T -> IO () ; an alternative is to put everything into nested where clauses, but that still requires a single entry point  (i had similar problems in the past, luckily the API i was working with provided a single entry
00:03:39 <Mr_Awesome> i see, that makes sense
00:04:11 <Mr_Awesome> a where claues is rather convenient here
00:14:19 <Mr_Awesome> wow, everything makes sense now
00:14:27 <Mr_Awesome> i just have to change my way of thinking
00:14:37 <Mr_Awesome> thanks ClaudiusMaximus :)
00:14:42 <ClaudiusMaximus> :)
00:15:21 <ClaudiusMaximus> when i asked about global mutable state, sorear rather cruelly pointed me to unsafePerformIO, which lead to much tearing of hair and gnashing of teeth :)
00:15:57 <ClaudiusMaximus> i was probably using it wrong, though
00:17:09 <LeCamarade> If I'm allowed to ask, would it still be sane if I recompiled thunks on the fly? In a hypothetical language, of course.
00:17:11 <Mr_Awesome> well, glut seems to make use of global mutable state, but it seems easier to me to just not use it
00:20:45 <quicksilver> LeCamarade: well if you are, for example, just-in-time optimising them, then that sounds quite sensible to me
00:21:09 <quicksilver> LeCamarade: if you're changing their semantics then your hypothetical language has a rather strange emnatic tructure, I think
00:23:24 <Baughn> LeCamarade: Runtime partial evaluation can give a truly enormous performance boost. I think someone wrote a kernel based on that once..
00:26:32 <LeCamarade> Baughn: Dr. Massalin. I'm thinking along those lines.
00:27:09 <LeCamarade> The performance shot of compiling can be offset (greatly) if the code will run many times, and if optimisation chances are improved.
00:27:34 <Baughn> LeCamarade: Yes, especially if you specialize the compilation process
00:28:00 <LeCamarade> The best thing about the thunks is that you can actually inspect them for an evaluation of how good the performance boost will be.
00:28:06 <LeCamarade> http://tratt.net/laurie/tech_articles/articles/why_dont_we_use_functional_programming_languages_more
00:28:07 <Baughn> LeCamarade: A lot of it devolves to "fill in the pointer values"
00:28:08 <lambdabot> Title: Laurence Tratt: Why Don't We Use Functional Programming Languages More?, http://tinyurl.com/2n8cra
00:28:13 <LeCamarade> ^^ Horrible.
00:29:14 <LeCamarade> Some people tend to look at lazy eval as a feature that comes with a cost. Nobody looks at slow networks the same way. It's unfair.
00:30:13 <Baughn> So, how /do/ I get a backtrace? Or, I suppose, avoid needing one?
00:30:41 <LeCamarade> Me, I choose lazy evaluation as my default eval strategy, and any problems it causes are to be considered as normal as, say, a limit on disk space.
00:32:44 <LeCamarade> Baughn: I don't agree with exceptions a lot. They cause the need for a backtrace. What happened to error values? :o(
00:33:41 <LeCamarade> That is not a sweeping statement - I just want to say I prefer error values to exceptions. Instead of head return x or throwing an exception, it should return a Just x or a Nothing.
00:33:43 <pejo> LeCamarade, most people build fast networks though, they don't build slow ones.
00:33:45 <Baughn> LeCamarade: I read a nic paper about that once, but the (predictable) conclusion was that both are handy at different times
00:34:37 <LeCamarade> Baughn: With syntactic support, you can totally replace exceptions with Maybe a'. I think.
00:34:40 <Baughn> In haskell, of course, exceptions aren't nearly as useful as elsewhere - you can't catch them outside IO
00:35:22 <pejo> Baughn, is there any pure language where you can catch exceptions in a non-monadic context?
00:36:01 <LeCamarade> pejo: I don't even know of another language with a monadic context ... :o)
00:36:15 * LeCamarade is no PL researcher, though ... :o)
00:36:18 <pejo> LeCamarade, Helium?
00:36:26 <Baughn> pejo: Not to my knowledge, no. I've tried to design one, without success.
00:36:49 <LeCamarade> pejo: Helium is Haskell without scales (phonetic pun intended).
00:37:30 <Baughn> pejo: Mostly, the Maybe monad is sufficient, but then there are functions such as head..
00:37:48 <LeCamarade> Baughn: head should return Maybe a'
00:37:55 <Baughn> I'm getting tempted to redefine the language to make it do just that
00:39:00 <ttfh> I wonder about "head" for example, is there som good reason it doesn't use Maybe?
00:39:00 <LeCamarade> Baughn: I have a very sexy language in my head (the brain store, as in), and it has absolutely no concept of exceptions, but support for Maybe a' is in-built just like suppoprt for Bool is in-built in Haskell.
00:39:14 <Baughn> ttfh: Too cumbersome?
00:39:40 <sphynx> I have the project and Cabal used for build and installation. Another thing I want to do is profiling and actuall running of software (testing too, but a bit later). Is there some ways to embed running and profiling in Cabal?
00:39:49 <LeCamarade> ttfh: Because the ML-family's handling of patterns makes it a pain to deal with a Maybe everywhere you need to use head.
00:40:13 <Baughn> ttfh: You could define head' = fromJust head, though
00:40:31 <sphynx> So I can type "./Setup.lhs profile" and then it is build with -prof option, run with +RTS -i -RTS and`less programname.prof` then
00:40:33 <ttfh> but with the do notation, Maybe becomes really nice to deal with
00:40:46 <Baughn> But having to say foo <- head bar every time I want to use head, that's.. just annoying.
00:41:01 <Baughn> ttfh: Do-notation doesn't help you use it inside expressions
00:41:04 <Baughn> Arguably it should
00:41:43 <LeCamarade> Baughn: So my language, while inspired of Haskell and pure, it has glorified Maybes (even more-glorified than Bools) and there is a syntactic equivalent for unsafePerformIO, which is basically a keyword to remove the impurity splotch.
00:42:11 <dons> sounds dangerous.
00:42:16 <ttfh> i guess it's a tradeoff, using Maybe would force you to think about it all the time
00:42:22 <Baughn> LeCamarade: What happened to laziness?
00:42:47 <xpika_> setup.hs: cannot satisfy dependency directory-any
00:42:53 <LeCamarade> Baughn: I just campaigned for laziness a few minutes ago! :o)
00:43:04 <xpika_> does anyone know what that means?
00:43:25 <LeCamarade> dons: Unfortunately, I am not too convinced of the necessity of too much purity, since this is a bare-metal language.
00:43:31 <Baughn> LeCamarade: Mentioning unsafePerformIO like that suggests that your language is strict - otherwise it couldn't possibly need a syntax element
00:43:33 <xpika_> directory any?
00:43:43 <ttfh> but f.ex if you have "fun [] -> ...; fun x -> {code}" you can safely use head on x in {code}
00:43:55 <dons> LeCamarade: its dangerous in the sense you can't optimise safely if you're abritrarily coercing side effects.
00:44:15 <sphynx> so any ideas with cabal and profiling?
00:44:21 <dons> you'd have to be very pesimissitc about optimising, if such casts would be common
00:44:22 <LeCamarade> There is an intimate need for impurity, so performing will have to be easy, almost encouraged. Sorry for not having learnt this particular lesson well. ;o)
00:44:24 <dons> sphynx: -p
00:44:33 <pejo> LeCamarade, you want laziness, but you reject purity - due to it being a bare-metal language?
00:44:35 <Baughn> Skipping back to what I'm actually /worried/ about - how do I figure out which bit of a ten-thousand-line program is causing an exception?
00:44:51 <Baughn> I haven't seen a backtrace yet, and now I see someone claiming they don't exist
00:44:56 <sphynx> dons: Yeah, I've mistaken with -i, sorry
00:45:02 <LeCamarade> dons: Anyway, it is still on paper, and that may change.
00:46:06 <LeCamarade> pejo: I want laziness because it enables to pull even more performance out of recompiling the thunks judiciously. And laziness is just too blerry sweet for me to live without, so I just have to coerce it in even when it fights and kicks to escape.
00:46:14 <dons> check out work on 'effect inference' for other approaches to making it easier to switch between effectful and pure code
00:46:31 <dons> there's some very hard thinking that has to be done, for the language to not fall apart
00:46:41 <LeCamarade> dons: @where?
00:47:07 <dons> hey, you're writing a language: you're expected to read, and find, papers! :P
00:47:58 <LeCamarade> dons: Yeah. :o) I spend the days weeding through the SPJ archive and planning to kidnap you and some other guys and make you talk.
00:48:22 <dons> if you want to try this out, check http://cs.anu.edu.au/people/Ben.Lippmeier/ this guy's work
00:48:23 <lambdabot> Title: Ben Lippmeier
00:48:37 <dons> he's been working for a while now on inferring the impure fragments
00:48:48 <xpika_> can anyone else here compile filepath?
00:48:48 <dons> and tagging when they're safe to play with. very hard!
00:49:00 <dons> so providing syntactic support for unsafePerformIO is not to be taken lightly
00:49:42 <pejo> dons, I guess he is searching for a safe approximation? Sounds very halting problemish to me.
00:52:00 <ttfh> http://www.haskell.org/haskellwiki/Non-empty_list
00:52:01 <lambdabot> Title: Non-empty list - HaskellWiki
00:52:10 <LeCamarade> My strategy (still foggy) is that, since unsafePerformIO (and equivs) will be syntactic, the compiler will be able to know what a perform is happening. And, besides, this is not a language for everyone. Just me, and I'll know what's going on. :o) I want to be doing bare-metal in pure-functional with the option of breaking into low-level at will.
00:52:16 <ttfh> interesting
00:53:04 <bens> xpika_: try downloading the directory package from http://darcs.haskell.org/packages/directory and installing that first.
00:53:07 <lambdabot> Title: Index of /packages/directory
00:55:17 <bens> xpika_: I'm not sure how well it will work outside of the ghc darcs head though.
00:56:35 <xpika_> bens: thanks
00:59:00 <bens> no worries
00:59:42 <xpika_> bens: do you think ill need ghc 6.1.1?
01:02:38 <xpika_> ive compiled and installed Filepath and can even import it in ghci but setup.hs gives me an error cannot satisfy dependancy filepath
01:04:48 <yakov> morning
01:06:04 <xpika_> yakov: hi
01:11:21 <bens> xpika_: I guess you're writing a .cabal file. Try adding filepath to the build-depends field.
01:11:50 <xpika_> bens: nope im using a setup.hs
01:11:52 <Vq^> morning yakov
01:12:31 <xpika_> does anyone think here that compiling a haskell program is like jumping on the source code gravy train?
01:13:56 <bens> it'd be best to read the cabal user's guide carefully: http://www.haskell.org/ghc/docs/latest/html/Cabal/
01:13:57 <lambdabot> Title: Common Architecture for Building Applications and Libraries
01:15:52 <bens> xpika_: or copy a Setup.hs and .cabal file from some other package and modify them
01:16:11 <xpika_> bens: im just trying to install something
01:16:53 <xpika_> bens: currently im on plan
01:16:54 <xpika_> b
01:17:03 <xpika_> install ghc 6.6.1
01:17:18 <bens> ok. Try that
01:17:20 <xpika_> but yet again i get dependancy requirements
01:17:31 <xpika_> happy made me sad :(
01:18:34 <LeCamarade> @remember xpika_ happy made me sad :(
01:18:34 <lambdabot> Done.
01:20:57 <bens> xpika_: you're trying to compile happy with ghc-6.6.1 now?
01:24:16 <xpika_> yep
01:24:40 <xpika_> the setup.hs thinks my ghc is in c:\Program Files\Haskell\
01:24:46 <xpika_> i dont know why it thinks that
01:24:55 * osfameron reads the Monads and Icecream thread and cries
01:28:42 <bens> xpika_: you can pass the path to your compiler with runghc Setup.lhs configure -w ${ghcpath}.
01:29:00 <xpika_> bens: ill try that ! thanks
01:29:37 <quicksilver> osfameron: monads and icecream?
01:29:52 <osfameron> quicksilver: yup
01:29:57 <quicksilver> osfameron: where?
01:30:19 <osfameron> quicksilver: [Haskell-cafe] found monad in a comic  (citing http://xkcd.com/c248.html )
01:30:20 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
01:30:35 <osfameron> started 12-Jun-2007 04:16
01:32:12 <Baughn> unsafePerformIO included, I see
01:36:06 <quicksilver> osfameron: ah
01:37:03 <osfameron> quicksilver: please don't try to explain... I don't have enough brane cycles to attempt to understand monads, parallel worlds etc.  I could probably manage to eat an icecream though (though that might make me feel a little sick as I've only just recently had breakfast)
01:38:17 <quicksilver> mmm icecream
01:39:58 <quicksilver> dpiponi is wrong, of course
01:40:09 <quicksilver> there isn't a mapping from 'thee' to 'a summer's day'
01:40:11 <xpika_> i thought the joke was just that the problem of the hopthetical was solved ironically with another hypothetical
01:40:13 <quicksilver> that was rather the point of the poem
01:49:37 <vincenz> time to go
01:49:39 <vincenz> time to give that course :)
01:49:58 <quicksilver> vincenz: gl
01:50:11 <Syzygy-> quicksilver: Actually, given the partial order of comparable expressions, there would be an arrow (known as the Shakespeare or Sonnet arrow) from 'thee' to 'a summer's day'....
01:56:58 <matthew-_> is there a paper in which overlapping and undecidable instances are talked about?
02:10:21 <hpaste>  nornagon pasted "procentry and getinfo apparently alloc a lot... why?" at http://hpaste.org/286
02:25:11 <ndm> @seen dons
02:25:11 <lambdabot> I saw dons leaving #xmonad and #haskell 49m 9s ago, and .
03:07:59 <malcolmw> it's quiet today
03:10:12 <kolmodin> ooooaaaoo! /me flips a chair and starts yelling
03:12:54 <LeCamarade> blublublublublublublublublu!
03:13:09 <LeCamarade> @yow
03:13:09 <lambdabot> My Aunt MAUREEN was a military advisor to IKE & TINA TURNER!!
03:16:46 <LeCamarade> It's interesting how many traitors we have in here. :o) Being logged into #haskell and #ocaml can be entertaining when you follow the simultaneous joins.
03:17:12 <opqdonut> @. elite yow
03:17:12 <lambdabot> Y0w! i jUzT \/\/EN7 8EL0\/\/ 7|-|E p0Ver+y |InE!
03:17:21 <opqdonut> @. elite yarr
03:17:21 <lambdabot> i'D 1ixE T0 DRop m3 4nc|-|Or IN HEr LAgOoN
03:17:26 <opqdonut> that'll be all
03:22:23 <igli> LeCamarade: #friendly-coders when you have time ;-)
03:23:57 <LeCamarade> igli: :o)
03:24:51 <igli> hi man :D
03:28:39 <beelsebob> @vixen you fixed yet?
03:28:39 <lambdabot> <undefined>
03:53:13 <opqdonut> @_@
03:53:13 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
03:53:15 <opqdonut> :)
03:53:25 <opqdonut> !quote
03:53:28 <opqdonut> ?quote
03:53:28 <lambdabot> xpika_ says: happy made me sad :(
03:54:07 <roconnor> ?quote
03:54:07 <lambdabot> madpickle says: Stuff costs more than it used to.
03:54:17 <roconnor> ?quote sad
03:54:17 <lambdabot> chessguy says: mejor cansado que casado!
03:54:37 <opqdonut> ?quote monad
03:54:37 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
03:54:38 <opqdonut> :)
04:07:41 <Boney> ?quote lazy
04:07:42 <lambdabot> Philippa says: the ivory tower isn't meant for use as a dildo! I stated lazy and not another scheme :-)
04:08:52 <opqdonut> woah
04:09:23 <beelsebob> lol
04:09:59 <LeCamarade> That quote takes the cake.
04:11:24 <igli> yeah
04:13:22 <ekidd> Good morning.
04:13:28 <opqdonut> morn
04:14:04 <ivanm> evening
04:14:10 <vincenz> it went well
04:18:43 <LeCamarade> Does SPJ ever show up here? I doubt he would, but he would be a nice addition to the list of #haskell elders. :o)
04:18:58 <quicksilver> I've never seen him
04:19:04 <quicksilver> I don't think he's an IRCer
04:19:23 <quicksilver> still, the 'other Simon' does :)
04:19:30 <LeCamarade> Hughes?
04:19:50 <LeCamarade> Si-Cubed. :o) The runners-up of ICFP '99.
04:20:48 <masak> ?quote monad
04:20:48 <lambdabot> jcreigh says: I've found learning Haskell makes me feel vastly inferior to Haskell coders. ("Oh,", they say, "That's just a fold over the hyper-monad fluxbox list. Here's the one-line replacement
04:20:48 <lambdabot> for your entire program.")
04:21:02 <masak> true...
04:21:12 <LeCamarade> :-)
04:21:17 <LeCamarade> ROTFLMAO hard!!!
04:21:33 <LeCamarade> Worryingly-true, you know.
04:21:42 <Igloo> SPJ was here a couple of times a while ago
04:21:47 <LeCamarade> Or, even worse, they @hoogle or @src.
04:21:59 <LeCamarade> Igloo: Was he, now? Wow!
04:31:22 <nornagon> @quote
04:31:22 <lambdabot> DougalStanton says: I'm beginning to wonder if Simon is less a name and more a title, meaning "strong in the lambda force" or somesuch. Let's hope they don't go over to the dark side ;-)
04:31:33 <nornagon> @quote monad
04:31:33 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
04:31:33 <lambdabot> a really bad one
04:31:53 <ivanm> @quote
04:31:53 <lambdabot> xDie says: sampabolla
04:32:40 <nornagon> ...
04:35:43 <kolmodin> "reality" check: does wxhaskell work properly with ghc-6.6 ?
04:37:56 <ivanm> @quote reality
04:37:57 <lambdabot> newsham says: dont confuse larry wall's drug induced vision of computing with the state of reality
04:38:42 <Boney> heh.  I like that one.
04:38:49 <Boney> um  ++
04:39:10 <Boney> @karma
04:39:10 <lambdabot> You have a karma of 0
04:39:11 <Boney> ?
04:39:19 <Boney> newsham++
04:39:28 <Alneyan> kolmodin: I couldn't get wxhaskell 0.10 to compile under ghc-6.6. The Darcs version does compile, however
04:39:45 <kolmodin> Alneyan: ok. thanks
04:40:11 <kolmodin> I hope they have done it properly now. iirc it did incremental compilation/installation before
04:42:04 <quicksilver> LeCamarade: no, marlow
04:42:07 <quicksilver> LeCamarade: good point, though
04:43:29 <ketil> Ah.
04:43:57 <ketil> Anybody get tagsoup to work?  I can't find the ~== operator anywhere?!
04:44:21 <ketil> (That is, I can't find its definition - it is used in the examples)
04:44:44 <ketil> @seen ndm
04:44:44 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1h 35m 53s ago, and .
04:44:58 <ketil> @seen
04:45:47 <ketil> Okay - anybody know how to parse an XML document a few megabytes in size?
04:46:21 <ketil> My HXT implmenentation blows my (1.5Gbyte) heap on a 9Mbyte document :-(
04:46:42 <opqdonut> stay away from xml :)
04:47:29 <ketil> opqdonut: Thanks for the advice.  Feel free to submit patches to my text BLAST-output parser.
04:47:55 <opqdonut> BLAST?
04:47:57 <ketil> (Translation: "human readable" text formats suck even more than XML)
04:48:09 <ketil> biological sequence search/alignment tool.
04:48:34 <opqdonut> csv is quite nice actually, as long as the data is not overly hierarchical
04:48:56 <opqdonut> yeah i've nothing against xml per-se, it's just used in some horrible stuff
04:49:30 <ketil> opqdonut: xml sucks.  But it is nice to be able to snip out parts you are interested in, without worrying about parsing the parts you are not.
04:50:02 <ketil> I just need a lazy parser, is all.  HXT is too strict.  And yes, ByteStrings would be a nice bonus.
04:50:41 <ketil> Oh, well.  I'll just grep the elements I need, and try to parse those, I guess.
04:51:46 <ekidd> Draft of my probability monad paper: http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
04:52:00 <ekidd> I'm still editing madly--this took much longer than I had anticipated to write.
04:54:17 <kolmodin> ketil: oh, the problem is that it is too strict?
04:55:05 <ttfh> ketil: how do you find sequence alignments? edit/levenshtein-distance?
05:00:33 <ekidd> I'm really surprised at how well probability monads decompose into monad transformers, and how easy it is to stumble over something interesting...
05:02:24 <hpaste>  mdmkolbe|work pasted "Am I reinventing the wheel?" at http://hpaste.org/287
05:03:46 <mdmkolbe|work> I needed to invent this type trick for a task I was doing.  Is it already known?  If so, by what name? http://hpaste.org/287
05:05:02 * ekidd would love to look, but is madly editing on deadline
05:05:11 <ketil> kolmodin: maybe strictness is the problem, yes.
05:05:23 <malcolmw> ketil: HaXml-devel has a lazy parser for XML
05:05:28 <ketil> I'd like to be able to stream the file, processing it on the go.
05:05:35 * mdmkolbe|work is using this type trick to write something on that same deadline ;-)
05:05:46 <ketil> malcolmw: Oh?  I'll check it out.  Is the interface much different from HXT?
05:05:47 <ekidd> mdmkolbe|work: If nobody can answer your question in the next few minutes, ping me a again and I'll take a look.
05:06:16 <quicksilver> ketil: the consequence of doing that is that you might find, at any point, that everything up until that point was actually invalid
05:06:22 <malcolmw> ketil: HXT started from HaXml's ideas and built out in a particular direction
05:06:23 <ketil> ttfh: yes, levenstein with substution score matrices depending on evolutionary distance.
05:06:32 <quicksilver> ketil: unless you do a quick first pass for wellformedness first, I suppose
05:07:12 <DRMacIver>  '15-JUN-07 1.00.00.000000';
05:07:14 <DRMacIver> Oops
05:07:17 <ketil> quicksilver: right.  I can live with delayed errors.  If the output is invalid or malformed, I have bigger problems.
05:07:17 <DRMacIver> Mispaste, sorry
05:07:52 <malcolmw> ketil: if your XML is guaranteed to be wellformed, then lazy parsing is ideal
05:08:33 <ketil> ttfh: (actually - BLAST uses a heuristic approximation to levenstein.  Slightly less sensitive, much faster.)
05:08:53 <quicksilver> I just wrote a half-lazy YAML parser, which is not an entirely unrelated thing
05:09:07 <quicksilver> half-lazy because it parses the lines strictly, but the structure lazily
05:09:12 <ketil> malcolmw: Yes.  (Isn't the *point* of xml that it should always be wellformed? :-)
05:09:25 <ketil> @where haxml
05:09:26 <lambdabot> http://haskell.org/HaXml
05:09:50 <malcolmw> ketil: actually, you want http://www.cs.york.ac.uk/fp/HaXml-devel/
05:09:51 <lambdabot> Title: HaXml: Haskell and XML
05:10:17 <ketil> Oh.  Darcs directory?
05:10:41 <malcolmw> yup
05:10:52 <ketil> Found it
05:10:53 <ketil> Great!
05:10:57 <malcolmw> what do you do after parsing the document?
05:11:18 <ketil> I just extract some information, and build a data structure.
05:11:42 <ketil> (Which can also be built from other (non-xml) representations)
05:12:02 <ketil> For this specific application, I just want to flatten things into a table.
05:12:40 <malcolmw> just noticed that you mentioned 'grep' earlier - so check out Xtract, either the cmdline tool or the API within HaXml
05:12:57 <oerjan> quicksilver: is there actually any requirement that an XML document use line breaks at all?
05:13:10 <quicksilver> oerjan: no, but mine is for YAML :)
05:13:13 <ketil> Ah, yes.  If it is what it sounds like, it could possibly be used to prune down the size to a more manageable size.
05:13:16 <quicksilver> oerjan: and YAML is line-based
05:13:23 <ketil> oerjan: no.
05:13:31 <malcolmw> well, the actual tool you want is XtractLazy I guess
05:13:31 <oerjan> oh
05:13:39 <quicksilver> malcolmw: how lazy is lazy? suppose I have <foo><bar>*error*</bar> ... </foo>
05:13:54 <quicksilver> malcolmw: if I never inspect the bar node with the error, can I access the rest of the foo?
05:14:28 <malcolmw> quicksilver: you would get enough data in haskell to see (Foo (Bar _) _ _ ... )
05:14:32 <ketil> Hmm. I guess you can be lazy in two directions? :-)
05:14:53 <malcolmw> but if you tug on anything inside the Bar, or to the right of it, BOOM
05:15:06 <quicksilver> malcolmw: 'or to the right of it' was waht I was probing at
05:15:17 <ketil> s/directions/dimensions
05:15:23 <malcolmw> of course it depends on what kind of error it is
05:15:29 <quicksilver> malcolmw: my YAML parser lets you go to the right, as long as you don't go inside. But they are not isomorphic problems.
05:16:04 <ekidd> mdmkolbe|work: Well, I haven't seen that particular trick before. But I'm not one of those crazy people who tries to write a raytracer in the type system. :-)
05:16:10 <malcolmw> if the error is a validity problem, rather than a well-formedness problem, lazy parsing should work OK
05:16:35 <apfelmus> how can i get those fancy double square brackets in LaTeX? Like in E[[x * y]] = x y
05:16:45 <oerjan> i suppose it depends on whether the error is so serious that you cannot determine the matching </bar>
05:16:49 <ketil> @where polyparse
05:16:50 <lambdabot> http://www.cs.york.ac.uk/fp/polyparse/
05:18:26 <mdmkolbe|work> ekidd: I just realized that it is foldl in the type system
05:18:30 <ketil> malcolmw: is a #! header in Setup.hs illegal?  It works with (at least) ghc, and its absence makes my system try to run Setup.hs with the shell...
05:18:59 <ekidd> apfelmus: Are you also finishing a paper this morning? ;-)
05:19:03 <ttfh> ketil: I used levenshtein distance for analzing debug output from a mobile platform in my thesis
05:19:04 <thoughtpolice> ketil: i normally have a shebang on my setup files
05:19:15 <apfelmus> ekidd: fortunately not :)
05:19:21 <malcolmw> ketil: depends on the compiler I think
05:19:26 <quicksilver> apfelmus: \llbracket
05:19:37 <ekidd> apfelmus: They're in the St. Mary's Road extension symbols...
05:19:40 <quicksilver> apfelmus: I recommend printing out one of the latex hint sheets though :)
05:19:42 <malcolmw> ketil: feel free to add a shebang if you want one
05:19:43 <mdmkolbe|work> Anyone know of a foldl that takes a predicate to determine when to stop the folding?
05:19:46 <ketil> ttfh: I have implementations for local and global alignment (using dynamic programming), should you need them again. :-)
05:19:55 <ekidd> Google for "symbols-a4.pdf"...
05:20:01 <quicksilver> apfelmus: and I further recommend mathligh, but I'm biased
05:20:07 <apfelmus> quicksilver, ekidd: thanks. Does that work for wikipedia, too?
05:20:19 <ketil> malcolmw: I should just strictify myself to type runhaskell more often, I guess.
05:20:24 <ekidd> apfelmus: Try it and see what they have loaded.
05:20:54 <ketil> thoughtpolice: me too.  (Standard? what standard?)
05:21:08 <ekidd> You know, I'm utterly amazed at how much work goes into a paper. I left a good 50+ hours just to write up results I already understood well, and it was grossly inadequate.
05:21:19 <ketil> mdmkolbe|work: fold . takeWhile p ?
05:21:36 <apfelmus> ekidd: :( "Failed to parse (unknown error\llbracket): \llbracket\mathtt{5*}\rrbracket"
05:21:37 <quicksilver> mdmkolbe|work: that sounds more like an unfold than a fold
05:21:38 <thoughtpolice> ketil: but a bit of my code uses ghc-specific extensions/libraries, so ymmv
05:21:41 <thoughtpolice> :p
05:22:06 <ketil> standard is as standard does, mah mahm used to say...
05:22:25 <malcolmw> ketil: please bug me if you hit any build/installation problems
05:22:31 <ekidd> mdmkolbe|work: If you're mapping one list to another, you can use unfoldr in place of fold, and get nicer termination predicates...
05:22:49 <ketil> malcolmw: tons of warnings, but it's trudging along.  Must be a few lines of code, it appears :-)
05:23:02 <mdmkolbe|work> > let my_fold f base pred x | pred x = base; my_fold f base pred (x:xs) = my_fold f (f x base) xs in my_fold + 0 even [1, 3, 5, 2, 4, 6]
05:23:04 <lambdabot>  Couldn't match expected type `[t]'
05:23:18 <ketil> malcolmw: since HXT is a spin-off I expect you use a general tree data structure?
05:23:24 <mdmkolbe|work> > let my_fold f base pred x | pred x = base; my_fold f base pred (x:xs) = my_fold f (f x base) xs in my_fold + 0 (even.head) [1, 3, 5, 2, 4, 6]
05:23:25 <lambdabot>  Couldn't match expected type `[t]'
05:23:29 <apfelmus> ekidd: darn, wikipedia doesn't even know \mathtt
05:23:48 <ketil> should it be possible to parse JSON to the same structure?  (http://www.json.org/)
05:23:49 <lambdabot> Title: JSON
05:24:39 <apfelmus> ah, it's \textt
05:24:42 <apfelmus> \texttt
05:25:07 <oerjan> mdmkolbe|work: missing parentheses around +
05:25:31 <mdmkolbe|work> > let my_fold f base pred x | pred x = base; my_fold f base pred (x:xs) = my_fold f (f x base) pred xs in my_fold (+) 0 (even.head) [1, 3, 5, 2, 4, 6]
05:25:32 <malcolmw> ketil: HaXml's generic tree data structure is fairly XML specific, particularly in the DTD section - I think HXT's is more general
05:25:32 <lambdabot>  9
05:25:46 <mdmkolbe|work> there, that's the kind of fold I mean
05:26:14 <vincenz> mdmkolbe|work: wouldn't it be better to plit that into 2 concepts
05:26:28 <vincenz> mdmkolbe|work: first cut the list at where pred is true
05:26:30 <vincenz> mdmkolbe|work: then apply a fold
05:26:34 <malcolmw> HaXml has combinators that are "content filters", whilst HXT generalises to arrow-based filters over anything (i.e. DTD equally as element content)
05:26:51 <vincenz> mdmkolbe|work: it's like
05:27:02 <vincenz> fold f z $ takeWhile (not . pred) $ list
05:27:41 <malcolmw> but HXT does not have DtdToHaskell, which converts from generic content trees to DTD-specific Haskell trees
05:28:06 <ketil> malcolmw: I must admit I found the HXT tutorial confusing - suddenly I was in to my armpits in arrows.  Anyway, HaXML is installed, I'll see if I can get it to work.
05:28:10 <oerjan> vincenz: mdmkolbe|work seems to test the tail, not the elements
05:28:15 <mdmkolbe|work> vincenz: Well, I'm actually implementing something like this in the type system (see my previous paste) so I was trying to find an existing function name so I could name my type system implementation analagously
05:28:33 <vincenz> oerjan: still, two seperate aspects
05:28:44 <vincenz> mdmkolbe|work: ah, missed that ::)
05:29:44 <malcolmw> ketil: I suggest having a quick look at http://www.cs.york.ac.uk/fp/HaXml-devel/Xtract.html to see if that is enough for you to prune your document down before using your existing HXT code
05:29:45 <lambdabot> Title: Xtract: a query language for XML documents
05:31:32 <ketil> malcolmw: thanks, will do.
05:36:28 <ketil> malcolmw: Xtract '*//-' should extract *all* text, shouldn't it?  I only get 72 lines from my 12Mb document...
05:37:58 <malcolmw> ketil: yes.  It is perhaps possible that various texts have been catenated onto the same line of output though.  I recently changed the pretty-printer, and that might have been one of the side effects
05:38:30 <malcolmw> oh, and XtractLazy, not Xtract, if you want the laziness
05:38:41 <ketil> malcolmw: hmm. *// should print the entire document, no?  It is truncated, somehow.
05:39:44 <malcolmw> ketil: truncation might indicate a parse failure
05:40:31 <ketil> malcolmw: hmm.  Should I put the file somewhere for you to look at?
05:40:44 <malcolmw> ketil: I'll happily take a look
05:41:44 <ketil> Okay, it's being pushed to http://www.malde.org/~ketil/JvsUniq.xml
05:43:11 <ketil> Oh wait - I think I know.  It's actually an old BLAST bug; it's a concatenation of XMl docs.
05:44:46 <ketil> (what was that about xml and correctness again? sigh)
05:45:07 <malcolmw> :-)
05:45:51 <malcolmw> error on line 39 at column 6: XML declaration allowed only at the start of the document
05:45:54 <quicksilver> Henning Thieleman == Lemmih?
05:46:04 <malcolmw> quicksilver: no, he's lemming
05:46:31 <malcolmw> lemmih = david himmelstrup
05:46:55 <ketil> == reverse "lemmmih" ++ "strup"
05:47:13 <vincenz> > let {endat [] pred = []; endat (x:xs) pred = if pred (x:xs) then [] else x:endat pred xs} in endat (even . head) [1..]
05:47:14 <lambdabot>  Couldn't match expected type `[t] -> Bool'
05:47:25 <quicksilver> malcolmw: Ah. I understand now why I got confused :)
05:47:29 <Lemmih> Argh, my secret identity has been revealed!
05:47:48 <quicksilver> As way of recompense, I will reveal that I am, in fact, Batman!
05:47:52 <quicksilver> (now we're even)
05:48:29 <ketil> This is functional progamming.  No identities please, only values!
05:48:35 <malcolmw> ketil: so is there an easy way to get the un-concatenated docs as separate files?  you can add all the separate filenames to the commandline i think
05:49:09 <ketil> malcolmw: I'm working on it.  I have a solution ...somewhere.
05:49:22 <malcolmw> but you are allowed multiple name bindings for each shared value
05:50:49 <ketil> > groupBy (const (not . isPrefixOf "foo")) ["foobar","zot","foozot","bar"]
05:50:50 <lambdabot>  [["foobar","zot"],["foozot","bar"]]
05:50:55 <ketil> hah!
05:51:31 <vincenz> ketil: o.O
05:51:49 <vincenz> > groupBy (const (not . isPrefixOf "foo")) ["foobar", "zot", "blabla", "foozot", "bar"]
05:51:50 <lambdabot>  [["foobar","zot","blabla"],["foozot","bar"]]
05:51:54 <Saizan> uoh, same trick in tagsoup's partition
05:52:23 <oerjan> hm...
05:53:00 <Saizan> ?src groupBy
05:53:00 <lambdabot> groupBy _  []       =  []
05:53:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
05:53:00 <lambdabot>     where (ys,zs) = span (eq x) xs
05:55:37 <ketil> and: sequence_ [writeFile ("JvsUniq_"++show f++".xml") (concat y) | f <- [1..] | y <- xmls]
05:56:07 <ketil> Remind me again, what are shells for?
05:56:16 <quicksilver> incidentally I'm not sure it's good to abuse groupBy that way
05:56:23 <quicksilver> you're using the *implementation* of groupBy
05:56:32 <quicksilver> but you're exceeding its *specification*
05:56:44 <quicksilver> (the specification says that eq should be an equivalence relation)
05:57:45 <ketil> quicksilver: "good"?  Getting results is good.  Whether it is decent another matter. :-)
05:58:34 <Saizan> ?where report
05:58:34 <lambdabot> http://www.haskell.org/onlinereport/
05:58:35 <oerjan> quicksilver: but it's so useful!
05:59:42 <quicksilver> oerjan: yes, but you should give it another name
05:59:57 <quicksilver> oerjan: one day Prelude.groupBy may change to a faster implementation of its specification
06:00:03 <quicksilver> which fails this property
06:00:09 <ketil> I agree.  The prelude is a bit short on useful splitting functions.
06:00:20 <quicksilver> (actually I don't think that' *very* likely. But the principle is sound)
06:00:22 <ketil> And it's hardly the obvious way to implement it.
06:00:32 <osfameron> yeah, the toWords and toLines or whatever are a bit odd, rather than being a parametrizable "split" function
06:00:32 <oerjan> i guess i should not mention when i used a non-reflexive predicate with insertBy
06:01:58 <quicksilver> osfameron: haven't we been round this one before? the fully parameterised version is fugly :)
06:02:16 <quicksilver> osfameron: fugly, and easy to write the case you need, when you need it
06:02:17 <osfameron> quicksilver: don't think so.  We maybe had a chat about join :-)
06:02:27 <osfameron> so the opposite problem :-)
06:02:41 <osfameron> but yeah, I was thinking of just "split on a character"
06:02:48 <quicksilver> you have to parameterise it on (1) specify delimeter by Char, String or predicate (2) include or exclude delimeter
06:03:03 <quicksilver> so if you're not careful you end up with 6 variants
06:03:13 <quicksilver> or some horribly clever multi-parameter one
06:03:32 <quicksilver> Oh, I forget (3) treatment of repeated delimiters
06:03:43 <xs> are there usable SDL bindings for haskell? most i find references to are missing or appear unmaintained.
06:03:58 <quicksilver> xs: there is only one I know of, and I don't know how usable it is.
06:04:06 <ketil> Note to self: do not bind file contents to variables in ghci.
06:04:22 <quicksilver> ketil: I like doing that :)
06:04:29 <xs> quicksilver: ah, pity. thanks. :)
06:05:36 <ketil> quicksilver: sure.  But it blew my heap.
06:05:46 <quicksilver> ketil: oh. that was a big file :)
06:06:08 <quicksilver> ghci needs a 'browse mode' for very large values
06:06:11 <quicksilver> anyone want to write it?
06:06:12 <quicksilver> :)
06:06:19 <ketil> Yes.  readFile .. >>= \xs -> sequence_ [writeFile ... grouBy (const ...] did work, though.  Constant space and all.
06:07:29 <osfameron> quicksilver: ok, repeated delimiters etc. is tricky.  Which is why I guess I supposed it would be dealt with in the prelude.  But no biggie as you say
06:17:37 <vincenz> quicksilver: "include or exclude delimiter is not needed", exclude by default and if you want it back just re`map' it back in
06:18:14 <igli> quicksilver: sorry i can only help if it's C, not haskell
06:20:11 <quicksilver> vincenz: tricky if the delimiter is a predicate, or has been collapsed from multiples
06:20:20 <quicksilver> vincenz: then you don't know how many to add back in
06:20:34 <quicksilver> osfameron: hard to get the right interface, is what I'm saying
06:20:41 <quicksilver> osfameron: go too general and the function looks stupid
06:20:50 <quicksilver> osfameron: go too specific and it's not useful enough!
06:20:55 <ketil> Hmm.. HXT complains about not finding the DTD, but I'm using (a_validate,v_0).  Huh?
06:21:22 <vincenz> quicksilver: that is why I argue you shouldn't collapse from multiples
06:21:31 <vincenz> quicksilver: you can always filter empty strings if you want that
06:21:40 <quicksilver> what about predicates though?
06:21:40 <vincenz> that's how python (or was it ruby) got split wrong
06:21:53 <ketil> Adding an empty file solved it.  Silly.
06:21:54 <osfameron> (perl split)++
06:22:22 <vincenz> split ',' ["a,b,,c,"] should return: ["a", "b", "", "c", ""]
06:22:31 <quicksilver> I understand what you mean
06:22:32 <vincenz> if you want to remove empty, you can always filter afterwards
06:22:36 <vincenz> going the other way is impossible
06:22:36 <quicksilver> but what about:
06:22:48 <quicksilver> split (isSpace) ["a b\tc"]
06:22:53 <vincenz> ah
06:23:06 <vincenz> quicksilver: another option then is
06:23:15 <quicksilver> > words "a b\nc"
06:23:17 <lambdabot>  ["a","b","c"]
06:23:20 <vincenz> split:: [a] -> [("a",a)]
06:23:28 <vincenz> then you have all thei nfo
06:23:28 <quicksilver> (note that words behaves like this, and loses information)
06:23:53 <vincenz> (words is a specific use case, however, that should be built ontop of a generic split)
06:23:57 <quicksilver> right, but I think you've made my point for me :)
06:24:01 <quicksilver> there's more than one way to do it
06:24:09 <quicksilver> and the most general looks rather ugly when you want something simpler
06:24:17 <vincenz> that's no issue
06:24:25 <vincenz> give some simpler ones
06:24:27 <vincenz> that use the generic one
06:24:34 <vincenz> prelude does this with fold
06:24:37 <vincenz> @src map
06:24:38 <lambdabot> map _ []     = []
06:24:38 <lambdabot> map f (x:xs) = f x : map f xs
06:24:40 <vincenz> hmm
06:24:40 <quicksilver> yup
06:24:42 <vincenz> or it should :)
06:24:45 <vincenz> map = fold
06:24:46 <quicksilver> and then you just have to pick the *right* types
06:24:54 <quicksilver> and the right names
06:25:03 <vincenz> naming is the worst part of coding :)
06:25:08 <vincenz> (or the hardest)
06:25:31 <osfameron> yeah, it's one of the most important things
06:25:39 <osfameron> I hammer our junior programmers about that
06:27:14 <oerjan> groupBy (equating p)
06:28:25 <oerjan> filter (not . p . head) (equating p)
06:28:42 <oerjan> er, filter (not . p . head) . groupBy (equating p)
06:30:11 <osfameron> isn't there a prelude function "partition" which would work with the (isSpace) example ?
06:30:17 <quicksilver> osfameron: incidentally I wasn't trying to suggest that the *programming* was the hard part :) The hard part is finding the elegant well named public API over the obvious functions
06:30:21 <quicksilver> osfameron: there is 'span'
06:30:31 <ddarius> @hoogle partition
06:30:35 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
06:30:35 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
06:30:35 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
06:30:39 <quicksilver> osfameron: which you can mix with 'takeWhile' and 'unfoldr' and three heaped spoon of sugar
06:31:30 <osfameron> quicksilver: rarr, yeah span/break is what I was thinking of, ok
06:31:42 <osfameron> yeah, I get your point
06:32:35 <osfameron> and of course the Perl split which is powerful and useful is crippled (from a haskell viewpoint, and occasionally from mine) by only working on strings
06:33:33 <Saizan> perl_split :: Char -> String -> [String] ?
06:34:20 <integral> Saizan: Regexp -> String -> Int -> [String]
06:34:36 <Saizan> ah, right
06:34:39 <Saizan> Int?
06:34:39 <osfameron> Regexp or String, though you could see String as being a subset of that
06:34:39 <integral> or, generalized: forall a. Regexp a -> a -> Int -> [a]
06:34:42 <osfameron> and the Int is optional
06:34:48 <integral> Saizan: number of fields to split into.
06:35:28 <Saizan> is that like take n or different?
06:35:55 <integral> different, because after n-1 fields are split off, the remainder is returned as a single lump
06:36:12 <integral> (eg. split / /, "abc mno xyz" 2 ===> ["abc", "mno xyz"])
06:36:13 <Saizan> uhm
06:38:40 <Saizan> the regex part is quite hard to render idiomatically
06:46:55 * edwardk yawns and checks to see if anyone is awake.
06:47:12 * oerjan snores loudly
06:47:22 <edwardk> =)
06:47:43 * edwardk starts to draw on oerjan's face with a sharpie, and wonders when he'll notice.
06:47:52 <oerjan> Ouch!
06:48:58 * ndm is slightly awake, although quite tired
06:49:32 <edwardk> so did you post up that paper you were talking about the other day, neil?
06:50:57 <ndm> edwardk: i'm just going the very final corrections, should have the library released with the paper in a few hours at most
06:51:05 <edwardk> k
06:51:58 <ndm> its nearly the same as the copy i gave you though
06:52:34 <edwardk> i didn't see any huge glaring holes from skimming through it the other day
06:52:41 <edwardk> so no big surprise ;)
06:53:10 <ndm> its all implemented, and very heavily used
06:53:17 <kolmodin> ndm: in the (far) future when we will add Catch to gentoo, we will need a yhc release, or an official snapshot
06:53:24 <kolmodin> ndm: not that you will have to worry just yet :)
06:53:29 <kolmodin> just so you know :)
06:53:46 <ndm> kolmodin: yep, we're working on it - target number 1 is to hit all the points on our "kill nhc" hitlist
06:53:59 <ndm> then we'll 1.0 it probably
06:54:09 <kolmodin> sounds lovely
06:54:22 <ndm> (the things on the hitlist are things that need doing most important, not a malicious intention just to kill nhc)
06:54:48 <kolmodin> hah
06:55:01 <malcolmw> meanwhile, /me has a different aim, which is to attempt to share as much as possible between nhc98 + yhc once again
06:55:16 * ndm doesn't think thats possible
06:55:35 <ndm> (but it would be lovely if it was)
06:55:43 <malcolmw> we can common-up a good chunk of the compiler itself, which is the only bit that we can share anyway
06:56:13 <malcolmw> the only problem is that it is tedious to go through all the diffs and resolve them
06:56:36 <ndm> i suspect it will be impossible, but i'm more than happy to be proved wrong
06:57:27 <malcolmw> did anyone ever benchmark AssocTree against Data.Map to see which was fastest, before they threw away AssocTree?
06:57:55 <ndm> nope
06:58:06 <ndm> if AssocTree is faster then thats a good argument for replacing it in base
06:58:54 <malcolmw> but AssocTree is probably incomplete
06:59:10 <ndm> but if its faster, someone should finish it off and shove it in base
06:59:31 <ndm> we want the smallest possible compiler, with the least code in it
06:59:36 <malcolmw> it may not be faster for everything - perhaps only for the operations that are currently provided
07:00:01 <ndm> perhaps, but i still think thats an issue for someone optimising base, not for someone writing a compiler
07:01:16 <malcolmw> given that CR recently discovered that Data.Set is 1000x slower than his own Set library, for a given application, I think it is reasonable to have application-specific libraries that duplicate some of the functionality of standard ones
07:01:35 <ndm> i disagree, i think thats a great reason to rip holes in the base library and fix them
07:01:57 <ndm> i think CR's set library is lazy in null, while it may be that the base library isn't
07:02:27 <ndm> I don't believe CR's complexity arguments, the way I see it base wins on complexity always, only has a higher overhead - and its not 1000x overhead
07:02:28 <malcolmw> but there is no one data-structure representation that fits all applications
07:02:49 <ndm> but both Data.Map and AssocTree are trees, i'm sure there isn't that much in it
07:03:12 <ndm> perhaps *hc should move to tries for something, but i doubt the tree makes a massive difference
07:03:12 <bos> this wasn't something that was discussed on -cafe, was it?
07:03:16 <ndm> nope
07:03:36 <bos> too bad. performance results are always fascinating.
07:03:45 <malcolmw> CR has an example which is 30sec in CR.Set, but 3hr30mins in Data.Set
07:03:55 <bos> yikes!
07:03:59 <edwardk> yow
07:04:08 <ndm> my guess is Data.Set has strictness bugs
07:04:12 <malcolmw> I make that about 440x slower
07:04:32 <ndm> I can believe there is a factor 10 overhead, but that kind of number is algorithmic complexity
07:04:44 <ndm> and CR's library does not have better complexity in anything
07:05:05 <malcolmw> but of course that is not a constant factor, it is because the set algorithms have different complexity
07:06:13 <ndm> but CR's are always slower in complexity
07:06:43 <edwardk> does someone have a link to CR's set library and who is CR? =)
07:06:53 <malcolmw> ndm: no, I thought they were equal or better than Data.Set in complexity
07:06:57 <ndm> elem is worse complexity, fromList is lower overhead but same complexity
07:07:00 <malcolmw> apart from the elem test
07:07:08 <ndm> edwardk: Colin Runciman, and no
07:07:15 <edwardk> ah k
07:07:27 <ndm> malcolmw: fromList is the only one he claims better complexity on, and i'm pretty sure he's wrong in a lazy setting
07:07:52 <ndm> using the "(++) is O(1) in a lazy language" argument
07:08:42 <malcolmw> I'm pretty sure that the balanced trees used in Data.Set mean that you cannot insert into the set lazily, ever
07:08:59 <ndm> possibly
07:09:03 <ndm> possibly not
07:09:18 <ndm> maybe we need Data.Set.Lazy as well
07:09:49 <ndm> but the null test should be able to be lazy in the insertion, only demanding enough to ensure there is one insertion
07:09:55 <ndm> which i think should be lazy enough
07:10:02 <ndm> depends if null is lazy in Data.Set
07:10:05 <ndm> @src Data.Set
07:10:06 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
07:10:11 <ndm> @locate Data.Set
07:10:11 <lambdabot> Unknown command, try @list
07:10:17 <malcolmw> think of CR's version as a candidate for Data.Set.Lazy
07:10:48 <ndm> yes, or the current set library as broken in some small way
07:11:03 <ndm> null seems to be appropriately lazy
07:11:28 <ndm>               | Bin {-# UNPACK #-} !Size a !(Set a) !(Set a)
07:11:38 <ndm> i strongly suspect those !'s are whats killing performance
07:11:50 <ndm> someone probably went ! happy without doing enough benchmarking
07:12:36 <malcolmw> oh, interesting
07:12:59 <malcolmw> yes, in GHC that will force the entire structure of the tree, on every operation
07:13:12 <ndm> null $ fromList [1..n] is O(n) in Data.Set
07:13:18 <ndm> just checked it with a quick benchmark
07:13:28 <ndm> i bet without the !'s you'd get O(1)
07:13:44 <malcolmw> ... but you'ld also get space leaks
07:13:55 <ndm> i don't know enough about that to answer
07:14:17 <ndm> would the space leaked be greater than the space the tree would take?
07:14:35 <ndm> and would you necessarily leak?
07:15:00 <malcolmw> leakiness depends on the usage pattern
07:15:40 <malcolmw> looking at Adams' webpage, I see that Data.Set was originally implemented in SML
07:16:33 <malcolmw> so perhaps that is why the translation decided to be strict - just in case it mattered for some unforeseen performance reason
07:16:50 <ndm> perhaps
07:16:57 <ndm> but it clearly has performance issues the other way as well
07:17:08 <ndm> maybe there is call for Data.Set.Lazy, without those !'s
07:17:20 <ndm> or perhaps those !'s aren't a great idea anyway
07:18:55 <malcolmw> in the SML source code, a comment says that the hedge_union algorithm is 20% faster by replacing strict operations with lazy ones
07:19:23 <ndm> ah, so we may be throwing away performance to make things go slower
07:23:00 <ketil> ndm: I couldn't get tagsoup (from darcs) to compile.  The (~==) operator is't defined anywhere, it seems.
07:23:28 <ndm> ketil: use the tarball linked to from my web page, its possible ~== is no longer in the repo
07:23:45 <ndm> if it isn't, i'll add it back - i've been accepting lots of patches lately, and don't really know what it does anymore
07:23:53 <ketil> ndm :-)
07:24:34 <ketil> anyway, malcolm tried to sell me HaXML, but I got my HXT stuff to work - I think, so maybe I have what I need.
07:24:34 <ndm> its not great, i've managed to spawn a popular project and i don't even know what it does, am not responding to email about it, and the darcs version is broken...
07:24:45 <ndm> ketil: what are you hoping to do?
07:24:55 <ketil> parse some xml, basically.
07:25:02 <ndm> who gives you teh XML?
07:25:04 <ketil> that is - extract some information I need.
07:25:09 <ndm> do you want all the information or, just a small bit
07:25:16 <ketil> blast (sequence alignment program)
07:25:22 <ketil> small bits.
07:25:32 <ketil> I think I have it working, though.
07:25:37 <ndm> tagsoup may suit you, if you know its valid the other library may do too
07:25:38 <malcolmw> XtractLazy not needed then?
07:26:00 <ndm> exactly what bits do you want?
07:26:15 <ndm> the tagsoup code is usually similar size to the english description of what you want
07:26:16 <ketil> malcolmw: not at the moment, no.  It would perhaps have been the easier option.
07:26:42 * ketil must run now.  Has been educational, thanks.
07:34:15 <jfredett> ... is a list comprehension nothing more than a sugarfied do block?
07:34:24 * jfredett ponders
07:34:25 <DRMacIver> It actually doesn't use the do block.
07:34:33 <DRMacIver> s/do block/monadic operations/
07:34:49 <DRMacIver> It did at an early part of the specification, and arbitrary monad comprehensions were allowed.
07:35:05 <jfredett> interesting
07:35:05 <osfameron>  can't see that a list comprehension is anything more than a glorified mapgrep
07:35:07 <DRMacIver> It's nothing more than sugarified maps and filters though.
07:35:13 <bos> jfredett: no.  it used to be that monad comprehensions were possible, but they proved too confusing to newbies.
07:35:16 <malcolmw> comprehensions are completely isomorphic to do notation, except restricted to lists
07:36:05 <jfredett> nifty
07:36:38 <Saizan> uoah, ~== has been removed and exploded in a series of specific functions in Text.HTML.TagSoup.Match
07:37:26 <ndm> Saizan: i'll be going back to the use of ~== shortly
07:37:38 <ndm> Saizan: use the tarball if you want ~== - i definately want ~== back
07:38:15 <Saizan> i think this has to do with the unicode-interpret-entities-parser patch
07:38:34 <osfameron> out of interest, why was it a problem that monad comprehensions were confusing to newbies?  Did they confuse the syntax of plain old list comprehensions?  As in, couldn't you just ignore them and pretend they didn't exist until you got around to using them ?
07:38:52 <osfameron> (which I'm doing with list comprehensions, 'cos I dislike them)
07:39:11 <Saizan> yeah ~== is much nicer, even if these functions looks more general
07:39:11 <jfredett> osfameron: list comprehensions are awesome- really.
07:40:03 * jfredett is afk
07:40:05 <oerjan> osfameron: what i heard was monad comprehension gave horrible type error messages
07:40:08 <Saizan> osfameron: i think because of errors about the Monad class when the newbie was trying to do some list stuff
07:40:39 <malcolmw> osfameron: textbooks gave some nice examples of list comprehensions, but if the newbie got something wrong, the error messages were deeply confusing
07:40:44 <osfameron> jfredett: I just find them harder to read than a map/filter, and using | for the filter syntax just doesn't make sense to me
07:40:50 <osfameron> ah, ok, those sound like good reasons
07:41:32 <oerjan> osfameron: the syntax is very similar to set comprehensions in mathematics
07:41:36 <malcolmw> errors like "no instance of MonadZero for Bool"
07:41:37 <Saizan> we may have a --newbie flag :)
07:41:43 <LoganCapaldo> List comprehensions look like sets which give me the warm fuzzies
07:42:23 <sjanssen> we should have monad comprehensions with a slightly different syntax
07:42:37 <Syzygy-> osfameron: Using | or : makes sure that people recognize it from {x|x^2<2}-style set declarations.
07:42:41 <sjanssen> like [{ }], or something
07:42:41 <igli> how so sjanssen?
07:42:52 <oerjan> sjanssen: we do, it's called do notation
07:42:52 <igli> hmm
07:43:02 <osfameron> that's it I guess, I didn't do maths after age 18, so it's not familiar to me at all, and just seems too compact to be clear
07:43:18 * LoganCapaldo makes a sad face
07:43:31 <sjanssen> igli: monad comprehensions are nice to have, but they confuse newbies -- using a different syntax lets the advanced users have them without confusing newbies
07:43:35 <osfameron> but I didn't say I was against them per se, just that I'm ignoring them later :-)
07:43:50 <sjanssen> oerjan: do is often significantly verbose
07:43:55 <osfameron> ^until later
07:43:56 <sjanssen> s/verbose/more verbose
07:44:12 <igli> sjanssen: ok but in general i think less verbosity is a good thing; noobies like me should just learn the syntax
07:46:12 <sjanssen> igli: the problem runs deeper than syntax.  Say a user accidentally does [x | x <- [1..10], y <- x /= 5] -- you get malcolmw's example message "no instance of MonadZero for Bool"
07:46:35 <igli> er what should they do there instead?
07:46:47 <osfameron> > [x | x <- [1..10], y <- x /= 5]
07:46:48 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Bool'
07:46:51 <sjanssen> so you'd have to teach your students about overloading and at least mention monads to teach list comprehensions
07:47:20 <osfameron> what's the actual error?
07:47:21 <LoganCapaldo> > [ x | x <- [1..10], x /= 5 ]
07:47:22 <lambdabot>  [1,2,3,4,6,7,8,9,10]
07:47:26 <igli> hmm ok if there's a valid pedagogical reason, cool. can you explain it to me as i am a noob tho?
07:48:19 <sjanssen> igli: the problem is that general monad comprehensions can give worse error messages
07:48:25 <LoganCapaldo> bringing back monad comprehensions would be cool for a "Database" monad.
07:48:35 <LoganCapaldo> queries and such
07:48:58 <osfameron> the one it actually gave above wasn't much cop either
07:49:13 <sjanssen> instead of the compiler saying "can't match a Bool with a list", it will say "Bool is not an instance of MonadPlus".  Newbies don't know what MonadPlus is.  They might not even know what an instance is
07:49:14 <osfameron> as it doesn't say which variable was the problem, calling it [t] instead
07:49:34 <dolio> I imagine that particular example would be about the same, anyway, since 'x <- [1..10]' already fixes the type to list.
07:49:40 <sjanssen> osfameron: lambdabot truncates the errors -- the full message should have more information
07:49:47 <dolio> Unless you do magic overloading of list literals, too.
07:49:48 <osfameron> ah, ok, yes
07:49:55 <sjanssen> dolio: yeah, that is a good point
07:49:56 <igli> ok in that instance, i'd say "unknown type? y" would be a better message
07:52:06 <dolio> Maybe we want that though. :) '[1..10] :: MonadPlus m, Num n => m n'
07:52:26 <sjanssen> that's a little bit evil
07:52:45 <shapr> SHAZAM!
07:53:12 <byorgey> KABLOOIE!
07:53:43 <byorgey> > [1..10] :: (MonadPlus m, Num n) => m n
07:53:44 <lambdabot>  Couldn't match expected type `m n' against inferred type `[a]'
07:53:52 * sjanssen wonders if shapr has the wisdom of Solomon
07:54:03 <sjanssen> or the strength of Hercules
07:55:15 <shapr> No, but I have the strength to lift lambdas with a single CPU!
07:55:59 <byorgey> that's amazing
07:56:26 <kaol> @src liftM
07:56:26 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
07:56:55 <opqdonut> @. undo src liftM
07:56:56 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 2, srcColumn = 1}) "Parse error"
07:56:56 <jfredett> @type liftM
07:56:58 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
07:57:31 <kaol> @src liftM2
07:57:31 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
07:58:13 <cjeris> "Shaprzam" ... sounds Polish
07:58:38 <osfameron> does that lift monads which are twice as heavy?
07:59:03 <LoganCapaldo> No, it just lifts a monad in each hand
07:59:25 <osfameron> harr!
08:00:22 <byorgey> you know what they say, a monad in each hand is better than two in the bush... no wait...
08:01:09 <jfredett> if this were not a family chat channel, I might say something about that...
08:01:17 <malcolmw> s/m/g
08:01:27 <DRMacIver> Hand me a long enough monad and I will move the world?
08:01:38 <DRMacIver> (Monads are the new lions apparently)
08:01:52 <cjeris> jfredett: yeah, well, the first time I tried to explain what was different about Haskell to my wife, her response was "Monad?  Is that when you only have one ball?"
08:02:03 <byorgey> lol
08:02:11 <jfredett> ...
08:02:19 <jfredett> frakking brilliant.
08:02:19 <osfameron> the existence of liftM and liftM2 seems a bit boilerplatey to me (though given haskell's concision in most everything else, that might seem a bit churlish?)
08:02:44 <LoganCapaldo> osfameron: how do you mean?
08:02:44 <byorgey> osfameron: don't forget about liftM3, liftM4, ...
08:02:47 <jfredett> yeh- this func and func2's and funcN's
08:02:57 <osfameron> yeah, thems
08:03:05 <jfredett> it strikes me that there should just be one, which take an n-arity function
08:03:38 <osfameron> but haskell doesn't have varargs, and that seems to be a lot of where it derives its expressive power from, so hard to see how
08:03:39 <byorgey> osfameron: it's true, but with static typing there's really no way around it except using some sort of metaprogramming (e.g. Template Haskell)
08:03:48 <jfredett> like-- funcN :: a1 -> (a1 -> a2 -> ... -> b) -> b
08:04:06 <LoganCapaldo> > let f x y z = x + y + z in return f `ap` (Just 2) `ap` (Just 4) `ap` (Just 6)
08:04:15 <lambdabot>  Just 12
08:04:48 <osfameron> oh yeah, `ap` seemed the sensible thing when I looked at it, though I haven't worked it out yet...
08:05:40 <byorgey> > let f x y = x + y in f <$> (Just 2) <*> (Just 4)
08:05:41 <lambdabot>  Just 6
08:05:58 <LoganCapaldo> @type <$>
08:06:00 <lambdabot> parse error on input `<$>'
08:06:12 <Saizan> (<$>) = fmap
08:06:14 <LoganCapaldo> @typ (<$>)
08:06:16 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
08:06:19 <LoganCapaldo> ah
08:06:31 <LoganCapaldo> @ty (<*>)
08:06:32 <byorgey> <*> is sequencing for applicative functors
08:06:33 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
08:06:40 <Saizan> aka ap
08:07:25 <LoganCapaldo> > let f x y = x + y in f `liftM` (Just 2) `ap` (Just 4)
08:07:26 <lambdabot>  Just 6
08:11:15 <Saizan> however printf does have varargs
08:11:31 <oerjan> @typ printf
08:11:33 <lambdabot> forall r. (PrintfType r) => String -> r
08:11:52 <osfameron> eeek!  there's printf in haskell!
08:12:02 <Saizan> :D
08:12:05 <osfameron> I thought I read a functional pearl on doing it with strongly typed combinators
08:12:07 <osfameron> which was cute
08:12:12 <osfameron> @src printf
08:12:13 <lambdabot> Source not found. stty: unknown mode: doofus
08:12:21 <byorgey> osfameron: there have been several, I think
08:12:27 <Saizan> @source Text.Printf
08:12:27 <lambdabot> http://darcs.haskell.org/packages/base/Text/Printf.hs
08:13:17 <LoganCapaldo> > printf "Through the %s magic of overloading, I am both an IO action and sprintf" "black" :: String
08:13:19 <lambdabot>  "Through the black magic of overloading, I am both an IO action and sprintf"
08:13:25 <LoganCapaldo> > printf "Through the %s magic of overloading, I am both an IO action and sprintf" "black" :: IO ()
08:13:27 <lambdabot>  <IO ()>
08:14:08 <osfameron> eeek!
08:14:50 <opqdonut> woah
08:15:05 * SamB wonders how to OCR a bunch of code where many of the letters and numbers are broken up
08:15:36 <osfameron> @type printf "%d %s\n"
08:15:38 <lambdabot> forall r. (PrintfType r) => r
08:15:47 <oerjan> so could liftMn be done similarly?
08:17:09 <osfameron> oh, it is actually magic, not plain haskell?
08:17:14 <Saizan> good question, the types are more vague
08:17:25 <Saizan> osfameron: it's just typeclass hackery
08:18:07 * byorgey wonders if there is such a thing as "plain" haskell
08:18:18 <Saizan> h98 :)
08:18:30 <SamB> how about h98 + heirarchical names?
08:18:48 <edwardk> oerjan: it could, but you might wind up stuck with some explicit type signatures floating around due to ambiguities, printf doesn't expect function arguments, and sometimes you may only lift some of your arguments into the monad, no?
08:19:21 <byorgey> I meant more in the sense that all of Haskell is magical...
08:19:24 <ndm> FFI + heirarchical
08:19:33 <ndm> probably, since there is an official FFI report
08:19:37 <edwardk> @type liftM (+)
08:19:39 <lambdabot> forall a1 (m :: * -> *). (Num a1, Monad m) => m a1 -> m (a1 -> a1)
08:19:42 <DRMacIver> byorgey: I'm sure there is.
08:19:42 <SamB> ndm: that isn't plain
08:19:52 <SamB> ndm: see, if you do that you are also using C
08:20:01 <SamB> even if it is fairly standard
08:20:17 <DRMacIver> byorgey: It's perfectly possible to write haskell as quite normal functional code with imperativity bits contained in monads for IO, etc. It's just that Haskell warps your mind so you don't want to do that. :)
08:20:32 <edwardk> dr: hehe
08:20:53 <byorgey> DRMacIver: right. =)
08:20:54 <DRMacIver> It's like a good version of what perl does to people. ;)
08:21:14 <byorgey> it's so true...
08:21:19 <byorgey> <-- still recovering from Perl
08:21:38 * edwardk is also a recovering perl addict.
08:21:46 * osfameron is still enjoying Perl :-)  (well, mainly)
08:21:50 <ptolomy> Hey, I was looking at http://blog.plover.com/math/choose.html, and I was wondering: "Does the IORef based iterative version end up being faster?".. it seemed the answer was "no".. are such solutions usually faster? Also, would a tail recursive transformation break the operation order of his final solution?
08:21:52 <lambdabot> Title: The Universe of Discourse : How to calculate binomial coefficients
08:22:05 <SamB> I thought the HTML generation library was lame.
08:23:26 <byorgey> osfameron: nothing wrong with that, I still enjoy Perl too... just trying to get away from the Perl style of thinking.
08:25:05 <osfameron> byorgey: oh, well, I'm definitely trying to get away from *some* styles of Perl thinking, but there are still many more left to choose
08:25:18 <byorgey> osfameron: true.
08:27:36 <ndm> yay, two papers submitted to Haskell Workshop!
08:27:45 <kolmodin> ndm: well done!
08:28:05 <kolmodin> the deadline is today, isn't it? :)
08:28:13 <ndm> yep
08:28:24 <kolmodin> that's two more papers than I submitted...
08:28:25 <kolmodin> :/
08:29:21 <Philippa> ndm: cool, good luck
08:29:47 <ndm> cheers :)
08:29:53 <matthew_-> only 19 hours 30 mins until the deadline folks!
08:30:37 <kolmodin> that's more than one hour per page if you start now. you can do it!
08:31:03 <matthew_-> kolmodin: they don't *have* to be 12 pages long. They can be less
08:31:14 <kolmodin> mm. true
08:31:17 <matthew_-> and so long as you litter the text with cites, you get a page for free!
08:31:19 <ndm> i'm now going to go and release the Uniplate library, so people can try out hte code
08:31:41 <malcolmw> I see the ICFP acceptance list has just been published
08:31:55 <ndm> yep
08:33:15 <pejo> malcolmw, on the ICFP homepage?
08:33:24 <malcolmw> on haskell-cafe
08:40:03 <matthew_-> I can't wait til September, I want to read those papers NOW!
08:40:07 <edwardk> =)
08:40:28 <pejo> Atleast SPJ has his stuff on his homepage. Same with dcoutts/dons
08:40:56 <matthew_-> I wish SPJ would produce bibtex entries with his papers
08:41:14 <matthew_-> I hate spending 10+ mins wanding around trying to find or work out the damn bibtex...
08:41:25 <matthew_-> *wand/er/ing*...
08:41:42 <quicksilver> grats to dons and dcoutts and everyone else
08:47:52 <Vq^> @pl \x -> uncurry (***) ((max *** min) x)
08:47:52 <lambdabot> uncurry (***) . (max *** min)
08:48:21 <SamB> matthew_-: have you suggested it?
08:49:31 <matthew_-> SamB. Err no.
08:51:15 <SamB> matthew_-: do!
08:51:44 <ptolomy> Hm.. I remember seeing code with unboxed IORefs somewhere.. is that even possibe?
08:51:57 <SamB> ptolomy: hmm?
08:52:14 <ptolomy> IOURef or something. :-/
08:52:18 <SamB> heh
08:52:21 * ptolomy scrounges.
08:52:22 <SamB> IOUArray, maybe
08:54:46 <ndm> matthew_-: i agree, just remember {Peyton Jones} in the entires
08:55:04 <matthew_-> ndm: yep, just went through my bibtex about an hour ago searching for those!
08:55:17 <matthew_-> ndm: what year PhD are you?
08:55:27 <ndm> matthew_-: 3rd
08:55:39 <matthew_-> ndm: write-up going well?
08:55:51 <ndm> matthew_-: no write up at all yet, just a couple of papers
08:56:57 <matthew_-> ahh.
08:57:25 <ndm> but two chapters have had all their work done for them
08:57:27 <ndm> and been released
08:57:38 <ndm> and have papers which are overflowing at 12 pages
08:57:45 <matthew_-> it's just as well easychair doesn't limit the number of times you can resubmit a paper...
08:58:24 <ndm> i got them both first time :)
08:58:37 <ndm> although it is a bit scary that easychair doesn't work well with cs.york.ac.uk addresses
08:58:41 <matthew_-> oh?
08:58:44 <ndm> lucky i have good old reliable gmail
08:58:55 <ndm> yes, apparently easychair and our virus scanner have a fight about some worm
08:58:59 <matthew_-> ahh
08:59:07 <matthew_-> I've submitted about 10-times today...
08:59:36 <matthew_-> "oh look, another mistake... <tap-tap, click-click> ... time to resubmit, again"
09:00:29 <ptolomy> SamB: Aha. Bulat's ArrayRef library has IOURefs.
09:00:43 <SamB> interesting
09:00:59 <SamB> that sounds even more useless than IOUs
09:01:07 <SamB> ;-)
09:02:50 <ptolomy> I would imagine that an IOURef would just compile down to mutable native type, which seems like it would be useful for performance-sensitive code. Do normal IORef Int just compile down to native normally?
09:04:22 <LoganCapaldo> @src IORef
09:04:22 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
09:04:33 <LoganCapaldo> @src STRef
09:04:33 <lambdabot> data STRef s a = STRef (MutVar# s a)
09:04:48 <LoganCapaldo> @src MutVar#
09:04:48 <lambdabot> Source not found. It can only be attributed to human error.
09:05:13 <LoganCapaldo> I guess that's the end of the line
09:05:56 <matthew_-> well, that stuff is in GHC Prims or there abouts
09:06:08 <matthew_-> and even with the source code of GHC, I struggle to follow it further...
09:09:59 * ptolomy really needs to read the papers on how ghc generates machine code..
09:14:05 <sjanssen> ptolomy: no, an IORef Int will still have a boxed representation
09:14:37 <ndm> edwardk: released Uniplate, the library and paper are now available
09:16:43 <SamB> MutVar#s are especially boxed
09:17:36 <SamB> ... I think, to have an IOURef, you'd need to use a MutByteArr#
09:18:33 <SamB> http://www.haskell.org/ghc/docs/latest/html/libraries/base/GHC-Prim.html#12
09:18:35 <lambdabot> http://tinyurl.com/298ag5
09:19:39 <misterPhyrePhox> what's the convention related to appending ' to a function name? what does that mean?
09:20:03 <sjanssen> misterPhyrePhox: sometimes in means strict
09:20:13 <sjanssen> s/in/it
09:20:36 <misterPhyrePhox> sorry, like strict as opposed to lazy evalutation? i'm new to haskell ;_;
09:21:05 <osfameron> oh, I thought it was "alternative" or "auxhiliary" ?
09:21:06 <sjanssen> yeah, it generally means the function is a strictly evaluated equivalent of a lazy one
09:21:18 <sjanssen> osfameron: there's that use too
09:21:25 <sjanssen> misterPhyrePhox: do you have an example?
09:21:27 <osfameron> ah, ok, that being in a let clause mainly
09:21:33 <LoganCapaldo> a strict version of a function is an alternative version after all
09:21:50 <LoganCapaldo> they're not incompatible :)
09:21:52 <osfameron> heh, true
09:22:05 <misterPhyrePhox> i've just seen it around in code i've been looking at
09:22:16 <misterPhyrePhox> i thought there was no strict evaluation in haskell
09:22:36 <LoganCapaldo> There's "stricter" evaluation
09:22:40 <sjanssen> misterPhyrePhox: there's a primitive called 'seq' that forces evaluation
09:23:15 <sjanssen> ' is also common in worker/wrapper code
09:23:44 <LoganCapaldo> seq and ye shall (a -> Bool) -> [a] -> Maybe a
09:23:58 <sjanssen> for example, map f xs = map' xs where map' (x:xs) = f x : map' xs; map' [] = []
09:24:46 <misterPhyrePhox> i see
09:24:49 <misterPhyrePhox> thanks
09:26:00 <olsner> @hoogle (a -> Bool) -> [a] -> Maybe a
09:26:01 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
09:26:05 <olsner> aah ;-)
09:26:14 <olsner> @quote seq and ye
09:26:14 <lambdabot> No quotes for this person. Have you considered trying to match wits with a rutabaga?
09:26:42 <olsner> @remember <LoganCapaldo> seq and ye shall (a -> Bool) -> [a] -> Maybe a
09:26:43 <lambdabot> Done.
09:26:55 <sjanssen> @flush
09:27:06 <LoganCapaldo> at flush?
09:27:42 <sjanssen> LoganCapaldo: flushes lambdabot's state to disk
09:27:54 <LoganCapaldo> aha
09:30:45 <LoganCapaldo> > let listToMaybe = find (const True) in listToMaybe [1,2,3]
09:30:47 <lambdabot>  Just 1
09:31:44 <olsner> is there an obfuscated haskell contest?
09:31:57 <sjanssen> olsner: there have been in the past
09:32:03 <sjanssen> @google iohcc
09:32:05 <lambdabot> http://lambda-the-ultimate.org/classic/message5790.html
09:32:05 <lambdabot> Title: LtU Classic Archives
09:32:44 <LoganCapaldo> I want to see a "Shortest (fewest number of functions not defined in terms of other functions) Prelude contest"
09:33:12 * Igloo submits the empty Prelude
09:33:35 <olsner> (that still implements the standard prelude, I assume?)
09:33:35 <LoganCapaldo> The Prelude is empty?
09:33:45 <LoganCapaldo> olsner: yeah that was the idea :)
09:34:24 <Igloo> Oh, I see. So presumably you actually want the shortest prelude with no functions defined in terms of other functions?
09:34:40 * Igloo still doesn't think I understand the requirements
09:35:00 <LoganCapaldo> Igloo: I want to see the "most combinatorial" prelude
09:35:00 <Saizan> i think he wants the prelude with the least number of "primitive" functions
09:35:12 <Igloo> Oh, I missed the "not"
09:35:14 <olsner> you could also measure the smallest number of function applications, or characters
09:35:34 <Igloo> So you just wanted the Prelude rewritten in as few bytes as possible without loss of functionality, right?
09:36:05 <Igloo> Except you probably don't want to include things like definitions of IO, Int
09:36:23 <LoganCapaldo> Yeah
09:36:34 <LoganCapaldo> Although i wish there was a better metric than bytes
09:36:42 <olsner> the smallest prelude should be the one where preludeFunc = primitiveFunc for some efficient coding of primitive function names
09:36:45 <Igloo> Lexemes?
09:36:52 <olsner> and that's plain cheating
09:36:54 <LoganCapaldo> yeah that sounds better
09:37:10 * Igloo suspects it's not very interesting as the functions are all small
09:37:34 <LoganCapaldo> mm
09:37:40 <Igloo> BICBW
09:37:54 <LoganCapaldo> BICBW?
09:38:13 <Igloo> But I Could Be Wrong
09:38:19 <LoganCapaldo> ah
09:38:54 <olsner> isn't the prelude mostly list operations and various recursions and similar higher-order functions?
09:39:22 <LoganCapaldo> Maybe if the scoring is more complex. The fewest number of "primitive" functions multipled by the number of times a primitive function is used in the definition of non-primitive functions
09:39:40 <LoganCapaldo> Maybe the prelude was a bad example <g>
09:39:44 <LoganCapaldo> ah well
09:40:02 <LoganCapaldo> I gtg, you guys think of a cool contest :)
09:40:29 <Igloo> :-)
09:43:15 <SamB> olsner: obviously, we don't actually want the smallest prelude
09:43:28 <SamB> probably *I'd* want the largest shared part of the prelude
10:38:22 * vincenz hmms "Had a funny comment today during my minicourse on FPL, targettiing darcs"
10:41:02 <vincenz> Someone said "well it definitely seems very efficient to program in" (referring to haskell) "is it efficient?"  At which point I said yes, that it can be efficient and usually is at worst within a factor 2 of C.  At that point someone else, whom I had previously introduced to darcs pointed out to the infinite hanging in darcs, I convinced him that was an algorithmic issue. but yes... why isn't that solved?
10:42:41 <Saizan> lack of man power?
10:42:51 <Saizan> when does it happen?
10:42:52 <Igloo> Because no-one has solved it
10:42:57 <ptolomy> I was under the impression that "it is being worked on, but those who have the expertise required to solve it are busy".
10:43:09 <vincenz> Saizan: I think it's on commits of binary files
10:43:15 <ptolomy> from a PR standpoint, it seems like it is the most important bug.
10:43:27 <ptolomy> People who have never used darcs know that it has an achilles heel.
10:43:43 <vincenz> ptolomy: he experienced it personally
10:43:49 <ptolomy> ouch.
10:43:55 <vincenz> For the rest, I was rather pleased with the uptake of people
10:44:17 <vincenz> Some people I feared would be more skeptical were raelly making an effort to understand and actually said they were partially interested
10:49:38 <pipping> Hi. Is this the right place for questions regarding getting ghc to work?
10:49:44 <emu> sure
10:49:48 <pipping> Alright =)
10:50:03 <pipping> I'm trying to build an ebuild for ghc for gentoo-alt
10:50:11 <pipping> which means, gentoo in a prefix running under macosx
10:50:21 <pipping> the problem is, that i use this tarball:
10:50:32 <pipping> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-apple-darwin-bootstrap.tar.bz2
10:50:34 <lambdabot> http://tinyurl.com/2yhkgq
10:50:47 <pipping> which was apparently created using macports
10:50:59 <pipping> because it is linked against /opt/local/lib/libgmp.3.dylib
10:51:18 <pipping> whereas the library *is* in ~/Gentoo/usr/lib/...
10:51:29 <pipping> i solved that by setting the DYLD_LIBRARY_PATH
10:51:55 <pipping> i still get the problem that ghc looks for Prelude here:
10:51:56 <pipping>         /opt/local/lib/ghc-6.6/imports/Prelude.hi
10:52:01 * ptolomy ponders the haskell-related responses at http://programming.reddit.com/info/1yowd/comments
10:52:02 <lambdabot> Title: Ask Reddit: Let&#39;s be honest.. what task/domain is your language of choice _n ...
10:52:14 <pipping> passing this:
10:52:15 <pipping> -i/Users/pipping/Gentoo/opt/ghc/lib/ghc-6.6/imports/
10:52:18 <pipping> doesn't help
10:52:54 <Igloo> pipping: Did you run configure with the right prefix and make install?
10:53:14 <pipping> well no, i didn't run configure. the tarball contains binaries for bootstrapping
10:53:34 <pipping> i have yet to get the binary to run before i can actually build ghc
10:55:09 <Igloo> pipping: Oh, that's a different tarball than the one I expected, sorry. So why are you using that one rather than http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-apple-darwin.tar.bz2 (or the 6.6.1 equivalent)?
10:55:10 <lambdabot> http://tinyurl.com/32kqzd
10:55:34 <Igloo> That should have a configure script and Makefile so you can install it where you want
10:55:48 <Igloo> If you really need to use the one that you have for some reason, then you need to edit package.conf
10:56:12 <pipping> well i can't build that unless i have a ghc installation, can i?
10:56:24 <pipping> i mean, can ghc be built without bootstrapping?!
10:56:31 <Igloo> That's a binary tarball
10:56:34 <pipping> oh
11:03:31 <pipping> that *does* look promising
11:03:33 <ihope> Hmm. Today's UserFriendly makes me wonder if I can do that in Haskell.
11:03:39 <ihope> A 48k game.
11:03:41 <pipping> and could have saved me a lot of work
11:03:44 <pipping> well, thanks a lot =)
11:06:47 <edwardk> heh a limited memory in haskell seems to me to indicate that you won't be using GHC ;)
11:06:54 <edwardk> er limited memory game competition
11:08:27 <edwardk> I used to enjoy 4k and 64k demo competitions, just have no idea how I'd tackle something like that in haskell.
11:08:51 <opqdonut> aren't those intros rather than demos?
11:09:04 <opqdonut> (might be regional terminology differences)
11:09:18 <edwardk> yeah i think it falls into the domain of terminology differences
11:09:24 <opqdonut> edwardk: well they're made practically only in c/asm hybrid
11:09:36 <edwardk> yeah
11:09:40 <edwardk> i remember =)
11:10:15 * edwardk spent waaay too much time on efnet/ircnet #coders thinking about demo tricks in the mid 90s.
11:10:40 <ihope> Well, GHC doesn't seem to do well for 48k executables.
11:10:59 <edwardk> yeah, jhc maybe? it at least generates small executables
11:11:18 <edwardk> i think 4k demos are out though.
11:11:24 <Codex_> edwardk: I have the same problem with linux. :) It seems making 4k intro is almost impossible with it :)
11:11:57 <ihope> 'main = putStrLn "Hello, World!" compiles to 6,568 bytes vs 177,120 bytes for GHC 6.4'
11:12:10 <Codex_> just opening the window takes 20k :)
11:12:10 <ihope> That sounds good, unless it depends on the "W" being a "W" and not a "w".
11:12:20 <edwardk> well, almost all 64k intros used some sort of compressor. ihope, strip that and gzip it, what does it come down to?
11:12:22 <ihope> You're using a window?
11:13:02 <Codex_> ihope: how else you're going to draw graphics.
11:13:38 <ihope> Output them right to the terminal!
11:13:41 <Codex_> I also tried these ggi things, but they dont seem to work on my laptop very well.
11:13:51 <edwardk> codex: um, build it as an old school dos demo and flip into modex or use ansi graphics ;)
11:14:05 <ihope> Remember your ANSI terminal codes!
11:14:16 <ihope> (Or use a cheat sheet.)
11:14:49 <edwardk> ansi/vt100/vt220 terminal codes are burned into my brain
11:15:19 <Codex_> I actually want real graphics, not some character based simulation :)
11:15:34 <edwardk> the character based stuff makes for fun raytracing, etc.
11:16:05 <thoughtpolice> www.256b.com has some awesome old school demos
11:16:13 <Codex_> my current code looks like this: http://www.kotiposti.net/terop/spheres.png :)
11:16:35 <vincenz> Codex_: you have graphical code?  What language is this?!?
11:17:00 <Codex_> vincenz: sorry to say, but it's c++ :)
11:17:09 <vincenz> Codex_: nono, the graphical code
11:17:15 <vincenz> you said your code looks like 'this' and then showed a sphere
11:17:28 <vincenz> some advanced graphical programming language?
11:17:37 <edwardk> maybe he meant the window behind the sphere? where his c++ shame is trying to hide itself.
11:17:42 <Codex_> a sphere? It ought to have 3 spheres.
11:17:43 <vincenz> can you program in it with the new microsoft multitouch system?
11:18:16 * vincenz sighs and quietly adds </crappy humor>
11:18:22 <edwardk> =)
11:21:00 <ihope> A piece of a sphere covered with little Mandelbrot sets!
11:21:43 <vincenz> oh
11:22:00 <vincenz> I thoguht that was just poor color multitoning or whatever the technical term is
11:22:30 <vincenz> (the stuff we used to get in 16/256 color mode on the old windows 3.1)
11:22:57 <edwardk> vincenz: dithering?
11:23:01 <vincenz> Codex_: make the fractals blue? so they stand out? they didn't pop to me, I thought just shading to get it orange
11:23:04 <vincenz> edwardk: yep, thx
11:23:32 <ihope> Hmm--specialize pragma?
11:23:41 <ihope> What's that do?
11:28:37 <Igloo> Hi dcoutts__
11:28:45 <dcoutts__> @arr
11:28:45 <lambdabot> Aye Aye Cap'n
11:28:46 <dcoutts__> hia
11:29:54 <emu> > 1 +# 1
11:29:55 <lambdabot>   Not in scope: `+#'
11:37:17 <igli> what is # ?
11:38:09 <edwardk> its an 'uglifier' used normally to indicate a primitive or unboxed form
11:38:15 <LoganCapaldo> Its not a valid part of an identifier in Haskell 98 which means ghc is free to use it for its internal stuff w/o fear of namespace collison
11:38:21 <igli> ok
11:39:16 <Lemmih> > let f # x = x f in ['a'..'z']#length
11:39:17 <lambdabot>  26
11:40:19 <ihope> > 1 #+ 1
11:40:20 <lambdabot>   Not in scope: `#+'
11:40:23 <ihope> Mmh.
11:40:35 <ihope> Does Haskell 98 use it for anything at all?
11:40:57 <vincenz> Lemmih: ooh, methods :)
11:41:17 <vincenz> Lemmih: I like your name use 'f' for data and 'x' for function :)
11:41:41 <ihope> (Other than in strings and such.)
11:41:53 <ihope> vincenz: why, functions are data!
11:42:02 <ihope> :-)
11:42:09 <vincenz> not all data are functions, however :)
11:42:30 <ihope> Sure they are. All you need is unsafeCoerce#
11:42:40 <LoganCapaldo> All data are functions
11:42:55 <ihope> They are?
11:42:59 <LoganCapaldo> At least if you convert to the lambda calculus
11:43:06 * vincenz looks at the channel name
11:43:16 <ihope> Indeed.
11:43:17 * vincenz looks at the sample of code above
11:43:35 <Codex_> you can find functions from data, but data is not same as functions. :)
11:43:35 <vincenz> LoganCapaldo: hmm, ok, give me real numbers in lc :)
11:43:41 <ihope> #length there showed up as a channel link here. :-)
11:44:12 <ihope> vincenz: give me some real numbers in ADTs!
11:44:24 <LoganCapaldo> vincenz: Real or floating point? If you want Real, I'll ask you to show me real in Haskell first :)
11:44:46 <vincenz> LoganCapaldo: float :)
11:44:58 <ihope> That makes it easier.
11:45:07 <LoganCapaldo> Sure, you just need a triple of sign, mantissa and exponent
11:45:21 <LoganCapaldo> and all three of those can be represented as natural numbers
11:45:30 <vincenz> LoganCapaldo: well .. .where's my addition operaiton?
11:45:43 <vincenz> btw
11:45:46 <vincenz> nm
11:45:53 <LoganCapaldo> vincenz: I'd think I'd need to charge you to waste that much of my time :)
11:46:02 <Codex_> why need natural numbers when we have successors :-)
11:46:40 <vincenz> LoganCapaldo: alright alrght, I'll keep it simple, integers only
11:46:42 <vincenz> LoganCapaldo: gimme a bitand?
11:47:48 <LoganCapaldo> assume I implement integers as list of bits, you just need to zip and (\a b -> a b a) over the list
11:48:00 <vincenz> assume assume
11:48:17 <LoganCapaldo> You really want to see the definitons?
11:48:18 <vincenz> afaik, church had an encoding!
11:48:33 <vincenz> nah, my bandwidth is limited :)
11:48:36 <vincenz> can't download that much
11:48:51 <vincenz> seriously tho
11:48:52 <LoganCapaldo> heh
11:49:01 <vincenz> is it possible to do bit-operatiosn on church-encoded numbers?
11:49:13 <LoganCapaldo> yes
11:49:33 <sjanssen> why wouldn't it be possible?
11:49:38 <vincenz> cause if you use a different encoding, you'll have to reinvent addition (though granted, bit-based addition exists)
11:49:44 <Codex_> I would assume they are pretty nasty algorithms. (possible yes, easy no.)
11:49:47 <vincenz> I dunno, the encoding doesn't seem too amenable to it
11:49:52 <vincenz> the encoding is not bit based at all
11:49:57 <vincenz> not even conceptually
11:50:13 <Heffalump> that doesn't make it impossible, just unpleasant
11:50:18 <LoganCapaldo> you take your church number and unfold it into a list of bits, do you bit wise ops and then fold it back to a church numeral
11:50:25 <LoganCapaldo> At least that's one way
11:50:50 * vincenz was hoping for something more straightforward
11:51:16 <sjanssen> the other option is to represent numbers as lists of bits
11:51:18 <LoganCapaldo> well there might be
11:51:57 <LoganCapaldo> I guess it depends on how bad you want them to be the n-fold composition definition
11:52:10 <LoganCapaldo> if you jsut start with lists of bits it's "easy"
11:52:41 <vincenz> true
11:55:25 <LoganCapaldo> Anything Turing can do, Church can do better, sooner or latter Church is better than Turing. No he's not. Yes he is! No he's not, No he's no he's not!
11:55:33 <LoganCapaldo> :)
11:55:55 <sjanssen> @remember LoganCapaldo Anything Turing can do, Church can do better, sooner or latter Church is better than Turing. No he's not. Yes he is! No he's not, No he's no he's not!
11:55:55 <lambdabot> Done.
11:55:57 <vincenz> neither can print to my screen
11:56:00 <sjanssen> @flush
11:56:02 <vincenz> or open a file
11:56:22 <vincenz> so I was wondering about floating point, but yeah, they can be encoded, duh
11:58:50 * Philippa asks LoganCapaldo what the Church Test is
11:59:11 * LoganCapaldo doesn't know that one
11:59:17 <LoganCapaldo> But if you hum a few bars :)
12:00:52 <LoganCapaldo> I find it much easier to think of how to build a turing machine with LC than the other way around
12:03:39 <vincenz> LoganCapaldo: you can extend the same idea to haskell and c:)
12:08:28 <byorgey> hi all
12:08:50 <byorgey> I'm looking for a way to use something that acts like >>= on lists, except discards duplicates
12:09:02 <ndm> @seen Igloo
12:09:02 <lambdabot> Igloo is in #haskell-soc, #haskell-overflow, #haskell, #ghc and #darcs. I last heard Igloo speak 40m 25s ago.
12:09:06 <Igloo> Yo
12:09:08 <ndm> @slap dcoutts
12:09:08 * lambdabot beats up dcoutts
12:09:14 <byorgey> i.e. nub . concatMap
12:09:17 <dcoutts__> oi!
12:09:31 <ndm> oh, actually, i'd better check something else before i start handing out slaps...
12:09:48 <ndm> I'd better upgrade the Cabal in Hugs first
12:09:50 <Igloo> I'm sure he deserves a slap for /something/  :-)
12:10:01 <ndm> I was about to complain about Hugs + Cabal + Spaces + CPP
12:10:09 <ndm> but i've got Hugs Sep 06, so you may well have fixed it
12:10:52 <ndm> hmm, can i upgrade the Cabal in Hugs?
12:11:07 <ndm> since Cabal is written with Cpp...
12:11:24 <dcoutts__> you can use cabal to install cabal :-)
12:11:35 <ndm> on GHC, yes
12:11:48 <ndm> with Hugs? Since it picks up the current Cabal, which has #ifdef in it
12:11:49 * dcoutts__ :: Lunch -> IO ()
12:12:22 * vincenz would hope it's
12:12:36 * vincenz :: Lunch -> IO SomethingUseful
12:12:47 <Igloo> ndm: So what's not working for you?
12:13:04 <Igloo> The hugs build system copies the Setup.hs file elsewhere IIRC
12:13:12 <ndm> Igloo: Hugs + CPP where cpphs is in "Program Files"
12:13:41 <Igloo> Ahh
12:13:46 <ndm> hmm, how do you specify which folder Hugs should look in?
12:13:53 <ndm> i need to remove "." before I can upgrade Cabal
12:14:37 <Igloo> Not sure OTTOMH, but the hugs build process does it
12:14:46 <ndm> -P
12:15:05 <ndm> although I'm not having much success with dropping the rest of Cabal
12:15:38 <Igloo> The simplest way is probably just to build Setup.hs with GHC
12:15:39 <ndm> grr, no i can't upgrade Cabal using Cabal, since you people broke it
12:15:55 <ndm> and run with what commands, to pick Hugs?
12:17:34 <ndm> runhugs: Error occurred
12:17:36 <ndm> ERROR "dist\build\Distribution\Simple\Utils.hs" - Can't find imported module "System.Process"
12:18:56 <ndm> Igloo: ^ is that error fairly fatal?
12:23:21 <Igloo> hugs isn't meant to have System.Process is it?
12:23:53 <ndm> nope
12:24:04 <Igloo> --hugs. Which implementation you use to compile/interpret Setup.hs has no bearing on which it will decide to use AFAIK
12:24:53 <Igloo> ndm: I'm not sure what you're doing, but Utils doesn't use Process under hugs in my repo
12:26:10 <ndm> Igloo: thats latest Cabal, ghc --make Setup, setup configure --hugs, setup build
12:26:32 <ndm> or at least a recent Cabal
12:27:45 <Igloo> Hmm, fair enough, not sure what's going on then
12:28:15 <ndm> i'll just give up, and delete the Program Files copy of cpphs, its enough for now
12:28:28 <ndm> i suspect its fixed in the latest Cabal, you got all those which did the haddock problem
12:31:06 <malcolmw> ndm: I'm about 1/3 way through a mechanical merge of yhc/src/compiler98 and nhc98/src/compiler98
12:31:29 <ndm> malcolmw: results?
12:31:47 <malcolmw> there are only a couple of tiny issues I will need to think about more deeply - it all looks very straightforward so far
12:32:07 <ndm> neat
12:32:28 <malcolmw> lots of whitespace diffs, and extra type sigs
12:32:57 <ndm> yeah, we did add type sigs for the haddock stuff
12:33:09 <malcolmw> always a good thing
12:35:11 <ndm> if we can just common up as many modules as possible, that will be a good thing
12:35:46 <malcolmw> that's exactly what I'm planning to do
12:35:56 <ndm> Scons sucks so badly
12:36:05 <ndm> i'm just adding Uniplate to Yhc.Core (in place of Play) and its horrible
12:36:13 <ndm> its like hacking Cabal, but in Python
12:36:14 <malcolmw> there isn't anything else to share except the compiler modules - RTS and libraries all different
12:37:09 <ndm> we should be moving to the nhc libraries
12:37:13 <ndm> or rather the base libraries
12:37:15 <malcolmw> then yhc will get my pattern-guard addition for free
12:37:19 <ndm> yay!
12:37:38 <malcolmw> and any other fixes to parser, typechecker etc can be shared too
12:37:46 <ndm> we can finally merge them and make the nyhc (new york haskell compiler)
12:38:31 <malcolmw> I don't mind having two separate backends for a while - three actually, if you count Javascript
12:38:44 <ndm> plus Supero
12:38:56 <ndm> we really do need to move to Yhc.Core though, instead of PosLambda
12:39:07 <ndm> and Yhc.ByteCode, since thats cleaner than nhc bytecode
12:39:27 <ndm> if we have a Yhc.Core -> Yhc.ByteCode path, then the front end is almost entirely orthoganol
12:39:33 <oerjan> there's a Javascript backend for Haskell?
12:39:49 <ndm> we can even have a GHC front end to Yhc.Core, and you can combine the good bits of NYhc and GHC
12:39:57 <ndm> oerjan: yes, in Yhc - ycr2js
12:40:27 <malcolmw> like the diagram I draw in the compiler course, with a single intermediate language, and multiple front and back ends
12:40:58 <oerjan> cool, i think
12:41:14 <ndm> yes, we'd have a well engineered compiler!
12:41:27 <ndm> (in 6 or 7 years of refactoring)
12:42:21 <MarcWeber> oerjan: Goto haskell.org and du a JavaScript search.
12:42:21 <malcolmw> 6 or 7 _more_ years
12:42:32 <malcolmw> :-)
12:43:28 <ndm> hmm, Yhc now has uniplate as a dependency, which means it now pulls down a copy of my HW paper in every Yhc checkout
12:44:44 <malcolmw> readable documentation is always a good thing to include
12:45:53 <ndm> but it gets pulled, but not latexed
12:46:52 <malcolmw> you could add a PDF to the repo
12:47:51 <dukedave> Hey team,
12:48:14 <ndm> or just point at the pdf on my website
12:48:18 <hpaste>  Marc Weber pasted "template haskell problem" at http://hpaste.org/289
12:48:58 <MarcWeber> What did I miss?
12:51:38 <dukedave> Could someone guess the name of something for me, I can't remember.. It's to do with types & is the concept that sometimes we can be less specific and refer only to classes not actual types... E.g. We can have a list of 'things which derive Show but are actually different types'
12:51:52 <dukedave> Erk, that wasn't *the* best description I've ever given :)
12:52:17 <sjanssen> dukedave: existentials?
12:52:38 * dukedave Googles
12:52:39 <malcolmw> ndm: the latex source for you paper will be pretty small, so not a big overhead on darcs checkouts
12:53:02 <ndm> malcolmw: nah, it should be fine - just interesting to see it in there - i think there may also be a powerpoint of my plasma talk in there too...
12:53:16 <vincenz> now that's slightly bigger
12:53:26 <ndm> 164Kb, hardly earth shattering
12:53:34 * dukedave Nods
12:53:38 <dukedave> Cheers sjanssen
12:54:35 <sjanssen> so when can I expect pattern guards in nhc/yhc? ;)
12:55:27 <malcolmw> sjanssen: they already work in nhc98
12:56:29 <ndm> malcolmw: but Catch doesn't work though nhc, which is why they are needed
13:00:28 <Igloo> malcolmw: diff -b might help with whitespace
13:00:58 <malcolmw> Igloo: I want the whitespace changes - mostly they remove evil tabs
13:01:28 <ndm> Yhc is Tab free :)
13:01:41 <SamB> is that why you use that wierd build system?
13:01:51 <ndm> Igloo: you still need to release your style guides, since Yhc policy is to follow your unreleased guide
13:02:03 <malcolmw> TextWrangler has a nice clicky interface to diff, which updates one or other file with the changes from the other (chunk by chunk), makes it really fast.
13:02:11 <ndm> SamB, nope, thats entire separate/stupid (depending on your viewpoint)
13:02:41 * ndm pushes and breaks all the Yhc buildbots
13:03:02 * SamB hopes he has those emails filtered out properly
13:03:29 <SamB> I wish buildbot would wait a bit and aggregate them...
13:03:53 <ndm> SamB, file a bug in the bug tracker - we have lots less now, it only sends one when a repo goes from passing to failing
13:04:13 <SamB> oh. that might be good enough then ;-)
13:05:09 <ndm> cat: .current-hash: No such file or directory
13:05:11 <ndm> Fail: Couldn't find patch matching "hash "
13:05:13 <ndm> Xtract: Ran out of input (EOF)
13:05:26 <ndm> malcolmw: i just got that error message when pushing to Yhc, is that your fault?
13:06:28 <dukedave> Error in the wikibook?...    Here: http://en.wikibooks.org/wiki/Haskell/Existentially_quantified_types#Example:_heterogeneous_lists             Am I correct in thinking  the line " hetroList :: [ShowH]" should read " hetroList :: [ShowBox]"?
13:06:30 <malcolmw> ndm: yes - I set up an email collator for darcs push, but forgot to initialise the hash
13:06:32 <lambdabot> http://tinyurl.com/f9umb
13:07:55 <Igloo> Seems likely, dukedave
13:08:33 <dukedave> Well, I'll go ahead & change it.. Can only be shunned from the Haskell community for ever if I'm wrong..
13:08:44 <dukedave> Can always go back to Java
13:08:47 <dukedave> \me shudders
13:09:39 <Heffalump> do we have a shunning procedure?
13:11:22 <dukedave> shun :: a -> Nothing ? :)
13:11:32 <vincenz> nono
13:11:35 <vincenz> it's not that simple
13:11:35 <Heffalump> ah, see, you're a prime candidate. Confusing types with values!
13:11:38 <dukedave> Haha
13:11:41 <sjanssen> lol
13:11:43 <dukedave> I just noticed that :)
13:11:46 <vincenz> shun :: (Shunnable a) => a -> IO Bin
13:11:55 <vincenz> instance Shunnable Heffalump where
13:12:11 <Heffalump> you can't shun me, I'm important!
13:12:20 <Heffalump> Well, I'm important for something. Can't think what...
13:12:28 <malcolmw> ndm: fixed
13:12:29 <vincenz> instance (ListensToHeffalump a) => Shunnable a where
13:13:07 <Heffalump> hah, now you're going beyond Haskell 98
13:13:37 <vincenz> what?
13:13:40 <vincenz> no I'm not
13:13:43 <vincenz> that's perfect H98
13:13:44 <ndm> no, thats haskell 98 shunning
13:13:54 <sjanssen> no, that isn't H '98
13:14:05 <ndm> oh, yes, you have to have a C in Shunnable
13:14:15 <vincenz> hmm?
13:14:29 <ndm> it must be Sunnable (C x y z) where C is a constructor
13:14:32 <sjanssen> instance (Listens a) => Shunnable (C a) -- is valid
13:14:33 <vincenz> OH
13:14:36 <vincenz> thx
13:14:44 <vincenz> why, tho?
13:14:45 <sjanssen> and x, y, z are all unique type variables
13:14:45 <Heffalump> see, you're a much better candidate for shunning than I am.
13:14:50 <sjanssen> vincenz: them's the rules
13:14:56 <vincenz> sjanssen: any reason they were made like that?
13:14:57 <Heffalump> vincenz: because otherwise the instance finder doesn't know what to do
13:14:57 <dcoutts__> malcolmw: sent xerox's mobile number to you
13:15:03 <dukedave> I love this channel sometimes :)
13:15:03 <vincenz> k
13:15:06 <vincenz> seems rather arbitrary
13:15:11 <malcolmw> dcoutts__: having a good holiday?
13:15:13 <ndm> vincenz: remember when they first did type classes, they were completely new, and not well understood
13:15:14 <sjanssen> vincenz: conservative restrictions to prevent overlapping, I think
13:15:18 <Heffalump> suppose you had instance A a => C a, and instance B a => C a, what would it do?
13:15:20 <ndm> (today they are old and not understood)
13:15:23 <dcoutts__> malcolmw: yes, great
13:15:31 <vincenz> sjanssen: ah, thanks
13:15:38 <malcolmw> dcoutts_: free wifi?
13:15:41 <Heffalump> and if you also have instance C (Foo a), how does it know which one to use
13:15:46 <dcoutts__> malcolmw: yep, hotel
13:15:57 <ndm> malcolmw: so now Yhc CVS messages come over cvs-nhc?
13:16:13 <malcolmw> ndm: yes, I wanted to see what you were up to :-)
13:16:20 <ndm> malcolmw: fair enough]
13:18:49 <swiert> dcoutts__: just out of curiousity, where are you?
13:19:09 <vincenz> Heffalump: I see
13:19:13 <vincenz> Heffalump: same problem can still be done tho
13:19:18 <vincenz> instance A a => C (X a)
13:19:22 <vincenz> instance B a => C (X a)
13:20:22 <sjanssen> vincenz: that's easier for the compiler to catch, though
13:20:27 <Heffalump> true. I think my explanation was poor. The key reason is that C a will overlap with everything else.
13:20:30 <Heffalump> like C (X a)
13:20:41 <Heffalump> so you could only ever have that single instance, and then why bother?
13:20:42 <dcoutts__> swiert: Deadwood, South Dakota, USA
13:20:56 <Heffalump> dcoutts__: cool name :-)
13:20:57 <sjanssen> the compiler just has to track a set of (Class, Constructor) to know when instances might overlap
13:21:00 <Heffalump> fits the South Dakota landscape too
13:21:57 <swiert> Wow. What drew you there?
13:23:09 <malcolmw> dinosaurs? :-)
13:23:17 <vincenz> like c++
13:23:17 <vincenz> ?
13:42:55 <ndm> @karma- scons
13:42:56 <lambdabot> scons's karma lowered to -2.
13:43:28 <ndm> and its going to keep loosing karma while it keeps breaking on me
13:43:46 <nominolo> @karma java
13:43:46 <lambdabot> java has a karma of -16
13:44:15 <nominolo> @karma haskell
13:44:16 <lambdabot> haskell has a karma of 24
13:44:46 <cjeris> @karma J
13:44:47 <lambdabot> J has a karma of 1
13:44:58 <oerjan> @karma karma
13:44:58 <lambdabot> karma has a karma of 3
13:45:53 <nominolo> @karma cabal
13:45:53 <lambdabot> cabal has a karma of 5
13:46:10 <nominolo> @karma
13:46:10 <lambdabot> You have a karma of 1
13:47:10 <olsner> trouble with scons, eh? there's been a lot of talk about making some haskell-based build system that will whip the behinds of llamas
13:47:22 <olsner> .. but not much action yet, afaics
13:47:31 <ndm> olsner: Cabal should do it, if cabal was capable
13:47:49 <Heffalump> cabal is a one-language system, though </hobby-horse>
13:47:57 <nominolo> ndm: what do you need?
13:48:37 <ndm> nominolo: Cabal to work reliably, and to make Yhc build with Cabal
13:48:54 <ndm> nominolo: your work will help greatly with that, plus we'd need cabal-install, and a few more bits and pieces
13:49:20 <nominolo> build system + reliable = magic ;)
13:49:48 <ndm> build system + scons = joke
13:50:59 <nominolo> you should see the make-hell we have at my former uni's kernel-poject
13:51:20 <malcolmw> ndm hates makefiles too
13:51:42 <ndm> my favourite makefile system was one i wrote in javascript
13:51:50 <ndm> a really nice use of embedded javascript and evl
13:51:51 <DRMacIver> ndm: Have you been incredibly busy today, or is the fact that my aggregator just dropped 8 of your blog posts on me at once an error? :)
13:51:53 <ndm> eval*
13:52:13 <ndm> DRMacIver: i modified some old ones, to fix up spacing in some elements - it shouldn't have resent them over RSS
13:52:19 <nominolo> after 1 week of fruitless trying i asked one from the team: "yeah, you need that script i wrote some time"
13:52:25 <DRMacIver> ndm: Seems to have.
13:52:33 <ndm> @karma- blogger
13:52:33 <lambdabot> blogger's karma lowered to -1.
13:52:37 <Cale> Any textual file format which requires the ascii tab character is obviously fundamentally flawed.
13:52:40 <DRMacIver> ndm: Dates are all set to new as well.
13:52:52 <olsner> ndm: was that a makefile system as in makefile generator or as in stand-alone build system?
13:52:57 <Heffalump> I find that happens all the time with LJ as an RSS reader.
13:52:58 <ndm> DRMacIver: hmm, in my system they still have their original date
13:53:04 <ndm> olsner: standalone
13:53:04 <malcolmw> SyntaxNinja's blog keeps refreshing all 45 articles in my RSS reader, despite the fact that he hasn't written one for about a year
13:53:19 <DRMacIver> (Not that I mind, as it gave me a chance to reread some of your old posts which I'd missed)
13:53:31 <Heffalump> anyone know what the status of the next londonhug meeting is?
13:53:37 <DRMacIver> ndm: Might be blogbridge's fault.
13:53:45 <DRMacIver> Heffalump: I've been wondering myself.
13:53:50 <olsner> Cale: if you're complaining about the tabs you like makefiles far too much ;-)
13:54:30 <Heffalump> @seen njbartlett
13:54:30 <lambdabot> njbartlett is in #haskell. I don't know when njbartlett last spoke.
13:54:36 <Cale> olsner: My editor smashes tabs into spaces automatically. ;)
13:54:52 <njbartlett> Heffalump: You rang, m'lord?
13:54:57 <Cale> So I clearly don't write all that many makefiles :)
13:54:58 <olsner> and apparently not all make's have that requirement... the OS/2 NMAKE I'm using at work seems to grok any form of indentation
13:55:01 <ndm> DRMacIver: they've got a updated tag, which i guess something must be picking up
13:55:22 <DRMacIver> ndm: Ok. It's probably my reader's fault. :)
13:55:50 <Heffalump> njbartlett: ahah :-) Was just wondering about the next London HUG meeting.
13:56:32 <njbartlett> Status of the next London HUG... yes, I need to organise the next one. The problem is, I was thinking about the next one being 2 months after the first, but then everybody went and voted for having the meetings every month :-)
13:56:46 <Heffalump> :-)
13:56:52 <Igel> good evening alltogether :)
13:57:06 <ndm> njbartlett: just ignore them, and jump for every 2 months
13:57:19 <Igel> has someone experience with haxml?
13:57:25 <Heffalump> I have some.
13:57:45 <malcolmw> I wrote it
13:57:45 <Igel> the thing is, the stdXmlUnescaper seems not to work
13:57:49 <bos> malcolmw would know a little about it, too.
13:58:29 <malcolmw> stdXmlUnescaper was written by George Russell
13:58:32 <Igel> when generating a document, it escapes & to &amp; , < to &lt;, etc
13:58:33 <njbartlett> I think we'll go with what somebody suggested: slightly more "formal" meetings (i.e. with talks in a lecture room every two months, and then the odd months we just chat
13:58:36 <Heffalump> malcolmw: any idea when the next stable release will be, btw? (not pushing, just to plan ahead a bit)
13:59:16 <Igel> but when reading a document, its weird
13:59:41 <Igel> eg &amp;&amp;&amp; is resolved to just "&"
14:00:02 <Igel> &amp;lt; is resolved to "<"
14:00:04 <malcolmw> Heffalump: no timescale, but there aren't many features to add
14:00:14 <njbartlett> lgel: solution is don't program with arrows ;-)
14:00:40 <Igel> the thing is, its about messages being transportet via xml
14:00:42 <malcolmw> Igel: oops, looks like there is a recursive call in the wrong place
14:00:46 <Igel> messages the user enters ;)
14:01:23 <Igel> i copied the code of xmlStdEscaper and played around with it a little
14:01:37 <Igel> but i don't see the pattern
14:02:05 <Igel> and i didn't spend hours reading source code ;)
14:02:14 <fasta> Why doesn't GHC have mutually recursive modules?
14:02:27 <fasta> I mean a system where the user doesn't need to anything special.
14:02:47 <Heffalump> because that would be implementation effort that noone has spent the time on?
14:02:51 <Heffalump> at a guess
14:03:02 <Heffalump> you could imagine a separate tool that made .hs-boot files
14:03:07 <fasta> Heffalump: how much effort are we talking about?
14:03:20 <Heffalump> No idea. Quite a bit of dependency analysis, at a guess.
14:04:09 <fasta> I need to jump to hoops now to get around this limitation.
14:04:16 <bos> fasta: use yhc :-)
14:04:22 <ndm> fasta: you can no longer type check each module separately, it breaks separate compilation
14:04:34 <ndm> bos: Jhc supports it, Yhc doesn't
14:04:43 <bos> oops, wrong letter
14:04:50 <Heffalump> but you can't with .hs-boot files either
14:04:57 <ndm> Yhc can
14:05:04 <Heffalump> can what?
14:05:13 <igli> Igel: sounds like it's an xhtml doc to me
14:05:18 <ndm> do .hs-boot files (or equivalent)
14:05:30 <Heffalump> I mean that they break separate compilation too, really.
14:05:45 <Igel> igli: no, its mere xml
14:05:47 <fasta> ndm: I find those arguments weak, since the only other solution I know of is to put those two modules into one.
14:05:54 <Heffalump> at least if you consider them logically connected to the thing they are .hs-boot files of, rather than to the thing that {-# SOURCE #-} imports them.
14:06:05 <igli> Igel: ah ok that's it then
14:06:06 <ndm> fasta: i agree
14:06:15 <fasta> ndm: (I know it are not your arguments)
14:06:21 <Igel> how do you mean this?
14:06:27 <ndm> fasta: although usually you can layer it properly, and not end up with super-large modules
14:06:35 <ndm> fasta: the other option is keep them separate and use CPP to join them up
14:06:39 <igli> &amp; is & and then &lt; is less than; so take away one &amp; every time
14:06:45 <Heffalump> that has different semantics, though
14:06:48 <igli> or add one to produce
14:06:57 <Heffalump> like the clause in the monomorphism restriction I can never remember
14:07:14 <ndm> but is likely to be a close enough semantics
14:07:29 * ndm hates the monomorphism restriction
14:07:36 <kolmodin> oh?
14:07:41 <Heffalump> oh, and name qualification
14:07:45 <ndm> or the "silly-premature-optimisation" restriction, as i prefer to call it
14:07:45 * Heffalump doesn't like it much either
14:07:58 <Heffalump> it's not just about that, though
14:08:04 <ndm> i know :)
14:08:18 <Igel> igli: huh? i dont really get what you mean
14:08:23 <Heffalump> there's also the "end up with a constrained type whose constrained variables aren't mentioned" problem.
14:08:25 <ndm> fasta: there was a great paper on how to do the appropriate module compilation with mutual recursion
14:08:27 <Igel> are you speaking of the unescaping process?
14:08:41 <ndm> Hacle does recursive modules
14:08:48 <ndm> so just compile to Clean
14:09:42 <igli> er sorry Igel came in at end of conversation, thought you were trying to process this stuff.
14:10:21 <Igel> no, i'm trying to find out what goes wrong in text.xml.haxml.escape :]
14:13:04 <fasta> ndm: mutually recursive modules are in H98, right?
14:13:10 <ndm> fasta: yes
14:13:20 <fasta> That makes it even more ridiculous.
14:14:00 <ndm> fasta: submit a patch for Yhc which allows it and we'll happily apply it
14:16:12 <Igel> can someone clear up this Reference type to me?
14:16:47 <Igel> looks like i need to know what it is when trying to read the unEscapeXY functions :)
14:16:54 <Igel> but it's not documented, is it?
14:17:14 * ekidd begins the final edit of his probability monad paper
14:18:38 <ndm> ekidd: for Haskell Workshop?
14:18:49 <ekidd> ndm: Yup.
14:18:58 <ndm> ekidd: 12 hours left yet
14:19:19 <malcolmw> Igel: Reference is either an entity ref e,g. &amp; or char reference e.g. &#20;
14:19:28 <ekidd> When's the actual deadline? I don't quite have a handle on this whole timezone business.
14:20:11 <Igel> malcolmw: so EntityRef "blah" is equivalent to "&blah;" in the raw document and CharRef 'c' to "c" ?
14:20:21 <ndm> ekidd: 12 hours, i think
14:20:46 <ndm> ekidd: but get hte world clock and western samoan time up to check
14:20:51 <malcolmw> Igel: more or less
14:21:06 <Igel> ok, thanks - that clears up things a bit
14:21:07 <ekidd> So it's midnight in Samoa? :-)
14:21:18 <ekidd> That's a pretty amusing deadline.
14:21:45 <ndm> yes
14:22:04 <ndm> thats the last place in the world where its midnight, so if you made it by midnight local time (whereever you are) you are in time
14:22:45 <Igel> @localtime ndm
14:22:46 <lambdabot> Local time for ndm is 15 June 2007 10:22:03 pm
14:22:54 <olsner> @localtime
14:22:56 <lambdabot> Local time for olsner is 2007-06-15 23:22:03 +0200
14:23:48 <Heffalump> @localtime Sydney
14:25:12 <Heffalump> are deadlines before the weekend better than deadlines after the weekend?
14:25:52 <Igel> i dont think so
14:26:07 <Igel> at least not for the one placing the deadline :)
14:26:36 <Heffalump> I mean for people working towards the deadline.
14:26:48 <ndm> i prefer before the weekend - since if want feedback from Colin I can't get that over the weekend
14:27:36 <ndm> i liked this deadline, since i got all my stuff in by 4pm
14:28:35 <Heffalump> does the system allow updated submissions?
14:28:57 <swiert> You can resubmit and upload a new pdf.
14:30:06 <Igel> i dont find anything wrong in haxml.escaper^^
14:30:06 <ndm> yes
14:30:15 <ndm> the system doesn't like cs.york.ac.uk
14:30:22 <Igel> wich of course doesnt mean anything^^
14:30:46 <Igel> but as far as i see it just replaces this refs with a fitting string
14:30:53 <Heffalump> doesn't like it in what way?
14:31:21 <Igel> i could imagine that the error happens at a lower level, where the actual '&'s are treated
14:31:47 <ndm> it claims we bounce emails from them, and gets very upset
14:31:57 <ndm> it says that the york server thinks their emails are worms
14:32:20 <malcolmw> Igel: perhaps it is in the way you are you using the xmlEscaper
14:32:57 <bos> did i miss a response to the question about when there might be an update to HaXml?
14:33:14 * ndm heads home, bye!
14:33:41 <Igel> malcolmw: well i've got a function:   parseMessage check (Document _ _ elem _)
14:33:41 <Heffalump> bos: yes. malcolmw said that there's no timescale but not very many new features to add
14:33:57 <Igel> where
14:33:58 <Igel> (Elem name attrs conts) = xmlUnEscape xmlEscaper elem
14:34:07 <bos> Heffalump: thanks
14:34:19 <Igel> so i'm just calling xmlUnEscape on the root element
14:34:29 <Igel> is that not correct?
14:34:47 * Heffalump tries to get his head around haskelldb
14:45:46 <vincenz> Heffalump: sounds painful
14:48:16 <malcolmw> Igel: I wonder if it isn't supposed to be xmlEscape there, rather than xmlUnEscape
14:49:12 <Igel> its the parser
14:51:11 <malcolmw> I'll make a note to look into it as a possible bug (on Monday)
14:51:33 <Igel> thanks
14:56:00 <Igel> thanks
14:58:10 <Igel> malcolmw: this might help you: we've got an xml-generator and -parser here and quickchecks, that verify parse.generate == id
14:58:27 <Igel> the generators output is alright (also escaped)
14:58:48 <Igel> s/verify/verifies/
14:58:49 <malcolmw> Igel: are you offering to supply them?
14:59:17 <Igel> i would have to talk to the rest of the team before that, but i dont think its a problem
14:59:38 <Igel> its a project at our university^^
15:00:58 <malcolmw> I can promise not to store them beyond fixing this bug, if you like (although it sounds like they might be cool tools to integrate into HaXml and distribute more widely)
15:01:45 <Igel> well we'd just have to make sure the code is actually ours ;)
15:02:10 <Igel> its no great secret project, rather a practical course in software engineering
15:04:06 <Igel> let's just talk again in a day or two when i had a chance to talk to the others
15:04:40 <sorear> hello!
15:06:19 <Heffalump> evening
15:06:29 <DRMacIver> Hi
15:10:43 * SamB wants an anti-boilerplate where the generic show would work the same as the real show for Data.Map.Map
15:15:17 <gwern> I'm hoping someone can jog my memory. I vaguely recall oleg showing a while ago that '98 type classes were surprisingly powerful, and could be used to implement X, where X is some powerful and general ability. but I can't remember what X is!
15:15:45 <oerjan> isn't that what he usually does? :)
15:16:07 <ekidd> My probability monad paper draft: http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
15:16:09 <lambdabot> http://tinyurl.com/276u5w
15:16:22 <DRMacIver> ekidd: Oh, cool. Some reading for the weekend. :)
15:16:28 * ekidd is proofreading
15:16:38 <DRMacIver> Hm. That sounded sarcastic, but it wasn't.
15:16:44 <ekidd> DRMacIver: Just save the URL, and you can grab an updated version later. :-)
15:17:03 <DRMacIver> I had a look at the probability monads stuff a a while ago and it seemed really neat.
15:17:30 <DRMacIver> ekidd: Will do. :)
15:17:47 <ekidd> Not being a proper academic, I have no real idea if this adds up to an actual paper or not. Oh, well. :-)
15:18:31 * ekidd now only suffers from mild anxiety, as opposed to the soul-crushing despair of several days ago, when he had several sections left to write.
15:23:44 <ddarius> Free M-sets! What a deal!
15:24:51 <vincenz> ekidd: welcome to the wonders of paper-writing :)
15:25:31 <ekidd> ddarius: M-sets! Come and get your M-sets!
15:25:46 <ekidd> One careful owner from new!
15:26:54 <ekidd> vincenz: Oh, man. I wrote an undergrad thesis on generic function dispatch, and it didn't prepare me for this at all.
15:27:19 <vincenz> :)
15:27:37 * SamB giggles at "express the program in problem-language using alphabetic words and easily understood numbers and symbols" being used to describe what an assembler allows
15:30:37 <Saizan> such an high level language!
15:30:58 <Saizan> you don't know where your bits are
15:37:08 <titusg> When I try to import ByteString I get: Could not find module `Data.ByteString.Char8' it was found in multiple packages: fps-0.7 base' ... ?
15:38:06 <sjanssen> titusg: you shouldn't install fps when you're running ghc 6.6
15:39:28 <titusg> sjanssen: erm, I didn't know that I had! What do I need to get rid of?
15:39:41 <oerjan> @type liftM `asTypeOf` liftM2
15:39:42 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a2)
15:39:42 <lambdabot>     Probable cause: `liftM2' is applied to too few arguments
15:40:31 <oerjan> @type liftM3 `asTypeOf` liftM2
15:40:33 <lambdabot>     Occurs check: cannot construct the infinite type: m = (->) (m a3)
15:40:33 <lambdabot>     Probable cause: `liftM2' is applied to too many arguments
15:40:58 <vincenz> what's the use of asTypeof?
15:41:05 <sjanssen> titusg: did your distribution install it for you, perhaps?  You can 'ghc-pkg unregister fps' but that's not a true uninstall
15:41:05 <vincenz> @type asTypeOf
15:41:07 <lambdabot> forall a. a -> a -> a
15:41:14 <oerjan> force two terms to have the same type
15:41:15 <vincenz> @src asTypeOf
15:41:15 <lambdabot> asTypeOf = const
15:41:19 <vincenz> o.O
15:41:23 <vincenz> oerjan: why?
15:41:31 <SamB> vincenz: because you wish for them to be
15:41:39 <sjanssen> > undefined `asTypeOf` True
15:41:40 <lambdabot>  Undefined
15:41:56 <SamB> vincenz: say you got a parameter of some type a...
15:41:57 <sjanssen> > maxBound `asTypeOf` 'a'
15:41:59 <lambdabot>  '\1114111'
15:42:00 <vincenz> SamB: most things already have very specific types, with static tpying and typeinference and all...
15:42:18 <SamB> vincenz: it has it's uses
15:42:26 <vincenz> okk
15:42:58 <vincenz> sjanssen: isolated case, in bigger code one would assume the maxBoudn to be constrained by use
15:43:14 * Saizan have used it monomorphic restriction and phantom parameters
15:43:15 <sorear> vincenz: Also, asTypeOf predates type signatures.
15:43:18 <titusg> sjanssen: that's done it, thanks very much
15:43:21 <SamB> when you get errors because of ambiguous types, you might appreciate it sometime
15:43:34 <vincenz> SamB: thx for that tip :)
15:43:37 <sorear> vincenz: Once upon a time it was the only reasonable way to make show . read typecheck :)
15:43:37 <vincenz> good idea :)
15:43:50 <SamB> especially when the type you want it to be isn't named
15:44:05 <SamB> (it has to do with the non-scopednes of type variables, partly)
15:44:10 <vincenz> SamB: "predicates type signatures"?
15:44:16 <vincenz> s/samb/sorear
15:44:20 * vincenz kicks his [tab]
15:45:03 <sjanssen> vincenz: if you quoted sorear correctly you'd see that he meant "predates" :)
15:45:15 <vincenz> OH :)
15:45:23 <vincenz> yay for latenight working
15:46:18 <SamB> once we have scoped type variables, asTypeOf will probably be unneeded
15:46:30 <SamB> but might be more concise in some situations anyway
15:46:53 <SamB> sorear: where did you learn all this history
15:47:00 <sorear> SamB: #haskell
15:47:02 <SamB> I want a Haskell History book that explains all this
15:47:35 <SamB> I want to read about the bloody Monadic Revolution
15:47:38 <sjanssen> the HOPL paper?
15:47:47 <SamB> sjanssen: how many pages?
15:47:57 <sjanssen> it isn't that detailed, but it's still very fascinating
15:47:58 <Heffalump> sorear: by asking people, or reading logs?
15:48:12 <SamB> Heffalump: I don't think #haskell is that old ;-)
15:48:16 <sorear> Heffalump: Asking and lurking...
15:48:18 * Heffalump has been on #haskell for ages and doesn't remember learning all that much history :-)
15:48:28 <vincenz> idem
15:48:31 <Heffalump> but then I'm quite lazy
15:48:37 <vincenz> and I have a terrible memory
15:48:40 <sorear> Heffalump: You probably don't lurk 8hrs a day :)
15:48:45 <Heffalump> both intellectually and in doing things terms
15:48:51 <Heffalump> I did at one point, but it was a lot quieter then
15:48:54 * sorear also has a good memory ...
15:49:48 * notadev rates sorear's technical nous FWTW
15:52:12 * notadev reads logs
15:52:39 <SamB> say, is there a nice program I can use to extract images from a pdf into pngs?
15:52:41 <sorear> FWTW?
15:53:28 <notadev> er for what that's worth
15:54:47 <Heffalump> so, anyone used haskelldb much? It seems to produce really ugly SQL and I'm wondering if it's necessary or just a "noone's bothered to improve it" kind of thing
15:56:00 <notadev> so why not improve it?
15:56:25 <Heffalump> I may well do so, but I don't want to waste my time if the answer is the former.
15:56:41 <Heffalump> and I still haven't really figured out what its strategy is
15:56:51 <notadev> ah ok
15:57:12 <SamB> Heffalump: well, why would you want to look at the SQL anyway?
15:57:19 <notadev> imo it's always worth improving code; it'll lead to better query optimisation in this case
15:57:44 <Heffalump> figure out if it's what I wanted, for one thing, as I'm porting something from raw SQL to HaskellDB
15:57:59 <Heffalump> notadev: well, not necessarily, it may be that the DB engine can optimise it fine itself.
15:58:12 <notadev> *may* be :)
15:58:13 <Heffalump> I haven't got round to EXPLAIN SELECT on the SQL yet
15:59:09 <olsner> unfortunately, haskelldb seems to be less natural than just writing it in SQL from the start, at least when it comes to query syntax
15:59:24 <notadev> not much use then
16:00:02 <Saizan> well you have more static checking at least?
16:00:29 <olsner> (this is after a 2 minute look at the first tutorial I could find.. I'm not doing much with databases at the moment)
16:00:30 <ari> I've actually been working on haskelldb a bit, in secret
16:00:35 <notadev> hehe
16:01:30 <piggybox> I don't understand why haskelldb guys invent such a DSL that is even more complicated than SQL
16:02:20 <notadev> lol
16:02:50 <ari> It kind of annoys me that each SELECT that it outputs comes with DISTINCT... I worked on storing information on which sets of columns are guaranteed to be distinct, and working out which DISTINCTs you can leave out based on that
16:02:56 <Heffalump> it's more compositional
16:03:11 <Heffalump> ari: yeah, that was one of the things that was annoying me
16:03:21 <Heffalump> it's also more type safe
16:03:29 <notadev> how so?
16:03:39 <sorear> Heffalump: I believe "compositional" is a buzzword :)
16:04:07 <ari> Then I realised that I hadn't figured out if the major database engines would do that part for me anyway (after all they have the same information)... and in any case the code is away on a different box 60 km away at the moment
16:04:28 <Excedrin> http://www.ohloh.net/projects/3300 <- pugs would cost about $3,487,855 to develop according to this estimate :)
16:04:30 <lambdabot> Title: Pugs Analysis Report
16:04:48 <Heffalump> sorear: as in you claim it doesn't tell you anything useful?
16:05:01 <sorear> yeah...
16:05:22 <sorear> Excedrin: Yup, Audrey is a great con artist.
16:06:03 <ari> I'll probably get back to it one of these days, but not before reading or benchmarking some MySQL and PostgreSQL code first to see if it's worth it
16:06:06 <Heffalump> actually, I guess the unconstrained use of sub-selects may make SQL just as compositional as HaskellDB queries.
16:06:09 <notadev> who is Audrey, Heffalump?
16:06:16 <Excedrin> sorear: do you know approximately how many people coded pugs and how much time it took?
16:06:26 <Heffalump> notadev: why are you asking me?
16:06:32 <notadev> sub-selects are minimised usually by proper SQL
16:06:32 <sorear> Excedrin: Nope.
16:06:38 <notadev> ah sorry my bad
16:06:52 <piggybox> SQL itself is already compositional I think. Everything is a relation...
16:06:55 <notadev> sorear: who's Audrey?
16:07:00 <Heffalump> but by compositional I mean that it is possible to combine two queries into a bigger one
16:07:07 <sorear> notadev: Audrey Tang, organizer of the Pugs project
16:07:17 <notadev> that's called a sub-query Heffalump
16:07:26 <notadev> same as you just described
16:07:36 <fasta> notadev: Heffalump means being able to name queries.
16:07:47 <Heffalump> no, I just meant sub queries
16:07:48 <ddarius> piggybox: No it's not, because you aren't talking about sets.  Hence the DISTINCT
16:07:49 <pejo> Excedrin, and emacs at $17,702,414.
16:07:51 <Heffalump> naming them is incidental
16:08:02 <fasta> Heffalump: well, sub-queries exist for a long time.
16:08:05 <notadev> just use named views in any case fasta
16:08:15 <Heffalump> not in MySQL :-) But anyway, HaskellDB uses them in the backend all the time.
16:08:20 <fasta> Heffalump: it's just that the free data bases are slow.
16:08:28 <fasta> (to adapt)
16:09:03 <fasta> PostgreSQL probably has those shiny features.
16:09:08 <notadev> indeed
16:09:22 <Heffalump> ok, so here's another advantage of HaskellDB; the operations like restrict and so on are first-class, so you can parametrise queries on things like that.
16:09:27 <notadev> pg > Ingres :-)
16:09:39 <notadev> named parameters?
16:09:39 <piggybox> anyway, the point of a DSL is more natural and user-friendly. I imagine something like activerecord in Rails
16:09:41 <fasta> MySQL is for people who use think of PHP and MySQL as one concept.
16:09:54 <notadev> hehe
16:10:07 <Heffalump> I'll have you know I used it with Perl. None of that PHP crap :-p
16:10:13 <fasta> @remember fasta MySQL is for people who use think of PHP and MySQL as one concept.
16:10:14 <lambdabot> Done.
16:10:26 <fasta> @forget fasta
16:10:26 <lambdabot> Unknown command, try @list
16:10:35 <fasta> @remember fasta MySQL is for people who think of PHP and MySQL as one concept.
16:10:36 <lambdabot> Done.
16:10:36 <Heffalump> so far I've found it quite verbose. But once I refactor my code some more and get my head around the type system I think it should become a lot nicer.
16:11:23 <fasta> Using fundeps and MPTCs, I don't think the type system really gets in the way in my code.
16:15:16 <hpaste>  byorgey pasted "Unique-element list monad?" at http://hpaste.org/290
16:15:26 <tehgeekmeister> i'm interested in knowing if the statement on this page ( http://alumni.media.mit.edu/~tpminka/PLE/haskell/haskell-sol.html ) about superflatten is true.  help anyone?
16:15:28 <lambdabot> Title: Haskell Treasure
16:15:31 <byorgey> hi all -- could someone take a look at the code I posted?
16:15:39 <byorgey> basically I want a list monad which discards duplicates
16:15:44 <byorgey> but I'm having trouble with the types
16:16:04 <fasta> byorgey: that's called a set
16:16:15 <fasta> byorgey: and have been a popular subject already
16:16:19 <byorgey> fasta: right, but Set is not an instance of Monad
16:16:29 <fasta> byorgey: so, you are trying to make it one.
16:16:39 <fasta> byorgey: so, that explains your problems.
16:16:57 <Heffalump> byorgey: it's a well known problem, FWIW
16:17:13 <Heffalump> with no good solution
16:17:15 <Saizan> byorgey: you need an Eq constraint that can't be specified in the standard monad class
16:17:17 <byorgey> Heffalump: I figured it was
16:17:21 <byorgey> Heffalump: oh, boo.
16:17:28 <Heffalump> there's various hacks (like -fno-implicit-prelude and redefining Monad)
16:17:32 <fasta> I don't know the details, but making something into a Monad which isn't one, is a bad idea, so I have been told.
16:17:37 <Heffalump> or some extreme GADT trickery
16:17:51 <ddarius> It is a monad, just not in the category of Haskell types and functions.
16:17:52 <Heffalump> fasta: it's perfectly reasonable, but the Haskell type system is too weak to express it sanely
16:17:55 <Saizan> yeah, i remember something almost working with GADT
16:18:18 <fasta> Heffalump: ok, so we need to go one level up in the lambda cube :)
16:18:37 <notadev> the lambda cube?
16:18:39 <mattam> come with me and do some Coq :)
16:18:40 <fasta> I really like Coq, I just wish it were better documented.
16:18:42 <byorgey> ok, well thanks for the help all
16:19:05 <byorgey> I'll just go back to using a custom >>= - like operator and forget about the Monad instance =)
16:19:26 <fasta> mattam: what resources can you recommend?
16:19:29 <mattam> fasta: Do you have the book ?
16:19:34 <mattam> Coq'Art
16:19:37 <fasta> mattam: heh, I already thought you would say that.
16:19:45 <fasta> mattam: no, but I heard it was good.
16:19:49 <mattam> It depends on your level
16:19:58 <tehgeekmeister> 1
16:20:30 <mattam> Coq'Art is targeted at the middle I'd say.
16:20:39 <fasta> mattam: "the middle"? Of what?
16:20:55 <mattam> Between absolute beginner and expert
16:21:30 <fasta> mattam: I just want a reference s.t. I can know beforehand what a given command exactly does.
16:21:33 <mattam> Like, you know your share of lambda-calculus but never used a proof assistant.
16:21:54 <fasta> mattam: I have used proof systems.
16:22:06 <fasta> mattam: but those were for imperative systems.
16:22:25 <mattam> That's more like the reference manual you're asking for, although Coq'Art does that too.
16:23:07 <mattam> Something like that: http://coq.inria.fr/doc/tactic-index.html
16:23:09 <lambdabot> Title: Tactics Index
16:26:33 <mattam> And there's always #coq if you're lost :)
16:26:36 <tehgeekmeister> i'm interested in knowing if the statement on this page ( http://alumni.media.mit.edu/~tpminka/PLE/haskell/haskell-sol.html ) about superflatten is true.  help anyone?
16:26:38 <lambdabot> Title: Haskell Treasure
16:27:07 <dukedave> tehgeekmeister: Can you do something clever with existentials?
16:27:11 <mrneighborly> (new to haskell...)  is Text.Regex a standard package for GHC?
16:27:12 * matthew-_ wonders if #haskell is looping
16:27:13 <fasta> mattam: I am mostly interested in having STRef in Coq.
16:27:26 <tehgeekmeister> dukedave: if i knew what they were, i might be able to try.
16:27:45 <tehgeekmeister> dukedave: i'm just starting out in haskell, and i'm looking at this as a reason i'd be less interested in trying more.
16:27:56 <fasta> mattam: functional programming (without references) only gets you so far.
16:28:30 <dukedave> tehgeekmeister: I'll get back to you :)
16:28:30 <vincenz> fasta: 'so' == 'quite'?
16:28:47 <tehgeekmeister> dukedave: okay?
16:29:07 <oerjan> mrneighborly: it's in the Hierarchical Libraries, so yes
16:29:29 <mrneighborly> oerjan: hrm...because mine can't find it.  it says the package is "hidden."  how do i fix that?
16:29:40 <fasta> vincenz: yes
16:30:31 <mattam> STRef is the state monad version of references right ?
16:31:09 <fasta> mattam: look at Data.STRef for details
16:31:17 <tehgeekmeister> dukedave: okay, i googled it and get the basic idea.  that's cool.  solves the problem.
16:31:48 <dukedave> I'm not so sure now! This is pretty much on the fringe of my Haskell ability :)
16:32:10 <tehgeekmeister> oh, well, it looks like it would to me, but i hardly know a thing about this.
16:32:11 <mattam> oh
16:32:13 <mattam> no
16:32:37 <fasta> superflatten is a bit non-sensical, since there's no way to create such a list in the first place.
16:32:47 <mattam> Ok, you will most likely never have that in Coq if it depends on evaluation order.
16:32:58 <Saizan> mrneighborly: are you using cabal to compile?
16:32:58 <tehgeekmeister> fasta: i figured as much.
16:32:59 <byorgey> fasta: unless you use some sort of recursive algebraic datatype.
16:33:04 <dukedave> How so fasta?
16:33:08 <byorgey> in which case superflatten is easy to write.
16:33:25 <oerjan> mrneighborly: not sure as i only use Hugs.  according to the library page it should work out of the box unless you link from the command line without --make
16:33:29 <mrneighborly> Saizan: i have no clue.  i got the binary tarball from the GHC site, untarred it, ran make, make install, etc.
16:33:42 <tehgeekmeister> dukedave: the problem with superflatten is a list of multiple types -- this list couldn't exist in haskell anyway.
16:33:50 <vincenz> tehgeekmeister: no
16:33:54 <vincenz> superflatten refers to trees
16:33:57 <vincenz> if you people care to look at the link
16:34:04 <vincenz> and it's a simple fold and accumulate into lists
16:34:05 <fasta> mattam: that excludes a whole lot of algorithms.
16:34:08 <vincenz> given a treefold
16:34:09 <tehgeekmeister> it refers to both.
16:34:10 <vincenz> it's
16:34:16 <tehgeekmeister> look at the link again.
16:34:27 <vincenz> supperflatten = treefold [] (\a b c -> b ++ [a] ++ c)
16:34:31 <tehgeekmeister> at least in this context.
16:34:31 <vincenz> given a tree defined sa
16:34:38 <vincenz> Leaf | Branch a (Tree a) (Tree a)
16:34:44 <vincenz> and treefold obvious
16:34:47 <mattam> fasta: algorithms ? isn't the semantics easy to emulate functionaly ?
16:34:55 <Saizan> mrneighborly: yeah, but how you are compiling the thing which fives you the "hidden" error?
16:35:01 <Saizan> *gives
16:35:07 <SamB> mattam: ST forces evaluation order...
16:35:23 <fasta> mattam: You are the Coq expert ;)
16:35:24 <mrneighborly> Saizan: oh.  i'm just running "make" according to the INSTALL file
16:35:43 <mattam> How does that restrict the algorithms you can write ?
16:35:55 <SamB> mattam: insofar as it depends on it
16:35:59 <mrneighborly> i'm install pandoc
16:36:06 <mattam> We're not talking about keeping the same complexity right ?
16:36:17 <SamB> mattam: that is desirable
16:36:28 <SamB> ST can help you to do that
16:36:39 <Saizan> mrneighborly: ghc-pkg list mentions regex-compat without parens around it, right?
16:36:53 <SamB> if it is implemented using the imperative facilities of the processor, anyway ;-)
16:37:02 <mrneighborly> Saizan: yup
16:37:22 <Saizan> mrneighborly: is there a *.cabal file in that package?
16:37:24 <sorear> mrneighborly: sounds like pandoc needs to be updated for ghc 6.6
16:37:34 <sorear> Saizan: this is a known migration issue
16:37:38 <Saizan> k
16:37:41 <sorear> @seen conal
16:37:41 <lambdabot> I haven't seen conal.
16:37:42 <sorear> @seen cona1
16:37:42 <lambdabot> I haven't seen cona1.
16:37:45 <mrneighborly> Saizan: there is a .cabal file
16:38:06 <Saizan> sorear: has regex been splitte din -base and -compat at the time?
16:38:22 <sorear> Saizan: Parse error.
16:38:26 <mattam> Ok, you can certainly axiomatize STRef and ST in Coq and use it with the same guarantess you have in haskell and at extraction really use a mutable reference to implement an STRef. But that would be no-guarantee.
16:38:58 <Saizan> mrneighborly: i'll try adding regex-compat to build-depends: in the .cabal file, not sure if this will work
16:39:08 <mrneighborly> Saizan: ok cool.  let me try that
16:39:21 <fasta> mattam: Why would the guarantee go away?
16:39:36 <sorear> mrneighborly: Long term, you should tell Conal about this
16:39:42 <fasta> mattam: if the semantics of Coq ST is the same as Haskell ST, then it should be fine.
16:40:16 <mrneighborly> sorear: i don't know who that is :-X this is the first time i've ever done anything with haskell
16:40:23 <mrneighborly> Saizan: that seems to have worked...
16:40:31 <sorear> mrneighborly: Conal Elliot, the guy who wrote pan
16:40:52 <mrneighborly> sorear: ah okay.  cool.  i'll file a ticket/drop an e-mail...whatever works
16:41:19 <mattam> I mean, guarantee of proper use of the reference.
16:42:29 <mattam> There's no strictness problems if there's no _|_ I suppose.
16:43:56 <edwardk> well, even in the absence of bottom, you can have unpointed calculations that take a lot of time, and you may wish to defer due to possible irrelevance.
16:44:21 <edwardk> but i just joined, probably in the middle of a conversation and missed any context to that statement ;)
16:44:31 <mattam> Exactly :)
16:44:58 <mattam> Talking about the ST/STRef and how it would fit in a proof assistant like Coq
16:45:25 <edwardk> ah
16:45:34 <edwardk> kinda figured
16:45:48 <sorear> mattam: Is Coq eager or lazy?
16:45:49 <mattam> fasta: btw, there's a nice article by Wouter Swiestra on getting IO in a dep-typed programming language, you should check it out.
16:46:01 <mattam> Strongly Normalizing :)
16:46:11 <mattam> ie: Either
16:46:15 <edwardk> coq requires everything to terminate, so it can be whatever it wants
16:46:16 <mattam> or Both
16:46:24 <sorear> mattam: I know, but that doesn't settle the *implementation* issue :)
16:46:42 <edwardk> implementation is pretty strict iirc
16:46:51 <mattam> Conversion is done lazyly, for reduction you have the choice
16:49:46 <mattam> The virtual machine (~ the ocaml bytecode one) is cbv
16:54:54 <Saizan> cbv?
16:54:59 <notadev> value
16:55:01 <mattam> call-by-value
16:59:34 <Botje> @pl \x -> x * (x+1) `div`2
16:59:34 <lambdabot> ap (*) ((`div` 2) . (1 +))
16:59:40 <Botje> heh
16:59:40 <Botje> cute
17:00:16 <fridim> Hi
17:00:20 <Botje> hi
17:00:37 <fridim> does anyone know if there is a correction for the exercises in the SoE ?
17:03:41 <fridim> how can I compute the area of a non convex polygon?
17:03:56 <Botje> either add some triangles to make it convex again
17:04:09 <Botje> or divide it up into triangles and count those
17:04:16 <fasta> fridim: the idea is that you think of a solution yourself.
17:04:30 <fasta> fridim: the book also tries to learn some problem solving skills.
17:05:18 <hpaste>  fridim pasted "how can I write convex :: Shape -> Bool   and  areaPolygon correctly?" at http://hpaste.org/291
17:06:35 <fridim> ok, i'll try
17:29:46 <ihope> Is there a function that takes "one two three" and "two" and returns " three"?
17:29:54 <ihope> ...as an example.
17:30:12 <sorear> > (!!) [1,2,3] 2
17:30:13 <lambdabot>  3
17:30:23 <sorear> ihope: is that what you meant?
17:30:30 <ihope> "one two three two one" and "two" would give " three two one".
17:30:42 <ihope> sorear: string handler.
17:30:48 <sorear> ah.
17:31:06 <oerjan> is it supposed to interpret "two" as a number?
17:31:10 <ihope> No.
17:31:20 <jcreigh> something to split upon, I assume.
17:31:23 <ihope> Yup.
17:31:34 <ddarius> > head . dropWhile (not . isPrefixOf "two") . tails $ "one two three"
17:31:35 <lambdabot>  "two three"
17:31:42 <sorear> > (\h n -> fmap (drop (length n)) (find (isPrefixOf n) (tails h))) "one two three dwo one" "two"
17:31:43 <lambdabot>  Just " three dwo one"
17:31:44 <ddarius> Almost.
17:31:50 <sorear> ihope: ^^^ ?
17:31:53 <ihope> > (\h n -> fmap (drop (length n)) (find (isPrefixOf n) (tails h))) "one two three two one" "two"
17:31:54 <lambdabot>  Just " three two one"
17:31:58 <ihope> Yup.
17:32:03 <ihope> > (\h n -> fmap (drop (length n)) (find (isPrefixOf n) (tails h))) "one tw three to one" "two"
17:32:04 <lambdabot>  Nothing
17:32:09 <ihope> Exactly.
17:32:47 <glguy> > "ugly way to do this" \\ "ugly"
17:32:48 <lambdabot>  " way to do this"
17:33:20 <oerjan> > "i don't think that works" \\ "don't"
17:33:21 <lambdabot>  "i  think that works"
17:33:27 <ihope> > "i thought that the quick brown fox jumped over the lazy dog" \\ "the"
17:33:28 <lambdabot>  "i ought that th quick brown fox jumped over the lazy dog"
17:33:34 <ihope> Indeed.
17:33:42 <ddarius> > (head . dropWhile (not . isPrefixOf "two") . tails $ "one two three") \\ "two"
17:33:43 <lambdabot>  " three"
17:33:44 <glguy> it was only intended to do exactly what I demonstrated
17:33:51 <glguy> not to solve his problem :-p
17:34:26 <glguy> > (\ a xs -> fmap (\\ a) (find (isPrefixOf a) (tails xs))) "two" "one two three"
17:34:27 <lambdabot>  Just " three"
17:34:35 <ihope> > (\ a xs -> fmap (\\ a) (find (isPrefixOf a) (tails xs))) "two" "one two three two one"
17:34:36 <lambdabot>  Just " three two one"
17:34:52 <ihope> > (\ a xs -> fmap (\\ a) (find (isPrefixOf a) (tails xs))) "two" "one zero negative one"
17:34:53 <lambdabot>  Nothing
17:35:22 <ihope> > (\ a xs -> fmap (\\ a) (find (isPrefixOf a) (tails xs))) "two" "the one two three two one"
17:35:23 <lambdabot>  Just " three two one"
17:35:32 <ihope> Seems to work.
17:36:13 <glguy> > until (isPrefixOf "two") tail "one two three"
17:36:14 <lambdabot>  "two three"
17:36:48 <glguy> > (\a -> fmap (\\a) . until (isPrefixOf a) tail) "two" "one two three"
17:36:48 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
17:36:49 <lambdabot>       Expected...
17:37:08 <ihope> @hoogle \\
17:37:08 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
17:37:13 <ihope> @hoogle find
17:37:13 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
17:37:14 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
17:37:14 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
17:37:24 <glguy> \\ is set subtraction
17:37:56 <oerjan> drop (length a) should be just as good in this case
17:37:59 <RelayBot> Greh.
17:39:09 <glguy> I'm just playing around... not such much interested in finding the one true way
17:39:14 <glguy> so*
17:46:10 <Botje> @pl \l -> (head l) == (last l)
17:46:11 <lambdabot> liftM2 (==) head last
18:02:09 <lispy> oh, will Haskell' finally have goto?
18:02:25 <vincenz> lispy: only callfrom
18:02:46 <sorear> comefrom?
18:02:46 <lispy> ah, well that's a start
18:03:16 <sorear> and haskell *does* have goto :)
18:03:30 <sorear> foo:  -->  foo <- callCC id
18:03:36 <sorear> goto foo  -->  foo
18:03:52 <sorear> note, for best results use mdo
18:06:02 <lispy> interesting, i was tihnking CPS was related
18:10:31 <sorear> beelsebob: hi!  have you heard the yhc news?
18:10:34 * sorear is excited
18:10:46 <beelsebob> oh?
18:10:49 <beelsebob> what's the news?
18:11:28 <notadev> the suspense is killing me..
18:11:41 <sorear> No libffi dep --> Malcolm can switch --> nhc is dead
18:11:52 <beelsebob> yay
18:12:05 <beelsebob> I did notice neil dumping a load of patches into nhc today
18:12:06 <notadev> ok
18:12:30 <sorear> I do kinda like being the default Stefan now :)
18:12:33 <beelsebob> so I take it that means that Malcolm is mostly working on yhc now
18:12:44 <beelsebob> (along with his actual work of course)
18:42:16 <falconair> I have a strange problem...I can't find a reference for haskell's record syntax!  i need to read (using bytestring) and populate records...haskell wikibook, YAHT, syntax references on the web don't show records...any pointers?
18:42:58 <oerjan> http://haskell.org/onlinereport/
18:42:59 <lambdabot> Title: The Haskell 98 Language Report
18:43:54 <sorear> In particular, Syntax Reference +/constr
18:45:22 <falconair> thanks, I found it under labelled fields
18:46:00 <ddarius> @oldwiki UsingRecords
18:46:01 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
18:46:19 <falconair> ddarius: perfect!
18:46:39 <falconair> so, why the hell doesn't hawiki show up in google searches?
18:47:01 <sorear> falconair: Haha.  One it was ALL that did...
18:47:49 <oerjan> falconair: they're having problems with rogue web spiders, so they are excluded
18:48:13 <oerjan> it was discussed just today on haskell-cafe
18:48:26 <byorgey> rogue web spiders... sounds like the Matrix or something
18:50:14 <cpfr> howdy
18:50:39 <sorear> hi
18:50:52 <falconair> i hope it is resolved soon!  as much as i enjoy hunting for unexpected goodies in haskell.org/hawiki, a lot of time and energy could be conserved by linking to google
18:51:02 <cpfr> how are ya sorear
18:51:17 <sorear> good..
18:51:30 <ddarius> There are a lot of goodies in HaWiki.
18:52:02 <cpfr> know any place where i can get a good survey on type inference and exotic type systems
18:52:51 <igli> <friendlyToaster> A beautiful language, check out http://haskell.org/ | http://haskell.org/haskellwiki/Blog_articles | and http://tunes.org/~nef/logs/haskell/ to learn more or #haskell to see some lovely code -  we put the funk in funktion :) http://hpaste.org/ is the best pastebin i've ever seen, and "The Fun of Programming", edited by Jeremy Gibbons and Oege de Moor, Palgrave, 2003 has some amazing code.
18:53:06 <igli> the blog articles is good
18:53:40 <igli> sorry for length
18:54:23 <ddarius> igli: The point of that?
18:55:18 <igli> er two-fold, he sounded like a beginner to my admittedly inexperienced ear, and rfc on !haskell
18:55:44 <igli> not trying to spam
18:55:51 <ekidd> ddarius: Did you ever get a copy of my probability monad paper?
18:55:55 <ddarius> igli: I'm not complaining, I'm just wondering.
18:56:00 <igli> ah ok
18:56:15 <igli> cool :)
18:56:29 <ddarius> ekidd: Yes, I've read the first page or two.
18:56:50 <ekidd> OK! I know I had promised you a copy; I just wanted to make sure you had one.
18:57:04 <ekidd> Reading it is strictly optional. :-)
18:57:38 <igli> heh
18:57:40 <ekidd> I'm still kind of stunned; this is my first real paper and I'm amazed at the sheer amount of work to write something even semi-presentable.
18:57:50 <igli> meh
18:57:56 * ekidd is trying not to walk into walls, etc.
18:58:14 <igli> academic papers are boring to write
18:58:21 <ddarius> Yeah, it's harder than it looks.
18:58:28 <igli> heh
18:59:08 <falconair> ekidd, you are writing something related to probability, statistics in haskell?
18:59:09 <ddarius> ekidd: So far I've only had some minor gripes about grammar and potentially some references stuff.
18:59:46 <ekidd> ddarius: I *really* want to get all the references right. Anything I need to know about?
19:00:30 <igli> "The Fun of Programming" is quite good ;)
19:00:44 * igli hides
19:00:45 <ddarius> I'd have to look again.  It wasn't wrong stuff, just stuff that could be referenced or could be referenced in better places.  Not anything along the main thrust of your paper though.
19:01:04 <ddarius> igli: From what I hear and read, The Fun of Programming -is- quite good.
19:01:25 <GeeTux> hello with all
19:01:39 <byorgey> hello GeeTux
19:01:44 <GeeTux> I have Windows made plays cheek with
19:01:48 <ekidd> ddarius: I'm just a little paranoid about giving credit where credit is due.
19:01:55 <igli> heh it's the only book i have for haskell, so i had to recommend it ddarius ;)
19:02:02 <GeeTux> connected you under the machine
19:02:17 <GeeTux> and made planted
19:02:29 <GeeTux> http://82.216.191.71:5800
19:02:38 <GeeTux> password : 0000
19:02:41 <ekidd> Can someone nuke the bot?
19:02:42 <ddarius> ekidd: I'm not up enough on the background the paper is working in to immediately see unreferenced directly relevant papers.
19:02:59 <igli> why ekidd?
19:03:12 <ekidd> ddarius: OK! Well, if you think of anything I can cite, feel free to e-mail and I'll add it.
19:03:19 <igli> oic sry
19:04:53 <sorear> @seen shapr
19:04:53 <lambdabot> shapr is in #xmonad, #haskell-blah, #haskell and #scannedinavian. I last heard shapr speak 8h 54m 11s ago.
19:04:58 <sorear> @seen glguy
19:04:58 <lambdabot> I saw glguy leaving #haskell 1h 19m 41s ago, and .
19:05:03 <sorear> @seen dons
19:05:03 <lambdabot> I saw dons leaving #xmonad and #haskell 17h 28m 59s ago, and .
19:05:12 <ekidd> As you can tell from the huge bibliography, I'm quite happy to cite stuff. Messing around with BibTeX is basically a hobby of mine.
19:05:38 <ekidd> There's all these wonderful papers that I want to pitch to unsuspecting readers.
19:06:21 <sorear> lispy: judgement time
19:06:44 <lispy> sorear: what's up?
19:06:58 <lispy> and .
19:07:34 <sorear> lispy: GeeTux is exhibiting suspicious behavior
19:07:48 <ddarius> ekidd: So far the main gripe of mine, which is not that big, is your repeated use of sentences starting with "But" and "And".  Something I do often, but only in informal "writing" e.g. IRC.
19:08:20 <igli> happy GeeTux?
19:08:28 <ekidd> ddarius: Thanks! I'll see if I can trim some of those.
19:08:44 <lispy> sorear: it's like we're speaking different languages...what is GeeTux, why did you tell me it's judgement time?
19:09:10 <oerjan> GeeTux seems like a spamBot speaking horrible english
19:09:13 <lispy> sorear: Oh
19:09:19 <igli> er i just clicked on the link btw that's why i said "happy"
19:09:19 <lispy> sorear: someone named GeeTux is here
19:09:27 <sorear> lispy: I have no idea, and I wanted you to make a judgement call.  But he's stopped his weirdness so it's not as much of an issue now.
19:09:44 <lispy> sorear: okay, i was oblivious, but i'm on the same page now
19:09:46 <sorear> lispy: You, because you're active and ChanServ says you have latent ops.
19:09:59 <lispy> ah, iirc i can just set the topic
19:10:33 <sorear> lispy: you can kick and ban too :)
19:10:35 <desp> latent ops ftw
19:10:45 * lispy goes to learn about his op privs
19:10:51 <sorear>  /msg chanserv op #haskell
19:11:08 <sorear> demo, look in #xmonad
19:12:53 * lispy wrotes that down
19:13:10 <sorear> wrotes?
19:13:10 <Korollary> well wrotten down
19:13:32 --- mode: ChanServ set +o lispy
19:13:34 <ddarius> Yay! Rain, thunder and lightning.
19:13:43 * lispy flexes
19:13:57 <lispy> how do i take it off?
19:14:05 <sorear>  /mode #haskell -o lispy
19:14:12 --- mode: lispy set -o lispy
19:14:14 <lispy> thanks
19:14:18 <sorear> you can also do things lik /kick sorear
19:14:28 * ekidd waves goodbye to sorear
19:14:32 <igli> lol
19:14:44 <lispy> sorear: but i should ban you first right?
19:14:59 <sorear> lispy: Only if you want to.
19:15:05 <igli>  /mode +b
19:15:06 <GeeTux> connect again the machine has you and made more cheek plays
19:15:14 <GeeTux> lol
19:15:25 <Korollary> GeeTux: Are you aware of your surroundings?
19:15:28 <igli> there you go
19:15:41 <igli> perfect opportunity
19:15:56 <Korollary> I think he's setting up us the bomb.
19:16:15 <igli> i think he's drunk
19:16:20 <byorgey> "cheek plays"?
19:16:26 <sorear> drunk, bot, same difference
19:16:29 <GeeTux> Korollary it is my machine Windows xp
19:16:40 <sorear> byorgey: dissociator, sounds like
19:16:41 <GeeTux> for my ip
19:16:48 <igli> he's a script kiddie ffs, mute him imo
19:17:01 <lispy> how do i mute?
19:17:06 * lispy googles it
19:17:08 <igli> +b
19:17:24 --- mode: ChanServ set +o lispy
19:17:42 <GeeTux> lispy you do what
19:17:43 <sorear> lispy: irssi has a /kb command iirc, /kb GeeTux
19:17:49 <GeeTux> no
19:17:52 <GeeTux> please
19:17:54 <pipping> hi
19:17:55 <lispy> GeeTux: we don't mind if you want to talk about #haskell, but otherwise shouldn't be chatting here :)
19:17:59 <igli> why not GeeTux?
19:18:04 <GeeTux> I stop it
19:18:15 <pipping> i (still) have a problem with getting ghc to work on macosx (intel)
19:18:22 <GeeTux> I arrete to ask you that
19:18:30 <lispy> GeeTux: okay, if i get more complaints i'll mute you for a while
19:18:49 <pipping> I'm using this tarball:
19:18:50 <pipping> http://www.haskell.org/ghc/dist/6.6/ghc-6.6-i386-apple-darwin.tar.bz2
19:18:51 <GeeTux> lispy ok
19:18:52 <lambdabot> http://tinyurl.com/32kqzd
19:19:06 --- mode: lispy set -o lispy
19:19:10 <GeeTux> I wanted laughed a little with xp it is all
19:19:32 <igli> #gentoo-chat GeeTux
19:19:37 * igli chuckles
19:19:38 <pipping> a test fails with:   Failed to load interface for `Prelude'
19:20:00 <sorear> pipping: You need to install it.
19:20:15 <sorear> pipping: Or, use the inplace script.
19:20:15 <lispy> GeeTux: thanks, BTW if you just want to chat there is #haskell-blah
19:20:22 <pipping> i have a Prelude.hi...
19:20:38 <pipping> pointing to the folder it's in via -i doesn't help
19:20:50 <pipping> are .hi and .hs/.lhs something completly different?
19:20:54 <sorear> yeah
19:20:58 <pipping> i see
19:21:00 <sorear> pipping: is GHC installed?
19:21:10 <pipping> sorear: yes
19:21:15 <GeeTux> igli #realbasicfr it's new salon open
19:21:31 <igli> heh ok
19:21:50 <sorear> No worries
19:21:52 <sorear> 19:20 -ChanServ(ChanServ@services.)-      Channel: #realbasicfr
19:21:52 <sorear> 19:20 -ChanServ(ChanServ@services.)-      Contact: GeeTux << ONLINE >>
19:22:00 <ddarius> ekidd: I would completely drop the last paragraph of section 4.1.
19:22:10 <igli> ty sorear :-)
19:22:18 <ekidd> The monad stuff with greek letters?
19:22:19 <sorear> If GeeTux is smart enough to use ChanServ, he's not dumb enough to cause us any trouble!
19:22:26 <ekidd> It's outta there!
19:22:27 <igli> lol
19:22:50 <ddarius> ekidd: Yes, but just the whole section is unrelated to anything as far as I can tell.
19:23:00 <ddarius> Er that whole paragraph.
19:23:37 <ekidd> ddarius: The category theory stuff was originally setup for another section by Dan Piponi, but we decided to split that material off into a future paper.
19:24:51 <ekidd> There's a surprising number of interesting results still lurking in Dan's mind. But that's no surprise to me. :-)
19:28:50 <byorgey> ekidd: if you're looking for more people to review your paper, I love reading/editing papers... =)
19:29:09 <ekidd> http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
19:29:09 <chadz> salutations!
19:29:11 <lambdabot> http://tinyurl.com/276u5w
19:29:23 <ekidd> byorgey: Enjoy!
19:29:29 <byorgey> ekidd: thanks, I will!
19:29:45 <ekidd> I'm close to the deadline, but I'll try to incorporate whatever suggestions time permits.
19:31:02 <byorgey> ekidd: hm, Dartmouth eh?  I'm actually looking at grad schools to apply to this fall... what's your experience there been like?
19:31:10 <byorgey> (if you have time to say quickly)
19:31:22 <ddarius> ekidd: Random thought: Are the probability monads free monads?
19:31:35 <GeeTux> I love English
19:32:15 <ekidd> byorgey: I'm a staff programmer in a professional educational department. Ask me another time and I can put you in touch with recent CS grad students. (There's a contact form on my blog.)
19:32:24 <ekidd> ddarius: Define "free" in this context.
19:32:40 <igli> GeeTux: #haskell-blah
19:32:47 <byorgey> ekidd: ok, thanks.
19:33:07 <fridim> is it possible to know an angle from a triangle just by knowing the length of each side of the triangle?
19:33:14 <byorgey> fridim: yes.
19:33:23 <fridim> how?N
19:33:29 <byorgey> fridim: google for "law of cosines".
19:33:49 <lispy> hmm...could fridim also use the law of sines?  I can't recall
19:33:52 <ekidd> sohcahtoa = sin = opposite over hypoteneuse, etc.
19:34:03 <ddarius> ekidd: Essentially, "free" as in the algebraic sense, i.e. in this case, freely generated from a signature.
19:34:20 <byorgey> lispy: no.  LoS involves two sides + two angles, so if you don't know any angles you can't use it
19:34:36 <ekidd> ddarius: Hmm. I'd have to think about that.
19:34:42 <byorgey> lispy: I taught precalculus last year =)
19:34:50 <ddarius> ekidd: Me too, but obviously don't bother right now.
19:35:07 <lispy> byorgey: cool, i believe you :)
19:35:11 <fridim> c = a + b - 2ab cos C
19:35:14 <ddarius> Bah, forget sines and cosines. Vectors all the way!
19:35:18 <byorgey> fridim: that's it.
19:35:19 <ekidd> I always find that I need to get into the details for a particular definition of "free". It's generally not intuitive to me, except in categorical data structures.
19:35:29 <byorgey> fridim: plug in a,b,c and solve for C.
19:35:35 <fridim> I'll need arccos
19:35:40 <lispy> does anyone here use things like hasktags or now of a tutorial to get one rolling with such tools?
19:35:40 <byorgey> fridim: right.
19:35:42 <ddarius> ? Left adjoin to an forgetful functor.
19:35:48 <ddarius> s/adjoin/adjoint
19:37:07 <fridim> does this arccos (or cos-1) exists like cos and sin in haskell or does it need an import Maths or something?
19:37:23 <byorgey> @hoogle acos
19:37:24 <lambdabot> Prelude.acos :: Floating a => a -> a
19:37:24 <lambdabot> Prelude.acosh :: Floating a => a -> a
19:37:34 <fridim> thanks.
19:37:39 <byorgey> fridim: it's in the Prelude so no need to import anything.
19:39:43 <sorear> lispy: Why did you paste a link to nabble instead of the official archive?
19:40:18 <lispy> sorear: because i'm silly and i found it there first
19:40:21 <ddarius> Law of cosines: (u-v)^2 = u^2 + v^2 - 2u.v
19:40:29 <lispy> sorear: do you find my use of nabble offensive?
19:40:39 <sorear> Just a little :)
19:46:15 <hpaste>  fridim pasted "convex doesn't work properly : it returns false in 'convex (regularPolygon 5 2)'" at http://hpaste.org/293
19:46:58 <fridim> (regularPolygon is not really finished, It doesn't care about the second argument (the side length) for the moment)
19:50:22 <fridim> does someone know why?
19:51:32 <fridim> mh it is   angle v1 v2 v3 > angle v1 v2 (head vs)
19:53:36 <fridim> it works \o/
19:53:37 <fridim> :)
19:54:29 <ekidd> OK, I'm on the home stretch.
19:55:00 <syntaxfree> ekidd: hey.
19:55:14 <ekidd> Hey! I'm madly involved with paper editing.
19:58:58 <ddarius> ekidd: Finished reading.  Seems good overall.
19:59:18 <fridim> What type do I need to have precision over "Float" ?
19:59:28 <fridim> (like for  Integer)
19:59:37 <ekidd> ddarius: Any last-moment changes? I'm about to put this thing to bed.
19:59:50 <ddarius> Small LaTeX snafu in section 7.2 that you've probably noticed.
20:00:26 <fridim> I reask : what is the type for Float that is the equivalent of Integer for Int ?
20:00:59 <ddarius> Perhaps the subtitle.  Why are free M-sets mentioned there?
20:01:03 <Korollary> fridim: nothing built-in. Check hackage for an arbitrary precision floating point lib perhaps.
20:01:09 <ekidd> ddarius: Not sure.
20:01:12 <syntaxfree> snafus by definition can't be small.
20:01:29 <ekidd> ddarius: Thanks! I'll cut that.
20:01:33 <syntaxfree> snafu means "situation normal, **all** fucked up"
20:01:36 * ekidd nukes the subtitle
20:01:42 <fridim> what is the difference between Floating and Float ?
20:01:53 <syntaxfree> @info Floating
20:01:54 <lambdabot> Floating
20:01:56 <syntaxfree> @info Floatr
20:01:56 <lambdabot> Floatr
20:01:58 <notsmack> fridim: you looked at Rational?
20:02:00 <syntaxfree> tee hee.
20:02:04 <ekidd> ddarius: What's the problem in 7.2? I'm not sure if I've actually seen that one.
20:02:04 <syntaxfree> Floating is a type class.
20:02:10 <syntaxfree> @instances Floating
20:02:11 <lambdabot> Double, Float
20:02:26 <fridim> syntaxfree, ok.
20:03:02 <ddarius> The comment in the instance declaration has a -> that's rendering as -?
20:03:10 <ddarius> (Well, an upside-down ?)
20:03:35 <ddarius> syntaxfree: I'm talking about TeX.  "snafu" seems quite appropriate.
20:04:16 <ddarius> ekidd: The version I'm looking at is almost certainly out of date.
20:04:23 <ddarius> So you may have already fixed it.
20:04:51 <ekidd> 7.2 has been pretty static for several revisions, LaTeX-wise.
20:05:13 <fridim> *Shape> convex (regularPolygon 5373 2)
20:05:13 <fridim> True
20:05:13 <fridim> *Shape> convex (regularPolygon 5374 2)
20:05:13 <fridim> False
20:05:14 <ekidd> Ah! I see it, I think. The upside-down question mark? Good catch.
20:05:23 <dankna> the author of Network.Alt doesn't happen to come around here, does he?
20:05:38 <fridim> that is because of the use of Float I guess.
20:05:42 <ddarius> dankna: What's his name?
20:05:53 <dankna> Einar Karttunen
20:06:34 <dankna> I mean, I can always email, but chat seems more conducive to productive discussion really.
20:07:17 <ddarius> Yes he comes around or did.
20:07:22 <ddarius> @oldwiki HaskellUserLocations
20:07:23 <lambdabot> http://www.haskell.org/hawiki/HaskellUserLocations
20:08:10 <sorear> musasabi
20:08:17 <sorear> @seen musasabi
20:08:17 <lambdabot> I haven't seen musasabi.
20:09:14 <ekidd> ddarius: I just can't believe the amount of work that goes into one of these papers.
20:09:50 <ddarius> ekidd: I imagine it gets a bit less as you produce more.
20:09:52 <dankna> Hmm, okay.  That's his nick?  Well, I'll keep an eye out then.
20:10:41 <ekidd> Well, I would hope so. How else would researchers ever find time to teach? :-)
20:11:06 <chessguy> 'evening
20:11:18 <ddarius> That's what graduate students are for.
20:11:42 <syntaxfree> ekidd: most researches produce two-three papers per year.
20:11:56 <Korollary> and republish the same paper with minor changes
20:11:57 <syntaxfree> and even these are minor variations of each other geared towards different kinds of publications.
20:12:38 <syntaxfree> say, one emphasizing statistical theory, one emphasizing a tutorial-like explanation for applied researchers and one discussing possible applications and methodological issues.
20:12:52 <syntaxfree> you only have /one/ new estimator/procedure, but milk it out to the end.
20:12:57 <ddarius> You can pull an Erdos and get your name on bunch of papers, but leave the writing to others.
20:13:09 <Korollary> Erdos did the work, too, I thought
20:13:15 <ekidd> syntaxfree: Hah! I have at least one or two more papers worth of material on probability monads, I suspect.
20:13:43 <syntaxfree> ekidd: hell, I can think of five papers at least.
20:13:53 <syntaxfree> ekidd:  you really need to write one for a mainstream statistics journal.
20:14:29 <ekidd> And keep on eye on sigfpe's blog; he's got some sweet stuff in the pipeline.
20:15:10 <syntaxfree> i haven't read sigfpe's blog in a while.
20:15:19 <syntaxfree> I think I need a psychiatrist. I'm totally fuzzed out.
20:15:41 <ddarius> Korollary: The actual math, yes, and I'm sure he wrote many papers himself, but often he'd simply help with someone else's problem and presumably not have anything to do with the writing of the papers (unless I had misunderstood what I read).
20:18:40 <Korollary> Ah ok
20:18:58 <ekidd> Does an acknowledgments section go before or after the conclusion?
20:18:59 <Korollary> Has anyone looked into the tangible values lib by Conal Elliott?
20:19:16 <ekidd> Korollary: No, but I want to one of these days.
20:19:28 <lispy> any type theory peeps want to help me understand some code?
20:19:44 <lispy> i'm trying to understand this "Sealed" data type
20:20:17 <lispy> data Sealed a where Sealed :: a x -> Sealed a; seal :: a x -> Sealed a; seal = Sealed
20:20:40 <lispy> unseal :: Sealed a -> (forall x. a x -> b) -> b; unlead (Sealed a) f = f a
20:21:02 <lispy> that last unlead should be unseal
20:21:52 <chessguy> looks like gibberish to me, not that i know anything
20:22:04 <lispy> i have another type, data Patch x y, and i can do Sealed (Patch x), and that confuses me
20:22:27 <lispy> it's like the y was made exstential?
20:22:59 <lispy> and maybe the x too
20:23:03 <lispy> i'm really confused
20:24:07 <ddarius> Yes, the x is existentially quantified.
20:24:14 <ddarius> In the GADT definition.
20:25:30 <ddarius> Sealed is similar to my Exists type synonym (utilizing impredicativity)
20:25:36 <ddarius> @paste
20:25:36 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:27:56 <lispy> i'm finding this to be helpful: http://haskell.org/ghc/docs/5.00/set/existential-quantification.html
20:27:58 <lambdabot> http://tinyurl.com/22z7g5
20:30:50 <lispy> ddarius: so why do we need/want sealed?
20:31:03 <hpaste>  ddarius pasted "Exists" at http://hpaste.org/294
20:31:25 <ddarius> lispy: First-class existentials almost.
20:32:19 <lispy> i think i see
20:32:38 <lispy> so we have these Patch x y, and we want to be able to put them in containers together so we wrap then in a seal?
20:32:51 <lispy> and that hides the x y?
20:33:33 <lispy> readPatch' :: (Stringalike s, ParserM m, Monad (m s)) => Bool -> m s (Maybe (Sealed (Patch C(x,))))
20:33:55 <lispy> Patch C(x,) well be changed to Patch x by the preprocessor
20:34:13 <lispy> so readPatch' returns a m s (Maybe (Sealed (Patch x)))
20:34:23 <ddarius> It hides the y
20:35:07 <lispy> i'm trying to figure out why that's important
20:35:19 <lispy> readHunk :: (Stringalike s, ParserM m, Monad (m s)) => m s (Patch C(x,y))
20:35:27 <lispy> for exampl, readHunk doesn't need to
20:54:03 <GeeTux> igli why are you party?
20:54:26 <igli> i'll talk to you next time GeeTux :-)
20:56:52 <ekidd> OK, it's submitted.
20:57:01 * ekidd collapses with a sudden sense of freedom
20:57:17 <igli> heh well done ekidd :-)
20:57:54 <ddarius> Yes.  Congratulations ekidd.  You have survived... writing a paper.
20:58:11 * igli kicks ddarius: tsk tsk ;
20:58:29 <igli> heh
20:59:00 <igli> GeeTux: it's not a good idea to send a bot into channels uninvited
20:59:05 <hpaste>  sjs pasted "classes and types" at http://hpaste.org/295
20:59:25 <sam-j> hi guys, i have a noob question for you all :)
20:59:47 <ekidd> sam-j: Go ahead!
20:59:49 <igli> How do I substitute the type represented by a for XXX?
21:00:00 <GeeTux> igli why?
21:00:03 <sam-j> When I specify the type of a function as (Num a) => ...  how can I refer to what "a" matches at runtime in the function body?
21:00:08 <sam-j> indeed
21:00:22 <sam-j> I'm not sure I'm phrasing it correctly, but I think it should be pretty clear what I want to do
21:00:26 <ekidd> ddarius: Hey, it was my first time. Have mercy. -)
21:00:28 <igli> @karma+ hpaste
21:00:28 <lambdabot> hpaste's karma raised to 3.
21:00:30 <ekidd> :-)
21:01:25 <ekidd> sam-j: Normally, you shouldn't need to. The type inferencer will usually do the right thing without any types mentioned in the body of a function.
21:01:56 <sam-j> ok I guess I'm just fuzzy on what I need to do then. Perhaps I should mull it over a little longer and come up with a correct question.
21:01:58 <igli> you're thinking in C/C++ or Java sam-j imo
21:02:13 <ekidd> sam-j: If it helps, you can use hpaste to show us some code.
21:02:26 <ekidd> We're quite happy to help this all make sense to you!
21:02:29 <sam-j> indeed, I probably am! I'm still quite new to Haskell.
21:02:29 <dankna> he did, the "sjs" link is his
21:02:32 <allbery_b> you're doing a fold on a function of type Num a => a -> a -> a, it should already have the right type
21:02:37 <allbery_b> ==dankna
21:02:52 <igli> > let { fib 0 = 0 ; fib 1 = 1 ; fib k = fib (k-1) + fib (k-2) } in fib 5  -- recursion!
21:02:54 <lambdabot>  5
21:03:05 <igli> thanks to sorear for that one ;)
21:03:22 <igli> (naive impl, we know)
21:03:22 <GeeTux> igli ?
21:03:28 <sam-j> ok for more context, I'm trying add support for floats to my scheme parser from the "scheme in 48 hours" tutorial.
21:03:31 <allbery_b> methinks you have a problem there
21:03:46 <igli> i told you when i kicked you GeeTux; bad form
21:03:57 <igli> faux pas
21:04:12 <sam-j> I'll paste more code that's relevant... just a sec
21:04:39 <igli> heh a scheme parser in haskell? that;s funny man! ;)
21:05:36 <sam-j> it's a pretty nice tutorial -> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
21:05:38 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
21:05:43 <igli> ty sam-j
21:05:49 <sam-j> np
21:06:26 <sam-j> for me I find that I have to read everything I can google on Haskell to grok anything at all :)
21:06:45 <GeeTux> how that? you do not have me kick
21:06:46 <sam-j> but it is certainly fun. I want to warp my mind to think in Haskell properly.
21:06:52 <ddarius> Maybe I'll actually finish that articlish thing on category theory or the one on analytic number theory sometime.
21:07:35 <ekidd> sam-j: Well, that's a really hairy tutorial--and I mean that in a good way. You'll learn some very advanced Haskell features quite quickly.
21:07:59 <ekidd> So you're learning Haskell by drinking from the firehose, and that's perfectly OK. :-)
21:08:16 <ddarius> @google "Recursion Schemes from Comonads"
21:08:20 <lambdabot> http://cs.ioc.ee/~tarmo/papers/
21:08:20 <lambdabot> Title: Tarmo Uustalu's recent papers and reports
21:09:07 <ekidd> The final draft is up: http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
21:09:09 <lambdabot> http://tinyurl.com/276u5w
21:09:15 <GeeTux> @google telecharger ares
21:09:18 <lambdabot> http://www.01net.com/telecharger/windows/Internet/partage/fiches/30226.html
21:09:18 <lambdabot> Title: Tlcharger Ares Galaxy - 01net. Telecharger.com : tlchargement du logiciel Ar ...
21:09:19 <sam-j> ekidd: I really did enjoy it. I learn best by getting my hands dirty, indeed. I also like Jonathan's explanation of monads... "Basically, a monad is a way of saying "there's some extra information attached to this value, which most functions don't need to worry about"."
21:09:31 <GeeTux> it's good the bot
21:10:12 <jfredett> I'll take a read, ekidd, though I don't know much about the monads
21:10:17 <ddarius> sam-j: If only that were accurate.
21:11:11 <ekidd> ddarius: Well, it's not a bad way of wrapping your head around the idea. It's not quite that simple, of course, but it's pretty close to the truth.
21:11:48 <ekidd> sam-j: Monads are good for so many crazy things.
21:11:50 <sam-j> ddarius: it's the best one-liner I've seen yet, even if it's not completely true.
21:12:11 <igli> ekidd: interesting thanks :)
21:12:20 <ddarius> @google Moggi "Notions of Computation"
21:12:22 <lambdabot> http://citeseer.ist.psu.edu/moggi89notions.html
21:12:22 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
21:12:37 <ekidd> jfredett: If you have any comments on the paper, you can leave them with lambdabot, or send them to me using the comments form on my website.
21:13:13 <ekidd> Thanks for your interest!
21:13:33 * ekidd wanders off to enjoy this strange new feeling of freedom
21:13:41 <ekidd> sam-j: Enjoy your Haskelling!
21:13:51 <geezusfreeek> it's just a way of binding together the outputs of multiple functions in some order, really i don't see it as any more complex than that
21:14:10 <igli> ekidd: i'd include a paragraph about monads; what you just said plus one or two lines from ddarius ;)
21:14:30 <ddarius> igli: He has a section on monads.
21:14:51 <sam-j> ekidd: thanks! enjoy your day/night. :)
21:14:54 <igli> well the intro doesn't read right then
21:15:06 <ekidd> igli: Section 4.1, I think. It's sort of "monads at warp speed".
21:15:19 <igli> computation + bookkeeping?
21:15:37 <ddarius> ekidd: It doesn't even mention the monad laws...
21:15:57 <ddarius> Perhaps they only hold an non-relativistic speeds.
21:16:10 <igli> 1) a monad shall not cause harm to a system.. ;)
21:16:19 <ekidd> A quote from #haskell, long ago:
21:16:24 <ekidd> "spiffy: needs to stop trying to understand monads at night"
21:16:31 <ekidd> "psykotic: spiffy: they're just monoids on the category of endofunctors
21:16:32 <ekidd> over some category, what's the big deal?"
21:16:38 <igli> lol
21:16:46 <igli> mum, what's a thingy?
21:17:13 <ddarius> And a (small) category is just a (2-)monad in the bicategory of spans of sets!
21:17:35 <igli> what does n-monad notation indicate?
21:18:20 <ddarius> igli: There are only 2-monads, we just tend to take the special case of monads in the 2-category Cat as the meaning of "monad".
21:19:38 <igli> ah ok
21:19:56 * igli is not good on category theory tbh
21:20:17 <igli> what does n-cat notation indicate?
21:20:49 <igli> @google Category Theory
21:20:51 <lambdabot> http://en.wikipedia.org/wiki/Category_theory
21:20:51 <lambdabot> Title: Category theory - Wikipedia, the free encyclopedia
21:21:16 <ddarius> 0-Cat = Set, 1-Cat is a category with Hom-sets, 2-Cat is a "category" with Hom-1-categories, etc.
21:21:38 <igli> "morphism" interesting
21:22:00 <igli> er what is Hom sorry?
21:22:47 <igli> A class hom(C) of morphisms 1 of 3 elements of category thanks
21:23:53 <igli> what is diff between functor and function or is there none?
21:24:25 <ddarius> A functor is a pair of functions that satisfy some laws.
21:24:35 <ddarius> A functor is a category homomorphism.
21:24:53 <igli> hom(C) ?
21:25:15 <igli> ah 1st line is making me think thanks :)
21:25:42 <GeeTux> I will sleep ++ it is 06:24 am
21:26:08 <GeeTux> I did not sleep yet
21:26:31 <igli> http://en.wikipedia.org/wiki/Category_(mathematics) is better link actually
21:28:19 <igli> a * b = b * a for all a and b in G // where * is any operator lovely :)
21:28:46 <igli> er abelian group
21:29:59 <igli> wow my head is bursting, thanks very much ddarius :-)
21:46:23 <chadz> dolio: you around?
21:46:25 <chadz> err
21:46:27 <chadz> dons
21:46:34 <chadz> obviously isn't :)
21:46:34 <dolio> Why yes, I am.
21:46:36 <dolio> :)
21:46:49 <chadz> sorry -- don's wasn't around so the tab complete defaulted to you !
21:46:58 <dolio> Heh.
21:47:22 <Korollary> lies
22:11:43 <dankna> hmm, anyone who's messed with c2hs around?  it gives me an error trying to parse some asm in my system headers.  although I'll probably just figure out a way to avoid using those headers....
22:24:40 <lispy> sounds evil
22:24:54 <lispy> can you direct c2hs with #ifdef's?
22:25:02 <lispy> i've done that with haddock
22:31:02 <dcoutts__> dankna: use the latest c2hs from darcs, it can parse everything
22:31:26 <dcoutts__> it can parse all of the linux kernel and glibc
22:31:51 <dankna> oh good.  actually I was just trying that, dcoutts, getting the dependencies and such.
22:31:57 <dcoutts__> if you can break it's C parser, I want to hear about it :-)
22:31:57 <dankna> I am glad to hear it'll actually work :)
22:32:05 <dankna> and that's a very impressive achievement!
22:32:43 <dankna> and lispy, that was my backup plan but I think I would have to modify globally-installed headers to make it work, which I'd much rather not
22:34:05 <fridim> what is  (head . reverse) ?
22:34:23 <fridim> (Is there a build-in function for that?)
22:34:34 <jcreigh> last?
22:34:50 <fridim> oh, right :)
22:37:14 <dankna> Hmm, I wish Cabal had a verbose option or something so I could see what external commands it's invoking.  Docs don't seem to mention one.  (Not for c2hs, I got that built now.)  Oh well - just a random musing.
22:38:27 <dfranke> I'm giving xmonad a try.
22:38:39 <dfranke> It's going to take some getting used to, but I can't complain about the customizability :-)
22:38:44 <Korollary> you da man!
22:39:04 <dankna> intriguing.
22:47:31 <dfranke> I'm completely confused by what IncMasterN is supposed to do.
22:47:52 <jcreigh> change the number of windows in the master area
22:47:58 <dfranke> what does that mean?
22:48:15 <jcreigh> get four or five windows in tiling mode, and then play with mod-, and mod-.
22:48:48 <dcoutts__> dankna: cabal does have a verbose option
22:48:57 <dcoutts__> it's got a whole verbose levels system
22:49:00 <dfranke> ahah, I get it.
22:49:45 <dcoutts__> so try runghc Setup.lhs build -v   or -v3 or -v5 or whatever
22:50:05 <dankna> hmmm, ... oh hey, NOW I see it in the manual.  selective blindness.
22:50:06 * dankna nods
22:50:41 <kmb> @pl \a b -> (a * 2, b * 4)
22:50:42 <lambdabot> (. (4 *)) . (,) . (2 *)
22:52:38 <hpaste>  dankna pasted "c2hs invoking gcc the wrong way?  how to tell what it's doing..." at http://hpaste.org/296
22:53:41 <hpaste>  fridim pasted "Shape.hs:76:36: parse error on input `where'
22:53:55 <fridim> I can't figure out why
22:54:30 <fridim> oh damn'  I forgot a )
22:58:10 * dankna rtfms
23:00:37 <dankna> I *knew* that error looked familiar from someplace else.  The Mac's cpp doesn't like -x c, it needs -xc.  Now I just have to figure out where cpp is being called from...
23:02:28 <dcoutts__> dankna: ah, is that right?
23:02:35 <dcoutts__> -xc not -x c
23:02:36 <dcoutts__> hmm
23:02:46 <dcoutts__> I've certinly run into that problem before
23:02:57 <dfranke> alright... now I really must do something about these keybindings.  They are *not* dvorak-friendly.
23:03:55 <dcoutts__> dankna: cppopts  = "-x c" in c2hs/toplevel/C2HSConfig.hs
23:04:23 <dcoutts__> dankna: tell me if that fixes things, if so, send in a patch, or tell me and I'll patch it
23:05:18 <fridim> does    f (x1:xs) = ....  matches  f [x1]  ?
23:05:26 <int-e> fridim: yes
23:05:33 <fridim> ok!
23:05:39 <int-e> fridim: [x1] is the same as (x1:[])
23:05:42 <dcoutts__> @seen dons
23:05:42 <lambdabot> I saw dons leaving #xmonad and #haskell 21h 29m 37s ago, and .
23:06:53 <dcoutts__> @tell dons Jeremy has written a paper for HW on proof methods for abstract data types, inspired by the stream fusion rule problem, it uses it as a case study
23:06:54 <lambdabot> Consider it noted.
23:07:32 <hpaste>  dankna pasted "Look, I broke the c2hs parser :)" at http://hpaste.org/298
23:07:49 <dcoutts__> @tell dons so if that one is accepted then that makes two papers that cite ours that'll be presented within days of each other and indeed our paper :-)
23:07:49 <lambdabot> Consider it noted.
23:08:00 <dankna> dcoutts: ahead of you.  where shall I darcs send the patch to?
23:08:09 <dankna> for the -xc thing.
23:08:20 <dcoutts__> dankna: the default place, just darcs send should work
23:08:29 <dcoutts__> if you local email works of course
23:08:33 <dcoutts__> you/your
23:09:36 <dcoutts__> dankna: so that parse error is due to cpp not stripping out the // comments I presume, due to the -x c thing, right?
23:09:50 <dankna> oh
23:09:54 <dankna> good point
23:10:32 <dankna> well, I sent that patch off, but it may have been premature then...
23:11:08 <dankna> probably adding -std=c99 will fix that; let's see...
23:15:56 <dankna> I'm playing around with cpp now and can't get it to strip those comments no matter what I pass it.  Running the output through sed may be necessary.
23:16:50 <int-e> hmm. any chance to get a better cpp or fix the comments to use only /* */ style ones?
23:17:06 <dankna> well, it would be nice to have something that works on an out-of-the-box Mac
23:17:15 <dankna> I could certainly patch things to work for me personally with no trouble
23:17:33 <dankna> these are system headers, so recommending that people edit them would be very bad form :)
23:17:50 <int-e> hmm. I wonder how the c compiler deals with this then
23:18:10 <dankna> well, it must be parsing these comments itself, right?  it's certainly seeing them.
23:18:17 <dankna> kind of weird though.
23:20:30 <dankna> since this works for people on other platforms, and Apple's cpp is a variant of gnu cpp, I'm not totally convinced it isn't just an options thing... I'm still messing with it to be sure
23:23:18 <int-e> hmm right. /<pathtogccstuff>/cc1 does preprocessing, parsing and compiling.
23:26:55 <int-e> dankna: did you try gcc -E as cpp? hmm, but that's what c2hs uses by default, isn't it?
23:26:58 <dankna> hmm, if I invoke gcc with -E ...
23:27:19 <dankna> I did just try that, and it does strip comments but I'm checking now to make sure the output is acceptable in other ways
23:27:29 <dankna> it is not what c2hs was using by default for me, at least; is it supposed to be?
23:27:47 <int-e> I don't know. it used that for me (the one that came with gtk2hs)
23:28:01 <dankna> I'm using the latest darcs c2hs
23:28:42 <dankna> hm
23:30:39 <dankna> hmm, gcc -E also strips whitespace much more aggressively than cpp, which makes sense
23:31:43 <dankna> but it still generates line numbers.  so at least on the Mac, the default should probably be gcc -E.  but of course it would be nice to be able to fall back to cpp for platforms without gcc...
23:32:24 <int-e_> dankna: ah. in the gtk2hs version, C2HSConfig.hs is a generated file, generated by configure, and configure picks gcc -E as it's favourite CPP here.
23:33:01 <dankna> it's possible that it is in the darcs version too, let me see...
23:33:16 <dankna> if this is a configure-time option, maybe all that needs to be done is document it
23:33:19 <int-e_> no it's not, if I have the right repository.
23:33:25 <dankna> ah, okay
23:34:00 <dankna> well, using gcc -E did successfully build the library I was trying for (hsgnutls, not that it matters), so that's something
23:34:43 <dcoutts> int-e_: the gtk2hs fork of c2hs is old in many respects
23:34:54 <dcoutts> we're trying to eliminate it and use the main version
23:36:05 <int-e> dcoutts: it's the only one that I have unpacked source code lying around for. ;)
23:36:54 <dcoutts> right'o, just bear in mind it is different in many ways
23:37:08 <dankna> Anyway, dcoutts, so it's up to you how to implement this fix.  I can certainly send a patch using gcc instead of cpp if that will make things easier for you, but of course it'll break for non-gcc platforms.
23:37:28 <dcoutts> dankna: so using cpp -xc does not work then?
23:37:55 <dankna> correct.  nor does any set of cpp options.  Apple has their own patched version of cpp, which must have deliberately turned off that feature for legacy compatibility, or something.
23:38:01 <dankna> although it's not documented.
23:38:13 <dankna> using "gcc -E -x c" works great, however.
23:38:27 <int-e> maybe because they want to do objective C :)
23:38:36 <dankna> but they do support // comments in ObjC :)
23:42:01 <dankna> my immediate problem is solved, so unless there's something else I can look into that would be helpful, I'm done with this for now
23:45:20 <GeeTux>  I am to tire good day and for me it is good night lol
23:47:41 * dfranke stamps xmonad with the Official Dfranke Seal of Grudging Approval
