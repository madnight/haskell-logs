00:00:02 <dons> the guys who do DLL stuff are likely to be there
00:00:05 <eivuokko> I think wiki has page that as better intructions.
00:00:48 <eivuokko> But I think you adapted the dllmain.c a bit wrong
00:01:24 <eivuokko> ie, you changed the extern declaration for your haskell module, but didn't change the reference to it in DllMain
00:02:56 <dlewissandy> hmm.  I copied the code directly from the ghc user's guide without modifications.
00:03:01 <eivuokko> Hmm, can't find that page in wiki...maybe I remember wrong.
00:03:55 <eivuokko> Heh, right, I get the same
00:04:25 <dons> http://programming.reddit.com/info/1zik8/details
00:04:26 <lambdabot> Title: New York (Typed) Functional Programmers Meetup (reddit.com)
00:04:45 <eivuokko> There must be space between void and __stginit_Adder on line 4
00:08:17 <dlewissandy> that did it.  Thanks!
00:09:02 <eivuokko> np, if you got question you can ask here, and if that fails, as dons suggested, don't be afraid to use haskell-cafe mailinglist.
00:18:11 <johnnowak> dons: you going?
00:19:08 <dons> going?
00:19:34 * edward2 waves hello.
00:19:35 <edward2> @users
00:19:36 <lambdabot> Maximum users seen in #haskell: 333, currently: 295 (88.6%), active: 7 (2.4%)
00:20:14 <kolmodin> morning!
00:20:23 <dons> morning kolmodin
00:20:30 <kolmodin> hey dons
00:20:38 <kolmodin> lot of hacking lately? :)
00:21:06 <kolmodin> dons: which projects are you currently hacking on? xmonad and..
00:21:10 <dons> a bit of hacking, more writing though :-)
00:21:12 <johnnowak> dons: er, the new york fp meetup
00:21:17 <kolmodin> ah, neat :)
00:21:28 <dons> johnnowak: oh, hehe. no. i'm on the other side of the pacific currently
00:21:35 <johnnowak> ahh.
00:21:48 <johnnowak> not, er, the atlantic?
00:21:48 <dons> kolmodin: yeah, xmonad, a bit of bytestring/fusion thinking. mostly thesis
00:22:00 <dons> johnnowak: nope. the pacific is between me and NYC
00:22:01 <DRMacIver> Hm. Why am I trying to figure out finger trees at this time in the morning? :)
00:22:11 <kolmodin> oh, my examiner just mailed me and approved my thesis!
00:22:13 <dons> DRMacIver: its the haskell way!
00:22:17 <dons> kolmodin: woot!
00:22:22 <dons> congratulations :-)
00:22:24 <kolmodin> thanks! :D
00:23:00 <kolmodin> "only" paperwork left to get the degree in order. neat :)
00:26:01 <DRMacIver> dons: Yeah, but it doesn't work very well 'cause my brain is full of mush until around 11am. :)
00:26:59 <dons> DRMacIver: we have a solution for this. coffee :-)
00:27:51 <DRMacIver> No, even with coffee. :(
00:28:06 <glguy> lies!
00:28:32 <glguy> Success? (chessguy's part message) has he been trying to escape the channel?
00:31:06 <dons> ExitSuccess  ?
00:34:23 <psnl> kolmodin: well done
00:34:36 * LeCamarade uses ExitFailure 27
00:34:42 <kolmodin> yay! thanks :)
00:35:11 <kolmodin> breakfast is over... and so is debugging two darcs failures on ppc and amd64. /me has to go to work in a few minutes
00:35:16 <LeCamarade> Because I know I'll be back, despite my resolution to stay away.
00:35:34 <glguy> dons: Iavor asked if you have defended your thesis yet
00:35:43 <glguy> had*
00:35:44 <kolmodin> if someone is bored: http://bugs.gentoo.org/show_bug.cgi?id=182512 http://bugs.gentoo.org/show_bug.cgi?id=182459
00:35:46 <lambdabot> Title: Gentoo Bug 182512 - dev-util/darcs-1.0.9 configure fails
00:35:48 <kolmodin> :)
00:36:06 <glguy> I didn't know the answer. Had you?
00:36:59 <dons> nope, i'm writing my thesis atm.
01:46:39 <iakovz_> morning
01:46:52 <|Steve|> 'evening.
02:15:31 <iakovz_> brb -> reboot
02:34:22 <njbartlett> http://www.londonhug.net/2007/06/19/hug-meeting-number-two/
02:34:24 <lambdabot> Title: Œªondon HUG ª Blog Archive ª HUG Meeting Number Two
02:39:54 <dons> njbartlett: yay!
02:41:22 <njbartlett> dons: don't suppose you can make it... ;-)
02:41:30 <dons> njbartlett: same day as the Ny meetup too, I see.
02:41:38 <dons> yeah, might be stretching my travel budget a bit
02:41:45 <dons> we had our Sydney FP workshop last week though
02:41:54 <njbartlett> Yeah, can't let those yanks get ahead of us
02:42:06 <dons> right!
02:42:40 <dons> here's the slides from the Sydney meeting, http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071 btw
02:42:41 <lambdabot> Title: &nbsp; : SAPLING - SAPLING 071 browse
02:42:46 <njbartlett> Cool. I've been so busy recently, haven't been monitoring the "blogosphere" much. How was the workshop?
02:43:32 <dons> nice. good to catch up with the other FP guys in the Sydney area. Manuel gave a good talk on indexed type families too.
02:43:52 <njbartlett> Ah yes, the slides for that one popped up on reddit
02:44:03 <dons> yep
02:44:06 <Syzygy-> dons: Will there possibly be more workshops in Sydney in the autumn? *curious*
02:44:36 <dons> well, this one was in Autumn :-) (winter, actually)
02:44:45 <dons> the next one is in November
02:46:38 <Syzygy-> Oh bugger.
02:46:48 <Syzygy-> I keep missing the interesting meeting this year.
02:47:06 <Syzygy-> I'll be in Sydney until late October, so I'll be missing ICFP and all the satellites and colocated things.
02:47:59 * kfish will be in sydney in october too :-)
02:48:07 <Syzygy-> kfish: Cooool. :)
02:48:17 <Syzygy-> I'll get there September 14, and leave again October 20.
02:49:22 <njbartlett> Anybody know much about the FP/Haskell community in Japan? I'll be there for about 3 months this year
02:50:15 <dons> there's a couple of haskell books published in japanese, maybe some kind of underground community, kfish ?
02:50:30 <kfish> ah hi
02:50:47 <kfish> yeah, i haven't found a community, some people have heard of it
02:51:08 <kfish> there's some academics in the math department at my uni (kyoto uni) doing fp papers, but not always haskell
02:51:28 <kfish> njbartlett, where will you be?
02:51:52 <kfish> but eg. the two books are quite introductory
02:52:21 <njbartlett> kfish: Kagoshima, pretty provincial, but easy enough to travel inside Japan if there's anything interesting going on
02:53:22 <njbartlett> Any chance of a Japanese translation for the "Real World" book? ;-)
02:55:49 <yakov> /is is away (lunch)
02:56:13 * kfish invites njbartlett to #haskell.jp :-)
03:01:34 <dons> kfish: and there's Chilli's former group at Tsukuba? (might be more functional logic programming though)
03:01:53 <kfish> ah right, cool
03:02:09 <dons> guys like http://www2.score.cs.tsukuba.ac.jp/people/professors/tetsuo-ida/ida/view?set_language=en
03:02:12 <lambdabot> Title: Welcome to Tetsuo Ida's Homepage &mdash; SCORE, http://tinyurl.com/yslvqv
03:02:21 <dons> (gave a great talk at unsw on computational origami)
03:02:28 <kfish> cool :-)
03:03:21 <dons> folds are powerful :-)
03:04:18 <kfish> yeah, i probably should have just joined an fp lab instead of joining a web/media/db lab and trying to convert them
03:04:30 <mdmkolbe|work> I'm a little to tired to think this through properly.  How would I write the inverse of this function?
03:04:31 <mdmkolbe|work> > let f lst = [(y, fromJust x) | (y,x) <- zip [1..] lst, isJust x] in f [Just True, Nothing, Just False]
03:04:32 <lambdabot>  [(1,True),(3,False)]
03:04:37 <kfish> but if i'd thought that, i might as well have stayed in sydney :-)
03:04:52 <dons> hehe
03:07:11 <njbartlett> Computational origami sounds fascinating...
03:07:33 <njbartlett> WTF does it mean? ;-)
03:08:31 <mdmkolbe|work> njbartlett: programming with folds
03:09:03 <njbartlett> Ah... I thought that was a joke :-)
03:09:59 <Shimei> So would foldl and foldr be yama-ori and tani-ori respectively? ;)
03:12:23 <kfish> for my next lab talk, i'm planning to demo a monadic interface to web queries (which i wrote yesterday), and introduce catamorphisms as a generalization of the SQL CROSS APPLY operator
03:12:46 <dons> computation by folding paper (or its abstract equivalent, folding over planes)
03:13:03 <dons> since the fundamental 'primops' for folding paper have interesting properties -- and complexity
03:15:15 <mdmkolbe|work> kfish: FYI, spj and phil w, just proposed an addition that adds SQL group by and order by to list comp http://haskell.org/haskellwiki/Simonpj/Talk:ListComp
03:15:16 <lambdabot> Title: Simonpj/Talk:ListComp - HaskellWiki
03:16:27 * mdmkolbe|work looks forward to the day that haskell list comprehensions replace SQL as the defacto database language standard ;-)
03:16:28 <kfish> mdmkolbe|work, ah nice, they were pretty obviously missing (for doing this kind of thing)
03:16:42 <kfish> and count
03:17:19 <mdmkolbe|work> kfish: their groupby gives you count for free
03:17:30 <kfish> yeah, i was just thinking that lol
03:17:32 <kfish> reading now :-)
03:17:36 <kfish> thanks for the link
03:24:57 <quicksilver> group by doesn't mix all that well with infinite lists, though :)
03:25:08 <quicksilver> (indeed, neither does order by)
03:25:43 <osfameron> unless you can prune
03:25:50 <osfameron> which is one of the examples in HOP iirc
03:25:57 <osfameron> but that only works well for certain datasets
03:26:03 <mux> quicksilver: heh, I thought this was postgresql and was trying to picture a lazy dbms with infinite tables or something :-)
03:26:11 <mux> s/postgresql/#postgrsql/
03:37:39 <mdmkolbe|work> quicksilver: true, but sort-by-using works out just fine if the "sorting" function can deal with lazyness.  e.g. filter out all the odd values.  (hmm, I just realized that filters gaurds (predicate clauses?) are a special case of sort by)
04:27:32 <Cale> > groupBy (<) [k | n <- [1..], k <- [1..n]]
04:27:34 <lambdabot>  [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,3,4,5],[1,2,3,4,5,6],[1,2,3,4,5,6,7],[1,2,...
04:28:01 <Cale> groupBy can actually work just fine with infinite lists.
04:28:31 <Saizan> but the SQL groupBy is quite different
04:28:55 <Cale> ah, serves me right for not actually reading the whole conversation :)
04:30:53 <Saizan> http://research.microsoft.com/%7Esimonpj/papers/list%2Dcomp/ <-- :)
04:30:54 <lambdabot> Title: Comprehensive Comprehensions
04:35:52 <quicksilver> Cale: just because it's my current hobby horse, I'll note that using groupBy with a non-equivalence-relation is a violation of its contract and should be considered to have undefined results
04:35:56 <quicksilver> :)
04:47:31 <matthew_-> you know how the two "bodies" of an if-then-else must have the same type?
04:47:37 <quicksilver> yes
04:47:53 <matthew_-> well, can they actually have different types, so long as they both have some typeclass context?
04:48:40 <quicksilver> not as such, because that wouldn't have the type you're imagining
04:48:40 <matthew_-> > let (x:: forall n . (Num n) => n) = if True then (5::Int) else (5::Double) in x
04:48:40 <lambdabot>  Parse error
04:48:41 <norpan> no
04:48:53 <matthew_-> bummer
04:48:59 <quicksilver> the haskell type is (forall n. (Num n) => n)
04:49:07 <quicksilver> but what you actually want, to be type-safe in that case
04:49:17 <quicksilver> is (exists n. (Num n) => n)
04:49:25 <quicksilver> which is not, per-se, a haskell type
04:49:29 <matthew_-> indeed
04:49:43 <quicksilver> however you can use an intermediate datatype to do what you want
04:49:51 <matthew_-> yes. I was just thinking that
04:50:12 <matthew_-> though you'd then have the standard issues of existentially qualified types escaping etc etc
04:50:28 <matthew_-> but they can be managed.
04:50:36 <quicksilver> data  ((Num a) =>) AnyNum = AnyNum a
04:50:38 <quicksilver> or something
04:50:44 <quicksilver> I always forget the syntax
04:51:00 <quicksilver> (because I hardly ever use it)
04:51:04 <matthew_-> data AnyNum :: * where AN :: (Num a) => a -> AnyNum
04:51:19 <quicksilver> that's the GADT version, yes :)
04:51:24 * matthew_- always uses GADT syntax these days: it just reads better
04:51:36 <Saizan> data AnyNum = forall a. Num a => AnyNum a
04:52:09 <Saizan> the ugly part is the constructor
04:52:11 <Cale> That's going to be relatively useless.
04:52:28 <quicksilver> matthew_-: I'm not sure why you see 'existentially qualified types escaping' as an "issue" with this solution
04:52:36 <matthew_-> Cale: indeed
04:52:40 <quicksilver> matthew_-: that's an essential issue with any solution to this problem :)
04:52:48 <matthew_-> quicksilver: absolutely
04:52:50 <Cale> You're not going to be able to write a sane Num instance for AnyNum.
04:53:38 <Cale> Existential constructors are a good thing, I think.
04:54:14 <quicksilver> Cale: he didn't say he wanted to right a num instance for it, did he?
04:54:18 <quicksilver> write
04:54:20 <quicksilver> damn my spelling
04:54:21 <Cale> I suppose not
04:54:30 <Saizan> ?src Num
04:54:31 <lambdabot> class  (Eq a, Show a) => Num a  where
04:54:31 <lambdabot>     (+), (-), (*)           :: a -> a -> a
04:54:31 <lambdabot>     negate, abs, signum     :: a -> a
04:54:31 <lambdabot>     fromInteger             :: Integer -> a
04:54:35 <matthew_-> well in truth, I'm not dealing with Nums anyway
04:54:37 <quicksilver> I think Num was just 'an example of a class'
04:54:39 * quicksilver nods
04:54:49 <quicksilver> this kind of thing make better sense for existential exception classes
04:54:55 <quicksilver> or xmonad's Message class
04:54:57 <quicksilver> etc
04:54:58 <Cale> In general, throwing away type information like that is a big deal, and it's worth having the constructor around to make you think about where you do it.
04:55:13 <matthew_-> indeed.
04:55:21 <quicksilver> yes, that is a fairly convincing way of putting it
04:55:40 <Saizan> yes, but then you are just left with an open union type
04:55:42 <quicksilver> there is of course an 'either-version-of-if'
04:55:49 <quicksilver> which puts Lefts and Right around automatically
04:55:57 <quicksilver> which is appropriate in some cases
04:56:02 <Saizan> well, open and forgetful
04:56:34 <matthew_-> quicksilver: ahh, of course, that may be an even better solution to my problem.
04:56:41 <matthew_-> so many ideas, so little time!
04:56:56 <matthew_-> sadly, I have to go, but thanks for your time.
05:03:04 <araujo> morning
05:04:31 <ekidd> Morning.
05:04:43 <ekidd> A good one, I hope. :-)
05:04:45 <quicksilver> there should be some guidelines
05:05:01 <quicksilver> existential types -> have you considered Either, or a finite ADT?
05:05:12 <quicksilver> HList -> have you considered your own simpler typeclass
05:05:24 <quicksilver> SYB -> have you considered sensibly structured types
05:05:38 <dons> HList, see existential types
05:05:58 <dons> hmm. these could be useful rules of thumb
05:06:36 <quicksilver> I mean, I don't deny that all those three LHS's are useful tools
05:06:44 <quicksilver> but I do often see people failing to apply occam's razor
05:06:55 <quicksilver> and useing them when something simpler would be, well, simpler
05:07:27 <quicksilver> I keep meaning to write something up about the dangers of metaprogamming, too
05:08:31 <Saizan> metaprogramming can help you to use less type hackery like those LHSs :)
05:09:50 <quicksilver> Saizan: but I'd rather use type hackery than metaprogramming, it's safer
05:10:10 <quicksilver> Saizan: still, I'm not saying metaprogramming isn't useful :)
05:10:20 <quicksilver> Saizan: I'm just saying, it is more dangerous than people recognise
05:14:17 <Saizan> quicksilver: you can use things that don't exist and there's no concept of types, but the generated code must typecheck in the end..
05:15:00 <quicksilver> Saizan: yes, and that's not what I mean
05:15:16 <quicksilver> Saizan: I don't have time for the details now, but metaprogramming breaks well-understood invariants
05:15:38 <quicksilver> Saizan: e.g. : order of definitions in a haskell file is not significant. Order of alternatives in a ADT is not significant
05:15:51 <quicksilver> Saizan: metaprogramming techniques can break these invariants
05:24:47 <TuanMy> /msg NickServ HELP REGISTER
05:24:59 <opqdonut> exactly
05:26:10 <ttfh> (sorry about beeing offtopic) I noticed that where I live, a lot of people with CS education do "alternative" sports, like multisport races, singlespeed mountainbiking and so on
05:28:05 <norpan> i do curling, is that alternative enough?
05:28:24 <ttfh> I would consider it alternative :-)
05:28:39 <norpan> well it's an olympic sport
05:29:06 <ttfh> yes, hehe
05:29:25 <Saizan> ?type sortBy√π
05:29:27 <lambdabot> parse error (possibly incorrect indentation)
05:29:28 <Saizan> ?type sortBy
05:29:29 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> [a]
05:30:03 <ttfh> I mean, I think there are supposedly "alternative" sports that have more practitioners than some olympic sports
05:30:59 <norpan> surely
05:31:15 <timbod> fe42
05:31:18 <norpan> geocaching for instance
05:31:21 <siti> do the system.io functions preserve unicode?
05:31:44 <mdmkolbe|work> Is there some function like liftM but that requires a weaker qualification? e.g. (Foo m) => (a -> b) -> m a -> m b for some Foo
05:31:48 <quicksilver> siti: the ones which write to files to do
05:31:51 <quicksilver> mdmkolbe|work: Functor
05:32:00 <quicksilver> mdmkolbe|work: (fmap)
05:32:15 <quicksilver> siti: the ones which write to file DO NOT, I mean
05:32:25 <quicksilver> siti: the file IO in system.IO is 8bit only
05:32:31 <siti> ok :(
05:32:32 <mauke> @hoogle (a -> b) -> m a -> m b
05:32:33 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
05:32:33 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
05:32:33 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
05:32:35 <siti> how do I fix it
05:32:42 <norpan> quicksilver: by specification or by ghc implementation?
05:32:51 * mdmkolbe|work slaps head
05:32:54 <quicksilver> norpan: that's not clear. But it's not just ghc.
05:32:55 <siti> I need to read the files as unicode :(
05:33:02 <mauke> siti: that doesn't make sense
05:33:03 <quicksilver> siti: that sentence makes no sense
05:33:06 <mdmkolbe|work> quicksilver: I must be really tired to have forgotten about that
05:33:09 <mauke> unicode is not an encoding
05:33:13 <mdmkolbe|work> quicksilver: thx
05:33:15 <quicksilver> siti: perhaps you mean, I need to read files as UTF8?
05:33:30 <siti> yeah, that's what I mean :p
05:33:36 <norpan> UTF-8 even :)
05:33:40 <quicksilver> siti: then I think you probably want to use CompactString
05:33:48 <quicksilver> @where CompactString
05:33:49 <lambdabot> I know nothing about compactstring.
05:33:55 * quicksilver slaps lambdabot 
05:33:59 <quicksilver> @where compactstring
05:33:59 <lambdabot> I know nothing about compactstring.
05:34:10 <siti> hmm ok
05:34:34 <quicksilver> @where+ compactstring http://twan.home.fmf.nl/compact-string/
05:34:35 <lambdabot> Done.
05:34:45 <quicksilver> I'm sure I taught LB about that once before!
05:34:48 <siti> looks good thanks
05:35:01 <siti> maybe he doensn't have a memory?
05:35:05 <siti> doesn't*
05:35:10 <quicksilver> @where compactstring
05:35:10 <lambdabot> http://twan.home.fmf.nl/compact-string/
05:35:53 <mdmkolbe|work> quicksilver: I think lb crashed a few weeks ago and lost it all.  I had to reteach LB where flags
05:36:26 <hpaste>  mauke pasted "decodeUTF8 :: String -> String" at http://hpaste.org/329
05:39:05 <siti> mauke: is it public domain though ;)
05:39:32 <mauke> it is now!
05:46:24 <dblhelix> niksnut: kun jij via poort 80 op www.cs.uu.nl ?
05:46:50 <dblhelix> oops: sorry
05:46:56 <mauke> no
05:50:19 <tibbe> anyone know why emac's haskell mode would say: Symbol's function definition is void: switch-to-haskell ?
05:50:29 <tibbe> typing ghci in a term works fine
05:50:34 <tibbe> version 2.3 of the mode
05:51:52 <quicksilver> you haven't loaded inf-haskell, I suspect
05:52:14 <tibbe> quicksilver: probably but I thought it would be loaded by default in haskell-mode
05:52:27 <quicksilver> it isn't
05:53:02 <quicksilver> (autoload 'run-haskell "inf-haskell"  "Run interactive haskell interpreter." t)
05:53:13 <quicksilver> ^^ this fragment in my .emacs loads it automatically the first time I try to run it
05:53:52 <dmhouse> tibbe: what have you got in your .emacs regarding haskell-mode?
05:54:18 <dmhouse> tibbe: you should just have (load "haskell-site-file").
05:54:20 <tibbe> (add-hook 'haskell-mode-hook 'turn-on-haskell-doc-mode)
05:54:24 <tibbe> (add-hook 'haskell-mode-hook 'turn-on-haskell-indent)
05:54:26 <tibbe> on ubuntu
05:54:27 <dmhouse> tibbe: that one line is all you should need.
05:54:41 <dmhouse> (Assuming you installed haskell-mode to somewhere in your load-path.)
05:54:49 <tibbe> so the ubuntu stuff doesn't load it automatically?
05:55:21 <dmhouse> Oh, hang on; are you using a version of haskell-mode from Ubuntu?
05:55:31 <quicksilver> emacs doesn't generally load all modules by default
05:55:35 <quicksilver> that would make startup very slow
05:55:38 <dmhouse> Because that's likely to be an older version that the most recent 2.3. Perhaps you should use that one instead.
05:55:56 <tibbe> dmhouse, I actually did a somewhat ugly thing and overwrote the 2.1 files withe 2.3 files
05:56:00 <dmhouse> Then you should use the line (load "haskell-site-file") in your .emacs to use it.
05:56:26 <dmhouse> tibbe: ah, okay, then the .emacs config that Ubuntu used for 2.1 might not work with 2.3 :) Or it might do, but there's a better way of doing it.
05:56:51 <tibbe> dmhouse: loading the site-file did it
05:56:56 <tibbe> dunno if that's the cleanest way
05:57:03 <tibbe> but there's no backport package
05:57:06 <tibbe> to dapper
05:57:26 <dmhouse> tibbe: for Emacs packages the best route is generally to ignore your package manager and just install them yourself :)
05:57:48 <dmhouse> Because there are hardly any in the repositories, and those that exist are often older versions.
05:57:50 <tibbe> dmhouse: :)
05:58:04 <tibbe> thanks
05:58:07 <tibbe> I'll get back to work
05:58:11 <dmhouse> tibbe: use (load "haskell-site-file") in your .emacs to use haskell-mode.
05:58:19 <tibbe> I do now thanks
06:14:57 <siti> grr compact string stack overflows with CS.unpack :(
06:15:16 <siti> C.unpack $ CS.toByteString $ contents <-- is ok
06:15:33 <siti> CS.unpack contents <-- is not :(
06:16:18 <quicksilver> that's odd
06:16:21 <quicksilver> twanvl: ping
06:16:39 <twanvl> quicksilver: pong
06:16:55 <quicksilver> twanvl: read up a line or two :)
06:17:17 <twanvl> It is entirely possible that there are stack overflows
06:17:46 <quicksilver> surprising to get one on something as simple as CS.unpack though?
06:18:35 <siti> it's about a 220KB on disk...
06:18:49 <twanvl> there may be a strictness issue there
06:18:53 <siti> ok
06:20:46 <twanvl> You could try making the 'loop' function strict. In CompactString.hs line 311, insert "STRICT3(loop)" before "loop _ _ 0 = ..."
06:21:16 <siti> ok I will try that
06:23:58 <siti> nope that didn't fix it :(
06:24:56 <quicksilver> are you compiling with -O2?
06:25:29 <siti> ghc-options: -Wall -fglasgow-exts -O2 -funbox-strict-fields -DSLOW_FOREIGN_PTR
06:25:37 <siti> I will try -O0 then
06:26:23 <quicksilver> no, -O2 is good :)
06:26:52 <siti> lol
06:26:58 <siti> I will try it just for fun then ;)
06:27:11 <siti> lol and guess what it works :p
06:27:20 <siti> ghc bug?
06:27:30 <quicksilver> intriguing
06:27:51 <quicksilver> sounds like an optimiser bug
06:27:52 <quicksilver> certainly I don't understand it :)
06:28:09 <siti> yeah
06:29:26 <Saizan> compiling CS or your code with -O0 works?
06:30:10 <siti> CS
06:41:30 <siti> wooho, unicode works, thanks guys, if you need anymore help with finding the cause of that bug just ask :)
06:58:06 * tomshackell wonders if Simon Marlow is about ...
07:00:31 <JaffaCake> tomshackell: quicksilver tells me you were looking for me
07:01:15 <tomshackell> I was just implementing throwTo in Yhc and had a slight semantics question. I figured you'd probably be the person to ask.
07:01:59 <tomshackell> it seemed sensible to try and keep the semantics as similar to GHC as possible.
07:02:25 <JaffaCake> ok, go ahead
07:03:28 <tomshackell> okay A is running an FFI action, B throwTos to A and blocks (waiting for A's FFI action to finish) . So far so good, but what happens if C now throwTos either A or B?
07:04:06 <JaffaCake> C blocks on throwTo A, but succeeds on throwTo B
07:04:26 <tomshackell> and cancels B's attempt to throw to A?
07:04:30 <JaffaCake> yes
07:04:35 <JaffaCake> that's the way GHC behaves, anyway
07:05:05 <JaffaCake> throwTo is an "interruptible" blocking operation
07:05:33 <JaffaCake> tomshackell: does this mean you have full concurrency in YHC?
07:05:45 <tomshackell> and with C throwing to A, presumably both exceptions are thrown? (perhaps either in order or in a non-determined order).
07:06:04 <JaffaCake> that depends
07:06:37 <JaffaCake> one exception gets thrown, and then A will be either dead or in an exception handler, so the exception handler gets to run before the next exception
07:07:02 <JaffaCake> exception handlers are in an implicit 'block'
07:07:43 <tomshackell> okay cool, and would B's exception be thrown to A first, or C's exception or is it undefined?
07:07:52 <JaffaCake> undefined
07:08:05 <JaffaCake> but in practice, whoever got there first
07:08:48 <tomshackell> cool. Yhc has 'sort of full' concurrency.
07:09:11 <JaffaCake> which bits are missing?
07:09:41 <tomshackell> well it's still emulated in a single thread with the interpreter switching, it also lacks advanced features such as the STM.
07:09:57 <JaffaCake> so no blocking on thunks?
07:10:04 <tomshackell> oh no it does that.
07:10:09 <JaffaCake> ah cool
07:10:09 <tomshackell> MVars work fine also.
07:10:25 <JaffaCake> and you can do blocking foreign calls?
07:10:56 <JaffaCake> I don't consider "emulating in a single thread" to be a drawback, incedentally
07:11:19 <JaffaCake> GHC on a non-SMP is still like that
07:11:26 <tomshackell> no, it's very sensible in an interpreter. It just means you can't make use of multiple processors.
07:11:37 <Serge`> > ([1..],[2..]) > ([2..],[1..])
07:11:39 <lambdabot>  False
07:12:15 <JaffaCake> ok, so the bits you don't do are the bound threads and FFI stuff
07:12:34 <tomshackell> it does do blocking foreign calls, it puts each one in a separate OS thread and then resyncs with the main thread when the FFI action finishes.
07:12:45 <JaffaCake> ok, nice
07:13:01 <tomshackell> unless of course there is only one thread in which case it doesn't bother.
07:13:27 <tomshackell> you'll have to remind me what "bound threads" are :-)
07:13:32 <RobHu> Really stupid newbie question... I used Haskell a year ago for a few days and now we're having a discussion about it at work... Why can't I just do   inc n = n+1   in ghci ? II get <interactive>:1:6: parse error on input `='
07:14:01 <JaffaCake> tomshackell: http://hackage.haskell.org/cgi-bin/haskell-prime/trac.cgi/wiki/Concurrency/DraftReportText
07:14:04 <lambdabot> Title: Concurrency/DraftReportText - Haskell Prime - Trac, http://tinyurl.com/2f5gpb
07:14:13 <xho> RobHu: > let inc n = n + 1
07:14:20 <JaffaCake> I expect you're pretty close to being able to implement all of that
07:14:20 <RobHu> ah
07:14:22 <RobHu> thankyou
07:14:59 <edwardk> the bound thread stuff is just when the ghc thread expects to be run entirely within a real os thread, so you can have things like normal thread local storage, right?
07:15:03 <notsmack> RobHu: inc n = n + 1 would work as a line in a .hs file, though
07:15:04 <mauke> RobHu: as for why, ghci doesn't support top-level declarations, only expressions and let bindings
07:15:05 <JaffaCake> tomshackell: how about in-calls?
07:15:18 <RobHu> Should I try something other than ghci?
07:15:33 <xho> ghci is pretty good
07:15:33 <tomshackell> RobHu no stick with ghci ;-)
07:15:42 <JaffaCake> edwardk: right, except that we don't specify what OS thread runs the Haskell code, only the OS thread that runs the foreign calls
07:15:59 <edwardk> ah k
07:16:07 <JaffaCake> it gives the implementation more flexibility
07:16:13 <notsmack> RobHu: no
07:16:22 <RobHu> edwardk !
07:16:25 <RobHu> I recognise than name!
07:16:29 <notsmack> RobHu: just use "let" from the prompt
07:16:30 <tomshackell> JaffaCake, ah no Yhc doesn't do that :-)
07:16:33 * edwardk arches an eyebrow.
07:16:36 <RobHu> I used your ICFP UM VM :P
07:16:41 <edwardk> hahaha
07:16:48 <tomshackell> JaffaCake, since I don't know what "in calls" are I doubt it does those either :-)
07:16:48 <edwardk> glad to see it was of some use
07:17:02 <JaffaCake> tomshackell: calls to a foreign export
07:17:14 <JaffaCake> in general, you want to allow them from any OS thread at any time
07:17:34 <tomshackell> oh calls back into haskell from foreign code?
07:17:41 <JaffaCake> yup
07:17:41 <edwardk> i'd throw my JITed version of it online somewhere but i don't think dons wants to recalibrate all of his statistics for those at this late date ;)
07:17:49 <tomshackell> JaffaCake, no it doesn't do those either :-)
07:18:00 <RobHu> Some discussion of edwardk.c here: http://pw201.livejournal.com/70254.html
07:18:07 <tomshackell> nor does it do foreign export wrapper or whatever it is :-)
07:18:14 <JaffaCake> ah right
07:18:19 <xho> if i have ghc in non threaded mode, and i spawn an additional thread, then i will have only one os thread, but then as soon as one of my threads makes a FFI call then an OS thread will be at that point created?
07:18:47 <JaffaCake> xho: no, it doesn't work like that
07:19:02 <JaffaCake> in non-threaded mode you never get another OS thread
07:19:15 <tomshackell> oh so FFI calls block all threads.
07:19:22 <JaffaCake> in non-threaded, yes
07:19:38 <JaffaCake> in threaded, a "safe" call will start another OS thread
07:19:39 <tomshackell> Yhc also doesn't do that :-)
07:20:05 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs
07:20:18 <JaffaCake> tomshackell: I guess you have no distinction between safe and unsafe (which is fine)
07:21:12 <tomshackell> JaffaCake, no but some of the builtin primitives are marked as "you don't need to spawn a thread for this because it terminates quickly".
07:21:34 <JaffaCake> right, that's more or less what unsafe does
07:22:25 <JaffaCake> ghc's implementation is a bit different, it doesn't switch to make the call
07:22:37 <JaffaCake> but we designed the semantics so that you could do it either way
07:22:45 <JaffaCake> I'm glad someone is doing it the other way :)
07:22:57 <tomshackell> it doesn't switch to make the call?
07:23:18 <JaffaCake> no, if you make a blocking call, another OS thread takes over the RTS
07:23:32 <tomshackell> oh right, that's an interesting approach :-)
07:23:55 <JaffaCake> if the call returns quickly, the original thread grabs the RTS again
07:24:19 <tomshackell> yes that's probably a little bit more efficient.
07:24:27 <tomshackell> but Yhc isn't overly fussed on efficiency.
07:24:39 <JaffaCake> right.  that's the tradeoff we had in mind
07:28:31 <edwardk> mauke: that is evil
07:29:01 <mauke> thanks
07:30:01 <RobHu> edwardk: I'd be interested to see the JITed version if you have it hanging around :)
07:30:09 <LoganCapaldo> is it portable?
07:30:48 <mauke> I think it requires x86/linux (assuming you mean my code)
07:31:51 <LoganCapaldo> yeah i did mean yours
07:32:15 <LoganCapaldo> doesn't appear to work here
07:32:18 <edwardk> RobHu: i'll see if i can find it when i get home tonight, i have a few of them, i have a haskell one that generates haskell code and runs itself, which is pretty pathetic actually the first run, but eventually gets up to speed, a perl one that uses inline c, and a rather fast haskell one that uses an assembler monad to generate dynamic code.
07:32:29 <LoganCapaldo> (OS X/PPC)
07:32:57 <edwardk> er the first haskell one uses hs-plugins to run the code it generates, but it compiles sloooow.
07:33:00 <RobHu> edwardk: I would find those interesting to read :P I don't hang around in #haskell... are you going to put them on a blog or a site somewhere?
07:33:20 <edwardk> well i think the first couple are up on comonad.com somewhere in the wiki
07:34:01 <edwardk> the last one is something i was playing with since then to get a feel for how to build a decent assembler monad, i'm not sure if i finished it to a usable state, now i'd probably rewrite it to use harpy
07:34:34 <tomshackell> JaffaCake, anyhows thanks for your help I'll get back to implementing it :-)
07:34:53 <JaffaCake> no problem, have fun :)
07:41:46 <dylan> Why does it seem all sysadmin jobs are for windows, and all programming jobs are for C-pound or Java?
07:42:19 <edwardk> because microsoft won the war. ;)
07:42:25 <dylan> why does mediocrity rule?
07:43:00 <edwardk> because its cheaper than innovation?
07:43:08 * dylan sighs
07:43:16 <mempko> very philosophical discussion
07:43:18 <dylan> perhaps I need to find a non-technical job.
07:43:40 <Itkovian> such as?
07:43:46 <Wild_Cat> Java (and Windows, for that matter) is a shining example of what I like to call the Counterstrike effect.
07:44:01 <Itkovian> Wild_Cat: elaborate ...
07:44:27 <dylan> Itkovian: bookstore attendent, library assistant, or somesuch?
07:44:52 <Philippa> CS probably isn't a fair target for the name
07:45:06 <Wild_Cat> Counterstrike is a Half-Life mod. It is but one out of hundreds, and there are a lot of other free HL mods that are objectively better than it is.
07:45:20 <Wild_Cat> the question is, therefore: why does everyone play Counterstrike?
07:45:22 <Itkovian> ah, right
07:45:31 <Wild_Cat> ...to which the answer is: because everyone plays Counterstrike.
07:45:43 <dylan> I've never played counterstrike
07:45:46 <Itkovian> the real question is: Why do all the other FPSs try to make a CS-like mod.
07:45:50 <koala_man> objectively better? really?
07:45:53 <Philippa> which is to utterly ignore the forces that caused the popularity explosion
07:46:11 <Wild_Cat> Philippa: that's because they're totally irrelevant now.
07:46:19 <Philippa> there aren't many objectively better mods in that approximate genre that're objectively better than CS and have been around anywhere near as long
07:46:27 <edwardk> counterstrike became popular because it was distinctive, you won't get into the same class of popularity by copying it
07:46:41 <siti> yeah CS was amazing when it first came out
07:46:44 <Wild_Cat> how things came to be isn't important. How things *are* is.
07:46:53 <Wild_Cat> (in the area of computer software, anyway)
07:46:56 <Philippa> Wild_Cat: that's rather naive
07:47:42 <Itkovian> Wild_Cat: I don't completely agree. If you wish to change things, having an idea why and how might help do better.
07:48:05 <edwardk> we are where we are today because of a form of social hill climbing, sometimes it is useful to see the initial conditions to figure out how we got stuck on top of this hill, when we really want to be hiking up that mountain range off to the side.
07:48:06 <Wild_Cat> Philippa: well, understanding how things came to be is probably necessary in order to change them, but if all you need to know is why they remain as they are, "everyone plays CS because everyone plays CS" is enough.
07:48:51 <Philippa> they don't though. It's clear that Java's hit peak by now, for example
07:48:52 <Wild_Cat> I'm fully aware that this is short-term reasoning, but alas it's how most corporations (heck, people) think.
07:49:00 <siti> people started playing CS, because it was a REALLY good MP game.  People still play it because they invested so much time in it and know the game better than the back of their hand. :P
07:49:22 <Wild_Cat> siti: exactly. s/CS/Java|Windows|C++|whatever/
07:49:24 <Philippa> me, I ditched it partly because I took a hiatus and half the things I knew like the back of my hand changed
07:49:39 <Philippa> funny how C++ isn't what it was a decade ago
07:50:04 <LoganCapaldo> are any of us what we were a decade ago?
07:50:12 <edwardk> because you took time off and half the things you knew like the back of your hand changed? =)
07:50:13 <LoganCapaldo> Time marches on...
07:50:42 <Philippa> edwardk: nah. I said ten years, not 15-20 :-)
07:50:49 <Wild_Cat> somebody once said Java is the new COBOL. He's right.
07:51:17 <dylan> my COBOL at work is actually lotus basic, which I've steadily avoided using for months now.
07:51:36 <Wild_Cat> dylan: Lotus Basic!?
07:51:44 <edwardk> java has managed to cement itself in that sort of enterprisy niche where COM and CORBA used to sit. its welcome to it.
07:51:45 <dylan> as in, lotus notes basic.
07:52:04 <Wild_Cat> oh, $deity!
07:52:09 <siti> yeah those enteprise code jokes are so true
07:52:29 <dylan> I manage to write things in perl, partly because they change things so often I need to be able to turn around working things quickly.
07:52:33 <siti> anything that java does is enteprise that's why it's ok to write ten times the LOC ;)
07:52:52 <dylan> my boss actually complained, "Everything is perl perl perl with you. you're stuck on perl"
07:53:06 <dylan> to which I asked if he'd like me to use a different language every day for a month.
07:53:23 <dylan> (and he didn't think 31 languages *existed*)
07:53:30 <Wild_Cat> to be more accurate: most of what people are paid to do in Java has management insisting that it be "Enterprise" (the fact that it's a meaningless buzzword notwithstanding).
07:54:09 <pejo> dylan, he should be happy - if your perl is sane he can replace you immediately.
07:54:28 <dylan> pejo: that's the best part. He doesn't believe other people use perl.
07:54:31 <Philippa> It's not totally meaningless, if you understand what the actual concerns involved are
07:54:56 <Philippa> "Enterprise" really means "something I can achieve serious uptime with in the middle of a huge, evolving system"
07:54:59 <siti> I just bang my head at how bad java is when I am coding
07:55:04 <dylan> he believes I am an autistic savant and that I am impossible to replace...
07:55:11 <Philippa> lucky for you, huh?
07:55:24 <dylan> I used to think so.
07:55:45 <siti> when I code in haskell I find so much cool stuff
07:56:00 <siti> I am always amazed at how concise my code can be :)
07:56:34 <Wild_Cat> Philippa: unfortunately, it seems to have devolved into "something that can't be run below $15000 of dedicated hardware".
07:56:51 * dylan likes writing things like lines >>> partition isField >>> parseField *** unlines >>> done
07:57:31 <Wild_Cat> to the point that "it's Enterprise" has become one of the worst insults I can hurl at someone's code. (just below "horrible soup of GOTO statements" and "Visual Basic")
07:58:10 <LoganCapaldo> Wild_Cat: Where's "One giant if statement" fall on your list?
07:58:43 <edwardk> there is a place for enterprise development. i do a fair bit of it when forced, but its not my preferred kind of code. i much prefer something lightweight functional and tricky.
07:58:45 <Wild_Cat> LoganCapaldo: close to "inheritance through copy and paste"
07:58:49 <dylan> or "that's a sweet one-pager"?
07:59:02 <Philippa> Wild_Cat: yeah, it's often built by trying to bullet-proof the code with a shitload of boilerplate
07:59:06 <edwardk> wildcat: abject-oriented programming?
07:59:30 <Philippa> edwardk: it's potentially interesting if you actually get to build the framework yourself. Unfortunately pretty much only a handful of people in a given company get to do that
07:59:49 <edwardk> Philippa: fortunately thats usually my role ;)
08:00:14 <DRMacIver> Philippa: My experience is that people who get to build the framework are just as bad as those who don't, they just do it on a higher level. :)
08:00:18 <Wild_Cat> Philippa: auto-generated, useless boilerplate, most of the time. Besides, to me, the mere presence of boilerplate OR auto-generated code is indicative of huge deficiencies, either in the design, or in the technologies in use.
08:00:41 <DRMacIver> (though this is more through inspecting the results)
08:00:45 <edwardk> er for those of you who didn't get the reference: http://typicalprogrammer.com/programming/abject-oriented/
08:00:50 <lambdabot> Title: Introduction to Abject-Oriented Programming &#8212; Typical Programmer
08:00:50 <siti> Wild_Cat: exactly, with java I find my self repeating things so much :(
08:00:50 <flux> a versioned copy paste would be a nice toy to see implemented
08:01:01 <DRMacIver> Wild_Cat: I disagree that autogenerated code is indicative of a deficiency.
08:01:11 <DRMacIver> Wild_Cat: It depeneds what it's being autogenerated for and from.
08:01:16 <siti> flux: I think kde has something like klipper
08:01:20 <flux> each character would contain information in which file/revision it originated, and all its history (with some obvious optimizations), and copy/paste would keep track
08:01:21 <Wild_Cat> DRMacIver: correction: it is a deficiency if you ever get to see (let alone modify) it.
08:01:44 <edwardk> Wild_Cat: that i'll agree with
08:01:57 <DRMacIver> Well, if it's mixed in with your normal code then I agree.
08:02:01 <flux> from quick glance I don't mean klipper
08:02:15 <flux> I meant in the context of an editor
08:02:17 <quicksilver> "inheritance through copy and paste"
08:02:20 <quicksilver> I like that!
08:02:45 <siti> flux: ok
08:02:54 <flux> how cool would it be in an interprisey application to see to how many places a buggy piece of code has been copied?
08:03:23 <siti> you know you have a broken language when you NEED an idea
08:03:33 <siti> cough, java is horrible without eclipse or netbeans
08:03:38 <siti> ide*
08:04:06 <DRMacIver> flux: There are good tools for detecting code duplication in Java.
08:04:10 <edwardk> flux: its called grep ;)
08:04:14 <DRMacIver> Or at least reasonable tools. :)
08:04:35 <edwardk> or you can try to see if SCO will license you their tools ;)
08:05:17 <Philippa> siti: projects over a certain size'll leave you wanting one pretty badly. There comes a point where refactorings above a certain size are just too painful to do by hand
08:05:19 <LoganCapaldo> If copy and pasted code had revision history attached like flux suggests, you could set it up so that anytime you edited one instanc eof the paste it would be reflected every where else it was pasted. muahahahaha
08:05:25 <Wild_Cat> edwardk: risky. If you do you'll find that most of your code infringes some of their patents.
08:05:34 <edwardk> heh
08:05:47 <mempko> who has read the recent OS design thread on gmane.comp.lang.haskell.cafe?
08:05:52 <Wild_Cat> I mean, surely some of your C code includes the line #include <stdio>, right?
08:05:59 <siti> Philippa: I didn't say ides are bad, I love eclipse, but if the language NEEDS an ide, I think it's broken :p
08:06:01 <Wild_Cat> that's $700 for you.
08:06:11 <edwardk> Wild_Cat: per user
08:06:12 <siti> if you need silly tools like generate setters and getters
08:06:21 <Philippa> mempko: the gmane names... aren't usenet, or valid outside gmane. The rest of us know it as the haskell-cafe mailing list
08:06:23 <siti> you have a broken language
08:07:09 <mempko> philippa: yes, I shall call it haskell-cafe then :-)
08:07:14 <edwardk> heh, here i am putting together a toy language that really needs editor support to be viable, i am going to go hang my head in shame now ;)
08:07:27 <siti> you should ;)
08:07:41 <siti> editor is different from an ide...
08:08:05 <edwardk> if only because syntax highlighting is needed to help you keep track of precedence rules and what is in scope, so you know what is being bound by a statement, etc.
08:08:28 <quicksilver> there's nothing wrong with editor support, in principle
08:08:30 <siti> yeah, I wouldn't say a language is broken if it needed that
08:08:36 <quicksilver> but it does make things painful in practice, if you're not careful
08:08:44 <quicksilver> epigram esentially requires editor support
08:08:47 <quicksilver> it's somewhat 2D
08:08:50 <siti> it's when you need all these random generator tools, templates etc otherwise you go insane :p
08:09:18 <Philippa> the somewhat 2Dness isn't that big a deal. I've seen epigram source in an ordinary text editor, it worked
08:09:25 <Philippa> it's the interactivity that's important
08:09:29 <quicksilver> Philippa: reading it is find
08:09:32 <edwardk> yeah, i'm trying to basically let you do edits in a text editor if you have to, but you'll want an IDE for coding, eclipse or visual studio
08:09:36 <quicksilver> Philippa: editing it is a pain
08:09:44 <quicksilver> Philippa: (if you have to change the size of some of the boxes)
08:10:08 <quicksilver> not impossible, obviously
08:10:12 <quicksilver> just a pain :)
08:10:16 <edwardk> heh, epigram reminds me of coding in that 2d language from the ICFP this last year
08:10:22 <Philippa> quicksilver: I got the impression it was actually how James McKinna prefers to work
08:10:30 <Wild_Cat> 2D language? Like Befunge?
08:10:37 <Philippa> not really
08:10:38 * Wild_Cat shudders
08:10:48 <edwardk> it was a sort of 2d circuit diagram functional programming language
08:10:54 <edwardk> you had to minimize the 'area' of your programs
08:10:55 <Philippa> I mean, funges're kinda like nd concatenative langs
08:11:06 <quicksilver> Philippa: interesting. Well we're not all James McKinna though :) But possibly he is supported by some nice editor macros, I wonder?
08:11:27 <Wild_Cat> that reminds me of a few dailyWTF calculator entries.
08:11:31 <mux> List::Util is funny
08:11:39 <Philippa> I wasn't seeing a lot of visible sheds. I suspect there's an automatic way for them to be introduced
08:12:02 <mux> they have somehow implemented folds in perl with "reduce"
08:12:10 <Philippa> edwardk: a friend of mine built a language like that, though I'm not sure quite how functional it was
08:12:22 <mux> and then they implement maximum, minimum, sum, etc in terms of it
08:12:40 <wolverian> why is it funny?
08:13:02 <quicksilver> 'reduce' is just another name for fold
08:13:07 <quicksilver> List::Util is handy
08:13:11 <quicksilver> although it has some annoying holes
08:13:15 <mux> maybe "funny" wasn't the right word
08:13:18 <wolverian> that's why we have List::MoreUtils :)
08:13:21 <mux> I like it
08:13:55 <wolverian> and List::Util::Superpositions # warning, slow
08:15:44 <LoganCapaldo> is ::Superpositions the list monad?
08:15:55 <wolverian> it's the quantum monad
08:16:10 <osfameron> eeeek!  perl on #haskell, theorem proving on #catalyst, the world has gone insane
08:16:36 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/331
08:16:44 * LoganCapaldo is waiting for Haskell' to get perl sigils on its variables
08:16:53 <LoganCapaldo> then the world will have gone mad
08:16:54 <wolverian> perl5 or 6? :)
08:16:59 <Saizan> sigils?
08:17:05 <Saizan> $%@ etc?
08:17:08 <wolverian> right.
08:17:10 <LoganCapaldo> yeah
08:17:42 <edwardk> LoganCapaldo: you try to convince the Simons that it would help future proof the language design, enabling them to add more keywords at will. ;)
08:17:56 <LoganCapaldo> heheh
08:18:07 <LoganCapaldo> but less keywords are the better
08:18:10 <edwardk> though i tend to think its the keywords that should be sigil'ed in a language.
08:18:24 <edwardk> $private, $public, that i could stomach
08:18:24 <LoganCapaldo> yeah I thought about have a keyword namespace
08:18:42 <LoganCapaldo> keyword:while ( a < b ) ...
08:18:52 <LoganCapaldo> or something
08:19:06 <edwardk> in my case i was thinking about supporting arbitrary xml namespaces, then you stick keywords in one for each version of the language specification
08:19:17 <edwardk> the ones in scope tell you what version of the language your code is in.
08:19:20 <wolverian> LoganCapaldo, statement:<foo> (...) in perl6 :)
08:19:39 <LoganCapaldo> <foo> being the keyword?
08:19:48 <wolverian> right. the <> are a quotish thing.
08:19:53 <edwardk> also lets you bind a scope to say that something is a variable, even though its some how a reserved symbol.
08:19:53 <LoganCapaldo> ah
08:20:09 <edwardk> var:if ... ala c#'s @ operator
08:20:09 <LoganCapaldo> edwardk: yeah that was part of my motivation
08:20:22 <edwardk> i actually have a parser for that lying around
08:21:16 <wolverian> http://perlcabal.org/syn/S02.html#Grammatical_Categories
08:21:18 <lambdabot> Title: S02
08:21:19 <edwardk> that supports that and using entity declarations as proxies so you can write unicode source code in plain text with possibly more descriptive names
08:22:23 <edwardk> a &#x2229; b or something like that, which with an entity gives you a &intersect; b, but the code views right in a browser, etc.
08:23:12 <edwardk> never finished wrapping the language in it because the details got to be a little too pedantic though
08:27:54 <ajudem_me>   ajudem_me pasted "(no title)" at http://hpaste.org/331 -> do you know what's the problem?
08:29:50 <boyscared> i'm trying to compile the hs-hat port on freebsd. there's a ghc call that includes "-package lang" which isn't found.. is there any way to install this?
08:30:05 <Saizan> ajudem_me: you forgot an else branch
08:30:18 <malcolmw> boyscared: -package lang was removed in ghc-6.6
08:30:39 <LoganCapaldo> ajudem_me: return isn't return
08:30:54 <malcolmw> boyscared: you could just remove references to -package lang in the Hat source build system
08:31:09 <LoganCapaldo> > return 1 >> return 2 >> return 3 :: Maybe Int
08:31:11 <lambdabot>  Just 3
08:31:13 <boyscared> ok, thanks
08:31:33 <ajudem_me> LoganCapaldo can't I put more that one return?
08:31:41 <LoganCapaldo> yeah sure
08:31:46 <sjanssen> ajudem_me: missing else
08:31:49 <LoganCapaldo> but it doesn't break out of the function
08:31:55 <sjanssen> oops, LoganCapaldo is allow over it
08:32:12 <sjanssen> s/allow/all
08:32:13 <notsmack> ajudem_me: the point is they don't return, they just wrap a value in a monad
08:32:16 <LoganCapaldo> the missing else is the syntax error for sure
08:32:27 <ajudem_me> ok =)
08:32:42 <LoganCapaldo> but judging by putStrlN "Erro Programa" return () I think you were trying to exit early, which return doesn't do
08:33:45 <notsmack> ajudem_me: the putStrLn already returns an IO () value, so the return is superfluous
08:33:58 <hpaste>  sjanssen annotated "(no title)" with "works?" at http://hpaste.org/331#a1
08:34:01 <hpaste>  ajudem_me annotated "(no title)" with "(no title)" at http://hpaste.org/331#a2
08:35:43 <ajudem_me> sjanssen... w8
08:37:11 <sjanssen> ajudem_me: what sort of error do you have with your latest annotation?
08:37:23 <sjanssen> ajudem_me: you're missing an 'in'
08:40:28 <LoganCapaldo> @index getAFile
08:40:28 <lambdabot> bzzt
08:40:46 <LoganCapaldo> @type ReadMode
08:40:54 <lambdabot> Not in scope: data constructor `ReadMode'
08:40:59 <LoganCapaldo> k
08:41:26 <hpaste>  sjanssen annotated "(no title)" with "partial rewrite" at http://hpaste.org/331#a3
08:42:14 <ajudem_me> yes... that was the problem ;)
08:43:24 <LoganCapaldo> sjanssen: is that a common idiom, case () with guards for a multiway if?
08:45:20 <quicksilver> LoganCapaldo: I've used it occasionally, although I feel it is slightly ugly
08:45:27 <quicksilver> LoganCapaldo: but multi-way ifs are uglier :)
08:47:17 <LoganCapaldo> quicksilver: I've just never seen it before, and thought it was a relatively clean solution
08:47:39 <quicksilver> LoganCapaldo: sometimes I prefer to use a 'let' to a 'case'
08:47:52 <quicksilver> (you can put guards on lets, too)
08:48:24 <LoganCapaldo> You can put guards on lets!?!?!
08:48:36 <LoganCapaldo> what happens if the guard fails?
08:48:51 <LoganCapaldo> oh wait
08:49:02 <quicksilver> > let {foo | True = 5 ; | False = 4} in foo
08:49:03 <lambdabot>  Parse error
08:49:08 <quicksilver> bah
08:49:11 <quicksilver> well something like that :)
08:49:11 <LoganCapaldo> > let { x | True = 1 ; x | False = 0 } in x
08:49:16 <lambdabot>      Conflicting definitions for `x'
08:49:16 <lambdabot>     In the binding group for: x, x
08:49:35 <quicksilver> > let {foo {| True = 5 ; | False = 4}} in foo
08:49:35 <lambdabot>  Parse error
08:49:38 <quicksilver> !
08:50:39 <LoganCapaldo> > let x | True = 1; | False = 0 in x
08:50:40 <lambdabot>  Parse error
08:50:48 <LoganCapaldo> > let x | True = 1 | False = 0 in x
08:50:49 <lambdabot>  1
08:51:03 <LoganCapaldo> neat!
08:52:29 <quicksilver> oh, guards aren't layout at all?
08:52:30 <quicksilver> :)
08:52:33 * quicksilver <-- fool
08:52:47 <SamB> quicksilver: they must surely be somewhat
08:53:10 <SamB> but, not like that.
08:56:58 <hpaste>  LoganCapaldo annotated "(no title)" with "quicksilver: thusly?" at http://hpaste.org/331#a4
08:58:00 <quicksilver> LoganCapaldo: yes, exactly like that
08:58:11 <LoganCapaldo> I like that :)
08:58:12 <quicksilver> LoganCapaldo: only, personally, I'd put the 'in putStrLn' part on a fresh line
08:58:18 <LoganCapaldo> mm
08:58:27 <quicksilver> LoganCapaldo: otherwise it looks like it 'belongs' to the third case
08:58:29 <quicksilver> (to my eyes)
08:58:30 <LoganCapaldo> yeah
08:58:35 <LoganCapaldo> ISWYM
08:59:09 <quicksilver> you've also eliminated the code duplication of putStrLn
08:59:13 <quicksilver> so I much prefer your version :)
08:59:20 <SamB> that is, they've got no more layout than anything else
08:59:31 <SamB> (except comments and whitespace)
08:59:47 <SamB> (... and continued strings)
09:02:48 <hpaste>  LoganCapaldo annotated "(no title)" with "(!!) :(" at http://hpaste.org/331#a5
09:08:09 <oerjan> LoganCapaldo: not sure what you are after but i see an extra ) after the last mundo
09:10:00 <LoganCapaldo> oerjan: oops :)
09:10:28 <LoganCapaldo> oerjan: it was putStrLn (...) before
09:10:44 <monochrom> I miss the Haskell Bimonthly News. :)
09:11:50 * kolmodin too
09:12:15 <sjanssen> does HC&AR publish more often than HWN now?
09:12:24 * Philippa has a sudden urge to spoof and wonders just how many haskellers're bi anyway
09:12:43 <conal> spoof?
09:13:37 <monochrom> Hahaha
09:13:52 <monochrom> @remember sjanssen does HC&AR publish more often than HWN now?
09:13:52 <lambdabot> Done.
09:13:55 <Philippa> conal "Haskell Bi Monthly News"
09:14:06 <Philippa> (there should be a : in there somewhere)
09:14:08 * conal blushes
09:14:51 <Philippa> like I said, I wonder just how many haskellers are bi anyway :-)
09:15:18 <monochrom> I'm a bipedal.
09:17:12 * byorgey has a bicycle which also has two pedals
09:18:09 <monochrom> Then you have four pedals in total. :)
09:20:50 <dylan> are chickens considered bipedal?
09:21:41 <monochrom> Yes.
09:21:58 <dylan> mmm, carbon based bipeds.
09:22:06 <Serge`> (17:24:57) (Serge`) !define bipedal
09:22:06 <Serge`> (17:25:00) (MuBot) [bipedal]: Walking on two legs.
09:22:09 <Serge`> =>
09:22:51 <dylan> offhand, I can't think of a biped that is both not human and a mammal.
09:23:14 <dylan> seems birds dominate the field, so to speak...
09:24:14 <Syzygy-> dylan: Kangaroos?
09:24:24 <byorgey> dylan: uh, gorillas don't count?
09:24:45 <notsmack> http://en.wikipedia.org/wiki/Image:Bristol.zoo.western.lowland.gorilla.arp.jpg
09:24:47 <lambdabot> Title: Image:Bristol.zoo.western.lowland.gorilla.arp.jpg - Wikipedia, the free encyclop ..., http://tinyurl.com/24h4oy
09:25:30 <dylan> byorgey: bah, those are mostly human. ;)
09:25:36 <Syzygy-> ...
09:25:44 <notsmack> Gorillas move around by knuckle-walking.
09:25:57 <Syzygy-> I stand by my suggestion of Kangaroos.
09:26:10 <dylan> Syzygy-: Thank you! Kangaroos! Of course.
09:26:14 <Syzygy-> And if you disqualify hopping, I'm going to call "No true scotsman" and abandon this discussion. :
09:26:17 <Syzygy-> :P
09:26:29 <dylan> No true scotsman is also a kangaroo.
09:26:30 <Syzygy-> dylan: Of course the weird counterexample would be Australian. ;)
09:26:51 <dylan> Next you'll tell me there is an egg-laying mammal.
09:27:49 <Syzygy-> dylan: "No true scotsman" is a type of bad argument... The definition of a $FOO is whatevery you want it to be, and as soon as someone proposes a counterexample to the stated definition of $FOO, some property of the counterexample, no matter how bizarre, is pointed upon as to demonstrate that it isn't really a $FOO after all.
09:27:58 <Syzygy-> And yeah, I'd point to the platypus for that. :P
09:28:23 <dylan> Syzygy-: I know, I was joking
09:28:27 <Syzygy-> :)
09:28:35 <dylan> for both
09:28:43 <Syzygy-> I wasn't certain whether you actually knew (platypus|no true scotsman)
09:28:57 <dylan> "no true scotsman is also a kangraroo" is a non-sequitor, I believe.
09:29:11 <dylan> *kangaroo.
09:29:41 <chessguy> man i hate imperative languages:
09:29:44 <chessguy>     if (!(prototypes instanceof Array)) {
09:29:44 <chessguy>         prototypes = [prototypes];
09:29:45 <chessguy>     }
09:30:04 <chessguy> well, s/imperative/dynamically typed/
09:30:30 <chessguy> not to mention mutable
09:32:50 <arcatan> don't be so narrowminded
09:33:16 <chessguy> bah
09:33:27 <chessguy> be as broad-minded as you want, that's still ugly
09:33:50 <monochrom> I hate openmindedness.
09:34:13 <monochrom> But I guess it depends on the definition of openmindedness.
09:34:27 <chessguy> the biggest problem with haskell is that you get spoiled when you have to go back to languages that everyone else uses
09:34:49 <byorgey> chessguy: what language is that?
09:35:10 <chessguy> languageS, that would be plural
09:35:41 <byorgey> chessguy: I mean, what language is that code you pasted?
09:35:43 <DRMacIver> But if you're lucky you can raid Haskell for ideas. :)
09:35:46 <chessguy> oh
09:35:49 <chessguy> javascript
09:35:57 <byorgey> chessguy: totally agree about the problem with Haskell, though =)
09:36:15 <byorgey> javascript, I see
09:36:22 <DRMacIver> (And then you can be even more miserable at how hard they are to make work in other languages)
09:37:41 <monochrom> I miss higher-order modules from ML.
09:38:17 <ddarius> monochrom: Encode them.
09:38:22 <chessguy> by the way, i had this weird idea the other day
09:38:25 <monochrom> I hate encoding.
09:38:44 <chessguy> what if we could formalize language specification
09:38:57 <monochrom> I also hate coding, but enough hatred for a day. :)
09:39:21 <osfameron> but dynamically typed things are lovely :-)
09:39:23 <ddarius> monochrom: That's fine.  I have enough of my own.
09:39:30 <chessguy> so instead of having the 900-page H98 standard, we'd have a formal specification of it, in some meta-language. and ditto for other languages
09:39:40 <monochrom> We can formalize language specification. But many coders disdain it.
09:39:47 <chessguy> monochrom, why?
09:40:03 <monochrom> They flunked math.
09:40:05 <ddarius> H98 is not 900 pages
09:40:15 <chessguy> wouldn't it make meta-programming easier?
09:40:25 <chessguy> ddarius, that was a flagrant exaggeration
09:40:37 <chessguy> not intended to be serious, but to make a point
09:40:38 <monochrom> Anyway I don't claim to understand humans and why they avoid formalizations.
09:40:53 <ddarius> chessguy: Well, C++ can be viewed anywhere between something like 1100 and upwards of 3000
09:40:57 <vincenz> overtly exaggerated claims rarely make a good basis for a point
09:41:56 <chessguy> vincenz, the point was obviously that the formal specification would be more concise
09:42:04 <vincenz> chessguy: that's debatable
09:42:04 <chessguy> and precise
09:42:09 <chessguy> and machine-readable
09:42:37 <byorgey> chessguy: are you talking about formally specifying the semantics?
09:42:41 * LoganCapaldo wish machine-readable guaranteed machine-checkable
09:42:51 <byorgey> the H98 report already includes a formal grammar, doesn't it?
09:42:56 <chessguy> byorgey, and syntax
09:43:07 <chessguy> byorgey, the grammer is for syntax, not semantics
09:43:13 <byorgey> chessguy: right, I know
09:43:28 * monochrom observes that machine-checkable guarantees machine-readable. :)
09:43:59 <chessguy> monochrom, there you go: problem solved!
09:44:06 <vincenz> once we have haskell defined in some language to specifiy the semantics, I think we should make it more concise by specify the semantics of the language used to specifiy the semantics of haskell.  If we keep going like this, eventually it will take just 1 page to describe it all
09:44:39 <chessguy> hmm
09:44:50 <chessguy> ok, you make a valid point, even if it's overtly exaggerated
09:44:53 <chessguy> (imagine that)
09:44:54 <vincenz> though in all seriousness
09:45:02 <vincenz> I think the project by alan kay is intended for that
09:45:03 <monochrom> The string "Haskell 98" is less than 1 page. :)
09:45:09 <ddarius> vincenz: You're thinking small, eventually it will only take one line!
09:45:13 <vincenz> they want to write a full OS in 20K lines
09:45:23 <vincenz> by going ultra meta
09:45:25 <vincenz> l
09:45:34 <ddarius> vincenz: I imagine Alan Kay has already done that a few times.
09:45:39 <chessguy> well, part of my point too was to standardize all language specification
09:45:46 <vincenz> chessguy: I think it's a valid idea, the problem is that as long as your language isn't' perfect, you lose a lot on specifying the little corner cases
09:46:06 <DRMacIver> vincenz: An obvious solution to that problem presents itself. :)
09:46:27 <vincenz> DRMacIver: I disagree
09:47:01 <vincenz> DRMacIver: I wrote an operationa lsemantics for a language that was a subset of C++.  I tried to keep it as clean as possible while keeping it purely a stack-based langaueg, aka no GCC.  Things like initializer lists, which create a corner case in your semantics, were impossible to remove.
09:47:08 <vincenz> erm
09:47:09 <vincenz> no GC
09:47:09 <monochrom> You can already use "structured operational semantics" to specify the semantics of almost all programming languages.  SML already does it.
09:47:46 <chessguy> monochrom, can you (easily) denote things like lazy evaluation in it?
09:47:59 <monochrom> Yes.
09:48:18 <vincenz> monochrom: the issue is not the feasibility but the conciseness
09:48:37 <vincenz> especially when you want to specify a meaningful subset of your language
09:48:42 <monochrom> Right, the SML one is still like 50 pages or 100 or something.
09:48:52 <DRMacIver> vincenz: I'm not exactly being serious when I describe "only make perfect languages" as an obvious solution to the problem. ;)
09:48:52 <vincenz> I mean you have a lot of crap that's gonna be difficult to add, for instance FFI
09:49:09 <chessguy> ouch
09:49:16 <chessguy> good point
09:49:17 <vincenz> DRMacIver: ah ok :)
09:49:37 <chessguy> just insert all the semantics of C++, no big deal :)
09:49:43 <vincenz> chessguy: eh
09:49:49 <chessguy> (joke0
09:49:51 <vincenz> chessguy: semantics of C++ don't exist
09:50:01 <vincenz> I know someone wrote an entire phd thesis just on the semantics of C
09:50:07 <vincenz> and it used some really ugly rules for some stuff
09:50:30 <vincenz> (for instance sequence points are a mess, as are unsafe casts of pointers)
09:51:13 <vincenz> anywho, time for some useful work, thanks for the interesting discussion
09:51:34 <chessguy> yeah, i gotta get back to banging my head against my desk (aka programming in javascript)
09:51:57 <ddarius> javascript isn't that bad
09:52:12 <chessguy> this particular instance is :)
09:52:42 <DRMacIver> That look relatively pleasant to me actually.
09:52:50 <DRMacIver> You just need to get into the right mindset. :)
09:53:38 <notsmack> would that be 'deranged'?
09:53:46 <chessguy> DRMacIver, take it to #biteme please :)
09:53:51 <monochrom> But generally I don't buy the "not concise" argument. It's too subjective and also too subjective to cheating. Is "just sort the damn array" more concise than the math notation for "new array is <longish expression for nondecreasing>, is <longish expression for permutation of old array>"?  I say no, "sort" is meaningless unless you have gone through the pain of knowing nondecreasing and permutation. Some "conciseness" is just
09:53:51 <monochrom>  hiding the problem under the rug.
09:54:22 <DRMacIver> notsmack: Sane people are no fun anyway.
09:54:48 <chessguy> anyway
09:54:50 <chessguy> </whining>
09:54:59 <Philippa> monochrom: you wouldn't be happy if you couldn't define what "sort the damn array" means though
09:56:49 <monochrom> Didn't I exactly say that?
09:58:30 <Philippa> not as such
09:58:57 <Philippa> you said it should be possible to express the things that should be the definition of sorting. Binding 'em to a name's another matter
09:59:36 <shapr> @users
09:59:36 <lambdabot> Maximum users seen in #haskell: 333, currently: 310 (93.1%), active: 12 (3.9%)
09:59:47 <shapr> Whoa, only 12?
09:59:59 <vincenz> @users
10:00:00 <lambdabot> Maximum users seen in #haskell: 333, currently: 310 (93.1%), active: 12 (3.9%)
10:00:17 <vincenz> > replicate 310 "lambda-cookie"
10:00:19 <lambdabot>  ["lambda-cookie","lambda-cookie","lambda-cookie","lambda-cookie","lambda-coo...
10:00:38 <ddarius> shapr: At least it's been an fairly active 12
10:04:00 <monochrom> Did I write too much, with one too many examples, and too few linebreaks?
10:04:05 <shapr> ddarius: Yeah, that is nice.
10:05:09 <monochrom> I was attacking the "conciseness" argument. Take an informal statement that looks concise. Take a formal statement that looks longish. I say, the informal one is cheating.
10:06:28 <ddarius> monochrom: Of course it is, that's the whole point.
10:07:07 <ddarius> But what I think Philippa is saying is that you should be able to bind that formal definition to the name "sort" and then it's short too.
10:07:18 <monochrom> Do I write too concretely, with too good examples? Should I write abstractly, with no example, no attempt at justification?
10:07:27 <Philippa> and then the cheat becomes formal
10:07:41 <monochrom> Yes yes ok.
10:08:08 <LoganCapaldo> Sir, your cheat is not wearing a tie. This is a formal event. I must ask your cheat to please leave.
10:08:12 * Philippa is reminded of the argument she had with sorear this morning though
10:08:31 <Philippa> but a tie'd go awfully with that dress!
10:08:56 <monochrom> Because in here and on the mailing lists I'm seeing the same disparity.  Lots of people write abstractly, no example.  I give examples.  I'm feeling that I am an odd man out in the haskell community.
10:09:27 <LoganCapaldo> examples++
10:09:49 <LoganCapaldo> need them to start to understand the abstractles.
10:09:58 <LoganCapaldo> at least in my experience
10:10:07 <vincenz> monochrom: I lke examples myself, it allows me better to grasp and understand what s said
10:11:06 <ddarius> I often speak only in examples.
10:11:59 <ddarius> I like both.
10:14:04 <osfameron> If I could have only a description of something or only an example of how it was used, I'd always prefer the example.
10:14:37 <ddarius> Which I would prefer depends on the circumstances.  I would always prefer both.
10:23:59 <oerjan> @karma C
10:24:00 <lambdabot> C has a karma of 2
10:24:06 <oerjan> @karma c
10:24:06 <lambdabot> c has a karma of 15
10:25:02 <Igel> @seen malcolmw
10:25:02 <lambdabot> I saw malcolmw leaving #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 20m 31s ago, and .
10:37:16 <crazy_coder> any tutorial, learning material for haskell. newb :) ?
10:38:05 <arcatan> what's your programming background?
10:38:33 <crazy_coder> how is that relavant ? C/ C++
10:38:44 <crazy_coder> I am student
10:38:57 <crazy_coder> Know scheme in bits and parts
10:39:20 <Excedrin> http://www.haskell.org/~pairwise/intro/intro.html
10:39:21 <lambdabot> Title: Haskell for C Programmers
10:39:33 <arcatan> here's a list: http://www.haskell.org/haskellwiki/Books_and_tutorials
10:39:34 <lambdabot> Title: Books and tutorials - HaskellWiki
10:39:36 <crazy_coder> Thanks
10:39:46 <arcatan> I recommend YAHT: http://darcs.haskell.org/yaht/yaht.pdf
10:40:32 <LoganCapaldo> @wiki MetaTutorial
10:40:32 <lambdabot> http://www.haskell.org/haskellwiki/MetaTutorial
10:41:56 <ari> crazy_coder: Your background is very important; What you have to forget in order to learn Haskell depends on what you have learned so far
10:43:08 <crazy_coder> Yeah thanks guys, I understood while I was reading the abstract
10:43:15 <crazy_coder> I really want to learn haskell
10:43:20 <crazy_coder> Heard its really cool
10:43:32 <byorgey> crazy_coder: well, you heard right =)
10:43:37 <crazy_coder> I want to implement certain things and do some projects
10:43:47 <crazy_coder> like RSS readers, IRC bots etc
10:44:27 <Excedrin> there's a simple HXT based RSS reader
10:44:35 <Excedrin> and there's an IRC bot tutorial
10:44:35 <byorgey> crazy_coder: maybe check out http://haskell.org/haskellwiki/Roll_your_own_IRC_bot
10:44:36 <lambdabot> Title: Roll your own IRC bot - HaskellWiki
10:45:08 <crazy_coder> byorgey: yeah I did. But couldn't understand the code
10:45:22 <crazy_coder> So I want to learn the syntax and stuff first
10:45:46 <byorgey> crazy_coder: right, come back to it later after you've gone through a more intro-level tutorial.
10:46:05 <crazy_coder> Thanks guys :)
11:00:04 * SamB wants to see a dependancy graph of the Haskell-related Debian packages, colored by maintainer...
11:01:09 <monochrom> libghc6-*.  They're all Ian Lynch.
11:01:33 <byorgey> did anyone get my message of Jun 8 to haskell-cafe about Template Haskell and QuickCheck?
11:01:52 <byorgey> I was subscribed in a weird way (through a Google group) so I'm not sure if it actually got sent over the list
11:01:58 <SamB> monochrom: not all
11:02:18 <monochrom> ok
11:02:28 <SamB> jgoerzen@complete.org has a few
11:03:31 <Igloo> SamB: shouldn't be hard to do, but I doubt it would be very interesting; the dependency tree is very flat I think
11:04:26 <kaol> and I and Arjan Oosting
11:04:27 <monochrom> I mispelled Ian's surname :)
11:04:34 <kaol> and rafl
11:04:57 <SamB> well, perhaps skipping any packages that neither depend on or are depended on by packages maintained by Igloo
11:43:51 <beelsebob> is there a Haskell API for filesystem interaction?
11:44:01 <shapr> Like ndm's FilePath, or what?
11:44:05 <beelsebob> plausable
11:44:08 <beelsebob> where's that
11:44:11 <shapr> @where filepath
11:44:11 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
11:44:52 <beelsebob> hmm, doesn't look like it
11:45:00 <beelsebob> mostly I want to be able to easily copy files about the place
11:45:12 <beelsebob> this may be a job for bash scripting
11:45:16 <beelsebob> :*(
11:45:27 <shapr> What exactly do you want to do?
11:45:40 <beelsebob> I have two directories
11:45:52 <beelsebob> both (after a series of fuckups) contain part of my music collection
11:46:07 <beelsebob> I want to guarentee having all the files in one directory
11:46:19 <beelsebob> hmm
11:46:20 <beelsebob> thought
11:46:22 <beelsebob> tar one
11:46:28 <beelsebob> untar over the top of another
11:47:24 <shapr> What about rsync?
11:48:04 <beelsebob> I don't trust that unless I've already been using it on the directories
11:48:37 <shapr> what about cp -i ?
11:50:20 <beelsebob> :/
11:50:25 <beelsebob> not sure I trust that
11:50:57 <shapr> Are all the files complete if they exist?
11:51:09 <beelsebob> yeh
11:51:10 <beelsebob> should work
11:51:17 <beelsebob> I think that may create some duplicates
11:51:19 <beelsebob> but not many
11:51:30 <beelsebob> it'll create duplicates wherever I now have a non-DRMed file
11:52:03 <shapr> Whoa, you purchase DRM'd files?
11:52:35 <beelsebob> I have done in the past if the rules have not been too inocuous
11:52:41 <olsner> I should DRM my mp3 collection so that no-one can steal it!
11:52:47 <beelsebob> rofl
11:52:59 <olsner> I've invested massive amounts of bandwidth in it ;-)
11:53:14 <beelsebob> so?
11:53:26 <beelsebob> surely that means you want it as free as possible
11:53:55 <beelsebob> surely you want the most you can get out of these items you've invested massive bandwidth in
11:54:29 <olsner> but what would it give me to share with other people?
11:54:44 <shapr> I get CC-licensed music from jamendo over bittorrent, and then I can contribute by uploading more when I have the albums downloaded.
11:55:07 <beelsebob> it wouldn't... what would it give you to DRM your files?
11:55:43 <arcatan> I have purchased two DRM'd files... which I instantly converted to drm-free form
11:56:12 <claint> join #lisp
11:56:13 <olsner> just schadefreude, I guess (is there an actual english word for that besides the german loanword?)
11:56:13 <emu> hmm i would have a haskell deb package in but NEW packages are taking forever to process
11:56:29 <beelsebob> olsner: what dos that mean?
11:56:30 <kaol> emu: which one?
11:56:48 <shapr> olsner: I thought schadefreude was the correct english word.
11:56:50 <emu> haskell-stp
11:56:57 <beelsebob> olsner: the only thing DRM does is restrict *you* from doing things you want to do... like putting your files on players that don't support that particular DRM
11:56:59 <olsner> but perhaps un-DRM:ing is easier than I imagined.. haven't really come upon any DRM files yet
11:57:01 <kaol> need a sponsor?
11:57:16 <olsner> beelsebob: I was thinking DRM:ing, then sharing, all the files
11:57:19 <emu> my package is in the NEW queue
11:57:24 <kaol> oh. never mind then.
11:57:33 <olsner> so that loads of people end up with needlessly DRM:ed music
11:57:33 <emu> is James having trouble keeping up?
11:58:04 <kaol> I could go and tell Ganneff to accept it. He's around here somewhere.
11:58:13 <emu> i want to reupload anyhow
11:58:26 <beelsebob> olsner: but that's just as illegal as sharing un-DRMed stuff
11:58:26 <kaol> I'd need to buy him a milk if I wanted to ask favours from him.
11:58:32 <beelsebob> and has none of the benefits
11:58:33 <emu> no need, there's no hurry
11:58:44 <shapr> olsner: I rented three movie DVDs on Saturday and could play only one of them because two were defective (er, 'copy protected'). I went back to movie gallery and complained on Sunday, and got three free rentals. Although I carefully selected DVDs that did not have the "This DVD is defective" logo, I still could only play one of the replacement movies. So I took 'em back and gave up on renting movies.
11:58:45 <emu> i'm just puzzled
11:58:46 <beelsebob> if you don't want other people to have your music, just don't give it to them
11:59:03 <olsner> (hence the schadefreude in having other people saying "Argh!! 'Twas DRM:ed :((" after they download it)
11:59:31 <beelsebob> shapr: strangely, those DVDs encourage me to pirate them... I can't play them in my player of choice, so I rip them, and play them later
12:01:01 <shapr> I figure I can just wait for five or six years until the Defective Restrictions Management dinosaurs all die off, and then I can buy inexpensive easily read movies.
12:01:36 <beelsebob> fair enough
12:04:50 <edwardk> shae: good luck, what will happen is the next generation of 'its mine and you can't have it' technologies will be making the rounds.
12:05:56 <edwardk> shae: i now watch movies in the theatre if its a movie I want to see, or I don't bother at all.
12:06:09 <dylan> if a movie is unable to play on my prefered player (a PS2), I rip it, and return it as "damaged"
12:06:21 <shapr> edwardk: In which case, I just won't even try to get it. I'll stick with jamendo.com and magnatune.com.
12:07:59 <shapr> If I put enough money into jamendo and magnatune, some smart person will discover that they can also sell movies that way, and then I'll give them money too. Someday, some movies worth watching will be available without DRM.
12:09:18 <shapr> Anyway, this is off-topic, how can I segue into a Haskell topic from this?
12:09:21 <shapr> oh HEY!
12:09:45 <shapr> musasabi wrote an implementation of DeCSS in Haskell, and got DeCSS successfully challenged in the Finnish courts!
12:09:58 <dylan> let's see... movies -> anime -> fantasy -> any haskellers planning on going to Dragoncon in September?
12:10:44 <shapr> http://arstechnica.com/news.ars/post/20070525-finland-court-breaking-ineffective-copy-protection-is-permissible.html is very cool.
12:10:46 <lambdabot> http://tinyurl.com/2fkwdg
12:11:19 <shapr> They had to turn themselves in and force the police to pay attention to them though :-)
12:11:24 <dylan> shapr: excellent. so if it is proven to finnish courts that all copy protection is ineffective...?
12:11:53 <sieni> dylan: no, just decss and it was the lowest court level and the prosecution appealed
12:12:04 <opqdonut> errr, breaking ineffective protection is allowed _in the law_
12:12:18 <opqdonut> those guys wanted to test wether css and a bunch of other stuff is inefective
12:12:20 <opqdonut> iirc
12:12:31 <shapr> sieni: Any idea where the DeCSS source is?
12:12:34 <arcatan> but CSS was ruled ineffective as it's widely available
12:12:36 <emu> sure, and the best guys to ask are a bunch of finnish legal stiffs?
12:12:47 <opqdonut> "In a ruling issued today, the court found that CSS is "ineffective" as a form of DRM and that the two defendants cited for violating Finnish copyright law were not guilty."
12:12:50 <opqdonut> yeah exactly
12:13:00 <opqdonut> emu: well, they're the ones interpreting the law
12:13:12 <emu> the law still believes the internet is a series of tubes
12:13:14 <opqdonut> there had to be a precedent on whether decss is legal or not
12:13:46 <sieni> the case is going to the appelate court next anyway and possibly to the supreme court
12:14:25 <opqdonut> yeh, not clear yet
12:14:26 <edwardk> nice
12:15:37 <emu> that's wonderful for finland, but the jackbooted thugs here don't care
12:16:07 <sieni> and anyway the ruling was not quite what the defendants wanted to get the court to address
12:18:12 <arcatan> shapr: http://liw.iki.fi/lists/organisoitukeskustelu@liw.iki.fi/msg00090.html
12:18:13 <shapr> It's a little bit funny that the RIAA and MPAA get DRM, but big business is so scared of the GPL.
12:18:14 <lambdabot> Title: Haskell DeCSS, http://tinyurl.com/yosxd8
12:18:25 <shapr> arcatan: kiitos
12:23:36 <hpaste>  rey_ pasted "haddock breakage" at http://hpaste.org/332
12:25:16 <dukedave> Haha so earlier today I took out "Type Theory & F.P." by Simon Thompson... Ever since I got back I've had an awful headache; and I haven't even opened it yet! A sign? :)
12:26:42 * shapr grins
12:43:08 <fbuilesv> Hello, are the modules HList and haskell-bin included in GHC by default?
12:44:24 <monochrom_> No. Not even in "extralibs". Do get them from hackage or project home page.
12:45:08 <dolio> Huh, the only collection type in Haskell is lists? Who knew?
12:46:03 <sjanssen> dolio: :/
12:46:09 <sjanssen> I think that guy needs to get a blog
12:46:42 <dolio> I was going to send a list of all the data structures in the hierarchical libraries, but that might be too mean.
12:47:27 <dolio> I'll just wait for someone else to be less curt.
12:47:45 <fbuilesv> Then, is anyone here involved somehow with the HAppS development? Might want to include those dependencies to the tutorial :D
12:50:49 <Saizan> reddit?
12:51:03 <dolio> haskell-cafe
12:51:07 <ari> Saizan: haskell-cafe, Andrew Coppin's post "Collections"
12:51:08 <allbery_b> dolio: the correct answer is "lists are built in and convenient and quick for prototyping, but for real applications there are ..."
12:51:28 <allbery_b> which is the reply I almost sent but decided against
12:52:47 <sjanssen> I wish it was on reddit
12:53:03 <sjanssen> lack of interest/votes would keep it from the main page
12:53:11 <sjanssen> I have no such filtering for my mail client
12:53:50 <dolio> Yeah, but instead you have to put up with an article blasting the US for not using the metric system being #1 by thousands of votes.
12:53:58 <allbery_b> heh
12:54:04 <sjanssen> :)
12:54:18 <dolio> For which I have trouble figuring out the connection to "programming."
12:54:49 <Nafai> shapr: So what does the text in your blog post say?  :)
12:55:18 <allbery_b> one connection that occurs to me is NASA's feet/meters confusion
12:56:02 <dolio> Clearly they should have been using static typing.
12:56:26 <allbery_b> along with that units-based typesystem?
12:56:40 <bringert> fbuilesv: talk to shapr or Lemmih
12:56:43 <dolio> Something like that.
12:57:02 <allbery_b> dimensional or whatever it was
12:58:28 <fbuilesv> bringert: Nvm, I was looking at another tutorial, the new one is on the wiki so it can be easily modified.
12:58:48 <Saizan> fbuilesv: the darcs version of happs doesn't have those dependencies, fyi
12:59:17 * LoganCapaldo looked up the Collections post
12:59:17 <fbuilesv> Saizan: Great, I won't modify the wiki then.
12:59:29 <LoganCapaldo> I'm confused
12:59:53 <LoganCapaldo> Data.Map isn't a collection? *Arrays aren't a collection?
13:00:12 * allbery_b thinks he's responding to the fact that lists often seem to be the first recourse
13:00:25 <allbery_b> which, as I said, is often true because they're convenient
13:00:35 <Saizan> fbuilesv: mmh, the current dependecies doesn't match the one listed on the wiki anyway :D
13:00:41 <Saizan> *don't
13:01:14 <fbuilesv> Saizan: Are they in the README or something? Wouldnt hurt to have a reference to them on the Wiki.
13:01:28 <dolio> Occasionally you even get speedups using lists over other data structures. :)
13:01:31 <allbery_b> so, when you see an example of some programming idea, it's often implemented in the examples on or with lists
13:01:33 <Saizan> lists are built-in as loops are built-in in imperative languages
13:01:35 <shapr> Nafai: Heck if I know. I can only read bits and pieces of it.
13:01:36 <allbery_b> instead of maps or sets or arrays, etc.
13:01:56 <dolio> Like the huge speedup on the spell checker switching from Set to arrays.
13:02:02 <Saizan> don't forget that we use data structures as control flow most of the time :)
13:02:08 <dolio> Due to deforestation and better cache performance, I imagine.
13:02:15 <Nafai> shapr: I'm guessing it includes a Haskell implementation of DeCSS?
13:02:36 <Saizan> fbuilesv: well, they are listed in the .cabal file
13:02:44 <monochrom_> I took the flame bait.  I replied to the Collections post.
13:02:56 <fbuilesv> Saizan: That makes too much sense :P  Gonna look into that and update the Wiki then.
13:03:31 <shapr> Nafai: Oh, it does that :-)
13:05:00 <Saizan> fbuilesv: you may want to leave a link to hackage, since it's where a package is supposed to be found, currently
13:05:19 <fbuilesv> Saizan: Yes, thats the idea.
13:06:23 <Dixi> hola!
13:06:39 <chrismbrown> in Haskell does putting a ~ in front of a pattern mean something specific? i.e. ~p ?
13:06:49 <Dixi> alguien me puede ayudar con QuickCheck y Arbitrary ?
13:07:09 <Heffalump> chrismbrown: it causes a lazy pattern match
13:07:11 <monochrom_> > case undefined of (_,_) -> "hello"
13:07:13 <lambdabot>  Undefined
13:07:15 <monochrom_> > case undefined of ~(_,_) -> "hello"
13:07:17 <LoganCapaldo> chrismbrown: it' an irrefutable (lazy) pattern
13:07:17 <lambdabot>  "hello"
13:07:28 <Dixi> Hi! I need help with QuickCheck and Arbitrary, help !
13:07:30 <Dixi> ;)
13:07:41 <chrismbrown> LoganCapaldo: but I thought all parameters are lazy by default anyway?
13:07:53 <LoganCapaldo> they are
13:07:56 <monochrom_> The matching is always declared to succeed, but the actual evaluation and extraction is postponed.
13:08:05 <LoganCapaldo> but to match a pattern you have to peek at the value
13:08:15 <LoganCapaldo> ~ delays the peeking
13:08:17 <Saizan> Dixi: any particular issue?
13:08:18 <chrismbrown> oh I see
13:08:19 <monochrom_> Pattern matching without ~ is the major way of causing evaluation to happen.
13:08:20 <chrismbrown> ah!
13:08:22 <slava> dons: i just saw yi posted on reddit. i didn't realize you were working on this. looks cool!
13:08:34 <chrismbrown> cool, you learn something new everyday
13:08:36 <chrismbrown> :)
13:08:43 <Dixi> yes
13:08:54 <chrismbrown> was wondering was this "HsPIrrPat p" was in Programatica's AST
13:08:55 <monochrom_> Do not think that "lazy" is binary.
13:09:09 <Dixi> I want to do a function for insertOrder for my TreeBin
13:09:39 <Dixi> and I want to know if is correct
13:09:47 <monochrom_> > case undefined : undefined of _:_ -> "hello"
13:09:48 <lambdabot>  "hello"
13:10:18 <olsner> > undefined
13:10:18 <Saizan> Dixi: ok, so you want to make your TreeBin an instance of Arbitrary?
13:10:19 <lambdabot>  Undefined
13:10:23 <monochrom_> In that way, the head and the tail of that list is lazily demanded, but the cons cell is eagerly demanded.
13:10:30 <Dixi> yes
13:10:51 <olsner> is Undefined a constructor for the value of undefined?
13:10:55 <dylan> Dixi: there exists a #haskell.es, btw.
13:11:03 <Dixi> and how I can use
13:11:11 <monochrom_> No. It is an error message from lambdabot.
13:11:22 <Dixi> dylan: thanks but nobady there
13:11:30 <Dixi> nobody :)
13:11:33 <dylan> Dixi: I am there. ;)
13:11:34 <chrismbrown> monochrom_: yes, but in that case the _ throws away the value. The catch all doesn't need to peek at the undefined...
13:11:38 <Dixi> ohhh
13:11:51 <Saizan> Dixi: have you read this? http://www.cs.chalmers.se/~rjmh/QuickCheck/manual.html
13:11:52 <monochrom_> Right. I'm showing that "lazy" is not just true or false.
13:12:02 <chrismbrown> monochrom_: well, I'm sure it's not!
13:12:10 <chrismbrown> :)
13:12:25 <Saizan> Dixi: there's an example of a generator for a binary tree in the Generating Recursive Data Types section
13:12:26 <monochrom_> It's easy to be eager up to a certain extent, then lazy beyond.
13:12:40 <dolio> chrismbrown: If you think about it, pattern matching with 'case ...' and on the left side of a function can cause branching, so it can't be lazy and know which branch to take.
13:12:46 <sjanssen> olsner: there's no constructor for undefined/_|_
13:13:08 <monochrom_> ~ makes things as lazy as possible.
13:13:20 <LoganCapaldo> All values are lazy. Some values are just more lazy than others. (with apologies to Orwell)
13:13:22 <dolio> But ~ says 'this pattern will always match' so it can then decide to not look at it.
13:13:38 <olsner> okay, so when given "undefined", lambdabot prints the text "Undefined", and that' s why I got the answer I got?
13:13:40 <chrismbrown> dolio: I think it all depends on the context of the pattern match, sure.
13:13:50 <monochrom_> Yes olsner
13:13:56 <dmhouse> See http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_pattern_matching regarding ~-patterns
13:13:59 <lambdabot> http://tinyurl.com/ykch9p
13:14:01 <Dixi> yes , i read it , but I dont know how i can use, how i can prove quickcheck ....'??
13:14:10 <dmhouse> Actually, that whole module should be pretty useful if you want to read about laziness/nonstrictness.
13:14:19 <olsner> > undefined + 1
13:14:20 <lambdabot>  Undefined
13:14:23 <monochrom_> the wikibook is good.
13:14:37 <dolio> chrismbrown: Yeah. 'let (_:_) = undefined in ...' works, because pattern matching in a let is lazy. There's no potential for branching there.
13:15:16 <chrismbrown> dolio: yes, in that case the undefined is being thrown away, so never needs to be evaluated
13:15:34 <chrismbrown> dmhouse: thanks for that link
13:15:55 <dmhouse> chrismbrown: drop any feedback to wikibook@haskell.org, or directly to me (I wrote most of that module).
13:15:59 <Saizan> Dixi: you write a property, with is essentialy a function that takes something in the class Arbitrary and returns a Bool, and pass it to the function quickCheck that performs the test
13:16:17 <chrismbrown> dmhouse: sure, thanks. It's quite interesting
13:16:39 <allbery_b> oh, the other cmment I'd make about lists and haskell is that in many ways haskell is a lisp derivative, so lists are *the* fundamental data type
13:16:46 <allbery_b> (or collection type at least)
13:17:02 <Dixi> Saizan: in that paper exist a function
13:17:19 <Dixi> for arbitrary
13:17:36 <Dixi> arbitrary =sized .....
13:17:46 <Dixi> how i can prove it?
13:17:51 <chrismbrown> > let _ = undefined in 42
13:17:53 <lambdabot>  42
13:17:59 <chrismbrown> let f = undefined in 42
13:18:03 <slava> allbery_b: closures are more 'fundamental' because you can make lists from closures but not vice versa
13:18:08 <Saizan> Dixi: prove?
13:18:11 <chrismbrown> > let f = undefined in 42
13:18:13 <lambdabot>  42
13:18:21 <olsner> somewhat confusing at first, this _|_/bottom/undefined business.. there was a long while I thought "whut!? how can they use _|_ in these examples even though ghc gives a syntax error for it in my code!?" or "what package do I import to get this bottom value they refer to?"
13:19:00 <Dixi> Saizan: yes
13:19:01 <monochrom_> _|_ is math. But you can use (error "whatever") or undefined or write your own infinite loop or ... in code.
13:19:21 <allbery_b> slava: somehow I think you missed the forest for the trees...
13:19:23 <Dixi> quickcheck arbitrary ?
13:19:52 <Saizan> Dixi: no, do you know how to use typeclasses?
13:20:00 <dmhouse> olsner: the terminology often gets mixed. When we talk about code, we should always say 'undefined'.
13:20:07 <LoganCapaldo> slava: you can't make a closure froma  list? [code, environment] :)
13:20:12 <fbuilesv> Any idea of how to fix: "Setup.hs: HAppS.cabal:55: 'Executable' stanza starting with field 'other-modules'" ?
13:20:15 <Dixi> Saizan: more or less
13:20:20 <Dixi> :(
13:20:20 <slava> LoganCapaldo: but now you need a data type for code and environment
13:20:39 <LoganCapaldo> Well if this is lisp the datatype for both is a list :)
13:20:46 * olsner has achieved understanding of the bottom
13:20:47 <slava> that's not true
13:20:58 <slava> only in a pathological lisp
13:21:13 <monochrom_> You should get to the bottom of it. :)
13:21:18 <LoganCapaldo> using closures to build linked lists is pathological too :)
13:21:20 <sjanssen> *obviously* the only data structures Haskell needs are (), Either, and (,)
13:21:38 <sjanssen> or just (->) if you want to get really hardcore :)
13:21:41 <olsner> @yow
13:21:41 <LoganCapaldo> I demand equal levels of pathology!
13:21:41 <lambdabot> I invented skydiving in 1989!
13:22:14 <olsner> LoganCapaldo: at first I though your line was the @yow line :P
13:22:25 <monochrom_> (->) is good enough for me.
13:22:28 <slava> LoganCapaldo: even using lists as the fundamental sequence type is pretty pathological, IMO :)
13:24:09 <Saizan> Dixi: to test your property you want to generate random TreeBin, right? to do this you have to write something like instance Arbitrary TreeBin where arbitrary = <some code here>
13:24:19 <shapr> @yow !
13:24:19 <lambdabot> Bo Derek ruined my life!
13:25:00 <Saizan> Dixi: that makes TreeBin an instance of the class Arbitrary, by providing the class method arbitrary :: Gen TreeBin
13:25:05 <olsner> (->) would give you some kind of lambda calculus, right? but don't you need some other basic type as leafs? like (->) and ()?
13:25:46 <olsner> (->) takes two arguments, so a tree built only from (->) nodes never ends, right?
13:25:49 <Saizan> Dixi: then you can write a property like prop_tree :: TreeBin -> Bool, and "run" it with quickChek prop_tree
13:25:50 <Dixi> Saizan: yes , i understand that
13:26:02 <sjanssen> olsner: you can Church encode both sum and product types -- should be enough, I think
13:26:05 <Saizan> ?hoogle quickCheck
13:26:09 <lambdabot> Test.QuickCheck.quickCheck :: Testable a => a -> IO ()
13:26:09 <lambdabot> Test.QuickCheck :: module
13:27:02 <LoganCapaldo> all you need is lambda
13:27:07 <LoganCapaldo> lambda's all you need
13:27:14 <Saizan> Dixi: how to implement the method arbitrary depends on your data structure, but the manual has some examples
13:27:27 <dolio> Leaf is something like: \f z -> z
13:27:30 <slava> LoganCapaldo: you can get by with S and K and no lambda, but the beatles didn't write a song about it
13:27:30 <LoganCapaldo> (well and those reduction / expansion operation thingies)
13:27:40 <LoganCapaldo> slava: for sure
13:27:41 <olsner> slava: or X
13:27:42 <dolio> Branch is something like \a b f z -> f a b
13:27:58 <byorgey> @remember LoganCapaldo all you need is lambda / lambda's all you need
13:27:58 <lambdabot> Done.
13:28:02 <dolio> Or something like that.
13:28:46 <Dixi> Saizan:
13:29:00 <hpaste>  Marc Weber pasted "Constructor / qualified ? How to tell ghc that I want to use  module.func and not constructor.<..> ?" at http://hpaste.org/333
13:29:06 <dolio> Maybe \a b f z -> f (a z) (b z)
13:29:11 <olsner> sjanssen: you lost me somewhere after 'can' :/
13:29:26 <sjanssen> :)
13:29:35 <dolio> Or with some f's in there as well.
13:29:44 <Dixi> Saizan: thanks , my data structure is the same  of the manual
13:30:06 <Dixi> i want to do one function for insert elements
13:30:12 <sjanssen> olsner: you can encode products (like tuples) as functions -- (a, b) is the same as ((a -> b -> c) -> c)
13:30:13 <monochrom_> http://www.haskell.org/pipermail/haskell-cafe/2007-March/023372.html  has the complete thread on how to use -> to implement data types
13:30:15 <lambdabot> Title: [Haskell-cafe] Church Encoding Function, http://tinyurl.com/2ygkw3
13:30:50 <LoganCapaldo> I also wrote about this on my blahg, but I used the wrong programming language
13:30:59 <Dixi> Saizan: ordered and prove it with
13:31:12 <Dixi> quickcheck
13:31:22 <sjanssen> olsner: you can encode (Either a b) as ((a -> c) -> (b -> c) -> c)
13:31:47 <LoganCapaldo> olsner: if you can suffer thru ruby examples http://meta-meta.blogspot.com/2007/06/church-code.html
13:31:49 <lambdabot> Title: Meta-Meta: The Church Code
13:32:32 <sjanssen> olsner: note that these signatures are quite similar to 'uncurry' and 'either' -- they're both catamorphisms!
13:33:26 <dolio> @type curry
13:33:31 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:33:35 <Saizan> Dixi: just write a function that takes a tree and a list of elements, insert them in the tree and then checks if it's ordered
13:33:44 <emu> oh no, the catamorphism is out of the bag!
13:33:53 <olsner> sjanssen: mmkay, but what happens to ()? If everything is of type a -> b, everything should have the type (a -> b) == (c -> d) -> (e -> f) == ((g -> h) -> d) -> (e -> f) etc etc, right?
13:34:02 <sjanssen> @remember emu oh no, the catamorphism is out of the bag!
13:34:03 <lambdabot> Done.
13:34:07 * shapr snickers
13:34:32 <monochrom_> haha
13:34:38 <sjanssen> olsner: () is equivalent to (a -> a)
13:34:55 <olsner> mmkay
13:35:13 <sjanssen> olsner: to do recursive structures, you need recursive types of some sort
13:35:21 <sjanssen> we can do this with newtype
13:36:09 <Dixi> Saizan: thanks :)
13:38:38 <olsner> recursive I grok, but I just can't see where this recursion ends
13:38:49 <bringert> is www.haskell.org for anyone else?
13:39:27 <shapr> I think haskell.org just got reddit-dotted.
13:39:29 <shachaf> bringert: It's for everyone. :-)
13:39:39 <bringert> dammit
13:39:46 <bringert> I'm trying to edit a wiki page
13:39:59 <shachaf> bringert: But it doesn't seem to pong for me at the moment.
13:40:17 <dolio> olsner: Because in recursive data structures, you pass a continuation for the branch case and the nil case, and the nil nodes use the latter.
13:40:19 <Igloo> Its load is 134
13:40:42 <sjanssen> olsner: well, you'll need some sort of concrete representation to finally do something useful (like print it to the screen, etc.)
13:40:44 <dmhouse> That's quite a lot.
13:40:54 <dolio> So to speak.
13:41:33 <sjanssen> olsner: otherwise they're represented as polymorphic functions
13:42:35 <shapr> Igloo: Aha, reddit-dotted!
13:42:38 <joelr1> good evening
13:42:45 <joelr1> has anyone written a wiki in haskell?
13:43:12 <matthew-_> joelr1: yep
13:43:22 <dmhouse> Nothing serious, I don't think, but shapr made one with HAppS, IIRC.
13:43:31 <sjanssen> @where flippy
13:43:32 <lambdabot> I know nothing about flippy.
13:43:37 <sjanssen> is that what it's called?
13:44:02 <matthew-_> joelr1: http://hikij.wellquite.org/
13:44:04 <lambdabot> Title: Hikij
13:44:10 <joelr1> matthew-_: looking...
13:44:18 <bos> http://www.scannedinavian.com/hope/entry/104
13:44:30 <matthew-_> joelr1: it's not quite a "normal" wiki though...
13:44:34 <olsner> mmkay, but then (->) isn't *really* the only type, only almost?
13:44:35 <Igloo> shapr: Do you know that for sure?
13:44:59 <sjanssen> olsner: it's the only type for theoretical purposes
13:45:07 <byorgey> > [2,4..9]
13:45:15 <lambdabot>  [2,4,6,8]
13:45:23 <dmhouse> Igloo: a link to Yi's wiki page is on the front of programming.reddit.com.
13:45:26 <byorgey> > [2,4..9.0]
13:45:26 <sjanssen> of course the physical computer has something concrete -- gotta represent it as bits and bytes somehow
13:45:27 <lambdabot>  [2.0,4.0,6.0,8.0,10.0]
13:45:34 <byorgey> *grumble*
13:45:43 <emu> > [2.7182,3.14159,..]
13:45:43 <lambdabot>  Parse error
13:45:51 <Igloo> dmhouse: But do you know that that is the cause?
13:45:51 <joelr1> matthew-_, bos: thanks
13:45:54 <emu> > [2.7182,3.14159 ..]
13:45:55 <dmhouse> Igloo: no.
13:45:55 <lambdabot>  [2.7182,3.14159,3.56498,3.9883699999999997,4.411759999999999,4.8351499999999...
13:46:08 <sjanssen> is that really enough to push load up to 134?
13:46:29 * sjanssen suspects it is the dreaded naughty bot DoS issue
13:46:37 <oerjan> > [exp(1), pi ..]
13:46:39 <lambdabot>  [2.718281828459045,3.141592653589793,3.564903478720541,3.988214303851289,4.4...
13:46:43 <emu> > 2.71828**(3.141592 * (0 :+: 1))
13:46:44 <lambdabot>   Not in scope: data constructor `:+:'
13:47:06 <emu> @info Complex
13:47:06 <lambdabot> Complex
13:47:13 <emu> @hoogle Complex
13:47:14 <lambdabot> Complex :: module
13:47:14 <lambdabot> Data.Complex :: module
13:47:14 <lambdabot> Data.Complex.Complex :: data Complex a
13:47:16 <mehrheit> > exp pi - pi
13:47:17 <lambdabot>  19.999099979189474
13:47:56 <emu> > 2.71828**(3.141592 * (0 :+ 1))
13:47:57 <lambdabot>  (-0.9999999999961724) :+ 2.7667901904084004e-6
13:48:03 <olsner> ah, yes, the primitive that enables something to be done would be part of the interpreter for the program constructed solely through nested lambdas, but the nested lambdas still form a complete description of the program.. I think I was trying to think about it all on a level of abstraction above lambda calculus while all we were talking about was actually lambda calculus
13:48:03 <dmhouse> > exp (sqrt (-1) * pi)
13:48:04 <lambdabot>  NaN
13:48:09 <emu> > exp(1)**(pi * (0 :+ 1))
13:48:10 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:48:30 <oerjan> > exp(0 :+ pi)
13:48:32 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:48:35 <|Steve|> What is :+?
13:48:37 <LoganCapaldo> > let exp pi = 20 ; pi = 0 in exp pi - pi
13:48:39 <lambdabot>  20
13:48:47 <dolio> Complex constructor.
13:48:53 <LoganCapaldo> |steve| constructor for complex numbers
13:48:58 <|Steve|> Ah, okay.
13:49:04 <dmhouse> |Steve|: data Complex = a :+ b (which means a + bi).
13:49:21 <dmhouse> Err, that was completely wrong.
13:49:30 <dmhouse> data Complex a = a :+ a
13:49:33 <emu> > let i = 0 :+ 1; e = exp in e(i*pi) + 1
13:49:35 <lambdabot>  0.0 :+ 1.2246063538223773e-16
13:49:57 <oerjan> @src Complex
13:49:58 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
13:50:05 <LoganCapaldo> data Complex where (:+) :: (Num a) => a -> a -> Complex a
13:50:14 <|Steve|> I had no idea that Haskell had support for complex numbers.
13:50:16 <LoganCapaldo> oh RealFloat is it?
13:50:33 <LoganCapaldo> > (2%1) :+ (3%2)
13:50:34 <lambdabot>   add an instance declaration for (RealFloat (Ratio t))
13:50:37 <LoganCapaldo> booo
13:50:40 <LoganCapaldo> boooo
13:50:46 <LoganCapaldo> ok I'm done now
13:50:54 <oerjan> i was slightly annoyed by the fact it cannot be used for Gaussian integers
13:51:28 <oerjan> the abs function forces a to be RealFloat
13:51:44 <|Steve|> Seems like that could be implemented easily enough as a pair.
13:51:47 <dolio> @type abs
13:51:49 <lambdabot> forall a. (Num a) => a -> a
13:52:11 <oerjan> @src Complex abs
13:52:11 <lambdabot> Source not found. Take a stress pill and think things over.
13:52:17 <dolio> I guess it does sqrt?
13:52:19 <oerjan> @src (Complex a) abs
13:52:19 <lambdabot> Source not found. Where did you learn to type?
13:52:24 <oerjan> bah
13:52:29 <olsner> time to sleep :(
13:52:31 <oerjan> right
13:52:35 <dolio> Yeah.
13:53:00 <dolio> Bummer.
13:53:19 <LoganCapaldo> @source Data.Complex
13:53:20 <lambdabot> http://darcs.haskell.org/packages/base/Data/Complex.hs
13:54:46 <oerjan> @src Data.Complex.Complex abs
13:54:47 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:55:02 <oerjan> @src String show
13:55:03 <lambdabot> Source not found. That's something I cannot allow to happen.
13:55:09 <oerjan> @src Char show
13:55:09 <lambdabot> Source not found. You type like i drive.
13:55:14 <oerjan> whoops
13:55:24 <LoganCapaldo> so abs uses magnitude which uses sqrt
13:55:26 <oerjan> @src Char showsPrec
13:55:26 <lambdabot> Source not found. Take a stress pill and think things over.
13:55:35 <LoganCapaldo> just in case anyone cared
13:55:43 <LoganCapaldo> about the reasoning
13:55:51 <LoganCapaldo> @type sqrt
13:55:54 <lambdabot> forall a. (Floating a) => a -> a
13:57:11 <oerjan> @src Complex (+)
13:57:11 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
13:57:28 <oerjan> @src [] >>=
13:57:28 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:57:33 <oerjan> @src [] (>>=)
13:57:34 <lambdabot> m >>= k     = foldr ((++) . k) [] m
13:57:43 <oerjan> finally one that worked
13:58:18 <iakovz_> hi
13:58:19 <oerjan> @src Complex a abs
13:58:19 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
13:58:30 <emu> functional rockets
13:58:43 <dolio> @instances Num
13:58:44 <lambdabot> Double, Float, Int, Integer
13:58:55 <oerjan> is there no way to get @src to give an instance method for an instance with variables in it?
13:59:02 <mehrheit> @src (:+) abs
13:59:02 <lambdabot> Source not found. You type like i drive.
13:59:10 <dolio> You just did with [].
13:59:22 <dolio> It must not be indexing Complex for some reason.
13:59:24 <oerjan> no, [] has no variables. Complex a has.
13:59:50 <dolio> @kind []
13:59:52 <lambdabot> * -> *
13:59:57 <dolio> @kind Complex
13:59:59 <lambdabot> * -> *
14:00:12 <dolio> @src Either (>>=)
14:00:12 <lambdabot> Left  l >>= _ = Left l
14:00:12 <lambdabot> Right r >>= k = k r
14:00:14 <emu> @src StateT (>>=)
14:00:14 <lambdabot> Source not found. That's something I cannot allow to happen.
14:00:17 <oerjan> what i mean is: (Monad []) has no variable, (Num (Complex a)) has.
14:00:39 <dolio> Either has a variable.
14:00:40 <oerjan> of course that might not actually be the problem here.
14:00:52 <emu> a free variable
14:00:54 <oerjan> right.
14:01:02 <oerjan> so then that's not the issue.
14:01:04 <dolio> @src (->) (>>=)
14:01:04 <lambdabot> f >>= k = \ r -> k (f r) r
14:01:13 <slowriot> What if I want to import a specific data type from a module? How do I do that?
14:01:39 <slowriot> import module (SomeData) doesn't seem to work
14:02:21 <oerjan> i'm not sure but i think it should work
14:02:31 <oerjan> how does it not work?
14:02:45 <slowriot> import Graphics.Rendering.OpenGL.GL.CoordTrans (Position)
14:02:58 <oerjan> i mean what is the error message?
14:03:07 <slowriot> Not in scope: data constructor 'Position'
14:03:13 <ptolomy> Probably an overbroad question, but how much memory does an unevaluated thunk take up?
14:04:01 <oerjan> is it exported from the module?
14:04:05 <oerjan> oh wait
14:04:16 <oerjan> types and data constructors are separate.
14:04:37 <bringert> how longs does stuff stay on reddit? (i.e. how long until the wiki is usable again?)
14:04:43 <oerjan> do (Position(..)), i think
14:04:51 <oerjan> that includes all the constructors.
14:05:01 <slowriot> worked
14:05:03 <slowriot> oh, okay
14:05:10 <slowriot> you have to import individual constructors
14:05:11 * ptolomy wants to memoize various parsing operations that might be invoked on a data type by having a record type that encompasses all of the parsing operations, but most of them won't be used.
14:05:47 <oerjan> .. abbreviates all the constructors for a type in export/import lists
14:05:51 <ptolomy> I just wonder if keeping around what will mostly be unevaluated functions will eat up memory..
14:08:27 <oerjan> ptolomy: the thunks may only include a pointer to code, plus the local identifiers used in it
14:11:23 <kolmodin> @yarr!
14:11:24 <lambdabot> I heard andersca is a pirate
14:12:57 <clanehin> haskell-mode for emacs seems poorly documented.  How do I make ghci load from the correct directory, for module chasing?  (It really should be able to guess correctly, most of the time.)  I'm using debian.
14:13:45 <shapr> clanehin: I think it's :set pwd
14:13:55 <dmhouse> clanehin: if you use C-c C-l on a file then the modules should be imported properly.
14:15:06 <Saizan> clanehin: when the *haskell* buffer is spawned the first time it's set to the directory of the file you've loaded, then you have to switch the directory with :cd inside ghci
14:15:06 <titto> You can setup the options passed to ghci as in (setq haskell-ghci-program-args (list "-cpp" "-DGHC_LIBDIR=\"/usr/lib/ghc-6.6.1\"" "-i/...path..")
14:16:35 <slowriot> you can set them in customize too
14:16:43 <clanehin> I see.  Thanks.
14:18:08 * slowriot sighs at haskell.org
14:20:17 <titto> Is there an "Haskell Query Language"? I am writing a Web app and I want to be able to query my application state remotely. The app state is  just an ordinary haskell term:  (say: data State = [User]   data User = User {userID::String,userPwd}. I would like to be able to query this in a generic way, for example to return the userIDs of all users. When I worked in Java, I had written a little object oriented query language to do the job (
14:20:17 <titto> hing similar is available in Haskell.
14:20:39 <Vq^> is Haskell.org down?
14:20:49 <slowriot> seems to be
14:21:58 <byorgey> Vq^: apparently it was linked to from the front page of reddit?
14:22:26 <sjanssen> titto: something from SYB might work for you?
14:22:40 <sjanssen> (NB: SYB is fairly complicated)
14:24:49 <titto> SYB makes it simpler to traverse a data structure, that would help to keep the query simple but how do I convert a query specified as a String to a haskell query ? Obviously I could just write the query in haskell and compile it dynamically with hs-plugins but I am bit worried that this might open security holes.
14:26:59 <bringert> titto: you could write an interpreter, but since SYB is type-driven, I think it would be hard to use that
14:27:22 <titto> ideally I would like a query language that is powerful enough to formulate most useful queries but not enough to allow malicious users to write non-terminating programs or other gremlins.
14:28:20 <titto> Maybe I could use TH to synthetise a parser directly from the definition of my data structure?
14:29:12 <bringert> stupid reddit. can't we vote that story off the front page or something?
14:29:44 <sjanssen> titto: sounds plausible
14:30:00 <sjanssen> I doubt that reddit can bring haskell.org down
14:30:16 <Heffalump> what are we voting down?
14:30:33 <shapr> ALL FANATICS MUST DIE!
14:30:40 <Heffalump> bringert: btw, have you seen this? Might be interesting for haskelldb: http://research.microsoft.com/~simonpj/papers/list-comp/index.htm
14:30:42 <lambdabot> Title: Comprehensive Comprehensions
14:31:10 <bringert> Heffalump: the Yi story on http://programming.reddit.com/
14:31:11 <lambdabot> Title: reddit.com: programming - what&#39;s new online
14:31:23 <bringert> Heffalump: it's taken down www.haskell.org
14:31:29 * dmhouse polishes off inferior-haskell-find-haddock for haskell-mode
14:31:35 <Heffalump> is reddit that popular
14:31:36 <Heffalump> ?
14:31:54 <bringert> apparentely
14:32:11 <bringert> hmm, that's spelled differently isn't it?
14:32:18 <Heffalump> apparently
14:32:31 <bringert> Heffalump: yeah, that looks like a nice idea
14:32:31 <Heffalump> like "differently", in fact ;-)
14:32:40 <bringert> hehe
14:33:07 <shapr> sjanssen: haskell.org has 1gb of ram, 2gb of swap. httpd appears to be using 2gb of memory total.
14:33:25 <Heffalump> I'm currently getting annoyed by the lack of (AFAICT) way to augmment an existing query with a single extra field without relisting all the first queries fields.
14:33:29 <shapr> sjanssen: 17:26:54  up 187 days,  1:15,  3 users,  load average: 134.21, 133.51, 131.51
14:33:34 <bringert> Heffalump: I've been wanting to redesign HaskellDB for a long time, but haven't really found the time.
14:33:44 <jao> hmm. i'm using ghc 6.6 on OS X, installed via fink. if i setup DYLD_LIBRARY_PATH before starting ghci, libX11 is found. but if, instead, i use -L/usr/X11R6/lib (the value of DYLD_LIBRARY_PATH) it's not found (the dynamic loader complains). anyone knows why?
14:33:59 <bringert> Heffalump: I think you could get around that, but it's not very nice
14:34:16 <Igloo> Has anyone got the Yi homepage loaded in a browser that they can save-with-content?
14:34:20 <Heffalump> I developed the motivation this morning to improve the query optimisation, but my spare time on trains will be taken up with HW reviewing for a while so the urge may have passed by the time that's done.
14:34:53 <Heffalump> bringert: I could by adding stuff under the hood. Is there a way without doing that?
14:34:59 <bringert> Heffalump: you can write a function that gets the fields you want, and then use that in several places. though I haven't tried that I think
14:35:44 <Heffalump> oh, right, yes, that's what I'm doing, roughly
14:35:46 <Igloo> Ah, n/m
14:35:49 <Heffalump> not quite the same thing, though
14:36:22 <bringert> something like let f r = l1 << f!l1 # l2 << f1l2 in project (f x) ... project (f x # l3 << x!l3)
14:36:26 <dmhouse> Igloo: ah, we're back up :)
14:37:19 <Heffalump> yes, that's roughly what I'm doing.
14:37:26 <bringert> Heffalump: have you looked at coddfish?
14:37:46 <Heffalump> no, hadn't heard of it before (googled now)
14:38:09 <bringert> Heffalump: it should be possible to use that as an alternative HaskellDB front-end
14:39:08 <bringert> gotta go
14:39:48 <Heffalump> I'll take a look. bye.
14:41:03 <shapr> Igloo: I've got a copy of the Yi page with content.
14:41:12 <Igloo> OK, I've redirected the Yi page to a static copy, so hopefully that'll fix it
14:43:02 <sjanssen> I'm getting emails from haskell.org again
14:44:36 <Excedrin> Igloo: haha, did you use the hack that's also on the front page of reddit for redirecting things to static copies?
14:44:42 <sorear> hello.
14:44:47 <Heffalump> how did it end up using 2GB of RAM?
14:44:48 <Igloo> Am I blind or does the wiki not say who admins it?
14:45:06 <sorear> Igloo: it does, in a very obscure place
14:45:10 <dmhouse> Igloo: thanks :)
14:45:21 <sorear> Igloo: I forget where, but Ashley Yakely is the answer
14:45:26 <dmhouse> ?karma+ Igloo
14:45:26 <lambdabot> Igloo's karma raised to 20.
14:45:30 <Igloo> Excedrin: Dunno, I can't see a hack on the front page of reddit
14:46:26 <Excedrin> Igloo:  HOW TO: Survive digg/reddit effect with only a few lines of code   (codingview.blogspot.com)
14:46:30 <Excedrin> that one?
14:51:53 <Igloo> sorear: Thanks
14:52:05 <Igloo> Excedrin: I did Redirect /haskellwiki/Yi http://www.haskell.org/yi/Yi.html
14:52:06 <lambdabot> Title: Yi - HaskellWiki
14:53:52 * dmhouse wonders why there are no Haddocks for GHC.Base...
15:07:42 <mehrheit> how to get +# and I# into scope?
15:09:38 <sorear> import GHC.Exts
15:09:47 <sorear> {-# OPTIONS_GHC -fglasgow-exts #-}
15:11:13 <mehrheit> thank you
15:12:47 <augustss> yo
15:13:11 <sorear> yo!
15:13:14 <shapr> tjenare!
15:13:31 <ari> tere
15:13:55 <shapr> heippa hei!
15:14:06 <shapr> Since it's today's buzzword.. has anyone tried Yi?
15:14:37 <sorear> No.  Everything on -cafe@ is idle speculation. :)
15:14:48 <ddarius> @index I#
15:14:48 <lambdabot> GHC.Exts
15:15:07 <oerjan> @index +#
15:15:07 <lambdabot> bzzt
15:15:13 <oerjan> @index (+#)
15:15:13 <lambdabot> bzzt
15:15:24 <ddarius> Now that I have an internet connected linux installation, I may take a swing at building it.
15:16:10 <shapr> yay
15:16:24 <shapr> Um, where did cabal-setup go?
15:17:19 <shapr> @where cabal-setup
15:17:20 <lambdabot> I know nothing about cabal-setup.
15:17:25 <shapr> @where cabal-install
15:17:25 <lambdabot> I know nothing about cabal-install.
15:19:20 <Modius> What's the shortest/cleanest haskell to "merge" the contents of 2 lists?  Kind of zippered, only with some sorting predicate.
15:19:46 <sorear> merge, from missingh
15:19:50 <sorear> @where missingh
15:19:50 <lambdabot> http://quux.org/devel/missingh
15:20:06 <lispy> ?src isNaN
15:20:06 <lambdabot> Source not found. Take a stress pill and think things over.
15:20:18 <ddarius> @hoogle isNaN
15:20:19 <lambdabot> Prelude.isNaN :: RealFloat a => a -> Bool
15:20:29 <ddarius> ?src Double isNan
15:20:29 <lambdabot> Source not found. stty: unknown mode: doofus
15:20:38 <ddarius> lambdabot: Indeed
15:20:53 <lispy> > let myNaN x = x /= x in myNaN (1/0)
15:20:55 <lambdabot>  False
15:20:58 <lispy> > 1/0
15:20:59 <lambdabot>  Infinity
15:21:08 <lispy> > 0/0
15:21:09 <lambdabot>  NaN
15:21:13 <lispy> > let myNaN x = x /= x in myNaN (0/0)
15:21:15 <lambdabot>  True
15:21:20 <Modius> Thanks
15:21:45 <kpreid> @let merge [] ys = ys; merge xs [] = xs; merge (x:xs) (y:ys) | x < y = x : merge xs (y:ys) | otherwise = y : merge (x:xs) ys
15:21:47 <lambdabot> Defined.
15:21:53 <shapr> @hackage cabal-install
15:21:53 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-install
15:21:56 <shapr> @hackage cabal-setup
15:21:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/cabal-setup
15:21:58 <shapr> aha
15:22:09 <kpreid> > merge [1,3,5] [2,9,27]
15:22:10 <lambdabot>  [1,2,3,5,9,27]
15:22:29 <mauke> > merge [1,1,2] [1,2,2]
15:22:30 <lambdabot>  [1,1,1,2,2,2]
15:22:32 <shapr> Seems like @where should fallthrough to @hackage
15:22:52 <lispy> yeah it does
15:23:00 <lispy> i guess @hackage is just too new
15:23:01 <ddarius> shapr: Hack it or finagle some newbie to hack it.
15:24:17 * lispy is starting to grok patch theory
15:24:23 <Heffalump> yay
15:24:37 * ddarius should hack @let to make it so that you can get the source and remove individual definitions.
15:25:03 <lispy> ddarius: yes, those were both proposed when @let was created
15:25:20 <oerjan> > compare (0/0) (0/0)
15:25:21 <lambdabot>  GT
15:26:48 <mehrheit> is there a way to pass cmdline options to ghc when compiling with a standard cabal Makefile or Setup.*hs?
15:26:51 <oerjan> @let merge
15:26:52 <lambdabot>  Parse error
15:27:09 <notsmack> @type (0/0)
15:27:11 <lambdabot> forall t. (Fractional t) => t
15:27:29 <Cale> In this case it was defaulted to Double
15:27:37 <Cale> > (0/0)
15:27:39 <lambdabot>  NaN
15:28:23 <Cale> > let f x = 1/x in (0 == (-0)) && (f 0 /= f (-0))
15:28:24 <lambdabot>  True
15:29:02 <mehrheit> > 1/0
15:29:03 <lambdabot>  Infinity
15:29:08 <oerjan> heh, Hugs gives EQ, but also (0/0) /= (0/0)
15:29:09 <mehrheit> > -(1/0)
15:29:10 <lambdabot>  -Infinity
15:29:18 <dmhouse> > let f x = 1/x in (0 == (-0), f 0 /= f (-0))
15:29:19 <lambdabot>  (True,True)
15:29:47 <dmhouse> I hate the stupid Infinity, -Infinity and NaN stuff. Yes, I know it's some annoying standard. It doesn't make it right.
15:30:00 <mehrheit> > let x = (1/0) in  (-x) < x
15:30:01 <lambdabot>  True
15:30:29 <astrolabe> Is there any way to turn it off?  It makes it harder to find bugs.
15:30:29 <sorear> 15:25 < mehrheit> is there a way to pass cmdline options to ghc when compiling with a standard cabal Makefile or Setup.*hs?
15:30:38 <sorear> mehrheit: Yes.
15:30:47 <notsmack> > (NaN)::Double -- this doesn't work, right?
15:30:47 <lambdabot>   Not in scope: data constructor `NaN'
15:30:50 <sorear> mehrheit: Ghc-options: foo
15:31:10 <Cale> astrolabe: turn what off?
15:31:47 <astrolabe> Cale: I want my program to stop with an error when it would normally create an Infinity or a NaN
15:32:08 <mehrheit> thanks, sorear
15:32:08 <Cale> Er, I suppose you could newtype Double and write your own instance of Num
15:32:18 <Cale> Or just use Rational
15:32:29 <oerjan> 1 % 0
15:32:33 <oerjan> > 1 % 0
15:32:35 <lambdabot>  Exception: Ratio.%: zero denominator
15:32:50 <mehrheit> > 2 % 2
15:32:51 <lambdabot>  1%1
15:33:12 <astrolabe> > log 0
15:33:14 <lambdabot>  -Infinity
15:33:27 <astrolabe> > log (-1)
15:33:28 <lambdabot>  NaN
15:33:35 <Cale> Floating point values have been designed to give some information about divergence when things fail.
15:34:19 <astrolabe> I'd need to write lots of my own versions of functions.
15:34:34 <Cale> yep
15:34:50 <Cale> You can test for failure conditions explicitly
15:34:58 <ddarius> Type classes make it not as bad as it would be.
15:35:18 <xho> hey cale... want to see the new generation of haskell powered web chat?
15:35:21 <Cale> > isNaN (0/0)
15:35:23 <lambdabot>  True
15:35:23 <astrolabe> I suppose it only has to be done once.  Maybe there should be a library.
15:35:25 <Cale> xho: sure
15:35:30 <Cale> > isInfinite (0/0)
15:35:32 <lambdabot>  False
15:35:34 <Cale> > isInfinite (1/0)
15:35:35 <lambdabot>  True
15:35:38 <Cale> > isInfinite (-1/0)
15:35:39 <xho> Cale: http://feld.sh.nu:2000/
15:35:40 <lambdabot>  True
15:36:23 <int-e> > let a = 0; b = -a in (a==b, 1/a == 1/b)
15:36:24 <lambdabot>  (True,False)
15:37:48 <int-e> > let a = 0/0 in a == a
15:37:49 <lambdabot>  False
15:38:33 <Modius> What's the haskell function to split a list into tuples of fixed size?
15:38:46 <Igloo> There isn't one
15:38:52 <dmhouse> Modius: as in, you want to pass a number which is the tuple size?
15:39:00 <dmhouse> Modius: because that wouldn't have a constant return type.
15:39:01 <Modius> Fixed to 2 would suffice
15:39:14 <dmhouse> Then I'd use zip xs (tail $ tail xs)
15:39:21 <Modius> Aah - thanks
15:39:24 <dmhouse> ... apart from that wouldn't work :)
15:39:41 <int-e> > unfoldr (liftM2 (>>) (guard . not . null) (return . splitAt 5)) [1..11]
15:39:42 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11]]
15:40:09 <notsmack> f (x1:x2:xs) = (x1,x2):f xs; f _ = []
15:40:20 <int-e> > takeWhile (not . null) . map (take 5) . iterate (drop 5) $ [1..11]
15:40:22 <lambdabot>  [[1,2,3,4,5],[6,7,8,9,10],[11]]
15:40:28 <dmhouse> > let pairs [] = []; pairs [_] = []; pairs (x:y:xs) = (x, y) : pairs xs in pairs [1..10]
15:40:29 <lambdabot>  [(1,2),(3,4),(5,6),(7,8),(9,10)]
16:00:11 <dibblego> ?where yaht
16:00:11 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
16:00:21 <dibblego> ?where cofp
16:00:21 <lambdabot> I know nothing about cofp.
16:00:35 <dibblego> ?where craft of functional programming
16:00:35 <lambdabot> I know nothing about craft.
16:00:59 <sorear> dibblego: it's a dead tree book
16:01:20 <dibblego> yeah I thought there might be a link to its web page
16:01:28 <dibblego> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
16:01:30 <lambdabot> Title: Haskell: The Craft of Functional Programming, Second Edition
16:02:25 <oerjan> @where+ cofp http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
16:02:25 <lambdabot> Done.
16:02:41 <oerjan> @where cofp
16:02:42 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
16:08:42 * shapr cheers for good code!
16:13:11 <Saizan> ?hackage haskellDB
16:13:11 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/haskellDB
16:14:11 <Saizan> (case sensitive webserver)--
16:14:29 <sorear> @karma webserver)
16:14:29 <lambdabot> webserver) has a karma of -1
16:15:21 <sjanssen> :)
16:15:37 <sjanssen> :)++
16:15:41 <sjanssen> @karma :)
16:15:42 <lambdabot> :) has a karma of 1
16:15:49 <dibblego> ?type fmap
16:15:52 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
16:18:35 <dibblego> > fmap (id) Nothing
16:18:37 <lambdabot>  Nothing
16:18:52 <dolio> @pl fmap id
16:18:53 <lambdabot> id
16:18:53 <dibblego> ?src instance Functor (Maybe a)
16:18:54 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
16:19:18 <dolio> @src Maybe fmap
16:19:18 <lambdabot> fmap _ Nothing       = Nothing
16:19:18 <lambdabot> fmap f (Just a)      = Just (f a)
16:19:24 <dibblego> thanks
16:23:54 <dibblego> > fmap (+8) (Just 7)
16:23:56 <lambdabot>  Just 15
16:28:07 <glguy> id = fmap id   is one of the Functor laws I believe
16:28:11 <Saizan> do any of the dbms interface libraries support prepared statement?
16:29:28 <ddarius> glguy: It is.
16:40:13 <Moozilla> hey I'm sort of new to haskell, could someone recommend a problem for me to try and solve?
16:40:33 <notsmack> Moozilla: projecteuler.net
16:41:05 <Moozilla> thanks! this site looks great :)
16:41:27 <notsmack> Moozilla: it's addicting
16:41:37 <Moozilla> haha
16:45:15 <glguy> Moozilla: You should try to learn enough to write a UTF-8 decoder (not as hard as it might sound)
16:45:32 <Moozilla> what would that do?
16:46:02 <glguy> takes a sequence of bytes, and decodes them into UCS values
16:46:23 <glguy> UTF-8 is a multi-byte encoding where ASCII characters are 1 byte
16:46:29 <fasta> glguy: don't we have something like that already?
16:46:40 <glguy> fasta: sure
16:46:53 <glguy> fasta: the point is as an exercise for someone learning Haskell
16:47:20 <fasta> Moozilla: build something that doesn't exist yet in Haskell
16:47:45 <Moozilla> fasta: wouldn't that be hard for a newbie?
16:47:53 <fasta> OTOH, I cannot really think of simple problems I need to have solved :)
16:48:13 <fasta> Moozilla: oh, yes, I got one.
16:48:18 <lispy> what doesn't exist yet in Haskell?
16:48:29 <lispy> someone was going to write a pdf viewer in haskell
16:48:43 <fasta> lispy: who? That's great.
16:48:44 <dibblego> a program that sorts my music
16:48:46 <Moozilla> is the pdf format open source?
16:48:57 <dibblego> by accepting a HOF that determines how to sort it
16:48:58 <ddarius> I was going to write a PDF parser.  It was suggested that someone make a PDF viewer.
16:48:58 <fasta> Moozilla: that statement is non-sense.
16:49:18 <ddarius> (Actually, I was probably going to write a postscript interpreter.)
16:49:30 <Moozilla> fasta: sorry, but do you know what I mean?
16:49:35 <lispy> ddarius: actually dons said he'd definitely like to do it after xmonad is a bit more complete
16:49:44 <ddarius> Actually, making a PDF viewer wouldn't be that hard.
16:49:53 <fasta> It would be great if there would be a way to see pdf files with a program that actually works.
16:49:56 <notsmack> i've been trying to gear up to write a xhtml/css layout engine and browser
16:50:07 <lispy> right, and if you need a snazzy rendering library haskell has cairo bindings
16:50:11 <fasta> All the existing tools are buggy in one way or another.
16:50:39 <ddarius> Moozilla: Make a PDF viewer using an implementation methodology inspired by xmonad.
16:50:39 <lispy> i bet cairo would work pretty cool for rendering ps/pdf
16:50:40 <fasta> They are good enough for 99,99% of the people, though.
16:51:04 <lispy> ddarius: what is the implementation methodology inspired by xmonad? just all the static testing/checking?
16:51:07 <fasta> ddarius: that would be highly non-trivial for a "newbie".
16:51:16 <Moozilla> ddarius: what fasta said
16:51:17 <ddarius> fasta: Which part?
16:51:59 <fasta> ddarius: hmm, well, I don't know enough about xmonad, never mind.
16:52:04 <ddarius> lispy: The rampant use of quickcheck properties, and I guess Catch would be fine too.
16:52:16 <fasta> ddarius: I assumed it would use monad transformers.
16:52:20 <lispy> i thought dons estimate that the techniques used by xmonad take about 3 years for the average haskell-on-the-side-hacker to learn
16:52:29 <fasta> ddarius: but with only 500 lines, that probably isn't true.
16:52:47 <notsmack> Moozilla: do you get monads yet?
16:52:59 <lispy> (I could be misremembering what he said)
16:53:02 <ddarius> fasta: I believe it does, but it is easy enough to -use- monad transformers, and at any rate that's not the aspect of xmonad I cared about.
16:53:14 <Moozilla> notsmack: sort of, I don't have a full understanding yet, but I think I  understand the concept
16:53:27 <Saizan> fasta: the X monad is ReaderT StateT IO iirc
16:53:42 <ddarius> lispy: Maybe the zipperish stuff and some of the enforcing static guarantees, but hopefully not quickcheck or catch.
16:53:44 <fasta> Moozilla: just start writing the pdf viewer, when you find you cannot solve something in some way elegantly, look at the wiki or ask in this channel.
16:54:18 <Moozilla> fasta: alright, after I solve this problem from project euler :P
16:54:20 <fasta> Moozilla: you will find that you need something better than your hacked up ideas later on and then will want to learn monads, or whatever you need.
16:54:51 <ddarius> @google "PDF reference"
16:54:54 <lambdabot> http://www.adobe.com/devnet/pdf/pdf_reference.html
16:54:56 <lispy> haskell programming techniques seems to go about as deep as the user is willing to delve :)
16:55:21 <notsmack> lispy: almost always deeper.
16:55:23 <ddarius> Yep.  Most are usable without having a profound understanding.
16:55:44 <fasta> I still would like to understand the reified delimited continuations Oleg programmed.
16:55:55 <ddarius> @google Defunctionalization
16:55:57 <lambdabot> http://www.haskell.org/hawiki/DeFunctionalization
16:55:58 <lambdabot> Title: DeFunctionalization - The Haskell Wiki
16:55:59 <Moozilla> right now I'm just wanting to make sure I know the basic functions and techniques like folds, mapping, and the like to solve problems
16:56:01 <fasta> But that will probably happen before I die.
16:56:02 <ddarius> Cute.
16:56:27 <lispy> oh, the wiki is google searchable again?
16:56:34 <ddarius> That's the old wiki
16:56:37 <lispy> oh :(
16:56:47 <ddarius> The new wiki should be indexed now.
16:58:30 <lispy> a search for "Haskell IDE" doesn't turn up any pages on the new wiki in the first page or so of results
16:58:50 <lispy> so i don't think the new wiki is indexed
16:59:52 <lispy> http://haskell.org/haskellwiki/IDE  <-- that page seems like it should have come up
16:59:54 <lambdabot> Title: IDEs - HaskellWiki
17:00:38 <fasta> lispy: maybe Google figured out that there is no IDE.
17:01:20 <ddarius> @google inurl:haskellwiki IDE
17:01:22 <lambdabot> http://www.haskell.org/haskellwiki/HIDE
17:01:22 <lambdabot> Title: HIDE - HaskellWiki
17:02:29 <fasta> I wonder when semantic search will be available.
17:03:14 <Excedrin> sometime after semantic markup is available
17:03:30 <wi> thats available. microformats/rdfa/xhtml2
17:04:56 <cjay> is hide dead?
17:05:14 <oerjan> last i read on haskell-cafe, they were still looking for someone to fix the wiki to accept robots.
17:05:42 <fasta> Excedrin: semantic markup will probably never be available
17:05:58 <dreameye> Hi
17:06:31 <fasta> I know the technology exists for semantic search (or interactive problem solving), it's just not economically viable yet.
17:06:41 <dreameye> I have problems with hs-plugins in GHC 6.6 and 6.6.1
17:06:54 <dreameye> didn¬¥t  you?
17:07:23 <lispy> what problems?
17:07:28 <dreameye> I have this error when calling  load:   Index out of bounds
17:07:33 <dreameye> inside load
17:07:44 <lispy> that sounds like a question for dons
17:07:56 <lispy> who is probably sleeping
17:07:58 <dreameye> is it alive?
17:07:59 <lispy> ?localtime dons
17:08:01 <lambdabot> Local time for dons is Wed Jun 20 10:07:03 2007
17:08:07 <lispy> ?seen dons
17:08:07 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 11h 33m 19s ago.
17:08:26 <lispy> i would expect him any time now :)
17:09:46 <dreameye> Anyone know his mail (dons)?
17:10:02 <lispy> ?version
17:10:02 <lambdabot> lambdabot 4p532, GHC 6.6 (Linux i686 2.66GHz)
17:10:02 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:10:36 <lispy> dreameye: http://www.cse.unsw.edu.au/~dons/contact.html
17:10:37 <lambdabot> Title: contact details
17:11:32 <dreameye> thanks Lispy
17:11:39 <lispy> you're welcome
17:12:48 <glguy> does anyone know if it is possible to build the unix package on windows using some mixture of cygwin, mingw, or msys?
17:14:15 <lispy> i do not know, but the whole point of cygwin is to provide a unix api on windows, so i'd say there is hope
17:17:35 <dons> moin
17:17:48 <lispy> moin moin
17:17:54 <LoganCapaldo> @whatis moin
17:17:55 <lambdabot> I know nothing about moin.
17:17:59 <LoganCapaldo> @dict moin
17:17:59 <lambdabot> Supported dictionary-lookup commands:
17:17:59 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
17:17:59 <lambdabot> Use "dict-help [cmd...]" for more.
17:18:08 <LoganCapaldo> @all-dicts moin
17:18:09 <lispy> LoganCapaldo: it's a german greeting
17:18:10 <lambdabot> No match for "moin".
17:18:37 <LoganCapaldo> I thought he was Australian? :)
17:18:39 <lispy> LoganCapaldo: as i understand it, 'moin' is more of the morning time version and 'moin moin' is the anytime version :)
17:18:40 <glen_quagmire> how long does it take to be a good haskell programmer?
17:18:49 <lispy> glen_quagmire: the rest of your life :)
17:18:50 <glen_quagmire> about a month?
17:18:56 <LoganCapaldo> glen_quagmire: a lifetime
17:18:58 <glen_quagmire> i can study 1 hour per day for a month
17:19:11 <glen_quagmire> how far will that let me be?
17:19:18 <lispy> 1 hour / day for a month and you will see considerable progress, but i doubt you'd be 'good'
17:19:19 <glen_quagmire> |---->           |
17:19:27 <glen_quagmire> ok  i see
17:19:33 <lispy> it is only 30 hours
17:19:39 <glen_quagmire> i might learn lisp than
17:19:48 <LoganCapaldo> glen_quagmire: the only quick way to become a good Haskell programmer is to change your name to Simon :)
17:19:52 <ndm> morning dons
17:19:52 <lispy> can you learn to ride a bike in 30 hours?
17:19:58 <ndm> lispy: no
17:20:04 <glguy> really??
17:20:04 <dons> hah. if you learn haskell, lisp is trivial. if you learn lisp, haskell will still be a mystery .
17:20:11 <glen_quagmire> yes. 30 hours spreaded to 30 days..why not
17:20:19 <glen_quagmire> brain works like this: work, rest, work, rest
17:20:20 <LoganCapaldo> What about a unicycle?
17:20:22 <dons> a typicaly uni course is hmm 54 hours
17:20:22 <lispy> dons: i would say lisp is not trivial for haskell programmers
17:20:34 <dons> the concepts are pretty obvious though, lispy
17:20:40 <LoganCapaldo> All that mutable state is confusing
17:20:44 <glen_quagmire> when you work tight for 1 hour and rest for 23 hours, your brain organizes what you dumped during the 1 hour
17:20:46 <ndm> dons: building on the rest of a uni course - if you started with a bricklayer it would require a lot more
17:21:24 <dons> yep a lot more. assuming glen_quagmire has done a bit of programming, i'd think maybe 100 hours, assuming he dives in and writes 2 or 3 projects
17:21:27 <ndm> dons: plus typical uni courses are taught in a much better manner than learning on your own allows (at least mine was)
17:21:31 <dons> to get competent
17:21:39 <dons> to get 'good' (for some 'good') might take longer
17:22:02 <glen_quagmire> i see. i like haskell coz it's a buzz word
17:22:11 <glen_quagmire> and i saw Yi editor
17:22:14 <ndm> thats enough of a reason to at least start to learn it
17:22:26 <lispy> glen_quagmire: i think 1 hour /day of programming an 30 min or so in the morning reading haskell papers would give you much more benefit than just the programming, BTW
17:22:51 <dons> 1 hour a day would be reasonable i think. assuming you had a project to work on, and asked for help here
17:22:51 <glen_quagmire> nice i'll dig haskell in july
17:23:06 <dons> if you've done lisp first, you might need to rewire your brain though. :-)
17:23:15 <emu> hey i did lisp for years
17:23:21 <ndm> not that much
17:23:24 <ndm> lisp is fairly close
17:23:34 <glen_quagmire> i quit lisp after having trouble transitioning from vim to emacs
17:23:35 <ndm> or at least you can write lisp in haskell, then slowly migrate
17:23:35 <emu> and my brain is totally wackedout
17:23:47 <dons> hehe
17:24:03 <glguy> ndm: Do you know anything about getting the unix package on windows? (using cygwin or something)
17:24:06 <glen_quagmire> but recommended editor for haskell is emacs hah
17:24:15 <dons> vim is fine
17:24:26 * glguy lives in vim
17:24:34 <ddarius> glen_quagmire: There are many vim and non-emacs users
17:24:56 <glguy> I heard that vim users were generally more productive than emacs users, actually
17:25:02 <ndm> glguy: unlikely to work, i think
17:25:13 <dreameye> dons:  I have problems with hs-plugins in GHC 6.6 and 6.6.1
17:25:18 <ddarius> That's because they spend their time writing text rather than tweaking configuration files.
17:25:18 <ndm> i use TextPad, and i'm perfectly productive
17:25:19 <glguy> ndm: so the solution is to dual-boot then ? :)
17:25:19 <dreameye> I have this error when calling  load:   Index out of bounds
17:25:34 <ndm> i think users without IRC and email are probably the most productive (after they've learnt haskell)
17:25:35 <glguy> ndm: You are better than to play into the troll :-p
17:25:39 <glen_quagmire> you should use http://www.haskell.org/yi/Yi.html
17:25:39 <lambdabot> Title: Yi - HaskellWiki
17:25:58 <ndm> glguy: i guess, if you have to use unix - i do wish there was a port of at least some of it, but there isn't
17:26:22 <glguy> one of the bindings we use requires it
17:26:32 <ndm> which one?
17:26:48 <ndm> some of hte things in Unix are also entirely portable in base, but people pick unix because they are lazy
17:27:20 <chessguy> wow, perfectly productive. that's a mighty tall claim
17:27:32 <glguy> hmm... never mind
17:27:38 <lispy> chessguy: different meaning of perfectly
17:27:42 <ndm> should i quality that with "when sober" ?
17:27:43 <glguy> looks like I was wrong,  Imight be able to get by without it
17:27:45 <wy> ndm: No they aren't lazy. they can't be
17:27:54 <dons> dreameye: sounds like it is using the wrong ghc to the one it was built for/
17:28:26 <dreameye> maybe, but I did the rebuild everytime
17:28:48 <ndm> @seen xho
17:28:48 <lambdabot> I saw xho leaving #happs and #haskell 45m 3s ago, and .
17:29:52 <dreameye> I¬¥m a bit desperate. I just want to be sure that this is not a known problem
17:30:48 <dreameye> maybe I have too many versions of GHC dancing at the same time
17:31:44 <chessguy> dreameye, that depends, are they doing a waltz or a tango?
17:32:20 <LoganCapaldo> As long as they aren't doing the macarena
17:32:33 <dreameye> it¬¥s more like random agitation
17:33:29 <Moozilla> quick question: what's the opposite of show?
17:33:37 <dibblego> read
17:33:42 <Moozilla> thanks
17:35:06 <Moozilla> I get an ambiguous type error
17:35:12 <Moozilla> > read "123"
17:35:14 <lambdabot>  123
17:35:23 <Excedrin> > read "123" :: Float
17:35:25 <lambdabot>  123.0
17:35:26 <dibblego> > (read "123") :: Int
17:35:28 <lambdabot>  123
17:35:48 <kpreid> Moozilla: when you use read in an appropriate context, it won't.
17:36:01 <Moozilla> kpreid: I think I get it
17:36:13 <kpreid> @type read
17:36:15 <lambdabot> forall a. (Read a) => String -> a
17:51:55 <LoganCapaldo> @hoogle (Read a) => String -> Maybe a
17:51:56 <lambdabot> No matches, try a more general search
17:52:06 <LoganCapaldo> fine!
17:52:07 <mauke> :t reads
17:52:09 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:52:50 <LoganCapaldo> :t map fst . listToMaybe . reads
17:52:52 <lambdabot>     Couldn't match expected type `[(a, b)]'
17:52:52 <lambdabot>            against inferred type `Maybe (a1, String)'
17:53:27 <LoganCapaldo> :t listToMaybe . map fst . reads
17:53:29 <lambdabot> forall a. (Read a) => String -> Maybe a
17:55:51 <LoganCapaldo> @pl \s -> case reads s of { (a, _):_ -> Just a; [] -> Nothing }
17:55:51 <lambdabot> (line 1, column 23):
17:55:51 <lambdabot> unexpected "{"
17:55:51 <lambdabot> expecting variable, "(", operator or end of input
17:56:16 <LoganCapaldo> @pl \s -> case reads s of  (a, _):_ -> Just a; [] -> Nothing
17:56:16 <lambdabot> (line 1, column 26):
17:56:16 <lambdabot> unexpected ","
17:56:16 <lambdabot> expecting letter or digit, variable, "(", operator or ")"
17:56:35 <LoganCapaldo> @pl \s -> case reads s of  { ((a, _):_) -> Just a; [] -> Nothing  }
17:56:35 <lambdabot> (line 1, column 24):
17:56:36 <lambdabot> unexpected "{"
17:56:36 <lambdabot> expecting variable, "(", operator or end of input
17:56:46 <LoganCapaldo> @pl (\s -> case reads s of  { ((a, _):_) -> Just a; [] -> Nothing  })
17:56:47 <lambdabot> (line 1, column 25):
17:56:47 <lambdabot> unexpected "{"
17:56:47 <lambdabot> expecting variable, "(", operator or ")"
17:56:57 <LoganCapaldo> Am I stupid or something?
17:57:04 <glen_quagmire> yes
17:57:21 <glen_quagmire> no you're not stupid LoganCapaldo .
17:57:49 <mauke> LoganCapaldo: @pl doesn't grok case
17:57:55 <mauke> or patterns
17:58:01 <LoganCapaldo> oh
17:58:10 <LoganCapaldo> ok then
17:59:03 <LoganCapaldo> @pl (\s -> let a = reads s in if null a then Nothing else Just (fst (head a)))
17:59:04 <lambdabot> ap (flip if' Nothing . null) (Just . fst . head) . fix . const . reads
17:59:14 <LoganCapaldo> I think I liked mine better
18:01:48 <LoganCapaldo> @type (\s -> let a = reads s in if null a then Nothing else Just (fst (head a)))
18:01:50 <lambdabot> forall a. (Read a) => String -> Maybe a
18:02:09 <LoganCapaldo> :t listToMaybe . map fst . reads
18:02:11 <lambdabot> forall a. (Read a) => String -> Maybe a
18:02:52 <oerjan> i am sure your case version was fine put @pl is not a full Haskell parser
18:03:11 <LoganCapaldo> I know that now :)
18:03:54 <LoganCapaldo> I'm a little surprised. You'd figure @pl could ask GHC to feed it the parse tree or something instead of parsing it itself
18:04:01 <LoganCapaldo> Oh wow
18:04:10 <oerjan> here is another:
18:04:15 <LoganCapaldo> I just realized parsing haskell must be a pain in the neck
18:04:37 <LoganCapaldo> operators with arbitrary precedence must totally ruin your day
18:05:36 <oerjan> :t \s -> do (a,_):_ <- Just (reads s) ; return a
18:05:38 <lambdabot> forall a. (Read a) => String -> Maybe a
18:05:48 <jfredett> Category theory question-- In a category, is it necessary that every morphism on object have an inverse?
18:05:48 <jfredett> that is,  forall f, f :: A -> B, there exists f^-1 such that f :: B -> A, and f*f^-1 == id ?
18:06:24 <jfredett> s/morphism on/morphism on an/
18:06:27 <LoganCapaldo> oerjan: neat
18:08:35 <wchogg> jfredett:  Not it is not.
18:09:19 <jfredett> damn
18:09:29 <wchogg> jfredett:  Why?
18:09:45 <jfredett> wchogg: I like it when things have inverses?
18:09:47 <jfredett> :)
18:09:49 <oerjan> those morphisms that do are called isomorphisms, btw
18:09:59 <sfogarty> Hi. I am probably being a complete idiot, but I simply cannot find a function. I am looking for something of String -> Maybe Int, since read might fail. I have looked in int, list, read.... anyone perhaps help?
18:10:07 <oerjan> actually, that is both ways.
18:10:13 <dibblego> ?hoogle String -> Maybe Int
18:10:14 <lambdabot> No matches, try a more general search
18:10:35 <oerjan> if it is only one way, they are called epic or monic, respectively.
18:10:38 <dibblego> ?hoogle String -> Maybe a
18:10:39 <lambdabot> No matches, try a more general search
18:10:44 <jfredett> oerjan: I see
18:10:48 <ddarius> jfredett: A category where every arrow is invertible is a groupoid.
18:10:57 <ddarius> If it has only one object, then it is a group.
18:11:09 <mauke> sfogarty: reads
18:11:15 <LoganCapaldo> sfogarty: are you serious?
18:11:17 <jfredett> whoa! what?
18:11:28 * LoganCapaldo feels really sureal
18:11:31 <jfredett> groups! I know what those are!
18:11:32 <jfredett> :/
18:11:33 <sfogarty> .....
18:11:49 <mauke> > reads "hello"
18:11:50 <LoganCapaldo> sfogarty: I just spent the last 5 minutes writing that function
18:11:54 <oerjan> sfogarty: we were actually doing just that just before you entered :)
18:11:55 <sfogarty> thank you
18:11:58 <sfogarty> heh
18:12:00 <sfogarty> yes, I am serious
18:12:05 <lambdabot>  thread killed
18:12:06 <LoganCapaldo> (in terms of reads)
18:12:06 <sfogarty> and yes, reads is exactly what I want
18:12:07 <sfogarty> thank you
18:12:16 <LoganCapaldo> :t listToMaybe . map fst . reads
18:12:18 <lambdabot> forall a. (Read a) => String -> Maybe a
18:12:19 <sfogarty> so fixated on the maybe :)
18:12:19 <jfredett> so categorys with only isomorphisms over 1 object are groups
18:12:23 <mauke> > reads "hello"
18:12:24 <lambdabot>  []
18:12:27 <ddarius> jfredett: Yes.
18:12:33 <mauke> > reads "42 EUR"
18:12:34 <lambdabot>  [(42," EUR")]
18:12:47 <LoganCapaldo> :t listToMaybe . map fst . reads $ "42 EUR"
18:12:49 <lambdabot> forall a. (Read a) => Maybe a
18:12:49 <jfredett> categorys with only isomorphisms over multiple objects are groupoids
18:12:55 <LoganCapaldo> > listToMaybe . map fst . reads $ "42 EUR"
18:12:56 <ddarius> Yes.
18:12:56 <lambdabot>  Just 42
18:13:03 <LoganCapaldo> > listToMaybe . map fst . reads $ "EUR"
18:13:05 <lambdabot>  Nothing
18:13:05 <jfredett> ddarius: You just blew my brain-
18:13:38 <sorear_> Wow.
18:13:38 <sfogarty> I must have read over reads half a dozen times, and just... missed it. Thank you very much.
18:13:54 <sorear_> I just lost my connection fro 10 minutes...
18:14:04 <ddarius> A category with only one object is equivalent to a monoid.
18:14:38 <hpaste>  Gwern pasted "A bot for archiving external links on Wikipedia" at http://hpaste.org/334
18:14:48 <lpz> hi all
18:14:56 <sorear> hello lzp
18:14:58 <sorear> lpz
18:15:13 <gwern> so I'm kind of proud of my latest little haskell program. anyone want to savage it and make me feel ignorant and poor of intellect as is the invariable wont of #haskellers? :)
18:15:15 <jfredett> so-- one more question, the category  (forgive if I don't use the correct notation) given by:
18:15:18 <lpz> hi sorear.. you probably know why im here haha more questions
18:15:33 <sorear> so++
18:15:47 <sorear> lpz: no problem, we actually *like* questions
18:15:49 <jfredett> ({A,B}, {f::A->B, g::B->A})
18:15:56 <jfredett> is a groupoid?
18:16:01 <jfredett> (it has id's too
18:16:09 <jfredett> but i just omitted them.)
18:16:21 <lpz> ok.. now i'm analyzing the take function from the prelude and i have a few questions
18:16:21 <ddarius> If f.g = id = g.f
18:16:24 <sorear> indeed I have a question of my own: what's the best SLR(1)-or-superset parser for haskell?
18:16:33 <sorear> lpz: ask please!
18:16:40 <jfredett> ddarius: awesome....
18:16:56 <ddarius> Well, those equalities don't match type wise-, but you get the idea.
18:17:32 <ddarius> Also, a category with at most one arrow between any two objects is a preorder.  If we quotient out isomorphism classes, it's a partial order.
18:17:57 <jfredett> whoa.. preorders and partial orders... :/
18:18:09 <int-e> gwern: hmm. maybe use map head . group . sort (or, maybe even better, Data.Set.toList . Data.Set.fromList) instead of nub. looks good to me otherwise
18:18:19 <jfredett> this category theory stuff is hardcore.
18:18:34 <sorear> lpz: ?
18:18:35 <ddarius> Those are just special cases of categories.
18:18:39 <lpz> ok, this is the code:
18:18:39 <lpz> take                :: Int -> [a] -> [a]
18:18:39 <lpz> take n _  | n <= 0  = []
18:18:39 <lpz> take _ []           = []
18:18:39 <lpz> take n (x:xs)       = x : take (n-1) xs
18:18:40 <lpz> i'd like to know how the first definition works. I tried deleting it and the result was that take actually didn't do anything: take 2 "hello" returned "hello", so i thought that that definition is escencial to finish the list.. is this right?
18:18:52 <gwern> int-e: what does the toList and fromList stuff do that nub doesn't?
18:18:59 <sorear> lpz: right.
18:18:59 <ddarius> The preorder/partial order specialization probably provides the most intuition.
18:19:12 <sorear> gwern: run much faster
18:19:15 <int-e> gwern: it has better complexity (nub is O(n^2))
18:19:20 <sorear> O(n log n) vs O(n^2)
18:19:34 <ddarius> E.g. adjunctions are Galois connections, monads are closure operators, initial/terminal is bottom/top, etc.
18:19:50 <gwern> oh. but besides complexity does the same thing?
18:19:54 <sorear> galois connections are CT?
18:20:00 <jfredett> ddarius: you just sailed out of my mathematical atmosphere
18:20:02 * sorear 's head explodes
18:20:02 <wchogg> ddarius:  And if you add finite products and coproducts it's a lattice.
18:20:08 <ddarius> sorear: Technically, yes.
18:20:43 <ddarius> Lattice/order theory is pretty straightforward.
18:21:11 <int-e> gwern: pretty much. nub preserves order, but I think you didn't need that.
18:21:13 <Cale> lpz: The first line says that take n of anything where n is less than or equal to 0 is the empty list.
18:21:21 <jfredett> yeh-- it seems like I should learn some of this other stuff (lattice/order theory, field theory, ring theory, etc.) before I keep going w/ CT
18:21:25 <ddarius> Category theory can be viewed as "Coherently constructive lattice theory"
18:21:27 <jfredett> yeh++
18:21:45 <Cale> lpz: It's essentially what causes the recursion to stop after the right number of elements have been taken.
18:22:02 <shachaf> lpz: Imagine it said "take 0 _ = []".
18:22:08 <sorear> jfredett++
18:22:13 <shachaf> lpz: But it also works for negative numbers.
18:22:16 <jfredett> sorear: lol
18:22:22 <ddarius> The core of category theory, that does exist as specialized versions in other branches of math is representability which is most simply stated using CT.
18:22:50 <jfredett> as in-- group representation theory representability?
18:22:56 <jfredett> that makes sense, I guess--
18:23:17 <jfredett> you look at groups as a category structure, and then map the Grp category to something else-
18:23:30 <shachaf> in++ guess++
18:23:33 <jfredett> like Mtrx or Kttn categorys
18:23:46 <ddarius> Not blatantly obviously.
18:23:58 <jfredett> ddarius: but it could happen... maybe...
18:24:20 <ddarius> jfredett: You know what a Hom set is, a functor, a natural transformation, an isomorphism?
18:24:30 <jfredett> ...
18:24:38 <jfredett> Hom set == set of homomorphisms?
18:24:52 <jfredett> and I know what an isomorphism is
18:24:55 <ddarius> That's where the name comes from, it's the set of arrows between two given objects.
18:25:04 <jfredett> ohhhh.
18:25:05 <ddarius> Those are all basic category theory things.
18:25:48 <ddarius> A collection of hom-sets is part of the definition of a category, a functor is a category homomorphism, a natural transformation is a functor homomorphism.
18:25:50 <jfredett> functors and nat transformations are something I haven't really fully comprehended yet
18:25:59 <ddarius> But you know what they are?
18:26:02 <jfredett> sortof
18:26:21 <jfredett> in a "I know what Quantum Physics is, but don't ask me to explain it" kind of way
18:26:41 <jfredett> I know functors map categorys to categorys
18:26:50 <jfredett> and natural transformations map functors to functors
18:27:03 <jfredett> or at least- thats how I'm understanding it now
18:27:12 <jfredett> doubtless I'll find that I'm completely wrong
18:27:13 <lpz> so theres a variable that iterates?
18:27:14 <sorear> oh, right, remembered why I came
18:27:31 <sorear> what's the best LALR(1) parser for Haskell?
18:27:33 <ddarius> jfredett: Yes that is what functors and natural transformations do.
18:27:48 <lpz> ok i got it
18:28:01 <ddarius> Do you know what the Hom-functor is?
18:28:04 <jfredett> whoa -- I was right
18:28:16 <jfredett> Hom-functor maps a Hom to a Hom? maybe?
18:28:41 <sorear> happy generates useless error messages
18:28:50 <ddarius> Hom(A,B) is the set of arrows between A and B.  This construction is functorial in each of A and B.
18:28:56 <sorear> maybe I should try to fix that now that I grok LR(1)
18:29:15 <ddarius> The action of Hom on arrows is merely pre-/post-composition.
18:29:26 <jfredett> hold on.. an arrow is a morphism, being functorial is
18:29:47 <jfredett> a morphism w/ the property of being a functor for both A and B?
18:29:58 <jfredett> where A and B are categorys?
18:30:03 <jfredett> no- that doesnt seem right
18:30:42 <ddarius> A and B are objects in a category C, Hom(A,B) is a set, i.e. an object of Set.  Hom(A,-) : C -> Set, Hom(-,B) : C^op -> Set
18:31:07 <ddarius> Hom(-,=) : C^opxC -> Set
18:31:08 <jfredett> C^op is like the complement of C?
18:31:23 <jfredett> oh, no- its C w/ all arrows reversed
18:31:27 <ddarius> C^op is the opposite/dual category to C.  It's the same as C but with all arrows reversed.
18:31:37 <jfredett> opposite... gotcha
18:32:50 <ddarius> f : A->B, g : C->D Hom(f,g) : Hom(B,C) -> Hom(A,D) via h |-> g . h . f
18:33:02 <ddarius> That's the action of the Hom functor on arrows.
18:33:28 <jfredett> ddarius: I think I'm lost again -- but thats okay.
18:34:06 <ddarius> For concreteness think of Hom(A,B) as A->B
18:34:16 <jfredett> but wouldn't that be Hom(f,g) : Hom(A,C) -> Hom(B,D) ?
18:34:30 <ddarius> Hom is contravariant in it's first argument.
18:34:34 <jfredett> oh
18:34:36 <jfredett> cool
18:34:55 <ddarius> That was f \in C, so it's usage there is f^op \in C^op : B -> A
18:35:20 <jfredett> i see.
18:35:59 <ddarius> The action of Hom(A,-)=A -> - on arrows is to post-compose. And indeed, instance Functor (a->) where fmap f g = f . g
18:36:22 <jfredett> so wait in -- Hom(A,-) -- what is the '-'
18:36:53 <ddarius> The very loose placeholder syntax common in CT, Hom(A,-) is shorthand for \X.Hom(A,X)
18:37:07 <jfredett> okay
18:37:13 <jfredett> so its kind of like _ ?
18:37:27 <ddarius> _ of Haskell?
18:37:30 <jfredett> yah
18:37:35 <ddarius> No
18:38:04 <jfredett> so its not Hom(A, <anything>)
18:38:15 <jfredett> is Hom(A, <?>)
18:38:20 <Cale> It's the map which sends X to Hom(A,X)
18:38:24 <ddarius> No, it's like a section.
18:38:26 <jfredett> okay-
18:38:28 <jfredett> i get it
18:38:39 <jfredett> i missed the lambda part
18:39:07 <jfredett> Hom(A, - ) is a map X -> Hom(A,X).
18:39:10 <jfredett> gotcha
18:39:30 <ddarius> Actually it extends to a functor C -> Set
18:40:43 <jfredett> okay-
18:40:46 <jfredett> i think I follow
18:41:20 <ddarius> Understanding the Hom-functor and natural isomorphism is all you need to state representability.
18:41:27 <jfredett> cool
18:42:03 <ddarius> A functor F : C -> Set is representable iff it is naturally isomorphic to a Hom-functor.  That is, F is representable <=> F ~ Hom(X,-)
18:42:44 <ddarius> Also, and more commonly, F : C^op -> Set is representable <=> F ~ Hom(-,Y)
18:42:56 <jfredett> and then a Functor from Grp to <something else> would be a representation of the group if the same were true, I get it...
18:44:57 <ddarius> Representability is everything in (1-)category theory.
18:45:42 <jfredett> nifty
18:46:32 <ddarius> It's equivalent to the notion of universal arrow.
18:46:45 <jfredett> oh dear.
18:47:05 * jfredett is on math overload.
18:49:29 <ddarius> How about a simple example: Let F be the constantly singleton set functor, then F ~ Hom(-,Y) means Y is the terminal object.
18:49:51 <jfredett> Famous last words... "Simple Example"
18:49:59 <jfredett> right- terminal object has only in-arrows
18:50:14 <jfredett> that is, Y is terminal means no f :: Y -> X
18:50:15 <jfredett> forall x
18:50:18 <jfredett> X*
18:50:19 <ddarius> No
18:50:39 <jfredett> damn --, I was hopeing it was that simple
18:51:00 <oerjan> @karma damn
18:51:01 <lambdabot> damn has a karma of 0
18:51:01 <Moozilla> question here, I have a function that calculates a given row of pascal's triangle. how can I make one that's an infinite list of the rows?
18:51:07 <wchogg> A terminality isn't an exlusive property.  It says nothing about arrows from the terminal object, just that for every other objects there exists one and only one arrow to it.
18:51:15 <ddarius> forall A.FA ~ {*} ~ Hom(A,Y), i.e. there exists exactly one arrow to Y for every object A.
18:51:25 <LoganCapaldo> Moozilla: map yourfun [1..]
18:51:25 <ndm> sorear: the best parser is mine, alas its also unwritten...
18:51:38 <jfredett> oooh!
18:51:40 <jfredett> I see
18:51:41 <LoganCapaldo> or [0..] depending on how you numbered the rows
18:51:49 <Moozilla> thanks!
18:51:54 <Moozilla> LoganCapaldo++
18:52:10 <Moozilla> (did I do that right?)
18:52:25 <jfredett> yep.
18:52:28 <jfredett> methinks
18:52:36 <ndm> yep, or @karma+ name
18:52:48 <jfredett> I know this karma system well
18:53:04 <Moozilla> actually that's not quite what I want to do
18:53:05 <jfredett> I accidently mark things down all the time
18:53:06 <jfredett> :)
18:53:25 <Moozilla> I want it to be like this sort of: fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
18:53:38 <Moozilla> so it calculates it off the last one
18:53:50 <shachaf> Moozilla: Try iterate?
18:54:20 <Moozilla> shachaf: I don't think that's what I'm looking for
18:54:30 <Moozilla> maybe it would help if I give my current function
18:54:41 <shachaf> > iterate (*2) 1
18:54:42 <lambdabot>  [1,2,4,8,16,32,64,128,256,512,1024,2048,4096,8192,16384,32768,65536,131072,2...
18:54:49 <Moozilla> pascal 0 = [1]
18:54:51 <Moozilla> pascal n = 1 : (zipWith (+) (reverse t) t) ++ [1]
18:54:52 <Moozilla>   where
18:54:54 <Moozilla>    t = tail (pascal (n - 1))
18:55:10 <oerjan> Moozilla: pascal = iterate f [1] where f l = zipWith (+) (0:l) (l++[0])
18:55:53 <Moozilla> > pascal = iterate f [1] where f l = zipWith (+) (0:l) (l++[0]) in take 5 pascal
18:55:53 <ddarius> jfredett: Understanding the continuity properties of Hom let's you immediately turn up a bunch of representations for things.
18:55:53 <lambdabot>  Parse error
18:56:09 <chessguy> > let f l = zipWith (+) (0:l) (l++[0]);  pascal = iterate f [1] in pascal
18:56:10 <lambdabot>  [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1],[1,5,10,10,5,1],[1,6,15,20,15,6,1],...
18:56:26 <chessguy> oerjan++ nice code
18:56:37 <jfredett> ddarius: neat.
18:56:52 <Moozilla> oerjan: yeah great code, but can you help me understand it? :P
18:56:55 <glen_quagmire> http://www.cafepress.com/glen_quagmire.142964960  hey i made this haskell book. do you think it's worth the money?
18:57:03 <glen_quagmire> it's yaht.pdf
18:57:09 <Cale> Moozilla: Consider what f l does to a list.
18:57:15 <glen_quagmire> or do you know any cheaper printing place?
18:57:30 <shachaf> Moozilla: Well, walk through it.
18:57:32 <oerjan> iterate f l gives the list [l, f l, f (f l), etc.]
18:57:39 <shachaf> Moozilla: Do you understand f?
18:57:42 <chessguy> ermm, why would you buy something that's freely available?
18:57:44 <Moozilla> yes
18:57:49 <oerjan> so you start with [1], then f gives the next row
18:57:55 <jfredett> the library? 0.10$ a page, 80 pages-- 8 bucks? heck-- my printer 0$?
18:57:56 <jfredett> :)
18:58:02 <ddarius> For example, since Hom is continuous in it's second argument (continuous means preserves limits in CT) then we can get the representation for products (products being limits).  Hom(-,AxB) ~ Hom(-,A)xHom(-,B)
18:58:15 <Moozilla> I guess I don't get where the 0's are coming from
18:58:31 <shachaf> > let f l = zipWith (+) (0:l) (l++[0]) in f [1,2]
18:58:31 <jfredett> oh dear
18:58:32 <lambdabot>  [1,3,2]
18:58:51 <Moozilla> oh I see now
18:58:57 <shachaf> > zipWith (+) [0,1,2], [1,2,0]
18:58:58 <jfredett> ddarius: that actually just made me dizzy
18:58:58 <lambdabot>  Parse error
18:59:00 <jfredett> ...
18:59:06 <Moozilla> it's just a different way than I was doing it
18:59:12 <Cale> Moozilla: that ensures that when you add the two lists, you get the first element of f l equalling the first element of l, and the last element of f l being the last element of l
18:59:19 <ddarius> jfredett: It just says an arrow into a product from some object C is the same thing as a pair of arrows from C.
18:59:27 <jfredett> i see
18:59:31 <jfredett> nifty
18:59:38 <Moozilla> right thanks everyone (is there a mass karma++?)
18:59:38 <Cale> (and everything in between being the sum of adjacent pairs of elements)
18:59:53 <shachaf> @karma karma
18:59:54 <lambdabot> karma has a karma of 3
19:00:03 <ddarius> @karma+ .*
19:00:03 <lambdabot> .*'s karma raised to 1.
19:00:08 <ddarius> .*--
19:00:14 <ddarius> @karma .*
19:00:14 <lambdabot> .* has a karma of 0
19:00:19 <shachaf> @karma+ #haskell
19:00:19 <lambdabot> #haskell's karma raised to 6.
19:00:26 <jfredett> @karma
19:00:26 <lambdabot> You have a karma of 1
19:00:30 <jfredett> whoo! 1
19:00:31 <jfredett> :)
19:00:34 <Moozilla> @karma
19:00:34 <lambdabot> You have a karma of 0
19:00:41 <Cale> @karma
19:00:41 <lambdabot> You have a karma of 46
19:00:46 <lpz> @karma
19:00:47 <lambdabot> You have a karma of 0
19:00:49 <LoganCapaldo> @karma
19:00:49 <lambdabot> You have a karma of 5
19:00:57 <LoganCapaldo> yes!
19:01:01 <lpz> how do i give karma?
19:01:13 <Cale> lpz++
19:01:17 <Cale> @karma lpz
19:01:18 <lambdabot> lpz has a karma of 1
19:01:24 <ddarius> @karma- lpz
19:01:24 <lambdabot> lpz's karma lowered to 0.
19:01:25 <LoganCapaldo> lpz: or @karma+ name
19:01:31 <jfredett> lpz <name> ++  or @karma+ <name>
19:01:39 <jfredett> minus spaces on the former
19:01:51 <lpz> @karma+ sorear
19:01:52 <lambdabot> sorear's karma raised to 41.
19:02:11 <Moozilla> lambdabot++ you are amazing
19:02:13 <ddarius> @karma
19:02:14 <lambdabot> You have a karma of 3
19:02:16 <sorear> :)
19:02:29 <Moozilla> @karma lamdabot
19:02:30 <lambdabot> lamdabot has a karma of 0
19:02:32 <jfredett> alright-- back to reading about CT
19:02:43 <shachaf> alright++
19:03:02 <chessguy> @karma alright
19:03:03 <lambdabot> alright has a karma of 0
19:03:10 <chessguy> @karma foobarbastic
19:03:11 <lambdabot> foobarbastic has a karma of 0
19:03:24 <shachaf> @karma+ plugh
19:03:25 <lambdabot> plugh's karma raised to 1.
19:03:34 <sorear> @karma+ xyzzy
19:03:34 <lambdabot> xyzzy's karma raised to 1.
19:03:50 <shachaf> @karma adventure
19:03:51 <lambdabot> adventure has a karma of 0
19:04:05 <jfredett> We should just have Lambdabot ignore everything I say, karmawise.
19:04:31 <Moozilla> maybe everything that isn't a user
19:04:47 <jfredett> @ignorejfredettbecausehecantcontrolhis-'s
19:04:47 <lambdabot> Unknown command, try @list
19:04:56 <sorear> @ignore + jfredett
19:04:58 <oerjan> well, everything that doesn't use explicit @karma+
19:05:17 <oerjan> @help ignore
19:05:17 <lambdabot> ignore [+|-] nick. change a user's ignore status.
19:05:24 <jfredett> yeh
19:05:42 <shachaf> sorear: I doubt that's what jfredett wanted.
19:06:00 <jfredett> :(
19:06:25 * sorear waits for an explicit request
19:06:38 * sorear does not like ambiguous timing
19:06:46 <oerjan> @ignore - jfredett
19:06:46 <lambdabot> Not enough privileges
19:06:50 <oerjan> aha
19:06:58 <LoganCapaldo> @privilege + oerjan
19:06:59 <lambdabot> Unknown command, try @list
19:07:04 <jfredett> ediboh?
19:07:19 <sorear> @admin + oerjan
19:07:25 * jfredett sits and tries to comprehend whats happening
19:07:27 <sorear> jfredett: ediboh?
19:07:30 <oerjan> @ignore - jfredett
19:07:38 <jfredett> its from a conlang I made once
19:07:54 <sorear> @admin - oerjan
19:08:18 <oerjan> aww ;-)
19:08:23 <jfredett> it means, simultaneously, "What; I'm confused; Oh my god my brain hurts; and F*$#"
19:08:42 <jfredett> oh- and "I don't even care anymore" also
19:08:45 <sorear> What is the preferred Haskell LR(1) parser?
19:08:53 * LoganCapaldo wonders what woulda happened if he had gotten @flush in there before the @admin - and then crashed LB.
19:09:09 <LoganCapaldo> Can regular joes flush anyway?
19:09:12 <LoganCapaldo> @flush
19:09:12 <lambdabot> Not enough privileges
19:09:16 <sorear> LoganCapaldo: Nothing useful. @admin status isn't serialized
19:09:16 <LoganCapaldo> guess not
19:09:22 <LoganCapaldo> sorear: ah
19:09:44 <sorear> LoganCapaldo: unfortunately lambdabot's design makes it impossible for core features to save state - only plugins can do that
19:09:52 <gwern> hmm. if (Data.Set.toList . Data.Set.fromList) does the same thing as 'nub', but with a better complexity, then why isn't nub defined in terms of Data.Set?
19:10:04 <oerjan> sorear: since when is haskell LR(1)? :)
19:10:11 <sorear> lambdabot needs a serious redesign.  I'd do it if I had half a clue how
19:10:16 <sorear> oerjan: Parse error
19:10:25 <LoganCapaldo> gwen: because nub only needs Eq
19:10:32 <sorear> LR(1) parser IN haskell
19:10:36 <dons> sorear: hmm. see the yi paper. it shows how to serialise the core
19:10:40 <LoganCapaldo> :t (Data.Set.toList . Data.Set.fromList)
19:10:43 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:10:43 <gwern> LoganCapaldo: and Set needs ord or something?
19:10:48 <LoganCapaldo> exactly
19:10:59 <gwern> alright. that makes sense then
19:11:00 <dons> we actually used to do that for a short while (i.e. even preserve network handles over restarts)
19:11:23 <LoganCapaldo> also I think nub preserves the original ordering, where (Data.Set.toList . Data.Set.fromList) wouldn't necessarily
19:11:28 <jfredett> right- because nub just repeatedly filters and tails the list- but Data.Set is organizing the list into a tree-- right?
19:11:31 <LoganCapaldo> > nub [2,1,3]
19:11:32 <lambdabot>  [2,1,3]
19:11:44 <sorear> jfredett: right. ( tree++ )
19:11:57 <LoganCapaldo> > (Data.Set.toList . Data.Set.fromList) [2,1,3]
19:11:58 <jfredett> shizzle, all but one on that one
19:11:59 <lambdabot>  [1,2,3]
19:12:06 <sorear> otoh, nub is lazier
19:12:07 <glen_quagmire> is there a recommended book other than yaht.pdf? deadtree books is fine too. http://www.haskell.org/haskellwiki/Books  so many books there. not sure what to choose
19:12:08 <lambdabot> Title: Books and tutorials - HaskellWiki
19:12:34 <sorear> > nubBy(((>1).).gcd)[2..] -- gwern:
19:12:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:12:41 <jfredett> nub l = (head l) : filter (\a -> a /= (head l)) (tail l)
19:12:45 <jfredett> as I remember
19:12:47 <sorear> `@src nub
19:12:47 <gwern> glen_quagmire: did you see the haskell wikibook's 'print' option?
19:12:49 <sorear> @src nub
19:12:49 <lambdabot> nub = nubBy (==)
19:12:54 <sorear> @src nubBy
19:12:54 <lambdabot> nubBy eq []             =  []
19:12:55 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
19:13:16 <gwern> sorear: alright, so the price one pays for the toList fromList approach's speed is that it is not lazy and it also requires Ord, basically?
19:13:19 <jfredett> i was close- i forgot the base case
19:13:20 <jfredett> :/
19:13:53 <sorear> gwern: Only the latter.  It can be made lazy, as I described in a mail to libraries@ a couple months ago
19:14:14 <jfredett> gwern: I'd say the real price is the lack of orderpreserving
19:14:25 <jfredett> rather than requiring Ord
19:14:26 <glen_quagmire> gwern: oh nice
19:14:39 <LoganCapaldo> :t map head . groupBy (==) . sort
19:14:41 <dons> ddarius: make any progress on the slides DSL?
19:14:41 <lambdabot> forall a. (Ord a) => [a] -> [a]
19:14:59 <gwern> jfredett: fair enough. in my case order is irrelevant, but I could see it being important
19:15:10 <LoganCapaldo> Isn't that a lazy version of the toList . fromList technique?
19:15:17 <ddarius> dons: I read that Scheme Slideshow paper.  I've read some of the Beamer user guide.
19:15:34 <LoganCapaldo> oh I guess sort isnt lazy
19:15:40 <jfredett> but its still slow-- isn't it?
19:15:45 <shachaf> slow++
19:15:53 <jfredett> damn, brb
19:15:54 <sorear> jfredett, gwern: the approach I sent WAS order-preserving
19:16:05 <jfredett> i see
19:16:11 <gwern> sorear: they didn't take it?
19:16:18 <sorear> gwern: Ord v. Eq
19:16:35 <sorear> gwern: besides, any thread longer than 10 messages is automatically forgotten
19:17:04 <sorear> Let's suppose I'm writing a largish Haskell program, which needs to, among other things, process a LR(1) language.
19:17:13 <sorear> What tool or library should I use?
19:17:14 <LoganCapaldo> sorear: did you fold a map over the list skipping elems if they were already in the list?
19:17:28 <LoganCapaldo> err already in the map I mean
19:17:31 <ddarius> sorear: Whichever fits the application best.  Whichever you like best.
19:17:46 <ddarius> There isn't a clear winner there.
19:18:00 <sorear> ddarius: Happy has v. bad error messages, I don't understand frown, and I don't know of others.
19:18:42 <sorear> v. bad  ==  worse than "No."
19:19:06 <jfredett> lol... sorear- how many times hae you asked that now?
19:19:28 <sorear> jfredett: Four or five.  But nobody has answered it before.
19:19:46 <jfredett> i know. sorear++ for determination
19:19:55 <oerjan> > nubBy (((==0).) . flip mod) [2..]
19:19:57 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:20:12 <sorear> oerjan: it's a lot shorter with gcd!
19:20:22 <sorear> > nubBy(((>1).).gcd)[2..]
19:20:24 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
19:20:26 <jfredett> is that a list of primes?
19:20:28 <oerjan> sorear: yes, but gcd is more expensive
19:20:41 <oerjan> i saw that above
19:20:45 <sorear> oerjan: So is trial division (which is what we're both doing)
19:20:45 <ddarius> jfredett: Yes
19:20:55 <jfredett> thats hardcore...
19:21:10 <jfredett> me and my dad had a C vs Haskell contest
19:21:31 <oerjan> sorear: gcd is more expensive than mod
19:21:33 <sorear> jfredett: Infact, it is the *maximal* list of primes.  In the sense that all ascending sequences of primes are subsequences of that one
19:21:34 <ddarius> jfredett: It's a straightforward implementation.  It's just neat that it's so concise.  It isn't particularly fast.
19:21:36 <jfredett> that would have won it
19:21:53 * sorear <3 math
19:21:59 <jfredett> thats fine- I had a 50 character seive method
19:22:10 <jfredett> with full, readable, intelligent names
19:22:23 <jfredett> he did a 80 character one, that had small names
19:22:33 <jfredett> the only rule was that it had to be a stream
19:22:39 <jfredett> of primes
19:22:50 <jfredett> I warned him that haskell was very good at streams.
19:22:59 <jfredett> but he didn't want to listen -- so I won
19:23:00 <jfredett> :)
19:23:53 <gwern> jfredett: what was the benchmark? shortness of program, running speed, big o, memory use or what?
19:24:28 <jfredett> shortness of program vs readability vs speed vs coolness factor
19:24:38 <jfredett> I won of shortness, readability, and coolness
19:24:41 <jfredett> he nailed me on speed
19:24:51 <gwern> aw
19:24:52 <jfredett> (I ran mine in ghci...)
19:25:02 <jfredett> it ran at half the speed his did
19:25:25 <dons> and in ghci too!
19:25:36 <gwern> wonder what a -02 would've done for it
19:25:42 <jfredett> I had to give him something-- he's been writing C for 30 years- it would have devestated him to learn that my code would probably outperform his when compiled
19:25:43 <ddarius> gwern: Nothing.
19:25:43 <Excedrin> is using the FFI to call primegen an acceptable Haskell solution?
19:25:45 <Saizan> is there a way to do foo :: Foo -> Bar\n $(<splice that declares a function foo>)? right now i get a Not in scope: foo error
19:26:03 <dons> well, if its very gmp heavy, ghci won't have much effect, but if it spends much time in haskell, you could get a big improvement by compiling
19:26:10 <ddarius> Excedrin: Does primegen return a stream?
19:27:52 <ddarius> Saizan: Move the type annotation into the splice?
19:27:52 <Saizan> ddarius: ugly :\
19:27:53 <Excedrin> ddarius: you call init, then next repeatedly... does that count?
19:28:00 <ddarius> Excedrin: If it can produce a stream, then yes.
19:28:15 <Excedrin> I'm not sure if that's a stream or not
19:28:24 <jfredett> it would count
19:28:35 <jfredett> we defined a stream as an effectively infinite list of numbers
19:28:56 <Excedrin> 50847534 primes up to 1000000000.
19:28:57 <Excedrin> Overall seconds: approximately 1.740579.
19:29:00 <oerjan> Saizan: what kind of splice?
19:29:15 <jfredett> that is, it would produce more numbers than could possibly be stored in memory at any given point-
19:29:19 <Saizan> oerjan:  Q [Dec]
19:29:45 <jfredett> so he (or I) couldn't just fill a big array with primes and then spit them out
19:29:51 <jfredett> to make it "look" infinite
19:30:02 <jfredett> and there were no libraries allowed.
19:30:46 <oerjan> Saizan: is it one of those metaprogramming things? in which case it is out of my league.
19:30:46 <jfredett> just the equivalents of the builtin functions of C
19:31:17 <Saizan> how did it managed to have arbitrarily large integers in C without libs?
19:31:22 <Saizan> oerjan: yup, TH
19:31:42 <dons> you'd have to use gmp no?
19:31:45 <jfredett> I let that one by
19:31:51 <jfredett> for him
19:31:54 <dons> ah . that's critical though :-)
19:32:02 <jfredett> because Integer is arbitrary
19:32:13 <jfredett> like I said, dons, I didn't want to crush him
19:32:26 <jfredett> just inform him that Haskell can contend with C
19:32:33 <dons> yeah. its an interesting experiment.
19:32:53 <dons> so was there a (language) generation gap? :-)
19:33:00 <jfredett> he was arguing that functional languages are pointless
19:33:01 <Saizan> well haskell is using gmp too, so you have just been fair :)
19:33:29 <chessguy> ermm, don't you mean ghc is using gmp?
19:33:43 <chessguy> or do other implmentations too
19:33:45 <dons> jfredett: nice, you batled on C's home territory too. not even say, parallel solutions or some such
19:33:46 <Excedrin> haskell == ghc
19:33:57 <dons> hugs doesn't use gmp.
19:34:00 <jfredett> dons: that was the goal.
19:34:08 <desp> speaking of C
19:34:15 <desp> is there anything like select(2) in Haskell?
19:34:24 <sorear> jfredett: but nubBy(((>1).).gcd)[2..] IS pointless!
19:34:26 <sorear> desp: Yes.
19:34:28 <jfredett> we're having another contest-- All of Project Euler
19:34:31 <dons> Iron Coder Fuctional -- jfredett  -- arise!
19:34:36 <sorear> desp: Control.Concurrent.forkIO
19:34:42 <jfredett> dons: LoL..
19:34:47 <desp> sorear: heh
19:34:54 <dons> desp, literally.
19:35:04 <jfredett> he's gotta catch up- I've got 12% finished
19:35:11 <jfredett> same grading criteria
19:35:17 <Moozilla> Alright I have this, is there a way I can get rid of the function? seems like there should be
19:35:19 <Moozilla> listfilter (f 7) [1..100] where f x y = mod y x == 0
19:35:22 <desp> dons: what do you mean/
19:35:29 <Moozilla> oops
19:35:30 <desp> s,/,?,
19:35:40 <sorear> desp: seriously, there is no binding to select because it interacts badly with the RTS, which uses select to schedule threads
19:35:40 <dons> forkIO is a layer over select
19:35:54 <desp> I see.
19:35:59 <timthelion> is there a ternery operator in haskell? evidently I can't do "2 if true then -2 else + 0" to check a condition on whether to subtract 2
19:36:04 <dons> threadWaitRead,		-- :: Int -> IO ()
19:36:17 <sorear> timthelion: sure
19:36:19 <dons> timthelion: if-then-else is a ternary expression
19:36:20 <Saizan> Moozilla: liftfilter ((==0) . mod 7) [1..100]
19:36:24 <jfredett> we have timthelion yes, its if then else
19:36:34 <jfredett> s/we have//
19:36:35 <sorear> (if True then subtract 2 else id) 2
19:36:35 <Saizan> Moozilla: liftfilter ((==0) . (`mod` 7)) [1..100]
19:36:38 <sorear> > (if True then subtract 2 else id) 2
19:36:39 <dons> 2 + (if x then 1 else -3))
19:36:40 <Excedrin> timthelion: if true then 0 else 2
19:36:41 <Moozilla> > filter ((==0) . mod 7) [1..100]
19:36:47 <lambdabot>  [1,7]
19:36:47 <lambdabot>  0
19:37:21 <Moozilla> > filter ((==0) . flip (mod 7)) [1..100]
19:37:22 <lambdabot>   add an instance declaration for (Integral (a -> c))
19:37:29 <desp> sorear, dons: would calling select from a bound thread be frowned upon by the RTS?
19:37:30 <Moozilla> that's what I meant to ask
19:37:57 <Moozilla> > filter ((==0) . (flip mod) 7) [1..100]
19:37:59 <lambdabot>  [7,14,21,28,35,42,49,56,63,70,77,84,91,98]
19:38:06 <Moozilla> oh :P
19:38:10 <LoganCapaldo> @hoogle ready
19:38:11 <lambdabot> IO.hReady :: Handle -> IO Bool
19:38:11 <lambdabot> Foreign.C.Error.eALREADY :: Errno
19:38:11 <lambdabot> IO.isAlreadyExistsError :: IOError -> Bool
19:38:30 <LoganCapaldo> @hoogle hwait
19:38:31 <lambdabot> IO.hWaitForInput :: Handle -> Int -> IO Bool
19:39:14 <sorear> desp: Yes.
19:39:17 <LoganCapaldo> desp: so if you don't need to do more than one handle at a time, hWaitForInput and hReady cover the :checking for stuff to read" aspects
19:39:24 <hpaste>  Gwern annotated "A bot for archiving external links on Wikipedia" with "Update archive-bot" at http://hpaste.org/334#a1
19:39:26 <sorear> desp: It would *work*, but it would be massively inefficient
19:39:43 <sorear> desp: why could you possibly want to do such a thing?
19:39:58 <desp> sorear: interacting with libcurl
19:40:02 <desp> LoganCapaldo: thanks for the pointer
19:40:17 <sorear> desp: curl requires select!?
19:40:58 <desp> sorear: no, but the asynchronous ("multi") interface to libcurl can be used from a single thread, using select
19:41:15 <desp> but not necessarily select
19:41:30 <sorear> desp: why can't you just use forkIO?
19:42:03 <desp> sorear: forkIO creates a new Haskell thread, which isn't guaranteed to execute in a given OS thread
19:42:22 <sorear> desp: And you care because...
19:42:26 <cdsmith> Anyone know a good approach for persistent transactional data structures in Haskell?
19:42:29 <desp> because libcurl cares
19:42:43 <desp> a sequence of operations on a libcurl handle needs to be made in the context of one thread
19:42:59 <sorear> desp: oh, then use a bound thread.  forkOS was designed for use with b0rken TLS-using libraries
19:43:13 <sorear> desp: specifically opengl, but libcurl should be usable too
19:43:14 <Excedrin> cdsmith: maybe MACID ?
19:43:16 <desp> yes, I am, but I don't think that spawning tons of bound threads would be a good idea
19:43:34 <Excedrin> cdsmith: http://happs.org/auto/apidoc/HAppS-MACID.html
19:43:45 <cdsmith> Excedrin: I looked, but can't find much documentation about using that.
19:43:57 <sorear> desp: bound threads are allocated from a pool, so it only matters if you have a lot running simultaneously
19:44:23 <desp> I would prefer not to restrict the users of the package as to the number of simultaneous transfers
19:45:24 <sorear> desp: then *grumble* you really do need select-like functionality.
19:45:26 * sorear codes!
19:45:30 <desp> :)
19:45:46 <desp> thanks for validating my choice
19:46:58 <sjanssen> libcurl *requires* using the same thread?
19:47:46 <desp> sjanssen: "The first basic rule is that you must never share a libcurl handle (be it easy or multi or whatever) between multiple threads."
19:47:59 <LoganCapaldo> this is too complicated. just shell out to the curl executable :)
19:49:08 <jfredett> .. can (.) be derived in terms of ($)? or vice versa?
19:49:14 <LoganCapaldo> So is the problem that a given forkIO thread won't necessarily execute in the same OS thread all the time?
19:49:15 <sorear> @src (.)
19:49:16 <lambdabot> (.) f g x = f (g x)
19:49:19 <sorear> @src ($)
19:49:20 <lambdabot> f $ x = f x
19:49:25 <sorear> LoganCapaldo: yeah
19:49:34 <desp> LoganCapaldo: no, that's not a problem thanks to bound threads (forkOS)
19:49:55 * LoganCapaldo is getting conflicting messages
19:50:02 <sjanssen> desp: "Only use one handle in one thread at a time."?
19:50:16 <sjanssen> that seems to conflict
19:50:34 <desp> sjanssen: with what?
19:50:50 <jfredett> sorear: I meant more along the lines of logic, ie
19:50:50 <jfredett> (.) :: (b->c) -> (a->b) -> a -> c
19:50:50 <jfredett> ($) :: (a->b) -> a -> b
19:50:55 <sjanssen> ie. we don't know whether a handle must belong to only one thread, or that accesses must be serialized
19:50:55 <hpaste>  sorear pasted "for desp" at http://hpaste.org/335
19:51:11 <chessguy> so i was joking with someone today that all languages were the same because they're all turing complete. his response was "not all languages are". my answer? "i bet you can't name one that's not!" he ceded that point, but can any of you name one?
19:51:12 <ddarius> ($) = id
19:51:15 <jfredett> they look so similar -- type wise.
19:51:21 <jfredett> hmm
19:51:23 <sorear> chessguy: C
19:51:29 <desp> sjanssen: I verified with the curl guys that the problem is that curl keeps thread-local state
19:51:36 <desp> sjanssen: so, only one thread per handle
19:51:37 <sjanssen> desp: ah, okay
19:51:39 <chessguy> sorear, seriously?
19:51:41 <oerjan> Smetana :)
19:51:41 <sorear> chessguy: really.
19:51:45 <sjanssen> desp: that blows :/
19:51:47 <desp> sorear: thanks, looking
19:52:07 <chessguy> hmm, i find that hard to believe. can you cite a source?
19:52:10 <desp> sjanssen: well, that's not really a problem, since it should be possible to use one thread only for all curl interaction
19:52:20 <sorear> chessguy: no, but I can cite a proof
19:52:29 <ddarius> SQL
19:52:30 * chessguy listens
19:52:42 <LoganCapaldo> SQL is a much better answer :)
19:52:56 <sorear> chessguy: C forces implementations to document a limit on the number of bits in an adress, which means that any given implementation must have finite memory; ergo it is impossible to represent the unbounded number of states in a turing machine
19:52:57 <jfredett> chessguy: SQL
19:53:03 <sjanssen> is English Turing-complete?
19:53:18 * LoganCapaldo really hopes that sorear's proof doesn't amount to "C can't address infinit memory"
19:53:20 <LoganCapaldo> nvm
19:53:24 <desp> sorear: hah
19:53:47 <mauke> sorear: I don't need infinite memory, I can just use temporary files
19:53:53 <sorear> LoganCapaldo: Technicalities are the bread and butter of formal mathematics.
19:54:19 <ddarius> Of -formal- mathematics.
19:54:32 <mlh> if the universe is finite, I guess there ain't no such thing as a Turing machine
19:54:34 <sjanssen> sorear: your filesystem has limits
19:54:43 * jfredett says like Agent Smith: "How will temporary files help you... if you cannot speak?"
19:54:55 <sorear> mauke: You have finite disk too.  Remember, FPOSMAX bytes in each of CHAR_MAX^INTPTR_MAX files
19:54:56 * desp sets mode +m
19:55:07 <jfredett> mlh: sure there is -- it exists in the mind of whoever needs a real turing machine
19:55:16 <syntaxfree> so, um, I'm thinking of using bytestrings to solve the following problem, which is trivial using [Char].
19:55:21 <jfredett> all practical math is approximation of whats in our brains
19:55:32 <mlh> jfredett: prove it :-)
19:55:40 <syntaxfree> I have a file with about 120 thousand lines of maybe 6000 characters each.
19:55:41 <mauke> sorear: what is FPOSMAX?
19:56:03 <sorear> mauke: A made up value representing the maximum fpos_t :)
19:56:03 <mlh> return -EBRAINFULL
19:56:03 <jfredett> prove what? that a turing machine can exist in my imagination?
19:56:05 <Moozilla> this is probably a dumb question, but how can I take a list of lists and turn it into one big list, I tried map (++)
19:56:06 <syntaxfree> I want to select a few columns, inputted from a list like [(l1, l2), (l3, l4), (l5, l6)]
19:56:10 <mauke> sorear: oh, not all files are seekable
19:56:10 <jfredett> mlh: well...
19:56:15 <jfredett> imagine a tape
19:56:17 <syntaxfree> the list can be hardcoded.
19:56:19 <chessguy> @src concat
19:56:20 <lambdabot> concat = foldr (++) []
19:56:20 <jfredett> a REALLY REALLY Long tape
19:56:24 <syntaxfree> Should that prove significantly harder than using [Char]?
19:56:28 <sorear> mauke: hmm.  are all files tellable?
19:56:31 <LoganCapaldo> sorear: err couldn't you have files that contained filenames of other files though?
19:56:38 <sorear> LoganCapaldo: Sure.
19:56:39 <Moozilla> chessguy: thanks
19:56:44 <syntaxfree> Is there much more to learn? Would bytestrings be significantly faster than [Char] for a ~300MB file?
19:56:45 <mauke> sorear: I don't think so
19:56:45 <sorear> LoganCapaldo: which helps you... how?
19:57:03 <sorear> syntaxfree: Vastly.
19:57:07 <sjanssen> syntaxfree: almost certainly
19:57:10 <jfredett> mlh an infinitely long tape. Now imagine a turing machine. the tape is indexed by the Naturals, lets say
19:57:12 <mlh> whats the blah  / chat channel caleld again?
19:57:13 <sorear> syntaxfree: 300B is the cutoff apprx.
19:57:23 <chessguy> @topic-tell #haskell-blah
19:57:24 <lambdabot> Anything BUT Haskell (even SEX!) -|- add yourself to the collection -> http://www.elis.ugent.be/~kehoste/haskell-blahSouthPark.html -|- lambdabot's first words: "Ooh, functional programmers are so
19:57:24 <lambdabot> hot" -|- current topic: "They say "Jump!", you say "How high?" (Rage Against The Machine)"
19:57:25 <jfredett> mlh haskell-blah
19:57:27 <LoganCapaldo> sorear: infinite levels of indirection
19:57:30 <syntaxfree> sorear: should it prove much harder if I've never done any bytestring stuff?
19:57:35 <mlh> maybe we should take it there
19:57:56 <sorear> LoganCapaldo: No such help - you only have finitely many loadable filenames...
19:58:06 <syntaxfree> is there a bytestring tutorial for [Char] users? :D
19:58:17 <sjanssen> @docs Data.ByteString
19:58:17 <lambdabot> Data.ByteString not available
19:58:22 <LoganCapaldo> you don't need to load all teh files at once though
19:58:23 <int-e> syntaxfree: depends on what you're doing really.
19:58:30 <gwern> Moozilla: concat?
19:58:34 <syntaxfree> I was thinking of going by the haddock docs, really.
19:58:39 <chessguy> @where bytestring
19:58:40 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
19:58:41 <syntaxfree> int-e: I've just stated my problem :)
19:58:42 <dolio> The simply typed lambda calculus isn't Turing complete, is it?
19:58:45 <LoganCapaldo> you can close them behind you
19:58:47 <int-e> syntaxfree: if you do a lot of pattern matching then bytestrings are probably a bit painful :)
19:59:00 <syntaxfree> I have a file with about 120 thousand lines of maybe 6000 characters each.
19:59:03 <syntaxfree> I want to select a few columns, inputted from a list like [(l1, l2), (l3, l4), (l5, l6)]
19:59:15 <sorear> syntaxfree: stop
19:59:20 <oerjan> dolio: no, all terms normalize
19:59:21 <sorear> syntaxfree: don't reinvent the wheel
19:59:22 <ddarius> dolio: Not without some primitives.
19:59:24 <sorear> syntaxfree: man 1 cut
19:59:32 <dolio> ddarius: Right.
19:59:39 <syntaxfree> uhh. there's a unix tool for that?
19:59:47 <sorear> Yup.
19:59:49 <aeyakovenko> has anyone ever used the crypto library?
19:59:54 <syntaxfree> heh.
19:59:57 <syntaxfree> the unix people were smart.
20:00:01 <int-e> syntaxfree: sounds like you can get away with breaking lines on ',' and selecting some columns?
20:00:07 <aeyakovenko> for some reason i am getting around 2 seconds for a sha1 sum for 256k
20:00:12 <LoganCapaldo> sorear: have a C program display some text on the screen telling the user to swap out the disk
20:00:14 <syntaxfree> int-e: huh?
20:00:20 <LoganCapaldo> when it hits the end of the disk
20:00:39 <sorear> LoganCapaldo: disks are round
20:00:39 <LoganCapaldo> C becomes turing complete w/ human intervention
20:01:02 <dylan> unless you have infinite disks, that will fail eventually
20:01:07 <syntaxfree> oh. cut even uses field delimiters.
20:01:13 <syntaxfree> the problem is, i have fixed-width columns.
20:01:17 <LoganCapaldo> dylan: facotires can keep producing disks :)
20:01:20 <syntaxfree> and, no, excel ain't gonna cut it for this humongous file size.
20:01:30 <sorear> syntaxfree: cut can use any combination of delimiters and columns
20:01:35 <int-e> syntaxfree: oh that's easy then. just use take/drop :)
20:01:42 <sorear> syntaxfree: look at -b and -c
20:01:48 <dylan> syntaxfree: awk can do field sizes
20:01:50 <int-e> syntaxfree: or cut -b
20:01:55 <syntaxfree> heh. is cut turing-complete? :D
20:01:58 <LoganCapaldo> dylan: also by that logic we're back to _no_ programming languages are turing complete and C isn't especially crippled compared to anything else
20:02:14 <ddarius> LoganCapaldo: Congratulations.
20:02:23 <dylan> I didn't think turing complete == turing machine
20:02:42 <syntaxfree> gah. i hate man pages.
20:02:44 <syntaxfree> way too obscure.
20:02:45 <LoganCapaldo> well isn't a turing machine turing complete?
20:02:49 <dylan> syntaxfree: only on linux.
20:03:06 <dylan> I thought turing complete == finite turing machine.
20:03:06 <ddarius> LoganCapaldo: Yes, and when you find one you're set.
20:03:09 <syntaxfree> I have a BSD userland, I think.
20:03:12 <LoganCapaldo> if so, if you can build a turing machine out of it its turing complete
20:03:20 <timthelion> LoganCapaldo: just because a bird can breath, doesn't mean you have to be a bird to breath
20:03:20 <syntaxfree> the man page tells me it's a BSD cut.
20:03:29 <LoganCapaldo> timthelion: for sure
20:03:50 <ddarius> LoganCapaldo: Good luck find Turing machine building machines.
20:03:52 <LoganCapaldo> but if its easier to transform into a bird then to learn to breathe
20:04:12 <syntaxfree> I don't know how to specify lists for cut.
20:04:16 <syntaxfree> Maybe I should ask #cut or something.
20:04:24 <desp> sorear: parIO parallelizes a list of IO actions, right? (this might be a silly question, but it's 5 AM and I'll better double check)
20:04:27 <desp> argh
20:05:19 <LoganCapaldo> ddarius: I'm sensing your irritated by this conversation. I'll stop
20:05:49 <LoganCapaldo> s/your/you're/
20:05:51 <ddarius> LoganCapaldo: I'm not.
20:06:15 <ddarius> Our current understanding of physics suggests that Turing machines don't exist.
20:06:55 <SamB> does it preclude their existance, or merely predict that the tape would be highly likely to find it's way into a nearby star?
20:07:03 <LoganCapaldo> lol
20:07:13 <ddarius> Why would we want the tape in a star?
20:07:15 <LoganCapaldo> oops, the tape slipped into a star again!
20:07:21 <SamB> ddarius: well, we wouldn't
20:07:22 <desp> @hoogle threadWaitRead
20:07:23 <lambdabot> Control.Concurrent.threadWaitRead :: Fd -> IO ()
20:07:31 <dylan> What if the M-branes are turing tapes?
20:07:34 <SamB> but the star has a lot of gravitational attraction...
20:07:53 * jfredett hides from the string theory
20:07:57 <syntaxfree> Teach dumb matter to do the Turing boogie!
20:08:04 <dolio> LoganCapaldo: If sorear's argument revolves around C enforcing a maximum ammount of addressable memory, that wouldn't necessarily disqualify all languages, since not all would have such a restriction.
20:08:05 <ddarius> jfredett: They call it M-theory now.
20:08:11 <desp> LoganCapaldo: could you repeat the two function names you wanted me to look at? I got distracted and they scrolled out of my history
20:08:12 <jfredett> oy
20:08:16 <syntaxfree> Charles Stross's "Accelerando" talks about "MIPS per milligram" all the time.
20:08:25 <LoganCapaldo> desp: hReady and hWaitForInput
20:08:32 <desp> LoganCapaldo: thanks
20:08:47 <jfredett> QT gives me enough of a headache
20:08:58 <desp> syntaxfree: fairly nice book
20:09:06 <ddarius> jfredett: Use Gtk then.
20:09:17 * jfredett moan.
20:09:26 <jfredett> that was cheap, ddarius
20:09:31 <jfredett> clever as fuck
20:09:34 <jfredett> but cheap
20:09:53 <ddarius> I'll agree with the cheap.
20:12:36 <LoganCapaldo> dolio: yes...
20:13:33 <syntaxfree> I guess I still win by writing Haskell.
20:13:44 <syntaxfree> I not only want to cut fields, I want to intersperse them with spaces.
20:13:58 <hpaste>  int-e pasted "for syntaxfree - I wonder how well this does?" at http://hpaste.org/336
20:14:00 <dylan> or using awk
20:14:24 <SamB> what's a good paper about fusion for people who don't actually know Haskell...?
20:14:57 <ddarius> SamB: Do they know category theory?
20:15:01 <SamB> actually, someone asked me for an example of where a compiler can optimize better if it has some understanding of a datastructure, instead of just having C code...
20:15:09 <SamB> ddarius: no...
20:15:19 <ddarius> Darn
20:15:20 <syntaxfree> I wish these large datasets were available in SQL format.
20:15:31 <syntaxfree> Instead, they give us humongous, fixed-size field, no delimiter text files.
20:15:36 <syntaxfree> Often 3 or 4 GB.
20:15:42 <syntaxfree> and I just need a few columns!
20:15:43 <dons> SamB: hmm.
20:15:58 <dons> you really really want to have domain specific knowledge in the optimiser
20:16:05 <dons> hence we have rewrite rules and TH.
20:16:13 <dons> since there are domain-specific optimsiations that just aren't generally good
20:16:17 <syntaxfree> int-e: hey, cool. but hwat is [input, output]?
20:16:22 <dons> but are maybe killer for a particular data structure
20:16:30 <syntaxfree> ah, output file.
20:16:32 <syntaxfree> doublepluscool!
20:16:45 <SamB> <Nach> SamB: I was wondering if you can think of an example of a data structure or high level construct that a compiler could optimize better if it understood it well, as opposed to just seeing a breakdown of it into simple C
20:16:52 <SamB> from #zsnes
20:16:53 <dylan> syntaxfree: cut --output-delimiter=" " -b 1-5,7-10
20:16:56 <syntaxfree> int-e++
20:17:00 <syntaxfree> int-e++
20:17:20 <syntaxfree> int-e++
20:17:23 <syntaxfree> dylan++
20:17:34 <int-e> @karma
20:17:34 <lambdabot> You have a karma of 33
20:17:36 <ddarius> I can't see breaking it down into simple C making it easier to optimize...
20:18:14 <SamB> this question actually has nothing much to do with Haskell...
20:18:22 <syntaxfree> --output-delimiter doesn't seem to work.
20:18:29 * syntaxfree goes with int-e's code.
20:18:32 <syntaxfree> dylan--
20:18:33 <dylan> you must have bsd cut.
20:18:35 <syntaxfree> :P
20:18:39 <syntaxfree> yes, I have bsd cut.
20:18:44 <dylan> bsd has better manpages and worse programs.
20:18:44 <SamB> ... 'tis the answer that I think is more related
20:18:57 <int-e> @type Data.ByteString.Lazy.Char8.join
20:19:00 <lambdabot> Data.ByteString.Lazy.ByteString -> [Data.ByteString.Lazy.ByteString] -> Data.ByteString.Lazy.ByteString
20:19:38 <dylan> @karma dylan
20:19:39 <lambdabot> You have a karma of 5
20:21:40 <int-e> syntaxfree: you can use L.unwords to interleave the fields with spaces.
20:22:36 <LoganCapaldo> sorear: You allow files right? I can write a C program to write a Haskell program and feed it thru ghc with system, which is in the C standard :)
20:22:45 <LoganCapaldo> (system, not ghc)
20:24:58 <haskell-newbie> I am new to haskell (In fact I am trying to write my 2nd program in haskell) -> can some one help me understand why I am getting a "parse error -> foo.hs:4:11: parse error on input `:'  " ->  http://hpaste.org/337
20:24:59 <syntaxfree> int-e: thanks!
20:25:46 <syntaxfree> int-e: hmm. what is the bytestring equivalent of (++)?
20:25:54 <dons> `append`
20:25:57 <dons> or concat
20:26:06 <int-e> syntaxfree: append.
20:26:16 <syntaxfree> int-e: thanks. But unwords will do :)
20:27:54 <syntaxfree> is GHC.Int.Int64 an instance of Integral?
20:27:59 <syntaxfree> @info GHC.Int.Int64
20:27:59 <lambdabot> GHC.Int.Int64
20:28:04 <syntaxfree> @instances Integral
20:28:06 <lambdabot> Int, Integer
20:28:23 <dolio> @instances-importing GHC.Int Integral
20:28:24 <lambdabot> Int, Int16, Int32, Int64, Int8, Integer
20:28:37 <int-e> use Data.Int please
20:29:08 <dolio> haskell-newbie: Which line is line 4 in your actual file?
20:29:13 <LoganCapaldo> haskell-newbie: your layout is wrong
20:29:26 <LoganCapaldo> the f1 has to be lined up under the f1
20:29:30 <haskell-newbie> oh
20:29:42 <syntaxfree> a tiny variation of your code is giving me type errors.
20:29:48 <haskell-newbie> dolio: f1(x1:x2:xs) = x1 + x2 + f1(x2:xs)
20:29:49 <notsmack> "testST :: ST s Integer" -- what's the 's'?
20:29:55 <int-e> haskell-newbie: set your editor to use tab width 8 or no tabs at all
20:29:57 <syntaxfree> cols = [(3,5)] infers to [(Integer, Integer)]
20:30:06 <haskell-newbie> thanks !
20:30:07 <syntaxfree> so I try to explictly make it (Integral a) => [(a,a)]
20:30:08 * haskell-newbie tries
20:30:16 <syntaxfree> but still,    Couldn't match expected type `[(a, a)] -> [L.ByteString]' against inferred type `[[(Int64, Int64)] -> L.ByteString]'
20:30:33 <LoganCapaldo> it thinks you wrote f1 :: [Float] -> Float f1 (x1: ...
20:30:49 <syntaxfree> oh, nevermind, I got the brackets wrong.
20:30:52 <syntaxfree> it's not an int issue.
20:31:33 <hpaste>  LoganCapaldo annotated "newbie-breaking-compile" with "like this" at http://hpaste.org/337#a1
20:31:39 <LoganCapaldo> arg
20:31:43 <LoganCapaldo> stupid tabs
20:31:46 <LoganCapaldo> not like that
20:32:01 * LoganCapaldo requests a preview button
20:32:08 <syntaxfree> fixed.
20:32:43 <int-e> haskell-newbie: btw it's a bit unusual to indent the top level declarations of a module (despite the 'where' after 'module Test (f) where', you are allowed to start the module's declarations in the first column)
20:33:21 <syntaxfree> OH. THAT IS BLINDINGLY FAST.
20:33:25 <syntaxfree> int-e: man, that is fast.
20:33:32 <LoganCapaldo> @where hpaste
20:33:33 <lambdabot> I know nothing about hpaste.
20:33:50 <mauke> @where paste
20:33:50 <lambdabot> http://paste.lisp.org/new/haskell
20:33:54 <mauke> :(
20:33:58 <sjanssen> wha?
20:33:59 <dolio> @paste
20:34:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
20:34:03 <chowmeined> yay
20:34:04 <sjanssen> stupid state flushes
20:34:17 <sjanssen> @where+ paste http://hpaste.org/new
20:34:17 <lambdabot> Done.
20:34:19 <sjanssen> @flush
20:34:27 <int-e> syntaxfree: you can thank dons and dcoutts for that :)
20:34:35 <LoganCapaldo> I was actually looking for darcs get http://www.scannedinavian.com/~eric/hpaste/
20:34:38 <LoganCapaldo> :)
20:35:06 <int-e> syntaxfree: and of course the ghc compiler writers
20:35:13 <syntaxfree> dons++
20:35:15 <syntaxfree> dcoutts++
20:35:20 <syntaxfree> dons++
20:35:21 <syntaxfree> dcoutts++
20:36:25 <sjanssen> we've set 'where paste' to hpaste no fewer than 6 times
20:38:48 <haskell-newbie> LoganCapaldo int-e dolio Thanks!
20:39:03 <haskell-newbie> it worked after I changed my tabs to spaces :)
20:39:51 <sjanssen> hpaste should show tabs in an ugly yellow
20:41:24 <kfish> is there  a web-based online haskell interpreter somewhere?
20:41:39 <mwc> kfish: there's IRC-based lambdabot ;)
20:41:45 <kfish> sure
20:42:01 <kfish> i'm after something simple, restricted-IO is fine, to use to teach an introductory class ...
20:42:06 <haskell-newbie> LoganCapaldo++   int-e++
20:42:09 <haskell-newbie> :)
20:42:12 <SamB> kfish: hugs?
20:42:31 <syntaxfree> int-e: hey. I learned a whole lot about bytestrings.
20:43:08 <kfish> i remember there was a web-based lambdabot somewhere for example ...
20:43:15 <jfredett> (solved my question from earlier) hah -- ($) == (id .)
20:43:30 <kfish> got it, http://lambdabot.codersbase.com/
20:43:32 <lambdabot> Title: Lambdabot Web Interface
20:43:35 <mauke> hmm?
20:43:40 <mauke> (id .) == id
20:43:46 <int-e> jfredett: I missed the question, but what's wrong with ($) = id?
20:43:54 <notsmack> who handles the ghc docs?
20:43:54 <jfredett> well, equivalent...
20:44:09 <LoganCapaldo> > (+1) `id` 2
20:44:10 <lambdabot>  3
20:44:15 <LoganCapaldo> > (+1) $ 2
20:44:17 <lambdabot>  3
20:44:22 <kfish> d'on, that lambdabot is asleep :-(
20:44:51 <notsmack> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-ST.html#t%3ASTUArray -- trivial, but "s i a" should be "s i e"
20:44:53 <lambdabot> http://tinyurl.com/2yczgp
20:45:13 <jfredett> I was just curious as to if (.) and ($) were related. and I wasn't willing to believe that ($) == id, so I figured I'd give it a shot
20:45:17 <int-e> kfish: you can play around with lambdabot in a query if you don't want to spam the channel.
20:45:44 <kfish> int-e, it's not for me, just preparing for a class i'm teaching tomorrow
20:59:24 <brainly-green> are there languages/compilers that use dynamic typing, but also have static optimizations to infer most types at compile-time?
21:00:03 <SamB> CMUCL has a compiler called Python that can do some of that
21:00:26 <SamB> I expect other CL implementations are similar...
21:02:01 <syntaxfree> Hmm. Are you saying Python qualifies as a Lisp or something?
21:02:21 <SamB> no.
21:02:31 <SamB> CMUCL's compiler is very confusingly named
21:02:54 <SamB> ... not that python is not a lisp.
21:03:06 <SamB> but that's totally irrelevant to what I was saying
21:03:13 <dylan> dons: ping.
21:04:09 <brainly-green> or even dynamic typing, with type declarations as debugging assertions
21:04:26 <brainly-green> caught at runtime
21:05:57 <Korollary> I think chicken scheme also infers types for optimization.
21:07:18 <pjd> brainly-green: does PyPy count?
21:08:29 <brainly-green> you could view the untyped lambda calculus as fundamental, and a statically typed program as a dynamically typed program whose interpreter knows how to optimize away every dynamic type prior to accepting input
21:11:26 <dylan> @ask dons can you offer a pointer to setting up blosxom to look "pretty"?
21:11:27 <lambdabot> Consider it noted.
21:29:33 <syntaxfree> isn't Stalin a famous optimizing scheme compiler?
21:29:41 <syntaxfree> I always hear it's not for production though. Why?
21:45:40 <dcoutts> syntaxfree: maybe people find whole program compilation does not scale
21:46:53 <brainly-green> maybe it's because it's only compatible with a subset of R5RS
21:48:43 <brainly-green> the wikipedia page says it is intended for "production use," if that can be trusted
21:54:40 * edwardk waves hello.
21:57:33 * LoganCapaldo chases dependencies
21:59:11 <Heffalump> be careful, they bite when they're cornered
21:59:17 * edwardk spots one, and trips it, trying to help LoganCapaldo catch up
21:59:30 <LoganCapaldo> I'm almost there
21:59:34 <LoganCapaldo> building HAppS
21:59:42 <LoganCapaldo> (so I can build HPaste)
22:05:14 <dons> challenge, anyone got a more concise way to get a 0-padded hex string from a  Ptr Word8:
22:05:15 <lambdabot> dons: You have 12 new messages. '/msg lambdabot @messages' to read them.
22:05:18 <dons>     go p n acc
22:05:20 <dons>         | n >= 16   = return $ concat (reverse acc)
22:05:23 <dons>         | otherwise = do w <- peekElemOff p n
22:05:26 <dons>                          go p (n+1) (draw w : acc)
22:05:28 <dons>     draw w = case showHex w [] of
22:05:30 <dons>                 [x] -> ['0', x]
22:05:33 <dons>                 x   -> x
22:05:34 <dons> showHex isn't immediately useful, since it doesn't 0 pad.
22:06:32 <sjanssen> dons: padded how many places?
22:06:57 <dons> one, its for and md5 cksum. so '0e' for example, or 'a2'
22:07:03 <dons> s/for an/
22:07:12 <dons>     draw w = case showHex w [] of
22:07:12 <dons>                 [x] -> ['0', x]
22:07:12 <dons>                 x   -> x
22:07:15 <Heffalump> dons: you can make it more concise by decreasing the indentation ;-)
22:07:23 <dons> hah
22:07:42 <dons> its a monadic map, of course. so maybe a sequenced' list comprehension over the ptr indicies
22:09:10 <Heffalump> is it too cache inefficient to walk through the Ptr backwards to save the reverse?
22:09:12 <sjanssen> major overkill: draw w = reverse $ zipWith const ((reverse $ showHex w []) ++ repeat '0') [(), ()]
22:09:51 <Heffalump> and if you also change the case in draw to be over the value of w (<16 or not), you can use the accumulating parameter to showHex
22:10:04 <dons> its a md5 sum, so its a fixed 16 byte buffer
22:10:07 <Heffalump> oh, wait, I see, you need to reverse the pairs
22:10:10 <Heffalump> never mind
22:10:15 <dons> yes, the pairs end up the wrong way
22:10:16 <sjanssen> @type \w -> reverse $ zipWith const ((reverse $ showHex w []) ++ repeat '0') [(), ()] -- fingers crossed
22:10:24 <lambdabot> forall a. (Integral a) => a -> [Char]
22:10:25 <dons> its a pity to use showHex x []
22:10:42 <lispy> haskell programmers are destroying the planet with their deforestation
22:11:06 <LoganCapaldo> but it's happening slowly because they are so lazy
22:11:44 <sjanssen> @hoogle digitToChar
22:11:44 <lambdabot> No matches found
22:11:58 <sjanssen> hmm
22:12:43 <dons>     liftM concat $ forM [0..15] $ \n -> do
22:12:43 <dons>                         w <- peekElemOff digest n
22:12:43 <dons>                         return $ case showHex w [] of [x] -> ['0', x]; x -> x
22:12:45 <sjanssen> ah, intToDigit
22:13:21 <LoganCapaldo> @type \d -> toEnum $ fromEnum d + fromEnum '0'
22:13:23 <lambdabot> forall a a1. (Enum a, Enum a1) => a1 -> a
22:13:31 <LoganCapaldo> err
22:13:36 <sjanssen> @type \w -> intToDigit (w `div` 16) : intToDigit (w `mod` 16) : []
22:13:38 <lambdabot> Int -> [Char]
22:13:48 <dons> mm
22:13:48 <LoganCapaldo> that's not quite what I expected..
22:13:56 <sjanssen> @pl \w -> intToDigit (w `div` 16) : intToDigit (w `mod` 16) : []
22:13:57 <lambdabot> ap ((:) . intToDigit . (`div` 16)) (return . intToDigit . (`mod` 16))
22:14:09 <hpaste>  dons pasted "fast bytestring md5" at http://hpaste.org/338
22:14:10 <sjanssen> hmm, there is something fancy here with quotRem
22:14:17 <dons> the full code is there ^^
22:14:20 <LoganCapaldo> @type (\d -> toEnum $ d + fromEnum '0')
22:14:21 <lambdabot> forall a. (Enum a) => Int -> a
22:14:33 <LoganCapaldo> @type (\d -> toEnum $ d + fromEnum '0') 3
22:14:34 <lambdabot> forall a. (Enum a) => a
22:14:41 <dons> can I just say that the haskell ffi is nice
22:14:43 <LoganCapaldo> > (\d -> toEnum $ d + fromEnum '0') 3
22:14:44 <lambdabot>  51
22:14:45 <dcoutts> dons: but that's cheating, calling openssl ;-)
22:15:05 <LoganCapaldo> > (\d -> toEnum $ d + fromEnum '0') 3 :: Char
22:15:06 <lambdabot>  '3'
22:15:10 <dons> 'crypto' only supports md5 :: [Word8]  :(
22:15:18 <dcoutts> dons: that latest binary email reminded me again that we need proper float support
22:15:23 <dons> yep
22:15:46 <dons> but the point of bytestrings originally was this :-)
22:15:53 <dons> zero-copy C lib calls
22:16:02 <sjanssen> @pl uncurry (\x y -> [intToDigit x, intToDigit y]) . flip quotRem 1
22:16:02 <dons> so its nice when that happens
22:16:02 <lambdabot> uncurry ((. (return . intToDigit)) . (:) . intToDigit) . flip quotRem 1
22:16:05 <syntaxfree> dons: wow, bytestrings are fast.
22:16:46 <dons> they got tuned up, yep.
22:17:15 <syntaxfree> and i have ghc 6.6 bytestrings. i wonder if they got even faster.
22:17:24 <syntaxfree> how do you even get haskell that fast? :)
22:17:35 <sjanssen> @pl \f x y -> [f x, f y]
22:17:35 <lambdabot> liftM2 flip (((.) . (:)) .) (flip flip [] . ((:) .))
22:17:43 <dons> its compiled to native code. you just talk sweetly to the compiler.
22:17:49 <sjanssen> @pl \x y -> [f x, f y]
22:17:49 <lambdabot> (. (return . f)) . (:) . f
22:17:50 <dons> yes, the unstable bytestring repo is faster.
22:18:37 <sjanssen> @pl \x y -> [x, y]
22:18:37 <lambdabot> (. return) . (:)
22:18:57 <dons> @pl \y -> [x,y]
22:18:58 <lambdabot> (x :) . return
22:21:28 <sjanssen> @pl \x y -> map intToDigit [x, y]
22:21:29 <lambdabot> (map intToDigit .) . (. return) . (:)
22:21:48 <cdsmith> @pl (-1)
22:21:48 <lambdabot> subtract 1
22:22:26 <sjanssen> @type uncurry ((map intToDigit .) . (. return) . (:)) . flip quotRem 16
22:22:28 <lambdabot> Int -> [Char]
22:23:50 <edwardk> wow, thats weird, compiling harpy on ghc-6.6.1 is nailing my cpu and not letting go.
22:24:20 * notsmack can't quite figure out 'while' in ST
22:27:50 <sjanssen> @type \test action -> mfix $ \again -> do continue <- test; when continue (action >> again)
22:27:52 <lambdabot>     Couldn't match expected type `m ()' against inferred type `()'
22:27:52 <lambdabot>       Expected type: m (m ())
22:28:19 <sjanssen> @type \test action -> fix $ \again -> do continue <- test; when continue (action >> again)
22:28:21 <lambdabot> forall (t :: * -> *) a. (Monad t) => t Bool -> t a -> t ()
22:34:52 * notsmack processes.
22:48:32 <notsmack> @type repeat
22:48:34 <lambdabot> forall a. a -> [a]
22:54:56 <purplepenguins> hello all
22:55:09 <purplepenguins> I need help understanding lambda calculus
22:55:21 <TRWBW> second that, anyone wanna give a quick tutorial?
22:55:26 <dons> hey, is anyone working on a bytestring openssl binding?
22:55:44 <dcoutts> dons: not so far as I know
22:55:54 <dons> ok. super quick tutorial. you have functions of one argument, and reduction, and that's it.
22:56:03 <purplepenguins> specifically, the syntax confuses me
22:56:12 <unknown> i tried to do some floating point calculations yesterday but i found that it is not as easy as i thought it would be
22:56:16 <LoganCapaldo> the syntax of all things?
22:56:17 <dons> dcoutts: did you know about http://cryp.to/hopenssl/
22:56:19 <lambdabot> Title: hOpenSSL
22:56:26 <TRWBW> dons: okay, functions over what space?
22:56:28 <purplepenguins> what does \lambda x x x . x mean?
22:56:35 <dons> TRWBW: function space :-)
22:56:39 <dons> its all functions.
22:56:40 <brainly-green> wikipedia's article on it was clear and informative the last time i looked at it
22:56:43 <dcoutts> dons: I think I did, but that doesn't use bs iirc
22:56:43 <LoganCapaldo> same thing as \x x x -> x
22:56:58 <dcoutts> anyway, bed time, g'night folks
22:56:59 <dons> \ x . x x is the functoin:    foo x = x(x) -- in other notation
22:57:04 <purplepenguins> I am looking at wiki's article but it doesn't help me, maybe I'm not reading it right
22:57:23 <brainly-green> \ x x x -> x doesn't make much sense to me
22:57:26 <TRWBW> so which function is 0?
22:57:31 <purplepenguins> what does -> mean?
22:57:36 <brainly-green> it means .
22:57:38 <purplepenguins> okay
22:57:44 <unknown> i want to determine something like 13/5 - floor(13/5) to determine how much a float is removed from the previous integer
22:57:49 <dons> \x -> e in Haskell declares an anonymous function, taking some argument 'x', and some function body 'e'
22:57:53 <brainly-green> I guess that \ x x x -> x would be the same as \ z y x -> x
22:57:56 <dons> in lambda calculus you write that as:   \x . e
22:58:03 <LoganCapaldo> TRWBW: zero is usually \f x -> x
22:58:12 <unknown> to later find a number with the smallest error
22:58:24 <unknown> how should i do that
22:58:29 <Syzygy-> unknown: let removedFromInteger (numerator,denominator) = (numerator `mod` denominator, denominator)
22:58:35 <LeCamarade> purplepenguins: \x y -> x * y is the same as let mul x y = x * y, only that you need no name for it, since you're going to use it right away, only once.
22:58:38 <LeCamarade> Observe:
22:58:48 <purplepenguins> I understood that
22:58:55 <LeCamarade> > (\x y -> x * y) 2 3
22:58:56 <lambdabot>  6
22:59:09 <unknown> Syzygy-: thank you, il;l try that
22:59:13 <TRWBW> would that mean 0 is \x x.x ?
22:59:17 <purplepenguins> but so \ x x x . x is equivalent to \x . \x . \x . x right?
22:59:22 <TRWBW> or would that be 1?
22:59:30 <LeCamarade> So \x x x x x is having all the args with the same name. Does that seem like it should work? No.
22:59:38 <LeCamarade> In a way, yes.
22:59:45 <brainly-green> yeah purplepenguins
22:59:47 <purplepenguins> okay
23:00:04 <LoganCapaldo> TRWBW: zero is \f x . x, one is \f x . f x, two is \f x . f (f x)
23:00:09 <purplepenguins> does this mean that you are applying a function over and over again, that keeps giving x?
23:00:20 <purplepenguins> or rather, applying x to itself keeps giving x
23:00:45 <brainly-green> it is a function of three arguments whose value is the third argument
23:01:01 <purplepenguins> why the third?
23:01:02 <brainly-green> but it seems like an abuse of notation to me
23:01:38 <LoganCapaldo> IOW n is a function from from f to f composed with itself n times
23:01:41 <brainly-green> add parentheses:  (\ x x x . x) = (\x . (\x . (\x . x)))
23:01:47 <purplepenguins> oh wait
23:01:50 <TRWBW> it's the \g x. x (x), the function that keeps on giving?
23:01:51 <purplepenguins> so it is associative that way?
23:01:57 <LeCamarade> All func calls are curried in Haskell. No function takes more than one arg. But for the syntactic sugar, it would be a regex-like affair.
23:02:06 <purplepenguins> I thought it was (((\x . \x) . \x ) . x
23:03:48 <brainly-green> well, it isn't, that's not formed right anyway
23:03:48 <brainly-green> then consider the application of it
23:03:49 <purplepenguins> \x . x is the identity
23:04:19 <purplepenguins> so this is like \x . (\x . I)
23:05:30 <brainly-green> ((((\x . (\x . (\x . x))) 1) 2) 3) = (((\x . (\x . x)) 2) 3) = ((\x . x) 3) = 3
23:06:35 <purplepenguins> I'm trying to see where this comes from
23:06:38 <brainly-green> but it's an abuse of notation, ordinarily you should only use the abbreviation for multiple arguments if they all have different names
23:06:58 <LoganCapaldo> this \x x x . x is a lousy example function
23:07:02 <brainly-green> yes it is
23:07:03 <purplepenguins> it is
23:07:45 <purplepenguins> do you start with the innermost nested paranthesis?
23:08:45 <Moozilla> how do I use .lhs files?
23:09:04 <LoganCapaldo> Moozilla: same way you use .hs files
23:09:19 <dons> yeah, ghc -O Foo.lhs --make
23:09:22 <LoganCapaldo> compile em or runghc or runhaskell them
23:09:24 <Moozilla> I mean it's the weird kind with all the code after > and comments
23:09:41 <dons> what do you mean by 'use' ?
23:09:57 <Moozilla> I mean I try to load it in ghci to test it out and it gets a lexical error
23:10:07 <dons> :load Foo.lhs ?
23:10:31 <Korollary> ghci loads them fine. The file must have some kinda error
23:10:36 <LeCamarade> Moozilla: In .lhs, it is only lines that start with > that are code. Everything else is part of one big, happy comment.
23:10:45 <dons> $ cat A.lhs
23:10:45 <dons> Literate stuffs
23:10:45 <dons> > module Foo where
23:10:45 <dons> >
23:10:45 <dons> > foo = 1
23:10:46 <lambdabot>  Parse error
23:10:46 <lambdabot>  Parse error
23:10:48 <dons> like that?
23:11:01 <Moozilla> the file in question is the md5 thing
23:11:11 <dons> which one?
23:11:26 <Moozilla> this one
23:11:27 <Moozilla> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/
23:11:29 <lambdabot> Title: MD5 in Haskell
23:11:40 <dons> ah, not this one, http://www.cse.unsw.edu.au/~dons/tmp/MD5.hs :-)
23:12:02 <Moozilla> ahh, why isn't there a link to that on the wiki?
23:12:06 <dons> probably its a cabalised library?
23:12:23 <dons> Moozilla: oh, you stumbled in on a conversation. we happened to be talking about md5 earlier
23:12:34 <dons> the one you link to is a nice reference implementation
23:12:41 <dons> the one i linked to isn't, its a binding to openssl
23:13:20 <Moozilla> so what should I use to just take the hash of a string?
23:13:36 <dons> how big is the string?
23:13:44 <dons> is it for fun, or for serious work?
23:14:22 <Moozilla> > length "dElnQV5zK4whZRXz80DpdCF3vvPWqgeJKLnPx5flzTJq"
23:14:24 <lambdabot>  44
23:14:36 <Moozilla> sort of both
23:14:38 <dons> oh, you want the md5 of that, eh? why not just use the standard crypto package?
23:14:49 <dons> if its bigger than 50k or so, probably the one i linked to is more efficient
23:14:59 <Moozilla> ahh, ok
23:15:11 <dons> ?hackage crypto
23:15:12 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/crypto
23:15:12 <Moozilla> where can I get the standard crypto package?
23:15:18 <dons> ^^
23:15:21 <Moozilla> oh, thanks :)
23:15:24 <dons> or is it Crypto
23:15:29 <Moozilla> dons++
23:15:34 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Crypto
23:16:15 <Vq^> ?karma dons
23:16:15 <lambdabot> dons has a karma of 142
23:16:48 <LoganCapaldo> ?karma audreyt
23:16:48 <lambdabot> audreyt has a karma of 634
23:16:54 <Vq^> :-o
23:17:05 <LoganCapaldo> inflation :)
23:17:26 <dons> audreyt uses cunning auto-karma bots :-)
23:18:26 <Vq^> LoganCapaldo: or cheating
23:18:55 <Moozilla> is there any windows gui for darcs?
23:19:13 <LeCamarade> I want int to overflow your karmas. That will be funny.
23:19:35 <int-e> dons: you could have lambdabot ignore that bot now.
23:20:19 <dons> quite so.
23:20:46 <dons> LeCamarade: not such luck, we planned for that,
23:20:47 <dons>   type KarmaState = M.Map Msg.Nick Integer
23:20:51 <dons> ;-)
23:21:04 <Vq^> :)
23:21:17 <int-e> so we'll just @karma+ dons until lambdabot runs out of memory :)
23:21:41 <LoganCapaldo> hmm Msg.Nick seems inaccurate
23:21:54 <LoganCapaldo> unless some poor guy really has a nick of java
23:22:03 <int-e> @karma Dons
23:22:03 <lambdabot> Dons has a karma of 0
23:22:12 <int-e> the module has its imperfections :)
23:22:17 <int-e> Java++
23:22:21 <LoganCapaldo> @karma java
23:22:21 <int-e> @karma Java
23:22:21 <lambdabot> java has a karma of -16
23:22:22 <lambdabot> Java has a karma of -8
23:22:35 <Moozilla> @karma lambdabot
23:22:36 <lambdabot> lambdabot has a karma of 47
23:22:50 <Moozilla> @karma+ lambdabot
23:22:51 <lambdabot> lambdabot's karma raised to 48.
23:22:52 <int-e> hmm. but that one actually did cost me one karma point. hehe.
23:23:13 <LoganCapaldo> @karma+ int-e
23:23:14 <lambdabot> int-e's karma raised to 34.
23:23:19 <LoganCapaldo> for taking one for the team
23:26:25 <dons> so, who wants to write a fast md5 over strict bytestrings in haskell only? :-)
23:27:41 <hpaste>  aaim annotated "trunk-tip/head-tail PE problem 18, you've been warned" with "try this" at http://hpaste.org/323#a1
23:28:47 <ahanwadi> I am trying to build Yi editor and facing some problems. I get the following error: "vty/Yi/UI.hs:196:35: Not in scope: `imgHeight'"
23:29:21 <edwardk> Hrmm. Ok, quick question, how bad would you find a language (with lots of cool features) for which a type inference algorithm didn't exist, but the compiler could prove the existence of a valid type annotation that your code could have been given in order to type check, even if it can't supply you with what it actually is. Implementing the reduction of type inference to
23:29:45 <edwardk> not the problem of inferring the types, but inferring the existence of such types
23:30:03 <dons> so you don't find the actual type, but it does know the type exists, and thus the code is type safe/
23:30:08 <edwardk> yeah
23:30:09 <dons> might be hard to debug type errors?
23:30:13 <opqdonut> heh, nice
23:30:24 <LoganCapaldo> well since no one in #HAppS has deigned to look at my problem :), I'll try in here in and see whether I get anywhere. I'm trying to build HAppS, and I get this error http://hpaste.org/339
23:30:25 <edwardk> there is that, and some of the cases would still be inferable
23:30:27 <Korollary> It doesn't really compile, tho, does it?
23:30:35 <edwardk> yeah it'd compile
23:30:46 <Korollary> then how come you don't know the types?
23:30:52 <LeCamarade> edwardk: Types would be my enemy, then, for they are the compiler's secret ... no?
23:31:29 <edwardk> lecamarade: if necessary i might provide you with a proof of the existence of the types, just not exactly what they are =)
23:32:06 <LoganCapaldo> edwardk: you're making my brain melt
23:32:35 <edwardk> Korollary: weird corner cases involving f-bounded polymorphism, proof of termination, etc.
23:33:36 <edwardk> its just something i wanted to think about for a moment =)
23:33:39 <LeCamarade> There are these Lispers who are angering me at Reddit on the `If Ruby is so great' thread ... Lisp is crap. Oh, this is not #haskell-blah ...
23:33:53 <opqdonut> LeCamarade: link please?
23:34:14 <LeCamarade> http://programming.reddit.com/info/1z8b8/comments
23:34:16 <lambdabot> Title: If Ruby is so great (reddit.com)
23:34:25 <opqdonut> thanks
23:34:30 <LeCamarade> Referring to this: http://metacircular.wordpress.com/2007/06/17/if-ruby-is-so-great/
23:34:31 <lambdabot> Title: If Ruby is so great ´ Metacircular thoughts
23:34:41 <Korollary> edwardk: It would be somewhat awkward. The programmer wouldn't know what changes he could do that would still typecheck.
23:35:19 <edwardk> if your code ever failed to type check i could provide you with a counter-example, since the process would be counter-example guided
23:35:22 <LeCamarade> Where some guy went and called Ruby a bag of hot air. I know this is #haskell, but shouldn't a language helping the lambda revolution get more respect from the designer of Factor, which is the Mother Imperative?
23:35:59 <edwardk> kor: well i already threw that baby out with the bathwater when i started inferring subset types ;)
23:36:59 <opqdonut> LeCamarade: well i haven't really seen whats so fine about ruby
23:37:17 <opqdonut> and amid all this lisp-bashing, i think sexps are the nicest thing since sliced bread :)
23:37:53 <edwardk> ruby isn't ugly enough to replace perl and its not pretty enough to replace python, and i know both so i don't feel the need to converge to the middle and mediocrity ;)
23:38:38 <kolmodin> morning!
23:39:07 <Korollary> morning!
23:39:11 <LeCamarade> opqdonut: Ruby is readable Lisp. Lisp is not static-typed. Haskell is readable Lisp, with type-safety. Lisp has been improved. S-Expressions save the compiler designer time (see a Haskell tutorial that builds a Scheme in 48 hours) at the expense of turning me - the dev - into a parser. Utter crap, since this is not 1960 anymore.
23:39:52 <ttfh> Isn't ruby trying to "out-python python" or something?
23:39:53 <edwardk> Korollary: er what i mean by that is that I already let the compiler do a lot of 'best effort' stuff around the corners of undecidable things, like, say let you define a predicate sorted : [a] -> Bool, then say sort : [a] -> { x : [a] | sorted x }, basically ESC/Haskell pre/post conditions rerolled into a primitive part of the language.
23:40:23 <LeCamarade> edwardk: I must return explicitly in Python. And there are no sane ways to create (or mimick) nice lambdas. I moved away from Py consciously. Oh, and Py is against recursion _by design_!
23:40:33 <opqdonut> LeCamarade: say what you will, but i insist that lisp macros are easier for the coder than template haskell
23:40:49 <edwardk> LeCamarade: there is a reason why i'm in #haskell and not #python ;)
23:41:02 <opqdonut> LeCamarade: what is this "ruby is readable lisp" based on btw? hadn't heard it before
23:41:08 <LeCamarade> ttfh: Ruby would never sink to trying to out-Python Python. It was born higher - matz called it once (tongue-in-cheek) `MatzLisp'.
23:41:42 <opqdonut> LeCamarade: but otoh i'm all for perl-like syntax
23:42:09 <LeCamarade> opqdonut: When I start using macros, I press ^D and import Parsec. :o) Or, actually, I just avoid needing them, just like impurity in Haskell. Can do it, won't do it.
23:42:23 <edwardk> python tends to be against recursion by design because its stack frames interleave with the c stack frames traditionally, so you never knew how many you could afford before you blew up ;)
23:42:29 <ttfh> LeCamarade: well I never actually looked closely at ruby, that was just my impression from the ruby-advocates
23:42:52 <int-e> edwardk: same as C? :P
23:43:00 <edwardk> int-e: =)
23:43:40 <opqdonut> LeCamarade: yeah i don't use template haskell either, mostly there's just no need for it :) what i was saying was that sexps make nice tricks awfully easy, they win over xml any day
23:43:41 <allbery_b> matzlisp?  not matzsmalltalk?
23:44:05 <LeCamarade> opqdonut: Ruby is a readable Lisp by emphasising human-friendly syntax. Not typing syntax trees. I'm very sensitive to syntax. I'll never do Lisp again (especially after the Haskell affair ...)
23:44:31 <Shimei> Python's moving away from FP if anything, while ruby seems to be staying where it is with FP.
23:44:37 <ttfh> Hmm, I like Scheme, Scheme and Haskell complement each other nicely in my mind
23:44:45 <Shimei> So "out-pythoning" python doesn't seem to make sense in that context.
23:44:50 <kfish> here's some nice Python3000: "def foobar(a: Integer, b: Sequence) -> String:" -- http://www.artima.com/weblogs/viewpost.jsp?thread=208549
23:44:51 <opqdonut> LeCamarade: yeah i realize that, but how is ruby like lisp?
23:44:51 <lambdabot> Title: Python 3000 Status Update (Long!)
23:45:04 <edwardk> python found generators and went ape-shit
23:45:08 <dobblego> that's not Python3000, that's Scala!
23:45:11 <LeCamarade> ttfh: I replaced Perl and (especially) Python with Ruby. I've never touched Rails. It's all just scripting for me - in a functional way. I no longer write loops - I recurse. And Python, for example, is designed to loop rather than recurse.
23:45:19 <edwardk> no one had the heart to tell them how much cooler continuations were ;)
23:45:23 <dons> opqdonut: they're both traditionally interpreted ? :-)
23:45:31 <LoganCapaldo> ruby isn't trying to out-python python, its trying to out-smalltalk perl :)
23:46:09 <int-e> generators are cool. in haskell, virtually anything is a generator :)
23:46:11 <dons> yeah, there's nothing lispy to it.
23:46:22 <LoganCapaldo> Or maybe out-perl smalltalk
23:46:30 <ttfh> and python was trying to out-{something} perl? which in turn was trying to out-{something}-sh?
23:46:42 <dons> awk/sed.
23:46:48 <opqdonut> ttfh: perl just glued sed, awk and sh together
23:46:51 <edwardk> int-e: =)
23:46:51 <LeCamarade> opqdonut: In Ruby, every single statement - even the creation of a class - returns. That's simply the only thing that makes Lisp functional in the first place. On top of the lambdas and stuff, which are over-supported in Ruby. Ruby is a Lisp that prefers to use things like algebraic notation and context-sensitive syntax, because it is built to favour humans, not parsers.
23:46:53 <LoganCapaldo> python was trying to out-ABC ABC
23:46:55 <opqdonut> and provided an interface to that glue
23:46:58 <allbery_b> perl was trying to swallow all the shell+tools whole
23:46:58 <jfredett> int-e: isn't that the definition of the language? as generators are a form of Lazy-eval, and thats like-- what haskell is?
23:47:27 <jfredett> like++
23:47:38 <thermoplyae> Ruby has macros?
23:47:47 <wi> no it has 'metaprogramming'
23:47:49 <int-e> jfredett: yes, exactly
23:47:57 * thermoplyae googles
23:48:02 <jfredett> python is just trying to outsnake python...
23:48:06 * jfredett grins
23:48:07 <LeCamarade> Imagine, when Python gets static typing, it is not inferred. Language designers need to spend time on #haskell before their next idea.
23:48:11 <jfredett> int-e brilliant!
23:49:24 <LoganCapaldo> python's not getting static typing its getting more documetation that looks like type annotation
23:50:05 <LoganCapaldo> "Function and method signatures may now be "annotated". The core language assigns no meaning to these annotations (other than making them available for introspection), "
23:50:22 <int-e> same as java then :/
23:50:44 <jfredett> alright- 3 more PE problems down, 124 to go....
23:51:11 <Shimei> So that's basically a formalized "respect my API foo" then?
23:51:17 <Japsu> :<
23:51:24 <jfredett> meh, sleep first, math later. :/ gnite folks
23:51:25 * Japsu doesn't like where Python's headed
23:51:26 <ttfh> Isn't there a Haskell-with-sexp-syntax somewhere?
23:51:32 <allbery_b> liskell?
23:51:35 <LoganCapaldo> @where liskell
23:51:36 <lambdabot> I know nothing about liskell.
23:51:39 <LoganCapaldo> fine!
23:51:44 <Japsu> @google liskell
23:51:44 <allbery_b> @go liskell
23:51:45 <LeCamarade> @go liskell
23:51:46 <LoganCapaldo> @go liskell
23:51:47 <lambdabot> http://clemens.endorphin.org/liskell
23:51:47 <lambdabot> Title: Liskell - clemens.endorphin.org
23:51:48 <lambdabot> http://clemens.endorphin.org/liskell
23:51:48 <Japsu> :DDD
23:51:48 <lambdabot> Title: Liskell - clemens.endorphin.org
23:51:49 <lambdabot> http://clemens.endorphin.org/liskell
23:51:50 <lambdabot> Title: Liskell - clemens.endorphin.org
23:51:51 <lambdabot> http://clemens.endorphin.org/liskell
23:51:53 <lambdabot> Title: Liskell - clemens.endorphin.org
23:51:54 <LoganCapaldo> oops
23:51:55 <allbery_b> @quote stereo
23:51:55 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
23:51:56 <ulfdoz> SPAM!
23:51:56 <LeCamarade> <lambdabot> Okay, okay!
23:52:02 <chowmeined> pytohn
23:52:04 <LeCamarade> <lambdabot> Okay, okay!
23:52:50 <ttfh> yeah, that's it
23:53:06 <allbery_b> (and it and it and it :)
23:53:19 <LoganCapaldo> @where+ liskell http://clemens.endorphin.org/liskell
23:53:20 <lambdabot> Done.
23:53:23 <jfredett> are you kidding me, in stereo? Fuck, that was practically 5.1 dolby surround.
23:53:30 <opqdonut> :D
23:54:39 <jfredett> anyway- gnite again.
23:54:52 <Japsu> But what I don't get is why anyone would want to write Haskell with Lisp syntax.
23:55:05 <Shimei> Macros.
23:55:05 <opqdonut> sexps are warm and fuzzy
23:55:09 <opqdonut> embrace them
23:55:15 <Japsu> No. They are ugly and clumsy.
23:55:16 <opqdonut> (and yes, macros are nicer than template haskell)
23:55:17 <jfredett> me neither, I love lisp to death
23:55:20 <dons> dcoutts: http://hacks-galore.org/aleix/BitPacket/ (python bit parsing, should be able to whoop that )
23:55:21 <lambdabot> Title: BitPacket
23:55:22 <allbery_b> like monads
23:55:27 <allbery_b> ?
23:55:28 <jfredett> but Haskell + Sexp's != good
23:55:37 <LeCamarade> Japsu: Maybe is just a sales pitch. Haskell has a big marketting department running on its own budget. Or a chance to use Monads again.
23:55:54 <jfredett> I rather prefer separation of languages... Sexps belong to scheme and lisp
23:56:00 <LoganCapaldo> 90% of the reason I tried to learn Haskell was the syntax
23:56:12 <jfredett> haskell is an ML-esque language- so it gets ML-esque syntax
23:56:30 <LeCamarade> jfredett: Aha. And ML is legible Lisp.
23:56:35 <Japsu> Lol. When I first laid my eyes on the liskell website, I said to myself, "I can smell the OSWD in this!". And then I scrolled all the way down - "original design by haran". :)
23:56:38 <LeCamarade> With more, more stuff.
23:56:45 <LoganCapaldo> Sure it's a shallow reason
23:56:55 <LoganCapaldo> but I'm a shallow person :)
23:56:59 <jfredett> funny-- I prefer the syntax of Lisp to Haskell
23:57:02 <Japsu> I've even used the same template myself.
23:57:15 <jfredett> not for stylishness, perse, but for plain old usefulness
23:57:28 <dons> you do see beginners programming haskell as if it was lisp
23:57:34 <jfredett> sexp's are a wonderful syntactic device
23:57:34 <dons> no (.) or ($)
23:57:36 <dons> just lots of ( )
23:57:40 <LeCamarade> LoganCapaldo: Not shallow at all! Syntax is programming. Otherwise we'd be using those turing tarpits like brainf*ck.
23:57:44 * allbery_b prefers haskell to lisp
23:58:03 <Japsu>       (* n (fact (- n 1))))))))
23:58:05 <Japsu> HNNNNNGH
23:58:07 <allbery_b> or still using fortran or pl/1
23:58:17 <LeCamarade> (((((((I will abolish Lisp after the revolution.))))))
23:58:21 <Japsu> there's eight )
23:58:23 <Japsu> there's eight )
23:58:24 <jfredett> allbery_b: if Lisp had half of the features of haskell, I would have never bothered with Haskell....
23:58:24 <Shimei> Or LOLCODE.
23:58:28 <Japsu> there's eight )'s in a row. EIGHT
23:58:34 <Japsu> (sry, enter faleage)
23:58:39 <LoganCapaldo> I CAN HAS PARENTHESEZ?
23:58:45 <hpaste>  (anonymous) annotated "trunk-tip/head-tail PE problem 18, you've been warned" with "(no title)" at http://hpaste.org/323#a2
23:59:06 <LeCamarade> (((anonymous)))?
23:59:09 <allbery_b> well, there are the lisp variants that let you close a bunch of parens with a ]
23:59:10 <jfredett> someone annotated me?
23:59:24 <jfredett> that was mine from the other day- I resolved it... :/
23:59:27 <int-e> with empty text.
23:59:33 <Shimei> allbery_b: Argh @ PLT for that.
23:59:37 <dons> > ((*) 7 (product (enumFromTo 1 ((-) 7 1))))
23:59:38 <lambdabot>  5040
23:59:44 <LoganCapaldo> did the small bots discover hpaste?
23:59:46 <LeCamarade> allbery_b: Those are Lisp variants trying to fix what is broken about Lisp? How about starting anew?
23:59:50 <dons> > 7 * product [1..7-1]
23:59:50 <LoganCapaldo> s/small/spam/
23:59:51 <lambdabot>  5040
23:59:54 <dons> syntax is cool
23:59:58 <LeCamarade> dons: I'll pull down your karma! :o)
