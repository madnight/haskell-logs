00:10:30 <Syzygy-> You can always create one
00:11:01 <Syzygy-> class (Eq a) => POrd a where pcompare :: a -> a -> Maybe Ordering
00:11:02 <Syzygy-> :)
00:11:53 <HWSOD> I hadn't thought of that!
00:17:09 <HWSOD> I'm almost done with this ticktactoe project so maybe I'll go back to the combinatorial games. or look at the graphic libs.
00:18:45 <HWSOD> In partickular the idea of using maybe to add the incomparable value feels obvious now but ...
00:26:31 <Cale> !paste
00:26:31 <hpaste> Haskell paste bin: http://hpaste.org/
00:42:20 <hpaste>  HWSOD annotated "Implementing the show function" with "(no title)" at http://hpaste.org/363#a1
00:43:41 <HWSOD> @cale ??
00:44:08 <Cale> HWSOD: hm?
00:44:55 <Cale> HWSOD: show name x will fail because show only has one parameter
00:45:00 <Cale> You want show (name x)
00:45:31 <DRMacIver> Hm. I failed to take into account that going onto planet Haskell would dump my entire blog history on there at once. Oh well. :)
00:46:07 <DRMacIver> ibid: Thanks. :)
00:46:14 <HWSOD> true!! thats the mistake i always make. :)
00:47:19 <hpaste>  HWSOD annotated "Implementing the show function" with "(no title)" at http://hpaste.org/363#a2
00:47:38 <Cale> actions x
00:48:10 <Cale> but yeah
00:48:25 <hpaste>  HWSOD annotated "Implementing the show function" with "(no title)" at http://hpaste.org/363#a3
00:48:46 <Cale> hpaste really needs an 'edit' feature
00:49:03 <Cale> heh, call it 'mutate', just to really rub it in :)
00:50:45 <hpaste>  Cale pasted "deleteZipwise" at http://hpaste.org/387
00:51:07 <Cale> @tell psymort http://hpaste.org/387
00:51:22 <Cale> errr...
00:51:32 <Cale> Right, lambdabot is asleep.
00:52:26 <Cale> Those are nice handwritten gammas on Chakravarty's blog :)
00:55:15 <Cale> Is it just me, or is the propensity to replace 'er' endings with 'r' in "Web 2.0" services starting to get tired?
00:57:59 <DRMacIver> You say that as if there was a point at which it were not tired.
00:58:13 <Cale> heh
00:58:28 * int-e waits for Web 3000
00:58:39 <Cale> I would have been okay with just one service doing that.
00:58:43 <TSC> You're just a whinr
00:58:49 <Cale> Everyone else copying it is pretty lame.
00:59:01 <Cale> Which one was first? flickr?
00:59:16 <Cale> heh
01:00:02 <Cale> Maye e shoud jut delee te secod lat lettr f evey wod e ue.
01:00:34 <int-e> r mayb th lst vowl?
01:00:51 <oerjan> n dnt b rdcls
01:02:33 * int-e prcks  vd dll f rjn wth  ndl.
01:02:43 <int-e> no, I think leaving out all vowels is too much :)
01:02:53 * mgsloan is totally waiting for web 3000
01:03:29 <Philippa> I heard they're taking away the idempotence of GET in it
01:04:42 <mgsloan> I bet it'll be functional
01:05:21 <hpaste>  (anonymous) pasted "sierpinsky" at http://hpaste.org/388
01:07:49 <Raystm2> Chuck Moore, inventor of Forth, wrote a famous letter defending his position on the construction of words in the forth dictionary being saved as only the first 3 letters and a count of the total letters the word would have it were fully saved, lik4 thi4, whi5 doe4 not3 see4 lik4 it2 cou5 wor4, but3 it2 wor5 jus4 fin4 in2 mos4 cas5.
01:09:23 <benny_> glo6 the13 war7!
01:10:04 <Raystm2> "Do you want to play a game?" -- computer from "War Games"
01:10:30 <Raystm2> good point tho benny_, context helps.
01:11:40 <benny_> well, I learned how to spell Thermonuclear so I had to show off, but Moore's way of doing it doesn't exhibit my skills ;-)
01:12:00 <Raystm2> hehe :)
01:12:24 <HWSOD> Is there a good way to read just a arbitrary part of a file?
01:12:32 <benny_> imagine a spelling bee contest that way ;-)
01:12:42 <Raystm2> lol
01:12:49 <HWSOD> that would be awsome.
01:13:31 <oerjan> HWSOD: hSetPosn
01:13:55 <dons> or just use 'take' :-)
01:13:55 <oerjan> er, i mean hSeek
01:13:59 <dons> lazy IO to the rescue.
01:14:25 <dons> let read10Lines = readFile >>= return . take 10 . lines
01:14:45 <HWSOD> yeah but i want line say 9005 out of 450000
01:15:06 <oerjan> line? then you have a problem
01:15:19 <Japsu> take 9005 !! 9005 :)
01:15:32 <HWSOD> and hSeek dosent work on windows on text files.
01:15:36 <oerjan> you cannot count lines without going through the entire file
01:15:42 <Japsu> yeah, there
01:15:42 <oerjan> up to that point
01:16:08 <Japsu> yeah, there's no concept of "lines" on the file level, they're just a stream of bytes
01:16:09 <HWSOD> well i know how many chars are in each line
01:16:14 <dons> i was wondering why 'haskell weekly news' appeared in my rss feed, as mentioned on a site titled: "The sex menu - I'll take one of everything"
01:16:17 <Japsu> well that helps you
01:16:36 <dons> then i noticed it was a rss aggregator for the term 'bondage and discipliie'
01:16:59 <Raystm2> oh no kidding, that's hillarious.
01:17:24 <swiert> Amazon keeps trying to sell me kinky books after I ordered "The Guide to LaTeX".
01:17:29 <dons> heh
01:17:31 <Japsu> :D
01:17:41 <HWSOD> Lol
01:17:42 <Raystm2> lol
01:18:33 <dons> i think that's more `lol's in a row then i've ever seen in here :-)
01:19:55 <pflanze> Wondering: on http://www.macs.hw.ac.uk/~dsg/gph/papers/html/Strategies/strategies_12.html they say "Because evaluation strategies are just normal higher-order functions, ..", but why are they "higher-order"?
01:20:07 <pflanze> Looks like a text bug?
01:20:38 <pflanze> Or am I misunderstanding the notion of "higher-order"?
01:20:56 <dons> aren't they functions that take functions as arguments? like pseq?
01:21:12 <pflanze> no, just values, afaics.
01:21:33 <pflanze> haven't seen pseq
01:21:38 <dons> i thought most of the parallel strategie combinators were higher order. do you have an example/
01:21:52 <dons> ?docs Control.Parallel.Strategies
01:22:06 <dons> ?bot
01:22:07 <dons> ah
01:22:08 <pflanze> rwhnf :: Strategy a
01:22:09 <pflanze> rwhnf x = x `seq` ()
01:22:25 <pflanze> rwhnf looks like a 'normal' function to me?
01:22:46 <dons> what's the type of Strategy a expanded though?
01:23:00 <pflanze> type Strategy a = a -> ()
01:23:15 <dons> right. that's not like
01:23:19 <dons> :t map
01:23:26 <araujo> hello
01:23:28 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
01:23:32 <dons> what about things like parMap ?
01:23:41 <dons> ?docs Control.Parallel.Strategies
01:23:42 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Parallel-Strategies.html
01:23:59 <dons> ^ that's the current api
01:24:07 <dons> and most are higher order, by the looks.
01:24:10 <dons> well, many.
01:24:16 <dons> ($|) :: (a -> b) -> Strategy a -> a -> b
01:24:16 <dons> ($||) :: (a -> b) -> Strategy a -> a -> b
01:24:17 <dons> (.|) :: (b -> c) -> Strategy b -> (a -> b) -> a -> c
01:24:20 <oerjan> ?docs Test.Ridiculous.ModuleName
01:24:20 <lambdabot> Test.Ridiculous.ModuleName not available
01:24:25 <pflanze> parMap has been mentioned in the paper in the first chapter as an example of raw `par` usage.
01:24:26 <dons> oerjan: :P
01:24:45 <dons> pflanze: yeah, perhaps double check against the as-implemented api. the haddocks give a nice summary, i think
01:24:52 <pflanze> k, thanks
01:25:18 <dons> i note the haddocks should be fleshed out a bit more
01:25:24 <dons> with at least a link to the paper you're reading
01:27:33 <dons> gday sjanssen
01:27:41 <dons> oh, rather late actually
01:27:51 <sjanssen> indeed
01:28:26 <pflanze> (ah, I realize that a in  a -> () could be a function, of course; I guess the point they wanted to make is that Strategies *can* be higher order.)
01:31:12 <pflanze> looks like haskell.org has a problem.
01:31:59 <dons> oh hmm, yes.
01:32:21 <dons> sundays are funny, that's the 4th sunday timeout in the last 12 months
01:32:30 <dons> maybe sunday is googlebot trawling day
01:32:43 <pflanze> hm wiki spammers are very active on weekends.
01:33:46 <pflanze> (probably it pays off better for them on weekends because on manually cleaned wikis they'll have their stuff online until monday)
01:34:15 <dons> we don't seem to get much wiki spam , very little in fact, but there have been problems with bots indexing the site
01:37:48 <swiert> dons: do you know if Galois still use Cryptol?
01:38:29 <dons> swiert: yeah, they do.
01:38:46 <swiert> Cool.
01:39:39 <whaleofconfusion> is there any reason not to consider a statically typed language as a variant of a dynamically typed language where the type checks are required to be optimized out by the compiler?
01:40:24 <dons> so, the same, but a static phase is introduced, no dynamic typing remains, and there's proper type erasure?
01:40:28 <dons> :-)
01:41:03 <dons> (usually, people spin it the other way around, dyn typed languages being statically typed languages, with a universal static type, and instead runtime checks inserted into each reduction step at runtime)
01:41:10 <DRMacIver> whaleofconfusion: Well, as has been observed before, Haskell is a counterexample to that view point. :)
01:41:34 <DRMacIver> (In that the inferred types are significant. Consider for example 1.)
01:42:16 <LeCamarade> I'm loving the links on Jim Apple's post: http://japple.blogspot.com/2007/06/proof-of-referential-transparency.html
01:42:18 <lambdabot> Title: Everyone Else is Crazy: Compiler Proof of Referential Transparency, http://tinyurl.com/274vxu
01:42:19 <dons> whaleofconfusion: i think the more important issue would be that the kind of static type systems you see in haskell require analysis not doable at runtime via checking. they're radically different type systems.
01:43:17 <ibid> DRMacIver: i thought planet only grabs two latest stories from new feeds. that's what it's supposed to do, anyway
01:43:18 <whaleofconfusion> dons: could you explain that one, maybe give an example of analysis that can't be captured by a runtime type check?
01:43:39 <augustss> whaleofconfusion: just to emphasize what dons said, anything with phantom types would be impossible at run-time
01:43:44 <ibid> DRMacIver: but i've stopped trying to make sense of what planetplanet does. should rewrite it in haskell :)
01:44:15 <DRMacIver> ibid: Yeah, it's fewer than I initially thought. I think it was more than 2 though.
01:44:24 <DRMacIver> One second while I check.
01:45:16 <DRMacIver> I count about 6 stories from me.
01:45:39 <DRMacIver> Which is ok, as it means they go back to the actually vaguely interesting one. :)
01:45:52 <ibid> ok
01:46:09 <ibid> as i said, i've stopped trying to make sense of planetplanet :)
01:51:13 <pflanze> augustss: but the 1. example could just represent the value in a "not-yet compiled" (e.g. string representation) form?
01:51:34 <whaleofconfusion> augustss: why would phantom types be impossible at run-time?
01:51:46 <pflanze> and then the runtime resolves it when the required type is known.
01:52:01 <mgsloan> bah! haskell instances decls should be able to define functions for classes which the class params depend on..
01:53:07 <mgsloan> (so basically the numeric types could have one instance...)
01:54:15 <whaleofconfusion> looking at http://en.wikibooks.org/wiki/Haskell/Phantom_types it seems possible
01:54:16 <lambdabot> Title: Haskell/Phantom types - Wikibooks, collection of open-content textbooks
01:55:17 <dons> whaleofconfusion: i'd imagine just about any non-local type unification would be very difficult, wouldn't it?
01:55:35 <augustss> The example of 1 is difficult to do at runtime, but it's not a phantom type.  Phantom types is about type checking of things that have to corresponding value at run-time at all.
01:55:59 <mgsloan> interesting nonetheless
01:56:50 <whaleofconfusion> dons: would anything make it more difficult than the statically typed version, with suitable restrictions on the kinds of type checks permitted?
01:57:21 <mgsloan> I think instances defining more than one classes functions would be possible, as long as the class def mentions all the type variables used in the constraints.
01:57:54 <augustss> whaleofconfusion: it would only be possible to do run-time type checks of phantom types if you add extra arguments.  how can you check something that does not exist?
01:58:00 <whaleofconfusion> that is, if you disallow all the dynamic features that are not also static features
01:59:21 <whaleofconfusion> ie if a function has type A -> B then that would be encoded as a type check for the type tag of the argument, to ensure that it matches A, and of the result, to ensure it matches B
01:59:43 <whaleofconfusion> and both those checks could then be optimized away as in static typing
01:59:51 <oerjan> mgsloan: i've had the same idea.  for one thing, it might make it possible to restructure the broken numerical class hierarchy without breaking existing programs...
01:59:54 <crazy_coder> hello guys
02:00:30 <crazy_coder> Any links to haskell standard or documentation containing all pre-defined functions ?
02:00:32 <mgsloan> oerjan - that's what I'm doing :)
02:00:57 <mgsloan> except I don't care about the breaking part - just making a prelude wrapper for this project
02:01:19 <mgsloan> crazy_coder: http://www.haskell.org/onlinereport/standard-prelude.html
02:01:19 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
02:02:05 <crazy_coder> Is there any pdf form standard ?
02:03:09 <astrolabe> http://www.haskell.org/definition/haskell98-report.pdf
02:03:13 <mgsloan> I hope haskell' patches up some of these type class issues
02:03:24 <crazy_coder> Thanks
02:04:15 <mgsloan> class intersection defaults would be awesome too
02:04:40 <augustss> Why are people whining so much about the Prelude?  It only takes two import lines to replace it (well mostly).
02:05:05 <|Steve|> What's wrong with the prelude?
02:05:18 <helikoptik> replace with what?
02:05:46 <augustss> Well, I presume that people who whine about the prelude has something better in mind.
02:07:04 <mgsloan> I'm not whining about the prelude, leave it like it is - at least the option to leave it out is given.
02:07:25 <augustss> ok :)
02:07:34 <mgsloan> I have in the past though :)
02:07:45 <mgsloan> |Steve| - mostly the numerics and monads bits
02:08:19 <mgsloan> the monads bits are fine, but it can be done much sweeter (as in The Other Prelude)
02:08:28 <Philippa> augustss: did you ever try using mdo as an "overloaded let", btw?
02:09:06 <augustss> Philippa: I've never used mdo.
02:09:24 <Philippa> *nod* - was just thinking of your FitA talk
02:09:45 <augustss> but using it as an overloaded let would be a good reason to use it :)
02:10:17 <psymort> cale: back again - sorry, had to run earlier
02:10:27 <augustss> generally, i try to avoid language extensions that only one compiler implements
02:10:45 <Cale> psymort: I pasted something on hpaste
02:11:27 <Cale> http://hpaste.org/387
02:11:34 <psymort> a
02:11:37 <psymort> ta
02:14:22 <|Steve|> I see/
02:14:24 <|Steve|> .
02:15:01 <Philippa> by now I'm reaching the point where I'm willing to trade that for being the one implementing the compiler in question - that quickly leads you away from Haskell though, not to mention away from productivity
02:17:39 <mgsloan> I'm probably going the wrong way by defining class Addable a b c where (+) :: a -> b -> c, but it seems to be the only way..
02:18:35 <mgsloan> though most reasonable uses are a->b->a or a->a->a
02:18:54 <|Steve|> Is that to get past the bizarre fromInteger and friends?
02:19:00 <Heffalump> augustss: what, like overloaded string literals and record wildcards? ;-)
02:19:42 <DRMacIver> What are record wild cards?
02:19:46 <|Steve|> I typically think in terms of left actions so a -> b -> b.
02:20:59 <Heffalump> a feature that should be going into GHC HEAD soon; Foo{..} in pattern context brings all the fields of Foo into scope, and in expression context constructs a Foo by scooping up all the field names of Foo from the current scope
02:21:24 <mgsloan> |Steve| - nah, its to allow for things like + :: (Addable b) => (a -> b) -> b -> (a->b)
02:21:36 <mgsloan> in other words, offset the range of a function
02:21:44 <DRMacIver> Interesting.
02:22:15 <|Steve|> I don't follow.
02:22:23 <psymort> cale: thanks for that - it'll take me a while to work out how it works
02:22:30 <psymort> cale: hope you didn't spend too long on it.  The function is just for me to try and work out how I would do in haskell something I just did @work in a procedural language using state.
02:23:06 <mgsloan> |Steve| - yeah, I didn't quite type that Addable right. should be Addable a a a.  Anyway, currently, for arithmetic ops, the inputs and the output all have to have the same type
02:23:06 <augustss> Heffalump: I said "try to avoid", I often fail. :)
02:23:15 <mgsloan> my version, they can all be different.
02:23:27 <Cale> psymort: I didn't spend too long :)
02:23:28 <Heffalump> :-)
02:24:53 <Cale> psymort: You could also actually use state (say, with ST) to translate the algorithm.
02:25:07 <mgsloan> + :: (Addable (a->b) b (a->b)) => (a -> b) -> b -> (a->b)
02:27:23 <psymort> cale: if you want the context, I basically have a very large datastream containing discrete records (LDIF to be precise).  Then I have several predicates that will yield out an attribute of the record if they match - basically forming a mapping function from the record to some identifier.  And, for each predicate/mapping function, I have a set of identifiers that need to be found somewhere in the stream for it to be considered a
02:27:23 <psymort>  valid stream.  Since the stream is huge (about 10GB), I really only want to iterate through it once :), and as I go reduce down each set of identifier I'm searching for until there are none left (valid) or the stream ends (invalid).
02:29:18 <mgsloan> whoah, sounds like a great candidate for bytestring!
02:29:32 <Cale> Definitely :)
02:30:13 <Cale> Using a strict data structure for your accumulator will also make things simpler.
02:30:42 <Cale> (don't just use lists)
02:31:21 <psymort> cale: yeah - I haven't looked into state in haskell yet.  In the procedural language, I basically just created arrays of identifiers I was seaching for, then iterated through the stream checking each predicate and doing a remove from the associated set.  The loop conditional was basically (recordStream.hasNext && !every_set_is_empty), then the function returned true if every set was empty at the end.
02:31:29 <olsner> and perhaps a Map or Array to keep track of the state
02:31:31 <psymort> hmm....so much to learn :)
02:32:10 <Cale> Lists in a lazy language are loops waiting to happen.
02:32:56 <Cale> In fact, any non-strict data structure can be looked at as embodying a certain kind of recursion or control flow.
02:33:11 <|Steve|> What is a strict data structure?
02:33:35 <Cale> |Steve|: one which is either all evaluated or not evaluated.
02:33:47 <|Steve|> Ah. I didn't know you could do that in haskell.
02:34:08 <Cale> You can add !'s before the fields when you declare the datatype.
02:34:17 <Cale> Which makes them strict.
02:34:37 <dons> data StrictList a = Nil | Cons !a !(StrictList a)
02:34:47 <dons> ?src []
02:34:47 <lambdabot> data [] a = [] | a : [a]
02:34:54 <mgsloan> the basic types like Int, Integer, Float, Double, are strict i think
02:35:01 <Cale> yes
02:35:32 <Cale> So lists aren't what you might think they are :)
02:35:56 <|Steve|> In what way aren't they?
02:36:02 <Cale> They're a whole lot more like processes which can produce values in a sequence.
02:36:18 <mgsloan> yeah, generators/streams
02:36:32 <mgsloan> /iterators
02:37:05 <psymort> Cale: so when you say don't just use lists - use a strict ds - do you mean to declare a ds that is kind of like a list, only strict?  (like dons had above)
02:37:22 <Cale> psymort: Or something which is closer suited to your domain.
02:37:29 <psymort> yup
02:37:33 <mgsloan> eg, ByteString
02:37:42 <Cale> ByteString would be one step
02:38:02 <Cale> A lazy bytestring would be ideal for collecting the input initially, before parsing it.
02:38:43 <Cale> But you want something strict on the side of the computation where you're accumulating information about that stream of data.
02:39:28 <Cale> The general heuristic in Haskell is that if you're taking lots and lots of data and collapsing it down to a "small" amount of data, you probably want strictness, and in all other cases, you want things to be lazy.
02:39:31 <psymort> cale: but then I wonder where to draw the line between tightly describing my domain, and being generic.  The algorithm for doing the search/check (which is embodied in the deleteZipwise), doesn't need to know anymore than the fact that the identifiers have equality.  Whereas using bytestring would be very specific to something that uses bytes probably from a file.
02:39:31 <mgsloan> strict on 10GB? seems a bit intense
02:40:16 <Cale> mgsloan: You want the 10GB stream to be lazy
02:40:18 <psymort> mgsloan: I don't think the stream itself would be strict.  Just the tokens parsed from it?
02:40:27 <mgsloan> oh, ok, good
02:40:39 <Cale> psymort: ByteString would be for representing the 10GB file as you parse it.
02:41:22 <psymort> cale: yeah - of course :)  I kind of avoided the whole parsing side of the issue for now, I wanted to pick a small area to start my attempt at implementing it in haskell.
02:41:23 <Cale> So you'd go  file --> ByteString --> lazy stream of chunks? --> strict datastructure representing a summary of the relevant information.
02:41:41 <psymort> cale: sounds about right to me
02:41:41 <olsner> do f <- B.getContents; print $ foldl' updateState startState $ map parse (chunks f)
02:41:51 <olsner> just fill in the blanks ;-)
02:42:07 <psymort> cale: still have to go and re-study IO in haskell
02:43:48 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO -- start here, perhaps :)
02:43:49 <lambdabot> Title: Introduction to IO - HaskellWiki
02:44:08 <Cale> Though given that you said "re-study", perhaps that's overly introductory :)
02:44:51 <psymort> cale: yeah - I did learn it about 6 years ago.  Although never very well ;-)
02:45:53 <psymort> cale: thanks again.  You've been really helpful.  I'll go try and figure out how your implementation works now :)
02:46:40 <nominolo> @tell sorear yes i, realized to late.  I write an explainatory mail to the list
02:46:43 <lambdabot> Consider it noted.
02:47:04 <DRMacIver> Hm
02:47:11 <DRMacIver> What's a good way to get the last n elements of a list?
02:47:52 <Heffalump> reverse . take n . reverse
02:48:13 <DRMacIver> That is a nice way, but the list is potentially very large, so I want approaches which don't prevent the head being garbage collected.
02:48:23 <Heffalump> is n dynamic?
02:48:27 <DRMacIver> Yes.
02:48:51 <Heffalump> tricky
02:49:00 <Heffalump> so you basically want streaming?
02:49:03 <DRMacIver> Yeah
02:49:12 <DRMacIver> My current best guess is to create a list of n element subsequences and drop until I find one of length < n
02:49:15 <Heffalump> you'll need to keep a window of n somehow
02:49:30 <Baughn> Is n large?
02:49:32 <Heffalump> that's o(n*m) where m is the length though.
02:49:36 <DRMacIver> Yeah. :-/
02:49:40 <Baughn> drop (length list - n) list ?
02:49:46 <Heffalump> that's not streaming
02:49:54 <DRMacIver> Baughn: That has the same problem as Heffalump's.
02:49:58 <DRMacIver> (It's the first one I thought of)
02:50:08 <DRMacIver> n is probably not too large.
02:50:28 <DRMacIver> 10s probably.
02:50:42 <Heffalump> dropWhile ((>= n) . length) . map (take n) . tails
02:50:46 <Heffalump> (which is what you suggested)
02:50:48 <olsner> use an m-sized array as a circular buffer?
02:50:56 <Heffalump> yeah, or that
02:50:59 <Heffalump> You mean n-sized.
02:51:22 <olsner> (for some assignment of variable names) :P
02:51:22 <Baughn> Recurse through tails list, backtrack once you hit the end?
02:51:37 <Heffalump> backtracking means it'll hold onto the entire list
02:51:46 <DRMacIver> Hm
02:51:48 <Baughn> Should be some way of avoiding that..
02:51:53 <Heffalump> oh, and my solution is slightly wrong anyway
02:51:54 <DRMacIver> That's easy to solve actually
02:51:57 <Heffalump> Baughn: like what..
02:51:58 <Cale> Do you know how long the list is?
02:52:14 <DRMacIver> Keep going while the tail is >= n + 1
02:52:19 <Baughn> Heffalump: Not sure. My functional-fu is too weak.
02:52:23 <DRMacIver> The first one which isn't is your desired n element sublist. :)
02:52:51 <Baughn> You could use an STArray for the window thing, but that's not very functional
02:52:58 <DRMacIver> So all we need is a lazy equivalent of (>= n) . length
02:53:04 <DRMacIver> Which is easy enough I think.
02:53:18 <Baughn> Sure, just instance Num [a] and it'll work
02:53:22 <Baughn> You can even drop the "length"
02:53:25 <DRMacIver> Ha
02:53:34 <DRMacIver> I'll pass. :)
02:53:34 <Baughn> It would, though. :P
02:53:53 <Heffalump> DRMacIver: yeah, but that becomes O(m^2), not O(n*m(
02:53:58 <Heffalump> ah, yes, what you said
02:54:28 <DRMacIver> Heffalump: Really?
02:54:37 <Heffalump> DRMacIver: not if you make length lazy, as you said
02:54:38 <DRMacIver> Heffalump: Oh, you mean with the version which calculates length.
02:54:39 <Baughn> :t (>)
02:54:41 <lambdabot> forall a. (Ord a) => a -> a -> Bool
02:54:42 * Heffalump was reading too slowly
02:54:53 <Heffalump> I think this a nice example of an application of runST.
02:54:56 <Baughn> @instances Ord
02:54:57 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
02:55:06 <Heffalump> you can get the fast algorithm that way, and have a functional interface.
02:55:19 <DRMacIver> Yeah. I might try to make that work.
02:55:26 <Baughn> > [0,0,0] > [1]
02:55:27 <lambdabot>  False
02:55:32 <Baughn> ..that could be a problem
02:55:42 <Heffalump> it being lexicographic and all
02:55:55 <olsner> lexicographic! just the word I was trying to find
02:56:08 <DRMacIver> Now I just need to figure out how the state monad works.
02:56:11 <DRMacIver> Imperative programming is hard. :(
02:56:11 <Baughn> olsner: We serve to live
02:56:37 <mehrheit> > let f xs = ((tails xs) !!) in f "abcdef" 2 -- what complexity is this?
02:56:40 <lambdabot>  "cdef"
02:57:35 <olsner> takeTail n = foldl' pushBack (circularBuffer n)?
02:57:45 <Heffalump> ST, not a normal State monad
02:57:51 <Heffalump> you need the O(1) array access
02:57:59 <Cale> > let takeEnd n xs = last . map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in takeEnd 5 [1..1000000]
02:58:03 <lambdabot>  [999996,999997,999998,999999,1000000]
02:58:06 <Cale> hmm :)
02:58:12 <DRMacIver> Ah
02:58:14 <Cale> How is that?
02:58:28 <Heffalump> correct, but still O(n*m) ...
02:58:57 <DRMacIver> So in fact I need to figure out the state monad transformer works?
02:58:58 * DRMacIver panics
02:59:03 <olsner> I think you have to try it with larger lists... even the simple (reverse . take n . reverse) handles [1..1000000]
02:59:04 <Cale> are you sure it's O(n*m)?
02:59:11 <Heffalump> no, you need to work out how ST works.
02:59:14 <Cale> What's n and m?
02:59:19 <Heffalump> m = length xs
02:59:23 <DRMacIver> ok. What exactly is ST? :)
02:59:25 <Baughn> DRMacIver: No, STArray's fairly self-contained. Works just like IOArray, too.
02:59:30 <DRMacIver> ok
02:59:33 <Cale> This is O(m-n)
02:59:37 <Heffalump> m >> n
02:59:47 <Cale> no?
03:00:02 <Cale> At least, it appears to be O(m-n) to me.
03:00:02 <Heffalump> yes, that's why he needs a streaming algorithm
03:00:10 <Cale> I mean, my algorithm
03:00:12 <Heffalump> take n is O(n)
03:00:14 <mgsloan> lets check
03:00:18 <Heffalump> and it operates on (m-n) things
03:00:30 <mgsloan> > let takeEnd n xs = last . map (take n) $ zipWith const (tails xs) (drop (n-1) xs) in takeEnd 50 [1..100000000]
03:00:33 <Cale> No, it operates on just one thing
03:00:38 <lambdabot> Terminated
03:00:49 <DRMacIver> Cale: The specification of the problem is that the list is very large, but n is probably only 10s and almost certainly not more than 100s.
03:00:59 <Heffalump> oh, cos of laziness. Hmm.
03:01:16 <Cale> DRMacIver: Try my code :)
03:01:24 <|Steve|> > let takeEnd n xs = drop ((length xs)-n) xs in takeEnd 50 [1..10000000]
03:01:32 <Heffalump> that's not streaming!
03:01:33 <lambdabot> Terminated
03:01:39 * Heffalump is starting to see Cale's point.
03:01:51 <DRMacIver> Cale: Ok. :)
03:02:03 <Cale> I've done this problem before, and I'm pretty sure that was the solution :)
03:02:04 <|Steve|> Oh, you wanted an online algorithm.
03:02:04 <Heffalump> too clever for me, clearly.
03:02:58 <Heffalump> the zipWith is a clever replacement for calculating length xs - n in advance.
03:03:13 <|Steve|> What is const?
03:03:14 <Cale> yeah
03:03:17 * mgsloan likes the circular buffer idea
03:03:18 <Cale> const x y = x
03:03:41 <|Steve|> Ah, I see what it's doing then.
03:04:07 <|Steve|> Maybe.
03:04:09 <Cale> You drop some elements, then zip that together with the list of tails.
03:04:34 <Heffalump> actually, why is map (take n) required?
03:04:39 <Cale> and remember that the zipped list stops when either list stops
03:04:44 <Cale> oh, I suppose it's not
03:04:46 <Heffalump> Surely by construction the last element should be the correct length.
03:04:49 <Cale> yeah
03:04:54 <|Steve|> That's the bit that's confusing me.
03:04:59 <Cale> I wrote something more general first
03:05:03 <Heffalump> I was about to complain that your solution is actually O(m) cos the take adds the n back again.
03:05:30 <Cale> Because you're taking the last tail anyway
03:05:37 <|Steve|> > let takeEnd n xs = zipWith const xs (drop n xs) in takeEnd 5 [1..1000]
03:05:37 <Cale> you don't need the take
03:05:38 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
03:05:48 <|Steve|> Oh, hmm.
03:05:53 <Cale> You absolutely do need the last though
03:06:29 <Cale> > let takeEnd n xs = last $ zipWith const (tails xs) (drop (n-1) xs) in takeEnd 5 [1..1000]
03:06:32 <lambdabot>  [996,997,998,999,1000]
03:06:42 <|Steve|> What does tails do?
03:06:49 <Cale> > tails [1,2,3,4,5]
03:06:49 <olsner> :t const id
03:06:51 <lambdabot> forall a b. b -> a -> a
03:06:53 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
03:07:04 <olsner> :t flip const
03:07:06 <lambdabot> forall a b. b -> a -> a
03:07:21 <Cale> > let xs = [1..5] in zip xs (tails xs)
03:07:24 <lambdabot>  [(1,[1,2,3,4,5]),(2,[2,3,4,5]),(3,[3,4,5]),(4,[4,5]),(5,[5])]
03:07:24 <mehrheit> @pl \n xs -> last $ zipWith const (tails xs) (drop (n-1) xs)
03:07:24 <lambdabot> (last .) . ap (zipWith const . tails) . drop . subtract 1
03:07:36 <mehrheit> :t subtract
03:07:38 <lambdabot> forall a. (Num a) => a -> a -> a
03:07:40 <Cale> > let xs = [1..5] in zip (drop 2 xs) (tails xs)
03:07:42 <lambdabot>  [(3,[1,2,3,4,5]),(4,[2,3,4,5]),(5,[3,4,5])]
03:08:05 <mgsloan> subtract is the currying/compositional version of (-)
03:08:08 <Cale> See how that works?
03:08:21 <|Steve|> Yeah, I do. That's clever.
03:08:41 <|Steve|> But it seems like it would be horribly inefficient as compared to just finding the length ahead of time.
03:08:49 <Heffalump> not at all
03:08:50 <DRMacIver> Ok. I see how this works.
03:08:53 <DRMacIver> Cale: Thanks.
03:08:53 <Cale> Finding the length takes an extra pass.
03:08:58 <|Steve|> Very true.
03:09:06 <|Steve|> But it's a _very_ simple loop.
03:09:08 <Cale> Tails is incredibly efficient.
03:09:18 <Cale> Lists were made for tails :)
03:09:24 <|Steve|> I suppose so.
03:09:28 <DRMacIver> |Steve|: The problem specification is that the head of the list must be garbage collectable because the list is potentially huge.
03:10:00 <|Steve|> DRMacIver: I understand the setup. I'm just thinking that if I didn't have that requirement, I'd just get the length first.
03:10:17 <Cale> Once that last has gone through a few of the tails, no references back to the head of the list will exist.
03:10:31 <DRMacIver> Yeah
03:10:42 <DRMacIver> I understand why your solution works, though I probably wouldn't have thought of it. :)
03:11:34 <Cale> Zipping like this is a great way to do lots of tricky things :)
03:11:45 <mgsloan> hmm, I never thought of the fact that tails was efficient
03:12:36 <Cale> isSubstringOf xs ys = any (isPrefixOf xs) (tails ys)
03:12:39 <DRMacIver> Cale: Yeah. I'll remember the trick. Thanks again. :)
03:12:50 <Cale> is equivalent to the nested loops with early breakout solution :)
03:13:39 <|Steve|> I just thought about it and tails is pretty simple, isn't it?
03:13:44 <|Steve|> > let tails' [] = [[]]; tails' (x:xs) = (x:xs):(tails' xs) in tails' [1..5]
03:13:45 <Cale> yeah
03:13:46 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
03:14:52 <Cale> There's a nice graphical way to picture it.
03:15:54 <Cale> Well, tails = scanr (:) []
03:16:11 <|Steve|> Heh, fine.
03:16:19 <mgsloan> let tails' [] = [[]]; tails' l@(_:r) = l:(tails' r) in tails' [1..5]
03:16:20 <Cale> and you know my picture of scanr :)
03:16:31 <|Steve|> I do not.
03:16:44 <|Steve|> I can never keep scanr/scanl separate.
03:16:48 <Cale> http://cale.yi.org/images/9/92/Folds.png
03:18:50 <olsner> is that (z:f z 1:f (f z 1) 2:...)
03:18:59 <|Steve|> That's not at all clear for the scans and it doesn't help that the l and r don't match up.
03:19:19 <mehrheit> @src tails
03:19:19 <lambdabot> tails []         = [[]]
03:19:20 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
03:19:43 <|Steve|> Hey, that looks quite similar to mine.
03:20:04 <mehrheit> it's more similar to mgsloan's
03:20:16 <|Steve|> > scanr (:) [] [1..5]
03:20:17 <mehrheit> it doesn't touch the head of the list
03:20:18 <lambdabot>  [[1,2,3,4,5],[2,3,4,5],[3,4,5],[4,5],[5],[]]
03:20:45 <|Steve|> I'm not sure how it differs apart from not naming the head of the list.
03:20:59 <|Steve|> > scanl (:) [] [1..5]
03:21:00 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
03:21:00 <lambdabot>       Expected...
03:22:04 <Cale> |Steve|: well, specialise f to : and z to [] in the diagram for scanr
03:22:13 <Cale> and see how that relates to what tails gives
03:23:09 <Cale> It gives a list whose first element is xs, and whose second element is tail xs, and so on, which, if you're reading the diagram correctly, is exactly what is shown.
03:23:32 <Cale> > scanl (flip (:)) [] [1..5]
03:23:34 <lambdabot>  [[],[1],[2,1],[3,2,1],[4,3,2,1],[5,4,3,2,1]]
03:23:37 <|Steve|> I suppose.
03:23:48 <Cale> that scanl is also quite fast
03:23:56 <Cale> scanl is always pretty fast
03:23:57 <olsner> @info foldl'
03:23:57 <lambdabot> foldl'
03:24:02 <olsner> @index foldl'
03:24:02 <lambdabot> Data.List
03:24:23 <Cale> because unless the combining function is complicated, it'll give you a list where the work will get done incrementally as you use each of the elements.
03:25:01 <Cale> scanr is usually bad, but in the case of f being a constructor, it's quite fast.
03:25:01 <|Steve|> So doesn't tails have to scan the entire rest of the list?
03:26:21 <Cale> er...
03:26:27 <Cale> In what sense?
03:27:01 <|Steve|> Well, in your diagram for scanr, it looks like it has to evaluate the rest of the list before getting the first element.
03:27:26 <Cale> Well, remember that if f is a constructor, it doesn't have to do any evaluation
03:27:32 <Cale> (a lazy constructor)
03:27:39 <Cale> In this case, f is (:)
03:27:59 <|Steve|> Is (:) a constructor?
03:28:03 <Cale> Also, it only does that evaluation when you actually look at the element.
03:28:05 <Cale> yeah
03:28:27 <Cale> So when you look at the first element of the scanr
03:28:39 <Cale> You see a (:) applied to some other stuff
03:28:48 <|Steve|> I guess I'd never thought of an infix constructor.
03:28:51 <Cale> and that other stuff is only going to get evaluated if you look at it
03:29:11 <Cale> Constructors are the things which you can pattern match against
03:29:42 <|Steve|> Are there tuple constructors?
03:29:45 <Cale> (,)
03:29:49 <Cale> : (,) 5 6
03:29:54 <Cale> > (,) 5 6
03:29:56 <lambdabot>  (5,6)
03:29:59 <Cale> > (,,) 1 2 3
03:30:01 <lambdabot>  (1,2,3)
03:30:06 <Cale> > (,,) 1 "Hello" 3
03:30:07 <lambdabot>  (1,"Hello",3)
03:30:11 <|Steve|> Okay.
03:30:24 <Cale> Can't section them though, unfortunately.
03:30:31 <Cale> > (,2) 1
03:30:31 <lambdabot>  Parse error
03:30:36 <|Steve|> Section?
03:31:01 <Cale> Sections are those partially applied infix operators
03:31:07 <Cale> > (*2) 3
03:31:09 <lambdabot>  6
03:31:12 <|Steve|> Ah.
03:31:33 <Cale> Which turns into flip (*) 2 3 by the desugarer.
03:31:52 <|Steve|> > map ((flip (,)) 2) [1..5]
03:31:55 <lambdabot>  [(1,2),(2,2),(3,2),(4,2),(5,2)]
03:32:03 <Cale> right, you can do that :)
03:32:29 <|Steve|> Seems sort of silly that you can't but it would probably complicate the grammar.
03:32:52 <Cale> yeah, people would want (,,3,,2,,) to mean something
03:33:07 <Cale> (Even though it would never actually come up ;)
03:33:35 <|Steve|> I think I used too many parentheses.
03:33:48 <Cale> yeah, you could have avoided a pair there
03:33:57 <Cale> > map (flip (,) 2) [1..5]
03:33:59 <lambdabot>  [(1,2),(2,2),(3,2),(4,2),(5,2)]
03:34:28 <Cale> http://cale.yi.org/index.php/Fold_Diagrams -- now that it's looking correct
03:34:29 <lambdabot> Title: Fold Diagrams - CaleWiki
03:36:14 <|Steve|> I see.
03:41:59 <DRMacIver> Hm
03:44:23 <DRMacIver> Am I going mad here? I can't seem to get let declarations in do blocks to work when I use the { ; } version rather than indentation
03:45:20 <DRMacIver> main = do { let foo = "bar"; putStrLn foo } gives me a parse error while the indented version works.
03:45:34 <DRMacIver> (parse error on input `putStrLn')
03:50:04 <olsner> > do { let foo = "bar"; putStrLn foo }
03:50:05 <lambdabot>  Parse error
03:50:14 <olsner> > do { let {foo = "bar"}; putStrLn foo }
03:50:22 <lambdabot>  <IO ()>
03:50:25 <DRMacIver> Ah
03:50:26 <DRMacIver> Thanks.
04:01:35 <DRMacIver> *headdesk*
04:01:56 <DRMacIver> Clearly I'm too used to Java's odd feature of variables and methods living in a different namespace.
04:02:25 * DRMacIver has just spent the last 10 minutes staring at an incomprehensible type error that resulted from trying to simultaneously have a list of strings called lines and use the lines function.
04:03:11 <olsner> you should've claimed CommonLisp-damage - much cooler than Java damage
04:03:24 <olsner> but now the cat's out of the box anyway
04:04:08 <DRMacIver> Eh, I'm known to be Java damaged. :)
04:04:43 <DRMacIver> Although in this case I suspect it's more accurate to claim lack of coffee damage.
04:06:29 <DRMacIver> Hm. Is there a good option parser for Haskell?
04:06:37 <Baughn> > do { foo <- "bar"; return (chr . (+ 1) . ord $ foo) }
04:06:38 <lambdabot>  "cbs"
04:06:55 <dolio> GetOpt?
04:07:08 <Baughn> What sort of parsing are you thinking about?
04:07:15 <DRMacIver> dolio: Ah, didn't see that. :)
04:07:40 <DRMacIver> Hm. The GetOpt page linked to from hoogle 404s.
04:07:44 <olsner> > map (char . (+ 1) . ord) "bar"
04:07:45 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
04:07:51 <olsner> > map (chr . (+ 1) . ord) "bar"
04:07:54 <lambdabot>  "cbs"
04:08:07 <DRMacIver> Baughn: Nothing very complicated. Just a bunch of command line flags for customising behaviour. ./doStuff --foo=bar baz for example.
04:08:11 <mux> > map (chr . (+ 1) . ord) "HAL"
04:08:14 <lambdabot>  "IBM"
04:08:21 <olsner> @hoogle Char -> Int -> Char
04:08:22 <lambdabot> No matches, try a more general search
04:08:24 <Baughn> > [ chr (+ 1 (ord x)) | x <- "foo" ]
04:08:25 <lambdabot>      The section `(+ (1 (ord x)))' takes one argument,
04:08:26 <lambdabot>     but its type `Int'...
04:08:41 <mux> > map (toEnum . (+1) . fromEnum) "HAL"
04:08:42 <lambdabot>  [73,66,77]
04:09:02 <DRMacIver> Hm
04:09:07 * DRMacIver -> food
04:09:12 <olsner> > (map (toEnum . (+1) . fromEnum) "HAL") :: String
04:09:13 <lambdabot>  "IBM"
04:09:17 <Baughn> > [ chr (1 + (ord x)) | x <- "foo" ]
04:09:19 <lambdabot>  "gpp"
04:09:30 <Baughn> Ahha! I claim common lisp brain-damage.
04:10:07 <olsner> @hoogle (Enum a, Num b) => a -> b -> a
04:10:08 <lambdabot> Prelude.const :: a -> b -> a
04:10:08 <lambdabot> Prelude.seq :: a -> b -> b
04:10:08 <lambdabot> Control.Parallel.par :: a -> b -> b
04:10:17 <Baughn> DRMacIver: ...you've got cannibals over for dinner?
04:10:18 <saturday> polish notaion is the shit
04:10:22 <mux> > let word = "HAL" in (map (toEnum . (+1) . fromEnum) word) `asTypeOf` word
04:10:24 <lambdabot>  "IBM"
04:10:32 <mux> h98 baby
04:10:56 <olsner> > map succ "HAL"
04:10:58 <lambdabot>  "IBM"
04:11:11 <mux> heh, I was getting there =)
04:11:32 <Baughn> :t asTypeOf
04:11:35 <lambdabot> forall a. a -> a -> a
04:12:03 <dolio> @src asTypeOf
04:12:03 <lambdabot> asTypeOf = const
04:12:29 <Baughn> :t const
04:12:31 <lambdabot> forall a b. a -> b -> a
04:12:34 <Baughn> ..that's not right.
04:12:40 <mux> yeah it is
04:12:48 <mux> all the magic lies in the type signature
04:12:49 <Baughn> Okay, but src is missing a type signature
04:12:58 <olsner> :t let f :: a -> a -> a = const in f
04:12:59 <mux> oh
04:13:02 <lambdabot> Not in scope: type variable `a'
04:13:02 <lambdabot>  
04:13:02 <lambdabot> <interactive>:1:14: Not in scope: type variable `a'
04:13:40 <olsner> :t let f = const :: a -> a -> a in f
04:13:43 <lambdabot> a -> a -> a in f :: forall a. a -> a -> a
04:14:31 <olsner> :t let f = const in f
04:14:35 <lambdabot> forall a b. a -> b -> a
04:14:53 <olsner> I think lambdabot borked the formatting on that previous one
04:17:32 <dolio> It gets confused when you use ::
04:18:09 <dolio> :t let f = (const :: a -> a -> a) in f
04:18:11 <lambdabot> forall a. a -> a -> a
04:19:00 <dons> :t const
04:19:02 <lambdabot> forall a b. a -> b -> a
04:19:24 <dons> ?src const
04:19:24 <lambdabot> const x _ = x
04:19:46 <dons> -- | 'asTypeOf' is a type-restricted version of 'const'.  It is usually
04:19:46 <dons> -- used as an infix operator, and its typing forces its first argument
04:19:46 <dons> -- (which is usually overloaded) to have the same type as the second.
04:19:46 <dons> asTypeOf        :: a -> a -> a
04:19:46 <dons> asTypeOf        =  const
04:20:22 <dons> all from the days before lexically scoped tyvars, and types decls in patterns
04:20:48 <dons> now days you just add a type constraint, f (x :: a) = ... (v :: a) ..
04:27:08 * dolio has been fooling with delimited continuations for hours.
04:27:50 <dolio> I was a bit disappointed to remember that the code uses unsafeCoerce.
04:28:03 * mehrheit wonders in what situations continuations might be useful
04:28:27 <mux> IOHCC
04:29:15 <Baughn> mehrheit: Whenever you'd use lazy evaluation, I've found
04:30:19 <Botje> mehrheit: you can use continuations to implement the [] monad.
04:30:29 <Botje> esp. the backtracking aspect of it
04:33:26 <dons> mehrheit: the binary serialisation in Data.Binary is done via continuations
04:33:46 <dons> decoding a value to bytes is interleaved with generating of chunks of lazy bytestrings
04:34:18 <dons> delimited continuations are used for some pretty cool things
04:34:23 <mehrheit> okay, I still have a lot to learn about them
04:34:43 <dons> the list zipper at the heart of xmonad window manager is a reified delimited continuation, in one view
05:14:05 <dancor> what is a good way to do fonts in X
05:14:08 <dancor> sdl?
05:15:03 <dons> Xlib? gt2hs?
05:23:20 <kfish> dancor: gtk2hs is neat (fonts on cairo with pango)
05:26:33 <kfish> http://darcs.haskell.org/gtk2hs/demo/cairo/Text.hs
05:30:51 <lumi> Hi, I made a library that I think might be useful to Haskellers of the world, and I was wondering how best to release it as open source
05:31:45 <Heffalump> cabalise it, stick it on hackage
05:31:50 <Heffalump> pick a licence
05:32:01 <Heffalump> stick a darcs repo on the web somewhere if possible
05:32:47 <Saizan> and add haddock documentation
05:32:56 <twanvl> and announce it on haskell@haskell.org
05:33:14 <dons> we even have a page describing this process,
05:33:27 <dons> here http://haskell.org/haskellwiki/How_to_write_a_Haskell_program
05:33:29 <lambdabot> Title: How to write a Haskell program - HaskellWiki
05:33:41 <lumi> Ah, lovely, thank you very much
05:33:45 <Heffalump> what's it do?
05:33:59 <lumi> It's a generator combinator library
05:34:13 <lumi> I haven't yet checked whether its overlap with Quickcheck can be bridged
05:34:16 <Heffalump> generate what?
05:34:26 <lumi> Generic
05:34:27 <Heffalump> random data?
05:34:38 <lumi> Actually it enumerates a structure
05:34:44 <lumi> Err
05:34:45 <dons> ah, generators in the quickcheck style?
05:34:50 <lumi> I guess that's not quite clear
05:34:51 <lumi> Yes
05:34:52 <Heffalump> have you seen SmallCheck?
05:34:55 <dons> have you seen the QC2 generators?
05:35:04 <lumi> No, I haven't
05:35:09 <lumi> I sort of built this by need
05:35:10 <dons> (things like NonNegative Int)
05:35:14 <Heffalump> http://www.cs.york.ac.uk/fp/darcs/smallcheck/README
05:35:46 <dons> yeah, the main similar works would be QC2's generators, and smallcheck's
05:36:03 <lumi> I'm using this for a certain textual hierarchic-structured language which I'm refraining from mentioning for some reason
05:36:43 <lumi> I've found that the search spaces tend to be phantasmagorically huge, and my main interest atm is actually how to make cases more interesting
05:37:06 <lumi> It's quite possible I'm Doing It Wrong, which is another reason to open-source :)
05:38:21 <lumi> Oh, huh. SmallCheck looks to be quite lovely with this
05:39:06 <lumi> I gave up on just using types for generation, because I got to using phantom blahs and GADT blahs just to get finite depth
05:39:33 <lumi> My coworkers find Haskell daunting enough without that
05:53:02 <dolio> !paste
05:53:02 <hpaste> Haskell paste bin: http://hpaste.org/
05:55:02 <hpaste>  dolio pasted "delimited continuations + transformers" at http://hpaste.org/390
06:10:43 <KOC> I want to use the debugger apparently available in GHCi but my version doesn't seem to have it (6.4.2 on Gentoo). Is this a new feature, or...?
06:11:04 <LoganCapaldo> yes its new
06:11:09 <psymort> Cale: back again - figured out how that func works now.  Thanks for the help.
06:11:19 <LoganCapaldo> so noew its only in HEAD afaik
06:11:21 <Cale> psymort: No problem
06:12:39 <psymort> Cale: did work out one thing though - my original version had the if check to try and stop reading rs once it found everything, where as this version doesn't.  But I'll work out a way to add it back in :)
06:13:17 <psymort> cale: yours is _way_ faster though (and constant space)
06:13:32 <Cale> :)
06:16:51 <psymort> Q: does anyone have any good references for writing unit tests of haskell code?  One thing I'm interested in is dependency breaking (using stubs / mocks - if there are such things in haskell?)
06:18:26 <LoganCapaldo> psymort: for pure code you don't need stubs / mock. For impure code, pehaps IOSpec will rub you the right way
06:19:33 <LoganCapaldo> Maybe claiming you don't need stubs / mocks was too strong of a claim in retrospect.
06:19:49 <LoganCapaldo> Rather I should say hopefully you don't need em
06:20:24 <Cale> If you need stubs, you could insert 'undefined' wherever you do.
06:20:39 <LoganCapaldo> psymort: XMonad might be good to look at the source of , testing wise
06:20:42 <Cale> (or better yet:  error "stub!"
06:20:43 <Cale> )
06:20:56 <hkBst> psymort: http://en.wikipedia.org/wiki/QuickCheck
06:20:57 <lambdabot> Title: QuickCheck - Wikipedia, the free encyclopedia
06:20:58 <Cale> There's HUnit and QuickCheck, which I suspect you'll be interested in
06:21:09 <LoganCapaldo> I understand it's chock fulla good QC specifications
06:21:17 <psymort> cool - I'll check those out.
06:22:02 <Saizan> uhm, with tails = scanr (:) [] you lose sharing of the cons cells between the input list and the "tails", isn't tails xs = scanl (const . tail) xs xs better?
06:22:20 <psymort> logan: you might be right about the stubs / mocks.  I'm not sure how you'd use mocks in a functional language, as the setting and checking of expectations are stateful.
06:25:54 <LoganCapaldo> @src tails
06:25:54 <lambdabot> tails []         = [[]]
06:25:54 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
06:26:22 <LoganCapaldo> they seem to have gone the "sharing" way
06:26:33 <LoganCapaldo> albeit w/o a HOF
06:26:59 <LoganCapaldo> (course who knows what the actual code in an actual impl. is)
06:27:42 <LoganCapaldo> @source tails
06:27:43 <lambdabot> tails not available
06:27:48 <LoganCapaldo> @source Data.List
06:27:49 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
06:28:25 <LoganCapaldo> appears to be the same defn as lb
06:30:13 <Saizan> ?index getArgs
06:30:13 <lambdabot> System.Environment
06:32:22 <LoganCapaldo> Does anyone else kinda wish args was an argument passed to main? Or has C broken my mind?
06:33:05 <Saizan> i wish it was in the prelude
06:34:17 <Cale> LoganCapaldo: The trouble is, they can be set later.
06:34:21 <hpaste>  (anonymous) pasted "sierpinsky factorisation" at http://hpaste.org/391
06:34:38 <Cale> @type System.Environment.withArgs
06:34:46 <lambdabot> forall a. [String] -> IO a -> IO a
06:34:59 <LoganCapaldo> Cale: I never saw a good reason for being able to set those. if there arguments, you coan just call main again with different params. I may be blubbing though.
06:35:21 <Cale> It is a little odd.
06:36:06 <LoganCapaldo> my use case is thos eprograms that change behavior based on the name, eg: main ("list":args) = ... ; main ("install":args) = ...
06:36:25 <LoganCapaldo> (of course I'm also throwing in that the program name should be part of the args list)
06:36:43 <LoganCapaldo> ah well
06:36:47 <LoganCapaldo> it is what it is
06:36:50 <Cale> You can of course just do:  main = getArgs >>= main'
06:36:57 <LoganCapaldo> yep
06:37:20 <Cale> You could even pass the whole environment as a parameter too :)
06:37:22 <LoganCapaldo> which is what I'd do if ever found myself actually wanting to use that idiom
06:37:26 <LoganCapaldo> heh
06:50:15 <gkr> Does anyone have a tutorial about implementing data types in Lambda caluclus?
06:59:32 <Philippa> gkr: I smell a homework question. I'm going to be nice: look up "church encoding"
07:04:01 <LoganCapaldo> gkr: why yesm yes I do have  atuorial about implementing data types in lambda calculus
07:04:22 <LoganCapaldo> gkr: hope you like ruby syntax http://meta-meta.blogspot.com/2007/06/church-code.html
07:04:23 <lambdabot> Title: Meta-Meta: The Church Code
07:08:19 <Saizan> can a sleeping process use CPU?
07:11:15 <Lemmih> Saizan: If it dream of electric sheep, yes.
07:12:25 <Saizan> :D
07:21:00 <gkr> LoganCapaldo, Philippa, thanks.
07:21:44 <sorear> (hello)
07:21:45 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
07:21:50 <sorear> @messages
07:21:51 <lambdabot> nominolo said 4h 35m 7s ago: yes i, realized to late. I write an explainatory mail to the list
08:00:39 <psymort> Does anyone have a reference to the implementation of foldl' ?
08:00:59 <Lemmih> ?src foldl'
08:01:00 <lambdabot> foldl' f a []     = a
08:01:00 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
08:02:13 <psymort> thanks bot :)
08:02:23 <psymort> (and lemmih)
08:05:23 <psymort> @type foldl'
08:05:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:05:44 <sorear> grr, no Eval a => constraint :)
08:08:39 <psymort> ?type foldl'
08:08:41 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
08:12:15 <psymort> ?type scanl'
08:12:19 <lambdabot> Not in scope: `scanl''
08:17:49 <matthew-_> Am I right in thinking that Clean uses uniqueness types where Haskell uses monads for IO?
08:19:25 <sorear> Yes.
08:19:41 <sorear> And where Haskell uses monads for !IO Clean has nothing :)
08:20:11 <sorear> > foldr (flip (.) . (:)) id "Higher order foldr to reverse!" []
08:20:12 <lambdabot>  "!esrever ot rdlof redro rehgiH"
08:28:18 <matthew-_> sorear: that was in Monad Reader a couple of issues back
08:28:36 <matthew-_> well, close anyway - the various implementations of dropWhile
08:28:49 <Heffalump> foldl in terms of foldr is a more general instance of that
08:29:26 <Japsu> @unpl (flip (.) . (:))
08:29:26 <lambdabot> (\ i c f -> c (((:)) i f))
08:29:47 <kmb> Is it possible in haskell to dynamically call a function at runtime?  (I suspect not...)
08:30:01 <Heffalump> kmb: what do you mean by dynamically?
08:30:09 <ibid> depends on what you mean by dynamically
08:30:16 <Heffalump> if you are thinking of dynamic loading of Haskell code, lookup hs-plugins
08:31:10 <kmb> I mean ala Java's Method.invoke(obj, args)
08:31:23 <kpreid> no need
08:31:27 <kpreid> just pass it and call it
08:31:55 <ibid> kmb: if you have the function, you can call it. no need for any "invoke" thingy
08:32:08 <kmb> I mean if I have the name of a function as a string for example, and I want to invoke it.
08:32:32 <ibid> kmb: no compiler magic for that
08:32:34 <kpreid> hs-plugins might be able to do that? otherwise, make a table
08:32:34 <Heffalump> the thing about Haskell is that functions are first-class
08:32:48 <Heffalump> so you might as well just pass around the function as a string giving its name
08:32:49 <ibid> kmb: there the problem is converting the string to a function, not calling it
08:33:02 <Heffalump> if you want the user to be able to specify it, just make a big table, perhaps with a pre-processor
08:33:25 <ibid> kmb: if there is a limited number of functions you want to call this way, just do what Heffalump just said
08:34:28 <kmb> That is not a generic solution, which is what I'm looking for.  I would like and open-ended way to get a function reference for a string.
08:35:02 <kpreid> kmb: perhaps eval is the answer, which hs-plugins provides
08:35:10 <kpreid> > words
08:35:13 <lambdabot>  <[Char] -> [[Char]]>
08:35:19 <kpreid> lambdabot uses hs-plugins
08:35:23 <kpreid> > unwords
08:35:26 <lambdabot>  <[[Char]] -> [Char]>
08:35:31 <Heffalump> kmb: but in a compiled program, the set of functions is closed
08:35:37 <ibid> kmb: there is no generic reflection capability, that's true
08:35:39 <kpreid> so use eval to pick out the function and then call it
08:35:47 <ibid> kmb: though they say hs-plugins might help there :)
08:35:50 <kpreid> of course, it has to be of a predetermined type
08:35:58 <Heffalump> so I don't understand why you would want an open-ended mechanism unless you want to dynamically load code too
08:36:02 <kpreid> unless the call is in the eval as well
08:36:30 <kpreid> another thing is, for the table-based approach, you don't have to name the functions outside the table!
08:37:06 <kpreid> [("foo", \x -> "foo" ++ x), ("bar", reverse), ("baz", show . (1+) . read)]
08:37:13 <ibid> any such reflection would just be this table thing under the hood, btw :)
08:37:27 <ibid> (unless it actually involves compiling. ugh)
08:37:38 <kpreid> well, there's a bit of a difference in using a table already built for the linker...
08:38:17 <ibid> the linker just cares about name-address mappings. is that enough?
08:38:28 <kpreid> I don't know. .hi files?
08:38:43 <ibid> are not part of the executable in a normal case :)
08:38:51 <kpreid> another thing
08:39:23 <kpreid> given a .hs one could easily parse it and generate a module containing a table of everything it exports
08:39:33 <kpreid> the only hard part would be ensuring type compatibility
08:39:33 <ibid> yep
08:41:12 <kmb> The point of my question is that I'm thinking of a program that evaluates a workflow configuration file, which specifies (directly or indirectly) the names of functions (as strings, naturally) to carry out certain actions.
08:41:57 <kmb> These functions may or may not be part of the original program.  They may come from add-on code written later.
08:41:58 <Heffalump> and where would these functions be defined?
08:42:07 <Heffalump> so how do you intend this add-on code to be loaded?
08:42:14 <Heffalump> sounds like a job for hs-plugins, anyway
08:42:25 <kmb> So hs-plugins could be the answer, but building tables from source code is not.
08:44:45 <Heffalump> it would be better to build tables from source code for each add-on, IMO
08:44:54 <Heffalump> and then export the table with hs-plugins
08:45:08 <Heffalump> but you could probably also just use "eval" or whatever it's called to do things directly
08:46:54 <kmb> ok, just read the example on the hs-plugins site, and that is what I want.  Thanks!
09:14:20 <Saizan> gshow' x = if typeOf x == typeOf (undefined :: String) then fromJust (cast x) else gshow x <-- this looks horrendously like a Java downcast :\
09:16:46 <int-e> hmm. case cast x of { Just x -> x; _ -> gshow x }
09:17:19 <Saizan> uuuh, way better
09:17:30 <int-e> maybe (gshow x) id (cast x)
09:17:45 <Saizan> we have Maybe for a reason :)
09:18:07 <int-e> fromMaybe (gshow x) (cast x) -- I keep forgetting about fromMaybe
09:18:54 <Saizan> :t fromMaybe
09:18:57 <lambdabot> forall a. a -> Maybe a -> a
09:20:41 <byorgey> @src fromMaybe
09:20:42 <lambdabot> fromMaybe d x = case x of {Nothing -> d;Just v  -> v}
09:21:07 <byorgey> @type cast
09:21:09 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
09:21:35 <byorgey> @type gshow
09:21:38 <lambdabot> Not in scope: `gshow'
09:22:07 <int-e> @type Data.Generics.gshow
09:22:10 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> String
09:22:30 <byorgey> ah
09:30:13 <nominolo> is there a good patch viewer or even code review system for darcs?
09:32:03 <nominolo> the best i can think of is: mkdir temp-branch; cd temp-branch; darcs pull [...]; diff -u -r . orig-branch
09:33:26 <Saizan> you can see the patches while deciding if you want to pull them
09:33:46 <Saizan> s/pull/apply/
09:36:55 <cdsmith> > [1, 3 .. 10]
09:36:57 <lambdabot>  [1,3,5,7,9]
09:37:02 <cdsmith> > [1.0, 3.0 .. 10.0]
09:37:05 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
09:37:11 <cdsmith> What's up with that?
09:37:17 <byorgey> cdsmith: I stumbled on that gotcha the other day too.
09:38:04 <byorgey> cdsmith: it's explained in the Haskell 98 report, but the idea is that for non-Integer types, enumerations continue as long as the terms are less than or equal to the common difference / 2.
09:38:05 <cdsmith> It's unusual, to say the least; and very counter-intuitive.
09:38:09 <byorgey> indeed
09:38:29 <byorgey> wait, I didn't explain that exactly right
09:39:03 <byorgey> in your case, the common difference is 2, and 11.0-10.0 <= 2/2, so 11.0 is included
09:39:57 <HWSOD> that is very wierd whats the motivation?
09:40:45 <byorgey> HWSOD: I'm guessing it has something to do with inaccuracies of floating-point numbers
09:41:06 <byorgey> > [0.0,1/3..3]
09:41:09 <lambdabot>  [0.0,0.3333333333333333,0.6666666666666666,1.0,1.3333333333333333,1.66666666...
09:41:15 <byorgey> > [0.0,1/3..1
09:41:15 <lambdabot>  Parse error
09:41:17 <byorgey> > [0.0,1/3..1]
09:41:19 <DRMacIver> Hm. For all that Haskell is a really lovely language in most respects, it has some really perverse corner cases. :)
09:41:19 <lambdabot>  [0.0,0.3333333333333333,0.6666666666666666,1.0]
09:41:26 <byorgey> DRMacIver: indeed...
09:41:37 <cdsmith> I suppose if one were to have a common difference in the neighborhood of one ulp, it might be easier to implement that way?
09:41:48 <byorgey> in the case above, 0.333333... times three might actually be slightly bigger than 1 due to inaccuracies
09:42:03 <byorgey> cdsmith: something like that
09:43:35 <byorgey> > [1,3..10] :: [Rational]
09:43:36 <lambdabot>  [1%1,3%1,5%1,7%1,9%1,11%1]
09:43:42 <cdsmith> If it's supposed to be somehow *more* intuitive (i.e., the 1.3 case above), then I think it's failed.
09:44:08 <byorgey> cdsmith: agreed.  and check out the Rational case above.  Obviously the "inaccuracies" argument doesn't hold water here.
09:44:31 <cdsmith> (oops, shoulda been "1/3", not "1.3")
09:45:07 <cdsmith> @src enumFromThenTo
09:45:07 <lambdabot> Source not found. My pet ferret can type better than you!
09:45:16 <cdsmith> drat
09:45:23 <sorear> @src Double enumFromThenTo
09:45:23 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:45:29 <byorgey> @src Data.Ratio enumFromThenTo
09:45:29 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:46:30 <byorgey> anyway, silly weirdness all around.  I just try not to rely on the behavior of enumFromThenTo and brethren for anything other than Integral types...
09:47:38 <cdsmith> I ran across it when explaining arithmetic sequences to a Haskell newbie.  Worst possible time.
09:48:18 <byorgey> cdsmith: lol, I'll bet
09:48:51 <byorgey> "and then if you type something like this, you get... what the hell!?"
09:49:20 <cdsmith> He was actually less concerned.  He wanted an error because 10 isn't in the sequence.
09:49:32 <cdsmith> (in both cases, but especially the Int case)
09:49:38 <byorgey> cdsmith: ah, I see.
09:49:56 <byorgey> I actually think it's pretty useful to be able to specify an ending value that isn't in the sequence
09:50:02 <cdsmith> I agree.
09:50:23 <cdsmith> Especially with floating point types, of course.
09:50:36 <byorgey> right.
09:51:12 <byorgey> well, tell him to make a newtype on top of Int and implement his own instance of Enum =)
09:51:22 <cdsmith> > [1.0, 2.0, .. 10.1]
09:51:22 <lambdabot>  Parse error
09:51:36 <cdsmith> > [1.0, 2.0 .. 10.1]
09:51:44 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
09:52:02 <cdsmith> That's better than I thought.  I'd originally thought it was always overrunning the bound by one for floats
09:52:23 <byorgey> that's what I originally thought too, but then I read up on it in the Report.
09:52:25 <ndm> @pl \p _ s -> cont p s
09:52:26 <lambdabot> const . cont
09:52:39 <byorgey> > [1.0, 2.0 .. 4.49]
09:52:40 <cdsmith> byorgey++
09:52:41 <lambdabot>  [1.0,2.0,3.0,4.0]
09:52:44 <byorgey> > [1.0, 2.0 .. 4.5]
09:52:46 <lambdabot>  [1.0,2.0,3.0,4.0,5.0]
09:53:00 <byorgey> @karma
09:53:00 <lambdabot> You have a karma of 1
09:53:05 <byorgey> woo, my first karma point! =)
09:53:09 <cdsmith> :)
09:53:18 <weitzman> There's an easy way to burn your karma
09:53:21 <weitzman> java++
09:53:23 <weitzman> @karma
09:53:24 <lambdabot> You have a karma of -2
09:53:26 <weitzman> java++
09:53:28 <Japsu> :D
09:53:28 <weitzman> @karma
09:53:28 <lambdabot> You have a karma of -3
09:53:33 <byorgey> lol
09:53:39 <Japsu> @karma C
09:53:39 <lambdabot> C has a karma of 2
09:53:48 <cdsmith> @karma java
09:53:48 <lambdabot> java has a karma of -16
09:54:02 <cdsmith> @karma
09:54:02 <lambdabot> You have a karma of 0
09:54:17 <chessguy> does haskell have issues with comparing floating point numbers using == ?
09:54:24 <chessguy> (like most languages)
09:54:42 <cdsmith> chessguy: A problem?  What do you mean?
09:54:53 <byorgey> chessguy: haskell compares floating point numbers with == as accurately as possible, just like most languages
09:55:10 <byorgey> it's not Haskell that has issues, it's floating point numbers
09:55:21 <cdsmith> It's usually a bad idea, but I'm not aware of any language that does it incorrectly.
09:55:33 <HWSOD> > (1 / 3.0) + (1 /3.0) + (1/ 3.0) /= 1
09:55:34 <lambdabot>  True
09:55:51 <HWSOD> >(1/3.0)
09:55:55 <chessguy> ah, good example
09:56:33 <chessguy> hm. i thought haskell had arbitrary precision
09:56:38 <chessguy> i guess that's only for integers
09:56:44 <cdsmith> chessguy: with Data.Ratio it does
09:57:03 <byorgey> chessguy: right, arbitrary precision is only for Integer.
09:57:11 <cdsmith> chessguy: there is no such thing as an arbitrary precision real number that fits into finite memory.
09:57:12 <chessguy> > (1 / 3.0) + (1 /3.0) + (1/ 3.0)
09:57:14 <lambdabot>  1.0
09:57:18 <byorgey> chessguy: however, there are various libraries for doing stuff with arbitrary-precision reals
09:57:28 <HWSOD> > (1%3) + (1%3) + (1%3) == 1
09:57:30 <lambdabot>  True
09:57:37 <chessguy> > (1 / 3.0) + (1 /3.0) + (1/ 3.0) == 1.0
09:57:39 <lambdabot>  False
09:57:47 <cdsmith> byorgey: you mean rationals, not reals (I'm being picky)
09:57:47 <chessguy> gotta love it
09:58:01 <byorgey> cdsmith: good point.
09:58:03 <olsner>  > (1%3) + (1%3) + (1%3)
09:58:08 <olsner> > (1%3) + (1%3) + (1%3)
09:58:10 <lambdabot>  1%1
09:58:19 <chessguy> > 1%1 == 1
09:58:21 <lambdabot>  True
09:58:30 <olsner> aha! (%) /= mod
09:58:42 <cdsmith> olsner: right!
09:58:44 <byorgey> olsner: nope =)
09:58:46 <sioraiocht> Prelude> 1 / 3.0 + 1 / 3.0 + 1 / 3.0 == 1
09:58:47 <sioraiocht> True
09:58:49 <chessguy> @type (%)
09:58:51 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:59:04 <chessguy> @hoogle Ratio
09:59:05 <lambdabot> Data.Ratio :: module
09:59:05 <lambdabot> Ratio :: module
09:59:05 <lambdabot> Data.Ratio.Ratio :: data Ratio a
09:59:10 <chessguy> @hoogle+
09:59:10 <lambdabot> Prelude.Rational :: type Rational
09:59:11 <lambdabot> Language.Haskell.TH.RationalL :: Rational -> Lit
09:59:11 <lambdabot> Language.Haskell.TH.rationalL :: Rational -> Lit
09:59:50 * byorgey goes off to make gazpacho
10:00:05 <cdsmith> byorgey: good luck.  Sounds good.
10:00:24 <chessguy> i hope it turns out better than my shrip alfredo...
10:08:06 <ndm> @karma+ Igloo -- fixing Windows README bugs
10:08:07 <lambdabot> Igloo's karma raised to 21.
10:45:09 <fasta> Can I get a warning when I put the same value in a data structure twice when another variable that is in scope is not used?
10:45:44 <Lemmih> fasta: Yes.
10:46:27 <fasta> Lemmih: how?
10:46:49 <Lemmih> fasta: -fwarn-unused-binds
10:52:27 <fasta> Heh, I get a gigantic list.
10:52:42 <fasta> Lemmih: thanks
10:53:43 <hpaste>  setuid_w00t pasted "Why doesn't this compile?" at http://hpaste.org/392
10:54:17 <setuid_w00t> whoa, something weird happened there
10:54:41 <setuid_w00t> I got it
10:54:50 <setuid_w00t> Those weren't minus signs
11:22:32 <setuid_w00t> How would you model the following in Haskell?  I have a polygon that is composed of a bunch of tuples of (x,y) pairs.  I was initially thinking of using a list and having the last item in the list and the first close the polygon.  The problem with this approach is that certain algorithms are complicated by this representation.  Say I want to iterate through the points and call a function on the next 3 points.  That becomes a pain
11:22:32 <setuid_w00t> at the end of the list because the next element and the one after it are at the beginning of the list.
11:23:39 <Heffalump> there's not obvious representation for cyclic structures
11:23:59 <Heffalump> but you could expose an interface saying "give me all the points in groups of n" or similar
11:24:03 <ndm> you can do: operate (x ++ take 1 x)
11:24:04 <lambdabot> ndm: You have 3 new messages. '/msg lambdabot @messages' to read them.
11:24:10 <ndm> then you get the closedness for free
11:24:14 <ndm> @messages
11:24:14 <lambdabot> sorear said 2d 20h 20m 22s ago: No.
11:24:14 <lambdabot> sorear said 2d 20h 19m 14s ago: Because I (a) haven't gotten that far (b) need to support arcane features like type checking which want to annotate the AST (c) want to support GHC and non-GHC
11:24:14 <lambdabot> extensions
11:24:14 <lambdabot> sorear asked 2d 20h 17m 36s ago: In supero - how about using pure Reynolds for the first stage. The second stage should be able to clean up the mess just fine, and it would avoid the complexities of
11:24:14 <lambdabot> making code completely first order by the Mitchell algorithm.
11:24:19 <beelsebob> ndm: not quite
11:24:28 <beelsebob> because you get overlaps
11:24:37 <beelsebob> you would have to trim the reresentation after doing the opp again
11:24:49 <ndm> beelsebob: either your algorithm likes overlaps, or it doesn't - i'm guessing the one which doesn't is the one he's having problems implementing
11:24:58 <ndm> but yes - you might need to canonicalise afterwards
11:25:00 * sorear unobtrusively makes his presence known
11:25:10 <beelsebob> setuid_w00t: which algorithms are you refering to?  Things like calculating cubic bezier curves?
11:25:16 <quicksilver> with certain algorithms it my sufficie to use 'cycle' on your list
11:25:19 * beelsebob taking a guess at one that needs 3 points
11:25:26 <beelsebob> indeed, that would work too
11:25:27 <quicksilver> > cycle [(1,2),(2,1),(0,1)]
11:25:28 <lambdabot>  [(1,2),(2,1),(0,1),(1,2),(2,1),(0,1),(1,2),(2,1),(0,1),(1,2),(2,1),(0,1),(1,...
11:25:48 <ndm> sorear: i replied to your @message - a very clever idea about doing reynolds first - still thinking if its feasible
11:25:57 <quicksilver> you could store the pair 'number of points, infinite (cyclic) list'
11:26:02 <quicksilver> that might work :)
11:26:09 <ndm> sorear: and re your TH, it would be nice if you were a superset of TH, so you could use Data.Derive over it
11:26:13 <setuid_w00t> beelsebob: I am just toying around.  I was thinking that I could determine whether a polygon is convex or not by using the cross product at each vertex in the polygon
11:26:36 <beelsebob> cyclicOp f x = take (length x) (f (cycle x))
11:26:43 <beelsebob> that would work...
11:26:45 <ndm> is the Haskell Equational Reasoning assistant still not online?
11:26:59 <beelsebob> so you can then wrap any function that needs it to be able to wrap around, in cyclicOp
11:27:23 <fasta> setuid_w00t: HSOE?
11:27:28 <setuid_w00t> fasta: yes
11:28:01 <fasta> setuid_w00t: You are the 3rd person that asks that question in this channel.
11:28:05 <setuid_w00t> haha
11:28:35 <setuid_w00t> I think it is a pretty hard problem given the position in the book
11:28:54 <fasta> setuid_w00t: I will say what I said earlier: HSOE tries to learn you problem solving skills.
11:29:37 <beelsebob> s/learn/teach/
11:29:44 <fasta> setuid_w00t: I personally don't think the problems are very hard.
11:29:48 <fasta> beelsebob: thank you
11:31:05 <matthew-_> does lhs2TeX not play nice with beamer?
11:31:31 <matthew-_> I'm getting odd errors as the result of a code block within itemize
11:38:25 <matthew-_> ignore that, have made it work!
11:44:51 <fasta> My ghc uses 172MiB. Isn't that a lot considering that I only have loaded a module and I am not running anything?
11:45:09 <Heffalump> how big is the module?
11:45:32 <Heffalump> I've got GHC up to about 600 or 700MB by just loading a (big) program
11:46:47 <fasta> Heffalump: you mean the rec. trans. closure?
11:47:09 <fasta> Heffalump: about 4KOC, I think, including comments.
11:47:14 <fasta> KLOC*
11:47:39 <Heffalump> that sounds weird, then.
11:47:58 <fasta> Heffalump: the process runs for almost 3 hours, though
11:47:59 <Heffalump> the thing I'm talking about is probably 10s of KLOC.
11:48:05 <Heffalump> just to load the module?
11:48:17 <fasta> Heffalump: It's now doing nothing.
11:48:29 <fasta> Heffalump: oh, no, maybe it has cached values
11:48:36 <Heffalump> ah, right
11:48:48 <Heffalump> that sounds likely
11:50:01 * Heffalump looks at fasta's trac report from yesterday (http://hackage.haskell.org/trac/ghc/ticket/1456) and wonders what GHC.Prim.Any is
11:50:03 <lambdabot> Title: #1456 (Wrong type being derived) - GHC - Trac
11:50:52 <Igloo> There's a bit of text in compiler/prelude/primops.txt.pp about it
11:51:04 <fasta> Heffalump: I reported another bug about that
11:51:11 <fasta> Heffalump: if you find that in 6.6.1 report it
11:51:17 <fasta> Heffalump: SPJ is interested in that
11:52:33 <Heffalump> find what?
11:53:07 <fasta> Heffalump: find Any being derived in 6.6.1
11:53:14 <Heffalump> ah, right
11:54:30 <matthew-_> gimme a nice multiparam type class plz
11:54:50 <fasta> matthew-_: is that a joke?
11:54:52 <sorear> Heffalump: Any is the default type
11:54:52 <matthew-_> no
11:55:06 <fasta> matthew-_: please use English in this channel
11:55:06 <matthew-_> fasta: I need an example of a standard multi-param type class
11:55:08 <sorear> matthew-_: class TypeCheck term type | term -> type
11:55:20 <matthew-_> sorear: mmm, fundeps are coming in in the next slide!
11:55:50 <sorear> matthew-_: class Biplate outer inner where biplate :: outer -> ([inner], [inner] -> outer)
11:56:02 <sorear> cf @where uniplate
11:56:08 <matthew-_> yeah
11:56:21 * matthew-_ thinks
11:56:35 * sorear reads * matthew-_ blinks
11:58:35 <matthew-_> mmm. I think I might use monad state, despite the fundep
11:58:46 <matthew-_> ...and superclass
11:59:28 <sorear> Relations need either dependencies or backtracking to be useful 99% of the time
12:00:55 <matthew-_> true
12:01:14 <fasta> sorear: backtracking? You mean to solve the types?
12:02:39 <Heffalump> sorear: it seems more like a representation of a free type variable.
12:02:58 <Heffalump> what's it actually for?
12:04:29 <fasta> ? What are you talking about?
12:04:59 <Heffalump> GHC.Prim.Any
12:30:22 <mgsloan> does wrapping the numeric classes with a new set get in the way of optimization?
12:36:27 <mgsloan> any one familiar with ghc's optimization stuff care to enlighten?
12:37:51 <HWSOD> to all- if you wanted to do a exe with a GUI in Haskell on MS Windows what would you recommend?
12:38:58 <quicksilver> mgsloan: what do you mean with a 'new set'?
12:39:19 <mgsloan> new classes/instances that wrap the old
12:39:27 <Heffalump> do you mean the games with (+) that you were talking about before?
12:39:30 <mgsloan> like the numerics prelude
12:39:36 <mgsloan> right
12:39:42 <quicksilver> mgsloan: shouldn't make any difference if it's all visible at compile-time
12:39:48 <quicksilver> mgsloan: it all gets inlined
12:39:51 <mgsloan> ok, cool
12:39:54 <mgsloan> thanks
12:40:03 <quicksilver> mgsloan: it might make a slight difference if you export a non-inlineable polymorphic function
12:40:35 <mgsloan> do class functions count as polymorphic?
12:41:04 <quicksilver> yes
12:41:18 <mgsloan> ah, probably inlineable anyway
12:46:45 <Heffalump> anything small should be inlined
12:46:49 <Heffalump> there are GHC options you can use to check this
12:46:54 <Heffalump> though I forget what they are
12:48:10 <quicksilver> if you export a function of type (Foo a) => a -> a, and it's too large to inline, then you might end up with a dictionary being passed
12:48:25 <quicksilver> however, to be honest, a dictionary is only a tuple and passing them around is not *that* expensive
12:48:31 <quicksilver> but in principle that is an overhead
12:48:45 <quicksilver> for efficient numeric calculation you want everything to inline, clearly
12:48:57 <mgsloan> yeah, we're dealing with unboxed numerics after all
12:49:11 <mgsloan> and going to need them fast..
12:49:58 * mgsloan and one of the cofounders of inkscape are dinking around with the idea of making an animation program in haskell
12:50:21 <quicksilver> if the type is Int -> Int, then you're OK, even thought you might use the class staff inside
12:50:37 <quicksilver> it's only if you export a polymorph you have a potential issue
12:50:52 <mgsloan> instance Addable Integer Integer Integer where (+) = (P.+)
12:50:52 <mgsloan> instance Addable Int     Int     Int     where (+) = (P.+)
12:50:56 <mgsloan> So these are fine?
12:51:12 <mgsloan> I think it infers the proper verson of P.+ for each
12:51:24 <Heffalump> I would hope so, but to be sure you should inspect the Core GHC produces.
12:51:40 <mgsloan> alright
12:52:25 <mgsloan> I'm wondering if I should stop trying to fix the prelude and just define +<, -<, *<, and /< ops
12:53:15 <sorear> .
12:53:59 <opqdonut> -< is defined in arrow :)
12:54:05 <mgsloan> arg
12:54:30 <mgsloan> +^, -^, *^, /^.... they take so long to type...
12:54:37 <sorear> opqdonut: No
12:54:51 <mgsloan> probably <- is defined as something or other
12:54:59 <sorear> opqdonut: Data.Arrow does not export -< - it's WORSE!
12:55:05 <shachaf> mgsloan: It's used in do-notation.
12:55:22 <sorear> opqdonut: when you pass -farrows to GHC, -< is lexed as a reservedop.
12:55:39 <sorear> opqdonut: It isn't merely in scope - it's not legal as an identifier!
12:55:49 <opqdonut> sorear: oh, okay
12:55:55 <sorear> like forall
12:55:56 <opqdonut> sounds evil :)
12:55:57 <mgsloan> shachaf: oh, yeah :)
12:56:05 <opqdonut> (but necessary i guess)
12:56:58 <mgsloan> yey for fundeps
12:56:59 <sorear> Not as evil as hiding/as/qualified
12:57:13 <sorear> which are not reservedops - they are non-reserved keywords!
12:57:42 <sorear> every haskell parser has a production of the form  varid : realvarid | QUALIFIED | AS | HIDING
12:58:24 <sorear> -, +, and ! also get special cased due to unary minus, n+k patterns, and datatype strictness annotations, respectively.
12:58:42 <sorear> It would be a whole lot nicer to parse haskell if the lexer wasn't context sensitive :)
13:00:08 <opqdonut> :)
13:00:26 <opqdonut> too much sugar
13:01:04 <mgsloan> definable unary ops would be fun.. then you could have stuff like ^/(100) = 10
13:01:07 <mgsloan> or maybe not..
13:10:34 <sorear> mgsloan: I'm thinking I'll do that for QHC - it sounds simpler than two adhoc unary opeators :)
13:10:49 <dukedave> Could someone explain or link to what exactly n+k patterns are.. They seem to be mentioned quite a lot in here :o
13:10:58 <mgsloan> sorear - cool!
13:11:25 <fasta> dukedave: they are a mistake according to many
13:11:43 <fasta> dukedave: f (n + 1) = n
13:12:01 <dukedave> Well that seems a little silly?
13:12:09 <sorear> Prelude> let{ sq 0 = 0; sq (n+1) = n + sq n } in sq 10
13:12:09 <sorear> 45
13:12:13 <sorear> dukedave: ^^^
13:12:29 <mgsloan> sorear - is there a page for this 'QHC'?
13:12:33 <sorear> dukedave: better matches math notation
13:12:40 <sorear> mgsloan: not yet
13:13:32 <dukedave> Looks a little funny to me
13:13:46 <dukedave> Are most people keen to keep it out of FP then?
13:14:10 <pastorn> http://foldl.com | http://foldr.com
13:14:11 <lambdabot> Title: foldl.com
13:14:23 <pastorn> <3 <3 <3
13:14:34 <ndm> sorear: what happened to shc?
13:19:13 <sorear> @google andy gill snowball haskell compiler
13:19:14 <lambdabot> http://www.cse.ogi.edu/~andy/
13:19:15 <lambdabot> Title: Andy Gill's Home Page
13:19:31 <sorear> ndm: dons told me :)
13:19:42 <ndm> sorear: is that still current?
13:19:53 <ndm> hmm, looks like it
13:19:59 <sorear> ndm: Reusing names sounds like a bad idea either way
13:20:07 <ndm> although if he releases that before the haskell equational reasoning tool i'll be upset!
13:20:21 <sorear> why?
13:20:35 <ndm> sorear: it was at HW06, and its still vapourware :(
13:20:38 <Heffalump> what's QHC?
13:20:46 <ndm> plus looks really cool
13:21:09 <ndm> i'm reserving the name thc for my haskell compiler
13:21:43 <Heffalump> isn't YHC (partly) yours?
13:21:57 <ndm> sorear: i'm going to take a guess that shc is years old, that web page looks very out of date
13:22:14 <sorear> Heffalump: sorear's summer slow haskell compiler project, modulo "./07.06.21-22:08:37 <dons> sorear: SHC is already taken!"
13:22:17 <ndm> Heffalump: yes, large portions are entirely mine, but large portions are also nhc
13:22:40 <ndm> its the nhc portions that need eliminating to have a good Haskell compiler
13:22:43 <sorear> ndm: so thc is the New York compiler?
13:22:52 <sorear> hmm, that's misparsable :)
13:22:59 <ndm> sorear: no, it looks like we might have yhc has the nhc/yhc merge
13:23:07 <mgsloan> what're QHC's main goals?
13:23:08 <ndm> i want nyhc "New York Haskell Compiler"
13:23:09 <Heffalump> waah, too many Haskell compilers, all too confusing :-)
13:23:33 <ndm> thc or bhc will be my compiler project
13:23:41 <ndm> but its got quite a few dependencies before its ready
13:23:54 <sorear> mgsloan: Small and hackable.  Vaporware haskell extensions are a major problem when the only usable compiler is 200kloc
13:23:54 <olsner> oh, and btw, is that New (york haskell compiler) or (New York) haskell compiler?
13:24:01 <ndm> (ready to begin, i should say)
13:24:14 <ndm> olsner: former, but thats why i like the name :)
13:24:14 <mgsloan> sorear: cool!
13:24:32 <mgsloan> an elegant well written haskell compiler would be fun
13:24:35 <olsner> ndm: cool, that's more clever than I assumed it would be ;-)
13:24:50 <ndm> sorear: i also hope it will be based on libraries, rather than a monolithic beast?
13:25:01 <Heffalump> aren't the large number of optimisations GHC does the reason it is usable?
13:25:24 <nominolo> ndm: are the extra packages included in the win32 installer for ghc?
13:25:34 <ndm> Heffalump: no, they chip away at quite a lot, but you could be a lot simpler and still have reasonable speed (i think)
13:25:42 <Heffalump> fair enough
13:25:44 <ndm> Supero will have one optimisation :)
13:25:50 <Heffalump> it'd be really nice to see one really good competitor for GHC
13:25:59 <ndm> nominolo: no idea...
13:26:13 <nominolo> didn't you create it?
13:26:30 <nominolo> "a new style of Windows Installer for GHC 6.6.1, prepared by Neil Mitchell."
13:26:32 <ndm> yes, it's whatever was in the tarball i downloaded
13:26:44 <ndm> i didn't compile any bits, i haven't even installed it on this machine :)
13:26:44 <sorear> ndm: I've been looking at librarization, but it seems like a Hard Problem (to design - implementation would be easy)
13:26:49 <ndm> i suspect it does have most things
13:27:18 <ndm> sorear: have Qhc.Haskell which is your syntax tree, have a parser/pretty printer etc - and then a convertor from Qhc.Haskell to Yhc.Core
13:27:41 <mgsloan> sorear - you might consider this -> http://www.cs.washington.edu/homes/blerner/seminal.html for type-errors
13:27:42 <lambdabot> Title: UW CSE > Benjamin Lerner
13:28:03 <mgsloan> (something like that, I mean)
13:28:35 <ndm> i think a constraint based type checker is the way to go
13:28:37 <mgsloan> keeps the type inference code seperate from the type errors code, and gives better errors to bott
13:28:40 <mgsloan> *boot
13:28:50 <fasta> ndm: ? That has already been done.
13:28:50 <mgsloan> probably, considering that types are constraints ;)
13:29:07 <ndm> fasta: doesn't mean it shouldn't be done that way again ;)
13:29:14 <fasta> ndm: true
13:29:20 * Philippa figures there's room for at least one competitor that's set up to work well with dynamically loaded code, for "can GC code" values of work well
13:29:39 <sorear> ndm: I'm thinking a lot in terms of a polymorphic compilation manager.  processHaskellProgram :: Monad m => AbstractFS m -> [Option] -> (Module iface -> (iface, object)) -> [object]
13:29:54 <sorear> ndm: Haddock and Catch both inhabit that type, fex
13:30:11 <ndm> that would be cool
13:31:48 <Heffalump> Philippa: wouldn't deterministic finalization be enough for that?
13:32:00 <Heffalump> or even just finalizers that did definitely run
13:33:20 <nominolo> that's hacd to guarantee
13:33:33 <nominolo> *hard
13:34:05 <nominolo> also gc-lifeness heuristics is onliny an approximation
13:34:07 <Heffalump> well, I guess if the GC gets round to removing the references to loaded code, then it would also run the finalizers, which could remove the loaded code itself
13:34:21 <nominolo> i think region-based MM is the way to go
13:34:39 <nominolo> oh
13:34:52 <Philippa> Heffalump: it's tricky enough I wouldn't want to add it after the event
13:35:22 <Heffalump> doesn't hs-plugins allow unloading?
13:35:32 <Philippa> it didn't last time I looked
13:35:36 <Philippa> which was admittedly a while back
13:36:11 <Heffalump> seems to have one
13:38:36 <Heffalump> so you just need a way of adding a finalizer to the code references you load
13:38:38 <sorear> Heffalump: hs-plugins has an unload function, but all it does is clean the symbol table
13:39:23 <sorear> Heffalump: GHC can't find all references to a code blob, so I panickedly asked dons a couple months ago.  he told me it's perfectly safe - code has unlimited lifetime
13:39:43 <Heffalump> ah, ok
13:40:06 <sorear> granted, in the VM age memory leaks are almost a nonissue :)
13:40:19 <Heffalump> cos VMs leak like hell anyway?
13:40:20 <sieni> sorear: yeah, right
13:40:41 <sorear> Heffalump: "Virtual Memory"
13:40:47 <matthew-_> does anyone know how to make lhs2TeX perform the same layout calculations in poly mode for comments in a code environment as for code?
13:41:06 <Heffalump> ah, right.
13:41:09 <sorear> matthew-_: the author joined 6 minutes ago
13:41:22 <sorear> oh wait, he just left :(
13:41:23 <Heffalump> I disagree completely, the granularities are completely different.
13:41:39 <sorear> Heffalump: nonsequiter?
13:41:45 <Heffalump> swiert is the author of lhs2TeX?
13:41:52 <Heffalump> are you confusing him and kosmikus?
13:42:03 <Heffalump> about VM making memory leaks a nonissue. But you may have been joking.
13:42:52 <sorear> Heffalump: yep, I was confusing them.
13:43:34 <sorear> Heffalump: Yeah, mostly joking...
13:51:20 <falconair> yesterday I packaged up Martin Erwig's "Probabilistic Programming" library through Cabal and installed it in my local ghc...I haven't changed anything but now I'm getting the following message:
13:51:23 <falconair> <interactive>:
13:51:24 <falconair> ghc-6.6: unable to load package `PFP-1.0'
13:51:50 <falconair> missed one line: /usr/local/lib/PFP-1.0/ghc-6.6/HSPFP-1.0.o: unknown symbol `_PFPzm1zi0_ListUtils_singleton_info'
13:51:56 <iakovz> hello
13:52:13 <mauke> did you rm the source directory?
13:52:39 <falconair> no, i didn't remove anything ... and ghc-pkg list shows PFP-1.0!
14:11:18 <sorear> falconair: odd.  sounds like a versioning issue
14:11:52 <sorear> falconair: cleaning and reinstalling should fix it
14:32:06 <falconair> sorear: clean and reinstall just the PFP library or ghc?  my current ghc version is 6.6 ... through mac ports I have the option of installing 6.7 ... is it a good idea to do so?
14:32:35 <sorear> falconair: PFP, and any library PFP depends on that you didn't upgrade properly
14:33:32 <sorear> GHC wants you to upgrade libraries in a very special way, and breaks in a subtle and nasty way if you fail - long after it is too late to learn from the mistake
14:33:55 <falconair> is there a way for the package to be downloaded, resolve dependencies and install automatically (like port, yum, apt-get, etc.) rather than having to download tar balls and run configure/build/install manually?
14:34:26 <sorear> falconair: I'd rather have aptage working :)
14:34:40 <sorear> falconair: language specific PMs are an intrinsically bad idea
14:35:03 <wolverian> x)http://steve-yegge.blogspot.com/2007/06/rich-programmer-food.html -- has some nice flaming about type theorists :)
14:35:04 <lambdabot> Title: Stevey's Blog Rants: Rich Programmer Food
14:35:09 <wolverian> er, s/x)//
14:35:45 <falconair> ruby and python have such nice package managers, newbies can just type one command and continue experimenting with the language ... not so with haskell :(
14:36:24 <sieni> how so?
14:36:41 <sieni> which platform?
14:36:43 <sieni> windows?
14:37:16 <fasta> falconair: apt-get install works nicely, it's just a lack of libraries, but other programming languages have that same problem.
14:37:40 <falconair> i don't remember the exact comand but I want to be able to say: "haskellgenie install somelibrary" and have all the downloading, building, linking done for me (same goes for finding packages, listing packages, upgrading and uninstalling, etc.)
14:37:52 <falconair> I'm on a mac, so can't use apt-get
14:37:55 <olsner> isn't hackage/cabal moving in that direction?
14:37:57 <fasta> falconair: cabel-get, but it's not done yet
14:38:05 <fasta> cabal-get*
14:38:15 <falconair> cabal-get?  something to look forward to!
14:38:22 <fasta> Or cabal-install or whatever it's called today
14:38:29 <Lemmih> falconair: There is cabal-install and it is ready for use.
14:38:42 <olsner> there's always macports (which doesn't have many haskell libraries though)
14:39:22 <falconair> i installed ghc through macports (woking so far without any probs) ... i'm about to check out cabal-install
14:41:02 <fasta> Lemmih: it's not released, is it?
14:42:08 <Lemmih> fasta: The darcs repo is public.
14:42:28 <fasta> Lemmih: that doesn't count, imho.
14:42:54 <nominolo> @wiki existential_types
14:42:54 <lambdabot> http://www.haskell.org/haskellwiki/existential_types
14:43:56 <Lemmih> fasta: It works fine, though.
14:44:20 <fasta> Lemmih: Does it do dependencies already?
14:45:02 <Lemmih> fasta: Yes.
14:45:53 <Lemmih> It has been capable of downloding dependencies from hackage since 2005.
14:47:08 <fasta> Lemmih: why hasn't it been packaged by e.g. Debian?
14:50:07 <Lemmih> fasta: Well, nobody really uses it. No itch, no scratch.
14:51:51 <sorear> Why doesn't OSX have a decent package manager yet?
14:52:19 <fasta> Lemmih: How do you know nobody uses it?
14:52:28 <falconair> macports works well for me
14:52:35 <|Steve|> macports builds from source.
14:52:39 <fasta> Lemmih: is the network traffic pattern analysed by galois?
14:52:40 <|Steve|> I'm over that phase in my life.
14:53:05 <falconair> fink allows binary installs...but i don't use it so can't say if it is good or bad
14:53:14 <fasta> I will build from source when my harddisk is 100 times faster then it is now, and my CPU a thousand times.
14:53:43 <fasta> (including a nice memory upgrade)
14:53:51 <Lemmih> fasta: Haven't received any bug-reports yet. Ergo, no users. (:
14:53:54 <olsner> but by then compilers will be 100 times slower and programs 100 times larger :P
14:54:29 <fasta> Lemmih: what's your real name again?
14:55:06 <Adamant> .dmg is a decent package manager
14:55:15 <fasta> Lemmih: Jones?
14:55:32 <Lemmih> fasta: Nah, David.
14:55:36 <Adamant> fasta - you want HyperFlash
14:55:57 <Adamant> or a Flash disk drive
14:56:06 <fasta> Adamant: Yes, but that costs $$$
14:56:15 <fasta> Adamant: I read about it already, it's very nice.
14:56:30 <Adamant> yeah, it is really nice. just kind of small capacity wise
14:56:39 <Adamant> I wish laptops had 2 HD's bays
14:57:06 <Adamant> put in a Flash disk for OS and a lot of things, use the other HD for storage
14:57:31 <fasta> But Flash disk life time is usually shorter than HD, AFAIK.
14:57:53 <Adamant> I am not sure about that. I think they use wear leveling and put in extra Flash to counter that
14:58:21 <Adamant> which is why the capacity is small
14:59:18 <fasta> Lemmih: if you want it to get more users, you shouldn't market it as: "This tool is in development and is available in a darcs repository at http://darcs.haskell.org/packages/cabal-install/."
14:59:19 <lambdabot> Title: Index of /packages/cabal-install
14:59:21 <sorear> Adamant: Also, it costs $$$ to make the stuff.  People don't seem to buy the $1,600 units :)
14:59:54 <fasta> Lemmih: you should say:"This tool has worked for years for me already and there are zero known bugs".
15:00:02 <Adamant> hey, they have 55" LCD monitors for $4000
15:00:04 * sorear guesses $1,600 of flash would be about a typical HD's worth of stuff
15:00:06 <Adamant> someone would buy it
15:01:41 <Philippa> sorear: on the large side
15:02:03 <Philippa> and that's for a desktop HD
15:02:08 <Philippa> laptop ones're normally smaller
15:02:14 <Lemmih> fasta: I've been quite out of touch with the development lately. Paolo Martini and Audrey Tang has done most of the recent changes.
15:02:28 <Adamant> "In consumer level devices you can expect the drive's data storage component to last roughly 10 years in normal use [4]"
15:02:38 <Adamant> - Teh Wiki
15:02:53 <sorear> Nobody with a decent OS should use cabal-get or any similar program
15:03:20 <sorear> Adamant: Oh, that's good - last time I was told, magnetic drives have a typical MTBF of 5y
15:03:43 <tuukkah> sorear, your list of decent OSes ?-)
15:04:31 <|Steve|> Languages that have their own package management systems like perl tend to be a mistake because they don't interact well with an OS's package management system.
15:05:21 <tuukkah> then languages that don't have their own package management system have less packages than perl :-)
15:05:47 <sorear> |Steve|: the 100-odd haskell packages on Debian are (afair) all maintained by Igloo and arjanoosting.  Cabal was designed to make their work easy.
15:06:11 <sorear> We can do better though.  I'd like to do a good job with 0 maintainers :)
15:06:38 <|Steve|> I see.
15:07:30 <olsner> package management should change all over to cope well with "alien" packages.. but it seems we're lacking a culture to make that happen
15:08:13 <pastorn> @where cabal
15:08:14 <lambdabot> http://www.haskell.org/cabal
15:08:42 <tuukkah> olsner, if the alien packages don't contain enough metadata, what do you do?
15:08:49 <pchiusano> simple q: how do I import the Haskell exact ratio type?
15:09:11 <olsner> tuukkah: Do The Right Thing ;-)
15:09:12 <Igloo> sorear: rafl, kaol and others too
15:09:47 <shachaf> pchiusano: Either ":m + Data.Ration" or "import Data.Ratio".
15:09:59 <shachaf> Yum, Data.FoodRation.
15:10:05 <pchiusano> cool
15:10:07 <sorear> olsner: Or, we could just standardize on one system.  You're heading seriously into O(n^2) work territory.
15:10:08 <pchiusano> thx
15:10:22 <Igloo> sorear: And my packages require pretty much no maintenance other than the generic scripts. We do desparately need library test suites, though
15:15:47 <c> so im finally about to try xmonad - dwm keeps saying "does this window suck? yes" in stderr, for everything
15:25:37 <mgsloan> true constants in haskell would be nice (ones that can be used in patt match)
15:30:42 <chessguy> ermm, like data MyBool = Tru | Fals
15:31:25 <chessguy> isTru :: MyBool -> Bool       isTrue Tru = True; isTrue Fals = False
15:31:36 <chessguy> ...
15:31:47 <mgsloan> like that, but for more complex data types.  Eg, I have:
15:31:47 <mgsloan>  up = Vector 0 1; down = Vector 0 (-1)
15:32:09 <mgsloan> doesn't really matter
15:32:20 <chessguy> and you want to do what with it?
15:32:45 <chessguy> oh like doSomethingWithVector up = ...
15:32:51 <mgsloan> aye
15:33:15 <mgsloan> I have origin = Vector 0 0 as well
15:33:24 <chessguy> what's wrong with doSomethingWithVector x | x == up = ...
15:33:35 <mgsloan> (Translate origin) * x = x
15:33:35 <tuukkah> it's longer :-)
15:34:01 <mgsloan> yeah, longer :)
15:34:26 <mgsloan> probably doesn't justify introducing a new construct, though, its true.  I kinda forgot about guards
15:34:39 <chessguy> not that bad. and it probably gets compiled to the same thing
15:35:03 <mgsloan> does it?  I thought guards did some monad stuffs
15:35:10 <mgsloan> I guess that might get inlined out
15:35:51 <tuukkah> but does ghc understand to get rid of the equality comparison?
15:35:53 <chessguy> monad stuff is generally more highly optimized anyway
15:36:48 <sorear> mgsloan: What you want is called views.
15:37:04 <chessguy> oh yes, SPJ has talked about that
15:37:05 <sorear> mgsloan: It's a haskell extension that has been vaporware, for, oh, 15 years
15:37:23 <chessguy> almost as long as sorear's been alive :)
15:37:34 <tuukkah> how old is haskell anyway =)
15:37:43 <chessguy> @where history
15:37:43 <lambdabot> I know nothing about history.
15:37:53 <c> like teh same age as lua and ruby, early 90s i think
15:38:13 <chessguy> tuukkah,  http://tinyurl.com/yowkle
15:38:15 <lambdabot> Title: A History of Haskell
15:38:16 <mgsloan> sorear - jeez!
15:38:28 <mgsloan> interesting, though
15:39:26 <tuukkah> chessguy, the long answer
15:39:56 <chessguy> surely you would expect laziness in this channel of all places :)
15:39:59 <sorear> tuukkah: 17 years give or take, the work was most active around 1990
15:40:20 <tuukkah> right, 1.0 came out then
15:41:22 <mgsloan> whoah, guess Haskell and I are fairly parallel in aging.  Kinda funky
15:42:22 <HWSOD> @post
15:42:22 <lambdabot> Maybe you meant: list part paste
15:44:52 <hpaste>  HWSOD pasted "Why dosen't this compile?!" at http://hpaste.org/393
15:45:16 <HWSOD> so can any one help?
15:45:22 <kpreid> HWSOD: s/include/import/
15:46:46 <HWSOD> To kpreid hun? is that a web page or what?
15:46:59 <kpreid> no, it's an instruction on fixing it
15:47:10 <kpreid> you have "include Maximals"
15:47:15 <kpreid> it should be "import Maximals"
15:47:44 <HWSOD> @karma C--
15:47:44 <lambdabot> C-- has a karma of 0
15:47:52 <HWSOD> @karma C --
15:47:52 <lambdabot> C has a karma of 2
15:48:07 <HWSOD> Thanks!!
15:56:05 <ari> No love for C--? Doesn't ghc use it as an intermediate language?
15:57:03 <Lemmih> ?karma+ C--
15:57:04 <lambdabot> C--'s karma raised to 1.
15:59:19 <|Steve|> Why does the bot accept ? and @ for commands?
15:59:29 <|Steve|> @karma+ C--
15:59:30 <lambdabot> C--'s karma raised to 2.
16:00:08 <shachaf> @karma c--
16:00:08 <lambdabot> c-- has a karma of 2
16:00:42 <lambdabot> I don't know. I just had an urge to respond to both every since I was spawned.
16:00:51 <shachaf> ari: See? Lambdabot is just case-sensitive.
16:01:22 <|Steve|> I take it people can make lambdabot speak.
16:02:09 <HWSOD>  @pl x ~<= y =  compare x y == Just GT || compare x y == Just EQ
16:02:28 <shachaf> |Steve|: No, this is just the Consciousness plugin.
16:03:31 <HWSOD> > pl x ~<= y =  compare x y == Just GT || compare x y == Just EQ
16:03:31 <lambdabot>  Parse error
16:04:26 <kpreid> @pl \x y -> compare x y == Just GT || compare x y == Just EQ
16:04:26 <lambdabot> ap (ap . ((||) .) . flip flip (Just GT) . ((==) .) . compare) (flip flip (Just EQ) . ((==) .) . compare)
16:04:55 <kpreid> but I'd suggest: compare x y `elem` [Just GT, Just EQ]
16:05:13 <HWSOD> nice
16:05:29 <Lemmih> |Steve|: The plugin was pretty much a fluke. The odds of accidently creating a sentient being is directly proportional to the number of Haskell lines in a given project.
16:09:29 <sorear> @msg |Steve| While I, sorear, would not be suprised if lambdabot became sentient (you should see the garfieldesque refrigerator rot on some of her code), it is more likely that one of the @admins did it.
16:10:52 <hpaste>  HWSOD annotated "Why dosen't this compile?!" with "this compiles" at http://hpaste.org/393#a1
16:11:00 <shachaf> sorear: You're the one who tends to do such things, in my experience. :-)
16:11:07 <shachaf> sorear: It wasn't you this time?
16:11:12 <sorear> shachaf: Yeah.
16:11:30 <sorear> to clarify - Not me, correct.
16:11:42 <sorear> kpreid is on the list
16:11:52 * kpreid waves
16:12:20 <sorear> huh, I *thought* he was
16:12:29 <sorear> http://www.cse.unsw.edu.au/~dons/code/lambdabot/online.rc
16:15:00 <dmwit> According to that, lambdabot has never stabbed anyone in the back.
16:15:02 <dmwit> ?slap me
16:15:02 * lambdabot smacks dmwit about with a large trout
16:15:13 <sorear> dmwit: ?
16:15:29 <dmwit> I think it's a lie!
16:15:29 * mgsloan just wrote 19 functions in one instance, for a class with only one function
16:15:47 <sorear> easy.
16:16:40 <sorear> instance Foo Bar where baz = \a -> \b -> \c -> \d -> \e -> \f -> \g -> \h -> \i -> \j -> \k -> \l -> \m -> \n -> \o -> \p -> \q -> \r -> \s -> \t -> \u -> a
16:16:49 <sorear> that should be about 19 :)
16:16:59 <mgsloan> those are lambdas though
16:17:17 <sorear> mgsloan: Lambdas are functions too you know!
16:17:34 <mgsloan> I suppose!
16:17:36 * sorear acts as if mgsloan just said something very offensive
16:17:44 <mgsloan> heh
16:18:55 <shachaf> OUR functions are better than lambdas!
16:19:05 * olsner scoffs: in *my* language there's no room for mere lambdas
16:19:07 <mgsloan> I'm just hoping that the compiled code isn't just a bunch of conditional checks...
16:19:45 <shachaf> They don't have all these monomorphism problems.
16:20:08 <mgsloan> yeah? well in my language data and functions are one
16:21:28 <shachaf> mgsloan: Well, in MY language there ARE no functions, only data.
16:21:34 <ndm> sorear: with regards to your suggestion about doing Reynold's defunc first, sadly that means you loose the type safety at the begining - which may mean that if you can't remove a function you don't end up with H98
16:21:48 <mgsloan> shachaf - so basically your language is an arbitrary binary file?
16:22:21 <olsner> shachaf: In MY language, there's no data either - only operators!
16:22:35 <shachaf> mgsloan: No,  my language is trinary.
16:22:40 <mgsloan> hah
16:22:48 <shachaf> mgsloan: Actually, base-11.
16:22:49 <mgsloan> well, my language is negabinary
16:23:47 <olsner> hah! pinary owns binary, negabinary, trinary and base-11 any day!
16:24:23 <shachaf> olsner: Pinary?
16:24:32 <shachaf> olsner: Is that with Peano numbers?
16:24:37 <mgsloan> hah
16:24:38 <olsner> no, Base-PI
16:24:41 <mgsloan> nah, base-pi
16:24:45 <shachaf> olsner: Oh.
16:24:57 <shachaf> olsner: I see.
16:25:24 <mgsloan> olsner - how do you write 2 with pinary?
16:25:30 <olsner> still haven't quite figured out how to convert between non-integer bases though
16:25:44 <olsner> I mean what
16:26:04 <olsner> what's n mod PI?
16:26:27 <olsner> > pi
16:26:28 <lambdabot>  3.141592653589793
16:26:34 <olsner> > 4 `mod` pi
16:26:35 <lambdabot>  Add a type signature
16:26:40 <olsner> > 4.0 `mod` pi
16:26:42 <lambdabot>  Add a type signature
16:26:45 <olsner> :t mod
16:26:47 <lambdabot> forall a. (Integral a) => a -> a -> a
16:26:48 <xpika> is there any haskell library that can pull in the filesystem as a tree
16:26:51 <xpika> :)
16:27:08 <xpika> ?
16:27:12 <shachaf> xpika: Wasn't there a discussion on haskell-cafe about that recently?
16:27:20 <xpika> ** checks haskell cafe
16:34:12 <olsner> argh, time to sleep... 3 hours until wake-time, then for packing, hopping on the train for 2 hours, 20mins to drop the bags and perhaps have a second breakfast, then off to work to start a new week ;-)
16:35:03 <olsner> and I've gotta convert my programming language into pinary ;-)
16:35:38 <shachaf> olsner: Why not enary?
16:35:55 <olsner> shachaf: pi tastes better
16:36:00 <shachaf> olsner: You use e as a base for logarithms already.
16:39:27 <olsner> I'll probably generalize it for any real number base though
16:39:43 <olsner> anyway... g'nite
16:39:54 <slowriot> can anyone tell me what the ".as" suffix means?
16:40:50 <ndm> assembler?
16:41:16 <slowriot> There are .as files in the Yampa source. They have haskell code in them.
16:43:36 <slowriot> I'm thinking maybe they are source files that have special arrows notation in them.
16:45:51 <MyCatVerbs> GNU toolchains usually use .s for assembler, and AFAIK many commercial assemblers like to use .asm. So I wouldn't suspect that.
16:46:21 <dibblego> > [11,10..1] -- what function(s) are using to construct this list?
16:46:24 <lambdabot>  [11,10,9,8,7,6,5,4,3,2,1]
16:46:34 <shachaf> > enumFromThenTo 11 10 1
16:46:36 <lambdabot>  [11,10,9,8,7,6,5,4,3,2,1]
16:46:37 <MyCatVerbs> dibblego: enumFromTo
16:46:43 <dibblego> ah thanks
16:46:56 <ndm> arrows is a reasonable guess
16:47:01 <MyCatVerbs> Er, enumFromThenTo, jah.
16:47:07 <shachaf> @pl \x y z -> [x,y..z]
16:47:07 <lambdabot> enumFromThenTo
16:47:23 * MyCatVerbs lazy, usually smacks enum^I and lets the REPL's tab completion find it.
16:47:52 * shachaf is lazier, and uses [x,y..z] syntax. :-)
16:48:09 <MyCatVerbs> That, too.
16:49:04 <sorear> ndm: Uh, you're starting from Yhc.Core, meaning classes are desugared, meaning you have at least rank-2 types to start with - and those *can't* be reinferred (cf J. Wells' thesis)
16:49:30 <ndm> sorear: yes, but its really rare that the Monad's don't get specialised, since they are a type class which is an easy pattern
16:49:57 <ndm> sorear: plus it has to be a function parameterised over monads - i know its not true that Yhc.Core can be given in inferred Haskell, but in practice it works enough
17:01:02 <dibblego> why does the source to GHC.Enum talk of zeroInt (from GHC.Base) instead of just using 0?
17:01:14 <dibblego> > GHC.Base.zeroInt
17:01:15 <lambdabot>   Not in scope: `GHC.Base.zeroInt'
17:01:20 <dibblego> > zeroInt
17:01:22 <lambdabot>   Not in scope: `zeroInt'
17:01:41 <sorear> dibblego: dependancies should be acyclic if at all possible
17:01:58 <sorear> dibblego: remember 0 means GHC.Num.fromInteger (GHC.Prim.S# 0#)
17:02:05 <dibblego> oh
17:02:06 <sorear> dibblego: does GHC.Num import GHC.Enum ?
17:02:24 <dibblego> yes
17:16:40 <ndm> how would people go about writing a lazy parser?
17:16:56 <ndm> i.e. imagine that parsing the document: "test
17:16:58 <ndm> as a string
17:17:09 <ndm> gives [Text "test",Warning "Missing closing quote"]
17:18:46 <TSC> If you have only a small constant lookahead, isn't that a kind of lazy?
17:19:24 <shachaf> ndm: You might want to look at YamlReference.
17:19:29 <sorear> ndm: I think that's called a lexer. :)
17:20:04 <shachaf> ndm: http://ben-kiki.org/oren/YamlReference/
17:20:07 <lambdabot> Title: YamlReference
17:20:11 <ndm> sorear: kind of, but lexers are usually more strict than that
17:20:15 <sorear> ndm: what do you want this for?
17:20:21 <ndm> sorear: i.e. you won't get Text, until you get to the close quote
17:20:24 <ndm> sorear: tagsoup
17:20:28 <sorear> ndm: hmm, maybe look at tagsoup?
17:20:31 <sorear> oh :)
17:20:37 <ndm> TSC: if you wait for the close quote, then its not bounded
17:20:43 <shachaf> ndm: It's going to be rewritten to be much nicer at one point, according to the author. :-)
17:21:00 <ndm> shachaf: thats me, and yes, it is being as we speak
17:21:16 <shachaf> ndm: I mean YamlReference, not tagsoup.
17:21:43 <ndm> shachaf: ah, i'm reading it now
17:21:49 <sorear> ndm: Use an Alex lexer of type [Token] -> [Token]
17:21:57 <sorear> ndm: THen use lazy patterns
17:22:13 <ndm> sorear: the Alex lexer will be overly strict
17:22:21 <sorear> ndm: huh?
17:22:33 <sorear> ndm: as long as you only use 1-character tokens
17:22:41 <ndm> sorear: oh, perhaps
17:22:48 <fnord124> does anyone know where i can check out some hdbc example code?
17:23:43 <ndm> sorear: if i only use one character tokens, what do i get over just [Char] ?
17:24:39 <sorear> ndm: lemme write something up (btw, alex is overkill for this unless it can be better automated
17:24:54 <ndm> sorear: my guess was Alex is not to be used for this too
17:28:04 * SamB usually uses Alex *with* [Char]
17:29:06 <ndm> SamB, producing [Char] ?
17:29:11 <SamB> no.
17:29:25 <ndm> thats what i was refering to :)
17:29:38 <SamB> usually I use it to make a monadic lexer
17:30:45 <ndm> people rarely write lazy parsers
17:31:16 <SamB> indeed
17:31:48 <SamB> it's hard, if your parser returns "Either error value", for it to be lazy...
17:32:18 <ndm> impossible, actually :)
17:32:29 <kpreid> How about (Maybe error, incomplete-value)?
17:32:36 <SamB> yes. I use understatement from time to time.
17:32:53 <ndm> also impossible, if they ever look at the Maybe
17:32:57 <ndm> so best just not to include it
17:33:01 <ndm> i don't want to raise errors anyway
17:38:16 <Binkley> ?yow
17:38:16 <lambdabot> All of life is a blur of Republicans and meat!
17:39:45 <ndm> Binkley: are you doing GHC.Core stuff?
17:40:03 <Binkley> ndm: in theory, yes
17:40:10 <Binkley> actually I was just thinking about that
17:40:25 <ndm> Binkley: have you figured out what your external rep is yet?
17:40:25 <Binkley> would a function compileToCore as part of the GHC API be enough for you?
17:40:34 <Binkley> bypassing files altogether?
17:40:40 <ndm> i keep getting run round in circles with people saying different things...
17:40:42 <Binkley> hah
17:40:54 <ndm> Binkley: yes, thats plenty - as long as "Core" is some in memory AST i can walk
17:40:58 <Binkley> Well, it's all a little uncertain because it tends to get worked on every couple of months :-)
17:41:09 <Binkley> I think we pretty much have the external rep worked out, but it's not set in stone
17:41:11 <ndm> Binkley: plus, i may need to compile the Prelude/Base
17:41:20 <sorear> ndm:
17:41:23 <sorear> @src words
17:41:23 <lambdabot> words s = case dropWhile isSpace s of
17:41:23 <lambdabot>     "" -> []
17:41:23 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
17:41:39 <ndm> Binkley: i suspect the translation will take not very long, so shooting at a moving target isn't an issue
17:41:39 <Binkley> So, I think it would be pretty easy to write the function that you want; I can try it sometime soon
17:41:54 <ndm> as long as the target does exist :)
17:41:59 <Binkley> heh
17:42:04 <Binkley> It exists.
17:42:07 <ndm> sorear: yeah, lazy patterns and tuples is my current thought
17:42:18 <ndm> i'm never sure - people keep saying it does and it doesn't
17:42:38 <ndm> i will need to do compileToCore on the Prelude though, and all the modules in baes
17:42:43 <Binkley> I mean, in the sense that exists on a piece of paper that Aaron has :-)
17:42:45 <ndm> not sure if that compilates things
17:42:50 <ndm> does paper exist?
17:42:59 <Binkley> it exists
17:43:09 <Binkley> there may still be some uncertainty about representing foreign calls in Core
17:43:17 <Binkley> which may complicate things for compiling base
17:43:22 <Binkley> I'll have to see
17:43:26 <ndm> i don't care enough about that to worry
17:43:42 <ndm> as long as we can get Yhc.Core, we can do clever things about foreign calls in that
17:44:12 <Binkley> Well, you care because you don't want to get a GHC panic for code that has a foreign call in it, which was the previous behavior :-)
17:44:18 <hpaste>  sorear pasted "ndm: another approach" at http://hpaste.org/394
17:44:40 <ndm> Binkley: i don't mind that, i can fix that with a nice bug report :) (igloo likes eliminating crashes)
17:45:15 <Binkley> Well, whether igloo or me fixes it, someone has to :-)
17:45:32 <sorear> ndm: ^^
17:45:43 <ndm> sorear: is that somewhat like CPS with laziness?
17:45:54 <ndm> you or Igloo both sound like "not me" :)
17:46:15 <Binkley> heh
17:46:37 <sorear> cps or laziness?  hadn't thought of it that way :)
17:48:24 <nominolo> @list
17:48:24 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
17:53:59 <dibblego> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style | runCont (square 4) print | should'nt the arguments be the other way around?
17:54:02 <lambdabot> Title: Haskell/Continuation passing style - Wikibooks, collection of open-content textb ...
17:54:09 <sorear> dibblego: No. :(
17:54:40 <dibblego> but runCont :: (a -> r) -> r
17:55:10 <sorear> no, runCont :: Cont r a -> (a -> r) -> r
17:55:28 <sorear> there is always an implicit first argument to record selectors
17:56:17 <dibblego> oh I see
17:57:16 <Binkley> Is anyone here familiar with Network.HTTP?
17:57:55 <sorear> @seen desp
17:57:55 <lambdabot> I saw desp leaving #haskell-blah, #haskell-soc and #haskell 3h 5m 13s ago, and .
17:58:47 <sorear> Binkley: Mietek B+-k, aka desp, is on a soc project to complete it
17:59:03 <Binkley> *nod*
17:59:08 <sorear> I suspect that the +- symbol was an encoing error, though:)
17:59:22 <Binkley> I just had a quick question about the API, and the Haddock documentation just gives type signatures
17:59:33 <Binkley> but I can RTFS
18:02:56 <Binkley> desp: I hear you're the resident Network.HTTP expert?
18:03:16 <desp> Binkley: well, not quite -- I'm working on a replacement
18:03:21 <Binkley> heh
18:03:35 <Binkley> do you know how the setProxy function works?
18:03:41 <desp> no idea
18:04:04 <Binkley> Heh, ok. I'm trying to set the proxy to http://localhost:<someportnumber>/, and it doesn't seem to be parsing out the port number correctly
18:04:12 <Binkley> but I'll keep looking at the source
18:04:35 <desp> there will be a way to do so in my project, but it's not complete enough for you to use
18:07:17 <pchiusano> question, I am trying to pattern match ratios, like f (x%1) = x
18:07:24 <pchiusano> but this does not seem to be valid
18:07:55 <ndm> pchiusano: % is not a data constructor, so you can't do that - you can only patter match on data
18:07:56 <sorear> Indeed not, because (%) is a function.
18:08:01 <oerjan> pchiusano: the actual constructor is not % and i think it is not exported.
18:08:06 <pchiusano> okay, what I figured
18:08:08 <sorear> You are the second person today to want views.
18:08:14 <sorear> oerjan: :%, and correct.
18:08:32 <pchiusano> :% is the constructor?
18:08:39 <edwardk> @seen ski
18:08:39 <lambdabot> ski is in #oasis, #haskell-overflow, #haskell-blah and #haskell. I don't know when ski last spoke.
18:08:51 <pchiusano> > :m Data.Ratio
18:08:51 <lambdabot>  Parse error
18:09:06 <pchiusano> > 1%2
18:09:07 <oerjan> pchiusano: it is not export so that you cannot form unsimplified fractions like 2 :% 4, i guess
18:09:08 <lambdabot>  1%2
18:09:11 <oerjan> *exported
18:09:58 <pchiusano> okay, so there is no way I can write functions which pattern match the numerator and denominator without modifying the source?
18:10:17 <pchiusano> or is there some way I can force it to export
18:10:27 <beelsebob> ndm: how many lines is yhc? (roughly)
18:10:41 <ndm> beelsebob: no idea, at all - wc it
18:10:55 <beelsebob> yeh, was just grabbing an up to date darcs to do that
18:10:56 <pchiusano> > 1 :% 2
18:10:57 <lambdabot>   Not in scope: data constructor `:%'
18:13:21 <ndm> its got 10,000 lines of build scripts
18:15:10 <beelsebob> 55012 in src
18:15:20 <pchiusano> if a module does not export a constructor, there is no way to somehow "force" the export without modifying the module and recompiling, is that rigth?
18:15:33 <ndm> pchiusano: correct
18:15:47 <pchiusano> okay, that is too bad
18:16:07 <SamB> you might be able to steal it using TH, but clearly that is nonportable ;-)
18:16:18 <pchiusano> who would I contact to suggest that Ratio export its data constructor?
18:16:31 <SamB> @src Ratio
18:16:31 <lambdabot> data (Integral a) => Ratio a = !a :% !a
18:16:37 <SamB> @index :%
18:16:38 <lambdabot> bzzt
18:16:40 <oerjan> pchiusano: my suggestion is just to define your own shortcut for (numerator r, denominator r)
18:16:42 <SamB> @index (:%)
18:16:43 <lambdabot> bzzt
18:16:51 <oerjan> pchiusano: but it is a feature, not a bug!
18:17:02 <SamB> @doc Data.Ratio
18:17:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Ratio.html
18:17:08 <pchiusano> oerjan, what do you mean?
18:17:24 <oerjan> pchiusano: as i said, it is probably so you cannot create things like 2 :% 4 without having them simplified
18:17:35 <SamB> oerjan: indeed
18:18:07 <pchiusano> right, but sometimes it is handy to be able to pattern match the numerator and denominator!
18:19:58 <HWSOD> @karma c
18:19:58 <lambdabot> c has a karma of 15
18:20:07 <oerjan> pchiusano: well they probably should have provided a numDenum function, which is the best you can do with H98 i think
18:20:20 <oerjan> but you can easily write your own.
18:20:54 <oerjan> there is an extension known as pattern guards which might be useful to get it slightly less verbose.
18:21:40 <oerjan> it allows you to bind in guards, i think it would work something like | (n,d) <- nD r
18:21:43 <SamB> @let numDenom = numerator &&& denominator
18:21:45 <lambdabot> Defined.
18:21:49 <SamB> @type numDenom
18:21:51 <lambdabot> Not in scope: `numDenom'
18:21:55 <SamB> @type L.numDenom
18:21:57 <lambdabot> Couldn't find qualified module.
18:22:01 <SamB> arg.
18:22:05 <SamB> @help let
18:22:05 <lambdabot> let <x> = <e>. Add a binding
18:22:15 <HWSOD> @pl \x -> count c = lenght . filter (==c)
18:22:15 <lambdabot> (line 1, column 15):
18:22:15 <lambdabot> unexpected "="
18:22:15 <lambdabot> expecting variable, "(", operator or end of input
18:22:17 <oerjan> SamB: it is just appended to > actions, i think, not actually loaded directly
18:22:28 <SamB> oerjan: ... oh.
18:22:29 <HWSOD> @pl \c -> count c = lenght . filter (==c)
18:22:29 <lambdabot> (line 1, column 15):
18:22:29 <lambdabot> unexpected "="
18:22:29 <lambdabot> expecting variable, "(", operator or end of input
18:22:33 <dons> c: hehe. 'does this window suck' :-)
18:22:43 <SamB> dons: so @let doesn't work with @type?
18:23:02 <HWSOD> @pl \c ->  = lenght . filter (==c)
18:23:03 <lambdabot> (line 1, column 8):
18:23:03 <lambdabot> unexpected "="
18:23:03 <lambdabot> expecting lambda abstraction or expression
18:23:10 <HWSOD> @pl \c ->  lenght . filter (==c)
18:23:10 <lambdabot> (lenght .) . filter . (==)
18:23:14 <SamB> > numDenom (5%154)
18:23:16 <lambdabot>  (5,154)
18:23:26 <dons> nope. doesn't work with @type
18:23:40 <SamB> dons: this is a bug
18:24:20 <dons> its not a bug, its a feature.
18:24:40 <dons> http://programming.reddit.com/info/20yt2/comments
18:24:40 <lambdabot> Title: Category theory and Haskell (reddit.com)
18:24:41 <SamB> dons: you will never convince me that it is a feature
18:25:45 <dons> its only a bug if i tried to add it, and it didn't work.
18:25:55 <SamB> well it can't be a feature!
18:25:59 <SamB> because you never added it.
18:26:07 <dons> its a feature that it doesn't work.
18:26:22 <dons> and you are asking me to add new functionality, yes?
18:26:26 <dons> which is a ... feature request
18:26:38 <dons> so, assuming a missing feature is itself a feature
18:26:47 <SamB> @help type
18:26:47 <lambdabot> type <expr>. Return the type of a value
18:26:52 <SamB> @help run
18:26:53 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
18:27:10 * SamB kinda expects type and run to work on the same things...
18:27:24 <dons> that's nice. is that in the docs? :-)
18:27:43 <SamB> what docs?
18:27:55 <SamB> you call those tiny little 1-2 line blurbs "docs"?
18:28:06 <oerjan> btw, it _would_ be nice if src, index, hoogle etc. also worked on the same things.
18:28:27 <SamB> oerjan: index and hoogle should work on the same things...
18:28:49 <oerjan> things missing from @src seem to burn me frequently
18:32:08 * SamB_XP wishes he saw a change here that was done by someone else: http://www.haskell.org/haskellwiki/?title=Special:Recentchangeslinked&target=Category:Language_extensions
18:32:11 <lambdabot> Title: Related changes - HaskellWiki, http://tinyurl.com/2cn33v
18:33:17 <kpreid> SamB_XP: be careful what you wish for: 'and isn't spam' :-)
18:33:45 <SamB_XP> kpreid: who would put spam in the "Language extensions" category?
18:33:59 <sorear> kpreid: and how could you tell the difference?
18:34:44 <oerjan> "Get your HOT dependent types at ..."
18:35:02 <sorear> hmm.
18:35:12 <SamB_XP> redundancy!
18:35:15 <sorear> how does  view x % y <- x :% y look
18:35:48 <sorear> or maybe view (%) where x % y = x :% y
18:35:57 <SamB_XP> it looks underly general
18:35:57 * sorear is designing Yet Another Views Proposal
18:36:06 * sorear *will* implement this in qhc.
18:36:22 <SamB_XP> quixotic haskell compiler?
18:36:39 <sorear> SamB_XP: Thank you
18:36:40 <SamB_XP> you're planning to compile windmills, er, giants?
18:36:50 <sorear> SamB_XP: I was looking for an expansion
18:36:50 <sjanssen> sorear: how are you tackling views?
18:37:04 <sorear> sjanssen: By writing a haskell compiler!
18:37:08 <sjanssen> sorear: like the simple syntactic proposal SPJ made a while back?
18:37:17 <sjanssen> or something entirely different?
18:37:38 <sorear> sjanssen: probably not, a lot of people think the view patterns extension sucks
18:37:44 <SamB_XP> sorear: you're going to make sure that the nice examples from papers mostly can be made to work?
18:38:06 <sorear> SamB_XP: Yup.  I want to implement every haskell extension that is possible to implement :)
18:38:14 <sorear> s/possible/feasable/
18:38:25 <SamB_XP> I meant the nice *views* examples...
18:38:41 <sorear> yes
18:39:04 <dons> sorear: i think you better support implicit parameters to functional dependencies inside TH
18:39:23 <SamB_XP> dons: wth?
18:39:26 * sjanssen wants n*k patterns
18:39:33 <SamB_XP> wouldn't associated types work nicer?
18:39:49 <sjanssen> ooh, serious suggestion: add a numeric kind
18:39:57 <SamB_XP> C++ has one
18:40:02 <SamB_XP> we'd like it too
18:40:04 <sjanssen> with some built in associated types for addition and such
18:40:26 <SamB_XP> sjanssen: you can write a wiki page about it
18:40:35 <dons> yeah and n`mod`k would be good
18:40:43 * mauke wants p++l patterns
18:40:49 <sorear> dons: n `mod` k?
18:40:52 <SamB_XP> and add [[Category:Language extensions]]
18:40:55 <SamB_XP> to it
18:40:57 <dons> and n `isPrime` patterns
18:41:07 <dons> would make crypto so much easier
18:41:35 <mauke> seriously, desugaring [x,y,z] ++ k to x : y : z : k should be trivial
18:41:36 <SamB_XP> or better, a put it in a subcategory "Category:Proposed language extensions" or something
18:41:56 <SamB_XP> mauke: erm.
18:42:06 <SamB_XP> mauke: can views not do that?
18:42:26 <mauke> dunno (I'm missing context here)
18:42:37 <oerjan> btw i think (x:y:) and (f . g .) should be legal sections :)
18:42:46 <SamB_XP> I personally would like "foo"++bar to work as a pattern
18:42:48 <oerjan> perhaps even (+ 3 *)
18:42:51 <sjanssen> sorear: tuple sections
18:43:01 <SamB_XP> sjanssen: crazy talk!
18:43:09 <sjanssen> ah, but they're so useful!
18:43:21 * sjanssen is tired of typing flip (,) x
18:43:28 <SamB_XP> maybe for pairs
18:43:40 <SamB_XP> but please not for anything but pairs!
18:44:06 <sjanssen> list sections!
18:44:17 <SamB_XP> ahhhhhh!
18:44:17 <sjanssen> [,,3,,,]
18:44:25 <LoganCapaldo> lol
18:44:26 <sorear> sjanssen: Congrats
18:44:33 <mauke> monad sections! ... wait
18:44:39 <sorear> sjanssen: You just gave the first thing I *won't* implement :)
18:44:46 <SamB_XP> sorear: hooray!
18:44:52 <sjanssen> sorear: tuple sections or list sections?
18:44:55 <SamB_XP> sorear: will you please also not implement (,,3,,,)
18:44:57 <SamB_XP> ?
18:44:59 <sorear> sjanssen: list sections
18:45:13 <LoganCapaldo> what about list sections like [,,] ?
18:45:16 <SamB_XP> (,3) seems innocent enough though
18:45:20 <mauke> sorear: a "don't" keyword, for blocks that are not to be executed
18:45:29 <SamB_XP> mauke: hah!
18:45:36 <SamB_XP> you should just give them impossible types
18:45:40 <sorear> mauke: What does it mean for something to not be executed?
18:45:42 <LoganCapaldo> [,,] :: a -> a -> a -> [a]
18:45:50 <sorear> mauke: besides, don't is reserved for comonads.
18:45:52 <Binkley> don't $ unsafeLaunchMissiles
18:45:54 <kpreid> so is [] :: a -> [a]?
18:45:54 <mauke> unless (isPrime x) $ don't { print x }
18:46:03 <sorear> kpreid: My point exactly.
18:46:25 <kpreid> tuple sections don't suffer from that since there is no 1-tuple
18:46:27 <LoganCapaldo> nah, :[] is a -> [a] :)
18:46:46 <LoganCapaldo> which I like to refer to as the robot emoticon :)
18:46:49 <SamB_XP> kpreid: but larger tuple sections do have the disadvantage of encouraging larger tuples
18:46:58 <SamB_XP> which is something I do not particularly like
18:47:02 <SamB_XP> I prefer pairs
18:47:15 <sorear> SamB_XP: Large tuples will be inductive if at all possible :)
18:47:24 <SamB_XP> sorear: what?
18:47:33 * kpreid thinks it's just silly that (,) is allowed but (x,) isn't
18:47:54 <SamB_XP> @type uncurry . uncurry
18:47:55 <kpreid> you can build N-tuples out of half-strict pairs, right?
18:47:58 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
18:48:30 <LoganCapaldo> @ty curry id
18:48:33 <lambdabot> forall a b. a -> b -> (a, b)
18:48:48 <SamB_XP> so, does anyone have any arguments for (a, b, c) => (a, (b, c))?
18:49:13 <LoganCapaldo> > curry id 2 "three"
18:49:16 <lambdabot>  (2,"three")
18:49:23 <mauke> @src curry
18:49:23 <lambdabot> curry f x y = f (x, y)
18:49:23 <kpreid> SamB_XP: against. it's got too many bottoms
18:49:31 <LoganCapaldo> interesting way of writing (,)
18:49:58 <kpreid> no, (,) x y = (x, y)
18:50:01 <mauke> @pl curry id
18:50:01 <lambdabot> curry id
18:50:02 <SamB_XP> kpreid: so has (a, b, c) => ((a, b), c)
18:50:21 <SamB_XP> @src (,)
18:50:21 <lambdabot> Source not found. stty: unknown mode: doofus
18:50:33 <kpreid> oh, I didn't see you meant the associativity
18:50:37 <|Steve|> > foldr (,) 0 [1..3]
18:50:38 <lambdabot>      Occurs check: cannot construct the infinite type: b = (a, b)
18:50:38 <lambdabot>       Expec...
18:50:52 <|Steve|> Lame.
18:50:57 <LoganCapaldo> no infinite types today
18:50:58 <SamB_XP> kpreid: see the type of (uncurry . uncurry) above
18:51:05 <LoganCapaldo> try back next week
18:52:14 <LoganCapaldo> > let uncurryList f a b = f [a, b] in uncurryList sum 2 3
18:52:16 <lambdabot>  5
18:52:45 <|Steve|> @type uncurry
18:52:48 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
18:52:55 <|Steve|> Ah.
18:52:57 <kpreid> @pl \a b -> [a, b]
18:52:58 <lambdabot> (. return) . (:)
18:53:04 <kpreid> @pl \a b c -> [a, b, c]
18:53:05 <lambdabot> (. ((. return) . (:))) . (.) . (:)
18:53:26 <|Steve|> What is @pl?
18:53:33 <LoganCapaldo> @help pl
18:53:33 <lambdabot> pointless <expr>. Play with pointfree code.
18:54:09 <kpreid> |Steve|: it removes all variable bindings
18:54:16 <|Steve|> I haven't the slightest clue  what is actually happening in the above code.
18:54:17 <LoganCapaldo> > let f = \a b c -> [a, b, c] ; g = (. ((. return) . (:))) . (.) . (:) in (f 1 2 3, g 1 2 3)
18:54:19 <lambdabot>  ([1,2,3],[1,2,3])
18:54:38 <kpreid> @pl f x = let y = x + 1 in x + y
18:54:39 <lambdabot> f = ap (+) (1 +)
18:54:48 <SamB_XP> |Steve|: it stands for pointless, a joking name for point-free
18:55:04 <SamB_XP> which is paradoxically a style of code in which there are a lot of dots...
18:55:06 <kpreid> |Steve|: it replaces binding with combinators and then tries to clean up the result a bit
18:55:09 <LoganCapaldo> @unpl f . g
18:55:09 <lambdabot> (\ c -> f (g c))
18:55:17 <kpreid> |Steve|: @unpl undoes @pl
18:55:19 <|Steve|> Interesting.
18:55:28 <|Steve|> @unpl (. ((. return) . (:))) . (.) . (:)
18:55:28 <lambdabot> (\ h q e -> ((:)) h (((:)) q (return e)))
18:55:53 <|Steve|> What does return e do?
18:55:55 <|Steve|> @type return
18:55:57 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
18:56:10 <SamB_XP> unfortunately unpl has no types
18:56:15 <kpreid> in this case, it makes a one-element list
18:56:26 <|Steve|> What Monad is this in?
18:56:27 <oerjan> |Steve|: for some reason @pl uses return instead of the more readable (:[])
18:56:34 <kpreid> |Steve|: the [] monad
18:56:44 <oerjan> @src [] return
18:56:44 <lambdabot> return x    = [x]
18:56:57 <kpreid> @src Maybe return
18:56:57 <lambdabot> return              = Just
18:57:01 <kpreid> @src Either return
18:57:01 <lambdabot> return        = Right
18:57:23 <|Steve|> I see. So why didn't it just say \h q e -> h:q:[e]?
18:57:44 <kpreid> |Steve|: because I forgot to put infixification in unpl
18:58:03 <SamB_XP> |Steve|: also that [e] would be "return e"
18:58:11 <kpreid> and it doesn't do type inference so it *can't* know to convert return into :[]
18:58:20 <|Steve|> Ah.
18:58:38 <SamB_XP> kpreid: so go remember already ;-)
18:58:59 <|Steve|> I guess I'm glad I don't work with haskell on a daily (or even monthly) basis.
19:00:46 <SamB_XP> |Steve|: why?
19:00:57 <SamB_XP> we'd never use something with so many dots in it in real code...
19:06:15 <Binkley> ?quote
19:06:15 <lambdabot> zeeeeeee says: so aside from the refactoring, there's no other (major) improvements i can make to my program?
19:06:42 <Saizan> @quote
19:06:42 <lambdabot> apfelmus says: Programming in Haskell is like dual-wielding two light sabers whereas programming in imperative languages is like being equipped with a blunt kitchen knife.
19:06:55 <SamB_XP> hmm.
19:07:08 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/396
19:07:10 <SamB_XP> doesn't Haskell have a "padded stick" mode?
19:07:30 <edwardk> samb: helium?
19:07:46 <SamB_XP> or, really, isn't it mostly padded?
19:08:02 <SamB_XP> the typechecker might hurt sometimes, but it won't chop your legs off!
19:14:23 <Binkley> ?yow
19:14:23 <lambdabot> Yow!  Is this sexual intercourse yet??  Is it, huh, is it??
19:14:48 <sorear> Hmm.
19:14:54 <sorear> Prolog has views for free!
19:16:19 <Binkley> then write a Haskell compiler in Prolog :-)
19:22:06 <sorear> view n+k | k -> n where
19:22:32 <sorear> hm, no, this won't work.
19:27:57 <edwardk> sorear: a view can be 'viewed' as just a limited form of equational unification, so sure.
19:34:48 <dibblego> why is there listToMaybe, but not a function [a] -> Maybe(a, [a]) ?
19:36:09 <SamB_XP> @where safe
19:36:09 <lambdabot> I know nothing about safe.
19:36:12 <gwern> what's the best way to profile a program? I tried adding -prof -auto-all, but it seems to require every last library ever linked to to also be compiled with those options, which isn't particularly feasible
19:36:22 <SamB_XP> sorear: where is "safe"?
19:37:12 <SamB_XP> gwern: it only *requires* them to be compiled with -prof
19:37:25 <SamB_XP> now, you might not get much info without at least -auto as well...
19:37:37 <gwern> oh. does -auto-all do anyting in the absence of -prof?
19:37:47 <SamB_XP> no
19:37:47 <gwern> I see them paired everywhere, and in the docs as well I think
19:37:49 <kpreid> @type foldr ((Just .) . (,)) Nothing
19:37:51 <lambdabot>     Occurs check: cannot construct the infinite type: a = Maybe (a1, a)
19:37:51 <lambdabot>       Expected type: a1 -> a -> a
19:38:05 <SamB_XP> but -prof definately does something without -auto-all
19:38:13 <Binkley> gwern: -prof enables profiling, -auto-all adds cost centres to each function
19:38:31 <Binkley> you can still get overall time and space data with -prof and not -auto-all, but not data about individual functions, unless you add cost centres manually
19:38:59 <gwern> ok, but I don't want to recompile everything with -prof, so what's the next best option?
19:39:00 <SamB_XP> so, if you want to know about individual functions in a library, -auto or -auto-all is a good idea...
19:39:21 <SamB_XP> gwern: ... cachegrind?
19:39:41 <SamB_XP> it has no cost centers though
19:39:55 <gwern> cachegrind being another programm...?
19:39:57 <SamB_XP> so don't expect any kind of intelligable inheritance of cost by callers
19:40:05 <Binkley> @google cachegrind
19:40:08 <lambdabot> http://valgrind.org/info/tools.html
19:40:08 <lambdabot> Title: Valgrind: Tool Suite
19:40:39 <gwern> oh. well, I'll give that s hot. think gentoo has it packaged so why not
19:42:21 <oerjan> dibblego: sometimes you can use do notation matches with the Maybe monad, like do (h:t) <- Just r; return (h,t)
19:42:42 <dibblego> oerjan, I guess
19:48:04 <sorear> SamB_XP: Why me?
19:48:12 <sorear> SamB_XP: safe is one of ndm's libs
19:48:38 <SamB_XP> sorear: hmm. true.
19:48:45 <SamB_XP> and he does have a decent webpage...
19:48:47 <SamB_XP> @where ndm
19:48:48 <lambdabot> http://www.cs.york.ac.uk/~ndm/
19:49:07 <SamB_XP> of course, I know it is one of ndm's libs
19:50:06 <SamB_XP> dibblego: http://www-users.cs.york.ac.uk/~ndm/safe/
19:50:08 <lambdabot> Title: Neil Mitchell - Safe
19:50:21 <dibblego> thanks
19:50:55 <SamB_XP> maybe it doesn't exactly do what you want
19:52:01 <dibblego> it's pretty close - I just thought there might be a valid reason, like oerjan said
19:52:52 <SamB_XP> I think the reason is because life is too short to spend all of your (and Haskell's) time in commitee
19:53:24 <gwern> common lisp is a good example of the bad things that can happen when you don't spend any time in comittee, though
19:53:25 <dibblego> I would have made listToMaybe of that type before its current type
19:53:35 <SamB_XP> and we didn't want to compete with the Common Lisp standard in length ;-)
19:53:48 <|Steve|> @type listToMaybe
19:53:56 <lambdabot> forall a. [a] -> Maybe a
19:53:58 <SamB_XP> gwern: hmm?
19:54:13 <SamB_XP> gwern: I thought that was an example of what happens when your module system sucks?
19:54:25 <|Steve|> @src listToMaybe
19:54:25 <lambdabot> listToMaybe []        =  Nothing
19:54:25 <lambdabot> listToMaybe (a:_)     =  Just a
19:54:42 <dons> gwern: that's a nice insight :-)
19:54:45 <SamB_XP> maybeToList and catMaybes seem more useful...
19:54:57 <dibblego> > let myListToMaybe [] = Nothing; myListToMaybe (x:xs) = Just (x, xs)
19:54:57 <lambdabot>  Parse error
19:55:09 <hpaste>  dolio annotated "delimited continuations + transformers" with "more tests" at http://hpaste.org/390#a1
19:55:12 <dibblego> > let myListToMaybe [] = Nothing; myListToMaybe (x:xs) = Just (x, xs) in myListToMaybe [1..10]
19:55:13 <lambdabot>  Just (1,[2,3,4,5,6,7,8,9,10])
19:55:15 <SamB_XP> @let myListToMaybe [] = Nothing; myListToMaybe (x:xs) = Just (x, xs)
19:55:18 <lambdabot> Defined.
19:55:21 <|Steve|> Neither seem particularly useful.
19:55:26 <SamB_XP> > myListToMaybe [1..10]
19:55:28 <lambdabot>  Just (1,[2,3,4,5,6,7,8,9,10])
19:55:34 <gwern> SamB_XP: nah, that could've been rectified - if the CL comittee hadn't disbanded never to meet again in like '91 or something
19:55:34 <SamB_XP> > myListToMaybe []
19:55:35 <|Steve|> How is that useful at all?
19:55:36 <lambdabot>  Nothing
19:55:40 <dibblego> listToMaybe is used in find
19:55:46 <shachaf> Why doesn't listToMaybe work with any MonadPlus?
19:55:52 <gwern> I mean, did they really think it would never be updated again?
19:56:01 <SamB_XP> dibblego: is there a raw version that doesn't use it?
19:56:06 <Cale> Or MonadZero...
19:56:17 <SamB_XP> gwern: ... '91?
19:56:19 <SamB_XP> so recently?
19:56:23 <shachaf> Cale: Yes, OK, if there was a MonadZero. :-)
19:56:24 <dibblego> SamB, of find? I can't find (:)) one
19:56:46 * SamB_XP took a while to parse that
19:56:58 <SamB_XP> my first thought was "paren mismatch"
19:57:15 <SamB_XP> second was "what's he doing with (:)"
19:57:16 <dibblego> I find right-angled mouths unattractive
19:57:31 <shachaf> > let { l2m [] = mzero; l2m (x:_) = return x } in (l2m [], l2m [1,2]) :: (Maybe Int, Maybe Int)
19:57:34 <lambdabot>  (Nothing,Just 1)
19:57:41 <SamB_XP> I usually don't parenthesize smilies by themselves
19:58:01 <SamB_XP> and I think I also tend to close the parentheses with the smile part ;-)
19:58:11 <SamB_XP> (like this ;-)
19:58:24 <SamB_XP> oh, and I still use noses ;-)
19:59:06 <gwern> SamB_XP: well, I think the major work was done in like ;88 and '89, but didn't the standard only get published and the revision in '91?
19:59:17 <SamB_XP> dunno
19:59:22 <SamB_XP> I'm not an afficiondo
19:59:28 <SamB_XP> I can't even spell it
20:00:23 <shachaf> Cale: Why isn't there a MonadZero, actually?
20:00:37 <al> > 2+2
20:00:39 <lambdabot>  4
20:00:44 <Cale> shachaf: It was removed in Haskell 98 along with monad comprehensions.
20:01:14 * shachaf has vaguely heard of monad comprehensions, though he's never used them.
20:01:17 <Cale> Someone made the observation that every monad in the standard libraries that was in MonadZero was also in MonadPlus, and somehow managed to conclude that MonadZero was unnecessary.
20:01:41 <Cale> Of course, that's completely wrong :)
20:01:46 <SamB_XP> that's like thinking that every instance of Num should only have one 0
20:02:20 <dons> Cale: we need to form the monad comprehensions task force :-)
20:02:27 <dons> with examples of code that becomes clearer, to motivate
20:02:34 <Cale> It's more like assuming that every instance of Eq is also an instance of Ord.
20:03:03 <SamB_XP> Cale: yeah, I'm just teasing ;-)
20:03:17 <dibblego> why is it like that?
20:03:34 <Cale> dons: If you happen to know your way around GHC, apparently a patch which adds them back in will get accepted.
20:03:45 <Cale> We just need someone to write it :)
20:03:53 <SamB_XP> Cale: why did they take them out?
20:04:01 * sorear will add them in QHC.
20:04:08 <SamB_XP> they could have just, you know, made an extension ;-)
20:04:16 <Cale> SamB_XP: Claims that they made error messages confusing for beginners.
20:04:26 <SamB_XP> Cale: hence... -fglasgow-exts!
20:04:47 <Cale> Of course, we'd need to reclaim MonadZero for this to work.
20:04:57 <SamB_XP> tis the panacea...
20:05:00 <SamB_XP> Cale: hmm.
20:05:04 <SamB_XP> that is a tougher issue.
20:05:14 <SamB_XP> we need JohnMeachem's help for that one ;-)
20:05:21 <Cale> hm?
20:05:30 <SamB_XP> fortunately he already wrote just the proposal!
20:05:47 <SamB_XP> hmm, I spelled his name wrong :-(
20:05:51 <Cale> Are you referring to class aliases?
20:05:59 <SamB_XP> Cale: exactly!
20:07:09 <|Steve|> What is MonadZero?
20:07:18 <SamB_XP> @src MonadPlus
20:07:18 <lambdabot> Source not found. Take a stress pill and think things over.
20:07:45 <SamB_XP> well, it would have the zero part of MonadPlus, as well as the "fail" method from Monad
20:07:52 <chessguy> nice quote: "...I find [it] hard to hear computer scientists ask, 'Monads - aren't those about state?'. That's like asking, 'Algebra - isn't that about 1 + 1 = 2?'."
20:08:21 <Cale> chessguy: hehe
20:08:27 <Cale> yeah, that is a nice quote
20:08:43 <dolio> No, man. Algebra is 1 + 1 = x. :)
20:08:51 <|Steve|> It's a good quote except that you wouldn't hear a mathematician ask the question about algebra so what does that tell you about monads?
20:09:10 <bd_> dolio: nah, algebra is getting x - 1 = 1 to become 1 + 1 = x
20:09:30 <|Steve|> No, that's arithmetic.
20:09:32 <chessguy> Cale, you'd like this thesis i bet. David Espinosa, from MIT (I think), called "Semantic Lego"
20:09:33 <Cale> |Steve|: That they're not well enough understood by people who should know better.
20:09:44 <bd_> nah, arithmetic is taking 1+1=x and deciding x = 2 <.<
20:10:09 <|Steve|> Cale: Or that they have little to no place in the realm of CS.
20:10:28 <Cale> |Steve|: but they clearly do.
20:10:33 <SamB_XP> |Steve|: I'd rather go with "ignorance"
20:10:45 <|Steve|> Well of course, this is #haskell after all.
20:10:56 <|Steve|> But where else are they used?
20:11:27 <sorear> |Steve|: CT
20:11:38 <SamB_XP> |Steve|: oh, I thought you meant the *people*
20:11:40 <|Steve|> In computer science.
20:11:40 <Cale> |Steve|: Semantics of programming languages in general.
20:11:50 <SamB_XP> not monads...
20:12:11 <|Steve|> I've never used monads when studying the semantics of programming languages.
20:12:30 <Cale> |Steve|: They originally came to CS in formal semantics, and then the formal semantics people decided that since they were going to use them to explain the semantics of their programs anyway, why not incorporate them directly into their programs?
20:13:50 <|Steve|> Which sort of semantics use it?
20:14:07 <|Steve|> I've studied axiomatix and operational semantics. It never appeared.
20:14:59 <Binkley> |Steve|: denotational semantics
20:15:55 <|Steve|> monads appear in once place in the wikipedia page for denotational semantics.
20:16:01 <|Steve|> However, I've never studied them.
20:16:29 <|Steve|> And that is in the "monads in functional programming" link.
20:16:39 <Cale> There are some papers by Moggi.
20:17:13 <Cale> http://citeseer.ist.psu.edu/moggi89notions.html
20:17:15 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
20:17:17 <Cale> http://citeseer.ist.psu.edu/moggi89computational.html
20:17:18 <lambdabot> Title: Computational Lambda-Calculus and Monads - Moggi (ResearchIndex)
20:17:32 <chessguy> there's also this paper: http://citeseer.ist.psu.edu/188147.html
20:17:34 <lambdabot> Title: Semantic Lego - Espinosa (ResearchIndex)
20:17:37 <chessguy> (which i'm reading now)
20:18:21 <chessguy> it talks about monads in semanticcs
20:18:27 <chessguy> s/cc/c/
20:19:34 <chessguy> though it's apparently a little out of date: "It is important to remember that, at least for the moment, mathematics and programming are two different activities. The main problem is that current languages provide no automated support for representing and verifying properties of programs."
20:19:47 <chessguy> apparently it was written before QC :)
20:20:02 <Cale> QC isn't what they mean by verifying.
20:20:10 <|Steve|> I'm not particularly impressed. So there are a few papers about one tiny aspect of one area of CS.
20:20:15 <Cale> QC can only refute properties, it can't verify them.
20:20:22 <chessguy> bah
20:20:29 <Cale> Also look up categorical semantics.
20:20:31 <chessguy> for some value of 'verifying'
20:20:43 <Cale> and domain theory
20:21:56 <|Steve|> A guy who is studying pl asked my algebra prof (the one who's obsessed with CT) about the use of CT in programming languages and was told that not a lot of that is done any more.
20:22:27 <Cale> That's kind of strange, and untrue.
20:23:15 <al> Sorry to interrupt the discussion... I was wondering if I could ask a quick newbie question about point-free style?
20:23:24 <SamB_XP> maybe he's just disconnected from CS lately
20:23:33 <Cale> al: sure
20:23:33 <SamB_XP> or has been listening to CS professors, of all people!
20:23:53 <SamB_XP> (a seedy lot, to be sure)
20:24:10 <|Steve|> Okay, so you've given one example of where else monads are used (although I never saw it while studying that area). Where else in CS?
20:24:30 <al> well I have something like `map (10-) [1,2,3]'
20:25:05 <Cale> |Steve|: well, obviously in the design of programming languages :)
20:25:15 <al> haskell interprets (-10) as negative 10, so I can do `map (\x->x-10) [1,2,3]'
20:25:22 <shachaf> al: map (subtract 10) [1,2,3]
20:25:24 <kpreid> al: (subtract 10)
20:25:45 <kpreid> @src subtract
20:25:45 <lambdabot> subtract x y = y - x
20:25:45 <dons> ?pl \x->x-10
20:25:45 <lambdabot> subtract 10
20:25:45 <shachaf> al: It's one of the special cases.
20:25:53 <|Steve|> > map ((-)10) [1..3]
20:25:59 <kpreid> subtract exists because of the unary minus wart.
20:26:01 <lambdabot>  [9,8,7]
20:26:10 <|Steve|> Oh, that didn't work.
20:26:16 <shachaf> al: There's also negate -- \x -> (-x)
20:26:20 <al> right... I did `map (flip (-) 1) [1,2,3]' and got the right thing
20:26:31 <shachaf> @pl \x -> x - 10
20:26:31 <lambdabot> subtract 10
20:26:37 <shachaf> @pl \x -> (-x)
20:26:37 <lambdabot> negate
20:26:43 <dolio> @pl flip (-)
20:26:43 <lambdabot> subtract
20:26:44 <|Steve|> > map (+ -10) [1..3]
20:26:46 <lambdabot>      The operator `+' [infixl 6] of a section
20:26:46 <lambdabot>         must have lower precede...
20:26:55 <|Steve|> Lame.
20:26:57 <shachaf> al: Lambdabot is useful like that. :-)
20:26:58 <al> but anyway, I'm pretty sure I saw something like this on a webpage on point-free style, and they used function composition to gloss over the 'hole'?
20:27:07 <dons> |Steve|: re uses of monads in CS, http://haskell.org/haskellwiki/Monad#Monads_in_other_languages
20:27:08 <Cale> > map (+(-10)) [1..3]
20:27:09 <lambdabot> Title: Monad - HaskellWiki
20:27:10 <shachaf> > map (+ (-10)) [1,2,3]
20:27:10 <lambdabot>  [-9,-8,-7]
20:27:12 <lambdabot>  [-9,-8,-7]
20:27:54 <chessguy> @quote stero
20:27:54 <lambdabot> No quotes match. Just what do you think you're doing Dave?
20:27:57 <chessguy> @quote stereo
20:27:57 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
20:28:00 <dons> most languages don't have terribly good support for monads though, and that tends to limit how pervasive they become. haskell has very light syntax for them, so they're everywhere
20:28:00 <|Steve|> dons: That's just an implementation in another language. Any Turing-complete language can do it so that doesn't mean much.
20:28:03 * chessguy kicks the bot
20:28:27 <dons> |Steve|: hmm? they're exmaple monads to solve various problems, in various languages.
20:28:36 <dons> not entirely sure what you're getting at?
20:28:49 <Cale> Actually, I find most of the implementations of monads in other languages so far to be severely lacking.
20:28:57 <SamB_XP> yes. they are.
20:29:07 <Cale> If you can't write programs which work in every monad, then you haven't really implemented the monad abstraction.
20:29:10 <|Steve|> Oh, looking at it, it looked like it was just a list of implementations of monads.
20:29:12 <SamB_XP> mostly because they don't have sufficiently advanced typesystems
20:29:20 <shachaf> The Reasoned Schemer uses monads in Scheme for backtracking.
20:29:47 <dons> shachaf: that's a nice reference.
20:29:51 <SamB_XP> even if you can implement monads as cale says, they're liable to be really really ugly
20:37:57 <chessguy> wasn't there a paper on monads recently that started out "Shall I be pure or impure", as sort of an ode to Wadler?
20:38:01 <chessguy> i can't find it now
20:38:41 <shachaf> @goo "Shall I be pure or impure"
20:38:43 <lambdabot> http://www.citeulike.org/user/rahul/article/82598
20:38:43 <lambdabot> Title: CiteULike: Monads for functional programming
20:39:02 <chessguy> that's the original wadler paper
20:43:00 <wy> Hi all
20:44:58 <dons> chessguy: i've not heard that quote.
20:45:04 <dons> it would be good to find it though! sounds fun
20:45:35 <chessguy> the paper compares several simple monad and non-monadic evaluators side-by-side
20:45:59 <dons> oh, that sounds nice. url?
20:46:08 <chessguy> i don't know, i can't find it
20:46:18 <dons> surely wadler didn't *recently* write this though?
20:46:24 <dons> i thought his monad days were in the past :-)
20:46:25 <chessguy> no, it's not by wadler
20:46:48 <chessguy> but the first line is sort of an homage to wadler
20:48:16 <wy> I can't find a channel for hardware DIY. I'm familiar with this channel, so I'd like to find people here who would like to discuss with me.
20:48:46 <chessguy> heh. nice mini-ruby interpreter in haskell in like 70 LOC
20:48:47 <chessguy> http://blog.moertel.com/articles/2005/03/25/writing-a-simple-ruby-evaluator-in-haskell
20:48:49 <lambdabot> Title: Writing a simple Ruby evaluator in Haskell, http://tinyurl.com/yzhgp7
20:49:39 <dons> wy, one idea that might work. create #hardware-diy or something, tell guys like sigfpe its been creatd (he makes his own robots), then write a blog post about it, and put it on reddit
20:49:46 <dons> you'd get 20-30 people pretty quickly that way :-)
20:50:23 <sorear> wy: Invite kc5tja
20:51:13 <wy> dons: sounds like a good idea!
20:52:19 <dons> ?users #xmonad
20:52:20 <lambdabot> Maximum users seen in #xmonad: 51, currently: 41 (80.4%), active: 4 (9.8%)
20:52:31 <dons> we'll catch #haskell soon :-)
20:52:40 <dons> ?users #darcs
20:52:41 <lambdabot> Maximum users seen in #darcs: 47, currently: 39 (83.0%), active: 0 (0.0%)
20:52:54 <dons> ?users #ghc
20:52:54 <lambdabot> Maximum users seen in #ghc: 26, currently: 19 (73.1%), active: 3 (15.8%)
20:54:11 <wy> Hello, there is a new channel called #hardware-diy now. Any haskell programmers who would like to discuss are welcome!
20:54:30 <dons> cool!
20:54:44 <wy> join join!
20:55:00 <dons> wy, is it intended to have a FP+hardware flavour?
20:55:27 <dons> i.e. haskell on robots kind of thing? (if so, you could add a mention that this is a haskell-ish channel to the haskell wiki page on irc channels)
20:57:09 * mgsloan imagines a subsumption architecture monad..
20:57:34 <dons> we should update the 'known monads' list.
20:57:56 * chessguy giggles at the amusing monad thread on reddit: http://programming.reddit.com/info/ox6s/comments
20:57:58 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com)
20:58:21 <wy> dons: Yes. Let's do it
20:58:43 <dons> chessguy: yeah, the vapourware comment #2 is cute
20:59:01 <chessguy> and the comment about it not fitting in the margins of reddit :)
20:59:12 <dons> oh, that also has my top rating comment in it
20:59:32 <dons> back when you could get 60- points for a comment in the subreddit, for a good explanation
21:00:01 <dons> wy, you'll have to take the task of building the community, i'm just giving you pointers on how to do it. :-)
21:00:19 <erider> gn
21:00:32 <dons> i'm a CS/software guy myself. not much of a hardware guy -- though i did apply for a job working on FPGAs at one point. hmm.
21:01:22 <wy> dons: I know FP is very useful when designing chips
21:01:25 <dons> oh, that thread also has tmoerte's great comment on 'choose your own evaluation semantics'
21:01:41 <dons> http://programming.reddit.com/info/ox6s/comments/coxiv
21:01:42 <lambdabot> Title: Ask Reddit: What the hell are monads? (reddit.com)
21:15:02 <chessguy> @type (/)
21:15:05 <lambdabot> forall a. (Fractional a) => a -> a -> a
21:15:09 <chessguy> @type div
21:15:10 <lambdabot> forall a. (Integral a) => a -> a -> a
21:15:20 <Cale> Haskell
21:15:30 <Cale> Haskell's numerics are actually pretty good
21:15:39 <Cale> compared with most other languages
21:16:07 <rashakil> i dunno, BF's are pretty easy to memorize
21:21:54 <dons> http://programming.reddit.com/info/20zr5/comments
21:21:56 <lambdabot> Title: Haskell and Number Theory: GCD and Higher Order Functions (reddit.com)
21:25:02 <dons> Cale: hey, do you want to break up the 'haskell for maths' section on the blog page into subsections by topic?  http://haskell.org/haskellwiki/Blog_articles#Haskell_for_mathematics
21:25:08 <lambdabot> Title: Blog articles - HaskellWiki, http://tinyurl.com/2fksds
21:25:38 <dons> actually, the blog page needs breaking up into sub pages
21:25:56 <al> > pl \f g -> filter f . map g
21:25:56 <lambdabot>  Parse error
21:25:56 <Cale> That is a rather long page :)
21:26:05 <shachaf> al: @pl
21:26:05 <dons> it is. too many blogs!
21:26:13 <Cale> @pl \f g -> filter f . map g
21:26:13 <lambdabot> (. map) . (.) . filter
21:26:24 <cdsmith> Whew!  Just wrote a plugin to integrate HsColour into the Windows Live Writer blogging software.  Is this of sufficient interest that I should publish it anywhere?
21:26:26 <dons> ?pl \g -> filter f . map g
21:26:26 <lambdabot> (filter f .) . map
21:26:40 <dons> cdsmith: that sounds useful (is that what you use on your nice blog page?)
21:26:58 <dons> i was just thinking you'd got some nice integration with haskell fragments on your blog...
21:26:59 <cdsmith> dons: yes, I use Live Writer.
21:27:08 <al> thanks... I'll try to figure out that second reply
21:29:16 <cdsmith> (It'd be cooler if I wrote the plugin in F#... but alas, I was stuck with C# for it.)
21:29:51 <dons> cdsmith: yeah, you should write about how you do it, and have tghat appear on planet.haskell.org
21:30:31 <cdsmith> dons: I'll think about it.  planet.haskell.org seems to ignore me if I write too often, so I'll probably wait a few days.
21:30:46 <dons> heh
21:31:27 <cdsmith> Besides, I really need to get back to learning HAppS instead of tinkering with stuff.
21:32:22 <cdsmith> HAppS seems cool, but every time I peel away one layer of abstraction, there's another.
21:38:11 <cdsmith> I'm beginning to wonder how many people actually use HAppS.  Anyone have an idea?
21:38:48 <dons> a few. not a hugh number.
21:38:51 <dons> hpaste.org :-)
21:39:00 <dons> best ask shapr or the other happs people
21:39:07 <cdsmith> I knew about that one. :)
21:43:23 <daniel_larsson> I rewrote an internal application using HAppS, but it's fairly trivial in it's use of HAppS features
21:43:30 <chessguy> mmmm, appending "\n" to a string doesn't make it print a newline at the end?
21:44:07 <chessguy> > "foo" ++ "\n" ++ "bar"
21:44:08 <lambdabot>  "foo\nbar"
21:44:20 <daniel_larsson> Print it
21:44:52 <chessguy> *Eval> print "foo\nbar"
21:44:52 <chessguy> "foo\nbar"
21:45:26 <daniel_larsson> Prelude> putStrLn "foo\nbar"
21:45:26 <daniel_larsson> foo
21:45:26 <daniel_larsson> bar
21:45:27 <chessguy> oh, putStrLn figures it out
21:45:31 <chessguy> weird
21:45:46 <daniel_larsson> print does putStrLn . show, no?
21:46:18 <chessguy> @src print
21:46:18 <lambdabot> print x = putStrLn (show x)
21:46:23 <chessguy> yup
21:46:45 <chessguy> that's bizarre
21:47:08 <oerjan> bizarre?
21:47:11 <chessguy> > show "foo\nbar"
21:47:12 <lambdabot>  "\"foo\\nbar\""
21:47:26 <chessguy> > print "\"foo\\nbar\""
21:47:28 <lambdabot>  <IO ()>
21:47:52 <chessguy> *Eval> print "\"foo\\nbar\""
21:47:52 <chessguy> "\"foo\\nbar\""
21:49:25 <cdsmith> daniel_larsson: thanks! that makes 2, then. :)
22:04:06 <chessguy> @pl r a = \x -> (a,x)
22:04:06 <lambdabot> r = (,)
22:12:06 <dibblego> is it just me, or is using a language without higher-order polymorphism really annoying and repetitive?
22:12:32 <sorear> dibblego: Don't you mean higher rank?
22:12:43 <dibblego> yes
22:12:44 <sorear> dibblego: Haskell doesn't have higher order polymorphism
22:13:02 <sorear> higher order: (forall s. s -> a) -> a
22:13:09 <sorear> higher rank: [a] -> [a]
22:13:19 <sorear> yeah, I agree completely :)
22:13:49 * sorear keeps meaning to learn C++, and expects he will greatly prefer it over C for just that reason
22:13:57 <sorear> OO I can live without. :)
22:14:33 <sproingie> the C standard library is reason alone to prefer C++ over C
22:14:35 <dibblego> that and type-classes
22:14:48 <sproingie> unless you really like inventing your own basic data structures yet one more time
22:15:15 <cdsmith> Then again, the C++ language is much uglier than C.  (But, I reluctantly admit, easier to get things done with.)
22:15:48 <sproingie> oh it's exceedingly ugly, but it takes less of it
22:16:35 <sproingie> tho using bind seems more trouble than it's worth
22:18:44 <sorear> Huh.
22:18:58 <sorear> Does C++ support quantifying over higher kinded type variables?
22:19:49 <sorear> data Reverse container a = Reverse (container a) -- AKA, can this be written in C++?
22:19:53 <sorear> s/AKA/IOW/
22:20:03 <sproingie> with sufficiently twisty templates, i suspect so
22:20:24 <sproingie> ew ... is there no compiler that has sugar for pattern-matching on strings?
22:20:39 <sproingie> i'm seeing code like: case p of ('e':'d':'i':'t':'=':[]) -> Default
22:21:11 <sorear> sproingie: "edit="
22:21:26 <dolio> > case "foo" of "foo" -> "bar" ; _ -> "baz"
22:21:34 <lambdabot>  "bar"
22:21:44 <sproingie> ok, so it's just the code i'm looking at that's funky
22:21:52 <sorear> sproingie: It's reasonably obscure, you might want to mention it to the author
22:21:52 <al> @pl \l -> l ++ (map f l)
22:21:53 <lambdabot> ap (++) (map f)
22:22:02 <sproingie> it's phillipa's flippi
22:22:16 <sorear> @seen Philippa
22:22:16 <lambdabot> Philippa is in #oasis, #scannedinavian, #haskell-soc, #haskell-overflow, #haskell-blah and #haskell. I last heard Philippa speak 7h 20m 8s ago.
22:23:14 <sproingie> it's otherwise quite nice and easily read code
22:23:48 <al> (??... what's ap?)
22:24:03 <dibblego> ?src ap
22:24:04 <lambdabot> ap = liftM2 id
22:24:05 <sproingie> Control.Applicative, no?
22:24:22 <sproingie> er wait that's the funny <*> stuff
22:28:45 <al> oh I see... so id just returns 'l', and the ap supplies 'l' to (++), and then 'l' to (map f) ?
22:30:10 <dolio> @pl liftM2 f id
22:30:10 <lambdabot> liftM2 f id
22:31:18 <dolio> Actually, you might want to think of it as 'liftM2 ($)'
22:32:20 <dolio> id == ($) for functions.
22:36:34 <sorear> dons: is it a bug if @pl changes strictness?
22:38:06 <al> hrm... I'm having a little difficulty figuring out how this works in terms of liftM2 then... don't we have to be in a Monad?
22:38:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/397
22:39:56 <dolio> It uses the ((->) e) monad.
22:40:56 <dolio> ap in that monad is the S combinator.
22:41:41 <dolio> S f g b = f b (g b)
22:42:10 <dolio> And liftM2 h f g x = h (f x) (g x)
22:42:33 <Syzygy-> :t liftM2
22:42:41 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:42:48 <dolio> So liftM2 id == \f g x -> id (f x) (g x) == (f x) (g x) = f x (g x)
22:46:47 <al> interesting... I think I understand that last part, but how do you go from
22:46:48 <al> (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
22:47:04 <al> to liftM2 h f g x = h (f x) (g x)
22:47:23 <dolio> :t \h f g x -> h (f x) (g x)
22:47:25 <lambdabot> forall t t1 t2 t3. (t1 -> t2 -> t3) -> (t -> t1) -> (t -> t2) -> t -> t3
22:47:52 <dolio> So, if m = ((->) t)
22:48:03 <Syzygy-> ?src Integer
22:48:03 <lambdabot> data Integer = S# Int#
22:48:03 <lambdabot>              | J# Int# ByteArray#
22:48:14 <dolio> (t -> t1) == ((->) t t1) == m t1
22:48:23 <dolio> And so on.
22:49:10 <dolio> So the types match.
22:49:59 <dolio> You can also look at the definition of >>= and work from there.
22:50:08 <dolio> @src (->) (>>=)
22:50:08 <lambdabot> f >>= k = \ r -> k (f r) r
22:50:27 <dolio> @src liftM2
22:50:27 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:51:15 <oerjan> @undo do { x1 <- m1; x2 <- m2; return (f x1 x2) }
22:51:16 <lambdabot> m1 >>= \ x1 -> m2 >>= \ x2 -> return (f x1 x2)
22:52:01 <al> okay I see how the types match up... is there a name for the ((->) t) monad?
22:52:18 <dolio> Reader or environment.
22:52:26 <oerjan> @src Reader
22:52:26 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
22:52:48 <dolio> There's also a Reader monad that uses newtype.
22:52:54 <dolio> and runReader.
22:53:15 <al> Thanks for the help, I'll be back in a bit after I read about the Reader monad :-)
22:53:26 <dolio> ((->) e) is the same monad defined directly on the raw type.
23:09:37 <xpika> is there an insertAt function?
23:10:26 <oerjan> > insertAt
23:10:27 <lambdabot>   Not in scope: `insertAt'
23:10:39 <sorear> 'night
23:10:51 <oerjan> @src splitAt
23:10:51 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
23:12:08 <oerjan> :t insert
23:12:10 <lambdabot> forall a. (Ord a) => a -> [a] -> [a]
23:15:08 <al> dolio: do you by any chance know of any introductory links or papers on *when* you would use these lifts?  Just trying to wrap my head around how these are used in practice
23:16:34 <dolio> Not off the top of my head. Generally, they're for when you have a function on pure values, but you want to use it on monadic ones.
23:17:16 <dolio> Instead of writing do { x <- m1 ; y <- m2 ; ... ; f x y ... }, you write liftMN f m1 m2 ...
23:17:53 <dolio> Within the context of ((->) e), it's something lambdabot does with @pl, and people have picked it up.
23:18:23 <dolio> Because various monadic combinators turn into generally useful function combinators with ((->) e).
23:25:00 <Heffalump> > liftM2 (+) (+1) (+2) 3
23:25:05 <lambdabot>  9
23:25:29 * Heffalump looks confused
23:25:36 <TSC> :t liftM2
23:25:39 <lambdabot> forall a1 a2 r (m :: * -> *). (Monad m) => (a1 -> a2 -> r) -> m a1 -> m a2 -> m r
23:26:26 <TSC> It's (+) ((+1) 3) ((+2) 3)
23:26:31 <Heffalump> yeah.
23:26:31 <TSC> 4 + 5 = 9
23:26:32 <davidL> I have a meeting with my college counseler tomorrow and I bring with me a list of colleges I'm interested in. Which colleges, beside the obvious MIT, Harvard, Caltech, etc... have good computer science programs?
23:26:33 <Heffalump> I just realised that.
23:26:37 <Heffalump> not awake yet :-)
23:26:43 <Heffalump> it's what I wanted too.
23:27:09 <Heffalump> CMU, Stanford
23:27:30 <davidL> CMU?
23:27:34 <Heffalump> Carnegie Mellon
23:27:37 <davidL> ah
23:27:44 <augnob> davidL: for an undergrad, I think plenty of universities are fine
23:28:09 <augnob> davidL: it can be okay to look at the best ones in any locality
23:28:12 <TSC> Especially if you continue to study at the University of IRC
23:28:47 <augnob> davidL: (some smart people go local.. and the combination between those people, along with professors who are perhaps not too self-absorbed can be a good combination)
23:29:17 <augnob> and then you can be more selective for the graduate portion if you continue
23:29:18 <davidL> augnob: Is there a specific name for the computer science that deals with logic more than anything else? I know the term CS is very general.
23:30:03 <davidL> I'm specifically interested in algorithms, efficiency, etc... (the things I read about in Knuth's books)
23:30:14 <augnob> davidL: hmm.. it's all pretty intertwined.  Even philosophy is quite useful
23:30:53 <Heffalump> as an undergraduate degree, CS is the umbrella that kind of thing would come under
23:31:00 <Heffalump> you just need to look at the specific courses on offer
23:31:43 <davidL> I suppose some mathematics courses would overlap as well.
23:31:45 <augnob> davidL: I think you'll find plenty of algorithms in any CS program
23:32:17 <augnob> davidL: along with O() analysis, etc.
23:32:50 <davidL> I'll take a look at some of the courses offered at nearby universities.
23:32:55 <Heffalump> if you go outside the US you might find a slightly wider range of names
23:33:29 <davidL> I've heard things about some school in AU
23:35:03 <Heffalump> you don't want to go there, it's full of nutters like seafoodX ;-)
23:35:25 <davidL> and lambdabot :)
23:36:08 <TSC> And the water drains the wrong way in the sink
23:36:55 <al> > liftM2 (+) (+1) (+2) (+3) 3
23:37:03 <lambdabot>   add an instance declaration for (Num (a -> a))
23:37:04 * seafoodX may contain traces of nuts
23:37:10 <al> > liftM3 (+) (+1) (+2) (+3) 3
23:37:11 <lambdabot>      Occurs check: cannot construct the infinite type: a3 = a3 -> r
23:37:11 <lambdabot>     Proba...
23:37:13 <Shimei> davidL: Some universities seem to offer computational science degrees in the math department.
23:39:24 <davidL> That's what I'm interested in, theory.
23:40:11 <dancor> @hoogle [(a, b)] -> ([a], [b])
23:40:12 <lambdabot> Prelude.unzip :: [(a, b)] -> ([a], [b])
23:41:05 <xpika_> what would be the code to load a bunch of words into a map?
23:41:22 <xpika_> based on the starting letter
23:41:41 <al> davidL: what kind of theory?  Complexity and data structures is probably first-year stuff at any university you go to
23:41:43 <xpika_> ["cat","dog","fish"]
23:42:42 <TSC> xpika_: So the key is the first letter, and the value is the list of words?
23:43:51 <ttfh> a fold over the list, with a Data.Map as state in the State monad?
23:44:11 <al> (oddly enough at my university the courses get more practical the higher the level)
23:44:20 <xpika_> TSC: yep
23:45:39 <davidL> al: I guess it depends on the courses you choose to take. I just don't want to get stuck in some very elementary course where I've learned all there is to learn
23:46:23 <Shimei> davidL: I got around that by taking placements tests (AP tests, in my case). I don't know if that'd work in your case though.
23:46:24 <augnob> davidL: I think there are plenty of universities where that shouldn't be a problem
23:46:59 <davidL> Shimei: I took a practice AP CS test and got a 5 but I don't know how much that helps my case ;)
23:48:01 <xpika_> > empty
23:48:08 <lambdabot> Terminated
23:48:32 <augnob> it's true though that if you're into theory, then CS could be somewhat of a cakewalk.  For me the biggest struggle was to try and be interested in my courses while I was writing programs in the meantime.
23:49:22 <augnob> with courses taught by professors who stayed in academics, there's a strong theoretical bent to it all
23:49:40 <davidL> theoretical?
23:49:53 <augnob> which is a good thing actually, if you can keep up your interest in it and don't get ahead of yourself
23:50:19 <davidL> well I suppose you can apply theory in code you are working on at the time
23:50:43 <TSC> xpika_: foldr (\ x m -> M.alter (\ l -> if l == Nothing then Just [x] else Just (x : fromJust l)) (head x) m) M.empty xs
23:50:59 <augnob> davidL: lots of things in pseudo code, O() analysis, mountains of terminology, lemmas, corrolaries, theorems, etc.
23:51:00 <TSC> The inner lambda is ugly; you should fix it up
23:51:01 <al> at my school, pretty much none of the cs courses are 'practical' (in terms of learning how to code), but you tend to just pick that up in a handful of brutal systems courses
23:51:25 <al> like operating systems, and real time operating systems...
23:52:10 <al> but generally they teach you how virtual memory or thread scheduling (or whatever) works, and then you figure out the details on your own later
23:52:34 <wolverian> sounds familiar
23:53:24 <al> or in terms of algorithms, you'll learn about say 'greedy algorithms' or 'dynamic programming', and then the assignments will be to solve an assembly line problem or something
23:53:44 <al> using java say
23:53:48 <davidL> ah so through a mix of low-level and theoretical courses I'd get a decent undergrad education in CS
23:54:13 <al> I think so
23:54:28 <augnob> and then often you find that teams in the real world are following the 'KISS' principle, and have a culture of trying to write code that won't confuse the fellow developers
23:55:03 <augnob> so the wonderfully elegant and powerful things from university don't always make their way into your work.. but it's nice to understand it
23:55:25 <al> but it's always important to try and keep your toes in a variety of things... that way you can better see how things relate to each other
23:55:32 <Shimei> And instead we get entries to the dailywtf. :)
23:55:50 <davidL> I see a lot of things in #haskell I wish I understood ;)
23:56:23 <al> I'm with you man... trying to crack this one myself :-)
