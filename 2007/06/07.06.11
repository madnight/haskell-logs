00:00:01 <ttfh> doesn't CC mention "statements"? can it be applied to haskell?
00:00:03 <weitzman> Just getting a simple typeset state machine with a latex math embedded in it makes me want to jump out of a window
00:00:16 <dons> ttfh: i thought it was branches in code?
00:00:21 <Korollary> It's about branches
00:00:43 <dons> so compute the control flow graph, run some heuristic on that, print a number
00:00:50 <ttfh> dons: I think it a function of the number of branches and the number of statements
00:01:07 <dons> well, statements is just silly ;)
00:01:23 <dons> doesn't scale to multicore programs.
00:01:25 <ttfh> dons: It showed up in a testing course under "white-box-testing"
00:01:29 <Korollary> Wikipedia says code without branches of any length has the same CC.
00:01:37 <dons> ok.
00:01:43 <dons> that's my understanding too.
00:03:15 <Korollary> I think that's a bit too primitive for Haskell. Other langs have switch statements with simple values. In haskell you can have complicated nested patterns.
00:03:44 <dons> yeah, you'd probably want to run it on the core code, after desugaring
00:04:41 <Korollary> That would make it hard for the programmer to relate to the result, tho.
00:05:47 <Korollary> Heh. What if the code contains regular expressions? #1 complexity issue for perl programs.
00:05:56 <Korollary> "What's this doing?!"
00:06:37 <Korollary> Or lisp macros
00:06:54 <Korollary> those are supposed to lower it
00:11:16 <Korollary> Speaking of macros, a post by Oleg (somehow not linked from his site) http://tinyurl.com/3bg7jq
00:11:18 <lambdabot> Title: Re-writing abstractions, or Lambda: the ultimate pattern macro - comp.lang.funct ...
00:38:08 * osfameron writes some haskell in a post to perl6-language...
01:03:07 <kfish> dons: yeah, just reading that japanese review of xmonad
01:11:03 <kfish> it's the best window manager for 5 reasons: tiling, keyboard control, the different tiling modes, the way it handles xinerama (having a separate workspace per screen), and because its written in haskell ..."
01:11:29 <dons> hehe cool.
01:12:06 <kfish> you might have heard of haskell? you've probably heard of monads, because monadius is famous
01:12:17 <dons> ah yes, monadius.
01:12:31 <dons> i think that was jmuk's project?
01:12:58 <kfish> http://www.geocities.jp/takascience/haskell/monadius_ja.html
01:12:59 <lambdabot> Title: Monadius - a scientist's toy box
01:13:04 <dons> (obscure asteroids game)
01:13:28 <dons> yeah
01:26:37 <pastorn> how do i implement colours in an application run in a terminal?
01:26:55 <pastorn> @where color
01:26:55 <lambdabot> I know nothing about color.
01:26:58 <pastorn> @where colour
01:26:58 <lambdabot> I know nothing about colour.
01:27:11 <opqdonut> pastorn: by printin ansi escapes
01:27:14 <opqdonut> or by using curses
01:27:22 <pastorn> curses seems nice
01:27:23 <opqdonut> (which is essentially an abstraction)
01:27:29 <opqdonut> curses is just horrible
01:27:34 <opqdonut> at least the c bindings are
01:27:34 <pastorn> it is?
01:27:46 <pastorn> but i don't need to touch them, do i=
01:27:47 <pastorn> ?
01:28:00 <opqdonut> it works, but the api is just awful
01:28:15 <pastorn> :/
01:28:18 <opqdonut> global state flags that need to be set right for some things to work,
01:28:23 <pastorn> @where curses
01:28:23 <lambdabot> I know nothing about curses.
01:28:33 <opqdonut> unintuitive refresh semantics
01:28:35 <pastorn> @google haskell curses
01:28:38 <lambdabot> http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/papers/Template_Haskell-A_Report_From_The_Field.ps
01:30:11 <dons> curses, or ansi escapes.
01:30:17 <dons> ?where hscurses
01:30:17 <lambdabot> http://www.informatik.uni-freiburg.de/~wehr/haskell/
01:30:29 <dons> and for ansi colours, i'd look at hscolour
01:30:42 <dons> hmp3 also has its own curses binding
01:30:48 <dons> ?where hmp3
01:30:48 <lambdabot> http://www.cse.unsw.edu.au/~dons/hmp3.html
01:31:47 <quicksilver> there's also vty?
01:31:50 <quicksilver> does that do colour?
01:33:09 <dons> yep
01:37:58 <EvilTerran> amirite in thinking foldr-fusion's generally used to change (f . foldr g a) to (foldr h b) and not vice-versa?
01:55:32 <mnislaih> does anyone know if Cabal defines a cpp value __CABAL__ with the version number, as ghc does ?
01:56:04 <mnislaih> or, how else can one cope with the Cabal API changes between ghc 6.6 and 6.6.1 ?
02:03:26 <JaffaCake> malcolmw: Text.ParserCombinators.Poly.apply is the same as Control.Monad.ap, BTW
02:03:48 <malcolmw> JaffaCake: ah, will look
02:04:11 <malcolmw> JaffaCake: but I bet Text.ParserCombinators.Poly.Lazy.apply is different
02:05:31 <JaffaCake> hmm, that's odd
02:06:24 <JaffaCake> so in Text.PC.PolyLazy, your (>>=) isn't lazy
02:06:34 <JaffaCake> which is why you needed a different apply
02:08:46 <yakov> hi
02:09:11 <JaffaCake> malcolmw: why does the PolyLazy variant return an Either?
02:09:39 <malcolmw> JaffaCake: yes, >>= is strict, apply is lazy
02:09:57 <JaffaCake> strikes me as strange
02:10:20 <malcolmw> JaffaCake: the point is that you want control over whether laziness or strictness is desired at any particular point
02:10:48 <malcolmw> PolyLazy returns Either, because some parsers must be fail-recoverable
02:10:51 <JaffaCake> oh, hmm
02:11:07 <malcolmw> So sequencing is fail-recoverable, `apply` is not
02:12:02 <malcolmw> in other words, you can have a choice point over sequences, but not over `apply`d structures
02:13:14 <malcolmw> JaffaCake: what prompts you to be looking at polyparse?
02:13:47 <JaffaCake> just poking around - I wondered about Tom's question about using parsec in Cabal, and thought I'd look at the alternatives
02:15:48 <JaffaCake> parsec is too big a dependency, I think
02:16:12 <JaffaCake> we could pull in something like your Poly library instead (modulo the license)
02:19:05 <malcolmw> JaffaCake: just one module you mean?  and you want to open negotiations about the GPL? :-)
02:19:24 <malcolmw> wait, it's LGPL, isn't it
02:20:04 <JaffaCake> I think it would make sense to just pull in the code for some parser combinators, rather than depend on another package
02:20:15 <JaffaCake> and Cabal is BSD3
02:20:39 <malcolmw> JaffaCake: yeah.
02:21:43 <malcolmw> JaffaCake: so, there is a bit of a redesign going on with polyparse anyway (all in T.PC.Poly.*, note the extra directory level)
02:21:55 <JaffaCake> ok
02:22:15 <JaffaCake> wouldn't it make sense to use StateT rather than having extra state versions?
02:22:30 <malcolmw> JaffaCake: so i could perhaps be persuaded to give away  one of the old modules to BSD3, whilst retaining LGPL for the newer ones
02:22:54 * malcolmw has never really got into monad transformers
02:23:14 <JaffaCake> there are millions of monadic parser combinator libraries out there, it's not a big deal
02:24:18 <malcolmw> where is parsing used within Cabal? is it mainly to suck in the .cabal file itself?
02:24:25 <JaffaCake> yup
02:25:28 <malcolmw> should be pretty easy to replace then - I have the bare bones of a .cabal file parser using poly combinators already
02:26:32 <JaffaCake> the existing one uses ReadP, which is monadic and many of the combinators have the same names, so yes I'm fairly sure it would be a simple task
02:26:52 <malcolmw> hold on, didn't you just say that it used parsec?
02:27:13 <JaffaCake> no, Tom was asking whether we should use parsec
02:27:21 <JaffaCake> on the cabal-devel list
02:27:24 <malcolmw> oh I see
02:27:33 <JaffaCake> ReadP is kind of a pain
02:27:43 <malcolmw> and the problem with ReadP is lack of error messages?
02:27:46 <JaffaCake> we only used it because it was already in base
02:28:00 <JaffaCake> lack of error messages, and questionable portability
02:28:12 <JaffaCake> the portable version is annoying to use
02:28:31 <JaffaCake> what's the license on HuttonMeijer?
02:28:50 <malcolmw> HuttonMeijer - there isn't one :-)
02:29:02 <JaffaCake> oh, meaning you can't use it? :)
02:29:13 <malcolmw> or rather, it was distributed with Gofer, so probably comes under the Gofer license
02:29:28 * JaffaCake can't remember what that was
02:29:33 <malcolmw> but there is no indication in the file itself of what its license is
02:29:53 <malcolmw> Hugs was artistic license for a while
02:30:03 <malcolmw> we could email Graham and ask him...
02:31:12 <dancor> so in cabal, Data-Files cannot contain directories?
02:31:35 <dancor> i would rather not have to list every single png file i have there
02:31:47 <JaffaCake> dancor: don't know off hand, probably not I'd guess
02:31:51 * EvilTerran is reading http://research.microsoft.com/~simonpj/papers/marktoberdorf/
02:31:52 <lambdabot> Title: Simon Peyton Jones: papers
02:31:55 <malcolmw> JaffaCake: the gofer distribution I have does not contain any licence that I can find
02:32:34 <EvilTerran> it's good stuff. i've decided i like operational semantics. =]
02:32:34 <malcolmw> there is a "trademark" declaration though...
02:32:47 <JaffaCake> heh, I remember that
02:32:58 <JaffaCake> hugs98 is BSD3
02:34:12 <JaffaCake> for some reason, my internet connection is running at 5k/sec today :(
02:35:04 <JaffaCake> malcolmw: is the HuttonMeijer lib still part of a current Hugs source distribution
02:35:05 <JaffaCake> ?
02:35:16 <malcolmw> JaffaCake: found a licence at last
02:36:24 <JaffaCake> malcolmw: so, what is it?
02:36:31 <malcolmw> looks like a custom job, basically allowing anything provided copyright notices are retained, and modification history is given in full
02:36:56 <JaffaCake> ok, we might be able to live with that
02:37:08 <malcolmw> I don't think HuttonMeijer is distributed with hugs these days, no
02:37:44 <JaffaCake> there was monadic parsing code in one of Phil Wadler's monad papers I think, we could always pinch that
02:37:51 <malcolmw> You could easily take HuttonMeijer (or even HuttonMeijerWallace, which has error-reporting) for use in Cabal
02:38:14 <JaffaCake> right, I'll suggest that.  thanks
02:38:48 <malcolmw> although the reason I stopped using HuttonMeijerWallace in HaXml and developed polyparse was the quality of the error messages :-)
02:39:23 <JaffaCake> hmm, maybe it woudn't be the best choice then
02:40:17 <jedai> Shouldn't Ghc evaluate expression when keeping them lazy could lead to a "Stack overflow" ?
02:40:21 <malcolmw> getting decent error messages is a bit of a challenge, and parsec + polyparse + Utrecht are the only ones that do a semi-decent job of it to my knowledge
02:40:33 <quicksilver> jedai: when it can tell, it does
02:40:54 <jedai> But for example it doesn't for this function :
02:41:02 <quicksilver> jedai: did you compile with optimisation?
02:41:14 <jedai> fact n = fact' n 1
02:41:14 <jedai>     where
02:41:14 <jedai>       fact' 0 acc = acc
02:41:14 <jedai>       fact' n acc = fact' (n-1) (n*acc)
02:41:40 <jedai> quicksilver : No, I'll try that now
02:41:53 <malcolmw> JaffaCake: like I say, I could maybe be persuaded to release some module in polyparse from the LGPL into BSD3
02:41:56 <quicksilver> jedai: without optimisation it is forbidden from making that kind of transformation :)
02:42:56 <JaffaCake> malcolmw: it's up to you - but if we had to ask each time we wanted to bring in fixes from the upstream version, that wouldn't be an ideal situation
02:43:11 <malcolmw> I missed the bit in the Gofer license that says "personal or educational use"
02:43:23 <JaffaCake> oh :(
02:45:28 <malcolmw> JaffaCake: If I give Cabal a poly module, I would be able to push any fixes across myself
02:45:44 <JaffaCake> true
02:47:06 <malcolmw> I imagine Cabal does not need state or laziness or bytestrings
02:47:30 <JaffaCake> mgiht be nice to use bytestrings, but not a big deal
02:48:03 <matthew-_> does anyone here know which acm sigplan template should be used for the icfp haskell workshop? 9pt, 10pt or 11pt? The sites don't seem to say.
02:48:40 <JaffaCake> matthew-_: it's usually 9pt, I think
02:49:48 <matthew-_> JaffaCake: yeah, that's what the acm site says. Just wondering if I've missed some clarifying text somewhere... Thanks.
02:50:09 <JaffaCake> don't rely on me, check the CFP :)
02:51:14 <malcolmw> HW2005 was 2-column 9pt
02:51:40 <matthew-_> the CFP doesn't specify. http://www.cse.unsw.edu.au/~keller/haskellws/CFP.html
02:51:40 <lambdabot> Title: ACM SIGPLAN 2007 Haskell Workshop
02:51:56 <matthew-_> all it says is: "Submitted papers should be in postscript or portable document format, formatted using the ACM SIGPLAN style guidelines"
02:52:51 <malcolmw> matthew-_: email gabrielle and ask her to clarify the webpage
02:53:35 <matthew-_> will do. Given it's a week until the deadline, I would have hoped that someone else would have done this by now!
02:54:48 <JaffaCake> I've been using 9pt, FWIW
02:55:04 <JaffaCake> if it's 10pt, I'm in trouble :)
03:07:02 <Syzygy-> ?docs Data.List
03:07:02 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
03:13:48 <Syzygy-> ?t count
03:13:48 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
03:13:51 <Syzygy-> :t count
03:13:53 <lambdabot> Not in scope: `count'
03:15:45 <matthew-_> JaffaCake, malcolmw: just got word back from gabrielle and it is 9pt
03:16:04 <malcolmw> matthew-_: that was fast
03:16:08 <matthew-_> and the CFP page has just been updated too
03:23:39 <xpika> i forget how you update a record
03:23:53 <AWizzArd> can Haskell optimize operations on big Arrays internally, so that of instantiating a new Array it will destructively change cells in the existing one?
03:24:04 <quicksilver> xpika: foo { bar = 6 }
03:24:10 <AWizzArd> so that instead of
03:24:58 <dmhouse> AWizzArd: you might want to look at the mutable array modules.
03:25:25 <sieni> or DiffArray
03:25:45 <xpika> quicksilver: thanks quicksilver :> it worked
03:25:59 <xpika> gcGetValues gc >>= \x -> gcSetValues gc (x {foreground=Color 65535 65535 0})
03:26:45 <AWizzArd> oh okay, thanks
03:28:20 <gour> @where dons
03:28:20 <lambdabot> http://www.cse.unsw.edu.au/~dons
03:36:17 <xpika> @where flags
03:36:17 <lambdabot> I know nothing about flags.
03:38:53 <xpika> @where+ flags http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
03:38:54 <lambdabot> Done.
03:39:00 <xpika> @where flags
03:39:00 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
03:56:08 <Igel> hi there
03:56:21 <Igel> can someone tell me how to pass ghc-flags to cabal?
03:56:31 <Igel> i need to compile a project with -threaded
03:58:40 <Saizan> Igel: ghc-options: -threaded in the .cabal
04:00:26 <Igel> that somehow has no effect
04:00:37 <Igel> at runtime, the binary complains:
04:00:43 <Saizan> have you rerun configure?
04:01:06 <Igel> ... user error (RTS down't support multiple OS threads (use ghc -threaded when linking))
04:01:12 <Igel> yes, i did reconfigure
04:01:31 <Igel> runhaskell Setup.hs configure --user
04:04:02 <Saizan> try a clean first
04:05:19 <Igel> no effect :(
04:12:48 <Igloo> SamB: FWIW I'm not actually from .li
04:18:47 <Igel> hm, i wrote the option at the wrong place in the .cabal
04:18:50 <Igel> now it works
04:47:24 <roconnor> @ 1 EUR in CAD
04:47:28 <roconnor> @go 1 EUR in CAD
04:47:28 <lambdabot> 1 Euro = 1.42349133 Canadian dollars
04:47:57 <mauke> > 1.42349133 ^ 2
04:47:58 <lambdabot>  2.026327566585169
04:48:57 <kaol> @go 1 EUR in USD
04:48:58 <lambdabot> 1 Euro = 1.33900 U.S. dollars
04:48:58 <opqdonut> mauke: ?
04:49:14 <mauke> opqdonut: !
04:49:15 <roconnor> @go 1 EUR ^2 in CAD ^2
04:49:16 <lambdabot> 1 (Euro^2) = 2.02632756 Canadian dollars^2
04:49:22 <mauke> haha
04:49:32 <opqdonut> mauke: wanted to demonstrate how close it is to sqrt 2?
04:49:41 <opqdonut> hehe
04:49:51 <mauke> the number looked familiar
04:49:54 <Botje> but euros are round, not square!
04:50:22 <mauke> have you never seen a round square?
04:50:36 <roconnor> @go sqrt(1/2) EUR in CAD
04:50:37 <lambdabot> sqrt(1 / 2) * Euro = 1.00656037 Canadian dollars
04:57:46 <bringert> what's an efficient way to do memset in Haskell?
04:57:56 <mauke> oh wow
04:57:57 <bringert> I want to clear some memory allocated by allocaBytes
04:59:45 <mauke> what do you need a block of zero bytes for?
05:01:39 <bringert> mauke: initializing a C struct
05:01:56 <bringert> I'll just call memset I guess
05:01:58 <mauke> how about no
05:02:04 <mauke> unless the C struct only contains chars
05:02:15 <bringert> ?
05:02:18 <Vq^> ?
05:02:39 <mauke> setting random C variables to all-bits-zero isn't guaranteed to do anything useful
05:02:40 <Vq^> mauke: memset(3) doesn't work only with char
05:02:51 <bringert> mauke: they aren't random
05:03:01 <mauke> Vq^: yeah, it usually also works with integers
05:03:06 <bringert> mauke: they are what the struct declaration says they are
05:03:12 <bringert> mauke: and pointers
05:03:15 <mauke> no, not pointers
05:03:22 <bringert> ?
05:03:26 <mauke> <insert rant here>
05:03:30 <bringert> isn't NULL alwasy 0?
05:03:33 <bringert> always
05:03:33 <quicksilver> NULL is not guaranteed to be represented by 0x0000
05:03:40 <opqdonut> yup
05:03:43 <mauke> don't confuse several issues
05:03:55 <mauke> NULL is 0 in that it is (fromInteger 0)
05:03:55 <Pseudonym> As of C9X, I believe that NULL now _is_ guaranteed to be 0.
05:04:00 <Pseudonym> It certainly is in C++.
05:04:06 <bringert> well, on any machine this will run on, NULL is 0
05:04:10 <quicksilver> NULL is always ((void*) 0)
05:04:13 <mauke> no, stop
05:04:23 <quicksilver> but ((void*)0) need not be 0x0000 (or indeed 0x00000000)
05:04:36 <mauke> C guarantees nothing about the bit representation of the null pointer(s)
05:04:41 <bringert> is there any platform where that isn't true?
05:05:01 <mauke> however, an integer constant zero is autoconverted to a null pointer if it's in a pointer context
05:05:17 <mauke> NULL is not always ((void *)0), but NULL == 0
05:05:33 <mauke> that still doesn't tell you anything about the underlying bits
05:05:41 <Pseudonym> Right.
05:05:49 <bringert> well, here's what the sample app from the suppliers of the API I'm calling does:
05:05:50 <bringert> memset(&Parm, 0, sizeof(TTSPARM)); /* first initialize the struct by filling it with 0's */
05:06:06 <mauke> that's why I hate (most) C programmers
05:06:09 <Pseudonym> NULL == 0, but if void *p == 0. *(int*)&p isn't necessarily 0.
05:06:24 <bringert> I'm guessing that I don't have to be more picky than them, since I'm trusting their implementation to do the right thing
05:06:43 <mauke> it's not their implementation (unless they also provide a C compiler/library)
05:06:50 <quicksilver> mauke: surely it is ((void *)0) ? surely that's the same as NULL == 0?
05:07:03 <bringert> they also wrote the library that the API is for, yes
05:07:09 <Vq^> quicksilver: not if the compiler handles 0 differently
05:07:21 <Vq^> quicksilver: ...depending on context
05:07:32 <mauke> quicksilver: NULL is a macro that expands to a null pointer constant. a null pointer constant is an integer constant zero, optionally cast to void *
05:08:45 <bringert> again, is there any platform where NULL isn't all zero bits?
05:09:04 <pjd> http://c-faq.com/null/machexamp.html
05:09:06 <lambdabot> Title: Question 5.17
05:09:47 <jethr0> mauke: so, do you think (1 + ((int) *(NULL))) compiles?
05:09:47 <lambdabot> jethr0: You have 1 new message. '/msg lambdabot @messages' to read it.
05:10:28 <ibid> bringert: it's mostly a historical artefact but it does leave the door open for freak implementations (which might have good reasons for differing)
05:11:27 <ibid> in any case, in program text, 0 is a valid null pointer constant (except in a typeless context like in an ellipsis parameter)
05:11:57 <bringert> the Haskell libraries assume that all pointers are the same size
05:12:32 <bringert> afaict
05:20:16 <pharm> some platforms have weird pointer formats.
05:23:33 <quicksilver> bringert: C permits you to assume that all data pointers are the same size as each other, and all function pointers as each other
05:23:40 <quicksilver> bringert: but the two may be different
05:24:06 <quicksilver> bringert: so a 'universal pointer' has to be union { void * ; void (*) () }
05:24:24 <bringert> ah ok, so the Ptr / FunPtr distinction is enough then
05:24:47 <Pseudonym> That's true in C, not in C++.
05:25:00 <Pseudonym> void (C::*)() might have yet another different size.
05:25:15 <quicksilver> Pseudonym: but since C defines a kind of "default lowest-common denominator" ABI
05:25:25 <quicksilver> Pseudonym: because of libcrt and libc and so on...
05:25:32 <quicksilver> Pseudonym: it's what C does that matters, most
05:27:12 <mux> a NULL macro that isn't a pointer type can lead to surprising things, though it's indeed permitted :)
05:27:15 <MyCatVerbs> quicksilver: except that nobody *sane* builds a machine where the function pointers have different widths to data pointers, because they'd get their eyeballs removed by angry softdevs in return.
05:27:26 <mux> MyCatVerbs: ia64 is this way actually
05:27:37 <MyCatVerbs> mux: like I said, nobody sane...
05:27:39 <quicksilver> MyCatVerbs: on the contrary, I think it's moderately common
05:27:45 <mux> it happens
05:27:53 <Pseudonym> Yeah, it does happen.
05:27:58 <quicksilver> code + data is a completely different address space, in principle
05:28:15 <Pseudonym> Lots of architectures are Harvard architectures.
05:28:29 <MyCatVerbs> Ohhhh, SHARCs and the like. My bad.
05:29:31 <LoganCapaldo> aren't lotsa microcontrollers and the like harvard arch.?
05:30:04 <MyCatVerbs> LoganCapaldo: PICs are. Most DSPs are. I'm not sure about the rest.
05:32:18 * Syzygy- is now -seriously- performing algebraic research with Haskell.
05:32:22 <Syzygy-> *pats program*
05:32:51 <MyCatVerbs> LoganCapaldo: ARMs are von Neumann I think, Atmel...
05:33:10 * MyCatVerbs pokes Atmel's site with a stick. "Fuck off marketroids, gimme the *real* data already."
05:34:53 <MyCatVerbs> Methinks Atmel micros are Harvard too.
05:35:50 <mauke> quicksilver: actually, data pointers can have different widths
05:35:56 <mauke> or formats
05:36:01 <mauke> jethr0: no, why?
05:36:42 <Syzygy-> How does the memory footprint in ghci with :set +s actually work?
05:36:50 <Syzygy-> I'm getting numbers that simply do not fit in my machine....
05:37:29 <quicksilver> mauke: true, but they must all be convertible to void * and back
05:38:00 <mauke> yeah, but you can still have sizeof (int *) > sizeof (void *)
05:38:29 <MyCatVerbs> mux: true, but people who make machine with *that* characteristic need to have their eyeballs removed with rusty scissors.
05:38:35 <MyCatVerbs> *mauke, sorry.
05:38:47 <Lemmih> Syzygy-: GHC has a zero-point device that can utilize interdimensional space for storing closures.
05:38:53 <MyCatVerbs> mauke: and yes, I know, that includes old x86es. Near versus far pointers, etc.
05:39:53 <Lemmih> Syzygy-: I think it gives the total number of allocated bytes.
05:41:08 <Syzygy-> Lemmih: Is that disregarding garbage collection then?
05:41:27 <Syzygy-> Lemmih: I run a largish calculation, and it tells me it used 441G no a machine with 1G RAM and less than 250G hard disk...
05:42:33 <MyCatVerbs> Syzygy-: aliens came in.
05:42:40 <Syzygy-> Mmmmmm
05:42:42 <Lemmih> Syzygy-: It did use 441G, just not all at the same time.
05:42:47 <Syzygy-> Right.
05:43:05 <Syzygy-> So it's basically sum of size over all "mallocs", disregarding any "free" that happened to happen?
05:43:16 <MyCatVerbs> Syzygy-: they swapped your L2 cache for an infinitely fast infinite Turing machine, and didn't tell you.
05:43:25 <Syzygy-> MyCatVerbs: I wish.
05:45:39 <matthew-_> @quote matthew
05:45:40 <lambdabot> matthew-_ says: <augustss> matthew-_: in finite memory. do you have more than that? <*matthew-_> augustss: yes, I have 3 times that much! ;-)
05:45:49 <matthew-_> (seemed appropriate)
05:46:02 <Syzygy-> Hehe
05:48:40 <ajudem_me> hello, could you tell me if there is a change to use global variables in Haskell?
05:48:59 <ndm> ajudem_me: no, don't use them, if you want to use them you are probably doing something wrong
05:49:46 <ndm> ajudem_me: depending on what you do, there are alternatives - usually monads, or something similar
05:49:57 <ndm> after a while you won't miss global variables at all :)
05:50:17 <ajudem_me> ndm... well, I found out I need to pass another argument (that varies) to all functions is the code, an I don't want to refactor all the code...
05:50:37 <ndm> ajudem_me: do you already pass some information to all these functions?
05:50:43 <ajudem_me> yes..
05:51:04 <ndm> you may want to create a data type, which contains some of the information being passed around
05:51:19 <ndm> and then if you extract/set things using records, you'll be able to add/remove data easily
05:51:29 <ndm> i.e. refactor once, and never again :)
05:51:48 <ddarius> Well you could refactor to monad style and then never again.
05:51:52 <ddarius> Also there is HaRe.
05:51:56 <ddarius> @where HaRe
05:51:56 <lambdabot> http://www.cs.kent.ac.uk/projects/refactor-fp/
05:52:09 <ndm> ddarius: if you refactor to monad style, you oftne loose the beauty of haskell, and the declarative nature
05:52:18 <ddarius> I agree.
05:52:32 <ajudem_me> hmmm... what I was thinking was about having a variable with the informatiion I need and access it all the time... could I?
05:53:04 <ndm> you can, in the IO Monad, with an IORef
05:53:10 <ndm> but its unlikely to be the best answer
05:53:16 <ndm> or you can use the State Monad
05:53:20 <ndm> @hoogle StateMonad
05:53:21 <lambdabot> No matches found
05:53:23 <ajudem_me> Ys... it looses the purity
05:53:24 <ndm> @hoogle State
05:53:25 <lambdabot> Control.Monad.State :: module
05:53:25 <lambdabot> Control.Monad.State.State :: (s -> (a, s)) -> State s a
05:53:25 <lambdabot> Control.Monad.State.State :: newtype State s a
05:53:39 <ajudem_me> so... with data records...
05:53:40 <ndm> if you use state monad, you can keep the purity
05:53:50 <ajudem_me> really??
05:53:53 <ndm> yes
05:53:57 <ndm> @hoogle runState
05:53:57 <lambdabot> Control.Monad.State.runState :: State s a -> (s -> (a, s))
05:53:57 <lambdabot> Control.Monad.State.runStateT :: StateT s m a -> (s -> m (a, s))
05:54:09 <ajudem_me> but doesn't it changes the value of somthing directly?
05:54:10 <ndm> that takes a state monad, and runs it to produce a pure value
05:54:20 <ndm> no, the monad does the necessary stuff
05:54:34 <ndm> it never changes anything, but it gives you the illusion that it does
05:54:42 <ndm> read a tutorial on the state monad first, i'd suggest
05:54:46 <ndm> its well worth it in the end
05:54:47 <ajudem_me> ok...
05:54:59 <ajudem_me> but with records, you said
05:55:03 <mauke> hmm, and ST does change things, but it gives you the illusion that it doesn't?
05:55:09 <ddarius> Haskell: All Smoke and Mirrors
05:55:17 <quicksilver> (and hair shirts)
05:55:30 <ddarius> mauke: No it changes things and gives the illusion that it does.
05:55:42 <ndm> data Foo = Foo {rec1 :: Int, rec2 :: String, rec3 :: [Bool]}
05:55:48 <ndm> then pass Foo to each function
05:55:55 <ndm> and extract hte useful bits with rec1 foo
05:56:07 <ndm> then when you add rec4, you don't need to change any existing code
05:56:33 <mauke> ddarius: but runST has a pure interface
05:56:41 <ddarius> So?
05:56:42 <ajudem_me> yes.. but what if I'm not using the records
05:56:44 <ajudem_me> for instance:
05:57:18 <ajudem_me> hmmm.. forget it...
05:57:23 <ajudem_me> I'm not really using records...
05:57:46 <ajudem_me> But it seems like a good alternative to avoid refactoring, though...
05:57:47 <ndm> its easy enough to start - read up on records in a tutorial, and you might find they do what you want quite easily
05:57:56 <Syzygy-> 20 minutes execution time and counting.
05:58:06 <ndm> the state monad is harder to get to grips with, records are pretty easy
05:58:09 <Syzygy-> > 8.7/0.3
05:58:10 <lambdabot>  29.0
05:58:15 <Syzygy-> > 2020/8.7
05:58:16 <lambdabot>  232.18390804597703
05:58:29 <Syzygy-> 2020*2300
05:58:38 <Syzygy-> > 2020*2300/60
05:58:39 <lambdabot>  77433.33333333333
05:58:49 <ajudem_me> ok, ndm. I think I'll refactor it all... But thanks anyway
05:58:49 <Syzygy-> > 2020*2300/3600
05:58:50 <lambdabot>  1290.5555555555557
05:58:58 <Syzygy-> Hmmmmm. This looks ugly.
05:59:09 <Syzygy-> > 2020*2300/(3600*24)
05:59:10 <lambdabot>  53.773148148148145
05:59:27 <Syzygy-> Yikes. If things continue the way I'm guessing, this execution run'll take up two months. :/
05:59:42 <mauke> Syzygy-: it looks better in base 3: 1202210.12
05:59:53 <ddarius> @hawiki UsingRecords
05:59:54 <lambdabot> Maybe you meant: gwiki wiki
06:00:01 <ddarius> @oldwiki UsingRecords
06:00:01 <lambdabot> http://www.haskell.org/hawiki/UsingRecords
06:00:14 <mauke> or base 9 (1683.5)
06:00:24 <Syzygy-> > 8.8/0.33
06:00:26 <lambdabot>  26.666666666666668
06:00:39 <Syzygy-> > 1020/8.8
06:00:40 <lambdabot>  115.9090909090909
06:01:24 <Syzygy-> > 116/27
06:01:25 <lambdabot>  4.296296296296297
06:01:41 <ndm> i think i actually prefer the old wiki...
06:02:56 <Syzygy-> > 400000 / 3600
06:02:57 <lambdabot>  111.11111111111111
06:03:43 <ddarius> There is a lot of good stuff there that never got migrated
06:05:47 <ddarius> @wiki Common idioms
06:05:47 <lambdabot> http://www.haskell.org/haskellwiki/Common_idioms
06:06:01 <ddarius> @oldwiki CommonIdioms
06:06:01 <lambdabot> http://www.haskell.org/hawiki/CommonIdioms
06:06:23 <ddarius> @wiki Common Haskell idioms
06:06:24 <lambdabot> http://www.haskell.org/haskellwiki/Common_Haskell_idioms
06:06:37 <ddarius> @oldwiki CommonHaskellIdioms
06:06:37 <lambdabot> http://www.haskell.org/hawiki/CommonHaskellIdioms
06:10:00 <MyCatVerbs> @wiki Filthy Pornography
06:10:01 <lambdabot> http://www.haskell.org/haskellwiki/Filthy_Pornography
06:10:23 <MyCatVerbs> ...? It doesn't even bother to check whether the article exists or not?
06:10:30 <Syzygy-> I'd suppose not.
06:13:05 <ekidd> Good morning!
06:15:25 <ddarius> A lot of the lambdabot commands are simple to the point of triviality, e.g. @oldwiki is almost surely just ("http://www.haskell.org/haskellwiki/"++)
06:20:08 <ekidd> If anybody would like an draft of my probability monads paper, you can contact me at http://www.randomhacks.net/contact (or leave a message with lambdabot), and I'll send you something in the next few days.
06:20:09 <lambdabot> Title: Random Hacks
06:20:44 <ekidd> I'm especially interested in feedback from people who actually know what a functional programming paper is supposed to *sound* like; I've never written one of these before.
06:21:10 <ekidd> Many thanks to anyone who is interested!
06:24:30 <ddarius> ekidd: I'd be interested.
06:25:22 <SamB_XP> ddarius: perhaps you'd like to tell him your email address?
06:26:13 <malcolmw> ekidd: to know what one sounds like, try reading a few from past ICFP, HW, etc...?
06:26:57 <SamB_XP> and remember to try and use a bad pun in the title
06:27:20 <ddarius> Wadler does a fairly good job with his puns.
06:27:46 <MyCatVerbs> Oooh, cheesy puns! <3
06:28:26 <ddarius> But Wadler has a knack.
06:29:20 <kombinator> hello, I
06:29:25 <kombinator> <sorry>
06:29:29 <ddarius> S K
06:29:54 <ddarius> or would SKK be more appropriate?
06:30:13 <kombinator> I'm looking for an easy example of application of lazy evaluation, comprehensible for a C++ programmer
06:30:24 <ddarius> @where whyfp
06:30:24 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
06:31:17 <kombinator> ddarius: you mean the example with searching the game tree?
06:31:33 <ddarius> I mean the many things he says laziness is beneficial for.
06:34:23 <bartw> bugs, bugs bugs
06:34:27 <kombinator> ddarius: I see several numerical examples, which are expressible in c++ with a simple loop imo, and an example with game tree
06:35:13 <kombinator> ddarius: It's hard for me to find something brief yet attractive for imperative programmers
06:35:32 <kombinator> ddarius: and I have only several sentences to spare in my report...
06:36:17 <jethr0> kombinator: lazyness can actually be a very nice interface. so instead of lacing control structures through everything you just create an infinite list and use what you need
06:36:44 <kombinator> jethr0: any accessible, simple example?
06:37:20 <kombinator> jethr0: I'm afraid I can't give a general statement like this w/o an example in my report
06:37:27 <jethr0> hmm, i like the game tree.
06:38:14 <jethr0> i've written a alpha-beta-pruning algo with that idea from "whyfp", but i guess that's anything but concise...
06:38:49 <ekidd> ddarius: Get me an e-mail address and I'll send you a copy. Thanks for your interest!
06:38:55 <jethr0> any kind of series where you just need the first N elements but it's not directly obvious how many base elements you have to calculate for that
06:39:40 <jethr0> especially if you have deeply nested calls and would have to keep "if's, while's and loops" around in a strict implementation
06:40:25 <kombinator> jethr0: good point
06:41:13 <jethr0> sorry, i'm not coming up with anything, but i think that the game tree search is a good example. and infinte lists in general, of course.
06:41:39 <jethr0> one nice example is the "acceleration" of series.
06:41:44 <kombinator> game tree is too big to show the code
06:42:17 <jethr0> so, if you have an infinite list that approaches Pi or E or sqrt(2) than you can accelerate the conversion nicely in a lazy language
06:44:24 <jethr0> arbitrary precision numbers are also a nice example of lazyness
06:44:39 <jethr0> oh, and dynamic programming of course
06:44:56 <jethr0> everything where you want to calculate "backwards" ;)
06:45:38 <kombinator> jethr0: perhaps I'll give some silly example and then talk about some nice ones without showing the code
06:45:44 <jethr0> hehe
06:46:10 <jethr0> sorry for being so sparse with code, but i'm not at my haskell machine ;(
06:47:09 <kombinator> np
06:47:18 <quicksilver> kombinator: in an interactive setting, where you don't know in advance which things the user will be interested in, lazy evaluation lets you calculate them on-demand
06:47:53 <quicksilver> kombinator: so you can set up big data structures which contai 'everything' the user might ask, but you only actually calculate when (and if) he asks for a particular thing
06:48:08 <kombinator> quicksilver: any nice example?;)
06:48:58 <jethr0> kombinator: for tic-tac-toe for example a game tree would be quite concise.
06:49:03 <osfameron> won't they be calculated the second time you ask for them too?
06:49:12 <quicksilver> osfameron: no
06:49:13 <osfameron> oh, you'd memoize?
06:49:16 <quicksilver> no
06:49:24 <quicksilver> I'd just use a big data structure
06:49:26 <jethr0> osfameron: not sure what you're asking, but values are memoized automatically
06:49:30 <quicksilver> (that is, I wouldn't memoize explicitly)
06:49:42 <osfameron> jethr0: only during the current evaluation though?
06:49:54 <quicksilver> for as long as that value is not garbage collected
06:50:27 <jethr0> which basically means for as long as you don't leave the current context upwards
06:50:41 <osfameron> ah, ok.  But a field of a structure can suspend the calculation indefinitely until it's asked for?
06:50:53 <quicksilver> not only can, but does
06:51:14 <jethr0> osfameron: by default EVERYTHING is suspended until asked for in haskell
06:51:15 <osfameron> I'm sure I'll get to see this in action soonish when I play more with this stuff, it's all still ab ti vague just thinking about it :-)
06:51:32 <jethr0> > length (replicate 5 undefined)
06:51:34 <lambdabot>  5
06:52:27 <SamB_XP> hmm. it looks like Google has slurped 108 of our wiki pages so far...
06:52:51 <jethr0> hehe
06:53:03 <SamB_XP> some of them in russian
06:53:20 <kombinator> osfameron: the value is remembered only if there is a variable that binds to it
06:53:40 <SamB_XP> and some in espaniol
06:53:44 <Boney> I saw an interesting demonstration.
06:54:03 <SamB_XP> hmm, what language is "Savuros dialog"?
06:54:18 <osfameron> kombinator: ok, cos obviously it can't automatically memoize *everything* or it would just get huge... that makes sense
06:54:21 <Boney> a variable prims was bound to the list of all prime numbers.
06:54:27 <SamB_XP> "Capitole de manual"?
06:54:40 <Boney> then at the interactive interface thingo 'primes' was typed.
06:54:49 <Boney> which begun to calculate and print out the list.
06:54:59 <Boney> after some time t the user pressed Ctrl-C
06:55:00 <SamB_XP> "Introdução"
06:55:06 <Boney> then ran primes again.
06:55:16 <mickeyg> anyone up for some questions?
06:55:23 <Wild_Cat> SamB_XP: that last one is portuguese, I think.
06:55:30 <Boney> the second time it quickly printed out the amount of the list it calcuated on the first run, then begun to calcuate the next part.
06:55:43 <SamB_XP> what is the ISO code for portuguese
06:56:01 <Boney> so Haskell 'rememberd' part of the list which was being evaluated lasily.
06:56:37 <jethr0> > let primes = sieve [2..] where sieve (p:x) = p : sieve [ n | n <- x, n `mod` p > 0 ] in take 20 $ primes
06:56:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71]
06:57:07 <Boney> primes
06:57:09 <Boney> hehehe
06:57:29 <mux> > nubBy (\x y -> gcd x y > 1) [2..]
06:57:34 <dmhouse> > nubBy (\x y -> y `mod` x == 0) [2..]
06:57:36 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:57:37 <dmhouse> Gah.
06:57:38 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
06:57:38 * Boney waits for lambdabot's head to explode.
06:57:43 <mux> mine's shorter :-)
06:58:17 <dmhouse> Right, it's time for some revision.
06:58:27 <Boney> length primes
06:58:28 <Boney> hehe
06:58:42 * Boney is too excitable.
06:59:20 <igli> hehe
07:03:19 <SamB_XP> should I move Introdução to Pt/Introdução?
07:03:47 <SamB_XP> or, more to the point, is there any reason why I shouldn't do that?
07:05:44 <SamB_XP> Wild_Cat: can you think of anything?
07:05:59 <vincenz> hi
07:06:25 <Wild_Cat> SamB_XP: not really. You know, I don't speak portuguese :p
07:06:43 <Wild_Cat> (if you need help about some french-language stuff, however, feel free to call me up)
07:06:58 <SamB_XP> yeah, I didn't think you did. google seems to agree with you about that being portuguese though.
07:07:51 <Syzygy-> What is the type synonym thingie keyword?
07:08:01 <SamB_XP> type
07:08:05 <Syzygy-> The one that behaves kinda like String being synonymous with [Char]
07:08:17 <SamB_XP> @src String
07:08:18 <lambdabot> type String = [Char]
07:14:10 <mickeyg> with list comprehension: let res = [ x ++ y | x<-listA, y<-listB ]   now if listA is [], then res is [] as well, right?
07:14:17 <Botje> yes.
07:15:06 <Botje> however, that expression probably doesn't do what you want, though
07:15:10 <mickeyg> now, I want something slightly different. I want that res will be [ x | x<- listA ]
07:15:18 <mickeyg> is there a good way?
07:15:28 <mickeyg> besides using if directly?
07:16:11 <Lemmih> mickeyg: Say again?
07:16:50 <mickeyg> ok, some background: I am trying to build a list of combinations of words (each combination is a list of words)
07:16:57 <mickeyg> it's recursive, obviously
07:17:20 <quicksilver> you could arrange for listA to be [""}
07:17:23 <quicksilver> instead of []
07:17:29 <quicksilver> then you'd just get literal listB
07:17:34 <quicksilver> (if that's what you want)
07:18:19 <mickeyg> I did, but then I get lists like these [ ["ab","cd",""], ["xy","z","w",""] ]
07:18:38 <mickeyg> which I can work with, but I'd rather not if I don't HAVE to
07:19:21 <Lemmih> mickeyg: Works for me.
07:19:39 <mickeyg> one of the problems is that what used to be an empty list [] now becomes [ [""] ]
07:19:43 <Lemmih> >  let fun alist blist = [ a++b | a <- []:alist, b <- blist ] in fun [] ["Hello", "World"]
07:19:45 <lambdabot>  ["Hello","World"]
07:21:12 <mickeyg>  []:alist
07:21:13 <mickeyg> hm
07:21:27 <quicksilver> "":alist if you prefer
07:21:29 <quicksilver> it's the same thing
07:21:37 <quicksilver> (if alist :: String)
07:22:12 <mickeyg> I am not really concatenating strings here, I am concatenating LISTS of strings and lists of lists of strings
07:22:38 <mickeyg> let's see
07:23:00 <Lemmih> >  let fun alist blist = [ a++b | a <- []:alist, b <- blist ] in fun [] [["Hello", "World"]]
07:23:02 <lambdabot>  [["Hello","World"]]
07:24:05 <quicksilver> yes, you only get phantom [] floating around if you add [] to both lists
07:24:11 <quicksilver> if you only add [] to one list, you don't...
07:24:29 <quicksilver> but it does depend what *exactly* you want :)
07:25:10 <mickeyg> as usual, I have to figure that out before I tell you :)
07:25:26 <mickeyg> but you solution does seem to help me
07:25:43 <mickeyg> as I removed several complex if's and replaced them with this neat trick
07:26:23 <SamB_XP> huh. isn't there a better way to link together the corresponding wiki pages for different languages?
07:26:53 <quicksilver> mickeyg: good :) I tend to find I'm happier with my haskell the more ifs I remove
07:27:07 <mickeyg> they seem iffy :D
07:28:08 <osfameron> ifs are somewhat like gotos, often better to wrap them in something more high level
07:28:40 <mickeyg> I was so proud of my pun, yet no one noticed
07:29:00 <osfameron> :D
07:29:06 <SamB_XP> I think I'd rather use if's
07:29:23 <SamB_XP> @djinn if' :: a -> a -> Bool -> a
07:29:24 <lambdabot> Cannot parse command
07:29:36 <quicksilver> I prefer guards or pattern guards or list comprehension guards
07:29:41 <SamB_XP> @djinn if2 :: a -> a -> Bool -> a
07:29:42 <lambdabot> Cannot parse command
07:29:46 <quicksilver> using ifs as a last resort
07:29:51 <SamB_XP> @help djinn
07:29:51 <lambdabot> djinn <type>.
07:29:51 <lambdabot> Generates Haskell code from a type.
07:29:51 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
07:29:56 <SamB_XP> @djinn a -> a -> Bool -> a
07:29:56 <lambdabot> f a b c =
07:29:56 <lambdabot>     case c of
07:29:56 <lambdabot>     False -> b
07:29:56 <lambdabot>     True -> a
07:30:35 <quicksilver> @djinn a -> a -> a -> Bool -> Bool -> a
07:30:35 <lambdabot> f a b c d e =
07:30:35 <lambdabot>     case d of
07:30:35 <lambdabot>     False -> c
07:30:35 <lambdabot>     True -> case e of
07:30:35 <lambdabot>             False -> b
07:30:37 <lambdabot>             True -> a
07:30:45 <quicksilver> cute
07:31:06 <quicksilver> "somewhat relevant" logic
07:31:18 <SamB_XP> I never expected it to generate that right before I tried it the first time ;-)
07:32:29 <SamB_XP> huh. Google has crawled 110 of our wikipages now ;-).
07:33:43 <mickeyg> ok here's a problem with the []: method:
07:34:01 <mickeyg> > [ w:ws | w<-["p1","p2"], ws<-[]:[["ab","cd"],["xy"]] ]
07:34:06 <lambdabot>  [["p1"],["p1","ab","cd"],["p1","xy"],["p2"],["p2","ab","cd"],["p2","xy"]]
07:34:14 <mickeyg> > [ w:ws | w<-["p1","p2"], ws<-[["ab","cd"],["xy"]] ]
07:34:15 <lambdabot>  [["p1","ab","cd"],["p1","xy"],["p2","ab","cd"],["p2","xy"]]
07:34:37 <mickeyg> see the extra [["p1"]]?
07:35:22 <mickeyg> what I want, and I may be asking the impossible, is to get [["p1"]] only if the second source list is empty
07:35:45 <Lemmih> > [["ab","cd"],["xy"]] ++ [ w:ws | w<-["p1","p2"], ws<-[["ab","cd"],["xy"]] ]
07:35:46 <lambdabot>  [["ab","cd"],["xy"],["p1","ab","cd"],["p1","xy"],["p2","ab","cd"],["p2","xy"]]
07:36:07 <Lemmih> mickeyg: Use a pattern guard?
07:36:33 <mickeyg> I could do that, but I might as well use if
07:36:50 <mickeyg> I was sorta hoping for not having to write all that :)
07:40:11 <Lemmih> mickeyg: Well, you kinda have to.
07:40:31 <mickeyg> so it seems
07:40:43 <Lemmih> mickeyg: '| null blist = alist' should do the trick.
07:40:49 <mickeyg> but the []: was neat too, so at least I learned something
07:58:37 <vincenz> Lemmih `ap` #oasis
08:01:25 <vincenz> @who
08:01:25 <lambdabot> Maybe you meant: echo ghc show what wn
08:01:28 <vincenz> @users
08:01:28 <lambdabot> Maximum users seen in #haskell: 332, currently: 324 (97.6%), active: 44 (13.6%)
08:03:05 <mdmkolbe|work> lambdabot: three questions.  Who are you?  What have you done with the real 'lambdabot'?  And how did you get 'ghc' from 'who'?
08:03:17 <Botje> :)
08:05:37 <vincenz> @ghc
08:05:38 <lambdabot> ghc says: Illegal deriving item
08:05:51 <lambdabot> I -am- the real lambdabot
08:06:09 <koala_man> woot
08:06:20 <mdmkolbe|work> Insidentally it might be better to say something like 'similarlly spelled commands' instead of 'maybe you meant' b/c it's more honest with users and they will feel less miffed if it does something stupid
08:07:26 <lambdabot> Maybe you meant: Incidentally it might be better to say something like 'similarly spelled commands' instead of 'maybe you meant' b/c it's more honest with users and they will feel less miffed if it
08:07:26 <lambdabot> does something stupid
08:07:28 * mdmkolbe|work looks for the puppeteer
08:07:59 * vincenz whistles innocently
08:08:18 * vincenz removes his hand from behind lambdabot's back
08:08:50 <mdmkolbe|work> vincenz: I do like the more polite lambdabot though ;-)
08:09:07 <vincenz> :)
08:20:44 <jethr0> hola vincenz
08:21:08 <jethr0> vincenz: preparing for the next icfp already? ;)
08:23:56 <bartw> the contest or the talks ?
08:27:09 <jethr0> the contest
08:27:18 <jethr0> @seen vincenz
08:27:18 <lambdabot> vincenz is in #oasis and #haskell. I last heard vincenz speak 10m 21s ago.
08:27:31 <vincenz> yow
08:27:35 * vincenz smacks jethr0 around a bit
08:27:35 <jethr0> @yow
08:27:36 <lambdabot> 	Talking Pinhead Blues:
08:27:36 <lambdabot> Oh, I LOST my ``HELLO KITTY'' DOLL and I get BAD reception on channel
08:27:36 <lambdabot>     TWENTY-SIX!!
08:27:36 <lambdabot>  
08:27:36 <lambdabot> Th'HOSTESS FACTORY is closin' down and I just heard ZASU PITTS has been
08:27:38 <lambdabot> [7 @more lines]
08:27:39 <bartw> can't wait for it to start, but how do you intent to prepare for it ?
08:27:40 <jethr0> huh
08:27:43 <vincenz> jethr0 `ap` #oasis
08:31:01 <vincenz> Writing haskell code is riding a unicycle, even if you haven't done it in a while, it's still hard.
08:31:13 * vincenz adds a 'like'
08:32:39 <jethr0> > riding unicycle where {riding = id; unicycle = "difficult"}
08:32:39 <lambdabot>  Parse error
08:36:14 <Baughn> What's the license on the GHC RTS?
08:36:35 <Baughn> Or, rather, on ghc-produced programs in general?
08:37:08 <quicksilver> Baughn: GHC does not impose any conditions on ghc-produced code
08:37:31 <vincenz> quicksilver: not even about using it to control nuclear missiles?
08:37:38 <quicksilver> AFAIK, it's a ver unrestrictive BSD-style license
08:37:39 <Baughn> quicksilver: It embeds the RTS in said code, though. So where's the license?
08:38:15 <sjanssen> vincenz: probably not -- that was an example in the STM paper IIRC
08:38:31 <vincenz> sjanssen: it was an inside joke referring to the java license :P
08:38:39 <vincenz> sjanssen: "Can't use this to control nuclear centrals"
08:39:05 <arcatan> i bet it'd suck if nuclear missile control software would crash during flight
08:39:16 <vincenz> arcatan: especially during launch
08:39:24 <arcatan> yeah
08:39:25 <quicksilver> Baughn: in a file called, rather controversially, LICENSE
08:39:28 <Baughn> arcatan: Then the missile wouldn't explode. I consider that a plus.
08:39:41 <vincenz> Baughn: says who, crashes are uncontrolled events
08:39:50 <Baughn> quicksilver: http://haskell.org/ghc/license.html applies to the RTS?
08:39:50 <lambdabot> Title: The Glasgow Haskell Compiler
08:40:26 <jethr0> yeah, what's up with the shouting in filenames
08:40:31 <quicksilver> Baughn: that is my reading, given that the RTS lives in the same directory and there is no notice to the contrary
08:40:44 <sproingie> BLAME GNU
08:41:04 <arcatan> BLAME CANADA
08:41:19 <Baughn> quicksilver: I'm not a lawyer, and I'm heading into highly lawyeriffic territory right now, considering that I'm planning to embed GHC (not just the RTS, the compiler as well) into a proprietary program that I don't personally own that has a highly /restrictive/ license
08:41:34 <Baughn> Fortunately, GHC's seems compatible. /Seems/. I hope it is.
08:42:59 <quicksilver> Baughn: my understanding is the that 'BSD3' style license is essentially compatible with anything except deliberate deception
08:43:14 <quicksilver> Baughn: i.e. you can't claim the university of glasgow wrote, or approves of, your software
08:43:32 <Baughn> quicksilver: That's okay. I don't think *anyone* approves of my software.
08:43:45 <bartw> i hope you yourself do ? :)
08:44:06 <vincenz> liftM shout jethr0
08:44:13 <Baughn> bartw: Not really. I'm still on the learning curve, so the older bits look horrible. :P
08:44:31 <bartw> Baughn : that never ends actually, get used to it
08:44:35 * jethr0 wonders what "highly /restrictive/" could mean...
08:44:50 <jethr0> liftM2 shout2 vincenz wazzzuuppp?
08:45:12 <Baughn> jethr0: "Don't even think about redistributing this source code yourself, despite it being freely available". And more along those lines.
08:45:22 <jethr0> Baughn: there's only one solution for that: the continuous rewrite ;)
08:45:44 <jethr0> ahh, highly restrictive after supplying the source!
08:45:45 <bartw> better let the code rot until you replace it
08:45:51 <Baughn> jethr0: The older bits work fine, though. They just look uncomfortably like lisp.
08:46:00 <bartw> usually actually the old parts work best
08:46:19 <bartw> normally because the 'bad' old code gets replaced :)
08:46:29 <jethr0> i wish i could write code that looked like lisp. everything i write looks like Visual Basic even though i've never used or learnt it
08:47:17 <Baughn> bartw: Sure, but there's not a single non-IO monad in there, whereas newer code is full of them
08:47:24 <jethr0> speaking of which, i have to print out the VBA tutorial to get a real l33t excel hacker *shudders*
08:47:32 <Baughn> It makes it hard to read
08:47:46 <jethr0> s/get/become/
08:48:28 <Baughn> jethr0: Contrary to popular opinion, VBA isn't that horrible a language. It's just that all the users tend to misuse it.
08:48:58 <vincenz> Baughn: same for C, those damn users and their dangling pointers
08:49:07 <jethr0> hehe, i don't think it horrible. i'm just not convinced that you should implement your COMPLETE business logic of a huge company on it.
08:49:11 <bartw> it isn't totally the language, average user iq has something to do with it too
08:49:46 <Baughn> jethr0: ..no, probably not.
08:49:51 <jethr0> vincenz: but i must admit that i've produced my fair share of dangling pointers. 80% bad habits, 20% language-thats-not-supposed-for-late-night-coding
08:50:12 <Baughn> jethr0: You know about valgrind, right? ;)
08:50:30 <fasta> Is FOO? a valid CPP identifier?
08:50:41 <Baughn> fasta: No, ? is syntax
08:50:48 <bartw> i would advice everybody to learn some assembly and build their own debugging memory manager
08:50:54 <jethr0> vincenz: came to know it very intimately *brr*. it's a great tool, but before i came to know it, it was just staring at the code until the bug disappeared for me *sniff*
08:51:01 <bartw> altough not necesarily at the same time
08:51:15 <fasta> bartw: ?
08:51:24 <Baughn> fasta: ..rather, ? is syntax in C, and therefore special-cased in CPP
08:51:33 <fasta> Baughn: Thanks, FOOP it is.
08:51:33 <jethr0> bartw: seems like two trivial things that are made to be done at the same time!
08:51:34 <Baughn> fasta: Another good reason not to use CPP for haskell, but meh
08:52:01 <fasta> I think it's stupid one cannot use ? in identifiers in Haskell, but that's another story.
08:52:15 <fasta> It breaks Scheme "tradition".
08:52:32 <jethr0> there's nothing like a nice "debugging memory manager" written completely in assembly. think of how fast it's gonna be *laughs-and-cries-at-the-same-time*
08:52:40 <vincenz> let a ? b = a + b in 1 ? 2
08:52:45 <vincenz> > let a ? b = a + b in 1 ? 2
08:52:47 * jethr0 likes trailing "?" for predicates
08:52:48 <bartw> jethr0 : a good memory managed, shared across modules, fast, threadsafe, read allignment near readdenied pages, and tracking leaks, isn't very easy
08:52:49 <lambdabot>  3
08:52:55 <vincenz> fasta: you were saying?
08:52:59 <quicksilver> the general haskell rule is that all symbolics are potential operators
08:53:04 <fasta> vincenz: you know perfectly well what I was saying.
08:53:10 <quicksilver> with just ' as an exception
08:53:11 <Syzygy-> > let odd? n = (n`mod`2 == 1) in odd? 3
08:53:11 <vincenz> fasta: ? is an identifier
08:53:12 <lambdabot>  True
08:53:24 <SamB> okay, why doesn't my Trac account have permission to make new GHC bugs?
08:53:27 <fasta> Wth..
08:53:28 <vincenz> Syzygy-: nice trick, won't work in general
08:53:32 <vincenz> Syzygy-: odd exists
08:53:37 <jethr0> k, see you all later.
08:53:41 <Syzygy-> Oh, that's why it worked?
08:53:42 <vincenz> > let bleep? n = n > 2 in bleep?
08:53:43 <lambdabot>  Parse error
08:53:44 <vincenz> > let bleep? n = n > 2 in bleep? 3
08:53:44 <lambdabot>   Not in scope: `bleep'
08:53:47 <vincenz> see
08:53:48 <Syzygy-> Oh. Ooops.
08:53:50 <jethr0> vincenz: count me in for now for the ICFP.
08:53:53 <vincenz> first bleep is a variable
08:53:57 <vincenz> second bleep is looked u[p
08:54:01 <vincenz> jethr0: good
08:54:11 <jethr0> vincenz: and i won't disappear as silently this time as i did last year *promise*
08:54:12 <fasta> I want to use the "?" at the end of variable names.
08:54:13 <vincenz> fasta: ? is a symbolic identifier... reason this is done so we can have infix
08:54:17 <fasta> Not as an operator.
08:54:26 <vincenz> fasta: that'd make parsing ambiguous
08:54:34 <vincenz> it's a choice
08:54:36 <quicksilver> well the simplistic lexical rules are a compromise
08:54:43 <quicksilver> they're quite handy, but they're a compromise
08:54:45 <Baughn> > let foo& = (+) in foo& 2 3
08:54:45 <lambdabot>  Parse error
08:54:47 <vincenz> foo? names vs infix identifiers
08:54:49 <fasta> vincenz: I think it's a bad choice.
08:54:58 <vincenz> fasta: well ... like all opinions, they differ
08:55:02 <fasta> vincenz: indeed
08:55:02 <bartw> lets keep ?!@ etc out of identifiers :)
08:55:11 <Baughn> I'd like some non-simplistic lexical rules, please. They only need to be written once. ;)
08:55:28 <fasta> Maybe I should start "Haskell with "?"".
08:55:29 <Baughn> Oh, right.. whitespace is optional
08:55:53 <quicksilver> well you'd need to make it possible to change the lexical class of a token
08:55:56 <quicksilver> like you can in TeX
08:56:01 <quicksilver> that way (another kind of) madness lies
08:56:06 <SamB> who is in charge of the GHC trac?
08:57:16 <Igloo> SamB: What's up?
08:57:36 <SamB> Igloo: it says my account lacks TICKET_CREATE privileges
08:57:46 <Igloo> What's your username?
08:57:49 <SamB> SamB
08:58:06 <SamB> also it doesn't say who to contact if trac gives you trouble in any obvious place...
08:58:30 <Igloo> OK, should be fixed now
08:58:58 <SamB> yeah.
08:59:18 <jethr0> *yeah* flamewar about bad haskell syntax choices. /me throws in (-) vs. subtract
09:00:01 <Igloo> jethr0: What about it?
09:00:09 <jethr0> also, OPTIONAL whitespace a la fortran has done wonders for readability in the past.
09:00:21 <osfameron> yeah, (-) is slightly insane
09:00:38 <osfameron> the optional whitsepace is surprisingly good
09:00:55 <mdmkolbe|work> > -1
09:00:59 <jethr0> osfameron: nah, i like some whitespace around my tokens
09:01:00 <lambdabot>  -1
09:01:01 <mdmkolbe|work> > - 1
09:01:03 <lambdabot>  -1
09:01:06 <mdmkolbe|work> > 2 -1
09:01:07 <lambdabot>  1
09:01:16 <mdmkolbe|work> so what is the problem?
09:01:25 <malcolmw> fasta: looking back at the logs, I see you have been having trouble with cpphs - I think I recently fixed all the bugs that were troubling you
09:01:26 <Syzygy-> :t (-1)
09:01:28 <lambdabot> forall a. (Num a) => a
09:01:28 <jethr0> > (+2) 3
09:01:30 <lambdabot>  5
09:01:31 <Syzygy-> :t (subtract 1)
09:01:33 <lambdabot> forall t. (Num t) => t -> t
09:01:34 <Syzygy-> That's the problem
09:01:35 <jethr0> > (-2) 3
09:01:35 <lambdabot>   add an instance declaration for (Num (t -> a))
09:01:35 <lambdabot>     In the expression: (- 2)...
09:01:39 <mdmkolbe|work> ah
09:01:45 <Syzygy-> 'Or rather even
09:01:49 <Syzygy-> :t (2-)
09:01:51 <lambdabot> forall t. (Num t) => t -> t
09:01:51 <Syzygy-> :t (-2)
09:01:52 <MyCatVerbs> GAWD! Haskell makes the most horrific _abominations_ actually fun to write.
09:01:53 <lambdabot> forall a. (Num a) => a
09:01:59 <quicksilver> I'm with jethr0
09:02:06 <quicksilver> - should be sections
09:02:16 <quicksilver> if I have to write anything in full it should be negate
09:02:19 <Syzygy-> And something like (negate 2) for the other.
09:02:21 <quicksilver> or a different char entirely
09:02:21 <jethr0>  > letidentifier=solutioninidentifier
09:02:24 <Syzygy-> Yeah
09:02:29 <jethr0> ~
09:02:37 <Igloo> Syzygy-: That I agree with, but that's about unary minus, not (-) or subtract
09:02:43 <mdmkolbe|work> mehh, you can always do ((-) 2)
09:02:45 <MyCatVerbs> Want to add, multiply, subtract strings from one another? No problem, write a data Z = Z String then define instance Num Z. Yeeeouch.
09:02:53 <Baughn> I'd go for (-2) being different from (- 2). -2 should be number syntax, not a function call.
09:02:59 <Syzygy-> Igloo: But the only reason we do have subtract is because prefixed (-) is unary.
09:03:08 <jethr0> Baughn: *bah*, that a nightmare for readability
09:03:11 <Igloo> True
09:03:16 <jethr0> 's
09:03:50 <Syzygy-> Baughn: GODS no! An almost invisible and highly syntactically relevant whitespace. Yech!
09:03:55 <Baughn> jethr0: Alternately, apply unicode. It has separate characters for "negative 2" and "minus 2".
09:04:02 <pharm> <tongue in cheek>But Haskell' will fix *all* these problems, won't it.</tongue in cheek>
09:04:05 <Syzygy-> Baughn: Readability? Anyone?
09:04:16 <jethr0> nice, have two identically looking characters for unary and binary minus *g*
09:04:18 <Baughn> Syzygy-: Syntax coloring. ;)
09:04:18 <fasta> malcolmw: I am using cpphs for about 2 weeks now.
09:04:26 <pharm> Baughn: oh yeah, that'll be readable :)
09:04:30 <osfameron> unicode--
09:04:31 <MyCatVerbs> Baughn: alternatievely, steal the OCAML solution and have different operators for negation and subtraction. - and ~, in that case.
09:04:32 <Baughn> jethr0: Oh, they don't look /identical/. The unary minus is slightly shorter.
09:04:45 <fasta> malcolmw: I worked around a few bugs.
09:04:45 <Syzygy-> Baughn: Thanks. Now I'm sitting with my stupid term that will neither display full unicode nor colours. Thanks. :)
09:04:48 <fasta> malcolmw: thanks for interest.
09:05:16 <malcolmw> fasta: bug me by email if you find any new differences between cpp and cpphs
09:05:52 <sjanssen> @hoogle catchIO
09:05:52 <lambdabot> No matches found
09:06:09 <dukedave> Could just do with out the unary negation operator all together and just force people to use  0-n  :)
09:06:41 <pharm> Is (0-n) different from -n for FP numbers?
09:07:03 <fasta> malcolmw: If you could convince someone at Debian to package your application, that would make life easier.
09:07:06 <dukedave> > (0-3) == -3
09:07:10 <lambdabot>  True
09:07:10 <fasta> malcolmw: the last version was 0.7
09:07:21 <mdmkolbe|work> ?type (0-3)
09:07:22 <lambdabot> forall t. (Num t) => t
09:07:24 <mdmkolbe|work> ?type -3
09:07:26 <lambdabot> forall a. (Num a) => a
09:07:41 <malcolmw> fasta: huh? I packaged up version 1.5 recently
09:07:51 <pharm> >(0::Double -3 == (-3)::Double
09:08:00 <pharm> oops
09:08:08 <pharm> >((0::Double) -3) == (-3)::Double
09:08:11 <vincenz> space
09:08:14 * malcolmw wonders who is the debian maintainer for cpphs?
09:08:19 <vincenz> > ((0::Double) -3) == (-3)::Double
09:08:19 * pharm pokes lambdabot
09:08:20 <lambdabot>  Couldn't match expected type `Double' against inferred type `Bool'
09:08:23 <vincenz> pharm: space
09:08:28 <Baughn> > (0 :: Double) == (-0 :: Double)
09:08:29 <lambdabot>  True
09:08:29 <vincenz> > 1
09:08:30 <lambdabot>  1
09:08:34 <pharm> >((0::Double) -3) == ((-3)::Double)
09:08:37 <vincenz> pharm: space
09:08:43 <vincenz> > expression  ... not >expression
09:08:43 <Syzygy-> > ((0::Double)-3) == ((-3)::Double)
09:08:44 <lambdabot>   Not in scope: `expression'
09:08:45 <lambdabot>  True
09:08:49 <fasta> malcolmw: I downloaded 1.4 recently, so my information must be out of date.
09:08:50 <pharm> ?
09:08:58 <Syzygy-> pharm: You keep forgetting a space after >
09:09:04 <pharm> ah.
09:09:05 <pharm> ta,
09:09:06 <Syzygy-> pharm: And thus lb doesn't recognize it as a command
09:09:08 <pharm> > ((0::Double) -3) == ((-3)::Double)
09:09:09 <lambdabot>  True
09:09:13 <pharm> TaDa!
09:09:16 <Syzygy-> :)
09:09:19 <pharm> :)
09:09:27 <dukedave> Hehee, good work team
09:09:47 <dukedave> Another way:
09:10:07 <Saizan> you abuse type annotations, (==) :: Eq a => a -> a -> Bool
09:10:10 <dukedave> > let minus = (\n -> 0-n) in       minus 6
09:10:11 <lambdabot>  -6
09:10:27 <vincenz> simple
09:10:35 <vincenz> > 0.0 - 3 == (-)
09:10:36 <lambdabot>        add an instance declaration for (Fractional (a -> a -> a))
09:10:39 <vincenz> > 0.0 - 3 == (-30
09:10:39 <lambdabot>  Parse error
09:10:41 <vincenz> > 0.0 - 3 == (-3)
09:10:42 <lambdabot>  True
09:10:47 <vincenz> 0.0 defaults to double
09:10:54 <vincenz> rest is what Saizan said
09:11:04 <jethr0> malcolmw: apt-cache show cpphs (or something like that ;)
09:11:10 <fasta> malcolmw: In unstable I still see 0.7-4 as latest version
09:11:25 <fasta> malcolmw: Maybe it's only in experimental
09:11:52 <vincenz> > (1/3)*3 == 1
09:11:53 <lambdabot>  True
09:14:03 <fasta> malcolmw: the latest package in Debian is the one I mentioned.
09:14:23 <fasta> malcolmw: so, Debian is distributing a pretty broken version of your software.
09:14:55 <malcolmw> fasta: I don't use debian, so I can't do anything about that, except poke the debian maintainer with a big stick
09:15:29 <fasta> malcolmw: I would either tell him to stop distributing it or to update it.
09:15:31 <malcolmw> fasta: oh, I see it is Igloo's fault :-)
09:15:59 <Igloo> Yeah, updating it is on my TODO list
09:16:13 * fasta thinkgs Igloo TODO list is long :)
09:16:18 <fasta> thinks*
09:16:29 <fasta> Igloo's*
09:16:34 * malcolmw pokes Igloo with a slightly shorter stick than he was originally going to
09:16:35 <Igloo> It is; feel free to do some of it  :-)
09:17:12 <fasta> Igloo: I don't know the process of becoming a "packager".
09:17:38 <fasta> Igloo: The way I read it, it takes a considerable amount of time and you need to find a mentor, etc.
09:18:42 <malcolmw> Outstanding bugs: #393598: new upstream version of cpphs available, 237 days old.
09:20:43 <malcolmw> Igloo: arjanoosting sent a patch to update debian to cpphs-1.3, but it never got merged?
09:21:24 <ndm> i read that as 393598 outstanding bugs
09:21:33 <ndm> i don't think even Yhc has that many...
09:22:25 <fasta> ndm: it is the total amount of bugs in about 200 million LOC currently found.
09:22:35 <Igloo> malcolmw: Right. I think I finally got ghc6+extralibs done 3 days ago, so I'll be going through the other packages when I next have some time for Debian work
09:22:43 <pharm> That's outstanding bugs, for this package, of which one is Debian bug number ######
09:22:52 <fasta> ndm: including feature requests, etc.
09:23:13 <dukedave> Hey guys, any idea on:
09:23:14 <dukedave> foo.hs:1:0:
09:23:14 <dukedave>     Failed to load interface for `System.FilePath':
09:23:14 <dukedave>       locations searched:
09:23:14 <dukedave>         System/FilePath.hi
09:23:14 <dukedave>         System/FilePath.hi-boot
09:23:29 <Igloo> dukedave: Use -package filepath or --make
09:24:03 <Igloo> Hmm, actually, I think that would be a different error. Do you have the filepath package installed? (ghc-pkg list)
09:24:10 <dukedave> Same problem Igloo Brought on trying to install Yi from darcs
09:24:32 <Igloo> If you have GHC 6.6 or older then filepath doesn't come with it
09:24:52 <dukedave> Aha, confirmed
09:25:17 <dukedave> Thanks very much... And so, what would be the most sane way to obtain it?
09:25:33 <dukedave> We don't have anything like CPAN right?
09:25:45 <Igloo> Wrong: http://hackage.haskell.org/
09:25:47 <lambdabot> Title: HackageDB: introduction
09:26:00 * dukedave goes to read.
09:26:01 <dukedave> Thanks
09:26:31 <Igloo> You can either compile it by hand, or in theory cabal-install will do it for you (but you'll have to compile cabal-install by hand)
09:27:19 <dukedave> Seem to have a third option of apt (being an Ubuntu user)
09:28:47 <dukedave> Sooner or later I'll experience Haskell's cabal :)
09:28:57 <dukedave> Damn people making things too easy :)
09:33:47 <ndm> as a Windows user, cabal makes me cry quite regularly
09:34:20 <Saizan> strange, on windows i found it quite pleasant to use
09:35:33 <ndm> ever try releasing something or building haddock documentation?
09:35:37 <Saizan> no cygwin or sh port needed etc..
09:36:12 <Saizan> builiding haddock is not just runhaskell Setup haddock?
09:36:41 <Saizan> i've not experienced releasing anything, though
09:36:47 <dukedave> ndm: Are you sure the blame is loaded correctly? I couldn't help but notice the pattern:  "as a Windows user [] makes me cry quite regularly"
09:36:49 <dukedave> :)
09:37:05 <ndm> dukedave: very sure!
09:37:15 <SamB> is there a pragma to say "don't warn me about this case overlapping"?
09:37:30 <ndm> Saizan: building haddock would be that easy, if it always worked
09:37:43 <SamB> or maybe even "warn me if this case could occur"?
09:37:50 <ndm> @google ghc haskell flags
09:37:52 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
09:37:52 <lambdabot> Title: 4.17. Flag reference
09:38:17 <ndm> -fwarn-nooverlapping-patterns
09:38:25 <ndm> -fnowarn-overlapping-patterns , i mean
09:38:36 <ndm> -fno-warn-overlapping-patterns , even
09:39:00 <SamB> dukedave: a lot of stuff that ought to work fine in Windows doesn't -- just because of a few gratuitous assumptions...
09:41:13 <dukedave> Haha
09:41:39 <SamB> ndm: that would ignore all overlapping patterns
09:41:59 <ndm> SamB, oh, i don't think you can turn it off on a per function basis
09:42:04 <SamB> I'm talking about ignoring or even asserting *one* overlapping pattern
09:42:20 <SamB> ndm: no, I mean on a per pattern basis, essentially
09:42:38 <SamB> my use case is happy
09:42:40 <ndm> SamB, yeah, i think its per-file or nothing
09:42:57 <dukedave> ndm: I just thought "I'm sure I've seen some case checker someone wrote about on Haskell-Cafe a while back", spend a few minutes Googling.. I'm guessing http://www-users.cs.york.ac.uk/~ndm/catch/ is yours? :)
09:42:58 <SamB> it always inserts a catch-all like this:
09:42:58 <lambdabot> Title: Neil Mitchell - Catch: Case Totality Checker for Haskell
09:43:18 <SamB> 	_ -> happyError' tk
09:43:38 <ndm> dukedave: yep, that's mine - now released :)
09:43:57 <ndm> SamB, GHC's case checker is not very good
09:44:00 <SamB> in the case for mapping token values to nonterminals
09:44:06 <SamB> ndm: so?
09:44:06 <ndm> SamB, perhaps _ | otherwise ->  would fool it?
09:44:09 <dukedave> Ah, I hope one day I can fly at those dizzy heights :)
09:44:42 <SamB> okay, so how about just ignoring that case?
09:44:51 <SamB> if it happens to overlap
09:44:56 <ndm> SamB, not possible, as far as i am aware
09:45:08 <ndm> the | otherwise trick might make it not report that as an error
09:45:09 <Igloo> Yeah, I don't think it's possible, unfortunately
09:45:14 <SamB> how ought it to look, though?
09:45:24 <ndm> how do you mean?
09:45:26 <Igloo> That trick won't help
09:45:42 <SamB> if there were a pragma for this... what should it be, and where should it go?
09:45:44 <ndm> why not? doesn't it take into account guards?
09:46:09 <Igloo> It does, but /any/ pattern there is unreachable, so will be warned about
09:46:18 <ndm> I'd probably imagine {-# BEGIN_NO_WARNINGS #-} .... {-# END_NO_WARNINGS #-}
09:46:26 <ndm> ah, true, you'd have to | otherwise the line before it :)
09:46:35 <dukedave> Any idea why Yi is kicking out "setup: cannot satisfy dependency yi-lib>=0.3"
09:46:49 <Igloo> | otherwise won't help because GHC will know that it will always match
09:47:12 <Igloo> And I think you want a finer grained pragma than that
09:47:46 <Igloo> {-# NoOverlappingWarning #-}, but I'd have to think about where you put it and what it attaches to
09:47:46 <ndm> does the pattern match checker go that deep?
09:48:01 <ndm> or does it just have a special case for otherwise
09:49:04 <ndm> if you just have a big bang nowarnings pragma then you can mark sections of your code as "i've checked this by hand"
09:49:17 <Igloo> I'm fairly sure it does, although I'm a bit confused now as it hasn't run the simplifier at that point, I don't think
09:49:39 <ndm> FWIW, #pragma nowarn(number,number) in MSVC does the job on a line by line basis
09:51:29 <SamB> ndm: I don't want no warnings
09:54:10 <SamB> maybe "case ... of ... ; {-# OVERLAPPING #-} _ -> ..."?
09:55:26 <SamB> or maybe it should go on the other side of pattern, or even the other side of the arrow
09:56:30 <sjanssen> why don't you want an overlapping pattern warning?
09:56:55 <bartw> nl
09:58:09 <olsner> @pl  (\(x,y) -> (x:y))
09:58:09 <lambdabot> uncurry (:)
10:00:36 <SamB> sjanssen: well, for one thing Happy *always* generates this particular alternative
10:00:49 <olsner> @pl (case xs of [] -> []; xs -> xs)
10:00:49 <lambdabot> (line 1, column 16):
10:00:49 <lambdabot> unexpected ">"
10:00:49 <lambdabot> expecting variable, "(", operator or ")"
10:01:36 <olsner> huh? @pl can't parse case expressions?
10:01:41 <ddarius> pl has its own "Haskell" parser.
10:02:28 <sjanssen> it can't do much with general case expressions anyway
10:03:30 <olsner> hmm, probably not
10:04:16 <Baughn> @pl \xs -> case xs of [] -> []; xs -> xs
10:04:17 <lambdabot> (line 1, column 22):
10:04:17 <lambdabot> unexpected ">" or "-"
10:04:17 <lambdabot> expecting variable, "(", operator or end of input
10:04:39 <ddarius> Incidentally, that is just id.
10:05:24 <Baughn> I see no reason to overwork the poor bot
10:06:13 <ddarius> It scares me how old lambdabot is.  It scares me how long I've been a Haskeller.
10:06:53 <olsner> yeah, I know it's just id.. I'm just looking for some way to pointfreeing pattern matching... f [] = []; f xs = (@pl ...) xs ... since the second variant has to use the variable the pointfreeing is just obfuscation
10:07:29 <ddarius> olsner: To point-free pattern matching you use higher order combinators.
10:08:09 <olsner> I want pl to do all my work for me so that I don't have to actually learn anything
10:08:41 <Baughn> Figuring out pl output makes for good exercise. ;)
10:08:41 <ddarius> olsner: That's Djinn
10:09:03 <Baughn> @djinn Int -> Bool
10:09:06 <Saizan> defList z f xs = if null xs then z else f xs
10:09:07 <lambdabot> f _ = False
10:09:43 <olsner> so what I want is f = defList [] (@pl ...)?
10:09:51 <Saizan> yup
10:10:20 <olsner> @index defList
10:10:20 <lambdabot> Text.Html
10:10:29 <Saizan> feel free to substitute the if with a case expression
10:10:35 <Baughn> > let a $ b $ c = a + b * c in 2 $ 3 $ 4
10:10:35 <lambdabot>  Parse error in pattern
10:10:41 <Saizan> i've coined that right now
10:12:43 <Baughn> > 2 `+` 3
10:12:43 <lambdabot>  Parse error
10:12:49 <Baughn> > 2 `(+)` 3
10:12:50 <lambdabot>  Parse error
10:13:14 <olsner> I think `` only works for names
10:13:16 <Baughn> ..granted, that code is a bit perverse, but it seems like it should work
10:14:09 <olsner> something like f `(.).(.)` g should also work but doesn't - IMO `` should work for arbitrary functional expressions ;-)
10:14:26 <ddarius> @oldwiki InfixExpressions
10:14:27 <lambdabot> http://www.haskell.org/hawiki/InfixExpressions
10:14:31 <takamura> hi
10:14:32 <Baughn> :t (.).(.)
10:14:34 <lambdabot> forall a b c a1. (b -> c) -> (a -> a1 -> b) -> a -> a1 -> c
10:14:56 <olsner> :t (\f g x -> f (g x) x)
10:14:58 <lambdabot> forall t t1 t2. (t1 -> t -> t2) -> (t -> t1) -> t -> t2
10:15:00 <ddarius> @oldwiki InfixExpression
10:15:00 <lambdabot> http://www.haskell.org/hawiki/InfixExpression
10:15:27 <olsner> @unpl (.).(.)
10:15:28 <lambdabot> (\ i b c f -> i (b c f))
10:16:00 <olsner> :t (\f g x -> f . (g x))
10:16:02 <lambdabot> forall t b c a. (b -> c) -> (t -> a -> b) -> t -> a -> c
10:16:11 <olsner> that's (.).(.)
10:17:18 <takamura> someone knows a library to sort a list of words alphabetically?
10:17:37 <Baughn> > sort ["beta","alfa"]
10:17:38 <lambdabot>  ["alfa","beta"]
10:18:04 <takamura> but sort is ascii-oriented
10:18:16 <Baughn> Wasn't that what you wanted?
10:18:23 <Baughn> There's always sortBy, too.
10:18:25 <takamura> there is a more general library, with functions for many languages?
10:18:52 <Baughn> takamura: Char's instance of Ord /should/ be valid for all of unicode
10:18:53 <takamura> I want to sort words in Spanish, with accented letters
10:19:03 <Baughn> Where it isn't, I'm sure GHC would enjoy the patches
10:19:19 <takamura> but for that instance, i<í
10:19:20 <Baughn> Hmm. Ord. No, not ORd...
10:19:23 <Baughn> :t sort
10:19:25 <takamura> also z<í
10:19:25 <lambdabot> forall a. (Ord a) => [a] -> [a]
10:19:30 <Baughn> ..oh. Yes Ord.
10:19:45 <takamura> that is not good for languages other tahn English
10:19:56 <olsner> > z < í
10:19:57 <lambdabot>  Illegal character ''\173''
10:19:59 <Baughn> takamura: Are you sure sort doesn't already handle it?
10:20:07 <olsner> > z < '\173'
10:20:08 <lambdabot>   Not in scope: `z'
10:20:09 <Baughn> olsner: Sadly, lambdabot doesn't accept unicode
10:20:12 <takamura> it handle it, but in the wrong order
10:20:16 <olsner> > 'z' < '\173'
10:20:17 <lambdabot>  True
10:20:24 <Baughn> takamura: Have you tried submitting a patch?
10:20:48 <takamura> accented letters should NOT be sorted in unicode order for any language
10:20:50 <Baughn> takamura: Alternately, sortBy works. I don't think there's a library for it, though.
10:21:06 <Saizan> Baughn: i think Char should keep the codepoints order
10:21:17 <takamura> what i want is a function for Spanish, other for Japanese, etc
10:21:24 <takamura> yes
10:21:44 <Baughn> takamura: You'll probably have to build it yourself. Happily, that should be trivial.
10:21:49 <takamura> the codepoint order is ok for sort, what I whant is sortSpanish, sortFrench... etc.
10:22:22 <takamura> yes, I only wanted to know if someone did it before and put it in a nice library :D
10:22:24 <Saizan> takamura: you may ask to haskell-cafe, but suspect you'd have to write the comparison function yourself and use it with sortBy
10:22:57 <norgul> hey
10:22:59 <Baughn> takamura: Write such a library, and upload it to hackage.:)
10:23:06 <norgul> i have some questions
10:23:06 <takamura> :)
10:23:20 <norgul> i just wrote my own map function
10:23:31 <norgul> my_map f [] = []
10:24:18 <norgul> my_map f (x:xs) = f x : my_map f xs
10:24:40 <norgul> does this cons the result of f x to the rest of the list
10:24:51 <takamura> ok, I will write the Spanish part (maybe also useful for other languages in the Latin-1 range)
10:24:52 <jethr0>  norgul: congrats
10:24:52 <norgul> or is : a following function?
10:24:53 <Saizan> yes
10:25:05 <jethr0> : binds extremely weakly
10:25:18 <jethr0> s/extremely/quite
10:25:18 <Saizan> ?type (:)
10:25:20 <lambdabot> forall a. a -> [a] -> [a]
10:25:38 <Baughn> norgul: Function application binds more strongly than pretty much everything else, so it's (f x) : (my_map f xs)
10:26:06 <vincenz> @type (:undefined)
10:26:08 <lambdabot> forall a. a -> [a]
10:26:19 <Baughn> Function application for standard, self-defined functions, that is
10:26:28 <jethr0> @type (:[])
10:26:29 <lambdabot> forall a. a -> [a]
10:27:21 <norgul> so it isn't a cons operator in this action?
10:27:21 <norgul> so it creates a new list?
10:27:50 <Philippa> it's cons with the tail pre-applied
10:27:57 <Baughn> norgul: It is cons, and it does create a new list
10:28:15 <vincenz> (:[]) == (lambda (x) (cons x ()))
10:28:21 <norgul> k
10:28:54 <norgul> so how can it append the recursion to the x ?
10:29:23 <norgul> never mind
10:34:57 <fasta> How can I use CPPHS to make two bindings that are indented as much? I want to make my macros better to read.
10:34:58 <norgul> so it conses the result of (f x) to a new list?
10:35:39 <fasta> @where tutorial
10:35:39 <lambdabot> http://www.haskell.org/tutorial/
10:39:05 <emu> i think i'm having trouble generating random numbers in a timely fashion
10:39:36 <Saizan> timely?
10:39:45 <emu> rey_: time
10:39:47 <emu> oops
10:39:50 <emu> regarding time
10:40:10 <emu> adding a bogus random boolean generation line to my program causes it to take 5x as long
10:40:16 <emu> well let me put it this way
10:40:29 <emu> i replaced the randomized algorithm with a bogus deterministic and fast predicate
10:40:45 <emu> so to be sure it was processing the input quickly
10:41:06 <emu> then i added 1 line which generates a random Bool and doesn't do anything with it, and my program's performance decreased by 5x
10:41:26 <fasta> emu: mail to spj
10:50:50 <SamB> Igloo: there aren't any newer RCs for Happy? It still has that bug I reported a while back...
10:50:56 <araujo> hello
10:51:30 <SamB> hi
10:52:49 <norgul> use of parantheses, is that function application?
10:53:40 <SamB> I wish GHC could derive Show instances for void types...
10:53:50 <Philippa> parens are just parens, nothing else
10:54:02 <Philippa> function application is just putting things in sequence, like so:
10:54:04 <Philippa> f 1 2 3
10:54:05 <norgul> what is func app, then?
10:55:45 <norgul> ($)
10:56:36 <byorgey> norgul: f $ x is the same as f x, but it has low precedence so it's used sometimes to avoid parentheses
10:56:59 <norgul> k
10:57:00 <byorgey> > negate (length [1,2,3])
10:57:01 <lambdabot>  -3
10:57:04 <norgul> i see
10:57:06 <byorgey> > negate $ length [1,2,3]
10:57:07 <lambdabot>  -3
10:57:29 <byorgey> norgul: you can also use it to do things like
10:57:48 <byorgey> > map ($1) [(2+), (3*), negate]
10:57:49 <lambdabot>  [3,3,-1]
10:57:58 <Japsu> @pl \v -> v `mod` n /= 0
10:57:58 <lambdabot> (0 /=) . (`mod` n)
11:05:57 <SamB> Igloo: hey, I sent you a Happy patch.
11:06:22 <SamB> it would make me happy if you would apply it and make a debian package soonish...
11:07:25 <SamB> @tell Igloo I sent you a Happy patch. I tried to send it in before but it seems to have gotten lost somewhere.
11:07:25 <lambdabot> Consider it noted.
11:25:09 <Modius> Is there a term for what is being done when chaining functions together?  E.g. if I want to chain    capitalize and to-string so into a single function that takes (some item) and returns capitalized string?
11:25:33 <olsner> composition
11:25:57 <Modius> Thanks
11:36:26 <emu> @^%&^%@^ randomized algorithms
11:36:26 <lambdabot> Unknown command, try @list
11:36:28 <emu> lol
11:36:40 <emu> i resubmitted it without change and it accepted
11:38:55 <Japsu> @hoogle a -> a -> [a]
11:38:55 <lambdabot> List.genericReplicate :: Integral a => a -> b -> [b]
11:38:55 <lambdabot> Data.List.genericReplicate :: Integral i => i -> a -> [a]
11:38:55 <lambdabot> Data.Graph.Inductive.Internal.FiniteMap.rangeFM :: Ord a => FiniteMap a b -> a -> a -> [b]
11:39:06 <Japsu> hmm
11:39:16 <Japsu> @djinn a -> a -> [a]
11:39:16 <lambdabot> -- f cannot be realized.
11:39:23 <Japsu> hmm hmm
11:39:46 <Syzygy-> :t (:)
11:39:48 <lambdabot> forall a. a -> [a] -> [a]
11:40:05 <takamura> Why Enum is not a subclass of Ord?
11:40:31 <takamura> there is some datatype for which the distinction is important?
11:40:39 <Japsu> Syzygy-: no, not that
11:40:53 <Japsu> hmm gaah, not a -> a -> [a]
11:40:59 <Japsu> @type foldr
11:41:01 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:43:02 <ihope> Any idea if Haskell will ever have dependent types?
11:43:46 <Saizan> you can probaly oleg-encode them :)
11:44:13 <emu> it would destroy decidable type inference once and for all
11:44:17 <fasta> Is let !_ = 3 in 3 valid GHC Haskell?
11:44:46 <fasta> It works, though.
11:44:57 <Saizan> i've seen !_ before
11:45:18 <olsner> @pl (\x y -> f x)
11:45:19 <lambdabot> const . f
11:46:17 <olsner> @pl (\x -> (x,y))
11:46:17 <lambdabot> flip (,) y
11:46:54 <fasta> unsafePerformIO is so nice. Everything that otherwise would require design can now just work :)
11:47:59 <fasta> Too bad I still don't know the semantics in any formal sense.
11:48:03 <kaol> "just works" never works, at least not in the long term.
11:48:22 <olsner> @remember <fasta> unsafePerformIO is so nice. Everything that otherwise would require design can now just work :)
11:48:22 <lambdabot> Done.
11:48:26 <EvilTerran> unsafePerformIO? semantics? don't make me laugh"
11:48:29 <EvilTerran> s/"/!/
11:48:34 <fasta> kaol: I only use it for debugging my code and it does work.
11:48:49 <olsner> @quote unsafe
11:48:50 <lambdabot> Binkley says: [Monads as clothes] <Binkley> using unsafePerformIO is kind of like going naked in public, might be safe in some contexts, but you really don't want to know what happensif you do it in
11:48:50 <lambdabot> a really bad one
11:48:54 <kaol> does work != just work :-P
11:49:59 <fasta> EvilTerran: have you written a Haskell compiler?
11:50:12 <EvilTerran> fasta, it was a joke
11:50:21 <byorgey> @djinn a -> [a]
11:50:25 <lambdabot> -- f cannot be realized.
11:50:26 <EvilTerran> but to answer your question, no
11:50:41 <whaleofconfusion> has anyone tried making a lambda calculus where the arguments to functions can be arbitrary expressions rather than variables?
11:50:53 <Heffalump> isn't that what call by name is?
11:50:54 <EvilTerran> byorgey, (:[])?
11:51:09 <EvilTerran> @pl \x -> [x]
11:51:10 <lambdabot> return
11:51:13 <EvilTerran> ...
11:51:14 <EvilTerran> or that.
11:51:25 <byorgey> EvilTerran: don't worry, I know how to make a function of that type =)
11:51:27 <therp> whaleofconfusion: do you mean arguments for function application or abstraction?
11:51:37 <byorgey> EvilTerran: I was just playing with Djinn
11:51:39 <whaleofconfusion> abstraction, I believe
11:52:02 <EvilTerran> okay. just making sure. :P
11:52:25 <Saizan> djinn doesn't grok [a]
11:53:42 <EvilTerran> so i see
11:53:42 <whaleofconfusion> for example, you might have ((\ (+ x 2) -> ((\ y -> (+ y 2)) 3))  (foo x))  = (foo 3)
11:54:04 <EvilTerran> could a superset of djinn be able to handle [a]?
11:55:05 <whaleofconfusion> where (+ y 2) is recognized as matching the argument (+ x 2) and then is replaced by (foo y)
11:56:24 <fasta> EvilTerran: djinn is just a theorem prover. There exist theorem provers that can try to prove undecidable problems, but simply won't succeed.
11:58:49 <EvilTerran> whaleofconfusion, that sounds like some kind of self-modifying substitution system O.o
11:59:30 <EvilTerran> or a macro language of sorts
11:59:49 <whaleofconfusion> yes, that's what I'm interested in--how it might be used for macro-like purposes
12:00:18 <EvilTerran> i think the R5RS macro system is related
12:01:07 <whaleofconfusion> I'm not too familiar with that, I'm more familiar with CL macros
12:01:29 <ski> syntax-rules is just pattern-matching (that happens to work on syntax)
12:01:36 <EvilTerran> R5RS macros're based on pattern-matching against bits of syntax
12:03:15 <whaleofconfusion> what I want this to do is act during evaluation--not splitting the computation into macroexpansion followed by interpreting
12:03:24 <whaleofconfusion> but just have it interpreted
12:03:32 <whaleofconfusion> no separate macro expansion phase
12:03:44 <whaleofconfusion> there's at least one problem I see though
12:03:51 <EvilTerran> ...is there anything to be gained from this?
12:04:15 <whaleofconfusion> well, simplicity, but also it means you could dynamically create macros in the middle of an execution
12:04:30 <EvilTerran> it seems to me that you should be able to resolve the syntax in full at compile-time
12:04:48 <whaleofconfusion> you might not always be able to or want to
12:04:56 <EvilTerran> unless you're dynamically loading, in which case you can load a set of macros in one pass and then dynamically load the rest of the script
12:05:11 <EvilTerran> possibly with more macros, then loading more script...
12:05:22 <whaleofconfusion> mainly though is that it might be theoretically simple, a natural extension to the lambda calculus
12:06:19 <EvilTerran> i guess. i look forward to your paper on a formal specification to this effect. ;)
12:07:10 <whaleofconfusion> maybe
12:07:27 <ski> whaleofconfusion : hm, wouldn't '(foo x)' be matched against '(+ x 2)' in your example ?
12:07:56 <whaleofconfusion> I was intending the x to match any expression
12:08:10 <ski> which 'x' ?
12:08:13 <whaleofconfusion> so it would also match (+ (/ z 30) 2)
12:08:31 <swiert> whaleofconfusion: You may be interested in Dale Miller's "Unification under a mixed prefix"
12:08:48 <ski> it appears there's an outer (free) 'x', and an inner (bound) 'x' shadowing the outer one
12:09:28 <ski> swiert : hm .. is that something related to lolli or L-lambda matching ?
12:09:39 <matthew-_> mmm. lhs2tex confuses me. If you put in %include lhs2Tex.fmt then it's fine, but it outputs stuff that can only go in the preamble
12:09:55 <matthew-_> so are you meant to re-cut-and-paste after you get the output?
12:10:06 <whaleofconfusion> ah yes swiert, it would be more clearly put as
12:10:15 <swiert> It could allow you to write pattern match functions of type (a -> (b,c)) as  (\x -> (f x, g x)).
12:10:31 <swiert> ski: I wouldn't know.
12:10:41 <whaleofconfusion> ((\ (+ z 2) -> ((\ y -> (+ y 2)) 3))  (foo x))  = (foo 3)
12:10:51 <pjd> whaleofconfusion: if you're interested in Schemely directions, probably take a look at John Shutt's Kernel language
12:10:56 <Japsu> Is there a Standard Prelude method that does the same as my flatten method: flatten xs = [y | x <- xs, y <- x]
12:10:57 <whaleofconfusion> the x in (foo x) is unrelated to the argument of the outer lambda form
12:11:14 <Saizan> Japsu: concat?
12:11:19 <Saizan> ?type concat
12:11:21 <lambdabot> forall a. [[a]] -> [a]
12:11:40 <Japsu> > concat [[1,2],[3,4]]
12:11:41 <lambdabot>  [1,2,3,4]
12:11:44 <Japsu> k thanks
12:11:45 <ski> (whaleofconfusion : *nod*)
12:11:49 <kosmikus> matthew-_: I don't understand the question.
12:11:49 <lambdabot> kosmikus: You have 1 new message. '/msg lambdabot @messages' to read it.
12:11:54 <ski> @src concat
12:11:54 <lambdabot> concat = foldr (++) []
12:11:57 <Japsu> yeah
12:12:09 <Japsu> that's what I thought next
12:12:35 <whaleofconfusion> actually that doesn't seem so simple anymore because extending that syntax to a single variable argument would replace the entire expression
12:13:40 <whaleofconfusion> i.e. ((\ x -> (+ x 90)) 30) would seem to evaluate to 30 because x would match the whole expression (+ x 90) if it's done the way I was thinking
12:13:47 <whaleofconfusion> which is definitely not what you want
12:13:56 <matthew-_> kosmikus: don't worry, I think I'm confused.
12:14:56 <kosmikus> matthew-_: feel free to ask me about problems with lhs2tex. I can only help if I understand the problem though ;)
12:15:42 <Japsu> hmm
12:15:54 <Japsu> then if I see a lot of "concat $ map" in my code, should I be worried?
12:16:03 <ski> @type concatMap
12:16:05 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
12:16:07 <ski> @type (=<<)
12:16:08 <Japsu> right.
12:16:09 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
12:16:16 <Japsu> concatMap it is then
12:16:30 <Japsu> @src concatMap
12:16:30 <lambdabot> concatMap f = foldr ((++) . f) []
12:16:57 <matthew-_> kosmikus: well in that case... I'm using poly. If I don't put %include lhs2Tex.fmt then it blows up and doesn't work
12:17:04 <ski> > do x <- [False .. True]; show x
12:17:05 <lambdabot>  "FalseTrue"
12:17:07 <EvilTerran> if you'd rather, you can -O and let GHC do it for you, Japsu
12:17:25 <matthew-_> kosmikus: if I do include it then I can't do lhs2tex --ploy blah.lhs > blah.tex
12:17:29 <Japsu> EvilTerran: hmm well, I guess concatMap is just as readable and intuitive as concat $ map
12:17:38 <EvilTerran> yeah, true
12:17:55 <Botje> it's shorter and there's less dollars involved! ,)
12:17:59 <matthew-_> kosmikus: because, if I then \input{blah} in my "main" tex file, the stuff in blah.tex contains code (eg usepackage) that can only go in the preamble of main
12:18:35 <matthew-_> kosmikus: does that make sense? So am I using it the "wrong" way?
12:18:56 <Japsu> Botje: :)
12:20:54 <kosmikus> matthew-_: ok, I see
12:21:18 <kosmikus> matthew-_: are you using lhs2tex-1.12?
12:21:23 <matthew-_> yes
12:21:56 <ski> swiert : ty for the paper reference, i think i need to read this :)
12:22:03 <kosmikus> you should add %include lhs2TeX.fmt to your "main" tex file as well
12:22:19 <kosmikus> matthew-_: ^^, and run it through lhs2TeX as well
12:22:26 <matthew-_> ohhhhhhhh!
12:22:41 <matthew-_> kosmikus: ok, I have *totally* the wrong model of using lhs2tex then
12:23:09 <kosmikus> matthew-_: possible
12:23:15 <kosmikus> matthew-_: I don't know what your model is
12:23:38 <Japsu> hmm
12:23:46 <matthew-_> I'm used to using highlight - you just tell it to format some code (in a separate file) and it spews out latex which you then either paste in or \input
12:23:46 <Japsu> @type concat $ replicate
12:23:48 <lambdabot>     Couldn't match expected type `[[a]]'
12:23:48 <lambdabot>            against inferred type `Int -> a1 -> [a1]'
12:23:54 <Japsu> ...nvm
12:24:08 <ski> @type \n as -> concat $ replicate n as
12:24:10 <lambdabot> forall a. Int -> [a] -> [a]
12:24:11 <kosmikus> matthew-_: oh, right. yes, lhs2TeX is designed to work on a full document.
12:24:37 <Japsu> @pl \n as -> concat $ replicate n as
12:24:38 <lambdabot> (join .) . replicate
12:24:45 <matthew-_> kosmikus: yep. So I write my LaTeX with haskell directly inside it, then lhs2Tex it and pdflatex the result of that?
12:24:47 <Japsu> hmm
12:24:48 <kosmikus> matthew-_: it's possible to use it on includes as well, but you still need some general routines, so you have to adapt the main document too.
12:24:57 <kosmikus> matthew-_: that's the easiest way, yes.
12:25:03 <Japsu> @hoogle Int -> [a] -> [a]
12:25:03 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
12:25:03 <lambdabot> Prelude.take :: Int -> [a] -> [a]
12:25:03 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
12:25:31 <Japsu> bah
12:25:33 <matthew-_> kosmikus: ok, many thanks for your help
12:25:37 <Japsu> any haskellier way to write this? renderOne (Many n x) = concat $ replicate n (show x)
12:25:57 <kosmikus> matthew-_: there's a minimal document on page 3 of Guide2.pdf ...
12:26:32 <matthew-_> ok. I'll take a look.
12:26:33 <kosmikus> matthew-_: note that "%include polycode.fmt" is preferred over "%include lhs2TeX.fmt" ...
12:26:40 <matthew-_> yes, I'd read that one
12:28:31 <ski> renderOne (Many n x) = iterate (shows x) "" !! n  -- Japsu : dunno if this is really better
12:29:01 <Japsu> ski: I don't like the indexing, so I guess I'll go the old way
12:29:02 <Japsu> no, wait
12:29:05 <Japsu> I have another way
12:29:12 <Japsu> which does it by my other functions
12:29:16 <Japsu> renderOne x = concatMap renderOne $ explodeOne x
12:29:23 <ski> @hoogle Int -> (a -> a) -> (a -> a)
12:29:23 <lambdabot> No matches, try a more general search
12:29:26 <ski> :(
12:29:34 <Japsu> explodeOne basically makes (Many n x) n pieces of (One x) :)
12:30:28 <swiert> ski: np. I'd like to understand it all myself :)
12:31:00 <ski> (it seems related to some thought's i've been having lately)
12:31:19 <ski> (s/'//)
12:31:57 <int80_h> is anyone working on ghci being able to listen to a port, such that someone would be able to telnet to the port and access ghci?
12:32:25 <integral> just add ghci to /etc/inetd
12:32:29 <integral> (or setup netcat to run it)
12:33:02 <int80_h> that simple? okay :)
12:33:24 <int80_h> sweet.
12:34:09 * pjd throws in a vote for socat
12:34:54 <integral> netcat seems more ubiquitous sadly
12:36:15 <jethr0> socat rules
12:36:42 <int80_h> I will look at socat
12:36:47 <int80_h> thanks for the tip
12:36:48 <jethr0> although i must admit that many of socat's features are clearly beyond me
12:42:46 <fnord123> what are people using for sqlite connectivity (or are they using sqlite at all?)
12:42:58 <hpaste>  Japsu pasted "Solving the Problem Mentioned in Le Jour des Fourmis by Bernard Werber" at http://hpaste.org/246
12:43:16 <fnord123> I see Takusen, HDBC and HSQL available
12:43:35 <MyCatVerbs> Feck ARSE ARSE.
12:43:59 <MyCatVerbs> Attaching ghci to netcat is moderately suicidal.
12:44:25 <MyCatVerbs> At least, it damn well is so if you don't explicitly do something about handling stderr.
12:44:40 <olsner> 2>&1
12:45:03 <olsner> .. not perfect, but it mostly does something similar to the right thing
12:45:39 <MyCatVerbs> Also there are other ways to make it blow up, like it doesn't seem to be quitting properly on ^D.
12:48:03 <olsner> hmm... sounds like what you need is some kind of single-client one-shot server mode for netcat that closes its input after the first client disconnects
12:49:09 <MyCatVerbs> Ah, hah. That works.
12:49:23 <olsner> or inetd ;-)
12:49:41 <olsner> however that'll spawn new ghci's for each client
12:50:11 <MyCatVerbs> mkfifo ay && nc -l 5000 <ay | ghci >ay 2>&1 &
12:50:26 <MyCatVerbs> Srsly, use f---ing inetd instead. x_x
12:51:03 <olsner> there's a time and place for everything.. even inetd ;-)
12:52:44 <MyCatVerbs> Inetd does it perfectly.
12:53:53 <MyCatVerbs> Handles stderr correctly and everything.
12:53:59 <olsner> wow
12:54:12 <MyCatVerbs> (And, yes, forks off a new ghci for every request.)
12:54:25 <olsner> I guess inetd is made for ... piping command outputs throuch sockets ... or something
12:55:18 <MyCatVerbs> olsner: you'd think so. =D
12:55:35 <olsner> ;-)
12:55:40 <MyCatVerbs> And holy Moses does that ever burn RAM.
12:55:48 <MyCatVerbs> Twenty three megs resident per copy of ghci.
12:56:22 <quicksilver> but almost certainly shared
12:56:47 <MyCatVerbs> quicksilver: oh yeah, I'd forgotten that.
12:57:04 <olsner> then again, how many copies of ghci can you use interactively productively simultaneously really?
12:57:09 <quicksilver> 12
12:57:10 <quicksilver> you?
12:59:48 <matthew-_> kosmikus: thanks for your help. I have it working nicely now.
13:11:47 <fasta> Hmm, one module of my project is already more than 2 times larger than the whole of xmonad :/
13:12:55 <jethr0> hmm, maybe it's time to split that module up. wasn't there some kind of "rule" similar to classes that modules shouldn't be more than a couple of screens full?
13:13:14 <jethr0> well, i've had monster modules as well that turned out to be hard to split up
13:13:54 <fasta> It is split up or otherwise I will have modules containing only one operation, which is not sensible in this case.
13:14:21 <matthew-_> fasta: I probably have type signatures that are as big as the whole of xmonad...
13:14:24 <jethr0> so, what are you working on? seems to be quite a big project...
13:14:54 <kosmikus> matthew-_: you're welcome
13:15:06 <fasta> matthew-_: Hmm, I think I don't get further than 3 pages.
13:15:10 <fasta> matthew-_: so you win :)
13:15:26 <jethr0> and then there's the possibility of implementing an xmonad equivalent in the type system
13:15:54 * cdtw
13:16:51 <jethr0> if only i had a few more pico-olegs of type system wizardry
13:17:45 <DRMacIver> matthew-_: These *are* generated from something though, right? :)
13:18:14 <fasta> DRMacIver: I don't think so.
13:18:45 <DRMacIver> fasta: I mean his type signatures bigger than xmonad.
13:20:53 <fasta> DRMacIver: depends on what you mean by "generated".
13:21:18 <fasta> DRMacIver: No man is going to type 500 lines of type signatures by hand.
13:21:34 <fasta> Well, at least, I won't.
13:22:07 <thoughtpolice> gimmie incentive.
13:23:03 <jethr0> it's gonna be f*cking hard to debug, won't it...
13:33:14 <SimonRC> Are we going to get a Data.Zipper, or Control.Zipper, or Traverse.Zipper, or whatever, at any point, or is that not possible.
13:33:37 * SimonRC wonders how good a "Traverse." set of modules would be.
13:36:20 <fasta> SimonRC: I am not sure whether Data.Zipper would have much use.
13:36:59 <fasta> SimonRC: but implement it, give it a BSD license, and see whether it gets adopted.
13:39:15 <Japsu> now this is depressing
13:39:33 <Japsu> what I did in 98 lines, josh triplett did in 6
13:39:36 <Japsu> http://www.research.att.com/~njas/sequences/A005150
13:39:36 <lambdabot> Title: The On-Line Encyclopedia of Integer Sequences
13:39:45 <SimonRC> Japsu: such is the way
13:40:15 <SimonRC> I find my code tend to shrink to about half the size or better once I fiddle with it a bit.
13:40:23 <vincenz> could prolly be done in less
13:40:32 <sjanssen> SimonRC: Zipper is more like a class of structures rather than a single data type
13:41:29 <dr_strangelove> is there an example implementation of read for some Map?
13:41:44 <sjanssen> so I'm not sure what Data.Zipper could contain :)
13:41:45 <dr_strangelove> read from    typeclass Read
13:41:51 <mauke> @instances-importing Data.Map Read
13:41:53 <lambdabot> (), (a, b), (a, b, c), (a, b, c, d), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Map k e, Maybe a, Ordering, Product a, Sum a, [a]
13:41:59 <mauke> yes
13:42:04 <sjanssen> @fptools Data.Map
13:42:04 <lambdabot> http://darcs.haskell.org/packages/base/Data/Map.hs
13:42:12 <sjanssen> dr_strangelove: the instance should be in there
13:42:30 <dr_strangelove> sjanssen, thanks
13:43:54 <SimonRC> How do you import certain instances?  I know you can import classes, and types, but what about just certain instances?
13:44:05 <fasta> @type (<<=)
13:44:06 <lambdabot> Not in scope: `<<='
13:44:07 <SimonRC> In fact, what *are* the rules for what instances are known where?
13:44:11 <fridim> I got my SoC this morning! \o/
13:44:15 <fasta> @type (=<<)
13:44:16 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
13:44:29 <SimonRC> fasta: "SoC"?
13:44:34 <fridim> s/SoC/SoE/
13:44:44 <fridim> school of expression
13:45:04 <fridim> (the book)
13:45:22 <fridim> (of Paul Hudak)
13:45:23 <SimonRC> ok
13:45:24 <fridim> (...)
13:45:25 <mauke> SimonRC: instances are autoimported. to get nothing but instances, say import Some.Module ()
13:45:25 <fridim> :)
13:45:48 <SimonRC> mauke: how would one *hide* them, to replace them with one's own?
13:45:58 <mauke> hack the compiler?
13:46:06 <SimonRC> bah
13:46:12 <balodja> how to make the simplest use of mutable Map in multiple threads? IORef (Map k a)?
13:46:28 <SimonRC> depends how you want to mutate it
13:46:33 <mauke> more like TVar
13:46:37 <Heffalump> it's part of the language definition that all imported instances are visible everywhere, transitively
13:46:52 <Heffalump> the idea is probably to discourage people from having multiple instances for the same type
13:46:56 <Heffalump> if you want that, use a newtype
13:47:01 <sjanssen> balodja: don't use IORef in a multi-threaded program
13:47:04 <SimonRC> first, you will want an MVar, TVar, or whatever
13:47:20 <SimonRC> as a rule of thumb, the "Var" ones are thread-safe and the "Ref" ones aren't
13:47:46 <kosmikus> Heffalump: strange, I always thought the idea was that otherwise, it depends on the time of instance resolution which instance applies
13:48:07 <Heffalump> ok, one of the ideas :-)
13:48:13 <kosmikus> :)
13:48:15 <balodja> so IORef is vulnerable to deadlocks?
13:48:31 <Heffalump> your reason is probably more believable than mine
13:48:36 <Heffalump> balodja: it doesn't do any locking, so I doubt it
13:48:40 <sjanssen> balodja: it's vulnerable to race conditions
13:49:27 <balodja> ok, thanks
13:50:50 <SimonRC> BTW, I think I now grok why unsafePerformIO is not always type-safe.  I mentionned it a few days ago but America was asleep at the time, so there was little response, and no-one gave me a yes or no.
13:50:57 <fasta> SimonRC: fasta != fridim
13:51:01 <SimonRC> oops
13:51:18 <SimonRC> accursed tab-completion
13:51:43 <Heffalump> SimonRC: it's because you can make a reference polymorphically, then write to it at one type and read from it at another type
13:52:09 <EvilTerran> then what happens?
13:52:12 <SimonRC> anyway, the problem with unsafePerformIO is that is has to turn things like "forall a. IO a" into "IO (forall a. a)", which is dodgy to say the least.
13:52:12 <Heffalump> segfault
13:52:14 <pitecus> @pl (\g f xs ys -> g xs ys f)
13:52:14 <lambdabot> flip . (flip .)
13:52:21 <Heffalump> SimonRC: right.
13:52:22 <SimonRC> EvilTerran: Bad Things
13:52:38 <Heffalump> where bad things = segfault, generally :-)
13:52:58 <EvilTerran> not just a runtime error, but an unhandled one? ouch.
13:54:11 <Baughn> EvilTerran: It normally isn't that hard to avoid, but you should keep unsafePerformIO well under wraps
13:54:12 <SimonRC> Some things can handle the polymorphism.  But not IORefs
13:54:13 <Heffalump> it is called *unsafe* PerformIO :-)
13:54:29 <SimonRC> explicit type signatures might help
13:54:57 <Heffalump> if you don't make polymorphic IORefs you're ok
13:55:10 <Heffalump> you generally would have to do it deliberately to get in trouble
13:55:24 <SimonRC> there are probebly other ways to shoot yourself in the foot with it
13:55:32 <MyCatVerbs> Heffalump: never underestimate end luser foolishness. ;)
13:56:01 <Heffalump> SimonRC: sure. unsafePerformIO (callCfunctionThatDereferencesNULL)
13:56:12 <SimonRC> Functions can handle the polymorphism better than IO actions:
13:56:18 <SimonRC> @type read "foo"
13:56:20 <lambdabot> forall a. (Read a) => a
13:56:54 <Baughn> > read "042" :: Int
13:56:55 <lambdabot>  42
13:57:08 <Baughn> > read "0o42" :: Int
13:57:09 <lambdabot>  34
13:57:28 <Baughn> > read "0b11" :: Int
13:57:29 <lambdabot>  Exception: Prelude.read: no parse
13:58:33 <SimonRC> > print 0o42
13:58:34 <lambdabot>  <IO ()>
13:58:39 <SimonRC> erm, ok
13:58:45 <SimonRC> interesting
13:58:49 <SimonRC> > 0o42
13:58:50 <lambdabot>  34
14:02:52 <Baughn> > show 0o42
14:02:54 <lambdabot>  "34"
14:03:05 <Baughn> So where's the octal printing function? -__
14:03:24 <Baughn> @hoogle a -> String
14:03:24 <lambdabot> Prelude.show :: Show a => a -> String
14:03:25 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
14:03:25 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
14:04:12 <EvilTerran> ?type printf
14:04:14 <lambdabot> forall r. (PrintfType r) => String -> r
14:04:47 <Heffalump> @type Numeric.showOct
14:04:49 <lambdabot> forall a. (Integral a) => a -> String -> String
14:06:04 <SimonRC> ?!
14:06:04 <lambdabot> Maybe you meant: . v
14:06:14 <SimonRC> lambdabot: no, just expressing suprise
14:06:41 <EvilTerran> > showOct 23 "?"
14:06:43 <lambdabot>  "27?"
14:06:58 <dmwit> ?karma one
14:06:58 <lambdabot> one has a karma of 0
14:06:58 <EvilTerran> ahh. k.
14:07:13 <SimonRC> ah, the friggin' auto-append
14:07:13 <dmwit> > let one = "fo"; two = "ur" in one++two
14:07:14 <lambdabot>  "four"
14:07:19 <dmwit> ?karma one
14:07:19 <lambdabot> one has a karma of 0
14:07:20 <EvilTerran> ?karma /me
14:07:21 * lambdabot has a karma of -2
14:07:29 <dmwit> > let one = "fo"; two = "ur" in one++ two
14:07:29 <SimonRC> heh
14:07:30 <lambdabot>  "four"
14:07:32 <dmwit> ?karma one
14:07:32 <lambdabot> one has a karma of 1
14:07:41 <dmwit> I wonder how often that's a problem.
14:07:42 <dmwit> one--
14:08:15 <EvilTerran> ?karma c
14:08:15 <lambdabot> c has a karma of 15
14:08:21 <dmwit> Special case. =)
14:08:22 <dmwit> c++
14:08:24 <dmwit> ?karma c
14:08:24 <lambdabot> c has a karma of 15
14:08:25 <EvilTerran> less than that /\, evidently
14:09:15 <dmwit> EvilTerran: How would you know?
14:09:25 <Syzygy-> ?karma+ c -- testing
14:09:26 <lambdabot> c's karma raised to 16.
14:09:27 <dmwit> Any variable name at all could be stuck in there.
14:09:32 <Syzygy-> ?karma- c -- testing
14:09:32 <lambdabot> c's karma lowered to 15.
14:09:34 <Syzygy-> Hah.
14:09:55 <EvilTerran> i guess. people don't generally have a ++ with no space before but space after, tho, so it shouldn't come up very often
14:10:04 <dmwit> agreed
14:10:28 <dmwit> ?karma C++
14:10:28 <lambdabot> C++ has a karma of -2
14:10:38 <dmwit> ?karma c++
14:10:38 <lambdabot> c++ has a karma of -6
14:11:30 <vincenz> @karma c
14:11:30 <lambdabot> c has a karma of 15
14:11:34 <vincenz> @karma C
14:11:34 <lambdabot> C has a karma of 2
14:11:35 <SimonRC> heh
14:11:51 <dmwit> hmmm
14:12:04 <dmwit> ?karma
14:12:04 <lambdabot> You have a karma of 4
14:12:07 <dmwit> > "has somebody taken care of dmwit++ this?"
14:12:09 <lambdabot>  "has somebody taken care of dmwit++ this?"
14:12:12 <dmwit> ?karma
14:12:12 <lambdabot> You have a karma of 4
14:12:32 <dmwit> darn
14:12:41 <igli> @botsnack
14:12:41 <lambdabot> :)
14:12:49 <igli> there there lambdabot :)
14:21:37 <dancor> how do i get ghc to generate function prototypes for me
14:22:04 <dancor> i remember some blog post (of dons?) about generating them in vim, but i can't find the post or info in ghc docs
14:26:31 <dmwit> dancor: http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
14:26:32 <emu> dancor: haskell-mode supports it.  i think dons had written a separate unix program to insert type annotations as well.
14:26:33 <lambdabot> Title: Haskell mode for Vim
14:26:55 <dmwit> dancor: or,
14:27:11 <dmwit> echo :t funcName | ghci FileName.hs
14:27:18 <dmwit> ;-)
14:27:26 <dancor> thanks!
14:27:35 <emu> sweet, i coerced ghc to output fast code for prime generator
14:33:11 <Vulpyne> I have this little function: captcha :: SQL.Connection -> PktHdr -> Ptr Word8 -> IO ()
14:33:11 <Vulpyne> captcha sqlp pkth datap = do
14:33:11 <Vulpyne>   l <- return $ fromIntegral $ caplen pkth
14:33:11 <Vulpyne>   a <- peekArray l datap
14:33:11 <Vulpyne>   return $ do
14:33:12 <Vulpyne>     return $ putStrLn "In maybe."
14:33:14 <Vulpyne>     sp <- getSimple $ Packet.toInPack ((UA.listArray (0,l-1) a) :: Packet.Chunk)
14:33:15 <Vulpyne>     parsed <- parseSIP $ content sp
14:33:18 <Vulpyne>     return $ do
14:33:19 <Vulpyne>              logPacket sqlp sp parsed
14:33:22 <Vulpyne>              putStrLn $
14:33:23 <Vulpyne>                (show $ source sp) ++ " -> " ++ (show $ dest sp) ++ ": " ++
14:33:25 <Vulpyne>                (B.unpack $ command parsed)
14:33:28 <Vulpyne>   putStrLn "Hi."
14:33:29 <Vulpyne> Oh damn.
14:33:31 <Vulpyne> Sorry!
14:35:36 <Vulpyne> http://hpaste.org/247 - That's what I intended to paste. :/ Anyway, the outer do block is IO, in that is Maybe, an within that is IO. The "In maybe." never gets printed out. I'm not quite sure. Any ideas why? The "hi" part does get printed every time the function is called.
14:42:03 <Vulpyne> Anyone have any ideas regarding my question?
14:48:05 <Lemmih> Vulpyne: Well, it's discarded.
14:48:18 <Lemmih> Vulpyne: Replace 'return $ do' with 'id $ do'.
14:48:36 <Vulpyne> Lemmih: Thanks.
14:49:22 <Lemmih> Vulpyne: Why do you have all those returns?
14:49:57 <Vulpyne> Lemmih: The short answer is that I write horrible Haskell. :)
14:50:35 <Vulpyne> I saw it as a way to make the result of some operations fit into the monad I was using.
14:51:54 <Vulpyne> lemmih: It doesn't compile with "id" substituted for "return".
14:52:28 <TSC> But you can't use IO inside the Maybe monad
14:52:55 <Vulpyne> Hmm, I didn't know that.
14:54:13 <TSC> What type does getSimple return?
14:54:29 <Vulpyne> getSimple :: InPacket -> Maybe SimplePacket
14:54:55 <Vulpyne> parseSIP returns a Maybe SIP.
14:56:10 <TSC> Let me see if I understand the function
14:56:34 <TSC> You get some data from the packet header and the packet itself
14:56:38 <TSC> Then you try to parse it
14:56:39 <Vulpyne> Alright, thanks for taking the time.
14:56:56 <Vulpyne> That's correct.
14:57:02 <TSC> Then if you can parse it, you do some more IO
14:57:07 <TSC> And that's it
14:57:09 <Vulpyne> Yeah.
14:57:16 <TSC> Cool
14:57:42 <Vulpyne> I had a case statement before, and it worked, but I was trying to simplify it.
14:57:46 <Vulpyne> Or perhaps obfuscate it. :)
14:57:47 <TSC> The problem is that you've mixed the IO with the Maybe stuff
14:58:25 <Vulpyne> And GHC doesn't know about the sideeffects, so it just optimizes that stuff out?
14:59:18 <TSC> You're doing (return $ <big maybe value>)
14:59:28 <TSC> And return just discards the big maybe value
14:59:48 <TSC> What are the imports needed to make it compile?
15:00:33 <Vulpyne> Well, that was just the one function pasted. There's quite a bit more in the actual program, and it also depends on hsql/pcap and also the packet parsing stuff from House.
15:01:03 <TSC> Ah
15:01:17 <Vulpyne> (The program's supposed to sniff SIP traffic, decode the packets and log them to a database.)
15:03:28 <TSC> You can still use the Maybe monad like that, but slightly rearranged
15:03:38 <Vulpyne> What would you suggest?
15:03:45 <TSC> I'll show you
15:06:47 <TSC> What's the type of logPacket?
15:07:12 <Igel> hiho once more :)
15:07:20 <Vulpyne> logPacket :: SQL.Connection -> SimplePacket -> SIP -> IO ()logPacket :: SQL.Connection -> SimplePacket -> SIP -> IO ()logPacket :: SQL.Connection -> SimplePacket -> SIP -> IO ()
15:07:23 <Vulpyne> Hmm.
15:07:32 <Vulpyne> My paste sure is screwed up today.
15:07:41 <Igel> how do i find out the local ip address?
15:08:03 <augustss> 127.0.01
15:08:11 <Igel> well yeah
15:08:12 <Botje> Igel: open a udp connection to 4.3.2.1 and get the local socket's ip.
15:08:42 <Igel> Botje: huh? is that a udp-specific trick?
15:08:54 <Botje> yes and no
15:08:57 <Syzygy-> There is a bunch of open servers on 4.4.*
15:09:01 <Botje> opening a udp connection doesn't send any packets
15:09:04 <Botje> because udp is stateless
15:09:12 <Igel> augustss: the thing is, we got a connection less udp-server and have to filter our own broadcasts
15:09:12 <Syzygy-> I know for DNS, the 4.4.4.1-6 are all open...
15:09:15 <Botje> and you can get the endpoint information from an open socket
15:09:16 <augustss> I don't know what you mean by "the local ip address"
15:09:17 <hpaste>  TSC annotated "(no title)" with "(no title)" at http://hpaste.org/247#a1
15:09:29 <Botje> well, what i said works.
15:09:34 <TSC> Vulpyne: have a look at that, I hope it compiles
15:09:36 <Botje> assuming you want the public-facing ip address
15:09:52 <augustss> interfaces have ip addresses, not hosts
15:10:08 <Igel> Botje: yes
15:10:10 <Igel> exactly
15:10:17 <Vulpyne> TSC: Hah, that's just about what it looked like before I started messing with it. :)
15:10:23 <augustss> or rather, hosts can have an arbitrary number of ip addresses
15:10:37 <Igel> as i said, i'm performing udp-broadcasts
15:10:46 <Igel> and i receive my own messagees
15:10:51 <Igel> i have to filter them out
15:10:53 <EvilTerran> shurely there's an ipconfig-esque program on all OSs?
15:10:55 <TSC> Vulpyne: In the logPacket line, "parsed" should be "sip" I think
15:11:08 <TSC> And probably also in the line after that
15:11:32 <Vulpyne> Yeah... Thank you.
15:12:27 <TSC> You're welcome
15:15:30 <Modius> Is there a haskell function that returns a list of sublists?  E.g. it takes [1 2 3 4] and returns [[1 2 3 4] [2 3 4] [3 4] [4] []] - I know this is doable recursively; but was wondering if there was some command which does something close, or a fold
15:15:46 <Botje> Modius: tails
15:15:52 <Botje> > tails [1..4]
15:15:54 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
15:15:58 <Modius> Thanks!
15:17:23 <kaol> @src tails
15:17:23 <lambdabot> tails []         = [[]]
15:17:23 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
15:17:51 <sorear> hello.
15:19:05 <Igel> Botje: the socket fails to bind
15:19:26 <SimonRC> Does it make sense to count the cyclomatic complexity of Haskell code?
15:19:34 <Igel> "bind: unsupported operation (Cannot assign requested address)
15:19:35 <Igel> "
15:19:50 <augustss> SimonRC: does it ever? :)
15:19:54 <chessguy> SimonRC, i don't know, but it sounds like it would hurt
15:20:31 <SimonRC> in normal imperative langs, cyclomatic complexity is used for thinking about program complexity
15:20:56 <augustss> I know people use it
15:21:04 <ddarius> It should work just as "well" in a functional language.
15:21:17 <Botje> Igel: err, why do you need to bind? you need to connect
15:22:00 <Igel> ok, im not so fit with this, sorry
15:23:33 <Igel> Botje: it works!
15:23:37 <Igel> thank you very much :)
15:23:40 <Botje> :)
15:23:42 <Botje> you're welcome
15:26:40 <chessguy> bringert, you around?
15:30:41 <dancor> how do i determine what cabal Build-Depends thing i need for 'Control.Monad.Error'
15:30:53 <dmwit> mtl
15:31:10 <dmwit> ...I think.
15:31:11 <sorear> dancor: it should say in the GHC errror message
15:31:29 <sorear> dancor: something like "... was found in package mtl, but that's hidden"
15:31:50 <dancor> oh duh
15:31:51 <dancor> thanks
15:32:39 <augustss> it's one of those error messages "I know what you want, but I won't do it unless you know the magic word"
15:32:51 <Modius> What's the clean way to A:  truncate a list to an upper size limit, and B: Truncate a list to the length of another (something more specialized than map?)
15:33:22 <dmwit> Modius: A. take B. zip
15:33:24 <augustss> take n l
15:33:35 <Modius> Thanks
15:33:44 <augustss> a little more than just zip
15:33:56 <dmwit> yeah
15:34:03 <Lemmih> chessguy: You rang?
17:49:37 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
17:49:37 --- topic: set by dons on [Sun May 27 19:49:12 2007]
17:50:00 <glguy> and return has to have type: Monad m => a -> m a
17:50:10 <glguy> if you tried to force it to take a list
17:50:18 <glguy> then you'd be constraining a
17:52:19 <glguy> if you defined foldr for your list type, then ++ is free:    (++) = flip (foldr (:))
17:52:48 <igli> what does 'free' mean?
17:52:55 <chessguy> @help free
17:52:56 <lambdabot> free <ident>. Generate theorems for free
17:52:57 <ddarius> @wn free
17:52:59 <lambdabot> *** "free" wn "WordNet (r) 2.0"
17:52:59 <lambdabot> free
17:52:59 <lambdabot>      adj 1: able to act at will; not hampered; not under compulsion or
17:52:59 <lambdabot>             restraint; "free enterprise"; "a free port"; "a free
17:52:59 <lambdabot>             country"; "I have an hour free"; "free will"; "free of
17:53:01 <lambdabot> [44 @more lines]
17:53:09 <shachaf> igli: You don't have to pay for it. :-)
17:53:09 <glguy> igli: effortless?
17:53:15 <chessguy> @free (++) = flip (foldr (:))
17:53:16 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
17:53:20 <igli> lol ok
17:53:36 <bd_> igli: It means you can define it without binding any variable names
17:53:38 <igli> sry thought it was a haskell syntax special use
17:53:43 <igli> ah thanks bd_
17:53:47 <bd_> I think
17:53:47 <bd_> wait
17:53:47 <bd_> no
17:53:53 <igli> ok
17:53:54 <bd_> I'm overtired, ignore me
17:53:57 <igli> np
17:54:02 <chessguy> well, pointfree would mean what bd_
17:54:02 <bd_> <-- was thinking of point-free
17:54:06 <glguy> a free variable is one that isn't bound
17:54:14 <glguy> in the current scope
17:54:17 <igli> ok hmm
17:54:20 <igli> er
17:54:23 <chessguy> in this case, it means that you ddon't have to define (++) in terms of the type
17:54:28 * igli ponders
17:54:35 * glguy goes home
17:54:40 <igli> ah thanks chessguy
17:54:41 <chessguy> you can just define it in terms of something which is defined in terms of the type
17:54:53 <glguy> but before I got
17:54:59 <igli> s/the/a/ ?
17:55:00 <glguy> chessguy: did you ever get a job programming in Haskell?
17:55:04 <glguy> go*
17:55:07 <chessguy> glguy, nope
17:55:11 <glguy> :-(
17:55:22 <chessguy> i did get a better job than where i was though
17:55:27 <chessguy> doing web programming
17:56:37 <igli> meh
17:59:22 <chessguy> 'night all
17:59:46 <_frederik_> how do i lookup a type alias in ghci? for instance there is a declaration 'type X = ...' somewhere, if I see that something has type X then how do I look up what the '...' is?
18:00:20 <shachaf> _frederik_: :i
18:00:30 <_frederik_> oh thank you
18:20:34 <SamB> hmm. my mouse is frozen!
18:20:48 <igli> get a trackball ;)
18:20:53 <igli> or clean it
18:21:00 <SamB> I think it is more of a software problem
18:21:09 <_frederik_> build a warm mouse house
18:59:51 <desp> I have a Cabal problem
19:00:08 <desp> I'm trying to build a library and an executable from a single .cabal
19:00:47 <desp> the library stanza has a C-Sources field, referencing a certain C file that needs to be compiled into the library
19:01:26 <desp> but apparently, it doesn't -- the linker complains about missing symbols from that file when attempting to compile the executable
19:08:23 <_frederik_> desp: i do the same thing, successfully, I think; I don't know what causes your error but I have found it easier to not use cabal
19:08:45 <desp> yes, I was happy with my makefile
19:09:05 <_frederik_> desp: perhaps if you post the error to http://hpaste.org/ then we will be able to understand it
19:09:40 <_frederik_> desp: also, let me know if you want to see the makefile i'm using
19:09:55 <desp> I can handle makefiles, thanks -- a .cabal file would be handy, though
19:10:50 <sjanssen> desp: do you have a header that describes all the symbols?
19:11:31 <sjanssen> you'll want an install-includes stanza too
19:11:35 <desp> http://pastie.textmate.org/69658
19:11:37 <lambdabot> Title: #69658 - Pastie
19:11:39 <desp> this is a .cabal file that works
19:12:07 <desp> but it appears not to compile cbits/curl.c into the library
19:12:14 <desp> which is unfortunate
19:12:28 <ihope> @free (++)
19:12:29 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
19:12:32 <ihope> Hmm.
19:12:48 <ihope> @free id
19:12:52 <lambdabot> f . id = id . f
19:12:57 <ihope> Yay!
19:13:18 <desp> sjanssen: yes, I do have a header describing all the symbols; the problem is of a slightly different nature
19:13:44 <sjanssen> desp: have you looked at a working .cabal?
19:13:47 <desp> sjanssen: I don't think I want an install-includes entry in either stanza, though -- I don't want to install any header files
19:14:08 <desp> yes, I have looked at a working .cabal, and read the Cabal manual
19:14:33 <desp> as I said, this .cabal file is working -- it builds successfully
19:14:54 <desp> it just doesn't appear to link the symbols from the cbits/curl.c file into the library
19:16:50 <desp> http://pastie.textmate.org/69660
19:16:52 <lambdabot> Title: #69660 - Pastie
19:17:01 <desp> here's the cabal clean/configure/build log
19:17:07 <desp> as you can see, no errors
19:17:10 <desp> working
19:22:18 <desp> cabal--
19:24:07 <sorear> re.
19:24:28 <desp> sorear: hi. perhaps you could lend a hand?
19:24:34 <sorear> perhaps
19:25:11 <desp> perhaps I'm missing something, but I assumed that I could get a C file compiled into a Haskell library
19:25:43 <desp> specifically, I need several wrapper functions to deal with FFI's lack of support for varargs
19:27:20 <sorear> that's easy!
19:27:42 <desp> sorear: http://pastie.textmate.org/69658
19:27:44 <lambdabot> Title: #69658 - Pastie
19:27:50 <desp> here's the Cabal file I'm using
19:28:06 <sorear> hmm, when did hpaste go down?
19:28:13 <_frederik_> desp: what error message are you getting?
19:28:31 <desp> sigh.  I really wish people would actually read what I'm writing.
19:28:33 <_frederik_> sorear: it is up for me
19:28:44 <_frederik_> desp: sorry i missed it
19:28:52 <sorear> desp: Should I scroll back?
19:28:56 <desp> _frederik_: I'm getting no error messages.  the Cabal file works.  http://pastie.textmate.org/69660 -- here's the build log.
19:28:57 <lambdabot> Title: #69660 - Pastie
19:29:06 <_frederik_> desp: then how do you know it is not linked?
19:29:29 <sorear> desp: looks like a successful build to me
19:29:30 <desp> the problem is, to compile the executable, cabal requires "C-Sources:          cbits/curl.c" in the executable stanza
19:29:42 <desp> which is the aforementioned C wrapper file
19:29:52 <desp> without this line, the linker complains about missing symbols
19:30:07 <_frederik_> ok...
19:30:09 <sorear> desp: that's not a problem, it's a feature
19:30:52 <desp> sorear: uh. could you explain?
19:31:12 <_frederik_> i think that when a library and executable are in the same cabal file, the executable is not linked with the library package, it is separate
19:31:28 <_frederik_> is that the issue?
19:31:55 <sorear> that's the defined behavior
19:32:16 <sorear> in general, you shouldn't have multi-stanza cabals anyway
19:32:40 <desp> okay. so the library IS actually being build with those C symbols inside?
19:32:44 <desp> built*
19:33:10 <sorear> yes.
19:33:17 <desp> well, thanks for clearing that up.
19:34:05 <desp> I must say that it's rather counter-intuitive to me.
20:35:09 <Korollary> Has any emacs user tried the new haskell mode (yaham) ?
20:36:15 <sorear> no?
21:04:35 <ivanm> Korollary: where can this new haskell mode be found?
21:05:40 <ivanm> @where yaham
21:05:41 <lambdabot> I know nothing about yaham.
21:06:00 <ivanm> well, from googling, it doesn't have a site yet... and not bird support
21:06:09 * ivanm will wait
21:07:31 <edwardk> haskell mode?
21:08:14 <TSC> For emacs
21:08:14 <ivanm> edwardk: its apparently a new haskell mode
21:08:27 <ivanm> http://www.nabble.com/Yaham---Yet-Another-HAskell-Mode-for-GNU-Emacs-tf3897482.html
21:08:30 <lambdabot> Title: Nabble - Yaham - Yet Another HAskell Mode for GNU Emacs, http://tinyurl.com/ytj7us
21:08:56 <ivanm> TSC: well, until yi gets to a useable state, what else is there to use? *ducks*
21:09:37 <Korollary> It doesn't do literate haskell mode, so I am not switching.
21:10:08 * ivanm agrees with Korollary ... plus, looks like it might be hugs only, from where it was posted...
21:11:09 <edwardk> ah
21:11:44 <Korollary> It claims to handle the syntax well
21:12:21 <hpaste>  gcarrier pasted "(no title)" at http://hpaste.org/248
22:02:09 <nornagon> what's the shebang line for haskell? I tried #!/usr/bin/env runhaskell and #!/usr/bin/runhaskell, to no avail
22:02:19 <nornagon> oh, hm.
22:02:51 <nornagon> I get "Could not find module `/home/nornagon/bin/hug'"
22:03:24 <nornagon> does runhaskell need a .hs?
22:04:58 <sorear> yes.
22:05:08 <nornagon> foo. :(
22:05:50 <nornagon> is there a way to make it not need that?
22:07:17 <sorear> nope
22:07:21 <emu> hugs ?
22:07:25 <nornagon> oh well.
22:07:28 <nornagon> emu: n.
22:07:44 <nornagon> a toy one-liner.
22:07:45 <nornagon> $ hug ghc
22:07:45 <nornagon> * ghc hugs you back!
22:07:47 <emu> yea it needs to distinguish .lhs from .hs i guess
22:57:13 <_frederik_> nornagon: it is an open bug, which should be fixed in 6.8
22:57:23 <_frederik_> (and should have been fixed a long time ago in my opinion)
22:58:05 <nornagon> _frederik_: ah, i see.
22:59:45 <_frederik_> the default will be .hs and not .lhs, AIUI
23:00:20 <skew> I suppose it's not completely unambiguous
23:01:26 <skew> main = putStrLn ".hs" {- \n \n \begin{code} \n main = putStrLn ".lhs" \n \end{code} \n \n -}
23:02:10 <_frederik_> mm
23:12:15 <sorear> @users
23:12:15 <lambdabot> Maximum users seen in #haskell: 332, currently: 295 (88.9%), active: 24 (8.1%)
23:34:46 <LeCamarade> @quote JohnMeacham
23:34:46 <lambdabot> JohnMeacham says: I liken learning haskell to tipping over a vending machine. you can't just push it, you gotta rock it back and forth a few times building up momentum until bam! suddenly the flash
23:34:47 <lambdabot> of insight hits and it all makes sense.
23:34:52 <LeCamarade> @quote JohnMeacham
23:34:53 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
23:34:58 <LeCamarade> @quote JohnMeacham
23:34:59 <lambdabot> JohnMeacham says: her name is lambda and she dances on the sand
23:35:27 <LeCamarade> There is another John quote that rips me, but it never shows up outside PRIVMSG. :o(
23:35:39 <LeCamarade> @quote JohnMeacham
23:35:39 <lambdabot> JohnMeacham says: Type theory makes totally awesome material for bar room shit talk.
23:36:09 <LeCamarade> @quote ribbing
23:36:10 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
23:36:10 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
23:36:10 <lambdabot> he was one of the pugs de
23:36:20 <LeCamarade> That. ^^ :o)
23:36:42 * LeCamarade slinks back to whence he came.
23:44:43 <notadev> ah bon, finalement il est alle' ;P
23:47:25 <LeCamarade> notadev: Qui est all?
23:47:48 <notadev> toi fou ;)
23:48:01 <notadev> (jk)
23:48:20 * LeCamarade pleut :((
23:48:42 <notadev> je voulais parler en francais un peu, c'est tout mon frere
23:48:54 * notadev gives LeCamarade a cookie
23:49:42 <LeCamarade> notadev: Merci. Si vous voulez parler en franais, allez  #ocaml.
23:49:51 <sieni> LeCamarade: don't accept it! it's a tracking cookie!
23:49:54 <notadev> ah oui, bien sur
23:49:56 <notadev> lol
23:50:05 <LeCamarade> sieni: LOL!!!
23:50:13 <arcatan> hah
23:51:18 <LeCamarade> notadev: #ocaml est ntre, et personne ne peut pas changer a. Okay, enough French for one day. It's not 1720 anymore. :o(
23:52:03 <LeCamarade> That doesn't mean, of course, that OCaml is not the Napoleon of functional programming languages.
