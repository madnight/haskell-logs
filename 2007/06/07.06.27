00:00:13 <glguy> your program crashes because you called "isempty?" on Nil? add an isempty? method to Nil! (ok, I'm done, back to installing linux)
00:00:40 <alexj> glguy:?
00:00:54 <glguy> alexj: I hate Ruby...
00:00:58 <glguy> but I'm back in control
00:01:04 <glguy> and getting stuff done ;)
00:01:07 <glguy> (now)
00:01:23 <Shimei> Say, how efficient would it be to implement a bit-array using a Haskell list/array with Data.Bits? Is there a better method?
00:01:46 <glguy> a UArray of Bools ?
00:02:20 <alexj> dons: what is the current state of ghc-api or hsplugins?  how much work do you think it would be to get happs so that you don't have to do manual server restarts?
00:03:57 <Shimei> glguy: Thanks, I'll try that out.
00:04:39 <dons> alexj: hmm. a fair bit of work. i'd probably start with ghc-api now.
00:04:55 <alexj> ok then will defer for now.
00:05:15 <dons> alexj, but you could also do the xmonad style: flush the state, refork the new version of the app, read  in the state
00:05:38 <dons> Shimei: UArray Bool is already a bit array
00:05:39 <alexj> oh interesting.
00:05:41 <dons> and its pretty fast.
00:06:00 <alexj> how do you detect when source changes?
00:06:02 <glguy> (that's what I thought he wanted)
00:06:12 <dons> alexj: it doesn't detect, its on demand (mod-q to restart)
00:06:42 <alexj> ah ok.  but we could probably just strobe through the source tree looking for changes.
00:07:08 <crazy_coder> hello everyone
00:07:20 <alexj> dons: forkOS main?
00:08:04 <hpaste>  crazy_coder pasted "(no title)" at http://hpaste.org/419
00:08:16 <dons> restart :: Maybe String -> Bool -> X ()
00:08:16 <dons> restart mprog resume = do
00:08:16 <dons>     prog <- maybe (io getProgName) return mprog
00:08:16 <dons>     args <- if resume then gets (("--resume":) . return . show . windowset) else return []
00:08:19 <dons>     catchIO (executeFile prog True args Nothing)
00:08:21 <dons> is what xmonad does (posix only)
00:09:05 <crazy_coder> I have got some problem parsing
00:09:14 <crazy_coder> a string into lines
00:09:42 <alexj> dons: cool.  does any of that not work on win32?
00:09:45 <crazy_coder> The given string is first divided into words and then into lines
00:09:46 <dons> using 'lines', crazy_coder ?
00:10:02 <crazy_coder> is it a standard keyword ?
00:10:02 <dons> alexj: you'd have to find the win32 version of 'executeFile'
00:10:09 <dons> its a function in Data.List
00:10:12 <crazy_coder> no
00:10:14 <dons> > lines "abc\ndef\nghi"
00:10:16 <lambdabot>  ["abc","def","ghi"]
00:10:17 <crazy_coder> I am not using it
00:11:01 <crazy_coder> what my lines does is splitLines "abc xyz "          ==   ["abc","xyz"]
00:11:31 <Korollary> > words "abc xyz "
00:11:33 <dons> > words "abc xyz "
00:11:34 <lambdabot>  ["abc","xyz"]
00:11:36 <lambdabot>  ["abc","xyz"]
00:11:36 <dons> hehe
00:11:42 <crazy_coder> I don't know why i am getting an error
00:11:42 <dons> so its not 'lines' at all :-)
00:11:55 <crazy_coder> anyways I call it lines
00:11:57 <alexj> dons: thanks!  any advice on watching for changes in a source tree?  with that we are all set on this piece.
00:12:05 <crazy_coder> sorry splitwords
00:12:15 <crazy_coder>  and now I have splitlines
00:12:30 <dons> alexj: the issue would be ensuring, after a change, its all recompiled and type checked
00:12:55 <crazy_coder> which takes this input and returns a list of words which will fit in one line only depending on the length of the line specifies
00:12:59 <crazy_coder> *specified
00:13:03 <dons> so you can certainly watch the src (inotify or something), but i'd wonder if watching would be what is required -- probably a general hook to trigger a restart would be more useful
00:13:08 <dons> like sending sighup?
00:13:34 <crazy_coder> Where can I look at functions in Data.List
00:13:59 <dons> ?docs Data.List
00:14:00 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
00:14:20 <alexj> dons: perhaps.  the pattern of editing code and then reloading the web page is pretty ingrained.  if reloading doesn't work.  then the user can look at console and see compiler error messages.
00:14:50 <alexj> hmm... but then we need a process that survives the recompile.
00:15:13 <alexj> ok.  will think about how this should work.  but the pattern is definiitely useful.
00:15:24 <alexj> thanks.
00:16:04 <oerjan> crazy_coder: the type of splitLines is [Word] -> [Line], not [Word] -> Line
00:16:09 <crazy_coder> There are very limited functions on strings
00:16:17 <crazy_coder> aaah
00:16:20 <crazy_coder> Thanks
00:16:50 <crazy_coder> oerjan: you rock !! :)
00:18:25 <oerjan> :)
00:19:03 <dons> oerjan++ is how you can convey your appreciation :-)
00:19:20 <dons> which oerjan can later trade in his karma points for candy
00:19:34 <crazy_coder> what is karma points
00:19:41 <dons> ?karma lambdabot
00:19:41 <lambdabot> lambdabot has a karma of 49
00:19:46 <dons> the points you get when someone does foo++ :-)
00:19:51 <crazy_coder> ?karma crazy_coder
00:19:51 <lambdabot> You have a karma of 0
00:19:53 <dons> ?karma oerjan
00:19:53 <lambdabot> oerjan has a karma of 2
00:20:00 <crazy_coder> crazy_coder++
00:20:09 <dons> you can't karma yourself (afaik)
00:20:10 <crazy_coder> karma crazy_coder
00:20:15 <crazy_coder> oh
00:20:16 <dons> ?karma crazy_coder
00:20:16 <lambdabot> crazy_coder has a karma of 0
00:20:23 <crazy_coder> Just kidding
00:20:29 <crazy_coder> oerjan++
00:20:31 <dons> and neither can you give karma to java.
00:20:49 <crazy_coder> ?karma oerjan
00:20:49 <lambdabot> oerjan has a karma of 3
00:20:57 <crazy_coder> oh great!
00:21:28 <crazy_coder> > max (karma _ )
00:21:29 <lambdabot>   Pattern syntax in expression context: _
00:21:47 <dons> ?karma-all
00:21:47 <lambdabot>  "audreyt"             634
00:21:47 <lambdabot>  "fglock"              202
00:21:47 <lambdabot>  "dons"                143
00:21:47 <lambdabot>  "gaal"                 99
00:21:47 <lambdabot>  "larry"                97
00:21:49 <lambdabot> [1101 @more lines]
00:21:51 <dons> nice idea though crazy_coder
00:21:58 <dons> @more
00:21:58 <lambdabot>  "agentz"               88
00:21:58 <lambdabot>  "lwall"                70
00:21:58 <lambdabot>  "moritz"               62
00:21:58 <lambdabot>  "putter"               56
00:21:59 <lambdabot>  "glguy"                51
00:22:01 <lambdabot> [1096 @more lines]
00:22:04 <dons> the perl guys run the show
00:22:14 <dons> they have lots of candy
00:22:23 <crazy_coder> :)
00:22:44 <crazy_coder> I liked this concept of Karma
00:22:59 <crazy_coder> pretty useful and moral boosting !! :)
00:23:10 <Igel> how does it work?
00:23:11 <dons> yes, it is how we reward and encourage good behaviour, and strengthen the community, in a fun way
00:23:16 <oerjan> ?karma foo
00:23:16 <lambdabot> foo has a karma of 1
00:23:24 <oerjan> foo--
00:23:36 <crazy_coder> ?karma foo
00:23:37 <lambdabot> foo has a karma of 0
00:23:52 <dons> yes, karma can be taken away (though that's rare). generally as a public admonishment for bad behaviour
00:24:29 <oerjan> perl guys? is this from pugs or is this a cross-language thing?
00:24:32 <dons> see haskell.org/haskellwiki/IRC_channel for more info.
00:24:35 <Igel> ?karma lambdabot
00:24:35 <lambdabot> lambdabot has a karma of 49
00:24:38 <Igel> :D
00:24:43 <dons> oerjan: from #perl6
00:24:51 <dons> lambdabot also runs there
00:24:54 <dons> ?seen lambdabot
00:24:54 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-
00:24:54 <lambdabot> haskell, #darcs and #scannedinavian
00:25:13 <crazy_coder> haskell-soc ?
00:25:17 <crazy_coder> social ?
00:25:20 <dons> the summer of code chanel
00:25:26 <oerjan> does this mean lambdabot actually runs pugs?
00:25:40 <crazy_coder> whats pugs ?
00:25:52 <dons> the perl6 implementation written in haskell
00:25:55 <dons> oerjan: nope.
00:26:00 <kfish> ?where pugs
00:26:00 <lambdabot> http://www.pugscode.org/
00:26:21 <crazy_coder> is perl also functional ?
00:26:42 <dons> not really, no.
00:27:02 <dons> perl6 has some functional features though
00:28:24 <crazy_coder> lamdabot was written in Haskell ?
00:28:52 <dons> yep
00:28:55 <dons> ?version
00:28:56 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
00:28:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:29:14 <dons> ?where lambdabot
00:29:15 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
00:29:15 <crazy_coder> dons: are you a student ?
00:29:20 <dons> a phd student.
00:29:30 <crazy_coder> great
00:29:45 <crazy_coder> You have lots of contribution to Haskell
00:29:52 <dons> that's my job :-)
00:29:59 <crazy_coder> great work . I want to be someone like you :)
00:30:07 <dons> hah. :-)
00:30:09 <crazy_coder> Job ?
00:30:11 <dons> write some libraries!
00:30:29 <crazy_coder> yeah. lets see I am still learning.
00:30:36 <timthelion> hello, can someone explain this strainge(to me) error? http://rafb.net/p/Pl0Tue36.html
00:30:37 <lambdabot> Title: Nopaste - No description
00:32:02 <dons> wow, lisp guy, timthelion :-)
00:32:02 <crazy_coder> dons: which univ are you doing your phd from ?
00:32:02 <dons> i'm at unsw, http://www.cse.unsw.edu.au/~dons :-)
00:32:02 <lambdabot> Title: Don Stewart
00:32:05 <dons> timthelion: what's the type of 'x' ?
00:32:17 <dons> timthelion: also, putStr $ show == print
00:32:29 <dons> and ++"\n" is putStrLn
00:32:34 <timthelion> the type of x is :: a (a->b) b
00:32:53 <dons> hmm?
00:32:53 <int-e> timthelion: did you mix up $ and . ?
00:33:26 <timthelion> dons I'm trying to do this y combinator thing shachaf was telling me about
00:33:28 <int-e> timthelion: in any case the types don't work out - you pass the 100 as the first argument to the second argument of x.
00:33:39 <dons> ?src fix
00:33:39 <lambdabot> fix f = let x = f x in x
00:33:57 <crazy_coder> gtg bye
00:34:39 <timthelion> oops I misstated my intended type
00:34:50 <timthelion> :: a -> (a-> b) -> b
00:34:54 <timthelion> for x
00:35:10 <int-e> that's flip id
00:35:13 <timthelion> dons I'm trying to make it myself (for understanding)
00:35:26 <int-e> i.e. f x y = y x
00:35:38 <timthelion> int-e no no no
00:35:40 <int-e> @djinn a -> (a-> b) -> b
00:35:40 <lambdabot> f a b = b a
00:35:49 <int-e> @type fix
00:35:51 <lambdabot> forall a. (a -> a) -> a
00:35:58 <timthelion> you can't tell what a function is by it's type
00:36:17 <int-e> timthelion: to some extend you can
00:36:32 <timthelion> infact
00:36:40 <timthelion> that's still not the type
00:37:03 <timthelion> a -> ((a->(hmm
00:37:09 <timthelion> it's an infinite type
00:37:16 <timthelion> is that not alloud?
00:37:33 <int-e> timthelion: a -> (a -> b) -> b has as possible values undefined, const undefined and flip id. everything else would break referential transparency.
00:38:11 <timthelion> int-e I want the lambda to be passed to x, and called with itself as the first arg
00:38:18 <int-e> hmm. I guess you get some additional functions with seq.
00:38:31 <yakov> morning
00:38:38 <timthelion> and then the lambda can call itself with itself as the first arg
00:38:40 <int-e> timthelion: yes, you want fix. you can't encode it in the lambda calculus way without some tricks - it won't typecheck
00:38:43 <int-e> @src fix
00:38:44 <lambdabot> fix f = let x = f x in x
00:38:46 <timthelion> thus recursion without name
00:38:52 <int-e> timthelion: but what's wrong with tha definition?
00:39:01 <int-e> *that
00:39:09 <timthelion> int-e what's wrong with my code?
00:39:22 <timthelion> what do you mean it won't type check?
00:39:44 <int-e> timthelion: you implement twice, the church number 2 - twice f :: a -> (a -> a) -> a
00:40:15 <oerjan> timthelion: haskell does not support calling a function with itself as argument directly.
00:40:17 <timthelion> church number?
00:40:42 <oerjan> er, perhaps if it is polymorphic
00:40:44 <timthelion> oerjan: oh, OK, so my thinking was not wrong, just incorrect
00:41:03 <oerjan> but not for Y combinators etc.
00:41:07 <ski> @type \f -> f . f . f . f . f -- the church number 5
00:41:09 <int-e> > fix (\f n-> if (n > 0) then (f ( f (n - 1))) else 0 ) 100
00:41:09 <lambdabot> forall c. (c -> c) -> c -> c
00:41:11 <lambdabot>  0
00:41:54 <timthelion> so what does fix do. hmm.
00:42:03 * timthelion scrolls up and looks at fix
00:42:24 <ski> > fix (1:)
00:42:25 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
00:42:30 <ski> > fix (1+)
00:42:34 <lambdabot>  Exception: <<loop>>
00:42:55 <int-e> ("Can't fix (1+): too broken")
00:43:05 <timthelion> ouch
00:43:21 <timthelion> I sprianed my brain looking at fix
00:43:36 <int-e> it uses recursive let to implement a fixed point.
00:43:48 <sieni> @src fix
00:43:48 <lambdabot> fix f = let x = f x in x
00:44:09 <int-e> and lazy evaluation makes it actually work.
00:44:27 <ski> maybe looks clearer if written as
00:44:30 <ski> fix f = x
00:44:33 <ski>   where
00:44:33 <ski>   x = f x
00:45:12 <int-e> which is just  fix f = f (fix f)  with a name for the result to force sharing.
00:45:48 <int-e> and the Y combinator satisfies the same equation, Y f -->* f (Y f)
00:45:49 <timthelion> isn't that an infinite loop?
00:45:58 <int-e> timthelion: you forget lazy evaluation.
00:46:11 <int-e> you can implement infinite loops with that of course
00:46:17 <timthelion> no I don't, I just dont grock it yet
00:46:17 <int-e> > fix (1+) -- this was an example
00:46:18 <ski> > fix (const 42)
00:46:20 <lambdabot>  Exception: <<loop>>
00:46:20 <lambdabot>  42
00:46:48 <ski> fix (const 42)  =  const 42 (fix (const 42))  =  42
00:46:50 <ski> @src const
00:46:51 <lambdabot> const x _ = x
00:47:26 <crazy_code1> >const 42 (+2)
00:47:28 <timthelion> is there a great book of things that make ones head hurt somewhere?  I think that would be a book I would read
00:47:39 <ski> crazy_code1 : forgot a space
00:47:57 <ski> > const 42 (+2)
00:48:00 <lambdabot>  42
00:48:12 <Syzygy-> :t (const 42 (+2))
00:48:15 <lambdabot> forall t. (Num t) => t
00:48:23 <timthelion> oh
00:48:25 <timthelion> hmm
00:48:34 <crazy_code1> can anyone tell me the significance of   =>   ??
00:48:49 <TSC> It constrains the type variables
00:49:02 <alexj> sorear: just posted new state change concept to the happs list.  are you subscribed?
00:49:07 <timthelion> so if f eventually returns something *without* touching x then it stops looking for x
00:49:12 <TSC> :t head
00:49:15 <lambdabot> forall a. [a] -> a
00:49:23 <sieni> int-e: yeah, it's a bit shorter than in scheme: (define (fix f) ((lambda (x) (f (lambda (y) ((x x) y)))) (lambda (x) (f (lambda (y) ((x x) y))))))
00:49:32 <TSC> crazy_code1: For example, head works on a list of "a", where "a" can be any type
00:49:37 <ski> :t (const (42 :: Complex Int) (+2))
00:49:39 <lambdabot>     No instance for (RealFloat Int)
00:49:39 <lambdabot>       arising from the literal `42' at <interactive>:1:8-9
00:49:40 <TSC> :t (+)
00:49:43 <lambdabot> forall a. (Num a) => a -> a -> a
00:49:43 <ski> :t (const (42 :: Complex Double) (+2))
00:49:46 <lambdabot> Complex Double
00:50:01 <TSC> crazy_code1: But (+) can only work on "a"s where the "a" is a member of the Num class
00:50:16 <crazy_code1> here can we drop (Num a) and just write a->a->a
00:50:20 <TSC> So instead of any old type, it only works on certain types
00:50:22 <TSC> No
00:50:28 <int-e> timthelion: how about http://www.haskell.org/hawiki/TyingTheKnot http://www.haskell.org/haskellwiki/Blow_your_mind :-P
00:50:29 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
00:50:30 <crazy_code1> oh right
00:50:32 <TSC> Because addition only works on members of the Num type
00:50:40 <crazy_code1> so it restricts a to be of Num type ?
00:50:48 <TSC> Of the Num *class*
00:50:53 <TSC> Types belong to classes
00:50:56 <crazy_code1> ok
00:51:00 <TSC> Another example is the Show class
00:51:03 <TSC> :t print
00:51:06 <lambdabot> forall a. (Show a) => a -> IO ()
00:51:11 <crazy_code1> TSC: what if i want a to be of class x and also of class y
00:51:52 <TSC> :t (\x -> read . show $ x)
00:51:55 <lambdabot> forall a a1. (Read a, Show a1) => a1 -> a
00:52:11 <TSC> Then you do something like that
00:52:20 <TSC> (Read a, Show a) => ...
00:52:39 <TSC> :t (\x -> show (x+2))
00:52:42 <lambdabot> forall a. (Num a) => a -> String
00:53:34 <crazy_code1> oh ok. so create tuples ? ok getting the idea
00:53:50 <DRMacIver> Morning
00:54:03 <crazy_code1> DRMacIver: G'Morning
00:54:54 <Syzygy-> yo drm!
00:55:43 <oerjan> @src Num
00:55:43 <lambdabot> class  (Eq a, Show a) => Num a  where
00:55:43 <lambdabot>     (+), (-), (*)           :: a -> a -> a
00:55:43 <lambdabot>     negate, abs, signum     :: a -> a
00:55:43 <lambdabot>     fromInteger             :: Integer -> a
00:55:56 <ski> '(Read a, Show a1)' can be read as the conjunction ('and') of two constraints
00:56:37 <ski> @src negate
00:56:38 <lambdabot> negate x = 0 - x
00:56:58 <ski> @src (-)
00:56:58 <lambdabot> x - y = x + negate y
00:57:00 <crazy_code1> @src words
00:57:01 <lambdabot> words s = case dropWhile isSpace s of
00:57:01 <lambdabot>     "" -> []
00:57:01 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
01:09:29 <seafoodX> Has anyone used the Eclipse Haskell plug-ins?
01:09:32 <seafoodX> What do they provide?
01:11:24 <DRMacIver> A sense of satisfaction arising from the amount of memory needed to edit your source code. :)
01:11:37 <DRMacIver> (Ahem. I don't know really)
01:15:03 <Dunearhp> seafoodX: syntax highlighting, ghc integration: error highlighting and auto build on save
01:16:53 <seafoodX> Dunearhp: Does it do anything fancy? By fancy I mean, can it determine the type of an expression by hovering your mouse over it?
01:17:27 <Dunearhp> unfortunately not
01:17:40 <DRMacIver> Hm. I'm surprised at how many design patterny type things the Haskell wiki lists. :)
01:18:31 <dons> DRMacIver: there's a long tradition of 'how to do some thing X' in haskell papers :-)
01:18:49 <dons> which people then write down as 'if you need to do X, here's how'
01:19:25 <DRMacIver> dons: Yeah, but I mean things which really do resemble the sort of design pattern you get people chanting to in the OO world.
01:19:38 <DRMacIver> They're less cumbersome, but they're still there. :)
01:20:44 <DRMacIver> (I'm specifically thinking of http://www.haskell.org/hawiki/CommonHaskellIdioms )
01:20:45 <lambdabot> Title: CommonHaskellIdioms - The Haskell Wiki
01:21:00 <dons> oh, that's an old hawiki page.
01:21:13 <dons> yeah, just a catalog of techniques
01:21:26 <dons> also, so we can point people to a page to explain what we're talking about in here.
01:21:32 <dons> (i think that's how that page originally emerged)
01:22:15 <dons> i think any language with sufficiently many 'ways to do it' and a community, must build up a library of techniques
01:22:21 <dons> just to help navigate the many ways to do it.
01:22:31 <DRMacIver> Sure. I'm not really hilighting this as a negative thing.
01:22:58 <dons> you've not seen the new idioms page? its scarier.
01:23:06 <DRMacIver> It's just that the OO design patterns often get raised as "You wouldn't need the AbstractHammerFactoryWidgetPattern if you had fnords in your language."
01:23:18 <dons> yeah, most of the fnords == monads too :}
01:23:27 <dons> or laziness, or currying, or ..
01:23:29 <DRMacIver> Or even just first class functions.
01:23:31 <dons> yeah
01:23:57 <DRMacIver> But right, that's my point. A lot of the raving functional program advocates say things along the lines of "You can throw away all your design patterns because you won't need them any more!"
01:24:01 <DRMacIver> And it's not really true. :)
01:24:13 <DRMacIver> You'll just need a different (and better, I think) set.
01:24:22 <dons> there are always going to be general patterns/frameworks
01:24:42 <dons> its just i think that the old OO patterns were often for stupidly simple things
01:24:51 <dons> here's the new idioms page, btw, http://haskell.org/haskellwiki/Category:Idioms
01:24:52 <lambdabot> Title: Category:Idioms - HaskellWiki
01:25:06 <dons> for when you need to remember how to do Typeful symbolic differentiation.
01:25:15 <dons> or Type SK calculus
01:25:19 <DRMacIver> Yeah, I'd already found it. :)
01:25:34 <seafoodX> Probably, the point to make is as follows. Some language features get rid of old design patterns. If design patterns still exist then perhaps this suggest new language features?
01:25:49 <DRMacIver> Sure
01:26:08 <DRMacIver> The ultimate goal of design patterns is to be downgraded to language features or libraries. :)
01:26:16 <dons> you end up with meta features -- and new stuff, like SYB -- to solve old problems.
01:26:21 <DRMacIver> (or upgraded, depending on how you look at it)
01:26:33 <dons> so a 'traversal pattern' becomes a SYB library, given time.
01:26:41 <DRMacIver> But you probably still just end up with a new set of patterns. :)
01:26:44 <dons> and there's not a lot of true boilerplate patterns in haskell
01:27:21 <dons> the type system hackery has some boilerplate -- not a lot of good abstractoin there yet
01:27:29 <dons> the value level seems fairly boilerplate-pattern free
01:27:51 <dons> so if i wanted to do type level numeric bounds, i'd copy a chunk of oleg type level boilerplate.
01:28:05 <dons> (though at least that could mostly go in a library)
01:29:19 <crazy_coder> If we do func :: classx  a => a->a->a   suppose
01:29:43 <crazy_coder> Then all signatures in classx can be used in the function func ?
01:31:54 <quicksilver> crazy_coder: yes
01:32:10 <crazy_coder> Thanks
01:32:12 <crazy_coder> :)
01:32:22 <crazy_coder> quicksilver++
01:34:53 <crazy_coder> having a class Ord and a function ord is very confusing
01:35:34 <crazy_coder> especially from the point of view of what they do
01:35:47 <quicksilver> well 'ord' is very rarely used in my experience
01:35:48 <dons> hmm, that's a good point -- and they're entirely unrelated. be careful to remember that capitatlisation matters in Haskell
01:36:19 <quicksilver> I think I tend to use 'fromEnum' rather than ord
01:36:45 <quicksilver> @check \x -> fromEnum (x::Char) == ord x
01:36:47 <lambdabot>  OK, passed 500 tests.
01:36:50 <oerjan> quicksilver: yeah, it doesn't require an import
01:37:19 <quicksilver> (and to be honest I don't use that very often either. Processing chars as numbers is ugly)
01:38:04 <oerjan> @src Char fromEnum
01:38:05 <crazy_coder> but sometimes one cannot do without it
01:38:05 <lambdabot> Source not found. That's something I cannot allow to happen.
01:38:09 <oerjan> @src ord
01:38:09 <lambdabot> Source not found. Are you on drugs?
01:38:30 <goltrpoat> lambdabot is ornery.
01:38:56 <crazy_coder> I didn't know lambdabot can get abusive at times ;)
01:39:15 <quicksilver> oerjan: fromEnum doesn't have source, it's compiler-derived
01:39:22 <oerjan> and strangely, usually when it's really lambdabot's fault...
01:39:31 <crazy_coder> :)
01:39:39 <quicksilver> oerjan: effectively it's case x of 'a' -> 96 ; 'b' -> 97 ; ....
01:39:46 <oerjan> quicksilver: i just thought one of them might be defined from the other
01:39:58 <quicksilver> hmm yes, ord might use fromEnum
01:40:44 <goltrpoat> ord = fromEnum in the report
01:40:53 <oerjan> it would have been nice if @src could tell when a function is derived
01:42:03 <oerjan> @src Just
01:42:03 <lambdabot> Source not found. You type like i drive.
01:43:58 <oerjan> that could have given the data Maybe source
01:44:03 <oerjan> @src Maybe
01:44:03 <lambdabot> data Maybe a = Nothing | Just a
01:45:38 <goltrpoat> anyone got about 5 minutes and want to give me some feedback on style/exposition/accuracy for this tutorial i'm trying to throw together?
01:46:49 <quicksilver>  @src isn't type aware or anything AFAIK, it is just built by naively scanning the source
01:48:23 <crazy_coder> whats the difference between constructors in Haskell and other programming languages ?
01:49:17 <TSC> goltrpoat: If you show everyone, I'm sure you'll get feedback
01:49:21 <crazy_coder> if the constructor is nullary ( accepts no arguments) then just how are two instances of the data type differentiated ?
01:49:24 <goltrpoat> point.
01:49:44 <oerjan> crazy_coder: type inference
01:50:11 <goltrpoat> http://70.116.12.139/temp.html -- crappy formatting in places, wrote it as a text file at first and then dumped it to html, so certain things are supposed to be tables but aren't.
01:50:17 <TSC> crazy_coder: Do you mean "data X = A | B" (so A and B are nullary constructors)?
01:50:18 <oerjan> although in some cases you do get an ambiguity error
01:50:25 <crazy_coder> TSC: yes
01:50:30 <ttfh> crazy_coder: there is only one instance
01:50:36 <DRMacIver> Why should they be differentiated?
01:50:44 <TSC> The constructor is part of the value, if you like
01:50:55 <crazy_coder> suppose I have data x = y int int
01:50:57 <oerjan> oh, i thought you meant something like data X a = A
01:51:03 <crazy_coder> then when I do y 1 2
01:51:07 <crazy_coder> then y 1 3
01:51:28 <oerjan> crazy_coder: y must be capitalized.
01:51:31 <crazy_coder> then I have 2 instances (1, 2) and (1, 3) right
01:51:38 <crazy_coder> yeah sorry about that
01:51:45 <TSC> You have two values, Y 1 2 and Y 1 3, sure
01:52:26 <oerjan> crazy_coder: to distinguish them you pattern match
01:52:28 <crazy_coder> Then If I have a nullary constructor ?
01:52:53 <TSC> Then your value would simply be "Y" rather than "Y 1 2"
01:53:25 <oerjan> crazy_coder: the "tag" is part of the value, as is each field.
01:53:57 <quicksilver> at least, theoretically it is
01:53:58 <crazy_coder> ok so i have only one instance Y or say if I do data A = Y | X | Z ,     then 3 different possibilites of A
01:54:07 <ttfh> if you have "data X = A | B", and do "let foo = A; bar = A" then foo and bar is the same instance
01:54:14 <oerjan> exactly how it is stored may depend on the compiler
01:54:18 <TSC> Yes, the type A has three values: X, Y and Z
01:54:36 <TSC> Just like "data Bool = False | True"
01:54:59 <crazy_coder> ttfh: foo and bar are the same instance means both point to the same memory location ?
01:55:11 <quicksilver> crazy_coder: they might do but you can never tell
01:55:29 <ttfh> because values can't change theres no point in thinking in terms of instances
01:55:55 <quicksilver> as it happens, in ghc, there is only one empty list in your entire program, even though you use lists of different types
01:56:31 <quicksilver> but there is no guarantee that another haskell compiler behaves the same
01:56:35 <oerjan> crazy_coder: i believe ghc at least as an optimization called "common subexpression elimination" where it identifies expressions that look the same
01:56:45 <crazy_coder> oh ok and in the above example what would I call Y 1 2  or Y 1 3 ?
01:56:49 <oerjan> *has
01:56:54 <quicksilver> crazy_coder: values
01:57:29 <ttfh> "Y 1 2" and "Y 1 2" would be different values
01:57:34 <crazy_coder> values of data type X ?
01:57:47 <ttfh> yes
01:57:52 <crazy_coder> Thanks
01:57:54 <crazy_coder> :)
01:58:13 <quicksilver> ttfh: erm, they're the same value :)
01:59:31 <TSC> goltrpoat: Looks alright to me, but since I'm already familiar with the content I guess I'm not in the intended audience
01:59:54 <goltrpoat> yeah.  that was a conglomerate of the stuff i keep repeating while explaining things to imperative folk
01:59:56 <oerjan> crazy_coder: in the opposite direction, ghc does inlining which may cause function code to be repeated several times
02:00:09 <ttfh> quicksilver: oh, that was supposed to be "Y 1 2" and "Y 1 3"
02:00:18 <oerjan> referential transparency allows you to do both.
02:00:47 <ttfh> crazy_coder: sorry if I confused you with that
02:00:53 <goltrpoat> i sort of wanted to get away from the whole "practical" angle and start with the basics.
02:00:54 <augnob> <-- imperative folk
02:01:01 <crazy_coder> ttfh: not at all
02:01:16 <crazy_coder> Thanks everyone
02:02:44 <crazy_coder> So basically one can use such data types by pattern matching only. right ?
02:02:54 <goltrpoat> no, of course not
02:03:43 <goltrpoat> > map Just [1..5]
02:03:45 <lambdabot>  [Just 1,Just 2,Just 3,Just 4,Just 5]
02:04:00 <ttfh> you could hide the pattern matching in functions
02:04:11 <oerjan> crazy_coder: as basic building block, i suppose yes
02:04:48 <oerjan> oh and of course construction, like goltrpoat notes
02:05:32 <crazy_coder> ok one more thing
02:07:15 <ttfh> In Haskell you can use a constructor as a function, like in goltrpoat's example, that's not possible in O'Caml for example
02:07:27 <TSC> :t Just
02:07:30 <lambdabot> forall a. a -> Maybe a
02:07:32 <crazy_coder> If we do deriving (Eq, Ord, Show etc...)   , then do we have to define == for the data type elements/ constructors ?
02:07:34 <oerjan> ttfh: it isn't?
02:07:55 <TSC> crazy_coder: "deriving" provides the implementation of the instances for you
02:08:09 <TSC> So you don't have to define, say, (==) yourself
02:08:09 <goltrpoat> well no, the point of deriving Eq is to come up with a reasonable "default" equality on the data type
02:08:36 <oerjan> it has been a while since i looked at ocaml, but i don't recall that was different
02:08:38 <ttfh> "List.map Some [1;2;3];;" returns "The constructor Some expects 1 argument(s),
02:08:43 <ttfh> but is here applied to 0 argument(s)"
02:08:46 <crazy_coder> so (==) for the constructors  is automatically done ?
02:08:57 <goltrpoat> :t (==)
02:08:58 <dons> ttfh: I wasn't aware of that, are constructors some how not first class?
02:08:59 <lambdabot> forall a. (Eq a) => a -> a -> Bool
02:09:00 <oerjan> oh
02:09:02 <TSC> crazy_coder: If you say "deriving Eq", yes
02:09:08 <goltrpoat> that's part of Eq
02:09:11 <dons> ttfh, that's a bit ... weird?
02:09:22 <dons> (they must be fully saturated?)
02:09:25 <quicksilver> crazy_coder: it doesn't use == for cases
02:09:41 <quicksilver> dons: ocaml constructores are not first-class, no
02:09:49 <ttfh> dons: yes... I "come" from O'Caml so to speak, and it was nice to discover how it worked in Haskell
02:09:53 <quicksilver> dons: that's one of my number one dislikes of ocaml
02:09:55 <dons> that's really weird.
02:09:59 <dons> why would they do that?
02:10:16 <dons> or is it just an accident, like non-firstclass labels in haskell records? too lazy to fix? :}
02:10:22 <goltrpoat> probably an accident
02:10:30 <goltrpoat> i don't think there's any good technical reason for it
02:10:40 <quicksilver> no, I think it's a design decision
02:10:46 <goltrpoat> slightly more work.
02:11:00 <dons> quicksilver: what would the justification be? /me tries to think of one.
02:11:37 <dons> some magic about how data structures are built, that being fully saturated is an advantage?
02:11:51 <TSC> Couldn't you easily write a function like "some x = Some x" to fake the first class constructor?
02:11:55 <ttfh> O'Caml is very nice, but there are some strange things, the thing that strikes me while learning haskell is how they got everything *right*
02:11:59 <crazy_coder> If the constructor is nullary eg data X = Y | Z   then doing map X [1,2,3] will give error right ?
02:12:13 <TSC> crazy_coder: Yes, because X is not a constructor
02:12:13 <ttfh> TSC: yes, but you have to write it yourself
02:12:14 <dons> ttfh: haskell certainly learnt from problems in the ML and OCaml families
02:12:27 <crazy_coder> sorry map Y [1,2,3]
02:12:35 <dons> well, its a nullary constructor, so that's a type error anyway
02:12:40 <oerjan> crazy_coder: yep, because X alone does not have a -> type
02:12:42 <TSC> crazy_coder: Even with Y, it's an error, because "Y 1" makes no sense
02:12:50 <dons> > map Nothing [1..10] -- for example
02:12:51 <lambdabot>  Couldn't match expected type `a -> b'
02:13:13 <crazy_coder> ok Thanks
02:13:41 <oerjan> @type Nothing
02:13:43 <lambdabot> forall a. Maybe a
02:13:47 <oerjan> @type Just
02:13:48 <lambdabot> forall a. a -> Maybe a
02:13:51 <dons> :k Maybe
02:13:52 <lambdabot> * -> *
02:14:04 <goltrpoat> ttfh:  i played with ocaml briefly, i just kept running into things that worked nicer in haskell
02:14:11 <dons> so can you ask for the type of a constructor in OCaml?
02:14:16 <dons> like we do above for Just?
02:14:18 <goltrpoat> probably had a lot to do with what i was doing
02:14:23 <dons> or do you get some weird info about how it not a true function?
02:14:24 <oerjan> ?run 1+2
02:14:26 <lambdabot>  3
02:14:32 <DRMacIver> goltrpoat: My brief experience with it suggests OCaml just isn't very nice. :)
02:14:40 <oerjan> are ? and @ completely equivalent in lambdabot?
02:15:01 <goltrpoat> i think my first experience with it had to do with trying to port parsec to F#
02:15:07 <DRMacIver> Ouch
02:15:10 <goltrpoat> that was just uh.. not pleasant.
02:15:14 <dons> oerjan: yeah
02:15:21 <DRMacIver> Although I guess there's a JParsec, so it can hardly be worse than that.
02:15:28 <dons> so F# also has this weird constructor issue?
02:15:32 <ttfh> a type constructor isn't a function in O'Caml, so you can't get its type, unless "None", then it's type is "option"
02:15:35 <goltrpoat> drm:  i'd imagine that was even less pleasant :)
02:15:50 <DRMacIver> Yeah. I'm afraid to even look at it.
02:16:00 <dons> ttfh: ok, thanks. is there some way to get info about a constructor?
02:16:12 <dons> (like how we use :info to find about about type classes, which don't have types)
02:16:13 <ttfh> but then you're not really getting the type of the constructor, you create a value of type "option" and then find out that it's type is "option"
02:16:28 <goltrpoat> dons:  F# is basically ocaml with fairly minor differences, minus modules, minus camlp4
02:16:39 * DRMacIver knows exactly how unpleasant porting functional code to Java is. :-/
02:16:58 <oerjan> :info Functor
02:17:09 <DRMacIver> dons: By the way, I stole the concept from stream fusion and abused it horribly. :)
02:17:31 <dons> DRMacIver: sounds interesting....
02:17:33 <oerjan> @info Functor
02:17:33 <lambdabot> Functor
02:17:39 <mrsolo> well then iis F# better than C#?
02:17:54 <dons> i note a stream fusion sketch for ocaml ws put on LtU recently, was rather nice
02:17:55 <ttfh> dons: If you use it wrong it will say: "The constructor X expects y argument(s), but is here applied to z argument(s)"
02:18:02 <dons> not so much fusion, as an implementation of the fusion combinators
02:18:13 <ttfh> so constructors are special creatures
02:18:15 <dons> ttfh: so it looks like a function, but not quite :-)
02:18:20 <DRMacIver> Yes, likewise I'm really stealing the streams rather than the fusion.
02:18:26 <dons> > Just 1 2
02:18:30 <lambdabot>  Couldn't match expected type `t1 -> t'
02:18:32 <DRMacIver> Streams turn out to translate very well into Java - much better than most functional idioms - if you abuse them enough. :)
02:18:39 <crazy_coder> >Just 1
02:18:48 <dons> DRMacIver: oh, very interesting.
02:19:12 <oerjan> crazy_coder: missing space
02:19:27 <crazy_coder> > Just 1
02:19:28 <dons> DRMacIver: i'll point you to the cool ocaml impl of the stream combinators, (SML actually) http://mlton.org/pipermail/mlton-user/2007-April/001091.html
02:19:29 <lambdabot> Title: [MLton-user] Stream Fusion
02:19:30 <lambdabot>  Just 1
02:19:38 <DRMacIver> dons: Thanks
02:19:44 <dons> gets some really really nice code from mlton.
02:19:54 <goltrpoat> mrsolo:  it's a step in a better direction i think, and i think don syme has done some incredible stuff with it, but overall if i'm using c# it's because i need to prototype something very quickly, and at that point it's either something that i'd rather prototype in haskell, or it's something gui-driven, at which point c# works just fine
02:20:38 <DRMacIver> Basically I replace parameter passing with mutable state (sorry! It just works better in Java :) ) and the pattern matching with suitably cut down exceptions. This lets you turn a lot of otherwise recursive code into code that's actually more natural to write in Java and runs in simple loops.
02:20:53 <goltrpoat> if i had to write a gigantic .net IDE, say, i'd probably use f# instead of c#.
02:21:26 <mrsolo> goltrpoat: ah i haven't touched C# for 3 years.. i am told it has folded in many functional programming language features..
02:21:43 <goltrpoat> the generics are actually usable now.
02:22:12 <goltrpoat> it had all these functional features to start with, but utterly crippled polymorphism
02:22:46 <hpaste>  rretzbach pasted "power function - not working" at http://hpaste.org/420
02:23:07 <rretzbach> Can somebody please point out, what went wrong?
02:23:07 <crazy_coder> what is f# and c# ?
02:24:23 <crazy_coder> I think you can do something like power m n | n==0  = 1
02:24:41 <crazy_coder>           |otherwise = m * power m (n-1)
02:24:41 <goltrpoat> rretzbach:  that code is fine
02:24:42 <oerjan> rretzbach: you must use only one let
02:24:46 <goltrpoat> works fine here.
02:24:56 <goltrpoat> oh crap.  except for the lets
02:25:01 <oerjan> it's an indented block
02:25:05 <goltrpoat> -nod-
02:25:18 <mrsolo> c# is microsoft's .net programming language
02:25:21 <rretzbach> So how can I check what went wrong?
02:25:28 <mrsolo> f# is sorta like ocaml running under .net
02:25:29 <apfelmus> rretzbach: ghi thinks that every let introduces a new function  "power"
02:25:32 <goltrpoat> let power 1 n = 1; power n 1 = n; power n m = n * power n (m-1)  in power 2 3
02:25:34 <apfelmus> *ghci thinks
02:25:35 <goltrpoat> bah
02:25:38 <goltrpoat> > let power 1 n = 1; power n 1 = n; power n m = n * power n (m-1)  in power 2 3
02:25:40 <lambdabot>  8
02:25:41 <oerjan> rretzbach: replace all "let" except the first by three spaces
02:25:46 <rretzbach> apfelmus: Aha! Thanks you, that makes it more clear.
02:26:01 <oerjan> oh wait...
02:26:07 <rretzbach> oerjan: So Haskell is indented with a 3 spaces basis?
02:26:14 <rretzbach> I don't mean that I have to.
02:26:19 <dons> 4 or 8 usually.
02:26:23 <rretzbach> But it's like a silent agreement.
02:26:24 <oerjan> you can only do one-liners in ghci
02:26:32 <apfelmus> rretzbach: you probably want to put everything that exceeds one line in a .hs file and load that into the interpreter
02:26:42 <oerjan> rretzbach: no, but all lines in a block must have the same indentation
02:26:49 <LeCamarade> I'm preparing an essay (for internal distribution) called `Referential Transparency Matters'. :o)
02:27:15 <rretzbach> oerjan: Yes, I read that. But for example in Ruby the common basis for indentation is 2 spaces.
02:27:21 <oerjan> so the other "power"'s must line up with the first (if you used a file)
02:27:25 <oerjan> rretzbach: i use 4
02:27:30 <rretzbach> I see.
02:27:46 <crazy_coder> I use as many as I need ;)
02:28:08 <goltrpoat> i use whatever looks pretty
02:28:48 <oerjan> rretzbach: and then sometimes i use 2 if i need something like a "where" squeezed just after another block
02:29:10 <oerjan> but there are a lot of ways to do it
02:30:52 <hpaste>  apfelmus annotated "power function - not working" with "put it into a file" at http://hpaste.org/420#a1
02:31:02 <apfelmus> rretzbach: ^
02:31:20 <oerjan> the thing about using 2 is that that doesn't leave room enough to start the block on the same line as the "let"
02:32:08 <oerjan> but sometimes i get burned by 4 too, like when doing let ... case ... of on one line
02:32:11 <rretzbach> Thanks Mr. apfelmus, but I don't know "module" yet, though I can guess what it does.
02:32:47 <crazy_coder> whats the use of module X where ? (apart from helping us to import/export )
02:33:02 <oerjan> rretzbach: you can leave out the module, it defaults to module Main (main) where
02:33:26 <apfelmus> rretzbach: you can also drop the entire "module ..." line if you want.
02:34:23 <oerjan> er, actually i don't use let much, i think i mean do ... case ...
02:34:37 <rretzbach> Does the Module give me my "own" namespace or something like that?
02:34:53 <oerjan> rretzbach: yep
02:35:06 <apfelmus> rretzbach: PS: apfelmus without Mr. is fine, it's not that this pseudonym deserves a title :)
02:35:26 <oerjan> Sir Apfelmus the Brave
02:35:29 <rretzbach> Indeed, I speak very good german :>
02:35:34 <goltrpoat> i don't know, "mr apfelmus" is pretty swanky.
02:35:48 <apfelmus> rretzbach: hehe :)
02:36:11 <apfelmus> goltrpoat: until you know what "apfelmus" means in translation ;)
02:36:37 <goltrpoat> suessspeise und dings.
02:37:18 <apfelmus> indeed :)
02:37:20 <goltrpoat> :)
02:37:59 <crazy_coder> Can't understand a thing here except for und :)
02:39:21 <ttmrichter> I used to enjoy Apfelmus a lot when I was younger.
02:39:29 <ttmrichter> I can't get it these days, though.
02:39:34 <ttmrichter> And I'm too lazy to make my own.
02:39:51 <rretzbach> I'm buying it from Aldi.
02:39:57 <apfelmus> ttmrichter: with me on IRC, you can now enjoy it that you're older as well ;)
02:40:12 <apfelmus> *enjoy it now
02:40:18 <ttmrichter> Well, enjoy in a different sense.  I hope.  :O
02:40:22 <goltrpoat> haha
02:40:55 <greenrd> I have a parser written using Frisby, which uses a big mdo block to construct the entire parser
02:41:16 <greenrd> However, I would like to parse individual terms, not just whole files
02:41:32 <ttmrichter> Frisby is another Haskell parser generator thing?
02:41:41 <greenrd> The first thing I thought of was returning [topLevel, term] instead of return topLevel
02:41:51 <ttmrichter> I'm just getting into Parsec and enjoying it immensely.  What are the other options?  I know about Happy.
02:41:53 <apfelmus> ttmrichter: yes, I'm not for the sense of taste :)
02:42:12 <greenrd> ttmrichter: it doesn't generate Haskell source; it generates a parser at runtime, you could say
02:42:37 <ttmrichter> URL me please?
02:42:51 <greenrd> http://repetae.net/computer/frisby/index.html
02:43:20 <greenrd> anyway, of course that didn't work, because that gives me Monad m => m [blah]
02:44:14 <apfelmus> greenrd: hm? watcha want to do?
02:44:17 <greenrd> I was trying to use sequence, but that has type Monad m => [m blah] -> m [blah]
02:44:23 <greenrd> which is the opposite of what I want
02:44:47 <greenrd> I want to return two of the parse rules in the mdo block
02:45:03 * ttmrichter sighs.
02:45:10 <ttmrichter> More bloody research....  ::(
02:45:31 <apfelmus> greenrd: mdo .... return (rule1,rule2)?
02:45:42 <greenrd> another possibility would be to try and break up the mdo block into two, since fortunately term and topLevel are not mutually recursive
02:45:56 <apfelmus> has type PM s ((P s a, P s a)) then
02:47:18 <greenrd> apfelmus: ok, so how would I parse something then?
02:47:18 <greenrd> runPeg :: (forall s . PM s (P s a)) -> String -> a
02:47:18 <apfelmus> rule1 = fmap fst allrules
02:47:18 <greenrd> is the basic primitive for running a parser
02:47:18 <apfelmus> runPeg rule1
02:47:25 <apfelmus> allrules being the big mdo-block
02:47:25 <greenrd> ah ok
02:48:05 <greenrd> of course
02:48:09 <greenrd> I should have thought of that
02:49:02 <apfelmus> hm, i ought to bug john meacham about making P s a an instance of Applicative and Monad
02:49:59 <greenrd> there are some changes in darcs recently which may not have made it onto the webpage
02:52:18 <dons> hey Mr. Apfelmus :-)
02:52:38 <apfelmus> dons: humble apfelmus, at your service :)
02:53:02 <dons> :)
02:55:56 <apfelmus> greenrd: ah, it's an instance of Applicative now. i think it can even be made a monad so you can drop the lookahead functions like peek
02:56:24 <greenrd> cool
02:57:06 <greenrd> so what would a frisby parser written in applicative style look like?
02:57:17 <apfelmus> not much different
02:58:05 <apfelmus> just <$> = flip (##)
02:59:02 <apfelmus> and f <*> x = uncurry ($) <$> (f <> x)
03:00:44 <apfelmus> in other words, the strange symbols would be rewritten to other strange symbols that are more common :)
03:01:06 <apfelmus> so that you have to learn strange symbols only once
03:02:59 <moonlite> This is a bit off topic, but what features of the C typesystem makes it loosely typed? Is it even? I'm not trying to imply anything, i just got the question from a friend and couldn't find a good answer more than that void-pointers and typecasts are bad.
03:04:20 <opqdonut> well you can a pointer to void and then to anything
03:04:26 <opqdonut> +cast
03:04:37 <LeCamarade> Hehe. Vanity quote (as in, quoting myself): `Can you imagine the havoc of the grep command did not promise referential transparency?' :o)
03:04:39 <kfish> moonlite, http://cdsmith.twu.net/types.html :-)
03:04:41 <lambdabot> Title: What To Know Before Debating Type Systems
03:04:51 <LeCamarade> s/of/if/gi
03:05:34 <moonlite> so typecasts would be loosely typed? Ie since they don't make any actual conversion?
03:05:42 <moonlite> kfish thx
03:07:08 <opqdonut> LeCamarade: huh?
03:07:17 <kfish> moonlite, i happened to be reading that just now, it's linked off programming.reddit.com
03:07:28 <wolverian> kfish, "static typing prevents infinite loops" .. am I reading this article right? :)
03:08:50 <wolverian> http://www.woodgears.ca/marbleadd/index.html -- nice
03:08:51 <lambdabot> Title: Binary marble adding machine
03:09:24 <LeCamarade> opqdonut: I'm trying to show that we depend a lot on the little referential transparency we are guarateed by pass-by-value systems. More of it would be better. It's some Haskell propaganda I'm churning out here/ :o)
03:09:44 <LeCamarade> s/\//./gi
03:10:04 <opqdonut> LeCamarade: what do  you mean with ref. transp. in grep exactly?
03:10:09 <Spark> just because the black box is referentially  transparent, doesn't mean its components must be
03:10:18 <Spark> opqdonut: only writes to stdout
03:10:40 <opqdonut> eh, isn't that "pure", not "referentially transparent"
03:10:46 <Spark> same thing
03:11:00 <Spark> maybe the former implies the latter, at least
03:11:09 <LeCamarade> opqdonut: That it does not modify any files. At the top of the essay I say that ref-trans is relative, and depends a lot on the system in question. For the shell, it is the file system, since STD* dumping is legitimate `returning'.
03:11:50 <LeCamarade> And I toss a remark around the end that the Haskell IO monad is, in fact, Haskell's version of the Unix shell's pipe. :o)
03:11:54 <Spark> you also have IPC
03:13:20 <wolverian> kfish, I think I was misreading it, since the rest of the article is so lucid. thanks for the link!
03:14:33 <LeCamarade> I ask some wild rhetorical questions: `What if Java passed int's by reference?' :o)
03:31:02 <Spark> LeCamarade: then everyone would make them final and declare their own local ints at the top of the function
03:31:19 <Spark> it would probably make no difference to the language other than mild annoyance
03:33:21 <ttmrichter> You mean "one more mild annoyance" surely?
03:36:25 <crazy_coder> cons has a small 'c' ?
03:36:39 <crazy_coder> >cons 1 2
03:36:50 <crazy_coder> > cons 1 2
03:36:51 <lambdabot>   Not in scope: `cons'
03:36:58 <opqdonut> ?hoogle cons
03:36:58 <lambdabot> Prelude.const :: a -> b -> a
03:36:59 <lambdabot> Data.PackedString.consPS :: Char -> PackedString -> PackedString
03:36:59 <lambdabot> Data.Generics.Basics.constrFields :: Constr -> [String]
03:36:59 <crazy_coder> > Cons 1 2
03:37:00 <lambdabot>   Not in scope: data constructor `Cons'
03:37:06 <opqdonut> what are you talking about?
03:37:12 <dons> ?let Cons = (:)
03:37:12 <crazy_coder>  :
03:37:13 <lambdabot> <local>:5:0: Not in scope: data constructor `Cons'
03:37:23 <dons> ?let cons = (:)
03:37:26 <lambdabot> Defined.
03:37:27 <dons> > cons 1 []
03:37:29 <lambdabot>  [1]
03:37:30 <opqdonut> dons: well : is not exactly like cons
03:37:33 <opqdonut> > cons 1 2
03:37:34 <lambdabot>   add an instance declaration for (Num [t])
03:37:36 <crazy_coder> Ok I understood
03:37:36 <opqdonut> bang
03:38:14 <crazy_coder> If we define (:) as a function cons , then it has small letter c,  but as a constructor it is supposed to be Cons right ?
03:38:22 <opqdonut> yeah
03:38:48 <crazy_coder> I somewhere read a Cons with small caps so got congused
03:39:17 <crazy_coder> *confused
03:39:22 <opqdonut> *consed
03:39:25 <opqdonut> :)
03:48:51 <crazy_coder> :)
03:54:51 <LeCamarade> Spark: In short, they'd fight to the death to get at least that little referential transparency.
03:54:55 <LeCamarade> :o)
03:58:57 <Spark> at least they have choice, though
04:01:12 <chris2> who can recommend me resources on parsing haskell (itself) or on building parsers for very similar languages?
04:02:02 <xpika> i forget what the difference between newtype and data is -.-
04:02:37 <malcolmw> chris2: there is the haskell-src package, and you could also look at the Happy parser used by ghc, or the combinator-based parser in nhc98/yhc.
04:02:42 <mux> @where Parsec
04:02:42 <lambdabot> http://www.cs.ruu.nl/~daan/parsec.html
04:02:58 <chris2> malcolmw: thanks
04:03:02 <mux> Parsec is a monadic combinator-based parser
04:03:31 <chris2> i know parsec, is there a haskell parser written in parsec (yhc's?)
04:03:39 <mux> oh, that I don't know, sorry
04:04:19 <xpika> @where newtype
04:04:19 <lambdabot> I know nothing about newtype.
04:07:51 <chris2> why are the nice syntaxes always that hard to parse. *sigh* :)
04:07:55 <aleator> I'm lazy and want to load constant data into my program. If I do it like 'module Foo where; data = unsafePerformIO $ loadImage "foo.png"; main = ...' Do I get burned by it loading the data several times?
04:11:42 <Cale> aleator: It shouldn't, but there are no guarantees. unsafePerformIO should really be thought of as a hook into the compiler.
04:13:05 <Cale> (So you have to understand GHC to really know what's going to happen)
04:13:45 <Cale> It's really there for things like FFI and implementing low-level libraries.
04:15:10 <aleator> Cale: Ok. Thanks.
04:15:52 <Cale> Personally, if I had a library of images that I needed to load and have my program use, I'd probably load them all up into a Data.Map and then just pass that map around the program.
04:16:17 <Cale> If I needed them to be loaded only on demand, then unsafeInterleaveIO is a better way to go.
04:16:53 <malcolmw> chris2: the difficulty with parsing haskell is actually the lexing stage, not parsing per se.
04:17:03 <chris2> yeah, indentation and stuff
04:17:12 <malcolmw> chris2: the lexer deals with the layout rule, yes
04:17:44 <malcolmw> chris2: once the semicolons and braces have been inserted, it is all fairly straightforward
04:17:59 <Cale> Except for the fixity stuff.
04:18:21 <malcolmw> fixity can be resolved in a subsequent pass
04:18:25 <Cale> yeah
04:18:31 <malcolmw> although I agree that the latter is not trivial
04:18:32 <Igloo> In GHC, the lexer and parser are both involved with handling the layout rule, due to the "parse error -> add }" case
04:19:04 <malcolmw> Igloo: I think we were hoping to remove that rule for haskell-prime, IIRC
04:19:14 <Igloo> Yup, that would be good
04:21:21 <Cale> What does that rule actually fix?
04:21:46 <Igloo> let x = 6 in x
04:22:33 <Igloo> and (case x of y -> y)
04:24:27 <Cale> ah, I see
04:25:01 <Cale> So if that rule is removed, that code is just going to break?
04:25:22 <Igloo> No, other rule changes are happening to make it mostly the same overall
04:25:26 <Cale> ah, okay
04:27:03 <roconnor> @seen ski
04:27:04 <lambdabot> ski is in #oasis, #haskell-blah, #haskell-overflow and #haskell. I last heard ski speak 3h 30m 5s ago.
05:06:45 <matthew-_> @seen DRMacIver
05:06:45 <lambdabot> DRMacIver is in #haskell-blah and #haskell. I last heard DRMacIver speak 28m 13s ago.
05:07:14 <matthew-_> anyone going to the λondon Hug meet tonight?
05:07:46 <edwardk> given that its probably in London, I think I'll have to pass ;)
05:08:00 <edwardk> bit of a round-trip. google maps tells me i have to swim across the atlantic. ;)
05:08:11 <matthew-_> edwardk: it'd be worth it!
05:08:21 <DRMacIver> matthew-_: Hm?
05:08:22 <edwardk> my arms would get awfully tired
05:08:25 <DRMacIver> matthew-_: Yes, I'll be there.
05:08:44 <matthew-_> it sounds like lennart's coming too
05:09:01 <matthew-_> no idea about spj - I presume it's a bit too far to come for just a pub mete
05:10:54 <DRMacIver> It would be a bit annoying if no one turned up after the mass "Yes, we want it every month!" popular vote. :)
05:11:06 <blackdog_> hey, do we have here-docs in haskell yet? or an easy way of doing multi-line string literals?
05:11:17 <matthew-_> DRMacIver: true.
05:11:42 <matthew-_> DRMacIver: well, I can think of at least 5 people who I fully expect to be there
05:12:23 <DRMacIver> Yeah. I'm sure there will be some people there. :)
05:12:59 <edwardk> this is the same thing where that video of SPJ talking about data parallel haskell came from right?
05:14:00 <DRMacIver> Yes
05:14:05 <DRMacIver> 'though it's just a pub meet this month.
05:16:24 <quicksilver> blackdog_: I do unlines ["this is a ", \n "very long strong"]
05:16:28 <quicksilver> blackdog_: personally
05:16:53 <DRMacIver> That seems to be quite common.
05:17:09 <blackdog_> quicksilver: cheers - i ended up appending and prepending "\", which seems to work
05:17:14 <blackdog_> it's still pretty grotty, though
05:17:16 <quicksilver> yes, that works
05:17:19 <quicksilver> but I think \s are fugly
05:17:28 <blackdog_> i find here docs really hard to live without
05:17:30 <quicksilver> I'd rather have it all in quotes and nicely lined up :)
05:17:47 <quicksilver> I must admit I've never much liked here docs at the best of times :)
05:17:52 <blackdog_> i'd rather have a decent quoting syntax :P
05:18:30 <blackdog_> yeah? Why not?
05:18:46 <blackdog_> actually, the pythonesque """blah""" syntax is my favourite
05:19:25 <quicksilver> why don't I like them?
05:19:28 <quicksilver> because they break up the code
05:19:44 <blackdog_> yes, but the unlines approach breaks up the string...
05:19:53 <quicksilver> agreed
05:19:56 <quicksilver> but I prefer that :)
05:20:01 <osfameron> perl is good for quoting...
05:20:01 <blackdog_> i mean, obviously if it's huge, it's a better idea to put it in a data file somewhere
05:20:09 <quicksilver> I don't like to disrupt my indentation
05:20:16 <quicksilver> by suddenly having something left-flush
05:20:58 <blackdog_> yeah, that'd look pretty ugly. i guess i generally just define this sort of thing at the top level
05:24:31 <quicksilver> if it's at the top level it might as well be in another file :)
05:24:35 <quicksilver> I can't help feeling
05:24:49 <blackdog_> well, that's one more thing to distribute
05:24:53 <blackdog_> and screw up :)
05:24:56 <quicksilver> I could see a neat TH hack to read in an external file at compile time
05:25:00 <quicksilver> that might be fun
05:25:08 <blackdog_> yes
05:25:21 <blackdog_> and then we can put some decent syntax on it too :)
05:25:40 <blackdog_> i dunno, it's one of those things about haskell that bugs me a bit
05:26:37 <blackdog_> it's a simple feature with not a lot of a downside (i guess it complicates parsing a bit if you're not careful)
05:26:53 <blackdog_> grar. sorry, bitching. sort of pointless. :)
05:26:58 <DRMacIver> And we all know that Haskell is designed with simple parsing in mind. :)
05:27:03 <SamB_XP> yeah!
05:28:12 <DRMacIver> I hate saying "Feature X is bad because it can be abused", but a problem with long string literals is that they encourage you to do nasty things like embed source code as string literals (I've seen this a lot in Java :( ).
05:28:28 <quicksilver> well haskell does actually have a fairly simple lex/parse setup
05:28:36 <quicksilver> much simpler than, say, perl's I would imagine
05:28:46 <quicksilver> and here-docs would certainly be addiing complexity there
05:29:01 <SamB_XP> quicksilver: ... simpler than perl's, you say?
05:29:18 <SamB_XP> isn't perl one of those languages which cannot be parsed without running it?
05:29:25 <quicksilver> SamB_XP: more or less, yes
05:29:26 <SamB_XP> like FORTH?
05:30:08 <quicksilver> blackdog_: http://osdir.com/ml/lang.haskell.prime/2006-09/msg00019.html
05:30:08 <lambdabot> Title: Here-docs in Haskell source
05:30:11 <SamB_XP> but, worse, it's really really hairy!
05:31:56 <osfameron> DRMacIver: we have arbitrarily long list literals, why not long string literals?
05:32:00 <blackdog_> quicksilver: yeah, that's one of the messages i was looking at - was where i found the / .... / syntax
05:32:41 <DRMacIver> osfameron: Well your string literals can be as long as you want as long as they're on one line. :)
05:32:43 <blackdog_> DRMacIver: in another language, i'd agree with you, but i don't think haskellers need to be protected from themselves to the same extent
05:33:11 <Cale> Haskellers *want* to be protected from themselves.
05:33:29 * osfameron hateses one-line strings...
05:33:42 <osfameron> they lead to horrible things with concatenation
05:33:50 <Cale> I sort of agree with DRMacIver on this one. After all, the original poster says he wants here-docs in order to embed SQL code. Clearly the right way is to write a library for constructing SQL code. :)
05:33:53 * osfameron shudders at " + VbCrLf + "." + ....
05:34:07 <Cale> concat [...]
05:34:11 <blackdog_> Cale: yeah, that application was sort of awful
05:34:27 <blackdog_> but it's still a useful little construct occasionally
05:34:45 <DRMacIver> blackdog_: I disagree. Adding a compile free zone to your source code is very against the spirit of Haskell's static type safety. :)
05:34:46 <quicksilver> I'm not opposed to the feature per se
05:34:54 <quicksilver> but I've always been happy with concat or unlines
05:34:57 <quicksilver> as appropriate
05:35:00 <DRMacIver> I'm not really objecting to the feature either.
05:35:14 <DRMacIver> More that people will inevitably abuse it to do things which I do object to. :)
05:35:17 <Cale> One thing about here-docs which is really ugly is that usually they ignore the indentation level of the surrounding code.
05:35:32 <Cale> Of course, we could do better in Haskell, but that makes things a little interesting ;)
05:35:42 <SamB_XP> I
05:35:51 <quicksilver> yaml allows you to embed here-docs whilst stripping indentation
05:35:56 <quicksilver> but I'm not sure that's the right answer
05:36:11 <quicksilver> Cale: I think one of the "use cases" is ability to edit in place, copy out, paste in
05:36:18 <quicksilver> Cale: so it would have ot be non-indented
05:36:22 <SamB_XP> yeah... also how do you decide what lexeme(s) to sacrifice?
05:36:44 <dons> > "foo \n\          \ bar"
05:36:46 <lambdabot>  "foo \n bar"
05:36:46 <quicksilver> SamB_XP: I normally go for _goat_ or *chicken*
05:37:11 <SamB_XP> *chicken* is three lexemes...
05:37:28 <quicksilver> SamB_XP: I wasn't intending that to be taken seriuosly :P
05:39:37 <edwardk> cale: i always wanted indentation supporting heredocs. it always annoyed me when i wrote heredocs in perl or what have you that the usage instructions popped all the way to the left ;)
05:41:02 <quicksilver> edwardk: but if you're happy with indented heredocs, I should imagine that unlines/concat would work for you, too
05:41:21 <quicksilver> I think the 'literal inclusion' thing is part of it
05:41:32 <edwardk> quicksilver: but then i have to put something on the beginning/end of each line, etc.
05:41:55 <quicksilver> edwardk: true but your editor can make that pretty painless
05:42:19 * quicksilver notes in passing that it's pretty cool to post a newbie question to the -cafe about your SOE exercise and have it answered by the author of the book :)
05:42:25 <edwardk> quicksilver: editor? =) and i like non-syntax for its easiness on the eyes
05:42:59 <quicksilver> edwardk: with syntax highlighting, I find the unlines/concat easy enough on the eyes too. Because the string lits are a different colour, they 'stand clear' anyway
05:44:14 <edwardk> the only problem i have with heredocs is its yet another construct to add to an already overworked parser that uses up yet another syntactic possibility. i realize they are total sugar =)
05:44:47 <dons> and string gaps/ concat/unlines seems to do the job nicely enough in practice
05:45:02 <SamB_XP> dons: eww string gaps!
05:45:11 <edwardk> string gaps?
05:45:12 <osfameron> but it's still more hassle with quotes and commas
05:45:16 <dons> woo string gaps!
05:45:24 <dons> yeah, string gaps are better
05:45:31 <dons> that's the haskell here doc
05:45:33 <quicksilver> I find string gaps much worse
05:45:47 <quicksilver> because my eyes don't "read" them as quoting
05:45:55 <dons> guess that's just practice
05:46:01 <quicksilver> and I can never remember what I'm supposed to do on the edge cases
05:46:09 <quicksilver> e.g. if there is a literal backslash at the end of a line
05:46:10 <dons> "\ \"
05:46:23 <quicksilver> yes, it is practice
05:46:34 <quicksilver> but for saving one character over the concat/unlines method
05:46:41 <quicksilver> (the comma, basically)
05:47:00 <quicksilver> plus some overhead at that beginning/end which doesn't fuss me much
05:47:32 <dons> also, you can use ByteString.pack directly on them, and know you'll get a bytestring constructed at compile time.
05:47:44 <dons> for those who care about big string literals :}
05:48:09 <dons> i wonder: are string gaps supported in unboxed string literals?
05:48:20 <dons> :t "abc"#
05:48:23 <lambdabot> GHC.Prim.Addr#
05:48:25 <dons> :t "ab\    \c"#
05:48:27 <lambdabot> GHC.Prim.Addr#
05:48:29 <dons> hehe
05:48:52 <quicksilver> dons: won't bytestring.pack fuse with an inlined concat?
05:49:08 <osfameron> > "ab\   \c"#
05:49:08 <lambdabot>  Parse error
05:49:22 <edwardk> > "ab\    \c"
05:49:24 <lambdabot>  "abc"
05:49:25 * dons can't remember. the main issue is that unboxed string literals have a rewrite rule
05:49:43 <dons> there's no fusion for pack.
05:49:51 <dons> there is for unpack
05:49:54 * quicksilver nods
05:49:55 <osfameron> what's the point of that?"
05:50:14 <osfameron> > "ab\zzzzzz\c"
05:50:14 <lambdabot>  Illegal escape sequence
05:50:14 <dons> osfameron: of?
05:50:18 <osfameron> string gaps
05:50:30 <dons> you can write multiline string literals with arbitrary indenting
05:50:31 <osfameron> > "ab\\c"
05:50:32 <lambdabot>  "ab\\c"
05:50:36 <xpika_> @where records
05:50:37 <lambdabot> I know nothing about records.
05:50:50 <edwardk> > "ab\   hrmm \c"
05:50:51 <lambdabot>  Illegal character in string gap
05:51:18 <dons> lambdabot is too strict
05:51:29 <dons> main = print "some\n\
05:51:29 <dons>      \string stuff\n\
05:51:29 <dons>                                        \goes here"
05:51:45 <dons> $ runhaskell /tmp/B.hs
05:51:45 <dons> "some\nstring stuff\ngoes here"
05:51:57 <osfameron> oh, it goes multiline too.  OK, it's kind of odd but ok
05:52:04 <osfameron> you have to put the newlines in yourself though?
05:52:19 <dons> generalised, indentable here docs. and yep, you've got to do the newlines
05:52:24 <dons> they're just 'strings with gaps'
05:52:41 <quicksilver> I think you can gap after the newline if you want. "some
05:52:45 <quicksilver> \         \string stuff"
05:52:48 <dons> and, along with defaulting, the most underused feature
05:53:00 <quicksilver> but, I do think they're ugly! And I do agree that is subjective.
05:53:09 <xpika_> @google haskell records
05:53:11 <lambdabot> http://research.microsoft.com/~simonpj/Haskell/records.html
05:54:01 <dons> defaulting, lazy patterns, string gaps. we hardly knew thee!
05:54:38 <osfameron> defaulting?
05:54:41 <dons> today's challenge, use defaulting, string gaps and lazy patterns in your code, today!
05:54:47 <dons> default(Int)
05:54:58 <dons> and you call yourself #haskell! ;)
05:55:50 <DRMacIver> Is #haskell pronounced hash-kell?
05:56:22 <osfameron> > default(Int)
05:56:22 <lambdabot>  Parse error
06:05:54 <quicksilver> osfameron: it's syntax, not an expression :)
06:06:07 <quicksilver> osfameron: remember lambdabot is just expressions...
06:07:16 <osfameron> quicksilver: fair enough - but I don't know what it's syntax for :-)  (google haskell defaulting  doesn't give immediately obvious results)
06:07:36 <fasta> After the split /usr/share/doc/ghc6-doc/html/libraries/doc-index.html is nearly empty. Where can I find the docs for Data.Map?
06:09:30 <edwardk> osfameron: the idea is what happens when you ask ghci or lambdabot for 1 + 1 ? what is the resulting type you expect it to have so it can figure out how to show it and what behavior it should take on?
06:09:57 <edwardk> default gives you sort of a fall back of what to select when you need a concrete type but you got a polymorphic one
06:10:01 <edwardk> @type 1 + 1
06:10:03 <lambdabot> forall t. (Num t) => t
06:10:15 <osfameron> ah
06:10:46 <edwardk> helps keep users of ghci/lambdabot sane
06:10:59 <edwardk> coz having to say > 1 + 1 :: Int all the time would get really old
06:13:48 <dons> :t []
06:13:50 <lambdabot> forall a. [a]
06:13:53 <dons> > [] -- yay for extended defaulting
06:13:55 <lambdabot>  []
06:14:13 <edwardk> yeah
06:14:17 <edwardk> > [] ++ []
06:14:21 <lambdabot>  []
06:14:39 <LoganCapaldo_> > []:[]
06:14:41 <lambdabot>  [[]]
06:14:46 <dons> its like .. there's no types at all!
06:15:10 <fasta> Where do I get documentation for Data.Map in Debian?
06:15:11 <quicksilver> > [[[],[]]]
06:15:13 <lambdabot>  [[[],[]]]
06:15:22 <ToRA> > [] :: String
06:15:23 <lambdabot>  ""
06:15:32 <fasta> It seems the documentation wasn't build correctly by accident.
06:15:47 <edwardk> er, does ghc not install a man page?
06:15:55 <edwardk> (for itself, not Data.Map) =)
06:15:58 <LoganCapaldo_> > [chr 64, chr 65]
06:15:59 <dons> ?docs Data.Map
06:15:59 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
06:16:01 <lambdabot>  "@A"
06:16:21 <mux> iterate ([]:) []
06:16:25 <mux> > iterate ([]:) []
06:16:28 <lambdabot>  [[],[[]],[[],[]],[[],[],[]],[[],[],[],[]],[[],[],[],[],[]],[[],[],[],[],[],[...
06:17:21 <Cale> /usr/share/doc/ghc6-doc/html
06:17:37 <fasta> Cale: if you look ^^, you see that I already have that.
06:18:01 <roconnor> > iterate (:[]) []
06:18:04 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
06:18:04 <lambdabot>       Expected...
06:18:10 <roconnor> oh right.
06:18:21 <fasta> The problem is that the index.html file is not generated correctly.
06:18:32 <Cale> Have you got the ghc6-doc package installed?
06:18:36 <fasta> Cale: yes
06:18:50 <Cale> hmm
06:19:02 <fasta> I do happen to have the documentation, it's just that when you click on the "Index" link in Haddock, that I get almost an empty page.
06:19:17 <fasta> It should show A-Z, but it doesn't.
06:19:23 <Cale> I suppose I'm running Ubuntu, I thought things were the same, but perhaps they fixed it.
06:20:14 <Cale> My copy is basically identical to the online one.
06:27:22 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/414#a1
06:37:06 * SamB wonders what is a good way to "segment" an image of text into characters, especially when some characters have breaks in them in the image (from bad thresholding)
06:39:36 <SamB> tesseract is a fairly good OCR, although it would probably work better if it had a clue as to the size of the characters...
06:41:27 <quicksilver> SamB: I'll say this much: it's a non-trivial problem :)
06:42:11 <SamB> quicksilver: true. though it should be easier for monospace text...
06:45:30 <pastorn_> anyone here experienced GREAT SUCCESS using the listing package when h4xx0ring their TeX files?
06:45:51 <SamB> heh
06:46:00 <pastorn_> I can't seem to get my code to be displayed in monospace
06:46:10 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/414#a3
06:46:18 <SamB> great!
06:46:24 <ndm> malcolmw: you should now update the h' status page saying that pattern guards are more widely implemented
06:46:33 <SamB> glguy will be thrilled with this paste...
06:46:47 <dons> malcolmw: want to add bang pattern support while you're there?
06:46:56 <malcolmw> ndm: good idea
06:47:01 <dons> i'd really like to move away from CPP in Data.ByteString...
06:47:11 <ndm> dons: remember that hacking nyhc is fun in the same way that Ada is fun :)
06:47:11 <malcolmw> dons: I don't like bang patterns
06:47:15 <dons> #define STRICT1(f) f a | a `seq` False = undefined
06:47:15 <dons> #define STRICT2(f) f a b | a `seq` b `seq` False = undefined
06:47:21 <dons> is so much worse than go !x = ..
06:47:24 <SamB> malcolmw: do you like CPP better?
06:47:37 <malcolmw> SamB: I did write cpphs :-)
06:47:47 <SamB> ... your point being?
06:47:58 <dons> its a conspiracy!
06:48:21 <malcolmw> dons: my preferred solution would be bangs in type signature rather than in patterns
06:48:32 <ndm> you mean "its a conspiracy | conspiracy `seq` False = undefined | otherwise =
06:48:33 <dons> old style, cpp :
06:48:34 <dons>         STRICT3(lgo)
06:48:34 <dons>         lgo z p q | p == q    = return z
06:48:34 <dons>                   | otherwise = do c <- peek p
06:48:34 <dons>                                    lgo (f z c) (p `plusPtr` 1) q
06:48:44 <dons> bang patterns:
06:48:45 <dons> foldl' f z0 xs0 = go z0 xs0
06:48:45 <dons>   where
06:48:45 <dons>     go !z []     = z
06:48:45 <dons>     go !z (x:xs) = go (f z x) xs
06:48:52 <SamB> malcolmw: ... why?
06:49:03 <SamB> what if you can't write a type signature, anyway?
06:49:07 <pastorn_> fine, i guess NOONE here ever written a tex file here with haskell code snippets then
06:49:07 <malcolmw> lgo :: !a -> !b -> !c -> d
06:49:34 <malcolmw> nicer still...
06:49:43 <SamB> pastorn_: well, your stipulation that it involve the "listing" package may have decreased the volume of responses
06:50:33 <malcolmw> pastorn_: I use lhs2tex for nice code formatting
06:50:35 <pastorn_> what i want to do is to emphasise certain words in my code in bold, and \texttt doesn't allow that
06:50:55 <SamB> malcolmw: you can't always write a type signature, you know
06:51:00 <roconnor> cdsmith: that's a great article on type systems.
06:51:03 <Syzygy-> Actually... I have.
06:51:15 <malcolmw> SamB: with scoped type variables, it will become possible to write a type sig anywhere
06:51:18 <Syzygy-> pastorn_: I'm preparing a preprint with quite a lot of TeX in it.
06:51:21 <SamB> malcolmw: true.
06:51:28 <Syzygy-> However, I'm using lhs2tex for it.
06:51:31 <SamB> is that in h'?
06:51:41 <dons> bang patterns have a nice counter to ~ patterns
06:51:49 <malcolmw> SamB: I believe so
06:51:49 <dons> maybe we could remove both, in favour of type sigs instead :-)
06:51:53 <SamB> also, I'm not finished yet.
06:51:56 <malcolmw> dons: but ~ patterns are horrible too!
06:52:10 <SamB> ! in patterns can do things that you can't do with them in types
06:52:12 <dons> !-patterns are certainly more *useful* currently
06:52:15 <ndm> bang patterns have a horrible parsing behaviour
06:52:25 <ndm> i think they added loads of conflicts
06:52:32 <SamB> ndm: that's a good argument...
06:52:42 <SamB> but is it any better if you put them in type signatures?
06:52:47 <dons> we need some solution to this. I'm not using CPP for future high-perf libs, so we'll need something
06:52:55 <cdsmith> roconnor: glad you liked it
06:52:56 <ndm> SamB, you can't have (!) in type signatures
06:52:59 <dons> and it'll end up being bang -patterns by default I suspect :(
06:53:17 <malcolmw> SamB: ! is not currently a valid operator at the type level, so no conflict
06:53:24 <SamB> > id :: (!) -> (!)
06:53:24 <lambdabot>  Parse error
06:53:27 <SamB> hmm.
06:53:38 <dons> ndm, right, remember benl tried to fix the parsing  issues  during the hackathon?
06:53:45 <dons> for the funny corner cases with !.
06:53:47 <bringert> a question about english grammar: my feeling is that to the question "who did it?", the correct answer is "he", rather than "him", and that "him" is common, but considered incorrect. Any English-speaking prescriptivists or pragmatists here?
06:54:13 <ndm> dons: and he concluded that having ! overloaded a million times was bad
06:54:22 <ndm> bringert: him is the right answer, i think
06:54:35 <SamB> hmm. I'd say "he did it", or "him"
06:54:45 <malcolmw> bringert: "he" is technically more correct
06:54:46 <ndm> bringert: you could respond with "he did it" or "him" (usually accompanied by a gesture)
06:55:06 <SamB> yes, it doesn't make much sense unless you point, usually
06:55:12 <pastorn_> bringert: bättre än du/dig?
06:55:16 <ndm> malcolmw: could you just answer "he" on its own? that sounds horrible
06:55:34 <malcolmw> ndm: I believe it is the correct form, although no-one uses it
06:55:38 <SamB> malcolmw: where do you learn these things?
06:55:52 <malcolmw> SamB: Latin grammar :-)
06:55:57 <SamB> is this the same people who tell you not to split an infinitive?
06:55:58 <dons> malcolmw: likely bytestring will stay with CPP macros, but new modules (e.g. Fusion.hs) will use bang patterns, since cpp is just too nasty to keep using. What do you suggest?
06:55:58 <SamB> yes?
06:56:06 <SamB> ... just because in latin you can't?
06:56:16 <dons> things like the ndp library use bang patterns too
06:56:28 <SamB> I'll remember to apply the perl grammar to haskell
06:56:31 <roconnor> cdsmith: I'm now quite intrested in what appears to be an open question: Why don't programs in dynamic typing languages (such as Python and Ruby) crash all the time?
06:56:45 <dons> they cast values to funny results, roconnor, instead
06:56:49 <SamB> roconnor: don't they?
06:56:54 <dons> they're strongly typed, they just print funny things
06:57:07 <SamB> I find that mine tend to crash due to spelling errors
06:57:18 <malcolmw> dons: I suppose we could parse bang patterns but throw the information away - so they would compile, but to lazy code
06:57:27 <SamB> malcolmw: hah
06:57:29 <dons> malcolmw: hmm.
06:57:53 <SamB> malcolmw: you could fail tests doing that...
06:57:54 <bringert> ndm, malcolmw, SamB: ok, thanks.
06:58:16 <roconnor> SamB, Oh, maybe they do crash all the time.
06:58:20 <ndm> SamB, we can fail tests in many ways :)
06:58:28 <malcolmw> SamB: could only fail due to resource issues, not semantic differences
06:58:28 <SamB> ndm: true
06:58:37 <SamB> malcolmw: sure.
06:59:01 <dons> yeah, but given the strictness is used for tight assembly loops, usually, which compile rather differently in the bytecode compilers, no one would probably notice :-)
06:59:15 <malcolmw> besides, far too many people think that sprinkling `seq` like confetti is the answer to performance problems, and they are wrong :-)
06:59:18 <dons> you could just slip a couple of `seqs` in ... ;)
06:59:21 <SamB> dons: I'd notice the blown stacks
06:59:39 <SamB> malcolmw: yeah, you have to sprinkle more carefully
06:59:49 <SamB> and mix with other things
07:00:50 <malcolmw> dons: so, a bang in patterns can only appear in front of a var, is that right?
07:01:07 <dons> yeah, or a pattern (anywhere ~ can)
07:01:25 <dons> but i only ever use them for f !x = ... stuff
07:01:26 <malcolmw> dons: but semantically, ! in front of a constructor is meaningless
07:01:47 <ndm> dons: you mean when they perfectly overlap with an indexing operation?
07:01:54 <dons> malcolmw: in a let binding, you can play tricks (I seem to recall doing that recently)
07:02:13 <malcolmw> ~ and ! really are duals, because ! is only useful where ~ is without effect, and vice versa
07:02:14 <SamB> dons: let bindings?
07:02:23 <SamB> that sounds sick...
07:02:46 <malcolmw> dons: oh, a pattern binding, hmm
07:02:57 <Syzygy-> Is ~ basically "Be lazy!"?
07:02:57 <malcolmw> dons:  let !(a,b) = foo ...
07:02:58 <dons> let !(Just n) = read something, iirc
07:03:05 <malcolmw> yes, that is nasty
07:03:08 <dons> to force a parse error before dropping out of the wrapping monad
07:03:21 <SamB> dons: that, again, sounds sick
07:03:28 <dons> sure.
07:03:37 <SamB> dons: perhaps it should be a meta-extension
07:03:46 <SamB> perhaps it should not be
07:03:50 <dons> haskell is a strict and lazy language.
07:04:07 <malcolmw> haskell was never lazy
07:04:14 <malcolmw> only non-strict :-)
07:04:57 <dons> :)
07:05:40 <dons> so yes, we were discussing re. bytestring 1.0, whether to abandon cpp, and hope that would force bang patterns into nhc ;)
07:05:43 <dons> and hugs. ah well
07:06:27 <SamB> dons: ... wait until they *use* it first, duh
07:06:47 <malcolmw> dons: for bytestring 1.0, you could cpp such that ByteString = String to avoid the 500x slowdown of ByteStrings in nhc98 :-)
07:07:12 <dons> i think nhc98 should get an asm jitter, and get a 500x speedup for bytestring ;)
07:07:19 <SamB> malcolmw: ... 500x?
07:07:36 <malcolmw> SamB: yes, Bytestrngs are phenomenally slower
07:07:56 <malcolmw> dons: nhc98 did have a JIT once
07:08:16 <malcolmw> before Java even existed
07:08:33 <dons> it would be nice to have little asm loops for the inner bytestring loops, in nhc.. :) tasty.
07:08:44 <ndm> dons: it would be better to entirely remove the string, ala Supero
07:08:50 <malcolmw> but the JIT only improved the speed by < 4x, so it was abandoned
07:09:38 <malcolmw> JIT compiling hbc worked out a lot better
07:10:08 <ndm> remember than Yhc has an optimising compiler in it, it just happens to be turned off...
07:10:08 <dons> why was that?
07:10:44 <malcolmw> dons: basically, the bytecode in nhc98 was a poor starting point for compiling further
07:11:03 <dons> ah ok.
07:11:04 <malcolmw> actually, come to think of it, it was nhc13, not nhc98
07:11:19 <Philippa> for those of us wondering, what was the big issue with the bytecode?
07:11:42 <dons> Philippa: you mean, why bytecode at all?
07:12:03 <dons> when lennart rolls native code compilers in blog posts now ? :)
07:12:07 <Philippa> dons: no, I mean what was the issue with that particular bytecode that made it poor for further compilation
07:12:24 <malcolmw> Philippa: I'm not sure we ever got to the bottom of it
07:12:41 <ndm> malcolmw: isn't Colin having a student do JIT again shortly?
07:12:41 <Philippa> fair enough. Presumably some flavour of info got hard to trace
07:12:45 <malcolmw> Philippa: but I suspect that yhc's bytecode is rather better
07:15:10 <malcolmw> I wrote a real C backend for nhc98 once, that could interoperate with bytecode.  It only achieved a 40% speedup iirc.  That might have been hampered by always needing to check whether to run bytecode or native code though.
07:15:35 <Philippa> yeah, that's a bugger of a cost if you can't find a way around it
07:15:55 <dons> i wonder if there are lessons in ghci's mixed compiler/interpreted stuff?
07:16:21 <malcolmw> dons: afaik, ghc can call from bytecode to native, but not the other way round
07:16:33 <malcolmw> which makes a lot of sense
07:16:47 <rretzbach> idx (x:xs) i = if i == 0 then x else idx xs (i-1) << is that if a bad style for using recursions?
07:17:08 <Philippa> are there any really big "but if you're strict you don't need to worry about this" lessons to be had these days? By which I mean change-your-whole-arch ones? I get the impression that there shouldn't be, or else that we should be working to a point where that's the case, because there's code (sometimes large chunks of it) that wants to be strict anyway
07:17:11 <dons> malcolmw: yeah.
07:17:33 <Syzygy-> rretzbach: Why not write it pattern matching instead
07:17:49 <Syzygy-> rretzbach: idx (x:xs) 0 = x; idx (x:xs) i = idx xs (i-1)
07:17:59 <rretzbach> I am a very beginner and this is one of the wikibooks exercise.
07:18:11 <Syzygy-> That said, idx xs i = drop i xs. :P
07:18:12 <malcolmw> Clean has strictness annotations in type sigs, and it seems to work well
07:18:17 <Syzygy-> No.
07:18:27 <Syzygy-> idx xs i = xs !! i -- I think
07:19:01 <Philippa> malcolmw: yeah, I do think that's where things should go in the long run - except that strictness annotations can proliferate like crazy if you don't have good shorthands
07:19:29 <Philippa> I mean, there're enough different ways to do it for lists alone, y'know?
07:19:50 <sjanssen> rretzbach: looks good, except you might want to replace the if/then/else with some pattern matching (as Syzygy- has pointed out)
07:20:20 <rretzbach> sjanssen: I might err, but I think I don't know about them yet.
07:20:42 * Philippa ended up doing a certain amount of rambling on the subject in the pub after FitA, anyway
07:20:55 <Syzygy-> FitA?
07:20:57 <sjanssen> rretzbach: you can pattern match against the '0' rather than using ==
07:21:30 <sjanssen> idx (x:xs) 0 = x; idx (x:xs) i = else branch here...
07:21:43 <Philippa> Syzygy-: Fun in the Afternoon. Termly UK academic thing
07:21:43 <rretzbach> sjanssen: pattern matching will be covered in the chapter after the next.
07:21:47 <rretzbach> :))
07:23:27 <shapr> Good morning #haskell !
07:23:29 <LoganCapaldo> wha? No pattern matching in the first chapter?
07:23:30 <shapr> @yow !
07:23:30 <lambdabot> DON'T go!!  I'm not HOWARD COSELL!!  I know POLISH JOKES ... WAIT!!
07:23:30 <lambdabot> Don't go!!  I AM Howard Cosell! ... And I DON'T know Polish jokes!!
07:23:59 <Syzygy-> yo shapr
07:24:18 <LoganCapaldo> @shapr
07:24:19 <lambdabot> why on earth would I slap
07:24:24 <LoganCapaldo> err
07:24:34 <LoganCapaldo> that's not the right command
07:25:32 <quicksilver> @get-shapr
07:25:32 <lambdabot> shapr!!
07:25:45 <Syzygy-> Oooooh.
07:25:48 <Syzygy-> @get-shapr
07:25:48 <lambdabot> shapr!!
07:26:06 <Syzygy-> Wonder how terrible we'd terrorize shapr if everyone fired this off simultaneously.
07:26:19 <Syzygy-> And for that matter whether it is in any way such an amusing thing to do as I seem to find it right now.
07:35:47 <JaffaCake> @users
07:35:47 <lambdabot> Maximum users seen in #haskell: 343, currently: 343 (100.0%), active: 23 (6.7%)
07:35:57 <dons> hey, cool. new high score.
07:36:17 <cdsmith> Do those stats get reset occasionally, or is this really the most ever?
07:36:26 <dons> that is really the most ever
07:36:31 <cdsmith> wow!
07:36:50 <dons> 339 was the previous score
07:37:30 <dons> long term trends here, http://www.cse.unsw.edu.au/~dons/irc/
07:37:30 <LoganCapaldo> yes! I've contributed 1/343th to the new high score!
07:37:30 <lambdabot> Title: Haskell IRC Activity
07:37:35 <quicksilver> it's a shame we don't save rthat value every day for graphing porpoises
07:37:48 <dons> note we've almost reached last years entire nick count ... in june
07:37:56 <quicksilver> although you could grep the whole IRC logs and get rather irregular samples which would still do for a graph
07:37:57 <Syzygy-> quicksilver: Would you really want to graph porpoises??
07:38:19 <LoganCapaldo> I prefer dolphins
07:39:17 <agocorona> hi dons. I have a undefined reference  (_memcmp) loading a object using hs-plugins. do you know what happens? (ghc 6.6)
07:39:19 * ndm discovers that the Catch performance results are all 30% slower than reality
07:39:25 <dons> agocorona: windows?
07:39:31 <agocorona> yes
07:39:55 <rretzbach> Could you please take a look at my 4 lines? http://pastie.caboo.se/74015
07:39:59 <lambdabot> Title: #74015 - Pastie
07:40:41 <cdsmith> rretzbach: that doesn't compile, does it?
07:40:51 <rretzbach> It doesn't.
07:40:52 <sjanssen> rretzbach: the first two lines are invalid
07:40:52 <dons> quicksilver: nick cycles http://irc.netsplit.de/tmp/channels/712_125627.png
07:41:07 <rretzbach> But I don't understand the compiler enough so that its messages would help me.
07:41:10 <sjanssen> rretzbach: those first two parameters are lists, but you're trying to match tuples
07:41:11 <LoganCapaldo> rretzbach: that doesn't type check
07:41:19 <dons> (only the last 2 weeks though -- but lambdabot could easily be patches to checkpoint )
07:41:52 <quicksilver> dons: ah, neat
07:42:01 <quicksilver> dons: shame it'sonly 2 weeks :)
07:42:08 <cdsmith> rretzbach: what do you want your function to do when one list is longer than the other?
07:42:08 <sjanssen> rretzbach: GHC says "`[b]' against inferred type `(a, b1)'", which means you're using a tuple where it expects a list
07:42:15 <rretzbach> But when I use: zp [] [(a, b)] = [(a, b)] it doesn't work either.
07:42:26 <LoganCapaldo> that sdoesn't type check either
07:42:43 <LoganCapaldo> because the second list isn't a list of tuples (necessarily)
07:42:48 <sjanssen> rretzbach: that's because you're matching against a list full of tuples -- but the list isn't full of tuples
07:43:22 <rretzbach> Ahh right. The list of tuples is the return type!
07:44:06 <sjanssen> rretzbach: there's only one thing you can possibly do when you run into the end of the list.  What is it?
07:44:45 <quicksilver> sjanssen: give up, and buy some ice cream
07:44:52 <LoganCapaldo> Mmmm ice cream
07:44:55 <MyCatVerbs> sjanssen: stick your fingers in your ears and sing long complicated songs about wheelbarrows.
07:44:58 <rretzbach> Yes. I just toss the last item.
07:45:20 <quicksilver> rretzbach: but what if there is more than one?
07:45:21 <LoganCapaldo> sjanssen: error "End of list, oh noes!!!" ?
07:45:34 <quicksilver> rretzbach: what do you want the answer to zip [1,2] [4,5,6,7,8,9] to be?
07:45:49 <MyCatVerbs> > zip [1,2] [4..9]
07:45:50 <lambdabot>  [(1,4),(2,5)]
07:45:53 <rretzbach> [(1,4), (2,5)]
07:46:08 <quicksilver> MyCatVerbs: yes I know what the standard lib does :) I want to know what rretzbach wants :)
07:46:13 <MyCatVerbs> On the evidence, I'd say that [(1,4), (2,5)] is the most sensible answer.
07:46:16 <quicksilver> rretzbach: right. so it's not "toss the last item"
07:46:24 <quicksilver> rretzbach: it's "toss the remaining itemS"
07:46:33 <MyCatVerbs> quicksilver: the evidence in question being that the standard lib was written by people who are in all likelihood much cleverer than I am. :)
07:46:33 <rretzbach> That's what I wanted to say.
07:46:34 <quicksilver> rretzbach: cos there might be four or more...
07:46:40 <quicksilver> good :)
07:47:07 <LoganCapaldo> Knowing this, what then should the first two clauses of zp look like?
07:47:33 <rretzbach> Why do you use x:xs instead of a:at for example?
07:47:48 <agocorona> Dons: is this a known bug under windows or something like that?
07:47:57 <mauke> because -t is not a plural suffix
07:48:08 <LoganCapaldo> rretzbach: the idea is that it looks like "x, followed by many xs"
07:48:13 <rretzbach> I see.
07:48:17 <MyCatVerbs> rretzbach: the justification I've heard for it is, because x:xs reads as "ecks on the head of eckses"
07:48:24 <rretzbach> I thought of "a tail" :)
07:48:31 <quicksilver> "ecks cons eckses"
07:48:35 <rretzbach> :D
07:48:35 <quicksilver> or just "ecks eckses"
07:48:52 <rretzbach> Then it makes sense.
07:48:53 <mauke> hd : tl
07:49:03 <MyCatVerbs> Or if you want to whore yourself out to the lispies, (car:cdr)
07:49:19 <rretzbach> :D
07:49:20 <LoganCapaldo> where have I seen hd:tl? Is that the ML convention? it looks familar
07:49:22 <MyCatVerbs> Even though that's totally wrong, it still sounds kinda nice.
07:49:31 <oerjan> x : r
07:49:36 <mauke> LoganCapaldo: OCaml?
07:49:42 <LoganCapaldo> could be
07:50:15 <oerjan> just pick a convention or three
07:50:34 <DRMacIver> LoganCapaldo: Pretty sure the ML convention is x:xs
07:50:44 <DRMacIver> LoganCapaldo: It's certainly the convention I learned when learning ML. :)
07:51:13 <mauke> well, OCaml has List.hd and List.tl
07:51:35 <mauke> hd : 'a list -> 'a
07:51:59 <LoganCapaldo> I dunno seeing hd:tl just gave me deja vu
07:52:23 <LoganCapaldo> I kinda gave up on learning ML / OCaml after I got into Haskell
07:52:41 <rretzbach> It really is fun learing Haskell (so far). Thanks for your support!
07:52:55 <Cale> http://programming.reddit.com/info/21nue/comments/c21o40
07:52:56 <lambdabot> Title: How do you write the factorial function totally wrong? (daily WTF) (reddit.com)
07:52:57 <Cale> hehe
07:54:44 <fasta> There is one thing I "miss" in Haskell: being able to put code in a data structure that's visualised with GTK2HS and where I can make adjustments in that application while it runs and then change something there. Is doing that _today_ possible e.g. with hs-plugins?
07:54:56 <LoganCapaldo> Cale: I think that combination of knowledge and ignoranc ewould cause the universe to implode
07:55:47 <Cale> LoganCapaldo: hahaha
07:56:34 <MyCatVerbs> rretzbach: hee, FP languages do generally tend to have freakishly good communities. I think it's the academia thing.
07:56:37 <quicksilver> fasta: that's sort of what FRP is about, isn't it? "tangible values" and so on?
07:56:53 <rretzbach> MyCatVerbs: Yes I assume that too.
07:57:01 <quicksilver> MyCatVerbs: and yet, academia itself is wrought with cliquishness and politics. Contradictory, isn't it?
07:57:06 <rretzbach> It also guarantees not too short answers ;)
07:57:14 <Cale> fasta: er, do you mean something like visualising the running program and modifying it in real-time somehow?
07:57:17 <quicksilver> and, quite often, multiple simlutaneous answers
07:57:24 <fasta> quicksilver: But AFAIK, I cannot put real Haskell code in those fields.
07:57:37 <hpaste>  (anonymous) annotated "(no title)" with "mind do's, names and parenthesizing" at http://hpaste.org/414#a4
07:58:00 <rretzbach> quicksilver: Yes, but I don't think that's bad. I appreciate every time someone spends for helping me.
07:58:31 <MyCatVerbs> quicksilver: well, it is confusing the crap out of me _now_, since I hadn't thought of that before.
07:58:50 <fasta> Cale: I mean that I have a structure T, for example a tree and an associated function f, and some field that contains the code for function f and a box containing the result of applying f to T and changing f results in an immediate update to the box.
07:59:08 <fasta> Cale: that's a fairly simple application, but it should be able to hold arbitrary code.
07:59:21 <Cale> Haskell code, then
07:59:31 <fasta> Cale: those kinds of things are the things people are doing with Smalltalk, or at least they can.
07:59:40 <Cale> You'll need hs-plugins certainly, if you want to evaluate Haskell code.
07:59:59 <fasta> Cale: I am far from a Smalltalk expert, but those things are pretty sweet.
08:00:02 <LoganCapaldo> seems like lambdabot is evidence that it's at least possible
08:00:09 <Cale> They're also pretty dangerous :)
08:00:29 <fasta> It's also a question of how efficient it is.
08:01:19 <LoganCapaldo> fasta: Just implement Haskell on top of Smalltalk ;)
08:01:19 <Cale> Smalltalk is fun, but I found myself wondering how the whole thing didn't manage to shake itself to pieces, what with all that mutability :)
08:01:44 <fasta> LoganCapaldo: I actually already thought of that possibility :)
08:02:03 <LoganCapaldo> ooo
08:02:04 <oerjan> fasta: that sounds like the Vital/Pivotal projects
08:02:09 <Cale> The whole system is one big piece of state.
08:02:15 <fasta> oerjan: yes
08:02:23 <LoganCapaldo> I like smalltalk, I like haskell. Maybe I should make my next project Smalltalk in HS
08:02:37 <LoganCapaldo> err HS isn't really a good abbrev. for Haskell. What was I thinking?
08:02:55 <fasta> I think the wiser thing is to get the smart ideas from Smalltalk to Haskell.
08:03:16 <fasta> The pile of state that is SmallTalk seems a bad idea, indeed.
08:03:48 * LoganCapaldo wonders if he can steal the MACID stuff from HAppS for the images
08:03:56 <quicksilver> fasta: ah sorry, I did misunderstand you
08:04:00 <fasta> oerjan: the problem is that those projects never escape academia
08:04:04 <quicksilver> fasta: yes, I agree that kind of stuff is quite cool
08:04:28 <fasta> quicksilver: currently, I am faking those things with assertions.
08:04:55 <fasta> quicksilver: I have some really efficient way to compute a value and some inefficient but guaranteed correct way.
08:05:02 <oerjan> fasta: perhaps one of those Summer of Code things i keep hearing about could do it?
08:05:07 <fasta> quicksilver: I assert that those two are the same at run time.
08:05:18 <Cale> It would be nice to have a graphical environment with which to explore Haskell code. I would really really like a code-graph visualiser.
08:05:27 <fasta> quicksilver: I am basically programming implications.
08:05:39 <edwardk> logan: heh, i got started in haskell because i wanted to write an ecmascript 4 implementation in haskell. they kept changing the spec behind closed doors though, so by the time i had a stable enough spec to code against, they'd already released a reference SML/NJ implementation. that kind of took the wind out of that initiative.
08:05:40 <Cale> (preferably an inefficient one which uses something rather close to the actual program text)
08:06:03 <Cale> (rather than translating to core or something first)
08:06:19 <LoganCapaldo> edwardk: :)
08:06:50 <fasta> Haskell mode currently parses GHC output.
08:07:02 <fasta> That's also a pretty bad idea
08:07:13 <fasta> It would be much better to _communicate_ with GHC.
08:07:14 <Cale> One thing which would be rather cool is visualising infinite data structures using the unit-disk model of the hyperbolic plane :)
08:07:39 <osfameron> fasta: like the Lisp server connection in SLIME mode emacs ?
08:07:44 <quicksilver> Cale: I really really want a pretty cell reduction GUI
08:07:44 <fasta> osfameron: right
08:07:48 <Cale> But that's getting rather far away from practicality :)
08:07:52 <Cale> quicksilver: yeah
08:07:53 <fasta> osfameron: I believe SHIM does that
08:07:57 <fasta> osfameron: but I am not sure.
08:07:59 <quicksilver> Cale: something which can show you lazy consumption of map . transpose
08:08:04 <Cale> quicksilver: :)
08:08:10 <quicksilver> Cale: and see how the (large) matrix is never all in memory at once
08:08:16 <quicksilver> assuming appropriate produces + consumers
08:08:25 <Cale> right. :)
08:08:44 <Cale> Or show how adding a seq here or there changes how the graph gets reduced.
08:08:45 <fasta> Hmm, I think I just used lazyness in monads for the first time actively :)
08:09:31 <fasta> I return undefined in the case that is expected to happen, but never will be evaluated.
08:09:38 <Cale> It's something that I've mostly learned to do in my head, but it's not so easy to convey to beginners. It would be a very nice teaching implement.
08:09:51 <quicksilver> Cale: and I bet it would reveal some surprising behaviours, even to experts
08:09:57 <Cale> oh, certainly
08:10:07 <fasta> quicksilver: but then those experts are not experts ;)
08:10:21 <quicksilver> fasta: these things are mostly relative, but your point is well-taken :)
08:10:28 <Cale> I know that Wolfram Kahl designed his own graphical graph-reduction language in order to debug a complicated algorithm in Lout.
08:10:50 <fasta> Lout is a programming language?
08:11:23 <Cale> fasta: Yeah, it's sort of the FP take on TeX.
08:11:35 <Cale> http://www.cas.mcmaster.ca/~kahl/HOPS/ANIM/index.html
08:11:36 <lambdabot> Title: HOPS - Animations
08:11:49 <LoganCapaldo> Is TeX a programming language?
08:12:06 <Syzygy-> LoganCapaldo: Of sorts, yeah.
08:12:06 <quicksilver> yes
08:12:08 <fasta> LoganCapaldo: yes
08:12:09 <Saizan> oooh, i wished i had this graph-visualizer last night when trying to see how much m >>= f >>= g is different from m >>= (\x -> f x >>= g) in the list monad
08:12:17 <Cale> LoganCapaldo: A very special purpose one, for typesetting documents.
08:12:18 <LoganCapaldo> That idea is gonna give me nightmares
08:12:21 <quicksilver> it's not generally regarded as a general purpose one
08:12:28 <quicksilver> although it is turing complete so technically it is
08:12:47 <quicksilver> it's homo-iconic and supports self-modifying code
08:12:50 <LoganCapaldo> Like those postscript programs that compute useful things
08:12:52 <jatqceer> Hi all, is there a read :: ByteString -> Double ?
08:13:14 * LoganCapaldo shudders
08:13:29 <Syzygy-> LoganCapaldo: Yeah?
08:13:50 <LoganCapaldo> I think I saw a postscript web server
08:13:50 <Syzygy-> LoganCapaldo: I still love the postscript taht computes the mandelbrot set it outputs. On your printer.
08:13:53 <Cale> jatqceer: It doesn't look like there is. You can of course convert the chunk to an ordinary string first.
08:14:01 <LoganCapaldo> yeah thing slike that
08:14:10 <LoganCapaldo> it can only get worse in TeX :)
08:14:55 <quicksilver> LoganCapaldo: standard postscript interpreters don't have network IO primitives
08:14:58 <jatqceer> I'm trying to read numeric data sets seperate with '\n'.  It's large so I want to use Data.ByteString.Char8.
08:15:01 <quicksilver> LoganCapaldo: but, clearly, with a custom one you could
08:15:08 <quicksilver> PS is just a custom kind of FORTH, isn't it?
08:15:13 <quicksilver> or a close relative, at least
08:15:18 <quicksilver> TeX is something rather more... unique.
08:15:27 <LoganCapaldo> if by kind of forth you mean a language w/ a stack, sure :)
08:15:42 <Syzygy-> "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
08:15:47 <ndm> Igloo: i just hozed my Cabal by upgrading...
08:15:47 <jatqceer> cale, so I need to convert a ByteString to a String first?
08:16:01 <fasta> Cale: is it just me or is HOPS the start of a great idea?
08:16:10 <ndm> Igloo: i did runhaskell Setup configure/build/install in Cabal, which reportedly worked
08:16:17 <LoganCapaldo> postscript is somewhere between forth and joy as I understand it
08:16:22 <Cale> jatqceer: Well, I'm not dons or dcoutts, but I think so :)
08:16:30 <LoganCapaldo> but me no ps expert
08:16:45 <quicksilver> that HOPS example is cool
08:16:45 <LoganCapaldo> (or forth or joy for that matter)
08:16:48 <sjanssen> jatqceer: yes, you'll have to go via String
08:16:53 <ndm> C:\Program Files\Haskell\Cabal-1.1.7\ghc-6.6.1/HSCabal-1.1.7.o: unknown symbol `_Cabalzm1zi1zi7_DistributionziCompatziFilePath_slash_closure'
08:16:54 <ndm> ghc.exe: unable to load package `Cabal-1.1.7'
08:16:57 <Cale> HOPS is indeed pretty cool.
08:17:00 <ndm> thats currently how broken my code is...
08:17:01 <quicksilver> I wish haskell had rules for associativity of * so it could do that transform
08:17:17 <quicksilver> I did bug JaffaCake about it once, but he thought it wasn't easy
08:17:22 <sjanssen> jatqceer: try to avoid doing 'unpack' on large strings -- do it at the last possible moment before calling read
08:17:51 <quicksilver> sjanssen: you should be able to do the B.lines  part first, right? and the unpack on the lines?
08:18:39 <jatqceer> quicksilver: yes, I was trying to do that
08:18:46 <crazy_coder> hello everyone
08:18:53 <sjanssen> quicksilver: right
08:19:44 <jatqceer> sjanssen: I couldn't think of a easy way to actually read 100k data
08:19:50 <ndm> @karma- Cabal
08:19:50 <lambdabot> Cabal's karma lowered to -1.
08:19:57 <agocorona> ndn that was a runtime error?
08:20:22 <crazy_coder> how to read a text file in Haskell ?
08:20:27 <ndm> agocorona: when Cabal was running, yes - i typed runhaskell Setup configure
08:20:36 <Cale> quicksilver: you can do a foldl', which amounts to the same thing.
08:20:51 <mauke> crazy_coder: quick and dirty? readFile
08:21:39 <vincenz>  or getContents
08:21:40 <vincenz> and then
08:21:41 <sjanssen> ndm: your old Cabal should still be around, yeah?
08:21:42 <vincenz> app < file
08:21:51 <sjanssen> ndm: just unregister the broken one with ghc-pkg
08:22:05 <ndm> sjanssen: old Cabal on Windows = worthless
08:22:35 <ndm> sjanssen: the reason for upgrading is that the old one couldn't create sdist's (which is what i need to do right now), so downgrading is not much good
08:22:48 <sjanssen> ndm: I argue that the one with 'unknown symbol' can't possibly be better :)
08:22:52 <sorear> ndm: And the new one can't either.
08:23:04 <sorear> :)
08:23:14 <ndm> indeed, the new one rates 0 on the usefulness scale, the old one was around 7/10
08:24:06 <sjanssen> ndm: the error sounds like a case of a module missing from exposed-modules
08:24:11 <sjanssen> or other-modules
08:24:22 <crazy_coder> mauke: vincenz: Thanks
08:24:43 <ndm> sjanssen: quite possible, i had to do things like change the Cabal file (the latest Cabal only works with GHC 6.7) so I may have gone wrong there (but i don't think so)
08:25:23 <shapr> @quote jfredett
08:25:23 <lambdabot> jfredett says: because If I found a language that was as good a sex, I'd use it, _alot_
08:25:28 * shapr grins
08:25:41 <mauke> @quote
08:25:41 <lambdabot> procyon112 says: Just wait until I have my "outputAsHaskell" function done, and I'll have all sorts of practical examples of unreadable code.
08:25:51 <sorear> ndm: My cabal (latest pull) doesn't even *have* Distribution.Compat.FilePath ...
08:26:04 <shapr> @quote Syzygy-
08:26:05 <lambdabot> Syzygy- says: "Fun" exercise: reimplement plain TeX as a Haskell-embedded DSL... :P
08:26:15 <ndm> sorear: i've just spotted that, mine has left over .hi and .o files - i'm trying a clean now
08:26:31 <agocorona> ndm: i had also undefined symbol errors when using hs.plugins (load) under windows. suposedly Dons is looking at it
08:26:54 <ndm> agocorona: its a lot more expected with hs.plugins, Cabal shouldn't have these issues...
08:27:53 <Igloo> ndm: 1.1.7 is the new one presumably?
08:28:13 <ndm> Igloo: from darcs is what i'm using
08:28:42 <ndm> Igloo: just doing a copmletely clean build, it may have been that which was going wrong
08:29:06 <agocorona> this error in Cabal should be when loading and linking an object file. The only known package that does that is hs.plugins
08:29:35 <Botje> Masklinn: heh. like the nick
08:29:50 <Masklinn> heh
08:30:30 <dcoutts_> ndm: you'll be glad to know that my win2k3 box is back online, so I can get building :-)
08:30:52 <ndm> dcoutts_ when can we have a gtk2hs build? i'm still stuck on SOC matters until its done
08:31:26 <sorear> agocorona: GHCi dynamically loads and links object files too
08:31:33 <dcoutts_> ndm: I'm going to do a new release and that involves building & testing on windows, you'll get the first pre-release builds to test for me :-)
08:31:35 <Syzygy-> I seem to be generating quotes latelyt....
08:31:42 <sorear> agocorona: runhaskell being another name for GHCi
08:32:08 <dcoutts_> jatqceer: yeah, there is no full framework for lexing numbers etc with ByteString, only a couple for lexing integers, so you have to go via String at the moment.
08:32:19 <dcoutts_> @quote Syzygy-
08:32:19 <lambdabot> Syzygy- says: And we have people doing maths -and- getting laid. Some of them simultaneously. :P
08:32:37 <agocorona> sorear: maybe, yes. but both can use the same underlying mechanism
08:32:37 <shapr> dcoutts_: Obviously related to the earlier jfredett quote.
08:32:59 <quicksilver> @quote jfredett
08:32:59 <lambdabot> jfredett says: because If I found a language that was as good a sex, I'd use it, _alot_
08:33:58 <dcoutts_> g'morning SyntaxNinja :-)
08:34:35 <sorear> @karma+ Cabal
08:34:35 <lambdabot> Cabal's karma raised to 0.
08:34:38 <sorear> @karma- GHC
08:34:39 <lambdabot> GHC's karma lowered to 1.
08:34:56 <oerjan> @karma ghc
08:34:57 <lambdabot> ghc has a karma of 4
08:35:06 <roconnor> dcoutts_: http://xkcd.com/c230.html
08:35:07 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
08:35:09 <rretzbach> @karma hitler
08:35:09 <lambdabot> hitler has a karma of 0
08:35:17 <oerjan> GHC-- ghc++
08:35:34 <jatqceer> dcoutts_: I hope the Num class will be supported soon
08:36:01 <dcoutts_> roconnor: heh heh
08:36:32 <sorear> dcoutts_: What about Data.Binary.Get, the LL(0) parser combinators for D.B.L?
08:37:12 <dcoutts_> yeah, there's that, but no parsing/lexing framework like Read/Show
08:37:24 <sorear> dcoutts_: Hmm, it seems trivial to extend D.B.G to LL(1), just ensure the current block is nonempty
08:37:37 <sorear> ah yes.
08:38:05 <dcoutts_> sorear: yes, some parsing combinators on top of Data.Binary.Get would be nice
08:38:13 <dcoutts_> have to consider use cases and performance
08:39:00 <shapr> dcoutts_: What about using Data.Binary parsing combinators to transparently read ASN.1 as real Haskell data structures?
08:39:18 <dcoutts_> that'd be nice
08:39:30 <dcoutts_> I don't plan on reading the ASN.1 spec however :-)
08:40:09 <shapr> I read several versions of the ASN.1 spec some years ago, my SAN score is just recovering.
08:42:09 <shapr> dcoutts_: It'd be roughly parsec that works on binary blobs, yeah?
08:42:14 <daniel_larsson> I hate ASN.1 :/
08:42:19 <dcoutts_> shapr: right
08:42:31 <dcoutts_> daniel_larsson: and with good reason! :-)
08:42:33 <shapr> daniel_larsson: I empathize.
08:43:08 <shapr> daniel_larsson: Have you seen Peter Gutmann's perfectly legal X.509 cert that embeds a 5mb video of his cat playing with a string?
08:43:39 <daniel_larsson> I've missed that one. Awesome :)
08:44:05 <shapr> Or maybe it was a PGP keysig? I forget exactly... in any case, that sort of thing shows one of the big problems with ASN.1, that the optional ANY blobs really suck.
08:44:12 <daniel_larsson> I might hate BER more than ASN.1 itself, I haven't made up my mind yet
08:44:57 <shapr> XER is another impressive encoding.
08:45:17 <shapr> I think that DER and BER aren't so bad, but there are about thirty other major encoding flavors.
08:45:31 <daniel_larsson> I remember back in the days I actually had to bother with ASN.1, some guys made their own encoding, which was roughly 1000 times faster than proper BER
08:45:36 <shapr> And I've heard that there are hundreds of minor encodings... it's just terrifying.
08:46:16 <daniel_larsson> 61 byte integers anyone?
08:46:29 <LoganCapaldo> 61 byte integers?
08:46:30 <shapr> I don't like XML much, for similar reasons... but at least it's usually distributed in either UTF-8 or iso-8859-1 !
08:46:49 <daniel_larsson> LoganCapaldo: BER can encode them
08:47:10 <LoganCapaldo> > 2 ^ (8 * 61)
08:47:12 <lambdabot>  7991676288808940112336888908270505742716411245222326146199441816640951651378...
08:47:19 <LoganCapaldo> that's a big integer
08:48:37 <shapr> daniel_larsson: For about a year it was my job to implement the client side of RFC3161, while the server side was being done by ... I think the Finnish government.
08:49:08 <oerjan> > length $ show $ 2 ^ (8*61)
08:49:11 <lambdabot>  147
08:49:25 <Syzygy-> shapr: Did the two follow the same interpretation of the RFC?
08:49:51 <sorear> shapr: Parsec works fine on binary blobs; it's just performance we're after.
08:50:05 <Syzygy-> > log n / log 10 where n = 2^(8*61)
08:50:05 <lambdabot>  Parse error
08:50:30 <Syzygy-> > let n = 2^(8*61) in log n / log 10
08:50:32 <lambdabot>  146.90263788402282
08:50:34 <shapr> Syzygy-: My client successfully queried the server twice, before the server project was shutdown. I was about a week from quitting the company from sheer frustration when I got that wonderful bit of news.
08:50:47 <Syzygy-> Hehe
08:51:43 <daniel_larsson> shapr: Ah. I did some work with, I hope a now long obsolete standard, called MMS. Process Control as in controlling paper mills, and other industrial processes. And the dams in netherlands. It was based on ASN.1/BER...
08:52:11 <shapr> My boss wanted to write the ASN.1 parser in C, and do everything manually, the company mandated Java so I used a javacc with an asn.1 lib to generate the parser. Problem was that both were thoroughly buggy.
08:53:18 <shapr> daniel_larsson: That sounds challenging.
08:54:22 <Syzygy-> shapr: Ouch.
08:54:45 * Syzygy- got to implement ASN.1 parsing for X.509 handling in Ansi C on my old job...
08:54:58 <shapr> Peter Gutmann's asn1dump.c was the most reliable way to get data from the server.
08:55:02 <daniel_larsson> Companies mandating java makes me scared :/
08:55:05 <shapr> Syzygy-: Wow, how did that go?
08:55:28 <shapr> Syzygy-: Also, how did you get such an awesome hostname?
08:55:30 <Syzygy-> Reasonably well. I could successfully parse sample certificates by the time I handed in my 3month notice to go do my PhD.
08:55:48 <Syzygy-> The hostname belongs to a guy sitting on #ANOTHER_CHANNEL
08:55:51 <shapr> ah
08:56:00 <Syzygy-> Who I know because my brother did classes with him. :P
08:56:06 <daniel_larsson> <-- recently sneak-introduced haskell into my company's product line!
08:56:31 <shapr> Syzygy-: I'm impressed. You wrote the parsers by hand? How long did it take you?
08:56:37 <shapr> daniel_larsson: Cool! How so?
08:56:42 <Philippa> sure you want to admit to that on a publically-logged chan? :-) And yeah, how so?
08:56:52 <rretzbach> negateall [a] = map negate [a] -- when trying negateall [1,4] I get "non-exhaustive patterns2
08:57:06 <rretzbach> map negate [1,4] works.
08:57:09 <Syzygy-> shapr: I had a skeleton available already. And we needed extreme control of code size.
08:57:35 <edwardk> heh, i used quickcheck a couple weeks back to demonstrate the correctness of a data warehouse publishing process we were using.
08:57:39 <Syzygy-> Basically, I was writing for a cryptography library that's sold to mobile phone firmware producers...
08:58:04 <oerjan> rretzbach: drop the [] around the a's
08:58:16 <edwardk> though that was 'out-of-band' and only demonstrated the correctness of a process, rather than a use of haskell in the day-to-day operations
08:58:22 <oerjan> you are only doing 1-element lists
08:58:25 <rretzbach> oerjan: I will, but will you please tell me why.
08:59:00 <quicksilver> rretzbach: [a] in that context means 'list whose only element is a'
08:59:07 <quicksilver> rretzbach: [a] matches [1] with a=1
08:59:11 <edwardk> rretzbach: when you say negateall [a] you are matching a singleton list
08:59:12 <quicksilver> rretzbach: [a] fails to match [1,4]
08:59:18 <Syzygy-> Philippa: Sure, I'll admit it publicly as long as I'm allowed to complete the statement with some sort of motivation. :)
08:59:25 <daniel_larsson> Well, it was a simple postprocessor for some accounting files (RADIUS accounting), and I wrote it in shell-scripts, then in haskell. The haskell version was unsurprisingly quite a bit faster (almost 100 times), and shorter )
08:59:28 <edwardk> negateall a = map negate a  will match any list
08:59:46 <Philippa> Syzygy-: I meant daniel_larsson :-)
08:59:51 <Syzygy-> Ah
09:00:11 <edwardk> when pattern matching [] is the empty list, [a] is a singleton list, (x:xs) extracts the head of the list and its tail
09:00:27 <rretzbach> Well the next chapter is pattern matching... :\
09:00:36 <Syzygy-> rretzbach: Go read it.
09:00:52 <rretzbach> But it's weird that it comes this late.
09:00:55 <edwardk> lists are unfortunately a bit of a special case where the pattern matching rules are concerned so they can be tricky
09:01:10 <Vulpyne> You can also match against multiple items at the head, like (x:y:z:zs)
09:01:29 <quicksilver> I agree, I'd have put pattern matching in a very early chapter
09:01:37 <quicksilver> I'd do pattern matching before HOFs
09:01:42 <quicksilver> but there are many ways to write a book
09:01:47 <edwardk> but the sugar there is a lot nicer than having to say "Cons x (Cons y (Cons z zs)))" =)
09:01:49 <quicksilver> and it's not clear I'd do very well at it :)
09:01:52 <edwardk> or something like that
09:01:55 <shapr> edwardk: That's cool! Industrial use of Haskell!
09:02:29 <Philippa> quicksilver: it depends a bit on your target audience. Some people get it better if you show them a separate case statement and then the syntactic sugar...
09:02:33 <shapr> daniel_larsson: Yay, shell script optimization!
09:02:38 <Philippa> in which case it can help to've done HOFs first
09:04:01 <quicksilver> Philippa: well if you haven't done mattern patching before you do the exercises, then people get confused trying to do the exercises like rretzbach has just
09:04:12 <quicksilver> Philippa: but yes, I agree, it does depend on the audience
09:04:23 <quicksilver> wow spontaneously spooneristic typing there :)
09:04:43 * shapr spoonerizes often.
09:05:13 <rretzbach> Well I definitely like not being taught everything at once.
09:05:37 <rretzbach> The books even tell me "in facts it's ..., but we want to keep it simple"
09:06:08 * shapr whispers to quicksilver 'there is no spoonerizing'
09:06:48 <MyCatVerbs> shapr: sere are no thoonerisms.
09:06:53 <shapr> heh
09:11:07 <nominolo> SyntaxNinja: congrats :)
09:11:17 <shapr> SyntaxNinja: Yeah, congrats!
09:12:28 <quicksilver> where the congrats for SyntaxNinja ?
09:13:00 <LoganCapaldo> SyntaxNinja: congrats for whatever it is!
09:14:52 <malcolmw> SyntaxNinja got married last week
09:15:19 <Syzygy-> Congratulations!!
09:16:31 <SyntaxNinja> :)
09:16:38 <SyntaxNinja> thanks :)
09:16:41 <Philippa> quicksilver: if you haven't taught pattern matching, don't issue exercises that use it?
09:17:02 <Philippa> and 'grats, SyntaxNinja
09:17:08 <SyntaxNinja> nominolo: will get back to you asap about SoC. dcoutts might be able to help w/ code reviews too.
09:17:11 <SyntaxNinja> thanks, Philippa
09:17:39 <MyCatVerbs> SyntaxNinja: apologies for my tardiness, but congratulations. ^^
09:19:43 <LoganCapaldo> @hoogle (Monad m) => (a -> b -> c) -> [a] -> [b] -> m [c]
09:19:44 <lambdabot> No matches, try a more general search
09:20:30 <LoganCapaldo> Is this in the libs somewhere?
09:20:32 <LoganCapaldo> @type let zipSameWith f [] [] = return []; zipSameWith f as [] = fail "Lists of unequal length"; zipSameWith f [] as = fail "Lists of unequal length"; zipSameWith f (a:as) (b:bs) = do { cs <- zipSameWith f as bs; return $ (a `f` b):cs } in zipSameWith
09:20:34 <lambdabot> forall t t1 a (m :: * -> *). (Monad m) => (t -> t1 -> a) -> [t] -> [t1] -> m [a]
09:20:40 <SyntaxNinja> thanks, MyCatVerbs
09:21:16 <LoganCapaldo> (the idea being to use m = Maybe)
09:21:35 <quicksilver> LoganCapaldo: no, it's not
09:21:43 <LoganCapaldo> k
09:21:51 <quicksilver> LoganCapaldo: it's a sensible function, though
09:21:57 <LoganCapaldo> is there a better name?
09:21:59 <quicksilver> modulo concerns about disliking fail
09:22:05 <LoganCapaldo> I don't really want to call it zipM
09:22:12 <opqdonut> isn't there a zipM?
09:22:14 <quicksilver> you shouldn't call it zipM
09:22:21 <LoganCapaldo> because I want the idea that its for zipping lists of equal length to be clear
09:22:25 <quicksilver> zipWithM would take t -> t1 -> m a
09:22:25 <opqdonut> :t zipM
09:22:27 <lambdabot> Not in scope: `zipM'
09:22:31 <quicksilver> :t zipWithM
09:22:33 <lambdabot> forall a b (m :: * -> *) c. (Monad m) => (a -> b -> m c) -> [a] -> [b] -> m [c]
09:22:37 * quicksilver nods
09:22:38 <opqdonut> ah :)
09:22:45 <quicksilver> LoganCapaldo: zipSameLength?
09:22:54 <quicksilver> hmm
09:22:58 <quicksilver> cna't think of a really good name
09:22:58 <LoganCapaldo> Just seems unwieldy
09:23:17 <opqdonut> LoganCapaldo: have you got an example usecase for that?
09:23:22 <opqdonut> (just interested)
09:23:43 <LoganCapaldo> opqdonut: not really. I was thinking about how to write == for lists
09:23:51 <opqdonut> mmmh
09:23:55 <LoganCapaldo> and I wanted to do it as a fold of && over zipWith ==
09:25:17 <Saizan> do we have a monad for non-fatal errors? so you end up with both a result and some errors
09:25:35 <opqdonut> Saizan: well, list in a way
09:25:36 <LoganCapaldo> List?
09:25:55 <oerjan> Saizan: might use Writer?
09:25:58 <byorgey> but with List, things that fail just disappear
09:26:29 <Saizan> what byorgey said..
09:26:31 <quicksilver> Saizan: that's a little tricky
09:26:45 <quicksilver> Saizan: since you'd have to be able to return a 'usable result' along with the failur
09:26:55 <quicksilver> Saizan: which starts to sound a bit like Writer
09:27:30 <LoganCapaldo> return usable result and log failures?
09:27:33 <Saizan> quicksilver: yes, it's probably an incarnation of writer
09:27:39 <quicksilver> LoganCapaldo: *nods*
09:31:15 <oerjan> maybe ErrorT [] might also work...
09:32:15 <oerjan> i mean ErrorT e []
09:33:05 <oerjan> since presumably the backtracking would be across the errors, collecting both useful results and errors.
09:42:09 <opqdonut> ?src Writer (>>=)
09:42:09 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:42:16 <opqdonut> ?src (>>=) Writer
09:42:16 <lambdabot> Source not found. stty: unknown mode: doofus
09:42:21 <opqdonut> ?src Writer.(>>=)
09:42:21 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
09:42:23 <opqdonut> bah
09:47:19 <Saizan> ?type let (w,a) >>= f = let (w',a') = f a in (w `mappend` w',a') in (>>=)
09:47:24 <lambdabot> forall t t1 t2. (Monoid t) => (t, t1) -> (t1 -> (t, t2)) -> (t, t2)
09:48:11 <easy4> How do I print a fraction without it being converted to a real?
09:48:26 <opqdonut> > 1%2
09:48:28 <lambdabot>  1%2
09:48:29 <ddarius> easy4: ?
09:48:42 <mauke> easy4: print fraction
09:48:48 <opqdonut> :t (%)
09:48:51 <lambdabot> forall a. (Integral a) => a -> a -> Ratio a
09:48:59 <opqdonut> :t (1%2)
09:49:02 <lambdabot> forall t. (Integral t) => Ratio t
09:49:14 <oerjan> > 2/3 :: Rational
09:49:17 <lambdabot>  2%3
09:49:42 <easy4> In ghci 1/2 prints as 0.5, which I don't want.
09:49:59 <sorear> opqdonut:
09:50:04 <sorear> ?src (,) >>=
09:50:04 <lambdabot> Source not found. Wrong!  You cheating scum!
09:50:07 <sorear> ?src (,) (>>=)
09:50:07 <lambdabot> Source not found. The more you drive -- the dumber you get.
09:50:09 <ddarius> easy4: That's because it defaults to Double
09:50:15 <oerjan> easy4: it does that in the floating point types, but not the Rational one
09:50:19 <sorear> b vhj hnc bjhh crvfgt l,
09:50:20 <ddarius> > 1/2 :: Rational
09:50:20 <byorgey> easy4: use % instead of / if you want rational numbers.
09:50:22 <lambdabot>  1%2
09:50:38 <easy4> OK, thanks.
09:50:57 <sorear> Why isn't the default default (Integer,Rational)
09:51:24 <sorear> (Int, Double) would make sense too
09:51:25 <oerjan> sorear: Rational doesn't have sin, sqrt and the like
09:52:29 <oerjan> @instances Floating
09:52:31 <lambdabot> Double, Float
09:52:47 <oerjan> @instances RealFrac
09:52:48 <lambdabot> Double, Float
09:52:56 <oerjan> er...
09:53:03 <oerjan> @src RealFrac
09:53:04 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
09:53:04 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
09:53:04 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
09:53:22 <oerjan> > floor (5%4)
09:53:24 <lambdabot>  1
09:53:51 <ddarius> @instances-importing RealFrac
09:53:52 <lambdabot> Double, Float
09:54:36 <oerjan> @help instances-importing
09:54:36 <lambdabot> instances-importing [<module> [<module> [<module...]]] <typeclass>. Fetch the instances of a typeclass, importing specified modules first.
09:54:53 <oerjan> @instances-importing Ratio RealFrac
09:54:53 <ddarius> @instances-importing Ratio RealFrac
09:54:54 <lambdabot> Double, Float, Ratio a
09:54:55 <lambdabot> Double, Float, Ratio a
09:55:17 <oerjan> @help instances
09:55:17 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
09:55:32 <opqdonut> @src Control.Monad.Writer.WriterT
09:55:32 <lambdabot> Source not found. That's something I cannot allow to happen.
09:55:54 <ddarius> :t runWriterT
09:55:56 <lambdabot> forall w (m :: * -> *) a. WriterT w m a -> m (a, w)
10:14:53 <ski> ~(w0,a) >>= k = (w0 `mappend` w1,b)
10:14:56 <ski>   where
10:14:56 <ski>   (w1,b) = k a
10:17:41 <Apocalisp> Annoyance!
10:17:45 <DRMacIver> Hm. Looks like I'm going to be late to London HUG.
10:17:59 * sorear bangs on pots at Apocalisp
10:18:39 <crazy_coder> Building a text-editor would require what all ?
10:18:52 <Apocalisp> Microsoft named their new shell "Monad" as a working title, and now Googling for Monad is littered with Visual Basic garbage.
10:19:23 <Apocalisp> Fools! The name "Monad" is already reserved by the implementors!
10:19:33 <crazy_coder> shell ?
10:19:56 <Apocalisp> ?Google Monad
10:19:56 <lambdabot> Maybe you meant: google hoogle
10:20:02 <glen_quagmire> i work for microsoft by buying windows xp cd.
10:20:03 <Apocalisp> ?google monad
10:20:05 <lambdabot> http://www.microsoft.com/technet/scriptcenter/hubs/msh.mspx
10:20:05 <lambdabot> Title: Scripting with Windows PowerShell
10:20:16 <shapr> Apocalisp: Yeah, and before that XP was an agile programming paradigm. I think Microsoft makes a serious attempt to steal popular words.
10:20:58 <ski> we ought to call the next big thing 'gonad'
10:21:01 <Apocalisp> shapr: You may be right. Their marketing department probably monitors up-and-coming fad words.
10:21:21 <glen_quagmire> gonaz and stripe
10:21:39 <glen_quagmire> ?google gonaz and stripe
10:21:41 <lambdabot> http://www.bebo.com/Profile.jsp?MemberId=20133168
10:21:41 <lambdabot> Title: Johny-C- <Johny-C->
10:22:06 <shapr> Then there's Apple... who named one of their products the eMac. That caused much excitement when housewives started posting excited fluttery messages to comp.eMacs newsgroups.
10:22:25 <Apocalisp> hahah
10:22:40 <apfelmus> *lol*
10:22:44 <Apocalisp> ?remember shapr Then there's Apple... who named one of their products the eMac. That caused much excitement when housewives started posting excited fluttery messages to comp.eMacs newsgroups.
10:22:44 <lambdabot> Done.
10:22:58 <apfelmus> well, eMac is actually a valid acronym.
10:23:08 <apfelmus> "educational Macintosh"
10:23:22 <apfelmus> and it rhymes with iMac
10:23:24 <Apocalisp> why didn't they just call it the Granny Smith?
10:23:33 <shapr> Apocalisp: ooh, good name.
10:24:19 <apfelmus> so, the similarity to emacs is rather unintended
10:24:30 <mauke> @google vimacs
10:24:34 <lambdabot> http://vimacs.com/
10:24:34 <lambdabot> Title: Invoice, Invoicing Software, Inventory Software, Billing Software, Inventory Con ...
10:24:41 <opqdonut> :D
10:31:45 <sorear> I presume comp.eMacs == comp.emacs?
10:31:55 <shapr> yeah
10:32:21 <ihope> I suddenly have the urge to point out that fix error and error (fix error) have different types.
10:32:31 <sorear> Yup.
10:32:47 <sorear> fix error has type forall (a :: *) . a
10:32:59 <sorear> error (fix error) has type forall (a :: ?) . a
10:33:04 <ihope> fix error :: String, no?
10:33:16 <sorear> Oh, yeah, forgot about that. :)
10:33:30 <ihope> What is ?
10:34:00 * sorear just loves the way error is a magic primitive in GHC, as magic as seq or unsafeCoerce#
10:34:16 <sorear> ihope: Superkind of * and #
10:34:19 <ihope> Magic primitive?
10:34:33 <sorear> With special typing rules...
10:35:08 <Lemmih> sorear: error /= throw . ErrorCall ?
10:35:59 <sorear> Lemmih: error isn't definable in GHC Haskell at all.  it's too polymorphic
10:36:22 <crazy_coder> dons: Are you there ?
10:36:24 <glen_quagmire> i think x = 1;   x is a function that takes no parameter
10:36:38 <sorear> glen_quagmire: A valid interpretation.
10:36:41 <glen_quagmire> > x = 1; :t x
10:36:42 <lambdabot>  Parse error
10:36:52 <sorear> @let x = 1
10:36:55 <Lemmih> ?type \s -> Control.Exception.throw (Control.Exception.ErrorCall s)
10:36:55 <lambdabot> Defined.
10:36:57 <lambdabot> forall a. String -> a
10:36:58 <Lemmih> ?type \s -> error s
10:37:00 <lambdabot> forall a. [Char] -> a
10:37:00 <Botje> :t let x = 1 in x
10:37:02 <lambdabot> forall t. (Num t) => t
10:37:19 <sorear> :t error "" :: GHC.Prim.Int#
10:37:22 <lambdabot> GHC.Prim.Int# :: GHC.Prim.Int#
10:37:38 <Lemmih> Ah, the kind.
10:37:39 <sorear> :t Control.Exception.throw (Control.Exception.ErrorCal "") :: GHC.Prim.Int#
10:37:41 <lambdabot>     Not in scope: data constructor `Control.Exception.ErrorCal'
10:37:45 <sorear> :t Control.Exception.throw (Control.Exception.ErrorCall "") :: GHC.Prim.Int#
10:37:47 <lambdabot>     Couldn't match kind `*' against `#'
10:37:47 <lambdabot>     When matching the kinds of `a :: *' and `GHC.Prim.Int# :: #'
10:37:57 <glen_quagmire> lambdabot: asl?
10:38:31 <sorear> glen_quagmire: Sorry, that plugin is broken.
10:39:04 <ihope> @type error "" :: GHC.Prim.Int#
10:39:08 <lambdabot> GHC.Prim.Int# :: GHC.Prim.Int#
10:39:19 <ihope> @type let foo = error in foo "" :: GHC.Prim.Int#
10:39:21 <lambdabot>     Couldn't match kind `*' against `#'
10:39:21 <lambdabot>     When matching the kinds of `a :: *' and `GHC.Prim.Int# :: #'
10:39:28 <ihope> Wow.
10:39:52 <ihope> True indeed: it can't be defined within the language.
10:39:59 <sorear> glen_quagmire: 5/F/UNSW
10:40:29 <glen_quagmire> good your_age >= floor(my_age/2) + 7
10:40:51 <glen_quagmire> i'm kidding
10:42:14 <ihope> UNSW?
10:42:31 <sorear> University of New South Wales, Sydney, Australia
10:43:36 <edward1> glen: you might want to open that range up a little more at the top. you rule out a lot of people when you turn 70 or so ;)
10:44:01 <ihope> Only people under 42!
10:44:06 <ihope> I think.
10:44:17 <glen_quagmire> this office doesn't have AC.
10:44:22 <glen_quagmire> i'm like stweating all over
10:44:28 * sorear likes apfelmus' quit message
10:44:30 <edward1> even so, living your life according to such rich guidelines maybe you should let loose a little later ;)
10:45:48 <glen_quagmire> (lx.xx)(lx.xx) what does this do?
10:45:58 <glen_quagmire> l(lx.xx).xx
10:46:05 <ihope> glen_quagmire: waits until you get bored.
10:46:08 <glen_quagmire> it'll return (lx.xx)(lx.xx)
10:46:14 <ihope> Runs until you get bored, that is.
10:46:20 <glen_quagmire> it's infinite recursinon
10:46:36 <sorear> Omega.
10:46:52 <glen_quagmire> i'm gonna write an interpreter in Actionscript so that you can see animations and listen to mp3 while you code
10:47:57 <byorgey> glen_quagmire: isn't that the Y combinator applied to id?
10:48:28 <shapr> Today's nifty error:"internal error: lockFile: fd out of range"
10:48:42 <sorear> byorgey: all unnormalizing terms are extensionally equivalent
10:49:16 <sorear> shapr: is that from the GHC-RTS?
10:49:27 <glen_quagmire> byorgey: i'm not sure. that was apfelmus' exit message
10:49:28 <byorgey> sorear: sorry, I grok "extensionally equivalent", but what's an "unnormalizing term"
10:49:29 <sorear> @quote bbb
10:49:29 <lambdabot> shapr says: Today's nifty error message: *Main> thread blotttchhhkrrreeeedaaa dddi   nbbbdllleooofcccikkkneeeidddt   eiiilnnnydddeeefffiiinnniiittteeelllyyy
10:49:43 <sorear> byorgey: One that doesn't normalize.
10:49:51 <sorear> byorgey: I made the term up 15s ago
10:49:58 <shapr> sorear: Heh, maybe I should have a weekly 'nifty error' blog post.
10:50:12 <byorgey> sorear: oh, hehe, I get it
10:50:21 <byorgey> glen_quagmire: http://en.wikipedia.org/wiki/Y_combinator
10:50:22 <lambdabot> Title: Fixed point combinator - Wikipedia, the free encyclopedia
10:51:03 <glen_quagmire> paul grahm used that as his cmopany name. just like microsoft Windows
10:54:31 <SamB> okay, say I have a list of 18-bit words and I need to serialize them to 3 8-bit bytes each (with a parity bit and another bit in each one)
10:54:57 <SamB> (I just want to put them in a file)
10:55:02 <SamB> what's a good way to do this?
10:57:48 <shapr> SamB: Use the BitSyntax lib from imperialviolet.org ?
10:58:00 <sorear> map (.&. 63) . zipWith shiftR (cycle [0,6,12])
10:58:22 <SamB> shapr: is that speedy?
10:58:39 <SamB> probably doesn't really matter
10:59:09 <chris`> Does anyone know why runhaskell Setup.lhs .* could return silently (without apparently doing anything)? This happens attempting to build X11-extras or xmonad with ghc.
10:59:34 <sorear> chris`: Why .* ?
10:59:53 <chris`> Sorry, (configure|build|install).
11:00:06 <chris`> Any command I throw at it returns to the prompt after about 1 second.
11:00:31 <edward1> runhaskell pointed off to lala land somehow?
11:00:34 <sorear> What happens when you run 'ghci Setup.lhs' and ':main' ?
11:00:43 <chris`> I'll check.
11:01:02 <sjanssen> alternatively, try ghc --make Setup, then run the Setup executable GHC produces
11:01:33 <chris`> It displays the initialization banner and then Killed. Sorry guys, I'm guessing that my ghc installation may be having a problem with hardened Gentoo.
11:01:48 <SamB> sorear: not quite...
11:01:58 <sorear> SamB: Yeah, parity, I know
11:02:17 <sjanssen> chris`: did you try ghc --make?
11:02:23 <SamB> sorear: that's not what I meant
11:02:28 <sorear> chris`: GHCi makes essential use of self modifying code, and doesn't work on SELinux.
11:02:31 <SamB> for one thing, you didn't flip shiftR
11:02:40 <sorear> chris`: Incidentally, this exact problem is in the GHC FAQ
11:02:43 <SamB> for another, that drops 2/3 of the data
11:02:50 <sjanssen> chris`: even if ghci/runghc is broken, there's a good chance that ghc works
11:05:28 <chris`> Thanks, I will check the faq and try --make.
11:06:08 * chris` cringes at the thought of rebuilding world.
11:07:05 <sorear> rebuilding world?
11:08:41 <Syzygy-> sorear: Rebuilding all the installed programmes - for instances in order to deharden gentoo, or for that matter in order to do a general system update.
11:08:46 <byorgey> the world could use some rebuilding.
11:08:49 <sjanssen> sorear: Gentoo speak for rebuilding the whole system
11:10:04 <byorgey> Is there any way to extract a String from an Id in the GHC API?
11:10:26 <sorear> what's an Id?
11:10:35 <olsner_> rebuilding world = recompiling every package installed?
11:10:39 <sorear> doesn't it have a fast string?
11:10:41 <byorgey> It's a type representing an identifier
11:10:48 <sjanssen> olsner_: yes
11:11:11 * sorear doesn't have much sympathy for users of source-only distributions
11:12:04 <sorear> byorgey: You might try asking in #ghc (the topic is GHC development but in practice it's more of GHC internals)
11:12:17 <byorgey> sorear: thanks
11:13:56 * byorgey just realized that "show" works just fine =P
11:25:11 <SamB> okay... suppose I have a list of Word8 and I want to write those to a file?
11:25:34 <sjanssen> convert to Char and hope GHC's bugs are never fixed
11:26:02 <sorear> Data.ByteString.writeFile "foo" . Data.ByteString.pack
11:26:04 <sjanssen> or use hPutBuf (quite painful)
11:26:13 <sorear> bytestrings will always be bytes :)
11:26:22 <sjanssen> sorear: probably better to use .Lazy
11:26:46 <sorear> sjanssen: Yes, but that's 12 more keystrokes :)
11:30:39 <SamB> sorear: only if you don't import it as BSL
11:33:51 <rretzbach> @type and
11:33:55 <lambdabot> [Bool] -> Bool
11:34:14 <rretzbach> I thought it would be Bool -> Bool -> Bool
11:34:32 <rretzbach> True and False --=> False
11:34:51 <cjay> rretzbach: thats &&
11:35:07 <rretzbach> Yeah, I guess "and" is the list version of &
11:35:13 <rretzbach> && that is.
11:35:27 <cjay> yes
11:35:32 <cjay> @src and
11:35:32 <lambdabot> and   =  foldr (&&) True
11:35:55 <rretzbach> The "@src" command might come in very handy. How do I do it in ghci?
11:36:27 <cjay> iirc it's a lambdabot feature :/
11:37:07 <rretzbach> Why not: and = foldr1 (&&) ?
11:37:09 <shapr> rretzbach: But there is ghci-on-acid, which includes lambdabot features!
11:37:21 <rretzbach> sounds hot!
11:37:40 <oerjan> > and []
11:37:42 <lambdabot>  True
11:37:54 <shapr> @where goa
11:37:55 <lambdabot> http://www.cse.unsw.edu.au/~dons/code/goa/
11:39:24 <rretzbach> oerjan: I don't know >.
11:39:38 <rretzbach> shapr: Thank you.
11:39:52 <oerjan> rretzbach: > is the lambdabot command to evaluate an expression
11:40:16 <sorear> True name @run
11:40:19 <sorear> @run 2 + 2
11:40:21 <lambdabot>  4
11:40:25 <rretzbach> tehehe, my bad
11:40:28 <oerjan> @type (>) -- also this
11:40:32 <lambdabot> forall a. (Ord a) => a -> a -> Bool
11:40:55 <crackers> ?users
11:40:55 <lambdabot> Maximum users seen in #haskell: 351, currently: 346 (98.6%), active: 11 (3.2%)
11:41:04 <oerjan> @run spot run
11:41:05 <lambdabot>   Not in scope: `run'
11:41:13 <rretzbach> forall and Ord I do not understand.
11:41:36 <cdsmith> @ty spot
11:41:39 <lambdabot> Not in scope: `spot'
11:41:59 <cdsmith> ?  Wht'd it complain about run, the\n?
11:42:22 <crackers> ?run
11:42:22 <lambdabot>  Parse error
11:42:34 <crackers> ?type run
11:42:36 <lambdabot> Not in scope: `run'
11:42:38 <sorear> rretzbach: for all possible types a, if a is a member of the type class Ord then (>) has type a -> a -> Bool
11:42:40 <rretzbach> oerjan: So add [] is True, is this a reason to use foldr instead of foldr1?
11:42:45 <sorear> Yes.
11:43:31 <rretzbach> I see that if would be bad for accumulating (?) ||, but for & too?
11:43:35 <oerjan> rretzbach: if you want it defined for an empty list, that's the most reasonable choice.
11:43:48 <rretzbach> Ahhh.
11:43:52 <rretzbach> Now I get it.
11:44:12 * SamB wonders how to implement his PDP-1 emulator
11:44:13 <rretzbach> foldr1 and foldl1 give an runtime error on empty lists.
11:44:29 <rretzbach> foldl1' too I guess.
11:44:30 <oerjan> right
11:45:12 <cdsmith> SamB: You should updgrade to the PDP-10.  It has all the latest new features!
11:45:25 <SamB> cdsmith: -10 ?
11:45:33 <SamB> was there one?
11:45:39 <Syzygy-> Hey, splurge. Do the PDP-11.
11:45:49 <cdsmith> SamB: yes
11:45:51 <Syzygy-> http://en.wikipedia.org/wiki/Pdp_10
11:45:52 <SamB> but I don't need a simulator for that...
11:45:54 <cjay> why doesn't and use foldl, I thougt foldl was more memory-efficient than foldr
11:46:05 <Syzygy-> SamB: Of course you do.
11:46:34 <SamB> anyway, it definately won't let me test my PDP-1 MACRO assembler
11:46:36 <Syzygy-> Some of TRON was rendered ona  PDP-10.
11:47:03 <rretzbach> cjay: I guess because Haskell is lazy it's slower.
11:47:23 <SamB> cjay: you mean foldl'?
11:47:24 <sorear> cjay:
11:47:25 <cdsmith> rretzbach: it depends, as always
11:47:38 <oerjan> cjay: because && is not strict
11:47:41 <sorear> > and ([False] ++ repeat True) -- cjay
11:47:43 <lambdabot>  False
11:47:45 <SamB> oerjan: that's a funny reason
11:47:58 <sorear> > foldl (&&) True  ([False] ++ repeat True) -- cjay
11:48:02 <rretzbach> Ahh right, infinite lists...
11:48:05 <lambdabot> Terminated
11:48:14 <oerjan> foldr makes sense over nonstrict functions, foldl' over strict ones
11:48:17 <SamB> > foldl' (&&) True ([False] ++ repeat True)
11:48:21 <oerjan> and foldl rarely.
11:48:24 <lambdabot> Terminated
11:48:24 <sorear> rretzbach: Or even merely long ones.
11:48:29 <rretzbach> Hai!
11:48:39 <SamB> > foldl' (&&) True [False, undefined]
11:48:40 <lambdabot>  False
11:48:43 <sorear> rretzbach: ECHAN?
11:48:49 <cjay> ah ok
11:49:08 <sorear> rretzbach: you have a quoting problem in your IRC client setup
11:49:09 <SamB> I'd be totally happy with and = foldl' (&&) True
11:49:11 <sorear> rretzbach: "Robert
11:49:22 <SamB> wel..
11:49:25 <SamB> maybe not.
11:49:31 <rretzbach> sorear: Yeah :>
11:49:33 <SamB> I suppose it saves time not to read the whole list...
11:49:36 <sorear> rretzbach: sounds like you tried "Robert Retzbach" but it got split on the space :)
11:49:43 <SamB> does and have constant stack usage as it is?
11:49:48 <rretzbach> sorear: I know :>
11:49:54 <rretzbach> But as Haskell I am lazy.
11:50:11 <sorear> SamB: Yes.
11:50:30 <SamB> thats fine then
11:50:35 <SamB> it isn't like sum or product
11:50:54 <SamB> ... i
11:51:39 <SamB> 'd be happy with foldl' if it weren't for the fact that it was slower that way, though.
11:51:40 <rretzbach> I just fixed my realname, just for you :)
11:52:08 <SamB> rretzbach: Unknown
11:52:25 <rretzbach> I get a correct reply on a whois.
11:52:41 <crazy_coder> Is 'real world Haskell' book available ?
11:52:46 <SamB> oh, I guess my client cached it
11:52:51 <rretzbach> :)
11:53:01 <SamB> if I actually do a /whois it works fine
11:53:10 <sorear> rretzbach++
11:53:13 <sorear> :)
11:53:19 <rretzbach> Thanks, mate.
11:53:49 <byorgey> crazy_coder: it's being written
11:53:54 <rretzbach> I don't like the karma feature, it increases the spam very much. hitler--
11:54:22 <byorgey> crazy_coder: I haven't seen any info after the initial announcement, although there were promises to make parts of it available as work progressed.
11:54:58 <SamB> rretzbach: huh?
11:55:35 <SamB> at least we made it silent when you use the ++/-- form (nevermind that it was upon the insistance of #perl6)
11:56:19 <oerjan> SamB: you mean if we use @karma+ it goes to all the channels?
11:56:38 <oerjan> er. never mind.
11:57:16 <SamB> no, the message just goes to the one in which you @karma+/-
11:57:46 <cjay> there is a lot of karma-spam in other channels, but not in here :)
11:57:51 <oerjan> i first thought you meant it was made silent upon the insistance of #perl6.
11:58:06 <oerjan> er, maybe you did.
11:58:08 <SamB> but when ++/-- was first implemented, they too wrote text to the channel
11:58:56 <SamB> ... since lambdabot is in #perl6, there was a lot of that going on, and it annoyed them that lambdabot would say something whenever they did it...
11:59:26 <SamB> I think their CIA bot does one ++ for each line of commit message...
11:59:59 <rretzbach> The wikibook uses Ord without explaining it :(
12:00:11 <sjanssen> @karma audreyt
12:00:11 <lambdabot> audreyt has a karma of 634
12:00:18 <oerjan> @src Ord
12:00:18 <lambdabot> class  (Eq a) => Ord a  where
12:00:18 <lambdabot>     compare      :: a -> a -> Ordering
12:00:18 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:00:18 <lambdabot>     max, min         :: a -> a -> a
12:00:25 <sjanssen> @karma
12:00:25 <lambdabot> You have a karma of 51
12:00:30 <sjanssen> @karma-all
12:00:30 <lambdabot>  "audreyt"             634
12:00:30 <lambdabot>  "fglock"              203
12:00:30 <lambdabot>  "dons"                143
12:00:30 <lambdabot>  "gaal"                 99
12:00:30 <lambdabot>  "agentz"               97
12:00:32 <lambdabot> [1107 @more lines]
12:00:53 <crackers> ?karma
12:00:53 <lambdabot> You have a karma of 0
12:00:57 <crackers> woohoo
12:01:01 <oerjan> rretzbach: Ord is the class for types whose values can be compared to each other.
12:01:31 <crackers> actually it's the class for types that can be ordered
12:01:33 <oerjan> (by order)
12:01:38 <rretzbach> Ahh, makes sense, cause I wondered wether elements have to have something like an Interface for being compared.
12:01:42 <crackers> equality comparisons are not sufficient
12:01:58 <SamB> these karmas would seem to support what I said about their CIA bot ;-)
12:02:03 <oerjan> (Eq is for equality)
12:02:09 <crackers> yeah
12:02:14 <SamB> rretzbach: yeah!
12:02:20 <SamB> exactly
12:03:51 <rretzbach> I just regret, that I have only six hours per day to learn this language :>
12:05:24 <shapr> rretzbach: Why only six?
12:05:35 <rretzbach> From six til midnight.
12:06:01 <shachaf> @karma ++/
12:06:02 <lambdabot> ++/ has a karma of -2
12:06:11 <shachaf> ++/++ ++/++
12:06:12 <rretzbach> @karma c
12:06:12 <lambdabot> c has a karma of 15
12:06:17 <SamB> heh
12:06:18 <shachaf> @karma ++/
12:06:18 <lambdabot> ++/ has a karma of 0
12:06:25 <oerjan> @karma C
12:06:25 <lambdabot> C has a karma of 2
12:06:32 <SamB> I didn't realize it counted ++/ as a nick
12:06:33 <rretzbach> @karma i
12:06:33 <lambdabot> i has a karma of 0
12:06:38 <SamB> @karma c
12:06:38 <lambdabot> c has a karma of 15
12:07:17 <SamB> are they so low because karma got reset, or because we talk about C-- as well?
12:07:37 <shachaf> @karma c
12:07:38 <lambdabot> c has a karma of 15
12:07:38 <shachaf> c++
12:07:40 <shachaf> @karma c
12:07:40 <lambdabot> c has a karma of 15
12:07:48 <sjanssen> SamB: C is special cased
12:07:53 <shachaf> SamB: I this C is a special case.
12:07:56 <SamB> oh. it's special case.
12:07:59 <shachaf> s/this/think/
12:08:02 <SamB> @karma C
12:08:02 <lambdabot> C has a karma of 2
12:08:11 <SamB> @karma+ C
12:08:11 <lambdabot> C's karma raised to 3.
12:08:12 <SamB> @karma C
12:08:12 <lambdabot> C has a karma of 3
12:08:15 <SamB> oops
12:08:16 <SamB> ;-)
12:08:40 <rretzbach> c++++
12:08:41 <SamB> I guess those are from people explicitly using @karma+/@karma-?
12:08:45 <rretzbach> @karma c++
12:08:45 <lambdabot> c++ has a karma of -5
12:08:48 <sjanssen> SamB: correct
12:08:48 <SamB> heh
12:08:51 <rretzbach> not bad
12:09:00 <SamB> I suppose I did the special-casing myself?
12:09:07 * sjanssen did it
12:09:10 <SamB> oh.
12:09:16 <SamB> I wonder why I didn't do it.
12:09:18 <sjanssen> at least in the current incarnation
12:09:37 <sjanssen> I rewrote it at some point -- but it might have been special cased before that too
12:09:47 <SamB> ah ;-).
12:10:34 <SamB> okay, anyway, who thinks I should use Haskell for my PDP-1 emulator?
12:11:03 <Syzygy-> Aye!
12:11:44 <Syzygy-> @karma c++
12:11:45 <lambdabot> c++ has a karma of -5
12:11:49 <Syzygy-> c++++
12:11:51 <Syzygy-> @karma c++
12:11:52 <lambdabot> c++ has a karma of -4
12:11:56 <Syzygy-> c++--
12:11:58 <Syzygy-> @karma c++
12:11:59 <lambdabot> c++ has a karma of -5
12:11:59 <sjanssen> SamB: use Harpy to make a JIT compiler
12:12:14 <Syzygy-> Hah. Lookitthat. The bug I hit was relevant for more things!
12:12:15 <SamB> advantages are: lovely goto, I've already written PDP-1 arithmatic for it, and said PDP-1 arithmatic actually works
12:12:18 <rretzbach> But does c++-- change the karma of c as well?
12:12:26 <Syzygy-> rretzbach: It just did.
12:12:35 <rretzbach> How do you know?
12:12:38 <sjanssen> rretzbach: no, it doesn't change the karma of c
12:12:39 <SamB> disadvantages are: a history of being slow for bytecode-type interpreters
12:12:43 <Syzygy-> Oh.
12:12:45 <Syzygy-> For c
12:12:48 <Syzygy-> No, I don't know.
12:12:52 <Syzygy-> @karma c
12:12:52 <lambdabot> c has a karma of 15
12:12:56 <Syzygy-> c++++
12:12:59 <Syzygy-> @karma c
12:12:59 <lambdabot> c has a karma of 15
12:13:00 <rretzbach> Nice.
12:13:00 <Syzygy-> @karma c++
12:13:01 <lambdabot> c++ has a karma of -5
12:13:07 <rretzbach> Well done!
12:13:13 <sjanssen> SamB: Haskell might be fast enough to emulate a PDP-1?
12:13:28 <SamB> sjanssen: yes. the thought had occured to me
12:13:36 <SamB> the instruction cycle is what, 5 ms?
12:14:11 * SamB tried to write pdp-1 arithmatic in C++, but it just doesn't work right for no obvious reason
12:14:18 * SamB thinks this is typical of C++
12:15:17 <sjanssen> SamB: you could probably implement it very naively and achieve acceptable performance
12:15:47 <SamB> some disadvantages, though, are that *I*, for one, lack a debugger
12:15:57 <Syzygy-> For PDP-1 or for Haskell?
12:16:01 <SamB> Haskell
12:16:13 <SamB> I think I could find a copy of the PDP-1 trace program
12:17:33 <SamB> granted, it would be hard to write a general debugger for Haskell...
12:19:05 * sorear has a haskell debugger
12:19:22 <SamB> sorear: how does it work?
12:19:28 <br1> I can't find 'response' in HAppS's API docs.
12:19:36 <sorear> SamB: Breakpoints
12:21:51 <br1> Well, I could but not where I expected it.
12:26:33 <fasta> Meh, why is that you always know how to write a program after is is done?
12:26:41 <fasta> it*
12:26:49 <edward1> gah, i feel dirty
12:27:22 <fasta> Can the GHC debugger when it's done, change variable bindings?
12:27:28 <fasta> While it's running, I mean.
12:27:41 <edward1> had to generate a date range in sql, but didn't have write access to the database, resorted to flipping bits from unions.
12:28:13 <rretzbach> edward1: Are you a mean hacker?
12:28:20 <edward1> select a.e*4+b.e*2+c.e+1 as month, d.e+2007 as year from (select 0 as e union select 1 union select 2) as a, (select 0 as e union select 1) as b, (select 0 as e union select 1) as c, (select 0 as e union select 1) as d order by year,month    *twitch, twitch*
12:28:57 <edward1> rretzbach: no idea, i just try to get things done ;)
12:30:13 <titusg> ?pl (\(n,x) ys -> (take n (repeat x)) ++ ys)
12:30:13 <lambdabot> uncurry (((++) .) . (. repeat) . take)
12:30:18 <edward1> that i think goes on record as the most pathetic thing i've ever written
12:33:00 <rretzbach> edwardk: Write a programm which generates such statements!
12:33:48 <flux> edwardk, using postgesql?
12:34:22 <olsner> > sequence [1,2,3] [5,6,7]
12:34:23 <lambdabot>   add an instance declaration for (Num ([t] -> a))
12:34:23 <lambdabot>     In the expression: 3
12:35:05 <olsner> @hoogle [a] -> [a] -> [[a]]
12:35:06 <lambdabot> No matches, try a more general search
12:35:18 <ari> > sequence [[1,2,3] [5,6,7]]
12:35:19 <lambdabot>  Couldn't match expected type `t -> m a'
12:35:23 <ari> > sequence [[1,2,3], [5,6,7]]
12:35:25 <lambdabot>  [[1,5],[1,6],[1,7],[2,5],[2,6],[2,7],[3,5],[3,6],[3,7]]
12:35:35 <olsner> yes! that's what I was looking for
12:35:36 <fasta> Is it possible to build a non-referential transparent Haskell debugger on top of ghci?
12:36:06 <olsner> so, n-ary cartesian product == sequence
12:36:31 <fasta> olsner: n-ary?
12:36:42 <edwardk> flux: microsoft sql server
12:36:54 <olsner> > sequence [[1,2],[3,4],[5,6]]
12:36:58 <lambdabot>  [[1,3,5],[1,3,6],[1,4,5],[1,4,6],[2,3,5],[2,3,6],[2,4,5],[2,4,6]]
12:37:06 <edwardk> flux: was needed inside of some random little reporting services report to work around the application =/
12:37:20 <rretzbach> sequence seems to be useful for permutations.
12:38:07 <flux> edwardk, well, it's not that bad.. I've had tables enumerating the years and months.
12:38:36 <olsner> fasta: yeah, cartesian product on an arbitrary number of sets.. although I guess it depends on the definition of cartesian products on more than 2 sets.. I could be mistaking terms here
12:38:53 <fasta> olsner: I didn't know that n-ary generalization.
12:38:58 <fasta> olsner: wikipedia explained.
12:40:09 <pastorn_> :type $
12:40:17 <pastorn_> ?type $
12:40:19 <lambdabot> parse error on input `$'
12:40:22 <SamB> fasta: haven't you heard of three-space?
12:40:24 <pastorn_> ?type ($)
12:40:26 <lambdabot> forall a b. (a -> b) -> a -> b
12:40:31 <pastorn_> ?type (.)
12:40:35 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
12:40:41 <fasta> SamB: no
12:41:07 <hpaste>  (anonymous) pasted "Wierd strictness in Arrow notation" at http://hpaste.org/421
12:41:11 <SamB> otherwise known as 3-dimensional space?
12:41:24 <fasta> SamB: heh, I do know that.
12:41:40 <SamB> what kind of coordinates do we like to use?
12:41:52 <sorear> fasta: The GHCI debugger is already !RT
12:41:55 <fasta> SamB: I already get your point.
12:42:04 <SamB> okay then ;-)
12:42:07 <fasta> sorear: !RT?
12:42:12 * SamB closes with a cube
12:42:21 <sorear> not referentially transparent...
12:42:21 <SamB> well, it's vertices
12:42:35 <SamB> > sequence (replicate 3 [-1,1])
12:42:37 <lambdabot>  [[-1,-1,-1],[-1,-1,1],[-1,1,-1],[-1,1,1],[1,-1,-1],[1,-1,1],[1,1,-1],[1,1,1]]
12:43:01 <rretzbach> Bah, that's very cool.
12:43:19 <edwardk> flux: we have those too, but not in this database ;)
12:43:24 <rretzbach> Is there an opengl lib?
12:43:45 <sorear> @where hopengl
12:43:46 <lambdabot> http://haskell.org/HOpenGL/
12:43:49 <ari> > replicateM 3 [0,1]
12:43:51 <lambdabot>  [[0,0,0],[0,0,1],[0,1,0],[0,1,1],[1,0,0],[1,0,1],[1,1,0],[1,1,1]]
12:43:51 <SamB> there is, but I don't think this n-ary cartesian product will help much with it ;-)
12:43:52 <rretzbach> Thank you.
12:44:09 <SamB> ari: oh, sweet
12:44:21 <sorear> rretzbach: Note that the web page is very out of date - when you want to start using it, you should go directly to the online API docs
12:44:28 <sorear> @docs Graphics.Rendering.OpenGL
12:44:28 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL.html
12:45:22 <olsner> :t replicateM
12:45:24 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
12:45:38 <edwardk> flux: the problem was more like how do i generate an row for each date in some interval of say 16 years when i'm not allowed to create a table ;)
12:45:58 <edwardk> at least breaking it down by bits makes the query size logarithmic in the timeframe
12:46:26 <shachaf> Hmm, is there a standard way to get the cartesian product of a Set?
12:46:32 <SamB> edwardk: ah. you needed to iterate!
12:46:46 <edwardk> yeah
12:47:17 <edwardk> and while there are rowset_functions in sql server, none of them build anything useful
12:47:20 <SamB> actually... did you?
12:47:23 <edwardk> at least by default
12:47:27 <SamB> what were the intervals?
12:47:55 * SamB supposes if you need to build rows for periods where nothing happened
12:47:58 <sorear> edwardk: check your channel, I don't see any messages from flux you could be replying to?
12:48:03 <SamB> ... that you really do need that...
12:48:07 <edwardk> well, in this case i needed a few years january to december to left join a report into so it could show periods that didn't have data
12:48:09 <olsner> I wonder how many iterations you need to binary-search a specific single- or double-precision float
12:48:32 <edwardk> sorear: his msg was about 10 minutes old
12:48:51 <SamB> edwardk: what do you think a nice way to do it would be?
12:49:00 <sorear> edwardk: ah, I see.  12:32 < flux> edwardk, using postgesql?
12:50:00 <edwardk> samb:  well, normally? i'd just give in and build a period dimension, its usually built for the data warehouse anyways. or i'd join a cheesy table of months with a cheesy table of years and get the cross product like a good little database 101 student
12:50:29 <olsner> like take a LP problem, rotate so that the goal function is one of the axis, binary-search for the best point that matches the conditions... it'd be a constant number of points (relative to the wanted precision) to check for inclusion in the search space
12:51:02 * SamB was thinking along the lines of [1..]
12:51:06 <edwardk> samb: but all of those require me to write to the database
12:52:40 <edwardk> samb: yeah. ideally? select month, year from [1..12] as month, [2007..2008] as year but then you need to figure out how to pun the table names, etc.
12:52:53 <edwardk> and it conflicts wiht the [ ] quotations
12:53:06 <SamB> that wasn't meant to be a proposed syntax
12:54:07 <byorgey> shachaf: you could use toList and fromList
12:56:15 <shachaf> byorgey: You could, but isn't there something better?
12:56:51 <byorgey> shachaf: not that I know of.  There might be.
12:56:53 <ttt-> how come haskell is so popular (this room at least)
12:57:04 <ttt-> i wouldnt think it is a very practical language
12:57:10 <ttt-> but im wrong probably
12:57:40 <Excedrin> what's impractical about it?
12:57:44 <olsner> of course it's popular *here* - this is the haskell channel!
12:57:49 <pastorn_> @paset
12:57:49 <lambdabot> Maybe you meant: part paste
12:57:52 <pastorn_> @paste
12:57:53 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:58:01 <sjanssen> ttt-: yep, you're wrong :)
12:58:10 <ttt-> it's in the freenode top10
12:58:30 <ttt-> being wrong is fun
12:58:38 <sjanssen> ttt-: #haskell is popular largely due to social and historical factors
12:58:39 <edwardk> ttt-: part of that is a good portion of the community actually lurks on channel ;)
12:58:43 <sjanssen> we're really nice here
12:58:53 <Excedrin> ttt-: why wouldn't you think of Haskell as a practical language?
12:58:58 <edwardk> yeah i came in with a question or two, and i just stayed
12:59:03 <sjanssen> and #haskell is The One True Channel for Haskell and the community
12:59:20 * Syzygy- blames sigfpe for getting stuck here.
12:59:21 <daniel_larsson> @users
12:59:21 <lambdabot> Maximum users seen in #haskell: 354, currently: 347 (98.0%), active: 18 (5.2%)
12:59:34 <edwardk> @seen sigfpe
12:59:35 <lambdabot> I haven't seen sigfpe.
12:59:40 <edwardk> @seen dpiponi
12:59:40 <lambdabot> I saw dpiponi leaving #haskell 20h 17m 2s ago, and .
12:59:41 <sorear> @seen dpiponi
12:59:41 <lambdabot> I saw dpiponi leaving #haskell 20h 17m 3s ago, and .
12:59:54 <SamB> I never don't get this "and ." bussiness
12:59:56 <byorgey> and .
13:00:34 <rretzbach> byorgey: lol
13:01:09 <byorgey> looks like some lazy (the bad kind) coding to me
13:01:47 * byorgey goes off to examine lambdabot's source
13:01:52 <olsner> :t (and .)
13:01:56 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
13:02:20 <sjanssen> :)
13:02:48 <olsner> @type (and .)
13:02:48 <olsner> > (and .)
13:02:48 <olsner> lambdabot--
13:02:51 <lambdabot>  Add a type signature
13:02:52 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
13:03:36 <SamB> ... is #haskell in the top 10?
13:03:38 <edwardk> @tell dpiponi the old initial/terminal algebra introduction on your mac.com homepage has an error in it. your patterns don't jump back to the longest prefix state that is a suffix. i.e. it fails to find "cat" in "ccat" and "cacat". nice explanation otherwise. just realized who you were ;)
13:03:39 <lambdabot> Consider it noted.
13:03:59 <SamB> I think it's in the top 20
13:05:46 <ndm> @seen Binkley
13:05:46 <lambdabot> I saw Binkley leaving #haskell-blah and #haskell 19h 23m 17s ago, and .
13:06:00 <ndm> @seen catamorphism
13:06:00 <lambdabot> I haven't seen catamorphism.
13:06:05 <sjanssen> SamB: #14 right now
13:06:14 <ndm> @seen anyone_who_can_use_the_ghc_api
13:06:14 <lambdabot> I haven't seen anyone_who_can_use_the_ghc_api.
13:06:23 <Syzygy-> Hehe
13:07:06 <ndm> sjanssen, Yhc can compile stackset.hs after my patch, so you can close the bug
13:07:12 <SamB> so... what sort of UI should my PDP-1 emulator have...
13:07:29 <ndm> does anyone have any experience with the GHC API?
13:07:31 <edwardk> punch cards? teletype? =)
13:07:44 <ndm> SamB, Gtk2hs, with a console version
13:07:46 <SamB> hmm.
13:07:53 * byorgey has about a half hour of experience with the GHC API, as of today
13:08:04 <SamB> you like to make things easy, don't you, ndm ;-)
13:08:34 <ndm> byorgey, i want to load a file, which may be a filename, or open a module out of a package
13:08:53 <ndm> i can just about load the filename...
13:09:20 <byorgey> ndm: I can load a file given a filename, but I don't know how to do anything with packages
13:12:29 <ndm> byorgey, how do i move from a file to a Module name?
13:12:39 <ndm> specifically:
13:12:40 <ndm> target <- guessTarget file Nothing
13:12:46 <ndm> mod <- findModule s (mkModuleName "Main") Nothing
13:12:54 <ndm> setContext s [] [mod]
13:13:13 <ndm> how do i make it so that findModule finds the one that got loaded by target?
13:15:49 <byorgey> ndm, I'm not sure
13:16:36 <rretzbach> hmm, I think I didn't understand any of this http://en.wikibooks.org/wiki/Haskell/Pattern_matching
13:16:59 <byorgey> ndm, you did do a call to addTarget right?
13:17:10 <byorgey> rretzbach: what are you confused by?
13:18:16 <edwardk> why do we introduce pattern matching there with lists which are kind of a special case, and are recursive rather than something non-recursive like Maybe?
13:18:20 <rretzbach> That lookup, the | in list comprehension, the <-, the {}
13:19:55 <edwardk> > let Just x = lookup "bar" [("foo",1),("bar",2),("baz",3)]
13:19:56 <lambdabot>  Parse error
13:20:05 <edwardk> > let Just x = lookup "bar" [("foo",1),("bar",2),("baz",3)] in x
13:20:10 <lambdabot>  2
13:20:13 <edwardk> there
13:20:21 <edwardk> rretzbach: that lookup?
13:20:26 <rretzbach> Yes.
13:20:32 <edwardk> well, lets take it apart
13:20:36 <edwardk> what does lookup return?
13:20:38 <edwardk> @type lookup
13:20:40 <mauke>  > let Just x = lookup "a bird" [("foo",1),("bar",2),("baz",3)] in length [x,x]
13:20:41 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
13:21:24 <edwardk> so lookup is going to give us back a value of type Maybe b for whatever type b the second element in each of the pairs contained in our list was
13:21:26 <edwardk> @src Maybe
13:21:26 <lambdabot> data Maybe a = Nothing | Just a
13:21:33 * shapr boings happily
13:21:45 <shapr> I get paid to write Haskell! Life is good!
13:21:50 <byorgey> ndm, the wiki page was very helpful for me: http://haskell.org/haskellwiki/GHC/As_a_library
13:21:51 <lambdabot> Title: GHC/As a library - HaskellWiki
13:21:59 <byorgey> I don't know if you're looking at that
13:21:59 <edwardk> Maybes will be either Nothing, or Just something, in this case, we assume it will be a Just something, and so we tell it to assume that pattern
13:22:04 <edwardk> its equivalent to saying
13:22:14 <shapr> Even when I was writing Java, it was still better than making Subway sandwiches...
13:22:38 * shapr should be quiet when someone is teaching/learning :-)
13:22:39 <edwardk> > case lookup "bar" [("foo",1),("baz",2)] of Just x -> x; Nothing -> error "Uh, I screwed up"
13:22:40 <lambdabot>  Exception: Uh, I screwed up
13:23:02 <edwardk> > case lookup "bar" [("foo",1),("bar",2)] of Just x -> x; Nothing -> error "Uh, I screwed up"
13:23:03 <lambdabot>  2
13:23:27 <daniel_larsson> shapr: I tried talking to you in the silent channel :)
13:23:32 <shapr> oh!
13:24:48 <rretzbach> lookup "bar" ... is like hash["bar"] in some other languages, right?
13:25:02 <sjanssen> rretzbach: it's similar
13:25:03 <mauke> more like list.find("bar")
13:25:11 <rretzbach> But what does it have to do with pattern matching?
13:25:20 <mauke> nothing
13:25:28 <mauke> the return value does
13:25:51 <edwardk> the let expression just uses the fact that if there is only one pattern  we want to try to match we can get the answer from, there isn't much point in trying to tear it apart the hard way. i.e. let a = fst (1,2); b = snd (1,2) in .. this way you can say let (a,b) = (1,2) in ...
13:26:10 <edwardk> s/we can get the answer from//
13:27:15 <edwardk> rretzbach: the only relevance of lookup in that statement to pattern matching is that it returns a complicated value, that you need to pattern match to take apart
13:27:25 <edwardk> it returns a "Maybe Int" in this case, not an Int.
13:27:39 <edwardk> so you either get back "Nothing" or "Just n" for some n that is an integer
13:27:40 <fasta> sorear: can one redefine functions in that debugger? And is it feasible? I.e. what is the UI for defining new functions? An editor?
13:27:57 <rretzbach> okay, that I understand.
13:28:10 <rretzbach> Thank you for your patience.
13:28:16 <edwardk> no problem
13:29:20 <edwardk> you'll find that pattern matching is one feature you come to miss the most when you move back to other languages after a while in haskell
13:30:09 <rretzbach> Well if you ask me I wouldn't be able to tell you what "pattern matching" is about.
13:30:21 <rretzbach> I try.
13:30:28 <mauke> destructuring compound values
13:30:32 <rretzbach> It's about binding variables to values.
13:31:29 <edwardk> data types give you a way to define a data structure, like a linked list in other languages is represented by a pointer to a structure containing a value and another pointer. the fact that the pointer can be 'null' is implicit in most languages. in haskell, there is no implicit null.
13:31:40 <edwardk> so if you want a linked list you need to define something like
13:31:59 <edwardk> data MyList a = MyNode a (List a) | MyNull
13:32:13 <mauke> actually, you don't :-)
13:32:22 <fasta> Error
13:32:24 <rretzbach> mauke: Please let him explain it to me.
13:32:37 <mauke> but detecting the end becomes a bit harder
13:32:42 <fasta> edwardk: List a is undefined
13:32:43 <edwardk> saying that if i have a 'list' its either the null list or its a node,
13:32:52 <edwardk> lukas: sure, you can have sentinels, etc.
13:32:59 <edwardk> but i meant just the sort of cs101 linked list ;)
13:33:24 <edwardk> lukas: and sentinels are harder to detect in haskell anyways since you have no pointer analysis tools ;)
13:33:31 <fasta> data MyList a = MyNode a (MyList a) | MyNull
13:33:33 <rretzbach> Am I the cs101?
13:33:34 <edwardk> without going to full fledged iorefs
13:33:36 <edwardk> er yeah
13:33:44 <edwardk> thats what i get for changing the example midsream
13:33:50 <edwardk> rretzbach: maybe =)
13:33:58 <rretzbach> :>
13:34:00 <edwardk> ok, so we have a list, we can now define values in it
13:34:21 <edwardk> so: MyNode 12 (MyNode 34 (MyNull)) gives me a list of two values and a null
13:34:27 <edwardk> so its 2 items long
13:34:33 <edwardk> but how do i take it apart?
13:34:37 <edwardk> thats where pattern matching comes in
13:34:57 <edwardk> length (MyNode x xs) = 1 + length xs; length MyNull = 0
13:35:19 <edwardk> defines a function that takes apart a "mylist" and figures out what its length is
13:35:53 <rretzbach> Yes.
13:35:56 <edwardk> it looks for the pattern of constructor and variable names on the left side of the equal sign.
13:37:01 <edwardk> otherwise we would be like people in c++ who have to define a half dozen member functions as boilerplate to be able to get at anything ;)
13:38:13 <edwardk> patterns basically give us an easy syntactic method to tear apart data, and they can be more complicated. if i wanted to tear apart my list and make sure it was in sorted order or something i could do
13:38:14 <rretzbach> Yes, I really like that _:_:[] matching.
13:39:09 <ndm> byorgey, yeah i did addToTraget, it all works, i just watned to get the module name automatically
13:39:22 <ndm> i've been using the wiki page as my primary reference
13:39:35 <edwardk> sorted MyNull = True; sorted (MyNode a MyNull) = True; sorted (MyNode a (MyNode b c) = a <= b && sorted (MyNode b c)
13:39:46 <edwardk> the latter introduces a good use for an @ in a pattern
13:40:01 <edwardk> notice we took apart (MyNode b c) then put it back together again
13:40:11 <edwardk> it might be nice to just keep a name for that node
13:40:40 <edwardk> sorted (MyNode a bc@(MyNode b _) = a <= b && sorted bc
13:40:51 <edwardk> using _ because we don't actually need 'c' any more =)
13:41:04 <rretzbach> That I do not understand.
13:41:10 <rretzbach> The @
13:41:15 <edwardk> did you understand the first version before the @?
13:41:31 <rretzbach> Yes.
13:41:47 <rretzbach> But I don't know how they can be compared.
13:42:25 <edwardk> sorted (MyNode a {-- --}(MyNode b c){-- --}) = a <= b && sorted {-- --}(MyNode b c){-- --}
13:42:41 <edwardk> notice that those things are identical in all things the two sections bracketed by {-- --}'s
13:43:03 <edwardk> compared using the <= you mean?
13:43:08 <rretzbach> Yes.
13:43:25 <edwardk> the <= is applied to the values in the list, not the lists themselves
13:43:44 <rretzbach> Okay.
13:44:09 <edwardk> a list is sorted if it is empty, the singleton list, or each element is less than or equal to the one after it, and the tail (starting at the element you compared the head of the list to) of the list is sorted
13:44:48 <rretzbach> Yes, I understood.
13:45:23 <byorgey> ndm: ah, now I understand your question.  yeah, I don't know how to do that.
13:45:26 <edwardk> so now, the @ lets us give a name to (MyNode b c) as a whole that way we don't have the pattern take it apart, and have to allocate a new node in memory just to figure out if we're sorted
13:45:50 <rretzbach> How is that @ called? at?
13:46:33 <edwardk> sorted (MyNode a bc@(MyNode b _) = ... binds 3 variables, a to the first item of the list, b to the item that is the second item in the list, and bc to the entire tail of the list from the second element on.
13:46:43 <edwardk> rretzbach: yeah
13:46:52 <rretzbach> Now it's cleat.
13:46:54 <rretzbach> clear
13:47:03 <edwardk> so, rewriting that with the builtin list sugar
13:47:04 <edwardk> we get
13:47:10 <rretzbach> So it's like (don't hurt me): select MyNode b _ as bc
13:47:46 <edwardk> sorted [] = True; sorted [x] = True; sorted a:bc@(b:_) = a <= b && sorted bc
13:48:01 <edwardk> which we should be able to test
13:48:04 <rretzbach> Yeah, very neat.
13:48:18 <rretzbach> You are good at explanation.
13:48:32 <edwardk> > let sorted [] = True; sorted [x] = True; sorted a:bc@(b:_) = a <= b && sorted bc in sorted [1,3,4,2]
13:48:33 <lambdabot>  Parse error in pattern
13:48:40 <edwardk> er i suck =)
13:48:51 <edwardk> > let sorted [] = True; sorted [x] = True; sorted (a:bc@(b:_)) = a <= b && sorted bc in sorted [1,3,4,2]
13:48:53 <lambdabot>  False
13:48:57 <rretzbach> Then I am such a wonderful student.
13:49:09 <edwardk> > let sorted [] = True; sorted [x] = True; sorted (a:bc@(b:_)) = a <= b && sorted bc in sorted [1,2,4,5]
13:49:11 <lambdabot>  True
13:49:18 <edwardk> i meant that i sucked because i didn't make that line compile ;)
13:49:51 <rretzbach> I understood that, but made it into a joke.
13:50:13 <rretzbach> a <= b && sorted bc is like if a <=b then sorted bc without an else
13:50:26 <edwardk> not quite
13:50:41 <edwardk> its like if a <= b && sorted bc then True else False
13:50:49 <edwardk> && is and
13:50:55 <rretzbach> Ahh okay.
13:51:07 <rretzbach> Well :> && is not and, I learned that today.
13:51:26 <edwardk> technically its conditional and with short circuiting ;)
13:51:41 <edwardk> since it doesn't commute
13:52:40 <rretzbach> catMaybes ms = [ x | Just x <- ms ] -- can you please explain this to me too, then I will stop asking for today :)
13:53:26 <mauke> oh, that uses a special trick
13:53:52 <mauke> do you know list comprehensions in general?
13:55:00 <rretzbach> No.
13:55:29 <mauke> simplified version: [ expr | var <- list ]
13:55:30 <rretzbach> i know that after a | you can pattern match
13:55:37 <mauke> read <- as "drawn from"
13:55:40 <rretzbach> but that <- I don't get.
13:55:43 <rretzbach> Aha.
13:55:44 <Saizan> > [ x+1 | x <- [1..10]]
13:55:45 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
13:56:09 <mauke> > [ x * 2 | x <- [5 .. 11]]
13:56:11 <lambdabot>  [10,12,14,16,18,20,22]
13:56:42 <mauke> the thing before <- is a pattern. a pattern consisting of a simple variable always matches.
13:57:09 <mauke> but if the pattern fails, it simply skips that element and goes on to the next
13:57:47 <mauke> > [ "what" | 5 <- [1 .. 10] ]
13:57:50 <lambdabot>  ["what"]
13:58:03 <mauke> that's probably a stupid example but whatever
13:58:17 <opqdonut> no, it's actually quite a nice one
13:58:26 <mauke> this code iterates over the numbers from 1 to 10, matching each one against 5
13:58:37 <opqdonut> > [0| 5+n <- [1 .. 10]]
13:58:37 <lambdabot>  Parse error in pattern
13:58:42 <opqdonut> > [0| (5+n) <- [1 .. 10]]
13:58:43 <lambdabot>  Parse error in pattern
13:58:48 <Saizan> n+5
13:58:50 <opqdonut> :( n+k patterns fail
13:58:52 <mauke> most of the numbers are not 5 and ignored, but one of them succeeds
13:58:58 <opqdonut> > [0| (n+5) <- [1 .. 10]]
13:58:58 <lambdabot>  Parse error in pattern
13:59:02 <opqdonut> no luck
13:59:09 <rretzbach> mauke: Aha!
13:59:11 <opqdonut> > [ 0 | (n+5) <- [1 .. 10] ]
13:59:11 <lambdabot>  Parse error in pattern
13:59:14 <opqdonut> nope
13:59:20 <mauke> that's why there's a single "what" in the result list
13:59:23 <Saizan> > let (n+5) = 1 in n
13:59:24 <lambdabot>  Parse error in pattern
13:59:45 <opqdonut> > let f (n+1) = n in f 1
13:59:46 <lambdabot>  Parse error in pattern
13:59:57 <rretzbach> mauke: What would be the output if I use [5,1..10] instead of [1..10]?
14:00:07 <mauke> > [5,1..10]
14:00:09 <lambdabot>  []
14:00:15 <mauke> that's an empty list :-)
14:00:17 <edwardk> rretzbach: back, one sec, missed your question
14:00:19 <opqdonut> 5:[1..10]
14:00:23 <opqdonut> > 5:[1..10]
14:00:26 <lambdabot>  [5,1,2,3,4,5,6,7,8,9,10]
14:00:29 <opqdonut> :)
14:00:29 <Saizan> > [ "what" | 5 <- [1 .. 10] ]
14:00:31 <lambdabot>  ["what"]
14:00:32 <mauke> > [ "what" | 5 <- 5 : [1 .. 10] ]
14:00:35 <lambdabot>  ["what","what"]
14:00:43 <rretzbach> okay, I guessed that.
14:01:19 <edwardk> list comprehensions are nice because you aren't limited to one thing to draw from
14:01:36 <edwardk> > [ (x,y) | x <- [1..3], y <- ['a'..'c'] ]
14:01:38 <lambdabot>  [(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
14:01:55 <rretzbach> So catMaybes ms = [ x | Just x <- ms ] -- ensures that I get a list of "not null" values, so only justs of maybes.
14:02:31 <edwardk> rretzbach: yeah and it removes the 'Just' tag as well, so you get a list of values not 'just values'
14:02:47 <edwardk> @type catMaybes
14:02:49 <lambdabot> forall a. [Maybe a] -> [a]
14:03:01 <edwardk> > catMaybes [Nothing, Just 12, Nothing, Just 34]
14:03:03 <lambdabot>  [12,34]
14:04:21 <Saizan> [ x | Just x <- ms] is desugared to concatMap (\x -> case x of Just x -> [x]; _ -> []) ms so things that don't match vanish
14:05:52 <rretzbach> That Maybe stuff is a bit unclear.
14:05:58 <rretzbach> Why does something like that exist?
14:06:17 <rretzbach> To warn you that some function returns nothing, I think.
14:06:37 <edwardk> rretzbach: well, it lets us explicitly know whether or not something can return 'null'
14:07:08 <edwardk> also, since you can 'nest' maybes and have a value of type Maybe (Maybe Int), then Nothing, Just Nothing and Just (Just 12) are distinct values
14:07:12 <rretzbach> And is Just a datatype?
14:07:20 <edwardk> @src Maybe
14:07:20 <lambdabot> data Maybe a = Nothing | Just a
14:07:27 <rretzbach> If so, 5 should be a Just too, right?
14:07:29 <mauke> no, Just is a constructor of Maybe
14:07:34 <edwardk> Just is a constructor in the Maybe data type
14:07:35 <rretzbach> Cause it's never null
14:08:03 <edwardk> well, actually 5 is a number, it has type 'Int' (to simplify things a bit)
14:08:11 <mauke> rretzbach: by the same reasoning 5 should be Nothing because it's never Just
14:08:33 <mauke> and 5 should be 1 because it's never 0
14:08:41 <edwardk> you can think of a Maybe as a list that never contains more than 1 element but may contain 0.
14:08:55 <edwardk> the 'null' analogy is starting to break down =)
14:09:40 <edwardk> you use 'Maybe something' when you need an extra value to indicate something went wrong.
14:09:53 <mauke> you can think of Maybe as a Bool where True also contains an extra value
14:14:33 <rretzbach> I've read it several times, but I don't get it fully.
14:15:09 <rretzbach> What can I read so that I understand what a Constructor is?
14:15:38 <mauke> in one direction, a constructor is a function that creates a value of some type
14:15:40 <emu> a constructor is a function which returns a value of the data type
14:15:56 <mauke> it's different from normal functions in that it can be used in patterns
14:16:10 <emu> for "de-construction"
14:16:32 <mauke> you can also think of constructors as tags
14:17:33 <mauke> data Value = VInt Int | VStr String | VNone
14:18:01 <mauke> a value of type Value is either a VInt, a VStr or a VNone
14:18:37 <rretzbach> So x :: Value; let x = 4 would be valid?
14:18:41 <mauke> if it's a VInt, it also stores an Int; if it's a VStr, it also stores a String
14:18:42 <mauke> no
14:18:53 <mauke> 4 is a constructor of Integer
14:19:14 <mauke> it's like data Integer = ... | -3 | -2 | -1 | 0 | 1 | 2 | 3 | ...
14:19:19 <mauke> (not actually valid code)
14:19:22 <rretzbach> Is VInt something I should know?
14:19:29 <emu> just an example
14:19:32 <mauke> no, I just defined it up there
14:19:38 <rretzbach> Okay, I thought so too.
14:19:50 <emu> rretzbach: the datatype defines a constructor function:   VInt :: Int -> Value
14:20:06 <emu> (VInt 4) :: Value
14:20:27 <emu> VInt 4 "constructs" a Value
14:20:36 <emu> as does VStr "a"
14:20:42 <emu> or just VNone
14:20:43 <rretzbach> mauke: What do you mean with "it also stores a String"?
14:20:48 <rretzbach> It stores two values?
14:21:12 <mauke> VStr "foo" stores two things, VStr and "foo"
14:21:13 <emu> let x = VInt 4 :: Value ; y = VStr "a" :: Value
14:21:29 <mauke> i.e. the information that it's a VStr (not VInt or VNone) and the actual data
14:21:32 <emu> x and y are both Values, with different constructors
14:21:53 <rretzbach> mauke: Aha!
14:22:18 <emu> Value is a disjoint type, aka sum or union type
14:22:25 <mauke> do you know C?
14:22:32 <rretzbach> A bit.
14:22:39 <mauke> this is like a type-safe union
14:22:47 <rretzbach> A lil bit.
14:23:26 <rretzbach> mauke: Can you please show a mini example how I would use Value?
14:24:06 <rretzbach> emu: I appreciate your help, i will read through your code when I am finished with mauke (lol). I can't read both of your text simultaneously.
14:24:31 <mauke> case v of VInt n -> putStrLn ("it's an int: " ++ show n); VStr s -> putStrLn ("it's a string: " ++ show s); VNone -> putStrLn "bzzt"
14:25:20 <dustin```> in 'class F a b | a -> b', what does the '| a->b' mean?
14:25:40 <mauke> dustin```: it's a functional dependency
14:25:47 <mauke> it means a uniquely determines b
14:26:14 <rretzbach> mauke: I think now I understand. that data is like a "preparation" so that I can "pattern match" better.
14:26:19 <mauke> so e.g. instance F Int Char; instance F Int Double; would be an error
14:30:20 <dustin```> mauke, I see, thanks!
14:31:04 <dustin```> mauke, the unique determination is always done via the first instance?
14:32:43 <mauke> huh?
14:32:50 <Saizan> dustin```: you'll get an error if you define both
14:35:46 <dustin```> Saizan, Right... so the association Int -> Char happens because someone instanced it that way.  Is there a way of forcing association without making an instance?
14:35:56 <dustin```> (referring to the example)
14:37:26 <fasta> Does loop = bar >> loop tail run in constant space?
14:38:07 <rretzbach> I think I have a good understanding of everythin on the pattern matching site now. Thank you very much mauke and emu! Good night.
14:38:15 <fasta> Hmm, I guess it depends on the monad.
14:38:19 <Saizan> dustin```: no, why would you want that?
14:38:28 <fasta> E.g. for State/ST/IO?
14:39:07 <Saizan> fasta: what's tail there?
14:40:00 <sorear> fasta: fix (bar >>)  in IO
14:40:07 <sorear> fasta: let x = bar >> x in x
14:40:27 <fasta> Saizan: that's a slip of the mind.
14:41:11 <sorear> fasta: let IO bar# = bar; x# st# = case bar# st# of { (# st2#, _ #) -> x# st2# } x in IO x#
14:41:15 <dustin```> Saizan, It was just a curiosity.
14:41:21 <fasta> sorear: but that loop doesn't run in constant space?
14:41:31 * DRMacIver waves
14:41:32 <fasta> sorear: I'd assume they are the same.
14:41:40 <fasta> sorear: the fix version and loop
14:41:46 <sorear> fasta: Sure it does. x# is in tail position and the case is strict.
14:41:59 <sorear> fasta: oh, fix was just for disambiguation :)
14:42:27 * SamB wonders how to render the PDP-1 front panel as a GUI
14:42:33 <dying_sphynx> sorry, but what # means?
14:42:52 <sorear> dying_sphynx: It's a letter.
14:42:59 <fasta> sorear: I found the tail-positions of Scheme to be very easy to understand.
14:43:09 <fasta> sorear: can I say the same cases hold also for Haskell?
14:43:25 <dying_sphynx> sorear, rather symbol :)
14:43:36 <fasta> sorear: I seem to recall lazyness adds more tail-positions.
14:43:46 <sorear> dying_sphynx: GHC considers it every bit the letter _ is...
14:44:08 <bos> is there a ghc 6.6.1 for debian yet?
14:44:32 <sorear> bostefan@stefans:/tmp$ dpkg -s ghc6 | grep Ver
14:44:32 <sorear> Version: 6.6.1-2
14:44:43 <fasta> bos: Unstable
14:44:51 <dying_sphynx> sorear, so it doesn't mean something special?
14:44:56 <Saizan> can you have bar in State such that fix (bar >>) terminates?
14:44:57 <sorear> dying_sphynx: Nope.
14:45:01 <bos> hmm. now all i need is enough debian fu to upgrade to it.
14:45:02 <GNU\caust1c> hi, can someone explain me, why removeduplicate doesnt work? http://gnulords.org/~caust1c/bla.hs
14:45:24 <mauke> delete (x xs) looks wrong
14:45:26 <SamB> so... http://www.ibiblio.org/pub/academic/computer-science/history/Incoming/pdp1.handbook/PDP-1_Control_Panel.gif is a picture of the front panel of a PDP-1..
14:45:27 <dying_sphynx> sorear, but it is sometimes used with references or smt?
14:45:28 <lambdabot> http://tinyurl.com/2qscw6
14:45:33 <mauke> you probably want delete x xs
14:45:38 <SamB> how should I render all those little toggle switches?
14:45:38 <sorear> GNU\caust1c: Bad parenthetisation
14:45:47 <SamB> or the lights?
14:45:48 <dying_sphynx> sorear, I saw in code of UM, for example
14:45:55 <sorear> GNU\caust1c: Parens *always* go on the *outside* of the function name
14:45:59 <Igloo> bos: Put   APT::Default-Release "stable";   in /etc/apt/apt.conf, add unstable lines to /etc/apt/sources.list, apt-get update, apt-get install ghc6 -t unstable
14:46:01 <sorear> (delete x xs)
14:46:05 <GNU\caust1c> thx, that was it ;D
14:46:10 <bos> Igloo: thanks
14:46:15 <GNU\caust1c> ok, thx :)
14:46:23 <Igloo> (assuming "stable" is right)
14:46:33 <sorear> GNU\caust1c: or just use "import List" "removedumplicated = nub"
14:46:44 <Igloo> bos: I don't know off-hand if ghc6 will pull in scary things like a newer version of libc6, though
14:46:53 <fnord123> sorear: im reading logs where you recommended someone use newpopen to call uuidgen externally instead of devise some bindings to libuuid.
14:46:54 <bos> ok, thanks
14:46:56 <Igloo> bos: At some point I'll hopefully get around to doing stable backports
14:47:00 <sorear> Igloo: Is there anything that *doesn't*? :)
14:47:20 <sorear> fnord123: There's a libuuid?
14:47:20 <fnord123> Is that they way forward? i think it would make distrobution to crappy platforms like windows more difficult
14:47:21 <GNU\caust1c> im trying to implement those functions to learn, i know that theres prelude ;D
14:47:25 <bos> Igloo++
14:47:34 <fnord123> sorear: i dont know. in the logs, dons was on about it
14:47:51 <sorear> fnord123: I thought this person was going to implement the whole acquisition process themself!
14:48:53 <fnord123> http://tuukka.iki.fi/tmp/haskell-2007-05-04.html @around 5:50
14:48:55 <lambdabot> Title: haskell-2007-05-04
14:49:14 <sorear> fnord123: I remember
14:49:25 <fnord123> for the benefit of lurkers :)
14:50:59 <SamB> hmm. how will I update the GUI with what should appear on the control panel?
14:53:16 <sorear> fnord123: By all means bind to libuuid, now that I know it exists.
14:53:44 <fasta> sorear: can you have bar in State such that fix (bar >>) terminates?
14:54:19 <LoganCapaldo> bar = undefined?
14:54:20 <sorear> fasta: No, because State has kind * -> * -> * and only types of kind * are inhabited.
14:54:34 <sorear> Therefore you cannot have bar in State.
14:54:46 * sorear doesn't understand
14:55:10 <mauke> sorear: s/State/State a b/
14:56:41 <Saizan> sorear: bar :: State a b for some a and b
14:57:10 <sorear> There are no terms of type State a b except return undefined, undefined, and repeatM (return ())
14:57:28 <sorear> oh, existential!
14:57:48 <sorear> well, there's error
14:58:14 <mauke> '_a '_b state (* using OCaml syntax *)
14:59:34 <sorear> fasta: Certainly.  For all a :: *, b :: *, x :: State a b, fix (x>>) is not _|_
15:00:00 <SamB> so... would a fairly literal rendition of the PDP-1 control panel as a gui would be a good idea?
15:00:10 <Saizan> sorear: but can you get a contructor by running it?
15:02:07 <Saizan> > runState (fix (>> put 1)) undefined -- i think you can only do that with a right section
15:02:09 <lambdabot>  ((),1)
15:03:52 * SamB ponders how he'd update his UI only once in a while when the emulated PDP-1 is running free, but every cycle (instruction?) when it's in single-step mode...
15:05:14 <Saizan> SamB: callbacks/continuations?
15:07:46 <ihope> Hmm, so is http://okmij.org/ftp/ Oleg's stuff?
15:07:47 <lambdabot> Title: This FTP site
15:07:54 <Heffalump> yes
15:07:59 <SamB> yes, that ftp site is oleg's stuff
15:10:04 <ihope> All of it?
15:11:10 <dmhouse> Yes; that's Oleg's site.
15:15:04 <ari_> @poll-add take_fail_out_of_Monad
15:15:04 <lambdabot> Added new poll: "take_fail_out_of_Monad"
15:15:25 <ari_> @choice-add take_fail_out_of_Monad yes
15:15:25 <lambdabot> New candidate "yes", added to poll "take_fail_out_of_Monad".
15:15:27 <ari_> @choice-add take_fail_out_of_Monad no
15:15:27 <lambdabot> New candidate "no", added to poll "take_fail_out_of_Monad".
15:15:40 <dmhouse> How does one vote?
15:16:55 <ari_> @help vote
15:16:55 <lambdabot> vote <poll> <choice>        Vote for <choice> in <poll>
15:16:55 <dibblego> can you add a comment :: String section?
15:16:55 <dmhouse> ?vote take_fail_out_of_Monad yes
15:16:55 <lambdabot> voted on "yes"
15:16:55 <ari_> @poll-add bring_back_Eval
15:16:55 <lambdabot> Added new poll: "bring_back_Eval"
15:16:55 <ari_> @choice-add bring_back_Eval yes
15:16:55 <lambdabot> New candidate "yes", added to poll "bring_back_Eval".
15:16:55 <dmhouse> dibblego: what do you mean?
15:16:55 <ari_> @choice-add bring_back_Eval no
15:16:55 <lambdabot> New candidate "no", added to poll "bring_back_Eval".
15:17:00 <Saizan> what's Eval?
15:17:04 <sorear> ?vote bring_back_Eval yes
15:17:04 <lambdabot> voted on "yes"
15:17:07 <Saizan> ah, for seq?
15:17:15 <sorear> ?vote take_fail_out_of_XMonad yes
15:17:15 <lambdabot> No such poll:"take_fail_out_of_XMonad"
15:17:18 <sorear> ?vote take_fail_out_of_Monad yes
15:17:18 <lambdabot> voted on "yes"
15:17:20 <ari_> Saizan: yes
15:17:39 <mauke> ?vote take_fail_out_of_Monad yes
15:17:39 <lambdabot> voted on "yes"
15:17:41 <dibblego> dmhouse, "no" "because blah blah..."
15:17:45 <sorear> class Eval a where { seq :: a -> b -> b }
15:17:53 * ari_ is done bringing democracy to #haskell... for now
15:17:55 <sorear> Saizan: ^^^ close enough
15:17:57 <dmhouse> dibblego: oh, to the poll?
15:18:17 <sorear> instance Eval Int where { seq 0 = id ; seq _ = id }
15:18:18 <dibblego> dmhouse, right
15:18:49 <dmhouse> seq breaks parametricity, but there is the problem with having to add Eval contexts everywhere, once your program is finished, if you want to get strictness.
15:18:56 <Saizan> if you get fail out of Monad then you should also make Functor a superclass of Applicative and Applicative of Monad (where does Arrow fit?)
15:19:31 <dibblego> what is a good reason that forall. xs n < 0. drop xs n == xs instead of drop xs n == undefined?
15:20:16 <emu> dibblego: drop n xs?
15:20:34 <ihope> Anybody know what CC_2CPST is?
15:20:36 <dibblego> emu, sorry, you're right
15:20:42 * dibblego flips dibblego 
15:20:44 <sorear> dibblego: It's more often what you want.
15:20:45 <emu> um, so its total?
15:20:57 <sorear> ihope: Probably a time zone
15:21:00 <dmhouse> We need a Nat type.
15:21:05 <dmhouse> drop :: Nat -> [a] -> [a]
15:21:11 <dibblego> emu, it's being proposed on the Scala list because I found a bug in it and it doesn't feel right - and I'm not sure why
15:21:15 <emu> data Nat = O | S Nat
15:21:18 <sorear> dmhouse: Even that won't suffice!
15:21:21 <ihope> dmhouse: make one out of Integer?
15:21:27 <sorear> dmhouse: Consider drop 20 []
15:21:34 <ihope> Are you proposing dependent types?
15:22:17 <ihope> drop :: forall n :: Nat => Vector (n+20) a -> Vector n a
15:23:23 <ihope> Boo Goedel. He's the one who made all axiom systems for Turing machines incomplete.
15:23:41 <ihope> (Okay, he discovered that they were all incomplete. Close enough.)
15:23:58 <emu> stay regular
15:24:41 <mattam> I find drop 2 [x] = [] a relatively natural spec, but drop (-1) xs has not much sense has it ?
15:24:55 <emu> yea, it should prepend something to the front of the list!
15:25:21 <sorear> What?
15:25:22 <mauke> drop (-1) "bar" == "ba"
15:25:32 <emu> voodoo
15:25:56 <ihope> But is that the... natural way forward?
15:25:59 <ari_> drop (-1) should obviously figure out how the list is supposed to continue and extend it accordingly
15:26:02 <sorear> What's so magic about Z that we have to use it so much?
15:26:14 <LoganCapaldo> > drop (-1) "bar" -- this doesn't work for real does it?
15:26:15 <lambdabot>  "bar"
15:26:19 <LoganCapaldo> phew
15:26:22 <LoganCapaldo> I was scared
15:26:27 <ihope> sorear: the fact that it matches up with lists?
15:26:34 <dibblego> LoganCapaldo, were you expecting "barb" ? :)
15:26:47 <sorear> ihope: it *doesn't*, that's the whole point of this thread
15:26:57 <ihope> It doesn't?
15:26:59 <sorear> "barf" would make much more sense
15:27:02 <LoganCapaldo> dibblego: should I have been? :)
15:27:08 <mattam> i doesn't, list is 0 or S n
15:27:11 <ihope> ...Oh, you said Z.
15:27:22 <ihope> N matches up with lists.
15:27:48 <ihope> newtype Natural = Natural Integer
15:28:04 <mattam> ints are just the most natural numbers on todays computers :)
15:28:07 <ihope> (deriving Eq, Show, etc.)
15:29:04 <mattam> At least haskell has UInt32...
15:29:07 <ihope> Or maybe we should find a way to extend our current value system things and make it so that we can also have lists with half an element and such.
15:29:16 <ihope> Haskell has Word.
15:29:19 <sorear> mattam: Only if you define it!
15:29:24 <sorear> type UInt32 = Word32
15:29:27 <ihope> :-)
15:29:42 <mattam> Well, you don't have that in ocaml
15:29:49 <ihope> I want a list with iota elements!
15:29:51 * ihope pouts
15:30:02 <sorear> type word32 = uint32 (*muahaha!*)
15:30:04 <dustin```> hmm, a dense linear ordering?
15:30:30 <mattam> ihope: what is that ?
15:31:11 <ihope> The simplest surreal number greater than zero but less than all positive real numbers.
15:31:27 <Saizan> 1/omega ?
15:31:41 <vincenz> iota
15:31:48 <mattam> I mean a list with iota elements
15:31:50 <ihope> Yup, 1/omega.
15:32:11 <chessguy> 'ello
15:32:18 <ihope> Also known as epsilon, but that can also refer to two other numbers.
15:32:22 <ihope> Ello.
15:32:29 <vincenz> epsilon is much bigger than iota
15:33:01 <ihope> Epsilon is both a dual number and an ordinal number, and all ordinal numbers are surreal numbers.
15:33:26 <ihope> As an ordinal number, it's pretty big (and I prefer to call it epsilon_0), but as a dual number it's quite tiny.
15:33:58 <dibblego> what use cases make it clear that drop n xs [n < 0] == xs is the desired behaviour?
15:36:40 <LoganCapaldo> > drop 3 [1]
15:36:41 <lambdabot>  []
15:37:28 <vincenz> ihope: what is the ordinal number epsilon
15:37:37 <vincenz> and I meant epsilon as in .... delta-epsilon
15:37:40 <LoganCapaldo> I would guess the logic is take the value passed in and make sure it fits in the interval [0, length xs]
15:37:49 <vincenz> it's supposedly very small but feels much bigger than iota
15:38:38 <dibblego> isn't the State monad suitable for the "Reinvention" thread on Haskell-cafe?
15:38:48 <dibblego> by passing the String along as state
15:38:55 <ihope> The ordinal number epsilon, or epsilon_0, is essentially omega^^omega, or omega tetrated to the omega: it's the smallest ordinal number bigger than omega, omega^omega, omega^(omega^omega), omega^(omega^(omega^omega)), etc.
15:39:07 <ihope> What's delta-epsilon?
15:39:07 <Saizan> vincenz: do you mean the epsilon used for example while defining limit?
15:39:21 <monochrom> I would generalize it to [b] -> [(a,[b])] and call it the parser monad.
15:39:39 <sjanssen> dibblego: seems that way to me
15:39:58 <monochrom> The guy was doing parsing anyway.
15:39:59 <dibblego> sjanssen, I'm just wondering why nobody has mentioned it yet
15:40:21 <vincenz> Saizan: yp
15:40:22 <monochrom> I refrained from replying because I'm tired of that guy.
15:40:25 * sjanssen has started skipping his threadds
15:40:32 <sjanssen> threads, rather
15:40:58 <Saizan> vincenz: well, that's not a specific number, it's just a positive real
15:41:13 <vincenz> Saizan: well true, and it approaches iota from the positive side
15:41:16 <vincenz> hence always bigger :)
15:41:24 <sorear> That's interesting.
15:41:41 <sorear> Do the ordinals have the property that every set of them has a supremum?
15:41:56 <monochrom> Yes.
15:45:28 <ihope> Every set of them has a least ordinal number not in the set. :-)
15:45:54 <vincenz> 'ordinal number' = ?
15:46:41 <sorear> @wikipedia Ordinal number
15:46:43 <lambdabot> No Result Found.
15:46:53 <monochrom> perhaps "ordinals"
15:47:02 <Saizan> @wikipedia Ordinals
15:47:05 <lambdabot> No Result Found.
15:47:11 <sorear> monochrom: the plugin is broken
15:47:19 <crackers> @wikipedia cardinals
15:47:19 <sorear> http://en.wikipedia.org/wiki/Ordinal_number
15:47:20 <lambdabot> No Result Found.
15:47:20 <lambdabot> Title: Ordinal number - Wikipedia, the free encyclopedia
15:47:29 <monochrom> Oh well
15:48:00 <frobn> hi
15:48:22 <monochrom> I prefer http://www.cs.toronto.edu/~trebla/transfinite.txt because I wrote it. :)
15:48:24 <frobn> anyone here who knows frisby (well)?
15:48:55 <vincenz> frobn: "how to" frisby?
15:49:05 <crackers> my dog catches them sometimes
15:49:07 <frobn> you know, the PEG parser library
15:49:11 <ihope> vincenz: I think they can be pretty much entirely defined with just one property: for every set of ordinal numbers, there is a least ordinal number that is not in the set.
15:49:40 <vincenz> so it's a typeclass
15:49:42 <vincenz> not a type
15:49:48 <vincenz> for instance, integers are ordinal numbers
15:49:51 <ihope> The least ordinal number not in {}, which is of course the lowest of them all, is called 0. The least ordinal number not in {0} is called 1, the least ordinal number not in {0,1} is 2, etc.
15:50:14 <ihope> Can you give me a least integer that is not in the set of all integers?
15:50:17 <monochrom> I think I can make it a type.
15:50:22 <ihope> Or a least integer not in the empty set?
15:50:23 <vincenz> ihope: is that a valid set?
15:50:30 <DRMacIver> ihope: And they're minimal such that they have that property.
15:50:31 <ihope> Yes, there is a set of all integers.
15:50:41 <ihope> DRMacIver: hmm?
15:51:33 <sorear> vincenz: Sets in mathematics can be really, really big. :)
15:51:38 <vincenz> ihope: so there's a set of all ordinal numbers?
15:51:40 <vincenz> sorear: I know
15:51:48 <sorear> vincenz: No.
15:51:48 <vincenz> ihope: and if not, why not
15:51:54 <ihope> There is no set of all ordinal numbers. There are too many of them.
15:51:55 <sorear> vincenz: There are too many of them
15:52:09 <DRMacIver> ihope: You need some sort of induction principle for your ordinals, so you need them to be a minimal class closed under that property instead of just any class whatsoever.
15:52:11 <vincenz> that's rather vague
15:52:20 <ihope> If there were a set of all ordinal numbers, there'd be a least ordinal number that's not an ordinal number. :-)
15:52:26 <vincenz> are ordinal numberers a type or a typeclass?
15:52:30 <ihope> DRMacIver: minimal meaning what?
15:52:31 <crackers> exactly
15:52:38 <monochrom> There is no set containing all ordinal numbers. Suppose there were. Take its supremum. Get new ordinal not in the purported set of all ordinals.
15:52:39 <crackers> by the definition there's one that's not in the set
15:52:42 <DRMacIver> ihope: No proper subclass has that property.
15:52:44 <frobn> i have a specific problem/bug, it says "Text/Parsers/Frisby.hs:(479,4)-(532,49): Non-exhaustive patterns in function f" whenever I use the function getPos
15:52:53 <vincenz> ok
15:52:56 <vincenz> so iti's a definition
15:53:10 <ihope> DRMacIver: so there are multiple classes with that property?
15:53:10 <vincenz> aka, any class of Foo's x that follows that definition is ordinal numbers
15:53:12 <vincenz> is there any instance?
15:53:18 <sorear> vincenz: Another approach is to consider ordinals as sets of ordinals
15:53:28 <sorear> vincenz: {} is 0, {0} is 1, etc
15:53:34 <sorear> vincenz: {0,1,...} is omega
15:53:37 <DRMacIver> ihope: You could consider for example two copies of the ordinals, stuck end to end.
15:53:45 * vincenz nods at sorear 
15:53:55 <vincenz> sorear: so it's the extension of the |N line
15:53:59 <DRMacIver> ihope: This isn't isomorphic to the ordinals because it has initial segments which aren't sets.
15:54:02 <ihope> vincenz: okay then. The ordinal numbers are pretty much a type: they're the minimal type satisfying that property.
15:54:03 <sorear> vincenz: if there was a set of all ordinal numbers, you could construct a new ordinal as it.
15:54:09 <vincenz> ihope: oh
15:54:16 <vincenz> ihope: ok, well that clears some stuff up
15:54:27 <DRMacIver> Anyway, ordinals are better thought of as isomorphism classes of well ordered sets.
15:54:31 <sorear> vincenz: That's a paradox - another, somewhat more formal, form of Russel's
15:54:39 <vincenz> sorear: nod
15:54:56 <DRMacIver> (Although the von neumann ordinal construction *is* cool. :) )
15:55:05 <vincenz> of course the question is, who says there's always a supremum
15:55:16 <ihope> vincenz: that's the property, isn't it?
15:55:26 <frobn> hmm, seems i have to look somewhere else
15:55:40 <DRMacIver> ihope: Well, you need to show that there exists a class with the property you've described. :)
15:55:41 <ihope> Every set of ordinal numbers has a supremum by definition.
15:55:45 <ihope> Well, yes, you do.
15:55:53 <vincenz> ihope: I know, but one could potentially define a property that does not hold for any type, and hence you can't get a minimal type to fit it
15:55:58 <monochrom> If you construct ordinals from set theory, you always gets a supremum. If you axiomatize, you just add it as an axiom.
15:56:15 <monochrom> (But that's the blanket answer to all questions "who says ___")
15:56:19 <Saizan> frobn: that's either a bug in frisby or you're not supposed to call getPos with the argument you are passing it
15:56:51 <ihope> Isn't the existence of a class with that property the same as the consistence of that property with... something?
15:57:28 <frobn> Saizan: thanks, I suppose it's a bug, then, because it takes no arguments :(
15:57:37 <ihope> With ZFC, I suppose, with the domain for the property restricted.
15:58:05 <vincenz> monochrom: gotta be careful new axioms don't create contradictions
15:58:06 <ihope> "For all sets X, if X is an ordinal number, there exists a set Y such that Y is an ordinal number and . . ."
15:58:33 <ihope> If every element of X is an ordinal number, that is.
15:59:03 <monochrom> Care is needed. But that is not a legit objection to the axiomatic method.
15:59:20 <vincenz> No, I am not against the axiomatic method
15:59:29 <vincenz> but if for instance I said
15:59:47 <vincenz> Quiggly numbers are those numbers satisfying "A quigly number is not equal to itself" you might have an issue with that
16:00:10 <crackers> wouldn't that just result in an empty set?
16:00:11 <monochrom> Whenever I say "axiomatic" I assume that it is understood that care must be taken. There is no need to re-mention it and re-mention it again.
16:01:26 <vincenz> monochrom: by saying property X is axiomatic doens't necessarily make it so.  Given for someone new to ordinal nubmers, it might not be directly obvious that it can be added as axiom
16:01:39 <vincenz> Anyways
16:01:43 <vincenz> We're getting offtrack
16:02:00 <monochrom> axioms in math = specs (e.g. quickcheck properties) of haskell modules.  construction in math = internal code of haskell modules.
16:02:09 <vincenz> I know what axioms are
16:02:38 <monochrom> Someone needs to write the code and verify it. But most users never look at that; they just use the axioms.
16:02:50 <vincenz> monochrom: not all combinations of axioms work
16:02:56 <vincenz> you get contradictions
16:03:14 <monochrom> Why are you saying all these to me?
16:03:28 <crackers> still, with the quiggly example I don't see the contradiction
16:03:37 <crackers> all it means it there are no quiggly numbers
16:04:07 <vincenz> exactly
16:04:13 <vincenz> but somoene said there are ordinal numbers
16:04:18 <vincenz> and when I said how, they said it's an axiom
16:04:22 * vincenz shrugs
16:04:34 <monochrom> crackers may be interested in http://www.cs.utexas.edu/users/EWD/ewd09xx/EWD923a.PDF  :)
16:04:53 <vincenz> anywho
16:04:55 <vincenz> it's late, goodnight
16:05:27 <DRMacIver> Likewise. night
16:05:32 <monochrom> For the record, I did not say it is an unverified axiom.
16:05:34 <bgeron> night
16:07:59 <crackers> interesting
16:08:53 <monochrom> I hate to say to other people "what's your point". I think it's a rude way to ask what's their point. But I still don't get vincenz's point. We all know axioms are tricky to get right. What's his point?
16:09:16 <Saizan> the difference lies in the fact that we've supposed that you can show that there are no quiggly numbers using some set of implicit axioms, where instead the existence of ordinals was an open question
16:09:26 <crackers> yes
16:09:32 <crackers> he was confused about ordinal numbers
16:10:10 <monochrom> If he wants to know, "has anyone ever constructed something to verify this particular axiom", then I have already answer that too, in the same sentence in which I mentioned the axiomatic method.
16:10:41 <monochrom> Quoting myself, "If you construct ordinals from set theory, you always gets a supremum. If you axiomatize, you just add it as an axiom."
16:10:43 <Saizan> however a better response to vincenz could have been a demonstration of the utility of ordinals
16:10:47 <Cale> Unless you really want to get picky, I think it's safe to assume ZFC.
16:10:49 <vincenz> My point is simple
16:10:50 <vincenz> I asked
16:10:56 <vincenz> do those numbers exist
16:10:58 <vincenz> and you told me it's an axiom
16:11:00 <Cale> ZFC implies the existence of ordinals.
16:11:02 <vincenz> as if that would inform me
16:11:07 <monochrom> I even mentioned the construction first. Could you people read!
16:11:47 <Cale> vincenz: do which numbers exist?
16:11:49 <monochrom> I even put "if" there.
16:12:28 <vincenz> Imagine if you were curious as to how a computer worked, and you went to someone and said "why does it work that way" and they rplied "cause they built it that way".  Sure, it's correct, but it's 0% informative.
16:12:30 <Cale> vincenz: Normally as a matter of course in first-order logic, you introduce equality in such a way that x = x for any x.
16:12:32 <monochrom> I feel that vincenz is taking what I say out of context.
16:12:53 <vincenz> monochrom: I feel like you were continuing to target me after I my presupposed dissapearance.
16:12:59 <vincenz> s/I my/my
16:13:01 <Cale> vincenz: So, things which are not equal to themselves immediately become contradictions.
16:13:16 * vincenz nods
16:13:23 <monochrom> Yes I do. Because you were also targetting me on contradictions.
16:13:32 <Cale> vincenz: But of course, this is a choice you can make in a nonstandard way, if you really want.
16:13:48 <vincenz> monochrom: at least I was talking -to- you
16:13:56 <Cale> vincenz: What was the original question?
16:14:19 <Cale> vincenz: Whether there's a set of all ordinals?
16:14:31 <vincenz> Well it seemed 'ordinal numbers' seemed a typeclass, not a type.  So ihope said you could consider the 'type' to be the minimal type fitting that description.  At which point I wondered whethere they even existed.
16:14:43 <Cale> vincenz: The answer is that no, there isn't (at least in ZFC), because it contradicts well-foundedness.
16:15:53 <Cale> (which is an axiom that was introduced to make set theory set theory, and not some strange version of graph theory :)
16:16:14 <vincenz> yep, constructive view of sets
16:16:54 <Cale> Well, not necessarily constructive, it just excludes having sets like A = {B}, B = {A}, and so on.
16:17:52 <Cale> Basically, it says that any descending chain of 'element of' relations terminates.
16:18:02 <vincenz> yep
16:18:29 <Cale> (so yeah, there is an essence of constructiveness to it, but it certainly doesn't imply constructiveness)
16:19:06 <Saizan> you can still demonstrate the existence of some sets without showing how to contruct them, no?
16:19:27 <Cale> Saizan: yep
16:19:29 <crackers> such as the set of all integers
16:19:41 <Cale> The axiom of choice also hands you lots of sets like that.
16:19:45 <monochrom> This is only because some set axioms grants you that.
16:20:09 <Cale> I'm pro-(axiom of)-choice
16:20:52 <monochrom> The axiom of union says "forall A,B. there exists C containing both A and B". This saves you from constructing the union of A and B.
16:21:17 <monochrom> Actually if you remove the axiom of union, you probably can't construct the union anyway.
16:21:46 <sieni> well, people have strange thoughts about the meaning of the axiom of choice
16:21:56 <Saizan> if you could that probably wouldn't be an axiom
16:22:18 <monochrom> So even with ZF you already have existence without construction other than "this axiom says so".
16:22:56 <sieni> usually you need the axiom of choice for weirder constructions
16:22:59 <crackers> monochrom: the barber example isn't exactly Russell's paradox
16:23:39 <sieni> you don't (unsurprisingly) need that to prove the existence of, say, infinite sets
16:23:47 <matthew-_> oooooooooo. That was fun. Just got back from Haskell London Hug meet
16:23:59 <ihope> The axiom of infinity proves their existence. :-)
16:24:19 <sieni> ihope: exactly
16:24:59 <monochrom> crackers: it is still along the line of "no one satisfies this requirement, where is the paradox".
16:25:19 <sieni> the funniest one that I know of is that you need the axiom of choice or some milder form of it to prove that the union of a countable collection of countable sets is countable
16:25:19 <crackers> true
16:27:19 <crackers> the paradox is in a system that says the barber must exist
16:28:57 <Excedrin> hmm, isn't it easy to show how to construct the set of all integers?
16:29:08 <matthew-_> DRMacIver: pong
16:29:18 <crackers> yes, I spoke without thinking
16:33:54 <sorear> the axiom of choice is just a constant...
16:35:18 <Pseudonym> Yeah, but you can make it into a constant twice as big using only translations.
16:49:31 <tessier_> So now I understand quicksort and even the burrows-wheeler transform (but not the inverse) in haskell...one day at a time...
16:51:24 <Pseudonym> If you understand the BWT, then you're doing well.
16:51:27 <Pseudonym> It's a very subtle transform.
16:51:47 <tessier_> It's only a few lines of haskell. :)
16:52:01 <Pseudonym> I mean how the BWT actually works.
16:52:05 <Pseudonym> Not how to do it. :-)
16:52:16 <tessier_> BWT is amazing. zip has been around for years but bwt wasn't discovered until 1994. Relatively recent.
16:52:38 <tessier_> I've done bwt on paper. It make sense. It's a neat trick.
16:53:13 <Pseudonym> There's a wonderful paper, which I don't have a cite for, which shows how the BWT, Lempel-Ziv methods and PPM methods are all mathematically the "same".
16:53:23 <Pseudonym> They differ only in constant factors.
16:53:33 <tessier_> What is PPM?
16:53:37 <Pseudonym> Mind you, constant factors are REALLY important here.
16:53:46 <Pseudonym> PPM is the best known lossless text compression algorithm.
16:53:50 <Pseudonym> Prediction by Partial Matching.
16:53:54 <tessier_> Indeed. Because in the end it's the size of the result that matters.
16:54:02 <tessier_> ah...not familiar with that one.
16:54:03 <Pseudonym> bzip2 gets within about 5% of PPM, at a tiny fraction of the cost.
16:54:07 <Pseudonym> Oh, DMC too.
16:54:13 <Pseudonym> But it's easy to see how DMC and PPM are similar.
16:54:50 <Pseudonym> Alistair Moffat was one of my lecturers at uni.
16:54:58 <Pseudonym> So I know ALL about this stuff.
16:58:21 <crackers> that's pretty cool
16:59:53 <jre2> oh man, I just say the NY Functional Programmers meetup for *today*
17:00:20 <monochrom> Will you make it?
17:00:56 <jre2> don't think so
17:00:59 <jre2> it's 8pm here
17:02:19 <shapr> Yay, author of lambdabot!
17:03:26 <Pseudonym> We are all authors of lambdabot.
17:03:30 <Pseudonym> Anyone who submits a patch.
17:03:41 <Pseudonym> I'm not even the benevolent dictator any more!
17:03:42 <shapr> Yeah, but who's REALLY to blame here?
17:03:48 <Pseudonym> dons
17:03:51 <shapr> I mean, who got this whole ball of YOW started?
17:03:58 <Pseudonym> dons
17:04:00 <Pseudonym> Really, it's dons.
17:04:12 <shapr> HAH, you can deny it all you want, but WE KNOW THE TRUTH!
17:04:14 <Pseudonym> I just wanted to work out how to mix multithreading and networks.
17:04:19 <shapr> And look where that got you!
17:04:28 <Pseudonym> Blamed for everything?
17:04:31 <shapr> Exactly!
17:05:53 <fnord123> Hm, Parsec seems a bit of an overkill for escaping ' characters in strings. Does anyone happen to know a simpler way?
17:06:30 <Pseudonym> escString (c:cs)
17:06:54 <Pseudonym>     | c `elem` "\\'" = '\\' : c : escString cs
17:07:01 <Pseudonym>     | otherwise = c : escString cs
17:07:06 <Pseudonym> escString [] = []
17:07:09 <Pseudonym> Something like that?
17:07:13 <fnord123> yes
17:07:18 <sorear> =<<
17:07:29 <Pseudonym> Or =<<, yes.
17:07:33 <Pseudonym> or even >>=
17:08:02 <Pseudonym> > "hello'world\\woo" >>= if c `elem` "\\'" then ['\\',c] else [c]
17:08:10 <lambdabot>   Not in scope: `c'
17:08:13 <Pseudonym> Err.
17:08:18 <Pseudonym> > "hello'world\\woo" >>= \c -> if c `elem` "\\'" then ['\\',c] else [c]
17:08:20 <lambdabot>  "hello\\'world\\\\woo"
17:08:22 <Pseudonym> Yeah, that.
17:09:58 <fnord123> why are you using 2 \, out of interest?
17:10:18 <Pseudonym> You need to escape backslashes inside strings.
17:10:20 <Pseudonym> Or chars.
17:10:31 <Pseudonym> It's the bane of every DOS programmer.
17:10:39 <Pseudonym> "C:\\Foo\\Bar\\"
17:10:47 <fnord123> DOS?
17:10:53 * Pseudonym is old
17:12:40 <fnord123> hm im wondering if i need to escape the \ as well as the '.
17:13:10 <Pseudonym> That's why I put that in.
17:13:22 <fnord123> i do.. thanks. that would have been bad. :)
17:14:35 <Pseudonym> I don'
17:14:55 <Pseudonym> I wouldn't use `elem` for this in real code, but it helps to save space in IRC.
17:15:34 <jatqceer> What is the best way to read floating point number separated by '\n' from stdin?  I've tried getContents and lines and map read to get [Double], but it seems very slow.
17:16:06 <Pseudonym> I'd do pretty much what you've done, only with Data.ByteString.
17:16:12 <Pseudonym> (The lazy version, probably.)
17:16:19 <monochrom> try "readLn"
17:16:34 <monochrom> But I don't know about speed.
17:16:48 <dcoutts> Pseudonym: sadly we don't have a double parsing function for ByteString(.Lazy)
17:17:07 <dcoutts> as jatqceer previously noted
17:17:11 <jatqceer> if I use Data.ByteString, I still have to unpack it to string and read double out of it, it turns out slower.
17:17:17 <Pseudonym> You can convert it to a String just before reading.
17:17:22 <Pseudonym> You do less work overall.
17:17:24 <dons> call C to read the Double
17:17:40 <Pseudonym> @remember dons call C [...]
17:17:41 <lambdabot> Done.
17:17:48 <jatqceer> call C?
17:18:02 <dons> map atof . lines =<< Lazy.getContents ?
17:19:18 <jatqceer> I came up with a recursion of readLn, that gains 10% speed
17:19:29 <jatqceer> dons: I'll try yours
17:22:16 <jatqceer> dons: I don't think I know how to use atof
17:22:44 <jatqceer> Pseudonym: I don't understand
17:22:50 <emu> strtod!
17:23:07 <monochrom> It's a C function. FFI ...
17:23:23 <emu> i coded FFI to strtoul recently, and it worked in examples, but not when compiled on large tests :/
17:26:08 <sorear> dcoutts: Any reason to have readInt et al on Data.ByteString rather than D.B.Get?
17:27:57 <dcoutts> sorear: because they have nothing to do with reading binary formats?
17:29:09 <dons> main   = S.getContents >>= print . sum . map atof . S.lines
17:29:09 <dons> atof s = unsafePerformIO $ unsafeUseAsCString s $ c_atof
17:29:10 <dons> foreign import ccall unsafe "stdlib.h atof" c_atof :: CString -> IO Double
17:29:12 <dons> something like that
17:29:27 <dons> $ ./a.out
17:29:28 <dons> 1
17:29:28 <dons> 2
17:29:28 <dons> 3
17:29:28 <dons> 6.0
17:29:46 <dons> might be a bit evil about expecting \0 at the end of the bytestring, btw.
17:29:57 <emu> strtod will give you a ptr to the string after the double
17:30:13 <emu> faster than S.lines i imagine
17:30:22 <dons> yeah
17:30:24 <dons> good idea.
17:30:44 <dons> then you just unfoldr over the bytestring
17:30:44 <emu> but my version of it segved on large inputs :/
17:30:54 <dons> why?
17:30:56 <emu> no idea
17:31:03 <dons> C is hard :}
17:31:23 <dons> jatqceer: that give you some ideas?
17:31:32 <gravity> heh
17:32:45 <emu> hm. looking at this again, i'm thinking it might not be handling termination right
17:33:13 <sorear> dons: You're violating the precondition on unsafeUseAsCString
17:33:17 <dons> i am.
17:33:23 <sorear> dons: Not that it makes a difference :)
17:33:53 <sorear> Well, I suppose you could get a segfault if the file didn't end with a newline (shootouts are fun)
17:34:00 <dons> you could.
17:34:18 <jatqceer> dons: yeah, thanks.  Are we sure there's always \0 waiting for us?
17:34:38 <dons> jatqceer: no, you can `snoc` one on, or use 'useAsCString'
17:34:53 <dons> to really zip it along though, use strtod, and avoid `lines'
17:34:54 <sorear> jatqceer: strtod will accept \012 just as well, and lines end with those...
17:35:32 <dons> we should create a small module of bindings to the C string parsing functions for strict bytestrings
17:35:53 <dons> would be cheap, and efficient.
17:36:49 <jatqceer> dons: and your S is?  Data.ByteString?
17:37:06 <dons> import Foreign
17:37:06 <dons> import Foreign.C.Types
17:37:06 <dons> import Foreign.C.String
17:37:06 <dons> import qualified Data.ByteString.Char8 as S
17:37:06 <dons> import Data.ByteString.Base
17:37:08 <dons> import Control.Monad
17:37:10 <dons> :)
17:37:26 <dons> import Foreign.* would be nice.
17:37:29 <jatqceer> Thanks
17:37:29 * sorear gets the feeling import is a comment on the shootout :)
17:37:53 <dons> I think there should be a convention to provide top level modules exporting everything
17:38:05 <sorear> there is
17:38:06 <dons> so import Control -- brings them all in, import Foreign, also.
17:38:08 <sorear> import Foreign
17:38:11 <dons> well, its not conventional
17:38:14 <dons> and see above
17:38:24 <dons> why would Foreign not provide *.String
17:38:45 <sorear> if it doesn't, I'm pretty sure it's a bug
17:39:01 <sorear> since the FFI predates hier modules, and mandates string marshalling
17:39:38 <sorear> aww, module CString
17:45:31 <hpaste>  emu pasted "using strtol" at http://hpaste.org/427
17:47:20 <dons> that inlinePerformIO is unsafe though
17:47:22 <dons> since you're allocating inside it
17:47:37 <emu> isn't it just unsafePerformIO
17:47:38 <crackers> that just makes it more fun ;)
17:47:43 <dons> emu, no!
17:47:59 <dons> the alloca could be floated outside, and shared (which may or may not be evil)
17:48:17 <dons> the boxing in Maybes might be a bit costly -- i've noticed that previously
17:48:56 <dons> {-# INLINE inlinePerformIO #-}
17:48:56 <dons> inlinePerformIO :: IO a -> a
17:49:12 <dons> is the key. super dangerous -- you must not allocate, and it must be pure.
17:49:14 <emu> k
17:49:41 <emu> not the problem though :/
17:49:54 <emu> it works in ghci btw :/
17:50:12 <sorear> ghci doesn't float
17:50:59 <dons> http://alan.petitepomme.net/cwn/2007.06.26.html#1
17:51:01 <lambdabot> Title: Caml Weekly News
17:51:34 <sorear> GHC's IO monad implementation has a proof of correctness.  To it, inlinePerformIO is antimatter.
17:52:54 <dons> it should be, iAskedFirstBeforeIDoThisPerformIO
17:53:22 <dibblego> ?type inlinePerformIO
17:53:27 <lambdabot> Not in scope: `inlinePerformIO'
17:53:33 <dibblego> get stuffed
17:53:46 <sorear> ?type Data.ByteString.Base.inlinePerformIO
17:53:49 <lambdabot> forall a. IO a -> a
17:53:57 <dibblego> nice
17:54:06 <dibblego> how is it different to unsafePerformIO?
17:54:20 <sorear> it has none of the nice properties
17:54:25 <dibblego> ?src Data.ByteString.Base.inlinePerformIO
17:54:25 <lambdabot> Source not found. The more you drive -- the dumber you get.
17:54:40 <sorear> with unsafePerformIO, your code will be executed an integer number of times.
17:54:46 <sorear> not so with inlinePerformIO
17:55:00 <dibblego> that totally bamboozles me
17:55:07 <dibblego> ?type unsafePerformIO
17:55:10 <lambdabot> Not in scope: `unsafePerformIO'
17:55:23 <dibblego> it's IO a -> a too iirc
17:55:40 <dibblego> what is "executed an integer number of times" got to do with anything?
17:55:51 <sorear> dibblego: consider eg 'array'
17:55:54 <sorear> @type array
17:55:57 <crackers> do you know the integer?
17:55:57 <lambdabot> forall i e. (Ix i) => (i, i) -> [(i, e)] -> Array i e
17:56:08 <dibblego> right
17:56:11 <sorear> crackers: no, and that's the unsafe thing
17:56:27 <sorear> array is implemented using unsafePerformIO; it allocates an array, fills it, and returns it.
17:56:41 <crackers> so you don't know how many times it gets executed?
17:56:45 <dibblego> ok, I can imagine that
17:56:53 <sorear> if array used inlinePerformIO, then 1 array would be allocated and shared between all attempts.  very very bad.
17:57:01 <dibblego> aaah
17:57:01 <crackers> ah
17:57:05 <sorear> referential transparency goes bye-byte
17:57:27 <emu> its like programming in C++, but in Haskell
17:57:56 <sorear> hmm, actually in that case it's safe because the array has a data dependency on the size; but in other cases things can be bad.
17:58:14 <sorear> basically, everything you put in inlinePerformIO must be idempotent
17:59:17 <sorear> \x -> inlinePerformIO $ print "hi" >> return x -- doesn't allocate but still isn't safe!  hi will be printed at most once in the entire program, if you use -O
17:59:48 <sorear> whereas with unsafePerformIO it would be printed at least once for each value passed through
17:59:52 <dibblego> idempotence is f . f = f right?
17:59:55 <sorear> yeah
18:00:01 <sorear> in this case f >> f = f
18:00:28 <dibblego> I have seen people confuse idempotence and referential transparency
18:00:49 <sorear> liftM2 (==) f f  =  f >> return True
18:02:21 <sjanssen> assuming == is not bogus
18:03:14 <sorear> where == = extenstional equality :)
18:04:31 <dibblego> what does -0 do anyway?
18:05:01 <sorear> dash oh
18:05:05 <sorear> not dash zero
18:05:17 <dibblego> oh :)
18:05:20 <sorear> anyway, it turns on the *O*ptimizer
18:05:34 <dibblego> which does what?
18:05:44 <emu> makes your program crash
18:05:50 <dibblego> CSE?
18:05:50 <sorear> mangles your code beyond all hope of human recognition
18:05:57 <Saizan> with -O constants are floated out so that print "hi" is executed only once
18:06:11 <Saizan> ?
18:06:13 <dibblego> > 5349 + 22086
18:06:21 <lambdabot>  27435
18:09:09 <sorear> @users
18:09:09 <lambdabot> Maximum users seen in #haskell: 354, currently: 323 (91.2%), active: 9 (2.8%)
18:09:15 <sorear> @yow
18:09:15 <lambdabot> NANCY!!  Why is everything RED?!
18:09:23 <dibblego> 354 is a new record I think
18:09:40 <sorear> dibblego: About 25 over the old one!
18:10:18 <dibblego> wonder what Haskell events occur that cause these spikes
18:10:19 <byorgey> about 150 over an appropriate really old one
18:10:32 <dons> wow.
18:11:51 <byorgey> @yarr
18:11:52 <lambdabot> Aye
18:12:08 <Excedrin> it was 342 on May 29
18:12:44 <byorgey> really? seems like I recall it being 338 just a few days ago
18:12:56 <dons> 342, yep.
18:13:06 <byorgey> apparently my memory fails me =)
18:13:51 <nominolo> @yarr
18:13:51 <lambdabot> I want me grog!
18:13:57 <nominolo> @yo
18:13:58 <lambdabot> I had a lease on an OEDIPUS COMPLEX back in '81 ...
18:17:09 * Pseudonym wonders what an Oedipus Quaternion would look like
18:17:18 <nominolo> whoa.  writing howtos/tutorials is a lotta work ..
18:17:25 <Pseudonym> But you gotta do it.
18:17:31 <wy> Hey guys. My office cheap standard dell keyboard died. Thinking about getting an ergonomic keyboard, but most of them are bulky with junk keys. Any ideas of a good keyboard?
18:17:32 <Pseudonym> @quote tutorial
18:17:32 <lambdabot> Tela says: ... tutorials which focus on the IO monad go to great lengths to mention how Monads basically save your life every day
18:17:36 <Pseudonym> @quote tutorial
18:17:36 <lambdabot> monochrom says: The problem is that bad programmers will assess tutorials for good programmers as "ivory tower", and moreover bad programmers are the vocal majority.  It gets you bad press.
18:19:13 <nominolo> tutorials are bad?
18:19:35 <Pseudonym> No, tutorials are good.
18:19:41 <dibblego> that quote is so true and is the concern I raised with bos yesterday re: RWH
18:19:41 <nominolo> or only for advanced topics?
18:20:00 <nominolo> RWH?
18:20:03 <beelsebob_> dibblego: turns on optimisations
18:20:07 <beelsebob_> o.O
18:20:08 <beelsebob_> splode
18:20:11 <dibblego> @where realworldhaskell
18:20:12 <lambdabot> I know nothing about realworldhaskell.
18:20:15 <dibblego> @where rwh
18:20:16 <beelsebob_> ignorem me
18:20:16 <lambdabot> I know nothing about rwh.
18:20:17 <nominolo> ah
18:20:19 <beelsebob_> odd things happening
18:20:34 <dibblego> @remember rwh is http://www.realworldhaskell.org/blog/
18:20:34 <lambdabot> Done.
18:20:42 <dibblego> @remember realworldhaskell is http://www.realworldhaskell.org/blog/
18:20:42 <lambdabot> Done.
18:20:43 <nominolo> i'm not trained in that brond new acronym yet :)
18:20:47 <Saizan> ..
18:20:50 <wy> I found this tutorial helpful http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:20:53 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ..., http://tinyurl.com/ecqzl
18:20:58 <dibblego> RWH is a hospital 5 minutes from here - my girlfriend works there
18:21:00 <Saizan> dibblego: you've added that as a @quote
18:21:06 <wy> But I still don't like monads
18:21:11 <dibblego> Saizan, oh, what's the correct command?
18:21:19 <Saizan>   @where+
18:21:27 <dibblego> is there @remember- ?
18:21:33 <dibblego> @remember- rwh
18:21:33 <lambdabot> Incorrect arguments to quote
18:21:47 <dibblego> @unremember rwh
18:21:47 <lambdabot> Incorrect arguments to quote
18:21:50 <Saizan> @help remember
18:21:50 <lambdabot> quote <nick>
18:21:51 <lambdabot> remember <nick> <quote>
18:21:51 <lambdabot> Quote somebody, a random person, or save a memorable quote
18:21:51 <nominolo> @help forget
18:21:51 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:21:52 <dibblego> @forget rwh
18:21:52 <lambdabot> Unknown command, try @list
18:22:36 <nominolo> sorear once deleted a quote
18:22:40 <dibblego> lambdabot has infinite memory and never forgets
18:22:52 <nominolo> don't remember how he did it though
18:23:03 <sorear> nominolo: Only way is to crash the bot.
18:23:07 <dibblego> you forgot how to forget?
18:23:24 <nominolo> @kill lambdabot
18:23:24 <lambdabot> Maybe you meant: keal kind tell
18:23:24 <Saizan> or edit the state file?
18:23:36 <Saizan> @keal
18:23:36 <lambdabot> need 1 to do a while 0 does !a. need 1 to do a while 0 does !a
18:23:56 <sorear> @quit
18:23:58 <Saizan> has that any sense?
18:24:08 <nominolo> > unsafePerformIO exit
18:24:14 <sorear> the bot respawns
18:24:21 <sorear> @quote rwh
18:24:28 <lambdabot> rwh says: is http://www.realworldhaskell.org/blog/
18:24:52 <sorear> darn, the one time I do it on purpose is the one time it actually manages to save
18:26:09 <sorear> nominolo: > forks, so the only way to kill the bot that way is kill(2)
18:26:52 <nominolo> @remember me
18:26:53 <lambdabot> Incorrect arguments to quote
18:31:03 <Pseudonym> @remember cow moo
18:31:03 <lambdabot> Done.
18:31:09 <shapr> @quote cow
18:31:09 <lambdabot> cow says: moo
18:31:12 <shapr> hmm
18:31:17 <shapr> @quote Lemmih
18:31:18 <lambdabot> Lemmih says: Two lambdabot days is probably like 8 human days.
18:31:21 <shapr> @quote lemmih
18:31:21 <lambdabot> Lemmih says: <shapr> Any idea where we should meet?  *** Lemmih opens Google Earth.
18:31:27 <shapr> I like that one.
18:31:32 <Pseudonym> Yeah.
18:31:38 <shapr> @quote Pseudonym
18:31:38 <lambdabot> Pseudonym says: "Run GHC", by the way, is a lesser-known 80s kip hop group.
18:31:45 * shapr laughs
18:31:53 <Pseudonym> And the typo is still not fixed.
18:31:57 * Pseudonym grumbles
18:32:59 <shapr> g'day Pseudonym, when will you update your personal website?
18:33:08 <Pseudonym> G'day, and I don't know.
18:33:19 * Pseudonym has a blog entry in the works, but I need to finish the code first
18:33:32 <weitzman> Is there a Haskell posse in the SF bay area, by any chance?
18:33:34 <shapr> Where's your blog?
18:33:48 <Pseudonym> Err... obvious url/blog
18:33:51 <Pseudonym> :-)
18:34:21 <Pseudonym> Actually, I guess it's kinda unusual to self-host blogs these days, when there are free options out there in the big wide world.
18:34:37 <dibblego> I host mine in my kitchen
18:34:41 <monochrom> All free options come with strings attached.
18:34:46 <Pseudonym> Does it get crumbs on it?
18:34:51 <Pseudonym> Yeah.
18:35:02 <Pseudonym> I wasn't happy with the way that other systems handle LaTeX.
18:35:05 <dibblego> actually, yes it does :)
18:35:08 <shapr> Pseudonym: blog.andrew.bromage.org doesn't resolve!
18:35:18 <Pseudonym> shapr: http://andrew.bromage.org/blog/
18:35:31 <sorear> Why is there no MaybeT?
18:35:34 <nominolo> @uptime
18:35:34 <lambdabot> uptime: 11m 37s, longest uptime: 1m 10d 23h 44m 29s
18:35:55 <monochrom> It may be more unusual to write your own blog software. :)
18:35:59 <Pseudonym> shapr: You might like the series on integration.
18:36:13 <Pseudonym> It's the code that's not done yet.
18:39:49 <chessguy> @go haskell gransim
18:39:52 <lambdabot> http://www.macs.hw.ac.uk/~dsg/gph/
18:39:52 <lambdabot> Title: Glasgow Parallel Haskell
18:41:43 <sorear> GRR.
18:41:51 <sorear> MaybeT is too hard to implement...
18:42:37 <Pseudonym> No it's not.
18:43:15 <Pseudonym> How would you like to implement it?  Data constructors or continuations?
18:43:40 <sorear> I don't care; the API is obvious.
18:43:53 <sorear> what I'd *like* to do is "import Control.Monad.MaybeT"
18:43:58 <sorear> Maybe rather
18:44:02 <Pseudonym> http://hfl.cvs.sourceforge.net/hfl/hfl/mtl/Logic.hs?revision=1.2&view=markup
18:44:04 <Pseudonym> Would that do?
18:44:05 <lambdabot> Title: SourceForge.net Repository - [hfl] View of /hfl/mtl/Logic.hs, http://tinyurl.com/32ldfk
18:44:15 <Pseudonym> Hang on.
18:44:16 <Pseudonym> Wrong one.
18:44:21 <Pseudonym> http://hfl.cvs.sourceforge.net/hfl/hfl/mtl/Negate.hs?revision=1.2&view=markup
18:44:22 <Pseudonym> That one.
18:44:23 <lambdabot> Title: SourceForge.net Repository - [hfl] View of /hfl/mtl/Negate.hs, http://tinyurl.com/y4nvgd
18:46:29 <Pseudonym> But really, there's a general technique for turning monads defined as data constructors into monad transformers, and that's to add another constructor.
18:46:37 <Pseudonym> data Maybe a = Nothing | Just a
18:47:08 <Pseudonym> data MaybeT m a = NothingT | JustT a | forall b. LiftBindT (m b) (b -> MaybeT m a)
18:47:20 <Pseudonym> The catch is that it uses higher-ranked types.
18:47:24 <dons> maybeToMonadPlus :: MonadPlus m => Maybe a -> m a
18:47:24 <dons> maybeToMonadPlus = maybe mzero return
18:47:28 <dons> should that be in Data.Maybe ?
18:47:39 <sorear> Definitely.
18:47:40 <dons> to lift all the Maybe stuff in List, for exapmle, in a standard way
18:47:45 <Pseudonym> It should definitely be somewhere.
18:47:51 <dons> and to encourage the use of Maybe of Monad.
18:47:53 <Pseudonym> Maybe it should be in MonadPlus.
18:47:55 <dons> s/over/
18:47:55 <sorear> I call it fromMaybeM
18:49:03 <Pseudonym> runMaybeT :: MaybeT m a -> m (Maybe a)
18:49:10 <Pseudonym> runMaybeT NothingT = return Nothing
18:49:18 <Pseudonym> runMaybeT (JustT a) = return (Just a)
18:49:28 <dons> yeah, its sort of an inverse of
18:49:28 <dons>    mzero = Nothing
18:49:28 <dons>    Nothing `mplus` ys  = ys
18:49:28 <dons>    xs      `mplus` _ys = xs
18:49:32 <Pseudonym> runMaybeT (LiftBindT m k) = m >>= \x -> runMaybeT (k x)
18:49:39 <Pseudonym> Straightforward.
18:50:04 <Pseudonym> Actually, I have a better idea.
18:50:05 <dons> oh, we have 'guard' in Monad.hs
18:50:09 <dons> so itwould go in there.
18:50:15 <dons> :t Control.Monad.guard
18:50:16 <Pseudonym> class Choosable f where
18:50:23 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
18:50:27 <Pseudonym>     choose :: (MonadPlus m) => f a -> m a
18:50:37 <Pseudonym> Then you can have Choosable [] and Choosable Maybe
18:50:53 <Pseudonym> I don't like the name "Choosable".
18:51:09 <chessguy> Choicage
18:51:13 <Pseudonym> AxiomOfChoice
18:51:33 <Pseudonym> Probably just Choice.
18:52:02 <chessguy> hm, maybe isn't really a choice
18:52:02 <Pseudonym> That proves it.  The axiom of choice is a natural transformation.
18:53:49 <Pseudonym> chessguy: No, but it's a container.
18:54:06 <chessguy> ...
18:54:07 <Pseudonym> I guess you can think of it as an optional choice.
18:54:42 <chessguy> more like a model of computational failure
18:55:01 <Pseudonym> So [] is a model of computational nondeterminism, INCLUDING failure.
18:55:22 <chessguy> yeah, why do we need Maybe anyway?
18:55:36 <Pseudonym> I like "choose" here, but I wonder what else it could apply to.
18:56:08 <Pseudonym> I guess Data.Set and Data.Map have obvious Choice instances, too.
18:56:18 <Pseudonym> And as a bonus, you don't need the Ord qualifications.
18:58:00 <chessguy> hm?
18:58:09 <chessguy> don't need what Ord qualifications?
18:58:40 <Pseudonym> Data.Set has an Ord context.
18:58:47 <Pseudonym> But you only use it when adding or modifying.
18:58:48 <chessguy> yes...
18:59:03 <Pseudonym> So the Choose typeclass actually works.
18:59:28 <chessguy> ermmm
18:59:49 <Pseudonym> It's either a limitation or a strength of Haskell's type system (depending how you look at it) that you can't put type contexts on typeclass instances.
18:59:51 <chessguy> the members of the set would still have to be instances of Ord, wouldn't they?
18:59:54 <Pseudonym> For constructor classes, anyway.
19:00:02 <Pseudonym> Yes, they'd need to be that to actually construct a set.
19:00:10 <Pseudonym> But the Choose typeclass wouldn't need to mention that.
19:00:24 <chessguy> oh you mean it could obfuscate it :)
19:00:51 <crackers> yay for obfuscation
19:01:01 <Pseudonym> Not obfuscating, exactly.
19:01:09 <Pseudonym> You just wouldn't need to mention it.
19:01:10 <chessguy> awfully darn close
19:06:47 <ihope__> Now, does Haskell have any support whatsoever for singletons?
19:07:22 <SamB> ihope: what's a singleton?
19:07:50 <crackers> isn't it a class with single shared instance?
19:07:56 <Pseudonym> You're really, REALLY asking the wrong question there.
19:07:59 <ihope> A type that only has one value, anywhere.
19:08:05 <Pseudonym> Like ()?
19:08:34 <ihope> You couldn't have a pair of values of that type, because there would only be one instance of it.
19:09:03 <Pseudonym> What is this "instance" of which you speak?
19:09:18 <sorear> ihope: Haskell objects don't have identity
19:09:30 <Pseudonym> ihope: Could you explain what you're trying to do?
19:09:48 <SamB> ihope: we don't have that kind of instance in Haskell
19:09:58 <Pseudonym> Singletons in OO languages serve two purposes.
19:10:09 <Pseudonym> 1. To avoid initialisation order problems.
19:10:21 <Pseudonym> 2. To allow lazy initialisation of "static" things.
19:10:31 <SamB> Pseudonym: I thought it was 1. To cause initialization order problems
19:10:34 <Pseudonym> Haskell gives you 2 for free, and 1 isn't an issue.
19:10:53 <dibblego> a singleton is just a destructive update register with wide scope
19:11:00 <Pseudonym> Usually, the Haskell equivalent of a Singleton is a top-level CAF.
19:11:03 <SamB> 2. To cause headaches for the implementors trying to prevent another instance from being created
19:11:29 <Pseudonym> SamB: It depends on the language. :-)
19:11:40 <Pseudonym> Certainly, singletons + DSOs + C++ = real headaches.
19:11:57 <SamB> anyway, Haskell's classes are such that if you want a single-instance class... you just make a type and functions ;-)
19:11:58 <Pseudonym> But the fact is, static objects + DSOs + C++ = real headaches.
19:12:27 <ihope> I found something equating singletons with the dual number epsilon.
19:12:42 <ihope> Sort of a fancy way of differentiating types.
19:12:53 <SamB> Pseudonym: my mother told me not to mixed static and shared objects if I valued my sanity
19:13:33 <Pseudonym> Your mother must have used Windows DLLs.
19:13:45 <sjanssen> SamB: was she speaking of laundry?
19:13:59 <SamB> no actually I'm lying
19:14:04 <sjanssen> ah
19:14:06 <SamB> she never said that
19:14:15 <sjanssen> otherwise, I'd say you have an interesting mother
19:14:21 <SamB> she wouldn't know a shared object if it bit her in the nose
19:14:47 <SamB> ... seeing as she runs windows 98, this probably happens on a daily basis anyway...
19:14:47 <Pseudonym> Object::instance()->bite(samB->mother()->nose())
19:15:04 <SamB> Pseudonym: have you detected the pun yet?
19:15:25 <Pseudonym> Evidently not.
19:15:31 <Pseudonym> Was it "bit"?
19:16:04 <SamB> ... no.
19:16:14 <Pseudonym> Then I definitely missed it.
19:16:14 <SamB> it involved a different meaning of "object"
19:16:31 <SamB> especially as it appears in "static object"
19:17:24 <Pseudonym> Nope, completely lost me.
19:17:31 <Saizan> ?type insertWith
19:17:33 <lambdabot> Not in scope: `insertWith'
19:17:40 <Saizan> ?type Data.Map.insertWith
19:17:43 <lambdabot> forall a k. (Ord k) => (a -> a -> a) -> k -> a -> Data.Map.Map k a -> Data.Map.Map k a
19:18:24 <Saizan> why it isn't  forall a k. (Ord k) => (a -> b -> a) -> k -> b -> Data.Map.Map k a -> Data.Map.Map k a ?
19:18:42 * SamB flings a .o file at Pseudonym
19:19:34 * shapr inturkalates SamB
19:19:44 * Pseudonym runs SamB's .fini
19:19:48 <SamB_XP> it's, uh, printf.o
19:20:17 <SamB_XP> from libc.a
19:30:01 * dylan really, really wished dzen2 had a -b switch
19:30:55 <dylan> but on the flip side, I wrote an compile-at-runtime C program.
19:33:05 <sorear> what does -b do?
19:33:32 <jcreigh> I assume it would put dzen at the bottom of the screen, like dmenu's -b option puts it at the bottom of the screen.
19:34:13 <dylan> one second, I'll post my wrapper zsh script. so you can gaze at the inefficiency.
19:34:44 <banbh> does haskell have an identity type constructor?  i.e. F t would be t
19:35:31 <Pseudonym> Not exactly.
19:35:40 <Pseudonym> But it has newtype Id a = Id a
19:35:45 <Pseudonym> Which is pretty close.
19:35:58 <Pseudonym> It's more useful as a newtype, because it's a functor and a monad and stuff like that.
19:36:03 <banbh> true.  although you have to wrap and unwrap
19:36:07 <Pseudonym> Right.
19:36:18 <Pseudonym> @kind Id
19:36:21 <lambdabot> Not in scope: type constructor or class `Id'
19:36:26 <Pseudonym> @kind Control.Monad.Id
19:36:28 <lambdabot>     Not in scope: type constructor or class `Control.Monad.Id'
19:36:30 <banbh> right!
19:36:32 <Pseudonym> @kind Control.Monad.Identity.Id
19:36:34 <lambdabot>     Not in scope: type constructor or class `Control.Monad.Identity.Id'
19:36:37 <Pseudonym> Or something.
19:36:40 * Pseudonym forgets where it is
19:37:11 <Pseudonym> @hoogle Id
19:37:11 <lambdabot> Prelude.id :: a -> a
19:37:11 <lambdabot> Control.Monad.Identity :: module
19:37:11 <lambdabot> Text.Read.Ident :: String -> Lexeme
19:37:18 <Pseudonym> Control.Monad.Identity, right.
19:38:09 <banbh> thx
19:39:09 <Saizan> are there widely known algorithms to find the longest possible path in an acyclic directed weighted graph?
19:40:36 <Excedrin> if by longest possible path you mean shortest possible path...
19:40:36 <sorear> Maybe the Bellmann-Ford algorithm?
19:40:38 <Pseudonym> Saizan: The weights are non-negative?
19:41:04 <sorear> Saizan: Negate all the weights, then use Bellman-Ford to find the shortest path
19:41:05 <Pseudonym> If so, the standard shortest-path algorithm will work just fine.
19:41:13 <Pseudonym> You don't even need to do that.
19:41:24 <Saizan> non-negative, yes
19:41:33 <Saizan> but _longest_
19:41:44 <Pseudonym> Conceptually, the algorithm is easy.
19:42:18 <Pseudonym> You start at the start node, and do a depth-first search on it.
19:42:32 <Pseudonym> At each step, you set the distance on each node to be the maximum of the inputs.
19:42:39 <Pseudonym> Iterate until no distances change.
19:43:21 <dylan> http://hardison.net/warez/xmonad/pzen
19:43:31 <dylan> ^ that's what I do to get around the lack of dzen2 -b. :(
19:44:27 <Saizan> Pseudonym: inputs?
19:44:57 <dylan> I suppose I could not use gapcalc.c as a script, but it's annoying to have such a trivial program compiled and put in /usr/local/bin on all my machines. :(
19:45:42 <dylan> hmm, this isn't #xmonad.
19:45:55 <Pseudonym> Inputs are arcs pointing into the current node.
19:46:08 <Pseudonym> A queue algorithm also works nicely.
19:46:18 <Pseudonym> Put the initial node in the queue.
19:46:24 <Pseudonym> Then iteratively:
19:46:30 <Pseudonym> - Pop a node off the queue.
19:47:08 <Pseudonym> - Compute its "greatest length": For each input arc, sum the weight of the arc and the distance of the node it comes from.
19:47:26 <Pseudonym> - If the length is different from what it was, push all of the successor nodes onto the queue.
19:47:47 <Pseudonym> That explanation wasn't great.
19:49:46 <Saizan> uhm
19:50:43 <weitzman> If I were trying to solve that problem in the clearest way possible, I would first note that the problem has an optimal substructure. The longest path from A to C will include the longest paths from A to B and B to C for some B
19:51:11 <weitzman> You could then think of solving for the longest paths with max length N for N = 1 to the number of nodes
19:52:01 <weitzman> And hopefully that would work and be clear
19:53:25 <weitzman> The CLR algorithm uses a function called relax() to shorten current shortest paths
19:53:35 <weitzman> I guess tenseUp() would be for longest paths
19:54:25 <Korollary> Is the extension "existentially quantified data constructors" actually the same as "arbitrary rank polymorphism"?
19:54:51 <sorear> No
19:55:01 <sorear> However, the latter subsumes the former
19:55:09 <Korollary> Right
19:55:10 <sorear> data Box = forall a. Box a
19:55:12 <Korollary> That's what I meant
19:55:23 <Korollary> Thanks
19:55:29 <sorear> data Box = Box (forall ret. (forall a. a -> ret) -> ret)
19:56:42 <Korollary> The funny thing is that you could write both data Box = Box (forall r. r) or data Box = forall r. Box r
19:57:20 <Pseudonym> Gotta run.  Fare well.
19:58:25 <Korollary> The type system extensions chapter of the GHC user's guide could be a little more linear.
20:18:01 * sorear uses Goedel's incompleteness theorem to construct an infinite class of logics indexed by the ordinal numbers, each logic being precisely the least powerful logic able to prove all previous logics consistent, with L_0 = ZFC
20:19:44 * crackers wishes he understood half of that
20:20:07 <Korollary> crackers: You're falling for the marketing.
20:21:55 <crackers> there's a lot of math in this channel that goes right over my head
20:23:43 <Korollary> #haskell's like a nudist colony. We're not ashamed of gratuitous math.
20:23:59 <emu> nudist mathematicians?
20:24:06 <emu> yet another excuse not to do laundry
20:24:07 <crackers> that doesn't sound pretty
20:24:21 <phoniq> EEEW
20:24:36 <sorear> is that like FFTW?
20:29:37 <crackers> ?src Graphics.Rendering.OpenGL.GL.VertexSpec.color
20:29:38 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:29:49 * crackers pouts.
20:30:01 <sorear> it's an overloaded foreign import
20:30:18 <sorear> @source Graphics.Rendering.OpenGL.GL.VertexSpec
20:30:18 <lambdabot> http://darcs.haskell.org/packages/OpenGL/Graphics/Rendering/OpenGL/GL/VertexSpec.hs
20:31:29 <crackers> I'm just trying to figure out if calling color is equivalent to setting the StateVar currentColor
20:33:39 <crackers> documentation is rather sparse on the Haskell opengl implementation
20:35:14 <hpaste>  Idiots pasted "Idiots" at http://hpaste.org/428
20:35:40 <emu> that's a polite spammer ...
20:36:20 <sorear> emu: check again :)
20:37:07 <sorear> The nice thing about an announcing bot is that spam doesn't last.
20:37:24 <sorear> that paste lasted what, 1 minute?
20:40:22 * LoganCapaldo wonders what the spam said
20:40:31 <LoganCapaldo> and now I will never know
20:40:40 <LoganCapaldo> it will eternally remain a mystery
20:44:40 <sorear> LoganCapaldo: Selling watches
20:46:45 <LoganCapaldo> > toDyn 4
20:46:47 <lambdabot>  <<Integer>>
20:47:07 <LoganCapaldo> well I'll be I didn't know lambdabot imported Data.Dynamic
20:47:12 <LoganCapaldo> @botsnack
20:47:12 <lambdabot> :)
20:48:24 <LoganCapaldo> > Data.Map.fromList [("Name", toDyn "Logan"), ("Age", toDyn 23)] -- who says Haskell is statically typed? :)
20:48:25 <lambdabot>   Not in scope: `Data.Map.fromList'
20:49:05 <LoganCapaldo> > M.fromList
20:49:07 <lambdabot>  Add a type signature
20:49:20 <LoganCapaldo> > M.fromList [("Name", toDyn "Logan"), ("Age", toDyn 23)] -- who says Haskell is statically typed? :)
20:49:23 <lambdabot>  fromList [("Age",<<Integer>>),("Name",<<[Char]>>)]
20:49:51 <dons> > fromDynamic ((toDyn ord) `dynApp` (toDyn 'x')) :: Maybe Int
20:49:53 <lambdabot>  Just 120
20:50:03 <dons> look mum, late checking!
20:50:24 <dons> > ((toDyn 7) `dynApp` (toDyn "foo"))
20:50:27 <lambdabot>  Exception: Type error in dynamic application.
20:50:27 <lambdabot> Can't apply function <<Integer...
20:50:54 <LoganCapaldo> whats the difference between dynApp and dynApply?
20:51:12 <dons> one calls error, one takes a default value, on type errors
20:51:34 <TSC> I want to make an interface like that of darcs record, where some information is shown and the user chooses an option.  Is there a general library for that sort of interface?
20:51:44 <LoganCapaldo> @type dynApplu
20:51:46 <lambdabot> Not in scope: `dynApplu'
20:51:50 <LoganCapaldo> @type dynApply
20:51:53 <lambdabot> Dynamic -> Dynamic -> Maybe Dynamic
20:52:31 * LoganCapaldo coulda sworn when he was reading the docs earlier today dynApp and dynApply both had the same type
20:52:40 <LoganCapaldo> maybe it was a trick of the mind
20:54:00 <LoganCapaldo> yep it was clearly me going mad
20:55:41 <LoganCapaldo> > fromDynamic $ (toDyn 2) `dynApp` (toDyn (+)) `dynApp` (toDyn 4)
20:55:44 <lambdabot>  Exception: Type error in dynamic application.
20:55:44 <lambdabot> Can't apply function <<Integer...
20:56:13 <LoganCapaldo> > fromDynamic $ (toDyn (+)) `dynApp` (toDyn 2) `dynApp` (toDyn 4)
20:56:17 <lambdabot>  Just 6
20:58:28 <LoganCapaldo> > fromDynamic $ toDyn (undefined :: ()) :: Maybe Int
20:58:30 <lambdabot>  Nothing
20:59:40 <dons> that's the essence of dynamic typing right there.
21:01:36 * LoganCapaldo waits for the "Essence of Dynamic Typing" cologne to come out
21:09:04 <LoganCapaldo> @source Data.Dynamic
21:09:05 <lambdabot> http://darcs.haskell.org/packages/base/Data/Dynamic.hs
21:12:18 <LoganCapaldo> funny
21:12:29 <LoganCapaldo> I used an existenial
21:12:48 <LoganCapaldo> I guess that can't to be portable
21:12:53 <dons> sure it is.
21:13:39 <LoganCapaldo> dons: so why is it written with all the preprocessor directives and what not?
21:13:56 <jsnx> what does the '$' do in haskell? i see it all the time but i can't find a reference for it...
21:14:14 <TSC> @src ($)
21:14:15 <lambdabot> f $ x = f x
21:14:34 <TSC> Function application, e.g.
21:14:44 <TSC> > (\x -> 2*x) $ 4
21:14:46 <lambdabot>  8
21:14:52 <dibblego> jsnx, it is mostly used to remove parentheses because it has different precedence
21:15:02 <jsnx> dibblego: oh, thank you
21:15:08 <dibblego> > head $ tail [1..1]
21:15:11 <lambdabot>  Exception: Prelude.head: empty list
21:15:13 <dibblego> > head $ tail [1..10]
21:15:15 <lambdabot>  2
21:15:20 <dibblego> > head (tail [1..10])
21:15:23 <lambdabot>  2
21:15:38 <jsnx> > head tail [1..10]
21:15:39 <lambdabot>  Couldn't match expected type `[a]'
21:16:23 <jsnx> hmmm
21:16:29 <dibblego> jsnx, that is like (head tail) [1..10]
21:16:38 <dibblego> > head . tail [1..10]
21:16:38 <jsnx> yes, i know
21:16:40 <lambdabot>  Couldn't match expected type `a -> [a1]'
21:16:52 <jsnx> (took me a minute, though)
21:17:24 <dibblego> > head . tail $ [1..10]
21:17:26 <lambdabot>  2
21:17:30 <crackers> > (head.tail) [1..10]
21:17:33 <lambdabot>  2
21:18:41 <jsnx> head . tail [1..10] -> head . (tail [1..10]) ?
21:19:09 <dibblego> yes
21:21:56 <jsnx> ha ha
21:25:43 <desp> how would you call a function that fills in a MVar (Maybe a)?
21:25:45 <desp> whenMVarNothing_ :: MVar (Maybe a) -> IO a -> IO ()
21:27:52 <sorear> Why would you put a Maybe in a MVar?
21:29:45 <desp> ah, because I forgot.
21:29:53 <desp> sorear++
21:31:01 <desp> although...hm
21:32:24 <desp> sorear: no, I think it is a valid reason -- for synchronization
21:32:32 <sorear> desp: ?
21:33:53 <desp> example: hasBeenInitialized :: MVar Bool
21:34:40 <desp> I don't think that a MVar (), using the empty state instead of False, would be equivalent synchronization-wise
21:36:18 <sorear> just readMVar to wait and putMVar to signal
21:39:27 <jsnx> will HAppS compile with nhc98?
21:39:43 <alexj> doubt it.
21:39:52 <alexj> parts use th or generics
21:39:58 <jsnx> only ghc, right?
21:40:07 <jsnx> alexj: also, concurrent
21:40:14 <alexj> yes.
21:40:16 <jsnx> alexj: i think nhc98 doesn't have that
21:44:58 <desp> sorear: I think I disagree. correct me if I'm wrong, but if initialization is supposed to happen only once, there's no way to guarantee that with only a putMVar
21:50:05 <desp> i.e. if two threads note that the MVar is empty and attempt to fill it by, one of them is going to get blocked, but it will fill the MVar as soon as it's empty again -- and I cannot have that
21:50:28 <desp> s/fill it by/fill it by doing some initialization work/
21:52:08 * desp pokes sorear
21:52:11 <desp> :)
21:52:16 * sorear curls
21:52:29 <desp> aw.
22:10:05 <Sgeo> G'night all!
22:11:06 <Manyfold> good night
22:17:16 <shapr> g'nite!
22:19:46 <blackdog> g'day shapr
22:23:37 <Vq^> morning mr Dog
22:57:45 <nornagon> ?hoogle [a] -> (a,a)
22:57:45 <lambdabot> No matches, try a more general search
22:58:29 <nornagon> ?pl \x1:x2:[] -> (x1,x2)
22:58:29 <lambdabot> (line 1, column 8):
22:58:29 <lambdabot> unexpected "["
22:58:29 <lambdabot> expecting natural, identifier, "_" or "("
22:58:41 <nornagon> ?pl \x1:x2:_ -> (x1,x2)
22:58:41 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
22:58:47 <nornagon> eek.
22:59:25 <wilx> ?pl \ [x1:x2] -> (x1,x2)
22:59:25 <lambdabot> (line 1, column 3):
22:59:25 <lambdabot> unexpected "["
22:59:25 <lambdabot> expecting pattern
22:59:29 <wilx> Hm..
22:59:34 <nornagon> ?unpl ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
22:59:34 <lambdabot> (\ g h i -> h >>= \ g -> i >>= \ e -> return (g g e)) (\ j -> j) (\ m -> (\ x _ -> ((,)) (head m) (head x)) >>= \ ac -> tail >>= \ ab -> return (ac ab)) tail
22:59:38 <wilx> ?pl \ ([x1:x2]) -> (x1,x2)
22:59:38 <lambdabot> (line 1, column 4):
22:59:38 <lambdabot> unexpected "["
22:59:38 <lambdabot> expecting pattern
23:28:55 <dons> ?yow
23:28:56 <lambdabot> I hope you millionaires are having fun!  I just invested half your life
23:28:56 <lambdabot> savings in yeast!!
23:32:22 <Korollary> dons: when's the move?
23:34:28 <dons> in a few weeks
23:40:07 <setuid_w00t> Ok, really simple type conversion question
23:40:18 <setuid_w00t> bottomToMid :: Int -> Float
23:40:18 <setuid_w00t> bottomToMid s = (1/2) * s * tan (pi/6)
23:40:42 <setuid_w00t> What would be the correct version of the 2nd line so that it would match the type on the first line?
23:41:07 <treble> fromIntegral s
23:41:26 <treble> :t fromIntegral
23:41:29 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:41:39 <treble> Float is a Num and Int is an Integral
23:42:21 <dons> ?let bottomToMid :: Int -> Float; bottomToMid s = (1/2) * (fromIntegral s) * tan (pi/6)
23:42:22 <lambdabot> Defined.
23:42:28 <dons> > bottomToMid 7
23:42:29 <lambdabot>  2.020726
23:43:20 <setuid_w00t> Thanks.  Hopefully that will stick in my brain.
