00:23:13 <bos> whew. another long night of haskell hacking draws to an end.
00:28:35 <thoughtpolice> fun :)
00:45:48 <gleb> hiya dons
00:47:42 <gleb> @seen dons
00:47:42 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 51m 59s ago.
00:50:54 <gleb> dons: I've put the summary of our yesterday conversation on the wiki, on my personal 'talk' page. To be honest I've re-read "Lazy functional state threads" yesterday and it suddenly made a lot more sense for me, I've began doubting that it needs further clarification. But anyway, here it is: http://haskell.org/haskellwiki/User_talk:Gleb
00:50:56 <lambdabot> Title: User talk:Gleb - HaskellWiki
01:01:39 <ski> (sieni,Korollary : ok .. for some reason i thought it just compacted the live objects to the bottom of the heap (i.e. C stack) .. so then the C stack would act roughly like a heap where allocation is just incrementation of a pointer)
01:14:05 <dancor> can i pattern match on a data with named elements
01:14:34 <dancor> map (\(MyData {MyArgA a, MyArgB b}, x) -> ..) ..
01:17:11 <TSC> I think so
01:17:51 <gleb> dancor: do you mean pattern match on records? yes you can
01:18:19 <ski> map (\(MyData {myFieldA = a, myFieldB = b}, x) -> ..) ..
01:18:19 <dancor> i can't find the syntax
01:18:20 <ski> i think
01:18:22 <dancor> ah
01:18:39 <dancor> ski: perfect
01:19:22 <newsham> what is {-# UNPACK #-} ?
01:20:22 <gleb> dancor: you can also pattern match like this: map (\(MyData a b) -> ...)
01:20:58 <dancor> gleb: right
01:21:30 <ski> newsham : some hint to the compiler to destructure a constructor cell, by keeping around its arguments parts separatedly in register .. or something likt that, i think
01:36:55 <dons> oh heh, i didn't intend this to be a `blog post', but people seem to like it.  http://programming.reddit.com/info/1wu5v/comments
01:36:56 <lambdabot> Title: Haskell: Fast number parsing with strict bytestrings (reddit.com)
01:40:45 <EvilTerran> ...would it be overly optimistic of me to hope to install, say, Graphics.GD under Windows XP/GHC?
01:43:09 <pejo> The Haskell GD binding is rather incomplete, if that might bother you.
01:46:14 <EvilTerran> i just want to read in an image in some readily-convertable-to-format and getpixel everything into a 2d array for analysis. shurely that's possible?
01:46:29 * EvilTerran looks at the haddock page on hackagedb
01:47:08 <EvilTerran> ... okay, there appears to as yet be no way of reading data off the image. never mind that, then.
02:02:16 <EvilTerran> i guess i'll look into Rolling My Own if and when I have the time
02:10:11 <LeCamarade> @where haps
02:10:11 <lambdabot> I know nothing about haps.
02:10:14 <LeCamarade> @where happs
02:10:14 <lambdabot> http://happs.org
02:15:05 <LeCamarade> HAppS is such sweet hackery, but I gather it will almost definitely require me to host myself, no?
02:20:28 <quicksilver> well, you can get shell access hosting
02:20:37 <quicksilver> including 'virtual dedicated servers'
02:20:42 <quicksilver> and, indeed 'true dedicated servers'
02:20:47 <quicksilver> gonna cost you more though :)
02:26:13 <Jaggederest> ec2 support is on the way eventually, so that'll make it ~$75 a month
02:26:39 <Jaggederest> which isn't too bad, really.
02:32:56 <LeCamarade> Hmm.
02:39:24 <quicksilver> you can get a dedicated server for $75/month
02:39:24 <quicksilver> I have no idea why you'd prefer an ec2 image to a dedicated server :)
02:41:07 <quicksilver> (since a dedicated server has a persistant, writeable disk and can run databases and stuff)
02:41:58 <Lemmih> quicksilver: EC2 is easier to scale?
02:42:54 <quicksilver> Lemmih: yes, probably. I meant LeCamarade in particular rather than people in general, though
02:47:36 <quicksilver> Lemmih: even then you have the costs of using S3 as your database being pretty high, as I understand it
02:47:41 <quicksilver> Lemmih: it's not an "easy" solution at the moment
02:51:20 <Jaggederest> A dedicated box for 75 a month with 160gb, 10c/gb transfer, a 1.75ghz proc, and 2GB ram?
02:52:10 <Jaggederest> show me because I'd like one too. Minimum I've seen is 200/mo for true dedicated with that spec.
02:53:15 <Jaggederest> ps s3 is free for internal transfers. You're looking at ~$5/mo for any reasonable size DB
02:53:27 <LeCamarade> I'm still some distance away from having to make that decision, but I'll have to make it at some point.
02:54:10 <quicksilver> Jaggederest: it's not free from EC2
02:54:40 <quicksilver> Jaggederest: I have a dedicated, fully supported, core duo, no bandwidth charges server which cost me UKP40
02:54:44 <quicksilver> Jaggederest: almost exactly $75
02:55:32 <Jaggederest> actually, it is free from EC2, they changed the pricing
02:55:48 <quicksilver> Jaggederest: it's the $0.01 per 1000 requests I'm talking about
02:55:56 <quicksilver> Jaggederest: also S3 is not as convenient as an SQL database IMO
02:56:21 <Jaggederest> ah, true. No, you aggregate there, eg serialize on shutdown
02:56:36 <quicksilver> Jaggederest: then you don't get the scaling that lemmih was talking about
02:56:44 <quicksilver> Jaggederest: and if your EC2 gets an unexpected shutdown you lose data
02:57:02 <Jaggederest> true, but that's always the case, really.
02:57:26 <quicksilver> you're pretty unlikely to lose data on a sensible SQL database even in the event of a power outage
02:57:34 <quicksilver> of course, it can happen, with hardware disk corruption
02:57:50 <quicksilver> but I'm thinking hardware disk corruption is some orders of magnitude less likely than an unexpected EC2 shutdown
02:57:54 <quicksilver> (but I don't know)
02:57:55 <Jaggederest> I can't imagine an app structure that's immune to 'oops we unplugged it' heh. You can mitigate but still :)
02:58:08 <quicksilver> Jaggederest: then you don't have a very good imagination
02:58:20 <quicksilver> Jaggederest: I design and administrate such systems as my profession
02:58:46 <Jaggederest> right but you still lose in-queue requests
02:58:55 <quicksilver> yes, but not committed ones
02:59:05 <quicksilver> which is in most cases the critical point
02:59:17 <quicksilver> that's a guarantee a hell of a lot stronger than the EC2 one
02:59:27 <quicksilver> (unless you committ every transaction over S3, which takes me back to the charging point)
02:59:38 <Jaggederest> just a larger transaction size ;)
02:59:48 <quicksilver> transaction size is not normally negotiable
02:59:58 <quicksilver> if you tell your customer "we have charged your card, your goods are on their way"
03:00:03 <quicksilver> then that is a transaction you better not lose :)
03:00:30 <quicksilver> anyhow, it's not clear to me that EC2/S3 at the current pricing is a magic bullet
03:00:33 <quicksilver> it's very interesting
03:00:36 <quicksilver> and I watch with interest :)
03:00:46 <Jaggederest> yup, that's the problem of write-heavy DBs
03:00:52 <quicksilver> once they have a sensible pricing scheme so that I can run an SQL database over S3
03:01:00 <quicksilver> then I'll be beating a path to their door I can tell you
03:01:15 <quicksilver> (well, not just pricing scheme but also DB architecture)
03:01:34 <Jaggederest> read-heavy DBs are a dream to scale on s3/ec2 I gather
03:01:54 <quicksilver> but for the typical 'I have $75/month and I want to paly with HAppS' type person
03:01:56 <Jaggederest> most of the apps I've worked on are write-heavy though :(
03:02:07 <quicksilver> I will continue to recommend a dedicated [maybe virtual] server
03:02:31 <Jaggederest> depends how the bright happs fellows solve it, it'll be interesting.
03:07:23 <quicksilver> yes, that's true
03:07:23 <quicksilver> they do have an unreleased S3 data store
03:07:23 <quicksilver> but they have misgivings about the cost per commit issue
03:07:23 <Jaggederest> yep. Maybe they've got a machine image that'll help. Distributed logging, say, would seem to be pretty slick
03:07:23 <Jaggederest> odds of losing all machines = k (1 / n)
03:07:23 <Jaggederest> k is the unknown
03:07:23 <quicksilver> isn't it p ^ n ?
03:07:23 <quicksilver> where p is the prob of losing one?
03:07:23 <quicksilver> (if you assume they're independent, which of course they aren't)
03:07:23 <Jaggederest> yeah but I don't know probability heh
03:07:23 <Jaggederest> problem with autodidactism
03:08:16 <Jaggederest> anyway, the killer app (ugh) is for caching and replication: keep one permanent server and scale using ec2.
03:17:41 <quicksilver> ndm: I emailed you some comments, hope you got them
03:18:03 <ndm> quicksilver: yep, thanks - i'll take a look at them later
03:27:27 <LeCamarade> To have some fun between those two monads, run @quote time. It's entertaining. Been doing it in PRIVMSG for the last dunno-how-long.
03:28:48 <DRMacIver> @quote time
03:28:48 <lambdabot> monochrom says: There was also a time we needed -fvia-fortran and -fvia-cobol
03:29:15 <opqdonut> viva fortran!
03:30:56 <LeCamarade> @quote Cale.sigma.phi
03:30:57 <lambdabot> No quotes match. My pet ferret can type better than you!
03:31:20 <opqdonut> @uote Cale.*sigma.*phi
03:31:20 <lambdabot> Maybe you meant: quote vote
03:31:24 <opqdonut> @quote Cale.*sigma.*phi
03:31:24 <lambdabot> No quotes match. I've seen penguins that can type better than that.
03:31:25 <LeCamarade> @quote sigma
03:31:25 <lambdabot> Cale says: alpha beta gamma delta epsilon, zeta eta theta iota kappa lambda mu, nu xi, omicron pi, rho sigma tau, upsilon phi, chi psi omega... now I know my alpha beta gammas, next time won't you
03:31:25 <lambdabot> sing with me?
03:32:17 <LeCamarade> @quote 2038
03:32:17 <lambdabot> Bulat says: there is new Time library, which is supposed to replace old System.Time. we hope that it will happen before 2038
03:33:21 <LeCamarade> @quote ray
03:33:21 <lambdabot> ray says: some people claim everything is lisp. one time i was eating some spaghetti and someone came by and said "hey, nice lisp dialect you're hacking in there"
03:34:12 <opqdonut> :)
03:35:16 <LeCamarade> @quote passtime
03:35:16 <lambdabot> No quotes match. You speak an infinite deal of nothing
03:35:21 <LeCamarade> @quote passttime
03:35:21 <lambdabot> No quotes match. Have you considered trying to match wits with a rutabaga?
03:35:32 <LeCamarade> @quote pasttime
03:35:32 <lambdabot> nmessenger says: Brain explosion is like a traditional pasttime in #haskell
03:35:44 <LeCamarade> :o)
03:35:49 <opqdonut> :o) indeed
03:35:58 <ndm> quicksilver: i've sent back comments on your comments - i have to say that i didn't pick the examples to benefit uniplate - they were picked rather randomly
03:36:45 <Saizan> ?hoogle IntSet
03:36:49 <lambdabot> Data.IntSet :: module
03:36:49 <lambdabot> Data.IntSet.IntSet :: data IntSet
03:37:09 <EvilTerran> does GHC do preemptive multitasking?
03:37:41 <Saizan> ndm: ^^ yesterday we noticed that searching for a one word type doesn't return "constants" of that type, empty in this case
03:38:10 <ndm> Saizan: no, it gets interpetted as a string, rather than a type
03:38:14 <ndm> ?hoogle :: IntSet
03:38:14 <lambdabot> hoogle: Hoogle.Parser.readType: ([::,IntSet],BItem ::)
03:38:14 <lambdabot>  
03:38:24 <ndm> that works in Hoogle 4 :)
03:38:30 <ndm> and crashes Hoogle 3...
03:38:48 <ndm> ?hoogle -> IntSet
03:38:48 <lambdabot> hoogle: unrecognized option `->'
03:38:48 <lambdabot> unrecognized option `- '
03:38:48 <lambdabot> unrecognized option `-I'
03:38:48 <lambdabot> HOOGLE - Haskell API Search
03:38:48 <lambdabot> (C) Neil Mitchell 2004-2006, York University, UK
03:38:50 <lambdabot> [17 @more lines]
03:39:04 <Saizan> :D
03:39:28 <ndm> i'm sure there is some syntax to always do a type search in Hoogle 3, but i can't remember it, and its probably not documented anywhere
03:40:13 <Igloo> Wow, I don't think I've ever seen a program that would parse "- " as the space option before  :-)
03:40:15 <ndm> perhaps adding that "precise type search" on one word answers is a good idea as well
03:40:48 <Igloo> Oh, actually, I guess anything would, you'd just need to quote or escape it
03:40:50 <ndm> Igloo: hoogle has to do some tricks to get a -> b not be treated as a pipe
03:44:08 <Saizan> yeah, i'd add the type search, especially if the word is capitalized and turns out to be the name of a type
03:45:23 <ndm> i'll have a think about it
03:46:00 <ndm> @type empty
03:46:05 <lambdabot>     Ambiguous occurrence `empty'
03:46:05 <lambdabot>     It could refer to either `empty', imported from Control.Applicative
03:46:23 <ndm> @hoogle empty
03:46:23 <lambdabot> Data.IntMap.empty :: IntMap a
03:46:23 <lambdabot> Data.IntSet.empty :: IntSet
03:46:23 <lambdabot> Data.Map.empty :: Map k a
03:46:40 <ndm> doesn't really work for IntMap though, since empty isn't of type IntMap
03:48:22 <Igloo> Huh?
03:48:34 <Igloo> Oh, DYM IntMap a vs IntMap?
03:49:35 <ndm> yep
03:49:46 <ndm> hoogle 4 would report :: IntMap searches as a kind error
03:50:05 <ndm> hoogle 3 would find nothing, if i could even remember the syntax for it to do a one word type search
03:50:43 <Igloo> You could automatically add type variables if that's all that's needed to make it kind-correct
03:52:49 <ndm> it will automatically suggest that for Hoogle 4
03:52:54 <ndm> "did you mean ..."
03:53:06 <Igloo> Cool
03:53:18 <ndm> in some cases, i may choose to follow the suggestion without the users intervention, i'll have to see how that works out
04:04:19 <sevda> sevda1990_2007@yahoo.com
04:04:28 <sevda> selam burada turk varmi
04:05:24 <EvilTerran> ...um?
04:36:30 <EvilTerran> is it correct to say "const undefined" is strict in its (first) argument?
04:36:46 <EvilTerran> seeing as const undefined _|_ = _|_
04:36:52 <dmhouse> const undefined only has one argument.
04:36:55 <dmhouse> But yes, I think so.
04:37:07 <dmhouse> f _|_ = _|_ <=> f is strict, I believe.
04:37:07 <EvilTerran> > const undefined :: a -> b -> c
04:37:09 <lambdabot>  Add a type signature
04:37:18 <dmhouse> > const undefined :: b -> c
04:37:18 <lambdabot>  Add a type signature
04:37:26 <EvilTerran> i thought so
04:37:32 <dmhouse> :t const undefined
04:37:34 <lambdabot> forall a b. b -> a
04:37:45 <EvilTerran> i felt compelled to say "first" because you could type it to take several if you wanted
04:37:47 <dmhouse> It clearly only takes one argument, you didn't need to think about its type for that. :)
04:37:48 <Igloo> If you have a single-bottom view of the world, yes
04:38:03 <quicksilver> dmhouse: you can instantiate it to a -> b -> c if you wish
04:38:11 <quicksilver> dmhouse: so it does take as many arguments as you wan
04:38:25 <dmhouse> Hmm, yes, I suppose.
04:38:28 <dmhouse> > const undefined ()
04:38:29 <lambdabot>  Undefined
04:38:33 <dmhouse> > const undefined () ()
04:38:34 <lambdabot>  Undefined
04:38:50 <roconnor> hmm
04:39:05 <dmhouse> EvilTerran: well, it's strict in all of its arguments, then. :)
04:39:06 <quicksilver> EvilTerran: actually const undefined _|_ is not _|_ though
04:39:07 <roconnor> but it doesn't force evalutation of it's argument!
04:39:13 <dmhouse> roconnor: neither does id.
04:39:14 <quicksilver> EvilTerran: it's \_ -> _|_
04:39:31 <quicksilver> erm
04:39:32 <dmhouse> quicksilver: err... it is?
04:39:35 * EvilTerran is trying to think up a strict function :: ((Bool -> Bool) -> Bool) -> Bool that is distinct from (\f -> f id) and (\f -> f not)
04:39:36 <quicksilver> hang on thats not true
04:39:37 <quicksilver> :0
04:39:57 <quicksilver> > const undefined undefined `seq` 5
04:39:58 <lambdabot>  Undefined
04:40:06 <roconnor> I thought strictness  was about forcing arguments.
04:40:10 <quicksilver> > \_ -> undefined `seq` 5
04:40:11 <lambdabot>  Add a type signature
04:40:19 <Saizan> it's not const that make the computation blow however, it's the fact that you inspect the return value
04:40:25 <EvilTerran> i've currently got cheaty things like using seq, if <foo> then <bar> else <bar>, or const undefined
04:40:28 <quicksilver> roconnor: this is a contrapositive type argument
04:40:45 <quicksilver> roconnor: strictness says that if you ever return, you force your arguments
04:40:51 <dmhouse> roconnor: not necessarily. if you force (id x), then x gets forced, as it has to be returned.
04:41:03 <quicksilver> roconnor: so if you never return, you're strict 'vacuously'
04:41:14 <dmhouse> roconnor: but, for example, if you force (const () x), then x won't get forced.
04:41:49 <dmhouse> So a function is strict iff, when you force an application of an argument to that function, it forces that argument.
04:42:04 <roconnor> If we say that undefined is not _|_ do we get away iwth (const ()) not being strict?
04:42:05 <dmhouse> Well, s/it forces that argument/that argument gets forced/.
04:42:25 <dmhouse> roconnor: ? of course undefined is _|_, what do you mean?
04:42:53 <dmhouse> And no-one's trying to say (const ()) is anything other than lazy :)
04:42:56 <roconnor> dmhouse: you are probably right
04:43:21 <roconnor> so what is const () strict and lazy?
04:43:29 <dmhouse> No, const () is lazy.
04:43:34 <dmhouse> Who said it was strict?
04:43:46 <dmhouse> const undefined is strict, but that's different.
04:43:53 <roconnor> [13:36] <dmhouse> f _|_ = _|_ <=> f is strict, I believe.
04:44:09 <dmhouse> roconnor: yes, and const () _|_ is not _|_.
04:44:12 <roconnor> oh right
04:44:28 <roconnor> const undefined.
04:44:33 <roconnor> is strict
04:44:33 <dmhouse> ... is strict.
04:44:41 <roconnor> but it is a stupid function anyways
04:44:45 <dmhouse> Hehe.
04:44:51 <roconnor> so I'm willing to let it be strict
04:44:57 <dmhouse> The easiest way to force something is to pattern match against it.
04:45:00 <dmhouse> So, for example:
04:45:36 <dmhouse> > let (x, _) = undefined in x -- we force undefined to whnf to check it's a pair. Forcing undefined halts our program.
04:45:37 <lambdabot>  Undefined
04:46:18 <dmhouse> > let (x, _) = id undefined in x -- we force id undefined, which amounts to forcing undefined, so because id "doesn't stop the forcing", id is strict.
04:46:19 <lambdabot>  Undefined
04:46:38 <roconnor> dmhouse: that help!
04:46:42 <roconnor> helps!
04:46:51 <opqdonut> > let (x, _) = (const (1,2)) undefined in x
04:46:52 <lambdabot>  1
04:46:53 <dmhouse> > let (x, _) = const (3, 4) undefined in x -- we force const (3, 4) undefined, which doesn't involve forcing undefined, so const (3, 4) is lazy.
04:46:54 <lambdabot>  3
04:47:01 <opqdonut> :)
04:47:19 <dmhouse> So a function f is strict iff, when you evaluate f x to whnf, you must evaluate x to whnf.
04:47:26 <pastorn> > const (3,4)
04:47:26 <lambdabot>  Add a type signature
04:47:32 <pastorn> > const (3,4) :: Int
04:47:33 <lambdabot>  Couldn't match expected type `Int'
04:47:36 <dmhouse> That's equivalent to saying that f _|_ = _|_.
04:47:40 <pastorn> @type const
04:47:42 <lambdabot> forall a b. a -> b -> a
04:47:45 <dmhouse> pastorn: const (3, 4) is a function that, whatever you pass it, returns (3, 4).
04:47:56 <roconnor> dmhouse: um does const undefined x evaluate x to whnf?
04:47:59 <opqdonut> :t const (3,4)
04:48:01 <lambdabot> forall t t1 b. (Num t, Num t1) => b -> (t, t1)
04:48:42 <pastorn> > const 0 1
04:48:44 <lambdabot>  0
04:48:53 <araujo> morning
04:49:01 <opqdonut> morn'
04:49:36 <EvilTerran> > const (error "first") (error "second")
04:49:37 <lambdabot>  Exception: first
04:49:51 <dmhouse> roconnor: hmm, interesting. I suppose it needn't, but suppose you had some imaginary function const' such that const' undefined x that _did_ force x, const undefined and const' undefined would be behaviourally equivalent.
04:49:57 <EvilTerran> roconnor, no; const is not strict in its second parameter
04:50:21 <EvilTerran> altho const undefined is strict in its first parameter
04:50:38 <dmhouse> roconnor: i.e., no, but you can't prove it doesn't.
04:51:17 <Saizan> dmhouse: you can if you can discern among _|_s
04:51:39 <dmhouse> Saizan: yes, hence Igloo's comment that const undefined is strict iff you have a "one-bottom view" of the world.
04:52:16 <dmhouse> Denotationally, undefined = error "hello".
04:52:25 <dmhouse> (They're both denoted by _|_.)
04:52:41 <dmhouse> Operationally, they're different, I guess.
04:53:16 <quicksilver> dmhouse: they're observably different in the prescence of Control.Exception.catch
04:53:32 <quicksilver> dmhouse: at which point, I think that naive denotation becomes 'inadequate'
04:53:44 <dmhouse> True.
04:53:45 <quicksilver> dmhouse: in that programs with the same denotation can be arbitrarily different
04:54:21 <quicksilver> IIRC, the exception paper does outline a denotation which encompasses that
04:54:34 <quicksilver> although I'm pretty it doesn't prove hard stuff about it
04:54:44 <quicksilver> long time ago I read it :)
04:55:04 <Saizan> also saying that a function is strict because it always return _|_ doesn't feel right to me
04:55:55 <roconnor> const (firstTwinPrime) x
04:56:04 <roconnor> er
04:56:05 <dmhouse> Well, it's a corner case, and it depends on whether you're talking denotational or operational semantics (and therefore what you mean by 'strict'), and whether your denotational semantics assigns the same denotation to everything with type forall a. a, or not.
04:56:08 <roconnor> bad example
04:56:15 <roconnor> const (firstOddPerfectNumber) x
04:56:39 <DRMacIver> lastTwinPrime would also work :)
04:56:52 <dmhouse> roconnor: yes, that's again denotationally bottom (under the normal denotaitonal sematics), but operationally distinct from many other bottom-denotating expressions.
04:57:07 <roconnor> DRMacIver: lastTwinPrime is not clearly semidecidable.
04:57:18 <DRMacIver> Hmm. True.
04:57:30 <dmhouse> Yes, that may not be bottom at all ;)
04:57:56 <dmhouse> Let's work out its denotation and thereby prove a long outstanding mathematical conjecture! :)
04:58:43 <hpaste>  dankna pasted "Mysterious HOC type error" at http://hpaste.org/210
04:58:53 <dankna> so yeah, I'm attempting to learn Haskell :)
04:59:09 <dankna> perhaps it is not the best decision to do this by using the HOC binding to the Cocoa API
04:59:28 <dankna> but anyway I was hoping somebody would have the spare time to help me figure out this type error that I've been staring at for an hour
04:59:59 <dankna> at some level I get what it's telling me, but as for what I can do about it...
05:02:03 <Saizan> dankna: well, what's the type of setMainMenu?
05:02:28 <dankna> good question, I'll have to dig into header files for that.  I mean, its ObjC type is that it takes a pointer to NSMenu and returns void.
05:02:51 <quicksilver> you don't have to dig into header files :)
05:02:51 <dankna> it's a method, so the way HOC maps it is that it takes two arguments, the NSMenu followed by the object it's being called on
05:02:55 <quicksilver> just type :t setMainMenu
05:02:58 <quicksilver> at a ghci prompt
05:02:58 <Saizan> dankna: also, newmenu has a quite strange type, it's returning an IO action that returns () inside IO
05:03:30 <dankna> sadly, it's also possible that HOC itself is broken, since it hasn't been updated in a while, but I'm working on the assumption the problem is in my code
05:03:38 <dankna> thanks, quicksilver :) trying that
05:03:40 <Saizan> ah, no sorry, i've misread ID as IO
05:04:09 <quicksilver> dankna: newmenu is return an ID (presumably the 'ID' of the menu?)
05:04:24 <quicksilver> dankna: setMainMenu wants the 'actual NSMenu object'
05:04:37 <quicksilver> dankna: I'm guessing there may be some kind of 'lookup' function
05:04:40 <dankna> hmm.
05:04:44 <quicksilver> that lets you get a NSMenu from an ID
05:04:47 <quicksilver> but I'm only guessing, there
05:04:51 <dankna> well, it would be more a typecast than a lookup
05:05:11 <dankna> ID means "pointer to any ObjC object", NSMenu means "pointer to an NSMenu", sort of.  in ObjC terms.
05:05:12 <dankna> hmm.
05:05:14 <quicksilver> if it isn't obvious, I've never used HOC :)
05:05:18 <dankna> I know :)
05:05:22 <dankna> that's fine
05:05:25 <quicksilver> well tehre should be some kind of 'safe cast'
05:05:27 <quicksilver> I suspect
05:05:31 <quicksilver> which casts but only if that makes sense
05:05:36 <quicksilver> and throws a runtime error if not
05:05:45 <dankna> seems logical...
05:05:56 <quicksilver> or...
05:06:02 <quicksilver> is there just a bracketing problem?
05:06:06 <dankna> hm, setMainMenu :: (Has_setMainMenu target) => NSMenu t1[a66zV] -> target -> IO ()
05:06:22 <dankna> you mean, a syntax issue?
05:06:23 <quicksilver> I think _NSMenu might be the name of the cast
05:06:26 <quicksilver> (guessing here)
05:06:48 <dankna> don't think so.  _NSMenu refers to, uh, the object representing the class itself
05:06:49 <quicksilver> I'm wondering about the relative precedence of # and >>=
05:06:55 <dankna> hmm,
05:07:04 <quicksilver> look at how you use _NSApplication in the first line
05:07:07 <quicksilver> that looks cast-like to me
05:07:38 <dankna> I see where you get that, but what it's actually doing is calling the sharedApplication method, which is a class method not an instance method so the left side of the # is the class object
05:07:45 <quicksilver> Oh.
05:07:48 <quicksilver> understood
05:08:07 <Saizan> so o # m = m o?
05:08:10 <dankna> I'm sure glad I at least understand the ObjC side of what's going on or I'd be totally confused
05:08:21 <dankna> Saizan: as I understand that, yes
05:08:24 <quicksilver> can you find out the type of  _NSMenu # alloc , please?
05:08:41 <dankna> _NSMenu # alloc :: IO (NewlyAllocated (ID (NSObject_ (NSMenu_ ()))))
05:08:53 <quicksilver> hmm
05:09:03 <quicksilver> and what's the type of initWithTitle ?
05:09:16 <dankna> initWithTitle :: (Has_initWithTitle target) =>
05:09:16 <dankna> NSString t1[a4Dk0] -> NewlyAllocated target -> IO target
05:09:24 <quicksilver> ah
05:09:26 * dankna reads what he just pasted and ponders
05:09:39 <quicksilver> and autorelease?
05:09:48 <dankna> autorelease :: (Has_autorelease target) => target -> IO (ID ())
05:09:53 <quicksilver> aha!
05:09:58 <quicksilver> that looks like the culprit
05:10:12 <dankna> ah, I see.  because autorelease is common to almost all classes, it returns an ID instead of something more specific
05:10:13 <quicksilver> autorelease si throwing away your NSMenu_, sin't it?
05:10:18 <dankna> hmm yes
05:10:51 <Saizan> so you need something (ID (NSObject_ (NSMenu_ ()))) -> (NSObject_ (NSMenu_ ()))
05:11:14 <dankna> yes, I see.  hm.  there might be a specific one or something...
05:11:38 <quicksilver> or you can just save the NSMenu from before?
05:12:14 <quicksilver> mymenu <- _NSMenu # alloc >>= initWithTitle (toNSString title) ; autorelease mymenu; return mymenu
05:12:17 <quicksilver> perhaps?
05:12:20 <Saizan> quicksilver: it's always inside ID, but that could just be a pattern match
05:12:34 <quicksilver> Saizan: yes, I hope it is :)
05:12:40 <dankna> hm!
05:12:49 <quicksilver> Saizan: I think some of these might be newtypes than can be automatically unwrapped
05:12:52 <quicksilver> Saizan: but I'm not sure :)
05:12:58 <Saizan> dankna: :i ID on ghci :)
05:13:27 <LoganCapaldo> I think quicksilver has the right idea
05:13:30 <dankna> *Main> :i ID
05:13:30 <dankna> data ID a = HOC.ID.ID HOC.ID.HSO | HOC.ID.Nil   -- Defined in HOC.ID
05:13:30 <dankna> instance Eq (ID a) -- Defined in HOC.ID
05:13:30 <dankna> instance SuperClass (NSProxy ()) (ID ())
05:13:30 <dankna>   -- Defined in Foundation.NSProxy.Forward
05:13:35 <dankna> instance SuperClass (NSObject ()) (ID ())
05:13:37 <dankna>   -- Defined in Foundation.NSObject.Forward
05:13:39 <dankna> instance ClassAndObject (Class a) (ID a) -- Defined in HOC.Class
05:13:41 <dankna> instance Object (ID a) -- Defined in HOC.ID
05:13:44 <dankna> (bit long to paste in-channel, but you asked; let me know if that's not okay)
05:13:58 <quicksilver> yes, there is a lot of magic autopromotion going on int those type calsses
05:14:00 <quicksilver> I strongly suspect
05:14:05 <LoganCapaldo> you usually say return [foo autorelease]; in Obj-C but it gives you back the pointer anyway
05:14:50 <hpaste>  quicksilver annotated "Mysterious HOC type error" with "try this?" at http://hpaste.org/210#a1
05:15:30 <quicksilver> LoganCapaldo: here it gives back the pointer but losing the type information, which is not what we want
05:15:34 <dankna> hm!  and it works
05:15:38 <quicksilver> LoganCapaldo: so I'm thinking to save the type info first
05:15:47 <LoganCapaldo> yeah exactly
05:15:51 <dankna> that approach makes sense
05:15:56 <LoganCapaldo> which is why i think you have the right idea :)
05:16:05 <dankna> I even think I like it better than some sort of safe-cast if there is such an operator, which I can't confirm
05:16:12 <quicksilver> < dankna> autorelease :: (Has_autorelease target) => target -> IO (ID ())
05:16:26 <quicksilver> I don't understand why not autorelease :: (Has_autorelease target) => target -> IO (target)
05:16:37 <quicksilver> if they want to preserve the ObjC idiom you're talking about
05:16:41 <dankna> that makes more sense, heh.
05:16:46 <quicksilver> or, IO ()
05:16:51 <quicksilver> if they wish to discard the idiom
05:16:57 <quicksilver> but just returning IO ID () is odd
05:16:58 <quicksilver> (IMO)
05:17:02 <quicksilver> maybe I miss something, though :)
05:17:09 <dankna> well, HOC is written in Template Haskell and is a bit beyond my ken.  it could just be a bug or something the author didn't think of.
05:17:23 <dankna> I'll revisit that question in a couple months when I have the expertise
05:17:25 <LoganCapaldo> well if ID is supposed to be ObjCs id, then autorealease has the same type it does in ObjC
05:17:26 <quicksilver> or an infelicity in his deeply nested stack of sick, sick typeclasses :)
05:17:43 <dankna> meanwhile, thank you!
05:17:44 <LoganCapaldo> its just that you'd write newmenu to have a type such that it would end up being casted
05:18:25 <LoganCapaldo> ie (NSMenu *)newmenu: (NSString *)title;
05:19:05 <LoganCapaldo> but that doesn't really fly in  Haskell afaik
05:19:13 <dankna> quite so
05:19:25 <TSC> Where should one report a library bug to?
05:19:34 <TSC> (in the GLUT library)
05:24:03 <Saizan> uhm libraries@ maybe?
05:26:10 <therp> is http://darcs.haskell.org/cabal identical to http://darcs.haskell.org/packages/cabal?
05:26:12 <lambdabot> Title: Index of /cabal
05:27:16 <dankna> the latter, um, doesn't exist?
05:27:55 <Igloo> therp: One's a symlink to the other
05:28:18 <therp> dankna: oh misspelled. /packages/Cabal. thanks igloo
05:29:45 <therp> http://hpaste.org/192
05:30:20 <therp> ah I though lambdabot would give a page title: shared libraries are coming :)
05:30:47 <dankna> that'll be nice!
05:31:14 <therp> that's why I was asking which one is the correct Cabal repo, as I have patches ready soon..
05:31:18 * Igloo wonders why it didn't; does it ignore hpaste on the assumption pastes iwll be announcned?
05:31:35 <Saizan> ?where glib
05:31:35 <lambdabot> I know nothing about glib.
05:32:06 <Saizan> too short url?
05:33:51 <quicksilver> Igloo: yes, I think it does
05:34:01 <quicksilver> Igloo: people complained about the spam
05:34:04 <quicksilver> Igloo: 3 lines per paste
05:34:11 * quicksilver uses 4 lines to make a short comment
05:34:25 <SamB> Igloo: exactly
05:34:47 * SamB thinks it should just ignore paste announcements from the hpaste bot
05:34:58 <noj> ha
05:34:59 <SamB> (not by name, though)
05:35:03 <noj> oops, wrong channel
06:00:37 <SamB_XP_> huh. I thought webcomic artists went to comic cons, not SIGGRAPH!
06:00:58 <Jaggederest> if they're lucky, both
06:03:08 <ndm> finally, i've released Catch, after over two years of work!
06:03:18 <SamB_XP_> http://www.gpf-comics.com/shows/siggraph2007/
06:03:21 <lambdabot> Title: GPF: The SIGGRAPH 2007 Pre-Con Report
06:04:01 <SamB_XP_> but it looks like maybe he's not wearing the webcomic artist hat...
06:04:03 <kolmodin> ndm: well done!
06:04:12 <SamB_XP_> ndm: nice
06:04:35 <SamB_XP_> now if I can figure out how to use it on my embedded C program, I'll be all set
06:05:30 <ndm> SamB_XP_: why are you writing in C?
06:06:14 <SamB_XP_> can you implement the MMC protocol in Haskell -- in 30k of RAM?
06:06:27 <ndm> no
06:06:32 <SamB_XP_> (the first 2k are given over to registers)
06:06:54 <SamB_XP_> now, I do have 256k of flash for program storage...
06:07:17 <SamB_XP_> not sure what units that is, though ;-)
06:08:21 <SamB_XP_> (24-bit instructions? 16-bit words, though half would be only bytes really? bytes?)
06:09:10 <SamB_XP_> I suppose I could scroll the "Program Memory" view all the way down...
06:09:48 <quicksilver> ndm: woo :)
06:10:36 <SamB_XP_> the highest instruction address I'm seeing is 2ABFE...
06:12:14 <SamB_XP_> > (0x2ABFE+2)*3/4 :: Rational
06:12:19 <lambdabot>  131328%1
06:12:23 <ddarius> @google Virgil OO
06:12:25 <lambdabot> http://lambda-the-ultimate.org/node/2131
06:12:25 <lambdabot> Title: Virgil: Objects on the Head of a Pin | Lambda the Ultimate
06:12:37 <kfish> ndm, congrats
06:13:27 <ddarius> SamB_XP_: So bytes?
06:13:28 <ndm> thanks everyone :)
06:13:43 <ndm> now lets see if anyone is able to use it...
06:13:43 <SamB_XP_> ndm: I have no clue
06:14:00 <SamB_XP_> that calculation wasn't very illuminating...
06:14:27 <ddarius> > 0x2ABFE
06:14:29 <lambdabot>  175102
06:14:53 * SamB_XP_ goes to look at a datasheet
06:15:29 <wwwww> i have a program that is giving me a type error
06:15:46 <wwwww> *** Type           : [[a]]
06:15:46 <wwwww> *** Does not match : [a]
06:16:08 <ari> hpaste: url
06:16:08 <hpaste> Haskell paste bin: http://hpaste.org/
06:16:11 <ari> wwwww: Indulge us
06:16:36 <roconnor> > exp (-1)
06:16:37 <lambdabot>  0.36787944117144233
06:17:14 <hpaste>  wellwisher pasted "Prime : type mismatch" at http://hpaste.org/211
06:17:15 <ddarius> > exp (0 :+ pi)
06:17:16 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
06:17:41 <wwwww> it is posted
06:18:12 <fasta> Is the RHS of a executed first let !a = <something;b = something else; c=something else? Or is there no guarantee?
06:18:21 * SamB_XP_ has possibly mistaken the meaning of the dsPIC33FJ256GP710 designator
06:18:45 <wellwisher> ?
06:19:53 <wellwisher> any help on "Prime : type mismatch" at http://hpaste.org/211 ?
06:20:27 <wellwisher> type mismatch on line 19
06:20:47 <ari> wellwisher: I'm on it
06:20:57 <wellwisher> ns ++ hm
06:21:15 <wellwisher> is what it is complaining about
06:21:22 <dmhouse> ?tell roconnor http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_and_strict_functions -- just written, feedback appreciated :)
06:21:22 <lambdabot> Consider it noted.
06:21:35 <hpaste>  ari annotated "Prime : type mismatch" with "(no title)" at http://hpaste.org/211#a1
06:21:42 <quicksilver> wellwisher: 'hm' is a single element
06:21:49 <quicksilver> wellwisher: you can't ++ to a single element
06:22:11 <wellwisher> o duh
06:22:33 <quicksilver> maybe you mean ns ++ [hm]
06:22:34 * dmhouse goes for lunch
06:22:35 <SamB_XP_> okay... apparantly it has room for 88k instructions, whereas the dsPIC33FJ128GPXXX models have room for 44k instructions and the 'J64' models have room for 22k
06:24:08 <ari> quicksilver: Also, the type of prime you gave meant that it should have worked on lists of anything, but due to using mod it can only work on lists of integers
06:24:11 <ari> Uhm
06:24:18 <SamB_XP_> I have *no idea* how that relates to the model numbers :-(
06:24:18 <ari> wellwisher: What I just said
06:24:34 <quicksilver> yes, that's true
06:24:39 <quicksilver> that type sig won't match
06:24:40 <quicksilver> :t mod
06:24:49 <lambdabot> forall a. (Integral a) => a -> a -> a
06:24:51 <ddarius> SamB_XP_: ?
06:24:53 <wellwisher> i relize that
06:25:02 <quicksilver> integral would be the best you oculd hope for
06:25:58 <wellwisher> thanxs for the help
06:32:45 <SamB_XP_> hmm.
06:33:04 <SamB_XP_> > 88*3
06:33:08 <lambdabot>  264
06:33:29 <SamB_XP_> oh, well, I guess it sorta does have some resemblance to the number of bytes...
06:36:21 <SamB_XP_> of course, each model actually has 256*3 more bytes before that, for a reset address and two interrupt vector tables... and 6 reserved bytes...
06:37:19 <adrian> hi. i'm curious about one thing. if a data structure like hashmap is implemented using haskell's lists (or else), then each time i wan to insert some value, the function cannot modify the structure in place, but has got to return the _new_ hashtable with modified element
06:37:42 <adrian> I guess the old hashmap get's gc'ed, but how can this be efficient.
06:38:06 <adrian> making a copy of a big hashmap each time i add something and gc'ing it seem to be lengthy operations.
06:38:25 <SamB_XP_> adrian: yeah. that is why you should use a different data structure...
06:38:41 <SamB_XP_> (the copying especially is lengthy)
06:38:54 <adrian> samb: what are the other possible data structures?
06:39:07 <SamB_XP_> well, we have a nice Data.Map over here
06:39:16 <SamB_XP_> it uses binary search trees
06:39:17 <adrian> and inserting modifies it in place?
06:39:31 <SamB_XP_> no, it just doesn't need to copy the whole tree
06:39:46 <adrian> oh, but it is pure haskell?
06:39:50 <SamB_XP_> yup!
06:40:52 <adrian> ok. so you say that Data.Map should be my choice when i need hashtable/dictionary functionality? i saw some edison library and others.
06:42:23 <SamB_XP_> hmm, you probably won't need edison for the mapping data structures...
06:43:08 <SamB_XP_> anyway, Data.Map works well for most needs
06:43:33 <adrian> i remember there was a problem with ghc 6.4 on alioth speed comaprison.
06:43:44 <adrian> haskellers had to implement the hashtable from scratch
06:43:50 <adrian> let me find the link...
06:44:28 <adrian> oh, it's here: http://www.nabble.com/Hashtable-woes-t977504.html
06:44:31 <lambdabot> Title: Nabble - Hashtable woes
06:44:32 <SamB_XP_> well, we do have hashtables. but we don't *like* them much, because we have to write imperative code in order to use them...
06:44:33 <quicksilver> adrian: data.map is fine
06:44:36 <adrian> and here: http://shootout.alioth.debian.org/gp4/benchmark.php?test=knucleotide&lang=all
06:44:38 <lambdabot> Title: k-nucleotide benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Lang ..., http://tinyurl.com/mnnkb
06:44:43 <quicksilver> adrian: hashtables are not that often needed
06:46:12 <adrian> well, I know. as long as i keep things functional haskell is great. but for some real world needs (i'm writing haskell webcrawler) i really need hashtables and mutable arrays in my imperative code
06:46:38 <osfameron> adrian: there's a good chapter on a fucntional webcrawler in Dominus's HOP
06:47:03 <osfameron> obviously that's using Perl and only the APIs are functional (e.g. internally he uses mutable Perl, but it's all encapsulated)
06:47:30 <osfameron> but it might make an interesting read, I think his code ended up being a lot nicer and more flexible than the imperative version
06:47:32 <adrian> osfameron: thanks, i'll take a look at it
06:48:11 <quicksilver> adrian: I doubt you do
06:48:15 <quicksilver> adrian: maybe you do, but I doubt it
06:48:25 <quicksilver> adrian: are you really sure that a Map is not good enough?
06:48:43 <adrian> quicksilver: no. i have no idea if Map is ok. I've never used it
06:48:53 <quicksilver> adrian: right, then you don't need a hashtable
06:48:55 <quicksilver> adrian: :)
06:49:08 <quicksilver> adrian: a hashtable is a very specific kind of algorithm
06:49:13 <quicksilver> adrian: which goes O(1) access time
06:49:18 <adrian> quickslv: :) ok, but when I need it, i'll look at Data.Map
06:49:28 <adrian> and what should I look like when I need extensible, mutable arrays?
06:49:31 <quicksilver> adrian: the haskell map primitives give O(log n) or O(log log n)
06:49:40 <quicksilver> adrian: and in many cases this is good enough
06:49:59 <quicksilver> adrian: you should consider your algorithm
06:50:09 <quicksilver> adrian: but of haskell has mutable arrays if that really is what you need
06:50:13 <quicksilver> (which it may well not be)
06:50:37 <fasta> quicksilver: log log n? What implementation gives that?
06:51:00 <fasta> quicksilver: I know of data structures with that property, I just don't believe Haskel has them already :)
06:51:57 <quicksilver> fasta: IntMap, I think?
06:52:21 <fasta> quicksilver: I don't know, but AFAIK, no.
06:52:58 <fasta> quicksilver: I checked and the answer is no
06:55:07 <fasta> I would like to do a horrible thing with CPP: given FOO(a b), it should create the code BAR(a);Zork b
06:55:17 <fasta> (cpphs)
06:55:23 <fasta> Is that possible?
06:55:50 <fasta> I don't want to use comma's to separate the arguments.
06:56:00 <quicksilver> fasta: no
06:56:07 <malcolmw> fasta: not possible with either cpp or cphs
06:56:14 <quicksilver> fasta: using commas is the only argument separation facility in cpp
06:57:07 <malcolmw> how could the preprocessor tell where the split between a and b lies without an explicit marker?
06:57:27 <malcolmw> FOO(something here with many spaces)
06:58:02 <quicksilver> fasta: m4 is a much more featureful macro language, although I don't know if it can do what you ask for
06:58:59 <fasta> malcolmw: if the preprocessor had an option to parse the strings that are passed as an argument it would be possible.
06:59:20 <LoganCapaldo> just feed it thru a haskell script :)
06:59:42 <malcolmw> fasta: why can't you use commas?
07:00:02 <fasta> malcolmw: I can, but I am lazy.
07:00:25 <balodja> hm-m-m, can ByteString.empty be used in patterns?
07:00:38 <LoganCapaldo> oh I know!. #define Z(X) X, #define A Z(a) FOO(A b)
07:00:49 <malcolmw> fasta: using commas will probably save work in the long run, if the alternative is to implement your own preprocessor :-)
07:01:22 <fasta> Maybe I should switch to Liskell ;)
07:01:24 <adrian> another thing. do ByteString support unicode (utf-8)?
07:01:53 <Saizan> balodja: no, you have to use a guard
07:02:09 <balodja> Saizan: that's awful :)
07:02:34 <LoganCapaldo> ByteString.empty  says "I'm not a constructor! I'm a free man!"
07:02:35 <Saizan> adrian: ByteStrings are only sequences of 8bits
07:03:05 <quicksilver> ByteString could have been written with an explicit, exported empty constructor.
07:03:08 <Saizan> adrian: there's Data.CompatString that's aware of encodings
07:03:12 <quicksilver> but that might well have been slower
07:03:19 <quicksilver> and would have added another invariant
07:03:23 <SamB_XP_> > Data.ByteString.empty
07:03:23 <lambdabot>   Not in scope: `Data.ByteString.empty'
07:03:32 <LoganCapaldo> an annoying invariant too
07:28:23 <adrian> hi. a newbie question. This program:
07:28:23 <adrian> import Data.Map as M
07:28:23 <adrian> main = do
07:28:23 <adrian>     let m = foldl (\m v -> M.insert v v m) M.empty [1..1000000]
07:28:23 <adrian>     putStrLn $ show $ M.size m
07:28:26 <adrian> gives me:
07:28:34 <adrian> Stack overflow error
07:28:47 <adrian> but foldl is tail recursive!? what's the problem here?
07:29:00 <quicksilver> you're building a huge unevaluated thunk
07:29:03 <adrian> Stack space overflow: current size 8388608 bytes.
07:29:03 <adrian> Use `+RTS -Ksize' to increase it.
07:29:11 <quicksilver> try using foldl'
07:29:19 <quicksilver> (yes, that's an apostrophe after the l)
07:29:54 <adrian> ok, so foldl' is strict :) where can I read about those "thunks"?
07:30:15 <adrian> i'd like to know how haskell works from inside and not ask any more dumb questions ;)
07:31:07 <earthy> thunks need not even be used in haskell implementations, but there's stuff by Simon Peyton-Jones that may give you a reasonable overview
07:31:23 <quicksilver> you could start here: http://www.haskell.org/haskellwiki/Haskell/Lazy_evaluation
07:31:24 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
07:31:33 <quicksilver> and follow some links
07:31:42 <adrian> ok, thx
07:31:44 <quicksilver> earthy: how could I implement haskell without thunks?
07:35:47 <Wild_Cat> as a strict language, in all likelihood.
07:36:17 <quicksilver> if it were strict, it would not be haskell
07:36:56 <Wild_Cat> well, it'd be "Haskell without thinks" ;)
07:37:00 <LoganCapaldo> strict haskell would be pretty useless for most of the existing code I imagine
07:37:01 <Wild_Cat> s/thinks/thunks/
07:37:21 <LoganCapaldo> althugh maybe not useless for new code
07:37:35 <earthy> quicksilver: think 'term graph rewriting'
07:38:06 <quicksilver> earthy: maybe I'm unaware of the very precise meaning of 'thunk'
07:38:23 <quicksilver> earthy: to my mind, that would be rather similar, with thunks being no-yet-rewritten terms
07:38:37 <fasta> I think thunk is used as an implementation technique by earthy
07:38:42 * earthy nods
07:38:51 <fasta> I don't agree with that terminology :)
07:38:56 <earthy> not-yet-rewritten terms would be redexes. ;)
07:39:11 <hpaste>  balodja pasted "(no title)" at http://hpaste.org/212
07:39:53 <quicksilver> I thought a thunk was just a suspended computation
07:39:59 <quicksilver> and a redex is definitely a suspended computation
07:40:33 <earthy> yeah, but I always understand a thunk in terms of an indirection with a pointer to the code to be executed
07:40:55 <earthy> whereas in a term graph rewrite system there need not be that pointer associated with a redex
07:41:03 <earthy> (not explicitly)
07:41:19 <earthy> but the distinction is rather artificial indeed
07:41:20 <balodja> so, at http://hpaste.org/212 I'm trying to add charset recoding to lambdabot, and I'm getting simple "parse error at |". could you poing me out, what's wrong in syntax?
07:41:27 <quicksilver> I could implement a lazy language inside a lazy language
07:41:36 <quicksilver> and use the outer thunking to implement the inner thunking
07:41:46 <quicksilver> and hence not need explicit pointers
07:41:51 <quicksilver> and by your definition not be a thunk :)
07:42:12 <fasta> I think the most popular notion of thunk is the most general.
07:42:15 <fasta> Hence, quicksilver's.
07:42:18 <balodja> ghc points "parse error" to the line with "| otherwise"
07:42:27 * earthy nods
07:42:34 * earthy is weird :)
07:42:45 <fasta> earthy: stop nodding, it makes me nervous ;)
07:42:54 <quicksilver> balodja: I think perhaps you can't use | guards with functions which have no argyments
07:42:57 <quicksilver> balodja: I'm not sure
07:42:58 * LoganCapaldo thinks he leans towards earthy's weirdness
07:43:46 <balodja> hm, seems reasonable
07:43:49 <quicksilver> balodja: no, that's not true. let me look more
07:43:52 <Igloo> balodja: The where clause has to go after all the guards
07:44:09 <balodja> oh
07:44:38 <quicksilver> ah :)
07:45:32 <quicksilver> balodja: I'm not sure that complex mixture of 'let' bindings and 'where' bindings is very sane to read
07:45:42 <quicksilver> balodja: you have to keep looking all the way up and all the way down, by turns
07:46:28 <balodja> eh, I'd like to get it working for the first time :)
07:46:39 <quicksilver> fair enough :)
07:48:46 <norpan> c++
07:50:44 <vegai> @karma c
07:50:44 <lambdabot> c has a karma of 15
07:54:52 <sjanssen> c++ is ignored, by the way
07:54:55 <sjanssen> @karma c
07:54:55 <lambdabot> c has a karma of 15
07:58:58 <vegai> @karma c++
07:58:58 <lambdabot> c++ has a karma of -6
07:59:01 <vegai> @karma java
07:59:01 <lambdabot> java has a karma of -18
07:59:04 <vegai> ow
07:59:07 <vegai> @karma erlang
07:59:07 <lambdabot> erlang has a karma of 0
07:59:11 <vegai> @karma sml
07:59:11 <lambdabot> sml has a karma of 0
07:59:24 <vegai> @karma python
07:59:24 <lambdabot> python has a karma of 1
07:59:26 * vegai shrugs.
07:59:29 <vegai> @karma haskell
07:59:30 <lambdabot> haskell has a karma of 24
07:59:50 <gds> @karma perl
07:59:51 <lambdabot> perl has a karma of 0
07:59:52 <schme> @karma lisp
07:59:52 <lambdabot> lisp has a karma of -1
07:59:56 <schme> hehehe.
07:59:56 <Japsu> -_-
08:01:20 <vegai> @karma perl6
08:01:20 <lambdabot> perl6 has a karma of 6
08:01:24 * vegai laughs.
08:02:07 <Jaak> @karma prolog
08:02:07 <lambdabot> prolog has a karma of -1
08:02:14 <Jaak> @karma ocaml
08:02:14 <lambdabot> ocaml has a karma of 0
08:02:16 <Jaak> hm
08:02:32 <geezusfreeek> how do you increase c's karma if c++ is ignored?
08:03:14 <geezusfreeek> or is it by a different notation anyway?
08:03:25 <geezusfreeek> i retract that, i don't really care :P
08:03:44 <LoganCapaldo> geezusfreeek: @karma+ c++
08:03:52 <geezusfreeek> aha
08:03:52 <LoganCapaldo> @karma c++
08:03:52 <lambdabot> c++ has a karma of -6
08:03:58 <LoganCapaldo> @karma+ c++
08:03:58 <lambdabot> c++'s karma raised to -5.
08:04:05 <LoganCapaldo> @karma- c++
08:04:05 <lambdabot> c++'s karma lowered to -6.
08:04:17 <geezusfreeek> yeah, i was about to say "put it back" ;)
08:04:44 <geezusfreeek> @karma ruby
08:04:44 <lambdabot> ruby has a karma of 0
08:04:57 <geezusfreeek> @karma squeak
08:04:57 <lambdabot> squeak has a karma of 0
08:05:21 <geezusfreeek> @karma lolcode
08:05:21 <lambdabot> lolcode has a karma of 0
08:05:27 <geezusfreeek> okay, enough
08:09:14 <ClaudiusMaximus> should i be using hsc2hs?  i'm finding it somewhat verbose and awkward, especially given the C API i'm wrapping has lots of "struct blah { union { foo *x, bar *y } quux; int which; }"
08:10:58 <dolio> c++++
08:11:01 <dolio> @karma c++
08:11:02 <lambdabot> c++ has a karma of -5
08:11:05 <dolio> c++--
08:11:07 <dolio> @karma c++
08:11:08 <lambdabot> c++ has a karma of -6
08:11:55 <norpan> wow
08:12:12 <norpan> incredible how a three character message could trigger all that :)
08:13:03 <geezusfreeek> we're programmers, therefore we are compulsive
08:13:12 <geezusfreeek> and obsessive even
08:13:48 <geezusfreeek> actually, i _wish_ i was obsessive… then i would get more done
08:14:28 <LoganCapaldo> I hate it when I get obsessive on a piece of code
08:14:35 <geezusfreeek> err... i think i'm following a strange definition of obsessive
08:14:38 <LoganCapaldo> thats always when I end up suddenly realizing its 6am
08:15:00 <LoganCapaldo> and that I didn't do any of that sleeping thing
08:16:09 <geezusfreeek> random thought: i wonder what the demographics are like in here? particularly academic types vs. others
08:18:33 <ClaudiusMaximus> geezusfreeek: i'm an artist (but that's rather unusual i think)
08:24:10 <geezusfreeek> my girlfriend will probably be learning haskell soon, and she is an art major at our university
08:24:18 <geezusfreeek> but then again, look at who her boyfriend is
08:24:39 <flux> who?
08:24:42 <geezusfreeek> and she also happens to like math
08:24:44 <flux> oh, right..
08:25:14 <geezusfreeek> just got to get her to move one from ruby
08:25:18 <geezusfreeek> *move on
08:35:16 <DRMacIver> I don't understand the craze for Ruby.
08:37:01 <emu> c++ programmers discovering that coding doesn't have to suck
08:37:01 <LoganCapaldo> DRMacIver: You don't understand the craze for ruby because its not that great, or you just don't understand why the hype machine picked ruby?
08:37:10 <DRMacIver> Both.
08:37:37 <LoganCapaldo> I'm of the opinion that the answer to both questions is perl
08:37:45 <quicksilver> DRMacIver: because it feels like a small step from perl and python, both popular languages
08:37:48 <vegai> DRMacIver: marketing
08:38:03 <int-e> gems are shiny
08:38:04 <DRMacIver> Maybe I'd find differently if I used it (which I will be doing soon), but the feature set Ruby offers seems to be a badly implemented version of some features which, while admittedly cool, are seriously old news.
08:38:06 <quicksilver> DRMacIver: yet it incorporates useful abstractions making the language able to be more concisely expressive than either of those two
08:38:16 <quicksilver> and rails, too, of course
08:38:16 <vegai> quicksilver: to what direction is it a step from python?
08:38:30 <LoganCapaldo> vegai: sideways, like a crab <g>
08:39:15 <daniel_larsson> I'd say rails have a lot to do with it.
08:39:25 <DRMacIver> Undoubtedly.
08:41:04 <daniel_larsson> It's an improvement over php at any rate (IMO)
08:41:23 <DRMacIver> Sure
08:41:28 <DRMacIver> I'm not even saying it's a bad language.
08:42:15 <DRMacIver> (Although issues such as scoping rules and performance might lean me towards saying it's a bad language :) )
08:42:45 <LoganCapaldo> well peformance issues just mean its a bad implementation :)
08:42:57 <DRMacIver> It's just... all the things which make Rubyists shout "OH my god! So cool! Can ur language do THIS?!?!" make me say "Yes. And it's been able to do that for decades."
08:43:06 <vegai> DRMacIver: indeed.
08:43:19 <DRMacIver> Hell, even Javascript has most of the features which they drool over. :)
08:43:30 <DRMacIver> (It's prototype rather than class based, but that's a feature rather than a bug)
08:43:40 <dmhouse> Javascript's actually a pretty cool languages.
08:43:42 <dmhouse> *language
08:43:46 <DRMacIver> Yeah.
08:43:48 <daniel_larsson> I don't like the way you can redefine module contents from anywhere. Which is supposedly a big feature
08:44:01 <DRMacIver> Modulo my previous complaints about debugging the damn stuff. :)
08:44:41 <dmhouse> Yeah, well, it's no harder than, ooh, I dunno, Haskell. :)
08:44:57 <daniel_larsson> Trying to understand exactly what happens when calling a method on some class becomes a hideous struggle, trying to chase down exactly what file redefined the behaviour of some base class
08:45:08 <DRMacIver> dmhouse: No, but you have to do it a lot more than you do for Haskell. :)
08:45:27 <dmhouse> True.
08:45:44 <dmhouse> I saw a slideshow documenting what was planned for JS2.0 once, it looked really very cool indeed.
08:46:01 <DRMacIver> Yeah. But JS3.0 is planning ot migrate it to class based OO. Sigh.
08:46:16 <DRMacIver> (Although does include a wealth of really really cool features to make up for the disappointment)
08:47:14 <dmhouse> I think http://developer.mozilla.org/presentations/xtech2006/javascript/ was it.
08:47:16 <lambdabot> Title: JavaScript 2 and the Future of the Web
08:47:43 <dmhouse> It'll have a type system!
08:48:15 <dmhouse> Albeit duck typed.
08:48:39 <DRMacIver> Yes, that will be greatly appreciated. :)
08:49:21 <LoganCapaldo> duck-typed type-system == structural subtyping no?
08:49:35 <dmhouse> And "destructuring assignment" -- pattern matching -- and all kinds of sugar including array (= list) comprehensions.
08:49:38 <DRMacIver> Yeah
08:49:53 <DRMacIver> Although destructuring assignment isn't really pattern matching. :)
08:50:17 <LoganCapaldo> its a very rudimentrary form of pattern matching :)
08:50:21 <DRMacIver> (it serves very similar purposes though)
08:50:26 <LoganCapaldo> pre-cambrian pattern matching
08:50:30 <daniel_larsson> hehe
08:52:09 <dmhouse> Ooh, parametric types too.
09:01:45 <geezusfreeek> ruby's main benefit to me is that is offers these features with a concise, readable syntax… a PL enthusiast such as myself won't drool much over its feature set, but it is still very practical for your everyday tasks and pretty nice for larger projects too
09:02:17 <geezusfreeek> imo, rails is the worst thing that could have happened to ruby
09:03:32 <geezusfreeek> turned it into nothing more than a web language
09:04:47 <daniel_larsson> On the other hand, it probably increased the number of ruby programmers by a magnitude or two )
09:05:19 <geezusfreeek> maybe so, but i doubt many of them use ruby for anything but rails
09:05:31 <daniel_larsson> Probably true
09:09:25 <therp> anyone writing on xft interface bindings? if no, than I guess I'll start now
09:09:25 <therp> s/than/then/
09:09:25 <benny99> hi
09:09:48 <Vulpyne> Make some good MySQL bindings instead. :)
09:10:11 <daniel_larsson> Thought there were several?
09:10:31 <Vulpyne> Well, there seems to be two choices: HQSL and HDBC.
09:10:38 <Vulpyne> HDBC doesn't support MySQL, you have to use ODBC.
09:11:03 <Vulpyne> HSQL has very few features - it doesn't even provide a string escaping function, no support for precompiling statements or doing substitution.
09:13:12 <DRMacIver> geezusfreeek: I have to admit, I find the syntax... unappealing. Maybe I'll get over it.
09:15:53 <takamura> hi
09:16:06 <takamura> > pl \f x y -> f x y
09:16:06 <lambdabot>  Parse error
09:16:35 <DRMacIver> @pl \f x y -> f x y
09:16:35 <lambdabot> id
09:16:52 <ari> @type \f x y -> f x y
09:16:56 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> t -> t1 -> t2
09:17:12 <DRMacIver> pl will often widen the type.
09:17:35 <geezusfreeek> DRMacIver: it might depend on your programming style. i've seen some pretty ugly ruby code before too, and i suspect that it's not because of incompetency but because people are trying to use it differently from what it was designed for
09:18:29 <DRMacIver> geezusfreeek: Maybe. But the syntax just seems inherently fairly unappealing to me. And given that I often try to use things in unconventional ways, a language which looks bad when I do so is less than desireable. :)
09:18:50 <takamura> mm I still don't understand why it is id... let me think for a moment...
09:19:20 <sjanssen> Vulpyne: can you use HSQL as a backend for haskelldb?
09:19:28 <geezusfreeek> to be honest, i'm not that big on the way the metaprogramming works in ruby
09:19:41 <Vulpyne> sjanssen: You can, yes.
09:19:47 <takamura> @pl \f x -> f x
09:19:47 <lambdabot> id
09:19:50 <geezusfreeek> it's hard to compete with Lisp or Io for that
09:20:01 <Vulpyne> sjanssen: But it kind of seems like it would be even worse (if you care about performance)
09:20:12 <DRMacIver> Ah, an Io fan. They do exist! :)
09:20:17 <geezusfreeek> :)
09:20:22 <takamura> mm I' trying to obtain the equivalent of ($) for functions of 2 arguments
09:21:04 <sjanssen> Vulpyne: the performance differences seem negligible ... what sort of issues are you worried about?
09:21:10 <takamura> to use it with zipWith3
09:21:23 <DRMacIver> geezusfreeek: I played with it for a bit a while ago, but didn't have a major use case for it and was more of a type system snob then than I am now, so I stopped using it.
09:21:46 <geezusfreeek> i mainly don't use it because it's still so unstable
09:21:46 <Igloo> takamura: id or ($) will both do it
09:21:54 <Vulpyne> sjanssen: I intend to capture, and log to MySQL a large amount of data. So I care about stuff like being able to precompute queries, etc.
09:21:55 <geezusfreeek> and i think it needs a better dialect
09:22:04 <geezusfreeek> i've toyed with the idea of making my own dialect of it though
09:22:08 <Vulpyne> sjanssen: I'm using hsql right not, but I'm not liking it. :)
09:22:09 <Igloo> takamura: ($) is just a type-restricted id
09:22:23 <takamura> ah, ok, thanks Igloo
09:22:57 <benny99> I want to learn a functional language and started with a (veery) little LISP and switched then to OCAML (and did some tutorials)
09:22:58 <benny99> But now I wonder whether I should learn Haskell...
09:23:08 <geezusfreeek> DRMacIver: and i'm a bit _more_ of a type system snob now :)
09:23:20 <Vulpyne> Haskell syntax seems a lot nicer than OCaml to me.
09:23:46 * SamB_XP_ wonders if GHC could use mmap for write barriers on arrays (so it doesn't have to scan an entire large array every collection, only changed blocks)
09:23:56 <SamB_XP_> maybe I mean mprotect
09:24:38 <asymptote> benny99, have you considered unlambda?
09:24:49 <geezusfreeek> lisp == flexible awesomeness; ocaml == easy, fast ugliness; haskell == difficult beauty
09:25:01 <benny99> asymptote: didn't even know it's name
09:25:13 <benny99> (its?)
09:25:26 <DRMacIver> benny99: asymptote is joking. :) Don't use unlambda.
09:25:26 <asymptote> benny99, it's a joke language; just S and K without lambda abstraction
09:25:29 <geezusfreeek> its
09:25:40 <therp> hm, no varargs from haskell ffi?
09:25:43 <asymptote> sort of a functional Intercal
09:26:10 <benny99> DRMacIver: I see ^^ (just found madore.org)
09:26:38 <SamB_XP_> yeah, your program is a Church-encoded String->String
09:27:29 <SamB_XP_> no wait, that's lazy K/.
09:27:33 * SamB_XP_ silly
09:27:43 <benny99> geezusfreeek: difficult beauty is what I'm looking for ^^
09:28:53 <DRMacIver> geezusfreeek: I've grown less snobby in my old age. I'm too apathetic to feel strongly about such things these days. :)
09:29:19 <geezusfreeek> DRMacIver: i just try to keep the "Know that you do not know" mentality, and i stay pretty happy
09:29:20 <tuukkah> anybody know of a haskell-driven typesetting system?
09:29:40 <benny99> geezusfreeek: is it "beautiful by nature" ?
09:30:34 <geezusfreeek> benny99: that is either a reference i'm not terribly familiar with or i just don't understand what you are hinting at
09:30:38 <asymptote> tuukkah, google tells me this guy: http://www.cs.cmu.edu/~crary/ is working on one
09:30:40 <lambdabot> Title: Karl Crary
09:30:41 <benny99> geezusfreeek: i.e. if I write a program (and I'm not trying to obfuscate anything) is it beautiful already or must I know about some "great features" ?
09:30:51 <DRMacIver> There seems to be a certain amount of anecdotal evidence that its beauty is an artificial consequence of the fact that all the examples are small. ;)
09:31:17 <geezusfreeek> benny99: there are usually better ways of doing things, but it becomes apparent at the time it's needed, really
09:31:26 <DRMacIver> benny99: It's certainly possible to write ugly Haskell.
09:31:36 <DRMacIver> benny99: But fairly normal Haskell is quite elegant. (at least on a local level)
09:31:45 <geezusfreeek> benny99: i'm still fairly new to all this, but i have a feeling that it's an eternal learning experience
09:31:58 <geezusfreeek> "how deep does the rabbit hole go?" kind of thing
09:32:07 <tuukkah> asymptote, yeah, anyone know anything more ?-)
09:32:14 <asymptote> On these matters elegance can be subjective; I find ML very very elegant while others find it vulgar
09:32:25 <DRMacIver> geezusfreeek: Especially as you can never keep up with what all the twisted compiler writers keep adding into GHC. ;)
09:32:59 <DRMacIver> "Oh, Haskell now has reversed polarity time traveling rodent parameterised types? Cool..."
09:33:43 <benny99> DRMacIver: ah, I should read a bit about Haskell anyway, I should decide later, maybe :)
09:33:49 <benny99> DRMacIver: :D
09:33:55 <geezusfreeek> benny99: ^^ as such is the biggest problem with haskell, in my opinion, is that in order to thrive in it, you must become an academic and start liking big words
09:34:26 <geezusfreeek> i highly recommend it to anyone wanting to expand their horizons at the least
09:34:33 <benny99> geezusfreeek: and shortcuts :P
09:34:46 <DRMacIver>  benny99 I highly recommend it. It's a lovely language. It's not all great, but it has a few unique and really marvelous features.
09:34:49 <benny99> geezusfreeek: yeah, expanding my horizon is what I'm doing anyway :<
09:35:26 <benny99> DRMacIver: I liked how you used the word "marvelous", I'll try and if I fail, I'll come back and complain :)
09:35:53 <geezusfreeek> haskell is marvelous marvelous marvelous… does that convince you more?
09:36:12 <DRMacIver> Prolific laziness, type classes and monads are lovely. :) Purity has a lot of advantages, and structuring your thinking that way has a lot of benefits.
09:36:20 <benny99> geezusfreeek: *only, I sometimes feel like I'll never really write a program that is made for using
09:36:34 <DRMacIver> It will however make you sad when you can't port most of these advantages to other languages. :)
09:36:49 <benny99> geezusfreeek: wow, yeah, that was convincing :)
09:36:50 <DRMacIver> When you start trying to write monads in Java, the end times will be at hand.
09:37:10 <geezusfreeek> DRMacIver: well, you certainly can, it's just that you have to maintain the constraints yourself instead of being able to depend on the compiler to keep you from screwing things up
09:37:38 <DRMacIver> geezusfreeek: For all intents and purposes, you can't. :) The results aren't pretty.
09:37:43 <DRMacIver> geezusfreeek: I mean, you could port a lot of it to ML.
09:37:46 <geezusfreeek> even in haskell, monads have some properties that aren't checked by the compiler
09:38:03 <DRMacIver> Maybe even to ruby, though it would hurt.
09:38:10 <benny99> DRMacIver: purity is my main point of interest (is that an English sentence ._.?).. and what are those great type classes?
09:38:34 <DRMacIver> benny99: Type classes are Haskell's mechanism for doing ad hoc overloading in a non ad hoc manner.
09:38:37 <DRMacIver> ?t (+)
09:38:38 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
09:38:41 <geezusfreeek> benny99: i like to look at typeclasses as equivalent to interfaces in OO languages
09:38:45 <DRMacIver> @type (+)
09:38:47 <lambdabot> forall a. (Num a) => a -> a -> a
09:38:57 <DRMacIver> benny99: Num a in the above is a type class
09:39:17 <benny99> DRMacIver: that appears to be great ._.
09:39:40 <benny99> DRMacIver: so I could create a vector class and overload it's operators like in C++ ? or is it even better?
09:40:00 <ihope> Typeclasses = interfaces but better.
09:40:16 <geezusfreeek> benny99: it's not really a class in the OO sense, more like an interface
09:40:20 <ihope> Sort of an extension of interfaces.
09:40:28 <benny99> ._. an interface like in Java ?
09:40:50 <DRMacIver> benny99: To a certain extent. You wouldn't be able to make it an instance of Num unfortunately, so couldn't give it +, but can do similar things.
09:40:55 <geezusfreeek> close enough as i can probably explain without going into excruciating detail
09:41:00 <DRMacIver> benny99: They're like interfaces on steroids. :)
09:41:03 <DRMacIver> Anyway, I've got to go
09:41:04 <DRMacIver> Bye
09:41:22 <geezusfreeek> bi
09:41:31 <benny99> DRMacIver: bye
09:41:39 <benny99> :'( I made him leave
09:41:49 <ihope> Everything you can do with an interface there you can do with a class here, I think.
09:43:04 <geezusfreeek> it's rich-man's duck-typing
09:43:07 <geezusfreeek> :D
09:43:11 <benny99> ihope: so, it's a class but without variables, but only methods? (makes sense in a functional sense for me)
09:43:27 <benny99> geezusfreeek: :( didn't understand that joke
09:43:42 <geezusfreeek> benny99: wasn't really a joke :P
09:43:45 <ihope> benny99: well, I guess an example of a class would do you good.
09:44:10 <benny99> geezusfreeek: I got at least that one ;p
09:44:21 <benny99> ihope: or I should simply start reading a tutorial :)
09:44:23 <ihope> class Num a where (+) :: a -> a -> a
09:44:31 <ihope> That's not the entire Num class; it's just a piece of it.
09:44:54 <benny99> why Num -- a ?
09:45:05 <ihope> To make a type an instance of the class, you do something like this: instance Num String where x + y = x ++ y
09:45:50 <geezusfreeek> benny99: a tutorial would probably be a good start :)
09:46:26 <ihope> ++ has the type [a] -> [a] -> [a]. Since String goes with the "a" in the class definition, this function needs to be String -> String -> String, which [a] -> [a] -> [a] matches with because String is defined to be the same as [Char].
09:46:26 <benny99> ihope: thanks for your explanations, but I really don't understand anything -- I should start with a tut :)
09:46:34 <ihope> Not a bad idea :-)
09:46:56 <benny99> what is [a] -> [a] -> [a] ?
09:47:08 <benny99> function returning [a] accepting [a] and [a] ?
09:47:14 <geezusfreeek> yes
09:47:26 <geezusfreeek> where [a] is an array of type a
09:47:29 <geezusfreeek> *list
09:47:40 <Saizan> list of things of type a
09:47:42 <geezusfreeek> wow, that was a slip of terminology there
09:48:09 <benny99> ihope: I got that last explanation at least ;)
09:48:10 <ari> Or, more specifically but less clearly, a function accepting [a] returning a function accepting [a] and returning [a]
09:48:36 <geezusfreeek> benny99: ari's explanation is the best one here
09:48:51 <benny99> ari: thanks :)
09:49:28 <roconnor> @type mapM readFile
09:49:35 <benny99> I should really start off with a tutorial instead of stealing time :), just wanted a first sight (is that a correct English sentence ?) :)
09:49:36 <lambdabot>     Ambiguous occurrence `mapM'
09:49:37 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
09:49:47 <roconnor> @type Control.Monad.mapM readFile
09:49:49 <lambdabot> [FilePath] -> IO [String]
09:50:23 * benny99 reads
09:51:09 <ihope> benny99: mm, maybe you'd want a word like "peek", "glance" or "look" there instead of "sight"...
09:51:55 <geezusfreeek> unless he wants love at first sight
09:52:13 <geezusfreeek> it wasn't love at first sight for me though, so i can't recommend depending on that
09:53:44 <benny99> ihope: listen to geezusfreeek :P
09:53:52 * benny99 is truly away now
09:54:03 * glguy will be back soon
10:22:38 <roconnor> @type cwd
10:22:38 <lambdabot> Not in scope: `cwd'
10:22:38 <xic> is there an alternative to mapM_ that goes through the list in reverse order?
10:22:38 <kpreid> @src mapM_
10:22:38 <lambdabot> mapM_ f as = sequence_ (map f as)
10:22:38 <kpreid> @src seqhence_
10:22:38 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:22:38 <kpreid> @src sequence_
10:22:38 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
10:22:38 <kpreid> @src (<<)
10:22:38 <lambdabot> Source not found. stty: unknown mode: doofus
10:22:38 <Saizan> mapM_ . reverse?
10:22:38 <kpreid> well, just build that up with (flip (<<)) instead of (>>)
10:22:38 <kpreid> er, (flip (>>))
10:22:38 <xic> what about foldl?
10:22:38 <Saizan> ?type foldl (>>) (return ())
10:22:38 <kpreid> not relevant for associative operations like >>
10:22:38 <lambdabot> forall (m :: * -> *). (Monad m) => [m ()] -> m ()
10:22:56 <kpreid> > execWriter $ mapM_ tell ["hello", "world"]
10:22:58 <lambdabot>  "helloworld"
10:23:02 <balodja> how to specify function type in let/where block? as i see, ghc treats lines like "function :: Int -> String" as continuation of previous line
10:23:03 <Saizan> yeah foldl would just stick return () at the top instead of at the end
10:23:37 <Saizan> ?type let f :: Int -> Int; f = undefined in f
10:23:38 <kpreid> > execWriter $ foldr (flip (>>)) (return ()) $ map tell ["hello", "world"]
10:23:38 <lambdabot> Int -> Int; f = undefined in f :: Int -> Int
10:23:39 <lambdabot>  "worldhello"
10:24:34 <xic> kpreid: does this have better performance then reversing the list?
10:25:02 <Jaak> @type tell
10:25:03 <lambdabot> forall w (m :: * -> *). (MonadWriter w m) => w -> m ()
10:25:30 <Saizan> xic: you'll reduce an intermediate list probably, if reverse doesn't get fused anyhow
10:25:32 <kpreid> xic: depends on the monad instance
10:26:00 <xic> kpreid: STM
10:26:12 <kpreid> probably not, then. might even be worse
10:26:13 <therp> with haskell FFI I'm unable to call functions with a variable number of arguments such as printf(char *, ...); right?
10:26:15 <kpreid> but try it!
10:26:34 <Saizan> kpreid: why worse?
10:27:11 <kpreid> because it's more likely to optimize lists than the backwards tree of >>s, I'd think
10:28:35 <kpreid> however, flipping >> is better than reversing the list in some cases:
10:28:45 <kpreid> > execState (foldr (flip (>>)) (return ()) $ repeat $ put 1) 0
10:28:46 <lambdabot>  1
10:28:51 <kpreid> > execState (foldr (>>) (return ()) $ reverse $ repeat $ put 1) 0
10:28:57 <lambdabot> Terminated
10:30:24 <Saizan> > execState (sequence_ $ repeat $ put 1) 0
10:30:26 <lambdabot>  Exception: <<loop>>
10:30:33 <kpreid> you can't reverse an infinite list, but you can make an infinite action out of it
10:31:13 <Saizan> i don't get how the first worked..
10:31:32 <kpreid> execState asks for the state
10:31:59 <kpreid> state is overwritten, so only the last put can matter, so all the "preceding" ones can't matter
10:32:48 <Saizan> how does it get the last put?
10:33:02 <kpreid> Saizan: by evaluation!
10:33:04 <kpreid> @let ecneuqes_ = foldr (flip (>>)) (return ())
10:33:05 <lambdabot> <local>:10:31:     Ambiguous type variable `m' in the constraint:       `Mona...
10:33:11 <kpreid> @let ecneuqes_ m = foldr (flip (>>)) (return ()) m
10:33:14 <lambdabot> Defined.
10:33:21 <Saizan> i see.
10:33:32 <kpreid> @let pamM f mxs = sequence_ (map f mxs)
10:33:33 <lambdabot> Defined.
10:33:37 <kpreid> er
10:33:39 <kpreid> @undefine
10:33:40 <lambdabot> Undefined.
10:33:42 <kpreid> @let ecneuqes_ m = foldr (flip (>>)) (return ()) m
10:33:43 <lambdabot> Defined.
10:33:52 <kpreid> @let pamM f mxs = ecneuqes_ (map f mxs)
10:33:53 <lambdabot> Defined.
10:33:57 <Saizan> put 1 << put 1 << .... << return ()
10:34:06 <kpreid> > execState $ pamM $ modify (\xs -> 0 : map succ xs)) []
10:34:07 <lambdabot>  Parse error
10:34:10 <Saizan> and the first put 1 doesn't force any of the frecedings
10:34:17 <kpreid> > execState $ pamM $ modify (\xs -> 0 : map succ xs) []
10:34:17 <lambdabot>  Couldn't match expected type `a -> m ()' against inferred type `()'
10:34:27 <kpreid> > execState (pamM $ modify (\xs -> 0 : map succ xs)) []
10:34:28 <lambdabot>  Couldn't match expected type `m ()' against inferred type `()'
10:34:51 <kpreid> gah, sorry
10:35:04 <kpreid> > execState (ecneuqes_ $ modify (\xs -> 0 : map succ xs)) []
10:35:05 <lambdabot>  Couldn't match expected type `m ()' against inferred type `()'
10:36:33 <kpreid> > execState (ecneuqes_ $ repeat $ modify (\xs -> 0 : map succ xs)) []
10:36:34 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:37:06 <kpreid> also, you can use Writer lazily forward
10:37:43 <kpreid> > execWriter (mapM_ (tell . return) [0..])
10:37:43 <lambdabot>   add an instance declaration for (Show (m a))
10:37:55 <kpreid> > execWriter (mapM_ (tell . (:[])) [0..])
10:37:56 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
10:42:14 <kpreid> if anyone says that monads are just reintroducing imperative programming, you can show them this :)
10:42:14 <SamB_XP_> kpreid: I'd tell them "well, yes. but it's imperative like you've never seen before!"
10:42:26 <benny99> wow, compiling ghc is really something you don't want to do twice a day...
10:43:36 <Igloo> A quickest build only takes me about 30 mins, on a not spectacularly fast machine
10:44:56 <byorgey> benny99: are you compiling ghc!?
10:45:03 <benny99> Igloo: I'm compiling the standard gentoo build
10:45:28 <benny99> Igloo: and it appears "stage2"...
10:45:37 <byorgey> benny99: there isn't a binary distribution you can use?
10:45:37 <benny99> byorgey: yep
10:45:46 <benny99> byorgey: no, gentoo-user :(
10:45:56 <Lemmih> benny99: There's ghc-bin, isn't there?
10:46:13 <benny99> damn >.<
10:47:47 <benny99> ah, but I guess it's just for compiling the compiler
10:48:49 <desp> sigh
10:48:58 <benny99> no, I guess I was an idiot ._., and also didn't expect it to take that much time
10:49:27 <desp> I seem to have found an omission in the FFI
10:49:51 <byorgey> benny99: yeah, I've never done it myself, but from what I've heard building ghc from source is probably not the best way to start off learning Haskell if you can help it =)
10:51:11 <desp> FunPtrs allocated using a "wrapper" stub need to be freed after use, using freeHaskellFunPtr.  however, there's no apparent way to associate a finalizer directly with the FunPtr.
10:52:32 <desp> I'm thinking of using castFunPtrToPtr and castPtrToFunPtr in order to work around this, but there are some portability warnings associated with those functions
10:52:35 <gogonkt1> hi,I new to haskell,only now some c++,I want to learn Haskell few day and hand on some easy program with GUI in XP.then continu learn and use she,Which stuff I begin firt,had this stuff for me? :)
10:53:05 <Lemmih> desp: Is it guaranteed that, when it is garbage collected, it won't be accessible from C?
10:53:14 * SamB_XP wonders why gogonkt1 isn't putting spaces after his commas
10:53:25 <desp> Lemmih: yes, I would guarantee that.
10:53:52 <benny99> Lemmih: desp's guarantee of destiny :O
10:53:57 <gogonkt1> SamB_XP: ?
10:54:10 <desp> benny99: ;)
10:54:19 <byorgey> gogonkt1: there are lots of Haskell tutorials, for example you could try
10:54:21 <Lemmih> desp: Then can't you free it manually?
10:54:23 <byorgey> @where yaht
10:54:23 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
10:55:04 <benny99> byorgey: at least I haven't to do anything... emerge ghc and everything else is done by emerge :)
10:55:08 <desp> Lemmih: yes, in that case I can, but I would also like to cover the case when the Haskell side decides the object is no longer needed
10:55:13 <gogonkt1> byorgey: I got too much at Haskell.org,I am lose the way
10:55:18 <desp> hm, perhaps I should rethink this.
10:55:21 <gogonkt1> :(
10:55:23 <byorgey> gogonkt1: you could also try looking here for a list of tutorials to choose from: http://www.haskell.org/haskellwiki/Meta-tutorial
10:55:25 <lambdabot> Title: Meta-tutorial - HaskellWiki
10:55:27 <benny99> gogonkt1: that tutorial appears to be nice :), I'm just reading the first few pages
10:55:46 * SamB_XP wants to see Haskell.org's access logs for /robots.txt
10:55:48 <byorgey> benny99: excellent.  I figured there had to be something like that.
10:55:49 * benny99 away again
10:56:47 <byorgey> gogonkt1: also, writing programs which create a UI in Windows XP is probably not a very good way to learn Haskell
10:57:21 <desp> understatement of the day
10:57:22 <desp> ;)
10:58:21 <gogonkt1> byorgey: can't haskell program GUI thing in windows?
10:58:37 <roconnor> haskell doesn't do gui's yet :P
10:58:37 <lambdabot> roconnor: You have 1 new message. '/msg lambdabot @messages' to read it.
10:58:51 <benny99> gogonkt1: you probably can, but it's "weird" if you programmed in C++ before
10:58:56 <desp> roconnor: eh? there are library bindings
10:59:17 <byorgey> gogonkt1: yes, but there's a lot of more basic stuff you would need to understand first.. it's not a good way to learn.
10:59:24 <benny99> desp: yeah, he wanted to show off a bit I guess ;P
10:59:27 <roconnor> desp: sure, but then you might as well program in the language that the bindings are bound to
10:59:35 <gogonkt1> haha, Thx, I got it
10:59:39 <benny99> desp: see ;)
11:00:21 <benny99> byorgey: it's built :'(
11:00:25 <roconnor> as soon as fudgits or phooey or whatever pans out, then we can do the real GUI programming.
11:00:28 <gogonkt1> gogonkt1: http://darcs.haskell.org/yaht/yaht.pdf
11:00:46 <byorgey> benny99: why is that sad?
11:00:47 <benny99> gogonkt1: ?
11:09:09 <benny99> byorgey: because it's that beautiful... I must cry :'(
11:09:09 <byorgey> benny99: ah, I see =)
11:09:09 <byorgey> *sniff*
11:09:09 * benny99 hugs byorgey and sniffs, too
11:09:09 * byorgey hugs benny99 back in a strictly platonic way
11:09:09 <gogonkt1> all Big Guys : Thx, I mark those page and begin Hakell :) , I got the way
11:09:09 <byorgey> gogonkt1: good luck!  feel free to ask in here if you have questions
11:09:09 <gogonkt1> byorgey: heha
11:09:09 <byorgey> anyone in here familiar with TH?
11:09:09 * benny99 is away again
11:09:09 <benny99> byorgey: no, never met a pro skater in my life :(
11:09:09 <Lemmih> byorgey: Yes, even is you add a C.
11:09:09 <byorgey> ok, now I'm confused. =)
11:09:09 <dmhouse> ?google th pro skater
11:09:09 <lambdabot> http://www.arcadevault.com/tony_hawk_skater.html
11:09:09 <lambdabot> Title: Arcade Vault - Tony Hawk's Pro Skater
11:09:09 <benny99> ^^
11:09:09 <byorgey> I see... *sigh* =)
11:09:09 <byorgey> of course, I meant Template Haskell...
11:09:09 <benny99> byorgey: Didn't know Template Haskell before :p
11:09:09 * benny99 is absolutely away now ._.
11:09:09 <byorgey> benny99: I wouldn't expect you to, if you're just learning...
11:09:09 <benny99> byorgey: (if I wasn't away, I'd say, that I was sorry for destroying 80% of your patience, but I'm away...)
11:13:22 <byorgey> benny99: if you weren't away, I'd say that you did nothing of the sort.  but seeing as you're away, I won't.
11:15:43 <daniel_larsson> I'd write a :) if I was actually here
11:23:48 * shapr boings cheerfully
11:24:12 <daniel_larsson> hi )
11:24:16 <shapr> hej daniel
11:24:36 <shapr> Jag känner mig så lyckligt!
11:24:41 <daniel_larsson> How's hApps coming along?
11:24:44 <daniel_larsson> Oh, good :)
11:24:53 <daniel_larsson> "lycklig" :)
11:25:00 <shapr> HAppS is fun as usual, I'm doing cool and nifty stuff with it right now.
11:25:23 <daniel_larsson> I've actually used it for an internal thing, it's fun
11:26:43 <shapr> Any thoughts or comments?
11:27:02 <daniel_larsson> Rewrote an old python implementation. Performance is way better ). Mostly due to stupid algorithm though, and not programming language :)
11:27:13 * dmhouse is visiting Scandinavia for the first time next month :)
11:27:26 <daniel_larsson> What part of it? :)
11:28:11 <shapr> dmhouse: Sweden? Norway?
11:28:48 <daniel_larsson> I had some troubles initially doing content negotiation, but I got it working finally. I'd have to recheck if I managed to easily do it, or if there was some tweaking going on. Was a while since I had time to play with it :/
11:29:35 <dmhouse> shapr: all over. Stockholm - Helsinki - Rovaniemi - Trondheim - Oslo - Göteborg - København.
11:29:59 <daniel_larsson> Oh, okay, so it's really Scandinavia )
11:30:26 <daniel_larsson> I'm kind of used to people just casually lumping us all together :)
11:31:00 <shapr> I've never been to Oslo, Köpenhamn, or Trondheim. But I've enjoyed the other cities lots!
11:31:27 <shapr> Does darcs let me use -i <key> somehow for a private ssh key?
11:31:43 <shapr> I thought darcs would use an existing Master connect, but it isn't doing it for some reason...
11:31:45 <dmhouse> (And then Berlin - Praha - Wien - Budapest - Ljubjana and back home again. :))
11:32:02 <Lemmih> shapr: When were you in Copenhagen? You should have looked me up.
11:32:26 <Lemmih> shapr: Oh, you've _never_ been in Copenhagen.
11:33:06 <dmhouse> shapr: any recommendations for places to see/stay?
11:33:22 <dmhouse> Lemmih, daniel_larsson: same question for you, if you're in one of the above cities :)
11:33:43 <daniel_larsson> Stockholm, so yes :)
11:34:33 <Modius> OMFG - this "scheme written in Haskell" tutorial is awesome.
11:34:44 <daniel_larsson> Take the ferry out to Djurgården )
11:34:53 <daniel_larsson> ferry = 5 min ride
11:35:42 <roconnor> how many entries should go in an atom feed?
11:35:57 <daniel_larsson> 42
11:36:13 <Lemmih> dmhouse: I can recommend my place if you're ever in Landskrona. (:
11:36:35 <dmhouse> roconnor: around 10?
11:37:14 <shapr> I like Kungstradgården
11:37:25 <roconnor> hmm
11:37:55 * dmhouse has fun trying to pronounce Swedish place names
11:37:55 <daniel_larsson> That's on the way back with the tram from Djurgården :)
11:38:15 * roconnor is writing a atom generator for his blog
11:38:56 <xic> roconnor: in haskell?
11:39:16 <desp> is there a way to assign default values for record fields?
11:39:17 <roconnor> xic:  of course
11:39:32 <desp> records--
11:39:38 <desp> Haskell needs a transplant of Erlang records
11:40:00 <xic> roconnor: are you planning on using one of the haskell xml libraries for generating atom?
11:40:15 <roconnor> xic: I was planning to use hxt
11:40:18 <and1> hello everyone
11:40:20 <daniel_larsson> Make a function returning a record with default values, then set those you want to set?
11:40:23 <shapr> I know you can do default values for typeclass instances.
11:40:31 <shapr> Yeah, that's what I do.
11:40:35 <and1> Any links to haskell standard or documentations in pdf form
11:40:38 <byorgey> hi and1.
11:40:54 <shapr> I always have emptyRecord = { <default values> } and I only use that.
11:41:02 <Cale> desp: Usually you just construct records by replacing fields in other records, when you want a default.
11:41:11 <byorgey> and1: what sorts of documentation are you looking for? a tutorial, or a specification?
11:41:34 <desp> hm.
11:42:07 <benny99> byorgey: If I was there and read your message, I'd tell you, that that was a nice answer, but that did never happen
11:42:08 <and1> byorgey: anything will do
11:42:15 <xic> haskell needs a syntax for modifying a field(or multiple fields) in a record
11:42:27 <benny99> and haskell is really nice :)
11:42:28 <desp> pardon me, but what is the syntax for replacing a field?
11:42:47 <xic> x { y = f (x y) }
11:43:07 <and1> byorgey: I want to learn haskell
11:43:08 <Baughn> xic: It has one
11:43:08 <desp> uh.
11:43:12 <xic> would be cool to be able to do that like x { y := f }
11:43:26 <shapr> desp: I think it's: emptyRecord { fieldname = newvalue }
11:43:37 <Baughn> xic: Well, it has a syntax for making a copy with some fields changed. Is that what you want?
11:43:53 <desp> Baughn: some? or just one?
11:43:55 <Cale> It would also be nice to allow function binding syntax for record update.
11:44:02 <byorgey> @where yaht
11:44:02 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
11:44:07 <byorgey> and1: you could try that
11:44:09 <xic> oops, i meant (y x) instead of (x y) up there
11:44:12 <Cale> So you could write  r { f x = ... }
11:44:24 <and1> byorgey: thnaks
11:44:31 <byorgey> and1: also this: http://www.haskell.org/haskellwiki/Meta-tutorial
11:44:32 <fax> hi
11:44:32 <lambdabot> Title: Meta-tutorial - HaskellWiki
11:44:43 <fax> is it easy to answer .. how does GHC compile haskell into C?
11:44:53 <desp> xic: could you be any more cryptic? :)
11:45:03 <fax> does it basically just convert everything to CPS and write it out in the style of a scheme->C compiler?
11:45:05 <benny99> fax: it's easy, pure magic :p (dunno)
11:45:34 <Lemmih> @google spineless tagless g-machine
11:45:36 <lambdabot> http://citeseer.ist.psu.edu/peytonjones92implementing.html
11:45:36 <lambdabot> Title: Implementing lazy functional languages on stock hardware: the Spineless Tagless  ...
11:46:07 <Lemmih> fax: "The Spineless Tagless G machine is an abstract machine designed to support nonstrict higher order functional languages."
11:46:25 <desp> I can't find a good webpage describing the record syntax.  the best I found was http://www.cs.sfu.ca/CC/SW/Haskell/hugs/tutorial-1.4-html/moretypes.html
11:46:27 <lambdabot> Title: A Gentle Introduction to Haskell: Types, Again, http://tinyurl.com/24yzho
11:48:01 <shapr> @where cabal
11:48:02 <lambdabot> http://www.haskell.org/cabal
11:49:02 <shapr> So, has anyone started on a postscript interpreter yet?
11:49:08 <fax> I dont..
11:49:12 <fax> think I get that :S
11:50:38 <shapr> fax: It's sort of like how Java compiles into C.
11:51:25 <shapr> @where filepath
11:51:25 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/filepath/
11:51:49 <xic> how difficult is it to write a compiler for a simple haskell-like language, that compiles into a language like javascript and converts tail calls to loops?
11:52:12 <shapr> edwardk said STG would be pretty easy to compile into JavaScript.
11:53:04 <xic> how hard is this for someone who has had no education in compiler theory or even any computer science?
11:54:10 <JohnMeacham> yay. jhc has achieved 100% regression. time to start building new libs to put up.
11:54:11 <shapr> Well, I don't have any education in any of those, and I don't think it'd be hard.
11:54:30 <norgul> anyone here who know emacs lisp?
11:54:44 <shapr> But then, my approach would be to ask edwardk what he was doing, and then continue that.
11:54:45 <fax> I write about 20 lines of elisp ;D
11:54:47 <benny99> xic: try it :)
11:55:06 <shapr> norgul: Do you have a problem that needs fixing with elisp?
11:55:06 <benny99> xic: *throws some motivation at xic*
11:55:10 <JohnMeacham> I wrote some general routines for working with 'chunked' files based on the PNG format (which was really well thought out). I thought they might be generally useful alongside Data.ByteString or Data.Binary..
11:55:17 <Igloo> JohnMeacham: It's completely regressed?  :-)
11:55:48 <Lemmih> JohnMeacham: The Haskell98 regression suite?
11:56:30 <fax> so uh..
11:56:35 <fax> how od you compile haskell to c? :|
11:56:49 <fax> Is GHC readable?
11:57:21 <shapr> Yeah, it's readable.
11:57:27 * Lemmih giggles.
11:57:51 <JohnMeacham> a signifigant portion of nobench.
11:58:09 <xDie> hi all
11:58:12 <shapr> fax: But I think you should read the STG url that Lemmih suggested if you really want to understand it.
11:58:20 <Lemmih> fax: Why not read the paper?
11:58:26 <Cheery> there's darn lots of nice algorithms for tree, but is that all we got?
11:58:29 <shapr> hiya xDie
11:58:34 <fax> ugh is this channel logged?
11:58:39 <shapr> fax: yup
11:58:43 <xDie> somebody can put lambdabot a moment in #debian-es
11:58:46 <fax> cool, ill check it out when I get home
11:58:47 <glguy> Check the topic
11:58:57 <fax> I bet its too hard for me to understand though :S
11:58:57 <xDie>  @part #debian-es
11:59:02 <xDie> a moment
11:59:10 <xDie> please
11:59:23 <xDie> i show the lambdabot power
11:59:39 <xDie> thanks!
12:00:27 <fax> lol
12:00:31 <fax> poor lambdabot
12:00:36 <xDie> yeah!
12:00:38 <xDie> hehe
12:01:27 <Excedrin> JohnMeacham: congrats!
12:03:41 <JohnMeacham> time to work on separate compilation. then it should be ready for general use.
12:04:33 <SamB_XP> JohnMeacham: what's that?
12:04:59 <JohnMeacham> jhc.
12:05:50 <JohnMeacham> the main impediment to people in general using it is the very long compilation times. I hope to fix that.
12:08:04 <SamB_XP> what exactly does it do that you want to make it not do in order to accomplish this?
12:08:05 <Saizan> don't you lose some of the optimisations with separate compilation?
12:08:17 <SamB_XP> Saizan: depends what you mean by "seperate"
12:08:18 * roconnor is having trouble gettin hxt to output anything
12:08:55 <SamB_XP> roconnor: oh?
12:09:15 <Saizan> roconnor: are you using more than one "filter" after a getChildren?
12:09:55 <roconnor> @hpaste
12:09:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:10:22 <hpaste>  roconnor pasted "my first hxt program" at http://hpaste.org/213
12:11:35 <Saizan> roconnor: you need to add root [] [ feed "" [] ]
12:12:06 <SamB_XP> hmm, that sounds like a bug to me
12:12:13 <roconnor> okay, http://www.haskell.org/haskellwiki/HXT#Document_construction_examples is misleading then
12:12:15 <lambdabot> Title: HXT - HaskellWiki, http://tinyurl.com/277hfo
12:12:22 <SamB_XP> (that it doesn't produce a useful error message when you do it wrong)
12:13:30 <roconnor> horray!
12:13:54 <SamB_XP> what is the extra root for?
12:13:58 <SamB_XP> in case of SGML?
12:17:04 <roconnor> > "\32"
12:17:08 <lambdabot>  " "
12:17:16 <roconnor> > "\33"
12:17:17 <lambdabot>  "!"
12:17:22 <roconnor> > "\x21"
12:17:23 <lambdabot>  "!"
12:17:27 <roconnor> > "\x2121"
12:17:28 <lambdabot>  "\8481"
12:17:40 <SamB_XP> > ['\32'..]
12:17:41 <lambdabot>  " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefgh...
12:18:40 <syntax> haskell-mode or shim?
12:18:42 <roconnor> grr
12:18:58 <SamB_XP> what is shim?
12:19:06 <roconnor> "\x2019C" isn't parsed as '\x2019':"C"
12:19:17 <syntax> it's another haskell mode for emacs, I'm told in #emacs
12:19:23 <roconnor> @scheck "\x2019C" == '\x2019':"C"
12:19:23 <lambdabot>  Character constant out of range
12:19:48 <benny99> what editor are you using ?
12:19:59 <benny99> (editors)
12:20:10 <SamB_XP> shim has no release yet
12:20:17 <SamB_XP> and it uses GHC-API
12:20:27 <syntax> oh. that makes it an easy choice I guess.
12:20:32 <desp> @hoogle seq
12:20:33 <lambdabot> Prelude.seq :: a -> b -> b
12:20:33 <lambdabot> Prelude.sequence :: Monad m => [m a] -> m [a]
12:20:33 <lambdabot> Prelude.sequence_ :: Monad m => [m a] -> m ()
12:20:56 <SamB_XP> http://shim.haskellco.de/trac/
12:20:58 <lambdabot> Title: shim - Trac
12:21:09 <SamB_XP> it sounds cool though
12:21:26 <SamB_XP> if GHC-API weren't so new, I'd want to try it myself...
12:22:18 * SamB_XP wonders how it borrows code from SLIME
12:22:33 <SamB_XP> maybe some of the elisp, I guess...
12:22:40 <therp> sambxp: shim.el is largely created from slime.el
12:22:50 <therp> s/largely/mostly/
12:23:02 <benny99> hm, I'm not an emacs fan :(
12:23:18 <SamB_XP> well, apparantly they want to try to do it for VIM too
12:23:21 <benny99> I'm using vim so far
12:23:25 <SamB_XP> but I didn't know VIM supported modes
12:23:49 <benny99> a separate IDE would be cute
12:24:00 <SamB_XP> (its hard to have a Superior Haskell *mumble* Mode without modes, isn't it?)
12:24:43 <opqdonut> ?src seq
12:24:43 <lambdabot> Source not found. Maybe if you used more than just two fingers...
12:24:54 <opqdonut> haha, i actually used only one!
12:24:55 <glguy> seq is rather primitive, no?
12:25:06 <SamB_XP> glguy: yes indeed.
12:25:16 <benny99> :D
12:25:20 <benny99> seq ?
12:25:28 <arcatan> why lambdabot never finds any sources?
12:26:03 <SamB_XP> arcatan: dons has to type them in by hand. he probably uses as many as three fingers to do it, too.
12:26:08 <benny99> http://haskell.org/hawiki/HaskellIde <-- what about that one ?
12:26:09 <lambdabot> Title: HaskellIde - The Haskell Wiki
12:26:11 * SamB_XP lies with a straight face
12:26:32 <SamB_XP> benny99: haven't heard from them in a while
12:27:07 <benny99> hm :(
12:27:27 <SamB_XP> maybe the current developers don't use IRC?
12:30:46 * roconnor tries to attach the "http://www.w3.org/2005/Atom" name space to the root element
12:30:48 <lambdabot> Title: Atom Vocabulary
12:30:49 * SamB_XP edits the frontpage for shim...
12:31:09 <SamB_XP> roconnor: well? did it work?
12:31:38 <roconnor> SamB_XP: did what work?
12:31:54 <SamB_XP> attaching that namespace to the </> element
12:32:12 <roconnor> well, mkelem "feed" [sattr "xmlns" "http://www.w3.org/2005/Atom"] works
12:32:19 <roconnor> but I'm not convinced it is proper
12:32:40 <roconnor> namespaces is out of the scope of the tutorial
12:32:48 <JohnMeacham> Saizan: indeed. but I modified them so they no longer depend on the whole program optimization for correctness. So you can do a whole-program optimized build, or a faster one that just compiles files one by one. (or something in the middle)
12:33:05 <daniel_larsson> Should be an ATOM validator out there somewhere
12:33:25 <JohnMeacham> SamB_XP: right now it collects the entire program together before optimizing. it can be slow, as it has to reprocess all the libraries for any compile.
12:33:29 <roconnor> daniel_larsson: I'm generating, not validating
12:33:43 <daniel_larsson> Yea, but to validate your generated ATOM
12:33:54 <roconnor> oh sure
12:34:21 <daniel_larsson> roconnor: you sounded unsure if it was proper
12:34:29 <roconnor> http://feedvalidator.org/
12:34:30 <lambdabot> Title: Feed Validator for Atom and RSS
12:35:04 <Excedrin> JohnMeacham: I get this error while building (some package is the wrong version I guess), FrontEnd/Tc/Kind.hs:21:25: Module `Doc.PPrint' does not export `pprintPrec'
12:35:16 <roconnor> daniel_larsson: what I'm unsure is the proper way to add a namespace to a XmlIOStateFilter
12:35:26 <daniel_larsson> Oh, I see )
12:35:39 <Excedrin> I'm using ghc 6.6.1, do you know if it should build with 6.6.1?
12:36:06 <norgul> i need to calculate prime numbers between 2 and 10 000 000
12:36:21 <norgul> anyone know a good algorithm how do this fast?
12:36:28 <norgul> this is c, though
12:36:28 <Excedrin> norgul: yes, use primegen
12:36:37 <norgul> k
12:36:47 <benny99> norgul: create a very simple one on your own ?
12:36:50 <JohnMeacham> Excedrin: you need to pull the latest version of Doc as well, do a 'darcs pull' in the Doc directory.
12:37:05 <norgul> i have, but it takes hours :P
12:37:16 <benny99> norgul: ?
12:37:18 <norgul> i have to make it faster
12:37:21 <benny99> norgul: from 2 to 10000 ?
12:37:21 <norgul> it's a contest
12:37:25 <Excedrin> norgul: primegen output: 50847534 primes up to 1000000000. Overall seconds: approximately 1.739312.
12:37:28 <norgul> ten million
12:37:29 <roconnor> > nubBy(((>1).).gcd)[2..10000000]
12:37:31 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:37:47 <sieni> roconnor: that won
12:38:04 <benny99> norgul: oh :D
12:38:05 <sieni> roconnor: that won't be over too soon :-)
12:38:09 <benny99> norgul: then play around, it's fun anyway
12:38:14 <norgul> maybe i should use haskell instead of C
12:38:22 <Excedrin> primegen = problem is already solved
12:39:33 <roconnor> > nubBy(((>1).).gcd)[2..10^7]
12:39:35 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:40:58 <norgul> nubBy?
12:41:08 <byorgey> @type nubBy
12:41:10 <lambdabot> forall a. (a -> a -> Bool) -> [a] -> [a]
12:41:54 <byorgey> > nubBy (\x y -> abs(x-y) <= 1) [1..20]
12:41:55 <lambdabot>  [1,3,5,7,9,11,13,15,17,19]
12:41:55 <roconnor> sieni: I thought sieving was the best method
12:43:35 <byorgey> roconnor: depends what you mean by sieving
12:44:19 * DRMacIver finds a comment in a random blog post. "C# 3.0 is as good as any statically typed language can get." and snickers.
12:44:22 <araujo> mmm..
12:44:33 <araujo> what is a good name for a file containing only data structures?
12:44:44 <SamB_XP> arag0rn: a library
12:44:45 <SamB_XP> er.
12:44:49 <SamB_XP> araujo:
12:45:15 <araujo> mmm...
12:45:21 <araujo> it could be
12:46:53 <benny99> anybody is able to explain how to indent functions that contain "in" ?
12:47:22 <benny99> like
12:47:22 <benny99> let f x = let xs = x*x
12:47:22 <benny99>         in xs
12:47:34 <SamB_XP> well, an "in" goes wikth a let
12:47:43 <SamB_XP> so indent it at least as much as the let it goes with
12:48:06 <sieni> norgul: http://en.wikipedia.org/wiki/S4ieve_of_Atkin
12:48:08 <SamB_XP> also make sure you use either (a) no TABs or (b) 8-space tabs
12:48:14 <sieni> O_O
12:48:28 <sieni> where did that 4 come from :-p
12:48:36 <sieni> norgul: http://en.wikipedia.org/wiki/Sieve_of_Atkin
12:48:37 <lambdabot> Title: Sieve of Atkin - Wikipedia, the free encyclopedia
12:48:45 <mauke> benny99: start a new line after in
12:49:43 <mauke> I use either "let x = y in\n..." or "let\n\tx = y\n\ty=z\nin\n..."
12:49:47 <norgul> thanks
12:49:53 <benny99> let pqf p q =
12:49:53 <benny99>         let mph = -p/2
12:49:53 <benny99>         in
12:49:53 <benny99>                 let det = sqrt (mph^2 - q)
12:49:53 <benny99>                 in ((mph + det), (mph - det))
12:49:55 <benny99> sorry :Z
12:50:10 <newsham> I would like to start a petition to change dons name to Donald "Bruce Almighty" Stewart.
12:50:21 <benny99> what's wrong :'( ?
12:50:39 <benny99> with the indentaion
12:50:42 <benny99> indention
12:50:57 <mauke> why is there a let at the beginning?
12:51:27 <benny99> mauke: ok, thanks
12:51:37 <benny99> mauke: didn't work sometimes without the let :(
12:51:47 <mauke> is this a top-level definition?
12:51:48 <benny99> at least not in ghci
12:51:59 <benny99> mauke: no, this one was in a file
12:52:06 <mauke> er
12:52:15 <benny99> mauke: but I tried some things before in ghci and it didn't work tehre without the let
12:52:20 <mauke> all top-level definitions are in files
12:52:32 <daniel_larsson> ghci is not quite like how you write it in a file
12:52:36 <mauke> ghc only supports expressions (well, and let bindings)
12:52:44 <benny99> mauke: ._. uh, sorry, thought definitions in modules are called different, whatever
12:53:03 <benny99> ok :) (you meant ghci?)
12:53:15 <mauke> yeah
12:53:28 <hpaste>  mauke pasted "benny99's code, reformatted" at http://hpaste.org/214
12:53:54 <benny99> mauke: yeah, it's working already without the let, thanks again anyway :)
12:54:07 * ndm grumbles that gmail is down :(
12:54:24 <hpaste>  mauke annotated "benny99's code, reformatted" with "using where instead of let" at http://hpaste.org/214#a1
12:54:53 <benny99> mauke: ah, nice :)
12:59:26 <xic> what is the copyright of code examples in the haskell.org wiki?
13:01:07 <ndm> xic, completely free for any purpose
13:01:23 <desp> I have several instances of  case/of  code that looks like this:  http://pastie.textmate.org/68947
13:01:25 <lambdabot> Title: #68947 - Pastie
13:01:31 <byorgey> ndm: it isn't down for me...
13:01:31 <xic> ndm: cool, where is this stated?
13:01:55 <desp> this is inside the IO monad.  I thought that by omitting the  Nothing  case the compiler woulddefault to  return ()
13:02:09 <desp> but instead it crashes at runtime with an nonexhaustive pattern match
13:02:39 <ndm> desp, thats only in the Maybe monad, not the IO monad
13:02:43 <SamB> hmm. I'm tempted to mention the robots.txt issue on http://haskell.org/
13:02:44 <lambdabot> Title: Haskell - HaskellWiki
13:02:47 <ndm> xic, http://haskell.org/haskellwiki/HaskellWiki:Copyrights
13:02:48 <lambdabot> Title: HaskellWiki:Copyrights - HaskellWiki
13:02:50 <benny99> wow, haskell really rocks my socks :)
13:02:55 <mauke> missing cases always error
13:02:58 <ndm> byorgey, different servers probably...
13:02:59 <byorgey> benny99: =)
13:03:07 <byorgey> ndm: yeah, probably...
13:03:10 <ndm> desp, if you want safety, use a tool like Catch
13:03:13 <ndm> @where catch
13:03:13 <lambdabot> http://www.cs.york.ac.uk/~ndm/catch/
13:03:18 <desp> ndm: http://pastie.textmate.org/68948
13:03:19 <lambdabot> Title: #68948 - Pastie
13:03:21 <ndm> desp, that will spot if you miss any cases anywhere
13:03:49 <desp> ndm: I didn't give the whole function, but I do believe it is in the IO monad.
13:04:07 <ndm> desp, make your own whenJust :: Maybe a -> (a -> IO ()) -> IO ()
13:04:10 <xic> ndm: thanks, what about the old wiki?
13:04:24 <desp> ndm: you're right, thanks.
13:04:24 <ndm> xic, unspecified, i think - no one cares though, lift code and be happy
13:04:42 * benny99 is gone for some uncertain amount of time
13:04:46 <ndm> desp, are you doing a libcurl binding?
13:04:57 <mauke> @type let whatever = return () in  maybe whatever
13:04:59 <lambdabot> forall (m :: * -> *) a. (Monad m) => (a -> m ()) -> Maybe a -> m ()
13:05:00 * benny99 allows anybody to /msg him if anything important happens
13:05:37 <desp> ndm: yes
13:05:51 <ndm> desp, is that a summer of code project? (i can't remember which there were in the end)
13:05:55 <desp> yep
13:06:17 <ndm> @seen Shimei
13:06:17 <lambdabot> Shimei is in #xmonad and #haskell. I don't know when Shimei last spoke.
13:06:31 <ndm> good good :)
13:06:51 <desp> another little thing -- I turned on -Wall, and I'm getting a warning about imported-but-not-used `.&.` from Data.Bits -- but I am using it
13:07:01 <desp> specifically, inside a pattern guard
13:07:18 <ndm> desp, ah, thats interesting :) - file a GHC bug
13:07:25 <bos> hi desp
13:07:27 <desp> right
13:07:30 <desp> bos: hello
13:07:32 <mauke> btw, doubly linked lists are made of evil and satan
13:07:48 <DRMacIver> Ha ha
13:07:55 <DRMacIver> Why? :)
13:07:55 <desp> bos: almost there ;) had to scrap the finalizers...
13:08:13 <bos> ok
13:08:28 <mauke> DRMacIver: first, they're completely useless for non-constant data because any operation on them is O(n) (at least)
13:09:15 <mauke> second, it's completely non-obvious to me how to make them do something like foldr
13:09:23 <mauke> (with sharing of results)
13:09:46 <DRMacIver> Fair enough
13:10:02 <newsham> mauke: doubly linked lists are O(n)?
13:10:10 <newsham> are we talking haskell or generally?
13:10:19 <mauke> newsham: any change anywhere in the list requires a complete rebuild
13:10:23 <bwerf> how do you instance a double linked list in haskell anyways ? you can't assign the newer node to the older node, purefunctional and all
13:10:29 <mauke> newsham: purely functional lists
13:10:42 <bos> @where knot
13:10:42 <lambdabot> I know nothing about knot.
13:10:47 <bos> @google tying the knot
13:10:50 <lambdabot> http://www.tyingtheknot.net/
13:10:50 <lambdabot> Title: BEBB | Studios
13:10:54 <bos> @google tying the knot haskell
13:10:58 <lambdabot> http://www.haskell.org/hawiki/TyingTheKnot
13:10:58 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
13:11:03 <bos> bwerf: see above
13:11:08 <bwerf> k
13:11:10 <mauke> bwerf: it's not that hard once you have a data definition
13:11:35 <mauke> I don't know a definition that enforces the linked list structure, though :(
13:12:08 <bwerf> in imperative context i prefer an arraylist backed on a circularly address array grown using buffer doubling when needed
13:12:22 <mauke> wtf is an arraylist?
13:12:49 <byorgey> mauke: it's a Java library
13:13:01 <joelr1> evening
13:13:13 <bwerf> ehmz, java has an arraylist, but it is much more general then that
13:13:14 <byorgey> hey joelr1
13:13:18 <Jaggederest> morning :)
13:13:28 <joelr1> folks, does anyone have an ACM subscription? i would love this article: http://portal.acm.org/citation.cfm?id=319838.319851&dl=Portal&dl=GUIDE&type=series&idx=319838&part=Proceedings&WantType=Proceedings&title=Conference%20on%20LISP%20and%20Functional%20Programming
13:13:33 <bwerf> amortized O(1) head and tail isnert and remove
13:13:33 <lambdabot> Title: : LFP '86, Design of an optimizing, ..., http://tinyurl.com/2gm28w
13:13:48 <bwerf> O(1) read/update O(n) insert
13:13:58 <bwerf> but O(1) insert at head or tail
13:14:42 <mauke> how is that different from a standard doubly linked list?
13:14:54 <glguy> Sequence has O(log(min(i,n-i))) read, updates and inserts
13:15:22 <bwerf> mauke: O(1) random read/update
13:15:35 <mauke> oh, by index?
13:15:43 <bwerf> mauke: and it uses alot less memory usually
13:16:08 <mauke> ok, so how does it work?
13:16:11 <byorgey> mauke: right, by index
13:16:34 <ekidd> @hoogle (a,b) -> (b,a)
13:16:34 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
13:16:47 <bwerf> you take a c style array allocated on the heap of the right type
13:17:01 <bwerf> if it is full you realloc it to double its previous size
13:17:04 <ekidd> Yuck. Is that really the best pair-flipping function in the standard library?
13:17:17 <desp> ndm: I was wrong about that unused import; I wasn't using the function which was using the import :)
13:17:21 <glguy> ?type curry (uncurry flip)
13:17:22 <bwerf> you keep track of the index in the array the first element is and wrap around as needed
13:17:23 <byorgey> ekidd: that's not a pair-flipping function.
13:17:26 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
13:17:45 <shachaf> @pl \(a,b) -> (b,a)
13:17:45 <lambdabot> uncurry (flip (,))
13:17:48 <bwerf> little wrapper around it to make it look like the first element has index 0
13:17:52 <bwerf> and done
13:18:06 <ekidd> shachaf: Ah, clever.
13:23:47 * ekidd is writing a paper
13:24:05 <bos> oh?
13:24:14 <ekidd> (Or, technically, procrastinating right this second.)
13:24:32 <ekidd> bos: Probability stuff, elaborating on my blog posts.
13:24:44 <bos> ah
13:27:08 <opqdonut> hey, i just grokked monads
13:27:13 <opqdonut> awesome
13:27:35 <icarroll> @quote monad
13:27:35 <lambdabot> mattam says: [Monads are] much more elegant [than soccer] in general.
13:27:40 <byorgey> opqdonut: hurrah!
13:27:56 <opqdonut> all the tutorials were just misleading me
13:28:02 <byorgey> @quote grok
13:28:02 <lambdabot> No quotes match. It can only be attributed to human error.
13:28:26 <opqdonut> monads are really a) an abstraktion on the return value of a function b) overloaded function composition
13:28:27 <ekidd> opqdonut: Congrats!
13:29:03 <icarroll> opqdonut: how did you arrive at this conclusion?
13:29:36 <ekidd> opqdonut: Have you tried writing your own monad yet? I find that's a good way to make sure I understand something. :-)
13:29:46 <opqdonut> it just kinda clicked together
13:29:58 <opqdonut> reading the beginning of The essence of functional programming was a catalyst tho
13:30:09 <opqdonut> ekidd: good idea
13:33:15 <quicksilver> opqdonut: have you read moggi's paper on monads?
13:33:33 <quicksilver> opqdonut: it's got some mathsy bits in which you can skip if you're not interested, but I find the computational insight to be quite good
13:33:58 <ekidd> quicksilver: Wadler's "Comprehending monads" is also good, and a bit lighter on the math.
13:34:40 <quicksilver> ekidd: Ooh, I don't think I've read that. But I've found other wadler papers excellent.
13:34:43 * quicksilver goes to look for it.
13:35:27 <ekidd> OK, enough procrastinating! Back to the paper.
13:37:55 <opqdonut> yeah wadler rules :)
13:39:03 <icarroll> Is there any monad for which bind is mplus?
13:39:07 <emu> i love it when simple usage of ByteString does better than fancy tricks
13:39:16 <emu> @type mplus
13:39:18 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
13:39:20 <emu> @type (>>=)
13:39:22 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
13:39:27 <icarroll> heh
13:39:28 <emu> no monad?
13:39:30 <icarroll> guess not :)
13:39:34 <emu> @type join
13:39:35 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
13:39:56 <icarroll> I suppose (>>) = mplus is what I'm looking for then.
13:40:14 <emu> aye
13:40:17 <emu> @type (>>)
13:40:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
13:40:54 <emu> (do ...; fail)`mplus` ...
13:41:03 <Heffalump> I hate fail.
13:41:29 <ndm> Heffalump, because its error, or for purity reasons with category theory?
13:41:38 <Heffalump> the idea of having something that in some monads will call error and in others be a natural semantic construct is just odd.
13:41:52 <ndm> tru
13:42:07 <ndm> it always does feel a bit weird using fail in Maybe, I always use return and Nothing
13:42:18 <Heffalump> I use mzero
13:42:33 <Cale> It's really a shame that MonadZero got killed off.
13:42:45 <dmhouse> Indeed. Why was that?
13:43:04 <Cale> Because every instance of it in the standard libraries was also an instance of MonadPlus.
13:43:10 <emu> is there a better way to convert a list of integers (large ones) into a line-separated string than unlines . map show ?
13:43:45 <ndm> emu, are you looking for something faster? or shorter and more beautiful?
13:43:49 <emu> faster
13:44:15 <emu> actually it's for putStr, so, putStr . unlines . map show
13:44:19 <ndm> that should be pretty fast
13:44:23 <dmhouse> Well, it would be a shame to lose the pattern match failure -> mzero semantics with current MonadPlusses, but then it would also be annoying to require a MonadPlus to use do notation.
13:44:27 <emu> it is pretty fast. just wondering
13:45:05 <ndm> emu, my optimiser would remove the intermediate lists, but should be pretty fast as it is
13:45:48 <Cale> dmhouse: You'd only need MonadZero for do-notation if you matched against a refutable pattern.
13:46:11 <dmhouse> Cale: so you're saying the type of a do-block should change based on the patterns contained within it?
13:46:11 <ndm> Cale, aren't irrefutable patterns desugared in the same way?
13:46:14 <Cale> dmhouse: Currently do-notation uses fail, which is evil.
13:46:19 <Cale> dmhouse: Yes.
13:46:26 <dmhouse> Right. Seems... flaky.
13:46:28 <Cale> ndm: Presently.
13:46:44 <opqdonut> ?instances MonadState
13:46:45 <lambdabot> s (ContT r m), s (ErrorT e m), s (RWS r w s), s (RWST r w s m), s (ReaderT r m), s (State s), s (StateT s m), s (WriterT w m)
13:47:21 <SamB> presently we don't seem to *have* a MonadZero class, which irks me.
13:47:50 <SamB> (did we have one before?)
13:47:54 <Cale> SamB: yeah
13:48:00 <Cale> SamB: Haskell 1.4 had it
13:48:17 <Cale> In fact, the Haskell 1.4 report is worth reading, especially the Prelude.
13:48:37 <Cale> One begins to wonder what the H98 committee was thinking :)
13:49:23 <dmhouse> Monomorphism restriction, anyone? :)
13:50:12 <SamB> is that another new "feature"?
13:50:30 <byorgey> SamB: it's neither.
13:50:33 <glguy> There is at least *some* merit to the MR
13:50:35 * SamB would prefer a "polymorphism warning"
13:50:45 <scodil> does anyone know of a vim script or something that will show indentation marks? so that you can tell if your text is properly aligned. something like vertical bars that run along the side of an indented block. the kde editor in kate/kwrite does this. there's got to be something similar for vim
13:51:04 <scodil> #haskell and #python seem like good places to ask about this. google isn't helping, and i don't like python
13:51:38 <SamB> Haskell's layout rule is a bit complicated for that, isn't it?
13:52:01 <SamB> perhaps SHIM can be made to do it, though...
13:52:01 <dmhouse> Kate/Kwrite just marks where the tabs are.
13:52:22 <scodil> no it has another feature that draws vertical lines
13:52:43 <SamB> scodil: does it work sensibly on Haskell code?
13:53:23 <johnnowak> scodil: something like this? (right side) http://www.suckless.org/shots/dwm-20070224.png
13:53:23 <scodil> its not smart like the C version, but it groups similarly-indented lines ok
13:53:44 <SamB> scodil: sounds kinda weak
13:53:44 <scodil> johnnowak: YEAH TOTALLY thats exactly the screenshot that made me think of it
13:53:53 <SamB> well, not that I'd expect more, mind you
13:54:24 <SamB> unless something was advertised as supporting that type of functionality with Haskell code, I mean.
13:54:53 <scodil> are the layout rules so sinister that they can't be written as vim syntax highlighting rules?
13:55:07 <scodil> (not that I would/could do it, mind you)
13:55:23 <SamB> ... probably yes
13:55:27 <scodil> hah. mind you. that was subconscious.
13:55:35 <scodil> i hate when that happens
13:56:24 <icarroll> @quote sinister
13:56:24 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
13:56:26 <scodil> johnnowak: so do you know what that script is in that screenshot? is it publicly available?
13:56:30 <SamB> @quote evil
13:56:30 <lambdabot> dylan says: <EvilRanter> perl, python etc will pointer all over the place, too  <dylan> they'll pointer on the carpet too!
13:56:42 <johnnowak> scodil: one sec, i think i have it around her somewhere...
13:56:47 <SamB> @remember scodil are the layout rules so sinister that they can't be written as vim syntax highlighting rules?
13:56:47 <lambdabot> Done.
13:57:01 <SamB> @quote evil
13:57:01 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
13:57:10 <icarroll> nicely put :)
13:57:16 <sieni> why, after all these years, we have quite a few nice operating systems, some very nice programming languages and NOT A SINGLE EDITOR THAT IS EVEN MARGINALLY USABLE!!!1!
13:57:45 <shachaf> sieni: VIM is usable.
13:57:47 <SamB> sieni: and yet we manage to edit files
13:57:49 * johnnowak has usable editors
13:57:58 <SamB> I think you have a strange definition of "marginally usable"
13:58:36 <scodil> its a big margin
13:59:01 <nattfodd> vim is more than usable, no matter the size of your margins
13:59:38 <SamB> nattfodd: how about the size of my flamethrower?
13:59:52 <scodil> that's always a factor
13:59:59 <benny99> sieni: vim is neat
14:00:09 <nattfodd> come on baby, light my fire
14:00:23 <Vulpyne> emacs can do that. It can make coffee too.
14:00:30 <icarroll> @quote emacs
14:00:30 <lambdabot> Entropy says: I agree; we need to remove Emacs' ridiculous dependency on a kernel being present
14:00:32 <benny99> sieni: you can use GEdit instead if you want to :)
14:00:42 <benny99> sieni: I like that one too, or Kite if you got KDE
14:00:43 <ndm> sieni, use TextPad
14:00:47 <benny99> (Kate?)
14:01:13 * SamB wonders how Entropy was planning to run helper apps with no kernel
14:01:17 <johnnowak> scodil: egh, got it
14:01:17 <nattfodd> kate or kile, I believe
14:01:37 <Vulpyne> Emacs can provide an ELF loader and syscall interface.
14:01:43 <sieni> benny99: is vim nowadays scriptable with a sensible language?
14:01:44 <benny99> whatever, those are neat and more modern
14:01:46 <icarroll> Emacs is a great operating system. Too bad no one's written a decent editor for it.
14:01:50 <sieni> benny99: at least emacs isn
14:01:54 <johnnowak> agggh
14:02:01 <SamB> Vulpyne: that wouldn't remove the kernel dependancy at all
14:02:02 <sieni> benny99: at least emacs isn't
14:02:07 <scodil> http://kate-editor.org/screenshots/kwrite/editing_c_code  <--- there's the kate feature i'm thinking of. it just marks of indent levels with dotted lines (running from "public:" to "private:" in that picture.) shouldn't be too hard, and back when I used kate with haskell, i remember it helped
14:02:07 <benny99> sieni: emacs is "totally scrptable"
14:02:08 <lambdabot> Title: Editing C++ code | Kate
14:02:09 <sieni> stupid keyboard
14:02:15 <daniel_larsson> Write helper apps in emacs lisp!
14:02:18 <sieni> benny99: yes, but the language sucks
14:02:20 <SamB> Vulpyne: it would merely mean that Emacs was stuck with a kernel to maintain
14:02:21 <Vulpyne> samb: Well, emacs would be the kernal. :)
14:02:24 <johnnowak> scodil: do this: set list, set lcs=tab:>-
14:02:27 <benny99> sieni: lol
14:02:33 <benny99> sieni: you are in the wrong channel then ;)
14:02:40 <benny99> sieni: check Visual *
14:02:46 <sieni> benny99: why? emacs lisp isn
14:02:51 <benny99> sieni: or run Visual *** under Wine if you want to
14:02:53 * emu awaits the completion of Yi
14:02:55 <sieni> STUPID KEYBOARD GRRRR
14:03:04 <shachaf> scodil: To enable what that screenshot has, add "tab:>-" to listchars and :set list.
14:03:11 <sieni> benny99: why? emacs lisp isn't a real lisp like common lisp or scheme
14:03:11 <johnnowak> scodil: if it doesn't work, you may be expanding tabs
14:03:14 <benny99> sieni: yeah, I don't like emacs that much too, but mainly because I didn't use it that often
14:03:19 <sieni> benny99: emacs lisp is a brain fart
14:03:21 <shachaf> scodil: But it only works for tabs, which are not recommended.
14:03:34 <SamB> sieni: CL sucks anyway
14:03:40 <benny99> sieni: whatever, there are *LOTS* of editors out there
14:03:42 <SamB> I mean, just look at how imports work
14:03:52 <benny99> sieni: most of them comming with haskell support etc. :)
14:04:00 <scodil> shachaf, johnnowak: yeah I use spaces
14:04:00 <shachaf> SamB: At least it's not dynamically scoped.
14:04:03 <SamB> for one name, you are stuck with either importing all of the slots, or none of 'em
14:04:03 <scodil> no dice
14:04:08 <SamB> that's pretty bad if you ask me
14:04:12 <johnnowak> scodil: ah, well not much point in it then :)
14:04:21 <sieni> benny99: I guess I
14:04:25 <scodil> well you still have to make sure things line up
14:04:43 <sieni> I hate this keyboard, I really do
14:04:44 <benny99> whatever, www.google.com helps ;)
14:04:44 <SamB> and, if you accidentally alter an existing symbol, there are no alarms that go off...
14:04:45 <scodil> sometimes the parse errors can be pretty confusing
14:05:13 <benny99> I'm gone again :)
14:05:19 <SamB> ... but later, other things (in other packages) will probably go crazy
14:05:21 <sieni> benny99: I guess I'll just improve Yi to fit my needs when I have the time and interest to do that
14:05:30 <Excedrin> scodil: Scite does that with Haskell code
14:05:32 <benny99> sieni: or try google
14:05:43 <sieni> for what?
14:06:04 <benny99> sieni: finding a text editor you like
14:06:13 <Excedrin> scodil: where "that" is visual lines for indent levels
14:06:19 <SamB> in short, I prefer to *not* have the things that a symbol represents referenced by mutable fields of a symbol
14:06:39 <scodil> Excedrin: yeah I've used scite. kate/kwrite does it too. I've just gotten used to vim now
14:06:43 <sieni> benny99: that
14:06:58 <scodil> used to use kate a lot and I liked that feature
14:07:41 <sieni> benny99:
14:07:43 <Excedrin> kate does it for Haskell code?
14:07:51 <benny99> sieni: I guess Visual Haskell is what you are looking for
14:07:55 <scodil> not intelligently, no
14:08:05 <sieni> benny99: Why do you think that?
14:08:06 * benny99 is gone, /msg if anything important is on your mind
14:08:06 <scodil> but if you've got a big ol' let...in it really helps
14:08:37 <scodil> especially in do-notation where the parse errors are less than helpful
14:08:42 <sieni> benny99: I do use emacs all the time (in viper-mode) and vim for writing mail and such
14:08:53 <benny99> sieni: because you get it for free (at least I think) and it got everything you probably like
14:09:14 <SamB> benny:
14:09:14 <sieni> like vi-keybindings and a sensible configuration/scripting language?
14:09:33 <SamB> but don't you need to, like, use Windows and Visual Studio to run that?
14:09:40 <benny99> sieni: ._. you can type text
14:10:02 <benny99> SamB: I guess Visual works using wine
14:10:13 <daniel_larsson> But hardly free )
14:10:19 <benny99> daniel_larsson: it is free
14:10:19 <johnnowak> sieni: you can script vim with python
14:10:24 <benny99> daniel_larsson: Visual Express at least
14:10:27 <Heffalump> Visual Haskell doesn't really work that well.
14:10:35 <benny99> *dunno*
14:10:36 <Heffalump> benny99: I thought that doesn't work with addins
14:10:41 <Heffalump> (Visual Express)
14:10:52 <benny99> Heffalump: I really dunno :(
14:11:05 <benny99> Heffalump: just know Visual C++ and that was a nice one
14:11:11 <Heffalump> there's this whole TestDriven.NET furore to publicise that :-)
14:11:13 <johnnowak> sieni: :help python
14:11:26 <benny99> Heffalump: but Codeblocks is as good (if it doesn't crash...)
14:11:31 <sieni> johnnowak: I know it's scriptable in Python :-)
14:11:32 <glguy> Visual Haskell is quite nice, I like all of the typing on hover
14:11:39 <benny99> whatever
14:11:42 <benny99> I'm gone :)
14:11:43 <johnnowak> sieni: well that's all you're going to get then! :)
14:11:49 <Heffalump> glguy: most of the Intellisense doesn't work reliably, though :-(
14:12:04 <glguy> well enough for me to enjoy using it
14:12:08 <glguy> maybe not perfect though
14:12:31 <sieni> johnnowak: well if the options are emacs lisp and python, then the options are like having to choose which arm to be cut off
14:12:44 <johnnowak> sieni: aye, but vim lets you work better with one hand.
14:12:58 <sieni> johnnowak: that
14:13:08 <sieni> johnnowak: that's true
14:13:09 <scodil> johnnowak: is that for when you write really sexy code?
14:13:10 <DRMacIver> sieni: Vimscript? ;)
14:13:25 <johnnowak> scodil: :)
14:13:27 <sieni> These large enter-keys should be banned
14:13:45 <dmhouse> sieni: they're the norm in Britain.
14:13:47 <SamB> sieni: totally agreed
14:13:59 <dmhouse> I hate the small ones, they're so hard to hit. :)
14:14:22 <Excedrin> also, ban agreeing, only allow disagreement
14:14:33 <dmhouse> Excedrin: agreed.
14:14:37 <SamB> well, in particular expecting someone who's used to the one kind to use the other should be banned
14:14:43 <Excedrin> I'm tired of all of this consensus
14:14:50 <scodil> i'm not
14:14:50 <johnnowak> Excedrin: i'm not!
14:14:53 <scodil> damnit
14:14:56 <johnnowak> egh..
14:15:03 <sieni> dmhouse: I have hard time not hittin it, when I want to hit ' or <backspace>
14:15:10 <SamB> but at least you won't accidentally hit enter when you switch from big to little
14:15:25 <SamB> sieni: I keep hitting it when I want \ or |
14:15:26 <dmhouse> SamB: no, you accidentally hit the keys arond it instead.
14:15:30 <DRMacIver> I hate switching keyboards.
14:15:40 <SamB> dmhouse: which can be fixed with backspace
14:15:50 <SamB> isn't nearly as embarrasing
14:15:54 <DRMacIver> One of the worst things in interviews is if I'm expected to use a computer there. I look like an incompetent because I can't use their keyboard. :)
14:16:04 <dmhouse> SamB: fair point.
14:16:17 <sieni> yeah, this is my brother-in-law's laptop, I'm baby-sitting here
14:16:20 <dmhouse> Anyway, who feels like a chapter review! http://en.wikibooks.org/wiki/Haskell/Laziness#Lazy_and_strict_functions -- just that one section.
14:16:23 <lambdabot> http://tinyurl.com/ykch9p
14:16:39 <SamB> sieni: what? a laptop with a big-ass enter key?
14:17:06 <whaleofconfusion> in a pure functional language, with no global variables, what is the difference between dynamic and lexical scope?
14:17:24 <SamB> whaleofconfusion: the same as usual
14:17:27 <whaleofconfusion> it seems like every time you refer to a variable it must be lexically named
14:17:50 <whaleofconfusion> so the latest dynamic binding would be the same as the latest lexical binding
14:18:02 <SamB> whaleofconfusion: not at all
14:18:35 <whaleofconfusion> could you give an example?
14:18:41 <SamB> @type ?x
14:18:43 <lambdabot> forall t. (?x::t) => t
14:19:11 <SamB> there is no binding for ?x around here!
14:19:41 <sieni> I don't think that a language with dynamic binding could be called purely functional
14:20:02 <Heffalump> why not?
14:20:29 <Heffalump> whaleofconfusion: lexical scope means that you just look statically to see where the variable would have been bound
14:20:40 <sjanssen> @protontorpedo
14:20:41 <lambdabot> can haskell be used to develop databases?
14:20:42 <Heffalump> dynamic scope means that the place it was bound will depend on the dynamic context
14:20:48 <whaleofconfusion> I know what they mean, I'm wondering if there's a difference
14:20:50 <sieni> Heffalump: perhaps I
14:20:53 <whaleofconfusion> for a pure functional language
14:20:56 <sieni> fuck this keyboard
14:21:06 <Heffalump> whaleofconfusion: well, you can bind ?x, then call something
14:21:17 <sieni> Heffalump: perhaps I'm confused, but dynamic binding seems to at least break referential transparency
14:21:18 <Heffalump> no lexical relation between the callee and caller
14:21:22 <SamB> whaleofconfusion: dynamic variables have their values carried more or less implicitly
14:21:40 <SamB> sieni: you could say that
14:21:46 <whaleofconfusion> but that never happens in a pure functional language
14:21:50 <whaleofconfusion> no implicit arguments
14:22:00 <sieni> Heffalump: instead of fixing the values of variables at the closure creation time, you look up them in the callers environment at call time
14:22:01 <SamB> whaleofconfusion: well, what about typeclasses?
14:22:03 <Heffalump> sieni: I don't think it does. Oleg has an example showing that it's not "true" dynamic binding as in (some) other languages.
14:22:28 <SamB> sieni: it doesn't work at all like that here
14:22:40 <SamB> sieni: in the core, it is totally explicit
14:22:51 <whaleofconfusion> making use of dynamic binding by naming a variable that is not lexically mentioned would break referential transparency
14:22:53 <sieni> Heffalump: SamB: url?
14:23:00 <Jaggederest> the only dynamic scoping I see is something like the state monad
14:23:23 <SamB> http://cvs.haskell.org/Hugs/pages/users_guide/implicit-parameters.html
14:23:25 <Heffalump> it is referentially transparent, because you can still substitute definitions into use sites
14:23:25 <lambdabot> http://tinyurl.com/35uxrh
14:23:27 <whaleofconfusion> but if you have dynamic scope but only name lexically mentioned variables, the difference is less clear
14:23:39 <whaleofconfusion> because that would still be pure functional
14:23:42 <Heffalump> and then collapse the implicit parameters once you have a binding
14:24:23 <Heffalump> http://okmij.org/ftp/Computation/dynamic-binding.html#implicit-parameter-neq-dynvar
14:24:24 <lambdabot> Title: Dynamic Binding, http://tinyurl.com/2lx5h5
14:25:29 <Heffalump> I'm not sure I agree with his conclusion; the binding is still dynamic in the sense of being determined by the dynamic context, it's just that the closest binding wins, so you can't override them later.
14:26:02 <SamB> Heffalump: well, the compiler sees it just like ordinary parameters...
14:26:40 <sieni> SamB: that makes sense
14:27:39 <SamB> ... approximately the same way it sees typeclass constraints
14:28:20 <SamB> (at least, in the case of GHC)
14:31:45 <hpaste>  zeeeee pasted "help, i'm getting a ghc-6.6.1 build error" at http://hpaste.org/215
14:32:08 <opqdonut> ?src Monad []
14:32:08 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
14:32:17 <opqdonut> urh, how did that work again?
14:32:35 <SamB> ?help src
14:32:35 <lambdabot> src <id>. Display the implementation of a standard function
14:32:37 <int-e> ?src [] (>>=)
14:32:37 <lambdabot> m >>= k     = foldr ((++) . k) [] m
14:32:44 <fbuilesv> Hello. I'm thinking of writing a blog engine (something like a simple Wordpress) for the educational value of it, any ideas of I should go for Network.CGI using Apache or should I try HApps?
14:32:46 <opqdonut> ah
14:32:50 <SamB> ?src [] Monad
14:32:50 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
14:33:19 <daniel_larsson> fbuilesv: if for educational value, I'd suggest HAppS
14:34:10 <fbuilesv> daniel_larsson: Any special reason?
14:34:20 <alexj> there is an early demo of blog implemented in happs in happs/doc/tut3
14:34:34 <fbuilesv> alexj: Great, that was my next question :D
14:34:52 <alexj> very primitive code but you can start with it.
14:35:20 <daniel_larsson> Well, no particular reason other than it's interesting to fiddle with :) More so than CGI programming
14:36:10 <fbuilesv> Haha, ok, now, let's suppose I want to try it in a web host with shared hosting somewhere (not local). That's not possible with HAppS, right?
14:36:34 <Heffalump> hi SyntaxNinja
14:36:51 <daniel_larsson> I guess that depends on the hosting setup
14:37:41 <daniel_larsson> But with HAppS, you'd get a separate web server, so I guess it might be trickier :)
14:37:57 <fbuilesv> Mmm, I'll look into it then, gonna read, thanks a lot!
14:38:15 <fasta> HApps got some funding, so I expect Happs to work.
14:38:20 <kaol> you can use HAppS via HTTP proxy too
14:39:00 <fasta> foo = do
14:39:01 <fasta>         if True then return () else return ()
14:39:01 <fasta> 	  >>=
14:39:01 <fasta> 	 (\f-> return f)
14:39:13 <fasta> Can I make this work _without_ indenting the lowest expression?
14:39:34 <Botje> you put a ; after the if statement?
14:39:47 <Botje> not much to a do block if you're going to >>= afterwards.
14:40:36 <fasta> Botje: yes, but in my application I do need it.
14:40:45 <fasta> Botje: thanks
14:40:56 <SyntaxNinja> y0 Heffalump
14:41:23 * Heffalump wonders how Haskell' is going. Haven't seen much noise about it lately.
14:46:45 <dmead> i heard ghc is getting rewritten
14:46:56 <Heffalump> in O'Caml?
14:47:03 <dmead> no idea
14:47:05 <benny99> dmead: right after they have rewritten g++ ?
14:47:22 <dmead> i heard it's getting rewritten to compile to assembler
14:47:24 <dmead> instead of c
14:47:58 <dmhouse> It already compiles to bytecode on some systems.
14:48:10 <benny99> sounds fast :)
14:48:14 <Heffalump> it's compiled to asm for a long time
14:48:19 <dmhouse> (I.e., directly to bytecode, rather than via C.)
14:48:25 <stepcut> dmhouse: -fasm
14:48:25 <Heffalump> I think it goes via C-- to asm now.
14:48:38 <Igloo> dmhouse: You mean machinecode, I think
14:48:51 <Igloo> It (ghci) does also compile to bytecode, though
14:48:54 <dmhouse> Most likely. Anything lower level than about C is greek to me.
14:49:26 <benny99> you should do some asm then :)
14:49:29 <emu> Socrates: mov eax,028h ?
14:49:31 * benny99 is afk again
14:49:38 <benny99> XD
14:51:27 <DRMacIver> Doesn't it compile to rather bad machine code at the moment? (I know next to nothing about the subject, but this is what I've heard).
14:51:41 <DRMacIver> (Well, assembler)
14:52:03 <SamB> DRMacIver: depends
14:52:13 <DRMacIver> On?
14:52:27 <sjanssen> phase of the moon
14:52:31 <stepcut> DRMacIver: http://www.cse.unsw.edu.au/~dons/nobench/x86_64/results.html
14:52:31 <lambdabot> Title: nobench: Haskell implementation shootout
14:52:50 <SamB> dmead: I heard they changed the *default* to generating ASM
14:52:53 <SamB> instead of C
14:53:26 <SamB> because GCC is so slow
14:53:49 <SamB> (mainly due to trying lots of inappropriate optimizations, I think)
14:54:16 <sjanssen> the C code GHC generates isn't exactly 'typical' C code
14:54:28 <SamB> true
14:54:31 <sjanssen> so GCC doesn't do all that well on it
14:54:32 <SamB> and it isn't C++, either
14:54:53 <DRMacIver> stepcut: I'm aware of the shootout performance. But GHC does a lot of really powerful high level optimisations, so generating fast code doesn't inherently rule out generating bad assembler once it actually gets down to the low level. :)
14:55:31 <sjanssen> DRMacIver: we'd have both high level and low level optimization -- in an ideal world :)
14:55:42 <DRMacIver> sjanssen: Sure. :)
14:55:56 <DRMacIver> sjanssen: And the high level ones are the ones which get exciting research funding, so...
14:56:02 <Heffalump> it doesn't shrinkwrap.
14:56:08 <DRMacIver> ?
14:56:12 <JohnMeacham> jhc compiles to 100% portable C code.
14:56:20 <Heffalump> I spent ages on the train this week trying to get it to optimise length [1..n] into a simple counting loop.
14:56:34 <sjanssen> Heffalump: isn't that solved in stream fusion?
14:56:36 <Heffalump> once I finally managed that, it was still storing one of the values on the stack
14:56:47 <Heffalump> sjanssen: quite possibly, I was planning on asking about that
14:57:36 <sjanssen> Heffalump: stream fusion is theoretically able to fuse length (foldl) and that enumeration
14:57:40 <Heffalump> shrinkwrapping is where you elide the stack operations at the entry and exit of a procedure where possible. Often made possible by introducing a tail call.
14:57:51 <Heffalump> sjanssen: I persuaded foldr/build to do it too, as it happens.
14:58:03 <Heffalump> though I'm not sure if my transformations were sound with regard to strictness
14:58:12 <sjanssen> Heffalump: by simulating foldl with foldr?
14:58:14 <Heffalump> yes
14:58:33 <Heffalump> the key step was transforming fix into a specialised version for (a -> b -> c)
14:58:40 <JohnMeacham> Heffalump: this is exactly what length compiles to in jhc:  repetae.net/foo.c
14:59:03 <JohnMeacham> http://repetae.net/foo.c
14:59:32 <Heffalump> JohnMeacham: I'm sure jhc does a great job, but it'd be nice if it'd also compile most Haskell programs (or does it now?)
14:59:45 <JohnMeacham> Heffalump: getting closer.
15:00:30 <Heffalump> cool
15:00:32 <JohnMeacham> though, check out that bit of c code. I made it generate idomatic C code. other than the funky naming conventions.
15:00:47 <Heffalump> it's certainly much more readable than GHC's C--
15:01:23 <fasta> JohnMeacham: Do you intend Jhc to be GHC compatible?
15:01:25 <JohnMeacham> _x5b__x5d is [] and _x3a is :. things starting with capital letters are constants #defined above.
15:01:52 <Heffalump> yeah, it all makes sense
15:01:52 <JohnMeacham> fasta: I am not sure what you mean. insofar as they both are implementations of haskell.
15:01:56 <Heffalump> what's jhc_case_inc() ?
15:02:13 <JohnMeacham> just a profiling hook. compiles to nothing when profiling isn't on.
15:02:22 <SamB> > '\x3a'
15:02:23 <lambdabot>  ':'
15:02:44 <fasta> JohnMeacham: GHC supports MPTCs, Fundeps, no monomo. restr. preprocessors... etc
15:02:45 <JohnMeacham> same thing with jhc_function_inc.
15:03:17 <fasta> JohnMeacham: (assert)
15:03:50 <Heffalump> fasta: jhc has magic underscore which is (IMO) nicer than GHC's assert
15:03:55 <fasta> JohnMeacham: Can one expect to give Jhc a project written in GHC Haskell to compile on GHC?
15:04:00 <JohnMeacham> fasta: I support many extensions, I am aiming for everything that will end up in H'. jhc supports a lot of extensions ghc doesn't. like polymorphic unboxed types, generalized assertions, first class existentials, etc...
15:04:04 <fasta> er Jhc
15:04:42 <SamB> JohnMeacham: how about sensible syntax for existentials?
15:04:48 <JohnMeacham> fasta: no. not yet. but it would depend on the extensions used. Most popular ones are going to be in H' anyway.
15:05:03 <JohnMeacham> type Foo = exists a . a -> a
15:05:05 <fasta> JohnMeacham: Do you participate in the H' process?
15:05:05 <SamB> I really don't want the GHC syntax standardizd.
15:05:14 <JohnMeacham> yes. I am on the comitee.
15:05:17 <SamB> JohnMeacham: exactly ;-)
15:05:17 <Heffalump> so which will be first, Haskell' or a usable jhc? ;-)
15:05:46 <fasta> JohnMeacham: oh, that's nice. So, it will be a matter of time before I try out your stuff :)
15:06:37 <JohnMeacham> Heffalump: perhaps in sync. jhc reached a milestone today, in that it passes full regressions. (a sizable chunk of nobench). I am going to spend a bit of time getting separate compilation working which should allow general use by everyone.
15:07:05 <Heffalump> nice.
15:07:08 <SamB> JohnMeacham: how much RAM are we looking at needing?
15:07:16 * Heffalump looks forward to some real competition in the Haskell compiler space
15:07:21 <beelsebob> http://newsvote.bbc.co.uk/1/hi/entertainment/6735631.stm?dynamic_vote=ON#vote_6732915_paris_hilton <-- quick, vote yes!
15:07:22 <Heffalump> what with Yhc too
15:07:23 <lambdabot> Title: BBC NEWS | Entertainment | Paris Hilton sent back to prison, http://tinyurl.com/ynkypc
15:07:30 <SamB> JohnMeacham: is it self-hosting yet?
15:08:09 <JohnMeacham> SamB: that really isn't a major goal at the moment. full H98  and a usable "fast compilation" mode are my current goals.
15:08:09 <fasta> Competition thrives innovation, so I read today.
15:08:15 <Heffalump> beelsebob: much more important: http://petitions.pm.gov.uk/kill-shambo/ ;-)
15:08:15 <lambdabot> Title: Petition to: stop the special treatment of the bull &quot;Shambo&quot;.
15:08:35 <SamB> JohnMeacham: yeah, fast compilation probably should come before self-hosting...
15:08:48 <JohnMeacham> SamB: less RAM usage is sort of what separate compilation is all about. so you can optimize smaller chunks at once.
15:08:49 <Heffalump> it's probably a prerequisite
15:09:12 <SamB> Heffalump: I wouldn't know. I think he has a lot of RAM...
15:09:34 <sorear> hello!
15:09:57 <JohnMeacham> 2G. I limit jhc to 768M though, to catch memory leaks sooner and not accidentally bump out my X server.
15:10:09 <nn-gentoo> hi all
15:10:24 <SamB> nn-gentoo: are you having trouble compiling lambdabot?
15:10:32 <nn-gentoo> no
15:10:47 <sorear> JohnMeacham: I'd NOT like to see the kind of forgetful compilation gcc specializes in...  incremental fully optimizing compilation of the forth flavor if you can manage it :)
15:10:52 <nn-gentoo> SamB, New Server usermain.net
15:11:10 <sorear> JohnMeacham: All I'd like is for it to run in 384M :)
15:11:19 <SamB> naesten@hydrogen:~% host usermain.net
15:11:19 <SamB> usermain.net does not exist, try again
15:11:39 <SamB> nn-gentoo: probably you need to wait a bit for the DNS to propagate
15:12:54 <DRMacIver> JohnMeacham: How good is the region inference stuff in JHC getting?
15:13:22 <JohnMeacham> sorear: indeed. it does accumulate information as it goes along. the problem at the moment is that it won't start optimizing (in any major way) until everything is collected at the end. I hope to spread that out more.
15:14:16 <fasta> When I am in Haskell mode and I evaluate an expression that starts external programs, how can I completely abort the evaluation? I.e. every process that was started gets killed and I get right back to the REPL?
15:14:23 <JohnMeacham> DRMacIver: it is pretty simple at the moment, just looking for finite regions, but it does find them and allocates them on the stack. I think that combined with a simple GC for the leftovers could work well.
15:15:50 <JohnMeacham> I would perhaps consider it 'escape analysis' at the moment. finding pointers that escape the current region. though, I have a nice (and perhaps novel) monadic representation of regions. Monadic intermediate languages are really nice to work with. much nicer than SSA form IMHO.
15:16:40 <sorear> JohnMeacham: Given 384M, is there any meaningful way to run jhcp?
15:16:58 <DRMacIver> There was an interesting paper on compile time garbage collection on LtU a while ago (I think it was presented as an alternative to region interface rather than a complementary approach), though I never got around to more than skimming it. Have you seen it?
15:17:12 <SamB> sorear: wait for "seperate compilation"
15:17:37 <JohnMeacham> the profiling version? sure. just create files with {-# OPTIONS_JHC -N #-} at the top. then compile with --noauto -ilib/base to just pull in a couple modules.
15:17:52 <SamB> oh.
15:17:57 <SamB> you really meant a p.
15:17:58 <JohnMeacham> Jhc.Basics, Jhc.IO and Jhc.Int should give you enough to write interesting test programs.
15:18:20 <sorear> JohnMeacham: -N ?
15:18:31 <sorear> is that like -fno-implicit-prelude ?
15:18:31 <JohnMeacham> or, that would work for just plain 'jhc'. I regularly do that when doing a testlcomplie roop.
15:18:35 <JohnMeacham> yes. exactly.
15:18:38 <pejo> DRMacIver, "compile time garbage collection"?
15:18:42 <sorear> ah yay!
15:19:02 <sorear> DRMacIver: that doesn't replace region allocation
15:19:12 <SamB> "a testlcomplie roop"?
15:19:24 <sorear> test/compile run
15:19:27 <JohnMeacham> --noprelude if you prefer.  'jhc --help' 'jhc -fhelp' are quite informative. I made sure every option was documented there.
15:19:46 <sorear> DRMacIver: Compile time garbage collection is the same thing as dead code elimination, but with a more meaningful name in a functional context
15:19:50 <JohnMeacham> yeah. WSS.
15:19:51 <fasta> Are the advanced garbage collection algorithms described good in the literature? Or is implementing one a whole different story?
15:19:52 <DRMacIver> Ah, here's the paper: http://www.mercury.cs.mu.oz.au/information/papers/CW2004_03_mazur.pdf
15:19:53 <lambdabot> http://tinyurl.com/ysgenx
15:20:05 <DRMacIver> sorear: Ah, I see.
15:20:09 <sorear> JohnMeacham: Huh.  -h give me uselessly terse output
15:20:17 <fasta> described well*
15:20:49 <JohnMeacham> sorear: hrm?
15:21:28 <sorear>     core-afterlift, core-beforelift, core-initial, core-mangled, core-mini, core-pass, core-steps
15:21:40 <JohnMeacham> jhc -dhelp to see those.
15:21:54 <JohnMeacham> jhc -fhelp to see code options.
15:22:28 <JohnMeacham> -d is all dumping things, -f is all code options. I suppose I should have it say '-fhelp for more info' as that is unclear.
15:23:11 <pejo> DRMacIver, once you know things are garbage and need to write new stuff, use the space of the garbage, basically?
15:24:04 <DRMacIver> pejo: Or even just free the space if you don't need to write new stuff.
15:24:11 <DRMacIver> It's not really something I know non-trivial amounts about though.
15:39:22 <ihope> #haskell.es isn't very active and I don't know enough Spanish to remark on that fact.
15:40:15 <JohnMeacham> just pushed about 100 patches or so. a whole wildly new number and primitive representation based on c--.
15:40:33 <sorear> Yippee!
15:40:45 <SamB> JohnMeacham: is it closer than GHC's Cmm?
15:41:10 <zeeeee> help, i'm getting a ghc-6.6.1 build error: http://hpaste.org/215
15:41:11 <sorear> JohnMeacham: is there any good documentation of jhc's MO?
15:41:28 <sorear> zeeeee:
15:41:30 <sorear> @bug
15:41:30 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
15:41:33 <JohnMeacham> numbers are now represented by 'bits'. like 'bits32'. 'Int' and 'Word' are just newtypes of them, and are only signed or unsigned due to different instances. like, the instance for Int calls the signed division primitive while the instance for Word calls the unsigned division one.
15:41:39 <sorear> ^^^ report it please, that's a real bug
15:42:13 <Igloo> zeeeee: What platform?
15:42:22 <zeeeee> Igloo, ubuntu
15:42:28 <zeeeee> 6.06
15:42:31 <Igloo> zeeeee: What arch?
15:42:38 <jacquesmerde> can someone recommend me a haskell learning resource? i learned haskell a few years ago, so a lot of it would be revision, but i want to learn it far mroe rigorously, eg knowing what is syntactic sugar and what is fundamental haskell...
15:43:04 * SamB has a stack of those for i386
15:43:12 <Cale> jacquesmerde: Well, there's the report, if you can stand it :)
15:43:26 <zeeeee> Igloo, Linux mtjs 2.6.18.5-gg10-mixed64-32 #1 SMP Tue May 8 22:29:42 PDT 2007 x86_64 GNU/Linux
15:43:30 <Cale> (together with the GHC User's Guide)
15:43:44 <JohnMeacham> it fits how computers actually work much better and compiles to nicer code.
15:43:48 <Cale> But that's sort of different than just learning the language :)
15:43:54 <Igloo> zeeeee: Hmm, interesting. What version of GHC are you using to compile 6.6.1 with?
15:44:17 <SamB> JohnMeacham: hmm, wonder why GHC doesn't do that.
15:44:32 <jacquesmerde> Cale: the report? ghc? i originally learnt with with hugs...
15:44:50 <SamB> perhaps because it doesn't allow unboxed types in polymorphic context...
15:45:13 <SamB> but that doesn't explain why Word# and Int#...
15:45:20 <zeeeee> Igloo, ghc 6.4.1
15:45:36 <Cale> jacquesmerde: ah, I pointed at the GHC user's guide because it describes all the extensions which people use
15:45:47 <SamB> I think unifying them would improve optimization considerably.
15:46:00 <Cale> jacquesmerde: The Report is the Haskell standard (which was last written in 1998, and is about to be revised)
15:46:03 <JohnMeacham> SamB: ghc only has a single number type, that us the size of a pointer on the current architectur. Word16 and whatnot are implemented by manually masking the upper bits after every operation.
15:46:09 <Cale> http://www.haskell.org/onlinereport/
15:46:10 <lambdabot> Title: The Haskell 98 Language Report
15:46:15 <SamB> @src Word
15:46:15 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:46:18 <SamB> @src Int
15:46:18 <lambdabot> data Int = I# Int#
15:46:31 <Cale> That might be too technical, but it will certainly let you know what's syntax sugar and what's not.
15:46:39 <SamB> well, for @src Word, it should have said "data Word = W# Word#"
15:47:00 <JohnMeacham> That is why 'Int' is (wrongly) 64 bits on x86-64. ghc can't handle more than two number types. (Int# and Word#)
15:47:15 <SamB> JohnMeacham: explain how it is wrong
15:47:23 <Igloo> zeeeee: Ah, you are running in 32bit mode?
15:47:26 <JohnMeacham> no.
15:47:40 <SamB> the Report says nothing about it being wrong
15:47:42 <JohnMeacham> the C int is 32 bits on x86-64 for good reason. it is considered a bug in ghc.
15:47:47 <SamB> it is?
15:47:48 <Igloo> zeeeee: You might need to run under linux32 or something
15:47:57 <JohnMeacham> not wrong in a technical sense. wrong as in a misfeature of ghc.
15:48:03 <SamB> ... exactly who considers it a bug?
15:48:06 <SamB> is there a ticket?
15:48:42 <zeeeee> Igloo, i'm not sure i understand (i'm completely new to 64-bit machines, never dealt with them before)
15:48:52 <zeeeee> am i currently in 64-bit mode?
15:49:02 <JohnMeacham> it doubles your code size among other things. you have to add 'REP' prefixes to every instruction acting on integers. and slows things down, halfs your cache lines, etc. x86-64 was designed for 32 bit arithmetic, but 64 bit addresses.
15:49:11 <Janni> Hello.
15:49:16 <SamB> JohnMeacham: oh.
15:49:17 <Janni> I'm currently porting GHC to FreeBSD-7 and have a minor (yet critical) problem.
15:49:44 <SamB> JohnMeacham: how does it half your cache lines?
15:50:17 <jacquesmerde> Cale: the report looks like something i'd really enjoy reading, it just looks like i'd need some background knowledge. (or have read and understood it first, to read and understand it)
15:50:24 <JohnMeacham> because your integers take up twice as much space in memory. and they are 8byte aligned, which can add lots of padding.
15:50:26 <Igloo> zeeeee: I think you're in 32bit mode, but things like uname still detect the CPU as x86_64, which confuses GHC. If you have linux32 installed then you should see the "x86_64" change to "i686" or similar if you run "linux32 uname -a" rather than "uname -a"
15:50:40 <SamB> considering that even if an Int# only took 4 bytes, GHC would still have to pad an Int out to 16 bytes...
15:50:43 <Janni> When I finally "make -C compiler stage=2" on the target machine, I get "ghc-pkg: dependency unix doesn't exist (use --force to override)".
15:50:46 <Cale> jacquesmerde: yeah, it's easy to read if you already know the language, and you just need to refine that knowledge
15:51:00 <Janni> Is there s.o. here, who is familiar with the GHC build process?
15:51:27 <Cale> jacquesmerde: If you're just learning, the Haskell Wikibook is pretty good (with a few exceptions)
15:51:46 <Cale> also, Yet Another Haskell Tutorial
15:52:10 <Cale> I wouldn't recommend learning about monads from either one.
15:52:11 <JohnMeacham> which is part of the reason Data.Binary serializing Int to 64 bits really bugs me. anything that assumes > 29 bits is broken anyway, and there won't even be _any_ compilers that have > 32bit ints at some point in the future.
15:52:17 <SamB> Janni: why does it need porting?
15:52:17 <zeeeee> Igloo, ok, linux32 now installed
15:52:21 <zeeeee> and uname reports i686
15:52:36 <Cale> Come here and we'll point you at resources, or just get you up to speed with a conversation, once you come to that point.
15:52:50 <Janni> SamB: There are no binaries for FreeBSD-7 yet.
15:53:06 <Janni> You need GHC for compiling GHC.
15:53:16 <Igloo> zeeeee: OK, if you build GHC in a "linux32 bash" shell or whatever then I think it should work. I'm not really an expert on the best way to work with a 32bit system on amd64, though
15:53:16 <atsampson> I thought the wikibook monads tutorial was pretty good, actually...
15:53:31 <SamB> Janni: so why does freebsd-7 need to break everything?
15:54:09 <Cale> atsampson: The analogy it uses is kind of bizarre.
15:54:18 <SamB> (I suppose a better question might be "why is GHC so hard to port"...)
15:54:48 <atsampson> Cale: "kind of"? ;)
15:54:58 <Janni> You can't run FreeBSD-6 binaries on FreeBSD-7 yet.
15:55:12 <Janni> Yes, the second is indeed a better question.
15:55:25 <Janni> GHC is written in Haskell using Glasgow Haskell extensions.
15:55:37 <jacquesmerde> Cale: yeah, i browsed the wikibook. was even less rigorous than my first year uni course in haskell
15:55:41 <Janni> So, you can't compile GHC without having a running GHC, which seems to be paradox...
15:55:46 <zeeeee> Igloo, it's compiling now, i'll see if it still dies
15:55:47 <Cale> atsampson: It's like the containers analogy, but not applied in quite the right way. I also don't like the use of "nuclear waste" to represent "values"
15:55:55 <fasta> JohnMeacham: why wouldn't there be such compilers?
15:56:01 <zeeeee> Igloo, btw if this works, does that mean i can only run ghc in 32 bit mode?
15:56:15 <Janni> So, to port GHC to a new platform, you need to get "bootstrap" binaries of ghc first, to compile GHC on the target machine then...
15:56:28 <Janni> SamB: OK?
15:56:28 <fasta> JohnMeacham: It seems natural to assume >29 when "everything" is 64 bits
15:56:40 <Igloo> zeeeee: I don't think you can run anything in 64bit mode, but like I say, I'm not clear on how it all works
15:56:51 <SamB> Janni: well, I thought the main problem was that GHC doesn't support cross compiling
15:56:53 <Lemmih> JohnMeacham++ # General coolness
15:56:59 <Janni> That to...
15:57:12 <Janni> (OK, that was an important thing I forgot to mention)
15:57:15 <SamB> but, I still think my first question is good
15:58:06 <Janni> There is not yet a compatibility layer for FreeBSD-7 available to run FreeBSD-6 binaries, which is probably the case, because FreeBSD-7 is not yet officially released.
15:58:12 <Janni> It's the developement branch...
15:58:54 <Janni> From version 6 to 7 quite a few libraries have changed, so FreeBSD-6 binaries can't be run if they use the "wrong" libraries...
15:58:59 <SamB> oh.
15:59:00 <SamB> that.
15:59:39 <jacquesmerde> Cale: is there a middle ground between the report/ghc user guide and the wikibook?
16:00:01 <jacquesmerde> Cale: is there a middle ground between manuals and tutorials?
16:00:28 <SamB> jacquesmerde: you want something akin to K&R?
16:00:46 <JohnMeacham> fasta: the report only guarentees 29 bits. so any program that assumes more than that in 'Int' is broken. use Int64 and friends if you need a specific width.
16:01:31 <jacquesmerde> SamB: yeah
16:01:41 <fasta> JohnMeacham: yes, I knew that, but sometime in the future that will probably be lifted.
16:01:50 <SamB> jacquesmerde: we don't seem to have one yet
16:01:52 <jacquesmerde> SamB: though actually i was surprised that K&R was less rigorous than it was
16:02:05 <fasta> JohnMeacham: but writing a program that depends on it now, is not smart, I agree.
16:02:12 <SamB> hmm?
16:02:15 <jacquesmerde> SamB: i'm not surprised that that last sentence actually made no sense
16:02:31 <fasta> jacquesmerde: a book
16:02:39 <jacquesmerde> SamB: nothing close?
16:03:01 <SamB> jacquesmerde: nothing with a cover...
16:03:24 <sorear> SamB: what about the Haskell Language and Libraries Report?
16:03:38 <SamB> sorear: that has a tutorial in the front?
16:04:15 <jacquesmerde> SamB: i preferred the second half of K&R
16:04:41 <SamB> jacquesmerde: you mean the part that starts on page 191?
16:04:54 <sorear> http://www.amazon.co.uk/Haskell-98-Language-Libraries-Revised/dp/0521826144 <- google saz
16:04:57 <lambdabot> http://tinyurl.com/24cc3h
16:05:25 <SamB> sorear: isn't that just the Haskell 98 Report?
16:05:32 <SamB> with revisions?
16:05:36 <sorear> SamB: Yes.
16:05:40 <sorear> 16:02 < SamB> jacquesmerde: nothing with a cover...
16:05:42 <JohnMeacham> fasta: I highly doubt it will ever be raised. more just arn't needed, and are already available in Data.Int.
16:06:04 <sorear> SamB: Same version online, but slightly older, and with a cover.
16:06:28 <SamB> sorear: he wanted something between the Wikibook and the Report...
16:06:33 <sorear> ah ok.
16:07:48 <JohnMeacham> architectures stay with 32 bits for their general purpose types because it is a nice 'sweet spot', not because they can't support more. Actually, I am considering making ints 30 bits in jhc on 32 bit arches. it would save a lot of memory indirections... I'd have to run tests though to see if it was worth it.
16:08:56 <sorear>   * start adding new c-- operator based representation
16:08:56 <SamB> JohnMeacham: how would it save indirections?
16:08:56 <sorear> Shall I pull this patch? (1/97)  [ynWvpxqadjk], or ? for help:
16:08:58 <sorear> YEAH!
16:09:06 <sorear> SamB: pointer tagging a la ocaml
16:09:15 <sorear> 31 bit 'int' FTW
16:09:16 <SamB> sorear: yeah.
16:09:19 <sorear> (guessing)
16:09:23 <JohnMeacham> SamB: because then they could be packed right into what would have been a pointer to a box containing an Int.
16:09:35 <jacquesmerde> SamB: while i was certainly a devoted of fan of K&R, i hope you can forgive me if i fail to remember which page numbers refer to which points in the text
16:09:46 <SamB> jacquesmerde: sure
16:10:00 <SamB> I just happen to keep mine handy
16:10:04 <JohnMeacham> not to mention the time saved reclaiming those Int boxes... of course. if everything gets unboxed as much as I hope, then it may be moot.
16:10:14 <chessguy> ok, so here's a question
16:10:16 <sorear> JohnMeacham: Uhm... good luck unboxing a 31 bit Int.  At least GHC can use ADD/SUB/etc on strict paths!
16:10:23 <SamB> JohnMeacham: yeah, I guess that's why I was asking ;-)
16:10:41 <sorear> JohnMeacham: unboxing being not quite the right term, but I'm sure you understand
16:10:55 <JohnMeacham> sorear: that won't be an issue. jhc will also use those on strict paths. unboxed ints are just ints like normal.
16:11:11 <chessguy> i've played with both vim and emacs (more of vim, but a little of both). i know some of the advantages and disadvantages of both. i know some people think one is the best and the other sucks.
16:11:20 <JohnMeacham> it would only do the tagging when ghc does a jump to an indirect pointer and a memory access. much much faster.
16:11:25 <sorear> JohnMeacham: IOW, you're going to make the size of Int depend on strictness annotations.
16:11:25 <SamB> JohnMeacham: but then you still need to shift to "unbox" and "rebox" them
16:11:32 * sorear makes a "crazy" hand gesture
16:11:55 <SamB> and you need to stick those "1"s in
16:11:58 <chessguy> personally, i think both are good, but one is probably more suited to certain people. my question is, how do i tell which of emacs and vim is better *for me*, without going through all the massive amount of learning involved in learning both
16:11:59 <JohnMeacham> SamB: yes. which is faster than jumping to a thunk or allocating heap memory.
16:12:14 <SamB> yeah
16:12:36 <JohnMeacham> sorear: it is fine by the standard, it only claims 29 bits and you can make no assumptions about what happens on wraparound.
16:12:46 <SamB> sorear: no!
16:12:54 <SamB> or. well. maybe.
16:13:03 <SamB> JohnMeacham: Data.Bits won't be happy.
16:13:19 <JohnMeacham> SamB: why not? it works on unboxed types.
16:13:38 <jacquesmerde> SamB: but yeah, i assume i mean that part
16:13:54 <SamB> jacquesmerde: the closest thing we have is the report
16:13:57 <weitzman> chessguy: Emacs may be more practical for general coding because of all the addons for it
16:14:12 <JohnMeacham> SamB: data bits needs some work anyway actually. remove the Num superclass, make two types of right shift. have shiftR and shiftL take 'Word' rather than Int arguments (or leave them unspecified for negative numbers).
16:14:18 <chessguy> weitzman, i really don't believe that either one is better or more practical for everyone
16:14:41 <SamB> JohnMeacham: I thought they were unspecified for negative numbers
16:14:59 <weitzman> chessguy: If there's a plugin or script to make VIM do something, it's almost guarenteed that there's something at least as powerful to do the same for emacs
16:15:01 <JohnMeacham> but, really, it might be fun to make Int's 30 bits just to test standards compliance of the various programs out there. :)
16:15:13 <int-e> JohnMeacham: fwiw, the haskell report wants 30 bits
16:15:18 <SamB> JohnMeacham: isn't ndm already doing that?
16:15:23 <chessguy> weitzman, i would bet that probably goes both ways
16:15:26 <weitzman> weitzman: I say this as a VIM guy whose only regret is that the emacs people are always showing off their fancy integration with stuff
16:15:47 <weitzman> I seem to be talking to myself
16:15:49 <JohnMeacham> SamB: ah. cool. well, the doc says shiftR is an alias of shift. which contradicts that... but I think those always being positive was the intent.
16:15:54 <SamB> chessguy: does vim have a validating XML parser?
16:16:11 <SamB> JohnMeacham: I don't remember reading that
16:16:14 <JohnMeacham> hmm.. I am not sure where I got 29 bits from.. 30 is good too.
16:16:19 <chessguy> samB, i wouldn't know, and that's not the point
16:16:19 <SamB> I think someone must have broken the docs
16:16:30 <JohnMeacham> SamB: it was in one of the haddock comments. which I suppose arn't canon.
16:16:41 <int-e> JohnMeacham: from the range of Int I guess, which is -2^29 to 2^29-1.
16:16:42 <SamB> JohnMeacham: they ought to be.
16:16:59 <JohnMeacham> int-e: ah. yeah. that must be it.
16:17:38 <weitzman> chessguy: I don't know if anyones clinically connected Emacs with RSI, but the weird hard to type shortcuts are uncomfortable for a lot of people
16:17:44 <SamB> JohnMeacham: engineered specifically because it is so convenient for tagging
16:17:48 <ddarius> chessguy: Pick one (flip a coin if you need to), use it, if it works for you then don't bother with the other.
16:17:49 <sorear> JohnMeacham: Where can i find information on jhc's current MO?
16:18:05 <SamB> weitzman: stallman has an RSI I think
16:18:06 <JohnMeacham> well, they should be correct certainly. :). separate shiftRA and shiftRL would be good to add. I think that is the most common reason I see CPP used in ghc, to get at those raw shifting primitives.
16:18:18 <JohnMeacham> sorear: MO?
16:18:37 <SamB> CPP?
16:18:38 <Excedrin> stallman's hands actually fell off
16:18:45 <SamB> Excedrin: what?
16:18:54 <sorear> JohnMeacham: mode of operation
16:18:57 <JohnMeacham> -fcpp preprocessor stuff to get compiler dependent stuff.
16:19:00 <Excedrin> SamB: you heard me
16:19:06 <sorear> JohnMeacham: from Latin "Modus operandi"
16:19:11 <stepcut> weitzman: the hardcore emacs users I know, all remap capslock -> control, which helps a fair bit
16:19:15 <sorear> I *thought* it was common :)
16:19:20 <JohnMeacham> sorear: hmm.. I am still not quite sure what you mean.
16:19:40 <benny99> @yaht
16:19:40 <lambdabot> Maybe you meant: fact part yarr
16:19:46 <SamB> when you say MO I think "Math Olympiad"
16:20:00 <sorear> JohnMeacham: i'd like a how it works summary document preferably a page or two
16:20:13 <sorear> SamB: I always qualify that USAMO
16:20:26 <chessguy> sorear, "current MO" is an oxymoron
16:20:40 <JohnMeacham> sorear: ah. there is this: http://repetae.net/john/computer/jhc/big-picture.pdf
16:20:43 <ddarius> sorear: I thought that first, but you (and others here) need to stop it with ridiculous abbreviations and acronyms.
16:20:44 <SamB> sorear: usually I hear it in the physical realm
16:21:04 <sorear> JohnMeacham: hmm.  is that still current?
16:21:20 <augustss> Isn't MO Math Olympiad?
16:21:25 <JohnMeacham> and comments in the files. particularly http://repetae.net/john/repos/jhc/data/jhc_rts2.c
16:21:36 <JohnMeacham> not entirely. but mostly.
16:21:39 <weitzman> chessguy: Another "disadvantage" of vim is that every time you get stuck using a text entry widget that doesn't support vim keybindings, you feel like you're using a crippled, dated GUI from 1975
16:22:10 <dylan> because you are. ;)
16:22:16 <JohnMeacham> and perhaps http://repetae.net/john/repos/jhc/E/TypeCheck.hs
16:22:38 <SamB> dylan: how is GTK from 1975?
16:23:05 <weitzman> VIM was written in 1976. Surely its technological advances should have propogated everywhere by now
16:23:12 <JohnMeacham> so.. yeah, there isn't really a good summary. documentation is something I need to work on. preferably something akin to darcs that can stitch together a document from source comments.
16:23:26 <SamB> why, I wouldn't really be very good at feeling that way because I wasn't born until 1986, and I don't think I even had a mouse until I was at least 6
16:23:33 <JohnMeacham> gotta run for a bit.
16:23:52 <Botje> weitzman: luckily, plugins exist to spread the VI love everywhere.
16:24:28 <weitzman> Botje: Some places better than others. The only Eclipse VI plugin I know of is commercial
16:25:10 <Jaggederest> emacs for life /ducks
16:25:18 <weitzman> Actually Emacs has a vi emulator, so I hear
16:25:20 <Botje> yes! even emacs has a vi mode! :)
16:25:39 <Jaggederest> yes, it does. Why, I don't know ;)
16:25:39 <SamB> emacs until someone comes up with a better way to integrate things with text editing...
16:25:52 <Botje> weitzman: this one? http://www.satokar.com/viplugin/
16:25:54 <lambdabot> Title: viPlugin for Eclipse | ... 'cause editing still is the way to code
16:26:06 <SamB> Jaggederest: for people who think it is an okay OS that needs a good text editor?
16:26:14 <weitzman> Botje: Yeah
16:26:44 <AshyIsMe> the emacs vi bindings limit your emacs usage quite a bit
16:26:46 <Botje> i'd gladly give the guy €15
16:26:48 <Jaggederest> this may be true Sam heh. Modal editing makes me angery and spiteful :)
16:26:51 <SamB> vi has no emacs mode because emacs users don't covet vi's features
16:27:30 <ddarius> vi people don't covet emacs' key bindings
16:27:50 <SamB> AshyIsMe: yeah. neither the vi users nor the emacs users know how to help you if you use viper
16:28:05 <ddarius> SamB: That's easy.  Don't use Viper.
16:28:11 <weitzman> Botje: As an IntelliJ user I've got my own free VI keybindings, but the poor students out there using Eclipse don't want to shell out money for open source stuff
16:28:11 <Jaggederest> otoh looking at RMS's hands emacs default bindings may not be best for my RTS problems
16:28:14 <SamB> hehe
16:28:40 <SamB> I would suggest Haskell for your RSI needs
16:28:56 <SamB> @topic-tell
16:28:57 <lambdabot> Do not know that channel
16:28:59 <SamB> @topic-tell #haskell
16:28:59 <lambdabot> ["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","
16:29:00 <lambdabot> The language of ICFP winners 3 years running"]
16:29:02 <ddarius> I was considering looking at emacs and using some such vi compatibility thing, but it didn't look very usable to me.
16:29:08 <Jaggederest> he's got more arthritis than my grandfather's whole nursing home
16:29:43 <Jaggederest> Yeah, haskell isn't bad, but the special character reaches are tough
16:29:53 <SamB> also, frequent gaming breaks (which RMS probably didn't get, with his "Free Software only" policy ;-)
16:30:10 <Jaggederest> python would probably be easiest in terms of damage per character
16:30:11 <SamB> Jaggederest: you are supposed to spend more time thinkiong
16:30:19 <SamB> less typing
16:30:24 <weitzman> I'm somewhat concerned about my hands, actually. I play piano, write software, and play video games. That can't be good for you
16:30:36 <chessguy> all at the same time?
16:30:38 <SamB> weitzman: it sounds much better than doing just one of those things
16:30:40 <DRMacIver> Not to mention spend time on IRC. :)
16:30:59 <Jaggederest> oh, no doubt, that's why I'm here. Family history of carpal tunnel = disability for programmers
16:31:07 <SamB> weitzman: use a real controller, though
16:31:26 <Jaggederest> minimize boilerplate where possible to avoid early retirement
16:34:10 <AshyIsMe> the shift keys are the worst
16:34:42 <AshyIsMe> my little fingers are starting to feel it and i'm not even out of college yet
16:34:46 <fasta> Can I do import qualified Foo <newline> import qualified Foo?
16:35:28 <fasta> This results from using a preprocessor that needs some modules, that other modules might already include.
16:36:25 <fasta> Yes, I can. How nice.
16:37:12 <ddarius> Jaggederest: Which keyboard layout do you use?
16:41:19 <gkr> Why are *algebraic* data types named 'algebraic'?
16:41:44 <sorear> Because they follow the laws of algebra.
16:41:56 <sorear> x + y corresponds to Either x y
16:42:03 <sorear> x * y corresponds to (x,y)
16:42:24 <sorear> 0 corresponds to data Z {- no constructors, a GHC extension -}
16:42:32 <sorear> 1 corresponds to data One = One
16:42:44 <gkr> You mean stuff in category theory?
16:42:52 <sorear> No, I mean algebra.
16:42:58 <sorear> Semirings specifically.
16:43:08 <dmhouse> Is something in normal form also in WHNF, or does WHNF exclude things in normal form?
16:43:19 <sorear> @google semiring
16:43:21 <lambdabot> http://en.wikipedia.org/wiki/Semiring
16:44:05 <gkr> sorear what do you recommend to read about the relations of 'algebraic' data types and algebras (semirings or whatever they are)?
16:44:48 <ddarius> dmhouse: Yes.
16:44:50 <sorear> gkr: My mind.  I have a gift for rediscovering things, and I didn't read this
16:44:59 <sorear> Google can probably find stuff
16:45:17 <ddarius> sorear: That's a pretty obvious one.
16:45:38 <syntax> the category theory might actually give you the entire semiring-of-types stuff for free.
16:46:28 <dfranke> woooooooot
16:46:30 <gkr> Like (a,b) is AxB?
16:46:37 <ddarius> Yes
16:46:39 <dfranke> building etch's default kernel, complete with all the modules that it enables:
16:46:44 <dfranke> $ time make -j10 bzImage modules
16:46:44 <dfranke> real 4m45.151s
16:46:44 <dfranke> user 29m17.774s
16:46:44 <dfranke> sys 6m20.272s
16:46:46 <dfranke> now for ghc!
16:47:19 <gkr> Okii. Which books cover these relations?
16:47:25 <Saizan> and data List a = Nil | Cons a (List a)?
16:48:01 <ddarius> Well there is also "algebra" in reference to "initial algebras"
16:48:31 <ddarius> Though not all Haskell ADTs are "algebraic"
16:49:01 <dmhouse> ddarius: which one? :)
16:49:10 <ddarius> The former
16:49:35 <dmhouse> Thanks.
16:49:43 <ddarius> dmhouse: In fact it is obvious that that must be the case.
16:49:47 <Saizan> uhm 1+(a*(1+a*(1+(a*....)))?
16:50:01 <ddarius> Saizan: Yes more or less.
16:50:41 <ddarius> Though, type List a = Nat -> a and that is algebraic using infinitary algebra
16:50:55 <ddarius> Er, that is Stream
16:53:12 <ddarius> But most typical Haskell data types are term algebras a la universal algebra
16:54:52 <lumi> Hi, I have a question about Control.Applicative
16:55:14 <sorear> Just ask it.
16:55:21 <gkr> ddarius what do you recommend to read?
16:55:42 <ddarius> gkr: For what precisely?
16:55:47 <lumi> There are two functions there, 'some' and 'many', that, afaict, diverge on any non-empty input
16:56:05 <ddarius> @hoogle some
16:56:06 <lambdabot> Data.Generics.Schemes.something :: GenericQ (Maybe u) -> GenericQ (Maybe u)
16:56:06 <lambdabot> Data.Generics.Schemes.somewhere :: MonadPlus m => GenericM m -> GenericM m
16:56:06 <lambdabot> System.Console.Readline.setIgnoreSomeCompletionsFunction :: Maybe ([String] -> IO [String]) -> IO ()
16:56:14 <ddarius> @type some
16:56:16 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
16:56:44 <lumi> Oh hm
16:57:02 <ddarius> @index some
16:57:02 <lambdabot> bzzt
16:57:12 <Saizan> @type many
16:57:13 <ddarius> > ''some
16:57:13 <lambdabot>  Improperly terminated character constant
16:57:13 <lambdabot> forall (f :: * -> *) a. (Alternative f) => f a -> f [a]
16:57:32 <lumi> Is it that it's sort of "repeat" lifted but with different cases for empty?
16:57:40 <Saizan> ?instances Alternative
16:57:41 <lambdabot> Couldn't find class `Alternative'. Try @instances-importing
16:58:08 <lumi> No, that doesn't seem to be it
16:58:10 * ddarius knows almost nothing about Control.Applicative
16:58:23 <lumi> > some []
16:58:25 <lambdabot>  []
16:58:30 <lumi> > some [1]
16:58:31 <lambdabot>  Exception: <<loop>>
16:58:47 <Saizan> > take 1 $ some [1]
16:58:48 <lambdabot>  Exception: <<loop>>
16:58:59 <ddarius> @src some
16:58:59 <lambdabot> some v = some_v
16:58:59 <lambdabot>   where many_v = some_v <|> pure []
16:58:59 <lambdabot>         some_v = (:) <$> v <*> many_v
16:59:02 <lumi> It loops immediately, note the lack of output
17:00:06 <ddarius> @src Alternative
17:00:06 <lambdabot> class Applicative f => Alternative f where
17:00:06 <lambdabot> 	empty :: f a
17:00:06 <lambdabot> 	(<|>) :: f a -> f a -> f a
17:00:27 <ddarius> @src [] (<|>)
17:00:27 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
17:00:43 <lumi> I've been using Applicative, but I only noticed Alternative today, and then these functions, which make no sense to me
17:00:46 <Saizan> > [1] <|> [2]
17:00:47 <lambdabot>  [1,2]
17:00:56 <ddarius> Saizan: I figured.
17:00:59 <syntax> wait, wait.
17:01:07 <syntax> <|> is WHAT?
17:01:07 <dmhouse> > [1,2,3] <|> [4,5]
17:01:08 <lambdabot>  [1,2,3,4,5]
17:01:09 <lumi> http://darcs.haskell.org/ghc-6.6/packages/base/Control/Applicative.hs
17:01:09 <ddarius> @src [] (<$>)
17:01:09 <lambdabot> Source not found. You type like i drive.
17:01:12 <lambdabot> http://tinyurl.com/2ynf8y
17:01:16 <lumi> <|> is ++, for lists
17:01:24 <Saizan> ddarius: i'm just trying for myself :)
17:01:26 <gkr> ddarius relationship between algebra and data types.
17:01:32 <kpreid> > some [[1]]
17:01:33 <lambdabot>  Exception: <<loop>>
17:01:43 <kpreid> > some [[()]]
17:01:45 <lambdabot>  Exception: <<loop>>
17:01:52 <ddarius> > (+) <$> [1,2,3] <*> [1,1,1]
17:01:54 <lambdabot>  [2,2,2,3,3,3,4,4,4]
17:02:44 <int-e> many [1]  would have an infinite list as its first result. :/
17:03:22 <Saizan> ?type (<*>)
17:03:24 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
17:03:25 <int-e> presumably this is the right behaviour for greedy parsers
17:04:13 <Saizan> > [(+1),(+2)] <*> [1..3]
17:04:14 <lambdabot>  [2,3,4,3,4,5]
17:05:43 <ddarius> gkr: At a basic level there's not much more to say than what sorear said.  Haskell data types are usually not directly related to abstract algebra.  Subsets of them are clearly term algebras from universal algebras (or alternatively initial algebras from category theory).
17:05:45 <int-e> > [(+1),(+2)] `ap` [1..3]
17:05:47 <lambdabot>  [2,3,4,3,4,5]
17:07:13 <Saizan> ?type (<$>)
17:07:15 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
17:07:39 <lumi> <$> is just fmap
17:07:43 <Saizan> yeah
17:08:24 <lumi> I still don't see how to get 'many' or 'some' to be useful in any sort of way
17:08:27 <Saizan> > take 1 $ fmap (:) [1] `ap` undefined
17:08:28 <lambdabot>  Undefined
17:08:39 <Saizan> > take 1 . fmap (take 1) $ fmap (:) [1] `ap` undefined
17:08:41 <lambdabot>  Undefined
17:09:44 <lumi> You're unrolling some?
17:09:50 <lumi> I mean, 'some'
17:13:04 <Saizan> yep
17:13:27 <gkr> Many thanks ddarius for your reply.
17:13:45 <Saizan> > fmap (take 1) $ fmap (:) [1] `ap` [undefined] -- this works but many_v doesnt' seem to be so defined ad [undefined] :)
17:13:46 <lambdabot>  [[1]]
17:14:20 <ddarius> > head $ some [1]
17:14:21 <lambdabot>  Exception: <<loop>>
17:14:26 <ddarius> > head $ some [1,2]
17:14:28 <lambdabot>  Exception: <<loop>>
17:14:55 <lumi> It must have *some* use, or it wouldn't be in base, right?
17:15:22 <Saizan> well it has for other instances maybe?
17:15:53 <ddarius> Yay! Free monad construction in a Haskell paper.
17:15:57 <lumi> The instances it comes with are Maybe and []
17:16:19 <Saizan> > some (Just 1)
17:16:20 <lambdabot>  Exception: <<loop>>
17:16:28 <lumi> Oh hm, apparenly also MonadPlus and ArrowPlus, maybe those can do anything at all
17:17:43 <lumi> But it doesn't even seem to return the first element of the list
17:21:38 <hpaste>  int-e pasted "Control.Applicative.many example." at http://hpaste.org/217
17:26:02 <hpaste>  int-e annotated "Control.Applicative.many example." with "alternative definition of <|> - still useful behaviour." at http://hpaste.org/217#a1
17:26:21 <int-e> lumi: does that help?
17:26:50 <lumi> int-e: Thanks, I'm trying to follow...
17:30:41 <benny99> Haskell is just great :)
17:30:47 <ddarius> Indeed it is.
17:31:14 <benny99> but it's 2:30am here :Z, so... sleep well :)
17:31:19 <benny99> ddarius: =)
17:33:42 <lumi> int-e: So why is it meaningless for []? It has to return an infinite list first, and can only do it when it's at the end?
17:34:14 <norpan> hey, it's 2:30 here too
17:34:20 <int-e> lumi: pretty much, yes.
17:35:31 <lumi> int-e: I get it, thanks :) Strange that it appears next to instances that make it useless and with no motivating example, though
17:42:56 <int-e> lumi: hmm. but where else would you put it? there are many ways to define parsers and arguably most of them can be made an instance of Applicative.
17:43:42 <int-e> lumi: the documentation can be improved though. (parsers are really the only thing I can think of where 'some' and 'many' would be useful)
17:47:35 <dons> http://programming.reddit.com/info/1x2gp/details
17:47:36 <lambdabot> Title: Using Haskell syntax for other purposes: the Test monad (reddit.com)
17:49:16 <hpaste>  zeeeee pasted "help, i'm running into build errors for missingh" at http://hpaste.org/218
17:50:02 <int-e> @index mapP
17:50:03 <lambdabot> bzzt
17:51:29 <sorear> parMap ?
17:55:39 <lumi> Off to sleep, thanks again
17:55:39 <sorear> 'night
17:55:39 <ddarius> ndm: That actually is a monad
17:55:39 <dons> ddarius: you worked out the laws for it? that seq doesn't complicate it, does it?
17:55:39 <zeeeee> can anyone help with my build error
17:56:44 <sorear> ddarius: ndm isn't here now
17:57:05 <norpan> i am a monad, bind me
17:57:48 <ddarius> dons: I've considered them in my head and I think the seq may still be fine perhaps with the right definition of return.
17:58:28 <ddarius> No, with return = Pass the laws seem to hold.
17:58:38 <ddarius> Ack, not quite.
17:58:42 <norpan> the earth seems to be flat
17:59:48 <ddarius> Actually...
17:59:57 <ddarius> The associative law seems to hold
18:00:18 <norpan> although it seems to be spinning after a few drinks
18:01:01 <ddarius> return X >>= f === f X holds if f isn't strict
18:01:34 <ddarius> m >>= return = m holds
18:02:57 <ddarius> Using return x = x `seq` Pass makes return X >>= f == f X hold if f is non-strict
18:03:14 <ddarius> er is strict
18:04:32 <ddarius> Or something. That case is the tricky one.
18:08:36 <int-e> @bot
18:09:20 <sorear> dons: check the bot
18:09:53 <int-e> sorear: no, not parMap, I was just curious if the identifier was taken. (should've used privmsg)
18:16:53 <byorgey> @pl \(a,b) (c,d) -> (a+c,b)
18:17:15 <byorgey> aww, no lambdabot?
18:17:19 * byorgey sulks
18:17:45 <sorearhuman> Have no fear
18:17:46 <sorearhuman> !
18:17:47 <sorearhuman> (+)***const
18:18:10 <byorgey> ah! right, thanks, I knew it had something to do with arrows =)
18:23:48 <SamB_XP> there is a baughnie in
18:23:51 <SamB_XP> ##c
18:24:03 <SamB_XP> (which is a lambdabot)
18:24:09 <MyCatVerbs> As opposed to what, #c#?
18:24:24 <sorear> there is a mbot in #math
18:24:30 <SamB_XP> true
18:24:33 <MyCatVerbs> Oh wow, it does exist.
18:24:42 <sorear> there is a lambdabot2 in several of the alt-language #haskells
18:24:48 <SamB_XP> perhaps Baughn or Cale would loan us one?
18:24:57 <SamB_XP> oh.
18:24:58 <ddarius> @bot
18:24:58 <lambdabot> :)
18:24:59 <SamB_XP> nm.
18:28:48 <byorgey> @type ((+) *** const)
18:28:50 <lambdabot> forall a a1 b. (Num a) => (a, a1) -> (a -> a, b -> a1)
18:29:18 <byorgey> hmm... well, after all, sorearhuman is only human =)
18:29:36 <byorgey> @pl \(a,b) (c,d) -> (a+c,b)
18:29:36 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . (((.) . (const .)) .) . flip . ((,) .) . (+))
18:29:41 <byorgey> gah
18:30:01 * byorgey tries to teach lambdabot about arrows
18:31:01 <MyCatVerbs> @pl (\(x,y)->y x)
18:31:01 <lambdabot> uncurry (flip id)
18:32:12 <ddarius> @type (uncurry (+) *** snd)
18:32:14 <lambdabot> forall a a1 b. (Num a) => ((a, a), (a1, b)) -> (a, b)
18:32:36 <ddarius> not quite
18:34:25 <syntax> it's fascinating just how polymorphic id is.
18:34:32 <ddarius> syntax: ?
18:35:35 <syntax> in what other type system would id work both on singleton types and tuples?
18:35:44 <Philippa> syntax: a small infinity of them
18:35:45 <syntax> so uncurry (flip id)  means something?
18:39:09 <sorear> Yes.
18:39:16 <sorear> It's a haskell term.
18:39:29 <syntax> I know what uncurry (flip id) means :)
18:39:50 <syntax> I'm saying, "in what other type system would that mean something?"
18:40:11 <syntax> @type uncurry (flip id)
18:40:13 <lambdabot> forall a c. (a, a -> c) -> c
18:42:14 <sorear> syntax: Type systems don't assign meanings to terms.  (Denotational semantics do)
18:42:26 <ddarius> > let twice f = f . f; dup x = (x,x) in twice dup
18:42:27 <lambdabot>      Occurs check: cannot construct the infinite type: c = (c, c)
18:42:27 <lambdabot>       Expec...
18:42:34 <syntax> sorear: I'm being very imprecise today. True.
18:42:57 <syntax> I should say "in what type system that even type-checks", etc. etc.
18:43:04 <syntax> it's been a bad day.
18:43:07 <sorear> Plenty.
18:43:15 <ddarius> > let dup x = (x,x) in dup . dup  -- let twice f = f . f; dup x = (x,x) in twice dup
18:43:16 <lambdabot>  Add a type signature
18:43:27 <ddarius> :t let dup x = (x,x) in dup . dup  -- let twice f = f . f; dup x = (x,x) in twice dup
18:43:29 <lambdabot> forall a. a -> ((a, a), (a, a))
18:43:30 <duey> how do I make a list e.g [1,2,2,2,2,3,3,4] equal [1,2,3,4] ?
18:43:40 <ddarius> nub
18:44:48 <ddarius> Or map head . group . sort for an asymptotically quicker version
18:46:00 <ddarius> That doesn't preserve ordering
18:46:23 <duey> thanks
18:51:20 <syntax> @src nub
18:51:21 <lambdabot> nub = nubBy (==)
18:51:25 <syntax> @src nubBy
18:51:26 <lambdabot> nubBy eq []             =  []
18:51:26 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
18:52:21 <sorear> > nubBy(((>1).).gcd)[2..]  -- nubBy can be handy sometimes
18:52:28 <ddarius> > let nub = foldr (\x -> filter (not . (x==)) [] in nub [1,2,2,3]
18:52:28 <lambdabot>  Parse error
18:52:30 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
18:52:36 <ddarius> > let nub = foldr (\x -> filter (not . (x==))) [] in nub [1,2,2,3]
18:52:37 <lambdabot>  []
18:53:00 <ddarius> > let nub = foldr (\x -> x:filter (not . (x==))) [] in nub [1,2,2,3]
18:53:01 <lambdabot>  Couldn't match expected type `[a]'
18:53:15 <ddarius> > let nub = foldr (\x -> (x:) . filter (not . (x==))) [] in nub [1,2,2,3]
18:53:17 <lambdabot>  [1,2,3]
18:53:51 <syntax> > nubBy ((==) . (flip mod 7)) [1..25]
18:53:52 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
18:54:02 <syntax> > nubBy ((==) . (mod 7)) [1..25]
18:54:03 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25]
18:57:10 <ddarius> > nubBy (curry (uncurry (==) . flip mod 7 *** flip mod 7)) [1..25]
18:57:11 <lambdabot>  Couldn't match expected type `Bool'
18:58:11 <ddarius> :t curry (uncurry (==) . flip mod 7 *** flip mod 7)
18:58:13 <lambdabot> forall a b. (Eq a, Integral (a, a), Integral b) => (a, a) -> b -> (Bool, b)
18:59:17 <ddarius> > nubBy (curry (uncurry (==) . (flip mod 7 *** flip mod 7))) [1..25]
18:59:18 <lambdabot>  [1,2,3,4,5,6,7]
19:38:44 <petekaz> @type flip
19:38:47 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
19:38:52 <petekaz> @type map
19:38:54 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:39:03 <petekaz> @type flip map
19:39:04 <lambdabot> forall a b. [a] -> (a -> b) -> [b]
19:39:14 <dons> flip map is 'foreach' in my books :-)
19:39:30 <dons> ?let foreach = flip map
19:39:32 <lambdabot> Defined.
19:39:42 <dons> > foreach [1..10] $ \n -> n * 2
19:39:44 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
19:39:49 <petekaz> @type fix
19:39:51 <lambdabot> forall a. (a -> a) -> a
19:39:57 <petekaz> @type flip fix
19:39:59 <lambdabot> forall b c. b -> ((b -> c) -> b -> c) -> c
19:40:51 <petekaz> I must me very stupid ... I still don't get how flip can work on fix because the first arg of flip is (a->b->c), but fix has a type of (a->a)->a
19:41:02 <petekaz> s/me/be/
19:41:10 <byorgey> @src flip
19:41:10 <lambdabot> flip f x y = f y x
19:43:11 <byorgey> I guess it's not so much that flip 'works on' fix as it is that (flip fix) is a function such that (flip fix) y x == fix x y
19:44:00 <byorgey> @type flip id
19:44:02 <lambdabot> forall b c. b -> (b -> c) -> c
19:44:11 <nn-laptop> hi
19:44:21 <byorgey> hi, nn-laptop
19:44:35 <nn-laptop> i have an ssh box server for devs
19:45:00 <nn-laptop> any one need some remote storage space?
19:46:20 <petekaz> byorgey: but fix only takes one arg right?
19:46:50 <byorgey> petekaz: right
19:47:02 <byorgey> petekaz: think of it this way: what would something like fix x y mean?
19:47:19 <petekaz> that would assume fix x returns a function.
19:47:24 <byorgey> exactly
19:47:57 <byorgey> so (flip fix) is the function which takes two arguments, fixes the second, yielding a function, which it applies to the first.
19:48:25 <byorgey> that is, (flip fix) y x == fix x y
19:49:22 <byorgey> petekaz: the thing is, with currying, every function really only takes one argument
19:50:32 <petekaz> right, but shouldn't the type of fix indicate in returns a fn?  I guess the part that confuses me is how to reconcile the type of flip's first arg (a -> b -> c) with fix's type (a -> a) -> a.  In the case of map (a -> b) -> [a] -> [b], it is easy to see that flip's a == map's (a -> b), and b == map's [a], and c == map's [b].  But with fix, I can't do that simple substition.
19:53:18 <byorgey> petekaz: if you specialize the type of fix to ((b->c) -> (b->c)) -> b -> c it matches the type of flip's first arg.
19:53:47 <byorgey> petekaz: the 'a' in flip's first arg happens to be ((b->c) -> (b->c))
19:54:25 <petekaz> I see.
19:54:29 <byorgey> petekaz: fix doesn't necessarily return a function in general.  but if you apply flip to it, then it has to.
19:55:24 <byorgey> petekaz: see if you can understand (flip id) too. =)
19:55:36 <SamB_XP> @type flip id
19:55:38 <lambdabot> forall b c. b -> (b -> c) -> c
19:55:38 <petekaz> ok .. let me think about it.
19:58:59 <chessguy> @djinn a -> b -> c
19:59:00 <lambdabot> -- f cannot be realized.
19:59:22 <byorgey> @type \a b -> undefined
19:59:24 <lambdabot> forall t t1 a. t -> t1 -> a
19:59:32 <byorgey> cannot be realized, my foot
19:59:42 <byorgey> =)
20:00:07 <ddarius> djinn does not allow undefined or recursion
20:00:13 <cdsmith> byorgey: djinn only writes functions that are guaranteed to evaluate normally.
20:00:35 <byorgey> cdsmith: I know, just being silly =)
20:00:54 <cdsmith> byorgey: ah, okay.
20:01:16 <petekaz> byorgey: I can't seem to work backwards to specialize types to fit flips.  I guess my brain does'nt work that way.
20:01:25 <byorgey> petekaz: ok, hold on a minute
20:01:55 <byorgey> petekaz: first, id x y = (id x) y = x y.  so in fact id = ($).
20:02:48 <petekaz> ok.
20:02:58 <ddarius> @pl ($)
20:02:58 <byorgey> petekaz: so then (flip id) x y = id y x = (id y) x = y x.
20:02:58 <lambdabot> id
20:03:16 <byorgey> so (flip id) is a function which applies its second argument to its first.
20:03:22 <byorgey> @type flip id
20:03:24 <lambdabot> forall b c. b -> (b -> c) -> c
20:04:19 <petekaz> neat.
20:05:35 <byorgey> > (\x -> x + 5) `id` 3
20:05:36 <lambdabot>  8
20:05:50 <byorgey> sort of an abuse of id, but nifty =)
20:06:37 <petekaz> > map (`id` 1) [(+1), (+2)]
20:06:39 <lambdabot>  [2,3]
20:06:49 <Jaggederest> 0_o
20:08:04 <geezusfreeek> oh gosh
20:09:17 <ddarius> ?
20:09:27 <ddarius> What is surprising?
20:09:52 <int-e> > sequence [(+1), (+2)] 1 -- more surprises?
20:09:53 <lambdabot> Terminated
20:09:59 <int-e> > Control.Monad.sequence [(+1), (+2)] 1 -- more surprises?
20:10:00 <lambdabot>  [2,3]
20:11:02 <geezusfreeek> i just came in and saw people playing with id and "oh gosh"ed in exasperation
20:11:11 <geezusfreeek> don't worry about it
20:11:19 <geezusfreeek> i should have kept my fingers still
20:11:28 <hpaste>  ivanm pasted "Error building hgl" at http://hpaste.org/219
20:11:42 <gwern> so, I'm interested in writing a little program. the idea is to take a database dump of all Wikipedia articles in XML format, do something with it such that a big list of external links (links to websites other than wikipedia) is generated, and then calling webcitation.org/archive repeatedly with each link. what sort of libraries would I be looking at using to accomplish this?
20:12:36 <ddarius> Look on the libraries page on haskell.org and Hackage.  The choices should be obvious.
20:12:43 <ddarius> Well, the options
20:13:18 <gwern> ddarius: not really. I've never done anything with XML in haskell so I don't even know which of the listed libraries would be useful
20:13:51 <dankna> well, what you want to do with the xml is to parse it.  you're going to find a stream-style parser more suited to going through a huge dataset like this than an object-style parser.
20:13:55 <gwern> would I even want an XML library? maybe I should be looking at regexps? or perhaps I really want parsing (in which case I've heard a lot of people talk about parsec)
20:14:04 <dankna> I haven't done this in Haskell, so I can't really advise on that
20:14:11 <dankna> but don't try to parse xml with regexps, it's a world of pain
20:14:19 <dankna> and there are so many ready-made parsers available
20:14:23 <Excedrin> gwern: what do you want to do? HXT is pretty nice
20:14:35 <gwern> well, this is the sort of basic thing I don't even know I don't know
20:15:07 <dankna> well, I think we just covered most of what there is to not know.  yes, you want an xml-specific library, because there's just no good reason to write your own except as a learning exercise.
20:15:11 <gwern> Excedrin: I'm going to take a big XML file of Wikipedia articles and extract external links from it, is the short-term goal
20:15:28 <Excedrin> oh, that needs something that does lazy parsing then afaik
20:15:35 <gwern> dankna: ok... and you say I want a streaming one?
20:15:45 <Excedrin> yes, streaming/lazy whatever
20:15:52 <Excedrin> you can't parse it all at once since it's huge
20:16:09 <dankna> right.  google the terms DOM and SAX to get a bunch of people talking about why we have both types and why you want the streaming (SAX-style) one.
20:16:16 <gwern> no, the uncompressed file is like 9GB
20:16:43 <dankna> right.  streaming means it doesn't keep anything in memory that you don't explicitly store yourself, it essentially just tokenizes it for you
20:16:46 <byorgey> all of Wikipedia fits in 9GB?
20:17:03 <dankna> the other thing you'll need is a library to make http requests
20:17:09 <dankna> in order to submit these to webcite
20:17:30 <dankna> again, many exist, no reason to roll your own, but it's actually pretty easy to roll your own if you get frustrated with the options
20:17:33 <gwern> byorgey: no - the full SQL tables for *everything* is about 80GB compressed the hell out of it, and images and multimedia run a couple hundred gigabytes compressed, don't know how much exactly
20:17:46 <trecool> do you know where i can find the movie "300"
20:17:47 <dankna> the other thing you really ought to do is make sure the webcite people are okay with you doing this!
20:17:50 <gwern> the 9GB figure is just for the XML dump of just mainspace stuff
20:17:54 <dankna> it seems like it might place something of a strain on their servers
20:17:56 <trecool> hi
20:17:56 <gwern> trecool: www.isohunt.com
20:18:08 <trecool> is it for free?
20:18:36 <byorgey> gwern: OK, that's what I thought
20:18:38 <ivanm> trecool: put it this way, do you want it legal or illegal?
20:18:44 <ivanm> and how exactly is this haskell related?
20:18:48 <ivanm> functional deaths? :p
20:18:51 <trecool> thank you gwern; is it for free though?
20:18:51 <gwern> dankna: they seem to rate-limit stuff. they also claim they're going to set up a batch system where you upload an XML file containing a lot of links and they archive the stuff.... whenever
20:19:18 <gwern> trecool: I'm pointing you to illegall bittorrents, so yes it is free, sheesh
20:19:39 <gwern> how does one know enough to get onto freenode and visit #haskell and not know how to download movies? yeesh
20:20:25 <kfish> damn, I thought this was a book: http://digitalmedia.oreilly.com/2005/08/03/combinator.html
20:20:28 <lambdabot> Title: O'Reilly -- Revenge of the Combinator
20:20:49 <dankna> well, #haskell was probably a random click given how little it has to do with the subject, heh
20:21:11 <dankna> but it's best to just ignore these things
20:21:30 <SamB_XP> we are perhaps a bit too helpful?
20:21:36 <dankna> heh, it looks like a nifty music program though
20:21:53 <gwern> hmm. is HaXml lazy?
20:22:33 <dankna> haven't used it, no idea, but my guess would be that anything written in Haskell is lazy
20:23:13 <kpreid> well, you can have programs structured such that they're not usefully lazy
20:23:21 * dankna nods
20:23:44 <kpreid> for example, insert (reverse . reverse) anywhere
20:23:47 <kpreid> or foldl
20:24:22 <dankna> haha, that's a very amusing call there.
20:24:59 <dankna> yeah, I'm quite new to Haskell (I'm an ex-Lisp programmer) so please don't take anything I say as at all authoritative
20:25:03 * byorgey wonders how hard it would be for a compiler to optimize (reverse . reverse) away
20:25:26 <sorear> byorgey: Very
20:25:26 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
20:25:32 <sorear> byorgey: it doesn't mean the same thing!
20:25:39 <byorgey> sorear: hm, I guess you're right
20:25:40 <sorear> > head [0..]
20:25:41 <lambdabot>  0
20:25:45 <sorear> mutt
20:25:50 <sorear> @slap sorear
20:25:50 <lambdabot> why on earth would I slap sorear
20:25:54 <sorear> @messages
20:25:54 <lambdabot> kc5tja said 14m 10s ago: Applying the header patch now. Check the Kestrel site for my patch including the Forth unit test micro-framework.
20:26:20 <bos> @pl \(n, s') -> countem (i+n) (tail s')
20:26:21 <lambdabot> uncurry ((. tail) . countem . (i +))
20:29:20 <byorgey> g'night all.  happy haskelling!
20:31:26 <petekaz> dons: When I read your zipper/xmonad article, and then read the haskell wiki zipper page, I noticed that in your arithmetic tree example, you take a different approach.  I.e in the wiki page, the zipper consists of the thread, which is a list, one entry deep for each level you descend.  But you decided to just create and maintain your own structure.
20:32:29 <petekaz> I tried to implement your example like the wiki page approach, with a thread.  I think the code is easier to comprehend, but maybe its just me.
20:33:32 <petekaz> So is the zipper supposed to be done one way or the other?  Or is does a zipper just mean 'in spirit' you have some cursor like object that lets one do constant time updates at the current node?
20:33:44 <sorear> petekaz: Zippers are very spiritual
20:34:14 <sorear> petekaz: there is a more concrete difference thought - dons' zippers have both a hole and a plug
20:34:19 <petekaz> The haskell wiki zipper page is great (except for all the math at the end of it)
20:34:28 <sorear> petekaz: last I checked, haskellwiki zippers are just the hole
20:34:47 <petekaz> I don't follow what you mean by hole and plug.
20:35:04 <sorear> [1,2,3,4,5,6]
20:35:10 <sorear> hole: [1,2,3,_,5,6]
20:35:13 <dons> petekaz: in ours, the zipper is a list zipper, its one per workspace
20:35:13 <sorear> plug: 4
20:35:18 <dons> not a single zipper for all workspaces
20:35:27 <dons> since we have to track focus on each workspace separately
20:35:42 <dons> and they have both a hole and a plug, yep.
20:37:26 <Cale> Yeah, so it's x d/dx rather than just d/dx. :)
20:38:44 <petekaz> I don't get it.  I implemented a zipper for Tree a = Leaf a | Node [Tree a] using the the thread concept from the wikipage.  What does my implementation not do that the hole and plug one does?
20:42:41 <Cale> petekaz: you're just storing an additional path to the hole?
20:44:00 <dons> petekaz: that's fine.
20:44:06 <petekaz> My zipper consists of a thread and the current node
20:44:09 <dons> xmonad doesn't use a tree zipper though. it uses a list zipper per workspace.
20:44:23 <dons> and a list zipper doesn't need threads, since there's no way 'up'
20:44:33 <petekaz> where the thread is a list of my way down the tree.
20:44:43 <dons> all there is in a list zipper is left and right nodes.
20:44:44 <chessguy> @seen procyon112
20:44:44 <lambdabot> I haven't seen procyon112.
20:45:04 <petekaz> dons: right.
20:45:47 <JohnMeacham> back-ish
20:45:50 <petekaz> dons: I guess my comment re: your zipper example, was specific to the arithmetic example you did.  I think I found that code harder to read than code that would have kept a thread.
20:46:10 <kpreid> New, zippier zippers!
20:46:11 <Cale> petekaz: Can you update the stuff around the context in constant time?
20:49:30 <petekaz> I believe so, I thought that was the whole point.
20:49:53 <petekaz> The thread just lets me combine the current node with its preceding context.
20:50:31 <petekaz> Maybe I better read that wiki page again ... now you guys are making me think I am confused.
20:51:44 <Cale> You might be fine.
20:53:17 <petekaz> I did the exercise from the wiki page first.  Make a zipper for a list.  That was easy.  Then make one for data Tree a = Leaf a | Bin (Tree a) (Tree a), and I used the thread idea.
20:54:06 <hpaste>  petekaz pasted "my binary tree zipper" at http://hpaste.org/220
20:54:37 <petekaz> And then I tried to make a zipper for the arithmetic example in don's article.
20:55:03 <hpaste>  peteakz pasted "my zipper from don's article" at http://hpaste.org/221
20:55:07 * dons looks
20:56:21 <dons> looks reasonable petekaz.
20:56:33 <dons> the one in my article was exactly the one from the original paper.
20:56:40 <dons> then a specific variants for xmonad workspacces.
20:56:41 <petekaz> Ok.  So how does this hole and plug thing relate?
20:57:36 <dons> that's just another way of thinking about the cursor point.
20:57:53 <petekaz> oh.
20:58:09 <petekaz> I see.
20:58:17 <Cale> T = x + T^2, dT/dx = 1 + dT/dx*T + T*dT/dx
20:58:50 <Cale> So data Tree' x = Leaf' | BinL (Tree' x) (Tree x) | BinR (Tree x) (Tree' x)
20:59:02 <Cale> That's how I'd do it.
20:59:08 <dons> yeah
20:59:27 <dons> that's the natural way , based on Conor's work, I think  (?)
20:59:43 <Cale> Did Conor actually come up with the idea himself?
21:00:04 <Cale> This actually parallels exactly some material from combinatorics which is at least 50 years old.
21:00:36 <Cale> I was actually a little surprised that the paper was as new as it was.
21:00:43 <Cale> (Conal's)
21:01:29 <Cale> It's similar to stuff that they teach in the 3rd year combinatorics class at Waterloo. (and occasionally in the 2nd year one too)
21:03:04 <Cale> Though, I suppose that's one step away from the category theory way to think about it, but the category theory way's been around a while too.
21:03:34 <chessguy> .
21:08:18 <lispy> and .
21:11:16 <Cale> http://en.wikipedia.org/wiki/Combinatorial_species -- it's basically the same as the differentiation discussed there
21:11:17 <lambdabot> Title: Combinatorial species - Wikipedia, the free encyclopedia
21:11:50 <Cale> Though that page doesn't really say enough about it.
21:13:14 <emu> hulo
21:13:24 <lispy> Cale: too bad you can't fix it :)
21:14:24 <Cale> But you see there that they mention that it has something to do with removing a single part of a structure.
21:15:48 <Cale> (and the example for lists results in the same thing you'd expect in the programming case :)
21:33:35 <gogonkt1> I found that Haskell so diffren, make me confuse, seem more like Ocaml
21:35:03 <dons> haskell was influenced by ocaml, and the SML family.
21:35:27 <dons> the core type systems are very similar
21:36:51 <gogonkt1> is new feeling than C,Java...
21:39:26 <ivanm> dons: is SML in general half imperative, half functional like Ocaml, or is that just Ocaml?
21:39:49 <gogonkt1> rember
21:39:52 <emu> SML is more focused on functional, but it has mutation
21:39:53 <dons> SML is impure and strict, like OCaml, but maybe a bit more `functional'
21:40:14 <ivanm> *nod*
21:41:14 <emu> that was a neat solution you posted dons
21:41:22 <gogonkt1> rember some say something make you feel faint , you geting something new in your mind
21:41:24 <emu> i didn't know about the chunking
21:41:57 <lispy> dons: have you compared you code against a C implementation that just mmaps the whole thing and works off that?
21:42:03 <lispy> so we have a baseline
21:42:08 <dons> yes, i think no one but duncan and I knew about that :/
21:42:30 <emu> it seems to be how LazyByteStrings are implemented? ondemand chunks?
21:42:33 <dons> lispy: i just compared mine against the C version that followed my version
21:42:36 <dons> emu: right.
21:42:52 <emu> i found a way of rewriting those functions to be more compact, but when i applied it to other problems, it didn't work out so well as the "simpler" code
21:42:59 <dons> in fact, the list (:) constructor on lazy bytestrings can be viewed as sugar for filling the cache
21:43:04 <gogonkt1> maybe I got new life in Haskell :P
21:43:05 <dons> so when you see:
21:43:19 <dons> f (c:cs) = ... :: [Strict.ByteString] ->
21:43:28 <dons> if we demand 'c', it causes the cache to be filled
21:43:43 <dons> so there's a nice, clear operational effect, encoded in the list cons :-)
21:44:05 <dons> *but* its still too hard to write this for non bytestring authors, i think.
21:44:28 <dons> however, if you can, you get a nice listy DSL for doing string processing in constant space.
21:45:01 <hpaste>  emu pasted "processing chunks" at http://hpaste.org/222
21:45:22 <dons> emu: i wonder if I could factor out my line/list chunk function into a simple module for doing strict, super-fast folds over lists of lines.
21:45:48 <ivanm> anyone got any idea why hgl won't compile? http://hpaste.org/219
21:45:59 <dons> emu: yes, i did exactly that, but note now you have a bounds check for null on eachchar
21:46:03 <dons> S.null t
21:46:06 <emu> i attempted to adapt this kind of code to other problems, but the performance was not so stellar
21:46:15 <emu> ah hm
21:46:16 <dons> so i think its a bit better to lift the S.null check to the end of each line
21:46:24 <dons> hence my inner/outer split
21:46:54 <emu> for example -- ones where it was necessary to output something for each line
21:47:16 <dons> yes. it is clear how to do very fast folds
21:47:23 <dons> but other kinds of things hmm.
21:47:26 <emu> at first i tried threading I/O and calling putStr immediately, but it turned out to be faster to accumulate a list and putStr . unlines . reverse it
21:47:56 <dons> you could accumulate the offsets, and call ByteString.putStr each time around. but the MVar locks on the Handles will probably kill performance anyway
21:50:05 <emu> unfortunately, the C implementations of INTEST are still over 2x as fast
21:51:14 <dons> than the best bytestring versoin?
21:51:18 <dons> oh, that sounds like a challenge!!
21:51:19 <emu> than yours, yeah
21:51:26 <dons> ok, do we have the src somewhere?
21:51:27 <sorear> dons: fwiw, I would implement the ML program using a state machine.
21:51:30 <emu> sure
21:51:41 <dons> yes, doing it in ocaml or sml would be interesting.
21:51:51 <sorear> mailing list :)
21:51:52 <hpaste>  emu pasted "INTEST" at http://hpaste.org/223
21:51:57 <sorear> dons: numbers modulo fixed K is a regular language and I will treat it as such
21:52:01 <dons> the ocaml optimiser does an excellent job on decoding stream fusoin combinators, for example
21:52:10 <dons> and works on strict bytestrings already
21:52:14 <emu> i think we had CAML beat though!
21:52:16 <sorear> flex should utterly smash C on INTEST
21:52:27 <emu> actually my doChunks version somehow came a bit ahead. might've been flukey though
21:52:41 <dons> emu, yea, but given laziness, and cache chunking, i suspect the ocaml compiler will produce better asm
21:52:58 <dons> but you would probably have to write a fair bit more code to get the on-demand cache filling
21:53:22 <dons> hmm. i wonder how much the bytestring performance really is due to just paying attention to cache architecture.
21:53:24 <hpaste>  emu pasted "TMUL" at http://hpaste.org/224
21:53:47 <emu> for example, on TMUL, i tried a complicated chunking-style parser, but it turned out to be faster just to use S.lines and S.readInteger
21:54:03 <sorear> dons: the beauty of the FSM approach is that chunking is essentially a non-issue, you can start and stop processing at any byte
21:54:05 <dons> huh. S.lines isn't terribly good, in my view.
21:54:07 <emu> i suspect the integer arithmetic was to blame there though. S.readInteger looks heavy.
21:54:17 <dons> yeah
21:54:32 <dons> doLine looks like an unfoldr
21:54:38 <sorear> dons: in ASM I would do this using goto and perfect hashing to build a FSM, refilling the buffer on SIGSEGV
21:54:43 <emu> it is yea
21:54:50 <emu> i actually used unfoldr in some other example
21:55:06 <dons> bos wrote this interesting sum file impl:
21:55:07 <dons> import qualified Data.ByteString.Lazy.Char8 as B
21:55:07 <dons> countem !i = maybe i (\(n, s') -> countem (i+n) (B.tail s')) . B.readInt
21:55:07 <dons> main = print =<< countem (0::Int) `fmap` B.getContents
21:55:11 <dons> which is a faster unfoldr
21:55:27 <dons> my unfoldr approach is usallly:   foldl' (+) 0 . unfoldr readInt
21:56:20 <dons> interestingly, there's still 20% faster bytestrings sitting in the stream fusion bytestring branch
21:56:26 <bos> woo!
21:56:27 <dons> to appear soonish (before Sept.)
21:57:39 <emu> dons: while doChunks does extra S.nulls, your version uses S.breakEnd which I think is missing rules that S.break has
21:57:53 <emu> and S.append
21:57:59 <emu> it just seemed a bit extra :/
21:58:03 <dons> right. S.breakEnd won't use a memchr (I think)
21:58:09 <emu> yea
21:58:16 <dons> the S.append aligns up chunks though, that's a big win.
21:58:32 <emu> but if  you are usign a FSM to parse anyhow ..
21:58:37 <dons> *but* it only has to walk maybe 5 chars back from the end anyway
21:58:59 <dons> findFromEndUntil f ps@(PS x s l) =
21:59:00 <dons>     if null ps then 0
21:59:00 <dons>     else if f (last ps) then l
21:59:00 <dons>          else findFromEndUntil f (PS x s (l-1))
21:59:01 <emu> but to append it has to copy the whole thing?
21:59:03 <dons> is breakEnd.
21:59:05 <emu> yea
21:59:25 <dons> oh, doh. my mistake
21:59:30 <dons> there's a much better `append`' version
21:59:43 <dons> that copies just the bit at the end, and the bit at the start of the next chunk
21:59:47 <dons> grumble.
22:00:08 <dons> new !i (s:t:ts) | S.last s /= '\n' = new (add i s') ts'
22:00:08 <dons>   where
22:00:08 <dons>     (s',r)  = S.breakEnd (=='\n') s
22:00:08 <dons>     (r',rs) = S.break    (=='\n') t
22:00:08 <dons>     ts'     = S.concat [r,r',S.singleton '\n'] : unsafeTail rs : ts
22:00:11 <dons> that does the minimal copy
22:00:42 <dons> so take the smallest bit of the end, the smallest prefix off the next chunk, append those, and do a zero-copy substring on the next chunk
22:01:38 <emu> aye
22:01:45 * dons checks the performance
22:01:47 <emu> make a new line
22:01:57 <dons> yeah
22:02:11 <dons> hah
22:02:18 <dons> $ time ./G < in
22:02:18 <dons> 29359
22:02:18 <dons> ./G < in  0.06s user 0.03s system 100% cpu 0.093 total
22:02:25 <dons> oh oops. cpu clock.
22:02:26 <dons> $ time ./G < in
22:02:26 <dons> 29359
22:02:26 <dons> ./G < in  0.19s user 0.02s system 80% cpu 0.262 total
22:03:01 <dons> versus the big append/copy:
22:03:02 <dons> $ time ./F < in
22:03:02 <dons> 29359
22:03:03 <dons> ./F < in  0.21s user 0.03s system 81% cpu 0.296 total
22:03:09 <dons> so another 10%
22:03:34 <dons> and 21 GCs ,versus 38
22:03:49 <lispy> dons: can you turn off the GC?
22:03:58 <dons> hmm. good idea.
22:04:09 <dons> though for constant space use... you kinda want it ... :-)
22:04:18 <lispy> oh hmm
22:04:26 <lispy> i was hoping it didn't allocate enough in total to matter
22:04:43 <dons> nah, doesn't seem to matter, as you say
22:04:50 <dons> 81424/81424 avg/max bytes
22:05:11 <lispy> so i guess you could set the major/minor GC thresholds very high
22:05:11 <emu> beats the previous version by a little
22:05:52 <hpaste>  dons pasted "minimal copy on align" at http://hpaste.org/225
22:07:12 <emu> would -O1 vs -O2 hurt?
22:07:31 <dons> -O2 would be better now.
22:07:36 <dons> since that turns on SpecConstr
22:07:49 <dons> particular in the ghc head, probably makes a good win.
22:08:45 <emu> ah it did indeed
22:09:25 <dons> how much different?
22:09:34 <dons> (you can see the rules firing with -ddump-simpl-stats)
22:09:46 <emu> ~15%
22:11:26 <dons> nice. that's roughly what SpecConstr does, when it fires, according to the paper.
22:11:35 <emu> we're now trouncing SBCL and Java
22:11:57 <lispy> now i'm impressed...SBCL does some pretty amazing optimization
22:11:58 <dons> on which program?
22:12:07 <emu> INTEST ;)
22:12:15 <dons> is that submitted?
22:12:25 <emu> and by trouncing i mean a difference of less than a second, but still
22:12:30 <emu> yea
22:12:37 <dons> is the table online?
22:12:37 <emu> https://www.spoj.pl/ranks/INTEST/start=60
22:12:40 <dons>  ah ha
22:13:22 <hpaste>  emu annotated "INTEST" with "current version" at http://hpaste.org/223#a1
22:13:34 <dons> where's the haskell version?
22:13:55 <emu> #61 ?
22:14:51 <dons> ah yes.
22:15:56 <dons> so do we know what the very fast C / C++ versions do?
22:16:25 <sjanssen> emu: I want to see a solution to BLINNET in Haskell
22:17:38 <emu> i haven't really found any versions of INTEST in C but i'm looking
22:17:55 <emu> https://www.spoj.pl/forum/viewtopic.php?t=362  /shrug
22:22:33 <sjanssen> BLINNET has only been solved in C, C++, Pascal, Java (by only 3 people), Fortran
22:22:47 <emu> hmm!
22:23:08 <sjanssen> it's just a straighforward MST problem -- but it has huge input
22:23:10 <dons> time to strike, emu!
22:23:38 <ed1t> wats BLINNET?
22:23:57 <emu> hm, prim's?
22:24:20 <sjanssen> ed1t: http://www.spoj.pl/ranks/BLINNET
22:24:24 <lambdabot> Title: Sphere Online Judge (SPOJ)
22:24:34 <sjanssen> https://www.spoj.pl/problems/BLINNET/ better link
22:24:54 <sjanssen> emu: last time I tried to solve it I used an ST version of Kruskal's
22:25:05 <emu> i'll take a poke at it next
22:25:44 <emu> i was actually doing the TDBFS before i left off earlier, which is kinda similar
22:25:58 <emu> DFS and BFS
22:26:13 <sjanssen> emu: I wrote a dummy submission that only parses the input -- took 2.19s (4s is the limit)
22:26:26 <emu> using bytestring?
22:26:39 <sjanssen> yeah, a hacked up state/parser monad
22:26:46 <sjanssen> they don't have MTL installed
22:27:25 <emu> do you need mtl just for basic Control.Monad ?
22:27:55 <sjanssen> not for Control.Monad
22:28:06 <sjanssen> but you do for most Control.Monad.*
22:28:19 <emu> yea hm. guy on the forum said they use debian packages, and were having some troubles
22:34:53 <emu> people did BLINNET in 0.0
22:34:56 <emu> o.O
22:35:14 <sjanssen> emu: probably cheaters
22:35:59 <sjanssen> IIRC you can do binary search on the correct answers by using non-zero exit codes
22:36:50 <emu> well the next tier up is 0.2, which is still pretty crazy
22:37:04 <sjanssen> yeah, my C++ solution is 3.45
22:37:07 <dons> sjanssen: btw, are you running with logging = True?
22:37:25 <sjanssen> it's a crappy version though
22:37:33 <dons> i want to get some people testing the workspace script, and the proposed pipe/mkfifi .xinitrc for a week or two
22:37:39 <dons> fifi?
22:37:43 <sjanssen> dons: no, I haven't tried it out yet
22:37:51 * shapr produces a poodle
22:38:01 <dons> sit, booboo, sit.
22:38:02 <emu> sounds painful
22:38:26 <sorear> Isn't fifi a topology? :)
22:38:38 <sorear> erm...
22:38:40 <dons> maybe its a black hole monad.
22:38:42 <sorear> tautology
22:39:46 <sjanssen> > fix ("fi"++)
22:39:48 <lambdabot>  "fififififififififififififififififififififififififififififififififififififif...
22:41:10 <sorear> @. . . read run if "topology" == "tautology" then "eval id" else "slap sorear"
22:41:11 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: ""
22:55:28 <KOC> I am making a function that takes a string, and I want to make it so that if the string begins with a certain value, it matches it
22:56:08 <KOC> Currently, I'm doing testf ('X' : 'X' : cs) = ... to see if the string begins with "XX"
22:56:39 <KOC> I wanted to do something like testf ("XX" : cs) = ... but that isn't right
22:56:51 <KOC> What's the best way to accomplish what i want?
22:56:56 <dmwit> ('X':'X':cs)
22:57:17 <KOC> That's the best way, dmwit ? (I actually typed that before you logged in)
22:57:40 <dmwit> For longer things,
22:57:59 <dmwit> s | take 6 s == "foobar"
22:58:19 <dmwit> What do you mean by "best"?
22:58:33 <dmwit> Speed, readability, size?
22:58:49 <KOC> readability, ease of typing
22:59:07 <dmwit> Yeah, I'd use a guard for maximum readability.
22:59:19 <KOC> awesome that's just what i wanted
22:59:55 <dons> f  y | "foo" `isPrefixOf` y == ...
22:59:58 <dons> f  y | "foo" `isPrefixOf` y = ...
23:00:17 <dmwit> ?src isPrefixOf
23:00:18 <lambdabot> isPrefixOf [] _          = True
23:00:18 <lambdabot> isPrefixOf _  []         = False
23:00:18 <lambdabot> isPrefixOf (x:xs) (y:ys) = x == y && isPrefixOf xs ys
23:00:37 <dmwit> neat
23:02:45 <KOC> What do I need to include to get isPrefixOf
23:03:13 <sorear> List
23:03:20 <KOC> thanks
23:32:47 <monstre> Is anyone familiar with Clean?
23:34:19 <dons> a little.
23:34:34 <dons> some other guys (earthy) are very familiar with it, though.
23:35:05 <monstre> I just stumbled across it
23:35:13 <monstre> seems very Haskell-like
23:35:17 <sorear> yeah
23:35:31 <sorear> it *was* one of the languages haskell was intended to replace
23:35:33 <monstre> faster too, according to the shootout
23:35:45 <sorear> the shootout prooves nothing
23:35:49 <dons> yeah, for some tasks. the native code generator of the clean compiler is pretty good.
23:35:53 <sorear> you can write FORTRAN in any language
23:36:09 <sorear> go ahead, try and read ANY of the shootout code
23:36:26 <monstre> well, the Haskell code is guilty of that too
23:36:32 <sorear> in the craze for #1, even the Haskell has been optimized beyond readability!
23:36:32 <dons> main problem with clean is social: missing libraries, tiny community
23:36:54 <sorear> and really, nobody cares how fast you can make unreadable code
23:37:12 <Jaggederest> lets not kid ourselves, haskell is a tiny community too.
23:37:46 <Shimei> Well, it has a larger IRC channel than most language communities.
23:37:54 <dons> #haskell is one of the biggest irc channels all up.
23:37:56 <Shimei> So it is easy to get help.
23:37:58 <dons> around 15th or so.
23:38:17 <monstre> so besides "uniqueness typing," what are the major differences between Clean and Haskell?
23:38:20 <sorear> monstre: Switching from Haskell to Clean because "it's faster on the shootout" is a good example of Knuth's "premature optimization"
23:38:29 <sorear> no type classes (iirc)
23:38:32 <dons> monstre: that's about it. haskell has far more extensions.
23:38:35 <sorear> observable sharing
23:38:36 <Jaggederest> true, but in terms of book buying, it's dwarfed by everything :)
23:38:37 <dons> clean has type classes.
23:38:38 <Shimei> Maybe it's just me, but seems like the Haskell community has a lot of organization that keeps efforts visible unlike some other language communities.
23:38:57 <dons> yep. its got a solid core of active language researchers, that keeps driving it along
23:39:25 <Jaggederest> yep, it's nice, I like it. But there's still tons of growth to be had before the community isn't tiny :)
23:39:26 <sorear> monstre: Before Haskell there were ~20 pure lazy fp languages vying for attention, and as a result none got any.
23:39:40 <dons> Jaggederest: how small do you think it is , though?
23:39:51 <Jaggederest> let me find the article
23:39:57 <sorear> monstre: then after haskell they all basically died.  clean is the brightest cinder by far but it's still a cinder
23:39:57 <Shimei> Well, I'd certainly like to see haskell get popular enough to be integrated into some more university curricula at least.
23:40:08 <Shimei> I don't look forward to taking tons of java courses...
23:40:29 <Adamant> there needs to be a Haskell equivalent to SICP
23:40:40 <dons> Jaggederest: i collect some statistics here, http://www.cse.unsw.edu.au/~dons/irc/
23:40:40 <lambdabot> Title: Haskell IRC Activity
23:40:47 <dons> includes mail list stats
23:41:20 <roconnor> As soon as haskell gets popular, I'm leaving it ...
23:41:24 <roconnor> for epigram
23:41:35 <Jaggederest> http://radar.oreilly.com/archives/2007/05/state_of_the_co_10.html
23:41:36 <lambdabot> Title: O'Reilly Radar > State of the Computer Book Market, Part Four - Programming Lang ...
23:41:36 <Excedrin> dons: what did you use to make the graphs? (specifically the 3rd one)
23:41:47 <dons> the mailing list graph?
23:41:53 <dons> is from gmane.
23:42:10 <dons> the others are from a gnuplot script i wrote, which analyses the irc logs
23:43:07 <Excedrin> I like the fill on the gmane graph
23:43:39 <Jaggederest> so the stats are, according to publisher data, this year so far they've sold ~400 haskell books.
23:44:23 <Jaggederest> compare to the top three, which sold 100x as many.
23:44:46 <dons> oh, the book situation is wildly different, yes.
23:44:53 <dons> we've only had 1 (beginner) book, published recently
23:44:59 <Jaggederest> 0.08% market share :)
23:45:01 <Shimei> Oh ouch, Ocaml is rated as an irrelevant programming language.
23:45:39 <dons> yeah, its hard to read anything about the community size from the sale of the beginner's book though.
23:45:44 <Jaggederest> only Practical Ocaml, and it's a pretty terrible rehash of Practical Common Lisp
23:45:47 <Shimei> Unfortunately, the ocaml book situation is worse than haskell's.
23:46:06 <Korollary> I've been  writing C++ for a living for 7 years. I've never owned a C++ book.
23:46:07 <Shimei> I sold my copy of Practical Ocaml. Wasn't too interesting.
23:46:10 <dons> right, there's going to be two advanced haskell books in the next year or so, so things should change a fair bit on that area, i suspect.
23:46:19 <Shimei> dons: I look forward to those.
23:46:35 <dons> me too :-)
23:46:47 <Jaggederest> +1 more books is good books
23:46:58 <Shimei> Seems like most beginners programming texts are mostly the same in any language. Advanced books are more interesting.
23:47:06 <dons> yeah.
23:47:18 <dons> well, haskell beginner books are a bit weird. they talk about proofs more than usual
23:47:29 <monstre> Which two books are you referring to?
23:47:31 <dons> and program derivation, but otherwise, the basic topics are the same.
23:47:46 <dons> monstre: 'Real-World Haskell' from O'Reilly, and 'Pragmatic Haskell'
23:47:55 <dons> ?google real world haskell
23:47:57 <lambdabot> http://www.realworldhaskell.org/
23:47:58 <lambdabot> Title: Real World Haskell
23:48:19 <dons> i must disclose a conflict of interest there. i'm one of the authors. ;)
23:48:40 <monstre> Actually, I had heard about that one, but "Pragmatic Haskell" is news to me
23:48:58 <Jaggederest> sweet. That'll def. flood the place :) So, are you doing a good job? imagine the ragging...
23:51:54 <monstre> "Real World Haskell" definitely looks like the book I've been looking for...
23:52:00 <Jaggederest> heeh, more reason to take that list with salt: C is bottom of the list...
23:53:44 <dons> yeah, the data is hard to interpret
23:54:27 <Jaggederest> I'm just amazed that some of those books are only selling 30 copies or less a month
23:59:17 <therp> how would you parse the output of "ghc-pkg describe base" (or any other package) into [(String, String)]
23:59:47 <sorear> read and case
