00:00:23 <sorear> hmm,
00:00:24 <therp> read? I'm not converting these strings
00:00:33 <therp> and what should I use case for?
00:00:44 <sorear> I'd use the package.conf files
00:00:48 <sorear> parse them with read
00:00:55 <therp> [("name","base"), ("version","2.0"), ("license", "BSD3")..)
00:01:27 <sorear> why!?
00:01:34 <sorear> that's a pretty useless format
00:01:48 <therp> it should be part of cabal, and cabal for some reason invokes ghc-pkg (to get the list of installed packages for instance)
00:02:22 <therp> sorear: it's usefull if you only need to operate on strings.
00:02:32 <therp> I don't need a full parse of the output.
00:02:52 <therp> I'm only interested in library-dirs
00:02:57 <therp> and hs-libraries.
00:04:24 <sorear> grep
00:08:17 <therp> not a single "DrawString" in xmonad..
00:10:07 <dons> therp: why would there be one?
00:10:41 <therp> dons: to display some status for some reason.. or debug info or ..
00:10:55 <therp> dons: I would like it to show a list of windows
00:11:22 <dons> right, that's what the new logging feature is for.
00:11:38 <therp> but it's not logging to the screen, right?
00:11:40 <dons> http://xmonad.org/contrib.html
00:11:41 <lambdabot> Title: xmonad : contributed code
00:11:53 <dons> no, it logs text to stdout, it just dumps the internal state.
00:12:02 <dons> you can then parse that, and display it with some other tool, like dzen
00:12:36 <dons> look at the section titled "Internal state logging"
00:13:00 <dons> i use this as follows, to display active workspaces:
00:13:01 <dons> xmonad-status < $PIPE | dzen2 -e '' -w 300 -ta l -fg $FG -bg $BG -fn $FONT &
00:13:01 <dons> # now go for it
00:13:01 <dons> xmonad > $PIPE &
00:13:09 <therp> wow there are a lot of extensions
00:13:12 <therp> I just read that
00:13:18 <dons> so xmonad writes into a pipe, xmonad-status parse the result, pretty prints it, and sends that to dzzen
00:13:25 <dons> yeah, there are lots. its cool .
00:15:04 <therp> I would like to experiment with focos management
00:15:08 <therp> er focus management
00:15:29 <dons> ok. come visit #xmonad -->
00:15:35 <therp> you surely no this inefficient way on windows to use alt-tab to cycle through the windows
00:35:24 <LeCamarade> ]/clear
00:35:33 <LeCamarade> :o)
00:36:16 <LeCamarade> Hey, the JavaScript 2.0 reference implementation is written in ML. Saw it at LtU.
00:37:48 <LeCamarade> We few, we happy few, we band of brothers; for he today that dies of monads with me shall be my brother -- William Shakespeare (c. 1599)
01:10:23 * roconnor tries to program with arrows
01:11:23 * LeCamarade tries not to program with arrows.
01:12:55 <roconnor> it feels like the first time I was doing monadic programming.
01:14:32 <roconnor> @type (&&&)
01:14:34 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
01:14:51 <roconnor> @type (***)
01:14:53 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
01:16:28 <dmwit> I can never keep those two separate.
01:16:43 <dolio> If you're going to write code that really uses arrows, I think arrow notation is recommended as The Way To Go.
01:17:08 <dolio> Trying to link everything up with &&& *** first second... is an exercise in frustration if you're doing something complicated.
01:18:22 <Heffalump> the desugaring of arrow notation relies on keeping track of what'll be used later
01:19:12 <xic> which haskell compilers have built-in support for arrow notation?
01:19:26 <DRMacIver> Morning
01:19:40 <Heffalump> GHC, but there's a standard preprocessor you can use for any compiler
01:19:54 <Heffalump> not sure about hugs, it might have built-in support given Ross Paterson maintains it
01:20:32 <xic> can template haskell be used to extend haskell with arrow notation?
01:20:59 <Heffalump> I don't think the raw notation would parse or type-check
01:21:08 <Heffalump> but only GHC has template haskell anyway
01:21:30 <xic> i'm just curious about the power of template haskell
01:22:42 * roconnor tries to stick an IO action inside my hxt thingy
01:23:31 <Heffalump> oh, TH appears to allow non-type correct things
01:23:51 <Heffalump> but I still think you'd have trouble getting it to parse arrow notation the way you want
01:27:29 <quicksilver> TH happens before the type check
01:27:32 <lispy> TH is supposed to be type sound, iirc
01:27:35 <quicksilver> but, I think, after the lex
01:27:46 <quicksilver> so you couldn't do the special syntax for <-
01:27:55 <quicksilver> since that would already have been parsed
01:27:58 <quicksilver> (I think)
01:28:27 <quicksilver> lispy: TH is supposed to produce type-sound code
01:28:33 <quicksilver> lispy: but it does run before the type-checker
01:28:47 <quicksilver> lispy: so you can do things like IO actions to generate your type-sound code and stuff
01:28:56 <lispy> yes you can
01:29:04 <quicksilver> it has its own type-discipline of course
01:29:04 <lispy> i've used unsafePerformIO in TH code
01:29:08 <quicksilver> 'meta-types'
01:29:16 <quicksilver> lispy: you don't need unsafe, there is a TH runIO too
01:29:27 <lispy> oh, i didn't realize that
01:29:45 <kfish> http://blog.kfish.org/2007/06/review-tagsoup.html
01:29:46 <lambdabot> Title: blog.kfish.org: Review: TagSoup
01:29:54 <lispy> in my case i ran the Language.Haskell compiler in the unsafePerformIO, and i figured since the file didn't change during compilation i was set :)
01:30:10 <lispy> er not compiler but parser
01:53:46 <dons> oh, i like kfish's idea of doing library reviews.
01:54:03 <dons> @tell kfish maybe you should get your stuff onto planet.haskell.org. more reviews would be great!
01:54:04 <lambdabot> Consider it noted.
01:55:06 <xic> where is kfish's website?
01:55:19 <dons> http://programming.reddit.com/info/1x4nn/comments
01:55:20 <lambdabot> Title: Haskell Library Review: TagSoup (Parsing malformed HTML/XML) (reddit.com)
02:05:14 <xic> anyone know how to get haddock to obfusicate email addresses?
02:06:22 <dons> hmm. sed
02:06:33 <dons> there's no way built  in to haddock, but it has been discussed (for hackage).
02:06:46 <dons> i think the idea was: if you write a library, and publish it, you'll be found anyway :-)
02:07:11 <DRMacIver> Email obfuscation is overrated anyway.
02:11:10 <xic> i mean for defense against spam bots that crawl html pages
02:12:11 <Saizan> uhm tagsoup would just need a search funtion that let's you see what's before the match.. i almost had a need for it :)
02:20:04 <DRMacIver> xic: I know what you mean. But spam will happen anyway, so the better solution is to deal with spam on arrival rather than go to extremes to prevent getting it in the first place. :)
02:31:19 <Saizan> uoah, catch is released
02:50:09 <Syzygy-> How would I list all permutations of a specific list?
02:52:12 <DRMacIver> @t foldr intersperse []
02:52:12 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
02:52:15 <DRMacIver> @type foldr intersperse []
02:52:18 <lambdabot> forall a. [a] -> [a]
02:52:29 <DRMacIver> Hm, that's not right.
02:52:50 <DRMacIver> Need more coffee.
02:54:41 <augustss> Syzygy: Haskell doesn't come with a permutation funcyion.  It should, even if it's just two lines
02:55:03 <Jaggederest> yeah I was asking that the other day. blank stares :)
02:59:52 <Jaggederest> http://www.algoblog.com/2007/06/04/permutation/
02:59:52 <lambdabot> Title: Algo Blog » Random Permutation
02:59:52 <Jaggederest> http://paste.lisp.org/display/25032
02:59:52 <Jaggederest> http://haskell.org/hawiki/HaskellNewbie_2fWorkingWithRandomNumbers
02:59:52 <lambdabot> Title: HaskellNewbie/WorkingWithRandomNumbers - The Haskell Wiki, http://tinyurl.com/2agyyk
02:59:52 <Jaggederest> that's about all I've seen. just about as easy to roll your own
02:59:52 <ari> Does anybody know of a good page about why it's good to have a REPL (no need for it to be about Haskell)? I looked at Wikipedia and C2 and neither had an article that would really cut it...
02:59:52 <augustss> But that gives you a random permutation, not all of them.
03:00:06 <Jaggederest> right but you'd build it into a generator for a list and do a uniq on them, or the like
03:00:34 <ari> Syzygy-: There's one at http://haskell.org/hawiki/LicensedPreludeExts
03:00:35 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
03:00:42 <augustss> But generating all isn't hard
03:01:17 <ari> Syzygy-: Also I wrote one by accident when playing with an unfoldM some time ago, I'll put it on hpaste if I can find it
03:01:18 <Jaggederest> ah ari nailed it
03:02:30 <Jaggederest> thanks, that's going to help me a ton too. Glad I stayed up late again
03:04:40 <yaxu> i'm getting dependency problems with the ghc packaged with ubuntu feisty, am i better off recompiling ghc from sources?
03:04:55 <yaxu> currently trying to tackle "cannot satisfy dependency binary-any"
03:04:58 <astrolabe> I can see two obvious strategies: 1) for each element of the list, prepend it to each permuation of the remainder, 2) insert the head of the list into each location of each permutation of the tail.  I can't tell which would be better.
03:05:50 <opqdonut> 1) is simpler to code imo
03:06:13 <opqdonut> tho 2) might be pretty using the list monad or something
03:06:50 <astrolabe> I'd need to code them to make my mind up.
03:07:16 <Igloo> yaxu: Compiling from source won't help - you need to install the binary package
03:07:28 <astrolabe> They seem dual to each other somehow.  I wonder if you could extract the commonalitiy between them.
03:07:37 <DRMacIver> @pl \f x y -> x >>= f y
03:07:37 <lambdabot> flip ((.) . (>>=))
03:07:39 <dmhouse> Hey all. Could someone just quickly run the whole lazy-vs-nonstrict thing past me quickly?
03:08:15 <yaxu> Igloo: i can't seem to find such a thing
03:08:16 <astrolabe> I think nonstrict is about semantics, while lazy is about how it is implemented.
03:08:24 <astrolabe> (I stand to be corrected)
03:08:45 <astrolabe> oh, semantics means lots of things in CS.  Sorry.
03:08:47 <Igloo> yaxu: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary-0.3
03:08:50 <lambdabot> http://tinyurl.com/25ptqt
03:09:03 <astrolabe> Lazy means you can refer to infinite lists
03:09:03 <yaxu> Igloo: ah, thanks very much!
03:09:14 <astrolabe> er wrong way wound
03:09:17 <dmhouse> Yeah. :)
03:09:19 * astrolabe shuts up
03:09:42 <dmhouse> Okay, so nonstrict semantics means that 'nothing gets evaluated until needed', and lazy evaluation is all about using thunks to model this?
03:10:05 <filcab42> hi
03:10:06 <astrolabe> dmhouse: sounds good.
03:10:16 <filcab42> what's the easiest way to read a matrix, in haskell?
03:10:31 <hpaste>  ari pasted "permutations with unfoldM, probably inefficient, but fun" at http://hpaste.org/226
03:10:43 <dmhouse> filcab42: 'read'? As in parse from a String?
03:10:44 <filcab42> I'm thinking a recursive function that reads a line and then passes it to another function which reads each element
03:10:47 <filcab42> yes
03:11:05 <hpaste>  filcab pasted "matrix" at http://hpaste.org/227
03:11:07 <filcab42> like this
03:11:14 <dmhouse> Right.
03:11:16 <filcab42> (they're always squared
03:11:19 <dmhouse> ?hoogle words
03:11:23 <lambdabot> Prelude.words :: String -> [String]
03:11:23 <lambdabot> Data.PackedString.wordsPS :: PackedString -> [PackedString]
03:11:23 <lambdabot> Prelude.unwords :: [String] -> String
03:11:26 <dmhouse> ?hoogle lines
03:11:26 <lambdabot> Prelude.lines :: String -> [String]
03:11:27 <lambdabot> Data.PackedString.linesPS :: PackedString -> [PackedString]
03:11:27 <lambdabot> Text.Html.linesToHtml :: [String] -> Html
03:11:32 <dmhouse> Those two will help :)
03:11:38 <filcab42> hmm... words and lines
03:11:43 <filcab42> didn't know them
03:11:47 <filcab42> (just a newbie ;))
03:11:49 <filcab42> thanks
03:11:52 <dmhouse> No problem.
03:12:10 <filcab42> can I "slurp" stdin?
03:12:14 <filcab42> or only "normal" files?
03:12:25 <ari> @type interact
03:12:27 <lambdabot> (String -> String) -> IO ()
03:13:01 <filcab42> nice
03:13:04 <filcab42> interact id :D
03:14:54 <filcab42> wait
03:15:05 <filcab42> but... interact doesn't return anything
03:15:32 <filcab42> oh. I should write a function that takes the input, solves the problem, and returns the output as a string, right?
03:16:12 <dmhouse> Depends what you want to do with the matrix once it's parsed.
03:16:14 <filcab42> btw, how can I insert a line-break in a haskell string?
03:16:19 <filcab42> \n doesn't seem to cut it
03:16:33 <ari> filcab42: Indeed. interact only allows you to work with stdin and stdout of course, if you need to work with other I/O you'll need to use the IO monad.
03:16:50 <dmhouse> \n will do it.
03:16:50 <Saizan> ?type getContents
03:16:52 <lambdabot> IO String
03:17:10 <dmhouse> Prelude> putStr "hello\nworld"
03:17:10 <dmhouse> hello
03:17:10 <dmhouse> world
03:17:33 <dmhouse> show "hello\nworld" -- This won't work, because show escapes characters like \n.
03:17:35 <filcab42> I see why I thought otherwise
03:17:50 <dmhouse> > show "hello\nworld"
03:17:51 <lambdabot>  "\"hello\\nworld\""
03:17:55 <filcab42> I used this like a lisp interpreter (which calls 'print when it prints objects)
03:18:00 <filcab42> and I did this:
03:18:00 <filcab42> Array> "o\nla"
03:18:00 <filcab42> "o\nla"
03:18:12 <dmhouse> Ah. print x = putStrLn (show x). Use putStrLn.
03:18:21 <filcab42> I was hoping to have the line break there
03:18:26 <filcab42> yes
03:18:45 <dmhouse> Everything you type into GHCi gets shown (show'd?).
03:19:08 <dmhouse> Unless it's something of type IO a, in which case it gets executed.
03:19:57 <dmhouse> But yeah, your best strategy is probably to read stdin using getContents, parse it, and do what you want with your matrix.
03:20:12 <ivanm> is there any way of getting hgl working with x11-1.2.2?
03:20:18 <filcab42> yap
03:20:20 <filcab42> thanks
03:20:30 <ivanm> the current version of ghl doesn't seem to work with it :(
03:20:33 <filcab42> are there two-dimensional arrays, in haskell?
03:20:40 <filcab42> or must I do an array of arrays?
03:20:45 <filcab42> (or a long array
03:20:50 <ivanm> filcab42: same way you use 1D arrays, but with a 2D index
03:21:09 <ivanm> so you're key would be (1,2), rather than just 1
03:21:18 <filcab42> like: arr ! (1, 2)
03:21:18 <filcab42> ?
03:21:23 <ivanm> yeah
03:21:43 <filcab42> and how do I create them? it seemed to me the bounds were start and finish
03:22:11 <dmhouse> It'd be easier (albeit less efficient) to use a list of lists to hold your matrix.
03:22:22 <dmhouse> In Haskell, the staple aggregate type is lists, not arrays.
03:22:24 <filcab42> Array> listArray ((2,2),(2,2)) [1,2,3,4]
03:22:24 <filcab42> array ((2,2),(2,2)) [((2,2),1)]
03:22:41 <filcab42> but lists are a bit inefficient
03:22:52 <filcab42> hmm, but for my problem it shouldn't matter much
03:22:59 <filcab42> I'll try with lists, then
03:23:00 <filcab42> thanks
03:23:07 <dmhouse> Exactly :) "Premature optimisation is the root of all evil."
03:23:16 <filcab42> that Knuth... :P
03:23:22 <ivanm> filcab42: what are you using arrays for?
03:23:31 <dmhouse> Dunno where it's from, but it's true. :)
03:23:32 <filcab42> the matrix
03:23:47 <ivanm> as in, what matrix problem are you working on?
03:24:02 * ivanm just joined in to this conversation
03:24:31 <filcab42> kind of like a TSP
03:24:56 <filcab42> but with 2 salesmen
03:25:06 <filcab42> all cities must be visited
03:25:13 <filcab42> shortet distance
03:25:24 <filcab42> and the cities should be visited in ascending order
03:25:26 <ivanm> so you're creating an incidence matrix form for a graph>
03:25:27 <ivanm> ?
03:25:32 <filcab42> I already solved it in C
03:25:55 <filcab42> incidence matrix? (I'm not a native english speaker, sorry)
03:26:14 <filcab42> first I must read the matrix with the costs
03:26:47 <ivanm> *nod*
03:26:58 <ivanm> http://en.wikipedia.org/wiki/Incidence_matrix
03:26:59 <lambdabot> Title: Incidence matrix - Wikipedia, the free encyclopedia
03:27:03 <ivanm> that looks like what you're doing
03:27:26 <ivanm> so, the element at (i,j) is the distance between cities i and j?
03:27:33 <ivanm> and the matrix should be symmetric?
03:27:36 <filcab42> yes
03:27:37 <ivanm> with 0s on the diagonal?
03:27:43 <filcab42> yap
03:28:09 <ivanm> well, having a matrix being a list of lists would probably work:
03:28:28 <dmhouse> dist matrix i j = matrix !! i !! j
03:28:36 <ivanm> yeah
03:28:56 <filcab42> that's if I use arrays
03:28:58 <ivanm> and to read it, just read it in as [[Int]]
03:29:03 <filcab42> but I'll try with lists first
03:29:04 <ivanm> no, thats a list form
03:29:16 <ivanm> arrays use '!', lists use '!!'
03:29:18 <filcab42> ?
03:29:20 <filcab42> oh
03:29:21 <filcab42> nice
03:29:28 <ivanm> > [[1,2],[3,4]] !! 1 !! 2
03:29:29 <lambdabot>  Exception: Prelude.(!!): index too large
03:29:43 <ivanm> grr, stupid 0 first counting /me is used to matlab
03:29:44 <dmhouse> > [[1,2],[3,4]] !! 0 !! 1 -- zero indexed
03:29:45 <lambdabot>  2
03:29:45 <ivanm> > [[1,2],[3,4]] !! 1 !! 0
03:29:46 <lambdabot>  3
03:29:59 <ivanm> matlab has ruined me :s
03:30:11 <ivanm> then again, I keep trying to do maps in matlab ;-)
03:31:17 <filcab42> m <- getContents
03:31:17 <filcab42>     map words . lines m
03:31:21 <filcab42> shouldn't this work?
03:31:28 <filcab42> or should there be parenthesis?
03:31:39 <dmhouse> You can't use (.) like that.
03:31:47 <ivanm> map words $ lines m
03:32:00 <ivanm> not that... map (words . lines) ,
03:32:06 <ivanm> I think that's what you want
03:32:15 <dmhouse> ivanm: no, it's not.
03:32:17 <filcab42> I was aiming for: (map words) . lines m
03:32:25 <dmhouse> You need to lines it first, then words on each line.
03:32:27 <ivanm> oh...
03:32:33 <ivanm> whoops, yeah
03:32:36 <filcab42> but yes, with $ I wouldn't need the parenthesis
03:32:38 <dmhouse> (.) can only be used to create functions by joining two other functions together. 'lines m' isn't a function. So you could have written (map words . lines) m, or more normally map words (lines m).
03:32:43 * ivanm hasn't done much string manipulation stuff
03:32:54 <Japsu> map words $ lines m
03:32:54 <dmhouse> filcab42: the second problem is that map words (lines m) isn't a monadic value.
03:33:16 <filcab42> yes, I should return it
03:33:17 <filcab42> right?
03:33:21 <dmhouse> filcab42: so that you can't just include it in a do-block like that.
03:33:24 <dmhouse> I'd do something like this:
03:33:26 <dmhouse> m <- getContents
03:33:32 <dmhouse> let matrix = readMatrix m
03:33:46 <dmhouse> someIOInvolvingMatrix
03:34:19 <dmhouse> (Where readMatrix is your map words . lines function, and someIOInvolvingMatrix might be printing it out, or something.)
03:34:22 <filcab42> hmm
03:34:22 <dmhouse> Or perhaps:
03:34:26 <dmhouse> m <- getContents
03:34:31 <dmhouse> let matrix = readMatrix m
03:34:36 <dmhouse> let soln = solveTSP matrix
03:34:38 <dmhouse> print soln
03:35:13 <ivanm> dmhouse: surely you could use the same let block, as long as the second line was indented?
03:35:18 <dmhouse> ivanm: yeah.
03:35:36 <dmhouse> So the pure bits of your program, readMatrix and solveTSP, are separated from the IO bits. That's good Haskell style.
03:36:27 <filcab42> thanks
03:36:33 <dmhouse> (Also if you had readMatrix = map words . lines, then it would return [[String]]. You'd need to apply 'read' to each of the strings to get [[Int]] or [[Double]] or whatever it is you want.)
03:36:56 <dmhouse> So readMatrix = map (map read . words) . lines
03:37:24 <dmhouse> ?type map (map read . words) . lines
03:37:33 <lambdabot> forall a. (Read a) => String -> [[a]]
03:37:59 <ivanm> presumably, you'd want to turn that [[String]] into something that can be read to [[Int]]
03:38:25 <ivanm> oh, wait, dmhouse just did that
03:38:34 <dmhouse> :) I was a little confused just then...
03:38:49 <ivanm> grrr... /me finds it annoying when someone else answers something whilst I'm still typing it
03:40:43 <DRMacIver> Hm
03:40:51 <filcab42> ERROR "/Users/filcab/ist/asa/Mini-Projectos/projecto3/proj3.hs":10 - Unresolved top-level overloading
03:40:52 <filcab42> *** Binding             : main
03:40:52 <filcab42> *** Outstanding context : (Read b, Read d, Read c, Show b)
03:40:53 <filcab42> whaaat?
03:41:20 <ivanm> filcab42: you have to specify what its reading to
03:41:28 <Saizan> you need to fix the type of your matrix to [[Int]] or something like that
03:41:30 <DRMacIver> filcab42: It apparently likes your context so much that it thinks it's outstanding. :)
03:41:44 <DRMacIver> </lame>
03:41:44 <ivanm> heh, good one DRMacIver
03:41:49 <hpaste>  filcab pasted "main" at http://hpaste.org/228
03:41:57 <filcab42> lol
03:42:04 <dmhouse> filcab42: just stick a type signature on readMatrix.
03:42:10 <dmhouse> readMatrix :: String -> [[Int]]
03:42:22 <DRMacIver> Hm. I can't remember how to do pattern matching in a lambda. I have a function I want to feed into @pl. :)
03:42:27 <dmhouse> (And by the way, putStrLn $ show matrix = print matrix.)
03:42:40 <dmhouse> DRMacIver: the same way as normal, just make sure to use lots of parentheses.
03:42:44 <filcab42> hmm
03:42:55 <dmhouse> ?pl \(Just x) -> x
03:42:55 <lambdabot> (line 1, column 8):
03:42:55 <lambdabot> unexpected "x"
03:42:55 <lambdabot> expecting operator or ")"
03:42:56 <filcab42> now I have an unresolved top-level overloading :s
03:43:12 <dmhouse> filcab42: paste the entire module.
03:43:27 <dmhouse> ?pl \ (Just x) -> x
03:43:27 <lambdabot> (line 1, column 9):
03:43:27 <lambdabot> unexpected "x"
03:43:27 <lambdabot> expecting operator or ")"
03:43:35 <hpaste>  filcab annotated "main" with "main" at http://hpaste.org/228#a1
03:43:43 <dmhouse> Prelude> :t \(Just x) -> x
03:43:44 <dmhouse> \(Just x) -> x :: Maybe t -> t
03:43:46 <dmhouse> Silly lambdabot.
03:44:22 <dmhouse> filcab42: and what error do you get? Paste that too.
03:44:36 <filcab42> sorry
03:44:50 <hpaste>  filcab annotated "main" with "error" at http://hpaste.org/228#a2
03:45:04 <Saizan> filcab42: you have the same problem with k and n
03:45:14 <Saizan> filcab42: add a type annotation tehre
03:45:21 <DRMacIver> Actually, this is going to be horrific...
03:45:22 <DRMacIver> @pl let insertions x y = case y of { [] -> [[x]]; (y : ys) -> (x : y : ys ) : (map (y:) (insertions x ys)); } in insertions
03:45:22 <lambdabot> (line 1, column 32):
03:45:23 <lambdabot> unexpected "{"
03:45:23 <lambdabot> expecting variable, "(", operator, ";" or "in"
03:45:23 <filcab42> with the variables?
03:45:56 <dmhouse> filcab42: otherwise it won't know what type to make k and n. You can probably lose the annotations in the future, when you're actually doing something with k and n that will specify their type.
03:45:56 <Saizan> filcab42: yup, k = read kStr :: Int for example
03:46:27 <DRMacIver> (I realised I couldn't do the function as a lambda anyway)
03:46:43 <dmhouse> DRMacIver: well, you can do anything as a lambda ;)
03:47:06 <DRMacIver> Without a fix or equivalent I mean
03:47:18 <filcab42> thanks
03:47:23 <ivanm> dmhouse: even trash your system? and do imperative code? :p
03:47:27 <DRMacIver> The function definition as currently written uses explicit recursion, and I don't want to manually convert it so that it doesn't. :)
03:47:36 <filcab42> well... got to go
03:47:40 <filcab42> I'll annoy you later ;)
03:47:54 <dmhouse> ivanm: (\_ -> system "rm -rf /") () -- seems okay to me.
03:47:58 <dmhouse> filcab42: enjoy Haskell. :)
03:48:03 <ivanm> dmhouse: heh
03:48:06 <chaoslawful_> ?pl take 100 [1..]
03:48:06 <lambdabot> take 100 [1..]
03:48:19 <ivanm> dmhouse: whats the final () at the end for?
03:48:19 <filcab42> dmhouse: I'm trying ;)
03:48:21 <DRMacIver> ?pf take 100 [1..]
03:48:22 <lambdabot> Maybe you meant: bf pl
03:48:23 <filcab42> bye
03:48:26 <dmhouse> ivanm: to actually make it evaluate.
03:48:29 <DRMacIver> ?unpl take 100 [1..]
03:48:30 <lambdabot> take 100 [1 ..]
03:48:31 <ivanm> *nod*
03:48:35 <DRMacIver> Boring. :)
03:48:36 <Saizan> ?pl \i j -> take i [j..]
03:48:36 <lambdabot> (. enumFrom) . take
03:48:41 <ivanm> @type (\_ -> system "rm -rf /") ()
03:48:41 <dmhouse> ?pl \f n -> f n [1..]
03:48:50 <lambdabot> Not in scope: `system'
03:48:50 <lambdabot> flip flip [1..]
03:49:46 <dmhouse> Prelude System.Cmd> :t (\_ -> system "rm -rf /") ()
03:49:46 <dmhouse> (\_ -> system "rm -rf /") () :: IO GHC.IOBase.ExitCode
03:51:18 <ivanm> *nod*
03:51:53 <ivanm> but isn't that kinda cheating? you're just offloading the function up to the OS rather than doing it in haskell...
03:52:35 <dmhouse> But at some level everything is offloading to the OS. I'm sure there's a deleteFile somewhere, but how does it work? It makes a kernel call, I imagine.
03:52:44 <chaoslawful_> @pl \x->x
03:52:44 <lambdabot> id
03:53:13 <chaoslawful_> @pl \x->map words (lines x)
03:53:13 <lambdabot> map words . lines
03:53:52 <ivanm> dmhouse: heh, fair enough
03:54:46 * Saizan imagine a lambda OS where real I/O is church encoded
03:55:50 <ivanm> heh
03:58:13 <MyCatVerbs> Saizan: aieeeeee! No, dammit.
03:58:31 <MyCatVerbs> Saizan: for the love of Pete, throughput! :/
03:58:51 <MyCatVerbs> Saizan: do something easier, like a lambda machine where all funcalls are thunked or something :)
04:05:49 <chaoslawful_> @unpl any.(=)
04:05:49 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}: Parse error
04:06:01 <chaoslawful_> @unpl any.(==)
04:06:01 <lambdabot> (\ c -> any ((==) c))
04:06:02 <ivanm> heh
04:06:21 <chaoslawful_> @unpl any.flip.(==)
04:06:21 <lambdabot> (\ f -> any (\ b c -> f == c b))
04:06:21 <ivanm> @unpl any (==)
04:06:21 <lambdabot> any (==)
04:06:53 <chaoslawful_> @unpl any.flip (==)
04:06:53 <lambdabot> (\ f -> any (\ c -> c == f))
04:21:22 <jf_> :source scanl
04:21:35 <jf_> @source scanl
04:21:35 <lambdabot> scanl not available
04:22:29 <jf_> @source inits
04:22:29 <lambdabot> inits not available
04:23:44 <Saizan> @src scanl
04:23:45 <lambdabot> scanl f q ls = q : case ls of
04:23:45 <lambdabot>     []   -> []
04:23:45 <lambdabot>     x:xs -> scanl f (f q x) xs
04:23:49 <Saizan> @src inits
04:23:49 <lambdabot> inits []     =  [[]]
04:23:50 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
04:24:21 <jf_> saizan: thanks
04:24:51 <Saizan>  @source is to get a link for the source of a module
04:24:57 <Saizan> @source Data.List
04:24:57 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
04:25:55 <araujo> morning
04:26:23 <LeCamarade> araujo: That word, `morning' must be your favourite.
04:29:34 <araujo> LeCamarade, it is .. at this hour of the day :-)
04:30:23 <hpaste>  yaxu pasted "A more elegant version?" at http://hpaste.org/229
04:31:12 <LeCamarade> araujo: Not ¡Hola! ? :o)
04:32:30 <araujo> LeCamarade, i am careful with that word ... someone told me it means something nasty in a lost european town :-P
04:33:15 <MyCatVerbs> araujo: so it's harmless then.
04:33:35 <MyCatVerbs> At least, until someone actually finds that place, there's not really much point in worrying about it.
04:34:12 <ivanm> heh
04:35:48 <araujo> MyCatVerbs, hah, i guess
04:39:08 <yaxu> was just wondering if there's a more beautiful way of doing http://hpaste.org/229
04:39:11 <yaxu> well i'm sure there is
04:39:45 <dmhouse> yaxu: why do you need the Eq context?
04:40:04 <yaxu> well it's for pairing up a list of unique elements
04:40:34 <dmhouse> I think what you've written is equivalent to [(x, y) | x <- xs, y <- xs].
04:40:35 <yaxu> so just making that explicit really, although true it doesn't need it
04:40:44 <dmhouse> Oh, not quite.
04:41:10 <yaxu> ah, list comprehensions, of course
04:41:16 <yaxu> forgot about those :/
04:41:24 <dmhouse> Well they're not quite the same.
04:42:06 <yaxu> ah, permutations rather than combinations
04:42:13 <dmhouse> If you wrote down xs twice, one along the top of a square, one along the side, then mine finds all pairs in that square, yours only finds one half of those (one triangle).
04:43:23 <dmhouse> I.e. mine applied to [1,2, 3] would be (1, 1) (1, 2), (1, 3) (2, 1), (2, 2), (2, 3), (3, 1), (3, 2), (3, 3). Yours would be (1, 1), (1, 2), (1, 3), (2, 2), (2, 3), (3, 3) I think
04:43:31 <yaxu> yes
04:45:09 <dmhouse> > [ (x, y) | x <- [1..3], y <- [x..3]]
04:45:11 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
04:45:44 <augustss> > [(x,y) | x:xs <- tails [1,2,3], y <- xs]
04:45:45 <lambdabot>  [(1,2),(1,3),(2,3)]
04:45:57 <Syzygy-> ?hoogle (\\)
04:45:57 <lambdabot> Did you mean: (\\)
04:45:58 <lambdabot> Prelude.undefined :: a
04:45:58 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:46:00 <dmhouse> > (\m -> [ (x, y) | x <- [1..m], y <- [x..m]]) 3
04:46:01 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
04:46:02 <Syzygy-> ?hoogle (//)
04:46:02 <lambdabot> Did you mean: (//)
04:46:03 <lambdabot> Prelude.undefined :: a
04:46:03 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
04:46:11 <Syzygy-> Hmmmm.
04:46:18 <Syzygy-> What's the bloody thing that lets you remove stuff from a list?
04:46:20 <augustss> > [(x,y) | x:xs <- tails [1,2,3], y <- x:xs]
04:46:22 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
04:46:25 <Syzygy-> The setminus thingie?
04:46:38 <dmhouse> > [1, 2, 3] \\ [1]
04:46:39 <lambdabot>  [2,3]
04:46:47 <Syzygy-> ?index (\\)
04:46:47 <lambdabot> bzzt
04:46:53 <Syzygy-> Is it in prelude?
04:46:56 <dmhouse> ?index (\\\\)
04:46:56 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
04:47:02 <Syzygy-> Ahhhhh
04:47:09 <dmhouse> Someone didn't escape their backslashes :)
04:47:47 <Syzygy-> Hrm.
04:47:50 <Syzygy-> Why doesn't this work?
04:47:52 <Syzygy-> let permuteList l = map (\x -> (x:permuteList (l \\ x))) l
04:48:04 <Syzygy-> Oh wait...
04:48:09 <Syzygy-> Of course it doesn't. *hrm*
04:48:58 <augustss> Syzygy: using \\ isn't good, it will require equality on the elements.  that's not necessary to generate permutations
04:49:02 <yaxu> my allPairs works on a list of unordered things, which I guess is why I want combinations and not permutations
04:49:17 <Syzygy-> augustss: OTOH, all I need is for it to work with [Int].
04:49:28 <dmhouse> > (\xs -> [(x, y) | (x, ix) <- zip xs [0..], y <- drop ix xs]) [1..3]
04:49:29 <lambdabot>  [(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
04:49:34 <dmwit> Syzygy-: Do you just need a permutations function, or are you trying to write it just to see if you can?
04:49:38 <dmhouse> augustss's is better but that was the one I was trying to think of.
04:49:49 <dmwit> http://www.haskell.org/hawiki/LicensedPreludeExts
04:49:50 <lambdabot> Title: LicensedPreludeExts - The Haskell Wiki
04:50:03 <augustss> That's a nice one
04:50:03 <dmhouse> > (\xs -> [(x, y) | (x, ix) <- zip xs [0..], y <- drop ix xs]) [3,1,2] -- it doesn't matter if the list is ordered or not.
04:50:04 <lambdabot>  [(3,3),(3,1),(3,2),(1,1),(1,2),(2,2)]
04:50:32 <yaxu> > (\xs -> [(x, y) | (x, ix) <- zip xs [0..], y <- drop ix xs]) (nub "hello world")
04:50:33 <lambdabot>  [('h','h'),('h','e'),('h','l'),('h','o'),('h',' '),('h','w'),('h','r'),('h',...
04:50:35 <augustss> dmhouse: what's wrong with my version with tails?
04:50:46 <dmhouse> augustss: <dmhouse> augustss's is better but that was the one I was trying to think of.
04:50:57 <augustss> ah
04:51:34 <yaxu> > [(x,y) | x:xs <- tails (nub "hello world"), y <- xs]
04:51:35 <lambdabot>  [('h','e'),('h','l'),('h','o'),('h',' '),('h','w'),('h','r'),('h','d'),('e',...
04:51:47 <yaxu> > [(x,y) | x:xs <- tails (nub "hello"), y <- xs]
04:51:49 <lambdabot>  [('h','e'),('h','l'),('h','o'),('e','l'),('e','o'),('l','o')]
04:51:55 <yaxu> yes excellent
04:52:27 <yaxu> now i just need to understand how that works :)
04:52:44 <dmhouse> yaxu: okay, picture the square image that I used before.
04:53:10 <yaxu> no i get it, very nice
04:54:25 <dmhouse> Yeah. tails [1,2,3] -> [], [3], [2, 3], [1, 2, 3], i.e. each of the rows in the triangle, then you pair each of the y values with that.
04:54:33 <yaxu> i can visualise the algorithm in terms of pipes connecting together in strange ways
04:55:03 <yaxu> dmhouse: ah, interesting
04:57:08 <yaxu> i was thinking of it in terms of lazy lists being matched together
04:57:32 <yaxu> of course the triangle is implicit in that as well
04:57:38 <yaxu> anyway, thanks all
04:59:39 <chaoslawful_> hmmm...will this style take up more memory than non-comprehension approach?
05:00:13 <yaxu> well mine was using ++ a lot, which I think is not efficient
05:01:34 <yaxu> seems to work lazily fine with [1 .. 10000000] as input, so
05:02:04 <chaoslawful_> oh, i see...
05:07:45 <chaoslawful_> ?help
05:07:45 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:07:51 <chaoslawful_> ?list
05:07:51 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
05:23:08 <ndm> it appears that absolutely noone uses everywhere' :(
05:23:19 <ndm> from Data.Generics - the SYB thing
05:23:34 <Baughn> :t everywhere
05:23:36 <lambdabot> Not in scope: `everywhere'
05:23:57 <ndm> :t Data.Generics.everywhere'
05:23:59 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
05:24:14 * ari ponders
05:24:18 <ari> :t Data.Generics.everywhere'
05:24:19 <LeCamarade> ndm: I keep away from stuff I don't need. :o)
05:24:20 <lambdabot> forall a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> a1) -> a -> a
05:24:21 <ndm> Baughn, note the use of ' at the end - people use everywhere, just not everywhere'
05:24:34 <ari> Hmm, that be strange
05:24:37 <ari> :t id
05:24:39 <lambdabot> forall a. a -> a
05:24:46 <Baughn> ndm: Neither exists anywhere in my documentation, though. Odd?
05:24:57 * ari shrugs - I'd thought for a while that lambdabot hated me but apparently she doesn't
05:24:59 <ndm> LeCamarade, i suspect everyone that uses everywhere' has got it wrong in corner cases - unfortunately its impossible to say since no one uses it
05:25:00 <Baughn> Or just new?
05:25:24 <ndm> Baughn, old - and available everywhere - where were you looking?
05:25:40 <ndm> @docs everywhere
05:25:40 <lambdabot> everywhere not available
05:25:47 <ndm> @docs Data.Generics.Schemes
05:25:47 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics-Schemes.html
05:25:50 <Baughn> file:///users/svein/doc/haskell/ghc/libraries/base/Data-Generics-Basics.html , which is the 6.6.0 documentation
05:26:13 <ndm> Baughn, look in Schemes, which is were it lives - although its re-exported by Data.Generics
05:26:19 <Baughn> Oh, it's in schemes. Odd reply from lambdabot..
05:26:49 <Baughn> ..that's the class. Never mind. I must be going blind. ;)
05:30:33 <igli> @botsnack
05:30:33 <lambdabot> :)
05:31:35 * igli waits to watch lovely code fly by :)
05:33:22 <Baughn> @src fix
05:33:22 <lambdabot> fix f = let x = f x in x
05:34:07 <Baughn> ^^<-- lovely code
05:35:17 <augustss> It can be a bit perplexing at first sight :)
05:35:35 <Baughn> It's a simple case of laziness. ;)
05:35:51 <augustss> and recursion
05:36:01 <igli> hehe
05:36:02 <Baughn> And recursion, yes.
05:36:22 <igli> i love this channel :)
05:37:40 <augustss> > take 10 $ fix (1:)
05:37:48 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
05:40:05 <igli> what is $ ?
05:40:11 <Baughn> $src ($)
05:40:14 <Baughn> @src ($)
05:40:14 <lambdabot> f $ x = f x
05:40:29 <igli> hmm ok
05:40:38 <augustss> > take 10 (fix (1:))
05:40:39 <lambdabot>  [1,1,1,1,1,1,1,1,1,1]
05:40:52 <Baughn> igli: For starters, imagine replacing every $ with a (
05:41:06 <augustss> It's a way to do function application that often saves parenthesis
05:41:18 <Baughn> > map ($ 2) [(1+), (*2), (/ 4)]
05:41:19 <lambdabot>  [3.0,4.0,0.5]
05:41:20 <igli> ah ok thank you both :)
05:41:54 <igli> wow
05:41:59 <igli> that's concise
05:42:15 <Baughn> It's a way to section function application. Sometimes it's useful to have that a function that just does that.
05:42:15 <igli> @src map
05:42:15 <lambdabot> map _ []     = []
05:42:16 <lambdabot> map f (x:xs) = f x : map f xs
05:42:23 <augustss> It's interesting that Haskell is one of the few languages that have all these predefined "useless" functions like id, const, $, ...
05:42:43 <Baughn> map..
05:42:56 <igli> yeah nice :)
05:42:58 <Baughn> foldr, foldl, foldl'. >_<
05:43:09 <igli> heh i read about those
05:43:12 <Baughn> Reasoning about the memory usage of those is annoying
05:43:19 <ndm> otherwise is another useless function
05:43:21 <vegai> it's interesting how you think they're not useless
05:43:24 * vegai flees :)
05:43:25 <igli> it all seems like ways to apply funcs
05:43:31 <ndm> in Haskell things like $ are more like syntax, than functions
05:43:33 <igli> hehe
05:43:43 <igli> yes
05:43:47 <Baughn> ndm: Yes, but I just used it as a function in that map. ;)
05:44:15 <Baughn> Very neat. Now, why isn't this working?:
05:44:25 <Baughn> @hoogle Boolean -> a -> a -> a
05:44:26 <lambdabot> No matches, try a more general search
05:44:38 <Baughn> @djinn Boolean -> a -> a -> a
05:44:38 <ndm> Baughn, yes, but thats the rare case,  probably
05:44:38 <lambdabot> f _ _ a = a
05:44:52 <augustss> Bool
05:44:53 <ndm> @hoogle Bool -> a -> a -> a
05:44:54 <lambdabot> No matches, try a more general search
05:44:59 <Baughn> ndm: When you need it, it's there
05:45:04 <ndm> @hoogle Ord a => Bool -> a -> a -> a
05:45:05 <lambdabot> No matches, try a more general search
05:45:10 <Baughn> ndm: No, no ord
05:45:11 <augustss>  @djinn Bool -> a -> a -> a
05:45:20 <ndm> oh, cond
05:45:21 <Baughn> :t \p a b -> if p then a else b
05:45:23 <lambdabot> forall t. Bool -> t -> t -> t
05:45:27 <augustss> @djinn Bool -> a -> a -> a
05:45:27 <lambdabot> f a b c =
05:45:27 <lambdabot>     case a of
05:45:27 <lambdabot>     False -> c
05:45:27 <lambdabot>     True -> b
05:45:29 <ndm> no, thats suspiciously missing from Haskell
05:45:38 <LoganCapaldo> it's a conspiracy!
05:45:51 <igli> what's missing?
05:46:37 <norpan> muxes
05:46:41 <Baughn> > let iff = \p a b -> if p then a else b in map (iff (== 3) 2) [1,2,3,4]
05:46:42 <lambdabot>      The section `(== 3)' takes one argument,
05:46:42 <lambdabot>     but its type `Bool' has none
05:46:54 <LoganCapaldo> > let fromBool True = const; fromBool False = flip const ; a = 2; b = 3 in fromBool (a < b) (b - a) (a - b)
05:46:55 <lambdabot>  1
05:47:47 <augustss> I guess it should be called bool
05:47:51 <LoganCapaldo> actually I mean
05:47:56 <augustss> like maybe and aither
05:47:58 <augustss> either
05:47:59 <Baughn> @pl \a b -> iff (a == 3) 2 b
05:47:59 <lambdabot> flip iff 2 . (3 ==)
05:48:07 <LoganCapaldo> > let fromBool True = asTypeOf; fromBool False = flip asTypeOf; a = 2; b = 3 in fromBool (a < b) (b - a) (a - b)
05:48:09 <lambdabot>  1
05:48:16 <Baughn> ..figures. Sometimes @pl is useful, but this is not one of those days.
05:48:39 <igli> norpan: what's a mux? do you mean mutex?
05:48:51 <augustss> multiplexor
05:48:54 <LoganCapaldo> igli: multiplexor
05:48:59 <igli> ah ok
05:49:02 <Baughn> igli: Multiplexers. If, switch/case, cond..
05:49:05 <Lemmih> mux: What's a mux?
05:49:10 <Baughn> :t cond
05:49:12 <lambdabot> Not in scope: `cond'
05:49:22 <igli> ok branching ?
05:49:54 <gattocarlo> hi! I have a question on hs-plugins:
05:49:55 <gattocarlo> eval "id 4 :: Int" [] should be working, right?
05:50:22 <gattocarlo> I'm sking because I'm getting a Nthing back...
05:50:34 <ndm> gattocarlo, which version of GHC?
05:50:38 <Baughn> cond :: [(a -> Bool, a -> b)] -> a -> b, I guess...
05:50:39 <gattocarlo> 6.6.1
05:50:48 <Baughn> That looks more useful in CL than in haskell.
05:50:53 <gattocarlo> plugins-1.0 from hackage
05:51:17 <ndm> gattocarlo, i'm not sure HsPlugins works with that, - it was last working on 6.4, and the 6.6 port was not finished
05:51:32 <LoganCapaldo> Baughn: I'd think I'd  want cond :: [(a -> Maybe b, b -> c)] -> a -> c
05:51:55 <gattocarlo> thanks ndm!
05:52:02 <ndm> no, you definately want cond :: Bool -> a -> a -> a
05:52:10 <ndm> since that covers the most common case by a mile
05:52:14 <ndm> i also often want:
05:52:33 <ndm> rep match new x = if x == match then new else x
05:52:39 <LoganCapaldo> ndm: naw, I want type Bool a = a -> a -> a :)
05:53:18 <ndm> LoganCapaldo, i've written entire compilers using church encoding - they are decidedly unpleasant
05:53:19 <Botje> @pl \t f -> t
05:53:20 <lambdabot> const
05:53:21 <Botje> @pl \t f -> f
05:53:21 <lambdabot> const id
05:53:30 <LoganCapaldo> ndm: not everything, just bools
05:53:32 <Botje> cute
05:53:37 <igli> i want type World = love -> peace -> harmony ;p
05:53:54 * igli hides
05:54:04 <ndm> LoganCapaldo, ah, weak :) - its only fun once you've got lists as church encoding
05:55:10 <LoganCapaldo> ndm: heh. I actually did that in ruby (Maybe and Either too). At first I tried to do it in Haskell, but I couldn't figure out how to make the type system like it
05:55:33 <ndm> LoganCapaldo, rank-2 types are required
05:56:36 <ndm> or an untyped intermediate language, which is what i used
05:58:09 <augustss> There's nothing wrong with church encoding that a little syntactic sugar can't fix
05:58:33 <ndm> debugging transformations in a church encoded program is not fun
05:58:57 <ndm> since generally you shouldn't use sugar at the low-level implementation
05:59:05 <augustss> ummmm, that's true.  you'd better get it right the first time :)
05:59:31 <ndm> impressively, for the Haskell on an FPGA project, we did...
06:00:21 <LoganCapaldo> I was pround of myself when I figured out how to test for zeroness with church numbers
06:00:44 <LoganCapaldo> \n -> n (true false) true
06:01:07 <augustss> the Reduceron looks fun
06:01:11 <LoganCapaldo> Iwas all like "hooray!"
06:01:13 <ndm> yep, it is
06:01:19 <ndm> took about 1 week from start to finish
06:01:41 <ndm> not entirely practical, since its still lacking a garbage collector
06:02:11 <augustss> yeah, doing SKI in HW shouldn't be too bad when you have a decent HW description language
06:02:26 <ndm> its using Lava, which made it quite easy
06:02:34 <augustss> yes
06:02:41 <ndm> sadly there is no research in it, most of it comes straight out of SPJ's book
06:02:44 <pejo> augustss, heh, so you're saying that we should write correct code at once, to avoid spending time debugging?
06:02:46 <augustss> does it have an interface to external memory?
06:02:54 <ndm> it does
06:02:57 <gaal> ooh, 100 pi users on the channel
06:03:12 <augustss> pejo: yep, that's the plan :)
06:03:26 <ndm> i think there are 4Mb or something on the development boards, but the real time systems group have ones with 1Gb of ram
06:03:37 <pejo> augustss, there are so many in here who aren't Simon or Lennart!
06:04:09 <gaal> say, I just installed a binary ghc 6.7 snapshot in-place, but it's not finding modules. is there a known-good linux bindist?
06:04:34 <augustss> ndm: is the memory interface good?  interms of bw, I mean
06:04:35 <gaal> ghc-pkg --user list  =>  {ghc-6.7.20070529}, rts-1.0
06:04:57 <Igloo> gaal: bindists don't work in the HEAD currently
06:05:04 <ndm> augustss, standard PC dimm's - so as good as on a normal computer
06:05:26 <gaal> Igloo: oh :( what's the last known date that worked?
06:05:38 <Igloo> No idea
06:05:53 <gaal> I have 20070301 but that doesn't feature :back in the ghci debugger, which I currently need :(
06:07:16 <gaal> okay, plan B: anyone got a tip for finding which Parsec rule raised an error? I have a big parser (pugs) that does use <?> in most rules, but apparently misses some
06:07:24 <augustss> ndm: well, it's very, very difficult to drive external DRAM fast from an FPGA.  Are you using some ready made memory controller from the FPGA vendor?
06:08:21 <ndm> augustss, i think so - York has a standard development board which does all this stuff for us
06:08:57 <augustss> ah, ok
06:09:04 <ndm> matt knows more of the low-level FPGA details, i helped more with the Church encoding/lambda lifting/transformation stuff
06:09:35 * roconnor wonders if there is a rewrite rule for (reverse . sort)
06:09:53 <gaal> I'm thinking some sort of instrumentation trick to prepend "(<?> nameOfCurrentFunction) $ " to function bodies that don't provide a message
06:09:56 <gaal> hmm maybe TH
06:10:23 <augustss> I remember Niklas Rojemo's woes when he wrote the DRAM controller in Bluespec.  It those ps clock and data skews that kills you.
06:11:31 <Igloo> roconnor: The obvious rule would be wrong due to stability
06:12:11 <ndm> roconnor, any rewrite rule probably makes assumptions about Ord
06:13:24 <ndm> we are relying mainly on the premade software for the reduceron, we download a premade CPU into the fpga, then more simulate the SKI stuff on it, rather than putting them direct in hardware
06:13:40 <ndm> but the instruction set is slightly customised for the SKI things
06:14:00 <ndm> the next step is to move more logic into the FPGA
06:27:08 <roconnor> Does HXT work on (non XML) HTML documents?
06:27:14 <roconnor> maybe I should just use tagsoup
06:29:24 <roconnor> @where tagsoup
06:29:24 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
06:30:20 <filcab42> how can I create an NaN?
06:30:28 <dmhouse> > 1/0
06:30:29 <lambdabot>  Infinity
06:30:33 <dmhouse> Err
06:30:34 <dmhouse> > 0/0
06:30:35 <lambdabot>  NaN
06:30:36 <filcab42> I want to do something recursive and I want to know the minimum
06:30:45 <filcab42> hmm
06:30:49 <dmhouse> filcab42: minimum of what?
06:31:01 <filcab42> can I have an integer that's larger than any other?
06:31:18 <roconnor> > isNaN (0/)
06:31:19 <lambdabot>   add an instance declaration for (RealFloat (t -> t))
06:31:19 <lambdabot>     In the expression:...
06:31:24 <dmhouse> > 1/0 > 56
06:31:24 <roconnor> > isNaN (0/0)
06:31:25 <lambdabot>  True
06:31:26 <lambdabot>  True
06:31:53 <filcab42> I have: f(x,y) = min(cost(x,i)+f(i,y); cost(y,i)+f(x,i))
06:31:58 <filcab42> where i = max(x,y)+1
06:32:05 <filcab42> hmm
06:32:13 <filcab42> I'll try passing infinity
06:32:31 <dmhouse> filcab42: is that Haskell?
06:32:36 <filcab42> no
06:32:39 <filcab42> pseudo-code
06:32:44 <dmhouse> Right, makes sense.
06:33:33 <ndm> roconnor, what are you hoping to do?
06:36:09 <roconnor> ah, there is an HTML parser in HXT
06:36:28 <roconnor> ndm: I'm writing an atom feed generator for my blog.
06:36:46 <roconnor> tagsoup is a bit inappropriate because I made valid HTML myself :)
06:37:51 <dons> roconnor: hmm, have you seen lambdaFeed?
06:37:53 <ndm> roconnor, hsx is good for what you want
06:38:35 <ndm> yes, i definately wouldn't use tagsoup to generate valid HTML, its unlikely to go well - atlhough i am writing a tagsoup based validator
06:39:41 <roconnor> well, I'm trying to read HTML.  I want to scrape out the content for the feed
06:39:43 <filcab42> hmmm
06:39:44 <ndm> dons, i notice that xmonad is starting to outstrip haskell-cafe in number of emails - impressive
06:39:51 <roconnor> I'm generating Atom XML with HXT.
06:39:56 <Igloo> Woah
06:40:07 <filcab42> in "yet another haskell tutorial" they said the type Int also had a value _|_ (bottom)
06:40:28 <filcab42> will min x _|_ be x for any x != _|_?
06:40:39 <Igloo> No, it will be _|_
06:40:49 <ndm> filcab42, no, in general if you give in _|_ you are likely to get _|_ out
06:40:50 <filcab42> admn
06:40:52 <filcab42> *damn
06:41:15 <ndm> filcab42, you should aim to never introduce _|_ into your program
06:41:22 <filcab42> that's what happens with NaNs... except in min/max
06:41:49 <dons> ndm, yeah, its been busy.
06:42:03 <filcab42> ndm: but then I can't have something with type int that tries to get a minimum
06:42:03 <dons> write apps, people, write apps! :-)
06:42:11 <augustss> filcab42: why don't you introduce your own type with the properties you like?
06:42:16 <ndm> filcab42, NaN /= _|_
06:42:26 <LeCamarade> dons: Busied by Haskellers, ornon-Haskellers? It would be nice if it were the latter group.
06:42:32 <ndm> dons, i have, i even released one :)
06:42:38 <filcab42> yes, I just thought they could have some properties that are equal
06:42:47 <ndm> although i think writing libraries is a nicer thing for the community
06:42:52 <LeCamarade> ndm: By the way, congratulations on Catch. You rock.
06:43:05 <filcab42> well... changing to just calculate the base case and sending it as a base for recursion
06:43:10 <dons> LeCamarade: the first 30 or so where haskellers, the next 40 or so on the list i don't think are haskell people.
06:43:38 <ndm> dons, matt is now using it exclusively, and really likes it
06:43:44 <dons> cool.
06:43:55 <ndm> so whats the next Haskell killer app?
06:44:16 <ndm> i think something on Windows with Gtk2Hs might do quite well
06:44:16 <LeCamarade> ndm: That's my secret. :o)
06:44:26 <dons> someone said something about a acroread killer.
06:44:41 <filcab42> is there a way to tell Haskell to memoize functions?
06:44:42 <ndm> LeCamarade, thanks about Catch :) - make sure  you announce whatever you come up with :)
06:45:09 <ndm> dons, that would be ambitious, and acrobat is very reliable as it is - i don't see the advantage of Haskell'ing it
06:45:32 <filcab42> I have an extremely recursive function. And I wanted ghc to memoize it so it would perform... a lot faster
06:45:50 <LeCamarade> Plus Acrobat stuff is already exhausted. Think what Rails did for Ruby.
06:47:04 <ndm> Rails is for programmers
06:47:08 <LeCamarade> The Haskell killer app should be for programmers, rather than a good tool for non-programmers.
06:47:25 <ndm> should it be for Haskell programmers?
06:47:36 <LeCamarade> I mean, I don't know what language was used in MS Office ... (tongue-in-cheek)
06:47:41 <ndm> C
06:47:51 <Japsu> C++ afaik
06:47:59 <filcab42> C, maybe a bit of C++ and asm
06:48:01 <igli> no way is that C yeah
06:48:03 <filcab42> (or C++, maybe a bit of C and asm
06:48:07 <LeCamarade> ndm: No, for programmers in general. Half of #haskell learnt about Haskell via Pugs.
06:48:09 <igli> do me favour
06:48:11 <ndm> Japsu, C++ later, C# after that, but mainly C
06:48:13 <igli> a^
06:48:20 <igli> seriously?
06:48:31 <ndm> hmm, we could port Hoogle to search Java libraries
06:48:40 <Japsu> lol
06:48:41 <ndm> thats in the road-map for Hoogle 6 anyway
06:48:47 <Japsu> that'd be cool
06:48:54 <Japsu> though Eclipse already does much of that
06:48:58 <LeCamarade> Anyway, whatever the MS Office language, its ubiquity didn't reveal the language (or give it extra credibility).
06:49:01 <ndm> by Type?
06:49:04 <Japsu> not in the extent Hoogle does
06:49:24 <Japsu> but I can type "DMTN" in Eclipse and hit Ctrl+Space and it completes it to DefaultMutableTreeNode
06:49:56 <ndm> Hoogle 6 is intended to do any OO or procedural language, so we could have a big online search for every language/library pair
06:50:03 <Japsu> cool
06:50:08 <ndm> Japsu, oh, thats very cool - i may have to add that for Hoogle
06:50:43 <Japsu> ndm: actually that's really useful when you're writing code - in Java the class and method names tend to get a little long
06:50:48 <LeCamarade> If I write a Java code generator, for example, in Haskell, that can easily become The Killer App.
06:50:49 <ndm> not sure if there are enough multi-word haskell names though...
06:50:54 <Japsu> yeah
06:50:59 <LeCamarade> Hoogle is going to rock.
06:51:03 <ndm> LeCamarade, generates what code?
06:51:08 <Japsu> but the Java coding style discourages abbreviations
06:51:14 <LeCamarade> @quote java
06:51:14 <lambdabot> Igloo says: [dons: anyone know what happened to [the] Haskell wishlist?]  Igloo: Did it have "Crush Java" listed?
06:51:18 <Japsu> so foldr would be foldRight in java :)
06:51:29 <LeCamarade> @quote static
06:51:29 <lambdabot> dons says: you start with lisp, get to statically typed lisp (ML), add laziness, add whitespace to solve the parens stuff, add syntax sugar (for human programmability), and finally, add purity (i.e.
06:51:29 <lambdabot> true functional programming), and you've got haskell
06:51:31 * SamB_XP wonders how you would search for an appropriate class
06:52:00 <Japsu> SamB_XP: hmm, one search criteria I could figure would be "extends TreeNode"
06:52:11 <LeCamarade> @quote public.static.void
06:52:11 <lambdabot> No quotes match. My pet ferret can type better than you!
06:52:16 <LeCamarade> :o(
06:52:16 <Japsu> (s/TreeNode/AbstractTreeNode/)
06:52:22 <Japsu> SamB_XP: or "implements TreeNode"
06:52:24 <ndm> i wanted things like from File -> Stream
06:52:27 <Saizan> i'd like more hoogle integration in editors, but this probably involve partially typechecking the piece of code you are working on
06:52:38 <SamB_XP> hmm.
06:52:39 <yakov> hi all
06:52:41 <Japsu> hmm
06:52:42 <ndm> in C# its possible, but is about 3 hops away
06:52:59 <Japsu> "implements Stream, has constructor (File)"?
06:53:04 <ndm> some of those hops are methods, some are base-classes, its all very confusing
06:53:11 * SamB_XP wonders if "uses TreeNode" would be doable?
06:53:22 <Japsu> SamB_XP: what would the "uses" criteria match?
06:53:35 <Japsu> inheritance? any reference?
06:53:57 <sorear> hi.
06:53:58 <Japsu> hmm
06:53:59 <Japsu> food
06:54:01 <SamB_XP> I suppose it ought to match both inheritance and ordinary references...
06:54:23 <sorear> ndm: congratulations on finishing basic Catch!!!
06:54:40 <ndm> sorear, thanks! it took long enough
06:57:20 <augustss> ndm: I'd really love to use catch, but I'm afraid I've used MPTC:(
06:57:48 <ndm> augustss, wait til GHC.Core comes out, then you can Catch any GHC code
06:58:19 <ndm> augustss, or until the end of the summer, when a summer of code student should have added MPTC to Yhc
06:58:25 <SamB_XP> ndm: what code does GHC.Core use?
06:58:52 <augustss> That will be excellent.  Does Catch cope well with larger programs (like a few hundred modules)?
06:58:53 <ndm> SamB_XP, its mainly vapourware, GHC can spit out Core, but there is no library to parse it available yet
06:59:18 <ndm> a few 100 modules is probably out of the range of Catch, at the moment
06:59:22 <SamB_XP> you can't use GHC-API to parse external core?
06:59:35 <sorear> SamB_XP: GHC can't parse external core
06:59:46 <SamB_XP> sorear: what the heck?
06:59:48 <sorear> SamB_XP: the feature has been broken ever since 6.0
06:59:53 <SamB_XP> oh.
07:00:03 <sorear> SamB_XP: Aaron Tomb is fixing it ATM, though
07:00:17 <ndm> augustss, there is nothing much stopping it doing things that size, but in practice as the volume of code increases, the chances of bumping into a rough edge do as well
07:00:17 <SamB_XP> well, even generation was broken last time I tried to use it, actually ;-)
07:00:39 <SamB_XP> ndm: rough edge?
07:01:06 <ndm> SamB_XP, firstly your code must go through Yhc, which is unlikely for a 100 mdule program
07:01:12 <SamB_XP> true
07:01:31 <ndm> SamB_XP, secondly, Catch uses an old version of the firstifier, there is a new one in Supero but I haven't backported it yet
07:01:45 <KOC> I remember I once read a tutorial that was geared towards a less theoretical crowd and started off by showing "main" in programs. I can't seem to find it now. Does anyone happen to know what this was? (It wasn't the "tutorial for C programmers")
07:02:04 <SamB_XP> ndm: oh, order-reduction?
07:02:19 <sorear> ndm: a couple random observations I've made on catch:
07:02:20 <ndm> thirdly, there are API's and stuff which i haven't written abstract versions but which are too low level, things like getChar etc. have to have "checkable" versions written
07:02:33 <ndm> SamB_XP, yes, making Haskell entirely first-order
07:02:57 <SamB_XP> firstifier is kind cryptic sounding ;-)
07:03:00 <sorear> ndm: 1. catch is a type system (at the first order), it seems to work by assigning types to top level functions
07:03:06 <SamB_XP> insert an "of"
07:03:15 <ndm> SamB_XP, although the version of Catch i released does actually allow higher-order stuff floating around, but i've not yet pinned down exactly what it likes etc.
07:03:45 <SamB_XP> ndm: ask its mother
07:03:46 <augustss> ndm: ok, I'll just have to wait a while then
07:03:48 <sorear> ndm: 2. catch can be used as a type system - just fuse all datatypes without extending cases
07:04:50 <ndm> augustss, hopefully not too long - i definately want a polished version before Christmas
07:05:07 <ndm> if GHC.Core isn't out by the end of the summer, i'm writing my own version...
07:05:08 <sorear> ndm: 3. catch can be "inverted"; define error x = error x; program; main = realMain `seq` realError
07:05:41 <SamB_XP> sorear: hmm?
07:05:42 <ndm> sorear, then used as a termination checker? that was the original intention
07:05:44 <sorear> ndm: I presume none of those are novel to you?
07:05:59 <ndm> yeah, i've been aware of them
07:06:06 <ndm> the type thing works for preconditions
07:06:21 <sorear> ndm: Inverted as in it becomes a optimistic case checker.
07:06:24 <fasta> Where do I get a login for GHC Trac?
07:06:37 <ndm> but not for properties/contracts, since every function has a massive number of "types" in parallel
07:06:46 <sorear> fasta: get a login normally, then ask Igloo to activate it
07:06:54 <sorear> fasta: spammers :(
07:06:55 <ndm> sorear, what do you mean by optimisitic case checker?
07:06:58 <fasta> sorear: ok
07:07:21 <ndm> i'm reading types and programming languages at the moment to try and pin down the Catch vs types thing
07:07:31 <sorear> ndm: Catch is pessimistic.  It always fails if your program is bad, but might fail if your program is good.
07:07:56 <jf_> @src inits
07:07:56 <lambdabot> inits []     =  [[]]
07:07:57 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
07:08:01 <sorear> ndm: Inverted catch is optimistic.  It always succeeds if your program is good, but might succeed if your program is bad.
07:08:06 <SamB_XP> so if you invert it, does ti always fail if your program is good, and maybe fail if your program is bad?
07:08:21 <fasta>  Trac detected an internal error:
07:08:21 <fasta> [Errno 13] Permission denied: '/srv/trac/ghc/trac.htpasswd'
07:08:23 <SamB_XP> oh rats
07:08:24 <SamB_XP> too slow
07:08:27 <fasta> sorear: it doesn't appear to work.
07:08:42 <jf_> @src scanl
07:08:42 <lambdabot> scanl f q ls = q : case ls of
07:08:42 <lambdabot>     []   -> []
07:08:42 <lambdabot>     x:xs -> scanl f (f q x) xs
07:08:57 <ndm> sorear, ah, thats neat - i think there is some overlap with a terminatino checker in there as well
07:09:16 <sorear> fasta: Oh.  I guess just ask Igloo to make the account wholly.
07:09:25 <fasta> @seen Igloo
07:09:26 <lambdabot> Igloo is in #haskell-overflow, #haskell, #ghc and #darcs. I last heard Igloo speak 28m 47s ago.
07:10:50 <ndm> sorear, although the inverted one doesn't respect laziness, so may get it wrong
07:11:31 <Igloo> fasta: Just use the guest account for now
07:12:03 <fasta> Igloo: You are moving first to another Trac version?
07:12:07 <sorear> ndm: would thunking everything clog the firstifier?
07:12:25 <ndm> sorear, probably - yes
07:12:29 <sorear> oh.
07:12:31 <Igloo> fasta: Yeah, although I don't know when
07:12:44 <ndm> certainly the current version, it may be ok with the one from Supero
07:12:49 * SamB_XP wants to see the access logs for /robots.txt
07:16:40 <fasta> data Foo = Foo{a::Int, b::Int} deriving Show
07:16:41 <fasta> foo = Foo {a=1}
07:16:41 <fasta> main = putStrLn (foo{b=2})
07:16:47 <fasta> Do we want foo to generate a warning?
07:16:58 <fasta> (b is undefined in foo)
07:17:40 <fasta> Note, that foo is never used with fields that are undefined.
07:17:49 <sorear> -fwarn-missing-field ?
07:17:53 <sorear> *fields
07:18:33 <filcab42> hi
07:18:40 <fasta> sorear: ?
07:18:41 <filcab42> how can I tell ghc to memoize a function
07:18:43 <filcab42> ?
07:18:55 <fasta> sorear: I don't think I explicitly enabled that
07:19:30 <Saizan> filcab42: you have to do it explicitly, you're probably better using dynamic programming style if you can, though
07:19:36 <fasta> sorear: -fno-warn-missing-fields would "solve" it the brute way.
07:19:48 <fasta> sorear: sometimes it's nice to get the warning.
07:19:49 <filcab42> what do you mean by "dynamic programming style"?
07:20:01 <filcab42> I'm solving a problem with dynamic programming, yes
07:20:08 <filcab42> But I never did it in haskell
07:20:12 <ndm> fasta, Catch will pick that up
07:20:14 <fasta> filcab42: GHC is not an auto DP'er
07:20:54 <filcab42> ?
07:20:56 <fasta> ndm: does Catch integrate in a sane way?
07:21:11 <ndm> fasta, its a standalone tool
07:21:36 <LoganCapaldo> you know haskell is the one PL I would expect to have automagic memoization, but because the implementators think long and hard abou the consequences of such things, it doesn't :)
07:21:43 <Saizan> filcab42: uhm, like starting from the base cases instead of recursing when writing fib
07:21:52 <fasta> ndm: Meaning, that when I do e.g. C-c C-l in Emacs, I want it to run.
07:22:14 <ndm> fasta, no reason you can't do that, its as simple as "catch Main.hs"
07:22:35 <ndm> LoganCapaldo, it does, they are called CAF's
07:22:36 <fasta> ndm: also if it takes 1 second to execute it's already too slow :)
07:23:09 <ndm> fasta, if you want automatic proofs in under a second, you probably want to wait  until we hit 1THz processors...
07:23:17 <LoganCapaldo> ndm: I mean like the scenario of automatically turning naive fib into a memoized version.
07:23:56 <fasta> ndm: ok, so, it wouldn't be in the standard C-c C-l, but another key binding would be nice.
07:24:06 <filcab42> s
07:24:10 <filcab42> ups, sorry
07:24:19 <ndm> fasta, its aimed at checking a program before release, but its fast enough to do before every commit/push, but not fast enough to do every character you type
07:24:32 <LeCamarade> ^]!catch Main.hs
07:24:36 <SamB_XP> Igloo: hey, could you try changing the robots.txt to say:
07:24:47 <SamB_XP> User-agent: *
07:24:47 <SamB_XP> Disallow: /haskellwiki/?
07:25:28 <SamB_XP> (that question mark is part of the text that would go in robots.txt)
07:26:06 <ndm> SamB_XP, doesn't that still mean we loose google on the wiki?
07:26:12 <SamB_XP> ndm: no
07:26:28 <sorear> why can't we just use /w/ and /wiki/ !?!?!?
07:26:30 <SamB_XP> because none of the normal wiki pages have question marks there
07:27:10 <daniel_larsson> The wiki uses GETS to change pages?
07:27:26 <SamB_XP> daniel_larsson: what?
07:27:51 <SamB_XP> we had a robot that was slurping diffs
07:27:57 <daniel_larsson> Ahh, right
07:28:21 <Igloo> SamB_XP: Done
07:28:34 <SamB_XP> Igloo: cool
07:29:04 <sorear> Igloo: How about /w/ and /wiki/?  it works for wikipedia
07:29:41 <Igloo> sorear: You want me to change the URLs? Or add alternatives?
07:31:22 <sorear> change the urls...  it's not an immediate request, just a good idea that was on the ML and afaict forgotten
07:31:38 <Igloo> That would break every external link for little gain
07:32:08 <SamB_XP> Igloo: I think it would only break external links to special things...
07:32:56 <sorear> that's what 304 is for
07:33:04 <Igloo> SamB_XP: So we're not talking about the "haskellwiki/" in the URLs?
07:33:14 <Igloo> That's a proposal for the wiki maintainer, anyway
07:33:38 <SamB_XP> well, I think haskellwiki would work as well as wiki ;-)
07:35:16 <SamB_XP> anyway, if it turns out that the bad bot doesn't understand this robots.txt, you could look at blocking its IP range with mod_access
07:38:08 <filcab42> does ghc support:
07:38:12 <filcab42> let n = 42
07:38:28 <filcab42>    score (n-1) = 3
07:38:33 <filcab42> in score 41
07:38:36 <filcab42> => 3
07:38:38 <filcab42> ?
07:39:00 <Igloo> no
07:39:06 <filcab42> thanks
07:39:10 <filcab42> I'll use a guard, then
07:40:24 <SamB_XP> we;v
07:40:38 <SamB_XP> we've been trying to get rid of n+k patterns for years
07:40:45 <SamB_XP> why would we have n-k patterns?
07:41:01 <SamB_XP> oh, wait
07:41:04 <SamB_XP> that isn't even that...
07:44:56 <ndm> but we're still not ditching n+k from Haskell'...
07:45:32 <Igloo> Well, no final decision have been made, have they?
07:47:01 <ndm> not yet, i don't think
07:47:09 <ndm> but i don't think it was even being considered
07:47:43 <sorear> Are there any plans to move the h' due date?
07:48:05 <ndm> what, from last October?
07:48:09 <Igloo> Haskell' doesn't have a due date, in any meaningful sense of the phrase, AFAIAA
07:48:22 <sorear> oh.  I misunderstood
07:48:31 <ndm> the original intention was Haskell Workshop 2006 would have a proposed new standard
07:54:12 <roconnor> @where lambdafeed
07:54:12 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/lambdaFeed/
07:55:20 <sorear> What is a minimal lhs2TeX setup?
07:55:42 <sorear> Just: %include "lhs2TeX.fmt" :gives ill-formed TeX
07:56:24 <LeCamarade> I have never used n+k, because I'm told not to. But why were they included, and where is the utility that was originally envisioned?
07:57:01 <ndm> sorear, you still need \begin{document} etc.
07:59:14 <sorear> ndm: Uhm ... what values should I use?
07:59:26 * sorear is not very skilled with LaTeX headers
07:59:57 <LoganCapaldo> > let odd n = n `mod` 2 /= 0; even n+1 = odd n in (even 0, even 2, odd 3, even 3)
07:59:57 <lambdabot>  Parse error in pattern
08:00:11 <LoganCapaldo> > let odd n = n `mod` 2 /= 0; even (n+1) = odd n in (even 0, even 2, odd 3, even 3)
08:00:12 <lambdabot>  Parse error in pattern
08:00:21 <LoganCapaldo> see, I can't even write them they are so horrible :)
08:01:14 <ndm> sorear, \documentclass{article}\begin{document}hello sorear\end{document}
08:01:33 <ndm> sorear with the lhs2tex stuff coming before \begin{document}
08:03:19 <kosmikus> sorear: I'd recommend \documentclass{article}\n%include polycode.fmt\n\begin{document}...\end{document}
08:03:35 <sorear> ndm++
08:03:50 <sorear> kosmikus: hmm, I thought that was the default now?
08:04:00 <kosmikus> default?
08:04:54 <ndm> kosmikus, he means doesn't lhs2tex give you polycode automatically
08:04:56 <sorear> 'poly' style is automatically selected
08:04:58 <kosmikus> polycode.fmt is better than lhs2TeX.fmt; I'm not going to change the behaviour of lhs2TeX.fmt to maintain backwards-compatibility
08:05:08 <sorear> aha.
08:05:13 <kosmikus> yes, poly style is automatically selected.
08:05:43 <kosmikus> polycode.fmt still has some better default settings though
08:05:51 <ndm> @karma- monomorphism-restriction
08:05:52 <lambdabot> monomorphism-restriction's karma lowered to -1.
08:06:09 <kosmikus> better vertical spacing, easier to extend/modify
08:06:20 <sorear> i see.
08:10:07 <sorear> @ask dons #dreamlinux-es has 0 humans.  Can we remove lb's autojoin?
08:10:08 <lambdabot> Consider it noted.
08:15:38 <bauchus> I'm to stupid for haskell :-((
08:15:50 <roconnor> hmm, I think my blog is just about working
08:16:54 <ari> bauchus: ?
08:17:57 <bauchus> what does this cause: "No instance for (MonadCGI [])"
08:18:35 <sorear> bauchus: Mental confusion, and a message "I'm to stupid for haskell :-(("
08:19:23 <daniel_larsson> You're trying to use a list where it expects an instance of MonadCGI?
08:19:50 <bauchus> I'm trying to do IO in a CGI monad
08:20:25 <sorear> bauchus: you probably forgot a return somewhere
08:21:32 <bauchus> no
08:21:40 <Heffalump> or a lift, but that's less likely from that error message
08:22:04 <bauchus> an example: addUserPage = do
08:22:04 <bauchus>   liftIO $ putStrLn "hello"
08:22:04 <bauchus>   return $ stringToHtml "test"
08:22:41 <bauchus> hm, here is the message: " No instance for (MonadIO [])"
08:23:04 <Heffalump> did you specify a type signature for addUserPage?
08:23:52 <bauchus> no, i'll try
08:24:32 <Heffalump> it might improve the error message
08:26:43 <Heffalump> for some reason it thinks your do is in the list monad, but it's not obvious why given that fragment
08:27:44 <pitecus> Im getting cramps for using haskell-mode. Is it just my emacs or is it normal that that when I hit C-c C-l it does scroll the haskell buffer down and doesnt put the cursor in it??
08:27:55 <pitecus> does=doesn't
08:29:17 <bauchus> no type signature is accepted. I tried e.g. addUserPage :: MonadCGI m => m Html
08:29:17 <bauchus>  
08:30:37 <ToRA|home> bauchus: what's calling addUserPage ?
08:31:10 <bauchus> addUserPage = do
08:31:10 <bauchus>   liftIO $ return ()
08:31:10 <bauchus>   return $ stringToHtml "test"
08:31:10 <bauchus>  
08:31:10 <LeCamarade> vi! vi! *ducks*
08:31:22 <ToRA|home> bauchus: what's /calling/ addUserPage ?
08:31:56 <Botje> vi ducks?
08:32:20 <bauchus>  
08:32:20 <bauchus> cgiMain = do
08:32:20 <bauchus>   mode <- getInput "mode"
08:32:20 <bauchus>   output
08:32:24 <bauchus>     (case fromMaybe "portal" mode of
08:32:27 <bauchus>       "portal" -> ePage "Main" mainPage
08:32:28 <Botje> argh!
08:32:30 <bauchus>       "register" -> ePage "Register!" registerPage
08:32:33 <bauchus>       "adduser" -> do
08:32:37 <bauchus>         p <- addUserPage
08:32:39 <bauchus>         ePage "New User added" p
08:32:39 <ToRA|home> bauchus: if it's long use @paste ?
08:32:41 <Botje> bauchus: please use hpaste or a similar pasting service..
08:32:42 <bauchus>       _ -> "haeh")
08:32:43 <ToRA|home> @paste
08:32:43 <lambdabot> Haskell pastebin: http://hpaste.org/new
08:32:45 <bauchus>  
08:32:48 <bauchus>  
08:32:54 <bauchus> sorry
08:33:03 <sorear> bauchus: _ -> "heah"
08:33:09 <sorear> bauchus: that's the problem line
08:33:13 <arjanoosting> ls
08:33:22 <sorear> arjanoosting: switch windows
08:33:23 <wolverian> . .. GOAT_PORN/
08:33:25 <ari> su
08:33:44 <sorear> ari: we've actually seen that here!
08:33:47 <arjanoosting> sorear: will do ;-)
08:33:52 <benny99> anybody wrote a compiler in Haskell yet :) ?
08:33:54 <wolverian> sorear, with password? :)
08:34:01 <Botje> benny99: ghc is written in haskell :P
08:34:05 <bartw> definitly
08:34:10 <wolverian> definitely
08:34:15 <sorear> wolverian: if so, their password was "damn" - unlikely
08:34:17 <bartw> done that kind of thing in the past, not here
08:34:24 <ari> sorear: :D
08:34:30 <DRMacIver> Isn't "writing compilers" the canonical example of a task Haskell is good for? :)
08:34:44 <benny99> DRMacIver: dunno :Z
08:34:49 <sorear> yep
08:34:53 <LeCamarade> A task ML-family is good for.
08:34:53 <benny99> DRMacIver: I just thought it might be good for :D
08:35:02 <bartw> make sure it is an imperative language the compiler accepts :)
08:35:31 <DRMacIver> LeCamarade: True. Although some of the features Haskell adds seem to help quite a lot.
08:35:53 <sorear> wolverian: Also seen on #haskell:
08:35:54 <LeCamarade> Yeah. True.
08:35:55 <sorear> ./03.05.19:19:30:39 * ozone ickserv identify zxcmn7
08:35:55 <sorear> ./03.05.19:19:33:25 * ozone grumbles as he changes his universal nickserv password
08:35:56 <DRMacIver> Speaking of which, I'm vastly annoyed that the ES2 reference implementation doesn't work on linux yet. :)
08:36:09 <benny99> and is it also good for AI ?
08:36:32 <DRMacIver> Hm. Someone was going through an AI book rewriting all the examples in Haskell on his blog. Who was it?
08:36:56 <ari> benny99: No, Lisp is the canonical AI language. Also, JavaScript can only be used on WWW browsers, and Ruby only on WWW servers :).
08:37:05 <wolverian> sorear, heh.
08:37:15 <bauchus> sorear is right, ghc is now happy with my code. Thank you all!
08:37:22 <sorear> yw!
08:37:38 <Syzygy-> Hmmmmm. I want to take a list of Ints, and split it at each point where there is a decrease in the listed Ints.
08:37:51 <benny99> ari: if lisp is good, why isn'T Haskell :8( ?
08:38:04 <Syzygy-> So I want [2,3,1,4] -> [[2,3],[1,4]] and [2,1,4,3] -> [[2],[1,4],[3]]
08:38:15 <ari> > groupBy (>) [2,3,1,4]
08:38:15 <Syzygy-> Any ideas how to do this neatly?
08:38:17 <lambdabot>  [[2],[3,1],[4]]
08:38:22 <Syzygy-> Wooot!
08:38:24 <yaxu> wow
08:38:26 <Syzygy-> Thanks!
08:38:28 <benny99> lol :D
08:38:33 <yaxu> haskell++
08:38:36 <sorear> no, that won't work
08:38:37 <DRMacIver> Hmm. Does that really do the right thing?
08:38:38 <Syzygy-> ari++
08:38:40 <LeCamarade> :o)
08:38:47 <Syzygy-> > groupBy (<) [2,3,1,4]
08:38:48 <lambdabot>  [[2,3],[1,4]]
08:38:51 <Syzygy-> Perfect!!
08:38:51 <sorear> Syzygy-: http://www-users.cs.york.ac.uk/~ndm/downloads/slides-unfailing_haskell_a_static_checker_for_pattern_matching-24_sep_2005.pdf
08:38:54 <lambdabot> http://tinyurl.com/yp7jvv
08:39:00 <Syzygy-> sorear: Hmmm?
08:39:02 <benny99> whatever, thank you :)
08:39:17 <DRMacIver> groupBy (>) [1, 2, 3, 4, 3]
08:39:19 <DRMacIver> > groupBy (>) [1, 2, 3, 4, 3]
08:39:20 <lambdabot>  [[1],[2],[3],[4,3]]
08:39:22 <sorear> Syzygy-: the first example they give just happens to be the one you need
08:39:24 <Saizan>  > groupBy (<) [2,3,5,4,6]
08:39:32 <Saizan> > groupBy (<) [2,3,5,4,6]
08:39:33 <Syzygy-> sorear: Oh?
08:39:34 <lambdabot>  [[2,3,5,4,6]]
08:39:40 <DRMacIver> > groupBy (>) [1, 2, 3, 4, 3, 2]
08:39:41 <lambdabot>  [[1],[2],[3],[4,3,2]]
08:39:43 <Syzygy-> sorear: But this groupBy (<) seems to do just what I want...
08:39:44 <sorear> Syzygy-: Right.  Page 2
08:40:04 <Saizan> Syzygy-: it doesn't, it always comapres with the first element
08:40:07 <sorear> @src groupBy
08:40:07 <lambdabot> groupBy _  []       =  []
08:40:07 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
08:40:07 <lambdabot>     where (ys,zs) = span (eq x) xs
08:40:27 <Saizan> Syzygy-: in fact the eq is supposed to be an equivalence relation
08:40:35 <Syzygy-> Oh, bugger
08:40:36 <sorear> > groupBy (<) [10,12,11]
08:40:37 <lambdabot>  [[10,12,11]]
08:40:40 <sorear> Syzygy-: ^^
08:40:45 <Syzygy-> Right.
08:40:51 <ari> ):
08:41:06 <sorear> Syzygy-: see 'risers' on page 2 of the pasted pdf
08:41:17 <Syzygy-> I have it.
08:41:18 <Syzygy-> Thanks!
08:43:06 <Syzygy-> sorear++
08:55:08 <sorear> Grr.
08:55:20 <sorear> I'm writing a 2d layout combinator system
08:55:37 <sorear> is it normal for `beside` to need 25 lines of boilerplate?
09:00:31 <benny99> The guy that wrote the YAHT book is a genius in explaining :]
09:00:47 <sorear> @seen kowey  -- it was this guy
09:00:47 <lambdabot> I haven't seen kowey.
09:00:50 <benny99> if any other newBs are in here, I recommend it
09:00:55 <Heffalump> I thought it was Hal Daume
09:01:02 <benny99> it's Hal
09:01:02 <Heffalump> kowey may have done stuff to it since
09:01:08 <sorear> oh right.  kowey did the wbook
09:01:11 <Heffalump> yes
09:01:41 <Heffalump> sorear: do you mean 2d as in the ICFP contest language from last year, or just a general 2d layout language?
09:02:16 <Saizan> i found the initial part on IO quite confusing, but i had never used a static typed language at the time
09:02:18 <sorear> Heffalump: The latter, for a real program.
09:02:32 <sorear> Heffalump: text "foo" `above` text "bar"
09:03:02 <benny99> btw. if there are any other new haskell programmers in here interested in participating the ICFP contest, I'd like to join them =)
09:03:24 * DRMacIver is interested in but unable to. :)
09:03:36 <DRMacIver> Timing doesn't work out. I'll be computerless the weekend of the competition.
09:03:47 <benny99> oh :(
09:04:16 <sorear> Heffalump: shall I @paste ?
09:05:01 <Heffalump> sure, sounds interesting
09:05:08 <Heffalump> you know about Lava and the like, presumably?
09:05:37 <sorear> nope
09:05:46 <sorear> well, I know what it *is*
09:06:44 * benny99 is away again, if anybody is interested /msg me -- but it's supposed to be fun only
09:07:26 <Heffalump> I presume they had to solve some kind of similar problem, that's all.
09:08:38 <swiert> sorear: Conor McBride also wrote some 2d layout combinators for Epigram.
09:09:21 <hpaste>  sorear pasted "look at beside" at http://hpaste.org/230
09:10:22 <swiert> You don't want to use monads maybe.
09:10:36 <swiert> It reminds me of applicative functors:
09:10:45 <sorear> swiert: Yes, I don't want to.
09:10:54 <mattam> Hi Wouter !
09:11:06 <sorear> swiert: But I have to.  queryTextExtents isn't pure
09:11:14 <swiert> Hi Matthieu!
09:11:45 * sorear did not know Swierstra was a #haskeller
09:12:09 <Heffalump> augustss may also have some advice, he's written this kind of thing for work
09:12:20 <Heffalump> sorear: there are many Swierstras :-)
09:13:43 <ekidd> Yay! The first three sections of my paper are done. Now I get to spend the remaining sections geeking out on the theory and implementation. :-)
09:14:21 <sorear> tat!
09:14:23 <sorear> yay!
09:14:27 <opqdonut> :)
09:14:28 * Heffalump likes not having to write papers any more
09:14:35 <opqdonut> i've got a presentation on tuesday
09:14:47 <opqdonut> general topic: genetic algorithms and haskell
09:14:56 * DRMacIver never went through a paper writing phase.
09:15:01 <ekidd> I get to write things like "Let $\eta : a \to \M a$ be a function that blah blah blah..."
09:15:04 <DRMacIver> I kinda regret this.
09:15:05 <opqdonut> well, more like "genetic algorithms (in haskell btw)"
09:15:27 <sorear> |eta :: a -> M| :)
09:16:07 <ekidd> sorear: I've forgotten how much work writing a paper is. It's been years since I last did this...
09:16:23 <emu> i was swimming in TeX last semester. wrote more of that than any prog. lang.
09:16:37 <Heffalump> DRMacIver: why not do a PhD :-)
09:16:53 <sorear> swiert: "It reminds me of applicative functors:" ?
09:16:55 <DRMacIver> Heffalump: I applied to do one, but they all turned me down. :)
09:17:16 <swiert> sorear: Your calculation of b0.
09:17:31 <swiert> You might want to right f <*> w1 <*> w2.
09:17:36 <swiert> For some suitable definition of f.
09:17:49 <bartw> never saw the attraction of paper writing
09:17:52 <DRMacIver> I may apply again in a few years when I'll hopefully be better prepared to convince people that not havin ga computer science degree doesn't disqualify me for doing a CS PhD. :)
09:18:19 <DRMacIver> (And I'm more convinced that I actually want to do one)
09:18:54 <Philippa> bartw: the attraction's more in having the paper written
09:19:39 <DRMacIver> To me the attraction is more doing the research.
09:20:03 <ekidd> Philippa: There's some real opportunity for despair in the middle of the writing process.
09:20:04 <Philippa> well yeah. Making your results concrete belongs in there somewhere though
09:20:20 <Philippa> ekidd: yeah, I know
09:20:26 <DRMacIver> Yeah. Although it has some downsides.
09:20:31 <DRMacIver> I actually have a paper half written.
09:20:41 <DRMacIver> The problem is it's been half written for most of a year and I've stopped writing it. :)
09:20:50 <Philippa> ...heh. It's a shame I dropped out officially now, or I would've asked if I could turn my current interpreter-and-compiler project into my final year dissertation project
09:21:30 <Heffalump> I sometimes wonder how important written papers are to the permanent record in CS.
09:21:48 <Heffalump> It can be hard to reproduce them without the accompanying software.
09:21:52 <ekidd> "Did I miss something in my literature search? How on earth can I explain this part to somebody who hasn't lived with this problem for months? Do I need to completely rethink section Foo, now that I'm actually trying to explain it?"
09:22:05 <DRMacIver> Well, mine was a maths paper. :)
09:22:27 <Philippa> it varies from field to field - technical reports are a good thing though
09:22:34 <ekidd> Oh, and, "Why did I only give myself two weeks to write 12 pages? Argh! I forgot how long this takes!"
09:22:42 <DRMacIver> Well a lot of papers don't seem to have accompanying implementations. And software rots, where paper doesn't. :)
09:22:54 <pejo> Heffalump, they're even harder to reproduce without the paper though.
09:23:15 <Philippa> ekidd: I try to tackle the middle one early by talking to people who aren't working on it once in a while
09:23:28 <ekidd> DRMacIver: My paper can actually be fed to GHC. :-)
09:23:39 <DRMacIver> Literate Haskell?
09:23:46 <Philippa> DRMacIver: paper does too rot, it's just rather slower and more literal
09:24:07 <DRMacIver> Philippa: Well, yes. I meant to say "where papers don't".
09:24:30 <ekidd> Philippa: Yeah. I have the advantage of starting from blog posts, so I had at least some expository framework. But making it all flow coherently is still a challenge.
09:24:34 <DRMacIver> It's harder to kill an idea than a program. :)
09:25:06 <ekidd> Philippa: And I'm currently running it by an ultra-bright high-school student.
09:25:20 <Philippa> ekidd: good move
09:25:54 <thedatabase> ekidd: hi there - what are you writing your paper on out of interest?
09:25:57 <ekidd> DRMacIver: Yup. lhs2TeX is definitely my friend.
09:26:32 <kosmikus> thanks
09:26:32 <thedatabase> ekidd: is it the probability monad stuff?
09:26:38 <ekidd> thedatabase: http://www.randomhacks.net/articles/tag/Probability
09:26:40 <ekidd> Yup.
09:26:40 <lambdabot> Title: Random Hacks
09:26:47 <thedatabase> nice
09:26:55 <thedatabase> look forwards to that coming out!
09:27:24 <ekidd> I should have drafts available by the end of the weekend, if I'm insanely lucky. :-) It's time for lunch, and then back to writing...
09:27:42 <thedatabase> good luck then! enjoy.. ;)
09:27:58 <Heffalump> pejo: sure, but people aren't forced to publish their implementations along with their papers :-(
09:28:32 <Philippa> do you find TRs useful where they're available?
09:29:12 <Heffalump> yes, but those are generally just papers with more material
09:29:19 <Heffalump> that they had to chop for conference proceedings
09:29:21 <DRMacIver> TRs?
09:29:26 <Philippa> Technical Reports
09:29:28 <Heffalump> usually any material in a TR ends up in the journal paper, if any
09:29:40 <DRMacIver> Ah
09:29:51 <Philippa> I've seen cases where it didn't
09:31:46 <Heffalump> hence "usually" :-p
09:32:12 <roconnor> @type unwords
09:32:16 <lambdabot> [String] -> String
09:33:09 <roconnor> Heffalump: I published my haskell source code with my paper in my recent publication, even though a reviewer didn't like it much as I recall.
09:35:11 <bos> @seen dons
09:35:12 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 2h 16m 30s ago.
09:35:34 <sorear> @itme done
09:35:36 <sorear> @itme dons
09:35:37 <lambdabot> Local time for dons is Sun Jun 10 02:35:03 2007
09:36:15 <gwern> ...why does @itme give the local time?
09:36:25 <ihope> gwern: because @time does?
09:36:28 <ihope> @itme
09:36:28 <sorear> gwern: why shouldn't it?
09:36:30 <lambdabot> Local time for ihope is Saturday, June 09, 2007 12:35:49 PM
09:36:42 <gwern> because itme isn't time?
09:36:53 <ihope> lambdabot does misspellings.
09:36:59 <sorear> @botsnake
09:37:00 <lambdabot> :)
09:37:09 <DRMacIver> Cunning
09:37:12 <sorear> @sene gwern
09:37:12 <lambdabot> gwern is in #haskell and #xmonad. I last heard gwern speak 30s ago.
09:37:13 <ihope> @qoute
09:37:13 <lambdabot> Maybe you meant: quote vote
09:37:17 <ihope> Darn.
09:37:19 <benny99> @itime
09:37:24 <sorear> @ow
09:37:25 <lambdabot> I hope the ``Eurythmics'' practice birth control ...
09:37:35 <gwern> so lambdabot is a cunning linguistuc parser then
09:37:39 <benny99> @itme
09:37:52 <benny99> :'( ok
09:37:56 * benny99 is away
09:38:15 <sorear> levenshtein :: (Eq a) => [a] -> [a] -> Int
09:38:21 <ihope> @itsme
09:38:24 <lambdabot> Local time for ihope is Saturday, June 09, 2007 12:37:41 PM
09:38:33 <ihope> lambdabot seems to not like benny99.
09:38:36 <wolverian> @eatme
09:38:36 <lambdabot> Unknown command, try @list
09:39:46 <Philippa> gwern: if you want that you'd have to ask @vixen nicely
09:40:16 <ihope> Ooh, here's a fun one.
09:40:17 <ihope> > let fac n = map (\x -> (x, True)) $ scanl (*) 1 [1..(read n)] in fac "5" :: [(Float, Bool)]
09:40:19 <lambdabot>  [(1.0,True),(1.0,True),(2.0,True),(6.0,True),(24.0,True),(120.0,True)]
09:41:17 <sorear> benny99: lambdabot uses CTCP - is that enabled in your client?
09:41:32 <sorear> 09:40 CTCP VERSION reply from benny99: Gaim IRC
09:41:43 <sorear> hmm, I wonder why it doesn't do TIME
09:42:00 <daniel_larsson> @time
09:42:17 <benny99> sorear: apears like Gaim doesn't
09:42:27 <sorear> aww
09:42:48 <daniel_larsson> I got "(18:42:31) sorear: Received CTCP 'TIME' (to daniel_larsson) from sorear"
09:42:56 <benny99> cool, lambdabot does haskell =D ?
09:43:04 <sorear> > 2 + 2
09:43:05 <lambdabot>  4
09:43:17 <sorear> > nubBy(((>1).).gcd)[2..]
09:43:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
09:43:24 <sorear> > fix((1:).scanl(+)1)
09:43:25 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
09:43:25 <benny99> >(\x -> x * x) 2
09:43:33 <sorear> benny99: you need the space
09:43:34 <benny99> it hates me :'(
09:43:43 <benny99> > (\x -> x * x) 2
09:43:43 <sorear> >(\x -> x * x) 2
09:43:44 <lambdabot>  4
09:43:48 <benny99> yeaaah :O
09:43:53 <sorear> >(\x -> x * x) 2
09:44:04 <benny99> I guess that is the best method to prevent spamming huh ;P
09:44:15 <sorear> @ignore + benny99
09:44:18 <benny99> and I was using ghci :p
09:44:21 <sorear> NOW the bot hates you :)
09:44:21 <benny99> :( what?
09:44:23 <sorear> @ignore - benny99
09:44:31 <kaol> @botsnack
09:44:32 <lambdabot> :)
09:44:32 <benny99> ah :P
09:44:39 <benny99> @botosexual
09:44:39 <lambdabot> Unknown command, try @list
09:45:15 <benny99> @botweiser
09:45:15 <lambdabot> Unknown command, try @list
09:45:27 <benny99> enough, sorry :S
09:49:02 <gogonkt1> Who is ndm in wiki ?
09:52:10 <fasta> What is the function that given two values in a tuple (a,b) applies f to a and g to b and collects the results and returns that? I think it's some library function.
09:52:11 <sorear> NeilMitchell
09:52:38 <sorear> > (negate *** recip) (20, 3)
09:52:43 <zarvok> benny99: if you want to keep playing with the bot, you can always /msg it instead
09:52:45 <lambdabot>  (-20,0.3333333333333333)
09:53:00 <sorear> fasta: Do I interpret you right?
09:53:01 <fasta> f and g and monadic computations
09:53:12 <fasta> By returned I meant "return in a monad".
09:54:10 <fasta> sorear: I don't think that applies to monadic functions, right?
09:54:29 <ToRA|home> fasta: do you have a type signature for the function you're thinking of?
09:55:11 <sorear> mystery :: Monad m => (a -> m b) -> (c -> m d) -> (a,c) -> m (b,d)
09:55:12 <sorear> ?
09:55:29 <benny99> zarvok: I'll try it the next time ;)
09:55:29 <fasta> sorear: yes
09:56:00 <benny99> I wonder if I could rape lambdabot for some calculations :Z ...
09:56:02 <conal> fasta: use Kleisli to turn the monadic computations into arrrow computations.  then (***) applies.
09:56:31 <sorear> (***) will work :: Kleisli m a b -> Kleisli m c d -> Kleisli m (a,c) (b,d)
09:56:35 <benny99> (I'm not seriously wondering)
09:56:41 <sorear> alas, Kleisli is a newtype
09:56:51 <benny99> have fun anyway
09:57:02 <sorear> @src Kleisli
09:57:02 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
09:57:21 <sorear> newtype Kleisli m a b = Kleisli { runKleisli :: a -> m b }
09:58:30 <conal> so mystery f g = runKleisli (Kleisli f *** Kleisli g)
10:02:33 <fasta> Thanks
10:05:04 <filcab42> IO> let {ola = [1,2,3,4,5,6,7]} in { acc 0 = 0; acc x = (ola !! x) + acc (x-1)}
10:05:10 <filcab42> shouldn't this work in the repl?
10:05:30 <sorear> No
10:05:43 <sorear> IO is just IO functions
10:05:52 <sorear> !!, +, and - are in Prelude
10:06:16 <sorear> Still no
10:06:18 <filcab42> oh
10:06:20 <filcab42> right
10:06:34 <sorear> the right hand of let needs to be an expression; those are declarations
10:06:44 <filcab42> it's always the same. I break the code in a :reload and then forget to change module
10:06:53 <filcab42> ups
10:06:57 <filcab42> quite right
10:07:01 <filcab42> thanks
10:07:10 <sorear> let ola = [1,2,3,4,5,6,7] ; acc 0 = 0 ; acc x = (ola !! x) + acc (x - 1) -- should work
10:08:28 <filcab42> yes
10:08:56 <filcab42> do you know how I could turn this into a list comprehension?
10:09:01 <filcab42> (where ola would be any list)
10:09:06 <filcab42> I can't get to that :s
10:09:30 <sorear> i'd use sum
10:09:32 <int-e> @type foldr
10:09:34 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
10:09:49 <sorear> acc x = sum (take (x + 1) ola)
10:09:49 <filcab42> hmm... foldr with a weird function, could work
10:10:04 <int-e> @src sum
10:10:04 <lambdabot> sum = foldl (+) 0
10:11:07 <int-e> oh, you never use  head ola  at all.
10:11:16 <hpaste>  sorear annotated "look at beside" with "beside in mock CPS.  no shorter but a lot prettier" at http://hpaste.org/230#a1
10:11:23 <int-e> > scanl (+) 0 [1..7]
10:11:24 <lambdabot>  [0,1,3,6,10,15,21,28]
10:11:46 <sorear> swiert: ^^
10:13:16 <int-e> so acc x = sum (drop 1 (take (x+1) ola)), or acc x = scanl (+) 0 (drop 1 ola) !! x
10:14:28 <sorear> @users
10:14:28 <lambdabot> Maximum users seen in #haskell: 325, currently: 319 (98.2%), active: 53 (16.6%)
10:16:45 <gogonkt1> @users
10:16:45 <lambdabot> Maximum users seen in #haskell: 325, currently: 318 (97.8%), active: 53 (16.7%)
10:16:54 <gogonkt1> oh
10:17:36 <gogonkt1> > scanl (+) 0 [1..7]
10:17:37 <lambdabot>  [0,1,3,6,10,15,21,28]
10:22:11 <filcab42> is there something like gdb?
10:22:24 <filcab42> to watch what happens and do step by step debugging?
10:23:41 <benny99> *got an idea* are there already IRC-MUD-Bots ?
10:25:30 <sorear> filcab42: yes
10:25:41 <filcab42> how?
10:26:07 <sorear> filcab42: in the development version of ghc there is a :break command
10:26:32 <filcab42> hmm
10:26:56 <Excedrin> benny99: there's a few irc games, but not muds afaik
10:27:36 <Excedrin> benny99: http://en.wikipedia.org/wiki/Idle_RPG <- this one is the best
10:27:38 <lambdabot> Title: Idle RPG - Wikipedia, the free encyclopedia
10:29:43 <benny99> Excedrin: thanks :)
10:39:14 <filcab42> damn
10:39:18 <sorear> ?
10:39:27 <filcab42> it just doesn't want to do what I told it!
10:39:31 <filcab42> (I know, I know :P)
10:39:58 <filcab42> I have a two-dimentional matrix (a list inside a list)
10:40:57 <filcab42> and I wanted to fill an array with the "score" of a certain cell
10:41:08 <filcab42> I'm doing dynamic programming, btw
10:41:39 <hpaste>  filcab pasted "problem" at http://hpaste.org/231
10:42:25 <filcab42> but the "cache" ends up filled with zeroes
10:43:13 <sorear> filcab42: I think you need to use y,x ordering
10:44:44 <int-e> filcab42: well all you ever calculate is min 0 0 = 0 ...
10:46:25 <filcab42> int-e: no...
10:46:27 <int-e> filcab42: maybe you're missing a '1+' somewhere?
10:47:04 <filcab42> to calculate (0,1) I have to calculate (0,2) + (1 @@ 2) and (1,2) + (0 @@ 1)
10:47:16 <int-e> yes, and both of these give 0
10:47:23 <int-e> as implemented
10:47:25 <filcab42> x@@y = matrix !! x !! y
10:47:26 <filcab42> ?
10:47:27 <filcab42> how?
10:48:02 <filcab42> if 1@@2 is 1 (for example), (0,1) is (0,2) +1
10:48:51 <int-e> _ @@ (n-1) and (n-1) @@ _ are 0. so _ @@ (n-2) and (n-2) @@ _ are 0, and so on.
10:49:17 <filcab42> ups
10:49:22 <fasta> How does one call this one?
10:49:24 <fasta> mystery_part_2 m1 m2 a  = do
10:49:24 <fasta>   k <- m1 a
10:49:24 <fasta>   m2 k
10:49:51 <filcab42> I meant to have this
10:49:52 <filcab42> (@@) i j = matrix !! i !! j
10:49:58 <filcab42> :'(
10:50:02 <filcab42> sorry :$
10:50:15 <int-e> filcab42: hah. ok, that explains a lot :)
10:50:22 <fasta> filcab42: you want to torture your machine?
10:50:27 <filcab42> now that was dumb
10:50:28 <filcab42> lol
10:50:33 <filcab42> why?
10:50:36 <kpreid> fasta: well, mystery_part_2 a = a >>= m1 >>= m2...
10:50:37 <fasta> filcab42: energy bill to low?
10:50:45 <filcab42> (but yes, I like torturing computers :P)
10:50:45 <filcab42> lol
10:50:45 <filcab42> nah
10:51:05 <int-e> filcab42: in any case, the recursive call to score,  score i y, should be matrix ! (i,y) (otherwise all the memoization will do you no good), and similar for  score x i
10:51:24 <int-e> filcab42: sorry
10:51:29 <int-e> filcab42: cache, not matrix.
10:51:34 <filcab42> yap
10:51:37 <filcab42> thanks
10:52:06 <filcab42> I like this lazy stuff :P
10:52:15 <filcab42> *ok... I'm starting to like :d
10:52:58 <fasta> kpreid: a is not a monadic value
10:53:14 <kpreid> er, whoops
10:53:31 <kpreid> so m1 a >>= m2
10:53:46 <fasta> kpreid: I don't want to mention a.
10:54:08 <kpreid> @type \m1 m2 a -> m1 a >>= m2
10:54:10 <lambdabot> forall t (m :: * -> *) a b. (Monad m) => (t -> m a) -> (a -> m b) -> t -> m b
10:54:11 <kpreid> okay...
10:54:13 <kpreid> @pl \m1 m2 a -> m1 a >>= m2
10:54:13 <lambdabot> flip . ((>>=) .)
10:54:25 <kpreid> @pl \a -> m1 a >>= m2
10:54:25 <lambdabot> (m2 =<<) . m1
10:54:30 <kpreid> how's that?
10:54:34 <filcab42> btw... when you're reading code, how do you read "m a >>= b"?
10:54:41 <filcab42> I just can't get a name in there
10:54:50 <filcab42> and it breaks my brain while reading code :s
10:54:51 <kpreid> filcab42: I read it as "m a >>= b"
10:54:54 <Heffalump> >>= is often read as "bind"
10:54:56 <filcab42> LOL
10:55:10 <filcab42> so... "m a 'bind' b"?
10:55:13 <Heffalump> yes
10:55:16 <filcab42> kind of weird :s
10:55:19 <filcab42> oh well...
10:55:21 <kpreid> you could call it "into" if you like
10:55:21 <filcab42> thnks
10:58:16 <filcab42> kpreid: thank you! that's way better! :D
11:03:05 <Heffalump> or "then"
11:06:24 <filcab42> wasn't "<<" the "then"?
11:06:37 <filcab42> ups.. ">>"
11:09:19 <benny99> ??
11:11:52 <Heffalump> oh, possibly
11:12:48 <filcab42> weird
11:12:56 <filcab42> I have: custos = [(acc (i-1)) + ((i-1) @@ i) | i <- [1..n-1]]
11:12:58 <Saizan> pipe?
11:13:10 <filcab42> (acc x = accumulated ! x)
11:13:12 <filcab42> and:
11:13:20 <filcab42> accumulated: array (0,3) [(0,0),...
11:13:35 <filcab42> cache: array ((0,0),(3,3)) [((0,0),5),((0,1),3),...
11:13:49 <filcab42> and I get: custos: [2,...
11:13:49 <filcab42> wtf?
11:14:11 <filcab42> the first one should be: acc 0 + cache (0,1)
11:14:17 <filcab42> which is 4
11:14:19 <filcab42> :s
11:15:07 <Saizan> what's @@?
11:15:22 <benny99> is there something like (^) for fracs ?
11:15:33 <Saizan> ?type (**)
11:15:35 <lambdabot> forall a. (Floating a) => a -> a -> a
11:15:41 <Saizan> ?type (^^)
11:15:42 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
11:15:53 <benny99> thanks :)
11:16:36 <benny99> I was looking for ** :)
11:17:14 <filcab42> @@ x y == cache ! (x,y)
11:18:09 * benny99 is away
11:18:39 <Saizan> it should be 3 then
11:19:18 <filcab42> yes
11:20:09 <Saizan> you sure you have not some off-by-one error somewhere?
11:20:58 * edwardk waves hello.
11:21:48 <sorear> hi!
11:29:13 <filcab42> ugh
11:29:13 <filcab42> ghc is 10 times slower than gcc
11:29:13 <filcab42> wait
11:29:13 * edwardk returns from microsoft-tech-ed land, where he had a good time proselytizing about the virtues of very strongly typed languages to a couple of the guys from the dynamic languages group there ;)
11:29:13 <sorear> filcab42: you're off by two orders of magnitude
11:29:13 <filcab42> lol
11:29:13 <filcab42> [filcab@godel ~/ist/asa/Mini-Projectos/projecto3] $ time ./proj3 < 10/10.in
11:29:13 <filcab42> custo: 14709
11:29:13 <filcab42> real    0m0.107s
11:29:13 <filcab42> user    0m0.096s
11:29:13 <filcab42> haskell
11:29:13 <filcab42> [filcab@godel ~/ist/asa/Mini-Projectos/projecto3] $ time ./proj < 10/10.in
11:29:13 <filcab42> 14709
11:29:13 <filcab42> 50
11:29:13 <filcab42> real    0m0.041s
11:29:13 <filcab42> user    0m0.005s
11:29:13 <filcab42> C
11:29:13 <filcab42> (only the first number counts
11:29:13 <Korollary> edwardk: preach it bro
11:29:13 <filcab42> I compiled it like this: [filcab@godel ~/ist/asa/Mini-Projectos/projecto3] $ ghc --make -O3 proj3.hs -o p
11:29:13 <filcab42> roj3
11:29:13 <sorear> filcab42: 0.04s is about how long it takes to start a program under Linux
11:29:13 <sorear> filcab42: so it's more like  0.067s v. 0.001s
11:29:13 <filcab42> lol
11:29:15 <filcab42> (when I said it was 10 times slower I didn't have -O3 in haskell)
11:29:30 <edwardk> kor: that and i was able to make meet the right people in the visual studio extensions team and get enough material to seriously think about plugging in my toy language into visual studio much like visual haskell. (now there is a lot more of the interface exposed via managed code, so the COM interop issues simon marlow ran into can be somewhat ameliorated)
11:29:55 <filcab42> oh... and gcc has -g and -O0
11:30:23 <filcab42> sorry if it seems trolling... but I just wanted to know what I could do to speed this up
11:30:57 <Twan> IIRC you need -O2 instead of -O3
11:31:00 <sorear> filcab42: ghc -O3 may be slower than ghc -O0 *at run time*, there is a bug in some versions that causes -O options higher than -O2 to be misparsed
11:31:29 <edwardk> same thing you can do in C, move to a lot of smaller modules with finer grained dependencies
11:31:37 <pejo> edwardk, are they encouraging VS extensions?
11:32:53 <edwardk> pejo: apparently, they have a new integrated mode versuib they are going to start shipping around visual studio 2008, where your language extension can be installed as the first thing in visual studio, and can install visual studio on its own if its not present
11:33:20 <edwardk> pejo: with no royalties/license fees, so it just became a serious contender to building up an interface in eclipse in my eyes
11:33:38 <edwardk> or at least a good solid additional interface to consider building
11:33:55 <edwardk> s/versuib/version/g
11:37:39 <filcab42> even with -O2 it's more than twice as slow
11:38:03 <filcab42> and, even worse, with a bigger test I have here, it doesn't end within 10 secs
11:38:19 <filcab42> (the C version (-O0 -g) runs all the tests in half a second)
11:38:29 <filcab42> that's quite a difference :s
11:38:33 <edwardk> filcab: it is going to be quite a bit slower than c, we generate c after all ;)
11:38:40 <filcab42> lol
11:38:44 <filcab42> but this is not "a bit"
11:38:53 <filcab42> [filcab@godel ~/ist/asa/Mini-Projectos/projecto3] $ time ./proj3 < 18/18.in
11:38:54 <filcab42> custo: 129437
11:38:54 <filcab42> real    0m58.059s
11:38:58 <filcab42> [filcab@godel ~/ist/asa/Mini-Projectos/projecto3] $ time ./proj < 18/18.in
11:38:58 <filcab42> 129437
11:38:58 <filcab42> 438
11:38:59 <filcab42> real    0m0.242s
11:39:07 <filcab42> > 60*5
11:39:08 <lambdabot>  300
11:39:16 <filcab42> it's 300 times slower
11:39:43 <edwardk> what is the task that you are comparing, can you hpaste it?
11:40:07 <filcab42> you want me to paste the input file?
11:40:09 <filcab42> or the program?
11:40:48 <edwardk> keep in mind the ghc version is dealing with all sorts of generic stuff in its prelude, that the c compiler doesn't deal with, so the compiler has a lot more overhead than c, it tends to be more fair to compare ghc compile time to the compile time of heavily STL'd c++ code, then they come out about equal ;)
11:41:07 <edwardk> i'm more interested in comparing the programs at this point
11:41:49 <pejo> edwardk, but only available for Windows, I assume?
11:41:51 <filcab42> well, the C program I can't paste (yet)
11:41:56 <filcab42> but I can paste the haskell one
11:42:13 <edwardk> pejo: thats why i was thinking of it as 'in addition to' not necessarily as instead of eclipse ;)
11:42:24 <sorear> filcab42: use hpaste, @paste
11:42:43 <sorear> filcab42: if it's bigger than 5k upload it somewhere - hpaste truncates
11:43:04 <hpaste>  filcab pasted "program" at http://hpaste.org/232
11:43:09 <filcab42> it's fairly small
11:44:20 <edwardk> filcab: i'll tell you right now you are taking a huge performance hit with using !! !! to dereference elements from a [[Int]] use an array!
11:44:55 <sorear> Huge as in !! is *asymptotically* slower
11:44:57 <filcab42> k
11:45:01 <sorear> O(n) in the size of the list
11:45:39 <fasta> filcab42: That was what I meant by torturing your computer btw.
11:47:38 <SamB> @hoogle String -> ReadS
11:47:42 <lambdabot> No matches, try a more general search
11:47:43 <SamB> @hoogle String -> ReadS a
11:47:44 <lambdabot> No matches, try a more general search
11:47:55 <sorear> @hoogle ReadS a
11:47:56 <lambdabot> Text.ParserCombinators.ReadP.readP_to_S :: ReadP a -> ReadS a
11:47:56 <lambdabot> Prelude.readParen :: Bool -> ReadS a -> ReadS a
11:47:56 <lambdabot> Text.ParserCombinators.ReadPrec.readPrec_to_S :: ReadPrec a -> Int -> ReadS a
11:48:03 <sorear> @src ReadS
11:48:04 <lambdabot> Source not found. My mind is going. I can feel it.
11:48:16 <sorear> type ReadS a = String -> [(a,String)]
11:48:27 <sorear> so passing String doesn't make much sense!
11:49:03 <filcab42> ?
11:49:22 <SamB> @doc Prelude
11:49:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
11:49:44 <filcab42> I'm trying to understand why you're directing me to ReadS
11:50:36 <sorear> filcab42: I think he's asking the bot for personal reasons and you can ignore him
11:51:08 <filcab42> oh
11:51:17 <SamB> filcab42: sorry
11:51:40 <weitzman> I always keep a private line to lambdabot open in case of a Haskell emergency
11:51:49 <filcab42> Array> listArray ((1,2),(1,2)) [1,2,3,4]
11:51:49 <filcab42> array ((1,2),(1,2)) [((1,2),1)]
11:51:55 <filcab42> shouldn't this work?
11:52:47 <dmhouse> filcab42: the only pair between (1, 2) and (1, 2) is (1, 2).
11:52:55 <dmhouse> > [(1, 2) .. (3, 4)]
11:52:56 <lambdabot>   add an instance declaration for (Enum (t, t1))
11:52:56 <lambdabot>     In the expression: [(1, ...
11:53:05 <dmhouse> Oh, I thought listArray needed Enum...
11:53:39 <dmhouse> ?type listArray
11:53:41 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
11:53:44 <filcab42> ups
11:53:45 <dmhouse> ?instances Ix
11:53:46 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
11:53:46 <filcab42> sorry
11:53:52 <dmhouse> ?instances-importing Data.Array Ix
11:53:54 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
11:55:19 <filcab42> wtf?
11:55:30 <filcab42> now it gives wrong answers :s
11:57:11 <hpaste>  filcab annotated "program" with "using an array" at http://hpaste.org/232#a1
11:57:20 <filcab42> shouldn't it work like before?
11:59:28 <petekaz> > foldl ($) 1 [(+1), (+2)]
11:59:29 <lambdabot>      Occurs check: cannot construct the infinite type: b = a -> b
11:59:29 <lambdabot>     Probabl...
12:00:10 <Saizan> > foldl (flip id) 1 [(+1), (+2)]
12:00:11 <lambdabot>  4
12:00:25 <petekaz> dons uses foldl in his last xmonad/zipper article like this ... why does his work?
12:00:54 <petekaz> http://cgi.cse.unsw.edu.au/~dons/blog/2007/05/17
12:00:54 <lambdabot> Title: Haskell hacking
12:00:59 <Saizan> > foldr ($) 1 [(+1), (+2)]
12:01:00 <lambdabot>  4
12:01:08 <sjanssen> @type flip id
12:01:10 <lambdabot> forall b c. b -> (b -> c) -> c
12:01:13 <petekaz> search for 'foldl' in his article.
12:01:39 <sjanssen> @type ($)
12:01:41 <lambdabot> forall a b. (a -> b) -> a -> b
12:01:49 <sjanssen> @type flip ($)
12:01:50 <lambdabot> forall a b. a -> (a -> b) -> b
12:01:58 <sjanssen> petekaz: does that clear it up?
12:02:00 <petekaz> In any case, my next question, how is that different than just doing: (+2) $(+1) 1  ...
12:02:19 <petekaz> sjanssen: yes, but is dons example wrong then?
12:02:26 <petekaz> I doubt it.
12:02:27 <sjanssen> petekaz: it isn't, really
12:02:51 <sjanssen> petekaz: the example is fine
12:03:27 <Saizan> sjanssen: dons has foldl ($) s [delete, view n, ...]
12:03:43 <Saizan> he's probably missing a flip?
12:03:46 <sjanssen> ah
12:04:01 <Saizan> s :: StackSet a
12:04:09 <sjanssen> yes, that should either be flip $ or a foldr
12:04:13 <petekaz> ahhh ...
12:04:20 <petekaz> I thought I was going nutz.
12:05:17 <sjanssen> foldr ($) s [view (tag (workspace (current s))),insertUp w,view n,delete w] -- the actual code
12:05:21 <petekaz> Ok, so that clears that part up.  As for using foldl vs just using x $ y $ z, just to illustrate a point?
12:05:32 <petekaz> sjanssen: Yeah, I'm reading the blog article.
12:05:35 <sjanssen> I'm not sure about that one
12:05:53 <fasta> Is a redundant return () optimized away?
12:05:56 <sjanssen> I'd say the explicit $ are more clear
12:06:19 <sjanssen> fasta: probably depends on the monad
12:06:50 <Saizan> does the list ever get autogenerated somewhere? maybe he's just keeping consistent with a point where it's useful to use that idiom
12:08:50 <ihope> fasta: putStr foo >> return ()?
12:09:17 <ihope> I guess that's what a redundant return () is.
12:10:00 <Heffalump> you'd expect GHC to have the monad laws as RULEs
12:10:07 <sorear> fasta: What monad?
12:10:15 <fasta> sorear: MonadST
12:10:23 <sorear> fasta: that's not a monad
12:10:40 <fasta> sorear: Ok, a monad based on StateT
12:10:56 <fasta> sorear: with ST as the inner monad.
12:11:28 <fasta> read "based on" as "newtyped"
12:11:32 <sorear> probably "Yes" then
12:21:27 <filcab42> can anyone (try to) help me understand what I did wrong here?
12:21:29 <filcab42> http://hpaste.org/232#a1
12:21:47 <filcab42> I tried to alter my code to use an array instead of a list of lists
12:21:58 <filcab42> but now it's giving me wrong results
12:22:08 <filcab42> and I can't locate the error :s
12:22:34 <filcab42> btw, it should read:       matrix = readMatrix contents n
12:22:34 <filcab42>  
12:22:44 <filcab42> (when copying and pasting I forgot the n
12:24:36 <filcab42> ups
12:24:36 <filcab42> sorry :$
12:25:01 <lispy> :t (:$)
12:25:02 <filcab42> the score function's limits had to be altered
12:25:03 <lambdabot> Not in scope: data constructor `:$'
12:25:08 <filcab42> now it's nice
12:25:09 <filcab42> lol
12:25:25 <filcab42> lispy: just symbol-macrolet it
12:26:17 <lispy> is that something you've defined in your code?
12:26:34 <filcab42> no
12:26:41 <filcab42> it's an embarassed emoticon in MSN messenger
12:26:45 <filcab42> lol
12:26:51 <lispy> oh hmm...
12:26:59 <lispy> i thought it was haskell :)
12:27:16 <Saizan> we could use it as sanely associative $
12:28:17 <sorear> @quote smil
12:28:17 <lambdabot> dons says: The "I'm swallowing TaPL smiley" :[]
12:28:18 <lispy> Saizan: i think any operator starting with : has to be a constructor
12:28:23 <sorear> @quote smil
12:28:23 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
12:28:26 <sorear> @quote smil
12:28:26 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
12:28:27 <sorear> @quote smil
12:28:28 <lambdabot> Failure02 says: in haskell you can have korean smilies as variables! like (^-^)
12:28:34 <dmhouse> Saizan: why is ($) not sanely associative?
12:28:37 <sorear> @quote emot
12:28:38 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean
12:28:38 <lambdabot> I'll keep doing what I'm doing." ;)
12:28:40 <sorear> @quote emot
12:28:41 <lambdabot> SyntaxNinja says: You'd be surprised how hard is to hire haskellers :( They're all like, "Yeah, I'll come work for you, and by 'come' I mean stay here and work remotely and by 'work for you' I mean
12:28:41 <lambdabot> I'll keep doing what I'm doing." ;)
12:28:56 <lispy> dmhouse: it's left associatitive instead of right, iirc
12:29:07 <lispy> dmhouse: and that leads to those weird places where you can't use ($)
12:29:08 <sorear> lispy: backward
12:29:16 <dmhouse> For example?
12:29:41 <lispy> i forget the example now...but i've seen some pretty good justification for it being a bit broken at the moment
12:29:42 <dmhouse> > odd $ succ $ 3 -- this wouldn't work if ($) were left-associative.
12:29:43 <lambdabot>  False
12:29:56 <Saizan> dmhouse: but there you should use .
12:30:01 <Saizan> > odd . succ $ 3
12:30:02 <lambdabot>  False
12:30:20 <dmhouse> Fair enough, but I'm yet to see anywhere where you can't use ($).
12:30:25 <Saizan> > (+) $ 1 $ 2 -- doesn't work
12:30:26 <lambdabot>   add an instance declaration for (Num (a -> b))
12:30:44 <dmhouse> I see.
12:30:50 <Saizan> (imagine 1 and 2 to be something less trivial)
12:30:56 <dmhouse> Yeah, that makes sense.
12:31:57 <Saizan> it's even more annoying with $!
12:32:05 <lispy> > let (-$) = ($); infixl -$ in (+) $ 1 $ 2
12:32:05 <lambdabot>   add an instance declaration for (Num (a -> b))
12:32:10 <lispy> > let (-$) = ($); infixr -$ in (+) $ 1 $ 2
12:32:11 <lambdabot>   add an instance declaration for (Num (a -> b))
12:32:22 <lispy> i guess that infix is ignored there?
12:32:25 <dmhouse> Err, I don't think you can do infixity declarations there.
12:32:32 <Saizan> > let (-$) = ($); infixl -$ in (+) -$ 1 -$ 2
12:32:33 <lambdabot>  3
12:32:40 <lispy> duh thanks
12:32:43 <lispy> :)
12:32:53 <opqdonut> :D
12:32:55 <defcons> hello
12:33:06 <defcons> who has read programming in haskell?
12:33:44 <Lemmih> defcons: Is that a book?
12:33:55 <emu> i have read programs in haskell
12:33:56 <defcons> yes
12:34:09 <defcons> emu, would you recommend it above other haskell books?
12:34:13 <Saizan> there's a review on TMR issue 7
12:34:18 <dmhouse> Lemmih: it's Hutton's, I think.
12:34:20 <Korollary> http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_bbs_sr_1/103-5945812-5628628?ie=UTF8&s=books&qid=1181417606&sr=8-1
12:34:24 <lambdabot> http://tinyurl.com/24zss2
12:34:26 <defcons> Saizan, sorry?
12:34:38 <lispy> TMR = the monad reader
12:34:38 <dmhouse> ?wiki The Monad Reader
12:34:38 <lambdabot> http://www.haskell.org/haskellwiki/The_Monad_Reader
12:34:39 <emu> i haven't read _Programming in Haskell_
12:34:58 <Saizan> defcons: follow the link :)
12:35:05 <dmhouse> http://www.haskell.org/haskellwiki/The_Monad.Reader
12:35:06 <lambdabot> Title: The Monad.Reader - HaskellWiki
12:35:10 <dmhouse> Follow that link :)
12:35:21 <emu> the yellow brick link
12:35:22 <defcons> cheers
12:35:32 <roconnor> @seen ibid
12:35:33 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
12:35:55 <filcab42> I have a list (e.g: [1,2,3,4,2,1,2])
12:35:58 <defcons> "there is currently no text in this page"
12:36:04 <filcab42> how can I know in which positions I have the minimum?
12:36:04 <dmhouse> defcons: try http://www.haskell.org/haskellwiki/The_Monad.Reader
12:36:06 <lambdabot> Title: The Monad.Reader - HaskellWiki
12:36:25 <defcons> thanks
12:36:42 <filcab42> I could get the minimum, zip it with [1..] and filter it
12:36:54 <dmhouse> let minIndices = findIndices . minimum in minIndices [1,2,3,4,2,1,2]
12:37:00 <dmhouse> > let minIndices = findIndices . minimum in minIndices [1,2,3,4,2,1,2]
12:37:01 <lambdabot>   add an instance declaration for (Num (a -> Bool))
12:37:01 <lambdabot>     In the expression: 2
12:37:03 <filcab42> but that would be traversing the list 3 times
12:37:20 <Saizan> only 2
12:37:37 <filcab42> findIndices?
12:37:40 <Korollary> Its Table of Contents doesn't impress me
12:37:47 <filcab42> oh
12:37:48 <filcab42> nice
12:38:32 <dmhouse> > let minIndices xs = findIndices (== minimum xs) xs in minIndices [1,2,3,4,2,1,2]
12:38:34 <lambdabot>  [0,5]
12:38:52 <dmhouse> ?pl minIndices xs = findIndices (== minimum xs) xs
12:38:53 <lambdabot> minIndices = findIndices =<< (==) . minimum
12:39:09 <Saizan> > fst . minimumBy (comparing snd) . zip [0..] $ [1,2,3,4,2,1,2]
12:39:09 <filcab42> ?
12:39:09 <filcab42> Prelude> :t findIndices
12:39:10 <lambdabot>  0
12:39:10 <filcab42> ERROR - Undefined variable "findIndices"
12:39:10 <filcab42> Prelude>
12:39:21 <dmhouse> filcab42: :m Data.List
12:40:05 <filcab42> thanks
12:40:12 <ibid> lambdabot: i spoke just now :)
12:40:33 <Saizan> @seen ibid
12:40:33 <ibid> roconnor: ?
12:40:33 <lambdabot> ibid is in #haskell. I last heard ibid speak 21s ago.
12:42:15 <fasta> Hmm, my assertions take more space than the actual code...
12:44:21 <SamB> say... is GHC's ReadPrec system, or something like it, being considered for Haskell'?
12:46:28 <lispy> SamB: good question...
12:46:43 <lispy> SamB: seems like there was some discussion about that at the Haskell-Workshop last year
12:46:53 <lispy> but i can't remember what was decided
12:49:04 <filcab42> how can I know in which operation I have an "Error in array index"?
12:49:52 <edwardk> filcab: laborious effort? =)
12:50:02 <filcab42> lol
12:50:13 <Korollary> Debug.Trace
12:50:16 <SamB> lispy: there aren't any extensions needed besides the fact that Prelude would depend on this, are there?
12:50:19 <filcab42> I can't even do prints here or there because then I would have to return from everywhere
12:50:27 <Korollary> I am a psychic
12:50:48 <Saizan> ?type Debug.trace
12:50:53 <lispy> SamB: maybe i misunderstood the question...i'm was thinking of someone asking for the Read/Show to be replaced with real parsers...
12:50:56 <lambdabot> Couldn't find qualified module.
12:51:04 <SamB> lispy: yes.
12:51:08 <Saizan> ?hoogle trace
12:51:08 <lambdabot> Debug.Trace.trace :: String -> a -> a
12:51:08 <lambdabot> Debug.Trace :: module
12:51:08 <lambdabot> Debug.Trace.putTraceMsg :: String -> IO ()
12:51:18 <SamB> but, you could still keep the old way...
12:51:38 <edwardk> filcab: you can always cheat and unsafePerformIO the putStrLn's if you really want to
12:51:52 <Korollary> or use Debug.Trace.trace
12:51:54 <SamB> ... I mean, import Text.Read and then do :i Read
12:51:56 <edwardk> ya
12:51:57 <Saizan> filcab42: you can use that for debugging purposes, it'll print the string when it's forced
12:53:05 <roconnor> ibid: I have a new blog feed
12:53:07 <Sgeo> > topic ++ show topic where topic = "[Quine Area] This is the current topic as a Haskell string: topic ++ show topic where topic =
12:53:07 <lambdabot>  Parse error
12:53:10 <Korollary> Why can't we catch an array bound violation?
12:53:13 <Sgeo> topic ++ show topic where topic = "[Quine Area] This is the current topic as a Haskell string: topic ++ show topic where topic = "
12:53:18 <roconnor> ibid: http://r6.ca/blog/feed.atom
12:53:21 <Heffalump> at compile time or runtime?
12:53:22 <Sgeo> > topic ++ show topic where topic = "[Quine Area] This is the current topic as a Haskell string: topic ++ show topic where topic = "
12:53:22 <lambdabot>  Parse error
12:53:25 <Korollary> at runtime
12:53:31 <Korollary> It would be nice to have it in the api
12:53:35 <SamB> lispy: or, um, look at
12:53:40 <SamB> @doc Text.Read
12:53:40 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
12:53:42 <Heffalump> I thought readArray does check that?
12:54:16 <SamB> lispy: notice the two methods that are for GHC only?
12:55:13 <Korollary> readArray is for MArray's
12:55:15 <Korollary> hmm
12:55:18 <Saizan> Korollary: you have to use catch in IO if you don't want to represent possibile failure in the type of !
12:56:06 <Saizan> ?type readArray
12:56:08 <lambdabot> Not in scope: `readArray'
12:56:24 <Saizan> ?type Data.MArray.readArray
12:56:25 <lambdabot> Couldn't find qualified module.
12:56:53 <lispy> SamB: interesting
12:57:01 <lispy> SamB: well, it would be nice if that went into Haskell'
12:59:25 <hpaste>  SamB pasted "Arith.hs" at http://hpaste.org/233
12:59:52 <hpaste>  SamB annotated "Arith.hs" with "strange error" at http://hpaste.org/233#a1
13:00:14 <jf_> ?type Data.Array.MArray.readArray
13:00:16 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Ix i, Data.Array.Base.MArray a e m) => a i e -> i -> m e
13:00:30 <lispy>   43      signum   0  = 0
13:00:30 <lispy>   44      signum (-0) = 0
13:00:54 <lispy> SamB: why do you have 0 and negative 0?
13:01:24 <ibid> roconnor: please email these stuff, i rarely have the time to do stuff immediately and irc is bad at queuing :)
13:01:28 <SamB> lispy: because that's how PDP-1 words work
13:01:30 <lispy> SamB: and shouldn't you need that P1 constructor?
13:01:56 <lispy> SamB: then won't you need a way to represent that? I don't think Haskell's number system, at least with Words supports negative 0
13:02:12 <SamB> lispy: sure
13:02:33 <SamB> -0 is represented by 0o777777
13:02:44 <lispy> octal?
13:02:49 <SamB> yeah
13:03:13 <lispy> SamB: but you see why the pattern is overlapped now, right?
13:03:26 <lispy> seems like it should be a type error though
13:03:28 <SamB> because GHC isn't very smart?
13:03:37 <lispy> 0 isn't a Pdp1Word
13:03:48 <lispy> so i'm a little confused that it even lets you write signum 0 = 0
13:03:51 <SamB> sure it is
13:03:53 <Saizan> well 0 can be equal P1 x
13:03:56 <SamB> @type 0
13:03:58 <lambdabot> forall t. (Num t) => t
13:04:06 <lispy> oh hm...interesting
13:04:13 <lispy> :t 1
13:04:15 <lambdabot> forall t. (Num t) => t
13:04:25 <SamB> I don't understand why (-0) is in the warning, and P1 x is, but not 0
13:04:52 <lispy> -0 and P1 x overlap with 0
13:05:18 <lispy> :t fromIntegral
13:05:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:05:23 <SamB> @type let f (-0) = "hi!" in f
13:05:24 <lambdabot> forall t. (Num t) => t -> [Char]
13:05:36 <lispy> so how does haskell convert 0 to an instance of your num?
13:05:50 <Saizan> ?type fromInteger 0
13:05:52 <lambdabot> forall a. (Num a) => a
13:06:11 <Saizan> that way
13:06:22 <lispy> > let f 0 = "zero"; f (-0) = "negative zero" in f (-0)
13:06:23 <lambdabot>      Warning: Pattern match(es) are overlapped
13:06:23 <lambdabot>              In the definition...
13:06:28 <sjanssen> SamB: there are some bugs in the overlap checker, you must be observing those
13:09:06 <SamB> hmm, I think this class of warning needs to be made more clear in general
13:09:16 <lispy> i would assume that with that pattern written like that, that it would compute (-0) as 0 and then call fromInteger with 0
13:10:17 <lispy> > let foo 0 = "zero"; foo (negate (fromInteger 0)) = "negative zero" in foo (-0)
13:10:17 <lambdabot>  Parse error in pattern
13:11:00 <lispy> SamB: try this: signum 0 = 0; signum (-(P1 0)) = 0
13:11:13 <lispy> does it still overlap?
13:11:26 <SamB> is that even legal?
13:11:40 <lispy> well, if (-0) is, i bet that is
13:12:05 <norpan> won't you get a lot of trouble making a type that has 0 and -0 distinct an instance of Num?
13:12:10 <SamB> lispy: it isn't
13:12:24 <SamB> actually I bet I'm lucky -0 works at all
13:12:25 <Saizan> *Arith> [-0,fromInteger (-0)] :: [Pdp1Word]
13:12:26 <Saizan> [0o777777,0o000000]
13:12:34 <SamB> as a pattern
13:12:41 <Saizan> shouldn't those two be the same?
13:12:42 <lispy> SamB: well, if that's not allowed then i bet signum (-0) has a different meaning than you expected
13:12:45 <Heffalump> norpan: you mean like Float and Double?
13:13:00 <SamB> *Arith> [-0,fromInteger (-0)] :: [Double]
13:13:06 <SamB> er.
13:13:11 <SamB> > [-0,fromInteger (-0)] :: [Double]
13:13:13 <lambdabot>  [-0.0,0.0]
13:13:22 <SamB> Saizan: you mean the way those two are?
13:13:22 <sorear> Saizan: you implemented negate wrong
13:13:24 <DRMacIver> Among the many reasons why floating point arithmetic is evil. :)
13:13:36 <SamB> sorear: no, I implemented it. correctly.
13:13:40 <sorear> Saizan: it needs to be TWOS complement, not ones
13:13:49 <norpan> well, the arithmetic operator laws don't apply on Floats and Doubles either
13:13:51 <SamB> sorear: on the contrary
13:14:15 <Heffalump> DRMaciver: it's just an approximation
13:14:20 <norpan> i think the point is that is IS one complement negation
13:14:24 <Heffalump> no approximation will be numerically perfect
13:14:35 <sorear> hmm.  ok
13:14:39 <DRMacIver> Heffalump: So it's a neccessary evil. It's still evil. ;)
13:14:41 <SamB> DRMacIver: that isn't actually a good reason why it is evil.
13:15:21 <Saizan> *Arith> [-0,-fromInteger 0] :: [Pdp1Word]
13:15:21 <Saizan> [0o777777,0o777777]
13:15:26 <Heffalump> I don't see any particular problem with it, given that (==) is a bad idea on floating point numbers anyway.
13:15:30 <Saizan> this two should and are the same :)
13:15:59 <benny99> DRMacIver: I agree..
13:16:22 <dmhouse> If (==) on floating point numbers is a bad idea, then floating point numbers are a bad idea.
13:16:30 <sorear> Saizan: well, Num is only for rings.  non-rings (that includes you, Double) shouldn't be instances!
13:16:32 <Heffalump> why?
13:16:32 <benny99> dmhouse: no
13:16:33 <SamB> dmhouse: not really
13:16:42 <Heffalump> they are an approximation, infinite precision being infeasible
13:16:44 <SamB> you can still do >
13:16:46 <SamB> or <
13:16:48 <sorear> == is perfectly reasonable on Double
13:16:49 <Heffalump> and checking two approximations for equality is a bad idea
13:16:54 <benny99> sorear: no :( ?
13:17:02 <SamB> sorear: is it ?
13:17:05 <SamB> for what?
13:17:07 <Heffalump> sorear: well, it depends what you want to know..
13:17:08 <sorear> if you don't want to face the facts about rounding, you deserve what you get
13:17:15 <lispy> Heffalump: not just infeasable, undecidable, as i recall
13:17:18 <sorear> SamB: Comparing doubles for equality.
13:17:25 <sorear> SamB: Doubles are not reals.
13:17:35 <SamB> sorear: they have equality. so do reals.
13:17:50 <sorear> SamB: if you're using Double to approximate reals, don't assume Double's == corresponds to real's ==
13:18:02 <SamB> well yeah
13:18:03 <sorear> but they are both perfectly legitimate operations
13:18:06 <Heffalump> especially given that real has no ==, as lispy points out
13:18:12 <Heffalump> at least not a decidable one
13:18:13 <SamB> Heffalump: it has...
13:18:27 <benny99> Floating point and == is a bad idea -- that's it
13:18:29 <SamB> but it can take forever if you have an infinitely long number...
13:18:41 <Heffalump> that sounds undecidable to me...
13:18:58 <SamB> yeah.
13:19:04 <Heffalump> given that you might have a finite representation of said infinitely long number
13:19:06 <sorear> benny99: STM
13:19:11 <benny99> sorear: ?
13:19:19 <Twan> > let ones = 1:ones in ones == ones
13:19:25 <lambdabot> Terminated
13:19:28 <Twan> Same thing
13:19:38 <sorear> benny99: Conservative approximations to equality are better than no approximations at all!
13:19:40 <SamB> but, anyway, in my case I just have two not-equal zeroes
13:19:57 <sorear> SamB: then it's not a monoid, nevermind a ring
13:20:04 <benny99> sorear: yeah, but == is not approximate :|
13:20:09 <SamB> sorear: are you certain?
13:20:12 <Korollary> There's nothing wrong with comparing approximations for equality.
13:20:15 <sorear> benny99: Yes it is
13:20:28 <SamB> I think it is if I use (-0) as the zero for Monoid...
13:20:37 <benny99> sorear: no, it's "perfect"
13:20:44 <Heffalump> the problem is that it's not a very easy to understand conservative approximation
13:21:05 <Heffalump> at least in the sense of understanding when two computations will produce the same bitpattern
13:21:19 <benny99> > -0.0 == 0.0
13:21:20 <lambdabot>  True
13:21:32 <sorear> Heffalump: So benny99's implicit universal qualifier reduces to "people are never careful".
13:21:49 <benny99> =/ ?
13:21:57 <benny99> whatever, I'm gone
13:22:03 <Korollary> understandin whether two integer computations will produce the same bit pattern is also not always trivial.
13:22:21 <Heffalump> I'd be interested to see an example of == being a useful operation on floating point numbers, apart from in cases where you are comparing two implementations for bit-exact equivalence.
13:22:30 <SamB> (nevermind the bogus Enum instance...
13:23:07 <geezusfreeek> Heffalump: maybe you could be testing to see if it is possible that they went through the exact same sequence of operations
13:23:12 <sorear> Heffalump: Memoization - if two numbers are bit-equivalent any function will return the same results
13:23:32 <sorear> Heffalump: no point in calculating both f(1) and f(1 + 10^-100)
13:23:47 <benny99> > (46*23)/23333333 == (23/23333333)*23
13:23:48 <lambdabot>  False
13:23:52 <Korollary> set membership
13:23:55 <opqdonut> Heffalump: well depends
13:23:57 <Heffalump> geezusfreeek/sorear: ok, so there's a whole class of "conservative equality test" type applications
13:23:59 <benny99> I'm dumb -.-
13:24:02 <opqdonut> gah sorry
13:24:10 <opqdonut> sorear: depends on the function :)
13:24:39 <sorear> opqdonut: I said function, not inputting monadic action :)
13:25:42 <benny99> > (23*27)/43123000000000000000 == (23/43123000000000000000)*27
13:25:43 <lambdabot>  True
13:25:57 <benny99> I'm sorry ._., ghci says false, I'm gone
13:27:51 <SamB> sorear: which monoid do you claim is not formed?
13:28:24 <sorear> (WordWithNEPlusAndMinusZero, +, 0)
13:28:29 <sorear> and erm, only group
13:28:32 <sorear> monoid is fine
13:29:18 <Heffalump> which 0?
13:29:24 <SamB> try
13:29:26 <Heffalump> or is that your point about why it's not a group?
13:29:29 <SamB> (WordWithNEPlusAndMinusZero, +, -0)
13:30:19 <SamB> Heffalump: would be a pretty silly reason to say it isn't a group
13:30:20 <sorear> Heffalump: Right.  Groups have 1 zero
13:30:43 <Heffalump> SamB: not really, as sorear says
13:30:47 <sorear> Z1 + -Z2 = -Z2 = Z2 = Z1 + -Z1
13:30:48 <Heffalump> though IIRC that's not one of the group axioms
13:30:58 <Heffalump> it's just that you will find that inverses don't work in any "group" that has multiple zeros
13:30:58 <sorear> Heffalump: no, it's a theorem :)
13:31:20 <SamB> sorear: why couldn't you have two groups, with different identity elements, with the same set and operation?
13:31:42 <Heffalump> because "identity element" is something you can infer from the operation
13:31:47 <sorear> SamB: Because then you could:
13:31:53 <Heffalump> if E + x = x forall x, then E is an identity
13:31:58 <sorear> zero1 = zero1 + zero2 = zero2
13:32:09 <sorear> SamB: ^^^ proving zero1 = zero2
13:32:18 <SamB> sorear: okay.
13:32:21 <SamB> point
13:32:43 <Heffalump> oh yes, it's just a logical impossibility to have multiple zeros :-)
13:32:46 <SamB> so 0 isn't actually a zero...
13:32:52 <Heffalump> > 0.0
13:32:54 <lambdabot>  0.0
13:32:57 <Heffalump> > -0.0
13:32:58 <lambdabot>  -0.0
13:33:02 <Heffalump> > 0.0 + (-0.0)
13:33:03 <lambdabot>  0.0
13:33:08 <SamB> in floating, sure
13:33:10 <Heffalump> > (-0.0) + (-0.0)
13:33:11 <lambdabot>  -0.0
13:33:15 <Heffalump> > (-0.0) + 0.0
13:33:15 <lispy> > 1.0 + (-0.0)
13:33:17 <lambdabot>  0.0
13:33:17 <lambdabot>  1.0
13:33:40 <SamB> Prelude Arith> 0-0 :: Pdp1Word
13:33:40 <SamB> 0o777777
13:33:42 <Heffalump> hmm, so -0.0 is actually an identity and 0.0 isn't
13:34:10 <bartw> auch
13:34:24 <SamB> hmm, wait, which one is zero then...
13:34:33 <SamB> I guess it is 0
13:34:43 <Heffalump> no, it's -0, at least in Double
13:34:46 <lispy> > 0.0 == (-0.0)
13:34:47 <lambdabot>  True
13:34:58 <SamB> in Pdp1Word, 0 seems to be it
13:35:03 <Heffalump> that (==) is broken.
13:35:12 <sorear> Heffalump: eh?
13:35:14 <SamB> mine is not
13:35:15 <benny99> Heffalump: yeah :o
13:35:30 <Heffalump> well, ok, it's not broken, but it's not bit-comparison
13:35:30 <SamB> Heffalump: well, that one is made for convenience
13:35:33 <benny99> ghci gives me other results
13:35:40 <sorear> Heffalump: the Report only says == has to be an equivalence relation, and quotient preserves that
13:35:41 <SamB> bit-comparison isn't the best way
13:35:49 <Heffalump> yes, fair enough
13:35:56 <SamB> always
13:36:02 <SamB> for instance, what about Data.Map
13:36:26 <Heffalump> what about it?
13:36:37 <Heffalump> oh, the trees might not be similarly balanced?
13:36:40 <sorear> SamB: Obviously, maps should be normalized continuously with a perfect balance mechanism!
13:36:43 <SamB> exactly
13:36:44 <Heffalump> but that's not observable
13:36:46 <lispy> > 0.0 `xor` (-0.0)
13:36:46 <lambdabot>  Add a type signature
13:37:05 <lispy> why does double have no Bits instance?
13:37:15 <lispy> > 0.0 `xor` (-0.0) :: Double
13:37:15 <lambdabot>   add an instance declaration for (Bits Double)
13:37:15 <lambdabot>     In the expression: 0.0 `x...
13:37:33 <SamB> lispy: because it doesn't make sense to xor two IEEE floats, certainly not two might-be-IEEE floats
13:38:07 <SamB> but anyway Haskell's numeric hierarchy is not so great
13:38:10 <lispy> well, it makes sense to xor their bitwise representations, because then you'd have a way to fix (==) :)
13:38:13 <sorear> SamB: it doesn't?  there are no invalid ieee bitpatterns
13:38:34 <SamB> sorear: hey, you can't do that in *C*
13:38:35 <sorear> lispy: Nice try, but -0 `xor` 0 = -0 == 0
13:38:48 * sorear type puns SamB
13:39:13 <sorear> oh wait, -0 `xor` 4 = -4 /= 4 = 0 `xor` 4
13:39:15 <SamB> well... I suppose you can do it that way...
13:39:28 <SamB> if you xor the representations one char at a time
13:39:37 <Heffalump> is there a quick way to compare two floats bitwise?
13:39:43 <Heffalump> (short of unsafeCoerce# trickery)
13:39:48 <SamB> memcmp?
13:40:42 <roconnor> > encodeFloat (decodeFloat 0.0 `xor` decoceFloat (-0.0))
13:40:43 <lambdabot>   Not in scope: `decoceFloat'
13:40:48 <roconnor> > encodeFloat (decodeFloat 0.0 `xor` decodeFloat (-0.0))
13:40:49 <lambdabot>  Couldn't match expected type `Integer'
13:41:18 <whitenoyce> what is the standard text editing, program writing environment that haskellers commonly use?
13:41:21 <whitenoyce> is vim ok?
13:41:25 <sorear> vim is ok
13:41:34 <sorear> vim and emacs are commonly used
13:41:41 <whitenoyce> i'm learning haskell and don't want to screw up in the beginning by using vim
13:41:42 <sorear> gedit is seen fairly often
13:41:47 <whitenoyce> like i did with lisp
13:41:53 <sorear> ed and yi are seen occasionally :)
13:42:06 <sorear> whitenoyce: vi can edit lisp just fine
13:42:16 <Heffalump> decodeFloat produces the same result
13:42:25 <Heffalump> SamB: memcmp is an unsafeCoerce# trick :-)
13:42:45 <Heffalump> whitenoyce: I use xemacs.
13:42:48 <lispy> > (decodeFloat 0.0, decodeFloat (-0.0))
13:42:49 <lambdabot>  ((0,0),(0,0))
13:42:53 <Heffalump> or Visual Haskell at work, sometimes
13:43:17 <lispy> visual haskell gets slow on large files, but it's pretty nice otherwise
13:43:21 <roconnor> @pl \(a,b) (c,d) -> (a `xor` c,b `xor` d)
13:43:21 <lambdabot> uncurry (flip flip snd . (ap .) . flip flip fst . ((.) .) . (. xor) . flip . (((.) . (,)) .) . xor)
13:43:28 <lispy> :t decodeFloat
13:43:30 <lambdabot> forall a. (RealFloat a) => a -> (Integer, Int)
13:43:37 <sorear> roconnor: join(***)xor
13:43:47 <sorear> roconnor: @pl doesn't grok *** yet
13:44:09 <roconnor> > let xor2 = join (***) xor in encodeFloat (decodeFloat 0.0 `xor2` decodeFloat (-0.0))
13:44:09 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
13:44:23 <lispy> why does 0.0 and (-0.0) decode the same?
13:44:26 <Heffalump> I'm not sure about "very nice". It's rather flakey.
13:44:27 <roconnor> > let xor2 = xor (***) xor in encodeFloat (decodeFloat 0.0 `xor2` decodeFloat (-0.0))
13:44:27 <lambdabot>      Occurs check: cannot construct the infinite type: b = (b, b)
13:44:28 <lambdabot>       Expec...
13:44:42 <Heffalump> lispy: because decodeFloat is transforming to Integer where 0 really is -0..
13:44:44 <lispy> Heffalump: ah, well VS is rather flakey too
13:44:53 <sorear> whitenoyce: what do you mean vim ruins lisp?
13:45:04 <roconnor> > let xor2 = xor *** xor in encodeFloat (decodeFloat 0.0 `xor2` decodeFloat (-0.0))
13:45:05 <lambdabot>  Couldn't match expected type `(Integer, Int) -> Integer'
13:45:09 <lispy> ?hoogle decodeFloat
13:45:09 <lambdabot> Prelude.decodeFloat :: RealFloat a => a -> (Integer, Int)
13:45:51 <lispy> > (-1)**0
13:45:52 <lambdabot>  1.0
13:46:09 <lispy> > (-1)**(-0)
13:46:10 <lambdabot>  1.0
13:46:19 <lispy> it seems that -0 behaves the same as 0
13:46:27 <lispy> with that one exception earlier
13:46:33 <lispy> > 0.0 + (-0.0)
13:46:35 <lambdabot>  0.0
13:46:42 <dolio> > 1/(-0.0)
13:46:43 <lambdabot>  -Infinity
13:46:44 <Heffalump> like, it having a different representation, different behaviour with show, etc?
13:47:16 <roconnor> @ type xor *** xor
13:47:23 <roconnor> @type xor *** xor
13:47:25 <lambdabot> forall a a1. (Bits a, Bits a1) => (a, a1) -> (a -> a, a1 -> a1)
13:48:10 <roconnor> @type (***) (xor *** xor)
13:48:11 <lambdabot> forall a a1 b' c'. (Bits a, Bits a1) => (b' -> c') -> ((a, a1), b') -> ((a -> a, a1 -> a1), c')
13:50:24 <roconnor> > let xor2 (a,b) (c,d) = (a `xor` c,b `xor` d) in encodeFloat (decodeFloat 0.0 `xor2` decodeFloat (-0.0))
13:50:25 <lambdabot>  Couldn't match expected type `Integer'
13:50:26 <whitenoyce> well i had a hard time using lisp with vim
13:50:35 <whitenoyce> and talking to #lisp i was made to believe that vim was the problem
13:51:05 <lispy> ah yes, but actually #lisp is the problem
13:51:18 <lispy> they probably recommended *shudder* SLIME
13:51:40 <sorear> lispy: Not a lispm emulator with the standard development tools?
13:52:13 <whitenoyce> yeah they did
13:52:16 <lispy> sorear: i don't know where you'd find that, but it could be cool
13:52:38 <lispy> people there have put a lot of effort into SLIME, but IMO, it's just annoying and gets in the way
13:52:58 <lispy> it's remarkable what they've done, but alas i found it annoying
13:53:35 <petekaz> what is the sequence idiom to map a list of functions over a single arg?
13:53:44 <petekaz> sorta the inverse of map?
13:53:52 <whitenoyce> lispy, what do you use for lisp & haskell?
13:54:26 <lispy> one problem with dynamic languages like lisp is that during development you keep changing things, renaming functions, changing parameter types, etc but the image keeps those definitions unless you overwrite them...so you NEED to restart your lisp interpreter as you refactor or else you run the risk of having the code not work the next time you start a session with ith
13:54:55 <lispy> whitenoyce: i really like emacs + interpreter, i don't normally integrate them into the same process...just run them in different windows
13:55:16 <sorear> > map ($ 2) [negate, recip, (+1)]
13:55:17 <lambdabot>  [-2.0,0.5,3.0]
13:55:21 <sorear> petekaz: ^^^
13:55:46 <lispy> whitenoyce: haskell-mode is good if you use emacs
13:56:06 <lispy> whitenoyce: what platforms will you develop on? windows? mac? linux/freebsd? more than one?
13:56:07 <SamB> lispy: I suppose you won't think much of shim, either, eh?"
13:56:17 <lispy> SamB: i haven't heard of shim
13:56:20 <whitenoyce> linux primarily
13:56:32 <SamB> it's supposed to do approximately the same thing for Haskell
13:56:39 <SamB> (though I suppose there's much less to do)
13:56:40 <sorear> @seen beschmi
13:56:40 <lambdabot> I haven't seen beschmi.
13:56:41 <whitenoyce> been using vim since day one, well actually day 2, i started with nano
13:56:41 <lispy> whitenoyce: i'd go with emacs, but i don't know vim at all...i know vim tends to have the best syntax coloring though
13:56:55 <SamB> and of course, to do it for Haskell, you need to use non-portable APIs...
13:56:55 <whitenoyce> i don't use syntax coloring hehe
13:56:59 <petekaz> sorear: I found the sequence version too ... sequence [(+1), (+2)] $ 1
13:57:07 <sorear> yup.
13:57:33 <petekaz> sorear: but I have absolutely no idea why that works due to the type of sequence.  it doesn't make any sense.
13:57:39 <petekaz> @type sequence
13:57:41 <lambdabot>     Ambiguous occurrence `sequence'
13:57:41 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
13:57:50 <lispy> SamB: it might be okay with Haskell. Some of the problems with SLIME is that it adds hooks to the interpreter so that when you get a backtrace it's never accurate, and it makes it painfully slow to restart the interpreter, which isn't as big of a deal in Haskell since :r dumps the old memory image and starts over
13:57:59 <whitenoyce> i'm just used to the vim keyboard mappings
13:58:30 <lispy> whitenoyce: syntax coloring is actually pretty helpful...helps you visually focus on the important bits
13:58:48 <Heffalump> petekaz: that's just the Monad instance for a ->, isn'it it?
13:59:29 <whitenoyce> i don't know it distracts me
14:00:06 <whitenoyce> now what IS cool, is autocompletion with autohelp built in
14:04:18 <lispy> SamB: i also found that SLIME made the interaction less robust...because now you didn't just have bugs in emacs and bugs in the compiler, you now had to deal with the least common denominater of the union of the bugs in those three
14:04:18 <whitenoyce> more like auto-suggestion
14:04:18 <petekaz> Based on this email thread I'm reading, it seems so.  But I'm a newbie and a -> means nothing to me.  I found a link to a paper that I'm hoping will clear things up.
14:04:18 <SamB> lispy: how do you take a least common denominator of a set?
14:04:18 <lispy> whitenoyce: haskell-mode can provide type signatures for standard functions in the emacs modeline
14:04:18 <lispy> SamB: i didn't mean it literally, just using the terms to get my point across... :)
14:04:18 <Heffalump> petekaz: look up the Reader monad
14:04:18 <sorear> lispy: shim can do it for ALL functions!
14:04:18 <lispy> sorear: awesome, i'll google it
14:04:18 <sorear> but I eventually decided it wasn't useful and ditched it
14:04:18 <SamB> @go shim trac
14:04:18 <lambdabot> http://swik.net/GHC?popular
14:04:18 <lambdabot> Title: The Glasgow Haskell Compiler - SWiK
14:04:18 <SamB> hmm.
14:04:18 <sorear> @wwhere shim
14:04:18 <lambdabot> http://shim.haskellco.de/trac/
14:04:18 <lispy> does it use ghc api
14:04:18 <lispy> ?
14:04:18 <SamB> yeah
14:04:18 <petekaz> Heffalump: I found some functional pearl paper on applicative programming.  I didn't see anything on the Reader monad docs that explains this.
14:04:18 <DRMacIver> Hm
14:04:18 <DRMacIver> Haskell makes my head hurt sometimes.
14:04:37 <lispy> does it use make or does it try to compile things?
14:04:39 <DRMacIver> It's like we've taken all the boring, tedious but easy parts of normal programming and in their place have raised up the most insane concoction of categorical nonsense that somehow does exactly what we want it to.
14:04:52 <Heffalump> DRMacIver: great, isn't it?
14:04:59 <lispy> i wolud want to use it with darcs, but darcs has a rather involved build process for a haskell program
14:05:18 <lispy> (basically just meaning you need to use the makefile due to all the options that need passed around)
14:05:18 <DRMacIver> "Why would you ever use a loop when you could use quasi-piadic dual cococofunctors??"
14:05:37 <Philippa> is that like a chocolate cofunctor?
14:06:06 <DRMacIver> Heffalump: It's locally great, but every now and then I step back and think "Oh my god, what madness is this? I just want to write code, not prove the Riemann hypothesis!"
14:07:03 <lispy> ?seen beschmi
14:07:03 <lambdabot> I haven't seen beschmi.
14:07:18 <lispy> hmm...
14:07:36 <lispy> not a good sign :)
14:07:51 <lispy> when the author of schim tells you to look for them on freenode but lambdabot doesn't know them...
14:08:24 <lispy> although the name looks familiar to me...so i think lambdabot may be anmensic here
14:08:25 <SamB> lispy: lambdabot gets amnesia from time to tiem
14:08:30 <SamB> yeah.
14:08:47 <SamB> @quote beschmi
14:08:47 <lambdabot> No quotes match. Take a stress pill and think things over.
14:08:51 <SamB> hmm.
14:08:53 <lispy> ?vixen silly old girl
14:08:53 <lambdabot> <undefined>
14:09:07 <lispy> ?vixen right back at you
14:09:07 <lambdabot> <undefined>
14:09:09 <sorear> she's only 5 :)
14:09:10 <SamB> lispy: do you know why it does that?
14:09:21 <sorear> SamB: I do
14:09:26 <lispy> why?
14:09:29 <SamB> lispy: it is because it used the old regex engine
14:09:36 <SamB> and nobody has updated it to use the new one
14:09:47 <lispy> vixen?
14:09:49 <SamB> possibly because everyone is afraid of having to translate all those regexes
14:09:56 <sorear> SamB: the serialization code for Seen has been broken since time immemorial...
14:10:22 <SamB> sorear: I was talking about @vixen saying "<undefined>" no matter what you say
14:11:40 <emu> hm. shouldn't i be able to 'freeze' an MArray inside runST in order to return it?
14:12:30 <sorear> yes
14:14:38 <sorear> or just use runSTArray
14:14:38 <emu> not an option
14:14:38 <emu> runSTArray does work fine, but i need to return some other info too
14:14:38 <emu> so basically i'm arranging: runST (do arr <- newArray ...; arr' <- freeze arr; return (arr', ...))
14:14:38 <emu> i've added an appropriate type sig on the newArray so it knows exactly what it is dealing with
14:14:55 <nn-gentoo_> hi
14:17:39 <emu> ugh, problem turned out to be the existential type variable
14:23:59 <Heffalump> that's not a problem, that's there to stop you leaking stuff :-)
14:26:46 <whitenoyce> so i should be ok to learn & use haskell w/ vim?
14:27:06 <whitenoyce> usually i bind F2 to save and execute the program...
14:27:15 <whitenoyce> in perl, python, bash, c, etc.
14:27:23 <whitenoyce> i suppose that works for haskell right?
14:27:24 <DRMacIver> I use Haskell with vim, but I must admit I don't do so especially intelligently. :)
14:28:36 <whitenoyce> the thing that confuses me is that hugs won't do functions
14:29:22 <DRMacIver> Hugs and GHCI are not proper repls. The code you enter there is closer to what you'd write inside a do block than it is to what you'd write in a source file.
14:29:39 <DRMacIver> (Well, do blocks are in source files, but you know what I mean)
14:30:59 <whitenoyce> apt-get install ghc
14:31:05 <whitenoyce> You are about to do something potentially harmful.
14:31:05 <whitenoyce> To continue type in the phrase 'Yes, do as I say!
14:31:17 <whitenoyce> The following packages will be REMOVED:
14:31:17 <whitenoyce>   build-essential g++ g++-4.1 initrd-tools kernel-image-2.6.8-2-386
14:31:17 <whitenoyce>   kernel-image-2.6.8-2-686 libstdc++6-4.1-dev tzdata util-linux
14:31:23 <whitenoyce> that doesn't look good
14:31:45 <DRMacIver> That's a great error message though. :)
14:32:35 <emu> Heffalump: it's a problem when im not leaking stuff but ghc is too retarded to realize that "s" in two different places is actually the same variable
14:32:46 * whitenoyce puts off learning haskell for another day
14:32:57 <emu> whitenoyce: ghc6
14:33:11 <DRMacIver> whitenoyce: Hugs is a perfectly viable thing to use as well.
14:33:11 <benny99> whitenoyce: what !?
14:33:18 <whitenoyce> emu, i think it is trying to install ghc6
14:33:31 <emu> no, you typed ghc. the package is named ghc6.
14:33:54 <whitenoyce> emu, i know but it defaulted to ghc6
14:34:01 <whitenoyce> apt-get install ghc6 does the same thing
14:34:09 <emu> which distribution is tihs?
14:34:25 <whitenoyce> debian
14:34:31 <whitenoyce> i think testing
14:34:35 <emu> hmm
14:34:57 <benny99> DRMacIver: where you serious about LISP is for AI ? (was that you?) since Haskell appears to be "as good as" LISP
14:35:17 <DRMacIver> It wasn't me, no.
14:35:23 <emu> whitenoyce: can you see which version of ghc6 it is
14:35:28 <emu> whitenoyce: apt-cache show ghc6
14:35:30 <benny99> DRMacIver: and what's your opinion ?
14:35:46 <DRMacIver> LISP is sortof the 'canonical' AI language, but that's historical as much as anything else. I don't know much about the subject, but from what I've seen Haskell seems pretty good for it.
14:36:00 <whitenoyce> Version: 6.6-3
14:36:37 <emu> that's the version in stable too
14:37:25 <DRMacIver> benny99: There's a certain feeling that dynamically typed languages in general and LISP in particular are very good for dealing with poorly specified problems such as those that crop up in AI. I don't know if this is a feeling grounded in reality.
14:37:56 <lispy> you mean classical AI
14:38:00 <SamB> DRMacIver: I think not
14:38:05 <lispy> i doubt much machine learning is done in lisp these days
14:38:16 <SamB> I mean, are my neurons dynamically typed?
14:38:27 <whitenoyce> that's because its mostly done in c++ sadly enough
14:38:39 <emu> whitenoyce: i'd have to suspect some kind of dependency snafu in testing. i don't have a chroot for it though.  i guess i'll check it out later.
14:38:47 <DRMacIver> As I say, it's an area I know very little about. This is all just my general impression. :)
14:38:53 <emu> SamB: are duck neurons duck typed?
14:39:45 <goban> hi, i was reading through a tutorial, and was wondering how you do oo stuff like inheritence
14:39:46 <SamB> emu: no...
14:40:05 <SamB> goban: what is this "inheritance" you speak of ?
14:40:12 <Philippa> SamB: I doubt your neurons are statically typed
14:40:56 <Philippa> goban: we don't, not as such. We can do interface inheritance via typeclasses though, and you can delegate away
14:41:16 <goban> ah ok thanks
14:41:23 <nn-gentoo_> hi sam, do you know any in here i should give a userbin.net account to?
14:41:32 <Philippa> the ongoing lesson with OO is that implementation inheritance is often a liability, anyway - decoupling it from interface inheritance is a good idea
14:42:13 <Philippa> DRMacIver: It's true, but it's not as true as it used to be because statically typed languages are getting better at being highly polymorphic without getting in the way
14:42:38 <DRMacIver> Fair point.
14:42:57 <Philippa> it's also true that higher-order functions or a near equivalent can be a big win in AI code
14:44:01 <DRMacIver> Is there anything for which higher order functions or a near equivalent is *not* a big win?
14:44:10 <nn-gentoo_> im giving out ssh accounts to devs who need a external file storage
14:44:28 <nn-gentoo_> for a project develupment ect
14:44:38 <Philippa> ease of various static analyses
14:45:53 <DRMacIver> I guess I meant from the user rather than implementer point of view, but fair point again :)
14:47:22 <Philippa> DRMacIver: those static analyses tend to translate into understanding about how your code behaves
14:48:19 <goban> DRMacIver, this guy thinks higher order functions SUCK, look at how much better his idea is: http://www.subtextual.org/demo1.html
14:48:20 <lambdabot> Title: Subtext demo
14:48:24 <goban> im jk btw :)
14:49:05 <DRMacIver> Alas, I don't have flash on my machine so cannot get your joke. :)
14:50:23 <benny99> DRMacIver: sorry, was afk for 10min :Z, *reading
14:50:58 <goban> only funny if you can see how bad it is but http://alarmingdevelopment.org/index.php?p=5
14:51:00 <lambdabot> Title: Alarming Development : Manifesto of the Programmer Liberation Front
14:51:13 <bitwiseshiftleft> is dynamic linking possible on Linux?  and if so, how?
14:51:44 <defcons> #linux
14:51:49 <defcons> maybe
14:51:54 <bitwiseshiftleft> er
14:51:59 <benny99> DRMacIver: ah :), I also don't got more than that feeling and wondered if anybody tried something more complicated
14:52:04 <bitwiseshiftleft> sorry.  is dynamically linking haskell programs possible on Linux
14:52:09 <defcons> oh right sorry
14:52:22 <bitwiseshiftleft> yes, obviously dynamic linking is possible on linux :-)
14:52:31 <kaol> @where hs-plugins
14:52:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
14:53:07 <bitwiseshiftleft> that's cool, but it's not exactly what I'm looking for
14:55:04 <bitwiseshiftleft> basically, i'm annoyed that "hello world" compiles to a 364k file, and am curious if it's possible to dynamically link the runtime system.
14:55:21 <bitwiseshiftleft> or to dynamically link haskell packages
14:56:31 <ddarius> Not yet unless things have changed.
14:57:09 <bitwiseshiftleft> m.  any idea if this is going to change in 6.8?
14:57:17 <lispy> so far i don't see how subtext is different than a spreadsheet
14:59:54 <benny99> lol, subtext appears to be super-abstract to me :Z
15:00:38 <benny99> I'm using "lol" already, I should sleep...
15:01:23 <benny99> DRMacIver: night :)
15:01:30 <DRMacIver> night
15:01:42 <Korollary> I lol at your aversion to lol
15:01:53 <defcons> lol
15:01:57 <defcons> ololol
15:02:23 <Jaggederest> heh reading that alarming development thing, seems like they're looking for a 'sufficiently smart IDE' heh
15:02:32 <Jaggederest> ps lulz
15:02:43 <opqdonut> link?
15:02:54 <Jaggederest> http://alarmingdevelopment.org/index.php?p=5
15:02:55 <lambdabot> Title: Alarming Development : Manifesto of the Programmer Liberation Front
15:04:44 <Jaggederest> so he seems to not only want a 'sufficiently smart compiler' but also a 'sufficiently smart IDE'
15:05:01 <Korollary> sufficiently smart developer too?
15:05:06 <bitwiseshiftleft> no, that's the point
15:05:12 <ekidd> Korollary: That's cheating. :-)
15:05:27 <bitwiseshiftleft> the ide and the compiler have to be smart so that the developer doesn't have to be smart
15:05:32 <Jaggederest> no, no, he's from the Java school on that one, must be idiotproof or it sucks
15:05:47 <bitwiseshiftleft> if only java were idiotproof
15:05:49 <DRMacIver> It's nice to hear people say "Terseness is bad".
15:06:05 <Korollary> the ultimate outsourcing.
15:06:15 <DRMacIver> Not because I agree, but because it vindicates my opinions as to what people are actually complaining about. :)
15:06:19 <bitwiseshiftleft> really, i'd think that people in this channel would agree.  wouldn't want our language to be perl, would we?
15:06:29 <Korollary> perl != terse
15:06:30 <Jaggederest> well, it depends, verbosity is bad too. Meaning / character is what's important.
15:06:40 <whitenoyce> could someone tell me which is easiest, easier and easy to learn from lisp, haskell & python?
15:06:56 <Jaggederest> and the accessibility thereof
15:06:58 <ekidd> bitwiseshiftleft: I like some of the new parallel operator syntax in Perl 6. The possibilities for abuse make me pretty happy.
15:07:00 <whitenoyce> throw c in there for fun if you would like
15:07:08 <DRMacIver> Jaggederest: What I mean is that it's often been my impression that the majority of (Java | other braceful OO language) programmers object to doing things which would cause them to write less code.
15:07:10 <bitwiseshiftleft> Korollary: really?  i think perl -pi -e 's/\d+/$&+1/ge' is terse
15:07:12 <MyCatVerbs> whitenoyce: python lisp haskell. C is hard to judge.
15:07:18 <defcons> lisp is terse!
15:07:19 <ddarius> whitenoyce: It depends on where you're coming from
15:07:22 <DRMacIver> Jaggederest: It shows up in a lot of circles, but whenever I call people on this they deny it. :)
15:07:48 <whitenoyce> MyCatVerbs, so i should get a firmer grip on lisp before starting haskell?
15:07:49 <MyCatVerbs> whitenoyce: (python being easiest. C isn't a large language, but it's Hell to work in and has many dark corners.)
15:08:09 <Jaggederest> DRM: they're paid by the line don'cha know ;) it's shannon coding for programming, double redundant
15:08:17 <MyCatVerbs> whitenoyce: I don't know, sorry.
15:08:21 <Philippa> defcons: actually, haskell for the same expression is often terser if you count the parens
15:08:26 <ddarius> Haskell 98 is a pretty simple language and should be easier for someone with no programming experience to deal with.
15:08:27 <bitwiseshiftleft> whitenoyce: you can learn haskell without knowing lisp well; the advanced features of lisp are very different from haskell
15:08:37 * Philippa seconds what ddarius said
15:08:47 <bitwiseshiftleft> however, haskell is definitely harder than python
15:08:57 <Philippa> depends what for
15:09:13 <whitenoyce> yeah i did python for a bit, was a lot of fun to work in, very easy to use
15:09:14 <Philippa> doing IO is slightly trickier to get started with, for example, and there's a different way of thinking
15:09:17 <ddarius> bitwiseshiftleft: For an "experienced" programmer, I'd agree.  For a new programmer, I don't agree.
15:09:19 <Jaggederest> python > ( lisp == haskell) > c
15:09:34 * DRMacIver glares at Jaggederest 
15:09:36 <dmhouse> *Cough*
15:09:40 <defcons> Philippa, are you at Nottingham university?
15:09:43 <MyCatVerbs> Philippa: !!!
15:09:48 --- mode: ChanServ set +o shapr
15:09:52 * shapr looks at Jaggederest 
15:09:55 <yaxu> for python, i'd say learn C first to get the discipline required to make well-structured programs
15:10:00 <DRMacIver> ...
15:10:02 <yaxu> for haskell, i'd say dive straight in
15:10:03 <defcons> hahaha
15:10:06 <MyCatVerbs> Philippa: I would not ever consider "you need to learn a new way of thinking" to be only "slightly" more difficult. :)
15:10:13 <defcons> yaxu, I tried to learn python
15:10:14 <Philippa> defcons: not any more, I'm an official dropout now
15:10:15 <defcons> it got boring
15:10:18 <defcons> then I want to Lisp
15:10:19 <Jaggederest> I'm talking about ease of use, don't get your back up
15:10:24 <defcons> Philippa, why so?
15:10:30 <DRMacIver> MyCatVerbs: I would not consider "you do not need to learn a new way of thinking" to be useful. ;)
15:10:34 --- mode: shapr set -o shapr
15:10:35 <defcons> I'm happy I didn't get set in my ways with imperative languages
15:10:46 <Korollary> Just learn the language.
15:10:48 <Philippa> defcons: semi-long story I've been through in chan a fair few times. You in Nottingham as well?
15:11:17 <defcons> Philippa, I'm in Glasgow . I'm going to start CS + maths in Edinburgh this year
15:11:21 <MyCatVerbs> DRMacIver: true, but that's another thing entirely. And yes, Alan Perlis rules. Any language that doesn't affect the way you think about programming isn't worth learning, etc.
15:11:21 <Philippa> MyCatVerbs: if someone's not a coder, they're going to learn a new way of thinking either way
15:11:26 <defcons> can't wait
15:11:27 <yaxu> defcons: my point was just that python isn't a good first language, but haskell is
15:11:35 <MyCatVerbs> Philippa: that hadn't occurred to me, good point.
15:11:39 <defcons> yaxu, what's good as that second? :)
15:12:03 <yaxu> defcons: i guess the second can be the one you write yourself :)
15:12:16 <DRMacIver> yaxu: s/first // ;)
15:12:18 <ddarius> Actually, I'm not sure that I'd say Haskell is a good first language.
15:12:20 <defcons> no lipsors?
15:12:29 <defcons> :(
15:12:48 <defcons> why ddarius?
15:12:48 <DRMacIver> Haskell would be an interesting first language.
15:12:51 <opqdonut> first i learned perl, it theached me how to think about programming. then i learned c which teached me how to program properly
15:12:58 <DRMacIver> Mainly for the hilarity value when you then tried to learn Java. :)
15:12:59 <Philippa> ddarius: I think it depends significantly on what you want to do. It's not ideal if you want to teach primarily about interacting with the computational ecosystem around a program, you probably want a good OO lang for that
15:13:03 <opqdonut> now i'm learning haskell, which means i've gotta learn everything again :)
15:13:11 <defcons> opqdonut, taught
15:13:23 <Philippa> the last person I threatened to teach it to's done some imperative coding but not so much it's entirely burnt in
15:13:24 <opqdonut> defcons: ouch :(
15:13:24 <ddarius> Philippa: I'm assuming that "learning programming" is what you want to do.
15:13:33 <ddarius> defcons: Because uncontrolled mutable state is something you need to learn to deal with.
15:13:34 <opqdonut> defcons: can't see how that slipped by
15:13:39 <defcons> opqdonut, I say it to help
15:13:47 <Philippa> right. If you can handle the monadic hurdle, I don't see the problem bar perhaps libs
15:13:49 <Jaggederest> yeah you'd be spoiled for anything less high level. God forbid you try to do C... "Where's map?"
15:13:49 <opqdonut> defcons: yeah
15:13:53 <SamB_XP> Philippa: OO is good for interacting with the surroundings?
15:14:05 <DRMacIver> Jaggederest: I really did have that reaction.
15:14:06 <Philippa> SamB_XP: it gives you a consistent model
15:14:23 <Philippa> you're already thinking in terms of stateful things you communicate with
15:14:26 <DRMacIver> Jaggederest: I learned to program in ML then landed in a job programming Java with zero Java experience.
15:14:32 <SamB_XP> I still have that reaction to C. well, more "Where's my monads"...
15:14:42 <defcons> where're my macros?
15:14:44 <Philippa> it's best when you learn it with a notion of message passing
15:14:47 * DRMacIver spent the first 6 months boggling at how primitive the control flow was before he managed to shrug and get on with it.
15:14:48 <defcons> (lisp macros)
15:14:51 <Jaggederest> yeah... that'll hurt your brain. Did you run far, far away?
15:14:54 <ddarius> Erlang might actually be pretty good...
15:14:56 <SamB_XP> "where's my custom numerics that break the rules"...
15:15:04 <defcons> Philippa, did you drop out because it turned into a javaschool?
15:15:11 <DRMacIver> Jaggederest: No, I'm still programming Java, but now I abuse it heavily and make it dance to my whims. :)
15:15:28 <Philippa> defcons: no, it's gone in the opposite direction. Besides, I dropped out this year and started in 2000
15:15:35 <defcons> whoah
15:15:42 <Jaggederest> good, good. I think they should teach an 'abuse of java' class senior year
15:15:46 <DRMacIver> Given sufficient beating you can almost pretend it's a decent OO language.
15:15:47 <Philippa> (and then ran into a bunch of the FoP crew at Fun in the Afternoon in Cambridge)
15:15:54 <defcons> FoP?
15:15:55 <SamB_XP> DRMacIver: they payed you for six months to come to terms with no HOFs?
15:16:14 <SamB_XP> (or monads)?
15:16:20 <Philippa> defcons: the Foundations of Programming research group
15:16:25 <defcons> cool
15:16:26 <DRMacIver> SamB_XP: I was perfectly capable of writing working code while coming to terms with no HOFs. :)
15:16:28 <Jaggederest> http://dis.4chan.org/read/prog/1180896798/
15:16:29 <lambdabot> Title: 4chan BBS - ..and you said java dont curry
15:16:35 <SamB_XP> DRMacIver: oh.
15:16:41 <defcons> C# has anonymous functions I hear
15:17:04 <ddarius> defcons: Yep and C#3.0 will have nicer syntax for them too.
15:17:12 <defcons> I can't wait...
15:17:14 <SamB_XP> yeah. 2.0 has something that sounds like "classes with an anonymous method", 3.0 has lambdas to go with 'em
15:17:24 <Jaggederest> c# is apparently starting to be influenced by a lot of Simon Peyton-Jones' stuff
15:17:25 <ddarius> And you can do crazy things with them that you can't do in Haskell.
15:17:49 <thermoplyae> Is there a function that returns the Cartesian product (in a sense) of two lists?
15:18:09 <ddarius> SamB_XP: You can write 'delegate (int x) { return x + 1; }' in C#2 and 'x => return x + 1' or something like that in C#3
15:18:19 <ddarius> liftM2 (,)
15:18:25 <thermoplyae> sweet
15:18:30 <Korollary> @hoogle [a] -> [b] -> [(a,b)]
15:18:30 <lambdabot> Prelude.zip :: [a] -> [b] -> [(a, b)]
15:18:49 <thermoplyae> zip is not it
15:18:51 <ddarius> The annoying thing is you can't use generators in anonymous functions
15:18:52 <Korollary> thats not zip
15:18:56 <SamB_XP> ddarius: what does the type of that look like?
15:19:01 <defcons> haskell98 does not have zipWith?
15:19:02 <SamB_XP> ddarius: you can't?
15:19:09 <SamB_XP> defcons: sure it does
15:19:14 <defcons> ok
15:19:24 <ddarius> SamB_XP: Not in C#2 at least.  It bit me pretty hard when I was translating HaXML to C#
15:19:24 <DRMacIver> SamB_XP: They certainly didn't expect me to be a top notch coder in the first 6 months, though my learning curve was pretty good. The 6 months was just how long it took for not having HOFs to stop being physically painful. :)
15:19:37 <SamB_XP> DRMacIver: ah.
15:19:46 <ddarius> SamB_XP: For C#2 you have to declare delegate types
15:19:51 <SamB_XP> physically painful, you say?
15:19:56 <Jaggederest> a wee stabbing pain behind the eyes every time you try to use map
15:19:58 <SamB_XP> you weren't up to typing so much?
15:20:12 <DRMacIver> No, it just gave me a headache. :)
15:20:23 <SamB_XP> ah.
15:20:27 <defcons> why don't you all apply to jane street capital?
15:20:34 <DRMacIver> I thought about it.
15:20:38 <SamB_XP> I'm not ready to apply yet.
15:20:40 <Jaggederest> that's where I am with PHP now. stabbing pains
15:20:46 <ddarius> Because I don't like O'Caml and I'm currently employed.
15:20:56 <SamB_XP> they make you program in o'caml?
15:21:00 <DRMacIver> But frankly, writing in a functional language isn't as important to me as working on something I like.
15:21:04 <Jaggederest> Galois up in Portland is where I'm headed, if they'll take me :)
15:21:17 <ddarius> Nor do I necessarily think I'd enjoy it there, but I haven't really looked much.
15:21:22 <Jaggederest> a Haskell shop.
15:21:37 <Korollary> coworkers and management matter more than languages
15:21:41 <SamB_XP> is that where we keep haskell.org?
15:21:48 <Jaggederest> I believe so
15:22:00 <DRMacIver> I mean, I'd much rather work in a functional language than not. But the language is pretty low on the priority list compared to other factors.
15:22:10 <SamB_XP> nice of them to house it ;-)
15:22:12 <Korollary> money matters
15:22:26 <defcons> what if the language were COBOL?
15:22:32 <Korollary> depends on the money
15:22:32 <ddarius> Korollary: Yep. Hating your work but liking your coworkers is much better than hating your coworkers but liking your work unless you never have to deal with your coworkers.
15:22:43 <SamB_XP> defcons: you should tell me, so I can tell my dad, that's what
15:22:47 <Jaggederest> stretching my brain > coworkers > money :)
15:22:54 <defcons> SamB_XP, ?
15:22:55 <Jaggederest> all three is nice though
15:23:07 <SamB_XP> jewelry returns doesn't pay so well
15:23:08 <Korollary> Jaggederest: You have to maintain your coworkers' code. It's not just your brain.
15:23:12 <sorear> re.
15:23:12 <DRMacIver> defcons: Conveniently, any job which involved programming COBOL would fail miserably at all of the other factors which influence me. :)
15:23:28 <ddarius> Jaggederest: You can stretch your brain in your free time and you can only stretch so much.
15:23:35 <SamB_XP> DRMacIver: huh
15:23:43 <ddarius> Your coworkers will still be there after you finish stretching your brain.
15:23:46 <DRMacIver> SamB_XP: Huh?
15:23:53 <Jaggederest> I got a ways to go before I'm overstretched :)
15:23:55 <SamB_XP> well, okay, good save
15:24:09 <SamB_XP> if you prefer that over "huh"
15:24:13 <DRMacIver> Ok. :)
15:24:53 <Jaggederest> ddarius: but I might not still be there after I stop stretching my brain. There's always bigger and better things.
15:25:35 <DRMacIver> I'm with Jaggederest's list.
15:25:51 <DRMacIver> Except that I add an item on the left. "Opportunities for world domination"
15:26:14 <Jaggederest> well, no doubt, but that's kind of a free time thing for me
15:26:24 <SamB_XP> DRMacIver: I don't want those
15:26:24 <Philippa> sufficient money is important
15:26:40 <SamB_XP> because I'm pretty sure if you do that, they expect you to make a lot of boring decisions
15:26:52 <ddarius> Whether I want it or not, opportunities for world domination is at the top of the aspects of my particular occupation.
15:27:03 <DRMacIver> ddarius: What's your particular occupation?
15:27:04 <whitenoyce> could lisp remove all the parentheses and replace them with notation like this? http://en.wikibooks.org/wiki/Haskell/Understanding_monads
15:27:04 <Philippa> yeah, the world makes for a rather demanding sub
15:27:19 <ddarius> DRMacIver: I'm a member of the United State military.
15:27:22 <SamB_XP> world domination leaves you with too much work
15:27:25 <DRMacIver> ddarius: Ah.
15:27:29 <Jaggederest> I have a woman who works (to me) boring jobs who makes the 'sufficient' money. I make the 'ooh shiney' money :)
15:27:43 <DRMacIver> ddarius: In what capacity, if I may ask?
15:27:49 <ddarius> I'm a programmer.
15:27:51 <SamB_XP> ddarius: technically the military isn't supposed to be in the business of world domination...
15:27:51 <Korollary> He peels potatoes
15:27:57 <xian> whitenoyce: yes.
15:28:00 <Jaggederest> are you an army of one?
15:28:09 <bitwiseshiftleft> whitenoyce: yes and no.  $ doesn't get rid of all your parentheses
15:28:10 <DRMacIver> ddarius: Ah, so you're not a marine who happens to study Haskell in his spare time. :)
15:28:22 <ddarius> I don't do Haskell on the job.
15:28:29 <DRMacIver> I figured.
15:28:53 <DRMacIver> But "Programmer who studies Haskell in his spare time" is less of a leap than "Marine who studies Haskell in his spare time"
15:29:02 <whitenoyce> bitwiseshiftleft, why not?
15:29:03 <bitwiseshiftleft> and LISP certainly would have fewer parentheses if it allowed infix ops.  but part of the point of lisp is its ridiculously simple syntax
15:29:14 <ddarius> Jaggederest: Those commercials are highly inaccurate.  Having a "battle buddy" is an important aspect of the Army, so it should be an "Army of Two"
15:29:14 <Jaggederest> oh man the mental image of a marine infantryman studying haskell in his spare time... talk about a violation of expectations
15:29:27 <bitwiseshiftleft> whitenoyce: it doesn't help for f (g x) h
15:29:41 <Jaggederest> Yes, three of my best friends are former airborne
15:29:47 <ddarius> DRMacIver: You could be a marine, a programmer, and study Haskell in your spare time all at the same time.
15:30:00 <DRMacIver> I suppose so.
15:30:21 <ddarius> My brother is a marine, but I am not.
15:31:06 <defcons> bitwiseshiftleft, yes but then if it didn't have parens, the code would not be a list
15:31:20 <bitwiseshiftleft> defcons: that too
15:31:26 <defcons> stella artois sucks
15:31:37 <ddarius> There are no lists in Lisp.
15:31:39 <Jaggederest> one thing I learned from my friends: never play cards with an artilleryman. They have nothing to do between calls for fire except become experts. (they're also programmers)
15:31:42 <defcons> ddarius, ?
15:31:44 <Korollary> pair mania
15:31:52 <Philippa> defcons: they're sugar
15:32:02 <Philippa> there's just cons cells, atoms and a few other basic types
15:32:07 <defcons> yeah but htey're still lists of objects
15:32:31 <Philippa> there's no list datatype though, just pairs
15:32:32 <bitwiseshiftleft> yeah, there aren't lists in Haskell either.  there's just some algebraic data type constructor []
15:32:48 <bitwiseshiftleft> and a bunch of sugar
15:32:56 <Philippa> bitwiseshiftleft: which happens to match the commonly understood definition of 'list' in a way that cons cells don't
15:33:00 <Jaggederest> (a b) == a : b : nil
15:33:06 <Philippa> the fundamental structure with lisp is a tree, not a list
15:33:15 <ddarius> Yep
15:33:29 <ddarius> data LispThing = AtomStuff | Cons LispThing LispThing
15:33:49 <bitwiseshiftleft> Philippa: yes, i suppose this is true.  However, the fundamental syntactic unit is a list, which is a particular interpretation of a tree
15:33:56 <ddarius> Either there are pairs or there are trees, no lists.
15:34:08 <dmhouse> It's just a heterogeneous list, surely.
15:34:17 <Philippa> bitwiseshiftleft: it's not fundamental, it's just the one everyone uses
15:34:30 <Philippa> dotted pairs are "fundamental"
15:34:33 <ddarius> And even then it's more like a rose tree.
15:35:00 <bitwiseshiftleft> i don't think it has to be fundamental to be a part of the language
15:35:16 <bitwiseshiftleft> none of the haskell data structures are fundamental
15:35:30 <Philippa> right, just algebraic datatypes and pattern-matching
15:35:37 <defcons> okay
15:35:40 <bitwiseshiftleft> but there are lists in Haskell.
15:35:41 <defcons> let's call it TISP :p
15:35:45 <Philippa> (and the IO monad)
15:35:54 <defcons> or TREEP
15:35:56 <bitwiseshiftleft> no, the IO monad isn't fundamental
15:36:09 <Jaggederest> bind
15:36:16 <whitenoyce> is haskell like a unique caliber rifle, its a wonderful rifle, problem is that everyone shoots standard calibers making it expensive & difficult to use?
15:36:18 <Philippa> bitwiseshiftleft: yes it is, you can't implement it within haskell
15:36:39 <ddarius> Modulo bottoms, Haskell lists correspond to various reasonable notions of list, e.g. free monoids.
15:36:55 <dmhouse> ddarius: ah, but bottoms is what makes lists fun :)
15:37:04 <bitwiseshiftleft> Philippa: sure you can.  It's more or less ST RealWorld
15:37:05 <Philippa> for a minimal system on top of which you can bootstrap the full thing, you need the monad itself and a ccall primitive or similar as a minimum
15:37:15 <dmhouse> bitwiseshiftleft: and how does one implement RealWorld? :)
15:37:21 <Philippa> bitwiseshiftleft: *hah*. No, given an expressive enough type system I can implement ST purely
15:37:25 <ddarius> bitwiseshiftleft: ST doesn't even exist in Haskell 98, nor RealWorld.
15:37:51 <Jaggederest> whitenoyce: It's quite a bit different than most languages, but the analogy isn't perfect.
15:37:59 <ddarius> Nor is that the only or best way to "implement" IO.
15:38:00 <Cale> whitenoyce: sort of?
15:38:08 <dmhouse> bitwiseshiftleft: the point is that RealWorld still has to be magic unless you want to create an algebraic datatype that completely describes the state of the entire world.
15:38:19 <ddarius> Haskell's expensive or difficult to use?
15:38:20 <dmhouse> bitwiseshiftleft: so okay, IO's not primitive, but RealWorld is.
15:38:37 <bitwiseshiftleft> no, RealWorld is just an ordinary type
15:38:39 <Cale> whitenoyce: It would save people lots of work in the medium or long term to use it, but most people don't like learning genuinely new programming languages.
15:38:45 <ddarius> The world passing view of IO is poor.
15:38:51 <SamB_XP> dmhouse: yay zippers
15:38:52 <sorear> IO is primitive.
15:38:54 <Cale> ddarius: I agree.
15:39:02 <Philippa> bitwiseshiftleft: no it's not, how do you call anything?
15:39:07 <sorear> World passing is an unsafe evil hack.
15:39:07 <bitwiseshiftleft> all you really need to be primitive is Seq and foreign calls
15:39:18 <sorear> Not even that
15:39:19 <bitwiseshiftleft> Philippa: in ST s, you don't actually pass in an s
15:39:26 <bitwiseshiftleft> s is just a marker
15:39:39 <SamB_XP> sorear: it would be safe if it weren't for unsafePerformIO, unsafeInterleaveIO, and the fact that Haskell lacks linear types
15:39:41 <whitenoyce> well i'm working on getting haskell installed
15:39:41 <sorear> bitwiseshiftleft: you just need seq, ccalls are not necessary in the haskell level
15:39:59 <Jaggederest> I always think of IO as being a store for a sequence of actions, rather than passing the whole world around
15:40:00 <ddarius> The world passing view of IO is conceptually bad.
15:40:00 <Cale> bitwiseshiftleft: the s represents the memory which STRefs are allocated from.
15:40:05 <Philippa> sorear: they are if you have the FFI, no? Also, it's that or implement all the IO operations
15:40:08 <yaxu> my types are getting too complicated
15:40:08 <whitenoyce> problem is apt-get just removed some impt files
15:40:12 <Cale> Jaggederest: I agree with that :)
15:40:14 <dmhouse> bitwiseshiftleft: if RealWorld is just an ordinary type, then how does writeFile "foo" "blah" >> readFile "foo" work?
15:40:23 <sorear> Jaggederest: me to.
15:40:26 <byorgey> whitenoyce: ?  what did apt-get remove?
15:40:30 <Philippa> ddarius: I wouldn't go that far, it has its uses
15:40:34 <Jaggederest> sweet, I'm not completely off base!
15:40:38 <dmhouse> bitwiseshiftleft: the state wouldn't get updated unless RealWorld either was magic or actually described the state of the system.
15:40:45 <ddarius> It does have it's uses, but it's ultimately misleading.
15:40:47 <whitenoyce> byorgey, no i did apt-get install ghc6
15:40:50 <geezusfreeek> what are views of monads vs. comonads (vs. other?) for IO in here?
15:40:54 <whitenoyce> but it removed some important packages
15:40:57 <Philippa> dmhouse: we're being told to use an unsafe ccall primitive
15:41:06 <byorgey> whitenoyce: hm, that's strange.  what did it remove?
15:41:09 <Philippa> geezusfreeek: comonads aren't safe in haskell, simple as that
15:41:14 <Philippa> (for IO, that is)
15:41:32 <ddarius> geezusfreeek: There is no reason to think comonads should be good for IO, monads are what we use now, we've used others but not since monads so...
15:41:37 <whitenoyce>   build-essential g++ g++-4.1 initrd-tools kernel-image-2.6.8-2-386
15:41:37 <whitenoyce>   kernel-image-2.6.8-2-686 libstdc++6-4.1-dev tzdata util-linux
15:42:00 <Cale> They aren't safe for IO unless you're prepared to copy the world.
15:42:01 <geezusfreeek> Philippa: do you mean that by haskell current implementation (around monads and with support for comands added in later) or by the fundamental nature of comonads?
15:42:01 <byorgey> whitenoyce: that's extremely odd.
15:42:13 <Cale> geezusfreeek: fundamentally.
15:42:14 <byorgey> whitenoyce: do an apt-get update ; apt-get dist-upgrade?
15:42:24 <byorgey> whitenoyce: just to make sure everything's up to date
15:42:26 <Cale> geezusfreeek: Especially if IO includes things like a network.
15:42:40 <Philippa> geezusfreeek: by the fundamental nature of the OI comonad and haskell's type system
15:42:43 * geezusfreeek is not yet familiar enough with comonads to really argue much... just learning about them recently
15:43:00 <ddarius> As I said, there is no reason to think that there should be "comonadic IO"
15:43:00 <dmhouse> Philippa: oh, okay. So rather than RealWorld being a magic type so that whenever you try to mutate it you generate a C call, you actually perform the C calls from within Haskell. Not much difference.
15:43:07 <whitenoyce> byorgey, working on it
15:43:12 <Cale> I suppose that if you could use uniqueness typing, you could make OI safe.
15:43:15 <byorgey> whitenoyce: kernel version 2.6.8 is pretty old.
15:43:16 <ddarius> In fact, the existence of monadic IO makes it even less likely, not more likely,
15:43:19 <Cale> But that would be somewhat silly.
15:43:21 <Philippa> dmhouse: except that it means you have unsafe primitives
15:43:55 <bitwiseshiftleft> there are no objects of type RealWorld.  RealWorld is only used in the type system.  the type of IO in GHC is newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #)).  State# s is not ever instantiated to anything, but is only there to allow functions to be sequenced.
15:44:01 <whitenoyce> byorgey, well i got 618 packages to go...
15:44:02 <Philippa> ddarius: it's been done, it's just not a big gain
15:44:06 <dmhouse> Philippa: yes, the difference is where the C gets called from.
15:44:09 <whitenoyce> dist-upgrade
15:44:17 <byorgey> whitenoyce: hm, yeah
15:44:24 <ddarius> Philippa: I'm aware of the OI monad, it didn't seem to work to me.
15:44:29 <Philippa> bitwiseshiftleft: point's gone. Also, citing GHC isn't much relevant
15:44:32 <Cale> comonad?
15:44:42 <byorgey> whitenoyce: you should probably do that more often =)
15:44:43 <Philippa> ddarius: like I said, it's unsafe in haskell as-is
15:44:43 <ddarius> s/monad/comonad
15:44:51 <geezusfreeek> well, to rephrase my question, if main was typed around comonadic operation instead of monadic and all primitive IO operations were designed with comonads in mind, it would be less safe than the existing IO monads?
15:44:54 <whitenoyce> byorgey, heh yeah
15:45:03 <ddarius> geezusfreeek: Yes.
15:45:04 <geezusfreeek> *monad
15:45:08 <whitenoyce> byorgey, probably first time ever
15:45:25 <Philippa> geezusfreeek: yes, the holes aren't due to having access to the IO monad
15:45:26 <Cale> bitwiseshiftleft: That implementation requires values of type Integer other than bottom and the integers.
15:45:39 <geezusfreeek> i guess i just still have to master the concept
15:45:44 <SamB_XP> so, has anyone implemented the FFI with RealWorld as an algebraic datatype?
15:45:48 <ddarius> Philippa: What would make it safe that wouldn't be able to support IO itself?
15:45:49 <Cale> bitwiseshiftleft: (Which is sort of the case in GHC, but we don't like to think of it that way)
15:45:57 <byorgey> whitenoyce: what distro/version?
15:46:04 <Philippa> ddarius: IIRC linear types would
15:46:05 <whitenoyce> debian testing
15:46:08 <dmhouse> Cale: what does Integer have to do with anything?
15:46:18 <Cale> dmhouse: nothing, it's just an example of a pure type
15:46:18 <whitenoyce> it was installed a year or two ago though
15:46:26 <Philippa> dmhouse: as an example. Cale's pointing out that it involves an unsafe primitive
15:46:36 <txberiu> hello
15:46:37 <Philippa> and thus breaks the language's semantics
15:46:40 <ddarius> With linear types you wouldn't need the comonad.
15:46:53 <dmwit> txberiu: Hi!
15:46:56 <dmhouse> Philippa: by 'unsafe primitive' you mean FFI ccals, right?
15:47:02 <Philippa> ddarius: you wouldn't need the comonadic structure, no. But you'd get most of it
15:47:03 <sorear> whitenoyce: there's your problem
15:47:17 <Philippa> dmhouse: I mean the equivalent of unsafePerformIO (ccall ...)
15:47:18 <ddarius> That said, I can see coalgebraic views of IO and comonads being related to that.
15:47:25 <byorgey> whitenoyce: it's important for security purposes to stay relatively up-to-date with patches etc. (I got bitten by that once many years ago before I knew better...)
15:47:33 <sorear> whitenoyce: debian testing is dynamic, any given package list is only useful for a week or so
15:47:40 <whitenoyce> its nat'ed up though
15:47:42 <Jaggederest> I think that everything should be based around the fundamental unit: lists of boxed bits.
15:48:04 <byorgey> whitenoyce: well, that's good, but still
15:48:12 <Philippa> Jaggederest: go write the interpreter, see how you find it
15:48:22 <sorear> whitenoyce: nat has nothing to do with this - the versions of packages that would be compatible with your system were deleted from the debian archive a year ago
15:48:24 <ddarius> Start using a HDL
15:48:26 <Philippa> "tedious" would be a good start
15:48:29 <Jaggederest> P: brainfuck? It's easy ;)
15:48:30 <byorgey> whitenoyce: there's no such thing as a magic bullet when it comes to security =)
15:48:53 <sorear> byorgey: No, but there is magic grey powder.
15:49:05 <Jaggederest> http://www.muppetlabs.com/~breadbox/bf/
15:49:06 <lambdabot> Title: The Brainfuck Programming Language
15:49:17 <byorgey> sorear: right, and you'll sell it to me for only $39.99/mo, right?
15:49:36 <Cale> sorear: iron filings to pour into machines you want to "secure"?
15:49:53 <sorear> Cale: you got one of the elements ;)
15:50:00 <sorear> two more
15:50:24 <byorgey> Cale: it's pretty much impossible to hack into a crater where a computer used to be
15:50:34 <Jaggederest> gunpowder. heh
15:50:56 <sorear> actually I was thinking of thermite.  but gunpowder works almost as well
15:51:14 <ddarius> Iron and aluminum.
15:51:16 <Cale> Yeah, I sort of figured you might be talking about thermite after you said that :)
15:51:17 <Jaggederest> thermite won't self-ignite in the power supply :)
15:51:19 <ddarius> And something to lite it.
15:51:24 <ddarius> s/lite/light
15:51:27 <ddarius> E.g. magnesium
15:51:28 <bitwiseshiftleft> iron III oxide and aluminum
15:51:29 <sorear> ddarius: +oxygen
15:51:30 <Cale> Though you'd need to get the iron filings to rust first :)
15:51:40 <ddarius> sorear: Oxygen is in ready supply
15:51:58 <SamB_XP> Cale: oh?
15:52:12 <ddarius> SamB_XP: You've never lit of themite before?
15:52:15 <Jaggederest> it's a single exchange reaction
15:52:20 <SamB_XP> no...
15:52:20 * byorgey wishes he paid more attention in chemistry class...
15:52:24 <ddarius> oxidation-reduction
15:52:35 <SamB_XP> ox-redux is my arch nemesis
15:52:43 <ddarius> SamB_XP: You can make it at home...
15:52:52 <Jaggederest> Fe3O4 + Al -> Al2O3 + Fe
15:52:53 <SamB_XP> which is too bad, since I don't actually believe in it
15:53:00 <ddarius> The hardest part is getting something to light it.
15:53:01 <bitwiseshiftleft> pretty hard to light at home though.
15:53:22 <Jaggederest> +880kj/mol = hot.
15:53:30 <ddarius> They say some of those self-igniting briquette things work.
15:53:52 <sorear> If I wanted to do it, my first approach would be an electric arc.
15:54:13 <Jaggederest> magnesium firestarters from camping stores.
15:54:24 <Jaggederest> or a road flare
15:54:30 <hpaste>  int80h pasted "int80_h borks chat server code" at http://hpaste.org/234
15:54:41 <Cale> http://www.youtube.com/watch?v=Q1yz0WL6k78 -- here's a cheesy video of it melting through an engine block
15:55:11 <sorear> int80_h: exactly, you borked the indentation
15:55:29 <int80_h> where? I copied this from a guy's blog
15:55:29 <sorear> the body of chat is being interpreted as a continuation of the type signature
15:55:35 <sorear> resulting in mucho madness
15:55:35 * int80_h eeps
15:55:45 <int80_h> ah hold on then
15:56:53 <int80_h> okay should I put the indentation back to what it was, all the lines in chat were aligned in the origional code. But I was getting other erros then
15:57:09 <int80_h> that went away, replaced by these others
15:57:45 <int80_h> server.lhs:40:1: parse error (possibly incorrect indentation)
15:57:56 <int80_h> that's what I get now after I fix indentation
15:58:08 <int80_h> I mean, put it back to the way it was from the blog
16:01:38 <byorgey> int80_h: can you paste the current version of your code?
16:01:40 <hpaste>  int80h annotated "int80_h borks chat server code" with "(no title)" at http://hpaste.org/234#a1
16:01:57 <yaxu> Cale: i understand that tv programme fabricated its experiments
16:02:43 <sorear> int80_h: it's still broken intentation
16:02:55 <dmwit> yaxu: Yeah, Brainiac is known for being a bit dishonest about what's really happening.
16:03:17 <sorear> int80_h: dedent the second line starting 'chat
16:03:22 <sorear> ' to the left margin
16:03:33 <hpaste>  byorgey annotated "int80_h borks chat server code" with "sane indentation" at http://hpaste.org/234#a2
16:03:40 <dmhouse> yaxu: it isn't really serious science, it's just an entertainment program. Quite good fun, though.
16:04:22 <yaxu> i haven't seen it, i'm dubious about trying to get children interested in science by lying to them though
16:04:31 <byorgey> int80_h: looking at the blog, it looks like the original author missed some <pre> tags around that bit of code
16:04:38 <yaxu> http://www.badscience.net/?p=261
16:04:42 <lambdabot> Title: Bad Science » Ka-Boom! Science! COOL!!?!
16:04:46 <byorgey> int80_h: so nothing got indented, although I'm sure the original code had indentation
16:06:23 <Cale> Ah, I'm not actually familiar with the show.
16:11:54 <int80_h_> good it works thanks so much :)
16:27:48 <pastorn> i'm looking for a title of a lisp book... it has a very unique style with questions and answers over ande over again
16:28:33 <loud-> the little schemer
16:28:45 <pastorn> loud- ftw
16:28:49 <pastorn> :D
16:28:53 <pastorn> danke meine herren :D
16:29:28 <loud-> =)
16:37:14 <sorear> kosmikus: ping?
16:43:06 <sorear> @time kosmikus
16:43:08 <lambdabot> Local time for kosmikus is Sun Jun 10 01:45:12 2007
16:49:28 <Botje> hmm
16:49:35 <Botje> if I read this web page correctly
16:50:00 <Botje> Deputy (http://deputy.cs.berkeley.edu/) uses dependent types to augment their C code
16:50:01 <lambdabot> Title: Deputy
16:54:52 <SamB_XP> yay. google slurped the updated robots.txt
16:55:40 <sorear> @google haskell wiki
16:55:42 <lambdabot> http://haskell.org/hawiki/
16:55:42 <lambdabot> Title: FrontPage - The Haskell Wiki
16:56:02 <SamB_XP> sorear: I never claimed that it had done anything with it
16:57:09 <SamB_XP> I'd give it another week
16:57:30 <SamB_XP> (I used the webmaster tools to find out that it had slurped the new robots.txt)
16:58:31 <ddarius> @google site:haskell.org stack overflow
16:58:32 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
16:58:32 <lambdabot> Title: Stack overflow - HaskellWiki
17:00:21 <SamB_XP> ddarius: it still had URLs
17:00:25 <SamB_XP> but no text content
17:00:32 <ddarius> Poor choice
17:00:47 <ddarius> @google site:haskell.org Oleg
17:00:49 <lambdabot> http://www.haskell.org/pipermail/haskell/2004-June/014109.html
17:00:49 <SamB_XP> ... which seems to be the case still
17:00:49 <lambdabot> Title: [Haskell] Re: how to write a list builder? fixpoint?
17:01:35 <SamB_XP> http://www.google.com/search?q=site:haskell.org/haskellwiki
17:01:35 <lambdabot> Title: site:haskell.org/haskellwiki - Google Search
17:03:45 <ddarius> Good call
17:05:49 <SamB_XP> but at least now it the webmaster tools say that robots.txt allows it to index the wiki
17:06:23 <SamB_XP> hopefully the crawler will recrawl the wikipages a bit sooner than they'll look at the homepage ;-)
17:07:00 <SamB_XP> apparantly they last crawled http://www.haskell.org/ in july 2006...
17:07:01 <lambdabot> Title: Haskell - HaskellWiki
17:10:39 <whitenoyce> variables are a misnomer in haskell
17:10:39 <whitenoyce> <- noob
17:11:15 <SamB_XP> whitenoyce: no more than in math
17:11:53 <whitenoyce> but why would a constant be called a variable if it does not vary?
17:12:10 <ddarius> Because it varies with the environment
17:12:21 <SamB_XP> C-- calls those things you are thinking of "registers" instead of "variables"
17:12:24 <SamB_XP> iirc
17:12:51 <SamB_XP> makes more sense, anyways.
17:13:14 <Cale> whitenoyce: for example in (\x -> x + 5), x is a variable, even though whenever the lambda is actually applied, it remains constant through that application
17:13:41 <Cale> (what the lambda gets applied to is really what varies)
17:14:18 <byorgey> whitenoyce: your computer finished upgrading? =)
17:17:35 <SamB_XP> why does yahoo's search results look so much like google's (in style, not content)...
17:17:46 <whitenoyce> byorgey, yes
17:18:02 <whitenoyce> E: Sub-process /usr/bin/dpkg returned an error code (1)
17:18:03 <whitenoyce> but ghci works
17:18:19 <whitenoyce> i like yahoo's search
17:18:20 <byorgey> whitenoyce: yah, I might expect some sort of glitch
17:18:29 <whitenoyce> live.com is pretty good too
17:18:46 <byorgey> whitenoyce: you should probably try running dist-upgrade again, and keep running it until it doesn't do anything
17:19:00 <byorgey> whitenoyce: or at least until it keeps returning the same error
17:20:16 <whitenoyce> yeah, its on a couple of unimportant packages
17:20:20 <whitenoyce> i'll just ignore it
17:20:41 <whitenoyce> or edit /var/lib/dpkg/status
17:22:11 * whitenoyce whitenoyce pokes at haskell and gets surprises
17:22:16 <Philippa> whitenoyce: they're variables in exactly the same sense as variables in algebra
17:22:22 <whitenoyce> let n=[1,2,3]
17:22:30 <Philippa> the imperative use of the word is the deviant
17:22:31 <whitenoyce> let n=0:n
17:22:33 <whitenoyce> uh, oh
17:22:44 <syntax> Malbolge rules'em  all.
17:22:47 <SamB_XP> why does everyone use the same syntax for site search now?
17:23:01 <byorgey> > let n = 0:n in n
17:23:03 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
17:23:13 <byorgey> perfectly valid Haskell =)
17:23:19 <sorear> SamB_XP: To spite the guy who invented printf-format multisearch customization (in firefox eg)
17:23:23 * sorear is guessing
17:23:33 <SamB_XP> heh
17:23:43 <whitenoyce> well its not identical
17:23:52 <whitenoyce> p= for yahoo
17:23:56 <igli> nice idea tho sorear ;)
17:23:58 <whitenoyce> results.aspx for msn
17:24:05 <Philippa> whitenoyce: that made sense re variables?
17:24:05 <whitenoyce> n= for yahoo
17:24:11 <whitenoyce> a cookie for msn results
17:24:12 <SamB_XP> whitenoyce: within the variable
17:24:18 <whitenoyce> num= for google
17:24:26 <whitenoyce> yeah i got the variable thing
17:24:33 <byorgey> whitenoyce: ok, ok... =)
17:24:44 <SamB_XP> all of them use the site:haskell.org/haskellwiki syntax
17:24:56 <whitenoyce> SamB, oh that
17:25:00 <whitenoyce> msn doesn't
17:25:00 <syntax> sorear: "madness" is feminine. you should say "mucha madness".
17:25:04 <whitenoyce> yahoo not really
17:25:10 <whitenoyce> siteexplore.yahoo.com
17:25:13 <SamB_XP> whitenoyce: live search does
17:25:23 <whitenoyce> SamB, they must've fixed it
17:25:31 <whitenoyce> they keep breaking it
17:25:33 <SamB_XP> and yahoo said it was redirecting my site: search to site explorer
17:32:22 <SamB_XP> unfortunately, not only do they all seem to use the same site: syntax, none of them seem to have any content from haskellwiki
17:33:47 <SamB_XP> huh. exalead has
17:33:58 <SamB_XP> (I learned of them through my own HTTP logs ;-)
17:34:00 <int-e> SamB_XP: that's a known problem - see http://haskell.org/robots.txt ...
17:34:16 <SamB_XP> int-e: I got Igloo to append a ? this morning, though
17:35:27 <SamB_XP> google has the new robots.txt, both for www.haskell.org and for haskell.org
17:35:44 <int-e> I see. hmm.
17:35:53 <SamB_XP> but they don't seem to have crawled any wiki pages yet. I'm obviously being too impatient.
17:36:12 <SamB_XP> now if only I'd checked exalead before Igloo changed robots.txt, or shortly afterwards...
17:36:46 <syntaxfull> how much of the search market has google by now?
17:38:41 <int-e> @google inurl:Haskell_in_5_steps
17:38:43 <lambdabot> http://www.haskell.org/haskellwiki/Haskell_in_5_steps
17:38:43 <lambdabot> Title: Haskell in 5 steps - HaskellWiki
17:39:53 <int-e> (but google has no contents for that page. the search finds a proxy though, funny)
17:41:27 <SamB_XP> hmm. I think exalead just doesn't throw stuff out when you restrict access using robots.txt
17:42:25 <SamB_XP> and they seem to have indexed a couple of pages since Igloo changed robots.txt
17:43:31 <syntaxfull> @google google
17:43:32 <lambdabot> http://www.google.com/
17:43:32 <lambdabot> Title: Google
17:43:45 <SyntaxNinja> y0
17:43:52 <syntaxfull> x0
17:44:13 <SamB_XP> @google exabot
17:44:16 <lambdabot> http://www.exalead.com/
17:44:16 <lambdabot> Title: Exalead - Internet search engine, image search engine, video search engine ...
17:44:51 <syntaxfull> one can't compose @ commands with >  haskell results. that is sucky.
17:44:56 <syntaxfull> @eval 2+2
17:45:07 <kpreid> @. show run 2+2
17:45:08 <lambdabot> " 4\n"
17:45:11 <syntaxfull> run?
17:45:14 <SamB_XP> no wait, exalead hasn't updated any of their index data...
17:45:27 <SamB_XP> well. maybe they have.
17:45:27 <syntaxfull> @. google run fix ("google":)
17:45:30 <lambdabot> http://video.google.com/
17:45:30 <lambdabot> Title: Google Video
17:45:33 <SamB_XP> but I was misreading the dates...
17:46:08 <kpreid> @. google . read . run replicate 10 y
17:46:08 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "replicate"
17:46:50 <syntaxfull> @read 2+2
17:46:50 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
17:46:55 <syntaxfull> @show 2+2
17:46:56 <lambdabot> "2+2"
17:47:19 <SamB_XP> heh
17:47:23 <syntaxfull> @. google . run replicae 10 y
17:47:23 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "replicae"
17:47:29 <syntaxfull> @. google . run replicate 10 y
17:47:30 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "replicate"
17:47:38 <syntaxfull> @help run
17:47:39 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
17:47:43 <kpreid> @. google . read run replicate 10 y
17:47:44 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
17:47:51 <syntaxfull> @help read
17:47:51 <lambdabot> read "<foo>". Print <foo>
17:47:53 <kpreid> @. google run replicate 10 y
17:47:56 <lambdabot> http://blogs.msdn.com/wesdyer/archive/2006/12/26/reading-and-writing-queries.aspx
17:47:56 <lambdabot> Title: Yet Another Language Geek : Reading and Writing Queries
17:48:02 <kpreid> there we go
17:48:30 <syntaxfull> @run replicate 10 y
17:48:30 <lambdabot>   Not in scope: `y'
17:48:43 <syntaxfull> @show . run replicate 10 y
17:48:43 <lambdabot> ". run replicate 10 y"
17:48:51 <kpreid> er, oops
17:48:54 <syntaxfull> @. show run replicate 10 y
17:48:55 <lambdabot> "  Not in scope: `y'\n"
17:48:58 <kpreid> @. google run replicate 10 "y"
17:49:01 <lambdabot> http://en.wikipedia.org/wiki/Y
17:49:01 <lambdabot> Title: Y - Wikipedia, the free encyclopedia
17:49:05 <SamB_XP> isn't this preview the best: http://www.exalead.com/search/results?q=hugs+mode+for+emacs&x=0&y=0
17:49:09 <lambdabot> Title: hugs mode for emacs - Exalead Search, http://tinyurl.com/yns2ry
17:49:43 <SamB_XP> the top thumnail on the left
17:50:01 <syntaxfull> @. quote quote
17:50:01 <lambdabot> No quotes match. The more you drive -- the dumber you get.
17:50:08 <syntaxfull> @quote
17:50:09 <lambdabot> SeanRussell says: [On the wmii (window manager) mailing list] Hah!  That's a laugh.  Since when does "it compiles" equate to "it will run (correctly)"?  We're talking about C, after all... not
17:50:09 <lambdabot> Haskell.
17:50:21 <SamB_XP> @quote
17:50:21 <lambdabot> The says: alien rulers of the galaxy must surely use a statically typed language with type inference
17:50:27 <SamB_XP> @quote
17:50:27 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
17:50:48 <syntaxfull> @quote magic
17:50:48 <lambdabot> malig says: I have to admit I'm still stunned when "tying the knot" actually works. it's like I just performed the kind of magic that normally requires a lot more goat's blood
17:50:52 <syntaxfull> ?quote magic
17:50:52 <lambdabot> ghc says: magic number mismatch: old/corrupt interface file?
17:51:36 <syntaxfull> ?. quote . google . show run chr(181)
17:51:39 <lambdabot> No quotes for this person. You speak an infinite deal of nothing
17:51:43 <syntaxfull> ?. quote . google . show run chr(65)
17:51:47 <lambdabot> No quotes for this person. Are you on drugs?
17:51:55 <int-e> @quote state
17:51:55 <lambdabot> state says:  ?. ++ . read . show . state ?. ++ . read . show . state
17:52:29 <syntaxfull> @quote drugs
17:52:29 <lambdabot> LoganCapaldo says: <LoganCapaldo> @src fixIO <lambdabot> Source not found. Are you on drugs? <LoganCapaldo> No <LoganCapaldo> Meanie
17:52:36 <syntaxfull> @quote drugs
17:52:36 <lambdabot> dylan says: pugs, darcs, and lambdabot: gateway drugs to haskell.
17:52:46 <syntaxfull> @quote drugs
17:52:46 <lambdabot> LoganCapaldo says: <LoganCapaldo> @src fixIO <lambdabot> Source not found. Are you on drugs? <LoganCapaldo> No <LoganCapaldo> Meanie
17:53:23 <syntaxfull> @quote mean
17:53:23 <lambdabot> edwinb says: I've just walked past a poster advertising a gig by a band called "The Awkward Squad". I assume this means they provide output, play concurrently, and people take exception to them.
17:54:48 <syntaxfull> @quote grep
17:54:49 <lambdabot> Kahdloc says: why's it called filter and not grep? :/
17:55:04 <syntaxfull> OH. that's a protontorpedoism if I ever saw one.
17:56:49 <sorear> @seen dons
17:56:50 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 10h 38m 7s ago.
17:57:47 <syntaxfull> wth is haskell-soc?
17:57:56 <chessguy> soc=summer of code
17:57:58 <chessguy> @where soc
17:57:58 <lambdabot> http://hackage.haskell.org/trac/summer-of-code/
18:06:43 <SyntaxNinja> our channel about socks.  socks are very important in haskell.
18:06:54 <SyntaxNinja> syntaxfull: are you the same as syntaxfree?
18:07:46 <sorear> SyntaxNinja: he has the same userinfo, Diego Navarro
18:08:17 <syntaxfull> 21:24 < syntax> sorear: "madness" is feminine. you should say "mucha madness".
18:08:27 <syntaxfull> 21:24 -!- You're now known as syntaxfull
18:08:46 <chessguy> @seen syntaxfree
18:08:46 <lambdabot> I haven't seen syntaxfree.
18:09:04 <SyntaxNinja> whew
18:09:12 <chessguy> @seen syntaxfull
18:09:12 <lambdabot> syntaxfull has changed nick to syntaxfree.
18:09:12 <lambdabot> syntaxfree is in #haskell-blah and #haskell. I last heard syntaxfree speak 45s ago.
18:09:12 <sorear> @seen Syntaxfull
18:09:12 <lambdabot> Syntaxfull has changed nick to syntaxfree.
18:09:12 <lambdabot> syntaxfree is in #haskell-blah and #haskell. I last heard syntaxfree speak 45s ago.
18:09:17 <SyntaxNinja> I was afraid there was yet another syntax-something
18:09:19 <syntaxfree> 22:08 -NickServ(NickServ@services.)- Password accepted - you are now  recognized
18:09:21 <chessguy> @quote stereo
18:09:22 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:09:22 <syntaxfree> heh.
18:09:37 <chessguy> not only answered in stereo, but asked, too!
18:13:21 <chessguy> well, that was a conversation-killer
18:13:44 <chessguy> or did i get booted again?
18:14:01 <syntaxfree> conversations are not living entities.
18:14:04 <syntaxfree> they cannot be killed.
18:14:15 <sorear> syntaxfree: you ruined it
18:15:08 <chessguy> syntaxfree, prove it
18:27:49 <rabbitear> lots
18:29:13 <sorear> straws
18:29:45 <rabbitear> nuns
18:40:23 <sorear> @tell kosmikus lhs2TeX doesn't typeset strict fields very well (probably unfixable)
18:40:23 <lambdabot> Consider it noted.
18:45:21 <rabbitear> tab made
18:46:07 <sorear> ?
18:48:00 <dancor> can i get the directory my program is executing in
18:48:22 <dancor> i mean the path of the executable
18:48:33 <dancor> as opposed to the $PWD
18:48:40 <sorear> no
18:48:55 <sorear> well you *can*, but it requires very deep hackery
18:49:04 <rabbitear> strace?
18:49:08 <sorear> deeper
18:49:19 <rabbitear> deeper then strace?
18:49:23 <rabbitear> read the code!
18:49:36 <sorear> rabbitear: As in, using undocumented kernel features
18:49:44 <SamB_XP> sorear: strace doesn't do that?
18:49:45 <rabbitear> ohhh.
18:49:53 <SamB_XP> which ondocumented features?
18:49:54 <sorear> strace is at least documented, and uses ptrace which is also
18:49:59 <sorear> you'll need to readlink /proc/self/exe
18:50:03 <SamB_XP> ... does linux have a ticket tracker?
18:50:17 <sorear> SamB_XP: the documentation for things under /proc is woefully lacking
18:50:18 <SamB_XP> sorear: how is that undocumented
18:50:31 <SamB_XP> well, I mean, ls -l isn't documentation ?
18:50:31 <rabbitear> I don't know 'this app'
18:50:38 <rabbitear> to say. that..
18:50:41 <sorear> SamB_XP: afaict man 4 proc hasn't been updated since before 2.0.x
18:51:16 <SamB_XP> sorear: and ls -l doesn't count as documentation?
18:51:18 <sorear> SamB_XP: by that logic the source code must count too
18:51:35 <SamB_XP> sorear: well, nearly
18:51:37 <rabbitear> must count..
18:52:01 <rabbitear> you should be able to see where a file is being 'got' from the source
18:52:18 <sorear> dancor: But if you're trying to access the directory of an exec, you are doing something very very un-unixlike
18:52:42 <rabbitear> sorear: what is this app?
18:53:04 <sorear> dancor: distributed programs are strongly encouraged to follow the Filesystem Hierarchy Standard, which says that your progam is in /usr/bin and none of your data files are there
18:53:10 <sorear> rabbitear: no clue, ask dancor
18:53:21 <sorear> rabbitear: oh, Linux
18:53:26 <sorear> linux proper that is
18:53:34 <rabbitear> sorear: the kernel itself?
18:53:36 <sorear> yes
18:53:39 <rabbitear> sorear: oh..
18:54:06 <rabbitear> sorear: I can't go there..
18:54:29 <sorear> rabbitear: Linux proper::has undocumented features    No clue, ask dancor::can i get the path of the executable?
18:54:34 <sorear> rabbitear: clarifies?
18:54:41 <SamB_XP> sorear: maybe he wants to know what prefix it is installed in
18:54:49 <SamB_XP> i.e. /usr vs. /usr/local
18:55:12 <rabbitear> I really don't know the topic here.
18:55:17 <sorear> dancor: if what SamB_XP says is true, @PREFIX@
18:56:12 <dancor> i'm reading the FHS.  thanks
18:58:24 <rabbitear> dancor: good idea
19:02:38 <dancor> i have an executable and a bunch of png files.  i have no immediate vision for how this would install onto /.  but right now i have the executable progName in ~/p/progName and the images in ~/p/progName/data.  i just want to be able to run the program as ~/p/progName/progName.  what is the correct thing to do, link the binary to ~/bin (or ~/usr/bin) and the data dir to ~/lib/share/progName and the program has to guess if it should look
19:04:18 <kpreid> images would go in PREFIX/share/progName/
19:04:27 <kpreid> executable in PREFIX/bin/
19:05:34 <dancor> right ok.  and how do you access PREFIX in the .hs?
19:06:00 <sorear> dancor: you got cut off sat "it should look"
19:08:19 <dancor> and so even when you guys are testing programs you have this structure in place (and PREFIX is like . or ~) ?
19:09:51 <kpreid> dancor: at compile/installation time you wire the prefix into the executable
19:10:17 <kpreid> it could be just a shell script which execs the real program and passes the prefix in environment or args
19:10:58 <rabbitear> dancor: if its not for you re-read FHS
19:11:19 <rabbitear> dancor: other wise, its not an issue
19:11:28 <gwern> so, I'm trying to figure out how to take some text and return a list of all the URLs in it, and I check out Text.HTML and I see 'address :: Html -> Html' in <http://www.haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html>, but this doesn't help me at all. where do I find the real documentation which actually describes what it does?
19:11:28 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/libraries/html/Text-Html.html>
19:11:29 <dancor> is it possible to specify PREFIX and PROGNAME (?) in the .hs file to be filled in at compile time
19:12:44 <ddarius> It certainly is possible in a variety of ways.
19:12:57 <rabbitear> yeppers
19:13:08 <rabbitear> FHS would have people not complain
19:13:34 <dancor> ddarius: but would i have to do something myself (sed 's/@PREFIX@/../g')
19:14:09 <ddarius> dancor: That's one possibility, or you can use CPP, or you can import a module that gets made, or you can use TH, or you can do a variety of other things.
19:15:11 <SamB_XP> how do you have Cabal tell you where your files will be?
19:15:21 <dancor> well which one is the most unixlike since what i wanted to do, in this world of possibilty, apparently wasn't :)
19:15:29 <SamB_XP> also, it occurs to me that Cabal should support games ;-)
19:15:44 <ddarius> SamB_XP: ?
19:16:02 <SamB_XP> ddarius: games go in different places from ordinary programs
19:16:24 <ddarius> And Cabal doesn't support that?
19:18:30 <dancor> i guess i'm confused how i can take the --prefix you give to ghc or cabal and replace strings in my source
19:18:45 <ddarius> The most unixy way would probably be to have an environment variable and/or commandline option to specify the directories.
19:18:55 <sorear> I had momentarily forgotten about Cabal.
19:19:07 <SamB_XP> well, game binaries go in /usr/games, data goes in /usr/share/games, highscores go in /var/games
19:19:16 <ddarius> sorear is getting senile in his old age
19:19:32 <sorear> Autoconf works by substituting information like the prefix for special tokens such as @PREFIX@ for the prefix, in a list of files.
19:19:45 <sorear> In cabal, you use a Paths_ module, *finds url*
19:20:45 <sorear> http://www.haskell.org/ghc/docs/latest/html/Cabal/authors.html#paths-module
19:20:47 <lambdabot> Title: 2. Creating a package, http://tinyurl.com/yv8xjt
19:20:54 <SamB_XP> ddarius: he has old age remarkably early!
19:21:14 <sorear> that is either out of date or deliberately vague; it does not document most of the Paths_ functions
19:23:06 <hpaste>  sorear pasted "sample Paths_ module" at http://hpaste.org/235
19:23:51 * gwern whacks Text.Html out of frustration. I just wanted to parse some URLs out of some text! why is that so hard? :(
19:24:12 <sorear> because Text.Html is a pretty printer
19:24:19 <sorear> I think you wanted a parser
19:24:23 <gwern> oh
19:24:30 <SamB_XP> lol
19:24:32 * gwern feels foolish now
19:24:51 <gwern> that would explain why feeding 'address' a html document was not producing useful results.
19:24:59 * SamB_XP smiles at relaxed "lol" policies 
19:25:21 <Korollary> but, do you smile out loud?
19:25:38 <SamB_XP> Korollary: of course not
19:25:47 <SamB_XP> my face isn't broken, you know!
19:26:24 <sorear> @where tagsoup
19:26:24 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
19:26:39 <sorear> gwern: ^^^ ndm's pathetic attempt at parsing html
19:26:43 <gwern> sorear: actually, I'm looking at the tagsoup manual now
19:26:52 <sorear> :)
19:27:15 <gwern> seemed like the only one on the wiki's list even remotely near my need :(
19:27:23 <gwern> and speaking of the wiki, why is the #1 hit for 'haskell wiki' the *old closed* wiki?
19:27:39 <sorear> gwern: because google is banned from indexing the new one
19:28:07 <sorear> or rather "was", but the problem was fixed an hour or so ago, no time to reindex
19:28:13 <gwern> oh. the stupid robots.txt issue again?
19:28:16 <sorear> yeah
19:28:22 <SamB_XP> sorear: we updated robots.txt probably 12 hours ago
19:28:38 <gwern> (sheesh, I mean you could just copy wikipedia's robot.txt if it's really that hard to write a good one)
19:28:39 <SamB_XP> google.com read the new robots.txt sometime after 4:00 PDT
19:29:26 <sorear> gwern: but our urls are different and Igloo refuses to shorten them
19:29:35 <sorear> 07:31 < Igloo> That would break every external link for little gain
19:29:58 <sorear> 'refuses' in an exaggerated sense
19:30:03 <SamB_XP> Igloo also said it was an issue for the wiki administrator...
19:30:12 <gwern> so do a search/replace then
19:30:32 <SamB_XP> gwern: you are going to go and do a search/replace on our irc logs?
19:30:37 <SamB_XP> that we don't manage?
19:31:21 <sorear> @seen nef
19:31:21 <lambdabot> I haven't seen nef.
19:31:24 <SamB_XP> heh
19:31:31 <gwern> SamB_XP: 'twas referring to searh/replace the different links in robots.txt
19:31:34 <SamB_XP> I don't think I've ever seen nef
19:31:43 <SamB_XP> it's possible that I saw nef in #tunes, I dunno
19:31:46 <Saizan> just moving the scripts pages won't hurt references
19:31:54 <SamB_XP> Saizan: yeah.
19:32:28 <SamB_XP> but anyway I realized that if we stick a ? in the excluded path, it will only exclude scripty usage
19:32:50 <SamB_XP> see robots.txt ;-)
19:33:23 <Saizan> i was reading when you suggested this :)
19:33:53 <sorear> @seen hcr
19:33:53 <lambdabot> I haven't seen hcr.
19:33:54 <sorear> @seen hcf
19:33:54 <lambdabot> I haven't seen hcf.
19:34:10 <SamB_XP> > 29/30
19:34:13 <lambdabot>  0.9666666666666667
19:34:37 <SamB_XP> ... my mom was bugging me to calculate that...
19:38:04 <SamB_XP> huh, google didn't trademark SafeSearch ?
19:39:01 <SamB_XP> huh. search.live.com knows and uses the fact that I'm in Upper Darby?
19:39:10 <SamB_XP> I guess it isn't that hard to find from my IP address...
19:41:56 <SamB_XP> huh. for some reason when I clicked on "for site owners" at the bottom of my Live search results, the first thing on the list was about Daylight Savings Time issues, and apparantly to fix them I need to finally install SP2 :-(
19:42:05 * SamB_XP lacks the harddrive space to do this
19:45:23 <dancor> dist/build/autogen/Paths_Ta.hs:7:7:
19:45:23 <dancor>     Could not find module `Data.Version':
19:45:24 <dancor>       it is a member of package base, which is hidden
19:46:01 <chessguy> dancor, what do you get from ghc-pkg list
19:46:11 <SamB_XP> I'm guessing it is a GHC bug
19:46:17 <SamB_XP> what GHC version?
19:46:25 <dancor> 6.6
19:46:42 <SamB> no, wait.
19:46:45 <dancor> chessguy: there is a lot of pkgs, what am i looking for
19:46:47 <SamB> why is base hidden?
19:46:52 * SamB_XP silly
19:47:01 <chessguy> danuh...Data.Version?
19:47:14 <chessguy> err, dancor
19:47:25 <SamB_XP> dancor: oh, maybe you need to say that your package uses base?
19:48:26 <dancor> SamB_XP: yes of course.. thanks
19:48:56 <SamB_XP> it seems kind of silly that it is necessary to specify that you need base ;-)
19:49:49 <sorear> not at all, base doesn't use base
19:50:58 <SamB_XP> Windows 98 requires *5* reboots to install? wow!
19:51:57 <sorear> Debian requires 0.  /me feels superior
19:52:18 <SamB_XP> *0*?
19:52:26 <SamB_XP> I thought it required 1.
19:52:43 <sorear> it's *encouraged*, but there is an option to skip it
19:52:54 <SamB_XP> first boot: install stuff to harddrive (including, say, the kernel)
19:53:15 <SamB_XP> second boot: okay! (install anything else you missed the first time)
19:53:32 <sorear> Turn on, boot from CD (which has a perfectly good kernel), install stuff,
19:53:45 <SamB_XP> third boot: oops! I need to do this and that with /etc/init.d before the system gets back to proper working order...
19:53:52 <sorear> EITHER: reboot, load kernel from hdd, install everything else
19:54:13 <sorear> OR: chroot and exec the second phase install scripts while still running off CD
19:54:26 <SamB_XP> can you keep it running like that indefinately?
19:54:29 <SamB_XP> is it a good idea>?
19:54:33 <sorear> Yes, and No.
19:54:43 <SamB_XP> so, I still say that's one reboot.
19:55:05 <SamB_XP> no reboots would be if you didn't *need* to boot before installing
19:55:43 <igli> oh where's all the lovely code gone? *groan*
19:55:55 <igli> @botsnack
19:55:55 <lambdabot> :)
19:56:31 <sorear> arke, erousseau, tozefs, dureyes, NDP-Kubuntu, NDPTAL85, NDPMacBook, hb2
19:56:35 <sorear> s/hb2/gb2/
19:56:53 <sorear> those are the freenode users coming from ~nef's ISP
19:57:11 <sorear> something tells me the NDP* are bots
19:57:20 <igli> @src fix
19:57:20 <lambdabot> fix f = let x = f x in x
19:57:41 <SamB_XP> well, okay, so maybe that takes care of the logs in ~nef
19:57:46 <SamB_XP> what about the ones on meme?
19:57:57 <sorear> he's much less anonymous
19:58:04 <SamB_XP> hmm?
19:58:05 * shapr points at cmeme
19:58:06 <igli> @src type
19:58:06 <lambdabot> Source not found. It can only be attributed to human error.
19:58:19 <rabbitear> thats good
19:58:26 <sorear>      * Logs are available at ~nef/logs/tunes/, WWW-browsable at Kevin Rosenberg's Meme Log Interface.
19:58:26 <SamB_XP> so how do the ~nef logs get from clog to ~nef anyway?
19:58:27 <igli> you're absolutely right lambdabot :)
19:58:38 <sorear> SamB_XP: ~nef has the same IP as clog
19:58:45 <igli> hehe
19:59:02 <SamB_XP> sorear: you didn't mention clog as one of the irc users from ~nef's IP...
19:59:17 <sorear> yea, I filtered him out as a definite-bot :)
19:59:27 <rabbitear> I'm sure all you irc users are okay
19:59:44 <sorear> unfortunately ~nef (hcf) has a VERY dynamic IP, seen changing multiple times in an hour
20:00:09 <sorear> the 9 users are from the class B subnet registered to the RCN corporation
20:00:20 <igli> rabbitear: you are a mathematician no?
20:00:24 <SamB_XP> sorear: wow
20:00:30 <rabbitear> igli: no
20:00:33 <SamB_XP> mine doesn't change nearly that often
20:00:33 <sorear> ?
20:00:51 <sorear> i'm also googlestalking based on 7 year old logs :)
20:00:57 <rabbitear> what I say here is not necessary what I'm saying here
20:01:13 <rabbitear> isn't much, I have a purpose here...
20:01:15 <SamB_XP> sorear: um.
20:01:27 <SamB_XP> since when does bespin change IPs several times an hour?
20:01:42 <igli> ah ok
20:01:56 <sorear> SamB_XP: he also comes in from RCN directly
20:02:02 <SamB_XP> huh.
20:02:31 <SamB_XP> cmeme is commercial and clog is non-profit, interesting
20:02:57 <SamB_XP> cmeme also doesn't have a RealName
20:03:26 <SamB_XP> and cmeme doesn't respond to CTCP version like CLOG does
20:03:42 <SamB_XP> CLOG is apparantly still at version 0
20:04:57 <SamB_XP> heh
20:05:29 <SamB_XP> MS suggests to keep site hierarchies fairly flat ;-) (one to three links from frontpage to other pages)
20:08:12 <sorear> hmm, nef seems to have moved
20:08:21 <sorear> 2003 logs give a different ISP
20:08:40 <sorear> great works internet, ME (what state is that?)
20:09:06 <sorear> *nobody* within the /18 block is on freenode
20:09:36 * sorear goes back to hmenu hacking
20:11:09 <sproingie> maine
20:12:48 <SamB_XP> does RCN own the US now?
20:13:01 <shapr> Royal Canadian Newbies?
20:13:31 <SamB_XP> what is RR?
20:13:43 <rabbitear> Reading Responce
20:14:11 <rabbitear> I'll have to kick you in the shin now
20:14:28 * SamB_XP wants a pie chart of #haskell ISPs
20:14:33 <SamB_XP> or two
20:14:46 <rabbitear> *:P*
20:14:54 <chessguy> is RCN an IRC network?
20:14:57 * chessguy is clueless
20:14:58 <shapr> rabbitear: Are you learning Haskell?
20:15:08 <rabbitear> shapr: not really.....
20:15:14 <SamB_XP> RCN is Residential Cable Network
20:15:16 <rabbitear> shapr: I'm learning the locals
20:15:25 <rabbitear> shapr: there's a difference
20:15:28 <SamB_XP> they offer TV, phone, and internet
20:15:37 <SamB_XP> We get phone and 'net from them
20:15:38 <shapr> rabbitear: Why are you learning the locals?
20:15:42 <rabbitear> shapr: I have to sing sometimes without fear
20:16:12 <shapr> rabbitear: The purpose of this channel is really to to learn and teach programming, with a specialization in Haskell.
20:16:30 <rabbitear> I know C only
20:16:40 <shapr> rabbitear: Do you want to learn Haskell?
20:16:57 <rabbitear> I wrote a bunch when I was little, just going on a trip
20:17:01 <SamB_XP> if he hangs out here, he probably will
20:17:12 <rabbitear> about other people, sick of the deadity
20:17:25 <shapr> rabbitear: That sounds like randomly generated nonsense. That sort of thing will get you kickbanned if you continue it.
20:17:57 <rabbitear> well, kick me then, I'm will say that to you next time too
20:18:15 <SamB_XP> it doesn't sound like MegaHAL
20:18:22 <shapr> If you get kickbanned there isn't a next time?
20:18:32 <SamB_XP> MegaHAL would say things that were somewhat more related to other things
20:18:39 <rabbitear> shapr: I don't know
20:18:43 <SamB_XP> (or somewhat less)
20:18:59 <sorear> SamB_XP: RR is "roadrunner", Time/Warner's trademark name for their west coast cable internet offering
20:19:18 <rabbitear> *bows*
20:19:19 <shapr> rabbitear: Have you tried the Haskell tutorials?
20:19:35 <rabbitear> no... just got here today
20:20:29 <shapr> rabbitear: Try this: http://www.haskell.org/haskellwiki/Learning_Haskell
20:20:30 <lambdabot> Title: Learning Haskell - HaskellWiki
20:21:16 <SamB_XP> @go Learning Haskell
20:21:18 <lambdabot> http://www.haskell.org/learning.html
20:21:18 <lambdabot> Title: Learning Haskell
20:21:20 <SamB_XP> hmm.
20:21:40 <SamB_XP> how old is that page?
20:21:48 <SamB_XP> did we even know it was still there?
20:21:59 <rabbitear> shapr: where is your thesis statement?
20:22:46 <Jaggederest> interesting. a discordian influence in haskell.
20:23:11 <SamB_XP> 555 page views since 2004?
20:23:18 <SamB_XP> not too popular sounding...
20:23:23 <shapr> rabbitear: Seriously, please stay on the Haskell topic.
20:23:35 <rabbitear> shapr: I will try
20:23:53 <Nafai> sorear: Road Runner isn't just on the West Coast...it's also here in Texas
20:24:01 <chessguy> SamB_XP, it can't be too old, it has SOE and COFP
20:24:29 <shapr> rabbitear: If you want to chat about non-Haskell subjects with the people who frequent #haskell, try #haskell-blah, it's specifically for that sort of off-topic discussion.
20:24:35 <shapr> Jaggederest: Hail Eris?
20:24:58 <Jaggederest> shapr: I was referring to the rabbitear :)
20:26:33 <rabbitear> shapr: I'm nobody but I just got here, right? no thesis statement in your website
20:27:28 <shapr> rabbitear: I wasn't aware that I needed one?
20:28:17 <Jaggederest> see? either discordian or linguistic barriers.
20:29:00 <Jaggederest> I'm trying to figure out if it's worth building a game in haskell. Are the libs/etc up to snuff?
20:29:08 <shapr> rabbitear: I think my thesis statement would be "One day I will have a thesis."
20:29:24 <rabbitear> say that!!!
20:29:28 <rabbitear> it says " http://www.haskell.org/haskellwiki/Learning_Haskell
20:29:29 <lambdabot> Title: Learning Haskell - HaskellWiki
20:29:35 <rabbitear> sorry 1 sec
20:29:46 <shapr> Jaggederest: You won't find a pygame equivalent, but there are bindings to OpenAL, OpenGL, SDL, Cairo, gtk, gtkglarea, and lots more.
20:29:55 <shapr> rabbitear: That's not my website. That's the Haskell wikiwiki.
20:29:56 <rabbitear> it says "This portal points to places where you can go if you want to learn Haskell."
20:30:06 <shapr> Yes, it does say that.
20:30:20 <chessguy> this is a nice little site: http://www.haskell.org/complex/why_does_haskell_matter.html
20:30:21 <lambdabot> Title: The Lambda Complex
20:30:27 <rabbitear> so! is what they gonna not tell you
20:30:54 <Jaggederest> ok. I know haskell school of expression deals with GL/sound stuff, I'm thinking a game would be a fun project.
20:31:27 <rabbitear> I'm a fifth party
20:31:32 <Jaggederest> plus one might entertain the notion of selling it.
20:31:37 <shapr> Jaggederest: Some existing games written in Haskell are Frag (quake clone), Yampa Arcade (space invaders game implemented with arrows), and a tank game and a parachuting game I've seen around.
20:32:02 <SamB_XP> Jaggederest: SOE doesn't really deal with gamey stuff much...
20:32:16 <shapr> rabbitear: Dude, you're pushing it.
20:32:50 <Jaggederest> ah proof of concepts. Do they come with code? No, but the core algorithms are the same and I've done some c# d3d stuff
20:33:01 <rabbitear> shapr: yes I am, it doesn't like me
20:33:09 --- mode: ChanServ set +o shapr
20:33:12 <Jaggederest> b&!
20:33:17 --- kick: rabbitear was kicked by shapr (Kicked by shapr)
20:33:43 --- mode: shapr set -o shapr
20:33:46 <SamB_XP> remind me to check the stats in a couple of days
20:34:29 <shapr> Which stats?
20:34:35 <SamB_XP> @where stats
20:34:35 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
20:34:39 <SamB_XP> those stats
20:34:50 <SamB_XP> I want to see if it still says "nobody got kicked"
20:34:53 <shapr> hehe
20:35:25 <shapr> Jaggederest: What sort of game do you want to write?
20:35:43 <shapr> Jaggederest: Frag and Yampa Arcade come with sources.
20:35:53 <Jaggederest> sweet
20:36:47 <Jaggederest> I'm thinking a SDL-based tower defence game, since that type seems to be the next sudoku in terms of popularity
20:38:40 <shapr> If you decide to do it as open source, I think I'd enjoy hacking on that.
20:39:59 <Jaggederest> yeah, these flash ones leave a lot to be desired. I keep wanting to fix bugs but oops, closed-source binaries.
20:40:23 <shapr> Yup
20:40:29 <Jaggederest> well, effectively closed, since you can disassemble .swf but only poorly
20:40:46 <shapr> I played a few of those tower defense games recently, they're fun.
20:41:04 <shapr> Onslaught and desktop defence or something.
20:41:31 <Jaggederest> http://onslaught.playr.co.uk/ yup that's the best one so far
20:41:32 <lambdabot> Title: Onslaught
20:41:51 <shapr> desktop defence is fun also.
20:42:32 <Jaggederest> http://novelconcepts.wordpress.com/ apparently those two are making six figures off DTD
20:42:34 <lambdabot> Title: Paul & Dave&#8217;s Novel Concepts
20:43:13 <shapr> How?
20:43:24 <shapr> Advertising?
20:43:49 <Jaggederest> yes. In-game mochiads
20:44:10 <Jaggederest> plus they are making custom versions for companies' sites
20:44:17 <Jaggederest> eg wrigley gum has one
20:45:09 <sorear> Grumble, grumble.  mplus v. mappend just wasted 10 minutes or so
20:45:10 <shapr> Amazing
20:45:14 <Jaggederest> http://www.mochibot.com/shared/shared_swfdetail.html?key=7cc46d900ed3978e8a7af588dd20aa91
20:45:16 <lambdabot> Title: MochiBot.com :: SWF Detail :: Flash Element TD, http://tinyurl.com/2y7bsy
20:45:27 <shapr> Too bad Flash is closed source.
20:45:52 <shapr> Someone was writing a Haskell to Flash compiler, but I think they dropped it and never released the source.
20:46:03 <Jaggederest> yup. Might be interesting to... yes that heh
20:46:05 <sorear> @seen stepcut
20:46:05 <lambdabot> stepcut is in #xmonad, #haskell-blah and #haskell. I last heard stepcut speak 1d 43m 3s ago.
20:47:07 <cdsmith> I'm interpreting the copyright comment on the Haskell 98 report as allowing and encouraging this.  http://www.cafepress.com/cdsmithus.139965523  Anyone disagree?
20:47:13 <Jaggederest> swf internally isn't that complicated compared to most bytecode formats, it's just the edge case stuff from the proprietarp back end
20:48:53 <Jaggederest> yes it's BSD, you can sell it
20:49:43 <cdsmith> I did that so I could buy it myself.  I just want to make sure no one thinks its on the shady side.
20:50:05 <Jaggederest> nope as long as it's all there you're legit.
20:50:07 <sorear> http://www.amazon.co.uk/Haskell-98-Language-Libraries-Revised/dp/0521826144
20:50:10 <lambdabot> http://tinyurl.com/24cc3h
20:50:11 <sorear> cdsmith: ^^^
20:50:40 <cdsmith> sorear: oh, I missed that! :(  But yikes, 45 pounds!
20:51:32 <Jaggederest> yeah, the cafepress one looks like a steal :)
20:52:39 <cdsmith> Does buying the one from Cambridge Univ. Press get money to actual Haskell people, or is it all profit for unrelated publishing sorts?
20:54:08 * sorear doesn't know
20:54:21 <Jaggederest> probably at least 90% unrelated costs.
20:54:41 <cdsmith> Okay, just checking for any possible reason to pay a lot more.
20:57:42 <Jaggederest> prolly rather you buy the cheaper one and give half the difference direct :)
21:05:18 <asicard> I am using System.Directory library to handle some files. How can I test if a file is a symlink without execute a external command (using system in System.Cmd)?
21:11:49 <edwardk> haskell to flash wouldn't be that hard, same issues as compiling to javascript, but you get a faster runtime
21:11:49 <mlh_> in Posix at a guess, since symlink is a posixish thing
21:11:49 <shapr> edwardk: Would you go from STG to flash?
21:11:49 <edwardk> yeah
21:11:49 <edwardk> same approach
21:11:49 <edwardk> i'd go stg to ecmascript 4, which gives me actionscript for free ;)
21:11:49 <mlh_> @hoogle getSymbolicLinkStatus
21:11:49 <lambdabot> No matches found
21:11:49 <edwardk> and the side effect of not having expensive hash lookups for every single operation
21:11:49 <asicard> mlh_: Yes, in Posix
21:12:14 <shapr> edwardk: Did you ever find a way to get STG out of GHC?
21:13:48 <edwardk> i have an open feature request, ian punched it in for 6.8
21:17:44 <stepcut> hrm, yhc core *used* to uniquify all the variable names across all functions (as far as I could tell), but recently they added v_fail_0, v_fail_1, etc, which are only unique within a function :(
21:19:09 * stepcut is compiling haskell -> flash at this very moment...
21:25:26 <aeyakovenko> i just set up ubuntu, and i am looking for haskell-binary package, i found one here, http://www.lv.kernel.org/pub/mirrors/ubuntu/pool/universe/h/haskell-binary/, i am new to apt, so what repo would i need to add to /etc/sources.list for me to grab that package?
21:25:28 <lambdabot> Title: Index of /pub/mirrors/ubuntu/pool/universe/h/haskell-binary, http://tinyurl.com/2h7fjm
21:26:13 <stepcut> aeyakovenko: feisty ?
21:26:29 <aeyakovenko> stepcut, i am on feisty
21:27:33 <stepcut> probably the lines that contain universe on this page -> http://www.psychocats.net/ubuntu/sources#feisty
21:27:35 <lambdabot> Title: Enabling Extra Repositories
21:31:10 <aeyakovenko> why is there a pool/universe and a dists/feisty/universe?  do i need to add pool as a source?
21:31:47 <stepcut> no
21:31:48 <Jaggederest> stepcut, are you the one working on the haskell-to-flash compiler? I'd be really interested in that
21:32:15 <igli> ubuntu stepcut
21:32:27 <igli> er sorry
21:32:37 * igli wakes up
21:32:56 <stepcut> aeyakovenko: no. just the dist
21:33:30 <stepcut> aeyakovenko: the dist is a specification that says what files belong to that release (like feisty). The pool is where all the actual .debs live
21:33:33 <aeyakovenko> stepcut, well i have feisty already enabled
21:33:54 <aeyakovenko> oh i see
21:33:55 <stepcut> aeyakovenko: do you have the universe component enabled ?
21:34:10 <aeyakovenko> hmm, eb http://us.archive.ubuntu.com/ubuntu/ feisty universe
21:34:11 <lambdabot> Title: Index of /ubuntu
21:34:17 <aeyakovenko> yea i think i do
21:34:18 <stepcut> Jaggederest: yes -- soon it may even work ;)
21:34:33 <stepcut> Jaggederest: and, then I can rewrite it to not suck :p
21:34:48 <stepcut> aeyakovenko: that looks correct to me
21:35:24 <stepcut> aeyakovenko: the binary deb you want to install is, libghc6-binary-dev
21:35:38 <stepcut> aeyakovenko: which comes from the haskell-binary source deb
21:36:23 <aeyakovenko> hmm, E: Couldn't find package libghc6-binary-
21:36:31 <aeyakovenko> hmm, E: Couldn't find package libghc6-binary-dev, i mean
21:36:59 <aeyakovenko> i did an apt-get update, and it Hit http://us.archive.ubuntu.com feisty/universe Packages
21:37:00 <lambdabot> Title: Index of /
21:37:07 <stepcut> aeyakovenko: can you join #haskell-overflow, I don't want to flood the channel with this conversation
21:37:14 <aeyakovenko> sure
21:45:15 <stepcut> Jaggederest: my swf library is at: http://www.n-heptane.com/nhlab/repos/haskell-swf/ and the haskell->swf is at http://www.n-heptane.com/nhlab/repos/yhc/, but it is not really usable yet
21:45:17 <lambdabot> Title: Index of /nhlab/repos/haskell-swf
21:45:53 <emu> i just wrote (+ a b) instead of (a + b)
21:46:03 <emu> this infix stuff is too difficult for me!!
21:47:13 <stepcut> well, (+) a b, would have worked :)
21:50:23 <ddarius> @google Typed Quote/AntiQuote
21:50:25 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
21:50:31 <dons> who knew fixity decls where scoped?
21:50:36 <Jaggederest> stepcut: thanks, I'll check it out
21:50:41 <ddarius> It comes as a surprise everytime.
21:51:16 <stepcut> Jaggederest: good luck! It's a shameful mess at the moment
21:51:24 <sorear> re.
21:52:34 <Jaggederest> no problem, it's better than the alternative(s) which are figuring it out myself or programming in SWF itself :)
21:52:48 <stepcut> :p
21:53:30 <stepcut> Jaggederest: well, currently the swf library works, but needs some API improvements. The haskell->swf does not yet work properly
21:53:49 <stepcut> Jaggederest: but hopefully in the next 1-2 months
21:54:32 <Jaggederest> that's soon enough for me :) I'm not trying to build a nuke sub :)
21:57:28 <fuzan> is there any way to get at hte value being propogated in a fold?
21:58:59 <Jaggederest> fuzan: you could try using a stateful function to fold over, or something. I bet there's a better way though
22:00:16 <fuzan> Jaggederest: yah, state'll do it. i'm just trying to simplify a simple tail-recursive func without having to use state
22:20:49 <sorear> Is there a standard symbol for a monad in CT?
22:23:41 <SamB_XP> Chrono Trigger has monads?
22:24:54 <sorear> gyhfrvegyrfegyfelgf
22:25:45 <SamB_XP> that's not a very good immitation of a kitty
22:25:50 <sorear> no
22:26:00 <syntaxfree> @remember SamB Chrono Trigger has monads?
22:26:01 <lambdabot> Done.
22:26:05 <sorear> it's an imitation of forceful forehead/keyboard interaction
22:26:11 <sorear> repeatedly
22:26:37 <SamB_XP> it might be a slightly better immitation of that
22:26:56 <syntaxfree> @quote monads
22:26:57 <lambdabot> SamB says: Chrono Trigger has monads?
22:27:06 <SamB_XP> @quote monads
22:27:06 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
22:27:22 <syntaxfree> @quote monads
22:27:22 <lambdabot> gimboland says: at present i'd say "tinkering with a nuclear bomb" is approximately where i am with monads...
22:48:14 <whitenoyce> so if one can program well in haskell then it is safe to say that person understands monads?
22:48:42 <igli> other way round
22:48:47 <igli> perhaps
22:48:52 <igli> but yeah
22:48:56 <whitenoyce> heh
22:49:14 <whitenoyce> maybe it is like a triangle
22:49:25 <whitenoyce> if there are three sides then it is a triangle
22:49:33 <whitenoyce> or if it is a triangle then it has three sides
22:49:44 <igli> #haskell-blah
22:49:48 <whitenoyce> its not a condition but a definition...?
22:50:07 <igli> sorry all i heard was "blah blah blah" ;)
22:50:34 <whitenoyce> yeah i blah a lot
22:50:37 <igli> lol
22:50:38 <whitenoyce> it has left me poor
22:50:39 <ddarius> sorear: The functor is usually name T
22:50:41 <igli> me 2 :)
22:51:00 <ddarius> whitenoyce: No.
22:51:15 <sorear> ddarius: Is that an uppercase latin T or a \top ?
22:51:17 <ddarius> You understand how monads are applied to programming and semantics.
22:51:17 * igli sits corrected
22:51:36 <ddarius> sorear: Usually a bold sans serif T
22:51:41 <ddarius> The letter
22:51:59 <whitenoyce> ddarius, could you clarify?
22:52:00 <igli> functor is class?
22:52:00 <sorear> ok.
22:52:06 <whitenoyce> perhaps with an example
22:52:18 <ddarius> It is not uncommon to differentiate (the functor of) a monad from an arbitrary functor.
22:52:37 <igli> ah common idiom?
22:52:46 <ddarius> whitenoyce: Monads have many many other applications and properties that are not relevant to how they are used in Haskell.
22:52:53 <igli> hmm
22:52:57 <igli> how come?
22:53:08 <igli> ah app domain perhaps
22:53:14 <ddarius> Functor is a class and a thingy from category theory.
22:53:29 <igli> hehe who thought up thingy?
22:53:48 <igli> a meta-class?
22:56:29 <ddarius> Incidentally, a simple example of a monad that is not directly to Haskell is a closure operator in some poset.
23:06:44 <whitenoyce> ddarius, so even if you're a good haskell programmer you may still not understand monads?
23:26:31 <^buggy^> http://programming.linux.com/article.pl?sid=07/06/07/1654251&from=rss
23:26:33 <lambdabot> Title: Linux.com | It is can be LOLCODE time plz?, http://tinyurl.com/2omrlz
23:27:04 <cr> the virus :/
23:44:33 <dankna> that introductory article is both longer and less entertaining than the project's actual front page
23:48:05 <whitenoyce> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours <- much better :D
23:48:06 <lambdabot> Title: Write Yourself a Scheme in 48 Hours - Wikibooks, collection of open-content text ...
23:50:58 <whitenoyce> :map <F4> :w \| :!ghc ./% && ./a.out <- ~/.vimrc :D
