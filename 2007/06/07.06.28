00:01:06 <treble> I was just reading the comments from dons and johnnowak on p.r.c
00:01:20 <treble> and then I saw johnnowak /quit from the channel
00:01:38 <treble> kind of confusing when you aren't really paying attention to what's going on :)
00:05:31 <DRMacIver> Morning
00:34:10 <tibbe> is there a high-order function (unfoldr, foldr, etc) that captures a traversal of a list where several elements are looked at at once and some of them are merged?
00:34:39 <sorear> Like the inverse to concatMap?
00:34:40 <tibbe> like: mergeDups [1,1,2,3,4,5,2] === [1,2,3,4,5,2] although merging rules can be more complicated
00:34:52 <tibbe> cause that's a group
00:34:57 <tibbe> hmm
00:35:01 <tibbe> perhaps a groupBy
00:35:02 * sorear just read BuildBot as Bulat
00:35:12 <tibbe> but I have to preserve order
00:35:24 <tibbe> sorear: happens all the time ;)
00:35:34 <DRMacIver> > map head . groupBy (==) [1, 2, 3, 4, 5, 6, 3]
00:35:36 <lambdabot>  Couldn't match expected type `a -> [[a1]]'
00:35:38 <DRMacIver> Hm
00:35:48 <astrolabe> It sounds a bit like a parser, but to a list rather than a tree
00:36:14 <oerjan> DRMacIver: . -> $
00:36:41 <DRMacIver> > let f = map head . groupBy (==) in f [1, 2, 3, 4, 5, 6, 3]
00:36:43 <lambdabot>  [1,2,3,4,5,6,3]
00:37:10 <DRMacIver> oerjan: Yeah, I know I could do it that way. I was trying to define the function and apply it at the same time and screwed up the precedence rules. :)
00:37:27 <tibbe> DRMacIver: oh that's right, groupBy doesn't sort
00:37:33 <DRMacIver> > let f = map head . groupBy (==) in f [1, 1, 2, 3, 4, 5, 6, 2]
00:37:36 <lambdabot>  [1,2,3,4,5,6,2]
00:37:41 <DRMacIver> Yeah
00:38:28 <astrolabe> tibbe: could you write it as a fold to some intermediate structure followed by a map from that to what you want?
00:38:32 <oerjan> astrolabe: that's a lexer isn't it
00:38:49 <astrolabe> er s/map/function
00:39:02 <astrolabe> oerjan: could be
00:39:51 <tibbe> astrolabe: perhaps, so basically I have something like this: data Foo | Bar | Baz where Bar and Baz could be defined as == in the merging context so I could have data Foo | BarBaz like type
00:47:28 <matthew-_> morning #haskell
00:51:05 <setuid_w00t> What is the proper way to do      let s = a / 2    when a :: Int and I want s :: Float?
00:51:20 <int-e> let s = fromIntegral a / 2
00:57:08 <dons> i've tidied up and categorised the blog articles page, and linked to related material. http://haskell.org/haskellwiki/Blog_articles
00:57:09 <lambdabot> Title: Blog articles - HaskellWiki
01:19:27 <quicksilver> dons: nice work
01:21:00 <osfameron> ooo, http://blogs.nubgames.com/code/ is nice
01:21:04 <lambdabot> Title: Nub Games
01:21:08 <osfameron> there's a really good example of lazy IO
01:23:42 <quicksilver> osfameron: oxymoron :P
01:23:50 <quicksilver> osfameron: that's a deceiving and upsetting example of lazy IO
01:31:06 <osfameron> quicksilver: really?
01:31:59 <osfameron> I wasn't upset, though I guess I could well have been deceived :-)
01:32:14 <DRMacIver> quicksilver doesn't like lazy IO. :)
01:32:33 <quicksilver> that blog gives the impression that unsafe lazy IO is just an example of haskell's generic laziness
01:32:47 <quicksilver> whereas we all know that unsafe lazy IO is a semantic farce
01:32:55 <quicksilver> but true laziness is a beautiful thing
01:33:34 <osfameron> it looks like laziness to the untrained eye :-)
01:33:40 <Cale> Lazy IO can be made reasonably safe.
01:33:40 * quicksilver nods
01:33:51 <quicksilver> osfameron: that is, more or less, my objection
01:33:57 <quicksilver> osfameron: that's he's passing the one off against the other
01:34:17 <quicksilver> osfameron: the whole point about laziness is that it *doesn't matter* when you reduce a thunk, because the answer will always be the same
01:34:39 <quicksilver> Cale: absolutely. "reasonably"
01:34:51 <quicksilver> Cale: it should be used being cognizant of the problems, not blindly
01:35:05 <quicksilver> osfameron: that just aint true if the thunk can do IO
01:35:37 <Cale> The contents of stdin only change between invocations of the program.
01:35:43 <Cale> So getContents is safe.
01:35:54 <osfameron> but it's lazy because you're not reading a big list of files into a massive list, even though that's what you wrote
01:36:41 <quicksilver> Cale: on a system which doesn't have exclusive locking by default, another process could be stamping over that data
01:36:51 <Cale> Hm?
01:37:01 <Cale> How could another process be modifying your stdin?
01:37:06 <quicksilver> because it might be a file
01:37:11 <Cale> (apart from appending to it)
01:37:21 <quicksilver> if it's a file, they could modify it anyweher, at any time
01:37:22 <osfameron> i r in yr stdin appendingz yr files
01:37:37 <Cale> readFile is less safe, but it's safe provided that once you do it, you never modify that file again
01:37:45 <quicksilver> osfameron: yes, I'm not saying that it isn't lazy
01:37:59 <quicksilver> osfameron: I'm saying that it's not "safely lazy" in the same way that pure laziness is "totally safe"
01:38:00 <osfameron> oh, good.  Cos if you were then I didn't understand anything :-)
01:38:16 <quicksilver> Cale: unless another process modifies the file
01:38:17 <osfameron> quicksilver: it's IO, I don't care if it's safe, I want to read a file :-)
01:38:21 <Cale> Of course, regardless of whether you do modify that file, you will get a constant, if not consistent view of the file.
01:38:27 <quicksilver> right
01:38:32 <quicksilver> constant but not necessarily consistent
01:38:36 <quicksilver> that's the worrying part :)
01:38:42 <Cale> Once each character is read, it stays read.
01:38:46 * quicksilver nods
01:38:56 <osfameron> yes, but it's an introductory article trying to make IO in haskell not scary
01:39:05 <Cale> This is a problem with strict IO too.
01:39:17 <eivuokko> Cale, How would you handle error in case of reading the file?  Say user removing device?
01:39:18 <osfameron> and if you're worrying about edge cases and race conditions and locking, then that's an "advanced topic" for imperative programming too
01:39:33 <quicksilver> osfameron: but it hides problems by pretending something works, which doesn't work
01:39:38 <Cale> eivuokko: Fail to parse the file, and produce an error?
01:39:41 <quicksilver> osfameron: although, admittedly, it does work most of the time
01:40:04 <eivuokko> Cale, So are you thinking less visible lazy io than we currently have?
01:40:11 <eivuokko> *more
01:40:30 <quicksilver> Cale: hmm that is a good point actualy
01:40:31 * quicksilver ponders
01:40:56 <osfameron> quicksilver: ok.  I guess I'm failing to see a) the alternative, and b) why a "works for most reasonable definitions of 'works'" isn't appropriate for a tutorial
01:41:18 <Cale> Basically whenever you're reading from a file, if you're not doing it all at once, and you don't ask the OS to lock the file for you somehow, you have no guarantee of consistency.
01:41:45 <Cale> Regardless of the programming model you're doing that with :)
01:42:01 <quicksilver> osfameron: a) strict IO or explicit 'callback' IO (b) because haskell makes such a big thing about correctness and ref. transparency.
01:42:37 <Cale> eivuokko: less/more visible?
01:42:40 <quicksilver> Cale: yes, you're right. Maybe the exception behaviour is more worrying than the inconsistency.
01:43:18 <eivuokko> Cale, there's a lot of times you might want to ask user to make file reappear instead.
01:43:37 <eivuokko> Cale, this isn't possible (neatly atleast) in current lazy io we have?
01:43:50 <Cale> I suppose not.
01:44:07 <Cale> There are stranger things which can happen than the file just disappearing
01:44:15 <eivuokko> Uh
01:44:26 <eivuokko> It depends on your platform.
01:45:09 * quicksilver goes to read his last anti-lazy-io tirade and find if he made any other good points or was just talking rubbish
01:45:55 <osfameron> ;-)
01:46:50 <Cale> I can see a point for readFile and friends asking the host OS to put a lock on the file so that it can't be written to or deleted. That sort of messes with the case that the file you're reading is a FIFO.
01:47:22 <Cale> (but perhaps that can be a special case)
01:47:31 <eivuokko> My example (user removing device) was picked just because of locking, can't stop usb device from disappearing.
01:48:32 <quicksilver> OK, I think last time I thought this through my main objections were side-effects and particularly exceptions
01:48:42 <quicksilver> there is merit to the point that 'reading' per se isn't a side effect
01:48:54 <quicksilver> but there are issues about OS resources being consumed (file handles etc)
01:49:04 <quicksilver> http://www.haskell.org/pipermail/haskell-cafe/2007-May/025894.html
01:49:06 <lambdabot> Title: [Haskell-cafe] Network.HTTP+ByteStrings Interface--Or: How to shepherd handles a ..., http://tinyurl.com/2ltj3w
01:49:45 <DRMacIver> When I've tried to implement lazy IO in other languages, the implementation has had some nasty synchronisation possibilities.
01:49:51 <Cale> eivuokko: hehe, perhaps we need some hardware-based approach to "locking" :)
01:50:16 <Cale> That ought to piss users right off :)
01:50:48 <Cale> "My USB key is stuck!", "Oh, close the program that was reading it."
01:51:05 <eivuokko> Cale, Heh.  When you have software ready..all you need is proper hardware.  Diffrent type of haskell hw than the type usually mentioned on lists? :)
01:51:27 <quicksilver> Cale: there certainly have been removable media which worked like that in the past
01:51:49 <eivuokko> Some OSses lock CDs, yea.
01:52:33 <Cale> Yep, I'm quite used to locking CDs.
01:54:43 <Cale> quicksilver: With regard to OS resources, you're specifically concerned about the program opening too many files and not closing them?
01:54:51 <eivuokko> Hehe
01:55:05 <dons> ?users
01:55:05 <lambdabot> Maximum users seen in #haskell: 354, currently: 310 (87.6%), active: 10 (3.2%)
01:55:09 <quicksilver> Cale: well that's one example of the kind of resource problem that lazy IO can cause, yes
01:55:21 <eivuokko> Yea, I think the problem with file handles was that base library doesn't know how to do gc when no more handles are available.
01:55:36 <quicksilver> eivuokko: I'm not entirely convinced that's a whole solution, although maybe it is
01:55:46 <Cale> Of course, that problem can also happen with strict IO, but it's easier to do something about it.
01:55:50 <quicksilver> in the general case 'resource release' may be more complicated
01:56:01 <eivuokko> quicksilver, True, it is only solution to knowledgeable use of lazy io.  It is not totally transparent.
01:56:24 <quicksilver> Cale: typically it's something that is more serious if you replace 'files' with 'sockets' or 'database handles'
01:56:38 <quicksilver> Cale: since those things are often more important and/or more resource-limited
01:56:45 <quicksilver> it's the same kind of issue, though
01:58:33 <eivuokko> Well, I think lazy io that implements file region locking for area it's readin might lead to deadlocks in some cases?
01:58:41 <Cale> I'd probably be more likely to want to solve that problem on the side which is creating the limitation, though that might be an impractical approach.
01:59:03 <dons> therp: good to see patches coming in for the native code gen!1
01:59:32 <quicksilver> Cale: that sounds a little bit like hiding from the problem, but it's certainly an interesting idea
01:59:34 <ttfh> i read that as "readin' might lead to dreadlocks"
02:00:13 <quicksilver> Cale: my experience is that large or long-running programs are well advised to understand their resource profile rather precisely
02:00:23 <Cale> Well, yes.
02:00:38 <quicksilver> and I don't personally feel that lazy IO techniques mesh well with that advice :)
02:01:04 <quicksilver> it's possible that my fears could be pacified by certain GC guarantees which we don't currently have
02:01:08 <Cale> This isn't really a problem for things using lazy IO so long as they don't open up resources and hang on to them indefinitely without consuming them.
02:01:38 <quicksilver> effectively unlocking something rather like stroustrops "intialisation is acquirement, destruction is release" paradigm for automatic C++ variables
02:01:42 <Cale> If the strings in question get GC'd the handles will of course close, and if the program finishes reading, then the resources will also be freed.
02:02:13 <quicksilver> yes, hence my point about GC guarantees
02:02:17 <Cale> It's just a matter of the lazy performance model being slightly more indirect than the strict one.
02:02:24 <quicksilver> although, one again, I'm pretty leary about 'side-effects at GC time' too
02:02:50 <Cale> Well, they're appropriate side effects for GC :)
02:02:53 <quicksilver> since you can imagine rather hard-to-debug problems arising where a certain call fails or succeeds depending on the speed of the GC system
02:02:56 <Cale> They're freeing of resources. :)
02:02:59 <quicksilver> and that's not a pleasant thing to imagine
02:03:16 <Cale> In a sense, you might imagine handles as being analogous to memory.
02:03:27 * quicksilver nods
02:03:39 <quicksilver> and then the interesting debate is how far we're prepared to take that analogy
02:03:43 <Cale> It's probably worth looking at a little harder from that perspective.
02:03:46 <quicksilver> there are ways in which not all resources are like memory
02:04:58 <quicksilver> for example the way they interact with other machines
02:05:13 <quicksilver> i.e. the resource may have a bit more of an 'external' quality than memory does
02:05:37 <Cale> Does that matter so much from the program's perspective though?
02:05:45 <quicksilver> I think so, yes
02:05:54 <quicksilver> the GC subsystem "owns" your heap
02:06:06 <quicksilver> it has considerable ability to consider strategies for managing it
02:06:11 <quicksilver> and look after it well
02:06:18 <quicksilver> it may be less informed about external resources
02:18:07 <therp> dons: most of them are trivial minor fixes :)
04:36:28 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
04:36:28 --- topic: set by dons on [Sun May 27 19:49:12 2007]
04:36:28 --- names: list (clog eddyp boegel triple_ Laney Rasser bgeron yakov quasisane moonlite_ chris2 ski ptx careo ToRA jessejones ChilliX SamB_XP_ mm_freak cognominal_ Nafai Cale JohnMeacham dcoutts_ emm- morner eivuokko kaol Wallbraker Saizan emu Choko BCoppens arag0rn GeoBesh helmut Poeir mornfall wolverian cernd kenn matthew_- joe_k mathrick thoughtpolice timchen1` dylan jmob xwl ont rho roconnor kpreid Pupeno2 therp malcolmw chrismbrown Cheery moonlite)
04:36:28 --- names: list (mdmkolbe|work hkBst triplah_ tommyd Lamperi zugz JaffaCake dfranke_ lome Adamant vydd _frederi1_ mux_ int-e astrolabe Wild_Cat borism alvarezp alexj shawn_ np amiddelk SamB nemequ Jaak dancor eno Tanuk slipstream toxic ttfh dblhelix RichardG guenni zames seancorfield progexp blackdog gattocarlo Mitar Vq^ gds noj benny sphynx rashakil quicksilver koala_man Alleria pejo aheller wilx ulfdoz ozone_ zilt mightybyte Thomas2 Syzygy- phoniq arcatan)
04:36:28 --- names: list (jql earthy aleator arguile_ fean yosemite pragma_ BobFunk ttmrichter fatsauce dfranke nn-firedragon tizoc_ Clintach_ bos mrsolo Muad_Dib z` TSC sioraiocht koffein_ beelsebob scook0 Lemmih lambdabot xinming Plareplane jatqceer vincenz dcoutts jyasskin lumi cafecubita JKnecht kosmikus heanol desp tmoertel_away Eelis a-priori_ dfeuer liyang Averell rretzbach dino- ksandstr Uz_ |Jedai| Souwh bct ohmega vstranger Dunearhp integral Tigge mattrepl)
04:36:28 --- names: list (wchogg bluestorm_ Xgc boyscared meester bd_ matthew-_ Eidolos greenrd nominolo norpan timthelion LoganCapaldo Shimei2 dblog noclouds agoode Shimei sabakas1 dibblego bohanlon mr_ank moconnor jdev mlh saccade gkr IvdSangen Lunar^ Modius profmakx GeoBes1 raxas pupeno_ TwigEther ibid Raystm2 Korollary Igloo jewel Metabol jcreigh siti atsampson Philippa psnl encryptio thedatabase erider acura jre2 ADEpt xerox araujo opqdonut_ kpk qwr cmeme)
04:36:28 --- names: list (eal shapr Tychom MyCatVerbs ph8 andun falconair stevan jle jaapweel GNU\caust1c Lunchy Khisanth Excedrin sm yaarg yahooooo audreyt fnordus Vulpyne mattam arjanoosting michie1 Boney felipe Botje agemo yango ari Shoragan sieni cinimod dgriffi3_ osfameron ray Japsu SimonRC kalven DRMacIver largos_ lispy cods lucca tessier_ hellige edwinb saturday jbalint Shurique allbery_b Nanar kolmodin dons audreyt_ _rey cjay shachaf |Steve| Spark c masak)
04:36:28 --- names: list (magagr nothingmuch petekaz dvekravy ski_ opqdonut nornagon orbitz thedward cameron Heffalump newsham flux bdash balodja pingu xsdg tuukkah qz psykotic levitation[A] @ChanServ tessier)
04:38:06 <rretzbach> mm_freak: Thanks,l it worked I blew them away!
04:38:40 <mm_freak> hehe congrats
04:38:53 <quicksilver> rretzbach: awesome :) grats
04:41:26 <rretzbach> Thank you both :)
04:41:48 <rretzbach> They said it was one of the best presentations of all of our apprentices
04:48:48 <desp> is it possible to overrule an instance declaration with a new one?
04:49:05 <desp> i.e.  newtype Foo = Int  instance Show Foo = ...
04:49:15 <desp> er
04:49:18 <desp> type Foo = Int
04:49:24 <beelsebob> no, you need to use a newtype
04:49:29 <desp> right
04:49:34 <beelsebob> type litterally means "synonym"
04:49:45 <beelsebob> the compiler can just go about replacing Foo with Int, and it should work
04:49:50 <desp> ah
04:51:28 <quicksilver> it is an open problem to have a good way of having multiple instances around
04:51:32 <quicksilver> and being able to choose between them
04:51:40 <quicksilver> I think a good solution to this would be preferable to the newtype stuff
04:51:47 <beelsebob> ditto
04:52:03 <beelsebob> there are *many* times I want to have multiple definitions of equality for the same type
04:52:29 <quicksilver> I liek the idea of something lexically scoped
04:52:40 <beelsebob> hmm, not so sure I do
04:52:44 <quicksilver> named instances, and a lexical construct to introduce the one you want
04:52:52 <beelsebob> I'm not sure I've yet seen a satisfactory way of doing it
04:52:58 <earthy> that sounds like a lot of typing
04:53:05 <quicksilver> with PointWiseEquality (a == b)
04:53:14 <quicksilver> where 'PointWiseEquality' is the instance name
04:53:18 <earthy> so what would it default to? :)
04:53:19 <mm_freak> should i write a finite field type for GF(p) explicitly or do it implicitly in my code?  The explicit version would be nicer, but also slower, wouldn't it?
04:53:28 <scook0> isn't that (multiple instances) the sort of thing ML-style modules are supposed to be good at?
04:53:35 <quicksilver> earthy: if there is only one instance in lexical scope, it defaults to that
04:53:37 <scook0> (for certain taskys, anyway)
04:53:47 <quicksilver> earthy: if there are multiple then I'm not sure, probably an error message
04:53:58 <earthy> quicksilver: but for most interesting datatypes it wouldn't be the only instance in scope
04:54:13 <quicksilver> earthy: you could put 'with' at a higher scope
04:54:19 <quicksilver> earthy: perhaps as high as 'whole file'
04:54:35 <quicksilver> my syntax is only an example
04:54:40 <quicksilver> there are probably neater ways to write it
04:54:47 <quicksilver> but the I like a lexical approach, personally
04:54:55 <earthy> so, with PointWiseEquality with OrdinaryEquality (a == b)  would have to work, right?
04:55:26 <earthy> there's ambiguity in the expected semantics of that second with
04:55:52 <earthy> plus, you'd really want the argument to with be a first-class citizen
04:55:59 <earthy> that can be passed to other functions
04:56:11 <earthy> gets messy real quickly
04:57:13 <quicksilver> earthy: I would see that like let a = 1 in let a =2 in a
04:57:19 <quicksilver> earthy: i.e. inner scope has priority
04:57:29 <quicksilver> earthy: that is what I meant by 'lexical scope' in fact
04:57:45 <earthy> quicksilver: right, but I'd expect the PointWiseEquality instance of == to also use another == itself
04:57:53 <quicksilver> that's ok
04:57:56 <quicksilver> that doesn't matter
04:58:02 <quicksilver> it's not DYNAMIC scope, it's lexical
04:58:05 <earthy> how would you specify which one to use? :)
04:58:11 <quicksilver> what is in scope inside the definition is up to you
04:58:31 <earthy> yep, but you don't gain much in flexibility that way
04:58:34 <quicksilver> well typically point-wise equality is defined by another == on the inside type
04:58:38 <quicksilver> not the same type
04:58:41 * earthy nods
04:58:43 <quicksilver> so actually I don't think that is a good example
04:58:52 <earthy> but suppose there are multiple instances of == on the internal type
04:59:00 <quicksilver> then you choose the one you want
04:59:04 <earthy> when? :)
04:59:07 <quicksilver> inside the definiton of PointWiseEquality
04:59:43 <earthy> right. so PointWiseEquality now suddenly can only use the default == to be in scope
04:59:45 <quicksilver> instance Eq Foo PointWiseEquality where (==) a b = (with SomeOtherEquality ...)
04:59:58 <earthy> given that the elements are of arbitrary type
05:00:01 <quicksilver> no, because PointWiseEquality is an instance declaration which is a normal expression
05:00:11 <quicksilver> and since it's a normal expression it can pull any other scope in it wants to
05:00:33 <earthy> yeah, okay, but suppose we have instance Eq ([a]) PointWiseEquality where (==) a b = ....
05:00:47 <earthy> now the internal == in the definition needs to come from somewhere
05:01:04 <earthy> but you don't necessarily know the full set of instances of Eq for a
05:01:27 <earthy> so there's a fixed default determined by the library writer
05:01:33 <earthy> that can not be changed
05:01:40 <earthy> kind of defeats the purpose, doesn't it? :)
05:02:14 <quicksilver> no, it doesn't
05:02:19 <quicksilver> that's just one particular instance
05:02:27 <quicksilver> erm, poor choice of word
05:02:34 <quicksilver> that's just one particular example of the problem
05:02:43 <quicksilver> it does gain you significant flexibility we don't currently live
05:03:01 <quicksilver> e.g. the ability to choose between two different Monoid instances for something
05:03:15 * earthy nods
05:03:26 <earthy> but newtype already gives you that flexibility
05:03:38 <earthy> at a smaller cost
05:03:45 <earthy> imho
05:05:23 <quicksilver> I disagree
05:05:30 <quicksilver> I think my cost can be smaller
05:05:40 <quicksilver> but without a couple of detailed worked examples it will be hard to show you that
05:05:47 * earthy nods
05:06:02 <earthy> I can see where with might help
05:06:07 <quicksilver> if you're dealing with more than one class
05:06:19 <quicksilver> than a newtype forces you to choose the instances 'all together'
05:06:30 <quicksilver> where a instance-choosing syntax would let you mix and match
05:07:14 <earthy> hm. well, the main advantage is adding another namespace for the instances to live in
05:07:18 <earthy> rather than in the type namespace
05:07:49 <quicksilver> yes, that's another way of looking at it
05:13:24 <bvd> Hello, quick question: which is faster? 'consumer [f x | x <- producer, p x]' or 'consumer $ map f $ filter p producer' or are they equally fast?
05:13:59 <bvd> (I thought the latter was better suitable for list fusion)
05:14:42 <ttfh> I think it's the same, but I'm guessing
05:14:48 <dons> should be pretty much the same. list comprehensions fuse too
05:14:56 <dons> though they're a little more complex to desugar
05:15:02 <dons> check the output with -O2 -ddump-simpl
05:15:22 <bvd> dons: good tip!
05:15:40 <dons> also, -ddump-simpl-stats will tell you how many fusion sites are found
05:16:38 <ttfh> Hmm, I like the one that doesn't use list comprehension better, though I'm not sure why, just a matter of taste maybe
05:17:04 <quicksilver> the fusion rules were explicitly design to be sure they worked with list comprehensions
05:17:07 <quicksilver> I believe
05:17:30 <ttfh> but I think I read a blog post or somesuch saying that list comprehensions should be avoided, but I don't remember if it was just in certain situations
05:17:40 <quicksilver> that sounds like FUD to me
05:17:46 <quicksilver> list comprehensions are awesome
05:17:49 <bvd> I though the paper about Stream fusion could handle list comprehnsions better?
05:18:06 <quicksilver> ghc's built in foldr/build fusion works with list comps
05:18:10 <dons> not true! list comprehensions are harder under stream fusion, currently :-)
05:18:20 <Philippa> list comprehensions're bad if your expected readers aren't particularly good with them and you're doing complex things that can be written well another way
05:18:35 <dons> and ghc's built in list comprehension desugaring produces foldr's and build. perfect for fusion
05:18:35 <quicksilver> Philippa: that sounds reasonable
05:18:41 <ttfh> So it comes down to what read better
05:18:46 <quicksilver> Philippa: applies to any language feature maybe :)
05:18:47 <ttfh> reads better
05:19:18 <dons> bvd: yeah, the last stream fusion paper gives on desugaring of list comps to streams
05:19:20 <Philippa> quicksilver: yeah, but they're also one of the haskell features that're more popular amongst academics who've spent a fair amount of time bashing set comprehensions than they are with everyone else
05:19:23 <quicksilver> > let getLefts l = [a | Left a <- l] in getLefts [Left 1, Right 2, Right 3, Left 4, Right 5]
05:19:25 <lambdabot>  [1,4]
05:19:26 <dons> there's some other ideas floating around for how to do itbetter
05:19:37 <quicksilver> ttfh: list comprehensions are lovely for that kind of thing :)
05:19:46 <dons> Philippa: you should see the list comprehensoins used in ~1990-era haskell
05:19:52 <dons> its crazy. they're *everywhere*
05:20:11 <Philippa> that doesn't surprise me
05:20:56 <opqdonut> a set-comprehension formulation of a logic programming language like prolog
05:20:57 <opqdonut> hmmm
05:26:58 <quicksilver> earthy: that's right, there is this proposal by Kahl and Scheffczyk
05:27:14 <quicksilver> earthy: although it's not the same as I was suggesting it does have some features
05:27:31 <quicksilver> they essentially make dictionary application (optionally) explicit
05:27:36 <quicksilver> so you need to apply to each site
05:27:55 <quicksilver> my proposal is to use the existing defaulting mechanism, but allow you to change the defaults lexically
05:29:43 * pesco waves at shapr
05:33:50 <bvd> Ok, I tested how well list fusion could be applied to list comprehensions. The result follows:
05:33:59 <bvd> http://hpaste.org/429
05:34:37 <bvd> It seems like it's faster without list comprehensions.
05:35:02 <dons> sum won't fuse though
05:35:04 <dons> its a foldl.
05:35:16 <dons> so there'll be no fusion with sum and a list comprehension
05:35:20 <dons> while map . filter will fuse
05:35:20 <earthy> hm. no haskell weekly news the past 3 weeks?
05:35:23 <bvd> dons: oops
05:35:28 <dons> earthy: right, busy!
05:35:36 <dons> bvd, you could write a foldr version of sum
05:35:41 <dons> (or use our streams library ;)
05:35:54 <earthy> dons: yeah, I can imagine, what with getting papers accepted. :)
05:36:06 <bvd> dons: how do I use the streams library... is it cabalised?
05:36:11 <dons> and trying to get my thesis written, earthy :)
05:36:14 <earthy> still. pity. now I have to start reading the haskell lists with <Delete>
05:36:22 <dons> bvd, it is, but we've not released it. (experimental stuff)
05:36:37 <bvd> dons: darcs repos anywhere?
05:36:38 <dons> earthy: i've got most of an issue prepared, so i'll see i can get the issue out tomorrow
05:36:50 <dons> bvd, yep, www.cse.unsw.edu.au/~dons/streams.html
05:36:59 <dons> import Data.List.Stream
05:37:02 <bvd> dons: thx
05:37:15 <dons> you should be able to get by with just darcs get --partial http://www.cse.unsw.edu.au/~dons/code/streams/list
05:37:15 <lambdabot> Title: Index of /~dons/code/streams/list
05:37:34 <bvd> dons: I'm going to try it when I have time... thanks alot!
05:38:01 <dons> yeah, we should really release it for general use (even without the ghc support for list comps and so on, its still useful)
05:38:15 <dons> the foldl' it has is a bit faster :-)
05:39:18 <dons> dcoutts: what do you think, we should bundle up a standalone lists-via-streams lib, for general consumption
05:39:32 <dons> should be a fairly easy replacement for some list-speed-critical apps
05:55:38 <banbh> I get a "Functional dependencies conflict" between the two instances in http://hpaste.org/430
05:56:31 <banbh> Is the problem that the s in the first instance could be of the following kind: a->s
05:56:34 <quicksilver> banbh: and, indeed, they do :)
05:56:50 <quicksilver> banbh: you have promised that the first param determines the second
05:56:52 <banbh> thus creating the conflict?
05:56:59 <quicksilver> and then you say that the second can be Bool for anything :)
05:58:12 <banbh> I was hoping to limit the s in the first instance to simple types and avoid the conflict
05:58:31 <quicksilver> you can't do that I'm afraid
05:58:40 <quicksilver> haskell doesn't have an airtight definition of 'simple types'
05:58:42 <quicksilver> for one thing
05:58:44 <banbh> i was afraid of that
05:58:49 <quicksilver> you could try removing the fundep completely
05:58:51 <dons> wow, scary, on a weird 9/11 conspiracy mailing list, i find a crank using haskell to explain the physics that proves the world trade centres must have been subject to a controlled demolition.
05:58:52 <quicksilver> I'm not sure it's helping you
05:59:02 <quicksilver> but then you still have overlapping isntances
05:59:06 <dons> its a great day when the conspiracy theorists are using haskell too
05:59:11 <quicksilver> ah, no you don't
05:59:17 <crazy_coder> hello everyone
05:59:24 <crazy_coder> I am writing a small parser
05:59:29 <quicksilver> banbh: remove the fundep and play with that
05:59:29 <banbh> can i limit things by kind?
05:59:39 <banbh> ok.  thx
05:59:45 <quicksilver> fundeps are only there to help resolution
05:59:53 <quicksilver> code without fundeps will always work
05:59:56 <quicksilver> but may need more type annotations
06:00:07 <banbh> interesting
06:00:07 <crazy_coder> It basically reads a text file and rewrites the entire text in lines containing not more than n characters
06:00:15 <quicksilver> the fundep basically says "if you've managed to unify this type, you know this type too"
06:00:20 <crazy_coder> I am having a small problem though
06:00:45 <crazy_coder> hPutStrLn requires a handle and a string as input
06:01:03 <crazy_coder> But I have a list of strings as output of a function
06:01:18 <quicksilver> then you want to run hPutStrLn lots of times over the list
06:01:21 <quicksilver> so you use mapM
06:01:27 <crazy_coder> mapM ?
06:01:39 <crazy_coder> let me check
06:01:54 <quicksilver> mapM (hPutStrLn outputhandle) list_of_strings
06:02:05 <crazy_coder> Thanks
06:02:06 <crazy_coder> :)
06:02:08 <quicksilver> :t \o l -> mapM (hPutStrLn o) l
06:02:10 <lambdabot> Not in scope: `hPutStrLn'
06:02:13 <quicksilver> bah
06:02:21 <quicksilver> :t \o l -> mapM (Sytem.IO.hPutStrLn o) l
06:02:23 <lambdabot> Couldn't find qualified module.
06:02:26 <quicksilver> :t \o l -> mapM (System.IO.hPutStrLn o) l
06:02:29 <lambdabot> GHC.IOBase.Handle -> [String] -> IO [()]
06:02:42 <quicksilver> mapM_ might have a more elegant type
06:02:46 <crazy_coder> Its in prelude right ?
06:02:47 <quicksilver> but very likely it doesn't matter :)
06:03:03 <quicksilver> it's in Control.Monad but I think it's in prelude too
06:03:17 <crazy_coder> do I have to import anything for that ?
06:03:38 <quicksilver> you shouldn't
06:03:41 <quicksilver> I don't think
06:05:41 <crazy_coder> Ah I am getting a parse error
06:05:56 <quicksilver> could be indentation
06:05:59 <quicksilver> hpaste it if you like
06:05:59 <crazy_coder> indentation is wrong somewhere
06:06:08 <crazy_coder> I'll figure it out. Thanks
06:06:10 <crazy_coder> :)
06:10:44 <dons> someone should really write a Flying Spaghetti Monad
06:10:58 <dons> f :: a -> FSM a and friends
06:11:01 <crazy_code1> I am getting a bit anxious to execute this .
06:11:13 <crazy_code1> http://hpaste.org/431
06:11:35 <dons> moin moin, Mr. Apfelmus!
06:11:55 <crazy_code1> i am getting parse error on last where
06:11:58 <quicksilver> crazy_code1: you can't use a where there
06:12:01 <crazy_code1> 'where' command
06:12:02 <apfelmus> dons: Hi :)
06:12:04 <crazy_code1> why ?
06:12:06 <quicksilver> crazy_code1: 'where' can only scope over declarations
06:12:12 <quicksilver> and there isn't a declaration there to scope over
06:12:17 <ndm> dons: instance Creator FSM where - parameterise it so you can choose your creator
06:12:31 <quicksilver> crazy_code1: you could close the ) before the where
06:12:38 <quicksilver> crazy_code1: drop the where back to the left margin
06:12:47 <quicksilver> crazy_code1: and then it scopes over the whole
06:12:49 <quicksilver> crazy_code1: ah, no you couldn't
06:12:55 <quicksilver> crazy_code1: it woudln't have access to 'contents' then
06:13:04 <quicksilver> crazy_code1: just inline doWrite :P
06:13:10 <crazy_code1> quicksilver: ok Thanks
06:13:11 <dons> ndm, good idea!
06:13:14 <apfelmus> dons: hm, i now have two libraries where I think that the interface can be changed
06:13:24 <crazy_code1> quicksilver++
06:13:27 <apfelmus> should i post that to the libraries list?
06:13:46 <dons> apfelmus: please do. if you feel very strongly, you could make it a 'proposal'
06:13:55 <quicksilver> :t Control.Exception.bracket
06:13:55 <crazy_code1> I didn't understand why one can't use a where like this ?
06:13:57 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
06:14:10 <quicksilver> crazy_code1: it's just syntax
06:14:10 <apfelmus> well, it's not the standard libraries
06:14:16 <crazy_code1> Ok
06:14:18 <quicksilver> crazy_code1: where only goes over delcarations
06:14:19 <crazy_code1> :)
06:14:20 <dons> ok, then just to the mailing list.
06:14:22 <apfelmus> and to some extend an implementation issue
06:14:23 <crazy_code1> Thanks :)
06:14:27 <quicksilver> crazy_code1: there are probabyl good reasons where it would be hard to parse
06:14:29 <quicksilver> I'm not sure :)
06:14:40 <dons> crazy_code1: formatting, http://hpaste.org/431#a1
06:14:43 <apfelmus> the other option would be to e-mail the authors only
06:14:50 <dons> apfelmus: which libraries?
06:14:54 <apfelmus> but i have some neat idea for a list post :)
06:14:58 <dons> if they're semi-core, then libraries@ is good
06:15:00 <quicksilver> dons: that's a scoping error on 'contents'
06:15:11 <dons> oh, 'contents' too, yes.
06:15:34 <apfelmus> Meacham's Frisby and O' Sullivans's FileManip
06:15:37 <edwardk> @seen igloo
06:15:37 <lambdabot> igloo is in #haskell-soc, #haskell, #ghc and #darcs. I last heard igloo speak 37m 18s ago.
06:15:42 <Igloo> Hello
06:15:45 <quicksilver> apfelmus: what sort of interface change (I ask out of curiosity only)
06:15:45 <edwardk> heya
06:16:01 <crazy_code1> dons: do I have to modify your code too ?
06:16:23 <apfelmus> quicksilver: well, P s a can be made a monad.
06:16:31 <dons> crazy_code1: hehe, no, just take it as formatting advice :-)
06:16:47 <dons> apfelmus: yes, i'd start on libraries@, and also CC the authors
06:16:49 <apfelmus> and in FileManip, the FindClause a things should be demonadified
06:17:04 <crazy_code1> dons: Thanks
06:17:07 <crazy_code1> :)
06:17:07 <dons> apfelmus: any thoughts on where this function should live? -->
06:17:08 <dons> maybeToMonadPlus :: MonadPlus m => Maybe a -> m a
06:17:08 <dons> maybeToMonadPlus = maybe mzero return
06:17:16 <apfelmus> Data.Maybe ?
06:17:25 <dons> (to avoid the monad-creep in list functions we see..)
06:17:48 <apfelmus> yeah, the lookup :: Monad m => ... -> m a makes me crazy :)
06:17:51 <dons> the other place would be in Control.Monad with 'guard'
06:17:58 <apfelmus> ?type guard
06:17:59 <dons> :t guard
06:18:03 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:18:04 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
06:18:21 <quicksilver> dons: I think the 'justification' for using 'm' is that 'fail' takes a string
06:18:26 <apfelmus> the name is too long, though :)
06:18:33 <dons> yes, needs a proper name.
06:18:33 <quicksilver> dons: "Nothing" and 'mzero' both can't take strings
06:18:44 <apfelmus> quicksilver: ah, good point
06:18:46 <dons> quicksilver: good point.
06:18:57 <quicksilver> dons: it drives me crazy too, but I understand that libraries want to attach error messages to their failures :(
06:19:07 <dons> a way to wrap properly-Nothings should be provided, I think
06:19:29 <dons> yes, maybe we should be using Either more widely. oh well.
06:19:43 <ndm> i think Maybe is the way to go
06:19:44 <apfelmus> yeah, Either is probably the right choice then
06:19:53 <ndm> all these monads are horrible, infecting things like lookup
06:20:06 <dons> a lot of these functions have only a single failure case though
06:20:17 <dons> so Maybe is reasonable there.
06:20:24 <araujo> morning
06:20:34 <quicksilver> apfelmus: but Either can't be a Monad in h98
06:20:41 <quicksilver> apfelmus: you need MPTCs to write the monad instance :(
06:20:46 <quicksilver> apfelmus: tis all a bit of a mess
06:20:47 <apfelmus> huh?
06:20:50 <ndm> how many people really use anything other than Maybe in Data.Map.lookup
06:21:03 <dons> ndm, i once used IO in a blog post :-)
06:21:05 <apfelmus> instance Monad (Either a) where
06:21:21 <quicksilver> apfelmus: the library instance requires (Error a)
06:21:22 <ndm> dons: blog post's don't count
06:21:23 <dons> :t lookup -- the true lookup!
06:21:25 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:21:33 <quicksilver> apfelmus: and a becomes a second parameter of the monad
06:21:43 <ndm> the true lookup doesn't have those forall's there
06:21:50 <dons> they're implicit ;)
06:22:03 <dons> :t Data.Map.lookup -- the pretender
06:22:05 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
06:22:06 <quicksilver> ndm: one might use IO occasionally, but I agree it's the less common case
06:22:24 <crazy_code1> illegal operation (handle is not open for reading)
06:22:27 <ndm> quicksilver: i'd call it ridiculously rare...
06:22:28 <crazy_code1> what does this mean
06:22:50 <apfelmus> quicksilver: *confused* but you can make Either a monad nonetheless?
06:22:50 <dons> crazy_code1: btw, your bracket code is the same as withHandle I think
06:23:00 <quicksilver> apfelmus: you can, but not give it a sensible implementation of faile
06:23:05 <apfelmus> I mean, no need for MonadError to make Either a monad
06:23:08 <quicksilver> apfelmus: since fail has type String -> m a
06:23:11 <dons> sorry, withFile, crazy_code1 :
06:23:12 <dons> withFile :: FilePath -> IOMode -> (Handle -> IO r) -> IO r
06:23:12 <dons> withFile name mode = bracket (openFile name mode) hClose
06:23:16 <quicksilver> :t fail
06:23:18 <crazy_code1> dons: what is withFile ?
06:23:19 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
06:23:29 <dons> System.IO.withFile (maybe its just in ghc 6.6?)
06:23:34 <quicksilver> apfelmus: so you need to be able to 'coerce' that string into your a
06:23:39 <apfelmus> ah
06:23:41 <quicksilver> apfelmus: which is what the Error instance is for
06:23:58 <apfelmus> ok, so what's strange about the Error class then?
06:23:59 <quicksilver> apfelmus: it's a bloody mess, I tell you :)
06:24:00 <crazy_code1> dons: so what should I do now ?
06:24:18 <dons> crazy_code1: well, just be aware that your 'bracket' code is a reimplementation of withFile :-)
06:24:30 <crazy_code1> But I am getting an error
06:24:31 <apfelmus> i mean, i still don't see why I'd need MPTC to make Either an instance of Monad
06:24:33 <crazy_code1> illegal operation (handle is not open for reading)
06:24:36 <dons> the 'handle not open' issue is somethiing else.
06:24:46 <dons> usually you're trying to read after a handle is closed?
06:24:54 <crazy_code1> oh
06:24:57 <MyCatVerbs> Attempting to fread() before fopen() or after fclose()
06:25:00 <quicksilver> apfelmus: class Monad m => MonadError e m | m -> e where
06:25:04 <MyCatVerbs> You naughty, naughty person.
06:25:05 <quicksilver> apfelmus: fundeps + MPTCS
06:25:09 <ari> @vote take_fail_out_of_Monad yes
06:25:09 <lambdabot> voted on "yes"
06:25:12 <dons> i don't think you do just for Either
06:25:18 <dons> but for the general Error class, it creeps in.
06:25:20 <dons> instance (Error e) => Monad (Either e) where
06:25:20 <dons> 	return        = Right
06:25:20 <dons> 	Left  l >>= _ = Left l
06:25:20 <dons> 	Right r >>= k = k r
06:25:22 <dons> 	fail msg      = Left (strMsg msg)
06:25:22 <apfelmus> sure, but that's something different
06:25:24 <dons> no MPTCs.
06:25:35 <dons> oh, Error. hmm. weird.
06:25:37 <apfelmus> i mean, MonadError is more than Monad
06:25:38 <dons> for strMsg
06:25:42 <crazy_code1> But my code looks fine, doesn't it ?
06:25:57 <dons> oh, and Error is fine. its MonadError that's the issue
06:26:08 <dons> class (Monad m) => MonadError e m | m -> e where
06:26:08 <dons> 	throwError :: e -> m a
06:26:15 <apfelmus> quicksilver: you don't get the MonadError convenience without MPTC, of course
06:26:17 <dons> should be a class-associated type 'e' :-)
06:26:27 <apfelmus> yes!
06:26:27 <quicksilver> apfelmus: yes, I think yoyu're right
06:26:35 <quicksilver> apfelmus: I think you can do something sensible without the MPTC part
06:26:42 <quicksilver> apfelmus: I wonder why it sin't separated out
06:27:02 * apfelmus waits impatiently for associated type synonyms
06:27:10 <dons> yes, they're in the head now
06:27:20 <dons> so we must be pretty close to being able to reimplement mtl to be less sccary
06:27:24 <apfelmus> data types or type synonyms?
06:27:29 <dons> ah, but maybe no synonyms yet.
06:27:31 <apfelmus> data types are in head
06:27:33 <dons> just data and newtype
06:27:36 <crazy_code1> can anyone tell me what the solution to my problem is ? Pls
06:27:37 <apfelmus> yeah
06:27:47 <dons> crazy_code1: where's your latest code?
06:28:07 <quicksilver> dons: although to maintain hugs compatibility for mtl
06:28:12 <araujo> hhmm
06:28:16 <quicksilver> dons: there will be some conditional pain :)
06:28:21 <dons> mtl' :-)
06:28:25 <quicksilver> dons: unless someone is porting ATs to hugs
06:28:27 <araujo> anyone knows a program to edit html online?
06:28:32 <araujo> something like a wiki
06:28:40 <crazy_code1> http://hpaste.org/432
06:28:42 <quicksilver> araujo: there are javascript richt text editors
06:28:47 <apfelmus> as i see it, they screwed up a bit on type inference for type synonyms
06:29:10 <quicksilver> crazy_code1: you are printing back to the same file handle you're reading from
06:29:15 <quicksilver> crazy_code1: that seems surprising :)
06:29:17 <dons> synonyms were the hardest I think.
06:29:22 <apfelmus> yes
06:29:35 <apfelmus> iirc, the paper showed how type inference would work
06:29:45 <apfelmus> but it doesn't work :)
06:29:50 <crazy_code1> quicksilver: I want to actually modify the file
06:29:55 <dons> the plan is now to have class-associated classes too
06:29:59 <dons> which should be much fun
06:30:02 <crazy_code1> so I print it to the same file
06:30:19 <crazy_code1> But i guess its not allowed then ....
06:30:27 <dons> solve the old Set/Monad-with class Ord issue.
06:30:36 <crazy_code1> So how to write to a new file ?
06:30:49 <dons> crazy_code1: ah you'll need to read the data strictly, and open the handle for reading and writing, otherwise write to a new file
06:30:58 <apfelmus> interesting. how would that look like?
06:31:00 <dons> mutating a file inplace is a bit like mutating a variable: evil
06:31:02 <quicksilver> crazy_code1: open anoth3er file in write mode
06:31:17 <crazy_code1> how to delete and rename ?
06:31:17 <quicksilver> crazy_code1: otherwise you have to read it all strictly, hSeek to the begining of the file, and write again
06:31:54 <araujo> quicksilver, wouldn't you know one by any chance? :-)
06:31:59 <crazy_code1> what does strictly imply ?
06:32:14 <dons> crazy_code1: removeFile and renameFile, in System.Directory, iirc
06:32:26 <quicksilver> crazy_code1: hGetContents is an evil evil thing, which only reads on demand :)
06:32:40 <crazy_code1> iirc ? another library ?
06:32:53 <quicksilver> annoyingly there isn't an out-of-the-box strick hGetContents AFAIK
06:32:55 <dons> apfelmus: slides here on the new stuff, 'http://programming.reddit.com/goto?id=1z3or'
06:32:55 <crazy_code1> oh ok
06:33:14 <quicksilver> crazy_code1: I'd start by writing to a new file to be honest
06:33:25 <quicksilver> crazy_code1: think about other ways to do it when you've got that working :)
06:33:41 <apfelmus> dons: thanks! /me reads
06:33:43 <crazy_code1> quicksilver: Thanks
06:34:55 <quicksilver> dons: class-associated-class or type-associated-class?
06:34:59 <dons> i note it says on the last slide 'synonym families: partially implemented'
06:35:12 <dons> quicksilver: class families (i think is the official ame)
06:35:46 <dons> class Set s where class Constraint s a ; empty :: s a ; insert Constraint s a => ...
06:36:00 <dons> instance Set [] where class Eq a => Constraint [] a
06:36:16 <dons> so, associate a class you want to use with your instance
06:36:23 <dons> Ord for those who have it, Eq for the other guys
06:36:44 <dons> 'associated class families' is the other name
06:36:45 <quicksilver> dons: gramattaically, 'Constraint' is binding a local name to an unknown class?
06:37:08 <dons> yeah, naming a class to be specified with the instance, i think
06:37:49 <dons> so the Set class lets instances use some class 'Constraint', rather than fixing on Ord.
06:38:17 <dons> see slide 24 and onwards
06:38:17 <quicksilver> dons: but how is the definition of Set supposed to say 'Erm, I said I'd accept any class 'Constraint' but actually I do rather need it to be a class which can behave like Eq or Ord' ?
06:38:53 <dons> not sure, I'd imagine hmm, you have at least Eq ?
06:39:04 <dons> class Eq a => MyC a
06:39:07 <dons> something like that?
06:39:15 * dons speculates wildly
06:40:21 <quicksilver> dons: *nod*
06:40:28 <dons> it definitely seems useful to be able to use a given instance with a type. replaces, for a start, rules-ish hacks for ord/eq issues (nub/groupBy/sort)
06:40:32 <quicksilver> dons: is there an associated paper yet, or is it just slides?
06:40:56 <dons> there's no paper on the associated class families, but there's several on the other parts of the story
06:41:11 * quicksilver nods
06:41:14 <quicksilver> I've read some of those
06:41:40 <dons> oh, i note a nice wiki page too, http://haskell.org/haskellwiki/GHC/Indexed_types
06:41:41 <lambdabot> Title: GHC/Indexed types - HaskellWiki
06:41:49 <apfelmus> this a bit OT but: how does a french accent look like in english?
06:42:03 <dons> amusing?
06:42:17 <apfelmus> :) i mean, i want to write it myself
06:42:29 <dons> you want to write english with a french accent?
06:42:32 <quicksilver> 'zis is ze eiffel tower!'
06:42:42 <apfelmus> dons: yes :)
06:43:00 <apfelmus> apparently, i know how to write a french accent in german
06:43:00 <quicksilver> 'my inklish is vary good, oui'?
06:43:09 <apfelmus> hehe
06:43:13 <apfelmus> do you have larger examples?
06:43:21 <dons> 'listen very carefully, i will zay siz once and only once'
06:43:48 <apfelmus> so, "th" becomes "z"
06:44:03 <apfelmus> any other rules? hole texts to learn from?
06:44:03 <quicksilver> apfelmus: it's not very easy, since there aren't really conventional english ways to denote many of the natively french sounds
06:44:09 <dons> yes, i think zat is zee rule.
06:44:44 * dons thinks apfelmus is crafting a grand post to the mailing list
06:44:48 <apfelmus> quicksilver: well, it probably makes it easier for i can invent stuff on my own :)
06:44:54 <apfelmus> dons: sshh :)
06:44:55 <quicksilver> dons: I printed those slides 4-up and each slide takes about 1/16th of a page witha  1-inch white border. stupid PDF.
06:45:04 <LeCamarade> dons: I saw you all. Don't complain when we do it at #ocaml. :o)
06:45:19 <dons> LeCamarade: :-)
06:46:44 <dons> its a pity, we have the swedish chef plugins, but no 'speak like you are french' plugins, it seems
06:46:52 <LeCamarade> "Ponshour, messsdames ette messiusse..."
06:47:01 <dons> heh
06:47:09 <LeCamarade> Anglophones speaking French. ^^
06:47:22 <dons> hehe
06:47:23 <apfelmus> :) i want the other way round
06:47:46 <norpan> Bork! Bork!
06:48:17 <apfelmus> the best would be an online text with french accent
06:48:18 <dons> hellu, I leeke-a heskell fery mooch. types ere-a guud. muneds ere-a fery herd fur me-a. Bork
06:48:29 <edwardk> dons: i submitted a patch for lambdabot to add a ton of chat filters about 4-5 months back. not sure if a french one was there, but there was an austrian accent, etc.
06:48:45 <MyCatVerbs> Dijstkra's algorithm is pretty damn fast, right? Assuming you don't have anything like all-nodes-connected-to-all-nodes.
06:48:45 <dons> edwardk: oh, i think that got applied.
06:48:53 <edwardk> @austro hello?
06:48:53 <lambdabot> Unknown command, try @list
06:48:58 <edwardk> @list filter
06:48:58 <lambdabot> No module "filter" loaded
06:49:02 <edwardk> *shrug*
06:49:04 <dons> ah no :(
06:49:07 <norpan> MyCatVerbs: O(pretty damn fast)
06:49:12 <dons> maybe not compiled in to the module list
06:49:15 <edwardk> ah
06:49:25 <crazy_coder> Its WORKING!! Its WORKING!!     Thanks
06:49:28 <norpan> MyCatVerbs: but yes, it's fast
06:49:30 <crazy_coder> :)
06:49:38 <quicksilver> crazy_coder: :)
06:49:42 <edwardk> i wondered if it was just silently not applied because it would add more annoying @vixen combinations ;)
06:50:21 <crazy_coder> Haskell is great. So are you guys
06:50:26 <crazy_coder> Thanks
06:50:56 * crazy_coder is thinking about writing interpreters now   :)
06:51:16 <edwardk> crazy: interpreters/compilers are really fun in haskell =)
06:51:25 <MyCatVerbs> norpan: sweet, handy to know. :)
06:51:41 <MyCatVerbs> edwardk: uhhhh...
06:51:54 <SamB_XP_> MyCatVerbs: uhhhh what?
06:51:54 <MyCatVerbs> edwardk: that sentence is missing several words.
06:52:10 <MyCatVerbs> ["extremely, ", "hilariously, ", "spiffy, "...]
06:52:27 <SamB_XP_> @vixen aren't you still broken?
06:52:27 <lambdabot> <undefined>
06:52:39 <crazy_coder> What is a real challenge in Haskell . Not that I'll try it any time soon , but just to know
06:52:53 <crazy_coder> Yi ?
06:53:03 <edwardk> getting lambdabot to compile ;)
06:53:13 <crazy_coder> (i meant text editor.......)
06:53:18 <DRMacIver> It's really hard to get NullPointerExceptions in Haskell. :)
06:53:19 <crazy_coder> Oh Bots
06:53:50 <crazy_coder> yes, I can write a bot...... Yet another bot to IRC ... :)
06:54:02 <SamB_XP_> writing a bot is probably easier than compiling lambdabot ;-)
06:54:02 <LeCamarade> DRMacIver: :o)
06:54:09 <edwardk> @where lambdabot
06:54:10 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
06:54:16 <Syzygy-> DRMacIver: That only depends on how much you use import Foreign
06:54:19 <edwardk> crazy: there is a nice starting point, but its scary =)
06:54:25 <edwardk> 'here be dragons'
06:54:32 <SamB_XP_> the trouble is that lambdabot *always* has to be picky about what GHC version you use
06:54:35 <LeCamarade> crazy_coder: There is a bunch of things called the `Squad'. Something Squad ...
06:54:46 <SamB_XP_> and has a fair amount of dependencies
06:54:57 <LeCamarade> Terrible Squad, I think.
06:55:03 * Syzygy- still hasn't got lambdabot to compile on my x86_64 box....
06:55:09 <SamB_XP_> Awkward
06:55:11 <edwardk> thats because lambdabot's dependency list is pretty much every module ever contributed to cabal, because invariably some joker turns it into a plugin..
06:55:11 <crazy_coder> i never really understood the concept of dependencies
06:55:16 <SamB_XP_> the Awkward Squad
06:55:28 <SamB_XP_> crazy_coder: what do you mean?
06:55:41 <SamB_XP_> do you know any other programming languages?
06:55:51 <LeCamarade> SamB_XP_: Yeah. The Awkward Squad. Perl-ward Squad, even.
06:55:55 <JKnecht> szygy: what OS?
06:56:02 <Syzygy-> JKnecht: Gentoo linux.
06:56:08 <Syzygy-> And I tend to have 6.6 lying around nowadays.
06:56:17 <crazy_coder> SamB_XP_: yes. But I never did any project till date
06:56:24 <Syzygy-> Admittedly - I tried it before hs-plugins got to compile on 6.6...
06:56:53 <DRMacIver> lambdabot frightens me.
06:56:54 <SamB_XP_> crazy_coder: well, have you played with anyone else's projects (in any language) yet?
06:57:04 <edwardk> Syzygy-: yeah same boat, maybe thats why i live in such fear of lambdabot =)
06:57:06 <DRMacIver> The codebase sounds horrific, which is difficult for Haskell. :)
06:57:06 <SamB_XP_> DRMacIver: it really isn't that bad
06:57:18 <SamB_XP_> it isn't horrific
06:57:24 <crazy_coder> SamB_XP_: I know C/C++/ Scheme  (nothing very profoundly but all in parts ....... )
06:57:29 <edwardk> dr: the codebase is quite clean actually
06:57:30 <DRMacIver> SamB_XP_: Phrases like "Yeah, that bit is all one mass of regular expressions, and no one understands how it works so we don't want to touch it" have been uttered. ;)
06:57:37 <desp> I have a problem with typeclasses.  can someone help?  http://pastie.textmate.org/74381
06:57:40 <lambdabot> Title: #74381 - Pastie
06:57:44 <DRMacIver> But maybe I'm conflating lb with something else.
06:57:49 <SamB_XP_> DRMacIver: oh, you talking about vixen?
06:58:01 <DRMacIver> I think so.
06:58:07 <SamB_XP_> well, that's one piece.
06:58:20 <SamB_XP_> and I think the regexes may be considered to be state
06:58:21 <crazy_coder> SamB_XP_: not yet. I'll start doing some good projects this year.... Mostly in Haskell. I am really loving it
06:58:35 <DRMacIver> SamB_XP_: That makes it better does it? :)
06:58:55 <SamB_XP_> DRMacIver: well, not in practice.
06:58:58 <quicksilver> @pl has a customer parser, too, rather than using Language.Haskell
06:58:58 <lambdabot> (line 1, column 22):
06:58:59 <lambdabot> unexpected ","
06:58:59 <lambdabot> expecting variable, "(", operator or end of input
06:59:07 <araujo> crazy_coder, be careful, Haskell is a bad programming language .... it makes you hate other languages
06:59:15 <SamB_XP_> personally, I think we need to write a parser for whatever brand of regexes it uses ;-)
06:59:18 <quicksilver> which accounts for its misbehaviour in certain cases
06:59:58 <SamB> @version
06:59:58 <lambdabot> lambdabot 4p534, GHC 6.6 (Linux i686 2.66GHz)
06:59:58 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:00:10 <crazy_coder> araujo: Yeah, But simultaneously I'll keep learning and practicing other languages too . :)
07:00:32 * SamB wonders if he can build lambdabot now?
07:00:32 <araujo> crazy_coder, you don't get it, Haskell is _bad_
07:00:35 <LeCamarade> crazy_coder: Noble as that is, it will be nearly impossible.
07:00:36 <DRMacIver> araujo is unfortunately not wrong. :)
07:00:53 <DRMacIver> (about the 'hating other languages' part)
07:01:00 <SamB> yeah, he's not.
07:01:01 <crazy_coder> what the hell do you guys mean?
07:01:02 <edwardk> i think you need an MPTC for CCURLCode, since you need to say both the type of the container and what it contains. saying that you can take it apart, or you need to change the type of the parameter to * -> * and get something like class CCURLCode f where toC :: CURLCode f => f a -> a; fromC :: CURLCode f => a -> f a
07:01:13 <SamB> but I remain unsure as to whether this is a good thing or a bad thing
07:01:29 <araujo> crazy_coder, it will make you hate coding on other languages
07:01:40 <SamB> actually, for many people it won't make them hate C much more
07:01:49 <Syzygy-> Wonder if it's a good idea to rebuild lambdabot, but so that it emulates Haskell instead of dynamically loading the code... :P
07:02:07 <LeCamarade> crazy_coder: Once you get used to programming in Haskell, even languages that are nearly as good as Haskell will be horrible. Only OCaml may still be bearable. I used to think it was plain Haskell propaganda. I'm living with the grim reality.
07:02:32 * Syzygy- ended up being rude to one of my teachers this term, because of Haskell to a large extent. :P
07:02:32 <SamB> Syzygy-: huh?
07:02:53 <Syzygy-> SamB: If you'd write a haskell interpreter in Haskell in lambdabot, you wouldn't need hs-plugins... :P
07:02:54 <LeCamarade> I'm writing a small Haskell-like syntax to generate PHP code for me. And other languages that may not be sweet enough or may not have  things like good TCO.
07:02:59 <SamB> Syzygy-: I've wanted it to dynamically load it's plugins ;-)
07:03:09 <crazy_coder> But even if one know a particular programming language to the deepest levels, one can implement almost anything and it should suffice all needs
07:03:14 <crazy_coder> Right ?
07:03:22 <Syzygy-> crazy_coder: So why don't you write in assembler then? ;)
07:03:40 * Syzygy- sets out to learn TeX to the extent that he doesn't need anything else ever...
07:03:54 <edwardk> the other way would be to say something like class CCURLCode external internal | external -> internal, internal -> external where toC :: external -> internal; fromC :: internal -> external; then instance CCURLCode (CURLEasyCode CCURLEasyCode) CCURLEasyCode, but both are kind of horrific and i should try to understand what it is you are doing more ;)
07:03:55 <opqdonut> crazy_coder: it's not about things being possible, it's about things being elegant and easy
07:04:06 <SamB> Syzygy-: hah
07:04:06 <LeCamarade> crazy_coder: Yes. But some languages are better for some things than others. You'll need a blurb language to earn money, yet you won't be able to use one, short of compiling from a Haskell-esque syntax to it.
07:04:24 <SamB> Syzygy-: what are you going to write souped-up DVI drivers in?
07:04:34 <Syzygy-> SamB: I don't need no dvi drivers!
07:04:42 <crazy_coder> yeah. You guys are right.
07:04:45 <Syzygy-> dvips was good enough for my adivsor, and it'll be good enough for me!
07:04:57 <SamB> Syzygy-: what about interactivity!
07:05:06 * LeCamarade sets out to learn the abacus well so no other language is necessary ...
07:05:08 <crazy_coder> So I said I'll keep learning and practicing other stuff too , even if it becomes painfull.
07:05:09 <Syzygy-> SamB: TeX gives you interactivity.
07:05:24 * LeCamarade even eyes lambda calculus suspiciously ...
07:05:34 <SamB> does dvips support embedded javascript?
07:05:43 <Syzygy-> Why would you want that?
07:05:53 <SamB> for interactivity!
07:06:02 <LeCamarade> crazy_coder: Yes. It will hurt. Be happy - the move from those langauges to Haskell is a daunting one. You'll never have to suffer it.
07:06:08 <SamB> haven't you ever wanted paper 2.0?
07:06:11 <Syzygy-> SamB: You don't need js for interactivity.
07:06:16 <LeCamarade> :o)
07:06:19 <Syzygy-> SamB: Stop. Please. I'm getting nauseous.
07:06:23 <SamB> heh
07:06:24 <SamB> okay
07:06:25 <ohmega_> is is possible to use lhs2tex with haskell code that contains UTF-8 greek characters etc?
07:06:37 <edwardk> lecamarde: just stick to the ski calculus, or maybe the sk calculus, or hrmm, the one with just the iota combinator sounds good. ;) its general purpose enough, and you can code with 2 keys, 1 if you want to make pause significant ;)
07:06:49 <Syzygy-> Morse code!
07:07:10 <Syzygy-> That's a programming language we HAVE to specify.
07:07:34 <Syzygy-> Turing complete, and consists of a sequence of timed "ON" and "OFF". With interface to the language engine over a morse keyer.
07:07:35 <crazy_coder> Ok gtg cya
07:07:50 <edwardk> @where remorse
07:07:50 <lambdabot> I know nothing about remorse.
07:07:54 <edwardk> ah shucks
07:08:03 <edwardk> http://www.cs.york.ac.uk/plasma/wiki/index.php?title=Software mentions it but the link is broken
07:08:04 <lambdabot> Title: Software - The Programming Languages and Systems Research Group
07:08:12 <kpreid> http://members.tripod.com/rkusnery/remorse.html
07:08:13 <lambdabot> Title: reMorse
07:08:51 <LeCamarade> @remember lambdabot I know nothing about remorse.
07:08:51 <lambdabot> Done.
07:09:10 <Syzygy-> @where you
07:09:10 <lambdabot> I know nothing about you.
07:09:13 <LeCamarade> Tough bot, eh?
07:09:14 <Syzygy-> :P
07:09:20 <LeCamarade> @seen me
07:09:20 <lambdabot> me has changed nick to logancapaldo.
07:09:21 <lambdabot> logancapaldo is in #oasis, #haskell and #darcs. I last heard logancapaldo speak 9h 55m 40s ago.
07:09:23 <Syzygy-> @where decency
07:09:24 <lambdabot> I know nothing about decency.
07:09:31 <LeCamarade> @seen everybody
07:09:31 <lambdabot> I haven't seen everybody.
07:09:38 <Syzygy-> @seen anybody
07:09:38 <lambdabot> I haven't seen anybody.
07:09:41 <LeCamarade> @seen anybody
07:09:42 <lambdabot> I haven't seen anybody.
07:09:47 <ToRA> @seen a sunset
07:09:47 <lambdabot> I haven't seen a.
07:09:48 <LeCamarade> ,,|,,
07:09:50 <ToRA> grr
07:09:53 <Syzygy-> @remember lambdabot I know nothing about decency.
07:09:53 <lambdabot> Done.
07:09:59 <edwardk> kpreid: the one i was thinking about was the 0th annual haskell obfuscated programming contest winner
07:10:01 <Syzygy-> @remember lamdbabot I haven't seen anybody.
07:10:01 <lambdabot> Done.
07:10:41 <LeCamarade> @seen or_heard_anything
07:10:41 <lambdabot> I haven't seen or_heard_anything.
07:11:29 <Syzygy-> "I went to a school of moderate renown." - link to Eton College
07:12:47 <kpreid> @seen orheardanything
07:12:47 <lambdabot> I haven't seen or.
07:12:54 <kpreid> bah
07:13:06 <kpreid> not *even* 8-bit-clean
07:13:11 <Syzygy-> Hehehe
07:15:12 <LeCamarade> @seen #haskell
07:15:23 <LeCamarade> :-o
07:22:16 <lambdabot> you're in #haskell, you dope!
07:23:54 <SamB> @seen #xmonad
07:25:36 <Syzygy-> @seen xmonad
07:25:36 <lambdabot> I haven't seen xmonad.
07:25:39 <Syzygy-> :)
07:25:51 <Syzygy-> Abusing lambdabot for general merriment!
07:28:53 <Wild_Cat> @dance
07:28:54 <lambdabot> unexpected end of input: expecting number
07:29:10 <Wild_Cat> that's not exactly what I had in mind.
07:30:07 <LeCamarade> @dance 3
07:30:07 <lambdabot> 3 => 3
07:30:10 <edwardk> @dance 4
07:30:10 <lambdabot> 4 => 4
07:30:15 <edwardk> hrmm
07:30:20 <edwardk> @dance 1283
07:30:20 <LeCamarade> @help dance
07:30:20 <lambdabot> 1283 => 1283
07:30:20 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:30:31 <LeCamarade> @help @dance
07:30:31 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
07:30:51 <LeCamarade> <lambdabot> Enough!
07:31:40 <quicksilver> @dance 3+1
07:31:40 <lambdabot> 3+1 => 4
07:31:48 <quicksilver> @dance 3*12.0
07:31:49 <lambdabot> unexpected "*": expecting digit, "d", "+" or end
07:31:59 <quicksilver> seems to be a calculator
07:32:00 <quicksilver> how odd :)
07:32:14 <edwardk> not even 4 function =)
07:32:24 <edwardk> @dance 3 - 1
07:32:25 <lambdabot> unexpected "-": expecting digit, "d", "+" or end
07:32:35 <edwardk> @dance 123+123+123
07:32:35 <lambdabot> 123+123+123 => 369
07:33:23 <edwardk> @dance 123+d
07:33:23 <lambdabot> unexpected "d": expecting number
07:33:31 <edwardk> @dance 123d
07:33:31 <lambdabot> unexpected end of input: expecting number
07:33:48 <edwardk> it says "d" in the list there, hence the confusion
07:33:54 <edwardk> *shrugs*
07:34:41 <LeCamarade> @dance 4 3 +
07:34:41 <lambdabot> unexpected end of input: expecting number
07:34:48 <desp> sigh
07:35:02 <desp> I've been wrestling with typeclasses for a few hours now, anyone care to help?
07:35:16 <edwardk> desp did you see my earlier commentary?
07:35:50 <desp> edwardk: oh, no I didn't
07:35:54 <desp> you didn't trigger my hilite :)
07:35:59 <desp> reading now, thanks
07:36:28 <edwardk> i suck like that, never got used to this newfangled tabbing to get people to hear you thing ;)
07:36:53 <Syzygy-> @dance d
07:36:53 <lambdabot> unexpected "d": expecting number
07:36:55 <Syzygy-> @dance 3d
07:36:56 <lambdabot> unexpected end of input: expecting number
07:37:04 <Syzygy-> @dance 3d2
07:37:04 <lambdabot> 3d2 => 5
07:37:07 <Syzygy-> @dance 3d2
07:37:07 <lambdabot> 3d2 => 5
07:37:10 <Syzygy-> @dance 3d3
07:37:10 <lambdabot> 3d3 => 6
07:37:11 <edwardk> aha!
07:37:12 <quicksilver> ah!
07:37:17 <quicksilver> @dice 3d2
07:37:17 <lambdabot> 3d2 => 5
07:37:21 <Syzygy-> AHHHH!
07:37:26 <quicksilver> good old spell-correction :)
07:37:31 <edwardk> @dance 3d6
07:37:31 <lambdabot> 3d6 => 9
07:37:34 <Syzygy-> That auto-guess spell-correction is weird.
07:37:40 <quicksilver> @dice 3d6+1
07:37:40 <lambdabot> 3d6+1 => 8
07:37:44 <Syzygy-> @dance 3d10
07:37:44 <lambdabot> 3d10 => 20
07:37:45 <Syzygy-> @dance 3d10
07:37:45 <lambdabot> 3d10 => 21
07:37:47 <Syzygy-> @dance 3d10
07:37:47 <lambdabot> 3d10 => 10
07:37:51 <edwardk> must be for those late night #haskell d&d sessions i don't get invited to.
07:37:57 <Syzygy-> And it does vary once we get high enough dice...
07:37:57 <desp> edwardk: hrm
07:38:47 <Wild_Cat> @dice 4k3
07:38:48 <lambdabot> unexpected "k": expecting digit, "d", "+" or end
07:38:52 <desp> edwardk: that's getting awfully complicated; in the meantime, I simplified the code a fair bit
07:39:01 <Wild_Cat> @dice 6d6 8
07:39:01 <lambdabot> 6d6 8 => 232
07:39:18 <Wild_Cat> peh. This bot doesn't even support proper dice systems.
07:39:18 <desp> edwardk: what would you say about http://pastie.textmate.org/74395 ? still doesn't compile, though ;)
07:39:19 <lambdabot> Title: #74395 - Pastie
07:39:24 <edwardk> desp: the problem is simply that your typeclass doesn't uniqueness specify the type being injected from or to, so something has to give
07:39:25 <SamB> @dice 3d6k8
07:39:25 <lambdabot> unexpected "k": expecting digit, "+" or end
07:39:34 <edwardk> desp: checking
07:39:51 <SamB> @dice 3d6 3k8
07:39:51 <lambdabot> unexpected "k": expecting digit, "+" or end
07:40:29 <DRMacIver> @dice d6d6
07:40:29 <lambdabot> unexpected "d": expecting number
07:40:35 <desp> hate to be a spoilsport, but all this bot abuse makes it hard to read interesting comments
07:40:56 <SamB> sorries
07:41:15 <edwardk> desp: code <- return (fromCInt cCode) can be replaced with let code = fromCInt cCode
07:41:16 <quicksilver> desp: you can just use type annotations, you know
07:41:18 <edwardk> desp: still reading
07:42:04 <DRMacIver> hate to be a spoilsport, but allt hese interesting comments make it hard to read the bot abuse. :)
07:42:11 <desp> ;)
07:42:17 <quicksilver> desp: ah, you are missing a Show a => constraint on your class
07:42:27 <quicksilver> desp: you want Show a => CURLCode a
07:42:34 <Saizan> when loading a file in ghci i should have in scope even non-exported symbols, right?
07:43:00 <quicksilver> desp: that is, in fact the whole of your problem
07:43:04 <quicksilver> Saizan: yes, that's right
07:43:06 <ihope> Does Parsec have a primitive that appends a string to the stuff to be parsed?
07:43:19 <quicksilver> desp: I think :)
07:43:25 <desp> quicksilver: hmm. not quite, I'm afraid :)
07:43:53 <desp> after adding  Show a => CURLCode a  I still get almost the same error
07:43:55 <edwardk> the two cases where he needs a show he passes the dictionary in
07:43:55 <quicksilver> desp: does it change the errors, at least?
07:44:07 <edwardk> wish i had access to a compiler here
07:44:20 <quicksilver> edwardk: no he doesn't
07:44:23 <Saizan> ok, so.. i don't have them only in modules which use TH, inherent limitation or bug?
07:44:28 <desp> quicksilver: http://pastie.textmate.org/74398
07:44:30 <lambdabot> Title: #74398 - Pastie
07:44:43 <quicksilver> edwardk: when he calls failWhenOn, inside callFun
07:44:48 <quicksilver> edwardk: tehre is no dictionary
07:44:55 <edwardk> ah
07:44:56 <edwardk> yeah
07:45:16 <quicksilver> desp: that is, to my mind, a totally different error now :)
07:45:37 <edwardk> totally different error. agreed
07:46:26 <quicksilver> desp: in callFun, you use 'fromCInt' to get a CURLCode out of a CInt, right?
07:46:36 <quicksilver> desp: how shall it choose which CURLCode to use?
07:46:39 <edwardk> you have a show . read problem
07:46:43 <edwardk> yeah
07:46:45 <quicksilver> (which instance of, to be precise)
07:47:02 <desp> right...hrm
07:47:21 <edwardk> to its eyes all instances are equally valid it has no way to 'break the tie'
07:47:35 <quicksilver> your types tell me that, in pricinpile, callFun and carefullCallFun could be run with any instance of CURLCode
07:47:42 <quicksilver> so you need a way to choose which one
07:47:58 <quicksilver> one possible way to pass in a 'dummy parameter' to choose which instance
07:48:07 <desp> see, I have two instances of CURLCode, and initially I wrote two versions of each function
07:48:08 <quicksilver> another possibly way is just to choose one statically at compile time
07:48:14 <desp> then I thought to simplify things
07:48:19 * quicksilver nods
07:48:28 <quicksilver> then maybe you want a dummy parameter
07:48:40 <quicksilver> to let the caller choosewhich instance
07:48:54 <desp> a dummy parameter to callFun will make things really ugly, because it's used a lot, and the params are hairy already :/
07:49:10 <quicksilver> well it's got to choose which instance in some way, desp :P
07:49:17 <desp> I understand
07:49:37 <quicksilver> it can either choose statically (at compile time), or it can allow its caller to choose
07:50:12 <desp> what do you mean by "choose one statically at compile time"?
07:50:42 <desp> something other than "write two functions"? :)
07:50:47 <quicksilver> suppose your two instances are  CURLFoo and CURLBar
07:51:09 <quicksilver> you could then write ((fromCInt cCode) :: CURLFoo) inside the defn of funCall
07:51:11 <edwardk> make a type definition at the top of a file somewhere saying type CURL = CURLFoo ;)
07:51:19 <edwardk> then use CURL everywhere ;)
07:51:20 <quicksilver> and it will always use CURLFoo
07:51:34 <desp> ah, sure
07:51:43 <desp> but that'll mean that I need two functions
07:52:19 <quicksilver> well your other option is to allow the type chcker to choose for you
07:52:29 <quicksilver> but it needs either a parameter or a polluted return value to do that
07:52:36 <edwardk> well, the 'right' way i think would be to rewrite it to pass the dummy parameter, then make two stub functions that call the fancy version with the extra parameter
07:52:50 <fasta> When you write a test that works with SmallCheck and QuickCheck, with the appropriate module imported, how do you make sure they work with both? I know a way, but first-class modules would be the correct solution, so it seems.
07:53:13 <desp> right. thanks much for your help, edwardk, quicksilver
07:53:45 <edwardk> underlyingFoo a b = fromC b `asTypeOf` a; FooA = underlyingFoo (undefined :: SomeType); FooB = underlyingFoo (undefined :: SomeOtherType)
07:54:45 <edwardk> where of course underlyingFoo is a lot more complicated. you get the best of both worlds, a simple invocation pattern, and a robust internal implementation you can extend with more definitions over time
07:55:40 <SamB> fasta: it's especially hard when your tests aren't of a type like a -> b -> ... -> Bool
07:55:55 <desp> @hoogle `asTypeOf`
07:55:55 <lambdabot> Hoogle Error: Parse Error: Unexpected character '`asTypeOf`'
07:56:04 <desp> @hoogle asTypeOf
07:56:04 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:56:11 <SamB> @src asTypeOf
07:56:12 <lambdabot> asTypeOf = const
07:56:15 <desp> heh
07:56:24 <SamB> that really ought to include the type signature...
07:57:02 <edwardk> desp: it forces the types to match
07:57:11 <desp> yeah
07:57:56 <quicksilver> it many respects asTypeOf is an ugly alternative to generalised type annotations
07:58:02 <ihope> @type let z=asTypeOf in z$z$z
07:58:04 <lambdabot> forall a. ((a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> a -> a -> a
07:58:11 <ihope> @type let z=asTypeOf in z$z$z$z
07:58:14 <lambdabot> forall a. (((a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> a -> a -> a) -> ((a -> a -> a) -> a -> a -> a) -> (a -> a -> a) -> a -> a -> a
07:58:16 <quicksilver> it can be preferably sometimes if types are very large, though
07:58:26 <SamB> quicksilver: I was just going to say that
07:58:35 <SamB> anyway, that's why we aren't getting rid of it ;-)
07:58:39 <ihope> Can types grow any faster than exponentially with the expression? :-)
07:58:42 <quicksilver> :t (\z -> z$z$z$z) asTypeOf
07:58:44 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> b
07:58:44 <lambdabot>     Probable cause: `z' is applied to too few arguments
07:58:48 <quicksilver> :)
07:59:00 <quicksilver> differecne between let and \ illustrated nicely
07:59:04 <SamB> ihope: we aren't talking about asymptotic bounds, but actual size
07:59:14 <edwardk> quicksilver: in the absence of freehand herbrand constraints. i suppose if you allowed those you'd be able to get the best of both worlds
07:59:40 <quicksilver> edwardk: or (argubaly more FP-like) just type-level "let"
07:59:49 <quicksilver> edwardk: that is, introduction of new local type variables
08:00:04 <edwardk> something like foo :: (t = mysupercomplicatedtype) => t; foo bar = ... ( ... :: t)
08:00:07 <fasta> Do we get first class modules with Haskell'?
08:00:11 <quicksilver> nope
08:00:11 <edwardk> quicksilver: yeah
08:00:21 <quicksilver> fasta: that's a massive language change
08:00:23 <edwardk> i'm currently exploring the herbrand path
08:00:27 <quicksilver> fasta: I doubt it will be in h'
08:00:39 <SamB> so what do you people think of bang patterns vs. bangs sprinkled in type signatures?
08:00:39 <fasta> quicksilver: Scheme48's system seems to be quite sane
08:00:43 <edwardk> fasta: yeah we call them 'typeclasses' =)
08:00:45 <LeCamarade> fasta: I think not, but they'd rock bloody hard!
08:00:55 <sjanssen> SamB: what are the semantics?
08:01:00 <edwardk> samb: like clean?
08:01:07 <SamB> dunno!
08:01:25 <SamB> I just know malcolmw prefers bangs in type signatures...
08:01:27 <sjanssen> SamB: things like 'f :: !Int -> Int; f = id' would be kinda weird, I think
08:01:38 <quicksilver> fasta: I'm not saying there aren't nice ideas around. SPJ has one such proposal.
08:01:43 <SamB> sjanssen: true
08:01:47 <quicksilver> fasta: I'm just saying I don't think one is on the table for H'.
08:01:50 <mauke> @src ($!)
08:01:51 <lambdabot> Source not found. stty: unknown mode: doofus
08:02:01 <SamB> I couldn't help but notice that you can't write something like
08:02:07 <fasta> I suppose first-class modules are the same as anonymous type classes, then.
08:02:12 <edwardk> the only issue i have with the type signature version is it seems a little less general
08:02:20 <SamB> f (!x,!y) -> (y,x)
08:02:21 <SamB> er.
08:02:25 <SamB> f (!x,!y) = (y,x)
08:02:30 <SamB> with bangs in types...
08:02:32 <sjanssen> SamB: we'd also need some sort of subtyping, we want to hand 'f :: (!a -> b)' to map
08:02:46 <SamB> er.
08:02:48 <fasta> I am very against putting bangs in types.
08:02:55 <SamB> actually I don't think the bangs would be in the types themselves
08:02:56 <sjanssen> also, what does [!a] mean?
08:02:59 <SamB> just in the signatures...
08:03:00 <sorear> (hello)
08:03:01 <edwardk> because you can't be strict in one argument of one constructor of a type and not in all other arguments of the same type in all constructors of the same type
08:03:31 <edwardk> unless i'm missing something
08:03:33 <SamB> well, anyway, don't direct your arguments at me. use them on malcolmw ;-)
08:03:45 <edwardk> which i just realized is a flaw in my toy compiler. gah
08:03:46 <mux> oh, the icon for the haskell summer of code is soooo cute :-)
08:03:58 <LoganCapaldo> sjanssen: you could move the ! to the -> symbol
08:04:02 <edwardk> thats what i get for letting you make me think ;)
08:04:18 <LoganCapaldo> a !-> b instead of !a -> b
08:04:22 <SamB> edwardk: heh
08:04:28 <sjanssen> LoganCapaldo: that's an idea
08:04:39 <LoganCapaldo> then you couldn't even write [!a]
08:04:53 <sjanssen> you could write [a !-> b], whatever that means
08:05:05 <edwardk> spencer: that would be a list of strict functions
08:05:32 <sjanssen> edwardk: yeah, but was does that really mean?
08:05:36 <SamB> I, too, prefer bang patterns, as I think they make sense in case alternatives (and function alternatives)
08:05:38 <sjanssen> what is the type of (:)?
08:05:54 <SamB> er.
08:06:00 <SamB> I think I forgot where I started just now.
08:06:00 <sjanssen> f : fs where f :: a -> b; fs :: [a !-> b]
08:06:04 <edwardk> that the arguments to each function gets forced to whnf before the function is reduced and evaluated?
08:06:13 <SamB> s/, as/.//
08:06:24 <sorear> sjanssen: see subtyping above :)
08:06:57 <LoganCapaldo> I think it does make a little more sense that they be part of case rather than the type.
08:07:10 <LoganCapaldo> but I'm a newb for sure
08:07:17 <SamB> LoganCapaldo: so?
08:07:30 <sjanssen> putting them in pattern matches is certainly simpler -- just a simple desugaring
08:07:50 <LoganCapaldo> SamB: so to what? My newbness or my opinion? :)
08:07:51 <edwardk> the main argument i see for it being in the type is it allows type distinctions between strict and lazy values
08:08:14 <LoganCapaldo> edwardk: I thught that would be  an argument against it <g>
08:08:33 <SamB> edwardk: I don't think malcolmw was proposing that the bangs be part of the actual types...
08:08:36 <SamB> just the signatures...
08:08:37 <edwardk> while they remain in the patterns you have a much harder job of carrying around strictness in the type system.
08:08:44 <edwardk> samb: yeah.
08:08:57 <edwardk> samb: thats why there are there in my toy compiler, i just realized how much functionality it cost me ;
08:09:09 <edwardk> er they
08:11:30 <edwardk> i think its more relevant to track that something may diverge though, tracking pointedness seems more important to me than strictness to me in general. fusion is still sound if something will take a long time as long as i know its not bottom. i don't care if its a value, just that its 'value-like'
08:12:07 <edwardk> strictness annotations tend to lead to rampant stack overflows and abuse =)
08:12:23 <edwardk> and weird breakages of otherwise elegant properties
08:12:57 <edwardk> though i admit those are separate issues
08:14:41 <edwardk> a nice annotation that says that something generates productive codata or well-founded data would be handy though I wince at the thought of teaching it to freshman
08:14:52 <edwardk> er freshmen
08:15:58 <mm_freak> http://wagerlabs.com/2006/01/01/haskell-vs-erlang-reloaded
08:16:00 <lambdabot> Title: Tenerife Skunkworks Haskell vs. Erlang, Reloaded
08:16:02 <mm_freak> this report worries me
08:16:14 <mm_freak> but i don't like erlang's semantics
08:16:28 * Saizan has still to learn which is the distinction between data and codata
08:16:49 <osfameron> I like that article.  Taking the trouble to write an app in two langauges you're learning is quite hardcore
08:17:07 <LoganCapaldo> re: !a -> b having a different type than a -> b. you don't need subtyping, just another class Applyable t a b where apply :: t -> a -> b and just make both (->) and (!->) instances of this and change map's type to map :: (Applyable t) => t a b -> [a] -> [b] :)
08:17:41 <LoganCapaldo> of course I think this would neuter the strictness annotation
08:17:52 <LoganCapaldo> so it;s pretty useless :)
08:17:57 <mm_freak> osfameron: but rather than writing my programs in erlang, i'd just write them in C++
08:18:14 <mm_freak> because IMO erlang isn't truely functional
08:18:28 <osfameron> mm_freak: that seems like a strange reason to write in C++
08:18:43 <osfameron> but I guess I'd write them in Perl because I know Perl and can get-things-done in it...
08:18:52 <mm_freak> osfameron: i know C++ well  that's a reason
08:19:07 <osfameron> yeah, that's a reason, definitely
08:19:20 <mm_freak> well  gotta go to work  cya
08:19:39 <edwardk> Saizan: codata is infinite, data is finite, you define 'data' via recursion, you define codata via corecursion. well-founded data has a base case and builds up from that. productive codata basically says you can get the next constructor you need if you inspect it from the outside in in bounded time.
08:20:16 <edwardk> [1..] is productive codata. [1..4] is well-founded data.
08:21:04 <edwardk> haskell kind of munges the concepts of codata and data together, so you get bottoms all over the place
08:21:07 <LoganCapaldo> Would something like standard input be productive codata?
08:21:28 <edwardk> logan: thats part of the awkward squad, so its a little bit weird =)
08:21:43 <Saizan> edwardk: ah! it was simpler than i thought, and yes quite obscure from haskell pov
08:22:16 <edwardk> Saizan: it took me about 6 months to realize that was about all there was to it ;)
08:22:31 <quicksilver> "You cannot compare the weight of the biggest telco thrown behind Erlang to the weight of Simon Marlow and Simon Peyton-Jones behind GHC, although the two Simons are without a trace of doubt VERY HEAVY."
08:22:42 <sjanssen> I don't think joelr's story is particularly useful here
08:22:53 <sjanssen> he wants a highly concurrent, networked server
08:22:55 <LoganCapaldo> what the heck is corecursion though?
08:23:08 <sjanssen> which is pretty much the design goal of Erlang
08:23:20 <edwardk> quicksilver: must be all the jaffacakes.
08:23:45 <sjanssen> if Haskell and its implementations can even come close on that type of project, we should be proud
08:24:17 <quicksilver> sjanssen: I think it is an interesting case study, of course it has to be understood in context
08:24:49 <ndm> it also has to be understood that he wanted records with 164 fields
08:25:03 <ndm> my guess is that implies non-Haskell like design at several points
08:25:12 <edwardk> logan capaldo: we use it every day: http://en.wikipedia.org/wiki/Corecursion
08:25:13 <lambdabot> Title: Corecursion - Wikipedia, the free encyclopedia
08:25:19 <ndm> someone with more Haskell experience may have picked an alternative design better suited to the language, and had more success
08:25:45 <sjanssen> ndm: yes, I generally have that feeling after reading about joelr's troubles
08:25:46 <quicksilver> ndm: right. that's exactly the kind of thing I meant by context
08:26:52 <osfameron> yes, but I like the article because it isn't haskell bashing or anything, it's just recounting a rather intersting experience with that an erlang
08:26:57 <LoganCapaldo> So is corecursion recursion but I intentionally "forget" to include the base case?
08:27:03 <edwardk> neil: yeah. its funny how people approach a problem with a particular implementation in mind, then wonder why a language suited to a different style of implementation feels unnatural as they contort it to meet their inner vision.
08:27:07 <edwardk> logan: yep
08:27:18 <edwardk> logan: and its a bit backwards in the way the implication works
08:27:41 <sorear> I love the way we need a Trac ticket and a month of dicussion *just to document Reader*
08:28:02 <Saizan> also he serialized with [Word8]?
08:28:17 <sjanssen> Saizan: Data.Binary didn't exist yet
08:28:22 * sorear is starting to hear the bolts popping out of the ghc maintainership...
08:28:35 <LoganCapaldo> So you could almost name unfoldr cofoldr?
08:29:17 <edwardk> logan: unfoldr generates codata. probably best named 'ana' =)
08:29:45 <edwardk> and foldr 'cata' since it is designed to tear down data.
08:29:48 <roconnor> sorear: yeah, I was working on http://hackage.haskell.org/trac/ghc/ticket/974, but then I just gave up
08:29:50 <lambdabot> Title: #974 (Add unzipEithers, lefts, rights to Data.Either) - GHC - Trac
08:29:51 <LoganCapaldo> ah hah
08:29:52 <roconnor> too much work.
08:30:28 <edwardk> which then leads you to a good base understanding to read things like the bananas papers on catamorphisms/anamorphisms, etc.
08:31:32 <desp> edwardk: whew, thanks again; works fine now, and is quite elegant
08:31:40 <edwardk> desp: no problem
08:32:49 <LoganCapaldo> edwardk: So are Streams from the Stream Fusion paper codata?
08:32:57 <edwardk> yep
08:33:08 <LoganCapaldo> I see
08:33:11 <sjanssen> @type foldr (\x ~(ls, rs) -> either (\l -> (l : ls, rs)) (\r -> (ls, r : rs)) x) ([], [])
08:33:16 <lambdabot> forall a b. [Either a b] -> ([a], [b])
08:33:40 <LoganCapaldo> Learning things on your own is weird.
08:33:49 <edwardk> logan: tell me about it =)
08:33:54 <LoganCapaldo> I feel like I'm coming at Haskell crabwise
08:34:01 <edwardk> i think we all do
08:35:10 <LoganCapaldo> thanks for answering my questions
08:35:41 <edwardk> What I love about Haskell is that learning it has been the first time I felt like I was actually learning something new about programming in years. Nothing else has so consistently surprised me.
08:36:49 <sjanssen> @pl foldr (\x ~(ls, rs) -> either (\l -> (l : ls, rs)) (\r -> (ls, r : rs)) x) ([], [])
08:36:50 <lambdabot> (line 1, column 11):
08:36:50 <lambdabot> unexpected "~"
08:36:50 <lambdabot> expecting operator, pattern or "->"
08:37:11 <edwardk> @pl foldr (\x (~(ls, rs)) -> either (\l -> (l : ls, rs)) (\r -> (ls, r : rs)) x) ([], [])
08:37:11 <lambdabot> (line 1, column 12):
08:37:12 <lambdabot> unexpected "~"
08:37:12 <lambdabot> expecting pattern
08:37:14 <Saizan> so if i have z = map (+1), z [1..], z is both recursing and corecursing?
08:37:14 <pejo> edwardk, what other functional languages did you know before Haskell?
08:37:16 <edwardk> ah no love
08:37:21 <edwardk> pejo: javascript? =)
08:37:31 <edwardk> and i'd done a little bit of lisp forever ago
08:37:35 <sjanssen> @pl foldr (\x (ls, rs) -> either (\l -> (l : ls, rs)) (\r -> (ls, r : rs)) x) ([], [])
08:37:36 <lambdabot> foldr ((`ap` snd) . (. fst) . flip (flip . ap (ap . (either .) . flip . ((,) .) . flip (:)) ((. flip (:)) . (.) . (,)))) ([], [])
08:38:01 <pejo> edwardk, so it's more learning about fp in general, rather than haskell?
08:38:27 <dino-> edwardk: I've felt that way too this whole past year of studying Haskell. I had never been exposed to FP prior to this.
08:38:48 <earthy> ndm: to come back to that 164 field records thing
08:38:55 <earthy> I've wanted to do that (and done it) in Haskell
08:38:55 <edwardk> pejo: nah, because i'd been using functional techniques in an imperative setting for a long time. it was more about the advent of laziness and typeclasses. i wouldn't have felt the same way about, say, ocaml.
08:39:08 <earthy> this sort of thing *does* come up in actual data sets
08:39:09 <ndm> earthy: there is usually an alternative way which would be better
08:39:17 <earthy> and you want to be able to deal with inputting those data sets
08:39:18 <ndm> earthy: not always, but often
08:39:31 <sorear> earthy: you should see nhc :)
08:39:34 <ndm> are you telling me there are 164 entirely distinct fields with no abstraction over them?
08:40:37 <quicksilver> it's certainly not all that odd to have 20-40 fields
08:40:44 <edwardk> haskell gave me a language that was very close to what i'd been trying to write up until that point in a more imperative setting, expressed in a far more elegant and self-consistent framework than I could have designed.
08:40:50 <chessguy> @help bf
08:40:50 <lambdabot> bf <expr>. Evaluate a bainf*ck expression
08:40:52 <earthy> ndm: nope. :)
08:40:54 <quicksilver> it's not very unusual to have a SQL table or join with 20-40 columns, for example
08:40:58 <chessguy> @bf + + + + + + + + [ > + + + + [ > + + > + + + > + + + > + < < < < - ] > + > - > + > > + [ < ] < - ] > > . > > - - - . + + + + + + + . . + + + . > . < < - . > . + + + . - - - - - - . - - - - - - - - . > + . > + + .
08:40:59 <lambdabot>  fd:17: hClose: resource vanished (Broken pipe)
08:41:04 <earthy> ndm: doing some abstraction we ran it down to 62 fields
08:41:07 <chessguy> bah
08:41:13 <earthy> still, that's a shitload.
08:41:20 <sjanssen> @pl foldr (\x xs -> either (\l -> first (l:) xs) (\r -> second (r:) xs) x) ([], [])
08:41:20 <lambdabot> foldr (flip (ap (either . flip (first . (:))) (flip (second . (:))))) ([], [])
08:41:28 <sjanssen> earthy: what were all those fields?
08:41:34 * sorear can't beleive earthy
08:42:02 <earthy> sorear hasn't seen medical records lately?
08:42:11 <earthy> this was a neonatal dataset
08:42:29 <chessguy> @bf ++++++++[>++++[>++>+++>+++>+<<<<-]>+>->+>>+[<]<-]>>.>>---.+++++++..+++.>.<<-.>.+++.------.--------.>+.>++.
08:42:29 <lambdabot>  fd:17: hClose: resource vanished (Broken pipe)
08:42:30 <sjanssen> oh, I thought you were referring to joelr's poker server
08:42:38 * chessguy sighs
08:43:55 <earthy> patientnumber, birthdate, sex, pregnancy length, weight, birthplace, reanimation techniques performed, transport types used, reason for taking into hospital, whether the child survived, diagnostics, treatments, APGAR scores at birth, days in a breerder, days under fototherapy etc etc
08:44:38 <earthy> just to say that joelr's requirement for a large number of fields may have been actually useful and domain-related
08:44:46 * sorear would split the fields into categories
08:44:53 <earthy> I'm guessing it wasn't, in his case, but I'm not going to dismiss him out of hand
08:45:25 <sjanssen> actually, joelr had 164 records, not records with 164 fields
08:45:48 <earthy> hm. even that I don't consider impossible. improbable, yes.
08:46:01 <zer01ne> hi
08:46:12 <sjanssen> 164 records seems much more possible to me
08:46:22 * earthy nods
08:46:33 <sjanssen> you might go for one record type for each protocol message, which seems very reasonable
08:46:48 <zer01ne> i need ur help
08:46:54 <sjanssen> well, a single ADT with many constructors would be better there
08:47:01 <earthy> and then you get to shitty large namespace issues
08:47:10 <SamB> yay. I've managed to write some Binary code to read vixen's state, which is in an old Binary format...
08:47:22 <Philippa> zer01ne: better to just ask your question
08:47:38 <sjanssen> SamB is practicing necromancy?
08:47:40 <zer01ne> hehe Philippa i try to
08:47:45 <earthy> hm. need to run if I want to eat dinner this evening.
08:47:49 <zer01ne> but i have to post some code :-(
08:47:58 <sjanssen> zer01ne: hpaste.org/new
08:50:12 <zer01ne> http://hpaste.org/433
08:50:30 <SamB> http://hpaste.org/434
08:50:35 <sorear> huh.  hpaste didn't announce
08:50:43 <SamB> indeed
08:50:45 <dino-> Probably didn't fill in #channel
08:50:54 <LoganCapaldo> hpaste: you there?
08:50:59 <sorear> !paste
08:51:06 <quicksilver> zer01ne: whats the problem?
08:51:08 <SamB> hpaste is not here
08:51:15 <fasta> So, much for Haskell stability ;)
08:51:21 <fasta> Rewrite it in Erlang?
08:51:23 <sorear> zer01ne: The where needs to be indented more than the function.
08:51:25 <fasta> </troll>
08:51:31 <sjanssen> @smack fasta
08:51:31 <lambdabot> Unknown command, try @list
08:51:36 <sjanssen> @slap fasta
08:51:36 <lambdabot> why on earth would I slap fasta
08:51:40 <zer01ne> quicksilver i need to know how to do the test
08:51:56 <zer01ne> act gives Action "back"
08:52:08 <zer01ne> and i need to know if its from type Reduce
08:52:25 <zer01ne> type = constructor type
08:52:26 <quicksilver> case act (head i) of Reduce R -> .... do something ...
08:52:32 <mauke> isReduce :: Action -> Bool; isReduce (Reduce _) = True; isReduce _ = False
08:53:00 <LoganCapaldo> zer01ne: case act (head i) of { Reduce r -> ... ; Shift -> ... ; Error -> ... }
08:53:00 <zer01ne> ah thx
08:53:11 <dcoutts_> dons: we do have a standalone lists-via-streams lib, remember? :-)
08:53:25 <SamB> anyway, my paste has the code I used to read vixen's "state"
08:53:25 * LoganCapaldo feels redundant
08:55:16 <Saizan> uhm, actually there's no logic to reconnect in case of problems inside hpaste
08:56:31 <SamB> huh. so that was *all* that was wrong with vixen?
08:59:56 <kral> bye all
09:01:01 <shapr> blackdog: g'day!
09:01:05 <shapr> pesco: hiya!
09:01:45 <shapr> @vixen
09:01:45 <lambdabot> <undefined>
09:02:49 <SamB> shapr: doesn't work yet
09:03:11 <SamB> lambdabot needs the fixed State/vixen file and a reboot
09:03:44 <SamB> apparantly the only thing wrong was that State/vixen was in a 32-bit format, but Data.Binary uses a 64-bit format now
09:05:47 <SamB> to try it at home, do Plugin.Vixen> encodeFile "State/vixen64" . unOC =<< decodeFile "State/vixen"
09:06:13 <SamB> then move State/vixen64 to State/vixen
09:07:42 <quicksilver> SamB: that was always one of the things that upset me about data.binary
09:07:49 <quicksilver> SamB: what if the format changes :)
09:08:33 <SamB> quicksilver: well, the point of using a 64-bit encoding for Int is to make data portable
09:08:59 <pesco> shapr: Hey. You wake up too late. I'm about to leave from work...
09:09:32 <pesco> But might check in again later for a chat.
09:09:47 <quicksilver> SamB: indeed
09:09:57 <quicksilver> SamB: but what if the data.binary people decide they've done something wrong
09:10:05 <quicksilver> SamB: and they change the format in some way
09:10:13 <quicksilver> SamB: one of the things about software is it has bugs in :)
09:10:25 <SamB> yeah :-(.
09:10:48 <SamB> it would be nice if there was a way to version changes...
09:10:51 <quicksilver> I wrote my own binary serialisation for that reason
09:10:55 <quicksilver> to use my own versioning
09:10:59 <SamB> or something...
09:11:01 <quicksilver> and so I could document my binary format exactly
09:11:19 <sorear> quicksilver: How much of it did you write?
09:11:20 <quicksilver> not 'this is whatever Data.Binary chooses' but 'this is 4 bytes of this, plus n*4 btytes of that, plus ... '
09:11:34 <SamB> but you can always use Data.Binary for it's mechanism, but not use the Binary class
09:11:38 <quicksilver> indeed
09:11:39 <ndm> Yhc doesn't use Data.Binary, as its substantially slower
09:11:43 <quicksilver> I didn't know that, at the time :)
09:11:50 <quicksilver> I ddin't know D.B was in "two layers"
09:12:08 <sorear> ndm: dcoutts_ would like to know that!
09:12:09 <quicksilver> still to be honest the Get/Put monads would add a tiny bit of prettiness to my code but they wouldn't make much different
09:12:25 <ndm> sorear: no he wouldn't, 1000 times slower on Hugs to him is a bonus point
09:12:33 <dcoutts_> heh
09:12:42 <quicksilver> that sounds a little harsh :)
09:13:01 <ndm> sorear: and once he's making it 1000 times slower on Hugs, we're not going to bother for GHC either (although i think it was slower there too as well)
09:13:17 <dcoutts_> it's not a bunus, it's just that we're not really prepared to sacrifice ghc performance for improved hugs performance
09:13:19 <SamB> ndm: slower than what?
09:13:26 <ndm> SamB, hPutChar
09:13:32 <SamB> eww
09:13:36 <dcoutts_> it's remarkably difficult to make it fast on both
09:13:41 <dcoutts_> I've got one idea though
09:13:46 <dcoutts_> use lists :-)
09:13:50 <ndm> not eww, it was trivial to write
09:13:50 <SamB> hehe
09:13:58 <dcoutts_> and have it fuse on ghc and not on hugs
09:14:01 <ndm> dcoutts_ - makes sense, then fuse them out of existance on ghc
09:14:17 <ndm> dcoutts_ and in Supero it could fuse the lists away entirely, the best of all worlds
09:14:21 <dcoutts_> so internally many of the bytestring functions might be bytestring comprehension or something
09:14:23 <SamB> ndm: ... I suppose there isn't much danger of hPutChar being implemented correctly... it seems impossible anyway ;-)
09:14:36 <dcoutts_> blah s = bytestring [ ... | ... <- ... ]
09:14:44 <ndm> SamB, lets just say hPutChar (ord 256) = bang
09:15:09 <dcoutts_> surely hPutChar (ord 256) = hPutChar (ord 0)
09:15:15 <dcoutts_> or does ord go bang ?
09:15:21 <SamB> heh
09:15:24 <SamB> ord does not go bang
09:15:38 <mauke> > ord 256
09:15:41 <lambdabot>   add an instance declaration for (Num Char)
09:15:45 <mauke> bang
09:15:49 <quicksilver> > chr 256
09:15:51 <lambdabot>  '\256'
09:16:06 <sorear> dcoutts_: shouldn't hPutChar (chr 256) write a character 256?  this isn't ascii age anymore ;)
09:16:16 <dcoutts_> sorear: in what encoding ? :-)
09:16:30 <quicksilver> one might hope
09:16:31 <sorear> dcoutts_: The system default, duh! :)
09:16:36 <quicksilver> hPutChar is actually hPutWord8
09:16:41 <quicksilver> in a rather thing disguise
09:16:47 <quicksilver> 'tis a little counterintuitive
09:16:50 <dcoutts_> sorear: locale? it'll break soooo many programs that assume locale = C
09:17:18 <dcoutts_> obviously we should have had different IO functions for word and Char from the beginning
09:17:33 <dcoutts_> these days, we do somewhat
09:17:37 <sorear> We can break things!
09:17:41 <dcoutts_> we have ByteString and .Char8
09:17:54 <SamB> sorear: well, see, there isn't much danger of anyone implementing hPutChar correctly
09:17:54 <dcoutts_> and some time we'll also have .UTF8 .UTF16 etc
09:17:59 <ndm> dcoutts_ bang = goes wrong, can't quite remember how...
09:17:59 <SamB> because nobody can figure out what that is
09:18:08 <mauke> IO handles should have encoding layers
09:18:09 <dcoutts_> and I've got an iconv implementation for ByteString
09:18:16 <mauke> like in perl
09:18:32 <SamB> I think "bang" mean "goes wrong, halting the program and making a loud noise"
09:18:44 <dcoutts_> I'd rather see the encoding layer as a pure function above the IO handle
09:18:53 <ndm> SamB, like in C? where bang means silently corrupting some other aspect of the system
09:18:58 <mauke> open my $fh, '>:utf8', $filename
09:19:05 <SamB> ndm: we don't like to do that in Haskell
09:19:15 <dcoutts_> ie read as bytes and then interpret them in some string encoding, using types to distinguish
09:19:16 <SamB> instead, we prefer cryptic messages, like...
09:19:21 <mauke> dcoutts_: sure the encoding functions should work on [Char] -> [Word8] or something
09:19:23 <SamB> > fromJust Nothing :: ()
09:19:25 <lambdabot>  Exception: Maybe.fromJust: Nothing
09:19:30 <sorear> Haskell is dead as soon as it starts worrying about backward compabitibility.
09:19:36 <ndm> SamB, you mean those of us who aren't using Catch
09:19:40 <SamB> sorear: not necessarily
09:19:41 <sorear> Actually, you can generalize on the first variable.
09:19:42 <dcoutts_> mauke: yes, but ByteString -> PackedString.UTF8
09:19:51 <SamB> we might come up with a cool way to do it sometime
09:19:56 <mauke> ew. no.
09:19:57 <ndm> sorear: agreed, but at hte same time we're screwed if we don't worry about it enough
09:20:25 <mauke> dcoutts_: if it's a byte string, how can it contain characters >255?
09:20:26 <ndm> either way, Haskell is screwed long term...
09:20:30 <sorear> ndm: it's not like code for 6.4 works on 6.6 anyway :)
09:20:45 <ndm> sorear: i know...
09:20:48 <quicksilver> mauke: it could contain UTF8
09:20:54 <dcoutts_> mauke: ByteString is a sequence of bytes, PackedString is going to be for Unicode
09:21:05 <dcoutts_> and will use one of the UTF encodings
09:21:07 <mauke> then why is UTF8 in its name?
09:21:09 <ndm> FastPackedString is for slow strings
09:21:10 <yax1> I'm getting "*** Exception: Prelude.head: empty list" - how do i get ghci to tell me the line number that called head?
09:21:11 <mauke> no, wrong
09:21:17 <ndm> how are we going to explain this to anyone?
09:21:30 <SamB> ndm: I thought we'd killed that?
09:21:44 <mauke> encoding information is attached to bytes, not characters
09:21:52 <ndm> yax1, in GHC 6.7 (unreleased) you can use the debugger - otherwise, how big is your code? You can use the Safe library, use Catch, use Hat, or use guesswork
09:21:57 <ndm> SamB, in Yhc it lives!
09:22:00 <dcoutts_> ndm: if you have an impl with the same semantics on yhc/nhc/hugs then we'll include it
09:22:08 * shapr boings cheerfully
09:22:09 <SamB> ndm: isn't it only slow in Yhc anyway?
09:22:11 <shapr> Good morning #haskell!
09:22:12 <ndm> dcoutts_ i don't
09:22:15 <dcoutts_> ndm: we can check the semantics are the same using our QC tests
09:22:17 <SamB> and possibly hugs?
09:22:18 <ndm> SamB, nope, its slow everywhere
09:22:23 <dcoutts_> hia shapr
09:22:28 <SamB> oh, is that pre-fusion?
09:22:28 <ndm> SamB, slower than String in GHC
09:22:38 <ndm> thats pre-98 even
09:22:41 <SamB> oh.
09:23:02 <SamB> I guess I'm not familiar with it being both (a) called that and (b) slow
09:23:03 <ndm> nhc was a bootstrapping Haskell compiler, NOT a bootstrapping H98 compiler
09:23:13 <yaxu> ndm: thanks
09:23:13 <lambdabot> yaxu: You have 1 new message. '/msg lambdabot @messages' to read it.
09:23:21 <yaxu> ooh!
09:23:32 <dcoutts_> ndm: hmm? what is this slow FPS with ghc ?
09:23:46 <ndm> dcoutts_ oh, i mean packedstring
09:23:52 <ndm> dcoutts_, fps == bytestring isn't it..
09:23:56 <dcoutts_> ah yes, that's quite different
09:24:01 <ndm> see how confusing these packed string libraries are!
09:24:03 <shapr> hi dcoutts_!
09:24:08 <dcoutts_> the old Data.PackedString
09:24:18 <SamB> yeah. notice how it doesn't have "fast" in the name
09:24:23 <SamB> or in any way imply that it is fast.
09:24:41 <sorear> In fact the documentation quite explicitly says
09:24:59 <shapr> yaxu: Hey, do you think there will ever be anything like freewheeling for Haskell?
09:25:00 <ndm> sorear: not when it was first written...
09:25:08 <sorear> well, I thought it did.
09:25:35 <sorear> dcoutts_: I know!  configurations.
09:25:40 <sorear> if compiler(ghc) {
09:25:45 <sorear>   Source-Dirs: ghc-fps
09:25:48 <yaxu> shapr: is that a time syncing thing?
09:25:50 <sorear> } else {
09:26:01 <dcoutts_> sorear: the problem is the lack of implementation for !ghc
09:26:02 <sjanssen> ooh, we're arguing about Unicode
09:26:08 * sjanssen reads the scrollback
09:26:33 <dcoutts_> sjanssen: fortunately not about what UTF encodings mean :-) that's a very tiresome one :-)
09:26:48 <shapr> yaxu: It's a program that does stuff like Imogen Heap does in her live acapella performances.
09:27:01 <sorear> dcoutts_: ghc, jhc, and hbc can use the ptrful code.  yhc can use its internal packedstring primitives.  everyone else can use [Word8]
09:27:08 <SamB> hmm. I think we need to look into giving lambdabot banning powerz
09:27:23 <SamB> like candide in ##c
09:27:51 <sorear> like @msg chanserv op #haskell
09:27:59 <dcoutts_> sorear: but [Word8] does not have the same semantics as ByteString, the strictness is quite different.
09:28:22 <yaxu> shapr: ah, loop layering?
09:28:27 <Philippa> SamB: bad idea. First, we have Chanserv for that. Second, it makes having admin powers on lambdabot a much bigger deal
09:28:39 <sorear> dcoutts_: The strictness of bytestring is already unpredictable, with fusion and all
09:28:49 <SamB> Philippa: I meant *automated* banning only
09:28:58 <dcoutts_> sorear: not nearly as much of a difference
09:29:21 <sorear> SamB: What do you mean automatic?
09:29:21 <shapr> yaxu: yeah, my girlfriend is a music student and she pointed me to a live Imogen Heap performance, so I apt-got freewheeling for her to play with last night. It's quite fun.
09:29:26 <Philippa> that's risky too
09:29:31 <SamB> then again, maybe it isn't a good idea because lambdabot might crash before expiring them...
09:29:33 <sorear> SamB: ChanServ can handle AUTOREM lists just fine!
09:29:40 <SamB> oh.
09:30:03 <quicksilver> we have very very rarely had incidents on this channel require use of OP powers
09:30:12 <yaxu> shapr: yes looks good, do you mean implementing it in haskell, or looping lots of bits of haskell? :)
09:30:13 <quicksilver> it hardly seems worth programming op-stuff into lambdabot
09:30:14 <SamB> sorear: well, say a bunch of bots come on to #perl6 and @tell TimToady obscene things
09:30:24 <sorear> quicksilver: + other than changing the topic :)
09:30:24 <quicksilver> unless it was purely purely as an exercise
09:30:40 <sorear> SamB: @purge-notices
09:30:55 <shapr> yaxu: Well, it reminded me of the stuff you've done, so I guess I was wondering about implementing loop layering in Haskell, whether recorded or generated.
09:31:01 <sjanssen> lambdabot has been used to spam people?
09:31:03 <sjanssen> that's a new one
09:31:05 --- mode: ChanServ set +o quicksilver
09:31:11 <Philippa> and then a chan-based ban. Lambdabot might need a notion of ignore though
09:31:28 <sorear> @help ignore
09:31:28 <lambdabot> ignore [+|-] nick. change a user's ignore status.
09:31:37 <yaxu> shapr: well you could do something in HSC for sure
09:31:39 <quicksilver> d'oh
09:31:45 <quicksilver> :)
09:31:47 <Philippa> sorear: that's not adequate
09:32:31 <Philippa> there's a reason you can use wildcards when you set +b
09:32:39 <yaxu> shapr: i like the idea of looping haskell
09:33:00 <shapr> Me too
09:33:15 <yaxu> enforcing a time structure upon a program
09:33:25 <shapr> Oh?
09:33:32 <Syzygy-> Hey yaxu
09:33:47 <yaxu> hey Syzygy-
09:34:22 <yaxu> i'm working on generating sound poetry at the moment
09:34:23 <shapr> yaxu: What do you mean?
09:34:26 * Syzygy- is almost sincerely considering buying a macbook in order to do Neat Livecoding Stuff...
09:34:34 <shapr> yaxu: How would you enforce a time structure on a program?
09:34:41 <sjanssen> why is Data.Binary slow in Hugs?
09:34:51 <shapr> yaxu: Also, do have tutorial that shows how other people can start doing Haskell livecoding themselves? :-)
09:35:07 <sjanssen> dcoutts_: do you know why?
09:35:27 <dcoutts_> sjanssen: because Data.ByteString is slow in hugs
09:35:32 <sjanssen> oh
09:35:41 <dcoutts_> because there are lots of primitive operations going on
09:35:44 <sjanssen> s/Data.Binary/Data.ByteString
09:35:47 <sorear> sjanssen: It is highly optimized by inlining
09:35:47 <sjanssen> :)
09:35:58 <yaxu> shapr: i'm not sure, maybe it was a stupid thing to say...  i guess you just take a lazy list of sound triggers and another lazy list of pause operations and zip them together
09:36:02 <sorear> sjanssen: Inlining is a win in GHC because code is code is code
09:36:11 <dcoutts_> which all get interpreted, vs lots of primitives that turn into a couple asm instructions each with ghc
09:36:17 <mauke> who the hell makes a torrent of a .rar containing four other .rars containing directories of files?
09:36:18 <sorear> sjanssen: Inlining is a loss in Hugs because it turns C into Haskell
09:36:39 <quicksilver> which is an interesting and subtle problem
09:36:40 <quicksilver> IMO
09:36:45 <dcoutts_> the optimisation strategy for hugs is simply to reduce the total number of reductions
09:36:58 <quicksilver> (if it's in fact a dull and obvious problem please enlighten me! :-)
09:37:06 <ndm> do we now get to take votes on what Igloo does?
09:37:10 <SamB> anyway, I think it would make sense to have lambdabot automatically silence or ban clients for flooding, botswarming, or just repeating an obscene message too many times
09:37:18 <Igloo> ndm: Feel free to have votes on whatever you like  :-)
09:37:19 <dcoutts_> for ghc you have all the low level things to play with, but playing with those do not help hugs if it increases the reduction count
09:37:19 <sjanssen> sorear: ndm claims 1000 times difference
09:37:20 <yaxu> shapr: yes rohan drape has done something, if you don't mind using emacs
09:37:26 <shapr> yaxu: I live in emacs.
09:37:26 <sjanssen> is this really all due to inlining?
09:37:27 <sorear> dcoutts_: I'm sure *some* reductions are costlier than others ;)
09:37:39 <shapr> yaxu: Not sure my girlfriend wants to learn emacs though.
09:37:42 <dcoutts_> sorear: sure, but to a first approximation
09:37:55 <ndm> sjanssen: ndm might have been inflating that a bit, but 100 is definately true
09:38:04 <yaxu> shapr: this is it - http://slavepianos.org/rd/r/darcsweb.cgi?r=sw-69;a=plainblob;f=/Help/Tutorial/Tutorial.lhs
09:38:06 <lambdabot> http://tinyurl.com/2tzutu
09:38:18 * ndm votes for Igloo to do his washing up
09:38:38 <SamB> ndm: why did you just refer to yourself as "ndm"?
09:38:39 * Igloo delegates that task to a big white box that whirrs
09:38:39 <sjanssen> even without inlining, Data.Binary is pretty straightforward, yeah?  Just push some bytes on to a ForeignPtr
09:39:00 <dcoutts_> SamB: ndm likes to refer to himself in the third person perhaps? :-)
09:39:04 <ndm> SamB, at least i didn't refer to myself as patricia
09:39:17 <SamB> ndm: that would have been really damn confusing, yes
09:39:25 <ndm> i don't like it when ndm refers to me by name
09:39:32 <shapr> yaxu: Nifty, are there more resources like this? Maybe a haskellwiki page I could peruse?
09:39:33 <SamB> okay...
09:39:47 <SamB> so why did you just do it?
09:39:53 <shapr> Igloo: White box testing, eh?
09:39:54 <ndm> is that 4th person?
09:40:01 <ndm> i'm trying to rack up my average
09:40:04 <SamB> heh
09:40:18 <SamB> I don't know of a 4th person in english
09:40:28 <SamB> I know of third people, though
09:40:35 * dcoutts_ thinks he's got the Gtk2Hs impl of SOE working using the -threaded RTS aka ghci
09:40:36 <dcoutts_> @arr
09:40:37 <lambdabot> I'll keel haul ya fer that!
09:40:39 <Jaak> ugh
09:41:03 <Jaak>    Bad interface file: /home/jaak/usr//lib/harpy-0.2/ghc-6.6.1/Harpy/CodeGenMonad.hi
09:41:09 <ndm> dcoutts_ - not got a 6.6.1 Win32 Gtk out yet?
09:41:15 <dcoutts_> ndm: I'll bug you to test that on win32 for me
09:41:20 <Jaak>     Something is amiss; requested module  harpy-0.2:Harpy.CodeGenMonad differs from name found in the interface file harpy:Harpy.CodeGenMonad
09:41:29 <dcoutts_> ndm: I'll have a go at building that this evening
09:41:31 <Jaak> this is weird
09:41:34 <ndm> dcoutts_ its a definate need within 2 weeks, so i can review my SOC student
09:42:43 <sorear> @remember ndm I don't like it when ndm refers to be by name
09:42:43 <lambdabot> Done.
09:42:54 <yaxu> shapr: for HSC?  there's *loads* of stuff in the help files
09:42:59 <Saizan> "me"
09:43:06 <mauke> sorear: s/be/me/
09:43:33 <yaxu> plus this http://www.haskell.org/haskellwiki/Applications_and_libraries/Music_and_sound
09:43:35 <lambdabot> Title: Applications and libraries/Music and sound - HaskellWiki, http://tinyurl.com/38fums
09:43:37 * shapr shows yaxu's youtube livecoding movies to his girlfriend
09:43:58 <sorear> @ask Pseudonym May we add a command for deleting (esp for fixing) quotes?
09:43:58 <lambdabot> Consider it noted.
09:44:37 <shapr> sorear: dons is the person to ask since he's the original maintainer. I wrote quote originally so you could draft me if you wish :-)
09:45:12 <sorear> shapr: May we add it?
09:45:23 <shapr> yaxu: Thanks for the info, we'll try it out! Is there some way to contact you in case I have more questions?
09:45:27 <shapr> sorear: Sure!
09:45:41 <sjanssen> sorear: maybe limit it to admins/quotees?
09:45:43 <shapr> sorear: Extending lambdabot == good
09:45:53 <shapr> Yeah, I think it should be an admin command.
09:46:03 <sorear> sjanssen: Anyone can @where+ lambdabot deleted
09:46:28 <yaxu> shapr: alex slab org , with relevant punctuation added
09:46:42 <shapr> yaxu: thanks!
09:47:00 * shapr boings cheerfully
09:49:42 * shapr builds hsshellscript to see if it can replace bash shell scripts.
09:50:14 <araujo> shapr, you can .. at some degree
09:50:24 * SamB wonders what a good way to interface his PDP-1 emulator with the UI would be..
09:53:48 <edwardk> samb: toothpaste and chewing gum
09:54:41 <SamB> hmm, is there a nice way to make *two* UIs for the same thing?
09:55:03 <ndm> SamB, yes, write a library which does "the good stuff", then use the library into two UI's
09:55:06 <shapr> SamB: typeclass?
09:55:12 <SamB> oh.
09:55:20 <ndm> SamB, remember that Hoogle has > 4 UI's
09:55:23 <edwardk> typeclasses and separate libraries =)
09:55:43 <ndm> very little need for typeclasses, that will encourage poor library design
09:55:59 <ndm> since you'll have your UI's implement functions which hook into the library, which will make it harder to reuse the code
09:56:21 <edwardk> ah true. i was just figuring since it was an emulator it would seem that the emulator would 'drive' the display, rather than the display query the emulator
09:56:26 <glen_quagmire> lolz i joined #haskellz
09:56:40 <edwardk> kind of an inversion of control from the hoogle paradigm which is mostly ask and receive
09:57:44 <ndm> hmm, usually you can factor things as ask/receive, which makes a better library interface
09:58:15 <shapr> I can has lambda now?
09:58:21 <edwardk> awkward to push character by character display updates and things like that no?
09:58:40 <sjanssen> @remember shapr I can has lambda now?
09:58:40 <lambdabot> Done.
09:58:44 <ndm> the library shouldn't be pushing character updates, it should be higher level
09:59:17 <gour> ndm: hi, how is SOC project going on?
09:59:27 <edwardk> i guess i build my emulators differently than you do =)
09:59:34 <ndm> gour: code is flowing, can't really tell until i have gtk2hs working on my machine
09:59:53 <ndm> http://darcs.haskell.org/~neil/ the code is all under there
09:59:54 <lambdabot> Title: Index of /~neil
10:00:05 <SamB> oh, I meant would it be practical to have multiple UIs at the same time?
10:00:33 <edwardk> woo, multiple teletypes ;)
10:01:46 <gour> ndm: thanks. you're waiting just a new gtk2hs release or cabalized one?
10:01:58 <ndm> gour: one that works with 6.6.1 on windows
10:02:00 <dcoutts_> just the new release
10:02:12 <dcoutts_> cabalised one is a long way off yet
10:02:22 <gour> i see...
10:02:31 <dukedave> Guys, you know how you're all really nice & smart. Also that I rarely go off topic.. Do you think I could maybe ask a tiny stats question on the off chance someone knows? :)
10:02:54 <sorear> @where stats
10:02:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
10:03:03 <sorear> you mean like that?
10:03:06 <Vq^> SamB: the unix way used to be to create a good cli application and then hack together some ugly tk wrapper for it
10:03:18 <dukedave> Okay, here we go..
10:03:20 <SamB> ndm: you know how you said I should make both a GUI and a command-line interface?
10:03:31 <SamB> well, it seems like maybe it would be nice to be able to use both at one time ;-)
10:03:44 <Spark> cli is useful for automatic tests
10:03:49 <ndm> SamB, if you want...
10:03:54 <dcoutts_> Vq^: but that sucked, so now the right way is to make a lib and build a curses and gtk UI using the lib
10:03:54 <ndm> SamB, although who would use both?
10:04:10 <Vq^> dcoutts_: it sure did
10:04:12 <dukedave>  I have a data set with a mean value & an std. dev. In plotting this on a graph I would like to translate the std. dev. into error bars. Should the top of each error bar should go std. dev. above each data point and std. dev. below it, or should it span std. dev. with the data point in the middle?
10:04:27 <Vq^> dcoutts_: so everybody end up using the good cli interface :)
10:05:07 <dcoutts_> aye, eg look at all the crap cd burner UIs there still are
10:05:17 <dcoutts_> because they all talk to cdrecord over pipes
10:05:40 <dcoutts_> and it doesn't help that cdrecord sucks too
10:06:18 <SamB> ndm: I would
10:06:26 <ndm> SamB, you're special :)
10:06:41 <ndm> SamB, its perfectly possible - perhaps event based and have both UI's intercept all the events
10:06:49 <gour> dcoutts_: nice to hear that (lib & gtk) - that's just what i plan to do ;)
10:06:57 <SamB> it's nice to have both blinkenlights and a textual UI
10:07:33 <dylan> what app are you talking about?
10:08:05 <SamB> PDP-1 emulator
10:08:12 <shapr> dukedave: http://en.wikipedia.org/wiki/Error_bars ?
10:08:14 <lambdabot> Title: Error bar - Wikipedia, the free encyclopedia
10:08:32 <SamB> haven't started yet because I have to figure out how to structure it
10:08:52 <dukedave> shapr: Be assured when I get an answer I will be putting it on there ;)
10:09:13 <SamB> maybe a textual UI would be better for mounting/unmounting tapes?
10:09:24 <shapr> dukedave: That page implies that there's a 'house style' for error bars.
10:09:40 <dukedave> I'm just not sure when it says 'range' if that mean +/- one std. dev. or +/- half an std. dev.
10:09:54 <dukedave> Ah yes, I noticed that..
10:09:59 <dcoutts_> ibid: ping
10:10:09 <dcoutts_> @seen ibid
10:10:10 <lambdabot> ibid is in #haskell. I don't know when ibid last spoke.
10:10:10 <SamB> then again maybe a GUI would be better, because that could actually show you any names that might be punched on the tapes...
10:10:59 <dcoutts_> ibid: I was going to add a couple soe demos to Gtk2Hs, several of them are your public domain code, but one has no such declaration, so I wanted to check that with you.
10:12:04 <shapr> Whoa, #haskell high water mark is up to 354, yay!
10:13:07 <bos> wow!
10:13:18 * araujo remembers when this channels was 90 people at most
10:13:31 <shapr> I remember when this channel had one person!
10:13:33 <sorear> @usrs
10:13:33 <lambdabot> Maximum users seen in #haskell: 354, currently: 330 (93.2%), active: 25 (7.6%)
10:13:52 <araujo> shapr, you were the first one coming in here?
10:14:33 <gour> "in the beginning there was lambda only..." :-)
10:14:44 <LoganCapaldo> Yeah he started the haskell curry fan club
10:14:54 <sorear> In the beginning, there was no lambdabot!
10:15:00 <LoganCapaldo> later for some reason the room occupancy soared
10:15:02 <shapr> araujo: Yes, the channel already existed when I got here, but no one was using it. So I contacted the person who created the channel and got maintainer-ness transferred to me. Then I started advertising!
10:15:28 <dukedave> gour, sorear, I feel there is a creationism debate coming on :)
10:15:40 <araujo> shapr, :-D
10:16:03 <sorear> shapr: Does the creator still come?
10:16:17 * araujo Trusts in The Monad
10:16:24 <gour> dukedave: see, see..
10:16:31 <shapr> sorear: I think once, about a week after I was maintainer.
10:22:55 <shapr> sorear: Also, I think the channel had only been registered for about two weeks when I took over.
10:23:21 <shapr> sorear: So the age you see in "/msg chanserv #haskell info" is very close to 'correct' .
10:23:29 <sorear> Was it originally for the same Haskell?
10:25:31 <shapr> It was originally for the Haskell programming language, if that's what you mean.
10:27:07 <MyCatVerbs> Why'd the original creator drop it anyhoo, out of curiosity?
10:27:21 <LoganCapaldo> shapr: apparently you mean /msg chanserv info #haskell fwiw
10:27:33 <dylan> perhaps he lost faith in The Monad?
10:27:59 <dukedave> Perhaps he ascended to the spiritual plane of Arrows? :)
10:30:52 <shapr> MyCatVerbs: I think the popular perception of Haskell at the time was that it was an esoteric language used only for research, and not relevant to the real world.
10:31:23 <MyCatVerbs> shapr: ...
10:31:47 <shapr> MyCatVerbs: In fact, when I started advertising #haskell, at least one #haskell regular who now has a job writing Haskell was convinced that I was tilting at windmills :-)
10:31:52 <gour> shapr: now we're waiting for "real-world" book :-)
10:32:17 <MyCatVerbs> shapr: that is also the popular perception of, say, Common Lisp and ML.
10:32:28 <shapr> gour: Yeah, I've enjoyed watching the popular perception of Haskell go from "cute toy" to "production tool".
10:32:56 <MyCatVerbs> shapr: and considering Haskell is less widely used than either of those, I'd say it's still the popular perception. At least, outside of reddit and other such functional havens.
10:33:22 <crazy_coder> hello everyone
10:33:34 <MyCatVerbs> (Er, I *believe* Haskell isn't as widely used as CL or ML. I couldn't actually tell you that for sure, though. I *can* say with confidence that Haskell is more fun, though. ;)
10:34:59 <dino-> I got a job a couple months ago at a place that's primarily lots and lots of OO Perl. They've been listening to me sneak Haskell into conversations so much that now I'm scheduled to give a talk about it here.
10:35:01 <shapr> MyCatVerbs: There are at least seven companies who are actively searching for skilled Haskell programmers for employment. The Haskell community isn't large, but it is tightly knit and well-connected. It's pretty easy to get a Haskell job if you demonstrate skill with the language.
10:35:38 <shapr> dino-: That's cool!
10:35:43 <dino-> Kind of terrified about it, but I feel that not trying to do things like this is to accept writing shitcode forever.
10:35:44 <MyCatVerbs> shapr: "tight knit" <-- now that is an understatement.
10:35:56 <shapr> MyCatVerbs: How so?
10:36:11 <ndm> i'd use friendly rather than tight knit
10:36:13 <shapr> dino-: Yeah! I totally agree! Keep on improving the world!
10:36:26 <ndm> its not like its an exclusive club, its just that people get on with each other and don't have flamewars
10:36:34 <dino-> We also have some people going to the imminent OSCON. I'm trying to encourage them to attend SPJ's talks.
10:37:35 <MyCatVerbs> shapr: you (and hopefully even we, should I ever get sufficient competence to be able to call myself a member rather than just a loony fanboy) look like goddamn Londoners compared to most programming languages' communities.
10:37:40 <shapr> ndm: Well, I don't mean 'tightly knit' in an exclusive sense. I just mean that if you get to know one Haskeller, it's easy to get to know more.
10:37:54 <shapr> MyCatVerbs: What's a Londoner in that context?
10:38:06 <sorear> ndm: Unfortunately, we *are* learning the meaning of "bikeshed" and "hysterical raisins".  Quickly.
10:38:09 <dino-> shapr: Thank you! I may yet have questions for you guys. I do this on July 20th.
10:38:33 <ndm> sorear: its not too bad, we just have to make sure Haskell stays inaccessible for a bit longer
10:38:36 <shapr> dino-: Feel free to ask questions, lots of friendly and helpful people here on #haskell :-)
10:38:46 <MyCatVerbs> shapr: peasant in London during the blitz. ;)
10:38:51 <ndm> less tutorials, more type theory!
10:38:57 <bos> how many people from #haskell are going to OSCON?
10:39:02 <bos> i
10:39:13 <MyCatVerbs> bos: where and when?
10:39:25 <dino-> MyCatVerbs: Portland, OR, US  July 23-27
10:39:30 <bos> portland, US, next month.
10:39:35 <shapr> MyCatVerbs: I still don't really get it, can you explain that in small words that an Alabama native can understand? :-)
10:39:39 <sorear> bos: Not SD anymore?
10:39:43 <bos> i know CosmicRay is planning to go.
10:39:54 <bos> SD?  OSCON's always been in OR.
10:40:14 <MyCatVerbs> shapr: damn tight.
10:40:27 <shapr> ah, ok
10:40:27 <ndm> MyCatVerbs: how do you mean "tight" ?
10:40:45 <ndm> in a negative "keeping others out", or a "well connected" sense
10:40:52 <dino-> I have had some hostility here over the big H too from some people. Like why are you wasting our time with this weird stuff. What does it have to do with our real world work.
10:41:03 <dino-> But not so much of that.
10:41:32 <MyCatVerbs> ndm: mainly well connected.
10:41:44 <rretzbach> Why should I use head and tail if I can pattern match (x:xs)?
10:41:55 <ndm> rretzbach: you can use either, when they suit you
10:41:59 <MyCatVerbs> ndm: but also habitually abducting passers-by and initiating them into the cult and having a jolly good time with 'em afterwards.
10:42:02 <rretzbach> Hmm.
10:42:09 <ndm> > map head ["neil","is","here"]
10:42:11 <lambdabot>  "nih"
10:42:24 <ndm> rretzbach: that would be a pain to do with a pattern match, but head makes it easier
10:42:27 <MyCatVerbs> rretzbach: whichever is more readable. :)
10:42:35 <ndm> in other places a pattern match is much nicer
10:42:52 <rretzbach> Okay, I agree.
10:43:05 <MyCatVerbs> > map (\(x:xs)->x) ["do","not","eat","yello","snow"]
10:43:08 <lambdabot>  "dneys"
10:43:14 <MyCatVerbs> *yellow, damnation.
10:43:18 <MyCatVerbs> Ah well, same result.
10:43:30 <sieni> @src head
10:43:30 <lambdabot> head (x:_) = x
10:43:30 <lambdabot> head []    = undefined
10:44:12 <rretzbach> What means "undefined"?
10:44:19 <ski> @src undefined
10:44:19 <lambdabot> undefined =  error "Prelude.undefined"
10:44:20 <rretzbach> Does that give me a runtime error?
10:44:21 <mux> error "Undefined"
10:44:25 <rretzbach> Ahh okay.
10:44:28 <mux> yes
10:44:32 <rretzbach> So it's a function.
10:44:32 <mux> head isn't a total function
10:44:40 <ndm> > head []
10:44:40 <mauke> > head ""
10:44:41 <mux> everything is a function :-)
10:44:44 <lambdabot>  Exception: Prelude.head: empty list
10:44:44 <lambdabot>  Exception: Prelude.head: empty list
10:44:52 <rretzbach> When is a function "total"?
10:44:57 <ski> sometimes defined as
10:44:58 <ski>   undefined | False = undefined
10:45:07 <MyCatVerbs> rretzbach: "total" means "defined for all possible values"
10:45:09 <mux> when it's well-defined for all the possible values it can take
10:45:10 <mauke> when it returns a value for all inputs
10:45:13 <sorear> rretzbach: When it never returns _|_ for non-_|_ inputs
10:45:23 <mux> wow, we're so helpful
10:45:23 <mauke> QUADROPHONICS
10:45:27 <mux> :D
10:45:28 <LoganCapaldo> > let map f xs = if null xs then [] else (f (head xs)):map f (tail xs) in map (+3) [0,-3,5]
10:45:29 <MyCatVerbs> rretzbach: like, in Scheme, sqrt is total. In Haskell, it isn't.
10:45:31 <lambdabot>  [3,0,8]
10:45:41 <mauke> > sqrt (0 :+ 1)
10:45:44 <lambdabot>  0.7071067811865476 :+ 0.7071067811865475
10:45:45 <ski> > sqrt (-1)
10:45:47 <lambdabot>  NaN
10:46:00 <ski> > sqrt (-1) :: Complex Double
10:46:01 <MyCatVerbs> rretzbach: because Haskell's will break if you give it a negative number, whereas Scheme will widen the result to a complex number.
10:46:03 <lambdabot>  -0.0 :+ 1.0
10:46:19 <MyCatVerbs> ski: unless you deliberately use the complex number library, of course. ^^
10:46:21 <dino-> @type (:+)
10:46:23 * mux notes that sorear, as usual, gave the most technical and thus most precise answer :-)
10:46:24 <lambdabot> forall a. (RealFloat a) => a -> a -> Complex a
10:46:25 <flux> well, isn't that still a total function, even if it responds with a NaN
10:46:46 <mauke> right
10:46:48 <dino-> I've never seen that function before. :o
10:47:07 * ski would contrapose sorear's statement ..
10:47:12 <mux> dino-: it's for constructing complex numbers
10:47:18 <mux> dino-: Data.Complex
10:47:21 <LoganCapaldo> @src Complex
10:47:22 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
10:47:40 <mux> > (0 :+ 1) ** 2
10:47:42 <LoganCapaldo> whyfor is Complex strict?
10:47:43 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
10:47:48 <mux> hrmpf
10:47:50 <dino-> neat
10:47:52 <ski> a :+ b  =  a + i * b  -- roughly .. where 'i' is an imaginary unit
10:47:54 <mux> > (1 :+ 0) ** 2
10:47:56 <lambdabot>  1.0 :+ 0.0
10:47:57 <mux> LoganCapaldo: speed
10:48:08 <mux> > (1 :+ 0) ^ 2
10:48:10 <lambdabot>  1.0 :+ 0.0
10:48:11 <mauke> LoganCapaldo: for what do you need a complex number that's only half defined?
10:48:20 <mux> > (0 :+ 1) ^ 2
10:48:23 <lambdabot>  (-1.0) :+ 0.0
10:48:26 <mux> ah.
10:48:30 <sjanssen> LoganCapaldo: you avoid building up giant thunks
10:48:31 <MyCatVerbs> LoganCapaldo: you're never interested in only the real or imaginary part, almost all arithmetic in complex numbers involves using both.
10:48:31 <crazy_coder> which is standard function to use if I want to get only the result of division (like 5/3 = 1)
10:48:41 <MyCatVerbs> So you might as well save the thunking time.
10:48:49 <MyCatVerbs> crazy_coder: quot or div or something, I can't remember which one.
10:48:49 <mauke> > 5 `mod` 3
10:48:51 <lambdabot>  2
10:48:58 <mauke> > 5 `div` 3
10:48:59 <MyCatVerbs> > 5 `quot` 3
10:49:01 <lambdabot>  1
10:49:01 <lambdabot>  1
10:49:13 <crazy_coder> MyCatVerbs: Thanks
10:49:16 <MyCatVerbs> crazy_coder: just try both in GHCI, see what you get. ;)
10:49:22 <LoganCapaldo> @quote stereo
10:49:23 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
10:49:32 <ski> crazy_coder : what should happen on negative numerator or denominator ?
10:50:03 <MyCatVerbs> > (-5 `quot` 3, -5 `div` 3)
10:50:04 <lambdabot>  (-1,-1)
10:50:13 <MyCatVerbs> > (-5 `quot` 2, -5 `div` 2)
10:50:15 <lambdabot>  (-2,-2)
10:50:21 <ski> > [divMod,quotRem] `ap` [16,-16] `ap` [7,-7]
10:50:23 <lambdabot>  [(2,2),(-3,-5),(-3,5),(2,-2),(2,2),(-2,2),(-2,-2),(2,-2)]
10:50:33 <MyCatVerbs> ap?
10:50:39 * MyCatVerbs lookup.
10:50:46 <mux> monadic application
10:50:47 <mauke> it'll eat your brain
10:50:57 <ski> > map (\f x y -> (f x y,x,y)) [divMod,quotRem] `ap` [16,-16] `ap` [7,-7]
10:50:58 <MyCatVerbs> mauke: I am noticing a pattern.
10:51:00 <lambdabot>  [((2,2),16,7),((-3,-5),16,-7),((-3,5),-16,7),((2,-2),-16,-7),((2,2),16,7),((...
10:51:04 <MyCatVerbs> mauke: in that most things seem to.
10:51:20 <mauke> @src ap
10:51:20 <lambdabot> ap = liftM2 id
10:51:26 <LoganCapaldo> oooo
10:51:39 <LoganCapaldo> ap w/ lists is something cool I'd not seen before
10:51:42 <ski> > return (,) `ap` [0,1] "abc"
10:51:43 <MyCatVerbs> mauke: frankly, I'm entirely lost.
10:51:44 <lambdabot>  Couldn't match expected type `t -> m a'
10:51:49 <ski> > return (,) `ap` [0,1] `ap` "abc"
10:51:53 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c')]
10:52:14 <mauke> MyCatVerbs: basically, it tries all combinations
10:52:19 <ski> > (,) `mapM` [0,1] `ap` "abc"  -- same thing
10:52:21 <lambdabot>  Couldn't match expected type `a -> b'
10:52:22 <MyCatVerbs> > return (+) `ap` [1..5] `ap` [5..10]
10:52:25 <lambdabot>  [6,7,8,9,10,11,7,8,9,10,11,12,8,9,10,11,12,13,9,10,11,12,13,14,10,11,12,13,1...
10:52:32 <ski> err, i mean 'liftM' of course
10:52:36 <ski> > (,) `liftM` [0,1] `ap` "abc"  -- same thing
10:52:39 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c')]
10:52:40 <LoganCapaldo> > return (,) `ap` (return 1) `ap` (return 2) :: Maybe (Integer, Integer)
10:52:43 <lambdabot>  Just (1,2)
10:52:49 <shachaf> Is it more standard to use `ap` than <*>?
10:53:05 <ski> @type (<*>)
10:53:06 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
10:53:08 <LoganCapaldo> > liftM2 (,) (return 1) (return 2) :: Maybe (Integer, Integer)
10:53:10 <lambdabot>  Just (1,2)
10:53:10 <MyCatVerbs> mauke: similar to how list comprehensions work?
10:53:14 <mauke> MyCatVerbs: yes
10:53:19 <ski> should be the same, only '(<*>)' is more general
10:53:19 <MyCatVerbs> :t ap
10:53:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
10:53:30 <ski> in case of monads, it doesn't matter
10:53:31 <MyCatVerbs> Oh shit, kinds.
10:53:39 <mauke> MyCatVerbs: ignore the part before .
10:53:40 * MyCatVerbs hides under the stairs and cries.
10:53:46 <mauke> it's irrelevant
10:53:54 <LoganCapaldo> ap is how you do liftMN for arbitrary N
10:54:01 <MyCatVerbs> Ohhh, that seems rather clever.
10:54:18 <ski> liftM3 f ma mb mc = return f `ap` ma `ap` mb `ap` mc
10:54:24 <mauke> MyCatVerbs: in list comprehensions you apply a function to multiple inputs. ap also takes multiple functions.
10:54:36 <MyCatVerbs> [(*),(+)] `ap` [0..2] [0..2]
10:54:42 <MyCatVerbs> [(*),(+)] `ap` [0..2] `ap` [0..2]
10:54:44 <ski> >
10:54:50 * MyCatVerbs facepalms.
10:54:53 <MyCatVerbs> > [(*),(+)] `ap` [0..2] `ap` [0..2]
10:54:55 <lambdabot>  [0,0,0,0,1,2,0,2,4,0,1,2,1,2,3,2,3,4]
10:54:57 <mauke> > [sqrt, (^2)] `ap` [0 .. 3]
10:54:59 <lambdabot>  [0.0,1.0,1.4142135623730951,1.7320508075688772,0.0,1.0,4.0,9.0]
10:55:06 <shachaf> @ty \f ma mb mc -> f <$> ma <*> mb <*> mc
10:55:08 <lambdabot> forall a a1 a2 b (f :: * -> *). (Applicative f) => (a -> a1 -> a2 -> b) -> f a -> f a1 -> f a2 -> f b
10:55:15 <MyCatVerbs> mauke: nice, that is kewl as Hell.
10:55:16 <ski> @type liftM3
10:55:18 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
10:55:40 <shachaf> @ty \f ma mb mc -> f `liftM` ma `ap` mb `ap` mc
10:55:42 <lambdabot> forall a1 a a11 b (m :: * -> *). (Monad m) => (a1 -> a -> a11 -> b) -> m a1 -> m a -> m a11 -> m b
10:56:10 <ski> return f `ap` ma = f `liftM` ma
10:56:27 <ski> mf `ap` return a = ($ a) `liftM` mf
10:56:38 <MyCatVerbs> mauke: is there any particular ordering imposed on the results? Does it just do a list comp [ f p q r... | p <- thing1, q <- thing2, r <- thing3... ] for each function in the list?
10:56:52 <MyCatVerbs> (And then concatenate all those lists together, I mean.)
10:56:56 <mauke> first things first
10:57:04 <ski> because
10:57:09 <MyCatVerbs> mauke: sensible.
10:57:37 <ski> mf `ap` ma = do f <- mf
10:57:40 <ski>                 a <- ma
10:57:42 <ski>                 return (f a)
10:57:43 <mauke> fs `ap` xs == [f x | f <- fs, x <- xs]
10:57:51 <mauke> :-)
10:57:54 <MyCatVerbs> Oh!
10:58:02 <ski> one *could* define 'ap' the other way around, to get the other nesting order
10:58:08 <MyCatVerbs> flist `ap` args1 `ap` args2...
10:58:16 <LoganCapaldo> > [ f x y | f <- [(*), (+)], x <- [0..2], y <- [0..2] ]
10:58:17 <mauke> yeah
10:58:18 <lambdabot>  [0,0,0,0,1,2,0,2,4,0,1,2,1,2,3,2,3,4]
10:58:28 <mauke> MyCatVerbs: that works because of currying
10:58:39 <LoganCapaldo> I seem to be slow
10:58:44 <MyCatVerbs> (flist `ap` args1) returns a list of the functions, partially applied to one argument, then that is partially applied to the next set of arguments, then... blah blah blah sausages for dinner.
10:58:46 <ski> > (,) `liftM` [0,1] "abc"
10:58:48 <lambdabot>  Couldn't match expected type `t -> m a1'
10:59:00 <ski> > (,) `liftM` [0,1] `ap` "abc"
10:59:03 <lambdabot>  [(0,'a'),(0,'b'),(0,'c'),(1,'a'),(1,'b'),(1,'c')]
10:59:10 <MyCatVerbs> mauke: I have acquaintances who tell me off for using the term currying for that. :)
10:59:12 <ski> > flip (,) `liftM` "abc" `ap` [0,1]
10:59:14 <lambdabot>  [(0,'a'),(1,'a'),(0,'b'),(1,'b'),(0,'c'),(1,'c')]
10:59:57 <MyCatVerbs> mauke: mainly because Haskell doesn't actually draw any distinction between partial application and currying, whereas the two *can* be different in imperative languages like lisp. :)
11:00:43 <bos> is use of Control.Applicative widespread?
11:01:09 <ski> f = \x -> \y -> ..x..y..  -- currying
11:01:09 <monochrom> Not very yet. But will grow.
11:01:14 <LoganCapaldo> Haskell makes a distinction. Currying just makes partial application have les syntactic overhead
11:01:14 <ski> map (f x) ys  -- partial application
11:01:35 <ski> bos : it ought to be
11:01:49 <MyCatVerbs> bos: yes, but we're dropping Agent Orange on its headquarters and napalming random innocent Vietnamese people in order to flush it out. Thus far, this doesn't seem to be working, so we'll just do it harder with more troops and more bombs and hope it suddenly starts working.
11:01:52 <monochrom> > map (map id) [[0,1],[2], []]
11:01:54 <lambdabot>  [[0,1],[2],[]]
11:02:22 <mauke> @free map
11:02:24 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:02:31 <olsner> @help free
11:02:31 <lambdabot> free <ident>. Generate theorems for free
11:02:32 <Syzygy-> MyCatVerbs: OO
11:02:33 <ski> @cofree map
11:02:35 <lambdabot> g . h = k . f => $map g . map h = map k . $map f
11:02:41 <olsner> "theorems for free"?
11:02:53 <LoganCapaldo> theorems for free!
11:02:58 <monochrom> Yes, there is a paper "theorems for free".
11:03:04 <ski> free the theorems !
11:03:05 <bos> apfelmus sent a very interesting critique of my FileManip library to libraries@, but his writing style was unusually elliptical.
11:03:25 <bos> so i read "blah blah blah ((->) a) blah blah"
11:03:29 <LoganCapaldo> @go theorems for free
11:03:32 <lambdabot> http://www.cs.chalmers.se/~koen/Aafp/free.ps
11:03:44 <MyCatVerbs> bos: thank him for the constructive criticism, then politely point out that it's actually quite hip to be square these days.
11:03:46 * LoganCapaldo wonders if that link is right
11:03:54 <ski> (Wadler wrote the paper, of course)
11:03:55 <monochrom> You just need an affine transform to turn elliptical to circular.  (duck)
11:03:59 <bos> MyCatVerbs: that's pretty much the plan
11:04:01 <shachaf> Is there any reason to use liftM rather than fmap or <*>?
11:04:24 <dancor> on my mac, i installed haskell with fink (after trying many other ways).  but when i compile, ld cannot find -lHShaskell98
11:04:25 <olsner> LoganCapaldo: it worked
11:04:30 <MyCatVerbs> LoganCapaldo: ghostview says... yep.
11:04:39 <Saizan> shachaf: you mean <$>?
11:04:48 <LoganCapaldo> shachaf: if someone forgets to write instance Functor for their monad...
11:04:50 <MyCatVerbs> :t liftM
11:04:52 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
11:04:54 <kpreid> shachaf: (a) the monad writer neglected to provide a Functor instance. (b) you're using liftM2/3 right next to it. (c) you want to restrict the type to Monad and not just Functor
11:05:03 <MyCatVerbs> scook0: liftM works for all monads, fmap only for Functors?
11:05:09 <ski> shachaf : 'fmap' and 'liftM' is the same, if you have a monad .. but 'fmap' also works for every functor, so is more general
11:05:28 <monochrom> Who is scook0? :)
11:05:39 <ski> shachaf : '(<*>)' and 'ap' is the same, if you have a monad .. but '(<*>)' also works for every applicative/idiom, so is more general
11:05:39 <shachaf> Saizan: Um, yes.
11:05:40 <olsner> it seems everything about haskell has been around for almost 20 years, and still haskell hasn't taken over the world
11:05:45 <ski> (every monad is a functor)
11:05:46 <MyCatVerbs> ski: I thought all functors were also neccessarily monads, or at least could be made into monads if the author weren't lazy?
11:05:59 <SamB> well, I suppose I don't really have to worry about race conditions in my PDP-1 emulator's UI...
11:06:04 <monochrom> Some authors are lazy.
11:06:09 <ski> (every monad is an applicative/idiom .. which all are functors, too)
11:06:24 <swiert> there are functors that aren't monads.
11:06:56 <ski> MyCatVerbs : istr some haskell functors not being monads being discussed here .. but i can't recall who they were
11:06:57 <SamB> though if I do support multiple UIs I'll need to have them exchange any changes they make to the switches and so on
11:07:31 <MyCatVerbs> ski: I suppose if there were a good reason for it...
11:07:44 <SamB> now, does anyone know where I can get some small toggle switch widgets, and small light widgets?
11:08:06 <ski> if haskell's class system allowed it, we would only have one of 'fmap','liftM' resp. '(<*>)','ap'
11:08:11 <SamB> I want to reproduce this control panel: http://www.dbit.com/~greeng3/pdp1/PDP1.10.jpg
11:08:57 <dancor> i do have /usr/local/lib/libHShaskell.a   how do i tell if ld is looking there?
11:08:58 <MyCatVerbs> Most data structures can be implemented in ways that satisfy the monad laws, right? Fibonacci heaps, for example.
11:09:11 <dancor> s/haskell.a/haskell98.a
11:09:15 <SamB> oh, some of the "switches" can be pushed up or down, or just left in the middle (where they return if you release them)
11:09:49 <ski> blinkenlichts !
11:09:58 <SamB> ski: yes! those!
11:10:11 <sjanssen> MyCatVerbs: ((,) a) is a Functor but not a Monad
11:10:34 <ndm> so, everyone, imagine you are writing a build system for Yhc
11:10:51 * sjanssen dies from all the stress
11:10:54 <ndm> which has to compile a Haskell program that makes use of Cabal packages, a C program, and lots of libraries
11:10:58 <ndm> how would you do it?
11:11:09 <MyCatVerbs> ndm: find someone lazy.
11:11:12 <MyCatVerbs> ndm: *really* lazy.
11:11:15 <sjanssen> ndm: Cabal for the Haskell, makefile for the C?
11:11:21 <ski> then force them to do it !
11:11:24 <ndm> sjanssen, that must work on Windows
11:11:37 <ndm> MyCatVerbs: volunteering?
11:11:41 <sorear> ndm: make works on windows I thought?
11:11:41 <MyCatVerbs> ndm: lazy and smart. Then threaten to stab them if they don't do it. Or worse yet, threaten to make them do the ironing.
11:11:46 <ndm> ski, got any mace?
11:11:57 <ndm> sorear, in the same way that Cygwin is a nice and friendly environment
11:12:04 <MyCatVerbs> ndm: smart lazy people will usually find an easier way to do it than anyone else would've bothered thinking of. ;)
11:12:07 <sjanssen> ndm: how does one build C programs on Windows?
11:12:07 <sjanssen> ndm: is the program simple enough for a simple .bat?
11:12:10 <ndm> sorear, Make is not nice and native on Windows
11:12:30 <ndm> sjanssen, the program is incredibly complex - think 10,000 lines of python build scripts - .bat is completely out
11:12:43 <ndm> sjanssen, GHC can build C programs, thats how i intend to do it
11:12:52 <sorear> yhi is just bloated :P
11:13:04 <ndm> sorear, submit your alternative!
11:13:11 <MyCatVerbs> ndm: it works, though. All it really *needs* to run is the ability to compare file modification dates and to open and close files.
11:13:20 <sjanssen> ndm: sure, it can call GCC -- but it is not a C build system
11:13:22 <ndm> MyCatVerbs, what works?
11:13:28 <MyCatVerbs> ndm: Make. Everywhere.
11:13:31 <ndm> sjanssen, indeed - but it can come quite close
11:13:32 <SamB> so... does anyone know of a nice Haskell GUI library that lets you write your own widgets?
11:13:54 <nominolo> SamB: gtk2hs
11:13:57 <ndm> btw, anyone suggesting Scons get's karma-'d
11:14:04 <nominolo> drawAreaNew
11:14:07 <sorear> ndm: You could always go with a simple build script and angband-style config.h files :)
11:14:12 <MyCatVerbs> ndm: you're already using Python anyway, why not try scons?
11:14:26 <ndm> MyCatVerbs, ~10,000 lines is Scons scripts in Python
11:14:32 <sjanssen> ndm: what is wrong with make on Windows?
11:14:58 <sjanssen> ndm: you already deal with using scons, which requires Python.  Is make comparatively arduous to install?
11:15:01 <ndm> sjanssen, its not designed to work with Cabal, its just not very good on Windows, and it just won't work well
11:15:10 <MyCatVerbs> sjanssen: even when it's finished doing its job, there's *still* a Windows machine under it instead of a real computer? ;)
11:15:12 <nominolo> SamB: or do you need something for windows?
11:15:20 <sorear> ndm: Why are you talking about Cabal for yhi?
11:15:22 <SamB> nominolo: that lets me write widgets?
11:15:23 <ndm> sjanssen, true - make is a lot cheaper than Scons, but make has many disadvantages
11:15:26 <sorear> ndm: seems kinda sillyu
11:15:38 <dcoutts_> SamB: yep, gtk2hs, you can draw widget stuff youself using cairo, and react to input events etc. People typically do it using/wrapping a DrawingArea widget
11:16:07 <ndm> sorear, whatever is easiest for Yhi, Cabal or other - i'm open to suggestions
11:16:23 <MyCatVerbs> dcoutts_: is Cairo that vector library they added opengl drawing for, or am I thinking of something else? Glitz?
11:16:28 <SamB> dcoutts: but it doesn't really count as a widget IMO.
11:16:30 <sjanssen> ndm: 10,000 lines just to build yhi?  (I'm assuming this is the C program we're talking about)
11:16:42 <dcoutts_> SamB: what are you looking for then?
11:16:46 <sorear> ndm: I'm thinking a 1-line .bat file (gcc this that the other) and a user editable config.h
11:16:49 <ndm> sjanssen, to build all of Yhc, Yhi, libraries, testing, pulling etc
11:17:08 <ndm> sorear, that seems reasonable
11:17:25 <dcoutts_> MyCatVerbs: yep, cairo is a vector graphics lib with multiple backends, including a glitz backend. It's also got png, xlib, win32 etc backends.
11:17:33 <SamB> arg, another botswarm in #perl6
11:17:34 <nominolo> MyCatVerbs: cairo is a vector drawing lib
11:18:10 <MyCatVerbs> dcoutts_: ah, Cairo's the interface and Glitz the guts. kewl.
11:18:10 <sorear> ndm: yhc and yhi have nothing to do with each other beyond a common file format... I think trying to use the same build system for both may be a mistake
11:18:41 <nominolo> SamB: what is your definition of widget?
11:18:47 <ndm> sorear, perhaps - we need some way to do both in one go - but that can be as simple as a script to do one then the other
11:18:47 <MyCatVerbs> sorear: user editable config.h always turns into a raging shitstorm, though. Unless you're only ever shipping prebuilt binaries, natch.
11:18:55 <nominolo> SamB: you mean this dashbord stuff?
11:18:56 <ndm> sorear, but they do need to coordinate for testing and stuff
11:19:08 <SamB> nominolo: I just want widgets for the lights and switches
11:19:24 <MyCatVerbs> SamB: lemme guess, you *have* an autokickban bot to deal with the botsorms in #p6...
11:19:32 <SamB> MyCatVerbs: no.
11:19:41 <SamB> nobody else seems to like the idea
11:19:41 <MyCatVerbs> SamB: but you're all too embarassed to turn it on because it's only writen in 5.8?
11:19:47 <SamB> !
11:19:55 <SamB> what's 5.8?
11:20:03 <sorear> MyCatVerbs: What do you mean?  Angband's configuration file doesn't seem much worse than ./configure --help in autoconf programs
11:20:08 <nominolo> what's perl?
11:20:09 <MyCatVerbs> sorear: current stable Perl.
11:20:15 <MyCatVerbs> s/sorear/SamB/
11:20:16 <SamB> oh, Perl
11:20:58 <sorear> @remember nominolo what's perl?
11:20:58 <lambdabot> Done.
11:21:04 <MyCatVerbs> sorear: What about the myriad little adjustments that you get when moving between almost-similar POSIXen?
11:21:34 <SamB> anyway, I'd want to be able to use my widgets in the same idiomatic ways that I could use the widgets that come with the library.
11:21:38 <MyCatVerbs> sorear: like, library and functions' and includes' names chage in between POSIX OSen.
11:21:41 <sorear> MyCatVerbs: that's in a different file users don't touch. (h-config.h)
11:22:11 <MyCatVerbs> sorear: jah, okay. But how do you generate that? You're back in autoconf territory, once you're dealing with that.
11:22:30 <SamB> at first I thought you meant GHC 5.8
11:22:38 <SamB> but I don't know that such a version ever happened
11:22:49 <SamB> I haven't seen anything older than 6.2
11:22:55 <MyCatVerbs> SamB: oh, no. I haven't been around long enough to. ;)
11:23:08 <SamB> I thought you were making up an old-sounding version
11:24:04 <nominolo> i'm so glad ruby came along, so that i don't have to write perl scripts for download scripts etc anymore
11:24:33 <MyCatVerbs> SamB: nahhh.
11:25:16 <SamB> anyway, it seems that the control panel on a PDP-1 has some lights, and some switches, and that I can handle them asynchronously from eachother...
11:25:39 <MyCatVerbs> SamB: it has a clockspeed measured in kilohertz, right?
11:25:50 <SamB> MyCatVerbs: 200 kHz I think
11:26:02 <sorear> SamB: ... and what's the cycle time?
11:26:02 <nominolo> whoa
11:26:03 <MyCatVerbs> Don't even bother multithreading. Hell, write it in Visual BASIC deliberately to make a point.
11:26:26 <nominolo> i wonder how long it would take to compile ghc with -O2 an a PDP-1
11:26:27 <MyCatVerbs> Visual BASIC 3.0 or 4.0, one of the ones before they added an actual compiler instead of embedding the 'terp.
11:26:29 <SamB> > 1 / 200e3
11:26:31 <lambdabot>  5.0e-6
11:26:42 <SamB> 5 microseconds, it seems
11:26:55 <SamB> ah, yes
11:27:04 <MyCatVerbs> What's the IPC on it?
11:27:06 <sorear> SamB: Early computers required 4-20+ cycles to execute anything....
11:27:07 <monochrom> PDP-1 probably does not have enough memory to build ghc.
11:27:12 <sorear> MyCatVerbs: I've seen a real time CPU emulator written in Perl.
11:27:14 <Syzygy-> Hehe
11:27:15 <SamB> sorear: yeah.
11:27:20 <sorear> MyCatVerbs: It used sleep calls.
11:27:23 <MyCatVerbs> monochrom: not enough *address space*, forget memory.
11:27:30 <nominolo> monochrom: and no backend ;)
11:27:31 <MyCatVerbs> sorear: !!!
11:27:35 <MyCatVerbs> sorear: usleep? =D
11:27:35 <sorear> MyCatVerbs: It didn't bother with accounting for time taken in computation
11:27:36 <SamB> sorear: well, this one is fast
11:27:50 <sorear> OK, select undef, undef, undef
11:28:01 <SamB> sorear: it seems that many of them take only one or two cycles
11:28:07 <sorear> Wow.
11:28:07 <monochrom> Well I like making a weaker but still sufficient statement.
11:29:11 <nominolo> otoh, with 10 chars / second it would take ages to just _show_ the ghc source code
11:29:16 <SamB> monochrom: what about magtape?
11:29:42 <nominolo> (yes, old terminals were that slow)
11:29:47 <sorear> Just set up the PDP with a 30baud modem and access network swap disks with software-managed doubleword addressing.
11:29:49 <xerox> have lambdabot part #perl6 please.
11:29:59 <sorear> @part #perl6
11:30:03 <xerox> thanks
11:30:03 <SamB> apparantly @tell has some kind of race condition
11:30:03 <monochrom> 30 baud :)
11:30:28 <sorear> xerox: who's being @tell'd?
11:30:35 <sorear> @activity-full 180
11:30:35 <lambdabot> 37*total 37*#perl6
11:30:40 <SamB> sorear: what about a paper-tape relay?
11:30:53 <MyCatVerbs> 30 baud...
11:31:03 <MyCatVerbs> You could actually compete with that using RFC1149x.
11:31:09 <MyCatVerbs> *RFC1149
11:31:29 <sorear> @activity-full 180
11:31:29 <lambdabot> 38*total 37*#perl6 1*#haskell
11:31:40 <monochrom> RFC1149x is RFC1149 with Mutant-X pigeons. :)
11:31:43 <sorear> @print-notices
11:31:44 <lambdabot> fromList [("TreyHarris:",(Nothing,[Note {noteSender = "markstos", noteContents = "Thanks for the unspecced clarification.", noteTime = (1159042987,796842000000), noteType = Tell}])),("agentzh:",(
11:31:44 <lambdabot> Nothing,[Note {noteSender = "markstos", noteContents = "I've made several links to L<S16>, which is described in S29, but doesn't exist. Perhaps these shouldn't be considered errors now since we
11:31:44 <lambdabot> know the document will eventually exist.", noteTime = (1158062003,104344000000), noteType = Tell}])),("andara:",(Nothing,[Note {noteSender = "audreyt", noteContents = "does webterminal server
11:31:44 <lambdabot> actually spawn children? it doesn't look like it", noteTime = (1161059780,744336000000), noteType = Tell}])),("augustss:",(Nothing,[Note {noteSender = "astrolabe", noteContents = "Just a sketch http:
11:31:44 <MyCatVerbs> Just wind a bit of magnetic tape around the pigeons' legs instead of plain paper.
11:31:46 <lambdabot> //hpaste.ath.cx:8000/23", noteTime = (1169425156,589759000000), noteType = Tell}])),("dcoutts:",(Nothing,[Note {noteSender = "dons", noteContents = "random public complaint about gtk2hs on freebsd,
11:31:49 <lambdabot> [338 @more lines]
11:32:00 <MyCatVerbs> monochrom: that and dodgy typing.
11:32:01 <sorear> @purge-notices
11:32:01 <lambdabot> Messages purged.
11:32:07 <SamB> sorear: why are you doing that in public?
11:32:07 <olsner> MyCatVerbs: the latency is probably worse on avian ip though
11:32:14 <SamB> also why are you purging all of them?
11:32:22 <SamB> we need a command to purge notices by content
11:32:36 <sorear> because 99% of them are trash?
11:32:46 <MyCatVerbs> olsner: the difference becomes inconsequential over sufficiently large file transfers, though. X-GIFs, for example.
11:33:10 <SamB> MyCatVerbs: I thought sneakernet would be simpler than training carrier pigeons to cross a room...
11:36:56 <sorear> @activity-full 180
11:36:56 <lambdabot> 0*total
11:39:30 * SamB wonders how to implement the "tape feed" switch's function...
11:40:42 <olsner> SamB: a room full of illegal immigrants cutting and pasting?
11:41:19 <SamB> olsner: well, this handbook says that it just feeds blank tape through the punch...
11:42:11 <olsner> "how many aliens does it take to ..."
11:43:04 <SamB> well, one thing I wonder is "is that just so that you can rip it?"
11:44:22 <olsner> hmm, I was reading "switch" as something that splits the tape into parts heading different directions... but I guess that you're talking about something that switches on and off the "tape feed"?
11:44:36 <SamB> yes ;-)
11:44:48 <olsner> perhaps you control the feed and the punch separately?
11:45:11 <SamB> well, I think it's not a toggle switch actually
11:45:45 <sorear> Push button to advance tape by 1 character
11:45:52 <sorear> yay RSI
11:46:29 <SamB> I think it's a "push it for as long as you want the blank tape to be fed"
11:49:03 <shachaf> So can liftM, fmap, map, mapMaybe, (.), and (<$>) really all be replaced by a single function, in theory?
11:49:12 <sorear> Yes.
11:49:38 <shachaf> And why aren't they?
11:50:18 <Heffalump> confusing type errors
11:50:25 <Heffalump> @type (<$>)
11:50:28 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
11:50:38 <Heffalump> and loss of idiomatic reading of code
11:50:40 <oerjan> because Haskell doesn't support subclasses having defaults for superclass methods
11:51:20 <mauke> I want them replaced by two functions, . and map
11:54:21 <Heffalump> I'm not sure I see the benefit.
11:54:29 <Heffalump> Having every Monad be a Functor would be nice.
11:54:43 <Heffalump> but I'd still rather use a name that reflects my thought processes
11:54:56 <Heffalump> and I don't want to force everything into a functorial view of the world
11:56:50 <monochrom> But I want to.
11:56:50 <oerjan> @src <$>
11:56:51 <lambdabot> f <$> a = fmap f a
11:57:05 <oerjan> heh, they actually _are_ identical
11:57:13 <Heffalump> you can use the more general combinators everywhere, then
11:57:16 <LoganCapaldo> @src fmap
11:57:16 <lambdabot> Source not found. Where did you learn to type?
11:57:25 <oerjan> @src Functor
11:57:25 <lambdabot> class  Functor f  where
11:57:25 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
11:57:26 <Heffalump> But leave the specialised ones for me to use :-)
11:57:32 * LoganCapaldo was hoping for fmap f a = f <$> a
11:57:44 <mauke> I want class Functor f where map :: ...
11:58:03 <Heffalump> sometimes it's important to have specialised types to pick the right type class instance, too
11:58:04 <mauke> and f . x = map f x
11:58:53 <oerjan> @src (->) fmap
11:58:54 <lambdabot> fmap = (.)
11:58:57 <monochrom> I suspect it's mainstream programmer psychology to like to be told to regard everything as ____.
12:00:46 <monochrom> OK, I think I was wrong. Most likely mainstream programmers just want to get something done and couldn't care less otherwise.
12:02:53 <MyCatVerbs> How's the optimizer in ghc, anyhoo? I'm... vaguely curious.
12:03:11 <MyCatVerbs> Like, will it eliminate gratituous uses of const, for example?
12:03:25 <LoganCapaldo> there's gratitous uses of const?
12:04:13 <LoganCapaldo> oh I guess x = const foo bar would be gratitous
12:05:02 <oerjan> > foldl' const 1 [2..100]
12:05:06 <lambdabot>  1
12:05:30 <LoganCapaldo> Does that really happen though?
12:05:38 <ptolomy> http://code.google.com/p/hiccup/ <-- an old project of mine that I figured I should put up somewhere.. it is a mimimalist (and fairly efficient.. faster than basic C version) tcl interpreter. Anyone have a few minutes to give it a quick look and maybe a suggestion or two before I embarrass myself by posting it to the Cafe? :-P
12:05:39 <lambdabot> Title: hiccup - Google Code
12:05:48 <oerjan> maybe as a result of other optimizations?
12:05:50 * LoganCapaldo he wondered
12:06:38 <MyCatVerbs> LoganCapaldo: dunno. I'll try it.
12:06:49 <dcoutts_> MyCatVerbs: the ghc optimiser is pretty amazing actually, but not black magic, it does everything by a series of transformations.
12:07:16 <MyCatVerbs> :t const
12:07:20 <lambdabot> forall a b. a -> b -> a
12:07:48 <dcoutts_> so yes, it will eliminate gratuitous uses of const, usually by inlining and then simplifying
12:07:51 <MyCatVerbs> Oh, cool, seems to.
12:08:30 <LoganCapaldo> @djinn (a -> b) -> (a -> (b -> r) -> r)
12:08:30 <lambdabot> f a b c = c (a b)
12:09:08 * MyCatVerbs tried using the o(2^n) algorithm for fibonacci in: main = do putStrLn $ show $ const (fib 8) (fib 4000) -- should end sometime after the sun goes out
12:09:20 <MyCatVerbs> Which worked perfectly, yay.
12:10:06 <LoganCapaldo> err does that prove removal of grattous use of const?
12:10:11 <dcoutts_> nope
12:10:13 <LoganCapaldo> or just lazy evaluation?
12:10:14 <dcoutts_> just lazyness
12:10:31 <LoganCapaldo> that's what  I thought
12:10:41 <sorear> MyCatVerbs: What's the O(2^N) algorithm?
12:10:45 <dcoutts_> MyCatVerbs: the non-strict semantics is what gives you that, not optimising const
12:11:07 <dcoutts_> MyCatVerbs: you'll get the same result with any other haskell implementation, and with ghc with or without -O
12:11:12 <LoganCapaldo> in fact in a strict language, optimizing const like that would be wrong, wouldn't it?
12:11:17 <dcoutts_> yep
12:11:19 <oerjan> er, a functionally defined fib doesn't use laziness unless ghc's optimization is rather good
12:11:20 <sorear> MyCatVerbs: I'm only familiar with the O(phi^N), O(N), and O(log N) algorithms
12:11:55 <crazy_coder> sorear: 2^n time complexity is involved generally with binary tree algos
12:12:07 <LoganCapaldo> oerjan: it's not the lazyness of fib, it's the laziness of const
12:12:30 <oerjan> > let fib 0 = 1; fib 1 = 1; fib n = fib (n-1) + fib (n-2) in fib 4000
12:12:36 <lambdabot> Terminated
12:12:42 <sorear> oerjan: that's not O(2^N)
12:13:45 <oerjan> oh, i misread the starting comment
12:13:57 * sjanssen probably missed the context, but "2^n time complexity is involved generally with binary tree algos"?
12:14:23 <oerjan> i thought somehow MyCatVerbs implied ghc calculated fib 4000 by a recursive algorithm fast...
12:14:51 <sjanssen> generally the trees are binary because you can half the search space each step of the way, giving O(log n)
12:15:07 <oerjan> sorear: well it's exponential
12:15:59 <LoganCapaldo> it's not 2^N? I must be playing two fast and loose
12:16:00 <sjanssen> sorear: you can't really do n fibs in O(log n), the digits of the result are linearly proportional to n
12:16:04 <shachaf> x = const "abcdefg" "tuvwxyz"; main = print x -- compiled with just --make, strings shows "tuvwxyz" in the binary; with -O2, it doesn't.
12:16:23 <LoganCapaldo> shachaf++
12:16:27 <LoganCapaldo> good show
12:16:40 <sjanssen> shachaf: this is surprising?
12:16:40 <sjanssen> ah, I see the context now
12:16:52 <crazy_coder> sjanssen: Yes you are right
12:17:46 <crazy_coder> But sometimes if one is writing balanced trees and n number of other types trees have certain operations which are of that complexity afaik
12:17:48 <sjanssen> sorear: you can do it in O(log n) multiplications, but they start getting expensive after a while :)
12:19:07 <monochrom> http://www.vex.net/~trebla/haskell/calculator/Calculator.hs  has one such algorithm
12:19:56 <monochrom> You can also just read http://www.vex.net/~trebla/haskell/calculator/Calculator.html
12:24:18 <LoganCapaldo> > let sieve (p:s) = p : sieve (filter (\n -> rem n p /= 0) s) in sieve [2..]
12:24:27 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:24:39 <LoganCapaldo> hooray primes
12:25:29 <sorear> > nubBy(((>1).).gcd)[2..] --much shorter
12:25:32 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
12:25:55 <LoganCapaldo> I was only cribbing from the Calculator.hs. You gonna send a patch sorear? :)
12:26:11 <sorear> Oh, I didn't see it in there. :)
12:27:50 <LoganCapaldo> @unpl (((>1).).gcd)
12:27:50 <lambdabot> (\ e h -> (gcd e h) > 1)
12:28:26 <sjanssen> @pl \x -> (/= 0) . (`mod` x
12:28:27 <lambdabot> (line 1, column 17):
12:28:27 <lambdabot> unexpected "`"
12:28:27 <lambdabot> expecting lambda abstraction or expression
12:28:35 <sjanssen> @pl \x -> (/= 0) . (`mod` x)
12:28:35 <lambdabot> ((0 /=) .) . flip mod
12:29:08 <sjanssen> > length "(((>1).).gcd)"
12:29:11 <lambdabot>  13
12:29:30 <sjanssen> > length "((0 /=).).flip mod)"
12:29:33 <lambdabot>  19
12:29:46 <LoganCapaldo> hehhe
12:29:51 <sjanssen> > length "((0>).).flip mod)"
12:29:54 <lambdabot>  17
12:30:00 <LoganCapaldo> code prime characters in length, to find primes
12:30:21 <sjanssen> is the extra efficiency worth 4 characters?
12:30:21 <monochrom> sorear's is certainly shorter. But I have actually implemented one of Melissa E. O'Neill's faster algorithms and have not uploaded yet.
12:31:27 <LoganCapaldo> the best would be an O(1) isPrime :: (Num a) => a -> Bool combined with filter :)
12:31:49 <mauke> isPrime = const True
12:31:54 <monochrom> I want O(1) isPrime too. Where can I find one?
12:32:08 <monochrom> But the class should be Integral not Num.
12:32:13 <LoganCapaldo> oops
12:34:06 <LoganCapaldo> let isPrime n = n `elem` primes; let primes = filter isPrime [2..] :)
12:34:28 <LoganCapaldo> > let isPrime n = n `elem` primes; let primes = filter isPrime [2..] in primes
12:34:29 <lambdabot>  Parse error
12:34:45 <monochrom> I wonder, if I use Data.Set, but I only use it as a priority queue (insert anything, peek and remove minimum only), does it behave as a heap time-wise, i.e. O(1) peek/remove minium?
12:34:48 <sjanssen> Exception: <<loop>>
12:34:55 <LoganCapaldo> > let isPrime n = n `elem` primes; primes = filter isPrime [2..] in primes
12:34:57 <lambdabot>  Exception: <<loop>>
12:35:01 <LoganCapaldo> there it is
12:35:12 <sjanssen> I win!
12:35:19 <sjanssen> monochrom: peek is O(log n)
12:35:21 <monochrom> Err correction, O(1) peek minimum.
12:35:31 <LoganCapaldo> sjanssen always wins
12:35:37 <monochrom> That is unfortunate.
12:35:54 <SamB> so... have I heard any talk of unifying Int#/Word# internally?
12:36:11 <sjanssen> monochrom: it is a fairly cheap O(log n), though (no comparisons, just pointer dereferences)
12:36:49 <monochrom> If I always peek-and-remove-anyway, it probably doesn't matter.
12:36:55 <sorear> monochrom: Have you read about finger trees yet? :)
12:37:04 <monochrom> No.
12:37:13 <SamB> I mean, in Core?
12:37:14 <sorear> SamB: Yes, and I've been the biggest proponent afaict.
12:37:24 <SamB> sorear: where can I sign?
12:37:28 <SamB> I want in on this.
12:38:14 <sorear> Probably better would be to give GHC real support for subword types.
12:38:25 <SamB> subword types?
12:38:49 <sjanssen> what's the advantage of unifying them?
12:39:00 <SamB> sjanssen: I'd show you but hpaste is down
12:39:14 <sjanssen> SamB: GHC represents Word8 as a Word#
12:39:15 <SamB> anyway, I think it would make code more efficient
12:39:20 <SamB> sjanssen: so?
12:39:23 <sorear> SamB: hpaste is working fine
12:39:37 <LoganCapaldo> hpaste just isn't working
12:39:44 <LoganCapaldo> namespace collision!
12:39:47 <sjanssen> sorear: sure about that?  It's hanging over here
12:39:54 <sorear> sjanssen: No.
12:40:14 <SamB> I tried to go to the page but I got "unable to connect"
12:40:44 <sorear> SamB: in GHC, *everything* is an integral number of machine words.  On a 64 bit machine that prefers 32 bit data, Int# is 64 bits
12:40:49 <SamB> anyway, as far as I know GHC doesn't act as if converting back and forth is free
12:41:00 <SamB> sorear: oh, that.
12:41:04 <SamB> that does seem kinda stupid
12:41:45 <sorear> SamB: And Word8 is 32 bits on 32 bit computers, just with software implemented wrapping.
12:41:53 <SamB> that's less stupid
12:42:27 <LoganCapaldo> 8 = the number of bits / byte?
12:42:57 <SamB> in POSIX yes
12:43:10 <LoganCapaldo> Well I meant in the name "Word8"
12:43:17 <LoganCapaldo> Was wondering where the 8 came from
12:43:34 <SamB> we also have Word16, Word32, Word64 at least
12:43:58 <sorear> LoganCapaldo: it's the bitsize
12:44:26 <sorear> in C, a byte is a machine defined unit of storage of at least 8 bits
12:44:33 <SamB> anyway... my point is that GHC acts as if wordToInt# and intToWord# actually do something
12:44:40 <sorear> eg, often 9 on pdp10s
12:44:41 <SamB> also they clutter Core displays
12:45:06 <sorear> SamB: How about providing :CoWord :: Int# ~ Word#
12:45:15 <sorear> SamB: GHC already knows `cast` is free
12:45:17 <SamB> sorear: I don't know if that would work any better
12:45:40 <SamB> that stuff is fine for high-level things but probably plays merry hell with bit-twiddling
12:46:41 <SamB> anyway, it seems rather silly to have to coerce back and forth just to do an xor...
12:47:06 <Philippa> the coercion'd still make for cluttered syntax when you read it
12:47:14 <SamB> that too
12:47:35 <SamB> anyawy you were already a proponent of Int#/Word# unification. why do I have to argue with you?
12:48:05 <crazy_coder> whats wrong with this :
12:48:06 <crazy_coder> invert :: [(Char,Int)] -> [(Char,Int)]
12:48:06 <crazy_coder> invert [(x,s)] = [(x,s)]
12:48:06 <crazy_coder> invert ((c,x):xs) = invert xs : (c,x)
12:48:28 <LoganCapaldo> So a Word8 is actually a value of "at least 8bits"?
12:48:39 <olsner> @src reverse
12:48:39 <lambdabot> reverse = foldl (flip (:)) []
12:48:43 <crazy_coder> I am getting an error : mismatch of types basically
12:48:44 <mauke> crazy_coder: the :
12:48:46 <Saizan> crazy_coder: invert xs ++ [(c,x)], you can't cons to the end
12:48:47 <SamB> LoganCapaldo: ... no.
12:48:52 <kpreid> crazy_coder: : is not concatenation
12:48:56 <kpreid> @type (:)
12:48:58 <lambdabot> forall a. a -> [a] -> [a]
12:49:06 <LoganCapaldo> the Word thing is throwing me off
12:49:08 <crazy_coder> Ah Thanks. Its really funny why we can;t
12:49:13 <SamB> LoganCapaldo: it always acts as an 8-bit thing
12:49:18 <kpreid> for your code to work you'd need [a] -> a -> [a]
12:49:44 <kpreid> but your invert appears to be a restricted form of reverse, so just use reverse
12:49:48 <LoganCapaldo> So it's not a word, unless your arch happens to do 8bits to a word.
12:49:58 <LoganCapaldo> it's jsut an 8bit thing
12:50:05 <SamB> LoganCapaldo: the Word part means "unsigned"
12:50:12 <LoganCapaldo> Aha
12:50:18 <pastorn> what's the compiling option that usually is used? -glasgowexts or something
12:50:23 <LoganCapaldo> all clear to me no
12:50:26 <LoganCapaldo> *now
12:50:29 <mauke> -fglasgow-exts
12:50:30 <Philippa> or to put it another way "it's n bits of raw data"
12:50:51 <balodja> @lusers
12:50:52 <lambdabot> Maximum users seen in #haskell: 354, currently: 324 (91.5%), active: 16 (4.9%)
12:50:59 <pastorn> mauke: danke :)
12:51:10 <monochrom> -O2 -fasm :)
12:51:20 <olsner> > (-10 :: Word8)
12:51:22 <lambdabot>  246
12:51:27 <olsner> ;-)
12:51:29 * LoganCapaldo complains and moans, suggesting it should be Data8 or something
12:51:29 <sorear> -O2
12:51:42 <sorear> -fasm isn't needed unless your GHC is <6.6.1
12:51:50 <olsner> Why not just Int8?
12:51:54 <SamB> basically, what I'm suggesting is that GHC, instead of having two primitive word-sized numerical types, one signed and one unsigned, should have one real primitive type with primitives to do both kinds of arithmatic on it
12:52:06 <LoganCapaldo> olsner: I could live with that
12:52:16 <LoganCapaldo> or maybe UInt8
12:52:25 <olsner> two sets of integer operators? that sounds ugly
12:52:40 <SamB> olsner: that's what CPUs do anyway
12:52:48 <Philippa> olsner: Int8 would be signed
12:52:49 <LoganCapaldo> but I'm done complaining now
12:53:00 <LoganCapaldo> Now I know Word doesn't mean a word, I'm good
12:53:03 <SamB> except they only have two versions of an operation if there is a difference between signed and unsigned arithmatic for that operation
12:53:26 <SamB> olsner: anyway, this is internals stuff
12:53:28 <Philippa> olsner: this isn't something you'd get exposed to even using the Word and Int types
12:53:32 <sjanssen> SamB: are you sure the conversion from Word# to Int# isn't free?
12:53:38 * sjanssen bets it is
12:53:51 <SamB> sjanssen: it is free, but GHC's optimizer doesn't seem to 100% realize this
12:54:01 <weitzman> If you want a useful finite integral type, one that doesn't silently overflow would be nice
12:54:05 <sjanssen> sounds like an optimizer bug
12:54:10 <SamB> well probably
12:54:14 <sjanssen> SamB: couldn't it be unsafeCoerce#?
12:54:18 <SamB> possibly
12:54:25 <crazy_coder> if I have a tuple (Char,Int) and a function which returns a tuple, how can one retrieve the char element of the tuple returned ?
12:54:37 <sjanssen> crazy_coder: fst
12:54:38 <oerjan> crazy_coder: fst
12:54:54 <crazy_coder> :)
12:54:56 <SamB> the simplifier really isn't very savvy with unlifted types, actually...
12:55:03 <SamB> afaict
12:55:09 <monochrom> case f x of (c,_) -> ... c is the char here ...
12:55:14 <olsner> @quote stereo
12:55:14 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
12:55:27 <olsner> obligatory quote ;-)
12:55:45 <SamB> but really it seems like it would be simpler all around not to have these coercions, rather than to do gymnastics to optimize things in which they appear
12:55:48 <oerjan> olsner: i'm just waiting for the quote itself to come in stereo
12:56:01 <monochrom> It has happened too.
12:56:44 <SamB> also in three-way
12:59:25 <nominolo> @ho Control.Applicative
12:59:25 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show thx v wn yow
12:59:29 <crazy_coder> @ src take
12:59:36 <nominolo> @hoogle Control.Applicative
12:59:36 <crazy_coder> @src take
12:59:39 <lambdabot> No matches, try a more general search
12:59:40 <lambdabot> take n _      | n <= 0 =  []
12:59:40 <lambdabot> take _ []              =  []
12:59:40 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
12:59:47 <crazy_coder> :t take
12:59:51 <lambdabot> forall a. Int -> [a] -> [a]
12:59:52 <nominolo> @slap lambdabot
12:59:53 * lambdabot slaps lambdabot
13:00:29 <nominolo> > take 5 [1,3..]
13:00:30 <crazy_coder> in the take function, does a have to be of type int only ?
13:00:31 <lambdabot>  [1,3,5,7,9]
13:00:39 <nominolo> no
13:00:44 <oerjan> :t genericTake
13:00:47 <lambdabot> forall i a. (Integral i) => i -> [a] -> [a]
13:01:03 <crazy_coder> I have a list of tuples (char, Int) It should work right ?
13:01:21 <crazy_coder> But I am getting an error over there
13:01:21 <nominolo> crazy_coder: yes, that's what the "forall a" states
13:01:29 <nominolo> !paste
13:01:48 <nominolo> crazy_coder: can you paste it at hpaste.org ?
13:02:07 <kpreid> > take 2 [('a',1),('b',2),('c',3)]
13:02:08 <crazy_coder> yes
13:02:08 <nominolo> http://hpaste.org/new
13:02:09 <lambdabot>  [('a',1),('b',2)]
13:02:34 <crazy_coder> Just a sec Ok I understood my error
13:02:43 <crazy_coder> I want to return a string
13:02:49 <crazy_coder> I was doing
13:02:50 <crazy_coder> putEarlier :: Char->[(Char,Int)]->Char
13:02:51 <crazy_coder> putEarlier ch ((c,x):xs) | (ch == c) = fst (take 1 xs)
13:02:51 <crazy_coder> 			 | otherwise = putEarlier ch xs
13:03:14 <kpreid> crazy_coder: take gives a list, fst wants a tuple
13:03:16 <olsner> oerjan: someone should add that to lambdabot, to always quote the stereo-quote in stereo
13:03:16 <crazy_coder> fst actually returns a tuple not a char right
13:03:19 <kpreid> you want head, not take
13:03:25 <nominolo> use head instead of fst
13:03:39 <crazy_coder> what will head do
13:03:42 <kpreid> @type take
13:03:42 <Saizan> or map fst?
13:03:43 <lambdabot> forall a. Int -> [a] -> [a]
13:03:44 <kpreid> @type head
13:03:46 <monochrom> > head [1,2,3,4]
13:03:46 <lambdabot> forall a. [a] -> a
13:03:48 <lambdabot>  1
13:03:58 <kpreid> > take 1 [1,2,3,4]
13:04:00 <lambdabot>  [1]
13:04:06 <crazy_coder> oh Ok
13:04:07 <crazy_coder> Thanks
13:04:09 <kpreid> head gives you the first *element*
13:04:14 <monochrom> Note that "1" and "[1]" are different.
13:04:15 <kpreid> take 1 gives you a 1-element list
13:05:45 <monochrom> The difference is underappreciated by beginners coming from other programming cultures. Many quirky languages deliberately identifies 1 with [1].
13:05:54 <crazy_coder> head will give me a tuple and fst $ head will give me a char. Is it ok ?
13:06:02 <monochrom> Yes!
13:06:03 <DRMacIver> monochrom: Example?
13:06:11 <monochrom> Matlab.
13:06:21 <DRMacIver> Hm. Ok.
13:06:42 <MyCatVerbs> monochrom: those bastards!
13:06:47 <nominolo> true, matlab is quirky
13:06:48 <MyCatVerbs> monochrom: er, I mean, all spit on Perl.
13:06:57 <MyCatVerbs> monochrom: and Basic and...
13:07:00 <DRMacIver> (10 years later: "Many quirky languages like Haskell identifty 1 and (1). But we know better.")
13:07:04 <MyCatVerbs> monochrom: but hey, lisp doesn't, w00t.
13:07:51 <MyCatVerbs> DRMacIver: Scheme doesn't. (1) returns a snarky error message from the 'terp or compiler or runtime. ^^
13:08:00 <Saizan> DRMacIver: well we don't consider tuples of size n to be the same type for different n, so (1) wouldn't be of much use
13:08:52 * oerjan vaguely recalls ocaml has (1,)
13:08:59 <Saizan> python too
13:09:10 <monochrom> Note that in Haskell (1) is not the same as (,) () 1 or (,) 1 ().
13:09:11 <crazy_coder> what the difference between ++ and : ?
13:09:24 <kpreid> @type (++)
13:09:25 <kpreid> @type (:)
13:09:26 <lambdabot> forall a. [a] -> [a] -> [a]
13:09:29 <lambdabot> forall a. a -> [a] -> [a]
13:09:33 <monochrom> 'c' : "hello"   and   "ccc" ++ "hello"
13:09:34 <kpreid> that's the difference
13:09:36 <Saizan> 2 week of searching a bug in a bot because of (a,)!
13:09:54 <DRMacIver> Saizan: It would be philosophically useful. :) I agree that there's not a lot of direct benefit.
13:10:03 <Saizan> ?src (++)
13:10:03 <lambdabot> (++) []     ys = ys
13:10:04 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
13:10:04 <Excedrin> Saizan: what was the bug?
13:10:44 <monochrom> Also  1 : [2,3,4]  and  [4,5,6]++[7,8,9]
13:10:48 <Saizan> Excedrin: passing a instead of (a,)
13:10:54 <Saizan> iirc
13:11:18 <MyCatVerbs> :t (1,)
13:11:19 <lambdabot> parse error on input `)'
13:11:34 <MyCatVerbs> Saizan: how _does_ one pass (a,)?
13:11:39 <nominolo> > () `(,)` ()
13:11:39 <lambdabot>  Parse error
13:11:54 <Saizan> MyCatVerbs: talking about python's (a,)
13:12:02 <MyCatVerbs> Saizan: ahhh, righto.
13:12:17 <nominolo> > let o = (,) in () `o` ()
13:12:19 <lambdabot>  ((),())
13:12:25 <Excedrin> so, in Haskell, there is a zero element tuple and N>1 element tuples, but no 1 element tuple?
13:12:26 <Saizan> you can pass \b -> (a,b) :)
13:12:36 <Saizan> Excedrin: exactly
13:13:24 <nominolo> for one-element tuples use newtype
13:13:40 <LoganCapaldo> > newtype OneTuple a = OneTuple a
13:13:40 <lambdabot>  Parse error
13:13:45 <nominolo> helps you infer its intended purpose, too
13:13:46 <monochrom> I am not sure in what sense () is a zero tuple.
13:14:01 <oerjan> :t (,).1
13:14:03 <lambdabot> forall b b1 a. (Num (a -> b)) => a -> b1 -> (b, b1)
13:14:04 <LoganCapaldo> I'm not sure () is a tuple either
13:14:08 <Saizan> monochrom: it looks like one :)
13:14:17 <LoganCapaldo> it could have just as well be written data Unit = Unit
13:14:30 <crazy_coder> hpaste is not working here ...  http://rafb.net/p/sKeDyo48.html
13:14:43 <Saizan> and (,) could be written data Two a b = T a b ..
13:14:48 <crazy_coder> can anyone pls tell me why I am getting  this error ?
13:14:53 * ptolomy realizes that he should probably create a downloadable tarball before deciding that his interpreter is "released".
13:15:03 <Excedrin> OCaml doesn't seem to have (1,)
13:15:40 <kpreid> crazy_coder: if nothing else, the first case of putEarlier has a value not matching its type
13:15:47 <ptolomy> If I'm working on a project that doesn't have any real outside dependencies, really shouldn't be installed, and only has a couple source files, is it worth it to make a cabal package?
13:16:12 <fbuilesv> Hello, I'm writing an application that will use SQLite as DB engine. Is it ok to use HSQL or is there something more modern and mantained?
13:16:28 <crazy_coder> kpreid: ignore the []  I did it because things were not working out
13:16:45 <LoganCapaldo> ptolomy: what if it grows? Will be easier to update an existing cabal file or add a new one? (I don't know the answer to this)
13:16:48 <oerjan> hm. maybe it was python i vaguely recalled...
13:16:48 <Saizan> fbuilesv: HDBC?
13:16:49 <crazy_coder> kpreid: you are right .. it should be just fst (...)
13:17:01 <monochrom> crazy_coder: I got "not in scope: invert" and "not in scope: roman".
13:17:07 <kpreid> crazy_coder: then paste the code you actually used, *with* the error you ot
13:17:12 <crazy_coder> kpreid: apart from that, is there any error ?
13:17:15 <mauke> crazy_coder: line 3 looks wrong
13:17:36 <ptolomy> LoganCapaldo: Not growing is part of the whole point of the project.. I'm keeping the simple version as a separate project, then creating a new branch where I will no longer concern myself with keeping things simple.
13:17:39 <fbuilesv> Saizan: I don't know, you tell me :D
13:17:55 <kpreid> crazy_coder: don't ask us to find it. show us what the compiler says and we'll explain it for you.
13:17:58 <LoganCapaldo> ptolomy: Oh well, in that case...I still don't know :)
13:18:06 <crazy_coder> ok wait
13:18:15 <crazy_coder> I'll paste the entire code
13:18:20 <monochrom> crazy_coder: I agree with kpreid.
13:18:37 <Saizan> fbuilesv: HSQL is quite minimal, HDBC feels more developed, never used it though, you can find it on hackage
13:18:40 <kpreid> crazy_coder: start with the error.
13:18:55 <fbuilesv> Saizan: Downloading right now, I'll take a deeper look, thank you :D
13:19:44 <crazy_coder> http://rafb.net/p/IgdyP491.html
13:19:46 <lambdabot> Title: Nopaste - No description
13:19:56 <crazy_coder> I am running it with ghci
13:19:58 <ptolomy> Broader question: If I have a fun little toy project that is a good demonstration of haskell strengths, where does one release it? Just announce on the cafe?
13:20:07 <crazy_coder> I'll have to manually type the error
13:20:13 <crazy_coder> Can't copy paste it
13:20:22 <mauke> are you on windows?
13:20:25 <Saizan> ptolomy: and hackage, if you cabalize it
13:20:25 <crazy_coder> no
13:20:32 <crazy_coder> mauke: linux FC-6
13:20:39 <mauke> then why can't you copy/paste?
13:20:44 <crazy_coder> executing it in shell
13:20:49 <mauke> ... so?
13:20:59 <crazy_coder> copy paste doesn't work
13:21:03 <crazy_coder> How do you do it
13:21:08 <monochrom> crazy_coder: I got "Could not find module `Types' "
13:21:17 <mauke> select with left mouse button, paste with middle mouse button
13:21:23 <crazy_coder> monochrom: remove  it
13:21:40 <crazy_coder> The definition of roman is in types
13:22:24 <crazy_coder> http://rafb.net/p/4JpxfF26.html
13:22:25 <lambdabot> Title: Nopaste - No description
13:22:30 <crazy_coder> Somehow it worked
13:22:33 <crazy_coder> this is the error
13:22:43 <pastorn> @hoogle Int -> Float
13:22:47 <lambdabot> No matches, try a more general search
13:22:51 <pastorn> what am i looking for?
13:22:51 <crazy_coder> Wasn't working yesterday
13:23:01 <monochrom> http://rafb.net/p/ICMhZo17.html   is the error message we all seek.
13:23:01 <lambdabot> Title: Nopaste - error message of crazy_coder
13:23:02 <crazy_coder> :p
13:23:13 <mauke> told you so
13:23:45 <Saizan> pastorn: fromIntegral?
13:23:47 <crazy_coder> monochrom: yes same here
13:23:51 <kpreid> crazy_coder: putEarlier yields a character. you are passing it to : which wants a list in the definition of repeatx
13:23:59 <pastorn> Saizan: i like you =)
13:24:24 <kpreid> crazy_coder: you should write repeatx 4 ch = [ch, putEarlier ch (reverse roman)]
13:24:48 <crazy_coder> But I want a string
13:25:01 <monochrom> > ['c', 'd']
13:25:03 <kpreid> that *is* a string
13:25:04 <crazy_coder> so whats wrong if I do  'Y' :'Z' ?
13:25:05 <lambdabot>  "cd"
13:25:13 <kpreid> crazy_coder: the right side of : is a list
13:25:19 <kpreid> 'Z' is a Char, not a list
13:25:25 <monochrom> the right side needs to be a string.
13:25:27 <crazy_coder> Oh Ok
13:25:33 <monochrom> 'c' : "h"
13:25:56 <crazy_coder> Thanks. I could have never solved this problem on myself
13:26:02 <crazy_coder> Thanks guys
13:26:18 <LoganCapaldo> 'Y' : 'Z' -- dotted pair? <g>
13:26:19 <monochrom> <monochrom> Note that "1" and "[1]" are different. <monochrom> The difference is underappreciated by beginners coming from other programming cultures. Many quirky languages deliberately identifies 1 with [1].
13:26:19 <crazy_coder> The error message sometimes doesn't help much
13:26:23 <monochrom> Remember that.
13:26:38 <kpreid> crazy_coder: your program *might* actually look cleaner if you use Strings everywhere and never Char
13:26:47 <kpreid> i.e. roman :: [(String, Int)]
13:26:52 <crazy_coder> Ok Sure :)
13:27:04 <monochrom> Actually to me "[Char] against Char" is pretty clear.
13:27:26 <LoganCapaldo> monochrom: which quirky languages were you thinking of?
13:27:36 <monochrom> Matlab. Most shells.
13:28:11 <LoganCapaldo> ah
13:28:34 <LoganCapaldo> well if [1] is a matrix or vector in matlab that kinda makes sense. I dunno
13:28:56 <DRMacIver> Identifying scalars and 1 * 1 matrices is Wrong.
13:29:30 <LoganCapaldo> DRMacIver: Wrong because its just Wrong, or are there Good Reasons I am unaware of?
13:29:44 <wolverian> matlab is very fucked up in numerous ways.
13:29:51 <monochrom> Also 1 vs [1] is a different story from 'c' vs "c" for most languages. If you look for those identifying 1 and [1] you can find a few. If you look for those identifying 'c' and "c" you can find a lot more.
13:29:51 * LoganCapaldo is too out of his depth to advocate either way
13:30:17 <DRMacIver> LoganCapaldo: Multiplying n * n matrices by 1 * 1 matrices is not valid for n != 1. It's always valid to multiply them by scalars.
13:30:30 <LoganCapaldo> DRMacIver: aha
13:30:32 <shachaf> monochrom: Do you mean in the syntax?
13:30:34 <LoganCapaldo> that makes sense
13:30:39 <DRMacIver> I seem to recall there being a bunch of other little inconsistencies but I don't remember what. :)
13:30:45 <monochrom> In both syntax and semantics.
13:30:54 <shachaf> monochrom: For example, in Ruby, 'a' == "a" and ?a == "a"[0]
13:31:16 <ptolomy> ruby char vs string is interesting.
13:31:30 <LoganCapaldo> ruby has no chars. It's not really interesting at all
13:31:41 <cjeris> monochrom: and then there's J, in which the array 3 can have as many dimensions as you want: 1$3, 1 1$3, 1 1 1 1$3 for one, two or four dimensions respectively
13:31:58 <monochrom> Haskell is not quirky. My advice is don't bring quirky habits to Haskell, or else you would be very disappointed.
13:31:59 <MyCatVerbs> shachaf: I thought single and double quoting only differed in how they handled variable expansions and escaping?
13:32:10 <MyCatVerbs> shachaf: or did Ruby not inherit that from Perl?
13:32:12 <ptolomy> I'd be happier if ruby string []() didn't return a fixnum.
13:32:16 <LoganCapaldo> MyCatVerbs: that was his point
13:32:18 <mauke> perl: ( ( ( 3 )[0] )[0] )[0]
13:32:18 <ptolomy> but a string of length 1.
13:32:48 <kpreid> mauke: well, yes, but the () are list constructors (well, contextifiers) there :-)
13:33:04 * LoganCapaldo runs away from the perl
13:33:09 <mauke> the () are part of the ( )[ ] operator
13:33:15 <kpreid> I'd say Perl 'lists' (which are not Perl arrays, which are normalish) are flat.
13:33:32 <Excedrin> Haskell has a few quirks
13:33:36 <mauke> perl arrays also are flat :-)
13:34:04 <LoganCapaldo> Excedrin: example?
13:34:10 <fasta> When I add #define FOOBAR in a module, what's the scope of that FOOBAR?
13:34:24 <Excedrin> LoganCapaldo: unary negation syntax
13:34:30 <LoganCapaldo> uck yeah
13:34:35 <LoganCapaldo> that's pretty quirky
13:34:53 <fasta> AFAIK, it's just the include files I might use afterwards, right?
13:35:08 <MyCatVerbs> LoganCapaldo: ook.
13:35:37 <fasta> To create a larger scope I would have to add it to the global command line.
13:35:58 * fasta looks at mauke 
13:36:09 <Excedrin> stuff related to estimating performance of lazy code is sort of hard to understand, but maybe not quirky
13:36:32 <mauke> fasta: what, in C?
13:36:37 <fasta> Excedrin: I don't think it's hard to understand when properly explained.
13:36:50 <monochrom> Lazy evaluation is not quirky. Just unfamiliar.
13:37:05 <fasta> mauke: I am using cpphs, which should be compatible with GNU cpp
13:37:10 <DRMacIver> monochrom: Haskell is most definitely quirky. :)
13:37:33 <pastorn> is there any way to implement rounding with div?
13:37:33 <mauke> the "scope" of a preprocessor macro is the preprocessor run it appears in
13:37:43 <Excedrin> fasta: is there a good explanation somewhere?
13:37:50 <monochrom> People confuses "unfamiliar" with "difficult", "confusing", "tricky".
13:37:55 <crackers> try wikipedia
13:38:09 <fasta> Excedrin: I do not recommend wikipedia.
13:38:13 <DRMacIver> monochrom: So, tell me what (-1) means again. :)
13:38:20 <rjmccall> pastorn: what sort of rounding?
13:38:26 <sjanssen> Haskell has at least one quirk: monomorphism restriction
13:38:35 <sjanssen> oh, unary minus is another one
13:38:39 <fasta> Excedrin: I think SPJ's book contains a nice description.
13:38:42 <sjanssen> (n+k) is pretty funky
13:38:45 <fasta> Excedrin: but I don't know that.
13:38:51 <pastorn> rjmccall: nevermind...
13:38:52 <fasta> Excedrin: since I didn't complete it myself.
13:38:52 <DRMacIver> > [1.0, 1.3, .., 10.0]
13:38:53 <lambdabot>  Parse error
13:38:53 <sjanssen> am I missing anything?
13:39:00 <DRMacIver> > [1.0, 1.3, .. 10.0]
13:39:00 <lambdabot>  Parse error
13:39:09 <fasta> Excedrin: I suggest you ask someone else.
13:39:13 * DRMacIver can never get those right
13:39:19 <fasta> Excedrin: and when you know the answer, tell me. :)
13:39:29 <Saizan> > [1.0, 1.3 .. 10.0]
13:39:30 <lambdabot>  [1.0,1.3,1.6,1.9000000000000001,2.2,2.5,2.8,3.0999999999999996,3.39999999999...
13:39:58 <DRMacIver> > [1.0, 3 .. 10]
13:40:00 <lambdabot>  [1.0,3.0,5.0,7.0,9.0,11.0]
13:40:10 <fasta> Hmm, I want a monad TestT
13:40:22 <fasta> And a pony!
13:40:39 <fasta> That should get rid of my cpp macros, which did their job well, though.
13:40:45 <DRMacIver> monochrom: Haskell is sane by default, and is far from the most quirky among languages, but it's definitely quirky. :)
13:40:47 <LoganCapaldo> Wouldn't you want a monad Test and a monad transformer TestT? :)
13:40:54 <LoganCapaldo> And a pony!
13:40:58 <rjmccall> Does anyone here know whether GHC's System.Mem.StableName.makeStableName is safe to put in an unsafePerformIO?
13:41:05 <DRMacIver> LoganCapaldo: And a PonyT?
13:41:09 <fasta> LoganCapaldo: yes, that too.
13:41:11 <monochrom> I will write lessons on time and space of lazy evaluation.
13:41:17 <Excedrin> monochrom: I should revise my statement, it's not just lazy eval, it's lazy eval combined with ghc optimizations, garbage collection, etc... it seems like there's very few people who are familar with that stuff
13:41:37 <fasta> monochrom: can you add more complex examples than the ones currently descibed?
13:41:55 <monochrom> I will try. It's still vapourware.
13:42:11 <fasta> monochrom: i.e. don't end with with "this is how lazy evaluation with lists work".
13:42:26 <fasta> works*
13:42:53 <fasta> Excedrin: optimizations only change constant factors.
13:43:02 <fasta> Excedrin: At least, that is a rule of thumb.
13:43:28 <DRMacIver> Albeit sometimes really large constant factors. :)
13:43:35 <sjanssen> fasta: not true
13:43:47 <fasta> sjanssen: heh, that's funny.
13:44:07 <DRMacIver> sjanssen: Do you have an example?
13:44:10 <sjanssen> foldl (+) 0 uses O(n) memory without optimizations, and O(1) with ghc -O
13:44:28 <DRMacIver> Ah. Good example. :)
13:44:29 <fasta> sjanssen: I argued in here, that I wanted to have those optimizations that did that, but everyone was against me.
13:44:55 <fasta> sjanssen: and now it is reality. How nice.
13:45:50 <sjanssen> fasta: I'm not opposed to the compiler improving code in that way, but I don't think you should rely on it
13:46:04 <fasta> sjanssen: I agree with you on that.
13:48:10 <sjanssen> fasta: I can't think of any cases where ghc changes the O time complexity of a program
13:48:21 <sjanssen> just space
13:48:43 <Excedrin> unless you use rewrite rules
13:48:46 <sjanssen> right
13:48:52 <Excedrin> but I guess that's not really "ghc"
13:49:11 <sjanssen> rewrite rules that change the order of a program are a bit sketchy
13:49:12 <LoganCapaldo> mmm
13:49:22 <LoganCapaldo> magical optimizers changing time complexity
13:49:31 <LoganCapaldo> that would be _sweeet_
13:50:18 <fasta> Is there a standard Haskell AST?
13:50:24 <sjanssen> oh, I suppose let floating can change time complexity
13:50:34 <DRMacIver> let floating?
13:50:37 <sjanssen> fasta: there's Language.Haskell
13:50:52 <LoganCapaldo> is Language.Haskell standard?
13:51:14 <fasta> I like the idea of a program transformation frame work disjoined from GHC.
13:51:20 <sjanssen> DRMacIver: transforming '\x -> let foo = ... in ..' to 'let foo = ... in \x -> ...'
13:51:33 <sjanssen> LoganCapaldo: not really
13:51:47 <LoganCapaldo> ah well
13:51:56 <oerjan> it is not clear that haskell _has_ a standard parsing.
13:52:30 <LoganCapaldo> touch
13:53:44 <oerjan> the interaction of layout (with parse error rules) and precedence (with fixity declarations) is rather vague.
13:54:01 * LoganCapaldo wonders what the ups / downs would be if the report defined a standardized AST
13:54:11 <sorear> sjanssen: GHC already does let-floating, which can change order
13:54:19 <sjanssen> sorear: right
13:54:27 <sjanssen> that's why I brought it up ;)
13:55:01 <LoganCapaldo> Doesn't order not matter anyway though? isn't that one of the benefits of pure FP
13:56:07 <fasta> LoganCapaldo: OTOH, it's not that important, since a suitable representation will be the defacto standard anyway.
13:57:46 <sjanssen> LoganCapaldo: not order as in sequence, but order as in O
13:58:03 <LoganCapaldo> oh lol
13:58:06 <LoganCapaldo> I'm silly
13:58:23 <LoganCapaldo> can it ever negatively impact O?
13:59:45 <DRMacIver> sjanssen: Ah
14:04:43 <rjmccall> LoganCapaldo:  not in runtime, I think.  In space, yes, CSE can add significant penalties.
14:05:13 <sjanssen> http://paste.lisp.org/display/43639
14:05:49 <sjanssen> an example of changing O(n^2) to O(n) ^^^
14:06:00 <LoganCapaldo> magic!
14:06:36 <sjanssen> will C compilers do that?
14:06:40 <sjanssen> hmm, I should try it
14:07:13 <LoganCapaldo> so it floats out the let z = ... so it only needs computer that some once instead of n times
14:07:35 <LoganCapaldo> woah
14:07:40 <LoganCapaldo> that was bizzare
14:07:46 <LoganCapaldo> s/computer/compute/
14:07:50 <LoganCapaldo> s/some/sum/
14:08:08 <LoganCapaldo> How did I ever decide to use some instead of sum?
14:08:13 <LoganCapaldo> I need to get outta here
14:08:42 <rjmccall> Case in point:  foo n = product [1..n] `div` sum [1..n]
14:09:29 <oerjan> does it _not_ float out the sum [1..x] if you use it directly rather than with a let?
14:09:42 <rjmccall> With the magic optimizations and CSE, this goes from constant space to linear space.
14:09:49 <oerjan> (i.e. dropping the name z)
14:11:34 <rjmccall> Well, GHC might not actually apply CSE in my example, but in principle....
14:12:51 <sorear> oerjan: GHC doesn't CSE
14:13:47 <fasta> It only does Common Variable Elimination (better known as sharing), I guess.
14:13:59 <emu> common subexpr elim?
14:14:03 <emu> doesn't do?
14:14:15 <sorear> rjmccall: and foo n = 2 * product [ 1 .. n - 2 ]   btw :)
14:14:17 <fasta> emu: no, because it's not always a good thing
14:14:45 <emu> well, partially at least
14:15:18 <oerjan> ooh, my illusions shattered :/
14:15:18 <rjmccall> sorear:  Heh. :)
14:23:36 <roconnor> @seen ski
14:23:36 <lambdabot> ski is in #oasis, #haskell-blah, #haskell-overflow and #haskell. I last heard ski speak 3h 12m 14s ago.
14:23:55 <ski> @seen roconnor
14:23:55 <lambdabot> roconnor is in #haskell. I last heard roconnor speak 19s ago.
14:24:05 <LoganCapaldo> > foldr (+) 0 . unfoldr (\x -> let s | x < 10 = Just (x, x + 1) | True = Nothing in s) 0
14:24:07 <lambdabot>  Couldn't match expected type `a -> [a1]'
14:24:20 <LoganCapaldo> > foldr (+) 0 $ unfoldr (\x -> let s | x < 10 = Just (x, x + 1) | True = Nothing in s) 0
14:24:23 <lambdabot>  45
14:24:26 <roconnor> I thought up a few examples of non-extentional function created by the intensional axiom of choice.
14:24:32 <Syzygy-> :t unfoldr
14:24:35 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
14:24:36 <mauke> :t uncurry snd
14:24:39 <roconnor> My faviourite is as follows
14:24:39 <lambdabot> forall a b c. ((a, b -> c), b) -> c
14:24:47 <mauke> :t curry snd
14:24:50 <lambdabot> forall a b. a -> b -> b
14:25:10 <LoganCapaldo> Will that be transformed by GHC's optimizer to constant space?
14:25:11 <roconnor> forall a:R, exists z:Z, | a - z | <= 1
14:25:22 <roconnor> by the intensional axiom of choice
14:25:26 <roconnor> it follows
14:25:48 <roconnor> exists f:R -> Z, forall a:R, | a - f a | <= 1
14:26:11 <roconnor> such a function f does exist on the reals
14:26:27 <roconnor> but it doesn't respect the eqivalence relation of the reals
14:27:06 <roconnor> because all constructable function from R -> Z that are extensional are continuous, and this case, constant.
14:30:07 <yakov> hi
14:30:15 <oerjan> :t flip const
14:30:18 <lambdabot> forall a b. b -> a -> a
14:30:32 <rjmccall> LoganCapaldo:  I think so.
14:30:42 <oerjan> @check curry snd == flip const
14:30:44 <lambdabot>   add an instance declaration for (Eq (b -> a -> a))     In the expression: (...
14:31:39 <LoganCapaldo> @check (\a b -> curry snd a b == flip const a b) :: Integer -> Integer -> Bool
14:31:40 <lambdabot>  OK, passed 500 tests.
14:31:46 <oerjan> thanks
14:31:47 <olsner> :t flip const
14:31:50 <lambdabot> forall a b. b -> a -> a
14:31:59 <olsner> :t flip id
14:32:03 <lambdabot> forall b c. b -> (b -> c) -> c
14:32:10 <mauke> :t flip flip
14:32:13 <lambdabot> forall a b c. b -> (a -> b -> c) -> a -> c
14:32:17 <LoganCapaldo> @scheck (\a b -> curry snd a b == flip const a b) :: Maybe Bool -> Maybe Bool -> Bool
14:32:19 <lambdabot>   Completed 9 test(s) without failure.
14:33:16 <ski> roconnor : sorry, got slightly busy .. reading
14:33:19 <oerjan> LoganCapaldo++
14:33:23 <LoganCapaldo> @check (\a b -> curry snd a b == flip const a b) :: (Eq a) => a -> a -> Bool -- does this work?
14:33:25 <lambdabot>  Add a type signature
14:33:31 <LoganCapaldo> guess not
14:34:28 <LoganCapaldo> @check (\a b -> curry snd a b == flip const a b) :: Maybe Bool -> Integer -> Bool -- don't have to be the same type I think
14:34:30 <lambdabot>  OK, passed 500 tests.
14:34:44 <sorear> Ordering and keep scheck
14:34:45 <LoganCapaldo> Ok it's proven
14:34:59 <LoganCapaldo> By exhausted
14:35:05 <LoganCapaldo> Because I'm exhausted :)
14:35:33 <ski> roconnor : hm, interesting (cauchy reals ?)
14:35:49 <LoganCapaldo> @scheck (\a b -> curry snd a b == flip const a b) :: Ordering -> Ordering -> Bool
14:35:51 <lambdabot>  add an instance declaration for (Serial Ordering)
14:35:51 <lambdabot>     In the expression:
14:35:51 <lambdabot>    ...
14:38:12 <roconnor> ski: Cauchy reals.
14:39:03 <pastorn> for use with dzen if anyone feels like it: http://allyourbase.se/code/?do=view&id=101
14:39:05 <lambdabot> Title: code dump
14:39:05 <rjmccall> Hmm.
14:39:19 <ski> specifically ? a stream of telescopic intervals ? a map from epsilon to interval with smaller length ?
14:39:43 <pastorn> a cpu load bar
14:40:01 <pastorn> prints usage again and again and again...
14:40:14 <LoganCapaldo> and again, and again
14:40:39 <oerjan> hopefully not so often as to affect it :)
14:40:40 <pastorn> sorta =)
14:40:49 <pastorn> hehe, anyway, for dzen
14:41:51 <LoganCapaldo> I don't even have a proc filesystem. woe is me.
14:41:53 <slowriot> Is it possible to import certain symbols as qualified and others not?
14:42:10 <LoganCapaldo> I think so
14:42:44 <slowriot> maybe I could import hiding and then import qualified
14:42:52 <sorear> yeah
14:42:57 <LoganCapaldo> import Foo hiding (q1, q2); import qualified Foo as F; F.q1; F.q2
14:43:07 <slowriot> okay, cool
14:43:19 <LoganCapaldo> </untested>
14:43:42 <pastorn> slowriot: debian ftw
14:43:48 <LoganCapaldo> I like haskell's module system.
14:44:22 <pastorn> http://gotmor.googlepages.com/dzen
14:44:23 <lambdabot> Title: gotmor - dzen
14:44:50 <slowriot> pastorn: what prompted you to say that? I'm a Linux newb.
14:46:21 <pastorn> slowriot: oh, sorry, that was for LoganCapaldo
14:46:28 <slowriot> pastorn: ah, okay
14:46:33 <pastorn> LoganCapaldo: debian ftw
14:46:37 <ski> (roconnor : ^)
14:48:26 <LoganCapaldo> pastorn: I don't even use dzen on this machine anyway so it's ok :) the laptop may get your code on it at some point
14:48:36 <LoganCapaldo> (and it does have a /proc filesystem)
14:48:53 <pastorn> hehe
14:54:17 <LoganCapaldo> > let tooth = "tooth"; hole = "hole"; teeth = tooth : holes; holes = hole : teeth in holes `zip` teeth
14:54:19 <lambdabot>  [("hole","tooth"),("tooth","hole"),("hole","tooth"),("tooth","hole"),("hole"...
14:55:08 <LoganCapaldo> look, a zipper!
15:06:23 <oerjan> and here i thought you were commenting on our dental hygiene
15:09:04 <oerjan> > let holes@(_:teeth) = cycle ["hole", "tooth"] in holes `zip` teeth
15:09:06 <lambdabot>  [("hole","tooth"),("tooth","hole"),("hole","tooth"),("tooth","hole"),("hole"...
15:17:37 <pflanze> Hello. (Newbie here) Wondering about naming conventions: suppose you have a function which takes e.g. "text/html" and "utf-8" and returns "text/html;charset=utf-8", meaning, foo contentType encoding= contentType ++ ";charset=" ++ encoding
15:17:42 <pflanze> How would you call foo?
15:18:31 <mauke> foo "text/html" "utf-8"
15:18:33 <pflanze> So that it explains itself when I use it as e.g.   (foo "text/html") somewhere in the coe.
15:18:34 <sorear> addCharset perhaps
15:18:46 <mauke> oh
15:18:51 <sorear> "text/html" `addCharset` "utf8"
15:19:18 <pflanze> basically it's  partofContentType_encoding_to_contentType
15:19:23 <ptolomy> http://code.google.com/p/hiccup/ <- Neat little toy project I'm 'bout to release, if anybody feels like giving it a once-over and suggesting last minute improvements.
15:19:24 <lambdabot> Title: hiccup - Google Code
15:19:52 <pflanze> sorear: I want it to be clear even if only one argument is given.
15:21:23 <ptolomy> (By my latest benchmark, it runs like 30% faster than the C program that inspired it)
15:21:26 <ptolomy> (hooray for ByteStrings)
15:21:27 <pflanze> maybe I'll just call it  buildContentType
15:25:57 <pflanze> ptolomy: impressive :) (for the tiny size)
15:27:41 <ptolomy> Thanks.
15:29:46 <pastorn> i don't understand the description... when do i want to use this application?
15:29:59 <Excedrin> ptolomy: I'd add the example program in the tar.gz
15:30:08 <ptolomy> Excedrin: Good call. I'll do.
15:30:09 <Cale> ptolomy: btw, do you have an Apple Cinema HD display or something? :) There are some pretty long lines there :)
15:30:39 <ptolomy> Yeah, my fonts are crazy small.. keep people from reading over my shoulder. :-P
15:30:56 <ptolomy> I probably should break some of those, though. One particular use of 'maybe' is quite bad..
15:31:06 <Cale> yeah, I'm looking at that :)
15:31:40 <ptolomy> To be fair, I've been sitting on it for a while, so I can wag a scornful finger at previous me with impunity.
15:34:11 <pastorn> @paste
15:34:12 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:34:20 <Pupeno2> Can I define a function in ghci?
15:34:31 <mauke> yes, let f x = ...
15:36:55 <dying_sphynx> hi all
15:37:27 <dying_sphynx> I wonder why there is no function for parsing Time from string..
15:38:03 <Saizan> ?go haskell parsetime
15:38:05 <lambdabot> http://www.haskell.org/ghc/dist/stable/docs/libraries/doc-index-P.html
15:38:14 <mauke> @index CInt
15:38:14 <lambdabot> Foreign.C.Types, Foreign.C
15:39:10 <dying_sphynx> Saizan,  ahh, ok. Thank you! I've searched in wrong place )
15:40:30 <Saizan> dying_sphynx: i just had "parsetime" in the back of my mind, so i asked google ^^
15:42:06 <dying_sphynx> it can be done in Data.Time.Format module..
15:47:17 <ptolomy> Does GHC use unboxed ints for enumeration values?
15:49:13 <SamB> ptolomy: huh?
15:49:27 <ptolomy> like True | False
15:49:50 <ptolomy> aack. gottago.
15:50:00 <SamB> no...
15:58:18 <LoganCapaldo> I think I saw on the performance wiki that to get unboxedness you use a newtype Int intead of an enumeratorion
15:58:46 <Alleria_> is hpaste down?
15:58:55 <sorear> Yes.
15:59:10 <LoganCapaldo> oh he left
15:59:16 <sorear> @get-shapr
15:59:16 <lambdabot> shapr!!
15:59:17 <LoganCapaldo> I was gonna link him
15:59:20 <LoganCapaldo> http://www.haskell.org/haskellwiki/Performance/Data_Types#Enumerations
15:59:23 <lambdabot> Title: Performance/Data types - HaskellWiki, http://tinyurl.com/2czp5c
16:00:46 <Alleria_> I'm getting a type error I don't understand -- where do I paste my 3-line function?
16:00:55 <Lemmih> ?paste
16:00:55 <lambdabot> Haskell pastebin: http://hpaste.org/new
16:01:05 <chessguy> 'evening
16:01:05 <Alleria_> Lemmih: down
16:01:16 <monochrom> 503 "service temp. unavailable"
16:01:27 <monochrom> I guess 3 lines is ok here.
16:01:27 <Lemmih> Hm, indeed.
16:01:39 <Alleria_> monochrom: thanks
16:01:50 <Alleria_> waysToDivide x = if x == 1
16:01:54 <Alleria_> then 1
16:01:55 <Alleria_> else
16:02:04 <Alleria_> foldr (+) 0 ( map ((*) (waysToDivide . fst) ( waysToDivide . snd )) [ (z, w) | z <- [1 .. ceiling(x/2)], w <- [x .. ceiling(x/2)], w+z == x ] )
16:02:19 <chessguy> @go haskell
16:02:22 <lambdabot> http://www.haskell.org/
16:02:22 <lambdabot> Title: Haskell - HaskellWiki
16:02:23 <Botje> blink
16:02:31 <mauke> foldr (+) 0 looks suspicious
16:02:32 <chessguy> weird. google isn't working for me
16:02:54 <chessguy> @src sum
16:02:54 <lambdabot> sum = foldl (+) 0
16:02:56 <Alleria_> I'm getting a " No instance for (Num ((t, t) -> a))"
16:03:06 <mauke> Alleria_: that's because you're trying to multiply two functions
16:03:34 <LoganCapaldo> mmm delicious function multiplication
16:03:39 <Alleria_> mauke -- I was trying to figure out how to get the first element of the two-tuple out, pass it to waysToDivide?
16:03:39 <mauke> map (\(a, b) -> waysToDivide a * waysToDivide b)
16:03:57 <mauke> @pl (\(a, b) -> waysToDivide a * waysToDivide b)
16:03:57 <lambdabot> uncurry ((. waysToDivide) . (*) . waysToDivide)
16:04:19 <LoganCapaldo> clever use of uncurry, Ms. Lambdabot
16:04:23 <LoganCapaldo> @botsnack
16:04:24 <lambdabot> :)
16:04:33 <monochrom> I recommend what mauke says for now.
16:04:34 <Botje> Alleria_: you could do the multiplication inside the list comprehension.
16:04:45 <mauke> true
16:04:51 <monochrom> Oh! That is even better. :)
16:04:55 <mauke> @pl (\waysToDivide (a, b) -> waysToDivide a * waysToDivide b)
16:04:55 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (*)) .))
16:04:58 <Alleria_> Botje: that's probably the simplest way here, I guess?
16:05:02 <LoganCapaldo> yeah then theres no unecessary tupleage
16:05:04 <Botje> [ (waysToDivide x) * (waysToDivide z) | x <- ..., z <- ...
16:05:15 <Botje> and replace foldr (+) 0 with sum, of course
16:05:17 <mauke> you don't need the parens
16:05:24 <Alleria_> excellent. Thank you all :)
16:05:33 <monochrom> They are z and w, not z and x.
16:05:47 <Botje> good point
16:05:48 <Botje> it's late :p
16:05:50 <Cale> man, @pl sometimes doesn't get the obvious way
16:06:04 <LoganCapaldo> s/sometimes/often/
16:06:28 <Cale> uncurry (*) . join (&&&) waysToDivide
16:06:29 <Botje> I never got the hang of parenthetisation in haskell
16:06:30 <monochrom> I really want to impeach the choice of the ISP for hpaste.org.
16:06:42 <chessguy> Cale, @pl doesn't know anything about arrows
16:06:56 <Cale> hmm...
16:07:01 * Alleria_ is a Haskell newbie, and understands nothing of Monads, let alone Arrows, heh.
16:07:05 * sorear points monochrom at shapr
16:07:09 <Cale> @pl \(x,y) -> (f x, y)
16:07:09 <lambdabot> first f
16:07:12 <Cale> yes it does
16:07:20 <monochrom> I understand that shapr is also a victim.
16:07:23 <chessguy> oh, hmm
16:07:30 <Cale> @pl \(x,y) -> (f x, g y)
16:07:31 <lambdabot> f *** g
16:07:41 * chessguy stands corrected
16:07:43 <chessguy> as usual
16:07:49 <sorear> Cale: @pl is greedy
16:07:56 <Botje> @pl \(x,y) -> (f x, f y)
16:07:56 <lambdabot> f *** f
16:07:59 <Botje> yay
16:08:04 <monochrom> But this ISP is, like, 503 every month, and screws up payments every year.
16:08:14 <Cale> @pl \(x,y) f -> (f x, f y)
16:08:14 <lambdabot> uncurry ((. flip id) . ap . ((,) .) . flip id)
16:08:20 <Cale> @pl \f (x,y) -> (f x, f y)
16:08:20 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
16:08:21 <LoganCapaldo> @type join (***) ?f
16:08:22 <chessguy> @bot
16:08:24 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a, ?f::a b c) => a (b, b) (c, c)
16:08:24 <lambdabot> :)
16:08:37 <Botje> ((.).(,))
16:08:40 <Botje> what a cute signature.
16:09:11 <LoganCapaldo> cute? looks like its crying out of one eye.
16:10:52 <LoganCapaldo> Does anyone ever come in here and ask, "How do I do x++ in Haskell?"
16:11:41 <monochrom> No. I think they have read enough blogs before they come here.
16:12:28 <sorear> x--
16:12:30 <mauke> modify succ
16:13:01 * SamB wonders what pair of numbers between 0 and 2^17-1 produce the product with the most 1 bits
16:13:07 <chessguy__> lovely
16:13:12 <Botje> get >>= \x -> put (x+1) >> return x --  actually.
16:14:13 <monochrom> Instead, they do ask, "how to xs.append(x)", and we do reply, unsophisticatedly, "xs ++ [x]". But if you dig into the real question, you invariably see that there is a better lazy-list algorithm than relying on xs++[x].
16:14:44 * Cale likes turning concatenation into composition :)
16:15:43 <sorear> SamB: 2^16-1 * 2^16+1   should get you pretty close!  (multiplies to 2^32-1)
16:16:37 <mauke> > printf "%b" 1 :: String
16:16:39 <lambdabot>  Exception: Printf.printf: bad formatting char b
16:21:17 <Botje> "What happened to all the haskell posts?" "Too much curry. <burp>"
16:21:27 <Botje> (from http://programming.reddit.com/info/221oa/comments)
16:21:28 <LoganCapaldo> mmm curry
16:21:28 <lambdabot> Title: What happened to all the haskell posts? (reddit.com)
16:21:56 <LoganCapaldo> Is the real answer, "dons took a break"?
16:23:29 <Saizan> probably
16:27:09 <SamB> so... have there been any interesting research projects?
16:27:12 <Cale> I still have lots of Haskell articles on my "new" list.
16:27:25 <Cale> Then again, the bottom of my new page is #369.
16:44:30 <agocorona> I have undefined symbols when using load (hs-plugins) under ghc-6.6 windows version. Do you?
16:44:32 <Saizan> is ReadP much slower than Parsec?
16:44:54 <Saizan> agocorona: which version of hs-plugins? darcs?
16:45:04 <agocorona> yes
16:45:40 <Saizan> ah, ok
16:46:05 <agocorona> do you know something?
16:47:30 <nominolo> @hoogle unsafePerformIO
16:47:31 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
16:48:29 <Saizan> no, sorry, i was just going to suggest to get from the repo if you were using the tarball
16:48:31 <mm_freak> samb: 1 * 131071
16:48:55 <agocorona> ah, ok ;)
16:49:19 <mm_freak> or should the result be less than 2^17 - 1 ?
16:50:25 <agocorona> Im waiting for Dons. I told that to him and he dissapeared quicly after. I suppose that he is looking at it. that is two days ago at least
16:51:13 <sorear> dons is #3 on the active users list, maintainer and operator of lambdabot, and primary channel contact.  I doubt he'll be gone long
16:52:38 <SamB> yeah! what about lambdabot's weekly reboot?
16:53:04 <SamB> agocorona: windows version, you say?
16:53:09 <SamB> what symbols are they?
16:53:28 <agocorona> _memcmp
16:54:24 <SamB> oh?
16:54:27 <SamB> is that all?
16:55:02 <agocorona> but also _Free  in really dumb object files
16:55:17 <agocorona> some others sometimes
16:56:18 <SamB> does it happen to mention object files?
16:57:17 <agocorona> the error appears in the invocation of "load". load invokes the linker and suppossedly, the linker return this error
16:57:35 <SamB> ah.
16:57:37 <nominolo> @hoogle Foldable
16:57:40 <lambdabot> No matches found
16:57:54 <agocorona> "load" ins invoked to load my ".o" files
16:58:06 <SamB> I realize that ;-)
16:58:50 <agocorona> I wasted a lot ot time with that
17:01:17 <sorear> SamB: Lambdabot auto-respawns, which means I can reboot her too
17:01:26 <nominolo> @src ((->) r) mappend
17:01:26 <lambdabot> Source not found. Wrong!  You cheating scum!
17:01:42 <chessguy> @yarr
17:01:43 <lambdabot> This is the END for you, you gutter-crawling cur!
17:01:45 <sorear> ./#haskell.log:21:23 < sorear> @quit
17:01:45 <sorear> ./#haskell.log:2007.06.13.16.14.37 < sorear> @quit
17:01:45 <sorear> ./#haskell.log:2007.06.20.15.22.16 < sorear> @quit
17:01:45 <sorear> ./#haskell.log:2007.06.27.18.22.36 < sorear> @quit
17:02:07 <nominolo> @instances Monoid
17:02:09 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
17:02:18 <sorear> nominolo: It's a reader lift
17:02:21 <sorear> In 6.6
17:02:33 <SamB> sorear: but generally these weekly reboots also involve accepting new code to the repository...
17:02:36 <sorear> (f `mappend` g) x = f x `mappend` g x
17:02:41 <sorear> In 6.4
17:02:47 <SamB> or data, as the case may be
17:02:51 <sorear> (f `mappend` g) x = f (g x)
17:03:01 <SamB> sorear: did you see my fix for @vixen?
17:03:07 <sorear> SamB: Yup.
17:03:25 <nominolo> ah, that latter was what i was looking for.  thanks guys
17:03:26 <sorear> SamB: And 64bit is a widely recognized evil of D.B!
17:03:37 <sorear> nominolo: Don't!
17:03:59 <sorear> nominolo: in 6.6 it does something entirely different from 6.4.
17:04:00 <nominolo> thanxs retreated
17:04:06 <sorear> nominolo: *With the same type*
17:04:22 <sorear> Your program will SILENTLY BREAK on compiler upgrade 6.4 -> 6.6
17:04:53 <nominolo> oh
17:05:12 <nominolo> i never used 6.4
17:05:19 <nominolo> started with 6.5
17:05:22 <nominolo> :)
17:05:54 <sorear> @users
17:05:54 <lambdabot> Maximum users seen in #haskell: 354, currently: 305 (86.2%), active: 7 (2.3%)
17:08:54 <Alleria_> ceiling is causing type ambiguities, and I don't understand why.
17:09:25 <Alleria_> should I be coercing my Integrals into RealFracs?
17:17:49 <Saizan> ?type ceil
17:17:51 <lambdabot> Not in scope: `ceil'
17:18:47 <Saizan> Alleria_: you need to use fromIntegral to go from Integer/Int to any Num
17:19:19 <allbery_b> ?type ceiling
17:19:21 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
17:19:46 <Saizan> ?type fromIntegral . ceiling :: Double -> Double
17:19:47 <lambdabot> Double -> Double :: Double -> Double
17:22:22 <Alleria_> Saizan: thank you!
17:29:13 <nominolo> hm, how heavyweight is (unsafePerformIO $ readIORef r)?  Will it be optimized to a single read?
17:30:33 <lispy> nominolo: there is also an inlinePerformIO or somesuch
17:31:08 <nominolo> yes, but i read some scary things about code floating around and somesuch
17:31:13 <sorear> nominolo: you could try it...
17:31:39 <sorear> nominolo: it's safe in this case, because readMutVar# is atomic to the optimizer
17:32:09 <nominolo> sure.  was just wondering if someone already knew
17:32:11 <lispy> nominolo: ah, well i figured if you were already using unsafePerformIO that you were being caution and made sure it was safe :)
17:32:47 <nominolo> yes.  i'm experimenting with space-efficient persistent datastructures
17:35:07 <sjanssen> nominolo: are you sure you want to use IORef -- they're not very nice for multi-threading
17:35:57 <sjanssen> remember that in GHC 6.6 anything (including pure code!) can happen concurrently
17:36:28 <nominolo> i'm not sure abaut anything, ATM ;)  but atomic writes should be sufficient
17:36:47 <nominolo> since every modification will create a vew version
17:37:18 <nominolo> and a traversal knows the version it traverses
17:37:42 <nominolo> so there should be no problems with inconsistend structures
17:38:22 <Saizan> but you get a pure api out of this?
17:38:53 <nominolo> hopefully
17:39:54 <mauke> wait, isn't that what ST is for?
17:40:40 <lispy> yeah sounds like a job for ST to me
17:40:55 <lispy> then instead of unsafePerformIO you can just use runST
17:40:59 <lispy> ?hoogle runST
17:41:00 <lambdabot> Control.Monad.ST.runST :: ST s a -> a
17:41:00 <lambdabot> Data.Array.ST.runSTArray :: Ix i => ST s (STArray s i e) -> Array i e
17:41:00 <lambdabot> Data.Array.ST.runSTUArray :: Ix i => ST s (STUArray s i e) -> UArray i e
17:41:29 <nominolo> i have escaping refs, though
17:41:40 <nominolo> don't thinx that'll vwork
17:42:10 * nominolo 's dvorak typing is pretty buggy 
17:43:32 <sorear> Yup, it's a read
17:46:53 <chessguy> hm, anyone heard of R-trees? i just heard of them the other day. might be fun to implement in haskell
17:47:02 <dons> http://programming.reddit.com/info/2212q/details
17:47:02 <lambdabot> dons: You have 2 new messages. '/msg lambdabot @messages' to read them.
17:47:03 <lambdabot> Title: Representing DSL expressions in Haskell (reddit.com)
17:47:34 <chessguy> yes, nice blog
17:47:44 <chessguy> augustss++
17:47:52 <sorear> chessguy: yes
17:48:08 <sorear> chessguy: I forgot what they are, but I've definitely read about them
17:48:32 <sorear> chessguy: I think they're related to storing spatially indexed data, I know they have a WP entry
17:48:46 <chessguy> they are and they do and it sucks
17:49:40 * nominolo knows B-Trees
17:50:40 * desp knows kung-fu
17:51:05 <chessguy> doesn't seem to be much info out there about r-trees
17:54:27 <Korollary> augustss++
17:54:46 <desp> nominolo: you are using NOINLINE, right?
17:55:12 <nominolo> i guess
17:55:51 <desp> for the function that calls unsafePerformIO
17:56:44 <nominolo> yes, i probably will
17:57:25 <desp> the GHC docs say that's a good idea
17:57:51 <sorear> not necessarily
17:58:11 <sorear> unsafePerformIO can and should be in an inlined function if used correctly.
17:58:29 <chessguy> mmmmm, looks hard to implement
17:58:35 <sorear> but some people insist on doing dumb things like using it to make global variables
17:58:50 <SamB> hmm.
17:58:52 <sorear> which completely violates the specified preconditions
17:59:18 <sorear> so you have to bludgeon the optimizer into not taking advantage of the documented precondtions you are breaking
18:02:20 <nominolo> heh.  i'm gonna do that, too :)
18:02:20 * nominolo <-- evil
18:02:50 <Lemmih> nominolo: Don't feel too bad. GHC itself is riddled with such hacks.
18:03:12 <nominolo> @localtime nominolo
18:03:12 <nominolo> lambdabot: ping
18:03:24 <SamB> sorear: oh?
18:04:36 <SamB> sorear: I believe you will be wrong in the future
18:04:55 <SamB> look at the patch that fixes ticket #986
18:05:05 <sorear> SamB: Very true.  I'm not perfect, and I do say false things from time to time.
18:05:22 <dons> ?users
18:05:22 <lambdabot> Maximum users seen in #haskell: 354, currently: 296 (83.6%), active: 13 (4.4%)
18:05:29 <SamB> sorear: I mean, what you're saying about unsafePerformIO is being changed
18:06:06 <sorear> SamB: You mean someone is going to add a guarantee that it is executed exactly once?
18:06:11 <sorear> that someone is an idiot
18:06:15 <SamB> sorear: not really
18:06:35 <SamB> needed to fix unsafeInterleaveIO so that getContents is threadsafe
18:07:15 <sorear> > "unsafePerformIO" == "unsafeInterleaveIO"
18:07:17 <lambdabot>  False
18:07:27 <SamB> sorear: they did the same thing to unsafePerformIO
18:07:32 <SamB> http://hackage.haskell.org/trac/ghc/ticket/986
18:07:34 <lambdabot> Title: #986 (SMP race condition in getContents) - GHC - Trac
18:07:54 <sorear> SamB: Also, this was a bug wrt the spec.
18:08:08 <sorear> SamB: The spec says uPIO is executed an integer number of times
18:08:18 <SamB> um.
18:08:20 <sorear> SamB: GHC had been doing it 1.5 times on occasion
18:08:24 <SamB> oh, that.
18:08:26 <SamB> true.
18:11:32 <SamB> sorear: anyway, clearly with unsafeInterleaveIO you *need* it to not run the IO action multiple times...
18:12:08 <SamB> I knew this bug was going to happen when I learned about lazy blackholing
18:12:48 <sorear> SamB: That could be handled eg with MVars, or eager blackholing.  Both more expensive than having the codgen invent a 0-word unboxed object
18:14:02 <jre2> does anyone know the reasoning why there aren't any (sucessful) haskell on .NET compilers?
18:14:10 <SamB> sorear: mvars?
18:14:40 <SamB> oh, why are you suggesting these things if they are bad ideas anyway?
18:14:45 <sorear> jre2: I'm told .NET's allocator sucks too much
18:15:14 * LoganCapaldo wonders why you'd want Haskell on .NET
18:15:27 <LoganCapaldo> GHC already works on windows don't it?
18:15:41 <jre2> moreso just curiosity
18:16:24 <jre2> since there's a decent MSR faction and all
18:17:50 <sorear> The x86 has 7 general purpose registers.  GHC reserves 2 of them *permanently* for allocation bookkeeping.  Haskell needs it.
18:18:05 <sorear> the CLI allocater is much much slower
18:18:17 <emu> what does F# use
18:18:29 <sorear> the CLI allocator I think :)
18:18:31 <emu> functional programming tends to generate a lot of short-lived objects
18:18:35 <sorear> making it slower
18:18:36 <LoganCapaldo> F# isn;t allocating thunks all the time though, is it?
18:18:42 <sorear> yeah.
18:18:53 <emu> no generational collector?
18:19:48 <int80_h> fst (snd [(5,'b'),(1,'c'),(6,'a')])
18:19:57 <int80_h> what's wrong with my syntax?
18:20:19 <emu> snd doesn't apply to lists
18:20:22 <Binkley> int80_h: what is snd's type, and what is the type of the argument you're applying it to?
18:21:04 <int80_h> how do I get ghci to express the type of a function?
18:21:12 <LoganCapaldo> :t function
18:21:12 <Binkley> int80_h: :t <whatever>
18:21:15 <lambdabot> Not in scope: `function'
18:21:16 <mauke> :t snd
18:21:19 <lambdabot> forall a b. (a, b) -> b
18:21:48 <LoganCapaldo> or yeah you can ask lambdabot :)
18:21:52 <LoganCapaldo> @botsnack
18:21:52 <lambdabot> :)
18:21:53 <int80_h> I see
18:22:11 <jre2> also, not of curiosity but rather in the interests of me escaping hell at work, anyone know of a "perl" backend for haskell? ;)
18:22:39 <LoganCapaldo> theres a 'perl' frontend for Haskell :)
18:23:48 <jre2> LoganCapaldo: yea, I jumped when I first saw it..and then I learned it was the other way around from what I wanted
18:26:41 <Cale> jre2: You can call C code from perl, so you could FFI export Haskell code and call it from perl.
18:27:20 <jre2> Cale: the scary thing is I'll give thought to that
18:28:06 <jre2> because while writting functions for folding,currying,etc is helping, it doesn't stand close to pattern matching
18:28:22 <jre2> also, my current job is mostly parsing
18:28:48 <jre2> and parsec sounds sooo much better than a huge conglomerate of regexes...
18:28:57 <Korollary> Perl has parser generators
18:29:31 <jre2> perl also has nearly zero typing
18:30:32 <LoganCapaldo> Parsec is tasty, I must say
18:33:53 <jre2> hmm, chessguy just left the #ai room as well, maybe I should have asked more questions earlier
18:35:52 <Cale> Also, if you could get away with using perl 6, it is rather closely integrated with Haskell.
18:36:42 <emu> perskell
18:36:52 <jre2> 5.8 is the highest we support right now
18:38:47 <LoganCapaldo> can pugs do old-fashioned perl?
18:39:13 <Cale> Yes, I think so.
18:39:40 <Cale> (of course, not directly, it needs access to a proper perl 5 installation)
18:40:19 <LoganCapaldo> So just slowly transistion from 5 to 6 to 7^HHaskell
18:40:33 <Cale> yeah
18:40:52 <LoganCapaldo> bwahahahaha
18:40:54 <jre2> I need to find more people in our company that would be willing to work in haskell
18:41:05 <LoganCapaldo> that's why it's slow
18:41:13 <jre2> then I can start petitioning
18:41:25 <LoganCapaldo> one day they wake up and realize they've been programming in Haskell for the past month
18:41:28 <LoganCapaldo> :)
18:41:37 <jre2> hah
18:42:32 <jre2> anyone know if MS proper has any haskell projects?
18:42:44 <dons> they fund ghc development.
18:42:53 * jre2 is taking ideas for places to intern next year
18:42:53 <Cale> As opposed to MS research?
18:42:54 <SamB> dons: I think that's called MS Research
18:42:55 <dons> well,MSR..
18:42:58 <jre2> not MSR
18:43:02 <SamB> dons: oh, did you see that I fixed vixen?
18:43:10 <dons> SamB: i did.good work.
18:43:15 <jre2> I don't think I'm cool enough to work at MSR sadly
18:43:20 <Cale> What's down with hpaste?
18:43:30 <SamB> it was easy as soon as I found out that the problem had nothing to do with regexes...
18:43:42 <Binkley> jre2: There's the Linq project, which is sort of FP-ish
18:43:44 <Binkley> it's not Haskell per se
18:43:45 <SamB> well actually at that point I was done
18:44:14 <Cale> It sort of annoys me how much the Linq guys play down the practicality of Haskell.
18:44:22 <jre2> Binkley: I think I recall some MS dev giving a talk about that recently, perhaps I should have paid more attention
18:44:37 <Binkley> jre2: it seemed like cool stuff, and they might have internships
18:44:52 <LoganCapaldo> Cale: well aren;t they coming at it from the angle of Joe VB Programmer?
18:44:53 <Binkley> jre2: start applying early, though, MS proper is slow about such things
18:44:57 <jre2> I think I saw it applied to .net's database and webdev
18:44:57 <SamB> Cale: I liked that paper which went approximately [Haskell..VB]
18:45:28 <Cale> LoganCapaldo: Well, to some extent at least.
18:45:41 <dons> i don't understand why this post is getting so many down mods, http://programming.reddit.com/info/2212q/details, its a very nice article. any ideas?
18:45:42 <lambdabot> Title: Representing DSL expressions in Haskell (reddit.com)
18:45:57 <SamB> dons: no!
18:46:04 <SamB> maybe you need to post more Haskell things
18:46:06 <lispy> dons: because it's reddit?
18:46:10 <SamB> so that people will be spread thinner
18:46:13 <Cale> dons: I upmodded it.
18:46:23 <jre2> Binkley: uiuc is one of MS's favourites recruitment wise, so I can get a standard internship at MS proper I believe, it's just a question of would it be interesting enough
18:46:24 <Cale> Everyone go and upvote that right now :)
18:46:26 <SamB> I, too, upmodded it
18:46:27 <Excedrin> it's not related to programming
18:46:34 <Excedrin> so obv downmod
18:46:38 <SamB> what?
18:46:41 <Cale> Excedrin: uh, what?
18:46:46 <SamB> that was definately programming
18:46:55 <Cale> Excedrin: perhaps you're looking at a different article?
18:46:56 <dons> Excedrin: implementing a DSL? with GADTs. -- its about implementing a programming language ... with programming.
18:46:59 <LoganCapaldo> I'm sorry I have to read it
18:47:07 <LoganCapaldo> then I'll upvote it :)
18:47:18 <dons> there is a lot of non-programming stuff on the site atm though
18:47:19 <SamB> maybe we should avoid jargon like "DSL" in titles?
18:47:21 <LoganCapaldo> I can't up/down vote things sight unseen
18:47:22 <dons> stupid tech stories
18:47:30 <Excedrin> I didn't read it
18:47:46 <jre2> SamB: do you think spelling it out would help?
18:47:50 <Cale> Heh, I spend about 30ms deciding whether to downvote most things or not.
18:47:59 <dons> too long, Cale!
18:48:09 <Cale> It's really easy when most articles have telling words like "Agile" in the title.
18:48:12 * jre2 finally registers
18:48:23 <Excedrin> it's ok, I upvote everything that has "Agile" in the title
18:48:25 <SamB> jre2: it would make it clear that it isn't talking about your internet connection, at least
18:49:08 <dons> yes, titles like 'writing an x86 compiler in haskell' get attention
18:49:21 <dons> so something like 'write a domain specific language in haskell' -- for dumbies.
18:49:29 <jre2> there you go
18:49:51 <jre2> anyone here use yi regularly?
18:50:12 <dons> i used to
18:51:09 <jre2> dons: 1) why did you stop? 2) are you of vim or emacs mentality?
18:51:23 <SamB> he's vim
18:51:31 <SamB> he didn't know anything about the emacs lexer!
18:51:57 <dons> jre2: i never got around to finishing syntax highlighting, so i went back to vim, and got caught up in work
18:52:11 <jre2> ah
18:52:17 <dons> now the console backend to yi is a bit second class, and i don't have time to improvie it
18:53:28 <SamB> dons: do you know anything about the missing symbols that someone was talking about with hs-plugins on windows?
18:54:06 <jre2> dons: busy with phd thesis or something else?
18:56:23 <LoganCapaldo> read and upvoted
18:56:28 <LoganCapaldo> good article
18:56:37 <jre2> chessguy: does the #ai room ever say anything?
18:56:48 <LoganCapaldo> explained the GADT interpreter thing clearly enough so I finally got it
18:56:51 <chessguy> sure
18:57:14 <SamB> for all that it's still at one!
18:58:05 <chessguy> @hoogle (!)
18:58:06 <lambdabot> Did you mean: (!)
18:58:06 <lambdabot> Prelude.undefined :: a
18:58:06 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
18:58:18 <mauke> @hoogle !
18:58:19 <lambdabot> Array.(!) :: Ix a => Array a b -> a -> b
18:58:19 <lambdabot> Prelude.! :: keyword
18:58:19 <lambdabot> Data.Array.(!) :: Ix i => Array i e -> i -> e
19:00:29 <chessguy> @instances-importing Ix
19:00:34 <lambdabot> Couldn't find class `Ix'. Try @instances-importing
19:00:46 <chessguy> brilliant suggestion
19:00:52 <chessguy> @instances-importing Data.Ix
19:00:52 <lambdabot> Couldn't find class `Data.Ix'. Try @instances-importing
19:01:12 <chessguy> @source Data.Array
19:01:12 <lambdabot> http://darcs.haskell.org/packages/base/Data/Array.hs
19:01:25 <mauke> @instances-importing Data.Ix Ix
19:01:26 <lambdabot> (), (a, b), (a1, a2, a3), (a1, a2, a3, a4), Bool, Char, Int, Integer, Ordering
19:01:34 <chessguy> nice
19:13:29 <xpika> i cant generate the haddock for the GHC API because the .hs files have macros in it
19:15:05 <dons> http://programming.reddit.com/info/022425/comments :-)
19:15:06 <lambdabot> Title: Collected Haskell blog articles: from monads to XML to robots (reddit.com)
19:24:00 <xpika> is there anyway i can de-macro the GHC source code so that i can extract the haddock?
19:27:12 <chessguy> @src elem
19:27:13 <lambdabot> elem x    =  any (== x)
19:28:19 <LoganCapaldo> @src elemIndex
19:28:20 <lambdabot> elemIndex x     = findIndex (x==)
19:28:32 <LoganCapaldo> @src findIndex
19:28:33 <lambdabot> findIndex p     = listToMaybe . findIndices p
19:28:48 <LoganCapaldo> @src findIndices
19:28:48 <lambdabot> findIndices p xs = [ i | (x,i) <- zip xs [0..], p x]
19:29:17 <LoganCapaldo> list comprehension. a bit surprising
19:30:25 <LoganCapaldo> @type \p xs -> map fst $ filter (p . snd) $ zip [0..] xs
19:30:25 <chessguy> > ['1'..'9'
19:30:25 <lambdabot>  Parse error
19:30:28 <chessguy> > ['1'..'9']
19:30:28 <lambdabot> forall a b. (Num a, Enum a) => (b -> Bool) -> [b] -> [a]
19:30:30 <lambdabot>  "123456789"
19:31:26 <LoganCapaldo> @type findIndices
19:31:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
19:32:34 <LoganCapaldo> > ['a'..'z']
19:32:37 <lambdabot>  "abcdefghijklmnopqrstuvwxyz"
19:34:50 <chessguy> @hoogle isUpper
19:34:51 <lambdabot> Char.isUpper :: Char -> Bool
19:36:03 <LoganCapaldo> > isUpper 'Z'
19:36:06 <lambdabot>  True
19:36:11 <chessguy> @type \type -> type
19:36:14 <lambdabot> parse error on input `type'
19:36:19 <chessguy> boo!
19:36:29 <chessguy> @type \x -> x
19:36:32 <lambdabot> forall t. t -> t
19:36:34 <jre2> I think we need more haskell blogs with videos: http://sigfpe.blogspot.com/2007/05/haskell-incarnate.html
19:36:35 <lambdabot> Title: A Neighborhood of Infinity: Haskell Incarnate
19:37:44 <dons> i agree.
19:41:05 <chessguy> @hoogle Char -> Int
19:41:06 <lambdabot> Char.digitToInt :: Char -> Int
19:41:06 <lambdabot> Char.ord :: Char -> Int
19:41:18 <chessguy> > digitToInt '2'
19:41:20 <lambdabot>  2
19:43:25 <chessguy> @pl a p l b = b // [(l,p)]
19:43:25 <lambdabot> a = (flip (//) .) . flip flip [] . ((:) .) . flip (,)
19:43:28 <chessguy> woohoo
19:43:42 * chessguy <3 pl
19:46:19 <Cale> @pl a b l p = b // [(l,p)]
19:46:19 <lambdabot> a = (. flip (flip . ((:) .) . (,)) []) . (.) . (//)
19:46:33 <Cale> @pl a l p b = b // [(l,p)]
19:46:33 <lambdabot> a = (flip (//) .) . flip flip [] . ((:) .) . (,)
20:19:09 <LoganCapaldo> :k ST
20:19:15 <LoganCapaldo> @kind ST
20:19:19 <lambdabot> Not in scope: type constructor or class `ST'
20:19:19 <lambdabot> Not in scope: type constructor or class `ST'
20:19:23 <LoganCapaldo> @kind IO
20:19:25 <lambdabot> * -> *
20:19:31 <ivanm> @type ST
20:19:33 <lambdabot> Not in scope: data constructor `ST'
20:19:38 <ivanm> @type State
20:19:39 <lambdabot> forall s a. (s -> (a, s)) -> State s a
20:19:47 <LoganCapaldo> Why is ST * -> * -> * ?
20:19:56 <LoganCapaldo> what's that param for?
20:20:22 <Cale> LoganCapaldo: for ensuring that references don't escape
20:20:31 <Cale> @type runST
20:20:32 <lambdabot> Not in scope: `runST'
20:20:39 <Cale> @type Control.Monad.ST.runST
20:20:41 <lambdabot> forall a. (forall s. GHC.ST.ST s a) -> a
20:21:31 <Cale> The fact that s scopes only over the parameter there means that the return type can't contain any s's.
20:21:39 <LoganCapaldo> Hiding the constructors isn't good enough?
20:22:18 <Cale> Well, consider something like  let r = runST (newSTRef 10)
20:22:28 <LoganCapaldo> ah
20:22:32 <LoganCapaldo> right
20:22:41 <LoganCapaldo> IO doesn't need that because there is no runIO
20:22:45 <Cale> Right.
20:24:14 <Cale> This also has the consequence that ($) is not sufficiently polymorphic to be able to apply runST to its parameter.
20:25:17 <LoganCapaldo> heheh really?
20:25:26 <LoganCapaldo> that's kind of amusing
20:25:37 <chessguy> yuck, the code formatting on The Haskell Sequence is awful :(
20:25:42 <chessguy> (for blogs)
20:25:47 <LoganCapaldo> Can you write a sufficiently polymorphic ($)?
20:26:09 <jfredett> hmm
20:26:31 <jfredett> thats odd, I can't seem to return " Just -1 " out of my function
20:26:34 <Cale> Not in Haskell, at least. I'm actually not completely sure what type it would need.
20:26:41 * sorear returns.
20:26:42 <Cale> jfredett: Just (-1)
20:26:46 <jfredett> because its being to lazy
20:27:00 <chessguy> is there a better (free) place to blog about Haskell?
20:27:24 <jfredett> oh- that works
20:27:25 <LoganCapaldo> What starting me on these questions was I was all raring to write a class Ref with readRef and writeRef and newRef functions so you could start in ST and switch to IO or vice versa
20:27:36 <jfredett> lol, simple solutions to simple problems, ayup
20:27:52 <Cale> LoganCapaldo: right, that's a problem with ST
20:28:06 <LoganCapaldo> but I guess I just discovered why that doesn't already exist
20:28:57 <SamB_XP> yeah, I'd rather use unsafePerformIO than tangle with those ST types
20:29:08 <Cale> ST is not so bad
20:29:13 <Cale> on its own :)
20:29:24 <SamB_XP> yes but sometimes I might want unboxed arrays
20:29:32 <jfredett> hussah, legendre symbol function == teh doneness.
20:29:37 <SamB_XP> then again, I might just use pure arrays ;-)
20:30:15 <SamB_XP> jfredett: you mean isDone (legendre symbol function)
20:30:27 <Cale> jfredett: Heh, you can write a QuickCheck property to ensure that the law of quadratic reciprocity is true.
20:30:45 <SamB_XP> or legendre symbol function `has` teh doneness
20:30:49 <jfredett> Cale: yes, and they call that the legendre symbol. :P
20:31:11 <jfredett> well- sortof
20:31:19 <jfredett> that way is the hard way
20:31:28 <jfredett> Euler's Criterion ftw.
20:31:56 <chessguy> well, any comments on http://sequence.complete.org/node/296 are welcome. it will probably move to a different blogging site when i find one though...
20:31:58 <lambdabot> Title: Chess in Haskell | The Haskell Sequence
20:32:10 <jfredett> a^((p - 1) `div` 2) `mod` p :)
20:32:34 <LoganCapaldo> chessguy writes about chess
20:32:46 <jfredett> ooh- chess
20:32:46 <chessguy> i know, what a novel idea ;)
20:32:52 <jfredett> i like chess, but i suck at it
20:32:59 <Cale> jfredett: I just mean leg q p = leg p q * (-1)^(((p-1)`div`2)*((q-1)`div`2))
20:33:04 <chessguy> jfredett, me too :)
20:33:30 <SamB_XP> chessguy: you could try to get the numbers to line up in a squarish shape
20:33:45 <jfredett> Cale, my legendre function is just a gussied up version of that, yes.
20:33:52 <chessguy> SamB_XP, crap. did they get screwed up? :(
20:34:05 <jfredett> the idea is to make it, gee, i dont know, readable?
20:34:06 <jfredett> :)
20:34:09 <chessguy> ugh
20:34:13 <SamB_XP> you seem to have forgotten to use <pre>
20:34:16 <Cale> Well, that can't be a definition of course
20:34:31 <SamB_XP> if I select it and "view selection source" it lines up
20:35:23 <jfredett> hmm, chessguy, why do you need O(1) access, I should think that, since you'll be updating alot, it may be better to go with something balanced, like finite maps, IIRC, they have O(log n) on just about everything
20:35:23 <chessguy> ok, fixed
20:36:08 <SamB_XP> jfredett: um.
20:36:10 <LoganCapaldo> people who need O(1) access, are the happiest people
20:36:17 <SamB_XP> chessboards are small.
20:36:19 <LoganCapaldo> in all the land
20:36:21 <SamB_XP> and dense.
20:36:34 <jfredett> SamB_XP: true- but what if you want to expand the AI to play variants
20:36:39 <jfredett> like 4 board chess, :)
20:36:45 <jfredett> or k^2 board chess
20:36:48 <jfredett> thats the fun stuff
20:36:48 <jfredett> :)
20:36:54 <SamB_XP> um. sepuku?
20:36:54 <chessguy> jfredett, updates and lookups are the most common thing you're going to do
20:37:03 <LoganCapaldo> it;s gotta play regular chess first <g>
20:37:04 <jfredett> i suppose that makes sense
20:37:11 <chessguy> and you're going to do it in the innermost loops of everything you do
20:37:21 <chessguy> so you want O(1) (or better) access
20:37:39 <SamB_XP> what is "or better"?
20:37:40 <jfredett> whats better than O(1)? I thought constant time was pretty damn good
20:37:42 <Cale> or better?
20:37:46 <jfredett> maybe O(-1)?
20:37:48 <Cale> O(-n)
20:37:49 <SamB_XP> O(1/n)?
20:37:51 <chessguy> lol, i knew that would get some attention :)
20:37:53 <jfredett> you gain some speed?
20:37:57 <SamB_XP> O(-1) is the same as O(1) isn't it?
20:38:07 <Cale> SamB_XP: yes
20:38:09 <jfredett> O(-Ack) :)
20:38:21 <chessguy> bitmaps give you parallel access to multiple locations in O(1) time
20:38:33 <jfredett> bitmaps? or bitboards?
20:38:46 <Cale> That would still be O(1) though.
20:38:50 <jfredett> i know theres a difference, I just want to make sure I wiki the right thing
20:38:53 <chessguy> you can call it either. bitboards is the more common chess lingo
20:39:01 <jfredett> oka
20:39:02 <jfredett> y
20:39:19 <chessguy> Cale, yeah, technically. that was for dramatic effect
20:39:25 <jfredett> nifty- thats a struct i'd like to see in Haskell- IIRC it wasn't particularly trivial.
20:39:25 <SamB_XP> I thought bitboards were more common in othello
20:39:31 <LoganCapaldo> depends onthe constant factor
20:39:48 <chessguy> jfredett, meh, they're just binary numbers
20:39:49 <LoganCapaldo> all cosntant times are equal but some are mor equal than others
20:40:09 <Cale> I suppose that technically, so long as you can't have arbitrarily large boards, every data structure is going to give you O(1) access.
20:40:13 <jfredett> LoganCapaldo: Whoa. Fuzzy Equality, Yay for logic!
20:40:37 <SamB_XP> actually O notation abuses = horendously
20:40:49 <SamB_XP> its more of a => deal
20:40:52 <jfredett> SamB_XP: I know, Algorithms hurts my brain
20:40:59 <jfredett> :/
20:41:11 <jfredett> yo necessito food. brb
20:41:14 <SamB_XP> or should I say <=?
20:41:20 <chessguy> Cale, eh?
20:41:26 <chessguy> Cale, what if you used a list? :)
20:41:36 <SamB_XP> chessguy: even so
20:41:44 <SamB_XP> the lookup time is bounded by the length of the list
20:41:54 <chessguy> yeah...
20:41:57 <chessguy> so it's O(n)
20:41:59 <SamB_XP> which... being constant... means it's O(1)
20:42:06 <Cale> SamB_XP: It's more of an 
20:42:12 <chessguy> well
20:42:13 <chessguy> ok
20:42:28 <SamB_XP> Cale: I suppose
20:42:33 <Cale> People write f(n) = O(n) when they mean f  O(\n -> n)
20:43:04 <SamB_XP> anyway, this is fairly well explained in Volume 1
20:43:16 <SamB_XP> not in so many words, perhaps
20:43:17 <chessguy> Volume 1?
20:43:22 <chessguy> CLR? or AOCP?
20:43:29 <SamB_XP> the latter
20:43:32 <SamB_XP> what's the former?
20:43:39 <chessguy> yeah, i guess CLR was only one volume
20:44:07 <chessguy> SamB_XP, the MIT one: http://theory.lcs.mit.edu/~clr/
20:44:08 <lambdabot> Title: Cormen/Leiserson/Rivest/Stein: Introduction to Algorithms
20:44:26 <SamB_XP> never heard of it
20:44:44 <LoganCapaldo> it has pretty red leaves on the cover
20:44:58 <chessguy> ah, a classic. i've never read it, but i got it out of the library once and used it for strength training
20:45:11 <jcreigh> chessguy: heh
20:45:54 <chessguy> jcreigh, by the way, speaking of chess, where is your project?
20:46:05 <jfredett> ooh, I have CLR... :)
20:46:06 <jcreigh> my project?
20:46:12 <jcreigh> oh, chess related.
20:46:16 <chessguy> jcreigh, weren't you working on a chess engine?
20:46:22 <Excedrin> chessguy: does Junior use bitboards?
20:46:24 <jcreigh> like all small projects I start, it's been left by the wayside
20:46:47 <chessguy> Excedrin, uh...junior is a commercial engine. they don't exactly hand out their source code...
20:46:57 <SamB_XP> jcreigh: so you have a big wayside?
20:46:59 <Excedrin> chessguy: also, are there any new engines that have improved on Junior?
20:47:05 <jcreigh> but don't most serious chess engines use bitboards?
20:47:10 <chessguy> Amir has probably said what he uses, but i don't recall offhand
20:47:16 <jcreigh> SamB_XP: no, it's just very well populated.
20:47:20 <weitzman> I just want to say that I love you people of #haskell
20:47:25 <chessguy> jcreigh, not necessarily
20:47:35 <weitzman> Every time I go to another channel to ask a quesiton, I get unhelpful assholes
20:47:38 <chessguy> 0x88 is pretty popular too
20:47:57 <jcreigh> 0x88?
20:48:05 <SamB_XP> weitzman: surely you also get the apathetic people who are also unhelpful
20:48:22 <chessguy> though, there have been some improvements in bitboards over the last couple years, and i haven't been active in the community, so they could be more common now
20:48:26 <weitzman> SamB_XP: Well, if I'm lucky
20:48:57 <chessguy> jcreigh, you can read about the basics of 0x88 on the first link at http://www.cis.uab.edu/hyatt/pubs.html
20:48:58 <lambdabot> Title: Online Publications
20:49:03 <jcreigh> o 6
20:49:12 <jcreigh> sorry, meant that for openurl :)
20:49:16 <chessguy> jcreigh, the first 2 links there also cover bitboards thoroughly
20:49:34 <chessguy> well, they introduce them thoroughly :)
20:50:04 <chessguy> i think bruce moreland has an intro to 0x88 on his site too
20:50:20 <chessguy> yeah: http://www.seanet.com/~brucemo/topics/0x88.htm
20:50:21 <lambdabot> Title: 0x88 Move Generation
20:50:58 <ibid> dcoutts: pong
20:55:29 <ibid> dcoutts: i'll note that /whois ibid is a better way of finding out whether i am online than lambdabot (as lambdabot does not see me talk on other channels)
20:56:24 <chessguy> @where lambdabot
20:56:25 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot.html
20:56:33 <chessguy> @seen lambdabot
20:56:33 <lambdabot> Yes, I'm here. I'm in #friendly-coders, #dreamlinux-es, #xmonad, #unicycling, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #
20:56:33 <lambdabot> darcs and #scannedinavian
20:59:38 <sorear> No instance Ord IORef
20:59:40 <sorear> Bah.
20:59:54 <LoganCapaldo> Bah?
21:00:01 <jfredett> Bah!
21:00:01 <Pseudonym> @go IOStableREf
21:00:03 <lambdabot> http://www.mail-archive.com/haskell-cafe@haskell.org/msg04591.html
21:00:03 <lambdabot> Title: Re: [Haskell-cafe] Ord (IORef a)?
21:00:13 <Pseudonym> sorear: Use that.
21:00:27 <LoganCapaldo> How could you have a an instance Ord IORef?
21:00:39 <LoganCapaldo> wouldn't compare have to be monadic?
21:00:53 <Pseudonym> LoganCapaldo: No, only creation has to be monadic.
21:00:54 <Pseudonym> And it is.
21:00:55 <sorear>                                     Error reading from socket                                 
21:01:13 <LoganCapaldo> @type readIORef
21:01:15 <lambdabot> Not in scope: `readIORef'
21:01:27 <LoganCapaldo> @type Data.IORef.readIORef
21:01:30 <lambdabot> forall a. GHC.IOBase.IORef a -> IO a
21:01:42 <sorear> Besides, I don't like copying code into projects :)
21:01:49 <sorear> importing I'm fine with
21:02:05 <Pseudonym> Well, it's a self-contained module.
21:02:23 <LoganCapaldo> maybe Ord IORef doesn't do what I think it does
21:02:26 <Pseudonym> Some time, I'm going to package up all of these little modules that people ask for and I've already implemented.
21:02:43 <Pseudonym> LoganCapaldo: I often use IORefs for hash consing.
21:02:54 <Pseudonym> For that, you need them to be hashable or Ordable.
21:03:12 <ibid> LoganCapaldo: the reason Ord IORef is sometimes useful is that there are situations where you want to put IORefs in an Ord-requiring container (like Set or as a key in a Map)
21:03:21 <Saizan> it's like comparing pointers
21:03:31 <LoganCapaldo> I thought that compare would have to look like do { v1 <- readIORef r1; v2 <- readIORef r2; return $ compare v1 v2 }
21:03:36 <Pseudonym> Except it's not, because in theory, IORefs could move due to compacting GC.
21:03:44 <ibid> LoganCapaldo: that would not be useful :)
21:03:52 <LoganCapaldo> Hence my confusion
21:04:16 <ibid> LoganCapaldo: for one, the ordering could change once you writeIORef :)
21:05:03 <LoganCapaldo> So you guys don't really care what the ordering is exactly, as long as its consistent, and you can use it to stick IORefs in containers?
21:05:22 <Pseudonym> Correct.
21:05:25 <LoganCapaldo> Ok
21:05:29 <LoganCapaldo> gotcha
21:08:55 <sorear> :t maybe
21:09:00 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
21:10:20 <LoganCapaldo> @type maybe Nothing Just
21:10:23 <lambdabot> forall a. Maybe a -> Maybe a
21:11:10 <Pseudonym> I sometimes wonder if all data constructors should have a CPS form like that.
21:11:13 <Pseudonym> @type list
21:11:15 <lambdabot> Not in scope: `list'
21:11:32 <Pseudonym> list :: a -> (a -> b -> b) -> [a] -> b
21:11:41 <shachaf> @type foldr
21:11:43 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
21:11:47 <Pseudonym> Right.
21:12:05 <shachaf> @type either Left Right
21:12:07 <Pseudonym> The point being that this is automagically derivable.
21:12:07 <lambdabot> forall a b. Either a b -> Either a b
21:12:39 <Pseudonym> pair :: (a -> b -> c) -> (a,b) -> c
21:12:51 <Pseudonym> @type uncurry
21:12:55 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
21:16:38 <LoganCapaldo> @type foldr (:) []
21:16:41 <lambdabot> forall a. [a] -> [a]
21:17:10 <LoganCapaldo> I didn't realize foldr was the CPS function for list before
21:17:13 <LoganCapaldo> silly me
21:17:25 <jfredett> CPS?
21:17:31 <Saizan> i won't really call that CPS
21:17:35 <jfredett> whats a CPS?
21:17:44 <Saizan> Continuation Passing Style
21:17:47 <jfredett> ooh
21:17:48 <jfredett> okay
21:17:48 <LoganCapaldo> Pseudonym said it first
21:17:54 <LoganCapaldo> I was just copying :)
21:18:16 <Pseudonym> It is CPS.
21:18:30 <Pseudonym> It turns pattern matching into continuations.
21:18:47 <Pseudonym> Actually, technically speaking, the type for list should be:
21:18:52 <LoganCapaldo> Woudl you prefer "I didn't realize foldr was the church encoder for list"?
21:19:04 <Pseudonym> list :: b -> (a -> [a] -> b) -> [a] -> b
21:19:16 <Saizan> LoganCapaldo: yeah, or catramorphism :)
21:19:20 <Saizan> *cata
21:19:56 <sorear> Pseudonym: Needs more forall's. :)
21:20:28 <LoganCapaldo> I think it might be time to try that bananas paper again
21:22:09 <dibblego> I have that function in Scala
21:22:16 <dibblego> def uncons[b](as: => c[a])(b: => b)(f: a => c[a] => b): b
21:23:25 <xpika> runhaskell says  Failed to load interface for `Main':
21:23:27 <xpika> :(
21:23:55 <Pseudonym> We really, really need an officially blessed way to do implcit configuration, IMO.
21:23:57 <Saizan> is your module called Main?
21:24:15 <xpika> nope
21:24:23 <Pseudonym> ANY value with ANY monomorphic type should be convertable into a typeclass instance.
21:24:28 <Pseudonym> At run-time.
21:24:33 <Saizan> that's the problem :)
21:24:42 <LoganCapaldo> if it has a name at all, and that name is not Main, that is your problem
21:24:55 <dibblego> Pseudonym, what do you mean by that exactly? do you have an example?
21:26:11 <xpika> Saizan: It still doesnt work if i add "module Main where" i think its because i have the extra option -package ghc
21:27:36 <Pseudonym> dibblego: Sure.  Here's an example.
21:27:52 <Pseudonym> Just a moment.
21:28:07 <dibblego> ok thanks
21:28:30 <Pseudonym> OK, consider this class:
21:29:20 <Pseudonym> class SomeValue s a | s -> a where getValue :: s -> a
21:29:37 <dibblego> what is | ?
21:29:43 <Pseudonym> Functional dependency.
21:29:57 <Pseudonym> The idea is that you have a state s, and that state stores a read-only value a.
21:30:16 <dibblego> ok
21:30:37 <Pseudonym> OK.  Now consider this:
21:30:47 <Pseudonym> class SomeValue s where  getValue :: s -> Int
21:30:48 <Pseudonym> Say.
21:31:00 <Pseudonym> I realised it'd be better to simplify it.
21:31:06 <Pseudonym> :-)
21:31:06 <Pseudonym> OK.
21:31:09 <dibblego> I see
21:31:30 <Pseudonym> So you have a state s which stores an Int.
21:31:55 <Pseudonym> You could make the state some structure which has an Int in it, but you can also actually store an Int in the type alone.
21:32:01 <Pseudonym> data Zero
21:32:17 <Pseudonym> data Succ a
21:32:36 <Pseudonym> instance SomeValue Zero where getValue _ = 0
21:32:51 <Pseudonym> instance SomeValue (Succ t) where getValue _ = 1 + getValue (undefined :: t)
21:32:53 <Pseudonym> Right?
21:33:10 <Saizan> SomeValue t =>
21:33:12 <dibblego> right
21:33:54 <Pseudonym> Errr.. right, Saizan.
21:33:54 <Pseudonym> Sorry, doing this from memory.
21:33:54 <Pseudonym> Mistakes like that will creep in.
21:33:54 <Pseudonym> OK.
21:34:13 <Pseudonym> To "store" an Int in this state, you have to construct a type which encodes it.
21:34:27 <Pseudonym> For example:
21:34:45 <Pseudonym> reifyInt :: Int -> (forall s. SomeValue s => s -> a) -> a
21:34:56 <Pseudonym> reifyInt 0 k = k (undefined :: Zero)
21:35:34 <Pseudonym> reifyInt n k = reifyInt (n-1) (\(_::s) -> k (undefined :: Succ s))
21:36:04 <Pseudonym> The neat thing is that you can then pass values as types.
21:36:22 <LoganCapaldo> wait, can you do this now, in haskell?
21:36:28 <sorear> Yes.
21:36:28 <Pseudonym> Yes.
21:36:44 <sorear> @google implicit configurations kiselyov shan
21:36:48 <lambdabot> http://portal.acm.org/citation.cfm?id=1017481&dl=&coll=&CFID=15151515&CFTOKEN=6184618
21:36:48 <lambdabot> Title: Functional pearl
21:36:52 <dibblego> that's pretty neat
21:36:53 <Pseudonym> Exactly.
21:36:57 <Pseudonym> Who else but Oleg?
21:37:04 <sorear> Of course, the "Kiselyov" part is a dead givaway. :)
21:37:08 <Pseudonym> In the paper, they show a way to reflect ANYTHING.
21:37:15 <Pseudonym> Using FFI.
21:37:24 <Pseudonym> You store the object, then reify the address.
21:37:30 <Pseudonym> Unfortunately, the object isn't GC'd.
21:37:49 <Pseudonym> I think there needs to be an officially blessed, and probably built-in, way to do this.
21:37:59 <LoganCapaldo> I'm boggled, and wondering why it isn't complaining about  infinite types and such
21:38:11 <Pseudonym> Because there are no infinite types.
21:38:12 <LoganCapaldo> boggled I say
21:38:35 <LoganCapaldo> well clearly there are no infinite types or else it would be complaining
21:38:41 <Pseudonym> Note that there are at several non-H98 extensions working in concert here.
21:38:52 <Saizan> LoganCapaldo: you have to use a rank2 type, so the continuation is forced to take any s in SomeValue
21:38:56 <Pseudonym> Fundeps (in the general case), higher-ranked types, lexically-scoped type vars and so on.
21:39:10 <LoganCapaldo> lexically scoped type vars!
21:39:15 <Pseudonym> And, of course, no-constructor types, though those are optional.
21:39:20 <LoganCapaldo> I knew that looked funny earlier
21:39:34 * LoganCapaldo remains boggled, but intrigued
21:39:46 <sorear> Higher rank functionally typed lexical dependancies OF DEATH!!!
21:40:00 <sorear> Or something.
21:40:05 <Pseudonym> The thing is, this feature would be bloody useful in many ways.
21:40:10 <Saizan> lexical scoped tpe vars aren't really needed
21:40:19 <dibblego> sorear, depend*e*ncy (sorry, you've done it enough times now to warrant me saying something :))
21:40:20 <Pseudonym> No, but they're useful.
21:40:43 <Pseudonym> Lexically scoped type vars lets you write whole programs using only "undefined" as values. :-)
21:41:12 <Saizan> succ :: s -> Succ s; succ = undefined; and then (\s -> k (succ s))
21:41:21 <Pseudonym> Right.
21:41:50 <Pseudonym> I'm doing some computer algebra at the moment, and I need some of this.
21:42:11 <Pseudonym> For example, with multinomials, it's useful to implement that as a polynomial with polynomials as coefficients.
21:42:25 <Pseudonym> But you'd like to store the name of the monomial for easy debugging purposes.
21:42:46 <Pseudonym> And that would require reifying a string as a type.
21:42:56 <Pseudonym> Which, being integral, isn't so bad.
21:43:09 <Pseudonym> But still.
21:43:42 <LoganCapaldo> arg. type to int made total sense. How the heck you are going from int to type is still boggling me.
21:44:27 <Pseudonym> And, I might add, this would remove the last argument in favour of implicit parameters.
21:44:38 <Pseudonym> Which are a real blot.
21:47:09 <Saizan> uhm, you need to build dictionaries at runtime
21:47:23 <Heffalump> you can do that with polymorphic recursion
21:47:58 <LoganCapaldo> implict parameters being?
21:48:36 <LoganCapaldo> the dictionary of type class functions for a value?
21:48:44 <LoganCapaldo> s/value/type/
21:49:31 <Saizan> ?type Let f = ?a + 1 in let ?a = 4 in f
21:49:35 <lambdabot> parse error on input `='
21:49:47 <Saizan> > let f = ?a + 1 in let ?a = 4 in f
21:49:47 <lambdabot>  Parse error
21:49:59 <Saizan> > let f = ?a + 1 in let a = 4 in f
21:49:59 <lambdabot>  Parse error
21:50:25 <LoganCapaldo> @type let f = ?a + 1 in let a = 4 in f
21:50:27 <lambdabot> forall a. (Num a, ?a::a) => a
21:50:58 <mauke> @type let f = show ?zomg in f
21:51:02 <lambdabot> (?zomg::Integer) => String
21:51:51 <LoganCapaldo> @type map ?f [1,2,3]
21:51:54 <lambdabot> forall a b. (?f::a -> b, Num a) => [b]
21:52:01 <Saizan> LoganCapaldo: they are like named ReaderT a, you can refer to a variable that's not in your lexical scope, but rather in the scoper of your caller
21:52:32 <LoganCapaldo> Saizan: why do you want / need that?
21:52:59 <Saizan> LoganCapaldo: when you don't want to thread a variable inside a deep stack of function calls
21:53:20 <Saizan> LoganCapaldo: and you don't like Reader
21:53:37 <LoganCapaldo> You just don't like Reader for no good reason? :)
21:54:00 <Saizan> well, you don't want to sequenzialize your code :)
21:54:06 <LoganCapaldo> Ah
21:54:07 <LoganCapaldo> ok
21:54:11 <LoganCapaldo> that's something
21:55:09 <LoganCapaldo> thanks guys
21:55:12 <LoganCapaldo> night :)
21:55:22 <Saizan> night
21:55:39 * Saizan sees the sun rising
21:57:09 <mm_freak> time for geeks to go to bedd
21:58:42 <Korollary> all of us?
22:00:24 <sorear> That would be one *huge* advantage of a flat Earth.
22:00:48 <jcreigh> lol
22:01:27 <jcreigh> @remember sorear <mm_freak> time for geeks to go to bed <Korollary> all of us? <sorear> That would be one *huge* advantage of a flat Earth.
22:01:27 <lambdabot> Done.
22:02:01 <Korollary> how would it be an advantage?
22:02:55 * sorear "loves" time zones.
22:03:32 <ivanm> how does having a flat earth make uniform time zones?
22:03:34 <Korollary> and I love oncall people in Ireland who watch our stuff while we sleep.
22:03:39 <ivanm> you would need uniform lighting for that to work...
22:03:45 <dibblego> because then the Sun is flat and the earth is constantly in darkness
22:04:00 <ivanm> no....
22:04:06 <ivanm> flat earth -/-> flat sun
22:05:26 <Cale> I think we should start a Flat Sun Society.
22:05:40 <Cale> The Earth is round, it's the *Sun* which is flat.
22:06:00 <ivanm> lol
22:06:16 <jcreigh> heh. yeah, it's just a giant disc, tidally locked with earth.
22:06:24 <ivanm> @remember Cale I think we should start a Flat Sun Society. The Earth is round, it's the *Sun* which is flat.
22:06:24 <lambdabot> Done.
22:06:26 <dibblego> the Earth is a giant ball of hydrogen, it is the *Sun* whihc harbours life
22:06:32 <sorear> Billboarding!
22:06:57 <ivanm> dibblego: right....
22:07:04 <ivanm> that's just a matter of labelling...
22:07:23 <Cale> jcreigh: No, it's an infinite plane. It's just an optical illusion that it looks like a ball or disc to us.
22:07:34 <sorear> How do you know there's no life on the Sun?
22:07:35 <ivanm> heh
22:07:49 <ivanm> Cale: due to gravity bending the light rays or something?
22:07:49 <jcreigh> Cale: oh, right, sorry. But to my credit, it's an easy mistake to make. :)
22:08:00 <Cale> ivanm: something like that
22:08:12 <Korollary> There's no life on the sun because certain religious texts assert so.
22:08:20 <ivanm> lol
22:08:24 <sorear> treble: hello!
22:08:25 <ivanm> which ones, though?
22:08:30 <sorear> treble: hpaste is down
22:08:42 <Korollary> ivanm: does it matter? I'm trying to be difficult here.
22:08:46 <ivanm> heh
22:08:48 <dibblego> but when we find life there, those religious texts will have been saying something else all along
22:08:53 <treble> ugh, one sec
22:09:05 <ivanm> Korollary: what, you'll make one up if you have to just so that you can be proven correct? :p
22:09:07 <treble> I don't have the ssh key on this machine
22:09:11 <Korollary> dibblego: it's ok. They've been wrong before.
22:09:13 <treble> give me a sec
22:12:44 <treble> the checkpoint file was lost
22:12:53 <treble> I had to roll back a few hours
22:13:35 <sorear> seems odd that haskell programs are so forgetful...
22:14:05 * sorear does have "Solve the State Problem" on his todo. :)
22:15:15 <ivanm> sorear: come on, we have to leave imperative programmers _something_ to feel superior about! ;-)
22:15:40 <Excedrin> what's the state problem
22:16:17 <ivanm> sorear> seems odd that haskell programs are so forgetful... <-- that, I presume
22:16:19 <sorear> Excedrin: go to hpaste.org and look for recent pastes.  Or, look through the logs and try to find matching quotes.  Or, ...
22:16:31 <sorear> s/quotes/lambdabot &/
22:16:56 <ivanm> so "try to find matching lambdabot &"? that doesn't make much sense... ;-)
22:17:31 <scook0> I'm looking for a function of type (Read a => String -> Maybe a), with the "obvious" behaviour -- is there one in the standard libs?
22:17:39 <scook0> (Hoogle doesn't come up with anything)
22:18:05 <ivanm> "Obvious behaviour"?
22:18:31 <scook0> return Nothing if there's no valid parse
22:18:41 <LeCamarade> ]/clear
22:18:42 <scook0> otherwise behave like (Just . read)
22:26:34 <lispy> it's more likely to be Read a => String -> Either a String (I might have the Either reversed)
22:27:01 <lispy> so that, Right gives you an error message and Left givnes you a value
22:27:09 <Saizan> ?type reads
22:27:13 <lambdabot> forall a. (Read a) => String -> [(a, String)]
22:28:28 <Saizan> ?type listToMaybe . map fst . reads -- i've seen variants of this defined quite often
22:28:30 <lambdabot> forall a. (Read a) => String -> Maybe a
22:28:40 <Saizan> ?docs Text.Read
22:28:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Read.html
22:30:54 <sorear> Yay IRC.
22:31:14 <sorear>   * RHS of a type instance must be a tau type
22:31:45 <sorear> Don't know what that is, but it's been *very* prominent on the Associated Types TODO for a *long* time.
22:32:04 <sorear> must be very good sign!
22:33:23 <Saizan> religious sign?
22:36:51 <lindzeyn> Hey everyone, quick question, I am using randomRIO and I want it to return an Int rather than an IO t, is there an easy way to coerce output from randomRIO
22:37:22 <sorear> No.
22:37:27 <ivanm> do it in the main method, and use the x <- foo construct
22:37:32 <Pete_I> does haskell have macros?
22:37:47 <Pete_I> similar to what lisp has?
22:38:08 <lindzeyn> ivanm can you elaborate?
22:38:14 <Pete_I> i'm trying to decide which i should learn.
22:38:16 <Saizan> Pete_I: yes, but you probably don't need them to do the same things that'll need macros in lisp
22:38:57 <sorear> Also, they're much harder to use.
22:39:16 <sorear> The AST definition is 5 pages (100 line terminal)
22:40:04 <ivanm> lindzeyn: wel, I've never used randomRIO, but I've used newstdgen in the main class... I can post a summary of what I did on hpaste if you want
22:40:40 <lindzeyn> thats alright, i'll put it on the backburner
22:40:51 <ivanm> *nod*
22:41:12 <ivanm> simple thing is, you can't convert anything of type IO to anything else (I've asked about this before)
22:41:46 <lindzeyn> ah, the strong types are killing us :)
22:41:48 <ivanm> the best you can do is have some method that does IO operations extract the value from the IO monad, then call another method that wants that value, get the result back and output it
22:41:50 <ivanm> heh
22:41:54 <lindzeyn> yea
22:42:09 <lindzeyn> i was thinking of writing to a file the reading hehe
22:42:58 <lindzeyn> I like the psuedorandom functions, but there comes a point where I just need something much more random w/ no stochastic index
22:43:09 <lindzeyn> pseudo*
22:43:31 <Saizan> lindzeyn: even randomRIO uses a seed, it's just hidden
22:43:35 <lindzeyn> otherwise you have to keep changing value of the seed
22:44:08 <lindzeyn> right but it changes the seed, or takes randomly from an infinite list
22:45:19 <Saizan> it split new seeds from the standard one initialized with time(), yep
22:49:01 <lispy> i know a way to convert IO to other types, it's called main :)
22:49:29 <ivanm> lol
22:49:41 <ivanm> though they get turned right back again though...
22:50:03 <lispy> i guess you could write them to a file and read them using C or something ;)
22:50:50 <lispy> ivanm: why do you need to convert it out of IO? usually people write pure code and use it from inside the IO monad
22:51:10 <lispy> because inside the IO monad you can get at the value part, call the functions you need to call, and then put the value back in the monad
22:51:23 <ivanm> *nod*
22:51:43 <lindzeyn> monads are over my head right now
22:51:56 <ivanm> though I think it'd be nice to be able to have a function generate a newstdgen for example each time its called, without having to use main as a wrapper
22:51:59 <lindzeyn> once I grow so gonads, I'll approach monads
22:52:02 <lindzeyn> some
22:52:11 <lispy> the IO monad is not bad at all, it's actually very similar to using C or some other imperative language
22:53:01 <lispy> ivanm: there probably is a function for that, but i rarely work with random
22:53:09 <lispy> so idon't know...
22:53:28 <ivanm> don't think so, since the only way to get a new random seed is to use an IO call
22:53:28 <lispy> ivanm: have you spoken to Cale about this? I know he has several examples of how to use random
22:53:50 <lispy> ah, i probably misunderstand the problem then
22:53:51 <ivanm> well, I was asking about this a month or so ago, and that was the only way I could find out back then
22:54:07 <ivanm> can't recall who I was talking to at the time, to be honest
22:54:25 <Cale> hm?
22:56:00 <ivanm> talking about how to let functions obtain new seeds for use in creating (pseudo) random numbers
22:56:12 <ivanm> _without_ using main, or the IO monad
22:56:28 <lispy> oh, right
22:56:39 <lispy> yeah, that's not really going to wokr, where do you get your entropy from in pure code?
22:57:19 <Cale> Well, when you generate a pseudorandom number, you get a new seed along with it.
22:57:28 <Cale> In the form of a generator.
22:57:38 <Cale> @type randomR
22:57:40 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> (a, g)
22:58:03 <Cale> (Takes a range, and a generator, and gives a value in that range, and a new generator)
22:58:29 <lindzeyn> is there anything in Haskell that will return a hash of the data in a range of memory?
22:58:31 <Cale> Of course, if you want, you can have a state monad, or a more specialised monad maintain the generator for you.
22:58:36 <lindzeyn> or is that too C
22:59:09 <Cale> lindzeyn: I'm sure you can do it. I'm not sure that you're very likely to want to.
22:59:13 <dmwit> lindzeyn: If you want that, you probably aren't writing Haskell.
22:59:42 <lindzeyn> yea, I come from a C upbringing, I really like Haskell though
22:59:53 <lindzeyn> Im trying to learn it, its very elegant
23:00:04 <dmwit> Yeah, lots of neat stuff. =)
23:00:33 <Cale> Generally you don't think at the level of memory -- that's something for the compiler to take care of. You think in terms of values.
23:00:45 <desp> @hoogle Maybe a -> a
23:00:46 <lambdabot> Maybe.fromJust :: Maybe a -> a
23:00:46 <lambdabot> Maybe.fromMaybe :: a -> Maybe a -> a
23:00:46 <lambdabot> Prelude.maybe :: b -> (a -> b) -> Maybe a -> b
23:00:53 <ivanm> lispy: yeah, I know...
23:01:24 <Cale> Of course, if memory becomes a problem, you need some model for how much things are going to use, but you can approximate this quite well by looking at the sizes of expressions for things as you might write them down.
23:01:30 <Alexy> hello
23:01:34 <Cale> Alexy: hello
23:01:53 <Cale> There's also really good profiling support in GHC.
23:02:22 <lindzeyn> Im glad to hear that
23:02:50 <lindzeyn> I am writing a genetic algorithm so I as few cycles as possible
23:02:56 <lindzeyn> I need
23:03:23 * dmwit munches on his processor
23:03:33 <dmwit> Tasty chips!
23:03:47 <Cale> Oh, I should point out that there are unboxed arrays, which are kind of like raw blocks of memory.
23:04:01 <lindzeyn> I was debating about taking the Haskell IR and porting it to Java
23:04:16 <lindzeyn> but ghc is pretty good you say
23:04:55 <Saizan> IR?
23:05:22 <lindzeyn> Intermediate Representation
23:05:30 <dmwit> Wow, Google for "IR acronym" -- lots of hits!
23:05:39 <Cale> It can take a while before you really get a good handle on how to measure the performance of Haskell code and really optimise things, (like it takes a while to work out performance the first time you learn imperative programming)
23:05:45 <dmwit> Er, I mean, lots of meanings given at the first hit.
23:05:57 <Cale> But the profiler helps, as does actually learning to run code by hand :)
23:06:47 <lindzeyn> Does it do a good job of getting rid of inherent recursive calls
23:06:53 <lindzeyn> and makes things more iterative
23:08:07 <lindzeyn> I'll read up on it
23:08:12 <Cale> In many cases -- often less than you'd want.
23:08:23 <lindzeyn> ah
23:08:34 <Cale> Lazy evaluation has funny effects on tail-recursion.
23:08:36 * dibblego wonders what an inherently recursive call is
23:08:42 <sorear> lindzeyn: WAY better than java, though.
23:09:11 <Cale> There are also libraries which help the compiler optimise combinations of calls to their functions.
23:09:24 <lindzeyn> cool
23:09:40 <Cale> Like Data.ByteString, which can produce programs that rival the performance of C programs in many cases.
23:09:40 <sjanssen_> lindzeyn: yeah, GHC should be competitive with Java
23:09:41 <lindzeyn> yea I was wondering about how it handled lazy eval
23:09:55 <Cale> Lazy evaluation is just the combination of two things:
23:09:56 <sjanssen_> (the shootout tends to agree)
23:09:57 <Bourbaki> moin
23:09:58 <lindzeyn> Thats saves some time, thanks
23:10:11 <Cale> 1) Outermost first evaluation
23:10:21 <Cale> and 2) sharing of duplicated parameters to a function
23:10:25 <Bourbaki> can you compile a dll with ghc on winx?
23:10:36 <dmwit> ?quote cookie
23:10:36 <lambdabot> vegai says: Hey Haskell! Give me that File! -Naah, I'm too lazy. *thinks* I'll give you a cookie if you tell me how many letters that file has! -Oh, ok!
23:10:37 <Cale> That means, if you have f (g x), then f is expanded first.
23:10:53 <Cale> say you have f y = y + y
23:11:20 <Cale> Then with outermost first evaluation we have: f (g x) -> (g x) + (g x)
23:11:30 <Cale> and then g x would get expanded and so on
23:11:51 <lindzeyn> so its left associative function function operator
23:11:57 <Cale> But as you can see, it looks like the work for computing g x will get repeated.
23:12:32 <Cale> But that's what the sharing is about -- it remembers that both the (g x)'s came from replacing y, and when one evaluates, the other is updated automatically for free.
23:13:28 <lindzeyn> Cool
23:13:38 <Cale> Perhaps I should do a really concrete example...
23:13:46 <Cale> f x = x + x
23:13:51 <Cale> f (f 5)
23:13:56 <lindzeyn> I see whats happening
23:14:05 <Cale> -> let y = f 5 in y + y
23:14:11 <Cale> -> let y = 5 + 5 in y + y
23:14:14 <Cale> -> let y = 10 in y + y
23:14:17 <Cale> -> 20
23:14:45 <lindzeyn> Got it
23:14:49 <lindzeyn> Thanks
23:14:51 <Cale> Whereas with strict evaluation, you do innermost first, of course.
23:15:01 <Cale> and that's really all there is to it :)
23:15:21 <DRMacIver> Morning
23:15:22 <Cale> I suppose you can get right down to how this is implemented on stock hardware
23:15:36 <Cale> But this approach is good enough for most purposes.
23:15:36 <sorear> lindzeyn: http://tunes.org/~nef/logs/haskell/07.04.02  starting around 10:34
23:15:38 <sorear> PM
23:15:41 <Bourbaki> ok dumb question
23:15:53 <lindzeyn> Thanks everyone
23:15:55 <Bourbaki> anotherone hopefully not so dumb
23:16:09 <sorear> I gave a long explanation of haskell compilation technology (and have been too lazy to compile it in document form)
23:16:28 <Bourbaki> can i wrap up hs-plugins in a dll and thus use haskell in c++ that way?
23:16:36 <Saizan> it's worth nothing that you really write f x = (g x) + (g x) as code, than those (g x) are computed separately
23:16:42 <Saizan> *noting
23:17:10 <Cale> Oh, yes
23:17:27 <sorear> Bourbaki: Uhm, look at the existing C interface
23:17:28 <Cale> That's why I used the 'let' form when I did the second example.
23:17:38 <bd_> but that could change in future versions, right? :)
23:17:48 <Cale> Well, it depends on CSE.
23:17:54 <Bourbaki> sorear : well id like to have haskell as an embedded language in c++
23:18:34 <ttfh> Saizan: but the compiler might optimize that, right?
23:18:35 <Cale> The compiler will actually detect some things and common them up as an optimisation. You have to be careful though, since sometimes that means that things that would otherwise be garbage collected have to wait longer.
23:19:06 <Cale> (i.e. it's a time/space tradeoff)
23:19:13 <Saizan> ttfh: ghc doesn't do that because it can be harmful
23:19:26 <Cale> GHC does *some* CSE.
23:19:50 <Cale> but it's a small enough amount that you can probably expect it not to common things up on you.
23:20:24 <Saizan> Cale: is it predictable?
23:20:48 <Cale> I don't think it's easy, but I'm not that familiar.
23:21:40 <Cale> CSE happens after the simplifier
23:21:46 <Cale> and lots of other stuff
23:21:52 <Saizan> a let is not so hard to use, anyway
23:21:53 <Cale> so probably not too predictable
23:22:10 <dons> ?yow
23:22:10 <lambdabot> I'd like some JUNK FOOD ... and then I want to be ALONE --
23:22:24 <Cale> dons probably knows better than I do :)
23:22:48 <Cale> http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain is a handy overview of what goes on in GHC.
23:22:50 <lambdabot> Title: Commentary/Compiler/HscMain - GHC - Trac, http://tinyurl.com/2ej9w4
23:23:11 <dons> what's that? cse in ghc?
23:23:26 <dons> there's a bit, but it can cause space leaks,  so best to do it manually
23:23:35 <Cale> right
23:23:52 <Cale> How does GHC decide whether or not it wants to do CSE?
23:23:57 <dons> one common case that doesn't work is in guards, in tight recursive loops
23:24:05 <dons>  you can often get a good win there with a 'where' clause
23:24:12 <dons> Cale: let me check..
23:24:44 <dons> http://haskell.org/haskellwiki/Performance/GHC#Common_subexpressions
23:24:46 <lambdabot> Title: Performance/GHC - HaskellWiki, http://tinyurl.com/3cmjvj
23:24:52 <dons> GHC doesn't do full CSE.  It'd be a relatively easy pass for someone to
23:24:52 <dons> add, but it can cause space leaks.  And it can replace two
23:24:53 <dons> strictly-evaluated calls with one lazy thunk
23:25:00 <dons> Instead GHC does "opportunistic CSE".  If you have
23:25:01 <dons>         let x = e in .... let y = e in ....
23:25:01 <dons> then it'll discard the duplicate binding. But that's very weak.
23:25:18 <dons> someone *could* add a hard CSE pass, to be enabled on demand
23:25:32 <dons> for those who know whta they're doing. would be a good introductory ghc hack
23:25:36 <dons> maybe glguy could do it.
23:25:44 * dons looks for things for glguy to do
23:26:00 <Bourbaki> can anyone of you point me to a site that gives me a start on how one would write a haskell like (very basic) language?
23:26:09 <glguy> do what?
23:26:16 <dons> Bourbaki: indeed I can!
23:26:23 * glguy realizes he'd better read through the backlog
23:26:23 <Bourbaki> ah thanks
23:26:28 <weitzman> Is there anything dons can't do?
23:26:37 <dons> here, we do it as an undergrad exercise, http://cgi.cse.unsw.edu.au/~cs3161/
23:26:37 <lambdabot> Title: Notices : COMP3161/9161 Concepts of Progamming Languages 2006/S1
23:26:51 <dons> Bourbaki: in particular, googling for MinML or MiniML should yield lots of nice hits.
23:27:02 <ttfh> hmm, a let certainly isn't hard to use, and might also make things easier to read
23:27:02 <jre2> weitzman: throw rave parties?
23:27:07 <dons> Bourbaki: see assignment 1 (the interpreter) and assignment 2 (the type checker)
23:27:14 <Bourbaki> ok thanks
23:27:19 <dons> jre2: we can do that if you want.
23:27:27 <dons> maybe at the next hackathon
23:27:41 <jre2> hah
23:27:52 <Bourbaki> how well are languages like that suited for slow hardware with limited memory?
23:27:56 <jre2> Bourbaki: at UIUC we write MicroML in ocaml
23:27:58 <dons> instead of going to the pub all night, like we usually do.
23:28:02 <jre2> http://www.cs.uiuc.edu/class/sp07/cs421/mps/
23:28:03 <lambdabot> Title: CS 421 (Spring 2007): mps
23:28:10 <dons> Bourbaki: things like miniML would be *great* for embedded/limited systems.
23:28:12 <Bourbaki> thanks
23:28:32 <dons> Bourbaki: should be a fair bit of work out there on FP for embedded/constrained systems
23:28:38 <dons> people put lisp on a chip, in the old days
23:28:41 <weitzman> At CMU, we write MinML in SML. I also wrote a garbage collector in ML, for extra irony
23:29:06 <Bourbaki> well lets say i was able to more or less get rid of the GC
23:29:17 <Bourbaki> cause i know all the data in advance
23:29:35 <Bourbaki> thus the GC is reduced to just flaggind data fields as beeing used or not
23:29:56 <dons> Bourbaki: maybe look at region inference then?
23:30:05 <jre2> weitzman: hows undergrad CS at cmu? (in your opinion)
23:30:06 <Sgeo> G'night all
23:30:08 <Bourbaki> region interface whats that?
23:30:12 <dons> that can be used to infer a priori allocation points
23:30:21 <weitzman> jre2: I was 99% satisfied
23:30:25 <dons> an analysis for heap object lifetimes
23:30:29 <dons> so you can avoid GC.
23:30:30 <weitzman> jre2: I had a senile professor or two, but who doesn't?
23:30:32 * fishkandy wishes those courses existed when he was at CSE :-)
23:30:37 <dons> a bit like we can infer scope for stack objects
23:30:48 <dons> fishkandy: and the new 'language security' course.
23:30:54 <jre2> weitzman: of course
23:30:57 <fishkandy> neat
23:31:00 <dons> all the good stuff now that everyone's left :}
23:31:05 <ttfh> http://citeseer.ist.psu.edu/cache/papers/cs/11330/http:zSzzSzwww.cs.chalmers.sezSz~paretozSzicfp99.pdf/hughes99recursion.pdf
23:31:07 <lambdabot> http://tinyurl.com/3xsbez
23:31:47 <ttfh> Is that region inference? I don't really understand it, but it looks cool
23:31:57 <fishkandy> dons: thankfully the lecture notes are online ;-) also the chalmers ones
23:32:07 <dons> the original regoin papers were Tofte and Talpin, iirc
23:32:08 <Bourbaki> hm
23:32:21 <jre2> weitzman: from what I've gathered from talking with various people, it seems cmu has better integration of CS and other disciplines than we do at uiuc (graphics,music,etc)
23:32:21 <dons> there's at least one by Appel, on how to write a GC with a language supporting region inference
23:32:26 <Bourbaki> miniml.com is that miniml site?
23:32:38 <dons> probably not. look for courses at CMU.
23:33:09 <weitzman> jre2: CMU has good number of courses that combine CS with stuff. I took an intro to computer music course
23:33:25 <ttfh> hmm miniml.com is something about fonts
23:33:30 <weitzman> jre2: There's a neat course called "building virtual worlds" that combines a lot of disciplines
23:33:33 <lindzeyn> nice, who taught that
23:33:36 <lindzeyn> weiztman
23:33:43 <Bourbaki> id like to use a small FP language for scripting
23:33:45 <weitzman> lindzeyn: Roger Dannenberg
23:34:15 <lindzeyn> Did you learn algorithmic composition?
23:34:30 <jre2> Bourbaki: sure you don't want full haskell for scripting?
23:34:34 <weitzman> lindzeyn: We discussed it briefly. We spent most of the time on synthesis methods
23:34:56 <Bourbaki> jre2 : actually id like to try to port some fp language for the ds and psp
23:35:04 <lindzeyn> Cool, Did you study any of Paul Lansky's works?
23:35:14 <jre2> Bourbaki: that would be pretty cool actually
23:35:24 <weitzman> lindzeyn: We listened to some of his stuff. Most classes would end with about 10 minutes of listening
23:35:42 <lindzeyn> I absolutely love "Table's Clear"
23:35:55 <lindzeyn> Do you have  a favorite electronical composed work?
23:36:06 <lindzeyn> electronically*
23:36:13 <weitzman> lindzeyn: I don't remember the names of anything we listened to, but I definitely listened to the most painful composition ever created
23:36:23 <lindzeyn> Haha
23:36:29 <lindzeyn> Stockhausen?
23:36:41 <lindzeyn> He had some brutal ones
23:36:57 <jre2> Bourbaki: I only looked into doing something on the nds/psp for a day, but it seems they have c,lua,python to various extents but not much beyond a SDL-like graphics library
23:36:58 <weitzman> lindzeyn: No idea. It was just some kind of stochastic disaster screetching sound
23:37:04 <lindzeyn> Hehe nice
23:37:32 <weitzman> lindzeyn: There was a neat piece made from an 8 note scale. Basically just two overlayed diminished chords
23:38:13 <lindzeyn> Octatonic then
23:38:15 <lindzeyn> Cool
23:38:38 <weitzman> lindzeyn: Dannenberg has done some pretty neat stuff
23:38:40 <lindzeyn> You can get some beautiful sonorities w/ that scale
23:38:52 <lindzeyn> I'll check him out
23:39:02 <dons> Bourbaki: people run haskell in hugs or nhc98 on tiny devices (like phones)
23:39:10 <weitzman> lindzeyn: He made a system that accompanies people and follows along with them a few decades ago
23:39:34 <weitzman> lindzeyn: He's also got a very impressive-sounded trumpet synthisizer using something he calls spectral synthesis
23:40:08 <lindzeyn> Hhmm sounds like a heuristic for sampling the harmonic series?
23:40:20 <weitzman> lindzeyn: Spectral interpolation might be what he calls it actually
23:40:21 <lindzeyn> Or is that all synthesis is
23:40:37 <lindzeyn> Cool
23:40:48 <weitzman> lindzeyn: It's just a method of integrating different samples that varies the samples used depending on volume and stuff
23:41:02 <weitzman> lindzeyn: Except you don't need a billion samples, and you can blend smoothly between them
23:41:15 <wolverian> it's great for generating terrain! :)
23:41:48 <lindzeyn> Good Call on taking amplitude into consideration, Loudness does affect the timbre on an intstrument, which MIDI i believes fails to take into account
23:41:58 <weitzman> lindzeyn: Dannenberg makes a pretty compelling argument that midi sucks
23:42:14 <lindzeyn> Amen
23:42:16 <lindzeyn> Hehe
23:42:24 <wolverian> no-one disagrees with that, I think..
23:42:24 <jre2> any better replacements for it?
23:42:29 <wolverian> that's the problem
23:42:33 <weitzman> lindzeyn: He noticed in building the trumpet synthsize that using human-derive control parameters gets human like sound
23:42:34 <wolverian> proprietary ones only, afaik
23:42:56 <weitzman> lindzeyn: And without human-based control parameters, the same synthesizer sounds very lifeless
23:43:06 <lindzeyn> would those parameters be mostly associated with ombichere (sp)?
23:43:39 <lindzeyn> thats makes sense
23:43:39 <weitzman> Depends on the instrument. For trumpet, he sampled himself playing stuff to learn parameters
23:43:48 <lindzeyn> Cool
23:47:00 <Bourbaki> dons : so there is a port of some kind?
23:48:40 <Bourbaki> im sorry if some of the question sound dumb
23:49:53 <dons> a port of?
23:50:09 <Bourbaki> haskell to cellphones
23:50:27 <dons> talk to shapr, i think hugs has an existing port to at least some nokia devices, and nhc should also
23:50:31 <Bourbaki> or do they compile .o files and link them for the platform?
23:50:38 <Bourbaki> ah ok
23:50:39 <dons> some to .o , some interpreted
23:50:42 <mgsloan> depends on the compiler you're talking about
23:50:43 <mgsloan> yeah
23:50:58 <mgsloan> I think there's some project working on java as well, which might be a good vector for cellphones..
23:51:12 <Bourbaki> the problem is if id have to have .o files for loads of platforms
23:51:18 <Bourbaki> pc ds and psp at least
23:52:41 <dons> yep, you'd use nhc then
23:52:44 <dons> or maybe yhc
23:53:33 <Bourbaki> but it wont compile .o files for these platform natively would it?
23:54:21 <dons> Cale: can you subcategorise this maths sectoin? --> http://haskell.org/haskellwiki/Blog_articles/Mathematics#Haskell_for_mathematics
23:54:23 <lambdabot> Title: Blog articles/Mathematics - HaskellWiki, http://tinyurl.com/2z7nz6
23:54:49 <Cale> dons: yeah
23:58:01 <Saizan> so the .hi contains all the code for that module?
23:58:20 <Saizan> (by reading http://hackage.haskell.org/trac/ghc/wiki/Commentary/Compiler/HscMain )
23:58:32 <lambdabot> Title: Commentary/Compiler/HscMain - GHC - Trac, http://tinyurl.com/2ej9w4
23:59:22 <Bourbaki> isnt there maybe a project that tries to make a haskellish syntax available in c++ via templates?
