00:00:57 <dons> ?yow
00:00:57 <lambdabot> Once upon a time, four AMPHIBIOUS HOG CALLERS attacked a family of
00:00:57 <lambdabot> DEFENSELESS, SENSITIVE COIN COLLECTORS and brought DOWN their PROPERTY
00:00:57 <lambdabot> VALUES!!
00:01:17 <araujo> hola dons
00:02:12 <araujo> anyone knows a project hosting repo with darcs support?
00:02:18 * araujo is urgently needing one
00:03:00 <JohnMeacham> vegai: it is fun. I used to do kernel work on solaris among other things.
00:03:41 <dons> araujo: hmm. its a very good question.
00:04:04 <dons> we're setting up a community server for just this, but syntaxninja who's organising is off getting married, i think.
00:04:23 <araujo> dons, i have a haskell.org account ... but i need to upload non-haskell code .. so , i guess that's a problem
00:04:30 <araujo> :-(
00:06:32 <ivanm> heh
00:06:37 <dons> ah ok.
00:12:03 <ramesh> hi, i am a haskell newbie
00:12:17 <ramesh> this is not a homework assignment
00:12:31 <ramesh> i need help with some code that i am trying
00:12:46 <ramesh> nf1 x 	|even x = div x 2
00:12:46 <ramesh> 	|otherwise = 3 *x + 1
00:12:46 <ramesh> cf1 n 1 = n
00:12:46 <ramesh> cf1 n x = cf1 (n+1) (nf1 x)
00:12:46 <ramesh> countseq1 x = cf1 0 x
00:12:48 <ramesh> maxi1 y [] = y
00:12:50 <ramesh> maxi1 y (x:xs) = maxi1 (max x y) xs
00:12:52 <ramesh> maxi x = maxi1 (-99999) x
00:12:54 <ramesh> maxseq x = maxi ([countseq1 y | y<-[1..x]])
00:13:02 <ramesh> this is for the collatz sequence
00:13:17 <ramesh> i am trying to find the maximum number of iterations from [1..x]
00:13:31 <ramesh> on winhugs this says "c stack overflow" after 3000 or so numbers
00:13:31 <dons> please don't paste code in channel
00:13:36 <dons> can you instead paste to hpaste.org ?
00:13:36 <ramesh> i am sorry
00:13:40 <dons> ?paste <-- this url
00:13:40 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:13:45 <Cale> Anyone happen to know if there's a name for monoids M such that for any w in M, there are finitely many pairs (u,v) of elements of M such that uv = w?
00:14:25 <hpaste>  Ramesh pasted "collatz sequence" at http://hpaste.org/204
00:15:05 <dons> the stack overflow is likely due to cf1 n x = cf1 (n+1) (nf1 x)
00:16:13 <Cale> I'd write that using an iterate, a takeWhile and length.
00:16:20 <opqdonut> #include "prn_dps_if.h"
00:16:23 <opqdonut> wopps
00:16:25 <opqdonut> sorry
00:17:16 <ramesh> i need help on why the program does not run after 3000 numbers and gets stack overflow
00:17:20 <ramesh> the same program does very well when i do not use maxi
00:17:24 <ramesh> and instead use sort and take the head
00:25:14 <shapr> Cale: trijective? :-)
00:25:23 <Cale> hehe :)
00:26:06 <Lemmih> ramesh2: fc1 n x = n `seq` cf1 (n+1) (nf1 x)
00:26:07 <shapr> Wow, trijective is a real term?
00:26:17 <Lemmih> Hi shapr.
00:26:37 <shapr> hej Lemmih, god morgon. Hur gÃ¥r det?
00:26:51 <opqdonut> :)
00:26:54 <Cale> shapr: I've never heard it before, but google turns up results :)
00:26:54 <Lemmih> Myget bra.
00:27:37 <shapr> Amazingly, erights.org uses the term twice.
00:28:55 <Cale> Here's a physics paper which has: "The state |Î¨ã€‰ determines a trijective or one-to-one-to-one correspondence..."
00:29:02 <Cale> http://philsci-archive.pitt.edu/archive/00001726/01/socks.pdf
00:29:35 <shapr> That sounds like a type that should be bijective.
00:29:37 <shapr> er, typo
00:29:44 <shapr> Gah, it's embarassing to typo the word typo.
00:29:57 <Cale> Except for the use of the term "one-to-one-to-one"
00:30:00 <shapr> oh
00:30:03 <shapr> I missed that part.
00:31:09 <shapr> Cale: I wish the names of those sorts of patterns were compositional. Then you could just describe the exact relationship with the name.
00:31:53 <Pseudonym> I can imagine how you might be more used to write "type" than "typo".
00:32:23 <Cale> I can imagine how you might be more used to writing "write" than "writing".
00:33:08 <Pseudonym> I noticed that just as I hit "enter", but I thought I'd not draw attention to it just in case nobody noticed.
00:33:09 <shapr> :-)
00:34:59 <johnnowak> are there any "learning to program with haskell" introductory texts available? i'm looking for something that targets non/new-programmers specifically
00:35:28 <dons> 'proogramming in haskell' is a good, new introductory text.
00:35:43 <dons> there are several others. 'the craft of functional programming' is aother good one.
00:36:06 <dons> johnnowak: see the list here: http://haskell.org/haskellwiki/Books_and_tutorials#Textbooks
00:36:10 <lambdabot> Title: Books and tutorials - HaskellWiki
00:36:40 <johnnowak> i've been tasked with designing a course for "learning programming with python"... by programming on cell phones. i'm trying to inject whatever sanity into it I can.
00:36:52 <johnnowak> thanks dons
00:37:06 <dons> cool. you could look at some of the other comp sci 101  courses that use haskell
00:37:16 <dons> http://haskell.org/haskellwiki/Books_and_tutorials#Teaching_Haskell
00:37:19 <lambdabot> Title: Books and tutorials - HaskellWiki, http://tinyurl.com/vqzky
00:37:47 <johnnowak>  the trick is that it is being taught at a design school, so the usual cs 101 approach won't work. an.. extreme effort to motivate is required. half of the students have no interest in programming at all.
00:37:51 <dons> this an (out of date) lsit of courses here, http://haskell.org/haskellwiki/Haskell_in_education
00:37:53 <lambdabot> Title: Haskell in education - HaskellWiki
00:37:57 <dons> ah hmm.
00:38:04 <dons> ok. tricky problem.
00:38:09 <johnnowak> aye.
00:38:15 <dons> might even be worth asking advice on haskell-cafe@ from some of the other techers
00:38:20 <dons> teachers. not techers ;)
00:38:38 <johnnowak> ah, I'll do that. thanks.
00:39:03 * dons `ap` bus
00:41:01 <Pseudonym> Home for me, too.
00:41:03 <Pseudonym> Nytol!
00:48:03 <Korollary> Does anyone have a link to a lambda calculus interpreter in a non-GC language?
00:53:34 <Adamant> shouldn't a Scheme implimentation in C qualify?
00:55:01 <opqdonut> :D
00:55:09 <opqdonut> except for the overkill factor, yes
00:59:54 <sieni> 1050
00:59:56 <sieni> eiku
01:21:50 <ibid> Korollary: i wrote one last year, see my blog
01:25:13 <Korollary> ibid: where's your blog?
01:27:48 <kolmodin> Korollary: this one? http://antti-juhani.kaijanaho.fi/newblog/
01:27:50 <lambdabot> Title: Antti-Juhani Kaijanaho
02:33:39 <dons> ?userrs
02:33:39 <lambdabot> Maximum users seen in #haskell: 336, currently: 300 (89.3%), active: 22 (7.3%)
02:38:45 <kolmodin> dons: how is the book coming along? :)
02:42:07 <opqdonut> ?yarr
02:42:08 <lambdabot> Keelhaul the swabs!
02:42:13 <dons> its ticking along :-)
02:42:27 <opqdonut> what sort of book?
02:42:53 <dons> ?google real-world haskell
02:42:57 <lambdabot> http://www.realworldhaskell.org/
02:42:57 <lambdabot> Title: Real World Haskell
02:42:59 <dons> that sort :-)
02:43:23 <kolmodin> dons: good good :)
02:43:38 <kolmodin> expecting to have a chapter finished soon? :D
02:43:54 <dons> towards the end of the month, i think
02:43:59 <kolmodin> wow, neat!
02:44:10 <dons> kolmodin: you might be interested in a new course we're doing at unsw, http://www.cse.unsw.edu.au/~cs4181/schedule.html
02:44:11 <lambdabot> Title: COMP4181: Language-based Software Safety - Provisional Schedule
02:44:21 <dons> i wonder if we can get the slides online for it.
02:44:23 <opqdonut> ah that one
02:44:54 <kolmodin> dons: that looks excellent!
02:44:56 <fuzan> what's the info bar dons is using here: here:
02:44:59 <fuzan> zomg.
02:45:05 <kolmodin> and in perfect alignment with my world domination plan
02:45:05 <fuzan> l(+cnt)] [Act: 1]
02:45:08 <fuzan> [#haskell]
02:45:10 <fuzan> OMG.
02:45:24 <swiert> dons: Will you still have time to write something about xmonad for TMR?
02:45:26 <fuzan> (not . <3) copypaste
02:45:35 <kolmodin> fuzan: haha :)
02:45:38 <fuzan> http://xmonad.org/images/screen-dons-tall-status.png
02:46:03 <dons> swiert: i think so. when's the deadline?
02:46:13 <dons> i've got material for hmm, 10 pages or so, i suspect.
02:46:14 <swiert> More than a month away.
02:46:16 <swiert> End of july.
02:46:19 <dons> yeah ok.
02:46:20 <fuzan> oh, dzen.
02:46:22 <fuzan> ugh :(
02:46:24 <kolmodin> much action in haskell land these days
02:46:51 <dons> fuzan: that's dzen. its perfect for us.
02:47:17 <fuzan> no debian pkg :(
02:47:26 <dons> fuzan: also, http://www.cse.unsw.edu.au/~dons/tmp/xmonad-status-dzen-dynamic.png
02:47:28 <lambdabot> http://tinyurl.com/2g9wda
02:47:34 <dons> that's doing dynamic workspace displays
02:47:46 <dons> fuzan: oh, just build it. its a tiny C program
02:47:49 <dons> ?where dzen
02:47:49 <lambdabot> http://gotmor.googlepages.com/dzen
02:47:59 <fuzan> dons: sexy :)
02:48:28 <dons> kolmodin: yes, surely world domination is around the corner :-)
02:48:30 <osfameron> ooo, dzen page even mentions xmonad
02:48:40 <kolmodin> dons: I'm relying on it!
02:48:52 <dons> oh? it does. cool.
02:49:07 * malcolmw is adding pattern guards to nhc98
02:49:09 <dons> ah yes.
02:49:13 <dons> malcolmw: woot!
02:49:31 <malcolmw> turned out to be much easier to get round the type checker than I thought it would be
02:49:36 <dons> malcolmw: xmonad in nhc98 can't be far away now.
02:49:57 <dons> we need the X11 package. i wonder if nhc can grok that
02:50:12 <malcolmw> the yhc guys will need to suck my patches across so that Catch can use pat guards
02:50:27 <dons> yeah
02:50:31 <malcolmw> dons: I suspect X11 requires callbacks
02:50:46 <dons> oh hmm. yes. (i think in the xerror function -- its tricky)
02:50:52 <malcolmw> dons: as in, "foreign import wrapper"
02:50:58 <fuzan> dons: what's the status.sh referred to in the README?
02:51:19 <dons> fuzan: some shell script that prints a string to stdout
02:51:40 <dons> malcolmw: oh, hmm.
02:51:41 <dons> $ find . -name '*.hsc' -exec grep wrapper {} \;
02:51:41 <dons> $ pwd
02:51:41 <dons> /home/dons/ghc/libraries/X11
02:52:03 <dons> fuzan: there's a couple of tutes on using dzen on xmonad.org
02:52:09 <fuzan> kk
03:02:16 <gleb> hello everyone. i have a bit philosophical, perhaps a bit silly question, but anyway. is there some mnemonic, some intuitive way to read types of higher-rank polymorphic functions? consider for instance runST :: (forall s. ST s a) -> a. I understand that runST has this type because STRef's aren't allowed to escape. i've read and kind of understood the explanation of how things like 'runST (newSTRef True)' are rejected by typechecker because 
03:02:16 <gleb> my point is that usually obe doesn't have to understand how typechecker works to understand the type. Types like (id :: a->a) or (put :: (MonadState s m) => s -> m ()) make a lot more sense because every type variable actually denotes something, and in the type (ST s a) it doesn't. thanks.
03:02:34 <fuzan> hmm, what's the issue with SizeHints in the current darcs build of xmonad?
03:02:47 <fuzan> it's not finding it.
03:03:11 <fuzan> nor is it referenced anywhere in the code. Did someone forget to add a file? :)
03:03:42 <dons> fuzan: update X11-extras first
03:03:49 <fuzan> ah.
03:03:55 <dons> gleb: hmm. good question.
03:04:36 <gleb> dons: i'm glad you think it is
03:04:38 <dons> gleb: so its all in the scoping of the type variables, but i don't have an intuitive way to read that.
03:04:54 <dons> gleb: i'd even be inclined to ask on haskell-cafe@ to see if someone has a nice intuition
03:05:22 <gleb>  dons: ok, i'll post my question to cafe
03:05:56 * mnislaih reads that as "for any ST action where s is free"
03:06:51 <dons> that's a good way to think about it, mnislaih
03:06:55 <mnislaih> one needs to know that STRefs bind s to something in order to make any sense
03:07:33 <malcolmw> the (forall s . ST s a) reads to me that the state parameter given to ST is internal, because nothing can influence what the s is from outside
03:07:59 <malcolmw> it must "work", for any given 's'
03:08:24 <malcolmw> (and therefore we don't give an 's' at all!)
03:09:14 <swiert> gleb: I sometimes find it helpful to think about how it all boils down to System F - where types are instantiated explicitly.
03:09:27 <swiert> I'm not sure if that helps you though.
03:09:35 <mnislaih> malcolmw the "it must work for any given s" intuition works for me with dimensions, i.e. for matrix computations where dimensions appear in the type. But it doesn't help me with ST
03:10:21 <dons> :t Data.Generics.gunfold
03:10:32 <lambdabot> forall (c :: * -> *) a. (Data.Generics.Basics.Data a) => (forall b r. (Data.Generics.Basics.Data b) => c (b -> r) -> c r) -> (forall r. r -> c r) -> Data.Generics.Basics.Constr -> c a
03:10:58 <dons> now, which scheme helps to decode that best?
03:11:20 <dons> :t Data.Generics.gfoldl
03:11:22 <lambdabot> forall (c :: * -> *) a. (Data.Generics.Basics.Data a) => (forall a1 b. (Data.Generics.Basics.Data a1) => c (a1 -> b) -> a1 -> c b) -> (forall g. g -> c g) -> a -> c a
03:11:33 <gleb> swiert, mnislaih, malcolmw: thanks for sharing your intuitions, but they really require knowing 'how typechecker works', what i've mentioned in my question
03:12:18 <dons> gleb: yes, that *really* helps. writing a little type checker for Hindley-Milner is a very useful learning exercise
03:12:32 <malcolmw> gleb: I don't agree, I think of it entirely in terms of predicate calculus
03:13:07 <dons> hey kfish
03:14:17 <ibid> Korollary: http://antti-juhani.kaijanaho.fi/newblog/archives/107
03:14:20 <lambdabot> Title: Antti-Juhani Kaijanaho » Blog Archive » Graph reduction
03:14:21 <malcolmw> gleb: the type signature is stating a logical property, involving constraints on the domains and ranges of values, and quantification is a natural part of the specification for more complicated properties
03:15:04 <gleb> ok, let's put it another way. consider a haskell newbie that just mastered State monad and trying to understand ST monad. they appear somewhat analogous in their purpose, ST being more rich and sophisticated. types State s a and ST s a look similar. how would you explain to a newbie, what s means in the type of ST s a?
03:16:26 <malcolmw> gleb: in State s a, the user provides the state.  In ST s a, the system provides it (opaquely), so you are not allowed to assume anything about what it looks like
03:17:34 <mnislaih> gleb: I don't see another way apart from teaching gim about rank-2 types
03:17:38 <malcolmw> and indeed, there are only very few things you can do with the state in ST s a, namely reading and writing STRefs - that's all
03:17:43 <mnislaih> him/her
03:19:40 <gleb> malcolmw: i like your point about logical properties. afaik variables in predicate calculus range over some domain, and statements like forall x . Human(x) -> Mortal(x) can be translated to natural language
03:19:41 <kfish> hi dons
03:20:10 <gleb> the question is what is the domain of 's' in ST s a?
03:20:24 <malcolmw> gleb: exactly
03:21:11 <malcolmw> gleb: but in the type system, domains are explicit, e.g. Int, and variables are polymorphic, meaning "give me some domain, any domain"
03:21:56 <malcolmw> gleb: so a type variable has the domain of "all possible types"
03:23:52 <malcolmw> gleb: at runtime, of course, the type variable must be instantiated to some particular types,
03:24:28 <malcolmw> (conceptually, anyway, since there are no type representations at runtime, to a first approximation)
03:24:34 <mnislaih> maybe it helps to think that in the type ST s a, s models the state thread, and every time you make a new STRef, it becomes tied to a given state thread. So one can say that the domain of s is the domain of  state threads
03:25:43 <gleb> mnislaih: thanks! that is nice intuition
03:25:56 <malcolmw> I would say that it is more about "who gets to instantiate this type variable".  For normal polymorphic variables, it is the caller of the function that instantiates them to some particular type
03:26:43 <malcolmw> but in the (forall s .  ....) bracket, it prevents the caller from being able to see the variable s, so it cannot be instantiated by the calling context
03:26:51 <gleb> malcolmw: but as far as i understand, 's' is never instantiated
03:27:14 <mnislaih> gleb that's what malcolmw is saying. In fact, the domain of s is any type. But it helps to think that it is the state thread
03:27:33 <malcolmw> gleb: oh, it _is_ instantiated, but internally and opaquely by the implementation
03:27:55 <Saizan> gleb: it's instantiated by runST effectively, it's fixed to some particular "s" so that you can't mix it with a different one
03:28:15 <A-oXiDe> what does the dot notation do in haskell?
03:28:30 <gleb> guys, thanks a lot. this discussion was really enlightening
03:28:32 <mnislaih> malcolmw: that would be only to RealWorld in IO. Saizan, for that matter, it is never instantiated. It is kept free
03:28:55 <swiert> A-oXiDe: A dot can mean a few different things. Do you have an example?
03:29:07 <Saizan> ?src (.)
03:29:08 <lambdabot> (.) f g x = f (g x)
03:29:21 <Saizan> A-oXiDe: it's just function composition
03:29:26 <A-oXiDe> (map f) . (filter p)
03:29:27 <A-oXiDe> ah
03:29:49 <A-oXiDe> so basically applying map to the filtered p
03:29:55 <Saizan> that means \xs -> map f (filter p xs)
03:30:08 <A-oXiDe> cheers
03:30:45 <Saizan> A-oXiDe: and it's a juast a defined operator, not something embedded in the language
03:30:55 <opqdonut> ?free (.)
03:30:55 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
03:31:01 <opqdonut> hrmm?
03:31:27 <opqdonut> ?scheck (f.g) x == f (g x)
03:31:31 <lambdabot>  Not in scope: `x'
03:31:33 <Saizan> ?free comp :: (b -> c) -> (a -> b) -> a -> c
03:31:33 <lambdabot> g . k = p . f => f . q = f1 . h => g . comp k q = comp p f1 . h
03:31:43 <opqdonut> ?scheck (f.g) == \x -> f (g x)
03:31:43 <lambdabot>  Not in scope: `g'
03:31:49 <opqdonut> oh ffs
03:35:53 * gleb saved IRC log. /me thinks this IRC channel is full of nice, extremely smart people
03:38:15 <ihope> Egad, generic zippers? They sound fun :-)
03:40:16 <ari> gleb: Don't forget http://tunes.org/~nef/logs/haskell/
03:40:17 <lambdabot> Title: Index of /~nef/logs/haskell
03:41:52 <gleb> ari: thanks i know about it, but i'd loke to keep this particular discussion locally
03:42:58 <gleb> s/loke/like/
03:55:40 <dons> gleb: perhaps, (not sure if this applied), you could polish up the question/answers on this topic into a blog post?
03:55:54 <dons> it would make a rather good reference for this question. perhaps a wiki page.
03:59:13 <gleb> dons: i'm planning to post this IRC log as it is in my blog actually, i've got really valuable answers. but my blog is in russian, and i doubt i can polish it appropriately for wiki because my english has a lot of room for imrpovement
04:00:13 <daniel_larsson> A wiki allows others to polish it in turn though )
04:00:31 <gleb> daniel_larsson: good point :)
04:10:07 <dons> gleb: well, either way, as long as we have a public record of it. :-) you could put the notes on your blog, and on the wiki
04:10:22 <dons> just so i can refer to it next time someone asks :-)
04:13:38 <timbod> Q: Is there any way to abstract a data type _within_ a file?
04:17:01 <Saizan> timbod: "abstract"?
04:18:29 <ibid> timbod: no
04:18:35 <timbod> If I put a type in a module (ie in a new file) and don't export it's constructors, then other modules can only access that type through the exported methods. I'm wondering if there's a way I can do that without having to move a type into a new file.
04:18:52 <ibid> timbod: no, there isn't
04:19:02 <timbod> ibid: thanks - that's a shame.
04:19:34 <timbod> I take it that ghc doesn't support multiple modules in the same file.... (haven't actually tried though).
04:19:45 <Saizan> uhm hugs has something similar with type synonims
04:20:11 <ibid> timbod: the point is that the module system is the (only) mechanism for information hiding
04:20:32 <ketti> haskell modules seems weak ^^
04:20:40 <Saizan> http://cvs.haskell.org/Hugs/pages/users_guide/restricted-synonyms.html
04:20:44 <lambdabot> http://tinyurl.com/yvr54e
04:20:54 <timbod> ibid: and each module must go in it's own file, right?
04:20:57 <Saizan> but it's not implemented in GHC afaik
04:21:08 <ibid> timbod: that's how it's usually implemented :)
04:21:24 <DRMacIver> I concur that Haskell modules seem rather weak.
04:21:47 <timbod> weak compared with what? ML/ocaml modules?
04:22:04 * ketti comes from caml...
04:23:09 <DRMacIver> timbod: Yeah. Or even OO languages (When one regards an object as a type of module, which is admittedly distorting definitions somewhat. :) ).
04:24:22 <timbod> I would have thought that a module was really closer to a C++ namespace rather than a class
04:24:30 <DRMacIver> Object != Class
04:24:37 * DRMacIver has a pet theory that taking something like ML and unifying its module system with some sort of (statically typed) prototype based OO to give a first class module system would result in something really cool.
04:25:04 <DRMacIver> And if you have higher order or first class modules they start to look a bit like objects.
04:25:37 <DRMacIver> And if you use objects like they're often done in modern enterprisey Java (or Spring, etc), they start to look a lot like modules.
04:26:12 <ketti> yes, i too think such a unification would be cool
04:26:21 <timbod> I've not used ocaml enough to grok the value of it's module system, but I've read that it's powerful and overlaps somewhat with typeclasses.
04:26:27 <mux> there's an SPJ paper about first-class modules in haskell
04:26:27 <ketti> ocaml has both modules, records, and objects...
04:26:33 <ketti> all of which should be unified
04:26:49 <DRMacIver> Cayenne unifies modules and records as I recall.
04:27:33 <gleb> dons: ok, i'll do it later today
04:27:59 <LoganCapaldo> doesn't Parsec use records to simulate first class modules?
04:28:01 <timbod> It may not be a major point, but I was sufficiently frustrated in ocaml with not having overloaded arithmetic operators that it turned me off the language.
04:28:22 <timbod> So I never got into the module system.
04:29:06 <roconnor> dependent record types!
04:29:17 <DRMacIver> I must admit I've never used ML's module system in a non-trivial way (I originally learned to program in ML, I just never got around to (ab)using the modules properly). I'm coming at this more from the OO side of things.
04:29:27 <DRMacIver> What I've seen of the ML module system really is very nice though. :)
04:30:23 <ketti> i constatly get annoyed at them not being first class though...
04:30:49 <ketti> functors etc seems like a big hack to work around that limitation too me :)
04:31:02 <DRMacIver> The proposals for Successor ML seem to be fixing that.
04:31:10 <DRMacIver> I think HamletS has first class and local modules now.
04:34:03 <ketti> cool :)
04:37:33 <Cf> does anyone have any experience with texture mapping in hopengl?
04:39:59 <LoganCapaldo> f :: Texture -> Surface -> [Texture] -> [Surface] ? ;)
04:40:41 <opqdonut> :D
04:49:18 <mdmkolbe|wor1> ihope: where did you see generic zippers?
04:49:29 <mdmkolbe|wor1> @seen ihope
04:49:29 <lambdabot> ihope is in #haskell. I last heard ihope speak 1h 11m 14s ago.
04:56:53 * LoganCapaldo waits for the snaps and buttons and velcro data structures
05:42:30 <desp> @hoogle INSTANCE_TYPEABLE0
05:42:30 <lambdabot> No matches found
05:50:40 <fasta> same (x:xs) = all (== x) xs ; same [] = True <- is this somewhere in the std. libs?
05:51:53 <LoganCapaldo> @hoogle (Eq a) => a -> Bool
05:51:53 <lambdabot> Char.isLatin1 :: a -> Bool
05:51:53 <lambdabot> Test.QuickCheck.Batch.isBottom :: a -> Bool
05:51:53 <lambdabot> Prelude.(/=) :: Eq a => a -> a -> Bool
05:52:06 <LoganCapaldo> @hoogle (Eq a) => [a] -> Bool
05:52:06 <lambdabot> Prelude.null :: [a] -> Bool
05:52:06 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
05:52:06 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
05:52:15 <LoganCapaldo> ah well
05:52:21 <LoganCapaldo> it was worth a shot
05:52:24 <dons> desp: that's a cpp macro iirc
05:52:42 <dons> so, who's up for some scary, mind bending type system extensions?
05:52:45 <fasta> dons: What macro system do you use?
05:53:05 <fasta> dons: assuming you use one...
05:53:08 <dons> fasta: hmm? i don't use macros :-
05:53:09 <dons> )
05:53:20 <TSC> fasta: How about "same = (<=1) . length . nub" ?
05:53:28 <dons> higher order functions + laziness seem to cover everything i need in real projects.
05:53:39 <TSC> It'd be slower, of course
05:53:45 <dons> anyway, for those looking for some fun type system extensions....
05:53:52 <dons>  type-indexed type classes!
05:53:53 <dons> http://hackage.haskell.org/trac/ghc/wiki/TypeFunctions/ClassFamilies
05:53:55 <fasta> TSC: it would be unacceptable slow.
05:53:56 <lambdabot> Title: TypeFunctions/ClassFamilies - GHC - Trac, http://tinyurl.com/27byjk
05:54:32 <fasta> dons: Ok, so how do you handle debugging code?
05:54:53 <fasta> dons: i.e. there is some code that's nice to have when you are debugging stuff.
05:55:04 <dons> trace usually. and ghci.
05:55:19 <dons> i've done some debugging of xmonad recently
05:55:23 <dons> that's involved printing X protocol events
05:55:42 <desp> dons: I'm trying to find out exactly what it does, but I'm failing
05:55:43 <dons> the internal data structures don't seem to ever need debugging of any depth. hmm.
05:55:50 <fasta> dons: I also use an ASSERT macro, s.t. I don't need to type assert (boolean) return value, but simply ASSERT(boolean)
05:56:01 <dons> index assert
05:56:04 <dons> ?index assert
05:56:05 <lambdabot> Control.Exception, Test.HUnit.Base, Test.HUnit
05:56:12 <dons> sometimes I do use Control.Exception.assert
05:56:18 <dons> ?type Control.Exception.assert
05:56:21 <lambdabot> forall a. Bool -> a -> a
05:56:28 <dons> oh, i used cpp for strictness once
05:56:31 <fasta> dons: I find it very annoying to do things repeatedly the same.
05:56:32 <dons> before bang patterns.
05:56:50 <dons> #define STRICT1(f) f a | a `seq` False = undefined
05:56:58 <dons> STRICT1(loop)
05:57:03 <dons> loop x = ... loop (x+1)
05:57:08 <fasta> dons: that's Oleg's trick
05:57:11 <TSC> Ah, doesn't fps have macros like that?
05:57:13 <dons> right. + macros
05:57:25 <dons> but bang patterns are better, so that's all redundant now
05:57:30 <fasta> TSC: There's Template Haskell
05:57:48 <dons> yeah, but you don't use TH for small syntactic hacks.
05:57:49 <fasta> TSC: but it's not documented well, imho. Others disagree
05:58:10 <dons> for syntactic hacks that are a bit beyond the language (like STRICT1) , cpp would be used. but most of those uses are doable in normal haskell.
05:58:16 <dons> for some full AST hacking, TH gets used
05:58:35 <dons> so, hmm, hard to think of a real use of cpp in '07 ghc haskell
05:58:47 <dons> i've not used it recently.
05:58:47 <dons>  
05:59:00 <fasta> dons: you don't think my ASSERT macro counts?
05:59:07 <fasta> dons: that's trivial
05:59:11 <fasta> dons: but useful
05:59:48 <fasta> dons: another useful case is a visualisation MACRO that basically uses bang-patterns to show intermediate data structures via graphviz.
06:00:00 <dons> oh, that sounds nifty
06:00:20 <fasta> dons: without those it would be next to impossible to debug what I am doing.
06:00:30 <fasta> dons: it wouldn't be practical and I would lose interest.
06:00:30 <dons> a Writer monad?
06:00:59 <dons> yeah, i'm sure there must be good uses for macros. printing structures seems like almost TH-worthy
06:01:00 <fasta> dons: it uses IO
06:01:14 <dons> WriterT IO a ?
06:01:24 <fasta> dons: that might be possible
06:01:51 <fasta> dons: you may write an article about that :)
06:02:06 <LoganCapaldo> isn't do basically a macro?
06:02:16 <dons> in a way, yes.
06:02:20 <mdmkolbe|work> maybe 'error ("error at " ++ __FILE__ ++ " " ++ __LINE__)'
06:02:24 <dons> its sugar for programmable, rebindable semicolons .
06:02:35 <dons> so you can insert logging statements into your semicolons, for example :-)
06:02:56 <fasta> dons: the problem would be to show an ST structure in ST code via graphviz
06:03:01 <Botje> "shh, the semicolons have ears!"
06:03:18 <fasta> dons: I solved that problem with CPP
06:03:29 <fasta> dons: and unsafePerformIO of course
06:03:29 <dons> fasta: sounds scary you'd use macros for that. there must be a good monadic framework. you're right though -- it would make a good article
06:04:03 <fasta> dons: I am using the assertions like in a design by contract way
06:04:18 <fasta> dons: I have become a firm believer of that way.
06:04:26 <dons> null (PS _ _ l) = assert (l >= 0) $ l <= 0
06:04:33 <fasta> dons: (although, I never used an actual design by contract system)
06:04:37 <dons> is how I use the assert function.
06:04:46 <dons> so i wouldn't use cpp for that, i think.
06:05:12 <dons> ah, and maybe i'm using QuickCheck these days for a lot of the 'contractual obligations' code has to fufil
06:05:16 <fasta> I use the macro to reduce nesting.
06:05:31 <fasta> (in monadic code)
06:05:43 <dons> fasta: it would be interesting to tease out the precise times when it is best to use cpp, or when it should be done in-language
06:05:57 <dons> do you feel up to starting a discussoin on haskell-cafe@ ?
06:06:07 <dons> i'd be intrigued to see what solutions to avoid cpp people had
06:06:43 <fasta> dons: I think it's a libraries problem.
06:06:52 <dons> and a techniques-in-general problem.
06:07:06 <fasta> dons: there should be a library which given any structure visualises it with some graph drawing package.
06:07:06 <dons> (i don't think oleg reads libraries@ ;)
06:07:17 <dons> fasta: oh hmm.
06:07:24 <fasta> dons: I don't know any programming language that does this.
06:07:51 <fasta> dons: I know there is something for C with a GPL license.
06:07:51 <dons> hmm. i think there was a data structure design and visualisation test bench a few years ago
06:07:55 <dons> 'Auburn' iirc?
06:08:43 <fasta> dons: that's benchmarking functional data structures
06:09:00 <dons> http://www.cs.york.ac.uk/fp/auburn/
06:09:02 <lambdabot> Title: The Auburn Home Page
06:09:19 <dons> yup.
06:09:32 <dons> seems like a similar problem to profiling or tracing.
06:09:50 <fasta> dons: I wonder whether big corporations have those tools I am talking about.
06:09:53 <dons> i wonder if you could annotate/extend/munge the new HPC code coverage, or the existing profiling, frameworks?
06:10:00 <fasta> dons: I honestly don't think so.
06:10:22 <fasta> dons: since in that case probably there would be someone selling the functionality.
06:10:31 <fasta> dons: to universities for example.
06:10:44 <dons> sounds interesting. if you come up with a non-cpp technique -- it's likely worth a paper :-)
06:10:45 <desp> @hoogle alignment
06:10:46 <lambdabot> Foreign.Storable.alignment :: Storable a => a -> Int
06:10:46 <lambdabot> System.Win32.Info.sM_MENUDROPALIGNMENT :: SMSetting
06:10:53 <fasta> dons: and since I never saw anyone mentioning something like that, I would guess it doesn't exists.
06:11:01 <dons> fasta: a graph tracing monad would be very nice :-)
06:11:41 <fasta> dons: such a library doesn't need to be efficient since the input sizes are limited.
06:12:01 <fasta> dons: I.e. I won't draw graphs of size 1000 on my screen.
06:12:05 <fasta> dons: it would lose all meaning.
06:12:23 <opqdonut> density diagrams or something like that might be tho
06:12:26 <fasta> dons: unless I have a very big screen ;)
06:12:33 <opqdonut> or drawing only well-enough connected nodes
06:12:48 <opqdonut> or drawing the lst or something like that
06:12:53 <desp> @hoogle unpackBits
06:12:53 <lambdabot> No matches found
06:13:00 <fasta> opqdonut: We are talking only about data structure visualisation.
06:13:01 <opqdonut> but those are doable with graph transformations
06:13:11 <opqdonut> fasta: okay
06:13:37 <dons> ?time dons
06:13:40 <lambdabot> Local time for dons is Thu Jun  7 23:13:09 2007
06:13:42 <dons> night all :-)
06:13:45 <opqdonut> :)
06:13:47 <opqdonut> nite
06:14:16 <fasta> night
06:14:46 <mux> oyasuminasai, dons-san
06:17:46 <ivanm> I'm trying to install shim, but cabal can't find Distribution.Verbosity
06:17:52 <ivanm> where can I get it from?
06:18:41 <desp> hm.
06:18:49 <desp> what's the difference between foldl and foldl'?
06:19:34 <ivanm> foldl' uses seq
06:19:36 <ivanm> @src foldl
06:19:36 <lambdabot> foldl f z xs = lgo z xs
06:19:36 <lambdabot>     where lgo z []     =  z
06:19:36 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
06:19:39 <ivanm> @src foldl'
06:19:41 <lambdabot> foldl' f a []     = a
06:19:45 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
06:19:46 <ari> desp: The short answer is that if you need a left fold, you should always use foldl'.
06:20:37 <opqdonut> :D
06:20:53 <ivanm> anyone here got shim installed and working?
06:25:47 <dr_strangelove> is there a vi mode for ghci?
06:25:57 <dr_strangelove> like in bash?
06:26:09 <quicksilver> it links to readline
06:26:14 <quicksilver> which is the same thing that bash uses
06:26:24 <quicksilver> so presumably the functionailty exists
06:26:28 <dr_strangelove> in bash I can "set -o vi"
06:26:32 <quicksilver> not idea how to trigger it
06:26:43 <dr_strangelove> hm
06:27:04 <ivanm> quicksilver: any idea where I can find the Distribution.Verbosity module?
06:27:22 <quicksilver> not a clue
06:27:27 <ivanm> hmmm
06:27:27 <quicksilver> ask my good friend google :)
06:27:32 <ivanm> heh, I did
06:27:40 <quicksilver> I'd not even  heard of it until 2 minutes ago
06:27:46 <quicksilver> when I read teh scrollback and saw your earlier question
06:28:12 <dr_strangelove> quicksilver: good tip with readline, I thought it was a bash feature. Vi mode: "M-C-j"
06:28:13 <Botje> dr_strangelove: man readline, look for emacs
06:28:15 <ivanm> all I found was mailing lists
06:28:19 <ivanm> quicksilver: fair enough
06:28:20 <Botje> you need to add "set editing-mode vi" to your .inputrc
06:28:24 <ivanm> @seen igloo
06:28:24 <lambdabot> igloo is in #happs, #haskell-overflow, #haskell, #ghc and #darcs. I last heard igloo speak 14h 13m 22s ago.
06:28:48 <ivanm> well, I found one mailing list with igloo's name on it mentioning it...
06:29:30 <quicksilver> try addressing him then. he might notice a highlight
06:29:50 <ivanm> @ask igloo I'm trying to install shim, but it can't find the module Distribution.Verbosity.  I found a mailing list listing with your name on it mentioning it... any idea where I can get it from?
06:29:50 <lambdabot> Consider it noted.
06:29:57 <ivanm> quicksilver: one step ahead of you ;-)
06:29:58 <ivanm> thanks anyway
06:30:00 <desp> ari: how about the long answer?
06:30:09 <dr_strangelove> is it possible to trigger recompilation and reloading in ghci of a file on filesystem-write?
06:30:12 <ivanm> I figured you might know, since you help me with so many of my queries ;-)
06:30:25 <Igloo> ivanm: It's in the Cabal HEAD
06:30:37 <ivanm> ahhh
06:31:01 <desp> ari: foldl looks tail-recursive, but I'm not sure if I understand what seq does
06:31:05 <desp> @src seq
06:31:05 <lambdabot> Source not found. Where did you learn to type?
06:31:16 <ivanm> Igloo: as in the testing version of cabal?
06:31:30 <Igloo> development, yes
06:31:31 <quicksilver> desp: tail recursion only makes sense with strict things
06:31:33 <bauchus> hello haskell wizards... Toubles on Debian/Stable: libghc6-filepath-dev is installed but couldn't be found by cabal :-( does anybody know this problem?
06:31:43 <desp> quicksilver: ahh.
06:31:48 <quicksilver> desp: tail recursion and laziness don't really make sesne together
06:31:56 <desp> right. I keep forgetting about laziness.
06:31:59 <quicksilver> your "laziness" just builds up an enormous thunk
06:32:14 <ivanm> thanks, Igloo ... /me might put off trying out shim then
06:32:47 <quicksilver> in many notable cases GHC notices the strictness and does the right thiing anyway
06:34:17 <quicksilver> (i.e. turns foldl into foldl', effectgively)
06:34:28 <desp> thank you
06:34:40 <quicksilver> desp: a `seq` b  means "reduce a to WHNF, before return the value of b"
06:35:06 <quicksilver> this is only a sensible thing to do if you also use the name 'a' somewhere else, otherwise the work was wasted
06:36:19 <fasta> quicksilver: If you insert the seqs in the right places, tail recursion does work, right?
06:36:43 <fasta> quicksilver: i.e. runs in constant space
06:38:20 <bauchus> what does this means: Could not find module `System.FilePath':
06:38:20 <bauchus>       it is a member of package FilePath-0.11, which is hidden
06:38:43 <Lemmih> bauchus: You probably need to add FilePath to the build-depends in your cabal file.
06:38:46 <dr_strangelove> can I print the function documentation from ghci?
06:38:59 <dr_strangelove> like   :docs List.length
06:39:21 <Lemmih> dr_strangelove: No.
06:39:36 <quicksilver> fasta: yes
06:40:19 <dr_strangelove> hm, would be a nice feature ...
06:40:24 <quicksilver> fasta: the interesting thing about tail recursion in a call-by-need setting is that it must inherently 'unroll' the entire recursion at once
06:40:30 <quicksilver> fast	because, clearly, a tail recursion can't produce constructores as it goes
06:41:33 <bauchus> Lemmih: Thanks, it has to be FilePath instead of filepath in my cabal file. Has the package name FilePath changed to filepath (ghc 6.6 vs 6.6.1)?
06:41:36 <quicksilver> fasta: not that this is n ecessarily a bad thing. just something to think about.
06:42:02 <fasta> quicksilver: but reverse doesn't use seq, so some patterns do already work
06:42:06 <fasta> @src reverse
06:42:07 <lambdabot> reverse = foldl (flip (:)) []
06:42:38 <fasta> Hmm, so, reverse is not tail recursive
06:42:44 <fasta> I thought it was.
06:43:24 <LoganCapaldo> fasta: how would you write a tail recursive reverse?
06:43:30 <Lemmih> bauchus: Has it ever been 'filepath'. I can't seem to remember.
06:43:39 <LoganCapaldo> (unless you just want to use an explicit stack?)
06:43:41 <opqdonut> LoganCapaldo: by using an accumulator
06:43:42 <opqdonut> yep
06:44:02 <LoganCapaldo> opqdonut: does that really gain you anything though?
06:44:09 <Saizan> isn't [] the initial accumulator in the def of reverse?
06:44:13 <opqdonut> LoganCapaldo: no :)
06:44:26 <LoganCapaldo> opqdonut: ok, just checking :)
06:44:46 <fasta> opqdonut: Doesn't it buy you a constant factor?
06:44:54 <opqdonut> fasta: i couldn't say
06:45:10 <fasta> I think it does, but ideally GHC would be so good that it isn't needed.
06:45:11 <opqdonut> with laziness bot versions are quite the same my intuition would say
06:46:39 <Saizan> reverse xs = reverse' [] xs where reverse' a (x:xs) = reverse' (x:a) xs; reverse' a [] = a <-- inlining foldl, but here you don't need seq because the cons can't be reduced further i think
06:46:51 <Saizan> instead of some arithmetical operations
06:47:24 <LoganCapaldo> > let reverse = rev xs [] ; rev [] xs = xs; rev (x:xs) ys = rev xs (x:ys) in reverse [1,2,3]
06:47:32 <lambdabot>   Not in scope: `xs'
06:47:34 <bringert> any c2hs developers here?
06:47:52 <LoganCapaldo> > let reverse xs = rev xs [] ; rev [] xs = xs; rev (x:xs) ys = rev xs (x:ys) in reverse [1,2,3]
06:47:53 <lambdabot>  [3,2,1]
06:47:58 <bringert> dcoutts: you here?
06:49:03 <Saizan> i.e. reducing (x:a) to WHNF will only give you x:a
07:01:48 <quicksilver> @src foldl
07:01:48 <lambdabot> foldl f z xs = lgo z xs
07:01:48 <lambdabot>     where lgo z []     =  z
07:01:48 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
07:02:13 <quicksilver> surely reverse is tail recursive because foldl is tail recursive?
07:03:24 <LoganCapaldo> quicksilver: methinks you are correct
07:09:18 <drigz> why are sum and minimum implemented with non-strict foldl?
07:10:19 <Saizan> ?src sum
07:10:20 <lambdabot> sum = foldl (+) 0
07:11:12 <Saizan> (i wonder if it's so even in GHC)
07:11:56 <DRMacIver> I thought lambdabot used GHC's libraries.
07:12:18 <ari> In ghc'-s Data.List minimum is rewritten to strictMinimum for [Int] and [Integer]... I don't know why that's not done for other types
07:12:20 <Saizan> lambdabot uses what dons putted in :)
07:12:37 <Saizan> ah right, rules
07:12:52 <Saizan> well <= could be non-strict for some types
07:12:54 <drigz> from ghci, minimum [1..1000000] causes a stack overflow
07:12:57 <Saizan> as well as +
07:13:19 <sjanssen> drigz: ghci doesn't try to optimize your code at all
07:13:31 <sjanssen> and the strictMinimum rules only fire with -O
07:13:59 <drigz> sjanssen: ok. Saizan's explanation seems to make sense then
07:14:25 <drigz> thanks
07:15:55 <fasta> Uhm, please don't tell me groupBy is strict...
07:16:04 <DRMacIver> GHC's rewrite rules are a seriously cool feature. :)
07:16:26 <Saizan> fasta: do you have an example?
07:16:50 <fasta> Saizan: no, it's just a hypothesis over my program.
07:17:10 <fasta> Saizan: I will need to debug it to see whether it really is groupBy
07:17:16 <Saizan> > take 3 $ groupBy [1,1,2,2,3,3,3,4,undefined]
07:17:23 <lambdabot>  Couldn't match expected type `a -> a -> Bool'
07:17:29 <Saizan> > take 3 $ groupBy (==) [1,1,2,2,3,3,3,4,undefined]
07:17:30 <lambdabot>  [[1,1],[2,2],[3,3,3]]
07:17:36 <Saizan> > take 3 $ groupBy (==) [1,1,2,2,3,3,3,undefined]
07:17:38 <lambdabot>  Undefined
07:17:45 <fasta> Ok, so groupBy isn't.
07:18:05 <fasta> If it wasn't for the -xc option I would have a problem now
07:18:17 <fasta> Uhm, I mean profiles.
07:18:32 <LoganCapaldo> @strict groupBy
07:18:32 <lambdabot> Unknown command, try @list
07:18:47 <LoganCapaldo> A man can dream
07:21:28 <fasta> Ok, this sucks... I don't get a profile...
07:21:58 <fasta> Never mind :)
07:24:38 <drigz> I've written an instance of Num for [a] with (+) = (++), and if I do print ([1..5] + [6..10]), it works
07:24:49 <drigz> but print (sum [[1..5], [6..10]]) doesn't
07:24:57 <drigz> it complains that i haven't written fromInteger
07:25:35 <int-e> drigz: sure, because sum starts to build the result from 0
07:25:36 <sjanssen> drigz: sum has to create 0 somehow
07:25:42 <int-e> drigz: which is fromInteger 0
07:25:48 <drigz> ah, thanks
07:26:23 <drigz> yes, that makes sense
07:26:24 <LoganCapaldo> fromInteger n = [1..n] ?
07:27:35 <LoganCapaldo> actually for [a] it would have to be fromInteger n = replicate n undefined
07:27:48 <int-e> drigz: needless to say you shouldn't try making [a] an instance of Num
07:27:50 <LoganCapaldo> woudn't it?
07:28:13 <Lemmih> fromInteger n = [fromInteger n], no?
07:28:28 <drigz> int-e: i'm just experimenting, it's not for actual use
07:28:33 <LoganCapaldo> Lemmih: I'm assuming that since + is ++, zero should be []
07:28:49 <int-e> Lemmih: that works for polynomials.
07:29:01 <int-e> Lemmih: but then (+) is not (++).
07:31:53 <Saizan> ?type ([], [[]], [[],[[]]])
07:31:55 <lambdabot> forall a a1 a2. ([a], [[a1]], [[[a2]]])
07:34:44 <mrchebas> @hoogle Int
07:34:44 <lambdabot> Data.Int :: module
07:34:44 <lambdabot> Prelude.Int :: data Int
07:34:44 <lambdabot> Text.Read.Int :: Integer -> Lexeme
07:34:44 <mrchebas> mmm, I wanted stuff that has "Int" in the type, not stuff that has it in the name.
07:34:44 <LoganCapaldo> @hoogle a -> Int
07:34:44 <int-e> @hoogle a -> Int
07:34:44 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:34:44 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:34:44 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:34:44 <lambdabot> Data.Map.findIndex :: Ord k => k -> Map k a -> Int
07:34:44 <lambdabot> Prelude.exponent :: RealFloat a => a -> Int
07:34:44 <lambdabot> Prelude.floatDigits :: RealFloat a => a -> Int
07:34:44 <LoganCapaldo> @hoogle Int -> a
07:34:44 <lambdabot> Data.Graph.Inductive.Example.starM :: GraphM m gr => Int -> m (gr () ())
07:34:44 <lambdabot> Data.Graph.Inductive.Example.ucycleM :: GraphM m gr => Int -> m (gr () ())
07:34:44 <lambdabot> Prelude.(!!) :: [a] -> Int -> a
07:34:44 <mrchebas> only Int, and no function, how to do it?
07:34:44 <int-e> mrchebas: 0, 1, 2, 3, ...
07:34:46 <int-e> @type 0
07:34:48 <lambdabot> forall t. (Num t) => t
07:34:52 <int-e> @type 0 :: Int
07:34:54 <lambdabot> Int :: Int
07:35:01 * int-e smacks lambdabot
07:35:31 <LoganCapaldo> string munging is not lb strong suite apparently
07:35:38 <mrchebas> it seems you cannot say "give me all things that are of type Int"
07:36:08 <LoganCapaldo> is there really anything besides literals that has type Int?
07:36:15 <int-e> why would you give names to Int constants?
07:36:40 <int-e> (except for internal constants in libraries which don't get exported ...)
07:36:40 <Saizan> > [minBound .. maxBound] :: [Int]
07:36:42 <lambdabot>  [-2147483648,-2147483647,-2147483646,-2147483645,-2147483644,-2147483643,-21...
07:37:06 <mrchebas> replace Int by some other type, you might still want to find out some useful constants
07:37:47 <LoganCapaldo> Saizan: minBound has type (Bounded a) => a and you know it
07:38:11 <Saizan> LoganCapaldo: "it seems you cannot say "give me all things that are of type Int""
07:38:13 <roconnor> > [minBound `asType` 0..maxBound]
07:38:13 <lambdabot>   Not in scope: `asType'
07:38:19 <LoganCapaldo> Saizan: hehehhee
07:38:20 <roconnor> > [minBound `astype` 0..maxBound]
07:38:21 <LoganCapaldo> sorry
07:38:21 <lambdabot>   Not in scope: `astype'
07:38:29 <roconnor> @ho astype
07:38:29 <Saizan> asTypeOF
07:38:29 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show v wn yow
07:38:30 <LoganCapaldo> Saizan: you sir surpass me in cleverness
07:38:35 <roconnor> @hoogle astype
07:38:35 <lambdabot> Prelude.asTypeOf :: a -> a -> a
07:38:38 <int-e> @hoogle IO String
07:38:38 <lambdabot> Prelude.getContents :: IO String
07:38:39 <lambdabot> Prelude.getLine :: IO String
07:38:39 <lambdabot> System.getProgName :: IO String
07:38:39 <mux> > [minBound `asTypeOf` 0..maxBound]
07:38:40 <lambdabot>  Add a type signature
07:38:42 <roconnor> > [minBound `asTypeOf` 0..maxBound]
07:38:43 <lambdabot>  Add a type signature
07:39:05 <int-e> 0 is polymorphic.
07:39:25 <Saizan> and it can't default to Integer, since Integer is not Bounded
07:39:25 <mrchebas> Saizan: i should have been clearer: "give me all identifiers that have type Int"
07:39:27 <roconnor> where's defaulting when you need it
07:39:31 <roconnor> oh
07:39:33 <roconnor> right
07:39:42 <LoganCapaldo> mrchebas: I don't think there are any though is the point
07:40:15 <Saizan> mrchebas: why do you need identifiers?
07:40:47 <Saizan> ah, like defined constants?
07:40:56 <mrchebas> LoganCapaldo, suppose you defined some compass datatype and you want to know the literals you use for it
07:41:09 <mrchebas> because it is abstract and you cannot use constructors
07:41:11 <int-e> IO actions aside I can't think of monomorphic constants.
07:41:12 <Saizan> you'll better search for reasonable names for those constants
07:41:12 <int-e> @type pi
07:41:14 <lambdabot> forall a. (Floating a) => a
07:41:29 <LoganCapaldo> mrchebas: sure. but then it works
07:41:37 <LoganCapaldo> as demonstrated by the search for IO String
07:42:03 <LoganCapaldo> you weren't seeing the kind of results you expected because nothing :: Int exists, not because it can't do it
07:42:10 <mrchebas> @hoogle String
07:42:10 <lambdabot> Foreign.C.String :: module
07:42:10 <lambdabot> Prelude.String :: type String
07:42:10 <lambdabot> Text.Read.String :: String -> Lexeme
07:42:22 <mrchebas> @hoogle FilePath
07:42:22 <lambdabot> Distribution.Compat.FilePath :: module
07:42:22 <lambdabot> Prelude.FilePath :: type FilePath
07:42:22 <lambdabot> Distribution.Compat.FilePath.breakFilePath :: FilePath -> [String]
07:42:39 <mrchebas> hoogle just assumes you want a name
07:42:53 <LoganCapaldo> mrchebas: what constant valued FilePath would there be?
07:42:54 <mrchebas> that matches your query when you type a token
07:42:56 <Saizan> also, lambdabot doesn't give all of hoogle output
07:42:59 <LoganCapaldo> @hoogle IO FilePath
07:42:59 <lambdabot> Directory.getCurrentDirectory :: IO FilePath
07:42:59 <lambdabot> System.Directory.getHomeDirectory :: IO FilePath
07:42:59 <lambdabot> System.Directory.getTemporaryDirectory :: IO FilePath
07:43:35 <mrchebas> LoganCapaldo, all I am saying is that I (that is a colleague) would have a use for finding constants for a given type
07:43:39 <mrchebas> and hoogle doesn't allow it
07:43:49 <LoganCapaldo> I think hoogle does allow it
07:43:52 <LoganCapaldo> I just did it
07:44:00 <mrchebas> nothing fundamental of course, fix the parsing and it would work
07:44:08 <LoganCapaldo> there jsut are no String constants or FilePath constants to be found
07:44:20 <int-e> @hoogle IntSet
07:44:21 <lambdabot> Data.IntSet :: module
07:44:21 <lambdabot> Data.IntSet.IntSet :: data IntSet
07:44:27 <int-e> @type Data.IntSet.empty
07:44:29 <lambdabot> Data.IntSet.IntSet
07:44:43 <mrchebas> int-e: indeed
07:44:58 <mux> @hoogle Floating a => a
07:44:59 <lambdabot> Prelude.pi :: Floating a => a
07:44:59 <lambdabot> Prelude.undefined :: a
07:44:59 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
07:45:00 <LoganCapaldo> mrchebas: so this whole time you couldn't come up with that example? :)
07:45:41 <Saizan> ?seen ndm
07:45:41 <lambdabot> I saw ndm leaving #happs, #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 22h 14m 25s ago, and .
07:45:44 <mrchebas> LoganCapaldo: it's rather clear from the web interface :) , just see what is highlighted
08:00:19 <A-oXiDe> hi, im a little confused what currying is to be precise? Can anyone help me possibly?
08:00:19 <quicksilver> A-oXiDe: currynig is when you consider a function of two arguments to be a function of one argument which returns a function
08:00:40 <quicksilver> A-oXiDe: in haskell notation, a -> (b -> c) instead of (a,b) -> c
08:01:50 <LoganCapaldo> @type curry
08:01:52 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
08:02:29 <A-oXiDe> im confused at what the need is for it?
08:02:38 <schme> A-oXiDe: http://en.wikipedia.org/wiki/Currying
08:02:39 <lambdabot> Title: Currying - Wikipedia, the free encyclopedia
08:02:43 <quicksilver> A-oXiDe: it is convenient for a variety of reasons
08:02:43 <Cf> when you write a -> b -> c it's the same as a -> (b -> c)
08:02:44 <A-oXiDe> cheers
08:03:02 <quicksilver> A-oXiDe: at the level of implementation, it means you don't need to distinguish between functions of one argument and functiosn of more
08:03:08 <quicksilver> A-oXiDe: all functions take exactly one argument
08:04:13 <LoganCapaldo> A-oXiDe: makes it easier to partially apply functions as well
08:04:13 <quicksilver> A-oXiDe: that can make implementation much easier
08:04:13 <byorgey> LoganCapaldo: darnit, I was almost finished typing that =)
08:04:13 <quicksilver> A-oXiDe: at the level of programmer use, it allows you to partially apply function
08:04:13 <quicksilver> A-oXiDe: which is a very useful thing
08:04:13 <LoganCapaldo> ((+) 2) vs. (\x -> (+) (x, 2))
08:04:13 <quicksilver> [But you can perfectly well partially apply uncurried functions, it's just that you need an explicit lambda)
08:04:47 <LoganCapaldo> @src curry
08:04:47 <lambdabot> curry f x y = f (x, y)
08:05:05 <A-oXiDe> ahk i think i get it, im gonna read this wiki article
08:08:14 <fasta> There are also uses in less toy problems.
08:08:14 <Igloo> shapr: If you install haddock 0.8-2 and cd /usr/share/doc/ghc6-doc/html/libraries && /usr/lib/ghc6-doc/gen_contents_index then your haddock docs should work properly
08:08:14 <fasta> Something I use often is writing a generic version of something and then the actual functions I use are partial applications of that.
08:08:14 <LoganCapaldo> And if you want to get really bizzare about it you can construct pairs from curried functions
08:10:01 <jao> Hi. What are the recommended (if any) Cocoa Haskell bindings?
08:10:44 <quicksilver> fasta: absolutely, and that's a great technique. It doesn't *fundamentally* depend on currying though; it's just convenient.
08:10:54 <LoganCapaldo> > let pair = \a b g -> g a b; fst = \a b -> a; snd = \a b -> b; z = pair 2 3 in z fst + z snd
08:10:56 <lambdabot>  5
08:11:03 <quicksilver> fasta: you could easily write f(a,b,c,d,e,f,g) = ... ; g (d,g) = f (0,0,0,d,0,0,g)
08:11:26 <quicksilver> LoganCapaldo: a.k.a. CPS pairs :)
08:12:47 <fasta> quicksilver: true
08:13:13 <Saizan> LoganCapaldo: heh, and fst == true, snd == false == 0 ? :)
08:13:29 <fasta> quicksilver: I liked the remark of someone on Haskell Cafe: about *programming* in Haskell and programming in *Haskell*
08:13:34 <LoganCapaldo> Saizan: yes I suppose :)
08:15:27 <fasta> How would a test solution look like where I can name tests (ideally autogenerated from the name of the function in the source file), also provides random testing like QuickCheck, and points me to the exact test case of where something went wrong?
08:15:38 <fasta> Does something like that already exists?
08:16:04 <fasta> It seems QuickCheck and HUnit both still are a bit toys in that respect.
08:16:11 <fasta> I.e. it's not a full solution.
08:16:25 <quicksilver> I object to the way you use the word 'toy', once again :)
08:16:39 <quicksilver> but I think you're right that they aren't full solutions to that
08:16:43 <fasta> I know quickcheck has a "script", but it's Hugs only and makes all kinds of assumptions.
08:16:46 <quicksilver> doesn't sound hard to build something up around them though
08:17:07 <fasta> quicksilver: no, that's true, but then I am programming in *Haskell* ;)
08:17:27 <fasta> I want a pony.
08:17:28 <quicksilver> I breifly discussed with JaffaCake the notion of having 'properties' stored in your haddock doc
08:17:41 <quicksilver> and a way of extracting and running them
08:17:49 <quicksilver> he'd like that, but no packaged solution exists
08:17:54 <quicksilver> ndm has something along those lines apparently
08:17:58 <quicksilver> (doesn't he always?)
08:18:10 <fasta> quicksilver: I don't really like that ;)
08:23:08 <Cark> any parsec guru around here ?
08:23:16 <Cark> hum though a simple user might suffice
08:24:05 <Saizan> Cark: fellf ree to ask
08:24:09 <Saizan> *feel
08:24:22 <Cark> i'd like the expression : "manyTill (noneOf "\\?*<\":>/") $ (try parseExtention)" not to consume the "(try parseExtention)" part
08:24:52 <SamB_XP_> @hoogle followedBy
08:24:56 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
08:25:16 <Cark> ahyes makes sense ...i'll try this
08:25:19 <SamB_XP_> Cark: try "many (noneOf "
08:25:22 <SamB_XP_> arg
08:25:32 <SamB_XP_> damn \ not where it should be
08:26:03 <fasta> quicksilver: do you know what "label" does in quickCheck?
08:26:13 <SamB_XP_> Cark: try "many (noneOf "\\?*>\":>/" `notFollowedBy parseExtention)" ;-)
08:26:24 <SamB_XP_> or.no.
08:26:30 <SamB_XP_> not quite...
08:26:43 <fasta> QC is a toy too, because its documentation is zero outside the webpage.
08:26:45 <SamB_XP_> use maukes's << combinator, which is probably ill named...
08:27:08 <SamB_XP_> p << q = do x <- p; q; return x
08:27:13 <SamB_XP_> er.
08:27:19 <SamB_XP_> mauke's
08:27:21 * SamB_XP_ silly
08:27:54 <Cark> there you lost me ... i'm a newbie haskeller =P
08:28:11 <Cark> i'll play around with notfollowedby
08:28:39 <SamB_XP_> okay, throw out all the code I suggested then
08:29:02 <Saizan> i think manyTill (noneOf "\\?*<\":>/") $ lookAhead (try parseExtention)   should work
08:31:41 <Cark> @hoogle <<
08:31:41 <lambdabot> Text.Html.(<<) :: HTML a => (Html -> b) -> a -> b
08:31:42 <lambdabot> Control.Arrow.(<<<) :: Arrow a => a c d -> a b c -> a b d
08:31:42 <lambdabot> Control.Arrow.(<<^) :: Arrow a => a c d -> (b -> c) -> a b d
08:31:54 <Cark> thanks you both
08:33:14 <Saizan> > many
08:33:15 <lambdabot>  Add a type signature
08:34:03 <LoganCapaldo> hmm
08:34:10 <byorgey> fasta: 'label' in QC is mostly a helper function used by classify and collect
08:34:20 <LoganCapaldo> seems like the type checker doesn't like recursive functions on my church encoded lists
08:34:37 <LoganCapaldo> ah well
08:35:09 <fasta> byorgey: ok, and is there a way to say to quickcheck: when this function fails, say:"function <this function> failed"?
08:35:27 <fasta> HUnit can do that, though.
08:35:51 <byorgey> fasta: I don't think so, since quickcheck really only includes facilities for testing one function at a time
08:36:11 <byorgey> fasta: if you want to test multiple functions and say which one failed you need to add another layer on top of it
08:36:19 <byorgey> fasta: I've run into the same issue =P
08:36:43 <fasta> byorgey: and already fixed it?
08:37:23 <byorgey> fasta: no, but I did get some advice yesterday from others here... hold on...
08:38:00 <LoganCapaldo> @index fix
08:38:00 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
08:38:11 <byorgey> fasta: there's this, from lispy: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
08:38:13 <lambdabot> Title: dagit.o » Blog Archive » Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
08:38:23 <LoganCapaldo> @src fix
08:38:24 <lambdabot> fix f = let x = f x in x
08:38:39 <byorgey> fasta: and of course there's the script I think you mentioned, which I couldn't get to work since it assumes Hugs
08:39:45 * SamB_XP_ thinks lookAhead.try is redundant
08:40:37 <fasta> byorgey: lispy is looking in the right way, but he is not distributing anything.
08:41:22 <byorgey> fasta: right, you just have to copy'n'paste the code from the blog...
08:41:45 <byorgey> fasta: I haven't actually tried it yet
08:42:26 <byorgey> fasta: it seems like there is a real need here for some kind of meta-package which provides facilities for automatically detecting and running QC tests
08:43:05 <byorgey> fasta: I'd write it, but I'm not sure that I'm quite at the required level of Haskell hackery yet
08:44:22 <fasta> byorgey: I am sure I am capable of writing it, but I wonder about the economics.
08:44:35 <byorgey> fasta: economics?
08:46:05 <fasta> byorgey: yes, suppose I spend 3 months of my life on it. Doing that for "nothing" isn't a smart move, unless I am sure I get quality software in return. Something like that doesn't exists except in a form of money.
08:46:52 <fasta> byorgey: By 3 months I mean a solution that's "really great", not something with lots of cases where it's not good.
08:47:36 <fasta> byorgey: or do you think of that otherwise?
08:48:59 <byorgey> fasta: I also like to "do things right", but surely for something like this it would be worth just spending a few days on it, even if what you come up with isn't perfect?  the point for me would not be to make money but to contribute something to the Haskell community.
08:49:16 <fasta> byorgey: that's just the issue.
08:49:23 <fasta> byorgey: mediocrity.
08:49:37 <fasta> That's the reason why everyone is not fully productive.
08:49:50 <Saizan> SamB_XP_: try is to get infinite lookahead, lookAhead is to not alter the parser state on success
08:50:28 <fasta> For example: this is a nice library: http://homepages.nildram.co.uk/~ahey/HLibs/Data.Tree.AVL/
08:50:38 <fasta> (by Adrian Hey)
08:50:55 <fasta> I never used it, but I am sure it took a lot of work to get right.
08:51:02 <SamB_XP_> Saizan: try's point is to retain the parser state in case of failure...
08:51:17 <SamB_XP_> (non-immediate failure)
08:51:22 <fasta> Those are the things that make a programming language valuable (libraries/tools).
08:51:43 <SamB_XP_> lookahead doesn't do that?
08:51:51 <SamB_XP_> er. lookAhead
08:52:01 <Saizan> SamB_XP_: lookAhead does that even on _success_
08:52:22 <byorgey> fasta: I agree, but I think that something like a data structure library is quite different than a utility like we are discussing.
08:52:32 <desp> @hoogle Ptr a -> a
08:52:33 <lambdabot> No matches, try a more general search
08:52:34 <SamB_XP_> Saizan: your use of even implies that it does it for failure too?
08:52:37 <Saizan> s/even/only/
08:52:52 <SamB_XP_> oh.
08:52:58 <Saizan> it does also on immediate failure
08:53:06 <byorgey> fasta: with a data structure library, you better get the design right from the start, since changing it later will be very difficult.
08:53:10 <desp> hm.
08:53:21 <SamB_XP_> Saizan: immediate failure still has the state
08:53:39 <desp> how should I peek/poke a Ptr a?
08:54:05 <SamB_XP_> byorgey: what do you mean?
08:54:30 <desp> ahh, got it. wrong type signature, my bad.
08:55:19 <Saizan> ?type lookAhead
08:55:21 <lambdabot> Not in scope: `lookAhead'
08:55:23 <byorgey> SamB_XP_: I'm not exactly sure, just an intuitive sense that to be really good/useful, something like a data structure library has to be designed right, the first time, all in one shot (which can take a lot of work), whereas something like a utility to automate quickcheck testing of multiple properties can probably be added to and improved over time
08:55:45 <SamB_XP_> byorgey: what do you mean by the design?
08:57:11 <byorgey> SamB_XP_: well, I mean the intangible 'higher-order' ways that you organize things: what sort of data structures you use, what combinators/interface you provide, the way everything fits together.
08:57:24 <byorgey> SamB_XP_: sorry if I'm being vague.
08:58:10 <SamB_XP_> byorgey: generally data structure libraries don't tell you what data structure they use...
08:58:37 <SamB_XP_> (well, maybe the documentation does, but the interfaces usually don't)
08:58:47 <fasta> The biggest problem that might occur with a data structure library is that the library isn't general.
08:58:52 <fasta> Otherwise there are none.
08:58:56 <hpaste>  (anonymous) pasted "hgl stuff" at http://hpaste.org/206
08:58:58 <byorgey> SamB_XP_: well, that's true.  But the underlying data structure is still important in terms of efficiency, etc.
08:59:20 <fasta> A purely functional datastructure might be completely useless.
08:59:29 <SamB_XP_> fasta: hmm?
08:59:35 <jamii> Hello. Having terrible trouble with hgl - could someone take a peek at the code for me?
08:59:38 <fasta> (that's what I have encountered with FingerTrees)
08:59:59 <SamB_XP_> fasta: are they bad for performance?
09:00:22 <fasta> SamB_XP_: no mutation makes some things impossible to make efficient.
09:00:24 <byorgey> well, perhaps I'm wrong about the distinction between different sorts of libraries... but I still think things worth doing are worth doing, even if you don't have time to do it perfectly -- at least it could provide a basis for the next person to improve upon.
09:00:35 <desp> er
09:00:38 <desp> "`sizeOf' is not a (visible) method of class `Storable'"
09:00:46 <fasta> afk
09:00:56 <desp> @hoogle sizeOf
09:00:57 <lambdabot> Foreign.Storable.sizeOf :: Storable a => a -> Int
09:01:40 <desp> ah, not imported.
09:03:29 <jamii> Meh, I'll come back later
09:04:59 <byorgey> jamii: sorry, I'd look at it but I don't know anything about hgl...
09:05:48 <jamii> Thanks - http://hpaste.org/206
09:06:00 <jamii> test1 and test2 both work as expected
09:06:21 <jamii> test3 and go, which should do the same as the first two, bring up a blank window and then segfault
09:06:40 <jamii> the difference seems to be the use of sequence_ but I cant see why that makes a difference
09:07:35 <gh_> hello
09:07:57 <gh_> is it possible to compile a haskell program as non-lazy ?
09:08:32 <gh_> i want to do that to debug a program .. and Hat doesn't work with Control.Monad.State / ST
09:09:08 <Igloo> No
09:09:16 <dmhouse> No, nonstrict semantics are absolutely core to Haskell.
09:09:58 <gh_> ok
09:10:23 <gh_> so, are there other tools like Hat that work with any module ?
09:10:35 <byorgey> jamii: I have no idea what those functions do, but is it important to run 'getWindowTick w' before the first 'drawInWindow' action?
09:10:55 <byorgey> jamii: because intersperse wouldn't put a 'getWindowTick' before the first element of the list
09:11:11 <byorgey> > intersperse '.' "test"
09:11:17 <lambdabot>  "t.e.s.t"
09:11:30 <malcolmw> gh_: there's HOOD, which is just a library, and allows you to observe intermediate data structures and/or function applications
09:12:58 <jamii> getWindowTick just blocks, in this case for 30 secs
09:13:23 <jamii> It still segfaults if the getWindowTick is taken out entirely
09:13:32 <jamii> *30 ms
09:13:36 <gh_> malcolmw, the problem is that it's hard to see where my effor comes from
09:13:40 <gh_> *error
09:14:20 <gh_> is HOOD more interesting than Debug.Trace ?
09:14:56 <malcolmw> gh_: HOOD allows you to animate the creation of the data-structure
09:15:06 <jamii> byorgey: This is copied from the original code - hang on and I'll give a simpler demo
09:15:27 <malcolmw> gh_: ghci has recently acquired some gdb-style breakpoint debugging
09:15:36 <byorgey> jamii: hmm, then I don't know... it seems like they should be equivalent, assuming the hgl graphics monad obeys the monad laws...
09:16:21 <jamii> Thats what I thought. Its incredibly confusing. I might post it to the maintainer if no-one else can spot the issue.
09:19:30 <glguy> ?docs System.Time
09:19:30 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Time.html
09:21:22 <desp> peek p = do { foo <- peek (castPtr p :: Ptr Foo) ; ... }
09:21:36 <desp> p :: Ptr Bar
09:21:44 <desp> this doesn't seem to work
09:21:55 <jamii> byorgey: Actually that whole section is in the IO monad. Which makes things even more confusing. It looks like the problem lies in the hgl library somwhere.
09:22:04 <desp> in other words, I can't get the type inference to work the way I'd like it to
09:22:09 <desp> can someone help?
09:22:48 <sjanssen> desp: p isn't in scope at that point
09:22:58 <desp> sjanssen: yes, yes. yes.
09:23:09 <desp> that wasn't part of the code :)
09:23:14 <sjanssen> oh :)
09:23:38 <sjanssen> the code looks right to me
09:24:07 <sjanssen> that binds foo :: Foo, that's what you want?
09:24:17 <desp> yes.
09:24:38 <desp> I'll paste the whole bit, one moment.
09:24:44 <desp> got to isolate it.
09:34:32 <fasta> SamB_XP_: Maybe Oleg's zipper works with n-hole contexts efficiently, though (which is what you need to get rid of ST).
09:36:07 <desp> sjanssen: could you take a look at http://pastie.textmate.org/68615 ?
09:36:09 <lambdabot> Title: #68615 - Pastie
09:36:43 <desp> I commented out the hsc2hs stuff just in case
09:39:22 <sjanssen> desp: you're binding the result of unpackCURLGlobalFlags, but it isn't in the IO monad
09:41:01 <SamB_XP_> .
09:41:03 <SamB_XP_> erg.
09:41:06 <sjanssen> same with packCURLGlobalFlags in poke
09:41:10 <desp> right...
09:41:28 <sjanssen> do x <- 1+1; print x -- is a type error
09:41:30 <desp> thanks, my bad.
09:41:58 <qwr> do let x = 1 + 1
09:42:22 * SamB_XP_ thinks the pic30 disassembler in microchip's libbfd port needs work...
09:42:53 <desp> got it now.
09:51:05 <desp> another question -- why the type Foo, instance of Storable, is an "Unacceptable argument type in foreign declaration"?
09:51:34 <Cark> SamB, Saizan :  manyTill (noneOf "\\?*<\":>/") $ (try $ lookAhead parseExtention) <|> (eof >> return " ")
09:51:39 <SamB_XP_> desp: the compiler isn't smart enough to use Storable for code generation
09:52:10 <desp> hrm. I thought that was the whole point of implementing Storable here. :)
09:52:52 <SamB_XP_> desp: it is for use with Ptrs
09:54:01 <desp> ah. I see what you mean. meh.
09:54:19 <SamB_XP_> desp: what are you trying to interface with?
09:54:57 <desp> cURL.
09:55:11 <desp> it's ok, I'll just do it in a less elegant way.
09:55:33 <sjanssen> hopefully curl doesn't require you to pass structs on the stack
09:55:44 <sjanssen> that's the biggest problem with FFI IMO
09:55:50 <SamB_XP_> darcs uses (or used) curl
09:56:09 <sjanssen> I believe darcs calls curl over the shell
09:56:21 <SamB_XP_> could be
09:56:40 <SamB_XP_> but I was under the impression it actually called it...
09:57:18 <SamB_XP_> @hoogle CInt
09:57:19 <lambdabot> Foreign.C.Types.CInt :: data CInt
09:57:29 <SamB_XP_> newtypes of types in that module should work
10:01:54 <slowriot> how would I convert an integer to a real? I have not been having much luck looking though the docs.
10:02:19 <emu> fromIntegral
10:03:39 <slowriot> thanks!
10:22:42 <moconnor> Does Haskell have a way to create a temporary directory?  I found a function for making a temporary file, but not a directory.
10:24:00 <Lemmih> Not in the standard library, I think.
10:24:14 <SimonRC> hmm
10:24:25 <SimonRC> Something's up with ghci...
10:25:10 <SimonRC> quoth the prelude...
10:25:20 <SimonRC> div :: a -> a -> a
10:25:22 <arcatan> nevarmore
10:25:26 <SimonRC> "integer division truncated toward negative infinity"
10:25:39 <opqdonut> ?src div
10:25:39 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
10:25:44 <opqdonut> ^_^
10:25:48 <opqdonut> ?free div
10:25:50 <lambdabot> Extra stuff at end of line in retrieved type "forall a. (Integral a) => a -> a -> a\n"
10:25:51 <SimonRC> but ghci says: -1 `div` 2    --->   0
10:25:56 <SimonRC> that IMO is wrong
10:26:13 <Lemmih> SimonRC: (-1) `div` 2
10:26:16 <opqdonut> yeah
10:26:18 <SimonRC> ah
10:26:25 <SimonRC> *COUGH*
10:26:27 <opqdonut> remember precedence :)
10:26:51 <SimonRC> thanks
10:27:06 <SimonRC> dear Haskell 2.0 people
10:27:33 <SimonRC> please add sane fixity declarations for infix div/mod/quot/rem
10:27:38 <SimonRC> love SimonRC
10:27:43 * SimonRC eats dinner
10:28:11 <dmhouse> Really, Haskell 98 is Haskell 2.0, seeing as it was previously Haskell 1.3.
10:28:43 <glguy> unless it was 1.4
10:30:13 <Jaggederest> @yow !
10:30:13 <lambdabot> I'm RELIGIOUS!!  I love a man with a HAIRPIECE!!  Equip me with MISSILES!!
10:30:37 <Jaggederest> #25 on programming reddit -> lots of people
10:30:52 <HairyDude> http://hackage.haskell.org/trac/hugs/browser gives a link error
10:50:48 <ihope> mdmkolbe|work: I think the Wikibooks page in zippers mentions generic zippers... or maybe it's the Haskell wiki page.
10:54:24 <HairyDude> hrm
10:54:25 <HairyDude> Word> :b Word
10:54:25 <HairyDude> module Word where
10:54:27 <HairyDude> something missing
11:10:26 <RyanT5000> so, i often end up having something like (Map a b, Map b a)
11:10:26 <RyanT5000> expressing a 1-to-1 mapping from some a's to some b's
11:10:26 <RyanT5000> is there something like that in the libraries?
11:10:26 <RyanT5000> or, alternatively, is there some reason i shouldn't be doing something like that?
11:10:26 <kpreid> well, I'd use a data/newtype to wrap it up to provide the invariant that the maps are actually inverses of each other
11:12:06 <hpaste>  slowriot pasted "stack overflow" at http://hpaste.org/207
11:12:59 <slowriot> could someone look at my problem?
11:13:26 <Lemmih> slowriot: 'zfunc' isn't tail recursive.
11:14:41 <slowriot> Limmih: Oh, in order for it to be tail recursive, it would have to be defined entirely in terms of itself
11:14:50 <slowriot> Limmih: So I should probably use a fold instead, huh?
11:16:53 <RyanT5000> kpreid: how come that isn't in the standard library? it seems pretty common
11:17:01 <Lemmih> slowriot: sum (map fivein [2..n]) ?
11:17:14 <slowriot> yeah, that would work
11:17:44 <kpreid> RyanT5000: Don't ask me, I didn't design it.
11:17:56 <kpreid> I'd like to know why there aren't vector and matrix operations!
11:18:02 <RyanT5000> lol yeah
11:18:20 <kpreid> that said, I've maybe once ever had a use for such a map
11:18:25 <Lemmih> slowriot: The compiler is even smart enough to remove the intermediate list.
11:19:21 <slowriot> slowriot: huh
11:19:25 <RyanT5000> kpreid: this particular context is that i'm storing a routing table: i need to be able to look up hardware address by logical address and vice versa (kind of like mac address and ip address)
11:19:29 <slowriot> Lemmih: huh
11:19:33 <slowriot> :)
11:20:44 <ihope> If you have a class Foo a b | a -> b, is there a way to make a type constructor Bar such that Foo a b => Bar a = b?
11:20:50 <Lemmih> slowriot: I'm just saying that using lists instead of hand-written recursion isn't necessarily slower.
11:21:04 <ihope> (type Bar a = Foo a b => b, by any chance?)
11:21:27 <slowriot> Lemmih: I'm still getting stack overflow
11:21:36 <sjanssen> ihope: sounds like you want associated types
11:21:38 <slowriot> it has to be able to handle 1000000000
11:21:54 <Lemmih> slowriot: Try with -O.
11:22:03 <ihope> sjanssen: how do those work?
11:22:26 <sjanssen> class Foo a where type Bar a :: *
11:22:46 <RyanT5000> when did associated types get put in?
11:22:46 <sjanssen> ihope: there's no complete implementation, though
11:22:50 <RyanT5000> oh
11:22:56 <sjanssen> ghc HEAD has a partial implementation
11:24:07 <slowriot> Lemmih: It should be able to call the function without generating any lists at all, generating only one element at a time.
11:24:17 <HairyDude> hrm... ghc's version of Graphics.SOE from Graphics.HGL exports a version of openWindowEx that has a different type than given in the book
11:26:06 <HairyDude> though it looks like you can replace drawBufferedGraphic with DoubleBuffered
11:26:41 <Lemmih> slowriot: It's 'fivesin' that's failing now.
11:27:01 <HairyDude> would be nice if it didn't use doze-specific functions too
11:27:39 <slowriot> Lemmih: what's wrong with it?
11:28:53 <hpaste>  Lemmih annotated "stack overflow" with "tail-recursive" at http://hpaste.org/207#a1
11:30:02 <slowriot> Lemmih: You just made it tail recursive?
11:30:43 <slowriot> Lemmih: Normally, I would say it's not significantly deep, but using tail recursion probably helps haskell optimize other parts of the code.
11:31:31 <desp> hrm
11:31:47 <Lemmih> slowriot: Not significantly deep?
11:31:56 <desp> "type ForeignCString = ForeignPtr CChar" -- ForeignCString is, again, an "Unacceptable argument type in foreign declaration"
11:32:10 <slowriot> well, the depth is the number of times that 5 divides the argument
11:32:30 <sjanssen> desp: you can't have ForeignPtr in a foreign decl.
11:33:08 <desp> right
11:33:10 <Lemmih> slowriot: That number is strict.
11:33:48 <slowriot> Lemmih: hmm. What does the ! in front of acc do?
11:34:22 <Lemmih> slowriot: Strictness annotation. You need GHC and -fbang-patterns for it to work.
11:34:47 <hpaste>  sjanssen annotated "stack overflow" with "one character to avoid stack o'flow" at http://hpaste.org/207#a2
11:34:53 <sjanssen> slowriot: ^^^
11:35:02 <sjanssen> mapM_ is key
11:35:05 <hpaste>  LoganCapaldo annotated "stack overflow" with "other tail reursive, not as cool as Lemmih's" at http://hpaste.org/207#a3
11:35:21 <HairyDude> getCPUTime seems to be returning units of 1e-11 seconds instead of the documented 1e-12
11:35:36 <sjanssen> slowriot: mapM holds on to the result of the IO actions -- very bad when the input is big
11:36:22 <Lemmih> sjanssen: Did you test that?
11:36:34 <Lemmih> sjanssen: Input is only one word.
11:36:52 <slowriot> sjanssen: thanks
11:37:04 <slowriot> I tested it
11:37:06 <slowriot> it doesn't work
11:37:10 <Lemmih> sjanssen: Anyhow, wouldn't that just cause lots of heap usage and not stack overflows?
11:37:45 <HairyDude> ah no, think I'm using getCPUTime wrong.
11:37:50 <sjanssen> Lemmih: mapM will cause a stack overflow
11:38:04 <sjanssen> assuming the input is big
11:38:10 <sjanssen> I guess there are other issues here :)
11:38:34 <hpaste>  augustss annotated "stack overflow" with "Less recursion" at http://hpaste.org/207#a4
11:41:00 <LoganCapaldo> augustss: clearly not paying attention :)
11:41:10 <hpaste>  augustss annotated "stack overflow" with "Less mess" at http://hpaste.org/207#a5
11:41:22 <LoganCapaldo> http://hpaste.org/207#a1
11:41:51 <SimonRC> is there a way to say that a type is an instance of show only if one of its parameter types is?
11:42:13 <augustss> yes
11:42:22 <glguy> instance Show s => Show (Magic a) where
11:42:27 <augustss> instance Show a => Show (Foo a)
11:42:29 <SimonRC> ah, silly me
11:42:30 <HairyDude> data Show a => Something a = <blah> deriving Show
11:42:45 <SimonRC> HairyDude: no
11:42:45 <LoganCapaldo> instance (Show a) => Show F a where...gives up typing at this point
11:42:46 <HairyDude> ah no, that's not going to work
11:42:55 <SimonRC> is there a way to *derive* it?
11:43:11 <augustss> SimonRC: deriving does the right thing
11:43:16 <SimonRC> huh?
11:43:17 <LoganCapaldo> data Foo a = Foo a deriving Show already works
11:43:25 <SimonRC> ah, cool
11:43:40 <HairyDude> then Foo (a -> b) doesn't have a Show instance, for example (I guess)
11:43:43 <SimonRC> I just expected that it would ask me to add (Show a) =>
11:44:35 <malsyned> I have a function I want to write that I feel like I've seen discussed here before, or possibly someplace else.  It's the problem of inserting spaces in the proper place in a camel-case string.
11:45:06 <malsyned> or at least, splitting a camel-case string into words.
11:45:46 <augustss> concatMap (\ c -> if isUpper c then [' ', toLower c] else [c])
11:46:59 <augustss> > concatMap (\ c -> if isUpper c then [' ', toLower c] else [c]) "helloCruelWorld"
11:47:00 <lambdabot>  "hello cruel world"
11:47:02 <slowriot> hmm
11:47:45 <malsyned> >concatMap (\c -> if isUpper c then [' ', toLower c] else [c]) "TestingCamelwithTLAs"
11:48:14 <malsyned> > concatMap (\c -> if isUpper c then [' ', toLower c] else [c]) "TestingCamelwithTLAs"
11:48:15 <lambdabot>  " testing camelwith t l as"
11:48:49 <malsyned> well, I messed up by not starting 'with' with a capital, but the rest illustrates the problem with that solution.
11:48:54 <augustss> well, i don't know what you consider the proper places
11:48:55 <malsyned> it doesn't take acronyms into account.
11:49:01 <malsyned> yeah.  I should have specified.
11:50:25 <olsner> @pl (\(x,y) -> char '\\' >> char x >> return y)
11:50:25 <lambdabot> uncurry ((. return) . (>>) . (char '\\' >>) . char)
11:50:36 <slowriot> any ideas on how to make zfunc faster?
11:51:05 <slowriot> I want to submit it to SPOJ, but I can't use any special compiler settings.
11:51:09 <malsyned> I want to insert spaces at number-to-nonnumber and nonnumber-to-number boundaries and before Capital lowercase sequences.
11:52:22 <augustss> slowriot: it would be faster if you didn't use brute force...
11:52:57 <sjanssen> slowriot: add {-# OPTIONS_GHC -O2 #-} to the top of the file
11:53:18 <glguy> Does SPOJ still use GHC 6.4.1
11:53:57 <slowriot> it uses 6.6.1
11:53:59 <sjanssen> nah, they use 6.6 now
11:54:05 <glguy> oh, cool
11:54:05 <augustss> malsyned: I'd just use an oldfashioned recursive function with some pattern matching then
11:54:45 <malsyned> augustss: yeah, I thought there was a function that would do what I want, but I think some clever combination of mapConcat and foldl is the best I'm going to get.
11:55:16 <glguy> ?hoogle mapConcat
11:55:20 <lambdabot> No matches found
11:55:25 <malsyned> glguy: I meant concatMap.
11:55:34 <glguy> :-p I figured as much
11:56:00 <augustss> malsyned: something with 'zipWith f str (tail str)' would let you look at pairs of characters
11:56:13 <defcons> Are the speed issues existent in haskell actually existent and are they thought to be solved in the near future?
11:56:33 <malsyned> augustss: ooh, good idea.
11:56:42 <augustss> they have been thought to be solved in the near future for a long time now
11:57:31 <defcons> I'm not trying to troll, here. I'm genuinely interested to know the developments in the speed of haskell compilers
11:57:49 <slowriot> augustss: yeah, actually, the algorithm I am using is pretty bad. I could just iterate through all powers of 5 and it would be a lot faster.
11:58:33 <slowriot> augustss: well... not ALL powers of 5
11:58:49 <slowriot> lol
11:59:29 <augustss> just the good ones :)
12:00:31 <SimonRC> My bizarre library passes my simple test with no problems
12:00:41 <augustss> defcons: i'm not sure what speed issues you are referring to.  for some things haskell performs great, for others it sucks.  did you have something special in mind?
12:02:06 <HairyDude> hrm... is it not possible to do pattern matching on records?
12:02:06 <defcons> augustss, well I read in a few places that haskell is slow
12:02:12 <defcons> and in many benchmarks I see for algorithms it is slow
12:03:19 <HairyDude> or can you just not do punning
12:03:25 <dmhouse> HairyDude: it is possible. You can either pattern match in just the same way as normal, or you can do like this: f (R { field = val }) = ..., which will bind val.
12:03:41 <augustss> defcons: but on the other hand haskell does (did?) quite well in the language shootout
12:03:48 <dmhouse> (Actually, those parentheses aren't necessary, but I think clarity suffers if they're ommitted.)
12:04:13 <HairyDude> omitting those parens looks horrible :)
12:04:23 <Modius> Got a bit of a weird request.  I am barely tutorial level on haskell; but would like to read up on a haskell book that explains elegant functional solutions to the kind of problems one would think one had to resort to imperative for.
12:04:28 <DRMacIver> augustss: Well, carefully optimised GHC did. :)
12:04:33 <defcons> http://shootout.alioth.debian.org/gp4/benchmark.php?test=regexdna&lang=all
12:04:34 <HairyDude> looks like you're passing f something called R, then something weird defined by braces
12:04:34 <lambdabot> Title: regex-dna benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/mgdtj
12:04:35 <augustss> HairyDude: there no punning in ghc. :(  I'll probably make a fix for that
12:04:40 <Modius> I'm going by a big B&N right now - what books that I'd see on the shelf would be good vs. worth avoiding?
12:05:22 <sjanssen> defcons: note that TCL wins -- that test is all about regex libs
12:05:27 <Modius> (Note - this is "likely on the shelf" not mail ordered)
12:06:04 <defcons> oh
12:06:19 <pejo> Modius, Okasaki, "purely functional data structures" is good.
12:06:29 <augustss> but likely?
12:06:43 <SimonRC> Right... now for a design question.  I have the function to take a map position and return the position to the immediate N/S/E/W.  If the user of the function tries to step off the edge of the map, should I throw an exception, or should I make the return type a Maybe type?  Note: checking for the edge of the map is non-trivial.
12:07:04 <augustss> defcon: if you look at the average of all benchmarks i think haskell does ok
12:07:28 <emu> oh no, spoj has 6.6.1
12:07:37 <emu> there goes my day
12:07:40 <SimonRC> emu: ?
12:07:44 <HairyDude> ooh, that's nice - 1e9 :: Fractional a => a (was kind of expecting Floating a => a)
12:08:15 <augustss> SimonRC: will stepping off the map ever happen under normal circumstances?  if so, use Maybe
12:08:30 <Modius> pejo :  Thanks
12:08:37 <augustss> > 1e9 :: Rational
12:08:42 <lambdabot>  1000000000%1
12:09:08 <SimonRC> ah...  there is no way for the user of the module to actually tell where the edge of the map is at all...  So "Maybe" it is.
12:09:27 <augustss> > 3.1416 :: Rational
12:09:28 <lambdabot>  3927%1250
12:09:33 <HairyDude> strange
12:09:46 <augustss> what is strange?
12:10:04 <HairyDude> *Picture> :t 1e9
12:10:04 <HairyDude> 1e9 :: (Fractional t) => t
12:10:15 <HairyDude> but then I use 1e9 where it would want an Integer, and it complains
12:10:26 <HairyDude> oh, eejit
12:10:27 <SimonRC> I have several related accessor functions that can fail if you aske them to do the impossible... is it normal to provide a "is this a Just or Nothing" wrapper for each?
12:10:28 <sjanssen> HairyDude: Integer is not a Fractional
12:10:30 <dmhouse> Because Integer is not an instance of Fractional.
12:10:30 <augustss> Integer is not Fractional
12:10:31 <HairyDude> it's 1e-9
12:10:41 <SimonRC> hmm
12:11:00 <dmhouse> HairyDude: right, because XeY, where X and Y are integers, isn't necessarily an integer.
12:11:11 <HairyDude> yes
12:11:13 <dmhouse> (Think what happens if Y is negative.)
12:12:02 <augustss> SimonRC: I say, throw an exception only in the cases where it's acceptable to terminate the program (or something similar)
12:12:03 <SimonRC> but the lexer should still be able to tell if it is an integer
12:12:10 <SimonRC> augustss: ah, ok
12:12:36 <SimonRC> that can lead to a *lot* of maybes, but do-notation makes them nice again
12:12:46 <augustss> SimonRC: or you could use exceptions in the Error monad, that's ok.
12:12:54 <dmhouse> SimonRC: should 2.0 :: Int be valid?
12:13:05 <SimonRC> dmhouse: hmm
12:13:37 <hpaste>  slowriot annotated "stack overflow" with "still not fast enough" at http://hpaste.org/207#a6
12:14:13 <SimonRC> augustss: this library is right at the bottom of the program.  I don't want to find myself threading error codes all over the place.  And the caller knows all the sensible information anyway.
12:14:28 <SimonRC> *"sensible error message information"
12:16:03 <HairyDude> gah
12:16:12 <HairyDude> doing any sort of arithmetic in haskell is a pain :(
12:16:37 <ihope> Using + is a pain?
12:16:41 <LoganCapaldo> Really?
12:16:45 <LoganCapaldo> Arithmetic?
12:17:03 <augustss> huh?
12:17:13 <geezusfreeek> more question marks???
12:17:26 <LoganCapaldo> exclamation point!
12:17:36 <augustss> > 1 + 2  -- seems smooth
12:17:38 <lambdabot>  3
12:17:43 <emu> arithmetic in haskell is easy once you realize where you need to convert concrete types to more general
12:18:13 <sjanssen> interrobangâ€½
12:18:15 <LoganCapaldo> smother than 1 + 2 vs. 1.0 +. 2.0 anyway
12:18:19 * LoganCapaldo ducks
12:18:40 <HairyDude> you have to sprinkle your code liberally with fromInteger / toInteger
12:18:47 <augustss> HairyDude: what is it that bothers you about arithmetic?
12:18:50 <HairyDude> less pedantic languages do that casting for you
12:19:26 <augustss> HairyDude: yes, you have to convert yourself.  I like that.  it means it doesn't cast behind my back
12:19:42 <emu> you should put fromInteger at the source of the concrete integers ...
12:19:51 <emu> the rest will take care of itself
12:20:04 <HairyDude> actually, I take back what I said earlier
12:20:15 <HairyDude> 1e3 should be Integral a => a, because it is an integer
12:20:45 <HairyDude> (1e-9 can still be Fractional a => a of course)
12:20:57 <geezusfreeek> that wouldn't make sense to me
12:21:25 <augustss> yes, you could argue that.  and it would be ok, but there's a consistency to the way it is now
12:22:53 <HairyDude> hmm
12:22:56 <augustss> how about  1.001e3?
12:23:18 <SimonRC> what is a good name for a function that takes in a list, and returns Just the item in the list if there is only one, and Nothing otherwise?
12:23:39 <augustss> getSingleton
12:23:52 <HairyDude> augustss: hmm... Fractional a => a, because if you use that instead of 1001 you're just asking for trouble :)
12:24:19 <malsyned> Is there a way to call a "main" function from the ghci prompt, specifying what getArgs should return?
12:24:26 <augustss> HairyDude: but it's an Integer.  that was your argument earlier :)
12:24:27 <Lemmih> @hoogle listToMaybe
12:24:27 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
12:24:39 <LoganCapaldo> malsyned: yes
12:24:39 <HairyDude> yes, I realise that :)
12:24:39 <SimonRC> Lemmih: cool
12:24:44 <Lemmih> Oh wait, that's slightly differnt.
12:24:48 <Lemmih> *different.
12:24:52 <malsyned> LoganCapaldo: I think I found it while I was waiting for the answer.  System.Environment.withArgs?
12:24:55 <LoganCapaldo> malsyned: :main arg1 arg2 ... argn
12:25:04 <LoganCapaldo> malsyned: that's another way
12:25:15 <malsyned> oh wow.  cool.  I didn't know about :main.
12:25:25 <LoganCapaldo> malsyned: me eithe runtil very recently :)
12:25:40 <geezusfreeek> maybeOne
12:25:46 <SimonRC> Lemmih: ah, no, that does the wrong thing on _:_:_
12:26:00 <SimonRC> I only permit  _:[]
12:26:14 <HairyDude> of course you could say that my using 1e3 instead of 1000 was just asking for trouble. :)
12:26:30 <augustss> i think it is :)
12:34:48 <ihope> @type 10^3
12:34:48 <lambdabot> forall t. (Num t) => t
12:34:48 <LoganCapaldo> malsyned: incidently the method I used to use was :set args arg1 arg2 ... argn
12:34:48 <malsyned> LoganCapaldo: another thing I didn't know about!  thanks!
12:34:48 <HairyDude> @type 1 * 10^3
12:34:48 <lambdabot> forall t. (Num t) => t
12:34:48 <geezusfreeek> HairyDude: if it bothers you too much you could always do something like: e l r = l * 10**r and then just 1`e`3 instead
12:34:48 <HairyDude> @type 1e3
12:34:48 <lambdabot> forall t. (Fractional t) => t
12:34:48 <HairyDude> :)
12:34:48 <geezusfreeek> err
12:34:48 <LoganCapaldo> geezusfreeek: i so had the same idea
12:34:48 <geezusfreeek> 10^r, not 10**r
12:34:48 <EvilTerran> I want to be able to display JPEGs in a graphical (either GUI or general drawing-and-blitting-to-the-screen) haskell application. what set of packages would I want for that?
12:34:48 <EvilTerran> geezusfreeek, maybe ^^ so it can do negative indices too?
12:34:57 <EvilTerran> > (10^^-1, 10^-1)
12:34:57 <lambdabot>   Not in scope: `^-'
12:34:58 <HairyDude> erm, no, the point was that it didn't
12:35:02 <EvilTerran> > (10^^ -1, 10^ -1)
12:35:03 <lambdabot>      precedence parsing error
12:35:03 <lambdabot>         cannot mix `(^)' [infixr 8] and prefix ...
12:35:07 <EvilTerran> bah.
12:35:17 <LoganCapaldo> > 10 ^^ negate 1
12:35:18 <lambdabot>  0.1
12:35:31 <geezusfreeek> the problem is that ^^ returns a fractional just like before
12:35:34 <EvilTerran> HairyDude, okay. i didn't look at the logs, i just saw people talking about the various exponential ops and threw my 2c in
12:36:09 <EvilTerran> (you'll see i arrived mid-conversation)
12:36:27 <ihope> > 10^(-1)
12:36:28 <lambdabot>  Exception: Prelude.^: negative exponent
12:36:47 <LoganCapaldo> @type (**)
12:36:49 <lambdabot> forall a. (Floating a) => a -> a -> a
12:36:54 <EvilTerran> > 1e-1
12:36:55 <lambdabot>  0.1
12:36:56 <LoganCapaldo> @type (^)
12:36:58 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:37:00 <ihope> @type (^^)
12:37:02 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:37:23 <EvilTerran> the ###e### notation supports negative indices, so i thought you might want `e` to as well...
12:37:31 <ihope> Typewise, ^ is more general than ^^, but ^^ accepts negative exponents... right?
12:38:01 <LoganCapaldo> I understand the need for ^, but doesn't ** cover everything you'd use ^^ for?
12:38:08 <LoganCapaldo> oh wiat
12:38:12 <LoganCapaldo> Nope it does
12:38:15 <LoganCapaldo> *doesn't
12:38:17 <LoganCapaldo> nvm
12:38:19 <LoganCapaldo> clever
12:38:30 <LoganCapaldo> Fractional a not Floating a
12:38:34 <Japsu> three exponentiation operators, super
12:38:36 <geezusfreeek> huh, rationals and stuff too
12:38:41 <LoganCapaldo> hooray rational operators
12:39:07 <EvilTerran> > (10 ** (-1000), 10 ^^ (-1000) :: Rational)
12:39:08 <julian> @pl flip(foldr (\x h n-> case n of {0-> ([],x:(snd (h 0)));_-> let (xs,ys) = (h (n-1)) in (x:xs,ys)})(const ([],[])))
12:39:08 <lambdabot> (line 1, column 32):
12:39:08 <lambdabot> unexpected "{"
12:39:08 <lambdabot> expecting variable, "(", operator or ")"
12:39:09 <lambdabot>  (0.0,1%100000000000000000000000000000000000000000000000000000000000000000000...
12:39:09 <ihope> Three is not enough! We must have... FIVE!
12:39:29 <EvilTerran>  /\ loss of precision with **, not with ^^
12:39:52 <geezusfreeek> couldn't this stuff be typeclassified?
12:39:52 <julian> toy
12:39:54 <LoganCapaldo> EvilTerran: yes I figuredthat out mid stream
12:40:01 <ihope> geezusfreeek: how?
12:40:07 <glguy> ^ for positive powers. ^^ for potentially negative ones. ** for potentially fractional ones :-)
12:40:19 <geezusfreeek> i dunno, i'm just asking question before i think about them enough :\
12:40:28 <EvilTerran> instance Exp a b where (^) :: a -> b -> a --?
12:40:30 <ihope> class Exponent a b where ...?
12:40:33 <ihope> ...Yes, that.
12:40:37 <EvilTerran> s/instance/class/, yes
12:40:43 <EvilTerran> brainfart :P
12:40:55 <ihope> Actually, let's trade. You take class and I'll take instance.
12:41:17 <geezusfreeek> > (4%5)^^4
12:41:18 <lambdabot>  256%625
12:41:21 <ihope> Well, as long as you have -foverlapping-instances or whatever you call it...
12:41:29 <EvilTerran> yes, quite.
12:41:30 <ihope> -fallow-overlapping-instances?
12:41:33 <dmwit> geezusfreeek: Whoa, lysdexia
12:41:39 <julian> flip(foldr (\x h n-> case n of 0-> ([],x:(snd (h 0))); _-> let (xs,ys) = (h (n-1)) in (x:xs,ys))(const ([],[])))
12:41:42 <geezusfreeek> haha
12:41:49 <ihope> Lysdexia? Wehre?
12:41:57 * glguy wonders what type negative integers have that would enable you to write this as a class
12:42:05 <julian> @pl flip(foldr (\x h n-> case n of 0-> ([],x:(snd (h 0))); _-> let (xs,ys) = (h (n-1)) in (x:xs,ys))(const ([],[])))
12:42:05 <lambdabot> (line 1, column 33):
12:42:06 <lambdabot> unexpected ">"
12:42:06 <lambdabot> expecting variable, "(", operator or ")"
12:42:13 * EvilTerran still wishes there were a way to devise a Not class
12:42:49 <EvilTerran> julian, fyi, you can use lambdabot by /msg
12:44:32 <LoganCapaldo> glguy: couldja use phantom types? data Neg; data NonNeg; data SignedInteger b = SI Integer ?
12:44:49 <ihope> EvilTerran: a Not class?
12:45:19 <ihope> Dependent types or whatever they're called would be useful here.
12:45:34 <augustss> Natural numbers would be useful
12:45:59 <EvilTerran> do something horribly cunning with fundeps to write a "class (c :: * -> *) => Not c a" with a cleverly-written instance
12:46:21 <ihope> EvilTerran: and what would this class do?
12:46:40 <EvilTerran> so that anything that isn't an instance of any given c would be an instance of (Not c) automagically
12:47:09 <ihope> * -> * doesn't look classy to me.
12:47:13 <EvilTerran> thus allowing you to write non-overlapping instances which wouldn't otherwise be possible
12:47:30 <EvilTerran> I'm not sure if that "(c :: * -> *) =>" bit was right.
12:47:47 <EvilTerran> i'm a bit shakey on kind notation and such
12:48:26 <ihope> (^) :: forall a b. (Integral b, Num a) => a -> all x: b => if x >= 0 then a else Null
12:48:28 <HairyDude> class Not (c::* -> *) a
12:48:28 <HairyDude> ?
12:48:33 <ihope> (data Null = Undefined)
12:48:48 <ihope> HairyDude: I think c here is a class.
12:49:01 <EvilTerran> yes, that was my intent, ihope
12:49:06 <ihope> % is what I... used once for class thingies.
12:49:11 <HairyDude> don't think there are such things as class variables
12:49:11 <augustss> ihope: that looks a bit weird
12:49:30 <ihope> class Not (c :: * -> %) a where ...
12:49:43 <ihope> At least, I think it's what I used for class thingies.
12:49:54 <EvilTerran> hairydude, don't monad transformers rely on class variables?
12:50:12 <EvilTerran> ...or am i just confused...
12:50:19 <ihope> I think you're confused.
12:50:24 <EvilTerran> i think i am =/
12:50:31 <ihope> They do rely on variables that are members of classes... I think.
12:51:24 <fasta> sjanssen: the compiler should optimize mapM to mapM_ in those cases.
12:51:35 <HairyDude> instance Monad m => Monad (ListT m)
12:51:38 <HairyDude> sort of thing
12:52:36 <ihope> Yeah, that's not a class variable. It's a variable that's a member of a class.
12:53:21 <HairyDude> time for tea
12:55:29 <EvilTerran> i get it
13:02:07 <titusg> Hi, I'm trying to do something really basic with a stream in IO - can anybody help?
13:02:23 <hpaste>  titusg pasted "IO Stream" at http://hpaste.org/208
13:06:11 <quicksilver> titusg: yeah, you can't do that
13:06:19 <quicksilver> titusg: IO is 'strict' in side-effects
13:06:35 <quicksilver> titusg: so that has to evaluate the entire infinite list before it returns
13:06:42 <quicksilver> you can acheive what you want with unsafePerformIO
13:06:48 <quicksilver> but it's not necessarily recommended
13:08:30 <EvilTerran> would unsafeInterleaveIO be more suitable here?
13:08:36 <EvilTerran> (and slightly safer)
13:09:14 <EvilTerran> @src unsafeInterleaveIO
13:09:15 <lambdabot> unsafeInterleaveIO (IO m) = IO ( \ s -> let r = case m s of (# _, res #) -> res in (# s, r #))
13:09:23 <EvilTerran> lambdabot, er, pardon?
13:09:37 <glguy> unsafeInterleaveIO is how readFile can be lazy
13:10:13 * EvilTerran tried to make sense of that @src... is (# , #) an unboxed tuple or something?
13:10:17 <glguy> yeah
13:10:17 <EvilTerran> *tries
13:10:51 <EvilTerran> waitaminute, you're not allowed to pattern match "IO m"!
13:11:08 <glguy> more like *you* aren't allowed to
13:11:25 <EvilTerran> for my own good, i'm sure ;]
13:11:43 <fasta> It contains the backdoor for the NSA.
13:12:47 * glguy wonders how hard it is to yank a notebook out of a notebook lock
13:13:15 <EvilTerran> unsafeInfringePrivacy?
13:14:14 <glguy> (because I was issued one at work and I just wondered how much *security* they afford)
13:14:19 <opqdonut> unsafeSex
13:19:10 <sjanssen> fasta: I don't think that's always sound
13:21:06 <EvilTerran> how does readFile ensure that the characters are read in the right order? some trick to ensure that each element is evaluated before any after it?
13:21:55 <EvilTerran> (let cs = sequence [unsafeInterleaveIO getChar)
13:22:01 <Modius> Ack - the local B&N (superstore) didn't have any Haskell books.  If ever I needed any further motivation, that was it.
13:22:04 <EvilTerran> bah, ignore that line, hit enter too soon
13:22:09 * EvilTerran goes back to thinking about it
13:22:21 <sjanssen> EvilTerran: that's not a valid defn. of readFile
13:22:31 <EvilTerran> sjanssen, <EvilTerran> bah, ignore that line, hit enter too soon
13:22:43 <sjanssen> that *will* read characters in the wrong order
13:22:49 <EvilTerran> it still annoys me how close backspace is to enter
13:23:04 <EvilTerran> i'd much rather have it on the other side so i couldn't hit the wrong one by mistake
13:23:17 * EvilTerran ponders swapping capslock and backspace over in functionality
13:24:24 <EvilTerran> sjanssen, altho you've hit the nail on the head wrt my question. the intuitive definition (sequence $ repeat $ unsafeInterleaveIO getChar) would almost certainly not work
13:24:32 <titusg> quicksilver: thanks for that...I think I'll create them one at a time...
13:24:41 * glguy turned his capslock into a control (no swap) ... hadn't considered backspace
13:25:36 <sjanssen> EvilTerran: the key is to use the IO's sequential guarantee to make sure it happens in the right order
13:25:57 <sjanssen> @src readFile
13:25:57 <lambdabot> readFile name = openFile name ReadMode >>= hGetContents
13:26:02 <sjanssen> @src hGetContents
13:26:03 <lambdabot> Source not found. I feel much better now.
13:26:14 * glguy tried that in PM earlier
13:27:00 <sjanssen> hGetContents h = do c <- getChar; cs <- unsafeInterleaveIO (hGetContents h); return (c:cs)
13:27:06 <sjanssen> plus EOF handling
13:27:14 <EvilTerran> ah, that makes sense
13:27:24 <glguy> so get contents does no buffering?
13:27:32 <sjanssen> it probably does
13:27:32 <glguy> reads one at a time?
13:27:40 <glguy> oh, that was an example definition?
13:27:47 <sjanssen> actually, I think Handle does the buffering internally
13:28:05 <sjanssen> glguy: yeah, it's just the gist of the function
13:33:01 <LoganCapaldo> @type unsafeInterleaveIO
13:33:03 <lambdabot> Not in scope: `unsafeInterleaveIO'
13:33:29 <LoganCapaldo> that's the steal the real baton for a minute one right?
13:33:46 <SamB_XP_> LoganCapaldo: what?
13:34:22 <quicksilver> titusg: there's nothing wrong with an array of [IO Sprite]
13:34:30 <quicksilver> titusg: erm, lazy list of [IO Sprite]
13:34:32 <SamB_XP_> LoganCapaldo: that's the one where it pulls a RealWorld# out of it's ass, isn't it?
13:34:38 <quicksilver> titusg: just don't "un-IO" them until you're ready
13:34:41 <SamB_XP_> well, the other one
13:35:21 <LoganCapaldo> SamB_XP_: sorry. I read something that analogized functions in IO to functions that passed around a baton (RealWord), and said that unsafePerformIO made up a fake baton, and unsafeInterleavIO temporarily stole the real one...
13:35:52 <SamB_XP_> LoganCapaldo: oh. well, you could say it does that. but I think it is a lie.
13:36:10 <SamB_XP_> because the Core seems to tell a different tale.
13:36:19 <LoganCapaldo> SamB_XP_: eh.
13:36:24 <kpreid> @google unsafePerformIO baton
13:36:27 <lambdabot> http://users.info.unicaen.fr/~karczma/matrs/Fuprog/Haskell/CoursTutoriels/AlbertLai/IO_inside.htm
13:36:28 <lambdabot> Title: IO inside - HaskellWiki
13:36:47 <LoganCapaldo> SamB_XP_: I take all these analgoies witha  gain of salt or 20 anyway :)
13:36:59 <SamB_XP_> well, maybe it doesn't though.
13:37:06 <augustss> Also, don't confuse GHCs implementation of IO with Haskell's spec.
13:37:07 * SamB_XP_ goes to check GHC.IOBase
13:37:22 <SamB_XP_> augustss: where in the Haskell spec does RealWorld appear?
13:37:31 <augustss> Nowhere
13:37:40 <augustss> IO is abstract
13:39:28 <SamB_XP_> actually... it looks like it steals an old copy of RealWorld
13:39:41 <LoganCapaldo> augustss: doesn't laziness imply (or inform maybe?) at least some aspects of the implementation though, even if its not spelled out? I recall reading a thread linked to from here about a version or YHC or NHC or something whose IO impl. was too strict
13:40:37 <augustss> I'm not sure exactly what H98 says about the laziness.
13:40:54 <SamB_XP_> LoganCapaldo: Yhc had an over-strict implementation for a bit, I believe
13:40:58 <augustss> But in, e.g., hbc IO was implemented in a totally different way.
13:41:37 <SamB_XP_> obviously, IO could have been implemented on top of the old style of I/O
13:41:53 <augustss> And that's the way iy was in hbc
13:42:15 <Modius> Loading up on Haskell/FP books (well, a few) - considering a reference - are there any that are worth having around?  Or does the spec/tools evolve such, or other reason, that it's low utility?
13:42:44 <dmead> dons: you should get some common messages going with lambdabot
13:42:56 <dmead> like when people ask for books and whatnort
13:43:05 <dmead> ?yow
13:43:06 <lambdabot> Yow!  Maybe I should have asked for my Neutron Bomb in PAISLEY --
13:43:40 <augustss> @quote
13:43:40 <lambdabot> spiffy says: [spiffy] ?quote spiffy [lambdabot] spiffy hasn't said anything memorable [spiffy] excellent
13:44:13 <augustss> wow, a multilevel quote
13:44:18 <opqdonut> meta-quote
13:44:20 <opqdonut> ?quote
13:44:20 <lambdabot> Baughn says: [I] once explained monads to a non-programmer. "And? What's so hard about that?"
13:44:30 <opqdonut> ?quote
13:44:30 <lambdabot> HamiltonRichards says: It's fair to say that functional programming requires a very different mind-set, but once you've made the "jump", programming in conventional languages feels like doing
13:44:30 <lambdabot> arithmetic in Roman numerals.
13:44:38 <opqdonut> :)
13:46:51 <SamB_XP_> I wonder if HamiltonRichards said that before or after QVICKBASIC
13:47:20 <opqdonut> ?quote
13:47:20 <lambdabot> Kahdloc says: why's it called filter and not grep? :/
13:47:23 <opqdonut> ?quote
13:47:23 <lambdabot> erg0t says: x k soy re gay
13:47:33 <opqdonut> ?quote
13:47:34 <lambdabot> awkward says: http://research.microsoft.com/~simonpj/papers/marktoberdorf/
13:47:42 * LoganCapaldo hopes Kahdloc was kidding
13:47:54 <SamB_XP_> LoganCapaldo: I don't think so
13:48:07 <tizoc[w]> erg0t: :o
13:48:20 <SamB_XP_> at least grep makes it clear that the predicate returns True for elements we want to KEEP
13:48:31 <erg0t> tizoc[w] Â¬Â¬
13:48:42 <LoganCapaldo> true
13:48:54 <SamB_XP_> sometimes I forget and think it works the other way
13:48:54 <sjanssen> SamB_XP_: it does?
13:49:00 <SamB_XP_> sjanssen: yeah.
13:49:02 <sjanssen> assuming you don't know Unix
13:49:10 <SamB_XP_> sjanssen: if it was the other way, it would be grep -v, duh
13:49:17 <opqdonut> :)
13:49:19 <LoganCapaldo> grooooan
13:49:28 <JohnMeacham> my friend is learning haskell and made this page about it: http://thisbindle.com/personal/haskell/
13:49:29 <lambdabot> Title: ThisBindle::Code::Haskell
13:49:59 <SamB_XP_> sjanssen: dude, Turbo Pascal came with a GREP program...
13:51:39 * LoganCapaldo renames filter to elementsSatisfying
13:52:31 <LoganCapaldo> > let elementsSatisfying = filter in elementsSatisfying even [1..10]
13:52:32 <lambdabot>  [2,4,6,8,10]
13:52:51 <LoganCapaldo> course now I want to rename even to eveness
13:53:08 <opqdonut> > let elementsSatisfying = filter; me = (>10) in elementsSatisfying me [1..]
13:53:10 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,...
13:53:14 <opqdonut> ^_^
13:53:32 <LoganCapaldo> or maybe I should leave even and say elementsSatisfyingPredicate even [1..10]
13:54:01 <moconnor> What's the difference between newtype and data?
13:54:08 <opqdonut> moconnor: bottom
13:54:22 <SamB_XP_> moconnor: newtype doesn't lift the field's type
13:54:36 <LoganCapaldo> And the compiler can cheat if its wants
13:54:38 <SamB_XP_> also a newtype can only have one constructor with one field
13:54:44 <emu> factoring some code out into a local function is causing a huge speed loss for me.  i thought GHC could autoinline that kinda stuff.
13:54:53 <SamB_XP_> LoganCapaldo: it isn't called cheating, it is called implementing Haskell
13:55:11 <SamB_XP_> emu: with -O?
13:55:15 <emu> -O2
13:55:19 <LoganCapaldo> SamB_XP_: I think you mean implementing Haskell the non-stupid way :)
13:55:20 <SamB_XP_> or that.
13:55:30 <augustss> emu: that's bad.  send a bug report
13:55:34 <emu> i'm trying {-# INLINE .. #-} too
13:55:58 <SamB_XP_> LoganCapaldo: the Report says that a newtype is suppose to be represented the same way as it's field's type
13:56:13 <moconnor> Would it be possible for someone to construct a small example (or point to one) that demonstrates the difference betwee newtype and data?  I'm not sure what opqdonut's comment about bottom means, nor SamB_XP_'s lifting comment.
13:56:38 <sjanssen> newtype X = X Int; data Y = Y Int
13:56:40 <SamB_XP_> moconnor: well, a newtype doesn't get its own bottom
13:57:00 <SamB_XP_> with these two types...
13:57:02 <sjanssen> seq (X _|_) a == _|_
13:57:07 <SamB_XP_> X _|_ = _|_
13:57:20 <sjanssen> seq (Y _|_) a = a
13:57:20 <SamB_XP_> Y _|_ /= _|_
13:57:21 <LoganCapaldo> SamB_XP_: aha. I still say its cheating. Institutionalized cheating, required cheating even. But cheating :)
13:57:38 <SamB_XP_> LoganCapaldo: how is it cheating?
13:57:52 <SamB_XP_> it is just a new type for the same set of values
13:58:18 <LoganCapaldo> Cause anything that lets you express more at code time with no speed loss at runtime is obviously cheating :)
13:58:28 <SamB_XP_> LoganCapaldo: that's totally stupid
13:59:05 <LoganCapaldo> My sense of humor is not appreciated in this channel (or any other I suppose ;) )
13:59:06 <SamB_XP_> anyway who said there was no speed loss?
13:59:13 <SamB_XP_> GHC is exceptionally stupid, sometimes
13:59:30 <moconnor> sjanssen: thanks
13:59:32 <emu> ooh i've narrowed it down further
13:59:32 <moconnor> SamB_XP_: thank you
13:59:40 <emu> the difference is where I use return
13:59:46 <SamB_XP_> just because something is effectively the identity function doesn't mean GHC is smart enough to remember that it doesn't cost anything
14:00:09 <emu> if I use return outside of the (if .. then .. else) then it is slow.   if I use return INSIDE of the (if .. then .. else) then it is fast.
14:00:37 <SamB_XP_> emu: that kinda makes sense in a sick way
14:01:32 <SamB_XP_> emu: you should write a mail about it, actually
14:01:40 <emu> i'm going to test with up-to-date head first
14:01:45 <SamB_XP_> fine
14:03:44 <SamB_XP_> do we have a place to keep GHC optimization tips / GHC optimizer wishes ?
14:05:58 <astrolabe> There is a request in the user guide for them to be sent in.
14:06:53 * LoganCapaldo wonders if return (if ...) is a function and if .. return ... else ... return .. is just a branch for the if part 
14:06:58 <SamB_XP_> oh. arg.
14:07:08 <ihope> LoganCapaldo: hmm?
14:07:15 <SamB_XP_> We still have robots.txt preventing google from indexing the wiki!
14:07:20 <SamB_XP_> please someone fix it...
14:07:29 <LoganCapaldo> I was wondering what code was beign generated in the two scenarios to cause the code slowup
14:07:40 <SamB_XP_> well, I mean, I bet google still crawls it
14:07:54 <SamB_XP_> because it has a bunch of URLs but no page data
14:08:59 <SamB_XP_> http://www.google.com/search?q=site:http://www.haskell.org/haskellwiki&filter=0
14:09:00 <lambdabot> Title: site:http://www.haskell.org/haskellwiki - Google Search, http://tinyurl.com/yvseua
14:10:37 <SamB_XP_> who can edit robots.txt?
14:10:54 <SamB_XP_> great. I just googled google.
14:17:27 <_roconnor> @go google
14:17:29 <lambdabot> http://www.google.com/
14:17:29 <lambdabot> Title: Google
14:18:09 <desp> arg
14:20:20 <LoganCapaldo> I've googled google to see if google was up to no good :)
14:27:26 <Vulpyne> Anyone looked at this thing: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
14:27:28 <lambdabot> Title: EmacsWiki: PrettyLambda
14:27:46 <Vulpyne> It's pretty nice, though it does a few things, like screwing up >>=.
14:29:45 <malsyned> is there an equivalent to withArgs for providing an alternate set of environment variables to an IO action?
14:30:19 <SamB_XP_> can someone please remove the robots.txt file from haskell.org?
14:30:23 <Saizan> ?docs System.Environment
14:30:24 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-Environment.html
14:30:27 <SamB_XP_> it doesn't work very well...
14:31:20 <dmhouse> SamB_XP_: best bet may be to email someone with FTP access.
14:31:37 <SamB_XP_> FTP? what is this? last decade?
14:31:58 <dmhouse> Or ssh or what have you.
14:32:58 * SamB_XP_ wants to see the logs for accesses to robots.txt by user-agents having "google" in their name
14:33:00 <Saizan> SamB_XP_: and the problem with the flooding crawler?
14:33:14 <SamB_XP_> Saizan: should be fixed with a more specific entry
14:34:05 <SamB_XP_> or perhaps the webserver can be configured to refuse it's requests, instead of depending on it to interpret robots.txt...
14:35:30 <Saizan> afaik they don't know much about it, not the user-agent, last time Igloo said he would change the robots.txt if someone has an acceptable alternative
14:36:42 <SamB_XP_> or, well, maybe the firewall could drop that IP...
14:37:55 <SamB_XP_> as a stopgap, we could at least allow google to index...
14:38:32 <Saizan> that was proposed and not accepted :\
14:38:42 <SamB_XP_> I don't like that idea myself, actually
14:39:10 <sjanssen> the naughty bot might even call itself googlebot
14:39:16 <sjanssen> I've heard they do that nowadays
14:39:32 <SamB_XP_> sjanssen: well wtf does it parse robots.txt, anyway...
14:39:44 <EvilTerran> sjanssen, a naughty bot might even ignore robots.txt
14:39:48 <navi> don't they have digital signatures nowadays? :-)
14:39:51 <sjanssen> SamB_XP_: good point
14:40:29 <SamB_XP_> could we possibly deflect it into one of those trap thingies?
14:50:32 <SamB_XP_> http://danzcontrib2.free.fr/en/pieges.php
14:50:36 <lambdabot> Title: Web Spider Traps, webbot and search engine detection, blocking a robot, allowing ...
14:53:03 <dmhouse> I've started pronouncing '>>=' as 'pipe through' recently, Ã  la Unix. It's an interesting analogy.
14:53:34 <kpreid> >>>!
14:54:01 <mehrheit> is there a simple way to convert a Char to an Int?
14:54:22 <sjanssen> @hoogle ord
14:54:22 <lambdabot> Char.ord :: Char -> Int
14:54:23 <lambdabot> Prelude.Ord :: class Eq a => Ord a
14:54:23 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
14:54:36 <Saizan> also fromEnum
14:54:38 <sjanssen> > Data.Char.ord 'a'
14:54:39 <lambdabot>  97
14:54:49 <Saizan> > fromEnum 'a'
14:54:50 <lambdabot>  97
14:54:56 <mehrheit> thank you.
14:58:45 <Saizan> how many locs an audio player with searchable playlist and queues would be?:)
14:59:21 <SamB> real googlebot seems to go by "Mozilla/5.0 (compatible; Googlebot/2.1; +http://www.google.com/bot.html)"
15:01:00 <SamB> hmm. some things seem to have been expecting that something on port 8080 would be a proxy!
15:01:06 <SamB> up to no good, I expect.
15:04:24 <EvilTerran> ...this "Mozilla/5.0 (compatible;" lark that IE caused is utterly mind-bogglingly ridiculous
15:04:44 <SamB> is it now?
15:04:51 <EvilTerran> IMO
15:04:57 <SamB> now, I don't get why bots need to use it
15:05:19 <EvilTerran> i don't know why IE felt compelled to do it in the first place
15:05:42 <SamB> at least Mozilla browsers don't need it ;-)
15:05:47 <EvilTerran> you'd expect the first thing on the line to be, oh, i dunno, the _name of the user agent_, maybe?!
15:05:47 <kpreid> there are, or were, sites which will say "Oh, you're not Netscape. Our site won't work on you. Go away."
15:05:57 <kpreid> that's the motivation for the bogosity
15:06:16 <EvilTerran> of course, these days, it's "oh, you're not internet explorer etcetc"
15:06:37 <EvilTerran> but such sites're few and far between
15:06:38 <SamB> so now what is it?
15:06:51 <EvilTerran> especially as firefox's grown in popularity in the last few years
15:07:06 <Saizan> ?google explorer destroyer
15:07:08 <lambdabot> http://www.explorerdestroyer.com/
15:07:09 <lambdabot> Title: Explorer Destroyer - Switch to Firefox, Make money from Adsense Referral
15:07:19 <SamB> Mozilla/4.0 (compatible; MSIE 6.0; compatible; StupidheadBot/-1.0
15:07:22 <SamB> ?
15:08:18 <EvilTerran> i hope not
15:08:39 <EvilTerran> but, as i said, you'd expect the actual name of the program to be the first thing
15:08:55 <SamB> why is "darcs" looking for .git files?
15:09:06 <EvilTerran> not "What I'm Pretending To Be X.Y (only kidding; What I Really Am P.Q...)"
15:10:23 <chessguy> greetings, citizens of #haskell
15:11:30 <SamB> now, real mozilla looks like...
15:11:45 <SamB> "Mozilla/5.0 (Windows; U; Windows NT 5.1; en-US; rv:1.8.1.4) Gecko/20070515 Firefox/2.0.0.4"
15:12:35 <EvilTerran> which is completely honest, altho i do wonder what "U;" means.
15:12:39 <SamB> and yahoo!'s crawler just pulled a page from my server recently...
15:12:43 <SamB> EvilTerran: Unicode?
15:12:45 <EvilTerran> well, mostly honest
15:12:45 * ptolomy hopes to hear more about Supero sometime soon. It's been a while.
15:12:51 <SamB> what do you mean "mostly"?
15:13:00 <SamB> Firefox is 100% mozilla
15:13:25 <SamB> XP really does run on NT 5.1
15:13:29 <EvilTerran> oh, wait, nm, 5.0. not 4.0.
15:13:41 <EvilTerran> i thought it was deliberately starting the same asthe IE one or sth.
15:14:16 <ptolomy> Aha. Found the slides for the Supero talk.
15:14:17 <SamB> I wonder when IE will feel ready for Mozilla/5.0 (compatible;
15:14:30 <SamB> like googlebot
15:14:41 <SamB> and Yahoo! Slurp
15:17:10 <SamB> it's kinda funny to have search indexing by all the engine's I've heard of and more, when I don't even have a webpage
15:18:57 <sorear> hello.
15:19:10 <SamB> ... including one crawler that claims to be from a stealth-mode startup...
15:20:20 <chessguy> hiya sorear
15:31:35 <sorear> @users
15:31:36 <lambdabot> Maximum users seen in #haskell: 338, currently: 316 (93.5%), active: 42 (13.3%)
15:33:17 <malsyned> how does lambdabot determine how many users are "active"?
15:33:37 <ihope> By weight, of course.
15:34:01 <ihope> If the user is under a certain weight, he/she's considered active. Otherwise, the user's considered lazy.
15:34:01 <malsyned> :P
15:34:03 <ari> @help users
15:34:03 <lambdabot> users [chan]. Report the maximum number of users seen in a channel, and active users in last 4 hours
15:34:15 <ihope> Oh, hmm.
15:34:25 * ihope attempts to convert time into weight or mass
15:34:58 <emu> @lazy emu
15:34:58 <lambdabot> Unknown command, try @list
15:34:58 <shapr> Igloo: That fixed the index, thanks!
15:37:43 <chessguy_> @seen procyon112
15:37:43 <lambdabot> I saw procyon112 leaving #gentoo-haskell, #haskell-blah and #haskell 1d 22h 18m 48s ago, and .
15:39:33 <saccade> what does "$" usually mean?
15:39:44 <Saizan> ?src ($)
15:39:44 <lambdabot> f $ x = f x
15:39:55 <emu> ($) = id
15:39:58 <saccade> terse
15:40:16 <Saizan> saccade: it mostly does nothing, but haveing the least precedence is like an open paren you don't have to close
15:40:29 <saccade> anyone care to expand on that a bid for those of us who are a bit slow to catch on?
15:40:34 <saccade> Saizan: thank you
15:40:58 <emu> > take 5 $ repeat 1
15:40:59 <lambdabot>  [1,1,1,1,1]
15:41:07 <emu> > take 5 (repeat 1)
15:41:08 <lambdabot>  [1,1,1,1,1]
15:41:15 <Saizan> > take 5 . repeat $ 1
15:41:16 <lambdabot>  [1,1,1,1,1]
15:41:23 <emu> > (take 5 . repeat) 1
15:41:24 <lambdabot>  [1,1,1,1,1]
15:41:59 <Saizan> > take 5 . repeat 1 -- this blows because is parsed as (take 5) . (repeat 1)
15:41:59 <lambdabot>  Couldn't match expected type `a -> [a1]'
15:42:25 <ddarius> :t let app = uncurry id in app -- the counit of the adjunction defining exponentials defined in terms of the mediating isomorphism.
15:42:27 <lambdabot> forall b c. (b -> c, b) -> c
15:42:55 <ddarius> :t curry id
15:42:57 <lambdabot> forall a b. a -> b -> (a, b)
15:43:16 <Igloo> shapr: Cool, thanks for confirming it
15:43:18 <emu> looks like modus ponens
15:43:47 * sorear looks at saccade's face
15:43:58 <Saizan> :t curry
15:44:00 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
15:44:07 <ddarius> emu: As it should
15:44:25 <ddarius> :t curry . uncurry
15:44:27 <lambdabot> forall a b c. (a -> b -> c) -> a -> b -> c
15:44:33 <ddarius> :t uncurry . curry
15:44:35 <lambdabot> forall a b c. ((a, b) -> c) -> (a, b) -> c
15:48:07 <saccade> sorear: beg pardon?
15:48:56 <sorear> saccade: Well, the look on it :)
15:52:12 <ihope> Is there any elegant way to express red-black trees in Haskell?
15:52:46 <Botje> ihope: i believe that's how data.map is implemented internally
15:52:49 <wolverian> yes, though it could be more elegant. there's a paper on functional red black trees.
15:52:55 <saccade> talk about a deliberately provocative question
15:52:56 <glguy> I saw I really neat implementation of them using the typesystem to enforce the constraints
15:52:58 <wolverian> (it's more elegant than imperative ones.)
15:53:41 <saccade> glguy: how does that play out in terms of runtime efficiency?
15:54:04 <glguy> I don't know, I didn't benchmark it, I just read it
15:56:06 <ihope> There are some... certain features that Haskell could use.
15:56:47 <ihope> Or maybe Haskell already has them. Hybrid constructors: act as constructors with some arguments, normal functions with others.
15:57:28 <ihope> Then there's populated constructorless types, except that I think one of the goals of Haskell is for there to be an obvious way to run a Haskell program.
15:57:29 <twanvl> how would that work?
15:58:39 <sorear> ihope: How could there be an obvious way to run a haskell program?
15:58:39 <ihope> "constructor Foo (Bar a b) (Bar c d) when a == c; Foo (Bar a b) (Bar c d) | a /= c = undefined"
15:58:42 <ihope> Something like that.
15:58:59 <sorear> ihope: there isn't even a obvious way to PARSE a haskell program! :)
15:59:10 <ihope> sorear: after parsing :-)
15:59:13 <ihope> Or something.
15:59:45 <ihope> I mean, do you really want Haskell programs to contain declarations like "this function never returns this value"?
16:00:25 <sorear> they come in really handy optimizing!
16:00:41 <ihope> "there exists a value x such that for all y, not (y `zElem` x)"
16:00:58 <ihope> abstract data ZSet
16:01:12 <ihope> zElem :: ZSet -> ZSet -> Bool
16:02:04 <ihope> Those three declarations force ZSet to be populated with a value x such that (`zElem` x) = const False
16:02:12 <ihope> Despite its not having any constructors.
16:03:55 <ihope> choose :: forall x :: Set a => if exists y (y `sElem` x) then a else Null
16:04:10 <ihope> Choice function: takes a set and returns one of its elements.
16:04:48 <ihope> abstract data Real; {- insert axioms of real numbers here -}
16:05:09 <ihope> A datatype that can hold all real numbers.
16:05:53 <ihope> Think Haskell should be extended with such things?
16:06:19 <twanvl> The datatype is not the problem, specifying a certain real is
16:06:38 <ptolomy> It's been my impression that haskell mainly gets whooped on performance in situations where destructive updates are used (unless ugly ugly things are done to allow it)..  what are the chances that I'll see a haskell compiler that recognizes when functions are just updating deep structures and handles it imperatively on the machine Before The Machines Take Over?
16:07:03 <ptolomy> (after the machines take over, I'll be too busy being fuel/a pet/dead to care about compilers, I imagine.)
16:07:41 <twanvl> ihope: no
16:07:55 <ihope> Pah, they wouldn't use humans for fuel. They'd just engineer a wonderful flammable fungus and use that for fuel.
16:08:00 <glguy> high level programming languages will become those things that humans used because their minds were not powerful enough to just write assembly
16:08:22 <ihope> Extensions like these require theorem provers to be automatically bundled with some programs.
16:09:18 <ihope> The problem isn't the datatype or specification; it's computing with these guys. Which Chaitin's constant is bigger?
16:09:30 <ptolomy> An example of what I'm talking about would be the shootout N-body benchmark.. the haskell code is the slowest of any static language, and it is quite scary.
16:09:36 <twanvl> Oh, you wanted instances of Eq and Ord?
16:10:14 <ihope> twanvl: nah, those aren't the problem.
16:10:27 <ihope> The compiler is stuck with the dirty work of actually figuring out how to compute everything.
16:10:38 <desp> I really, really, really hate the record syntax
16:10:40 <SamB> glguy: that is silly
16:10:46 <SamB> compilers need HLLs, too!
16:10:57 <glguy> they do?
16:11:01 <SamB> yes!
16:11:07 <glguy> why do they need compilers
16:11:11 <twanvl> Why do you have to compute anything? data Real = HumanReadableDefenition String
16:11:16 <glguy> compilers are just there to make up for our being human
16:12:03 <SamB> glguy: and what could we be that would make us willing and able to program in ASM for all our days?
16:13:07 <SamB> actually probably our pathetic sequential machine languages are to make up for our being human, too
16:13:39 <ihope> abstract data Real = RealZero | RealOne; (+) :: Real -> Real -> Real; (-) :: Real -> Real -> Real; (*) :: Real -> Real -> Real; (/) :: Real -> forall x. Real => if x == 0 then Null else Real; LUB :: forall s. Set Real => if not (sNull s) && not (sUniversal s) && bounded s then Real else Null
16:13:45 <ihope> And that's just the type declarations.
16:14:47 <ihope> If we want to be able to handle automatic foralls and axioms nicely, we have to capitalize every value and say that lowercase ones are automatically forall'd over the entire axiom.
16:17:01 <twanvl> You can probably do this with GADTs and undecidable instances
16:17:12 <twanvl> (And being oleg)
16:17:32 <ihope> Summon oleg, then. :-)
16:19:27 <desp> is there a convention for naming record fields?
16:19:40 <desp> well.  field labels.
16:19:46 <sorear> desp: Mock-hungarian
16:20:25 <desp> chrzaszczFoo?
16:20:25 <ihope> x + y = y + x; x + RealZero = x; (x + y) + z = x + (y + z); x * y = y * x; x * RealZero = RealZero; x * RealOne = x; x * (y * z) = (x * y) * z; x - y = x + Opposite y; x - x = RealZero; x / 0 = Undefined; x / y = x * Reciprocal y; x / x = RealOne
16:20:31 <dons> nah. though for monads unFoo is used
16:20:52 <ihope> (Though I should probably stop, since I don't think anyone's actually listening.)
16:21:15 <sorear> fooChrzaszcz usually
16:21:29 <desp> right
16:21:35 <desp> I thought to append _
16:21:40 <desp> to distinguish from local vars
16:23:14 <marcusf> Hello! A newbie with a question here: I'm working through the language piece by piece, but I'm still very early in, and right now I'm writing some routines to operate on matrices. I define a Matrix as "type Matrix a = [[a]]", but this seems unsatisfying, since I want all the sub-lists to have the same width. I can't figure out how though. Am I missing something obvious?
16:24:56 <bd_> marcusf: You could use a Data.Array (Or one of the alternate array types, like Data.Array.Diff, depending on how you're manipulating it), and use a pair of integers as an index type
16:25:17 <bd_> @hoogle Data.Array
16:25:18 <lambdabot> No matches, try a more general search
16:25:22 <bd_> @docs Data.Array
16:25:22 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array.html
16:25:33 <SamB> there are apparantly not too many situations in which Data.Array.Diff is actually a good idea
16:26:10 <bd_> it's obviously nicer to work with the whole array at once, so maybe later versions of GHC can do fun things like autoparallelization ofc :)
16:26:13 <marcusf> ah, ok. thanks, I'll look into it. Though, does list comprehension and folds and stuff work on arrays?
16:26:36 <sorear> sadly, no
16:26:49 <bd_> marcusf: Array implements Foldable, so you can fold it actually. You'll have to hide the Prelude list-only version.
16:26:49 <marcusf> damnit
16:27:06 <bd_> list comprehension, however, won't work (you can convert it to a list, if you'd like)
16:27:26 <marcusf> oh, ok.
16:27:29 <SamB> apparantly the accounting involved in DiffArrays has a rather large overhead, so that you'd need to be making really small updates of really big arrays for it to be worthwhile...
16:27:50 <bd_> marcusf: see: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html#t%3AFoldable
16:27:52 <lambdabot> http://tinyurl.com/23pc9l
16:28:16 <bd_> You'd  want to do something like import Data.Foldable (newline) import Prelude hiding (foldl, foldr, foldl1, foldr1)
16:28:33 <bd_> Data.Foldable really should be in the prelude though >.>
16:29:39 <marcusf> hm, ok. thanks alot. i'll probably give arrays a try.
16:44:02 <glguy> could someone recommend a good emacs cheat sheet?
16:44:51 <sjanssen> man vim
16:44:55 <sorear> rumor has it #emacs exists.  (rumour also has it the occupants are extremely unfriendly)
16:45:18 <sorear> C-h b
16:45:49 <TSC> The refcard that comes with Emacs should serve well
16:46:29 <TSC> It'll be in /usr/share/emacs/<version>/etc/refcard.ps, or somewhere like that
16:46:40 <sorear> well I downloaded my emacs without paying, and didn't get a refcard :)
16:46:49 <sorear> oh, an electronic one
16:47:58 <dmead> sorear, thats because their disciples of lisp living in a C world
16:48:07 <dmead> it must be :< for them
16:49:33 <SamB> dmead: :<?
16:49:43 <dmead> sadface =/
16:49:48 <dmead> :<
16:49:51 <dmead> =(
16:50:21 <SamB> sorear: don't you just love pirating free software?
16:50:47 <sorear> Yes!
16:50:52 <glguy> sorear: ^H B is more of a complete listing than a gentle reference :-)
16:55:32 <desp> sigh
16:55:42 <desp>     Couldn't match expected type `GHC.IOBase.Exception'
16:55:43 <desp>            against inferred type `IOError'
16:56:02 <desp> catch (failIfError err) (\e -> do throwIO e)
16:56:26 <desp> what gives?  throwIO is said to take Exception, catch is said to take Exception -> IO a
16:56:43 <glguy> is this a case where you need to hide Prelude's catch
16:56:51 <glguy> and import Control.Exception's
16:57:34 <desp> aha! thanks.
16:57:40 <desp> works now.
17:00:25 <chessguy> shapr, around?
17:01:25 <chessguy> @get-slap
17:01:25 <lambdabot> shapr!!
17:07:09 * int80_h is in love with haskell and #haskell
17:22:27 <sorear> I'm guessing I *don't* want to know what print(int(rand*32768),"\n") parses as in Perl?
17:22:59 <EvilTerran> why, does it not parse as expected?
17:23:22 <sorear> Nope.
17:24:25 <EvilTerran> i can see two possible problems: either int is being interpreted as a filehandle for the "print FH blah,blah" syntax, or *32768 is being interpreted as a typeglob parameter to rand()
17:24:51 <sorear> rand()*32768 fixes it
17:25:01 <sorear> typeglob eh?  See what I meant!
17:25:13 <EvilTerran> in which case it was the typeglob one. putting spaces around the * should work, too
17:25:42 <desp> hrm
17:25:54 <desp> is there a built-in function that does ioError . userError?
17:26:00 <sorear> yes
17:26:03 <sorear> @src IO fail
17:26:03 <lambdabot> fail s  = failIO s
17:26:07 <sorear> @src failIO
17:26:07 <lambdabot> failIO s = ioError (userError s)
17:26:15 <desp> thanks
17:26:25 <EvilTerran> and yes, you don't want to know about typeglobs. they were useful in perl4, before perl had proper references, and they still have their place in stuff like custom module importer scripts
17:26:27 <desp> @type failIO
17:26:29 <lambdabot> Not in scope: `failIO'
17:26:34 <EvilTerran> but in general, they're completely gratuitous
17:26:42 <desp> @hoogle failIO
17:26:42 <lambdabot> No matches found
17:26:50 * desp pokes lambdabot
17:27:05 <EvilTerran> @hoogle map
17:27:05 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
17:27:06 <lambdabot> Data.IntMap.map :: (a -> b) -> IntMap a -> IntMap b
17:27:06 <lambdabot> Data.IntSet.map :: (Int -> Int) -> IntSet -> IntSet
17:27:07 <bos> sorear: return in the IO monad evaluates its argument to WHNF, right?
17:27:08 <sorear> desp: it's a non-exported internal GHC function
17:27:14 <sorear> bos: absolutely not
17:27:18 <bos> no? ok.
17:27:25 <sorear> desp: users should use fail :: IO a
17:27:30 <sorear> String -> IO a rather
17:27:41 <EvilTerran> > return undefined >> putStrLn "blargh"
17:27:42 <lambdabot>  <IO ()>
17:27:47 <EvilTerran> > return $! undefined >> putStrLn "blargh"
17:27:48 <lambdabot>   add an instance declaration for (Show (m (IO ())))
17:27:53 <EvilTerran> > (return $! undefined) >> putStrLn "blargh"
17:27:55 <lambdabot>  <IO ()>
17:28:00 <EvilTerran> hm.
17:28:01 <sorear> EvilTerran: I actually *do* know about typeglobs, but never encountered them this painfully before :)
17:28:02 <desp> ah.
17:28:19 <Pseudonym> You need to know a bit about typeglobs if you're passing non-scalars to functions.
17:28:37 <desp> ok, that simplified things a bit.
17:28:37 <sorear> I don't pass non-scalars to functions.
17:28:41 <Pseudonym> Not much, but a bit.
17:28:43 <EvilTerran> Pseudonym, not really; afaik, you can do anything with references
17:28:50 <Pseudonym> What about file handles?
17:28:56 <Pseudonym> At least you need to know about *.
17:29:04 <sorear> file handles are EVIL!
17:29:06 <EvilTerran> you should be using scalar filehandles :P
17:29:21 <EvilTerran> ''open my $file, ">", "blargh.txt"''
17:29:32 <sorear> once I get to this level of complexity, I generally trade perl in for ghc anyhow
17:29:41 <Pseudonym> I know you should, but not all CPAN code works this way.
17:30:22 <EvilTerran> i think you can generally pass filehandles around without wrapping them in a glob, anyway. i'm not sure about that, tho', 'cos i use scalar FHs wherever i can
17:30:37 <EvilTerran> it's not encouraged, but perl will try to DWYM. as usual. :P
17:31:10 <bd_> In perl, I use IO::File for file opening, because those globs are evil. :)
17:32:27 <EvilTerran> as i said, i tend to use "open my $fh, ..."
17:33:24 <EvilTerran> but that works too
17:33:47 <EvilTerran> but anyway. this isn't #perl.
17:34:02 <EvilTerran> ...so. how's about them stream fusions?
17:35:06 <hpaste>  int80h pasted "problem in linking stage with ghc?" at http://hpaste.org/209
17:35:29 <sorear> int80_h: --make
17:35:36 <int80_h> say again?
17:35:47 <sorear> int80_h: pass --make to the compiler
17:35:51 <int80_h> sweet
17:36:42 <EvilTerran> being ghc-speak for "chase dependencies in full"
17:36:56 <int80_h> I love you :)
17:37:04 <EvilTerran> steady...
17:37:22 <int80_h> sorry this has been plagueing me for some days now
17:37:29 <int80_h> and now all is well with the world
17:38:11 <sorear> only 7 characters saved the world :)
17:38:35 <EvilTerran> sounds like LotR :P
17:39:17 <EvilTerran> 7 characters: frodo, aragorn, legolas, gandalf...
17:39:20 <chessguy> @seen dpiponi
17:39:21 <lambdabot> I saw dpiponi leaving #haskell 22d 2h 41m 11s ago, and .
17:39:39 <chessguy> @bot
17:39:39 <lambdabot> :)
17:39:42 * EvilTerran hangs his head in shame at that shockingly bad wordplay
17:39:59 <marcusf> sorry to be a pain, but another question. this time about operator overloading: I'm trying to write (*) :: Num a => Matrix a -> Matrix a -> Matrix a, but it bitches about ambiguity with the (*) in the prelude (in GHC.Num.*). I can't quite figure out why, since they're for completely different types. Does anyone have a pointer?
17:40:33 <sjanssen> marcusf: overloading in Haskell doesn't work like it does in C++
17:40:38 <desp> @botcrack
17:40:38 <lambdabot> :)
17:40:50 <sjanssen> if you want to use (*), you need to write a Num instance for your type
17:41:01 <EvilTerran> marcusf, in order to use the (*... yeah, what sjanssen said.
17:41:17 <marcusf> ahh.
17:41:29 <marcusf> I haven't quite figured out the type classes-thing quite yet. thanks :)
17:42:15 <int80_h> okay that was the first step in my mud engine project, write a tco server. which I stole from the beloved intarweb.
17:42:25 <int80_h> I mean, tcp server.
17:42:26 <EvilTerran> creating a Num class is a bit of a pain, so it may just be simpler to call your multiplication op something else.
17:42:40 <int80_h> now I ned to figure out what the heck the code is doing, exactly.
17:43:43 <chessguy> @seen dpiponi
17:43:43 <lambdabot> I saw dpiponi leaving #haskell 22d 2h 45m 34s ago, and .
17:43:57 <chessguy> whoah, 3 weeks?
17:44:59 <EvilTerran> @seen needs to be adapted to do weeks as a unit if people're managing to stay away from #haskell for that long
17:45:00 <lambdabot> I haven't seen needs.
17:45:06 <EvilTerran> ... whups.
17:45:34 <marcusf> EvilTerran: Yeah, as I figure it, for my type to derive (?) from Num, it has to implement the whole shebang, not just *
17:45:38 <marcusf> true?
17:46:12 <sjanssen> marcusf: you aren't *required* to give implementations for all the functions
17:46:28 <desp> sigh
17:46:35 <sjanssen> but the compiler will complain loudly, and you can get a runtime error if you use one of the missing functions
17:46:45 <desp> how do I load two modules at once in hugs/ghci?
17:46:58 <jcreigh> :m + Foo
17:47:00 <jcreigh> :m + Bar
17:47:06 <desp> thanks.
17:47:17 <jcreigh> err, that might be ghci only...
17:47:22 <desp> yes.
17:47:32 <desp> should've tried ghci first.
17:47:32 <desp> :)
17:47:39 <marcusf> sjanssen: ah. ok. seems logical
17:47:57 <EvilTerran> :a AnotherModule
17:48:00 <EvilTerran> for hugs, iirc
17:48:02 <marcusf> damn, this language is still sweet though
17:48:24 <EvilTerran> but it seems to not do quite what you (I, anyway) would expect.
17:48:36 <EvilTerran> (:a for :also)
17:48:41 <marcusf> first time I've had this much fun programming since I first tried lisp
17:48:56 <desp> that doesn't appear to add the module the samy way :m + does
17:49:12 <EvilTerran> desp, as i said, it seems to be a bit odd
17:49:29 <EvilTerran> only one module's used as context at any one time, i know that much
17:49:41 <chessguy_> man i hate wireless
17:49:49 <EvilTerran> but you don't seem to be able to access stuff in the other modules even if you fully qualify 'em, afaict
17:56:06 <desp> is it possible to associate a finalizer with a FunPtr?
17:56:26 <desp> looks like I could cast it to a Ptr, but that appears not to be very portable
17:56:42 <desp> (the FunPtr needs to be freed using freeHaskellFunPtr)
18:05:39 <Cale> desp: As far as I recall, you can only associate finalizers with ForeignPtrs
18:14:56 <desp> Cale: right. I can work around this, though.
18:27:21 <falconair> I've been reading about applicative functors:  I understand what pure, <*> and fmap do (fmap coming from basic functor) ... but why is this class considered good for embedding dataflow in haskell?
18:31:14 <byorgey> falconair: I was just reading about AF too!
18:32:18 <falconair> byorgey: do you understand them any better? :)  an AF only has two funcitions...simple ones at that, but I don't understand why it is significant
18:33:32 <byorgey> falconair: I'm still thinking it over, but I think the main benefit is that they give a nice model of sequencing computations with effects, but they're a bit more general than monads
18:34:02 <byorgey> falconair: so there are certain things you can express in terms of applicative functors that you actually couldn't do with monads
18:35:18 <falconair> so why is it proposed as a better way to do reactive programming (better than Arrows)
18:35:47 <wchogg> falconair:  I don't remember them proposing that it was a better way to do reactive programming.  Where was that in the paper?
18:35:57 <byorgey> wchogg: no, it's not in the paper
18:36:01 <falconair> no, it wasn't in their paper
18:36:02 <byorgey> falconair: I don't know
18:36:32 <falconair> it was in another paper called "Another Essence of Dataflow" and a more recent draft of Conal Eliot called ... let me check
18:36:55 <wchogg> Hrmm...I haven't seen those.
18:37:03 <falconair> Applicative Data-Driven Computation
18:37:13 <falconair> http://www.haskell.org/haskellwiki/Applicative_Data-Driven_Programming
18:37:16 <lambdabot> Title: Applicative data-driven programming - HaskellWiki, http://tinyurl.com/ypbdck
18:37:25 <wchogg> Thanks.
18:38:19 <byorgey> falconair: thanks for the link.  I remember seeing the announcement of that paper on the haskell mailing list, but since I didn't know anything about AF at the time it didn't really register =)
18:38:27 <wchogg> Hrrm, just from the blurb it sounds like he's really making use of the fact that they're closed under composition.
18:39:31 <byorgey> oh yeah! falconair: that's another benefit of applicative functors, they're closed under composition =)
18:39:40 <byorgey> whereas monads aren't necessarily
18:39:47 <falconair> I heard of AF from the "Another essence.." paper, which I came to know about from another paper "Essence of ..." ... I read all of them but they still don't make any essence :)
18:40:12 <byorgey> falconair: have you read the original McBride/Paterson paper?
18:40:42 <byorgey> falconair: do you have a link to the "Another essence..." paper you're talking about?
18:40:53 <falconair> so perhaps that is the trick?  anything a dataflow variable touches much become a dataflow expression itself...hence the importance of being closed under composition?
18:41:13 <falconair> http://citeseer.ist.psu.edu/denckla06another.html
18:41:14 <lambdabot> Title: Another Essence of Dataflow Programming (ResearchIndex)
18:41:18 <byorgey> falconair: thanks
18:41:28 <byorgey> falconair: hmm, I'm not sure what you mean
18:41:45 <falconair> byorgey: i did read the McBride paper as well
18:41:55 <byorgey> falconair: in this context, "closed under composition" means you can always put together two different applicative functors to get a new applicative functor
18:42:11 <byorgey> falconair: OK, that's the only one I've read so far
18:44:03 <falconair> byorgey, i see what you mean ... that is the definition of "close under compsition" i had in my head as well...I thought it might also apply when .... never mind, i'm too confused :)
18:44:32 <byorgey> falconair: heh...
18:44:59 <byorgey> falconair: well, I think they make sense to me... except only in a theoretical sense, I'm still not sure I understand when/how you would use them.
18:46:36 <wchogg> The only other paper from the original I had read on applicative functors was the Essence of the Iterator Patern, which is pretty neat.
18:47:15 <desp> aha
18:47:22 <desp> @hoogle addMVarFinalizer
18:47:23 <lambdabot> GHC.Conc.addMVarFinalizer :: MVar a -> IO () -> IO ()
18:47:41 <desp> Cale: ^
18:47:44 <lispy> dons++ -- for the great explanation of fast number parsing on haskell-cafe
18:47:57 <falconair> i think i need to understand 'traverse' as well ... by the way, i believe it is also mentioned in a paper about higher order functions being design patterns...something like it
18:48:29 <dons> lispy: cheers. i thought it was about time the lazy-lists-of-strict-chunks approach got talked about
18:48:42 <Cale> desp: ah, right
18:48:52 <lispy> byorgey: the reason i didn't generalize my unit testing thing further is because i use Language.Haskell which only parses vanilla H98.  A better version could use something like the GHC api
18:49:25 <lispy> byorgey: and i agree it would be a worthwhile contribution to the community
18:50:00 <byorgey> lispy: that makes sense.
18:50:13 <lispy> dons: yeah, now if i could get you excited about hacking on darcs...Igloo did a lot to optimize it, but we can do so much more i belive
18:50:24 <byorgey> lispy: I might try to put something together -- do you mind if I use your code as a starting point?
18:50:50 <lispy> byorgey: please do!  I'd be overjoyed to have something i wrote become something useful :)
18:51:38 <byorgey> lispy: ok, thanks!  I have no idea how far I will get, but I'll probably learn a lot trying.  and if I get stuck I guess that's what #haskell is for =)
18:51:49 <lispy> byorgey: definitely
18:51:57 <lispy> byorgey: do you need any help hosting your source code?
18:52:11 <lispy> there is darcs.haskell.org that might give you an account, otherwise i can offer some webspace
18:52:24 <byorgey> lispy: hm, that would probably be good
18:52:46 <byorgey> lispy: I've never used darcs before either so this will be a good opportunity to learn that too
18:52:59 <lispy> yes! and there is a wikipage about this
18:53:01 <lispy> hang on
18:53:46 <lispy> gr...why isn't the wiki searchable by google....
18:53:59 <lispy> it makes it (almost) completely useless to me since i never can find it
18:54:21 <byorgey> lispy: someone else was complaining about that earlier today
18:54:37 <byorgey> lispy: apparently there's a robots.txt file that prevents google from indexing the wiki
18:54:38 <lispy> byorgey: http://www.haskell.org/haskellwiki/Structure_of_a_Haskell_project
18:54:39 <lambdabot> Title: Structure of a Haskell project - HaskellWiki
18:54:45 <byorgey> lispy: thanks!
18:55:00 <lispy> byorgey: yeah, apparantly it causes too much strain on the webserver when the bots start indexing the page histories
18:55:05 <lispy> but i thought they were going to fix it
18:55:25 <lispy> actually, that's not the link i wanted
18:55:43 <lispy> byorgey: http://www.haskell.org/haskellwiki/How_to_write_a_Haskell_program
18:55:45 <lambdabot> Title: How to write a Haskell program - HaskellWiki
18:56:01 <byorgey> lispy: ah, that looks useful too
18:56:17 <lispy> it looks long, but that's just because it's step by step everythin gyou need to get off the ground
18:57:08 <byorgey> lispy: that's good, since that's what I need!
18:58:19 <lispy> i hope you find that the haskell community is alive and helpful if/when you get stuck or need help
18:59:08 <byorgey> I don't doubt that it will be
19:01:30 * desp <3 Haskell
19:02:08 <desp> it's nice to write some code, read more documentation, and discover already abstracted out patterns to simplify the code
19:06:30 <igli> yay! #haskell again :D
19:06:35 <ihope> Mmh, I feel like writing useful code with an obscure idiom.
19:07:23 <LoganCapaldo> is CPS an obscure idiom?
19:07:39 <LoganCapaldo> Oh I know! goal oriented computations! Write it in Icon
19:07:47 <lispy> dons: did anyone stepup to head the haskell pdf viewer project yet?
19:07:48 <ihope> The most obscure idiom I know right now is the... Huet zipper, I think it is.
19:07:58 <LoganCapaldo> That's pretty obscure
19:08:00 <byorgey> ihope: try applicative continuation-passing zipper cofunctors
19:08:19 <ihope> Maybe I'll stick to CPS for now.
19:08:19 <dons> lispy: nope.
19:08:25 <byorgey> =)
19:08:59 <lispy> dons: ah, that's too bad...people seemed genuienly interested last time it was discussed
19:09:11 <dons> yes, i'm interested.
19:09:13 <dons> once xmonad is done.
19:09:34 <lispy> sjanssen is the lead for xmonad right?
19:10:06 <lispy> so many cool projects not enough time
19:10:12 <dons> lispy, what i really need is someone to write a parsec based on the hints i just gave to the list about bytestring parsing.
19:10:13 <lispy> i still need to fix lambdaweb
19:10:24 <dons> yeah, sjanssen and i are really co-leads, i'd say.
19:10:27 <lispy> yes, we need a bytestring parsec
19:10:32 <dons> the work is divided up pretty much 50/50
19:10:59 <lispy> but what i encountered with transforming parsec to bytestring is that grammer makes a difference in how you want to optimize internally
19:11:12 <igli> @botsnack
19:11:13 <lambdabot> :)
19:11:13 <lispy> that and some of the parsec source was a bit over my head
19:11:15 <dons> yep.
19:11:23 <igli> i missed you too lambdabot :D
19:12:19 <byorgey> igli: as a welcoming-back seems to be in order...welcome back! =)
19:12:33 <lispy> some things i'd like to work on...purely functional scene graph on hopengl, pdf viewer, turn Language.C into a full blown compiler, and to work on that unit test thing i was just discussing
19:12:39 <igli> heh thanks byorgey had no gui for over a week :)
19:12:54 <byorgey> igli: IRC requires a gui?
19:13:17 <lispy> dons: i need a job that pays me to work on opensource haskell projects!
19:13:45 <igli> heh no just that i've been troubleshooting it on BitchX then irssi ;)
19:14:03 <lispy> actually, i wish i could just get paid to work on darcs for a couple years...get it to the point where it dominates over all, and then back off to work on other projects
19:14:07 <byorgey> lispy: good luck with that!
19:14:46 <lispy> byorgey: yeah, i'd settle for paid haskell dev period, but i'm dreaming right now :)
19:15:05 <igli> dunno ppl go on about jobs in here all the time
19:15:12 <byorgey> lispy: yeah, I'd love that too
19:15:14 <desp> @pl failWhen val err = when val $ fail err
19:15:14 <lambdabot> failWhen = (. fail) . when
19:15:19 <desp> meh
19:15:55 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs) -- ah haskell...
19:15:57 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
19:16:56 <ihope> Now tell me an obvious use of CPS...
19:17:11 <desp> ihope: compilers? ;)
19:17:36 <ihope> Mm, CPS isn't bad when you're implementing Unlambda, actually. :-)
19:18:05 <desp> oops, 4 am again
19:18:24 * ihope 4-AM-bops desp
19:18:40 * byorgey shoos desp off to bed
19:18:43 * kfish passes desp the sleep token
19:18:51 <desp> heh.
19:19:04 <desp> just one more thing...
19:19:10 * ihope 10-PM-bops himself.
19:19:14 <lispy> ihope: i think the all about monads tutorial has the most obvious use...try to work on something and then you need more input from the user so you use a continuation to get it
19:19:18 <ihope> I have to wake up at 6AM tomorrow for exams.
19:19:37 * chessguy passes desp as a continuation to his bed
19:21:12 <ihope> You can get stuff like that via a continuation?
19:21:58 * byorgey wishes ihope good luck with exams!
19:22:15 * byorgey misses exams...
19:22:28 <ihope> And after the exams, school is over. >:-)
19:22:47 <ihope> And eac--wait, I should go to bed right about now.
19:24:06 <lispy> ihope: good night
19:24:38 <shapr> chessguy: I'm here, but busy..
19:25:34 <chessguy> shapr, ah, ok. i wonder if i could brainstorm with you sometime on the GP project
19:50:56 <shapr> Has anyone ever tried to do setup and teardown with HUnit tests?
19:51:28 <lispy> shapr: i have not used HUnit
19:51:30 <lispy> sorry
19:56:16 <dibblego> what does HUnit provide that QC doesn't? is it for doing testing of IO functions?
19:56:16 <shapr> yup
19:56:16 <shapr> HUnit is very good at handling IO testing.
19:56:16 <shapr> I haven't gotten around to trying out HFT (stefan wehr's lib that combines QC and HUnit).
19:56:16 <shapr> If it's decent I'll add test fixtures there somehow.
19:56:16 <shapr> I haven't found a pretty way to add fixtures in HUnit.
20:07:33 <alexj> anyone here know how to use Data.Digest.MD5?
20:07:47 <alexj> it maps Octets to Octets, but I have String.
20:09:54 <Korollary> A string is in unicode, so I suppose md5 is not applicable directly. You could md5 its utf8 representation I think.
20:11:03 <alexj> any idea how I do that?
20:11:22 <alexj> I want it to behave the way PHP and Python's MD5 code does.
20:11:34 <Korollary> Do they handle unicode strings?
20:11:54 <alexj> assume they are just utf8
20:12:03 <alexj> not unicode.
20:12:04 <alexj> or ascii
20:12:06 <alexj> or whatever.
20:12:44 <Korollary> ascii is easy. I don't know about utf8
20:12:46 <bd_> It's unfortunate, but haskell's unicode support is still a little weak. Strings are /theoretically/ unicode, but I don't believe anything bothers to do conversions. You might want to look into Data.CompactString
20:12:54 <bd_> or just map ord, if you can assume it's ascii
20:13:25 <alexj> currently I am doing md5::String->String
20:13:30 <alexj> md5 = map (toEnum . fromIntegral) . MD5.hash . map (fromIntegral.fromEnum)
20:13:48 <alexj> but that generates weird escape characters that I assume are not permitted.
20:14:11 <Korollary> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Encode-0.7
20:14:13 <sjanssen> alexj: if you're using the existing IO functions, you don't have to worry about Unicode
20:14:14 <lambdabot> http://tinyurl.com/2692gf
20:15:09 <jcreigh> "don't have to worry" here means "you *can't* worry about unicode, even if you wanted to" (My understand is that IO functions just assume one byte = one char on input and truncate to bytes on output)
20:15:16 <jcreigh> *understanding
20:15:30 <alexj> I don't want to worry about unicode, I just want to pass an md5 hash in a url.
20:15:42 <jcreigh> alexj: yeah, you're going to want to hex format it
20:16:09 <alexj> ok...?
20:17:10 <jcreigh> something like:
20:18:03 <jcreigh> md5 = concatMap (print "%02x" . fromIntegral) . MD5.hash . map (toEnum . fromEnum)
20:18:07 <jcreigh> md5 :: String -> String
20:18:10 <jcreigh> might work. Maybe.
20:18:39 <jcreigh> and I'm sure there's a nicer way to format something in hex than resorting to printf...
20:19:04 <Korollary> See the Encode package I posted
20:20:15 <jcreigh> (and you'll have to import Text.Printf to get printf, btw)
20:22:30 <alexj> Korollary:  how do I use that?
20:23:16 <alexj> looks like it solves the problem, but am not sure I understand usage.
20:33:01 <alexj> I htink I need hex output.
20:33:37 <jcreigh> > concatMap (printf "%02x") [45,23,238,123] :: String
20:33:42 <lambdabot>  "2d17ee7b"
20:34:08 <jcreigh> like I said, there's a better way than that, I just don't know what it is.
20:34:21 <jcreigh> If only someone knew, and told us... *cough* *cough*
20:34:43 <sjanssen> @hoogle showHex
20:34:43 <lambdabot> Numeric.showHex :: Integral a => a -> ShowS
20:34:51 <jcreigh> there we go!
20:34:57 <jcreigh> sjanssen++ thank you
20:35:25 <sjanssen> > foldr showHex [45,23,238,123]
20:35:26 <lambdabot>   add an instance declaration for (Num Char)
20:35:26 <lambdabot>     In the expression: 123
20:35:50 <sjanssen> > foldr showHex "" [45,23,238,123]
20:35:52 <lambdabot>  "2d17ee7b"
20:36:13 <jcreigh> > foldr showHex "" [1,2,3,4] -- not padded with zeros
20:36:15 <lambdabot>  "1234"
20:36:19 <jcreigh> how can we fix that?
20:36:21 <sjanssen> ah, hmm
20:38:56 <byorgey> I mean, it wouldn't be hard to write a wrapper function around showHex that padded with a zero if necessary
20:39:12 <byorgey> but then you might as well use printf... =P
20:41:15 <alexj> php produces a longer string
20:41:21 <SamB_XP_> @hoogle digit
20:41:21 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
20:41:21 <lambdabot> Char.digitToInt :: Char -> Int
20:41:21 <lambdabot> Char.intToDigit :: Int -> Char
20:41:32 <jcreigh> alexj: using showHex or printf?
20:41:33 <SamB_XP_> > intToDigit 16
20:41:35 <lambdabot>  Exception: Char.intToDigit: not a digit 16
20:41:38 <SamB_XP_> > intToDigit 15
20:41:39 <lambdabot>  'f'
20:41:49 * SamB_XP_ thinks intToDigit is awfully picky
20:41:50 <alexj> printf
20:42:04 <alexj> I think php pads an md5 value or something
20:42:06 <SamB_XP_> what if I wanted to use base-36
20:42:22 <jcreigh> alexj: what does md5 "hello" evaluate to?
20:42:43 <byorgey> SamB_XP_: you don't.  The Char package has decreed it.
20:42:53 <byorgey> =)
20:43:00 <SamB_XP_> base-32?
20:43:14 <alexj> 5d41402abc4b2a76b9719d911017c592111
20:43:17 <alexj> in php
20:43:32 <jcreigh> ~% echo -n hello | md5sum
20:43:32 <jcreigh> 5d41402abc4b2a76b9719d911017c592  -
20:43:35 <alexj> 5d41402abc4b2a76b9719d911017c592
20:43:36 <byorgey> SamB_XP_: duotrecimal?
20:43:40 <alexj> in python
20:43:43 <jcreigh> PHP is doing something strange.
20:43:47 <alexj> I don't know what the 111 is
20:43:49 <SamB_XP_> the Sega Genesis Game Genie actuallly uses base-32... though it skips some letters that look too much like numbers etc.
20:44:04 <alexj> padding?
20:44:12 <byorgey> SamB_XP_: interesting.
20:44:47 <jcreigh> alexj: dunno. Do you have access to the PHP source? Or is this someone else's app?
20:44:47 <SamB_XP_> or was it base 16 with only letters?
20:44:54 <SamB_XP_> no... I think it was 32...
20:45:01 <alexj> just the default php md5 function
20:45:44 <alexj> oh my bad
20:45:46 <alexj> fixed!
20:45:58 <alexj> was doing something stupid in php.  don't know it well,.
20:46:12 <alexj> thanks!
20:46:16 <byorgey> goodnight all...
20:46:38 <alexj> brb
21:55:05 <dons> ?users
21:55:05 <lambdabot> Maximum users seen in #haskell: 338, currently: 292 (86.4%), active: 17 (5.8%)
21:55:09 <dons> ?uptime
21:55:09 <lambdabot> uptime: 2d 23h 24m 33s, longest uptime: 17d 7h 41m 6s
22:14:05 <Korollary> Can a CPS transform (or some other transform) of lambda calculus remove the need for a heap?
22:14:05 <Korollary> Apparently it can. That's what chicken scheme seems to be doing.
22:43:41 <ski> Korollary : i think chicken uses the C stack as a heap
22:45:04 <Korollary> ski: Yup I found it
22:45:55 <ski> (so i don't think the heap is removed)
22:52:01 <sieni> ski: well I think it just converts everything into CPS and allocates everything on the C stack and when it runs out of C stack, it copies the live objects from the stack to heap and then just starts all over from the beginning of the C stack
22:56:58 <Korollary> That's what the FAQ says too
23:20:17 <xpika> Setup.hs seems to think ghc should be in Program Files/Haskell
23:20:31 <xpika> where did it get that info
23:26:53 <fridim> Hi
23:27:31 <fridim> though http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries exists, I get nothing when searching "GUI" on the haskellwiki
23:27:33 <lambdabot> Title: Applications and libraries/GUI libraries - HaskellWiki, http://tinyurl.com/yttdtd
23:30:55 <dancor> how do i suppress a "Warning: Fields of `Game' not initialised: gScreen"
23:31:24 <dancor> i have everything in a monolithic structure but i need to initialize gScreen later
23:31:32 <dancor> so i just want to kill the warning
23:32:28 <dons> {-# OPTIONS -w #-}
23:32:30 <dons> in that module :-)
