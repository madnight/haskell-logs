00:05:33 <brainly-green> is it possible in the untyped lambda calculus to have a function eq so that (eq a b) = true iff a's beta normal form is the same as b's beta normal form?
00:06:16 <brainly-green> or alternatively is there some other usual definition for eq?
00:08:32 <opqdonut> isn't that just extensionality?
00:09:17 <brainly-green> but that's a transformation rule, not a function
00:09:40 <brainly-green> I mean not a function in the lambda calculus
00:09:45 <opqdonut> ah sorry, thought you wanted a lambda-calculus function for that
00:09:47 <opqdonut> yeh
00:10:04 <brainly-green> I do want a lambda-calculus function for it
00:10:32 <brainly-green> with eq being an expression in untyped lambda calculus
00:12:23 <Korollary> That's a tough question
00:13:46 <Korollary> eq? \xy.x \xy.y . I don't know how I'd write an eq? that can handle that.
00:14:12 <brainly-green> or something weaker would also be acceptable, I just want to know how it's usually done
00:14:12 <brainly-green> so long as eq is a lambda calculus expression and does something like equality
00:15:01 <Korollary> What is your reference text?
00:15:09 <brainly-green> sorry I don't have one, maybe I should
00:15:27 <brainly-green> I've only been particularly interested in this for a week or so
00:16:06 <brainly-green> I'm just using sources on the internet for now
00:16:26 <Korollary> I can give you links to a few online sources.
00:16:50 <brainly-green> well on the internet I'm starting from the Wikipedia article http://en.wikipedia.org/wiki/Lambda_calculus
00:16:51 <lambdabot> Title: Lambda calculus - Wikipedia, the free encyclopedia
00:17:15 <Korollary> My copy of TaPL has encodings for church numerals and it's got an equal function for those. But it doesn't say anything about comparison in general.
00:20:57 <Korollary> I recommend http://www.cs.ru.nl/E.Barendsen/onderwijs/T3/materiaal/lambda.pdf
00:27:41 <brainly-green> Lisp's eq basically presumes pass-by-reference while lambda calculus is apparently by value
00:28:09 <brainly-green> so maybe it's incompatible
00:29:22 <Korollary> lambda calculus can be implemented using different evaluation orders.
00:29:56 <Cale> Lambda calculus on its own doesn't even really have a notion of evaluation
00:30:09 <Thunder> @seen dons
00:30:09 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 15m 12s ago.
00:30:20 <Korollary> No, it doesn't.
00:31:02 <brainly-green> well eq is pointer equality and in lambda calculus you always substitute the full value of an expression anywhere its name appears
00:32:07 <Korollary> I didn't mean pointer equality with eq.
00:33:08 <Korollary> eq is just another lambda term. The question is whether there is such a term.
00:33:11 <brainly-green> I know, there are other ways to do it
00:33:54 <opqdonut> probably atleast by embedding lambda calculus in lambda calculus?
00:34:11 <opqdonut> :)
00:36:10 <brainly-green> I was thinking about this because I was wondering if a right-to-left function application could be made sensible/useful
00:37:02 <Svrog> if i remember correctly j uses right to left evaluation
00:37:21 <brainly-green> I actually mean both right to left rules and left to right rules
00:37:34 <brainly-green> so if you have (E1 (\ x <- E2)) (note the backwards arrow) then you might add a replacement rule to bind E1 to the free occurrences of x in E2
00:38:13 <Korollary> Other than just different notation, what is the point?
00:38:15 <brainly-green> and say that right-to-left application takes precedences over left-to-right application (i.e. no left-to-right application can be done if the right term is a right-to-left function)
00:38:35 <brainly-green> it could be used for dynamic polymorphism or things like the dirac delta function
00:39:38 <Korollary> Precedence doesn't enable more than what explicit syntax does.
00:39:46 <brainly-green> for example, consider the pseudocode: (\ x <- if x is integrate and the limits of x enclose 0, then 1, else 0)
00:40:31 <brainly-green> that would be something like the dirac delta function, allowed to specify that when you integrate it across 0 its integral is 1 and its integral is 0 otherwise
00:41:59 <Korollary> Why can't you do that using regular LC?
00:42:16 <brainly-green> because you'd have to alter the definition of the integrate function
00:42:44 <brainly-green> this way, using an existing integrate function (not changing that code), you can extend it to handle the dirac function
00:44:44 <brainly-green> or the pseudocode: (\x <- if x is weight then 105 else if x is height then 162 else if ... )
00:44:54 <Korollary> You need a "if x is integate" predicate, yes. If you had that, you could do that using regular LC, too.
00:45:02 <brainly-green> which would be dynamic polymorphism
00:45:14 <brainly-green> specifying the member methods for an object
00:45:52 <brainly-green> I don't think you can do the dirac with regular LC except by changing the integrate function, prove me wrong
00:46:29 <Korollary> You're essentially passing the function to its argument, which checks whether the function is integrate and behaves accordingly, yes?
00:46:35 <brainly-green> yes
00:48:33 <Korollary> It would be something like integrate (\f. if eq f integrate then somethingelse otherwise usualnumber)
00:48:50 <Korollary> err I meant (f somethingelse) and (f usualnumber)
00:50:00 <quicksilver> I'm probably being really dense here, but how do I write a parsec parser for "[ab]*b" ?
00:50:08 <brainly-green> you'd have to pass it f then
00:50:28 <Korollary> brainly-green: Yes.
00:51:08 <brainly-green> you'd need to call it like ((\f. if eq f integrate then f somethingelse otherwise f usualnumber) integrate)
00:52:09 <brainly-green> but you don't want to call it like that for ordinary numeric functions, you usually want integrate to come first
00:53:33 <Korollary> You also don't want to write backwards arrows.
00:54:31 <brainly-green> ok
00:54:34 <Korollary> It's just a syntactic difference either way
00:54:54 <brainly-green> well it's more than that, because if you have implemented integrate over a large program and use it in many places
00:55:26 <brainly-green> and now you want to be able to integrate the dirac delta function, the only way to do it (using normal untyped lambda calculus) is to alter your integrate function or change your calling style
00:55:59 <brainly-green> but if you have this, it's a local change
00:56:33 <Korollary> Don't you have to insert left-arrows everywhere?
00:56:56 <brainly-green> no, only when you need to do something funny with the function on the left
00:57:51 <Korollary> Well, you wrote (integrate x) all over the place when x wasn't supposed to be dirac delta. Now that it can be, you need to add the arrows so that it can be handled correctly.
00:58:07 <brainly-green> you only add the arrows in x
00:58:17 <brainly-green> everything else stays the same
00:58:32 <brainly-green> and only when x is dirac delta, all the other values also stay the same
00:59:34 <brainly-green> (integrate -1 1 x (\x -> x + 1)) would work the same as before
01:00:46 <Korollary> Yes. If you could identify all x's that don't need to change, you save some typing.
01:00:50 <quicksilver> blah, I can do it with manyTill but it's fugly
01:01:01 <brainly-green> none of the other x's would need to change
01:01:15 <brainly-green> just the dirac delta
01:01:50 <Korollary> Depending on the program, you may not be able to statically identify all x's that can remain untouched. Sometimes, you can save some typing, tho.
01:04:22 <brainly-green> I don't think there's any situation where any other code could be broken
01:04:36 <brainly-green> unless the value using the <- is itself buggy
01:05:22 <brainly-green> not just for integrate, but for any usage of <-
01:07:02 <Korollary> Since dirac delta is a value just like other numbers, it may be getting passed around, being returned from functions, etc. So you can't always statically guarantee that at a call site the argument is not the dirac delta, but a regular number.
01:08:34 <brainly-green> well the dirac delta is more similar to a function than it is to a number, but in general I think it would be the job of the dirac delta to behave sensibly wherever it is used
01:09:24 <brainly-green> so it would behave properly when given to an integral, and it would need to have code to check if the left hand side is * or + so that it can appropriately multiply or add itself
01:09:57 <LeCamarade> DRMacIver: ping
01:11:42 <LeCamarade> @tell DRMacIver That crappy, half-assed mimick of lambdas for C that I threatened to write yesterday ... I did. But it's too much of a toy. :o)
01:11:42 <lambdabot> Consider it noted.
01:13:14 <LeCamarade> @tell DRMacIver It, of course, doesn't get enclose its scope. Utter crap, but it was euphoric getting my boss closer to stopping the marginalisation of Haskell by making C sweeter before his very eyes. :o)
01:13:14 <lambdabot> Consider it noted.
01:19:21 <Korollary> brainly-green: You may be interested in this thread: http://tinyurl.com/2qvefq
01:19:22 <lambdabot> Title: comp.lang.functional | Google Groups
01:33:06 <brainly-green> ty, that was helpful, apparently the consensus is that it's not possible
01:33:43 <beelsebob> brainly-green: what's that?
01:33:54 <brainly-green> Korollary's link
01:34:44 <beelsebob> oh
01:34:55 <beelsebob> no, it's not possible to tell if two functions are equal
01:34:58 <brainly-green> so I guess that eq needs to be provided specially by the language
01:35:03 <brainly-green> no, not for that reason
01:35:14 <brainly-green> just because of a lack of reflection
01:35:27 <beelsebob> hmm?
01:35:33 <quicksilver> which, despite the implication in that thread, is not unique to lambda calculus
01:35:38 <brainly-green> it's certainly possible to tell if two functions have the same beta-normal form
01:35:45 <quicksilver> very few languages have introspection for code
01:35:53 <quicksilver> off hand I can only think of certain lisps
01:35:59 <brainly-green> not all the time, but some of it
01:36:07 <beelsebob> brainly-green: no it's not
01:36:12 <beelsebob> is omaga equal to true?
01:36:22 <beelsebob> you're gonna have to sit evaluating omega to find out
01:36:22 <brainly-green> that is, there is a function that can take two expressions and terminate iff they have the same beta-normal form
01:36:36 <beelsebob> yeh, that's not equality
01:36:44 <beelsebob> equality should always terminate
01:36:57 <beelsebob> it shouldn't ever be "I don't know, not only that, I don't know if I can ever tell"
01:37:21 <quicksilver> brainly-green: when you say 'take two expressions'
01:37:39 <brainly-green> not a function in lambda calculus, a function that takes two syntactic expressions and analyzes them
01:37:43 <quicksilver> brainly-green: you mean, presumably 'take two expressions reflected as concrete term structures' or something
01:37:47 * quicksilver nods
01:38:33 <brainly-green> nonterminating for inequality would be OK, but apparently you can't get even that with lambda calculus
01:38:46 <beelsebob> why not?
01:38:53 <beelsebob> write a lambda calculus evaluator
01:38:59 <beelsebob> tell it to evaluate each
01:39:00 <brainly-green> within lambda calculus
01:39:03 <beelsebob> yes
01:39:06 <beelsebob> that's possible
01:39:08 <brainly-green> you can't get it with an expression within lambda calculus
01:39:17 <beelsebob> why not?
01:39:25 <beelsebob> lambda calculus is turing complete
01:39:36 <brainly-green> the consensus in that thread, which makes sense to me, is that because lambda calculus is non-reflective, there's no way to get at the syntactic structure of an expression
01:39:39 <quicksilver> taking two lambda terms (as distinct from representations of lambda terms)
01:39:46 <quicksilver> you can't do it
01:39:52 <quicksilver> with the reps of course you can
01:39:58 <beelsebob> yeh
01:40:00 <beelsebob> I see
01:40:01 <brainly-green> the only thing you can do to an expression is substitute into it or call it as a function
01:40:01 <beelsebob> yeh
01:40:29 <quicksilver> the trickiest thing in this debate is keeping the terminology clear
01:40:35 <beelsebob> yes -- you can tell if two representations represent equal functions
01:40:40 <beelsebob> but you can't tell if two functions are equal
01:41:44 <quicksilver> but I repeat, this is not unique to lambda calculu
01:41:50 <beelsebob> no, not at all
01:41:58 <quicksilver> (although one of the posters in that thread suggested it was)
01:42:02 <beelsebob> it's very rare you would be able to do that in fact
01:42:06 <quicksilver> very few languages can do it
01:42:12 <quicksilver> some LISPs can in some circumstances
01:42:20 <quicksilver> as long as they're not bytecompiling and stuff
01:42:51 <quicksilver> 'homoiconic' is it called?
01:42:52 * quicksilver checks
01:43:17 <quicksilver> yes, that's the one :)
01:43:38 <quicksilver> TeX is somewhat homoiconic too
01:43:41 <quicksilver> with sufficient care
01:44:32 <quicksilver> apparently smalltalk is? Hmm I didn't know that.
01:45:35 <brainly-green> well I'm going to sleep
01:45:38 <brainly-green> later
01:53:05 <osfameron> homoiconic?  oh, not like Kylie Minogue
01:55:50 <pejo> quicksilver, what is the equal you're discussing, operationally equivalent?
01:56:17 <quicksilver> osfameron: No, not quite. Not homoiconic as in "The thing about growing up in the 80s is the weird experience of watching all your childhood idols become gay icons"
01:56:28 <quicksilver> osfameron: although I agree it would be funnier if it meant that
01:56:34 <quicksilver> pejo: alpha-equivalent, say
01:56:44 <quicksilver> pejo: or some similar structural equivalence
01:57:05 <osfameron> yeah, gay clubs would be so much more pleasant if they played interviews with Alan Kay instead of awful bouncy pop remixes of the Sound of Music
01:58:15 <osfameron> I used to live abovce a gay club that played the same horrible SoM techno remix every saturday the whole time I lived there, I swear if I ever meet Julie Andrews I will be tempted to headbutt her
01:58:22 <osfameron> though I don't suppose it's really her fault.
01:58:56 <quicksilver> You could headbutt Connie Fisher as a kind of proxy thing. Although to be fair it's not really her fault either.
01:59:55 <osfameron> indeed.  Funnily enough I live above a gay club right now, and they're as quiet as mice, very considerate.
02:18:20 <jacquesm1rde> @version
02:18:20 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
02:18:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
03:02:44 <yakov> hi
03:07:35 <dons> hi yakov
03:16:42 <fridim>   Couldn't match expected type `Float' against inferred type `Int'
03:16:42 <fridim>     In the expression: cos (((x * 2) * pi) / n)
03:16:45 <fridim> why?
03:17:41 <dons> integers, but floating point division.
03:17:51 <dons>  / wants floating point arguments
03:17:58 <dons> if you want integer division, use `div`
03:18:10 <dons> or, convert an Int to a Double or Float, with 'fromIntegral'
03:18:17 <dons> > fromIntegral (7 :: Int)
03:18:21 <lambdabot>  7
03:18:38 <fridim> mh
03:18:41 <dons> > fromIntegral (7 :: Int) / 42.3
03:18:42 <lambdabot>  0.16548463356973997
03:18:48 <dons> > (7 :: Int) / 42.3
03:18:48 <lambdabot>   add an instance declaration for (Fractional Int)
03:18:49 <lambdabot>     In the expression: (7 ...
03:18:52 <dons> > (7 :: Int) `div` 42.3
03:18:52 <lambdabot>   add an instance declaration for (Fractional Int)
03:19:08 <fridim> so  n :: Int is not automatically converted to float?
03:19:22 <fridim> even if cos expects Float
03:19:35 <dons> nope. you have to ask for your types to be converted, with fromIntegral, since its an unsafe conversion, potentially
03:19:49 <fridim> ok. Thanks
03:19:50 <thoughtpolice> no, you have to explicitly use something like fromIntegral (or you may be able to give a type annotation but I'm not sure
03:19:54 <thoughtpolice> )
03:20:14 <dons> a type annotation won't help, if its already constrained to be an Int.
03:20:14 <thoughtpolice> > (7 :: Float) / 3.5
03:20:15 <lambdabot>  2.0
03:20:20 <dons> the most common case is the 'length' function
03:20:25 <dons> > length "haskell" / 3
03:20:26 <lambdabot>   add an instance declaration for (Fractional Int)
03:20:26 <lambdabot>     In the expression: (le...
03:20:31 <dons> which we can fix two ways:
03:20:39 <dons> > fromIntegral (length "haskell") / 3
03:20:40 <lambdabot>  2.3333333333333335
03:20:59 <dons> or use a generic length, which returns a polymorphic integral value, which could be constrained to Float by /
03:21:08 <dons> > genericLength "haskell") / 3
03:21:09 <lambdabot>  Parse error
03:21:12 <dons> > genericLength "haskell" / 3
03:21:13 <lambdabot>  2.3333333333333335
03:21:31 <apfelmus> Does eager evaluation reduce function arguments to normal form?
03:21:55 <fridim> can I had   where  n' = fromIntegral n   and replace every n by n' ?
03:22:01 <fridim> s/had/add
03:22:08 <dons> fridim: yep.
03:22:39 <fridim> In the expression: cos (((x * 2) * pi) / n')
03:22:43 <fridim> the same :/
03:22:45 <apfelmus> fridim: not quite. toIntegral n' doesn't work then
03:22:57 <fridim> I paste.
03:23:41 <apfelmus> So, does ML evaluate arguments of function type to some normal form? Or does it leave them as is?
03:23:53 <hpaste>  fridim pasted "(no title)" at http://hpaste.org/276
03:43:35 <quicksilver> apfelmus: I believe it evaluates them until they 'demand' their argument
03:43:53 <quicksilver> apfelmus: I don't think the ML evaluation is different depending on the type, per se
03:44:16 <apfelmus> quicksilver: well, it's a delicate question
03:44:27 <apfelmus> I mean, consider (\x.(\y.y)3)
03:44:33 <apfelmus> \ = lambda
03:44:54 <roconnor> Is every applicative traversable thing zipable?
03:45:16 <apfelmus> When given as a parameter to say  map,  Haskell doesn't do anything about the expression
03:45:18 <quicksilver> apfelmus: yes, I think it's just WHNF
03:45:30 <quicksilver> apfelmus: but of course ML implementations might vary
03:45:32 <apfelmus> But it's neither HNF nor NF
03:45:52 <apfelmus> ML might evaluate it to NF (\x.(\y.y)3) => \x.3
03:46:20 <quicksilver> indeed, it might
03:46:24 <quicksilver> my guess is it doesn't
03:46:31 <quicksilver> but like I said, implementations might vary
03:46:40 <apfelmus> roconnor: i think not. How to zip two trees? but you can always unzip I guess
03:46:54 <apfelmus> quicksilver: yeah, i guess it doesn't, too
03:47:11 <nomeata> @localtime nomeata
03:47:12 <lambdabot> Local time for nomeata is Thu Jun 14 11:46:27
03:47:47 <roconnor> apfelmus: zip a b = ap (map (,) a) b
03:48:03 <roconnor> @type ap (liftM (,) a) b
03:48:05 <lambdabot> Not in scope: `a'
03:48:05 <lambdabot>  
03:48:05 <lambdabot> <interactive>:1:17: Not in scope: `b'
03:48:12 <roconnor> @type \a b -> ap (liftM (,) a) b
03:48:14 <lambdabot> forall a1 a (m :: * -> *). (Monad m) => m a1 -> m a -> m (a1, a)
03:49:30 <apfelmus> roconnor: that's liftM2 (,)
03:50:07 <roconnor> apfelmus: yep.  But I only use the applicative and traversable interfaces (I think).
03:50:13 <roconnor> applicative gives you ap
03:50:21 <roconnor> and traversable gives you map?
03:50:27 <apfelmus> roconnor: hm, zip a b = (,) <$> a <*> b looks good, though
03:50:34 <roconnor> ah
03:51:06 <apfelmus> But it probably does not what you want
03:51:12 * roconnor is still learning about this applicative and tranversable.
03:51:28 <roconnor> apfelmus: oh, ... BTW, what is the type of that zip?
03:51:43 <apfelmus> I mean, pure (,) = Leaf (,)
03:51:54 <roconnor> ah, that is indeed bad
03:52:57 <apfelmus> Leaf (,) <*> Branch (Leaf a) (Leaf b) = ?
03:53:05 <apfelmus> is Tree applicative at all?
03:53:33 <oerjan> it's not zip, but cartesian product
03:54:31 <apfelmus> roconnor: zip ond ZipList is the real zip, though
03:55:21 <apfelmus> And I think that Tree is not an applicative functor
03:55:48 <oerjan> Tree is a Monad
03:56:26 <apfelmus> Ah
03:57:02 <apfelmus> Yeah, so Leaf (,) <*> Branch (Leaf a) (Leaf b) = Branch (Leaf (a,) Leaf (b,))
03:57:30 <apfelmus> left tree at the left of <*> gets hooked up at every Leaf
03:57:49 <roconnor> shouldn't <*> have been named <@> ?
03:58:00 <apfelmus> and the functions all therein get the value at the leaf as argument
03:58:08 <roconnor> well, maybe * is less communative than it looks.
03:58:35 * roconnor needs to redesign all mathematical notation
04:01:07 * apfelmus <**> away
04:03:40 <nomeata> Hi. I’m trying to compile lambdabot, but I don't want to build zlib, as I would have to build some more dependencies. Can't lambdabot run without zlib?
04:05:47 <opqdonut> huh, build zlib? isn't it available practically everywhere?
04:05:50 <nomeata> (I would need greencard and pfsetup)
04:05:58 <nomeata> opqdonut: the haskell bindings..
04:06:12 <opqdonut> ahhh
04:06:21 <opqdonut> of course
04:07:36 <nomeata> I wonder why Setup.hs thinks zlib needs greencard
04:10:15 <nomeata> ah, nevermind, these are not errors it seems
04:10:29 <opqdonut> warning: i'm warning you sonny
04:24:28 <dukedave> Hey everyone, bit of a strange one: Does anyone know a list of Haskell or FP notation (specifically symbols used)?
04:28:03 <opqdonut> err?
04:29:09 <oerjan> including all the library defined ones, maybe some invocation of grep 'infix' is the simplest way to get one
04:29:30 <dukedave> I did say it was a weird one :)
04:29:44 <kfish> dukedave, what's the scope of your question? syntax? typesetting? ascii art?
04:29:53 <oerjan> for just Haskell 98 there is a precedence list in the report
04:31:25 <oerjan> http://www.haskell.org/onlinereport/decls.html#fixity
04:31:26 <lambdabot> Title: The Haskell 98 Report: Declarations
04:32:09 <oerjan> (=<< is missing, that's in the errata list)
04:32:31 <dukedave> I'm writing a report as part of my MSc & enjoy consistent notation.. I'll probably just generate it as I go along to be honest..
04:32:53 <oerjan> actually that's just the Prelude.
04:34:15 <oerjan> you could also try hoogle
04:35:09 <Botje> @vixen
04:35:09 <lambdabot> <undefined>
04:35:13 <Botje> @yarr
04:35:13 <lambdabot> Gangway!
04:35:17 <Botje> @yow
04:35:17 <lambdabot> does your DRESSING ROOM have enough ASPARAGUS?
04:35:34 <matthew-_> mmm. is Eq on MVar really defined to do pointer equality test?
04:35:47 <matthew-_> I'm having trouble navigating through the code...
04:37:08 <quicksilver> matthew-_: yes ,I think it must be
04:37:16 <quicksilver> matthew-_: I can't think of anything else it could be :)
04:37:23 <Botje> ..-
04:37:56 <matthew-_> quicksilver: indeed - especially as it doesn't require Eq on its type param
04:39:11 <quicksilver> matthew-_: exactly
05:06:08 <sphynx> ?where darcs
05:06:09 <lambdabot> http://darcs.net/
05:47:46 <Cark> I'm having a bit of an issue using HList, I don't seem to understand how to define record labels
05:48:06 <Cark> any ideas where to find some code about this ?
05:49:22 <Lemmih> Are you sure you want to use HList?
05:49:34 <quicksilver> Lemmih++ # good question
05:49:37 <Cark> it seems to fit my problem pretty well
05:49:46 <quicksilver> @remember Lemmih Are you sure you want to use HList?
05:49:46 <lambdabot> Done.
05:50:28 <Cark> i need to access the list as a list, it needs to be heterogeneous
05:50:55 <Cark> and i need to access the items as record fields too
05:51:02 <Lemmih> Cark: HLists are just tuples.
05:51:19 <Cark> but i can't iterate across tuples, can I ?
05:51:38 <Lemmih> You can at compile-time with type-classes.
05:51:48 <ndm> Cark: what exactly do you want to do, at a slightly higher level?
05:52:36 <Cark> let's say i have a table , with items which need to be indexed aong diferent kind of indexes
05:52:47 <Cark> i need to have a list of these indexes in my table
05:52:56 <Cark> that's an heterogeneous list
05:53:14 <ndm> do you know in advance what will be in the database?
05:53:15 <Cark> also i need to access an index in order to query it
05:53:20 <ndm> you can use data types, and a list/map usually
05:53:26 <Cark> i want to abstract that away
05:53:31 <ndm> but you sound like you're doing a database?
05:53:46 <Cark> a little in memory database yes
05:54:22 <Cark> are there some reasons for which i should avoid using HLists ?
05:54:51 <quicksilver> IT HURTS MY BRANE
05:55:05 <quicksilver> the main reasons is it is added complexity, if you don't need it
05:55:08 <ndm> Cark: i've written 100,000's of lines of haskell, and i've never needed to use them
05:55:30 <ndm> Cark: they blow away my brain, and usually you end up with less type guarantees - more scope for errors - plus it tends to be non-natural haskell
05:55:37 <Pseudonym> The take-home message: Wait until you find something that you can't do without them.
05:55:44 <Lemmih> ndm: Really, 100,000's? That's pretty impressive.
05:55:55 <quicksilver> Pseudonym: and then ask someone else first, to make sure they agree you can't do without them
05:55:57 <Pseudonym> Yeah.  100,000 lines of Haskell must be sentient.
05:56:06 <osfameron> what's a HList ?
05:56:11 <quicksilver> yes, ndm is the universal haskell writing machine
05:56:25 <quicksilver> osfameron: it's a lot of clever type hackery around tuple-types
05:56:31 <Cark> well i have to disagree on some point : HList makes the code more typed
05:56:33 <quicksilver> osfameron: to give you 'heterogenous lists'
05:56:57 <Pseudonym> HList is to Haskell what type lists are to C++.
05:56:58 <osfameron> ooo!  is it the haskell equivalent of type-punning ?
05:56:59 <ndm> Lemmih: yeah, probably just over 100,000 (the 's is a bit over the top) - at least 50,000 of those are in Catch
05:57:42 <quicksilver> osfameron: it's just "data Foo = Foo Int String Bar"
05:57:49 * ndm notes that writing lots of lines, most of which turn out to be wrong, is not impressive, merely typing practice!
05:58:02 <quicksilver> osfameron: but with type class magic which knows that you can call 'head' and the type will be Int
05:58:27 <quicksilver> osfameron: (and tail gives you something of type ... String Bar, and you can call head and the type will be String, etc)
05:58:42 <osfameron> oh, so *short* heterogenous lists ?
05:58:48 <quicksilver> not necessarily no
05:58:56 <quicksilver> but if they're long your types get quite hairy :)
05:59:19 <osfameron> that was kind of what I was getting at, yeah
05:59:19 <Cark> my first try was using existensial types in a list ...but then i had the type of key of my indexes escaping when trying to  query those indexes, and so i had to use dynamics, which doesn't sound right
05:59:35 <osfameron> it sounds like you might as well use tuples?
05:59:48 <ndm> records sounds the best thing, in this case
05:59:49 <osfameron> oh, but you can't index those in the same way
05:59:55 <quicksilver> osfameron: right
06:00:04 <Cark> how do i iterate over these tupples in order to update all indexes of my table upon insertion ?
06:00:19 <ndm> SYB would do it
06:00:22 <Lemmih> Cark: With type-classes.
06:00:29 <ndm> scrap  your boilerplate
06:00:31 <ndm> @where syb
06:00:32 <lambdabot> I know nothing about syb.
06:00:37 <quicksilver> osfameron: it is "just using tuples"; it's just using tuples with some type classes which let you index, calculate length, get head and tail, and so on
06:00:42 <ndm> the gmapQ function will let you do it
06:00:47 <ndm> @hoogle gmapQ
06:00:47 <lambdabot> Data.Generics.Basics.gmapQ :: Data a => (a -> u) -> a -> [u]
06:00:47 <lambdabot> Data.Generics.Basics.gmapQi :: Data a => Int -> (a -> u) -> a -> u
06:00:47 <lambdabot> Data.Generics.Basics.gmapQl :: Data a => (r -> r' -> r) -> r -> (a -> r') -> a -> r
06:01:16 <Cark> well, going for SYB seems as hard a moutain to climb as going for HLists =P
06:01:27 <quicksilver> osfameron: imagine instance LikeAList (a,b,c) where second (a,b,c) = b
06:01:30 <ndm> i disagree, SYB certainly fits my brain much better than HList
06:01:31 <Cark> besides HLists are a perfect fit, and fully typed
06:01:36 <quicksilver> osfameron: ..length = 3, and so on
06:02:01 <ndm> but that may be a brain structure thing, I can never understand anything by Oleg
06:02:05 <osfameron> quicksilver: right
06:02:07 <quicksilver> osfameron: except HList builds all those typeclasses for you so it just works. It's fairly syntactically heavy.
06:02:20 <Cark> you mean syb
06:02:29 <Cark> ?
06:03:00 <SamB_XP> ndm: I think GHC would agree with you
06:03:19 <SamB_XP> remember when joelr was trying to use HList?
06:03:31 <ndm> i think he broke the compiler in 8 different ways
06:03:39 <quicksilver> to be honest, I don't think simple HList stuff is hard to understand
06:03:52 <quicksilver> but some of the more peculiar stuff i
06:04:10 <quicksilver> SYB, meanwhile, just has such ugly function names :(
06:04:14 <quicksilver> uniplate all the way!
06:04:46 <Cark> what is uniplate ?
06:04:53 <quicksilver> I still don't really undestand Cark's problem area, but it doesn't sound like HList to me. To be honest it sounds like a job for a couple of simple type classes
06:05:18 <Cark> well i tried goind this direction
06:05:18 <quicksilver> Cark: ndm's own approach to generic; slightly less expressive but very much more pleasant to read + write
06:05:30 <Cark> going*
06:05:44 <ndm> @where uniplate
06:05:45 <lambdabot> I know nothing about uniplate.
06:05:57 <ndm> @where+ http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:05:57 <lambdabot> Done.
06:06:05 <ndm> i actually released uniplate yesterday, although silently
06:06:08 <Cark> the thing is that it isn't enough to have several items to be of the same class to put these in the same list
06:06:13 <quicksilver> did you need to give it the 'name' as the keyword, ndm?
06:06:20 <quicksilver> or doest it remember the last where query?
06:06:27 <ndm> @where+ uniplate http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:06:28 <lambdabot> Done.
06:06:34 <ndm> quicksilver: nope, i screwed it up
06:06:38 <quicksilver> :)
06:06:41 <opqdonut> :)
06:06:49 <opqdonut> @where http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:06:59 <ndm> @where uniplate
06:07:00 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:07:14 <opqdonut> just wondering what that first @where+ did actually
06:07:24 <quicksilver> @where kjhklj
06:07:25 <lambdabot> I know nothing about kjhklj.
06:07:27 <quicksilver> it did something
06:07:34 <quicksilver> LB doesn't say 'I know nothing' about it :)
06:07:39 <quicksilver> but it didn't say anythign either
06:07:43 <nomeata> Is jgoerzen on IRC sometimes?
06:07:49 <quicksilver> yes
06:07:59 <quicksilver> @seen CosmicRay
06:07:59 <lambdabot> I haven't seen CosmicRay.
06:08:07 <quicksilver> not recenetly, apparently
06:08:08 <nomeata> ok, thx
06:08:24 <quicksilver> Cark: why do you want them in a list at all/
06:08:32 <quicksilver> Cark: there is something about your problem I'm just not getting...
06:08:33 <nomeata> Anyone here using darcs-buildpackage while being both the maintainer and the upstream author?
06:08:41 <Cark> when i add a record to my table, i need to update all the indexes
06:08:57 <Cark> so i need to iterate across the list of indexes
06:09:29 <Cark> so they need to be in some kind of a list
06:09:47 <quicksilver> then presumably your indexes must be uniform somehow, so they must all conform to a type clas
06:09:58 <quicksilver> otherwise you wouldn't know how to 'update' them?
06:10:08 <quicksilver> so it sounds like a list of type-class quantified thing
06:10:11 <Cark> they do belong to a Index_ class
06:10:24 <Cark> right, up to this point that working well
06:10:28 <quicksilver> sounds like [exists a . => Index_ a] then
06:10:38 <Cark> but at some point i might want to query one of those indexes
06:11:04 <quicksilver> and that's a problem because?
06:11:13 <quicksilver> nomeata: speak of the devil :)
06:11:23 <Cark> because the key type will escape the exitential type
06:11:33 <nomeata> Hi CosmicRay
06:11:37 <Cark> keys are different for each index
06:11:41 <nomeata> I’m trying my first steps with darcs-buildpackage
06:11:45 <CosmicRay> good morning
06:11:49 <nomeata> I’m both upstream and debian maintainer.
06:12:02 <nomeata> Is this clever:
06:12:09 <hpaste>  fridim pasted "what's wrong?" at http://hpaste.org/277
06:12:24 <fridim> I don't understand.
06:12:34 <nomeata> I do upstream work in ~/debdarcs/sm.upstream and debian work in ~/debdarcs/sm
06:12:36 <fridim> > cos (2 * pi / 4)
06:12:37 <lambdabot>  6.123031769111886e-17
06:12:52 <quicksilver> Cark: well this list might be the right way to access the indices when you want to update them
06:12:56 <fridim> > cos ( 2 * x * pi / 4) in x = 5
06:12:56 <lambdabot>  Parse error
06:13:00 <CosmicRay> nomeata: oh, you don't package it as a debian-native package?
06:13:00 <nomeata> before building a new debian package, I pull the upstream changes, without a release, into ~/debdarcs/sm
06:13:08 <CosmicRay> ok.
06:13:09 <quicksilver> Cark: but it may still not be the right way when you want to get the right one for a key
06:13:12 <nomeata> CosmicRay: no, as the package is not debian specific
06:13:20 <edwardk> ndm: just read the uniplate stuff, not bad
06:13:30 <nomeata> and when I upload the package, I tag the current state of sm.upstream with the new upstream version
06:13:34 <nomeata> change debian/changelog
06:13:34 <apfelmus> > let n = 4 in cos (2 * pi / n) -- fridim
06:13:36 <lambdabot>  6.123031769111886e-17
06:13:40 <edwardk> i definitely like the way the list comprehensions read
06:13:41 <nomeata> build and debrelease
06:13:41 <Cark> quicksilver : i agree on that
06:13:42 <quicksilver> fridim: 'x' is an integer
06:13:42 <ndm> edwardk: the paper describes it in a much more accessible and complete way
06:13:46 <nomeata> and then dpb-debmark
06:13:49 <nomeata> sounds sane?
06:13:54 <ndm> edwardk: particularly it has code comparisons between Compos, SYB and Uniplate
06:13:57 <fridim> quicksilver, and?
06:13:58 <CosmicRay> nomeata: I'd add a pull from upstream after you tag it
06:14:06 <quicksilver> fridim: so you can't multiply it by a Float or a Double
06:14:09 <apfelmus> fridim: n is an integer, too
06:14:09 <ndm> yeah, i like the list comps - they make lots of boilerplate exactly one oline
06:14:13 <CosmicRay> nomeata: but that is not really a big deal.  that way your dbp-markdeb tag references the upstream tag as well
06:14:16 <nomeata> CosmicRay: from sm.upstream to sm
06:14:20 <apfelmus> fridim: but 4 is not an integer :)
06:14:20 <quicksilver> fridim: you probably want (fromIntegral x), and also n
06:14:20 <CosmicRay> but yes, that is how the tool is designed to work
06:14:21 <CosmicRay> right
06:14:23 <fridim> 4 is an integer either
06:14:29 <nomeata> oh, right
06:14:30 <apfelmus> @type 4
06:14:32 <lambdabot> forall t. (Num t) => t
06:14:36 <fridim> mh.
06:14:37 <nomeata> I’ll pull the upstream version tag.
06:14:38 <CosmicRay> nomeata: so you tag sm.upstream, then pull the tag into sm
06:14:44 <fridim> Integer -> Float  is impossible?
06:14:45 * nomeata acks
06:14:53 <quicksilver> fridim: no it's posible and I just told you how :)
06:14:59 <nomeata> ok, I’ll try it, and come back if I have problems :-)
06:15:02 <CosmicRay> nomeata: darcs-buildpackage should then generate a nice upstream tarball for you automatically as well
06:15:16 <nomeata> nice
06:15:23 <fridim> i've tried fromIntegral
06:15:30 <edwardk> gah irc client crashed
06:15:32 <quicksilver> well, it's the right answer
06:15:40 <quicksilver> maybe you didn't put it in the right places?
06:15:41 <fridim> But it didn't work. So how to use it?
06:15:50 <CosmicRay> > :t fromIntegral
06:15:51 <lambdabot>  Parse error
06:16:00 <apfelmus> :t fromIntergal
06:16:01 <lambdabot> Not in scope: `fromIntergal'
06:16:03 <apfelmus> ><
06:16:04 <CosmicRay>  (fromIntegral (5::Int))::Float
06:16:07 <CosmicRay> > (fromIntegral (5::Int))::Float
06:16:08 <lambdabot>  5.0
06:16:11 <CosmicRay> that works
06:16:18 <apfelmus> :t fromIntegral
06:16:20 <lambdabot> forall a b. (Num b, Integral a) => a -> b
06:16:43 <edwardk> was starting to say that i'd been doing a bunch of similar transformations using catamorphisms. i wonder if your trick can be adapted to exponential functors or not, i.e. HOAS
06:16:48 <CosmicRay> fridim: consider something: what is the type of [1 .. n] ?
06:16:51 <nomeata> CosmicRay: and I can work directly in the repos specified in ~/.darcs-buildpackage? They are in no way special?
06:17:07 <fridim> so I have to write :  fromIntegral (n :: Int) :: Float ?
06:17:13 <fridim> or simply   fromIntegral(n) ?
06:17:13 <nomeata> CosmicRay: or should I “get” them somewhere else
06:17:16 <CosmicRay> nomeata: yes, you can.  they were originally designed to be helpful for dbp-get, but I have found I rarely use it anyway
06:17:37 <quicksilver> fridim: (fromIntegral n)
06:17:40 <CosmicRay> fridim: show us what you tried with fromIntegral
06:17:54 <fridim> could show me how to use it in my regularPolygon ?
06:17:56 <quicksilver> fridim: and (fromIntegral x)
06:18:20 <quicksilver> fridim: replace every x with (fromIntegral x) replace the second 'n' in the 'v' expression with (fromIntegral n)
06:18:28 <nomeata> CosmicRay: then I have a feature request: i’d like to be able to specify a map of package -> repos, e.g. to keep official and inofficial packages separated.
06:18:48 <nomeata> (Or I adapt to that scheme, no big deal)
06:18:52 <edwardk> gah now is when i wish i had access to haskell at work, i want to try that out =)
06:18:54 <ndm> edwardk: i have no real idea, i don't know much about functors/catamorphisms
06:19:20 <CosmicRay> nomeata: I guess I misspoke, that config is also used for finding the upstream repo with darcs-buildpackage
06:19:31 <CosmicRay> darcs-buildpackage uses your current working directory for the debian repo though
06:19:51 <fridim> mh ok
06:19:52 <edwardk> neil: basic concern is handling things like data Exp = Ap Exp Exp | Lam (Exp -> Exp) where you can see in Lam Exp recurs in a 'negative' position on the left side of the ->
06:19:52 <fridim> It works
06:19:53 <CosmicRay> at least I *think* that's how it works.  I designed hg-buildpackage a bit differently and they are blending together in my mind right now
06:20:00 <CosmicRay> mutt
06:20:03 <CosmicRay> bah
06:20:51 <fridim> Is it not simpler to declare regularPolygon   Num -> Side -> Shape  ?
06:20:56 <quicksilver> ndm: presumably uniplate doesn't do anything to types under (->) ?
06:21:22 <SamB_XP> I want multiplate
06:21:23 <ndm> quicksilver: its not something i've considered, but i'm not sure how it can do - since they aren't accessible while under ->
06:21:36 <ndm> SamB_XP: its called biplate, and its fully described in the paper
06:21:45 <SamB_XP> I'm kidding actually
06:21:51 <SamB_XP> @go uniplate
06:21:56 <lambdabot> http://www.applegate.co.uk/company/11/88/494.htm
06:21:56 <lambdabot> Title: Uniplate Ltd
06:21:59 <SamB_XP> hmm.
06:22:06 <SamB_XP> not quite what I was hoping for ;-)
06:22:10 <quicksilver> @where uniplate
06:22:10 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
06:22:16 <ndm> edwardk: you may be able to define a variant that composes the transformation in to the function, but not sure if it would work
06:22:30 <ndm> i've just asked the HW chair if releasing the paper with teh library is acceptable while also submitting to HW
06:22:40 <ndm> if it is, i'll announce friday evening with a copy of the paper as well
06:22:44 <edwardk> neil: the trick to get at them involves fiddling with the problem domain a bit, stephanie weirich has a sort of paper-in-progress on the topic, there is an older paper by fegaras and sheard on revisiting catamorphisms, and meijer and hutton have the original work
06:23:36 <edwardk> er to get at them meaning to get at the contents of the (Exp -> Exp)
06:23:38 <SamB_XP> ndm: why does it have a notepad icon next to the link to the paper?
06:24:05 <SamB_XP> wouldn't an, uh, internet explorer "HTML document" icon be more appropriate ;-)?
06:24:21 <nomeata> CosmicRay: doing it this way, upstream changes will end up in .diff.gz until they are tagged with a new release. But that is not a problem...
06:24:43 <ndm> SamB_XP: its a manual, thats what i picked for my manual icon - it could certainly be better!
06:25:12 <ndm> edwardk: i've not really looked at that at all, its not my area, and wasn't necessary to how i use uniplate - but hte ideas may carry accross
06:26:27 <CosmicRay> nomeata: correct
06:27:00 <edwardk> neil: fair enough, i'm just wrestling with a similar set of issues using HOAS, currently i jump through hoops to get a zipper to walk through the representation, just think that for some traversals your approach is a lot cleaner.
06:27:22 <ndm> edwardk: have you got a copy of the paper?
06:27:30 <edwardk> paper?
06:27:44 <edwardk> all i have is your manual on the page you linked a half hour ago or so
06:28:19 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/
06:28:22 <lambdabot> Title: Index of /~ndm/temp
06:28:26 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/uniplate-draft.pdf
06:28:41 <SamB_XP> ndm: ... why don't you link it from the uniplate page?
06:28:43 <ndm> edwardk: thats the paper that fully describes the libary, read that for details and discussion of everything
06:29:04 <ndm> SamB_XP: because its going to be submitted tomorrow, and i haven't announced uniplate yet - i will once everything is in place
06:29:28 <edwardk> k
06:29:34 <SamB_XP> oh. then explain how we are talking about it on IRC?
06:29:42 <edwardk> =)
06:30:34 <ndm> IRC /= real world
06:30:44 <SamB_XP> you seem to have mentioned it as many as 9 days ago?
06:30:54 <ndm> i've had the library for over a yaer, in various forms
06:31:05 <ndm> i just got an email back, the paper will be linked to from my website tomorrow evening
06:33:03 <SamB> @localtime ndm
06:33:04 <lambdabot> Local time for ndm is 14 June 2007 2:32:12 pm
06:35:48 <nomeata> Is there a way to specify _darcs/prefs/email per default somehow?
06:35:57 <nomeata> So that I do not have to set it for each darcs repository I create?
06:39:01 <takamura> hi
06:40:16 <nomeata> CosmicRay: works nicely, result in http://darcs.nomeata.de/. thanks!
06:40:17 <lambdabot> Title: Index of /
06:42:24 <CosmicRay> nomeata: glad to hear it
06:47:49 <vincenz> Anyone have any interesting exampl to show recursion
06:48:06 <nomeata> vincenz: see this example
06:48:19 <opqdonut> nomeata: :P
06:48:27 <vincenz> nomeata: I meant in haskell code
06:48:43 <nomeata> vincenz: let example = example
06:48:44 <nomeata> :-P
06:48:48 <vincenz> ..
06:48:50 <opqdonut> ?src fix
06:48:50 <lambdabot> fix f = let x = f x in x
06:48:50 <nomeata> ok, here is a serious one:
06:48:51 <ndm> vincenz: ackermanns, map, repeat
06:48:57 <ndm> @src repeat
06:48:57 <lambdabot> repeat x = xs where xs = x : xs
06:49:00 <vincenz> ndm: map /repeat require datatypes
06:49:01 <opqdonut> ?src map
06:49:01 <lambdabot> map _ []     = []
06:49:01 <lambdabot> map f (x:xs) = f x : map f xs
06:49:03 <nomeata> allright, there are some
06:49:12 <ndm> vincenz: church encode them
06:49:17 <vincenz> as for ack
06:49:23 <vincenz> ac can't be tail-callized
06:49:26 <ndm> vincenz: fib?
06:49:29 <vincenz> idem
06:54:04 <vincenz> see
06:54:06 <vincenz> not that easy :/
06:56:52 * vincenz just does nsum
06:56:54 <vincenz> nsum 0 = 0
06:56:59 <vincenz> nsum n = n + nsum (n-1)
07:00:05 <quicksilver> if you rule out data types, then you only have the natural numbers
07:00:15 <quicksilver> which is a pretty  boring type, so you're going to get b oring functions
07:00:20 <quicksilver> (with apologies to number theorists)
07:00:22 <opqdonut> well, ackermann
07:00:52 <Japsu> nsum = foldr (+) [1..n]
07:00:58 <Japsu> ^_______^
07:01:18 <Japsu> + n
07:01:26 <Japsu> > let nsum n = foldr (+) [1..n] in nsum 3
07:01:27 <lambdabot>   add an instance declaration for (Num [t])
07:01:27 <lambdabot>     In the expression: let nsum n...
07:01:36 <Japsu> :o
07:01:39 <Japsu> evil
07:01:45 <vincenz> quicksilver: yah
07:01:56 <vincenz> Japsu: what's your point about nsum
07:02:00 <opqdonut> nsum n = n*(n+1) `div` 2
07:02:01 <opqdonut> :P
07:02:02 <vincenz> quicksilver: I made it 'interesting'
07:02:05 <Japsu> opqdonut: lol
07:02:13 <vincenz> quicksilver: I only allow inc and dec as primitive operations
07:02:33 <moonlite> > let nsum n = sum [1..n] in nsum 3
07:02:35 <lambdabot>  6
07:02:49 <vincenz> thank you for the pointless golf
07:02:55 <Japsu> vincenz: absolutely no point whatsoever!
07:02:59 * vincenz is trying to introduce 'interesting' recursion without datatypes
07:03:14 <vincenz> btw
07:03:15 <opqdonut> vincenz: well ackermann is doable with only inc, dec and numbers
07:03:18 <vincenz> what are some other names
07:03:27 <vincenz> opqdonut: yeah, but it is not possible to make it tailcall
07:03:32 <vincenz> I have added fib , which is more known
07:03:36 <vincenz> and then nsum1 and nsum2
07:03:36 <opqdonut> of course not :)
07:03:39 <vincenz> one being tailcall
07:03:49 <vincenz> the one being 2
07:04:01 <vincenz> btw
07:04:05 <opqdonut> the point of ackermann is that it is not primitive recursive
07:04:09 <vincenz> other names for variant type and sum type include?
07:13:05 <edwardk> vcincenz: discriminated union?
07:13:35 <vincenz> nod
07:13:47 <edwardk> thats bout all i got ;)
07:14:44 <vincenz> tagged union
07:14:47 <vincenz> algebraic data type
07:17:24 <vincenz> anyone have an interesting datatype that has no parameters
07:17:31 <vincenz> (and is not predefined, or I'd use Bool)
07:17:40 <quicksilver> data Color = Red | Green | Blue ?
07:17:49 <vincenz> yeah, have that one, but not interesting
07:17:50 <vincenz> besides
07:17:51 <vincenz> before I show em
07:18:01 <vincenz> data Tree a = Leaf | Branch a (Tree a) (Tree a)
07:18:21 <vincenz> I'd like to show one that a) doesn't have parameters, b) doesn't have recursion, but c) does have memberfields
07:18:23 <quicksilver> data Language = English | Welsh | French | Klingon
07:18:37 <quicksilver> ah, *does* have fields
07:18:46 <[LeCamarade]> Am I the only one who thinks it is irredeemably ashaming that some languages call function overloading a feature, as though Hindley-Milner is a jazz band?
07:18:47 <quicksilver> I assumed that's what you meant by 'parameters'
07:19:07 <vincenz> [LeCamarade]: You mean like typeclasses?
07:19:19 <vincenz> quicksilver: no I meant the 'a' bit after the typeconstructor name as parameters :)
07:19:27 <quicksilver> vincenz: they're not datatypes, technically
07:19:32 <quicksilver> vincenz: that's why I didn't see what you meant
07:19:53 <quicksilver> anyhow, data Color = RGB Int Int Int | CYMK Int Int Int Int ?
07:20:08 <LeCamarade> vincenz: No. The Other Languages. Not This Language.
07:20:35 <quicksilver> data Statement = Assign String Value | Print Value
07:21:09 <vincenz> LeCamarade: Oh, like modules in ml?
07:22:04 <LeCamarade> vincenz: No those are better. Like function/method over-loading in C++ and Java. They skirt around a problem (still alive in C) that the Hindley-Milner type system doesn't even know about. :o)
07:22:15 <vincenz> LeCamarade: Oh, like object-subtyping in ocaml
07:22:59 <LeCamarade> Object-subtyping?
07:23:09 <vincenz> the 'o' part of ocaml
07:23:18 * LeCamarade uses functors and modules in OCaml - OOP is a mistake in OCaml. It is not necessary.
07:23:29 <vincenz> it is done by their inference engine tho
07:23:38 <vincenz> and "xxx is a mistake in yyy" is a mistake in english
07:24:06 <vincenz> oop has it's purposes
07:24:14 <LeCamarade> vincenz: Yes, but I must tell you I only do OCaml objects when I do F#, which can't escape them. Otherwise if OCaml code uses objects, it is wrong code.
07:24:20 <vincenz> LeCamarade: right
07:24:26 <vincenz> LeCamarade: notice how your phrase says
07:24:32 <vincenz> "but *I* must tell you *I* only ..."
07:24:50 <jacquesm1rde> @src case
07:24:50 <lambdabot> Source not found. Are you on drugs?
07:25:04 <jacquesm1rde> @src drugs
07:25:04 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
07:25:24 <visage> Pardon my ignorance, I am a very big OCaml noob (just waded from the SML sea) -- how does pattern matching on objects work?
07:25:36 <visage> Whoops, wrong channel
07:25:37 <vincenz> visage: not sure you acn pattern-match on em
07:25:39 <visage> Sorry Haskell gents
07:25:45 <LeCamarade> vincenz: Yes, *I*. I have a very idiosyncratic programming style, influenced by Haskell, Forth and other things, and no Java in sight.
07:26:01 <vincenz> LeCamarade: and you are the guru we should all listen to that has solved all CS problems in existence?
07:26:13 * LeCamarade goes to #ocaml to help the OCaml guy.
07:26:15 <vincenz> LeCamarade: OOp has it's place, as does FPL and logic programming and others
07:27:10 <LeCamarade> vincenz: No, my views affect mainly my code alone.
07:27:26 <vincenz> LeCamarade: then stop phrasing them as if they were absolute truths
07:27:48 <quicksilver> surely it's obvious that what LeCamarade says is his opinion?
07:27:52 <quicksilver> it's obvious to me
07:28:15 <LeCamarade> vincenz: Yeah, alright. I'll start putting `IMHO' before every opinion. :o)
07:28:21 <vincenz> " LeCamarade uses functors and modules in OCaml - OOP is a mistake in  OCaml. It is not necessary."
07:28:33 <vincenz> that was a very non-subjective statement, imho
07:28:45 <vincenz> especially the bit after the -
07:28:56 <quicksilver> nonetheless, it's clearly his opinion, because he said it
07:29:03 <vincenz> quicksilver: you are wrong
07:29:07 <vincenz> (point in case)
07:29:15 <quicksilver> this channel is a nice friendly place, let's preserve that
07:29:28 * vincenz returns to his slides
07:29:53 <desp> OOP in OCaml is kind of painful
07:29:55 <LeCamarade> vincenz: Yeah. That's what happens even when we express views on freedom of expression and democracy and the like.
07:30:10 <desp> I can never remember the exact inheritance rules
07:30:45 <desp> so even if LeCamarade's opinion isn't an absolute truth, I share it
07:30:46 <desp> ;)
07:31:33 <sjanssen> @quote
07:31:34 <lambdabot> edwinb says: I think I'd panic if I had to write something that wasn't a compiler.
07:32:09 * edwinb feels his ears burning
07:33:00 <LeCamarade> There was this thing I read in The Monad.Reader, about a company that used OCaml. And the guy let out one of the most-fulfilling tirades against objects in OCaml.
07:33:37 <LeCamarade> I've never seen code that relies on OCaml objects, for one (not looking at that much, though). Except in F#, where I use them every two lines.
07:34:23 <vincenz> LeCamarade: And there was a lovely presentation by the famous game-writer whose name I forgot giving a reason -for- objects, what's your point?
07:34:26 <vincenz> LeCamarade: domains differ
07:34:41 <desp> vincenz: I do believe LeCamarade isn't against OOP in general
07:35:15 <sjanssen> pssh, all concrete data sucks
07:35:18 <LeCamarade> vincenz: Maybe I just need some sleep. :o(
07:35:25 <sjanssen> we should all be church encoding our data!
07:35:40 <vincenz> LeCamarade: idem
07:35:57 * vincenz church-encodes sjanssen into |_|
07:35:58 <vincenz> erm
07:35:59 <vincenz> _|_ :)
07:36:11 <desp> into a shot glass? :)
07:36:16 <vincenz> :D
07:36:53 <vincenz> LeCamarade: they have a bit of an abhorrent syntax, and yes, the afact that you have to cast explicitly is a pain.  But that being said, saying that oop in general is wrong in ocaml, as paradigm is a strong statement
07:37:03 <LeCamarade> vincenz: You do juggle channels! I see you this end ... and this end.
07:37:08 <vincenz> s/wrong commas/good comams
07:37:19 <vincenz> LeCamarade: was just answering visage there
07:37:27 <vincenz> LeCamarade: I left that channel a long time ago due to a certain element
07:38:27 <LeCamarade> vincenz: There's Yet Another Anti-OOP Tirade on that side now. Hmm. To stay neutral, I choose type classes.
07:38:29 <LeCamarade> :o)
07:38:39 <vincenz> LeCamarade: right, typeclasses + existentials = oop
07:38:56 <LeCamarade> flux: Yeah. Like when you do F#.:o)
07:39:22 <vincenz> LeCamarade: flip channel
07:39:33 <LeCamarade> OOPs.
07:39:55 <LeCamarade> Thing is, I have always suspected they were added because they were a buzzword.
07:39:57 <quicksilver> I've yet to be shown a real program for which I felt ocaml-style OO was the best solution
07:40:06 <quicksilver> I've always felt I could do better without
07:40:11 <vincenz> LeCamarade: then why is haskell adding existentials, which is oop in another form
07:40:14 <quicksilver> but that doesn't mean such program don't exist
07:40:22 <vincenz> LeCamarade: at some point, you need that sort of loose binding
07:41:20 <LeCamarade> OOP is good. Especially when you are being imperative. In fact, one can't write 10 lines of imperative code without wishing for an OO system.
07:41:39 <vincenz> LeCamarade: oop is also good when yuor system is inheritently based around objects
07:41:42 <vincenz> for instance, a mud engine
07:41:44 <LeCamarade> Once you have two functions manipulative one cell of data, now you need an object system.
07:42:01 <vincenz> (or most games for that matter)
07:42:04 <roconnor> OOP = MonadState ?
07:42:12 <vincenz> roconnor: oop = existential + TC
07:42:25 <roconnor> what is TC?
07:42:32 <vincenz> LeCamarade: and some oops are even side-effect free, so not imperative at all
07:42:34 <vincenz> roconnor: typeclasses
07:42:39 <roconnor> ah
07:42:55 <vincenz> iirc, ocaml objects can be made lightweght in that sense
07:43:11 <LeCamarade> Whenever I have played this silly game where I see code and try to refit it with OCaml/Haskell, I end up using type classes/(modules + functors) && recursive data types and the like. And it works, often very impressively well for a translated concept.
07:43:48 <vincenz> LeCamarade: a typical example where you might like objects better, is if you have many different types of obejects that can all be in a container (for instance a room) that obey to some interface
07:43:49 <pejo> vincenz, lots of things can be modelled as objects in quite a clear way. Not necessarily with (implementation-) inheritance.
07:43:59 <vincenz> at that point oop is better than a very large adt
07:44:03 <vincenz> cause when you add new objects
07:44:12 <vincenz> you have to break your adt up and all your patternmatchers
07:44:17 <quicksilver> "that kind of oop" is just type classes though
07:44:19 <vincenz> I remember this webpage
07:44:24 <LeCamarade> vincenz: And modules + functors + sig-end interfaces. Just as good.
07:44:32 <vincenz> FP: easy to add more methods, OOP: easier to add more objects
07:44:37 <vincenz> LeCamarade: not really
07:44:39 <vincenz> LeCamarade: simple example
07:44:41 <fasta> I constructed a value of type ST s String. I would like to get the String value out of it while escaping the ST monad. The way the String is constructed is via read only operations, so AFAIK, it should be safe. There must be some way to get rid of the ST layer, just like unsafePerformIO.
07:44:42 <vincenz> assume you have your game
07:44:46 <fasta> How?
07:44:51 <vincenz> data Object = Enemy | Friend | Gun
07:44:56 <vincenz> you have different functions that work on this
07:45:02 <vincenz> lie a display, something to show poitns, etc,etc
07:45:06 <vincenz> now you add another object
07:45:08 <vincenz> Barrel
07:45:11 <vincenz> you get to break open ALL of your code
07:45:17 <vincenz> cause you use an FP instead of OOP approach
07:45:48 <vincenz> seriously, each paradigm has its domain where it is most useful
07:46:02 <visage> Which is why I think more languages should strive to provide both!
07:46:10 <vincenz> visage: 'xactly
07:46:21 <visage> goddamnit, I will figure out an effective way to create pattern matching on objects
07:46:30 <kpreid> fasta: um, return it from runST?
07:46:33 <vincenz> visage: patternmatching on objects is wrong
07:46:34 <visage> I created a hackety version in Ruby, but designing a language around the paradigm would be cool.
07:46:46 <quicksilver> fasta: why don't you just runST t?
07:46:48 <vincenz> visage: patternmatching is something that will have to be broken open again, like the example showed here with datatype
07:46:55 <fasta> kpreid: howly cows, I am asleep.
07:47:02 <vincenz> visage: the idea of objects is that disptach is done on methodcall, NOT, with patternmatch
07:47:08 <fasta> kpreid: thanks
07:47:18 <LeCamarade> vincenz: Indeed. For example, good luck doing idiomatic FP on .NET. The whole system is built to be imperative. So 90% of the OCaml I've written as F# uses OOP very, very intimately.
07:47:54 <vincenz> LeCamarade: that's just a factor of mismatch
07:47:55 <visage> vincenz: indeed, but why not define an object as several possible structures (or datatypes)?
07:48:05 <SamB> LeCamarade: what about my x86
07:48:15 <SamB> it seems to also be built for imperative programming
07:48:15 <vincenz> it has nothing to do with the inherent properties of a problem domain, but more with the deficiencies of a compiler/interpreter/runtime framewokk
07:48:27 <vincenz> visage: that is feasible, if you do not foresee adding new object 'types' soon
07:48:47 <SamB> visage: it would be more fun to use an algebraic datatype
07:49:06 <vincenz> look, it's not hard ... patternmatch = methoddispatch.  Plan on adding new objects/datatconst ofte: go for oop.  Plan on adding new functions/methods often: go for FP
07:49:11 <SamB> it's kinda funny how ADT can mean either algebraic datatype or abstract datatype
07:49:17 <LeCamarade> SamB: Also imperative. I've always thought of FP as an elevated thing. More-removed from the bare metal. Although the steamy dreams about a functional bare-metal language.
07:49:21 <visage> You know, FP chat rooms have much more interesting discussions than the drivel in those 'main-stream' languages
07:50:08 <fasta> visage: just wait 5 years, it will become as bad here as there.
07:50:14 <SamB> visage: well, sometimes we talk about Haskell in ##c...
07:50:15 <visage> noooo!
07:50:19 <visage> say it ain't soooo!
07:50:40 * vincenz keeps his channel #oasis as a general PL discussion channel that is PL agnostic :)
07:50:42 <SamB> fasta: nonsense. we just need to keep adding confusing extensions...
07:50:45 <byorgey> fasta: I don't know, I kind of doubt it
07:51:01 <LeCamarade> byorgey: I kind of think it will happen.
07:51:11 <desp> LeCamarade: functional bare-metal language? like Lisp on that IBM?
07:51:18 <roconnor> Or we can move to #coq or #epigram
07:51:25 <vincenz> roconnor: or BF
07:51:40 <LeCamarade> desp: That Lisp and the IBM where built for each other, which disqualifes it.
07:51:50 <fasta> If we move to #fjlkfjdfjlfjhlfsdlkfhsdfhsdaflsdfhsjdkfdfsfsd nobody will follow us :)
07:52:02 * LeCamarade was writing a functional Forth to try the idea, and it exploded in his face.
07:52:26 <LeCamarade> @remeber fasta If we move to #fjlkfjdfjlfjhlfsdlkfhsdfhsdaflsdfhsjdkfdfsfsd nobody will follow us :)
07:52:26 <lambdabot> Done.
07:52:28 <vincenz> fasta: signal-to-noise ratio is a function that is not purely decreaasing or increasing in terms of the users... it definitely has a peak somewhere at a place > 1 user
07:52:39 <SamB> fasta: but we won't remember the name if we do that
07:53:05 <SamB> if we make it hard to do anything without knowing what you are doing, we should be okay
07:53:52 <byorgey> SamB: see, that's why I think we're already okay
07:53:53 <SamB> (of course, the best way to do that is to make it so that you figure out what you are doing when you try to do something, but you aren't sure what that is ;-)
07:53:54 <geezusfreeek> ah, somebody is afraid to let go of some of the stuff he learned as an OO programmer
07:54:09 <SamB> geezusfreeek: not afraid
07:54:12 <SamB> exactly
07:54:13 <MyCatVerbs> SamB: I've often wondered if that is the whole rationale behind continuations. Yes, they do allow you to write all the same spaghetti code that you would otherwise write using gotos. However, they're a hard enough concept that only fairly smart people appear to ever use them.
07:54:14 <geezusfreeek> but i'm not gonna get into it today… i have lots of work to do
07:54:20 <cjeris> @remember vincenz data Object = Enemy | Friend | Gun
07:54:20 <lambdabot> Done.
07:54:24 <SamB> unwilling to discard useful techniques
07:54:37 <cjeris> vincenz: that's an admirably straightforward worldview :D
07:54:40 <vincenz> geezusfreeek: if you're referring to me...
07:54:41 <geezusfreeek> hahaha
07:54:43 <SamB> ... because they really would be a nice fit
07:54:46 * vincenz hasn't touched OO in a -long- time
07:54:54 <SamB> I thought he menat visage
07:54:56 <vincenz> geezusfreeek: but I'm against people that push purely one paradigm, as they -all- have a plce
07:55:00 <vincenz> oh
07:55:05 <geezusfreeek> vincenz: looks to me like you are using FP as OO anyway
07:55:16 <vincenz> geezusfreeek: no, I was claiming that in that case, one should use OO
07:55:19 <vincenz> geezusfreeek: read backscroll
07:55:36 <geezusfreeek> (i've made the claim before too, so i know where you are coming from)
07:55:40 <SamB> maybe he would like to do some of that here and there
07:55:46 <geezusfreeek> i've since retracted the claim though
07:55:46 <SamB> but it's not terribly easy
07:55:48 <vincenz> cjeris: the funny thing is, I don't live in the US or am a redneck, it was referring to a game engine
07:55:52 <geezusfreeek> but like i said, i'm not getting into it :)
07:55:56 <vincenz> nod
07:55:59 <visage> geezusfreeek: actually, it depends on the problem.  I learned the non-OO way first, so OO isn't exactly implemented in me.
07:56:10 <SamB> geezusfreeek: are you asserting that an O(n^2) cost is justified?
07:56:11 <cjeris> vincenz: oh, I didn't mean to impute either to you -- it's still funny
07:56:16 <vincenz> :D
07:56:23 <SamB> where n is the number of kinds of things you have in your game?
07:56:43 <MyCatVerbs> SamB: sure, why not?
07:57:19 <geezusfreeek> SamB: that would depend on how crazy your game is :)
07:57:25 <MyCatVerbs> SamB: just write a game composed entirely of boss fights. Then you'll only ever have *two* objects in the field. One player, one f---ing huge monster. Scaling problems? Heehee, what scaling problems?
07:57:31 <LeCamarade> Yeah, OOP has deep necessities that solve problems, which problems fade a lot the closer you get to pure functional programming (since, for example, properties are variables, which Haskell doesn't have). But if you're somewhere between C and Haskell (think OCaml/F#) you'll need OOP to some degree.
07:57:36 <vincenz> MyCatVerbs: no, you forgot the gun
07:57:43 <vincenz> MyCatVerbs: data Object = Friend | Enemy | Gun
07:58:52 <MyCatVerbs> vincenz: nahhh. Guns are for people who can't be arsed to rend their enemies unto tiny pieces by hand.
07:59:44 <cjeris> MyCatVerbs: Samus Aran would like to have a word with you outside
07:59:52 <LeCamarade> @remember MyCatVerbs nahhh. Guns are for people who can't be arsed to rend their enemies unto tiny pieces by hand.
07:59:52 <lambdabot> Done.
07:59:57 <byorgey> data Object = Friend | Enemy | EnemyRentUntoTinyPieces
08:00:00 <geezusfreeek> i chew my enemies into mulch very slowly starting with their toes
08:00:04 <LeCamarade> cjeris: :oD
08:00:17 <LeCamarade> @quote guns
08:00:18 <lambdabot> MyCatVerbs says: nahhh. Guns are for people who can't be arsed to rend their enemies unto tiny pieces by hand.
08:00:28 <vincenz> @quote denotational
08:00:28 <lambdabot> vincenz says: Binkley: the sex is all in the operational semantics, denotational semantics only deals with love
08:00:41 <geezusfreeek> :o
08:00:41 <vincenz> just to pull an old one back up :D
08:00:41 <LeCamarade> :o)
08:00:53 <LeCamarade> @quote ribbing
08:00:53 <lambdabot> JohnMeacham says: Last night I was at this dive bar listening to live music and there was this cute girl I was talking too while this guy was there, we started ribbing each other in the appropriate
08:00:53 <lambdabot> way when confronted with the situation of two guys talking to the same girl, and our jeers eventually turned technical until we were arguing about haskell, perl, and pugs development. it turning out
08:00:53 <lambdabot> he was one of the pugs de
08:00:57 <MyCatVerbs> cjeris: hrmn. Well, Samus never actually leaves the gun or the suit or anything behind, so there's no particularly pressing need to track it seperately.
08:01:07 <LeCamarade> I hate it that it is incomplete. :o(
08:01:16 <vincenz> what is 'ribbing'
08:01:27 <LeCamarade> I dunno! That's why I like it!
08:01:28 <MyCatVerbs> vincenz: taking the piss, making snide comments.
08:01:44 <vincenz> at first I thought it referred to those things they put on the outside of some condoms
08:01:45 <LeCamarade> Lets me invent what ribbing is, depending ..
08:01:51 <MyCatVerbs> vincenz: insulting banter, generally.
08:03:18 * vincenz ribs MyCatVerbs 
08:03:46 <MyCatVerbs> ...
08:03:57 <vincenz> anywho, anyone have a good (very simple) model of a stack machine
08:03:58 <MyCatVerbs> That is not how one enacts that verb.
08:04:54 <MyCatVerbs> What, as in a Forth interpreter? LALR parser?
08:05:59 <vincenz> much much simpler
08:06:21 <vincenz> nm
08:06:48 <beelsebob> vincenz: somewhere I've got code for the SECD machine
08:07:03 <beelsebob> (and the various deconstructions in landin's paper)
08:07:05 <beelsebob> not landin
08:07:13 <beelsebob> who did the rational deconsturction of the machine again?
08:07:53 <beelsebob> olivier danvy
08:07:58 <vincenz> beelsebob: the idea is to introduce people to haskell/FPLs
08:08:19 <vincenz> beelsebob: so I thought a VERY simple machine from math-expressions compiling to a stack machine, and then interpreting it
08:08:24 <beelsebob> oh
08:08:29 <beelsebob> why do you want to compile?
08:08:36 <beelsebob> why not just interpret straight off the bat
08:08:38 <vincenz> to show 'something'
08:08:55 <beelsebob> hmm, fair enough
08:08:55 <vincenz> the point is not the interpreter, it's to show how to use fpl features
08:09:02 <beelsebob> fair enough
08:09:04 <vincenz> (recursion, data types, hof, fcs
08:09:08 * beelsebob might have a nice example of that
08:09:10 * beelsebob goes to look
08:09:42 <beelsebob> I have a Brainfuck interpretter
08:09:47 <beelsebob> that nicely demonstrates a lot of stuff
08:09:47 <vincenz> how big is it?
08:09:52 <beelsebob> but it misses the compile step
08:09:55 <vincenz> (linewise)
08:09:58 <beelsebob> it's 98 lines
08:10:00 <vincenz> hmm
08:10:07 <beelsebob> including comments
08:10:13 <vincenz> beelsebob: monads?
08:10:15 <beelsebob> (although not many comments)
08:10:17 <beelsebob> no monads, no
08:10:22 <vincenz> not even io?
08:10:23 <beelsebob> well, IO in main
08:10:27 <vincenz> right
08:10:32 <vincenz> hmm
08:10:33 <vincenz> sounds interesting
08:10:34 <beelsebob> oh wait
08:10:46 <beelsebob> I have used IO in interpret, but only in a very lose way
08:10:49 <vincenz> nodnod
08:11:04 <beelsebob> hang on, I'll pastebin it for you to stare at
08:11:25 <hpaste>  beelsebob pasted "BF interpretter" at http://hpaste.org/278
08:12:04 <vincenz> thx
08:12:27 * beelsebob goes to see if he has any better examples
08:15:20 <beelsebob> hmm, nothing else really
08:15:23 <beelsebob> I should write one
08:15:26 <beelsebob> as a hat test case
08:15:33 <beelsebob> ohh... cap's interpretter
08:17:02 <hpaste>  beelsebob pasted "Somewhat more complex interpreter" at http://hpaste.org/279
08:17:09 <beelsebob> that may be useful to you too
08:18:39 <vincenz> truth be told, the first one was already too much code
08:18:44 <vincenz> I'm gonna show this on sldes
08:19:01 <vincenz> 1h session to people new to FP
08:19:07 <beelsebob> okies
08:19:33 <beelsebob> I'm afraid I have nothing really useful for you then
08:19:59 <beelsebob> I've been trying to make all my examples slightly more complex, because people keep shooting our papers down saying "yeh, but it won't scale", when it really really does
08:20:12 <beelsebob> the whole point of the approach is that it scales way better than the old versions
08:20:20 * LeCamarade does FP propaganda in C.
08:20:29 <beelsebob> heh
08:20:43 <beelsebob> people here do FP propaganda in a combination of Java and Haskell
08:21:02 <beelsebob> the compilers module had to be taught in java to make up the number of modules with buzzwords in the title
08:21:17 <beelsebob> so the lecturers stick in the 4 line haskell versions after every 50 line java class
08:21:20 <chessguy> 'morning
08:21:37 <LeCamarade> I spent last night writing naive half-assed lambdas in C, and people are floored. `You didn't have to declare the function?'
08:22:27 <visage> LeCamarade, I would love to see that code
08:22:31 <LeCamarade> I tell them to have some Haskell for six months, and they'll puke at every next for loop.
08:22:33 <shapr> beelsebob: Hah
08:22:41 <LeCamarade> visage: It is Python ... the interpreter.
08:22:44 <shapr> LeCamarade: yay!
08:22:57 <visage> Ah, gotcha.
08:23:11 <shapr> It's good to expand the minds of the people around you.
08:23:12 <LeCamarade> shapr: Yay for Python? I thought it was blasphemous to mention them languages here.
08:23:35 <LeCamarade> I did it in Py so they could read the code and get it.
08:24:03 <shapr> Yay for mind expanding.
08:24:09 <LeCamarade> They are really floored - my boss told me to put it in the company's library.
08:24:18 <LeCamarade> As a directive.
08:24:22 <chessguy> LeCamarade, when dealing with mere imperative programmers, anything you can give them helps
08:24:24 <LeCamarade> shapr: :O)
08:24:27 <jfredett> lol
08:24:39 <jfredett> A little anonymous functionizing and there floored...
08:24:45 <shapr> I remember the first time I exposed a bunch of Java-only programmers to Python, they said the things. "Wait, you didn't declare the types... of anything!"
08:25:06 <LeCamarade> jfredett: I told them if they think this is cool, they'll not believe Haskell is real.
08:25:14 * shapr agrees with LeCamarade
08:25:27 <jfredett> lol
08:25:43 <jfredett> I did that to my father (a hardcore C programmer) the other day
08:26:04 <jfredett> I showed him how to do some naive closure stuff in C
08:26:07 <jfredett> w/ function pointers
08:26:14 <jfredett> and he was like, "You can do that?"
08:26:28 <LeCamarade> I mentioned type inference (that my lambdas didn't do it) and they asked what it was. I told them it is like GCC putting the right type for you instead of complaining that you wrote the wrong one. And silence reigned.
08:27:16 <jfredett> heh, silly imperative programmers
08:27:20 <visage> Gotta love that static typing
08:27:50 <cjeris> at one point in 2001 i was working in a C++ shop where for some reason we didn't have an RPC stub compiler for some code we needed to make work over RPC.  so i wrote this awful thing in ocaml that tried to parse our header files and spit out the RPC stubs.  it took about a week and the resulting abomination made everyone else's head explode.  i never want to have to parse C++ again.
08:28:26 <cjeris> it worked though, sort of.
08:29:32 <visage> all I know is that when I moved from function pointers in C/C++ to closures and first order functions in Ruby/SML ... I almost cried
08:29:42 <LeCamarade> cjeris: When you do OCaml, you get all the pluses of C++ (pun intentional, of course) without the minuses.
08:29:46 <shapr> LeCamarade: Reminds me of when my girlfriend started learning programming... A few days into the process of learning Haskell, I compared something to Python and confused her, and after a long explanation she said "How could you write code like that? You'd never be able to trust that a value wasn't changed behind your back when you weren't expecting it!" And I couldn't really disagree.
08:29:52 <visage> and I know I am just skimming the top of the power of the languages
08:30:36 <visage> shapr: I would be afraid to teach my girlfriend to program.  it would make what I do seem a lot less like magic.
08:31:03 <LeCamarade> @remember visage I would be afraid to teach my girlfriend to program.  it would make what I do seem a lot less like magic.
08:31:03 <lambdabot> Done.
08:31:20 <jfredett> lol
08:31:21 <shapr> visage: Programming is the Magic Executable Fridge Poetry, it is machines made of thought, fueled by ideas. :-)
08:31:22 <jfredett> brilliant
08:31:29 <LeCamarade> shapr: It's why I think leaning should be in Haskell.
08:31:45 <DRMacIver> That seems like an odd attitude to me. I'm never comfortable with anything I do being regarded as magic.
08:31:45 <lambdabot> DRMacIver: You have 2 new messages. '/msg lambdabot @messages' to read them.
08:32:00 <Nafai> I wish my wife understood what I did
08:32:07 <fasta> ALSA is magic for me.
08:32:11 <LeCamarade> Some months ago, I argued with some guy in here literally to death over Haskell being a first language, saying it was a bad thing. I don't remember who he is - I'd like to tell him I'm a lot smarter now.
08:32:12 <fasta> I don't like that.
08:32:15 <visage> Well, let me put it to you guys this way -- I have gone to two schools, RIT and Cornell.  At RIT, they tried to teach us in Java.  At Cornell, they taught us in SML.  Cornell is ranked 5th in the US for CS, RIT is ranked as god-only-knows what.
08:32:38 <quicksilver> LeCamarade: you could grep for yourself through the logs and find out :)
08:32:50 <DRMacIver> visage: That's quite interesting, given that a lot of what Cornell does research wise seems rather Java centric.
08:33:00 <DRMacIver> (Or at least I got that impression when I was looking at their PhD program)
08:33:00 <quicksilver> LeCamarade: although if it as literally to the death, he's now dead. So it's a bit late for him :(
08:33:05 * shapr laughs
08:33:08 <LeCamarade> quicksilver: If it's more than a monad away, it is too much work. Being lazy with class, you know.
08:33:20 <shapr> LeCamarade: It's only one parser monad away!
08:33:34 <DRMacIver> (Cambridge does SML in the first term then Java in the second I think)
08:33:49 <visage> DRMacIver: Couldn't tell ya.  Not from what I have experienced.
08:33:57 <ndm> York does Lisp then Ada, and yet its still a good university
08:34:05 <ndm> its not necessarily correlated
08:34:26 <DRMacIver> ndm: Lisp then Ada seems a rather good selection actually.
08:34:31 <LeCamarade> UNSW does Haskell, I'm led to believe?
08:34:33 <Wild_Cat> ndm: depends. You usually have an edge if you're able to learn a new language by yourself.
08:34:54 <Wild_Cat> which you pretty much have to do when all you know is Lisp and Ada.
08:34:57 <ndm> DRMacIver: never used Ada, I assume?
08:35:15 <ndm> Wild_Cat: yes, later courses are taught with Java and C, but the languages are not taught - you are assumed to be able to pick anything up
08:35:25 <DRMacIver> ndm: Well I've used a language with Ada derived syntax (which throws away all the advantages of Ada, but never mind).
08:35:26 <Wild_Cat> QED
08:35:37 <LeCamarade> Wild_Cat: Exactly. After I discovered FP, especially Haskell, I started suspecting all obscure languages of hiding some nice *insert perverse interest*.
08:35:42 <DRMacIver> ndm: But you're right. I was more commenting on the LISP than on the Ada. :)
08:36:17 <ndm> DRMacIver: Ada == the suck, if you want Dykstra's opinion on Ada, its online - but its a lot better than my opinion
08:36:26 <ndm> Scheme, rather than Lisp, actually
08:36:33 <ndm> but it is a nice language to start with
08:36:49 <quicksilver> well "good" undergraduate course is not very tightly correlated with "good research department"
08:36:55 <DRMacIver> Scheme is an even better choice than lisp. ;)
08:36:56 <quicksilver> I meant, they're not unrelated either, but...
08:38:09 <DRMacIver> ndm: Doesn't dijkstra hate everythign though? ;)
08:38:43 <ndm> quicksilver: they are reasonably close
08:39:03 <ndm> DRMacIver: yes, he does - maybe its more relevant that I hate Ada, but like things like C#/Javascript
08:39:51 <LeCamarade> DRMacIver: No, everything is considered harmful. :o)
08:39:53 <ndm> i sat the undergrad open assessment, i could have done it in 20 minutes with any sensible language (Javascript, C#, C, C++, Python, Haskell...), but it took me over 6 hours in Ada
08:40:02 <quicksilver> ndm: well Queen Mary, say, has lower undergraduate entry requirements and therefore less advanced undergraduate classes
08:40:34 <DRMacIver> LeCamarade: Heh. True.
08:40:46 <sphynx> hi all
08:41:14 <quicksilver> ndm: but still has a world-class research dept
08:41:31 <fasta> How can I get vertical separation in Text.PrettyPrint? The only thing that works is text "foo" <> text"\n". text "bar" $$ PP.empty doesn't work.
08:41:42 <shapr> Students are the one case where I don't prefer lazy evaluation... I wish more of them would be self motivated to learn programming on their own. Then the quality of the courses at their school wouldn't make such a difference.
08:41:51 <sphynx> is there some way to work with strings in UTF-8?
08:42:17 <sphynx> fasta: you can use vcat for [Doc]
08:42:23 <quicksilver> sphynx: the more normal thing to do is read UTF-8, store it internally as unicode, and write to UTF-8 afterwards
08:42:24 <sphynx> or <+>
08:42:25 <fasta> sphynx: yes, I know that.
08:42:32 <fasta> sphynx: no that is not possible
08:42:47 <quicksilver> sphynx: you won't find ncie functions for working with UTF8 in a [Word8], though
08:42:50 <fasta> sphynx: Have you used the libary in the first palce?
08:42:57 <fasta> sphynx: place*
08:43:09 <fasta> sphynx: if not, please do not answer next time.
08:43:20 <sphynx> fasta: Now I'm using it for creating my list printer
08:44:00 <DRMacIver> shapr: Lazy evaluation of knowledge works quite well if you can achieve a decent performance once you actually need to evaluate it. :)
08:44:09 <nomeata> CosmicRay: some suggestion: could darcs-buidpackge either pass -uc -us to debuild OR run dbp-debmark, so that released (=signed) builds are always tagged?
08:44:26 <nomeata> CosmicRay: and dbp-debmark should warn about unrecorded changes.
08:45:08 <sphynx> quicksilver: I need to do BS.split for unicode
08:45:24 <ndm> quicksilver: there is definately a correlation, i guess its not perfect though
08:47:02 <quicksilver> sphynx: you're best converting it from UTF8 to a 1-char-per-unit representation whilst it's in the BS
08:47:10 <quicksilver> sphynx: check out compactstring, perhaps
08:48:02 <sphynx> fasta: so have you tried <+>?
08:48:13 <sphynx> quicksilver: OK, I will take a look, thanks!
08:51:39 <sphynx> quicksilver: hm, I've not found compactString in standard packages
08:51:46 <sphynx> ?hoogle CompactString
08:51:48 <lambdabot> No matches found
08:51:54 <quicksilver> @where Compacttring
08:51:54 <lambdabot> I know nothing about compacttring.
08:51:59 <quicksilver> @where CompactString
08:51:59 <lambdabot> I know nothing about compactstring.
08:52:02 <quicksilver> bah
08:52:04 <sjanssen> @hackage compactstring
08:52:04 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/compactstring
08:52:30 <sjanssen> wha?  It's not on hackage?!
08:52:40 <quicksilver> @where+ compactstring http://twan.home.fmf.nl/compact-string/
08:52:40 <lambdabot> Done.
08:53:08 <sphynx> oh, thanks!
08:56:17 <fasta> What is the point of the semantics of $$?
08:56:29 <quicksilver> :t ($$)
08:56:29 <fasta> It seems rather _pointless_ to me.
08:56:31 <lambdabot> Doc -> Doc -> Doc
08:56:50 <fasta> I can't imagine one case where it would be useful.
08:57:02 <fasta> I just want to have one document and place another below it.
08:57:07 <fasta> I.e. compile to a new line.
08:57:20 <fasta> I can easily do that, but the library doesn't even offer that.
08:57:30 <fasta> It does offer "colon", etc.
08:57:31 <emu> huh? i use $$ all the time
08:57:46 * Igloo doesn't understand the question either
08:57:46 <fasta> It indents the expression below it
08:57:51 <Igloo> No it doesn't
08:57:58 <fasta> Then it must be a bug
08:58:12 <fasta> Or I made a mistake
08:58:15 <Igloo> The second argument will have the same identation as the first
08:58:29 <emu> $$ (nest ...) would
08:58:45 <Igloo> You might have done    foo <> (bar $$ baz)   or something?
08:59:01 <Igloo> In which case you'd want (foo <> bar) $$ baz
08:59:13 <fasta> Igloo: possiblly, good pointer. I will check it.
08:59:18 <fasta> possibly*
08:59:30 <emu> i'm lokoing at some code which does:  some items in the document $$ other items in the document at the same level
09:00:00 <quicksilver> '$$' is for doing tricks like 'combining opening ( onto the same line'
09:00:07 <quicksilver> as some LISP pretty printers do
09:00:11 <quicksilver> or that's my understand
09:00:38 <quicksilver> so if you have "<10 spaces> (" and "<12spaces> ("
09:00:52 <fasta> Igloo: I don't use parentheses in that way.
09:00:53 <quicksilver> you get "<10 spaces> ( ("
09:00:56 <fasta> brb
09:00:57 <Thunder> So the new UrlCheck is ready: http://www.iks-jena.de/mitarb/lutz/haskell/urlcheck-0.0.tar.gz
09:01:15 <Igloo> fasta: You can get the same effect without using explicit parens
09:17:06 <chessguy> @hoogle ($$)
09:17:07 <lambdabot> Did you mean: ($$)
09:17:07 <lambdabot> Prelude.undefined :: a
09:17:07 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
09:17:24 <quicksilver> chessguy: Text.PrettyPrint.$$
09:17:27 <chessguy> @hoogle Doc
09:17:27 <lambdabot> Text.PrettyPrint.HughesPJ.Doc :: data Doc
09:17:27 <lambdabot> Language.Haskell.TH.PprLib.Doc :: type Doc
09:17:27 <lambdabot> Language.Haskell.TH.PprLib.to_HPJ_Doc :: Doc -> Doc
09:22:22 <jacquesm1rde> which is more rigorous, the main haskell wikibook or yaht?
09:24:37 <SamB> @pl liftM sum $ mapM evalTerm
09:24:37 <lambdabot> fmap sum (mapM evalTerm)
09:25:01 <SamB> @pl liftM sum $ mapM evalTerm expr
09:25:01 <lambdabot> fmap sum (mapM evalTerm expr)
09:28:44 <LeCamarade> vincenz: You said you wanted to see that lambda crap?
09:28:56 <LeCamarade> But it Python, I warn again.
09:28:58 <vincenz> ?
09:29:00 <vincenz> what lambda crap?
09:29:10 * LeCamarade is ashamed, of course.
09:29:19 * vincenz is missing context
09:29:23 <vincenz> please give me the scope ;)
09:30:10 <quicksilver> I thought you said it was C, LeCamarade ?
09:30:23 <LeCamarade> vincenz: I remember you saying `I want to see that code ...' when I talked of the lambdas in C. Okay, it isn't important. :o)
09:30:32 <LeCamarade> quicksilver: It is Python converting C.
09:30:35 <vincenz> LeCamarade: wrong person?
09:30:45 <LeCamarade> From lambda-ed C to ANSI C.
09:30:48 <quicksilver> ah
09:30:49 * quicksilver nods
09:30:54 <vincenz> LeCamarade: was visage
09:30:56 <vincenz> LeCamarade: not me
09:31:01 * vincenz scrolled back
09:31:10 <vincenz> I was afraid I was so tired I had already forgotten that :D
09:31:23 <LeCamarade> Oh, yeah. visage, I think.
09:31:24 <LeCamarade> :o)
09:32:41 <vincenz> wow
09:32:45 <vincenz> skryb seems spiffy
09:35:22 * LeCamarade goes for a reboot ...
09:39:58 <nominolo> @seen SyntaxNinja
09:39:58 <lambdabot> I haven't seen SyntaxNinja.
09:46:46 <hpaste>  sjanssen pasted "cycling timer script" at http://hpaste.org/280
09:48:02 <Lemmih> sjanssen: huh?
09:48:51 <sjanssen> Lemmih: pertains to #xmonad conversation -- forgot to uncheck the announce box
09:51:18 <bluestorm_> why not uncheck it by default ?
09:52:17 <sjanssen> hpaste is mostly used to promote #haskell discussion, leaving it on makes sense to me
10:00:28 <nomeata> CosmicRay: Hi. Does darcs-buildpackage use darcs dist in the upstream repo to build the tarball, if it exists?
10:09:54 <nomeata> CosmicRay: ah, it does, but added files (e.g. from autoreconf) cause problems
10:10:57 <nomeata> CosmicRay: maybe it should run predist on the debian sources as well
10:11:16 <nomeata> CosmicRay: and build the diff.gz from that
10:17:08 <misterPhyrePhox> hello
10:17:52 <misterPhyrePhox> i'm following this (http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing) tutorial, and i'm trying to use Text.ParserCombinators.Parsec
10:17:55 <lambdabot> http://tinyurl.com/2yojoc
10:18:06 <misterPhyrePhox> but when i compile, i get errors about undefined references
10:18:19 <misterPhyrePhox> do i have to link to some kind of parsec lib or something?
10:18:31 <Lemmih> misterPhyrePhox: Try with --make or -package parsec.
10:19:41 <misterPhyrePhox> -package parsec worked, thanks!
10:19:43 <misterPhyrePhox> what does --make do?
10:20:00 <misterPhyrePhox> --make worked as well
10:20:41 <Lemmih> --make adds the necessary package flags.
10:20:59 <misterPhyrePhox> yeah i just found it in the docs
10:21:02 <misterPhyrePhox> thanks again
10:22:50 <SamB> hmm, what precedence and fixity should Data.DList.cons and Data.DList.append have?
10:23:08 <SamB> oh, I guess it doesn't matter too much for append...
10:41:30 <pejo> Is it dmhouse who has written the denotational semantics in the wikibook?
10:41:34 <pejo> Or Cale?
10:42:03 <dmhouse> Neither, I think.
10:42:30 <pejo> Hm. Any idea who it might be then? :-)
10:42:35 <dmhouse> IIRC it was mostly apfelmus.
10:42:40 <dmhouse> pejo: you could always just check the history. :)
10:43:34 <dmhouse> pejo: http://en.wikibooks.org/w/index.php?title=Haskell/Denotational_semantics&oldid=668717 was how it looked before Apfelmus started work on it.
10:43:37 <lambdabot> http://tinyurl.com/yj4rbm
10:44:35 <pejo> dmhouse, the top of the page says to report things here. Figured I'll only be reading it for hte first time once. :-)
10:45:09 <dmhouse> pejo: true. :) Another good place to report them is the wikibook@haskell.org mailing list, if you'd prefer to send an email.
10:51:28 <ClaudiusMaximus> any thoughts on whether to use exceptions or return an error in a dynamic method dispatcher in the IO monad, given that I'll want to catch exceptions from the methods later in any case?
10:56:38 <pejo> Is there a standard works on denotational semantics? Preferably with a functional view, rather than imperative.
10:56:49 <dylan> @hoogle (a -> Bool) -> ([a], [a])
10:56:49 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
10:56:50 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
10:56:50 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
10:59:33 <bos> pejo: "denotational semantics: the scott-strachey approach to programming language theory" is the one i have
11:01:10 <pejo> bos, by Stoy, from 1981?
11:01:14 <dylan> @hoogle filter
11:01:15 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:01:15 <lambdabot> Data.IntMap.filter :: (a -> Bool) -> IntMap a -> IntMap a
11:01:15 <lambdabot> Data.IntSet.filter :: (Int -> Bool) -> IntSet -> IntSet
11:01:27 <bos> pejo: yes, it's the classic of the field.
11:02:11 <nomeata> CosmicRay: and while I’m at it, libghc6-configfile-dev seems to need a recompile for ghc6-6.6.1
11:02:12 <bos> it's also almost 30 years old, so it's a smidge out of date.
11:15:25 <hpaste>  sphynx pasted "putStrLn and encodings " at http://hpaste.org/281
11:15:38 <CosmicRay> nomeata: yeah, I got about halfway through my list of things to recompile so far.
11:15:42 <CosmicRay> that is so annoying.
11:16:04 <hpaste>  sphynx annotated "putStrLn and encodings " with "fixed" at http://hpaste.org/281#a1
11:16:33 <sphynx> could you please take a look my paste?
11:16:59 <sphynx> I have problem with printing non-ASCII strings (in KOI8-R encoding)
11:17:09 <nomeata> CosmicRay: true, I hope that changes some time
11:17:55 <sphynx> putStrLn "" works good, but putStrLn . show $ (1, "") - not
11:18:32 <pejo> bos, happen to know if there are any more recent papers from summer schools or similar online somewhere?
11:21:29 <oerjan> sphynx: show for strings eventually depend on Char.showLitChar
11:21:49 <oerjan> which according to the prelude does that
11:22:12 <oerjan> *prelude=H98 report
11:22:22 <bos> pejo: i'm sure there are, but i haven't cared about denotational semantics in about 10 years.
11:23:22 <sphynx> oerjan: it seems I 've figured why this happens
11:23:34 <sphynx> > show "12"
11:23:36 <lambdabot>  "\"12\""
11:23:57 <sphynx> putStrLn . show $ "12"
11:24:04 <sphynx> > putStrLn . show $ "12"
11:24:05 <oerjan> sphynx: show is supposed to give a format suitable for portable reading
11:24:05 <lambdabot>  <IO ()>
11:24:20 <oerjan> so it cannot depend on your local encoding
11:25:00 <sphynx> so show translate somehow my string, but putStrLn prints it directly, right?
11:25:42 <nominolo> @src unfoldr
11:25:42 <lambdabot> unfoldr f b  = case f b of
11:25:42 <lambdabot>    Just (a,new_b) -> a : unfoldr f new_b
11:25:42 <lambdabot>    Nothing        -> []
11:25:46 <oerjan> sphynx: you could wrap it in a newtype and define your own Show instance
11:26:02 <oerjan> right
11:26:58 <oerjan> something like newtype RawString = RS String; instance Show RawString where show (RS s) = (s++)
11:27:04 <oerjan> i think
11:27:13 <sphynx> oerjan: hm, so how should I cope with this? I need to print strings in local encoding, which are placed in more complicated data structures?
11:28:01 <oerjan> i mean show (RS s) = s
11:28:03 <pejo> bos, ok, thanks.
11:28:35 <sphynx> oerjan: well I'll try. Thanks!
11:31:13 <sphynx> oerjan: Cool, it works! Thank you for advice :)
11:31:24 <oerjan> sphynx: you're welcome :)
11:33:43 <misterPhyrePhox> is there a parser in Parsec that matches nothing?
11:34:23 <andun> parseNothing = () -- maybe?
11:34:28 <misterPhyrePhox> i tried return ()
11:34:36 <misterPhyrePhox> doesn't work; it has to be a Parser Char or something
11:34:40 <misterPhyrePhox> and return '' doesn't work either
11:34:42 <jaapweel> do you mean one that won't match anything, or one that matches the empty string?
11:34:48 <misterPhyrePhox> won't match anything
11:34:59 <sphynx> oerjan: BTW, if I use newtype, should I use deriving (Ord, Eq, ..etc.) ?
11:35:10 <jaapweel> fail ""
11:35:33 <misterPhyrePhox> i don't want it to fail
11:35:56 <misterPhyrePhox> i'm using a fold with (<|>) to compose a list of parsers, and i need a parser to provide as the second argument to foldl
11:35:57 <jaapweel> that's what it does, though, if it doesn't match
11:36:15 <oerjan> sphynx: you might
11:37:14 <jaapweel> if you don't want it to fail, what do you want it to do? silently return nothing? in that case, "empty >>= return ()"
11:37:32 <jaapweel> or rather "empty >> return ()"
11:38:09 <oerjan> misterPhyrePhox: the choice function already does such a fold
11:38:10 <misterPhyrePhox> okay i see
11:38:18 <misterPhyrePhox> oh! that's cool!
11:38:35 <misterPhyrePhox> thanks
11:59:41 <lekro> what could be a nice piece of code to impress people from a C++ background with the power of monads? (the context would be a not too long and not too theoretical presentation.)
12:00:24 <SamB> probably a parsec parser
12:00:49 <lekro> I thought of that, too, but C++ has boost::spirit.
12:01:02 <SamB> well, why don't you see how they compare ;-)
12:01:17 <Excedrin> lekro: just translate code from C++ books into Haskell and show how much cleaner it is, no templates for parametric poly, etc
12:09:02 <lekro> IMHO, boost::spirit is too complex to be easily compared against monads in a presentation. only a (perhaps small) part of the audience knows boost::spirit, after all (but I'm sure they'd point that out if I use parsec as an example). C++ books could be worth a try, but I was looking for something where you write code in do-notation, run it in different monads and let it do something completely different in these monads (but something use
12:09:02 <lekro> ful)
12:09:39 <SamB> lekro: well, you could do enough comparison to point out how complicated it is and then stop
12:10:18 <SamB> and using functions from Control.Monad is a good way to show off the use of generic monadic code
12:10:29 <ClaudiusMaximus> FFI question:  are FunPtr's generated by 'foreign import ccall "wrapper"' stable (in the sense of StablePtr)? the control flow in my program is C -> Haskell -> C, moreover it returns to the outermost C before the C calls the FunPtr
12:11:55 <SamB> ClaudiusMaximus: that's an import?
12:11:59 <Cale> To do something really interesting in a generic monad, you have to have input which is, or contains, computations in a generic monad. My favourite example is some code which xerox and I wrote to expand L-systems.
12:12:01 <SamB> that syntax is wierd
12:12:06 <yaarg> anyone here at debconf?-)
12:13:16 <ClaudiusMaximus> SamB: it's an import because it generates a haskell function :: a -> IO (FunPtr a)
12:14:45 <SamB> I guess they probably are
12:15:04 <SamB> because it would be kind of silly to make
12:15:13 <SamB> FunPtrs that couldn't be safely passed to C..
12:16:22 <vincenz> @hoogle (a -> Bool) -> [a] -> ([a],[a])
12:16:23 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
12:16:23 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
12:16:23 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
12:16:47 <SamB> well, the fact that there is something called "freeHaskellFunPtr" seems to indicate that, yes, those things are stable
12:17:58 <SamB> ClaudiusMaximus: got that?
12:18:04 <araujo> afternoon
12:19:05 <ClaudiusMaximus> SamB: true, it seems highly likely, and my code hasn't crashed yet, just wanted absolute confirmation.  thanks for your thoughts :)
12:19:26 <SamB> Cale: oh, like that diff :: Floating a => (a -> a) -> (a -> a) or whatever?
12:20:17 <SamB> ClaudiusMaximus: well, it would be totally bonkers to have a "free" function if the associated memory was not stable (and, therefor, garbage collected)
12:20:42 <Cale> SamB: Er, I suppose? :)
12:21:18 <SamB> Cale: I'm not positive I got the type right...
12:21:28 <SamB> in fact I'm sure I got it wrong
12:21:43 <SamB> because it needs a forall a bit further in..
12:22:52 <Cale> In our case, it was  expand :: (Monad m) => Productions m -> String -> m String
12:23:44 <SamB> anyway, the way it works is it has a special type with custom instances for all the relevant classes, which essentially created an AST for the function...
12:23:58 <Cale> er, maybe we're not talking about the same thing?
12:24:08 <SamB> well, yours does something different.
12:24:12 <ClaudiusMaximus> SamB: indeed; just suprised it isn't explicitly stated, was frightened Haskell->C->Haskell was safe (callbacks), but not C->Haskell; C ->Haskell (stored pointer) -- i need to work on my paranoia issues ;)
12:24:42 <SamB> ClaudiusMaximus: actually a better idea would be to suggest improvement to the FFI addendum ;-)
12:25:32 <ClaudiusMaximus> SamB: where do i file that suggestion?
12:25:53 <SamB> ClaudiusMaximus: probably haskell-cafe@
12:26:26 <ClaudiusMaximus> SamB: ok
12:29:24 <ClaudiusMaximus> SamB: mind if i quote from IRC in the mail?
12:31:22 <SamB> not at all
13:06:24 <shapr> YAY CODE!
13:18:02 <ndm> quite a lot of the mailing list now seems to start on IRC
13:19:53 <Modius> Is there a haskell function which splits a list based on some predicate?
13:20:01 <Modius> I mean, splits it in to multiple sublists
13:20:05 <oerjan> partition
13:20:53 <Modius> I was thinking of something that would split apart a list of chars into a list of strings/char-lists, say, based on a comma being found.
13:21:08 <basti_> like "words"?
13:21:14 <basti_> > words "ajkfjg sjkfdlsak skjfdlak"
13:21:16 <lambdabot>  ["ajkfjg","sjkfdlsak","skjfdlak"]
13:21:30 <oerjan> someone mentioned undelim recently, i thought it did that
13:21:41 <tuukkah> truly a frequently asked question :-)
13:21:59 <ndm> Modius: no, its noticable in Haskell by its absence - you could add it, and someone should...
13:23:07 <Modius> I can understand its absence - easy to write, and a person desiring this functionality may or may not want to skip the found item.  Hard to make a 2-arg function to please everyone.
13:23:26 <ndm> i entirely disagree
13:23:42 <Modius> (Or may wish to skip that which is before or after) - and someone may want to search based on more than a match, may want a predicate on "this point onward"
13:23:50 <ndm> its easy enough to design a version which will do everything which you want
13:24:10 <Modius> I have one but it's 3-parameter. . ..
13:24:26 <ndm> you can probably find that you could implement the more exotic variants in terms of mapping over the results
13:24:34 <ndm> so the central split function is nice and simple
13:24:48 <emu> what would you say about "70% of running time is GC" as a symptom of program misbehavior?  is it caused by the retention of too many live objects?  or is it the generation of too many quickly dead and collected objects?
13:25:14 <ndm> emu: space leak
13:25:34 <ndm> emu: look at the statistics for the live heap at each GC
13:25:51 <ndm> then go and read a Runciman paper on heap profiling with Clausify
13:25:54 <emu> which option is that?
13:26:07 <ndm> @google heap profiling runciman clausify
13:26:11 <lambdabot> http://journals.cambridge.org/production/action/cjoGetFulltext?fulltextid=44166
13:26:19 <CosmicRay> @hpaste
13:26:19 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:26:23 <ndm> i use the one that writes thing to the stderr
13:26:25 <oerjan> btw there should be a Data.Eq.comparing
13:26:37 <ndm> +RTS --help will tell you
13:26:40 <hpaste>  (anonymous) pasted "strange compiler error" at http://hpaste.org/282
13:26:46 <ndm> oerjan: i think there is now, it got added recently
13:27:03 <CosmicRay> does anyone have an idea about the error at http://hpaste.org/282 involving the interaction between typeclasses and records?
13:27:21 <oerjan> ndm: i don't see it in the online hl docs
13:27:22 <emu> -S?
13:27:35 <ndm> emu: that sounds like it
13:27:49 <ndm> @docs comparing
13:27:50 <lambdabot> comparing not available
13:27:53 <emu> k
13:27:53 <ndm> @index comparing
13:27:54 <lambdabot> bzzt
13:28:12 <ndm> i'm sure it got added somewhere, possibly only in the darcs so far
13:28:23 <oerjan> there _is_ Data.Ord.comparing
13:28:40 <oerjan> but i mean the equivalent for Eq
13:28:51 <ndm> oh, equating
13:29:02 <ndm> i think it was
13:29:17 <ndm> but easier to use (==) `on` f
13:31:05 <kosmikus> CosmicRay: getC3 is "forall b. C2 b => a -> IO [b]"
13:31:13 <oerjan> :t on
13:31:21 <lambdabot> Not in scope: `on'
13:31:38 <dmhouse> f `on` g = \x y -> f x `g` f y
13:31:59 <kosmikus> CosmicRay: so the "b" in scope in the instance declaration can't be the `same' b
13:32:07 <dmhouse> Err, that was meant to be g x `f` g y, sorry.
13:32:24 <CosmicRay> kosmikus: hrm, how to fix?
13:32:34 <CosmicRay> kosmikus: I have tried multi-parameter type classes but that doesn't seem to help
13:33:04 <CosmicRay> I also can't figure out how to remove the "b" from the type of BasicC2
13:33:12 <CosmicRay> (without using extensions anyway)
13:33:48 <kosmikus> CosmicRay: I don't know what you want to do.
13:34:00 <kosmikus> CosmicRay: removing the type from the "data" declaration -- can't you simply do it?
13:34:24 <CosmicRay> err, there is a typo in my paste.
13:34:40 <hpaste>  CosmicRay annotated "strange compiler error" with "(no title)" at http://hpaste.org/282#a1
13:35:04 <CosmicRay> that type signature for getC3 was wrong.
13:35:07 <CosmicRay> the error is the same.
13:35:32 <kosmikus> maybe you want something like "getC3 :: C3 b => a b -> IO [b]" ?
13:36:00 <CosmicRay> then I would have to do "class C2 a b where", right?
13:36:08 <kosmikus> no
13:36:20 <kosmikus> a would become a type variable of kind * -> *
13:36:21 <oerjan> is `on` defined somewhere?
13:36:33 <CosmicRay> err, how can "a b" work then?
13:36:40 <CosmicRay> I get a "Kind mis-match" when I try to do that
13:36:41 <kosmikus> CosmicRay: the instance would become "instance C2 BasicC2 where ..."
13:37:34 <CosmicRay> blink.
13:37:36 <CosmicRay> that worked.
13:38:12 <CosmicRay> I think I get it, actually.  I don't think I had ever realized Haskell did kind matching like that.
13:38:21 <LoganCapaldo> I just realized I want the reader monad
13:38:34 <CosmicRay> kosmikus: is there somewhere that I could read more about this?
13:38:35 <LoganCapaldo> actually ReaderT IO
13:38:50 <LoganCapaldo> I don't know why I felt the need to anounce that
13:39:04 <kosmikus> CosmicRay: hmm, about what specifically? about kinds? about constructor classes?
13:39:27 <CosmicRay> kosmikus: kinds, perhaps.  I have read bits about them in the ghc manual and never really understood it
13:40:01 <kosmikus> hmm
13:40:46 <kosmikus> I don't think I know a good tutorial. Some of the "generic programming" work uses kinds heavily, so there are probably some introductory sections there.
13:43:31 <kosmikus> CosmicRay: maybe Sec. 1.2 of www.informatik.uni-bonn.de/~ralf/publications/GH.pdf ?
13:48:35 <ndm> CosmicRay: i think typing haskell in haskell covers them in detail
13:52:31 <kosmikus> ndm: it covers them, but does it explain them or give examples?
13:54:07 <pejo> CosmicRay, there's a chapter in TAPL on kinds if you happen to have that book nearby.
13:54:27 <ndm> kosmikus: i don't know, it gives their type rules...
13:54:30 <nominolo> @pl \x -> [x]
13:54:30 <lambdabot> return
13:54:44 <nominolo> :t ([])
13:54:46 <lambdabot> forall a. [a]
13:55:42 <LoganCapaldo> :t (:[])
13:55:44 <lambdabot> forall a. a -> [a]
13:56:12 <mehrheit> what does @pl do?
13:56:35 <nominolo> transform into pointfree form
13:56:38 <nominolo> eg
13:56:49 <nominolo> @pl \x -> x + 3
13:56:49 <lambdabot> (3 +)
13:57:01 <mehrheit> interesting
13:57:44 <nominolo> ie, no explicit mentioning of variables (=points)
13:58:52 <nominolo> @unpl not . (`elem` [1..5])
13:58:53 <lambdabot> (\ d -> not (elem d ([1 .. 5])))
14:01:25 <oerjan> @pl \x y z -> if x then y else z
14:01:25 <lambdabot> if'
14:02:06 <oerjan> @pl \x y z -> x*y+z
14:02:06 <lambdabot> ((+) .) . (*)
14:02:24 <oerjan> @pl \x y z -> z*y+x
14:02:25 <lambdabot> flip (flip . ((+) .) . (*))
14:02:54 <CosmicRay> pejo: whats TAPL?
14:03:02 <SamB> Types and Programming Languages
14:03:25 <oerjan> @pl \x y z -> x z (y z)
14:03:25 <lambdabot> ap
14:03:35 <LoganCapaldo> @unpl flip (flip . ((+) .) . (*))
14:03:35 <lambdabot> SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 28}: Illegal character ''\SI''
14:03:58 <SamB> huh!
14:04:04 <SamB> interesting parse error there ;-P
14:04:09 <CosmicRay> rats, that's not on safari
14:04:09 <LoganCapaldo> indeed
14:04:25 <LoganCapaldo> i thinkk my irc oops wen i c&ped
14:04:49 <SamB> @tell dons @pl uses a really funny way to display parse errors
14:04:50 <lambdabot> Consider it noted.
14:06:38 <SamB> @tell dons oops I meant @unpl
14:06:39 <lambdabot> Consider it noted.
14:09:17 <kpreid> SamB: all it needs is to prettyprint a SrcLoc instead of showing it
14:11:59 <sphynx> hm, it seems I still have little trouble with speed of my centericq history investigator
14:12:47 <sphynx> I've profiled it and profiler has  shown 3 most greedy functions
14:13:08 <sphynx> could you please look on them if I paste?
14:13:20 <sphynx> ,aybe it is possible to improve them somehow
14:13:34 <sphynx> although they seem to be almost ideal :)
14:14:52 <hpaste>  CosmicRay annotated "strange compiler error" with "trouble generalizing" at http://hpaste.org/282#a2
14:15:42 <CosmicRay> kosmikus: I guess I could change every instance of "a" to "a b", but that seems a bit... not quite right.
14:16:30 <CosmicRay> and also -- this would seem to tie it to the data implementations.  what if I wanted to make something else a member of the class, which isn't something with the more complex kind?
14:20:34 <hpaste>  sphynx pasted ""CICQ investigator" profiling" at http://hpaste.org/283
14:21:39 <sphynx> I pasted all profiling info and 3 most time-consuming functions along with data types defined
14:31:06 <LoganCapaldo> gah
14:32:15 <Vulpyne> Agree.
14:34:58 <SamB> "Hoogle Employees _{Beta}", anyone?
14:35:20 <SamB> er. wait.
14:35:31 <SamB> that should be in #haskell-blah
14:35:36 <SamB> I do ttihs a lot...
14:41:40 <mdmkolbe|home> is there something citeable on xmonad? (preferably about how it uses the zipper)
14:42:00 <lispy> might want to ask in #xmonad
14:42:19 <mdmkolbe|home> lispy: I did, haven't seen a responce yet
14:42:29 <lispy> ah, i see
14:42:38 <lispy> well, dons is probably sleeping ATM
14:42:43 <lispy> and maybe sjanssen too
14:42:47 <mdmkolbe|home> @localtime dons
14:42:47 <lispy> ?seen sjanssen
14:42:48 <lambdabot> sjanssen is in #haskell and #xmonad. I last heard sjanssen speak 1h 6m 2s ago.
14:42:48 <lambdabot> Local time for dons is Fri Jun 15 07:42:02 2007
14:44:52 <kosmikus> CosmicRay: as I said before, I don't really know what you want to do. but from your original paste it seems that you probably want some relation between a and b. so if making b a parameter of a doesn't work, then maybe parameterizing the class over a and b and having a fundep a -> b would?
14:45:44 <kosmikus> (oh, what happened to me, I recommended to someone to use a functional dependency ...)
14:45:51 <CosmicRay> kosmikus: http://darcs.complete.org/photoset/Data/PhotoSet.hs
14:46:18 <SamB> type families!
14:48:00 <sjanssen> lispy: what up?
14:48:07 <sjanssen> oh, about citing xmonad
14:48:29 <sjanssen> mdmkolbe|home: we've got the source, mailing list posts, and blogs
14:49:39 <mdmkolbe|home> sjanssen: I just need to cite something in a paper I'm writing about zippers.  From that list it sounds like the blog is the best option
14:51:01 <kosmikus> CosmicRay: probably the album type determines the photo type, right?
14:51:50 <CosmicRay> yes
14:51:55 <CosmicRay> it can, at least.
14:53:10 <CosmicRay> I'm fine with saying that it does.
14:53:30 <kosmikus> CosmicRay: then it looks like a fundep (or an associated type) to me ...
14:53:46 <CosmicRay> ok, I guess I need to read up on both
14:53:53 <kosmikus> CosmicRay: at least if you aren't happy with parameterizing
14:54:16 <CosmicRay> heh, ghc doc says "There should be more documentation, but there isn't (yet). Yell if you need it."
14:54:23 <CosmicRay> igloo, can you hear me? ;-)
14:54:29 <kosmikus> something like "class Photo b => Album a b | a -> b where"
14:54:47 <CosmicRay> what does that mean?
14:56:07 <kosmikus> it means that if Photo b holds, you can define instances Album a b where knowledge of a uniquely determines b
14:56:07 <CosmicRay> ah, never mind, found it in the ghc docs.
15:00:48 <sorear> (hello)
15:00:52 <CosmicRay> kosmikus: this would require ghc -fglasgow-exts or hugs -98 +o, right?
15:01:20 <lispy> CosmicRay: i tihnk there is a more specific extension in the case of ghc
15:01:36 <CosmicRay> yeah, I'm sure there is
15:01:41 <lispy> something about functional dependencies, but i don't recall it
15:02:45 <twanvl> {-# LANGUAGE FunctionalDependencies #-} ?
15:03:58 <kosmikus> CosmicRay: yes, it would.
15:04:36 <desp> when darcs asks about my email address, does it want just the address, or "name <address>"?
15:05:20 <desp> I'm finding the instructions ambiguous:
15:05:22 <desp> "Darcs needs to know what name (conventionally an email address) to use as the
15:05:23 <desp> patch author, e.g. 'Fred Bloggs <fred@bloggs.invalid>'. "
15:05:41 <lispy> desp: you can use whatever you want really, i tjust affects if people can easily email you
15:05:57 <lispy> desp: so if all you want to use is fred@bloggs.invalid you're good
15:06:15 <desp> lispy: I guess I'm just asking if the next question is going to be about my name, in which case I would feel very silly
15:06:21 <lispy> nope
15:06:24 <desp> ok, thx
15:06:41 <lispy> desp: also you can set a global preference for this
15:06:49 <lispy> iirc, ~/_darcs
15:06:54 <lispy> well in that dir, let me check
15:07:19 <lispy> http://www.darcs.net/manual/node5.html#SECTION00510000000000000000
15:07:21 <lambdabot> Title: Configuring darcs, http://tinyurl.com/yubb8j
15:07:26 <desp> thnaks
15:07:43 <lispy> that's per repository
15:07:54 <desp> yeah
15:07:54 <lispy> if you scroll up a tiny bit it shows you the global one
15:08:33 <lispy> ~/.darcs/prefs/author is what you want edit, probably
15:10:33 <lispy> you probably also want ~/.darcs/defaults to have the lines, send edit-description and send unified
15:12:08 * CosmicRay leaves
15:12:34 <sorear> desp: Remember, darcs projects conventionally use the inventory as their sole credits file.  So if you use a fake name/address, don't expect credit...
15:23:13 <desp> sorear: not planning on doing that
15:23:25 <sorear> ok good :)
15:23:56 <sorear>   * Removed dependency on libffi (although it's still recommended)
15:24:06 <sorear> Oooh!  (big yhc news!)
15:26:26 <sjanssen> what does that mean?
15:26:46 <sorear> sjanssen: It means nhc is dead.
15:27:13 <sorear> sjanssen: libffi doesn't quite work on OSX; this was the only thing keeping Malcolm off yhc
15:32:03 <lispy> yhc will work on OSX now?
15:32:14 <lispy> you mean, it didn't already?
15:33:21 <sorear> Probably.  You'd be best to ask ndm; I do not follow yhc that deeply.
15:33:23 <sorear> ndm: ^^
15:34:39 <ndm> lispy: it does, but sometimes requires an extra hoop to jump through - now you just need libffi
15:34:47 <ndm> that dependency is being eliminated tomorrow :)
15:35:17 <ndm> lispy: i mean you just need libgmp, which is being eliminated tomorrow
15:35:30 <lispy> cool
15:35:32 <ndm> after that, Yhc will be able to be ported with just a C compiler - no libraries at all
15:36:02 <ndm> part of our goal to answer the "How can I port Yhc to the lego mindstorms" FAQ
15:36:03 <sorear> what will we use instead?
15:36:08 <ndm> Int :)
15:36:16 <ndm> maxBound + 1 = minBound
15:36:42 <ndm> the intention is that anyone who wants Haskell semantics should use libgmp, anyone who couldn't care less (initial ports, embedded systems) can ignore it
15:36:44 <dmhouse> > maxBound + (1 :: Int) == minBound
15:36:46 <lambdabot>  True
15:38:22 <ndm> Tom is always very quiet on these things, the first i knew about this was when i saw the commit message fly by
15:39:42 <ndm> sorear: i don't think nhc is dead yet, it manages to keep going on - which is silly
15:41:39 <SamB> ndm: so, what non-Haskell semantics will such people see?
15:42:17 <ndm> SamB, just the wrap around of Integer, we don't think it is likely to bite anyone who doesn't do large number numerical computation
15:42:22 <sorear> SamB: Integer would not be a field
15:42:48 <SamB> ndm: when does it wrap around?
15:42:57 <ndm> > maxBound
15:42:57 <sorear> ndm: Or address calculations, etc.  I see integer fairly often when a C programmer would just rescale things
15:42:58 <lambdabot>  Add a type signature
15:43:00 <ndm> > maxBound :: Int
15:43:02 <lambdabot>  2147483647
15:43:16 <SamB> ndm: um. that could bit very easily.
15:43:20 <SamB> er. bite.
15:43:31 <ndm> sorear: address calculations? you mean for ffi stuff?
15:43:43 <ndm> SamB, i very much doubt it breaks that many programs - my guess is nearly none
15:43:58 <sorear> ndm: Array indexes and Map keys are addresses too ;)
15:44:01 <SamB> so when does your Int64 wrap around?
15:44:15 <ndm> > maxBound :: Int64
15:44:16 <lambdabot>  9223372036854775807
15:44:20 <sjanssen> you'll at least throw a giant warning during the configure/build stage if GMP isn't used?
15:44:27 <sorear> @src Int64
15:44:27 <lambdabot> data Int64 = I64# Int64#
15:44:28 <SamB> ... so why not make Integer at least that big?
15:44:31 <sorear> @src Int128
15:44:32 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
15:44:42 <SamB> how the heck is...
15:44:49 <SamB> > 9223372036854775807 :: Int64
15:44:50 <ndm> SamB, this is intended for embedded systems - these people really couldn't care less about Integer, but want easy porting
15:44:51 <lambdabot>  9223372036854775807
15:45:07 <SamB> going to work, if Integer can only store Int's range?
15:45:11 <ndm> sjanssen: yes, if you don't use libgmp, you are building Haskell--, not Haskell, and it will tell you loudly
15:45:15 * sorear thought gmp was portable
15:45:38 <ndm> sorear: pretty portable, yes, but its a pain to port to lego mindstorms etc - think of no libgmp as our unregistered route
15:46:11 <sorear> ndm: Huh.  I thought that the base case was ANSI C
15:46:15 <sorear> but ok.
15:46:23 <sorear> makes sense aside from that
15:46:32 <SamB> how large is it?
15:46:41 <ndm> sorear: its not hte code, its more configuration, finding libraries, integration and size of compiled code
15:46:42 <sorear> SamB: 2^31
15:46:55 <SamB> GMP
15:46:59 <ndm> sorear: plus the warning on libgmp is that compiling it yourself is likely to go wrong, and give bad answers
15:47:02 <SamB> not an Int
15:47:04 <ndm> 100Kb is typical
15:47:11 <ndm> in increased Yhc size
15:47:25 <SamB> that's more than 3x the size of the RAM on my RCX!
15:47:27 <sorear> ndm: I think that's only true with clever compilers.
15:47:41 <ndm> SamB, usually bigger or smaller?
15:47:42 <sorear> SamB: wouldn't this be going in (EE)PROM?
15:48:04 <ndm> sorear, i mean
15:48:20 <SamB> sorear: RCX's don't have that
15:48:43 <SamB> they come with some ROM, but it's, well, ROM!
15:49:00 <sorear> SamB: Oh.  Ok then, my guess was wrong, nm then.
15:49:20 <sorear> ndm: Sorry, I meant to the warning.  GMP is misoptimized only by optimizing compilers.
15:49:24 <SamB> probably 32k of ram isn't enough to run much more complicated than forth ;-)
15:49:50 <desp> darcs failed:  Couldn't initialize remote repository.
15:49:56 <desp> any clues why does that happen?
15:49:57 <matthew-_> SamB: elite fitted into 32KB of RAM on the BBC Model B. That was pretty complex ;)
15:50:04 <desp> I'm trying to darcs put a copy of my local rep over ssh
15:50:15 <sjanssen> desp: permissions?
15:50:16 <desp> the dst directory is empty, so far
15:50:17 <sorear> matthew-_: what's elite?
15:50:19 <hpaste>  emu pasted "reading ints from bytestrings" at http://hpaste.org/284
15:50:36 <desp> sjanssen: drwxr-xr-x 2 desp desp 4096 Jun 15 00:47 darcs
15:50:36 <SamB> matthew-_: I think it managed with only 16k on the NES
15:50:37 <chessguy> @hoogle (a -> Bool) -> [a] -> [[a]]
15:50:37 <lambdabot> No matches, try a more general search
15:50:39 <matthew-_> sorear: a *classic*, era defining game by David Brabham and others...
15:50:45 <SamB> but, of course, it had ROM to hold it's code...
15:50:57 <chessguy> @bot
15:50:58 <lambdabot> :)
15:51:01 <emu> profiler indicates that my inner loop there generates most of the garbage in the program.   i can't think of any better way to do it.
15:51:15 <chessguy> @hoogle split
15:51:15 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
15:51:16 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
15:51:16 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
15:51:24 <chessguy> @hoogle+
15:51:24 <lambdabot> Data.Map.split :: Ord k => k -> Map k a -> (Map k a, Map k a)
15:51:24 <lambdabot> Data.Set.split :: Ord a => a -> Set a -> (Set a, Set a)
15:51:24 <lambdabot> GHC.Exts.split :: Splittable t => t -> (t, t)
15:51:33 <ndm> emu: you read the Runciman paper yet?
15:51:35 <chessguy> isn't there some kind of split for lists?
15:51:44 * matthew-_ has just released a library on hackage *requiring* GHC 6.7.x
15:51:45 <ndm> chessguy: break, span
15:51:48 <LoganCapaldo> @hoogle break
15:51:49 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
15:51:49 <lambdabot> GHC.ConsoleHandler.Break :: ConsoleEvent
15:51:49 <lambdabot> Data.PackedString.breakPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
15:51:50 <emu> i went over it, but it seemed to be about the implementation of a profiler, not the use
15:52:04 <chessguy> @hoogle span
15:52:05 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
15:52:05 <lambdabot> Data.PackedString.spanPS :: (Char -> Bool) -> PackedString -> (PackedString, PackedString)
15:52:05 <lambdabot> Text.Html.colspan :: Int -> HtmlAttr
15:52:20 <ndm> emu: have you read the lag, drag, void and use one - that explains the stages heap cells go through quite well
15:52:30 <desp> oh, so darcs needs to be installed there as well
15:52:30 <sorear> emu: Does manual unboxing do a better job?
15:52:31 <desp> ;p
15:52:32 <emu> ah the biographical prof
15:52:34 <chessguy> hmm, i want to break up a comma-delimited string
15:52:46 <thoughtpolice> matthew-_: which would be?
15:52:50 <ndm> chessguy: does it have spaces in?
15:52:56 <chessguy> ndm, yes
15:53:03 <chessguy> but not around the commas
15:53:06 <emu> sorear: manual how?
15:53:11 <ndm> chessguy: write your own split then
15:53:17 <chessguy> i can write my own easily enough
15:53:22 <matthew-_> thoughtpolice: sessions
15:53:38 <chessguy> i coulda sworn there was something that would do it though
15:53:45 <ndm> chessguy: there isn't
15:53:49 <thoughtpolice> matthew-_: just saw. fun stuff. :)
15:53:55 <ndm> (there should be!)
15:54:00 <matthew-_> thoughtpolice: cheers.
15:54:04 <sorear> emu: Int# -> Int# -> Addr# -> (# Int# , Addr# #)
15:54:15 <desp> does anyone know if it's possible to naively replicate a darcs rep using scp?
15:54:25 <desp> well, or any other naive copy
15:54:26 <thoughtpolice> matthew-_: why's it require 6.7?
15:54:27 <desp> :)
15:54:35 <SamB> desp: rsync!
15:54:36 <SamB> and yes
15:54:40 <matthew-_> thoughtpolice: improvements to the propogation of contexts
15:54:41 <SamB> of course
15:54:48 <sjanssen> desp: just copy the directory.  scp -r should work
15:54:52 <desp> ack
15:54:57 <SamB> for instance, cp works !
15:55:03 <desp> ;)
15:55:16 <desp> I'm asking because darcs put attempts to execute darcs init on the remote side
15:55:24 <Mr_Awesome> when i invoke ghc -o main main.hs -package GLUT, i get the linker error cannot find -lGL, even though libGL.so is in /usr/lib as well as libGL.a
15:55:29 <mauke> http://mauke.ath.cx/stuff/haskell/split.hs
15:55:36 <matthew-_> thoughtpolice: it needs to propogate a context out of a GADT properly, which 6.6 doesn't do
15:55:46 <SamB> well... it probably doesn't want to copy all the settings and so on...
15:55:56 <sjanssen> matthew-_: what is a 'session type'?
15:56:18 <emu> sorear: ok i'm gonna have to read about that one sec
15:56:39 <matthew-_> sjanssen: Session Types allow for conversation plans between two parties to be treated as types
15:56:51 <matthew-_> sjanssen: you can think of them as finite state machines
15:56:57 <SamB> wooohooo
15:56:58 <SamB> parties
15:56:59 <matthew-_> sjanssen: sorta ;)
15:57:44 <LoganCapaldo> chessguy: sepBy (char ',') (many $ noneOf ",") or splitRegex (mkRegex ",") :)
15:58:01 <chessguy> LoganCapaldo, parsec?
15:58:07 <LoganCapaldo> the first is
15:58:12 <LoganCapaldo> the second is Text.Regex
15:58:43 <chessguy> ah
15:59:25 <chessguy> that is much easier
15:59:25 <lispy> :t splitRegex (mkRegex ",")
15:59:33 <lambdabot> Not in scope: `splitRegex'
15:59:33 <lambdabot>  
15:59:33 <lambdabot> <interactive>:1:12: Not in scope: `mkRegex'
16:00:10 <chessguy> split :: String -> [String]
16:00:18 <chessguy> lispy, ^^
16:00:38 <matthew-_> right, bed time. night y'all
16:00:40 <lispy> nice
16:01:01 <chessguy> LoganCapaldo++
16:02:34 <chessguy> @pl \(v:w:x:y:z:zz) -> (v,w,x,y,z)
16:02:37 <lambdabot> ap (flip ap tail . (. head) . flip flip tail . (ap .) . flip flip head . ((.) .) . flip flip tail . ((flip . (ap .)) .) . flip flip head . ((flip . ((.) .)) .) . flip flip tail . (flip .) . ((flip .)
16:02:37 <lambdabot>  .) . (((ap .) .) .) . flip flip head . (flip .) . ((flip .) .) . ((((.) .) .) .) . ((((const .) .) .) .) . (,,,,) . head) tail
16:02:37 <lambdabot> optimization suspended, use @pl-resume to continue.
16:02:41 <chessguy> whee
16:03:40 <chessguy> @pl \[w,x,y,z] -> (w,x,y,z)
16:03:40 <lambdabot> (line 1, column 2):
16:03:40 <lambdabot> unexpected "["
16:03:40 <lambdabot> expecting pattern
16:03:49 <chessguy> @pl f [w,x,y,z] -> (w,x,y,z)
16:03:49 <lambdabot> (line 1, column 13):
16:03:49 <lambdabot> unexpected ">" or "-"
16:03:49 <lambdabot> expecting variable, "(", operator or end of input
16:04:00 <chessguy> @pl f [w,x,y,z] = (w,x,y,z)
16:04:00 <lambdabot> (line 1, column 13):
16:04:00 <lambdabot> unexpected "="
16:04:00 <lambdabot> expecting variable, "(", operator or end of input
16:04:03 <lispy> i have this feeling like theabove would be pretty nice if @pl groked arrows
16:04:56 <desp> woop
16:04:58 <desp> woop
16:05:16 <desp> I am finally not all that much behind with my webpage
16:05:17 <desp> :)
16:06:16 <oerjan> chessguy: something with foldl, ($) and take 5 perhaps?
16:06:50 <oerjan> chessguy: something with foldl, ($) and take 5 perhaps?
16:06:51 <sjanssen> a solution with foldl is tricky here
16:07:08 <oerjan> oh right, types..
16:07:26 <sorear> chessguy_: there are no standard functions dealing with quadruples
16:07:26 <chessguy> this'll work. it's just a quick and dirty hack anyway
16:07:50 <oerjan> :t (,,,)
16:07:54 <chessguy> yeah, i think there used to be
16:07:56 <lambdabot> forall a b c d. a -> b -> c -> d -> (a, b, c, d)
16:08:10 <sjanssen> @type foldl (\(a, b, c, d) x -> (b, c, d, x)) (undefined, undefined, undefined, undefined)
16:08:12 <lambdabot> forall b. [b] -> (b, b, b, b)
16:08:35 <sjanssen> > foldl (\(a, b, c, d) x -> (b, c, d, x)) (undefined, undefined, undefined, undefined) "wxyz"
16:08:37 <lambdabot>  ('w','x','y','z')
16:09:07 <LoganCapaldo> that there is a neat trick
16:09:08 <oerjan> that doesn't quite seem to help making it point-free
16:09:29 <sjanssen> oerjan: right.  We need the catamorphism on 4-tuples to do that
16:09:55 <sjanssen> (ie. uncurry4)
16:10:14 <LoganCapaldo> Hmmm
16:10:32 <LoganCapaldo> class Tuple a where uncurry :: a -> err never mind can't do that
16:10:58 <chessguy> @quote wonders.why
16:10:59 <lambdabot> SamB says: * SamB wonders why oh.
16:17:07 <oerjan> @pl \(x:y:z) -> (x,y)
16:17:07 <lambdabot> ap ((`ap` tail) . (. head) . (const .) . (,) . head) tail
16:20:40 <emu> i guess it's pretty bad if VOID is the largest on the bio graph
16:20:48 <sorear> yea
16:22:58 <emu> i think i get it: readInt is constructing a LOT of Ints, but a good portion of them will never be used
16:24:24 <emu> because Kruskal's stops running once it has picked enough edges.  and the edges are in an IntMap [Int] which is converted into a sorted list, and then traversed until enough edges are found.
16:24:35 <chessguy> ok, this is stupid, i ought to be able to do this in my sleep
16:25:39 <chessguy> i have a file of 67 lines, each line has a label and 4 integers, comma separated. the first line has the total of all the others for that column. i want to calculalate what percent of the total each line has in each column
16:28:08 <oerjan> \(fst:rest) -> map (flip (zipWith (/)) fst) rest, or something
16:30:59 <oerjan> chessguy ^^
16:31:56 <oerjan> bah, not again!
16:32:06 <oerjan> chessguy: \(fst:rest) -> map (flip (zipWith (/)) fst) rest, or something
16:32:49 <chessguy_> yeah, i saw that
16:32:56 <chessguy_> sorry, my wireless sucks
16:36:15 <LoganCapaldo> I wrote split. Its stylistically horrible because I wanted it to "fit on one line"
16:36:22 <LoganCapaldo> >  (\pred list -> unfoldr ( \sl -> let (a,b) = break pred sl in if null sl then Nothing else (if null b then Just (a, []) else Just (a, tail b))) list) (== ',') "abc,123,do re me"
16:36:23 <lambdabot>  ["abc","123","do re me"]
16:37:12 <LoganCapaldo> @pl  (\pred list -> unfoldr ( \sl -> let (a,b) = break pred sl in if null sl then Nothing else (if null b then Just (a, []) else Just (a, tail b))) list)
16:37:12 <lambdabot> (line 1, column 37):
16:37:12 <lambdabot> unexpected "("
16:37:12 <lambdabot> expecting natural, identifier or "in"
16:38:01 <chessguy> @pl \x -> p $ s x
16:38:01 <lambdabot> p . s
16:40:55 <sjanssen> @pl (\x y -> x /= ',' && y /= ',')
16:40:55 <lambdabot> (. ((',') /=)) . (&&) . ((',') /=)
16:41:05 <sorear> That code is unreadable, btw.
16:41:26 <chessguy> @type intersperse
16:41:28 <lambdabot> forall a. a -> [a] -> [a]
16:42:19 <sjanssen> > filter (/= ",") . groupBy (\x y -> x /= ',' && y /= ',') $ "abc,123,do re me"
16:42:20 <lambdabot>  ["abc","123","do re me"]
16:42:51 <dmhouse> Hey, that's a nice definition I haven't seen before.
16:43:14 <dmhouse> The ones using unfoldr are always so unwieldly, because of the silly Prelude defintion of unfoldr.
16:46:41 <lispy> :t unsafeCoerce#
16:46:42 <lambdabot> Not in scope: `unsafeCoerce#'
16:46:46 <lispy> :t unsafeCoerce
16:46:47 <lambdabot> Not in scope: `unsafeCoerce'
16:47:43 <oerjan> :t print
16:47:44 <lambdabot> forall a. (Show a) => a -> IO ()
16:47:53 <Saizan> ?index unsafeCoerce
16:47:53 <lambdabot> bzzt
16:48:08 <sorear> :t GHC.Prim.unsafeCoerce#
16:48:10 <lambdabot> forall t b. t -> b
16:48:52 <LoganCapaldo> > filter (/= ",") . groupBy (curry $ uncurry (&&) . (uncurry (***) $ join (,) (== ','))) $ "abc,123,do re me"
16:48:53 <lambdabot>  ["a","b","c","1","2","3","d","o"," ","r","e"," ","m","e"]
16:49:04 <LoganCapaldo> Mmm
16:49:10 <LoganCapaldo> thats not right
16:49:38 <lispy> :t GHC.Prim.unsafeCoerce#
16:49:38 <lispy> <interactive>:1:22: parse error (possibly incorrect indentation)
16:49:39 <lambdabot> forall t b. t -> b
16:49:44 <LoganCapaldo> > (curry $ uncurry (&&) . (uncurry (***) $ join (,) (== ','))) ',' ','
16:49:45 <lambdabot>  True
16:49:47 <lispy> i wonder why ghci doesn't find it
16:49:57 <LoganCapaldo> > filter (/= ",") . groupBy (curry $ uncurry (&&) . (uncurry (***) $ join (,) (/= ','))) $ "abc,123,do re me"
16:49:59 <lambdabot>  ["abc","123","do re me"]
16:50:12 <Saizan> lispy: -fglasgow-exts
16:52:46 <LoganCapaldo> > filter (/= ",") . groupBy (\x y -> all (/= ',') [x,y]) $ "abc,123,do re me"
16:52:48 <lambdabot>  ["abc","123","do re me"]
16:53:53 <LoganCapaldo> @pl \x y -> all (/= ',') [x,y]
16:53:53 <lambdabot> (all ((',') /=) .) . (. return) . (:)
16:54:20 <LoganCapaldo> @pl -> \x y -> [x,y]
16:54:20 <lambdabot> (line 1, column 1):
16:54:20 <lambdabot> unexpected "-"
16:54:20 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
16:54:29 <LoganCapaldo> @pl \x y -> [x,y]
16:54:29 <lambdabot> (. return) . (:)
16:54:34 <LoganCapaldo> foof
16:55:37 * chessguy sighs. i think i could have done this faster by hand
16:57:30 <LoganCapaldo> @type \pred list -> filter (not . pred) . groupBy (\a b -> (not . pred) a && (not . pred) b)) list
16:57:32 <lambdabot> parse error on input `)'
16:57:50 <LoganCapaldo> @type (\pred list -> filter (not . pred) . groupBy (\a b -> (not . pred) a && (not . pred) b))) list
16:57:52 <lambdabot> parse error on input `)'
16:57:58 <LoganCapaldo> @type (\pred list -> filter (not . pred) . groupBy (\a b -> (not . pred) a && (not . pred) b)) list)
16:58:00 <lambdabot> parse error on input `)'
16:58:09 * LoganCapaldo goes away
16:58:45 <MyCatVerbs> @src foldl
16:58:45 <lambdabot> foldl f z xs = lgo z xs
16:58:45 <lambdabot>     where lgo z []     =  z
16:58:45 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
16:58:49 <MyCatVerbs> @src sum
16:58:49 <lambdabot> sum = foldl (+) 0
17:00:02 <oerjan> chessguy: for the parsing, you might try something like map (map read . tail . words) . lines, assuming the label on each line is a single word
17:00:50 <dibblego> is foldl' the strict foldl?
17:00:53 <lispy> > sum [1..100000000]
17:00:58 <lispy> dibblego: yes
17:00:59 <lambdabot> Terminated
17:01:16 <lispy> > foldl' (+) 0 [1..100000000]
17:01:22 <lambdabot> Terminated
17:01:27 <oerjan> oh, forgot the commas
17:01:28 <dibblego> thought so, thanks (there are so many foldl* I get foncused)
17:02:30 <lispy> although, it seems that sum may be strict enough to not need foldl'
17:02:42 <lispy> well, assuming your Num instace is strict i guess
17:03:02 * lispy has made non-strict num instances
17:03:28 <chessguy> actually, the commas are easy to take out with an editor
17:04:16 <dmhouse> sum is lazy because you can't assume (+) is strict, yes.
17:04:30 <dmhouse> ?src sum
17:04:31 <lambdabot> sum = foldl (+) 0
17:04:35 <dibblego> ?src foldl
17:04:35 <lambdabot> foldl f z xs = lgo z xs
17:04:35 <lambdabot>     where lgo z []     =  z
17:04:35 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:04:55 <dibblego> ?src foldl'
17:04:56 <lambdabot> foldl' f a []     = a
17:04:56 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:05:26 <Saizan> sum has RULES to be stricter with Int,Integer, etc..
17:06:00 <MyCatVerbs> Hrmn...
17:07:13 <MyCatVerbs> I vaguely get why foldl (+) 0 [1..] consumes infinitely expanding quantities of memory and foldl' (+) 0 [1..], while never terminating, requires only constant space.
17:07:58 <sorear> No, foldl' (+) 0 [1..]  consumes infinitely (very slowly) expandign memory
17:08:03 <MyCatVerbs> But how come this: let { sleff f z [] = z; sleff f z (x:xs) = sleff f (($!) (($!) f z) x) xs; } in sleff (+) 0 [1..] -- takes infinitely expanding quantities of RAM, same as plain foldl does?
17:08:07 <sorear> because it defaults to Integer
17:08:41 <MyCatVerbs> sorear: oh right yeah, sizeof(Integer) increases. But if you pretend for a moment that integers are fixed-size...
17:10:26 <MyCatVerbs> What's my mistake in there? I'm attempting to create the same eagerness as foldl' has.
17:10:37 <oerjan> MyCatVerbs: that (($!) (($!) f z) x) is not evaluated until the whole list has been recursed into
17:10:41 <MyCatVerbs> (Er, please. If anyone would care to lend an eye.)
17:10:49 <MyCatVerbs> oerjan: oh, blast.
17:12:48 <Saizan> MyCatVerbs: you have to force f z x before the recursive call, (($!) (($!) f z) x) will just remain a thunk if nothing ask for it
17:13:57 <Saizan> with -fbang-patterns you'd write sleff f !z [] = z; sleff f !z (x:xs) = sleff (f z x) xs
17:14:01 <LoganCapaldo> what about foldr (+) 0 $ unfoldr (\n -> Just (n, (n + 1))) 0 ... ignoring Integer's growing size, will this be "constant" if you turn O up to 11?
17:16:05 <MyCatVerbs> Saizan: I'm not familiar with -fbang-patterns. How does one force f z x to be evaluated? Is that what the (rather strange looking) usage of seq in foldl' is there for?
17:16:08 <LoganCapaldo> > foldr (+) 0 $ unfoldr (\n -> Just (n, (n + 1))) 0
17:16:19 <lambdabot>  Exception: stack overflow
17:16:30 <LoganCapaldo> > foldl (+) 0 $ unfoldr (\n -> Just (n, (n + 1))) 0
17:16:36 <lambdabot> Terminated
17:16:57 <Saizan> MyCatVerbs: yeah, it's equivalent
17:17:59 <MyCatVerbs> Ohhhh! Right, I see.
17:18:07 <Saizan> sleff f z (x:xs) = let z' = f z x in z' `seq` sleff f z' xs <-- here z' is reduced to it's outermost constructor (its value in case of Int) before the recursion can be started
17:18:28 <MyCatVerbs> So, (seq x y) is the idiomatic way to force x to be evaluated immediately, so that you can make use of it in y?
17:19:01 <Saizan> yup
17:19:39 <Saizan> note that if x is for example a list, it will be evaluated only to something like (z:zs)
17:19:39 <MyCatVerbs> Kewl. Y'all are ridiculously goshdarn helpful.
17:20:07 <LoganCapaldo> weak head normal form, weak head normal form.
17:20:13 <Saizan> > undefined `seq` ()
17:20:14 * LoganCapaldo sings the weak head normal form song
17:20:14 <lambdabot>  Undefined
17:20:18 <MyCatVerbs> Saizan: ah, right, I see.
17:20:21 <Saizan> > [undefined] `seq` ()
17:20:23 <lambdabot>  ()
17:21:00 <Saizan> > length [undefined] `seq` ()
17:21:02 <lambdabot>  ()
17:21:18 <Saizan> > length (():undefined) `seq` ()
17:21:19 <lambdabot>  Undefined
17:21:25 <Saizan> :)
17:21:28 <LoganCapaldo> > length [undefined, undefined, undefined, undefined]
17:21:29 <lambdabot>  4
17:21:39 <MyCatVerbs> Saizan: is there some way to force the evaluation of zs, too? Other than strict folding or mapping with an identity function of some description?
17:22:06 <Saizan> there's a DeepSeq class somewhere
17:22:29 <Saizan> or you can use rnf (reduce to normal form) from Control.Parallel
17:22:34 <lispy> MyCatVerbs: there is a common idiom to make the arguments of a function strict, so you could use that
17:22:34 <LoganCapaldo> @type foldl' (flip (:)) []
17:22:35 <lambdabot> forall b. [b] -> [b]
17:22:49 <lispy> you could either use bang patterns or the idiom
17:22:55 <LoganCapaldo> @type reverse . foldl' (flip (:)) []
17:22:57 <lambdabot> forall b. [b] -> [b]
17:23:23 <Saizan> Lemmih: that will still only force the spine, like length
17:23:24 <LoganCapaldo> > reverse . foldl' (flip (:)) [] $ (():undefined)
17:23:25 <lambdabot>  Undefined
17:23:35 <LoganCapaldo> > reverse . foldl' (flip (:)) [] $ (():[])
17:23:36 <lambdabot>  [()]
17:23:38 <Saizan> err, LoganCapaldo
17:23:48 <LoganCapaldo> Saizan: ah
17:23:50 <LoganCapaldo> nvm then
17:23:57 <LoganCapaldo> it was worth a shot
17:24:01 <MyCatVerbs> That still seems kinda, er, expensive, anyway.
17:24:04 <dolio> > rnf [undefined]
17:24:04 <lambdabot>  Add a type signature
17:24:15 <dolio> > rnf [undefined :: Int]
17:24:16 <lambdabot>  Undefined
17:24:26 <LoganCapaldo> @type rnf
17:24:28 <lambdabot> forall a. (NFData a) => a -> Done
17:24:38 <MyCatVerbs> Not much use, considering that the reason for wanting to force eager evaluation is as a (crappy) optimization strategy anyway.
17:24:40 <LoganCapaldo> > rnf [1]
17:24:41 <lambdabot>  ()
17:24:52 <LoganCapaldo> :t () :: Done
17:24:54 <lambdabot> Done :: Done
17:24:57 <MyCatVerbs> (Unless the compiler can optimize it away to nothing, but that still seems like overkill.)
17:25:12 <LoganCapaldo> that's a fasicinating type alias
17:25:54 <LoganCapaldo> @instances NFData
17:25:55 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
17:26:05 <LoganCapaldo> @instances-importing NFData
17:26:06 <lambdabot> Couldn't find class `NFData'. Try @instances-importing
17:26:31 <MyCatVerbs> @src rnf
17:26:31 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:26:42 <dolio> @src [] rnf
17:26:42 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
17:26:44 <igli> @botsnack
17:26:45 <lambdabot> :)
17:26:45 <LoganCapaldo> > let a = [undefined] in snd (rnf a, a)
17:26:46 <lambdabot>  Add a type signature
17:26:58 <LoganCapaldo> > let a = [undefined :: ()] in snd (rnf a, a)
17:26:59 <lambdabot>  Undefined
17:27:10 <LoganCapaldo> > let a = [1] in snd (rnf a, a)
17:27:12 <lambdabot>  [1]
17:27:17 <MyCatVerbs> Tarnation. What module is rnf in, please? I'm looking through the library docs generated from haddock and it doesn't seem to be in Control.Parallel.
17:27:29 <LoganCapaldo> @index rnf
17:27:29 <lambdabot> Control.Parallel.Strategies
17:27:30 <dolio> Control.Parallel.Strategies?
17:27:46 <LoganCapaldo> @bot
17:27:46 <lambdabot> :)
17:27:56 <MyCatVerbs> Ah, cool feature. Thanks.
17:28:07 <igli> heh nice one LoganCapaldo
17:28:25 <LoganCapaldo> igli: ?
17:28:46 <igli> er @bot short ver :-)
17:29:15 * MyCatVerbs stares at control.parallel.strategies' docs.
17:29:16 <dolio> > let a = [undefined :: ()] in snd (a, a)
17:29:17 <lambdabot>  Undefined
17:29:35 <LoganCapaldo> ah
17:29:40 <MyCatVerbs> Looks like this could do with some major expansion. Like, a few explainations as to what the HELL is going on with this stuff.
17:29:54 <LoganCapaldo> dolio: yeah I realized that after the fact
17:30:04 <dolio> :)
17:30:07 <LoganCapaldo> There should be a "lazy" show
17:30:18 <Saizan> > fix show
17:30:19 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:30:38 <dolio> rnf only does something if you demand its result, I think.
17:30:46 <Saizan> > show [(),undefined]
17:30:47 <lambdabot>  Undefined
17:31:00 <LoganCapaldo> Saizan: I mean "evil magic show that displays teh thring <Promise> or something"
17:31:02 <Saizan> > take 1 $ show [(),undefined]
17:31:03 <lambdabot>  "["
17:31:03 <dolio> > let a = [1, 2, 3, undefined] in snd (rnf a, take 3 a)
17:31:04 <lambdabot>  [1,2,3]
17:31:21 <Saizan> > take 4 $ show [(),undefined]
17:31:22 <lambdabot>  "[(),"
17:31:29 <Saizan> > take 5 $ show [(),undefined]
17:31:30 <lambdabot>  Undefined
17:32:04 <Saizan> i think that lb is doing something here
17:32:46 <MyCatVerbs> If I understand this properly, (x:xs) takes constant storage only: one data structure holding the value of x, and another thunk structure specifying how to calculate the next (and any further) values of xs should you want to get at them, right?
17:33:01 <oerjan> >[1..100]++[undefined]
17:33:25 <oerjan> > [1..100]++[undefined]
17:33:26 <lambdabot>  Undefined
17:33:52 <oerjan> > [1..1000]++[undefined]
17:33:53 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:34:01 <MyCatVerbs> So a strict version of map would be mostly pointless, since it wouldn't improve the memory requirement at all (though it might save a tiny quantity of CPU time under some circumstances)?
17:34:46 <Saizan> MyCatVerbs: it mostly depends on the function you are mapping
17:35:19 <oerjan> > [1..200]++[undefined]
17:35:20 <lambdabot>  Undefined
17:35:26 <Saizan> but since map "returns" one element at a time, it can be consumed before allocating
17:35:27 <oerjan> > [1..300]++[undefined]
17:35:28 <lambdabot>  Undefined
17:35:30 <Saizan> the next
17:35:34 <oerjan> > [1..500]++[undefined]
17:35:35 <lambdabot>  Undefined
17:35:40 <oerjan> > [1..600]++[undefined]
17:35:41 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:35:49 <oerjan> > [1..513]++[undefined]
17:35:50 <lambdabot>  Undefined
17:36:10 <lispy> sometimes lambdabot is more strict
17:36:18 <MyCatVerbs> Saizan: howso? You mean the difference in CPU time usage would only be relevant when you're mapping a very fast function across a large list, or something else?
17:36:36 <oerjan> > [1..513]++[undefined]
17:36:37 <lambdabot>  Undefined
17:36:58 <MyCatVerbs> Saizan: and am I totally off the mark about how much space an unevaluated list takes up, or...?
17:37:29 <SamB> MyCatVerbs: what do you mean by strict?
17:37:48 <Olathe> > [1..538]++[undefined]
17:37:49 <lambdabot>  Undefined
17:37:53 <Olathe> > [1..539]++[undefined]
17:37:54 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
17:38:29 <oerjan> > length (show [1..538])
17:38:30 <lambdabot>  2045
17:38:40 * SamB thinks lambdabot shouldn't just display "Undefined" when something has a bottom in it somewhere
17:38:45 <MyCatVerbs> SamB: like the kind of naive map implementation a C programmer would write. As in, running the function against the whole list immediately rather than mapping the function against list elements one at a time as required.
17:39:12 <dibblego> MyCatVerbs, refunctoring!!
17:39:13 <oerjan> right, lambdabot uses "take 2048" or something
17:39:14 <SamB> MyCatVerbs: A C programmer would expect *ours* to work that way
17:39:20 <MyCatVerbs> SamB: or, uh, more concisely, written so that the result of strictmap f l would be bottom if *any* element in l is bottom.
17:39:38 <MyCatVerbs> (or if l is infinite, I guess)
17:39:54 <SamB> ah, so strict in the elements and in the tail?
17:40:01 * MyCatVerbs nods.
17:40:55 <Saizan> i don't think you can gain much with it, maybe some unboxing?
17:42:05 <SamB> i.e. map f [] = []; map f (x:xs) = y `seq` ys `seq` (y:ys) where y = f x; ys = map f xs
17:42:09 <SamB> ?
17:42:14 <MyCatVerbs> Saizan: I don't think there'd be any gain at all in space consumption, but maybe just a tiny gain in CPU time from not having to construct and evaluate thunks.
17:42:28 <SamB> you'd blow your stack
17:42:38 <SamB> i.e. it's a LOSS in space
17:42:44 <SamB> nwo.
17:42:50 <MyCatVerbs> SamB: thought so.
17:42:59 <SamB> if you were strict only in elements...
17:43:14 <SamB> i.e. map f [] = []; map f (x:xs) = y `seq` (y:ys) where y = f x; ys = map f xs
17:43:16 <MyCatVerbs> SamB: but if you know that the list is finite (short?) anyway, it's not neccessarily a problem.
17:43:25 <SamB> then maybe that'd be okay.
17:43:40 <SamB> MyCatVerbs: isn't wasting stack inefficient?
17:43:56 <dolio> You'd also risk losing cache coherence from operating on a list at a time rather than an element at a time.
17:44:11 <dolio> Would you not?
17:44:23 <SamB> yeah...
17:44:24 <MyCatVerbs> SamB: yes, but in space and not time.
17:44:33 <MyCatVerbs> dolio: oooh, good point, hadn't thought of that.
17:44:37 <sorear> dolio: cache efficiency maybe, but not coherence - coherence is a correctness aspect
17:44:55 <SamB> and maybe you wouldn't need all those element values in memory...
17:45:01 <SamB> hrmm.
17:45:15 <SamB> you'd lose, um, locality of reference
17:45:43 <Saizan> also, strictmap wouldn't fuse so well..
17:45:45 <MyCatVerbs> Cache locality, you mean. Or locality of reference.
17:46:10 <dolio> Ah, yeah, my bad.
17:46:47 <MyCatVerbs> dolio: cache coherence is what clueless bastards playing with multiprocessor machines using unsafe code violate. ;)
17:46:56 <dolio> :)
17:47:39 <Saizan> do quantum computers have cache decoherence?
17:47:53 <SamB> they have not got caches
17:48:05 <MyCatVerbs> dolio: oh and what clueless bastards playing with CPUs with seperate I and D caches screw up when they do stupid things like scribble over the values of opcodes that're physically close in memory... but that's handled transparently for you by the hardware on most archs (though the perf hit isn't ^^).
17:48:41 <SamB> MyCatVerbs: I thought most architectures required you to warn about that?
17:49:02 <MyCatVerbs> Saizan: if a tree falls in the forest and there's nobody to hear it but the clueless D-wave marketroid, does his last dying breath still get published by a clueless twat working for "Wired"?
17:49:59 <sorear> SamB: Good architectures, yes, with cache flush instructions.
17:50:01 <MyCatVerbs> SamB: ...no, you're right. I think most RISC archs require you to warn about that, but AFAIK i386 does it for you transparently, albeit at a perf hit that'll make your eyeballs bleed.
17:50:02 <Saizan> ?yow
17:50:02 <lambdabot> Make me look like LINDA RONSTADT again!!
17:50:10 <sorear> SamB: Bad ones like i386 do it automagically.
17:50:16 <SamB> MyCatVerbs: yes, i386 bein a notable exception
17:50:33 <SamB> but there are a heck of a lot more RISC arches than there are i386 arches
17:50:41 <sorear> SamB: With very nasty logic, resulting in very nasty corner cases.  Ever heard of the K6 high memory bug?
17:50:54 <SamB> nope
17:50:55 <MyCatVerbs> SamB: well. i386 is kinda legacy-ish. I mean, the instruction set hails from the bad old days of CPUs that didn't even have cache at all.
17:51:41 <MyCatVerbs> SamB: dunno, there are a surprisingly large number of really old CISC architectures. 6502s, 68ks, Burroughs machines, 8080s, 4004s...
17:52:10 <sorear> SamB: The AMD K6 first stepping had a cut corner in the I/D coherency logic which caused memory writes to flush caches 32MB away, as well as at the same address.  Not a problem.
17:52:15 <SamB> MyCatVerbs: oh, I thought you meant current arches
17:52:37 <MyCatVerbs> SamB: and there are only a handful of RISC architectures out in the wild. Pretty much nobody's making new ones any more. MIPS, SPARC, POWER and maybe as many again tiny niche ones. 
17:52:49 <sorear> SamB: It also had a bug in the speculative execution engine which caused one instruction to be executed twice if a trace was abandoned due to modification.
17:52:57 <SamB> also, those old ones aren't either i386 or RISC, and they don't need to do anything special for overwriting machine code in RAM
17:53:03 <sorear> SamB: Most i386 instructions are idempotent, but
17:53:20 <SamB> sorear: hmm?
17:53:34 <sorear> SamB: if the stars are just right all this will happen on an INC or DEC, thus resulting in very subtle miscomputation.
17:54:03 <MyCatVerbs> SamB: yeah, true. My perceptions are pretty strongly coloured by what I'm used to - mostly i386en and Z80s.j
17:54:35 <SamB> and I thought we were talking about current arches
17:54:43 <MyCatVerbs> Heh.
17:54:44 <SamB> (nobody bothers with 8080s anymore do they?)
17:54:58 <MyCatVerbs> SamB: I suffer heavily from all-the-world's-a-VAX syndrome and tend to make pretty boneheaded mistakes about Harvard archs and RISC kit.
17:55:05 <SamB> (Z80s being better and all)
17:55:41 <MyCatVerbs> SamB: but of course not. Z80s not being any more expensive, either. ^^
17:57:08 <MyCatVerbs> Though I'm not sure if anyone sane would use Z80s either now. PICs are cheaper to put in things, what with the lower chip count and all.
17:57:22 <MyCatVerbs> No external RAM or PIOs, lah.
17:57:35 <SamB> but Z80's are a lot more comfy
17:58:06 <MyCatVerbs> Eh. You can get (crap) faux-C compilers for PICs now.
17:58:41 <MyCatVerbs> Oooh, there's a thought. I wonder what Haskell on a PIC would be like? XD
17:58:50 <MyCatVerbs> Wait, no, better idea.
17:59:20 <sorear> Maybe I should retarget the K-RAFTS 65816 forth compiler to the PIC :)
17:59:21 <sorear> +project
17:59:25 <MyCatVerbs> We design a CPU specifically for the sake of being used as a Haskell machine. Customize it with instructions for fast thunking and stuff.
17:59:44 <MyCatVerbs> The spiffy bit is that instead of Verilog or VHDL or something, we write the CPU design in Atom HDL. XD
17:59:49 <Boney> now you sound like the Lisp Machine guys.\
18:00:08 <SamB> Boney: I think he just wants to avoid doing a ton of instruction fetch cycles...
18:00:10 <MyCatVerbs> Boney: Yes, but those things were really awesome computers.
18:00:19 <desp> looks like people are spamming the Haskell trac
18:00:30 <Boney> So I'm told.
18:00:31 <MyCatVerbs> sorear: Forth compiler?
18:00:38 <desp> http://hackage.haskell.org/trac/summer-of-code/ticket/1132 http://hackage.haskell.org/trac/summer-of-code/ticket/1133
18:00:40 <lambdabot> Title: #1132 (flash site builder software johor bahru web hosting) - Haskell.org Google ...
18:00:40 <sorear> MyCatVerbs: Yes!
18:00:41 <Philippa> MyCatVerbs: how would you do faster thunking?
18:01:06 <LoganCapaldo> Haskell machine. Would it have a lazy hard drive?
18:01:07 <sorear> desp: that's best announced on #ghc and prefixed with Igloo:
18:01:18 <SamB> LoganCapaldo: I thought that was called Linux
18:01:42 <LoganCapaldo> Or a lazy filesystem? Wouldn't delete anything until you actually looked at the directory listing again? :)
18:01:47 <MyCatVerbs> sorear: is it actually neccessary to compile Forth, except for purposes of optimization? I thought Forth bytecode 'terps were usually Damn Well Fast Enough, plus more compact to boot.
18:02:14 <sorear> MyCatVerbs: Forth bytecode 'terps use a lot of ram, relatively speaking :)
18:02:17 <desp> sorear: ack
18:02:30 <MyCatVerbs> SamB: heh. I've copied out megs of files onto floppies before, only for the system to not actually *write* anything until after typing "sync" XD
18:02:57 <sorear> MyCatVerbs: Does the pic have somethign line the 4004's FIN instruction?
18:03:05 * sjanssen seriously doubts the plural on "megs"
18:03:22 <MyCatVerbs> Philippa: dunno. Make one instruction that constructs a thunk for calling some function in a single cycle, and another instruction that eats up a thunk and calls the required function in a single opcode?
18:03:34 <Philippa> sjanssen: 2.88s weren't that uncommon
18:03:35 <MyCatVerbs> sjanssen: one point two-ish. ;)
18:03:43 <sorear> sjanssen: Is there anything we can do to make failure-to-autoreconf errors on X11-extras easier to spot?
18:03:51 <MyCatVerbs> sorear: dunno, what did that do, please? I'm not familiar.
18:04:06 <sorear> MyCatVerbs: Fetch INdirect from rom
18:04:21 <Philippa> sjanssen: also, compression. I'm surely not the only one who crammed semi-ludicrous amounts of data onto floppies back in the day
18:04:23 <SamB> Philippa: why don't they sell 'em anymore?
18:04:25 <sorear> MyCatVerbs: thus allowing you to access tables
18:05:19 <sjanssen> sorear: I'm not particularly worried about it -- releases don't require it and darcs users can read the commit messages
18:05:20 <sorear> MyCatVerbs: Actually I suppose that's unnecessary.  You can always do STC
18:05:27 <MyCatVerbs> sorear: ahhh. I'm not sure. The instruction sets vary a lot from model to model.
18:05:43 <sorear> MyCatVerbs: can pics call subroutines?
18:06:20 <MyCatVerbs> sorear: about the only thing they seem to have in common are that they're all accumulator machines and all Harvard machines. Some of them have *really* minimalist instruction sets - practically no way of building indirection in at all, even.
18:06:22 <Igloo> sorear, desp: You want someone else for the SoC trac, really
18:06:37 <MyCatVerbs> sorear: subroutines? Kinda.
18:06:59 <sorear> hold on a sec - must restart X, upgrading xmonad
18:07:16 <sjanssen> huh?  Since when is restarting X required?
18:07:21 <desp> Igloo: I'd gladly clean that up, but i don't have access :)
18:07:23 <MyCatVerbs> sorear: like, the PIC14xxx's I've played with (or was it PIC16? I can't remember) had CALL/RETURN instructions, but only an 8-deep stack. And no operand stack.
18:07:25 <Eidolos> sorear: no gnu screen? :)
18:07:43 <sorear> sjanssen: Since you decided to incompatibly change the StackSet format.
18:08:05 <sjanssen> sorear: put all your windows on one workspace :)
18:08:05 <sorear> sjanssen: Not a big deal, since it doesn't happen every patch :)
18:08:35 <sjanssen> xmonad gracefully handles the parse failure, but fails to pick up iconified windows
18:11:17 <MyCatVerbs> Whoa, the channel just stopped for three minutes in a row. And after such heavy activity, too...
18:11:37 * MyCatVerbs thought his SSH connection had died again there.
18:13:41 <Eidolos> ?? mimic[5]
18:19:44 <sorear> Mimic, eh?  /me is reminded of the nethack-wiki and /whois Eidolos
18:20:21 <Eidolos> ;)
18:20:27 <Eidolos> in-joke, only one person will get it
18:20:42 <Eidolos> and probably not even him! :(
18:21:42 <dylan> @hoogle FilePath -> FilePath -> FilePath
18:21:42 <lambdabot> Distribution.Compat.FilePath.dropPrefix :: FilePath -> FilePath -> FilePath
18:21:42 <lambdabot> Distribution.Compat.FilePath.joinPaths :: FilePath -> FilePath -> FilePath
18:22:18 * MyCatVerbs smites Eidolos, munches h(is|er) corpse and resultingly disguises himself as a pile of gold for no good reason.
18:23:26 <Eidolos> 8)
18:23:51 <shachaf> "You can't resist the temptation to mimic an orange."
18:24:00 <richcollins> ghc isn't finding libreadline.  how can I check to see where it is looking?
18:24:18 <MyCatVerbs> shachaf: the closest I've ever come to mimicing an orange is in body shape.
18:24:34 <MyCatVerbs> shachaf: between laziness and a damnably insistent sweet tooth...
18:24:39 <richcollins> ldd isn't working on the ghc binary
18:24:49 <ekidd> ddarius: You around?
18:25:00 <MyCatVerbs> richcollins: try: file `which ghc`
18:25:04 <LoganCapaldo> mimic :: (Mimic a, Mimicable b) => b -> a -> b
18:25:15 <MyCatVerbs> richcollins: IIRC, it's a Bourne shell script that calls out to the *real* ghc binary.
18:25:19 <richcollins> MyCatVerbs, it is in /usr/local/bin
18:25:19 <sorear> richcollins: ghc -v5
18:25:23 <richcollins> ah
18:25:23 <shachaf> MyCatVerbs: "You suddenly dread being peeled and mimic a human again!"
18:25:34 <wchogg> Okay, might be a silly question but what's fundamentally the difference between a data declaration with only one constructor and a newtype?
18:26:02 * LoganCapaldo feels an impending sense of deja vu
18:26:03 <ekidd> wchogg: Not very much, except that newtype promises to be really, really efficient.
18:26:03 <sorear> richcollins: Ah, you need to hexedit the binary and change 'libreadline.so.4' to 'libreadline.so.5'
18:26:11 <MyCatVerbs> richcollins: oh.
18:26:27 <MyCatVerbs> richcollins: weird. Works on my system (OpenBSD 4.0 w/ ghc 6.6).
18:26:29 <richcollins> sorear, it is looking for .5
18:26:34 <ekidd> wchogg: Oh, and it supports newtype deriving, which is described in the GHC manual. There's probably something else, too.
18:26:41 <sorear> richcollins: then go the other way
18:27:02 <MyCatVerbs> shachaf: sounds horrible. I've always vaguely wondered what happens if someone steals you while you're mimicing gold, though.
18:27:13 <wchogg> ekidd:  Okay, so in principle though there isn't necessarily much of a difference?  It's just implementation details?  Hrmm.
18:27:14 <sorear> richcollins: this is pretty shady business in general, but I know from experience that it works with ghc/readline
18:27:16 <MyCatVerbs> shachaf: are mimics and leprechauns more deadly acting in concert than alone?
18:27:29 <LoganCapaldo> And there's something about how newtype X = X Int vs. data Y = Y Int is like X _|_ is _|_ but Y _|_ is not _|_
18:27:32 <sjanssen> wchogg: the Haskell spec requires that a newtype has exactly the same representation as the type it wraps
18:27:36 <richcollins> sorear, http://pastie.caboo.se/70608
18:27:39 <lambdabot> Title: #70608 - Pastie
18:27:51 <wchogg> sjannsen:  Ah!  Okay.
18:27:58 <richcollins> sorear, I am actually trying to compile darcs which appears to fail when it checks for ghc
18:28:02 <dibblego> what are some good programming books (e.g. TAPL)
18:28:06 <ekidd> wchogg: You'd have to check the Haskell standard to be certain, but yeah, they're pretty much equivalent.
18:28:06 <richcollins> so this might be the wrong direction anyway
18:28:20 <shachaf> MyCatVerbs: Hmm, interesting. I can't find anything about it in the source, at first glance.
18:30:36 <MyCatVerbs> dibblego: SICP (first hit on Google)
18:30:36 <sorear> richcollins: editing the binary is a good workaround
18:30:36 <dibblego> MyCatVerbs, nice thanks
18:30:36 <richcollins> ugh
18:30:36 <sorear> shachaf: nope, nothing of the sort
18:30:36 <wchogg> sjannsen:  So it essentially acts just like a type declaration except that since it's "new" you can define different instances for it?
18:30:36 <wchogg> Err, type synonym.
18:30:36 <MyCatVerbs> dibblego: uhhh wait, I can find more'n that. Hang on while I dig up a link for you.
18:30:36 <sjanssen> wchogg: yeah, it's like a more principled type synonym
18:30:36 <dibblego> MyCatVerbs, great thanks
18:30:36 <wchogg> sjanssen:  Thanks, I hadn't know that.
18:30:36 <MyCatVerbs> dibblego: right, have a look at this: http://programming.reddit.com/info/1y0ux/comments
18:30:36 <lambdabot> Title: The Six Essential *Language Agnostic* Programming Books (reddit.com)
18:30:36 <sjanssen> wchogg: also note that the typechecker considers them different types
18:30:36 <MyCatVerbs> dibblego: totally ignore the main article, it's shite.
18:30:36 <dibblego> MyCatVerbs, I know, I commented on it and have been emailing the author since :)
18:30:36 <MyCatVerbs> dibblego: read the comments instead, they're written by much cleverer people than the fuckstain blogger who's been linked to.
18:30:36 <richcollins> I'll just compile it
18:30:36 <sorear> MyCatVerbs, shachaf: nethack has a number of disgusting asymetryies between the player and monsters.  I've managed to fix them in tinyhack (an unpublished rl of my own) - but tinyhack is incredibly slow because of all the vision checks between every pair of monsters
18:30:36 <richcollins> hrm there is no make uninstall
18:30:55 <sorear> richcollins: indeed.  the ghc team doesn't believe in that stuff
18:31:15 <sorear> richcollins: wait - you can't install a binary ghc, so you're trying to install it from source?
18:31:21 <sorear> richcollins: is that correct?
18:31:35 <MyCatVerbs> sorear: really? I didnae realise that. I thought nethack was pretty impressively symmetric between the two, what with how gracefully it handles things like the player polymorphing themselves into various monsters.
18:31:49 <richcollins> sorear, yes I was hoping doing it from source would find the libs during configure
18:31:56 <richcollins> sorear, I already installed the binary
18:32:00 <MyCatVerbs> dibblego: http://www.cs.brown.edu/~sk/Publications/Books/ProgLangs/2007-04-26/
18:32:03 <lambdabot> Title: Programming Languages: Application and Interpretation by Shriram Krishnamurthi, http://tinyurl.com/2bhkwx
18:32:04 <sorear> MyCatVerbs: it fakes it on the surface, but inside the code is duplicated to a ridiculous extent :(
18:32:09 <MyCatVerbs> dibblego: another decent one, published fwee! online.
18:32:13 <ekidd> If anybody is interested in reading a draft of my probability monad paper, see channel #probabilitymonads.
18:32:15 <dibblego> thanks
18:32:18 <shachaf> sorear: I would agree about the asymmetries.
18:32:20 <MyCatVerbs> sorear: oh, pity. Still.
18:32:21 <sorear> richcollins: You need a binary GHC to compile GHC.
18:32:32 <sorear> richcollins: it's written in haskell with ghc extensions
18:32:37 <richcollins> sorear, ah metacircular :(
18:32:39 <ekidd> I'm currently editing madly.
18:32:41 <MyCatVerbs> sorear: they'll never live up to Operation Flashpoint, anyway. Now *that* is what I calls symmetry! ^_^
18:32:48 <sorear> MyCatVerbs: OF?
18:33:11 <sm> hmm.. haskell nethack port, anyone ?
18:33:28 <richcollins> sorear, So hexedit is the best option?
18:33:29 <LoganCapaldo> Purely functional nethack
18:33:42 <MyCatVerbs> sorear: Flashpoint 1985. Game by some little studio, uh, I think they're Czech. _Ridiculously_ realistic end-of-Cold-War era wargame.
18:33:43 <sorear> richcollins: Yes.
18:33:45 <LoganCapaldo> sounds, dangerous
18:33:48 <richcollins> ugh
18:33:49 <shachaf> sm: A perfect Nethack port/clone seems like it would be very hard.
18:34:06 <sorear> richcollins: not hard at all, hexedit has a search feature
18:34:08 <sm> yes, probably
18:34:11 <shachaf> sm: A lot of Nethack depends on its C-ness, I think.
18:34:27 <LoganCapaldo> You could call it HackMonad
18:34:37 <shachaf> sm: But a roguelike in Haskell... I  think there are some.
18:34:41 <sm> still, haskell excels at modelling.. it should be doable ?
18:34:49 <LoganCapaldo> it could be the second in a long line of practical *Monad Haskell applications
18:34:54 <MyCatVerbs> sorear: basically it's the Nethack of FPSes, in that you are guaranteed to die like ten million times, it's evilly hard, you get killed a lot, it can be pretty hairily complex (though not to anything like the same extent) and it's not a rare event for you to get your ass shot into mincemeat. Oh and did I mention the game wasn't very easy?
18:35:04 <richcollins> sorear, hexedit is command line?
18:35:13 <LoganCapaldo> Think we can get darcs to change its name to SourceMonad or something?
18:35:17 <sorear> richcollins: yeah. 'hexedit FILE'
18:35:26 <richcollins> sorear, using opensolaris
18:35:30 <richcollins> doesn't appear to have it
18:35:33 <MyCatVerbs> LoganCapaldo: that _would_ be good PR, except that "darcs" is snappier.
18:35:44 <LoganCapaldo> yeah I know
18:36:20 <LoganCapaldo> darcsM ?
18:36:23 <MyCatVerbs> dibblego: oh and there's all the really awesome classics like the MINIX book, the Dragon book, etc. But those're bastard expensive, argh.
18:36:23 <richcollins> oh ther eis a packge
18:36:41 <dibblego> MyCatVerbs, I think I've already exhausted my permitted list :)
18:36:43 * shachaf hasn't ascended in Nethack yet. :-(
18:36:51 <sm> actually, that reminds me.. I saw a (roguelike + 3d graphics) the other day - http://roguestar.downstairspeople.org/screenshots.html
18:36:52 <lambdabot> Title: Chapter&#160;2.&#160;Screenshots
18:37:12 <MyCatVerbs> LoganCapaldo: not that it's impossible, mind. I mean, there's the whole Yellow Pages/NIS dichotomy that cropped up with the distributed logon tech.
18:37:19 <MyCatVerbs> shachaf: nor me. I still love it, though.
18:37:47 <MyCatVerbs> sm: ehhhh.
18:37:48 <shachaf> MyCatVerbs: I've gotten pretty close.
18:38:00 <MyCatVerbs> emu: there's a Ninja class, but no Pirate. Fuck that, arrrrr!
18:38:00 <shachaf> MyCatVerbs: All the way to the amulet and up to the valley of the dead.
18:38:09 <emu> YARR
18:38:13 <MyCatVerbs> shachaf: oh, ouch. Lemme guess, that prick sonofabitch Death?
18:38:22 <shachaf> MyCatVerbs: No, not THAT close.
18:38:38 <shachaf> MyCatVerbs: Just a (master?) mind flayer.
18:38:43 <MyCatVerbs> shachaf: oh.
18:38:50 <MyCatVerbs> shachaf: hah, I had one of those the other day.
18:39:07 <richcollins> sorear, so I have to search in hex?
18:39:12 <shachaf> MyCatVerbs: Death by mind flayer? Or down-and-halfway-back-up?
18:39:14 <mlh> dibblego: http://www.hanselman.com/blog/SixEssentialLanguageAgnosticProgrammingBooks.aspx
18:39:17 <lambdabot> Title: Scott Hanselman's Computer Zen - Six Essential Language Agnostic Programming Boo ..., http://tinyurl.com/2kzqd3
18:39:17 <MyCatVerbs> shachaf: was playing a newbie wizard, something like level six or seven, and a MMF appeared in like level two of the gnomish mines.
18:39:18 <sorear> richcollins: No, search in ascii.
18:39:28 <richcollins> sorear, / to search?
18:39:41 <richcollins> Invalid hexa string
18:39:43 <MyCatVerbs> shachaf: in retrospect, "I bet I can take that on," was a really, really stupid thing to be thinking.
18:39:45 <sorear> MyCatVerbs: That is why Charm Monster is one of the most useful spells ever. :)
18:39:53 <richcollins> when I use / and then search for libreadline
18:39:54 <sorear> richcollins: TAB first
18:39:56 <sm> MyCatVerbs: lol
18:40:01 <dibblego> mlh, I think that web page is complete rubbish, left a comment to suggest so and the author has since gone off to learn Haskell :)
18:40:05 <richcollins> ah gotcha
18:40:17 <MyCatVerbs> sorear: I always liked scrolls of taming best. Blessed for extra chaos.
18:40:18 <shachaf> MyCatVerbs: In my case -- the "oY was draining my Pw, otherwise I could've finger-of-deathed that mind flayer easily.
18:40:28 <MyCatVerbs> shachaf: ah, suckage. :/
18:40:32 <shachaf> MyCatVerbs: The first shot missed, and then it was too late. :-(
18:40:49 <shachaf> MyCatVerbs: I took a long Nethack break after that.
18:40:52 <MyCatVerbs> sorear: there's something hilarious about popping into bigroom, casting Taming and then watching the almighty fuckin' punchup ensue.
18:41:41 * MyCatVerbs idly flips over to the other screen window and rolls up another elven wizard,
18:42:35 <shachaf> MyCatVerbs: Do you play on NAO?
18:42:41 <mlh> dibblego: at least he corrects his omissions with tapl and sicp
18:42:58 <dibblego> mlh, indeed, his email seems to suggest that he is open-minded
18:43:04 <mlh> I don't know about the other 4, but pearls and code complete are good books
18:43:53 <MyCatVerbs> shachaf: NAO? I'm not sure what that stands for.
18:44:06 <shachaf> MyCatVerbs: nethack.alt.org
18:44:08 <LoganCapaldo> nethack.alt.org
18:44:13 <shachaf> MyCatVerbs: Public Nethack server.
18:44:15 <LoganCapaldo> according to the almighty gooohoogle
18:44:50 <shachaf> MyCatVerbs: Others can watch your games, send you messages (via mail daemon), global bones/highscores, etc.
18:44:55 <MyCatVerbs> ...fuck.
18:45:06 <MyCatVerbs> I am just playing the gimpiest damn characters tonight.
18:45:33 <richcollins> sorear, libreadline.so.5.libncurses.so.5.libgmp.so.3./usr/local/lang/lib/gcc/i386-pc-solaris2.10/3.4.6:/usr/local/lib
18:45:34 <MyCatVerbs> First character, immediately thwarted on first level by secret doors. Decide I'm too likely to starve before finding anything to kill and eat, run back up stairs.
18:45:48 <richcollins> it appears to look in /usr/local/lib
18:46:00 <MyCatVerbs> Second character, immediately mistake a gray stone on the floor for a touchstone. Pick it up. Oh shit, cursed loadstone. Dammit. x_x
18:46:31 <shachaf> MyCatVerbs: They're always cursed. :-)
18:46:52 <sorear> shachaf: from mkobj, yes.  but loadobj maybe not! :)
18:46:55 <shachaf> MyCatVerbs: Why pick them up if you're not certain (by kicking)?
18:47:21 <shachaf> sorear: loadobj?
18:47:24 <MyCatVerbs> shachaf: because I'm a dumbass.
18:47:29 * shachaf doesn't know that much about Nethack internals.
18:47:32 <sorear> Nethack is no fun for me.  I thoroughly understand the code, and if stats were accurate, I'd have a WIS of 2^31/**
18:47:34 <MyCatVerbs> ...killed by a fucking gnome while helpless.
18:47:57 <sorear> MyCatVerbs: "fucking gnome" is not a monster in standard nethack 3.4.3 :)
18:48:26 <MyCatVerbs> sorear: try sluthack 3.4.bitch.bitch.bitch
18:48:35 <shachaf> sorear: I assume that you've ascended, yes?
18:48:41 * allbery_b prefers dungeon crawl, "stone soup" branch
18:48:50 <allbery_b> (crawl-ref.sf.net)
18:48:57 <LoganCapaldo> oh wow, nethack.alt.org is awesome. I cna just watch other people play
18:49:00 <sorear> shachaf: Not even close.  I wind up losing interest around level 3
18:49:09 <LoganCapaldo> this is way easier than eactually playing
18:49:37 <shachaf> LoganCapaldo: You can send them mail, too (press "m").
18:51:03 * MyCatVerbs would give it a go, but he's just rolled up a new character. So, not happening until this one dies... five minutes, maybe.
18:51:26 * LoganCapaldo suspects this person knows how to pl;ay nethack
18:52:04 <LoganCapaldo> The one I'm watching I mean
18:52:16 <shachaf> LoganCapaldo: Many NAOers tend to.
18:52:38 <LoganCapaldo> Cause I sure don't and I have no idea what's going on
18:53:17 <shachaf> LoganCapaldo: Oh, you mean, you haven't played at all?
18:53:28 <LoganCapaldo> No I'v eplayed
18:53:44 <LoganCapaldo> I know how to play nethack the same way i know how to play chess
18:54:02 <LoganCapaldo> I know the legal moves and that's about it :)
19:02:28 <MyCatVerbs> Ah, fucking hidden doors.
19:09:09 <Modius> I'm trying to analyze a solution (that I got from someone on this channel once).  It uses listarray, which is filled from sparse data.
19:09:48 <Modius> What I'm quasi-tangentially wondering is - does this implement internally as an array?  I ask as technially it uses a "listarray = function of listarray" aspect to the solution
19:10:15 <Modius> Which makes me wonder - does listarray actually implement as an array?  How is it implemented internally?  I mean, this solution can't be allocating/filling a brand new array each run through. . . .
19:11:48 * MyCatVerbs grins like an idiot at shachaf.
19:15:08 <Modius> Aah - found it myself.  Diffarray - got it
19:15:37 <sorear> DiffArray is BAD
19:15:46 <sorear> v. slow
19:15:55 <Modius> Sorear - it may have been you who gave me this solution - it was for tugofwar
19:16:11 <sorear> tugofwar?
19:16:53 <Modius> I found my notes - it WAS you:  <sorear> Modius: the first case is just the lazy array filling idiom - memoization using an array, or something like that.  The second is the pseudo-standard imperative technique, using a list to accumulate at each stage
19:17:36 <ekidd> Who would have thought that leaving two weeks to finish a paper was leaving it until the last possible moment?
19:18:32 * ekidd weeps in despair, then jumps up to continue editing
19:20:51 <dankna> depends very much on the paper
19:21:43 <ekidd> danka: Probability monads. About 10 pages in SIGPLAN format, which is whole tons of words in tiny type. :-
19:22:16 <dankna> eep, indeed
19:22:40 <ekidd> danka: I've written almost all of it, and I'm currently editing.
19:23:06 <dankna> well, it sounds like you'll have it ready
19:23:33 <ekidd> danka: Yeah, but I'm a perfectionist, and I really want to spend days editing it.
19:23:38 <ekidd> Not going to get them, though.
19:24:36 <dankna> right, I see
19:25:09 <richcollins> Any darcs users here?
19:25:17 <dankna> aye
19:25:17 <richcollins> Getting a configure error, http://pastie.caboo.se/70616
19:25:19 <lambdabot> Title: #70616 - Pastie
19:25:52 <dankna> what's the output of ghc --version?
19:26:02 <dankna> this doesn't look like anything I've run into, but.
19:26:07 <richcollins> ghc --version
19:26:07 <richcollins> The Glorious Glasgow Haskell Compilation System, version 6.6.1
19:26:25 <richcollins> this is on opensolaris btw
19:27:07 <LoganCapaldo> Glory Glory Haskellia
19:28:12 <dankna> oh Solaris.  I remember hearing about trouble with Solaris.
19:28:16 <dankna> missing libraries or something
19:28:26 <richcollins> great
19:28:35 <dankna> there's an existing binary for it, do you really need the latest?
19:28:45 <richcollins> not sure
19:29:06 <richcollins> as long as we can all push to it using our 1.9 "clients"
19:29:36 <dankna> pretty sure the premade binary will work.  it's statically linked with everything it needs.
19:29:44 <richcollins> ok cool
19:29:50 <richcollins> I'll have a look
19:39:44 <richcollins> dankna, darcs
19:39:44 <richcollins> -bash: /usr/local/bin/darcs: Invalid argument
19:40:58 <dankna> all I can say is, that's really weird
19:47:42 <dons> sorear: in future, don't have lambdabot2 join lots of channels, its a pain cleaning up after.
19:47:42 <lambdabot> dons: You have 9 new messages. '/msg lambdabot @messages' to read them.
19:49:43 <ekidd> dons: Good evening!
19:50:33 <sorear> hi dons.
19:51:50 <chessguy> hiya dons
19:54:11 <dankna> richcollins: it just occurred to me that maybe you're accidentally executing a shell script that wraps around the darcs binary, and the shell script is configured wrong?
19:54:20 <richcollins> dankna, Nope just figured it out
19:54:25 <dankna> oh, good.  what was it?
19:54:26 <richcollins> downloaded the sparc binary
19:54:30 <dankna> ahh.
19:56:02 <richcollins> dankna, Wonder if the linux binary would work
19:56:42 <dankna> conceivable, if it doesn't need linux libraries.  I know freebsd has a linux-compat layer and can use linux binaries as native, but I don't know much about solaris at all.
19:57:06 <richcollins> neither do I unfortunately
19:57:45 <richcollins> I'll probably need to compile
20:18:50 <jfredett> Can I have a function with a monad of a monadic value?
20:19:00 <jfredett> like m a -> w m a ?
20:19:07 <jfredett> just out of curiousity
20:19:31 <bos> you mean -> w (m a)?
20:19:35 <jfredett> I guess something like IO String -> Maybe (IO String)
20:19:38 <emu> > return (return 1) :: [[Int]]
20:19:45 <jfredett> that makes sense. I suppose
20:19:46 <bos> yes, that's totally normal.
20:19:50 <jfredett> okay- nifty
20:19:54 <lambdabot>  thread killed
20:20:02 <sorear> dons!!
20:20:21 <bos> jfredett: in fact, there's a function named join for dealing with precisely that
20:20:26 <bos> @type join
20:20:28 <Saizan> ?type lift
20:20:28 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
20:20:30 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
20:21:10 <jfredett> and I assume I can take that to any number of monads? ie  (psuedohaskell)
20:21:10 <jfredett> m1 (m2 .... a) -> m0 (m1 (m2 ... a))
20:21:17 <jfredett> oh, nifty
20:21:20 <bos> yes.
20:21:23 <jfredett> cool
20:21:33 <bos> cf "monad transformers" for the generalised idea.
20:21:51 <jfredett> so _thats_ what a transformer is for. :/
20:22:22 <Saizan> yah since given a monad m, you can have any m a, and m1 (m2 .... b) can be called a :)
20:22:22 <emu> that's what the movie Transformers is all about!
20:23:06 <jfredett> i see, so Optimus Prime was a monad
20:23:07 <jfredett> I see
20:23:09 <Pseudonym> ?kind RWST
20:23:11 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
20:30:31 <lispy> did anyone see david's email on haskell-cafe about gadt type witnesses?
20:30:33 <lispy> any ideas?
20:31:19 <sorear> yeah
20:31:40 <sorear> david has ben abducted by aliens and replaced with an ML programmer
20:32:56 <sorear> haskellers don'
20:33:05 <sorear> t use Foo(x,y) syntax normally...
20:33:44 <sorear> Ahhh....
20:34:11 <lispy> sorear: i assume my reply just floated in :)
20:34:24 <sorear> yup ;)
20:35:08 <richcollins> Anyone here use solaris?
20:35:57 <sorear> Yes, I saw someone just today complaining about problems with GHC on OpenSolaris.
20:36:02 * sorear lastlogs
20:36:23 <sorear> Oops :)
20:36:30 <sorear> 18:34 < richcollins> sorear, using opensolaris
20:36:45 <richcollins> heh that was me
20:36:51 <richcollins> still trying
20:36:59 <richcollins> I think it will run linux binaries though
20:37:01 <richcollins> trying that now
20:37:11 <richcollins> 1.0.7
20:37:12 <sorear> anyway, I've seen bugs filed about Solaris linker support.  so it is definitely supported
20:37:25 <sorear> richcollins: ask on the mailing list, it's more diverse than #haskell
20:37:28 <sorear> haskell-cafe@
21:20:57 <ddarius> Bugger
21:21:42 <edwardk> ?
21:21:59 <ddarius> Missed ekidd
21:22:05 <edwardk> ah
21:22:12 <richcollins> sorear, http://www.nabble.com/-GHC---1421:-elf-object-code-problem-exposed-when-linking-under-i386-Solaris-10-t3900365.html
21:22:16 <lambdabot> Title: Nabble - [GHC] #1421: elf object code problem exposed when linking under i386 So ..., http://tinyurl.com/ytxkgg
21:22:33 <richcollins> I think that is the issue but the file they reference isn't there :)
21:22:34 <richcollins> :(
21:22:54 <sorear> richcollins: nabble is a mirror of a mirror
21:23:23 <sorear> http://hackage.haskell.org/trac/ghc/ticket/1421
21:23:24 <lambdabot> Title: #1421 (elf object code problem exposed when linking under i386 Solaris 10) - GHC ...
21:23:31 <sorear> ^^^ the source
21:23:35 <richcollins> ah there it goes
21:23:36 <richcollins> http://www.informatik.uni-bremen.de/agbkb/forschung/formal_methods/CoFI/hets/pc-solaris/versions/new-ghc-6.6.1-i386-unknown-solaris2.tar.bz2
21:23:40 <lambdabot> http://tinyurl.com/29yww6
21:42:51 <dibblego> is there a character for the little + that appears on the top right of Z, for the set of all positive integers?
21:44:13 <Apocalisp> How do I pass something of type Integer to a function that expects an Int?
21:44:24 <dibblego> ?hoogle Integer -> Int
21:44:27 <shapr> fromIntegral
21:44:40 <shapr> but if it's larger than Int, you're in trouble.
21:45:05 <Apocalisp> it's not.
21:48:52 * bos gets bitten by a misdesign in filepath
21:49:48 * sorear wonders what <b is supposed to signify
21:50:25 <bos> i've forgotten.  been using it for years.
21:51:17 <richcollins> sorear, ld: fatal: library -lgmp: not found
21:51:19 <richcollins> :(
21:51:24 <richcollins> is that the same as libgmp
21:51:28 <sorear> richcollins: Yes.
21:51:47 <richcollins> damn I have it
21:54:39 <sorear> richcollins: Probably not.  libgmp3 /= libgmp3-dev
21:54:48 <sorear> er, nm
22:17:57 <lucca> hm
22:18:07 <lucca> someone was asking about solaris linking?
22:19:31 <lucca> ah n/m
22:29:26 <sorear> dons: Failed to download URL http://www.cse.unsw.edu.au/~dons/code/darcs-graph/_darcs/inventory
22:29:27 <lambdabot> http://tinyurl.com/22ygtx
22:33:46 <dons> sorear: indeed. the machines are playing funny games down here.
22:35:01 <araujo> hello
22:35:34 <sorear> hello!
22:36:49 <araujo> @yarr!
22:36:49 <lambdabot> Shiver me timbers!
22:41:40 <hpaste>  dibblego pasted "is this code silly?" at http://hpaste.org/285
22:43:03 <sorear> dibblego: Yes.  You should be using IORefs and unsafePerformIO
22:43:16 <dibblego> for O(1) you mean?
22:43:38 <dibblego> and, wouldn't that just be another instance?
22:43:43 <sorear> Doesn't matter.  IORef/unsafePerformIO/Map would be better.
22:44:06 <sorear> Threading memo tables around manually buys very little.
22:44:21 <dibblego> so keep a global one?
22:44:29 <sorear> yes
22:44:40 <sorear> in a small, trustable module
22:45:01 <Saizan> and make sure you lookup the table for recursive calls
22:45:04 * emu sends in the referentially transparent police
22:45:07 <dibblego> do you have an example?
22:45:26 <dibblego> lookup the table for recursive calls? wtf?
22:47:17 <Mr_Awesome> im using glut, and i want to collect all the points generated by mouse motion while the mouse button is down, then perform a function on them when the button is released, but i dont even know how to start goin about it. it would require some sort of global var. can anyone give me a hint?
22:47:22 <Saizan> dibblego: suppose your f call itself in its definition, you want to use the memoized version of f for those calls
22:47:38 <dibblego> Saizan, that isn't universally true
22:48:34 <Saizan> well, yeah, it depends on f, but it's quite common
22:49:46 <dons> dcoutts: yeah, i agree with the appraisal, and have replaced the allocating inlinePerformIO with unsafe*
22:50:00 <dcoutts__> dons: ok
22:50:02 <dibblego> hey dons, the link to lambdabot COMMANDS gives a 403
22:50:04 <dibblego> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
22:50:17 <dons> yeah, file server here is playing up.
22:50:27 <dibblego> k
22:50:37 <Korollary> Mr_Awesome: I don't know glut, but you could use a global, or depending on where you collect that data, it may be just a local mutable var.
22:51:09 <Mr_Awesome> it has to be global. but i have no idea how to go about doing that
22:52:37 <Korollary> Why does it have to be a global? Anyways, check out Data.IORef.
22:53:44 <Mr_Awesome> well, the data is collected inside the callback to mousemotion, but the function needs to be applied when the mousebutton up event is received in a different callback
22:53:55 <Mr_Awesome> thanks, ill check that out
22:54:43 <Korollary> the two callbacks may share a binding to the mutable var without making it a global.
22:55:58 <jfredett> so I'm trying to decide which project will be both more interesting and more helpful (in terms of me learning how data types work in Haskell), a Algebra/Math system, or a simple Game. Any suggestions (for other projects or opinions on these?
22:56:00 <jfredett> )
22:56:37 <Korollary> jfredett: whichever is easier for you
22:56:51 <jfredett> well, thats my problem
22:57:12 <jfredett> I'm pretty much gonna have the same difficulty with both
22:57:37 <jfredett> I guess maybe writing a game would be worthwhile, as I haven't seen many haskell games in the recent past
22:58:13 <jfredett> but a CAS type system may be easier to plan out, at least in my case -- given my experience.
22:58:33 <Korollary> What experience do you have?
22:58:49 <jfredett> I'm a 3rd year Math Undergrad
22:58:59 <jfredett> with a CS double major
22:59:07 <Korollary> But have you written a CAS before?
22:59:13 <jfredett> nope
22:59:24 <jfredett> but it would be a damn good thing to put on my Resume.
22:59:40 <Korollary> Yes, for a math major
22:59:46 <Korollary> certainly better than the game
23:00:01 <jfredett> but I'm worried that I'm getting in over my head with the CAS
23:00:10 <jfredett> and maybe a Game would be a little easier-
23:00:11 <Korollary> well, I assume that it would be. Frankly, we don't care what you do as an undergrad.
23:00:12 <jfredett> i dunno
23:00:18 <jfredett> lol
23:00:30 <Korollary> I am speaking for most software developer positions
23:00:39 <jfredett> I see.
23:00:53 <jfredett> you mean in terms of project work too?
23:01:10 <Korollary> If you do it in grad school as part of your thesis or something, that may change things if the position requires hands-on experience in that area.
23:01:15 <jfredett> I figured that as far as classes go, thats moot, but real project work-
23:01:27 <jfredett> hmm
23:01:39 <jfredett> interesting-
23:01:53 <Korollary> Classes and GPA's matter. projects tend to be fluff.
23:02:20 <Korollary> But if you can explain it well during an interview, then a good project is a bonus.
23:02:31 <jfredett> cool, I'll remember that
23:02:36 <Korollary> Human resources doesn't even know what you did.
23:03:23 <jfredett> I've written a couple of neat things. thats what I banked my resume on- because I don't have any job experience (yet.)
23:03:49 <Korollary> jfredett: The recruiters are well aware of that.
23:03:58 <jfredett> maybe I'll try to rework it to emphasize my stellar (3.87, damn statistics...) GPA.
23:04:12 <jfredett> lol, I'm sure they are.
23:04:45 <jfredett> anywho- I think I may as well just dive in with the CAS
23:05:16 <jfredett> maybe I'll turn it into a thesis thing later-
23:05:21 <jfredett> i dont know, can you do that?
23:05:35 <jfredett> turn a previous project into a thesis, hmm
23:05:47 <cbrad> When interviewing, we generally ignore most undergrad work to :-)
23:05:59 <Korollary> Not exactly. You'll probably start over, but it will save you time.
23:06:01 <jfredett> well thats good to know-
23:06:12 <jfredett> Korollary: thats what I figured
23:06:15 <Mr_Awesome> Korollary: wait, they can share a binding?
23:06:18 <Mr_Awesome> how does that work?
23:07:19 <jfredett> alright- thanks for the help, Korollary. time for sleep though-- bye folks
23:07:30 <Korollary> Mr_Awesome: If you set up the callbacks in the same lexical scope, you can pass two local functions that share a binding.
23:07:35 <Korollary> jfredett: night
23:09:47 <Mr_Awesome> Korollary: but that binding would still have to be mutable, right?
23:11:26 <Korollary> Mr_Awesome: The binding can be to an IOVar, yes.
23:12:59 <Mr_Awesome> Korollary: is that in the standard lib?
23:13:07 <quicksilver> yes
23:13:10 <quicksilver> Data.IORef
23:13:23 <quicksilver> (Korollary meant IORef not IOVar)
23:14:39 <Korollary> oops yes
23:15:37 <aleator> If I'm lazy and want to do a global var containing image with 'lena = unsafePerformIO $ loadImage "l.jpg"', where loadImage is ffi call, will it bite me?
23:15:47 <ClaudiusMaximus> Mr_Awesome: an IORef is a nonmutable variable that is a reference to a mutable variable, you can pass the IORef around through any code, but accessing/modifying its contents needs to be done in the IO monad
23:16:25 <ClaudiusMaximus> Mr_Awesome: or something like that
23:16:35 <Mr_Awesome> yeah, i understand that
23:16:49 <Mr_Awesome> but what is this IOVar?
23:16:57 <Mr_Awesome> its not in the std lib
23:17:08 <Mr_Awesome> oh damn
23:17:13 <Mr_Awesome> sorry i didnt see that Korollary
23:17:19 <Korollary> no problem
23:17:27 <Mr_Awesome> thanks a lot for the help guys
23:23:25 <TSC> Is there some way I can tell cabal to use a different GHC (that is, provide a path to the executable) ?
23:23:52 <TSC> Ah, there it is
23:23:54 <TSC> Never mind
23:29:49 <nornagon> hm, I'm trying to write a function to compute tx/rx rate from /proc/net/dev
23:30:03 <nornagon> /proc/net/dev provides info on the number of bytes sent
23:30:44 <nornagon> so i need to read it at regular intervals and calculate a rate from that... my question is, how can i store the previous value?
23:31:27 <nornagon> ideally, i'd like a function that, when called, returns the difference between the number of bytes read when it was last called, and the number of bytes read now.
23:31:37 <nornagon> I imagine this involves some sort of StateT?
23:41:37 <ttfh> nornagon: maybe a scanl over the stream(lazy list) of measurements?
23:45:29 <ttfh> nornagon: read it in such a way that you get a lazy list of the "bytes read"-measurements, then use scanl with a function that computes the difference between 2 consecutive measurements, the scanl results in a list of differences which you print (lazily) or do whatever you want to do
23:46:08 <nornagon> hmm... interesting idea!
23:46:41 <ttfh> i like scanl
23:48:33 <nornagon> so bytesReadList would look a little like do { a <- bytesRead; b <- bytesReadList ; return (a:b) }
23:48:40 <nornagon> yes?
23:49:23 <ttfh> example: I had lap-times from a race and wanted accumulative(not what you call it...) times instead, sollution: scanl (+) 0
23:49:38 <nornagon> wouldn't that be foldl?
23:49:56 <nornagon> oh ah
23:50:12 <ttfh> scanl returns immediate result from a fold
23:50:15 <Mr_Awesome> hmm, i have "points = newIORef []" defined, but that means whenever i refer to points, it creates a new IORef. how can i hold onto the same IORef in a global variable?
23:51:05 <ttfh> with foldl you'd get the last difference only, and there is no "last" difference
23:51:26 <Lemmih> Mr_Awesome: Global mutable variables aren't really encouraged in Haskell.
23:51:27 <dons> you want a global mutable variable, Mr_Awesome ? that's a bit unHaskellish :)
23:51:36 <dons> Mr_Awesome: normally you'd use a state monad instead
23:51:52 <nornagon> well, that bytesReadList thingy I wrote above seems not to work.
23:51:56 <dons> runState (code that needs some state) (intial state)
23:52:30 <Mr_Awesome> yeah i know its unhaskellish. i just cant figure out any other way to do it
23:53:06 <ttfh> nornagon: Is there some variant of "getContents" you can use?
23:53:40 <nornagon> uh?
23:54:20 <Mr_Awesome> well, how can i establish a common lexical scope for two functions (containing that mutable variable) while still maintaining global access to these two functions?
23:54:29 <ttfh> nornagon: "getContents" returns a lazy IO String of the standard input
23:54:55 <nornagon> right
23:55:24 <ttfh> nornagon: "hGetContents" is the same but from a file handle
23:56:20 <nornagon> what's your point? I don't see how getContents is related.
23:56:34 <nornagon> (I'm already using it to get the contents of /proc/net/dev)
23:57:26 <ttfh> nornagon: Yes, I realise I was simplifying things a bit, quite a bit...
23:58:31 <ttfh> nornagon: you have to take care of the periodic measurements bit
23:59:33 <ttfh> nornagon: read /proc/net/dev, extract number of bytes, wait for a period of time, repeat
23:59:52 <nornagon> yes
