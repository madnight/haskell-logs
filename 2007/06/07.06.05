00:16:54 <dons> ?uptime
00:16:54 <lambdabot> uptime: 1h 45m 15s, longest uptime: 17d 7h 41m 6s
00:42:49 <thoughtpolice> question: in general, how long would you guys say it takes someone to really, seriously grok haskell? i haven't been with haskell very long, but when I read articles like dons' one over cpuperf, I feel like I'm simply overlooking a lot of stuff in the process of writing my apps; i get the feeling this is just because i'm reletively new, but I dunno.
00:43:33 <thoughtpolice> you get a sort of "oh wow didn't think about doing it that way" feeling; which in part I suppose is due to a lack of -overall- knowledge.
00:45:07 <opqdonut> thoughtpolice: i take the same kind of approach to haskell as to maths
00:45:23 <opqdonut> you can never now all of it, you can just know some specific areas well and have a good overall grasp
00:45:50 <opqdonut> tho haskell atm is a lot smaller conceptually than even category theory
00:48:53 <pejo> thoughtpolice, dons has had quite a few years of training, soak up all his wisdom. :-)
00:53:16 <jfredett> thoughtpolice, I've been at this haskell thing for about a month, i've gotten relatively good at it, and I can safely say, understanding haskell is like understanding women
00:53:22 <jfredett> its all one giant educated guess
00:53:50 <jfredett> but you really just can't live without making those kind of guesses
00:53:50 <jfredett> :)
00:54:11 <thoughtpolice> well i've known that about women for a while. (btw, about 3 month haskeller or so here.)
00:54:33 <jfredett> brilliant, another person I can harass when I have stupid problems
00:54:34 <jfredett> :)
00:54:38 <thoughtpolice> :>
00:54:45 <jfredett> with that, its time for sleepy brain to... sleep
00:54:47 <thoughtpolice> feel free. summer is going to get boring.
00:54:48 <jfredett> i guess
00:54:58 <jfredett> heh- I actually have to learn C/C++ first
00:55:04 <jfredett> I have a job- :/
00:55:20 <jfredett> silly jobs- get in the way of me wasting time.
00:55:30 <thoughtpolice> they tend to do that
00:55:32 <Korollary> you like hyphens
00:55:39 <jfredett> and all I get is a lousy check
00:55:48 <quicksilver> it depends on how often you used it
00:55:48 <jfredett> did I lower the karma on anything?
00:55:54 <quicksilver> if you used haskell all day, every day
00:56:00 <jfredett> I do like hyphens, sometimes i use too many
00:56:05 <quicksilver> you'd get a pretty solid grasp in  2-4 weeks
00:56:07 <jfredett> and i lower the karma of things
00:56:19 <quicksilver> if you only use it for half an hour every now and then
00:56:23 <jfredett> quicksilver, I have a pretty good grasp of it now
00:56:23 <quicksilver> then it will take longer :)
00:56:29 <jfredett> using it about 2-3 hours a day
00:56:36 * quicksilver nods
00:56:38 <vegai> hmm... should we expect a new hs-plugins release (one that works on ghc-6.6) soon?
00:56:38 <jfredett> its just the little things
00:56:43 <quicksilver> 2-3 hours a day is a pretty solid chunk
00:56:48 <jfredett> like my complete lack of understanding of Type theory
00:56:53 <jfredett> that gets in the way
00:56:56 <vegai> has there been thoughts of integrating hs-plugins into ghc?
00:57:10 <Korollary> vegai: I thought it was done
00:57:23 <quicksilver> most 'full-time programmers' don't put more than 4-5 hours a day into their work language, after all
00:57:28 <quicksilver> vegai: 'integrating' in what sense?
00:57:28 <jfredett> learning type theory ad hoc is tough. :/
00:57:38 <vegai> Korollary: which?
00:57:46 <quicksilver> vegai: hs-plugins is based on underlying GHC functionality as it is
00:57:51 <Korollary> jfredett: you don't really learn type theory while learning haskell
00:57:53 <vegai> quicksilver: so that it's included in ghc's libraries
00:58:02 <quicksilver> vegai: I doubt it
00:58:07 <quicksilver> vegai: that just holds up releases
00:58:08 <jfredett> quicksilver, on a good day, I spend 10 hours writing code for my job, 5 with the new stuff, and 5 with everyone elses stuff
00:58:22 <jfredett> my new job is going to be all C though, and no java. :(
00:58:22 <thoughtpolice> quicksilver: i've just taken the route of writing apps in it, since that both occupies my time and gives me pleasure (i've been pretty actively involved with using haskell since I started it.)
00:58:24 <quicksilver> the direction we're moving is for *less* to be bundled with ghc, not more
00:58:31 <thoughtpolice> so far I've only written a few things though
00:58:33 <jfredett> Korollary, yah- but it certainly doesn't hurt to know it
00:58:39 <vegai> quicksilver: you mean I could easily implement the same functionality myself?
00:59:06 <quicksilver> vegai: erm, it's not that easy :)
00:59:16 <quicksilver> vegai: but you could implement a very simplistic version quite quickly
00:59:18 <Korollary> vegai: I thought the recent HCAR mentioned that hsplugins was updated for 6.6. I could be wrong.
00:59:26 <quicksilver> vegai: it's just a question of poking around in the GHC API
00:59:43 <vegai> Korollary: might be, in darcs. I was pondering about a release
01:00:15 <thoughtpolice> the darcs repo should build on 6.6 nicely (it did for me)
01:00:27 <vegai> does yhc implement dynamically loaded modules in some way?
01:01:10 <vegai> I don't doubt that... but what I forgot to mention that I'm thinking of building a binary package of hs-plugins... and I feel awkward building those from VC versions
01:01:23 <jfredett> anyway, gnite peoples
01:01:24 <thoughtpolice> using it the way in the paper dons' described on 6.6 seemed to have a few issues, though. i believe dons is hoping it'll get superseded by GHC's own API though
01:10:44 <yakov> hi
01:16:44 <vegai> does the next Haskell standard have any sort of notion of dynamically loadable modules?
01:20:40 <quicksilver> vegai: not that I'm aware of, no
01:20:56 <quicksilver> vegai: the standard is pretty quiet about compilation techniques and linkers though
01:21:14 <quicksilver> vegai: I suspect these are viewed as implementation issues
01:21:42 <vegai> well, there could be some mention of the API, couldn't there?
01:22:04 <quicksilver> tehre could be a library spec, yes
01:42:26 <nattfodd> does anyone know if/how I can profile haskell code?
01:43:02 <vegai> you can
01:44:14 <nattfodd> s@if/@@ then :)
01:44:34 <roconnor> @type forAll
01:44:36 <lambdabot> Not in scope: `forAll'
01:44:40 <roconnor> @hoogle forAll
01:44:40 <lambdabot> Test.QuickCheck.forAll :: (Show a, Testable b) => Gen a -> (a -> b) -> Property
01:44:40 <lambdabot> Prelude.forall :: keyword
01:44:40 <lambdabot> Language.Haskell.TH.ForallC :: [Name] -> Cxt -> Con -> Con
01:44:58 <Lemmih> nattfodd: Compile with -prof and run with +RTS -p -RTS
01:45:19 <nattfodd> Lemmih: ok, back in a couple hours, then :)
01:45:22 <Lemmih> http://www.haskell.org/ghc/docs/latest/html/users_guide/profiling.html
01:45:24 <lambdabot> Title: Chapter 5. Profiling, http://tinyurl.com/kwh6c
01:46:24 <nattfodd> Lemmih: do you know if profiling will add a big overhead to the execution time/space?
01:46:32 <nattfodd> it's a 25k LoC project
01:47:11 <roconnor> heh, (Positive Int) for quickcheck is a neat idea
01:47:24 <Lemmih> nattfodd: It depends on where you place cost centers.
01:47:59 <nattfodd> hum
01:48:12 <nattfodd> it's not my project and I have no idea of how the code works
01:48:21 <nattfodd> I take it using -auto will be very costly, then?
01:49:49 <kolmodin> nattfodd: it depends on the code, but it will run a couple of times slower at least
01:50:08 <nattfodd> great, this stuff already takes hours on my machine...
01:50:20 <kolmodin> good good :)
01:50:30 <quicksilver> -auto-all is just top-level functions
01:50:44 <quicksilver> depending how your code is structured that may or may not be lots :)
01:51:02 <nattfodd> that's not my code :)
01:51:02 <quicksilver> -auto is only the exported ones
01:51:53 <quicksilver> can you not run it on 'smaller data' in some sense to finish a bit more quickly?
02:33:01 <dons> this is rather lovely, http://programming.reddit.com/info/1vzog/details
02:33:02 <lambdabot> Title: Scientific.Dimension: Type Arithmetic and Physical Units in Haskell (reddit.com)
02:34:12 <dons> hmm. but its not on the main page? what's going on.
02:34:55 <dons> ?tiny-url http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/
02:34:56 <lambdabot> http://tinyurl.com/2fzx3c
02:35:55 <roconnor> dons: About how long did xmonad take to develop?
02:36:14 <dons> to which point?
02:36:34 <dons> http://programming.reddit.com/info/1w0z1/comments
02:36:35 <lambdabot> Title: Scientific.Dimension: Type Arithmetic and Physical Units in Haskell (lovely!) (r ...
02:36:36 <roconnor> yeah, my question isn't very clear.  Any answer will do.
02:36:48 <dons> oh, let me give you a graph:
02:36:54 <dons> http://cgi.cse.unsw.edu.au/~dons/blog/2007/06/02#xmonad-0.2
02:36:54 <lambdabot> Title: Haskell hacking
02:37:17 <dons> the first release was 6 weeks in, the second 10 weeks in. i started using it full time on day 2.
02:37:35 <roconnor> that's pretty fast.
02:37:47 <roconnor> presuming you were working in your spare time ... mostly
02:37:49 <dons> yes, it has been remarkable
02:37:58 <dons> yep. though we've had 3 guys doing that.
02:38:04 <dons> and some 10 or so other contributors
02:38:18 <dons> note, around 4 patches a day
02:38:32 <roconnor> were 3 of you really working together? or one main guy and a little bit of support?
02:39:04 <dons> sjanssen and I've implemented about 85%, 40% or so each. jcreigh did about 10% , everyone else the last 5%
02:39:16 <dons> (i think i got those figures right. the actual numbers are in the darcs repo)
02:39:28 <roconnor> you have actually numbers, wow.
02:39:36 <dons> darcs changes ;)
02:40:21 <roconnor> dons: did you write any FFI code?
02:40:36 <dons> yeah. esp. early on.
02:40:41 <kolmodin> ah, yes... :)
02:40:55 <roconnor> I'm really impressed by xmonad, even though I've never used it.
02:41:01 <dons> we talk to libX and libXinerama, after all
02:41:02 <kolmodin> augustss did a lecture on type level calculations in a chalmers AFP course
02:41:10 <roconnor> I want to work on a project on a similar scale
02:41:20 <dons> kolmodin: oh, you know the author of that blog post?
02:41:35 <dons> who is http://liftm.wordpress.com/ ? :-)
02:41:36 <lambdabot> Title: Monad.liftM
02:41:46 <kolmodin> dons: no, I don't :/
02:41:50 <dons> roconnor: yeah, its a nice size.
02:41:53 <kolmodin> unless it's augustsson :)
02:42:08 <dons> roconnor: you want it motivating (i.e. something you use every day), but such that you can get a prototype in around 100-200 lines
02:42:23 <dons> using standard cabal + hackage has helped out users massively, btw.
02:42:32 <dons> people remark how easy it is to build
02:42:41 <roconnor> dons: I was browsing the code.  You never put StackSet into a MonadState do you?
02:42:43 <kolmodin> he/she should think of adding the blog to planet haskell
02:43:21 <kolmodin> is it time for a haskell weekly news letter perhaps? :)
02:43:28 <dons> roconnor: its the windowset threaded in X
02:43:38 <dons> kolmodin: yes.
02:43:47 <dons> i reeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeealy should get the next isue out
02:44:05 <kolmodin> I'm always thrilled to read each time
02:44:17 <kolmodin> +it
02:44:21 <roconnor> dons: ah I see now, it is part of the XState.
02:44:27 <dons> someone reflexively mods down my haskell posts on reddit now :/ the articles always start out +1, -1, +1 +1 ...
02:44:33 <kolmodin> hm.. it's more ofe a haskell monthly letter ... :)
02:44:47 <kfish> dons: can we help with hwn?
02:44:51 <dons> yeah, i'm going to change the prologue to say something about 'semi-regular ...'
02:45:04 <kolmodin> yeah
02:45:15 <dons> kfish: hmm. i can't see any way to make it easier to get out.
02:45:25 <dons> i've been kinda distracted with xmonad :}
02:45:40 <dons> but i have an issue mostly done.
02:47:04 <nattfodd> I just installed binary with --prefix=~/tmp and now agda will pass configure but fail at build with http://hpaste.org/175
02:47:23 <nattfodd> do I need to give it extra informations to let it know that it is located in ~/tmp/ ?
02:48:08 <dons> see, now it has +1 -2, same thing happened last time. so there's at least 2 haskell down modders on reddit now.  http://programming.reddit.com/info/1w0z1/details
02:48:09 <lambdabot> Title: Scientific.Dimension: Type Arithmetic and Physical Units in Haskell (lovely!) (r ...
02:48:21 <dons> used to be you coudl rely on #haskell for +4-5  ;)
02:48:58 <dons> now everyone is so apathetic "yeah, another type hacking article. *yawn*'
02:49:12 <kfish> dons, cool -- you've got a few more distractions coming up in the near future, so if you want any help with random stuff like hwn, i'm happy to chip in, and i'm sure others are too :-)
02:49:16 * dons remembers the bad old days when you'd go weeks without reading a haskell article
02:49:30 <dons> kfish: yes, i'm planning on off loading a few projects :)
02:49:34 <dons> yi has gone to jyp.
02:49:39 <dons> i'm looking around for a lambdabot maintainer
02:49:41 <dons> hwn, not sure yet.
02:49:45 <quicksilver> they don't necessarily have to be haskell down-modders
02:49:54 <quicksilver> maybe they just don't think it's a very interesting article
02:50:13 <kfish> dons: dwn (debian) moved to a team of editors a while back, seems to have worked ok for keeping it regular
02:50:14 <dons> true. quicksilver, it was more i've noticed a similar pattern on the last 5 or so, articles that then go on to receive few, if any, more down mods
02:50:21 * quicksilver nods
02:50:24 <dons> so we'll see if it now gets +20.
02:50:35 <dons> kfish: right. hmm. that's an interesting idea.
02:50:58 <dons> kfish: i need someone starting their phd , who's keen to get involved...
02:51:09 <kfish> lol
02:51:10 <dons> phd students make the best maintainers. so good at getting side tracked
02:51:23 <dons> and you've got them for 4 years.
02:52:06 <pejo> dons, heh. Will you arrange funding for them? ;)
02:52:34 <dons> nah, they have to have their own funding, then they're slav^h^h^h volunteers
02:53:10 <pejo> dons, meant for the phd, the maintanance is of course "voluntary"!
02:53:30 <dons> yes, they have to have their own phd funding :-)
02:53:35 <dons> hehe
02:54:15 <kolmodin> dons: good good, we all get distracted by xmonad :)
02:54:38 <dons> hah
02:54:51 <dons> its almost done though...
02:54:53 <kolmodin> I'm really looking forward to the next entry, I've been so busy that some stuff in it might actually be new to me :)
02:55:04 <dons> (actually, there's a cunning plan to ensure its never done: the user contrib library)
02:55:19 <dons> once we provide hooks for compositing, the users won't be able to help themselves
02:55:42 <dons> kolmodin: hmm .yes. there's been quite a few things released.
03:15:34 <nattfodd> so, I'm trying to compile agda with -prof -auto-all
03:15:45 <nattfodd> and it complains that it can't find binary modules
03:15:54 <nattfodd> which are there and in the search path
03:16:01 <nattfodd> it also says:
03:16:01 <nattfodd>       Perhaps you haven't installed the profiling libraries for package binary-0.3?
03:16:19 <Lemmih> Well, perhaps you haven't installed the profiling libraries for package binary-0.3?
03:16:26 <nattfodd> do I need to do something specific to have the "profiling libraries"? recompiling binary with -prof -auto-all didn't help
03:17:00 <Lemmih> nattfodd: Configure binary with --enable-library-profiling
03:17:10 <nattfodd> ah, thanks :)
03:55:10 <malcolmw> dons: for HWN, you could mention in "code watch" that cpphs has today reached version 1.5.  It's only minor fixes, so I'm not going to bother with a proper release announcement.
03:55:59 <kfish> @where cpphs
03:56:00 <lambdabot> http://www.cs.york.ac.uk/fp/cpphs/
03:56:16 <malcolmw> Igloo: around?  I've finally fixed all the bug reports you gave me about cpphs a month or so back.
04:02:38 <bringert> are there any Haskell ALSA bindings?
04:05:38 <kolmodin> there are bindings to alut/openal
04:06:41 <kolmodin> which can backend to also, if I understand correctly
04:07:37 <bringert> hmm, complex
04:08:38 <kfish> bringert, you just want to play audio, or record , sync with video etc. ?
04:09:37 <bringert> kfish: at first, capture to send to a speech recognition library.
04:09:50 <bringert> kfish: then play audio from a speech recognizer
04:10:17 <bringert> kfish: I want to use ALSA to be able to use multiple speech recognizers at the same time
04:11:01 <kfish> ALSA's API is kinda nasty, would something like pulseaudio be useful?
04:11:03 <bringert> hmm, maybe I can do that with OSS
04:11:37 <bringert> I would prefer to keep the requirements low, i.e. no extra sound servers etc
04:11:48 <kfish> right
04:11:49 <bringert> maybe I'll go with OSS to start with
04:12:11 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/176
04:12:19 <ajudem_me> can't I do this?
04:13:30 <ajudem_me> does anyone knows?
04:14:26 <Lemmih> ajudem_me: Nope.
04:14:49 <ajudem_me> I've have to use the "where" clause, then?
04:15:21 <Lemmih> ajudem_me: How about: stuff = (==).
04:15:28 <quicksilver> ajudem_me: that is a case where you need to use ==
04:15:36 <ajudem_me> ok =)
04:15:45 <ajudem_me> I thought it was like prolog =)
04:15:53 <quicksilver> part of haskell is like prolog
04:15:56 <quicksilver> but not that part :)
04:16:12 <quicksilver> pattern binding unifies types but it doesn't unify values
04:16:30 <ajudem_me> oki =)
04:16:44 <quicksilver> Lemmih: I spent much of yesterday telling ajudem_me not to use ==, because he should have been using patterns and bindings
04:16:53 <quicksilver> Lemmih: now he has found the example where he should be using == :)
04:17:19 <kolmodin> dons: btw, I saw your (very tall) twin the other day in Göteborg downtown
04:17:46 <ajudem_me> quicksilver: lol... yes, I was trying to do a pattern matching =P
04:17:57 <Lemmih> quicksilver: When can you use patterns and bindings for testing equality?
04:18:49 <quicksilver> Lemmih: he was writing things like f x | (x == (0,y)) = ....
04:19:00 <quicksilver> Lemmih: I.e. he was hoping '==' could *bind* y in that context
04:19:01 <Igloo> malcolmw: Cool, thanks  :-)
04:19:12 <quicksilver> Lemmih: so I told him to not use ==, and showed him how to nest patterns
04:19:26 <malcolmw> Igloo: there are lots of tests in the repo (named igloo*) to prove it
04:19:54 <malcolmw> Igloo: I look forward to you find some more corner cases where cpphs is still wrong :-)
04:20:30 <Igloo> malcolmw: Well, IIRC the last corner cases I found the Mac's cpp disagreed with gcc's cpp
04:21:07 <malcolmw> Igloo: it was the difference between --traditional and --ansi I think
04:24:08 <Syzygy-> Suppose I have a list of trees with numbered leaves. And I have made them in such a way that the numbers occur subsequently from left to right among the trees. I have a bunch of Ints, and I want to repackage these trees into lists, such that whenever i is in my list of Ints, then the tree containing i and the tree containing i+1 are in the same list.
04:24:24 <Syzygy-> Does anyone have any idea how to attack this? I've been bashing my head against a wall with it for a while now.
04:25:12 <Syzygy-> So, I want, for an example, that > groupTrees [Leaf 1, Leaf 2, Leaf 3] [1] ==> [Node [Leaf 1, Leaf 2], Leaf 3]
04:25:43 <quicksilver> your question didn't quite make sense
04:25:44 <Syzygy-> And > groupTrees [Leaf 1, Leaf 2, Leaf 3] [1,2] ==> [Node[Leaf 1, Leaf 2, Leaf 3]]
04:25:48 <Syzygy-> Hmmm.
04:26:06 <quicksilver> from your example, I interpret that you want to change [Tree Int] into [Tree [Int]] ?
04:26:11 <Syzygy-> Nope.
04:26:21 <Syzygy-> I want to change [Tree Int] into [[Tree Int]]
04:26:32 <Syzygy-> (only it isn't quite Tree Int - since only leafs carry labels)
04:26:34 <quicksilver> neither of your examples have that type
04:26:42 <Syzygy-> Sorry.
04:26:54 <quicksilver> erm
04:27:03 <quicksilver> Node is n-ary?
04:27:20 <quicksilver> then your examples are just [Tree Int] -> [Tree Int], in fact
04:27:23 <Syzygy-> No, what I want to do in the end is [Tree Int] -> [Tree Int], whereby the [Tree Int] -> [[Tree Int]] is an intermediate step at the back of my head.
04:27:29 * quicksilver nods
04:27:29 <Syzygy-> Node can have any arity, yup.
04:33:36 <Syzygy-> Ok.
04:34:16 <Syzygy-> quicksilver: How would you do this? A function [Int] -> [Int] -> [[Int]], that makes sure that if i is in the second list, and i,i+1 are both in the first list, then the list in the output containing i also contains i+1?
04:34:45 <Syzygy-> You are allowed to assume all lists are sorted.
04:51:49 <chessguy> > let infixes n as = map (take n) $ take (length as - n + 1)
04:51:49 <chessguy> (tails as) in infixes 2 "foobar"
04:51:49 <lambdabot>  Parse error
04:52:17 <chessguy>  > let infixes n as = map (take n) $ take (length as - n + 1) (tails as) in infixes 2 "foobar"
04:52:22 <chessguy> > let infixes n as = map (take n) $ take (length as - n + 1) (tails as) in infixes 2 "foobar"
04:52:26 <lambdabot>  ["fo","oo","ob","ba","ar"]
04:54:02 <chessguy> @pl infixes n as = (take n as) ++ infixes n (drop n as)
04:54:02 <lambdabot> infixes = fix (ap (ap . ((++) .) . take) . (`ap` drop) . ((.) .))
04:54:29 <chessguy> @do infixes n as = (take n as) ++ infixes n (drop n as)
04:54:29 <lambdabot> infixes n as = (take n as) ++ infixes n (drop n as) not available
04:54:59 <chessguy> @src take
04:54:59 <lambdabot> take n _      | n <= 0 =  []
04:55:00 <lambdabot> take _ []              =  []
04:55:00 <lambdabot> take n (x:xs)          =  x : take (n-1) xs
04:55:18 <chessguy> @src drop
04:55:18 <lambdabot> drop n xs     | n <= 0 =  xs
04:55:18 <lambdabot> drop _ []              =  []
04:55:18 <lambdabot> drop n (_:xs)          =  drop (n-1) xs
04:57:02 <chessguy> > let infixes = map (tail . inits) . tails in infixes "foobar"
04:57:03 <lambdabot>  [["f","fo","foo","foob","fooba","foobar"],["o","oo","oob","ooba","oobar"],["...
04:57:53 <chessguy> > let infixes = concatmap (tail . inits) . tails in length $ infixes "foobar"
04:57:54 <lambdabot>   Not in scope: `concatmap'
04:58:05 <chessguy> > let infixes = concatMap (tail . inits) . tails in length $ infixes "foobar"
04:58:06 <lambdabot>  21
04:59:27 <TSC> @pl \x -> [x]
04:59:27 <lambdabot> return
04:59:35 <syntaxfree> > let infixes = concatMap (tail . inits) . tails in infixes "Jam"
04:59:36 <lambdabot>  ["J","Ja","Jam","a","am","m"]
04:59:53 <syntaxfree> > let infixes = concatMap (tail . inits) . tails in infixes "Skinnerbox"
04:59:55 <lambdabot>  ["S","Sk","Ski","Skin","Skinn","Skinne","Skinner","Skinnerb","Skinnerbo","Sk...
05:00:08 <syntaxfree> > let infixes = concatMap (tail . inits) . tails in infixes "Skinner"
05:00:10 <lambdabot>  ["S","Sk","Ski","Skin","Skinn","Skinne","Skinner","k","ki","kin","kinn","kin...
05:07:37 <araujo> morning
05:09:20 <roconnor> morning
05:13:19 <timbod> roconnor: Hi. Just making a few patches and updates to my chart library. Haven't looked at it for a while. Did you find much of a use for it?
05:14:57 <roconnor> timbod: yeah, I was plotting simulations of different betting stratagies
05:15:46 <timbod> roconnor: betting on stocks? or something else? were the strategies successful/profitable?
05:16:01 <roconnor> timbod: I was reading about Kelly's criterion.
05:16:29 <roconnor> suppose we flip a biased coin, in your favour
05:16:37 <roconnor> and play a normal betting game
05:16:44 <roconnor> you start with $100
05:16:58 <roconnor> the question is, what fraction of your wealth should you bet each time.
05:17:20 <roconnor> What is interesting, is that if you bet too much, you will still lose in the long run
05:17:30 <roconnor> even though the odds are in your favour
05:17:37 <roconnor> and the fraction to bet is really small
05:17:50 <timbod> Ah - I see. That does sound interesting. Just looking at it on wikipedia
05:17:53 <roconnor> Say the coin has a 10% bias in your favour.
05:18:09 <roconnor> Then the optimal amount to bet is somewhere around 5% if I recall correctly
05:18:25 <roconnor> and if you bet more that around %10 you will lose in the long run.
05:18:41 <roconnor> So I was running some simulations, and (not surprisingly) it really is true.
05:19:18 <timbod> Was your interest purely theoretical?
05:19:30 <AshyIsMe> roconnor: you read ralph vince?
05:20:47 <roconnor> AshyIsMe: nope, I don't think so
05:21:04 <roconnor> timbod: I play a game called the Foresight Exchange
05:21:11 <timbod> roconnor: If you have a decent screenshot a copy would be great.
05:21:18 <roconnor> timbod: I had one
05:21:23 <roconnor> maybe I should just make it again
05:21:30 <roconnor> maybe I'll just paste the code
05:21:57 <AshyIsMe> roconnor: he's written 3 books on optimal position size strategies
05:22:21 <roconnor> AshyIsMe: I just read a paper that I found through wikipeida.  I forget the author.
05:22:34 <AshyIsMe> k
05:22:42 <roconnor> @paste
05:22:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:22:44 <AshyIsMe> you should check out his books if you get some spare time
05:23:54 <hpaste>  roconnor pasted "simulation of betting on a biased coin" at http://hpaste.org/178
05:24:05 <mauke> @pl \x -> x : toUpper x : []
05:24:06 <lambdabot> ap (:) (return . toUpper)
05:24:16 <mauke> @pl \x -> toUpper x : x : []
05:24:17 <lambdabot> liftM2 (:) toUpper return
05:24:31 <roconnor> timbod: in this case the coin is fair
05:24:42 <roconnor> but you get an extra 10% when you win
05:24:50 <roconnor> so the odds are still in your favour
05:25:10 <roconnor> but if you bet 10% of your funds, your funds tend to 0 as you repeatedly play
05:25:18 <roconnor> 5% is closer to the optimal.
05:25:23 <timbod> It
05:25:38 <roconnor> timbod: Let me know if it doesn't build.
05:26:29 <timbod> It's an intriguing idea - sort of counter intuitive in that you'd tend to thing that it would be easy to win in the long run if you know the bias.
05:26:41 <roconnor> it was always clear when you should buy a stock, when it is undervalued.
05:26:52 <roconnor> but it was never clear to me before how much should be bet.
05:27:03 <roconnor> now I can preform the calculation.
05:27:26 <timbod> assuming it builds - can I add it as a replacement for my rather trivial log axis example on the home page?
05:27:37 <roconnor> timbod: absolutely
05:27:40 <Botje> > let fix x = fix (fix x) in fix (1:)
05:27:42 <lambdabot>  <[Integer] -> [Integer]>
05:27:58 <roconnor> right, so I wanted a log axis because it is easier to see your wealth on a log scale.
05:28:09 <roconnor> because your funds grow (or lose) exponentially.
05:28:21 <roconnor> At first I was just plotting the log of the funds
05:28:30 <roconnor> but I thought it would be nicer to plot the actual funds on a log scale.
05:28:38 <timbod> of course - my day job has me sitting next to a quant who lives in a world of log normal distributions.
05:28:50 <roconnor> :)
05:31:36 <timbod> roconnor: runs fine, and looks nice - I haven't actually seen the auto-log axes on real data!
05:32:10 <roconnor> it changes everytime you run it ;)
05:33:03 <roconnor> timbod: I still want to rewrite the autolog axis code, to make it a bit better and hopefully more clear.
05:33:16 <timbod> recent gtk2hs has support for pdf, ps, and svg output, so you can get some quite nice looking output now.
05:33:18 <roconnor> But still, It is the best autolog axis routine I've come across.
05:33:27 <timbod> I'm just adding some helper functions now.
05:33:39 <roconnor> timbod: will it be possible to get svg output to a Haskell string?
05:33:43 <mux> yeah, cairo is really nice, and it's a breeze to code with it in haskell, thanks to the Render monad
05:33:49 <roconnor> rather than a file
05:34:44 <timbod> mux: you bet. Over many years I've writting a few charting libs, and cairo + haskell is the nicest drawing environment I've come accross.
05:35:12 <mux> we should create the gtk2hs fan club ;-)
05:38:43 <timbod> to be honest, I'm torn between gtk2hs and wxwindows. There's much to prefer about the former, but to the best of my knowledge it doesn't yet run natively on osx.
05:39:21 <mux> if it doesn't run on mac os x yet, I dare say that it should do so quite soon
05:39:39 <mux> gtk+ already runs fine on windows, and I've seen mac os x related stuff in the changelogs in the past
05:40:20 <timbod> When I say run, I mean run natively via aqua or whatever the windowing system is, rather than X11. It works via X11 on the mac, but looks ugly.
05:41:24 <mux> I can't comment on that, but I think they are working towards this goal
05:44:03 <timbod> roconnor: Don't know about svg to a string. Just been looking at the source, and can't tell quickly.
05:45:25 <roconnor> timbod: Ah, okay
05:45:39 <roconnor> I should write a native SVG backend for your library
05:46:25 <timbod> Why the strong preference for a string rather than a file? Are you thinking of a web service or something?
05:51:24 <roconnor> timbod: I was thining of doing a webservice
05:51:46 <roconnor> but it is only at the vague idea stage
05:53:29 <timbod> do you have an opinion on the available haskell frameworks yet? I'm vaguely interested, but haven't had a chance to study them yet.
05:54:21 <timbod> (for web services, that is)
05:54:24 <roconnor> timbod: I was just going to roll my own little thing.
05:54:33 <kaol> happs rules
05:54:41 <roconnor> Network.HTTP and such.
05:55:13 <timbod> kaol: is hpaste written with happs
05:55:49 <roconnor> @where happs
05:55:49 <lambdabot> http://happs.org
05:58:33 <roconnor> is happs a webserver?
05:59:20 <timbod> library for building web services, I think.
06:01:07 <roconnor> Does that mean it runs as an Apache plugin?
06:01:18 * roconnor is highly ignorant
06:02:07 <timbod> No, I think it's a stand alone exe (or it is once you write your application with it)
06:02:40 <roconnor> so how do I get from port 80 to the service?
06:02:54 <Itkovian> roconnor: I assume the service listens on a port you specify
06:03:01 <roconnor> maybe I should ask what a web service is ;)
06:03:12 <roconnor> does it have anything to do with HTTP?
06:03:14 <Itkovian> "First of all, default HAppS applications run their own webserver on port 8000"
06:03:18 <daniel_larsson> Yes, it's a web server
06:03:48 <roconnor> ah cool
06:03:51 <roconnor> maybe I should use it
06:03:52 <Itkovian> roconnor: HTTP is a protocol that can be used by webservices to communicate with each other or a human user
06:06:42 <unknown> I have a function returning a `Maybe [a]', how do i concatenate this with a list (or another `Maybe [a]') ?
06:07:34 <roconnor> @type fmap (++)
06:07:36 <lambdabot> forall a (f :: * -> *). (Functor f) => f [a] -> f ([a] -> [a])
06:07:44 <roconnor> @type liftM2 (++)
06:07:45 <lambdabot> forall a (m :: * -> *). (Monad m) => m [a] -> m [a] -> m [a]
06:07:50 <roconnor> that will do
06:08:20 <roconnor> or if you like do { x<-myMaybeList; return (x++myOtherRegularList) }
06:08:59 <roconnor> unknown: assuming you want a Maybe [a] as a result
06:12:55 <timbod> roconnor:  Your example is at http://dockerz.net/twd/HaskellCharts - thanks!
06:12:56 <lambdabot> Title: HaskellCharts - twd
06:13:41 <roconnor> kaol: happs looks totally awsome!
06:14:47 <roconnor> timbod: heh, that's a bad example.  ;) The blue line is not losing money.  But at least the green is doing better.
06:15:08 <roconnor> timbod: of course, it is perfectly fine for illustrating the chart application.
06:15:21 <timbod> I was looking for pretty pictures, rather than actually outcomes.
06:15:47 <roconnor> :)
06:19:16 <unknown> roconnor: thanks
06:26:19 <roconnor> haskell is pretty enjoyable to program in.
06:26:26 <roconnor> bits <- fmap randoms getStdGen
06:26:36 <roconnor> where bits::[Bool]
06:26:50 <roconnor> all the pesudo-random data I'll ever need.
06:27:44 <timbod> agreed - though I remember when I first tried to understand how to use random numbers in haskell - it was hard to see through the doco to get to that line.
06:28:09 <roconnor> timbod: yeah, MonadRandom ought to be added to the standard libs
06:28:23 <roconnor> although you do miss out on split when you use it.
06:32:10 <timbod> I'm off - goodnight.
06:40:08 <fasta> Is the run-time and space costs of something that's only used in an assertion with the option passed to GHC to disable assertions, zero?
06:40:36 <fasta> It basically decides whether I need an extra CPP macro or not.
06:41:33 <fasta> To test something I need for example another library. Since it's not used anywhere else, I don't want it to be included in the final object file or what compiled form.
06:45:31 <pitecus> is there some option in cabal to make ghc compile C sources with optimizations?
06:47:11 <ejt> I remember reading a haskell version of popen somewhere.  Does anyone know where ?
06:47:57 <fasta> ejt: J. Goerzen wrote one
06:48:13 <fasta> ejt: GPL
06:48:32 <daniel_larsson> http://www.fh-wedel.de/~si/HXmlToolbox/hdoc_filter/System-PipeOpen.html
06:48:32 <daniel_larsson> is one
06:48:32 <lambdabot> http://tinyurl.com/36yfn2
06:48:47 <ejt> thankyou :)
06:51:43 <Si> does anyone know how I can stop Alex from treating semi-colon (;) as a comment?
07:05:52 <MyCatVerbs> Si: punch his lights out every time he does it.
07:06:03 <MyCatVerbs> Si: Pavlovian conditioning is pretty reliable.
07:10:15 <kfish> ndm: hi
07:10:20 <ndm> hi kfish
07:10:29 <kfish> i'm playing with tagsoup atm
07:10:37 <ndm> cool, hows it going?
07:10:44 <kfish> getting some funny behaviour from the hackage example
07:11:02 <ndm> i honestly don't really know what it does at the moment - quite a few people have submitted patches which i've applied, and not had a chance to go back to it
07:11:06 <ndm> does it load?
07:11:15 <ndm> type checking errors or runtime issues?
07:11:29 <kfish> runtime
07:11:32 <ndm> plus does the readURL method work - behind certain firewalls that isn't very reliable
07:11:44 <kfish> yep, readURL works, it reads data
07:11:51 <kfish> and most of the other examples work
07:11:54 <ndm> perhaps hackage got changed
07:11:59 <ndm> are you on the latest darcs version?
07:12:04 <kfish> yes, latest darcs
07:12:10 <kfish> hackage is returning an empty list
07:12:21 <kfish> and it seems to be related to h tags
07:12:28 <SamB_XP_> maybe there aren't any packages ;-P
07:12:39 <ndm> ok, give me a sec, i'll just try it out...
07:12:42 <kfish> eg. if i change the isTagOpenName to div, or a, it doesn't return an empty list
07:12:56 <kfish> if i change the map parseSect line to eg:
07:13:03 <kfish> return $ take 1 $ map show $ partitions (isTagOpenName "div") tags
07:13:25 <kfish> then i get warnings in the output like: TagOpen \"h\" [],TagWarning \"Junk in opening tag: \\\"1\\n
07:13:37 <kfish> where it is trying to parse the tag <h1 ...
07:13:41 <ndm> hmm, warnings are something new - i know nothing about them
07:13:48 <ndm> perhaps the tag parser got broken...
07:14:01 <SamB_XP_> ndm: seems so!
07:14:16 <ndm> kfish: yep, a definate bug! i'll report  it to the person who sent me the tag
07:14:17 <SamB_XP_> it obviously ought not to think the "1" in "h1" is junk
07:14:54 <kfish> okies
07:16:49 <kfish> ndm: also, you might like to update the HTML haddock docs on the web site -- some functions (like partitions) are not listed there, yet haddock comments exist in the source
07:17:19 <ndm> kfish: i've had no time for tagsoup for a while, i want to get back and tidy it all up at some point...
07:17:34 <ndm> Henning Thielemann has been doing most of the maintenance
07:18:04 <ndm> although i'm not sure why i don't had up to date haddock information, since that should be generated nightly by a cron script...
07:19:27 <ndm> i guess when i come back to tagsoup i'll also need to start up a regression test...
07:19:55 <kfish> heh, no worries
07:20:33 <ndm> i am curious how much of a "market" their is for tagsoup though - it seems quite a few people have been making use of it
07:22:43 <kfish> i'm just checking out the various xml-like libraries atm
07:22:52 <kfish> does tagsoup have html-specific code in it?
07:23:06 <ndm> no
07:23:13 <ndm> well, yes, it knows about HTML entities
07:23:19 <ndm> but nothing to do with html tags
07:23:22 <kfish> ok, sure
07:23:31 <ndm> although i was going to write a validator on top of TagSoup to validate HTML
07:23:41 <ndm> and more generally, XML validation
07:23:47 <ndm> should only be about 15 lines
07:23:58 <ndm> what are you hoping to do?
07:24:20 <kfish> oh, RSS, Atom etc.
07:24:25 <ndm> parsing them?
07:24:29 <kfish> which often contains embedded html etc.
07:24:30 <ndm> or generating them?
07:24:40 <kfish> well, generally i'm looking at both parsing and generating
07:24:57 <ndm> i would have thought generating was quite easy - almost so easy you don't need a mechanism for it
07:25:17 <ndm> although tagsoup will let you generate the "tags" and then do the right content encoding
07:25:41 <ndm> if you do want xml generation, hsx is pretty good - thats what i use in Hoogle
07:25:48 <kfish> ah, neat
07:26:23 <ndm> for parsing, you either expect the input to be valid, or invalid - if its valid and strict then something other than tagsoup might be best, if its possibly invalid then tagsoup is the best choice
07:26:34 <ndm> i.e. if its invalid but you still want to "semi-parse" what you can
07:26:57 <ndm> although even on valid XML, tagsoup is sometimes neater
07:27:45 <kfish> @where hsx
07:27:45 <lambdabot> http://www.cs.chalmers.se/~d00nibro/haskell-src-exts/
07:28:22 <kfish> eh? did you mean hsx above?
07:28:26 <ndm> yes
07:29:14 <ndm> http://www.cs.york.ac.uk/fp/darcs/hoogle/src/Web/HTML.hsx
07:29:21 <ndm> thats an example of it being used in Hoogle
07:29:59 <kfish> ah, right, like in HSP
07:30:16 <ndm> i think its used in that, perhaps - but you can run trhsx separately, which is what i do
07:32:14 <kfish> ndm: cool, thanks
07:37:15 <kfish> ndm: ok, i've got a patch for the parser
07:39:01 <kfish> yay, and the hackage example works again
07:39:29 <ndm> kfish: send it over: ndmitchell  --AT-- gmail.com
07:39:42 <kfish> okies, will do
07:44:21 * SamB_XP_ wonders what a loopless plane graph is
07:47:41 <quicksilver> acyclic and embeddable in 2D, perhaps
07:48:04 <quicksilver> whether they actually care about embeddability or whether it's supposed to be an inituitive help I don't know
07:48:45 <quicksilver> yup, apparently so
07:48:50 <quicksilver> embeddable in 2D without crossings
08:03:46 <Si> Has anyone ever thought about using a Happy grammar/Alex lexicon to also generate printer for a data-type? Or indeed is there a way of doing this?
08:03:59 <quicksilver> I shouldn't think so, because in general there can be multiple sources which parse to the same result
08:04:08 <quicksilver> however, arrow parsers can give that guarantee
08:04:46 <Bobtree> it seems that Clean, formally Concurrent Clean, is no longer concurrent.  does anyone know why?
08:05:04 <quicksilver> @go there and back again arrows
08:05:05 <lambdabot> http://www.cs.ru.nl/A.vanWeelden/bi-arrows/
08:05:06 <lambdabot> Title: There and Back Again: Arrows for Invertible Programming
08:05:09 <quicksilver> Si: like that
08:05:14 <Si> that's true, but if there exists a way from getting from A->B, there must be a way from getting back to an equivalence class of A
08:05:41 <quicksilver> indeed
08:06:00 <quicksilver> but that requires you to construct inverses (perhaps defined in terms of equivalence classes) for all the operations you perform
08:06:16 <quicksilver> and inverting a user-defined function is of course intractable in general
08:06:25 <quicksilver> the arrows paper I cited shows you one way to tie things down, though
08:07:21 <Si> yes, so the way I'd do it is to force the user to only construct the data-types using the constructors and specifying the inverses for any other functions
08:08:00 <quicksilver> which is roughly what the invertible arrow stuff enforces
08:26:46 <kfish> ndm, sent -- also added support for namespaces and an rss example ;-)
08:27:06 <ndm> kfish: cheers :)
08:28:13 <ndm> kfish: can you darcs record them pleasE?
08:28:22 <ozone> kfish ftw!
08:28:28 <kfish> ndm, sure
08:29:06 <kfish> ndm, actually, i'll add that other patch i mentioned in the email then send it over
08:29:13 <kfish> btw does darcs send work in this repo?
08:29:44 <ndm> kfish: cool, do a "darcs send -o file.patch" then "tar file.patch" - it increases the chance of it not getting newline corrupted as it goes through
08:29:58 <ndm> kfish: not sure, perhaps, perhaps not - darcs wasn't designed for windows users
08:30:11 <ndm> back in 15 mins, so i'll send it over to you then
08:30:16 <ndm> * apply it then
08:30:23 <kfish> okies
08:42:10 <alexj> anyone know how to use the "everything" function from Data.Generic?
08:42:26 <alexj> I want to flatten data types into a list of Dynamics
08:51:20 <quicksilver> alexj: define 'flatten' ?
08:51:33 <quicksilver> alexj: how do you decide what to flatten, and what to package up into a dynamic?
08:51:58 <alexj> I want Strings not stay intact as Strings but everything else to flatten
08:52:20 <quicksilver> that soundsl ike it will produce a list of Strings
08:52:24 <quicksilver> not a list of Dynamics
08:52:53 <alexj> Foo "bar" 3 should produce a list of 2 dynamics
08:53:14 <alexj> length (flatten (Foo "bar" 3)) == 2
08:53:26 <alexj> actually 3
08:53:28 <alexj> but you get the idea
08:53:33 <quicksilver> 3?
08:53:38 <quicksilver> I don't get the idea I don't think...
08:53:43 <ndm> alexj: yes, everything (++) ([] `mkQ` f) x
08:53:54 <ndm> where f :: String -> [String]; f = (:[])
08:54:10 <ndm> that will extract all the strings
08:54:38 <ndm> if you want to dynamic everything else, the "[]" in `mkQ` is the place to put it
08:55:00 <ndm> alexj: what is your ultimate goal?
08:55:00 <alexj> ?
08:55:04 <alexj> not sure I understand
08:55:17 <ndm> which part?
08:55:23 <sjanssen> I don't think you want 'everywhere'
08:55:28 <ndm> everything...
08:55:32 <ndm> i always mix those two up
08:55:50 <alexj> x@(Foo "abdef" 12 ) should become [toDyn x,toDyn "abdef",toDyn 12]
08:56:08 <alexj> I know I want everything
08:56:10 <alexj> :-)
08:56:18 <ndm> everything (++) toDyn
08:56:21 <ndm> that should do it
08:56:34 <ndm> oh, everything (++) (\x -> [toDyn x])
08:56:34 <alexj> no I want "abdef" to stay intact
08:56:35 <sjanssen> @type Data.Generics.everything (++) Data.Dynamic.toDyn
08:56:39 <lambdabot>     Couldn't match expected type `[a]' against inferred type `Dynamic'
08:56:40 <lambdabot>     In the second argument of `Data.Generics.Schemes.everything', namely
08:56:46 <ndm> ah, i see the issue
08:56:53 <ndm> you'll need gmapQ
08:56:55 <quicksilver> ndm: in your earlier example would it not be f `mkQ` [], by the way?
08:57:02 <sjanssen>  @type Data.Generics.everything (++) (return . Data.Dynamic.toDyn)
08:57:11 <sjanssen> @type Data.Generics.everything (++) (return . Data.Dynamic.toDyn)
08:57:12 <ndm> and do each descending level on its own
08:57:13 <lambdabot> forall a. (Data.Generics.Basics.Data a) => a -> [Dynamic]
08:57:23 <quicksilver> oh, now, I'm reading the type backwards
08:57:27 <quicksilver> sorry
08:57:34 <ndm> quicksilver: not sure, i use Uniplate, i just know why Uniplate is better than SYB :)
08:57:37 <alexj> I want to intercept the [Char] type.
08:57:48 <ndm> yes, do a gmapQ at each level, and a typeOf test
08:57:52 <ndm> @type gmapQ
08:57:53 <alexj> ?
08:57:54 <lambdabot> Not in scope: `gmapQ'
08:57:57 <ndm> @type gmapT
08:57:59 <lambdabot> Not in scope: `gmapT'
08:58:05 <ndm> @type Data.Generics.gmapQ
08:58:07 <lambdabot> forall u a. (Data.Generics.Basics.Data a) => (forall a1. (Data.Generics.Basics.Data a1) => a1 -> u) -> a -> [u]
08:58:15 <quicksilver> I think you'd be wise to separate in your head the two separate requirements
08:58:24 <quicksilver> (a) get all subexpressions in the tree
08:58:28 <quicksilver> (b) special-case the strings
08:58:33 <ndm> thats not enough
08:58:43 <ndm> because "neil" contains "eil", and you can't tell after the fact
08:59:04 <quicksilver> you could do the strings in a second pass
08:59:09 <ndm> you need gmapQ, to go down on level, a type specific behaviour on each element where String calls toDyn, and anything else returns a dynamic and calls gmapQ onwards
08:59:11 <sjanssen> ndm: what does this program look like in Uniplate?
08:59:12 <quicksilver> oh, no you couldn't
08:59:16 * quicksilver ponders
08:59:25 <quicksilver> you could do pass 1 to a tree (not a list!)
08:59:33 <quicksilver> then you could do pass 2, to pull out the strings
08:59:36 <quicksilver> and then flatten as pass 3
08:59:37 <ndm> sjanssen: flatten x = [y | y <- universeEx x] :: [String]
08:59:44 <ndm> that extracts all the strings
09:00:10 <ndm> sjanssen: actually flatten = universeEx, and an appropriate type signature
09:00:18 <quicksilver> ndm: I had not heard of uniplate until 2 and a half minutes ago
09:00:20 <ndm> i'm so used to using universeEx with list comps
09:00:23 <ndm> @where uniplate
09:00:23 <lambdabot> I know nothing about uniplate.
09:00:23 <quicksilver> ndm: can you give any pointers?
09:00:27 <alexj> ndm: I think I should be able to pass everything a (\x->[toDyn x]::String->[Dynamic]) but that doesn't appear to work.
09:00:29 <ndm> quicksilver: expect a release this week
09:00:37 <quicksilver> ndm: once again, you amaze me :)
09:00:44 <ndm> @where play
09:00:44 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/play/
09:00:49 <quicksilver> is it using generics under the hood?
09:00:49 <sjanssen> alexj: parens
09:00:51 <ndm> quicksilver: it was play, now its renamed
09:01:07 <sjanssen> ((\x -> [toDyn x]) :: String -> [Dynamic])
09:01:19 <ndm> quicksilver: there is a paper being submitted to haskell workshop - it can use generics, or not - its haskell 98 and shorter boilerplate than anything else
09:01:21 <alexj> sjanssen: it was pseudocode.
09:01:33 <ndm> alexj: give me a second, and i'll give you the answer :)
09:01:45 <alexj> ndm: ok.  standing by.
09:01:58 * ndm hates that none of this works in hugs
09:02:20 * alexj just uses ghci
09:02:43 <quicksilver> ndm: do printable docs exist in a better form than 'http://www.cs.york.ac.uk/fp/darcs/play/play.htm' ? Or is that the canonical version to print and read on the bus?
09:03:17 <ndm> quicksilver: give me 10 mins, and i'll send you the draft paper - which is the best form of docs so far - but still in draft
09:03:30 <quicksilver> ndm: good man. No hurry. My bus doesn't leave for a while.
09:03:33 <quicksilver> :)
09:05:50 <ndm> @hpaste
09:05:50 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:06:01 <hpaste>  ndm pasted "flatten implementation with SYB" at http://hpaste.org/180
09:06:03 <alexj> ndm: play looks nice.  I've been doing a lot of SYB stuff lately and feeling a little bruised.  XML and database stuff.
09:06:14 <ndm> alexj: ^^ there is the SYB version
09:06:33 <alexj> syb version of ?
09:06:35 <alexj> play?
09:06:35 <ndm> @where+ uniplate http://www-users.cs.york.ac.uk/~ndm/uniplate/
09:06:36 <lambdabot> Done.
09:06:43 <ndm> play should redirect to uniplate...
09:06:57 <ndm> alexj: the hpaste is an implementation of flatten
09:07:24 <ndm> alexj: there is a uniplate implementation on top of SYB, so you can revert to SYB if you need it, and do automatic derivation of Uniplate
09:07:41 <sjanssen> @where play
09:07:41 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/play/
09:07:47 <alexj> ndm: thanks it works!
09:07:49 <fasta> ndm: have you used Play on something real?
09:08:02 <ndm> fasta: Yhc, Catch - i have over 100 Play traversals in Catch
09:08:04 <quicksilver> ndm: I don't understand how it could be H98, what am I missing? Surely some compiler support is needed to 'bootstrap' generic traversals?
09:08:14 <ndm> Supero has about 25 in it
09:08:25 <ndm> Reduceron (released last week) has at least 25 uses of it
09:08:27 <ndm> quicksilver: type classes
09:08:30 <alexj> ndm: can I get a copy of the play paper as well?
09:08:38 <ndm> alexj: sure, i'll just upload it...
09:08:47 <fasta> ndm: and you don't need to write instances by hand?
09:08:53 <sjanssen> @where+ Play Play is now known as Uniplate
09:08:53 <lambdabot> Done.
09:09:27 <fasta> ndm: I did a very quick skim.
09:09:28 <ndm> fasta: you can use deriving Data in GHC, you can derive them automatically with Data.Derive, or you can write them by hand - your choice
09:09:28 <quicksilver> ah, that's the part I was missing :)
09:09:31 <ndm> fasta: the paper discusses this in some detail, the various ways to write the instances and what they should look like
09:09:44 <quicksilver> so it's "compatible" with 'deriving Data', but alternatively you can write by-hand instances
09:09:47 <ndm> yes
09:09:59 <ndm> plus its about 8 times faster than SYB
09:10:11 <ndm> or about 30% faster than SYB, if you use deriving Data
09:10:21 <ndm> i.e on top of SYB, Uniplate is still faster :)
09:10:36 <fasta> ndm: I like that the user doesn't need to do "mkT" etc.
09:10:57 <ndm> fasta: me too, plus its more type correct - with mkT you can type garbage and it just won't do anything
09:12:08 <quicksilver> ndm: cute example of using [0..] in a 'State' instead of the more typical explicityly incremented Int state
09:12:14 <fasta> ndm: is it easy to write a function that gives the innermost of a term?
09:12:27 <ndm> fasta: define the problem more?
09:12:29 <ndm> http://www-users.cs.york.ac.uk/~ndm/temp/uniplate-draft.pdf
09:12:56 <quicksilver> thanks
09:12:57 <ndm> alexj, fasta, quicksilver ^^ the paper - be ware its in draft form - i have a pile of corrections scribled on the paper copy on my desk
09:13:06 <ndm> but the interface is pretty solid
09:13:13 <ndm> and the darcs repo matches it
09:13:18 <alexj> ok
09:14:14 <fasta> ndm: I am sorry, I meant a function that applies another function at every term starting from the lowest level in the term.
09:14:31 <ndm> fasta: transform, assuming you mean every term of the same type
09:20:54 <ndm> fasta: its the standard transformation, since its nearly always what you want to do
09:20:54 <fasta> ndm: yes, every term is e.g. of the type ASTNode
09:20:54 <ndm> yes, then transform
09:20:54 <ndm> transform is similar to everywhere in SYB, but type restricted and more type safe
09:20:54 <ndm> universe is similar to everything
09:20:54 <fasta> ndm: same for outermost?
09:20:54 <sjanssen> ndm: I like the 'Scrap Your Scary Types' subtitle :)
09:20:54 <ndm> fasta: you can write it if you want, but you probably don't want it - what do you want to do top-down traversal for?
09:20:54 <quicksilver> transform traverses a term which might have multiple mutally recursive types, but only 'fires' on leaves of the correct type, then?
09:20:54 <ndm> quicksilver: yes
09:20:54 <fasta> ndm: If you want to know that check the Stratego source.
09:20:54 <ndm> fasta: i had 10 top-down traversals in Catch, i think 8 of them were wrong in corner cases - its trivial to write, but rarely a good choice
09:20:54 <ndm> sjanssen: thanks, i like that bit too - the original title was "Play with your boilerplate" - i prefered that to the uniform boilerplate thing...
09:20:54 <fasta> ndm: A comparison with Stratego would be nice, I guess.
09:20:54 <fasta> ndm: that already has about zero boiler plate, but no type correctness.
09:20:54 <ndm> fasta: thats in the paper, but only very lightly in related work - i don't know enough about Stratego to do that sadly
09:20:54 <ndm> fasta: do you have a good document that accurate describes the kind of thing you'd write in Stratego using Haskell?
09:20:54 <ndm> most of hte documentation i found was about type theory, random other stuff, or overview stuff - not a tutorial of "write this in this syntax to do this"
09:20:54 <fasta> ndm: You mean a comparison between Stratego and Haskell?
09:20:54 <ndm> i had the same problem with strafunski until someone told me about "A Strafunski application letter" which turns out to be _the_ paper on how to actually use it
09:20:54 <ndm> fasta: is Stratego embedded in Haskell?
09:20:54 <fasta> ndm: no
09:20:54 <fasta> ndm: Stratego in written in Stratego
09:20:59 <ndm> kfish: pushed and applied
09:21:04 <quicksilver> ndm: if nothing else, you win big on sensible names
09:21:09 <ndm> @karma+ kfish -- contributions to tagsoup
09:21:09 <lambdabot> kfish's karma raised to 7.
09:21:20 <quicksilver> ndm: mKgmapTQK just doesn't do it for me
09:21:33 <ndm> quicksilver: good good :)
09:21:58 <ndm> my goal was to be usable by beginners more, since SYB and stuff can get quite complex very easily - as the example just posted showed
09:21:58 <fasta> If you have used Stratego, mkT is unacceptable :)
09:22:21 <kfish> ndm, cheers :-)
09:22:24 <ndm> fasta: would you have any recommended tutorial on Stratego? anything on how to interface it to Haskell?
09:22:30 <ndm> that was where i fell down
09:22:58 <ndm> plus i'm curious if there is anything where Stratego is shorter than Uniplate - i think its got to the stage where everythign is pretty minimal
09:24:06 <fasta> ndm: the manual is pretty good
09:24:19 <fasta> ndm: (of Stratego)
09:24:29 <fasta> ndm: you can also browse the source on the web
09:24:46 <fasta> ndm: interfacing to Haskell can be done via ATerm libraries
09:24:53 <quicksilver> the 'boring-old-man' part of me always worries about people using generic techniques when simpler techniques would apply
09:25:02 <fasta> ndm: you don't need that for comparisons, though.
09:27:13 <ndm> quicksilver: my generic techniques are sufficiently simple that they are "simple generic techniques"
09:27:13 <ndm> i never use SYB since I use Hugs all the time, i only looked into SYB for the Uniplate comparison
09:27:13 <ndm> and because Uniplate instances work in terms of gfoldl, which is one of the most evil functions ever
09:27:13 <fasta> @where uniplate
09:27:13 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/uniplate/
09:27:13 <pitecus> I get errors from ghci when tryin to use a lib which uses FFI
09:27:13 <pitecus> Like so:
09:27:13 <pitecus> Loading package maxent-0.0 ... can't load .so/.DLL for: gfortran (libgfortran.so: cannot open shared object file: No such file or directory)
09:27:13 <ndm> fasta: thanks, looking through the manual for Stratego now
09:27:31 <pitecus> I have /usr/lib/libgfortran.so.1
09:27:41 <dolio> quicksilver: Are you still looking for explanations of delimited continuations?
09:27:58 <quicksilver> dolio: I'm certainly still interested if you have a nice one for me
09:28:26 <dolio> quicksilver: Well, I read a couple pages of Oleg's new paper, and it seems like it might be nice.
09:28:39 <pitecus> this stuff works for ghc, its ghci which cant seem to find the libs...
09:29:09 <dolio> quicksilver: It's essentially, "delimited continuations for systems hackers" so it seems simpler than most of the other papers I've read.
09:29:20 <quicksilver> dolio: cool.
09:29:23 <quicksilver> dolio: link? :)
09:29:29 <dolio> Plus, it looks like it has lots of examples for intuition. :)
09:29:53 <dolio> http://lambda-the-ultimate.org/node/2276
09:29:54 <lambdabot> Title: CONTEXT07. Delimited contexts in OS | Lambda the Ultimate
09:30:13 <quicksilver> thanks
09:39:43 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/181
09:40:30 <ajudem_me> do you know how to help me?
09:41:11 <ajudem_me> I've no idea what's wrong
09:41:54 <quicksilver> you don't want those "if"s
09:41:58 <quicksilver> you don't need an if on a guard
09:42:09 <ajudem_me> ohhh
09:42:09 <ajudem_me> ok =)
09:42:14 <quicksilver> for future reference paste the error message too
09:42:36 <ajudem_me> oki =)
09:42:44 <ajudem_me> tnks ;)
09:42:49 <ajudem_me> (again ;P)
09:56:18 <hpaste>  mdmkolbe|work pasted "Obscure (but critical) question about the GHC source" at http://hpaste.org/182
10:01:22 <Bobtree> is anyone here using fp for simulations, scientific computing, visualization, computer graphics, games, that sort of thing?
10:01:34 <Syzygy-> I do.
10:01:38 <Syzygy-> Well, kinda.
10:01:51 <Syzygy-> I do combinatorial and algebraic computations in Haskell.
10:02:18 <Bobtree> but is that your problem domain, or just a tool for something else?
10:04:10 <Syzygy-> Well, I do research in homological algebra... :)
10:04:37 <Bobtree> so, math then.  not so much simulation, games, graphics type of stuff?
10:04:53 <Syzygy-> Nope.
10:04:56 <astrolabe> I use it for some bayesian stuff at work
10:05:50 <pitecus> Does anyone know how to compile a package which links extra libraries so that its usable from GHCi?
10:06:49 <Bobtree> I have some serious high performance algorithm needs (physics simulation, level of detail rendering, audio synthesis), and I really like the expressive power of fp (maybe even performance with Clean), but I don't know how useable it is in practice, with for example system-level bits in D and the front end application in Lua
10:07:37 <ddarius> @google LuaML
10:07:39 <lambdabot> http://www.cminusminus.org/code.html
10:07:40 <lambdabot> Title: C-- Downloads
10:07:40 <ddarius> @where ffi
10:07:40 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
10:08:11 <Bobtree> C FFI linking for example, Haskell is supposed to be decent at, but Clean is mysteriously obscure.  likewise OCaml is nifty mixed-paradigm high performance stuff, but I'm not sure it's what I'm looking for
10:08:15 <astrolabe> My impression is that to write high-performance haskell, you need to know quite a lot, and the code doesn't look so nice anyway.
10:08:50 <SamB_XP_> astrolabe: well, hopefully the main of the code will look nice
10:09:16 <Bobtree> I googled LuaML but don't have any idea what I'm supposed to look for there
10:09:34 <astrolabe> SamB_XP_: It might well.  My impressions aren't very educated ones.
10:09:40 <Bobtree> astro: that's why I'm considering Clean, which has apparently astonishingly good performance
10:09:51 <pitecus> The couple times I tried to do some number crunching in haskell is was way slower than even Java
10:09:58 <SamB_XP_> well, to write high-performance libraries you may need to know a lot...
10:10:12 <Bobtree> really, I'm trying to ditch C++ and upgrade to something higher level in the process
10:10:29 <ddarius> http://www.eecs.harvard.edu/~nr/pubs/embed-abstract.html
10:10:31 <lambdabot> Title: Embedding an Interpreted Language Using Higher-Order Functions and Types (Abstra ...
10:10:49 <ddarius> Clean is about comparable to Haskell.
10:10:53 <Bobtree> but for simulation, I really can't see sacrificing performance.  you can always simulate MORE stuff, or higher detail, or with more accuracy, and so on
10:11:07 <SamB_XP_> Bobtree: what kind of simulations are you doing?
10:11:16 <Bobtree> I know Clean is a comparable language
10:11:25 <DRMacIver> Bobtree: You could probably do a lot worse than a step sidewards to D.
10:11:27 <ddarius> Bobtree: I meant performance wise
10:11:39 <SamB_XP_> what algorithms and datastructures does it use?
10:11:54 <Bobtree> um, it's hard to describe, because I think nobody has simulated this particular thing before.  the algorithm is similar to molecular dynamics stuff
10:12:38 * SamB_XP_ doesn't know how that works
10:12:44 <Bobtree> I need to code a big fancy hierarchical adaptive data structure that embeds bounding volumes, a signed distance field, material properties, and so on
10:12:58 <SamB_XP_> adaptive?
10:13:16 <Bobtree> but the update is lazy and asynchronous, based on propogation of impulses.  it's not a "one big matrix solver" kind of problem
10:13:36 <Bobtree> adaptive, as in, not uniform resolution, and not updated in a globally synchronous manner
10:14:07 <SamB_XP_> and what do you mean "lazy"?
10:14:10 <ddarius> Bobtree: What are the inputs?
10:14:33 <Bobtree> there's a priority queue, and only the soonest event happens first, all event scheduling is local
10:15:32 <Bobtree> the input is a physical model, as an adaptive signed distance field.  the hierarchy looks like layers of cubeoctahedra (think a 3d honeycomb)
10:16:47 <ddarius> Bobtree: Your best bet both performance and simplicity-wise may be to generate specialized simulations
10:16:54 <Bobtree> does this make any sense?  the outright numeric performance isn't that important.  it isn't about crunching big arrays of floats.  it's the locality of memory access that will dominate performance.
10:17:25 <ddarius> A la http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
10:17:25 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
10:17:29 <Bobtree> you mean to preprocess and compile specific examples as their own programs?
10:17:52 <ddarius> Yes if there are significant aspects that stay constant.
10:17:53 <Bobtree> thanks for the link
10:18:13 <ddarius> Or vary slowly and incrementally
10:18:33 <Bobtree> that's not really appropriate for what I'm doing.  this is for a game engine.  it's a non-rigid body dynamics simulator.
10:18:41 <SamB_XP_> Bobtree: so, what are some things that currently hurt your locality of reference?
10:18:58 <Bobtree> it's a level-of-detail algorithm, so the adaptivity makes up for a lot
10:19:37 <Bobtree> well, the access-order is almost random in memory.  small neighborhoods are evaluated together, to schedule updates, but in the large, there isn't a single traversal order or anything to exploit
10:20:31 <SamB_XP_> oh, and what do your updates look like?
10:21:08 <SamB_XP_> do you change just about everything in a given node in an update?
10:21:45 <Bobtree> so, an event is something that couldn't be delayed any further, for accuracy reasons, and has to be done now.  some physics happen, and new impulses are assigned to a few elements, which then reschedule every other pending event in their neighborhoods (the prority queue decides what happens first)
10:22:27 <Bobtree> mostly it's just momentum that changes (usually velocity), position is implicit between physical events
10:23:19 <Bobtree> but the data structure will shift around a lot due to collision checking, and sometimes things like mass or material properties can change (e.g., fracture or plastic deformation)
10:23:25 <Excedrin> so, is your question whether Haskell will offer good enough performance?
10:23:38 <SamB_XP_> Bobtree: so, do you use a lot of in-place updates then?
10:23:47 <Bobtree> it's not so much that the data in the nodes is big, but there are lots of nodes, and their relationships can change a lot.
10:24:01 <Bobtree> well, in C++ I would, but that's the rub here
10:24:13 <SamB_XP_> yeah, that is what I meant.
10:24:26 <Bobtree> Excedrin: I don't know, I think Clean might be ok performance-wise, but it's the language -> algorithm suitability I'm curious about
10:25:14 <SamB_XP_> well, what are your gripes with C++ for this purpose?
10:25:16 <Excedrin> I think that Haskell is excellent for that sort of thing, but there's a big learning curve before that becomes apparent
10:25:38 <SamB_XP_> Excedrin: I think it might be slow :-(
10:26:03 <Bobtree> mostly, the data in the nodes changes only in small bits at a time, but the data structures are being reorganized quite frequently (collision tracking at volume bounaries), and the global priority scheduler has to be efficient (the # of elements is proprotional to all possible pending events in the system)
10:26:34 <Bobtree> my gripes are that C++ sucks, and life is just too short to deal with all that complex crap, ridiculous build system, and so on forever.  I'll be using D at the very least I think.
10:27:09 <SamB_XP_> which complex crap are you referring too? (C++ has lots of complex crap, you know.)
10:27:29 <Bobtree> my fear is that you both may be right: fp could be perfect for describing my algorithm, but too slow in practice.
10:27:48 <SamB_XP_> note: I'm not saying you should continue using C++...
10:27:53 <Excedrin> I don't think it will be too slow
10:27:55 <Bobtree> I don't know where to start.  most game developers (any real dev I suspect), tend to use small safe subsets of C++ that get what they want done.
10:27:59 <DRMacIver> Solution: Haskell combinators for generating fortran code for doing the slow bits. :)
10:28:13 <SamB_XP_> DRMacIver: fortran is good at trees now?
10:28:25 <DRMacIver> Well, maybe not.
10:28:30 <Bobtree> fortran is all about numerics on arrays isn't it?  I don't think it's appropriate.  I don't have big matrices to solve.
10:28:40 <DRMacIver> Ah, fair enough.
10:28:42 <DRMacIver> C or C++ then. :)
10:28:47 <Bobtree> D
10:28:49 <SamB_XP_> Bobtree: who knows? I know it is good for that, but I have no idea if it is good for anything else
10:28:54 <DRMacIver> D would work too.
10:29:11 <DRMacIver> The key point is 'generating', so you can worry more about which gives you the best performance than which is the least painful to write.
10:29:20 <Excedrin> Bobtree: can you make some sort of minimal example / benchmark in C++ or whatever, then share it so that people can implement it in Haskell and compare performance?
10:29:32 <Bobtree> I'm very tempted to try with Clean at at this point.  I have some small fp background (Scheme and SICP in school, reading CTMCP more recently)
10:29:56 <Bobtree> Excedrin: the idea is to avoid the pain of doing it in C++ to begin with.
10:30:04 <Bobtree> I may find some example though...
10:30:12 <Excedrin> is there any existing implementation?
10:30:42 <Bobtree> DRM: I considered that, you're right that it may be possible to generate fast code after the fact.
10:30:48 <dmead> Bobtree, i think clean is pretty much the same as haskell
10:30:57 <dmead> from what i've seen
10:30:58 <Bobtree> Excedrin: no, this is brand new as far as I know
10:31:11 <Excedrin> Clean is less active than Haskell
10:31:25 <Bobtree> dmead: some anecodal evidence suggests I may be happier with Clean, especially with the performance
10:31:43 <Bobtree> I'm aware that Haskell is the most mainstream pure-fp-lazy-etc language
10:31:56 <sjanssen> I think Clean lacks Haskell's community
10:32:29 <daniel_larsson> anectodal evidence suggests people looking for clean answers join the #haskell channel
10:32:33 <Excedrin> Clean performance is slightly better than Haskell's in some areas, and vice-versa
10:32:49 <Bobtree> afraid so
10:33:01 <Bobtree> looking for my example here, not sure where I  wrote it down ...
10:33:14 <Excedrin> fortunately, if you find some area of Haskell performance that's lacking, it's typically vastly improved in a year ;)
10:33:18 <sjanssen> @remember daniel_larsson anectodal evidence suggests people looking for clean answers join the #haskell channel
10:33:18 <lambdabot> Done.
10:33:55 <SamB_XP_> hmm, C# might be cool if it had functions.
10:34:05 <DRMacIver> SamB_XP_: It does in 3.0 doesn't it?
10:34:20 <dmhouse> SamB_XP_: C# lacks functions?!
10:34:28 <DRMacIver> Even in 2.0 it has anonymous delegates.
10:34:31 <Excedrin> if you're going to start talking about all kinds of other languages that might be good for this, Ocaml and SML are the obvious choices
10:34:40 <SamB_XP_> DRMacIver: oh.
10:34:56 <Modius> Downside in 2.0 is without type Inference C# 2.0's incredibly verbose.  (I program functional in 2.0; but it's ugly)
10:35:23 <DRMacIver> Yeah. From what I've seen the anonymous delegates aren't really much better than Java's (does C# have the same?) anonymous inner classes.
10:35:29 <Modius> IEnumerable<OutputType> result = Map<OutputType, InputType>(delegate () { }, someListHEre);
10:35:42 <SamB_XP_> DRMacIver: C# 3 has lambdas
10:35:43 <Modius> C#'s anon delegates are significantly superior to anon classes
10:35:53 <DRMacIver> From a "amount of typing" point of view. :)
10:36:06 <SamB_XP_> I assume that anonymous delegates lack gratuitously incompatible method names
10:36:13 <DRMacIver> (Yes, they're clearly better from a sanity and useage perspective)
10:36:54 <Modius> It's not the delegates in C# 2.0 that are ugly, it's that you have to type qualify all the recipients
10:37:08 <DRMacIver> Fair enough.
10:37:13 <Modius> If you want to make "general purpose" functions like Map they have to have generics in their definition.
10:37:36 <Bobtree> I can't find what I'm looking for, my notes are too long and messy :(  the math is similar to an iterative relaxation solver, but rather that iterating globally to solve one "timestep", it considers only local interactions, "relaxing" them (or delaying them) one by one in the order they would actually happen
10:38:31 <Modius> That said, functional programming support even in C#2.0 is currently safe and powerful - it is in a different league to Java.  It's verbose; but verbose "in the expression", rather than being verbose due to having to structure differently.
10:39:08 <DRMacIver> ok. My exposure to it is very limited, so I'll take your word for it. :)
10:39:10 <Bobtree> a global total ordering is overkill actually, it is only necessary that the propogation of effects generates a consistent spacetime (the relative ordering of events locally)
10:40:16 <Bobtree> I realize that's not helpful in any way shap or form.
10:45:08 <Bobtree> funny that, I'm working on a new algorithm, now looking for the best language to implement it in, and yet if I could just post simple example code, everyone could implement it in their favorite language and we could all compare performance, and then it would already be done.
10:45:48 <Bobtree> if it were simple enough for such, I wouldn't be in search of a better language to begin with
10:49:20 <DRMacIver> Bobtree: It genuinely sounds like you should just not worry about the performance for now in that case. :)
10:51:45 <Bobtree> I do expect to find better ways to write it in the future, but performance is a pretty serious consideration
10:54:17 <Bobtree> performance and scalability are really the point of the level-of-detail bits that make it complicated, because they enable things that wouldn't otherwise be possible
10:55:55 <Bobtree> I really expect some jaws-on-the-floor reactions (possibly mine included) when people first see the system run
10:56:59 <sjanssen> if top-notch performance is really important to you, just use C
10:57:35 <Bobtree> well, that's where I'm coming from, but still hoping to find something better yet suitable
10:58:23 <sjanssen> OTOH, is your task suitable for code generation?
10:59:14 <sjanssen> http://www.cse.unsw.edu.au/~dons/papers/SCKCB07.html
10:59:14 <lambdabot> Title: Generative Code Specialisation for High-Performance Monte-Carlo Simulations
10:59:26 <Bobtree> it might be possible, but I don't know yet.  there won't be many operations in total, so it's feasible, but the data structures are very complicated
10:59:30 <Bobtree> I got that link already, thank you;
11:00:43 <Bobtree> it's the complexity of the necessary structures and manipulations that make C dangerous and error prone for this.
11:00:55 <sjanssen> Haskellers turn high icky high performance numerical problems into a task we all love: compiler writing :)
11:01:08 <Bobtree> mmmm, not really my forte.
11:01:26 <sjanssen> ah, but it is Haskell's forte
11:05:52 <Bobtree> thanks for the input everyone
11:06:22 <Bobtree> one more question, again, does anyone know why Clean is no longer Concurrent Clean?
11:07:31 <Igloo> Can anyone remind me if mingw has a commandline program of its own please?
11:07:49 <Igloo> Something akin to cmd.exe, I mean
11:07:52 <bos> a commandline program? you mean, like bash?
11:08:03 <Saizan> there's sh in msys
11:08:03 <bos> yes, it even has a port of rxvt.
11:08:09 <Igloo> OK, thanks
11:10:00 <Bobtree> yes, mingw has a nice unixy shell system
11:10:07 <Bobtree> msys anyway
11:17:32 <Excedrin> does anyone still read reddit? Paging #haskell to http://programming.reddit.com/info/1w1gg/comments
11:17:33 <lambdabot> Title: Creating A Functional Web Forum Program (reddit.com)
11:20:33 <goltrpoat> Excedrin:  i'm not sure what he's complaining about.. i played with HSQ briefly a while back, seemed pretty straightforward
11:20:42 <goltrpoat> HSQL, rather
11:22:01 <Excedrin> yea, I agree
11:22:29 <Excedrin> I think HAppS would make coding a simple forum very easy
11:23:08 <Excedrin> I don't know how to deal with scaling HAppS, but I imagine it's possible
11:23:11 <alexj> Excedrin.  Coding a blog demo
11:23:13 <alexj> right now
11:23:22 <alexj> you can see it in recent repos if you pull
11:23:24 <alexj> not complete yet
11:23:45 <Excedrin> cool, I wrote a ladder program with HAppS
11:23:50 <alexj> ladder?
11:24:45 <Excedrin> yes, like a Chess / Pool / Tennis ranking system
11:24:58 <Excedrin> it implements the Glicko rating system
11:25:06 <Shurique> what would be the best way to read the contents of a file, one line at a time, and insert lines that satisfy a given predicate into a list?
11:25:26 <alexj> excedrin: not sure I understand what that is, but I think that is cool.
11:25:40 <alexj> excedrin: where are you located?
11:26:07 <Excedrin> http://math.bu.edu/people/mg/glicko/
11:26:08 <lambdabot> Title: Glicko home page
11:26:10 <Excedrin> SF Bay area
11:26:12 <sjanssen> Shurique: do f <- readFile "foo"; return . filter p . lines $ f
11:26:52 <sjanssen> Shurique: and use the Data.ByteString.Lazy.Char8 analogs of 'lines' and 'readFile' if you need serious performance
11:27:02 <dmhouse> sjanssen: or simply fmap (filter p . lines) (readFile "foo")
11:27:05 <mauke> >>= return . better written as liftM
11:27:17 <alexj> excedrin: me too
11:27:27 <alexj> on union st right now.
11:27:28 * sjanssen suspects Shurique is a newbies that doesn't want to learn about liftM right now
11:27:36 <dmhouse> Yes, or s/fmap/liftM/ depending on your preferences, which modules are imported, alignment of the planets, etc.
11:27:53 <alexj> you in SF proper?
11:28:06 <Shurique> I am a newbie, yes, but I have time and I'm willing to learn :)
11:28:15 <Excedrin> no, live in RWC and work in MV
11:28:26 <Shurique> thanks for the suggestions
11:29:16 <dmhouse> Shurique: essentially, if you ever write do x <- blah; return (f x), or equivalently blah >>= return . f, then a shorter way of writing that is fmap f x, or liftM f x (they're the same function).
11:29:30 <dmhouse> (Up to Functor/Monad distinction, if you really want to get technical.)
11:29:56 <alexj> Excedrin: new arrival in SF.  Don't know the lingo
11:30:33 <alexj> are you programming Haskell/happs in a work context?
11:30:57 <Excedrin> no, just as a hobby
11:31:39 <Excedrin> RWC = Redwood City, MV = Mountain View, both are south of _The_ City
11:37:15 <bos> alexj: still up for lunch?
11:37:38 <alexj> yup.
11:37:51 <alexj> on union and webster now.
11:38:25 <bos> cool. great.
11:38:35 <alexj> Excedrin: am starting new company here .... looking for haskellers....
11:39:28 <alexj> bos: see you in 20 min at 641 vallejo
11:39:39 <bos> sounds good.
11:40:05 <weitzman> Why would ghc tell me getBounds is not in scope when all the rest of the MArray functions are working perfectly?...
11:41:32 <Codex_> weitzman: check for typos in the name :)
11:41:35 <weitzman> Aha, do I need 6.6?
11:41:48 <weitzman> There's no typo
11:41:56 <Igloo> Yes, it was bound or hasBoudns or something in earlier GHCs
11:41:59 <Igloo> And wasn't monadic
11:42:23 <weitzman> That's a little sneaky, changing API functions and not mentioning it in the docs
11:42:41 <Igloo> Which docs?
11:42:44 <Igloo> It was in the release notes
11:42:47 <weitzman> Whatever hoogle returns
11:43:01 <Igloo> Those docs document the current API
11:43:20 <weitzman> The current API should still mention incompatabile API differences with old versions, I'd say
11:43:57 <Igloo> I guess that would be nice, but it's not current practice
11:47:43 <CosmicRay> @seen syntaxninja
11:47:44 <lambdabot> Last time I saw syntaxninja was when I left #darcs, #dreamlinux-es, #gentoo-haskell, #gentoo-uy, #ghc, #haskell, #haskell-blah, #haskell-overflow, #haskell-soc, #jtiger, #oasis, #perl6, #scannedinavia
11:47:44 <lambdabot> n, #unicycling and #xmonad 19d 19h 15m 42s ago, and .
11:48:09 <CosmicRay> wow, lambdabot is everywhere.
11:48:27 <dmhouse> ?channels
11:48:27 <lambdabot> Unknown command, try @list
11:48:31 <dmhouse> ?list
11:48:31 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
11:48:47 <Igloo> He's been busy with wedding stuff recently
11:49:05 <Igloo> (syntaxninja, not lambdabot. TTBOMK, at least)
11:49:09 <CosmicRay> heh
12:58:52 <noj> how would I pass a specific instance of a typeclass function? this one: "unpack :: (Message a) => String -> a" I want to pass it as a function to another function, for the type class instance ClientMessage. I tried the obvious "unpack :: ClientMessage" but that doesn't work
13:01:03 <Saizan> well unpack :: String -> ClientMessage, at least
13:01:08 <sjanssen> noj: unpack :: String -> ClientMessage
13:01:16 <sjanssen> @quote stereo
13:01:16 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:02:08 <Procyon112> So, "newtype X = X T" vs. "data Y = Y T"  I am still not seeing where this makes any programatic difference.  If T is an infinite list, the newtype is still evaluated lazily.  Can somebody give an example where X and Y act differently?
13:02:31 <sjanssen> X undefined == undefined
13:02:39 <noj> of course, how obvious! thanks sjanssen and Saizan
13:02:40 <sjanssen> Y undefined /= undefined
13:03:59 <Procyon112> So the only difference is in divergence?
13:04:36 <Procyon112> (I'm trying to get my brain around it, not beat a dead horse :) )
13:04:36 <sjanssen> it's implemented differently, and has different performance characteristics
13:05:48 <sjanssen> from an implementation POV, the 'Y x' constructor allocates a new 'box' that contains a pointer to x
13:06:07 <sjanssen> but in 'X x', X is a no-op
13:06:31 <Procyon112> So, when then is a good time to choose newtype when you don't plan on wrapping undefined?  Should I always use data and possibly pepper in newtypes during profiling?
13:06:46 <hpaste>  LoganCapaldo pasted "sjanssen is there a way to write an example like this that does demonstrate the difference?" at http://hpaste.org/183
13:07:59 <sjanssen> oh, that's the other difference with newtypes
13:08:13 <sjanssen> pattern matching against a newtype never diverges
13:08:48 <sjanssen> Procyon112: you almost always want to use newtype for single constructor types
13:09:02 <sjanssen> very rarely do you want or need the distinction
13:09:57 <sjanssen> erm, single constructor, single component data types that is
13:10:52 <Procyon112> Right.  And when I *do* need data there instead, I assume that it will be because of a runtime error cropping up with my newtype.
13:11:18 <sjanssen> this doesn't really happen in practice
13:11:27 <Procyon112> :)
13:11:55 <sjanssen> because (Y _|_) is about as useless as _|_ itself
13:13:10 <Procyon112> right... which is kind of why I don't the point of newtype much.  It would seem that the parser could detect when the single-constuctor,single-param case exists and automatically unbox them as a compiler optimization.
13:13:10 <LoganCapaldo> would it be a good thing if a haskell compiler detected cases of data X = X T and converted them into newtypes?
13:13:24 <sjanssen> it changes the semantics
13:15:06 <sjanssen> http://haskell.org/onlinereport/exps.html#pattern-matching
13:15:07 <lambdabot> Title: The Haskell 98 Report: Expressions
13:15:33 <sjanssen> also http://haskell.org/onlinereport/decls.html#sect4.2.3
13:15:34 <lambdabot> Title: The Haskell 98 Report: Declarations
13:16:24 <sjanssen> Procyon112: do you have any concrete cases of wrestling between data and newtype?
13:18:42 <Jaak> > length $ iterate succ True
13:18:49 <lambdabot> Terminated
13:21:54 <Procyon112> sjanssen: No.. I was seeing no difference at all.  I was sitting there writing my code and realized I was using data or newtype completely arbitrarily without understanding why.
13:22:49 <sjanssen> Procyon112: just use newtype until the compiler complains :)
13:23:00 <Procyon112> :)
13:23:39 <sjanssen> (ie. use newtype for types with a single constructor containing a single componenent)
13:23:58 <dolio> Of course, you could use newtypes exclusively. :)
13:24:30 <sjanssen> that will get unreasonable at some point
13:24:35 <sjanssen> using Either is cheating
13:24:39 <dolio> data P a b c = Foo a b | Bar b c ==> newtype P a b c = P (Either (a, b) (b, c))
13:24:45 <Procyon112> lol
13:24:54 <sjanssen> and church encoding all your sum types is time consuming :)
13:25:02 <dolio> :)
13:34:57 <LoganCapaldo> Sum types are easier than others
13:37:46 <dolio> I must say, Oleg's paper on delimited continuations in operating system design is pretty cool.
13:37:52 <Saizan> esier than newtype T a b = T (a,b)?
13:38:27 <Vulpyne> What was the name of that SQL module that was built on top of hsql?
13:39:08 <Vulpyne> I was looking at it at one point, but I can't remember the name now. ;/
13:39:55 <Saizan> i only know of haskellDB as a layer on top of HDBC
13:40:29 <Vulpyne> Ah, damn, that must be what I was thinking of.
13:40:33 <Vulpyne> But it doesn't support MySQL. :(
13:40:35 <Vulpyne> Thanks.
13:40:45 <Saizan> yeah :\
13:40:51 <Vulpyne> Oh, wait.
13:40:54 <Vulpyne> It does support hsql.
13:41:03 <Vulpyne> haskelldb works for both hdbc and hsql.
13:41:03 <Saizan> uh
13:43:06 <Heffalump> and hdbc supports mysql via odbc, AIUI (not tried it yet, but plan to)
13:43:31 <Vulpyne> ODBC is a pain.
13:49:53 <mdmkolbe|work> Wow, ./compiler/nativeGen/MachCodeGen.hs is 5000 lines of Haskell!  The only other (non-generated) sources in the compiler even close to that are about half the size.
13:51:13 <Saizan> uoah, there are at least 10 wm there!
13:51:42 <mdmkolbe|work> real lol
13:53:36 <Igloo> wm?
13:53:46 <ari> Igloo: window managers
13:53:52 <Igloo> Ah
13:54:35 <Igloo> And 105 instances of #if; mmm
13:55:39 <Heffalump> Vulpyne: In what ways? (I have no experience of it)
13:56:36 <hpaste>  mdmkolbe|work pasted "in MachineCodeGen.hs" at http://hpaste.org/184
13:56:48 <mdmkolbe|work> Igloo: yeah, it's impossible to change for fear or breaking all the other platforms, some of which are already broken apearently
13:56:59 <mdmkolbe|work> s/fear or/fear of/
13:58:10 <Vulpyne> heffalump: Well, you need an ODBC library and you need to configure it.
13:58:27 <Vulpyne> heffalump: And it's another layer of stuff, which means more chance to have issues/performance.
13:58:41 <Vulpyne> I got it working at one point, but it was a pain. I don't really want to use it.
13:58:54 <Vulpyne> I don't know, though, I might have to. hsql seems pretty light.
13:59:04 <Vulpyne> Can't even have prepared statements.
13:59:35 <Vulpyne> I probably picked the worst real project for trying out Haskell. Heh. Something that has to capture packets with pcap and log them to DB.
14:07:42 <pigle-z> hi.. has been anybody here asking for a little help with a list program already? (like: 5=[5],[4,1],[3,2],[3,1,1],[2,1,1,1],[1,1,1,1,1])
14:08:16 <pigle-z> i'm having some troubles with that one :(
14:08:20 <ndm> hmm, my parsec isn't working :(
14:08:36 <Cale> pigle-z: sure
14:08:40 <ndm> the parser "types" matches a particular string
14:08:46 <ndm> the parser "names" doesn't
14:08:59 <ndm> but "try names <|> types" doesn't match either
14:09:20 <pigle-z> Cale: i'm having some troubles to find the recursion on it
14:09:34 <Cale> pigle-z: If you want to generate all the partitions of n, it helps to first write the program which generates all the partitions of n into parts of size at most k.
14:10:05 <shachaf> Is there a way to make runghc accept input from stdin?
14:10:25 <Cale> If we had such a program, partitions' n k = ..., then we could write partitions n = partitions' n n
14:10:42 <Cale> (as a partition will never contain a part larger than the sum)
14:11:35 <pigle-z> i think it's something little more simple. like decrementing the list's head, until the difference btwn the input and the head is one puting it on a list
14:11:58 <Cale> As for the recursion, at this point, just notice that a partition of n into parts of size at most k, is a number j from 1 up to k, (or from k down to 1) followed by a partition of (n-j) into parts of size at most j.
14:12:47 <pigle-z> hmm..
14:13:21 <Cale> (that's ignoring base cases, of course)
14:13:31 <pigle-z> yep
14:13:45 <pigle-z> but do you think it's simple to write this partition' program
14:13:46 <pigle-z> ?
14:13:48 <Cale> yeah
14:14:01 <Cale> Do you know about list comprehensions?
14:14:35 <Cale> that is, things like...
14:14:50 <Cale> > [(i,j) | i <- [1..3], j <- [1..3]]
14:14:51 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:15:04 <mdmkolbe|work> hmm, just another curiosity but I thought it would be cool to get a histogram of the GHC sources line counts
14:15:04 <LoganCapaldo> Comprehend comprehensions
14:15:07 <hpaste>  mdmkolbe|work pasted "Distribution of line counts in the GHC sources" at http://hpaste.org/185
14:15:28 <mdmkolbe|work> notably 3/4 of the GHC sources are under 100 lines
14:16:05 <Cale> > [(i,j) | i <- [1..3], j <- [4..6]]
14:16:06 <lambdabot>  [(1,4),(1,5),(1,6),(2,4),(2,5),(2,6),(3,4),(3,5),(3,6)]
14:16:27 <Cale> > [(i,j) | i <- [1..3], j <- [1..3], i < j]
14:16:28 <lambdabot>  [(1,2),(1,3),(2,3)]
14:16:40 <Cale> pigle-z: There are some examples, anyway :)
14:17:19 <Cale> List comprehensions allow you to construct lists of all elements of a specific form, constructed by choosing elements of other lists in all possible ways.
14:17:22 <Vulpyne> mdkmkolbe: I've noticed that programming in Haskell gets you in the habit of splitting stuff up into very small chunks.
14:17:36 <Cale> (and put conditions on the choices at the same time, but we won't need that)
14:18:25 <pigle-z> i see
14:20:05 <Cale> also, you're allowed to make later generators depend on earlier ones (it's sort of like a bunch of nested loops, if you're used to imperative programming)
14:20:23 <Cale> > [(i,j) | i <- [1..10], j <- [1..i]]
14:20:25 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
14:21:30 <Cale> So, play around with those pieces for a bit, and if you're still having trouble, just ask :)
14:21:53 <pigle-z> yes, i guess this will help
14:21:59 <pigle-z> thank you very much ;)
14:22:09 <Cale> No problem :)
14:28:48 <julian_> Hi
14:29:29 <Cale> hello
14:30:10 <julian_> @pl g x h 0 = ([], x : snd (h 0))
14:30:10 <lambdabot> g = (((,) [] .) .) . (. (snd .)) . (.) . (:)
14:36:00 <mdmkolbe|work> hmm, the number of source files of a particular size (in lines) in GHC follows the inverse square law
14:39:28 <LoganCapaldo> @unpl f . g
14:39:28 <lambdabot> (\ c -> f (g c))
14:40:10 <dolio> Note: the result of julian_'s pl isn't right. :)
14:41:02 <dolio> @pl f 0 = 0
14:41:02 <lambdabot> f = id
14:42:53 <julian_> @pl p x h n = if n==0 then ([],x:snd (h 0)) else (x:xs,ys) where (xs,ys) = h (n-1)
14:42:53 <lambdabot> (line 1, column 70):
14:42:53 <lambdabot> unexpected "="
14:42:53 <lambdabot> expecting variable, "(", operator or end of input
14:43:36 <dolio> Probably doesn't do where clauses.
14:43:52 <dolio> @pl f z = g where g = z
14:43:52 <lambdabot> (line 1, column 17):
14:43:52 <lambdabot> unexpected "="
14:43:52 <lambdabot> expecting variable, "(", operator or end of input
14:44:17 <dolio> @pl f z = g where z
14:44:17 <lambdabot> f = g where
14:46:12 <julian_> @pl p x h n = if n==0 then ([],x:snd (h 0)) else (x:(fst(h(n-1))),snd(h(n-1)))
14:46:15 <lambdabot> p = ap (ap . ((ap . flip (if' . (0 ==)) . (,) []) .) . (. (snd . ($ 0))) . (:)) ((`ap` ((snd .) . (. subtract 1))) . (liftM2 (,) .) . (. ((fst .) . (. subtract 1))) . (.) . (:))
14:46:28 <dolio> So much better. :)
14:46:54 <flippo> my goodness
14:47:04 <Vulpyne> Is that the obfuscator command? :)
14:47:36 <dolio> Depends.
14:47:37 <julian_> translate from pointwise to pointfree(pointless maybe) :P
14:47:43 <monochrom> @pl f x y = x
14:47:44 <lambdabot> f = const
14:47:50 <monochrom> it's the clarifier command
14:47:52 <julian_> where is liftM2 ?
14:48:00 <dolio> @pl \x -> f (g (h x))
14:48:00 <lambdabot> f . g . h
14:48:22 <monochrom> @pl \x -> f (g (h (f (g (h x)))))
14:48:22 <lambdabot> f . g . h . f . g . h
14:48:53 <dolio> liftM2 is in Control.Monad
14:49:28 <monochrom> Some people think that \x -> f (g (h (f (g (h x))))) is clearer and simpler than f.g.h.f.g.h.  They also think that x^2 + 2x + 1 is simpler than (x+1)^2.
14:49:54 <monochrom> http://www.vex.net/~trebla/pointfree.html
14:49:58 <julian_> and if' ?
14:50:00 <monochrom> err
14:50:01 <ddarius> Sometimes one is better than the other
14:50:05 <monochrom> http://www.vex.net/~trebla/weblog/pointfree.html
14:50:06 <lambdabot> Title: The Point of Pointfree
14:50:07 <dolio> if' doesn't exist.
14:50:29 <ddarius> if' b t e = if b then t else e
14:50:52 <LoganCapaldo> I think let m = f . g . h in m . m is better than f.g.h.f.g.h :)
14:51:21 <dolio> Nah, 'join (.) $ f . g . h'
14:51:39 <dolio> :)
14:52:48 <LoganCapaldo> > let twice f = f . f in in twice $ id . const . seq
14:52:48 <lambdabot>  Parse error
14:52:58 <Jaak> @check \xs -> nub (sort xs) == map head . group $ sort xs where _ = xs :: [Int]
14:52:58 <lambdabot>  Parse error
14:53:00 <LoganCapaldo> > let twice f = f . f in twice $ id . const . seq
14:53:01 <lambdabot>  Add a type signature
14:53:18 <julian_> @pl g x h 0 = ([], x : snd (h 0))
14:53:19 <lambdabot> g = (((,) [] .) .) . (. (snd .)) . (.) . (:)
14:59:55 <jmesquita> Hello you all.
15:04:55 <fasta>  if
15:06:22 <jmesquita> I am learning Haskell at college and my teacher proposed an problem that I just don't know how to solve
15:07:06 <jmesquita> My program needs to receive an integer and return a list of lists in which the sum of each lists elements are equal to the integer I received
15:07:41 <jmesquita> For example if I receive 2 as input I will return: [[2],[1,1]]
15:07:57 <jmesquita> I am stuck here, can any of you help me?
15:07:58 <fasta> jmesquita: homework?
15:08:13 <monochrom> Use recursion.
15:08:17 <fasta> never mind
15:08:24 <jmesquita> fasta, Not really
15:08:31 <ddarius> The problem is underspecified as you've stated it.
15:08:33 <jmesquita> fasta, A challenge
15:08:42 * fasta is with ddarius 
15:08:46 <jmesquita> ddarius, Why so?
15:08:57 <jmesquita> monochrom, yeah, but how?
15:09:02 <ddarius> > sum [-1,3]
15:09:06 <lambdabot>  2
15:09:12 <jmesquita> ddarius, Ok, all positive, sorry
15:09:21 <sorear> hello.
15:09:28 <LoganCapaldo> > sum [0,0,0,2,0]
15:09:29 <lambdabot>  2
15:09:31 <jmesquita> ddarius, Actually, all >0
15:09:34 <dmhouse> LoganCapaldo: positive means > 0
15:09:38 <fasta> I know an answer: f x = [[x]]
15:09:39 <ddarius> and do you always want replicate n 1 and so forth
15:09:39 <dmhouse> jmesquita: as above.
15:09:51 <monochrom> The answer to n+1 can be built on the answer to n.
15:10:03 <ddarius> But at any rate, monochrom is telling you what to do.
15:10:06 <LoganCapaldo> dmhouse: so is zero negative?
15:10:13 <dmhouse> LoganCapaldo: no, it's neither.
15:10:20 <ddarius> > signum 0
15:10:21 <lambdabot>  0
15:10:26 <LoganCapaldo> dmhouse: I demand a dichotomy!
15:10:29 <LoganCapaldo> ;)
15:10:33 <monochrom> I am just too lazy to spell the whole thing out.
15:10:35 <jmesquita> ddarius, Ok, I am a really unexperienced programmer, specially with recursion
15:10:35 <dmhouse> LoganCapaldo: positive = > 0. negative = < 0. nonnegative = >= 0. nonpositive = <= 0.
15:10:38 <ddarius> dmhouse: You get merely a trichotomy
15:10:53 <ddarius> Er LoganCapaldo
15:11:04 <jmesquita> monochrom, Ehehe, you don't have to give me any coding
15:11:19 <jmesquita> monochrom, As long as you are pacient enough to deal with someone barely dumb
15:11:24 <jmesquita> monochrom, that would be me
15:11:27 <jmesquita> monochrom, :)
15:12:08 <monochrom> I heard that the French define >=0 to be positive and <=0 to be negative.
15:12:09 <ddarius> jmesquita: Think about how you could solve the problem for n+1 if you already had the answer for n
15:12:28 <ddarius> monochrom: Luckily, no one listens to the French.
15:12:38 <monochrom> I like them.
15:12:48 <jmesquita> ddarius, humm, what would be n?
15:12:59 <ddarius> But it'd be suprising if that were the case, as there were quite a few great French mathematicians
15:13:16 <ddarius> jmesquita: An arbitrary number (presumably >0)
15:14:00 <jmesquita> ddarius, Ok, I got an idea of an algorithm, I just don't know how to implement that
15:14:11 <jmesquita> ddarius, Here's how I would do it
15:15:04 <jmesquita> ddarius, [n] is the first answer
15:15:12 <LoganCapaldo> I feel insecure so I'm gonna hpaste my soln. jmesquita don't look if you don't want to corrupt your mind with my answer
15:15:30 <jmesquita> ddarius, then [n-1,1]
15:15:37 <jmesquita> ddarius, then [n-2,2]
15:15:53 <jmesquita> But always with the first element >=1
15:16:14 <jmesquita> That will guarantee that the sum of the two terms are always = n
15:16:18 <monochrom> I miss the Haskell Monthly News.
15:16:46 <ddarius> jmesquita: I imagine you need to return -all- such lists modulo permutations.
15:16:46 <hpaste>  LoganCapaldo pasted "jmesquita's problem" at http://hpaste.org/186
15:17:17 <jmesquita> WhenYes
15:17:21 <jmesquita> ddarius, Yes
15:17:24 <jmesquita> ddarius, All of them
15:18:01 <ddarius> jmesquita: Your current approach only returns two element lists, it will not return 3 = sum [1,1,1]
15:18:45 <jmesquita> Yeah, but when the first element gets to 1, I will have n-1 on the second
15:18:57 <jmesquita> Right?
15:19:02 <ddarius> jmesquita: Yes, so?
15:19:12 <jmesquita> Then I will do [1,n-2,1]
15:19:19 <LoganCapaldo> fwiw, mine is wrong
15:19:26 <jmesquita> [1,n-3,2]
15:19:36 <jmesquita> Untill [1,1,n-2]
15:20:13 <ddarius> jmesquita: Right out the sequence of solutions using n = 2,3, and 4 and compare them.
15:20:14 <jmesquita> Eventually, I will get to every element as 1
15:20:46 <jmesquita> n=2 : [[2],[1,1]]
15:21:04 <Excedrin> I think I misunderstood the problem
15:21:25 <Excedrin> LoganCapaldo: I annotated your paste...
15:21:30 <jmesquita> n=3 : [[3],[2,1],[1,2],[1,1,1]]
15:21:38 <jmesquita> Ah, heres the problem with this algorithm
15:21:46 <jmesquita> [2,1] and [1,2] are the same
15:21:51 <ddarius> Yep.
15:22:12 <jmesquita> ddarius, Hummm, how would I get this right then ...
15:22:14 <chessguy> why do i feel like i should have heard of these authors before? http://www.amazon.com/Pragmatic-Programmer-Journeyman-Master/dp/020161622X
15:22:20 <lambdabot> http://tinyurl.com/y828cp
15:22:21 <Excedrin> oh, so this is a simple list monad thing, right?
15:22:22 <chessguy> fantastic book, by the way
15:22:43 <ddarius> jmesquita: So for now list them as usual, but only keep lists that are sorted ascendingly when you have permutations.
15:23:13 <jmesquita> ddarius, Ok, I can do this in a really dumb way
15:23:22 * yax1 wonders if it's possible to write haskell code while drunk
15:23:26 <newsham_> http://lolcode.com/implementations/implementations
15:23:28 <lambdabot> Title: implementations:implementations Â· LOLCODE
15:23:38 <ddarius> yax1: The type systems is quite a boon there.
15:23:45 <Excedrin> yax1: sure, just mash at keys until it typechecks
15:24:06 <yax1> heh
15:24:36 <jmesquita> ddarius, I can do it like this: [[n],[n,1],[n,2] ... ]
15:24:53 <fasta> Just to make sure: if I have a reference somewhere and then pass that reference as an argument to some function, pass it again and again, and then writeSTRef that_ref <some value>, then at the location in the code where I called the function chain, the contents of that reference is now <some value>, right?
15:25:02 <jmesquita> If the sum gets bigger then n, I will decrease n and create a new item on the new list
15:25:27 <jmesquita> That would defnetly work, the problem is implementing that
15:25:31 <ddarius> sum [n,1] /= n
15:26:19 <jmesquita> ddarius, Sorry, wrote it wrong
15:27:00 <jmesquita> ddarius, I will do n as the fist list. then when trying to add 1 to n, I will see it is bigger, then I have to do n-1
15:27:14 <jmesquita> ddarius, Shoot, I have no idea
15:27:48 <newsham_> how come no haskell EDSL on the lolcode page?
15:27:48 <ddarius> jmesquita: Write out the solution for n=2,3,4 keeping only the sorted lists when there are "duplicates"
15:27:57 <jmesquita> ddarius, Everything I think of will repeat numbers
15:28:03 <ddarius> newsham_: Because you haven't written one.
15:28:22 <ddarius> jmesquita: Just write out the answers and compare for now.
15:28:26 <newsham_> if haskell was a cool language, it woulda been done already!
15:28:34 <jmesquita> ddarius, With duplicates?
15:28:42 <jmesquita> ddarius, Or how it is supposed to be?
15:28:44 <sorear> @quote dons drunk
15:28:44 <lambdabot> dons says: Coding drunk in Haskell is ok though, its like drinking on a passenger plane flight -- the stewards will prevent you from hurting anyone. However, coding drunk in C is just scary, DUI
15:28:44 <lambdabot> territory, and should not be allowed. I hope linux kernel devs don't write code under the influence
15:28:45 <ddarius> No, keep only the sorted versions.
15:28:49 <sorear> yax1: ^^
15:29:04 <jmesquita> ddarius, Ok
15:29:11 <sorear> yax1: btw, your nick is still yaxONE
15:29:29 <yax1> yes, i'm logged in at work
15:29:34 <yax1> but i can fix that
15:30:17 <jmesquita> n=2 : [[2],[1,1]], n=3 : [[3],[2,1],[1,1,1]] and n=4 : [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]]
15:30:23 <fasta> Linux said GIT is 80,000 LOC. As if that's a good thing...
15:30:27 <fasta> Linus*
15:30:44 <jmesquita> ddarius, Right
15:31:21 <sorear> uh, how could anyone think that?
15:31:40 <jmesquita> ddarius, Erm, I am afraid to say: what now?
15:31:41 <jmesquita> Ehehehe
15:32:20 <sorear> fasta: I don't know how it is with Finns, but Americans don't brag about how fat they are.  Why do they do it with code?
15:32:41 <dibblego> how many LOC is darcs?
15:32:42 <dmwit> sorear: ...because it's good code?
15:32:50 <Itkovian> is there something like Python's optparse for Haskell?
15:32:51 <yaxu> well i seem to be able to write parseable haskell, but not say meaningful things on IRC, so I shall be quiet :)
15:33:05 <dmwit> sorear: I doubt much of git is "fat" -- I feel reasonably confident in guessing that it is dense code.
15:33:08 <fasta> dmwit: 80,000 lines of good code?
15:33:17 <fasta> dmwit: highly unlikely.
15:33:19 <sorear> All code is fat.
15:33:27 <augustss> Unix v6 was 10000 lines...
15:33:30 <sorear> The only good lines are LOD
15:33:37 <fasta> Add another "did it in 2 weeks to it" and you got a mess.
15:35:15 <Excedrin> wow, it's 82866 lines
15:35:38 <jmesquita> I am sorry guys. But I am lost ... :(
15:35:46 <dmwit> jmesquita: What are you trying to do?
15:35:52 <Itkovian> jmesquita: is it the order of items in the sublists  important?
15:35:55 <dmwit> (Fill me in, I just arrived. =)
15:35:59 <jmesquita> Itkovian, No!
15:36:15 <jmesquita> dmwit, I want to do the following: n=2 : [[2],[1,1]], n=3 : [[3],[2,1],[1,1,1]] and n=4 : [[4],[3,1],[2,2],[2,1,1],[1,1,1,1]]
15:36:23 <jmesquita> dmwit, For any n as input
15:36:30 <dmwit> ok
15:36:35 <dmwit> Were you in here last night, too?
15:36:40 <dmwit> Or was that a different person?
15:36:43 <Itkovian> so of [1,2] and [2,1] , only one of them should occur
15:36:52 <jmesquita> dmwit, The sum of the sublists is always equal  n
15:36:56 <jmesquita> Itkovian, yes
15:36:59 <jmesquita> dmwit, no, why?
15:37:04 <Itkovian> jmesquita: but what you said to dmwit gives you the solution
15:37:11 <dmwit> Somebody else was asking the exact same question. =)
15:37:17 <Itkovian> in a sense
15:37:24 <Itkovian> think on it
15:37:24 <dmwit> jmesquita: Hold on a sec, I'll look in the logs.
15:37:52 <jmesquita> Itkovian, I bet, I am just bad at this
15:38:03 <Excedrin> I guess git should be about 2762 lines of Haskell, but darcs is 55731 lines, so I guess darcs has 20 times more functionality than git
15:38:05 <Itkovian> jmesquita: try to find a pattern in what you wrote down
15:38:18 <jmesquita> Itkovian, All the 1,1,1,1
15:38:18 <Itkovian> Excedrin: only code lines?
15:38:23 <Excedrin> no, all lines
15:38:30 <jmesquita> Itkovian, n*1
15:38:34 <Itkovian> jmesquita: what would happen if you went from 4 to 5?
15:38:50 <Itkovian> come on, I'm practically giving you the solution
15:39:01 <Itkovian> and I'm not used to doing that for students :-)
15:39:32 <jmesquita> Itkovian, I would add one more 1 to all the sublists
15:39:50 <jmesquita> and the a sublist containing the element 5
15:40:07 <Itkovian> but that's not sufficient
15:40:07 <dmwit> jmesquita: Exactly!
15:40:23 <Itkovian> but you are on the right track, I think
15:40:34 <dmwit> jmesquita: Now just think of the few cases you're missing (try it!) and you'll be even closer.
15:40:49 <jmesquita> n=5: [[5],[4,1],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]
15:41:09 <jmesquita> I am missing [3,2]
15:41:09 <dmwit> jmesquita: Here's another idea: make a helper function (f :: Int -> Int -> [[Int]])
15:41:24 <fasta> I can't say I can read that C code very good. Can you?
15:41:43 <dmwit> It would give you lists that sum to "n", using at most "m" as the biggest element.
15:41:52 <fasta> It has some comments, but there are lots of abbreviations that I don't know.
15:42:14 <fasta> It seems a document describing what all those abbreviations mean would come in handy :)
15:42:28 <Excedrin> git has almost no comments, and it does have comments like: /* why??? */
15:42:47 <Itkovian> Excedrin: easy answered: because.
15:42:54 <Itkovian> easily even
15:42:59 <Excedrin> maybe I should submit a patch
15:43:22 <Itkovian> Excedrin: it would zip pretty well, I guess :-)
15:43:43 <fasta> All these "open-source" programs with such bad comments aren't "open-source".
15:44:01 <jmesquita> dmwit, I dont understand that
15:44:05 <piis3141> question: is there a function that converts a `Integer' to a `Int'?
15:44:24 <dibblego> ?hoogle Integer -> Int
15:44:24 <lambdabot> No matches, try a more general search
15:44:31 <dolio> > fromInteger 5 :: Int
15:44:32 <dibblego> ?hoogle Num a => Integer -> a
15:44:33 <lambdabot>  5
15:44:33 <lambdabot> Prelude.fromInteger :: Num a => Integer -> a
15:44:36 <Itkovian> piis3141: fromInteger ?
15:44:39 <fasta> It makes me think they have a real version of the program source text somewhere else.
15:44:48 <fasta> Or they are just bad programmers.
15:45:00 <dibblego> piis3141, just ask hoogle, but hoogle puts the question mark at the end (poor grammar)
15:45:06 <fasta> "bad" meaning that when they die the program needs to be rewritten.
15:45:19 <piis3141> ok thanks
15:45:21 <dmwit> jmesquita: For example, (f 10 1 = [[1,1,1,1,1,1,1,1,1,1]]), and (f 5 2 = [[2,2,1], [2,1,1,1], [1,1,1,1,1]])
15:45:31 <ddarius> Luckily the world will move on before they die.
15:45:39 <dmwit> jmesquita: You should be able to define such a function inductively in a fairly intuitive way.
15:47:18 <jmesquita> dmwit, Bah
15:47:30 <jmesquita> dmwit, I dont understand that
15:47:39 <sorear> ddarius: You can "pull a JÃ¶rg" at any age, though.
15:47:44 <jmesquita> dmwit, Probably because I am haskell dumb
15:47:48 <dmwit> jmesquita: Which part is confusing?
15:47:55 <dmwit> jmesquita: Do you understand the non-Haskell bits?
15:48:05 <dmwit> jmesquita: If so, we can definitely help with the Haskell bits.
15:48:07 <fasta> There is some technical documentation
15:48:28 <Excedrin> some comments from git (obviously, there are some reasonable comments as well, but these are amusing), /* Ugh */, return; /* all done */, if (DEBUG) /* sanity */, /* Reading from stdin */, "\033[31m",     /* REMOTE (red) */, /* BAD CRAP */, /* another O(n^2) function ... */
15:48:30 <jmesquita> dmwit, Yes
15:48:36 <dmwit> ?pl \f x -> f x x
15:48:36 <lambdabot> join
15:48:49 <mdmkolbe|work> who is currently working on Yi?  I have a question for them and it's burning a hole in my head (but dons is asleep I presume)
15:49:01 <sorear> mdmkolbe|work: dons isn't working on yi
15:49:04 <jmesquita> dmwit, That helper function is defenetly my solution
15:49:05 <sorear> jyp is
15:49:07 <sorear> @seen jyp
15:49:07 <lambdabot> I saw jyp leaving #oasis and #haskell 21d 1h 8m 33s ago, and .
15:49:19 <sorear> don't worry, the bot is just forgetful
15:49:21 <dmwit> jmesquita: Right.  So, think inductively.
15:49:21 <sorear> @uptime
15:49:22 <lambdabot> uptime: 17h 18m 6s, longest uptime: 17d 7h 41m 6s
15:49:25 <dmwit> jmesquita: What's the base case?
15:49:39 <jmesquita> dmwit, If I had that, as far as I understand, I could do f 5 5, and that would return me the right combination already
15:49:45 <dmwit> exactly!
15:49:46 <jmesquita> n*1
15:50:10 <jmesquita> dmwit, if n is 5, the base cas will be [1,1,1,1,1]
15:50:18 <dmwit> Right!
15:50:26 <dmwit> How do you think you might write such a base case in Haskell?
15:50:54 <jmesquita> dmwit, prog n = [] ???
15:50:55 <mdmkolbe|work> sorear: ok, thx
15:51:18 <jmesquita> dmwit, No, thats not the base case
15:51:18 <dmwit> jmesquita: We need a function of two variables, so we can tell apart base cases and other cases.
15:51:52 * ddarius wonders whether a relational approach would've been better.
15:51:56 <sorear> mdmkolbe|work: jeanphilippe.bernardy@gmail.com
15:52:53 <jmesquita> dmwit, Ok, I am not thinking straight anymore
15:53:04 <jmesquita> dmwit, Why on earth haskell gets me confused all the time
15:53:21 <ddarius> jmesquita: Haskell has nothing to do with it
15:54:04 <ddarius> You haven't yet described the algorithm, so the implementation language is largely irrelevant.
15:54:15 <fasta> jmesquita: Try Scheme, if you want to make sure it's not the programming language that's in the way.
15:54:23 <jmesquita> ddarius, Then, like I said, I have been given a task I am not able to complete
15:54:32 <dmwit> I disagree.
15:54:35 <ddarius> I doubt that.
15:54:40 <dmwit> You just haven't fully thought out how to accomplish it yet.
15:54:49 <dmwit> Once you have, the actual coding will be easy.
15:55:32 <jmesquita> dmwit, Ok, I might be frustrated now
15:55:40 <jmesquita> dmwit, I will pick it up tomorrow morning
15:55:45 <jmesquita> dmwit, Its already late here
15:55:54 <dmwit> Okay.  Good luck!
15:56:03 <jmesquita> dmwit, Thanks a lot
15:56:14 <jmesquita> ddarius, Thanks dude, i am sorry to be so pissed at ... my head
15:56:15 <jmesquita> :D
15:56:27 <jmesquita> Thanks again you all
15:57:06 <Itkovian> yw
15:58:53 <Jaak> > let ascending (x : y : ys) = if x <= y then ascending (y : ys) else False; ascending _ = True; sums n = case n of 0 -> []; _ -> [n] : [m' | n' <- [1..n - 1], m' <- map (n' :) (sums $ n - n'), ascending m'] in sums 7
15:58:54 <lambdabot>  [[7],[1,6],[1,1,5],[1,1,1,4],[1,1,1,1,3],[1,1,1,1,1,2],[1,1,1,1,1,1,1],[1,1,...
16:00:05 <dmwit> > let sums x = sums' x x; sums' n 1 = [replicate n 1]; sums' n m = (if n >= m then map (m:) (sums' (n - m) m) else []) ++ sums' n (m - 1) in sums 7
16:00:06 <lambdabot>  [[7],[6,1],[5,2],[5,1,1],[4,3],[4,2,1],[4,1,1,1],[3,3,1],[3,2,2],[3,2,1,1],[...
16:00:31 <Jaak> nice
16:01:37 <dmwit> > groupBy (<) [1..5]
16:01:39 <lambdabot>  [[1,2,3,4,5]]
16:02:00 <int-e> > groupBy (<) [1,3,2,0,5,4,3,2,1]
16:02:03 <lambdabot>  [[1,3,2],[0,5,4,3,2,1]]
16:02:13 <dmwit> > let ascending xs = length (groupBy (<) xs) == 1 in ascending [1..5]
16:02:14 <lambdabot>  True
16:02:17 <dmwit> > let ascending xs = length (groupBy (<) xs) == 1 in ascending [1..5,4]
16:02:17 <lambdabot>  Parse error
16:02:24 <dmwit> > let ascending xs = length (groupBy (<) xs) == 1 in ascending 4:[1..5]
16:02:25 <lambdabot>   add an instance declaration for (Num Bool)
16:02:25 <lambdabot>     In the expression: 5
16:02:34 <dmwit> > let ascending xs = length (groupBy (<) xs) == 1 in ascending (4:[1..5]) -- =)
16:02:35 <lambdabot>  False
16:02:57 <dmwit> > let ascending xs = sort xs == xs in ascending [1..5]
16:02:58 <lambdabot>  True
16:03:06 <dmwit> > let ascending xs = sort xs == xs in ascending (4:[1..5])
16:03:07 <sorear> dmwit: tell me what groupBy does, without looking at code or documentation
16:03:07 <lambdabot>  False
16:03:16 <int-e> > let ascending xs = all (uncurry (<)) (zip xs (drop 1 xs)) in ascencing [1,2,3]
16:03:17 <lambdabot>   Not in scope: `ascencing'
16:03:22 <int-e> > let ascending xs = all (uncurry (<)) (zip xs (drop 1 xs)) in ascending [1,2,3]
16:03:23 <lambdabot>  True
16:03:31 <dmwit> sorear: It groups lists into a list of lists using the given predicate as a grouper.
16:03:36 <sorear> dmwit: "grouper"
16:03:36 <dmwit> sorear: Why do you ask?
16:03:40 <Jaak> > let ascending = (<= 1) . length . groupBy (<=) in ascending [1,2,3,3]
16:03:42 <lambdabot>  True
16:03:48 <sorear> dmwit: Because a lot of people misunderstand.
16:03:50 <ddarius> sorear: Technically, he can't.
16:03:51 <Jaak> > let ascending = (<= 1) . length . groupBy (<=) in ascending [1,2,3,3,2]
16:03:52 <lambdabot>  True
16:03:55 <Jaak> err
16:04:07 <int-e> Jaak: groupBy won't work
16:04:12 <Jaak> oh, right
16:04:19 <dmwit> sorear: It was a trick to make one pass over the data, instead of the two that the sort method requires.
16:04:24 <sorear> > groupBy (<) [10,9,11]
16:04:24 <ddarius> Not with certainty at least.
16:04:25 <lambdabot>  [[10],[9,11]]
16:04:58 <sorear> > groupBy (>) [10,6,8]
16:04:59 <lambdabot>  [[10,6,8]]
16:05:02 <sorear> dmwit: ^^^
16:05:35 <dmwit> sorear: I'm lost.  What's the point you're trying to make?
16:05:43 <dmwit> It's a lot easier to just say it, I think. ;-)
16:05:47 <Jaak> > let asceding xs = and $ zipWith (<=) xs (tail xs)) in asceding [1,2,3]
16:05:47 <lambdabot>  Parse error
16:05:54 <ddarius> Hmm, what is the real name for groupBy
16:05:56 <sorear> dmwit: groupBy doesn't compare adjacent elements
16:05:59 <Jaak> > let asceding xs = and $ zipWith (<=) xs (tail xs) in asceding [1,2,3]
16:06:01 <lambdabot>  True
16:06:01 <sorear> ddarius: List.groupBy
16:06:03 <Jaak> > let asceding xs = and $ zipWith (<=) xs (tail xs) in asceding [1,2,3,2]
16:06:04 <lambdabot>  False
16:06:18 <sorear> dmwit: it compares each new element to the first element of the group
16:06:25 <dmwit> sorear: Mmmm... wow, I must be half asleep.
16:06:29 <ddarius> sorear: I meant a name that captures it's behavior when the passed in function isn't an congruence.
16:06:44 <sorear> dmwit: which makes no difference if you're a good boy and use equivalence relations like the docs require
16:07:16 <sorear> ddarius: Wouldn't such a name be about as long as the definition?
16:07:24 <dmwit> sorear: Okay, thanks.  Good point! =)
16:07:40 <ddarius> Not likely.
16:07:49 <ddarius> It's not -that- unstructured.
16:08:46 <ddarius> @src groupBy
16:08:46 <lambdabot> groupBy _  []       =  []
16:08:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:08:46 <lambdabot>     where (ys,zs) = span (eq x) xs
16:09:08 <int-e> ddarius: if the given relation is a partial order it groups by minima - a new group changes when the minimum of the initial segment of the given list changes.
16:09:47 <ddarius> int-e: You are being too concrete.
16:09:56 <Jaak> @type let ascending = and . (zipWith (<=) `ap` tail) in ascending
16:09:58 <lambdabot> forall a. (Ord a) => [a] -> Bool
16:10:10 <int-e> ddarius: the definition is artificial for non-equivalence relations, imho.
16:13:07 <Jaak> @pl \xs -> and $ zipWith (<=) xs (tail xs)
16:13:07 <lambdabot> and . ap (zipWith (<=)) tail
16:15:15 <fasta> Why are dictionaries being passed in the implementation of type classes in Haskell?
16:15:42 <int-e> jhc makes do without them.
16:15:46 <fasta> Doesn't the type infererencer know _exactly_ what is being called when?
16:15:53 <fasta> int-e: cool
16:16:25 <int-e> but in general, no, you can't really - you can have a haskell program that uses an arbitrary number of types (with corresponding instances) at runtime.
16:17:01 <fasta> int-e: Ah, like the Peano type?
16:17:01 <int-e> (jhc makes that work by traversing a run-time representation of the type I guess.)
16:17:05 <int-e> fasta: yes.
16:17:26 <int-e> fasta: or like the finger tree in Data.Sequence
16:17:44 <fasta> int-e: but for non-recursive types the costs should be zero
16:18:57 <fasta> C++0x gets these "concepts", but it must implement them efficiently, and although I am no expert, I'd expect them to get the same problems.
16:19:04 <int-e> fasta: not passing dictionaries also means having to specialize functions for every instance of the classes they use (if they're actually used for that class, of course)
16:19:47 <int-e> fasta: so the downside of the approach is the risk of code explosion.
16:19:50 <fasta> int-e: a combinatorial explosion
16:20:35 <fasta> int-e: but that would be no larger than "hand-coded".
16:20:53 <fasta> int-e: although, reducing code size is sometimes a good idea.
16:21:20 <sorear> nah, hand coding results in dictionary use
16:21:37 <sorear> people, at least good ones, don't duplicate code
16:21:49 <fasta> sorear: that's not how Bjarne puts it :)
16:21:55 <fasta> sorear: but yes, you are right.
16:22:50 <sorear> fasta: C++ (STL actually) concepts are just compile time duck typing
16:23:07 <int-e> fasta: in any case inlining can also reduce the cost of passing dictionaries around. ghc does specialise that inlined code if the type is statically known.
16:24:53 <fasta> sorear: duck-typing means crash and burn when you use something wrongly at run-time in Python right? I.e. in SmallTalk you get the message "not understood".
16:25:30 <fasta> sorear: by "it" I mean calling a method bark at a cat.
16:25:33 <sorear> fasta: Right.
16:25:49 <sorear> fasta: In C++ you get Cannot resolve bark(cat)
16:26:04 <sorear> fasta: but that is static/dynamic
16:26:16 <sorear> completely orthogonal to duck/class
16:26:17 <fasta> sorear: yes, I have seen 4 pages of output when I used a Boost library.
16:27:01 * sorear should note that he has never actually used a C++ compiler
16:27:59 <LoganCapaldo> oh lordy template error messages make the no instance for Num [t] ghc messages look completely clear
16:28:33 <int-e> LoganCapaldo: you can thank the hugs and ghc compiler writers for that.
16:28:35 <wchogg> LoganCapaldo:  I hear you there.
16:29:30 <fasta> sorear: how are duck/class related then?
16:30:33 <fasta> I have, on multiple occasions, gotten 3 pages of output from GHC.
16:30:38 <sorear> duck typing is all about the names.
16:30:41 <goltrpoat> sorear:  concepts basically introduce dependently parametrizable typeclasses to c++.  instead of saying template <T> void func() { T::some_method_i_expect(some_value_that_may_be_illegal_for_this_T); }, you specify all that at compile that
16:30:59 <goltrpoat> very little to do with duck typing.
16:31:11 <goltrpoat> er.. compile that = compile time
16:31:23 <sorear> goltrpoat: Concepts don't exist in the compiler, unless they've reused the term since the last time I read the library manual
16:31:38 <fasta> sorear: they are working on that
16:31:41 <sorear> Concepts, as I understood them, were notions like EqualityComparable
16:31:42 <ddarius> sorear: They hope to formalize them.
16:31:46 <goltrpoat> T::some_method_i_expect would normally fail at compile time, if T doesn't implement it, but the dependent bit adds static guarantees
16:31:50 <fasta> sorear: don't know whether they will succeed, though.
16:31:53 * sorear waves a cross at fasta
16:31:59 * sorear jumps back
16:32:18 <goltrpoat> sorear:  you're thinking of something else.  concepts are part of a language that doesn't yet exist :)
16:32:20 <qwr> the C++ templates are more macros than a part of type system
16:32:48 <fasta> sorear: are you suggesting that they should prey to get it working? Or is that some expression I don't know?
16:33:02 <fasta> pray*
16:33:08 <ddarius> fasta: sorear is acting bizarrely.
16:33:16 <int-e> how bjarne stroustrup envisions C++ concepts: http://www.research.att.com/~bs/popl06.pdf
16:34:04 <fasta> If Haskell gets associated types it will be the same as C++ with perfect concepts.
16:34:04 <int-e> sorear: none of that exists in compilers yet, I think, but even Bjarne seems to acknowledge that it'd be nice to be able to specify them :)
16:34:49 <sorear> crazy stuff like this gives me hope for epigram
16:35:06 <goltrpoat> fasta:  actually, templates give you dependent types, so it wouldn't be quite the same thing
16:35:39 <fasta> goltrpoat: type classes also give you dependent types, ask Oleg.
16:35:43 <goltrpoat> haha
16:35:54 <fasta> goltrpoat: (as in GHC, at least)
16:36:02 <goltrpoat> -nod-
16:36:42 <fasta> I find that the "advanced type hackery" isn't really practical, though.
16:36:58 * LoganCapaldo waits for the T-Shirt that says "Haskellers do it in the type system"
16:37:42 <fasta> I think Qi's approach is much easier to understand.
16:38:38 <Binkley> LoganCapaldo: there's already this one, anyway -- http://www.cafepress.com/doitmonad
16:39:24 <LoganCapaldo> Binkley: gnary
16:39:27 <LoganCapaldo> *gnarly
16:40:47 <Binkley> @yow
16:40:47 <lambdabot> I put aside my copy of "BOWLING WORLD" and think about GUN CONTROL
16:40:47 <lambdabot> legislation...
16:42:09 <fasta> sorear, int-e, ddarius: do you use the Turing completeness of the type system in Haskell?
16:43:00 <LoganCapaldo> Binkley: actually thinking about it more, I think that t-shirt would lead to too many testicle jokes at my expense
16:43:12 <Binkley> LoganCapaldo: you should have seen the "too hot for prime time" designs
16:43:14 <goltrpoat> fasta:  that statically checked linear algebra library (i forget the name/author) is probably about as far as you want to practically get with type hackery
16:45:24 <goltrpoat> speaking of epigram, last time i tried it, there was literally no documentation on it (and i never did get it to work in xemacs)
16:45:27 <goltrpoat> has that changed any?
16:45:53 <fasta> goltrpoat: you don't specify when you last used it
16:46:07 <goltrpoat> good point.  six months ago or so
16:46:35 <fasta> goltrpoat: I did try it around that time, too, but here it also didn't work.
16:46:57 <fasta> goltrpoat: Epigram is vaporware
16:47:17 <fasta> If I can't just install it with one command it doesn't exist.
16:47:38 <LoganCapaldo> Sweet, I don't exist!
16:47:48 <Binkley> hmm, has anyone ever been able to install GHC with one command? :-)
16:47:57 <fasta> (unless I am _really_ _really_ interested in it)
16:48:00 * LoganCapaldo runs around in a metaphysical euphoria
16:48:03 <fasta> Binkley: apt-get install ghc6
16:48:22 <LoganCapaldo> fasta: that's arguably two commands
16:48:30 <fasta> Binkley: and switching to root
16:48:59 <fasta> With sudo it's one command.
16:49:02 <Philippa> Binkley: point, even with the Windows installer you have to give it a path
16:49:20 <Binkley> I remember the days when installing ghc was a multi-day project
16:49:21 <Jaak> Binkley: yes. "emerge ghc"
16:49:22 <LoganCapaldo> fasta: no I'm apeaking of apt-get (1 command) and install (2 command)
16:49:35 <LoganCapaldo> since you can apt-get remove, etc.
16:49:50 <fasta> LoganCapaldo: ok, three mental steps
16:49:54 <goltrpoat> clearly we need a definition of 'command'
16:50:08 <monochrom> a command is a value of a monadic type.
16:50:23 <fasta> LoganCapaldo: name of package, installation program, instruction for installation program.
16:51:00 <fasta> OTOH, if they have on their website: do apt-get install ghc6
16:51:07 <fasta> Then it's just a copy paste.
16:51:21 <fasta> Which is one mental step + verification.
16:51:29 <fasta> Anyway, that's what I call supported.
16:51:37 <fasta> Everything else is wasting my time.
16:52:01 <LoganCapaldo> fasta: ok but I could also put on my website wget http://url && tar -zxvf file && cd dir && ./configure && make && sudo make install. and that's just a copy and paste too :)
16:52:49 <fasta> LoganCapaldo: indeed, and I would be happy with that too as long as it fits on one screen.
16:52:58 <fasta> LoganCapaldo: problem is that lots of people don't
16:53:13 <fasta> LoganCapaldo: assuming sudo is also a bad idea.
16:53:29 <monochrom> Debian users have strong convictions over apt-get vs aptitude vs synaptic vs ...  If you say "apt-get install ghc6" on your web page, fans of the other two will say "bah! this is biased!"
16:53:31 <LoganCapaldo> fasta: I know, re: sudo
16:53:35 <LoganCapaldo> was just an example
16:53:56 <fasta> LoganCapaldo: ok, I was just trying to keep you from writing such scripts in the future :)
16:54:22 <fasta> monochrom: actually I use aptitude now ;)
16:54:42 <fasta> monochrom: do you have experience with such people?
16:54:54 <fasta> monochrom: I find it hard to believe.
16:55:09 <monochrom> OK, "bah! this is biased!" never happened.
16:56:06 <monochrom> What happens is: "bah! this imposes one more mental step because I have to translate this apt-get thing to my favourite package manager and I hate apt-get so much"
16:56:21 <goltrpoat> who hates apt-get?
16:56:42 <dmwit> I do!
16:56:58 <fasta> monochrom: is this corporate stuff?
16:57:04 <dmwit> I can't get at its database, which means if something isn't in the repository, my system will likely break.
16:57:34 <dmwit> So, I guess I don't hate apt-get.
16:57:43 <dmwit> I hate incomplete, outdated repositories.
16:57:46 <monochrom> Freedom and choice is too complicated. The web page has to abstract away from particular implementations or else enumerate all gory details.  It would make everyone's life simpler to impose, say, Windows Vista on everyone.  Then the web page just needs to say "click here" and it's an installshield exe.  Zero mental steps.
16:58:04 <sorear> APT is APT is APT is APT is APT
16:58:05 <goltrpoat> dmwit:  but synaptic/aptitude are just frontends for apt
16:58:38 <dmwit> goltrpoat: Yes, I don't like those either. ;-)
16:58:42 <goltrpoat> oh
16:58:56 <monochrom> See?  Someone actually wants to use dselect.
16:58:59 <sorear> dmwit: Debian isn't grossly out of date or incomplete.
16:59:19 <fasta> sorear: cpphs in Debian is
16:59:21 <dmwit> sorear: Well, Ubuntu Dapper is.  Eventually, I'll be not lazy and update.
16:59:30 <fasta> sorear: but most popular stuff isn't
16:59:32 <dolio> goltrpoat: I've heard that aptitude does better dependency resolving than plain apt, and so should be preferred. I don't know how true that is, though.
16:59:46 <goltrpoat> ah, didn't know that
16:59:47 <dibblego> dolio, that was once the case, but not any longer
17:00:00 <dolio> dibblego: Ah.
17:00:02 <goltrpoat> my preference depends on whether or not my hand is closer to the mouse or to the keyboard
17:00:02 <sorear> I use aptitude because it's less of a pain to browse the package list.
17:00:10 <goltrpoat> -or not
17:00:16 <dibblego> dolio, the main issue was aptitude has autoremove and apt-get didn't
17:00:37 <dolio> dibblego: ah, but apt-get has it now?
17:00:42 <dibblego> dolio, right
17:01:41 <sorear> dmwit: Stable versions are usually quite out of date.  You mostly use them if a system crash would result in lawsuits. :)
17:04:54 * sorear hellos Raystm2 
17:05:10 <lispy> sorear: ya know and it's only, what, 3 years between stable releases?
17:05:20 <lispy> that's still more often than, say, windows isn't it?
17:05:40 <sorear> lispy: Nobody uses windows's programs.
17:05:41 <Pseudonym> Hell, it's more often than Debian.
17:06:03 <sorear> lispy: 3 years between kernel+libs+major system tools is fine
17:06:39 <Pseudonym> If it's being maintained in the mean time...
17:06:50 <Pseudonym> After all, what's a major release anyway?
17:06:57 <lispy> Pseudonym: hmm...debian is what i was thinking of actually...i'm pretty sure they shoot for 3 years between stable releases of the OS
17:07:00 <sorear> but Debian comes with a widely used text editor (more like 2^32 actually), windows not really.  Same for almost everything else.  Windows users rely on independantly maintained sw.
17:07:06 <gravity> lispy: No, we shoot for half that
17:07:29 <lispy> sorear: well, windows itself is what i meant
17:07:36 <gravity> And with the latest release, we actually got much closer
17:08:09 <Pseudonym> Personally, I don't care when software increases major version numbers.
17:08:18 <Pseudonym> So long as the features that I care about get added in a timely manner.
17:08:46 <sorear> IMO, having major releases is like trying to solve the sewage disposal problem using concrete plugs.
17:08:47 <fasta> sorear: say I selected alien in aptitude now, how can I get up to the listing again?
17:09:01 <sorear> fasta: i'll need more information
17:09:09 <sorear> fasta: 'selected' could mean many things
17:09:15 <sorear> (screenshot would qork)
17:09:20 <fasta> sorear: I see "alien info" in the top right corner.
17:09:26 <sorear> try 'q' if you have at least two tabs open
17:09:54 <fasta> sorear: that was it
17:09:57 <sorear> C-T: Menu  ?: Help  q: Quit  u: Update  g: Download/Install/Remove Pkgs Packages                                                             alien info                                                             alien info
17:10:01 <sorear> aptitude 0.4.4
17:10:27 <sorear> grumble, urxvt is being too clever with selections
17:11:53 <fasta> sorear: I am not sure what you meant by "tabs".
17:12:09 <lispy> YMMV, but i found aptitude confusing and apt-get and apt-cache are more my style
17:12:25 <goltrpoat> my poor laptop at home is really not handling these two ssh connections plus xterm very well.
17:12:51 <goltrpoat> im starting to think that perhaps XWin+ssh is not a viable way of uh.. doing anything.
17:13:22 <sorear> http://members.cox.net/stefanor/1181088687.png
17:13:32 <sorear> see the three bits of text at the top?
17:13:42 <sorear> goltrpoat: it's quite viable
17:14:04 <goltrpoat> im running it in 800x600, and it takes 5 seconds to resize a window :)
17:14:05 <sorear> goltrpoat: you just need to restrict yourself to clients that don't suck
17:14:12 <sorear> "it" ?
17:14:24 <goltrpoat> well.. it's xwin via putty
17:14:33 <sorear> "xwin" ?
17:14:36 <goltrpoat> i don't think there's another x server for windows that's free
17:14:41 <lispy> x reflection is very bandwidth intensive
17:14:41 <sorear> ah
17:15:09 <lispy> in fact, in terms of bandwidth, i greatly prefer rdesktop
17:15:20 <lispy> i just wish it didn't imply using a windows server
17:15:21 <sorear> i run X.org/ssh
17:15:40 <fasta> sorear: yes, it was solved when you said 'q' the first time, but what you meant by tabs in this context?
17:15:42 <sorear> it works (ed, I don't use it anymore because my main machine works now)
17:15:51 <Excedrin> there's Xming
17:16:03 <Excedrin> http://freedesktop.org/wiki/Xming
17:16:05 <lambdabot> Title: freedesktop.org - Xming
17:16:13 <sorear> fasta: can you suggest a lightweight paint program?
17:16:35 <goltrpoat> well.. i have a linux box at home, running sshd, and my main machine is windows, so i ssh in, and run xwin on the windows machine
17:16:35 <lispy> also, i think cygwin comes with an X server
17:16:42 <MarcWebe1> sorear: artrage is nice. But I don't know how lightweight it is..
17:16:46 <Binkley> yes, cygwin does come with one
17:16:47 <goltrpoat> lispy:  that'd be XWin
17:16:53 <lispy> oh, i see
17:17:30 <goltrpoat> it crawls pretty bad over LAN, but gets really bad remote
17:18:23 <fasta> sorear: inkscape
17:18:36 <Excedrin> goltrpoat: maybe try the FreeNX stuff
17:18:44 <beelsebob> inkscape is unfortunately, poo
17:18:45 <fasta> sorear: not really light-weight, but kpaint depends on too much, I guess.
17:18:57 <kolmodin> is inkscape that lightweight?
17:19:03 <goltrpoat> Excedrin:  thanks, looking at it
17:19:05 <beelsebob> inkscape is pretty heavyweight
17:19:16 <kolmodin> yeah, I'd say so too
17:19:17 <fasta> yes, it is.
17:19:21 <beelsebob> inkscape is to Illustrator as GIMP is to Potatoshop
17:19:38 <fasta> (heavy weight)
17:19:46 <beelsebob> similar, but crap
17:19:53 <fasta> sorear: xfig is probably light weight
17:20:01 <sorear> xfig is vector
17:20:15 <sorear> http://members.cox.net/stefanor/1181088687.png  -- improved using gpaint
17:20:18 <fasta> sorear: are you sure it cannot read bitmaps?
17:20:24 <sorear> nope
17:20:34 <beelsebob> most vector programs can read bitmaps
17:20:49 <beelsebob> they just create a vector object, that happens to have a bitmap texture applied
17:21:09 <Excedrin> you could try tuxpaint :)
17:21:18 <beelsebob> tbh, Illustrator ftw
17:22:01 <goltrpoat> Excedrin:  oh, it actually translates X protocol into RDP?  that's pretty cool
17:22:08 <dons> ?users
17:22:08 <lambdabot> Maximum users seen in #haskell: 336, currently: 299 (89.0%), active: 35 (11.7%)
17:22:11 <goltrpoat> er.. other way around
17:22:15 <beelsebob> ohhhh
17:22:18 * beelsebob just thought
17:22:24 <beelsebob> I have a Hat test case
17:22:29 <beelsebob> that produces PDF images easily
17:22:38 <beelsebob> why don't I write a Haskell vector graphics editor
17:22:48 <beelsebob> would be fairly simple to add on on top
17:23:38 <lispy> and what will you use as the gui library for the editor?
17:24:27 <beelsebob> dunno
17:24:32 <fasta> sorear: that is one tab?
17:24:36 <sorear> hi dons
17:24:36 <beelsebob> might be my first experience in HOC
17:24:48 <beelsebob> although gtk2hs would be better for cross platformness
17:24:50 <sorear> fasta: yes?
17:25:18 <fasta> sorear: I read the aptitude manual once, but I cannot remember "tabs".
17:25:59 <lispy> beelsebob: i want to see a gui library come to the forefront for haskell and really make a name for itself
17:26:21 <beelsebob> lispy: which GUI library?
17:26:24 <lispy> something that is easy to compile/install on each platform and looks native-ish
17:26:31 <sorear> fasta: it's not self explanatory enough? tabs are pretty ubiquitous
17:26:36 <beelsebob> yeh... see... I hate that
17:26:37 <lispy> beelsebob: i don't care as long as the features make me happy :)
17:26:43 <sorear> lispy: I hate libraries like that
17:26:53 <beelsebob> I really really don't like the cross-platform things that claim to be native-ish
17:27:00 <beelsebob> because they're never anything like native
17:27:28 <ivanm> morning everyone
17:27:36 <sorear> morning ivanm!
17:27:44 <ivanm> I can't seem to get hgl to compile this morning for some reason, even though I"ve compiled it before
17:28:02 <ivanm> its complaining about "Graphics/HGL/X11/DC.hs:47:9: Couldn't match expected type `Foreign.C.Types.CInt' against inferred type `Int'"
17:28:06 <ivanm> any ideas?
17:28:21 <Excedrin> wxWidgets is really nice in terms of appearance
17:28:32 <Excedrin> Gtk2hs is nice(er) to use imho
17:28:43 <fasta> sorear: I didn't recognize them as tabs, since I haven't seen multiple next to each other and they don't look like "tabs" in modern GUI programs, imho,
17:28:45 <beelsebob> Excedrin: wxWidgets is *awful* at appearance
17:28:51 <beelsebob> it doesn't even look native on OS X
17:28:55 <beelsebob> let alone behave in a native way
17:29:05 <Excedrin> I don't use OS X
17:29:18 <beelsebob> doesn't stop wx failing at what it's trying to do
17:29:35 <Excedrin> so... is Gtk better on OS X?
17:29:40 <beelsebob> it's better
17:29:45 <beelsebob> but a long way from perfect
17:29:48 <Excedrin> does it require X?
17:30:02 <beelsebob> I don't think so... if you use odd libraries
17:30:13 <Excedrin> my only experience with OS X made me think that the native apps are very different from X apps
17:30:25 <beelsebob> very very different
17:30:31 <beelsebob> that's why wx gets no where near
17:30:35 <beelsebob> it expects everything to be X11 like
17:30:39 <fasta> sorear: thanks
17:31:02 <Excedrin> well, I dislike the native OS X stuff, so if I used OS X, I'd prefer if everything was another X client
17:31:23 <fasta> sorear: I don't use many curses based applications.
17:31:27 <beelsebob> heh, the OS X native stuff I find 10000 times better than X11 inconsistancies
17:31:29 <chessguy_> > [(x,y) | x <- [0,1,2,3,4], y <- [0,1,2,3], 0 <= 2*x-y, 0 < 1.2*y-x]
17:31:37 <lambdabot>  [(1.0,1.0),(1.0,2.0),(2.0,2.0),(2.0,3.0),(3.0,3.0)]
17:32:17 <chessguy> @seen procyon112
17:32:17 <lambdabot> I saw procyon112 leaving #gentoo-haskell, #haskell-blah and #haskell 12m 46s ago, and .
17:32:20 <chessguy> @seen procyon
17:32:20 <lambdabot> I haven't seen procyon.
17:32:46 <lispy> and .
17:33:10 <lispy> (i learned to talk from listening to lambdabot ;)
17:33:22 <chessguy> @type and .
17:33:24 <lambdabot> parse error (possibly incorrect indentation)
17:33:58 <chessguy> @type (and .)
17:34:00 <lambdabot> forall a. (a -> [Bool]) -> a -> Bool
17:34:10 <Binkley> ?remember lispy (i learned to talk from listening to lambdabot ;)
17:34:10 <lambdabot> Done.
17:34:26 <lispy> Binkley: and .
17:34:34 <lispy> Done.
17:35:56 <byorgey> lispy> @seen lispy
17:36:10 <sorear> byorgey: you need :
17:36:18 <sorear> lambdabot: @seen lambdabot
17:36:18 <lambdabot> Yes, I'm here. I'm in #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #
17:36:18 <lambdabot> scannedinavian
17:36:25 <sorear> lambdabot> @seen lambdabot
17:36:58 <byorgey> sorear: ah, indeed.
17:37:49 <lispy> byorgey: Yes, I'm here.
17:37:56 <byorgey> lispy: oh good!
17:38:10 <chessguy> i'm not!
17:38:20 <lispy> ghc says: Use -fglasgow-exts to allow multi-parameter classes
17:40:27 <Binkley> :)
17:50:09 <pigle-z> > let ascending (x : y : ys) = if x <= y then ascending (y : ys) else False; ascending _ = True; sums n = case n of 0 -> []; _ -> [n] : [m' | n' <- [1..n - 1], m' <- map (n' :) (sums $ n - n'), ascending m'] in sums 7
17:50:10 <lambdabot>  [[7],[1,6],[1,1,5],[1,1,1,4],[1,1,1,1,3],[1,1,1,1,1,2],[1,1,1,1,1,1,1],[1,1,...
17:52:15 <beelsebob> mmm... Haskell code complete with smileys :)
17:53:15 <lispy> :t (=])
17:53:17 <lambdabot> parse error on input `='
17:53:46 <lispy> > let (=]) a b = a + b in 1 =] 2
17:53:46 <lambdabot>  Parse error
17:54:00 <lispy> i guess ] can't be used because of lists
17:54:22 <ddarius> lispy: I'm sure = is shady as well
17:54:37 <lispy> > let (===) a b = a + b in 1 === 2
17:54:39 <lambdabot>  3
17:55:08 <lispy> > let (!=) = (/=) in 1 != 2
17:55:09 <lambdabot>  True
17:55:13 <dainanaki> hey dmead, you could have just told me to use ++ instead of : for that reverse problem... that took ages to figure out
17:55:47 <lispy> > foldr (flip :) [] [1,2,3,4]
17:55:47 <lambdabot>  Couldn't match expected type `b -> b'
17:56:15 <ddarius> dainanaki: You shouldn't be using ++
17:56:25 <dainanaki> why not?
17:56:38 <ddarius> Or ideally you shouldn't, though it certainly makes the code easier.
17:56:47 <dainanaki> what's wrong with it?
17:56:48 <ddarius> Well "easier"
17:57:11 <ddarius> dainanaki: Adding a single element to the end of a list is O(n) in the length of the list.
17:57:19 <ddarius> Now you do that for each element...
17:57:41 <dainanaki> ah that makes sense
17:57:43 <byorgey> O(n^2), hooray!
17:58:02 <dainanaki> well then what would be preferable then
17:58:14 <ddarius> dainanaki: You presumably have reverse (x:xs) = reverse xs ++ [x]
17:58:20 <ddarius> @src reverse
17:58:20 <lambdabot> reverse = foldl (flip (:)) []
17:58:51 <lispy> yeah, i should have been using foldl
17:59:01 <dainanaki> right but the concept was to not use any predefined functions
17:59:15 <ddarius> dainanaki: foldl expands into accumulator recursion
17:59:43 <beelsebob> the traditional progression from reverse (x:xs) = reverse xs ++ [x] is
17:59:43 <beelsebob> > let reverse xs = reverse' xs []; reverse' [] x = x; reverse' (x:xs) a = reverse' xs x:a in reverse [1,2,3,4]
17:59:44 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
17:59:44 <lambdabot>       Expected...
17:59:46 <beelsebob> o.O
17:59:50 <beelsebob> what bob break?
18:00:10 <ddarius> beelsebob: parens
18:00:15 <beelsebob> oh yeh
18:00:34 <beelsebob> > let reverse xs = reverse' xs []; reverse' [] x = x; reverse' (x:xs) a = reverse' xs (x:a) in reverse [1,2,3,4]
18:00:35 <lambdabot>  [4,3,2,1]
18:00:43 <dainanaki> so what is accumulator recursion compared to standard?
18:01:14 <lispy> dainanaki: with accumulator recursion you accumalate the intermediate results into a paramater that you pass along
18:01:16 <beelsebob> dainanaki: well, the idea is to accumulate the result as you go go through the recursion
18:01:33 <beelsebob> instead of only being able to start constructing output when you've seen the whole list
18:01:36 <lispy> dainanaki: when you're done you just return the parameter
18:01:44 <dainanaki> ah
18:01:58 <lispy> reverse' [] x = x;
18:02:04 <lispy> x is the accumalator
18:02:10 <beelsebob> should really have called it a
18:02:13 <beelsebob> but nvm
18:02:49 <lispy> reverse' (x:xs) a = reverse' xs (x:a) <-- notice here the similarities to this and the foldl example that does flip (:)
18:02:55 <beelsebob> indeed
18:03:25 <beelsebob> the foldl version is just a realisation that the accumulator one is an instance of a general function
18:03:26 <dainanaki> aha
18:03:43 <dainanaki> i got it
18:03:52 <dainanaki> ok then
18:04:35 <lispy> flip is pretty handy
18:04:41 <beelsebob> yeh, very
18:05:01 <dainanaki> yeah i didn't know that was allowed
18:05:01 <ddarius> It's handy when it is.  I don't use it that much.
18:05:07 <lispy> ?pl \xs -> foldl (flip (:)) [] xs
18:05:07 <lambdabot> foldl (flip (:)) []
18:05:48 <lispy> dainanaki: if you were doing homework then probably it wasn't allowed
18:06:02 <lispy> your prof probably wants to you learn to walk all over again before they let you run
18:06:19 <dainanaki> well i'm learning on my own
18:06:28 <dainanaki> dmead gave me practice problems
18:06:33 <lispy> ah
18:06:43 <lispy> here is your next problem, explain the output of the following:
18:06:45 <lispy> > fix show
18:06:47 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
18:06:49 <lispy> ;)
18:06:49 <dainanaki> and i wanted to do it without predefined functions
18:07:00 <lispy> how would you define flip?
18:07:09 <dainanaki> :|
18:07:23 <dainanaki> f x y = f y x ?
18:07:39 <Cale> flip f x y = f y x
18:07:42 <dainanaki> well. i meant this
18:07:54 <dainanaki> flip f x y = f y x
18:08:04 <lispy> yeah, always check the type :)
18:08:05 <dainanaki> yeah i forgot to put flip at the front
18:08:24 <byorgey> @src flip
18:08:25 <lambdabot> flip f x y = f y x
18:08:27 <byorgey> hurrah!
18:08:44 <dainanaki> yes
18:08:55 <dainanaki> i am winner
18:09:23 <lispy> ?check \a b -> (\f x y -> f y x) (-) a b == flip (-) a (b::Int)
18:09:24 <lambdabot>  OK, passed 500 tests.
18:09:35 <ddarius> @djinn flip
18:09:35 <lambdabot> -- f cannot be realized.
18:09:53 <ddarius> @djinn (a -> b -> c) -> b -> a -> c
18:09:53 <lambdabot> f a b c = a c b
18:09:59 <lispy> dainanaki: can you also define (.) ?
18:10:22 <lispy> dainanaki: a really good way to learn haskell is to rewrite the prelude
18:11:01 <dainanaki> (.) f1 f2 = f1(f2)
18:11:09 <dainanaki> right?
18:11:11 <lispy> almost
18:11:19 <dainanaki> @src (.)
18:11:20 <lambdabot> (.) f g x = f (g x)
18:11:41 <lispy> i think you can also define it like this, (f . g) x = f (g x)
18:11:50 <dainanaki> oh i was thinking it resulted as a partially applied function
18:12:12 * ddarius could really see some Haskeller getting totally lost why (.) f g = f . g does not work for a good second.
18:12:13 <lispy> :t f g
18:12:15 <lambdabot> Not in scope: `f'
18:12:15 <lambdabot>  
18:12:15 <lambdabot> <interactive>:1:2: Not in scope: `g'
18:12:34 <lispy> :t \f g -> f g
18:12:36 <lambdabot> forall t t1. (t -> t1) -> t -> t1
18:12:47 <ddarius> :t ($)
18:12:48 <lambdabot> forall a b. (a -> b) -> a -> b
18:12:51 <ddarius> @src ($)
18:12:51 <lambdabot> f $ x = f x
18:12:53 <Cale> :t \f g -> \x -> f (g x)
18:12:55 <lambdabot> forall t t1 t2. (t1 -> t2) -> (t -> t1) -> t -> t2
18:13:32 <lispy> > sort [Nothing, Just True, Just False, Nothing]
18:13:33 <lambdabot>  [Nothing,Nothing,Just False,Just True]
18:13:47 <dainanaki> i liked discovering partially applied functions last night
18:13:49 <ddarius> @src Maybe
18:13:49 <lambdabot> data Maybe a = Nothing | Just a
18:13:59 <dainanaki> those are so handy
18:14:09 <lispy> > map (1+) [1..5]
18:14:11 <lambdabot>  [2,3,4,5,6]
18:14:25 <lispy> dainanaki: yes, and part of why flip comes in handy
18:14:28 <dainanaki> exactly
18:14:41 <dainanaki> and list comprehensions!
18:14:49 <goltrpoat> > map ($1) [(+1),(+2),(+3),(+4), (+5)]
18:14:50 <lambdabot>  [2,3,4,5,6]
18:14:51 <goltrpoat> :)
18:14:53 <dainanaki> those are greatness
18:15:22 <ddarius> > length "flip (-) 1" <= length "subtract 1"
18:15:23 <lambdabot>  True
18:15:27 <dainanaki> last night i picked up a gentle introduction after trying to go through yaht, and it was so much easier to understand
18:15:31 <lispy> > [(a,b,c) | a <- [1..13], b <- [1..13], c<-[1..13],a^2+b^2=c^2]
18:15:32 <lambdabot>  Parse error
18:15:40 <lispy> > [(a,b,c) | a <- [1..13], b <- [1..13], c<-[1..13],a^2+b^2==c^2]
18:15:42 <lambdabot>  [(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(12,5,13)]
18:15:49 <ddarius> I almost never use list comprehensions.
18:15:58 <dainanaki> yep
18:16:10 <dainanaki> i wish other languages had them
18:16:21 <ddarius> They do.
18:16:34 <dibblego> dainanaki, they do; the ones that don't invent "refactorings" instead
18:16:44 <dainanaki> well not java or c++
18:16:59 <dainanaki> afaik
18:17:25 <dainanaki> so how does error evaluate as String -> a?
18:17:29 <dibblego> dainanaki, read this web page: http://www.refactoring.com/catalog/replaceParameterWithMethod.html
18:17:32 <lambdabot> Title: Refactoring: Replace Parameter with Method, http://tinyurl.com/23zgml
18:17:36 <lispy> ?src error
18:17:36 <lambdabot> error s = throw (ErrorCall s)
18:17:51 <dibblego> dainanaki, inventing euphemisms to make up for language inferiorities is a common trend
18:17:56 <Saizan> > [(a,b,c) | a <- [1..13], b <- [1..a], c<-[1..b],a^2+b^2==c^2]
18:17:58 <lambdabot>  []
18:18:45 <lispy> > [(a,b,c) | a <- [1..b], b <- [1..c], c<-[1..13],a^2+b^2==c^2]
18:18:46 <lambdabot>   Not in scope: `c'
18:19:08 <lispy> oh well, that makes sense :)
18:19:23 <Saizan> > [(a,b,c) | a <- [1..13], b <- [1..a], c<-[1..b],c^2+b^2==a^2]
18:19:24 <lispy> dainanaki: i think tuples are really nice in haskell
18:19:24 <lambdabot>  [(5,4,3),(10,8,6),(13,12,5)]
18:19:45 <lispy> dainanaki: they make a good quick datatype when you just need it for a second
18:20:02 <dainanaki> yes
18:21:13 <dainanaki> tuples + wildcards let you get away with a lot
18:21:34 <lispy> dainanaki: so do you know how to implement fold yet?
18:21:54 <dainanaki> foldl or foldr?
18:22:05 <lispy> dainanaki: well, either and can you tell the difference? ;)
18:22:19 <ajudem_me> where can I learn how to use data types?? I need to use it but I don't know how
18:22:47 <lispy> ajudem_me: how to create them?
18:22:57 <lispy> data Foo = Bar | Baz
18:22:57 <ajudem_me> lispy... hmmm.. everything
18:22:59 <ddarius> The Gentle Introduction
18:23:19 <lispy> data Foo a b = Bar a | Baz b
18:23:19 <ajudem_me> ddarius I read it but I didn't understand
18:23:43 <lispy> ajudem_me: did you try some of the exercises?  do you have questions about them?  we're much better at helping if you have specific questions
18:24:06 <ajudem_me> no... I haven't seen exercises
18:24:10 <ajudem_me> where can I find it?
18:24:22 <dibblego> ?where yaht
18:24:22 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
18:24:40 <dainanaki> foldl is left associative with parenthesis basically, so foldl f a (b:bs) = foldl f (f a b) bs
18:24:57 <lispy> ?src foldl
18:24:57 <lambdabot> foldl f z xs = lgo z xs
18:24:57 <lambdabot>     where lgo z []     =  z
18:24:57 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
18:25:04 <lispy> way off ;) j/k
18:25:25 <lispy> what you typed looks okay to me at a chance...now i'm trying to decode what ?src returned
18:25:34 <dainanaki> idunno about right, let me think about that
18:25:49 <chessguy> @seen shapr
18:25:50 <lambdabot> I saw shapr leaving #xmonad, #haskell-blah, #haskell and #scannedinavian 1h 43m 29s ago, and .
18:25:56 <dainanaki> well i didn't do the part for an empty list
18:26:10 <lispy> yeah, but hopefully you can figure that part out
18:26:23 <lispy> (the base case is usually very important, but here i dunno...just don't forget it)
18:26:35 <lispy> anyone know why foldl is defined with that helper function?
18:26:36 <dainanaki> yeah i was showing the important section
18:26:36 <Saizan> that lgo is only to recycle the binding to f
18:26:54 <lispy> Saizan: it creates sharing?
18:27:12 <Saizan> yeah, f is shared to every invocation of lgo
18:28:43 <Saizan> however is a quite obfuscated implementation imho, especially since it should be useful for beginners..
18:28:58 <lispy> dainanaki: well, for foldl you applied f going down (think recursively)
18:28:58 <falconair> hi, I have read that functors are related to monads, however neither the types for functors, nor the types for monads mention the other ...in terms of types, how are they related?
18:28:59 <dainanaki> so foldr could be: foldr f a (b:bs) = f b (foldr f a bs)
18:29:00 <falconair> class Functor f where ..., class Monad m where ... ?
18:29:45 <lispy> dainanaki: yes, i think that's right, did you check the type?
18:29:52 <dolio> falconair: Every Monad is a Functor.
18:30:09 <Saizan> falconair: we could have class Functor m => Monad m where
18:30:10 <dainanaki> :t foldr
18:30:10 <dolio> Theoretically, you could declare it as: 'class (Functor m) => Monad m where ...'
18:30:18 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:30:21 <dainanaki> wait this is irc
18:30:28 <dibblego> s/Theoretically/in other languages, such as CAL
18:30:29 <Saizan> falconair: in particular fmap = liftM
18:30:30 <dainanaki> ?type foldr
18:30:32 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
18:30:39 <lispy> dainanaki: :t works here too :)
18:30:44 <lispy> :t 1
18:30:46 <lambdabot> forall t. (Num t) => t
18:30:56 <dainanaki> oh ok
18:30:57 <falconair> dolio: exactly, that's what i expected the signature to be ... but looking at just the class declaration, there doesn't seem to be a connection
18:31:09 <dibblego> falconair, it;s a mistake - it has been corrected in CAL
18:31:19 <dolio> dibblego: You could do it in haskell, too, but apparently some people don't want that, because they don't like writing two instances or something.
18:31:21 <falconair> what's CAL?
18:31:28 <dibblego> falconair, Haskell for Java
18:32:30 <dolio> falconair: If you notice the type of liftM...
18:32:33 <dolio> @type liftM
18:32:33 <falconair> ok, so it is a known mistake then...heh,  i discovered something on my own :)
18:32:35 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
18:32:41 <dainanaki> i wish there were more exercises on haskell.org to practice on
18:32:53 <dolio> falconair: liftM is fmap, only with a Monad constraint rather than a Functor constraint.
18:33:31 <lispy> dainanaki: always keep in mind: get the types correct.  When the types are wrong, there is little or no chance that the definition is correct, but if the type is correct there is a chance you have the write definition
18:33:52 <lispy> er, last "write" should be right
18:34:03 <dainanaki> thanks for that advice
18:34:16 <dainanaki> i got the type right i believe
18:34:17 <lispy> np, talk is cheap ;)
18:34:22 <lispy> i think you did too
18:34:28 <lispy> the def'n looked right
18:34:35 <lispy> how about map then?
18:34:55 <lispy> if you have map/foldl/foldr down then you're ready to really start manipulating lists
18:35:31 <dainanaki> map f [] = []; map f (x:xs) = (f x) ++ map xs
18:35:31 <falconair> ok, now the applicative functor looks very similar to functor: (<*>) :: f (a -> b) -> f a -> f b vs fmap :: (a -> b) -> f a -> f b  ... i have read the right paper but I don't get the feel for why AF has an 'f' in the first argument
18:35:33 <lispy> and then that's when the learning gets good...you could, for instance, take a look at the list monad :)
18:35:44 <Cale> f x : map f xs
18:35:54 <Cale> map f = foldr ((:) . f) []
18:35:54 <lispy> :t (++)
18:35:56 <lambdabot> forall a. [a] -> [a] -> [a]
18:36:15 <lispy> dainanaki: that definition shouldn't type check
18:36:25 <dainanaki> oops
18:36:25 <dainanaki> mistake!
18:36:30 <Saizan> falconair: have you used ap?
18:36:34 <dainanaki> yeah that was wrong
18:36:34 <lispy> :t \f (x:xs) -> (f x) ++ map xs
18:36:36 <lambdabot>     Couldn't match expected type `a -> b' against inferred type `[t]'
18:36:36 <lambdabot>     In the first argument of `map', namely `xs'
18:36:52 <lispy> :t \f (x:xs) -> (f x) ++ map f xs
18:36:53 <dainanaki> i've been kind of obsessed with concatenating...
18:36:54 <lambdabot>     Occurs check: cannot construct the infinite type: a = [a]
18:36:54 <lambdabot>       Expected type: t -> a
18:37:04 <dainanaki> that should have been cons
18:37:15 <lispy> dainanaki: well, (++) can be really slow performance wise
18:37:15 <falconair> Saizan: no, i'd like to understand it better since it is mentioned in relation to dataflow programming
18:38:03 <dainanaki> i get that impression, i just was boggled at how else to solve reverse last night so it got stuck in my mind
18:38:05 <dolio> falconair: Note: liftA is also fmap.
18:38:10 <lispy> dainanaki: but also, do you know how to define (++)?  then you'd see why it's slow
18:38:13 <Cale> xs ++ ys takes at most O(length xs) time
18:38:23 <chessguy> @src (++)
18:38:23 <lambdabot> (++) []     ys = ys
18:38:23 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
18:38:39 <Cale> It's when you're repeatedly adding things to the end of a list that ++ is slow.
18:39:17 <dainanaki> yes because it has to redo it a bunch
18:39:22 <Cale> right :)
18:39:25 <chessguy> Cale, and only for arbitrarily large lists, too
18:39:44 <lispy> Cale: well, compared to some languages even O(length xs) is slow.  append could be O(1) given a list where you alway have a pointer to the end
18:39:57 <dainanaki> i wish that indexing lists was easier
18:40:00 <bd_> lispy: But then you don't have a pure data structure :)
18:40:00 <falconair> dolio: hadn't noticed that...but vaguely makes sense
18:40:05 <Cale> dainanaki: xs !! 5 ?
18:40:05 <bd_> lispy: Data.Seq does it in a pure way
18:40:11 <Cale> > [1..10] !! 5
18:40:13 <lambdabot>  6
18:40:13 <dolio> falconair: So you can have a further hierarchy.
18:40:18 <bd_> with O(min(lg x, lg y)) (iirc) append
18:40:23 <dainanaki> really?
18:40:24 <dolio> falconair: 'class (Functor a) => Applicative a where ...'
18:40:27 <dainanaki> i didn't know about that one, thanks Cale
18:40:41 <dolio> falconair: 'class (Applicative m) => Monad m where ...'
18:40:44 <Cale> Data.Sequence, even though the data type is for some reason called Seq
18:40:55 <lispy> really?
18:41:00 <lispy> i would confuse with seq
18:41:01 <dolio> falconair: And, 'pure' from Applicative is 'return' from Monad.
18:41:02 <lispy> :t seq
18:41:04 <lambdabot> forall a t. a -> t -> t
18:41:20 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
18:41:22 <lambdabot> http://tinyurl.com/um3d4
18:41:45 <thoughtpolice> what's exactly the difference between a newtype and just 'data'? i generally notice people using newtype for the definition of things like monads transformers.
18:41:46 <dmwit> ?seen pigle-z
18:41:46 <lambdabot> I saw pigle-z leaving #haskell 50m 29s ago, and .
18:42:14 <lispy> thoughtpolice: well, it makes sense there because you can use 'newtype deriving' to get many things for free
18:42:22 <lispy> thoughtpolice: and yet still get a new type
18:42:23 <Saizan> thoughtpolice: newtype is almost optimized away, also
18:42:23 <falconair> dolio: right, i understood return being the same as pure ... I don't quite understand the 'f' in  f(a->b) in the definition of <*> (applicative)
18:42:46 <Cale> thoughtpolice: The big difference in that case is that you can derive any class that's defined on the old type.
18:42:54 <lispy> thoughtpolice: basically a newtype just creates a new type without doing anything else really
18:42:56 <Cale> For instance, you can derive Monad, Functor, and so on.
18:43:08 <chessguy> @type sequence
18:43:10 <lambdabot>     Ambiguous occurrence `sequence'
18:43:10 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
18:43:10 <falconair> dolio: i should clarify, why is AF more suited for reactive programming than simple functors+monads?  it seems AF is a couple of simple translations away from monads and functors anyway
18:43:18 <chessguy> @type Control.Monad.sequence
18:43:20 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
18:43:31 <lispy> thoughtpolice: data on the other hand, creates a type and some storage for some values
18:43:39 <Cale> falconair: There are applicative functors which are not monads.
18:43:44 <lispy> thoughtpolice: it creates a 'box' essentially
18:43:56 <chessguy> @quote repeatM
18:43:56 <lambdabot> No quotes match. Do you think like you type?
18:43:57 <Cale> falconair: Similarly, there are arrows which are not monads.
18:43:58 <thoughtpolice> hm.
18:44:38 <chessguy> @type repeatM
18:44:40 <lambdabot> Not in scope: `repeatM'
18:44:40 <falconair> Cale: I see, hence the fact that 'AF' generalizes monads ... i have a better understanding now, thanks!
18:44:52 <lispy> thoughtpolice: so, let's say you wanted to use Int for the size of a window but you want width and height to have different types, you could use newtype to create Height and Width as types but have them really jsut be Ints
18:45:21 <thoughtpolice> it's like an alias, and in the case of a transformer you can use newtype-deriving to derive from Monad and Functor, but it still just be like an 'alias'
18:45:28 <lispy> thoughtpolice: then it would just be the type checker that knows about width and height, no run-time machinery would be needed
18:45:46 <lispy> thoughtpolice: not like an alias you'd get from typedef in C++ though
18:46:08 <chessguy> @type \n -> flip mapM \_ -> [1..n]
18:46:09 <lambdabot> parse error on input `\'
18:46:12 <ddarius> A newtype doesn't exist at runtime.  It is purely a figment of the typecheckers imagination.
18:46:21 <chessguy> @type \n -> flip mapM $ \_ -> [1..n]
18:46:22 <lambdabot>     Ambiguous occurrence `mapM'
18:46:23 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
18:46:27 <Cale> thoughtpolice: It's different from type though, in that it's a genuinely new type for the typechecker, which doesn't unify with the old type.
18:47:06 <Cale> thoughtpolice: and you have a tag (the data constructor for the newtype) which acts like "permissions" to create values of the new type.
18:47:09 <thoughtpolice> so newtype basically just creates a 'fabricated' type that doesn't actually exist in the typical sense; yet you can derive things from classes like Monad or Functor?
18:47:43 <Cale> It creates a new type which has the same runtime implementation as the old one, and you can derive (almost) any class that the old type supported.
18:48:01 <lispy> thoughtpolice: the type really exists, what you didn't create are new values...you recycle the values of another type
18:48:27 <Cale> Compilation boils away the data constructor for the newtype, it's only there for typechecking purposes.
18:48:58 <thoughtpolice> :/
18:49:10 <thoughtpolice> i'm having a hard time getting this but I guess I'll just have to experiment with it.
18:49:14 <lispy> thoughtpolice: going back to my window example, if you newtype'd Height and Width even though they're both Int under the hood, you couldn't use a Width where a Height is expected and vice versa
18:49:15 <Cale> Well, for example...
18:49:24 <Cale> newtype Dollars = Dollars Int
18:49:33 <Cale>    deriving (Eq, Ord, Show, Num)
18:49:58 <Cale> Eq, Ord and Show will use the ordinary mechanism for deriving
18:50:23 <Cale> the instance for Num may even directly share the dictionary for the old type (Int)
18:50:53 <Cale> At runtime, values of type Dollars are just values of type Int, but in your program, you're not allowed to confuse the two.
18:51:00 <lispy> yes, although dictionaries aren't the only way to implement type classes (supposedly)
18:51:04 <Cale> Right.
18:51:27 <Cale> I'm specifically referring to the GHC implementation, since I think it's the only thing which currently supports newtype-deriving anyway.
18:51:42 <lispy> i see
18:51:49 <Cale> So if you do (Dollars 5) + (7 :: Int), that's a type error.
18:51:54 <lispy> newtype-deriving is extremely handy though
18:52:13 <chessguy> @type replicateM
18:52:15 <lambdabot> forall (m :: * -> *) a. (Monad m) => Int -> m a -> m [a]
18:52:17 <Cale> and usually easy to implement -- we can hope someone implements it for hugs :)
18:52:22 <lispy> even though Dollars 5 is no more costly at runtime than 7 :: Int
18:52:26 <thoughtpolice> so a newtype can basically be defined as just about anything (Int, String, StateT s IO (), etc. etc.), only you couldn't directly use say, StateT s IO () where it would be expecting a, say, SpecialNewtype (or whatever you defined it as)
18:52:36 <Cale> thoughtpolice: right
18:52:55 <thoughtpolice> it's basically just a method to make sure your types are more sound a logically a bit more 'seperated'?
18:53:01 <Cale> thoughtpolice: One advantage of this is that you can view the data constructor tag as being permissions to construct values of that type
18:53:04 <Cale> yeah
18:53:29 <Cale> By not exporting the data constructor from the module you define the newtype in, you restrict construction of values of the newtype to that module.
18:53:35 <lispy> obviously anything in the same module can construct values directly, but you don't have to export the construct
18:53:37 <thoughtpolice> I mean, i.e. if you have f with type Int -> Int -> Int, you could use a newtype and more logically define that as Height -> Width -> Int
18:53:42 <Cale> So you can enforce additional constraints.
18:54:09 * lispy expects the Natural numbers example to naturaly come up next ;)
18:54:26 <lispy> thoughtpolice: yes you could do that
18:54:28 <Cale> Yeah, and it would check that what you passed to f was really a Height and a Width and not just two Widths.
18:54:54 <lispy> now, to be fair, you could do this with data types too
18:55:02 <lispy> data Width = W Int
18:55:22 <thoughtpolice> newtype is basically a way to enforce a little more strict typechecking in the basic sense?
18:55:27 <Cale> yeah
18:55:29 <thoughtpolice> i mean, is that basically the bottom line
18:55:31 <lispy> but, there are reasons why you might not want to use data.  If you have many Widths, the newtype will be more efficient
18:55:33 <Cale> exactly
18:55:59 <Cale> If you want, you can think of newtypes as just being equivalent to datatypes with just a single constructor that has a single parameter.
18:56:10 <Cale> However, there are subtle differences in semantics.
18:56:12 <thoughtpolice> lispy: since you're creating a 'box' rather than just a quick 'typechecked alias'
18:56:19 <Cale> (with regard to undefined values)
18:56:20 <lispy> thoughtpolice: percisely
18:56:33 * lispy can't type
18:57:21 <thoughtpolice> and newtype deriving is basically a way to create a 'typechecked alias' (like creating a newtype based on a monad transformer) but able to derive things from functor or monad?
18:57:47 <thoughtpolice> so you're basically getting typechecking + a type with already derived functions from the get-go
18:57:51 <lispy> yeah, you're just borrowing their instance definitions for your newtype
18:58:09 <lispy> thoughtpolice: right, there is an interpreter example that does this, i'll find the link
18:58:12 <Cale> and you're allowed not to derive everything
18:58:16 <lispy> it's quite illustrative to read it
18:58:18 <thoughtpolice> well of course.
18:58:20 <Cale> so you can redefine some classes if you want
18:58:30 <Cale> which is in contrast to using 'type'
18:59:05 <lispy> thoughtpolice: i think you'll find this read to be very informative: http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
18:59:07 <lambdabot> Title: Monad Transformers Step by Step
18:59:37 <thoughtpolice> lispy: thanks
18:59:41 <lispy> yw
18:59:50 <lispy> it should be standard reading material here ;)
19:00:19 <Cale> http://cale.yi.org/index.php/How_To_Use_Monad_Transformers -- I also wrote this in order to explain why it's a good idea to do that newtype wrapping.
19:00:21 <lambdabot> Title: How To Use Monad Transformers - CaleWiki
19:00:38 <thoughtpolice> Cale: that's the article I was reading ;)
19:00:43 <Cale> :)
19:00:45 <lispy> hah, awesome
19:00:55 <lispy> Cale++
19:01:44 <chessguy> bah, that Cale guy doesn't know anything about haskell :)
19:05:06 <chessguy> @paste
19:05:06 <lambdabot> Haskell pastebin: http://hpaste.org/new
19:05:50 <ed1t> we got a pastebin now!
19:08:02 <chessguy> we've had a pastebin for a long time :)
19:08:50 <ed1t> ooo i just noticed it
19:32:43 <Binkley> ?quote
19:32:43 <lambdabot> cypherx says: Oh god, C++ is like a lamprey in my urethra.
19:32:59 <dainanaki> why did everyone leave like that???
19:33:25 <emu> i scared them away
19:35:46 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/187
19:36:27 <sorear> re.
19:36:38 <int80_h> ControlMonad doesn't export forM in ghc 6.4.2. how would I be able to find where forM lives?
19:36:57 <sorear> Ask yourself?
19:37:03 <int80_h> I mean, Control.Monad
19:37:03 <ajudem_me> can you explain how can I do this?
19:37:17 <ivanm> ajudem_me: ummm.... why would you?
19:37:20 <sorear> int80_h: You just said where it is when it exists.
19:37:25 <ivanm> AFAIK, in haskell, you don't use iterators, etc
19:37:28 <sorear> int80_h: So just read the scrollback.
19:37:30 <ivanm> just map, folds, etc
19:37:36 <sorear> int80_h: Your question makes no sense.
19:37:42 <ajudem_me> ivanm, how's that?
19:38:02 <dmwit> int80_h: forM doesn't exist in 6.4, but it's just forM = flip mapM
19:38:11 <dmwit> So, add a line if you really want it.
19:38:12 <int80_h> cool
19:38:13 <dmwit> Why do you ask?
19:38:19 <ajudem_me> ivanm I'm doing a compiler, I've to track this stuff
19:38:21 <int80_h> best thing for me to do then is update ghc
19:38:26 <int80_h> thanks
19:38:30 <ivanm> ajudem_me: *shrug* don't know for a compiler
19:38:31 <ivanm> sorry
19:38:58 <ivanm> though maybe asking people directly instead of putting messages on hpaste would be a better idea? hpaste is more for code chunks...
19:39:39 <dmwit> ajudem_me: Can you just use a sum type?
19:41:35 <ajudem_me> ??
19:41:48 <dmwit> I'll annotate your paste.
19:43:53 <hpaste>  dmwit annotated "(no title)" with "dmwit :: English -> Haskell" at http://hpaste.org/187#a1
19:44:19 <dmwit> ajudem_me: Although I'm not so sure the given structures are really what you want for any real project.
19:44:23 <dmwit> What are you really trying to do?
19:44:31 <dmwit> Has this structure been assigned to you?
19:46:16 <dmwit> ajudem_me: Have you ever studied compiler design at all?
20:09:29 <lispy> sure looks like homework
20:13:25 <mrsolo> yea
20:13:30 <mrsolo> hey but in haskell!
20:14:54 <ed1t> hw in haskell is a good thing!
20:18:08 <falconair> i just heard a google talk by Linux Trovalds on benefits of distributed source control GIT ... is that what makes darcs special?  Is it distributed?
20:18:22 <sorear> darcs is distributed
20:18:56 <ivanm> and is written and designed by a physicist :p
20:20:09 <Korollary> and it's named better
20:20:36 <sjanssen> and I know how to use it
20:20:58 <dmwit> But its name is worse.
20:20:58 <falconair> sorear: I just always heard that darcs is great, never understood why...Linux made a forceful and convincing argument
20:21:05 <dmwit> It's all under one hand on the keyboard.
20:21:27 <sjanssen> falconair: Linus
20:21:59 <hitesh> sjanssen: maybe his Linux distro told him what to use
20:21:59 <falconair> oops, sorry.  A typo, I assure you :)
20:22:16 <geezusfreeek> i'm thinking about testing my chops by attempting to make distributed STM (over a network), but i figure it would be best if i make sure i'm not duplicating effort hereâ¦ anybody know if i would be?
20:22:20 <sjanssen> hitesh: then I'd expect GNU/Linus
20:22:21 <sjanssen> :)
20:22:26 <hitesh> :)
20:23:15 <sorear> geezusfreeek: you might want to hold off a few year
20:23:25 <sorear> geezusfreeek: that's *excellent* PhD material
20:23:30 <geezusfreeek> ha
20:23:42 <dmead> geezusfreeek, just pray for it and maybe it'll appear =/
20:23:46 <dmead> :)
20:26:13 <ivanm> dmwit: did ajudem_me ever get back to you on that annotation you did for him?
20:26:22 <dmwit> no =/
20:26:29 <dmwit> It's a very strange layout.
20:26:35 <dmwit> Especially if it is for a homework.
20:26:38 <ivanm> yeah
20:36:31 <Pseudonym> geezusfreeek: I vaguely remember a paper from the early 90s which had a similar thing.
20:36:44 <Pseudonym> But it used locks, not STM.
20:37:17 <chessguy> @pl \s -> 'c':s
20:37:17 <lambdabot> ('c' :)
20:38:07 <chessguy> @pl \c -> c:"foo"
20:38:07 <lambdabot> (: "foo")
20:40:52 <TomMD> @where com
20:40:52 <lambdabot> I know nothing about com.
20:41:36 <TomMD> Does anyone know about microsoft com libraries for Haskell
20:44:14 <hpaste>  hitesh pasted "filter by constructor?" at http://hpaste.org/188
20:44:51 <hitesh> can someone tell me how to improve this code?  http://hpaste.org/188
20:45:13 <hitesh> how can I avoid defining functions like isA ?
20:47:12 <lispy> TomMD: recently there was an updated comlib
20:47:16 <lispy> ?where comlib
20:47:16 <lambdabot> I know nothing about comlib.
20:48:01 <lispy> TomMD: http://www.haskell.org/pipermail/haskell/2006-September/018445.html
20:48:03 <lambdabot> Title: [Haskell] Re: H/Direct (HaskellDirect) still maintained?, http://tinyurl.com/yphz2j
20:48:09 <lispy> ?help where
20:48:09 <lambdabot> where <key>. Return element associated with key
20:48:18 <lispy> how do i set a where key again?
20:48:27 <Korollary> where+ I think
20:48:32 <lispy> ah right
20:48:45 <lispy> ?where+ comlib http://darcs.haskell.org/vshaskell/comlib/
20:48:45 <lambdabot> Done.
20:48:45 <ivanm> hitesh: you could have an inner function maybe.... aprat from that, no clue sorry
20:48:54 <Korollary> hitesh: Why do you keep needing functions like that anyway?
20:49:10 <TomMD> lispy: thanks
20:49:32 <lispy> TomMD: good luck!
20:50:58 <TomMD> Huh, that's not a proper darcs repo! wget it is.
20:51:58 <hitesh> Korollary: Good question.  But let's say I wanted a count of how many As were in some list.
20:52:57 <Korollary> hitesh: then you can't avoid it. You'd normally define such functions where needed instead of the top level.
20:55:02 <hitesh> Korollary: actually your question is making me think a little more.  In this case I'm thinking of As and Bs and Cs as all having an is_a relationship with datatype E ... is that wrong?
20:56:14 <hpaste>  dmwit annotated "filter by constructor?" with "list comprehensions" at http://hpaste.org/188#a1
20:56:28 <Korollary> hitesh: Well, A & B are E's alternative constructors. So, they are related but I don't know what you are after.
20:58:10 <timthelion> um, is there some function other than getArgs. it seems that getArgs sends the arg string through words. well anyway, I can't seem to get newline information out of that array which makes it hard to deal with the output of ls -c1
20:58:26 <mauke> there is no arg string
20:58:27 <timthelion> which lists files 1 per line
20:58:36 <mauke> program arguments are a list of strings
20:58:37 <timthelion> so how do I get the list of lines?
20:58:43 <mauke> what lines?
20:58:54 <dmwit> timthelion: Maybe you are thinking of getContents?
20:58:59 <timthelion> well the arguments I'm giving it are a list of lines.
20:59:09 <mauke> I'd like to see that
20:59:17 <timthelion> I want that list as an array of lines
20:59:24 <Korollary> timthelion: you may want to quote your args in the shell
20:59:46 <timthelion> Korollary: thanks
21:00:12 <hitesh> dmwit: thanks for the code!  I just learned a new idiom
21:00:13 <timthelion> now is there a function that doesn't bork the string? or is the string borked by the shell?
21:00:27 <mauke> there is no string
21:00:31 <dmwit> hitesh: Cheers!
21:00:49 <timthelion> mauke: I'm not buying that.
21:01:00 <Korollary> timthelion: the shell splits the args into words unless you quote them
21:01:20 <timthelion> mauke: I have a string. "program-name arguments" everything after program-name is sent to the program
21:01:28 <mauke> no
21:01:31 <mauke> the underlying function is execve(const char *, char *const *, char *const *)
21:01:33 <timthelion> ok
21:01:42 <timthelion> that's what I thought might be the case
21:01:46 <bos> timthelion: are you using unix or windows?
21:01:47 <mauke> that's C speak for String -> [String] -> [String] -> IO Int
21:01:52 <timthelion> in windows it just gives the program a Char*
21:02:02 <timthelion> bos I'm using linux
21:02:39 <bos> ok. windows's argument parsing rules and the interaction with the command shell are really bizarre.
21:02:40 <dmwit> timthelion: In what language have you seen the behavior you're asking for?
21:02:50 <dmwit> (I'm just curious.)
21:03:01 <sorear> timthelion: ping
21:03:03 <timthelion> dmwit: I used to code C on windows. and the args are passed as a strait char*
21:03:08 <timthelion> sorear: ping
21:03:14 <sorear> timthelion: we'd like to speak to you on #xmonad
21:03:16 <mauke> that's because windows is broken
21:03:35 <timthelion> mauke: nothing broken about that
21:03:43 <timthelion> sorear: ok
21:03:48 <Korollary> C's main is char**.
21:03:50 <timthelion> sorear: am I in trouble?
21:03:51 <mauke> yes, there is
21:03:59 <dmwit> timthelion: Uh, no?  I thought it was int main (int argc, char **argv) // same type, basically
21:04:08 <sorear> timthelion: not exactly...
21:04:15 <timthelion> dmwit: that's C++
21:04:22 <dmwit> ...no it's not
21:04:23 <mauke> timthelion: wtf?
21:04:46 <mauke> dmwit: the C library parses your char * into a list of strings, then calls main
21:04:59 <dmwit> huh
21:05:04 <mauke> dmwit: so if you use a different C runtime, you get different command line parsing
21:05:11 <dmwit> =((
21:05:55 <mauke> IIRC there are several mutually incompatible argument parsers
21:09:25 <Jaggederest> ok, I set out to build some tools for TSP stuff
21:09:31 <Jaggederest> http://hpaste.org/189
21:09:55 <Jaggederest> anyone mind telling me if I did anything right? :)
21:16:49 <Cale> Jaggederest: one thing to consider is that (length coords) is going to get computed (length coords) times in mkmatrix
21:17:14 <dmwit> Jaggederest: mkmatrix coords = map mkrow coords -- don't explicitly use indices unless you really need them
21:17:37 <Cale> er, that's not quite the same :)
21:17:49 <dmwit> Well, he only uses mkmatrix 0, so... =)
21:18:01 <Cale> no
21:18:01 <weitzman> falconair: Are you still around?
21:18:06 <Cale> look at the recursive call
21:18:15 <dmwit> mmm
21:18:28 <falconair> weitzman: yup
21:18:31 <Cale> I think what is really meant is  mkmatrix coords = [[distance x y | y <- coords] | x <- coords]
21:19:04 <Cale> Let me check if that's right :)
21:20:14 <Cale> yeah
21:20:33 <weitzman> falconair: For what it's worth, I think Linus didn't approach the problem of SCM very creatively. You might find it interesting to check out Vesta  (http://www.vestasys.org/) or TeamCity (http://www.jetbrains.com/teamcity/) to see some really neat benefits you can get from a more centralized system
21:20:35 <lambdabot> Title: Vesta Configuration Management System
21:20:40 <Cale> basically, you should always try to avoid indexing into lists
21:20:48 <Cale> unless you're only doing it once or something
21:21:42 <dmwit> Jaggederest: The usual pattern for tourlength is something like
21:22:06 <falconair> weitzman: thanks, i'll check it out.  I'm not really in the market for a new SCM...just thought it was an interesting take on a subject I never thought much about
21:22:16 <dibblego> weitzman, I use TeamCity with subversion; I'll be using it with git soon
21:22:17 <dmwit> tourlength matrix (x:y:rest) = ... -- head tour -> x, tour !! 1 -> y, tail tour -> (y:rest)
21:22:35 <weitzman> falconair: I'm not selling any SCMs, I'm just pointing to some stuff with features that might surprise you
21:22:46 <weitzman> Vesta, for example, has constant-time checkout
21:22:48 <dibblego> I don't think TeamCity refutes his position that distributed is better (which it is, since it is merely a generalisation of centralised)
21:22:52 <weitzman> Check-in, rather
21:22:57 <weitzman> Wait, check-out
21:23:05 <dmwit> Jaggederest: And similar pattern checks for shorter tours, of course.
21:23:17 <weitzman> I'm not using either of those as a refutation
21:23:23 <weitzman> He made some statements I disagree with, though
21:23:23 <falconair> weitzman: didn't mean to imply you were :)  I'm checking out your links
21:23:34 <dibblego> what statements?
21:23:45 <weitzman> Like that a centralized system isn't good for work across locations unless you have a private internet backbone
21:24:02 <weitzman> Vesta supports caching servers on-location, I believe
21:24:06 <weitzman> At least, it could
21:24:13 <dibblego> a centralised system cannot be better than distributed by its very own definition - that is a specialised type of distributed system
21:24:36 <Cale> > let distance x y = sqrt (x^2 + y^2); coords = [(0,1), (1,2), (2,3), (2,4), (0,6)] in liftM2 distance coords coords
21:24:39 <lambdabot>   add an instance declaration for (Floating (t, t1))
21:24:41 <dibblego> the inverse is not true - you need only look at SVK to see what happens when you try
21:24:46 <weitzman> By centralized I mean that everyone agrees who is in charge
21:24:49 <Cale> er, oh
21:24:57 <weitzman> Also, somebody pays for a nice server or 10
21:25:20 <Cale> > let distance (x1,y1) (x2,y2) = sqrt ((x1-x2)^2 + (y1-y2)^2); coords = [(0,1), (1,2), (2,3), (2,4), (0,6)] in liftM2 distance coords coords
21:25:22 <lambdabot>  [0.0,1.4142135623730951,2.8284271247461903,3.605551275463989,5.0,1.414213562...
21:25:27 <dibblego> so really, it has nothing to do with software
21:25:48 <dibblego> I have seen people in here complain that Haskell doesn't "do imperative stuff very well"
21:26:00 <dibblego> the response is of course, "just put everything in the IO monad"
21:26:17 <dmwit> Jaggederest: You may also be interested in the structure of (zip x (tail x))... ;-)
21:26:17 <dibblego> Haskell is a generalisation of "imperative stuff" in that sense
21:26:29 <Korollary> or the ST monad
21:26:31 <dibblego> is there a benefit to "not putting everything in the IO monad"? of course
21:26:41 <dibblego> but not absolutely always
21:26:47 <weitzman> I wouldn't say "well", and I hope I didn't. I believe I said that I don't find imperative Haskell very easy to write or elegant to read compared to a language desigend for imperative coding
21:27:02 <dibblego> oh, I didn't even mean to suggest it was you
21:27:14 <weitzman> Ah, well we did have that argument a few days ago :)
21:27:42 <dibblego> writing "imperative code in Haskell" is exactly as it appears in imperative languages
21:28:01 <dmwit> Jaggederest: Over all, though, you're solving an interesting problem, and you did it in a fairly nice functional way.  Good work!
21:28:08 <dibblego> yeah, I just forgot :)
21:38:48 <hpaste>  Cale annotated "(no title)" with "using an array, cleaned up a bit" at http://hpaste.org/189#a1
21:40:35 <skew> hello #haskell
21:41:00 <Cale> Jaggederest: If you want, you can see there how I'd probably write it :)
21:43:00 <Cale> Mostly it's just applying idioms in order to remove the explicit recursion. I also replaced the list of lists with an array because of the way that it's being accessed. (xs !! n) takes n steps to compute, and while in this case, the n is fairly small, it's generally better to use an array in cases where you have lots of indexing.
21:45:54 <ivanm> Cale: in that annotation, wouldn't it be better to have zipWith (matrix !) instead of map (matrix !) . zip ?
21:47:15 <Cale> (matrix !) needs a pair
21:47:32 <Cale> I suppose you could curry it
21:47:49 <Cale> zipWith (curry (matrix!)) tour (tail tour)
21:48:00 <ivanm> ahhh, k
21:49:03 <ivanm> I thought you were just doing the distance for each one (and that matrix = distance) :s
21:49:47 <Cale> I suppose you could just do that, but I assume the intention is to retain the distance calculations rather than doing them over and over.
21:50:14 <Jaggederest> wow I got distracted
21:50:21 <Cale> hehe
21:50:25 <Jaggederest> holy reams of feedback batman
21:50:29 <Cale> hehe
21:50:44 <Cale> Yeah, we've been discussing your code for a while :)
21:51:25 <ivanm> Cale: *nod*
21:52:14 <Cale> The mildly ironic thing about the original version is that doing the lookups in the matrix as a list of lists is probably more expensive than just recomputing the distance.
21:52:24 <skew> you might actually be beter off just redoing the calculations
21:52:49 <skew> especially if this is part of some TSP algorithm that's just considering local changes to paths
21:53:11 <Cale> yeah
21:53:35 <skew> recalculating from cached point coordinates much better than hitting main memory for a table
21:55:12 <skew> ooh, "race" http://www.dcs.st-and.ac.uk/~eb/Partial/partial.v
21:55:28 <Jaggederest> yeah it's a transposition of purely imperative code
21:55:31 <skew> seems like something you ought to be able to define in Haskell somehow
21:55:41 <Jaggederest> so it's not very nice right now
21:56:34 <skew> hmm, maybe not quite. but I would like peano addition such that plus (S _|_) _|_ = plus _|_ (S _|_) = S (plus _|_ _|_)
21:57:55 <Jaggederest> yeah I think I will swap out the memoization through the matrix.
22:10:24 <falconair> on page 227 of "Haskell School of Expression," the definition of "integral" has the following line:  integral (Behavior fb) = Behavior (\uts@(us,t:ts)-> 0:loop t 0 ts (fb uts)) where loop ...
22:12:09 <falconair> i don't quite understand it, what do the '@' and '->' symbols mean?
22:13:25 <dolio> > let f xs@(h:t) = h : xs in f [1..4]
22:13:25 <falconair> (i've seen '->' in function type, but not in the body)
22:13:26 <lambdabot>  [1,1,2,3,4]
22:13:49 <weitzman> > (\x -> x + 1) 1
22:13:50 <lambdabot>  2
22:14:47 <hpaste>  (anonymous) annotated "(no title)" with "(no title)" at http://hpaste.org/189#a2
22:15:15 <Jaggederest> that's much nicer
22:15:30 <Jaggederest> though I borked the indentation :)
22:15:31 <falconair> yikes, i was just being stupid with '->' ,  i guess it got lost in rest of the expression ... i still didn't quite get @
22:15:54 <weitzman> @ does simultanious pattern matching on the same value
22:16:04 <weitzman> Sorta
22:16:16 <weitzman> Except I bet it just lets the first part be a name
22:16:45 <dolio> > let f (x:xs)@(y:ys) = x:ys in f [1..4] -- test
22:16:45 <lambdabot>  Parse error
22:16:46 <weitzman> > (\(a:b:_)@(c:d:_) -> (a,d)) [1,2,3]
22:16:46 <lambdabot>  Parse error
22:16:49 <weitzman> yeah
22:17:27 <weitzman> So it's just a shorthand to avoid needing a separate "case of"
22:18:00 <dolio> Or reconstructing.
22:18:18 <falconair> ok, thanks weitzman, dolio
22:22:19 <Jaggederest> here's a question for you: what's an efficient way to swap two random elements of a list?
22:22:58 <dolio> Hmm...
22:23:33 <Jaggederest> eg [1, 2, 3] => [2, 1, 3]
22:24:25 * Jaggederest searches hoogle for 'permut'
22:25:13 <Jaggederest> no dice... (pun unintentional!)
22:26:24 <jcreigh> well, a list isn't good at random access, so it shouldn't shock anybody that there's no quick way to swap two arbitrary elements.
22:27:26 <Jaggederest> no, of course not.
22:35:04 <Jaggederest> hmm, so random numbers happen in IO because they're nondeterministic. That makes a lot of sense now that I think about it
22:39:18 <dolio> @paste
22:39:18 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:40:50 <hpaste>  dolio pasted "swap" at http://hpaste.org/190
22:45:33 <hpaste>  dolio annotated "swap" with "New and improved." at http://hpaste.org/190#a1
22:46:34 <dolio> Jaggederest: ^^^
22:48:30 <dolio> I guess the first one will work on infinite lists, too, but it won't quit early, and if you manage to overflow the Int, it will swap more than just the two elements.
22:51:19 <quicksilver> Jaggederest: you can however have deterministic random numbers outside of IO if you like
23:02:30 <dmead> gawd.
23:02:36 <dmead> so many channels are super idle
23:05:37 <sorear> @list-all
23:05:37 <lambdabot> activity provides: activity
23:05:37 <lambdabot> babel provides: babel
23:05:37 <lambdabot> base has no visible commands
23:05:37 <lambdabot> bf provides: bf
23:05:37 <lambdabot> check provides: check
23:05:39 <lambdabot> compose provides: . compose
23:05:41 <lambdabot> dice provides: dice
23:05:43 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
23:05:45 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
23:05:47 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools hackage
23:05:50 <lambdabot> elite provides: elite
23:05:52 <lambdabot> eval provides: run let undefine
23:05:54 <lambdabot> Plugin `system' failed with: IRCRaised thread killed
23:07:51 <kfish> dmead, must be good hacking weather
23:07:55 <kfish> or just good weather :-)
23:11:45 <dolio> They're all watching the Fallout 3 trailer over and over and drooling.
23:12:50 <Jaggederest> Ah, Dolio, thanks! I'm writing a blog entry about this as I go
23:12:58 <Jaggederest> > distance (x1,y1) (x2,y2) = sqrt ((x1-x2)^2 + (y1-y2)^2)
23:12:58 <lambdabot>  Parse error
23:13:17 <sorear> Jaggederest: what do you think that would eval to?
23:13:27 <sorear> Jaggederest: only expressions have value
23:13:30 <Jaggederest> @type (\(x1,y1) (x2,y2) = sqrt ((x1-x2)^2 + (y1-y2)^2))
23:13:32 <lambdabot> parse error on input `='
23:14:04 <Jaggederest> eh nothing I'm just trying to add type signatures and I don't have GHC here
23:14:20 <Jaggederest> @type (\(x1,y1) (x2,y2) -> sqrt ((x1-x2)^2 + (y1-y2)^2))
23:14:22 <lambdabot> forall t. (Floating t) => (t, t) -> (t, t) -> t
23:14:29 <Jaggederest> excellent
23:22:16 <kfish> @quote
23:22:16 <lambdabot> Adamant says: Haskell makes my brain taste like burning
23:23:25 <opqdonut> @quote
23:23:25 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
23:23:30 <opqdonut> @quote
23:23:30 <lambdabot> tibbe says: I will definately check it out, the thing is that someone turned on the laundry machine in the room next door so my internet connection isn't working well ;)
23:52:06 <timthelion> how do I convert a string to a list of chars?
23:52:15 <Korollary> it already is
23:52:23 <timthelion> then how do I get the last one?
23:52:33 <timthelion> I want to check if a string ends in ~
23:52:45 <Korollary> @index isSuffixOf
23:52:45 <lambdabot> Data.List
23:53:44 <Jaggederest> postage: http://illicittech.blogspot.com/2007/06/travelling-salesman-problem.html
23:53:49 <lambdabot> Title: Illicit Technology: Travelling Salesman Problem: Introduction (in Haskell), http://tinyurl.com/2b2eqr
23:57:08 <emu> > (=='~') . last $ "foo~"
23:57:09 <lambdabot>  True
23:59:25 <mwc> @seen shapr
23:59:25 <lambdabot> I saw shapr leaving #xmonad, #haskell-blah, #haskell and #scannedinavian 7h 17m 13s ago, and .
23:59:35 <mwc> Damn.... anybody here know Finnish?
