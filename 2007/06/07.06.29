00:02:54 <dons> Bourbaki: hmm, there's an FP/template lib. bit scary. I'd just grab nhc98 and compile your stuff for the arm( or whatever arch). that's been done plenty of times before -- just ask on haskell-cafe@ if you're stuck
00:03:17 <Bourbaki> ah ok sorry
00:03:33 <Bourbaki> now i get it i can compile nhc98 in the target platform
00:03:44 <dons> yeah
00:04:00 <dons> and its optimised for small heap usage, and constrained environments.
00:04:06 <dons> that was the main focus for nhc, for much of its life.
00:04:18 <dons> when you only had 1-4M availble
00:04:25 <Bourbaki> sounds good thanks a lot
00:04:39 <dons> yhc might also be suitable -- not sure.
00:04:49 <dons> and hugs too, of course, if you can get the interpreter on the device
00:04:49 <Bourbaki> ill have a look at both of them
00:05:01 <dons> (which i imagine must be possible, if they run perl or lua on them)
00:05:14 <dons> anything you find out would be useful to talk about on the mailing list, btw.
00:05:21 <dons> lots of people have programmable, small devices now :-)
00:05:32 <Bourbaki> ill see where it will lead me :)
00:05:34 <dons> i might even get one -- if i can write haskell programs for it.
00:05:41 <dons> or just a zaurus maybe ..hmm.
00:05:45 <lucca> arm with 4M available?
00:05:50 <lucca> nintendo DS!
00:05:56 <Bourbaki> the thing is just that i do not think ppl here in the office will do haskell instead of c++
00:06:16 <dons> that's very likely, Bourbaki :( but you can just churn out code faster than those guys, if you do get it working :-)
00:06:20 <Bourbaki> so id have to find a way to just make it available additionally
00:06:29 <dons> yeah
00:06:39 <dons> then as haskell people to write tons of cool code for it
00:06:46 <Bourbaki> :)
00:07:17 <Bourbaki> i guess in the end it will boil down to something like a small fp like language for our purposes
00:07:34 <Bourbaki> id like to have something like that especially for parsing and such
00:07:57 <dons> you should also talk to stepcut, he's used haskell on phones, iirc.
00:08:10 <dons> there's a bit of a disconneted community of haskell-on-small-devices hackers
00:08:19 <dons> we should get them to put together a web page.
00:08:24 <Bourbaki> good idea
00:08:39 <dons> -- since the theory is you'll be able to write robust software faster in haskell, than in C or C++. so it seems like a good idea.
00:09:02 <Bourbaki> maybe it id have to do a lot of concept rethinking
00:09:19 <Bourbaki> cause im quite familiar with c++
00:09:24 <dons> so, i'd probaby start by asking on haskell-cafe@ for any other people with experience in this area.
00:09:35 <Bourbaki> i should do some more stuff in haskell again
00:09:35 <dons> and suggest perhaps putting together a web page on what people know can be done
00:10:07 <Bourbaki> well ill do some experimenting and then see if its feasable
00:10:43 <Bourbaki> thanks a lot for the links and the ideas
00:12:20 <Bourbaki> i just wonder if i compile the compiler for the platform how do i compile my programs then?
00:12:46 <Bourbaki> cause i cant just shovel it up to the platform and compile there or can i? or would i have to use an emu?
00:12:59 <dons> depends on the platform. perhaps you compile the program to binary in a simulator, then downlaod it onto the device?
00:13:13 <dons> or cross-compile the program.
00:13:41 <Bourbaki> tricky
00:14:02 <dons> how does one compile C++ programs for the device -- you'd follow the same path
00:14:09 <dons> or lua, for example?
00:14:35 <Bourbaki> well of course but lua is a script language
00:14:48 <Bourbaki> the haskell compiler will make a standalone binary
00:15:07 <Bourbaki> and the compilation might needs some space and such i do not have on a small platform
00:15:33 <Saizan> but C++?
00:15:58 <Bourbaki> the c++ compiler runs on win and then i put that up there
00:16:16 <Bourbaki> but in order to make binaries with the nhc i need to compile in the target platform
00:16:24 <Bourbaki> at least if i understood it right now
00:18:11 <dons> lua is scripting, so it requires the lua interpeter on the target machien, doesn't it?
00:18:17 <dons> which would by like having hugs on the target.
00:18:32 <dons> c++ compiles to binaries, somehow, which would be like using nhc to produce binaries.
00:18:57 <Bourbaki> what i mean is that i need the compiler on the target
00:19:05 <Bourbaki> along the binary i want to have
00:19:14 <Bourbaki> that uses space and all
00:19:35 <Bourbaki> and if you want to get all the memory for the binary you want to compile you can not to so
00:19:58 <Bourbaki> ok well i just might run the stuff on an insanely big memory stick or so :)
00:19:59 <mgsloan> somehow your C++ compile process must be cross-compiling.  you may likely do something similar with nhc.
00:20:29 <Saizan> Bourbaki: you mean you want to be able to make new programs from the device?
00:22:59 <Bourbaki> Saizan : i think there is no other way to do it
00:23:19 <Bourbaki> i need to compile the compiler on the target platform and then compile the sources there
00:23:46 <Bourbaki> hm
00:24:23 <mgsloan> well, a mem stick might do it then, though compilation will probably take some time
00:24:59 <mgsloan> I'm sure some of the embedded-device people have insight on the issue
00:25:35 <Bourbaki> i bet yes
00:26:00 <dons> can't you just cross compile from nhc?
00:26:07 <dons> (isn't that what the C++ compiler would be doing?)
00:26:29 <dons> how do you compile C++ programs for this device? and how do you run lua programs?
00:26:35 <Bourbaki> dons : yes maybe but how do i tell the nhc what code he has to generate?
00:26:55 <dons> i think there's an arch flag, iirc. but best check with malcolm or the yhc guys
00:26:56 <Bourbaki> dons : the compiler i use just writes the proper op codes for the target platform
00:27:05 <Bourbaki> ah!
00:27:06 <dons> so its a cross compiler?
00:27:12 <Bourbaki> sorry again
00:27:16 <Bourbaki> now i get it
00:27:33 <Bourbaki> if i can get it to compile for ARM its ok
00:27:58 <dons> yeah, that's definitely be done. tony Sloane at Maquarie runs nhc on the arm (or for the arm)
00:28:10 <dons> and also check with Heffalump -- he worked at ARM, and did haskell there.
00:28:26 <dons> so there's a good body of knowledge awaiting a wiki page ;-)
00:30:43 <Bourbaki> the ds has two cpus
00:30:49 <Bourbaki> one arm9 and one arm7
00:31:21 <dons> sounds like fun.
00:31:40 <Bourbaki> so i can run the scripting stuff on a single cpu maybe:)
00:31:52 <sorear> 'night.
00:31:59 <Bourbaki> nighto
00:32:26 <kral> ahoy
00:33:10 <Cale> dons: Well, I made some sort of attempt at it :)
00:34:06 <Cale> 'night
00:34:15 <Bourbaki> nighto
00:34:33 <mgsloan> reminds me of the gp2x, I think its got dual arm7s or arm9s...
00:35:05 <mgsloan> dual arm9s
00:35:08 <Bourbaki> i just wonder how i can invoke stuff to run on the second cpu
00:36:02 <dons> how do you do it in C++?
00:36:09 <dons> (it would be a matter of the appropriate FFI bindings)
00:36:24 <Bourbaki> no idea yet :)
00:36:46 <dons> Cale, great work
00:37:33 <jre2> Bourbaki: I think you compile two seperate programms
00:37:39 <jre2> and they have some IPC setup
00:38:09 <mgsloan> on the gp2x, anyway, I think one is the master, and one is the slave, and there is some sort of funky transfer/invocation api
00:38:37 <jre2> so your program on the one processor should just be a loop on messages from the other proc and pushing it into eval() ;)
00:39:43 <mgsloan> I think usually people just use the 2nd one for a few brute render routines written in asm
00:40:00 <mgsloan> which isn't so bad, really - arm asm is pretty reasonable
00:40:36 <augnob> I like the conditional flags on each instruction to avoid branches
00:40:39 * mgsloan is talking about gp2x here, I know nothing about the DS
00:40:41 <mgsloan> yeah, me too
00:40:50 <augnob> I was very happily surprised by those
00:41:22 <augnob> and a bunch of other smart things
00:42:43 <mgsloan> indeed.  Been a while since I've written any, but certainly worlds better than nasty x86 etc stuff
00:43:04 <augnob> hehe.  has been about 10 years for me (non-handheld stuff)
00:43:14 <augnob> yeah, much better
00:46:29 <dons> Cale: i tidied up the 'math & haskell community page' -- do you have anything else to add? other relevant resources?
00:46:39 <dons> http://haskell.org/haskellwiki/Haskell_and_mathematics
00:46:40 <lambdabot> Title: Haskell and mathematics - HaskellWiki
00:50:56 <scook0> hmm, I have a space leak :(
00:52:00 <dons> got the code somewhere? what does ghc -O2 -prof -auto-all say about where the leak is?
00:56:02 <scook0> (wrestling with profiling stuff...)
00:57:40 <jre2> dons: any idea how much has performance improved on frag since cheong's thesis?
01:01:10 <dons> no one's touched it, though we have two undergrads woring on various aspects (the AI, and hmm, can't remember the other one0
01:01:28 <dons> i thought performance was considered acceptable (esp. since its pretty unoptimised)
01:02:57 <DRMacIver> What's frag?
01:03:16 <DRMacIver> Ah, FPS in Haskell
01:03:47 <dons> ?wiki Frag
01:03:47 <lambdabot> http://www.haskell.org/haskellwiki/Frag
01:03:48 <quicksilver> since cheong's thesis, performance has improved massively
01:03:54 <dons> it has?
01:03:57 <quicksilver> because computers + cards have got faster :)
01:04:03 <quicksilver> adn the code has remained the same...
01:04:12 <dons> yeah, gpus are faster :-)
01:04:35 <dons> but it was already rate limited to 60 fps
01:04:49 <dons> why the ops, quicksilver ? did we have a troll?
01:05:19 <quicksilver> it's a bit odd, really
01:05:23 <dons> Mun did an amazing job with Frag. I wonder what he's doing now.
01:05:26 <quicksilver> I don't have ChanServ privileges :)
01:05:33 <dons> from haskell newbie to Frag in 6 months.
01:05:41 <augnob> ah, I hadn't heard of frag.  I'm glad to see something like that
01:05:42 <quicksilver> we were talking about ops (And the fact you don't need them often in #haskell)
01:05:46 <dons> quicksilver: oh?
01:05:46 <quicksilver> and someone opped me
01:05:50 <quicksilver> no idea who :)
01:05:50 <dons> heh
01:05:54 <dons> you want to be de-opped?
01:05:59 <dons> probably sorear playing games.
01:06:03 <quicksilver> I can deop myself I suspect
01:06:06 --- mode: quicksilver set -o quicksilver
01:06:18 <quicksilver> that's one of the privileges of op privilege :)
01:06:26 <dons> heh
01:06:47 <dons> augnob: for the other games see http://www.haskell.org/haskellwiki/Applications_and_libraries/Games
01:06:49 <lambdabot> Title: Applications and libraries/Games - HaskellWiki, http://tinyurl.com/2l6gn6
01:06:58 <augnob> dons: yeah, I already ended up there
01:07:25 <augnob> dons: this is very interesting to me.. because often when people are excited about a language, I'm skeptical without ever seeing a proof of concept
01:07:37 <augnob> dons: now it seems someone has gone and done it
01:07:43 <augnob> (2 years ago perhaps :))
01:07:43 <jre2> after looking at his thesis, I was pretty amazed actually
01:08:23 <dons> well, there's a huge range of apps written in haskell, but this is the biggest game, and one of the few opengl games.
01:08:34 <mgsloan> is frag written very.. functionally?
01:08:44 <dons> yeah, it uses arrows
01:08:50 <scook0> dons: I've recompiled my program with profiling, but how do I get it to actually give me data?
01:08:51 <dons> to multithread the game agents
01:08:51 <mgsloan> oh, interesting
01:08:53 <jre2> it uses functional reactive programming via yampa
01:09:05 <dons> scook0: run it with +RTS -p
01:09:17 <dons> and the prof data goes into foo.prof (if youre executable is called 'foo')
01:09:23 <jre2> (arrows being the underlying concept for fpr)
01:09:28 <dons> oh, the other idea would be to map yampa threads onto cpus
01:09:33 <dons> for easy multicore frag
01:09:46 <dons> i wonder if we can get a summer student to work on that
01:10:00 <scook0> ta
01:10:45 * jre2 has to code perl to pay loans :(
01:10:48 <mgsloan> MenTaLguY and I are tossing around the idea of making a rather interactive application in haskell
01:10:58 <desp> a pity I can't get frag to run on OS X
01:11:26 <desp> crashes with a bus error immediately after starting
01:11:38 <mgsloan> the main idea is to implement it in a very DSL way
01:11:44 <jre2> it's a pity you run osx ;)
01:12:38 <dons> desp, yeah, it depends on your opengl and graphics card
01:12:53 <dons> we probably should move frag onto the community server
01:13:04 <dons> and try to encourage a person in the community to maintain it
01:13:19 * jre2 heads off to bed
01:13:27 <profmakx> hm
01:13:28 <desp> dons: that's rather odd; I had no problems running an OpenGL game I wrote in OCaml on all the major platforms
01:13:41 <profmakx> i played with the thought of maintaining it dons...
01:13:43 <profmakx> but
01:13:51 <dons> perhaps you've the old opengl binding for haskell, desp?
01:14:01 <dons> profmakx: but .. ?
01:14:08 <profmakx> i don`t really know the program and need time to get into it ;)
01:14:09 <desp> dons: how do I check? :)
01:14:16 <dons> it makes a great 'gateway drug' for getting undergrads into haskell hackint, btw.
01:14:20 <desp> I simply downloaded and compiled frag
01:14:27 <profmakx> perhaps i should start maintaining it to get to know it ;)
01:14:28 <dons> if someone is looking for a motivating project to get people working on
01:14:51 <dons> desp, i think there's a dependency on whatever is the most recent hopengl ?
01:15:06 <jre2> a good framework for game development certainly attracts people (although sometimes not the kind you want)
01:15:15 <dons> true
01:15:16 <apfelmus> i had the same problem compiling/running frag
01:15:30 <desp> I wish there was something like Ruby Gems for Haskell
01:15:44 <quicksilver> I've certainly run openGL stuff on haskell
01:15:52 <quicksilver> erm with haskell on osx
01:16:01 <quicksilver> haven't tried frag though
01:16:03 * profmakx compiled frag and ran it on my FreeBSD box
01:16:22 <profmakx> and I rendered lots of teapots and stuff ;)
01:16:27 <hpaste>  scook0 pasted "reinforcement.prof" at http://hpaste.org/1431
01:16:28 <quicksilver> desp: isn't that what hackage/cabal is?
01:16:32 <desp> profmakx: :)
01:16:36 <quicksilver> having never used ruby..
01:16:55 <desp> quicksilver: I can write "gem install foo" and it does the right thing
01:17:16 <scook0> seems 'update' is where the leak is (which is bad, since it's called millions of times)
01:17:18 <quicksilver> I believe that is the idea for cababl too
01:17:25 <jre2> alias gem='apt-get' ?
03:16:23 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
03:16:23 --- topic: set by dons on [Sun May 27 19:49:12 2007]
03:16:23 --- names: list (clog daniel_larsson ptx Itkovian matthew_- arag0rn chrismbrown vydd jessejones lindzeyn dcoutts JaffaCake yakov mrsolo_ Pupeno2 eddyp triplah_ _frederik_ hkBst roconnor mdmkolbe|work Igel therp swiert borism kjdf kombinator ph8 tommyd wilx|wrk apfelmus ski boegel kral ont gour Wild_Cat iblechbot mgsloan amiddelk z` dblhelix Bourbaki ttfh kilimanjaro siti dmwit dblog Lemmih hhg rey_ kosmikus ari kaol co Adamant balodja1 Shoragan mathrick_)
03:16:23 --- names: list (fishkandy koffein_ sek_ eal` triple yahooooo Poeir slipstream bdash audreyt_ andun xsdg Eelis atsampson dgriffi3 moconnor benny vincenz magagr ray quasisane cjay LeCamarade hpaste xwl earthy seancorfield Boney dfranke_ |Jedai| tizoc_ jfredett SamB_XP Cheery joe_k ivanm scook0 Nucleo drbean dukedave nominolo jle dvekravy SimonRC_ kpk ski_ TwigEther pingu_ desp tmoertel_away wchogg progexp Alleria_ GeoBes1 norpan matthew-_ astrolabe RyanTM)
03:16:23 --- names: list (julian fbuilesv dfranke mlh Averell rretzbach Uz cognominal_ ntgrl Mitar Vq^ gds sphynx rashakil koala_man pejo aheller wilx ulfdoz ozone_ zilt mightybyte Thomas2 Syzygy- phoniq arcatan jql aleator arguile_ fean yosemite pragma_ BobFunk eno kenn helmut morner emm- helikoptik noj kpreid mauke vstranger Spark sioraiocht quicksilver Hirvinen mm_freak Nafai Cale JohnMeacham dcoutts_ eivuokko Wallbraker Saizan emu Choko mornfall wolverian cernd)
03:16:23 --- names: list (thoughtpolice timchen1` dylan jmob moonlite Lamperi lome mux SamB toxic zamez blackdog fatsauce nn-firedragon TSC lambdabot xinming Plareplane jyasskin JKnecht heanol dino- ksandstr ohmega Dunearhp Tigge bluestorm_ Xgc boyscared bd_ Eidolos greenrd LoganCapaldo Shimei2 agoode Shimei sabakas1 bohanlon mr_ank jdev saccade IvdSangen Lunar^ Modius profmakx raxas pupeno_ ibid Raystm2 Korollary Igloo jewel Metabol jcreigh Philippa psnl encryptio)
03:16:24 --- names: list (thedatabase erider acura jre2 ADEpt araujo opqdonut_ qwr cmeme Tychom MyCatVerbs falconair stevan jaapweel GNU\caust1c Lunchy Khisanth Excedrin sm yaarg audreyt fnordus Vulpyne mattam arjanoosting michie1 Botje agemo yango sieni cinimod osfameron Japsu kalven DRMacIver largos_ lispy cods lucca tessier_ hellige edwinb saturday jbalint Shurique allbery_b Nanar kolmodin dons shachaf |Steve| tessier levitation[A] psykotic qz flux newsham Heffalump)
03:16:24 --- names: list (cameron thedward orbitz nornagon opqdonut c masak nothingmuch petekaz @ChanServ)
03:18:18 <Philippa> <quicksilver> Philippa: well isn't the style sheet provided by the blog program, not the user? <- style sheets are entirely optional. It's common for one to be supplied by a blog, but any browser worth its salt that uses stylesheets at all can override them
03:19:38 <Philippa> quicksilver: One of the results of that is that accessibility is best handled not by trying to provide an infinity of stylesheets but by making sure that your HTML plays well with a stylesheet supplied by the reader
03:19:43 <Igloo> dons: At ICFP, yes, but I don't know how much time they'd spend at a Hackathon given there are other things happening too
03:20:10 <apfelmus> Philippa: well, uhm, you're loosing fonts and stuff when kicking out stylesheets to make it printable
03:20:18 <Igloo> dons: If we can find a friendly local soul then I don't think extra negotiation power will be necessary
03:20:32 <Philippa> apfelmus: yes. So?
03:20:42 <apfelmus> Philippa: i wouldn't call that print ...
03:21:03 <Philippa> apfelmus: it ends up coming out of your printer, doesn't it?
03:21:08 <quicksilver> Philippa: understood. but stylesheets *do* have a built in feature to provide separate print directives
03:21:17 <quicksilver> Philippa: I was only suggesting it might be nice if those were better used
03:21:39 <Philippa> quicksilver: yes. I'm just saying it's in no way necessary that they be used - it doesn't affect the printability
03:21:43 <apfelmus> well, it's the difference between a typewriter paper with ASCII art and a LaTeX-book
03:22:17 <Philippa> no, it's the difference between a LaTeX book and one marked up strictly for semantics in a language that doesn't know anything about typography
03:22:57 <Philippa> (which LaTeX does, it just provides chunks of a semantic layer over the top)
03:23:16 <Philippa> it's LaTeX parameterised over style info, if you like
03:23:27 <apfelmus> well, the style is important
03:23:42 <Philippa> it may be for your reading pleasure - it doesn't matter a damn for archiving the info
03:24:31 <apfelmus> at least my mind archives things based on their layout
03:24:40 <dons> Igloo: yes, we'd want to hold it before ICFP
03:24:52 <dons> or in between ICFP and HW?
03:24:59 <Philippa> yeah, but the content of most blog posts is pretty one-dimensional
03:25:08 <dons> though i suppose, we could also do a more student/hacking version during ICFP..
03:25:15 <dons> who needs talks anyway ;)
03:26:11 <Philippa> if you ditch the sidebar and so forth, it'll generally Just Work if you print if off with no stylesheet at all
03:26:46 <apfelmus> Philippa: i mean, archiving something means that i want to read it again when the time comes
03:27:57 <Philippa> apfelmus: yes. Does your browser's default print layout suck so badly that content's unreadable in it?
03:28:27 <apfelmus> it's the sidebars and navigation stuff that sucks
03:28:41 <Philippa> yes. I've already said how that should be solved: "Print the contents of this div"
03:29:05 <Philippa> the actual post content is an identifiable semantic element of a page...
03:29:28 <apfelmus> yes, sounds good. I wish it would have been implemented already :)
03:29:57 <Philippa> there're a few situations in which it has. Failing that, you can butcher the HTML a little by hand
03:30:24 <mgsloan> can't you define a CSS for print output, and list the nav etc stuff as hidden or whatever?
03:30:42 <Philippa> mgsloan: presumably. My point is that really this shouldn't be the blog author's duty
03:30:49 <mgsloan> ah
03:31:05 <apfelmus> ideally, it wouldn't be the readers duty either
03:31:31 <mgsloan> well, html and all that is pretty crappy
03:31:49 <Igloo> dons: There are 0 days between HW and ICFP...
03:31:51 <Philippa> yeah, so you end up with some standard div classnames or something similar
03:32:19 <apfelmus> i mean, i always adapt the HTML to kick out sidebars but I'm growing tired of doing that
03:33:19 <Philippa> yep. Better browsers're the answer though - it wouldn't be that hard to pop up a tree view of some sensible projection of a page's HTML and let the user select the nodes they want printed
03:42:09 <greenrd> Can anyone give me a short explanation of how mfix works?
03:42:13 <greenrd> for the IO monad
03:43:32 <dons> fixIO k = do
03:43:32 <dons>     ref <- newIORef (throw NonTermination)
03:43:32 <dons>     ans <- unsafeInterleaveIO (readIORef ref)
03:43:32 <dons>     result <- k ans
03:43:32 <dons>     writeIORef ref result
03:43:35 <dons>     return result
03:44:02 <dons> pretty wacky stuff
03:44:26 <greenrd> haha, yes
03:44:31 <dons> instance MonadFix Maybe where
03:44:31 <dons>     mfix f = let a = f (unJust a) in a
03:44:31 <dons>              where unJust (Just x) = x
03:44:33 <dons> is a bit simpler
03:45:08 <matthew-_> that's quite funny
03:45:25 <dons> ?src fix
03:45:25 <lambdabot> fix f = let x = f x in x
03:45:33 <dons> there you can almost see how to get from fix to mfix
03:45:36 <matthew-_> it needs the let to do the existential unpacking or Maybe so thus it can't do the pattern match on the instance?
03:45:44 <matthew-_> s/or/of/
03:46:07 <dons> oh, and fixIO is doing its own blackholing
03:46:09 <dons> wow
03:48:39 <greenrd> so suppose the k function returns a pair, where the right element can only be computed once the left element is known, but not vice-versa
03:49:15 <greenrd> and neither of them actually depend on input from the world
03:49:34 <greenrd> then it would put a thunk to the pair in the IOref
03:49:54 <greenrd> then when the right element was demanded, the left element would be demanded, and it would all work...
03:50:00 <greenrd> hmm this is all a bit sketchy
03:50:04 <sphynx> hi all!
03:50:32 <sphynx> Is there some good article about Haskell syntax related to strict/lazy evaluation?
03:50:56 <dons> syntax related to strict/lazy evaluation?
03:51:18 <dons> you mean, keywords that affect strictness or laziness?
03:51:18 <greenrd> my basic question is how do I know, when I use mfix, when I will be creating a data dependency that will cause nontermination?
03:51:36 <sphynx> dons, yeah, keywords, type strictness modifiers, etc/
03:52:11 <dons> oh, i don't think we have a page on that. the main things are: the `seq` function, bang patterns: f !x = .. ; and lazy patterns:   f ~x = ...
03:52:21 <dons> also, $! , strict application.
03:52:29 <greenrd> does the very fact of sequencing computations a <<= b <<= c introduce a data dependency?
03:52:51 <sphynx> dons: Thanks, it can be aim of searching.
03:53:03 <greenrd> I mean obviously the side-effects, if any, must happen in a specific order
03:53:07 <dons> yep. you can read about `seq` and $! in the Haskell 98 report.
03:53:15 <sphynx> dons: But maybe there is an article showing how to use all these strict things correctly?
03:53:18 <dons> "bang patterns" are mentioned in the ghc user's guide.
03:53:18 <greenrd> but if there are no side-effects...
03:53:29 <dons> sphynx: yes, that seems like a missing document. we should write it!
03:53:50 <sphynx> dons: Are bang patterns GHC-specific?
03:54:09 <dons> they are, currently, but are on the path to being standardised.
03:54:20 <dons> aso, strict constructors in data types. data T = T !Int
03:54:27 <dons> I forgot that one ^^
03:54:43 <dons> you may be able to find more info in the haskell wikibook, http://en.wikibooks.org/wiki/Haskell
03:54:45 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
03:54:52 <dons> and the other things are described in the report, and the ghc users' guide.
03:55:17 <sphynx> dons: OK, thank you very much for such detailed answer!
03:55:37 <sphynx> I will try to read Haskell98 report at first
03:55:38 <dons> i think i might write a wikipage on this tonight.
03:55:55 <sphynx> dons: it would be  very cool!
03:56:18 <sphynx> sphynx: could you please message me on this channel on send email when you've done, please?
03:56:40 <dons> sphynx: sphynx yes :-)
03:56:55 <sphynx> dons: oops, I'm writing to myself )
03:56:59 <dons> oh, see also: http://haskell.org/haskellwiki/Haskell/Lazy_evaluation
03:57:00 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
03:57:06 <dons> and http://haskell.org/haskellwiki/Performance/Laziness
03:57:07 <lambdabot> Title: Performance/Laziness - HaskellWiki
03:57:10 <dons> and http://haskell.org/haskellwiki/Performance/Strictness
03:57:11 <lambdabot> Title: Performance/Strictness - HaskellWiki
03:57:18 <therp> therp: do you also want to write to yourself? I think that's cool.
03:57:20 <therp> therp: no.
03:57:54 <dons> fix therp.
03:58:01 <dons> therp, therp, therp, ...
03:58:53 <dons> > fix ("therp, "++)
03:58:56 <lambdabot>  "therp, therp, therp, therp, therp, therp, therp, therp, therp, therp, therp...
03:59:23 * therp therp therp has to think about that
03:59:42 <dons> laziness is fun.
04:00:06 <sphynx> dons: yeah, but a bit complicated
04:02:02 <dons> different, anyway. its fairly obvious if its the first evaluation mechanism you ever see.
04:03:57 <sphynx> dons: Yeah, like the functional programming in general is, I think
04:05:34 <Saizan> greenrd: about mfix/mdo i'll suggest you to read The Monad Reader issue 6, there's a very nice article by roconnor about using it to implement a one pass assembler
04:05:46 <greenrd> ah ok
04:05:53 <greenrd> I remember that now
04:05:55 <greenrd> thanks
04:20:34 <therp> dons: you are one moderator of cabal-devel, right? is it ok to send darcs patches there? because the cabal repository points me there as default send address. still the msg size <40kb seems to restrict patch posting a lot
04:20:47 <therp> s/msg size/msg size restriction/
04:27:41 <Igloo> therp: Patches should go there. I've just added a tag to the repo, which may or may not help
04:29:20 <Igloo> http://www.neatorama.com/2007/06/28/yarr-best-license-plate-ever/ -- did you know dcoutts drives a jeep?
04:29:21 <lambdabot> Title: Neatorama » Blog Archive » Yarr! Best License Plate Ever.
04:31:12 <dons> i wouldn't have guesed, but does look like someting he'd have.
04:31:19 <dons> ?yarr!
04:31:19 <lambdabot> Prepare to be boarded!
04:31:38 <matthew-_> hopefully not attached to a 3.7L prickmobile
04:32:03 <xpika> does anyone know where i can pick up the ghc package lang?
04:32:31 <xpika> @where lang
04:32:31 <lambdabot> I know nothing about lang.
04:32:39 <dons> there's no such package now. its subsumed by package haskell98 , iirc or haskell-src
04:32:53 <Igloo> Sentient lambdabot! (look at the text at the bottom of the numberplate)
04:36:22 <xpika> dons: wxhaskell wants it. do you think that makes it safe to use --force?
04:36:50 <xpika> on ghc-pkg
04:37:10 <Igloo> You probably need a more recent (possibly darcs) wxhaskell
04:37:57 <xpika> Igloo: ill try that then
04:43:38 <opqdonut> is there something like a lookupM?
04:43:54 <nornagon> :t lookup
04:44:03 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
04:44:14 <opqdonut> yeah like that but returns m b
04:44:23 <opqdonut> so i could get a list for example
04:45:16 <nornagon> @hoogle a -> [(a, b)] -> [(a, b)]
04:45:17 <lambdabot> No matches, try a more general search
04:45:28 <nornagon> er.
04:45:34 <nornagon> @hoogle a -> [(a, b)] -> [b]
04:45:34 <lambdabot> No matches, try a more general search
04:45:38 <opqdonut> @hoogle a -> [(a, b)]
04:45:39 <lambdabot> Data.FiniteMap.fmToList_GE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
04:45:39 <lambdabot> Data.FiniteMap.fmToList_LE :: Ord key => FiniteMap key elt -> key -> [(key, elt)]
04:45:51 <opqdonut> that doesn't even find lookup :)
04:47:18 <nornagon> ?pl \a l -> filter ((==a).fst) l
04:47:18 <lambdabot> filter . (. fst) . (==)
04:47:28 <nornagon> :t filter . (. fst) . (==)
04:47:32 <lambdabot> forall b a. (Eq a) => a -> [(a, b)] -> [(a, b)]
04:47:37 <LoganCapaldo> @hoogle a -> [(a,b)] -> Maybe b
04:47:38 <lambdabot> Prelude.lookup :: Eq a => a -> [(a, b)] -> Maybe b
04:47:49 <LoganCapaldo> @hoogle a -> [(a,b)] -> m b
04:47:50 <lambdabot> No matches, try a more general search
04:47:54 <opqdonut> :)
04:48:00 <nornagon> :t map snd . filter . (. fst) . (==)
04:48:02 <lambdabot>     Couldn't match expected type `[(a, b)]'
04:48:02 <lambdabot>            against inferred type `[(a1, b1)] -> [(a1, b1)]'
04:48:16 <LoganCapaldo> great hoogly mooglu
04:48:16 <nornagon> :t map snd $ filter . (. fst) . (==)
04:48:18 <lambdabot>     Couldn't match expected type `[(a, b)]'
04:48:18 <lambdabot>            against inferred type `a1 -> [(a1, b1)] -> [(a1, b1)]'
04:48:23 <nornagon> ahr.
04:49:34 <Igloo> SamB: ndm#s asked for an example in http://hackage.haskell.org/trac/ghc/ticket/1444 - can you provide one please?
04:49:36 <lambdabot> Title: #1444 (Template Haskell: add proper support for qualified names in non-splicing  ...
04:49:50 <opqdonut> anyways, i settled for using Maybe Maybe and restructuring :)
04:51:16 <sphynx> I need to solve following little problem. I have a list of something and I need to get list of tuples showing number of occurences of each unique element of initial list. I'm doing this in such way:
04:51:55 <TSC> map length . sort . group ?
04:52:00 <TSC> Err
04:52:04 <TSC> Switch group and sort (:
04:53:07 <sphynx> foldl' (\m x -> Map.insertWith' (+) x 1 m)
04:53:44 <sphynx> And I wonder if this is the fastest solution
04:54:13 <sphynx> I have a list of ~10000 unique string and maybe even more
04:55:06 <LoganCapaldo> a hash table or trie could be faster I belief
04:56:06 <sphynx> TSC: It's not that I need.. I need to produce [("a, 2), ("b", 3)] from ["a","b","a","b","b"] for example
04:56:21 <TSC> sphynx: Yeah, but that gets you most of the way
04:56:32 <TSC> It would probably be slower than your way
04:57:07 <LoganCapaldo> eh those solutions should be the same modulo constant factors
04:57:32 <sphynx> LoganCapaldo: Could you please tell what module exactly do you mean?
04:57:36 <TSC> Yes, I think the constants are smaller for sphynx's
04:58:05 <sphynx> BTW insertWith' gives some advantage
04:58:13 <sphynx> I mean in comparsion with insertWith
04:58:21 <sphynx> with non-strict version
04:58:36 <LoganCapaldo> I wasn't speaking of a module, I don't know if theres a hash table or trie in the regular lib collection
04:59:33 <TSC> Data.HashTable?
04:59:35 <LoganCapaldo> @docs Data.HashTable
04:59:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
05:00:07 <LoganCapaldo> there you go
05:00:08 <sphynx> yeah, I'm looking at it at the moment
05:01:13 <LoganCapaldo> it's in IO though :(
05:01:50 * LoganCapaldo wonders if that's really necessary
05:01:50 <sphynx> LoganCapaldo: yeah, it's not pure :(
05:02:40 <sphynx> anyway, that my decision with Data.Map is fast enough, I just seeking for some another approaches
05:02:46 <Saizan> Data.Map is faster than HashTable currently
05:03:39 <LoganCapaldo> that's 2 strikes
05:03:49 <LoganCapaldo> Why is HashTable slower Saizan?
05:04:22 <Saizan> poor implementation, from what iv'e read
05:04:25 * quicksilver wonders if fromList is faster than foldl' insert
05:04:44 <Saizan> ?docs Data.Map
05:04:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
05:05:01 <quicksilver> as somebody once pointed out here, in practice O(log n) is the same as O(1), since log n is bounded above by 64 and thus constant :)
05:05:16 <quicksilver> thus, a tree might well be as good as a hashtable :)
05:05:50 <LoganCapaldo> quicksilver: it hits the asymptote that quickly? I didn't know that..
05:05:54 <LoganCapaldo> wow
05:06:00 <quicksilver> well , it doesn't really
05:06:02 <quicksilver> it's a bit of a silly point
05:06:09 <quicksilver> the point is, 2^64 is a big number
05:06:19 <quicksilver> you're not likely to have more than 2^64 entries in your table
05:06:25 <quicksilver> (your computer is too small)
05:06:26 <LoganCapaldo> true
05:06:29 <quicksilver> so log n < 64
05:06:38 <LoganCapaldo> yeah
05:06:39 <quicksilver> so O(log n) is just a constant factor worse
05:06:41 <LoganCapaldo> good point
05:06:54 <quicksilver> it might sometimes be *better* than 64
05:06:57 <quicksilver> but that's OK
05:07:03 <quicksilver> it's worse case bound is 64..
05:07:09 <quicksilver> mathematically it's a daft argument
05:07:20 <Saizan> fromListWith (+) $ zip xs (repeat 1) ?
05:07:21 <quicksilver> but really the content is 'log n is a very shallow curve'
05:07:53 <quicksilver> draw n log n on graph paper. Excluding the very early stage it's *incredibly* close to a straight line
05:08:04 <quicksilver> thus very hard to distinguish from n
05:08:25 <quicksilver> I know this because I worked on a program which tried to computationally observer empirical complexity
05:08:34 <LoganCapaldo> > (\xs -> M.fromListWith (+) $ zip xs (repeat 1)) ["a","a","a","b","b","c"]
05:08:36 <lambdabot>  fromList [("a",3),("b",2),("c",1)]
05:08:38 <quicksilver> it turns out to be just about impossible to distinguish O(n) and O(log n)
05:08:59 <LoganCapaldo> err O(1) and O(log n) right?
05:09:21 <quicksilver> O(n) and O(n log n)
05:09:23 <quicksilver> is what I mean
05:09:26 <LoganCapaldo> ah
05:09:26 <quicksilver> sorry :)
05:09:51 <quicksilver> that's a more interesting problem in prfactice: you may have O(1) access to your data but I bet you retrieve it all at least once
05:09:58 <quicksilver> (otherwise what is it there for?)
05:10:40 <LoganCapaldo> mm
05:12:09 <LoganCapaldo> I guess you start to worry more about this distinction when it's something like a DB and you're moving around disk blocks instead of in memory datastructures.
05:12:38 * quicksilver nods
05:12:40 <LoganCapaldo> but even then 2^64 is still a really big number
05:12:48 <quicksilver> yes. you can't take what I said really literally
05:12:53 <quicksilver> of course there *is* a difference
05:13:00 <quicksilver> however, the difference is quite small
05:13:09 <quicksilver> it could easily be cancelled out by a bad constant
05:13:16 <LoganCapaldo> yep
05:13:21 <quicksilver> (which is presumably how our HashTable ends up slower than our Map)
05:13:40 <LoganCapaldo> (I was gonna say that :))
05:13:45 <quicksilver> the difference between O(n) and O(n^2) on the other hand is a quite different matter.
05:13:58 <LoganCapaldo> for sure
05:14:29 <sphynx> intersting, if "fromListWith (+) $ zip xs (repeat 1)" faster than that fold' with inser
05:15:17 <quicksilver> you're saying it is? or you're saying it would be interesting if it were?
05:16:04 <sphynx> I'm saying it would be interesting to check which is faster :)
05:16:18 <sphynx> and I'm going to do this
05:16:31 * quicksilver nods
05:17:09 <quicksilver> I don't think foldl' is likely to be a very good idea with Map.insert
05:17:16 <Saizan> sphynx: fromListWith is implemented as foldl' + insertWith
05:17:26 <quicksilver> ok, well I'm wrong then
05:17:30 * quicksilver grins
05:17:40 <Saizan> http://darcs.haskell.org/ghc-6.6/packages/base/Data/Map.hs
05:18:04 <LoganCapaldo> not necessarily. those Data.Map implementors could be bad haskell programmers <g>
05:18:31 <sphynx> Saizan: hmm. so it is completely equal?
05:18:39 <Saizan> quicksilver: well, not sure, Data.Set is known to be too strict and less performant because of this
05:18:40 * LoganCapaldo is joking of course
05:18:49 <sphynx> Well, then I will not compare )
05:20:18 <LoganCapaldo> well it's not exactly the same,
05:20:34 <LoganCapaldo> they use insertWithKey , aren't you using insertWithKey'
05:21:01 <sphynx> yeah, but I've already compared insertWithKey and insertWithKey' in my implementation
05:21:36 <LoganCapaldo> k
05:21:50 <sphynx> strict version seems to be a bit faster, but it is hard to prove, because profiler gives a bit different time results each time
05:23:01 <LeCamarade> What nick does the guy of then Notes on Haskell blog use?
05:23:10 <LeCamarade> s/then/the/gi
05:24:36 <opqdonut> gi? overkill
05:27:49 <opqdonut> hrmm
05:27:54 <opqdonut> is there something like readMaybe?
05:28:19 <opqdonut> i wouldn't want to use readIO, kinda overkill
05:29:09 <scook0> opqdonut: you mean (Read a => String -> Maybe a)?
05:29:19 <sieni> @src readIO
05:29:19 <lambdabot> Source not found. Where did you learn to type?
05:29:25 <opqdonut> scook0: yeap
05:29:35 <scook0> opqdonut: I asked the same question earlier
05:29:38 <opqdonut> something that would return Nothing when the string doesn't parse
05:29:39 <scook0> and got: "listToMaybe . map fst . reads"
05:29:48 <opqdonut> ah, okay
05:29:59 <scook0> though I've not tried it myself
05:31:09 <sphynx> BTW, is readInt in ByteString as slow as 'read' (I've noticed from GHC user's manual that one should avoid read, because it's slow and ugly :))
05:31:13 <sphynx> ?
05:31:32 <LoganCapaldo> @src read -- theres a readEither somewheres apparently
05:31:33 <lambdabot> Source not found. That's something I cannot allow to happen.
05:31:52 <LoganCapaldo> @src read
05:31:53 <lambdabot> read s = either error id (readEither s)
05:32:08 <LoganCapaldo> I guess @src no likey comments
05:32:36 <opqdonut> ah
05:33:02 <opqdonut> @src readEither
05:33:02 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
05:33:16 <opqdonut> hrmm, hoogle doesn't find it Either (notice the pun)
05:33:28 <LoganCapaldo> ba dum ching!
05:33:33 <LoganCapaldo> reads works
05:34:09 <LoganCapaldo> > reads ".3" :: [(Int, String)]
05:34:11 <lambdabot>  []
05:34:20 <LoganCapaldo> map fst []
05:34:27 <LoganCapaldo> > map fst []
05:34:29 <lambdabot>  []
05:34:30 <opqdonut> in what cases does reads return multiple results?
05:35:12 <LoganCapaldo> I'm assuming its for the bizzare scenario of an ambigous valid parse
05:35:19 <opqdonut> ok
05:35:42 <LoganCapaldo> failure as a lsit of successes and all that jazz
05:37:06 <LoganCapaldo> > reads "3" :: [(Int, String)]
05:37:07 <lambdabot>  [(3,"")]
05:37:31 <LoganCapaldo> @type cacth
05:37:33 <lambdabot> Not in scope: `cacth'
05:37:34 <LoganCapaldo> @type catch
05:37:37 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
05:37:55 <Saizan> @type Control.Concurrent.catch
05:37:59 <lambdabot> Not in scope: `Control.Concurrent.catch'
05:38:09 <Saizan> @type Control.Exception..catch
05:38:12 <lambdabot> parse error on input `Control.Exception..'
05:38:28 <Saizan> @type Control.Exception.catch
05:38:30 <LoganCapaldo> can you catch exceptions produced by error? I thought you could...
05:38:30 <lambdabot> forall a. IO a -> (GHC.IOBase.Exception -> IO a) -> IO a
05:38:41 <Saizan> yes you can
05:39:12 <LoganCapaldo> w/ Control.Exception.catch?
05:39:28 <LoganCapaldo> Then you have to be in IO, right?
05:40:35 <Saizan> the type says so :)
05:40:51 <Saizan> and yes, C.E.catch
05:41:15 <LoganCapaldo> drat
05:41:52 <LoganCapaldo> I was hoping for a readMaybe a = (Just $ read a) `catch` (\_ -> Nothing) or something along those lines
05:42:07 <LoganCapaldo> eh that's abusive of exceptions anyway
05:42:42 <scook0> hmm, I had a space leak I was tracking down (with help from dons) -- turns out it was caused by RWST
05:43:26 <Saizan> ?src read
05:43:26 <lambdabot> read s = either error id (readEither s)
05:44:03 <LoganCapaldo> @type listToMaybe . map fst . reads
05:44:06 <lambdabot> forall a. (Read a) => String -> Maybe a
05:44:20 <Saizan> LoganCapaldo: yes i had the same idea, but using exception like that is more appropriate in python/java i think :)
05:44:50 <LoganCapaldo> exceptions are like mines in haskell
05:45:02 <LoganCapaldo> you only have to worry about them if you actually step on them :)
05:45:05 <Saizan> scook0: with [a] as the monoid for the writer part?
05:45:15 <hpaste>  (anonymous) annotated "Lagged Fibonacci Generator" with "(no title)" at http://hpaste.org/1412#a2
05:45:23 <LoganCapaldo> lazy explosions <g>
05:45:24 <scook0> Saizan: ()
05:45:49 <scook0> i.e. I wasn't actually using the writer, (or the state), so substituting ReaderT fixed the leak
05:46:43 <scook0> though the old code worked fine under 6.4
05:48:09 <Saizan> a change in the RWST code maybe?
05:48:27 <hpaste>  (anonymous) annotated "Lagged Fibonacci Generator" with "sorry, shouldn't it be like this" at http://hpaste.org/1412#a3
05:48:42 <LoganCapaldo> @type readIO
05:48:44 <lambdabot> forall a. (Read a) => String -> IO a
05:48:59 <LoganCapaldo> @src readIO
05:48:59 <lambdabot> Source not found. Wrong!  You cheating scum!
05:52:27 <Igloo> dcoutts: ping?
05:53:39 <dcoutts_> Igloo: pong
05:54:19 <Igloo> dcoutts_: I'm confused. In Cabal's Distribution/PackageDescription.hs, is there a reason why the CABAL_VERSION-not-defined case isn't a #error, rather than a runtime error?
05:54:41 <opqdonut> ?src liftM
05:54:41 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
05:54:55 <dcoutts_> Igloo: lemme have a quick look...
05:54:56 <opqdonut> ?pl return . id
05:54:56 <lambdabot> return
05:55:00 <opqdonut> bah
05:55:05 <opqdonut> ?pl return . (+1)
05:55:06 <lambdabot> return . (1 +)
05:57:01 <Igloo> dcoutts_: Do you know what that value is actually needed for?
05:57:05 <dcoutts_> Igloo: yes, I think there is. It's because to bootstrap, Cabal needs to build itself using just runghc Setup.hs and in that case we do not have CABAL_VERSION defined
05:57:50 <dcoutts_> Igloo: the Cabal.cabal file adds the -DCABAL_VERSION=...
05:58:06 <dcoutts_> so when Cabal get's built using Cabal it's all fine
05:58:17 <dcoutts_> but when cabal is interpreted with runghc it does not
05:58:27 <dcoutts_> and that's necessary when bootstrapping
05:58:43 <Igloo> dcoutts_: So should Cabal work if it is built without that defined?
05:59:04 <dcoutts_> Igloo: enough to bootstrap itself, yes.
05:59:18 <Igloo> dcoutts_: Hmm, hang on while I reproduce my problem
05:59:55 <dcoutts_> Igloo: but it must never ask it's own version number, so it will not cope with Cabal itself putting a restriction on the versions of Cabal it needs to build for example
06:00:40 <Igloo> dcoutts_: What makes it ask its own versino number?
06:01:24 <Igloo> dcoutts_: OK, it's building Cabal (with nominolo's patches) that is breaking
06:01:27 <dcoutts_> Igloo: Cabal sometimes needs to know it's own version number so that it can implement the feature where you can specify in the .cabal file what version of Cabal is needed to build the package
06:01:37 <Igloo> Ah, I see, there is a Cabal-Version: >= 1.1.7
06:01:47 * Igloo deletes it
06:01:48 <dcoutts_> in the Cabal.cabal file?
06:01:52 <Igloo> Yup
06:01:55 <dcoutts_> that'll certainly not work :-)
06:10:55 <opqdonut> ?pl (\x -> (listToMaybe . map fst . reads) x >>= flip lookup [(1,1)])
06:10:56 <lambdabot> (flip lookup [(1, 1)] =<<) . listToMaybe . map fst . reads
06:24:57 <sphynx> dons: I have read all the articles you give, so waiting for your fresh-written article )
06:27:15 <Igloo> dcoutts_: Are you a cabal-dev moderator?
06:27:24 <dcoutts_> Igloo: yep
06:27:35 <dcoutts_> Igloo: I just approved a bunch of over-length patches
06:27:53 <Igloo> dcoutts_: Just before I sent mine, I think  :-)
06:27:56 <dcoutts_> heh
06:28:19 * dcoutts_ grumbles about darcs including too much detail in contexts
06:29:01 <dcoutts_> Igloo: done. do you know how we set the attachment size to be a bit higher?
06:29:19 <Igloo> dcoutts_: Thanks. There's a setting in the admin stuff somewhere
06:29:41 <dcoutts_> sadly I'm only moderator, not admin. I'll ask SyntaxNinja
06:30:06 <Igloo> Ah, OK
06:30:25 <Igloo> Fixing darcs would be the best answer, though
06:30:55 <LeCamarade> The frequency with which people ask for maybeRead (a read that doesn't except) strengthens my resolve in the war against exceptions, in favour of Maybe.
06:31:42 <Igloo> You know about reads presumably?
06:31:45 <LoganCapaldo> in favour of MonadError I think you mean :)
06:33:16 <ndm> LeCamarade: reads
06:33:31 <dcoutts_> @type reads
06:33:33 <lambdabot> forall a. (Read a) => String -> [(a, String)]
06:34:32 <fasta> @pl mapM (\f -> f a b c) []
06:34:33 <lambdabot> mapM (flip (flip ($ a) b) c) []
06:34:44 <fasta> @pl mapM (\f -> f a b c d e f g h i j) []
06:34:44 <dcoutts_> > case reads "foo" of [(n :: Int, _)] -> n; _ -> error "not a number!"
06:34:44 <lambdabot> mapM (flip (flip (flip (flip (join (flip (flip (flip (flip ($ a) b) c) d) e)) g) h) i) j) []
06:34:44 <lambdabot>  Parse error in pattern
06:34:53 <dcoutts_> > case reads "foo" of [(n, _)] -> n :: Int; _ -> error "not a number!"
06:34:54 <lambdabot>  Exception: not a number!
06:34:59 <dcoutts_> LeCamarade: ^^^
06:35:09 <dcoutts_> see, reads
06:35:15 <fasta> That is a nice transformation to obfuscate.
06:35:40 <dcoutts_> fasta: aye, I've used pl as an obfuscator before
06:35:58 <fasta> dcoutts_: what do you need obfuscation for?
06:36:15 <dcoutts_> fasta: I used it to obfuscate a spec which I included into a quickcheck test that I distributed to students
06:36:17 <LoganCapaldo> scaring people away from Haskell of course :)
06:36:25 <dcoutts_> fasta: or rather not a spec, as such
06:36:26 <LoganCapaldo> woah
06:36:30 <LoganCapaldo> that's clever
06:36:33 <fasta> dcoutts_: good idea
06:36:52 <fasta> dcoutts_: but... what happens if your student find out they can reverse the process?
06:36:53 <dcoutts_> fasta: the QC test checked their code against a correct (obfuscated) version
06:36:59 <dcoutts_> heh, they can't
06:37:19 <fasta> dcoutts_: I don't know, but isn't there some way to reverse it efficiently?
06:37:24 <dcoutts_> and if they can, they deserve to pass :-)
06:37:27 <LoganCapaldo> well if there solution looks suspiciously like the output of @unpl...
06:37:31 <dcoutts_> no, it really lost information
06:37:38 <dcoutts_> expecially var names
06:37:53 <fasta> dcoutts_: they will just say: I am a fan of Forth ;)
06:38:27 <dcoutts_> I get to read all the solutions and none were obscure like that, so it was not a problem
06:39:16 <fasta> I'd had expected mapM ($ foo bar baz) [function_taking_three_args] to work, but obviously it doesn't.
06:39:37 <dcoutts_> also, if you never tell the students that it's an obfuscated version then there is no incentive to try and reverse engineer, there'd only be that incentive if I'd said it was, because it'd be like a challenge
06:40:23 <fasta> dcoutts_: wouldn't it be easier to implement something via a server?
06:40:38 <dcoutts_> nah, too much fuss, just a QC.hs file
06:41:28 <dcoutts_> this didn't even count to their final grades, so it didn't need that much engineering
06:41:37 <dcoutts_> and it was a good excuse to use @pl :-)
06:42:42 * ndm is very  bored
06:42:52 <opqdonut> ?paste
06:42:52 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:43:00 <daniel_larsson> @hoogle ap
06:43:01 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
06:43:01 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
06:43:01 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
06:43:23 <hpaste>  opqdonut pasted "simple text adventure engine" at http://hpaste.org/1434
06:43:29 <opqdonut> check it out :)
06:43:54 <dcoutts_> hmm, based on recent Hackage additions I'd guess Lemmih is writing a tc client
06:44:03 <dcoutts_> tc/bt doh!
06:44:06 <vincenz> tc?
06:44:17 <dcoutts_> bt, bittorrent
06:44:44 <Lemmih> Shhh, not so loud.
06:44:50 <vincenz> opqdonut: small stylistic pointers?
06:44:57 <dcoutts_> Lemmih: heh heh, ok :-)
06:45:07 <opqdonut> vincenz: go ahead
06:45:15 <opqdonut> comments and type sigs, i know
06:45:18 <vincenz> opqdonut: use where instead of let, unless it's a monadic let
06:45:27 <vincenz> opqdonut: and use custom types instead of commenting like that
06:45:36 <vincenz> type ChoiceDesc = String
06:45:40 <opqdonut> ok
06:45:48 <vincenz> that way later you an replace em by opaque ones if you want to
06:45:51 <vincenz> and you don't have to hunt em down
06:45:59 <opqdonut> yeah, i know
06:45:59 <vincenz> s/an/can
06:46:27 <vincenz> @pl \rooms -> (map foo rooms, map bar rooms)
06:46:27 <lambdabot> ap ((,) . map foo) (map bar)
06:46:40 <opqdonut> map foo &&& map bar right?
06:46:44 <vincenz> think so
06:46:47 <vincenz> @type (&&&)
06:46:47 <opqdonut> yeh :)
06:46:50 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:46:54 <vincenz> yep
06:46:54 <fasta> dcoutts_: I am not sure if it was him, but he already wrote one.
06:47:10 <vincenz> opqdonut: oh! and add a module :)
06:47:16 <opqdonut> yeah, okay
06:47:21 <vincenz> for the rest it looks pretty good
06:47:32 <dcoutts_> fasta: oh ok, I'm just slow then :-)
06:47:40 <fasta> dcoutts_: You would go to to some not very legal page full of torrents and it would automatically download it, I have never used it, though.
06:47:50 <opqdonut> vincenz: thanks!
06:48:16 <vincenz> np ;)
06:48:53 <Lemmih> dcoutts_: I'm actually writting a bittorrent directory as well as a bittorrent client.
06:52:20 <hpaste>  opqdonut annotated "simple text adventure engine" with "improved version" at http://hpaste.org/1434#a1
06:52:36 <opqdonut> there
06:52:43 <opqdonut> gtg, leave a message if you have comments
06:53:10 <vincenz> opqdonut:           choices_      = zip [0..] . map fst . choices
06:53:15 <vincenz> opqdonut: where does 'choices' come from
06:54:06 <fasta> Lemmih: you did write one earlier, right?
06:54:25 <opqdonut> vincenz: accessor of Room :)
06:54:33 <vincenz> ah ;)
06:54:53 <Lemmih> fasta: Yes, now I'm rewriting it with HAppS.
06:55:10 <opqdonut> that state transition matrix is a lousy representation but it was kinda required
06:55:24 <opqdonut> ("assignment" from friend/proof-of-concept)
06:55:27 <fasta> Lemmih: and assuming you have something done already, do you think HAppS seems like a good idea?
06:55:32 <opqdonut> but yeah, gtg really -->
06:55:48 <SamB_XP> why is it called a matrix?
06:56:30 <Lemmih> fasta: Oh yes, HAppS is a lovely framework. It's a true diamond in the rough.
06:56:40 <mdmkolbe|work> Is there already a function for finding the mode of a list of elements?  ("mode" as in average, mean, meadian, mode i.e. most common element)
07:02:06 <Lemmih> fasta: I probably wouldn't have gone with HAppS if it wasn't also my day job. I can imagine it to be immensely difficult to use if you aren't intimately familiar with it.
07:02:16 <ndm> mdmkolbe|work: head . head . sortBy (comparing length) . group
07:02:59 <mdmkolbe|work> ndm: thx, that will do it
07:03:09 <dons> Lemmih: what's the plan to make it simpler?
07:03:17 <dons> -- though i must say, hpaste was fairly painless
07:03:20 <ndm> mdmkolbe|work: actually, one of those head's should be a last
07:03:47 <ndm> (the first one can be last or head, but head is more efficient - the second one must be last)
07:05:40 <Lemmih> dons: We're planning to revamp the HTTP API but there are more urgent issues on the TODO list.
07:06:27 <dons> ok, good to see activity
07:07:03 <fasta> Lemmih: who do you work for?
07:07:34 <fasta> Lemmih: I think most software is hard to work with unless it is documented good.
07:07:54 <fasta> Lemmih: E.g. Emacs is documented well.
07:08:12 <fasta> s/good/well
07:08:16 <dcoutts_> heh, I'm not sure that proves your point :-)
07:08:49 <fasta> dcoutts_: The simplicity of Emacs is like the simplicity of UNIX.
07:08:55 <Lemmih> fasta: What little documentation we have is out-dated.
07:09:09 <dcoutts_> right, which is why most of my students find both incomprehensible :-)
07:09:12 <fasta> dcoutts_: it takes a genius to see it ;)
07:09:45 <Lemmih> fasta: Things are in state of flux, currently. Hopefully it'll be better once 1.0 is released.
07:09:54 <fasta> dcoutts_: Emacs with its ugly fonts was one of the major reasons for me not to use it.
07:10:04 <fasta> dcoutts_: With Emacs 23 that has been solved.
07:10:27 <dcoutts_> most of my students trip up over the strange way emacs deals with mouse selections
07:10:35 <fasta> dcoutts_: I think if you properly explain the ideas behind Emacs, it shouldn't be a problem.
07:10:45 <fasta> dcoutts_: you can configure that for them
07:10:56 <fasta> dcoutts_: Emacs supports about every mode, thinkable.
07:11:10 <dcoutts_> it's easier to just use an editor that works the way they expect it straight off
07:11:15 <fasta> dcoutts_: by mode, I mean whether pasting from an X buffer, or not.
07:11:37 <fasta> dcoutts_: I don't think I agree.
07:12:57 <dcoutts_> fasta: the students have plenty of time in their three years to pick up any editor they like, but we can't waste the first week teaching them about editors
07:13:12 <fasta> dcoutts_: I don't think that's how it works.
07:13:19 <ndm> i find its much easier telling everyone to use KEdit, everyone can figure out how it works in 10 seconds flat
07:13:23 <fasta> dcoutts_: most people come from a Windows environment, I think.
07:13:29 <dcoutts_> fasta: exactly
07:13:37 <dcoutts_> especially since they don't need any advanced editor features
07:13:44 <ndm> (or should go and do a history degree)
07:14:05 <fasta> dcoutts_: so, they will use things like NotePad, ConText and similar weak tools.
07:14:07 <ndm> we used to have a lecturer recommend emacs to all students, that was a nightmare, no one could do anything - i kept getting called over to do stuff like move text
07:14:09 <dcoutts_> so gedit works just fine, doing line numbering and Haskell syntax highlighting
07:14:30 <ndm> dcoutts_ apart from the hilighting of True and False, plus it doesn't have select a block and press tab
07:14:36 <fasta> Maybe forcing is the wrong word.
07:14:46 <dcoutts_> ndm: aye, we've used emacs for years, I could never figure out how to get syn hl to turn on reliably
07:14:50 <ndm> or rather it does, but it replaces the block with tab, rather than indenting it
07:15:00 <fasta> I mean having a webpage on the university site providing practical tips.
07:15:02 <Lemmih> fasta: I work for Alex Jacobson.
07:15:12 <ndm> dcoutts_ the ada mode in Emacs basically types your code for you, rearranges it and everything - it scares me
07:15:17 <fasta> Lemmih: shapr works there too, right?
07:15:24 <fasta> Lemmih: how large is your gang? ;)
07:15:24 <Lemmih> fasta: Yes.
07:15:34 <dcoutts_> ndm: aye, that's a controversial point in gedit/gtksourceview, the behaviour of block tab
07:15:47 <ndm> dcoutts_ - its not "contoversial", its plain wrong!
07:15:54 <dcoutts_> the gtktextview behaviour follows the behaviour of windows
07:16:16 <dcoutts_> that is, whenever something is selected, typing new stuff replaces it
07:16:19 <ndm> "the gtktextview behaviour is wrong, but they are punting off their wrongness by copying"
07:16:37 <dukedave> Well gee, if only you could have some kind of 'mode' you could change into where rather than 'inserting' text you are giving 'commands'  :)
07:17:02 <ndm> i can believe that very few people _want_ to delete all their text and insert a tab at once
07:17:20 <ndm> remember that things like Word do the sensible thing, so i don't think its standard windows behaviour
07:17:22 <dcoutts_> aye, but then people scream about consistency :-)
07:17:42 <ndm> perhaps they can swap the OK/Cancel buttons again, just for a laugh ;)
07:17:44 <dcoutts_> oh, word does that now? interesting
07:17:54 <ndm> word has done that since the begining of time
07:18:00 <dcoutts_> really? hmm
07:18:12 <ndm> there are various "selection" modes, one is character selection, one is word, one is paragraph
07:18:27 <ndm> as soon as you've selected a whole paragraph, the behaviour changes to tab doing indent, not replace
07:18:28 * dcoutts_ tries it in windows notepad.exe
07:18:36 <ndm> dcoutts_ - word, not notepad!
07:18:45 <dcoutts_> yeah, yeah, I know
07:18:55 <ndm> wordpad is still broken though, just checked
07:19:06 <ndm> not that i know anyone who uses wordpad...
07:19:27 <dcoutts_> right, that behaviour sounds quite sensible
07:19:35 <ndm> yes
07:20:01 <ndm> it gives you exactly what you expect, and can be modified to give you the other behaviours really easily
07:20:14 <ndm> whereas if tab doesn't indent, there is no easy way to get the same effect
07:20:58 <dcoutts_> without using another key combo like my main editor uses
07:21:04 <ndm> indeed
07:21:40 <ndm> my main editor (textpad) does the sensible thing, and as a result there is no need for a key combo to do it (although i think it has one, even so, and a button for it)
07:24:02 <fasta> Did you read about the Intel Core 2 Duo?
07:24:16 <ndm> yeah, its broken :)
07:24:26 <fasta> It seems more like it has been done on purpose.
07:24:34 <ndm> who said that?
07:24:38 <fasta> Me
07:24:48 <ndm> all processors are full of bugs (ask Heffalump)
07:24:56 <ndm> usually compiler writers patch around them
07:25:57 <ndm> one of my friends worked on the first 128-bit console, it had 1 single 128 bit instruction, which took up about 5mm squared of chip, and completely didn't work - the compiler emitted 3 64 bit instructions in its place
07:26:15 <quicksilver> or the OS writers, of course
07:26:22 <quicksilver> depending where the appropriate place to patch it is
07:26:35 <quicksilver> but some chips are, nonetheless, buggier than others, and some bugs more serious than others
07:27:04 <ndm> indeed, and some chips its not the chip thats buggy, its the manufacturing and lack of total test coverage
07:27:13 <fasta> The way I understand it from the OpenBSD reports is that user-space code can get root.
07:27:43 <ndm> i read that as "we're upset so we're going to publicly slander you"
07:27:44 <fasta> Essentially the difference between user-space and kernel space is gone, bringing us back to the Wind98 age.
07:27:58 <quicksilver> there are no documented exploits, it's only a theory
07:28:05 <dcoutts_> Igloo: btw, I agree with ndm, send out your style guide
07:28:08 <quicksilver> it's not a simple thing to exploit either
07:28:24 <quicksilver> Theo has been known, in the past, to post fairly emotive articles
07:28:26 <fasta> The German government seems highly interested in such tools, however.
07:28:27 <quicksilver> nonetheless, it's interesting
07:31:02 <MyCatVerbs> Er, too lazy to read all the backscroll, what bug is this?
07:31:12 <MyCatVerbs> Someone's chip doesn't distinguish ring 3 from ring 0 or something?
07:31:36 <dons> the core 2 chips are ignoring the no-exec bit, iirc
07:31:43 <MyCatVerbs> !
07:31:47 <MyCatVerbs> Holy shit.
07:31:49 <dons> meaning, security based on setting no-exec ain't going to work.
07:32:04 <SamB_XP> wow!
07:32:13 <dons> there's other issues too.
07:32:13 <kyo> where I can find functional programming tutorials for haskell?
07:32:32 <ndm> @where yaht
07:32:32 <dons> MyCatVerbs: see http://undeadly.org/cgi?action=article&sid=20070628134608
07:32:32 <MyCatVerbs> dons: yikes. That's, uh, roughly one-half of my favourite desktop OS's security measures blown away at a stroke.
07:32:32 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
07:32:33 <lambdabot> Title: Intel Core 2 considered evil
07:32:40 <ndm> kyo: ^^
07:32:41 <dons> kyo: on haskell.org, there's 100s of tutorials :-)
07:32:47 <dons> yaht is a good one.
07:32:59 <kyo> ok thanks
07:33:01 <MyCatVerbs> kyo: try the Haskell wiki. The meta-tutorial is a handy collection of links to other tutorials.
07:33:33 <MyCatVerbs> kyo: personally, I rather liked the Hitchhiker's Guide to Haskell, but after reading one or two others.
07:34:15 <pejo> MyCatVerbs, http://marc.info/?l=openbsd-misc&m=118296441702631
07:34:17 <lambdabot> Title: 'Intel Core 2' - MARC
07:34:44 <MyCatVerbs> Dammit.
07:34:53 <LeCamarade> kyo: You need a number of tutorials. One rarely suffices.
07:35:26 <fasta> kyo: no, you need to read a few books on Haskell
07:35:33 <fasta> kyo: tutorials only get you so far
07:36:53 <quicksilver> I think that's quite subjective
07:36:58 <quicksilver> I've never read a single book on haskell
07:37:06 <quicksilver> different people learn in different ways
07:37:58 <osfameron> yeah.  I find it sufficiently odd that I need the focused effort of plodding through a book
07:38:17 <MyCatVerbs> Write some programs, write many programs, read several tutorials, read several books. Pick any two and a half.
07:38:36 <LeCamarade> I gather tutorials, blog posts, snippets, examples and my scratchings and make a book.
07:39:14 <quicksilver> I recommedn learning haskell with very healthy amounts of use of ghic (or hugs) and trying stuff
07:40:33 <fasta> MyCatVerbs: right
07:40:39 <scook0> heh, -Wall just found a nasty bug :)
07:43:26 <MyCatVerbs> scook0: ?
07:43:54 <MyCatVerbs> quicksilver: I heart REPLs for purposes of playing around with the language. ^^
07:43:59 <erider> good morning
07:44:34 <scook0> MyCatVerbs: effectively do { a <- x; b <- f a; return a }, when I should have been returning b
07:44:56 <scook0> (but more complicated in the actual code)
07:45:33 <MyCatVerbs> scook0: it caught the fact that b wasn't used?
07:45:41 <scook0> MyCatVerbs: exactly
07:48:28 * SamB wonders how exactly you go about making your own widgets using canvases...
07:50:28 <dylan> ghci is the first place I try new algorithms.
07:52:02 <MyCatVerbs> scook0: spiffy.
07:52:09 <MyCatVerbs> Heeheee.
07:52:31 * fasta suspects dylan is not using Haskell mode.
07:52:44 * fasta suspects dylan uses Windows.
07:53:25 * dylan has not used windows for 5 years
07:54:13 * dylan uses xmonad + ghci + vim.
08:07:15 <tom_> hi all
08:07:58 <ndm> hi tom_
08:08:06 <tom_> Can anyone recommend a simple way to output bitmap images from a Haskell program? The format's not that important although Jpeg would be best
08:09:05 <ndm> The gtk2hs stuff may have some of this, they have some Cairo bindings
08:09:46 <tom_> Thanks, but I just want to write it out to a file, I don't need to display it (which I assume is what gtk2hs is good at)
08:10:00 <swiert> you could try generating postscript...
08:10:04 <dylan> you could output pixmaps
08:10:10 <dcoutts_> tom_: aye, gtk2hs's Pixbuf can save in .jpeg format
08:10:37 <fasta> It would be nice if someone would write a demo for GTK2HS sorting three lists of numbers in real-time.
08:10:46 <mauke> you could use .pnm
08:10:56 <dcoutts_> fasta: huh?
08:11:24 <fasta> dcoutts_: that is something that includes threads, some drawing operations and some control.
08:11:46 <fasta> dcoutts_: not easy for someone not familiar with GTK.
08:11:53 <tom_> is there a haskell library for .pnm, or is it just a very simple format
08:12:01 <TSC> PPM's really simple
08:12:03 <dcoutts_> tom_: it's a really simple format
08:12:18 <mauke> tom_: it's a plaintext header + raw pixel data
08:12:19 <TSC> A small text header, then the binary data
08:12:24 <tom_> I'll check out the gtk option as well, are there any problems using that in Windows, Linux and OSX
08:12:38 <dcoutts_> tom_: gtk2hs works on all three
08:12:54 <dylan> I thought haskell had GD or imagemagick bindings
08:12:55 <ndm> tom_ you currently can't use gtk2hs on the latest version of windows (although dcoutts_ should have that fixed by, umm, yesterday :) )
08:13:11 <tom_> PNM sounds like what I need then
08:13:13 <dcoutts_> ndm: I just built the installer 30 seconds ago :-)
08:13:22 <ndm> dcoutts_ upload!
08:13:36 <dcoutts_> ndm: I've not even tested it myself yet!
08:13:39 <fasta> dcoutts_: why the '?'?
08:13:59 <dcoutts_> fasta: I wasn't quite sure what you were asking for
08:15:50 <fasta> dcoutts_: are you now?
08:18:48 <dcoutts_> fasta: less so
08:21:05 * mdmkolbe|work comes back from afk
08:21:42 <mdmkolbe|work> is the head of a sortBy lazy?  (i.e. O(n), not O(n log (n))
08:22:43 <dcoutts_> mdmkolbe|work: I think so, yes.
08:23:41 <ihope__> You know, main=putStr(x++show x)where x="main=putStr(x++show x)where x=" is one of the shortest quines I've seen.
08:25:05 <mauke> > ap(++)show"ap(++)show"
08:25:07 <lambdabot>  "ap(++)show\"ap(++)show\""
08:25:21 <mdmkolbe|work> ihope__: "" is a quite for 'cat' ;-J
08:25:27 <quicksilver> ihope__: I guess the way the show primitive adds the quotes for you simplifies things somewhat
08:25:27 <mdmkolbe|work> s/quite/quine/
08:25:51 <mdmkolbe|work> @unpl p(++)show"ap(++)show"
08:25:51 <lambdabot> p (++) show "ap(++)show"
08:25:52 <quicksilver> mdmkolbe|work: empty programs are excluded from most definitions of 'quine'
08:26:17 <mdmkolbe|work> quicksilver: ok, "1" is a quite for m4 ;-JJ
08:26:20 <mauke> @unpl ap(++)show"ap(++)show"
08:26:20 <lambdabot> ((++) >>= \ b -> show >>= \ a -> return (b a)) "ap(++)show"
08:26:25 <mdmkolbe|work> grr s/quite/quine/
08:27:28 <mdmkolbe|work> @pl let (>>=) = concatMap; return x = [x] in ((++) >>= \ b -> show >>= \ a -> return (b a)) "ap(++)show"
08:27:28 <lambdabot> (line 1, column 5):
08:27:29 <lambdabot> unexpected "("
08:27:29 <lambdabot> expecting natural, identifier or "in"
08:27:31 <ihope__> quicksilver: very much, yes.
08:27:49 <ihope__> "Hello, world!" is a quine in ///.
08:28:23 <mdmkolbe|work> @pl let (>>=) = concatMap in ((++) >>= \ b -> show >>= \ a -> return (b a)) "ap(++)show"
08:28:23 <lambdabot> (line 1, column 5):
08:28:23 <lambdabot> unexpected "("
08:28:23 <lambdabot> expecting natural, identifier or "in"
08:28:47 <quicksilver> mdmkolbe|work: @pl has a rather restricted syntax, I'm not sure it suports let at all
08:28:50 <mauke> @pl  ((++) >>= \ b -> show >>= \ a -> return (b a)) "ap(++)show"
08:28:50 <lambdabot> ((show >>=) . (return .) =<< (++)) "ap(++)show"
08:28:56 <quicksilver> @pl let x = 5 in x
08:28:56 <lambdabot> 5
08:29:11 <quicksilver> @pl let (*) = (+) in (*)
08:29:12 <lambdabot> (line 1, column 5):
08:29:12 <lambdabot> unexpected "("
08:29:12 <lambdabot> expecting natural, identifier or "in"
08:29:23 <quicksilver> ah, it's just the 'bracketed operator' construct itchokes on
08:29:37 <mdmkolbe|work> @pl let bind = concatMap; return x = [x] in ((++) `bind` \ b -> show `bind` \ a -> return (b a)) "ap(++)show"
08:29:37 <lambdabot> ((++) =<< (show =<<) . (return .)) "ap(++)show"
08:29:49 <mdmkolbe|work> @unpl let bind = concatMap; return x = [x] in ((++) `bind` \ b -> show `bind` \ a -> return (b a)) "ap(++)show"
08:29:49 <lambdabot> let { bind = concatMap; return x = [x]} in bind (++) (\ b -> bind show (\ a -> return (b a))) "ap(++)show"
08:30:23 * mdmkolbe|work goes cross eyed trying to unstand that quine
08:30:41 <mauke> @src ap
08:30:41 <lambdabot> ap = liftM2 id
08:30:56 <ihope__> Here, have another quine: <interactive>:1:0: parse error on input `<'
08:31:42 <ihope__> @src product
08:31:42 <lambdabot> product = foldl (*) 1
08:31:55 <ihope__> :-)
08:33:02 <shachaf> mdmkolbe|work: In this context, ap is S: ap x y z = x z (y z)
08:34:42 <mdmkolbe|work> > (++)show (show "ap(++)show")
08:34:42 <lambdabot>  <Plugins.Eval>:1:10: parse error on input `='
08:35:45 <mdmkolbe|work> > show "ap(++)show" ((++) "ap(++)show")
08:35:46 <lambdabot>  Couldn't match expected type `([Char] -> [Char]) -> t'
08:35:53 <mauke> > (++) "ap(++)show" (show "ap(++)show")
08:35:55 <cstar> any "Yi" users to whom I could direct a question?
08:35:56 <lambdabot>  "ap(++)show\"ap(++)show\""
08:36:40 <mdmkolbe|work> mauke: thx, that helped
08:39:42 * mdmkolbe|work just realized that might have sounded sarcastic, but he didn't mean it to
08:40:10 <mauke> heh
08:42:59 <mm_freak> <lambdabot> product = foldl (*) 1   -- according to a performance paper i've read, this is a rather bad definition
08:43:50 <shachaf> mm_freak: Lambdabot often doesn't have the real sources.
08:43:51 <mauke> ghc -O should help with that
08:44:19 <mm_freak> hmm
08:44:25 <dcoutts_> I think it has to be defined that way actually
08:44:32 <dcoutts_> and there is no foldl' in H98
08:44:56 <dcoutts_> there is an argument to change it however...
08:45:21 <dcoutts_> it should probably either be specified with foldr or foldl' (which would require specifying foldl')
08:45:39 <dcoutts_> if it's supposed to allow lazy definitions of (*) then it should probably use foldr
08:45:53 <sjanssen> that doesn't seem very useful in practice
08:45:57 <dcoutts_> if not, and it seems not since it uses foldl rather than foldr, then it should be foldl'
08:46:36 <dcoutts_> or we should wait until ghc can transform foldl to foldl' based on the strictness of the function arg
08:46:43 <dcoutts_> which would be cool :-)
08:47:04 * dcoutts_ wants rules that can use strictness info
08:47:09 <quicksilver> sjanssen: what about continued fractions?
08:47:15 <quicksilver> sjanssen: wouldn't you want a lazy (*) then?
08:47:19 <sjanssen> quicksilver: sure
08:47:21 <quicksilver> I didn' tthink that through, I just said it
08:47:32 <dcoutts_> quicksilver: I'm not so sure
08:47:46 <dcoutts_> quicksilver: how is a continued fraction represented?
08:47:59 <sjanssen> quicksilver: but do you want O(n) memory use to compute the product of a list of Ints?
08:48:57 <dcoutts_> quicksilver: and I think you can make it lazier by adding boxes
08:49:36 <quicksilver> dcoutts_: a continued fraction is represented as a list of denominators
08:49:42 <quicksilver> dcoutts_: or, something isomoprhic to that
08:49:49 <quicksilver> sjanssen: yeah, I don't really know :)
08:49:56 <quicksilver> sjanssen: I've not actually thought this through, as I said
08:51:18 <dcoutts_> quicksilver: no problem then, foldl' would only force the list to be [] or (_:_)
08:54:36 * sjanssen thinks foldl should be abolished, and foldl' should be renamed to foldl
08:55:24 <quicksilver> >  unfoldr (\x -> Just (floor x,1/(x-(fromIntegral . floor $ x)))) pi
08:55:26 <lambdabot>  [3,7,15,1,292,1,1,1,2,1,3,1,14,3,3,23,1,1,7,4,35,1,1,1,2,3,3,3,3,1,1,14,6,4,...
08:55:44 <quicksilver> dcoutts_: continued fraction for pi, subject to rounding errors after the first couple of places
08:56:06 <quicksilver> > 3 + 1/7 :: Double
08:56:08 <lambdabot>  3.142857142857143
08:56:15 <quicksilver> > 3 + 1/(7 + 1/15) :: Double
08:56:17 <lambdabot>  3.141509433962264
08:56:54 <quicksilver> > 3 + 1/(7 + 1/(15 + 1/(1+1/292))) :: Double
08:56:56 <lambdabot>  3.1415926530119025
08:57:04 <dcoutts_> interesting
08:57:05 <quicksilver> and better and better approximations generated from that list
08:57:18 <quicksilver> it's a real pain in C, it's a one liner in haskell :)
08:57:30 <quicksilver> Ok, it's not a *real* pain. But it's not that easy.
08:57:53 <quicksilver> > 3 + 1/(7 + 1/(15 + 1/(1+1/292))) :: Rational
08:57:56 <lambdabot>  103993%33102
08:58:03 <quicksilver> rather good rational approximation :)
08:58:23 <sjanssen> > toRational pi
08:58:24 <lambdabot>  884279719003555%281474976710656
08:58:41 <quicksilver> > toRational pi - (103993%33102)
08:58:43 <lambdabot>  2692214101%4658692339538067456
08:58:47 <oerjan> @src toRational
08:58:47 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:58:50 <quicksilver> error term looks quite small to me
08:58:58 <fasta> C is not the language one should compare too, anymore.
08:59:03 <fasta> to*
08:59:14 <quicksilver> fasta: that's a fair point, my comments should be taken fairly light heartedly :)
08:59:26 <fasta> Just that a large part of broken software is written in C, doesn't mean it's good :)
08:59:28 <quicksilver> fasta: they are friday afternoon comments...
08:59:38 <fasta> quicksilver: yes, I know and this is IRC.
08:59:52 <fasta> quicksilver: there is no need to be perfectly accurate. :)
09:00:23 <oerjan> @src RealFrac
09:00:23 <lambdabot> class  (Real a, Fractional a) => RealFrac a  where
09:00:23 <lambdabot>     properFraction                   :: (Integral b) => a -> (b,a)
09:00:23 <lambdabot>     truncate, round, ceiling, floor  :: (Integral b) => a -> b
09:00:31 <fasta> I never thought I would like QC and SmallCheck this much.
09:00:40 <oerjan> :t toRational
09:00:42 <lambdabot> forall a. (Real a) => a -> Rational
09:00:51 <oerjan> @src Real
09:00:51 <lambdabot> class  (Num a, Ord a) => Real a  where
09:00:51 <lambdabot>     toRational      ::  a -> Rational
09:01:19 <dcoutts_> ndm: got time to test a gtk2hs installer for me?
09:01:29 <ndm> dcoutts_ hit me with a link
09:01:34 * dcoutts_ uploads
09:01:59 <quicksilver> oerjan: I thnk the toRational instances for the interesting types are primops
09:02:12 <oerjan> > iterate (`div` 4) 281474976710656
09:02:14 <lambdabot>  [281474976710656,70368744177664,17592186044416,4398046511104,1099511627776,2...
09:02:19 <quicksilver> oerjan: to implement toRational for Double you need to have access to the underlying storage
09:02:25 <quicksilver> and understand the format
09:02:27 <quicksilver> I think?
09:02:31 <oerjan> > iterate (`div` 16) 281474976710656
09:02:33 <lambdabot>  [281474976710656,17592186044416,1099511627776,68719476736,4294967296,2684354...
09:02:58 <oerjan> > log 281474976710656/log 2
09:03:00 <lambdabot>  48.0
09:03:04 <oerjan> 2^48
09:03:07 <oerjan> > 2^48
09:03:10 <lambdabot>  281474976710656
09:04:06 <savanni> Is anybody available to help me with a parsec problem?
09:04:37 <LoganCapaldo> savanni: only if you ask the question will we know :)
09:04:50 <oerjan> quicksilver: i was just checking if the denominator was a power of 2, as you would expect if it corresponded exactly to the floating point
09:05:04 <savanni> :D I still like to check first to see if anyone is interested.
09:05:05 <savanni> Anyway...
09:05:15 <oerjan> savanni: me! me!
09:05:45 <savanni> I am trying to, as a small part of a bigger parser, write a parser that takes a semicolon-separated list, breaks it up, but stops parsing and returns as soon as it hits a \n
09:06:21 <savanni> Effectively, I will have multiple lines of this, and I want the parser that I am currently working on to get only the first line, but leave the \n there for the next parser.
09:06:35 <savanni> Or not.  That last part is optional.
09:06:42 <savanni> Just so long as the next parser is esesntially starting at the next line.
09:06:52 <savanni> (I have a small source file if you want to look at it)
09:07:00 <oerjan> savanni: followedBy will leave what it matches.
09:07:10 <oerjan> :t followedBy
09:07:13 <lambdabot> Not in scope: `followedBy'
09:07:36 <savanni> The parsec docs only list notFollowedBy
09:08:19 <savanni> Yeah, I apparently don't have followedBy at all.
09:08:28 <oerjan> hm, it seems so
09:08:55 <oerjan> well, as long as none of your subparsers match an '\n', that should be simple enough
09:10:04 <savanni> Well, I have a subparser that should grab and return all characters up to the ';' or a '\n' since either indicates the end of a part of the list.
09:10:29 <savanni> And then a parent parser that watches for the '\n' also to know not to re-do the subparser, but the'\n' has already been eaten.
09:11:21 <dcoutts_> ndm: http://haskell.org/~duncan/gtk2hs/gtk2hs-0.9.11.2.exe
09:11:33 <crazy_coder> hello everybody
09:11:54 <oerjan> i think you better paste
09:12:06 <crazy_coder> Is there a std function to change the colour of the text written to stdin ?
09:12:13 <crazy_coder> oerjan: was it for me ?
09:12:19 <oerjan> no, for savanni
09:12:21 <savanni> oerjan: http://www.alyra.org/svn/pim/attr_parse.hs
09:12:30 <dcoutts_> crazy_coder: see the ANSI escape codes for terminal colour
09:12:57 <crazy_coder> dcoutts_ Thanks
09:12:59 <dcoutts_> crazy_coder: hscolour does that too, so you could look at the source code for that
09:13:34 <crazy_coder> it think it would be elegant to use shell command instead of haskell code to implement it
09:13:56 <crazy_coder> what should I 'man' for ?
09:14:24 <mauke> there is no shell command
09:14:32 <malcolmw> the source code for hscolour has a full set of ANSI terminal codes, so you can look them up there if you like
09:14:50 <malcolmw> things like ESC[0m
09:14:55 <crazy_coder> what is hscolour ?
09:15:03 <dcoutts_> @where hscolour
09:15:04 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
09:15:21 <oerjan> savanni: try using (noneOf "\n;") instead of anyChar
09:15:32 <crazy_coder> Great Thanks
09:15:36 <dcoutts_> crazy_coder: it syntax highlights Haskell code, it can output to colour terminals or produce html
09:16:02 <crazy_coder> Actually I am implementing a search function
09:16:18 <crazy_coder> which takes a string, finds it in a text file and highlights it
09:16:25 <crazy_coder> Thanks anyways :)
09:17:48 <savanni> oerjan: I still get the same problem.  test_attr_list_2 just parses into a single long list containing all of the words.
09:19:08 <savanni> strangley, if I change that line to read 'many (noneOf "\n;")', something in attrList fails to stop parsing.
09:19:19 <oerjan> what are attr and attrList supposed to parse, respectively?
09:20:19 <ndm> @karma+ dcoutts
09:20:19 <lambdabot> dcoutts's karma raised to 48.
09:20:24 <savanni> Given a line that contains a semicolon-separated list, attr should return the next element of that list as simply a string.  attrList should put together all of the elements in that single line and return a list of all the elements in that list.
09:20:33 <ndm> dcoutts_: perfect
09:21:00 <dcoutts_> ndm: note that it doesn't include the demos or docs yet (and gtksoe is still borked in ghci)
09:21:09 <dcoutts_> threading is a *****
09:21:31 <ndm> dcoutts_ - it does guihaskell, which is my need (and i didn't install demos or docs since i'm short of disk space)
09:22:35 <dcoutts_> ndm: btw, I hear that the next major gtk version has yet more win32 theme improvements
09:22:41 <dcoutts_> and it has glade built in :-)
09:22:45 <ndm> dcoutts_ about time!
09:22:54 <dcoutts_> and printing uses the native dialog boxes
09:23:12 <dcoutts_> GtkBuilder replaces libglade
09:23:56 <dylan> do they have a non-ugly file dialog for unix now?
09:24:11 <dcoutts_> what do you mean? it's never been ugly ;-)
09:24:28 <dcoutts_> it's the same one that it's had for the last few major releases
09:24:33 <dylan> until a month ago or so it didn't let me type a path
09:24:45 <dcoutts_> it does, use ctl-L
09:24:52 <dylan> that's evil.
09:25:15 <dcoutts_> there's talk of having the path box be there by default, or letting it be a setting
09:25:39 <oerjan> savanni: i think your problem is that attr parses something which isn't its job to match at all. try attr = manyTill (noneOf "\n;") attrSep
09:25:41 <ndm> are they replacing their file picker?
09:25:50 <dcoutts_> ndm: no
09:25:59 <dylan> the UI-simplification people are making firefox, gtk, and gnome really not fun to use.
09:26:12 <ndm> because as UI design goes, it makes me cry
09:26:24 <ndm> firefox has clever simplification
09:26:40 <oerjan> actually, leave out attrSep too.
09:26:52 <ndm> gtk file choose is a bunch of idiots, getting together, smoking crack, and then designing a filechooser based on a bad trip
09:26:58 <savanni> And just make it 'many (noneOf "\n;")'?
09:27:07 <oerjan> yep
09:27:11 <dcoutts_> ndm: I think the file picker is fine, of course on win32 it'd be nicer if it followed the native one, but given a clean slate on linux it's fine
09:27:30 <dcoutts_> nice and simple, configurable shortcuts
09:27:39 <ndm> dcoutts_ - no, it sucks in all circumstances, but they've obviously got to you with the marketing :)
09:27:46 <savanni> hmmm
09:27:58 <oerjan> and then replace eoln_noparse () by attrSep in attrList
09:27:58 <dcoutts_> ndm: the acid test is using it, I have no probs using it
09:28:02 <sjanssen> ndm: why does it suck compared to eg. the Windows file dialog?
09:28:13 <oerjan> er, no
09:28:16 <ndm> sjanssen: its not as powerful, you can't type a file to open it, it sucks
09:28:20 <savanni> Yeah, that wouldn't do it.
09:28:34 <ndm> dcoutts_, i've tried to use it, and tried to rip my eyes out - it made me cry for the user interface of a console
09:28:52 <dcoutts_> ndm: you can just type a file name
09:28:54 <dylan> The icons are too large, as well.
09:28:57 <ndm> sjanssen: the Windows one is not perfect, the one in Visual Studio is very neat - it has auto-completion in a GUI framework, its a bit more refined
09:29:05 <ndm> dcoutts_ - there is no text box to see what i am typing
09:29:13 <Nafai> Uh
09:29:21 <Nafai> There's one in my gtk file chooser
09:29:27 <sjanssen> ndm: the box appears when you start typing
09:29:41 <savanni> with the eoln_noparse still present, test cases that have two elements in the first line never terminate.  To me that makes no sense, though.
09:29:50 <quicksilver> I've been using gtk since the very first version and I've *always* typed the file name
09:29:55 <quicksilver> I'm quite sure that's always worked
09:30:03 <oerjan> instead, try attrList = sepBy attr attrSep
09:30:10 <ndm> sjanssen: exactly, if a tree falls in the forest and no one sees it did it happen?
09:30:24 <ndm> and if you didn't know trees can fall, how would you discover this?
09:30:36 <ndm> (me enjoys mixing incompatible metaphores)
09:30:40 <savanni> Does sepBy know to automatically stop at "\n"?
09:30:46 <sjanssen> yes, it isn't discoverable at all
09:30:46 <savanni> (that is the behaviour I think I'm seeing)
09:31:12 <quicksilver> savanni: no
09:31:20 <quicksilver> savanni: sepBy doesn't know anything special
09:31:22 <quicksilver> :t sepBy
09:31:24 <lambdabot> Not in scope: `sepBy'
09:31:25 <oerjan> savanni: every parser stops when it doesn't match
09:31:38 <ndm> Gnome is a project who has tried hard to design a good UI, alas with absolutely no talent, ability, direction or focus
09:31:40 <savanni> OH!
09:31:42 <savanni> I see.
09:32:07 <quicksilver> ndm: oh come on, that's tiresome
09:32:21 <quicksilver> ndm: the gnome project contains a vast amount of talent and ability
09:32:36 <savanni> oerjan: thank you for your help on this!
09:32:41 <quicksilver> and it certainly has direction and focus, just not imposed from above, and you may choose to disagree with that direction
09:32:54 <dcoutts_> ndm: oh, on my system the location box is there by default now
09:32:56 <ndm> quicksilver: fair enough, there is talent, and i agree that these questions should be the ones that are being asked, but i don't think the end result matches something like Apple
09:33:03 <oerjan> :)
09:33:15 <dylan> I dislike apple's file chooser too
09:33:22 <ndm> or even Microsoft, who really don't have a great track record on consistency or UI design
09:33:30 <quicksilver> absolutely
09:33:38 <therp> ndm: I definitely find Gnome better in usability and uniform structure than Apple's UI
09:33:47 <quicksilver> tehre is glaring inconsistency, and the UI design is by no means great
09:33:48 <Nafai> ndm: I certainly wouldn't call Apple the panacea of usability though
09:33:54 <quicksilver> but your criticisms went a bit too far :)
09:33:57 <ndm> therp: apple have been doing their hardest to blow whatever gains they have
09:34:15 <ndm> quicksilver: consider my comments tempered appropriately :)
09:34:16 <quicksilver> ndm: FWIW, GTK is not part of the Gnome project I don't believe
09:34:26 * nominolo uses emacs' ido-mode. now graphical dialogs suck even more
09:34:31 <ndm> quicksilver: they are very linked though :)
09:34:50 <ndm> i.e. QT isn't part of the KDE project, but if you kill of QT you kill KDE too
09:36:15 <ndm> filepickers were originally designed because the computer couldn't have an open "explorer" and a program at the same time, the original intention was that you should drag/drop between the two
09:37:20 <dcoutts_> ndm: the gnome folks wanted to do that, but people screamed :-)
09:37:29 <dcoutts_> they're all too used to having these file pickers
09:37:43 <ndm> dcoutts_ rightly so, its probably a better way, but will be a painful transition
09:37:55 <ndm> i have never used WinHug's file picker, for example, i always use drag and drop
09:38:05 <dcoutts_> as I recall, the Acorn RiscOS did do it that way, you dragged from the save box to your floppy disk
09:38:32 <dcoutts_> but it doesn't work well with full-screen apps
09:39:01 <ndm> i think xmonad solves all those problems :)
09:39:39 <dcoutts_> only as long as you can switch windows while dragging something
09:40:12 <ndm> you can in windows
09:40:31 <ndm> but i meant for xmonad partitioning the screen - you can imagine a small window for the file system in the corner
09:41:07 <fasta> Completed 205500 test(s) without failure.
09:41:14 <fasta> Seems to be working :)
09:44:30 <lindzeyn> question, Integral (randomIO) :: Int ... =/ won't work will it?
09:45:07 <lindzeyn> fromIntegral*
09:45:22 <jcreigh> :t randomIO
09:45:27 <lambdabot> forall a. (Random a) => IO a
09:45:34 <jcreigh> :t fromIntegral
09:45:36 <lambdabot> forall a b. (Num b, Integral a) => a -> b
09:45:47 <lindzeyn> welp that answered that
09:45:50 <jcreigh> see the problem?
09:45:59 <lindzeyn> yes
09:46:21 <oerjan> lindzeyn: i think you might mean liftM fromIntegral randomIO
09:46:36 <oerjan> which won't work either because of type ambiguity.
09:46:40 <lindzeyn> I didnt mean that, but what does that do?
09:46:43 <lindzeyn> ah
09:46:52 <jcreigh> lindzeyn: what you are trying to do?
09:47:00 <jcreigh> if you want a random Int, you can just do:
09:47:02 <lindzeyn> A monad would get around this correct?
09:47:02 <oerjan> it runs randomIO then applies fromIntegral to the result
09:47:04 <jcreigh> > randomIO :: IO Int
09:47:05 <lambdabot>  <IO Int>
09:47:38 <oerjan> yes, because randomIO is in the IO monad
09:48:19 <lindzeyn> but that would still give me an IO Int, not Int
09:48:36 <jcreigh> lindzeyn: yeah
09:48:48 <oerjan> to do random numbers without monads, you must pass around the StdGen
09:49:10 <oerjan> (although you probably still want to get it from IO initially)
09:49:16 <lindzeyn> Right, but I want a random seed that is determined by time()
09:49:38 <oerjan> :t getStdGen
09:49:40 <lambdabot> IO StdGen
09:50:06 <jcreigh> lindzeyn: well, you're going to have to wrap your computation in the IO monad then
09:50:15 <jcreigh> remember that you can always call pure functions, so you can do.
09:50:41 <lindzeyn> Cool, thanks. jcreigh
09:50:49 <jcreigh> randInt <- randomIO :: IO Int
09:51:03 <jcreigh> return (somePureFunction randInt)
09:51:12 <jcreigh> all inside a "do" block in the IO monad, of course.
09:51:58 <crazy_code1> can anyone please take a look at http://www.cs.york.ac.uk/fp/darcs/hscolour/docs/hscolour/Language-Haskell-HsColour-ANSI.html.
09:52:00 <lambdabot> http://tinyurl.com/yu3puh
09:52:16 <crazy_code1> I guess I require to use highlight funtion
09:52:30 <crazy_code1> But I am not sure how to use ut
09:52:33 <crazy_code1> *it
09:53:31 <malcolmw> crazy_code1: hmm, the source code seems to be missing from the haddocks
09:53:54 <dcoutts_> crazy_code1: highlight [Bold] "foobar!"
09:54:08 <crazy_code1> I tried that but I am getting an error
09:54:29 <oerjan> what error?
09:54:37 <crazy_code1> btw, i did    import Language.Haskell.HsColour.ANSI
09:54:56 <crazy_code1> error is Couldn't match expected type `[Highlight]'
09:54:56 <crazy_code1>            against inferred type `Highlight'
09:54:56 <crazy_code1>     In the first argument of `highlight', namely `Bold'
09:54:56 <crazy_code1>     In the expression: highlight Bold "Hello"
09:54:56 <crazy_code1>     In the definition of `it': it = highlight Bold "Hello"
09:55:17 <oerjan> er, highlight takes a _list_ of attributes
09:55:18 <dcoutts_> crazy_code1: did you just say: highlight Bold "foobar!"
09:55:34 <crazy_code1> Oh Ok
09:55:34 <dcoutts_> crazy_code1: ie you missed the [ ] brackets
09:55:39 <crazy_code1> yes
09:56:02 <crazy_code1> I get output as Couldn't match expected type `[Highlight]'
09:56:02 <crazy_code1>            against inferred type `Highlight'
09:56:02 <crazy_code1>     In the first argument of `highlight', namely `Bold'
09:56:02 <crazy_code1>     In the expression: highlight Bold "Hello"
09:56:02 <crazy_code1>     In the definition of `it': it = highlight Bold "Hello"
09:56:06 <crazy_code1> sorry
09:56:18 <crazy_code1> I get output as "\ESC[1mhello\ESC[0m"
09:56:21 <dcoutts_> crazy_code1: take another look at that error message and see how it corresponds to the problem, it'll help you to understand the messages next time
09:56:30 <oerjan> crazy_code1: use putStr, not print
09:56:43 <oerjan> i mean, you need to use putStr
09:56:45 <crazy_code1> Ok. Great
09:57:15 <dcoutts_> the difference is that print shows you the string, putStr outputs it directly to the terminal
09:57:18 <malcolmw> those look like the right escape codes - putStr will give them to the terminal correctly, rather than making them printable
09:57:46 <crazy_code1> putStr (highlight [Bold] "Hello") gives output  as  Interrupted
09:58:04 <dcoutts_> you pressed Ctl-C , just try it again
09:58:05 <fasta> malcolmw: do you know why ' is not allowed in cpp macros?
09:58:40 <malcolmw> fasta: because it is an incomplete lexeme in C - for a character constant
09:58:47 <malcolmw> e.g. 'x'
09:59:08 <crazy_code1> Ah its working
09:59:09 <crazy_code1> Thanks
09:59:11 <crazy_code1> :)
09:59:14 <malcolmw> fasta but ' is permitted in cpphs of course
09:59:24 <fasta> malcolmw: yes, that's one of the reasons I like cpphs :)
09:59:54 <fasta> OTOH, I hope to get rid of macros someday.
10:00:56 <malcolmw> macros are mostly replaceable by lazy evaluation in Haskell
10:01:19 <norpan> and template haskell
10:03:10 <dcoutts_> malcolmw: aye, the only annoying ones we can't do are things like platform dependent ffi calls
10:03:39 <malcolmw> cpphs is still jolly useful for conditional compilation, yes
10:04:04 <malcolmw> and I use it occasionally for improved error messages via __LINE__ and __FILE__ specials
10:04:14 <dcoutts_> malcolmw: it'd be great to be able to have some kind of cppery type thing built into the language to cope with portable access to ffi things, eg yhc could just select the right calling convention at runtime depending on the arch
10:04:28 <dcoutts_> or the right dynlib name or whatever
10:04:50 <dcoutts_> or say struct sizes
10:05:34 <dcoutts_> actually struct sizes could be done ok
10:05:44 <dcoutts_> at the moment I mean
10:06:54 <malcolmw> dcoutts_: you seem to be suggesting a runtime conditional compilation ?
10:07:28 <dcoutts_> malcolmw: well, not quite as general as that, just for ffi things
10:08:11 <dcoutts_> eg you could put in the ffi decl which platform it was for (or generic) and then yhc could select at runtime or ghc at compile time
10:08:48 <SamB> ... wouldn't that complicate the bytecode interpreters?
10:08:55 <dcoutts_> only a little
10:09:05 <dcoutts_> it'd be great for the bytecode interpreters
10:09:30 <dcoutts_> since then the same bytecode could actually run on both linux and windows, not just when you avoid using ffi
10:09:33 <SamB> would it not be slow?
10:09:37 <dcoutts_> nope
10:09:46 <dcoutts_> it uses runtime linking anyway
10:09:59 <SamB> the bytecode does, you mean?
10:10:09 <sjanssen> the conditions could likely be solved at the very beginning of execution, anyway
10:10:12 <dcoutts_> the bytecode interpreter does
10:10:17 <dcoutts_> the runtime
10:10:45 <SamB> so... what does this do to being able to ship closures across the 'net?
10:10:54 <dcoutts_> nothing :-)
10:11:01 <SamB> ah. good.
10:11:02 <dcoutts_> well, not much
10:11:26 <dcoutts_> it'd just allow the bytecode to be more portable
10:11:32 <sjanssen> it should improve the situation, yeah?
10:11:40 * SamB wonders what happens when you try to ship a Ptr across the net?
10:12:53 * dcoutts_ hands SamB 0x00002b07a2810158
10:13:19 <SamB> I was hoping it would be something more sensible like (error "don't do that you bonehead!")
10:13:20 <dcoutts_> SamB: what can you do with that? what does it point to ? :-)
10:14:19 <dcoutts_> SamB: it points to a 8 byte GHC heap object, but which one?
10:14:22 <SamB> dcoutts: what can I do with it? that doesn't even refer to a part of my address space!
10:14:28 <dcoutts_> heh heh
10:14:37 <malcolmw> GpH (glasgow parallel haskell) manages to ship heap pointers across the net without loss of information
10:14:48 <dcoutts_> > Foreign.ForeignPtr.mallocForeignPtrBytes 0
10:14:49 <lambdabot>   Not in scope: `Foreign.ForeignPtr.mallocForeignPtrBytes'
10:15:00 <malcolmw> they build a virtual shared heap though
10:15:44 <SamB> hmm, I suppose you just ship something that says "Hi! I'm a pointer to an object in this other address space!"
10:16:38 <rretzbach> Can you please point out why this isn't legal? 3 lines: http://pastie.caboo.se/74817
10:17:34 <malcolmw> rretzbach: your two uses of the list constructor (:) are opposite ways round
10:17:46 <sjanssen> rretzbach: you probably mean (pivot n xs) ++ [x]
10:17:49 <sjanssen> @type (:)
10:17:51 <lambdabot> forall a. a -> [a] -> [a]
10:17:56 <rretzbach> Ahh.
10:18:11 <rretzbach> Thank you, you two, I see. : is just vor one element.
10:18:30 <sjanssen> rretzbach: (:) is only for putting a single element on the front of a list
10:18:40 <crazy_coder> If a function accepts a list of constructors, so we can g
10:18:51 <crazy_coder> *give multiple constructors ?
10:18:57 <crazy_coder> *can we give
10:19:41 <SamB> crazy_coder: huh?
10:19:43 <malcolmw> crazy_coder: highlight [Bold,Foreground Yellow,Background Blue] "hello"
10:19:44 <Philippa> crazy_coder: could you clarify a little?
10:20:01 * Philippa figures malcolmw's answered the intended question, but hey :-)
10:20:02 <crazy_coder> malcolmw: yeah
10:20:17 <crazy_coder> malcolmw: can we do that ?
10:20:25 <malcolmw> sure
10:20:31 <Philippa> though really that's just "multiple values" - Bold, Foreground etc would all have to belong to the same type
10:20:40 <Philippa> nothing special about constructors there
10:21:05 <Philippa> highlight [1,4,9] or highlight ["this", "that"] would be valid - at least, for varying values of highlight
10:21:23 <crazy_coder> So the highlighting will be bold with Yellow foreground and Blue background ?
10:21:40 <malcolmw> try it and see
10:22:05 <crazy_coder> actually it didn't work :(
10:22:14 <crazy_coder> so i asked
10:22:22 <crazy_coder> giving it another shot
10:22:27 <malcolmw> bold yellow often looks brown
10:22:57 <crazy_coder> malcolmw: this is exactly what I did
10:23:09 <crazy_coder> So got confused. :) Its working
10:23:28 <vincenz> malcolmw: mold often looks brown too
10:23:42 <malcolmw> thank you vincenz
10:23:46 * vincenz nods
10:24:01 <crazy_coder> Thanks malcolmw, Philippa,
10:25:16 <Philippa> np, hope I wasn't too confusing for lack of context on my end
10:25:33 <fasta> @hoogle (Monad m)=> m (a -> b) -> a -> m b
10:25:35 <lambdabot> Prelude.asTypeOf :: a -> a -> a
10:25:35 <lambdabot> Prelude.const :: a -> b -> a
10:25:35 <lambdabot> Prelude.seq :: a -> b -> b
10:25:53 <glen_quagmire> -> -> lol
10:26:01 <fasta> Uhm, don't we have that function somewhere?
10:26:02 <int-e> asTypeOf?!
10:26:10 <mauke> :t flip liftM (flip id)
10:26:13 <lambdabot> forall r b c. (((b -> c) -> c) -> r) -> b -> r
10:26:22 <mauke> :t flip (liftM2 (flip id))
10:26:25 <lambdabot> forall a1 c (m :: * -> *). (Monad m) => m (a1 -> c) -> m a1 -> m c
10:26:40 <int-e> @type flip ap
10:26:43 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m (a -> b) -> m b
10:26:53 <int-e> ah, no.
10:27:10 <fasta> :t \x -> liftM ($ x)
10:27:12 <lambdabot> forall a b (m :: * -> *). (Monad m) => a -> m (a -> b) -> m b
10:27:17 <int-e> @type flip (ap . return)
10:27:19 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> b) -> m b
10:27:57 <int-e> @type flip (flip ap . return)
10:27:59 <lambdabot> forall (m :: * -> *) b a. (Monad m) => m (a -> b) -> a -> m b
10:28:07 <fasta> flip considered evil
10:28:20 <oerjan> @unpl flip (flip ap . return)
10:28:20 <lambdabot> (\ b c -> b >>= \ k -> (return c) >>= \ j -> return (k j))
10:28:41 <int-e> that's not an improvement :)
10:28:45 <mauke> :t \mf x -> do { f <- mf; return (f x) }
10:28:47 <oerjan> @list undo
10:28:47 <lambdabot> undo provides: undo redo
10:28:49 <lambdabot> forall t (t1 :: * -> *) t2. (Monad t1) => t1 (t -> t2) -> t -> t1 t2
10:28:54 <oerjan> @. redo unpl flip (flip ap . return)
10:28:54 <lambdabot> (\ b c -> do { k <- b; j <- (return c); return (k j)})
10:29:14 <mauke> @pl \mf x -> mf >>= \f -> return (f x)
10:29:15 <lambdabot> flip (fmap . flip id)
10:29:18 <fasta> Now, all we need is a good name.
10:29:32 <fasta> applyM?
10:29:54 <rretzbach> fooBAR
10:30:19 <fasta> rretzbach: taken already
10:33:11 <int-e> @type (. return) . ap
10:33:14 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> a -> m b
10:33:29 <int-e> no flip :)
10:33:36 <int-e> (sections of . are evil too, though)
10:34:44 * SamB still doesn't know how to do blinkenlight widgets...
10:34:46 <crazy_coder> whats the difference between mapM and map ?
10:34:48 <crazy_coder> @src mapM
10:34:49 <lambdabot> mapM f as = sequence (map f as)
10:34:50 <crazy_coder> @ src mapM
10:34:57 <fasta> crazy_coder: it in the list monad, nothing
10:35:05 <mauke> fasta: do you mean fmap?
10:35:23 <int-e> crazy_coder: mapM results in a sequence of monadic actions.
10:35:24 <fasta> mauke: yes, I shouldn't respond so fast
10:35:24 <olsner> > mapM (+ 1) [1,2,3]
10:35:25 <lambdabot>   add an instance declaration for (Show (m [b]))
10:35:26 <SamB> > map (:[]) "Hello!"
10:35:28 <lambdabot>  ["H","e","l","l","o","!"]
10:35:32 <SamB> > mapM (:[]) "Hello!"
10:35:34 <lambdabot>  ["Hello!"]
10:35:58 <int-e> crazy_coder: and returns the result in a monad
10:36:06 <ptolomy> Eep. Just sent my first message to the Cafe. Now I can't claim to just be a lurker anymore.
10:36:07 <mauke> > mapM (replicate 2) "hello"
10:36:09 <lambdabot>  ["hello","hello","hello","hello","hello","hello","hello","hello","hello","he...
10:36:12 <int-e> > mapM (+) [1,2,3,4] 2
10:36:14 <lambdabot>  [3,4,5,6]
10:36:25 <int-e> (sorry)
10:36:51 <mauke> > mapM (replicate 2) "abc"
10:36:53 <lambdabot>  ["abc","abc","abc","abc","abc","abc","abc","abc"]
10:37:08 <rretzbach> huh?
10:37:12 <oerjan> eek
10:37:21 <mauke> ah
10:37:33 <rretzbach> Who wrote the bot? :>
10:38:08 <mauke> it will write itself and send itself back in time
10:38:12 <oerjan> > map (replicate 2) "abc"
10:38:15 <lambdabot>  ["aa","bb","cc"]
10:38:33 <int-e> > mapM (:'-':[]) "abc"
10:38:35 <lambdabot>  ["abc","ab-","a-c","a--","-bc","-b-","--c","---"]
10:38:59 <rretzbach> whoa, that's nice
10:39:01 <int-e> this may be clearer than the replicate 2 example :)
10:39:04 <fasta> How can I make sure forall s a (t3 :: * -> * -> *) (m :: * -> *) isn't shown in types in ghci?
10:39:10 <int-e> the principle is the same
10:39:10 <mauke> > mapM (\x -> [x, toUpper x]) "abc"
10:39:12 <lambdabot>  ["abc","abC","aBc","aBC","Abc","AbC","ABc","ABC"]
10:39:22 <sjanssen> fasta: don't use -fglasgow-exts
10:39:36 <fasta> sjanssen: meh
10:40:21 <int-e> > map catMaybes (mapM ((:[Nothing]) . Just) "abc")
10:40:24 <lambdabot>  ["abc","ab","ac","a","bc","b","c",""]
10:40:31 <crazy_coder> Is it difficult to implement pdf reader ?
10:41:05 <fasta> crazy_coder: Probably not
10:41:12 <crazy_coder> Is there any copyright, proprietary stuff involved ?
10:41:16 <olsner> crazy_coder: all you need is two stacks and a state machine
10:41:59 <fasta> crazy_coder: there are some patents, but I don't think they hold in every country.
10:42:04 * mauke read that as "two sticks"
10:42:39 <fasta> crazy_coder: but you can always include some flag that compiles with the non-patented version, IIRC.
10:43:07 <fasta> crazy_coder: and these only become issues if you have a hugely successful reader, of which the likelyhood is small.
10:43:19 <crazy_coder> right :)
10:43:27 <fasta> crazy_coder: the specification is open
10:44:02 <fasta> There are newer internal specs, IIRC, but that's how Adobe keeps its edge.
11:05:19 <aeyakovenko> why can't i create an array with Word# as the element?  a80::(StorableArray Int Word#) <- newArray (0,79) 0; gives me an error
11:05:48 <oerjan> Word# is an unlifted type?
11:05:53 <aeyakovenko> yea
11:05:58 <aeyakovenko> Expecting a lifted type, but `Word#' is unlifted
11:06:11 <aeyakovenko> i want to use the unlifted types though
11:06:24 <oerjan> use UArray, i think
11:06:46 <fasta> UArray is not mutable.
11:06:59 <aeyakovenko> is there a mutable unboxed array?
11:07:05 <fasta> Use STUArray
11:07:09 <fasta> Or IOUArray
11:07:46 <fasta> aeyakovenko: on the other hand, you need to know you use arrays in the first place.
11:07:59 <fasta> aeyakovenko: otherwise it's just premature optimization.
11:08:22 <aeyakovenko> i get the same error with IOUArray
11:08:27 <Lemmih> StorableArray is just as unboxed as *UArray.
11:08:59 <int-e> a storablearray of Word should work then?
11:09:01 <fasta> aeyakovenko: I didn't say they allowed unlifted types.
11:09:20 <aeyakovenko> but i want to get the unlifted type out of it when i call readArray
11:09:37 <int-e> aeyakovenko: why? just unbox the result yourself
11:09:38 <fasta> aeyakovenko: what are you doing that requires those hacks?
11:09:45 <aeyakovenko> trying to make sha1 fast
11:10:08 <fasta> aeyakovenko: ok, still why not call the C version.
11:10:18 <aeyakovenko> because i want a native haskell version
11:10:27 <fasta> And why do you want a native haskell version?
11:10:27 <int-e> aeyakovenko: yes, but you can trust the compiler in that case, if you use   case readArray uarray idx of W# result ->    then the W# constructor will never actually be created.
11:11:28 <aeyakovenko> fasta, because i already know how to write fast C code, and I am learning haskell
11:11:52 <fasta> aeyakovenko: ok, that is a nice goal.
11:12:17 <aeyakovenko> so i profiled my implementation, and the part thats taking the most time is the actuall math
11:12:22 <int-e> or rather unsafeRead
11:12:38 <aeyakovenko> and i am about 10 times slower then the C version
11:13:51 <fasta> aeyakovenko: do you use lists?
11:13:59 <aeyakovenko> fasta, no arrays
11:14:15 <aeyakovenko> i am actually casting a ByteString pointer to a storable array to avoid unpacking
11:14:21 <fasta> aeyakovenko: let's stop this game, paste code if you want someone to look at it
11:14:27 <aeyakovenko> sure
11:16:07 <hpaste>  aeyakovenko pasted "my sha1 attempt" at http://hpaste.org/1435
11:16:11 <fbuilesv> Any idea of what causes a "./Setup.hs haddock" to "generate: haddock: /usr/share/ghc-6.6/html/libraries/base/base.haddock: openBinaryFile: does not exist (No such file or directory)" ?
11:17:43 <int-e> is that a warning?
11:18:18 <fbuilesv> Error I'd say, doesnt generate any documentation.
11:18:41 <int-e> I'd think that it's looking for the base library's documentation to link to. But I've never seen it as an error.
11:19:13 <Excedrin> aeyakovenko: is doList the slow part?
11:19:16 <hpaste>  (anonymous) pasted "sha1 profile" at http://hpaste.org/1436
11:20:00 <aeyakovenko> so mosf of the running time is spent doing math it seems, i cant figure out how to make it faster
11:20:00 <fbuilesv> Maybe it has something to do with the fact that Ubuntu doesnt install GHC in that directory, is there anyway to change the place where Haddock looks for doc?
11:20:10 <fbuilesv> locate
11:20:12 <fasta> aeyakovenko: 512 `div` 8 <- you should inline this value
11:20:14 <fbuilesv> mt
11:20:17 <int-e> hmm. reverse [0..7] -> [7,6..0]
11:20:24 <fasta> aeyakovenko: you also use a few lists, still
11:20:50 <aeyakovenko> the lists i dont think are an issue, and doList should be renamed, it uses an array
11:21:00 <fasta> aeyakovenko: I don't think 512 `div`  8 is evaluated at compile time
11:21:01 <int-e> actually I'm not sure whether  map ... [7,6..0]  produces good code.
11:21:06 <Excedrin> aeyakovenko: have you tried unsafeReadArray?
11:21:18 <aeyakovenko> no i havent
11:21:45 <fasta> aeyakovenko: you can define foo = 512 `div` 8  at the top-level'
11:21:52 <fasta> aeyakovenko: and then use foo
11:22:27 <aeyakovenko> ill try that, any ideas on how to make the doList function faster?
11:22:40 <Excedrin> actually, it's just unsafeRead, try replacing readArray with that
11:22:57 <fasta> aeyakovenko: bang patterns in the where clauses?
11:22:57 <aeyakovenko> Excedrin, where is it defined?
11:23:12 <fasta> aeyakovenko: I have not written such overly optimized code, myself though.
11:23:26 <aeyakovenko> fasta, this is my first attempt :)
11:23:34 <fasta> I'd rather just fix the compiler myself.
11:23:50 <aeyakovenko> hehe, i was thinking of using the x86 extension
11:24:31 <Excedrin> Data.Array.Base
11:24:57 <fasta> aeyakovenko: also, strictness doesn't always make code faster.
11:25:23 <aeyakovenko> fasta, i've experimented with the profiler, it seems that this is as fast at it will go
11:25:23 <fasta> aeyakovenko: but I cannot give you rules on when it will help you or not.
11:25:23 <Excedrin> but for sha1, you probably want as much strictness as possible
11:25:41 <fasta> Excedrin: yes, in this case, I would think that too
11:25:56 <fasta> aeyakovenko: you should check the Core that is generated.
11:25:58 <aeyakovenko> Excedrin, i cant seem to find the docs for it
11:26:03 <int-e> aeyakovenko: I'd write doList20, doList40, doList60 and doList80 functions.
11:26:32 <Excedrin> http://haskell.org/haskellwiki/Performance/Arrays
11:26:33 <lambdabot> Title: Performance/Arrays - HaskellWiki
11:26:42 <int-e> aeyakovenko: probably in terms of a doList function that gets ff and kk as arguments.
11:27:03 <Excedrin> undocumented :)
11:27:13 <fasta> aeyakovenko: also doing conversion of any kind is a bad idea.
11:27:33 <aeyakovenko> what kind of conversion?
11:27:35 <fasta> aeyakovenko: The C version doesn't convert anything, IIRC.
11:27:55 <fasta> aeyakovenko: ByteString to Word*
11:28:04 <aeyakovenko> i am not converting
11:28:12 <fasta> aeyakovenko: wasn't there some mailing list topic about this?
11:28:22 <aeyakovenko> i am just taking the raw C pointer, and casting it to a StorableArray of type Word32
11:28:28 <aeyakovenko> it shouldn't do any marshalling
11:28:30 <int-e> aeyakovenko: turning ff into a 3 argument function obviously.
11:29:03 <Saizan> return $! ((temp ww), aa, (sRotateL bb 30), cc, dd) <-- here $! is useless, it just check that the (,,,,) constructor is there
11:29:19 <aeyakovenko> yea, i was bitching on how crypto is slow, and dons suggested that i need to use bytestrings, so here i am
11:29:59 <gour> vim/emacs users can check new pida http://pida.co.uk/ (is supports darcs too)
11:30:01 <lambdabot> Title: PIDA Community loves you!
11:30:11 <Saizan> ?docs Data.Array.MArray
11:30:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-MArray.html
11:31:00 <aeyakovenko> i am surprised that hack of casting bytestring data to an array worked
11:31:04 <aeyakovenko> i thought it would blow up
11:31:07 <fasta> aeyakovenko: the reason it is "slow" is 1) that you are new to Haskell 2) GHC doesn't do optimizations you would expect it to do 3) The C version probably has had a lot of work. 4) Haskell uses higher-order functions where the C version just inlines loops. (in no particular order)
11:31:52 <Excedrin> 5) it's very difficult to get 50% of C performance for low level bit twiddling code in Haskell
11:32:06 <Saizan> aeyakovenko: doList just reads a single element from the array, right?
11:32:09 <aeyakovenko> fasta, i agree with you, but i would like to know how to make haskell/ghc run as fast as possible, i plan on using haskell in teh future
11:32:23 <aeyakovenko> Saizan, yea, its badly named atm, i rewrote it a couple of times
11:32:32 <fasta> aeyakovenko: I also use it _now_. The problems I solve cannot be solved with C, so it doesn't matter.
11:32:45 <fasta> aeyakovenko: in theory, of course they can, in practice, no.
11:33:06 <Excedrin> fasta: what's an example?
11:33:28 <int-e> Saizan: yes. And I can't see the compiler optimize the ffkk calls nicely so I think splitting doList into 4 functions will help.
11:33:57 <aeyakovenko> fasta, i work on embedded OS, so i have a lot of interest in having correct code that is small and runs fast, hopefully haskell will get there one day, C sure isn't going anywhere fast
11:34:19 <olsner> is that haskell code derived from the C code or from a short-and-sweet haskell rendering of the algorithm?
11:34:31 <aeyakovenko> olsner, hehe, from the wikipedia page on sha1
11:34:36 <fasta> aeyakovenko: if you want correct code that runs fast, why not use Coq and compile to the fastest platform?
11:34:45 <aeyakovenko> olsner, thats not a bad idea, i bet the C version is optimized
11:35:02 <Saizan> i thinks rewriting the foldM doList, in terms of foldr , a doList that takes (i,e) as parameter, and getAssocs would improve the performance
11:35:09 <olsner> I was rather aiming for the opposite ;-)
11:35:25 <aeyakovenko> fasta, whats Coq
11:35:30 <hpaste>  jimitheking pasted "jimitheking" at http://hpaste.org/1437
11:35:37 <fasta> aeyakovenko: Coq is a proof assistant.
11:35:54 <fasta> aeyakovenko: you can proof that your code is correct, but its learning curve is rather steep.
11:36:16 <aeyakovenko> fasta, interesting, ill take a look at it, does it work with C?
11:36:25 <int-e> oh great, we got spam :/
11:36:36 <olsner> I imagine that an optimized short-n-sweet program is less salty than "C written in haskell"-style programs
11:37:30 <fasta> aeyakovenko: It compiles to Haskell, Scheme and OCaml and maybe more.
11:37:49 <fasta> aeyakovenko: and since you can call C from all of those, I guess the answer is yes.
11:38:44 <fasta> aeyakovenko: note that Haskell is more practical than Coq currently for some value of practical.
11:38:53 <olsner> aeyakovenko: another idea: just steal a "super-optimized" assembly version off the net then call it with FFI
11:39:08 <fasta> olsner: he wants to learn something, scroll up
11:39:11 <aeyakovenko> olsner, i was thinking of using the x86 extension, Adam or something
11:40:15 <fasta> aeyakovenko: what x86 extension/
11:40:21 <olsner> oh, a bit of jump in late and shoot tips from the hip sneaked into me there
11:40:44 <aeyakovenko> adam i think, i saw it a couple of weeks ago on the mailing list, you can compile x86 assembly inside haskell, if i am not mistaken
11:41:37 <aeyakovenko> oh, its Harpy
11:41:44 <aeyakovenko> http://uebb.cs.tu-berlin.de/harpy/
11:43:08 <mauke> http://mauke.ath.cx/stuff/haskell/hell.hs
11:43:30 <fasta> mauke: Hello from hell?
11:43:44 <mauke> well, it compiles to hell.o
11:44:13 <olsner> what does mkFun look like?
11:44:27 <mauke> foreign import ccall "dynamic" mkFun :: FunPtr (IO ()) -> IO ()
11:44:33 <olsner> doesn't it need some other object file to provide the definition?
11:44:39 <mauke> nope, it's "dynamic"
11:45:18 <mauke> you can download this file and runghc it as-is
11:45:30 <olsner> but what's mkFun?
11:45:30 <mauke> well, assuming you have linux/x86
11:45:55 <mauke> something that turns function pointers into IO actions
11:46:23 <olsner> but it has no source, and you said it didn't get pulled in from another object file.. so what is it?
11:46:28 <olsner> magic?
11:46:38 <SamB> it's a wrapper
11:46:47 <SamB> or a wrapper generator...
11:46:56 <mauke> The second and third alternative, identified by the keywords dynamic and wrapper, respectively, import stub functions that have to be generated by the Haskell system. In the case of dynamic, the stub converts C function pointers into Haskell functions; and conversely, in the case of wrapper, the stub converts Haskell thunks to C function pointers.
11:47:00 <SamB> that "foreign" thing *is* the definition
11:48:02 <fasta> mauke: what are all the numbers in that string?
11:48:31 <mauke> opcodes
11:48:40 <fasta> mauke: and what do they do?
11:48:52 <olsner> okay, so "dynamic" asks the system to generate the implementation of a function that converts FunPtr's into functions? but why doesn't the system just include a function called mkFun in the library?
11:49:00 <fasta> I know what an opcode is just not what those do :)
11:49:11 <mauke> fasta: it prints "Hello, world!"
11:49:13 <SamB> fasta: disassemble them to find out
11:49:15 <aeyakovenko> the cool thing is at least my sha1 runs in constant time, the crypto one seems to blow up
11:50:02 <SamB> ghc -e 'putStr "\232\14\0\0\0Hello, world!\n\186\14\0\0\0\89\187\1\0\0\0\184\4\0\0\0\205\128\49\192\195"' | ndisasm -
11:50:20 <SamB> hmm.
11:50:24 <SamB> maybe I need to set 32-bit mode
11:50:43 <SamB> ghc -e 'putStr "\232\14\0\0\0Hello, world!\n\186\14\0\0\0\89\187\1\0\0\0\184\4\0\0\0\205\128\49\192\195"' | ndisasm -b32 -
11:50:48 <aeyakovenko> would making the + strict make a difference?
11:51:23 <mauke> SamB: yeah, that's better :-)
11:52:13 <fasta> SamB: that command doesn't work here
11:52:47 <mauke> fasta: http://rafb.net/p/un1SV694.html
11:52:48 <lambdabot> Title: Nopaste - No description
11:53:02 <fasta> Ok, I put it in a file now. And now it works
11:53:05 <hpaste>  SamB pasted "hell disassembled" at http://hpaste.org/1438
11:53:30 <olsner> it seems the program has garbage on the end that isn't actually part of the hello world stuff
11:53:40 <fasta> Hmm, ok, and now you expect me to read this?
11:53:48 <mauke> olsner: where?
11:53:51 <SamB> olsner: that's for returning true...
11:54:01 <olsner> I'm not getting the same output from ndisasm
11:54:06 <SamB> fasta: you could order manuals from intel
11:54:12 <SamB> olsner: what do you get?
11:54:22 <SamB> olsner: did you do it with or without -b32?
11:54:36 <olsner> with
11:54:38 <fasta> SamB: Do you have manuals from intel?
11:54:43 <SamB> fasta: yes. they be free!
11:54:47 <hpaste>  olsner annotated "hell disassembled" with "the garbage at the end" at http://hpaste.org/1438#a1
11:55:02 <fasta> SamB: are they free for individuals?
11:55:07 <mauke> yes
11:55:19 <SamB> fasta: I may have filled in something for a "company" field
11:55:20 <fasta> Last time I tried to order them they weren't.
11:55:27 <SamB> but it should have been clearly bogus
11:55:28 <fasta> SamB: :)
11:55:44 <SamB> then again, the first time I just sent 'em an email...
11:55:46 <olsner> up until those instructions, the disassembly is the same
11:56:00 <SamB> so I wouldn't have had to fill in a company field...
11:56:11 <mauke> olsner: those look a bit like terminal escape sequences
11:56:47 <mauke> ^[[?1034h
11:57:19 <olsner> aha! that's an escape sequence
11:57:33 <olsner> but what's it do.. hmm... weird
11:58:47 <SamB> wow, that's tight code
11:59:18 <fasta> mauke: but what does your code do?
11:59:35 <mauke> <mauke> fasta: it prints "Hello, world!"
11:59:44 <SamB> intel manuals are at http://www.intel.com/products/processor/manuals/index.htm
11:59:47 <lambdabot> Title: Intel&reg; 64 and IA-32 Architectures Software Developer's Manuals
12:00:27 <fasta> mauke: yes, but besides that?
12:00:32 <mauke> nothing
12:00:43 <SamB> fasta: what about the Haskell code?
12:00:46 <SamB> er.
12:00:47 <SamB> mauke:
12:00:50 * SamB args
12:01:10 <mauke> the haskell code invokes the machine code stored in "code", then exits
12:03:35 <mauke> withCString allocates a suitable byte buffer and copies the code into it. castPtrToFunPtr is a no-op on x86. mkFun then turns the function pointer into an IO action, which is finally bound to main
12:03:37 <fasta> SamB: did you order them all in one email?
12:04:04 <mauke> so using this trick you can execute arbitrary machine code
12:06:24 * olsner calls on Scotty for auxiliary power to his laptop
12:07:09 <fasta> SamB: do they also ship outside the US?
12:14:05 <gkr> Is there anyfunction for tokens in Haskell?
12:14:28 <fasta> Ok, so much for Haskell not giving "access" to the machine.
12:14:40 <sjanssen> fasta: FFI gives you the full power of C
12:14:51 <fasta> sjanssen: Yes, I know that.
12:15:04 <sjanssen> so allowing evil things is actually a design goal :)
12:15:08 <SamB> fasta: that, I don't know
12:15:12 <sjanssen> for the FFI, at least
12:15:24 <fasta> Is this also what harpy does?
12:15:30 <fasta> This evil thing I mean?
12:15:42 <SamB> fasta: I imagine Harpy does it with less evil ;-)
12:15:52 <fasta> MORE EVIL!!!
12:15:53 <sjanssen> fasta: probably something quite similar
12:16:28 <fasta> I played with assembly code to understand how buffer overflows worked, but that's about it.
12:16:29 <SamB> for instance, I don't think harpy would (a) need position-independant code or (b) use linux syscalls
12:16:30 <olsner> I'm still bothered that the assembly wasn't minimal in size
12:16:42 <SamB> olsner: what?
12:17:01 <SamB> you mean that escape code that sneaked in for you?
12:17:16 <SamB> or you think it could use shorter "mov" forms?
12:17:36 <ihope> @index hPutStrLn
12:17:36 <lambdabot> System.IO
12:17:46 <olsner> I think I can think of a few tricks to shave off a few bytes (besides removing the escape sequence).. yeah, movz was the first thing I thought of
12:18:11 <SamB> olsner: escape sequence wasn't in the string
12:18:18 <sjanssen> gkr: perhaps you want groupBy or takeWhile?
12:18:50 <olsner> that was something with my terminal settings.. calling TERM=vt100 ghc fixed it
12:19:12 <fasta> Are there any terminals that don't get all weird when they print binary stuff?
12:19:26 <fasta> I don't understand why that happens anyway.
12:19:48 <fasta> I use reset to well reset it, but it seems stupid that I need to do that.
12:21:06 <olsner> but my terminal didn't actually even print it! it just got inserted into a pipe
12:21:41 <gkr> sjanssen what does groupBy do?
12:21:43 <ihope> @hoogle buffer
12:21:47 <lambdabot> System.IO.BufferMode :: data BufferMode
12:21:47 <lambdabot> Network.Socket.RecvBuffer :: SocketOption
12:21:47 <lambdabot> Network.Socket.SendBuffer :: SocketOption
12:21:50 <sjanssen> @docs Data.List
12:21:50 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
12:21:53 <sjanssen> gkr: ^^^
12:22:09 <gkr> Thanks.
12:22:47 <fasta> I take that as a no?
12:23:22 <dcoutts> aeyakovenko: there's several things you could do to make that code faster, just from a quick look here's a few (I don't know if they're in the inner loop or not)
12:23:49 <dcoutts> word64ToWord8s looks slow, that reverse [0..7] isn't going to fare well
12:23:57 <fasta> dcoutts: already said
12:24:00 <dcoutts> and it producing a list should make you worry
12:24:09 <dcoutts> it'll only be fast if it's inlined and fused
12:24:17 <dcoutts> fasta: oh ok
12:24:19 <fasta> dcoutts: scroll up
12:24:35 <olsner> I wonder if <16-bit prefix> call <16-bit address> would work
12:26:34 <dcoutts> aeyakovenko: did anyone explain that return $! (blah, blah, blah) does not do what you think it does ?
12:26:59 <dcoutts> aeyakovenko: and BS.copy (BS.append xh yh) is just a slower version of BS.append xh yh
12:27:19 <olsner> movz should take 2 or 3 bytes off of those three moves.. and you could ignore returning 0 (what does the FFI do to the return value? does it have to be zero?)
12:27:50 <dcoutts> aeyakovenko: since strict ByteStrings are just big chunks of memory, append creates a new chunk, so copying it is pointless
12:28:03 <dcoutts> the only time one might want to copy is if one is making a substring
12:28:22 <dcoutts> because that shares the block, and copy unshares it, which might allow the parent block to be GC'ed
12:28:38 <dcoutts> otherwise it just slows things down by doing more memory allocation and copying
12:29:18 <dcoutts> aeyakovenko: I presume someone suggested unpacking all the fields in Word160
12:35:48 <aeyakovenko> dcoutts, yea, fasta it hinke xplained to me that the $! is pointless there
12:36:44 <aeyakovenko> dcoutts, yep, i know its slower, but i dont want to hang on to the entire string, and it will only occur once per hash, and the profiler doesn't think its a problem
12:37:03 <dcoutts> aeyakovenko: no, it really does nothing for you at all
12:37:12 <dcoutts> it just copyies it twice rather than once
12:37:19 <aeyakovenko> dcoutts, what do you mean by unpacking?  like using Word#?
12:37:34 <dcoutts> since append constructs a new bytestring anyway, copying it is pointless
12:37:54 <dcoutts> BS.copy (BS.append xh yh) = BS.append xh yh
12:38:22 <aeyakovenko> dcoutts, ok, thats fine
12:38:51 <dcoutts> all this use of IO seems a bit fishy to me
12:38:56 <chr1s> evening everyone!
12:39:36 <aeyakovenko> dcoutts, i need to use a mutable array for the intermediate hashes, so far my implmementation is 33 times slower the C, the crypto one is 450 times slower, and blows up in memory
12:39:53 <dcoutts> aeyakovenko: I'd use an unboxed mutable array of Word32 in the ST monad
12:40:10 <aeyakovenko> dcoutts, i think fasta said taht the storablearray is unboxed as well
12:40:19 <dcoutts> it is
12:40:49 <sjanssen> aeyakovenko: is the one in crypto using ByteString or [Char]?
12:41:00 <dcoutts> [Char] iirc
12:41:01 <aeyakovenko> sjanssen, it uses word8
12:41:08 <aeyakovenko> so you have to unpack, i am not unpacking
12:41:19 <dcoutts> there's a fast sha1 in darcs if I remember correctly
12:41:34 <aeyakovenko> dcoutts, it probably uses openssls sha1
12:41:42 <dcoutts> aeyakovenko: no it doesn't
12:42:08 <dcoutts> at least it didn't last time I looked
12:42:33 <aeyakovenko> dcoutts, cool, ill take a look at it
12:42:42 <chr1s> is there a function with a type signature that looks something like this:
12:43:13 <chr1s> :: Data a => (a -> b) -> a -> b
12:43:37 <chr1s> which recursively traverses over all the children (either bottom-up or top-down)
12:43:40 <olsner> :t (flip ($))
12:43:42 <dcoutts> aeyakovenko: yep, it provides sha1PS :: PackedString -> String
12:43:42 <lambdabot> forall a b. a -> (a -> b) -> b
12:43:43 <nominolo> @hoogle Data a => (a -> b) -> a -> b
12:43:44 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
12:43:44 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:43:44 <lambdabot> Data.Generics.Basics.gmapQi :: Data a => Int -> (a -> u) -> a -> u
12:43:46 <dylan> @hoogle (Data a) => (a -> b) -> a -> b
12:43:47 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
12:43:47 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
12:43:47 <lambdabot> Data.Generics.Basics.gmapQi :: Data a => Int -> (a -> u) -> a -> u
12:44:01 <dcoutts> aeyakovenko: where PackedString is an old version of ByteString that's included in darcs
12:44:07 <gkr> Is there any function that does this: tok [1,2,3,4] 2 = ([1],[3,4]), it partitionates the list by an element?
12:44:23 <chr1s> @hoogle split
12:44:24 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
12:44:24 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
12:44:24 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
12:44:26 <dylan> @hoogle partition
12:44:26 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
12:44:26 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
12:44:26 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
12:44:32 <chr1s> ah, partition
12:45:18 <apfelmus> > partition (2==) [1,2,3,4]
12:45:21 <lambdabot>  ([2],[1,3,4])
12:45:22 <nominolo> chr1s: maybe in SYB or that new stuff by noil
12:45:28 <nominolo> *Neil
12:45:45 <chr1s> yeah
12:46:06 <gkr> Nope, I meant something more like splitAt + elemIndex
12:46:10 <apfelmus> @hoogle a -> [a] -> ([a],[a])
12:46:11 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
12:46:11 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
12:46:14 <hpaste>  aeyakovenko pasted "sha1 with profile output" at http://hpaste.org/1439
12:46:30 <gkr> splitAt (elemIndex 'x') ['a','b','x','d']
12:46:35 <gkr> > splitAt (elemIndex 'x') ['a','b','x','d']
12:46:36 <chr1s> or alternatively: is there a function that gets a list of all the children of a data-constructor?
12:46:36 <lambdabot>  Couldn't match expected type `Int'
12:46:46 <gkr> > splitAt (elemIndex 'x' ['a','b','x','d'])
12:46:47 <lambdabot>  Couldn't match expected type `Int'
12:46:51 <gkr> Oh, maybe int.
12:47:01 <dmhouse> ?hoogle splitAt
12:47:01 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
12:47:01 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
12:47:01 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
12:47:06 <dmhouse> ?hoogle elemIndex
12:47:06 <lambdabot> List.elemIndex :: Eq => a -> [a] -> Maybe Int
12:47:06 <lambdabot> Data.List.elemIndex :: Eq a => a -> [a] -> Maybe Int
12:47:13 <chr1s> so that would be something like :: Data a => a -> [a]
12:47:58 <aeyakovenko> oh ok, i think the way they do the math is really optimized, cool, ill try it
12:48:00 <apfelmus> > span (==2) [1,2,3,4]
12:48:01 <lambdabot>  ([],[1,2,3,4])
12:48:05 <dmhouse> >let xs = "abxd" in splitAt (fromJust $ elemIndex 'x' xs) xs
12:48:13 <nominolo> anyone happen to know an irssi script that allows to set special colors for special nicks (like lambdabot)?
12:48:17 <dmhouse> > let xs = "abxd" in splitAt (fromJust $ elemIndex 'x' xs) xs
12:48:19 <lambdabot>  ("ab","xd")
12:48:21 <apfelmus> > break (2==) [1,2,3,4]
12:48:23 <lambdabot>  ([1],[2,3,4])
12:48:28 <dylan> nominolo: /hilight
12:48:40 <hpaste>  sjanssen annotated "my sha1 attempt" with "don't use tuples" at http://hpaste.org/1435#a1
12:48:43 <dylan> it's no script. :)
12:48:49 <sjanssen> aeyakovenko: ^^^
12:48:53 <apfelmus> gkr: break is what you want
12:49:10 <sjanssen> aeyakovenko: I get a small performance boost by using -funbox-strict-fields and replacing your tuples with Word160
12:49:29 <gkr> Thanks apfelmus
12:49:33 <aeyakovenko> sjanssen, i am building with -O2 -fexcess-precision -funbox-strict-fields -fglasgow-exts -fbang-patterns
12:49:47 <apfelmus> gkr: and a full hoogle search reveals that, too :)
12:49:59 <sjanssen> aeyakovenko: I suggest you place those flags in an OPTIONS_GHC pragma -- it's nice documentation
12:50:06 <aeyakovenko> sjanssen, i think this is why mine is slow http://abridgegame.org/cgi-bin/darcs.cgi/darcs/src/SHA1.lhs?c=annotate
12:50:19 <aeyakovenko> take a look at how the darcs guys do the math
12:50:34 <sjanssen> aeyakovenko: I think you can take yours a bit further
12:50:48 <sjanssen> look for some key places to add strictness
12:51:00 <nominolo> dylan: i'd like to dim it, though
12:51:07 <dylan> nominolo: -color
12:51:10 <apfelmus> gkr: (http://haskell.org/hoogle, not google)
12:51:12 <lambdabot> Title: Hoogle
12:51:26 <nominolo> dylan: ah.  i take look
12:53:57 <ihope> Okay, I just got dons' fps-0.7 and I'm trying to install it under Windows using Cygwin.
12:54:54 <ihope> "bash: ./Setup.hs: /usr/bin/env: bad interpreter: No such file or directory"
12:55:33 <ihope> I notice that the shebang says "/usr/bin/env runhaskell", so I'm guessing I need to add runhaskell to it.
12:55:50 <nominolo> > "test"
12:55:52 <lambdabot>  "test"
12:56:30 <aeyakovenko> sjanssen, how can i turn a Word32 into a Word#?
12:57:21 <ihope> aeyakovenko: unapply the W32# constructor, I think.
12:57:40 <ihope> \(W32# x) -> x
12:58:50 <ihope> @index W32#
12:58:50 <lambdabot> bzzt
12:58:52 <nominolo> @where cabal
12:58:52 <lambdabot> http://www.haskell.org/cabal
12:58:55 <ihope> It's in GHC.Word, I think.
12:59:12 <olsner> isn't fps included in recent GHC's?
12:59:14 <ihope> ...Oh, does Cabal have runhaskell?
12:59:22 <ihope> I have 6.4.1.
12:59:51 <ihope> I guess there's nothing keeping me from upgrading.
13:01:41 <nominolo> @users
13:01:41 <lambdabot> Maximum users seen in #haskell: 354, currently: 305 (86.2%), active: 16 (5.2%)
13:02:17 <treble> > maxBound :: Int
13:02:20 <lambdabot>  2147483647
13:02:22 <aeyakovenko> wow, i got double performance improvement in using Word160 instead of tuples
13:02:25 <treble> :( 32-bit
13:02:45 <treble> *Main> maxBound :: Int
13:02:45 <treble> 9223372036854775807
13:02:50 <treble> woot ;)
13:03:26 <aeyakovenko> i am only 40 times slower then C now :)
13:04:33 <aeyakovenko> and i also made + strict
13:07:50 <nominolo> @quote
13:07:50 <lambdabot> lennart says: [August 1990] DON'T BLAME HASKELL WHEN THINGS GO WRONG
13:08:20 <norpan> BLAME CANADA
13:09:08 <nominolo> @quote canada
13:09:08 <lambdabot> No quotes match. Your mind just hasn't been the same since the electro-shock, has it?
13:09:56 <norpan> @quote monad
13:09:57 <lambdabot> mwc says: There's a time when your brain doesn't get the monads. Then something violent and irreversable happens and you hate every other language for not having monads
13:10:23 <sjanssen> aeyakovenko: oh god, the darcs code is horrible!
13:10:43 <norpan> how good is darcs nowaday apart from the code being horrible?
13:11:14 <aeyakovenko> sjanssen, they skip a step taht i am doing, which is expanding the 16 words from the string into a 80 word array
13:11:33 <sjanssen> aeyakovenko: yeah, but they have 80 lines of boilerplate
13:12:11 <nominolo> @hoogle rawsystem
13:12:15 <lambdabot> System.Cmd.rawSystem :: String -> [String] -> IO ExitCode
13:13:13 <aeyakovenko> sjanssen, its not like what i am doing is very functional either
13:14:51 <host`> hmm
13:15:02 <sjanssen> aeyakovenko: this isn't a question of purity -- it's the fact that they unroll that loop by hand
13:15:06 <host`> so this is where you spend your free time when not in cheggit encryptio
13:15:15 * encryptio whacks host`
13:15:43 <encryptio> here, among (19) other places
13:17:36 <nominolo> dylan, nay idea why this deos not werk?  /hilight -line -color %G -mask lambdabot!*@*
13:17:48 <dylan> dunno, I always use:
13:18:09 <dylan>  /hilight -nick -mask lambdabot* -color %G
13:18:19 <dylan> > "test"
13:18:20 <lambdabot>  "test"
13:18:35 <nominolo> > t
13:18:36 <lambdabot>   Not in scope: `t'
13:18:50 <dylan> hmm
13:18:55 <nominolo> doesn't work :/
13:19:33 <nominolo> > scrt 42
13:19:34 <lambdabot>   Not in scope: `scrt'
13:19:49 <olsner> scrt?
13:19:51 <dylan> one momenent
13:19:57 <nominolo> > sqrt 42
13:19:59 <lambdabot>  6.48074069840786
13:20:00 <rretzbach> > rj 45
13:20:01 <lambdabot>   Not in scope: `rj'
13:20:01 <dylan> I have 21 hilights and I always have to remember the right syntax
13:20:23 <dylan> > 2
13:20:25 <lambdabot>  2
13:20:42 <vincenz> > (2pi)**@
13:20:42 <lambdabot>  Parse error
13:20:43 <vincenz> > (2pi)**2
13:20:45 <lambdabot>   add an instance declaration for (Num (a1 -> a))
13:20:49 <vincenz> > (2*pi)**2
13:20:50 <lambdabot>  39.47841760435743
13:21:21 <dylan> > 1 + 2
13:21:24 <lambdabot>  3
13:21:27 <dylan> aha!
13:21:33 <oerjan> :t 2pi
13:21:36 <lambdabot> forall t. (Num (Double -> t)) => t
13:21:43 <dylan> /hilight -color %G -nick -mask *i=dons* works, but doesn't distinguish dons from lambdabot
13:21:56 <oerjan> o_O
13:21:57 <vincenz> 2pi == 2 pi
13:22:05 <vincenz> = apply 2 as function to pi
13:22:15 <vincenz> 2 is of typeclass Num
13:22:20 <vincenz> so you need a function in the Num typeclass
13:22:30 <vincenz> taking a double (pi)
13:22:44 <dylan> > 1
13:22:44 <SamB> @tell JohnMeacham you left a "hiding (join)" out of Grin.NodeAnalyze
13:22:45 <lambdabot> Consider it noted.
13:22:46 <lambdabot>  1
13:22:48 <oerjan> it's not the type class that worries me, it's the lexical analysis
13:22:52 <nominolo> > (0 :+ 1)**2
13:22:54 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:22:57 <dylan> nominolo:
13:22:59 <vincenz> oerjan: it's two separate tokens
13:23:05 <dylan> /hilight -color %G -nick -mask lambdabot*i=dons*
13:23:24 <vincenz> > (0 :+ 1) ^ 2
13:23:26 <lambdabot>  (-1.0) :+ 0.0
13:24:31 <nominolo> > (exp 1)
13:24:33 <lambdabot>  2.718281828459045
13:24:43 <nominolo> yay!
13:25:18 <nominolo> > (exp 1)^(pi * (0 :+ 1))
13:25:19 <lambdabot>        add an instance declaration for (Integral (Complex t))
13:25:19 <lambdabot>     In the expr...
13:25:51 <oerjan> > (exp 1)**(pi * (0 :+ 1))
13:25:52 <nominolo> > (exp 1) ** (pi * (0 :+ 1))
13:25:53 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:25:54 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:26:35 <nominolo> > (exp 1) ** (pi * (0 :+ 1)) + 1 == 0
13:26:37 <lambdabot>  False
13:27:12 <nominolo> > (exp 1) ** (pi * (0 :+ 1)) + 1
13:27:14 <lambdabot>  0.0 :+ 1.2246063538223773e-16
13:27:43 <vincenz> > ( 0 :+ 1) ^ (0 :+ 1)
13:27:44 <lambdabot>        add an instance declaration for (Integral (Complex t))
13:27:44 <lambdabot>     In the expr...
13:27:49 <vincenz> > ( 0 :+ 1) ** (0 :+ 1)
13:27:51 <lambdabot>  0.20787957635076193 :+ 0.0
13:29:05 <tuukkah> so are we missing an exponentiation operator?
13:29:30 <oerjan> tuukkah: no, instead we have three...
13:29:44 <nominolo> > 3 ^^ 4
13:29:46 <lambdabot>  81.0
13:29:50 <LoganCapaldo> please, don't add a fourth! :)
13:29:58 <treble> ^ is for non-negative integer exponents
13:30:00 <tuukkah> i mean, can we evaluate the equation
13:30:04 <treble> ^^ is for integer exponents
13:30:11 <treble> ** is for fractional exponents
13:30:29 <oerjan> (the last also complex)
13:30:54 <treble> :t (**)
13:30:55 <tuukkah> we're missing exact complex expontents
13:30:56 <lambdabot> forall a. (Floating a) => a -> a -> a
13:31:02 <nominolo> @let i = (0 :+ 1)
13:31:03 <oerjan> which equation?
13:31:05 <lambdabot> Defined.
13:31:06 <treble> anything that is an instace of floating
13:31:53 <mehrheit> > question "Was @undef used in the last few days?"
13:31:55 <lambdabot>  True
13:32:00 <mehrheit> oh, liar
13:32:02 <Cale> tuukkah: but they'd require symbolic computation to really work with anyway
13:32:22 <tuukkah> oerjan, e^i*pi == -1
13:32:50 <Cale> > exp (0 :+ pi)
13:32:56 <norpan> e^(i*pi) to be precice
13:33:49 <oerjan> > ln i
13:34:10 <Cale> > log (0 :+ 1)
13:34:34 <Cale> ln is an abomination :) The default logarithm is the natural one :)
13:35:19 <nominolo> @seen me
13:35:27 <tuukkah> oh no, what did you do to lambdabot =-o
13:35:30 <lambdabot> me has changed nick to logancapaldo.
13:35:30 <lambdabot> logancapaldo is in #oasis and #haskell. I last heard logancapaldo speak 5m 40s ago.
13:35:32 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
13:35:33 <lambdabot>   Not in scope: `ln'
13:35:34 <lambdabot>  0.0 :+ 1.5707963267948966
13:36:28 <vincenz> log
13:37:43 <Cale> > log (-1) :: Complex Double
13:37:44 <lambdabot>  0.0 :+ (-3.141592653589793)
13:38:05 <Cale> > log (exp 1)
13:38:08 <lambdabot>  1.0
13:38:20 <Cale> > exp 1
13:38:24 <lambdabot>  2.718281828459045
13:40:00 <augustss> yo
13:40:07 <tuukkah> hmm Cale, did you mean complex exponents need symbolic computation or e and pi need symbolic computation?
13:40:46 <Cale> tuukkah: exact complex exponents would need symbolic computation
13:41:00 <tuukkah> right
13:41:24 <tuukkah> so perhaps we don't need the operator in haskell after all :-)
13:41:31 <ihope> Oh! I don't have /usr/bin/env!
13:41:40 <augustss> which operator?
13:42:06 <tuukkah> exact complex exponentiation
13:42:30 <augustss> why only complex?
13:42:33 <tuukkah> ihope, it doesn't actually do anything, just finds runhaskell in the path
13:42:54 <ihope> Can I just change the shebang, then?
13:43:01 <augustss> > exp ** log 10
13:43:03 <lambdabot>   add an instance declaration for (Floating (a -> a))
13:43:03 <lambdabot>     In the expression: ...
13:43:15 <Cale> Well, yeah, exact rational exponentiation requires it too :)
13:43:19 <augustss> > exp 1 ** log 10
13:43:22 <lambdabot>  10.000000000000002
13:43:46 <mehrheit> > exp . log $ 10
13:43:48 <lambdabot>  10.000000000000002
13:43:50 <Cale> ihope: yes, though you probably should work out how to install it
13:44:44 <tuukkah> ihope, you don't even need to change the shebang, you can directly invoke runhaskell Setup.hs
13:45:00 <fbuilesv> Hello, does anyone know if HDBC provides a way to print to screen the results of a SQL query?
13:45:17 <ihope> "runhaskell Setup.hs configure --bindir=`pwd`"?
13:45:36 <tuukkah> i'd think so
13:45:56 <ihope> Yup, that seems to be it.
13:46:10 <treble> Haskell gives new meaning to the phrase: Who'da thunk it?
13:46:47 <ihope> Setup.hs: cannot satisfy dependency unix-any
13:46:51 <augustss> haskell has a lot of thunks
13:46:51 <ihope> Grah.
13:47:38 <ihope> So do I want a Cygwin-aware runghc or something?
13:48:11 <tuukkah> how was it, a cygwin version of all of ghc
13:48:43 <ihope> "How was it"?
13:48:57 <Lemmih> fbuilesv: How about querying the database and then printing the result?
13:48:59 <tuukkah> i've heard about something like that...
13:49:04 <dying_sphynx> hm, I can't find one cool quote here... Something like "Unfoldr you mind, filter your impure thought, mapt smt..."
13:49:13 <dying_sphynx> Do somebody remember it?
13:49:28 <fbuilesv> Lemmih: That's what I'm doing
13:49:34 <fbuilesv> The thing is, I dont know how to print the result
13:49:39 <dying_sphynx> ?quote impure
13:49:40 <lambdabot> No quotes match. Sorry about this, I know it's a bit silly.
13:49:48 <Lemmih> fbuilesv: Use print or putStrLn.
13:50:31 <fbuilesv> fetchRow (query) returns IO(Maybe  [SqlValue]), so putStrLn wont work and I have no idea how to make print work with that
13:50:57 <Lemmih> fbuilesv: Why wont putStrLn Work?
13:51:49 <aeyakovenko> fbuilesv, you want to pull that value out of the IO monad, foo <- fetchrow query
13:51:51 <fbuilesv> Because it receives a String?
13:52:06 <aeyakovenko> fbuilesv, the type of foo will be Maybe [SqlValue]
13:52:08 <oerjan> ?quote unfold
13:52:08 <lambdabot> No quotes match. That's something I cannot allow to happen.
13:52:14 <oerjan> ?quote unfoldr
13:52:14 <lambdabot> No quotes match. I feel much better now.
13:52:22 <Lemmih> fbuilesv: Then use 'show'.
13:53:06 <fbuilesv> That's why I asked if HDBC had something already built, so I dont get results like this: "Just [SqlString \"pepe\",SqlString \"gomez\"]"
13:53:10 <aeyakovenko> fbuilesv, it takes a while to wrap your brain around the monad types, but after a while it will all click
13:53:31 <fbuilesv> aeyakovenko: Progressing, not there yet but progressing :D
13:53:41 <Lemmih> fbuilesv: Oh, you want some kind of pretty-printing.
13:53:53 <fbuilesv> Something I can output to an HTML page, yes
13:54:27 <aeyakovenko> fbuilesv, you would still need to pull it out of the IO, then print it
13:54:28 <Lemmih> fbuilesv: No, nothing like that in HDBC. And rightly so, I'd add.
13:55:13 <fbuilesv> Lemmih: Something for debugging purposes wouldnt hurt I think, not HTML off course. But you might be right.
13:55:43 <fbuilesv> Let me see if I can pull this in a "nicer" way, thanks for the help :D
14:02:08 <dolio> @source Control.Monad
14:02:09 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
14:03:29 <ihope> So, um, anybody know how to get past lambdabot's unix-any dependency on Windows
14:03:55 <ihope> (Anybody have a question mark to spare I'm all out.)
14:05:04 <tuukkah> ihope, did you google for ghc cygwin?
14:05:06 <Jaak> is mallocBytes guaranteed to set allocated bytes to 0?
14:05:15 <ihope> Nope. Not a bad idea.
14:13:46 <hpaste>  kattiaboo pasted "kattiaboo" at http://hpaste.org/1440
14:14:54 <vvv> @hoogle m a -> m [a]
14:14:55 <lambdabot> Prelude.id :: a -> a
14:14:55 <lambdabot> Prelude.asTypeOf :: a -> a -> a
14:14:55 <lambdabot> Prelude.const :: a -> b -> a
14:15:01 <oerjan> more spam
14:22:51 <SamB> hmm, so why hasn't JHC's mailing list been added to gmane yet?
14:23:46 <fbuilesv> Does GHC have any restriction with multiline strings or something?
14:23:59 <SamB> fbuilesv: more than usual?
14:24:22 <fbuilesv> SamB: Depends what you understand as usual :D
14:24:37 <fbuilesv> Isnt there a way to enter a multi-line string like inserting a \ at the end of line or something?
14:24:50 <matthew-_> yes. unlines
14:24:57 <mauke> you need two \'s
14:25:00 <matthew-_> just it uses ", rather than \
14:25:08 <aeyakovenko> so the darcs sha1 is about 10 times slower then C, and 4 times faster then mine
14:25:13 <mauke> all whitespace between them will be chopped
14:25:16 <Lemmih> > "Hello\       \world"
14:25:20 <lambdabot>  "Helloworld"
14:29:09 <fbuilesv> lexical error in string/character literal at character '\n'  <--- thats what I get if I use \\
14:29:09 <fbuilesv> I know I could just ++ 2 strings but I'm guessing there's a "right" way to do it.
14:29:32 <SamB> fbuilesv: many of us just use unlines ["line 1","line 2"]
14:29:43 <SamB> usually we put a newline after the comma, though ;-)
14:30:06 <SamB> also see what Lemmih just pulled
14:30:12 <fbuilesv> Oh, I thought there was a "native" way to do it, but Ill use that then :D
14:30:29 <matthew-_> tbh, I'd question why you would want strings like that as constants
14:30:41 <fbuilesv> matthew-_: SQL query
14:30:47 <matthew-_> wrong answer!
14:30:50 <matthew-_> haskelldb?
14:30:51 <fbuilesv> :O
14:30:53 <fbuilesv>  /run
14:30:56 <fbuilesv> HDBC
14:31:06 <fbuilesv> more familiar with the SQL syntax tbh
14:31:19 <matthew-_> but... it's... not... type safe!!
14:31:35 <matthew-_> and sql injection and... and... and...
14:31:47 <fbuilesv> that's what she said
14:31:47 * matthew-_ collapses out of comic exhasperation
14:32:07 <SamB> fbuilesv: there *is* a native way to do it. Lemmih just did it to insert some gratuitous whitespace in a string literal...
14:33:17 <Igloo> SamB: Did you see Neil asking for an example in http://hackage.haskell.org/trac/ghc/ticket/1444 ?
14:33:18 <lambdabot> Title: #1444 (Template Haskell: add proper support for qualified names in non-splicing  ...
14:34:10 <fbuilesv> Wait, wrong answer :P
14:34:10 <fbuilesv> mmm, I'm just learning the language so far, nothing serious or anything.
14:34:15 * SamB wonders why JC uses so much RAM *before* parsing the modules it's supposed to compile...
14:34:18 <SamB> er.
14:34:19 <SamB> JC
14:34:21 <SamB> arg.
14:34:22 <SamB> JHC
14:35:12 <matthew-_> fbuilesv: if you're just learning the language, then I would really encourage you to do the haskell idiomatic thing from one end to the other. That way you'll get a fuller picture of haskell.
14:35:41 <Lemmih> matthew-_: Query parameters makes HDBC free of SQL injections.
14:36:19 <fbuilesv> SamB: Yes, I typed my answer before reading Lemmih's answer, that was what I was looking for
14:36:36 <matthew-_> Lemmih: ok, I'm sure. I've seen similar stuff done in Perl and JDBC. I still much prefer haskelldb to raw sql
14:37:32 <sorear> hello.
14:37:38 <matthew-_> evening
14:38:23 <fbuilesv> matthew-_: Thank you for the advince, I'll do it in both ways I guess.
14:38:41 <matthew-_> fbuilesv: that's definately a good idea
14:39:17 <sorear> @users
14:39:18 <lambdabot> Maximum users seen in #haskell: 354, currently: 307 (86.7%), active: 13 (4.2%)
14:39:43 <matthew-_> imho, haskelldb really wins out when you need to parameterise queries with more than just values - having the sql as a normal haskell function is much safer and more powerful then combining various snippets of sql-strings together
14:40:39 <MyCatVerbs> What's the ratio of Europeans to Americans to the rest of the world here, out of curiosity?
14:41:30 <matthew-_> by number or mass?
14:41:36 <MyCatVerbs> It was much busier here around 11:00 GMT than it is now around 22:40, despite those times being roughly six in the morning and early evening Stateside.
14:41:40 <LoganCapaldo> by volume!
14:41:43 <Lemmih> MyCatVerbs: http://www.haskell.org/hawiki/HaskellUserLocations
14:41:44 <lambdabot> Title: HaskellUserLocations - The Haskell Wiki
14:41:49 <MyCatVerbs> matthew-_: that was, uh, cheeky.
14:42:05 <matthew-_> MyCatVerbs: yep. sorry. Bit cheap there.
14:42:17 <matthew-_> err. cheep, rather
14:42:23 <MyCatVerbs> matthew-_: witty, but...
14:42:25 <LoganCapaldo> hmm there seem to be < 307 points on that map...
14:42:51 <MyCatVerbs> Well, I'd have laughed in practically *any* other channel. But the, ah, tone is rather different here.
14:42:52 <matthew-_> no, I was right first time. Sheesh, english confuses me...
14:42:56 <sorear>  /who will help.
14:43:09 <sorear> I've seen at least five people come in from Cox/San diego
14:43:25 <sorear> @spell cheep
14:43:42 <MyCatVerbs> Hrmn. How do I get myself added to that? More votes for the UK! =)
14:43:47 <LoganCapaldo> really need @grammar cheep
14:43:54 <matthew-_> sorear: they're both words - cheep is what a bird does, but cheap is inexpensive
14:44:11 <sorear> Wow.  I never knew that.
14:44:43 * LoganCapaldo wonders if he sarcasm detector is functioning properly
14:44:50 <LoganCapaldo> cause it's going off
14:44:58 <matthew-_> LoganCapaldo: yeah, that one had me pausing for a bit
14:45:01 <sorear> LoganCapaldo: Nope, it's malfunctioning
14:45:29 <matthew-_> right, well it's clearly time for me to go to bed...
14:45:34 <MyCatVerbs> Hence the joke, man walks into a pet store, asks if they have any kittens going cheap. Shopkeeper says, no, but you might want to take a look at these budgies I have o'er here...
14:47:38 <LoganCapaldo> heh
14:48:40 <mdmkolbe|home> does anyone know of an existing bz2 implementation in haskell?  I just thought I'd wip one up but wanted to check first in case it's already been done
14:50:30 <dying_sphynx> ?seen cosmicray
14:50:31 <lambdabot> I saw cosmicray leaving #haskell-blah, #darcs and #haskell 2d 23h 42m 37s ago, and .
14:54:15 <sorear> mdmkolbe|home: Implementing bzip2 in haskell isn't a great idea; I'd recommend using libbz2 (I *think* there's a binding already)
14:54:25 <sorear> @google Codec.Compression.Bzip2
14:54:27 <lambdabot> No Result Found.
14:57:00 <sorear> @where bzlib
14:57:00 <lambdabot> I know nothing about bzlib.
14:57:01 <mdmkolbe|home> sorear: It's not a pragmatic question this time (heh, for once).  I'm just thinking about the large set of programs that are really just supped up algorithms and how they should all be boiled down to their reductions.  (e.g. wc, cat, tex, bz2)  Compression algorithms seemed like a good place to start the boiling process
14:57:03 <sorear> http://haskell.org/~duncan/bzlib/
14:57:04 <lambdabot> Title: Index of /~duncan/bzlib
14:57:15 <sorear> mdmkolbe|home: Certainly.
14:57:30 <sorear> @google site:haskell.org toy compression algorithms
14:57:32 <lambdabot> http://www.haskell.org/haskellwiki/Toy_compression_implementations
14:57:32 <lambdabot> Title: Toy compression implementations - HaskellWiki
14:59:04 <mdmkolbe|home> cool like
14:59:07 <mdmkolbe|home> **link
14:59:26 <olsner_> I was just about to do something like that! (any day now...)
15:02:27 <mdmkolbe|home> @pl (\xs -> (length xs, head xs))
15:02:27 <lambdabot> liftM2 (,) length head
15:02:52 <sorear> aka length &&& head
15:03:23 <oerjan> :t &&&
15:03:25 <lambdabot> parse error on input `&&&'
15:03:30 <oerjan> :t (&&&)
15:03:31 <mdmkolbe|home> sorear: ty, that was just what I was trying to figure out
15:03:32 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
15:03:39 <Vulpyne> Hmm... importing List or Data.List doesn't seem to bring the nub function into scope. Am I just dumb?
15:03:43 <LoganCapaldo> \(x:xs) -> (1 + length xs, x)
15:03:57 <LoganCapaldo> i'm silly
15:04:00 <mdmkolbe|home> @index nub
15:04:00 <lambdabot> Data.List
15:04:11 <mdmkolbe|home> Vulpyne: "import Data.List" should do it
15:04:25 <Vulpyne> Hmm.
15:04:30 <Vulpyne> That's freaky.
15:04:38 <Vulpyne> I guess restarting ghci fixed it. Thanks.
15:04:44 <Vulpyne> Usually :r works.
15:21:25 <olsner_> > 3 `flip id` (+ 1)
15:21:25 <lambdabot>  Parse error
15:21:31 <olsner_> shouldn't this work?
15:22:01 <olsner_> > let f = flip id in 3 `f`` (+ 1)
15:22:01 <lambdabot>  Parse error
15:22:08 <olsner_> > let f = flip id in 3 `f` (+ 1)
15:22:11 <lambdabot>  4
15:23:45 <olsner_> @pl flip id
15:23:45 <lambdabot> flip id
15:29:34 <sorear> olsner_: In F# it's available under the name (|>)
15:31:48 <jre2> hmm, the sysadmin guys at my work apparently won't add ghc to our systems because it won't compile in their environment
15:31:52 * jre2 must look into this
15:32:41 <kpreid> olsner_: `flip id` doesn't parse because it would be ambiguous: consider what happens if the expression *contains* a ``
15:32:52 <sphynx> hm, I'm trying to build cabal-rpm, it needs Cabal 1.17
15:32:58 <sphynx> 1.1.7 *
15:33:09 <sphynx> I've build it from source and installed
15:33:32 <sphynx> now "ghc-pkg -l" gives me two Cabals: 1.1.6 and 1.1.7
15:34:11 <sphynx> but when I run build for cabal-rpm package, it seens that it uses 1.1.6 for buid, cause show message with error:
15:34:34 <sphynx> src/Distribution/Package/Rpm.hs:39:7:
15:34:35 <sphynx>     Could not find module `Distribution.Compat.FilePath':
15:34:35 <sphynx>       it is hidden (in package Cabal-1.1.6)
15:35:38 <sphynx> how should I cope with this problem? I think I need either remove 1.1.6 or find some way to tell cabal to use exactly 1.1.7 for building
15:35:49 <sorear> jre2: There is no point in trying to install GHC from source.
15:36:43 <jre2> sorear: our sysadmins spend a lot of effort not using binaries of any sort
15:36:53 <jre2> so I assume that's the reason
15:36:56 <sorear> jre2: GHC 6.6 is written in Haskell+GHC 6.2 extensions;  GHC 6.2 is written in Haskell+GHC 5.04 extensions; GHC 5.04 is written in Haskell+GHC ?.?? extensions ...
15:37:24 <LoganCapaldo> it's turtles all the way down
15:37:26 <sorear> You can upgrade GHC from source, but from scratch is a lost cause.
15:37:34 <jre2> ouch
15:37:40 <sorear> Even Gentoo distributes a binary GHC.
15:38:02 <sorear> (the "ghc" package is an ordinary source package that depends on the binary ghc)
15:38:07 <mauke> gentoo also distributes a binary gcc. blasphemy!
15:38:10 <Vulpyne> FreeBSD compiles it fromsource with ports.
15:38:46 <sphynx> hmmm, so what should I do with these two cabals installed? :) any ideas?
15:38:50 <sorear> Vulpyne: They still distribute one of the written-in-lazyML versions? :)
15:39:16 <Vulpyne> sorear: I don't really know how it works, but I can tell you that it takes a hell of a long time to compile.
15:39:19 <Vulpyne> Even on a fast machine. :)
15:39:27 <jre2> I don't know the details of our situation, but I'm trying to look into it (haskell instead of perl at work would be awesome), but I guess if it's the no binaries thing it's a lost cause in that case
15:39:45 <sorear> jre2: You could always use Hugs
15:39:45 <mauke> jre2: where did they get a C compiler?
15:40:00 <jre2> mauke: good question
15:40:17 <sorear> jre2: hugs is an interpreter, written entirely in (nearly) portable C
15:40:19 <olsner_> kpreid: grmbl.. I guess that's true.. but still it'd be nice to have infix functional expressions (e.g. for clever one-liners and obfuscation :P)
15:41:31 <kpreid> hm, `(flip id)`
15:41:38 <sorear> jre2: It also depends on how they define "source".  It's possible to save the generated C files from a GHC build and then compile them on another machine with just a C compiler (this is how porting is done)
15:41:58 <kpreid> also, how about a double section
15:42:05 <kpreid> (++ " and " ++)
15:42:31 <LoganCapaldo> -| flip id |-
15:42:33 <LoganCapaldo> :)
15:42:38 <jre2> sorear: yea, I'm definately going to check it out on monday
15:43:05 <olsner_> > 3 `(flip id)` (+ 1)
15:43:06 <lambdabot>  Parse error
15:43:16 <jre2> sorear: afaik we use all in house and open source with the exception of microsoft products. maybe flashing MSR's name at them will work for ghc...
15:43:24 <kpreid> olsner_: it was an idea
15:43:56 <olsner_> heh, okay ;-) yeah, a paren should remove the ambiguity
15:44:06 <sorear> jre2: If you can't get a binary GHC hugs is probably your best bet.  it's slow and a little buggy, but the build procedure is fairly simple
15:44:12 <LoganCapaldo> sjanssen's paste seems to be lost :(
15:44:22 <sorear> LoganCapaldo: Yep.
15:44:41 <sorear> 2007.06.28.22.11.24 < treble> the checkpoint file was lost
15:44:41 <sorear> 2007.06.28.22.11.32 < treble> I had to roll back a few hours
15:46:18 <LoganCapaldo> that was such a neat trick
15:46:38 * oerjan wonders if you could compile some version of ghc with hugs
15:46:54 * LoganCapaldo was thinking what oerjan was thinking
15:47:16 <jre2> maybe, gonna try pulling the MSR card though
15:47:39 <mgsloan> has anyone ever used parsec to parse a language like markdown or textile?
15:47:43 <LoganCapaldo> MSR?
15:47:47 <jre2> microsoft research
15:48:11 <mgsloan> it's not the usual sort of parse task, as most of its plaintext with some interspersed markup symbols
15:48:14 <jre2> since our company allows microsoft binaries (for the obvious reason, plus we have decent ties with them due to our size)
15:48:29 <sorear> mgsloan: Philippa wrote a wiki in Haskell
15:48:42 <mgsloan> sorear - cool, does it have a name?
15:49:07 <sorear> Flippi
15:49:35 <sorear> http://www.flippac.org/
15:49:36 <mdmkolbe|home> @pl \n xs -> drop n xs ++ take n xs
15:49:36 <lambdabot> ap (ap . ((++) .) . drop) take
15:49:37 <lambdabot> Title: Philippa Cowderoy
15:51:02 <sphynx> \
15:51:09 <mgsloan> thanks
15:52:31 <hpaste>  LoganCapaldo pasted "-| |- recreated (`flip id`)" at http://hpaste.org/1442
15:52:31 <oerjan> > uncurry (flip (++)) . splitAt 3 $ "testing"
15:52:39 <lambdabot>  "tingtes"
15:53:43 <oerjan> @pl \n xs -> uncurry (flip (++)) (splitAt n xs)
15:53:43 <lambdabot> (uncurry (flip (++)) .) . splitAt
15:55:09 <olsner_> the operator with the lower number takes priority, right?
15:55:25 <sorear> other way
15:57:03 <olsner_> but the parenthetication(!?) should be 3 -| (flip id |- (+ 1)), right?
15:57:45 <LoganCapaldo> could just as well be (3 -| flip id) |- (+ 1)
15:58:17 <LoganCapaldo> (which it is, I think)
15:58:38 <olsner_> oh, so it doesn't matter? then why do the two operators have different priorities?
15:59:05 <LoganCapaldo> I'm not sure
15:59:24 <LoganCapaldo> I totally did it from trying to remember what sorear wrote :)
15:59:45 <LoganCapaldo> And I remembered one was 1 and the other was 0
15:59:50 <LoganCapaldo> not sorear
15:59:54 <LoganCapaldo> sjanssen
16:00:07 <LoganCapaldo> too many smart people with s's in their names in here :)
16:01:02 <olsner_> when I get my brain some sleep I should check that out
16:01:49 * olsner_ -| flip id |- (sleep . watch farscape)
16:01:58 <LoganCapaldo> farscape++
16:02:24 <LoganCapaldo> @type flip id (+ 10
16:02:26 <LoganCapaldo> @type flip id (+ 1)
16:02:32 <lambdabot> parse error (possibly incorrect indentation)
16:02:35 <lambdabot> forall c a. (Num a) => ((a -> a) -> c) -> c
16:02:50 <LoganCapaldo> @type flip id (+ 1) 3
16:02:52 <lambdabot> forall c. (Num ((Integer -> Integer) -> c)) => c
16:02:55 <LoganCapaldo> that's why
16:03:17 <LoganCapaldo> it doesn't have the right type with the other parentheisization
16:03:57 <LoganCapaldo> @type flip id
16:04:00 <lambdabot> forall b c. b -> (b -> c) -> c
16:04:04 <LoganCapaldo> yeah
16:04:11 <LoganCapaldo> flip id is value -> function
16:04:13 <hpaste>  gmc pasted "iterationbug" at http://hpaste.org/1443
16:04:22 <LoganCapaldo> ok I'm satisfied :)
16:04:50 <olsner_> > flip id 3 (+ 1)
16:04:53 <lambdabot>  4
16:04:59 <olsner_> > flip id (+ 1) 3
16:05:00 <lambdabot>   add an instance declaration for (Num ((a -> a) -> c))
16:05:38 <Cheetahfoot> i'm doing an exercise from yaht ... the exercise wants you to collect a group of numbers then print out the sum, product and factorial for each. i've got the sum and product printing out okay, but iterating through the list isn't going very well. could someone please tell me where i'm going wrong?
16:05:46 <Cheetahfoot> http://hpaste.org/1443
16:06:05 <olsner_> yeah, of course the left side has to be applied first... x `f` y = f x y, not f y x!
16:06:12 <olsner_> bah
16:06:18 <LoganCapaldo> Cheetahfoot: your base case for printFacts has the wrong type
16:06:45 <Cheetahfoot> oh ... you mean printFacts [] ... ?
16:06:51 <LoganCapaldo> yes
16:07:15 <Cheetahfoot> okay, thank you LoganCapaldo. but i'm confused, what should it be?
16:07:22 <LoganCapaldo> something in IO
16:07:35 <LoganCapaldo> return [] if you like, but probably return () is good
16:07:47 <Cheetahfoot> why is return () better?
16:07:57 <Cheetahfoot> (i'm sorry, i'm really just getting used to this)
16:08:19 <LoganCapaldo> well jsut because printFacts is an action, and it jsut prints stuff, you don't use it's result anywhere
16:08:49 <LoganCapaldo> IO () is the traditional type for actions like that
16:08:55 <olsner_> ?type do {}
16:08:57 <lambdabot> Empty 'do' construct
16:09:16 <olsner_> ?type mapM_ []
16:09:19 <lambdabot>     Couldn't match expected type `a -> m b'
16:09:19 <lambdabot>            against inferred type `[a1]'
16:09:19 <Cheetahfoot> okay. okay. can i do a return IO () then? or just return () ...
16:09:28 <mauke> ?type do "cocaine"
16:09:30 <lambdabot> [Char]
16:09:32 <LoganCapaldo> just return ()
16:09:53 <nanothief> does anyone know how to get haskell installed on cygwin?
16:10:16 <Cheetahfoot> is () null? or just an empty tuple? ...
16:10:23 <mauke> data () = ()
16:10:39 <LoganCapaldo> () is pronounced "unit" (I think)
16:11:07 <Cheetahfoot> thank you, thank you, thank you.
16:11:19 <dcoutts> Cheetahfoot: it's often used where there is no useful result
16:11:48 <Cheetahfoot> ahhh ... good to know.
16:11:54 <Cheetahfoot> thank you.
16:12:03 <mauke> > head [minBound .. maxBound] :: ()
16:12:05 <lambdabot>  ()
16:12:14 <LoganCapaldo> you're welcome
16:12:27 <olsner_> ?src Maybe
16:12:27 <lambdabot> data Maybe a = Nothing | Just a
16:12:30 <Botje> LoganCapaldo: I like "coin" for ()
16:12:33 <olsner_> ?src ()
16:12:33 <lambdabot> data () = ()
16:12:34 <weitzman> nanothief: Any reason calling normal windows haskell from within cygwin wouldn't be good enough?
16:12:43 <Botje> "ie print is of type something to IO coin"
16:12:54 <Botje> but you could call it void for all i care :)
16:13:06 <LoganCapaldo> Botje: I wasn't sure if the OCaml corruption was showing or not :)
16:13:26 <Botje> what do they call it? void?
16:13:32 <LoganCapaldo> unit
16:13:46 <mdmkolbe|home> Anyone know of an asymtoticly efficient cycle traversal algorithm.  e.g. [(a, 2), (b, 0), (c, 1)] gives [a, c, b].  The snd of each pair indicates which pair to use next.  (I'm flexible on the representation it doesn't have to be a list)
16:14:13 <olsner_> void makes sense for C hackers.. a -> b -> IO () is simply the equivalent to void function(a, b)
16:14:32 <jre2> anyone know what exactly gentoo's 'X' use flag for ghc does?
16:14:33 <LoganCapaldo> uh huh
16:15:00 <mauke>  + + X      : Adds support for X11
16:15:12 <nanothief> weitzman, no particullar reason, I just thought it would work better from within cygwin if I was using a cygwin build
16:15:23 <jre2> yes, that's more or less assumed by the capital X, I meant what does that mean ;)
16:17:04 <Cheetahfoot> ugh. i tried printFacts IO () = () ... now I'm getting Not in scope: data constructor `IO'. i guess i'm confused anyway ... isn't the last thing that gets handed to printFacts a null list?
16:17:29 <LoganCapaldo> mdmkolbe|home: Data.Map Int (a, Bool) perhaps?
16:17:41 <mauke> Cheetahfoot: yes, it is
16:17:43 <LoganCapaldo> Cheetahfoot: printFacts [] = was right
16:17:51 <sieni> nanothief: http://hackage.haskell.org/trac/ghc/wiki/Building/PlatformsScriptsFileNames says that cygwin-targeted ghc is not supported
16:17:53 <lambdabot> Title: Building/PlatformsScriptsFileNames - GHC - Trac, http://tinyurl.com/39mw26
16:17:58 <LoganCapaldo> it was just the right hand side that had the wrong type
16:18:01 <sieni> -> sleep
16:18:09 <Cheetahfoot> aaaahhhhh ...
16:18:10 <mdmkolbe|home> LoganCapaldo: I guess that would work
16:19:28 <jcspect> so hi
16:19:43 <jcspect> i'm trying to do win32 stuff in haskell
16:20:06 <nanothief> sieni, thanks for that
16:20:08 <mdmkolbe|home> @docs Data.Map
16:20:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
16:20:09 <jcspect> is there a later version of the win32 bindings available for ghc 6.6.1
16:20:12 <jcspect> ?
16:21:20 <LoganCapaldo> mdmkolbe|home: ooo I think if you did it right it wouldn't even have to be (a, Bool)
16:21:26 <LoganCapaldo> just Map Int a
16:21:29 <LoganCapaldo> I'm silly
16:21:53 <mdmkolbe|home> yeah, I figured that's what you ment
16:22:24 <araujo> hello
16:22:53 <LoganCapaldo> oh wait maybe I'm not silly..
16:23:02 <LoganCapaldo> eh you'll figure it out I'm sure :)
16:23:41 <Cheetahfoot> aaaaahhhh! it works!
16:23:50 <LoganCapaldo> it's aliiiiiive!
16:23:54 <Cheetahfoot> yes!
16:24:33 <LoganCapaldo> @type curry $ flip (,)
16:24:35 <lambdabot> forall a b a1. a -> b -> a1 -> (a1, (a, b))
16:24:43 <LoganCapaldo> @type uncurry $ flip (,)
16:24:46 <lambdabot> forall a b. (b, a) -> (a, b)
16:25:13 <jcspect> I keep having to add things missing from the bindings and I've been trying to do it so that my code is built on top of the 6.6.1 bindings, but now I need to add the wM-NOTIFY symbol but the rest of the wM symbols are defined in a template-haskell enum WindowMessage command
16:26:16 <Cheetahfoot> LoganCapaldo: why do i have to specify 'return ()' ... what does the return keyword give me? i would have thought printFacts [] = () would implicitly "return" () when given a the null list ...
16:26:34 <LoganCapaldo> return in haskell != return in imperative language of choice
16:26:52 <dcoutts> Cheetahfoot: it's not a keyword, it's a primitive monad function
16:26:57 <LoganCapaldo> return is "return this value to the monad"
16:27:05 <LoganCapaldo> @type return
16:27:07 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
16:27:21 <mauke> Cheetahfoot: return is a function, not a keyword
16:27:43 <mauke> it puts the lotion in the basket
16:28:18 <Cheetahfoot> aaaahhhh ... thank you, mauke, dcoutts, LoganCapaldo. i'll go read up on monads and figure it out now. thanks for the help.
16:28:20 <mauke> (Monad basket) => lotion -> basket lotion
16:29:24 <LoganCapaldo> Either LotionOnSkin HoseAgain
16:30:43 <Cheetahfoot> (HaskellIRC) -> DisturbingSilenceOfTheLambReferences
16:32:00 <mgsloan> SilenceOfTheLambda
16:32:09 * LoganCapaldo groans
16:35:23 <mdmkolbe|home> How do I import qualified at the GHCI prompt?
16:35:32 <mauke> I don't think you have to
16:36:14 <mdmkolbe|home> e.g. I don't want to keep typing Data.Map.lookup b/c it's ambig with Prelude.lookup
16:40:11 <mauke> doesn't seem to be possible
16:40:23 <mauke> let mlookup = Data.Map.lookup
16:42:27 <weitzman> Lambdabot imports Data.Map as M
16:42:33 <weitzman> So you can say M.lookup
16:46:14 <weitzman> Lambdabot is so much nicer than GHCI
16:47:00 <Igloo> :m - Prelude    then    :m + Data.Map
16:50:04 <hpaste>  LoganCapaldo pasted "mdmkolbe|home: this is what I meant, :)" at http://hpaste.org/1444
16:51:44 <mdmkolbe|home> yep. I just implemented the inverse Burrows-Wheeler transform in two lines of haskell. d xs = unfoldr (flip Map.lookup permutation) where permutation = Map.fromList $ zip [0..] $ sort $ flip zip [0..] $ xs
16:54:25 <gkr> How can I prove that always applicative reduction takes less steps than normal reduction?
16:57:10 <sorear> You can't, because it isn't true.
16:57:40 <gkr> Cool. Where do I get a counter example?
16:57:46 <sorear> > const 2 [0..]  -- this take omega steps under applicative order, but a finite number under normal order
16:57:47 <gkr> I get when applicative gets to oo
16:57:49 <sorear> #haskell
16:57:55 <lambdabot>  2
16:58:33 <sorear> > const 2 [0..2000000000]  -- this takes billions of steps under under applicative order, but a much smaller number under normal order
16:58:36 <lambdabot>  2
16:58:53 <gkr> If I can get to normal form via applicative reduction and normal reduction, applicative reduction takes less or equal number of steps?
16:58:59 <hpaste>  jast44 pasted "jast44" at http://hpaste.org/1445
16:59:13 <sorear> gkr: no, see that second example.
16:59:31 <gkr> Oka, thanks.
16:59:41 <Saizan> more spam..
16:59:41 <gkr> :-*
17:00:23 <sorear> Saizan: Fortunately, trebla has given me an account.
17:00:45 <LoganCapaldo> sorear, you're like some kind of lightning deleter
17:00:49 <sorear> (not to be confused with treblacy aka monochrom)
17:00:59 <LoganCapaldo> I never see the same
17:01:03 <LoganCapaldo> s/same/spam/
17:01:55 <glen_quagmire> s/spam/Spam
17:02:23 <Saizan> sorear: aka glguy?
17:02:46 <sorear> yeah
17:03:19 <sorear> but if he keeps changing his nick I'm just gonna have to start calling him Eric all the time :)
17:03:55 <Saizan> heh :D
17:04:28 <glen_quagmire> i want to make friends
17:04:36 <glen_quagmire> which website should I use?
17:04:53 <Excedrin> adultfriendfinder
17:05:27 <glen_quagmire> i'm gonna use facebook. it's meta social site
17:05:37 <glen_quagmire> bunch of applications' collections
17:05:45 <LoganCapaldo> > [0..] `zip` [3,2,1]
17:05:53 <lambdabot>  [(0,3),(1,2),(2,1)]
17:06:49 <glen_quagmire> > zip [1..] [3,2,1]
17:06:52 <lambdabot>  [(1,3),(2,2),(3,1)]
17:07:06 <glen_quagmire> so i guess [n..] increments n
17:07:12 <glen_quagmire> :t ..
17:07:14 <lambdabot> parse error on input `..'
17:07:20 <LoganCapaldo> > [10,9..]
17:07:22 <lambdabot>  [10,9,8,7,6,5,4,3,2,1,0,-1,-2,-3,-4,-5,-6,-7,-8,-9,-10,-11,-12,-13,-14,-15,-...
17:07:31 <Cale> > [0,2..]
17:07:33 <lambdabot>  [0,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
17:07:36 <glen_quagmire> wtf
17:07:40 <glen_quagmire> this is amazing
17:07:43 <LoganCapaldo> it's magic
17:07:50 <Cale> It's not that magical :)
17:07:53 <LoganCapaldo> > [0,3..9]
17:07:54 <glen_quagmire> > [-1, 2    ..  ]
17:07:55 <lambdabot>  [0,3,6,9]
17:07:56 <lambdabot>  [-1,2,5,8,11,14,17,20,23,26,29,32,35,38,41,44,47,50,53,56,59,62,65,68,71,74,...
17:08:03 <Excedrin> > [0,0.2..]
17:08:03 <wchogg> Don't listen to Cale, it's *space magic*.
17:08:05 <lambdabot>  [0.0,0.2,0.4,0.6000000000000001,0.8,1.0,1.2,1.4,1.5999999999999999,1.7999999...
17:08:21 <glen_quagmire> > [0.0, 0.1 ..]
17:08:23 <lambdabot>  [0.0,0.1,0.2,0.30000000000000004,0.4,0.5,0.6,0.7,0.7999999999999999,0.899999...
17:08:32 <LoganCapaldo> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
17:08:34 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
17:08:36 <glen_quagmire> lol 0.30000000000000004
17:08:38 <Cale> 1/10 isn't exactly representable in floating point :)
17:09:00 <glen_quagmire> > [1/2, 2/1..]
17:09:02 <lambdabot>  [0.5,2.0,3.5,5.0,6.5,8.0,9.5,11.0,12.5,14.0,15.5,17.0,18.5,20.0,21.5,23.0,24...
17:09:19 <LoganCapaldo> > [1%2, 2%1..]
17:09:21 <lambdabot>  [1%2,2%1,7%2,5%1,13%2,8%1,19%2,11%1,25%2,14%1,31%2,17%1,37%2,20%1,43%2,23%1,...
17:09:22 <Excedrin> > ['a'..]
17:09:23 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
17:09:24 <glen_quagmire> wow haskell so good
17:09:37 <LoganCapaldo> > [False..]
17:09:37 <lambdabot>  Parse error
17:09:38 <Cale> > [1%10,2%10..]
17:09:41 <lambdabot>  [1%10,1%5,3%10,2%5,1%2,3%5,7%10,4%5,9%10,1%1,11%10,6%5,13%10,7%5,3%2,8%5,17%...
17:09:48 <glen_quagmire> ['\136'..]
17:10:01 <mauke> > [() ..]
17:10:01 <glen_quagmire> yay i broke lambdabot
17:10:02 <lambdabot>  [()]
17:10:08 <Saizan> > ['\136'..]
17:10:11 <LoganCapaldo> no you just forget a >
17:10:11 <lambdabot>  "\136\137\138\139\140\141\142\143\144\145\146\147\148\149\150\151\152\153\15...
17:10:16 <glen_quagmire> > [[]..]
17:10:18 <lambdabot>   add an instance declaration for (Enum [a])
17:10:18 <lambdabot>     In the expression: [[] .. ]
17:10:18 <lambdabot> ...
17:10:21 <LoganCapaldo> > fix show
17:10:23 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
17:10:24 <sorear> @v
17:10:25 <lambdabot> "\"#$%&'()*+,\""
17:10:34 <mauke> @keal
17:10:34 <lambdabot> you think i am one of them persnipity uppity men are pig lesbian mathematicians?
17:10:45 <LoganCapaldo> @protontorpedo
17:10:46 <lambdabot> I dont know any programming yet at 33 dream of learning ti and gettign rich
17:10:54 <glen_quagmire> there is no lesbian. and no lesbian methmaticinas
17:10:58 <mauke> @keal
17:10:58 <lambdabot> lamadabot took 5 to 8 whole seconds to return []
17:11:01 <LoganCapaldo> @yow
17:11:02 <lambdabot> But they went to MARS around 1953!!
17:11:06 <mauke> @quote
17:11:06 <lambdabot> JohnPeterson says: [1991] `Miranda' is a trademark of Research Software Ltd. `Haskell' is not a trademark of anyone.
17:11:13 <glen_quagmire> > [+ ..]
17:11:13 <lambdabot>  Parse error
17:11:16 <LoganCapaldo> @botsnack
17:11:16 <lambdabot> :)
17:11:27 <Excedrin> why don't [True..] and [LT..] parse?
17:11:28 <LoganCapaldo> > [(+)..]
17:11:29 <lambdabot>   add an instance declaration for (Enum (a -> a -> a))
17:11:29 <lambdabot>     In the expression:...
17:11:33 <Cale> > [True ..]
17:11:35 <lambdabot>  [True]
17:11:35 <glen_quagmire> hey, how is lambdabot 's parser written flex and bison?
17:11:38 <Excedrin> oh
17:11:39 <Cale> > [False ..]
17:11:41 <lambdabot>  [False,True]
17:11:46 <mauke> glen_quagmire: hahaha
17:11:56 <glen_quagmire> or is lambdabot written in haskell?
17:11:57 <Cale> True.. could be an infix operator in the module True, called .
17:12:06 <Cale> lambdabot is written in Haskell
17:12:19 <Cale> Its parser is written in Haskell too
17:12:21 <LoganCapaldo> @remember Cale True.. could be an infix operator in the module True, called .
17:12:21 <lambdabot> Done.
17:12:23 <glen_quagmire> and ghc's parser is written in flex and bson?
17:12:34 <Cale> Nope
17:12:35 <mgsloan> > [LT..GT]
17:12:35 <lambdabot>  Parse error
17:12:42 <glen_quagmire> hand written?
17:12:42 <Excedrin> I guess modules can't be numbers
17:12:46 <Cale> It's written in Alex and Happy, iirc.
17:12:47 <LoganCapaldo> > [LT ..]
17:12:47 <Excedrin> > [LT ..]
17:12:50 <lambdabot>  [LT,EQ,GT]
17:12:50 <lambdabot>  [LT,EQ,GT]
17:12:52 <mgsloan> oh
17:12:52 <jre2> @quote
17:12:52 <lambdabot> HavocPennington says: Haskell is the least-broken programming language available today.
17:12:59 <glen_quagmire> @parser
17:12:59 <lambdabot> Unknown command, try @list
17:13:16 <Lemmih> glen_quagmire: And Alex+Happy are written in Haskell.
17:13:20 <LoganCapaldo> glen_quagmire: import Language.Haskell.Parser
17:13:28 <glen_quagmire> it seems yacc and lex
17:13:31 <LoganCapaldo> it's a vicious cycle
17:13:31 <Excedrin> > enumFrom LT
17:13:35 <lambdabot>  [LT,EQ,GT]
17:13:52 <glen_quagmire> oh never heard of Alex and Happy
17:14:12 <Cale> glen_quagmire: they're like the Haskell versions of lex and yacc.
17:14:34 <glen_quagmire> http://cvs.haskell.org/cgi-bin/cvsweb.cgi/fptools/ghc/compiler/parser/Lexer.x?rev=1.36;content-type=text%2Fx-cvsweb-markup
17:14:37 <lambdabot> Title: fptools/ghc/compiler/parser/Lexer.x - view - 1.36, http://tinyurl.com/39gfm9
17:14:37 <Cale> GHC itself is of course written in GHC Haskell. :)
17:15:08 <LoganCapaldo> was ghc bootstrapped with gofer and/or hugs and/or miranda at any point?
17:15:28 <Cale> I think it was bootstrapped with C.
17:15:44 <LoganCapaldo> boooooring :)
17:17:18 <LoganCapaldo> if wikipedia can be believed: "GHC originally started in 1989 as a prototype, written in LML (Lazy ML) by Kevin Hammond at the University of Glasgow. Later that year, the prototype was completely rewritten in Haskell, except for its parser, by Cordelia Hall, Will Partain, and Simon Peyton Jones."
17:17:46 <jre2> LoganCapaldo: that's accurate according to haskell's history with class paper
17:17:55 <Cale> Oh, interesting
17:18:52 <jre2> research.microsoft.com/~simonpj/papers/history-of-haskell/history.pdf
17:18:59 <sorear> glen_quagmire: You seem to have been replaced by someone else with much less Haskell experience.  Presuming this is the case - Welcome!
17:21:21 <Saizan> "you seem to have beed replaced" seems a line from matrix
17:21:35 <glen_quagmire> sorear: i just read Basic section in the wikibooks. that's all i know about haskell
17:21:46 <glen_quagmire> now i need to read Elementary haskell
17:22:45 <glen_quagmire> i'm gonna make a dvd plaery in haskell
17:27:44 <Saizan> i'd like to write an audio player that doesn't suck and it's not bloated.. what's the standard library on linux to play audio files? xinelib? gstreamer?
17:27:44 <glen_quagmire> in programming language creation, parsing is the most hard part?
17:28:00 <glen_quagmire> Saizan: alsa
17:28:12 <Excedrin> parsing is pretty easy
17:28:22 <LoganCapaldo> glen_quagmire: parsing is nto if the easiest part, definitely one of the easier parts
17:28:28 <Excedrin> getting the semantics right is far more difficult
17:28:37 <glen_quagmire> oh. i'm stuck at writing a parser
17:28:43 <Saizan> glen_quagmire: isn't that just an audio backend? i'd like to not have to decode the files myself :)
17:28:52 <LoganCapaldo> glen_quagmire: Parsec!
17:28:54 <Cale> glen_quagmire: Look into parsec
17:28:58 <glen_quagmire> Saizan: http://img440.imageshack.us/img440/7315/linuxaudiolb3.png
17:29:00 <LoganCapaldo> Parsec makes parsing fun
17:29:06 <glen_quagmire> let me check
17:29:14 <jre2> Saizan: I don't know, but supporting everything mplayer does would be nice
17:29:26 <sorear> Saizan: I think both of the libraries you suggested are pure bloat. :)
17:29:28 <LoganCapaldo> Although I thought parsing was fun before I discovered Parsec, now I just think its more fun
17:29:29 <wchogg> LoganCapaldo:  I do think parsing is one of the most boring parts of any compiler.
17:29:34 <sorear> Saizan: Have you seen hmp3?
17:29:54 <jre2> write it from scratch
17:29:55 <LoganCapaldo> wchogg: grammars make me all warm and fuzzy <g> I think there's something wrong with me :)
17:29:58 <sorear> wchogg: Parsing Haskell isn't boring.
17:30:10 <jre2> I've heard nothing but bad things about the code for most media players
17:30:13 <wchogg> sorear:  Ah, no I imagine it's not.
17:30:21 <jre2> "scary" is the usual term actually
17:30:22 <sorear> wchogg: It's "fun"
17:30:37 <sorear> wchogg: "interesting" also fits
17:30:38 <glen_quagmire> http://legacy.cs.uu.nl/daan/download/parsec/parsec.html is this correct parsec?
17:30:52 <sorear> wchogg: Also, it's never been done before.
17:31:08 <glen_quagmire> oh i found the correct link
17:31:12 <wchogg> sorear:  I was following you until that last statement.
17:31:12 <Saizan> sorear: yup, but the description says it work only on mp3, i've m4a and such..
17:31:39 <LoganCapaldo> it seems like interesting languages are either really easy to parse (Lisp, forth) or really hard to parse (Haskell, C++)
17:31:59 <sorear> > let {} in True == True == True  -- Perfectly valid haskell 98
17:32:00 <lambdabot>      precedence parsing error
17:32:00 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
17:32:10 * bos31337 <3 apfelmus
17:32:11 <slowriot> I think C++ is only hard to parse if templates are involved.
17:32:12 <LoganCapaldo> Of course interesting is short for "interesting to LoganCapaldo"
17:32:13 <sorear> GHC can't parse haskell.
17:32:15 <wchogg> Ah!
17:32:26 <wchogg> I didn't realize that those edge cases were there.
17:32:37 <slowriot> Or maybe I just think it's easy because I use it frequently.
17:32:45 <slowriot> oh
17:33:11 <bos31337> sorear: have you been following my chat with apfelmus on libraries@?
17:33:20 <slowriot> you know what? I misinterpreted "parse." I just read the most recent part of the discussion. I'm an idiot.
17:33:41 <sorear> bos31337: Slightly
17:33:50 <LoganCapaldo> slowriot: how were you thinking "parse"?
17:33:59 <slowriot> LoganCapaldo: mentally
17:34:03 <LoganCapaldo> ah
17:34:04 <wchogg> slowriot:  I can appreciate the difference that makes.  Easy to read & easy to write parsers for seem to be almost inverses of each other.
17:34:33 <LoganCapaldo> I don't know that forth is easy to read either :) at least not for me
17:34:55 <sorear> bos31337: ?
17:35:31 <bos31337> sorear: just curious as to whether you had a $.02 of any kind
17:35:42 <sorear> bos31337: He has good points, but IMO most of what the two of you are doing is pointing bikesheds
17:35:48 <sorear> that's my .02$
17:36:17 <sorear> *painting
17:36:45 <bos31337> sorear: :-)
17:37:15 <bos31337> it's nice to have a not-necessarily-productive chat once in a while.
17:37:40 <glen_quagmire> productive chats begin with "asl?"
17:38:03 <wchogg> No, those are reproductive chats.  Subtle difference.
17:39:05 * sorear <3 tlas
17:39:22 <LoganCapaldo> import Export
17:39:39 <LoganCapaldo> import Ant
17:39:49 <glen_quagmire> isn't Ant Java build thingy?
17:40:00 <glen_quagmire> Makefile XML version
17:40:17 <jre2> bah, I got off work early to start enjoy my weekend by playing around with hopengl, only to find my dev environment messed up
17:40:23 <LoganCapaldo> it's also the last three letters of important
17:40:30 <LoganCapaldo> (and a bug)
17:40:45 <glen_quagmire> hah
17:40:49 <LoganCapaldo> (hey look more word play)
17:41:02 <LoganCapaldo> import Ant ( bug )
17:41:12 <nominolo> anyone know a btree/2-3-4-tree/or similar implementation in haskell?  preferably also a zipper interface
17:41:40 <LoganCapaldo> @ho haskell btree
17:41:40 <lambdabot> Maybe you meant: hoogle hoogle+ . bf echo ft ghc id pl rc show thx v wn yow
17:41:48 <LoganCapaldo> @go haskell btree
17:41:51 <lambdabot> http://ibgs.christoph-bauer.net/~fridolin/haskell-btree/
17:41:51 <lambdabot> Title: Index of /~fridolin/haskell-btree
17:42:15 <sorear> nominolo: Yes, look at Data.Sequence
17:42:19 <glen_quagmire> @go haskell quantum
17:42:22 <lambdabot> http://portal.acm.org/citation.cfm?id=871900&dl=ACM&coll=portal
17:42:22 <lambdabot> Title: Modeling quantum computing in Haskell
17:42:29 <sorear> nominolo: Size annotated 2-3-4 finger trees
17:42:43 <sorear> @google Data.FingerTree
17:42:46 <lambdabot> http://hackage.haskell.org/packages/archive/fingertree/latest/doc/html/Data-FingerTree.html
17:42:58 <sorear> also look at that, more general
17:43:26 <sorear> pretty much every persistant data structure can be implemeted on top of finger trees in an asymptotically optimal way
17:43:43 <sorear> dequeues with O(1) end access, heaps with O(1) insert and peek-min, etc
17:43:54 <LoganCapaldo> ooo pretty
17:44:07 <jre2> anyone have a nice template for a personal website with projects/papers?
17:44:08 <sorear> heaps with O(1) remove-min (but O(log n) insert)
17:44:12 <sorear> @where ndm
17:44:12 <lambdabot> http://www.cs.york.ac.uk/~ndm/
17:44:17 <sorear> jre2: that maybe?
17:44:42 <nominolo> sorear: thanks. that's a lot of pointers :)
17:44:49 <dcoutts> sorear: surely a heap cannot have O(1) remove-min
17:45:02 <sorear> dcoutts: Why not?
17:45:07 <LoganCapaldo> surely you jest
17:45:11 <sorear> dcoutts: Sorted list heaps do!
17:45:21 <sorear> dcoutts: at the cost of O(n) insert
17:45:26 <dcoutts> sorear: it'd then have to have O(n log n) construction time, then it no longer looks much like a heap to me
17:45:58 <dcoutts> a search tree is not a heap, a heap is less ordered
17:46:16 <sorear> dcoutts: it supports fastish insert and delete-min... what more do you want?
17:46:43 <sorear> also, sorted lists satisfy the traditional heap invariant just fine
17:46:45 <LoganCapaldo> dcoutts: so your saying _by definition_ it's not a heap because it has O(1) remove min?
17:47:22 <dcoutts> LoganCapaldo: I suppose so, it doesn't look like a heap to me if it's O(1) remove and O(n) insert
17:47:31 <LoganCapaldo> k
17:47:35 <LoganCapaldo> was just curious
17:48:05 <dcoutts> the cool thing about heaps are the O(n) construction of n items and O(log n) delete-min
17:48:10 <jcspect> i need help debugging
17:48:14 <dcoutts> which is what allows heap sorting
17:48:19 <mauke> hmm, how about O(1) insert and O(1) remove-min
17:48:27 <dcoutts> not possible
17:48:34 <mauke> using a trie
17:48:36 <dcoutts> since sorting is O(n log n)
17:48:41 <jre2> sorear: not bad, but was trying to find something with a bit more infrastructure for projects (ie a wiki or something for docs, looking for ideas along those lines though)
17:49:21 <dcoutts> mauke: ok, so that's not using ordinary comparison
17:49:36 <sorear> dcoutts: Wouldn't O(n log n) construction and O(1) deletion be just as good for sorting?
17:50:21 <dcoutts> sorear: no, since then I can't get only the first few items and only pay for them, rather than all
17:50:55 <dcoutts> ie take m (sort [0..n]) costs O(m log n)
17:51:11 <dcoutts> which is better than O(n log n)
18:01:52 <dons> http://programming.reddit.com/info/22b6d/comments
18:01:53 <lambdabot> Title: Haskell : Generating more code with Harpy (reddit.com)
18:01:55 <nominolo> whoa finally a well-written paper, again ("Applicative programming with effects")
18:02:05 <dons> yeah, that's a great paper.
18:02:29 <nominolo> i really like the "Except for the noise of the repeats and zapps, this definition is in a fairly standard
18:02:33 <nominolo> applicative style, even though we are working with vectors." bits
18:12:38 <dons> http://programming.reddit.com/info/22d5b/comments
18:12:39 <lambdabot> Title: hiccup: an implementation of tcl in 250 lines of Haskell (reddit.com)
18:17:28 <LoganCapaldo> I coulda sworn I saw this already
18:17:34 <LoganCapaldo> maybe it wasn't on reddit
18:17:45 <nominolo> planet haskell
18:19:29 <LoganCapaldo> could very be
18:19:32 <LoganCapaldo> *well
18:21:07 <sorear> I look up information on pointer reversal tracers, and Google decides what I *really* wanted to know about was graph reduction machines.
18:21:30 <ski> "pointer reversal tracers" ?
18:21:36 <LoganCapaldo> did you pass -fno-dwim ?
18:21:58 <LoganCapaldo> ski: google it :)
18:22:45 <ski> @google it
18:22:47 <lambdabot> http://en.wikipedia.org/wiki/Information_technology
18:22:47 <lambdabot> Title: Information technology - Wikipedia, the free encyclopedia
18:23:20 <LoganCapaldo> wikipedia is taking over the tubes
18:30:13 <nominolo> @hoogle Mighty
18:30:13 <lambdabot> No matches found
18:30:19 <nominolo> @hoogle Musty
18:30:19 <lambdabot> No matches found
18:30:34 <nominolo> @leet laaame
18:30:35 <lambdabot>  Parse error
18:30:49 <nominolo> @elite laaame
18:30:49 <lambdabot> LA44M3
18:31:50 <SamB> probably of no use, but: http://www.cs.york.ac.uk/fp/hat/ifl2002.ps.gz -- hit 12 on my results for pointer reversal tracers
18:33:13 <ski> SamB : i think that was not it ..
18:33:20 <ihope> @. elite . elite elite The quick brown fox
18:33:20 <lambdabot> 7|-|E quIXx 8r0\/\/N PH0X
18:33:35 <ihope> The elite of the elite of the elite. :-P
18:33:51 <ski> (i can't find 'pointer reversal' in the to-text translation of that postscript file)
18:36:32 <ski> @unelite v3|2510n5
18:36:33 <lambdabot> V3|2510n5
18:36:59 <nominolo> a paper that contains "miffy" "iffy" "migty" "musty" and "accy" and got accepted as a functional paper just *has* to be good ...
18:37:10 <ski> @babel el en v3|2510n5
18:37:11 <lambdabot>   v3|2510n5
18:38:06 <nominolo> *functional pearl
18:41:49 <sorear> AKA Deutsch Shorr Waite DFS algorithm.
18:46:02 <sorear> that's interesing.  Scheme runs on 1kb pics
18:48:12 <nominolo> yep.  but pretty sure not R6RS
18:48:26 <ski> s/Shorr/Schorr/
18:48:42 <sorear> R4RS
18:50:38 <ski> is 'Deutsch Shorr Waite' related to e.g. traversing a binary tree by keeping references to two nodes, "rotating" when descending (always "descending" "left") ?
18:50:43 <ski> sorear : ^
18:50:49 <Excedrin> why doesn't unelite work for v3|2510n5 -> versions?
18:50:55 <ski> @help unelite
18:50:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
18:50:56 <sorear> ski: Maybe
18:51:12 <sorear> ski: I don't really unders... LIGHTBULB!
18:51:22 <sorear> hmm, no
18:51:46 <sorear> if you have cycles, following the left wall won't take you everywhere in a maze
18:51:55 <ski> @list elite
18:51:55 <lambdabot> elite provides: elite
18:52:07 * ski nods
18:52:30 <ski> so the aforementioned traversal can handle cycles then, i take ?
18:54:20 <sorear> yeah
18:54:35 <sorear> actually, DSW is normally used for marking
18:54:45 <sorear> which means it has a trail, and can avoid cycles
18:54:53 <ski> (as <http://www.cs.arizona.edu/~collberg/Teaching/520/2005/Html/Html-39/index.html> mentions)
18:54:53 <lambdabot> http://www.cs.arizona.edu/~collberg/Teaching/520/2005/Html/Html-39/index.html>
18:54:54 <sorear> marking as in aGC
18:55:17 * ski nods
18:57:13 <ski> hmm .. "An Applicative Control-Flow Graph Based on Huet's Zipper" sounds interesting
18:58:30 <sorear> someone discovered that a few days ago right here
18:58:47 <sorear> the stack of a graph reducer is nothing more than a zipper on the graph
18:59:03 <ski> what's a grapg reducer ?
18:59:17 <sorear> a program that reduces graphs
18:59:28 <sorear> such as an interpreter
18:59:30 <ski> (and what do you mean by 'tracer' in 'pointer reversal tracer' above ?)
18:59:40 <sorear> something that traces pointers
18:59:42 <ski> oh
18:59:51 * ski was thinking of 'reduce' as in 'fold'
19:00:31 <sorear> @type Foreign.withArrayLen
19:00:39 <lambdabot> forall a b. (Foreign.Storable.Storable a) => [a] -> (Int -> GHC.Ptr.Ptr a -> IO b) -> IO b
19:03:41 <jre2> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
19:03:43 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
19:04:10 <jre2> ^^ anyone know how hard that would be to follow for a haskell beginer (trying to convince my roommate to go through it)
19:04:10 <ski> (not to be confused with Scheme48)
19:04:40 <jre2> it claims to be useful for those with only a strong quanitative background
19:05:01 <jre2> but I don't want to underestimate it and scare him away
19:06:11 <ski> does your roommate know Scheme ?
19:07:20 <jcspect> anybody know how to make an HWND of value NULL in haskell's win32 bindings?  i've been looking for a while now
19:07:29 <sorear> fromIntegral 0 perhaps?
19:07:34 <jre2> ski: I believe he does to some degree
19:08:10 <jcspect> no
19:08:14 <jcspect> doesnt work, sorear
19:08:28 <jcspect> HWND is an alias for Ptr ()
19:08:47 <jcspect> perhaps a cast function
19:08:58 <ski> jre2 : ok .. i was thinking it might be easier to digest in such case (though i haven't looked in detail at that tutorial .. also istr there was some inconsistencies with r5rs, but icbw)
19:09:25 <ski> @index nullPtr
19:09:25 <lambdabot> Foreign.Ptr, Foreign
19:09:59 <ski> jcspect : ^
19:10:39 <jcspect> ok
19:10:41 <jcspect> thanks
19:10:54 <jre2> alright, thanks
19:12:02 <LoganCapaldo> are certain Ptr s really fromIntegral-able? that's kind ascary if so, pointer arith. in haskell
19:12:26 <sorear> LoganCapaldo: you could add it quite easily
19:13:01 <LoganCapaldo> No, I don't want it to be added! Don't do it!
19:14:45 * sorear puts on a manic grin . . .
19:16:30 <allbery_b> addled, maybe...
19:16:45 <jcspect> the messageBox function is thoroughly broken
19:16:58 <jcspect> unusable
19:17:36 <dolio> Wouldn't really work, though, would it? plusPtr is 'Ptr a -> Int -> Ptr a', not 'Ptr a -> Ptr a -> Ptr a'.
19:18:00 <sorear> dolio: castPtrToInt
19:18:14 <sorear> ptrToIntPtr rather
19:21:29 <dolio> What do you do with that, then? I don't see any functions that actually do anything with IntPtr.
19:21:46 <dolio> Oh, I guess you can add them.
19:21:55 <dolio> I see.
19:22:35 <LoganCapaldo> instance Num Ptr a where (+) = error "If you want C, you know where to find it."
19:23:12 <dolio> Why use C when you can muck about with Foreign.*? :)
19:23:27 <ski> 'xor'ed pointers !
19:23:44 <sorear> Yeah.  When you use Foreign, you still have lambdas!
19:26:32 <dolio> @seen Cale
19:26:32 <lambdabot> Cale is in #haskell, #haskell-overflow, #ghc and #oasis. I last heard Cale speak 1h 57m 38s ago.
19:36:13 <hpaste>  edpudol pasted "edpudol" at http://hpaste.org/1446
19:38:38 <jcspect> the bindings come with castUINTToPtr but not castLONGToPtr
19:39:03 <jcspect> i tried using fromIntegral to go to a UINT
19:39:07 <jcspect> but i dont think thats what i want
19:39:19 <LoganCapaldo> arrrrrrrrg
19:39:22 <jcspect> fromIntegral is too smart for this stuff, isn't it?
19:39:31 <LoganCapaldo> I sure hope so
19:39:32 <jcspect> i need to just reinterpret the bits
19:39:58 * LoganCapaldo runs in circles
19:43:39 <jcspect> i tried to copy the definition of castUINTToPtr
19:43:42 <jcspect> but i get an error
19:44:13 <jcspect> fake: undefined reference to castLONGToPtr
19:44:41 <jcspect> it's an inline function defined in the header file
19:54:47 <Saizan_> ok, we need a spam filter for hpaste..
19:56:57 <mm_freak> for large bit fields, which Data.Bits instance should i use?
19:57:00 <mm_freak> Integer?
19:57:45 <mm_freak> (i'll never need the value of the integer, just individual bitsâ¦  it's for an implementation of the sieve of eratosthenes)
19:57:51 <jcspect> in a do expression, can if statements not have elses?
19:58:03 <mm_freak> jcspect: they always must have else
19:58:09 <TSC> jcspect: Yes, but you have to be careful with indentation
19:58:09 <jcspect> well
19:58:13 <dons> Saizan: you can ask sorear to remove any spam, he's got admin privs
19:58:19 <jcspect> oh
19:58:20 <dolio> :t when
19:58:25 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
19:58:35 <dons> btw, who is maintaining hpaste.org now?
19:58:46 <mm_freak> jcspect: you should take a class about monads
19:58:48 <TSC> jcspect: The "else" has to be indented past the if
19:58:51 <dons> where did the pastes fro mthe past 72 days go?
19:58:56 <Saizan> jcspect: no, you can use when though
19:59:18 <dons> sorear: can you kill off paste 1446
20:00:04 <LoganCapaldo> dons: there was some kind of checkpointy thing. sorear quoted it earlier
20:00:26 <sorear> done.
20:00:49 <sorear> btw, *every* hpaste spam so far has had the same string for nick and title
20:01:05 <sorear> I think we could match on that and ignore (not fail!) requests
20:01:10 <dons> sorear: who's maintaining hpaste now?
20:01:19 <sorear> dons: Eric Mertens
20:01:23 <dons> it seems our initial checkpoints *were* restored, but what happened to the others/
20:01:38 <sorear> dons: now known as trebla, formerly known as emertens and glguy
20:02:03 <dons> oh, trebla eh?
20:02:46 <sorear> yeah
20:03:00 <sorear> not to be confused with treblacy AKA monochrom
20:07:07 <crazy_coder> g'morning
20:07:36 <scook0> in cabal, does "cc-options" affect .hs files too (if compiling via C), or is it only applied to plain .c files?
20:08:39 <sorear> Probably the latter.
20:08:54 <sorear> You can use Ghc-options: -optc-O2   if you want
20:09:16 <scook0> sorear: yeah, I'm doing that; I just wondered if it was redundant :)
20:10:19 <dons> ?userrs
20:10:19 <lambdabot> Maximum users seen in #haskell: 354, currently: 281 (79.4%), active: 12 (4.3%)
20:10:39 <dons> ?uptime
20:10:40 <lambdabot> uptime: 2d 1h 46m 37s, longest uptime: 1m 10d 23h 44m 29s
20:12:55 <crazy_coder> Is learning XML completely necessary for implementing RSS readers ?
20:13:24 <sorear> No.
20:14:04 <crazy_coder> I don't want to use XML parsing tools/ library functions etc
20:14:19 <dons> you might need to understand the format , at least a little bit
20:14:29 <dons> understanding RSS and Atom might be more useful though.
20:14:40 <dons> crazy_coder: have you seen lambdaFeed ?
20:15:10 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/lambdaFeed-0.3.1
20:15:13 <lambdabot> http://tinyurl.com/35prug
20:15:33 <crazy_coder> No.
20:15:46 <dons> minimal rss/xml tool, might be a useful starting point
20:16:08 <crazy_coder> Ok, I would initially try to implement only for RSS and later for Atom
20:16:19 <crazy_coder> when things start working for rss format
20:16:35 <dons> cool, that sounds like a fun project.
20:16:39 <dons> a great way to learn haskell.
20:16:51 <dons> so you'll roll your own parser? and do a bit of network code?
20:17:20 <crazy_coder> yeah
20:17:48 <crazy_coder> I am having great fun this summer holidays, learning haskell is so great fun
20:17:54 <dons> cool :-)
20:17:58 <crazy_coder> :)
20:18:26 <dons> evening augustss_
20:18:40 <crazy_coder> I actually implemented a search function for a text document in less than 1/2 hr (thanks to you guys too)
20:19:00 <dons> there's some related libraries here, http://haskell.org/haskellwiki/Applications_and_libraries/Web_programming#XML
20:19:02 <lambdabot> Title: Applications and libraries/Web programming - HaskellWiki, http://tinyurl.com/253xhy
20:19:18 <crazy_coder> Thanks
20:19:21 <dons> and this is a great little rss aggregator Cale wrote, http://cale.yi.org/index.php/HRSS
20:19:26 <lambdabot> Title: HRSS - CaleWiki
20:19:33 <dons> Cale: is HRSS on hackage? it should be.
20:19:42 <dons> crazy_coder: see some other examples here, http://haskell.org/haskellwiki/Blog_articles/Web
20:19:43 <lambdabot> Title: Blog articles/Web - HaskellWiki
20:20:00 <crazy_coder> dons: thanks You rock !
20:20:16 <dons> ICFP contest registration appears to be open: http://www.icfpcontest.org/teams/register
20:20:17 <lambdabot> Title: Teams
20:20:25 <dons> we should start *now* organising people here into teams....
20:20:41 <dons> anyone got some opinions on how to best do that?
20:21:45 <crazy_coder> dons: I can team up with you ;)
20:22:31 <dons> nah, i'm a bit busy this year. but i want to help esure all 350 people in here enter :-)
20:22:45 <Saizan> a textual search through hpaste's state is going to be very slow? gzipped BytesStrings inside a Seq ..
20:22:52 <dons> we usually have 2 or 3 teams from this channel, but we can hook people together a bit better this time, i think
20:22:57 <crazy_coder> btw, do we have to do some project and submit it online?
20:23:09 <dons> Saizan: O(n)?
20:23:20 <dons> Saizan: we could export hpaste somehow.
20:23:27 <dons> then upload the choice bits into a better db?
20:24:13 <dons> hey jfredett
20:24:43 <Saizan> choice bits?
20:25:08 <jre2> s/choice/Maybe/
20:25:34 <dons> oh, that's a bit obscure. "the good stuff"
20:25:59 <dons> "choice bits" -- pieces/bits you'd choose :-)
20:26:18 <Saizan> ah, i was thinking of providing a search function on the site
20:26:35 <dons> yeah, that'd be good, and doable.
20:27:40 <jfredett> hi dons
20:27:55 <jfredett> am i needed for something, or are you just saying hi?
20:28:18 <dons> just saying hi :-)
20:28:26 <dons> if you're needed, i will summon you.
20:28:35 <dons> to do the bidding of our lambda masters.
20:28:44 * jfredett returns to his alcove
20:28:58 <jfredett> we are Functional programmers
20:29:09 <jfredett> you will be made referentially transparent
20:29:14 <jfredett> state is futile..
20:29:17 <dons> heh
20:29:44 <Saizan> dons: so you think the way to do this would be to use a dbms for the pastes instead of in memory Seq?
20:29:45 * crazy_coder got scared looking at the  ICFP 2005 Programming Contest Task
20:30:32 <dons> Saizan: hmm, perhaps implement something simple and in-memory, see how it works, then think about an external dbms or some such
20:32:15 <mgsloan> wow, the break function is really handy for parsing that's too simple for parsec
20:32:33 <LoganCapaldo> lex!
20:34:00 <Saizan> i just love ReadP, screw determinism!
20:34:46 <dons> mgsloan: what's it look like?
20:35:03 <mgsloan> what's what look like?
20:35:32 <dons> oh, sorry, misread.
20:37:35 <LoganCapaldo> weee lex
20:37:37 <LoganCapaldo> > takeWhile (not . null) $ unfoldr (listToMaybe . lex) "a = 2; b = \"ok\"; moo = 5"
20:37:39 <lambdabot>  ["a","=","2",";","b","=","\"ok\"",";","moo","=","5"]
20:38:07 <mgsloan> ?src lex
20:38:07 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:38:37 <LoganCapaldo> > takeWhile (not . null) $ unfoldr (listToMaybe . lex) "a = 2; b = \"ok\"; moo = 5; 2.673"
20:38:39 <lambdabot>  ["a","=","2",";","b","=","\"ok\"",";","moo","=","5",";","2.673"]
20:38:43 <LoganCapaldo> I love it
20:40:25 <mgsloan> :t lex
20:40:27 <lambdabot> String -> [(String, String)]
20:45:25 <jre2> do any editors support tab completion besides gchi?
20:45:56 <jfredett> editors or interpreters?
20:46:09 <jfredett> vi "tab" completetion is ^P
20:46:12 <sorear> ghci isn't an editor
20:46:21 <sorear> it links readline, which is
20:46:26 <jre2> yea, that wasn't phrases well
20:46:39 <jre2> I just didn't want someone to say ghci
20:46:50 <jfredett> ghci
20:46:51 <jfredett> :P
20:47:55 <LoganCapaldo> theres that shim thing, does that do completion?
20:48:00 <LoganCapaldo> @where shim
20:48:00 <lambdabot> http://shim.haskellco.de/trac/
20:48:01 <dons> so, anyone got some thoughts on organising #haskell teams for ICFP?
20:48:21 <jfredett> im not great at Haskell,
20:48:24 <jfredett> but I'll play
20:48:43 <jfredett> haven't done an ICFP before though
20:48:52 <jfredett> they sounded to dangerous for the likes of me
20:48:53 <jfredett> :P
20:48:57 <dons> what we need is a way for people to let everyone know they're looking for teams, or teams to notify us they're looking for more members
20:49:06 <dons> that is, match up people
20:49:13 <dons> to get as many teams together as possible
20:49:21 <dons> so,  a wiki page? or is there some better way?
20:49:23 <jre2> YES, it works for vim
20:49:36 <jfredett> wiki should be fine, methinks
20:49:44 <jfredett> solve first, optimize later
20:49:52 * jre2 is tired of his emacs friends pointing out how their editor does everything
20:50:10 <dons> vincenz: around?/
20:50:13 <jfredett> tell them its notan editor, its an operating system.
20:50:52 <jre2> yea, they don't seem to accept my argument of "carpal tunnel shouldn't be on your feature list"
20:51:01 <LoganCapaldo> is possible to solo?
20:51:07 <jfredett> i use both Vi and Emacs, before anyone gets jihad-y
20:51:20 <jfredett> jre2: heh, I like that
20:51:55 <jfredett> I generally just ignore Emac-junkies and Vi-fiends
20:52:32 <jfredett> i just kindof Zen out and "Mu" them all away.
20:52:45 <jfredett> LoganCapaldo: In ICFP? yah, from what I read
20:52:58 <Saizan> i find more comfortable with C and M than with ESC, btw
20:52:58 <jfredett> It doesn't seem to disallow the existence of teams of 1
20:53:07 <jre2> jfredett: you could, you know, just follow the chuch of The One True Editor
20:53:24 <jfredett> jre2: what, ed?
20:53:33 <jfredett> Saizan: to each his own, Mu
20:53:35 <jre2> that would have been EDitor then
20:53:44 <LoganCapaldo> jfredett: I was asking more from the POV of "is it feasible to do the problem(s) by yourself", not if it was legal from a contest rules standpoint :)
20:54:00 <LoganCapaldo> but I guess I should have said that in the first place
20:54:02 <jfredett> LoganCapaldo: I answer what you ask. Not what you mean. :P
20:54:14 <jfredett> I dont know- i haven't looked at old problems.
20:54:22 <jfredett> but something tells me that its probably not
20:54:31 <jfredett> since you only have what- a weekend to do it?
20:54:34 <jre2> DAMN, the vim integration isn't done, only the emacs mode
20:54:54 * jre2 's roommate snickers at him
20:55:08 <Toms2> guess you better call your physiotherapist
20:58:26 <LoganCapaldo> talk about a misnomer
20:58:33 <LoganCapaldo> NewBinary: "An older binary serialization library used by a number of projects. For new projects consider an alternative such as binary."
20:59:05 <Saizan> heh :D
20:59:36 <sorear> LoganCapaldo: do you know what the image format used by old-style 16 bit windows executables is called? :)
20:59:58 <LoganCapaldo> NewPE?
21:00:04 * LoganCapaldo gueses
21:00:04 <sorear> New Executable
21:00:13 <sorear> PE came later, much later. :)
21:01:01 <dons> LoganCapaldo: hehe.
21:01:06 <dons> LoganCapaldo: where's that?
21:02:48 <LoganCapaldo> dons: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/NewBinary-0.1
21:02:51 <lambdabot> http://tinyurl.com/3c6rrv
21:03:05 <dons> you do want to use Data.Binary, yes.
21:03:38 <LoganCapaldo> I was just browsing thru hackage, saw that, got all interested
21:03:55 <LoganCapaldo> I'm very disappointed with the choice of name :)
21:04:08 <LoganCapaldo> NewBinary should be newer than Binary :)
21:04:08 <dons> it was the NewBinary replacement for nhc98's Binary
21:04:22 <dons> but Data.Binary is a replacement for NewBinary -- (pure , and faster)
21:04:29 <dons> :)
21:04:30 <sorear> ooh, stepcut
21:04:44 <dons> yeah, he's the NewBinary maintainer of yore.
21:04:44 <sorear> somehow I would have expected NewBinary was by a complete outsider
21:05:25 <dons> the full history starts with malcolmw and CR (I think), in nhc.
21:05:31 <dons> they then wrote 'bits between the lambdas'
21:05:36 <dons> that code was ported internally into ghc
21:05:38 <sorear> CR?
21:05:40 <dons> then torn out, as NewBinary
21:05:42 <dons> colin runciman.
21:05:43 <sorear> claus reinke, oh
21:05:49 <sorear> oh. ;)
21:05:50 <dons> ah, not that CR :-)
21:06:03 <dons> i did a stripped down NewBinary, for lambdabot (?)
21:06:15 <dons> that was a bit faster. then we sat around for a while
21:06:28 <dons> then lenartk and dcoutts hacked up the ContT-based lazy bytestring binary serialiser
21:06:29 <LoganCapaldo> @remember Data.Strict.Maybe Note that strict Maybe is not a monad since return _|_ >>= f = _|_ which is not necessarily the same as f _|_.
21:06:29 <lambdabot> Done.
21:06:32 <dons> which turned into Data.Binary
21:06:46 <dons> LoganCapaldo: fair enough ,eh?
21:07:08 <LoganCapaldo> Lambdabot should have more quotes from libraries
21:07:15 <LoganCapaldo> bwahahah
21:07:24 <dons> and now we're hacking more on Data.Binary (rewrite rules for bounds checking for 1.0)
21:09:33 <LoganCapaldo> well Data.String in MissingH looks useful
21:10:04 <dons> LoganCapaldo: you should make some notes on features missing from hackage while your trawl through it
21:10:10 <dons> to send off to the hackage SoC guys
21:10:51 <LoganCapaldo> hmm missing features...
21:12:29 <LoganCapaldo> maintainer emails should be clickable
21:12:40 <LoganCapaldo> Or is that an antispam measure?
21:13:48 <LoganCapaldo> no search apparently
21:14:06 <LoganCapaldo> conceivably they thought of that one already though
21:14:19 <dons> could you make some notes please?
21:14:29 <dons> then we can send them off to , is it , nominolo ?
21:14:37 <LoganCapaldo> Ok
21:14:43 <LoganCapaldo> I'll make a list of complaints heh
21:14:58 <dons> btw, another great post on native-code compiled, embedded languages in haskell, http://programming.reddit.com/info/22b6d/comments
21:14:59 <lambdabot> Title: Haskell : Generating more code with Harpy (reddit.com)
21:15:17 <jfredett> jesus freaking christchild. ICFPC2k5 is hard.
21:15:18 <dons> and again, i think due to the title, not getting the attention it deserves.
21:15:33 <dons> jfredett: hehe, it was a bit hard, yeah. they're all hrad though.
21:15:48 <jfredett> my goodness...
21:15:51 <dons> yucky AI. 06 was more in my comfort zone, but it was bloody evil
21:16:05 <jfredett> Cops and robbers...
21:16:10 <jfredett> AI is interesting
21:16:13 <jfredett> I like it, i think
21:16:18 <jfredett> never really done much of it
21:16:51 <jfredett> thats what I should do -- write an AI. That'll look good on a resume... heck- it could interview for me
21:18:04 <jfredett> that would be cool...
21:18:05 <dons> heh
21:18:13 <LoganCapaldo> dons: How pie in the sky should I get with these notes? Can I complain about the lack of hooglability?
21:19:00 <dons> sure. just collect a list of missing features, and bugs
21:19:18 <dons> double check against hte todo list, http://hackage.haskell.org/trac/hackage/wiki/HackageToDo
21:19:19 <lambdabot> Title: HackageToDo - Hackage - Trac
21:19:40 <dons> hoogle is on that list already, for example
21:20:22 <dons> hehe, blogs are fun. some guy discovers haskell: "I?ve been writing Haskell for a week now. Haskell is very refined. I?m already disgusted with Ruby"
21:21:21 <LoganCapaldo> So I have 3 notes so far. 2 are not on the todo list afaict
21:21:29 <dons> good.
21:21:49 <dons> i'd like to sort by various fields (author, for example)
21:22:03 <dons> and see the 'most used' libraries, by counting dependencies on the packages
21:22:21 <jre2> that would be a useful metric
21:22:55 <Saizan> a package page visit/download counter?
21:23:23 <dons> that's another thing people have proposed too
21:24:26 <dons> http://programming.reddit.com/info/22e5n/comments
21:24:27 <lambdabot> Title: Defining the uncountable ordinals in Haskell (reddit.com)
21:25:06 <jfredett> :)
21:25:12 <jfredett> Yay for Ordinals!
21:27:30 <LoganCapaldo> does cabal have a test phase?
21:28:29 <Korollary> I dont think so.
21:28:39 <LoganCapaldo> k
21:28:49 <Korollary> Wait
21:29:11 <Korollary> yes it does have something for test
21:29:45 <Korollary> I had even figured it out
21:29:59 <dons> yeah, it does. you can plug in test scripts to run
21:31:04 <LoganCapaldo> I haven't used hackage froma dev POV. is all the data / metadata extracted from the .cabal file or do you fill in a form as well?
21:31:24 <dons> its all in the .cabal file
21:32:01 <LoganCapaldo> drat
21:32:25 <LoganCapaldo> Can you add extra fields to a cabal file?
21:32:52 <LoganCapaldo> I wanted to suggest providing a field for the darcs repo
21:32:56 <dons> arbitrary fields?
21:32:58 <LoganCapaldo> (if there was one)
21:33:00 <LoganCapaldo> yeah
21:33:02 <dons> yes, that's also been suggested
21:33:07 <dons> since there's already the 'homepage' field
21:33:19 <dons> ask the cabal guys, there really should be a 'repository: ...' field
21:33:59 <LoganCapaldo> or even just a x-repository: ... type deal :)
22:01:08 <jcspect> what's the function to get the nth item of a list?
22:01:15 <jfredett> !!
22:01:28 <jfredett> > [1,2,3,4] !! 0
22:01:30 <lambdabot>  1
22:01:33 <jfredett> > [1,2,3,4] !! 3
22:01:34 <lambdabot>  4
22:02:00 <jcspect> actually
22:02:05 <jcspect> I have an array of lists
22:02:10 <jfredett> though, if you need to do that, i've found your likely doing something that could be done better.
22:02:14 <jfredett> its still !!
22:02:24 <jfredett> iirc
22:02:31 <jfredett> well, if its an array
22:02:34 <jfredett> i guess your fine
22:02:38 <xpika> compiling wxWidgets takes ages... :(
22:02:42 <jfredett> but !! on lists is linear
22:02:50 <jfredett> and thats not fun
22:03:12 <jcspect> no, its an array on the outside, but a list on the inside and i:m indexing into both
22:03:20 <jfredett> hmm
22:03:24 <jfredett> what are you trying to do?
22:03:26 <dons> Array Int [a] ??
22:03:33 <jcspect> i,j where i is the array index and j is the list index
22:03:44 <dons> Array (Int,Int) a -- might be better?
22:03:44 <jfredett> right- whats the code for though?
22:04:04 <jfredett> certainly faster indexing, ayup
22:04:28 <jcspect> i have IOArray Int [String]
22:04:34 <jfredett> ahh
22:05:12 <jcspect> i want an function that is Int -> int -> IO String
22:05:16 <jcspect> i guess
22:05:23 <dons> using and IntMmap might make more sense than [String] ?
22:05:30 <jfredett> so you have an array of lists of [Char]... hmm
22:05:37 <jfredett> thats nasty
22:05:46 <dons> anyway, you'd have index i j arr = ( arr ! i ) !! j
22:06:23 <dons> so its an array of vectors, basically
22:06:43 <dons> possibly Array Int Sequence might be more efficient
22:06:47 <jcspect> well, thats not working. its IOArray, so ...
22:07:09 <Saizan> ?type readArray
22:07:12 <lambdabot> Not in scope: `readArray'
22:07:27 <Saizan> ?type Data.Array.MArray.readArray
22:07:28 <dons> index i j arr = do ls <- readArray arr i ; return (ls !! j)
22:07:29 <lambdabot> forall (a :: * -> * -> *) i e (m :: * -> *). (Ix i, Data.Array.Base.MArray a e m) => a i e -> i -> m e
22:07:49 <dons> ?undo do ls <- readArray arr i ; return (ls !! j)
22:07:49 <lambdabot> readArray arr i >>= \ ls -> return (ls !! j)
22:07:54 <dons> ?pl readArray arr i >>= \ ls -> return (ls !! j)
22:07:54 <lambdabot> (!! j) `fmap` readArray arr i
22:08:09 <dons> ?pl index i j arr = (!! j) `fmap` readArray arr
22:08:09 <lambdabot> index = const ((. readArray) . fmap . flip (!!))
22:08:11 <dons> heh
22:08:28 <jre2> Setup.hs: cannot satisfy dependency old-time-any
22:08:34 <jre2> anyone know where to find that?
22:08:37 <Saizan> ?pl index i j arr = (!! j) `fmap` readArray arr i
22:08:37 <lambdabot> index = flip ((.) . fmap . flip (!!)) . flip readArray
22:08:39 <dons> is it on hackage?
22:08:45 <dons> or bjorn's site.
22:09:26 <Saizan> ?pl index arr i j = (!! j) `fmap` readArray arr i
22:09:26 <lambdabot> index = (flip (fmap . flip (!!)) .) . readArray
22:09:41 <jre2> I have "a" time library, I'll see if the one on hackage is different
22:10:18 <Saizan> well, it asks for "old-time"
22:10:25 <jre2> the dependancy chain for shim is rediculous
22:10:53 <jcspect> its complaing no instace for (MArray IOArray [String] t0
22:12:38 <Saizan> uh, fun, there are only instances for numeric types
22:13:08 <dons> that doesn't sound right.
22:13:44 <dons> oh, you want to index by [String] ?
22:13:50 <hpaste>  farida pasted "farida" at http://hpaste.org/1447
22:13:50 <dons> that's not what you want is it.. :-)
22:13:56 <jcspect> no it isnt
22:13:58 <dons> sorear: ^^
22:15:23 <dons> newListArray (0,9) [["foo","bar"], ["dons","Saizan"]]  :: IO (IOArray Int [String])
22:16:13 <Saizan> well, the problem in that type is that you've not fixed the monad, i think. "t0"
22:18:23 <dons> sorear: around?
22:20:31 <Saizan> does binary work with ghc HEAD now?
22:20:42 <dons> Data.Binary? I don't see why not
22:21:19 <Saizan> undefined symbols when linking a program that imports it, last time i tried
22:21:33 <Saizan> there was a bug on trac iirc
22:21:38 <dons> url?
22:21:55 <hpaste>  jcspect pasted "Array error msg" at http://hpaste.org/1448
22:22:01 <sorear> dons: yes.
22:22:18 <dons> sorear: spam on hpaste. can you privmsg me the admin passwd too, please? i seem to have lost mine.
22:24:26 <Saizan> jcspect: add a type annotation there so that the typechekcer know that you're in the IO monad
22:25:55 <jcspect> that worked saizan
22:26:08 <jcspect> i dont really understand it though
22:27:05 <jre2> found the chain shim <- filepath <- directory <- old-time <- old-locale. old-time is broken though (missing HsTimeConfig.h), I think that's fixable though
22:27:49 <Saizan> jcspect: well, for some reason that expression was forced to a monomorphic type, so the typecheker wants to resolve the instances, and since it has no clue on which MArray instance to use it complained
22:28:16 <Saizan> jcspect: was it part of a binding with no arguments?
22:28:36 <jcspect> it was a lambda
22:28:42 <jcspect> passed to another function
22:29:21 <jcspect> the other function didnt yet have code to make use of it either so it didnt care what type it was
22:30:22 <hpaste>  dons annotated "Array error msg" with "arrays" at http://hpaste.org/1448#a1
22:30:42 <dons> jcspect: 6^ an example
22:31:18 <dons> I'd probably use Data.Sequence though.
22:31:22 <dons> arrays seem overkill here.
22:31:39 <jcspect> thanks
22:32:38 <jcspect> overkill for what?
22:32:51 <jcspect> are you saying you think i shouldnt use arrays?
22:33:10 <dons> yeh, mutable arrays here are maybe more than you need, and a bit too inconvenient.
22:33:12 <Saizan> dons: http://hackage.haskell.org/trac/ghc/ticket/1282
22:33:14 <lambdabot> Title: #1282 (binary package wants uncheckedShift functions to be exported from base) - ...
22:33:14 <dons> let me code up a purely functional example
22:33:20 <dons> Saizan: ah ha.
22:34:06 <jcspect> this is a program that will read a large number of records, each one turned into a list, and display it in a widget.  The user will be able to click headings to sort the columns and such.  The OS gets the strings for display by calling back to me so i need to be able to look them up fast
22:34:45 <dons> ok. are the strings constant?
22:34:57 <jcspect> basicaly, the os widget is giving me i, j and i give it teh string
22:35:00 <hpaste>  dons annotated "Array error msg" with "using finger trees" at http://hpaste.org/1448#a2
22:35:32 <dons> yep, cool. Sequences give you shorter, purely function code, with /O(log(min(i,n-i)))/ index.
22:35:33 <jfredett> time for sleep
22:35:38 <jfredett> gnite folks
22:35:47 <jre2> this is probably trivial but, how do you explicitly say where to get a module (say, if you get a "it was found in multiple packages:" error)?
22:36:02 <jcspect> a given i and j does not always map to the same string
22:36:05 <dons> you can link with a specific package version
22:36:13 <jcspect> but the strings themselves are constant
22:36:20 <dons> jcspect: but its just a 2-d, updatable table, right?
22:36:36 <jcspect> yes
22:36:46 <dons> basic interface;   index :: Int -> Int -> A String -> String ; insert ; delete ; replace ?
22:38:09 <jcspect> probably, not sure what that means
22:38:44 <dons> just a table that supports indexing, insert, delete, and update, of elements?
22:39:10 <jcspect> ya
22:39:17 <jcspect> a large number of rows, a few columns
22:39:34 <dons> ok.
22:39:44 <dons> the rows are fixed at initialisation time?
22:40:03 <jcspect> fixed?
22:40:10 <dons> the size
22:40:13 <dons> is constant
22:40:40 <siti> Here's what I have been working on for the last few months, http://siti.geek.nz/?q=node/3  I thought some people might be interested since the majority of the code is done in haskell.  Most of the code will be open sourced too :).
22:40:42 <lambdabot> Title: Search Engine | Siti's Site
22:40:42 <jcspect> well, i will have different tables with different numbers of rows.
22:40:53 <LoganCapaldo> > let takeUntil = takeWhile . (not .) in takeUntil (< 3) [25,24..]
22:40:55 <lambdabot>  [25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3]
22:40:57 <jcspect> er
22:41:03 <jcspect> i mean, different numbers of columns
22:41:11 <jcspect> hm
22:41:22 <jcspect> the columns that the widget actually displays will be configurable
22:41:49 <jcspect> but the row-record itself has a fixed max columns for a particular type of record, but i have several different types
22:42:35 <jcspect> ug
22:43:01 <jcspect> so i guess the number of columns and the number of rows and the order of rows is all changable from the widgets point of view
22:44:41 <hpaste>  dons annotated "Array error msg" with "pure 2d finger-tree table" at http://hpaste.org/1448#a3
22:45:11 <dons> there's a little example, anyway, of a non-IOArray-based updatable 2d table. should be a little easier to deal with than a IOArray [String]
22:46:01 <psykotic> dons, are you doing icfp this year?
22:46:23 <jre2> dons: hmm, I can't seem to find out how to do this. would you mind directing me to a page on how to force a specific version of a module (I'm trying to fix the old-time package which needs old-locale's System.Locale instead of base)
22:46:40 <dons> psykotic: not this year, gotta finish my thesis
22:46:50 <psykotic> dons, ah. that going well?
22:46:57 <psykotic> dons, i know that finishing that is a bitch.
22:46:59 <dons> reasonably :-) time pressure is on though.
22:47:13 <psykotic> you already have the material, right, "just" need to write it up?
22:47:16 <dons> moving countries too, so lots of stuff to get organised.
22:47:16 <sorear> Someone on the ML thinks monads are impure!
22:47:18 <dons> yeah
22:47:35 <psykotic> to where are you moving?
22:47:43 <dons> Portland, OR.
22:47:51 <psykotic> haskell related?
22:47:59 <dons> jre2: so you're trying to update the dependencies to refer to the new package time?
22:48:09 <dons> psykotic: yes! :-) galois.com
22:48:15 <psykotic> oh, galois, nice one :)
22:48:27 <dons> yay for haskell jobs
22:48:58 <dons> psykotic: so you're interested. i'm interested in helping organise teams from #haskell
22:49:12 <psykotic> dons, i actually already have a team with vincenz, lemmih and a few others
22:49:14 <dons> ensuring people who need members, or people looking for teams, can find each other
22:49:16 <psykotic> dons, was just curious about your plans
22:49:21 <dons> ah right yes, the lazy bottoms :-)
22:49:27 <psykotic> the few, the proud :)
22:49:32 <dons> the lazy!
22:49:37 <jre2> dons: er, make old-time use old-locale (or base if it's compatible)
22:50:04 <dons> psykotic: so, hmm, i'm thinking maybe starting a page of teams and members, and then people who are looking for a team
22:50:08 <dons> a wiki page.
22:50:27 <jcspect> i dont understand how update :: Int -> a -> Seq a -> Seq a can be logarithmic.  Internally, wouldnt haskell need to copy the entire Seq a ?
22:50:35 <psykotic> that might be useful. i think there are a lot of people who sort of think of doing it but since it's just them on their own they'll probably end up abandoning it
22:50:49 <dons> jcspect: check how finger trees are defined, you can just update a node, and the spine to that node
22:51:00 <dons> psykotic: exactly.
22:51:10 <dons> there's 350 people in here, probably at least 50 would be interested.
22:51:26 <dons> normally we get about 3 teams , but we can do better
22:51:28 * jfredett raises  his hand
22:51:34 <psykotic> right. even if the team won't be super organized, just having that peer pressure to get your act together and actually compete would be useful
22:51:34 <dons> i'll start a wiki page for helping teams get organised.
22:51:41 <dons> yeah
22:51:57 <dons> and internet-based teams seem to do fairly well -- like lazy bottoms
22:52:04 * sorear wonders how he'd do.
22:52:06 <psykotic> we should have a system for trades
22:52:08 <dons> or say, us, last year, half in syd, half in germany
22:52:11 <psykotic> based on lamdabot karma points  :)
22:52:12 <jre2> think there's a reason for that?
22:52:16 <psykotic> like in pro sports
22:52:20 <dons> heh
22:52:30 <jfredett> sorear: probably better than me
22:52:30 <dons> yes, we need a pre-season trading round
22:52:30 <psykotic> dons, you said there were 3 last year?
22:52:45 <psykotic> which aside from lazy bottoms
22:52:47 <dons> duncaheffaloo, lazy bottoms, deaus ex machina
22:52:52 <dons> there's a couple of other smallish teams
22:53:12 * sorear doubts duncaheffaloo will get very big. :)
22:54:36 <jcspect> dons, im going to sort all the rows by some particular column when the user clicks it.  Wouldnt arrays be better for that?
22:56:18 <dons> why would they? the same interface is provided for both?
22:56:58 <jcspect> well I suppose id want soem fast sort on Seq thats already written for me
22:58:54 <dons> do you want to mutate the Seq, or extract it as a list and sort that?
22:59:27 <mgsloan> hmm, why is mapFst stuck in Data-Graph-Inductive-Query-Monad ?
22:59:32 <mgsloan> it's a handy function..
23:00:02 <mgsloan> course I'll just write my own instead, but still!
23:00:15 <LoganCapaldo> @hoogle mapFst
23:00:16 <lambdabot> Data.Graph.Inductive.Query.Monad.mapFst :: (a -> b) -> (a, c) -> (b, c)
23:00:33 <LoganCapaldo> @type map . first
23:00:35 <lambdabot> forall b c d. (b -> c) -> [(b, d)] -> [(c, d)]
23:00:50 <LoganCapaldo> oh
23:00:54 <LoganCapaldo> I mean first
23:00:57 <LoganCapaldo> @type first
23:01:00 <lambdabot> forall (a :: * -> * -> *) b c d. (Arrow a) => a b c -> a (b, d) (c, d)
23:01:12 <dons> mgsloan: ah yes, how timely
23:01:24 <dons> there seems to be a lot of fun stuff in Data-Graph-Inductive-Query-Monad that should be in a standalone package
23:02:08 <mgsloan> yeah, or stuff that shouldn't be exported
23:02:25 <mgsloan> eg, orP :: (a -> Bool) -> (b -> Bool) -> (a, b) -> Bool
23:03:52 <LoganCapaldo> @type (***)
23:03:54 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
23:03:57 <Saizan> @type (uncurry (||) .) . (***)
23:03:58 <dons> http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
23:03:59 <lambdabot>     Couldn't match expected type `Bool' against inferred type `(b, b')'
23:03:59 <lambdabot>       Expected type: (b, c) -> (b', c') -> (Bool, Bool)
23:04:00 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
23:04:10 <dons> psykotic: ok ^^ i've started  a page for teams, teams needing people, and people needing teams
23:04:24 <LoganCapaldo> @type uncurry (||) . ((***) .)
23:04:26 <lambdabot>     Couldn't match expected type `(Bool, Bool)'
23:04:26 <lambdabot>            against inferred type `a1 -> a b' c' -> a (b, b') (c, c')'
23:04:28 <Saizan> @type ((uncurry (||) .) .) . (***)
23:04:30 <dons> if anyone interested, at this point, you can just add your name and any relevant details
23:04:30 <lambdabot> forall b b'. (b -> Bool) -> (b' -> Bool) -> (b, b') -> Bool
23:04:40 <Saizan> missed a >>> :)
23:05:54 <LoganCapaldo> Control.Arrow, come for the tuple combinators, stay for the ???
23:06:13 <sorear> when is the ICFPPC
23:06:14 <sorear> ?
23:06:25 <LoganCapaldo> weekend of the 20th i think
23:06:36 <dons> see http://www.icfpcontest.org//
23:06:38 <lambdabot> Title: ICFP Programming Contest 2007
23:06:46 <xpika__> i have one GTK+ program with a 3d window which i forkIO'd and then i tried the opengl command translate and my program just quit :S
23:09:14 --- mode: ChanServ set +o dons
23:09:21 --- topic: set to '["The Haskell programming language: Write less, think more!","Compete in the ICFP contest: http://tinyurl.com/3dx5mv","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","The language of ICFP winners 3 years running"]' by dons
23:09:45 <jfredett> there, First name (after lambdabot) on the ICFPPC. now time for sleep
23:09:53 <dons> i created #haskell-icfp07 too
23:09:56 --- mode: ChanServ set -o dons
23:12:27 <dons> ?join #haskell-icfp07
23:12:53 <kfish> xpika__, paste?
23:13:13 <kfish> xpika__, gtk+ doesn't usually like being multithreaded ...
23:15:12 <siti> well and gtk2hs doesn't like it too
23:15:13 <scook0> @src mapM_
23:15:13 <lambdabot> mapM_ f as = sequence_ (map f as)
23:15:20 <siti> you can use forkOS in the newest gtk2hs
23:15:20 <xpika__> kfish: id only doesnt like the Opengl command
23:15:32 <xpika__> forkOS?
23:15:38 <xpika__> siti: whats that?
23:15:48 <siti> it's a full OS level thread
23:16:02 <siti> although you have to be careful not to use gtk2hs functions on the forked threads
23:16:14 <xpika__> siti: tries to forkOS
23:16:39 <xpika__> @hoogle forkOS
23:16:39 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
23:18:10 <xpika__> siti: sorry same problem
23:18:44 <xpika__> im typing the opengl function translate in at the prompt interactivly while the program is forked
23:19:09 <xpika__> i dont think opengl likes getting talked to by different threads
23:19:36 <xpika__> just a guess
23:20:32 <hpaste>  xpika pasted "gl code" at http://hpaste.org/1449
23:24:26 <hpaste>  xpika annotated "gl code" with "extras" at http://hpaste.org/1449#a1
23:31:02 <jre2> is it possible to note in the cabal information to use a specific version of a module?
23:32:03 <dons> yep
23:32:04 <scook0> @src sequence_
23:32:05 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
23:32:08 <dons> depends foo-0.3.1
23:32:25 <jre2> er
23:32:43 <jre2> so if you import System.Locale
23:33:15 <dons> well, the .cabal file would specify exactly which package
23:33:21 <dons> there's only package level granularity
23:33:34 <jre2> ah
23:34:18 <jre2> is there some sort of workaround that's used then?
23:34:53 <dons> i think you jsut need to work out precisely which package version you need?
23:36:02 <jre2> old-time seems to need old-locale-1.0's version of System.Locale instead of base's
23:36:41 <jre2> likewise for directory needing old-time's over base's for System.Time
23:38:57 <dons> what library are you working on?
23:39:24 <dons> maybe there's some replacement that doesn't need the old-* stuff
23:39:40 <scook0> if I apply mapM_ to a list of length n, what would be causing it to evaluate the function n^2 times?
23:39:57 <dons> possibly the list monad? where's the code?
23:40:02 <dons> mapM_ print [1..10] --  ?
23:40:29 <jre2> yea, I think I'll just drop it, but I replaced the missing HsTimeConfig.h file and figured I'd try to get it all working and push a patch
23:40:33 <scook0> hang on, I'll try to paste a clean version
23:42:05 <hpaste>  scook0 pasted "profiling says 'update' gets called n^2 times" at http://hpaste.org/1450
23:42:58 <sorear> scook0: How many times are you calling performUpdates?
23:43:20 <scook0> once per simulation iteration, so roughly 10000 times
23:43:43 <scook0> update should be getting called 400 times more frequently
23:43:56 <scook0> but it's called 160000 times more frequently
23:44:19 <scook0> wait, hang on
23:44:27 <sorear> What is Simulation?
23:44:45 <scook0> no, my numbers are off
23:45:07 <scook0> it's only getting called 1600 times, which is only 4 times too many
23:45:25 <scook0> sorear: newtype Simulation a = MkSim { unSim :: ReaderT SimRead IO a }
23:45:44 <sorear> ok.
23:45:46 <scook0> so it's not n^2 after all
23:47:00 <scook0> I'll try to find what's causing the factor-of-four
23:51:08 <Cale> scook0: well, maybe check the indicesToUpdate lists and ensure they're the expected lengths.
23:51:26 <Cale> er, looks like you were doing that
23:51:35 <scook0> Cale: yup
