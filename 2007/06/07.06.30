00:15:10 <sorear> it's late.  I'd best be sleeping
00:37:02 <goltrpoat> i spent most of last night writing a hutton-meijer type parsing framework in c++.  it seemed like a fine idea when i started.
00:37:04 <goltrpoat> fill in the blanks.
00:37:24 <dons> hheh
00:37:28 <dons> poor goltrpoat
00:37:37 <dons> C++ isn't meant for writing.
00:38:12 <goltrpoat> hehe
00:40:10 <goltrpoat> it leaks like crazy, appears to be a lot less efficient than parsec, and mplus is buggy at type level, but i can parse things like 5*(3+2) in about 500 lines of code
00:40:55 <dons> cool! that's a good productivity boost over assembly
00:40:58 <arcatan> dons: C++ is meant for reading?
00:40:59 <goltrpoat> hahah
00:41:57 <siti> C++ is a torture technique...
00:42:27 <dons> its a conspiracy to keep people employed in testing and debugging
00:42:34 <siti> heheh
00:42:45 <goltrpoat> and writing documentation
00:43:04 <siti> it's like law students going in to all the different fields
00:43:09 <siti> they make it complex to make more money ;)
00:44:07 <wilx> Hm.
00:44:18 <Vq^> :)
00:44:20 <wilx> Isn't Boost.Spirit almost like Parsec?
00:44:30 <goltrpoat> i think that's the idea, yes
00:45:45 <mgsloan> yeah, C++ is pretty bad.  I rewrote ~1000 lines of geometry lib in ~150 lines 'o haskell
00:46:00 <mgsloan> still working on the C++ version, though :)
00:46:48 <goltrpoat> heh
00:47:15 <mgsloan> and that's only about 1/20th of the geom lib - just the prims..
00:48:09 <goltrpoat> ive been wanting to implement schewchuk's geometric predicates paper in haskell for a while
00:50:02 <mgsloan> oh yeah, the precise/fast orientation/incircle things?
00:50:05 <goltrpoat> yeah
00:50:16 <mgsloan> I'm planning to use the nasty huge C for that in a little while
00:50:22 <goltrpoat> ah joy
00:50:26 <goltrpoat> you know about gns, right
00:50:27 <mgsloan> indeed
00:50:35 <mgsloan> gns?
00:50:51 <goltrpoat> a library that implements his stuff, amongst other things
00:51:11 <goltrpoat> not gns.  i'm thinking of my old wiki.
00:51:12 <goltrpoat> heh
00:52:08 <goltrpoat> ok, why can't i remember this.
00:53:32 <mgsloan> I might actually be doing a little SoC-ish thing this summer... A bit of an insane project - stable intersection/booleans on curvy paths
00:53:59 <goltrpoat> (not CGAL)
00:54:08 <mgsloan> yeah, CGAL is ugly as hell
00:54:20 <mgsloan> and i think there are licensing issues
00:54:20 <goltrpoat> blah.  it'll come to me at some point.  were using it a while back
00:54:40 <goltrpoat> booleans of swept volumes you mean?
00:54:49 <mgsloan> nah, 2-dimensional
00:56:01 <mgsloan> well, maybe its not so insane, but as far as i know noone has done it without converting to linesegs and back
00:56:52 <mgsloan> I think I remember what you are talking about.. perhaps a code generator for such algorithms as his predicates ?
00:56:59 <goltrpoat> im sure there are implicit surface formulations along the lines of ADFs
00:57:06 <goltrpoat> assuming i understand what you're talking about
00:57:33 <goltrpoat> nah, it was a gnu library for geometric primitives
00:57:54 <goltrpoat> it was using shewchuk's paper to implement intersection queries and booleans
00:58:15 <mgsloan> well, basically, taking parametrically defined paths and finding their intersection precisely and stably (handling all of the crazy cases)
00:58:46 <goltrpoat> oh, intersections between actual curves in the plane?  i figured you meant swept solids
00:58:46 <mgsloan> hmm, how primitive were these geometric primitives?
00:58:50 <mgsloan> no
00:58:58 <mgsloan> yeah, solids would be crazy
00:59:10 <hpaste>  D11S pasted "D11S" at http://hpaste.org/1451
00:59:24 <mgsloan> it's still at least a summers worth, though
01:00:19 <goltrpoat> i don't quite know what the scope of it was.  it handled triangle meshes and booleans between those -- one of my partners wanted to prototype an algorithm we'd been talking about, and was blocked by the fact that i was supposed to write the geometry library
01:01:26 <dons> does that mean a person sits there and tries to spam hpaste?
01:01:42 <goltrpoat> yeah, ive seen it happen occasionally
01:01:51 <dons> seems inefficient
01:02:46 <dons> btw, people thinking of competing in the ICFP contest --> http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
01:02:49 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
01:02:50 <dons> add your names/teams.
01:05:41 <goltrpoat> mgsloan:  any restrictions on the two curves?
01:05:47 <mgsloan> nope
01:06:19 <mgsloan> well, they're continuous and closed
01:06:49 <goltrpoat> closed and bounded?
01:06:57 <mgsloan> though there is some funkiness with that, as some paths might have extra paths which cut holes in them
01:07:25 <mgsloan> I also have to write a function that basically takes a rather gnarly path rep and uniformitize it to these
01:07:31 <mgsloan> bounded?
01:07:44 <mgsloan> yes, i suppose they never go to infinity
01:07:49 <goltrpoat> no points at infinity or any of that
01:08:13 <goltrpoat> hmm
01:08:28 <goltrpoat> but you have a bracket on the roots of h(s,t) = f(s)+g(t) then
01:08:30 <mgsloan> big trickiness is the numerical precision of the intersection points
01:09:08 <mgsloan> and it has to be fast
01:09:11 <goltrpoat> with arbitrary open curves, the only thing i could think of was going to an implicit representation, and then there's a fair bit of weirdness with coinciding curves
01:09:29 <mgsloan> yeah, dealing with coinciding curves is a must
01:09:38 <goltrpoat> ah
01:09:38 <mgsloan> and of course dealing with tangential intersection
01:10:27 <Philippa> <dons> cool! that's a good productivity boost over assembly <- it definitely /isn't/ if you've got a macro assembler...
01:10:45 <Philippa> and quite possibly not anyway
01:11:27 <Philippa> 'lo goltrpoat
01:11:30 <mgsloan> goltrpoat - you know what inkscape is?
01:11:31 <goltrpoat> hey philippa
01:11:56 <goltrpoat> mgsloan:  rings a bell, is that the coreldraw type editor?
01:12:24 <mgsloan> something to that effect.  Really nice OSS vector editor.  Anyway, this might become its replacement booleans
01:12:30 <goltrpoat> ahh cool
01:12:36 <goltrpoat> ah so hence fast
01:12:42 <mgsloan> yeah
01:13:27 <dons> inkscape's very nice
01:13:32 <dons> good for .eps in papers.
01:14:16 <mgsloan> yep.  has horrid code though
01:14:36 <mgsloan> in some bits
01:14:39 <mgsloan> some bits are ok
01:14:42 <dons> ah well. good coders don't want to write vector graphics editors, i guess?
01:15:33 <mgsloan> I dunno, its got some pretty good coders, its just gotten kind of monolithic (C++ doesn't help)
01:16:29 <goltrpoat> ok so i guess my first thought from there would be that from it being a vector editor, you get nice bounds in the sense that you can rasterize both polygons in a reasonable amount of time, which gives you extremely nice first guesses
01:16:34 <mgsloan> incidentally several of the founders know haskell..
01:16:45 <goltrpoat> for the intersection points, i mean
01:16:55 <mgsloan> there was a tiny attempt at an InkscapeLambda a few years ago.
01:17:25 <mgsloan> hmm, that's a good point
01:17:38 <mgsloan> in outline mode, anyway, this is true
01:18:25 <mgsloan> one problem with this is that it'll be implemented in a side project, a geom lib intended to replace inkscape's geom stuff
01:19:10 <goltrpoat> ah
01:19:46 <mgsloan> there are other applications as well.  For example, Raph Levien, wants to use it for font stuff
01:20:01 <mgsloan> in that situation its all about stability and precision
01:20:22 <goltrpoat> but you use bezigons in fonts
01:20:28 <goltrpoat> not exactly arbitrary curves
01:20:54 <goltrpoat> much easier problem, no?  you know the number of roots
01:21:02 <goltrpoat> sec, smoke
01:21:06 <mgsloan> well, Raph actually uses clothoids, well, rather generalized clothoids called spiros
01:23:52 <pierre1> hello
01:24:25 <pierre-> now can i generate XML with HaXml?
01:25:54 <Igel> you need to build a document
01:25:56 <Igel> Document
01:26:14 <goltrpoat> not familiar with clothoids, lemme look it up
01:26:21 <Igel> which contains a tree of Elems
01:26:49 <pierre-> Igel, i tried to do that with combinators
01:27:12 <Igel> where's the problem?
01:27:14 <goltrpoat> mgsloan:  curves whose curvature is monotonically increasing in their length?
01:27:16 <pierre-> but can't find a way to create empty document
01:27:36 <goltrpoat> oh, this other place just says linearly
01:27:42 <mgsloan> goltrpoat - those'd be the ones
01:27:58 <mgsloan> yeah, technically it should be linearly, but his don't
01:28:02 <goltrpoat> ah ok
01:28:13 <Igel> pierre-: just use the Document constructor
01:28:26 <mgsloan> I'm not even sure it has to be monotonic..
01:28:50 <goltrpoat> well, it has to be constrained somehow, right.  otherwise we can take any old family of curves.
01:28:59 <Igel> and xml needs at least one element afaik
01:29:12 <Igel> Elem "root" [] []
01:29:31 <Igel> would be "the possibly most empty" document root, i think
01:29:39 <mgsloan> yeah, I'm hoping that it can be implemented in such a way that is open to extension to multiple curve types
01:30:08 <goltrpoat> my rasterization idea doesn't quite work right of the box, by the way.
01:30:18 <mgsloan> yeah, I know
01:30:34 <pierre-> Igel: thanks
01:30:50 <Igel> pierre-: you're welcome :)
01:32:11 <goltrpoat> it can be fixed, but you need more constraints than just continuity
01:33:18 <mgsloan> my current plan is to divide each path such that they are always monotonic on x or y.  Use simple bounding primitives to figure out the possible intersection combinations.  Assuming these bounding thingamabobs are more fitting than an AABB, you should be able to find the points of intersection of these bounding thingies, and hopefully be able to relate these intersection points to points on the curves, further narrowing the domain of 
01:33:47 <goltrpoat> got cut off at "further narrowing the domain of"
01:34:11 <mgsloan> oh there's not much left - "the bounding thingamabob."
01:34:14 <goltrpoat> ah
01:34:18 <mgsloan> perhaps I said thingamabob one too many times
01:34:21 <goltrpoat> hehe
01:34:48 <mgsloan> probably will be ellipses or convex hulls
01:35:08 <goltrpoat> intersection of ellipses is a 6th degree polynomial
01:35:09 <goltrpoat> hehe
01:35:14 <goltrpoat> i'd go with convex hulls or OBBs
01:35:28 <mgsloan> yeah, OBBs could work
01:36:58 <mgsloan> anyway, I'm not uber mathsy
01:37:03 <goltrpoat> don't you have to come up with a piecewise linear representation to find chunks that are monotonic in x or y?
01:37:09 <mgsloan> yep
01:37:14 <mgsloan> I wrote our piecewise class
01:37:16 <mgsloan> :)
01:37:28 <mgsloan> I dunno about 'linear'
01:37:38 <goltrpoat> but i thought you said the point was to avoid going with a piecewise linear curve
01:37:52 <mgsloan> it's piecewise curvy segments
01:38:39 <mgsloan> basically a mapping of time onto a series of segment representations
01:39:21 <pierre-> Igel: can you give me a hint: how do i apply CFilter combinators to Document?
01:39:33 <goltrpoat> ah.. no i mean, just determining that, say, f(t) is monotone in x for a<=t<=b, to find a and b, you either need some heavy machinery, or you'll be using an approximation, unless i'm missing something
01:40:01 <goltrpoat> or rather, to find b given an a
01:40:31 <Igel> pierre-: i've not used that one yet
01:40:32 <Igel> but
01:40:55 <Igel> it is a function :: [Content i] -> Content i
01:41:01 <mgsloan> actually, we've got the machinery, though the precision is a little bit doubtful
01:41:07 <Igel> each Element has a list [Content]
01:41:23 <Igel> you probably just apply the function to that list
01:41:59 <goltrpoat> i take that back.  you'll be looking for zeroes of f' for t>a, which is nicer than looking for zeroes of h(t,s) = f(t)-g(s).  you'll probably want to require that f is differentiable, not just continuous, though.
01:42:02 <Igel> hope that helps^^
01:42:26 <mgsloan> yeah, we've got a function type that's closed under differentiation :)
01:42:26 <goltrpoat> er.  f' being df/dx for x monotone, etc.
01:42:36 <goltrpoat> ahh right, we're doing this in haskell.
01:42:36 <mgsloan> and rootable
01:42:38 <goltrpoat> hehe
01:42:45 <mgsloan> actually, no, it's C++
01:42:49 <goltrpoat> ah
01:42:57 <Igel> pierre-: i'm afk now, organizing some breakfast
01:42:58 <goltrpoat> ok, but i hadn't even thought of AD for some reason.
01:43:04 <mgsloan> ah
01:43:12 <Igel> otherwise i'm going to starve this weekend ;)
01:43:26 <pierre-> Igel: thanks again
01:43:30 <mgsloan> I think its pretty quick to check if a segment is monotonic or not
01:43:44 <Igel> no problem
01:43:48 <goltrpoat> oh, it's very quick to check that it's monotonic
01:43:58 <goltrpoat> the issue is finding long monotonic segments
01:44:07 <goltrpoat> but.. that's much easier with AD
01:44:11 <mgsloan> yeah
01:44:31 <Igel> @karma der_eq
01:44:31 <lambdabot> der_eq has a karma of 0
01:45:11 <mgsloan> we've actually got some pretty cool stuff.  If I wasn't worried about efficiency and speed, I'd probably parameterise the monotonic segments on x or y, subtract, and root
01:45:45 <mgsloan> err, precision and speed
01:46:13 <goltrpoat> i've done a ton of collision and intersection detection, but that was on piecewise linear meshes -- so i hadn't even thought of constructing an OBB, say, hierarchy around the curve
01:46:33 <mgsloan> cool
01:46:44 <goltrpoat> that's pretty cool.  i wouldn't want to have to write anything that needs to find *all* roots of an arbitrary function in two variables
01:46:48 <mgsloan> yeah, pretty much everyone does it with the linears
01:47:09 <goltrpoat> one of the roots, most of the time -- sure :)
01:47:20 <mgsloan> well, once its parametrized on a component, its just one var
01:47:24 <goltrpoat> right
01:48:18 <mgsloan> I'll actually probably implement this first, so I can work on booleans and such
01:48:38 <mgsloan> so that at least I'll have functioning code, then can go back and monkey with precision/efficiency
01:49:01 <goltrpoat> -nod-
01:49:50 <mgsloan> I'm rather proud of another class I made - D2<T>
01:49:56 <goltrpoat> so actually, you get swept volumes almost for free, from this.
01:50:27 <mgsloan> D2<double> is a point, D2<Interval> is a AABB, D2<func> is a parametric curve
01:50:31 <goltrpoat> i mean, what i thought you were talking about earlier, continuous collision detection of uh.. things.. swept by closed curves along paths
01:50:42 <mgsloan> hmm
01:50:42 <goltrpoat> ah cool
01:51:01 <goltrpoat> "almost for free" == redon's stuff fits right on top of it
01:52:21 <mgsloan> oh, by swept are you talking about 2d or 3d sweepage?
01:52:35 <goltrpoat> well, 2d here, although i'm not sure it particularly matters
01:52:41 <mgsloan> in a 2d game engine I had physics with swept collisions, man, was it sweet
01:52:43 <mgsloan> yep
01:53:17 <scook0> is there an easy way to get cabal to build C++ code for me?
01:53:21 <scook0> or am I stuck with plain C?
01:55:45 <dons> C++ , don't think so. you would need a Makefile, unless I'm mistaken
01:55:47 <dons> to build the C++ bits
01:56:25 <scook0> hmm
01:57:06 <scook0> though I suppose I could still get cabal to link the resulting .o files
01:57:56 <therp> scook0: in the worst case you can cook them into a convenience library and add it to ld-options of .cabal
01:59:40 <scook0> indeed -- interfacing the two is certainly possible, but I was hoping it would be as effortless as plain C
02:01:22 <mgsloan> whoah.. haddock is quite a beast!
02:01:39 <augustss> it sure is
02:03:01 <mgsloan> is a full haskell parsing really necessary?
02:03:15 <mgsloan> well, lexing maybe
02:04:22 <augustss> you pretty much need to parse so you know where to attach the docs
02:04:33 <mgsloan> ah
02:05:26 <mgsloan> I'm trying to figure out an efficient (dev time wise) way to have a delinked code/doc system
02:06:05 <mgsloan> inline docs are usually horrid
02:06:44 <mgsloan> ignore the interrconnections between functions, don't explain functions by comparison, lead to copy/paste, restating the function name as a sentence, etc etc.
02:07:41 <goltrpoat> at this point, we're basically planning on hiring a few people to write the documentation for us.
02:07:59 <mgsloan> hah
02:08:24 <mgsloan> I went on a doc binge yesterday and wrote about 22kb
02:09:31 <mgsloan> It's a sort of combo of manual, reference, and tutorial
02:09:51 <mgsloan> the main problem is I can't figure out a way to write it with links without resorting to pure html
02:10:31 <goltrpoat> i was doing this contract recently that involved writing a texture unwrapper.  there's 5-6 contiguous pages worth of comments in one of the headers, that i'm 99% sure no one in the client's company could actually understand
02:10:44 <mgsloan> hah
02:11:27 <mgsloan> I always just use Ultimate Unwrap ;)
02:12:11 <goltrpoat> well, they wanted something that would require zero user intervention in 99% of the time -- normally that doesn't really work, but this was for heightfield based meshes
02:12:20 <mgsloan> oh, i see
02:12:54 <mgsloan> automatic unwrapping is also used a lot for lightmaps
02:13:02 <goltrpoat> so the documentation started out with "we seek to approximate a conformal mapping" and went downhill from there.
02:13:13 <mgsloan> hehe
02:14:03 <goltrpoat> you don't have the same requirements for lightmaps though
02:14:13 <mgsloan> true
02:15:04 <goltrpoat> quake1 and 2 just exported a giant atlas of per-triangle lightmaps, iirc, packed in little 32x32 slots in one gigantic texture with no attempt at bin packing
02:15:20 <mgsloan> hah!
02:15:50 <mgsloan> I used to use a dinky map editor that did it by quads, though it did pack pretty well
02:16:57 <mgsloan> actually, it might have done it by planar surface
02:17:26 <goltrpoat> yeah, i think just bsp'ing the texture plane gives a 1.5-approximation -- assuming non uniform size, pick the biggest rectangle, place it at 0,0.  split the texture plane along one of the edges.  pick the next biggest rectangle.  put it in whatever halfspace will fit it.  repeat.
02:17:41 <mgsloan> It wouldn't attempt to stick surfaces together on the map though, just unwelded all the vertices for each joint
02:18:18 <mgsloan> yeah, that's basically how it worked
02:19:22 <goltrpoat> with shaped bin packing, genetic algorithms are popular apparently
02:19:27 <goltrpoat> was just this looking into that recently
02:19:36 <goltrpoat> er.  -this
02:20:03 <mgsloan> oh, odd!
02:20:29 <mgsloan> I guess it works well if you've got some computation power on hand
02:20:39 <mgsloan> and don't want to write a proper algorithm :)
02:21:17 <goltrpoat> i don't think there's any other proper algorithm for packing non-convex objects
02:21:41 <goltrpoat> in the general case i mean.
02:22:07 <mgsloan> right
02:22:07 <goltrpoat> if you want to pack puzzle pieces, there are obviously easier ways of going about it :)
02:22:14 <mgsloan> it's a pretty interesting problem
02:22:39 <goltrpoat> i had the idea that you could algorithmically recreate the process you would use mechanically
02:22:55 <goltrpoat> as in, put the objects in the bin willy nilly and shake it for a while.
02:22:56 <mgsloan> yep, that's how I often times approach problems
02:22:58 <mgsloan> yeah
02:24:45 <mgsloan> I'd probably add objects largest to smallest
02:25:54 <goltrpoat> well, the first issue is that intuitively, it doesn't seem like it would work well with a rectangular bin and rectangular objects
02:26:07 <goltrpoat> i mean, either adding largest to smallest, or adding it randomly
02:26:26 <goltrpoat> compared to known approximations with good bounds, i mean
02:26:35 <mgsloan> mm
02:26:52 <mgsloan> interesting, tricky problem, certainly
02:26:56 <goltrpoat> so that's one point for genetic algorithms
02:26:57 <goltrpoat> hehe
02:27:05 <rey_>  
02:27:17 <mgsloan> yeah, probably the best way to do it
02:27:45 <mgsloan> there's probably better solutions, but its not worth spending huge amounts of time working out just to save some computation time
02:28:11 <goltrpoat> well, i actually have a practical problem with a rectangular bin and non-convex object
02:28:17 <goltrpoat> objects, rather
02:29:09 <goltrpoat> i don't think there's a non-randomized algorithm for this.. i can't even write it as a reasonably sized ILP off the top of my head
02:29:13 <mgsloan> what's the usual GA 'genetic code' for this problem.  The way I'd probably do it would be to store object angles
02:29:42 <goltrpoat> generalized coordinate of each object
02:30:03 <mgsloan> oh, wierd
02:30:10 <mgsloan> what do you mean by generalized?
02:30:42 <goltrpoat> in the physics sense.  the stacked vector of position and rotation, in the usual rigid case
02:31:12 <mgsloan> ah.
02:32:17 <mgsloan> The way I'd do it is have a tree with an object and rotation at every node.  Each branch would store the angle off the object that that branch's node is positioned
02:32:37 <mgsloan> in other words, it would already assume that everything touches
02:32:51 <mgsloan> and assumes there aren't any holes :)
02:32:54 <goltrpoat> but that assumes star-shaped objects
02:33:53 <mgsloan> oh, yeah, hmm
02:34:11 <goltrpoat> actually, that's a good point.
02:34:49 <goltrpoat> i think every object i have is a disc, so i can parametrize that and store attachment points as a single scalar
02:35:03 <mgsloan> yep
02:35:26 <goltrpoat> ah, but then that assumes that all objects are touching in the optimal solution.
02:35:59 <goltrpoat> close enough probably, though.  certainly makes the parameter space a hell of a lot smaller.
02:36:06 <goltrpoat> cool, thanks.
02:36:09 <mgsloan> indeed
02:36:10 <mgsloan> welcome
02:36:31 <mgsloan> for concave objects, a piecewise path is enough to yield all points of the object directly accessible, so in that worst case, 2 scalars should be enough
02:37:02 <mgsloan> I think that parameter space is a lot better for GA as well
02:37:03 <goltrpoat> well, concave or not, i think i can assume they're all discs topologically.  so i can just parametrize the boundary.
02:37:16 <mgsloan> doh! good point!
02:37:40 <mgsloan> must be the lateness getting to me..
02:37:43 <goltrpoat> :)
02:38:47 <greenrd> Anyone know if it is safe to use immediate left recursion in Frisby parsers?
02:39:02 <greenrd> http://en.wikipedia.org/wiki/Left_recursion#Immediate_left_recursion
02:39:05 <lambdabot> http://tinyurl.com/yvj6sl
02:40:11 <mgsloan> even if the objects have holes, you can just parameterize along the rim
02:40:53 <mgsloan> stick it on the end of the exterior domain
02:41:18 <goltrpoat> greenrd:  i haven't used Frisby, but you usually left-factor that
02:41:57 <goltrpoat> mgsloan:  yeah, was just thinking that.  the parametrization doesn't need to be nice.
02:42:03 <mgsloan> yep
02:45:49 <mgsloan> you could also bound the angle at each branch such that it doesn't cause a collision
02:46:16 <mgsloan> that way you won't have to do any tweaks in the fitness algo for collisions
02:46:24 <mgsloan> actually that might be a bad idea
02:46:45 <goltrpoat> well, it's not that the angle needs to be bounded, it's that the operator that takes the angle to an attachment point is not a function
02:46:48 <goltrpoat> imagine a donut.
02:47:16 <mgsloan> well, I'm actually thinking of the object angle
02:47:45 <goltrpoat> object angle?
02:47:48 <mgsloan> which, if you imagine it varying, would cause the object to wiggle back and forth on its attachment point
02:47:57 <mgsloan> err, hmm
02:48:16 <goltrpoat> oh, the angle of the attached object?
02:48:19 <goltrpoat> ohh i see what you're saying
02:48:22 <mgsloan> there may be 3 scalars involved at each attachment point
02:48:29 <goltrpoat> well, no, hopefully that's something that the fitness function will take care of
02:49:30 <mgsloan> one for the time on the first object's boundary, one for the time of the second object's boundary, and one for the 2nd object's rotation
02:50:04 <goltrpoat> if you restrict it too far, you'll take a fair bit of time coming up with a single generation that doesn't look like a gigantic chain, i think
02:50:55 <mgsloan> most of the time you only really need 2 as the rotation would be derivable from the derivatives, but you get cusps and corners and such
02:51:34 <goltrpoat> well, here's a slight problem
02:51:50 <goltrpoat> the shapes come from image data
02:52:15 <mgsloan> ah, so they're piecewise linear?
02:52:32 <goltrpoat> you can get "tangents" on the boundary, but you'll end up with a range of valid configurations for each tangent point
02:52:40 <mgsloan> indeed
02:52:56 <mgsloan> you could devote equal parametrization domain to the sides and points
02:53:14 <mgsloan> through the domain devoted to the points, the angle would vary
02:53:42 <mgsloan> so, basically I guess I'm suggesting storing the 2nd object's rotation, hah!
02:53:58 <goltrpoat> heheh
02:54:20 <mgsloan> I'm getting a bit incoherent in thinking, been a good convo though, night
02:54:43 <goltrpoat> later.  thanks for the parametrization idea, i'll have to play with that
02:54:48 <mgsloan> welcome
02:55:05 <mgsloan> btw, you might want to check out ant colony optimization as an alternative to GA
02:55:14 <mgsloan> might work out better with this kind of domain
02:55:37 <goltrpoat> i actually haven't read much about that.  i know the term, don't know a whole lot about it though
02:55:40 <goltrpoat> i'll have to check it out.
03:04:38 <goltrpoat> at this point, i'm fairly sure that there's no topic that someone here doesn't know something about.  #haskell should fight crime, or something.
03:05:04 <rretzbach1> ack
03:06:00 <goltrpoat> apparently not everyone likes crime.
03:06:11 <goltrpoat> er.  dislikes crime.
03:06:24 <goltrpoat> i'll stop talking now.
03:08:21 <Adamant> #haskell, for all your hive mind needs
03:12:07 <scook0> ok, if my haskell program is going to be linked against some c++ code in a library, is there a good way to get cabal to invoke the library's makefile?
03:12:16 <scook0> or am I better off getting make to invoke cabal?
03:17:20 <dons> yeah, the latter i think
03:17:20 <rretzbach1> Can someone please tell me what a "side effect" in imperative languages is?
03:17:20 <dons> rretzbach1: performing some action from a procedure other than simply returning a value
03:17:20 <dons> for example, changing some global state
03:17:20 <rretzbach1> so bulb.toggleLight() would cause a side effect?
03:17:20 <rretzbach1> that is, changing the glowing attribute for instance
03:17:21 <dons> if it does something other than return a value computed from its parameters, then the function has performed a side effect
03:17:48 <rretzbach1> Isn't that possible with haskell too?
03:17:52 <dons> so, e.g. double sin(double); in C is not side effecting
03:17:59 <TSC> If it matters *when* you perform some action, a side effect is probably involved
03:18:04 <dons> while putchar is. it returns () and writes something to the screen
03:18:18 <rretzbach1> Yes.
03:18:19 <dons> rretzbach1: side effects are certainly possible in haskell, but they're not allowed by default
03:18:42 <rretzbach1> Hmm. I am thinking about IO too.
03:18:58 <dons> yes, IO involves side effects
03:19:01 <dons> :t getChar
03:19:03 <lambdabot> IO Char
03:19:13 <dons> states that getChar produces a Char value, but does some IO as well
03:19:21 <dons> :t 'x' -- is just a Char that does nothing else
03:19:23 <lambdabot> Char
03:19:37 <dons> :t putChar
03:19:40 <lambdabot> Char -> IO ()
03:19:53 <dons> takes a Char, returns (), but does some side effect (which you can guess :)
03:20:03 <dons> :t ord
03:20:06 <lambdabot> Char -> Int
03:20:21 <dons> doesn't, its 'pure', it computes an ascii value based soley on its argument, and nothing else
03:20:36 <dons> as you can probably guess, non-side effecting code is a fair bit easier to understand
03:20:46 <rretzbach1> Yes.
03:20:51 <dons> this also makes it easier to optimise, and to avoid bugs relating to when and how effects occur
03:21:15 <rretzbach1> last sunday I had absolutely 0 knowledge of Haskell.
03:21:20 <dons> welcome! :-)
03:21:36 <rretzbach1> But I spent as much time as possible learning the last days
03:21:39 <dons> a good place to start is with one of the tutorials on haskell.org, the wikibook or yaht for example :)
03:21:44 <rretzbach1> Yes.
03:21:45 <dons> also, install ghc, and work through some code
03:21:50 <rretzbach1> I am reading them.
03:21:57 <rretzbach1> And now I am in the Monad chapter.
03:22:05 <rretzbach1> And it begins with side effects.
03:22:15 <dons> ah ha, welcome to 'how to do side effects in a language that doesn't allow them by default' :-)
03:22:25 <dons> the main thing is to ensure side effects occur in the right order
03:22:36 <rretzbach1> Thanks :D
03:22:41 <dons> that order is baked into imperative languages: you do one step after each other.
03:23:00 <goltrpoat> bulat, i think, had a nice explanation of issues with the pre-monadic RealWorld style IO in haskell, that i thought was a pretty good motivating example for why things are done the way they're done
03:23:27 <goltrpoat> can't think of the url off the top of my head.  should be on the wiki somewhere.
03:24:33 <helmut> hum. can I somehow define a type Foo in one file and in another file which must not depend on the first file tell haskell that there is a type Foo and use it in a data constructor which is never used in that file?
03:24:35 <goltrpoat> not sure if it was bulat, come to think of it.  it basically started with the "suppose we have a getChar :: Char" and went from there.
03:24:42 <augustss_> g'day dons
03:24:48 <dons> hey augustss_
03:25:21 <helmut> (polymorphism doesn't work in my case)
03:25:23 <dons> helmut: the existence of the type 'Foo', if you name it, requires importing Foo's module
03:25:31 <sphynx> dons: Hi!
03:25:40 <goltrpoat> helmut:  are you trying to break a circular dependency?
03:25:41 <dons> possibly you could define an interface Foo's support, and then just interact via the interface
03:25:47 <dons> hey sphynx
03:25:48 <helmut> goltrpoat: maybe.
03:26:11 <dons> augustss_: so you're workng up to a full embedding of haskell in haskell, with harpy? :-)
03:26:15 <sphynx> dons: So can I read new article about strictness keywords? :)
03:26:23 <dons> sphynx: oh right! yes, i should do that.
03:26:43 <augustss_> dons: well, you can't get full haskell with the same syntax :(
03:27:09 <augustss_> but my next blog post will get me closer.  i'll just have to write the code first
03:27:13 <dons> augustss_: might be fun to say, outperform ghc for some doman-specific task, with a custom code generator. that'd be cute.
03:27:42 * dons thinks of the polymer simulator stuff Gabi and I were working on.. but without gcc involved
03:27:48 <augustss_> oh, it's easy to outperform ghc on say, strict numeric functions
03:27:52 <goltrpoat> dons:  i have a simple optimizing compiler using harpy on my list-o-posts-to-write
03:27:53 <dons> yeah
03:28:02 <goltrpoat> harpy is seriously fun to play with.
03:28:32 <dons> a custom generator for some numercs (hmm, a hash function perhaps?) would be nice.
03:28:35 <augustss_> i wish harpy had floating point instructions
03:29:16 <dons> goltrpoat: yeah, embedding, say, nice strict, MiniML in haskell, with harpy, would be fun
03:29:49 <helmut> goltrpoat: I have got a parser, an evaluator and two compilers importing the parser. Now for lifting values to expressions in the evaluator I'd like to extend expressions by a Literal Value constructor without modifying the compilers.
03:30:09 <goltrpoat> dons:  might be too long for a post.  i wanted to talk about SSA and register coloring.
03:30:54 <goltrpoat> so some tiny imperative language, probably.
03:31:00 <dons> yeah, that would be a useful.
03:31:21 <dons> you could almost do the subset of C-- that ghc handles...
03:31:34 <augustss_> I thought i'd cover SSA when I do CSE, which will have to be soon.
03:32:40 <dons> augustss_: i've collected the links here, for the series, btw, http://haskell.org/haskellwiki/Blog_articles/EDSLs
03:32:41 <lambdabot> Title: Blog articles/EDSLs - HaskellWiki
03:33:06 <augustss_> dons: thanks!
03:33:06 <goltrpoat> augustss:  ah cool
03:33:48 <sphynx> Is there some way to use hidden package of library?
03:33:50 <augustss_> if you do an embedded DSL in Haskell you'll need CSE since the Haskell let does not give you sharing
03:33:55 <goltrpoat> augustss:  SSA is like.. this giant advertisement for functional programming.
03:34:01 <dons> hmm, it would be nice to link from the harpy hackage.haskell.org page across to blog articles showing how to use it
03:34:07 <dons> and for other libraries
03:34:23 <dons> some way to add external doc links to hackage pages.
03:34:38 <sphynx> I need to build cabal-rpm but it uses Distribution.Compat.FilePath module which is hidden
03:34:40 <dons> goltrpoat: yeah , you've see the ANF == SSA paper?
03:34:51 <goltrpoat> dons:  i haven't.. link?
03:35:43 <Saizan> would be feasible to use phantom types to annotate DSL expressions with a type level list of registers used, so that you can save only those?
03:36:11 <dons> so Appel I think was the guy who first suggested SSA was just another functional language, but that's since been elaborated here , http://www.cse.unsw.edu.au/~chak/papers/CKZ03.html
03:36:11 <lambdabot> Title: Research Papers of Manuel Chakravarty
03:36:32 <dons> "we discuss a new formalisation of the mapping from SSA programs to a restricted form of lambda terms, called administrative normal form (ANF)"
03:36:38 <goltrpoat> saizan:  that sounds like that'd give you a logical but suboptimal allocation
03:36:41 <goltrpoat> unless i'm missing something
03:36:47 <dons> and an awful lot easier to understand than wacky old SSA.
03:38:38 <goltrpoat> dons:  i've done some work with SSA on a compiler in C++ ages ago, for a C++-derived language, which was amazingly painful.  so then while working on a compiler for a pure functional language, i just sort of put two and two together.
03:39:40 <goltrpoat> in a compiler for an imperative language, you're taking your imperative program, *converting it* to a functional representation, doing analysis on that, and then moving on.
03:40:14 <goltrpoat> somehow this seemed a reasonable thing to do when i was working in c++.
03:40:30 <Philippa> yeah, but C++ fucks you up
03:40:39 <hpaste>  baakar pasted "baakar" at http://hpaste.org/1452
03:42:07 <dons> more spam. silly
03:43:20 <thoughtpolice> dons: i tried to email you a patch for mkcabal but I got an err on repo format. :/ it seems that darcs is confusing the repo dir with your uni's err page or somesuch.
03:43:56 <dons> hmm, there was a file server issue earlier in the week,
03:44:01 <dons> perhaps pull and try again?
03:44:11 <goltrpoat> philippa:  well, not permanently, apparently.
03:45:36 <thoughtpolice> dons: even for pulls it seems I get the same repo err. :(
03:46:03 <dons> what url?
03:46:34 <thoughtpolice> _darcs/prefs/defaultrepo is set to http://www.cse.unsw.edu.au/~dons/code/mkcabal/
03:46:35 <lambdabot> Title: Index of /~dons/code/mkcabal
03:46:43 <dons> $ darcs pull http://www.cse.unsw.edu.au/~dons/code/mkcabal
03:46:43 <lambdabot> Title: Index of /~dons/code/mkcabal
03:46:47 <dons> yeah, seems to work here.
03:46:51 <thoughtpolice> i'll try a fresh get and just copy the changes over
03:46:59 <goltrpoat> philippa:  it's sort of funny, too.  i've been programming in imperative languages for 19 years now, with about 3 years of functional languages.  i'm very good at c++, i'm average at haskell.
03:47:18 <goltrpoat> philippa:  i noticed recently that i do all of my prototyping in haskell.
03:47:47 <dons> goltrpoat: oh, that's interesting. i find haskell (and type decls) make a great pseudocode
03:48:03 <thoughtpolice> dons: unfortunately it's not as joyful over here. :(
03:48:16 <dons> thoughtpolice: hmm. you can't 'get'?
03:48:20 <goltrpoat> as in, basically, anything that needs to be done quickly, ends up being done in haskell.  i can think of one exception, where i was playing with ILP and ended up doing it in prolog.
03:48:20 <thoughtpolice> i can't even make a bundle from the patch via send. otherwise I'd just email it to you. :(
03:48:31 <dons> $ darcs get http://www.cse.unsw.edu.au/~dons/code/mkcabal/
03:48:31 <dons> Copying patch 16 of 16... done!
03:48:31 <dons> Applying patch 16 of 16... done.
03:48:31 <dons> Finished getting.
03:48:31 <lambdabot> Title: Index of /~dons/code/mkcabal
03:48:40 <thoughtpolice> dons: no, get worked fine. but trying anything else (pull, send, etc) results in a repository format error
03:49:13 <dons> oh, odd version of darcs ?
03:49:16 <thoughtpolice> and the output is HTML, so I assume it's thinking some sort of uni err page is the repo, hence :(
03:49:21 <dons> hmm. ok.
03:49:32 <thoughtpolice> 1.0.8 release
03:49:34 <dons> very strange, no one else has reported problems.
03:49:41 <thoughtpolice> quite.
03:49:42 <psykotic> goltrpoat, yo
03:49:47 <dons> $ darcs --version
03:49:47 <dons> 1.0.9rc2 (release candidate 2)
03:49:51 <dons> if that helps.
03:49:55 <goltrpoat> psyk:  hey dude.
03:50:07 <thoughtpolice> hm i'm running openbsd, haven't had time to compile 1.0.9
03:50:18 <thoughtpolice> i'll go for that and try again
03:50:25 <goltrpoat> psyk:  you missed a computational geometry conversation earlier.
03:50:59 <thoughtpolice> dons: actually i think my linux box has 1.0.9, so I'll try that first.
03:51:55 <psykotic> goltrpoat, i'm too busy cursing's java's retarded type erasure
03:52:13 <thoughtpolice> dons: ah, that was it. :) i'll update then darcs send.
03:52:18 <psykotic> messing around with scala... which is absolutely awesome, except for the sake that it has to run on the jvm :)
03:52:25 <psykotic> *for the fact
03:53:40 <dons> thoughtpolice: ok cool.
03:54:03 <goltrpoat> psykotic:  ...
03:54:05 <goltrpoat> java? :)
03:54:24 <goltrpoat> why are you doing java
03:55:18 <goltrpoat> as a side note, have you done cantor-zassenhaus?  i had some questions for you, but i can't read my notes, and this was a few weeks ago.
03:55:21 <thoughtpolice> i heard scala was actually pretty nice. i haven't touched outside of haskell or erlang really though for anything other than testing (i looked at nemerle for a while, though)
03:55:39 <psykotic> goltrpoat, because scala is a very slick language and java does have a great ecosystem of libraries. but the jvm sucks.
03:55:56 <goltrpoat> ah
03:56:06 <Saizan> can i tell haddock to not try to link with the documentation of imported packages?
03:56:24 <goltrpoat> i'm avoiding the jvm, possibly to my detriment.  way too many bad experiences with j2me.
03:56:31 <psykotic> goltrpoat, cantor-zassenhaus? is that a theorem or a book?
03:56:54 <goltrpoat> it's an algorithm for factorizing polynomials over finite fields
03:57:37 <psykotic> sorry, don't recall it
03:58:18 <psykotic> i do remember the berlekamp algorithm though, which i think does the same thing
03:58:25 <goltrpoat> looking at the wikipedia page, it seems straightforward, so i think i may have been drunk when i wrote down the questions, considering i can't read it.
03:58:30 <goltrpoat> yes, berlekamp does the same thing
03:58:52 <goltrpoat> C-Z is newer.
03:59:07 <psykotic> anything named after cantor and zassenhaus, two long dead mathematicians, is newer? hah!
03:59:13 <goltrpoat> yes :)
04:00:18 <psykotic> oh, it's another cantor
04:00:28 <goltrpoat> and another zassenhaus.
04:00:43 <psykotic> no, looks like it's the same zassenhaus
04:00:55 <goltrpoat> or maybe the same zassenhaus
04:00:56 <goltrpoat> ah.
04:01:17 <goltrpoat> i sort of assumed the cantor bit was after cantor's randomized algorithm for factoring.. uh.  p^n-1, was it?
04:02:03 <goltrpoat> wait, that wasn't even cantor.
04:02:56 <Igel> is there a way to generete pdf or latex with haddock?
04:03:26 <goltrpoat> there's lhs2tex
04:03:56 <Igel> the thing is, we have haddock comments
04:04:10 <Igel> but we need a pdf :/
04:04:35 <Igel> lhs is a different format, isn't it?
04:05:49 <goltrpoat> psykotic:  oh, i remember what my questions were.  i don't know if you've done anything with this, i just sort of assume you've done everything until proven otherwise.  apparently, the idea is that if you're in Z, you start with some prime p, and then use hensel lifting to go to bigger and bigger finite fields modulo p.
04:06:09 <goltrpoat> then you stop at some point.
04:06:35 <psykotic> hensel lifting? you mean apply hensel's lemma?
04:07:39 <goltrpoat> k, so suppose we have a root of a(x), mod p^i.  we can find a root, mod p^{i+1}
04:08:12 <goltrpoat> we'll do this by expanding a about x, coming up with a polynomial identity, and doing various magic.
04:08:36 <psykotic> k, sounds related to hensel's lemma
04:08:46 <psykotic> which basically says that if something has a root p^n for all n, then it has a root over Z
04:08:51 <psykotic> (i think)
04:10:40 <psykotic> actually i think that's over p-adic fields. it's been too long since i did any of this stuff, so i doubt i can be much help.
04:11:31 <goltrpoat> ah ok
04:11:54 <goltrpoat> i keep picking this up once every couple of weeks, making a little progress, and then not having any time to continue
04:12:31 <thoughtpolice> dons: nevermind. apparently the problem only manifests on my obsd box. :/ don't know why, but it's pretty annoying. i'll just have to copy it to my linux box and mail it from there.
04:12:41 <crazy_code1> which is a good GUI library in Haskell
04:14:26 <siti> gtk2hs
04:15:10 <augustss> does anyone here have any experience using haskell with eclipse?
04:15:34 <siti> augustss: do you mean using eclipsefp ?
04:15:41 <siti> so creating haskell in eclipse?
04:15:44 <augustss> yes
04:15:52 <Toxaris> augustss: a litte bit, but not too much
04:15:54 <Igel> augustss: do you have a link?
04:15:55 <siti> I have done a little bit
04:16:04 <crazy_code1>  siti: Thanks
04:16:09 <augustss> lget: just google haskell and eclipse
04:16:20 <Toxaris> http://eclipsefp.sourceforge.net/
04:16:21 <lambdabot> Title: EclipseFP - Functional programming support for Eclipse
04:16:29 <aleator> Hey, this might be silly question, but I'd like to attach a darcs disted source code inside my binaries somehow. Any ideas?
04:17:37 <aleator> Ie. I keep losing track of what changes I did to my simulation code between runs that do good or bad. They take about a day, and I forget in the meantime.. :/
04:18:42 <TSC> What if you run "darcs changes" when you run your simulation?
04:18:56 <TSC> darcs changes > output-file && ./simulation >> output-file
04:19:32 <gour> for non-eclipse people, i.e vim/emacs users, latest pida could be (much) lighter solution, see http://pida.co.uk/
04:19:33 <lambdabot> Title: PIDA Community loves you!
04:19:41 <Toxaris> I use only three features of EclipseFP (1) syntax highlighting (2) ghci  integration into eclipse console and (3) display of compiler errors in editor window. I'm not sure if there are more...
04:20:35 <siti> I am trying out the new eclipsefp version to see if I like it better than gedit ;)
04:20:44 <aleator> TSC: That would be good, but I'm not building the simulators in machine I'm running them..
04:20:56 <thoughtpolice> i guess i'm stuck with emacs since I don't use X at all. :/
04:21:12 <aleator> TSC: Which makes it bit ackward..
04:21:28 <Toxaris> but eclipsefp is partly written in Haskell, so it may be extendible
04:21:53 <TSC> Yeah, that's awkward
04:22:00 <Toxaris> code formatting would be very nice, and something like "go to declaration of this identifier"
04:22:17 <TSC> You'd need to run something when you build that inserts some text (say, the output of darcs changes) into a source file
04:22:27 <Toxaris> (yes I know emacs can all of this, since I followed the latest haskell-cafe discussion)
04:23:06 <aleator> TSC: Even more so that I'm working the code on my laptop, and the big server can only be accessed through another machine.
04:23:57 <dons> thoughtpolice: got it, thanks.
04:24:06 <aleator> TSC: I've been thinking that, not exactly certain how to proceed. Optimal case would be that when given a flag, the simulator would spew out the repo it was built from..
04:24:47 <TSC> aleator: You could use sed to insert the repo information into a source file when you build
04:24:57 <TSC> Then have that info printed by some flag
04:25:06 <TSC> It'd be a bit awkward
04:25:49 <thoughtpolice> dons: np. i'm just frusterated as to why this little issue is only apparent on my openbsd box. :/
04:27:55 <aleator> TSC: Yeah, maybe.. Then I'd need to make wrapper around the main.. How would I proceed to include binary data into haskell source?
04:28:52 <hpaste>  mattr pasted "ghci differs from ghc" at http://hpaste.org/1453
04:29:02 <matt__r> hi all
04:29:12 <TSC> aleator: I was thinking you'd include just information about the repo, not the repo itself
04:29:14 <matt__r> the pasted code works correctly in ghci, but not in ghc
04:29:26 <dons> thoughtpolice: weird, i'm using openbsd too, but not issues with darcs or curl
04:29:28 <TSC> Enough to identify exactly which patches are included
04:29:32 <matt__r> in ghc, the question mark is not printed until after the readline
04:29:36 <matt__r> any ideas?
04:29:43 <dons> thoughtpolice: hmm, you built darcs yourself?
04:30:16 <astrolabe> Is there a standard function called 'comparing'?
04:30:21 <dons> astrolabe: yep
04:30:28 <aleator> TSC: I know :) But I'm so sloppy with my work, that I'll probably lose the repo in mean time :)
04:30:31 <astrolabe> dons: where does it live?
04:30:41 <dons> ?hoogle comparing
04:30:42 <lambdabot> No matches found
04:30:53 <dons> $ grep comparing ghc/libraries/base/Data/*
04:30:53 <dons> ghc/libraries/base/Data/Ord.hs:   comparing
04:31:05 <dons> :)
04:31:08 <astrolabe> thanks :)
04:31:21 <thoughtpolice> dons: yeah
04:31:34 <astrolabe> Now I want to know what that '$' did.
04:31:37 <thoughtpolice> The Glorious Glasgow Haskell Compilation System, version 6.6.1
04:31:40 <ski> @type Data.Ord.comparing
04:31:42 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
04:31:43 <thoughtpolice> :( cry
04:32:00 <dons> thoughtpolice: hang on, i've an idea..
04:32:14 <dons> thoughtpolice: first, you've checked with 1.0.9?
04:32:27 <TSC> aleator: Maybe it would be easier to tar up the repo when you copy the program from your development-machine to your execution-machine
04:32:33 <TSC> And keep track of it by hand
04:34:04 <aleator> TSC: Well your right.. getting a notebook from storeroom is probably the best solution.
04:34:13 <gour> have you seen http://www.slideshare.net/Arbow/comparing-cpp-and-erlang-for-motorola-telecoms-software/
04:34:16 <lambdabot> Title: Comparing Cpp And Erlang For Motorola Telecoms Software » SlideShare, http://tinyurl.com/35q82u
04:34:17 <thoughtpolice> dons: yes, i got the repo and after that, a pull came up with the same repo err.
04:34:50 <dons> the one thing you could try would be to edit the darcs source file FastString, removing the call to (do {{-c_munmap p $ fromIntegral l;-}
04:35:26 <dons> i've in the past had trouble with c_munmap on openbsd -- due to the invalidating it does. not sure, but i'm pretty sure my darcs runs without this.
04:35:39 <dons> i might be grasping at straws though, since munmap failing would manifest with segfaults
04:35:44 <dons> not repo errors, afiak
04:36:08 <thoughtpolice> dons: hm. first let me see if it's a problem outside of mkcabal (i wish my repo's were up right now.) i'll just try pulling yi or something.
04:36:28 <dons> ok.
04:37:45 <thoughtpolice> hm no. it doesn't seem to have an issue with darcs.haskell.org.
04:37:57 <dons> ok. good. so maybe just a web server issue
04:38:01 <dons> strange though.
04:38:04 <thoughtpolice> yes, that's what I'm thinking
04:38:16 <thoughtpolice> since I've been using darcs on this box for a while, no error like that has ever manifested.
04:38:29 <thoughtpolice> strange though, definately.
04:38:32 <dons> let me move the repo, see if it works from elsewhere.
04:39:46 <dons> oh, sorry, that won't work. my other machine is playing silly buggers
04:39:53 <thoughtpolice> dons: ah crap. i noticed in my patch i forgot to add the util I used to create haskellized-licence code from just a plain piece of text (just a 5min perl script.)
04:42:10 <thoughtpolice> dons: sent a [new] patch. my bad on that note.
04:43:11 <nominolo> dons: i'm the cabal-guy.  the hackage guy is currently not very active on irc
04:44:45 <thoughtpolice> dons: apparently the problem only manifests on openbsd, *only* in your code/ repositories. so yeah, my thoughts are leading to web-server buggery.
04:45:14 <rretzbach1> Not having read the whole "understanding monads" page, I am thinking "monads aren't that hard to understand"
04:45:20 <rretzbach1> We'll see if that changes.
04:46:48 <thoughtpolice> rretzbach1: just keep that kind of attitude and practice a little and the general story will be clinched for you in no time, I found. :)
04:47:24 <rretzbach1> Then arrows!
04:47:51 <dons> thoughtpolice: can you try pulling from http://code.haskell.org/~dons/code/mkcabal/
04:47:53 <lambdabot> Title: Index of /~dons/code/mkcabal
04:48:47 <dons> nominolo: ah ok.
04:48:52 <thoughtpolice> dons: no errors. :/
04:49:09 <dons> so the cse server is being weird.
04:49:15 <thoughtpolice> i think your uni's server just doesn't like me or something. :/
04:49:50 <hpaste>  matt__r pasted "different in ghc and ghci" at http://hpaste.org/1454
04:50:08 <matt__r> got it down to the smallest broken code
04:50:30 <matt__r> Why is this code giving different results in ghc and ghci?
04:50:33 <matt__r> strange
04:51:14 <mehrheit> ghci flushes stdin
04:51:20 <mehrheit> ghc buffers it until newline
04:51:25 <matt__r> cool
04:51:34 <mehrheit> put 'hFlush stdin' after putStr
04:51:46 <matt__r> I figured that is what was happening - but why is the really interesting question?
04:52:26 <matt__r> mehrheit++
04:53:15 <mehrheit> probably because ghci prints the Module> w/o \n and waits for input
04:57:45 <matt__r> hFlush stdin is not working though
04:57:59 <matt__r> I get  <stdin>: hFlush: illegal operation (handle is not open for writing)
04:58:25 <mehrheit> oops, it's stdout
04:58:48 <matt__r> ack! I just realised that!
04:58:54 <matt__r> now I feel like a right pillock
04:59:10 <matt__r> you only typed the mistake once, I was trying ot over and over again :)
04:59:15 <matt__r> \me hides in corner
05:07:35 <fasta> Can I derive Num instances?
05:09:09 <fasta> Never mind
05:09:44 <dons> for newtypes over Num types
05:11:09 <thoughtpolice> what would be the easiest way to go from String -> ByteString? if you could just do something like pack . map (toWord8) "..." (where toWord8 :: Char -> Word8, naturally) that would be good enough. i'm trying to find a simple or elegant way to do this.
05:11:19 <dons> Data.ByteString.Char8.pack :-)
05:11:29 <dons> useful for string literals
05:11:56 <dons> the *.Char8 modules provide String-converted versions of Data.ByteString
05:12:18 <cinimod> @where when
05:12:18 <lambdabot> I know nothing about when.
05:12:30 <dons> ?index when
05:12:30 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
05:12:36 <dons> ?hoogle when
05:12:37 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
05:12:37 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
05:12:48 <cinimod> thanks
05:13:11 <thoughtpolice> dons: thanks. :)
05:13:12 <thoughtpolice> dons++
05:16:01 <bluestorm> @src Monad.when
05:16:01 <lambdabot> Source not found. My mind is going. I can feel it.
05:16:24 <Saizan> @src when
05:16:24 <lambdabot> when p s = if p then s else return ()
05:47:20 <nopcode> hey :)
05:48:11 <nopcode> i have a simple (Tree a) datatype and an inorder traversal function that returns [a]
05:48:19 <nopcode> how do i define a show-function for that?
05:48:53 <nopcode> that is, i want it to perform "show (inorder t)" for any tree t
05:49:09 <mehrheit> show is already defined for lists ([])
05:49:22 <nopcode> yeah but that doesnt help
05:49:40 <nopcode> instance Show (Tree a) where sho
05:49:43 <Toxaris> instance (Show a) => Show (Tree a) where show = show . inorder
05:49:47 <nopcode> wpardon
05:50:56 <nopcode> ok that works
05:50:59 <nopcode> could you explain it, too? *G*
05:51:08 <nopcode> the dot is for function concatenation?
05:51:12 <Toxaris> yep
05:51:18 <Toxaris> in prosa:
05:52:17 <Toxaris> given a tree over a showable type, showing it means computing the inorder traversal and showing it, wich is easy because the element type is showable
05:52:40 <Toxaris> instance (Show a) => Show (Tree a) says that only trees with showable elements are showable
05:52:51 <nopcode> that part is what i dont understand
05:53:02 <nopcode> => is derivation of some kind?
05:53:09 <Toxaris> it's a precondition
05:53:23 <Toxaris> instance A => ... means that ... is valid only if A holds
05:53:33 <scook0> "if a is showable, then Tree a is showable"
05:53:53 <nopcode> so it could be omitted? :)
05:54:20 <scook0> only if you can find an instance for Show (Tree a) that doesn't rely on a being showable
05:54:36 <scook0> which prevents you from actually showing any of the elements
05:55:06 <igli> http://www.haskell.org/tutorial/goodies.html let inc n=n+1 -- doesn't work in lambdabot?
05:55:06 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
05:55:35 <igli> > let inc n=n+1
05:55:35 <lambdabot>  Parse error
05:55:50 <mehrheit> > let inc n = n+4 in inc 1
05:55:53 <lambdabot>  5
05:56:09 <igli> oh i can't save a def'n in lambdabot? ty
05:56:27 <mehrheit> it's @let
05:56:41 <igli> ah thanks :-)
05:57:50 <mux> @type on
05:57:52 <lambdabot> Not in scope: `on'
05:58:08 <mux> @let on f g x y = f (g x) (g y)
05:58:10 <lambdabot> Defined.
05:58:13 <mux> @type L.on
05:58:16 <lambdabot> Couldn't find qualified module.
05:58:20 <igli> er i get 'Defined.' and then that not in scope err for type
05:58:58 <mux> LB is broken, @let should add the definition to the qualified L namespace
05:59:10 <igli> ok thanks :)
05:59:25 <erider> good morning
05:59:32 <yakov> hello
05:59:36 <igli> hi
06:00:47 <Serge> @let inc'' n = n + 1
06:00:49 <lambdabot> Defined.
06:00:53 <Serge> > inc'' 5
06:00:55 <lambdabot>  6
06:01:53 <mux> > sortBy (compare `on` snd) [('a', 4), ('b', 2), ('c', 3)]
06:01:55 <lambdabot>  [('b',2),('c',3),('a',4)]
06:02:19 <mux> so now LB's @let adds stuff directly into the base namespace?
06:02:35 <scook0> @src on
06:02:35 <lambdabot> (*) `on` f = \x y -> f x * f y
06:02:52 <Serge> > sortBy (\(x,y) -> y) [('a',4), ('b', 2), ('c',3)]
06:02:53 <lambdabot>      Occurs check: cannot construct the infinite type:
06:02:53 <lambdabot>       t = (t1, t) -> O...
06:03:03 <nopcode> foldl (insert) Null [42,23,1,101,55,11,72]
06:03:04 <nopcode> [1,11,23,42,55,72,101]
06:03:08 <nopcode> yay, it works *g*
06:03:23 <nopcode> insert is the tree insert-function =)
06:05:31 * mux hearts the 'on' combinator
06:05:43 <mux> it lets you write really beautiful things: map (maximumBy (compare `on` snd)) . groupBy ((==) `on` fst)
06:06:32 <SamB> mux: me too
06:07:07 <SamB> the compare function isn't half bad, either ;-)
06:07:13 * mux nods :)
06:07:29 <nopcode> btw how do you do find the element with minimum "cost" from a list? by zipping elements with their cost and comparing these two-tuples?
06:07:52 <SamB_XP> nopcode: depends how expensive it is to calculate "cost"
06:08:29 <nopcode> SamB_XP: i mean the academical, short solution *g*
06:09:10 <SamB_XP> well, you could just use minimumBy (comapre `on` cost)
06:09:26 <SamB_XP> if cost isn't too expensive to calculate
06:09:33 <SamB_XP> and if you spell better than I do
06:09:37 <nopcode> *g*
06:09:59 <nopcode> so what does "on" do?
06:10:35 <scook0> it compares two values, in a user-defined way
06:10:48 <SamB_XP> scook0: not compares
06:10:50 <LoganCapaldo> f `on` g = \a b -> f (g a) (g b)
06:11:31 <scook0> oh, yeah, I was only thinking of comparative fs
06:11:36 <nopcode> ahhh i see
06:11:38 <scook0> but I suppose it could be any binary op
06:11:44 <SamB_XP> yeah ;-)
06:11:51 <nopcode> and haskell doesnt simply use '<' for ordering... that was confusing me
06:11:56 <scook0> hooray for generic combinators
06:12:13 <scook0> nopcode: what do you mean?
06:12:17 <scook0> > 1 < 2
06:12:20 <lambdabot>  True
06:12:40 <nopcode> well does that work for minimumBy?
06:12:49 <SamB_XP> no...
06:12:55 <SamB_XP> @src compare
06:12:55 <lambdabot> compare x y | x == y    = EQ
06:12:55 <lambdabot>             | x <= y    = LT
06:12:55 <lambdabot>             | otherwise = GT
06:12:57 <scook0> :t minimumBy
06:12:59 <lambdabot> forall a. (a -> a -> Ordering) -> [a] -> a
06:12:59 <nopcode> can you do... (minimumBy (on < cost))
06:13:00 <LoganCapaldo> scook0: Some langs go out of their way to only call < for things like sorting, or trees, etc.
06:13:06 <nopcode> i see
06:13:09 <SamB_XP> that's the default implementation of compare
06:13:17 <nopcode> LoganCapaldo: thats what i mean
06:13:23 <nopcode> c++ uses operator< by default
06:13:28 <nopcode> that is, the std library
06:13:36 <SamB_XP> LoganCapaldo: don't you mean libraries?
06:13:49 <mux> nopcode: if you've done perl before, compare is more like <=>
06:14:00 <LoganCapaldo> SamB_XP: yeah.
06:14:02 <nopcode> mux: argh, i hate perl ;)
06:14:08 <mux> who doesn't?
06:14:16 <nopcode> but i get the point
06:14:21 <mux> but if you know perl's <=> it still helps you understanding compare :-)
06:14:28 * LoganCapaldo deletes -pedantic from SamB_XP 's compiler options
06:15:13 * SamB_XP gives a flag error upon his next invocation
06:15:34 <scook0> Ord can deduce all the comparison operators from a definition of (<=), if you want it to
06:16:02 <SamB_XP> so true
06:16:12 <SamB_XP> or from the definition of compare
06:16:12 <scook0> and once a type is known to be ordered, you can use whatever comparison you like
06:16:20 <scook0> indeed
06:17:12 <LoganCapaldo> ability to have default implementations of class functions (that overlap with each other)++
06:17:29 <mehrheit> @karma ability to have default implementations of class functions (that overlap with each other)
06:17:29 <nopcode> hmm i'm looking for a problem to solve to get some haskell experience
06:17:29 <lambdabot> ability has a karma of 0
06:17:37 <SamB_XP> @karma other)
06:17:37 <lambdabot> other) has a karma of 1
06:17:52 <LoganCapaldo> eh
06:17:57 <mux> ++++
06:18:03 <LoganCapaldo> what are you gonna doo
06:18:03 <mux> @karma ++
06:18:03 <lambdabot> ++ has a karma of 2
06:18:32 <SamB_XP> @karma xs
06:18:32 <lambdabot> xs has a karma of 1
06:19:31 <nopcode> i suppose things like red-black trees are relatively easy to implement in haskell thanks to pattern matching?
06:19:44 <mux> shockingly easy
06:20:00 <nopcode> :)
06:20:27 <augnob> out of curiosity, where are red-black trees used?  in my experience, things end up getting creatively worked into hash tables most of the time
06:20:42 <LoganCapaldo> mux: with or without parent pointers? <g>
06:20:47 <mux> you don't necessarily use the same data structures as in imperative languages with haskell, and I'm not sure re-black tress are used much in haskell
06:20:52 <mux> LoganCapaldo: heh
06:21:07 <mux> but trees are very very easy to deal with
06:21:55 <LoganCapaldo> rotations are probably slightly more annoying as well. pattern matching is definitely a win for traversing the tree
06:21:57 <nopcode> augnob: i've never used balanced trees before but for one you cant walk a hashtable inorder
06:23:32 <hpaste>  nestaninv pasted "nestaninv" at http://hpaste.org/1455
06:23:37 <augnob> well.. the hash index can be a supplement, so there are ways to do such things
06:23:57 <LoganCapaldo> gah
06:24:07 <LoganCapaldo> spam again
06:24:42 <nopcode> augnob: how do you mean?
06:25:05 <mux> pattern matching, affordable recursion and recursive data-types make for easy trees :)
06:25:23 <augnob> nopcode: hashes can index into many different kinds of data structures, if you like
06:26:00 <mux> when you can write: data MyTree a = Leaf a | Node a (MyTree a) (MyTree a), you know things are going to be easy :-)
06:26:00 <nopcode> augnob: hm
06:26:04 <augnob> nopcode: sometimes a hash table gives you objects themselves, or other times pointers
06:26:22 <augnob> nopcode: if it's a pointer.. then that could be going anywhere.  you just may have to do your maintenance differently.
06:26:25 <LoganCapaldo> well you don't necessarily use a tree for a map either
06:26:45 <LoganCapaldo> hash isn't gonna help if you want to do a tree sort for instance
06:26:50 <nopcode> augnob: but how would you know where to insert elements in that other datastructure? ;)
06:27:43 <augnob> it depends a lot on what you're doing.  it's just from my experience, I had plans of using fancy data structures.. but after graduation, found those plans got shot down by hash tables and simple data structures all the time.
06:28:11 <augnob> it could depend on your needs though of course
06:28:17 <nopcode> yeah it depends, if you have stuff like range-searches trees might be better
06:28:21 <nopcode> like, geometric stuff
06:28:29 <nopcode> geospatial
06:28:51 <mux> 2-3 finger trees ftw!
06:29:08 <augnob> yeah, trees get used.  I just haven't come across real use of things like red-black trees and avl trees
06:29:14 <nopcode> mux: what? %)
06:29:27 <dons> ?docs Data.Sequence -- these guys
06:29:27 <lambdabot> Data.Sequence -- these guys not available
06:29:30 <dons> hah
06:29:31 <nopcode> augnob: i suppose people rather use B-trees
06:29:35 <mux> heh
06:29:37 <dons> ?docs Data.Sequence
06:29:38 <lambdabot> Data.Sequence not available
06:29:43 <dons> oh, not in 6.4
06:29:49 <dons> ?docs Data.List
06:29:49 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
06:29:57 <LoganCapaldo> red-black trees are "fancy
06:29:58 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Sequence.html
06:30:00 <LoganCapaldo> "?
06:30:00 <lambdabot> http://tinyurl.com/yz86s7
06:30:15 <LoganCapaldo> dons: you can't kill the spam can you?
06:30:22 <dons> i can.
06:30:26 <dons> do we have some?
06:30:33 <LoganCapaldo> 1455
06:30:40 <mux> augnob: it's not that rare to need to deal with trees or graphs; even a package manager software needs to handle DAGs
06:30:42 <dons> we do. i will wield my lambda at it.
06:30:50 <augnob> logancapaldo: I don't remember what exactly they are.  I remember they were a little goofy though.
06:31:06 <nopcode> yeah wikipedia says they have many cases
06:31:10 <augnob> mux: yeah, I use trees a lot of course.  just not the self-balancing type
06:31:11 <mux> augnob: I have some C (!) code using binary trees to store arbitrarily complex expressions on pathnames
06:31:16 <nopcode> like 5 different cases when inserting and removing nodes each
06:32:17 <mux> the FreeBSD kernel uses splay trees to deal with vm_map'w
06:32:22 <mux> s/w$/s/
06:32:42 <LoganCapaldo> i had a friend who got really excited about splay trees once
06:32:48 <mux> but dealing with trees in C is annoying, you always have to re-recursify things
06:33:01 <hughperkins> Hi, trying to figure out how to do a read within a function where the incoming data type is not necesarily an instance of Read
06:33:03 <mux> grr, de-recursify I meant
06:33:21 <nopcode> "A splay tree is a self-balancing binary search tree with the additional unusual property that recently accessed elements are quick to access again."
06:33:24 <nopcode> ic
06:33:25 <dons> wow, original yale haskell system, http://www.cs.cmu.edu/afs/cs/project/ai-repository/ai/lang/lisp/code/syntax/haskell/src_205.tgz (haskell in lisp)
06:33:28 <lambdabot> http://tinyurl.com/3bqdvm
06:33:37 <mux> splay trees are great
06:35:46 <Igel> mux: don't splay trees need sideeffects when reading from then?
06:35:57 <Igel> i might mix this up
06:35:59 <LoganCapaldo> hughperkins: do you want to use read on values that aren't necessarily instances of read or do you want to use read if it's availble and something else if it's not?
06:36:11 <mux> I've always used them in imperative languages
06:36:20 <mux> but they can definitely be used in functional languages
06:36:25 <Igel> but splay trees statistically balance themselves during all operations, i think
06:36:32 <mux> you need no side-effects to transform a tree
06:36:36 <Igel> yeah
06:36:43 <Igel> but you would have something like
06:36:58 <Igel> elem :: a -> STree a -> (Bool, STree a)
06:37:00 <mux> we would have a splay function taking a splay tree and returning another
06:37:11 <mux> splaying an element of it
06:37:21 <mux> maybe this could be done with zippers too, I'm not sure
06:37:53 <LoganCapaldo> that type for elem almosts makes me think "Monad!"
06:38:05 <LoganCapaldo> but it would probably have to be (Ord a) => right?
06:38:33 <mux> LoganCapaldo: aren't we going to get restricted monads in ghc 6.8 anyways, btw?
06:38:40 <LoganCapaldo> mux: I dunno
06:38:58 <LoganCapaldo> I did not have my finger on the pulse of ghc dev. <g>
06:40:02 <LoganCapaldo> actually, you could rework it to be State (Stree a) b
06:41:41 <Serge> Can anyone give me a concise definition of "Shunting"?
06:41:50 <siti> why?
06:41:59 <Serge> Because I don't know what it means : >
06:42:14 <siti> like a train pushing another...
06:42:15 * LoganCapaldo doesn't know what it means either
06:42:19 <LoganCapaldo> @go shunting
06:42:21 <lambdabot> http://en.wikipedia.org/wiki/Shunting
06:42:21 <lambdabot> Title: Shunting - Wikipedia, the free encyclopedia
06:42:37 <Serge> With respect to Haskell?
06:42:38 <siti> well that's not the english meaning I know :P
06:43:11 <siti> I will put it in context, A train shunts another train (e.g. a train hits into a train and moves it)
06:43:26 <Serge> I know the English definition :P
06:43:29 <mux> http://en.wikipedia.org/wiki/Shunt_%28railway_operations%29
06:43:40 <Serge> What does it mean in a Haskell context?
06:43:44 <siti> lol :S
06:43:50 <LoganCapaldo> @go haskell shunting
06:43:53 <lambdabot> http://www.kingston.ac.uk/~ku07009/HaskellWorkshop/unit2.html
06:43:53 <lambdabot> Title: Haskell Workshop: Unit 2
06:44:37 <Serge> "behaves like a train shunting carriages." :(
06:44:38 <LoganCapaldo> I've never heard that before
06:44:50 <Serge> Guess it just means what it sounds like
06:44:59 <LoganCapaldo> is it a haskell shibboleth or something?
06:45:03 <Serge> Thought it might have some ... special meaning
06:45:32 <augnob> all these terms make it harder for me to understand what people are talking about
06:46:22 <Serge> Must just be this Haskell book
06:46:35 <Serge> Keeps refering to "shunting arguments"
06:46:45 <Serge> Using the map to operator =S
06:48:01 <Igloo> You can probably read it as "moving"
06:51:34 <Serge> Thanks
06:52:13 <dons> http://programming.reddit.com/info/22g69/details :-)
06:52:14 <lambdabot> Title: Found: source for Yale Haskell - a Haskell in Lisp (reddit.com)
06:52:21 <dons> (i even put in a timeline for the project)
06:53:40 <LoganCapaldo> Last Web update on Mon Feb 13 10:30:42 1995  <--- my birthday heh
06:56:21 <nopcode> is there a "nil" value in haskell?
06:56:23 <nopcode> or something similar?
06:57:01 <ski> why do you ask ?
06:57:12 <ski> i.e. what are you trying to do ?
06:57:37 <LoganCapaldo> just say no to nil :)
06:57:40 <nopcode> ski: i'm thinking about how to represent the empty fields in a sudoku puzzle :)
06:57:47 <dons> Nothing / Just 'x'
06:57:50 <LoganCapaldo> nopcode: Maybe Digit
06:57:52 <ski> nopcode : Maybe
06:58:03 <ski> @src Maybe
06:58:03 <lambdabot> data Maybe a = Nothing | Just a
06:58:15 <ski> @type lookup
06:58:17 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
06:58:22 <nopcode> whats "Just" and "Maybe"?
06:58:25 <dons> the type Maybe is used to represent either just a value, or nothing.
06:58:35 <dons> it has the constructors Just, and Nothing.
06:58:36 <ski> > lookup 'a' [('b',3),('a',1),('c',18)]
06:58:37 <dons> > Just 7
06:58:38 <lambdabot>  Just 1
06:58:40 <lambdabot>  Just 7
06:58:40 <ski> > lookup 'd' [('b',3),('a',1),('c',18)]
06:58:41 <lambdabot>  Nothing
06:58:51 <nopcode> so uh those arent keywords?
06:59:02 <dons> its a data type for representing possibly-empty values
06:59:05 <ski> > case lookup 'a' [('b',3),('a',1),('c',18)] of Just v -> show v; Nothing -> "oops !"
06:59:06 <lambdabot>  "1"
06:59:08 <ski> > case lookup 'd' [('b',3),('a',1),('c',18)] of Just v -> show v; Nothing -> "oops !"
06:59:10 <lambdabot>  "oops !"
06:59:11 <LoganCapaldo> no. they are constructors (functions)
06:59:33 <dons> > [[Just 1, Just 2, Nothing], [Just 7, Just 8, Nothing]]
06:59:36 <lambdabot>  [[Just 1,Just 2,Nothing],[Just 7,Just 8,Nothing]]
06:59:42 <xho> what do you guys think about a c++ style const qualifier for IORefs and other mutable variables?
06:59:44 <dons> a list of values, some of which are empty.
06:59:53 <nopcode> so could i do
06:59:58 <nopcode> data Cell = Empty | Int
06:59:59 <nopcode> ?
07:00:03 <LoganCapaldo> why would you need a const IORef?
07:00:08 <LoganCapaldo> nopcode: almost
07:00:09 <dons> nopcode: data Cell = Empty | One Int
07:00:17 <LoganCapaldo> ^^
07:00:20 <dons> which is isomorphic to the type Maybe Int
07:00:27 <ski> xho : 'IOReadRef' and 'IOWriteRef' interfaces to 'IORef' would be interesting, yes
07:00:28 <nopcode> so is maybe a keyword or not?
07:00:30 <nopcode> i dont get it
07:00:43 <dons> Maybe is a type :-)
07:00:45 <LoganCapaldo> no it's not a keyword
07:00:46 <nopcode> i read "Just" and "Maybe" all the time in the tutorials... they are self-defined aren't they?
07:00:55 <dons> ?src Maybe
07:00:55 <lambdabot> data Maybe a = Nothing | Just a
07:00:56 <crazy_code2> One is the constructor for Cell right ?
07:00:56 <ski> xho : one could even make 'IOReadRef' a (covariant) functor, and 'IOWriteRef' a contravariant functor, i think
07:01:00 <dons> that's how they're defined
07:01:03 <LoganCapaldo> they're defined in the std prelude
07:01:07 <nopcode> ah
07:01:10 <nopcode> ahh ok
07:01:18 <nopcode> so i'll use Maybe Int?
07:01:24 <LoganCapaldo> good idea~!
07:01:25 <ski> yes
07:01:36 <dons> :-)
07:01:36 <nopcode> ok thanks :)
07:01:46 <crazy_code2> An instance would be Maybe 3 right?
07:02:17 <LoganCapaldo> crazy_code2: no, Nothing or Just 3
07:02:28 <xho> ski: what do you think about having the functionality in the IORef module?
07:02:35 <ski> data ReadRef ref a = forall x. RR (x -> a) (IORef a)
07:02:45 <ski> data WriteRef ref a = forall x. WR (a -> x) (IORef a)
07:02:48 <crazy_code2> LoganCapaldo: if one uses the code that dons wrote above
07:03:07 <LoganCapaldo> which code?
07:03:21 <nopcode> how do i convert a single numeric digit to its integer representation?
07:03:21 <crazy_code2> data Cell = Empty | One Int
07:03:27 <ski> xho : possibly, yes
07:03:28 <kpreid> nopcode: read
07:03:37 <kpreid> > read "1" :: Integer
07:03:39 <lambdabot>  1
07:03:47 <xho> ski: what about other mutable variables, like IOArray?
07:03:50 <LoganCapaldo> crazy_code2: then your choices are Empty or One 3
07:03:50 <kpreid> nopcode: and in normal code you won't need the type signature I used
07:04:04 <LoganCapaldo> Maybe is a type constructor, you can't apply to a value
07:04:16 <ski> xho : hm .. mayhaps one could make a more generic interface, yes
07:04:21 <LoganCapaldo> *it to a value
07:04:30 <crazy_code2> right
07:04:35 <crazy_code2> typo
07:04:43 <crazy_code2> I meant One 3
07:05:04 <LoganCapaldo> yes. One 3 would inhabit Cell :)
07:05:13 <xho> ski: would also be useful for user types that are a composition of IORefs
07:05:17 <crazy_code2> :)
07:05:41 <ski> (er .. in above 'data' defs, i meant s/IORef/ref/ of course)
07:06:09 <nopcode> i suppose "One" is kind of a "dummy" constructor?
07:06:17 <ski> xho : example ?
07:06:18 <kpreid> nopcode: nothing dummy about it
07:06:57 <ski> 'One' tells us that there was in fact an integer here
07:07:23 <xho> ski: length2 :: IORef [a] -> IO Int; length2 x = readIORef x >>= (\l -> return length l)
07:08:08 <xho> what would the type signature look like for a const IORef?
07:08:27 <LoganCapaldo> and w/o the One we couldn't distinguish between 3 :: Cell and 3 :: Int
07:08:49 <LoganCapaldo> (you could, but not with a definition like data One = Empty | Int)
07:08:57 <dons> you can think of constructors as runtime tags telling us which version of the type we have. data T = A Int | B String, means the type T holds either Ints or Strngs, and you can tell which s which by looking at the tag.
07:09:09 <ski> xho : 'MonadRef ref m => ReadRef ref [a] -> m Int' mayhaps ..
07:09:44 <ski> or i guess we could make 'MonadReadRef' and 'MonadWriteRef' superclasses of 'MonadRef'
07:10:41 <ski> ('ReadRef' could be renamed to 'Source' and 'WriteRef' to 'Sink' ..)
07:10:54 <xho> hm..... i think this stuff is too advanced for me :|
07:11:04 <ski> hm !
07:11:23 <ski> anyway, i didn't get exactly why you chose that example ?
07:11:52 <xho> the length2 function doesn't modify the argument
07:11:55 <ski> as an example of something that only needs to read the 'IORef ...', yes ?
07:12:00 <ski> ok
07:12:01 <xho> yeah
07:12:13 <ski> anyway
07:12:19 <ski> <xho> ski: would also be useful for user types that are a composition of IORefs
07:12:23 <xho> i was thinking that it could have a type like length2 :: ConstIORef [a] -> IO Int
07:12:42 <xho> and then maybe have a function toConst :: IORef a -> ConstIORef a
07:13:05 <ski> seemed (to me) to imply that you had something more advanced in mind than simply an 'IORef ...' (that in this case happens to contain a list instead of an integer)
07:13:44 <ski> yes, your 'ConstIORef' i think is the same as my 'ReadRef IORef'
07:13:46 <xho> well, i'm not exactly sure what i'm thinking of
07:13:49 <ski> however
07:14:40 <ski> in e.g. C++, one can have 'const' pointers pointing to structures containing pointers
07:15:23 <xho> yeah, in that case you can modify the values at those pointers
07:15:31 <ski> hm .. iirc, the 'const'ness is not transitive in C++ though, so one can still mutate the locations referred to by the pointers inside that structure
07:15:49 <ski> otoh, i think i've read that in D, 'const'ness is transitive
07:15:55 <ski> so, consider in haskell
07:16:32 <ski> foo :: IOReadRef (Int,[IOReadRef Double]) -> IO Bar
07:16:41 <ski> er
07:16:46 <ski> foo :: IOReadRef (Int,[IORef Double]) -> IO Bar
07:16:56 <ski> or, longer
07:17:02 <ski> foo :: ReadRef IORef (Int,[IORef Double]) -> IO Bar
07:17:04 <ski> anyway
07:17:40 <ski> 'foo' gets a reference to a mutable cell containing pairs of integers and lists of references to mutable cells containing doubles
07:17:43 <xho> i like the c++ way, in this case foo can mutate the contents of the list
07:18:11 <ski> and the top reference cell can only be read by 'foo', not mutated
07:18:18 <nopcode> how do i get a slice from a list?
07:18:24 <ski> but the individual double cells can still be mutated
07:18:29 <nopcode> given a start index and count
07:18:37 <ski> so the 'ReadRef' is not transitive
07:18:59 <nopcode> and how do i test an element for membership in a list?
07:19:23 <xho> ski: if you wanted to ensure total 'constness' you would use IORef (Int, [Double])
07:19:41 <ski> xho : no
07:20:04 <ski> > let slice index count = take count . drop index in  slice 3 5 "abcdefghijkl"
07:20:12 <lambdabot>  "defgh"
07:20:18 <ski> > let slice index count = take count . drop index in  slice 3 5 "abcde"
07:20:20 <ski> > let slice index count = take count . drop index in  slice 3 5 "ab"
07:20:21 <lambdabot>  "de"
07:20:23 <lambdabot>  ""
07:20:32 <nopcode> ski: uh.
07:20:35 <ski> nopcode : that maybe does what you want
07:20:41 <nopcode> a bit longish ;)
07:20:59 <ski> (just define 'slice' as a utility function)
07:21:09 <ski> @hoogle Int -> Int -> [a] -> [a]
07:21:09 <lambdabot> No matches, try a more general search
07:22:08 <ski> xho : 'const'ness as a type modifier implies that there is a reference cell that *potentially* someone else can mutate
07:22:28 <ski> in '[Double]' nobody can modify the doubles
07:23:05 <kpreid> nopcode: it's long because of the variable names. take and drop by itself is short, or you can just put in that defintion of "slice" and then use it
07:23:19 <kpreid> > take 5 . drop 3 ['a'..]
07:23:21 <lambdabot>  Couldn't match expected type `a -> [a1]'
07:23:27 <kpreid> > (take 5 . drop 3) ['a'..]
07:23:29 <lambdabot>  "defgh"
07:23:43 <ski> ('const'ness as a storage class implies that nobody can mutate the implicit cell, since you've just created it, and it never had the ability to be mutated, thus nobody can)
07:24:19 <ski> ('const'ness as a storage class might imply that taking the address is invalid, i dunno)
07:25:05 <ski> > take 5 . drop 3 $ ['a'..]
07:25:07 <lambdabot>  "defgh"
07:25:09 <ski> > take 5 $ drop 3 $ ['a'..]
07:25:11 <lambdabot>  "defgh"
07:25:17 <ski> > take 5 (drop 3 ['a'..])
07:25:19 <lambdabot>  "defgh"
07:25:21 <xho> hm.... a c++ variable is like a haskell IORef, so what is a c++ pointer?
07:25:39 <Toxaris> IORef (IORef a))
07:25:45 <nopcode> slice l s n = take n (drop s l)
07:25:48 <nopcode> that will do i guess?
07:25:57 <kpreid> nopcode: yes
07:26:05 <nopcode> ah ok. that _is_ a bit shorter :>
07:26:08 <kpreid> nopcode: that's the same as ski's definition of slice above
07:26:14 <nopcode> why do you guys keep using currying
07:26:32 <kpreid> can't avoid it
07:26:35 <nopcode> hehe
07:26:40 <kpreid> perhaps you mean why we use composition?
07:26:42 <kpreid> because it's better
07:27:20 <ski> xho : a C++ variable is sorta like a constant C++ pointer pointing to a valid location, which is then like a haskell 'IORef' variable
07:27:44 <nopcode> that too
07:27:47 <nopcode> but also, currying
07:27:59 <nopcode> omitting function arguments
07:28:03 <Toxaris> ski: is there a pragmatic difference between (IO a) and (ReadRef a)?
07:28:23 <ski> xho : remember that you can take the address of a C++ variable .. so every C++ variable is actually implicitly (potentially) referring to a location
07:28:34 <nopcode> so... how do i test if an element is contained in a given list?
07:29:08 <ski> Toxaris : well, if you want to enforce by types that the recipient of a reference can read it, but not write to it, then the latter can do that, but not the former
07:29:17 <ski> @type elem
07:29:20 <lambdabot> forall a. (Eq a) => a -> [a] -> Bool
07:29:27 <ski> > 3 `elem` [0..]
07:29:29 <lambdabot>  True
07:29:34 <ski> > 3 `elem` [8..]
07:29:41 <Toxaris> ski: I
07:29:42 <lambdabot> Terminated
07:29:43 <ski> > 3 `elem` [0,2..6]
07:29:46 <lambdabot>  False
07:29:52 <Toxaris> ski: I've used your ReadRef type wrong, i think
07:30:15 <nopcode> ok thx
07:30:26 <Toxaris> I meant passing a (IO a) action that reads the ref instead of the ref
07:30:32 <nopcode> is there any consensus on when to use infix notation?
07:31:09 <ski> (btw, i defined 'ReadRef' instead of 'IOReadRef' above so that one can have 'ReadRef IORef','ReadRef (STRef s)','ReadRef TVar',etc .. mutatis mutandis for 'WriteRef')
07:31:14 <olsner> "when appropriate" :P
07:31:28 <Toxaris> as in readOnlyList :: IO [Double] -> Int; readOnlyLength p = liftM length p
07:31:45 <Toxaris> and toConst = readIORef
07:32:39 <ski> Toxaris : oh .. sorry, i misread your 'IO a' as 'IORef a' :) .. well, if you pass in a 'IO a', then that could potentially do anything when executed, while if you pass in a 'ReadRef IORef a' then that can only be used to access the current contents of one reference cell
07:33:41 <ski> itym 'readOnlyLength :: IO [Double] -> IO Int'
07:34:08 <Toxaris> yes
07:35:48 <ski> (hm .. to get equality on these restricted references (being functors by the above 'forall x. '), one must have "heterogenous" equality on the underlying reference type)
07:36:25 <ski> or ..
07:36:44 <ski> no, that is not enough
07:37:49 <ski> 'RR (*2) a_Ref_to_Double' oughtn't be the same as 'RR (/2) a_Ref_to_Double'
07:38:04 <ski> since we want
07:38:43 <ski> forall ref0,ref1.  ref0 == ref1  ==>  readRef ref0 = readRef ref1
07:39:24 <nopcode> how do i perform integer division?
07:39:57 <LoganCapaldo> > 3 `div` 2
07:39:59 <ski> (Toxaris : did you understand my objection ?)
07:40:05 <lambdabot>  1
07:40:14 <LoganCapaldo> > 3 `quot` 2
07:40:16 <lambdabot>  1
07:40:18 <ski> :)
07:40:21 <kpreid> ski: Eq constraint on the reference type?
07:40:30 <LoganCapaldo> > (-3) `div` 2
07:40:32 <lambdabot>  -2
07:40:37 <ski> kpreid : yes ?
07:40:39 <LoganCapaldo> > (-3) `quot` 2
07:40:42 <lambdabot>  -1
07:40:48 <kpreid> ski: ...oh
07:40:54 <kpreid> right. still doesn't match
07:40:58 <ski> > 3 `div` (-2)
07:41:01 <lambdabot>  -2
07:41:02 <ski> > 3 `quot` (-2)
07:41:04 <kpreid> Eq and Typeable would be sufficient though :)
07:41:04 <lambdabot>  -1
07:41:37 <ski> also .. 'div','mod' is to 'divMod' as 'quot','rem' is to 'quotRem'
07:41:56 <ski> kpreid : no .. you'd need equality on functions
07:42:08 <kpreid> no, j...oh. foo.
07:42:41 <kpreid> okay, discard the function argument and use a type class
07:42:46 <ski> (i.e. 'heterEqRef :: forall a b. IORef a -> IORef b -> Equal a b' doesn't suffice)
07:43:26 <ski> kpreid : but then we lose 'Functor IOReadRef' :(
07:43:34 <LoganCapaldo> whats so hard about equality on functions? :)
07:43:44 * LoganCapaldo is joking
07:43:54 <ski> LoganCapaldo : only that it is undecidable :)
07:44:16 <Codex_> logan: you can always compare the function name only? :)
07:45:19 <ski> assertEqualAddress :: Computation a -> Computation a -> Conservative ()
07:45:31 <hkBst> what is the correct way of doing : data Comment = Comment String | Comment L ; data L = Comment | Symbol String | List [L]
07:45:36 <kpreid> instance ReadRef IORef a where read r = readIORef r; data AnyReadRef a = forall r. ReadRef r a => AnyReadRef r; instance ReadRef AnyReadRef a where read (AnyReadRef r) = read r
07:45:37 <LoganCapaldo> f == g = @check (\x -> f x == g x) == OK 500 :)
07:45:56 <kpreid> hkBst: the first definition has two constructors with the same name; fix that
07:46:14 <ski> runConservative :: Conservative a -> NonDet (Maybe a)
07:46:31 <ski> choose :: NonDet a -> IO a
07:46:56 <LoganCapaldo> and L can;t have a constructor named Comment
07:47:06 <LoganCapaldo> if Comment has a constructor named Comment
07:47:15 <ski> ('Conservative' is meant to be like 'Maybe', except that it is always valid to fail instead of returning a value)
07:47:58 <ski> (i forgot 'unsafePeekComputation :: a -> Computation a')
07:48:49 <hkBst> kpreid: isn't it possible to overload it?
07:49:01 <kpreid> hkBst: no
07:49:05 <Toxaris> ski: your objection about my (IO a) idea? yes, I do. It's to mighty.
07:49:06 <ski> LoganCapaldo : it could be done in O'Haskell .. in some sense
07:49:15 <LoganCapaldo> hkBst: not like that
07:49:16 <kpreid> hkBst: it would make type inference ...difficult
07:49:19 <ski> (Toxaris : ok)
07:49:28 <kpreid> actually, no
07:49:32 <kpreid> it's no worse than type classes
07:49:33 <LoganCapaldo> you could have comment :: (Commentable a) => a -> Comment
07:49:47 <LoganCapaldo> and make String and L instances of Commentable
07:50:05 <ski> (LoganCapaldo : forget what i said, i missed you had 'Comment' in two places in 'data Comment')
07:50:45 <ski> only one can't match on 'comment x' ..
07:52:06 <kpreid> hkBst: Even if you could do that, you wouldn't want to because it would make case expressions on that type confusing
07:52:30 <LoganCapaldo> ski: yep
07:52:55 <kpreid> case x of Comment s -> ...; Comment l -> ... -- oh look, these are non-overlapping, but only if the types of the ...s are different!
07:53:31 <LoganCapaldo> I think most of these questions would answer themselves if people stopped worrying so much about how much of a pain it is to get values in, and started worrying more about how much of a pain it is to get value _out_
07:53:43 <ski> kpreid : how to decide that at run-time ?
07:54:00 <kpreid> ski: it would be decided at compile time
07:54:10 <kpreid> just like typeclass resolution
07:54:35 <LoganCapaldo> it could only be decided at compile time (w/o annotations) if s and l appeared in the bodies of the ...
07:54:44 <kpreid> yup!
07:55:02 <LoganCapaldo> and event that it wouldn't necessarily be decideable
07:55:18 <LoganCapaldo> Comment l -> Just (Comment l) ; Comment s -> Just (Comment s)
07:55:25 <kpreid> much like 'show . read'
07:55:42 <nopcode>     No instance for (Eq Cell)
07:55:43 <nopcode>       arising from use of `==' at <interactive>:1:0-26
07:55:43 <nopcode> hm
07:55:45 <LoganCapaldo> constructors with dictionaries...
07:55:55 <nopcode> i was trying (rows !! y !! x) == Empty
07:56:07 <LoganCapaldo> nopcode: tack a deriving (Eq) on the end of your data declaration
07:56:16 <ski>   data Foo a b = F a Int | F Bool b
07:56:17 <ski>   foo (F a 0) = Left a; foo (F False b) = Right b
07:56:23 <ski> what is type of 'foo' ?
07:56:24 <LoganCapaldo> data Cell = Empty | One Int deriving (Eq)
07:56:33 <nopcode> ok thx
07:56:36 <kpreid> nopcode: or write it as 'case rows !! y !! x of Empty -> ...; One _ -> ...
07:56:55 <kpreid> nopcode: that's better if you're really using it to make a decision and not just getting the boolean value
07:57:04 <kpreid> or if you want to use the number in it if it's One
07:57:10 <kpreid> which is probably the case
07:59:44 <hkBst> how does one specify a Parsec parser that parses one character which is not equal to its argument?
07:59:46 <ski>   foo :: Different a b => Foo a b -> Either a b
07:59:46 <ski> ?
08:00:06 <LoganCapaldo> hkBst: noneOf "c"
08:00:35 <hkBst> heh, I was using notOf... :)
08:00:39 <LoganCapaldo> (will match any char _but_ 'c')
08:00:57 <kpreid> I wonder why noneOf is specialized to Char
08:01:09 <LoganCapaldo> Is it?
08:01:15 <LoganCapaldo> @hoogle noneOf
08:01:16 <lambdabot> Text.ParserCombinators.Parsec.Char.noneOf :: [Char] -> CharParser st Char
08:01:19 <LoganCapaldo> so it is
08:01:34 <Toxaris> kpreid: because parsec is not restricted to (Eq token)
08:01:51 <kpreid> so, noneOf :: Eq token => [token] -> ...
08:02:04 <Toxaris> yup sounds sensible :-)
08:02:06 <LoganCapaldo> @hoogle satisfy
08:02:06 <lambdabot> Text.ParserCombinators.ReadP.satisfy :: (Char -> Bool) -> ReadP Char
08:02:06 <lambdabot> Text.ParserCombinators.Parsec.Char.satisfy :: (Char -> Bool) -> CharParser st Char
08:02:12 <LoganCapaldo> ack!
08:02:26 <LoganCapaldo> why would _satisfy_ be specialized to CHar!?!?!
08:02:41 <kpreid> "because it's in Parsec.Char"
08:02:49 <LoganCapaldo> oh
08:02:52 <LoganCapaldo> doh
08:03:29 <ski> @hoogle notFollowedBy
08:03:29 <lambdabot> Text.ParserCombinators.Parsec.Combinator.notFollowedBy :: Show tok => GenParser tok st tok -> GenParser tok st ()
08:03:31 <LoganCapaldo> don't mind me
08:03:51 <kpreid> LoganCapaldo: and here I thought that was a silly answer
08:04:05 <kpreid> "well, why isn't it in Parsec.Combinator?"
08:04:12 <LoganCapaldo> touche
08:04:35 <sorear> hello.
08:06:00 <LoganCapaldo> hello
08:13:34 <ntome> hi
08:14:32 <sorear> hi
08:16:14 <ntome> (can I ask some noob question ?)
08:16:20 <ski> yes
08:16:58 <sorear> In fact, we prefer it if you just ask.
08:17:20 <rretzbach1> Maybe you can also sing the question!
08:17:54 <nopcode> how can i return either a result or "False"?
08:18:02 <hpaste>  hkBst pasted "parseL" at http://hpaste.org/1456
08:18:05 <ski> why do you want to return 'False' ?
08:18:18 <ski> to denote something didn't succeed ?
08:18:22 <nopcode> ski: yeah
08:18:26 <nopcode> ski: a recursive puzzle-solver
08:18:30 <ski> @type lookup
08:18:31 <sorear> nopcode: look at Maybe
08:18:33 <hkBst> could someone help me with the type errors in my paste, please?
08:18:33 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
08:18:52 <ski> > lookup 'a' [('b',4),('a',1),('c',18)]
08:18:54 <lambdabot>  Just 1
08:18:55 <ski> > lookup 'd' [('b',4),('a',1),('c',18)]
08:18:56 <hpaste>  (anonymous) annotated "parseL" with "(no title)" at http://hpaste.org/1456#a1
08:18:57 <lambdabot>  Nothing
08:19:00 <nopcode> ah right
08:19:02 <sorear> hkBst: What is the error message, and on what line?
08:19:09 <sorear> oh. :)
08:19:12 <ski> > case lookup 'a' [('b',4),('a',1),('c',18)] of Just n -> show n; Nothing -> "oops !"
08:19:16 <lambdabot>  "1"
08:19:16 <ski> > case lookup 'd' [('b',4),('a',1),('c',18)] of Just n -> show n; Nothing -> "oops !"
08:19:18 <lambdabot>  "oops !"
08:19:52 <sorear> hkBst: On the 'parens = ...' line, you need to use characters, not strings
08:19:58 <sorear> :t "a" -- a string
08:20:00 <lambdabot> [Char]
08:20:02 <sorear> :t 'a' -- a string
08:20:05 <lambdabot> Char
08:20:06 * ski notices ntome is in fact not nopcode
08:20:12 <sorear> :t 'a' -- oops, sorry, a character
08:20:14 <lambdabot> Char
08:20:42 <ski> ntome : i assume your question is coming, then ?
08:20:45 <ntome> ok, here, I don't understand the error message http://hpaste.org/1457
08:21:03 <ntome> (I was waiting not to mix questions)
08:21:09 <ski> (np)
08:21:22 <ntome> (and because I'm not sure :) )
08:21:35 <hkBst> sorear: thanks, that's one down, two to go :)
08:22:01 <sorear> hkBst: For the first one, the problem is that comment returns a token but whiteSpace doesn't.
08:22:53 <sorear> hkBst: You could add 'return ()' to both definitions, but then you wouldn't preseve comments
08:23:32 <nopcode> how do i get a list with the n-th element replaced by a given one?
08:23:34 <fasta> Why is this illegal? class F a where b::(Z a l) => l -> Bool
08:23:44 <sorear> fasta: Because it is.
08:23:52 <sorear> fasta: There really isn't a better reason
08:24:05 <sorear> fasta: one of the GHC extensions relaxes it (I forget which)
08:25:10 <fasta> It seems that the dynamic hippies are right. If you use a static typing system too long you find limitations.
08:25:28 <hpaste>  ski annotated "(no title)" with "you want floating-point numbers" at http://hpaste.org/1457#a1
08:25:45 <sorear> hkBst: As for the remaining error, you have a combinator mixup in lines; you want >> because char '\n' does *not* take an argument.
08:25:56 <sorear> hkBst: I've just addrssed all three errors ^^^
08:26:17 <SamB> fasta: hmm? and can dynamic languages overload an operation based on the result type?
08:26:20 <kpreid> nopcode: replace 0 y (_:xs) = y:xs; replace i y (x:xs) = x : replace (pred i) y xs
08:26:31 <ski> ntome : ok ?
08:26:39 <ntome> readin' :)
08:26:59 <sorear> SamB: why are you feeding the troll? :)
08:27:06 <ski> @type \side -> round (fromIntegral side * (cos (pi / 3)))
08:27:09 <hkBst> sorear: so you have :) But how can I would really like "line" and "comment" to return the stuff they consumed...
08:27:09 <lambdabot> forall a b. (Integral a, Integral b) => a -> b
08:27:10 <fasta> SamB: Right, dynamic language is the wrong word. The perfect language kiddies, which is none, indeed.
08:27:17 <SamB> sorear: I think he meant that honestly!
08:27:29 <SamB> fasta: ah.
08:27:46 <rretzbach1> make love, not war
08:27:51 <hkBst> s_how can_ _
08:28:18 <sorear> hkBst: In that case, you could probably ... *types*
08:29:31 <fasta> sorear: amazing that you recognized that situation within the blink of an eye
08:29:55 <Philippa> sorear: it's not unreasonable to point out that all static type systems have limitations, and that currently if you want to be able to express /anything/ it comes at the cost of a lot of discomfort
08:30:28 <fasta> Philippa: do you know the extension sorear hinted at?
08:30:32 <sorear> Philippa: the phrasing seemed to say more...
08:30:41 <fasta> I can't find it in the manual.
08:30:51 <ski> nopcode : i found '(0,x:xs) `modify` f = f x : xs; (i,x:xs) `modify` f = x : ((pred i,xs) `modify` f)' useful
08:30:56 <fasta> 7.4. Type system extensions
08:31:56 <ski> nopcode : in case you're wondering, one can use that to change things in nested lists in a nice way
08:32:02 <hpaste>  sorear annotated "parseL" with "fixed?" at http://hpaste.org/1456#a2
08:33:32 <sorear> hkBst: ^^
08:33:52 <ntome> ski: thanks :) , trying to understand
08:34:40 <ski> > let (0,x:xs) `modify` f = f x : xs; (i,x:xs) `modify` f = x : ((pred i,xs) `modify` f); xss = [[0,1,2,3],[4,5,6],[7,8],[9]] in  (1,xss) `modify` \xs -> (2,xs) `modify` \x -> x*x
08:34:43 <lambdabot>  [[0,1,2,3],[4,5,36],[7,8],[9]]
08:35:14 <ski> the latter part can be indented as
08:35:20 <ski>   (1,xss) `modify` \xs ->
08:35:25 <ski>   (2,xs) `modify` \x ->
08:35:26 <ski>   x*x
08:36:44 <fasta> Is there a flag that enables all extensions in GHC?
08:36:53 <ski> so this reads as : "start modifying the 1st element of 'xss', call the current value in that position 'xs', then modify the 2nd element of 'xs', call the current value there 'x', then then final modification is to square 'x'"
08:37:32 <hkBst> sorear: hmm, *> is nice, what is the purpose of <fmap WhiteSpace> in <whiteSpace = fmap WhiteSpace $ oneOf " \t\n"> ?
08:37:33 <nopcode> uhm
08:37:48 <ski> the point being that one doesn't have to use '(!!)' *as*well*as* 'replace' on the outer list 'xss' .. also it reads nicely :)
08:37:58 <sorear> hkBst: To turn '\t' into WhiteSpace '\t'
08:38:03 <nopcode> ski: does it ;)
08:38:23 <sorear> hkBst: Which is an error in my correction; is should be data ... = WhiteSpace *Char* | ...
08:38:38 <sorear> @src Maybe fmap
08:38:38 <lambdabot> fmap _ Nothing       = Nothing
08:38:38 <lambdabot> fmap f (Just a)      = Just (f a)
08:38:45 <sorear> representative example ^^
08:38:49 <ski> (hm, actually, it might be a little nicer to do '(xs,i)' instead of '(i,xs)' .. i.e. same order as in 'xs !! i')
08:40:25 <fasta> sorear: I am fairly sure that ghc 6.6.1 does not support it, since I enables every language option.
08:40:40 <fasta> (4.17.12. Language options)
08:40:48 <fasta> enabled*
08:41:04 <sorear> fasta: Actually ... what's the definition of Z?
08:41:14 <fasta> class Z a l | a -> l
08:41:17 <ski> (nopcode : note, one can modify other nested structures as well .. such as lists of pairs or lists, etc .. one'd need a modifier function for pairs as well, then (or inline it))
08:41:48 <sorear> fasta: The fundep needs to go the other way for the above to be legal.
08:42:14 <hkBst> sorear: parsers combined with <|> have to have results of the same type?
08:42:21 <sorear> hkBst: Yes.
08:42:43 <fasta> sorear: then GHC still doesn't accept it
08:43:01 <fasta> sorear: and AFAIK, it wouldn't fit the intended semantics anymore.
08:44:04 <fasta> class Z a l | a -> l; class F a where z::(Z a l) => l -> Bool
08:45:13 <sorear> fasta: that's definitely illegal, since it would be ambiguous
08:45:59 <sorear> fasta: a does not appear in the signature of z and is not fixed by a fundep, so there would be no way to figure out what instance to use for the Z constraint in a use of z
08:46:05 <fasta> sorear: why? A is given in F. Fill in a in Z a l. Find class Z. Fill in a in z. That fixes l, because of the fundep. So, l is known.
08:46:39 <ski> you start from 'z' and the type 'l', and want to find 'a' to find the correct instance
08:46:45 <ski> but you can't
08:46:57 <sorear> my bad
08:47:15 <ski> ?
08:49:11 <hkBst> sorear: with your definition of (*>), "line" tries to consume '\n' first, right? Did you switch 'a' and 'b' in *> definition?
08:49:52 <ski> (s/instance/two instances .. 'F a' respectively 'Z a l' .. the correct 'z', and the correct instance dict to pass to it/)
08:49:53 <fasta> ski: ok, I see, so I would either need a phantom parameter or just make a new class.
08:50:10 <sorear> hkBst: Yup
08:50:14 <sorear> hkBst: Error
08:51:43 <ski> fasta : (i haven't been following, but) i don't see how you mean ..
08:52:21 <sorear> @seen ndm
08:52:21 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 22h 56m 35s ago, and .
08:52:59 <fasta> ski: doesn't matter, never mind. I solved it already
08:53:19 <fasta> ski: unless you are curious ;)
08:54:19 * ski is curious (although tired)
08:56:34 <fasta> ski: class Z a l | a -> l; class F a where z::(Z a l) => l ->  Bool => class F a where z::(Z a l) => a -> Bool (I realized that this was correct) (this makes it a "normal" class declaration.
08:57:47 <fasta> Ok, the context is now redundant, though.
08:58:10 <fasta> Although, semantically it should be there.
09:00:39 <ski> well, if you happen to have any 'a' lying around and 'F a' holds, but there is no 'l' for 'Z a l' to hold, it could matter
09:01:01 <ski> ("is no" as opposed to "i haven't seen any")
09:01:24 <hkBst> @karma+ sorear
09:01:24 <lambdabot> sorear's karma raised to 44.
09:01:48 <nopcode> how can i trace evaluation?
09:01:58 <ski> @index trace
09:01:58 <lambdabot> Debug.Trace
09:01:59 <nopcode> i'm getting an exeception (!!: index too large) and i dont know where it happens
09:02:14 <nopcode> how do i use that?
09:02:32 <fasta> ski: yes, but an F without a Z is meaningless as a whole.
09:02:47 <ski> @type Debug.Trace.trace
09:02:49 <lambdabot> forall a. String -> a -> a
09:03:01 <ski> fasta : if you say so
09:03:30 <ski> > 1 + (Debug.Trace.trace "foo" 2)
09:03:32 <lambdabot>   Not in scope: `Debug.Trace.trace'
09:03:42 <ski> lambdabot won't let me try that :)
09:04:06 <ski> anyway, if 'trace "foo" x' is evaluated, then "foo" is printed
09:04:13 <nopcode> i dont get it
09:04:14 <nopcode> ah
09:04:16 <nopcode> its a printf?
09:04:25 <nopcode> i was thinking about a function call trace
09:04:26 <ski> it is a debugging usility
09:04:27 <hpaste>  N1hyipcom pasted "N1hyipcom" at http://hpaste.org/1458
09:05:17 <mux> @src nubBy
09:05:17 <lambdabot> nubBy eq []             =  []
09:05:17 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
09:05:28 <ski> getting a call trace is not as useful (or at least harder to understand) in non-strict languages like haskell than strict languages, i think
09:05:53 <nopcode> ski: well i want to know atleast where the !! operator is called
09:05:54 <ski> however there's some more advanced debugging utilities, like 'hat'
09:05:58 <ski> @where hat
09:05:58 <lambdabot> http://www.haskell.org/hat/
09:06:05 <ski> (which i haven't tried)
09:06:10 <nopcode> i'm getting an index out of range exception
09:06:16 <nopcode> and i want to know at what line.
09:07:15 <ski> sorry, i don't know how to do such
09:07:26 <ski> (mayhaps ndm could help more, if he's awake)
09:07:59 <ski> (you *could* replace every call of '(!!)' by an instrumented variant, i guess)
09:08:05 <cinema> dons, are you aware of the problem compiling hs-plugins with Fedora 7 ?
09:08:24 <mux> @djinn (b -> b -> c) -> (a -> b) -> a -> a -> c
09:08:25 <lambdabot> f a b c _ = a (b c) (b c)
09:08:27 <ski> @seen ndm
09:08:27 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 23h 12m 41s ago, and .
09:08:31 <nopcode> ski: how do i put multiple statements in a function?
09:08:43 <nopcode> ah nevermind
09:09:00 <greenrd> I'm having a problem with left-factoring and precedence in my Frisby parser
09:09:12 <ski> nopcode : you don't put statements in a function .. mayhaps you're thinking of several defining equations ?, or local definitions
09:09:14 <sek> @src return
09:09:14 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:09:17 <ski> one could do stuff like
09:09:23 <mux> @src [] return
09:09:23 <lambdabot> return x    = [x]
09:09:27 <nopcode> ski: the trace..
09:09:35 <mux> @src Maybe return
09:09:35 <lambdabot> return              = Just
09:09:41 <sek> oh ofcourse, thanks
09:10:14 <greenrd> basically, I have left-factored a parse rule that had immediate left recursion, but now the precedence is messed up
09:10:27 <ski>   foo x y = ("in 'foo' : " ++ show x ++ " " ++ show y)
09:10:28 <ski>     `trace` ..the.actual.body..
09:10:38 <greenrd> "f a -> f" is being parsed like "f (a -> f)"
09:10:39 <ski> (not sure if the parens are actually needed)
09:10:56 <ski> nopcode : does that help ?
09:11:20 <greenrd> this is probably because in the "tail" of my left-factoring, I am using foldr to combine partial function applications
09:11:34 <greenrd> but I'm a bit confused at this point and unsure how to fix it
09:11:56 <greenrd> normally with Frisby, if you want to make one alternative take priority, you just move it higher
09:12:07 <greenrd> but in this case that doesn't make any difference
09:12:17 <nopcode> ski: it's strange %)
09:12:21 <nopcode> i'll try without trace
09:13:46 <greenrd> because the minimal non-terminal is always matched first
09:13:49 <greenrd> due to the left-factoring
09:13:59 <nopcode> ok i found the problem
09:14:37 <ski> my_index text xs i = if i < 0 || i >= length xs then error text else xs !! i
09:14:58 <fasta> nopcode: There are easier to ways to find the location of a bug.
09:15:16 <ski> (then replacing 'xs !! i' by 'my_index "i'm in function foo" xs i')
09:15:17 <fasta> nopcode: compile it such that you get a stack trace
09:15:20 <greenrd> hmm, maybe I should return a pair (PrecedencePriority, f) instead of just f
09:15:42 <fasta> nopcode: with the stack trace you see all the functions it went through before it crashed and burned.
09:16:00 <fasta> nopcode: assuming every function only has 1 (!!) call, you found it then.
09:16:10 * ski didn't know ghc(?) did that :O
09:16:15 <fasta> nopcode: much easier than what ski is suggesting.
09:16:20 <greenrd> I can't really visualise my problem, let alone a solution
09:16:52 <fasta> greenrd: then you shouldn't be sitting behind a computer, grab some paper and think about the problem.
09:16:57 <greenrd> heh
09:17:03 <greenrd> interesting idea!
09:17:15 <greenrd> I never figure out my programming problems with pen and paper - maybe I should
09:17:16 * ski thinks greenrd's problem could be expressed with delimited continuations somehow .. but is too tired to think about it
09:17:44 <ski> (i.e. the general problem of parsing operators with precedence and associativity)
09:17:48 <greenrd> continuations!
09:17:52 * greenrd runs away screaming
09:17:55 <greenrd> ;)
09:20:38 <greenrd> maybe I could just sort the list of functions in order of precedence and throw an exception if there are any with equal precedence
09:20:48 <greenrd> no, that's not right
09:21:18 <greenrd> foo . bar $ goo . noo is valid, even though there are two operators with equal precedence in there
09:21:44 <greenrd> as indeed is foo . bar . goo for that matter
09:21:54 <int-e> there are also left and right associative operators
09:21:58 <greenrd> yes
09:22:04 <greenrd> I was hoping to avoid that ;)
09:22:25 <int-e> > 1 == 1 == 1 -- and non-associative ones
09:22:25 <greenrd> this should really be built into something reusable for frisby... once I figure it out
09:22:27 <nopcode> data Sudoko = None | [[Int]]
09:22:29 <nopcode> why doesnt this work?
09:22:32 <lambdabot>      precedence parsing error
09:22:32 <lambdabot>         cannot mix `(==)' [infix 4] and `(==)' ...
09:22:55 <int-e> nopcode: you need a constructor for the second alternative
09:23:24 <nopcode> int-e: i suppose i can't call that one Sudoku as well? ;)
09:23:25 <int-e> nopcode: data Sudoku = None | Some [[Int]] will work.
09:23:49 <int-e> nopcode: you can also call it Sudoku, yes
09:23:52 <greenrd> nopcode: You might also want to try type Sudoku = Maybe [[Int]]
09:24:05 <int-e> nopcode: that being said, is [[Int]] or Maybe [[Int]] good enough for you?
09:24:39 <int-e> (for [[Int]] you could use [] as an empty board. but that's probably ugly :)
09:24:47 <nopcode> hmm
09:24:53 <nopcode> i need both empty boards and empty cells
09:25:11 <oerjan> Maybe [[Maybe Int]]
09:25:12 <mux> [[Maybe Int]]
09:25:20 <nopcode> =))
09:25:20 <mux> [] being the empty board
09:25:31 <nopcode> mhm
09:25:50 <int-e> 0 being an empty cell. choices, choices. clear code or simple types? :)
09:26:10 <mux> :)
09:26:47 <oerjan> is an empty board any different from a board with all empty cells?
09:26:47 <greenrd> Cale - I need to implement precedence and associativity for operator parsing in my Frisby parser - with left-factoring - any clues to get me started?
09:27:10 <greenrd> I've done the left-factoring and now I can't figure out how to do precedence (let alone left-associativity, right-associativity)
09:27:39 <nopcode> oerjan: yeah
09:29:12 <oerjan> ok
09:29:52 <hkBst> @src space
09:29:52 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:30:03 <oerjan> @src isSpace
09:30:04 <lambdabot> Source not found. Take a stress pill and think things over.
09:30:30 <oerjan> #"%&!
09:30:38 <hkBst> @hoogle space
09:30:39 <lambdabot> Text.PrettyPrint.HughesPJ.space :: Doc
09:30:39 <lambdabot> Text.ParserCombinators.Parsec.Char.space :: CharParser st Char
09:30:39 <lambdabot> Text.Html.spaceHtml :: Html
09:30:52 <hkBst> @src Text.ParserCombinators.Parsec.Char.space
09:30:53 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:31:06 <oerjan> oh i know there is an isSpace, it's just that lambdabot won't show the source
09:31:33 <hkBst> ok :( too bad
09:32:08 <Cale> greenrd: I think the basic idea is to ensure that lower-precedence operators are parsed higher up in the tree -- so there should be a rule for parsing a chain of things combined by low-precedence operators, where the things themselves are chains combined with higher-precedence operators
09:32:39 <Cale> I don't know anything about Frisby myself though.
09:32:49 <oerjan> @src seems to be all about lambdabot throwing stones from glass houses
09:32:50 <lambdabot> Source not found. Wrong!  You cheating scum!
09:33:33 <int-e> @source GHC.Unicode
09:33:33 <lambdabot> GHC.Unicode not available
09:37:02 <hkBst> ok, `space' seems to be `oneOf " \v\f\t\r\n"', but how would one go from `space' to `noneOf " \v\f\t\r\n"'?
09:37:48 <sphynx> Does anybody use ICQ here?
09:38:08 <nominolo> why?
09:38:18 <oerjan> (space >> fail) <|> anyChar, perhaps
09:38:30 <oerjan> (not quite fail)
09:38:32 <sphynx> I'm writing some tool for analyzing ICQ history files in Haskell, so I am interested what log file formats should I support :)
09:38:58 <oerjan> er, a try around that
09:39:03 <nominolo> i use adiumx
09:39:10 <sphynx> Now I support only centericq client, which I use
09:39:23 <nominolo> i think it's simple <nick>: <text>
09:39:49 <oerjan> try (space >> fail "something" <|> anyChar)
09:39:53 <sphynx> nominolo: adiumx? Interesting I've never heard abt this client )
09:40:08 <fasta> ski: any idea what "postfixing the dynamic scope of a routine" is?
09:40:13 <nominolo> it's a mac-frontend to the gaim/purple lib
09:41:00 <sphynx> ahhh, it's for mac os x, I undestand.
09:41:34 <sphynx> nominolo: gaim history format is a bit hard to parse..
09:41:47 <greenrd> Cale: Thanks - I'll think about that
09:41:55 <oerjan> try ((space >> fail "something") <|> anyChar)
09:42:15 <sphynx> nominolo: I have a friend which use Pidgin (former Gaim), he is interested in program, but I need almost completely rewrite it to support Gaim
09:42:30 <oerjan> that ought to work, haven't tested
09:44:08 <fasta> sphynx: what is there to analyze about such files? Unless you work for the NSA, that is...
09:44:20 <nominolo> it's xml here
09:44:44 <nominolo> and it seems they've also changed the format at one point
09:45:52 <nominolo> it's <chat ...><event ...><message ..>html-formatted text</ ...>
09:46:07 <hkBst> oerjan: the "try" is not part of the code, right?
09:46:29 <oerjan> hkBst: yes it is
09:47:07 <oerjan> if you want to backtrack further if there was a space, you need it
09:47:23 <fasta> You can make an OMG LOL ROLF-index for all your friends and post it to your blog for people to laugh at, but I don't think you can do that two times.
09:47:23 <sphynx> fasta: I'm interested in many facts - who is most talkful person, what word is used many times, with whom I said given word mostly, etc.
09:47:38 <fasta> ROFL*
09:47:50 <sphynx> fasta: There can be many typs of statistics )
09:48:41 <ski> (fasta : i am asleep)
09:48:44 <sphynx> fasta: here is example
09:49:30 <fasta> ski: please continue this subject when you feel like it
09:49:35 <hpaste>  sphynx pasted "Allknow usage" at http://hpaste.org/1459
09:49:54 <sphynx> ^^
09:50:06 <oerjan> hkBst: anyway noneOf should be more efficient
09:50:10 <ski> (fasta : dynamic scope sounds like the environment, aka "reader", monad .. what "postfix" can mean in this context i can only imagine)
09:50:22 <sphynx> nominolo: Is there some fast XML parser in Haskell?
09:50:45 <sphynx> nominolo: which can cope with ~5 megabytes files?
09:50:53 <littledan> HaXML?
09:51:37 <nominolo> there are many.  haven't used any though.  so dunno
09:51:41 <sphynx> littledan: Is it fast enough?
09:52:37 <littledan> not sure. It makes sure to do all the parsing lazily, though
09:52:43 <sphynx> It should parse ~5-10 megabytes in <3 seconds to be usable in my case...
09:52:54 <hkBst> oerjan: `notSpace' should be defined along with `space', IMHO
09:53:42 <sphynx> fasta: have you impressed with possibilities of allknow? ;)
09:53:52 <littledan> sphynx, why not benchmark it?
09:54:42 <fasta> sphynx: no, but then again, I am not impressed easily.
09:55:08 <fasta> sphynx: it's certainly nicer than fib :)
09:55:35 <sphynx> littledan: yeah, I will try to do this )
09:56:01 <nominolo> sphynx: you might be able to use some approximation, since you probably want to strip out all the tags anyways
09:56:16 <oerjan> well, space               = satisfy (isSpace)     <?> "space"
09:56:17 <sphynx> fasta: yeah :) I will add some cool search features and maybe morphology later )
09:56:48 <oerjan> so you would want notSpace = satisfy (not . isSpace) <?> "nonspace"
09:56:57 <sphynx> nominolo: Yeah, I need only text of messages, direction and time
09:57:27 <oerjan> i guess it is much more rarely needed.
09:58:26 <nominolo> so you can try s/<[^>]>//
09:59:51 <nominolo> er s/<[^>]*>//
10:03:44 <cdsmith> What;s the best way to write image files from Haskell?
10:04:52 <nominolo> pango can do png at least
10:05:05 <cdsmith> @where pango
10:05:05 <lambdabot> I know nothing about pango.
10:05:23 <oerjan> @hackage pango
10:05:23 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pango
10:05:40 <cdsmith> 404
10:06:01 <dmhouse> Yay, my haskell-mode patch got installed.
10:06:25 <cdsmith> Pango's part of GTK?  Would I use Gtk2Hs?
10:06:33 <dmhouse> (It adds an inferior-haskell-find-haddock to inf-haskell.el so that you can look up haddocks for the identifier at point with C-c C-d.)
10:06:46 <cdsmith> dmhouse: congrats
10:06:57 <oerjan> @hackage sillyname
10:06:57 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/sillyname
10:07:03 <oerjan> bah
10:07:04 <cdsmith> oh
10:07:30 * cdsmith is suddenly tempted to write a haskell library called sillyname
10:07:52 <nominolo> wait. sorry, i meant cairo
10:08:06 <cdsmith> nominolo: ok, cool
10:08:11 <nominolo> but that's part of gtk2hs, too
10:08:59 <nominolo> i don't think it's strictly necessary, but atm it is
10:09:00 <cdsmith> nominolo: hmm, so I'd need GTK installed on my web server?
10:09:21 <nominolo> i'm afraid so
10:09:32 <cdsmith> I suppose I could do that.
10:10:33 <nominolo> i have to manually upgrade to xorg 7.7 just to get ghc on my freebsd server
10:10:33 <cdsmith> If I wrote a simple Haskell wrapper for libpng, would this be useful for others?  Or should I just do it the messy way?
10:10:45 <nominolo> er xorg 7.2
10:11:37 <sjanssen> nominolo: FreeBSD still packages the extralibs with the compiler?
10:12:22 <nominolo> sjanssen: http://www.freebsd.org/cgi/ports.cgi?query=ghc&stype=all
10:12:23 <lambdabot> Title: FreeBSD Ports Search
10:13:00 <nominolo> lots and lots of dependencies
10:13:20 <sjanssen> nominolo: yeah, it seems that FreeBSD still packages the X11 package with GHC
10:13:41 <sjanssen> nominolo: the packager really shouldn't be doing that with GHC >= 6.6
10:14:19 <nominolo> no it's pretty bad if you just want to compile darcs for your server ;)
10:14:43 <nominolo> haven't looked for binaries, yet
10:23:19 <sorear> re.
10:23:35 <sorear> @flush
10:23:37 <sorear> @seen ndm
10:23:37 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 1d 27m 51s ago, and .
10:23:44 <nominolo> @localtime sorear
10:23:45 <lambdabot> Local time for sorear is Sat Jun 30 10:22:22 2007
10:23:53 <hughperkins> Hi, trying to use fromConstrM  Its not really easy :-/  Anyone know how to use it?
10:24:13 <nominolo> good morning
10:24:20 <jre2> cdsmith: libpng might be useful, how hard would it be to do it cleanly?
10:24:50 <cdsmith> jre2: I don't know, but I could look into it.
10:25:24 <bos31337> why would it necessarily be hard? it's just a C library with a reasonably sane API.
10:26:00 <hughperkins> everything is easy when it is someone else doing the implementing ;-)
10:26:07 <cdsmith> I don't see why it would be hard either... and I should learn the FFI.  I'll make that my task today.
10:26:32 <bos31337> cdsmith: your best bet is to use hsc2hs, rather than the plain FFI
10:26:43 <bos31337> you'll still be using the FFI, it just makes the job less onerous
10:26:47 <cdsmith> Okay, cool.
10:27:10 <bos31337> it eases the job of stuffing values into C structs, and getting them back out, etc.
10:27:49 <nominolo> yeah, it's pretty neat
10:28:03 <cdsmith> I'll have a lot to figure out.  I used libpng once, about 10 years ago.  I'm sure it's changed since then, too.
10:28:07 <nominolo> take a look at gtk2hs for example uses
10:28:20 <nominolo> but the docs are okay, too
10:30:36 <hughperkins> Does anyone happen to know how to write a function of type :: Data a => String -> a that works for all a, but is easily customizeable for different data types?
10:31:00 <sorear> Yes.
10:31:05 <hughperkins> Cool :-)
10:31:10 <hughperkins> How?
10:31:17 <sorear> That is *exactly* the motivating problem of:
10:31:25 <sorear> @google Scrap your boilerplate with class
10:31:28 <lambdabot> http://www.cs.vu.nl/boilerplate/
10:31:28 <lambdabot> Title: Scrap your boilerplate ... in Haskell
10:31:33 <hughperkins> Yes, which I just finished reading :-)
10:31:41 <hughperkins> Whats the paste url again pls?
10:31:44 <sorear> hughperkins: Even the WithClass?
10:31:46 <sorear> @paste
10:31:46 <lambdabot> Haskell pastebin: http://hpaste.org/new
10:32:20 <hpaste>  (anonymous) pasted "SYB3 parsestring" at http://hpaste.org/1460
10:32:35 <hughperkins> So, here's my attempt to do this in SYB3: http://hpaste.org/1460
10:32:48 <hughperkins> It works for everything declared as "instance" of StringParser
10:33:07 <hughperkins> and logically it really ought to work for anything that is an instance of Data too
10:33:23 <hughperkins> but... it doesnt... it needs an instance declaration for every data type
10:33:43 <Igloo> You need an instance Data a => StringParser a
10:33:47 <hughperkins> which means it doesnt seem to work inside fromConstrM for example, which only enforces (Data a)
10:34:46 <hughperkins> Igloo, that gives me an error that I'm using class "Data" as a type?
10:35:27 <Igloo> hughperkins: Can you paste your code?
10:35:48 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1461
10:35:57 <hughperkins> http://hpaste.org/1461
10:36:09 <Igloo> You need an "instance Data a => StringParser a"
10:36:42 <hughperkins> Oooo
10:36:44 <hughperkins> trying...
10:37:21 <hughperkins> "Constraint is no smaller than the instance head"
10:37:49 <Igloo> You need -fglasgow-exts -fallow-overlapping-instances -fallow-undecidable-instances
10:37:52 <hughperkins> hmmm, it says "use -fallow-undecidable-instances to permit this".  Is that a standard option I should acitavte?
10:37:55 <hughperkins> Ok
10:39:03 * Igloo is trying to work out what the constraint in the class method actually means there
10:39:53 <hughperkins> Igloo, yeah, it would make sense that the method in the class would be applicable to all datatypes which are instances of the base class(es)?
10:40:56 <hughperkins> hmmm, getting an incoherent instances error?
10:41:08 <hughperkins> add -fallow-incoherent-instances?
10:41:50 <Igloo> You probably don't want that. I can't remember how the earlier SYB stuff is meant to work in this situation OTTOMH
10:42:20 <Igloo> Do you get that error if you comment out the String instance?
10:42:35 <hughperkins> Yes
10:43:14 <sorear> thoughtpolice++
10:43:21 <hughperkins> but... the error is not in compiling the parsestring function itself, its at the point where it is being used, inside the call to fromConstrM
10:43:42 <hughperkins> so it could be the way I'm calling it that has an issue
10:44:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/1462
10:44:54 <hughperkins> Heres the function that calls it: http://hpaste.org/1462
10:45:17 <hughperkins> fieldvalues is a list of the values, like ["somename","18"]
10:45:40 <hughperkins> templateobject is a haskell object, like say Config {login :: String, age ::Int}
10:45:57 <thoughtpolice> ? did i do something recently?
10:46:04 <thoughtpolice> i'm so confused. :(
10:46:21 <bos31337> > 2.3**3
10:46:23 <lambdabot>  12.166999999999998
10:46:27 <bos31337> > 2.3^3
10:46:29 <lambdabot>  12.166999999999996
10:46:37 <bos31337> how weird that they'd give different answers.
10:46:45 <cdsmith> thoughtpolice: sorear thinks you're so great that whatever you are doing, it's worth karma.
10:47:13 <bos31337> @src (^)
10:47:14 <lambdabot> Source not found. My pet ferret can type better than you!
10:47:18 <bos31337> grumble.
10:47:20 <thoughtpolice> oh. well that's not out of the usual. normally when i'm on the streets people walk up and give me money too.
10:47:27 <slowriot> name collisions in Haskell are confusing. At least I'm confused about how to handle them.
10:47:28 <thoughtpolice> and women frequently ask me to take pictures and kiss their babies
10:47:29 <dmhouse> ?hoogle (^)
10:47:30 <lambdabot> Did you mean: (^)
10:47:30 <lambdabot> Prelude.undefined :: a
10:47:30 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
10:47:35 <thoughtpolice> i just didn't expect it in #haskell :)
10:47:37 <sorear> thoughtpolice: You hack mkcabal
10:47:47 <dmhouse> bos31337: it's defined separately for each instance of Num, or Fractional, or whatever the class is.
10:47:53 <dmhouse> bos31337: it's a method of that class.
10:48:34 <thoughtpolice> sorear: oh that. :) i figured a gpl3 addition to mkcabal would be nice to have, and also at 3:00am it can get hard to find something to do, so I chose something to hack on.
10:48:56 <bos31337> dmhouse: sure, i know.
10:49:21 <dmhouse> bos31337: for pretty much all numeric types the definition would be built-in, I imagine.
10:50:14 <bos31337> now that's weird.  ratios don't seem to be instances of Fractional.
10:50:22 <bos31337> > (7%3)**2.0
10:50:24 <lambdabot>   add an instance declaration for (Floating (Ratio t))
10:50:24 <lambdabot>     In the expression:...
10:50:42 <bos31337> oh, (**) expects Floating., never mind.
10:50:54 <oerjan> bos31337: you want ^^
10:51:44 <slowriot> Let's say I have import a module which exports a data type with a constructor which is named identically to a constructor defined in the module I'm working in. Shouldn't I be able to say (constructor :: datatype name) to differentiate between them?
10:51:50 <hpaste>  hkBst annotated "parseL" with "Why doesn't it parse more?" at http://hpaste.org/1456#a4
10:53:39 <bos31337> oerjan: never noticed (^^) before.
10:53:39 <mauke> slowriot: no
10:53:41 <oerjan> slowriot: no, but you can qualify the constructor
10:54:37 <slowriot> oerjan: how do I do that?
10:54:53 <slowriot> oh
10:54:58 <slowriot> nevermidn
10:55:00 <slowriot> I know how
10:59:37 <helmut> could someone tell me why the parsing functions generated by frown return lists?
11:00:41 <sorear> perhaps that's the type of your toplevel action?
11:00:41 <helmut> kosmikus: maybe you?
11:01:19 <Igloo> Can anyone tell me what yhc or nhc say about "class Eq a => Foo a where foo :: Eq a => a" please?
11:01:26 <helmut> uhm. I'm sorry, but I don't know what is meant by toplevel action.
11:01:45 <sorear> helmut: Start symbol
11:01:57 <helmut> *expr {Expr};
11:02:01 <sorear> helmut: also, the credits imply swiert is much more likely to know
11:02:46 <helmut> I therefore would assume that expr :: [Token] -> Expr whereas it really is [Token] -> [Expr]
11:03:34 <helmut> looking at the generated source it looks like a monadic return, so the type might actually be inferred by my usage.
11:04:39 <oerjan> helmut: i don't know frown but maybe it returns alternatives for ambiguous parsing?
11:04:46 <zarvok> speaking of parsers, does anyone have or know where I can find the benchmarks that are linked from the Parsec tutorial?
11:04:55 <zarvok> The links are dead and the author doesn't respond to emails
11:05:06 <helmut> oerjan: at least for my grammer the parsing is not ambigous.
11:05:38 <zarvok> oerjan: glancing over the documentation, it appears the tool doesn't support ambiguous grammars
11:05:41 <helmut> oerjan: and a ambigous grammer results in shift/reduce or other conflicts.
11:05:56 <oerjan> helmut: i meant it might return lists generally to support that
11:07:05 <helmut> oerjan: hmm. ok. maybe. in fact it only returns 1-element lists (as far as I observed).
11:07:23 <hkBst> hmm, did parsec die? My mail to daan@cs.uu.nl just bounced and I notice all the "legacy" in the URLs...
11:07:39 <elux> holy shit
11:07:42 <elux> lots of people
11:08:01 <oerjan> elux: boo!
11:08:04 <zarvok> hkBst: Yeah, I found a microsoft email for him that doesn't bounce at least, but no response
11:08:19 <oerjan> @users
11:08:19 <lambdabot> Maximum users seen in #haskell: 354, currently: 316 (89.3%), active: 16 (5.1%)
11:08:28 <zarvok> hkBst: I don't think it's "dead" though, for example, one of the haskell google soc projects deals with it this year
11:10:26 <hkBst> zarvok: hmm, could I get that email address?
11:11:36 <zarvok> daan (at) microsoft.com
11:11:41 <zarvok> but I don't know if it is current
11:11:47 <zarvok> since I didn't get a response
11:12:19 <sorear> zarvok: I've sent mail to daan / microsoft  *and* gotten a response.
11:12:40 <zarvok> sorear: I'm jealous :)  I could use one!
11:13:18 <zarvok> how recently?
11:13:32 <zarvok> My suspicion was that he is no longer there, but I don't actually know
11:14:50 <sorear> oh wait, no
11:15:32 <sorear> my message was from Doitse Swierstra
11:15:57 <Cheetahfoot> is it possible to do a list comprehension defined as an infinite sequence, but then stop the list at a certain point?
11:16:37 <hkBst> sorear: tell him to update http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
11:16:37 <zarvok> Cheetahfoot: sure, use take
11:16:46 <zarvok> > take 2 [1,2,3]
11:16:48 <lambdabot>  [1,2]
11:16:51 <zarvok> works on infinite lists too
11:17:07 <Cheetahfoot> hm ...
11:17:35 <Cheetahfoot> okay ...
11:17:40 <slowriot> I want to perform an IO action if specific constructor matches and do nothing otherwise. Is there a better way to do this than using case?
11:17:40 <zarvok> or takewhile
11:17:44 <dmhouse> Cheetahfoot: if you have take n [ f x | x <- xs ], then you'll only calculate f x for the n values of xs.
11:17:48 <Cheetahfoot> takewhile ...
11:17:58 <zarvok> > takeWhile (\x -> x < 3) [1,2,3,4]
11:17:59 <lambdabot>  [1,2]
11:18:08 <Cheetahfoot> oh! that's what i want!
11:18:18 <Cheetahfoot> takewhile, yes, thank you zarvok, dmhouse
11:18:20 <dmhouse> (Due to laziness.)
11:18:52 <zarvok> Cheetahfoot: no problem.  Incidentally, these functions aren't too hard to write yourself - you might want to think about how you could do it
11:19:33 <allbery_b> slowriot: case, or top level functions which amount to the same thing
11:19:49 <slowriot> allbery_b: okay, thanks
11:20:15 <Cheetahfoot> good idea, zarvok.
11:22:21 <allbery_b> suppose one could also come up with a monad transformer-ish way of doing it, but that seems like too much work
11:22:53 <allbery_b> (EitherT IO?)
11:24:04 <allbery_b> actualy MaybeT
11:25:44 <oerjan> > MaybeT
11:25:52 <lambdabot>   Not in scope: data constructor `MaybeT'
11:25:53 <greenrd> Sorry for the FAQ: How can I get a stack trace from a <<loop>> ?
11:26:23 <dmhouse> oerjan: it's a type constructor, like Maybe, so you can't evaluate it, it only appears in type expressions.
11:26:24 <greenrd> or how can I debug it?
11:26:53 <oerjan> @src MaybeT
11:26:53 <lambdabot> Source not found. Just what do you think you're doing Dave?
11:27:14 <oerjan> @index MaybeT
11:27:14 <lambdabot> bzzt
11:27:14 <Cheetahfoot> okay, i'm confused ... why doesn't this work then? http://hpaste.org/1463
11:27:23 <dmhouse> ?hoogle MaybeT
11:27:24 <lambdabot> Maybe.maybeToList :: Maybe a -> [a]
11:28:10 <sorear> Cheetahfoot: why are you filtering?
11:28:48 <Cheetahfoot> well, i want all even fibs below 1000000
11:28:49 <mauke> Cheetahfoot: because you're trying to use a list element that doesn't exist yet
11:28:57 <mauke> that's not what your code does :-)
11:29:08 <Cheetahfoot> so i figured i'd just generate the list and filter for even fibs
11:29:11 <oerjan> > let fib = 1 : 1 : [ (a+b) | (a,b) <- zip fib (tail fib), (mod (a+b) 2) == 0 ] in fib
11:29:14 <lambdabot>  Exception: stack overflow
11:29:29 <mauke> Cheetahfoot: your code generates the wrong list
11:29:38 <oerjan> Cheetahfoot: you must move the mod check out
11:29:42 <Cheetahfoot> ah ... it does?
11:29:59 <mauke> > let fib = 1 : 1 : [ a+b | (a,b) <- zip fib (tail fib) ] in takeWhile (< 1000000) . filter even $ fib
11:30:03 <lambdabot>  [2,8,34,144,610,2584,10946,46368,196418,832040]
11:30:07 <oerjan> > let fib = 1 : 1 : [ (a+b) | (a,b) <- zip fib (tail fib), (mod (a+b) 2) == 0 ] in take 3 fib
11:30:10 <lambdabot>  [1,1,2]
11:30:20 <oerjan> > let fib = 1 : 1 : [ (a+b) | (a,b) <- zip fib (tail fib), (mod (a+b) 2) == 0 ] in take 4 fib
11:30:23 <lambdabot>  Exception: stack overflow
11:30:42 <Cheetahfoot> why doesn't the filter work though?
11:31:04 <mauke> because 1 + 2 == 3, which is rejected
11:31:21 <mauke> it then tries 2 + <?> where <?> is the current list element
11:31:27 <Cheetahfoot> oooooooooooohhhhhhhhhhhhhhhhhhhhh ...
11:31:40 <mauke> so it loops into itself
11:31:42 <Cheetahfoot> whoa. i get it.
11:31:51 <oerjan> Cheetahfoot: because you are filtering out the odd numbers that it needs to sum in order to get the next even ones
11:31:57 <Cheetahfoot> duh.
11:32:02 <Cheetahfoot> that makes so much sense.
11:32:03 <Cheetahfoot> sorry.
11:33:01 <Cheetahfoot> thank you mauke, oerjan.
11:33:12 <allbery_b> IIRC MaybeT is in the "New monads" section of the wiki, it's not standard
11:33:22 <allbery_b> (yet)
11:33:22 <Cheetahfoot> this list rocks, btw.
11:33:34 <oerjan> well we can simulate with ErrorT, i think
11:33:43 <oerjan> @src ErrorT
11:33:43 <lambdabot> newtype ErrorT e m a = ErrorT { runErrorT :: m (Either e a) }
11:33:56 <allbery_b> @index EitherT
11:33:57 <lambdabot> bzzt
11:34:09 <mauke> @instances Monoid
11:34:10 <lambdabot> (), (a -> b), (a, b), (a, b, c), All, Any, Dual a, Endo a, Ordering, Product a, Sum a, [a]
11:34:45 <helmut> oerjan: as im reading docs: frown can create non-deterministic parsers.
11:35:21 <oerjan> helmut: oh.  maybe i guessed right anyhow then :)
11:36:13 <oerjan> @instances-importing Control.Monad.Error Error
11:36:14 <lambdabot> IOError, [Char]
11:36:39 <mauke> @src Error
11:36:39 <lambdabot> class Error a where
11:36:39 <lambdabot>     noMsg  :: a
11:36:39 <lambdabot>     strMsg :: String -> a
11:37:00 <mauke> instance Error () where noMsg = (); strMsg = const ()
11:37:28 <helmut> hmm. I'm still sitting on 12 reduce/reduce conflicts. :-(
11:42:39 <oerjan> hm, i searched for the mysterious Daan Leijen and found another address: daan (at) equational (dot) org
11:51:21 <hpaste>  jimmy80_1 pasted "jimmy80_1" at http://hpaste.org/1464
11:52:12 * allbery_b sees the spammers have found hpaste again :(
12:00:06 <dolio> I have a hard time believing anyone would make purchases based on that.
12:01:41 <sorear> allbery_b: deleted.
12:02:39 * allbery_b was just grumping
12:27:44 <SamB> sorear: so how's the quixotic compiler going?
12:29:52 <Nafai> quixotic?
12:39:59 <mgsloan> pandoc dude on here?  it's sweet has hell!
12:40:07 <mgsloan> just what I need!
12:41:08 <sorear> mgsloan: conal
12:41:40 <nominolo> @where pandoc
12:41:40 <lambdabot> I know nothing about pandoc.
12:41:57 <mgsloan> http://sophos.berkeley.edu/macfarlane/pandoc/
12:44:32 <nominolo> but it seems to be written by john macfarlane. not conal
12:44:44 <nopcode> re
12:45:00 <nopcode> i have a recursive function which calculates solutions to a puzzle
12:45:03 <nominolo> @where+ pondoc http://sophos.berkeley.edu/macfarlane/pandoc/
12:45:03 <lambdabot> Done.
12:45:13 <nopcode> everything it reaches its deepest level of recursion it has found a solution
12:45:48 <sorear> nominolo: pondoc?
12:45:50 <nopcode> so if i make the whole function return a list of all solutions, will that benefit from lazy evaluation _if_ i only take the first element of that result for example?
12:46:05 <sorear> yeah
12:46:48 <nominolo> sorear: yep
12:47:23 <sorear> you where+'d  pee oh en dee oh sea
12:47:42 <nominolo> ouch
12:48:00 <nominolo> @where+ pandoc http://sophos.berkeley.edu/macfarlane/pandoc/
12:48:00 <lambdabot> Done.
12:48:31 <nominolo> @where pee oh en dee sea
12:48:31 <lambdabot> I know nothing about pee.
12:48:42 <araujo> hello
12:49:24 <nominolo> @where+ pondoc
12:49:25 <lambdabot> Done.
12:49:32 <nominolo> @where pondoc
12:49:47 <oerjan> @list where
12:49:48 <lambdabot> where provides: where url what where+
12:49:57 <oerjan> @help url
12:49:57 <lambdabot> url <key>. Return element associated with key
12:50:01 <nopcode> how can i remove all elements equal to a given one from a list`?
12:50:03 <oerjan> @help what
12:50:04 <lambdabot> what <key>. Return element associated with key
12:50:11 <sorear> @where mlwlvlf
12:50:11 <lambdabot> I know nothing about mlwlvlf.
12:50:16 <nominolo> nopcode: fllter
12:50:29 <sorear> @where+ pondoc I know nothing about pondoc.
12:50:29 <lambdabot> Done.
12:50:34 <sorear> @where pondoc
12:50:34 <nopcode> nominolo: ah. currying right?
12:50:34 <lambdabot> I know nothing about pondoc.
12:50:51 <nopcode> nominolo: (/= key) as comparison function?
12:51:06 <nominolo> > filter (/=3) [1..5]
12:51:08 <lambdabot>  [1,2,4,5]
12:51:16 <nopcode> yeah, right, thanks... cool :)
12:51:41 <oerjan> @where+ pondoc 10° 43' 0" North, 125° 0' 0" East
12:51:41 <lambdabot> Done.
12:58:12 <br1> Why are Java interfaces closer to Haskell's classes than to C++'s? I always had the impression that Java interfaces where just virtual base classes.  See http://jjinux.blogspot.com/2007/06/computer-science-coping-with-unknown.html
12:58:14 <lambdabot> Title: JJinuxLand: Computer Science: Coping with Unknown Types, http://tinyurl.com/2u5pvd
12:58:56 <sorear> br1: they're just different ways of looking at the same thing
12:59:30 <sorear> haskell classes are like C++ pure virtual template classes, or Java generic interfaces
12:59:41 <sorear> (albeit with better inference)
13:00:17 <sorear> (I find it amazing that BS declared return type inference "too hard" when Damas-Milner had been around for so many years already)
13:00:26 <Nafai> br1: abstract classes are probably closer to virtual base classes
13:00:39 <nominolo> br1: if you're interested you might like to see wadler's talk at google
13:01:17 <Nafai> I tried listening to Wadler's talk but I couldn't concentrate hard enough to understand it.  Type systems are complicated :/
13:01:19 <mauke> sorear: well, it is hard if you want to build it on top of C
13:01:26 <nopcode> hm
13:01:37 <nopcode> how do i apply the same arguments to multiple functions?
13:01:39 <nominolo> br1: "evolution of programming languages" (or so)
13:01:43 <br1> this http://video.google.com/videoplay?docid=-4167170843018186532 ?
13:01:44 <lambdabot> Title: Faith, Evolution, and Programming Languages
13:01:52 <br1> ok
13:01:57 <nominolo> yep
13:01:58 <mauke> > sequence [sin, sqrt, (^2)] 3
13:02:06 <lambdabot>  [0.1411200080598672,1.7320508075688772,9.0]
13:02:13 <nopcode> thx
13:02:19 <oerjan> nopcode: map ($ x) for one argument
13:02:41 <nopcode> i have 3 arguments actually
13:02:49 <nopcode> what does $ do?
13:03:02 <oerjan> it's application
13:03:07 <oerjan> as an operator
13:03:11 <mauke> is there an uncurry3?
13:03:13 <nopcode> ic
13:03:14 <nominolo> > [sin, sqrt, (^2)] `ap` [1,4,6]
13:03:17 <lambdabot>  [0.8414709848078965,-0.7568024953079282,-0.27941549819892586,1.0,2.0,2.44948...
13:03:30 <nopcode> nominolo: ic :)
13:03:58 <thoughtpolice> nopcode: essentially, you could just say that 'f x' is the same as saying 'f $ x'
13:03:59 <nominolo> actually, i was just testing ;)
13:04:01 <oerjan> nopcode: people here are being too clever
13:04:07 <Igloo> Does anyone know the best place to get RPMs for a machine claiming to be running RHEL3?
13:04:09 <nopcode> i dont have `ap`
13:04:18 <mauke> nopcode: import Control.Monad
13:04:21 <allbery_b> Control.Monad
13:04:23 <oerjan> try using a lambda: (\f -> f x y z)
13:04:23 <allbery_b> heh
13:04:41 <nopcode> wait i second i want an academic solution
13:04:47 <nopcode> not a production one with external stuff etc
13:04:52 <mauke> > [(+), (*), div] `sequence` 10 `sequence` 3
13:04:54 <lambdabot>  [13,30,3]
13:05:30 <nominolo> mauke: wicked :)
13:06:00 <mauke> > map (\f -> f 10 3) [(+), (*), div]
13:06:02 <lambdabot>  [13,30,3]
13:06:18 <nopcode> mauke: that looks nice
13:07:13 <nopcode> ah damn i have to concatenate the elements too
13:07:17 <nopcode> that makes it rather long again
13:07:21 <oerjan> nopcode: Control.Monad is a standard module
13:07:31 <nopcode> is there a short concatenation operator?
13:07:37 <oerjan> concatMap
13:07:44 <nopcode> ah cool
13:07:51 <milkcan> hello can someone help me to develop malware? i cam currently using haskell to develop an advertisement bot net for irc
13:08:03 <oerjan> (also concat if you don't need to combine with a map)
13:08:05 <mauke> obvious troll is obvious
13:08:22 <milkcan> this is bold text
13:08:24 <nopcode> oerjan: k :)
13:08:29 <dbremner> Igloo - CentOS?
13:08:40 <nopcode> let set = concatMap (\f -> f rows x y)  [getRow, getColumn, getBlock] in filter (\i -> not (elem i set)) [1..9]
13:08:47 <nopcode> any suggestions on how to improve that further?
13:08:51 <mauke> notElem
13:09:08 <nopcode> i want to find all ints in 1..9 that are not in that concatenated list called set
13:09:11 <nopcode> mauke: ok
13:09:58 <milkcan> only muslims have a right to live! allahu akhbar
13:10:10 <nominolo> (\i -> not (elem i set)) == (not . (`elem` set))
13:10:17 <oerjan> nopcode: \\ difference operator
13:10:21 <mauke> (`notElem` set)
13:10:35 <oerjan> > [1..9] \\ [2..3]
13:10:36 <lambdabot>  [1,4,5,6,7,8,9]
13:10:49 <Igloo> dbremner: Hmm, looks like they only offer ISOs for download?
13:11:07 <nopcode> oerjan: nice!!
13:11:21 <dbremner> Igloo - there should be rpm mirrors somewhere.
13:11:43 <nopcode> test.hs:16:86: Not in scope: `\\'
13:11:51 <oerjan> @index (\\)
13:11:51 <lambdabot> bzzt
13:11:55 <oerjan> @index \\
13:11:55 <lambdabot> bzzt
13:12:00 <oerjan> @hoogle \\
13:12:01 <lambdabot> Hoogle Error: Parse Error: Unexpected character '\\'
13:12:04 <oerjan> @hoogle (\\)
13:12:05 <lambdabot> Did you mean: (\\)
13:12:06 <lambdabot> Prelude.undefined :: a
13:12:06 <lambdabot> Control.Monad.Reader.ask :: MonadReader r m => m r
13:12:11 <Igloo> dbremner: Ah, think I've found them, ta
13:12:17 <oerjan> sheesh
13:12:26 <oerjan> nopcode: probably in Data.List
13:13:11 <oerjan> > (Data.List.\\)
13:13:13 <lambdabot>  <[Integer] -> [Integer] -> [Integer]>
13:13:26 <oerjan> :t (Data.List.\\)
13:13:30 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
13:13:53 <oerjan> (also a standard module)
13:15:07 <nopcode> ok working :)
13:15:45 <nopcode> i have a feeling that haskell might even make perl look bad in terms of compact representation
13:16:20 <oerjan> sometimes
13:17:05 <nopcode> ok it seems to work
13:17:09 <nopcode> sudoku solver in 33 lines *g*
13:17:48 <oerjan> > nubBy(((>0).).gcd))[2..]
13:17:48 <lambdabot>  Parse error
13:18:02 <oerjan> > nubBy(((>0).).gcd)[2..]
13:18:07 <lambdabot> Terminated
13:18:42 <oerjan> > nubBy(((>1).).gcd)[2..]
13:18:45 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
13:18:47 <fasta> Can I also make an Arbitrary instance for reference based structures?
13:19:33 <nopcode> ok now i need a compact way to "replace" a value in a 2D-array (list of lists)
13:19:43 <sorear> nopcode: bad idea
13:19:51 <nopcode> sorear: why?
13:19:52 <sorear> nopcode: lists are O(n) to modify'
13:20:00 <sorear> indeed, access
13:20:08 <sorear> because they are linked lists, not arrays
13:20:15 <nopcode> but haskell seems to be very list-centric
13:20:19 <sorear> you should probably be using Maps
13:20:30 <oerjan> nopcode: only before you start looking at the libraries
13:20:30 <dbremner> Igloo - there's also RHN, if by some chance it has support.
13:20:39 <sorear> nopcode: yes, but that won't make up for O(n) vs O(log n)
13:21:05 <nopcode> well a proper 2d array should be O(1) ;)
13:21:28 <nopcode> well if the notation is clean and readable, ok
13:21:57 <nopcode> a tree?
13:22:06 <nopcode> well that's not much better
13:22:12 <nopcode> aren't there fixed-size arrays?
13:22:35 <oerjan> nopcode: you might try Diff arrays
13:22:43 <fasta> nopcode: have you ever browsed the documentation?
13:23:08 <oerjan> @index Diff
13:23:09 <lambdabot> bzzt
13:23:09 <sorear> nopcode: why invent a tree?
13:23:16 <oerjan> @index Data.Array.Diff
13:23:16 <lambdabot> bzzt
13:23:25 <oerjan> @index Data.Array
13:23:25 <lambdabot> bzzt
13:23:28 <nopcode> sorear: i just checked the docs and Maps are trees
13:23:35 <sorear> nopcode: And you care?
13:23:39 <nopcode> yeah
13:23:50 <nopcode> because thats not the "proper" datastructure either
13:23:55 <sorear> nopcode: Why?  It's plenty fast and natural to use.
13:23:55 <nopcode> then i can as well use lists
13:24:01 <oerjan> :t Data.Array.Diff.array
13:24:05 <lambdabot> forall i e (a :: * -> * -> *). (Ix i, Data.Array.Base.IArray a e) => (i, i) -> [(i, e)] -> a i e
13:24:26 <sorear> nopcode: trees are MUCH faster than lists, rather faster than GHC's implementation of arrays, and very natural in a FP setting.
13:24:42 <nopcode> sorear: my lists consist of 9 elements..
13:25:23 <nopcode> sorear: but it's still not correct to use a tree for a densely indexed, constant size array ;)
13:25:28 <fasta> sorear: how can trees be faster than arrays?
13:25:48 <sorear> fasta: DiffArrays require thread synchronization
13:25:49 <mgsloan> search
13:26:02 <sorear> fasta: acquiring a MVar is far slower than walking a tree
13:26:17 <fasta> sorear: what if you only have one thread?
13:26:27 <sorear> fasta: GHC doesn't know that :)
13:26:32 <fasta> sorear: !!
13:26:42 <sorear> ??
13:27:01 <fasta> sorear: If GHC compiles a complete program by itself, why would it ever use MVars?
13:27:05 <nopcode> actually i dont want mutable arrays
13:27:12 <nopcode> what about Data.Array?
13:27:22 <sorear> it's not usual for threadsafe structures to auto-detect singlethreadedness
13:27:23 <fasta> nopcode: read the documentation
13:27:49 <fasta> sorear: where does the MVar come into play?
13:28:10 <nopcode> fasta: i'm browsing it in parallel
13:28:24 <fasta> sorear: or: where is one that doesn't do synchronisation?
13:28:38 <fasta> sorear: even Java has non-synchronizing structures
13:28:49 <sorear> No, because Haskellers are allergic to anything that requires side conditions.
13:28:51 <Saizan> fasta: only DiffArray does this
13:29:04 <sorear> newtype IOToDiffArray a i e =
13:29:08 <sorear>  DiffArray {varDiffArray :: MVar (DiffArrayDataa i e)}
13:29:13 <sorear> urxvt--
13:29:46 <fasta> How easy is it to get one that doesn't use MVars?
13:30:41 <fasta> Or wouldn't it work in the first place?
13:32:07 <nominolo> > [(^2),(*2)] <*> 4
13:32:11 <lambdabot>   add an instance declaration for (Num [a])
13:32:23 <nominolo> > [(^2),(*2)] <*> (4 :: Int)
13:32:25 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Int'
13:32:41 <Saizan>  > [(^2),(*2)] <*> [4]
13:32:45 <Saizan> > [(^2),(*2)] <*> [4]
13:32:48 <lambdabot>  [16,8]
13:33:01 <nominolo> @src [] (<*>)
13:33:01 <lambdabot> (<|>) = (++)
13:33:16 <Botje> :t <*>
13:33:17 <nominolo> huh?
13:33:19 <lambdabot> parse error on input `<*>'
13:33:26 <Botje> :t (<*>)
13:33:28 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
13:34:26 <oerjan> > [(^2),(*2)] `ap` [4]
13:34:29 <lambdabot>  [16,8]
13:34:44 <nominolo> > [(^2),(*2)] <*> [4,3]
13:34:46 <lambdabot>  [16,9,8,6]
13:35:01 <oerjan> @src Applicative
13:35:01 <lambdabot> class Functor f => Applicative f where
13:35:01 <lambdabot>     pure  :: a -> f a
13:35:01 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
13:35:21 <nominolo> @src Applicative []
13:35:22 <lambdabot> Source not found. I feel much better now.
13:35:34 <sorear> @src pure []
13:35:34 <lambdabot> Source not found. Maybe if you used more than just two fingers...
13:35:39 <sorear> @src [] pure
13:35:39 <lambdabot> pure = return
13:35:45 <sorear> @src [] (<*>)
13:35:45 <lambdabot> (<|>) = (++)
13:35:57 <sorear> @src [] (<\*>)
13:35:57 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
13:36:24 <sorear> @tell dons "@src [] (<*>)"
13:36:24 <lambdabot> Consider it noted.
13:36:42 <oerjan> instance Applicative [] where pure = return (<*>) = ap
13:37:13 <oerjan> instance Applicative [] where pure = return (<*>) = ap
13:37:28 <oerjan> what happened to the line breaks? o_O
13:37:57 <nominolo> hm, in the paper thay talk of (<*>) = zapp
13:38:07 <nominolo> and pure = return
13:38:10 <nominolo> er
13:38:12 <nominolo> repeat
13:38:26 <oerjan> for lists?
13:38:59 <nominolo> yep
13:39:11 <nominolo> page 5, at the top
13:39:22 <fasta> Ok, I looked at the source of DiffArray somewhat better. Indeed, it looks horrible.
13:40:09 <aeyakovenko> woooot, my sha1 is only 12 times slower then the native C, without unrolling any loops
13:40:20 <sorear> nominolo: look at the end
13:40:43 <sorear> nominolo: they say you have to be compatible with existing Monad instances, so they created a newtype wrapper
13:40:48 <nopcode> how do i get the "cross product" of a range of numbers?
13:40:49 <sorear> @src ZipList pure
13:40:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
13:41:32 <SamB> Nafai: sorear for some reason decided to call his Haskell compiler QHC, and I guessed wildly that it might stand for Quixotic Haskell Compiler. he seemed to like it...
13:41:41 <Nafai> Heh
13:41:43 <sjanssen> @yow
13:41:43 <lambdabot> It was a JOKE!!  Get it??  I was receiving messages from DAVID LETTERMAN!!
13:41:43 <lambdabot> YOW!!
13:42:35 <sjanssen> nopcode: do you mean cartesian product?
13:42:49 <conal> nominolo: The [] instance of Applicative is the standard Monad-as-Applicative
13:42:52 <sjanssen> > [(x, y) | x <- [1..3], y <- [1..3]]
13:42:55 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:43:13 <sjanssen> > liftM2 (,) [1..3] [1..3] -- for obscurity's sake
13:43:14 <nopcode> sjanssen: yeah
13:43:14 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
13:43:26 <nopcode> ic
13:43:38 <conal> nominolo: in other words, every monad is an AF, using that definition.  ZipList gives another instance (and so must be newtype-wrapped).
13:43:41 <nominolo> conal: ok, makes sense.  btw, great paper!
13:44:20 <conal> nominolo: the "tangible" one?
13:44:30 <oerjan> > liftM2 (,) [1..3] [1..4]
13:44:32 <nominolo> ah
13:44:32 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(2,1),(2,2),(2,3),(2,4),(3,1),(3,2),(3,3),(3,4)]
13:44:42 <fasta> @where QHC
13:44:42 <lambdabot> I know nothing about qhc.
13:44:46 <nominolo> oh.  sorry.  confused
13:44:56 <nominolo> conal =/= conor
13:45:08 * SamB wonders how long JHC will continue to load it's library files monolithicalyl
13:45:16 <mnislaih> @help src
13:45:16 <lambdabot> src <id>. Display the implementation of a standard function
13:45:23 <conal> nominolo: oh!!  :)  i've been deep into AFs also.  that might cause some confusion!
13:45:53 <mnislaih> does src display specific implementations for type class functions ?
13:45:58 <mnislaih> @src [] fmap
13:45:59 <lambdabot> fmap = map
13:45:59 <nominolo> conal: but your's are nice too.  i wonder when we'll have real "presentations" for haskell :)
13:46:07 <mnislaih> @src Maybe fmap
13:46:08 <lambdabot> fmap _ Nothing       = Nothing
13:46:08 <lambdabot> fmap f (Just a)      = Just (f a)
13:46:10 <mnislaih> cool !
13:46:27 <conal> nominolo: thanks.  real "presentations"?
13:47:03 <nominolo> conal: the dynamic windows toolkit for the lisp machine had "presentations"
13:47:30 <bottle> hi any one here run plan9?
13:47:31 <nominolo> a visual, interactive representation of some internal data structure
13:47:32 <conal> nominolo: what were they?
13:47:38 <conal> nominolo: oh!
13:48:12 <nominolo> in fact you could associate *any* output with a presentation
13:48:24 <conal> nominolo: i wonder how my "interactive visualizers" (eros) relate.
13:48:56 <nominolo> conal: they are quite similar i think
13:49:38 <conal> nominolo: good to know.  i'll poke around for a description.  do you have any pointers?
13:49:42 <nominolo> conal: http://www.lispworks.com/documentation/lw43/CLIM/html/climguide-92.htm#pgfId-383438
13:49:44 <lambdabot> Title: 6.1.2 Presentations and Presentation Types, http://tinyurl.com/2dabhl
13:49:56 <conal> nominolo: thanks!
13:50:07 <nominolo> conal: the whole clim spec is online
13:50:27 <nominolo> i don't know any really good tutorial though
13:51:23 <conal> i'm exploring a thesis that all GUIs are visualizations of functional values.  other kinds of "interfaces" as well.
13:51:45 <fasta> conal: what meaning has that sentence?
13:51:51 <Nafai> conal: What do you mean "visualizations of functional values"?
13:51:56 <bottle> please any one help?
13:52:33 <fasta> I have another thesis: writing a good GUI takes work no matter how nice your frame work is.
13:52:47 <fasta> Sure, it might make things _easier_.
13:52:49 <conal> i mean ways to interactively visualize/inspect pure values, e.g., functions.
13:52:50 <Saizan> bottle: feel free to ask
13:53:04 <fasta> That doesn't mean it will magically become _easy_.
13:53:17 <fasta> Some values are hard to visualize to begin with.
13:54:04 <nominolo> fasta: but frameworks to easily try out new visualizations are more than welcome
13:54:04 <nopcode> hmm it seems to have become much slower with arrays as opposed to lists
13:54:14 <conal> fasta: maybe.  i don't know.  i'm approaching the other angle for now.  from GUIs to pure values.
13:54:54 <fasta> conal: "the other angle"
13:55:01 <fasta> conal: can you be more vague?
13:55:17 <nominolo> conal: could that yield spreadsheet-like capabilites?
13:56:20 <conal> nominolo: if you mean dependencies and immediate update, then yes.  that's what TV/GuiTV do now.  http://www.haskell.org/haskellwiki/TV
13:56:21 <lambdabot> Title: TV - HaskellWiki
13:56:45 <fasta> dependencies and immediate update is a simple algorithm developed decades ago.
13:56:51 <conal> fasta: probably, if i tried.
13:57:08 <fasta> Sure, it's nice to have, but nothing _new_.
13:58:15 <conal> fasta: it's not the algorithm that's new.  rather then algebra of visualizations, and hiding the update machinery underneath the functional algebra.
13:58:32 <fasta> conal: that's also not new.
13:58:57 <fasta> conal: efficient functional data structures have already been discovered for years.
13:59:05 <nominolo> conal: i'm looknig for something that would scale up to editors with multiple lines and maybe more.  but i guess it'll probably too heavyweight for this
13:59:14 <fasta> More efficient than anything implemented in Haskell, though.
13:59:54 <conal> fasta: i'm having a hard time tracking how your comments are related to what TV does.  Have you read the wiki entry or the eros paper?
14:00:04 <fasta> conal: I saw TV once.
14:00:12 <fasta> conal: I didn't see anything new.
14:00:37 <conal> fasta: i believe you.  perhaps you missed it.
14:00:44 <fasta> Nope, I don't see anything new.
14:01:24 <fasta> conal: I saw that wiki page months ago and it is now about the same.
14:01:35 <conal> nominolo: i'd be interested in playing with that application.
14:01:57 <norpan> i like fudgets
14:02:54 <fasta> If by visualizations of values you mean printing text in a textbox, you are wildly misusing words.
14:02:56 <glen_quagmire> > [0..0]
14:02:58 <lambdabot>  [0]
14:03:04 <conal> fasta: could you explain how efficient functional data structures relate?  i'm not making the connection.
14:03:35 <conal> nominolo: i mean collaboratively, if it's something you're thinking about.
14:04:04 <fasta> conal: There is no difference between functional and non-functional values anymore.
14:04:35 <fasta> conal: so, you specifying them as if they are is nonsensical to begin with.
14:05:17 <nominolo> conal: sure.  but it's only thinking and some small experiments so far.  it'll also be not at all related to my Master's thesis, so it'll stay a side project for a while.
14:05:37 <nominolo> conal: i can write up the general idea though
14:06:26 <conal> nominolo: works for me.  i'll be happy to give you some comments, and we can take it from there, as inspired.
14:06:52 <mgsloan> conal - are you the pandoc guy?
14:07:30 <conal> mgsloan: i did pan.  what's "pandoc"?
14:07:44 <mgsloan> oh, never mind then
14:08:07 <mgsloan> pandoc is a haskell documentation engine
14:08:20 <nominolo> mgsloan: i don't thing john macfarlane is in this channel
14:08:37 <mgsloan> yeah, I suppose not
14:08:38 <conal> msgloan: oh, yeah.  looks very neat!
14:08:48 <nominolo> mgsloan: he probably has an email address though ;)
14:08:53 <mgsloan> true :)
14:17:03 <nopcode> it really became alot slower with arrays as opposed to lists =)
14:17:31 <nopcode> i'm using diffarrays now
14:18:01 <nopcode> sudoku = listArray ((0,0), (8,8)) (concatMap parseLine hard) :: DiffArray (Int,Int) Int
14:18:12 <nopcode> is that the correct way to use a DiffArray?
14:19:47 <oerjan> i guess so
14:20:00 <nopcode> takes minutes
14:20:06 <nopcode> it took less than half a second before
14:20:21 <nopcode> with a list of 9 lists with 9 elements each
14:21:39 <oerjan> well from the discussion it sounds like DiffArrays have been broken, really.
14:21:52 <nopcode> well the normal arrays didnt seem to be faster
14:22:01 <nopcode> i think i'll go back to lists
14:22:27 <oerjan> the immutable arrays are not supposed to be efficient to update, except DiffArray
14:22:53 <oerjan> the mutable arrays require monadic code.
14:23:21 <oerjan> probably best with lists for such small sizes, then
14:24:40 <Jaak> > foldM (\xs x -> (x : xs) : [xs]) [] [1,2,3]
14:24:42 <lambdabot>  [[3,2,1],[2,1],[3,1],[1],[3,2],[2],[3],[]]
14:25:20 <conal> does anyone know if @djinn handle type definitions?
14:25:26 <conal> (handles)
14:27:24 <oerjan> conal: i thought i saw someone do that the other day
14:27:32 <oerjan> @list djinn
14:27:32 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
14:27:45 <oerjan> @help djinn-add
14:27:45 <lambdabot> djinn-add <expr>.
14:27:45 <lambdabot> Define a new function type or type synonym
14:28:41 <oerjan> @help djinn-names
14:28:42 <lambdabot> djinn-names.
14:28:42 <lambdabot> Show the current djinn environment, compactly.
14:28:47 <oerjan> @djinn-names
14:28:47 <lambdabot> Either Left Right Maybe Nothing Just Bool False True Void Not Void Eq Bool
14:28:47 <conal> oerjan: thanks.
14:29:28 <conal> @djinn-add Endo a = a -> a
14:29:28 <lambdabot> Cannot parse command
14:29:33 <treble> callCC = ($ Cont . const)
14:29:39 <conal> hm
14:29:41 <treble> seems so much simplier
14:29:46 <treble> now that I Think about it
14:30:00 <nopcode> so uh
14:30:07 <oerjan> :t callCC
14:30:09 <nopcode> whats the suggested way to change an element in a list of lists?
14:30:09 <lambdabot> forall a (m :: * -> *) b. (MonadCont m) => ((a -> m b) -> m a) -> m a
14:30:29 <nopcode> or how do you change the n-th element of a list, anyways?
14:30:45 <oerjan> nopcode: i don't think there is a given function for it but splitAt is a good start
14:31:04 <oerjan> > splitAt 3 "testing"
14:31:06 <lambdabot>  ("tes","ting")
14:31:38 <treble> changeNth 0 y (_:xs) = y:xs; changeNth n y (x:xs) = x:changeNth (n-1) y xs
14:32:07 <treble> splitAt is a cleaner way though...
14:32:11 <oerjan> @quote recursion
14:32:11 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
14:32:15 <oerjan> @quote recursion
14:32:15 <lambdabot> VerityStob says: Lisp is still #1 for key algorithmic techniques such as recursion and condescension.
14:32:27 <oerjan> @quote peeve
14:32:28 <lambdabot> No quotes match. It can only be attributed to human error.
14:32:34 <oerjan> @quote soapbox
14:32:34 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
14:32:40 <oerjan> what?
14:32:52 <treble> Why don't you just try to say what you are trying to get lambdabot to say ;)
14:33:27 <oerjan> there was a quote about how everyone tried to use clever higher-order functions when simple recursion would do
14:33:31 <conal> @djinn-add type Endo a = a -> a
14:34:17 <nopcode> let (l,r) = (splitAt x s) in
14:34:22 <nopcode> this seems to work interactively
14:34:26 <treble> changeNth n y xs = case splitAt n xs of (a,_:b) -> a ++ y:xs; _ -> error "index out of range"
14:34:30 <nopcode> but not in the source file?
14:34:49 <treble> oops
14:34:53 <treble> a++y:b
14:36:24 <nopcode> doesnt that work?
14:36:30 <nopcode> let (l,r) = splitAt ...?
14:36:36 <treble> yes that works
14:36:45 <treble> You can't do the let at the top level though
14:37:06 <oerjan> nopcode: depends where you put it i guess
14:38:08 <nopcode> changeCell s:ss x 0 c = let (l,r) = (splitAt x s) in 1
14:38:12 <nopcode> thats the actual definition
14:38:17 <nopcode> it says "parse error in pattern"
14:38:26 <oerjan> nopcode: need parentheses around s:ss
14:38:42 <nopcode> argh!
14:38:44 <nopcode> ok thx :)
14:40:31 <oerjan> btw it is a haskell idiom to pass a function changing the value rather than the new value.  that way you can use the method recursively, which may help with a list of lists
14:41:09 <nopcode> a function changing the value?
14:42:22 <treble> changeNth n f xs = case splitAt n xs of (a,b:c) -> a ++ f b : c; _ -> error "index out of range"
14:42:57 <treble> thought I don't know which idiom you are refering to :)
14:43:29 <nopcode> ok its working again
14:43:41 <oerjan> and then you can do changeNth x (changeNth y (const c)) ss
14:43:44 <nopcode> solves a hard soduko in like 0.5 seconds :)
14:44:35 <oerjan> treble: there are lots of modify functions
14:45:03 <oerjan> :t modify
14:45:11 <lambdabot> forall s (m :: * -> *). (MonadState s m) => (s -> s) -> m ()
14:45:25 <nopcode> so theres no builtin function for slicing lists is there
14:45:51 <fasta> nopcode: there are programs that generate and solve all sudokus in under one second
14:46:04 <nopcode> fasta: all sodukos?
14:46:29 <oerjan> fasta: you mean all of them at once?
14:46:36 <fasta> oerjan: yes
14:46:42 <nopcode> :)
14:46:49 <mauke> nopcode: well, there's take/drop
14:46:53 <nopcode> well my c++ solver took like 20 ms for any sudoku, including empty
14:47:04 <oerjan> @src splitAt
14:47:04 <lambdabot> splitAt n xs           =  (take n xs, drop n xs)
14:47:13 <fasta> nopcode: but those used smart algorithms
14:47:13 <nopcode> i'm actually suprised that this haskell program is so fast
14:47:24 <nopcode> fasta: ah ic, i'm using backtracking
14:47:41 <fasta> nopcode: heh, well, I am sure they weren't wasting their time doing that :)
14:47:59 <nopcode> wasting their time? it's efficient ;P
14:48:10 <fasta> nopcode: it's efficient for your time, yes
14:48:31 <nopcode> plus it can be low-level optimized alot
14:48:56 <fasta> nopcode: not that much ;)
14:50:06 <nopcode> _blockBitmaps[16 * (div3mul3[y] + div3[x]) + val-1] = 1;
14:50:07 <nopcode> hihi
14:50:11 * nopcode <3
14:50:44 <nopcode> could probably also be implemented efficiently on a fpga
14:51:35 <fasta> nopcode: is that your code?
14:51:42 <nopcode> my c++ code yeah
14:52:11 <fasta> nopcode: No comments
14:54:02 <nopcode> =)
14:54:22 <mauke> _blockBitmaps is possibly a reserved identifier
14:54:30 <mauke> depends on its scope
14:54:59 <nopcode> don't blame me, it's the coding style used in a lot of books and i adopted it
14:55:08 <nopcode> i use underscore prefixes for class variables
14:55:22 <mauke> eww
14:55:50 <nopcode> "design patterns" for example
14:55:53 <mauke> another reason why C++ needs to be shot
14:56:41 <nopcode> :)
14:56:51 <nopcode> well there are no alternatives
14:56:58 <nopcode> java is sluggish at best
14:57:07 <mauke> get a better java compiler
14:57:14 <nopcode> yeah, right
14:57:44 <nopcode> eclipse took like 5 seconds from pressing a key untill the character appeared in the editor on a p2-400
14:57:52 <nopcode> that's when i laughed and uninstalled the java stuff :)
14:58:07 <mauke> that has nothing to do with the language
14:58:18 <nopcode> sure it's the implementation
14:58:32 <nopcode> but i haven't seen an efficient one
14:59:19 <sorear> fasta: I have trouble beleiving you can generate and solve all sudokus in 1s.
14:59:38 <sorear> fasta: If you could do that, surely you could count them in the process
15:00:00 <nopcode> hmm
15:00:09 <nopcode> some random sampling should give an idea how many valid sodukos exist
15:00:11 <sorear> nm
15:00:22 <nopcode> guess i could do that
15:00:28 <sorear> WP says:   A completed Sudoku grid is a special type of Latin square with the additional property of no repeated values in any 3Ã3 block. The number of classic 9Ã9 Sudoku solution grids was shown in 2005 by Bertram
15:00:30 <fasta> sorear: all valid sudokus, one of the rules is that no back tracking is requires, IIRC, but I didn't do it, but someone I trust and with skill did.
15:00:33 <sorear>  Felgenhauer and Frazer Jarvis to be 6,670,903,72,021,072,936,960^[19] (sequence A107739 in OEIS) : this is roughly 0.00012% the number of 9Ã9 Latin squares. Various other grid sizes have al so been
15:00:46 <fasta> required*
15:00:51 <nopcode> oh.
15:00:54 <sorear> fasta: He couldn't have done it via simple enumeration
15:01:12 <sorear> fasta: if he's a good mathematician, maybe, but
15:01:15 <oerjan> fasta: i haven't understood what "no backtracking required" is supposed to _mean_?
15:01:19 <jre2> anyone know why the gentoo overlay for ghc would have a filesize mismatch error? (is that always a corruption issue, or maybe something simple just wasn't updated)
15:01:41 <sorear> > length [ 1 .. 6670903752021072936960 ]
15:01:45 <sorear> fasta: ^^^
15:01:46 <lambdabot> Terminated
15:02:13 <fasta> sorear: are you sure those are the sudokus as used in magazines?
15:02:27 <nopcode> yeah thats too much
15:02:36 <nopcode> for < 1 s
15:02:50 <nopcode> i mean "generating" means constructing an explicit representation
15:03:11 <nopcode> which ought to be at least as complicated as incrementing an integer ;)
15:03:31 <sorear> Otoh...
15:03:37 <fasta> sorear: I think it didn't solve symmetrical problems.
15:03:44 <sorear> > let sudokuBoards = [ 1 .. 6670903752021072936960 ] in ()
15:03:45 <lambdabot>  ()
15:03:54 <nopcode> uhhh and thats only the solution grids
15:03:59 <nopcode> the number of puzzles is much higher
15:04:19 <nopcode> you can clear any amount of random cells in any of these solution grids and get another valid puzzle
15:04:52 <nopcode> well maybe not any amount if you stick to the puzzles with unambiguous solutions
15:07:59 <fasta> sorear: that's the number of completed sudokus, the number of problems having an unambiguous solution is much smaller.
15:08:23 <nopcode> greater :)
15:08:45 <nopcode> for each completed soduko you can generate multipl puzzles with that solution
15:09:13 <fasta> Right, I am sleeping.
15:10:29 <nopcode> main = putStrLn (length (solve sudoku))
15:10:31 <nopcode> why doesnt this work?
15:10:52 <mauke> what does length return? what does putStrLn take?
15:11:20 <nopcode> oh, right
15:12:08 <nopcode> how do i produce a static, optimized binary with ghc?
15:13:37 <nopcode> ah got it
15:15:13 <fasta> Is there any software system or language in which one can easily make changes to an existing library provides that source is available in a sort of AST tree at run-time, which enables you to make real sensible changes? I think only Smalltalk qualifies.
15:16:08 <SamB> yay.
15:16:28 <SamB> I seem to have managed to do a refactoring on JHC, preparatory to implementing a feature!
15:17:14 <fasta> Maybe that's only a good thing.
15:17:26 <fasta> SamB: nice, what feature?
15:18:02 <SamB> 'foreign import ccall "dynamic"' thingies
15:18:15 <Igloo> SamB: Re http://hackage.haskell.org/trac/ghc/ticket/1444 , I think we need an example of what you're actually trying to do and why it doesn't work
15:18:16 <lambdabot> Title: #1444 (Template Haskell: add proper support for qualified names in non-splicing  ...
15:19:02 <SamB> hmm.
15:19:57 <fasta> Igloo: is there any chance of getting a fast DiffArray soon?
15:20:15 <SamB> fasta: hmm?
15:20:18 <fasta> Igloo: i.e. one that doesn't use MVar?
15:20:42 <Igloo> fasta: I don't think I even knew it was slow
15:21:15 <xho> what about memcpy from one IOArray to another?
15:21:31 <sjanssen> fasta: in the concurrent GHC of today, an MVar is absolutely necessary
15:22:06 <fasta> sjanssen: you are suggesting that running code on two cores goes faster when you use DiffArray
15:22:12 <fasta> sjanssen: is that true?
15:22:16 <tuukkah> > maxBound :: Int
15:22:19 <lambdabot>  2147483647
15:22:34 <sjanssen> fasta: no, I'm saying that GHC must do locking to ensure safety
15:23:01 <fasta> sjanssen: on a single core it should be safe to get rid of it, right?
15:23:20 <sjanssen> fasta: *any* piece of code (even the pure stuff) can be executed concurrently
15:23:32 <sjanssen> fasta: there must be some atomicity regardless
15:24:23 <sjanssen> because a thread might be interrupted in the middle of an update, even when you're running on a single core
15:24:50 <fasta> sjanssen: but if you only have one thread running...
15:25:06 <sjanssen> fasta: this is a lot of "but if" :)
15:25:10 <sorear> fasta: run any ghc-compiled program with the debug scheduler option
15:25:20 <sorear> fasta: 5 threads when main is invoked
15:25:37 <sjanssen> fasta: you also have to consider stuff like 'par'
15:25:38 <fasta> sorear: ok, those are for garbage collection and stuff?
15:25:49 <sjanssen> fasta: and the NDP we'll see in 6.8
15:26:31 <sjanssen> fasta: IMO, making anything not concurrency safe is a poor decision at this time
15:26:32 <Igloo> fasta: Even if you only have one capability, you still have to handle preemptive concurrency
15:27:50 <fasta> I kind of assumed that GHC running the program and GHC doing other stuff where all or nothing games.
15:28:35 <sorear> fasta: Have you ever heard of "compositionality" ?
15:28:51 <xho> i'm writing a c function that i want to call from haskel. haskell should see it as returning a list. how should i design the c function so that the return value can be best converted to a haskell list?
15:29:31 <fasta> sorear: Isnt't that a synonym for making things simpler than they are in this case?
15:29:38 <sjanssen> xho: what is convenient for the C program?
15:29:53 <sjanssen> xho: it's pretty easy to marshal C arrays with Foreign.* functions
15:30:17 <fasta> sorear: It seems obvious to me that when I run the same semantics I intended in Java or C without any synchronizing variables, it would go much faster.
15:30:17 <sorear> Or you could generate elements one at a time. Or ...
15:30:29 <xho> problem with C array is who will free the memory?
15:30:50 <fasta> sorear: so, if GHC only assumes everything is "concurrent" that is a wrong assumption.
15:31:07 <fasta> OTOH, I can understand that the evaluation model should be kept simple.
15:31:31 <fasta> Calling that compositionality, however, goes one step too far.
15:31:54 <fasta> sorear: do I misunderstand you in any way?
15:31:56 <sjanssen> fasta: why is that a wrong assumption?
15:31:59 <sphynx> hi again!
15:32:47 <sphynx> My code of history analyzer is growing and now I'm trying to distribute it among several packages
15:33:00 <sphynx> But I encountered some troubles
15:33:06 <Lemmih> xho: Can't you just do that on the Haskell side?
15:33:36 <fasta> sjanssen: because if the same program goes faster when one strips of all the MVars and only has one thread running in a co-routine sort of way, it means the code doesn't run as fast as it could given the resources, hence wasted cycles.
15:35:28 <xho> Lemmih: i guess so... if i "null terminate" the array, will haskell be able to detect the end?
15:35:39 <sorear> fasta: Compositionality says that when you take two valid programs and run them concurrently, you don't suddenly start getting segfaults.
15:35:57 <sphynx> I have data definition used in main class and parser which I want to move to separate class. Parser uses data classes. And main class uses parser function in its main functions
15:36:13 <sphynx> So I'm producing cyclic dependecies between modules
15:36:35 <sphynx> and I have no good idea how I should resolve this..
15:36:48 <Lemmih> xho: Yes, there are functions in Foreign.Marshal.* that can do that.
15:37:11 <sphynx> Maybe I should move data classes to separate file and then import them from both modules?
15:37:28 <xho> Lemmih: ok thanks i'll read up on the docs
15:37:49 <fasta> sorear: so, GHC should keep track of what threads are accessing what values at compile time and based on that optimize useless stuff away.
15:38:16 <dmwit> sorear, I thought compositionality meant you could send the output of one function to the input of another without worrying about the first one affecting the second one?
15:38:24 <sorear> fasta: You just teleported from "Shoot my foot off *please*" territory into "PHD" territory.
15:38:34 <sorear> :)
15:38:51 * dmwit decides it might be good to look at the logs before jumping in
15:39:26 <fasta> sorear: I didn't actual teleport, I am everywhere.
15:39:31 <fasta> actually*
15:39:38 <fasta> :)
15:39:54 <sjanssen> fasta: one point to make is that truly pure code doesn't suffer from concurrency
15:40:12 * sorear wonders why fasta can't just use maps
15:40:27 <sjanssen> fasta: ghc doesn't have to do any locking on thunks
15:40:54 <fasta> sorear: they don't have O(1) operations
15:41:03 <sjanssen> yes, use IntMap -- O(1) updates!
15:41:33 <sorear> fasta: 10^9 > log n :)
15:41:59 <fasta> I might actually switch to IntMap, since I almost buy that argument.
15:42:40 <sjanssen> fasta: note that IntMap's operations are O(1) because the size of an Int is bounded
15:42:50 <fasta> sjanssen: I know
15:43:24 <sjanssen> we can make a similar case with Map -- addressable memory is bounded too ;)
15:43:51 <fasta> sjanssen: but when n-> infinity the IntMap stops working.
15:44:09 <fasta> Never mind.
15:44:18 <nopcode> hmm
15:44:19 <fasta> Hmm, do mind.
15:44:26 <nopcode> how do you construct graphs in haskell?=
15:44:45 <fasta> nopcode: you cannot efficiently unless you write your own library
15:44:48 <mauke> @hoogle graph
15:44:48 <sorear> @where fgl
15:44:48 <lambdabot> Data.Graph :: module
15:44:49 <lambdabot> Data.Graph.Inductive.Graph :: module
15:44:49 <lambdabot> Data.Graph.Graph :: type Graph
15:44:49 <lambdabot> http://www.cs.orst.edu/~erwig/fgl/
15:44:52 <nopcode> pardon?
15:44:53 <dmwit> There seems to be a Data.Graph...
15:45:04 <fasta> nopcode: those libraries are jokes
15:45:12 <nopcode> wait a second
15:45:20 <nopcode> i thought haskell was very well suited to graph operations
15:45:24 <sjanssen> fasta: well, you can't really construct an IntMap of size 'n' for an arbitrary n
15:45:40 <sorear> it is...
15:45:58 <fasta> nopcode: it is, there are just no good libraries.
15:46:08 <nopcode> what would i need a library for?
15:46:27 <fasta> nopcode: to do Complicated Stuff(TM)
15:46:46 <sorear> fasta: What do you think is wrong?
15:46:48 <nopcode> ;)
15:46:56 <sorear> fasta: FGL supports Complicated Stuff fine
15:46:57 <nopcode> well i was wondering how to do the referencing
15:47:08 <ptac> i'm trying to install cabal, and it says it needs pretty-any, and gives http://hackage.haskell.org/cgi-bin/hackage-scripts/package/pretty . That does not exist, and I can't find the pretty library.
15:47:09 <fasta> sorear: look at the complexities and laugh.
15:47:11 <sorear> fvo Complicated == I don't understand how to do it myself
15:47:12 <ptac> where can I find it/
15:47:14 <nopcode> that is have a node have a list of "references" to the other nodes
15:47:18 <fasta> sorear: or cry
15:47:41 <fasta> It should be called: the library that doesn't scale in a million years.
15:47:43 <sjanssen> nopcode: the general method is to give vertices some sort of label (like an Int)
15:47:58 <nopcode> sjanssen: ok, and then?
15:48:14 <sorear> fasta: exaples please
15:48:23 <sjanssen> and make your graph something like: type Graph v = Map v [v]
15:48:38 <fasta> sorear: read his articles
15:48:47 <Lemmih> ptac: You might be better off with a stable snapshot.
15:48:49 <sjanssen> nopcode: that representation is equivalent to an adjacency list that you see in all the algorithm books
15:49:18 <sorear> fasta: Paper /= Reality
15:49:38 <dmwit> Or better, type Graph v = v -> [v], and you can change the representation later if you don't like it! =P
15:49:56 <nopcode> dmwit: whats that?
15:50:02 <mauke> a function
15:50:10 <nopcode> oh, right ;)
15:50:17 <Lemmih> ptac: The base packages have been rearranged quite a bit. You can find them here if you feel like giving them a try: http://darcs.haskell.org/packages/pretty/
15:50:18 <lambdabot> Title: Index of /packages/pretty
15:50:41 <nopcode> because i just realized that sudoku is actually a 9-coloring problem
15:50:51 <nopcode> i think.
15:50:57 <fasta> nopcode: it is
15:51:18 <nopcode> fasta: but i suppose "good" algorithms make use of the spatial structure?
15:51:32 <nopcode> but then writing it as a graph algorithm is cleaner...
15:51:33 <nopcode> mh
15:51:58 <dmwit> Writing it as a graph *is* making use of the spatial structure, no?
15:52:01 <fasta> nopcode: I have not looked into the sudoku problem deeply myself other than knowing it's a graph coloring problem.
15:52:15 <nopcode> dmwit: nah, after you have a graph you use generic algorithms
15:52:23 <nopcode> that don't use the specific nature of the graph
15:52:39 <ptac> thanks Lemmih, the stable version installs fine
15:52:49 <dmwit> Mmm,  yeah, okay.
15:53:44 <nopcode> hm
15:56:20 <nopcode> Graph v = v -> [v]
15:56:23 <nopcode> that didnt seem to parse
15:56:29 <dmwit> type ...
15:56:29 <nopcode> graph.hs:3:12: parse error on input `->'
15:56:39 <dmwit> tyep Graph v = v -> [v]
15:56:40 <nopcode> ah :)
15:56:46 <nopcode> i thought "type" was imperative ;)
15:57:00 <dmwit> Yeah, sorry.
15:57:01 <dmwit> =)
15:57:09 <nopcode> how does that differ from "data"?
15:57:17 <dmwit> No constructor.
15:57:31 <dmwit> So, it's a synonym that doesn't need to be unwrapped.
15:57:32 <sjanssen> nopcode: 'type' just introduces a shorthand for a type
15:57:49 <nopcode> and how do i make use of that if i should chose to use a Map?
15:57:59 <dmwit> If the map is called m,
15:58:14 <dmwit> the function (m !) is of type a -> [a]
15:58:15 <dmwit> .
15:58:18 <dmwit> ...
15:58:24 <slowriot> In yampa, the input sensing function either returns the Just (current input), or Nothing
15:58:25 <dmwit> Assuming m :: Map a [a]
15:58:33 <slowriot> Nothing is a signal for the program to quit
15:58:41 <nopcode> dmwit: and that makes it compatible with Graph a?
15:59:05 <dmwit> nopcode: Right, anything that has type (a -> [a]) is automatically also a (Graph a).
15:59:06 <slowriot> that seems kind of like an abuse of Maybe to me
15:59:29 <mauke> slowriot: how so?
15:59:39 <dmwit> So (m :: Map a [a]) => ((m !) :: a -> [a]) => ((m !) :: Graph a).
16:00:07 <dmwit> nopcode: But on second thought, it probably isn't that great of an idea.
16:00:26 <slowriot> mauke: Well... the input doesn't mean "Nothing". It means "Quit".
16:00:32 <dmwit> Because you don't have a similar mapping from (Graph a) to (Map a [a]), which means that modifying graphs becomes less obvious.
16:01:39 <dmwit> slowriot: So, you would introduce a new type (data Input a = Quit | Input a) and lose all the nice functions that operate on Maybe types?
16:02:12 <nopcode> dmwit: ok so should i define it as "data Graph v = Map v [v]"?
16:02:41 <slowriot> dmwit: I wasn't sure what the correct solution was. But what you just said did occur to me.
16:02:42 <dmwit> nopcode: Sure, though you probably meant "type Graph v = Map v [v]".
16:03:07 <nopcode> well i think i read "data" somewhere ok
16:03:30 <slowriot> I guess Maybe is a correct solution. But referring to "Quit" as "Nothing" doesn't seem to carry the correct semantics.
16:03:54 <slowriot> by "a correct solution," I mean the best one I can think of.
16:04:04 <dmwit> nopcode: You could use data, but it would have to be something like (data Graph v = Graph (Map v [v])) if you wanted to use Data.Map for your Map type.
16:04:24 <dmwit> slowriot: Yeah, I understand.
16:04:55 <slowriot> This is kind of like how I avoid using std::pair in C++. "first" and "second" are rarely ever appropriate names for the fields they refer to.
16:05:07 <dmwit> slowriot: It does kind of hash well with the (>>) meaning of Maybe, though, no?
16:05:17 <dmwit> (Quit >> f) == Quit
16:05:44 <mauke> slowriot: so you don't use tuples in haskell?
16:07:19 <glen_quagmire> :t Quit
16:07:22 <lambdabot> Not in scope: data constructor `Quit'
16:07:41 <slowriot> mauke: I haven't been using haskell very long, but I've used tuples quite a few times. Usually I use pattern matching to handle tuples, though fst and snd are probably often necessary.
16:08:06 <slowriot> dmwit: Yeah, that does make sense.
16:08:11 <dmwit> glen_quagmire: Quit = Nothing
16:09:16 <dmwit> > let m = m in Nothing >> m -- err, actually, did I get that right?
16:09:18 <lambdabot>  Nothing
16:09:23 <dmwit> Phew!
16:09:52 <mauke> > Nothing >> undefined
16:09:54 <treble> But in the case of Maybe, if you sequence a Nothing in, you lose the whole computation
16:09:55 <lambdabot>  Nothing
16:10:10 <treble> so it doesn't do so well as "quit" as "cancel"
16:10:47 <treble> when I way to use that behavior as "quit" I use a MaybeT
16:11:01 <glen_quagmire> > Cin >> Cout
16:11:03 <lambdabot>   Not in scope: data constructor `Cout'
16:11:09 <glen_quagmire> :t Nothing
16:11:11 <lambdabot> forall a. Maybe a
16:11:21 <glen_quagmire> :t >>
16:11:22 <treble> so the the wrapped monad can still accomplish something
16:11:23 <lambdabot> parse error on input `>>'
16:11:31 <treble> :t (>>)
16:11:33 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
16:11:59 <slowriot> okay, back to coding
16:12:16 <glen_quagmire> > 1 >> Nothing
16:12:17 <lambdabot>   add an instance declaration for (Num (Maybe a))
16:12:29 <dmwit> > Just 1 >> Nothing
16:12:31 <lambdabot>  Nothing
16:12:31 <nopcode>     Ambiguous occurrence `filter'
16:12:32 <nopcode>     It could refer to either `filter', imported from Prelude
16:12:32 <nopcode>                           or `filter', imported from Data.Map at graph.hs:1:0-14
16:12:36 <nopcode> what can i do?
16:12:39 <treble> > return 1 >> mzero :: Maybe Int
16:12:43 <lambdabot>  Nothing
16:12:43 <dmwit> There's two choices:
16:12:53 <dmwit> 1. import Data.Map hiding (filter)
16:13:05 <dmwit> 2. import qualified Data.Map as M
16:13:15 * treble prefers the latter
16:13:20 * dmwit too
16:13:26 <nopcode> dmwit: will that second thing import all map-specific functions too?
16:13:31 <treble> but, I always also add: import Data.Map (Map)
16:13:36 <treble> well.. not always :)
16:13:42 <nopcode> treble: what does that do?
16:13:51 <dmwit> nopcode: The first imports all functions except filter.
16:13:51 <treble> imports the Map data type
16:14:03 <dmwit> nopcode: The second imports all functions, but with the M. prefix.
16:14:07 <treble> so you can say: my_function :: Map Int Float -> Magic
16:14:12 <treble> instead of Map.Map
16:14:29 <dmwit> i.e. M.filter would the the one from Data.Map, and filter would be the one from Prelude.
16:14:41 <dmwit> treble: Ooo, good call, I never thought of that.
16:15:19 <dmwit> nopcode: Of course, all functions are always available from their fully-qualified name, so there is a third option.
16:15:22 <treble> and I do "as Map" instead of "M"
16:15:26 <glen_quagmire> > do putStrLn "hola"
16:15:28 <lambdabot>  <IO ()>
16:15:34 <treble> so it gives the impression that the Map in Map and Map.lookup are the same
16:15:38 <dmwit> You can replace the currently offending "filter" with either "Prelude.filter" or "Data.Map.filter", whichever you meant.
16:15:49 <treble> glen_quagmire: also, you don't need "do" when you only have one statement
16:16:31 <glen_quagmire> :t Prelude
16:16:34 <lambdabot> Not in scope: data constructor `Prelude'
16:16:42 <treble> Prelude is a module
16:18:07 <dmwit> > let filter = flip const in (filter even [1..5], Prelude.filter even [1..5])
16:18:11 <lambdabot>  ([1,2,3,4,5],[2,4])
16:20:27 <dmwit> :t ap
16:20:31 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
16:21:07 <dmwit> :t ap :: (a -> b -> r) -> (a -> r) -> (b -> r) -- like this?
16:21:10 <lambdabot>     Couldn't match expected type `a' (a rigid variable)
16:21:10 <lambdabot>            against inferred type `b' (a rigid variable)
16:21:24 <dmwit> oh
16:21:37 <dmwit> :t ap :: (r -> a -> b) -> (r -> a) -> (r -> b)
16:21:39 <lambdabot> (r -> a -> b) -> (r -> a) -> (r -> b) :: forall r a b. (r -> a -> b) -> (r -> a) -> r -> b
16:22:37 <dmwit> :t s x y z = x z (y z)
16:22:39 <lambdabot> parse error on input `='
16:22:48 <dmwit> :t let s x y z = x z (y z) in s
16:22:50 <lambdabot> forall t t1 t2. (t -> t1 -> t2) -> (t -> t1) -> t -> t2
16:23:13 <oerjan> @src (->) ap
16:23:13 <lambdabot> Source not found. Are you on drugs?
16:23:19 <dmwit> So, (s, k, i) = (ap, const, ($)) ?
16:23:37 <dmwit> Oh, no, i = id, I mean.
16:23:44 <oerjan> @pl \s x y z -> x z (y z)
16:23:45 <lambdabot> const ap
16:24:05 <dmwit> hm
16:24:35 <dmwit> ?pl \x y z -> x z (y z) -- this is really s
16:24:35 <lambdabot> ap
16:24:51 <dmwit> Wow, cool!
16:25:14 <oerjan> oops
16:26:20 <dmwit> ...which means ?pl is smarter than me. =/ heh
16:27:57 <ikoniari> Hello.
16:28:36 <dmwit> Hiya ikoniari!
16:29:17 <ikoniari> I found this channel through /list :)
16:29:27 <ikoniari> Never heard about the language before, heh.
16:29:34 <ikoniari> Im on the site reading currently.
16:29:42 <ikoniari> Seems interesting :)
16:29:45 <conal> dmwit: (s,k,i) = (<*>, pure, id)
16:30:11 <dmwit> :t pure
16:30:13 <xho> "We put the funk in funktion" -- lambdabot
16:30:15 <dmwit> Arrows!
16:30:20 <lambdabot>     Ambiguous occurrence `pure'
16:30:20 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
16:30:25 <dmwit> oh
16:30:35 <conal> dmwit: i meant Applicative.pure
16:30:38 <mauke> :t Control.Applicative.pure
16:30:40 <dmwit> :t (Control.Applicative.<*>, Control.Applicative.pure)
16:30:42 <lambdabot> parse error on input `,'
16:30:42 <lambdabot> forall a (f :: * -> *). (Applicative f) => a -> f a
16:30:54 <dmwit> :t (Control.Applicative.<*>)
16:30:56 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => f (a -> b) -> f a -> f b
16:31:00 <mauke> that doesn't look like K
16:31:09 <conal> it's s
16:31:11 <mauke> oh, wait
16:31:46 <dmwit> Time to learn about Control.Applicative. =)
16:32:02 <nopcode> yay, i've implemented depth-first traversal
16:32:29 <dmwit> ?doc Control.Applicative
16:32:29 <lambdabot> Control.Applicative not available
16:32:33 <dmwit> nopcode: Nice!
16:32:44 <nopcode> visitRec g seen node = if elem node seen then [] else [node]:(concatMap (visitRec g (node:seen)) (g Map.! node))
16:32:48 <nopcode> \o/
16:33:12 <nopcode> i think i'm starting to get the hang of this
16:33:47 <conal> dmwit: i don't know of a "gentle intro" for Applicative.  It's like Monad, but weakened (generalized), replacing >>= with ap (i.e., <*>)
16:34:04 <dmwit> conal: I found http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
16:34:06 <lambdabot> http://tinyurl.com/yrwujr
16:35:27 <conal> dmwit: yep.  that's the library doc.  you've discovered one example: s,k.  i've been playing with UIs as another example.  Parsing is another.
16:35:36 <jfredett> the shanks-tonelli algorithm is a bitch...
16:36:13 <Botje> jfredett: so make it *YOUR* bitch
16:36:20 <jfredett> Botje: that is the idea-
16:36:27 <Botje> :)
16:36:32 <jfredett> its just the R' step thats beatin me down
16:36:34 <kfish> in what way is it more generalized?
16:36:50 <Cale> Using Haskell-style indenting for shell-scripts works really well.
16:36:55 <conal> kfish: are you asking about AFs?
16:37:06 <conal> kfish: (applicative functors)
16:37:09 <kfish> yes
16:37:36 <kfish> category theory functors? ...
16:37:46 <conal> kfish: AFs are more general than monads in that every monad is an AF, but not vice versa.
16:38:20 <kfish> ok, monads are elite and awesome, if i write an AF what can i do with it that I can't do with a monad?
16:38:44 <mauke> kfish: nothing
16:38:53 <mauke> all monads are AFs
16:39:00 <kfish> ok, what can I do more easily ...
16:39:05 <mauke> wrong question
16:39:19 <mauke> some things aren't monads
16:40:17 <conal> you can write a library that requires the AF interface instead of Monad.  If you do, then your library will be more generally useful than one that requires a monad.
16:41:04 <glen_quagmire> im a monad
16:41:24 <jfredett> me too!
16:41:39 <conal> just as the monad interface allows functions that work on IO, lists, Maybes, parsers, etc, the AF interface allows function to work for even more (non-monad) types.
16:41:41 <jfredett> my friends call me List
16:41:50 <nominolo> conal: you got mail :)
16:42:11 <nburlett> what's the AF interface?
16:42:15 <conal> nominolo: i sure did
16:42:20 <nominolo> @src Applicative
16:42:20 <lambdabot> class Functor f => Applicative f where
16:42:20 <lambdabot>     pure  :: a -> f a
16:42:20 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
16:42:26 <kfish> nburlett, sequencing but no binding
16:42:27 <conal> nburlett:  http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html
16:42:28 <lambdabot> http://tinyurl.com/yrwujr
16:42:33 <kfish> conal, sweet, got it :-)
16:42:41 <nburlett> ooh, I see.. never heard it called AF
16:42:50 <conal> kfish: :)
16:43:25 <kfish> hmm, i've been wondering what to do with my japanese grammar generator ... it's nice to hide away the transforms, but a monad doesn't feel quite right
16:43:38 <kfish> perhaps that's the way to go
16:44:08 <conal> kfish: could be, but it really depends on why Monad isn't quite working
16:44:23 <oerjan> kfish: also check out arrows
16:44:31 <kfish> oerjan, ok :-)
16:44:52 <jfredett> you know, it never ceases to amaze me the amazingly eclectic (and awesome) things people choose to do with haskell. Japanese Grammar generators, Cop&Robber AI, Window Managers, CAS's...
16:44:55 <jfredett> its just crazy
16:44:59 <nburlett> so, is Yi still being developed? I tried building the version in darcs on my Mac, but it hates me
16:45:01 <kfish> phew, and I thought I'd have nothing to do today :-)
16:45:19 <kfish> jfredett, it's awesome, when you join clauses together, each clause transforms in a subtle way
16:45:31 <jfredett> nburlett: thats okay, Yi doesnt build for me either
16:45:35 <conal> kfish: See Phooey (http://www.haskell.org/haskellwiki/Phooey) for closely related examples of monad, arrow, and AF.
16:45:36 <lambdabot> Title: Phooey - HaskellWiki
16:45:45 <kfish> and there is a general level of politeness / humility that underpins each sentence
16:45:52 <jfredett> thats cool
16:46:48 <jfredett> i dont know much about Japanese, my period of obsession with linguistics was more about phonetics than actually language, but that sounds pretty awesome
16:47:11 <augustss> hi conal!
16:47:36 <conal> hi lennart!
16:47:42 <nominolo> conal: do you have a gtk-version of phooey?  wxWindows is really buggy on macos and it also deadlocks in most examples
16:48:02 <nominolo> (i mean wxHaskell)
16:48:06 <conal> nominolo: sadly, no.  in theory it should be very simple to do.
16:48:18 <conal> augustss: i'm reading your djinn reply
16:48:20 <augustss> conal: sorry, djinn can't generate the answer you want for that function
16:49:17 <conal> augustss: oh well.  it works nicely for other examples.
16:49:31 <augustss> luck :)
16:49:43 <conal> :)
16:50:53 <nominolo> nburlett: i can't run yi
16:51:09 <nominolo> either
16:52:25 <jfoutz> if i have a data delcaration like : data Foo m = F m Int, is there some syntax for constraining m? I'd like it to be Show-able, and Eq-able.
16:52:56 <jfoutz> data (Show m, Eq m) => Foo m = F m Int dosn't seem to work.
16:52:56 <oerjan> data (Show m, Eq m) => Foo m = ...
16:53:03 <jfoutz> heh
16:53:08 <sorear> it's usually a bad idea to do that
16:53:16 <oerjan> it doesn't?
16:53:19 <augustss> That's mostly useless syntax
16:53:25 <sorear> much better to put the constraints in the functions that use it
16:53:30 <sorear> @src Map
16:53:30 <lambdabot> Source not found. stty: unknown mode: doofus
16:53:31 <oerjan> @src Complex
16:53:31 <lambdabot> data (RealFloat a) => Complex a = !a :+ !a
16:53:49 <sorear> yeah, H98 has bad haskell style in places :)
16:54:24 <Cale> jfoutz: That only means what you want it to mean in GHC HEAD, and only when using the GADT syntax.
16:54:27 <jfoutz> hmm... i lied. it works for the Foo example.
16:54:30 <Cale> (It's really unfortunate)
16:55:02 <Cale> Putting the conditions there will constrain what the constructor can be applied to, but that's all.
16:55:15 <jfoutz> ohhhh.... i see.
16:55:22 <Cale> You'll still have to add appropriate typeclass constraints to all functions using the datatype.
16:55:27 <jfoutz> i still need to instance my datatype in show and eq.
16:55:49 <jfoutz> i was trying to cheat. hoping deriving would work.
16:56:03 <Cale> oh, it will
16:56:06 <dmwit> it should
16:56:17 <Cale> data Foo a = Foo a Int deriving (Show, Eq)
16:56:34 <augustss> yeah, that works fine
16:56:49 <augustss> deriving is pretty clever
16:57:30 <jfoutz> F[1]   No instance for (Show (Int -> Foo [t]))
16:57:35 <jfoutz> (interactive)
16:58:20 <oerjan> jfoutz: you cannot partially apply it and expect Show
16:58:27 <SamB> okay, not quite that clever...
16:58:39 <jfoutz> partialy apply?
16:58:41 <jfoutz> what?
16:58:51 <greenrd> I am using fixIO (i.e. mfix for IO) and I am getting <<loop>> - how can I find out why?
16:59:04 <oerjan> it looks like you are trying to show (Foo x)
16:59:12 <oerjan> where x is some list
16:59:21 <oerjan> but you need to add the Int too
16:59:25 <SamB> jfoutz: did you want data Foo a = Foo (a Int) ?
16:59:33 <nominolo> greenrd: did you maybe forget to use lazy pattern matching?
16:59:57 <jfoutz> why wouldnt the m be  of type list?
17:00:03 <jfoutz> F Just 1
17:00:12 <greenrd> nominolo: I pretty much don't do any pattern matching on the relevant input, I think
17:00:20 <oerjan> i mean F x
17:00:57 <SamB> jfoutz: did you want data Foo a = F (a Int), then??
17:01:06 <dmwit> jfoutz: That parses as (F Just) 1, yeah?
17:01:43 <jfoutz> hmm. my gears are spinning... sorry...
17:02:04 <nominolo> well, maybe you can try the ghci debugger in ghc head.  otherwise, maybe paste the code?
17:02:10 <oerjan> jfoutz: anyway, something is being applied to the wrong number of arguments
17:02:24 <greenrd> nominolo: never mind, I figured it out - it's obvious really
17:02:24 <oerjan> as defined, F takes two
17:02:33 <jfoutz> i would like a datatype, inside the data type i'd like a monad of Int
17:02:41 <jfoutz> and i don't know how to say that
17:02:42 <greenrd> I used lookup and then used maybe to deconstruct the value of lookup
17:02:57 <greenrd> but wait
17:03:15 <dmwit> jfoutz: Pay attention to SamB, he's a smart cookie. ;-)
17:03:23 <allbery_b> data Monad m => Foo m = Foo (m Int) -- ?
17:03:41 <greenrd> why was that demanded?
17:03:44 <SamB> allbery_b: nooooo don't put that context there
17:03:47 <allbery_b> ok
17:03:59 <SamB> it may parse, but it does not do anything useful
17:04:11 <allbery_b> yeh, I'm never quite sure about how haskell treatrs contexts in declarations
17:04:33 <allbery_b> but it does at least act as documentation that you intend a monad, them?
17:04:36 <allbery_b> er, then
17:05:00 <jfoutz> I think SamB is right, i did mean F (m Int)... i'm not sure that did what i expected.
17:05:15 <SamB> allbery_b: it does that, and constrains arguments... but it doesn't let you use Monad methods on things you unpack from it...
17:05:55 <allbery_b> yeh, I understand that
17:06:18 <jfoutz> yeah. hmm. data Foo m = F (m Int) deriving (Eq, Show), has problems with showing m
17:07:02 <jfoutz> but, adding the data (Show m) => F (m Int) deriving (Eq,Show) says m is applied to tto many type arguements...
17:07:12 * SamB wonders why all these Grin modules are being rebuilt based on the changes he made...
17:07:24 <oerjan> right, a monad cannot be Show, it has the wrong kind.
17:08:23 <oerjan> you want Show (m Int) but I am not sure that is possible
17:08:27 <SamB> jfoutz: leave out the (Show m) =>
17:09:01 <oerjan> there is no context on m alone that can give Show (m Int)
17:09:12 <jfoutz> i get Type found where type variable expected
17:09:20 <jfoutz> weather i include it or not.
17:09:45 <jfoutz> or even (Show (m Int)) =>
17:09:47 <oerjan> er, you have forgot the Foo m part
17:10:46 <jfoutz> er, heh, oops.
17:11:16 <oerjan> i don't think what you want can be done in mere Haskell 98.  I don't know about extensions.
17:11:42 <jfoutz> no, that's fine. i can add the instances. i was just trying to get the hand of the bindings
17:12:08 <jfoutz> i'm still sorta hazy on type constraints (obviously)
17:12:21 <oerjan> The problem is that Haskell 98 demands some context using m alone that implies Show (m Int)
17:12:25 <oerjan> i think.
17:12:44 <jfoutz> thanks so much for the help. the F (m Int) was exactly the observation i needed.
17:13:10 <jfoutz> i can deal with the not deriving.
17:14:16 <SamB> hmm. I should have liked to warn him that I think he'd get that error anyway...
17:15:27 <Cale> er, for lots of monads, you can get  (Show a) => Show (m a)
17:23:41 <oerjan> does the general instance Show (m Int) => Show (Foo m) work with undecidable instances?
17:30:14 <oerjan> anyway, good night.
17:30:17 <greenrd> I am trying to compile my project using -prof, following the instructions at http://www.haskell.org/ghc/dist/current/docs/users_guide/template-haskell.html#id410569
17:30:19 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/yrpq2p
17:30:33 <greenrd> however, I get the following error
17:30:55 <greenrd>     Bad interface file: build/Data/Pair.hi
17:30:55 <greenrd> 	mismatched interface file ways: expected , found p
17:31:55 <greenrd> it seems that the recommended procedure only outputs separate .o files, not separate .hi files
17:32:07 <greenrd> so it looks like it can't work with Makefile-based builds
17:33:43 <greenrd> or maybe I just have to be a bit smarter...
17:37:37 <greenrd> ah, there we are - just need to use -hisuf as well, I think
17:39:55 <greenrd> cool, it works
18:03:03 <greenrd> OK, to try and find out where my <<loop>> was coming from, I compiled my project with profiling, but the output isn't very useful
18:03:49 <greenrd> it ends with <SandrH.processFile,SandrH.pluggableMain,Main.main,SandrH.CAF><System.IO.CAF>SandrH: <<loop>>
18:05:21 <greenrd> so I guess I need to use the ghci debugger
18:36:58 * SamB tries adding foreign import ccall "dynamic" to JHC
18:40:26 <SamB> there, er, happens to be a specific JHC primitive that I'll need to add support for at least in the C-printing code...
18:42:05 <kfish> is there a debian package or task which installs all libghc6-*-dev packages?
18:42:22 <dons> http://programming.reddit.com/info/22hwe/details
18:42:23 <lambdabot> Title: Everyone Else is Crazy: Constructability, Uncountability, and Ï-Haskell (reddit ...
18:42:49 <SamB> but I won't be able to do that until I see the error ...
18:43:01 * SamB wonders what this signifies
18:43:11 <SamB> ââ´Barendregt: 7
18:43:27 <SamB> besides the fact that unicode SUCKS...
18:45:40 <kfish> dons, interesting
18:46:01 * kfish once explained countability to a girlfriend by diagonalising an infinite chocolate box
18:46:12 <SamB> heh
18:46:19 <SamB> that works
18:46:48 <SamB> as long as you have a finite set of types of chocolates...
18:47:21 <kfish> yeah, i usually check that at the store first ;-)
18:47:29 <sjanssen> @keal
18:47:29 <lambdabot> i just got banned from math because i not have good ability to convey thoughts
18:54:27 <fnord123> Is it trendy to hate unicode again?
18:55:07 <sorear> SamB: first, jhc uses unicode for outline structure, nothing more significant.
18:55:14 <sorear> in ASCII art that symbol is
18:55:16 <sorear>   |
18:55:17 <sorear>   |
18:55:19 <sorear>   +---
18:55:20 <sorear>   |
18:55:21 <sorear>   |
18:55:24 <dons> ok.
18:55:32 <dons> let's bring back @moo!
18:55:54 <jfredett> dons, I agree. though  I have no idea what @moo is
18:55:58 <fnord123> sarahbot: yow!
18:56:02 <SamB> sorear: I know
18:56:12 <jfredett> @yow !
18:56:13 <lambdabot> Quick, sing me the BUDAPEST NATIONAL ANTHEM!!
18:56:21 <jfredett> i dont know that one, lambda
18:56:22 <sorear> SamB: secondly, Henk Barendregt.  inventor of of the lambda-cube type system used by jhc
18:56:29 <jfredett> but I know the khazakstan one.
18:56:30 <SamB> sorear: you don't experience the problem I'm bitching about, due to using a character matrix display almost exclusively
18:56:49 <jfredett> "... is the greatest, exporter of potassium...
18:56:57 <SamB> but in my IRC client the line drawing characters don't line up correctly because they are drawn from different fotns
18:56:58 <SamB> er.
18:56:59 <SamB> fonts
18:57:01 <syntaxfree> potassium?
18:57:04 <syntaxfree> @quote potassium
18:57:05 <lambdabot> No quotes match. It can only be attributed to human error.
18:57:11 <sorear> SamB: your *irc* client.
18:57:15 <jfredett> Borat.
18:57:19 <syntaxfree> I have to download Borat.
18:57:28 <jfredett> :) yay for piracy!
18:57:38 <syntaxfree> I wish I had it right now.
18:57:41 <jfredett> it was funny as hell. Sick, Demented, and left me stupider for watching it
18:57:44 <jfredett> but funny as hell
18:57:45 <syntaxfree> I need some comedy.
18:58:01 <dons> jfredett: :-)
18:58:03 <dons>     -        [["         (__)",
18:58:03 <dons>     -          "         (oo)",
18:58:03 <dons>     -          "  /-------\\/",
18:58:03 <dons>     -          " / |     ||",
18:58:03 <syntaxfree> jfredett: I'm taking drugs that make me stupider, but I feel better.
18:58:05 <dons>     -          "*  ||----||",
18:58:08 <dons>     -          "   ~~    ~~",
18:58:09 <SamB> sorear: it looks fine in uxterm though
18:58:11 <dons> that's @moo
18:58:20 <jfredett> kickass, Moo!
18:58:27 <SamB> I just wish unicode had enough semantics to make things behave
19:00:02 <SamB> I also wonder what I need to add to fix:
19:00:05 <SamB> analyze: (ELam (146::ELit (Jhc.Prim.World__::ESort #)) (ECase {eCaseScrutinee = EVar (518::E
19:00:06 <SamB> Lit (Jhc.Prim.World__::ESort #)), eCaseType = ELit ((#2#) (ELit (Jhc.Prim.World__::ESort #))
19:00:06 <SamB>  (ELit (Jhc.Basics.()::ESort *))::ESort #), eCaseBind = 524::ELit (Jhc.Addr.FunAddr::ESort *
19:00:06 <SamB> ), eCaseAlts = [FunAddr# (526::ELit (bits<ptr>::ESort #))::ELit (Jhc.Addr.FunAddr::ESort *)
19:00:06 <SamB> -> ELetRec {eDefs = [(530::ELit (Jhc.Addr.FunAddr::ESort *),ELit (FunAddr# (EVar (400::ELit
19:00:06 <SamB> (bits<ptr>::ESort #)))::ELit (Jhc.Addr.FunAddr::ESort *)))], eBody = ECase {eCaseScrutinee =
19:00:09 <SamB>  EPrim (IFunc {funcIOLike = True, primArgTypes = ["HsFunPtr"], primRetType = "void"}) [EVar
19:00:11 <SamB> (530::ELit (Jhc.Addr.FunAddr::ESort *)),EVar (146::ELit (Jhc.Prim.World__::ESort #)),EVar (5
19:00:13 <SamB> 26::ELit (bits<ptr>::ESort #))] (ELit (Jhc.Prim.World__::ESort #)), eCaseType = ELit ((#2#)
19:00:14 <SamB> (ELit (Jhc.Prim.World__::ESort #)) (ELit (Jhc.Basics.()::ESort *))::ESort #), eCaseBind = 53
19:00:20 <SamB> 2::ELit (Jhc.Prim.World__::ESort #), eCaseAlts = [], eCaseDefault = Just (ELit ((#2#) (EVar
19:00:22 <SamB> (532::ELit (Jhc.Prim.World__::ESort #))) (ELit (Jhc.Basics.()::ELit (Jhc.Basics.()::ESort *)
19:00:27 <SamB> ))::ELit ((#2#) (ELit (Jhc.Prim.World__::ESort #)) (ELit (Jhc.Basics.()::ESort *))::ESort #)
19:00:29 <SamB> )), eCaseAllFV = [x146,x526,x530]}}], eCaseDefault = Nothing, eCaseAllFV = [x146,x400,x518]}
19:00:29 <jfredett> aahh!
19:00:33 <SamB> ),S(LA))
19:00:35 <SamB> hmm.
19:00:36 * jfredett hides
19:00:37 <SamB> arg.
19:00:39 <SamB> stupid wrapping
19:00:41 * SamB forgot about that
19:01:11 <Saizan> what's that? a wall of obfuscation?
19:01:11 <SamB> wow, what do you know
19:01:23 <SamB> I seem to have picked a nice font for emacs
19:01:42 <jfredett> emacs. pleh, it makes my wrists hurt.
19:02:42 <SamB> http://hpaste.org/1471
19:02:58 <SamB> what's with our bots?
19:03:09 <Saizan> which was that program to change which char a key on your keyboard correspond to? xmodmap?
19:03:20 <dons> yep
19:03:21 <Saizan> ?seen hpaste
19:03:22 <lambdabot> I saw hpaste leaving #haskell 6h 37m 39s ago, and .
19:03:26 <jfredett> vicious...
19:05:14 <greenrd> great, now I've tried the ghci debugger to debug my <<loop>>, and I get no history whatsoever
19:05:34 <greenrd> I only get a history for an exception in an unrelated part of the code
19:05:52 <sorear> @seen mnislaih
19:05:52 <lambdabot> I saw mnislaih leaving #haskell and #ghc 3h 29m 3s ago, and .
19:06:08 <jfredett> greenrd: this is why you should just never write bugs.
19:06:12 <greenrd> haha
19:06:15 <greenrd> thanks, jfredett
19:06:17 <jfredett> solves the problem of debugging in O(1)
19:06:20 <greenrd> I'll bear that in mind
19:06:28 <jfredett> i help where i can
19:06:31 <greenrd> now, I've had enough - off to bed
19:06:45 <jfredett> sounds like a plan, good luck debugging tomorrow, greenrd
19:07:43 <dons> @seen glguy
19:07:43 <lambdabot> I saw glguy leaving #haskell 1d 17h 59m 29s ago, and .
19:08:31 <dons> ?uesrs
19:08:31 <lambdabot> Maximum users seen in #haskell: 354, currently: 296 (83.6%), active: 11 (3.7%)
19:08:54 <jfredett> lol, good times, 11 people active
19:09:21 <ont> Professional idling takes a lot of time to master.
19:09:29 <jfredett> true that
19:09:39 <jfredett> bah, I need something to do
19:09:50 <jfredett> <insert whining here>
19:10:29 <SamB> jfredett: tell me how to fix that error shown in my paste ;-)
19:10:37 <jfredett> lol
19:10:52 <jfredett> I -- uhh...
19:10:52 <ont> There's an entire universe full of things to do.
19:10:55 * jfredett hides
19:11:22 <dolio> SamB: That's an error?
19:11:41 <jfredett> ont, the problem is, the boredom in me is screaming "DO SOMETHING"
19:11:42 <jfredett> and the lazy ass in me is saying "no"
19:11:47 <dolio> How can you tell?
19:13:04 <SamB> dolio: because (a) I was expecting an error and (b) JHC stopped
19:13:07 <nopcode> hm
19:13:16 <dolio> Ah. :)
19:13:32 <nopcode> what are the main consequences of haskell's lazy evaluation in terms of program design?
19:13:55 <nopcode> i mean, what makes it radically different from lisp?
19:14:10 <mgsloan> heh, two very different questions
19:14:14 <sorear> dons: "trebla"
19:14:28 <nopcode> mgsloan: the first one, then
19:14:49 <jfredett> well, yes, it does change the way you code alot,
19:14:51 * SamB waits for someone to point out that they aren't so different
19:14:55 <jfredett> if thats what you mean
19:14:57 <mgsloan> good. I don't know lisp very well.  You code more declaratively
19:15:03 <nopcode> jfredett: yeah, in what way?
19:15:04 <dolio> nopcode: It makes it easy to design algorithms in a certain way.
19:15:22 <sorear> nopcode: Laziness means that we just don't write iterators.
19:15:32 <SamB> E is a funny language
19:15:41 <mgsloan> with laziness you don't have to try as hard to make your algorithms efficient
19:15:42 <dolio> nopcode: For instance, if you're solving chess, you could make an infinite tree of all moves, and then have a separate function that searches a tree to a given depth.
19:15:43 <sorear> nopcode: We write generators only, and let laziness worry about sequencing.
19:15:53 <nopcode> sorear: but pass (possibly infinite) sequences instead?
19:15:59 <sorear> yes
19:16:05 <nopcode> ahh, i see
19:16:11 <dolio> So you can separate the move generation from the search code.
19:16:16 <mgsloan> or even definitely infinite sequences
19:16:20 <dolio> Which can make things cleaner.
19:16:30 <jfredett> lazyness allows you to stop thinking about the limits of your program. In lisp, I constantly have to think about top values and accumulators and all sorts of nasty things
19:16:38 <mgsloan> of course, there's more to laziness than lists
19:16:42 <nopcode> so it's basically... a kind of stream-model?
19:16:43 <jfredett> for instance, in lisp, if i wanted a list of all factorial numbers
19:17:20 <mgsloan> nopcode - it allows something like streams, but its more - it applies to all data
19:17:35 <jfredett> i would have to force some limit on how many enter the list.
19:17:49 <sorear> nopcode: Also, laziness acts as a guaranteed form of loop fusion; so we can write our algorithms in as many passes as we please - without dramatically increasing memory use.
19:18:18 <jfredett> in haskell, that limit isn't imposed. The idea i guess is you spend less time trying to confine your code to work in some limit memory space, or w/e
19:18:31 <jfredett> and more time trying to find new ways to abuse lazyness
19:18:37 <nopcode> :)
19:18:51 <sorear> nopcode: Making passes free also dramatically improves your willingness to build programs by composition.
19:19:10 <sorear> compiler = codeGen . optimize . desugar . typeCheck . parse
19:19:19 <mgsloan> yep
19:19:21 <nopcode> hehe
19:19:38 <sorear> in a strict language, you'd be strongly tempted to combine those passes yourself.
19:19:40 <jfredett> lispEvaluator = (print . eval . read)
19:19:40 <jfredett> :)
19:19:43 <nopcode> that sounds alot like the unix paradigm
19:20:00 <jfredett> precisely, nopcode
19:20:01 <sorear> nopcode: Indeed.  UNIX pipes act as a form of lazy evaluation
19:20:21 <nopcode> hmm true... they're only evaluated when the right side pulls data...
19:20:23 <mgsloan> well, the pipe one.  Still, I'd like to stress that its more than just linear data
19:20:23 <nopcode> :))
19:20:28 <sorear> nopcode: because the producer generates at most 4k more data than the consumer demands...
19:20:51 <jfredett> mgsloan all data is linear, if you squish it enough.
19:21:07 <mgsloan> true
19:21:12 <SamB> in Haskell, you'd be a lot less tempted, because you'd just *know* it would become a nightmare if you did that...
19:21:32 <mgsloan> but in the unix pipes, you have to read all the data, you can't skip around
19:21:35 <SamB> combined your passes...
19:21:43 <SamB> of course, you'd be writing a compiler ;-)
19:21:53 <dons> yes, fusion really makes sense for strict, pure structures. but there aren't many of those. and there's not a lot of strict pure languages
19:22:16 <sorear> parsing haskell is nightmare enough without trying to type check it at the same time!
19:22:19 <SamB> dons: what about Ints and Words and so on?
19:22:23 <dons> lazy pure languages have lazy lists for glue, which don't make huge wins when compositon fuses.
19:22:37 <dons> SamB: don't cost very much.
19:23:05 <SamB> they cost less when they fuse ;-)
19:23:30 <sorear> SamB: Int is also a non-recursive product type
19:23:58 <sorear> and the optimizer is already smart enough to deforest those...
19:24:31 <mgsloan> one prob with laziness is it introduces some funkinesses, eg, &&/|| aren't symmetric.  Actually, I suppose that's not that bad.  They aren't symmetric in most languages that short circuit
19:24:35 <jfredett> nopcode: this is why lazy eval changes how you code:
19:24:35 <jfredett> > let fibs = 0 : 1 : (zipWith (+) fibs (tail fibs)) in (take 10 fibs)
19:24:38 <lambdabot>  [0,1,1,2,3,5,8,13,21,34]
19:24:55 <nopcode> jfredett: yeah i've seen that :D
19:25:01 <jfredett> the take 10 on there just reigns in the code, fibs is actually infinite
19:25:01 <sorear> In UNIX, you do fibs | head -n 10
19:25:01 <jfredett> :)
19:25:15 <SamB> mgsloan: yeah. I like how it works in Haskell better, because it is 100% specialnes-free
19:25:20 <nopcode> jfredett: but i dont see yet how it generalizes to other problems
19:25:27 * sorear will be very interested to see how much faster GHC gets when Neil's generic defunctionalization algorithm is integrated
19:25:41 <syntaxfree> in soviet russia, fibs | head -n 10 does YOU.
19:25:43 <jfredett> well- hmm- let me see if i can dig up a good example
19:25:46 <mgsloan> SamB - that's certainly true, but still, I'd like it if a || b == b || a
19:25:52 <dolio> Whyfp has examples, doesn't it?
19:25:56 <jfredett> I've got a bunch of Project Euler problems around
19:26:13 <dolio> @where whyfp
19:26:14 <lambdabot> http://www.math.chalmers.se/~rjmh/Papers/whyfp.html
19:27:12 <nopcode> hm
19:27:41 <dolio> Newton-Raphson square roots seems to be one.
19:27:50 <nopcode> does fp really scale well to large systems?
19:27:58 <nopcode> i thought that was the job of oop ^^
19:28:09 <jfredett> Well, theres always Xmonad, I'd call that a large system
19:28:25 <dolio> Heh, it isn't that large, though.
19:28:27 <jfredett> if you think ~500 lines of code for a WM large.
19:28:30 <dolio> What is it, 500 lines?
19:28:32 <dons> all the basics of fp: control of side effects, state, encapsulation, strong typing, pure interfaces, are the essence of reusable, stable large systems.
19:28:38 <syntaxfree> in soviet russia, xmonad calls YOU a large system.
19:28:38 <mgsloan> bah, that's not large
19:29:00 <SamB> mgsloan: perhaps the only reason it's not large iss FP?
19:29:01 <jfredett> syntaxfree: damn right, I got my Large System right here.... Ladies....
19:29:12 <mgsloan> SamB - quite likely :)
19:29:14 <dons> OO is one way, emphasising encapsulation
19:29:16 <nuncanada> Xmonad is relatively small in terms of code isnt it?
19:29:20 <dons> but missing out on purity and other things.
19:29:22 <nopcode> dons: "encapsulation"?
19:29:23 <dons> xmonad is a tiny project
19:29:36 <mgsloan> yeah, it's a project where one of the main goals is tiny
19:29:39 <nuncanada> fp does scale to large projects, just look at Erlang
19:29:41 <SamB> encapsulation works better in FP anyways
19:29:44 <dons> nopcode: preventing details leaking across interfaces, whther state, implementation, other side channels
19:29:45 <nuncanada> you dont get bigger than that
19:29:50 <augustss_> tiny projects are the best.  if they do the job :)
19:29:56 <syntaxfree> we are better at theory. let's face it.
19:29:57 <nopcode> dons: yeah i was just wondering what FP language provides that
19:30:16 <nopcode> dons: i always have a feeling writing large software in FP would be namespace pollution hell
19:30:17 <SamB> nopcode: haskell does
19:30:25 <SamB> we have this thing called "newtype"
19:30:37 <mgsloan> nopcode: we've got namespaces - modules, actually
19:30:45 <augustss_> nopcode: Haskell has qualified names
19:30:46 <mgsloan> they work quite nicely
19:30:55 <SamB> and also this thing sometimes called "exporting abstractly"
19:31:05 <syntaxfree> if we try and understand why we haven't gone out in large-scale projects yet while we're better at theory and in theory, we'll be able to go higher and further.
19:31:07 <nopcode> yeah i guess objects wouldnt make sense because theres no state ;)
19:31:07 <dons> qualified names, controlled exports, abstract data types, existential types. all the hiding you could want.
19:31:19 <jfredett> nopcode: really, the only way to see if Haskell will do what you want is to take the Red pill and learn it. Haskell is remarkably expansive.
19:31:40 <jfredett> trying to say "Haskell can do this" doesn't do Haskell justice
19:31:47 <SamB> unfortunately we are all out of blue pills
19:31:53 <nopcode> jfredett: scalability doesn't matter much to me, for now i see haskell as a possible tool in my toolbox, for prototyping / testing algorithms maybe
19:31:57 <augustss_> nopcode: there is state, if you really need it
19:32:06 <syntaxfree> C64 assembler can do anything Java can.
19:32:11 <jfredett> nopcode: thats more or less what I'm using it for
19:32:18 <jfredett> and its worked out quite well
19:32:28 <SamB> syntaxfree: can I load a 65k file?
19:32:44 <nopcode> SamB: what about the framebuffer? ;)
19:32:55 <SamB> nopcode: that's in RAM too
19:33:00 <augustss_> SamB: you need the infinite tape drive addon
19:33:00 <nopcode> damn :)
19:33:36 <syntaxfree> SamB: I said C64 assembler, not a physical Commodore 64.
19:33:46 <jfredett> modulo the few sessions of head-against-wall fighting a battle w/ the type checker
19:33:46 <jfredett> only to realize it was right.
19:33:49 <nopcode> jfredett: i've got python, c++, asm, and a little bit of bash... i still need something very-highlevel *g*
19:34:09 <ed1t> is there support for mysql?
19:34:17 <nopcode> i used to do common lisp for a while until i found out it wasn't fit for real-life (I/O...)
19:34:36 <Saizan> ed1t: yes, see HDBC or HSQL on hackage.haskell.org
19:34:41 <SamB> syntaxfree: are you implying that it would be c74 assembler if you assembled it to an ISA with a larger address space?
19:34:52 <SamB> s/7/6/
19:34:55 <jfredett> nopcode: I've got Java, Lisp/Scheme, A little C/C++, some ASM, a little Python, some Javascript/HTML/XML/..., a little SML here, some random esoteric languages there
19:35:02 <araujo> nopcode, ADTs are as good or probably better ways of encapsulating code than a general conception of an object through class structures that offer many of the OOP languages.
19:35:09 <jfredett> and about 3 or 4 other languages I more or less ignore now.
19:35:15 <jfredett> Haskell is the awesomest.
19:35:19 <jfredett> :)
19:35:25 <Saizan> ed1t: HSQL spports it directly, HDBC through ODBC
19:35:27 <nopcode> araujo: ADTs? :)
19:35:39 <jfredett> Algebraic Data Types, I think...
19:35:41 <araujo> nopcode, Algebraic Data Types
19:35:45 <dons> ed1t: check hackage.haskell.org under the database category
19:35:51 <ed1t> thx
19:36:23 <Cale> jfredett: It's rather humbling to fight with the typechecker a while only to find out that it's found a serious bug in the way you were thinking about your algorithm :)
19:36:26 <nopcode> jfredett: uh, whats SML? =)
19:36:37 <jfredett> Standard ML.
19:36:45 <jfredett> @google ML wikipedia
19:36:48 <lambdabot> http://en.wikipedia.org/wiki/ML
19:36:48 <lambdabot> Title: ML - Wikipedia, the free encyclopedia
19:36:57 <dons> precursor to haskell ;)
19:37:02 <jfredett> its similar to Haskell in syntax
19:37:07 <jfredett> but less cool overall
19:37:10 <jfredett> and its strict
19:37:11 <Cale> @wikipedia ML (programming language)
19:37:13 <lambdabot> No Result Found.
19:37:16 <Cale> hm
19:37:18 <Cale> @google wikipedia ML (programming language)
19:37:20 <lambdabot> http://en.wikipedia.org/wiki/ML_programming_language
19:37:20 <lambdabot> Title: ML (programming language) - Wikipedia, the free encyclopedia
19:37:31 <sorear> Cale: @wikipedia is completely broken
19:37:31 <Cale> heh
19:37:32 <jfredett> i only dabbled in it a little
19:37:35 <sorear> SamB: clue?
19:37:42 <jfredett> wrote a simple unit tester in it
19:37:47 <jfredett> then jumped over to Haskell
19:37:50 <nopcode> ah.. the students that came after us at university are doing ocaml
19:37:54 <ed1t> how do i install cabal packages?
19:37:59 <jfredett> ocaml makes my brain hurt
19:38:01 <SamB> sorear: it's been broken almost as long as it has existed, iirc
19:38:06 <jfredett> to many ;'s at the end of lines.
19:38:17 <SamB> I think blackdog made it
19:38:22 <mauke> ; is >>
19:38:24 <jfredett> and object orientatedness should not be found in functional code. ever.
19:38:29 <nopcode> jfredett: on the other hand many people get mad when they hear about indentation scoping
19:38:43 <nopcode> which i don't understand
19:38:43 <jfredett> nopcode: well, if you don't mind python, Haskell shouldn't be that bad
19:38:48 <jfredett> it makes alot of sense
19:38:49 <SamB> I merged it and @google into the search module because it was just a rape&paste job on my @google
19:38:50 <sorear> those people are *clearly* idiots :)
19:38:53 <jfredett> and makes things readable
19:38:53 <dons> it used to work with an old versoin of mediawiki
19:38:54 <nopcode> sorear: yup
19:38:57 <dons> but the search has changed since then
19:39:08 <dons> best to use one of the well known wikipedia interface libs i guess
19:39:18 <Cale> Haskell's way of doing indentation-sensitivity makes more sense than Python's even.
19:39:21 <nopcode> i mean like haven't they found emacs yet or what
19:39:27 <SamB> Cale: yes
19:39:37 <Cale> You can make things indentation-insensitive if you want them to be.
19:39:39 <SamB> I was just saying that the other day when I tried to write some python
19:39:55 <Cale> Which is always nice when you're learning and don't want to fight with the parser :)
19:40:01 <SamB> I was thinking more of how we handle statement termination, actually ;-)
19:40:04 <jfredett> heh- all you guys should need to do is make
19:40:04 <jfredett>  @wikipedia searchtext = "@google wikipedia " ++ searchtext
19:40:08 <Cale> That too.
19:40:08 <jfredett> that should work. :P
19:40:21 <Cale> site:wikipedia.org
19:40:30 <SamB> having to put an operator or \ at the end of a line is not nice
19:40:30 <bluestorm> jfredett: actually ';;' aren't required in real ocaml code
19:40:46 <jfredett> bluestorm: yah- but the fact that someday I _might_ have to put them there
19:40:51 <jfredett> make me sad.
19:40:54 <mauke> bluestorm: yeah, but that hack is insane
19:40:57 <SamB> I never understood why ML reverses the roles of : and ::
19:41:13 <dons> history.
19:41:20 <augustss_> It's Haskell that has them reversed
19:41:25 <SamB> (yes that was tongue-in-cheek)
19:41:25 <dons> G |- a : tau
19:41:30 <araujo> ocaml is not that bad.. i mean, there are many worse things out there ... but it really has kind of a weird syntax
19:41:31 <SamB> (I realize Haskell came later ;-)
19:41:37 <bluestorm> jfredett: you may be interested in http://people.csail.mit.edu/mikelin/ocaml+twt/
19:41:40 <lambdabot> Title: "The Whitespace Thing" for OCaml
19:41:42 <nopcode> what would as arguments for a generic backtracking algorithm? start node, expansion function, maybe cost function and a predicate that says if a node is a target node?
19:41:50 <nopcode> s/would/would i need/
19:41:51 <SamB> "the whitespace thing"?
19:42:04 <SamB> oh, btw, why doesn't the report call it "the layout rule"?
19:42:25 <sorear> nopcode: just decompose it.
19:42:33 <sorear> nopcode: backtracking is DFS
19:42:40 <nopcode> DFS?
19:42:49 <SamB> we have a generic backtracking algorithm
19:42:50 <nopcode> ah
19:42:53 <nopcode> depth first search
19:42:54 <SamB> it's called Monad []
19:42:54 <nopcode> right
19:42:57 <sorear> nopcode: so build a search tree using the start node and expancsion function (this is called an unfold)
19:43:27 <sorear> nopcode: then search the tree using a fold, with [] for backtracking
19:43:39 <sorear> hmm.  hylomorphism!
19:43:55 <jfredett> high-low-morphism? What?
19:43:58 <nopcode> uhh
19:44:01 <nopcode> sorear: why a fold?
19:44:02 <jfredett> @google wikipedia hylomorphism
19:44:04 <lambdabot> http://en.wikipedia.org/wiki/Hylomorphism
19:44:04 <lambdabot> Title: Hylomorphism - Wikipedia, the free encyclopedia
19:44:17 <nopcode> i would only need a fold if i need to accumulate state on my way down right?
19:44:28 <sorear> @google bananas lenses and barbed wire
19:44:31 <lambdabot> http://citeseer.ist.psu.edu/meijer91functional.html
19:44:31 <lambdabot> Title: Functional Programming with Bananas, Lenses, Envelopes and Barbed Wire (Research ...
19:44:41 <jfredett> ahh- i see
19:44:57 <jfredett> htlomorphism == build 'em up, tear 'em down.
19:45:03 <nopcode> but hey yeah thats kind of the insight i was asking for
19:45:08 <jfredett> s/htlomorphism/hylomorphism
19:45:36 <nopcode> but... why a fold?
19:45:59 <nopcode> isn't all thats needed to continue backtracking contained in the current node?
19:46:05 <sorear> chessguy: nopcode here is asking about lazy evaluation and whatnot.  could GPLib be a useful example?
19:46:10 <nopcode> ehrm, continue the search
19:46:21 <chessguy> sorear, uh. not really
19:46:31 <chessguy> you could point him to my lazy evaluation example/tutorial thing
19:46:44 <nopcode> :)
19:47:05 <chessguy> http://haskell.org/haskellwiki/Haskell/Lazy_evaluation
19:47:06 <lambdabot> Title: Haskell/Lazy evaluation - HaskellWiki
19:47:28 <nopcode> ok thx :)
19:52:06 <nopcode> so...
19:52:44 <nopcode> lazy evaluation means patterns are applied while they fit and if none do, the expression is evaluated a step further, repeat?
19:53:01 <sorear> close enough
19:53:27 <sorear> actually, it tests patterns strictly in order
19:53:53 <sorear> so it evaluates enough to pass/fail the first; then evaluates enough to pass/fail the second; ...
19:53:57 <SamB_XP> sorear: noooooo not strictly!
19:54:21 <sorear> :)
19:54:31 <nopcode> oh ic
19:55:02 * SamB_XP wonders how he came to have opened a pdf about computer synthesis of birdcalls
19:55:26 <bd_> By clicking on a blue highlighted phrase.
19:55:29 <jfredett> must have been that sugar cube that one hippie girl gave you
19:55:31 <nopcode> lol
19:55:34 <Saizan> how do change the interpreter that haskell-mode uses?
19:55:49 <jfredett> you dont, because emacs hates you
19:55:52 <nopcode> it's 5 AM here, i'd like the opposite
19:55:56 <nopcode> something to stop the birdcalls.
19:56:04 <SamB_XP> Saizan: I don't remember
19:56:07 <SamB_XP> but you can
19:56:23 <dmwit> grep ghci *
19:56:24 <Saizan> nopcode: hehe, same here :D
19:56:51 <nopcode> ok well i guess i'll try and write some generic backtracking code (maybe with non-DFS / cost function weighting) tomorrow
19:56:56 <nopcode> but for now i gotta get some sleep
19:56:58 <SamB_XP> nopcode: perhaps if you synthesize them perfectly with inverted polarity, you can cancel them !
19:57:03 <nopcode> thanks for the help, night :)
19:57:06 <jfredett> sleep, theres an idea
19:57:07 <Saizan> dmwit: i've to change the source? i was hoping for some var
19:57:10 <jfredett> night!
19:57:13 <nopcode> SamB_XP: they make headphones with that feature :)
19:57:28 <dmwit> Saizan: I have no idea, I'm a vim junkie. =)
19:58:28 <SamB_XP> Saizan: well, maybe if you look in the source you'll discover the var
19:58:40 <sorear> Saizan: M-x customize
19:59:17 <sorear> Configuring emacs is easy now!
19:59:49 <mauke> FSVO "easy"
19:59:56 <oo> and customize-apropos
20:00:19 <sorear> mauke: All reasonable definitions I know of...
20:01:29 <Saizan> uhm, i never remember of customize
20:01:58 <sorear> Saizan: it's easy!  just cursor over and RET
20:01:59 <SamB_XP> sorear: you obviously don't have much trouble finding the desired options
20:02:06 <SamB_XP> sometimes they don't even exist!
20:02:17 <sorear> SamB_XP: No, because I read the whole thing.
20:09:53 <kerkers> hey
20:10:06 <sorear> hello, kerkers
20:10:11 <sorear> and welcome here too :)
20:10:14 <kerkers> can anyone help me out... i'm having trouble compiling the X11-extras package :(
20:10:20 <kerkers> dont know if this is the right channle to post that
20:10:27 <kerkers> channel
20:10:30 <jfredett> its right enough, methinks
20:10:31 <sjanssen> kerkers: here or xmonad is fine
20:10:32 <kerkers> sorear: :)
20:10:35 <jfredett> whats the error?
20:10:38 <sjanssen> kerkers: what is the problem?
20:10:55 <kerkers> sjanssen: error processing Graphics.X11.Xinerama
20:11:01 <kerkers> sorry
20:11:04 <kerkers> preprocessing
20:11:06 <sorear> kerkers: cannot find file?
20:11:17 <kerkers> yes
20:11:19 <jfredett> you probably just need the file from Hackage
20:11:21 <sorear> kerkers: you need to run autoreconf as the first step when building from darcs
20:11:29 <kerkers> X11_extras_config.h
20:11:33 <sorear> kerkers: I think it's in the readme
20:11:34 <jfredett> oh- there you go-
20:11:35 <kerkers> oh
20:11:36 <sorear> yeah, that's the one
20:11:41 <jfredett> sorear is smarter than me, as usual
20:11:46 <kerkers> lol
20:11:54 <jre2> anyone know if ghc plans on switching to libreadline5 at any point or what is currently preventing them from doing so?
20:12:10 <sorear> jre2: ghc does work with libreadline5
20:12:41 <sjanssen> jre2: you're wondering about the generic Linux builds?  They build it on an outdated-ish box
20:12:49 <sorear> jre2: it's just that since old libraries are easier to find than newer ones, the binary distributions are prepared on an extremely ond install
20:12:52 <jre2> ah
20:12:55 <kerkers> sorear: thanks, ill try that
20:13:11 <jfredett> bah, my ipod died... :(
20:13:16 <kerkers> jfreddet, sjanssen: you too :P
20:13:16 * sjanssen waits for sorear to point out his hexedit hack
20:13:24 <jfredett> np kerkers
20:13:30 <sorear> sjanssen: thanks I'd forgotten :)
20:13:39 <jre2> so if I reinstalled ghc from source I would be able to use readline5?
20:13:49 <sorear> jre2: libreadline4 and libreadline5 have *extremely* good binary compatibility
20:13:57 <sjanssen> jre2: yep, that should work fine
20:14:02 * jfredett is AF to the Kizzay.
20:14:11 <jre2> ah
20:14:33 <sorear> jre2: so good that if you find the real ghc binary and hexedit "libreadline4" to "libreadline5", it will work fine.
20:14:36 <sorear> in about 15 seconds
20:14:49 <sorear> compare to 7200 for rebuilding
20:14:52 <jre2> I switched my system to libreadline4 to get my binary ghc working and that broke a number of my other packages ;)
20:15:04 <jre2> sorear: are you serious?
20:15:12 <SamB_XP> sorear: why can't you just use sed?
20:15:20 <kerkers> sorear: autoreconf cursed me with all kinds of nasty errors regarding aclocal
20:15:33 <sorear> jre2: Very serious.  That's how my ghc-6.4.2 is set up
20:16:06 <sorear> jre2: turns out you can't use GHC 6.7 to build 6.4, you need an *older* version to compile from source - or just get and fix the binary
20:16:46 <jre2> 6.7 is out? I grabbed the 6.6.1 binary
20:16:49 <sorear> kerkers: yeah, autoreconf requires some programs from the "automake" package to work fully
20:17:02 <sorear> jre2: linux kernel numbering scheme.  6.7 is the devel branch
20:17:09 <jre2> ah
20:17:25 <kerkers> sorear: sorry, i didnt noticed the lack of automake
20:18:57 * jfredett is back like a bad cold
20:27:09 <jfredett> does anyone know if Haskore is still being actively worked on?
20:27:25 <jfredett> it looks like its old (c 2000) now
20:28:25 <SamB_XP> it probably is that old
20:28:35 <SamB_XP> why do you ask?
20:28:42 <jfredett> well--
20:28:47 <jfredett> i've got this program
20:28:49 <jfredett> its in Java
20:28:51 <sjanssen> well++
20:29:05 <jfredett> you beat me, sjanssen
20:29:23 <dons> there was an announcement last year of a new haskore project
20:29:33 <jfredett> anyways, this program contains a neural-net-ish datastructure for learning music
20:29:35 <SamB_XP> oooh, a new project?
20:29:38 <jfredett> it reads in midi
20:29:42 <jfredett> and trains itself
20:30:00 <SamB_XP> jfredett: that sounds only marginally related to haskore to *me*
20:30:11 <jfredett> unfortunately, the program is mostly boilerplate and nasty to deal with-
20:30:30 <jfredett> well, what I need is some infrastructure- just the ability to muck around with musical datatypes
20:30:34 <SamB_XP> I think you might find Uniplate or Data.Generics to be more interesting...
20:30:39 <jfredett> and do some basic analysis
20:31:03 <jfredett> i think the transition to Haskell alone should help take care of my boilerplate problem
20:31:22 <SamB_XP> yes, probably
20:31:39 <jre2> sorear: muhaha!! it totally worked, thanks
20:31:44 <jfredett> but if Haskore is old and not getting newer.
20:31:54 <jfredett> i might just work on something like Haskore.
20:31:55 <dons> btw, people interested in organising #haskell teams for ICFP in a couple of weeks, register your interest: http://haskell.org/haskellwiki/ICFP_Programming_Contest/Teams_2007
20:31:58 <lambdabot> Title: ICFP Programming Contest/Teams 2007 - HaskellWiki, http://tinyurl.com/3dx5mv
20:32:01 <dons> then we'll know how many teams we can organise
20:32:47 <sorear> jre2: And you thought you'd have to give up binary munging! :D
20:33:09 <siti> wooho lambda bot is competing :D
20:33:16 <jre2> who would have thought I'd use my hex editor for a legal and useful purpose!
20:33:49 <jfredett> SamB_XP: basically, I know how to implement the important stuff from my program, but if i could dodge the reimplementation of the basic music interface/midi IO
20:33:52 <jfredett> that would be good.
20:33:58 <jre2> I'll be on lambdabot's team
20:34:11 <SamB_XP> jfredett: I'm not sure Haskore supported input
20:34:13 <jfredett> I'll suck on whatever team I'm on!
20:34:23 <jfredett> SamB_XP: hmm *reads*
20:34:35 <SamB_XP> @vixen do you work yet?
20:34:35 <lambdabot> <undefined>
20:34:38 <SamB_XP> aww.
20:34:52 <SamB_XP> dons: when is rebootin' time?
20:34:55 <jfredett> well, theres certainly midi out.
20:35:05 <SamB_XP> jfredett: so I am aware
20:35:28 <jfredett> i guess i'll probably end up creating a haskoralike- unless i can find someone who already is. :)
20:35:41 <jfredett> it'll be fun, anyway.
20:35:44 * SamB_XP used a hexeditor to help him fixing vixen. granted, he didn't do any editing with it
20:37:14 <mgsloan> it's shocking how there aren't any good OSS hexeditors
20:37:28 <mgsloan> least as far as I've looked
20:37:55 <emu> write one: hasXOR
20:38:06 <jfredett> thats because usually OSS software doesn't need to be stolen/cracked/hacked/etc.
20:38:18 <jfredett> and if you want to see the internals. you download the source
20:38:19 <mgsloan> heh, probably...
20:38:29 <SamB_XP> we have hexdumpers well enough
20:38:30 <mgsloan> but hexeditors are useful tools for way more than that
20:38:38 <SamB_XP> and frhed is open source, notice!
20:39:29 <TSC> emacs has an ok hex-mode
20:39:29 <sproingie> bed is a hex-editor that's all right
20:39:32 <mgsloan> windows
20:39:37 <jfredett> mgsloan: i'm sure they are, but they're typically used by script kiddies for illegal purposes, so OSS doesn't bother to support that.
20:39:57 <mgsloan> good point
20:40:05 <mgsloan> I suppose more necessary is a hex viewer
20:40:13 <jfredett> true that
20:40:25 <jfredett> i use vi. :)
20:40:44 <jfredett> vi a.out is a mind numbingly useless experience.
20:41:20 <SamB_XP> mgsloan: and we have plenty of those
20:41:52 <sorear> mgsloan: What do you consider a "good" hexeditor to be?
20:42:01 * sorear thinks tweak is pretty good
20:42:01 <mgsloan> sproingle - looks pretty good, except I don't like cmd like apps very nice
20:42:21 <mgsloan> I'm not sure.  I've never really found one.  The one i've used most is xvi_32
20:42:56 <sorear> well I've never used it; can you briefly explain what it does better then 'hexedit' ?
20:44:04 <mgsloan> well, one thing I appreciate is the ability to convert bytes, starting at the current selection, into the various numeric forms
20:44:38 <rjseagraves> when using Parsec, what's the best way to parse just uppercase or just lowercase letters?
20:45:14 <SamB_XP> rjseagraves: isn't that covered in daan's tutorial?
20:45:27 <mgsloan> I dunno exactly what HexEdit looks like, but I also like when bytes in the regular ascii range are colored, and all 00 are colored
20:45:57 <mgsloan> in particular, once I figured out a file format - turned out some ints were stored big-endian
20:46:53 <SamB_XP> rjseagraves: http://legacy.cs.uu.nl/daan/download/parsec/parsec.html
20:48:15 <mgsloan> tis also nice if you can start tagging sections of files
20:49:11 <mgsloan> an amazing feature would be to have relative and absolute offset flags, and be able to position them over bytes, and have it indicate where they point
20:51:26 <SamB_XP> mgsloan: you don't think big enough yet ;-)
20:52:11 <mgsloan> hah!
20:53:44 <yaarg> lllllloooooooooooooooooooooooooo
20:55:29 <dons> ?yow
20:55:30 <lambdabot> I'm using my X-RAY VISION to obtain a rare glimpse of the INNER
20:55:30 <lambdabot> WORKINGS of this POTATO!!
20:55:34 <dons> cool!
21:00:56 <yaarg> opps
21:06:50 <dons> http://programming.reddit.com/info/22kvk/comments
21:06:51 <lambdabot> Title: Roll your own DSL: embedding a larger language into Haskell with overloading (re ...
21:13:59 <jfredett> sleep time, gnight folks
21:31:05 <bos31337> @type (^)
21:31:09 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
21:31:09 <bos31337> @type (^^)
21:31:12 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
21:31:13 <bos31337> @type (**)
21:31:15 <lambdabot> forall a. (Floating a) => a -> a -> a
21:31:20 <bos31337> sigh.
21:32:04 <Cale> bos31337: Something wrong?
21:32:38 <bos31337> i was hoping to talk about exponentiation early on, but the presence of three different operators does not a good example for newbies make.
21:33:00 <bos31337> especially when they give subtly different answers for the same inputs.
21:33:27 <Cale> Well, they correspond nicely to the definitions of exponentiation from mathematics.
21:34:16 <bos31337> where (^) and (^^) correspond to iterated multiplication, and (**) not, yes.
21:34:37 <bos31337> but the presence of both (^) and (^^) is still weird.
21:34:47 <treble> ^^ supports negative exponents
21:34:48 <Cale> Not at all.
21:34:56 <Cale> (^) is what you get in any monoid/group
21:35:12 <Cale> er, any monoid
21:35:23 <Cale> and (^^) needs inverses of the elements you're exponentiating
21:35:25 <bos31337> ah, i hadn't noticed the ability to use negative exponents with (^^).
21:35:49 <treble> > 1 ^ (-1) -- for example
21:35:51 <lambdabot>  Exception: Prelude.^: negative exponent
21:35:52 <sorear> @src ^
21:35:52 <lambdabot> Source not found. Do you think like you type?
21:35:55 <sorear> @src (^)
21:35:55 <lambdabot> Source not found. Are you on drugs?
21:36:01 <sorear> @src (^^)
21:36:02 <lambdabot> x ^^ n      =  if n >= 0 then x^n else recip (x^(negate n))
21:36:07 <bos31337> okay, this confirms my conclusion that exponentiation can wait :-)
21:38:13 <mgsloan> class Exp a b where (^) :: a -> b -> a
21:50:09 <Aphelion> lambdabot is funny
21:51:58 <mgsloan> will ghc optimize out constant functions?  eg, take the value of the function, inline another short function, and partially evaluate
21:52:54 <chessguy> anyone here that can read norwegian?
21:53:05 <jre2> is there any easy way to generate ghc docs if you installed via binary?
21:55:56 <Cale> jre2: I doubt that, though hopefully there's a corresponding documentation package, if the binary package didn't come with docs already.
22:00:53 <jre2> Cale: sadly not, I guess I'll reinstall from source overnight
22:01:18 <Cale> jre2: Which binary package did you install with?
22:01:27 <sorear> mgsloan: can you elaborate a little more?
22:01:36 <jre2> the 6.6.1 generic linux one on the ghc site
22:04:47 <mgsloan> sorear - well, this isn't exactly what I was talking about before, but:
22:04:47 <mgsloan>     a == m@Matrix = toMat a == m
22:05:30 <mgsloan> toMat will take a member of the datatype Transform, and return a Matrix, another member of Transform
22:05:49 <mgsloan> will it automatically specialize this function for each of the members of the ADT, and inline the function?
22:06:37 <sorear> Maybe.
22:06:49 <mgsloan> ahwell, I'll just do it this way.  shorter.
22:06:57 <sorear> You just described SpecConstr, one of the passes enabled by -O2.
22:07:08 <sorear> Try it with -O2 -ddump-simpl-stats
22:07:10 <mgsloan> oh, cool
22:08:07 * sorear mentally mixes two lines of Hugs output, producing "I/O Error"
22:14:35 <mgsloan> aw, m@Matrix should be a shorthand for m@(Matrix _ _ _)
22:15:19 <jre2> is anyone here using shim or something else to get background compliation with vim?
22:23:17 <bos> barry warsaw has a lot to answer for.  around the world, hundreds of thousands of people are being spammed by monthly mailman list reminders.
22:26:06 <Gwern-away> is there any easy to understand general sort of documentation for the Control.Parallel.Stratagies library? I was hoping to use it to get some more parallelism but just the API doesn't explain how to use it well
22:26:36 <dons> Gwern-away: currently there's just the papers, afaik.
22:26:45 <dons> some documentation would be really really useful
22:27:47 <Gwern-away> dons: yes, you said you would write some some day in your blog
22:27:59 <Gwern-away> ...which was one of the top hits. a mention by dons he would write a blog post on it one day
22:28:08 <bos> heh.
22:28:14 * Gwern-away suspects the library may be under documented and utilized :)
22:29:11 <bos> CosmicRay and i are making nice progress on the o'reilly book.
22:29:31 <bos> i'm looking forward to dons being able to join in.
22:29:49 <dons> right!
22:30:00 <shachaf> bos: Good news!
22:30:05 <Gwern-away> bos: did you guys set up the darcs repository yet and settle the license?
22:30:06 <dons> you guys leave all the hard chapters for me ;)
22:30:06 * shachaf is looking forward to it. :-)
22:30:44 <bos> dons: yeah, we should have chosen them at random instead of from the front of the book to the back :-)
22:30:51 <dons> :)
22:31:07 <bos> Gwern-away: we have a darcs repo with plenty of content in it already.
22:31:23 <bos> we've settled on *a* CC license, just not on *which* CC license.
22:31:33 <Gwern-away> bos:
22:31:39 <dons> i'm looking forward to getting stuck into some of the meaty bits. lots of good stuff to talk about. now, just get this thesis done, book the removalist, pack up the house, oh busy busy time.
22:31:39 <Gwern-away> so no change on the license front :(
22:31:50 <Gwern-away> oh well. link to the repo?
22:32:07 <bos> Gwern-away: oh, you were the one talking about some different license a few weeks ago?
22:32:30 <bos> we'll publish a link to the repo once we're happy with the early chapters.
22:33:01 <Gwern-away> bos: yes. as I was saying, it's crucially important for wikipedia-related projects that the CC license not have the NC clause
22:33:03 <bos> we started with chapters 5 and 7 to fulfill an early contract deadline, and now we're backfilling.
22:33:11 <bos> ah yes.
22:33:21 <Gwern-away> what were 5 and 7 on?
22:33:57 <bos> 5 is typeclasses; 7 is putting some of the stuff from earlier chapters to use.
22:34:22 <bos> Gwern-away: i'm 99% sure the license will have the NC clause, otherwise o'reilly's lawyers will have kittens.
22:34:34 <Gwern-away> =right there was going to be an emphasis on practicality wasn't there?
22:34:40 <bos> zigackly.
22:34:59 <Gwern-away> bos: dunno why they'd be so upset. the SA clause makes it commercial poison for anyone else to publish
22:35:41 <bos> they've had people republish works, on paper, before, and they didn't enjoy it very muhc.
22:36:53 <Gwern-away> bos: so how did O'Reilly come to choose you guys specifically?
22:37:01 <bos> we chose them :-)
22:37:31 <Gwern-away> 'we' being?
22:38:07 <bos> i know a bunch of o'reilly people, and they'd been snuffling around haskell and erlang for a bit, so i stuck my head over the parapet.
22:38:45 <bos> then i asked dons to coauthor, and we asked CosmicRay to coauthor, as we knew he already had a book in mind.
22:38:48 <Gwern-away> just emailed them so to speak, and suggested hey I know some good haskell hackers with a literary bent?
22:39:12 <bos> pretty much.
22:39:32 <bos> if i was j random nobody, that wouldn't have worked out so well, perhaps.
22:39:49 <Gwern-away> but you'd previously written something for them, iirc ?
22:39:57 <bos> no. i just knew people there.
22:40:36 <Gwern-away> oh. truly, contacts are valuable thiings
22:41:05 <bos> i've written another book, about distributed revision control, so they at least had something to assure themselves i could get from chapter 1 to chapter N without falling over.
22:41:51 <bos> and CosmicRay has written another book or two. and dons just spews out code and words every waking moment.
22:42:08 <bos> so we're a lean mean writing team :-)
22:42:35 <bos> except for the bit where docbook makes me very grumpy.
22:59:18 <treble> ?losers
22:59:18 <lambdabot> Maximum users seen in #haskell: 354, currently: 291 (82.2%), active: 5 (1.7%)
23:05:24 <jsnx> how does one cast in haskell?
23:05:31 <jsnx> i can't find it anywhere
23:05:52 <sorear> cast?
23:05:56 <Cale> jsnx: Exactly what do you mean by cast?
23:06:18 <sorear> jsnx: it's there if you need it, but you need to *much* less often than in C
23:06:40 <sorear> jsnx: for instance, you can store arbitrary objects in a linked list without casts
23:06:44 <sorear> @src []
23:06:44 <lambdabot> data [] a = [] | a : [a]
23:06:53 <sorear> @src !!
23:06:53 <lambdabot> xs     !! n | n < 0 = undefined
23:06:53 <lambdabot> []     !! _         = undefined
23:06:53 <lambdabot> (x:_)  !! 0         = x
23:06:53 <lambdabot> (_:xs) !! n         = xs !! (n-1)
23:06:58 <Cale> There's a cast operation which has type  a -> Maybe b, which gives Just x only in the case that a and b are actually the same type.
23:07:41 <Cale> But that's probably not what you're looking for
23:08:01 <Cale> If you're trying to convert between numeric types, that's done primarily with fromIntegral and realToFrac
23:08:12 <sorear> There's a more flexible cast operation a -> b, which gives segfaults if the types don't match.  We use it *very* rarely.
23:08:27 <jsnx> well, I'm trying to go from Integer to Int
23:08:33 <sorear> fromInteger
23:08:45 <jsnx> sorear: oh, so that's what that does
23:08:48 <Cale> or fromIntegral.
23:09:08 <jsnx> why does !! demand an Int?
23:09:12 <sorear> jsnx: yeah, the other casts are strictly memory casts; an Integer is not a valid Int even if the value is in range
23:09:23 <Cale> Because the Haskell 98 committee was shortsighted, and Int is faster.
23:09:30 <jsnx> sorear: oh, dear
23:09:31 <sorear> jsnx: it's supposed to make things easier for newbies
23:09:41 <jsnx> sorear: what is?
23:09:50 <sorear> jsnx: (!!) :: _ -> Int -> _
23:10:02 <jsnx> sorear: how?
23:10:18 * sorear defers to Cale
23:10:24 <jsnx> sorear: oh, you're saying real users don't use !!
23:10:31 <Cale> sorear: No, it was because Int is actually faster than Integer, and at the time it was standardised, compilers didn't have the specialise pragma.
23:11:22 <Cale> In Data.List, there's genericIndex :: Integral a => [b] -> a -> b
23:11:45 <Cale> which is really what !! should be, but for now, we're stuck with Int.
23:13:31 <jsnx> back
23:14:14 <jsnx> so, now I have another issue -- I pass a parameter that is known to be an Integer to logBase _ _
23:14:22 <TSC> :t logBase
23:14:24 <Cale> @t logBase
23:14:29 <Cale> er, :t :)
23:14:29 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
23:14:31 <lambdabot> forall a. (Floating a) => a -> a -> a
23:14:37 <jsnx> right, yes
23:14:41 <Cale> Yeah, so again, fromIntegral
23:14:41 <jsnx> that it my problem
23:14:42 <TSC> fromIntegral
23:14:48 <jsnx> Cale: ?
23:14:54 <Cale> fromIntegral turns any integer-like number into any other kind of number.
23:15:03 <jsnx> ha ha ha
23:15:16 <jsnx> that's why I couldn't figure it out
23:15:23 <Cale> Which you can see by its type signature:
23:15:27 <Cale> :t fromIntegral
23:15:31 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:15:38 <jsnx> yes, now i can
23:15:41 <mgsloan> > read "56" :: Int
23:15:45 <lambdabot>  56
23:16:05 <mgsloan> > read "[1,1,2,3,5]" :: [Int]
23:16:08 <lambdabot>  [1,1,2,3,5]
23:16:20 <jsnx> that's kind of cool, actually, that the system infers what type to turn it into
23:16:36 <mgsloan> actually, I'm specifying what type to turn it into
23:16:47 <mgsloan> (the :: [Int] bit)
23:16:54 <mgsloan> > read "[1,1,2,3,5]"
23:16:56 <lambdabot>  Exception: Prelude.read: no parse
23:17:10 <Cale> > read "()"
23:17:13 <lambdabot>  Exception: Prelude.read: no parse
23:17:15 <Cale> nope :)
23:17:16 <mgsloan> hmm, that seems like a funny way to say "you didn't tell me what to return, dummy!"
23:17:17 <Cale> > read "5"
23:17:17 <mgsloan> hah
23:17:18 <scook0> :t read "()"
23:17:19 <lambdabot>  5
23:17:21 <lambdabot> forall a. (Read a) => a
23:17:31 <TSC> > map (+1) $ read "[1,1,2]"
23:17:34 <lambdabot>  [2,2,3]
23:17:35 <mgsloan> Cale - whoah, what just happened!
23:17:43 <Cale> mgsloan: defaulting
23:18:02 <jsnx> mgsloan: I was referring to fromInteger
23:18:06 <Cale> I suppose it's defaulting types to Integer.
23:18:14 <Cale> jsnx: yeah
23:18:26 <mgsloan> jsnx - yeah, it uses the 'expected type' to know what to turn it into
23:18:36 <Cale> jsnx: In fact, it can be ambiguous too, but there's enough defaulting in place to make that highly uncommon.
23:18:49 <sorear> Cale: this is -fextended-defaulting-rules at work
23:19:00 <mgsloan> > read "[5]"
23:19:02 <lambdabot>  Exception: Prelude.read: no parse
23:19:11 <Cale> Numeric things get defaulted to Integer if possible, and Double otherwise.
23:20:13 <sorear> Seems kinda silly to me.
23:20:28 <sorear> Wouldn't (Integer,Rational) or (Int,Double) make more sense?
23:21:00 <Cale> That's what the default keyword is for :)
23:21:03 <sorear> oh yeah, I asked that a could days ago and got told about show (sin 1)
23:21:14 <Cale> If you don't like the defaults you can declare them to be different
23:21:18 <mgsloan> > show (sin 1)
23:21:21 <lambdabot>  "0.8414709848078965"
23:21:34 <mgsloan> seems reasonable to me!
23:22:21 <Gwern-away> was it Gerard Huet who described the zipper or Paul Huet?
23:23:33 <mgsloan> well, it was patented in 1851 by Elias Howe
23:23:46 <TSC> Gerard
23:23:59 <Gwern-away> mgsloan: oh noes
23:24:05 <Gwern-away> I hope the patent has expired by now!
23:24:11 <Gwern-away> TSC: k. thought so
23:24:14 <mgsloan> I believe so :)
23:24:49 <TSC> GÃ©rard, really
23:26:06 <Gwern-away> are there any FUSE haskell bindings?
23:26:16 <sorear> @where hfuse
23:26:16 <lambdabot> I know nothing about hfuse.
23:26:20 <sorear> @google hfuse
23:26:23 <lambdabot> http://darcs.haskell.org/hfuse/
23:26:23 <lambdabot> Title: Index of /hfuse
23:26:32 <Gwern-away> coolios
23:28:28 <Gwern-away> known to work with... "The Glorious Glasgow Haskell Compilation System, version 6.2.2"? how old is this?
23:31:15 <Cale> 2004-2005 or so
23:31:23 <Cale> (probably)
23:57:39 <jre2> http://www.cs.kent.ac.uk/projects/pivotal/index.html
23:57:40 <lambdabot> Title: Pivotal home page
23:57:48 <jre2> ^^ iritated Mathematica user?
