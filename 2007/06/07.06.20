00:00:06 <LeCamarade> Oh.
00:00:07 <Japsu> that's scary :(
00:00:10 <LeCamarade> :-*
00:00:12 <allbery_b> lecamerade: actually I think that's from interlisp which was (one of?)_ the first LISP implementations
00:00:13 <dons> how do people write lisp/scheme in irc?
00:00:17 <dons> matching up those parens hurt my head
00:00:22 <LeCamarade> dons: Push it at the Lispers, please!
00:00:32 <jfredett> lol
00:00:40 <opqdonut> dons: they do it instinctively :)
00:00:41 <LoganCapaldo> dons: they're using ERC inside emacs, so the parens get hilighted anyway :)
00:00:45 <jfredett> alright, I'm really really leaving this time
00:00:48 <LeCamarade> allbery_b: So Lisp has needed to be fixed since back then? And it hasn't been fixed _yet-?
00:00:48 <dons> heh
00:00:57 <jfredett> I use vi for my schemeing.
00:01:01 <dons> yeah, they fixed it, and called in haskell ;-)
00:01:07 <opqdonut> i used to hang out in some lisp chans, and the guys were unable to type ":)" it had to be "(:)"
00:01:16 <LoganCapaldo> LOL
00:01:16 <allbery_b> heh
00:01:21 <LeCamarade> dons: Yep.
00:01:30 <LoganCapaldo> @type (:)
00:01:32 <lambdabot> forall a. a -> [a] -> [a]
00:01:32 <jfredett> ...
00:01:33 <dons> someone should back port haskell syntax to (haskell version (-6)), aka lisp.
00:01:34 <LeCamarade> Lisp is only good to be generated.
00:01:42 <allbery_b> lecamerade: actually lisp has been fixed a bunch of times.  haskell's one of them :)
00:02:04 <LeCamarade> @remember dons someone should back port haskell syntax to (haskell version (-6)), aka lisp.
00:02:04 <lambdabot> Done.
00:02:13 <jfredett> just remember- no matter what- greenspuns tenth still applies, even to haskell
00:02:24 <arcatan> it was nice that version of vim with paren matching was just released when I first tried scheme
00:02:29 <allbery_b> see, we knew it!
00:02:33 <jfredett> us lispy folk are still everywhere. :)
00:02:40 <LeCamarade> (haskell (version (- (6)) (aka (lisp))))
00:02:40 <jfredett> err- i suppose (:)
00:02:48 <jfredett> I'll show some solidarity. :)
00:02:53 <jfredett> gnite again.
00:03:06 <allbery_b> so why haven't any of you fixed ":set lisp" in nvi? :)
00:03:11 <SamB> doesn't haskell already have the half of lisp we want?
00:03:17 <LoganCapaldo> Lisp is a conspiracy
00:03:23 <dons> i think there's another rule at work too
00:03:30 <LoganCapaldo> perpetrated by con-men
00:03:38 <dons> any useful lisp program contains an ad hoc implementation of haskell's type system -- at runtime.
00:03:44 <Korollary> Lisp is old enough to have had its fair share of intellectual investment.
00:03:56 <LoganCapaldo> if you look carefully you can see evidence of this in the choice of identifiers
00:04:12 <dons> also, any sufficiently complicated lisp program contains an ad hoc implementation of haskell's syntax -- as macros
00:04:13 <LoganCapaldo> for instance, cons, a subtle hint that you're being conned
00:04:14 <arcatan> Fortran is old enough
00:04:25 <LoganCapaldo> car, as in they want to steal it from you
00:04:31 <Japsu> @rememeber dons any useful lisp program contains an ad hoc implementation of haskell's type system -- at runtime.
00:04:31 <lambdabot> Done.
00:04:41 <LeCamarade> dons: Not to metion the uncertainty of purity! Or that you have to evaluate the 1000000th element, when you are only running (car thatlist).
00:04:50 <LoganCapaldo> cdr, as in they use blank cds to pirate other's source code
00:04:53 <allbery_b> cdr as in "incomprehensible"?
00:04:56 <allbery_b> ah
00:05:00 <LeCamarade> LoganCapaldo: :o)
00:05:09 <allbery_b> (yes, I know where car/cdr come from)
00:05:11 <arcatan> oh those evil lispers!
00:05:20 <Shimei> Haskell, on the other hand, is a capitalist plot. Look at all those "$". Numismaphilia!
00:05:30 <int-e> car and cdr are the nub of lisp.
00:05:38 <dons> lisp was cool in 1958 though. really really cool.
00:05:45 <LoganCapaldo> And trust me, you don't want to know what nconc really stands for
00:05:50 <LeCamarade> Shimei: But we are moving the revolution to Haskell ... watch:
00:06:15 <LeCamarade> > let _'slavery' = "freedom" in _'slavery'
00:06:17 <lambdabot>  "freedom"
00:06:36 <LeCamarade> Okay, this is getting too -blah, now.
00:06:38 * allbery_b doesn't wannt to think about nconc, it makes his head hurt
00:07:30 <dons> oh, that reminds me,     SQL, Lisp, and Haskell are the only programming languages that I've seen where one spends more time thinking than typing.
00:07:34 <dons>      Philip Greenspun
00:07:53 <arcatan> is that because they're so hard to use?
00:07:55 * dons notices the topic . interesting.
00:08:16 <Korollary> Algebra is hard. Let's go shopping.
00:08:28 <dons> stuff is hard. let's not do stuff.
00:08:33 <LoganCapaldo> Shopping is hard. Let's do algebra
00:08:35 <arcatan> malebolge needs really more thinking than typing
00:08:46 <dons> reminds me of Knuth's (?) rule about buying a car
00:09:18 <SamB> it's because they aren't so full of boilerplate that you can't spend more time thinking than typing
00:09:24 <Korollary> I'm sorta disappointed by that recent article on reverse engineering of TeX in ML. I would have expected better from Knuth.
00:09:27 <LoganCapaldo> Or even number theory where the proofs are all written using unary. Anything to avoid shopping
00:09:41 <opqdonut> Korollary: link?
00:09:47 <opqdonut> and what was so disappointing?
00:10:30 <Korollary> opqdonut: http://lambda-the-ultimate.org/node/2288
00:10:32 <lambdabot> Title: A Functional Description of TeX&#039;s Formula Layout | Lambda the Ultimate
00:13:23 <kfish> dons: what was that rule about buying a car?
00:14:31 <Japsu> @hoogle ap
00:14:32 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
00:14:32 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
00:14:32 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
00:21:08 <kombee> Hey guys. Urbexer? come along to #urbexAU
00:22:38 <dons> kfish: oh, i remember richard buckland saying knuth's car algorithm was: to buy a car, go to the nearest car dealership, buy the cheapest car in the lot, get back to hacking.
00:23:12 <kfish> haha
00:24:00 <davidL> is there a vim syntax script for haskell?
00:24:37 <dons> yeah
00:24:44 <dons> :set syntax on
00:25:09 * davidL hoped for more :P
00:26:22 <dons> nice new screenshot of xmonad on a wide flat lcd, now on the front page, http://xmonad.org/ -- for those pondering how to lay out their windows on their big new monitors :-)
00:26:24 <lambdabot> Title: xmonad : a tiling window manager
00:26:51 <kfish> @google "haskell + vim"
00:26:52 <lambdabot> http://www.cs.kent.ac.uk/people/staff/cr3/toolbox/haskell/Vim/
00:26:52 <lambdabot> Title: Haskell mode for Vim
00:27:12 <davidL> ah, google > vim.org
00:27:22 <davidL> thanks kfish
00:27:52 <kfish> there are rumours of vim.org staging a corporate takeover of google, but we'll have to wait for web4.0 to see how that pans out
00:28:14 <opqdonut> dons: someone said that xmonad is optimized for wide-screen. i think he hit the nail on the head
00:28:24 <opqdonut> or did he say that about dwm, hmmm
00:28:33 <opqdonut> i guess dwm as xmonad is miles more flexible
00:28:35 <opqdonut> anyways :)
00:29:01 <dons> yeah, xmonad is just a more flexible dwm, in the long run. in particular, its optimised for widescreen, multihead set ups.
00:29:43 <dons> the fullscreen mode in xmonad is more for 1024/x768 12" laptops, so that's the other aspect
00:30:07 <opqdonut> yeah kinda like the ratpoison aspect
00:31:18 <opqdonut> i'm using ion atm with a full-screen workspace for browser, and a [-| ] layout for coding. on smaller monitors i keep irc on the scratchpad (a toggleable on-the-top floating frame) and on bigger ones on the terminal desktop
00:31:40 <opqdonut> would you say something like that would be possible with xmonad? i particularily like the toggleable irc :)
00:32:09 <opqdonut> (sorry to bother you with stuff like this ^_^;;;)
00:32:37 <davidL> heh, that's an odd location for a screenshot but it's better than adding an incomplete row to the screenshots section
00:33:03 <dons> well, it means the first half of the page isn't empty
00:33:05 <davidL> opqdonut: you mean like a drop down console (quake style)?
00:33:13 <dons> and the shot is a nice summary of how you'd use xmonad
00:33:16 <dons> imo.
00:33:19 <opqdonut> davidL: kinda like :)
00:33:48 <dons> opqdonut: seems reasonable yes.
00:34:02 <dons> fullscreen, [-| ] and floating will just work, on each workspace.
00:34:04 <davidL> opqdonut: oddly, enough I was thinking about the exact same thing earlier
00:34:14 <davidL> s/,//
00:35:01 <opqdonut> dons: yeah [-| ] seems quite like what all the xmonad screenshots are about :)
00:35:13 <opqdonut> the thing that bothers me somewhat is the lack of tabs
00:35:31 <opqdonut> i mean, all clients on a workspace are always visible in the tiling modes, correct?
00:35:43 <dons> opqdonut: use Tabbed.hs, droundy's tabbing extension
00:35:48 <dons> it seems to be quite popular.
00:36:13 <davidL> does XMonadContrib.Tabbed work like ion3 tabbing?
00:36:47 <dons> opqdonut: the builtin layouts, tall and wide (i.e. [=| ] and [-+-] always show all clients. fullscreen shows the focused client. other strategies are done by editing your config.hs
00:36:58 <dons> davidL: yeah, its supposed to.
00:37:05 <davidL> I noticed it was a Layout, does that mean I can only have 1 set of tabs on the screen at the time?
00:37:18 <dons> hmm?
00:37:33 <opqdonut> dons: do tall and wide move the focused frame into the "biggest" slot automatically?
00:37:42 <dons> nope.
00:38:02 <opqdonut> good :)
00:38:09 <davidL> I should just try the module before asking stupid questions.
00:38:15 <dons> you cycle focus around with mod-jk, and the 'biggest slot' (known as the master frame) can be set with mod-return, if you want to move a client there.
00:39:22 <opqdonut> davidL: yeah i probably should :) it's just this is my work box and i'd feel kinda guilty playing around with wms on paid time
00:39:30 <opqdonut> otoh, ircing isn't that much better
00:39:44 <dons> yeah, you should irc about playing around with wms.
00:40:19 <davidL> I was actually speaking for myself :-)
00:41:38 <davidL> dons: care to share your ~/.irssi/config (or where I could find something similar)?
00:42:01 <davidL> I'm mostly interested in the status bar at the bottom.
00:43:16 <dons> oh, that screenshot is rob|
00:43:21 <dons> check in #xmonad
00:43:42 <davidL> hmm, hadn't realized this was #haskell
00:43:46 <davidL> thanks
00:44:27 <dons> well, according to google , there's twice as many pages about xmonad, than 'haskell programming', so maybe we should call this #xmonad anyway ;) (silly google!)
00:48:00 <arcatan> nobody ever programs in haskell. they just study it
00:48:44 <davidL> :( "Your terms - xmonad - do not have enough search volume to show graphs.
00:50:05 <davidL> Interesting, the number one region for the search term Haskell is Jamaica.
00:50:24 <flux> I think it gives a more accurate result after you go a few pages deeper
00:50:34 <osfameron> perhaps it is a "seriously easy going" programming language?
00:51:03 <flux> yeah, going to page 20 gives "192 for xmonad" :)
00:51:22 <dons> sounds more like it.
00:51:37 <dons> so, yeah, and TIOBE bases their language activity graphs on these google numbers...
00:59:41 <kfish> dons, what license is lambdabot under? the cabal file and COPYING disagree (and there is no LICENSE file referred to by lambdabot.cabal)
01:01:16 <dons> GPL version 2 or later, iirc
01:01:34 <dons> ah maybe not.
01:01:49 <dons> yeah, its more open than that. see Andrew's original licensing.
01:01:53 <dons> in COPYIG.
01:12:50 <matthew-_> does anyone have any idea why libghc6-haskelldb-dev, recompiled for 6.6.1 is only available in debian for i386?
02:16:30 <baboa> hi all, I have a ffi question
02:16:50 <baboa> how do I export a Haskell function and get to know its address at the same time?
02:17:19 <baboa> something like: foreign export "myfunc" + foreign import "&myfunc"
02:17:54 <mdmkolbe|work> I need to sort a list of pairs by the first element.  I can use sortBy with an anonymous lambda, but this wheel's already been invented.
02:17:55 <mdmkolbe|work> > sortBy (\a b -> compare (fst a) (fst b)) [(1, 'a'), (2, 'b')]
02:18:03 <lambdabot>  [(1,'a'),(2,'b')]
02:18:04 <Lemmih> baboa: Looks good. Doesn't it work?
02:18:31 <baboa> it does with -fasm, doesn't with -fvia-c
02:18:36 <dmhouse> mdmkolbe|work: in newer libraries theres a comparing function.
02:18:50 <dmhouse> > sortBy (comparing fst) (zip [1..3] ['a'..'c'])
02:18:52 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
02:18:53 <mauke> baboa: why do you need its address?
02:19:09 <dmhouse> > sortBy (comparing fst) (reverse $ zip [1..3] ['a'..'c'])
02:19:10 <baboa> Lemmih: so -O is a problem
02:19:11 <lambdabot>  [(1,'a'),(2,'b'),(3,'c')]
02:19:12 <ClaudiusMaximus> baboa: there is "foreign import wrapper" that makes a factory for converting haskell functions to C function pointers at runtime
02:19:31 <baboa> mauke: to put it further to some other C function :)
02:19:54 <baboa> ClaudiusMaximus: I know, but I need to freeHaskellFunPtr after that
02:20:03 <baboa> ClaudiusMaximus: I'd rather skip that part :)
02:20:05 <mdmkolbe|work> dmhouse: how new?  (this is for code in GHC so IIRC there needs to be compatability back to GHC 5)
02:20:19 <dmhouse> GHC 5 isn't new :)
02:20:53 <dmhouse> But if it's going to be distributed with new GHCs, then those new GHCs will come with the new libraries, right?
02:21:24 <mdmkolbe|work> dmhouse: well, the new GHCs need to be compiled with old GHCs
02:25:50 <Lemmih> baboa: How does it fail with -O?
02:28:10 <baboa> it fails under Cabal build, with all the flags it passes to ghc
02:28:14 <mauke> : undefined reference to `bubbles'
02:28:29 <baboa> mauke: exactly
02:29:10 <baboa> I thought it has something to do with spiit-objs but to this day I don't know how to enable/disable split-obj in cabal :)
02:32:51 <mauke> -fvia-C doesn't generate the _stub files
02:33:48 <baboa> mauke: should I file a bug report?
02:34:10 <mauke> probably
02:34:26 <mauke> if you need a simple test program, I have one here :-)
02:34:41 <baboa> mauke: I have one, too :)
02:34:58 <baboa> could you check the split-objs? how does it interact?
02:35:05 <mauke> I don't know what that is
02:36:45 <mauke> hmm. 'ghc -fvia-C try.hs' fails with a linker error. 'ghc try.hs' succeeds (and generates a few files). now 'rm try.o try_stub.o && ghc -fvia-C try.hs' succeeds (it even regenerates try_stub.o).
02:37:06 <baboa> mauke: I see
02:37:27 <baboa> ghc is by default -fasm, it goes by itself
02:37:33 <baboa> try ghc -O2
02:38:30 <mauke> what the hell
02:38:42 <mnislaih> wtf. I never noticed how cpp inserts newlines at whim, until I used it in a Cabal descriptor
02:38:52 <mauke> *everything* succeeds now
02:39:08 <baboa> mauke: how?
02:39:34 <mauke> rm try.{hi,o} try_stub.*;  ghc -fvia-C try.hs
02:39:51 <mauke> -O2 doesn't make a difference
02:44:22 <hpaste>  mauke pasted "why does this work now?!" at http://hpaste.org/341
02:44:28 <mauke> baboa: ^
02:44:36 <baboa> looking...
02:44:44 <mauke> eek, broken line wrapping
02:52:45 <baboa> sequence ["rm *.o *.hi *stub*", "ghc -fasm ghctest.hs", "ghc -fvia-c ghctest.hs"]
02:52:46 <baboa> or
02:53:16 <baboa> sequence ["rm *.o *.hi *stub*", "ghc -fvia-c ghctest.hs", "ghc -fasm ghctest.hs"]
02:53:38 <mauke> $ rm a.out try.{hi,o} try_stub.* && ghc -O2 -Wall try.hs && ./a.out
02:53:39 <mauke> try.hs:8:0: Warning: Defined but not used: `foo'
02:53:39 <mauke> o hi
02:53:48 <baboa> seems that -fasm and -fvia-c first generate incompatible stub files and then use them
02:54:06 <mauke> same result without -O2
02:56:00 <baboa> --make seems to cure the problems
02:56:28 <mauke> I can't reproduce the initial problem now :(
02:57:04 <baboa> clean the dir, then ghc -fasm try.hs, then ghc -fvia-c try.hs
02:57:16 <baboa> of first -fvia-c then -fasm
02:57:37 <mauke> ah
02:58:04 <baboa> reproduced?
02:58:14 <mauke> yes
02:58:31 <mauke> "compilation IS NOT required" <- rm try.o fixes it
02:59:11 <baboa> is this a bug or not?
02:59:20 <mauke> no idea
02:59:51 <mauke> maybe ghc should store/compare compilation flags to decide whether compilation really isn't required
03:00:17 <baboa> I don't think any compilation system does this
03:00:25 <mauke> ccache does
03:00:33 <baboa> mhmmm
03:01:09 <baboa> I thnk, how did I come to this situation?
03:01:29 <baboa> I do not remember specifying any of asm|via-c initially...
03:08:15 <quicksilver> it is a bug
03:08:22 <quicksilver> it's been mentioned before :)
03:09:13 <baboa> quicksilver: :)
03:14:32 <baboa> quicksilver: do you remember more? is it reported in trac?
03:15:21 <quicksilver> baboa: I think so, yes
03:15:41 <baboa> quicksilver: remember some keywords? I cannot find it...
03:15:44 <quicksilver> http://hackage.haskell.org/trac/ghc/ticket/437
03:15:45 <lambdabot> Title: #437 (Recompilation check should include flags) - GHC - Trac
03:15:56 <quicksilver> (google search for 'ghc trac compiler flag', second hit)
03:15:59 <quicksilver> I have the google-fu today!
03:16:59 <igli> hehe
03:17:45 <baboa> oh, I see :)
03:18:06 <baboa> so I need to find some other bug to report :)
03:18:10 <baboa> shame :)
03:18:27 <quicksilver> #1450 - Baboa fails to use google to full efficiency
03:18:29 <quicksilver> :)
03:18:46 <baboa> I tried to use trac search
03:18:55 <quicksilver> yeah, all other search sucks
03:19:02 <quicksilver> google is the only search :)
03:19:14 <quicksilver> it's unusual for a site's own search tool to do a better job than google, sadly :(
03:19:20 <igli> meh ask.com is supposed to better
03:19:50 <baboa> I read recently, that google doesn't index haskell.org because of something
03:19:58 <baboa> and didnt try it
03:20:10 <quicksilver> it doesn't index the wiki
03:20:15 <quicksilver> although I think they changed that
03:20:38 <baboa> quicksilver: never mind
03:21:05 <baboa> anyway I think this functionality should be more in Cabal, not in ghc
03:21:20 <quicksilver> possibly, yes
03:21:24 <baboa> AFAIK cabal doesn't even check timestamps right now
03:21:34 <quicksilver> but it certainly applies to ghc --make, too
03:44:47 <LeCamarade> Phew. Lambdas survive the Great Guido restructuring. But, still, Ruby ruleth.
03:45:04 <osfameron> apparently they survived for a whole year without anyone noticing
03:48:05 <ttfh> idea: "Haskell for Excel Users - Learn programming by applying your spreadsheet knowledge"
03:49:56 <ibid> you know you've been doing haskell too long when you start to think that "excel" needs another "l"
03:50:41 <dmhouse> ttfh: that'd be cool :)
03:51:38 <DRMacIver> Haskell and Excel? What a weird combination.
03:51:41 * DRMacIver eyes Heffalump 
03:52:03 <dmhouse> DRMacIver: it's said that pure programming and spreadsheets have a few features in common.
03:52:22 <DRMacIver> Oh, I know. It was just a cheap joke. :)
03:52:26 <ttfh> you start with summing a column in excel, and summin a list in haskell
03:52:35 <ttfh> summing...
03:52:46 <dmhouse> And of course there's LÃ¶b's theorem. :) http://sigfpe.blogspot.com/2006/11/from-l-theorem-to-spreadsheet.html
03:52:49 <lambdabot> Title: A Neighborhood of Infinity: From L&ouml;b's Theorem to Spreadsheet Evaluation, http://tinyurl.com/22eoxu
03:53:03 <matthew-_> mmm. it strikes me that it would be useful to be able to remove old versions of a package from Hackage...
04:30:21 <baboa> yet more ffi: where can I find what does safe vs unsafe in foreign import?
04:31:35 <ClaudiusMaximus> baboa: safe means it can call back into haskell, iirc
04:32:15 <baboa> hmm
04:32:25 <baboa> I remember that, too
04:32:39 <baboa> but I'd like some more concrete statements :)
04:33:02 <ClaudiusMaximus> baboa: http://haskell.org/haskellwiki/Performance/FFI
04:33:03 <lambdabot> Title: Performance/FFI - HaskellWiki
04:33:08 <eivuokko> Huh?
04:34:08 <baboa> good :)
04:35:22 <baboa> thanks
05:02:06 <araujo> morning
05:02:39 <glen_quagmire> what is haskell-complete language?
05:02:50 <glen_quagmire> a language that is as good as haskell?
05:03:15 <ekidd> glen_quagmire: Sounds like a humorous way of saying that.
05:03:22 <arn> ^^
05:03:55 <glen_quagmire> but are there core sets of functionalities that make haskell haskell?
05:04:10 <glen_quagmire> like foldl ?
05:05:36 <quicksilver> higher-order functions, recursive data types, and type classes
05:05:39 <quicksilver> I guess
05:05:50 <glen_quagmire> thanks
05:06:25 <glen_quagmire> It might sound silly but i think haskell isn't purely functional. you can always put new names and bind it to a function. there, side effect.
05:06:48 <quicksilver> I don't know what you mean
05:07:10 <quicksilver> there is no 'before' and 'after' so how can there be a side-effect?
05:07:23 <quicksilver> a haskell program stands 'all at once'
05:07:31 <glen_quagmire>  //a not defined..              a = 1;    //a is there
05:07:39 <quicksilver> that's not haskell
05:07:56 <quicksilver> ah, well maybe it is
05:08:03 <quicksilver> but a is defined before, as well as after, that point
05:08:22 <quicksilver>  //a is here.....      a = 1;      // a is here, too
05:09:23 <glen_quagmire> i should study more
05:09:37 <quicksilver> example for you:
05:09:48 <quicksilver> > let { b = a ; a = 1 } in b
05:09:56 <lambdabot>  1
05:10:09 <quicksilver> you see, 'a' exists before its definition, in a sense
05:10:20 <quicksilver> to be more precise, though, the defeinitions aren't ordered at all
05:10:24 <quicksilver> there is no order, only nested scopes
05:12:35 <yakov> hi
05:13:07 <glen_quagmire> quicksilver: ah nice
05:16:19 <gattocarlo>  need help with the haskell-mode: sometimes something happens and I have to kill the ghci process...
05:16:57 <gattocarlo> ...when I start a new one and want to haskell-ghci-load-file the keyborad stop working...
05:17:11 <gattocarlo> till I press C-G
05:17:45 <gattocarlo> but if I switch to the *ghci* buffer, it works....
05:17:48 <quicksilver> I saw that once
05:17:54 <quicksilver> but I never managed to replicate it
05:17:59 <quicksilver> not quite sure what cause it :(
05:18:17 <gattocarlo> I happened to find a solution, but now I do not remember anymore...
05:18:50 <Saizan> was your ghci hanged on some error?
05:19:10 <gattocarlo> died with an error
05:19:35 <gattocarlo> the same when I kill by mistake
05:20:09 <gattocarlo> Saizan: yes
05:20:34 <Saizan> i think it happens because haskell-mode waits for ghci output to parse the error line and place your cursor at that point int he source buffer
05:20:44 <Saizan> but if ghci dies..
05:20:51 <gattocarlo> yes!
05:21:16 <gattocarlo> because it happens the same when I undo something in the *ghci* buffer and the try to load a file
05:21:43 <gattocarlo> some kind of cursor mess up?
05:22:35 <gattocarlo> what can I do? Have planty of open buffer, and cannot quit emacs now...:-(
05:22:43 <Saizan> that's what i think, but i didn't have this problem anymore when i switched to inf-haskell
05:22:57 <Saizan> you can kill the ghc process
05:23:03 <Saizan> from outside
05:24:29 <gattocarlo> Saizan: inf-haskell? can you elaborate?
05:24:49 <Saizan> @where haskell-mode
05:24:49 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
05:26:05 <Saizan> gattocarlo: is your ghci buffer called *ghci* or *haskell* ?
05:26:16 <gattocarlo> ehmmmm, sounds interesting?
05:26:26 <gattocarlo> Saizan: *ghci*
05:27:17 <Saizan> i think you need to upgrade your haskell-mode to the cvs version
05:27:49 <gattocarlo> ok
05:41:16 <gattocarlo> solved, as a mystery: I killed the buffer, unset a variable (haskell-ghci-mode-map), restarted the haskell-ghci-mode and now everything is fine
05:44:46 * dylan attempts to write an embeded haskell parser.
05:48:56 <mauke> http://dev.rubyonrails.org/ticket/8681
05:48:59 <lambdabot> Title: #8681 (Removed &#34;cocksucker&#34; from unit tests) - Rails Trac - Trac
05:49:33 <quicksilver> !
05:51:33 <xs> hi. the haskell report and the ghc documentation don't list (**) as part of the minimal complete definition of Floating. the ghc implementation implements the default (**) as x ** y = exp (log x * y). this will not work for x <= 0. is this a bug?
05:52:07 <mauke> > (-1) ** 0.5
05:52:09 <lambdabot>  NaN
05:52:36 <xs> > (-1) ** 2
05:52:37 <lambdabot>  1.0
05:52:49 <xs> but if you make your own instance of Floating
05:52:51 <xs> you get NaN
05:53:00 <xs> because the default uses log
05:53:40 <quicksilver> that's not really a bug
05:53:46 <quicksilver> it's just the default implementation
05:54:06 <quicksilver> general exponentiation is not defined for negative numbers
05:54:15 <quicksilver> if you want to try to special-case the ints, I think that's up to you
05:55:19 <xs> ah. hm. okay. thanks.
05:56:14 <quicksilver> incidentally I don't think the numeric type classes are really all that perfect
05:56:18 <quicksilver> they have plenty of rough edges
05:56:27 <quicksilver> and the rules you might imagine are violated anyway
05:56:39 <quicksilver> > abs ( negate ( 8 :: Word8) )
05:56:41 <lambdabot>  248
05:56:49 <osfameron> ah, well, it'll all be sorted in Haskell 6
05:56:53 <osfameron> oh, wait, I was thinking of Perl...
05:56:57 <xs> heh.
05:57:04 <baboa> in related question: how to convert CDouble to Double?
05:57:08 <xs> i was expecting x ** 0 = 1, but i guess not so.
05:57:22 <ndm> Igloo: is there a cabal-frustrated-users@ list, and if not (i can't find it) is cabal-devel or haskell-cafe the best place?
05:57:46 <Igloo> ndm: cabal-dev
05:57:52 <ndm> cheers
05:58:13 <quicksilver> :t realToFrac
05:58:15 <lambdabot> forall a b. (Fractional b, Real a) => a -> b
05:58:28 <quicksilver> baboa: realToFrac, IIRC
05:58:45 <quicksilver> @instances CDouble
05:58:46 <lambdabot> Couldn't find class `CDouble'. Try @instances-importing
05:59:19 * DRMacIver peers suspiciously at lambdabot 
05:59:24 <DRMacIver> That error message was almost helpful.
05:59:26 <baboa> quicksilver: thanks
05:59:27 <DRMacIver> Where's the real lambdabot?
05:59:45 <baboa> quicksilver is a real lambdabot :)
06:02:26 <baboa> @hoogle CDouble -> Double
06:02:27 <lambdabot> No matches, try a more general search
06:02:48 <quicksilver> yeah, well it doesn't have that type :)
06:03:35 <baboa> if hoogle doesn't know realToFrac, I don't know either :)
06:03:53 <Saizan> ?hoogle (Fractional b, Real a) => a -> b
06:03:55 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
06:03:55 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
06:03:55 <lambdabot> Control.Monad.State.put :: MonadState s m => s -> m ()
06:03:59 <quicksilver> hoogle does know real to frace, it just ain't that type :)
06:04:28 <ndm> '?hoogle realToFrac
06:04:31 <ndm> ?hoogle realToFrac
06:04:32 <baboa> me too :)
06:04:32 <lambdabot> Prelude.realToFrac :: (Real a, Fractional b) => a -> b
06:05:00 <baboa> anyway, how come throwError here?
06:05:13 <baboa> seems a bit unrelated...
06:09:46 * Saizan finds another bug caused by [] in derive
06:10:08 <quicksilver> baboa: I think it matches 'a -> b'
06:10:16 <quicksilver> baboa: which isn't very interesting but there you go :)
06:11:34 <baboa> all ok, only if I could make cabal talk to my haddock :/
06:20:33 <ndm> Saizan: derive? i.e. Data.Derive?
06:23:55 <Saizan> ndm: yes
06:24:13 <ndm> Saizan: details please!
06:26:42 <Saizan> ndm: lk "[]" [] :: Exp ==> VarE (mkName "[]") instead of ConE (mkName "[]") or ListE [], not sure which of the last two is the better one
06:27:58 <ndm> Saizan: probably the second one - care to send a patch?
06:28:16 <ndm> Saizan: i typically use Data.Derive as a command line program, where that makes no difference ;)
06:28:45 <Saizan> ndm: i see :)
06:29:02 <ndm> Saizan: are you developing new derivations? or using it?
06:29:04 <Saizan> ok, just one more guard to lk..
06:29:24 <ndm> yeah, its meant to accumulate all the little differences in Haskell syntax
06:30:19 <Saizan> i'm just using Helper, to parse and "prepare" some SQL queries at compile time
06:30:58 <ClaudiusMaximus> is there a libdarcs or something that other apps can use?  pondering on linear undo/redo in most editors (eg Gimp, nedit, ...) and its not-very-good-ness...
06:31:21 <ndm> cool :)
06:31:52 <dmhouse> ClaudiusMaximus: why not just use an editor with built-in version control support? Emacs, perhaps?
06:32:43 <ClaudiusMaximus> dmhouse: emacs has an image editor??
06:32:55 <dmhouse> Emacs has _generic_ VC support, so that the same bunch of keybindings can be used with darcs files, CVS files, svn files... I hit C-x v v (Ctrl+X, V, V) to record a patch to the current file, type a message, then hit C-c C-c (Ctrl+C, Ctrl+C) to record it.
06:33:08 <dmhouse> Oh, images? Sorry, I misunderstood.
06:33:13 * dmhouse wonders why you'd want to version images
06:33:24 <ClaudiusMaximus> dmhouse: same reason you'd want to version anything
06:33:31 <dmhouse> You can't get diffs, though.
06:33:40 <dmhouse> I suppose it would still work as a glorified undo tool.
06:33:44 <quicksilver> you could get diffs
06:33:53 <quicksilver> it's only that current technology doesn't work well
06:33:55 <ClaudiusMaximus> glorified undo is exactly the point
06:34:01 <dmhouse> Ah, okay then. :)
06:38:00 <KOC> I have a newbie question: I want to make a data type that is either a tuple of two strings or a string. I though data Mytype = Mytype (String, String) | String would do it, but it doesn't seem to work. Is what I want even possible?
06:38:16 <dmhouse> KOC: you need two different constructors.
06:38:16 <quicksilver> you need two names for the two alternatives
06:38:21 <quicksilver> so you can tell them apart
06:38:30 <dmhouse> KOC: data Mytype = PairOfString (String, String) | ASingleString String
06:38:30 <swiert> KOC: data MyType = One String | Two (String,String)
06:38:35 <quicksilver> data Mytype = Two String String | One String
06:38:40 <quicksilver> @quote stereo
06:38:40 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
06:38:46 <KOC> Ohhhhhh
06:38:48 <quicksilver> note that you really don't need the tuple there
06:38:54 <dmhouse> Yeah, PairOfString String String is better than PairOfString (String, String) tool
06:38:56 <dmhouse> *too.
06:38:58 <KOC> Thanks dmhouse, swiert!
06:39:00 <quicksilver> the two-argument constructor is a named tuple
06:40:03 <KOC> ok
06:40:11 <KOC> awesome
06:41:03 <dukedave> @type intersperse
06:41:05 <lambdabot> forall a. a -> [a] -> [a]
06:41:50 <dukedave> Ah, its in List :)
06:44:33 <Saizan> ndm: what do you think of lk "[]" xs | not (null xs) = lst xs ? too liberal? technically [] should not have any arguments, but..
06:45:15 <ndm> Saizan: i'm happy with whatever, i'd probably go with lk "[]" xs = ListT xs
06:45:28 <ndm> Saizan: might as well be liberal, i.e. convert errors into the most likely thing they meant
06:45:46 <ndm> also provides a neat lk "[]" [a,b] -> ListT [a,b]
06:46:11 <ndm> oh, that looks a bit weird
06:46:13 <Saizan> ok
06:46:20 <ndm> why null xs /= lst [] ?
06:46:26 <ndm> i'd have thought that was exactly what you wanted
06:46:42 <ndm> lst == ListT, so use lst (since thats our helper version)
06:47:06 <Saizan> the not . null was to stree the problem
06:47:26 <Saizan> lK "[]" xs = lst xs
06:47:44 <Saizan> s/stree/stress/
06:48:47 <ndm> oh, so lK "[]" [] gives a ConT, rather than a ListT
06:48:50 <ndm> I guess either is fine
06:49:04 <dylan> how can one match many anyChar but not "%]" with parsec?
06:49:07 <ndm> actually, ConT is probably more appropriate - so I guess your first version
06:49:47 <Saizan> dylan: noneOf "%]"
06:50:22 <dukedave> Hey any VTY hackers around here? Just writing my first toy program & I'm getting "(.text+0x1065): undefined reference to `c_get_window_size'"    :(
06:50:53 <Saizan> dukedave: are you compiling with --make?
06:50:58 <dukedave> Ah, that's because I didn't rtfm :)
06:51:15 <dukedave> Heh, yeah but missed the 'gwinsz.c' on the ghc line ;)
06:57:03 <dukedave> In a data type definition what does a ! before a type mean?
06:57:10 <quicksilver> strict
06:57:18 <quicksilver> that field can never be _|_
06:57:39 <dukedave> Ah right... That, seems wrong!
06:58:21 <SamB_XP> are you, related to captain kirk?
06:59:21 <gkr> What does ~ before an argument?
06:59:29 <dukedave> Haha well observed, maybe, I am, maybe, not    ;)
07:00:28 <quicksilver> gkr: ~ doesn't go before arguments, as such
07:00:30 <kpreid> gkr: lazy/irrefutable pattern; that case is executed without evaluating the argument yet
07:00:31 <edward1> gkr: it makes it an 'irrefutable' pattern, the idea is that the match is allowed to go ahead but haskell doesn't look at the argument until you need it.
07:00:33 <quicksilver> gkr: it goes before patterns
07:00:53 <sorear> .
07:01:03 <quicksilver> gkr: it makes it lazier, in effect, at the cost of a possible exception if the match fails
07:01:08 <edward1> i.e. if i have f ~(x,y) = 1; and then i call f undefined, i get 1, if i hadn't used ~, i'd get an error
07:01:20 <edward1> > let f ~(x,y) = 1 in f undefined
07:01:21 <kpreid> > (\(_, _) -> 1) undefined
07:01:22 <lambdabot>  1
07:01:23 <lambdabot>  Undefined
07:01:25 <kpreid> > (\~(_, _) -> 1) undefined
07:01:26 <lambdabot>  Parse error
07:01:29 <kpreid> hm
07:01:37 <edward1> > let f (x,y) = 1 in f undefined
07:01:38 <lambdabot>  Undefined
07:01:58 <edward1> you can only use ~ when there is only one case you are interested in basically.
07:02:03 <edward1> i.e. a pair has only one constructor
07:02:40 <quicksilver> I don't think you can ~-bind lambdas
07:02:47 <edward1> or you could define head ~(x:_) = x      so that you COULD take the head of an empty list as long as you don't look at it.
07:02:53 <edward1> @src head
07:02:53 <lambdabot> head (x:_) = x
07:02:53 <lambdabot> head []    = undefined
07:03:01 <sorear> quicksilver: yes you can, you just need more parens
07:03:08 <quicksilver> sorear: ah :)
07:03:10 <sorear> this is a wart in the syntax
07:04:47 <dukedave> > let toKirk = unwords $ map (++",") $ words in     toKirk "May be I am maybe I'm not"
07:04:48 <lambdabot>  Couldn't match expected type `[[Char]]'
07:04:53 <gkr> undefined is the so called bottom?
07:04:58 <Saizan> ndm: patch sent
07:05:10 <shachaf> dukedave: Use ".", not "$".
07:05:18 <quicksilver> gkr: undefined is an example of _|_
07:05:28 <gkr> Oki :-D
07:05:31 <gkr> Thanks.
07:05:32 <quicksilver> gkr: undefined is, more or less, error "undefined"
07:05:48 <dukedave> Ah yes :)
07:05:56 <dukedave> > let toKirk = unwords . map (++",") . words in     toKirk "May be I am maybe I'm not"
07:05:57 <lambdabot>  "May, be, I, am, maybe, I'm, not,"
07:06:16 <dukedave> That's a good trick to remember :)
07:06:17 <gkr> Why Haskell doesn't treat patterns as lazy by default?
07:06:23 <Japsu> @hoogle intersperse
07:06:24 <lambdabot> List.intersperse :: a -> [a] -> [a]
07:06:55 <Japsu> > unwords $ intersperse ", " $ words "May be I am maybe I'm not"
07:06:57 <lambdabot>  "May ,  be ,  I ,  am ,  maybe ,  I'm ,  not"
07:06:57 <sorear> gkr: They tried that in Miranda
07:07:03 <Japsu> oops
07:07:13 <edward1> gkr: a.) there is a performance hit, b.) it doesn't work if you have multiple cases
07:07:14 <sorear> gkr: I think it led to massive space leaks or something
07:07:17 <dukedave> Heh, Japsu, that's what I did first :)
07:07:25 <Japsu> dukedave: :P
07:07:53 <quicksilver> @src catMaybes
07:07:53 <lambdabot> catMaybes ls = [x | Just x <- ls]
07:08:00 <quicksilver> cute tricks like that don't work with lazy patterns :)
07:09:44 <ari> @src [] fail
07:09:44 <lambdabot> fail _      = []
07:19:20 <mdmkolbe|work> if zipWith is the generalization of zip, shouldn't there be a concatZipWith?
07:20:22 <dylan> hmm
07:20:35 <dmhouse> ?hoogle concatZip
07:20:38 <lambdabot> No matches found
07:20:41 <mdmkolbe|work> sorry I meant "if zipWith is the generalization of *map*"
07:20:41 <dmhouse> mdmkolbe|work: why?
07:20:47 <dylan> how can I make: normal = manyTill anyChar (try (string "[%")) -- not consume "[%"?
07:20:53 <mdmkolbe|work> @type map
07:20:59 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
07:21:00 <mdmkolbe|work> @type zipWith
07:21:02 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
07:21:07 <dmhouse> mdmkolbe|work: it's not really a generalisation.
07:21:18 <dmhouse> mdmkolbe|work: map is for unary functions, zipWith for binary. Neither is more general.
07:21:32 <mdmkolbe|work> @type zipWith2
07:21:34 <Saizan> dylan:  normal = manyTill anyChar (lookAhead . try $ string "[%")
07:21:34 <lambdabot> Not in scope: `zipWith2'
07:21:36 <mdmkolbe|work> @type zipWith3
07:21:38 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
07:21:44 <dylan> Saizan: thanks
07:21:50 <dmhouse> In fact debatebly map is more general as you can write zipWith in terms of map.
07:22:13 <ndm> Saizan: sent to where? i've not got it yet
07:22:24 <mdmkolbe|work> dmhouse: zipWith == zipWith2, map == zipWith1.  In scheme, these two are even given the same name of function (distiguished by arity).
07:22:26 <kpreid> @let zipWithN f = map f . transpose
07:22:28 <lambdabot> Defined.
07:22:50 <dmhouse> mdmkolbe|work: right, so zipWithN is a generalisation of map. zipWith isn't, though.
07:23:00 <Saizan> ndm: ndmitchell@gmail.com if darcs is telling the truth
07:23:39 <LeCamarade> Saizan: ^^ not dangerous?
07:23:48 <mdmkolbe|work> dmhouse: ok, but my original claim still remains
07:24:02 <mdmkolbe|work> @type let zipWithN f = map f . transpose in zipWithN
07:24:03 <LeCamarade> I've heard that lambdabot is part of a global conspiracy of spambots ... :o)
07:24:04 <lambdabot> forall a b. ([a] -> b) -> [[a]] -> [b]
07:24:12 <mdmkolbe|work> @type transpose
07:24:14 <lambdabot> forall a. [[a]] -> [[a]]
07:24:29 <Saizan> LeCamarade: i trust gmail spam filter a lot :)
07:24:35 <dmhouse> zipWithN isn't really a generalisation of the zipWith* functions, as it requires all the arguments to be of the same type.
07:24:44 <dmhouse> mdmkolbe|work: well, how often do you use zipWith? How much more trouble is it to wite concat (zipWith ...)? You have to draw the line somewhere.
07:24:59 <dmhouse> mdmkolbe|work: concatMap is only really defined as a single function because it's >>= in the list monad.
07:25:10 <LeCamarade> Saizan: Me too. A lot. Of course it ensures nobody out there makes me feel like a millionaire anymore ... :o(
07:25:43 <SamB_XP> dmhouse: truly?
07:26:24 <Saizan> dmhouse: concatMap is defined because it's more efficient than concat . map
07:26:35 <SamB_XP> hmm.
07:26:37 <dmhouse> ?src concatMap
07:26:37 <lambdabot> concatMap f = foldr ((++) . f) []
07:26:46 <SamB_XP> @src concat
07:26:47 <lambdabot> concat = foldr (++) []
07:26:52 <dmhouse> Saizan: with fusion they should be the same.
07:26:54 <dmhouse> ?src map
07:26:54 <lambdabot> map _ []     = []
07:26:54 <lambdabot> map f (x:xs) = f x : map f xs
07:27:23 <profmakx> @version
07:27:23 <lambdabot> lambdabot 4p532, GHC 6.6 (Linux i686 2.66GHz)
07:27:24 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
07:27:48 <SamB_XP> concatMap is more concise...
07:28:19 <SamB_XP> @pl (concat . map f) xs
07:28:20 <lambdabot> f =<< xs
07:28:24 <SamB_XP> hmm.
07:28:27 <SamB_XP> not that concise.
07:29:25 <dmhouse> map f = foldr (\x xs -> f x : xs) []
07:29:29 <dmhouse> concat = foldr (++) []
07:29:30 <quicksilver> I suspect that concatMap was added before fusion worked?
07:29:35 <mdmkolbe|work> Saizan: would the properly fused equivalent be concatZipWith f a b = concatMap f (zip a b) ?
07:29:37 <dmhouse> Two folds -> fusion, I should think.
07:29:39 <sjanssen> @src concatMap
07:29:39 <lambdabot> concatMap f = foldr ((++) . f) []
07:29:39 <dmhouse> quicksilver: probably.
07:29:55 <sjanssen> that really isn't much more efficient
07:30:41 <dmhouse> ?pl \x xs -> f x : xs
07:30:42 <lambdabot> (:) . f
07:31:19 <Saizan> mdmkolbe|work: zip doesn't fuse, iirc
07:31:44 <mdmkolbe|work> @src zip
07:31:44 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:31:44 <lambdabot> zip _      _      = []
07:31:52 <sjanssen> zip can be a good producer and a good consumer of one input IIRC
07:32:15 <sjanssen> (in foldr/build, that is)
07:32:27 <quicksilver> doesn't stream fuse though
07:32:46 <quicksilver> but dons bravely stated that he knows of a stream fusion scheme which will fuse zip
07:33:41 <sorear> uhm... the current stream fusion system can fuse zip fully
07:33:43 <sorear> it doesn
07:33:49 <sorear> 't foldr/build fuse fully
07:33:57 <ndm> i know a kind of fusion that can
07:34:03 <ndm> Supero
07:34:31 <sorear> ndm: Yeah, well, I haven't seen your paper yet :)
07:35:06 <ndm> sorear: my slides are pretty clear and have the central rules, i'm just converting to GHC's IO monad then i'll get the nobench results, then the paper comes
07:35:20 <sorear> oh, I hadn
07:35:26 <sorear> 't seen the slides.
07:35:28 <ndm> http://www-users.cs.york.ac.uk/~ndm/supero/
07:35:28 * sorear looks
07:35:30 <lambdabot> Title: Neil Mitchell - Supero
07:35:32 <ndm> fastest lambda first
07:36:00 <ndm> plus the conference season is almost over, so i'd have nowhere to send a paper
07:36:14 <ndm> there is IFL, but i think thats it
07:37:12 <pejo> ndm, would it fit PEPM?
07:37:23 <ndm> pejo: don't know, don't know much about that one
07:37:27 <ndm> @google PEPM
07:37:29 <lambdabot> http://santos.cis.ksu.edu/pepm06/
07:37:29 <lambdabot> Title: P E P M - 2 0 0 6
07:37:45 <ndm> yes, it probably would
07:37:56 <pejo> Well, it's the partial evaluation people. But they ar einterested in working things.
07:38:09 <DRMacIver> I originally read that as "Neil Mitchell - Superhero"
07:38:11 <quicksilver> ndm: damn it, is there no interesting area of haskell research on which you have not got a project? :)
07:38:17 <Saizan> do you have optimizations up to -O10 in yhc?
07:38:27 <pejo> (And a good excuse to go to POPL, if you need one).
07:38:30 <ndm> pejo: that looks pretty good, actually - thanks!
07:38:45 <ndm> quicksilver: do you consider type systems interesting?
07:39:14 <ndm> Saizan: they are -O100, but non-terminating and not safe at the moment, the challenge is to dial them down
07:40:32 <sorear> ndm: bah, I invented the idea indepenendly :(
07:40:45 <ndm> sorear: with the church encoding trick as well?
07:40:47 <sorear> ndm knows when to persue...
07:40:49 <sorear> yeah
07:41:00 <ndm> its a neat trick :)
07:41:00 <sorear> didn't get to pretend though
07:41:16 <ndm> did you have any ideas on termination?
07:42:01 <ndm> since the algorithm isn't overly terminating if you just fire it off...
07:42:04 <sorear> yeah.  I realized that if my algorithm worked and always terminated it would solve the halting problem
07:42:31 <sorear> which is usually a good sign it won't :)
07:42:35 <pejo> ndm, for stopping the transformation?
07:42:35 <ndm> indeed :)
07:42:40 <ndm> pejo: yes
07:42:48 <pejo> ndm, looked at the homeomorphic embedding?
07:43:23 <ndm> pejo: just printing a paper on it, thanks
07:43:52 <pejo> ndm, Leuschel (sp?) has work on "better" ones.
07:44:05 <ndm> http://citeseer.ist.psu.edu/196231.html
07:44:06 <lambdabot> Title: Homeomorphic Embedding for Online Termination - Leuschel (ResearchIndex)
07:44:10 <ndm> that was my first hit, which is that guy
07:44:16 <pejo> Oh, heh. Yeah.
07:46:32 <sorear> ndm: typo in the slides
07:46:38 <sorear> count n (x:xs) | n == x = 1 + count xs
07:46:42 <sorear> type erorr!
07:47:46 <sorear> ndm++ brilliant as always.
07:49:48 <edward1> ndm i like, how much of a hit has it proven to be on compile times?
07:50:04 <edward1> i'm already doing some pretty horrendous whole program optimizations and this seems to dovetail nicely
07:50:11 <Syzygy-> Homeomorphic embedding of what in what?
07:50:15 * Syzygy- smells topology....
07:51:03 <edward1> as for termination checking, i've been looking into the near-concrete interpretation and the approach the microsoft terminator guys have been using, but thats in a slightly different problem domain.
07:51:27 <edward1> as i'm using it to check if the program i'm compiling (or the calculation in question) will terminate.
07:52:01 <pejo> Syzygy, terms in terms, for this case I guess.
07:52:22 <Syzygy-> pejo: So ... how on earth do you get homeomorphisms -there-??
07:52:25 <pejo> Syzygy, it goes back to some work by Kruskal in the 60's iirc. Something about Vasalis (sp?) conjecture.
07:52:31 <Syzygy-> o.O
07:53:35 <pejo> Syzygy, the layman pov on the homeomorphic embedding we're talking about here is essentially if one term embeds another one.
07:53:59 <Syzygy-> I want to see a topology dammit! ;)
07:54:04 <pejo> Syzygy, I know nothing about topology though, so you need to either read the paper or ask better questions. :-)
07:54:47 <pejo> (I found the Kruskal one rather hard to read. The stuff by Leuschel is very nice and easy though).
07:55:29 * LeCamarade doesn't even know how to pronounce them names, for starters.
07:56:21 <LeCamarade> Schöernfinkel ...
07:58:47 <sorear> LeCamarade: Too many e
07:58:48 <sorear> 's
08:00:13 <sorear> Ã¶ and oe are the same letter, Ã¶e is something completely different
08:00:33 <LeCamarade> Oh.
08:00:49 <LeCamarade> They never write their names in Haskell. X-(
08:01:12 <LeCamarade> Someone write a LOLCODE implementation in Haskell! Parsec power, anyone?
08:01:33 <Syzygy-> If, then I'd prefer to wait for the specification to settle. :P
08:01:38 <Syzygy-> But that's just me.
08:01:40 <ndm> edward1: still compiles fast enough, i do all the compilation using Hugs
08:01:45 <DRMacIver> The problem with lolcode is that it's semantically very very boring. :)
08:01:57 <ndm> sorear, well spotted - but never mind - not that serious
08:02:16 <edward1> neil: any asymptotic estimate of practical cost relative to program size yet? or not stable enough for that?
08:03:47 <ndm> edward1: my guess is linear in the resultant program, which should be related to the size of the original
08:03:56 <edward1> nice
08:04:08 <edward1> definitely going to read those slides more carefully then =)
08:04:15 <edward1> ETA for a paper? =)
08:04:46 <ndm> I'm hoping to have the code done in "not too long" - perhaps a month, maybe a bit more
08:04:52 <edward1> nice
08:04:56 <ndm> paper draft should be coming after that
08:05:00 <ndm> its the final chapter of my phd
08:05:23 <Igloo> The last one numerically, or the last one you have to write?
08:05:23 <ndm> depends - if either Uniplate or Catch get accepted/rejected from HW I either have to revise or not, so they may eat up that time
08:05:27 <edward1> i like the first-order transformation part
08:05:30 <ndm> last one to write
08:05:32 <pejo> ndm, do you have a figure with all rules in one place btw?
08:05:37 <ndm> pejo: no
08:05:45 <Igloo> Cool
08:05:48 <ndm> pejo: the rules need crisping up as well
08:05:58 <ndm> my PhD is: Uniplate, Supero, Catch, in that order
08:06:18 <ndm> since you need Supero to make things first order so Catch can work on them
08:06:21 <Igloo> What's Supero?
08:06:26 <Igloo> Oh, -O11?
08:06:32 <ndm> and without Uniplate its impossible to do much transformation
08:06:35 <ndm> yes, -O11
08:08:24 <sorear> ndm: I wonder if it would make more sense to factor out the firstifier into its own section, then demonstrate two unrelated but equally cool uses of it.
08:09:02 <ndm> sorear: possibly, depends how much extra gets into the optimiser - it may literally be an invokation of the firstifier twice
08:17:22 <Modius> Got a situation for which I can't think of a clean functional solution - imagine values whose total is reconciled against some tiered result.  A product can span multiple tiers.  A list of products must be reconciled against the tiers with product entries potentially split between tiers (one entry for each)
08:18:04 <sorear> @all-dict tiered
08:18:05 <lambdabot> *** "tiered" wn "WordNet (r) 2.0"
08:18:06 <lambdabot> tiered
08:18:06 <lambdabot>      adj : having or arranged in tiers; "a tiered mound"
08:18:07 <fasta> Why can I use "put undefined" in a do block that evaluates to a value of type Control.Monad.Cont.ContT a m a? I am asking, since I also use some ST computations in this block, but these need to be lifted to get a value of type *T.
08:18:19 <fasta> I guess there are some instances that take care of this.
08:18:22 <fasta> Which ones?
08:18:57 <sorear> Modius: What does tiered mean in this context?
08:19:03 <Modius> Sorry, I'll give a concrete example
08:19:07 <fasta> MonadState s m => MonadState s (ContT r m) <- probably this one
08:20:27 <Modius> Everything under $1M is in category "A".  Everything $1M-$2M is in category "B" - everything $2M+ is in category "C".  First product is $700K.  Second is $700K.  Third is $700K.  First is all in category A.  Second, $300K is in A, $400 is in B.  For third, $600K is in B, $100K in C
08:22:00 <Modius> I'm after either some (haskell goodie I don't know about) or a functional approach to splitting these products up into their successive contributions to each tier/level.
08:22:45 <Modius> I can do it imperative; but big deal.  I can make a bit of a messy thing from the imperative in functional; but it's kind of long.  I figure there's a clean way; but it'll involve something new having to go into my mental toolbox
08:23:22 <mdmkolbe|work> fasta: is it giving an ambiguity error or something else?
08:23:48 <sorear> Oh, so like
08:24:22 <sorear> > sum $ filter (<100) $ filter (>10) [1,2,5,12,24,36,120,1000]
08:24:24 <lambdabot>  72
08:24:27 <sorear> ?
08:25:54 <Modius> The result I'd be fishing for is something like ("First" (("A" 700K))) ("Second" (("A" 300K) ("B" 400K"))) ("Third" (("B" 600K) ("C" 100K)))
08:27:54 <fasta> mdmkolbe|work: no, it's working. I was surprised that it did, but the instance I shown above it probably the reason.
08:28:33 <fasta> s/it/is
08:29:09 <edward1> > sum $ filter (liftM2 (&&) (<100) (>10))  [1,2,5,12,24,36,120,1000]
08:29:10 <lambdabot>  72
08:30:12 <fasta> > trace "hi" "man"
08:30:13 <lambdabot>   Not in scope: `trace'
08:30:18 <fasta> > Debug.trace "hi" "man"
08:30:19 <lambdabot>   Not in scope: `Debug.trace'
08:30:36 <fasta> What's dangerous about Debug.trace?
08:31:11 <sorear> Huh?
08:31:15 <edward1> fasta: well, it probably prints to dons' standard output rather than channel for one
08:31:17 <sorear> it doesn't exist
08:31:21 <edward1> =)
08:31:23 <sorear> Debug.Trace.trace
08:31:31 <fasta> sorear: good point
08:31:38 <fasta> > Debug.Trace.trace "hi" "man"
08:31:39 <lambdabot>   Not in scope: `Debug.Trace.trace'
08:32:12 <fasta> edward1: another good point
08:32:58 <fasta> Do you know whether Emacs supports an operation to remember the current position with one key, and then when pressed another key to jump to that position?
08:32:58 <mdmkolbe|work> @index trace
08:32:59 <lambdabot> Debug.Trace
08:33:39 <sorear> fasta: C-SPC then C-x C-x
08:35:08 <fasta> sorear: that doesn't work when I select a region
08:35:21 <fasta> sorear: I mean something specifically designed for that purpose.
08:36:38 <quicksilver> yes, C-SPC is that thing
08:36:46 <quicksilver> it doesn't matter if you select a region later
08:36:56 <quicksilver> you can flick through a 'ring' of previous points
08:37:16 <quicksilver> with C-u C-SPC
08:38:07 <quicksilver> there is also bookmark-set, for something a bit more heavyweight (named and persistent if you want)
08:38:30 <sorear> > let{ cutInterval (l,h) = [ (c,h'-l') | (c,il,ih) <- [('A', id, min 1000000), ('B', max 1000000, min 2000000), ('C', max 2000000, id)], let h' = ih h, let l' = il l, h' > l' ] ; tally = map cutInterval . ap zip tail . scanl (+) 0 }in tally [700000, 700000, 700000]
08:38:32 <lambdabot>  [[('A',700000)],[('A',300000),('B',400000)],[('B',600000),('C',100000)]]
08:38:47 <sorear> wow, it worked the first time!
08:38:52 <sorear> Modius: ?
08:40:28 <fasta> quicksilver: yes, I know bookmark-set, but it's not practical for this, imho.
08:40:41 <fasta> quicksilver: thanks
08:41:47 <Modius> Sorear:  Thanks!
08:42:20 <Modius> Sorear:  It'll take a while for me to digest it - but it sure looks general purpose
08:44:30 <Modius> What's  id in this solution?
08:45:17 <quicksilver> he's using functions to represent min and max cutoffs
08:45:28 <andun> fasta: C-x r SPC <key>, and C-x r j <key> to jump back
08:45:43 <quicksilver> min 1000000 <your number here>
08:45:57 <quicksilver> is the 'maximum' for the first tier
08:46:41 <quicksilver> so id <your number here> is just <your number>
08:46:48 <quicksilver> which is the right thing for the two ends of the tiers
08:47:54 <cdsmith> Is there any reason I should expect to not be able to build HaXml with GHC HEAD?
08:48:33 <Igloo> base splitup possibly - what's the problem?
08:49:13 <cdsmith> It's running  ghc --make -cpp -i. -package base -package-name HaXml -i..  DtdToHaskell and expecting to get a a.out, but ghc isn't producing one.
08:49:42 <Igloo> It'll get DtdToHaskell nowadays - both HEAD and 6.6.1
08:50:21 <cdsmith> Actually, I just get a .hi and .o
08:51:04 <Igloo> Does it contain module Main?
08:51:20 <cdsmith> DtdToHaskell.hs is module Main
08:52:08 <Igloo> What does the command print?
08:52:21 <cdsmith> The ghc command?  There is no output.
08:52:27 <Igloo> Oh, wait, -package-name HaXml shouldn't be there
08:52:46 <cdsmith> Okay.  That's odd that it would be, then.
08:52:59 <Igloo> That sounds like a hack to avoid recompilation, but GHC wants Main.main to be in package main
08:53:50 <cdsmith> Okay, that does it.  Thanks.
08:54:11 <ndm> how do i tag a uniplate version
08:54:24 <sorear> darcs tag uniplate-1.0
08:54:25 <sorear> ?
08:54:25 <ndm> i'm pretty sure i added the tag, but i can't remember how to make --partial only go up to that version
08:54:40 <sorear> darcs optimize --checkpoint    after tagging
08:55:11 <ndm> thanks, got it now
08:55:17 <ndm> i forgot that --checkpoint last time
08:57:13 <shapr> @yow !
08:57:14 <lambdabot> Yow!  Am I in Milwaukee?
08:57:15 <sorear> SyntaxNinja: hi
08:57:33 <sorear> SyntaxNinja: how's the community.h.o project doing?
09:06:50 <emu> sorear: "It works!"
09:07:01 <sorear> emu: Context lost.
09:07:09 <emu> community.h.o
09:07:14 <sorear> I see.
09:08:52 <sjanssen> how does one get an account?
09:09:06 <sorear> SyntaxNinja i think?
09:09:40 <sjanssen> I wouldn't mind moving xmonad to c.h.o if that means jcreigh can have an account
09:10:02 <bos> http://community.haskell.org/admin/account_request.html
09:10:03 <lambdabot> Title: Account Request
09:10:13 * shapr boings cheerfully
09:10:18 <bos> it's early days yet.
09:10:20 <sorear> sjanssen: doesn't he already have a gcode acct?
09:10:32 <bos> shapr: did you see my privmsg about epoll the other day?
09:10:50 <sjanssen> sorear: yeah, but gcode doesn't host the darcs repo
09:10:55 <ndm> sjanssen: can't you add him to your authorized keys file on darcs.haskell.org
09:10:56 <sorear> oh.
09:11:37 <sjanssen> ndm: I'd rather not do that
09:11:48 <sjanssen> for one, that gives jcreigh write access to ghc
09:12:05 <ndm> sjanssen: you don't want to see the number of people who are on my authorized keys lists :)
09:12:11 <ndm> sorear is just one of the many
09:12:16 <shapr> bos: Not sure, can you send it again?
09:12:23 <ndm> sjanssen: do you trust him? if so, i don't think its a problem
09:13:37 <bos> shapr: i was just saying that i'm hoping to replace select with a library that uses epoll or whatever's appropriate
09:14:13 <bos> need to write the library first, though. the existing libraries that try to be portable also want to take over the even loop completely, which is a bit rude.
09:15:33 <shapr> bos: I've forgotten the details of the problem, is there a one line summary? epoll is better than select for socket stuff?
09:15:46 <bos> yeah, select is hopeless for scaling.
09:16:25 <emu> it is limited by FD_SETSIZE
09:16:47 <bos> not only that, but it can't be implemented efficiently.
09:17:34 <cdsmith> ??? "Something is amiss; requested module  HaXml-1.13.2:Text.XML.HaXml.Types differs from name found in the interface file HaXml:Text.XML.HaXml.Types"
09:18:01 <bos> cdsmith: are you mixing versions of HaXml by accident?
09:18:14 <cdsmith> I only have one version of HaXml
09:18:24 <sjanssen> ndm: sure, I trust him
09:18:32 <sjanssen> ndm: but d.h.o is generally consided d
09:18:37 <sjanssen> eprecated, AIUI
09:18:49 <cdsmith> bos: I did just kludge a bunch of things to get HaXml to build.  Is there something I might have screwed up there?
09:19:07 <ndm> sjanssen: i understand what you are saying - it was really weird adding unknown people to my authorised_keys at first
09:19:48 * ndm finds that two concurrent builds of Yhc slows down his computer
09:20:00 <bos> cdsmith: yeah, if you had to kludge stuff, something's probably borked.
09:20:11 <bos> cdsmith: Haxml ought to build cleanly
09:20:32 <cdsmith> bos: HaXml definitely did not build cleanly; but I think the problems were all in building the tools.
09:21:20 <cdsmith> bos: Oh, and I had to mkdir the ghc-6.7.2007.../imports directory by hand.
09:22:19 <bos> oh, you're building with GHC head? brave chap.
09:22:30 <cdsmith> bos: Yeah, I am.
09:22:58 <cdsmith> bos: This looks like the last hump before I get HAppS running with GHC head.
09:23:10 <SyntaxNinja> sorear, sjanssen: keep your eyes peeled for an announcement :)
09:23:58 <SyntaxNinja> the machine is up, getting configured, we're figuring out how to deal with accounts and groups... Igloo and malcolmw might have more infol.
09:24:26 <sjanssen> okay, I'll wait for an announcement
09:24:36 <chessguy> what's the worst that can happen with HEAD?
09:25:00 <dcoutts> chessguy: it might eat you?
09:25:13 <chessguy> that would be pretty bad
09:25:14 <Saizan> eat all your ram while compiling?
09:25:29 <chessguy> i'd have to give it indigestion
09:25:38 <dcoutts> it might curry you
09:25:58 <sorear> chessguy: HEAD is known to silently miscompile things and sow bugs that eat your data months later.
09:26:20 <chessguy> yikes
09:26:22 <cdsmith> chessguy: the biggest thing, in practice, is that you have to change a bunch of .cabal files because base was split up.  I ran into one case where I had to build with -Onot to prevent a compiler crash.  Other than that, it seems usable.
09:28:43 <Saizan> will ./darcs-all pull get the base splittage done right?
09:30:09 <mdmkolbe|work> @where HApps
09:30:10 <lambdabot> http://happs.org
09:30:31 <sorear> Saizan: ./darcs-all --extra get
09:30:41 <sorear> which WILL skip directories you already have
09:46:30 <mdmkolbe|work> Is there a comparisen of HAppS against twistd anywhere?
09:48:10 <fasta> mdmkolbe|work: probably HAppS has a design?
09:48:27 <fasta> Seriously, I don't know.
09:50:53 <shachaf> mdmkolbe|work: Isn't Twisted Python?
09:51:19 <shachaf> mdmkolbe|work: (And isn't Python twisted?) :-)
09:51:37 <shachaf> mdmkolbe|work: Why did you specifically pick those two?
09:51:51 <mdmkolbe|work> shachaf: yep (it's python), it's actually very popular b/c it has a nice module structure
09:54:18 <mdmkolbe|work> shachaf: twisted is probably the one to beat, because of the niche they both fill (application server that has a slightly off-beat modular archetechure and is thus "better") and because twiested is what I imagine most people that see HAppS will compare it to when evaluating it
10:02:31 <dcoutts> @localtime dons
10:02:33 <lambdabot> Local time for dons is Thu Jun 21 03:01:32 2007
10:02:38 <dcoutts> oh well
10:03:14 * dcoutts is very confused about the relation between his own time zone and everyone else's
10:03:49 <Syzygy-> @localtime dcoutts
10:03:50 <lambdabot> Local time for dcoutts is Wed Jun 20 18:02:49
10:03:59 <Syzygy-> dcoutts: UK?
10:04:05 <dcoutts> Syzygy-: actually that's wrong
10:04:17 <dcoutts> I've just not changed my clock on this laptop
10:04:34 <dcoutts> currently in US central time
10:04:38 <Syzygy-> So what -is- your time zone? Ah.
10:04:50 <dcoutts> it's midday atm
10:04:50 <ndm> i need Gtk2Hs!
10:05:05 <ndm> i'm supervising a SoC student and can't see what they are doing until you release a package for 6.6.1
10:05:29 <dcoutts> ndm: la la la, can't hear you, what a nice holiday I'm having... :-)
10:05:35 <opqdonut> :D
10:05:40 <dcoutts> ndm: they can't just use 6.6?
10:05:47 <ndm> dcoutts, they can, i can't
10:05:57 <ndm> they are on windows, they are fine
10:06:19 <ndm> i've not got enough disk space for multiple installations etc, and can't downgrade for various reasons
10:06:27 <opqdonut> :)
10:07:04 <ddarius> ndm: How do you not have enough disk space?
10:07:07 <dcoutts> ndm: actually I did try before I went away, but the win2k3 server I normally have access to was down
10:07:26 <dcoutts> I'll see if it's up when I get back in a week
10:07:28 <ndm> ddarius: i don't have much disk space on any of my machines, most i can't open up
10:07:33 <ndm> dcoutts, cheers :)
10:07:36 <ndm> @karma- dcoutts
10:07:36 <lambdabot> dcoutts's karma lowered to 47.
10:07:43 <ndm> you'll get 2 karma points when you fix gtk2hs
10:07:49 <ndm> thats an incentive for you ;)
10:07:55 <dcoutts> it build from source just fine :-)
10:08:07 <ndm> do you think i have enough disk space for the source code?
10:08:17 <dcoutts> but I guess you don't have enough disk space for mingw :-)
10:08:18 <ddarius> ndm: What is taking up all your disk space?
10:08:26 <sorear> it should be about 0.5% of the size of windows
10:08:33 <ndm> ddarius: my work, visual studio, other stuff
10:08:53 <byorgey> buy a cheap external HD?
10:08:54 <ddarius> ndm: Do you have a 1GB hard drive or something?
10:09:07 <ndm> ddarius: two 10Gb ones on this machine
10:09:12 <ndm> byorgey: lazy :)
10:09:24 <arcatan> may the source be with you
10:09:25 * dcoutts starts the ndm starving hacker fund
10:09:27 <ndm> its an intention, but i never get round to actually doing it
10:09:42 <dcoutts> ah, not if you're just lazy :-)
10:09:46 * ndm contributes, its a worth cause
10:09:59 <ndm> well, not this year - come September i have no funding (yay!)
10:12:51 <bos> ndm: have you started writing up yet?
10:13:15 <ndm> bos: no, but i have 2 papers submitted to HW, both of which will be chapters, and both of which have had all the work done on them
10:13:21 <ndm> then its just one chapter left
10:13:40 <bos> ]cool.
10:13:49 <bos> decided what you want to do afterwards?
10:13:53 <dcoutts> same here, more or less
10:14:07 <dcoutts> one more chapter after the two papers which will be chapters
10:14:25 <ndm> get some form of income which i can use to live on
10:14:33 <ndm> anyone want to offer me a research position?
10:14:44 <bos> ah, autumn's fresh crop of new phds :-)
10:15:27 <dcoutts> ndm: If I had a research budget I'd hire you and me to hack on Haskell tools, like IDEs and tool integration things :-)
10:15:38 <byorgey> ndm: does it have to be a paid research position? =)
10:15:43 <bos> i gather the deans of cs depts don't hang out on irc any more. they've all moved to second life so they can be furries.
10:15:54 <dcoutts> heh heh
10:15:56 <ndm> dcoutts, cool :) - any chance of either of us getting a research budget for years yet...
10:16:05 <ndm> byorgey: yes, i hope!
10:16:06 <dcoutts> ndm: nope :-)
10:16:23 <ndm> i wonder if i could get a research project to hack on hoogle
10:16:40 <dcoutts> ndm: unless we go and get rich
10:16:46 <bos> if you don't mind actual jobs, i know at least three companies hiring leet haskell haxxors
10:16:48 <ndm> i could call it e-learning in a distributed manner
10:17:16 <dcoutts> bos: I know of 2, plus Jane St probably
10:17:28 <dcoutts> but, ugg, ocaml
10:17:29 <ndm> bos: i'll be looking for one of those real jobs if i can't find anything academic - but not for a while yet
10:17:33 <bos> yeah, but yaron will make you use ocaml
10:18:07 <Excedrin> I read that they're using MLton at Jane St
10:18:27 <bos> no, it's ocaml
10:18:36 <Excedrin> perhaps only since hiring Stephen Weeks, but either way, I prefer SML to OCaml
10:22:43 <Saizan> uh, what darcs diff should make the diff against? my repo and the one where i pulled from?
10:23:02 <sorear> Saizan: Don't use darcs diff without a good reason!
10:23:18 <sorear> Saizan: it shows your unrecorded changes
10:23:29 <sorear> Saizan: but don't dare use it to make a patch
10:23:38 <sorear> Saizan: that's very very bad darcs practice
10:24:03 <sorear> Saizan: oh wait, you contributed to derive, you must know how to use darcs.  nm
10:24:20 <sorear> Saizan: darcs diff is fine for sending patches to unenlightened people
10:25:06 <ndm> Saizan: i still haven't seen your derive patch...
10:25:09 <Saizan> sorear: i wanted some way to tell which are the differences between my local copy and the remote one
10:25:27 <sorear> Saizan: darcs send -o /dev/null
10:25:36 <sorear> Saizan: that will list patches you have and they don't
10:25:49 <Saizan> sorear: non-recorded things?
10:26:03 <sorear> Saizan: do you know how to record changes?
10:26:34 <sorear> Saizan: if not, go to darcs.net and read the manual; I don't want to rewrite it, especially in an editor as poor as irssi :)
10:26:57 <ndm> hmm, i want a Monad _without_ return
10:27:24 <Saizan> sorear: i know how, but i don't want to, however i'll read the manual :)
10:27:49 <sorear> Saizan: you have to record changes before you can send them.
10:27:57 <Saizan> ndm: i'll try sending it manually, the email address from before is fine, right?
10:28:04 <sorear> Saizan: why!?
10:28:09 <sorear> Saizan: record, then send
10:28:10 <ndm> Saizan: ndmitchell -at- gmail.com
10:28:20 <sorear> Saizan: fully automatic, no need to type addrsses!
10:28:23 <Saizan> sorear: the darcs diff issue is totally unrelated
10:28:28 <sorear> Saizan: darcs is not CVS
10:28:38 <sorear> oh.
10:29:00 <Saizan> sorear: i did that but ndm didn't receive the patch, so now i've darcs send -o foo.patch
10:33:37 * shapr boings cheerfully
10:33:55 <Saizan> ndm: re-sent, if it doesn't work i think i'll just paste the 2 lines in your query :D
10:34:06 <shapr> @quote bos
10:34:06 <lambdabot> bos says: [dons] and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing [bos] um, is that next to the dilithium crystals?
10:34:12 <shapr> @quote bos
10:34:13 <lambdabot> bos says: i gather the deans of cs depts don't hang out on irc any more. they've all moved to second life so they can be furries.
10:35:15 <LeCamarade> @quote bos
10:35:15 <lambdabot> bos says: algorithm analysis is generally questionable. most of the people who write analyses are analysing the compexity of their own algorithms, and have an axe to grind.
10:35:21 <LeCamarade> I'm liking this.
10:35:26 <ndm> @karma+ Saizan -- received successfully and pushed
10:35:26 <lambdabot> Saizan's karma raised to 3.
10:35:53 <LeCamarade> I'm liking this.
10:35:54 <LeCamarade> @quote bos
10:35:55 <lambdabot> bos says: [dons] and stricify, specialise and inline as appropriate till the raw bytestring Addr# start appearing [bos] um, is that next to the dilithium crystals?
10:36:41 * esap has been thinking about Cantor's diagonalization proof again...
10:37:33 <SamB> some people have their algorithms to grind ;-)
10:43:26 <crazy_coder> I want to out a list recursivley
10:43:31 <crazy_coder> how to do that.
10:43:35 <shapr> out?
10:43:39 <crazy_coder> fibo 0 = 1
10:43:39 <crazy_coder> fibo 1 = 1
10:43:39 <crazy_coder> fibo n = (fibo (n-1)  + fibo (n-2))
10:44:01 <crazy_coder> now problem is that I want a list of all fibonacci numbers
10:44:34 <shapr> crazy_coder: I haven't seen a computer that has enough memory/drive/etc to list all the fibonacci numbers. It's an infinite list.
10:44:55 <crazy_coder> yeah an infinite list containing n number of elements
10:45:00 <LoganCapaldo> map fibo [0..]
10:45:02 <crazy_coder> fibo n
10:45:26 <LoganCapaldo> take n $ map fibo [0..]
10:45:38 <crazy_coder> oh I don't  know map
10:45:41 <crazy_coder> Lets see
10:45:51 <LoganCapaldo> @type map
10:45:53 <shapr> > let fibo 0 = 1; fibo 1 = 1; fibo n = (fibo (n-1)  + fibo (n-2)) in fibo 5
10:45:54 <crazy_coder> can't change something in the above code
10:45:56 <lambdabot>  8
10:46:05 <crazy_coder> to make it work as a list ?
10:46:06 <lambdabot> thread killed
10:46:11 <LoganCapaldo> crazy_coder: sure you can
10:46:23 <shapr> > let fibo 0 = 1; fibo 1 = 1; fibo n = (fibo (n-1)  + fibo (n-2)) in map fibo [1..5]
10:46:31 <shapr> hmm
10:46:33 <lambdabot>  [1,2,3,5,8]
10:46:43 <crazy_coder> oh Thanks
10:46:52 <shapr> crazy_coder: question is.. do you understand what I did?
10:47:02 <crazy_coder> Can't we do something using  :  ?
10:47:04 <LoganCapaldo> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
10:47:04 <lambdabot>  Parse error
10:47:05 <oerjan> > let fibo 0 = 1; fibo 1 = 1; fibo n = (fibo (n-1)  + fibo (n-2)) in fibo 30
10:47:11 <LoganCapaldo> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs) in fibs
10:47:13 <lambdabot>  1346269
10:47:23 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
10:47:29 <chr1s3> hey all!
10:47:35 <sorear> hi!
10:47:35 <shapr> hoi chr1s3
10:47:42 <byorgey> hi chr1s3
10:47:47 <chr1s3> How do I execute a system command and fetch the output?
10:47:53 <crazy_coder> hi chr1s3
10:47:56 <sorear> @where newpopen
10:47:56 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
10:48:01 <sorear> dons' lib
10:48:11 <chr1s3> I'm aware of system, but that seems to return only an returncode
10:48:23 <chr1s3> ok, thanks, I'll have a look
10:48:54 <LoganCapaldo> chr1s3: if you want to be hacky about it system "foo > /tmp/bar" ; readFile "/tmp/bar"
10:49:01 <LoganCapaldo> but yeah popen waaay cooler :)
10:49:48 <chr1s3> why isn't this in any StdLib? I think it's pretty lame, isn't it?
10:50:15 <chr1s3> (I don't think dons's code is lame, the fact that it isn't in the stdlibs)
10:50:30 <sorear> chr1s3: Because we're trying to shrink the stdlib atm :)
10:51:00 * shapr boings happily and cheerfully
10:51:02 <shapr> Yay code!
10:51:36 <arcatan> Internets is full of code
10:51:48 <Syzygy-> shapr: Did I show you my mathematician paper?
10:51:52 <shapr> Syzygy-: No, show me!
10:51:57 <Syzygy-> The one that's a Haskell program too...
10:52:01 <arcatan> Show me, show you, Kikkoman!
10:52:01 <shapr> oooh
10:52:10 <Syzygy-> http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
10:52:15 <shapr> arcatan: HAMPURILAINEN!
10:52:34 <Syzygy-> I need feedback from one mathematician who I seem to be contradicting with my findings there, but then I'll go off and prepare it for publication.
10:52:54 <shapr> (I want kikkoman on my hampurilainen please)
10:53:24 <arcatan> I want kikkoman in my wok please
10:53:36 <shapr> Syzygy-: I've never heard of those these guys or their diagonal, but the literate Haskell parts is way spiffy.
10:54:12 <shapr> Syzygy-: Also, I'm *far* more impressed with math papers that include executable code so I can play with 'em.
10:54:28 <Syzygy-> shapr: Umble is a mathematician in northeast US, Saneblidze a mathematician in T'bilisi, Georgia, and their diagonal is a very important tool in my corner of mathematics.
10:54:50 <shapr> Er, not the Georgia next to me, right?
10:54:52 <Syzygy-> And I'm going to bug whatever journal publishes me to get the .lhs and possibly a cabal distribution published on the web together with the paper itself.
10:55:29 <arcatan> permutahedron sounds evil
10:55:44 <arcatan> it's coming.. and it's going to permute you!
10:55:55 <Syzygy-> shapr: The .lhs is up now at ibid.lhs
10:56:19 <shapr> Syzygy-: This is way spiffy, I can actually understand this from reading the code!
10:56:21 <Syzygy-> So that you can play with it. :)
10:56:26 <Syzygy-> BWAHAHAHA! Great!
10:56:45 <Syzygy-> shapr: Btw - a Haskellite-rewritten version of this was the thing I was fishing for publication venues for the other day.
10:56:46 <shapr> I don't understand so much of why, but I do understand what.
10:57:59 <shapr> Syzygy-: What about TMR?
10:58:20 <Syzygy-> TMR?
10:58:28 <Syzygy-> Oh, yeah, The Monad Reader...
10:58:29 <shapr> The Monad.Reader
10:58:32 <Syzygy-> Yeah, it'd be good there.
10:58:34 <Syzygy-> One version at least.
10:59:04 <Syzygy-> But I wouldn't mind an academic-pointed version of it, with focus on how to prove correctness for algebraic programs.
10:59:35 <Syzygy-> The TMR I would imagine would end up focusing much more on "Look, pretty polytopes! And nifty things we can do with them! And the reasons we care!"
10:59:37 <LoganCapaldo> undefined is such a useful function. hooray undefined
10:59:55 <Syzygy-> But I may just have misunderstood the scope of TMR.
10:59:56 <shapr> But you'd also get to discuss correctness.
11:00:28 <Syzygy-> Sure.
11:00:36 <shapr> Well, the scope of TMR when it started was "more than a wiki page, but less than a full FP journal article."
11:01:07 <Syzygy-> Yeah.
11:01:19 <Syzygy-> And I think I might be able to swing a journal article with this.
11:01:24 <shapr> Yeah, I think so too.
11:01:48 <Syzygy-> However, I don't quite have the intuition for CS publishing, so I'd have to rely on outside judgement for that.
11:01:53 <shapr> If you added some Coq -> Haskell generative stuff you could definitely publish it for ICFP/HW
11:01:57 <Syzygy-> But it feels like it.
11:02:00 <Syzygy-> Coq?
11:02:10 <shapr> The proof assistant Coq
11:02:14 <Syzygy-> That's that automated prover thingie?
11:02:16 <shapr> yup
11:02:19 <Syzygy-> Gods. Another thing to learn.
11:02:48 <shapr> I'm excited about the idea of building an assisted proof in Coq or whatever, and then generating Haskell source from that.
11:03:47 <shapr> But I read (three years ago?) one paper where someone generated executable fibonacci series code from Coq and it took two or three days for the generated code to get fib 8.
11:04:47 <|Steve|> Why a journal paper?
11:05:11 <sorear> he was running this on a 4004 with network attached storage over IP/avian-carriers?  :)
11:05:36 <Syzygy-> |Steve|: That or conference presentation. I want it to generate cred for me and my future PhD degree. :P
11:05:42 <shapr> In the academic community, peer respect and monetary income is based on the number and quality of the papers that you publish.
11:05:45 <shapr> 'publish or perish'
11:05:52 <|Steve|> Conference papers are the way to go in CS.
11:05:58 <Syzygy-> Right.
11:06:04 <|Steve|> Unlike every other field, journal papers don't mean much for some reason.
11:06:25 <Syzygy-> I have already concluded that all the sane conferences this year happen in the wrong place at the wrong time. But I could always go later.
11:06:41 <|Steve|> There were like 10 conferences in San Diego last week.
11:07:07 <shapr> Syzygy-: Too bad you'll be out of the EU when ICFP is happening.
11:07:08 <sorear> And I missed all of them? *gulp*
11:07:12 <Syzygy-> That said, I'm a mathematician who's going to tie in a little trickle of CS publishing. There might be a point to make for publishing the CS stuff in a way that the CS community would notice, but in my home discipline, journal papers are the important things.
11:07:15 <shapr> sorear: Are you in San Diego?
11:07:17 <Syzygy-> shapr: Yeah. I'm a bit miffed about that.
11:07:25 <sorear> shapr: Yep.
11:07:34 <Syzygy-> shapr: Anyone know where ICFP 2008 will happen?
11:07:38 <|Steve|> shapr: I am, yes.
11:07:47 <bos> CS is pretty conference driven. journal articles take about a zillion years to get published.
11:08:00 <shapr> Syzygy-: It's almost always alternating between the USA and Europe.
11:08:04 <Syzygy-> Ouch. Long publishing time is alcear negative.
11:08:15 <bos> manuscript received 1976, accepted 2012.
11:08:25 <Syzygy-> shapr: I have funding for at least one extended US trip in 2008 - however I wanted to spend that in the spring...
11:08:25 <|Steve|> heh
11:08:30 <Syzygy-> bos: Yikes
11:08:40 <bos> i exaggerate a little, but not as much as i like.
11:08:44 <Syzygy-> bos: In other words bad news if I want it in my actual dissertation?
11:08:55 <shapr> Syzygy-: Haskell Workshop is a lot of fun, especially since there'll be at least twenty #haskell people there.
11:09:10 <|Steve|> My friend got published in some journal after he had already graduated with an MS and gone to another school for his Ph.D.. He said it took 3 years or something.
11:09:13 <bos> yes. journal articles are death to dissertation schedules.
11:09:27 <shapr> Syzygy-: Uppsala in 2003, first time I met #haskell people -> http://www.cse.unsw.edu.au/~sseefried/seafood/photos/people/people-Pages/Image8.html
11:09:29 <lambdabot> Title: Shae Erisson and Ian Lynagh (shapr and Igloo), http://tinyurl.com/282f96
11:09:41 <Syzygy-> :)
11:09:55 <Syzygy-> Back in 2003, I was still in Stockholm. Dammit - why didn't I know #haskell then!??
11:10:10 * sorear shares a city with three #haskell people - and has never met them
11:10:33 <Syzygy-> shapr: Which is which?
11:10:40 <shapr> Syzygy-: I'm the plump one.
11:10:45 <Syzygy-> Ah.
11:10:55 <shapr> I started unicycling heavily since then, not so plump now :-)
11:11:01 * bos has met one haskell person in 12 years of living in san francisco
11:11:02 <shapr> Igloo has more beard now!
11:11:05 <bos> and that was last week.
11:11:11 * Syzygy- has met ... DRMacIver IRL.
11:11:19 <fasta> I need the following instance: MonadFix (Control.Monad.Cont.ContT ()  (Control.Monad.State.Lazy.StateT (MyState a1 STRef s(MyOtherType s MyType c))) m))
11:11:26 <Syzygy-> And listing names here was a bad idea. Bugger.
11:11:28 <bos> actually, that's not true. julian seward visited a few years ago. but he's not a haskell person any more.
11:11:32 <arcatan> hmm, the gallery has weird loop
11:11:57 <shapr> bos: But GHC was involved in Valgrind's creation
11:11:58 <dmhouse> shapr: _more_ beard?
11:12:06 <fasta> Anybody with a smart idea of how to write it?
11:12:17 <fasta> Or is it already included in some library?
11:12:34 <sorear> fasta: it should be in Cont...
11:14:22 <fasta> sorear: I am sorry for this stupid question, but I don't see anything related to MonadFix in Cont.
11:15:33 <shapr> dmhouse: Hm, maybe it's the same amount of beard - http://www.undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0371.jpg
11:15:36 <lambdabot> Title: AngloHaskell, http://tinyurl.com/2kgppz
11:15:53 <dmhouse> shapr: it's quite enough :)
11:16:02 <shapr> David Roundy shaved his off!
11:16:16 <shapr> I went to Haskell Workshop 2006 and I couldn't find him even though everyone said he was in the room.
11:16:19 <dmhouse> Does _anyone_ have short hair? :)
11:16:43 <shapr> Lemmih does!
11:16:54 <shapr> Lemmih -> http://www.undecidable.org.uk/edwin/photo/anglohaskell.php?photo=IMG_0364.jpg
11:16:57 <lambdabot> Title: AngloHaskell, http://tinyurl.com/28tqw9
11:17:31 <Serge> shapr: Where's that photo from? One of the guys at the table is a Ph.D student at my uni
11:17:58 <fasta> sorear: ?
11:18:22 <sorear> fasta: Memo table exhaused.  I would need to think.
11:18:29 <shapr> Serge: I'd guess you mean Peter Nuttal, aka psnl
11:18:46 <Serge> shapr: Liyang Hu
11:18:59 <shapr> Oh! Glasgow, then?
11:19:02 <Serge> Nottingham
11:19:05 <vincenz> dmhouse: I have short hair
11:19:20 <vincenz> Lemmih: lol, that picture posted by shapr :)
11:19:23 <dmhouse> vincenz: as do I, but I've never been to a Haskell meetup so I don't count. :)
11:19:26 <sorear> Me too.  (but I'm not in any haskell photos)
11:19:32 <vincenz> dmhouse: point taken
11:19:46 <shapr> Oh, I recently found a picture of SPJ trying out my unicycle - http://www.scannedinavian.com/~shae/spj-unicycle.jpg
11:20:04 <dmhouse> Who's that on the right? Duncan?
11:20:07 <shapr> Yup
11:20:22 <dcoutts> @arr!
11:20:23 <lambdabot> I'll crush ye barnacles!
11:20:33 <shapr> Duncan has many cool unicycles of his own, of course.
11:20:40 <dcoutts> :-)
11:20:54 <dcoutts> though I'm currently at my cousins house and he's got 7 in the garage!
11:20:59 <Syzygy-> Hehe
11:21:00 <dcoutts> 4 more than me!
11:21:05 <shapr> dcoutts: ooh, got pix?
11:21:06 <paetso> has anyone here had a chance to look at Liskell?
11:21:14 <vincenz> dmhouse: how long have you had your hair grow?
11:21:30 <dmhouse> I saw a video of one of SPJ's lectures, I was impressed as to how good a speaker he was.
11:21:42 <vincenz> dmhouse: the one on stm?
11:22:02 <shapr> dmhouse: Yeah, he's charming, modest, relaxed, informal, knowledgeable, etc
11:22:30 <dmhouse> No, it was data parallelism I think.
11:22:47 <bos> i wouldn't call him relaxed. he's a bundle of inhuman energy.
11:22:50 <vincenz> shapr: thingy is a good speaker too:; krishnamurti
11:23:34 <arcatan> I'd love to try unicycling
11:24:03 <shapr> arcatan: I'll be back in Stockholm by February at the latest.
11:24:14 <tcr> Is there a generic way to map over a datum (where mapping means calling a function on every argument of every respective data constructor the datum was created with)?
11:24:27 <dmhouse> vincenz: well my hair's especially short at the moment as I've just had it cut for the summer, but it's only a few inches long. I get it cut about every month.
11:24:30 <vincenz> tcr: fmap
11:24:38 <vincenz> dmhouse: likewise
11:24:47 <vincenz> tcr: and make sure all containers are functors
11:25:17 * vincenz `ap` fix zzz
11:26:46 <fasta> Does anyone have the following instance? MonadFix (ContT ()  (Control.Monad.State.Lazy.StateT (MyState a1 STRef s(MyOtherType s MyType c))) m))
11:27:20 <fasta> http://www.cse.ogi.edu/~magnus/mdo-callcc-slides.pdf <- it appears that it is not completely trivial
11:27:22 <tcr> Having to declare Functor instances on all the containers is the kind of pain I want to get away from in the first place.
11:27:38 <dmhouse> tcr: not really in general, you might want to look at generics though.
11:28:44 <augustss> tcr: usually you don't have that many containers...
11:29:02 <augustss> tcr: but look at the SYB stuff as well, it might be what you need
11:29:06 <tcr> augustss: I'm gotta traverse an AST.
11:29:53 <augustss> tcr: then you might want SYB, or composOp, or UniPlate
11:29:56 <swiert> tcr: even if you have a complicated AST, it's usually worth the effort to define fold and map.
11:30:17 <fasta> augustss: do you know how I can define that instance?
11:30:27 <augustss> UniPlate looks very neat
11:30:30 <tcr> swiert: Indeed, that's why I came here if there wasn't a less laborious way!
11:33:02 <swiert> tcr: you might be interested in things like SYB and Data.Derive, but I think that if you find the right higher-order combinators, the boilerplate code is usually not too bad.
11:33:10 <augustss> fasta: which instance?
11:34:06 <tcr> swiert: I'm not sure how I can abstract the pattern matching stuff to descend one level in my recursion via higher-order combinators.
11:34:58 <swiert> tcr: This might be interesting: http://www.cs.chalmers.se/~bringert/publ/composOp/composOp.pdf
11:35:09 <tcr> I'm failing to find a website for SYB, could anyone give me a hand?
11:35:21 <swiert> but I can't really judge, if I don't know anything more specific about your problem.
11:35:38 <swiert> http://research.microsoft.com/~simonpj/papers/hmap/hmap.ps
11:35:45 <fasta> augustss:  MonadFix (ContT ()  (Control.Monad.State.Lazy.StateT (MyState a1 (STRef s(MyOtherType s MyType c))) m))
11:35:48 <byorgey> @where SYB
11:35:48 <lambdabot> I know nothing about syb.
11:36:02 <fasta> augustss: (with m a monad)
11:38:35 <Cale> @google scrap your boilerplate
11:38:38 <lambdabot> http://www.cs.vu.nl/boilerplate/
11:38:38 <lambdabot> Title: Scrap your boilerplate ... in Haskell
11:38:55 <Cale> That would be it
11:39:03 <Cale> Also...
11:39:07 <Cale> @docs Data.Generics
11:39:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Generics.html
11:40:26 <augustss> fasta: can't say that I can write that instance just like that
11:41:54 <fasta> Ok, that's not good, since I now either need to delete all uses of mdo from my program or think really deep.
11:42:47 <augustss> faste: if you have a type like that it looks like you're in deep shit anyway ;)
11:44:00 <fasta> augustss: my program is very very deep shit :)
11:44:21 <fasta> augustss: the types make it somewhat manageable so it seems
11:45:06 <fasta> augustss: I am trying to convert to StateT for this computation, since I wanted to add another "variable".
11:45:36 <Cale> ContT () ?
11:46:00 <Cale> Oh, I suppose that could be handy.
11:46:38 <dukedave> Hey gang, I'm getting "Non-exhaustive patterns in function" breaking my program at run time, does that mean it's actually tried to use the missing pattern, or simply that one could exist ?
11:46:55 <Igloo> It's tried it
11:47:01 <augustss> you tried to use it
11:47:11 <Igloo> ghc -Wall will tell you where they all might be
11:47:34 <dukedave> Ooh, I've spotted
11:48:01 <dukedave> Like the -Wall switch though :)
11:50:18 <fasta> In what source file is Control.Monad.Fix defined?
11:50:29 <opqdonut> ?src fix
11:50:29 <lambdabot> fix f = let x = f x in x
11:50:44 <fasta> ?src mfix
11:50:45 <lambdabot> Source not found. Take a stress pill and think things over.
11:50:47 <shachaf> @index fix
11:50:47 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
11:50:47 <opqdonut> there was a way to query the file iirc
11:50:50 <opqdonut> yeah
11:50:59 <fasta> ?
11:51:06 <opqdonut> no
11:51:08 <fasta> _source_file_
11:51:21 <fasta> It's not in mtl/Control/Monad
11:51:33 <fasta> At least.. there is no Fix.hs
11:51:36 <opqdonut> http://darcs.haskell.org/ghc-6.6/packages/base/Control/Monad/Fix.hs
11:51:36 <shachaf> fasta: Control/Monad/Fix.hs?
11:51:40 <lambdabot> http://tinyurl.com/yqehsk
11:51:41 <oerjan> @hoogle fix
11:51:42 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
11:51:42 <lambdabot> Control.Monad.Fix :: module
11:51:42 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
11:51:45 <opqdonut> that's what hoogle tells
11:51:48 <shachaf> fasta: Maybe you're looking in mtl?
11:51:50 <LeCamarade> Goodnight, lambdafolk!
11:52:14 <fasta> shachaf: yes, I was. THanks
11:58:15 <LoganCapaldo> :t \f -> fix (return . f)
11:58:32 <LoganCapaldo> no that's not gonna work
11:58:32 <lambdabot> thread killed
11:58:38 <LoganCapaldo> mmm
11:58:51 <LoganCapaldo> how would you write fixM?
11:59:02 <oerjan> @t fixM
11:59:05 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
11:59:10 <oerjan> :t fixM
11:59:13 <lambdabot> Not in scope: `fixM'
11:59:24 <oerjan> :t mfix
11:59:28 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
11:59:35 <LoganCapaldo> Ah
11:59:40 <LoganCapaldo> another type class is how
11:59:51 <oerjan> @src MonadFix
11:59:52 <tcr> Has anyone used Data.Derive here?
11:59:52 <lambdabot> class (Monad m) => MonadFix m where
11:59:53 <lambdabot>     mfix :: (a -> m a) -> m a
12:00:06 <sorear> tcr: Quite definitely yes.
12:00:12 <LoganCapaldo> @src Maybe mfix
12:00:13 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
12:00:13 * sorear co-wrote Data.Derive
12:02:20 <tcr> sorear: the manual talks about passing an --append flag, but I'm wondering passing it to what? ghc?
12:02:27 <sorear> derive
12:02:34 <sorear> the standalone program
12:04:29 <oerjan> interesting.  you would think mfix (const Nothing) should be Nothing, but it may be impossible to define it that way.
12:05:24 <oerjan> er wait that one should work
12:05:35 <oerjan> > mfix (const Nothing)
12:06:46 <Cale> Prelude> :m + Control.Monad.Fix
12:06:46 <Cale> Prelude Control.Monad.Fix> mfix (const Nothing)
12:06:46 <Cale> Nothing
12:07:04 * Vulpyne pokes lambdabot.
12:07:09 <Saizan> @bot
12:07:17 <oerjan> however, if f actually examines a and _then_ gives Nothing, it won't.
12:07:26 <Saizan> you've killed her!!
12:07:42 <Vulpyne> It got tired of my stupid @pl queries. :(
12:08:03 <Cale> Yeah, mfix (\x -> x `seq` Nothing) is an infinite loop.
12:08:26 <oerjan> actually i think it is a matching error
12:08:37 <Cale> hm?
12:08:48 <Cale> You can't fail to pattern match against x
12:08:56 <oerjan> oh wait
12:09:09 <oerjan> of course f cannot examine a
12:09:11 <shapr> @botsnack
12:10:04 <Cale> > isJust (mfix Just)
12:10:04 <Cale> True
12:10:35 <Cale> Of course, looking at the contents of the Just is a stack overflow.
12:10:40 <lambdabot> :)
12:10:40 <lambdabot> :)
12:10:42 <lambdabot>  True
12:10:55 <Cale> heh, just a little lagged
12:12:10 <oerjan> @src [] mfix
12:12:11 <lambdabot> mfix f = case fix (f . head) of
12:12:11 <lambdabot>            []    -> []
12:12:11 <lambdabot>            (x:_) -> x : mfix (tail . f)
12:13:24 <ed1t> @src zipWith
12:13:24 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
12:13:24 <lambdabot> zipWith _ _      _      = []
12:13:40 <tcr> What is mtl-any, and where can I obtain it?
12:13:42 <Cf> quick question: can you have where clauses inside lambda functions?
12:14:14 <Cale> tcr: It's the monad transformer library. It should come with GHC.
12:14:35 <fasta> Ok, I think I did it :)
12:14:46 <Cale> tcr: If you're on Debian or Ubuntu, libghc6-mtl-dev
12:14:49 <Cale> or something like that
12:15:07 <Saizan> tcr: or here: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/mtl
12:15:15 <Vulpyne> Cf: Don't think so.
12:15:41 <Cf> gah
12:15:45 <Cale> In fact, I just install all the libghc6-*-dev packages, since it's nice not to have to worry about them.
12:15:56 <Cale> Cf: You can use case.
12:15:59 <Saizan> > (\x -> let x2 = square x where square x = x*x in x2) 1
12:16:05 <Cale> er, I mean let
12:16:10 <lambdabot>  1
12:16:12 <Cale> You said where clauses :)
12:16:14 <Cf> yeah, gonna try that now
12:16:23 <Cf> don't like lets :)
12:16:41 <fasta> Is there a general way to refer to runStateT and runContT in one go?
12:16:44 <Cale> let is part of expression syntax, where is part of declaration syntax
12:16:45 <Vulpyne> Probably cleaner not to use a lambda.
12:17:15 <Cale> fasta: Not unless you write it.
12:17:41 <Cale> fasta: If you're using a complicated stack of monad transformers, you should always newtype it, and derive Functor, Monad, etc.
12:17:57 <Cale> fasta: then write a runFoo which runs the whole stack.
12:21:28 <fasta> I wrote: fixContT :: (MonadFix m, MonadTrans t) => (a -> ContT a m a) -> t m a
12:21:43 <fasta> mfix requires: mfix :: (MonadFix m) => (a -> m a) -> m a
12:21:58 <fasta> Why isn't my version good enough?
12:22:16 <monochrom> Does Cont admit an mfix at all?
12:22:24 <LoganCapaldo> fasta: yours is more specific isn't it?
12:22:30 <fasta> LoganCapaldo: right
12:22:51 <fasta> LoganCapaldo: I use "return" at one place, but that's because I don't know how to make that more general
12:22:58 <fasta> LoganCapaldo: other than using undefined.
12:23:31 <LoganCapaldo> yeah I don't know either but my intuition is that its not general enough for the type of mfix. I don't know for sure of course
12:24:04 <LoganCapaldo> (ie same reason you can't have the Set monad)
12:24:16 <LoganCapaldo> but i could be totally wrong of course
12:24:26 <tcr> sorear: Still there?
12:24:37 <opqdonut> LoganCapaldo: why can't there be a set monad?
12:24:54 <Cale> opqdonut: Because set operations require Ord
12:25:00 <LoganCapaldo> opqdonut: because you need (Ord a) or at least (Eq a)
12:25:03 <opqdonut> ah, true
12:25:24 <sorear> tcr: yp
12:25:24 <jfredett> does haskell automatically memoize functions?
12:25:30 <sorear> jfredett: only 0-argument
12:25:31 <monochrom> No.
12:25:36 <Cale> So a set datatype would only be a monad over a subcategory of Haskell types, and we don't have a way to do that nicely.
12:25:40 <jfredett> damn
12:25:47 <jfredett> so i'll have to do it myself then. :/
12:25:59 <Cale> jfredett: Memoisation is rather easy though.
12:26:04 <jfredett> yeh, i know
12:26:20 <monochrom> You want to control memoization yourself.
12:26:24 <Cale> You just create a named datastructure which holds the values, and make the function look in that datastructure.
12:26:24 <jfredett> i've got a predicate "isAmicable" and its unfortunately slow.
12:26:25 <tcr> sorear: I copied the snipped from ``Using Template Haskell Derivations'' into a file foo.hs, and run derive -o out.hs foo.hs; But afterwards, out.hs is still empty.
12:26:27 <opqdonut> does the prelude have memoization functions?
12:26:42 <oerjan> i think you can do a monad data Set' a = Set' (a -> Bool), however
12:26:44 <sorear> tcr: Right.
12:26:53 <sorear> tcr: You don't use derive with TH
12:26:53 <opqdonut> something like memoF = memo f 10
12:26:58 <notsmack> jfredett: euler?
12:27:01 <jfredett> yep
12:27:09 <jfredett> i'm doing each problem in Haskell
12:27:10 <_case> hello, if i got "apply where apply (f, x) = f x" , what does the "," do in (f, x) ?
12:27:12 <fasta> fixContT :: (MonadFix m) => (r -> ContT r m r) -> ContT r m r and mfix :: (MonadFix m) => (a -> m a) -> m a seem _very_ similar to me
12:27:13 <sorear> tcr: the TH mechanism is an alternative to the standalone 'derive'
12:27:16 <jfredett> i'm up to 21
12:27:18 <tcr> sorear: Ah.
12:27:22 <notsmack> jfredett: nice.  going in order?
12:27:25 <jfredett> yep
12:27:26 <Cale> opqdonut: No, though there's a paper which describes how to construct such functions using unsafePerformIO.
12:27:30 <jfredett> with some exception
12:27:37 <jfredett> i did 67 w/ 18
12:27:39 <Cale> opqdonut: The problem is that there's lots of things which you might want memo to do.
12:27:41 <jfredett> cause they were related
12:27:43 <fasta> Cale: any idea why fixContT isn't eaccepted?
12:27:45 <jfredett> (i think it was 18
12:27:47 <fasta> Cale: accepted*
12:27:53 <opqdonut> yeah i realize
12:27:56 <jfredett> the number-net path one)
12:28:00 <opqdonut> and it's impure too
12:28:00 <tcr> sorear: But I correctly figured that it's possible to derive this way for stuff out of other modules, yes?
12:28:01 <notsmack> yep
12:28:07 <dolio> fasta: Consider what m is in that ContT expression.
12:28:10 <sorear> tcr: right.
12:28:19 <dolio> fasta: m depends on a.
12:28:25 <notsmack> i've got 25 from the other night, but pretty much just grabbed the low hanging fruit.  now they're getting /really/ interesting :)
12:28:25 <monochrom> _case: (f,x) is an ordered pair.  E.g., you can pass around things like ('c', True), (34.5, "hello"), (1,2).
12:28:46 <_case> monochrom: you mean it's a tuple?
12:28:49 <jfredett> i think my real issue is actually in my divisorsOf function, its slow as cold molasses going uphill during a blizzard... :/
12:28:51 <monochrom> Yes, tuple.
12:28:59 <_case> monochrom: ok :) thanks
12:29:02 <fasta> dolio: ok, is it even possible write a good definition?
12:29:06 <tcr> sorear: Still, I'd like to get at the source code for the derivations, is that still possible?
12:29:36 <dolio> fasta: I don't know. Although it seems like there'd be one already if there were.
12:29:38 <sorear> tcr: Yes.  You can use the internal hook I left in to allow 'derive'
12:29:56 <notsmack> jfredett: mine's pretty slow too, probably the naive implementation
12:29:57 <_case> monochrom: i guess i don't understand why it's type is (a -> b,a) -> b
12:30:00 <tcr> sorear: Alright, how do I do that? Or can look it up?
12:30:06 <SamB> jfredett: what is your divisorOf function?
12:30:15 <SamB> oh, wait, divisorsOf
12:30:17 <SamB> ah.
12:30:21 <sorear> tcr: write in a file ' import Foo.Bar ; import Data.Derive.Class ; import Data.DeriveTH ; main = putStrLn $( _derive_string_instance makeClass ''Type )'
12:30:23 <fasta> dolio: I don't fully understand what you mean, though.
12:30:28 <fasta> dolio: can you elaborate?
12:30:37 <Cale> _case: apply takes a pair consisting of a function, and a parameter, and applies the function to the parameter.
12:30:38 <sorear> tcr: it's not really documented because it isn't intended for much use
12:30:38 <monochrom> _case: if you allow me to add more parentheses, ( (a->b), a ) -> b
12:30:42 <dolio> fasta: Which part?
12:30:57 <fasta> dolio: "m depends on a"
12:31:23 <_case> monochrom, cale: yep, i see it now
12:31:36 <tcr> sorear: How come? I'd like to create the source code for the instances at distribution creation time, but still be able to derive things from within other modules.
12:31:38 <_case> is apply a standard function btw?
12:31:39 <dolio> fasta: The type of mfix when specialized to ContT needs to be: 'mfix :: (a -> ContT r m a) -> ContT r m a'
12:31:40 <fasta> dolio: or to put it differently: how should the type signature of fixContT look like?
12:32:04 <fasta> dolio: heh, you read my mind :)
12:32:15 <monochrom> apply = uncurry ($)
12:32:31 <Cale> _case: no, though you can write it succinctly as monochrom just did :)
12:32:42 <sorear> tcr: Then use the hook, and bug ndm for a cross-module feature in the standalone derive.
12:32:46 <_case> k :)
12:33:24 <tcr> sorear: I see. Many thanks so far!
12:34:23 <dolio> fasta: If it's 'ContT r m r' then in 'instance MFix (ContT r m) where ...' you've already fixed the type of 'a' in mfix to be 'r', but it needs to be defined forall a, not just r.
12:34:35 <tcr> sorear: (I suppose, I must alter makeClass and ''Type within your snippet to my specific case?)
12:34:47 <sorear> yeah
12:34:47 <fasta> dolio: good explanation. Thanks
12:34:51 <sorear> and .Class
12:34:54 <sorear> and Foo.Bar
12:35:07 <xerox> ?type app -- _case Cale monochrom
12:35:09 <lambdabot> forall (a :: * -> * -> *) b c. (ArrowApply a) => a (a b c, b) c
12:35:34 <monochrom> Haha I knew it was in the arrows.
12:36:11 <monochrom> > app (sin, pi/4)
12:36:26 <lambdabot>  thread killed
12:36:50 * monochrom cries
12:36:51 <Cale> Something strange is going on with lambdabot
12:37:02 <Cale> > app (sin, pi/4)
12:37:14 <Cale> Oh, come on :)
12:37:17 <lambdabot>  thread killed
12:37:30 <monochrom> It has too many rogue processes. Happens once in a while. Cause still unknown.
12:38:00 <fasta> But.. doesn't this mean that Haskell is completely non-compositional for complex control flow?
12:38:10 <fasta> E.g. unlike Scheme.
12:38:17 <monochrom> Basically somehow after a large number of > uses, it degrades.
12:39:06 <monochrom> Scheme is compositional for complex control flow? Like call/cc doesn't give you arbitrary global jumps?
12:39:58 <SamB> I think Haskell is the other way
12:39:59 <tcr> sorear: I'm trying to load the file via ghci's :load (-fglasgow-exts being set); but it complains about syntax (i.e. lexical error in literal at character '\'')
12:40:17 <sorear> tcr: -ftjh
12:40:19 <sorear> tcr: -fth
12:40:30 <SamB> I don't believe Haskell's continuations give you arbitrary global jumps...
12:40:41 <shapr> -fthsn !
12:40:50 <fasta> I mean, somebody writes something with mdo syntax... then he decides he needs ContT, then he finds out he is f*cked.
12:40:51 <shapr> Maybe that should just be -fdvorak
12:40:53 <sorear> unsafePerformCont
12:41:17 <monochrom> That brings back to my original question. Does Cont admit an mfix at all?
12:41:31 <fasta> Can't Djinn solve that?
12:41:36 <sorear> fasta: No.
12:41:42 <Heffalump> in what was does call/cc give you arbitrary global jumps?
12:41:55 <SamB> I don't think our Cont/ContT are typed the way they should be
12:42:19 <SamB> ... I'm not sure we can type them the way they should be typed yet?
12:42:45 <dolio> There was a ContT on one of the wikis at some point with a rank 2 type, if you're into that sort of thing.
12:42:52 <dolio> I don't know if that helps any, though.
12:42:59 <SamB> I think I copied it to haskellwiki
12:43:04 <monochrom> Is SamB referring to the wiki article "Cont done right"?  That's an unrelated question.
12:43:08 <fasta> I don't care about the rank, as long as it works :)
12:43:25 <monochrom> I think SamB is great at introducing lateral thinking to most discussions.
12:43:28 <dolio> monochrom: That has to do with the type of callCC, right?
12:43:33 <SamB> monochrom: yes, that.
12:43:46 <SamB> well, I really don't know that it is unrelated...
12:44:36 <monochrom> I'm more interested in the original question, i.e., whether and how to do mfix for Cont and ContT.
12:44:36 <fasta> We don't seem to know a lot ;)
12:45:08 <SamB> monochrom: I think it might involve using a Cont and ContT that are done right, though ;-)
12:45:24 <SamB> @wiki MonadCont done right
12:45:25 <lambdabot> http://www.haskell.org/haskellwiki/MonadCont_done_right
12:45:53 <monochrom> Fine. Let's assume it's done right. The original question still stands: whether and how to mfix it.  My guess is impossible.
12:46:37 <tcr> sorear: So it fails trying to derive Functor for the Color example of the manual. The end of the manual depicts some limitations, but I thought those have to do with extending the row of automatically derivable type classes.
12:47:16 <sorear> tcr: Fucntor deriving doesn't quite work
12:47:33 <sorear> ping twanvl, he's the only one who understands it?
12:47:34 * monochrom hates forking discussions and lateral thinking. Counterproductive.
12:47:36 <tcr> Damnit! :)
12:48:03 <monochrom> Linear thinking is the only proven method that has ever got anything done.
12:48:17 <monochrom> Lateral thinking is only good for killing time at pubs BSing about nothing.
12:48:18 <quicksilver> monochrom: I was under the impression that Cont did not admit an mfix structure
12:48:28 <monochrom> Right, my bet too.
12:48:29 <quicksilver> monochrom: but I could have misremembered or misunderstood
12:49:02 <dolio> I bet Oleg can answer the question. Someone should post it to the mailing list. :)
12:49:22 <monochrom> I bet Oleg has answered the question. :)
12:49:28 <fasta> http://www.mail-archive.com/haskell-cafe@haskell.org/msg09081.html
12:49:30 <lambdabot> Title: Re: [Haskell-cafe] Re: Control.Monad.Cont fun, http://tinyurl.com/2zs64g
12:50:18 <monochrom> Nice, thanks.
12:55:38 * LoganCapaldo is scared by "callcc (\k -> mfix (\v -> E))"
12:56:13 <monochrom> hehe
12:56:16 <fasta> Is it even possible to always turn mdo into do without using MonadFix? I guess not.
12:56:24 <fasta> I mean manually.
12:56:59 <monochrom> Manually you can check that your mdo doesn't have any forward reference, then it's just do.
12:57:20 <monochrom> Or you can look for forward references and rewrite as do with mfix.
12:57:56 <monochrom> OK, the latter case is done by the compiler already. You're more interested it the former case.
12:58:01 <LoganCapaldo> what is mdo exactly? (link would be fin)
12:58:29 <fasta> @where mdo
12:58:29 <lambdabot> I know nothing about mdo.
12:58:33 <mehrheit> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html
12:58:35 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
12:58:36 <mehrheit> 7.33
12:59:21 <fasta> monochrom: yes, but then I still need an instance which I cannot write, right?
12:59:33 <LoganCapaldo> woah
12:59:38 <fasta> monochrom: i.e. it becomes impossible to write certain programs
12:59:43 <LoganCapaldo> woah, that first example hurst my brain
13:00:00 <monochrom> Does mfix alone hurt your brain?
13:00:29 <LoganCapaldo> monochrom: I didn't think so, I'm not so sure anymore
13:01:00 <monochrom> You can try to translate mdo to mfix+do first.
13:01:33 <fasta> monochrom: again: why would that solve the problem?
13:01:48 <fasta> monochrom: mdo is translated to mdo by the compiler already
13:01:53 <fasta> monochrom: I use forward references.
13:02:01 <monochrom> The first example is:  do { xs <- mfix (\xs -> Just (1:xs)); return xs }
13:02:10 <LoganCapaldo> let a = do { xs <- Just a; mfix (1:xs) } in a
13:02:21 <LoganCapaldo> err
13:02:26 <LoganCapaldo> I meant mfix (1:)
13:02:35 <LoganCapaldo> but I'm clearly wrong anyway
13:02:42 <LoganCapaldo> actually
13:02:46 <LoganCapaldo> I think I meant mfix a
13:02:51 <LoganCapaldo> gah
13:02:55 <monochrom> forward references such as that example requires mfix positively.
13:03:08 <monochrom> some monads cannot support mfix clearly
13:03:19 <LoganCapaldo> oooo wait
13:03:26 <LoganCapaldo> I think i'm starting to get it
13:03:43 <monochrom> some programs cannot be written (or, you can try, but it won't compile). welcome to the world.
13:04:25 * LoganCapaldo woulda just done Just $ fix (1:)
13:04:32 <monochrom> "a = do { xs <- Just a; mfix (1:xs) }"  may fail to type-check.
13:05:03 <LoganCapaldo> hmm
13:05:19 <monochrom> But do you understand my translation?
13:05:55 <LoganCapaldo> thinking about it
13:06:20 <monochrom> I may have done more manipulation than the computer does.
13:07:05 <LoganCapaldo> No I don't understand. But I think its one of those "have to let settle" things. thanks though
13:07:10 <monochrom> (But, given mfix laws, my translation is equals computer's translation)
13:07:54 <fasta> monochrom: I think it would be reasonable if I could use this code: http://pastebin.ca/579716
13:08:01 <LoganCapaldo> @src [] mfix
13:08:01 <lambdabot> mfix f = case fix (f . head) of
13:08:01 <lambdabot>            []    -> []
13:08:01 <lambdabot>            (x:_) -> x : mfix (tail . f)
13:09:56 <byorgey> @pl \f g h x -> f (g x) (h x)
13:09:56 <lambdabot> liftM2
13:09:59 <monochrom> fasta: You positively want to add ContT to that?
13:10:28 <LoganCapaldo> @type \f -> let a = f (runIdentity a) in a
13:10:30 <lambdabot> forall a. (a -> Identity a) -> Identity a
13:11:01 <fasta> monochrom: In a do block that should return a value of type ContT <..> I want to be able to see that value.
13:11:17 <BlueCell> Could someone tell me why tail.head is of type [[a]]->[a]? As in: how does the "." make tail ([a]->[a]) and head ([a]->a) that?
13:11:34 <LoganCapaldo> BlueCell: head has type [a] -> a
13:11:34 <fasta> monochrom: it's very much possible that there's another way to do this, but I don't know.
13:11:42 <LoganCapaldo> tail has type [a] -> [a]
13:11:46 <BlueCell> yeah
13:11:58 <LoganCapaldo> so for tail to work on the head of something
13:12:01 <LoganCapaldo> it must be a list of lists
13:12:03 <Syzygy-> BlueCell: So for head to deliver something tail can get, we need to srart in [[a]]
13:12:16 <BlueCell> oh
13:12:26 <monochrom> head::[b]->b, tail::[a]->[a].  To unify b to [a], b = [a], [b] = [[a]].
13:12:27 <BlueCell> is there a "rule" for this?
13:12:39 <LoganCapaldo> teh type inference alogrithm?
13:12:39 <fasta> monochrom: any idea?
13:12:43 <BlueCell> mmm...
13:12:55 * sorear <3 Hindley-Damas-Milner
13:13:45 <fasta> sorear: from the above problem I start to hate it, even though, I recently started to appreciate it.
13:13:49 <monochrom> fasta: if you can avoid Cont or ContT, good. If you must include ContT, the haskell-cafe message that you found says there is a way, but beware that one of the mfix laws is broken, so don't be surprised if the end result behaves wierdly.
13:13:57 <sorear> fasta: it = HDM?
13:14:40 <fasta> monochrom: The "code" in that paper needs to be modified before it works.
13:15:29 <fasta> sorear: I like type systems as long as they don't get in the way, and now the type system does get in the way.
13:16:29 <monochrom> if you see "error: infinite type", you can introduce a newtype to solve it.
13:20:09 <fasta> Is the Identity monad in 6.6.1?
13:21:22 <LoganCapaldo> fasta: appears so
13:21:29 <sorear> No.  MTL was split out of the compiler in 6.6.0
13:21:38 <LoganCapaldo> or I could be wrong
13:21:42 <LoganCapaldo> and have mtl installed
13:22:31 <monochrom> Identity is in mtl. mtl is in extralibs.
13:23:30 <Heffalump> isn't the job of the type system to get in the way when you try to shoot yourself in the foot?
13:24:24 <monochrom> you may claim you are doing legit things.
13:24:53 <monochrom> but I'm cynical about human judgement.
13:25:45 <BlueCell> Could anyone explain why the type of "map curry" is [(a,b) -> c] -> [a -> b -> c]?
13:25:52 <BlueCell> curry is of type  ((a,b) -> c) -> a -> b -> c
13:25:53 <_case> BlueCell, studying for your exam tommorow btw? :)
13:25:58 <BlueCell> yeah
13:26:00 <BlueCell> lol :D
13:26:02 <_case> tudelft :)
13:26:05 <fasta> Heffalump: have you seen the code I pasted?
13:26:06 <BlueCell> lol
13:26:07 <BlueCell> yeah
13:26:20 <_case> ik herken het proeftentamen ;)
13:26:33 <monochrom> map :: (x->y) -> [x] -> [y].
13:26:54 <fasta> Heffalump: why shouldn't I able to run that code in something ContT'ed?
13:27:10 <BlueCell> _case: you know how to do the type thingy?
13:27:27 <_case> BlueCell, it's the only part i find difficult
13:27:31 <monochrom> unify x->y with ((a,b) -> c) -> a -> b -> c.  x = ((a,b) -> c), y = a -> b -> c.  Now plug them into [x], [y].
13:27:32 <BlueCell> ah ok
13:27:39 <fasta> Heffalump: maybe I make a mistake, but I just to have access to the result of that function within a do block evaluating to ContT <..>
13:28:03 <_case> i've written some functions on a cheatsheet, like curry and foldr
13:28:08 <monochrom> Do you see my pattern?
13:28:16 <BlueCell> no, not really :S
13:28:26 <monochrom> TRY TO USE DIFFERENT VARIABLE NAMES and avoid confusing yourself.
13:28:44 <Excedrin> sometimes I use 'g' as a variable name
13:28:49 <Excedrin> just to mix things up
13:28:53 <BlueCell> mmm...
13:30:00 <monochrom> Also know the precedence.  a->b->c = a->(b->c).
13:30:21 <BlueCell> ah ok
13:30:32 <LoganCapaldo> BlueCell: it might help to try and work it out with example values too
13:30:41 <BlueCell> ok
13:30:45 <monochrom> ((a,b) -> c) -> (a -> (b -> c))   now it's clear how that unifies with x->y.
13:31:53 <monochrom> If you have taken a logic course, a really, really good one, that emphasizes "resolution proofs", "unification", it's the same deal.
13:32:07 <LoganCapaldo> e.g: map uncurry [ \(x, y) -> x ] -> [ uncurry (\(x,y) -> x) ] -> [\x -> \y -> x], and the last thing is a list cotaining one argument functions
13:32:12 <fasta> monochrom: Ok, the compiler has beaten the human.
13:32:22 <LoganCapaldo> err 2 argument functions I mean
13:32:28 <fasta> monochrom: It appears that with two lifts in the right location it works :)
13:32:56 <fasta> monochrom: so, I don't need the instance, so the problem is solved. Thanks, for moral support ;)
13:34:33 <fasta> This problem I had would be a nice exam question :D
13:35:24 <monochrom> I hate such trial-and-error and dont-know-why, but still, congrats.
13:35:27 <BlueCell> I am still having difficulties
13:35:32 <BlueCell> I don't see it
13:35:46 <BlueCell> x = ((a,b)->c)
13:35:56 <BlueCell> and y = (a->(b->c))
13:35:56 <BlueCell> ?
13:36:00 <monochrom> Yes.
13:36:06 <BlueCell> and then...
13:36:37 <_case> the output of map is [a]
13:36:42 <monochrom> You need a logic course.
13:36:51 <fasta> monochrom: Me?
13:36:51 <BlueCell> :)
13:36:57 <BlueCell> no me :D
13:36:59 <monochrom> Everyone.
13:37:02 <BlueCell> hehe
13:37:04 <_case> you have to put the x and y in the [a], so you get [x] and [y]
13:37:23 <_case> ergo [((a,b)->c)] -> [(a->(b->c))]
13:37:31 <byorgey> @pl \x y -> x + (recip y)
13:37:31 <lambdabot> (. recip) . (+)
13:37:43 <fasta> monochrom: can you recommend one? I already followed multiple.
13:37:46 <monochrom> @type map curry
13:37:48 <lambdabot> forall a b c. [(a, b) -> c] -> [a -> b -> c]
13:38:01 <fasta> monochrom: I do understand why it didn't work, though.
13:39:32 <LoganCapaldo> unification is fun
13:39:42 <BlueCell> @type map curry
13:39:44 <lambdabot> forall a b c. [(a, b) -> c] -> [a -> b -> c]
13:43:26 <_case> BlueCell, do you see it yet? :)
13:43:28 <LoganCapaldo> @type \a b -> case (cast a) `asTypeOf` Just b of { Nothing -> False ; Just z -> z == b }
13:43:31 <lambdabot> forall a a1. (Typeable a1, Typeable a, Eq a1) => a -> a1 -> Bool
13:44:03 <BlueCell> uhm...
13:44:06 <BlueCell> A bit
13:44:10 <BlueCell> I see tail.head
13:44:12 <LoganCapaldo> > (\a b -> case (cast a) `asTypeOf` Just b of { Nothing -> False ; Just z -> z == b }) 2 2
13:44:18 <BlueCell> head = [a]->a
13:44:24 <BlueCell> tail = [b]->[b]
13:44:27 <lambdabot>  thread killed
13:44:30 <_case> jup
13:44:36 <BlueCell> so a should map to [b]
13:44:54 <BlueCell> therefore.... head "becomes" [[a]]->[a]
13:45:00 <BlueCell> so that [a] = [b]
13:45:10 <BlueCell> now...
13:45:17 <BlueCell> [[a]] -> [b]
13:45:28 <BlueCell> if I'd following the same logic...
13:45:48 <_case> yeees
13:45:57 <BlueCell> then what should map to (x->y)
13:46:03 <BlueCell> if we'd do map curry
13:46:10 <mehrheit> @type tail.head
13:46:12 <lambdabot> forall a. [[a]] -> [a]
13:46:23 <_case> BlueCell, well, the output of map is [a]
13:46:50 <BlueCell> mmm... about the tail.head....
13:47:15 <BlueCell> a (the output of head) should map to [b] (the output of tail)
13:47:19 <BlueCell> ?
13:47:43 <BlueCell> or....
13:47:48 <BlueCell> a (the output of head) should map to [b] (the INPUT of tail)
13:48:00 <BlueCell> input or output?
13:48:05 <mehrheit> to the input
13:48:14 <BlueCell> ok
13:48:17 <BlueCell> thought so
13:48:21 <_case> i concur
13:48:30 <BlueCell> so, for something like...
13:48:35 <BlueCell> (x->y)
13:48:39 <BlueCell> = input map
13:48:46 <BlueCell> should map to output of curry
13:48:49 <BlueCell> which is...
13:49:15 <BlueCell> c?
13:49:31 <BlueCell> @type curry
13:49:33 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:49:44 <BlueCell> is that true?
13:49:46 <mehrheit> map has two inputs, a function and a list; and an output - a list with the function applied to every member
13:50:00 <BlueCell> ah
13:50:02 <BlueCell> ok
13:50:07 <LoganCapaldo> BlueCell: in this case the output of curry is more like (a -> b -> c)
13:50:27 <BlueCell> so (x->y)->[x] is the input of map
13:50:27 <mehrheit> (map curry) has one input, a list, and an output, the first list with curry applied to every member
13:51:09 <byorgey> @src foldl
13:51:09 <lambdabot> foldl f z xs = lgo z xs
13:51:09 <lambdabot>     where lgo z []     =  z
13:51:09 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
13:51:40 <byorgey> @src foldr
13:51:41 <lambdabot> foldr k z xs = go xs
13:51:41 <lambdabot>     where go []     = z
13:51:41 <lambdabot>           go (y:ys) = y `k` go ys
13:51:57 <BlueCell> what should map to ... (x->y)->[x] ?
13:52:04 <tcr> Let's say I've got a type like data Foo = Quux Int | Bar String; is it somehow possible to define a kind of mapping such that `mymap (\x -> case x of { Quux i -> Quux 42; Bar s -> Bar "Zeep" }) (foo::Foo)' is possible?
13:53:19 <SamB> tcr: ... "mymap = id"?
13:53:27 <LoganCapaldo> type Foo = Either Int String
13:53:34 <LoganCapaldo> @type either
13:53:36 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
13:53:58 <BlueCell> @type map
13:54:03 <BlueCell> @type curry
13:54:14 <lambdabot> thread killed
13:54:16 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
13:55:53 <kpreid> tcr: your example code fits with "mymap = id"; what property are you actually looking for?
13:57:27 <tcr> Yeah the example was too simplistic; I don't just want a map over one type but over several types (each with multiple data constructors again, which are not necessarily very similiar to each other.) The problem is that Either does not really scale for me, because I've got a few dozen of those types.
13:58:04 <kpreid> but what do you want this function to *do*? what do you want to improve?
13:58:47 <tcr> kpreid: It's an AST, I want to map over the AST, and replace occurence of a type by another datum of that type.
13:59:02 <kpreid> tcr: Data.Generics
14:00:40 <kpreid> > Data.Generics.everywhere (Data.Generics.mkT (++"!")) [Left "a", Right ("b","c")]
14:00:52 <lambdabot>  [Left "a!!",Right ("b!!","c!!")]
14:01:04 <kpreid> hrm
14:01:07 <kpreid> > Data.Generics.everywhere' (Data.Generics.mkT (++"!")) [Left "a", Right ("b","c")]
14:01:22 <lambdabot>  thread killed
14:01:45 <kpreid> I'm not sure exactly what went wrong there
14:02:03 <sorear> kpreid: not your fault
14:02:30 <sorear> kpreid: ghc randomly starts spinning, causing *massive* load on lambdabox
14:02:48 <kpreid> no, I meant getting "a!!" instead of "a!"
14:03:09 <kpreid> tcr: Data.Generics is exactly for that sort of thing
14:04:30 <BlueCell> uhm...
14:04:34 <BlueCell> what should map to ... (x->y)->[x] ?
14:05:04 <BlueCell> a->b->c
14:05:56 <kpreid> BlueCell: I don't understand the question.
14:06:50 <Syzygy-> I wonder how difficult a preimage :: (x->y) -> y -> [x] or a kernel :: HasZero y => (x -> y) -> [x] would be to build... How much you'd need to restrict for it to be even possible.....
14:06:51 <kpreid> The only value a function of type (x -> y) -> [x] can compute is a list of bottoms
14:07:12 <tcr> Nice Typable & Data seems to be supported by Data.Derive. :)
14:07:15 <Syzygy-> (where HasZero is a class of some decent setup that guarantees the existence of a specific element in the class....)
14:07:40 <Syzygy-> kpreid: Is there a proof for that floating around somewhere?
14:09:25 <kpreid> Syzygy-: I read something on the subject a while ago, but I don't know whether it had a proof or what it was.
14:10:32 <BlueCell> f
14:10:35 <sorear> tcr: GHC even!  deriving(Data, Typeable)
14:11:20 <LoganCapaldo> it's a wonderful  thing
14:11:31 <tcr> How does Data.Generics relate to SYB?
14:11:42 <sorear> tcr: synonyms
14:11:44 <mehrheit> @type mfix
14:11:50 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:11:57 <Syzygy-> ?doc Typeable
14:11:58 <sorear> tcr: SYB was first, so it got the generics name
14:12:01 <lambdabot> Typeable not available
14:12:05 <fbuilesv> @where hlist
14:12:06 <lambdabot> http://homepages.cwi.nl/~ralf/HList
14:12:08 <sorear> tcr: everyone else has been more creative
14:13:52 <nominolo> any yi person here?
14:14:23 <Syzygy-> ?index Typeable
14:15:48 <lambdabot> Data.Typeable, Data.Dynamic, Data.Generics.Basics, Data.Generics
14:15:48 <sorear> nominolo: jyp isn't here ATM, but he comes daily
14:16:15 <nominolo> sorear: thanks
14:16:33 <nominolo> i'm confused that it doesn't build with my cabal
14:17:55 <nominolo> the setup.lhs chokes on interface changes i didn't make
14:19:06 <shachaf> nominolo: Are you using the Setup.lhs directly?
14:19:15 <nominolo> no
14:19:24 <nominolo> i'm calling make emacs
14:19:52 <shachaf> nominolo: Hmm, make vim "works" for me.
14:19:55 <fbuilesv> How can I find the parameters for operators like ":" inside GHCi?
14:20:07 <nominolo> is there something like svn's blame command for darcs?
14:20:08 <fbuilesv> .
14:20:24 <Saizan> ?type (:)
14:20:29 <shachaf> nominolo: Which version of cabal?
14:20:37 <nominolo> 1.1.7 (head)
14:20:38 <fbuilesv> Thank you.
14:20:43 <shachaf> nominolo: I remember someone asked that here before. :-)
14:21:15 <nominolo> oh, hehe
14:21:15 <Igloo> nominolo: If there's a typesig with a Maybe UserHooks in then comment it out
14:22:01 <nominolo> i have an idea for adding a more extendable hook-interface though
14:23:53 <nominolo> ok, the fix was straightforward
14:23:53 <lambdabot> forall a. a -> [a] -> [a]
14:24:03 <nominolo> lol
14:24:04 <kpreid> nominolo: darcs annotate
14:24:13 <nominolo> lambdabot: is slow today
14:24:27 <nominolo> kpreid: thanks
14:28:25 <nominolo> ok, what i really need is to figure out the question: "when was this function removed?"  anyone know of a tool to do this?
14:28:46 <kpreid> darcs trackdown?
14:29:35 <aspo> I have a pretty newb question, I'm trying to learn haskell and ran into a problem and the tutorials I've looked at aren't helping
14:29:43 <aspo> if I have a data like
14:29:47 <aspo> data BTree a = Nil | Node (BTree a) a (BTree a)
14:30:02 <aspo> and I a to have to be an Ord
14:30:04 <aspo> how do I do that?
14:30:28 <nominolo> kpreid: could work
14:31:07 <kpreid> aspo: data Ord a => BTree a = ...
14:31:10 <nominolo> aspo: you add the Ord constraints to the functions that need it
14:31:23 <aspo> ahh
14:31:25 <aspo> thanks
14:31:36 <nominolo> aspo: at least that's more flexible
14:31:45 <aspo> well it ties into
14:31:57 <aspo> I'm trying to make my data instance Show
14:32:12 <aspo> but it's mad cause I can't make sure the nodes are always shows
14:32:46 <nominolo> instance Show a => Show (BTree a)
14:32:58 <nominolo> ?
14:33:07 <oerjan> > head $ show (undefined :: Char)
14:33:12 <lambdabot>  Undefined
14:33:20 <oerjan> darn
14:33:38 <oerjan> head $ show 'a'
14:33:43 <oerjan> > head $ show 'a'
14:33:51 <aspo> nominolo: ahha!
14:33:58 <lambdabot>  thread killed
14:33:58 <aspo> thanks
14:34:10 <oerjan> > head $ show 'a'
14:34:19 <LoganCapaldo> > head $ show (undefined, undefined)
14:34:26 <lambdabot>  thread killed
14:34:33 <oerjan> what the?
14:34:34 <lambdabot>  thread killed
14:34:35 <Heffalump> > show 'a'
14:34:35 * SamB has to remove some .prerm files from /var/lib/dpkg/info because they fail to uninstall non-installed GHC packages...
14:34:38 <oerjan> show 'a'
14:34:40 <Heffalump> @src show
14:34:41 <lambdabot> show x = shows x ""
14:34:41 <oerjan> > show 'a'
14:34:46 <Heffalump> @src shows
14:34:46 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
14:34:50 <lambdabot>  thread killed
14:34:55 <Heffalump> > show ()
14:34:57 <lambdabot>  thread killed
14:35:04 <lambdabot>  "()"
14:35:07 <oerjan> hm, lambdabot is ill
14:35:21 <oerjan> > 'a'
14:35:36 <lambdabot>  thread killed
14:35:44 <oerjan> this is weird
14:36:03 <oerjan> > map (:[]) "hello"
14:36:18 <lambdabot>  thread killed
14:36:30 <oerjan> lambdabot doesn't like me :(
14:37:08 <oerjan> > [0..]
14:37:24 <lambdabot>  thread killed
14:37:28 <oerjan> > show ()
14:37:44 <lambdabot>  thread killed
14:37:55 <mehrheit> she's apparently tired
14:48:36 <Ulfalizer> > 1
14:48:50 <lambdabot>  1
14:49:39 <nominolo> @src msum
14:49:39 <lambdabot> msum =  foldr mplus mzero
14:52:15 <nominolo> @instances MonadPlus
14:52:16 <lambdabot> Either e, ErrorT e m, IO, Maybe, RWST r w s m, ReaderT r m, StateT s m, WriterT w m, []
14:52:32 <nominolo> @src Either mplus
14:52:32 <lambdabot> Left _ `mplus` n = n
14:52:32 <lambdabot> m      `mplus` _ = m
14:52:42 <nominolo> @src Either mzero
14:52:43 <lambdabot> mzero            = Left noMsg
14:52:44 <oerjan> > let s' c = '\'':tail (show c) in mfix s'
14:53:00 <lambdabot>  thread killed
14:53:35 <oerjan> #%&/(!
14:53:50 <oerjan> > 1
14:54:06 <lambdabot>  thread killed
14:54:30 <oerjan> @src Char show
14:54:31 <lambdabot> Source not found. stty: unknown mode: doofus
14:56:24 <oerjan> it would have been so nice if mfix show had worked. :(
14:57:20 <mehrheit> can ghc take input from stdin?
14:58:16 <oerjan> @src [] mfix
14:58:17 <lambdabot> mfix f = case fix (f . head) of
14:58:17 <lambdabot>            []    -> []
14:58:17 <lambdabot>            (x:_) -> x : mfix (tail . f)
14:58:36 <Heffalump> @type mfix
14:58:38 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
14:59:11 <Heffalump> works in ghci
14:59:34 <ddarius> lambdabot is just experiencing a bug
14:59:53 <Heffalump> oh, no it doesn't. Well, it does what you'd expect, i.e. not terminate and not produce any output.
15:01:22 <oerjan> as far as i can see, mfix show _should_ produce an infinite string if show for Chars had been nonstrict
15:01:46 <oerjan> and the s' i defined should work that way. so what is wrong?
15:05:02 <dukedave> It's quite neat this Parsec isn't it :)
15:06:05 <dukedave> Although I do keep having to check myself using do notation, it does make things deceptively procedural...
15:06:20 <Heffalump> oerjan: oh, yes, you're right, it should produce the first '
15:06:20 <oerjan> hm, i think mfix for lists is actually broken.
15:08:35 <oerjan> it assumes that the first element of the list in only gives one element of the list out
15:12:01 <oerjan> @let mfix' f = l where l = case fix (f . head) of [] -> []; x@(_:_) -> x ++ concatMap f (tail l)
15:12:24 <lambdabot> thread killed
15:12:34 <oerjan> #¤%&&/!
15:13:04 <ddarius> oerjan: dons needs to fiddle with the bot
15:13:16 <Syzygy-> > mfix (\x -> [1..x]) [1,2,3]
15:13:51 <Syzygy-> ?index mfix
15:13:55 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
15:14:15 <oerjan> @hoogle mfix
15:14:27 <edward2> ddarius: i never knew lambdabot could play the violin
15:14:47 <ddarius> edward2: lambdabot is a bot of many hidden skills
15:15:19 * edward2 listens as dons and lambdabot rip into "The House of the Rising Sun" =)
15:15:19 <lambdabot> Plugin `hoogle' failed with: IRCRaised thread killed
15:15:35 <Syzygy-> Ummmm.
15:15:39 <ddarius> edward2: Not a bad idea.
15:15:41 <Syzygy-> How would one actually use mfix?
15:15:51 <ddarius> Syzygy-: Usually via mdo.
15:16:02 <Syzygy-> ddarius: Huh? mdo?
15:16:06 <Syzygy-> :t fix
15:16:10 <Syzygy-> ?src fix
15:16:34 <ddarius> Syzygy-: Lookup mdo or recursive do notation in the GHC User Guide in the extensions section.
15:17:14 <oerjan> hmph mfix' is not correct either.
15:18:57 <lambdabot> fix f = let x = f x in x
15:19:10 <gwern> so I was converting my little bot to use bytestrings (hopefully it'll improve memory usage), and I'm having a bit of trouble. I was using the Data.Set toList . fromList combo to remove duplicate entries in my list of strings, but Data.Set doesn't appear to operate on Data.ByteString.Char8s, and the latter doesn't appear to provide any sort of nub
15:19:12 <mehrheit> @doc Data.List
15:19:12 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-List.html
15:19:40 <gwern> am I supposed to convert back to a regular [String] if I want remove dupes?
15:20:03 <zeeeee> hey, are h4sh binaries available anywhere?
15:20:04 <sorear> Ahem?
15:20:09 <hpaste>  dukedave pasted "Parsec question" at http://hpaste.org/346
15:20:17 <dukedave> Quick one there,
15:20:17 <sorear> Bytestrings can too be put into sets!
15:20:27 <sorear> you must be doing something wrong.
15:20:47 <sorear> ByteString can do *everything* string can.
15:21:03 <gwern> hmm. maybe my diagnosis was wrong then
15:21:15 * gwern will ponder over my code and the compilation errors some more then
15:21:39 <zeeeee> i'm trying to build h4sh but it requires plugins -> haskell-src -> happy. i installed happy but haskell-src complains "Setup.hs: Language/Haskell/Parser.ly: no happy preprocessor available"
15:21:43 * SamB thinks he's going about his assembler all wrong...
15:21:49 <sorear> > S.toList $ S.fromList [ Data.ByteString.Char8.pack "foo", Data.ByteString.Char8.pack "bar", Data.ByteString.Char8.pack "foo" ] -- gwern: this really does work!
15:21:57 * SamB wonders off to read the uniplate paper...
15:22:24 <sorear> (except for the minor fact that the bot is dead)
15:23:19 <sorear> @quit
15:24:04 <lambdabot>   Not in scope: `Data.ByteString.Char8.pack'
15:24:30 <ddarius> Couldn't we implement a @restart command.
15:26:06 <LoganCapaldo> @tell glguy I have the rough sketch of a preview functionality added to hpaste. Let me know if you want it and/or would like me to polish it up
15:26:12 <lambdabot> Consider it noted.
15:26:18 <sorear> > 2 + 2
15:26:26 <lambdabot>  4
15:26:40 <sorear> > S.toList $ S.fromList [ Data.ByteString.Char8.pack "foo", B.pack "bar", B.pack "foo" ] -- gwern: this really does work!
15:26:48 <lambdabot>   Not in scope: `B.pack'
15:26:55 <sorear> > S.toList $ S.fromList [ Data.ByteString.Char8.pack "foo", P.pack "bar", P.pack "foo" ] -- gwern: this really does work!
15:26:59 <oerjan> > let s' c = '\'':tail (show c); mfix' f = l where l = case fix (f . head) of [] -> []; x@(_:_) -> x ++ concatMap f (tail l) in mfix' s'
15:27:00 <lambdabot>   Not in scope: `P.pack'
15:27:04 <lambdabot>  "'\\'''\\\\''\\'''\\'''\\'''\\\\''\\\\''\\'''\\'''\\\\''\\'''\\'''\\'''\\\\'...
15:27:07 <oerjan> finally
15:27:28 <oerjan> that's what mfix show "should" produce.
15:27:49 <shachaf> sorear++
15:27:52 <oerjan> but both mfix (for lists) and show (for Chars) are broken.
15:27:53 <mehrheit> @pl \x -> [id x]
15:27:54 <lambdabot> return
15:27:54 <shachaf> lambdabot++
15:28:59 <oerjan> the show case may be a matter of opinion, but not the mfix one, i think
15:29:48 <kpreid> oerjan: how is mfix for lists broken?
15:30:11 <SamB_XP> @type mfix
15:30:12 <zeeeee> are h4sh binaries available anywhere? i'm trying to build h4sh but it requires plugins -> haskell-src -> happy. i installed happy but haskell-src complains "Setup.hs: Language/Haskell/Parser.ly: no happy preprocessor available"
15:30:12 <oerjan> kpreid: it assumes the function produces only a single element list
15:30:14 <lambdabot> forall a (m :: * -> *). (MonadFix m) => (a -> m a) -> m a
15:30:54 <SamB_XP> > mfix (1:)
15:30:55 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
15:30:55 <lambdabot>       Expected...
15:30:58 <SamB_XP> hmm.
15:31:05 <SamB_XP> > mfix (:[1])
15:31:07 <lambdabot>  Exception: <<loop>>
15:31:10 <sorear> oerjan: how is show broken?
15:31:20 <SamB_XP> > mfix (:[])
15:31:22 <lambdabot>  Exception: <<loop>>
15:31:24 <kpreid> > take 1 $ show (undefined::Char)
15:31:26 <lambdabot>  Undefined
15:31:29 <kpreid> sorear: like that
15:31:32 <SamB_XP> I suppose that ought to happen...
15:31:39 <oerjan> sorear: show for a Char always starts with '\'', but this is not produced lazily.
15:31:45 <sorear> ah.
15:31:53 <monochrom> > take 1 (undefined : undefined)
15:31:55 <lambdabot>  Undefined
15:31:59 <SamB_XP> @type (:[1])
15:32:00 <monochrom> sorry
15:32:03 <lambdabot> forall a. (Num a) => a -> [a]
15:32:04 <kpreid> > fix (head . show) :: Char
15:32:06 <monochrom> > take 1 ('c' : undefined)
15:32:07 <lambdabot>  Exception: <<loop>>
15:32:08 <lambdabot>  "c"
15:32:44 <ddarius> oerjan: The definition in the Prelude in the Report is strict, but that may be an oversight.
15:33:18 <SamB_XP> > mfix (([1]++) . return)
15:33:21 <lambdabot>  Exception: stack overflow
15:33:55 <SamB_XP> > mfix (const "hi!")
15:33:58 <lambdabot>  "hi!"
15:34:12 <oerjan> ddarius: i figure.  also this is not a particularly important case, since it will probably only show up in tricks like this.
15:34:58 <SamB_XP> oerjan: it might be confusing though
15:38:52 <oerjan> actually i am not quite sure that is how mfix is broken.  what is clear is that it assumes mfix (tail . f) = tail . mfix f, which presumably is not true.
15:39:52 <monochrom> > tail undefined
15:39:54 <lambdabot>  Undefined
15:40:22 <monochrom> > tail []
15:40:22 <oerjan> where would i send an error report?
15:40:24 <lambdabot>  Exception: Prelude.tail: empty list
15:42:06 <kpreid> oerjan: -- Maintainer  :  libraries@haskell.org
15:42:07 <SamB_XP> @free (a -> [a]) -> [a]
15:42:08 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:42:21 <SamB_XP> @free mfix :: (a -> [a]) -> [a]
15:42:22 <lambdabot> $map f . g = h . f => $map f (mfix g) = mfix h
15:46:32 <oerjan> do the theorems work for things defined recursively?
15:46:43 <monochrom> Yes.
15:47:28 <SamB_XP> do they work for lifted types?
15:47:43 <sorear> Yes.
15:48:05 <kpreid> @free foo :: (a -> b) -> b
15:48:06 <lambdabot> g . h = k . f => g (foo h) = foo k
15:48:22 <monochrom> > map (take 10) $ mfix (\xs -> map ( : xs) [0,1,2])
15:48:24 <lambdabot>  [[0,0,0,0,0,0,0,0,0,0],[1,1,1,1,1,1,1,1,1,1],[2,2,2,2,2,2,2,2,2,2]]
15:48:34 <SamB_XP> @. free type fix
15:48:38 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
15:48:40 <SamB_XP> hmm.
15:48:44 <SamB_XP> @type fix
15:48:45 <kpreid> SamB: @free type
15:48:46 <lambdabot> forall a. (a -> a) -> a
15:48:47 <kpreid> er
15:48:49 <kpreid> @free fix
15:48:52 <lambdabot> f . g = h . f => f (fix g) = fix h
15:49:01 <SamB_XP> oh. it doesn't like the forall?
15:49:27 <monochrom> > map (take 10) $ mfix (\xs -> map (const []) [0,1,2])
15:49:27 <kpreid> if you don't give a type it looks it up like @type
15:49:29 <lambdabot>  [[],[],[]]
15:49:30 <kpreid> no, it doesn't like not getting a name
15:49:32 <kpreid> @type doesn't give a name
15:49:35 <lambdabot> Not in scope: `doesn't'
15:49:35 <lambdabot>  
15:49:35 <lambdabot> <interactive>:1:8: Not in scope: `give'
15:49:43 <SamB_XP> kpreid: oh right
15:50:11 <monochrom> oerjan: could you say again what is broken in mfix for list? any simple example that exhibits wrong behaviour?
15:51:01 <oerjan> > mfix ((1:).(:[]))
15:51:04 <lambdabot>  Exception: stack overflow
15:51:17 <oerjan> er no
15:51:23 <oerjan> > mfix ((1:2:).(:[]))
15:51:25 <lambdabot>      The operator `:' [infixr 5] of a section
15:51:25 <lambdabot>         must have lower precede...
15:51:40 <oerjan> > mfix (([1,2]++).(:[]))
15:51:43 <lambdabot>  Exception: stack overflow
15:51:52 <oerjan> that one, i think
15:52:19 <oerjan> @let mfix' f = l where l = case fix (f . head) of [] -> []; x@(_:_) -> x ++ concatMap f (tail l)
15:52:21 <lambdabot> Defined.
15:52:30 <oerjan> > mfix' (([1,2]++).(:[]))
15:52:32 <lambdabot>  [1,2,1,1,2,2,1,2,1,1,2,1,1,2,2,1,2,2,1,2,1,1,2,2,1,2,1,1,2,1,1,2,2,1,2,1,1,2...
15:52:55 <oerjan> and that's what it should do.
15:56:30 <nominolo> hm, anyone know when the pretty, process, old-time and directory packages were introduced?
15:56:58 <SamB> @where uniplate
15:56:58 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/uniplate
15:59:10 <oerjan> :t mfix'
15:59:12 <lambdabot> Not in scope: `mfix''
15:59:47 <oerjan> :t let mfix' f = l where l = case fix (f . head) of [] -> []; x@(_:_) -> x ++ concatMap f (tail l) in mfix'
15:59:49 <lambdabot> forall a. (a -> [a]) -> [a]
16:05:12 <monochrom> Interesting. Thanks oerjan.
16:06:06 <oerjan> monochrom: are you responsible for that function or should i tell someone else?
16:07:07 <monochrom> Perhaps post to haskell-cafe or libraries. No, I am not responsible, someone else.
16:07:21 <ddarius> It says in the documentation.
16:07:27 <ddarius> @docs Control.Monad.Fix
16:07:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad-Fix.html
16:07:40 <monochrom> "libraries@haskell.org" :)
16:22:55 <SamB> libraries is a very friendly person
16:23:07 <SamB> he talks to himself a lot for some reason
16:26:41 * SamB thinks $(derive ''Eq ''Color) would be nicer syntax than $(deriveEq ''Color)
16:27:03 <SamB> or possibly...
16:27:14 <sorear> SamB: we don't have deriveEq
16:27:25 <SamB> oh.
16:27:26 <SamB> true.
16:27:26 <sorear> $(derive makeEq ''Color) is the correct syntax
16:27:49 <SamB> well, my point was it would be nicer to pass in the type name instead of some strange function with Eq stuck on the end of it ;-)
16:27:50 <sorear> besides, ''Eq is ill-typed, because Eq isn't a type
16:28:16 <SamB> *Main> ''Eq
16:28:16 <SamB> Loading package template-haskell ... linking ... done.
16:28:16 <SamB> GHC.Base.Eq
16:28:29 <SamB> ... so you say that that is ill-typed?
16:28:30 * sorear gapes!
16:28:41 <sorear> didn't work the last time I tried it :)
16:28:51 <SamB> oh. maybe it wasn't intended.
16:29:10 <SamB> ... don't see why it would be unintended though...
16:29:21 <Igloo> It's intended
16:30:20 <SamB> why does the documentation claim that [t| ... |] is unimplemented?
16:30:29 <SamB> it seems to work here...
16:30:45 <SamB> unfortunately it seems to want types there...
16:33:06 <Igloo> Where does it claim that?
16:33:19 <lispy>     My brain just exploded.
16:33:19 <lispy>     I can't handle pattern bindings for existentially-quantified constructors.
16:33:28 <lispy> that's what ghc just said to me
16:34:17 <Igloo> lispy: I think using case rather than let will fix that
16:34:41 <lispy> oh, i use 'where', so i'll try a case
16:34:54 <lispy> thanks for the hint
16:35:07 <Igloo> np
16:36:36 <SamB> @hoogle concatMapM
16:36:36 <lambdabot> No matches found
16:37:48 <Igloo> SamB: Where does the documentation claim that?
16:38:21 <SamB> http://www.haskell.org/ghc/docs/latest/html/users_guide/template-haskell.html
16:38:23 <lambdabot> Title: 7.6. Template Haskell, http://tinyurl.com/y3camx
16:38:55 <SamB>   o [Planned, but not implemented yet.] [t| ... |], where the "..." is a type; the quotation has type Type.
16:39:05 <lispy> now i get a type error, which is what i actually expected
16:39:33 <Igloo> SamB: Aha, ta
16:41:45 <SamB> okay... how come when I add a LANGUAGE or OPTIONS_GHC pragma to a Happy grammar, all hell breaks loose?
16:42:13 <SamB> or rather, all these "happy" names suddenly become undefined...
16:43:24 <emu> pragmas make Happy unhappy?
16:46:07 <SamB> @bug
16:46:07 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
16:48:19 <SamB> hmm, Language.Haskell.TH.Syntax.Q isn't a Functor. what "component" does that count as?
16:48:19 <jfredett> is there a way to do function composition exponentiation? that is:
16:48:19 <jfredett> (f . g) ^ k = (f . g)^k-1 . (f . g), with (f.g)^1 = (f.g) ?
16:49:50 <jfredett> maybe? anyone? :)
16:49:53 <oerjan> jfredett: iterate
16:49:57 <jfredett> brilliant
16:50:00 <lispy> instance Num (a -> b) where -- maybe?
16:50:15 <lispy> oh, maybe that needs to be a -> a
16:50:17 <jfredett> @type iterate
16:50:20 <lambdabot> forall a. (a -> a) -> a -> [a]
16:50:21 <oerjan> :t iterate
16:50:23 <lambdabot> forall a. (a -> a) -> a -> [a]
16:50:24 <kpreid> f ^ 0 = id; f ^ n = f . f ^ (pred n)
16:50:38 <jfredett> brilliant
16:51:00 <jfredett> is there an iterate while?
16:51:00 <jfredett> @hoogle iterateWhile
16:51:01 <lambdabot> No matches found
16:51:08 <jfredett> @hoogle iterate
16:51:08 <lambdabot> Prelude.iterate :: (a -> a) -> a -> [a]
16:51:12 <jfredett> hmm
16:51:17 <oerjan> :t until
16:51:19 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
16:51:20 <lispy> jfredett: takeWhile + iterate
16:51:25 <jfredett> freaking brilliant
16:51:35 <lispy> ?src until
16:51:35 <lambdabot> until p f x | p x       = x
16:51:36 <lambdabot>             | otherwise = until p f (f x)
16:53:14 <kpreid> > iterate (++"x") "" !! 10
16:53:17 <lambdabot>  "xxxxxxxxxx"
16:53:30 <jfredett> one last question.
16:53:46 <lispy> jfredett: it's your last, better mak it good :)
16:53:52 <jfredett> can I do an until with a "lookback", that is
16:53:58 <jfredett> I have a function "applyClosure"
16:54:05 <jfredett> which applys a binary function over a list
16:54:20 <jfredett> I want it to apply it until we get the same list twice (the closure is complete)
16:54:26 <lispy> usually if you want a look back, you want to use a list
16:54:38 <lispy> hrm
16:54:53 <jfredett> so effectively, I want to do until (\a -> a == <previous a>)
16:55:01 <jfredett> applyClosure ... blah
16:55:06 <lispy> fix
16:55:08 <lispy> ?
16:55:10 <jfredett> :t fix
16:55:13 <lambdabot> forall a. (a -> a) -> a
16:55:22 <lispy> ?src fix
16:55:22 <lambdabot> fix f = let x = f x in x
16:55:26 <oerjan> well if l is your list of iterations, you might do a search on (l, tail l)
16:55:30 <Saizan> you have to use a pair of list
16:55:53 <jfredett> fix looks interesting -- it finds fixpoints? I assume
16:55:56 <lispy> i bet you colud do this with fix
16:56:03 <lispy> > fix show
16:56:03 <SamB> least fixed points
16:56:05 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:56:18 <jfredett> which is what I need.
16:56:21 <jfredett> i think-
16:56:27 <lispy> i think so too
16:56:32 <oerjan> jfredett: it depends how your function works.
16:56:33 <jfredett> hmm
16:56:42 <jfredett> I'll give it a shot w/ fix
16:56:57 <lispy> your closure is the least fix point of the operation you use to find closure
16:57:20 <jfredett> right
16:57:23 <lispy> and now, that's brilliant
16:58:06 <monochrom> least fixed point means recursion.
16:58:09 <oerjan> jfredett: if your function is lazy enough, fix should work.  but if it is strict in its argument, you need something else.
16:58:24 <jfredett> its not strict anywhere, as far as i can tell
16:58:50 <oerjan> @src fix
16:58:50 <lambdabot> fix f = let x = f x in x
16:58:52 <Saizan> what about this: until (\(x,y) -> x == y) (\(x,y)-> (func x,x)) (list,[])
16:58:53 <SamB> we really need better language for strictness
16:59:46 <jfredett> @hoogle fix
16:59:47 <lambdabot> Control.Monad.Fix.fix :: (a -> a) -> a
16:59:47 <lambdabot> Control.Monad.Fix :: module
16:59:47 <lambdabot> System.IO.fixIO :: (a -> IO a) -> IO a
17:01:10 <jberg> uhm, i have a function next which returns a list, then i want to call next again with the list it returned, and call next again with the list it returned and so on.. so i want and infinite list of lists all generated by next, but i dont know how?
17:01:14 <SamB> sorear: how do I get a biplate instance?
17:01:21 <SamB> for that matter, where do I get the class?
17:01:24 <jfredett> cool, that totally works
17:01:45 <ari> jberg: iterate?
17:02:01 <monochrom> iterate next
17:02:05 <jberg> is that a function in the prelude?
17:02:07 <ari> @type iterate
17:02:09 <lambdabot> forall a. (a -> a) -> a -> [a]
17:02:16 <oerjan> someone is iterating the questions!
17:02:21 <monochrom> iterate next seeding_list
17:02:27 <jberg> ok ill check it out
17:02:28 <jberg> thanks
17:02:44 <sorear> SamB: Biplate?
17:03:13 <SamB_XP> sorear: oh, right, you can't actually read ndm's mind
17:03:47 <sorear> SamB_XP: it's called uniplate, the class is in the library, and Dâ§erive can make it.
17:03:58 <SamB_XP> sorear: there is another class
17:04:04 <SamB_XP> called Biplate
17:05:07 <SamB_XP> I think I need it for mutually recursive datatypes?
17:07:20 <SamB_XP> or even for finding all the things of one type inside a thing of another type
17:07:57 <timthelion> hey, in lisp, there are symbols which can be passed to a function.  so you can make a function that takes 'master-only 'no-magnification and 'magnification as the possible symbols. is there a concept like this in haskell? what is it called?
17:08:18 <jfredett> Datatype?
17:08:44 <jfredett> data SymbolSubstitute = MasterOnly | NoMag | ...
17:09:01 <jfredett> then do a pattern match on the input?
17:09:06 <Cale> Right.
17:09:06 <timthelion> ok
17:09:13 <jfredett> Cale: I was right?!
17:09:18 <Cale> Yep.
17:09:18 <ddarius> Yes
17:09:26 <jfredett> kickass- that'd be my first nontrivial haskell question answered
17:09:26 <lispy> indeed.
17:09:39 <SamB> sorear: oh, apparantly I need PlateDirect
17:09:40 <timthelion> but after that, I can just use MasterOnly, I don't need SymbolSubstitute.MasterOnly
17:09:48 <ddarius> Yes.
17:09:56 <ddarius> E.g. data Bool = False | True
17:10:21 <lispy> SymbolSubstitute.MasterOnly isn't valid haskell
17:10:23 <timthelion> ok, but I have to make the argument typed as SymbolSubstitude
17:10:28 <lispy> right
17:10:33 <sorear> timthelion: it's inferred!
17:10:39 <lispy> it's an algebraic datatype
17:11:21 <timthelion> ok, thanks guys, makes my code much more readable than having a string of 2 bools to do that list
17:11:59 <lispy> yeah
17:12:04 <lispy> it's a great habit to get into
17:16:15 <SamB> sorear: what are |+ and +|
17:16:23 <sorear> No clue!
17:17:18 <dons> quicksilver: yeah, zips fuse under stream fusion, see the latest paper.
17:17:30 <SamB> what's l1? and how is it wise?
17:17:34 <dons> pretty much everything you're likely to use fuses.
17:17:55 <oerjan> right, my mail to libraries@haskell.org was rejected because i am not subscribed.
17:17:56 <SamB> dons: tails?
17:18:01 <timthelion> wow, I can barly tell that is el one not el el or one one
17:18:10 <sorear> hiya dons.
17:18:46 <jberg> can i abort ghci in a calculation from emacs?
17:18:53 <sorear> Yes.
17:18:55 <sorear> C-c C-c
17:18:59 <jberg> thanks
17:19:05 <aheller> so, google hasn't been to helpful; I'm trying to build lambdabot with ubuntu's ghc6.6 and attendent packaged libraries, and the build script fails with: Setup.hs: cannot satisfy dependency haskell-src-any.  What's the obvious thing I've forgotten?
17:19:24 <sorear> haskell-src
17:19:39 <sorear> libghc6-haskell-src-dev probably
17:20:41 <aheller> sorear: thanks! we'll see what I've missed next, now.
17:21:05 <dons> SamB: `likely to use' :-)
17:21:31 <SamB> dons: ... and tails isn't one of those?
17:21:32 <dons> the *By functions don't, either. or its not worth to fuse them anyway
17:21:47 <dons> there's things that could fuse, but it may not be efficient to do so
17:22:10 <dibblego> ?check \xs -> foldl' (const (+1)) 0 xs == length xs
17:22:14 * SamB is teasing dons, actually.
17:22:19 <lambdabot>  Falsifiable, after 0 tests: [-2,2]
17:22:24 <dibblego> can length be written in terms of foldl?
17:22:24 * SamB already tried to implement half-fusable tails
17:22:39 * SamB decided it wasn't worth the effort of getting it through the tests...
17:23:02 <dons> dibblego: sure.
17:23:32 <dons> its defined in terms of foldl in the standard, ,iirc
17:23:37 <dibblego> oh
17:23:51 <dibblego> ?src length
17:23:51 <lambdabot> Source not found. My mind is going. I can feel it.
17:24:02 <dons> its not implemented in practice as a foldl though
17:24:06 <SamB> why doesn't it say "dave"?
17:24:10 <dibblego> ok
17:24:22 <SamB> as in "My mind is going, dave. I can feel it.
17:24:27 <sorear> dons: this would be so much nicer if haskell was call-by-name :P
17:24:27 <dons> ?pl \n _ -> n + 1
17:24:28 <lambdabot> const . (1 +)
17:24:33 <sorear> dons: no sharing worries!
17:24:45 <dons> ?let len = foldl (const . (1 +)) 0
17:24:46 <lambdabot> Defined.
17:24:55 <dons> > len "haskell"
17:24:56 <lambdabot>  7
17:25:01 <dons> > len [1..]
17:25:07 <lambdabot> Terminated
17:25:23 <dibblego> gah of course, thanks
17:25:24 <sorear> > len [1..1000000]
17:25:27 <lambdabot>  Exception: stack overflow
17:25:30 <dons> :-)
17:25:30 <sorear> > length [1..1000000]
17:25:33 <lambdabot>  1000000
17:25:52 <dons> ?let len' :: [a] -> Int ; len' = foldl' (const . (1 +)) 0
17:25:53 <lambdabot> Defined.
17:25:57 <dons> > len' [1..1000000]
17:25:59 <lambdabot>  1000000
17:26:00 <sorear> of course, lambdabot can do FUSION
17:26:06 <dons> indeed!
17:26:33 <dons> ?let len_ :: [a] -> Int ; len_ = foldl (const . (1 +)) 0
17:26:35 <lambdabot> Defined.
17:26:38 <dons> > len_ [1..1000000]
17:26:40 <lambdabot>  1000000
17:26:41 <dons> Int is good.
17:26:48 <SamB> sorear: so, can you explain why Derive doesn't use qualified names?
17:27:01 <sorear> SamB: GHC.Base.+
17:27:07 <SamB> hmm.
17:27:15 <dibblego> pl or unpl changes the type
17:27:22 <sorear> SamB: IOW they don't work on Neil's compiler of choice
17:27:29 <SamB> okay, can you explain why the various modules don't say what you should import to use their derivings?
17:27:31 <dons> sorear: i'm surprised you didn't do a draft md5 on bytestrings over night.
17:27:31 <sorear> yay hugs compatibility
17:28:04 <dons> dibblego: they can, yes. they're lisp macro style rewrites ;)
17:28:19 <dibblego> dons, not in this case, I'm just retarded
17:28:20 <dons> they shouldn't though. its a feature if they do
17:28:35 <dons> ?pl foo x x foo
17:28:35 <lambdabot> foo x x foo
17:28:41 <SamB> sorear: well, I think the GHC.* names are enough excuse without bringing portability to non-ghc into it ;-)
17:28:52 <sorear> ?. type pl \x -> [x]
17:28:53 <dons> ?pl foo x (\ x -> x (foo x ))
17:28:54 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:28:54 <lambdabot> foo x (ap id foo)
17:29:08 <dons> it also introduces type cass constraints happily
17:29:18 <sorear> dons: btw, lambdabot started seriously acting up earlier; I had to @quit it
17:29:29 <dons> ok .
17:29:31 <SamB> though I think the real solution would be to have TH resolve qualified names...
17:29:32 <sorear> dons: thankfully it autorestarted :)
17:29:36 <dons> right
17:29:56 <SamB> sorear: doesn't that sound nice?
17:29:59 <dons> we should probably consider lambdabot as a draft
17:30:14 <dons> someone with a couple of years handy should sit down and reimplement lambdabot from the ground up.
17:30:30 <dons> i've done my tour of duty with lambdabot though, so it won't be me.
17:31:12 <sorear> dons: friendlyToaster, a closed source bot in #friendly-coders, seems to do most of what lambdabot does, and claims to be <300 lines of PHP.  *shudder*
17:31:12 <dons> bytestrings, less hacky threading. associated types for module state. robust error handling from scratch
17:31:25 <dons> heh i don't think it could really do 'most of what lambdabot does'
17:31:37 <dons>  @pl and @eval take some effort
17:32:06 <dons> i thought you were writing lambdabot 7, sorear ?
17:32:14 <sorear> were
17:32:25 <sorear> I forgot how I was going to handle state :(
17:32:26 <dons> i suppose in the end i could another lambdabot.
17:32:50 <dons> we've learnt a lot about how to do extensible irc bots properly
17:33:00 <SamB> then you can make us write all the plugins again
17:33:10 <dons> nah, i'd try to keep all the plugins
17:33:22 <dons> just redo the core to be more robust, and you know, actually follow the spec
17:33:24 <SamB> ... and fix vixen?
17:33:28 <dons> shrug
17:33:43 <SamB> sorear: I know! you can write a program to fix vixen!
17:36:54 <SamB_XP> ... it seems kind of funny to derive Biplate instances that use Data.Generics...
17:38:02 <Saizan> scrap the boilerplate of scrapping your boilerplate?
17:38:52 <SamB_XP> ... something like that
17:39:01 <SamB_XP> using TH to scrap even more boilerplate
17:39:07 <SamB_XP> ... I suppose
17:39:57 <dibblego> ?check \xs -> foldl' (\ys y -> y : ys) [] xs = reverse xs
17:39:57 <lambdabot>  Parse error
17:40:01 <sorear> @go uniplate
17:40:04 <lambdabot> http://www.applegate.co.uk/company/11/88/494.htm
17:40:04 <lambdabot> Title: Uniplate Ltd
17:40:05 <dibblego> ?check \xs -> foldl' (\ys y -> y : ys) [] xs == reverse xs
17:40:06 <lambdabot>  Add a type signature
17:40:15 <dibblego> ?check \xs -> foldl' (\ys y -> y : ys) [] xs == reverse (xs :: [Int])
17:40:17 <lambdabot>  OK, passed 500 tests.
17:40:30 <SamB> yeah, derive supports that method
17:41:10 <SamB> @tell ndm Biplate seems to require another extension besides MPTCs
17:41:10 <lambdabot> Consider it noted.
17:41:49 <ndm> SamB, which one? overlapping instances?
17:41:49 <lambdabot> ndm: You have 1 new message. '/msg lambdabot @messages' to read it.
17:41:56 <ndm> @clear-messages
17:41:56 <lambdabot> Messages cleared.
17:42:49 <ndm> @seen augustss_
17:42:50 <lambdabot> augustss_ is in #haskell. I don't know when augustss_ last spoke.
17:43:15 <SamB> ndm: actually wait.
17:43:23 <SamB> GHC requires better error messages.
17:43:33 <SamB> ... or something.
17:43:43 <SamB> I added MultiParamTypeClasses and it works now...
17:44:01 <SamB> even though it gave me:
17:44:03 <SamB>     Illegal instance declaration for `PlateAll Line Line'
17:44:03 <SamB>         (The instance type must be of form (T a b c)
17:44:03 <SamB>          where T is not a synonym, and a,b,c are distinct type variables)
17:44:05 <SamB> before
17:44:24 <ndm> technically all of the ones that implement Biplate require overlapping instances
17:44:38 <ndm> but you could implement Biplate without it, and the instances aren't actually overlapping
17:44:41 <Igloo> You really want FlexibleInstances or something; it just happens to work as both currently add -fglasgow-exts
17:45:00 <SamB> Igloo: are you telling me that LANGUAGE is broken?
17:45:03 <SamB> it should warn about that
17:45:07 <ndm> SamB, Class Type Type /= Class Type is the error message
17:45:25 <ndm> SamB, it is in GHC 6.4, which is why I have -fglasgow-exts as well
17:45:39 <ndm> SamB, out of curiosity, which Biplate instances are you using?
17:45:58 <SamB> I was just going to use the Direct ones
17:46:40 <SamB> I have like 3 types that could possibly be involved...
17:46:58 <SamB> so I figured O(n^3) was fine
17:47:08 <SamB> er.
17:47:13 <SamB> O(3^2).
17:47:39 <ndm> SamB, fair enough - its rarely even that high, since its usually a very restricted set of those you actually use
17:47:40 <SamB> anyway it works out to being a small, constant bound ;-)
17:48:51 <SamB> it just seems like it will be easier to use biplate than to duplicate the hairy details of an ancient PDP-1 program ;-)
17:50:53 <ndm> Uniplate/Biplate are really useful, once you have learnt them
17:51:25 <ndm> i helped Matt (my office mate) half the number of lines in his PhD using Uniplate - I just showed him the first 2 changes and he did the rest on his own
17:51:43 <ndm> it was really cool - for every question he asked i could just point him at a section in the paper :)
17:53:52 <ndm> of course, i'm curious how people get on with it in general - so if you have any overall impression i'd love to hear it - once you've had a bit more experience with it
17:57:29 <sorear> ndm: I'm writing a haskell compiler, and expect to find many testing opportunities once I get past the parser :)
17:58:28 <ndm> sorear, are you writing a translator to Yhc.Core as part of that?
17:58:37 <sorear> yes
17:58:47 <ndm> Yhc.Core provides Uniplate instances for free
17:59:04 <sorear> haskell -> bigfattree -> yhc.core -> yhc.hbc
17:59:20 <ndm> I'm just rewriting the Simplifier in Yhc.Core at the moment to make it extensible
17:59:35 <ndm> thats the way I'd do it, if i had the time :)
18:00:32 <ndm> if you can get from haskell to yhc.core, we'll have the rest of the compiler done by the time you get there
18:01:10 <jsnx> i would like to write apps in Haskell on my Linux box and ship them to Windows consumers -- how do I do it?
18:01:29 <lispy> jsnx: hire a team to do windows quality assurance
18:01:43 <ndm> jsnx, open source?
18:01:43 <jsnx> lispy: ha ha
18:01:48 <jsnx> lispy: why?
18:02:02 <lispy> jsnx: no really, if don't do your testing there, how can you expect it to work well there?
18:02:03 <jsnx> ndm: that's the last question I expected...
18:02:24 <jsnx> lispy: works fine for ruby, man
18:02:38 <ndm> jsnx, if its a useful program and its open source someone will compile it for you - one day hackage may even be able to compile it for you
18:02:44 <jsnx> lispy: these are the kinds of things i need to know
18:02:57 <jsnx> ndm: well, it's not always something i want to distribute
18:03:14 <ndm> jsnx, i do the reverse - develop on windows and deploy to linux, i've never had it go wrong yet - be sensible with the filepath library (rather than explicit filepath ops), and don't require the unix package
18:03:24 <lispy> jsnx: then use the same gui library that ruby uses :)
18:03:29 <ndm> other than that, Haskell is very cross platform
18:03:33 <jsnx> ndm: how do you do it?
18:03:42 <dons> just write in h98, avoid unixy libs..
18:03:43 <lispy> jsnx: but i seriously doubt that the ruby stuff works perfectly on windows when it was developed for linux
18:03:51 <lispy> jsnx: because this doesn't even happen with java
18:03:56 <ndm> jsnx, i just develop on windows, and release the source, then it works on linux every time
18:04:00 <jsnx> dons: how do I compile it?
18:04:14 <dons> oh, you want to also ship binaries for windows, without a windows installation?
18:04:16 * sorear sees dons advocate h98, faints
18:04:17 <ndm> jsnx, look at Cabal, thats cross-platform way of compiling
18:04:21 <Igloo> You can't compile for Windows on a Linux machine, if that's what you mean
18:04:24 <sorear> yhc!
18:04:28 <jsnx> dons: yes
18:04:31 <ndm> dons, i wouldn't have even suggested h98 restriction...
18:04:33 <jsnx> Igloo: oh, fudge
18:04:42 <sorear> Igloo: Not with ghc maybe, but it can be done in general
18:04:46 <jsnx> sorear: really?
18:04:50 <sorear> Igloo: mingw32 runs unix-hosted
18:04:52 <dons> ndm, that's guaranteed to work though :-)
18:05:07 <jsnx> sorear: they do javascript as well, I hear
18:05:25 <sorear> jsnx: More pertinantly, they do portable bytecode.
18:05:26 <ndm> dons, not really, we're still lacking any implementation of h98
18:05:41 <olsner> if you're serious about having windows customers, you should have at least one windows machine to build and test on anyway
18:06:08 <jsnx> olsner: thank you for your advice
18:06:21 <jsnx> olsner: right now though, that's not what i'm trying to find out about
18:07:09 <olsner> I mean, regardless of how portable libraries/compilers/languages turn out to be and the possibility of cross-compilation.. which sounds like what you wanted to know about ;-)
18:07:38 <jsnx> sorear: do you think i could use mingw32 to compile windows binaries?
18:07:38 <ndm> jsnx, summary: the language is portable, most libraries are portable, you can't cross compile and you should always test
18:07:56 * olsner goes to sleep
18:08:01 <jsnx> ndm: thank you ndm
18:08:07 <sorear> jsnx: Yes you could.  but mingw32 only does c / c++
18:08:19 <jsnx> sorear: oh, fudge
18:08:25 <sorear> jsnx: GHC doesn't support cross compiling anything except itself
18:08:44 <sorear> jsnx: you could probably run a Windows GHC build under Wine
18:08:55 <jsnx> sorear: lol
18:09:12 <sorear> seriously, that's the way we "cross compile" here :(
18:09:13 <dons> i've run a linux ghc under openbsd emulation, profitably
18:09:20 <dons> geerating linux binaries
18:09:26 <dons> which in turn run under emulation
18:09:38 <jsnx> dons: well, the bsds offer binary compatibility with linux
18:09:48 <sorear> dons: does ghc support obsd natively?
18:09:50 <jsnx> linux, however, does not offer binary compatibility with windows...
18:09:57 <sorear> jsnx: Sure it does.  see wine
18:09:57 <dons> i guess windows doesn't offer binary emulation of linux
18:10:09 <dons> otherwise you'd just ship linux binaries ;)
18:10:13 <dons> sorear: of course.
18:10:22 <jsnx> dons: that's what i'd need if i was going the other way.
18:10:25 <dons> i used to run 4.08.2 under linux emul.
18:10:43 <jsnx> sorear: thanks for the tip about wine
18:10:44 <weitzman> Technically windows can run posix stuff, for some very outdated and restricted definition of posix
18:10:54 <weitzman> The windows compatability layer is pretty odd
18:11:07 <weitzman> Win32 is actually implemented on top of NT, as it unix
18:11:11 <weitzman> Hence unix tools for window
18:11:11 <jsnx> sorear: you use this regularly i gather?
18:11:13 <weitzman> *s
18:11:17 <weitzman> </digression>
18:11:18 <sorear> jsnx: Not at all.
18:11:24 <jsnx> sorear: oh
18:11:35 <sorear> jsnx: I haven't touched windows programming in 3 years
18:11:52 <jsnx> sorear: do you by chance have any blog-postings, etc. so that i could find out more?
18:12:03 <sorear> nope.
18:12:03 <jsnx> sorear: well, i don't ever want to touch it
18:12:14 <jsnx> sorear: trying to protect myself
18:12:18 <sorear> hehe.
18:12:32 <jsnx> i'm looking at continuing with ruby or moving to scala or haskell
18:12:59 <ndm> jsnx, probably best to start learning Haskell first - its quite a big difference from Ruby or something
18:13:11 <weitzman> Incidentally, http://en.wikipedia.org/wiki/Microsoft_Windows_Services_for_UNIX
18:13:11 <lambdabot> Title: Microsoft Windows Services for UNIX - Wikipedia, the free encyclopedia
18:13:39 <jsnx> oh, i've been doing my reading...
18:13:48 <jsnx> recently learnt erlang
18:14:01 <jsnx> ndm: it's different but it's so sweet!
18:14:36 <dolio> dons: I've been trying my hand at making a ByteString md5 hash. It's still pretty slow, though.
18:14:41 <dons> cool!
18:14:45 <dons> dolio: i'm happy to look at it
18:14:50 <sorear> ndm: reading the plate paper - I'm not sure I understand what you mean by coinductive dictionaries
18:14:53 <dolio> Although, 40x slower instead of 400x. :)
18:14:54 <dons> just wanted someone to do the intial transposition :-)
18:15:04 <dons> dolio: oh, i think we can really do better
18:15:12 <dons> i'd suspect 2x, looking at md5.c
18:15:14 <sorear> ndm: ghc can typecheck   instance Foo a => Foo a   ?
18:15:19 <sorear> ndm: that can't be right...
18:15:21 <dons> there's nothing terribly problematic there, afaik
18:15:32 <jsnx> thank you everybody
18:15:32 <dons> dolio++ send it over when you're done
18:15:43 <jsnx> may be back soon...
18:15:55 <ndm> sorear, i'm not entirely sure either, but Ross told me so :) - it can't check that
18:16:12 <dons> btw guys, we should all keep this in mind :   "
18:16:24 <ndm> sorear, but i can check Foo a => Bar a, Bar a => Foo a, i think, and can build recursive dictionaries
18:16:24 <dons>   "The Lisp experience - 19-year old college student asks for help in #lisp, has to wait half an hour for a response; asks in #python, gets the answer in 6 minutes. Gives up on Lisp... "I'll wait for Arc, thanks."
18:16:39 <dons> 6 minutes seems too slow
18:16:42 <sorear> MPTC details make my head hurt.
18:16:52 * sorear looks forward to checking them
18:16:55 <ndm> sorear, read SYB "extensible generic functions with class" - they detail how coinductive dictionaries work
18:17:10 <sorear> dons: yeah, people here get answers in 6 seconds
18:17:24 <dons> in stereo
18:17:38 <dons> http://programming.reddit.com/info/1zym1/comments/c200so ;)
18:17:39 <lambdabot> Title: The Lisp experience - 19-year old college student asks for help in #lisp, has to ...
18:17:41 <sorear> ndm: thanks for the ref
18:17:58 <weitzman> Wait for Arc? Does anyone actually believe Arc is ever going to be for real?
18:18:16 <dons> seems a bit silly, doesn't it.
18:18:23 <Saizan> and dolby surround where available
18:18:26 <dons> wait for jhc? no. use what we have.
18:19:41 <ndm> no, wait for Supero!
18:20:02 <ndm> (which should massively outperform jhc if all you want to do is count lines all day)
18:21:17 <weitzman> I'm trying to figure out how long ago PG started working on Arc, but I can't see any obvious dates. Anyone know?
18:21:50 <ndm> PG is so often wrong in his articles, i'm sure his programming language would be equally wrong
18:21:55 <dons> jhc is pretty good though, ndm :-)
18:22:06 <tessier> hmm
18:22:23 <tessier> So I'm trying to do some of the examples in this Haskell book now that some things are starting to make sense about the theory of functional programming.
18:22:42 <tessier> I am in hugs. Do I need to somehow run a command to load the prelude or am I automatically in the prelude?
18:22:47 <ndm> dons, i like competition ;)
18:22:54 <dibblego> tessier, a former ##java member?
18:22:58 <ndm> tessier, is the problem related to ord or chr?
18:23:10 <sorear> what's Arc?
18:23:11 <mauke> tessier: the prelude is loaded by default
18:23:20 <tessier> And when I try to define a function by saying sum :: [Int] -> Int why do I get the error ERROR - Cannot find "show" function for: *** Expression : sum *** Of type    : [Int] -> Int
18:23:26 <tessier> dibblego: No. I can't stand java. :)
18:23:26 <mauke> sorear: next generation lisp
18:23:38 <weitzman> Arc is a LISP dialect that is supposed to be better than all other languages because Paul Graham is smarter than everybody
18:23:40 <tessier> dibblego: I hang out in #python, #lisp, #haskell, #erlang, #plone, etc.
18:23:43 <mauke> tessier: you can't define functions in hugs
18:23:48 <dibblego> tessier, ok, my mind is mixing up then
18:23:53 <tessier> mauke: ah. Hrm. Isn't that a fundamental part of haskell?
18:24:00 <mauke> yes, but not hugs
18:24:02 <aheller> still trying to build lambdabot... what do I do about "lexical error at character 'i'" ?
18:24:12 <ndm> tessier, you define the command in a file, save it with a .hs extension, then load it in Hugs
18:24:17 <mauke> the interactive environment only supports expressions
18:24:22 <dibblego> does anyone still use hugs?
18:24:36 <sorear> dibblego: you just insulted ndm, I think
18:24:38 <ndm> me!
18:24:43 <dibblego> sorry :)
18:24:43 <sorear> aheller: check - are you usign darcs lb, darcs hs-plugins, and ghc 6.6.x ?
18:24:45 <ndm> I develop Yhc in Hugs
18:24:52 <weitzman> Hugs has a nice interface on windows
18:24:57 <ndm> and Hoogle, and Catch, and Supero
18:24:58 <tessier> ndm: Hmm...If I can't write programs in hugs then what is it good for?
18:24:59 <dibblego> I meant it in a "I'm really naive" way :)
18:25:06 <aheller> sorear: yes, no -ubuntu's - yes
18:25:06 <weitzman> ghc is in a dos prompt on windows, which is not so cool
18:25:16 <Excedrin> ndm: were you planning on making a new winhugs or something similar?
18:25:23 <dibblego> does anyone still use windows?
18:25:25 <ndm> tessier, you can - you save the program in a file and load it
18:25:29 <mauke> tessier: interactive expression evaluation
18:25:33 <sorear> aheller: non-darcs hs-plugins is incompatible with ghc 6.6.x.
18:25:36 <ndm> weeitzman, GuiHaskell is being written to solve that
18:25:41 <aheller> sorear: I lie, I built hs-plugins
18:25:47 <sorear> ok.
18:25:50 <ndm> Excedrin, i have a summer of code student working on it this summer
18:26:18 <Saizan> tessier: you can't define functions at the hugs prompt, but you can write them in a .hs file and load it from hugs
18:26:27 <weitzman> dibblego: Touche. There are a few apps I like to use that are written for windows, and linux doesn't support my hardware too well. The next computer I buy will have linux supported hardware, I've decided
18:26:40 <aheller> sorear: ghc-pkg list gives me plugins 0.9.10 and plugins-1.0
18:27:29 <ndm> i use Windows and WinHugs all day long, its a fantastic environment, when combined with TextPad
18:27:55 <emu> i use ghci inside emacs which works on linux or windows
18:28:12 <mauke> something about the winhugs command history annoyed me
18:28:29 <mauke> I don't remember what it was, but it made me run ghci instead
18:28:33 <weitzman> I tried out the Haskell plugin for Eclipse, which makes ghc more bareable on windows except there's some kind of text output/buffering weirdness
18:28:47 <weitzman> Text appears in the middle of the prompt
18:29:09 <weitzman> Does ghc ever write to stderr?
18:29:40 <cdsmith> weitzman: I used eclipsefp for a while.  I finally gave up.  There's just too many weird broken things in it.
18:30:00 <ndm> mauke how long ago?
18:30:17 <mauke> good question
18:30:18 <weitzman> cdsmith: Yeah, I've decided that the optimal way to write haskell on windows is to use VMware
18:30:35 <mauke> several months, maybe a year?
18:30:53 <dons> weitzman: windows running in vmware, on linux?
18:30:59 <weitzman> Linux
18:31:10 <dons> linux running in vmware, on windows?
18:31:11 <weitzman> That way I can play counter-strike in real windows :)
18:31:18 <cdsmith> weitzman: I looked briefly at some called the "Crimson editor".  With some custom tool configuration for running GHC, it seemed usable.  But yeah, I develop on Linux now.
18:31:25 <weitzman> I've got a debian minimal image in vmware
18:31:30 <dons> ah right
18:31:33 <weitzman> Running xmonad
18:31:35 <emu> its amazing the extent people will go to avoid emacs :/
18:31:39 <weitzman> Which is sweet, by the way
18:32:29 <cdsmith> Everybody keeps raving about xmonad.  I'm almost convinced to install X-Windows on my Linux system so I can try it. :)
18:32:31 <aheller> Could it be that I've deleted the dependency on fps>=0.7 and replaced it with a dependency on binary in lambdabot.cabal.plugins?
18:33:30 <dons> aheller: can you just confirm you're using the darcs version of lambdabot?
18:34:11 <aheller> dons: yes
18:34:18 <|Steve|> Has anyone used ghci on ubuntu?
18:34:25 <dibblego> |Steve|, yes
18:34:25 <|Steve|> I get: ghc-6.6: not built for interactive use
18:35:07 <dons> aheller: here's the .cabal file i'm using with ghc 6.6, http://www.cse.unsw.edu.au/~dons/tmp/lambdabot.cabal
18:35:12 <aheller> dons: it builds fine if I don't do the copy to get eval working.
18:35:13 <dons> its the *-6.6 cabal file, iirc
18:35:27 <|Steve|> Is there anything special I need to do to get it to work dibblego?
18:35:39 <dibblego> |Steve|, sudo apt-get install ghc # on 7.04
18:35:46 <dibblego> I built it myself for dapper
18:36:15 <ddarius> |Steve|: I'm running Feisty Fawn and had got the ghc-6.6 package earlier and just ran GHCi and it ran fine.
18:36:49 <|Steve|> ghc is installed but ghci just doesn't work for me.
18:36:51 <aheller> dons: it's building now; thanks!
18:37:03 <|Steve|> Very annoying. But at least it runs on my other computers.
18:37:21 <cdsmith> dons: did you get the lambdabot patch I sent yesterday?  My email's been shaky.
18:37:44 <dons> cdsmith: an @pl fix/
18:37:50 <cdsmith> dons: yes
18:37:58 <dons> got it
18:38:01 <cdsmith> cool
18:40:31 <ndm> hmm, whats a good name for something that changes from
18:40:46 <ndm> func879234, func387433, func38439   to func1, func2, func3
18:40:53 <ndm> i've got uniqueFuncsConsecutive
18:41:06 <ndm> but consecutive doesn't feel like it should ever be a part of a function name...
18:41:28 <ddarius> rename
18:41:52 <dons> rename :-)
18:41:58 <dons> ?free sortBy
18:42:01 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
18:42:09 <dons> uses a nice 'rename' actually, to guess all those h/f/x/g's
18:42:25 <ndm> hmm, rename doesn't say how it renames them
18:42:34 <ndm> the point is it uses shorter more comprehensible names
18:42:42 <dons> renameFunctionsUsingNeilsAlgoForShortNames?
18:42:46 <ndm> (LAMBDA87923 was NEVER a good choice for an identifier)
18:42:47 <ddarius> simplifyName
18:43:00 <ndm> and the uniqueFuncs bit stays
18:43:08 <ndm> its just hte consecutive that feels wrong
18:43:11 <ddarius> Also uniqueFuncsConsecutive doesn't read as a verb
18:43:31 <ndm> dons, the algorithm is 8 lines long, i don't want the name to be longer
18:43:51 <ddarius> renameUnique
18:44:11 <dibblego> f
18:44:12 <ddarius> renameFuncsUniquely
18:44:23 <ddarius> rename'
18:44:27 <dons> f
18:44:49 <ndm> uniqueFuncsRename i guess will do
18:45:55 <cdsmith> Is unique really all that meaningful? Is there a worry that the function might rename things non-uniquely?
18:46:11 <ndm> the other functions in that module start with uniqueFuncs :)
18:46:16 <cdsmith> Ah, okay.
18:46:19 <ndm> and its in the module UniqueName
18:46:23 <aheller> dons: built fine, but Eval still seems to be in pain: Plugin `eval' failed with: IRCRaised Data.ByteString.last: empty ByteString
18:46:26 <ddarius> So they're all poorly named.
18:46:35 <dons> aheller: update your text-regex install
18:46:43 <dons> it needs the latest regex (i should update the .cabal file)
18:46:45 <sm> normalizeNames
18:46:46 <ndm> the idea is to put all the uniqueness stuff on function names into one place
18:46:54 <dons> alphaConvert
18:46:56 <aheller> ah, I see.  thanks for the handholding.
18:47:01 <dons> no worries.
18:47:46 <aheller> which of the regeces do I want from hackage?
18:49:43 <sorear> ndm: finished reading - thanks, I understand
18:50:16 <Saizan> aheller: lambdabot.cabal should list the package name in build-depends
18:50:18 <sorear> ndm: I'm going to have to look at PlateTypable - I suspect it can be done using TTypeable with all the efficiacy of PlateDirect
18:50:44 * sorear will need to implement options in shc with names like -fallow-incomprehensible-instances
18:50:46 <ndm> sorear, TTypeable is GHC only - which is why i didn't explore very far down that route
18:50:57 <sorear> ndm: really?
18:51:08 <sorear> ndm: *T*Typeable
18:51:24 <aheller> Saizan: Right, thanks
18:51:55 <ndm> sorear, yes, all Oleg type class hackery from the last few years is GHC only
18:52:03 <ndm> Typeable is Hugs as well
18:52:12 <ndm> sorear, even still, I'd love to have PlateTTypeable
18:53:01 <SamB> that sounds like how piglet pronounces Typeable
18:53:13 <SamB> ... because he's scared of type hackery ;-)
18:53:52 <Saizan> what the first T stands for?
18:54:09 <SamB> Terrifying?
18:54:13 <SamB> Terrific?
18:54:36 <sorear> Type-level
18:54:36 <Saizan> Tarrasque?
18:55:10 <ndm> i do agree though that it should have similar performance to PlateDirect
18:55:13 <sorear> ndm: do you have any references for the subtleties in question?  I'd like shc to be oleg-compatible
18:55:15 <SamB> ... how the heck do you need typeable at the type level?
18:55:36 <SamB> don't types already *have* themselves?
18:55:44 <ndm> sorear, Hugs doesn't have corecursive dictionaries, and is broken - things like reordering the list of instances can change its behaviour - just too many little bugs
18:55:45 <Saizan> i think it's implemented at the type level, rather
18:56:21 <SamB> ... doesn't asTypeOf already do that?
18:58:00 <ndm> SamB, its confusing, but its a dynamic test of typeness (i.e. cast) that is resolved at compile time
18:58:06 <SamB> is there a shorter way to do this:
18:58:15 <SamB> $( liftM concat $ mapM (derive makeUniplate)    [''Line, ''Term, ''MacroDef] )
18:58:15 <SamB> $( liftM concat $ mapM (derive makePlateDirect) [''Line, ''Term, ''MacroDef] )
18:58:55 <ndm> not yet, but if you add derives [makeUniplate, makePlateDirectr] ["Line","Term","MacroDef"]
18:59:16 <ndm> and implement derives in Data.Derive, I'll happily accept a patch
18:59:31 <ndm> does PlateDirect work in Data.Derive?
18:59:49 <SamB> ... apparantly not, actually
18:59:59 <SamB> but my question is independant of whether it actually works ;-)
19:00:35 <ndm> the solution would be to implement something that readily allows the cross product to be done
19:00:43 <SamB> yeah...
19:00:47 <ndm> but if you're using GHC, why not just import PlateData ?
19:01:00 <ndm> thats what I do when i'm feeling lazy
19:01:07 <sorear> ndm: what should I do with my Play checkout?
19:01:20 <ndm> sorear, delete it - Uniplate is the new name for Play
19:01:39 <SamB> ndm: can't he pull from the uniplate repo?
19:02:24 <ndm> sorear - you can do as sorear says, and just pull from uniplate instead
19:02:27 <SamB> so... what is the point of Data.Derive.PlateDirect?
19:02:33 <SamB> heh
19:02:44 <SamB> as *sorear* says?
19:02:44 <ndm> SamB, to work when i've got the time to implement it, and have resolved a few TH issues
19:03:12 <ndm> i made sorear into a coinductive dictionary
19:03:33 <aheller> hm, more fun.  Given "> 1", lb gives me "Ix{Int}.index: Index (1024) out of range ((0,26))"
19:03:49 <SamB> ndm: and, well, would you use qualified names in your TH code if TH would follow reexports?
19:04:14 <ndm> SamB, no idea, i just did what was easiest
19:04:24 * SamB tries to think about that
19:04:53 <SamB> I suppose you would want them to come out the way you put them in...
19:05:11 <ndm> TH first qualifies everything, which means you get GHC.Base.[]
19:05:53 <SamB> it would be nice if it would qualify it with the kosher name
19:06:30 <SamB> the problem, I suppose, is that TH isn't designed to output useful Haskell code ;-)
19:06:43 <ndm> indeed
19:06:57 <SamB> I should report a bug to that effect
19:07:50 <ndm> go for it, if we can do better, we would
19:10:47 <Saizan> ?ty let derives ds ts -> Prelude.sequence [?derive d t| d <- ds, t <- ts] in derives -- Q is still a monad
19:10:51 <lambdabot> parse error on input `->'
19:11:09 <Saizan> ?ty let derives ds ts = Prelude.sequence [?derive d t| d <- ds, t <- ts] in derives
19:11:12 <lambdabot> forall t t1 (m :: * -> *) a. (?derive::t -> t1 -> m a, Monad m) => [t] -> [t1] -> m [a]
19:11:42 <SamB> what's a good title for a "feature request" ticket...
19:12:05 <SamB> Template Haskell: proper support for non-splicing applications?
19:15:57 <dons> SamB: 'add support for ...'
19:16:04 <dons> 'add' makes clear its a feature request
19:17:55 <dylan> hmm.
19:18:22 <SamB> what should we get for 'True, instead of GHC.Base.True?
19:18:31 <SamB> Prelude.True?
19:18:48 <ndm> probably, yes
19:21:12 <SamB> how would GHC know what the canonical name of a thing ought to be?
19:21:33 <SamB> does haddock know?
19:22:11 <ndm> leave that to the person fixing that bug ;)
19:25:10 <sorear> ndm: How does the performance of combinatory PlateDirect code compare to specialized explicit instances?
19:25:56 <ndm> sorear, you mean written without the Uniplate library, or written with a Uniplate instance crafted by hand?
19:26:02 <sorear> latter
19:26:13 <ndm> see Table 1
19:26:22 <ndm> Direct vs Manual
19:26:35 <ndm> pretty much the same, since for Manual you can
19:26:48 <ndm> 't write continuation passing stuff, withut your head exploding
19:28:19 <sorear> I was just thinking, what if we had a special purpose optimizer (that could do CPS stuff)
19:28:30 <sorear> would that be able to improve performance.
19:28:34 <ndm> yes
19:29:01 <ndm> i think Supero may get the performance of PlateDirect down to better performance than the hand-optimised transformations
19:29:19 <ndm> since it can remove repeated ++ by doing crazy things
19:29:26 <sorear> than the hand-optimized transformations with Supero?
19:29:37 <ndm> they should be equivalent
19:29:56 <ndm> after Supero they should both produce the same code
19:30:17 <sorear> how stable is supero - is it still like jhc, pattern match failing on 95% of stuff you throw at it?
19:30:35 <ndm> sorear, do you prefer non-termination or pattern-match errors?
19:30:58 <ndm> its not ready for real use, but its a really small code base, and i know what needs to be done - not more than a months work
19:31:11 <sorear> ndm: Hehehe.  I'll take pattern match errors, but I'd rather !_|_
19:31:49 <ndm> me too, but Supero isn't years off, and it is pretty simple compared to Jhc
19:35:09 <SamB> okay, this isn't the best feature request ever, but there is a reason I'm not calling it a proposal ;-)
19:35:59 <sorear> ndm: It'll be interesting to see how supero does on programs like GHC that consist mostly of composed (possibly generic) traversals.
19:36:22 <ndm> sorear, does GHC actually use a generics library?
19:36:59 <sorear> ndm: not afaik, but yhc.core counts as a "program like GHC" :)
19:37:29 <ndm> sorear, one day...
19:37:31 * sorear icks at ndm's handcoded boilerplate tuple instances
19:37:36 <ndm> it now has a lambda lifter
19:37:53 <ndm> which ones? in Yhc.Core?
19:37:57 <ndm> they aren't that yuk
19:37:59 <sorear> in PlateTypeable
19:38:06 <sorear> I just wish tuples were inductive :(
19:38:30 <ndm> they are exactly like Read/Show/Eq/Ord for preludes
19:38:37 <sorear> ndm: they're as yuck as every other tuple instance family
19:38:40 <ndm> apart from i stopped at 5, rathern than 20
19:38:42 <ndm> indeed
19:38:58 <ndm> i do wish tuples were defined as (a,b,c) == (a,(b,c))
19:39:33 <SamB> ndm: I tend to agree.
19:39:40 <SamB> well, I've never looked into it.
19:40:01 <SamB> but I'm positive that I'd want either that or (a,b,c) == ((a,b),c)
19:40:17 <ndm> you want the first
19:40:28 <sorear> (a,b,c) == (a,(b,(c,()))) anyone?
19:40:31 <ndm> has anyone yet proposed this for H'
19:40:50 <sorear> ndm: I don't think anyone reads the h' list
19:40:51 <ndm> or sorears, but i'm not sure which - i'm not sure the () is necessary
19:41:09 <ndm> its hardly got any traffic, i'm on it
19:41:27 <sorear> yeah, but that just makes it more obvious that nobody replies
19:41:28 <sjanssen> sorear: there was a discussion about it towards the beginning IIRC
19:41:54 <SamB> @type uncurry . uncurry
19:41:57 <lambdabot> forall b c a b1. (a -> b1 -> b -> c) -> ((a, b1), b) -> c
19:42:07 <SamB> ooooh
19:42:09 <sjanssen> is Haskell' more busy behind the scenes, or is it seriously stalled?
19:42:09 <SamB> look, see!$
19:42:21 <SamB> it oughta be ((a,b),c)
19:42:29 <ndm> its a bit too lazy, and no one is evaluating it
19:42:39 <sorear> sjanssen: due for November
19:42:49 <ndm> seriously?
19:42:52 <sorear> 06
19:42:56 <sjanssen> :)
19:42:58 <ndm> it was due for 2006 when i last looked
19:43:00 <ndm> ah :)
19:43:06 <ndm> yes, its dead as a doornail
19:44:13 <sjanssen> oh well
19:44:31 <sjanssen> if it's stalled for another year, associated types might be a serious possibility
19:44:45 <ndm> would need longer than that
19:44:53 <ndm> they still aren't in any useable compiler
19:45:11 <sjanssen> we should see ghc 6.8 by that time
19:45:29 <ndm> just in one compiler as an experiment /= standards material
19:45:38 <sjanssen> true
19:45:43 <SamB> yeah.
19:46:03 <SamB> someone has to figure out how to do it in hugs!
19:46:06 <sjanssen> but if MPTCs and the like aren't in it, what will be?
19:46:19 <SamB> I rather hope MPTCs are in it
19:46:24 <ndm> MPTCs and TDs will probably be in
19:46:33 <sjanssen> MPTCs are useless without fundeps
19:46:38 <sjanssen> fundeps suck.
19:46:39 <SamB> now that ndm has shown that they are useful even *without* fundeps
19:46:53 <sjanssen> sure, on rare occasions
19:46:57 <SamB> yes.
19:47:06 <SamB> but they seem pretty simple to me...
19:47:25 <ndm> i would have been more likely to use FD's if i understood them
19:47:36 <ndm> anyway, sleep time now - the birds are already waking up
19:47:39 <ndm> bye!
19:47:41 <SamB> ndm: I don't see how they would even be useful
19:50:32 <sjanssen> SamB: how fundeps would be useful?
19:51:32 <SamB> sjanssen: yes.
19:51:41 <SamB> in this instance, I mean.
19:51:43 <sorear> SamB: it simplifies the compiler
19:52:02 <SamB> sorear: how would they be useful in biplate?
19:52:13 <ddarius> I'm happy H' is stalled.  I would not want a new Haskell standard without MPTC and fundeps or something equally (or more) as powerful.
19:52:19 <sorear> pure MPTC can handle collections fine, if you allow the compiler to do general resolution
19:52:55 <dons> yeah, it would be good to get ghc 6.8 out, convert mtl to associated types
19:52:57 <sorear> ddarius: as a prolog expert - is that statement valid?
19:52:59 <SamB> ddarius: ... that is probably why it is stalled
19:53:06 <SamB> dons: yeah.
19:53:07 <dons> (fundeps are already coded in terms of associted types in ghc head now)
19:53:08 <SamB> that's fun.
19:53:12 <dons> and then see if we need fundeps at all
19:53:14 <SamB> should I send in the work I did?
19:53:16 <sorear> is ddarius on the h' committee?
19:53:22 <ddarius> SomB: I believe it is.
19:53:44 <dons> no one understands FDs. that's the problem
19:53:58 <ddarius> sorear: I guess if it always came out to a single instance you could.
19:54:07 <SamB> yeah...
19:54:34 <sorear> dons: aside from the obvious effect on context reduction, what do they do?
19:54:47 <dons> prolog
19:54:56 <sorear> dons: I'd like SHC to be oleg-compatible...
19:55:03 <ddarius> sorear: No, re H'.
19:55:03 <SamB> SHC?
19:55:21 <sorear> SamB: Sorear
19:55:22 <ddarius> H' started when I was away from the Haskell community.
19:55:34 <ddarius> hbc got the best nam.
19:55:34 <sorear> 's Haskell Compiler project...
19:55:39 <ddarius> s/nam/name.
19:55:45 <sorear> yeah :)
19:58:13 <SamB> ... why are these things trying to define the wrong method on uniplate???
19:58:17 <SamB> er.
19:58:20 <SamB> Uniplate.
20:07:34 <SamB> sorear: I don't understand how what "guess" guesses for PlateTypeable is based on the example...
20:07:35 <timthelion> does haskell have any of the char-byte duality one can take so much advantage of in c? I tried ['a' .. 22] and that didn't work. is there some kind of cast I need to use?
20:07:54 <sorear> fromEnum  / toEnum
20:08:00 <sorear> > fromEnum 48 :: Char
20:08:01 <lambdabot>  Couldn't match expected type `Char' against inferred type `Int'
20:08:05 <sorear> > toEnum 48 :: Char
20:08:07 <lambdabot>  '0'
20:08:07 <SamB> it seems to refer to several functions not mentioned in the example, as well as defining some methods that are not in the example...
20:08:53 <sorear> what's $A500?
20:08:58 <sorear> just bought one for $A500 .. at that kind of price there's
20:09:03 <sorear> on ML
20:09:24 <sorear> hmm.  should've gone to -blah :(
20:09:41 <sorear> @slap me
20:09:41 * lambdabot slaps sorear
20:10:41 <SamB> > 0xA500
20:10:42 <lambdabot>  42240
20:11:25 <timthelion> sorear: thankyou that is what I want
20:16:43 * SamB feels dirty using SYB just so he can use Biplate
20:17:08 <emu> scrub your dinnerplates
20:19:52 <SamB> wow.
20:20:06 <SamB> that's the craziest way to write id so far...
20:21:27 <SamB> universeBi :: Data.Generics.Data a => [a] -> [a]
20:22:24 <SamB> uses *two* boilerplate reduction libraries and who knows how many extensions!
20:24:27 <SamB> @hoogle (a -> Either b c) -> [a] -> [b] -> [c]
20:24:27 <lambdabot> No matches, try a more general search
20:24:35 <SamB> @hoogle (a -> Either b c) -> [a] -> ([b], [c])
20:24:35 <lambdabot> No matches, try a more general search
20:24:50 <SamB> @hoogle [Either a b] -> ([a], [b])
20:24:51 <lambdabot> No matches, try a more general search
20:25:06 <SamB> @hoogle partition
20:25:06 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
20:25:06 <lambdabot> Data.IntMap.partition :: (a -> Bool) -> IntMap a -> (IntMap a, IntMap a)
20:25:06 <lambdabot> Data.IntSet.partition :: (Int -> Bool) -> IntSet -> (IntSet, IntSet)
20:25:16 <SamB> nevermind...
20:25:22 <SamB> I'll just use list comprehensions...
20:26:07 <tessier> wah? Emacs 22 doesn't come with a haskell mode?!
20:26:21 <SamB> did emacs 21?
20:27:16 <tessier> I don't know. I thought it would have. But perhaps it didn't and still don't
20:29:24 <SamB> anyway, in Debian there is that "haskell-mode" package
20:31:36 * SamB wonders if you can do nasty things to <<Loop>>s to make them show where they come from
20:33:01 <sorear> SamB: +RTS -xc
20:36:06 <SamB> sorear: I haven't got any yet
20:36:19 <SamB> it's just that the way I'm seeing this assembler, I think it is going to happen
20:36:28 <SamB> anyway... not enough space for profiling libs...
20:36:53 <sorear> space!?
20:37:32 <SamB> yes. space.
20:38:13 <SamB> oh, huh.
20:38:20 <SamB> base comes with profiling libs now?
20:38:28 <SamB> oh, ait.
20:38:31 <SamB> er.
20:38:31 <SamB> wait.
20:38:41 <SamB> maybe I already installed the profiling version of base ;-).
20:39:29 <SamB> and the, er, other core libraries.
20:39:31 <SamB> like parsec.
20:39:58 <sorear> parsec is extalibs
20:40:20 <tessier> hmm...so haskell mode with emacs works and I can fire up an inferior shell and hugs gets the code.
20:40:30 <SamB> well than why does ghc6-prof provide libghc6-parsec-prof
20:40:36 <tessier> If I edit the code how do I make hugs get the new code? Do I have to kill the buffer and start a new inferior shell?
20:40:48 <SamB> :r
20:40:56 <sorear> C-c C-l
20:41:22 * SamB usually uses external shells
20:41:42 <SamB> (I run the compiler under emacs sometimes, but that's about it)
20:44:36 * SamB wonders how he can expand macros in this assembler, given that ., when appearing in a macro argument, refers to the first address in the macro's expansion...
20:44:41 <thedatabase> @seen tessier
20:44:42 <lambdabot> tessier is in #haskell. I last heard tessier speak 4m 6s ago.
20:44:53 <thedatabase> tessier: emacs 22 comes with haskell mode
20:45:14 <thedatabase> tessier: at least on aquamacs does...
20:45:20 <tessier> thedatabase: How does one invoke it? My emacs 22 didn't recognize M-x haskell-mode
20:45:55 <geezusfreeek> thedatabase: my aquamacs didn't come with it
20:46:10 <tessier> newsum (x:xs)    = 1 + x + newsum xs
20:46:20 <tessier> Why does this not add an extra 1 each time through?
20:46:46 <dolio> dons: Well, I think I'm at a wall. My bit twiddling code is taking most of the time (I think I'm boxing/allocating too much), and I'm not really sure how to optimize that sort of thing.
20:46:46 <tessier> sum [1,2,3] normally gives 6. I expect my modified version to give me 9.
20:46:50 <thedatabase> /Applications/Aquamacs Emacs.app/Contents/Resources/site-lisp/edit-modes/haskell-mode/inf-haskell.elc
20:47:03 <dons> dolio: great. you've done the hard part.
20:47:06 <ddarius> > let newsum = foldr (\x acc -> 1 + x + acc) 0 in newsum [1..10]
20:47:07 <lambdabot>  65
20:47:11 <dons> dolio: so you get the same md5 output asthe C program?
20:47:17 <ddarius> > let newsum = foldr (\x acc -> 1 + x + acc) 0 in newsum [1..3]
20:47:19 <lambdabot>  9
20:47:21 <thedatabase> Applications/Aquamacs
20:47:21 <thedatabase>      Emacs.app/Contents/Resources/site-lisp/edit-modes/haskell-mode/inf-haskell.elc
20:47:27 <dolio> dons: I get the same output as md5sum on the few things I've tried.
20:47:31 <thedatabase> sorry bout the formatting...
20:47:44 <dolio> dons: I based my code on the wikipedia description of the algorithm, because that C code is heinous.
20:47:50 <tessier> ddarius: man....I guess I have to read further on in this book before I can even make trivial changes. :(
20:47:53 <dons> dolio: cool. same complexity, i hope?
20:48:07 <ddarius> tessier: Your code should work, modulo needing a base case.
20:48:08 <SamB> ... wasn't there already haskell md5 code?
20:48:30 <dons> SamB: not low level stuff though.
20:48:55 <dons> dolio: do you want to post it somewhere/
20:49:05 <dolio> Sure. Where do you suggest? Just paste it?
20:49:14 <dons> how long is it?
20:49:22 <dolio> 123 lines.
20:49:44 <dons> ok. paste away
20:50:12 <dolio> dons: As far as I can tell, the main difference between the wikipedia algorithm and the C is that the C has all sorts of stuff unrolled, inlined and pre-computed.
20:50:19 <dons> ok. cool.
20:50:29 <tessier> ddarius: What do you mean by "a base case"?
20:51:02 <hpaste>  dolio pasted "md5" at http://hpaste.org/347
20:51:04 <ddarius> tessier: Eventually it needs to stop recursing, since you are recursing over a list (structurally) what do you do when you hit the end of the list?
20:51:28 <tessier> ddarius: Oh, I didn't paste all of the code. Yes, it does have a base case. newsum [] = 0
20:51:54 <tessier> ddarius: But my code does not seem to be working. It may be that I am not getting it reloaded into hugs or something because it gives the same result as sum
20:51:56 <dons> dolio: ok, i'll have a look now
20:52:01 <ddarius> tessier: I figured.  Your code should work.
20:52:22 <ddarius> > let newsum [] = 0; newsum (x:xs) = 1 + x + xs in newsum [1,2,3]
20:52:24 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
20:52:24 <lambdabot>       Expected...
20:52:31 <ddarius> > let newsum [] = 0; newsum (x:xs) = 1 + x + newsum xs in newsum [1,2,3]
20:52:33 <lambdabot>  9
20:52:42 <Figs> hello
20:52:51 <sorear> hi.
20:53:29 <Figs> could someone please explain to me, a lowly C++ programmer, what exactly a 'monad' is? I don't really get it, and I'm not too familiar with haskell, but I don't know where else to go
20:53:31 <dons> dolio: you got to some effort to copy around the strict chunks?
20:53:37 <tessier> ddarius: Ah, it does work. I had to kill the inferior shell. c-c c-l wasn't sending the new code to the interpreter like I thought it was.
20:53:44 <tessier> lambdabot: monad?
20:53:45 <dons> ?wiki Monad
20:53:46 <lambdabot> http://www.haskell.org/haskellwiki/Monad
20:53:52 <tessier> ?monad
20:53:52 <lambdabot> Unknown command, try @list
20:53:55 <tessier> hmm
20:53:58 <tessier> ?quote monad
20:53:58 <lambdabot> dcoutts says: monad transformers are not known for their blistering speed
20:54:06 <tessier> ?quote tessier
20:54:06 <dcoutts> true
20:54:06 <lambdabot> tessier says: After the last newbies head exploded trying to read everything on that monad link there was a lot of paperwork. We'd like to avoid doing that again.
20:54:21 <tessier> I kill me
20:54:26 <dcoutts> it'd be a fun project, to look into what needs to be done to make mtl really fast
20:54:29 <dons> Figs: its an abstraction over evaluation order, under one interpretation. meaning you can reprogram your ';' (semicolon), to behave like an imperative, sequential language, or a prolog-like language, or all sorts of other computational strategies.
20:54:33 <ddarius> Figs: Exactly what context are you encountering monads in that's not Haskell?
20:54:36 <dcoutts> probably it's mostly representation changes
20:55:01 <tessier> ddarius: architecture? category theory? lots of other places...
20:55:04 <ddarius> dcoutts: Yes, add continuations to Haskell.
20:55:20 <dcoutts> ddarius: we can do them already
20:55:22 <ddarius> tessier: I know, but...
20:55:29 <dcoutts> in the appropriate monad
20:55:31 <ddarius> dcoutts: I mean to the implementation.
20:55:47 <dcoutts> ddarius: I don't think that's the slowness
20:56:02 <dcoutts> it's just that the representations use too many nested lifted things
20:56:09 <dcoutts> which could be unpacked
20:56:11 <Figs> ddarius: general language design information
20:56:23 <ddarius> Perhaps not, but, e.g. Maybe is constantly rechecking whether you or not the computation has failed which it only needs to do when it matters.
20:56:34 <Figs> they're talked about everywhere, but I haven't seen many examples except in haskell
20:56:39 <ddarius> I guess using a Cont monad would be acceptable, but it would need to be well optimized by the compiler.
20:56:48 <ddarius> Figs: Okay.
20:57:04 <dcoutts> ddarius: it's not quite that bad, adjacent non-failing computations do not need to check, and similarly with the cont monad
20:57:10 <ddarius> Denotational semantics is how they weaseled their way into programming.
20:57:16 <dons> Figs, unfortunately, most older languages aren't expressive enough to provide useful, simple support for monads. though if you check that wiki page you'll find examples in a dozen or so languages
20:57:20 <dcoutts> ddarius: you know the Binary serialisation monad is based on continuations and is very very fast
20:57:29 <Figs> Yeah, I'm looking at the C++ example
20:57:35 <Figs> it looks overly complex
20:57:40 <dons> Figs: its a bit like contiuations (a specific monad). not a lot of languages are rich enough to support continuations.
20:57:41 <dcoutts> ddarius: you only need to build the continuation or check the Maybe when you don't statically know much about the code
20:57:48 <dons> Figs: yes, the C++ implementation is horrible
20:57:51 <dcoutts> like calling some non-inlined function
20:57:55 <dons> given its 3 lines of haskell to define the same thing.
20:57:56 <dolio> dons: I figured the sort of thing you did with the number reading example might work well for this as well, although I just did that straight away.
20:58:01 <ddarius> dcoutts: -If- CPS is well optimized by GHC, which is not unlikely as GHC was supposed to do higher order functions well, then that is fine.
20:58:08 <dons> dolio: ok.
20:58:11 <Figs> is there an example with, say, boost::function?
20:58:20 <dylan> people that keep $HOME in darcs:
20:58:27 <dons> hmm, i really don't know if C++ is going to be the best place to work out how monads  work.
20:58:29 <ddarius> dcoutts: You should only need to do the checks when you actually -perform- some effect.
20:58:39 <dons> its not expressive enough to use them very easily.
20:58:39 <dylan> what do you do about files that might contain sensitive data? (addressbooks or even passwords?)
20:58:47 <dcoutts> ddarius: I've spent some time looking at the core output from ghc for this kind of Cont monad stuff, it's really pretty excellent
20:58:56 <dolio> dons: What exactly is the chunk size?
20:58:59 <Figs> how about a general explaination?
20:59:00 <ddarius> dcoutts: Coolsville.
20:59:13 <ddarius> @google Moggi Notions of Computation
20:59:15 <dcoutts> the backend isn't quite as good sadly
20:59:15 <lambdabot> http://citeseer.ist.psu.edu/moggi89notions.html
20:59:15 <lambdabot> Title: Notions of Computation and Monads - Moggi (ResearchIndex)
20:59:30 <dons> dolio:
20:59:31 <dons> defaultChunkSize = 32 * k - overhead
20:59:31 <dons>    where k = 1024
20:59:31 <dons>          overhead = 2 * sizeOf (undefined :: Int)
20:59:51 <dons> Figs, general explanations are to be found on the Monad wikipage, and in the haskell wikibook.
20:59:54 <dons> ?where wikibook
20:59:54 <lambdabot> http://en.wikibooks.org/wiki/Haskell
21:00:11 <dons> i gave a small, generic explanation earlier (the one about programmable semicolon)
21:00:22 <ddarius> I should benchmark the Maybe monad v. a continuations based version v. a Representing Monads version.
21:01:15 <Figs> anyway, what I was most interested in was the fact that I saw they were listed as another way of expressing effects in competition with 'effects systems'
21:01:19 <Figs> is that valid?
21:01:34 <ddarius> Not necessarily in competition, but yes.
21:01:41 <dons> Figs: yes, quite so.
21:01:41 <ddarius> @google Wadler Marriage of Effects and Monads
21:01:44 <lambdabot> http://citeseer.ist.psu.edu/536524.html
21:01:44 <lambdabot> Title: The Marriage of Effects and Monads - Wadler (ResearchIndex)
21:02:09 <dons> and that's one use for them in Haskell, in fact, for tagging, tracking and implementing specific effect systems.
21:03:25 <ddarius> Furthermore, monads can be related to modal logic which I'm pretty sure is related to effect systems.
21:03:27 <dons> Figs: you thinking of an application to some interesting effects you want to handle?
21:03:50 <dibblego> > foldl (+) 0 [1..]
21:03:56 <Figs> well, I'm working on a parser/compiler system... and I was doing research.
21:03:58 <lambdabot> Terminated
21:04:16 <dons> dibblego: try an Int constraint on 0
21:04:25 <dons> oh, sorry, that'd still not terminate ;)
21:04:26 <dibblego> > foldl (+) (0 :: Int) [1..]
21:04:33 <Figs> I was thinking of designing a method of marking 'rule' types to restrict the values of data and functions
21:04:33 <lambdabot> Terminated
21:04:34 * dons flashes back to earlier conversation.
21:04:41 <dibblego> dons, how does that change anything?
21:04:52 <SamB> well, I've managed to use uniplate to extract all of the "variables" from this macro1 program
21:04:52 <Figs> and I found 'effects systems' when I started looking for ideas on how to impliment it
21:05:05 <dons> Figs: hmm, interesting. have you seen ben lippmeijer (sp?) work on effects and inferring them from monadic programs?
21:05:12 <SamB> (an operation that the real macro1 assembler did during the first of two passes)
21:05:12 <Figs> no
21:05:20 <ddarius> dibblego: If you weren't trying to sum an infinite list and were getting a stack overflow, that would (probably) allow strictness analysis and avoid the stack overflow.
21:05:43 <dons> yes, Int cranks up the strictness just enough
21:05:47 <dibblego> ddarius, strictness analysis, meaning it would behave like foldl' ?
21:05:50 <dons> so that foldl turns into an unboxed loop
21:05:52 <dons> right
21:05:54 <ddarius> dons: Um, wouldn't that just be type checking.
21:06:01 <dibblego> the Int annotation still failed to terminate though?
21:06:11 <Figs> what I realized was that an effects system would almost certainly be locked into the error system, possibly as one of the primary forms of error handling
21:06:12 <ddarius> dibblego: You are summing an infinite list.
21:06:30 <dons> ddarius: inferring where the monads are, in code freely intermixing pure and impure code. :-)
21:06:30 <dibblego> oh right, duh
21:06:30 <ddarius> dibblego: If you implement lazy numbers and use foldr it will work.
21:06:31 <dibblego> > foldl (+) (0 :: Int) [1..100000000]
21:06:36 <lambdabot> Terminated
21:07:01 <ddarius> dons: Okay, you said it the other way (or that's how I read what you said).
21:07:05 <dons> Figs: see the phd topic of Ben Lippmeier, Australian National University,
21:07:28 <Figs> I'll see if I can find it
21:07:30 <dons> but there's a lot of work on this stuff
21:07:55 <ddarius> Where are effect systems?  They seem like a good or at least reasonable idea, but you don't see them.
21:08:15 <dons> you see them in formal verfication of stuff like C though.
21:08:19 <SamB_XP> ddarius: I think they are very hard to understand
21:08:30 <SamB_XP> ... you see, they involve effects ;-)
21:08:41 <dons> side effects are hard :-)
21:09:19 <Figs> well, it's like
21:09:24 <Figs> I have a variable 'x'
21:09:27 <Figs> it's an integer
21:09:33 <Figs> x!=0
21:09:38 <Figs> otherwise the rule fails
21:10:20 <dons> you doing research for a phd or something, Figs? can you explain the background to your work a bit ?
21:10:33 <Figs> no phd, I'm just a highschool student
21:10:42 <dons> heh. good to see you're starting early :-)
21:10:43 <Figs> well, freshman next year
21:10:54 <dons> good good.
21:11:08 * SamB_XP prints out the uniplate paper -- hopefully
21:11:12 <ddarius> Figs: Freshman highschool student?
21:11:20 <Figs> no, freshman college (undergrad)
21:11:21 <dons> there's some papers on monads, and effects, here,
21:11:23 <dons> http://haskell.org/haskellwiki/Research_papers/Monads_and_arrows#Monads
21:11:24 <ddarius> Darn
21:11:26 <lambdabot> Title: Research papers/Monads and arrows - HaskellWiki, http://tinyurl.com/fgd83
21:11:43 <dons> Figs, also, this list contains the most popular /cited monad papers, http://haskell.org/haskellwiki/Research_papers/Top_10
21:11:44 <lambdabot> Title: Research papers/Top 10 - HaskellWiki
21:11:48 <Figs> I just graduated from HS about a month ago
21:11:55 <ddarius> Why wasn't Haskell more popular when I was (earlier) in high school?
21:11:56 <sorear> Figs: Aww.  I was hoping I'd hear of a haskeller younger than me...
21:12:07 <ddarius> sorear: Me too.
21:12:23 <ddarius> What was the name of that other kid?
21:12:32 <Figs> Well, I don't know haskell at all... so...
21:12:36 <Figs> I'm doing this all in C++
21:12:42 <dons> scary.
21:12:45 <jfredett> He's younger than me... :) <- 20 in 1 month and change. :)
21:12:45 <dons> C++ is a lot of work.
21:12:49 <jfredett> C++! AAH!
21:12:51 * jfredett hides
21:12:59 <Figs> I just finished writing an enhanced regex library
21:13:00 <dons> you might be able to prototype the concepts in haskell first, then translate it laboriously into C++
21:13:01 <sorear> jfredett: So am I.
21:13:05 <jfredett> protect me, lambdabot!
21:13:09 <ddarius> C++ was my language of choice until just after high school when I found Haskell.
21:13:12 <dons> Figs, cool. using the newer regex algos?
21:13:18 <ddarius> Or maybe just near the end of high school.
21:13:19 <lambdabot> You are damn well on your own.
21:13:35 <Figs> no, the regex stuff is written basically from scratch
21:13:49 <jfredett> lambdabot? he- speaks?
21:13:49 <ddarius> Figs: "enhanced" in what way?
21:13:58 <lambdabot> That's "she".
21:14:00 <ddarius> lambdabot is a bot of many skills.
21:14:04 * jfredett pokes lambda
21:14:08 <Figs> well, I can have expressions refer to each other in a BNF-like format
21:14:12 <Figs> let me get an example
21:14:14 <jfredett> sorry- lambda, mea culpa
21:14:39 <Figs> http://rafb.net/p/tSGMmf40.html
21:14:41 <lambdabot> Title: Nopaste - command line regex calculator
21:14:56 <ddarius> Figs: Are they even still regular expressions (not like Perl's are, but hey)
21:15:10 <Figs> it's more like grammars
21:15:15 <dons> dolio, there's a lot of appending and packing going on.
21:15:22 <Pseudonym> Ow, and I thought Spirit was painful.
21:15:33 <dons> i'd have probably gone directly for md5 :: S.ByteString -> String
21:15:33 <Figs> I basically rewrote spirit
21:15:35 <Pseudonym> Very cool hack, though.
21:15:42 <dolio> dons: Yeah, I know. That unpackW32A function is pretty bad, I think.
21:15:44 <Figs> since I thought it was messy
21:15:52 <Figs> it's not as good as xpressive
21:16:02 <Figs> but it's pretty clean, I think
21:16:10 <Figs> look at 62-72
21:16:21 <dons> dolio, is the core of it the 'chunk' function?
21:16:29 <Figs> and line 172
21:16:38 <dolio> dons: If you move 'op' up to the top level, though, it takes about 80% of the time/allocation.
21:16:47 <Figs> it defines legal mathematical expressions
21:16:50 <dolio> dons: Yeah, chunk is the core.
21:17:04 <Pseudonym> Yeah, it's very pretty.
21:17:07 <Figs> the code lets me deal with order of operations and parenthesis correctly
21:17:20 <Pseudonym> Figs: Are you doing POSIX-style enhanced regexes or actual regular expressions?
21:17:23 <dons> unpackW32A :: S.ByteString -> UArray Int Word32
21:17:33 <dons> is going to kill any chance of chasing c.
21:17:43 * Figs doesn't know what POSIX-style enhanced regex means
21:17:53 <dons> dolio: isn't that just a type cast/
21:17:55 <Pseudonym> Regular expressions are compilable to DFAs.
21:17:57 <Figs> the real difference is that they can refer to each other or themselves recursively
21:18:00 <Pseudonym> Regexes aren't.
21:18:04 <Pseudonym> Ah, recursive?
21:18:11 <Pseudonym> Then... how do you parse them?
21:18:11 <Figs> yeah look at 172 for example
21:18:29 <Pseudonym> Like Spirit?
21:18:30 <Figs> at this point, I just check for matches
21:18:33 <dolio> dons: You'd be better qualified to answer that than me. :)
21:18:34 <jfredett> well thats interesting
21:18:45 <Figs> match_result foo = expression.match(input);
21:18:48 <jfredett> my algorithm for finding amicable numbers is _too_ good
21:18:55 <jfredett> it finds amicable and perfect numbers
21:19:02 <Figs> that will check if 'input' contains a legal mathematical expression
21:19:05 <dons> dolio, its not processing the data, afaik, its just grouping the bytes into groups of 4 or something?
21:19:11 <jfredett> I dont think thats ever happened to me before... :/
21:19:25 <Figs> (3*(4+5)-6)*7 for example, would be legal
21:19:25 <dolio> dons: Right. If a typecast works, it's all in the right order to begin with.
21:20:25 <Figs> '|' means 'or', '>>' means 'followed by', '+' means 1 or more, '*' means 0 or more, opt() is an optional term, and range() should be obvious
21:21:11 <Pseudonym> Figs: So you're doing LL(1) parsing?
21:21:29 <Pseudonym> Or something else?
21:21:35 <dons> dolio, in which case, i'd avoid copying all together, and just leave it as a bytestring
21:21:39 <Figs> I haven't quite pegged which form of parsing it's at
21:21:58 <Figs> since it's a bit odd
21:22:20 <Figs> the downside to early homebrew
21:22:33 <dolio> dons: I need arithmetic on Word32 elsewhere, though. Unless you think working that out for ByteString would make it faster.
21:22:49 <ddarius> Figs: I have a different question.  Why did you write it?
21:22:51 <Pseudonym> Can you briefly describe it, or would that take too long?
21:23:07 <Figs> (I've never taken a real class on programming or computer science, unless you count things like logo...)
21:23:14 <dons> dolio, yeah, i think copying data here is unlikely to be what the C versions do.
21:23:17 <ddarius> Figs: What's wrong with Logo?
21:23:26 <dons> and we've got to basically implement the C version directly
21:23:28 <Pseudonym> Most Logos are limited.
21:23:44 <Figs> usually you're limited to just describing graphics
21:24:18 <Figs> which can be interesting, and does teach some basic concepts, but you usually don't get into serious depth in those classes
21:24:20 <ddarius> True, though from what I hear it's supposed to be a fairly sophisticated language.
21:24:36 <Pseudonym> Yeah.  PostScript actually relies a lot on Logo.
21:24:41 <Pseudonym> Its array data structure model.
21:24:49 <Pseudonym> Logo is actualy a mix of Forth and Lisp-lite.
21:24:54 <dolio> dons: The C does something similar. It loops through the input shifting and oring.
21:24:56 <Figs> we never really had all that much with it back then
21:24:57 <Pseudonym> Plus the turtle graphics, of course.
21:25:12 <Figs> just drawing shapes and things
21:25:13 <dolio> dons: But that might be faster in C than what I've got there.
21:26:40 <Figs> anyway, the reason I wrote it is that I was getting a bit fed-up with C++, I was interested in how the heck people come up with languages, had enough experience with C++ that I could get somewhere by experimenting... etc.
21:26:58 <ddarius> Figs: Learn Haskell or some language nicer than C++
21:27:09 <ddarius> (And I still like C++ quite a bit)
21:27:10 <Figs> I like C++'s syntax for a lot of things, which is what's put me off learning something like lisp
21:27:23 <Pseudonym> Learning Haskell will make your C++ better.
21:27:27 <Pseudonym> I've certainly found that.
21:27:47 <ddarius> I was already starting to head in a Haskelly direction with my C++.
21:27:52 <Figs> I don't know, I think a lot of stuff that's done in C++ is over-complicated
21:28:16 <Figs> learning haskell would probably help me see different things
21:28:19 * jfredett watches as Figs hits the nail on the proverbial head
21:28:22 <ddarius> Figs: Very likely, but there's a lot of accidental complexity due to the language.
21:28:26 <Figs> don't know if I have enough time though
21:28:27 <Pseudonym> I think that the main problem in C++ is its backwards compatibility with C.  Unfortunately, that's also one of its great strengths.
21:28:27 <ddarius> Figs: It will.
21:28:31 <dolio> dons: Lines 120 - 124 in the C. It's updating in place, though, not going ByteString -> [Word32] -> UArray like the haskell.
21:28:36 <Pseudonym> It's an odd mix of very high-level and very low-level.
21:28:54 <ddarius> Yes.  C++ is very nice, as long as you avoid all the C parts.
21:28:56 <Pseudonym> And unfortunately, it wastes perfectly good syntax on low-level stuff that could be used to express high-level stuff succinctly.
21:29:28 <Pseudonym> So yes, concentrating on high-level hacking for a while will help a LOT.
21:29:38 <Figs> I figured the two biggest things to get rid of are templates (replace with a better system), and multiple number types (replace with a 'rational' number type and restriction system)
21:30:10 <ddarius> Haskell has the former, blech on the latter.
21:30:23 <Figs> why blech on the latter?
21:30:55 <ddarius> It wouldn't work.  The various number types don't match up that well.
21:31:04 <jfredett> sadly.
21:31:10 <aspo> silly newb type question
21:31:33 <Figs> uh, what's wrong with a typical math system like you learn in 1st - 6th grade?
21:31:34 <aspo> Ints don't seem to autobox into Integers
21:31:44 <aspo> Prelude> let a = 4::Integer
21:31:44 <aspo> Prelude> let b = 4::Int
21:31:44 <aspo> Prelude> a * b
21:31:53 <aspo> doesn't work
21:32:00 <ddarius> Figs: It's not implementable on a computer and what is can be very inefficient.
21:32:10 <aspo> I can't figure out how to force b into an Integer
21:32:10 <ddarius> aspo: Indeed.
21:32:15 <ddarius> :t (*)
21:32:17 <lambdabot> forall a. (Num a) => a -> a -> a
21:32:18 <Figs> (1) already implimented it, (2) yes it is inefficient, but that can be improved
21:32:34 <Figs> a simplified version
21:32:42 <Figs> but enough to test the idea
21:32:44 <ddarius> Figs: What "restrictions" do you support?
21:32:50 <Figs> not that part
21:33:04 <Figs> the other part
21:33:10 <ddarius> Implementing rationals is easy, though they do have inherent inefficiency problems.
21:33:24 <aspo> well I don't really have a and b
21:33:32 <Figs> I think I was misunderstanding you, sorry
21:33:34 <aspo> I have results of funcitons, one that returned an Int, another a Integer
21:33:45 <ddarius> fromIntegral
21:33:49 <aspo> ahh
21:34:01 <ddarius> Haskell has no implicit conversions
21:34:12 <Figs> well, one way is just an implicit check whenever a variable is likely to go out of bounds
21:34:25 <dons> ddarius: 'cept from polymorphic to monomorphic literals :-0
21:34:29 <ddarius> Figs: Variables never go out of bounds for rationals.
21:34:39 <Figs> with a rules system, they do
21:34:41 <aspo> thanks
21:34:48 <SamB_XP> dons: those aren't conversions...
21:34:55 <Figs> if x!=0 is a prerequisite to a function
21:34:55 <SamB_XP> those are optimizations ;-)
21:35:18 <Figs> then that should bloody well be checked first
21:35:30 <ddarius> Figs: What the heck are you talking about now?
21:35:35 <Figs> restrictions on variables
21:35:51 <ddarius> Oh, it's even worse than I thought.
21:35:55 <Figs> for example, say you have a div() function that takes 2 params 'a' and 'b'
21:36:00 <Figs> and returns a/b
21:36:14 <Figs> b!=0 would be a prerequisite
21:36:15 <jfredett> :t div
21:36:17 <lambdabot> forall a. (Integral a) => a -> a -> a
21:36:22 <jfredett> we do. :)
21:37:13 <ddarius> Figs: What you seem to want to do is a lot harder than you may think.
21:37:25 <Figs> I realize some of the problems with it
21:37:55 <Figs> for example, depending on how it's used and implimented, it could be horribly inefficient
21:38:22 <ddarius> Simply sticking to rationals is going to very inefficient on some occasions.
21:38:39 <Figs> that's why you can optomize under the covers
21:38:58 <Figs> for example, you don't need a huge structure store *most* data
21:39:05 <Figs> usually you can get away with 4 bytes
21:39:38 <ddarius> Optimize to what? when?
21:39:39 <Figs> but, there are a lot of cases, (enough to justify, I think), where it'd be convenient not to require the limitation
21:40:08 <Figs> suppose you have 5*10 being computed
21:40:26 <Figs> we can already do this pretty well with normal 4 byte processor arithmetic, right?
21:41:00 <Figs> both values fit into registers, and produce a result that doesn't overflow
21:41:46 <Figs> the overhead you need to *check* is 2 bytes and a couple of cmp/jmp instructions
21:42:03 <Figs> 1 byte to indicate what type of data you are dealing with
21:42:11 <Figs> for each piece of data
21:42:27 * ddarius is reminded of a very recent Haskell mailing list thread.
21:43:24 <Figs> (unless, of course, you're dealing with a large value, such as the number 234123890123491234.32, in which case, it *will* be slower to check because you have to calculate it out in software rather than relying on simple hardware math)
21:44:00 <ddarius> http://www.haskell.org/pipermail/haskell-cafe/2007-June/027160.html
21:44:02 <lambdabot> Title: [Haskell-cafe] Re: Perl-style numeric type, http://tinyurl.com/2ctoy6
21:46:06 <Figs> haa :p
21:46:37 <Figs> well, does what I'm talking about make any sense?
21:46:51 * Figs just wants to make sure he hasn't lost the entire audience...
21:47:03 <dons> :-)
21:47:15 <ddarius> Figs: Yes.  It's just, in my opinion, 1) a bad idea, and 2) impossible to efficiently implement.
21:47:25 * bos despairs of docbook processing toolchains
21:47:38 <bos> my kingdom for latex!
21:47:49 * ddarius has never dealt with docbook.
21:47:54 <Figs> we'll see :)
21:47:55 <ddarius> From all I hear, I take that as a good thing.
21:48:00 <bos> yes, it is.
21:48:15 <ddarius> Figs: As we've seen before.  Go history.
21:48:55 <Figs> it's possible that it's impossible, but I won't give up the idea until I've at least tested it
21:49:14 <Figs> or gotten to the point where I can see why it really is impossible and that there aren't any other ways around the problem.
21:49:29 <dons> hehe, http://programming.reddit.com/info/1zym1/comments/c201wm?context=5
21:49:32 <lambdabot> Title: The Lisp experience - 19-year old college student asks for help in #lisp, has to ..., http://tinyurl.com/2fblh8
21:49:37 <ddarius> Figs: Have fun.
21:50:17 <dibblego> now we'll have people joining #haskell, so they can say that they rule
21:50:37 <dons> hey, we rule!
21:50:49 <dons> and we'll answer questions about category theory
21:50:52 <dons> or monads in C++
21:50:58 <Figs> ;)
21:51:12 <Figs> going back to that... I still don't think I really get it
21:51:12 <ddarius> Figs: You are not the first person to ask about monads in C++
21:51:25 <dons> yeah, I don't get C++ either :-)
21:51:35 <Figs> which part?
21:51:37 <Figs> :P
21:51:49 <dons> the bits between main and exit.
21:52:51 <dibblego> ?where yaht
21:52:51 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
21:52:59 <dons> i once implemented PRE in C++. urgh, iterators are no substitute for pattern matching and recursive descent traverals
21:53:11 <dibblego> ?where cofp
21:53:12 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
21:53:25 <bos> my day job is all c++. don't get me started.
21:53:26 <ddarius> Well the bits are just numbers in the field Z/2, or categorically they can be viewed as pushouts in from the 0 object to the terminal object...
21:54:13 <Figs> division would be a lot harder to do in the system I was describing... you might have to do that one the long way every time
21:54:39 <Figs> but addition, subtraction, and multiplication will work fine, I think
21:55:03 <Figs> PRE?
21:55:19 * Figs guess 'pattern recognition'?
21:55:43 <dons> partial redundancy elimination, a compiler optimisation
21:55:49 <Figs> oh
21:55:53 <Figs> *really bad guess*
21:56:06 <dons> ;-0
21:56:10 <dons> grr.
21:56:11 <dons> :-)
21:56:18 <dons> silly shift keys
21:56:23 <Figs> sorry, I'll try to be more clairvoyant next time :-P
21:56:29 <Pseudonym> Really, pattern matching is the one thing I miss in traditional languages.
21:56:42 <Pseudonym> So much so that I'm often tempted to write a pattern matching preprocessor.  I've done a couple.
21:56:52 <Pseudonym> Visitors don't quite cut it.
21:57:23 <ddarius> Bugger fields and them being finite sum theories.
21:57:36 <Pseudonym> What's wrong with fields?
21:57:44 <dibblego> dons, is there a website or mail list for announcements on your book?
21:57:52 <dons> yeah, the web site
21:57:58 <dons> ?go real world haskell
21:57:59 <ddarius> Pseudonym: They are left exact theories.
21:58:01 <lambdabot> http://www.realworldhaskell.org/
21:58:01 <lambdabot> Title: Real World Haskell
21:58:04 <ddarius> s/are/aren't
21:58:06 <dibblego> thanks
21:58:12 <Pseudonym> Have you sorted through all of the offers for review?
21:58:25 <dons> not yet.
21:58:28 <Pseudonym> Slacker.
21:58:35 <dons> :P
21:58:46 <Pseudonym> I don't mean you necessarily.
21:58:52 <Pseudonym> Your co-authors are also clearly to blame.
21:58:59 <dons> true. all a bunch of slackers.
21:59:02 <Pseudonym> Yeah.
21:59:23 <dons> lazy FP does that to one.
21:59:40 <dons> i'm sure they'll be sorted when someone demands it be done.
21:59:42 <Pseudonym> When there's no demanded output, no work gets done.
21:59:49 <dons> zactly.
21:59:58 <dibblego> ?hoogle zactly
21:59:58 <lambdabot> No matches found
22:00:02 <dibblego> just checkin :)
22:00:06 <Pseudonym> ?google zactly
22:00:08 <lambdabot> http://www.urbandictionary.com/define.php?term=Zactly+Breath
22:00:08 <lambdabot> Title: Urban Dictionary: Zactly Breath
22:00:15 <Pseudonym> @yow
22:00:15 <lambdabot> I'm dressing up in an ill-fitting IVY-LEAGUE SUIT!!  Too late...
22:00:28 <dons> ok. interesting.
22:00:30 <dibblego> @let zactly = (==)
22:00:30 <lambdabot> <local>:20:9:     Ambiguous type variable `a' in the constraint:       `Eq a'...
22:02:26 <Figs> is it just me, or does C have very clean syntax?
22:02:30 <Figs> (for most things)
22:02:36 <Figs> *typical
22:02:39 <jfredett> its just you.
22:02:42 <Pseudonym> Yeah.
22:02:44 <Pseudonym> Just you.
22:02:54 <dons> good bit twiddling syntax
22:02:57 <Figs> maybe I've just done too much crap with templates...
22:03:00 <Pseudonym> It has a highly optimised syntax for writing Unix and old C compilers.
22:03:11 <Pseudonym> That's not "most things".
22:03:22 <dons> good syntax for mutable memory
22:03:37 <siti> yep, it beats haskell when writing low level code :P
22:03:38 <jfredett> templates are uglier than normal C, IMO
22:03:46 <Pseudonym> But you know, if I was designing C++ from scratch, memory blocks would have a different syntax.
22:04:05 <Pseudonym> They'd be built into the language, but they'd look like templated classes.
22:04:18 <Pseudonym> Instead of int* foo, you'd write std::raw_pointer<int> foo.
22:04:20 <Pseudonym> For example.
22:04:26 <Pseudonym> So "*" could be used for something useful.
22:04:45 <dons> siti: let (:=) = poke
22:04:59 <Pseudonym> foo.set(2)
22:05:02 <Pseudonym> Or something.
22:05:22 <Figs> would you really?
22:05:24 <jfredett> hmm- I wonder if there exists a pair of amicable number within a pair of amicable numbers, that is:
22:05:26 <Pseudonym> Yup.
22:05:27 <jfredett> a < b < c < d, were a,d are an amicable pair, and b,c are an amicable pair (amicable pair being defined as the sum of all divisors of x equal y and vice versa.
22:05:41 <Figs> I've always thought of int* as being a type directly
22:05:44 <Pseudonym> jfredett: Only one way to find out.
22:05:53 <jfredett> proof? :)
22:05:58 <jfredett> i dont think there could be
22:05:59 <Pseudonym> Figs: I've always thought of reinterpret_cast<Foo>(x) as a function.
22:06:00 <Figs> I'd get tired of std::raw_pointer ...
22:06:12 <Pseudonym> So I guess we're even.
22:06:18 <SamB> uniplate is really really sweet
22:06:19 <Figs> hehehe
22:06:30 <jfredett> I should write it up.
22:06:32 <SamB> especially biplate ;-)
22:06:33 <Figs> I don't think I've ever needed a reinterpret cast
22:07:14 <Pseudonym> static_cast then
22:08:00 <Pseudonym> Maybe std::raw_pointer is too verbose.
22:08:08 <Pseudonym> Maybe just: ptr<int> foo;
22:08:17 <Figs> that's not too bad
22:08:18 <SamB> is reinterpret_cast for when you really *must* interpret that double as a uint64_t?
22:08:31 <jcreigh> and when things get really tough, you can always bring out the excessively_verbose_yet_strangely_vague_cast<>
22:08:43 <SamB> jcreigh: heh
22:08:54 <SamB> jcreigh: I've never heard of that one
22:09:03 <Pseudonym> SamB: It's more for casting odd pointers, or dealing with multiple inheritance crap, or stuff like that.
22:09:05 <jcreigh> SamB: it's a little known corner of the C++ spec. :)
22:09:06 <Figs> reinterpret_cast is for when you need to play with dark magical byte magic
22:09:10 <Pseudonym> Yeah.
22:09:29 <Pseudonym> Most of the time, static_cast<> gives you what you need.
22:09:34 <jfredett> jake damnit! its too slow!
22:09:50 <Pseudonym> Or on rare occasions, dynamic_cast<>.
22:10:07 <Pseudonym> And const_cast<> is only useful for binding to archaic C libraries which don't respect const correctness.
22:10:15 <jfredett> jake damn son of a one minute rule stupid...
22:10:24 <ddarius> Yay const correctness
22:10:24 * jfredett mumbles expletives about project euler
22:10:51 <Figs> ooh, const correctness is good... hard to learn, but usually good once you've got it
22:10:53 <SamB> Pseudonym: I have yet to have a clue how multiple inheritance is even possible in C++
22:11:05 <ddarius> SamB:?
22:11:08 <Pseudonym> SamB: The short answer is "it almost isn't".
22:11:34 <SamB> Pseudonym: if I didn't know otherwise I would swear that it couldn't be
22:11:34 <Figs> basically, a child has multiple pointers
22:11:57 <Figs> *pointer types
22:12:33 <Figs> multiple inheritance in C++ is meant more like multiple inheritance in java
22:12:35 <SamB> I realize that there must be different offsets into the object that could be pointed to depending on the type of pointer...
22:12:36 <Pseudonym> SamB: Basically, multiple inheritance is why you need static_cast and dynamic_cast.
22:12:42 <Figs> except they don't call it that in java ;)
22:13:03 <SamB> but what about diamonds?
22:13:08 <Figs> you have two options:
22:13:11 <Pseudonym> But the key thing is that multiple inheritance mostly doesn't work in objects without vtables.
22:13:18 <Pseudonym> Thankfully, most objects do.
22:13:21 <jfredett> there is no multiple inheritence in java
22:13:23 <SamB> oh ???
22:13:26 <jfredett> there are interfaces
22:13:28 <SamB> you need a vtable?
22:13:31 <Pseudonym> Yeah.
22:13:32 <Figs> either you get the objects inherited twice (one in each hierarchy), or you define the inheritance as virtual (one object for all instances)
22:13:49 <jfredett> which is pretty different than multiple inheritence. ayup
22:13:50 <Pseudonym> There's a hidden entry in the vtable which gives you the "base pointer" of the object as a whole.
22:14:01 <Figs> jfredett: that _is_ multiple inheritance
22:14:01 <SamB> Figs: why do I get the feeling that this comes back and bites you in the ass
22:14:10 <SamB> Figs: not really...
22:14:17 <Pseudonym> However.  Fact is, most of the time that you use multiple inheritance, you at least have a dynamic destructor.
22:14:18 <jfredett> interfaces ~= crippled typeclasses
22:14:20 <Figs> yes, that's why there is =0 in C++
22:14:34 <jfredett> multiple inheritence != interfaces
22:14:49 <Pseudonym> So that gives you your vtable.
22:14:51 <jfredett> they accomplish the same goal
22:15:02 <Figs> it's basically the same thing, you just can't carry implimentation with interfaces
22:15:09 <Figs> afaik
22:15:14 <jfredett> but thats like saying C is equivalent to Haskell,
22:15:15 <jfredett> because you can program computers with them.
22:15:18 <Figs> no
22:15:35 <Figs> the real reason for MI in C++ is so you can combine multiple libraries
22:15:45 <jfredett> what do you mean by "carry implementation" btw
22:15:51 <Pseudonym> There's only one time I've ever needed true multiple inheritance, and it turned out that I actually needed virtual inheritance.
22:15:55 <Figs> I mean, foo { /*does something*/}
22:16:03 <Figs> is defined in the parent
22:16:06 <jfredett> you can combine libs in Java too.
22:16:17 <dibblego> type-classes > inheritance
22:16:24 <jfredett> well- you shouldn't do that-- its about separation of concerns there-
22:16:32 <jfredett> dibblego: i agree
22:16:39 <Figs> what I'm talking about is ABC's
22:16:44 <Figs> (abstract base classes)
22:16:52 <Pseudonym> Which is what Java calls "interfaces".
22:16:54 <jfredett> you can do that in Java
22:16:59 <Figs> where all methods in the class are virtual
22:17:06 <Figs> and abstract
22:17:06 <jfredett> no- there are abstract classes in java
22:17:17 <dibblego> you can't have multiple abstract classes in Java
22:17:26 <dibblego> you cna have multiple interfaces though
22:17:30 <jfredett> right- and you generally shouldn't
22:17:34 <dibblego> the former is an illegitimate use case anyway
22:17:36 <dibblego> right
22:17:44 <Figs> multiple interfaces is the point
22:17:50 <dibblego> you can't shoot yourself in the head with the safety-catch on either
22:17:58 <dibblego> and this a *good* thing
22:18:10 <Figs> you have an interface which shows the relationship to X and one which shows you to Y
22:18:27 <dibblego> the only reason you combine interfaces is when there is an additional constraint not specified by the type system
22:18:30 <Figs> and you inherit from those interfaces (_called_ ABC's in C++)
22:18:47 <SamB> eek.
22:18:47 <dibblego> interface Sequence<T>{ int length(); T get(int index); } // is a good example
22:19:01 <Figs> what language are we in now?
22:19:10 <dibblego> Java/C++ same thing, different retardedness
22:19:15 <jfredett> that looks like java to me
22:19:21 <jfredett> dibblego: ditto
22:19:22 * SamB doesn't like universeBi :: Data a => a -> [String]
22:19:25 <Figs> I'm not familiar with <T> in java
22:19:32 * jfredett <3 Haskell.
22:19:35 <Figs> could be there, but I haven't done much with java
22:19:47 <Pseudonym> One more thing.  Modern C++(tm) thinking is that implementation inheritance in C++ is usually unnecessary.
22:19:53 <dibblego> it's there, I used to work on the implementation (sadly)
22:19:53 <Figs> yes
22:19:59 <dibblego> it's from JSR-14
22:20:02 <Pseudonym> And is better expressed as delegation.
22:20:19 <ddarius> Yay! Down with implementation inheritance.
22:20:27 <Figs> implementation inheritance _is_ useful
22:20:32 <SamB> Pseudonym: I assume that there may be some cases where it is considered a good idea?
22:20:32 <Figs> it's just abused
22:20:42 <dibblego> no, it is illegitimate across all possible use cases
22:20:45 <Pseudonym> Figs: It is, but it's usually not necessary.
22:20:51 <jfredett> Hasah! my solution to PE problem 21 ran in 59 seconds. just under the wire, (in ghci, no less)
22:20:56 <Pseudonym> SamB: Probably.
22:21:01 <dibblego> why are we arguing silly crap in #haskell anyway?
22:21:04 <ddarius> The trick, though, is how to present it in a way where it's very difficult to abuse.
22:21:13 <SamB> like... when you really did just want to reimplement a virtual method?
22:21:14 <jfredett> good question, dibblego
22:21:20 <Pseudonym> Yeah, that's what #haskell-blah is for.
22:21:23 <dibblego> this feels like a blub discussion
22:21:44 <jfredett> maybe its because we've discussed all other possible pointless topics
22:21:51 * Figs isn't a regular here, so I guess the fault is with me... we were talking about monads at some point...
22:21:53 <jfredett> and so now we're fishing for semipointless ones
22:22:02 <jfredett> no worrys, Figs
22:22:08 <Pseudonym> Actually, the point about implementation inheritance is a bit important for Haskell.
22:22:13 <dibblego> implementation inheritance can't make sense, because inheritance doesn't make sense, finished
22:22:22 <jfredett> QED!
22:22:25 <Pseudonym> Because it suggests that it's actually not a necessary feature in the Haskell class system.
22:22:40 <Pseudonym> HList or no HList.
22:23:05 <sorear> Figs: nobody starts out as a regular!
22:23:05 <Figs> does haskell have a way of easily wrapping classes?
22:23:09 <sorear> wrapping?
22:23:13 <dibblego> newtype
22:23:18 <dibblego> if only Java/C++ has that!
22:23:24 <Figs> facade, wrapper, etc
22:23:31 <dibblego> Figs, yes, it is one line of code usually
22:23:35 * Pseudonym nods
22:23:39 <dibblego> newtype T = T U
22:23:44 <Figs> meaning?
22:23:50 <dibblego> T wraps U
22:23:57 <Figs> how do you modify T?
22:24:04 <Pseudonym> Figs: It's a type synonym, but it's compiler-checked.
22:24:05 <dibblego> instance C T where
22:24:14 <dibblego> or 'deriving'
22:24:17 <Figs> so, effectively a typedef?
22:24:23 <Pseudonym> Yeah, but compiler-checked.
22:24:28 <Pseudonym> newtype Id = Id Int
22:24:28 <jfredett> btw, they're not typically called classes, but rather datatypes, theres a name collision with type classes
22:24:29 <dibblego> compiler-enforced typedef
22:24:37 <Pseudonym> That's as efficient as an Int, but you can't add an Id to an Int.
22:24:40 <sorear> Figs: haskell isn't really an OO languuage, incased you hadn't noticed :)
22:24:51 <Pseudonym> You need to unpack it if you want to do that.
22:24:55 <Figs> I figured it was a functional language :P
22:24:58 <Pseudonym> increment (Id x) = Id (x+1)
22:25:01 <jfredett> Objects are just poor mens closures, anyway
22:25:12 <ddarius> Closures are just poor mens objects, anyway
22:25:13 <dibblego> Pseudonym, I thought the compiler was clever enough to make any efficiency problems go away with newtype
22:25:15 <Pseudonym> No, objects are poor men's threads.
22:25:16 <Figs> but since I'm most familiar with C++, I try to relate things to that
22:25:27 <sorear> dibblego: Usually.
22:25:27 <jfredett> threads are for erlangers
22:25:31 <Pseudonym> dibblego: That's what I said.
22:25:33 <Pseudonym> I think.
22:25:43 <dibblego> Pseudonym, sorry, I imagined a 'not' in there
22:25:46 <Pseudonym> Ah.
22:26:01 <Figs> how do you change the adaptation?
22:26:08 <sorear> dibblego: In GHC <=6.6, newtype is treated as type after the type checker is finished, so there is no possibility of overhead
22:26:51 <Figs> nevermind
22:26:56 <dibblego> Figs, it would be best if you forgot everything you know about C++, this is the blunt truth
22:27:03 <Figs> not really,
22:27:08 <Figs> I've put too much time into it
22:27:09 <Pseudonym> Er... no.
22:27:12 <sorear> dibblego: in >=6.6.1 newtypes are unpacked using a special `cast` primitive, which doesn't generate code and is theoretically free, but the extra structure confuses the optimizer sometimes IME
22:27:17 <jfredett> well, maybe not forget
22:27:20 <ddarius> Figs: How much time have you put into it?
22:27:25 <Figs> about 5 years experience
22:27:29 <jfredett> C/C++, though horrible and ugly, is useful
22:27:42 <Figs> I guess I started in 7th grade
22:27:44 <dibblego> C/C++ only serves to taint the learning potential of a candidate
22:27:44 <Pseudonym> It would be best if you learn a new language every year (at least).
22:27:48 * sorear has 8 years of experience with ~20 programming languages
22:27:55 <jfredett> just partition your Biological hard drive to the C/C++ side
22:27:58 <jfredett> and the Haskell side
22:28:03 <jfredett> and don't let the two mix
22:28:04 <emu> sorear: since you were 8?
22:28:05 <Figs> Well, I'm basically an expert at GML
22:28:07 * Pseudonym has ~20 years experience with ~60 programming languages
22:28:08 <jfredett> ever.
22:28:10 <Figs> but *no one* knows that
22:28:21 <Figs> maybe ~10,000 people
22:28:27 <sorear> emu: yes
22:28:31 * dons as ~20 years experience with ~60 icecream flavours!
22:28:36 <Pseudonym> Woo!
22:28:38 <sorear> Figs: is GML a member of the SML family/
22:28:38 <emu> omg
22:28:39 <Pseudonym> Icecream!
22:28:42 <Figs> no.
22:28:45 <dons> icecream!
22:28:46 * jfredett has ~ 12 years experience with ~25 langs
22:28:48 <Pseudonym> Finally, an on-topic discussion!
22:28:53 <Figs> 'game maker language' :P
22:28:56 <dibblego> learn C++ after learning Haskell; watch horror films after puberty
22:28:59 <jfredett> but I'm only 20. :)
22:29:00 <emu> IceCreamT
22:29:07 <dons> mmm. tasty
22:29:13 <dibblego> otherwise, avoid C++ (and horror films)
22:29:18 <jfredett> hmm, thats the best Monad Transformer Ever!
22:29:19 <ddarius> And to think, I was 12 when I started programming.
22:29:21 * Pseudonym wonders if he could get an ice cream cocone.
22:29:24 <dons> IceCreamT (Topping,Nuts) (BrainFreeize a)
22:29:32 <Figs> I started programming in 4th or 5th grade
22:29:42 <Figs> I'm not sure exactly
22:30:14 <Figs> I was working with GM v3, I think, and they're up to v7 now..., so it's been a long time
22:30:18 <jfredett> Common Lisp since i was 8, hoorah. :)
22:30:24 <sorear> C :(
22:30:28 <ddarius> QBASIC
22:30:31 <emu> i did C around 10
22:30:32 <dons> jfredett: that explains so much :-)
22:30:39 <dolio> dons: Well, I wrote myself an unsafeIndex32 which seems to work well enough. But it's still at around 20x slower than C, due to the 'chunk' function sucking. :)
22:30:45 <jfredett> Figs: my little cousin plays with GM
22:30:49 <Pseudonym> jfredett officially has the least to unlearn of any of us.
22:30:51 <jfredett> Figs: he loves the stuff.
22:30:52 <Figs> oh, so you know it? :)
22:30:53 <emu> CL would've been a sight better
22:30:53 <dons> dolio: oh ok. we can probably work on that.
22:31:03 <jfredett> Pseudonym: Really?
22:31:12 <Pseudonym> Yeah.  Starting on Common Lisp that young.
22:31:15 <jfredett> well- I also made the mistake of learning VB6 at one point
22:31:26 <Pseudonym> But if you learned Lisp first...
22:31:27 <Figs> that's pretty neat, wish I'd learned CL around then
22:31:28 <jfredett> it kind of broke my brain for imperative languages
22:31:36 <jfredett> took me till college to break out of it
22:31:37 <jfredett> but yah
22:31:48 <jfredett> CL for 5 good years was the only lang I knew
22:31:52 <SamB> jfredett: I never learned too much VB5...
22:31:55 <Figs> well, the way I see it, you *always* get to the point of an imperitive language
22:32:07 <Figs> no matter what language you're in, eventually it devolves into statements
22:32:09 <jfredett> and for the record, Emacs sucks ass.
22:32:16 <Pseudonym> Figs: It does not.
22:32:19 <ddarius> Figs: Haskell has no statements.
22:32:23 <jfredett> Figs no.
22:32:26 <SamB> jfredett: I think that's one feature it lacks.
22:32:26 <ddarius> Well, I guess do notation...
22:32:28 <emu> emacs sucks, it just sucks less than everything else mostly
22:32:28 <Pseudonym> SQL has no statements.
22:32:35 <ddarius> Prolog has no statements.
22:32:46 <Pseudonym> Well, Prolog kinda does, actually.
22:32:49 <jfredett> Lisp _can_ have no statements
22:32:50 <SamB> ddarius: what do you call those things where you say
22:32:51 <sorear> Unlambda has even less that could be called statements.
22:32:51 <Pseudonym> Mercury doesn't, though.
22:33:02 <SamB> loves(you, your_mother)
22:33:10 <ddarius> Pseudonym: It -kinda- does.
22:33:11 <jfredett> oedipus!
22:33:12 <dons> yeah, you only get statements if you end up in an imperative style
22:33:19 <Pseudonym> assert() is a statement.
22:33:21 <ddarius> SamB: clauses, rules, predicates
22:33:29 <jfredett> SamB: I don't doubt that its a wonderful editor
22:33:29 <SamB> ddarius: they ought to be statements ;-)
22:33:31 <Pseudonym> So are Prolog'
22:33:33 <dons> Figs: so an awful lot of haskell programs don't ever have statements.
22:33:36 <Pseudonym> s I/O predicates.
22:33:38 <jfredett> SamB: but ELisp makes me sad inside
22:33:49 <SamB> jfredett: oh, true
22:33:51 <jfredett> Yi looks interesting though-
22:33:53 <SamB> and it's really a horrible editor
22:34:01 <Figs> SQL doesn't really count since it's not turing complete. (at least, it wasn't the last time I looked at it)
22:34:04 <ddarius> jfredett: ELisp should make everyone sad inside.
22:34:04 <jfredett> so, more accurately, ELisp sucks ass
22:34:16 <SamB> because it is so broken sometimes
22:34:17 <jfredett> I dont use Emacs, so I won't judge
22:34:25 <jfredett> I use cat | sed, like a man.
22:34:34 <sorear> BURN HIM!!
22:34:35 <ddarius> Figs: So?  And at any rate making it Turing complete would not require adding statements.
22:34:44 <SamB> I thought ed was what real men used
22:34:48 <sorear> Unlambda is turing complete.
22:34:51 <ddarius> sorear: Who? Why?
22:34:52 <dons> jfredett: real men use sed < foo
22:35:00 <Pseudonym> I use cat - > a.out.gz like a REAL programmer.
22:35:05 <sorear> ddarius: jfredett, for useless use of cat
22:35:20 <jfredett> I kid, of course
22:35:22 <jfredett> I use vi
22:35:27 <SamB> heh
22:35:31 <emu> i put files together using cat alone
22:35:31 <SamB> sorear: hahahaha
22:35:32 <Figs> if haskell doesn't have statements, then how do you get anything done?
22:35:35 <jfredett> typically in a style similar to that of a human
22:35:39 <dons> i just use mkfifo and sed.
22:35:42 <jfredett> rather than say, a monkey
22:35:47 <sorear> I've HAND-ASSEMBLED code and TYPED IT IN USING HEX EDITORS!
22:35:48 <jfredett> or a llama
22:35:49 <SamB> Figs: well, he lied
22:35:50 <dons> Figs: the entire program is an expression that reduces.
22:35:51 <SamB> it has them
22:35:53 <emu> concatenative programming!
22:35:55 <ddarius> sorear: Hasn't everybody?
22:36:02 <SamB> but you have to put them inside do expressions
22:36:02 <dons> main = interact (unlines . map toUpper . lines)
22:36:04 <jfredett> sorear: uhm, your point?
22:36:07 <SamB> and you don't *need* them
22:36:13 <Figs> then it's more or less one BIG statement?
22:36:13 <sorear> hm, not sure.
22:36:29 <dons> Figs, you could view the entire haskell program as a single 'statement' yes.
22:36:29 <Figs> sorear: I have too
22:36:33 <Figs> it's sad.
22:36:34 <ddarius> It's one big declaration.  Or rather a declaration with one "big" expression.
22:36:40 <dons> since statements are just expressions with implicit state threading
22:37:01 <SamB> what about, say, [path] <- getArgs
22:37:05 <SamB> is that an expression?
22:37:11 <sorear> no, that's a stmt
22:37:16 <SamB> haha
22:37:18 <dons> getArgs >>= \[path] -> rest of program
22:37:26 <ddarius> SamB: No, but it's also very light sugar over something that is not a statement.
22:37:28 <SamB> and I suppose MPTC stands for Multi Param Type Classes?
22:37:31 <sorear> I suppose it could be a qual
22:37:35 <Pseudonym> [path] <- getArgs is a binding
22:37:40 <Pseudonym> Yeah, or a qual.
22:37:43 <dons> stmts are sugar for a particular expression form.
22:37:45 <Figs> prolog has at least one statement in a program
22:37:50 <Figs> (a goal)
22:37:58 <SamB> dons: they still exist in the grammar
22:38:03 <Figs> the rest could be seen as structuring
22:38:04 <dons> figs, what is a statement though?
22:38:15 <jfredett> damnit dons, you beat me to it.
22:38:19 <SamB> despite sorear's claiming that stmt is totally different from statement
22:38:21 <Figs> a statement is anything that directs the computer to perform an action
22:38:21 <Pseudonym> No, a goal isn't really a statement.
22:38:31 <dons> Figs, hmm. isn't 1+2 a statement then?
22:38:32 <Figs> (typically at run time)
22:39:07 <Figs> a declaration isn't really a statement, because nothing happens (it just defines relations and structure) unless you're performing an assignment action
22:39:11 * SamB reformats Figs' hard drive at compile time
22:39:12 <ddarius> Everything in a source file directs the computer to perform an action.
22:39:13 <Figs> the difference is like:
22:39:18 <Figs> int foo;
22:39:25 <Figs> would be something I'd consider a declaration
22:39:30 <Figs> int foo = x+1;
22:39:37 <jfredett> well then, in a language like haskell, which is delcarative, everything is a delcaration
22:39:38 <Figs> would be an action (assignment)
22:39:40 <dons> sure. but the relevant issue is the difference between statements and expressions.
22:39:48 <sorear> x = 2
22:39:54 <sorear> is a function definition
22:39:57 <Pseudonym> In Haskell, "statement" is really only a concept that exists in the grammar.
22:40:02 <Pseudonym> It's not part of the semantics.
22:40:02 <jfredett> therefore -- there are no statements in haskell. non?
22:40:11 <Figs> in prolog, most of the statement is implied
22:40:18 <dolio> I always though 'statements' were syntactic elements that, in a sense, don't return a value. Defined in distinction to expressions.
22:40:27 <Pseudonym> Prolog is a tricky case because it's highly impure.
22:40:28 <Figs> I'm being quirky
22:40:32 <dolio> So, Ruby, for instance, doesn't have statements. It only has expressions.
22:40:38 * sorear can't believe how pointless this has become
22:40:56 <shachaf> dolio: Are comments statements? :-)
22:40:59 <Figs> maybe I should use a different term...
22:41:00 <Figs> an action
22:41:07 <jfredett> whats an action?
22:41:15 <Figs> every program must have one action, or it doesn't _do_ anything
22:41:16 <jfredett> or more to the point, and action on what?
22:41:25 <dolio> Comments are invisible. :)
22:41:35 <Figs> it's a directive to the computer to _Do_ something
22:41:36 <shachaf> Figs: Exactly.
22:41:44 <dons> Figs, isn't that a statement?
22:41:46 <shachaf> Figs: Every Haskell program has exactly one action.
22:41:46 <jfredett> so what is the directive acting on?
22:41:53 <Figs> I'm changing the term to be more clear
22:42:11 <Figs> shachar: I'm seeing that, thanks
22:42:15 <sorear> Figs: Haskell can be seen as having statements, sure.  But we don't like to think at that low of a level
22:42:15 <Figs> :)
22:42:24 <jfredett> but it still begs the question- what is the action acting on? the answer is the state of the machine.
22:42:36 <ddarius> Figs: Obviously Haskell programs do stuff, so what is your question?
22:42:48 <Figs> I'm mostly thinking aloud
22:43:09 <sorear> > let{ fib = 0 : 1 : zipWith (+) fib (tail fib) } in fib
22:43:16 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:43:28 <sorear> the whole thing is a statement which creates a fib thunk.
22:43:47 <sorear> 0 : ...  is a statement which creates a (:) with 0 as the car and a thunk as the cdr.
22:43:52 <sorear> ...
22:44:23 <Pseudonym> > fix ((0 :) . (1 :) . ap (zipWith (+)) tail)
22:44:25 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
22:44:27 <Figs> I think I sort of get that
22:44:38 <ddarius> And 0 is the statement which loads 0 into a register or memory location or something at some time.
22:45:03 <sorear> > fix ((1:) . scanl (+) 0)
22:45:05 <Figs> is every program in Haskell essentially a one-liner?
22:45:06 <lambdabot>  [1,0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
22:45:20 <sorear> Figs: no, lambdabot is 30k lines or so :)
22:45:24 <Figs> (not counting readability punctuation)
22:45:32 <sorear> Figs: GHC is ~170k lines
22:45:32 <Figs> ok
22:45:40 <Figs> then how do you relate two lines?
22:45:40 <Pseudonym> Figs: If we converted it to pointless style, it might fit on one line.
22:45:42 <Pseudonym> A very long one.
22:45:49 <dons> Figs, one calls the other.
22:45:55 <Figs> please explain
22:46:12 <jfredett> even x = not (odd x-1)
22:46:15 <sorear> Figs: in C, consider: a = x + y ;
22:46:20 <jfredett> even 0 = true
22:46:34 <jfredett> odd x = (not (even x-1)
22:46:38 <jfredett> odd 1 = True
22:46:39 <dons> main = interact f
22:46:39 <dons> f    = lines . map g . unlines
22:46:40 <dons> g  x = toUpper x
22:46:40 <sorear> Figs: x is a statement that loads x; ... we have many statements even in a line of C
22:46:55 <Pseudonym> let { a = 0:b; b = 1:a } in a
22:46:57 <jfredett> those two functions will bounce off each other- forever
22:47:00 <Pseudonym> > let { a = 0:b; b = 1:a } in a
22:47:01 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
22:47:07 <ddarius> jfredett: Um, your clauses are out of order and the odd 1 case is unnecessary.
22:47:13 <dons> Pseudonym: nice, canonical example.
22:47:30 <jfredett> ddarius: thats why I keep that shit in a library
22:47:37 <Figs> effectively, though, you have a _sequence_ of things that happen, right?
22:47:48 <dons> not really, no.
22:47:49 <sorear> Figs: Yes.
22:47:51 <Pseudonym> dons: You're welcome to use it in the book.
22:47:53 <dons> sequences are for imperative languages.
22:48:09 <sorear> Figs: But it's best not to think about the sequencing.
22:48:10 <dons> the sequence is not determined though.
22:48:17 <ddarius> > fix ((0:) . (1:))
22:48:19 <lambdabot>  [0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1...
22:48:28 <Figs> sorear: but the whole *point* of my thought experiment is the sequencing :)
22:48:43 <dons> there's no fixed sequencing.
22:48:50 <jfredett> Figs: its not worth the trouble of trying to force imperitive language think into the functional world. It'll probably just confuse you more in the long run.
22:48:55 <Pseudonym> Figs: One good way to think about I/O in Haskell is the way it used to be implemented long ago.
22:48:58 <dons> so the language might runs things in any order, or in parallel
22:49:09 <Pseudonym> It actually returned a physical data structure which was like a "script".
22:49:12 <Pseudonym> In the theatre sense.
22:49:24 <Pseudonym> The run-time system just played the script.
22:49:47 <Figs> ok, that's sort of how I see prolog
22:49:53 <Pseudonym> And data got fed back, so the program could work out what kind of script to feed enxt.
22:49:55 <Figs> (though I'm not very experienced with it)
22:50:13 <Pseudonym> Lazy evaluation did the rest.
22:50:17 <shachaf> Pseudonym: That's not what it does today?
22:50:18 <ddarius> Figs: As far as IO is concerned, Prolog just had side-effects.
22:50:23 <Pseudonym> Right.  I/O in Prolog is, basically, not logical.
22:50:26 <Figs> nonono
22:50:29 <Pseudonym> shachaf: Not under the hood, no.
22:50:29 <Figs> not I/O in C++
22:50:30 <ddarius> shacaf: IO is abstract today.
22:50:31 <Figs> *prolog
22:50:39 <Figs> I mean in _general_
22:50:45 <Figs> you define a lot of structure
22:50:46 <shachaf> Pseudonym: I mean, from the user's point of view.
22:50:52 <Figs> relationships
22:50:56 <ddarius> shacaf: IO is abstract.
22:50:58 <Pseudonym> From the user's point of view, you can think of it that way.
22:50:59 <jfredett> the thing to realize about functional languages is this: if, at line 1, f(0) = 1, then at any other line, f(0) will equal 1
22:51:00 <Figs> and there is a goal that gets worked towards
22:51:01 <Pseudonym> But yeah, it's abstract.
22:51:10 <jfredett> which is not true of an imperative language
22:51:11 <Pseudonym> The script model is, IMO, a good one to understand what's going on.
22:51:18 <jfredett> or more generally, a language with state.
22:51:21 <ddarius> I agree with Pseudonym.
22:51:24 <ddarius> More or less.
22:51:32 <Pseudonym> But as an implementation strategy, it unfortunately doesn't scale.
22:51:43 <Pseudonym> Each new kind of IO primitive needs a new data constructor for the script.
22:51:56 <ddarius> Not really.
22:52:08 <Pseudonym> It did back in the day when IO was implemented this way. :-)
22:52:13 <Pseudonym> We didn't have existential types then.
22:52:18 <ddarius> We've had this discussion before though.
22:52:28 <ddarius> Pseudonym: You could just stuff a bunch of things in Strings
22:52:34 <Pseudonym> Ouch.
22:52:46 <Figs> you have to realize, I'm not asking this to try to think in Haskell as much to see how Haskell relates to other languages
22:52:58 <Figs> though I do appreciate the clarifications
22:53:06 <Figs> they help
22:53:07 <jfredett> i see
22:53:29 <ddarius> Figs: Haskell is pretty unique.  It is one of the few significant pure languages and one of essentially two significant pure functional languages.
22:53:49 <Figs> so, effectively, the bulk of haskell is declarative, correct?
22:53:54 <jfredett> you might want to mess around with scheme, if you want to learn a functional language- as (IMO) its a little less hardcore than Haskell. It has some ability to work with state.
22:53:55 <dons> imperative programming is just a special case in haskell, its a particular fixed evaluation order. haskell lets you pick others.
22:54:00 <dons> Figs, yes, its a declarative language
22:54:20 <ddarius> All of Haskell is declarative.
22:54:22 <Pseudonym> EVERYTHING in Haskell is declarative, apart from a few nits which let you escape to a lower level if you need a hack.
22:54:31 <Pseudonym> But you don't want to know about them.
22:54:43 <jfredett> We like our ivory towers hear @ #haskell... :)
22:54:47 <Figs> :P
22:54:54 <jfredett> s/hear/here
22:55:01 <Pseudonym> If you know about them too early, you might be encouraged to use them.
22:55:05 <Figs> personally, I think of the imperitive system to be implied
22:55:25 <ddarius> Why?  Why bother?
22:55:25 <Figs> and I can't spell... can I? :P *imperative
22:55:36 <Figs> because it's fundamental to the nature of a computer
22:55:39 <Korollary> We don't mind if you misspell imperative.
22:56:00 <ddarius> Perhaps, but not to computing.
22:56:04 <jfredett> frak, I misspell more words than G W Bush on mispronounces on most days.
22:56:04 <shachaf> Figs: Don't bring computers into this. :-)
22:56:09 <Figs> hehe :P
22:56:13 <Pseudonym> No more than files and directories are fundamental to the nature of a hard drive.
22:56:14 <dons> its not really fundammental though. think about multicore machines.
22:56:28 <Korollary> If you bring up computers, I'll bring up telescopes.
22:56:32 <Figs> remember, I'm working on a compiler system of sorts, so _I_ have to think at that level
22:56:34 <dons> or even a single cpu with speculation.
22:56:41 <sorear> ddarius: what's the other pure functional language
22:56:41 <Figs> even if the users of my language never do
22:56:46 <jfredett> Nothing is fundamental in a computer, except for the fact that things break.
22:56:51 <ddarius> sorear: Clean
22:56:55 <Pseudonym> Yeah, modern CPUs aren't as declarative as their ISAs alone would indicate.
22:56:57 <sorear> ddarius: Oh right.
22:57:06 <Pseudonym> Sorry, aren't as _imperative_.
22:57:13 <Figs> well, I'd like to see a computer that doesn't need to do any computation
22:57:15 <ddarius> I haven't seen any purely functional CPUs yet.
22:57:22 <jfredett> heh, I read _I_ as bottom, not an emphasized "I"
22:57:28 <dons> and things like GPUS are pretty much purely functional stream processors
22:57:29 <Pseudonym> Figs: Zen computing!
22:57:29 <ddarius> Figs: Computation doesn't require imperative programming.
22:57:40 <shachaf> jfredett: Yes. :-)
22:57:41 <Pseudonym> It doesn't need answers, it just is.
22:57:48 <sorear> Figs: I'd suggest reading the "Implementation of Functional Programming Languages" then.  It's long and dense, but well written and explains things well.
22:57:52 <dons> texture in, pixels out. map and fold only. no mutable state. yay for GPUs
22:57:57 <sorear> Figs: (PDF on web)
22:57:57 <Figs> do you have a link?
22:58:02 <Figs> I'd really like to read that
22:58:02 <ddarius> dons: You may have won there.
22:58:08 <sorear> @google slpj-book-1987
22:58:10 <lambdabot> http://www.haskell.org/pipermail/yhc/2007-March.txt
22:58:15 <ddarius> dons: Are they Turing complete though?
22:58:19 <jfredett> you know your a haskeller when: "You don't say, 'We'll just play that by ear', but rather 'We'll just lazily evaluate that'"
22:58:26 <dons> ddarius: pretty sure, yep.
22:58:27 <sorear> @go "Implementation of Functional Programming Languages"
22:58:29 <lambdabot> http://research.microsoft.com/~simonpj/papers/slpj-book-1987/index.htm
22:58:29 <lambdabot> Title: The Implementation of Functional Programming Languages
22:58:33 <sorear> that.
22:58:34 <Figs> dons: everything is impied there, the conversion to a screen format
22:58:37 <dons> though they're getting creeping imperative features (some new ones have pointers)
22:58:37 <Figs> *implied
22:59:18 <dons> so people do, for example, run parallel array processing algos on GPUs, given they might have 128 cores sitting in them, secretly churning away on their input buffer
22:59:49 <Figs> yes, but ultimately, they must do the processing
23:00:04 <dons> input to output. in some unspecified order.
23:00:12 <dons> that's not imperative. the order's not fixed in hardware.
23:00:12 <ddarius> Figs: Who are you responding to?
23:00:31 <Figs> dons
23:00:44 <ddarius> Figs: No is saying no computation, we're saying it doesn't require mutable state.
23:00:52 <ddarius> s/No/No one
23:01:09 <jfredett> Its interesting, Figs, you said you aim to differentiate FP and IP, yet you keep coming back to trying to make FP into IP.
23:01:30 <Figs> I don't think I ever said 'differentiate', I think I said 'compare'
23:01:36 <jfredett> okay
23:01:41 <jfredett> its just interesting
23:01:52 <Figs> It's just a product of the way I think
23:01:56 <jfredett> I would assume compare and differentiate go hand in hand.
23:02:13 <ddarius> Figs: And we're saying there's no reason to think that way.
23:02:14 <Pseudonym> Differentiable reals aren't comparable on Turing machines.
23:02:26 <dons> so yeah, while cpu ISAs provide an imperative abstraction, even that is a bit suspicious, with the compiler-level speculation and parallelisation hints. and other processors, like GPUs, are very non-imperative in nature.
23:02:32 <jfredett> ddarius: actually, I'm saying theres no reason to think, period.
23:02:36 <ddarius> Pseudonym: That's the reals fault, don't blame differentiation.
23:02:42 <Pseudonym> True.
23:03:01 <Figs> now, I don't consider parallelism to really block the imperative base
23:03:02 <dibblego> ?hoogle (a -> b) -> [a] -> [b]
23:03:02 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
23:03:03 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
23:03:03 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
23:03:10 <dibblego> why doesn't it give me fmap?
23:03:30 <ddarius> dibblego: It didn't get to it yet maybe?
23:03:30 <jfredett> Figs, what do you mean?
23:03:41 <Figs> ultimately, at that level, you're still at declaration
23:03:53 <Figs> remember, *if* we allow implimentation to be implied
23:03:57 <Figs> the actions, I mean
23:04:07 <Figs> there only needs to be one statement: run
23:04:21 <Figs> (this is just a thought experiment, remember)
23:04:33 <SamB> wow uniplate is nice compared to trying to model this PDP-1 assembler's operations with monadic code ;-)
23:04:43 <jfredett> I'm not sure I follow- are you saying that if you allow the implementation of the action to be implied (that is, solved by the compiler)
23:04:48 <dibblego> ?type msum
23:04:51 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
23:05:07 <jfredett> then the problem of paralellism is "solved"
23:05:24 <aspo> sorry, I'm jumping in here without reading back
23:05:24 <jfredett> because it sounds like your describing a declarative approach, in that case
23:05:27 <aspo> but do you even need a run?
23:05:34 <Figs> I'll brb in just a second
23:05:35 <jfredett> rather than an imperative approach
23:05:36 <dibblego> > msum [1..10]
23:05:37 <ddarius> aspo: No.
23:05:37 <lambdabot>   add an instance declaration for (Num (m a))
23:05:37 <lambdabot>     In the expression: 10
23:06:01 <SamB> I've already implemented macroexpansion and it only took me 75 lines -- sure maybe a little boilerplate, but it's a heck of a lot easier than the way I was trying it before...
23:06:07 <aspo> you could have a hard coded ic that acts on inputs, therei s no "run"
23:06:26 <ddarius> aspo: Exactly what I was thinking of.
23:07:01 <jfredett> Run, or Run not, there is no Run.
23:07:10 <jfredett> ooh, Zen-y
23:07:12 <jfredett> :)
23:07:16 <dons> run implies an initial machine?
23:07:22 <ddarius> Or you could have a nice optical computer.
23:07:23 <SamB> if there were a Run, we would have to Catch it...
23:07:26 <dons> its a runState code memory
23:07:50 <dons> which is just a non-run program, with code applied to memory.
23:08:07 <jfredett> bah- time for sleep
23:08:13 <ddarius> Indeed.
23:08:35 <jfredett> Figs: Have fun with FP, Learn Scheme! (then Haskell later.)
23:08:43 <dibblego> > msum [[1], [2]]
23:08:45 <lambdabot>  [1,2]
23:08:52 <dibblego> > msum [[1,2], [2,4]]
23:08:54 <lambdabot>  [1,2,2,4]
23:09:04 <jfredett> Erlangs good too, ayup.
23:09:10 <Figs> back
23:09:15 <aspo> I've seen plenty of no FP scheme
23:09:21 <aspo> non
23:09:42 <jfredett> aspo, right- but the theory is that eventually, you'll start doing it right
23:09:47 <jfredett> and doing full FP scheme
23:09:49 <aspo> optimist
23:09:52 <dons> heh.
23:10:03 <jfredett> by that point, you're enlightened, and are allowed to graduate to Haskell..
23:10:03 <dons> full FP should be the default ;)
23:10:11 <aspo> talking of which, is there a good site for learning haskell style
23:10:22 <ddarius> haskell.org
23:10:28 <aspo> as I slowly wrap my brain around this crazy language I'm kind of worried
23:10:33 <jfredett> well thats how _I learned_ scheme/Lisp
23:10:35 <aspo> that I'm doing things totally ass backwards
23:10:37 <dons> yeah, there's style guides on haskell.org
23:10:52 <jfredett> aspo, you just have to let haskell kill you and then resurect you as a FP Zombie
23:10:54 <Korollary> It's ok as long ass backwards is a monad.
23:11:01 <jfredett> its not that much to pay. :)
23:11:28 <ddarius> Okay, I have to get up in 5 hours and 35 minutes, I'm going to sleep.
23:11:33 <Pseudonym> aspo, you're also welcome to post your code for a critique.
23:11:45 <Figs> Did I say I was back?
23:11:47 * Figs can't remember
23:11:56 <jfredett> the only language which you can learn "wrong" is VB, and the only way to do that wrong is to start learning it
23:12:00 <Pseudonym> Figs: You are back.  Consider your memory jogged.
23:12:01 <Figs> oh, I did
23:12:03 <jfredett> yes, Figs at 2:08:10 am
23:12:07 <Figs> ok, thanks :)
23:12:09 <jfredett> EST
23:12:13 * Figs was reading the log
23:12:18 <Figs> or skimming, I should say
23:12:20 <dons> ?time Figs
23:12:21 <lambdabot> Local time for Figs is Wed Jun 20 23:11:20 PDT 2007
23:12:21 <jfredett> would you like the milliseconds too?
23:12:51 <jfredett> damn PDT kids and your 3 hour lagbehind
23:13:02 <dibblego> dons, was it you who has done some programming on nvidia GPUs?
23:13:03 <Figs> I used to live in Hawaii
23:13:07 <Figs> UTC-10
23:13:07 <sorear> @time
23:13:07 * jfredett 's girlfriend lives in CA
23:13:09 <lambdabot> Local time for sorear is Wed Jun 20 23:12:01 2007
23:13:11 <dons> dibblego: Sean Lee, guy sitting next to me.
23:13:22 <Figs> now, that was crazy :P
23:13:23 <jfredett> ?time
23:13:32 <dons> he has a special purpose toy^h^h^h machine with hide end programmabe nvidias
23:13:35 <dibblego> dons, I'm going to be doing a bit - haven't started look yet - does he also write some C?
23:13:38 <dons> s/high/
23:13:55 <dons> he writes in C and CG, OpenGL and the new nvidida CUDA thingy
23:14:22 <dons> mostly array processing and similar stuff currently.
23:14:23 <jfredett> okay, time for sleep
23:14:29 <jfredett> hasta la pasta
23:14:33 <Figs> adios :P
23:14:40 <sorear> g'night all!
23:14:42 <dons> so if you're doing some big old array munging. toss an nvidia gpu at it.
23:14:51 * dons ponders parallel bytestrings on gpus.
23:15:17 * Figs has an idea
23:15:32 <Figs> (be afraid!)
23:15:53 <dibblego> dons, my boss has been looking at nvidia GPUs and plans on using C/Haskell to do something-a-rather; I get worried that he is duplicating work when he has these ideas
23:16:41 <sorear> zzz.
23:17:10 <Figs> do you guys consider type-checking in languages like C++ to be related to preparing functional language code for execution?
23:17:13 <dibblego> he has the impression that laziness incurs a performance penalty and I have been trying to persuade him otherwise for weeks
23:17:46 <Figs> well, I'm sure it does! stop being so lazy at work! </joke>
23:17:57 <dibblego> it's a common beginner mistake is all
23:18:46 <Figs> please let me know if I'm getting annoying or disruptive; I'm just interested in my thought experiments, I'm not trying to piss anyone off
23:20:34 * Figs wonders if everyone has been scared off by my insanity
23:20:35 <ski> what do you mean, "preparing functional language code for execution" ?
23:20:54 <Figs> I guess I mean 'compiled'
23:21:13 <ski> one could perhaps say statically typed FPLs "prepare code for execution" partly be type checking
23:21:17 <Figs> although the way you guys have described it, compiled or interpretted doesn't seem to make much difference
23:21:20 <ski> (s/be/by/)
23:21:20 <dons> dibblego: also, its rather hard. better talk to Manuel and Roman about it.
23:21:32 <Figs> but that could just be my n00bishness
23:21:55 <dons> laziness doesn't have a penalty if you don't want it to have one: strictness analysis removes all laziness, after all.
23:21:56 <dibblego> dons, my boss has been emailing Manuel about it; I just get worried when he goes on these journeys :)
23:22:00 <dons> hehe
23:22:04 * gour hopes dons is doing some 'real-world' haskell
23:22:07 <dibblego> dons, that's what I've been trying to explain (in more detail)
23:22:21 <dons> its a strict, eager and lazy language, in the end.
23:22:37 <dons> so you can choose between full strict, eager (like lazy bytestrings), or fully lazy
23:22:40 <dons> as appropriate.
23:22:43 <Pseudonym> dons: You're forgetting the full-employment theorem for strictness analyser writers.
23:22:47 <dibblego> he plans to use Haskell and then use C at times when performance is a requirement
23:22:49 <dons> hehe yes.
23:22:55 <dons> dibblego: sounds reasonable
23:23:05 <Pseudonym> Many areas of compiler design have full-employment theorems.
23:23:06 <dibblego> I'm not sure if a) that is a good idea or b) he has sound judgement in gauging performance
23:23:16 <dibblego> dons, thanks :)
23:23:19 <Pseudonym> I don't think that C++ parsing has one yet, but it's only a matter of time.
23:23:30 <Figs> full employment?
23:23:54 <Pseudonym> Figs: A full employment theorem is a theorem that states that some desirable task is impossible to do perfectly.
23:24:09 <Pseudonym> So there's always scope for people to come up with new algorithms.
23:24:13 <Pseudonym> Hence, full employment.
23:24:17 <dons> compilers, and optimisation in general, often have this property
23:24:31 <dibblego> Java programmers will always have "full employment"
23:24:33 <Figs> ahh :P
23:24:42 <dibblego> because a desirable task is always impossible
23:24:55 <Figs> sort of cynical, or perhaps realistic
23:24:57 <Pseudonym> Strictness analysis is, if you want it perfect, equivalent to the halting problem.
23:24:57 <Figs> ;)
23:24:58 <dons> there's some connection to the NP hardness, I'm sure, of a given problem. ;)
23:25:11 <Pseudonym> That's pretty trivial to show.
23:25:15 <dons> yeah. those are the good ones.
23:25:22 <dons> since you can just keep billing for your time
23:25:46 <Pseudonym> As long as you keep showing improvement, of course.
23:26:08 <dons> so that's the main thing, to keep hill climbing.
23:26:39 * Figs remembers stories of a-life and hill climbing
23:27:59 <Figs> how many pure declarative *practical* languages are there?
23:28:04 <quicksilver> dons: but I'm right in thinking they didn't in the first verion of stream fusion?
23:28:13 <quicksilver> SQL?
23:28:15 <dons> quicksilver: in the bytestring paper, they're left as further work.
23:28:19 * quicksilver nod
23:28:23 <Figs> I mean for like, full programs
23:28:26 <Pseudonym> It largely depends what you mean by "practical".
23:28:29 <dons> since we didn't know how to optimise the state that gets stuck in the stream state
23:28:33 <quicksilver> you can presumably only fuse down one side, I suppose?
23:28:35 <Pseudonym> Some people have the odd idea that Haskell isn't practical.
23:28:38 <dons> but that's when constructor specialisation comes in
23:28:53 <Figs> In your opinion
23:29:02 <dons> zip,                    -- :: Stream a -> Stream b -> Stream (a, b)
23:29:05 <Pseudonym> It's my opinion that that idea is odd.
23:29:19 <Figs> no, I mean languages
23:29:53 <Pseudonym> I can think of half a dozen offhand, most of them special-purpose.
23:30:03 <Pseudonym> Haskell and Mercury have both been used in industry.
23:30:14 <dons> it'll fuse with both input arguments
23:30:15 <Pseudonym> Clean may or may not have, unsure on that.
23:30:24 <Figs> has anyone tried a full declarative language with a syntax like C yet? :P
23:30:25 <dons> zipWith3 f xs ys zs = unstream (Stream.zipWith3 f (stream xs) (stream ys) (stream zs))
23:30:28 <dons> for example
23:30:30 <Figs> just out of curiousity
23:30:33 <Pseudonym> SQL, of course, is now Turing-complete.
23:30:43 <dons> will fuse with an: unstream . f . stream applied to the result
23:31:11 <Pseudonym> In the sense that any well-moded Prolog program with no I/O can be converted into a SQL expression.
23:31:38 <quicksilver> dons: so it becomes an "iteration" which accesses all three streams in a loop?
23:31:42 <dons> and the input streams will fuse, if they're streams themselves.
23:31:56 <dons> yielding a zip that pulls elements off each input stream in turn,
23:31:58 <dons> right.
23:32:03 <quicksilver> Pseudonym: general recursion is not present in any actual SQL dialect I'm aware of
23:32:06 <quicksilver> dons: nice
23:32:07 <dons> it'll become a loop with 3 reads
23:32:19 <dons> the stepper (loop body) is:
23:32:21 <dons>     next (sa :!: sb :!: Nothing)     = case next0 sa of
23:32:21 <dons>         Done        -> Done
23:32:21 <dons>         Skip    sa' -> Skip (sa' :!: sb :!: Nothing)
23:32:21 <dons>         Yield a sa' -> Skip (sa' :!: sb :!: Just (L a))
23:32:24 <dons>     next (sa' :!: sb :!: Just (L a)) = case next1 sb of
23:32:26 <dons>         Done        -> Done
23:32:29 <dons>         Skip    sb' -> Skip          (sa' :!: sb' :!: Just (L a))
23:32:31 <dons>         Yield b sb' -> Yield (f a b) (sa' :!: sb' :!: Nothing)
23:32:43 <dons> which pulls an element off the first input stream, then off the second, and applies f to it.
23:32:57 <dons> so yeah, just a single loop
23:33:27 <dons> the trick was to get ghc to optimise the two branches of the 'next' back into 2 separate functions
23:33:32 <dons> avoiding the Maybe that's rebuilt each time around
23:33:39 <Figs> maybe I'm weird, but I think most things are best as a mix of declarative/relational code and some imperative code
23:34:15 <Pseudonym> Figs: I tend to agree in part.  Most sufficiently large applications are best expressed using more than one paradigm.
23:34:36 <Pseudonym> What you need is either multiple languages, or one language in which you can convincingly fake it.
23:34:47 <Pseudonym> Haskell, for example, fakes imperative code convincingly.
23:34:53 <Pseudonym> do-notation has a lot of people convinced.
23:35:05 <dons> s/convinced/fooled/ ;)
23:35:07 <Pseudonym> C++ can fake a lot of other paradigms, too.
23:35:08 <Figs> how about a language which is really more than one language?
23:35:20 <aspo> what, common lisp?
23:35:24 <Pseudonym> LOL!
23:35:25 <moozilla> python?
23:35:35 <Pseudonym> Common Lisp really is more than one language, yeah.
23:35:38 <Figs> no, it was just a weird idea that I was thinking of
23:35:40 <dons> what is a language that is more than one language?
23:35:41 <jfredett> python is for losers.
23:35:46 <Figs> but yeah, I guess I can see what you mean about Lisp
23:35:46 <dons> a single language with non-coherant parts?
23:35:49 <moozilla> jfredett: I agree
23:35:55 <jfredett> CL > Python, frak you guido van rossum
23:36:08 <jfredett> getting rid of everything that made me want to learn python
23:36:22 <quicksilver> well stuff like SQL embedded in C, presumably
23:36:26 <jfredett> just another book that'll sit on my shelf.
23:36:27 <jfredett> :/
23:36:29 <quicksilver> which was a popular trick at one point
23:36:29 <moozilla> haha http://python.org
23:36:33 <dons> or like do-notation layered on haskell?
23:36:52 <Figs> heh, I actually had an idea of a way to impliment SQL-like table lookups directly in C++ notation
23:37:00 <dons> Pseudonym: do you like the .au gov debate regarding broadband :}
23:37:04 <Figs> (operator overloading is fun)
23:37:13 <Pseudonym> dons: I'm selling popcorn.
23:37:17 <Pseudonym> Figs: You'll love HaskellDB.
23:37:21 <Figs> but, that's neither here nor there
23:37:40 <Figs> ooh, I once made C++ look a bit like lisp
23:37:41 <dons> Pseudonym: i notice just then one member pointing out that wireles will require add on wireless cards, and thus its all a sham. the intertubes won't work, without new hardware. shock!
23:37:56 <Pseudonym> Oh, man./
23:37:56 <jfredett> Figs: them be fightin words.
23:37:59 <Pseudonym> I didn't catch that.
23:38:02 * Pseudonym laughs
23:38:25 <dons> too much money, not enough qualified people, involved :-(
23:38:30 <Figs> it was an abuse of operators
23:38:39 * dons starts "engineers for president" party
23:38:47 <jfredett> good times, Lisp is good at abusing operators
23:38:48 <Pseudonym> This is the BSA all over again.
23:38:59 <Figs> I wish I'd caught worsethanfailure's programming contest
23:39:01 <jfredett> and code, data, and life in general
23:39:09 <Figs> or I'd have entered it, based on greenspun's tenth law ;)
23:39:13 <Pseudonym> When that was being debated, parliamentarians were falling over each other trying to say how luddite they were.
23:39:18 <dons> ;(
23:39:22 <jfredett> Lisp will beat gold shits out of you
23:39:22 <Pseudonym> "Well I know less than you!"
23:39:43 <Pseudonym> They were actually *proud* of that!
23:40:03 <dons> yeah, i'm not sure you can get away with that now.
23:40:12 <jfredett> that loosely translates to "Damnit! I'm dumber!"
23:40:19 <Pseudonym> Yeah, pretty much.
23:40:25 <jfredett> brilliant
23:40:31 <jfredett> Bush has them beat though
23:40:33 * notsmack can't figure out the context of this
23:40:35 <jfredett> US wins again!
23:40:47 <jfredett> there is no context, only Mu.
23:41:08 * notsmack is down with Mu.
23:41:17 <jfredett> I get Zen-y when I'm exhausted
23:41:31 <Figs> anyway, thanks guys
23:41:37 <Figs> I've gotten all I need for tonight
23:41:41 <jfredett> rock on, learn scheme.
23:41:42 <Figs> cya
23:42:58 <opqdonut> just read zen and the art of archery once again
23:43:14 <opqdonut> the book manages to blow my mind every single time i read it :)
23:43:45 <jfredett> Zen is fun
23:44:02 <therp> opqdonut: that's a nice one
23:44:20 <Pseudonym> Zen isn't fun.  Zen just is.
23:44:40 <jfredett> Zen isn't just, Zen just isn't.
23:44:46 <opqdonut> therp: yeah, guess why i'm dying to get to japan on university exchange :)
23:44:47 <Pseudonym> Mu.
23:44:59 * jfredett is enlightened
23:51:58 <dolio> > (4.3 * 20) / 60
23:52:00 <lambdabot>  1.4333333333333333
23:53:38 <dolio> > 176.25 / 4.3
23:53:39 <lambdabot>  40.98837209302326
23:54:20 <stevan> hi, how can i divide two ints? (1 :: Int) / (1 :: Int). thanks.
23:54:28 <dolio> :t div
23:54:30 <lambdabot> forall a. (Integral a) => a -> a -> a
23:54:58 <jfredett> >5`div`2
23:55:13 <vincenz> need a space
23:55:18 <jfredett> > 5 `div`2
23:55:21 <lambdabot>  2
23:55:24 <jfredett> my bad
23:55:29 <vincenz> np :)
23:55:41 <stevan> and if i want the decimals?
23:55:54 <vincenz> stevan: then you have to use floating point numbers
23:56:02 <vincenz> stevan: one option is to convert the integers
23:56:06 <vincenz> :t fromIntegral
23:56:11 <lambdabot> forall a b. (Num b, Integral a) => a -> b
23:56:13 <jfredett> > (fromIntegral 5) / (fromIntegral  2)
23:56:15 <lambdabot>  2.5
23:56:25 <vincenz> > let x = 1 :: Int in fromIntegral x / fromIntegral x
23:56:27 <lambdabot>  1.0
23:56:45 <vincenz> jfredett: 5 can default to double
23:56:46 <vincenz> > 5 / 5
23:56:49 <lambdabot>  1.0
23:57:03 <vincenz> > let x = 5 :: Int in x / x
23:57:04 <lambdabot>   add an instance declaration for (Fractional Int)
23:57:04 <lambdabot>     In the expression: let...
23:57:07 <jfredett> granted, but in context
23:57:12 <vincenz> > let x = 5 :: Int in fromIntegral x / fromIntregral x
23:57:14 <lambdabot>   Not in scope: `fromIntregral'
23:57:20 <vincenz> ack, well you saw it before
23:57:46 <jfredett> anywho, gnite again
