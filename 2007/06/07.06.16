00:05:35 <basti_> yow
00:24:01 <fridim> I've a Polygon [Vertex]   which is  [(Float, Float)]. How Can I now that a list :: [Vertex] is in the clockwise ?
00:24:25 <basti_> know?
00:24:35 <fridim> it is to compute area of a polygon
00:24:42 <fridim> yes, s/now/know/
00:24:47 <basti_> hmm
00:24:51 <basti_> there was a trick for that
00:24:54 * basti_ tries to remember
00:25:46 <basti_> you could sum up the angles
00:26:01 <fridim> I hope so, because for the moment I feel stupide since I've been trying to solve this exercise for 4 hours
00:26:04 <mdmkolbe|work> How do I go about citing the zipper file system in a paper?  It looks like it was a talk as HW2005, but I can't find any paper for it only source code and some web/newsgroup postings.
00:26:35 <kfish> how about an opaque list type that you can only manipulate with functions that maintain clockwise ordering?
00:26:37 <basti_> fridim: can you determine the angle between two pieces of line?
00:26:47 <fridim> basti_, yes.
00:26:55 <basti_> then you know if it's clockwise or not
00:27:24 <fridim> I wrote a function  angle :: Vertex -> Vertex -> Float  for that
00:27:35 <basti_> you just sum up, if the angle is positive you're one way, if not, you're the other
00:27:50 <basti_> an angle between two vertices?
00:28:07 <fridim> yes
00:28:08 <kfish> (ah, know == determine, not ensure ;-)
00:28:16 <basti_> heh
00:29:31 <fridim> basti_, if I sum up the angles of list or the angles of reverse list, it is the same. Or maybe I don't see how you sum up
00:29:42 <basti_> hmm
00:30:25 <basti_> measuring the angle between two pieces of line would yield a different result if you do it the other way
00:30:55 <basti_> _/ < lets take this angle
00:31:20 <basti_> now you come from the left and measure clockwise... you'd get something like 135°
00:31:32 <basti_> hm
00:31:34 <basti_> no actually not
00:31:36 <basti_> lol
00:31:56 <basti_> how was this trick dang...
00:31:59 <fridim> angle v1 v2 v3 = acos ( (a^2 + b^2 - c^2) / (2 * a * b) )
00:31:59 <fridim>                  where a = distBetween v1 v2
00:31:59 <fridim>                        b = distBetween v2 v3
00:31:59 <fridim>                        c = distBetween v3 v1
00:32:07 <fridim> this is the function angle I wrote.
00:32:27 <basti_> looks good
00:33:05 <basti_> hrmm
00:35:35 <basti_> how about measuring the angles between 0, v1 and v2 for every line?
00:35:44 <basti_> and then summing then up?
00:37:45 <fridim> it will be the same working clockwise or not
00:39:52 <basti_> in 3d the normal will point according to the sense.
00:40:55 <fridim> and what about self-crossing?
00:40:56 <fridim> :-)
00:41:09 <fridim> I think i'll give up this exercise
00:41:10 <basti_> self-crossing is a pathological case.
00:41:11 <basti_> ^^
00:41:22 <fridim> I never thought it would be that hard
00:41:38 <fridim> to do the third exercise of this book
00:41:44 <fridim> oO
00:41:47 <basti_> h3h3
00:41:52 <basti_> oops
01:32:24 <hpaste>  fridim pasted "my answer to the computation of a convex or non convex Polygon" at http://hpaste.org/299
01:33:14 <basti_> convex/non convex is different to clockwise/anticlockwise.
01:34:54 <fridim> in fact clockwiseList doesn't check the clockwiseness :)
01:35:24 <fridim> I admit all polygon are given in clockwisely :)
02:02:45 <MarcWeber> How to express " show _ = "foo" ++ (show (undefined :: a)) ++ (show ( undefined :: b)) in template haskell ?
02:02:59 <MarcWeber> http://hpaste.org/289 < This results in compiler errors
02:06:07 <Heffalump> aren't you quantifying over the type parameter?
02:06:08 <lambdabot> Heffalump: You have 1 new message. '/msg lambdabot @messages' to read it.
02:06:59 <Heffalump> that ForallT [n] looks dodgy.
02:07:19 <Heffalump> since n is one of typeParams that should already be in scope from the instance declaration
02:13:34 <MarcWeber> Heffalump: runQ [| .. |] >>= print did print this. I'll try
02:19:08 <Heffalump> MarcWeber: did you have the instance declaration inside the brackets too at the time? I guess not sincce [| .. |] are expr brackets
02:19:11 <MarcWeber> Heffalump: He. Thanks a lot.. That's it! *beeing happy* *beeing happier*
02:19:21 <MarcWeber> *beeing happiest*
02:19:39 <Heffalump> it would have assumed the free type variables were quantified at the topmost level, and pushed them into some natural place for them
02:19:53 <MarcWeber> nulling the first list within forallT did it.
02:20:09 <Heffalump> right
02:20:29 <MarcWeber> Then this might be a bug in the [| .. parser ? I'll ask at the ghc mailnglist
02:21:04 <Heffalump> no, it's not a bug
02:21:27 <Heffalump> you gave it a fragment out of context, so it couldn't tell where the type variables were bound
02:21:57 <Heffalump> if you'd given it the whole instance inside whatever brackets those go in [d| ... |] I guess, it should have got it right
02:23:37 <MarcWeber> Heffalump: No. I did tell ghc to runQ [| instance ... |] >>= print the whole thing
02:23:41 <MarcWeber> But I'll retry
02:24:14 <dancor> i have a finite but intricate data structure where each possibile value corresponds to an image.  i want to just specify the type -> image mapping once (or zero times by being clever with show..) and load all the images at once (walking over deriving enum?)
02:24:49 <dancor> does this seem feasible in haskell
02:25:30 <dancor> right now i'm loading them into an array and i have a data -> int fcn to look them up, but there is redundancy
02:27:27 <hpaste>  Marc Weber pasted "@ Heffalump" at http://hpaste.org/300
02:30:33 <Heffalump> I didn't think [| .. |] were the right brackets for an instance declaration
02:30:43 <Heffalump> oh, I see, you used [d|, ok
02:31:46 <Heffalump> I think that ForallT [d_1] [] (VarT d_1) should be ForallT [] [] (VarT d_0)
02:31:56 <Heffalump> seeing as d_0 is the thing in scope
02:32:00 <MarcWeber> Exactly. That's what you have suggested.
02:32:06 <MarcWeber> And that works.
02:32:22 <Heffalump> however, it's possible that I'm a bit confused about the rules for type variables being in scope in instance declarations
02:32:23 <MarcWeber> I'll post this issue the the glasgow-haskell-users list
02:32:30 <MarcWeber> They'll tell me ;-)
02:32:35 <Heffalump> sounds reasonable
02:33:13 <Heffalump> (note that your comment at the bottom of the paste says d_1 for what you think it should be, which is why I corrected it to d_0)
02:38:58 <MarcWeber> Heffalump: Have look again at http://hpaste.org/289  (function und n = ... Here I'm using n. n is an element of map as well as the Show n1 , Show n2 instances are. So this doesn't solve the problem (thus compare contexts to und. both use typeParams)
02:39:41 <MarcWeber> The only solution is to omit the X in  ForallT [X].
02:57:36 <dancor> does haskell have exact fractions
02:57:47 <dmhouse> ?hoogle Ratio
02:57:48 <lambdabot> Data.Ratio :: module
02:57:48 <lambdabot> Ratio :: module
02:57:48 <lambdabot> Data.Ratio.Ratio :: data Ratio a
02:57:55 <dmhouse> ?src Ratio
02:57:55 <lambdabot> data (Integral a) => Ratio a = !a :% !a
02:58:03 <dancor> nice
02:58:34 <Heffalump> MarcWeber: what doesn't solve the problem?
03:01:27 <Heffalump> (gone out for a while)
03:28:01 <MarcWeber> Heffalump: Using the same d_ as in the instance declaration (..) =>
03:30:57 <nomeata> lambdabot needs to respond to @thx or @thanks, considering how useful lambdabot is :-)
03:31:07 <opqdonut> @botsnack
03:31:07 <lambdabot> :)
03:31:52 <nomeata> ah, ok
03:35:39 <xpika> hi
03:39:38 <xpika>  while compiling ghc i get this error
03:39:42 <xpika> cannot find input file: docs/users_guide/ug-book.xml.in
03:41:01 <Heffalump> MarcWeber: (back)
03:41:11 <Heffalump> I'm still a bit confused about what does and doesn't work.
03:41:15 <xpika> it wants an xml file but its not located anywhere in the source
03:41:33 <Heffalump> I'd expect using the same type variable as mentioned in the instance declaration, without putting it in the ForallT list, to work .
03:41:48 <Heffalump> I don't think I'd expect anything else to.
03:47:58 <xpika> dw its in the tar,but  for some reason it didnt extract :/
03:48:28 <dancor> does anyone ever feel like there should be a way to generalize over like liftM4, liftM5..
03:48:35 <xpika> yes
03:48:45 <dancor> haskell metafunctions
03:49:12 <opqdonut> generalised tuple-functions would be heaven as well..
03:49:14 <xpika> i would like to see a zipN aswell
03:49:19 <opqdonut> yeah exactly
03:50:16 <MarcWeber> Heffalump: Using the same d_ as in the instance declaration (..) => , Never mind. you have solved the problem ;-)
03:50:55 <Heffalump> dancor: template haskell is one, slightly hacky, way to solve those problems
03:53:18 <MarcWeber> Heffalump: Do you have HList installed?
03:53:34 <Heffalump> nope
04:01:06 <MarcWeber> Heffalump: http://www.mawercer.de/marcweber/Heffalump.zip
04:01:17 <MarcWeber> stripped down example which works. See the last comment in TH.hs
04:03:22 <Heffalump> "cannot find HOrd"
04:03:42 * Heffalump just reads the code
04:03:50 <Heffalump> I don't see why you expect the commented out bit at the bottom to work
04:04:09 <Heffalump> the forall quantification of n makes it into a different n from the one bound y the instance declaration
04:04:13 <Heffalump> s/bound y/bound by/
04:04:14 <MarcWeber> Then everything is fine.
04:04:18 <Heffalump> ok, cool
04:04:40 <Heffalump> though as you say, the quasiquoting may be buggy
04:04:46 <MarcWeber> Except of the [d| ] >>= print thing which produces this not working example from working code
04:05:38 <MarcWeber> Mail sent to glasgow-haskell-users ;) Thank again!
04:08:35 <mdmkolbe|work> Wheee ... the Great Deadline has now expired
04:08:44 * mdmkolbe|work can relax for the first time in three days
04:10:07 <opqdonut> :)
05:36:47 <chessguy> 'morning
05:36:52 <chessguy> @seen procyon112
05:36:52 <lambdabot> I haven't seen procyon112.
05:45:25 <nomeata> Hi. Is hare still developed?
05:53:12 <erider> good morning
05:53:24 <ohub> hello
06:23:36 <chrismbrown> nomeata: yes
06:25:02 <chrismbrown> nomeata: I'm the sole developer left on the project. Do you have a question regarding it?
06:25:55 <nomeata> chrismbrown: no, not really. I just had a quick glance...
06:26:28 <chrismbrown> nomeata: there hasn't been a release for a while due to various reasons. It's still very much being developed though
06:26:50 <nomeata> nice!
06:26:56 <nomeata> Iâ€™ll have a look on the project
06:27:06 <Heffalump> how usable is it?
06:27:34 <chrismbrown> Heffalump: very useable! lol. It works on the full Haskell 98 standard and is intergrated into both Emacs and Vim
06:32:12 <Heffalump> "just the full Haskell 98 standard"
06:32:19 <Heffalump> sorry, meant to reword that
06:32:21 <chrismbrown> what do you mean just?
06:32:33 <Heffalump> the full Haskell 98 standard is a bit behind most Haskell programs these days, sadly :-(
06:33:04 <chrismbrown> not through our fault though! When we designed the infrastructure the haskell 98 standard was very much the de facto standard to use
06:33:24 <chrismbrown> and is *still* the haskell standard
06:33:53 <chrismbrown> it's far too much effort to port it to, say, the GHC infrastructure
06:34:42 <Heffalump> yeah, I know it's hard
06:34:48 <nothingmuch> `/w 23
06:35:02 <chrismbrown> it's frustrating, like you say, people don't seem to use just the standard these days
06:35:13 <Lemmih> chrismbrown: Is there a snapshot that works with ghc-6.6?
06:35:38 <chrismbrown> I have a snapshot I'm hacking on right now that works with 6.6.1
06:38:00 <Lemmih> chrismbrown: Can I have it?
06:38:20 <chrismbrown> Lemmih: sure, I'm just pushing some changes to the repo then I'll send you the darcs link
06:41:10 <Lemmih> bens__: Multiplying, eh?
06:41:24 <Heffalump> they're everywhere!
06:43:47 <chrismbrown> Lemmih: darcs get http://www.cs.kent.ac.uk/projects/refactor-fp/HaRe_Project
06:50:10 <chrismbrown> Lemmih: you might want to pull that again, I forgot to add a couple of files...
06:50:59 <ekidd> Good morning!
06:52:56 <Heffalump> morning
06:53:43 <ekidd> I need to decide what to hack on next... There are too many choices, as always.
06:54:06 <Lemmih> chrismbrown: Whoa, 308 non-hierarchical modules.
06:54:30 <chrismbrown> Lemmih: I know... it's because it's built on top of a refurbished Programatica
06:56:45 <syntaxfree> ekidd: do think about writing a paper for a statistics journal on probability monads.
06:56:59 <Lemmih> chrismbrown: Is step 0 still valid?
06:58:04 <syntaxfree> ekidd: do you know Pancito, btw?
06:58:08 <ekidd> syntaxfree: You'd have to tell me where to start. :-)
06:58:11 <ekidd> Nope.
06:58:40 <ekidd> Oh, interesting!
06:59:25 <ekidd> Those are really pretty images: http://www.acooke.org/jara/pancito/
06:59:26 <lambdabot> Title: Jara Software: Pancito: Home Page
06:59:29 <syntaxfree> ekidd: well, basically you have to explain further what are monads, etc. and how monads are an interesting framework for a very general approach to probability system.
06:59:40 <syntaxfree> ekidd: the system itself is interesting. you manipulate images as functions.
06:59:48 <syntaxfree> I'd *love* something like that for audio.
07:00:09 <ekidd> syntaxfree: Would it be better to explain monads in terms of a programming language, or in terms of pure math?
07:00:45 <syntaxfree> depends on the journal, I guess.
07:00:58 <syntaxfree> It's better to explain what the monad "does" in pseudoimperative code, I guess.
07:01:23 <syntaxfree> http://syntaxfree.wordpress.com/2007/01/20/baby-steps-with-pancito-a-simple-color-filter/
07:01:28 <lambdabot> Title: Baby steps with Pancito: a simple color filter « Data.Syntaxfree, http://tinyurl.com/2juora
07:01:37 <syntaxfree> I actually went halfway through writing a Pancito-like once, before even finding out about it.
07:02:05 <ekidd> syntaxfree: If you'd like to coauthor something on probability monads, I'd be delighted to collaborate with you.
07:02:27 <ekidd> You know the audience so much better than I do.
07:04:27 <chrismbrown> Lemmih: step 0?
07:05:07 <syntaxfree> ekidd: I'm actually not acquainted with computation-oriented statistics journals. I've read a few /books/, but that's different.
07:05:10 <Lemmih> chrismbrown: from the README file.
07:05:32 <chrismbrown> yes, it's valid
07:05:33 <syntaxfree> of course,  it'd be a great honour to co-author something, I'm just afraid of not being the right partner.
07:06:14 <ekidd> syntaxfree: I, on the other hand, have never even sat through a course in real statistics (I'm just some kind of weird Bayesian fanboy).
07:06:18 <chrismbrown> oh, I guess the bit about the partial built probably could be taken out
07:06:20 <syntaxfree> Statistics is such a wide field, it's almost as wide as, say, "computers".
07:06:21 <ekidd> So you're way ahead of me there.
07:07:24 <syntaxfree> The kind of /journals/ I'm very acquainted with deal with parametric estimation, mostly. I know a bunch about nonparametric methods, but only to the point of standard (graduate-level) textbook fare.
07:08:12 <syntaxfree> ekidd: anyway, yeah, we can try, I guess. We can format it for an econometrics audience.
07:08:52 <syntaxfree> People get away with publishing papers for Stata implementations of straight-forward minimization algorithms just because it's a new GMM-based estimator.
07:09:44 <syntaxfree> and I'd sure love a paper on my CV with "monad" on its title :P
07:09:59 * syntaxfree = CS teenybopper.
07:10:19 <ekidd> Well, if you have a particular journal in mind, and a good idea of what the readers should take away from a survey article, please let me know!
07:10:27 <ekidd> You can send me an e-mail later, if you want.
07:10:42 <ekidd> (...and thus the monad cabal does its evil work...)
07:11:05 <syntaxfree> ekidd: basically, what econometricians do about programming right now is really ugly imperative code.
07:11:34 <syntaxfree> a practicing econometrician has a lot of programming to get done if they are to use modern methods, but not much knowledge about programming itself is spread.
07:11:49 <syntaxfree> People are always amazed at how pretty my code looks just because it's kinda factored into functions.
07:12:21 <ekidd> syntaxfree: Heh.
07:13:06 <SamB> heh
07:13:14 <ekidd> syntaxfree: It might actually be easier to go after statisticians who do slightly less day-to-day programming.
07:13:34 <syntaxfree> ekidd: it might. but then why would they be interesting in programming concepts?
07:13:36 <ekidd> I find that novice programmers are more open to functional approaches than people who know only C++, and that badly.
07:13:48 <SamB> well, if they like his code they may try to immitate it
07:14:06 <syntaxfree> SamB: except they can't figure the first thing out about how I factor stuff into functions.
07:14:15 <SamB> syntaxfree: they can't?
07:14:18 <syntaxfree> They try to immitate it by separating sequential steps into functions.
07:14:19 <SamB> what part gets them?
07:14:22 <SamB> oh.
07:14:23 <SamB> heh
07:14:32 <SamB> what do you do?
07:14:36 <syntaxfree> "Code reuse" hasn't dawned upon them.
07:14:38 <DRMacIver> Even that is better than nothinng. :)
07:14:44 <ekidd> *Really* experienced C++ programmers actually make reasonable functional programmers, because they've already been forced to think functionally while building template libraries.
07:14:45 <syntaxfree> Well, I use functions for ... functional parts.
07:15:12 <SamB> syntaxfree: teach 'em lambda calculus !
07:15:33 <syntaxfree> SamB: that's not gonna work. They don't want to learn CS theory.
07:15:38 <ekidd> I'm continually horrified and amazed at how ugly most code by engineers and physicists tends to be--
07:15:44 <SamB> disguise it in maths
07:16:01 <syntaxfree> But if probability monads are to help with code reuse and suchlike it might catch.
07:16:04 <ekidd> a 5-page program in one giant function, with one-letter variable names and no comments, just for example.
07:16:08 <SamB> better, disguise your program as maths
07:16:18 <DRMacIver> ekidd: I'm continually horrified and amazed at how ugly most code by programmers tends to be. :)
07:16:18 <syntaxfree> ekidd: yeah. and a lot of stuff wrapped into matrices.
07:16:44 <SamB> I might have one-letter
07:16:47 <syntaxfree> I've done that, when taking a coure in numerical methods by an applied mathematician/fluid-dynamics physicist.
07:16:53 <SamB> variable names in some of my engineering-ish code...
07:16:55 <syntaxfree> I've even taken that style to my first neural net code.
07:17:04 <SamB> (and an enter key that is too big)
07:17:08 <syntaxfree> I made loops into matrix multiplications.
07:17:21 <ekidd> syntaxfree: There's a whole bunch of languages for Bayesian networks and probabilistic reasoning. Do any corners of the statistics community occasionally have papers involving these languages.
07:17:25 <syntaxfree> I had to have sheets of paper with hollow matrix shapes and indexes to track what I got done.
07:17:50 <syntaxfree> ekidd: not that I know of. But then again, I don't follow machine learnign closely.
07:17:55 <ekidd> DRMacIver: Well, most actual programmers at least make a token effort to use some functions now and then. (Well, except in PHP code, which can get pretty vile.)
07:18:08 <syntaxfree> My speciality is statistical methods for inference from nonexperimental data.
07:18:19 <SamB> nonexperimental?
07:18:30 <SamB> you mean, like release data ;-)?
07:18:34 <syntaxfree> SamB: yeah. When you don't get to do pretty controlled experiments.
07:18:50 <DRMacIver> ekidd: 'token effort' is the key phrase unfortunately. They're often very good about making everything nice and isolated when things are simple, but as soon as it gets complicated the lines all start to cluster together in larger and larger functions...
07:18:59 <DRMacIver> Or at least such is my experience of some of our code at work. :)
07:19:01 <syntaxfree> The basic thing about controlled experiments is that all unobserved factors are supposed to be random.
07:19:04 <syntaxfree> So you're testing a drug.
07:19:15 <syntaxfree> You get two random groups. Give one of them a drug and one of them placebo.
07:19:17 <syntaxfree> Then compare.
07:19:38 <syntaxfree> You don't want age/height/gender/weight to influence the result. So you get representative groups on each side.
07:19:39 <SamB> the key to that is that you start with one unrandom group
07:19:47 <SamB> and split it randomly into two
07:20:06 <SamB> or, well, fairly so
07:20:19 <syntaxfree> SamB: it's still a random group in the sense you don't want to get all males, 60-65 year old, same profession, etc.
07:20:42 <ihope> "Do you want a placebo or the real thing?"
07:20:45 <syntaxfree> anyway, in nonexperimental data you don't get to design experiments at all. You just get a bunch of data.
07:21:01 <SamB> ihope: hah
07:21:27 <SamB> ihope: you can't ask people that, the placebo effect only works if people think they are getting the real thing
07:21:36 <ihope> :-)
07:21:39 <syntaxfree> SamB: the main thing is that each group has a fair ammount of variation so you're not capturing the effect of other factors, just the effect of the drug.
07:23:02 <syntaxfree> Anyway, when you're trying to make inferences against nonexperimental data you don't get that much cleanliness.
07:23:09 <syntaxfree> Say you want to study the abortion-crime link.
07:23:21 <syntaxfree> You can't just compare states that don't have abortion and states that do.
07:23:28 <syntaxfree> Many other factors could influence crime.
07:23:35 <syntaxfree> Poorer states might have more crime.
07:23:42 <syntaxfree> Cultural factors could influence.
07:24:07 <DRMacIver> So you get lots of people to move into one state and commit crimes and see if the abortion rate changes? :)
07:24:11 <syntaxfree> A controlled experiment would involve picking 15 states at random and giving 7 of them an abortion ban.
07:24:21 <syntaxfree> and waiting 10 years.
07:24:49 <Heffalump> people confuse cause and effect all the time :-(
07:24:56 <Heffalump> syntaxfree: 30 years, I'd say
07:25:06 <syntaxfree> instead, what you have is that some states banned abortion and that's pretty much it.
07:25:08 <Heffalump> you have to wait for all those non-aborted babies to turn into criminals
07:25:11 <syntaxfree> you have to /control/ for other factors.
07:25:14 <Heffalump> (or not)
07:25:25 <syntaxfree> Heffalump: the parents might turn into criminals to support the children.
07:25:46 <syntaxfree> anyway, there are (very simple, actually) methods where you can factor in unemployment and GDP of the state into the comparison.
07:25:50 <Heffalump> perhaps, but you still need to study what happens to the children
07:26:17 <syntaxfree> So you can have an estimate of, given a fixed GDP and unemployment rate, what happens to the crime rate regarding an abortion law.
07:28:05 <syntaxfree> Other problems with endogenous selections (say, you can suppose the smarter, less-likely-to-become-criminal people leave abortion-ban states out of spite) or very complicated theoretical causality graphs to test.
07:28:15 <syntaxfree> er, other problems require more involved methods.
07:28:43 <syntaxfree> anyway, for the simple changes-in-crime-rate-are-caused-by-abortion-or-poverty-levels, you can fit an equation like
07:29:32 <syntaxfree> log(change in crime) = a0 + a1* log(change in poverty) + a2*log(change in unemployment) + a3*(is abortion allowed this year) + error
07:30:21 <syntaxfree> linear algebra guarantees that the a3 coefficient is the same as if you had taken the error from regressing crime against poverty and unemployment and then regress it against abortion.
07:34:51 <fasta> Why is there no instance (Monad m) => Control.Monad.Fix.MonadFix (Control.Monad.Cont.ContT a m)?
07:38:31 <oerjan> I am sure you would need at least MonadFix m context, consider the ContT _ IO instance
07:39:31 <fasta> oerjan: right, I was being sloppy, but that question remains.
07:40:25 <hpacheco> hi, i need help towards writing a function such that f :: SomeClass a b => a -> b
07:41:08 <oerjan> wild guesses: (1) no one has got around to it, or (2) there is actually some problem with defining it
07:41:10 <hpacheco> the type-checker always complains about the type not being enough generic when writing patterns
07:41:34 <Heffalump> can you paste an example to hpaste.org?
07:42:54 <hpacheco> sure
07:46:37 <hpaste>  hpacheco@gmail. pasted "class functional depency inference?" at http://hpaste.org/302
07:47:07 <hpacheco> me:P
07:47:52 <Heffalump> your definition of test assumes one particular instance of SomeClass, namely the Int Bool one
07:48:04 <Heffalump> what if someone else comes along with a different instance? test would be type incorrect for that instance.
07:48:33 <HairyDude> ?hoogle Monad m => (a -> m [b]) -> [a] -> m [b]
07:48:33 <lambdabot> No matches, try a more general search
07:49:26 <Heffalump> @type \f -> sequence . map f
07:49:27 <lambdabot>     Ambiguous occurrence `sequence'
07:49:28 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:49:42 <Heffalump> doh
07:49:43 <HairyDude> @type \f -> sequence . mapM f
07:49:45 <lambdabot>     Ambiguous occurrence `sequence'
07:49:45 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:49:55 <HairyDude> @type \f -> Monad.sequence . mapM f
07:49:55 <Heffalump> @type \f -> liftM concat . mapM f
07:49:57 <lambdabot>     Ambiguous occurrence `mapM'
07:49:57 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
07:49:58 <lambdabot>     Ambiguous occurrence `mapM'
07:49:59 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
07:50:09 <Heffalump> @type \f -> liftM concat . Control.Monad.mapM f
07:50:09 <HairyDude> @type \f -> Monad.sequence . Monad.mapM f
07:50:11 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m [a]) -> [a1] -> m [a]
07:50:12 <lambdabot> forall a b. (a -> [b]) -> [a] -> [[b]]
07:50:22 <HairyDude> aha
07:50:51 <HairyDude> Heffalump++
07:50:52 <cinimod> @seen bringert
07:50:53 <lambdabot> bringert is in #ghc and #haskell. I don't know when bringert last spoke.
07:51:04 <bringert> ni cinimod
07:51:09 <bringert> eh, hi
07:51:39 <cinimod> bringert: hi you have a version of quickcheck
07:51:47 <hpacheco> the functional dependency in the class ensures that instances for one argument a are unique...
07:51:52 <SamB> @pl (\x y -> setSym x =<< evalExpr y)
07:51:52 <lambdabot> (. evalExpr) . (=<<) . setSym
07:51:57 <cinimod> bringert: which finds more bugs than the version distributed with ghc
07:52:08 <hpacheco> I have referred that in the hpaste
07:52:12 <cinimod> bringert: what's its status?
07:52:21 <SamB> @pl (\y x -> setSym x =<< evalExpr y)
07:52:22 <lambdabot> (. setSym) . (>>=) . evalExpr
07:52:32 <cinimod> http://www.cs.chalmers.se/~bringert/darcs/QuickCheck
07:52:37 <lambdabot> Title: Index of /QuickCheck
07:52:46 <Heffalump> hpacheco: but it doesn't ensure that the argument a will always be an Int
07:52:59 <Heffalump> your definition claims to be able to take any a where SomeCheck a b exists
07:53:04 <Heffalump> but it can only handle Int
07:53:19 <bringert> cinimod: that has now moved to http://darcs.haskell.org/QuickCheck/
07:53:20 <lambdabot> Title: Index of /QuickCheck
07:53:29 <bringert> cinimod: it's an unreleased development version
07:53:34 <hpacheco> and it does it
07:53:48 <hpacheco> more instances, more patterns, it should be enough generic for that
07:53:57 <cinimod> bringert: it found a bug that the distributed version didn't
07:53:59 <bringert> cinimod: it's just missing some people with enough time to polish it to release quality
07:54:13 <bringert> cinimod: yeah, it has quite a few new features
07:54:26 <bringert> cinimod: btw, I didn't write it, koen did
07:54:35 <cinimod> bringert: ok I'm going to install and use
07:54:48 <cinimod> bringert: what polishing does it need?
07:55:23 <bringert> cinimod: testing by others, haddocking, maybe some general clean-up
07:55:56 <cinimod> bringert: ok I'll be testing. I'm not sure about the rest.
07:57:11 <HairyDude> @pointless  \f -> liftM concat . Control.Monad.mapM f
07:57:11 <HairyDude> @botsnack
07:57:11 <lambdabot> ((fmap join . Control . Monad) .) . mapM
07:57:11 <lambdabot> :)
07:57:12 <HairyDude> hrm, did I kill lambdabot?
07:57:19 <cinimod> bringert: thanks - talk later
07:58:28 <Heffalump> I think lambdabot has failed to parse the module namespacing . correctly
07:58:39 <Heffalump> @pl \f -> liftM concat . mapM f
07:58:40 <lambdabot> (fmap join .) . mapM
08:02:14 <hpacheco> Heffalump: ok, but is there any other way I could express this association?
08:02:18 <Heffalump> bringert: I'm using haskelldb and trying to take the result of an aggregate expression and calculate some new value with it (and then project that new value), but the types prevent me from doing so. Is there any reason why operators shouldn't be overloaded for any member of ExprC
08:02:29 <Heffalump> hpacheco: I'm not really sure what you're trying to acheive
08:02:34 <Heffalump> you may want to make test a member of the class
08:02:45 <Heffalump> then you can provide different implementations for different type parameters
08:03:07 <Heffalump> the idea of type classes is that the class members encapsulate the different behaviour for different types
08:03:14 <hpacheco> I want to fool the type checker, so that two types become equal
08:03:17 <Heffalump> a type class with no members is usually not very useful
08:03:32 <bringert> Heffalump: good question. I seem to remember that was some reason for that that had to do with SQL restrictions, but I wrote that stuff years ago.
08:04:10 <Heffalump> bringert: the reason for ExprAggr being separate (that you mention in your paper) is that they can only be used in projections (i.e. not restrict, insert etc, I guess)
08:04:12 <hpacheco> Heffalump: and need some class to represent that association
08:04:32 <bringert> Heffalump: good thing you read my old paper
08:04:33 <Heffalump> hpacheco: I'm still not quite sure what you actually want to do.
08:05:43 <Heffalump> bringert: ok. I might play with making the operators more general then
08:05:58 <bringert> Heffalump: please do
08:06:03 <Heffalump> As long as the result is still an ExprAggr, I don't think there'll be a problem.
08:06:20 <Heffalump> might need a different class, though, since I don't think that could be done with ExprDefault
08:06:22 <bringert> ExprDefault might be tricky though
08:06:27 <bringert> heh
08:06:29 <Heffalump> :-)
08:06:58 * SamB makes an typeclass for adding, that can only be invoked in type constraints
08:07:13 <hpacheco> Heffalump: my real problem is that I have types like (Either a b) and (Const a:+:Const b) x and say that they are equal
08:07:17 <Heffalump> btw, did you think much about folding in the subqueries into the main query where possible?
08:07:17 <hpacheco> where
08:07:41 <hpacheco> newtype Const b a = K {unK :: b}
08:07:45 <Heffalump> hpacheco: I don't know what you mean by saying the types are equal.
08:07:52 <Heffalump> Is your goal to have some kind of cast operator?
08:08:11 <hpacheco> in theory, they are the same type
08:08:26 <hpacheco> I need to create some type of relation
08:08:32 <hpacheco> that hacks it
08:09:32 <Heffalump> but what is the relation actually supposed to *DO*?
08:09:33 <syntaxfree> hpacheco: what does it mean for two types to be equal?
08:09:47 <Heffalump> you won't ever get the typechecker to treat two different types as interchangeable
08:10:41 <syntaxfree> you can however write a cast function.
08:11:03 <hpacheco> syntaxfree: say, a type a is of the same type as Const a
08:11:07 <syntaxfree> cast (Either x y) = (Const x :+: Const y)
08:11:20 <hpacheco> since they can represent the same domain of values
08:11:25 <hpacheco> yes I can
08:11:25 <syntaxfree> hpacheco: except it isn't. that's the whole point of type checking.
08:11:28 <GeeTux> hi bens
08:11:32 <hpacheco> but I need it at the type level
08:11:34 <syntaxfree> implicit casting is evil.,
08:11:53 <syntaxfree> you want implicit casts. Most modern languages won't support that.
08:12:02 <hpacheco> not evil, you are completely sure they represent the same thing
08:12:16 <hpacheco> although different for haskell of course
08:12:16 <syntaxfree> how would the compiler enforce that?
08:12:30 <hpacheco> not enforce... implicitely translate
08:12:37 <hpacheco> that's what I'm trying to achieve
08:13:09 <syntaxfree> well, the type system is meant for precisely the opposite thing.
08:13:22 <syntaxfree> In a way, a function that works on (a,b) could also work on Either a b
08:13:35 <syntaxfree> the type system enforces the distinction.
08:13:46 <syntaxfree> If you want distinction-less programming just use tuples.
08:14:18 <hpacheco> but those types are not the same
08:14:28 <hpacheco> they represent different things
08:14:35 <syntaxfree> in what sense is Either a b different from (a,b)?
08:14:44 <hpacheco> at the value level
08:14:45 <syntaxfree> a lossless, invertible cast function can be trivially written.
08:14:59 <hpacheco> but for the types I presented
08:15:03 <hpacheco> it is
08:15:38 <hpacheco> it is just a matter of functor lifting
08:15:52 <syntaxfree> hpacheco = protontorpedo?
08:15:56 <hpacheco> of course I do not complain about they being different to haskell:P
08:15:57 <syntaxfree> @protontorpedo
08:15:57 <lambdabot> where was haskell during th internet boom?
08:16:03 <hpacheco> nope, new here
08:16:12 <syntaxfree> I think you're a troll.
08:16:22 <syntaxfree> I won't give you any more attention.
08:16:24 <Heffalump> syntaxfree: really? How would you turn (a, b) into Either a b?
08:16:42 <hpacheco> he wouldn't without loosing information
08:16:43 <syntaxfree> Heffalump: ah, of course. Either a b is the tycon.
08:17:02 <syntaxfree> imagine I have data Two a b = Two a b
08:17:03 <syntaxfree> :)
08:17:08 <Heffalump> :-)
08:17:45 <syntaxfree> @quote troll
08:17:45 <lambdabot> dibblego says: using logic in imperative programming language channels is generally considered trolling
08:17:46 <hpacheco> and it is reasonable to want them to represent the same thing:P
08:18:00 <syntaxfree> hpacheco: sure. Use tuples.
08:19:37 <hpacheco> got to go, but believe me I have a point
08:19:39 <Heffalump> I wonder if the system FC stuff provides something to let hpacheco do this stuff.
08:19:48 <hpacheco> thanks the same
08:19:56 <Heffalump> but from a source point of view, I think you are completely missing the point of types.
08:20:08 <syntaxfree> @quote tuple
08:20:09 <lambdabot> ghc says: Illegal unboxed tuple type as function argument
08:20:24 <bens__> ugh, pardon my dodgy connection.
08:27:26 <olsner_> @quote
08:27:26 <lambdabot> Klauso says: haha, this bot seems to have many features
08:36:21 <Saizan> second reverse . foldl (\(q,r) b -> if head r then (True:q,tail $ add (r++[b]) ys) else (False:q, tail r++ [b])) ([True],tail $ add a ys) $\ b
08:36:31 <Saizan> ?pl second reverse . foldl (\(q,r) b -> if head r then (True:q,tail $ add (r++[b]) ys) else (False:q, tail r++ [b])) ([True],tail $ add a ys) $ b
08:36:33 <lambdabot> second reverse (foldl (uncurry (ap (ap . (ap .) . ap ((.) . if' . head) . (. ((tail .) . flip flip ys . (add .) . (. return) . (++))) . (.) . (,) . (True :)) ((. ((. return) . (++) . tail)) . (.) . (
08:36:33 <lambdabot> ,) . (False :)))) ([True], tail (add a ys)) b)
08:40:31 <opqdonut> haha ":)"
08:40:48 <opqdonut> @quote
08:40:48 <lambdabot> adept says: Tried to co-read and co-understand comonads, but got co-re dump
08:40:57 <encryptio> > (reverse . dropWhile (' '==) . reverse . dropWhile (' '==)) "  test  "
08:40:59 <lambdabot>  "test"
08:41:17 <dmhouse> ?pl \x -> 8:x
08:41:17 <lambdabot> (8 :)
08:41:32 <encryptio> lol,
08:41:50 * dmhouse tries to think of a suitable haircut character
08:42:08 <encryptio> > (iterate (reverse . dropWhile (' '==)) !! 2) "  test  "
08:42:09 <lambdabot>  Couldn't match expected type `[a]'
08:42:29 <encryptio> > ((iterate (reverse . dropWhile (' '==))) !! 2) "  test  "
08:42:29 <lambdabot>  Couldn't match expected type `[a]'
08:42:59 <dmhouse> > (iterate (reverse . dropWhile (' '==)) "  test  ") !! 2
08:43:00 <lambdabot>  "test"
08:43:14 <encryptio> ah.
08:43:18 <dmhouse> > filter (/= ' ') "  test  "
08:43:20 <lambdabot>  "test"
08:43:32 <dmhouse> Oh, there's a reverse, too, never mind.
08:43:58 <encryptio> chop from front, reverse, chop from front, reverse - trim left and right spaces
08:44:55 <dmhouse> Yeah, I'd normally write that as trim = reverse . dropWhile isSpace . reverse . dropWhile isSpace, but it's the same general idea.
08:45:02 <dmhouse> (Using iterate is a bit obfuscated.)
08:45:26 <opqdonut> now for a solution with fix :)
08:45:32 <encryptio> yeah, that's what my first one was, minus the isSpace
08:46:21 <dmhouse> opqdonut: it's not recursive :P
08:46:27 <dmhouse> Unless...
08:46:45 <encryptio> mainly i'm trying to find a short way to write that point-free
08:48:04 <oerjan> > (!! 2) . iterate (reverse . dropWhile (' '==)) "  test  "
08:48:05 <lambdabot>  Couldn't match expected type `a -> [a1]'
08:48:11 <oerjan> er
08:48:19 <oerjan> > ((!! 2) . iterate (reverse . dropWhile (' '==))) "  test  "
08:48:20 <lambdabot>  "test"
08:48:39 <opqdonut> maybe using group?
08:48:51 <opqdonut> or groupBy actually
08:49:25 <Saizan> let trim = join (.) $ reverse . dropWhile isSpace in trim "  test  "
08:49:29 <Saizan> > let trim = join (.) $ reverse . dropWhile isSpace in trim "  test  "
08:49:30 <lambdabot>  "test"
08:49:49 <encryptio> i was thinking join, but couldn't wrap my head around a decent usage
08:50:27 <oerjan> @type join
08:50:29 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
08:50:30 <dmhouse> > let trim xs = let xs' = reverse $ dropWhile isSpace xs in if isSpace (head xs) then trim xs' else reverse xs' in trim "  hello  "
08:50:31 <lambdabot>  "hello"
08:50:33 <dmhouse> Now we can use fix! :)
08:50:48 <dmhouse> > let trim = fix \xs -> let xs' = reverse $ dropWhile isSpace xs in if isSpace (head xs) then trim xs' else reverse xs' in trim "  hello  "
08:50:49 <lambdabot>  Parse error
08:51:00 <dmhouse> > let trim = fix (\xs -> let xs' = reverse $ dropWhile isSpace xs in if isSpace (head xs) then trim xs' else reverse xs') in trim "  hello  " -- pretty boring, though.
08:51:01 <lambdabot>  Couldn't match expected type `[Char] -> [Char]'
08:51:11 <dmhouse> Gah. Sorry, It's coming.
08:51:31 <dmhouse> > let trim = fix (\trim' xs -> let xs' = reverse $ dropWhile isSpace xs in if isSpace (head xs) then trim' xs' else reverse xs') in trim "  hello  " -- pretty boring, though.
08:51:33 <lambdabot>  "hello"
08:52:10 <oerjan> @type join (.)
08:52:12 <lambdabot> forall b. (b -> b) -> b -> b
08:52:34 <encryptio> @pl \x y -> x == y && x == ' '
08:52:34 <lambdabot> ap (flip . ((&&) .) . (==)) (' ' ==)
08:52:38 <encryptio> argh
08:53:01 <oerjan> > join (.) (+1) 0
08:53:02 <lambdabot>  2
08:53:26 <oerjan> heh
08:54:03 <encryptio> > (concat . tail . init . groupBy (\x y -> x == y && x == ' ')) "  this is a test  "
08:54:05 <lambdabot>  "this is a test"
08:54:28 <encryptio> broken if there aren't spaces though.
08:54:37 <oerjan> encryptio: that will not work if the string doesn't actually have spaces at the end
08:54:55 <Saizan> or at the start
08:55:01 <oerjan> *ends
08:55:52 <encryptio> > tails [1..4]
08:55:53 <lambdabot>  [[1,2,3,4],[2,3,4],[3,4],[4],[]]
08:57:05 <encryptio> :t ap
08:57:07 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:57:14 <jfredett> are array entries mutable in haskell?
08:57:26 <Heffalump> depends on the array type
08:57:28 <encryptio> in mutable arrays, yes
08:57:28 <Heffalump> there are many
08:58:21 <jfredett> okay- as long as its possible, I was just considering methods of implementing an imperative language w/ destructive updates in Haskell
08:58:46 <jfredett> I figured one could use an array- and allocate a slot in the array for the initial variable's value
08:58:49 <SamB> yeah, you can do that
08:58:59 <jfredett> i'm sure there are better ways
08:59:04 <Heffalump> you might find you have to resize the array sometimes, though
08:59:05 <jfredett> but thats just the first that came to mind
08:59:07 <SamB> I meant, write a language like that
08:59:19 <SamB> see for example pugs ;-)
08:59:34 <jfredett> Well, I knew it was _possible_
08:59:42 <jfredett> i was just pondering how to do it
08:59:49 <jfredett> I'm working on a CAS
08:59:50 <Heffalump> that's a compiler, not an interpreter, though
08:59:54 <SamB> well, it depends on the language's model ;-)
09:00:00 <SamB> Heffalump: I thought it did both?
09:00:05 <Heffalump> oh, maybe
09:00:12 <oerjan> IORefs are the most direct way of doing mutable variables
09:00:18 <jfredett> which will need to have some destructive capablities
09:00:33 <encryptio> IOArrays are close too. =p
09:00:37 <SamB> jfredett: okay, you'll need to use monadic style, or something like that
09:00:49 <jfredett> cool
09:01:11 <jfredett> it's not particularly important, I'm starting by implementing all the back end math stuff first-
09:01:14 <emu> one thing i've been wondering is: if i transliterated some C code into the equivalent using Ptrs and other FFI stuff, how different would be the performance.
09:01:57 <jfredett> probably a little worse than just using straight C
09:03:35 * jfredett is afk
09:07:58 <SamB> emu: also, Haskell does not support structs
09:08:54 <SamB> and the code would be longer
09:08:54 <encryptio> are there any c-like languages with a type system like haskell's?
09:09:21 <SamB> so... don't try to translate long passages of C to the exact Haskell equivalent ;-)
09:09:58 <SamB> instead, translate it into something better, little bits of which may be equivalent.
09:10:00 <pejo> encryptio, you could have a look at Cyclone
09:11:41 <hpaste>  dgoodlad pasted "tuples" at http://hpaste.org/303
09:12:18 <SamB> I once translated a most of a C program to a Haskell program in the monad "StateT (Maybe Char) IO"
09:12:18 <dgoodlad> ^^ I'm trying to learn Haskell, and am doing some exercises from a tutorial that I found... I just wrote the above, but feel like I'm missing some important abstraction
09:12:23 <dgoodlad> anyone care to have a quick look?
09:12:32 <dgoodlad> my code works but it feels really ugly to me
09:12:37 <SamB> ... and it went faster ;-)
09:12:38 <encryptio> SamB: sweet.
09:13:01 <SamB> ... of course, the program might as well have been written that way in the first place ;-)
09:13:04 <encryptio> *badtab
09:13:10 <encryptio> pejo: sweet.
09:14:09 <SamB> (it was the libgc-using standard C implementation of unlambda)
09:14:11 <astrolabe> dgoodlad: It looks ok to me
09:14:50 <dgoodlad> astrolabe: hmm I just feel like I should be able to express, for example, the tuple4 method more succinctly without specifying all 4 constructors
09:15:01 <dgoodlad> s/method/function/
09:15:05 <astrolabe> dgoodlad: you could shorten it a little by collecting the Nothing cases together.
09:15:20 <dgoodlad> yeah, that's what I want to do, but am unsure of how to actually express that
09:15:24 <oerjan> dgoodlad: variable length records is a weak point of haskell
09:15:46 <olsner_> as anyone been playing with compiling imperative languages into GHC core?
09:15:54 <astrolabe> Start with the Just cases, then for the remainder say    tuple4 _ = Nothing
09:16:06 <dgoodlad> astrolabe: ahh of course, forgot about the _ completely
09:16:15 <dgoodlad> astrolabe: that cleans it up a bit :)  thanks
09:16:26 <olsner_> *has
09:16:52 <dgoodlad> oerjan: I don't want to know about weak points yet, I just started learning, don't push me away! hehe
09:17:08 <oerjan> er, okay :)
09:19:14 <Saizan> ?pl (\(q,r) b -> (if last r then (True:) *** rem else (False:) *** init) (q,(b:r)))
09:19:15 <lambdabot> uncurry (ap ((.) . flip (flip if' ((True :) *** rem) . last) ((False :) *** init)) . (. flip (:)) . (.) . (,))
09:20:55 <Saizan> ?pl (\(q,r) b -> (q,b:r))
09:20:56 <lambdabot> uncurry ((. flip (:)) . (.) . (,))
09:21:10 <oerjan> SamB: Unlambda really calls for a ContT in there
09:24:29 <Heffalump> SamB: why Maybe Char?
09:25:42 <chessguy> i don't understand why the records thing is so hard to fix. i know there's backwards-compatibility issues, but why not *add* a different record structure, and let the users of the libraries choose
09:26:06 <Heffalump> it's not obvious what a new one should be
09:26:12 <Heffalump> and what punctuation would you use? :-)
09:26:45 <chessguy> so add several. the good ones will last, the bad ones won't
09:27:22 <DRMacIver> Heffalump: Add a literal overloading type class for record? :)
09:27:27 <astrolabe> Wouldn't they all last once they are used?
09:27:52 <chessguy> astrolabe, well, by 'last', i mean 'enjoy significant use'
09:27:55 <oerjan> Heffalump: Unlambda's only state is the last read character from stdin, which may be undefined in the beginning and after eof
09:28:06 <pejo> chessguy, removing things from a language is quite hard.
09:28:26 <chessguy> pejo, i haven't suggested to remove anything
09:29:10 <astrolabe> Having seldom used redundant syntax in a language is nasty.
09:29:17 <chessguy> so what if existing clients use a deprecated structure. leave it in the language, and those who are in the know will use the higher quality version
09:29:21 <SamB> @hoogle Int -> [a] -> [a]
09:29:21 <lambdabot> Prelude.drop :: Int -> [a] -> [a]
09:29:22 <lambdabot> Prelude.take :: Int -> [a] -> [a]
09:29:22 <lambdabot> Control.Parallel.Strategies.parBuffer :: Int -> Strategy a -> [a] -> [a]
09:29:40 <SamB> @pl concat . replicate
09:29:40 <lambdabot> join . replicate
09:30:01 <olsner_> @type replicate
09:30:04 <lambdabot> forall a. Int -> a -> [a]
09:30:09 <Heffalump> you create a huge mess for people that need to write language tools, or maintain existing code, or interface with code
09:30:13 <olsner_> > replicate 3 2
09:30:20 <lambdabot>  ghc-6.6: could not execute: gcc
09:30:29 <balodja> gcc? :)
09:30:37 <Heffalump> it's presumably going -fvia-C
09:30:42 <Heffalump> > 1
09:30:42 <lambdabot>  ghc-6.6: could not execute: gcc
09:30:45 <Heffalump> oh dear.
09:30:51 <astrolabe> Also, it is more painful to learn the language.
09:30:58 <SamB> chessguy: I think the issue is that we need the syntax back in order to have a new record system...
09:31:05 <HairyDude> where's the darcs repo for the unix-2.0 library?
09:31:10 * DRMacIver doesn't believe in backwards compatibility. :)
09:31:24 <HairyDude> the current release version gives a link error
09:31:25 <SamB> chessguy: where else are we going to get the syntax we need?
09:31:26 <chessguy> bah, why can't we use different syntax?
09:31:30 <DRMacIver> Old code should be aggressively and maliciously broken where it allows the option for improving new code.
09:32:01 <ndm> DRMacIver: are you suggesting that all useful tools written by academics get burned upon release?
09:32:18 <ndm> since typically there is no requirement for someone to maintain them otherwise
09:32:23 <DRMacIver> I'm not sure how my suggestion got interpreted as that. :)
09:32:25 <SamB> I'd propose a program that would upgrade you to the new syntax automatically
09:32:42 <ndm> academic code usually gets written, released and abandoned
09:32:54 <SamB> we don't want to use bitrotted code anyway
09:32:58 <ndm> since there is no funding to maintain something after, and further work is not "new" and "exciting"
09:33:05 <SamB> and, if we had a tool, that'd be fine anyway
09:33:08 <ndm> and more importantly, not publishable
09:33:08 <DRMacIver> ndm: Short version? Yes. If it doesn't get maintained, it's probably not being used. Therefore I don't care if it gets broken.
09:33:23 <ndm> DRMacIver: what if it is being used, or would be used if it worked (Hat)
09:33:39 <SamB> ndm: then it needs a maintainer anyway
09:33:42 <DRMacIver> Then some of its users should be putting in the effort to make it work. :)
09:33:51 * Igloo suspects more academic code gets written and the not released
09:33:59 <DRMacIver> Unmaintained code is a disaster waiting to happen.
09:34:08 <SamB> and, this record system is simply mediocre
09:34:18 <ndm> DRMacIver: but thats not always feasible - and do they want to spend their limited time running after a forward moving language, or improving their tool
09:34:24 * ndm agrees with Igloo
09:34:32 <pejo> DRMacIver, breaking it isn't the solution though.
09:34:37 <SamB> ndm: well, what do you think of the idea of automatic upgrading?
09:34:42 <ndm> I think Haskell Workshop should reject every paper who has source code which isn't on Hackage
09:34:46 <SamB> also we need a hackage-qa team
09:34:51 <ndm> SamB, usually doesn't work - if it did, it would be great
09:35:15 <SamB> ndm: what's the problem that would make it not work?
09:35:22 <Heffalump> ndm: I think mandating hackage is unfair.
09:35:40 <DRMacIver> pejo: Yes it is. If you don't break it then you will be stuck with it. This is a far worse problem.
09:35:44 <Heffalump> But "published online under a license that permits distribution" would be reasonable.
09:35:46 <ndm> Heffalump: for hackage read "publically available and downloadable"
09:36:00 <SamB> how about a darcs repo with an email address for patches?
09:36:03 <ndm> i don't think permitting distribution is necessary, just availability
09:36:03 <Igloo> Why is hackage particularly unfair, OOI?
09:36:04 <SamB> or hackage
09:36:15 <xs> unmaintained code is going to have more problems than just the underlying language changing. i won't use unmaintained code. it's a waste of time.
09:36:17 <Heffalump> well, the project may not fit within those confines
09:36:23 <Heffalump> what about patches to GHC, say?
09:36:39 <ndm> you don't have to give away your code, but you do have to show that your code works - so that people can check it and reimplement it from your paper if they choose
09:36:42 <SamB> so, publicly available darcs or svn repo?
09:36:43 <Igloo> Ah, I see
09:37:01 <SamB> or *shudder* tarball?
09:37:10 <ndm> SamB, all hackage gives is a tarball
09:37:17 <HairyDude> is it even possible to get unix-2.0 separately from ghc?
09:37:18 <SamB> ndm: yeah. it's a pain.
09:37:18 <Heffalump> also, I dislike the idea of forcibly linking two aspects of the community like that
09:37:33 <ndm> hackage is merely the way libraries/tools should be distributed
09:37:40 <SamB> well, some papers might not actually be about a library...
09:37:46 <Heffalump> indeed.
09:37:54 <ndm> i said those that have code should make the code available
09:37:58 <SamB> ah.
09:38:01 <Igloo> HairyDude: It's in hackage
09:38:03 <SamB> so, no vaporware.
09:38:08 <ndm> if its not a code paper, or if its a trick or somewhere where the code is in the paper, then thats fine
09:38:09 <Heffalump> ndm: agreed, but by consent, not by mandate (re hackage being the way things should be distributed)
09:38:28 <HairyDude> Igloo: HEAD as well?
09:38:30 <SamB> but please no tla!
09:38:31 <Heffalump> ndm: of course, now you have to define that. Though I guess you could just let the PC exercise their judgement.
09:38:34 <ndm> Heffalump: yes, i just meant somewhere public
09:38:39 <Igloo> HairyDude: eh?
09:38:46 <HairyDude> http://article.gmane.org/gmane.comp.lang.haskell.libraries/6797
09:38:48 <lambdabot> Title: Gmane -- Mail To News And Back Again
09:38:51 <ndm> it would be a nightmare to figure out the rules
09:38:58 <HairyDude> it seems the bug I have is fixed, but not in the version I have
09:39:02 <HairyDude> which I got from hackage
09:39:19 <ndm> but just a general "papers which discuss source code should make the source code available to the world"
09:39:24 <Igloo> HairyDude: Then you don't want unix 2.0, surely?
09:40:02 <HairyDude> Igloo: erm, why not?
09:40:17 <HairyDude> Igloo: it's the version xmonad needs in any case
09:40:27 <Igloo> HairyDude: Because you just said that 2.0 has the bug you need fixed
09:40:33 <HairyDude> though somehow xmonad manages to cope
09:40:38 <Igloo> HairyDude: http://darcs.haskell.org/packages/unix/ ought to be compilable with GCH 6.6.1, anyway
09:40:39 <lambdabot> Title: Index of /packages/unix
09:41:27 <ndm> would be interesting to see how many papers at ICFP/HW have public source code
09:43:13 <HairyDude> Igloo: aha, looks likely
09:46:43 <KOC> I always see people do ?src here -- where can I find that info online?
09:47:05 <Heffalump> ndm: I was just seeing if I could figure it out for the HW submissions
09:47:41 <ndm> Heffalump: how many submissions are there (if you can say)
09:47:52 <Heffalump> I'm not sure if I should, so I won't.
09:48:32 <HairyDude> Setup.hs: cannot satisfy dependency directory-any
09:48:36 <ndm> fair enough, probably best to err on the side of caution
09:48:47 <ndm> i guess at the acceptance time you'll say how many papers there were
09:49:06 <ndm> if at that time you could say how many submissions included public source code, that would be cool
09:49:09 <Heffalump> it always goes in the PC report
09:49:14 <Heffalump> the PC chair report, that is
09:49:17 <ndm> yeah
09:49:25 <ndm> but not the source code statistic
09:49:58 <Heffalump> I'll try and remember to suggest it. But you could always email her yourself and do so.
09:50:22 <HairyDude> Igloo: seems like it only works with the latest version of base
09:50:44 <HairyDude> I take it compiling base separately from ghc is actually supported?
09:51:06 <HairyDude> (it came up with an error and told me to report it as a bug)
09:51:16 <Igloo> HairyDude: Oh, true, you'd have to change the dependencies of the package back to how they were before the base breakup
09:51:32 <Igloo> You don't want to compile base yourself
09:52:07 <HairyDude> grumble grumble grumble
09:52:11 <HairyDude> :)
09:52:32 * SamB wonders why ghci is waiting for a condition
09:53:10 <KOC> oh hey I found it; there's a "source code" link in the upper left of this module page
09:58:27 <HairyDude> Igloo: ah, seems my ghc is 6.6 not 6.6.1
10:04:00 <HairyDude> well there's a libreadline4 compatibility rpm, but is there a corresponding deb?
10:04:04 <HairyDude> or even tarball
10:04:35 <HairyDude> suppose I could alien it
10:38:45 <apfelmus> int-e: ping
10:52:04 <int-e> apfelmus: pong
10:52:16 <apfelmus> hi :)
10:52:50 <apfelmus> i'm looking for a proof that
10:53:16 <apfelmus> lazy evaluation always takes less reduction steps than eager evaluation
10:53:28 <basti_> always less or the same I'd say
10:53:38 <apfelmus> so far, i've been unable to locate one
10:53:48 <jfredett> hmm, are there any CAS's already written in Haskell? I'm not particularly sure how to start--
10:53:53 <Heffalump> CAS?
10:53:58 <jfredett> Computer Algebra System
10:54:00 <apfelmus> basti_: err, of course.
10:54:03 <jfredett> like Maple or Mathematica
10:54:19 <apfelmus> int-e: do you have an idea/hint/reference?
10:54:38 <beelsebob_> there was a discussion about CAS systems an the mailing list a while back
10:54:47 <apfelmus> jfredett: there's DoCon
10:54:53 <apfelmus> @google DoCon haskell
10:54:54 <Korollary> apfelmus: There was a paper titled More Speed Less Haste or something like that. Maybe it has something similar.
10:54:55 <lambdabot> http://www.haskell.org/docon/
10:54:55 <lambdabot> Title: DoCon the Algebraic Domain Constructor
10:55:37 <jfredett> hmm, worth a look-
10:55:47 <dfranke> dzen is great.
10:55:58 <dfranke> I've been using big, bloated WMs for so long just for want of that simple feature.
10:56:13 <jfredett> ayup...
10:56:35 <Heffalump> http://web.comlab.ox.ac.uk/oucl/work/geraint.jones/morehaste.html, but I don't think that solves apfelmus's problem
10:56:37 <lambdabot> Title: Research Highlights - More Haste Less Speed
10:56:45 <apfelmus> yeah, i know that paper
10:57:20 <apfelmus> it shows that there are (may be) problems for which lazy evaluation allows to formulate asymptotically strictly better algorithms than eager
10:57:31 <dmhouse> dfranke: what does it do>
10:57:36 <dmhouse> s/>/?/
10:58:16 <dfranke> dmhouse, puts whatever it reads from stdin onto a status bar across the top or bottom of the screen.  Updates the contents when it reads a newline.
10:58:41 <Korollary> apfelmus: Ok. I mentioned it because it might contain a similar proof if there's one.
10:59:18 <apfelmus> Korollary: unfortunately not. "More haste less speed" constructs a concrete lazy algorithm
10:59:35 <dmhouse> dfranke: what do you use it for?
10:59:36 <apfelmus> it's in fact a follow-up paper to "pure & impure lisp" (or similar)
11:00:09 <dfranke> dmhouse, time, mail check, ACPI status.
11:00:22 <dfranke> in xmonad.
11:00:26 <apfelmus> this one establishes a lower bound on the time for the particular problem
11:00:32 <int-e> apfelmus: I think that the reductions performed by lazy evaluation are a subset of those performed by strict evaluation - but identifying the corresponding reductions looks tedious. I know of no complete proof.
11:01:42 <apfelmus> int-e: yes, that's what is commonly assumed. the technical problem is too keep track of reductions that don't yet exist but show up during execution
11:01:47 <apfelmus> *to
11:01:51 <apfelmus> *to keep
11:02:05 <dfranke> apfelmus, that doesn't make sense to me.  You can always simulate lazy evaluation in a strict language by explicit thunks.
11:02:37 <apfelmus> dfranke: not quite. either you loose memoization or you have to use side effects
11:02:51 <jfredett> dfranke, that among other things, of course. My dzen bar happens to also draw a neat little fish swimming around to indicate the CPU Load... :)
11:03:07 <jfredett> the things you can do with some ascii art and way to much time on your hands...
11:03:46 <dfranke> apfelmus, oh, ok.  So you're referring strictly (in the vernacular sense; pun not intended) to purely functional languages then.
11:03:47 <ddarius> apfelmus: For the pure lambda calculus, it's pretty clear that lazy evaluation takes less reduction steps, you should be able to easily prove it by induction.
11:03:56 <ddarius> Call-by-name doesn't necessarily.
11:05:24 <apfelmus> int-e: actually, i found a proof, but it's rather strange.
11:05:24 <apfelmus> http://www.ps.uni-sb.de/~jan/publications/da.pdf investigates up a concurrent lambda calculus and gets the proof as an unexpected side result.
11:05:38 <ddarius> apfelmus: Just prove it yourself.
11:05:42 <apfelmus> ddarius: oh? it's not clear for me :)
11:06:13 <apfelmus> by induction on the structure of the lambda terms?
11:06:23 <ddarius> I believe you could do it that way.
11:06:25 <dfranke> jfredett, I'd need eight fish, and that would take too much space :-)
11:06:54 <apfelmus> ddarius: the problem is that lazy and eager quickly do very different things. you can't run them side-by-side
11:07:10 <ddarius> So?  You don't need to run thme.
11:07:27 <ddarius> It's like an abstract interpretation with the domain of number of reductions.
11:07:59 <apfelmus> that number is not compositional
11:08:19 <apfelmus> numredux(N M) =/= numredux(N) + numredux(M)
11:08:28 <int-e> apfelmus: you need to consider the actual reduction graph I think, because sharing is essential for this. you can annotate each node with the corresponding set of strict reductions and show that every lazy reduction splits such a set into disjoint subsets of that set (and possibly some leftover set). It's still tedious, but it looks doable. What it would exploit is that the reductions of strict evaluation are local - in (A B), no reduction in A 
11:09:36 <olsner_> int-e: looks like you were cut off after "no reduction in A ..."
11:09:53 <int-e>  no
11:09:55 <int-e> reduction in A affects anything in B.
11:10:16 <apfelmus> int-e: the problem is somehow that there is no common reduction graph for strict and lazy
11:10:49 <apfelmus> at least, not at a single point in "time"
11:11:25 <ddarius> Perhaps induction on the contexts.  You should still be able to convince yourself with an informal induction on the structure of the terms.
11:12:54 <int-e> apfelmus: you can do a few steps of lazy evaluation and then switch to strict evaluation (with a provision for the shared nodes of course)
11:13:25 <apfelmus> and do induction on that?
11:13:30 <int-e> apfelmus: and the claim would be that no matter when you switch, you'd never get any additional reduction step.
11:13:34 <int-e> yes.
11:14:09 <hpaste>  HairyDude pasted "Bloody monomorphism restriction" at http://hpaste.org/304
11:14:13 <int-e> the sets that I wanted to annotate the nodes with are exactly the strict evaluation reduction steps that you'd still need.
11:15:16 <chessguy> @unpl concatMapM = (liftM concat .) . mapM
11:15:16 <lambdabot> concatMapM d g = liftM concat (mapM d g)
11:15:48 <ddarius> apfelmus: Essentially #redux(x) = (how much effort to reduce what is bound to x but only counted once for all occurences of x,0), #redux(\x.E) = (0,0), #redux(M N) = (fst #redux(M) + 1,snd #redux(M) + #redux(N) + 1)
11:15:52 <basti_> int-e:  somefunction (error "error") endlessloop might need more lazy evaluations than eager evaluations
11:16:11 <ddarius> Then you take not of the fact that x can not occur in a lambda term.
11:16:30 <apfelmus> basti_: error = endlessloop for us
11:16:41 <ddarius> and fst #redux(x) == #redux(N) for the appropriate N
11:16:42 <basti_> hmm, error is a special endless loop
11:16:59 <basti_> but still, you can replace "endlessloop" with something that needs more evaluations than error
11:17:03 <basti_> like (1+1)
11:17:10 <ddarius> Use a monadic fold using the state monad, and you're pretty much done.
11:17:34 <basti_> you might, however, not allow error and the likes
11:17:50 <int-e> basti_: I didn't consider errors, only non-termination.
11:18:01 <nomeata> @seen dons
11:18:01 <lambdabot> I saw dons leaving #xmonad and #haskell 1d 9h 41m 55s ago, and .
11:18:32 <basti_> as apfelmus remarked, error in haskell is a special endless loop which makes the RTS fail with a message
11:18:34 <ddarius> basti_: When you throw in exceptions, it can actually switch.
11:18:51 <ddarius> basti_: See Filinksi's Symmetric Lambda Calculus
11:18:57 <basti_> o.o
11:19:32 <apfelmus> int-e: hm. doesn't the induction still have the problem that the strict end before the switch is very different from the strict end after the switch?
11:19:46 <ddarius> (\x.E)(throw X) takes less reductions in a strict language than in a non-strict one.
11:19:58 <nomeata> @lambdabot
11:19:59 <lambdabot> Unknown command, try @list
11:20:45 <apfelmus> hm maybe not
11:20:58 <ski> (ddarius : what can switch ?)
11:21:24 <ddarius> ski: Whether a lazy language takes more or less reductions than an eager one.
11:21:42 <ski> mhm
11:21:53 <ski> and that's related to SLC ?
11:22:59 <ddarius> Filinski's argues that one of the benefits of normal order evaluation (that it will always terminate if there is a way to terminate) is due to our asymetric view of the lambda calculus.
11:23:10 <nomeata> hi. can you access lambdabotâ€™s darcs?
11:23:21 <ddarius> @version
11:23:21 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
11:23:21 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
11:23:22 <ski> ddarius : yes .. i think that could be true
11:23:33 <hpaste>  gattocarlo pasted "override_redirect" at http://hpaste.org/305
11:23:34 <ddarius> http://www.cse.unsw.edu.au/~dons/lambdabot
11:24:08 <Saizan> asymmetric in what sense?
11:24:12 <ski> (i suspect it is also probably related to free copying of values, but not of continuations)
11:24:16 <ddarius> Well, if lambdabot can't even connect to it, then probably no one can.
11:24:40 <ddarius> Saizan: Favoring values over continuations.
11:24:49 <ski> Saizan : well, e.g. the "minus" connective isn't present
11:25:15 <ski> ((converse ?) dual of implication)
11:28:03 <apfelmus> int-e: i think the proof works out.
11:28:04 <apfelmus> assume a top-level N M. if N is a redex, it doesn't really matter if we first reduce it one step and then eval M or whether we do it the other way round.
11:28:04 <apfelmus> assume (\x.N') M. then, the only trick is that N' may not mention x at all which gives less reduction steps
11:28:49 <apfelmus> the key property is probably that when reducing N M, the part M will be the next inner redex
11:30:09 <apfelmus> the proof gives even more
11:31:36 <apfelmus> in any reduction sequence made out of eager (innermost leftmost) and lazy (outermost leftmost) steps, we can exchange any eager step with a lazy step.
11:31:45 <apfelmus> and won't use more time
11:33:11 <bos> @users
11:33:11 <lambdabot> Maximum users seen in #haskell: 328, currently: 324 (98.8%), active: 43 (13.3%)
11:33:20 <bos> wow, we teh busy
11:49:00 <SamB> hmm, what'
11:49:08 <SamB> s the nearest C++ equivalent of newtype?
11:49:34 <basti_> #define ?
11:49:39 <slowriot> hmm... I can't think of anything that comes close.
11:49:45 <nomeata> @ask dons I cannot darcs send to the lambdabot repo right now (seems to be down). Can you send me lambdabot message when it is back up, so that I do not forget about that patch?
11:49:45 <lambdabot> Consider it noted.
11:51:09 <slowriot> You could do it, but rather than using some language feature like "newtype" you would have to use some sort of hierarchical structure with abstract and concrete classes.
11:53:20 <HairyDude> newtype is like typedef isn't it? except that C isn't strongly typed
11:53:42 <HairyDude> or is typedef more like type
11:53:50 <slowriot> yeah
11:53:56 <edwardk> is there an alternate link for the FFI information? http://www.cse.unsw.edu.au/~chak/haskell/ffi/ seems to be down at the moment
11:54:38 <slowriot> typedef just gives another name to an existing type.
11:54:59 <edwardk> typedef is like haskell's 'type' which just declares an alias for an existing type
11:55:27 <edwardk> type Foo = Bar; they become interchangeable just like the c typedef
11:57:01 <HairyDude> I suppose newtype Foo = Foo { bar :: Baz } is kind of like typedef struct { Baz bar; } foo
11:57:11 <slowriot> I'm trying to learn haskell. Can anyone reccomend some good learning projects? My usual approach, solving problems on the sphere online judge, doesn't seem to be working too well.
11:57:11 <HairyDude> s/foo/Foo/
11:58:09 <slowriot> HairyDude: Yeah, I think that would do the trick.
11:59:00 <slowriot> Would solving ICFP contest problems be a good starting point?
11:59:17 <hpaste>  gattocarlo pasted "override_redirect new version" at http://hpaste.org/306
12:00:27 <HairyDude> then of course instead of frotz = Foo quux you do Foo * frotz = malloc(sizeof(Foo)); frotz->bar = quux;
12:00:33 <HairyDude> a mere matter of syntax ;)
12:02:34 <int-e> HairyDude: now you created a copy. the newtype Foo 'constructor' will be a nop at runtime.
12:03:59 <HairyDude> okay then, memcpy(&frotz->bar, quux, sizeof(*quux))
12:07:06 <HairyDude> of course we can replace &frotz->bar with frotz, cos memcpy isn't type safe
12:07:20 <edwardk> newtype doesn't actually incur any runtime overhead at all
12:07:27 <HairyDude> yes
12:07:44 <balodja> @help free
12:07:45 <lambdabot> free <ident>. Generate theorems for free
12:08:07 <balodja> hm, how to use this? :)
12:08:09 <Heffalump> @free (x -> x) -> (x -> x -> x)
12:08:09 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
12:08:13 <edwardk> its designed to be free, it just lets the compiler distinguish between say an Int and say, a newtype GF32 = GF32 Int, so you could define a separate Num instance, etc. by the time the compile is over there is no 'tag' or struct residue at all
12:08:18 <Heffalump> not like that, apparently..
12:08:18 <int-e> HairyDude: it should really be a cast. something like (Foo *) &quux
12:08:51 <fasta> Cannot match a monotype with `forall s a (chain :: * -> * -> *) (m :: * -> *). <- this is what changed in GHC about half a year ago, right?
12:09:57 <fasta> I am using a list in a pattern binding holding two elements with different functions, but of the same type(same context, and rest of type).
12:10:45 <HairyDude> int-e: they both get cast to void * anyway, so it doesn't really make a difference
12:10:54 <HairyDude> s/cast/coerced/
12:11:39 <int-e> HairyDude: you misunderstood. this was a replacement for the whole memcpy call (which doesn't capture the meaning at all)
12:12:39 <HairyDude> ah, I see what you mean
12:12:53 <apfelmus> int-e: i think i've got the proof
12:12:54 <HairyDude> Foo * bar = (Foo *)quux;
12:13:09 <fasta> Where is the monotype entry in Trac?
12:13:21 <HairyDude> given Baz * quux;
12:13:31 <int-e> HairyDude: yes. oh. I missed the point where quux became a pointer.
12:13:42 <int-e> apfelmus: nice.
12:13:56 <apfelmus> int-e: it's actually quite easy :)
12:14:19 <int-e> apfelmus: I still imagine that it's tedious to write up in detail.
12:14:26 <apfelmus> int-e: no, not at all
12:14:58 <apfelmus> lemma: have a term and a reduction sequence that does something with that term
12:15:48 <apfelmus> assumption: no reduction does something under lambdas, i.e. no \x.N -beta-> \x.N'
12:17:11 <apfelmus> assertion: you can exchange the first reduction step with the lazy step
12:17:45 <apfelmus> proof: the term looks like this: (\x.N) @ M1 @ M2 @ ... @ Mk
12:18:12 <fasta> Uhm, isn't (Eq a) => a -> a -> Bool a mono type?
12:18:37 <Korollary> apfelmus: you may wanna use hpaste.org for the proof
12:18:49 <apfelmus> Korollary: that seems sensible
12:18:54 <apfelmus> ?paste
12:18:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
12:19:09 <int-e> fasta: no.
12:26:17 <Saizan> mmh, monotype means rank 1?
12:27:15 <Igloo> a monotype is a type with no polymorphism at all
12:33:44 <hpaste>  apfelmus pasted "Lazy evaluation needs less reductions than eager evaluation" at http://hpaste.org/307
12:33:55 <apfelmus> int-e: ^^
12:34:33 <apfelmus> argl, i want line-wraps
12:39:25 <ccoder> How do i make something to the power of fraction ?
12:39:48 <basti_> you mean, a root?
12:39:50 <apfelmus> :t (^^)
12:39:52 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
12:39:59 <apfelmus> :t (^)
12:40:01 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
12:40:08 <apfelmus> > 3 ^ 0.5
12:40:09 <lambdabot>  Add a type signature
12:40:18 <apfelmus> > 3.0 ^0.5
12:40:19 <lambdabot>  Add a type signature
12:40:21 <shachaf> > 5 ** 0.5
12:40:27 <conal> :t (**)
12:40:28 <lambdabot>  ghc-6.6: could not execute: gcc
12:40:28 <shachaf> Lambdabot's gcc is broken..
12:40:29 <ccoder> ( 3 ^ 0.5 ) :: Int
12:40:29 <lambdabot> forall a. (Floating a) => a -> a -> a
12:40:40 <shachaf> But you'll want to use ** for this, probably.
12:40:57 <ccoder> shachaf: Yeah you'r right :d
12:40:59 <ccoder> thanks a lot
12:41:01 <ccoder> laterz.
12:41:09 <vincenz> > 1
12:41:19 <lambdabot>  ghc-6.6: could not execute: gcc
12:41:22 <vincenz> o.O
12:41:37 <Japsu> :O
12:41:39 <Japsu> evil
12:41:56 <shachaf> None of those three work with Data.Ratio, by the way.
12:45:19 <Japsu> ?pl \x,y -> sum $ zipWith (*) x y
12:45:19 <lambdabot> uncurry ((sum .) . zipWith (*))
12:45:50 <Japsu> ?pl \x,y -> (sum $ zipWith (*) x y)
12:45:51 <lambdabot> uncurry ((sum .) . zipWith (*))
12:48:05 <ddarius> @instances Fractional
12:48:12 <Saizan> is \x,y -> valid haskell?
12:48:16 <ddarius> No
12:48:19 <lambdabot> Double, Float
12:48:44 <pjd> Saizan: \x y -> ... or \(x,y) -> ...
12:49:26 <Saizan> pjd: yeah, @pl has a quite weird parser :)
12:50:15 <pjd> oh, sorry; i wasn't paying attention :/
12:51:31 <hpaste>  mc pasted "n00b : fact" at http://hpaste.org/308
12:52:21 <Japsu> oops
12:52:31 <Japsu> ?pl \x y -> (sum $ zipWith (*) x y)
12:52:31 <lambdabot> (sum .) . zipWith (*)
12:52:42 <Japsu> yaeh
12:52:53 <Japsu> @hoogle Vector
12:52:53 <lambdabot> Test.QuickCheck.vector :: Arbitrary a => Int -> Gen [a]
12:53:01 <Japsu> ...no
12:53:03 <Japsu> @hoogle Matrix
12:53:04 <lambdabot> Text.Html.BlockTable.getMatrix :: BlockTable a -> [[(a, (Int, Int))]]
12:53:07 <Japsu> bah
12:55:40 <int-e> apfelmus: hmm. I don't know. your terms need recursive lets (or should be graphs, with let a = b in c as syntactic sugar for a shared node), otherwise the proof doesn't work for any step but the first. in the first case, the general redex is (let ... in (\x.N)) @ M.
12:56:26 <int-e> apfelmus: these are technical details, of course, the proof idea is sound, I think.
12:56:26 <apfelmus> int-e: i use let as a shorthand for graph sharing
12:57:48 <apfelmus> imagine the term as graph and everything shared in N is under the lambda
12:58:19 <apfelmus> but i think you're right
12:58:36 <apfelmus> the quirk is that the Mi may share stuff
12:59:05 <apfelmus> even with N
12:59:58 <apfelmus> case expressions cut off sharing then
13:01:16 <apfelmus> but none of these things destroy the ability to mirror the reduction up to the outermost function application
13:02:59 <apfelmus> int-e: the main technical trick is your observation to compare things with a changed first reduction step only because the terms become equal again after some time.
13:10:04 <emu> @#^#$^#^&#&
13:10:04 <lambdabot> Unknown command, try @list
13:10:08 <emu> lol
13:10:17 <emu> never underestimate the power of IntMaps
13:12:19 <emu> or rather, never overestimate the running time
13:14:31 <khatar> hello world
13:15:10 <sjanssen> emu: you solved BLINNET!
13:15:16 <sjanssen> emu++
13:15:22 <emu> yes
13:15:33 <emu> and i ended up dumping my STArrays
13:15:33 <sjanssen> how'd you do it?
13:15:54 <emu> i think there's a problem with optimization in loops involving ST
13:15:56 <emu> or monads
13:16:11 <emu> basically i kept trying different things until I figured out the bottleneck on their end
13:16:23 <emu> i was able to read and sort ALL the input (forced) in about 1.3 seconds
13:16:47 <emu> if i paid no attention to union find and just took the first n edges, it was fast
13:17:07 <emu> if i took the first 2n edges, time went up a bit
13:17:08 <sjanssen> weird
13:17:18 <emu> 4n edges.. so on
13:17:38 <emu> every loop it would be doing a find and a union... which should be fast
13:17:46 <sjanssen> so you did Kruskal's with an IntMap based disjoint set?
13:18:04 <emu> yea so i figured maybe its the STUArray based union find, and rewrote one with IntMaps
13:18:21 <sjanssen> that's outrageous :)
13:18:33 <emu> I think its a bug in ghc, maybe warrant further investigation
13:18:44 <sjanssen> really good work emu, that's the first solution in a high level language that I'm aware of
13:18:48 <HairyDude> Config.hs:33:7:
13:18:48 <HairyDude>     Could not find module `System.FilePath':
13:18:48 <HairyDude>       it is a member of package FilePath-0.11, which is hidden
13:18:48 <emu> java :(
13:18:56 <emu> there must be another trick to this
13:18:57 <HairyDude> what is this 'hidden'?
13:19:01 <sjanssen> Java barely counts
13:19:08 <sjanssen> and there are only a couple solutions in that
13:19:14 <emu> my C99 solution ran in 0.86 with Kruskal and buffering input
13:19:29 <emu> fread / strtoul
13:19:33 <sjanssen> emu: IntMap based sort too?
13:19:39 <emu> no, a heap
13:19:47 <emu> i tried qsort but it wasn't better
13:20:06 <emu> say, i noticed this optimization problem with my Haskell ST-based heap too ..
13:20:38 <emu> IntMaps are pretty slick, but i don't think it should be outperforming straight up mutable arrays
13:20:51 <sjanssen> probably not
13:21:11 <emu> i'm trying to prepare a cleaner solution file one moment
13:21:35 <vick> what does deriving (Show, Eq) mean ?
13:21:36 <emu> oh the other outrageous trick i used was to re-boot the runtime system with GC options
13:21:48 <emu> thats why it lists 200m as the memory
13:22:07 <sjanssen> heh
13:22:18 <notsmack> vick: the compiler uses a default way to print and check equality of that type
13:22:23 <hpaste>  gattocarlo pasted "X11 createWindow related bug (?)" at http://hpaste.org/309
13:22:59 <vick> notsmack: What does that mean ? i mean why it is absolutely needed, isn't that the default way why should i specify it ?
13:23:21 <notsmack> vick: you may want a different way?  or you may not need to do those things with the type
13:23:59 <vick> notsmack: i am a little bit confused about what it do tho
13:24:10 <emu> oho i forgot i was still forcing the entire input
13:25:26 <notsmack> vick: the derived Show will be to just print the constructor name followed by the 'show's of the parameters
13:25:49 <vick> What about the 'Eq' ?
13:25:55 <notsmack> vick: so if a parameter was a function, you wouldn't be able to derive show
13:25:58 <emu> sjanssen: other tricks used: encoding edges as Ints, copying swathes of ByteString into my code and tweaking it (I think there's a problem with cross-module optimization too)
13:26:19 <notsmack> Eq is the equality class, I believe it checks that the constructors are the same, and also that the Eq of any parameters are the same
13:28:24 <sjanssen> emu: how can you encode an edge as an Int?
13:28:33 <sjanssen> are all edges less than 2^16?
13:28:43 <emu> each node < 10000
13:28:49 <emu> so yea basically
13:28:56 <notsmack> vick: so if a) that's not an appropriate equality test, b) you won't be checking equality, or c) one of the parameters isn't in Eq; you wouldn't derive Eq
13:29:28 <sjanssen> but there's no limit to edge weight
13:29:48 <emu> so my graph is represented as IntMap [Int] basically
13:29:52 <emu> weight -> [edges]
13:30:32 <vick> notsmack: so derive (Show, Eq) prints the constructor name followed by anything which is 'Eq'
13:30:37 <khatar> bye
13:30:41 <notsmack> vick: no.
13:30:45 <vick> No ?
13:30:53 <notsmack> vick: that derives both Show and Eq, which are separate
13:31:32 <notsmack> Show is to print values of that data type using the 'show' function, and Eq is to check their equality with "=="
13:31:56 <notsmack> @type (==)
13:31:57 <vick> oh!
13:31:58 <lambdabot> forall a. (Eq a) => a -> a -> Bool
13:32:02 <vick> i get it now
13:32:10 <vick> notsmack: Why do i associate it with 'data' tho ?
13:32:32 <vick> To be able to print all it's constructors and use all it's data in equality ?
13:32:36 <notsmack> for any type a in the class Eq, two of that type can be compared with == to return a bool
13:33:00 <vick> data Something = Heh deriving (Show, Eq)
13:33:06 <vick> Does that make Something comparable ?
13:33:14 <notsmack> vick: equality comparisons, yep
13:33:23 <notsmack> vick: Ord if you want >, <, etc
13:33:27 <vick> notsmack: On what basis ?
13:33:46 <vick> nothingmuch: In that cases all Something will be the same ?
13:33:50 <vick> grr
13:33:52 <vick> notsmack*
13:33:59 <notsmack> vick: correct, in that case they'll all be the same
13:34:13 <vick> What if there was data Something = Heh Int
13:34:16 <notsmack> vick: but, say it was "data Something = Heh Int deriving (Eq)"
13:34:19 <notsmack> exactly
13:34:33 <vick> then Heh 0 would be /= Heh 1
13:34:39 <notsmack> exactly
13:34:44 <vick> Thanks a lot notsmack :D
13:35:27 <notsmack> and if you derive Show, then (show (Heh 1)) == "Heh 1"
13:35:52 <emu> sjanssen: want me to paste it?
13:39:32 <hughperkins> Hi, heard about Haskell in slashdot via an article by Tim Sweenie about the future of computing languages for gaming.
13:40:25 <hughperkins> Haskell looks like it offers some very promising conceptual solutions to threading issues.
13:40:29 <Heffalump> absolutely
13:40:44 <Saizan> STM?
13:40:45 <Heffalump> them being practical for gaming might be a while off though
13:40:49 <sjanssen> emu: nah, I don't want any spoilers :)
13:41:21 <apfelmus> Haskell also offers very promising conceptual solutions to all other problems :D
13:41:38 <hughperkins> Question: to what extent are there implementations of Haskell available with threading that I could play with?
13:41:47 <Heffalump> GHC supports it fine.
13:41:57 <hughperkins> automatically by default?
13:42:05 <Heffalump> not quite
13:42:05 <emu> sjanssen: i wasn't able to do it without restarting and adding GC options, btw
13:42:08 <sjanssen> hughperkins: GHC's threading support is very nice
13:42:10 <hughperkins> or I have to do something to activate it / take advantage ofit?
13:42:12 <Heffalump> I forget if it defaults to threaded RTS now.
13:42:22 <Heffalump> But you definitely need to use +RTS -N2 -RTS at runtime to use 2 CPUs (etc)
13:42:22 <hughperkins> Cool
13:42:31 <Heffalump> you may also need to compile with -threaded
13:42:31 <hughperkins> Ok
13:42:42 <Heffalump> also, bear in mind this isn't automatic parallelisation
13:42:53 <Heffalump> you still need to fork off threads for yourself, in the IO monad
13:42:57 <hughperkins> Ok
13:43:29 <kpreid> there *is* also non-IO parallelization
13:43:33 <Heffalump> there's also the `par` combinator, and a whole library of stuff built on top of that, in Control.Parallel.Strategies, for parallelising pure code.
13:43:48 <Heffalump> both of these things are here right now
13:43:57 <hughperkins> that sounds interesting
13:44:08 <Heffalump> in a future version of GHC, there'll be automatic parallelisation of "array comprehensions"
13:44:33 <Heffalump> i.e. bulk data parallelism, as opposed to the computation level parallelism of `par`, or the thread level parallelism of forkIO
13:45:48 <hughperkins> Yeah, I'm kindof hoping to have the parallelization be done automatically :-)
13:46:03 <hughperkins> It's the bit that's hooked my interest
13:47:21 <Heffalump> there's still quite a bit of research and engineering to do before that's ready
13:47:29 <hughperkins> Ok :-)
13:47:30 <Heffalump> lookup "nested data parallelism"
13:47:44 <hughperkins> Yes, it's cutting edge, which is why it's so interesting :-)
13:48:00 <notsmack> especially the video of SPJ's talk on it
13:48:06 <hughperkins> Ok
13:48:20 <Heffalump> the basic challenge is that, while it's obvious that you can split up a simple bulk data operation across multiple CPUs, how do you make a sensible division of a bulk operation that itself applies bulk operations?
13:49:27 <notsmack> @google Tim Sweenie haskell
13:49:30 <lambdabot> http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/sweeny.pdf
13:50:15 <Heffalump> Tim Sweeney
13:50:35 <hughperkins> lamdabot, that's how I found about Haskell, that presentation :-)
13:50:52 <notsmack> Heffalump: i see, but google figured it out
13:50:56 <notsmack> @botsnack
13:50:57 <lambdabot> :)
13:51:02 <Heffalump> that's presumably the POPL talk?
13:51:36 <hughperkins> POPL?
13:52:21 <emu> ok, i think i will leave it for now.  2.20 sec =)
13:52:39 <notsmack> huh, 90% of integer variables in Unreal exist to index into arrays.  that's an interesting fact.
13:53:41 <Heffalump> one of the major programming language conferences
13:53:52 <hughperkins> Ah... :-)
13:53:52 <Heffalump> that talk is one of the invited talks there in 2006
13:54:01 <Philippa> notsmack: it doesn't surprise me in the slightest
13:54:16 <Philippa> bear in mind that anything coordinate-based isn't going to be integer
13:54:41 <notsmack> Philippa: right.  just interesting to see it on paper.
13:54:46 <emu> fixed pt?
13:55:19 <dfranke> Philippa, not necessarily... you can treat them as fixed-point numbers.  Kinda pointless on modern CPUs though.
13:57:04 <notsmack> "pointless"
14:02:18 <olsner_> @pl 1.0
14:02:19 <lambdabot> 1 . 0
14:02:30 <int-e> @pl \a b c x y z -> y z (x a c) b
14:02:30 <lambdabot> flip . ((flip . ((flip . (flip .) . flip flip) .)) .) . flip . flip id
14:02:39 <notsmack> @type (1 . 0)
14:02:42 <lambdabot> forall c a. (Num (b -> c), Num (a -> b)) => a -> c
14:02:55 <int-e> @quote pointfree
14:02:55 <lambdabot> No quotes match. Wrong!  You cheating scum!
14:03:00 <int-e> @quote pointless
14:03:00 <lambdabot> qwe1234 says: lol, thanks for the pointless offtopic post
14:03:59 <LoganCapaldo> > 1.0
14:04:05 <lambdabot>  ghc-6.6: could not execute: gcc
14:04:12 <LoganCapaldo> waaaa?
14:04:23 <int-e> cool.
14:04:34 <notsmack> > ""
14:04:34 <lambdabot>  ghc-6.6: could not execute: gcc
14:05:11 <Heffalump> it's been doing that all day
14:06:53 <hpaste>  gattocarlo pasted "override_redirect solved!!" at http://hpaste.org/310
14:08:15 <nuncanada> you need gcc too
14:10:15 <matthew-_> does anyone have a really funky laser pen
14:10:30 <matthew-_> which can also talk bluetooth or something similar
14:10:43 <matthew-_> and has buttons for advancing a presentation?
14:11:08 <matthew-_> I'm almost considering strapping a laser pointer to a Wiimote...
14:11:25 <shachaf> matthew-_: Does infrared work?
14:11:36 <dfranke> matthew-_, mine can take IRDA if you're really fast.
14:12:48 <matthew-_> shachaf: my laptop doesn't have irda port
14:12:59 <matthew-_> bluetooth or wifi would be best
14:13:03 <shachaf> matthew-_: But is it within line-of-sight?
14:13:06 <shachaf> matthew-_: Hmm, OK.
14:13:31 <matthew-_> line of sight: um, possibly, but I wouldn't be able to guarantee that for any arbitrary presentation
14:14:31 <shachaf> matthew-_: And does it indeed need to be a pen?
14:15:15 <matthew-_> shachaf: I guess not.
14:15:41 <matthew-_> I need to make a dot or something on a wall/projection-screen for giving a presentation...
14:16:12 <shachaf> matthew-_: There's the Logitech Cordless Presenter, is that approximately what you need?
14:16:28 <shachaf> matthew-_: It's a bit expensive, though.
14:17:19 <matthew-_> that kinda thing.
14:18:14 <matthew-_> yeah. I don't run windows at all though, so I need to have some degree of confidence that it doesn't rely on horrid windows drivers to emulate missing hardware and hence won't ever work on linux
14:19:10 <shachaf> matthew-_: Oh, more requirement...
14:19:46 <shachaf> matthew-_: I have a PCMCIA-card-size infrared remote control with a laser pointer that emulates a keyboard/mouse.
14:19:51 <shachaf> matthew-_: But it's line-of-sight.
14:20:02 <chessguy> i've never seen syntax like this:
14:20:04 <chessguy> $(inferStartState ''PasteState)
14:20:04 <chessguy> $(inferRecordUpdaters ''PasteState)
14:20:09 <chessguy> is that TH?
14:20:11 <sjanssen> yes
14:20:12 <Saizan> yup
14:20:12 <shachaf> chessguy: Yes.
14:20:20 <chessguy> ah
14:21:01 <chessguy> sorry, can't resist:
14:21:03 <chessguy> @quote stereo
14:21:04 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
14:21:09 <Saizan> ''PasteState refers to the type, $() "calls" the macro
14:22:08 <matthew-_> sorry, from the above, what would the type of inferStartState be :: ??? -> Q [Dec}
14:22:18 <Saizan> Name ->
14:22:24 <matthew-_> ahh
14:26:50 <shachaf> matthew-_: What about the Targus Wireless Presenter?
14:26:58 <shachaf> matthew-_: It looks like what you need.
14:27:38 <shachaf> matthew-_: http://www.amazon.com/Targus-Wireless-Presenter-Laser-Pointer/dp/B000F004RO
14:27:42 <lambdabot> http://tinyurl.com/24dawl
14:29:35 <matthew-_> shachaf: yep I agree. Presumeably it'll just appear as a standard USB HID mouse to the kernel
14:29:49 <shachaf> matthew-_: Keyboard, but yes.
14:30:03 <shachaf> matthew-_: Probably PgUp, PgDn, Esc, and B.
14:30:08 <shachaf> matthew-_: (Just a guess.)
14:30:15 <matthew-_> ahh.
14:30:15 <shachaf> matthew-_: Or maybe alt-tab.
14:30:21 <shachaf> matthew-_: Something like that.
14:31:12 <shachaf> matthew-_: Plus, you can stop "asking colleges to change the slides". :-)
14:31:29 <matthew-_> quite
14:32:05 <matthew-_> no, it's just the endless walking to the side to get out of the way of people's view of the screen, but then trekking back to change slides...
14:33:14 <shachaf> matthew-_: Actually, I was just making fun of their malapropism. :-)
14:33:29 <shachaf> matthew-_: Actually, this is spelled similarly, but pronounced differently.
14:33:36 * shachaf isn't sure what that's called.
14:33:51 <shachaf> matthew-_: This should probably all be in #haskell-blah , anyway.
14:34:43 <matthew-_> indeed. sorry.
14:35:04 <shachaf> matthew-_: I was talking a lot more than you were. :-)
14:35:33 <matthew-_> must... talk... about... types...
14:39:48 <Codex_> type checking... type inhabitation... type... :)
14:46:52 <HairyDude> is hPutStr lazy?
14:47:47 <oerjan> HairyDude: can't imagine so
14:48:12 <oerjan> although the output file might be buffered by the OS
14:48:20 <sjanssen> HairyDude: no, it isn't
14:48:57 <HairyDude> ah, good
14:49:24 <HairyDude> well an hClose will flush it, right?
14:49:24 <oerjan> @src interact
14:49:25 <lambdabot> interact f = do s <- getContents; putStr (f s)
14:50:51 <oerjan> yes, according to 21.3.2 of the Haskell 98 report
14:52:09 <oerjan> @onlinereport io
14:52:09 <lambdabot> Unknown command, try @list
14:58:23 <HairyDude> I think what might be happening here is that I'm deleting the file before the spawned process gets a chance to read from it
14:58:30 <HairyDude> is there a haskell equivalent of popen?
14:59:52 <HairyDude> aha, runInteractiveProcess
15:00:14 <lispy> HairyDude: chances are you will be disappointed
15:00:29 <lispy> HairyDude: i think lambdabot has the closest i've seen to a real popen in haskell
15:00:32 <lispy> ?version
15:00:33 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
15:00:33 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
15:00:41 <lispy> HairyDude: you can browse the sounce ^^
15:00:44 <lispy> source*
15:06:59 <hughperkins> Random question: spj asserts that you couldnt create a thread for each of 100 million sub-tasks.  Is there a fundemental limit on minimum thread cost, or is this something that could change in the future?  (in a future before one where we have 100 million core processors of course)
15:08:10 <emu> sjanssen: i dunno whats up. i've tried to come up with test cases demonstrating the better time performance of IntMaps, but I keep finding the array-based versions to be faster.  except BLINNET.
15:10:44 <emu> oh, and IOUArrays outperform STUArrays :/
15:11:00 <emu> time for food
15:11:19 <vincenz> hughperkins: maybe it has to do with the cost of the scheduler, or the cost of the communication synch between threads
15:20:30 <ddarius> Yes there is a minimum cost to threads.
15:26:21 <hughperkins> cost of the scheduler is cost to processor optimization of jumping from one piece of code to another, plus the time to swap out registers?
15:28:37 <ihope> 100 megatasks?
15:29:00 <ihope> 100 megatasks at 4000 megahertz means 40 hertz per task.
15:29:05 <vincenz> hughperkins: no
15:29:11 <vincenz> hughperkins: it's the scheduler itsefl
15:29:19 <vincenz> hughperkins: you have a list of 100M things and you have to give them a fair scheduling
15:29:31 <vincenz> hughperkins: wake them up when they're able to run, sleep them when they're waiting on file descriptors
15:29:51 <vincenz> ihope: 4Ghz = nothing
15:30:26 <ihope> Now, CPS probably gives me a nice way to say "stop what you're doing and perform this action, then quit".
15:30:26 <vincenz> hughperkins: not to mention that either your application is embarassingly paralle, or your bottleneck is the communication between tasks
15:31:04 <hughperkins> well, communication between tasks is a separte issue; one issue at a time ;-)
15:31:17 <hughperkins> wrt "you have a list of 100M things and you have to give
15:31:27 <ihope> @index ContT
15:31:28 <lambdabot> Control.Monad.Cont, Control.Monad.Cont
15:32:14 <hughperkins> +them a fair scheduling", (oops pressed enter too soon), presumably if you had 100 million threads, each one is tiny, maybe just a few instructions, so you could just let each thread run to completion?
15:33:03 <vincenz> hughperkins: what if they wait on a socket?
15:33:14 <hughperkins> well, waiting ona a socket is non-pure?
15:36:21 <sjanssen> hughperkins: making 100M of anything is fairly expensive
15:36:40 <sjanssen> > 10^8 * 4 `div` (2^20)
15:36:47 <lambdabot>  ghc-6.6: could not execute: gcc
15:36:51 <sjanssen> bleh
15:37:07 <hughperkins> Well, whatever happens, processing 100 million tasks is going to take a certain amount of time.
15:37:34 <sjanssen> anyway, it takes about 380 MB simply to have 100M single words in memory
15:38:27 <hughperkins> The issue is: if its currently non-obvious to fairly divide up 100 million tasks amongst a smallish number of threads, to what extent is it less non-obvious to dump everything into a thread, and optimize the threading?
15:39:17 <ihope> @type sequence
15:39:19 <lambdabot>     Ambiguous occurrence `sequence'
15:39:19 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
15:39:26 <ihope> Bleh.
15:39:35 <sjanssen> well, if these tasks are truly independent, you can just batch them across a certain number of threads
15:39:36 <ihope> @type Prelude.sequence
15:39:37 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m [a]
15:39:59 <hughperkins> yes, across 100 million threads ;-)
15:40:17 <hughperkins> oh, maybe I misunderstood / missed the word batch
15:40:20 <sjanssen> if you've got 100 CPUs, schedule 1M tasks for each CPU -- only 100 tasks have to be running and in memory at one point
15:41:28 <hughperkins> Yes, like a thread pool?
15:41:35 <sjanssen> yeah, something like that
15:41:48 <Cale> It's quite likely that if you have 100 million tasks, they're not all completely different computations :)
15:42:34 <Cale> So you can just create as many threads as you have processing units, with each being a loop.
15:42:36 <hughperkins> Right.  In the spj presentation he's presenting nested data parallelism.
15:43:03 <hughperkins> He asserts that you can just run each subtask in a separate thread, because it would be insanely slow,
15:43:26 <hughperkins> which is probably true today, but that could possibly change depending on optimizations in the future? or not
15:43:43 <hughperkins> s/can just run/ cant just run/
15:43:55 <Cale> Well, you have to do some level of processing to determine which thread to run at which time on which processor.
15:44:00 <sorear> (hello)
15:44:14 <Cale> So there's always a cost associated with having lots of threads.
15:44:20 <sjanssen> hughperkins: at that scale, you don't want to be doing any extra work
15:44:23 <sorear> @seen
15:44:31 <sjanssen> simply adding a thread to a run queue is extra work
15:44:37 <Cale> You can make them pretty cheap, but eventually it'll kill you.
15:45:08 <Cale> Especially if all the tasks are extremely small.
15:45:26 <hughperkins> Ok
15:46:49 <oerjan> @index callCC
15:46:49 <lambdabot> Control.Monad.Cont
15:57:57 <sorear> Hmm.
15:58:11 <sorear> Suppose we have a module Foo, which exports a data constructor Foo.
15:58:16 <sorear> now :
15:58:20 <sorear> module Bar where
15:58:25 <sorear> import Foo
15:58:29 <sorear> Foo.Foo = Foo
15:58:59 <sorear> Is that a definition of a function (.), or a nullary pattern binding on a qualified constructor?
15:59:00 <ddarius> sorear: Is that valid syntax?
15:59:10 <ddarius> The latter.
15:59:12 <sorear> ddarius: I'm pretty sure
15:59:24 <ddarius> I didn't think of the pattern matching case.
15:59:24 * sjanssen bets on option 2
15:59:44 <ihope> Ah, yes, there's nullary pattern bindings.
15:59:48 <ihope> > let True = False in True
15:59:59 <lambdabot>  ghc-6.6: could not execute: gcc
16:00:01 <ddarius> Foo.Foo will already be lexed as an identifier
16:00:04 <ihope> Wonderful@
16:00:06 <sjanssen> lambdabot is broken
16:00:40 <sorear> ddarius: Haskell doesn't have a lexical syntax as such, the valid keywords depend on context...
16:00:56 <jaapweel> is there a rule against using single quotes in descriptions in cabal files, or is the hackage web site generator thingie just broken? see http://hackage.haskell.org/cgi-bin/hackage-scripts/package/HsSyck-0.4
16:00:58 <lambdabot> http://tinyurl.com/yw5adl
16:01:06 <sorear> jaapweel: Yes.
16:01:31 <sorear> jaapweel: Or rather, Haddock chokes on the invalid markup.
16:01:38 <ihope> But that... thing there results in True.
16:01:52 <sorear>    The following characters have special meanings in documentation comments: /, ', `, ", @, <. To insert a literal occurrence of one of these special characters, precede it with a backslash (\).
16:01:55 <jaapweel> sorear, I was not aware there was haddock involved at all
16:02:23 <Japsu> @src Data.List.group
16:02:23 <lambdabot> Source not found. That's something I cannot allow to happen.
16:02:26 <Japsu> :<
16:02:37 <Japsu> @src List.group
16:02:38 <lambdabot> Source not found. stty: unknown mode: doofus
16:02:42 <Saizan> @src group
16:02:43 <lambdabot> group = groupBy (==)
16:02:46 <Saizan> @src groupBy
16:02:46 <sorear> Hmm.
16:02:46 <lambdabot> groupBy _  []       =  []
16:02:46 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
16:02:46 <lambdabot>     where (ys,zs) = span (eq x) xs
16:02:47 <Japsu> :O
16:02:47 <jaapweel> i thought i was just writing a text file description of the package
16:02:50 <ddarius> ihope: Indeed.  As a top-level declaration you can have: True = False
16:02:54 <sorear> There's still a nasty case
16:03:04 <sorear> Foo.bar = Foo
16:03:17 <sorear> that needs to lex as Foo . bar = Foo
16:03:27 <ihope> Why?
16:03:46 <sorear> Because you can't bind qvars.
16:04:01 * sorear is trying to get into the haskell implementation game...
16:04:06 <sorear> again...
16:04:22 <slowriot> Does anyone have any suggestions for a project to help me learn Hasell? I'm thinking about trying some ICFP contest problems.
16:04:40 <ihope> Oh, because you can't bind an imported variable, isn't it?
16:04:46 <ihope> Is that what a qvar is, then?
16:04:46 <sorear> Right.
16:04:54 <sorear> qualified varname
16:09:48 <slowriot> hmm... maybe I'll come back when the channel is more active.
16:10:10 <sorear> @list-all   --have some spam!
16:10:11 <lambdabot> activity provides: activity
16:10:11 <lambdabot> babel provides: babel
16:10:11 <lambdabot> base has no visible commands
16:10:11 <lambdabot> bf provides: bf
16:10:11 <lambdabot> check provides: check
16:10:13 <lambdabot> compose provides: . compose
16:10:15 <lambdabot> dice provides: dice
16:10:17 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
16:10:19 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
16:10:21 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools hackage
16:10:23 <lambdabot> elite provides: elite
16:10:25 <slowriot> lol
16:10:25 <lambdabot> eval provides: run let undefine
16:10:27 <lambdabot> Plugin `system' failed with: IRCRaised thread killed
16:17:41 <astrolabe> Someone posted a link to a draft paper on probability monads here a couple of days ago.  Does anyone have it?
16:18:29 <astrolabe> Ah it was ekidd
16:18:35 <astrolabe> @seen ekidd
16:18:35 <lambdabot> I saw ekidd leaving #haskell 45m 52s ago, and .
16:27:34 <Choko> !ripe 80.166.99.141
16:27:53 <Choko> sorry, wrong channel :(
16:28:20 <vincenz> botnet?
16:28:28 <Choko> no
16:28:50 <vincenz> right, because you would say 'yes' if you'd been caught :)
16:29:06 <Choko> just some bot on another network that can show information about routes
16:29:15 <Choko> from the ripe database
16:29:32 <mauke> http://www.ripe.net/fcgi-bin/whois?form_type=simple&full_query_string=&searchtext=80.166.99.141&submit.x=6&submit.y=11&submit=Search
16:29:33 <vincenz> @google ripe database
16:29:35 <lambdabot> Title: Query the RIPE Database, http://tinyurl.com/2gbue9
16:29:35 <lambdabot> http://www.ripe.net/whois
16:29:35 <lambdabot> Title: Query the RIPE Database
16:29:59 <vincenz> what is it?
16:30:44 <Choko> ripe has information about routes to at least european ipv4 assigned addresses
16:31:21 <Choko> and ripe is the institution in europe atleast who gives out ip addresses
16:31:58 <Excedrin> the euro version of arin
16:32:09 <Choko> yes!
16:32:42 <Choko> who is asia actually using ?
16:32:48 <Excedrin> apnic
16:33:21 <Choko> and africa? i guess they are under ripe?
16:33:33 <vincenz> wow so much stuf fwe use daily we know nothing about o.O
16:33:38 <Excedrin> no, it's afrinic or something
16:33:53 <vincenz> nic = ?
16:34:06 <vincenz> Asian Pacific Network I C
16:34:23 <Excedrin> network information center
16:34:37 <vincenz> so every dns lookup goes through them?
16:34:38 <Choko> great so actually every continental has its own network information center :)
16:34:44 <Excedrin> no, it has nothing to do with dns
16:34:50 <vincenz> what does it do?
16:35:07 <Excedrin> they hand out IP allocations and AS numbers
16:35:22 <vincenz> ah
16:35:33 <Excedrin> AS = autonomous system
16:35:38 <vincenz> what gives them that power?
16:36:37 <Saizan> the net gods.
16:37:04 <Excedrin> as the net grew, the IANA created these seperate IRs
16:37:17 <vincenz> yay for more acronyms
16:37:22 <Excedrin> there's some history about NSF and stuff somewhere
16:37:40 <vincenz> IDKWIANAMSCYPE
16:38:23 <Excedrin> here you go: http://en.wikipedia.org/wiki/History_of_the_Internet
16:38:25 <lambdabot> Title: History of the Internet - Wikipedia, the free encyclopedia
16:39:11 <vincenz> cool, thx :)
16:39:45 <ddarius> vincenz: I suggest you stop using all things that you don't completely understand.
16:42:06 <vincenz> ddarius: yes, why don't yo stop using your brain
16:48:33 <emu> wtf, i come back and suddenly MArrays are fast.
16:49:24 <emu> did someone hack on my copy of GHC while I was gone
16:52:29 <hughperkins> can I use map to print each member of a list?
16:52:42 <emu> sequence_ . map
16:52:43 <hughperkins> seomthing like say "map putStrLen mylist"
16:52:46 <emu> @src mapM_
16:52:46 <lambdabot> mapM_ f as = sequence_ (map f as)
16:52:46 <hughperkins> ok
16:53:02 <hughperkins> Thanks
16:53:07 <emu> :t sequence_
16:53:09 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:53:22 <emu> basically, "map putStrLn myList" would result in [IO ()]
16:53:33 <hughperkins> yeah thats what it gave me
16:53:42 <emu> and sequence_ takes any [m a] and "runs" it
16:53:50 <hughperkins> Ok
16:53:55 <emu> that's how it appears in IO
16:54:03 <emu> of course it's more general than that
16:54:36 <emu> > sequence [[1,2],"ab"]
16:54:37 <lambdabot> Terminated
16:55:06 <emu> > sequence [[1,2],[3,4]]
16:55:07 <lambdabot> Terminated
16:55:18 <emu> ok well lambdabot is screwy
16:55:21 <Saizan> > Prelude.sequence [[1,2],[3,4]]
16:55:22 <lambdabot>  ghc-6.6: could not execute: gcc
16:55:46 <emu> but the idea was to show that sequence on the List monad will return the possible sequences it can form by choosing a value from each list
16:55:54 <Japsu> gah
16:56:07 <Japsu> nvm
16:57:30 <hughperkins> Ok, that will probably make more sense to me in the future ;-)
16:57:49 <emu> well consider [putStrLn "hi", putStrLn "world"]
16:57:54 <hughperkins> Woot! managed to print the contents of a directory!
16:58:10 <hughperkins> Ok
16:58:18 <emu> if you "sequence" that, you expect it to print "hi" then "world" in IO.
16:58:35 <hughperkins> ok, because it runs each member fo the array?
16:58:40 <hughperkins> of the list
16:59:03 <emu> now sequence [[1,2], [3,4]] will "choose a member" from [1,2] and then "choose a member" from [3,4]
16:59:26 <emu> the List monad embodies "non-deterministic computation" which means operating on many-values at once
16:59:42 <hughperkins> Ah ok...
16:59:45 <mauke> sequence [y1, y2, y3, ...] == do { x1 <- y1; x2 <- y2; x3 <- y3; ...; return [x1, x2, x3, ...] }
17:00:15 <emu> do { _ <- putStrLn "hi"; _ <- putStrLn "world" } in the IO case
17:00:29 <emu> do { _ <- putStrLn "hi"; _ <- putStrLn "world" ; return () } strictly speaking
17:01:21 <mauke> s/_ <- //
17:01:26 <emu> yep
17:01:36 <emu> but it points out the genesis of the _ in sequence_ ;)
17:01:56 <mauke> sequence_ [y1, y2, y3, ...] == do { y1; y2; y3; ... ; return () }
17:03:37 <hughperkins> oh, sequence /= sequence_ ? two different functions?
17:03:49 <emu> sequence_ is used when you purely want the side effects
17:03:56 <emu> that didn't sound quite right
17:04:45 <hughperkins> ok
17:04:50 <mauke> hughperkins: sequence_ swallows the return value, giving you only ()
17:04:55 <oerjan> sequence_ throws away the results of the actions, sequence collects them in a list
17:05:04 <hughperkins> Ah ok
17:06:17 <oerjan> @src sequence_
17:06:17 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
17:07:07 <hughperkins> how can I do something like "when( path /= "." and path /= ".." )"  ?
17:07:13 <hughperkins> ie, combine two conditions
17:07:20 <oerjan> hughperkins: &&
17:07:24 <hughperkins> Ok
17:07:46 <hughperkins> Cool!
17:08:12 <mauke> when (all (path /=) [".", ".."])
17:08:28 <emu> 'and' and 'or' are list-versions of && and || which shortcut too because of lazy eval ;)
17:08:55 <oerjan> although in that case you could also do not (path `elem` [".", ".."])
17:09:11 <mauke> path `notElem` [".", ".."]
17:10:24 <oerjan> it occurs to me that sequence_ could have used foldr1 to be more tail recursive
17:10:46 <mauke> foldr is never tail recursive
17:11:26 <mauke> and sequence_ can't use foldr1 because that would fail for empty lists
17:11:37 <oerjan> it could check
17:12:03 <mauke> wtf?
17:12:05 <oerjan> although i just realized it doesn't work because it needs to throw away the result
17:12:43 <oerjan> (a separate [] case)
17:13:04 <mauke> then why use foldr1 instead of foldr?
17:13:20 <oerjan> what i mean is, foldr1 (>>) l could be tail recursive in the last action of l, in some monads
17:13:53 <Saizan> tail recursive in the last action?
17:14:04 <mauke> huh?
17:14:28 <Saizan> you just want to create a m1 >> m2 >> m3 >> ... >> return ()
17:14:44 <oerjan> no return () at the end that would ruin it
17:14:54 <oerjan> so it wouldn't be either sequence or sequence_
17:15:10 <mauke> I don't get it
17:15:10 <emu> @tell sjanssen 1.37 sec with IOUArrays.  there's something about ST arrays that spoj especially doesn't like.  and ghc shows more efficiency with IO arrays in my local tests too :/
17:15:10 <lambdabot> Consider it noted.
17:15:35 <Saizan> well sequence is  m1 >>= m2 >>= m3 >>= ... >>= mN
17:15:42 <Saizan> uhm no.
17:16:00 <Saizan> quite different :)
17:16:02 <sjanssen> emu: bizarre
17:16:03 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
17:16:12 <oerjan> i mean, say you do cmd = foldr1 (>>) [something1, something2, cmd]
17:16:18 <sjanssen> wait, I've got an idea
17:16:26 <hughperkins> how can I do something like "contents2 <- filter not(`elem` [".",".."]) contents
17:16:45 <emu> sjanssen: i can't recreate the discrepancy though.  on my tests, IOUArrays are only like 10-20% faster.  on spoj, it just bombs
17:16:48 <hughperkins> ie, take the list "contents" and filter out "." and ".." and put that in list contnts2
17:16:51 <oerjan> (not . (`elem` [".",".."]))
17:16:57 <mauke> hughperkins: let contents2 = filter (`notElem` [".",".."]) contents
17:17:17 <Saizan> contents2 <- filter (\c -> not (c `elem` [".",".."])) contents, also
17:17:36 <mauke> he wants contents2 to be a list
17:18:25 <hughperkins> Cool! :-)
17:18:34 <Saizan> mauke: right, my bad
17:18:47 <emu> ST is mysteriously chewing up more RAM too -- could be strictness issue at hand
17:22:03 <oerjan> there's an ST.Lazy, isn't there?
17:22:31 <emu> well yes, but IO is strict and does much better so i'd imagine laziness is bac
17:22:32 <emu> bad
17:23:05 <emu> then again we've already shown that i know nothing
17:23:29 <oerjan> strange there should be a difference since i just yesterday saw that IORef is defined in terms of STRef
17:23:35 <oerjan> @src IORef
17:23:35 <lambdabot> newtype IORef a = IORef (STRef RealWorld a)
17:23:53 <sorear> and, ST and IO are represented samely
17:23:56 <sorear> @src ST
17:23:56 <lambdabot> newtype ST s a = ST (STRep s a)
17:23:58 <sorear> @src IO
17:23:59 <lambdabot> newtype IO a = IO (State# RealWorld -> (# State# RealWorld, a #))
17:24:02 <sorear> @src STRep
17:24:02 <lambdabot> type STRep s a = State# s -> (# State# s, a #)
17:30:30 <emu> also i don't think lazy ST permits STUArrays
17:33:55 <emu> blah, there isn't much performance difference between ST and IO on my system.  but on spoj its the difference between TLE and 1.5seconds runtime.  i've made sure everything is the same except the types.
17:34:03 <emu> something is scerwy
17:41:04 <cartman> hi
17:42:00 <cartman> Latest GHC doesn't compile with gcc 4.2.0 ( http://hackage.haskell.org/trac/ghc/ticket/1427 ) , is there a way to get some attention to this bug? Or shall I just more than 1 day (doh ;))
17:42:02 <lambdabot> Title: #1427 (GHC fails to compile with gcc 4.2.0) - GHC - Trac
17:42:10 <cartman> good lambdabot
17:42:19 <cartman> s/more/wait more
17:43:09 <oerjan> @version
17:43:09 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
17:43:09 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:43:09 <emu> probably wait
17:43:17 <emu> i'm sure the ghc devs are enjoying their weekend
17:43:26 <oerjan> no connection to the current lambdabot problems?
17:44:01 <cartman> emu: ah forget about weekend even :|
17:44:03 <cartman> emu: thanks
17:44:31 <emu> i have a sid chroot but i didnt update to gcc 4.2
17:46:29 <cartman> well I use Pardus Linux anyway
17:46:40 <cartman> Debian bug report is a good reference, hence I added it
17:46:52 * int80_h stays sane by using netbsd
17:46:53 <emu> ah. trying it now
17:47:35 <cartman> it was a tough job to bootstrap ghc btw
17:47:43 <cartman> libreadline.so.4 dependency is not good :-/
17:47:56 * cartman just packaged ghc for Pardus
17:53:49 * syntaxfree announces he's about to engage in general-purpose whining in #haskell-blah for public amusement.
17:54:14 <emu> cartman: yea i imagine
17:54:29 <emu> does your source package self-bootstrap?
17:54:37 <emu> sounds difficult
17:54:48 <syntaxfree> how is ghc bootstrapped nowadays, btw?
17:54:56 <cartman> emu: it uses a pre-compiled ghc with libreadline.so.4 to bootstrap normal ghc
17:55:00 <syntaxfree> i remember some ancient version of ghc was written in one of the MLs.
17:55:06 <cartman> in the end a native ghc build done
17:55:23 <cartman> but if precompiled packages @ haskell.org used libreadline.so.5
17:55:26 <cartman> it would be easier
17:56:35 <emu> isn't there a version w/o readline
17:56:44 <emu> that's for ghci really
17:57:42 <syntaxfree> my ghci has no readline support.
17:58:14 <syntaxfree> and no, rlwrap doesn't help.
17:58:29 <cartman> emu: not on haskell.org
17:58:38 <cartman> emu: I can now use my native ghc to bootstrap the source
17:58:39 <cartman> evil :)
18:21:36 <oerjan> ever heard of -th? :)
18:22:01 <oerjan> (i need to learn to check my window focus)
18:33:34 <xpika> has anyone here compiled readline4 on cywin?
18:44:42 <hpaste>  int80h pasted "int80_h borks parser" at http://hpaste.org/311
18:48:29 <int80_h> any ideas guys?
18:49:22 <int80_h> hmm this is wierd, the way it formatted my code in the web browser
18:54:49 <kpreid> int80_h: perhaps you got some â€˜curlyâ€™ quotes in your source?
18:55:19 <kpreid> yes...that would be consistent, with hpaste failing to process utf-8
18:55:45 <kpreid> 'tis a shame that Haskell 98 wasn't specified with encoding facilities
19:00:41 <int80_h> kpried, do you men I should have ' instead of ` or visa versa? this is code I snagged from someone's blog.
19:02:32 <int80_h> I think I've got it figured out.
19:02:49 <int80_h> I fixed that line and now it's got the same complaint for other lines. I hope that's all that is wrong
19:16:09 <kpreid> int80_h: I mean you have â€˜fâ€™ and â€œfooâ€ instead of 'f' and "foo"
19:16:38 <kpreid> â€˜, â€™, `, and ' are all distinct
19:22:04 <int80_h> thanks
19:26:29 <int80_h> kpried, can you see what's wrong with this?
19:26:30 <int80_h> nadsat <- anyChar 'manyTill' (char ":");
19:26:55 <kpreid> ` is for infix, ' is for characters
19:27:27 <int80_h> it's complaining about 'manyTill'
19:27:31 <kpreid> yes
19:27:47 <int80_h> ah, so I should use `
19:27:50 <kpreid> yes
19:29:40 <oerjan> int80_h: also you probably need ':' or you will get a type error once it parses
19:33:03 <chadz> salutations!
19:34:02 <jfredett> hmm
19:34:13 <jfredett> i'm looking for a Hashmap / dictionary datatype
19:34:28 <jfredett> does one exist?
19:34:33 <jfredett> Oh! I can hoogle it
19:34:36 <jfredett> @hoogle Dict
19:34:37 <lambdabot> No matches found
19:34:42 <jfredett> @hoogle Hash
19:34:43 <lambdabot> Data.HashTable :: module
19:34:43 <lambdabot> Data.HashTable.HashTable :: data HashTable key val
19:34:43 <lambdabot> Data.HashTable.hashInt :: Int -> Int32
19:34:46 <jfredett> hah hah!
19:35:21 <chadz> jfredett: i recommend Data.Map
19:35:27 <jfredett> I forget I have all these things -- most other languages dont have such wonderful API finding utilities.
19:35:33 <jfredett> Map, gotcha
19:35:44 <chadz> :t lookup
19:35:46 <lambdabot> forall a b. (Eq a) => a -> [(a, b)] -> Maybe b
19:35:57 <chadz> hmm
19:36:04 <chadz> :t Data.Map.lookup
19:36:06 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
19:36:21 <chadz> :t fromList
19:36:23 <lambdabot> Not in scope: `fromList'
19:36:30 <jfredett> So its a monad?
19:36:33 <jfredett> ish
19:36:34 <jfredett> thing?
19:36:52 <oerjan> jfredett: no, Data.Map is pure
19:37:14 <jfredett> nifty
19:37:16 <oerjan> (tree-based)
19:37:52 <jfredett> so wait- i have Data.map, I create a map with some key type and some value type?
19:37:58 <Cale> It returns its result typed in a monad, which is really an awful hack. It uses 'fail' if the value isn't there.
19:37:58 <jfredett> does the Key have to be orderable?
19:38:14 <oerjan> jfredett: yes
19:38:22 <Cale> Really, it ought to be (MonadZero m) => ...
19:38:41 <Cale> but if you use a monad which isn't a MonadZero, your program will just die on failure.
19:39:14 <Cale> (Unfortunately, MonadZero is gone, so you just have to know which monads have a suitable fail)
19:39:23 <jfredett> i see.
19:39:24 <Cale> Most likely, you'll just want Maybe
19:39:29 <jfredett> right
19:39:31 <oerjan> Cale: i never quite understood the difference between fail and MZero
19:39:47 <chadz> > Data.Map.lookup 1 $ fromList [(1,"hello"),(2,"world")]
19:39:48 <lambdabot>   Not in scope: `fromList'
19:39:59 <chadz> > Data.Map.lookup 1 $ Data.Map.fromList [(1,"hello"),(2,"world")]
19:40:00 <lambdabot>   Not in scope: `Data.Map.fromList'
19:40:05 <chadz> psh
19:40:13 <oerjan> @type MZero
19:40:15 <lambdabot> Not in scope: data constructor `MZero'
19:40:17 <Cale> oerjan: fail is sort of a hack which was put into the Monad class to simplify the translation of do-notation.
19:40:35 <Cale> @type mzero
19:40:37 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a
19:40:52 <jfredett> oh dear-- lots of monads
19:41:09 <Cale> They moved mzero into MonadPlus when they removed monad comprehensions, for some ill-conceived reason.
19:41:20 <jfredett> I'm only starting to get comfy w/ monads
19:41:55 <chadz> jfredett: read marlow's akward squad, it's the best paper for introducting monads imho
19:42:17 <chadz> @go awkward squad marlow
19:42:21 <lambdabot> http://research.microsoft.com/~simonpj/
19:42:21 <lambdabot> Title: Simon Peyton Jones
19:42:49 <vincenz> > 1
19:42:51 <lambdabot>  ghc-6.6: could not execute: gcc
19:42:52 <jfredett> I've read quite a number of papers on them, Haskell Wikibook, YahT, millions.
19:42:52 <vincenz> @join #oasis
19:43:08 <chadz> jfredett: try this one :)
19:45:22 <jfredett> you know the best thing about Hoogle's documentation- all the various docs for the operators/etc have complexity info
19:55:36 <hpaste>  int80h annotated "int80_h borks parser" with "int80_h borks parser, the revenge " at http://hpaste.org/311#a1
19:56:04 <int80_h> I have new problems, pretty sure not related to the old ones.
19:56:25 <jfredett> so heres a conceptual question about monads
19:56:25 <jfredett> say I have a return value of Maybe a, I know that I get out either Nothing or Just x, where x is a value with type a.
19:56:25 <jfredett> is there a way to get the x value out of the just x permanently? rather than having to use >>= all the time?
19:57:35 <oerjan> jfredett: use a case statement
19:58:00 <jfredett> ediboh?
19:58:02 <jfredett> as in:
19:58:25 <jfredett> case blah of
19:58:25 <jfredett>     Just x = x
19:58:25 <jfredett>     Nothing = <something else>
19:58:26 <jfredett> ?
19:58:31 <oerjan> right
19:58:39 <jfredett> you mean- that will work?
19:58:44 <jfredett> I pulled that out of my ass
19:58:48 <jfredett> I thought that was pseudocode
19:58:59 <oerjan> actually = should be -> but the rest is correct
19:59:20 <jfredett> holy crap dude, I love haskell.
20:00:59 <int80_h> oerjan, any ideas on how I can fix my borked parser?
20:01:08 <int80_h> yeah haskell is my new true love.
20:02:16 <oerjan> int80_h: there is some serious junk in the original
20:02:50 <int80_h> oh I can repaste with the new code, I expect the junk is gone now
20:03:02 <oerjan> no, it's still there
20:03:20 <oerjan> (in your "revenge")
20:04:06 <oerjan> from the line with "Either ParseError b" things don't make sense
20:04:44 <int80_h> arg...this was supposed to be working code from some guy's blog
20:04:54 <int80_h> could you take a look at his blog to help me figure things out?
20:05:02 <int80_h> I posted his url
20:05:04 <oerjan> i'll take a look at the _actual_ original
20:05:22 <int80_h> yeah it started with me cutting and pasting
20:07:00 <oerjan> ah right, there is some code in the original that is just comments, not supposed to be included in the final source
20:09:16 <oerjan> remove the lines "Either ParseError b", "fmap", "main" and "fmap"
20:09:24 <int80_h> oh...garrrrr
20:11:15 <int80_h> still getting complaints about ubst s m = unwords $ map (\x-> Map.findWithDefault x x m) (words s)
20:11:29 <int80_h> oops
20:11:40 <int80_h> that was bad...did that make sense on what line is troublesome?
20:12:06 <int80_h>  subst s m = unwords $ map (\x-> Map.findWithDefault x x m) (words s)
20:12:22 <int80_h> parser.hs:25:13: parse error on input `='
20:13:19 <int80_h> what just happened? Netsplit?
20:13:23 <oerjan> int80_h: remove the indentation on that line
20:13:28 <int80_h> thanks
20:14:05 <oerjan> and also on "main = " if you haven't already
20:14:37 <int80_h> yeah I just did and now I get the following errors
20:15:06 <int80_h> parser.hs:10:38: Couldn't match expected type `Char' against inferred type `[Char]' In the first argument of `char', namely `":"' In the second argument of `manyTill', namely `(char ":")' In a 'do' expression: nadsat <- anyChar `manyTill` (char ":")
20:15:10 <int80_h> Failed, modules loaded: none.
20:15:34 <int80_h> is this referring to the original problem?
20:15:46 <oerjan> i did tell you above you needed to change ":" to ':' :)
20:16:11 <jfredett> you should just reverse the polarity on the flux capacitor function on line 36
20:16:22 <jfredett> that'll fix everything, int80_h.
20:16:24 * int80_h giggles
20:16:33 * int80_h pokes jfredett
20:18:35 * int80_h wuves oerjan
20:18:42 <int80_h> thanks guy, it compiles
20:18:52 <jfredett> hey! thats a bad touch!
20:18:55 * jfredett crys
20:31:28 <siti> does alloca zero the memory it allocates?
20:33:56 <jfredett> is there a wayto check what instances a certain type implements?
20:34:03 <jfredett> w/ ghci or lambdabot?
20:34:24 <ddarius> Try :info
20:34:29 <jfredett> :info String
20:34:32 <jfredett> ?
20:34:37 <ddarius> In GHCi
20:34:49 <jfredett> oh.:/
20:35:09 <ddarius> Or just look at the documentation pages which should list at least the ones defined in that module.
20:35:36 <jfredett> cool
20:35:42 <jfredett> info didn't help much
20:35:47 <jfredett> i guess its to hoogle for me
20:36:29 <ddarius> jfredett: You shouldn't really need that information.  You should more need to know whether a specific (collection of) instance(s) exist.
20:37:26 <jfredett> well, i just want to know whether String is orderable
20:37:43 <jfredett> or whether I'm going to rethink my methods.
20:38:35 <sjanssen> jfredett: yes, String is an instance of Ord
20:38:49 <jfredett> awesome, i figured it would be
20:40:30 <oerjan> @help instances
20:40:31 <lambdabot> instances <typeclass>. Fetch the instances of a typeclass.
20:40:41 <oerjan> @instances Ord
20:40:43 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
20:40:43 <jfredett> brilliant.
20:41:26 <jfredett> and since String = [Char], String is orderable, awesome
20:42:02 <sjanssen> parametric polymorphism with typeclasses ftw
20:42:41 * jfredett mimics Howard Dean, "Yaaarrghh"
20:43:57 <emu> man where do they have FIOS in pit
20:53:35 <oerjan> @instances-importing Ord
20:53:36 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
21:06:05 <lispy> what is Product a?
21:06:13 <lispy> i haven't seen that before
21:06:22 <lispy> same with sum
21:06:32 <lispy> ?google Product
21:06:34 <lambdabot> http://en.wikipedia.org/wiki/Product_(business)
21:06:34 <lambdabot> Title: Product (business) - Wikipedia, the free encyclopedia
21:06:41 <ddarius> @index Produce
21:06:41 <lambdabot> bzzt
21:06:41 <lispy> ?hoogle Product
21:06:42 <lambdabot> Prelude.product :: Num a => [a] -> a
21:06:43 <ddarius> @index Product
21:06:43 <lambdabot> bzzt
21:06:58 <ddarius> It's newish related to Monoids.
21:07:03 <ddarius> @doc Data.Monoid
21:07:04 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Monoid.html
21:07:19 <lispy> ?. tiny-url doc Data.Monoid
21:07:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "doc"
21:08:38 <ddarius> @help docs
21:08:39 <lambdabot> docs <lib>. Lookup the url for this library's documentation
21:08:48 <ddarius> @. tiny-url docs Data.Monoid
21:08:50 <lambdabot> http://tinyurl.com/y5qk9n
21:10:43 <lispy> thanks
21:17:22 <sam-j> does anyone know of any documentation or tutorial regarding Text.ParseCombinators?
21:18:58 <sam-j> (other than the official docs, that is)
21:19:45 <sam-j> ah, nevermind I think I just found it.
21:27:36 <Cale> sam-j: There's the Parsec documentation.
21:28:28 <sam-j> Cale: Yes I just found it and it's quite good. I looked a bit this afternoon but I think I just googled for the wrong terms. Thanks. :)
21:50:43 <shachaf> dons: /last dons
21:50:47 <shachaf> Oops.
21:51:57 <dons> ?pong
21:51:58 <lambdabot>   CSE	 : "Abdullah","Lili Marziana","PhD Student","ATP  Australian Technology Park","","lilia"
21:51:58 <lambdabot> CSE	 : "Ahmed","Nadeem","Research Fellow","K17 501E","57229","nahmed"
21:51:58 <lambdabot> CSE	 : "Ahmed","Shabbir","PhD Student","K17 501-19","55301","shabbira"
21:51:58 <lambdabot> CSE	 : "Akand","Elma Hussana","PhD Student","K17 401-02","56913","akande"
21:51:58 <lambdabot> CSE	 : "Al-Kilidar","Hiyam","PhD Student","ATP Australian Technology Park","","hiyama"
21:52:00 <lambdabot> [325 @more lines]
21:52:00 <dons> huh
21:52:03 <dons> oh, yes.
21:52:07 <dons> ?ring dons
21:52:07 <lambdabot>   CSE	 : "Stewart","Donald","PhD Student","K17 501-16","57225","dons"
21:52:09 <dons> :}
22:19:45 <dons> another amazing sigfpe/monad post, http://programming.reddit.com/info/1z0on/comments
22:19:46 <lambdabot> Title: How to write efficient optimzation code without really trying (reddit.com)
23:11:11 <hpaste>  gattocarlo pasted "problems with Xlib.FontStruct" at http://hpaste.org/312
23:26:06 <pastorn> dons: you there?
23:26:22 <dons> yep
23:26:34 <pastorn> you know farre?
23:26:44 <dons> no?
23:26:47 <pastorn> anyway, he told me you were working on a book
23:26:57 <dons> right.
23:26:58 <gour> dons: hi, how many chapters of 'real-world' are already written? ;)
23:27:05 <dons> 1 1/2?
23:27:34 <pastorn> how many chapters are planned?
23:28:06 <dons> lots :-) see http://www.realworldhaskell.org/blog/2007/05/23/real-world-haskell-its-time/
23:28:08 <lambdabot> Title: Real World Haskell » Blog Archive » Real-world Haskell: it&#8217;s time!, http://tinyurl.com/2ddm5b
23:30:00 <gour> dons: any estimation how bulky the book would be?
23:30:18 <dons> fairly big, i suspect
23:30:22 <dcoutts> door stopper
23:33:02 <gour> dons:that's great. just do it. i'll buy one for sure. do you have any date in mind how long it would take?
23:34:17 <gour> dcoutts: due to your reviews ?
23:34:29 <dcoutts> gour: huh?
23:34:59 <gour> dcoutts: i mean book will become bulky after you send your 'patches' in review-form ;)
23:35:05 <dcoutts> heh heh
23:35:29 <dcoutts> I would not dream of telling them what to do :-)
23:35:48 <gour> you're still enjoying life, holidays etc. in the form of  R&D ?
23:35:50 <gattocarlo> dcoutts: we have a cabal issue with xmonad
23:36:09 <gour> dcoutts: or realy holidays now?
23:36:14 <gour> *real
23:36:30 <dcoutts> gattocarlo: sorry, got to sleep, send email to cabal-devel or me or xmonad list or something, or tell me next time I'm around
23:36:40 <gattocarlo> the haddock hook treats libraries differently from exec
23:36:41 * dcoutts :: IO Sleep
23:36:42 <dons> gattocarlo: yes, cabal list is best.
23:36:42 <gattocarlo> ok
23:36:48 <gattocarlo> ok
23:37:06 <dons> if you come up with a patch to cabal to allow execs to get haddocks built, i'd be pretty confident it would be accepted
23:37:18 <gattocarlo> sorry guys, 'night
23:38:31 <emu> anyone got recommendations on a good blog for haskell posts w/ code
23:38:56 <dons> a good blog oftware?
23:39:00 <emu> yea
23:39:23 <dons> hmm. see what sigfpe or ekidd use. anythiing that let's you embed HsColour -css output
23:39:53 <emu> oh dons btw, my bottleneck turned out to be some weirdness with ST
23:40:55 <dons> interesting.
23:41:12 <gour> @localtime dcoutts
23:41:13 <lambdabot> Local time for dcoutts is Sun Jun 17 07:39:41
23:41:34 <gour> huh, nice time for going to bed...
23:42:08 <emu> mornings are meant to sleep through
23:42:37 <dons> i don't think that's duncan's current time zone though..
23:42:37 <gour> emu: worst time for sleep if you want to stay healthy ;)
23:43:05 <gour> dons: right, that's utc
23:43:09 <emu> dons: yea it makes no sense.  locally, ST is fine.  but there, it causes some serious problems.  IOUArrays were blazing fast otoh, with the same exact code.
23:43:54 <sjanssen> emu: strangest of all: IOUArrays are simple wrappers around STUArrays
23:44:04 <dons> i've found some issues with optimsing ST code -- but that's weird. as IO*Array is just a layer over ST*Array
23:44:16 <dons> maybe some extra strictness got inserted somewhere
23:44:30 <emu> and even stranger, i just tried to rewrite another program from ST to IO arrays, and that made things worse
23:44:34 <dons> for true speed, nothing beats !Ptr Foo though. (though also, nothing is more dangerous ;)
23:44:57 <emu> i was breaking out FFI .. i wanted to use strtoul for number parsing
23:45:21 <emu> it would work in byte-code toplevel but crash in compiled code :/
23:45:44 <dons> yeah, FFI makes  a nice flexible ST monad, but also more dangerous
23:47:46 <ariks> data Color = RGB Int Int Int | CMYK Int Int Int Int deriving (Eq, Show)
23:47:46 <ariks> [B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[B[BB[B[B[B[B[B
23:48:16 <ariks> bah, sorry. touchpad has a damn "middle click" spot.. that i accidentally hit
23:48:36 <ariks> i'll look into disabling that right now.
23:48:57 <emu> dons: i'd imagine its some weird stirctness thing, except that i couldn't replicate the behavior locally
23:51:58 <rhz> I have a Haskell program which is freezing at some certain point. Can I trace through it somehow to work out which function is causing it to freeze?
23:52:39 <Cale> Debug.Trace will let you annotate expressions with messages to be printed when they're evaluated.
23:53:21 <rhz> Ok but the problem is that I don't want the console to be flooded with messages.
23:54:05 <rhz> I only want to work out what is going on when the program freezes which is about 10 seconds into it.
23:54:41 <ibid> use binary search with trace
23:54:57 <ibid> put trace somewhere. if you get the message, it's before the freeze
23:55:20 <ibid> (of course, laziness makes determining "before" a bit tricky)
