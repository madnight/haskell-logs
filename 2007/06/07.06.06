00:00:03 * mwc desperately needs a translation of the terms: aakkonen, dirikka, and nirritin
00:00:17 <opqdonut> mwc: aakkonen is alphabet (singular)
00:00:23 <opqdonut> dirikka means directory (computer slang)
00:00:30 * mwc is working on finnish source
00:00:32 <opqdonut> nirritin can be almost anything (slang too)
00:00:41 <mwc> opqdonut: nirritin == stuff?
00:00:54 <opqdonut> nirritin == something that does something
00:01:07 <Jaggederest> function maybe?
00:01:11 <Korollary> I didn't know shapr knew finnish. He lived in Sweden for a while.
00:01:17 <opqdonut> [rambo:~]% echo $(( log(24) ))
00:01:17 <opqdonut> 3.1780538303479458
00:01:17 <opqdonut> [rambo:~]% echo $(( log(20) ))
00:01:17 <opqdonut> 2.9957322735539909
00:01:17 <opqdonut> [rambo:~]% echo $(( log(24) ))
00:01:19 <opqdonut> 3.1780538303479458
00:01:21 <opqdonut> [rambo:~]% echo $(( log(20) ))
00:01:24 <opqdonut> 2.9957322735539909
00:01:26 <opqdonut> [rambo:~]% echo $(( log(24) ))
00:01:29 <opqdonut> 3.1780538303479458
00:01:31 <opqdonut> [rambo:~]% echo $(( log(20) ))
00:01:34 <mwc> I was hoping he'd picked a bit up... they share a border IIRC
00:01:34 <opqdonut> 2.9957322735539909
00:01:36 <opqdonut> woops
00:01:39 <opqdonut> sorry
00:01:41 <opqdonut> mispaste
00:01:44 <opqdonut> i doubt it
00:01:45 <Korollary> no problem, John.
00:02:12 <TSC> I'll stop trying to determine the meaning hidden in the logarithms...
00:02:37 <Jaggederest> me too. I was thinking 'Close to pi...'
00:03:01 <opqdonut> actually i just had to demonstrate that log(20)<3<log(24)
00:03:11 <opqdonut> in order to deliver the punchline of a bad in-joke
00:03:15 <Jaggederest> ?
00:03:16 <mwc> thanks alot opqdonut
00:03:23 <opqdonut> np, mwc
00:03:27 <Jaggederest> now you have to tell it :)
00:03:31 <kolmodin> in QuickCheck, what's the common thing to do if you want to verify that your code throws an 'error "foo"' ?
00:03:35 <Korollary> No he doesnt
00:04:15 <mwc> opqdonut: uhm... is there a possibility aakkonen could mean grammar or parser?
00:04:23 <mwc> or would that most likely be a diff't word?
00:04:30 <opqdonut> mwc: aakkonen is letter basically
00:04:46 <opqdonut> parser is usually "parseri" or "jäsennin"
00:04:47 <skew> kolmodin: you need to be in IO to catch
00:05:00 <mwc> Ah, okay, I was thinking it had something to do with lexical analysis
00:05:01 <mwc> thanks
00:05:35 <opqdonut> Jaggederest: well in short the name of the next class here at my school will be "log", and there will be 24 of them. The class size used to be 20. Thus showing that log(20) <3 (notice the heart) but log(24) >3 (no heart) is droll in some way
00:05:47 <kolmodin> skew: yeah, I guess I have to write that myself... otoh it'll be like one line.
00:06:39 <opqdonut> mwc: well aakkonen might be lexical symbol, actually
00:06:55 <mwc> opqdonut: that's what I'm figuring at this point.
00:07:02 <opqdonut> yeah, sounds logical
00:07:25 <mwc> Now I just need to figure out what nirritin does... all the comments and identifiers (other than the std lib) are Finnish ;)
00:07:54 <skew> mwc: that's the real test of "self-documenting" code
00:08:00 <hpaste>  Itkovian annotated "swap" with "simpler but perhaps less efficient" at http://hpaste.org/190#a2
00:08:16 <mwc> skew: lol, except generally you count on the identifiers to well, identify ;)
00:08:39 <skew> I like alpha equivalence
00:09:50 <mwc> I'm guessing Filterri means filter... now what's Koostenimi?
00:09:51 <skew> more to the point, my compilers doesn't read so good, so if something's going to be handled automatically it better not rely on identifiers meaning anything
00:10:53 <opqdonut> mwc: koostenimi is compound name
00:10:56 <mwc> I'm reminded of a scifi book I heard about where the future saw archeologists digging through old code
00:11:01 <mwc> opqdonut: thanks again
00:11:04 <opqdonut> :)
00:11:31 <mwc> I'd try feeding this through babelfish, but it doesn't do finnish :(
00:18:41 <Wild_Cat> mwc: I wouldn't call that kind of book sci-fi. Horror seems more appropriate.
00:19:14 <mwc> Wild_Cat: amen
00:36:26 <dons> ?yow
00:36:26 <lambdabot> Did I do an INCORRECT THING??
00:37:41 <opqdonut> ?. elite yow
00:37:42 <lambdabot> YOW!! nOw i uND3rzTanD 4d\/aN(ED /\/\icr08iOlOgY 4nd +|-|' NE\/\/ TAX R3ph0r/\/\ Laws!!
00:37:44 <Pseudonym> Woo!
00:38:11 * Pseudonym sighs a big sigh of relief
00:38:20 <dons> ?. lolcode yow
00:38:21 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "lolcode"
00:38:22 <dons> doh!
00:38:33 <Pseudonym> *PolyReduce_Test> prettyPrint p1
00:38:33 <Pseudonym> "x^2*(e^x)^2"
00:38:33 <Pseudonym> *PolyReduce_Test> prettyPrint ex1
00:38:34 <Pseudonym> "(((1/2*x^2 + 1/2*x + 1/4)*(e^x)^2),0)"
00:38:44 <Pseudonym> Note that the second expression is the integral of the first.
00:38:44 <dons> oh, that's pretty cute
00:39:13 <dons> writing a HW paper, then, Pseudonym ? :-)
00:39:21 <Pseudonym> Blog entry, actually.
00:39:43 <dons> i was going to say. function differentiation is the monad tutorial of 2007.
00:39:56 <Pseudonym> Except this isn't differentiation, it's integration.
00:40:12 <Pseudonym> Which won't be the monad tutorial for quite some time, I suspect.
00:40:17 <dons> you've got a blog?
00:40:22 <Pseudonym> Kinda.
00:40:25 <mwc> lol, be sure to introduce non-determinism in [] to account for the constant of integration
00:40:29 <dons> is it a darcs repo?
00:40:30 <Pseudonym> http://andrew.bromage.org/blog/
00:40:31 <lambdabot> Title: The BWAIN
00:40:39 <dons> oh, its a real blog
00:40:42 <Pseudonym> This code isn't in a darcs repo yet.
00:40:43 <dons> wow
00:40:53 <Pseudonym> But parts 1-3 with the theory so far are there.
00:40:55 <mwc> night all
00:41:03 <dons> did you not tell us about this secret blog, Pseudonym ?
00:41:11 <dons> or did i just not have my spiny sense on.
00:41:18 <Pseudonym> You haven't been on haskell-blah at the right time of day, clearly.
00:41:27 <dons> oh, -blah.
00:41:53 <Pseudonym> Actually, I'd appreciate a proofread of the first three integration entries.
00:42:08 <Pseudonym> Just want to know if it's pitched at the right level or not.
00:42:17 <dons> why don't i just drop it by reddit, and sigfpe can comment? :-)
00:42:30 * Pseudonym laughs
00:42:45 <Pseudonym> *PolyReduce_Test> putStrLn $ prettyPrint p2
00:42:46 <Pseudonym> 2*(tan x)^2 + (tan x) + 1
00:42:46 <Pseudonym> *PolyReduce_Test> putStrLn $ prettyPrint ex2
00:42:46 <Pseudonym> ((2*(tan x)),((tan x) + -1))
00:42:49 <dons> not enough code fragments :)
00:42:55 <dons> my eyes wander for chunks of haskell code to hang on to
00:42:59 <Pseudonym> Note that the second element of the tuple is the bit that the polynomial reduction can't handle./
00:43:07 <dons> ahh heh
00:43:14 <Pseudonym> So the integral of 2*(tan x)^2 + (tan x) + 1
00:43:24 <Pseudonym> is 2 tan x plus the integral of tan x - 1.
00:43:38 <Pseudonym> Early days yet, though./
00:43:56 <Pseudonym> The full Risch algorithm is probably 20+ blog entries.
00:46:20 <Pseudonym> 500 lines of Haskell so far, including re-implementing about 20% of the numeric prelude.
00:46:20 <dons> wow.
00:46:20 <dons> i hope you intend to get this on hackage.
00:46:20 <Pseudonym> I hope to get it finished!
00:46:20 <dons> the state of all the math stuff is kinda fragmented -- we need a haskell/math consortium
00:46:20 <Pseudonym> It was a bit of a coincidence that someone suggested re-implementing Mathematica right AFTER I started this.
00:46:20 <dons> that was one of the more bizarre threads i've seen on haskell-cafe@ recently
00:46:23 <dons> the community is growing and changing in funny ways
00:46:24 <Pseudonym> Yeah.
00:46:45 <Pseudonym> There's an appropriate youtube video that applies to that thread.
00:47:13 <Pseudonym> If I can find it.
00:47:37 <dons> haskell-cafe@ seems to attract cranks periodically
00:50:06 <Pseudonym> Never mind.  It's a guy who does this game show: "Sarcasm, Moron or Nut Job".
00:50:21 <Pseudonym> When someone says something clearly contrary to reality, it's one of the three.
00:50:38 <dons> jhehe
00:51:34 <Pseudonym> OK, gotta go.
00:51:44 <Pseudonym> Got stuff working, so I can go now. :-)
00:51:44 <Pseudonym> Night.
00:53:59 <swiert> Has anyone here managed to build ghc-devel from Darwinports?
01:01:41 <dons> swiert: hmm. pretty sure chilliX has
01:01:52 <dons> oh, actually, no, he'd have built from src
01:02:55 <swiert> dons: Ok. Thanks anyhow.
01:25:02 <LeCamarade> What are the disadvantages of recursion? I am a bit worried, since I only think in recursion, after all this Haskell time. (I swear, I haven't written an imperative loop in about 6 months.)
01:25:15 <LeCamarade> I need to be scared out of this silliness.
01:25:16 <skew> disadvantes?
01:25:22 <LeCamarade> Help.
01:25:23 <skew> hmm
01:25:27 <LeCamarade> skew: Yes.
01:25:33 <dons> what's the disadvantages of a loop?
01:25:36 <LeCamarade> Bad things. Negative things. Evil things.
01:25:46 <dons> to illustrate why the question is a bit weird ;)
01:26:03 <LeCamarade> dons: I don't want to loop when I mean to fold. Blame this guy:
01:26:10 <LeCamarade> @go what is wrong with the for loop
01:26:13 <lambdabot> http://notes-on-haskell.blogspot.com/2007/02/whats-wrong-with-for-loop.html
01:26:13 <lambdabot> Title: Notes on Haskell: What's Wrong with the For Loop
01:26:14 <LeCamarade> ^^
01:26:19 <skew> some shoddy language implementations consume stack space with every recursive call, even if it's obviously tail-recursive
01:26:53 <LeCamarade> skew: Yes. Like Ruby. But I just make myself believe I won't recurse 250000 times.
01:27:02 <LeCamarade> So that isn't strong 'nough.
01:27:06 <LeCamarade> :o(
01:27:07 <dons> also, writing an explicit loop (i.e. with recursion ) can often be avoided in favour of particular useful loop forms, like map, filter, fold or unfold
01:27:10 <skew> oh, ruby is broken too?
01:27:25 <dons> most of that brand of languages seem to be broken wrt. recursion
01:27:57 <skew> lua gets it right, or has a very good excuse, I forget which
01:28:14 <LeCamarade> dons: Yes, I use folds and maps instead of loops. Ruby (not JRuby, though, I'm made to believe) has bad TCO.
01:28:30 <opqdonut> i think lua has TCO
01:28:32 <skew> heck, does Java have much TCO?
01:28:39 <skew> I know gcc tries
01:28:47 <Wild_Cat> LeCamarade: The JVM lacks TCO. I'd be surprised if JRuby did have it.
01:28:49 <dons> a quick overview:  http://shootout.alioth.debian.org/gp4/benchmark.php?test=recursive
01:28:51 <lambdabot> Title: recursive benchmark | Gentoo : Intel&#174; Pentium&#174;&nbsp;4 Computer Languag ..., http://tinyurl.com/yrp7xm
01:28:57 <dons> pretty graphic example of those languages that can't do recursion
01:29:11 <skew> oops
01:29:20 <dons> usual suspects dominate the tail of the list
01:29:20 <Wild_Cat> (and no, as a result Java doesn't have TCO either)
01:29:31 <LeCamarade> Wild_Cat: Lemme check about for the link ...
01:30:07 <dons> its an indictment on the relevant language designers, imo.
01:30:23 <dons> or maybe on the quality of teaching of language design principles.
01:30:47 <skew> there are even schemes that mis-implement tail calls
01:31:07 <dons> the memory usage on those graphs seems broken, i note
01:31:10 <skew> of course, when you conflate specification and implementation you can't use that excuse
01:31:11 <LeCamarade> But why does it have to be `tail'? Theoretically, isn't it possible to turn any recurion into a while loop?
01:31:22 <dons> LeCamarade: how do you think while loops are implemented?
01:31:32 <dons> they're just a particular tail recursive call. i.e. a goto
01:31:36 <skew> ruby#2 shows smaller memory consumption, and seems to be simple recursion
01:31:44 <Wild_Cat> that benchmark is sorted according to CPU time. If you look at memory consumption, you'll find that Ruby, Python et al. aren't bad at all.
01:31:50 <LeCamarade> Wild_Cat: http://ola-bini.blogspot.com/2007/01/yarv-tail-call-optimization-in-jruby.html
01:31:52 <lambdabot> Title: Ola Bini on Java, Lisp, Ruby and AI: YARV tail call optimization in JRuby, http://tinyurl.com/2mmjvz
01:32:01 <Wild_Cat> (144 megs for C++, what the hell?)
01:32:09 <dons> Wild_Cat: the 144,628 is wrong.
01:32:26 <skew> LeCamarade: CPS turns all calls into tail cals
01:32:33 <dons> note that a whole bunch of tests appear to come in at ridiculous memory use. the use of gtop to find peak memory use is clearly broken there.
01:33:08 <skew> ah, that tail call thing is much like the gcc hack
01:33:09 <dons> ah here's a fixed versoin:
01:33:10 <dons> http://shootout.alioth.debian.org/debian/benchmark.php?test=recursive
01:33:12 <lambdabot> Title: recursive benchmark | Debian : AMD&#8482; Sempron&#8482; Computer Language Bench ..., http://tinyurl.com/2n7rov
01:33:13 <dons> Wild_Cat: ^^
01:33:16 <Wild_Cat> yeah, I sure hope it is. 'Cause if it's not, there's an awful lot of languages that eat memory like they're Java.
01:33:38 <Wild_Cat> cheers, I'll have a look at it.
01:33:51 <dons> running time almost directly corresponds to whether you can do tail calls, in this test.
01:33:57 <dons> as does memory use.
01:34:41 <skew> hey, how does GHC #5 do it in 0 bytes of source?
01:34:59 <dons> apparently they don't maintain their system very well ;)
01:35:06 <Wild_Cat> runtime can't be trusted here. A lot of those (including Ruby) run on (slow compared to compiled code) VMs.
01:35:53 <dons> sure, doesn't mean the tested implementation isn't slow though.
01:36:37 <dons> so i'm pretty sure we can trust that the native code compilers will generally dominate the speed category.
01:36:40 <dons> no surprise.
01:37:13 <skew> they need instances big enough for implementations based on something like Levin search to win
01:39:09 <Wild_Cat> dons: of course. So you can't rely solely on run time to detect the TCO-ness of a language. A non-TCO'd, recursive C will outperform most VM-based languages no matter what.
01:39:25 <osfameron> TCO?
01:39:32 <skew> witness MzScheme
01:39:39 <osfameron> oh, tail call
01:39:40 <skew> but gcc does try to do some TCO
01:39:41 <mdmkolbe|wor1> Tail call optimized?
01:39:48 <osfameron> I was thinking "Total Cost of Ownership" :-)
01:39:48 <skew> certainly at least if a function tail calls itself
01:39:58 <skew> just like the case that ruby thing was talking about
01:39:59 <dons> yeah, the ones in the middle are suspect.
01:40:12 <dons> scheme, in particular.
01:40:38 <skew> but seriously, somebody needs to write some kind of JIT runtime that includes proof search
01:40:51 <LeCamarade> osfameron: Haskell would have a very high Total Cost of Ownership.
01:40:54 <LeCamarade> :o)
01:41:21 <osfameron> yeah, I wonder what Gartner have to say about it!
01:42:45 <mdmkolbe|wor1> dons: you're the original author for Yi right?
01:43:47 <dons> yeah
01:44:06 <dons> Thu Oct 14 12:22:28 EST 2004  dons@cse.unsw.edu.au
01:44:07 <dons>   * Initial import of riot-hsplugins as hemacs
01:44:08 <dons> :-)
01:44:18 <dons> oh, those were the days.
01:44:20 <mdmkolbe|wor1> :-)
01:44:33 <mdmkolbe|wor1> dons: It occured to me that Yampa's dpSwitch and Yi's "reboot the system to make a config change" might be two manifestations of the same thing.
01:44:55 <dons> up until the start of 2006. then jyp took over.
01:45:03 <dons> hmm.
01:45:08 <mdmkolbe|wor1> dons: I just wondered if someone more familiar with Yi might have an option on taht
01:45:17 <dons> there might be some connection. but yi uses hot code reloading in the runtime
01:46:00 <dons> there's a paper on the yi reloading architecture
01:46:28 <mdmkolbe|wor1> dons: yes, I've read that paper
01:48:53 <mdmkolbe|wor1> dons: I'm still trying to descide whether Yampa-dpSwitch/Yi-reboot are seem to be related in that they are manifestations of interfaces for suspending and restarting computation, but I'm not sure if that is someting trivial/obvious or if there could be some synergy by trying to generalize/unifiy the two ideas
01:51:04 <skew> if nothing else, it seems like that's the easiest way to get a semantics for upgrading code, writing out the old state and reading it into the new code
01:51:32 <skew> then you can just pretend the code was all part of one big happy program to begin with, and reason about it like any other code
01:53:46 <mdmkolbe|wor1> skew: provided you can get the turn-around time fast enough ;-).  e.g. a GUI for designing a simulated circuit might get reconfigured when edges are added so you'd better be able to do all that faster than a user can click the mouse
01:54:50 <skew> you can probably arrange to reconfigure something just locally
01:55:01 <skew> especially in yampa, when it's just shipping a new arrow to the right place in the graph
01:57:30 <mdmkolbe|wor1> skew: (playing devil's advocate) unless the circuit gets big enough or has big enough components in it that being local to the circuit graph isn't fast enough.  e.g. a circuit simulating a mother board that gets a pin on the CPU connected to the memory
01:57:58 <skew> I meant local like subgraph
01:58:29 <skew> if you are going to be replacing code, something has to be patched and state has to be fixed up somehoew
01:59:34 <mdmkolbe|wor1> skew: I was under the impression you could only do that with Yampa if the subgraph was it's own arrow and that even then you have to completely reload the component arrows of the subgraph even if you're just changing the routing between them (they might have large amounts of state inside them)
02:01:13 * mdmkolbe|wor1 has to go to a talk
02:01:27 <skew> well, if you can freely rewrite with arrow laws you should be able to make it cheap
02:02:01 <skew> turn it into big stateful arrows composed with a non-stateful one that does the routing
02:04:55 * mdmkolbe|wor1 is back after remembering that the talk date was moved
02:09:20 <skew> You should always be able to rewrite your stateful subgraph as loop (pure f &&& (stateful1 &&& (stateful2 &&& ...)))
02:09:30 <skew> then just swap out the pure part, with no fuss
02:10:51 <skew> not that you can necessarily do with with Yampa, I'm just trying to figure out how satisfying serialization and replacement might be as a formal model for hot loading code
02:13:06 <mdmkolbe|wor1> skew: that makes sense to me assuming that building each new routing function (in the Yampa sense of routing function) can be done quickly (almost certainly true)
02:14:21 <mdmkolbe|wor1> skew: I'm not sure if it works out as well when the routing isn't between parallel arrows, but between arrows in a complex graph (you could hack the arrows to be parallel again but that might introduce timing issues or make the routing function get hammered to much)
02:15:01 <mdmkolbe|wor1> i.e. in Yampa you have loop (route >>> (arr1 &&& (arr2 &&& (arr3 ...))))
02:17:29 <monstre> hello
02:18:40 <mdmkolbe|wor1> but in general you might have, route1 >>> ((arr1 >>> route2 >>> (arr2 &&& arr3)) &&& (arr4)) which could be non-trivial (even in terms of performance or maintainability) to factor out both the routing functions if they get nested deeply
02:18:46 <mdmkolbe|wor1> monstre: hello
02:20:22 <monstre> newbie question: what exactly is the point of the IO monad?
02:20:33 <quicksilver> so that you can do IO in a purely functional setting
02:20:34 <monstre> I think I understand the machinery involved, but what do you gain by isolating side effects in this way besides added complexity?
02:20:44 <quicksilver> added simplicity!
02:20:51 <quicksilver> better modularity
02:20:56 <quicksilver> better optimisations
02:20:59 <quicksilver> easier to reason about code
02:21:02 <quicksilver> better tests
02:21:03 <Lemmih> monstre: The alternative is no side-effects at all.
02:21:06 <mauke> __attribute__((__const__)) on all functions
02:21:14 <mdmkolbe|work> monstre: observe
02:21:20 <mdmkolbe|work> @type print
02:21:24 <lambdabot> forall a. (Show a) => a -> IO ()
02:21:36 <mdmkolbe|work> > let x = print "1" in x; x
02:21:36 <lambdabot>  Parse error
02:21:42 <mdmkolbe|work> > let x = print "1" in do x; x
02:21:44 <lambdabot>  <IO ()>
02:22:10 <mdmkolbe|work> err...does lambdabot support running the IO monad?
02:22:49 <ClaudiusMaximus> does yampa have a graphical graph editor?
02:23:09 <skew> dons does not want you to > System.removeDirectoryRecursive "/"
02:23:11 <quicksilver> mdmkolbe|work: no, otherwise you could launch nuclear missile with it
02:23:13 <mdmkolbe|work> monstre: anyway, that 'let' should print *twice* b/c the IO in print isn't a side effect as much as it is an encapsulated *potential* computation
02:23:54 <bluestorm_> monstre: generally, having a pure language has lots of advantages
02:24:54 <dons> isloating side effects in a monad, and tagging them with a separate type, means lambdabot can execute random user code directly.
02:24:55 <bluestorm_> i'd say you can work algebraically on your program
02:25:09 <monstre> I can see that the IO monad is a good way to sequence side effects in a pure language, I'm just not entirely sure why I would want to program in such a language
02:25:30 <LeCamarade> monstre: It is added complexity only in the first instar. Later on, you will be writing C programs with _your own IO monads_. I promise.
02:25:36 <bluestorm_> hum
02:25:37 <bluestorm_> monstre:
02:25:45 <bluestorm_> in the Wadler paper i read to understand monads
02:26:01 <bluestorm_> there was a demonstration where monads for I/O actually simplified the code
02:26:10 <Wild_Cat> also, in theory, knowing which parts of your program are pure enable the compiler to perform a lot of optimizations
02:26:22 <mdmkolbe|work> monstre: b/c your program will be ten times smaller (in lines of code), and less likely to have bugs
02:26:29 <bluestorm_> at some point he showed "and then you can do *that* for free, whereas with a traditionnal I/O system it would be hell a lot harder"
02:26:30 <skew> Wild_Cat: in practice as well - see stream fusion
02:26:45 <monstre> I guess my question isn't so much about the IO monad, but rather the motivation for functional programming to begin with
02:26:47 <dons> yeah, side effects kill compilers
02:26:50 <skew> Wild_Cat: and many other optimizations as well, but that's the shiny new toy
02:26:50 <bluestorm_> monstre:
02:26:51 <Wild_Cat> e.g. if, in a given expression, it sees the same pure function call twice, it knows both will evaluate to the same result. So the computation is only performed once.
02:26:56 <bluestorm_> see a really simple optimisation like
02:27:09 <skew> monstre: read "Why Functional Programming Matters"
02:27:11 <LeCamarade> monstre: It is simply an assurance that yout functions are not affected by the outside world. For example ... hey, what's that string.h function that uses a static size_t to track stuff?
02:27:11 <Wild_Cat> there's also auto-parallelization.
02:27:15 <bluestorm_> map f (map g (something)) -> map (f . g) something
02:27:19 <LeCamarade> I have never grokked it.
02:27:24 <monstre> skew: I have, not much help if you ask me
02:27:24 <dons> monstre: i guess at the very bottom of it all, traditional side effecting imperative code is very very hard to understand. FP languages aim to simplify all that.
02:27:25 <bluestorm_> you can't do that if your language is impure
02:27:31 <dons> all other points flow from this.
02:27:49 <LeCamarade> skew: That paper only makes sense when you've done FP already.
02:27:55 <skew> hard to manipulate, mostly
02:28:08 <skew> LeCamarade: oh, does it?
02:29:01 <LeCamarade> skew: At least it just sounded like empty, silly, self-righteous rambling from Yet Another Academic. Until I did Haskell.
02:30:03 <monstre> I thought the paper made a nice case for higher-order functions and lazy evaluation...
02:30:18 <LeCamarade> There is that string.h function that I never understood, because it had state info. State is not visible from the function definition, and that makes some programs hard to grok.
02:30:18 <mdmkolbe|work> monstre: lazy eval is *very* hard in an impure language
02:30:19 <skew> funny, I find it's usually the academics that do not write things that are empty
02:30:21 <mauke> monstre: lazy evaluation and side effects don't mix
02:30:34 <mauke> LeCamarade: strtok
02:30:47 <skew> well, sometimes papers just have gobs of equations...
02:30:57 <monstre> well, I'm not entirely sold on lazy evaluation either, but that's another story...
02:31:13 <LeCamarade> mauke: Thanks a lot.
02:31:13 <Wild_Cat> oh, good point, Haskell's very first optimization-ish feature.
02:31:33 <mauke> monstre: functional programming is fun, and it makes sense to me :-)
02:31:56 <Wild_Cat> there's a steep initial learning curve to FP, though.
02:31:57 <mdmkolbe|work> monstre: in mathematics you can manipulate equations and transform them and make proofs about them, pure functional programming does the same for programming.
02:31:59 <bluestorm_> monstre: you may be interested in http://homepages.inf.ed.ac.uk/wadler/papers/marktoberdorf/baastad.pdf
02:32:01 <skew> monstre: every kind of deforestation ever requires pure functions
02:32:02 <lambdabot> http://tinyurl.com/zhxow
02:32:19 <LeCamarade> monstre: I am afraid FP is supposed to be hated until you have crossed some point and you just can't stand anything else. It is a recursive thing, I think.
02:32:34 <monstre> I guess what I'm trying to convey here is that the limitations of functional prgramming are immediately visible to an imperative programmer, but the advantages, not so much
02:32:43 <mdmkolbe|work> > let x = 1:x in take 5 x --lazy eval
02:32:44 <lambdabot>  [1,1,1,1,1]
02:33:02 <schme`> monstre: imperative programmers haven't had their mind twisted yet (:
02:33:03 <mauke> mdmkolbe|work: not really, you can do that in OCaml
02:33:05 <skew> well, the advantages are only obvious if you think about your code
02:33:10 <LeCamarade> mdmkolbe|work: Brilliant idea. Show some Haskell-fu.
02:33:16 <bluestorm_> mauke: but ocaml use lazy eval for that :)
02:33:20 <mdmkolbe|work> monstre: I would agree with that
02:33:23 <mauke> bluestorm_: how so?
02:33:31 <JohnMeacham> anyone have some handy code to take a string and pipe it through an external unix command and get a new string lying around?
02:33:38 <bluestorm_> there is lazy evaluation support in ocaml
02:33:45 <LeCamarade> > map (* 2) [1 .. 5] -- You need a whole 5-line loop for this in other languages.
02:33:46 <lambdabot>  [2,4,6,8,10]
02:33:47 <bluestorm_> (Stream, Lazy, and recursive lists)
02:34:14 <mauke> how are recursive lists lazy?
02:34:16 <skew> more restrictions on code pay off in more properties for reasoning with, and more rewrites that are valid
02:34:38 <mauke> LeCamarade: map { $_ * 2 } 1 .. 5   # perl is FP now?
02:34:45 <bluestorm_> mauke: i guess it's a special thing for immediate recursive values
02:34:51 <bluestorm_> it's a "language extension" anyway
02:35:04 <LeCamarade> mauke: Perl is more FP than people like to accept.
02:35:35 <skew> JohnMeacham: have you checked missingH?
02:35:46 <LeCamarade> Many languages are FP enough, but side-effect friendliness undoes the delicate work. Plus I think in terms of pattern-matching, these days. :o)
02:35:53 <LeCamarade> So that cuts out many.
02:36:27 <quicksilver> I'm pretty sure that lists are not lazy by default in ocaml
02:36:35 <quicksilver> unless it's changed a lot since I last used it
02:36:42 <quicksilver> you have to explicitly ask for the lazy type if you want it
02:36:43 <Wild_Cat> Pattern matching isn't a FP-specific feature, though. It's a shame more languages don't have it.
02:36:45 <mdmkolbe|work> > let facs = scanl (*) 1 [1..]; fac n = facs !! n in fac 3 -- from the evolution of a haskell programmer
02:36:46 <lambdabot>  6
02:37:13 <LeCamarade> quicksilver: No, they are not. There is a Lazy module (much like Scheme promises) but ... no, not lazy.
02:37:16 <bluestorm_> quicksilver: but i think self-recursive lists are implemented lazily
02:37:18 <monstre> so would it be fair to say that the argument in favour of FP is basically that pure functions are simpler to understand/reason about than imperative code?
02:37:20 <quicksilver> did somebody just describe John Hughes as "empty, silly and self-righteous"? *boggle*
02:37:29 <monstre> or is there something else I'm missing?
02:37:31 <Wild_Cat> monstre: mostly, yeah.
02:37:38 <mdmkolbe|work> monstre: I would agree with that
02:37:47 <mauke> bluestorm_: no, they aren't
02:37:59 <Wild_Cat> that, and the nifty tricks that derive from that (optimization and all)
02:38:04 <skew> monstre: and transform
02:38:10 <dons> monstre: that's an argument for pure FP, not FP in general though.
02:38:14 <LeCamarade> Wild_Cat: Yeah. Indeed. My ultimate C (I very nearly wrote it) would have pattern-matching on structs and type-inference. At the very least.
02:38:31 <mdmkolbe|work> monstre: if 'a' and 'b' are pure, then let x = a (); y = b() in x + y is the same as let y = b(); x = a () in x + y
02:38:32 <skew> monstre: and simple enough to do all that stuff for that it can actually be automated, and stuck in compilers
02:38:38 <Wild_Cat> LeCamarade: Type inference is probably the best thing ever. It's not FP-specific either.
02:39:15 <Wild_Cat> now that I think about it, a lot of the things I really like in Haskell aren't FP-specific, yet don't exist in any non-FP language that I know of.
02:39:23 <quicksilver> monstre: it's not "the argument" no
02:39:24 <flux> lecamarade, c++0x has some type inference, you can declare types of variables to be 'auto' (which is different from 'auto' for memory management)
02:39:25 <skew> JohnMeacham: http://software.complete.org/missingh/static/doc/System-Cmd-Utils.html
02:39:27 <mdmkolbe|work> monstre: I can fold 'a' and 'b' in, or factor them out with strait copy and paste style reasoning (or more formally equational reasoning)
02:39:27 <lambdabot> http://tinyurl.com/wfqgr
02:39:32 <quicksilver> monstre: the discussion isn't simple enough to have "one" argument
02:39:40 <LeCamarade> monstre: But that's not all. You can't do that map thing in Java. At all. In any way. I write, in one cheap line, the equivalent of sixteen Java classes (ie, sixteen Java files).
02:39:49 <monstre> so what other arguments are there then?
02:39:52 <quicksilver> monstre: another argument is that functional programming permits import forms of modularity
02:40:05 <quicksilver> such as those allowed by higher-order-functions and lazy evaluation
02:40:13 <quicksilver> (this is roughly Hughes' point)
02:40:41 <monstre> I agree that those are good points
02:40:45 <LeCamarade> flux: C++0x will probably rock, but I don't see how type-inference stayed out of the mainstream so long. And C++ is evil for having been new with old, tired ideas.
02:40:50 <quicksilver> Another argument really relates to strong type systems; this argument is that having a strong type system prevents very many errors
02:40:52 <Wild_Cat> higher-order functions are more of an argument in favor of languages that aren't half-arsed, though.
02:40:59 <monstre> they just don't have much to do with purity so far as I can tell
02:41:16 <skew> try making a lazy impure language!
02:41:23 <skew> or, try making program in it
02:41:27 <quicksilver> however, it's quite hard to encapsulate 'enough' information in your type system without purity
02:41:29 <mauke> .oO( enumFromTo(1, 5).map(new Times(2)) )
02:41:44 <Lemmih> mdmkolbe|work: The usual example is 'x = y => f(x) = f(y)'. What you said is not true in Haskell.
02:41:51 <quicksilver> so purity from that setting is a useful tool on the path to a good type system
02:41:53 <mrsolo> (1..5).to_a.map {|x|  x * 2 }
02:42:06 <monstre> okay, so maybe lazyness does require a pure language, I really wouldn't know...
02:42:23 <dons> referential transparency is such an important programming technique that it deserves language support
02:42:33 <quicksilver> it's certainly very very hard to get sensible general lazy semantics in an impure language
02:42:39 <quicksilver> of course you can do 'special-case' lazyness
02:42:42 <quicksilver> like ocaml does
02:42:45 <mdmkolbe|work> monstre: lazyness needs the purity b/c otherwise you don't know when anything's side effect would happen
02:42:47 <quicksilver> and like python's generators
02:43:10 <monstre> I'm just not sure I *want* lazyness just yet...
02:43:27 <mdmkolbe|work> Lemmih: why would what I said not be true?  do you mean with regard to strict ness?
02:43:42 <LeCamarade> monstre: No, you can have lazy-eval in any language. In any paradigm.
02:43:57 <Lemmih> mdmkolbe|work: a `fn` b  /=  b `fn` a
02:44:02 <dons> monstre: well, laziness is something you can turn off, or on. bang patterns let you turn it off. so its not all or nothing.
02:44:02 <LeCamarade> You don't want laziness, even as the man whol ived in 1530 never needed a keyboard.
02:44:06 <skew> JohnMeacham: \input -> liftM snd (pipeBoth cmd args input)
02:44:10 <LeCamarade> But once you experience it, you'll see.
02:44:28 <monstre> dons: but is lazyness the right *default*?
02:44:40 <quicksilver> yes, it is
02:44:51 <quicksilver> this is definitely a surprising result, though
02:44:57 <quicksilver> (and a contentious one)
02:44:57 <mdmkolbe|work> Lemmih: but I didn't do that.
02:45:42 <Lemmih> mdmkolbe|work: Oh, right. You didn't.
02:45:52 <skew> monstre: laziness always gives the same result as strict evaluation if the program terminates either way, but it can finish evaluating some programs that strict evaluation gets stuck on
02:46:52 <monstre> it also makes reasoning about the space complexity of programs a bit of a puzzle
02:47:09 <monstre> so it's not all sunshine and rainbows
02:48:09 <quicksilver> this is true
02:48:33 <JohnMeacham> skew: thanks.
02:48:41 <quicksilver> but reasoning about complexity (space or time) of imperative programs is extremely hard
02:48:44 <quicksilver> outside of simple cases
02:48:52 <quicksilver> so it's not as if it's a new puzzle
02:48:58 <quicksilver> it just makes some bits easier and some bits harder
02:49:08 <JohnMeacham> jhc now has a -fm4 as well as a -fcpp option. cpp was too limiting... not that I approve of preprocessors in general.
02:49:08 <Jaggederest> if you want fixed time and space solutions, I think all the RTOSes I've seen are in C. Other than that... it's a blank canvas
02:49:13 <monstre> I would certainly it is *easier* in a strict language
02:49:16 <dons> you're forced to pick an evalutation order, if you're strict. so laziness really is the right default -- you get to program disregarding eval order, and come back to it, if required.
02:49:43 <skew> maybe you could get a bit farther, with some promises about confluence
02:50:24 <quicksilver> but really the more important win about laziness is it allows you to use your data structures as flow control
02:50:29 <quicksilver> at least, that seems to me more important
02:50:38 <skew> like, not think about termination conditions at all
02:50:42 <osfameron> quicksilver: that sounds very profound
02:50:43 <quicksilver> rather than having to write a new flow control library for each new structure
02:50:56 <skew> just describe a process, and let the consumer decide how much they want
02:50:58 <quicksilver> osfameron: it's essentially dons' insight, recycled into my words
02:51:04 <chrismbrown> darcs changes
02:51:10 <chrismbrown> ah! wrong window
02:51:24 <osfameron> quicksilver: my colleague is joking that I am now 20% slimmer having taken up haskell!  (sadly I doubt I'm yet 20% cleverer)
02:51:41 <Jaggederest> skew: dataflow languages? good fun
02:51:43 <quicksilver> the 'Visitor' pattern is a very heavyweight example of how classic OO languages have to write complex flow for a new structure
02:51:49 <dons> yeah, that's probably the most profound change. data as control flow
02:51:56 <dons> and just things like lazy control structures.
02:52:03 <quicksilver> osfameron: are you skipping lunch to program in haskell? that would explain it!
02:52:09 <dons> that's the aspect that is most apparent. that and constant time string processing
02:52:37 <monstre> for the benefit of the slow-witted: what exactly do you mean by "data as control flow"?
02:52:40 <skew> monstre: it's vaguely like garbage collection, easier to express something that computes the desired results if you have infinite resources, maybe a bit harder to reason the resource requirements if it becomes necessary
02:53:12 <LeCamarade> For one, I think reasoning about space complexity is something a programmer (ideally) shouldn't worry about. I know I don't. I have `Get a better machine' on the automated response.
02:53:38 <LeCamarade> monstre: Data as flow control, watch this:
02:54:25 <LeCamarade> You can say this: takeWhile (/= Nothing) [SomeList]
02:54:35 <LeCamarade> Now, SomeList can be generated thus:
02:54:52 <quicksilver> monstre: basically, lists replace 'for' loops and simple (linear) recursion
02:55:10 <quicksilver> monstre: your tree structure replaces 'recursive descent'
02:55:23 <DRMacIver> I'm getting increasingly worried by the "Don't prematurely optimise", "Programmers shouldn't worry about space complexity", etc. attitude.
02:55:28 <LeCamarade> If, say a file, has reached it's last line, the function returns Nothing. Otherwise, it retuns Just the line. So, you can go for as far as the file goes.
02:56:14 <quicksilver> DRMacIver: yes, it's a balance, isn't it
02:56:20 <norpan> DRMacIver: worrying about space complexity is always valid, prematurily optimizing is another matter
02:56:31 <quicksilver> DRMacIver: but I see premature optimization far more often that I see slow code
02:56:33 <Wild_Cat> DRMacIver: "don't prematurely optimize" is the attitude one should have in just about any programming language. As they say, make it work, make it good, make it fast, make it cheap.
02:56:57 <monstre> can I just interject at this point that it's a little suspect how new opportunities for optimization is touted as a great feature of pure functional programming...
02:57:00 <norpan> make it good and then it's automatically fast and working
02:57:05 <dobblego> DRMacIver, I hear ya :)
02:57:20 <monstre> yet the answer to lazyness and space leaks is: don't worry about it
02:57:21 <LeCamarade> norpan: Space complexity varies a lot. Worrying about it makes you a slave of the runtime. IMHO.
02:57:30 <DRMacIver> quicksilver: I'm not really complaining about slow code. I'm complaining about code with large space usages. I routinely use some incredibly bloated applications, and I can't help but feel that the underlying cause of this is programmers doing stupid things.
02:57:48 <norpan> LeCamarade: you're always a slave of the runtime
02:57:58 <LeCamarade> norpan: But shouldn't be.
02:58:05 <norpan> but you have to be
02:58:07 <mauke> monstre: is "profile your code, eliminate bottlenecks" a better answer?
02:58:07 <skew> monstre: talk to dons about that
02:58:09 <Jaggederest> monstre: key is ref. transparency; only the slow/large functions should have to change
02:58:11 <LeCamarade> Movin' on up, movin' on up ...
02:58:27 <norpan> the runtime is your slave and master at the same time
02:58:28 <LeCamarade> monstre: See the map example?
02:58:32 <Wild_Cat> monstre: pure functions allow for *automated* optimization.
02:58:33 <LeCamarade> > map (* 2) [1 .. 5]
02:58:37 <skew> monstre: see e.g. "Rewriting Haskell Strings"
02:58:41 <lambdabot>  [2,4,6,8,10]
02:58:44 <Wild_Cat> that is, the *compiler* optimizes. You don't.
02:58:48 <LeCamarade> A clever compiler can make each of those run on a differnet processor.
02:58:56 <quicksilver> s/can/could/
02:59:02 <mauke> LeCamarade: unlikely
02:59:03 <skew> monstre: I get the impression fp folks are finally getting around to implementing all those fancy optimization they've been promising
02:59:13 <LeCamarade> And then it gets nice when the map actually does a lot of work.
02:59:25 <monstre> "a sufficiently smart compiler," where have I heard that before...
02:59:27 <thoughtpolice> referential transparency can leverage compiler optimization; automatic parallelization (sp?) is one such benefit
02:59:27 <quicksilver> automatic parallelisation isn't as easy as some people make out
02:59:32 <LeCamarade> mauke: I was scared of say [:Float:] ... NDP stuff
02:59:41 <quicksilver> for a start it's in conflict with clal-by-need
02:59:41 <norpan> running those five multiplications on different processors doesn't seem very clever to me :)
02:59:42 <Wild_Cat> (read that Google dude's paper on MapReduce)
02:59:49 <DRMacIver> monstre: GHC isn't a sufficiently smart compiler yet, but it's a lot less stupid than most of the alternatives. :)
03:00:00 <quicksilver> the very nature of call-by-need is that you only ever need one thing at a time
03:00:02 <DRMacIver> monstre: But I think it tends to optimise much more for speed than for space.
03:00:27 <LeCamarade> norpan: What if they are brute-force algorithms? * 2 is cheap. Maps are generic.
03:00:48 <thoughtpolice> well space is somewhat due to the lack of shared libs, hopefully the SoC project will help in that respect.
03:01:17 <opqdonut> Mui.
03:01:21 <LeCamarade> DRMacIver: And why do we even worry about space, when people are lugging gigs and gigs of RAM? It's like writing in C to get the speed benefit.
03:01:23 <Jaggederest> or on an infinite list looking for a 'hit', then your map is important. That's how Google does MapReduce
03:01:56 <DRMacIver> LeCamarade: Because people run more than one program at once.
03:02:05 <quicksilver> LeCamarade: people worry about space *complexity* not space
03:02:13 <dobblego> LeCamarade, many programmers generally don't, but the universe is not finite; we must stop evaluating the universal hash table - albeit being orthogonal to the final solution
03:02:14 <DRMacIver> LeCamarade: I have 2GB of RAM on this machine, and I routinely run out of memory because more than one group of programmers adopted that attitude.
03:02:37 <quicksilver> LeCamarade: if your program is e^N space *complexity* then you find no matter how much ram you have, there is a rather small N you can't solve
03:02:55 <Jaggederest> rainbow tables are cool though, even so
03:02:55 <DRMacIver> (Plus quicksilver's point about complexity)
03:03:04 <araujo> morning
03:03:41 <LeCamarade> I meant space complexity. Yeah, I also get CPU pegged running Perl scripts, some times. But I refuse to get consumed by runtime factors. I can't win, so I don't fight. :o)
03:04:28 <DRMacIver> I'm not sure how to respond to that. "My machine is rendered unusable in the course of things I need to do for work" is an odd thing to not fight.
03:04:36 <LeCamarade> I advocate sane algorithms. But at some point ... Google couldn't have happened on the UNIVAC. Machines have to grow up for my code, rather than my code growing down for them.
03:05:21 <monstre> maybe I lack imagination, but it's hard for me to think of tail-recursive functions not running in constant space as anything but a defect
03:05:28 <njbartlett> What nonsense. Google couldn't happen on modern hardware either if their engineers didn't spend insane amounts of time thinking about speed and space efficiency
03:05:38 <mauke> monstre: it does run in constant space
03:05:47 <mauke> monstre: the accumulated result doesn't, though
03:06:05 <monstre> tomayto, tomahto
03:06:24 <mauke> what
03:07:16 <osfameron> quicksilver: actually, I'm jogging up a hill every morning, but I'm sure that haskell is responsible really.
03:07:30 <mauke> Node *fun(int n, Node *acc) { return n <= 0 ? acc : fun(n - 1, new Node(n, acc)); }
03:07:45 <mauke> that's tail recursive but the accumulator uses O(n) memory
03:07:59 <njbartlett> @src ArrowState
03:07:59 <lambdabot> Source not found. That's something I cannot allow to happen.
03:08:06 <LeCamarade> njbartlett: Yeah. The engineers wrote good algorithms and stuff. But there is a limit to how low you stoop. I can hope to make Google on my Bearwulf cluster here. But I couldn't run even MS Word on the ENIAC, even though someone wanted it to. At some point, `get a better machine to run today's code' is the only way. And that point, for me, is now.
03:08:19 <LeCamarade> But isn't this #haskell-blah material? :-p
03:08:23 <monstre> mauke: if the accumulated result consumes linear space, it's a bit of a stretch to say the function executes in constant space, no?
03:08:26 * LeCamarade ducks
03:08:57 <mauke> monstre: so that's a defect in C++?
03:09:08 <monstre> one of many
03:09:15 <mauke> how would you fix it?
03:09:16 <skew> monstre: if the desired result consumes linear space, it's a bit of a stretch to expect anything to make it run in constant space.
03:09:40 <monstre> I'm talking about your basic factorial function here, nothing fancy
03:10:01 <mauke> no, you're talking about functions in general
03:10:11 <njbartlett> LeCamarade: The ENIAC won't run MS Word, but there's nothing to stop it running a less bloated word processor. Perhaps the point should be, write code that's appropriate for the hardware you have.
03:10:21 <mauke> "it's hard for me to think of tail-recursive functions not running in constant space as anything but a defect"
03:10:53 <skew> monstre: what do you get if you compile with optimization?
03:11:59 <monstre> well, I don't have GHC installed at the moment, so you'll have to tell me
03:12:09 <skew> I'm working on it
03:13:10 <LeCamarade> njbartlett: Yeah. You're very right. But there is a doubling in RAM every 9 months. :-p For me to worry about space complexity is legitimate. But I am very slow (most-probably as a bad habit I'm defending) to change my stuff to fit well in your particular today's RAM.
03:14:38 <njbartlett> LeCamarade: I don't think there's a Moore's law for RAM ;-)
03:14:59 <skew> njbartlett: why not? Moore's law is integration density.
03:16:07 <LeCamarade> njbartlett: I'm still thinking it up ... :o)
03:16:47 <njbartlett> LeCamarade's Law? Doesn't really roll off the tongue.
03:17:04 <mauke> monstre: I'm running fac 1000000 and it doesn't seem to eat my memory
03:17:34 <monstre> I guess GHC is "sufficiently smart" then
03:18:43 <quicksilver> yes, GHC does strictness analysis
03:18:58 <quicksilver> and avoids suspensions where it believes they are not helpful
03:19:04 <monstre> good to know
03:19:06 <skew> mauke: how about 10000000
03:19:16 <mauke> without -O I get a stack overflow
03:19:22 <LeCamarade> njbartlett: Sad. And I know where Shoernfinkel (or the like) ended up against Curry.
03:19:55 <skew> monstre: the root of the problem is that with numbers - and pretty much only with numbers - you often might as well compute right away
03:20:15 <mauke> but even without -O it works if I make fac' strict in the accumulator
03:20:24 <monstre> right
03:20:48 <mauke> haskell doesn't force you to be lazy
03:20:57 <mauke> pun not intended
03:21:10 <LeCamarade> mauke: :oD
03:21:33 <quicksilver> a really clever compiler, which knew that + and * were associativev
03:21:36 <LeCamarade> @remember mauke haskell doesn't force you to be lazy. pun not intended
03:21:36 <lambdabot> Done.
03:21:39 <skew> monstre: the difference from a true lack of tail call optimization is that you can patch it up by evaluating bits early, instead of having to rewrite the code
03:21:46 <quicksilver> could actually transform the naive version into constant space
03:21:55 <quicksilver> that would be a nice trick to show off
03:22:33 <monstre> now that would be "sufficiently smart" indeed
03:23:26 <monstre> so besides potentially infinite data structures, what else is lazyness good for?
03:23:52 <mauke> transposing control flow
03:24:05 <opqdonut> it turns O(n) list processing into O(1) stream processing
03:24:12 <skew> there are many uses, most of which can be described as "potentially infinite data structures"
03:24:31 <opqdonut> skew: yeah i just realised that O(n)->O(1) is that exactly
03:24:40 <opqdonut> oh, O(n) space
03:24:44 <skew> but could also be described as modularity
03:24:45 <opqdonut> not time
03:24:47 <monstre> wouldn't it be sufficient to make constructors lazy?
03:24:47 <opqdonut> (btw)
03:24:48 <skew> or something else
03:25:06 <skew> making constructors lazy gets you pretty far, I think
03:25:18 <opqdonut> monstre: well function application would force evaluation of the lazy structure
03:25:41 <skew> although all of the systems I know of that do something like that really make constructors "lazy" and other code strongly normalizing
03:26:43 <LeCamarade> Off-hand: Can a `sufficiently-smart compiler' infer the need for laziness? As in, not seeing a test for a base case, for example?
03:27:09 <quicksilver> LeCamarade: the 'need' for laziness is the wrong thing to test
03:27:27 <quicksilver> LeCamarade: there are plenty of cases which work on finite structures, and therefore have a base case
03:27:32 <skew> LeCamarade: some stuff like that goes under the name "eager" or "lenient" evaluation
03:27:33 <quicksilver> LeCamarade: but, the finite structure is very large
03:27:40 <LeCamarade> s/laziness/strictness/ # :o)
03:27:42 <quicksilver> LeCamarade: therefore, laziness is still a win
03:27:48 <quicksilver> yes, you can infer the need for strictness
03:27:49 <skew> and on the other hand strictness analysis
03:27:53 <quicksilver> that's exactly what GHC does :)
03:28:16 <LeCamarade> quicksilver: GHC does that???
03:28:21 <quicksilver> yes, it does
03:28:30 <quicksilver> if you experiement with foldl and foldl'
03:28:38 <quicksilver> you'll find that (under -O2) they generate the same code, sometimes
03:28:46 <quicksilver> those are the cases when ghc is able to infer the strictness itself
03:28:55 <skew> monstre: recursive definitions in general seem to be helped by laziness
03:28:56 * LeCamarade spent a night ponderin' it, and thinking he was being novel... But that was back then. Shoulda asked earlier.
03:29:43 <quicksilver> monstre: modularisation is the other key point
03:29:58 <quicksilver> monstre: which is nicely described in the Hughes' paper that got so roundly insulted earlier
03:30:23 <monstre> not by me, I like that paper
03:30:26 <skew> monstre: so is ones = 1:ones an infinite structure, or a cyclic one? if "let" is like a lazy letrec, then it's natural you can just write something like let result = x + y; x = 1; y = 2
03:30:28 <quicksilver> :)
03:31:06 <mauke> laziness means turning 'f x = (...) x' into 'f = ...' is ok
03:31:34 <mauke> (is that eta reduction?)
03:31:53 <monstre> until you bump against the monomorphism restriction...
03:32:00 <mauke> I never do
03:32:07 <mauke> all my toplevel functions have type signatures
03:32:08 <quicksilver> yeah, but the monomorphism reduction is just a silly warning
03:32:17 <quicksilver> it's not representative of a real issue
03:32:40 <mauke> {-# OPTIONS_GHC -fno-monomorphism-restriction #-}
03:32:42 <quicksilver> s/du/stri/
03:32:46 <monstre> still, it is part of the standard
03:32:51 <opqdonut> what is monomorphism restriction?
03:33:05 <mauke> monstre: the transformation is still safe
03:33:05 <quicksilver> opqdonut: CAFs must be monomorphic
03:33:18 <opqdonut> CAFs?
03:33:23 <quicksilver> monstre: all you have to do is add a type sig though
03:33:32 <monstre> I know
03:33:39 <quicksilver> so it's not a big deal, just an annoyance
03:33:53 <monstre> but that defeats the more immediate sense of "lazyness"
03:33:55 <quicksilver> opqdonut: top-level definition with no parameters
03:34:01 <opqdonut> quicksilver: ah okay
03:34:17 <mauke> monstre: huh?
03:34:18 <opqdonut> why is that restriction in the standard?
03:34:34 <quicksilver> opqdonut: because people 'assume' that CAFs are automatically evaluated at-most-once
03:34:38 <quicksilver> opqdonut: (i.e. memoised)
03:34:43 <opqdonut> ah
03:34:51 <quicksilver> opqdonut: but if they're polymoprhic, then really they have a hidden parameter, and this cannot happen
03:35:02 <opqdonut> yep i see
03:35:09 <skew> or at least polymorphic with any class constraints on them
03:35:17 <monstre> mauke: I meant plain old lazyness, as in not wanting to type type signatures if I can avoid it
03:35:23 <mauke> not_a_constant :: (Integral a) => a; not_a_constant = gcd 1234 5678
03:35:38 <mauke> monstre: oh. I write my type signatures first
03:35:42 <mauke> for prototyping, etc
03:35:57 <quicksilver> skew: true, although there aren't really very many interesting fully polymorphic CAFs which could me memoised in any sense
03:36:08 <quicksilver> skew: fully polymorphic things tend to be top-level lambda forms anyway
03:36:36 <skew> well, there's []
03:36:42 <opqdonut> and undefined?
03:36:45 <quicksilver> :)
03:36:52 <quicksilver> [] isn't very expensive to compute, at least
03:37:03 <skew> I suppose not
03:37:11 <skew> maybe there are some examples
03:37:15 <quicksilver> and it does have a hidden parameter, in a sense
03:37:23 <quicksilver> it has a hidden parameter which is the type
03:37:31 <quicksilver> each type has a different [], in haskell
03:37:34 <skew> yeah, but when you get right down to the bits you don't need it
03:38:06 <mauke> don't all []'s have the same runtime representation?
03:38:17 <skew> yeah, that's what I mean
03:38:42 <quicksilver> I'm not sure if they do
03:38:47 <quicksilver> certainly that's an implementation detail
03:38:55 <quicksilver> one might imagine compilers where they don't
03:38:59 <quicksilver> let's ask someone who knows
03:39:18 <quicksilver> JaffaCake: Do all []s at different types have the same runtime representaion, in GHC-compiled code?
03:39:24 <skew> like GHC
03:39:37 <skew> just unsafeCoerce# [] at one type to another, and see if anything explodes
03:39:39 <JaffaCake> quicksilver: yes
03:39:45 <opqdonut> skew: :)
03:39:46 <opqdonut> nice
03:39:57 <quicksilver> JaffaCake: so in principle there could be only one :)
03:40:07 <JaffaCake> there is only one :)
03:40:07 <quicksilver> JaffaCake: that sounds like a pretty useless optimisation
03:40:10 <quicksilver> awesome
03:40:13 <skew> actually, you can go between unrelated types too, as long as they have the same number of constructors, of the same arity
03:40:43 <skew> data Box a = Box a, unsafeAddressOf x = unsafeCoerce# (Box x) :: Ptr ()
03:40:51 <skew> :)
03:40:57 <opqdonut> :D
03:41:10 <opqdonut> the unsafe* functions are really a joy
03:41:18 <opqdonut> they enable you to code C in haskell!
03:41:19 <opqdonut> :)
03:41:35 <LeCamarade> @quote unsafe
03:41:36 <lambdabot> monochrom says: 007 titles for haskellers.  fromForeignPtr withCString.  You Only lift Twice.  Bottoms Are Forever.  The Monad with the Pure Function.  For Your Types Only.  A view to A seq.
03:41:36 <lambdabot> Licence to killThread.  iterate Never Dies.  unsafePerformIO Is Not Enough.
03:41:42 <DRMacIver> opqdonut: Doesn't the FFI let you do that anyway?
03:41:57 <opqdonut> DRMacIver: well yeah, unsafe is just more haskellish
03:42:00 <LeCamarade> @quote unsafe.simon
03:42:00 <lambdabot> No quotes match. You speak an infinite deal of nothing
03:42:16 <LeCamarade> @quote simon.unsafePerformIO
03:42:16 <lambdabot> No quotes match. My mind is going. I can feel it.
03:42:30 <opqdonut> LeCamarade: ?
03:42:31 <LeCamarade> There was a very interesting quote, sometime, about unsafe*
03:42:37 <mauke> @quote simon.*unsafe
03:42:38 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
03:42:40 <opqdonut> @quote simon.*unsafe
03:42:41 <lambdabot> No quotes match. BOB says:  You seem to have forgotten your passwd, enter another!
03:42:49 <opqdonut> @quote simon unsafe
03:42:50 <lambdabot> No quotes for this person. My mind is going. I can feel it.
03:42:53 <opqdonut> gah
03:43:10 <monstre> is there any sort of deadline for haskell'?
03:43:21 <mauke> monstre: yes. kind of.
03:43:28 <mauke> I think it was in 2006
03:44:02 <monstre> so what happened?
03:45:05 <ibid> we heard the sound of the deadline wooshing by
03:46:43 <pastorn> deadline?
03:46:47 <pastorn> for what?
03:46:58 <monstre> Haskell'
03:47:06 <pastorn> the new haskell standard?
03:47:12 <monstre> yes
03:47:19 <pastorn> haskell 98 --> haskell 0x
03:47:57 <ibid> no, haskell prime :
03:47:58 <ibid> )
04:04:55 <dons> fun new course, http://www.cse.unsw.edu.au/~cs4181/
04:04:55 <lambdabot> Title: COMP4181/9181: Language-based Software Safety
04:05:04 <dons> check the topic list, http://www.cse.unsw.edu.au/~cs4181/schedule.html
04:05:04 <lambdabot> Title: COMP4181: Language-based Software Safety - Provisional Schedule
04:05:48 <quicksilver> dons: awesome
04:05:55 <quicksilver> dons: what level of student is that for?
04:10:18 <thoughtpolice> dons: looks awesome.
04:10:35 <thoughtpolice> i hope to get a course on type systems when I get to uni.
04:12:05 <LeCamarade> The best part about being an autodidact is that you don't wait to get to Uni. :o)
04:12:59 <LeCamarade> Just crack into ochestra (the box) and scp everything over to your box and start reading.
04:13:03 <JohnMeacham> hmm.. getting nobench even with --partial still takes a lot of time. I think perhaps darcs optimize checkpoint fixes that.. but am unsure.
04:13:44 <JohnMeacham> all of the previous broken cases I pulled down now work with jhc. time to grab a new batch to add to my regression suite.
04:14:05 <thoughtpolice> LeCamarade: I'm pretty much self taught entirely. :/ i'm only 17 and have never had any sort of formal experiance with other programmers in learning; which is why I'm looking forward to going to uni.
04:14:26 <dons> its for 4th years, and graduate students.
04:14:48 <thoughtpolice> although I'll admit some of the opencourseware from MIT may almost qualify :)
04:15:06 <LeCamarade> thoughtpolice: A few years behind me. I am self-taught, too. But at 17 I was thinking in Java - lucky you!
04:15:25 * DRMacIver couldn't code at 17. :)
04:16:01 <thoughtpolice> haha
04:16:05 <LeCamarade> DRMacIver: Still, lucky you, because some bad habits people pick up when coding on adrenaline and testosterone are to blame for the Software Crisis.
04:16:59 <Syzygy-> > .1*(341+492)
04:16:59 <lambdabot>  Parse error
04:17:02 <skew> I am looking for a haskell unicode library
04:17:05 <thoughtpolice> i can't even remember exactly where my whole programming history went. it starts at twelve and ends now. the programming timeline looks something like this: php -> perl -> c -> ??? -> erlang -> haskell
04:17:06 <Syzygy-> > 0.1*(341+492)
04:17:07 <lambdabot>  83.30000000000001
04:17:12 <Syzygy-> Oooooh, nice!!
04:17:12 <thoughtpolice> you may be wondering exactly what happened in the middle there
04:17:14 <thoughtpolice> so am I
04:17:29 * Syzygy- is gonna get just over 80 Euro for two translated letters. Yay!
04:18:16 <skew> I would like something that would make it easy to replace non-ASCII characters with their character names
04:18:33 <thoughtpolice> so far though I'm just glad I found haskell 'sooner' than 'later.' :)
04:18:53 <skew> Syzygy-: It looks like you are going to get just over 83 Euro, even
04:19:36 <skew> just over 83.3 Euro, rather
04:20:23 <JohnMeacham> skew: see Doc.Chars in my Doc library.
04:20:34 * LeCamarade has BASIC at the beginning -> [about 10 langs] -> Haskell. But not much adventure.
04:20:49 <quicksilver> dons: pretty hardcore even for 4th years
04:21:00 <quicksilver> unsw++ # real computer science
04:21:16 <skew> ... -> Python -> Unlambda -> Haskell -> ???
04:21:19 <LeCamarade> quicksilver: That's a scary comment, man.
04:21:39 <thoughtpolice> LeCamarade: I would consider PHP in my case to be the same as starting with BASIC :p
04:22:02 <quicksilver> LeCamarade: ?
04:22:22 <LeCamarade> quicksilver: `hardcore'. I like it gentle.
04:22:35 <JohnMeacham> skew: http://repetae.net/repos/Doc/Chars.hs
04:22:46 <LeCamarade> thoughtpolice: PHP is sane, compared to the BASIC I'm talking about.
04:23:31 <skew> JohnMeacham: I am looking for something the other way around, like looking up character properties in the unicode tables
04:24:07 <JohnMeacham> ah. saw that somewhere arounh too once.. but not written by me.
04:24:23 <thoughtpolice> LeCamarade: how 'BASIC'-esque of a basic are we talking here? like the most insanely horrid basic to ever have an implementation written?
04:24:35 <DRMacIver> Mine was approximately ML -> [Java, Javascript] -> [Haskell, Scala]
04:24:51 <DRMacIver> With insignificant dabbling with other languages mixed in there.
04:24:59 <skew> you stopped using Javascript?
04:25:09 <skew> did you get out of web programming entirely?
04:25:10 <DRMacIver> Well, no. I'm still using Java and Javascript.
04:25:24 <DRMacIver> And ML.
04:25:28 <DRMacIver> It's a widening progression. :)
04:25:31 <quicksilver> pascal ftw!
04:25:33 <thoughtpolice> I should probably take the time to learn ML.
04:25:37 <thoughtpolice> delphi!
04:26:00 <LeCamarade> Actually, not too bad, since it was for a calculator. Can't ask for much. CASIO BASIC.
04:26:02 <quicksilver> pascal -> basic -> Z80 asm -> C -> "C with Objects" -> C++ -> {path diverges too widely for the margin of this IRC channel}
04:26:15 <thoughtpolice> but at least you guys remember in general. when I said that "???" i meant it: I have no idea exactly what happened in that area.
04:26:18 <LeCamarade> DRMacIver: JS is a god language. Only second to Haskell on my list of lovers.
04:26:23 <thoughtpolice> :(
04:26:37 <DRMacIver> LeCamarade: I used to think that.
04:26:51 <thoughtpolice> lisp is the language god would have used to write the universe. but in all honesty, it was hacked together with perl mostly. :)
04:27:19 <DRMacIver> LeCamarade: But then I tried to do non-trivial things with it and changed my mind. :)
04:27:32 <thoughtpolice> actually,
04:27:46 <thoughtpolice> I suppose now you may be able to tag "perl 6" on the end of that little lisp; or at least group it with Haskell.
04:27:57 <thoughtpolice> s/lisp/list/
04:27:57 <thoughtpolice> :(
04:28:37 <LeCamarade> DRMacIver: For what it is meant to do, it is a star. Just write an implementation that has fine libraries.
04:28:53 <LeCamarade> And IO access and stuff. FFI. It'll rock hard.
04:29:18 <DRMacIver> LeCamarade: Such exists. It doesn't rock especially hard.
04:29:50 <DRMacIver> Trying to do non-trivially large things in Javascript is an exercise in frustration. It's too brittle a language.
04:30:00 <DRMacIver> Although escaping the browser helps a lot I have to admit.
04:30:24 <LeCamarade> DRMacIver: Yeah. But it does! Never used it outside scratching the DOM to hell, but I learnt so much from doing JS. So, so much. I'll always love JS.
04:30:50 <skew> sigh, I figured Java would at least make it straightforward to get at unicode property stuff
04:34:06 <quicksilver> DRMacIver: actually, it's not *that* frustrating, once you get used to the wierd corners in the semantics
04:34:35 <quicksilver> DRMacIver: compared to lots of other imperative languages it has a pleasant uniformity of syntax and its abstraction is *really* powerful
04:34:55 <quicksilver> of course, I hate that it's untyped
04:35:06 <quicksilver> but you can write large programs in it with sufficient discipline
04:35:51 * LeCamarade needs a compiler to enforce discipline with an iron hand. Static checking, et cetera.
04:36:43 <LeCamarade> I get horribly adventurous when given stuff like eval and the like. They are bad. For some people.
04:37:06 <DRMacIver> quicksilver: Yeah, I'm aware of and really like its power. Perhaps I'm just bitter because of the problems that the browser API causes, but I've found that it's *really* hard to e.g. work with libraries because of the power given to them to step on your toes. I've also found debugging it very unpleasant.
04:38:24 <DRMacIver> Possibly I'll get over it and discover I like it again after all. :)
04:39:03 <quicksilver> DRMacIver: ok, but the inconsistent libraries of the netscape and IE browser APIs are not the language
04:39:15 <quicksilver> DRMacIver: granted that is a frustration, but it's not javascript's fault in itself
04:39:55 <LeCamarade> quicksilver: But they did so much damage, I don't think we should let people walk away scot-free. But we are an anarchy. :o(
04:41:12 <quicksilver> LeCamarade: I believe this is known as the 'chains and bondage' argument for strongly typed languages :)
04:41:12 <DRMacIver> quicksilver: Well, I'm not talking about those. I'm talking about pure javascript libraries which people create (which allegedly help compensate for those libraries).
04:41:24 <quicksilver> DRMacIver: ah well, you're talking about software
04:41:32 <quicksilver> News at 11: Software is crap
04:42:25 <LeCamarade> quicksilver: I hate to have the freedom to ruin my life. I tell people that when they say Haskell is a bondage-and-discipline language.
04:42:27 <DRMacIver> quicksilver: Unfortunately you can't get away with that excuse. :)
04:42:33 <DRMacIver> Ultimately a language has to be judged by how well it works. And when most of the software written in a language doesn't work very well, this has to be taken as a problem with the language. :)
04:42:49 <opqdonut> DRMacIver: wellllll
04:43:01 <opqdonut> there could just be lousy coders
04:43:13 <opqdonut> and "letting the coder shoot his leg off" is not a bad feature imo
04:43:43 <DRMacIver> opqdonut: Not really. These are fairly well established and popular libraries. e.g. YUI has been giving me grief recently.
04:44:14 <DRMacIver> Admittedly most of the problem there is the way javascript interacts with the browser.
04:44:20 <DRMacIver> Single threaded event handling and animation. :(
04:45:28 <LeCamarade> opqdonut: Yeah, some people like to be free to shoot their legs off. But not me. I am deeply aware of how easily I could shoot my lower half off (I've done it), so I prefer B-and-D languages.
04:45:42 <opqdonut> :)
05:04:23 <dons> hey, i wonder if we can help this guy out,
05:04:24 <dons>   http://kunosure.blogspot.com/2007/06/unscientific-comparison-35-getting.html
05:04:27 <lambdabot> Title: Wheel of Ezekiel: An unscientific comparison 3.5 - getting the cookie, 3.5, http://tinyurl.com/2frrsf
05:04:34 <dons> "I found this unbelievably hard at first. Why? Two things, monads and typing"
05:04:50 <integral> Not being able to type makes most programming hard :-P
05:05:51 <dons> heh
05:05:58 <dons> need voice activation
05:06:51 <dons> i know: lolcode voice activation!
05:07:16 <dons> "i has a getChar; i fmap ur char lifting ur toUppers"
05:08:10 <arcatan> monads are kinda easy when you get them
05:08:26 <arcatan> at least to use them
05:08:55 <dons> yeah. it all falls into place, and you start tossing different tricks around your code.
05:09:00 <mauke> monads are hard because there's so little to understand
05:09:35 <dons> i imagine its a bit like understanding stacks and recursion
05:09:52 <dons> for new programmers. so simple, so useful
05:10:14 <arcatan> it doesn't really help everybody says monads are hard
05:10:19 <arcatan> +that
05:10:21 <dons> yeah :/
05:10:34 <mauke> any specific monad is easy
05:10:34 <dons> and that monads aren't taught in comp sci courses very often.
05:10:47 <mauke> except for Cont, maybe :-)
05:10:55 <opqdonut> well i can use monads but i wouldn't say i completely understand them
05:10:55 <dons> well, even that's pretty rare.
05:11:04 <dons> people just get the IO one baked in to  them
05:11:07 <vincenz> Hey peeps, this friday I'm giving an introductory session on FPLs at my company.  I figure I'll first explain a bit about FPLs in general and then go towards Haskell.  Any tips or suggestions of what I should mention?
05:11:30 <dons> ah, we must surely have some slides for similar talks somewhere.
05:11:40 <dons> hmm. vincenz, maybe some of SPJs talks?
05:11:48 <arcatan> I really haven't figured out what makes a language functional
05:11:48 <vincenz> Thx, I'll take a look
05:11:51 <opqdonut> vincenz: laziness, pureness and how it affects optimization
05:11:59 <vincenz> opqdonut: that's one slice of it
05:12:05 <vincenz> I figure I'll first present the three axis
05:12:09 <dons> the awkward sqaud paper, "why FP matters", and maybe some of the new SPJ talks -- like hinting about parallelism and so on
05:12:14 <opqdonut> vincenz: also how the functional view has much less problems than the imperative one
05:12:14 <mauke> arcatan: function values, emphasis on function style
05:12:18 <vincenz> lazy vs strict, dynamically typed vs statically typed, and pure vs non-pure
05:12:30 <opqdonut> vincenz: yup sounds like a nice sectioning
05:12:34 <mauke> er, functional style
05:12:46 <opqdonut> vincenz: with examples like haskell, scheme, prolog or something
05:12:52 <vincenz> though it seems not all of those points are inhabited
05:13:00 <vincenz> opqdonut: indeed :) though I lack knowledge of prolog
05:13:07 <opqdonut> vincenz: just mention it :)
05:13:13 <opqdonut> it effectively is the haskell list monad
05:13:17 <opqdonut> (afaict)
05:13:18 <vincenz> :P
05:13:21 <vincenz> I can show some ML
05:13:33 <vincenz> and show how tail-recursion vs non-tail recursion differs between lazy and non lazy
05:13:42 <Wild_Cat> vincenz: make sure you mention type inference in your dynamic vs static typing discussion.
05:13:48 <vincenz> (you want to tail-recurse and reverse in eager languages)
05:13:53 <vincenz> Wild_Cat: definitely
05:13:55 <opqdonut> and polymorphism!
05:14:08 <vincenz> yep
05:14:09 <Wild_Cat> for most people, "static typing" means "C/C++/Java's crap type system"
05:14:13 <vincenz> though it's only 1h talk
05:14:21 <vincenz> so I figure half of it for FPLs in general
05:14:28 <vincenz> half of it for more pratical haskell examples
05:14:35 <vincenz> (and some discussions)
05:14:44 <mdmkolbe|work> vincenz: my favorate example is to ask the audience to define factorial mathematically and write it on the board as they do so, then I surprise them by telling them that what was written on the board is a syntactically correct haskell function (ok, so I lead them along as it is written on the board, but it usually works)
05:15:02 <opqdonut> :)
05:15:17 <quicksilver> @tell ndm nice paper, a couple of comments
05:15:17 <lambdabot> Consider it noted.
05:15:29 <vincenz> But the first clue
05:15:41 <vincenz> what makes a functional language functional... first class functions and HOF?
05:15:59 <opqdonut> vincenz: referential transparency
05:16:05 <vincenz> opqdonut: not all of em
05:16:11 <opqdonut> well, to some extent
05:16:27 <Wild_Cat> IIRC Ocaml doesn't have ref. transparency.
05:16:28 <mdmkolbe|work> opqdonut: cf. scheme/set!
05:16:46 <quicksilver> you can program in the referentially transparent subset of ocaml
05:16:55 <opqdonut> or of scheme
05:16:58 <quicksilver> but you can't expect the compiler to take advantage of the fact
05:16:58 <mauke> or perl
05:17:00 <vincenz> dons: You have that template system that you use for latex slides?
05:17:05 <vincenz> dons: I might like to use it for thes
05:17:07 <vincenz> +e
05:17:12 <Wild_Cat> yeah, I guess referential transparency works for the parts of your program that the compiler can identify as pure. Correct?
05:17:12 <quicksilver> (not that GHC takes much specific advantage of ref. trans. afaik?)
05:17:31 <mdmkolbe|work> vincenz: it's just like what makes a language object oriented, FP in general is an orientation around writing funtions that return values instead of proceedures that mutate values, but like with OOP there are degrees and not all languages are pure
05:17:56 <vincenz> mdmkolbe|work: true, though I guess fc functions and hof are most typifying?
05:19:26 <pejo> vincenz, there are first order functional languages
05:19:28 <mdmkolbe|work> vincenz: yes
05:19:56 <mdmkolbe|work> pejo: example?
05:20:33 <quicksilver> there is no universally accepted definition of 'functional language'
05:20:42 <quicksilver> c.f. imperative, declarative
05:20:44 <pejo> mdmkolbe, Wadler's paper on deforestation contains one. It's pretty common to study a problem for a first order language before going higher order.
05:21:21 <quicksilver> algebraic data types are pretty universal in 'FP' languages
05:21:27 <quicksilver> yet they're not really much to do with functions, per se
05:21:28 <vincenz> quicksilver: nope
05:21:37 <vincenz> quicksilver: they were only added later on as a lib in some scheme implementaitons
05:21:46 <quicksilver> "A broader conception of functional programming simply defines a set of common concerns and themes rather than a list of distinctions from other paradigms. Often considered important are higher-order and first-class functions, closures, and recursion."
05:22:13 <quicksilver> vincenz: there are people who would not consider scheme a very good example of a functional language :)
05:22:18 <quicksilver> vincenz: that's part of what I mean...
05:22:26 <quicksilver> vincenz: it's very much open for debate
05:22:31 <vincenz> yah
05:22:37 <vincenz> I will mention many features tho
05:22:46 <vincenz> but my first slide needs to show some 'typifying' features
05:22:52 <quicksilver> I could say, for example: Scheme is an imperative language with funny syntax and first-class functions
05:23:03 <pejo> mdmkolbe, doesn't the MLton people go to a first order language in their compiler too btw?
05:23:03 <vincenz> as is ML :P
05:23:12 <quicksilver> vincenz: quite.
05:23:19 <quicksilver> and Perl
05:24:07 <dons> vincenz: that's chaksem.cls
05:24:23 <vincenz> dons: ah thx
05:25:54 <vincenz> dons: how do you show code then?
05:26:11 <dons> i use 'pspresent'
05:26:24 <dons> but there's probably other postscript/pdf fullscreen viewers
05:26:42 <vincenz> dons: oh I can use evince, but I mean, how do you make code look nice?
05:27:15 <dons> oh, code i use verbatim, with color hints. i hear that hscolour can print coloured latex directly now though
05:27:19 <dons> so that'd be worth trying
05:27:45 <vincenz> hmm
05:27:50 <vincenz> how do you do bold and color hints in verbatim?
05:28:05 <dons> let me check
05:28:37 <dons> ah no. i've switched to haskell mode
05:28:39 <dons> \begin{haskell}
05:28:39 <dons> f :: Int\# \to{Int\#}                          \\
05:28:39 <dons> f n = {\hskwd{sum}} 0 ( \\
05:28:39 <dons>    \quad\hsalign{\hscase{1 > n}{
05:28:42 <dons>     True~ \to [~] \\
05:28:48 <dons> e.g.
05:28:48 <dons> False &\to {\red go} (x+1)}}{%
05:28:56 <dons> but hscolour might be better at that
05:29:21 <dons> anyone want to write a haskell edsl that spits out tex ?
05:29:32 <dons> so we don't have to write this gunk? :-)
05:29:34 <vincenz> think I can reuse that for other langs like ml/scheme?
05:30:02 <dons> yeah
05:31:01 <vincenz> haskell - lstenvironment?
05:31:09 <malcolmw> does anyone use hscolour interactively?
05:32:23 <dons> malcolmw: ah. should we?
05:32:32 <malcolmw> I discovered recently that the 'less'  viewer has a -R option to display the ANSI highlights properly
05:32:42 <dons> oh , yes.! i do use it that way
05:32:50 <dons> ghc -ddump-simpl | HsColour -tty | less -r
05:32:53 <dons> i use that all the time.
05:33:05 <malcolmw> and I was wondering if there are any editors that could use hscolour even more interactively
05:33:36 <malcolmw> probably a silly idea, but I prefer hscolour's highlihghts to vim's choice of highlights for haskell
05:34:03 <dons> mm. its a nice idea
05:34:33 <malcolmw> re-lexing the whole file on evry keystrike wouuld be a nightmare
05:34:52 <quicksilver> incremental lexing and parsing is interesting
05:34:58 <quicksilver> it's not easy to do it right
05:35:15 <vincenz> dons: have an example .tex?
05:35:21 <quicksilver> quite possible to do it 'well enough', though, which is what vim and emacs do as it stands
05:36:13 <mdmkolbe|work>  is haskell's indentation CFG parseable?
05:36:52 <quicksilver> mdmkolbe|work: as with most such problems, it depends how much you are willing to leave to the 'post-process' pass
05:37:00 <quicksilver> mdmkolbe|work: but the most literal answer to your question is 'no'
05:37:28 <mdmkolbe|work> quicksilver: I just want the indentation -> bracketed step.  Is that part CFG?
05:37:31 <quicksilver> mdmkolbe|work: your parser needs to store in its state a stack of previously used indentations, so it's not context-free
05:38:42 <mdmkolbe|work> quicksilver: but if it's a *stack* of previously used indentations, then shouldn't it be PDA/CFG
05:39:05 <quicksilver> not unless you can think of a way to encode that stack in the pushdown-state
05:39:11 <quicksilver> which off the top off my head, I can't
05:39:28 <quicksilver> they are different stacks
05:39:35 <quicksilver> the indentation stack is fundamentally line-based
05:39:49 <quicksilver> the PDA (implicit) stack is based on terminals and non-terminals
05:40:04 <quicksilver> there's other context used too
05:40:10 <quicksilver> the 'automatic closing'
05:40:26 <quicksilver> if an illegal production is encountered, which would be legal if you closed a few }}}
05:40:31 <quicksilver> then the }}} are closed automatically
05:41:36 <Jaggederest> yay for random numbers. rng <- getStdGen works perfect
05:43:12 <Jaggederest> also, horrible pun alert, I was cooking thai for leftovers, and converted my distance function not to use pairs... so I was currying twice
05:46:36 <vincenz> Is it me or is it hard to show the feature 'first class functions' without invoking either 'closures' or 'hof' to be useful?
05:46:50 <quicksilver> very hard, yes
05:47:04 <quicksilver> first class functions are mostly useful because you can use them as arguments
05:47:07 <quicksilver> i.e. hof
05:47:09 <vincenz> I wanted to show each feature isolated :P
05:47:29 <quicksilver> you could put some functions in a list
05:47:36 <quicksilver> that's something you need 1st-class to do
05:47:40 <vincenz> true
05:47:48 <vincenz> or use a let statement
05:47:53 <vincenz> but ... it's not really that mind-blowing
05:48:03 <quicksilver> 'let statement' just looks like assigning an alias\
05:48:05 <quicksilver> so that's quite dull
05:48:11 <quicksilver> putting functions in a data type is better
05:48:28 <vincenz> nod
05:49:21 <vincenz> twice x = 2 * x
05:49:24 <vincenz> thrice x = x * twice x
05:49:34 <vincenz> list_of_functions = [twice, thrice]
05:49:43 <vincenz> rather lame example :P
05:50:31 <osfameron> you can do dispatch tables with first class functions
05:50:35 <osfameron> that's useful
05:51:08 <osfameron> that's not really HOF in the sense that you're not then *doing* stuff with those functions, you're just invoking them
05:51:14 <osfameron> so conceptually it's a good bit simpler
05:51:43 <vincenz> good idea
05:51:49 <vincenz> I can do something like
05:51:53 <vincenz> (list !! 3) x
05:53:35 <opqdonut> well HOFs come for nearly free once you have first class functions
05:54:03 <opqdonut> vincenz: and in that case (!!) is a hof
05:54:14 <opqdonut> if you look at the specialized (non-polymorphic) haskell type
05:54:16 <opqdonut> :)
05:55:01 <vincenz> > fst (1,2)
05:55:11 <lambdabot>  1
05:55:35 <vincenz> @paste
05:55:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
05:55:48 <hpaste>  vincenz pasted "bleh" at http://hpaste.org/195
05:56:03 <quicksilver> opqdonut: yes, but I think it's permissible to gloss over (!!) being HOF there
05:56:22 <quicksilver> opqdonut: it's "only" a parametrically polymoprhic function which happens to be instantiated at a higher-order type
05:56:27 <opqdonut> yeah, true
05:56:37 <opqdonut> but in haskell, almost everything is a HOF
05:56:43 <vincenz> that look ok?
05:56:43 <quicksilver> vincenz is only trying to write a talk here :)
05:56:44 <opqdonut> or can be specialized into one
05:56:56 <quicksilver> he's not trying to win prizes for PhD viva-level accuracy
05:56:58 <vincenz> I was gonna use lists
05:57:01 <vincenz> but ...
05:57:08 <vincenz> !! is yucky :)
05:57:10 <osfameron> callbacks also
05:57:11 <opqdonut> quicksilver: i'm just trying avoid getting bored
05:57:16 <osfameron> !! is horrible syntax
05:57:29 <vincenz> quicksilver: well no, my phd is on something else :P
05:58:29 <vincenz> hmm
05:58:37 <vincenz> be nice if I could build on the examples
06:02:23 <rarphow> hi. could you please tell me how can I combine all the elements of two lists?
06:02:33 <DRMacIver> Define 'combine'
06:02:39 <opqdonut> :t zip
06:02:40 <opqdonut> :t zipWith
06:02:44 <lambdabot> forall a b. [a] -> [b] -> [(a, b)]
06:02:45 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
06:02:54 <vincenz> odd
06:03:29 <dons> > "foo" ++ "bar"
06:03:30 <lambdabot>  "foobar"
06:04:03 <dons> > zipWith (+) [1..10] [1..10]
06:04:04 <DRMacIver> You shouldn't attempt to read minds. It encourages people to ask overly vague questions. ;)
06:04:05 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
06:04:20 <dons> DRMacIver: good point. telepathy makes people lazy
06:04:24 <rarphow> DRMacIver i'm sorry about the english
06:04:44 <dons> rarphow: its ok. can you say what the input and output would be? an example.
06:04:45 <rarphow> by combine i mean to join all the possibilities of two elements together.. it's pretty simple
06:05:14 <mdmkolbe|work> > [(a, b) | a <- [1..3], b <- [6..7]]
06:05:15 <lambdabot>  [(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
06:05:22 <vincenz> http://imagebin.org/8873
06:05:23 <lambdabot> Title: Imagebin - A place to slap up your images.
06:05:23 <rarphow> yes that's it.. thank you :)
06:05:33 <vincenz> What about something like this
06:05:35 <opqdonut> liftM2 (,) [1..3] [6..7]
06:05:37 <vincenz> so I can keep it usable :)
06:05:37 <opqdonut> > liftM2 (,) [1..3] [6..7]
06:05:39 <lambdabot>  [(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
06:05:42 <opqdonut> :)
06:06:26 <dons> > sequence [ [x,y] | x <- "foo", y <- "bar" ]
06:06:27 <lambdabot> Terminated
06:06:34 <dons> > Control.Monad.sequence [ [x,y] | x <- "foo", y <- "bar" ]
06:06:35 <lambdabot>  ["fffoooooo","fffooooor","fffooooao","fffooooar","fffoooboo","fffooobor","ff...
06:06:41 <dons> silly list monads
06:06:52 <dons> :-)
06:07:10 <rarphow> i'm sorry i'm really beginning in the language.. but how can i put this on hugs?
06:07:19 <DRMacIver> rarphow: I'm not complaining about the english, just that it was an insufficiently precise question. :)
06:07:27 <rarphow> ok :)
06:07:37 <rarphow> i'm brazilian
06:07:52 <dons> you should be able to just type it into hugs.
06:07:59 <rarphow> (now i mean haskell language, lol)
06:08:05 <dons> Hugs.Base> [(a, b) | a <- [1..3], b <- [6..7]]
06:08:05 <dons> [(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
06:08:09 <DRMacIver> Hmm. I always seem to forget about liftMn for n > 1.
06:08:22 <DRMacIver> @src liftM2
06:08:22 <lambdabot> liftM2 f m1 m2 = do { x1 <- m1; x2 <- m2; return (f x1 x2) }
06:08:24 <rarphow> no, it doesn't aceept it
06:08:24 <dons> DRMacIver: we use it in the binary library quite a bit
06:08:38 <dons> liftMn Cnstr get get get get
06:08:39 <mauke> someone needs to define liftM1 = liftM; liftM0 = return
06:09:03 <mdmkolbe|work> @type ap
06:09:05 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
06:11:24 <rarphow> hugs doesn't aceept this: [(a, b) | a <- [1..3], b <- [6..7]]
06:11:45 <mauke> Hugs.Base> [(a, b) | a <- [1..3], b <- [6..7]]
06:11:45 <mauke> [(1,6),(1,7),(2,6),(2,7),(3,6),(3,7)]
06:12:02 <mdmkolbe|work> rarphow: what error does hugs give?
06:12:43 <rarphow> Syntax error in input (unexpected `|')
06:13:10 <vincenz> blegh
06:13:10 <mdmkolbe|work> > ord '|'
06:13:11 <lambdabot>  124
06:13:14 <vincenz> This is so annoying
06:13:31 <vincenz> If I want to introduce concepts such as HoF in a meaningful way... I have to first introduce data-types
06:13:50 <mauke> rarphow: oh, you're trying to load it from a file?
06:14:15 <rarphow> tried both ways
06:14:17 <mdmkolbe|work> rarphow: are you using the right '|' character?  It should be the same one you use for shell pipelines.  (try "ord '|'" at the hugs prompt, it should come back as 124)
06:15:06 <rarphow> ERROR - Undefined variable "ord"
06:15:12 <rarphow> what am i missing?
06:15:13 <mdmkolbe|work> @index ord
06:15:14 <lambdabot> Data.Char
06:15:27 <mdmkolbe|work> hmm, maybe hugs doesn't have that function
06:15:38 <mdmkolbe|work> > fromEnum '|'
06:15:39 <lambdabot>  124
06:15:41 <dylan> @hoogle (b -> c) -> (a, b) -> (a, c)
06:15:41 <lambdabot> Data.Graph.Inductive.Query.Monad.mapSnd :: (a -> b) -> (c, a) -> (c, b)
06:15:42 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
06:15:46 <mdmkolbe|work> @index fromEnum
06:15:46 <lambdabot> Prelude
06:15:49 <rarphow> now i got 124
06:16:27 <mdmkolbe|work> rarphow: try these to see which ones give an error
06:16:33 <mdmkolbe|work> > [1, 2]
06:16:34 <lambdabot>  [1,2]
06:16:38 <mdmkolbe|work> > [(1, 2)]
06:16:39 <quicksilver> dylan: that's also "second" from Control.Arrow, I believe
06:16:40 <lambdabot>  [(1,2)]
06:16:53 <mdmkolbe|work> > let f x = 1 in f 2
06:16:54 <lambdabot>  1
06:17:07 <mdmkolbe|work> > let f x | x == 2 = 1 in f 2
06:17:08 <lambdabot>  1
06:17:28 <mdmkolbe|work> > [1..3]
06:17:29 <lambdabot>  [1,2,3]
06:17:41 <rarphow> i'm sorry. now it's working
06:17:49 <mdmkolbe|work> heh
06:19:07 <rarphow> thank you! sorry bothering with such basics :|
06:19:54 <dylan> quicksilver: or (fst &&& (tail . snd))
06:20:02 <DRMacIver> :t (&&&)
06:20:04 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
06:20:17 <DRMacIver> Hm
06:20:24 <DRMacIver> That totally fails to enlighten me. :)
06:20:54 <dylan> Prelude Control.Arrow> (fst &&& snd) ("foo", "bar")
06:20:54 <dylan> ("foo","bar")
06:21:05 <quicksilver> dylan: indeed, but 'second tail' is neater looking :)
06:23:22 <quicksilver> > ((+1) &&& (*2)) (1,2)
06:23:23 <lambdabot>   add an instance declaration for (Num (t, t1))
06:23:51 <quicksilver> d'oh
06:23:55 <quicksilver> > ((+1) &&& (*2)) 4
06:23:57 <lambdabot>  (5,8)
06:24:03 <quicksilver> DRMacIver: something like that :)
06:25:48 <DRMacIver> I see.
06:25:50 <vincenz> Think I should introduce lambdacalculus?
06:25:57 <quicksilver> probably not
06:26:11 <quicksilver> it's a modelling tool; I'm not sure it's directly interesting to programmers
06:26:13 <dylan> @hoogle isSpace
06:26:13 <vincenz> doesn't the lambacube entail the three axes I mentioned?
06:26:13 <lambdabot> Char.isSpace :: Char -> Bool
06:26:27 <vincenz> or are they different axes
06:27:06 <mdmkolbe|work> vincenz: http://en.wikipedia.org/wiki/Lambda_cube
06:27:07 <lambdabot> Title: Lambda cube - Wikipedia, the free encyclopedia
06:27:14 <vincenz> yep, just googled ;)
06:27:32 <vincenz> apparently not :)
06:27:49 <vincenz> all of lambdacube is typed, and I guess eager vs non-eager makes little difference in lambdacalculus
06:31:18 <earthy> yeah, reduction strategy is not an issue in the lambdacube
06:33:29 <ajudem_me> hello
06:33:34 <ajudem_me> dmwit, are you there?
06:33:53 <kombinator> I have code like this: case x of Nothing -> (f, g, h); Just y -> (f' y, g' y, h' y); How do I make it more lazy? I want (,,) constructor to be produced immediately.
06:35:23 <ajudem_me> http://hpaste.org/187  -> I wrote this yesterday, and dmwit answered. But I can't understand something. What does the definition of iterator in statement take an I??
06:36:16 <ClaudiusMaximus> kombinator: perhaps something like (a,b,c) where a = case x of Nothing -> f ; Just y -> f' y ; b = ...
06:36:16 <ajudem_me> and how can I build an statement, for instance?
06:37:03 <ajudem_me> does anyone know?
06:37:05 <quicksilver> ajudem_me: 'I' is just a tag
06:37:23 <quicksilver> ajudem_me: it's the constructor you use to make a value of type 'Statement' out of a value of type 'Iterator'
06:37:52 <quicksilver> so if 'myit' is an iterator, then 'I myit' is a statement
06:38:02 <kombinator> ClaudiusMaximus: that will make it a bit longer, is it not possible to leave it as concise as before?
06:38:03 <ajudem_me> ohhhh!!!
06:38:08 <ajudem_me> quicksilver, tnks =)
06:38:25 <ajudem_me> and if it happens recursivly
06:38:42 <ajudem_me> for instance
06:38:47 <ajudem_me> in Loop
06:38:56 <ajudem_me> Conditional is somithing like:
06:38:58 <quicksilver> kombinator: no, because you have to somehow "prove" that both cases are the same constructor
06:39:08 <quicksilver> kombinator: ergo, you have to move the constructor outside the cased
06:39:10 <ndm> @seen kosmikus
06:39:10 <lambdabot> kosmikus is in #xmonad, #haskell, #ghc, #gentoo-haskell and #darcs. I last heard kosmikus speak 4h 31m 36s ago.
06:39:35 <ajudem_me> I mean
06:39:36 <quicksilver> kombinator: it can be less verbose than ClaudiusMaximus ' version though
06:39:42 <ajudem_me> if it's a data, also
06:39:51 <quicksilver> kombinator: (a,b,c) where (a,b,c) = case ....
06:40:05 <ajudem_me> well.. I'll try
06:40:06 <quicksilver> ajudem_me: yes it's recursive
06:40:15 <ClaudiusMaximus> @type maybe
06:40:20 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
06:41:40 <ClaudiusMaximus> > (maybe 5 (+5) Nothing, maybe 6 (+3) (Just 12))
06:41:41 <lambdabot>  (5,15)
06:42:17 <ClaudiusMaximus> kombinator: ^^^ might make it even less verbose?
06:42:31 <kombinator> ClaudiusMaximus: yes
06:42:49 <kombinator> quicksilver: It works! However I've yet to understand why
06:44:09 <quicksilver> kombinator: (a,b,c) is 'definitely' a constructor
06:44:26 <quicksilver> kombinator: a general case, even though proven to be right type, might evaluate to _|_
06:44:48 <quicksilver> kombinator: so haskell doesn't produce the (,,) until it has 'executed' enough code to prove the constructor is there
06:44:57 <kombinator> quicksilver: ok, now I get it, in the worst case I could have (_|_, _|_, _|_)
06:45:03 <quicksilver> exactly
06:45:14 <kombinator> thanks!
07:02:13 <olsner> @pl flip (\x -> map (\f -> f x))
07:02:13 <lambdabot> flip (map . flip id)
07:02:21 <olsner> :type flip id
07:05:12 <olsner> @pl (\l x -> l >>= (\f -> f x))
07:05:12 <lambdabot> (. flip id) . (>>=)
07:05:50 <olsner> ... but that's not quite the same
07:07:00 <ptolomy> hey, quick microb enchmark test..
07:07:19 <SimonRC> is there a Maybe-fetch for arrays
07:07:48 <SimonRC> It would return Just foo if the index was in-bounds and Nothing if the index was out-of-bounds
07:08:12 <ptolomy> should I be surprised that 'fromIntegral (sum lst) / fromIntegral (length lst)' is consistently faster (compiled and in ghci) than a hand-coded type-specified function that calculates the length while it does a sum?
07:08:32 <SimonRC> maybe
07:08:38 <SimonRC> depends on 1001 things
07:09:26 <SimonRC> it mostly depends on (a) various types of caching (b) how obscure the code is to the optimiser
07:10:02 <SimonRC> you might be getting better CPU cache behaviour with one version than the other
07:10:07 <ptolomy> hmm.. bang patterns, and still my function isn't faster.
07:10:22 <ptolomy> I'm going to try again with my function as a strict left fold
07:10:37 <sjanssen> @yow!
07:10:37 <lambdabot> Sometime in 1993 NANCY SINATRA will lead a BLOODLESS COUP on GUAM!!
07:11:21 <SamB_XP_> ptolomy: look at the core
07:11:24 <olsner> lambdabot: temporal inconsistency!
07:11:46 * SimonRC just writes the darn combinator himself
07:12:41 <olsner> list !? index ;-)
07:13:03 <olsner> user-defined operators can be fun
07:13:53 <SimonRC> ah, !? is probably a good name for it
07:14:00 <SamB_XP_> olsner: what do you expect when lambdabot is channeling zippy the pinhead?
07:14:07 <SimonRC> or maybe ?! would be better
07:14:17 <SamB_XP_> ?!?
07:14:17 <lambdabot> Maybe you meant: . bf ft id pl rc v wn
07:14:23 <olsner> or maybe!!
07:14:31 <SamB_XP_> SimonRC: definately !?
07:14:34 <SimonRC> ok
07:14:43 <SamB_XP_> it won't be misinterpreted as a lambdabot command ;-)
07:16:07 <SimonRC> The Maybe type is great for self-documenting code.
07:16:48 <SimonRC> it gets round the eternal need to say what happens when you pass null pointers in, or when you might receive them out.
07:20:01 <olsner> people have suggested can-be-null-types for all kinds of languages... I think there's a java-based language where you have to add ? to a pointer type to be able to assign null to it (assigning a Type? pointer to a Type variable invokes run-time checks IIRC)
07:20:17 <DRMacIver> You're probably thinking of Nice.
07:21:07 <ndm> @seen quicksilver
07:21:07 <lambdabot> quicksilver is in #haskell and #ghc. I last heard quicksilver speak 36m 4s ago.
07:21:09 <SimonRC> In .NET, value (as opposed to reference) types are by default "non-nullable", and ? is syntactic sugar for a way of making them nullable.
07:21:16 <DRMacIver> (It's not nearly as Java based as its syntax claims it to be. It's much closer to a really weird dialect of ML)
07:21:39 <olsner> yeah, Nice is probably it
07:21:43 <SimonRC> alas, you mostly work with reference types, which are already nullable, and you can't make something nullable twice
07:22:33 <olsner> that extension included making references non-nullable until marked nullable, I think
07:23:20 <DRMacIver> Yeah. And it had various useful inference mechanisms for checking for nullness. So in a if (foo != null) { bar(foo); } you could treat foo as a non null reference.
07:23:42 <DRMacIver> Unfortunately they were insufficiently clever and you had to work around their shortcomings in a number of cases. :)
07:23:44 <SimonRC> it is nice to have NullPointerExceptions look ugly in the place where the null pointers are generated, rather than where they are used
07:27:06 <SimonRC> is there an operator to do this yet?
07:27:07 <SimonRC> (.$) f g x y = f $ g x y
07:27:19 <SimonRC> @type let (.$) f g x y = f $ g x y in (.$)
07:27:21 <lambdabot> forall a b t t1. (a -> b) -> (t -> t1 -> a) -> t -> t1 -> b
07:27:54 <ndm> @seen lambdabot
07:27:54 <lambdabot> Yes, I'm here. I'm in #dreamlinux-es, #xmonad, #unicycling, #perl6, #parrot, #oasis, #jtiger, #haskell-soc, #haskell-overflow, #haskell-blah, #haskell, #ghc, #gentoo-uy, #gentoo-haskell, #darcs and #
07:27:54 <lambdabot> scannedinavian
07:27:59 <DRMacIver> @pl let (.$) f g x y = f $ g x y in (.$)
07:27:59 <lambdabot> (line 1, column 5):
07:27:59 <lambdabot> unexpected "("
07:27:59 <lambdabot> expecting natural, identifier or "in"
07:28:12 <olsner> @pl (\f g x y -> f (g x y))
07:28:12 <lambdabot> (.) . (.)
07:28:18 <SimonRC> ah
07:28:23 <SimonRC> how woderfully clear
07:28:34 <SimonRC> (sigh)
07:28:45 <SimonRC> a bit verbose though
07:28:55 <olsner> @pl (\f g x -> f . g x)
07:28:55 <lambdabot> (.) . (.)
07:29:52 <olsner> I remember using that exact function just a couple of days ago
07:31:53 <ajudem_me> quicksilver, can you please check this?
07:31:56 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/196
07:35:30 <Syzygy-> How can I suppress the 123e-15 -notation when printing doubles?
07:36:01 <Botje> ajudem_me: you could possibly encode the Else branch in a Maybe Statement
07:36:49 <olsner> using records might be easier to work with than five-tuples, something like W { int :: Int, int2 :: Int, condition:: Conditional, stmt :: Statement }, or even L { loopKind :: LoopKind, ... } - where LoopKind could be something like data LoopKind = Precheck | Postcheck
07:41:13 <olsner> :t sequence
07:41:15 <lambdabot>     Ambiguous occurrence `sequence'
07:41:15 <lambdabot>     It could refer to either `sequence', imported from Control.Monad.Writer
07:45:23 <ajudem_me> olsner... how does it work, later?
07:46:25 <ajudem_me> but is this correct?
07:47:16 <Botje> ajudem_me: haskell will tell you it's correct, yes
07:49:40 <ajudem_me> ok
07:49:45 <ajudem_me> and, for instance
07:50:01 <ajudem_me> I want to see what kind of statement is "stm"
07:50:04 <ajudem_me> how can I do that?
07:50:48 <ajudem_me> like: if it's an iterator, return true, else return false
07:51:24 <Botje> pattern match.
07:52:24 <Botje> isIterator (I _) = True
07:52:28 <Botje> isIterator _ = False
07:52:37 <ajudem_me> ohhh!!!
07:52:42 <ajudem_me> thks!! =))))
07:52:47 <Botje> but most of the time you do the pattern match in your function self..
07:53:09 <Botje> don't write code such as run x = if (isIterator x) then .. else ...
07:53:15 <ajudem_me> I'm having difficult to get used to data... What is a data in C, for instance?
07:53:23 <Botje> typedef
07:53:24 <ajudem_me> Botje, so what should I write?
07:53:39 <Botje> you pattern match.
07:53:53 <ajudem_me> how?
07:53:53 <Botje> run (I x) = (code to run an iterator)
07:53:54 <daniel_larsson> run (I _) = ...
07:53:54 <daniel_larsson> run _  = ...
07:54:05 <daniel_larsson> well yea, (I x) )
07:54:07 <ajudem_me> what does run?
07:54:14 <Botje> how should I know?
07:54:23 <ajudem_me> hmm w8...
07:54:45 <ajudem_me> I thought run was some kind of special command
07:55:09 <Botje> no ..
07:55:45 <ajudem_me> hmm... I thought Haskell "type" was the C "structure"
07:56:05 <sjanssen> 'type' is more like typedef
07:56:23 <sjanssen> 'data' is a bit more like a struct
07:58:17 <ajudem_me> sjanssen... now I'm confused...
07:58:31 <ajudem_me> I always thought typedef and struct were the same
07:58:37 <Botje> oh dear
07:59:06 <dylan> hmm, why don't I have Data.Time.Format?
07:59:21 <Botje> there's a good chance I'll know more than my teacher about haskell next year
07:59:35 <sjanssen> ajudem_me: you might ask #C about that one :)
08:00:10 <sjanssen> ajudem_me: anyway, 'type' introduces a type synonym: a shorthand name for another type
08:00:45 <sjanssen> say I've gotten tired of writing 'Map Position ChessPiece' in my type signatures
08:01:07 <sjanssen> 'type Board = Map Position ChessPiece'
08:01:47 <sjanssen> 'data' is the keyword used to make brand new types
08:01:53 <Syzygy-> ?hoogle split
08:01:53 <lambdabot> Random.split :: RandomGen a => a -> (a, a)
08:01:54 <lambdabot> Data.IntMap.split :: Key -> IntMap a -> (IntMap a, IntMap a)
08:01:54 <lambdabot> Data.IntSet.split :: Int -> IntSet -> (IntSet, IntSet)
08:01:58 <Syzygy-> Hmm.
08:02:00 <ajudem_me> sjanssen... oh!
08:02:09 <Syzygy-> ?hoogle [a] -> a -> ([a],[a])
08:02:09 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
08:02:09 <lambdabot> Data.List.genericSplitAt :: Integral i => i -> [b] -> ([b], [b])
08:02:34 <Syzygy-> ?hoogle splitAt
08:02:34 <lambdabot> Prelude.splitAt :: Int -> [a] -> ([a], [a])
08:02:34 <lambdabot> Data.PackedString.splitAtPS :: Int -> PackedString -> (PackedString, PackedString)
08:02:34 <lambdabot> List.genericSplitAt :: Integral a => a -> [b] -> ([b], [b])
08:02:56 <ajudem_me> sjanssen... and how can I do operations with my data types?
08:03:00 <ajudem_me> how should I define it?
08:03:15 <sjanssen> what do you want to define?
08:03:49 <Syzygy-> ?hoogle find
08:03:49 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
08:03:49 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
08:03:49 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
08:04:00 <dylan> @hoogle Data.Time.Format
08:04:01 <lambdabot> No matches, try a more general search
08:04:17 <ajudem_me> http://hpaste.org/196 I want to check if my variable "stm" is an iterator
08:04:28 <quicksilver> ajudem_me: I think you should work through at least the beginning of a haskell tutorial
08:05:01 <quicksilver> ajudem_me: http://www.haskell.org/tutorial/ for example contains sections on defining your own type and writing pattern matches on them
08:05:02 <lambdabot> Title: A Gentle Introduction to Haskell, Version 98
08:05:15 <quicksilver> we're always here to help when you get stuck
08:05:48 <defcons> hello
08:05:49 <ajudem_me> quicksilver, and where are data types?
08:06:00 <defcons> does anyone know how to get -> to be displayed as an Unicode arrow on emacs?
08:06:24 <quicksilver> ajudem_me: in the second section, 'Values, Types and other goodies'
08:06:38 <quicksilver> defcons: #emacs is other that way ---->
08:06:54 <defcons> yeah I thought someone may know as I thought it may be common with haskell coders
08:07:08 <defcons> or maybe an option of haskell-mode to be turned on
08:07:23 <quicksilver> it's not a very good idea actually because it may confuse your layout :)
08:07:34 <rey_> defcons: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
08:07:35 <lambdabot> Title: EmacsWiki: PrettyLambda
08:07:49 <defcons> htanks rey_
08:07:52 <sjanssen> IIRC you can use the actual arrow character with ghc 6.6
08:08:20 <defcons> now I'll need to learn regex :)
08:08:23 <quicksilver> using the actual character is a much better idea
08:08:29 <quicksilver> at lest that's "one char wide" :)
08:08:34 <defcons> oh, it's further down
08:09:14 <jao> defcons: http://hacks-galore.org/darcs?r=emacs-debian;a=headblob;f=/custom/jao-pretty-lambda.el is a function to show lambda as a greek lambda. you could adapt that for your ends
08:09:16 <lambdabot> Title: darcs - emacs-debian, http://tinyurl.com/2cdk2y
08:09:23 <defcons> yeah
08:10:18 <jao> (oops, sorry, hadn't read the previous answers)
08:10:59 <dylan> what library does one use to parse dates/times?
08:11:52 <quicksilver> dylan: Data.Time.Format, perhaps?
08:11:53 <dylan> I thought Data.Time.Format.parseTime would do, but Data.Time.Format doesn't appear to exist in my ghc-time package..
08:12:08 <dylan> (using ghc 6.6..)
08:12:19 <quicksilver> ah maybe it got moved around
08:12:25 <quicksilver> there are library re-orgs going on
08:12:50 <dylan> @hoogle parseTime
08:12:51 <lambdabot> No matches found
08:13:17 <quicksilver> dylan: http://haskell.org/ghc/docs/6.6/html/libraries/time/Data-Time-LocalTime.html
08:13:19 <lambdabot> http://tinyurl.com/yweyp9
08:13:23 <quicksilver> dylan: was the closest thing in 6.6
08:13:29 <quicksilver> dylan: and I don't see a 'parse' function :|(
08:15:13 <dylan> blah. all I'm trying to do is make a blosxom-alike in haskell. :(
08:16:07 <quicksilver> so write your own date parsing :P
08:16:11 <quicksilver> snot hard..
08:17:14 <MarcWebe1> Do you know what a type indexed coproduct is ? (TIC.hs from HList)
08:17:34 <MarcWebe1> When is Proxy used?
08:23:04 <joakim> hi
08:29:37 <joakim> got some problems here ...
08:30:39 <quicksilver> well if you don't tell us what they are, it's unlikely anyone will help...
08:32:01 <byorgey> joakim: try some solutions, that usually helps =)
08:32:34 <joakim> exercise 3.3
08:33:10 <byorgey> joakim: exercise 3.3 of what?
08:33:19 <quicksilver> joakim's homework, perhaps? ;)
08:33:26 <ndm> MarcWebe1: no one bug Oleg understands HList...
08:33:42 <joakim> Yet Another Haskell Tutorial
08:33:48 <joakim> it makes me think :)
08:33:57 <byorgey> @where yaht
08:33:57 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
08:34:07 <CosmicRay> Igloo: do you have any idea what is the proper thing to do about #427769?  The source really doesn't care what version of libghc6-network-dev is installed, so it has an unversioned dependency on it.  Should I be doing something else?
08:35:06 <joakim> i have a string of upper and lower case characters
08:35:34 <joelr1> g'day
08:35:48 <joelr1> is anyone using a macbook without an external monitor all day?
08:36:05 <pejo> joelr, I am.
08:36:15 <joakim> with map, i should leave a new list with True on lower cases and False on upper cases
08:36:42 <joelr1> pejo: how do you find it? screen too small? are you using it for over 8 hours a day?
08:36:45 <quicksilver> sounds easy enough; how far did you get?
08:36:54 <joelr1> pejo: no external monitor, right?
08:37:27 <pejo> joelr, I have a 15", no problems with the screen. I have an external keyboard though.
08:37:51 <quicksilver> joakim: what approach did you take so far?
08:37:51 <joakim> how can i do that?
08:38:05 <quicksilver> have you used map? do you understand what map does?
08:38:37 <defcons> how do I get the nth value of a list?
08:38:43 <quicksilver> defcons: !!
08:38:47 <quicksilver> defcons: it counts from 0, though
08:38:48 <defcons> I forgot
08:38:51 <defcons> yes
08:38:53 <quicksilver> at least, I think i t does
08:38:54 <defcons> is it nth?
08:38:57 <defcons> elt?
08:38:58 <quicksilver> !!
08:39:03 <defcons> oh :)
08:39:04 <quicksilver> that wasn't me being rude
08:39:06 <quicksilver> it was the answer :)
08:39:11 <quicksilver> > [1..5] !! 3
08:39:13 <lambdabot>  4
08:39:37 <defcons> bloody hell, it computes fibonacci numbers very fast
08:39:45 <quicksilver> :)
08:39:48 <joelr1> pejo: well, mmm, that doesn't count as i'm wondering about the 13.3" screen (not pro). thanks though
08:39:58 <defcons> I'm on learn-haskell megadrive as summer school starts on Monday and I didn't think I'd be doing summer school :)
08:40:44 <quicksilver> joakim: have you used map? do you understand what map does?
08:41:07 <byorgey> defcons: so you need to learn Haskell before monday??
08:41:13 <joakim> it goes over the list, and puts each element to the inputted function
08:41:23 <joakim> right?
08:41:46 <mauke> map f [x1, x2, x3, ...] == [f x1, f x2, f x3, ...]
08:41:53 <quicksilver> yes
08:41:54 <defcons> byorgey, I would like to
08:42:02 <quicksilver> joakim: e.g.:
08:42:05 <defcons> I think they start with python, which I already know
08:42:08 <quicksilver> > map toUpper "aBcDe"
08:42:10 <lambdabot>  "ABCDE"
08:42:14 <defcons> but this is Glasgow, so they may do haskell. I don't know
08:42:43 <quicksilver> joakim: can you see what you need, now to get your trues and falses?
08:43:05 <byorgey> defcons: well, have fun!  I doubt you can learn "all" of Haskell by Monday, but then again, it would probably take years to learn "all" of Haskell, for a suitable value of "all" =)
08:43:15 <defcons> thank you
08:43:24 <defcons> I'm reading the craft of functional programming
08:43:32 <joakim> a function that makes true and false ...
08:43:46 <defcons> is there xor in haskell?
08:43:53 <joakim> depending on the character
08:43:53 <mauke> @index xor
08:43:53 <lambdabot> Data.Bits, Foreign
08:44:10 <defcons> also is it possible to define the factorial function with a list?
08:44:46 <quicksilver> joakim: I haven't read, yaht, it's possible the function is already introduced
08:44:55 <defcons> yes of course
08:44:59 <quicksilver> joakim: but otherwise, have a look around the docs for Data.Char
08:45:06 <quicksilver> joakim: I think you'll find some possibilities there
08:45:18 <Cale> > let factorial n = product [1..n] in factorial 5
08:45:19 <lambdabot>  120
08:45:20 <joakim> k, i have been looking there
08:45:42 <kosmikus> ndm: pong?
08:45:43 <dolio> > map (uncurry (/=)) [(False, False), (True, False), (False, True), (True, True)]
08:45:45 <lambdabot>  [False,True,True,False]
08:45:49 <defcons> fac = 1 : 1 : (length fac + 1) * tail fac ?
08:46:00 <quicksilver> > map isSpace "abc def GHI"
08:46:01 <defcons> naah that's dumb
08:46:01 <lambdabot>  [False,False,False,True,False,False,False,True,False,False,False]
08:46:16 <Cale> oh, I see what you mean though
08:46:16 <dolio> > scanl (*) 1 [1..]
08:46:17 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
08:46:25 <quicksilver> dolio beat me to it :)
08:46:34 <hpaste>  thoughtpolice pasted "help with monad transformer" at http://hpaste.org/198
08:46:34 <Cale> yep
08:46:48 <defcons> is there anything like mapping with index?
08:47:12 <thoughtpolice> anybody mind helping me with that? I can't exactly figure out why I can't 'lift ask'
08:47:18 <quicksilver> thoughtpolice: lift comes from MonadTrans
08:47:25 <quicksilver> thoughtpolice: which you didn't derive
08:47:40 <ndm> kosmikus: did you get the copy of my Play/Uniplate paper i sent you?
08:47:50 <Cale> defcons: zipWith f [0..] xs
08:47:52 <thoughtpolice> quicksilver: I've already tried.
08:47:56 <mauke> defcons: zipWith f ... what Cale said
08:48:01 <quicksilver> thoughtpolice: I believe if you derive 'MonadReader' then you can just use ask directly
08:48:04 <defcons> okay thanks
08:48:09 <kosmikus> ndm: no
08:48:11 <quicksilver> thoughtpolice: without the lift
08:48:11 <thoughtpolice> hm just a sec
08:48:13 * kosmikus looks
08:48:18 <defcons> can I apply this to make an infinite list of factorials?
08:48:32 <ndm> kosmikus: hmm, i sent it about a week ago - i'll have a new draft tomorrow if you want
08:48:45 <kosmikus> ndm: yes
08:48:48 <quicksilver> defcons: yes, you can, but dolio's answer is cuter
08:48:57 <kosmikus> ndm: I got it. I was on vacation until today, so no surprise I missed it.
08:49:00 <joakim> got it
08:49:02 <defcons> oh htanks dolio I didn't see that
08:49:10 <thoughtpolice> quicksilver: ah, thanks! deriving from MonadReader String fixed it
08:49:15 <thoughtpolice> quicksilver++
08:49:46 <mauke> > let fac = 1 : zipWith (*) [1..] fac in fac
08:49:48 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,...
08:49:48 <Cale> > let fac = 1 : zipWith (*) [1..] fac in take 10 fac
08:49:50 <lambdabot>  [1,1,2,6,24,120,720,5040,40320,362880]
08:49:50 <kosmikus> ndm: but if you want me to look at a more recent version, I'd be happy to receive an update ;)
08:49:59 <mauke> stereo :-)
08:50:00 <ndm> kosmikus: fair enough, in that case ignore it and i'll send you a better one tomorrow
08:50:03 <Cale> yep :)
08:50:25 <quicksilver> ndm: I had some comments, but I don't have time to pass them on now
08:50:33 <quicksilver> ndm: I'll send you an email on the train home
08:50:37 <ndm> quicksilver: cool, probably best to email them
08:50:42 <ndm> cool :)
08:50:58 <quicksilver> short version goes like this "Nice. Really Nice"
08:51:57 <ndm> cool :)
08:52:03 <ndm> the rewrite section is getting a bashing
08:52:13 * shapr boings cheerfully
08:52:16 <ndm> thats the bit where my supervisor said "umm, i don't understand"
08:55:01 <Syzygy-> ndm: My supervisor does that a lot.
08:55:15 <ndm> my supervisor does it very very rarely
09:00:31 <quicksilver> I don't honestly recall my supervisor ever not understanding anything
09:00:34 <joakim> exercise 3.5 in YAHT, it seems impossible?
09:00:38 <quicksilver> maybe that means I didn't push them hard enough
09:02:03 <Botje> joakim: then it would be called "research topic" not "exercise" :)
09:02:30 <joakim> is YAHT as that
09:02:45 <joakim> that you have to research a little to make things work out?
09:02:45 <Botje> "write a function using a fold that will return the maximum value in a list " ?
09:02:54 <joakim> ye
09:03:14 <mauke> why is it impossible?
09:03:21 <joakim> for me, it seems to be that i have to use some control structures
09:03:32 <Botje> all exercises should be doable if you've read and understood the chapter above
09:03:34 <MyCatVerbs> > foldl (\x y-> if x>y then x else y) 0 [1,4,3,5,6,25,3,19]
09:03:38 <lambdabot>  25
09:04:31 <MyCatVerbs> Botje: dunno, I found a couple of the earlier chapters a little overly terse.
09:04:32 <Botje> joakim: did you understand the part above (folding) ?
09:04:33 <pejo> quicksilver, or that your thoughts are very clear.
09:04:33 <mauke> > foldr max 0 [5,10,2,8,1]
09:04:34 <lambdabot>  10
09:04:41 <roconnor>  > foldl (\x y-> if x>y then x else y) 0 [-1,-4,-3,-5,-6,-25,-3,-19]
09:05:06 <joakim> ye, it "replaces the cons with the function and [] with an initial value
09:05:17 <MyCatVerbs> roconnor: you have a point. foldl1 would be better. >>
09:05:18 <mauke> foldl? no
09:05:24 <roconnor> > foldl (\x y-> if x>y then x else y) 0 [-1,-4,-3,-5,-6,-25,-3,-19]
09:05:26 <lambdabot>  0
09:05:41 <mauke> roconnor: the exercise assumes nonnegative numbers
09:05:48 <MyCatVerbs> roconnor: or foldr1, it doesn't really matter.
09:06:03 <MyCatVerbs> > foldl1 max [-1,-4,-3,-5,-6,-25,-3,-19]
09:06:04 <lambdabot>  -1
09:06:20 <mauke> > maximum [-1,-4,-3,-5,-6,-25,-3,-19]
09:06:21 <lambdabot>  -1
09:06:46 <roconnor> > fromJust $ foldr (\z y-> case z of Nothing -> y ; Just x -> if x>y then x else y) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:06:47 <lambdabot>        add an instance declaration for (Num (Maybe (Maybe a)))
09:06:47 <lambdabot>     In the exp...
09:06:56 <roconnor> > fromJust $ foldr (\y z-> case z of Nothing -> y ; Just x -> if x>y then x else y) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:06:57 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
09:06:57 <lambdabot>       Expe...
09:07:05 <roconnor> @type foldr
09:07:07 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
09:07:51 <roconnor> > fromJust $ foldr (\y z-> case z of Nothing -> y ; Just x -> Just (if x>y then x else y)) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:07:52 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
09:07:52 <lambdabot>       Expe...
09:09:07 <ndm> has anyone used SYB, and has anyone ever used everywhere' ?
09:09:12 <ndm> as opposed to everywhere
09:09:21 <mauke> > fromJust $ foldr (\y z-> case z of Nothing -> y ; Just x -> if x>y then x else y) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:09:22 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
09:09:22 <lambdabot>       Expe...
09:09:29 <mauke> > fromJust $ foldr (\y z-> case z of Nothing -> y ; Just x -> Just $ if x>y then x else y) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:09:30 <lambdabot>      Occurs check: cannot construct the infinite type: t = Maybe t
09:09:30 <lambdabot>       Expe...
09:09:43 <ndm> i suspect everywhere' is a bit useless, but its hard to prove its useless without enumerating the program example space
09:10:39 <roconnor> > fromJust $ foldr (\y z-> case z of Nothing -> Just y ; Just x -> Just (if x>y then x else y)) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:10:40 <lambdabot>  -1
09:10:43 <roconnor> yay!
09:11:42 <dolio> ndm: Is everywhere' the one that's bottom up instead of top-down?
09:11:44 <mauke> > foldr (\x z-> Just $ case z of Nothing -> x ; Just y -> max x y) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:11:45 <lambdabot>  Just (-1)
09:11:57 <ndm> dolio: its top-down, everywhere is bottom-up
09:12:43 <dolio> ndm: Ah. I thought one of the SYB papers had an example of where it'd be necessary, but I guess that's no guarantee that it isn't too trivial, and that such situations never come up in practice.
09:13:05 <roconnor> > foldr (\x z-> Just $ maybe x (max x) z) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:13:06 <lambdabot>  Just (-1)
09:13:14 <ndm> dolio: the first SYB paper which introduces everywhere' certainly doesn't given an example, and i couldn't find any others in their papers
09:13:25 <roconnor> @pl foldr (\x z-> Just $ maybe x (max x) z) Nothing
09:13:25 <lambdabot> foldr ((Just .) . ap maybe max) Nothing
09:13:42 <roconnor> foldr ((Just .) . ap maybe max) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:13:46 <roconnor> > foldr ((Just .) . ap maybe max) Nothing [-1,-4,-3,-5,-6,-25,-3,-19]
09:13:47 <lambdabot>  Just (-1)
09:14:05 <roconnor> > foldr ((Just .) . ap maybe max) Nothing []
09:14:07 <lambdabot>  Nothing
09:17:01 <mauke> > foldr (liftM return `liftM` ap maybe max) (fail "") [2,5,4]
09:17:02 <lambdabot>  Just 5
09:17:23 <dolio> ndm: Ah, you're right. I guess I'm having trouble coming up with a situation where that'd make a difference, as well.
09:18:28 <quicksilver> ndm: something to do with a zipper, maybe?
09:18:49 <quicksilver> ndm: since, in some sense, zippers turn your structures inside-out
09:18:52 <quicksilver> (but they don't really)
09:23:58 <ndm> quicksilver: still don't see how that would be useful, since the zipper is usually turning out the data structure, so you are doing operations over a different data structure
09:27:52 <quicksilver> ndm: It was an intuitive guess
09:27:57 <quicksilver> ndm: I'm by no means convinced myself :)
09:28:19 <quicksilver> ndm: my brain is so firmly in 'bottom-up' mode that I can't think of a convincing top-down version at all
09:28:31 <quicksilver> ndm: are some compiler optimisations best performed top-down perhaps?
09:28:41 <quicksilver> ndm: big-picture module optimisation?
09:29:05 <ndm> quicksilver: not that i can think of... - anything i come up with can be just as easily (if not more easily) done bottom-up
09:30:33 <quicksilver> ndm: maybe drop SPJ a note. I bet he had a compiler-motivated example in his head
09:30:55 <ndm> quicksilver: i've emailed the list, i'll see if he picks up on it - otherwise i will give him a mail - thanks
09:31:01 * ndm off now, bye!
09:33:02 <pitecus> what cabal uses to parse .cabal files, is that available as a separate package?
09:34:54 <daniel_larsson> It's part of the cabal package, but I'm not sure if it exports it :/ Check the cabal .cabal file
09:36:42 <mdmkolbe|work> ClaudiusMaximus: did you ever find a graphical graph editor for Yampa?
09:37:48 <pitecus> it exports smth called parseutils which must be it...
09:40:43 <daniel_larsson> Check Distribution.PackageDescription
09:50:24 <pejo> Suppose you answer a question before it's given, is that "preemptively"?
09:50:41 <LoganCapaldo> pejo: yes
09:51:01 <pejo> LoganCapaldo, and that spelling is correct?
09:51:29 <LoganCapaldo> My spell checker seems to think so
09:51:36 <pejo> Thank you.
10:01:38 <pitecus> Im wondering what should I use for a configuration file syntax: XML,YAML,JSON, Read-able haskell records?
10:01:59 <kpreid> with the right instances, the fourth is the same as one of the others!
10:02:16 <LoganCapaldo> clever kpreid
10:02:18 <LoganCapaldo> heh
10:02:33 <mdmkolbe|work> pitecus: depends on the application and the cluture you're tailoring it to
10:02:46 <mauke> pitecus: ini
10:02:54 <pitecus> ini, whats that?
10:03:40 <mauke> http://en.wikipedia.org/wiki/INI_file
10:03:41 <lambdabot> Title: INI file - Wikipedia, the free encyclopedia
10:03:47 <pitecus> basically i want to avoid introducing too many dependencies, and have smth human readable
10:04:32 <pitecus> mauke, ok so why would someone use some superseded windows file format?
10:04:43 <LoganCapaldo> pitecus: I made my own recently. it didn't take more than an hour
10:04:48 <mauke> it's human readable and simple
10:04:55 <LoganCapaldo> but I don't know if you want to bother with that
10:05:07 <mauke> I can parse it in ~10 lines of perl
10:05:25 <mdmkolbe|work> pitecus: ini is quite popular b/c it's so simple so I'd say it hasn't been superseeded
10:05:56 <pitecus> ok i guess its an option
10:06:30 <opqdonut> the only problem with ini is that it isn't hierarchical
10:06:35 <mdmkolbe|work> pitecus: still it depends on the feel of the application you want.  Windows -> Ini, Overblown/To-many-options -> XML, toy appliation -> readable Haskell expressions (or module that's compiled in)
10:07:00 <opqdonut> i prefer lua, but binding lua to a haskell program will probably be a PITA
10:07:07 <opqdonut> (unless C glue is used)
10:07:22 <LoganCapaldo> turing complete config files! hooray! :)
10:07:35 <opqdonut> LoganCapaldo: why not?-)
10:07:54 <opqdonut> reading config options from env. vars is a good idea too
10:08:03 <opqdonut> or a simple one
10:08:06 <opqdonut> rather
10:10:29 <mauke> get creative, use a config directory where the keys are names of symlinks and the values are the targets
10:10:55 <opqdonut> :)
10:11:04 <opqdonut> sounds like conffs (or whatever) from plan9
10:11:17 <mauke> huhu, putting the ffs in conffs
10:11:20 <opqdonut> well except it works a bit more like proc (catting values into files)
10:12:19 <dylan> turing-complete config files are useful if you need to make your personal config files work on multiple systems.
10:12:32 <opqdonut> exactly
10:12:50 <opqdonut> + using an existing solution is better than coding a homebrew parser
10:12:52 <opqdonut> with a custom format
10:13:15 <mauke> unless the existing parser sucks
10:15:14 <dylan> does base have a function for computing the md5 sum of a string?
10:16:39 <int-e> @where md5
10:16:39 <lambdabot> I know nothing about md5.
10:16:44 <int-e> @where+ md5 http://web.comlab.ox.ac.uk/oucl/work/ian.lynagh/md5/
10:16:45 <lambdabot> Done.
10:16:59 <thoughtpolice> there's also the crypto library which you can find on hackage
10:21:33 <LoganCapaldo> @hoogle String -> MD5
10:21:33 <lambdabot> No matches, try a more general search
10:25:41 <LoganCapaldo> ah well
10:25:41 <LoganCapaldo> Sometimes I think there should be _tons_ more type aliases, just to make hoogling easier <g>
10:25:41 <opqdonut> :D
10:25:41 <dmwit> ?seen ajudem_me
10:25:41 <lambdabot> I saw ajudem_me leaving #haskell 47m 37s ago, and .
10:25:41 <LoganCapaldo> type Feet = Integer; type Inches = Integer; @hoogle Feet -> Inches, etc. :)
10:25:41 <dylan> those thould be newtypes.
10:25:41 <dylan> *should.
10:25:41 <dylan> with typeclass for units of length, etc.
10:25:41 <int-e> newtype Feet a = Feet a
10:25:41 <LoganCapaldo> dylan: well ATM I'm looking at it from the point of view of searching, not actual API design :)
10:25:41 <LoganCapaldo> but yes you're obviously right
10:25:41 <int-e> deriving Num. I guess. Or maybe not - multiplication is bad :)
10:25:41 <A-oXiDe> can anyone help me with installing the haskell plugin in eclipse? ive forgotten how to go about it and got an exam in a few days :-/
10:26:14 <shapr> You're obviously not the average student. Most of them would say "in a few hours."
10:27:04 <MyCatVerbs> A-oXiDe: why on Earth do you need Eclipse for an exam? Autoflagellate, then learn to use vim, silly! ;)
10:27:17 <emu> good luck finding someone who actually uses eclipse
10:27:19 <shapr> I like emacs myself.
10:27:24 <A-oXiDe> autoflagellate?
10:27:26 <A-oXiDe> whats that
10:27:28 <MyCatVerbs> (or, uh, try jEdit or something, there's an interface for ghci for that which is pretty damn good.)
10:27:29 <shapr> Whip yourself
10:27:35 <Excedrin> I use Scite
10:27:46 <shapr> flagellum is latin for whip, and the auto prefix means "apply to self"
10:27:57 <A-oXiDe> lol
10:28:22 <A-oXiDe> how would i go about jedit?
10:28:31 <wolverian> carefully
10:28:46 <shapr> I've never used jedit.
10:28:53 <shapr> Well, once for five minutes.
10:28:55 <A-oXiDe> ok what would ppl recommend then?
10:28:58 <MyCatVerbs> A-oXiDe: hang on, I'll have to look this up for you.
10:29:16 <shapr> I'd say this channel is about half emacs and half vim users.
10:29:32 <Excedrin> is there an editor you're familiar with? if yes, use that, while using whichever Haskell you like and :r (reloading) the file after you save it
10:29:56 <A-oXiDe> yeah i dont mind using whatever
10:30:00 <A-oXiDe> ive used eclipse for it before
10:30:10 <MyCatVerbs> I'm with Excedrin on this one, choice of editor isn't really important so long as you're comfortable.
10:30:20 <A-oXiDe> but never got the compiler properly implemented
10:30:21 <MyCatVerbs> But I'll still light emacs users on fire recreationally.
10:30:50 <shapr> I think people should use whatever tool they prefer, and that they should regularly (once a year or so) try the other tools available.
10:31:02 <dylan> @quote for the games
10:31:03 <lambdabot> No quotes for this person. Listen, broccoli brains, I don't have time to listen to this trash.
10:31:04 <shapr> In my opinion that applies to languages, editors, operating systems, whatever.
10:31:10 <dylan> @quote dylan
10:31:10 <lambdabot> dylan says: [I] don't know peano numbers from beano
10:31:27 <shapr> @quote dylan
10:31:27 <lambdabot> dylan says: everything's a hack. the world's a hack.
10:31:43 * dylan doesn't remember saying either of those.
10:31:55 <shapr> @quote dylan
10:31:56 <lambdabot> dylan says: [I] don't know peano numbers from beano
10:32:11 <Excedrin> shapr: ya, that's a good idea; since I currently use Linux, Solaris and Windows on a daily basis, what's the next OS I should try?
10:32:12 <int-e> @quote emacs
10:32:12 <lambdabot> Philippa says: because emacs wasn't a good enough OS after all
10:32:23 <dylan> there's one about using emacs for the games..
10:32:30 <Excedrin> @quote games
10:32:30 <lambdabot> dylan says: I run emacs for the games
10:32:36 <shapr> Excedrin: Tried the Plan9 successor?
10:32:41 <Excedrin> Inferno?
10:32:43 <shapr> Yeah
10:32:48 <Excedrin> I actually bought that, and it's sitting on my shelf
10:32:57 <dylan> I've been running freebsd on my TV computer. :)
10:33:02 <Excedrin> I used it for a few days... since then it's been collecting dust
10:33:17 <shapr> There's a GPL version now, I think the filesystem-centric approach is interesting.
10:33:27 <Excedrin> oh, I'll have to check it out again
10:33:39 <Excedrin> it's still based entirely on Limbo, right?
10:34:02 <shapr> I think so
10:34:29 <MyCatVerbs> A-oXiDe: http://www.cs.bris.ac.uk/home/rb6822/jeditwikipage.html
10:34:31 <lambdabot> Title: BristolCSWiki: Jedit
10:35:36 <MyCatVerbs> A-oXiDe: my uni's CS department has jEdit installed on all the workstations and customized out to Hell so that it's really really nice to work with. That's a copy of a page from the internal wiki on how to enact the same customizations yourself at home.
10:35:57 <emu> i like how they feature Haskell next to Java
10:36:20 <MyCatVerbs> emu: they're both taught during the second half of the first year.
10:36:50 <emu> it's in java though eh
10:36:54 <MyCatVerbs> emu: they like to talk about how teaching a totally OO-centric language and a totally function-centric language simultaneously helps students learn to think muuuch bettar.
10:36:58 <emu> i'm not sure i even have java installed anymore
10:37:04 <emu> i guess i can try it on another machine
10:37:24 <MyCatVerbs> emu: personally, I like to think it's more to do with the fact that teaching the shit language too will make people with the neurons to understand it appreciate Haskell more ;)
10:37:35 <thoughtpolice> Excedrin: aside from plan 9 I would say bsd (openbsd'r here) :)
10:37:37 <emu> hehe
10:37:58 <shapr> Excedrin: Or try House :-)
10:38:02 <MyCatVerbs> Yesh, but jEdit with 'dem customizations is a really, really nice editor. Like, with that ghci plugin, it's at least one third or a Lisp REPL.
10:38:05 <MyCatVerbs> *of a
10:38:44 <thoughtpolice> emacs: mod+` then hit 'h' followed by 's' in haskell-mode
10:39:06 <thoughtpolice> interpreter baked in :)
10:39:32 <MyCatVerbs> thoughtpolice: niiice. I'll have to try that sometime.
10:39:34 <emu> haskell-mode runs ghci in a buffer like the old lisp repls
10:39:53 <shapr> Yeah, C-c C-l dumps the currently visited file into ghci
10:39:54 <emu> shim is the SLIME-like project
10:40:23 <emu> still needs work though -- i think it's currently being defeated by the difficulties of GHC API :(
10:40:36 <thoughtpolice> i generally have ghci open in emacs when ever I do any sort of haskell, even experiments
10:40:53 <emu> i have ghci open in emacs even when im not doing haskell oO
10:40:54 <Excedrin> thoughtpolice: I use openbsd at work and for a home machine (transparent filtering bridge) but not on the desktop... I think it's basically the same as any free *nix on the desktop
10:41:02 <emu> sometimes i have ghci and sbcl at the same time
10:41:09 <thoughtpolice> since I don't have to constantly quit and reopen or switch via ctrl+z/fg every time i make a change
10:41:12 * emu adds coq proofgeneral to that mix
10:41:17 <dolio> MyCatVerbs: What all does jEdit do for Haskell editing in that mode?
10:41:20 <thoughtpolice> emu: buffers are the greatest :)
10:41:25 * dolio has not used jEdit in a long time.
10:41:37 <MyCatVerbs> dolio: you have the REPL open in a window docked to the editor.
10:42:00 <dolio> MyCatVerbs: Ah. What about indenting and coloring and stuff?
10:42:20 <MyCatVerbs> dolio: you can happily copy and paste between 'em. An' isss a little more convenient for ^S-tab-:r ^^
10:42:29 <MyCatVerbs> I'm not sure. I can't actually remember.
10:42:50 <MyCatVerbs> I have vague memories of it being distinctly-not-shit, though.
10:42:55 <thoughtpolice> one of these days I'll get around to having roughly 10+REPL's in emacs at one time
10:43:05 <thoughtpolice> and just have that task backgrounded at all times for when I need it
10:43:07 <emu> oh, i guess eshell counts too
10:43:16 <dolio> Heh. Maybe I'll try it out, for nostalgia's sake. :)
10:43:19 <MyCatVerbs> My GOD
10:43:24 <MyCatVerbs> It's full of emacs users! ;)
10:44:32 <shapr> I sometimes have eshell, ghci, and python running at the same time in xemacs. And I use ERC for my irc client. The big downside is that emacs will never be multithreaded, and once you hit five or so processes, you start to see mysterious deadlocks.
10:44:37 <shapr> That's one reason I'd rather use Yi.
10:45:25 <emu> i guess the jedit haskell plugin is separate
10:45:28 <Nafai> Yi sounds like it could be very cool
10:47:07 <opqdonut> Nafai: _could_, exactly
10:48:40 <roconnor> @type writeFile
10:48:42 <lambdabot> FilePath -> String -> IO ()
10:49:41 <weitzman> I thought yi sounded like it could be cool, but when I tried to compile and run it on windows things that didn't make sense happened
10:49:53 <weitzman> The compiling went ok, but the running didn't
10:52:25 <roconnor> mify f [] = fail "mify: empty list"
10:52:25 <roconnor> mify f x = return (f x)
10:52:34 <roconnor> now I can say (mify head foo)
10:52:46 <roconnor> now I can say (mify last foo)
10:52:50 <roconnor> etc
10:52:59 <roconnor> ... granted this is a terrible name
10:54:28 <opqdonut> ?type fail
10:54:30 <lambdabot> forall (m :: * -> *) a. (Monad m) => String -> m a
10:54:37 <opqdonut> oh yes it was polymorphic
10:54:54 <opqdonut> > fail "lol" :: [String]
10:54:55 <lambdabot>  []
10:55:01 <opqdonut> > fail "lol" :: Either
10:55:02 <lambdabot>      `Either' is not applied to enough type arguments
10:55:02 <lambdabot>     Expected kind `?', ...
10:55:09 <opqdonut> > fail "lol" :: Either Int String
10:55:10 <lambdabot>   add an instance declaration for (Error Int)
10:55:10 <lambdabot>     In the expression: fail "lo...
10:55:18 <opqdonut> yeh yeh
10:55:27 <roconnor> > fail "lol" :: Either String Int
10:55:29 <lambdabot>  Left "lol"
10:55:37 <opqdonut> roconnor: yeah i realised
10:55:55 <opqdonut> ?src fail
10:55:55 <lambdabot> fail s      = error s
10:56:00 <opqdonut> :)
10:56:02 <opqdonut> ?src error
10:56:03 <lambdabot> error s = throw (ErrorCall s)
10:56:08 <weitzman> @src throw
10:56:08 <lambdabot> throw exception = raise# exception
10:56:21 * opqdonut is in a maze of twisty definitions, all alike
10:56:22 <weitzman> This path leads to madness
10:57:32 <Saizan> ?src [] fail
10:57:33 <lambdabot> fail _      = []
10:57:39 <Saizan> ?src Either e fail
10:57:39 <lambdabot> Source not found. Wrong!  You cheating scum!
10:57:49 <Saizan> ?src (Either e) fail
10:57:49 <lambdabot> Source not found. Just what do you think you're doing Dave?
10:58:02 <dolio> @src Either fail
10:58:02 <lambdabot> fail msg      = Left (strMsg msg)
10:58:07 <opqdonut> :)
10:58:19 <opqdonut> ?src strMsg
10:58:19 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
10:58:24 <opqdonut> :t strMsg
10:58:27 <lambdabot> forall a. (Error a) => String -> a
10:58:32 <roconnor> @hoogle getArgs
10:58:32 <lambdabot> System.getArgs :: IO [String]
10:58:33 <opqdonut> ah
11:00:54 <thoughtpolice> hm weird
11:17:38 <roconnor> @type unlines
11:17:43 <lambdabot> [String] -> String
11:22:57 <roconnor> @hoogle digit
11:22:58 <lambdabot> Text.ParserCombinators.Parsec.Char.digit :: CharParser st Char
11:22:58 <lambdabot> Char.digitToInt :: Char -> Int
11:22:58 <lambdabot> Char.intToDigit :: Int -> Char
11:23:04 <roconnor> @hoogle isDigit
11:23:04 <lambdabot> Char.isDigit :: Char -> Bool
11:24:14 <roconnor> @hoogle (x -> [x] -> Bool
11:24:14 <lambdabot> Prelude.elem :: Eq a => a -> [a] -> Bool
11:24:14 <lambdabot> Prelude.notElem :: Eq a => a -> [a] -> Bool
11:29:31 <defcons> hello
11:29:34 <defcons> The integer square root of a positive integer n is the largest integer whose square
11:29:34 <defcons> is less than or equal ton. For instance, the integer square roots of 15 and 16 are
11:29:34 <defcons> 3 and 4, respectively. Give a primitive recursive definition of this function.
11:29:41 <defcons> Is it possible to do it tail-recursively?
11:29:46 <defcons> rather than iteratively
11:31:12 <monochrom> they are different?
11:31:21 <opqdonut> tail-recursion is iteration :)
11:31:50 <defcons> you know what I mean
11:31:54 <defcons> you get iterative fib and recursive fib
11:32:29 <defcons> was I wrong in my choice of wrods?
11:32:29 <monochrom> I don't know what you mean. Seriously. Because what you say about "rather than" contradicts what I know. Clearly we are not on the same page.
11:32:41 <opqdonut> how 'bout just: floor . sqrt . fromIntegral ?
11:32:53 <_frederik_> hello, i upgraded to 6.6.1, now says "ghc-6.6.1: unknown package: mtl"
11:32:55 <_frederik_> what do i do?
11:33:03 <Saizan> i think he means from n and going down rather than from 1 and up?
11:33:04 <defcons> from #lisp , I seem to have learned that tail-recursive is different than iterative
11:33:08 <_frederik_> i don't see anything on the release notes
11:33:25 <defcons> okay
11:33:35 <monochrom> _frederik_:   how did you obtain and install ghc?  The answer depends on that.
11:33:43 <_frederik_> monochrom: debian
11:33:45 <defcons> is it possible to define a function as an answer to the question where the state is stored in the definition rather than the arguments?
11:34:11 <monochrom> look for libghc6-mtl-dev, let me double-check the name
11:34:20 <byorgey> monochrom: that's the right name
11:34:26 <monochrom> Nice!
11:34:37 <_frederik_> monochrom: ok thanks
11:34:48 <_frederik_> monochrom: why was it made non-default by the way?
11:35:09 <monochrom> In general look for libghc6-*   many libraries are unbundled since 6.6
11:35:18 <defcons> anyone?
11:35:41 <byorgey> defcons: what do you mean by the "state stored in the definition"?
11:35:45 <_frederik_> it would be nice if it were in the release notes for the debian package or on haskell.org
11:35:49 <monochrom> defcons: how do you store state in the definition?
11:35:53 <defcons> byorgey, it is when it is not stored in the arguments
11:36:09 <byorgey> defcons: well, the only way to do that is to use some sort of monad
11:36:17 <byorgey> defcons: and I don't think that's what you want to do =)
11:36:22 <dolio> > let sqt n = last . takeWhile ((<=n) . (^2)) $ [1..] in (sqt 15, sqt 16)
11:36:24 <monochrom> Do you plan to use Control.Monad.ST? mutable variables?
11:36:25 <defcons> in #lisp terminology, this is recursive:
11:36:27 <lambdabot>  (3,4)
11:36:30 <defcons> fac 0 = 1
11:36:38 <defcons> fac n = n * fac (n - 1)
11:36:43 <byorgey> defcons: ok, right
11:36:45 <defcons> and this is iterative:
11:38:07 <byorgey> defcons: ?
11:38:11 <defcons> I was thinking
11:38:37 <Jaggederest> there's no good iterative way in haskell ;)
11:39:00 <defcons> (defun fac (n &optional (cur 1)) (if (= n 0) cur (fac (- n 1) (* n cur)))
11:39:31 <byorgey> > let fac n = fac' 1 n where fac' r 0 = n; fac' r n = fac' (r*n) (n-1) in fac 5
11:39:32 <lambdabot>  5
11:39:44 <byorgey> hrm
11:39:56 <monochrom> _frederik_: it was actually said in 6.6 release notes 1.4.3
11:39:59 <byorgey> defcons: yes, I see what you mean
11:40:03 <defcons> okay
11:40:08 <byorgey> defcons: it uses an extra parameter to accumulate the result
11:40:15 <defcons> yes, the state is stored in the arguments
11:40:19 <byorgey> defcons: but it's still recursive
11:40:28 <defcons> hmm
11:40:34 <defcons> well lispers call it iterative
11:40:40 <monochrom> _frederik_: ok, it's said tersely :)
11:40:57 <byorgey> defcons: fair enough.  I think Haskellers don't tend to use the word "iterative" that way.
11:41:06 <defcons> hmm okay
11:41:39 <defcons> (defun fac (n) (if (= n 0) 1 (* n (fac (- n 1))))
11:41:43 <defcons> that's tail-recursive
11:41:52 <monochrom> It is?!
11:41:55 <byorgey> defcons: no
11:41:56 <dolio> No, that's recursive.
11:42:03 <dolio> Tail recursive is iterative.
11:42:05 <byorgey> defcons: after the recursive call to fac it still has to multiply by n.
11:42:54 <defcons> okay
11:43:00 <byorgey> defcons: tail recursive means, essentially, that the value of the entire expression is just the value of the recursive call
11:43:00 <defcons> well I got stuff mixed up
11:43:12 <monochrom> Please don't get stuff mixed up.
11:43:13 <byorgey> defcons: i.e. nothing else has to be done after the recursive call.
11:43:18 <byorgey> defcons: that's OK. =)
11:43:24 <defcons> monochrom, please bloody help instead of these stupid remarks that help noone
11:43:35 <Jaggederest> true iterative would be for i = 1; 1 to n do |x| i * x end
11:43:36 <defcons> I'm obviously confused and you are not helping by making these remarks
11:43:52 <defcons> I just want a non-iterative answer to the question I pasted
11:43:57 <defcons> and I'm asking if it's possible
11:44:00 <Saizan> let fac n = fac' 1 n where fac a 0 = a; fac' a n = fac' (a*n) (n-1) in fac 5
11:44:02 <byorgey> defcons: I doubt monochrom meant offense.
11:44:05 <Saizan> > let fac n = fac' 1 n where fac a 0 = a; fac' a n = fac' (a*n) (n-1) in fac 5
11:44:11 <lambdabot> Terminated
11:44:28 <jmesquita> Hello yall!
11:44:59 <Saizan> > let fac n = fac' 1 n where fac' a 0 = a; fac' a n = fac' (a*n) (n-1) in fac 5
11:45:01 <lambdabot>  120
11:45:02 <Botje> hello, jmesquita
11:45:11 <byorgey> defcons: so, in summary, "tail-recursive" is basically the same thing as "iterative"
11:45:20 <defcons> okay thanks
11:45:29 <monochrom> Sigh.
11:45:33 <byorgey> defcons: and both involve recursion (in Haskell/Lisp at least.)
11:46:07 <Jaggederest> you could use a loop or while in lisp... but why? :)
11:46:20 <byorgey> Jaggederest: well, right, Lisp is non-pure... =)
11:46:39 <byorgey> defcons: so your original question had to do with a function to compute integer square roots?
11:46:44 <defcons> yes
11:46:53 <jmesquita> ddarius, hello
11:47:03 <dolio> > let sqt n = last . takeWhile ((<=n) . (^2)) $ [1..] in (sqt 15, sqt 16)
11:47:05 <lambdabot>  (3,4)
11:47:16 <dolio> takeWhile is recursive, so if you inline everything, you'll get a recursive definition. :)
11:47:29 <roconnor> > product [1..5]
11:47:30 <lambdabot>  120
11:47:31 <byorgey> dolio: heh. =)
11:47:31 <Jaggederest> bam. that's slick
11:47:34 <defcons> right can it be done simply?
11:48:13 <ClaudiusMaximus> mdmkolbe|work: no, i didn't find a graphical graph editor for Yampa, but i didn't really look very hard either...
11:48:29 <byorgey> defcons: you could make a tail-recursive function that "counted up" from 1 until the square of the current count exceeded n
11:48:40 <byorgey> defcons: but that's basically what dolio's solution does
11:49:02 <defcons> but wouldn't that be iterative?
11:49:07 <byorgey> defcons: yes
11:49:20 <defcons> I'd like a non-iterative version
11:49:23 <byorgey> defcons: hmm
11:53:27 <Cale> What's the question?
11:53:49 <byorgey> Cale: a recursive version of floor . sqrt
11:54:20 <byorgey> Cale: presumably just using integer arithmetic
11:54:28 <Jaggederest> > let sqt` n x = if x^2 >= n then x else sqt' n (x + 1) in sqt' 15 1
11:54:28 <lambdabot>  Parse error
11:54:47 <newsham_> sqrt' != sqt`
11:54:49 <sjanssen> how are recursion and iteration different things?
11:55:11 <newsham_> sjanssen: in general or in haskell? :)
11:55:12 <shapr> ClaudiusMaximus: Seen blobs?
11:55:22 <byorgey> sjanssen: they're not, I think the distinction being made is between tail- and non-tail recursion
11:55:23 <sjanssen> newsham_: trick question, they're not different :)
11:55:45 <shapr> sjanssen: One can overflow?
11:55:53 <byorgey> sjanssen: which of course aren't really that different either
11:56:17 <byorgey> defcons: just out of curiosity, why are you asking/where did you get this question?
11:56:33 <Jaggederest> > let sqt` n x = if (x^2 >= n) then x else (sqt' n (x + 1)) in sqt' 15 1
11:56:33 <lambdabot>  Parse error
11:56:41 <defcons> it's from haskell, the craft of functional programming
11:56:50 <byorgey> Jaggederest: you've got a backtick after the first sqt
11:56:51 <defcons> and it hasn't explained iteration yet, so I'd like a non-tail recursive version
11:57:03 <defcons> or maybe it's expecting me to discover tail-recursion
11:57:06 <Jaggederest> ah thanks byorgey
11:57:12 <Jaggederest> > let sqt' n x = if (x^2 >= n) then x else (sqt' n (x + 1)) in sqt' 15 1
11:57:18 <Choko> hes
11:57:20 <lambdabot>  4
11:57:53 <byorgey> let sqt 1 = 1 ; sqt n = 1 + sqt ( 1 + n `div` 2) in map sqt [1..10]
11:57:58 <byorgey> > let sqt 1 = 1 ; sqt n = 1 + sqt ( 1 + n `div` 2) in map sqt [1..10]
11:58:01 <lambdabot>  Exception: stack overflow
11:58:12 <byorgey> > let sqt 1 = 1 ; sqt n = 1 + sqt ( 1 + sqt (n `div` 2)) in map sqt [1..10]
11:58:15 <lambdabot>  Exception: stack overflow
11:58:22 <ClaudiusMaximus> shapr: hmm, that seems to be a graph editor, but not designed for writing programs (unless i'm missing something)
11:58:25 <Jaggederest> > let sqt' n x = if ((x+1)^2 > n) then x else (sqt' n (x + 1)) in sqt' 15 1
11:58:26 <monochrom> n div 2 may be 1.
11:58:27 <lambdabot>  3
11:58:32 <Jaggederest> > let sqt' n x = if ((x+1)^2 > n) then x else (sqt' n (x + 1)) in sqt' 16 1
11:58:33 <lambdabot>  4
11:59:11 <byorgey> > let sqt 1 = 1 ; sqt n = 1 + sqt (n - ( 1 + (n `div` 2))) in map sqt [1..10]
11:59:14 <lambdabot>  Exception: stack overflow
11:59:19 <defcons> I guess I'll have to combine both
11:59:26 <byorgey> defcons: well, it's something like that I think
11:59:52 <byorgey> > let sqt 0 = 0 ; sqt 1 = 1 ; sqt n = 1 + sqt (n - ( 1 + (n `div` 2))) in map sqt [1..10]
11:59:54 <lambdabot>  [1,1,2,2,2,2,3,3,3,3]
12:00:13 <byorgey> hmm, off by one
12:01:56 <shapr> ClaudiusMaximus: Oh, in that case check out Aardappel. It's a graphical concurrent tree rewriting programming language: http://strlen.com/
12:01:57 <lambdabot> Title: Wouter van Oortmerssen's web pages
12:02:22 <Jaggederest> I still like floor . sqrt :) back to sleep for me
12:02:31 <byorgey> > let sqt 0 = 0 ; sqt 1 = 1 ; sqt n = 1 + sqt (n - ( 1 + ((n+1) `div` 2))) in map sqt [1..10]
12:02:32 <lambdabot>  [1,1,1,2,2,2,2,2,2,3]
12:02:44 <byorgey> nope
12:02:49 <byorgey> oh well
12:02:52 <defcons> integerSqrt n =
12:02:52 <defcons>     let actual a
12:02:52 <defcons>             | a^2 < n = a
12:02:52 <defcons>             | otherwise = actual (a - 1)
12:02:52 <defcons>     in actual n
12:03:09 <defcons> but that's iterative of course
12:03:14 <byorgey> defcons: right
12:03:17 <defcons> I guess there is no non-tail-recursive version
12:03:29 <byorgey> defcons: I think my version will work if it's tweaked in the right way
12:03:49 <dolio> Some things are naturally tail recursive.
12:03:50 <byorgey> defcons: it has to do with the fact that n^2 = sum(2k - 1) as k goes from 1 to n.
12:03:54 <dolio> @src last
12:03:54 <lambdabot> last [x]    = x
12:03:54 <lambdabot> last (_:xs) = last xs
12:03:54 <lambdabot> last []     = undefined
12:04:22 <defcons> why isn't last [], []?
12:04:29 <dolio> @type last
12:04:31 <lambdabot> forall a. [a] -> a
12:04:35 <sjanssen> defcons: that isn't well typed
12:04:38 <defcons> damn
12:04:52 <Cale> > let isqrt n = floor (fix' (f n') n') where {n' = fromIntegral n; f n x = (1%2)*(x + n/x); fix' f x | abs (f x - x) < 1 = f x | otherwise = fix' f (f x)} in map (ap (,) isqrt) [1..30]
12:04:54 <lambdabot>  [(1,1),(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(12,3),...
12:06:23 <Cale> > let isqrt n = floor (fix' f n') where {n' = fromIntegral n; f x = (1%2)*(x + n'/x); fix' f x = if abs (f x - x) < 1 then f x else fix' f (f x)} in map (ap (,) isqrt) [1..30]
12:06:25 <lambdabot>  [(1,1),(2,1),(3,1),(4,2),(5,2),(6,2),(7,2),(8,2),(9,3),(10,3),(11,3),(12,3),...
12:06:59 <Botje> :t ap (,) isqrt
12:07:01 <lambdabot> Not in scope: `isqrt'
12:07:04 <Botje> buh
12:07:13 <Cale> :t ap (,)
12:07:15 <lambdabot> forall a b. (a -> b) -> a -> (a, b)
12:07:19 <ClaudiusMaximus> shapr: looks interesting, but not really what i want either; i saw a diagram in a paper on Yampa that showed the data flow of some code, and want to write code in diagram form
12:08:07 <shapr> I don't know.
12:08:08 <Cale> @. pl djinn (a -> b) -> a -> (a, b)
12:08:08 <lambdabot> (line 2, column 9):
12:08:09 <lambdabot> unexpected ">"
12:08:09 <lambdabot> expecting variable, "(", operator or ")"
12:08:16 <Cale> @. pl djinn f :: (a -> b) -> a -> (a, b)
12:08:16 <lambdabot> Cannot parse command Cannot parse command
12:08:20 <Cale> er
12:08:30 <Cale> @djinn (a -> b) -> a -> (a, b)
12:08:30 <lambdabot> Cannot parse command
12:08:30 <lambdabot> f :: (a -> b) -> a -> (a, b)
12:08:30 <lambdabot> f a b = (b, a b)
12:08:30 <pastorn> yay
12:08:43 <Cale> @pl f a b = (b, a b)
12:08:43 <lambdabot> f = ap (,)
12:08:59 <pastorn> my head is spinning...
12:09:12 <pastorn> ap isn't exactly my favourite function
12:09:16 <pastorn> @hoogle ap
12:09:16 <lambdabot> Monad.ap :: Monad a => a (b -> c) -> a b -> a c
12:09:16 <lambdabot> Control.Monad.ap :: Monad m => m (a -> b) -> m a -> m b
12:09:16 <lambdabot> Data.Graph.Inductive.Query.ArtPoint.ap :: Graph gr => gr a b -> [Node]
12:09:20 <ClaudiusMaximus> shapr: http://www.blurty.com/users/claudiusmaximus/day/2007/05/11#398 << something like this, but not a mockup ;)
12:09:22 <lambdabot> Title: ClaudiusMaximus' 2007-05-11
12:09:24 <Cale> It's rather nice in the ((->) e) monad
12:09:38 <Cale> ap f g x = f x (g x)
12:10:02 <Cale> > ap (+) (^2) 5
12:10:03 <lambdabot>  30
12:10:13 <Cale> > (\x -> x + x^2) 5
12:10:14 <lambdabot>  30
12:10:38 <Cale> > ap (++) reverse "Hello!"
12:10:39 <lambdabot>  "Hello!!olleH"
12:11:20 <dolio> > fix ((1:) . (1:) . ap (zipWith (+)) tail)
12:11:22 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
12:11:32 <Cale> I was just about to do that :)
12:11:36 * cjeris tries to think of a combination of ap and fold to evaluate polynomials by Horner's rule
12:11:50 <shapr> ClaudiusMaximus: Have you seen Epigram?
12:12:00 <Excedrin> ClaudiusMaximus: you should look at the CAL GemCutter app
12:12:10 <Excedrin> ClaudiusMaximus: it's almost exactly what you're describing
12:12:19 <shapr> ClaudiusMaximus: Also, you should try using Aardappel. It's similar to your mockup.
12:13:50 <Excedrin> Aardappel is neat
12:14:52 <LoganCapaldo> @type join
12:14:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:14:57 <LoganCapaldo> @type flip ap id
12:14:59 <lambdabot> forall b a. (a -> a -> b) -> a -> b
12:15:22 <LoganCapaldo> > flip ap id (,) 2
12:15:23 <lambdabot>  (2,2)
12:15:24 <int-e> @type join id
12:15:26 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a1
12:15:26 <lambdabot>     Probable cause: `id' is applied to too many arguments
12:15:36 <LoganCapaldo> > join (,) 2
12:15:37 <lambdabot>  (2,2)
12:16:13 <LoganCapaldo> @type (->) join
12:16:14 <lambdabot> parse error on input `->'
12:16:32 <Cale> > let horner z = foldr ((. (z *)) . (+)) 0 in horner 2 [1,2,3]
12:16:33 <lambdabot>  17
12:16:38 <int-e> @type join . ($)
12:16:40 <lambdabot> forall a a1. (a1 -> a1 -> a) -> a1 -> a
12:18:52 <LoganCapaldo> there it is
12:18:52 <Cale> @pl horner z = foldr ((. (z *)) . (+)) 0
12:18:52 <lambdabot> horner = flip foldr 0 . (. (+)) . flip (.) . (*)
12:18:52 <Cale> heh
12:18:52 <LoganCapaldo> @type ($) f
12:18:52 <lambdabot> Not in scope: `f'
12:18:52 <LoganCapaldo> @type ($) ?f
12:18:52 <lambdabot> forall a b. (?f::a -> b) => a -> b
12:18:52 <Cale> too much flippiness for me to guess that :)
12:18:52 <ClaudiusMaximus> shapr, Excedrin: thanks for the ideas - plenty to read up on at least :)
12:19:16 <Cale> though in retrospect, it makes perfect sense :)
12:23:46 <jethr0> @seen
12:24:29 <jethr0> hi shapr
12:40:38 <shapr> dang, I missed jethr0
12:40:53 <shapr> Has anyone done 'test fixtures' with HUnit?
12:41:02 <shapr> gutentag jethr0
12:41:09 <shapr> Long time no see.
12:41:25 <jethr0> exactly, i'm in the czech republic now :)
12:41:29 <shapr> Cool!
12:41:42 <jethr0> and what've you been up to?
12:41:51 <shapr> Hacking on HAppS, what about you?
12:42:04 <jethr0> after a long time i've had the itch to do some serious "work" in haskell again
12:42:19 <jethr0> as in leisure
12:42:27 <shapr> Yeah, Haskell is leisure and fun!
12:42:57 <araujo> @yarr!
12:42:57 <lambdabot> I'd like to drop me anchor in her lagoon
12:43:30 <shapr> jethr0: What sort of leisure work?
12:43:56 <jethr0> i've tried to write an alpha-beta-pruning algorithm which was agnostic of problem representation. and that could be interrupted and resumed
12:44:15 <shapr> Sounds nifty.
12:44:18 <jethr0> i finally got it to work at some point but the whole code was a single uglyness.
12:44:46 <jethr0> so, i've been thinking to "rewrite" with the help of some this channels' gurus and maybe make it part of the intended AI library
12:44:50 <jethr0> *whoknows*
12:45:05 <shapr> Yeah, good idea.
12:45:48 <jethr0> also, i've started reading some papers again like the new zipper os paper or some stuff about applicative functors vs. comonads ;))
12:46:38 <dainanaki> so i'm trying to set up haskell on emacs, where might i find some detailed instructions on how to do that?
12:49:49 <shapr> dainanaki: Are you installing haskell-mode on linux or windows?
12:49:53 <shapr> jethr0: Yeah, that's seriously cool stuff.
12:50:21 <dainanaki> shapr, on a mac, so i surmise the linux guide would be more useful
12:53:08 <shapr> dainanaki: Here's the maintainer's page - http://www.iro.umontreal.ca/~monnier/elisp/#haskell-mode I'm not sure how things get installed on a Mac.
12:53:10 <lambdabot> Title: Emacs Lisp packages
12:53:29 <swiert> dainanaki: what emacs are you using?
12:53:50 <dainanaki> aquamacs
12:54:56 <swiert> You need to download the haskell-mode files and put them in ~/Library/Preferences/Aquamacs\ Emacs
12:55:20 <dainanaki> okie
12:58:22 <dainanaki> is that it?
12:59:04 <swiert> No. You need to add a file called "site-start.el" in the subdirectory containing the haskell-mode files.
13:02:05 <dainanaki> what has to be in that file?
13:02:05 <swiert> It should contain the stuff lisp code mentioned in the README file.
13:03:16 <dainanaki> alright i did that
13:03:38 <dainanaki> so how do i change to this mode?
13:03:56 * SamB_XP_ wishes MPLAB had a better dsPIC simulator...
13:04:15 <SamB_XP_> or, really, I wish *I* had one
13:04:38 <shapr> Gah, doing fixtures in HUnit isn't much fun.
13:04:57 <byorgey> dainanaki: meta-x haskell-mode
13:05:03 <Mr_Awesome> i have a function g :: a -> b -> c and a function f :: c -> d.  i want to compose the two to get a function a -> b -> d.  how can i do that?  f . g doesnt work, since it expects b -> c -> d instead of just c -> d for f.
13:05:11 <byorgey> dainanaki: you might have to restart emacs
13:06:33 <dainanaki> hooray
13:06:53 <dainanaki> now i just have to learn how to use emacs
13:07:00 <byorgey> @pl \f g x y = f (g x y)
13:07:00 <lambdabot> (line 1, column 10):
13:07:00 <lambdabot> unexpected "="
13:07:00 <lambdabot> expecting pattern or "->"
13:07:10 <byorgey> @pl \f g x y -> f (g x y)
13:07:10 <lambdabot> (.) . (.)
13:07:59 <byorgey> Mr_Awesome: just define compose' f g x y = f (g x y)
13:08:07 <byorgey> Mr_Awesome: then compose' f g
13:08:24 <norgul> is there many side effects in haskell?
13:08:43 <byorgey> Mr_Awesome: there might be a simpler way... I'll leave that to anyone more ninja in the ways of Haskell
13:08:53 <emu> side effects may include: headache when using other languages
13:09:05 <MyCatVerbs> norgul: yeah, it makes you fucking hate java.
13:09:05 <Mr_Awesome> byorgey: i see. thanks
13:09:24 <byorgey> emu: lol
13:09:27 <byorgey> norgul: what do you mean?
13:09:28 <sjanssen> @pl \x y -> f (g x y)
13:09:28 <lambdabot> (f .) . g
13:09:29 <emu> ... compulsion to write tutorials on monads
13:10:02 <dainanaki> thinking in haskell
13:10:04 <emu> sudden tendency to try parallelizing everything
13:10:16 <dainanaki> i actually had a dream in haskell last night
13:10:24 <byorgey> dainanaki: !?
13:10:37 <byorgey> dainanaki: in what sense?
13:10:42 <emu> @where haskell-mode
13:10:42 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
13:11:01 <dainanaki> after working on writing the prelude as practice, i fell asleep and it was literally functions all around me :|
13:11:07 <shapr> cool!
13:11:16 <jethr0> emu: instead of writing tutorials on monads i'd propose writing a really simple, understandable, impressive, small program in monad style and use that to teach intermediate monad users ;)
13:11:36 <emu> jethr0: a monad tutorial by any other name
13:11:44 <jethr0> dainanaki: yeah, rewriting prelude helped me a lot too
13:11:59 <byorgey> dainanaki: kind of like http://xkcd.com/c224.html, but with Haskell?
13:12:00 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
13:14:15 <jethr0> i think there's more than enough monad tutorials out there, but not quite enough short, understandable examples
13:14:15 <jethr0> most monad examples tend to overcomplicate and be especially smart
13:14:15 <pastorn> jethr0: i could usu that
13:14:15 <emu> > filterM (const [True,False]) [1..10]
13:14:15 <lambdabot>  [[1,2,3,4,5,6,7,8,9,10],[1,2,3,4,5,6,7,8,9],[1,2,3,4,5,6,7,8,10],[1,2,3,4,5,...
13:14:15 <pastorn> *use
13:14:15 <dainanaki> byorgey, very much like that, only i didn't talk with God and i still have to learn monads
13:14:15 <jethr0> pastorn:  use what?
13:14:15 <dainanaki> so maybe on a smaller scale
13:14:15 <pastorn> a good example to learn from
13:14:15 <byorgey> dainanaki: right, ok =)
13:14:41 <emu> i, unfortunately, am terrible at thinking up good examples
13:15:29 <jethr0> pastorn: exactly my point, unfortunately learning monads seems to be quite binary in nature. i tried to use all standard monads (state, reader, maybe, ...) until i kinda got the hang of it
13:15:48 <shapr> I think good monad examples should come from applying monads to everyday problems. Like sigfpe's "You could have invented monads, and probably already have!"
13:15:53 <emu> sure
13:16:05 <dainanaki> like grocery lists!
13:16:16 <dainanaki> that's a good example
13:16:16 <emu> ok, what about grocery lists?
13:16:17 <jethr0> ack
13:16:32 <shapr> Actually, you could do that...
13:16:42 <pastorn> how would i use monads when handling grocery lists?
13:16:50 <dainanaki> idunno, i haven't learned pretty much anything about monads
13:16:55 <dainanaki> i'm just throwing that out there
13:16:58 <pastorn> jethr0: start a paste...
13:16:59 <pastorn> @paste
13:16:59 <shapr> Maybe monad to filter out items you already own... Either would give you a response if you're out of money...
13:16:59 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:17:33 <shapr> Maybe you could use the Reader monad as an example of one particular trip to the grocery store?
13:18:00 <pastorn> but those are easy... Maybe and Either are simple... it's state and the basic principles behind them that is difficult
13:18:06 * shapr wonders if the Cont monad involves shoplifting...
13:18:07 <newsham_> $ echo "2 + 2" | ./runplugs
13:18:07 <newsham_> runplugs: /u1/tim/lambdabot/ShowQ.o: unknown symbol `templatezmhaskell_LanguageziHaskellziTHziSyntax_zdf21_closure'
13:18:08 <jethr0> pastorn: paste what?
13:18:08 <dainanaki> and then writing to the list or changing your mind about things
13:18:10 <newsham_> runplugs: user error (resolvedObjs failed.)
13:18:14 <newsham_> anyone familiar with this?
13:18:31 <pastorn> jethr0: some easy examples
13:19:05 <Baughn_> newsham_: I've seen it, but.. hmm. Is that lambdabot's build directory?
13:19:23 <newsham_> thats where I built it
13:19:26 <shapr> dainanaki: Yeah, list monad could find the best deals with backtracking... or even find the best tradeoff between spending gas money to visit other stores with cheap prices, or paying more money at a nearby store to save yourself time and gas.
13:19:31 <jethr0> pastorn: haven't got any handy. but for example implementing reader, writer, state monad is a good exercise once you've "grokked" the basic principles
13:20:25 <pastorn> what i want to do is to have the proper knowledge to know wtf ap does
13:20:38 <SamB_XP_> I think that, after I wrote my first monad, I realized that I might as well have just used State anyway ;-)
13:20:41 <dainanaki> i get the ideas behing monads, i just don't  actually know how to use them yet
13:20:58 <shapr> dainanaki: I think the grocery list idea is pretty cool.
13:21:20 <dainanaki> nobody hijack it!
13:21:26 <shapr> Quick, write it!
13:21:26 <hpaste>  emu pasted "Going grocery shopping" at http://hpaste.org/199
13:21:28 <pastorn> i won't
13:21:29 <Baughn_> newsham_: It's lambdabot's source directory? You're not moving it elsewhere?
13:21:31 <dainanaki> i'm gonna use that as my excuse to learn monads
13:21:34 <Baughn_> Then I'm no help, I'm afraid.
13:21:42 <shapr> dainanaki: Good idea
13:21:44 <newsham_> the build script copies binaries into the source directory
13:21:49 <newsham_> I stick w/ that convention
13:21:49 <glguy> pastorn: You mean more than: ap takes the function result from one computation and the argument result from another and applies the argument to the function in a wrapper?
13:22:00 <newsham_> ./Setup.hs configure --bindir=`pwd` --libdir=`pwd`/lib
13:22:01 <newsham_> etc..
13:22:34 <Baughn_> newsham_: Hang on. You didn't use the build script?
13:22:46 <Baughn_> newsham_: You need to do that; lambdabot is not particularily well cabalized
13:22:53 <newsham_> I did use the build script (indirectly)
13:23:01 <jethr0> although i've sometimes had ideas for writing my own monad, most of the time i could just use a standard one
13:23:21 <emu> there you go, Grocery shopping with State.
13:23:30 <Baughn_> newsham_: I made myself a version that, among other things, solved that problem - see http://rafb.net/p/bDSYNN74.html . I don't know if it'll help, but try it anyway.
13:23:32 <lambdabot> Title: Nopaste - No description
13:23:55 <pastorn> glguy-: i want to be able to read it and say "Aha, cool, just what i was looking for, let's use it here"
13:24:41 <newsham_> any idea what is causing runplugs behavior?
13:24:50 <newsham_> this used to work in 6.4.2, now i built with 6.6.1 and its failing
13:24:53 <emu> now i'm hungry. someone buy me some groceries.
13:24:53 <Baughn_> newsham_: Oh, and I think it also happened once after not cleaning lambdabot after upgrading.. some library
13:24:55 <newsham_> most other parts of the bot work fine
13:25:08 <newsham_> hmm..
13:25:45 <jethr0> pastorn: unlikely, for some monads you just need to give it just a few minutes ;)
13:25:47 <newsham_> maybe the tree didnt get cleaned enough..
13:25:48 <newsham_> thanks.
13:25:52 <newsham_> hey glguy
13:25:55 <glguy-> hi
13:26:03 <glguy-> colloquy has been buggy for me today :(
13:26:17 * glguy- changed his nick so everyone can see his hostname :-)
13:26:36 <Baughn_> newsham_: I've got a *large* list of patches that make it work with 6.6.1, most rather hacky and not at all sent anywhere. You can find it at http://brage.info/~svein/repos/milfbot/ , but it's very much a hackjob. Be very careful about which patches you apply.
13:26:37 <lambdabot> Title: Index of /~svein/repos/milfbot
13:27:00 <newsham_> i've got a custom tree at the moment and would prefer not to have to do a lot of merging :)
13:27:13 <newsham_> at some point i need to get off my ass and clean up my deltas and submit them
13:27:22 <newsham_> i run my bot on silc, not irc...
13:27:50 <Cf> does anyone know if there's a guide to texture mapping using HOpenGL?
13:27:56 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/200
13:27:57 <Baughn_> newsham_: You can use mine as inspiration, anyhow. The solution is in there.. somehow.
13:28:01 <Cf> library has no explanation at all :(
13:28:12 <pastorn> wtf? "milfbot"?
13:28:21 <Baughn_> pastorn: A long, anime-related story.
13:28:55 <newsham_> glguy: you can receive /msg's right?
13:29:07 <glguy> umm... I haven't yet
13:29:07 <emu> ajudem_me: looks ok
13:29:23 <newsham_> ahh, msg'd you.. i'll put it here
13:29:23 <glguy> try now?
13:29:26 <glguy> I'm identified
13:29:43 <newsham_> i hijacked your code. take a look at this: http://www.thenewsh.com:8000/
13:29:46 <lambdabot> Title: recent - hpaste
13:30:03 <ajudem_me> emu the prob is that WinHugs said: (Integer,Integer,[a],Condicao) doesnt match (Int,Int,[Stm],Condicao)
13:30:18 <emu> ajudem_me: try fromIntegral (-1)
13:30:23 <emu> weird though, hugs bugs?
13:31:43 <Bourbaki> hidiliho
13:31:54 <Bourbaki> is there anything like octave for haskell?
13:32:07 <ajudem_me> emu... Hmmm... I'm guessing it's just poiting in a bad direction
13:32:25 <glguy-> newsham_: try now?
13:32:27 <newsham_> glguy: i hijacked your code. take a look at this: http://www.thenewsh.com:8000/
13:32:27 <lambdabot> Title: recent - hpaste
13:32:55 <glguy-> newsham_: I see you added images
13:33:17 <newsham_> yah, its just a hack for replacing certain strings in between []'s with image tags
13:33:24 <glguy-> cool
13:34:23 <glguy-> I've been occupied with moving and startinga new job.. getting married
13:34:26 <glguy-> the list goes on
13:34:40 <glguy-> making it hard to get motivated to get my ass back in gear with hpaste
13:34:40 <byorgey> glguy-: congratulations!
13:34:42 <newsham_> congrats on all three
13:34:44 <dainanaki> nooo
13:34:59 <byorgey> dainanaki: what? are you getting married too?
13:35:14 <byorgey> dainanaki: it's not that bad
13:35:15 <dainanaki> no
13:35:19 <byorgey> =)
13:35:35 <jethr0> maybe dainanaki stalled while trying to get his ass back into gear ;)
13:35:47 <dainanaki> i was concerned for a moment that i'd lost my haskell file
13:35:55 <dainanaki> with all my notes
13:35:59 <jethr0> nooooo, *THE* haskell file
13:36:06 <dainanaki> but i found it
13:36:19 <jethr0> unless it's 1TB big, how about a backup copy...
13:36:36 <dainanaki> yeah yeah
13:36:53 <byorgey> wow, if xmonad can be written in under 500 lines, just imagine what you could do with 1TB of Haskell!
13:37:10 <int-e> and how long ghc would take to compile it :)
13:37:21 <jethr0> hmm, that diagram (http://en.wikibooks.org/wiki/Haskell/Class_declarations) with haskell class instances could come in real handy sometime
13:37:22 <dainanaki> lol cure cancer duh
13:37:31 <dainanaki> and aids
13:37:38 <emu> build a machine capable of destroying the universe!
13:37:38 <SamB_XP_> byorgey: not much
13:37:45 <dainanaki> and write a monad that solves world hunger
13:37:49 <SamB_XP_> people can't follow that big a program
13:37:55 <byorgey> build a machine capable of simulating the universe!
13:37:58 <byorgey> erm...
13:38:00 <navi> answering the ultimate question of the life, the universe and everything
13:38:13 <navi> no, finding the question, I mean :-)
13:38:18 <SamB_XP_> I'm fairly certain the TB would be used to hold the universe data, not the code to simulate it
13:38:19 <byorgey> SamB_XP_: obviously, it would have to be generated by a computer-generated program-generating program
13:38:20 <jethr0> with 1TB of haskell you could write a simulator that was faster than the computer it ran on
13:38:39 <SamB_XP_> jethr0: such things are not actually unheard of
13:38:44 <dainanaki> lol
13:38:58 <jethr0> SamB_XP_: you have me intrigued
13:39:00 <SamB_XP_> but I'm fairly certain they aren't anywhere near that size
13:39:05 <navi> it probably even would be able to solve the halting problem
13:39:11 <SamB_XP_> well, there is this thing called, iirc, VM
13:39:27 <SamB_XP_> for s/360
13:39:29 <emu> thus rendering the universe undecidable
13:39:31 <emu> poof
13:40:30 <Baughn_> byorgey: I already /have/ a program capable of simulating the universe. It's really simple.
13:40:37 <byorgey> Baughn_: nice!
13:40:46 <byorgey> Baughn_: ok, what am I going to say next?
13:40:48 <hpaste>  ajudem_me annotated "(no title)" with "(no title)" at http://hpaste.org/200#a1
13:41:10 <ajudem_me> I don't know why this happens...
13:41:17 <Baughn_> byorgey: "Build me a program capable of simulating /only/ this universe"
13:41:20 <glguy-> ajudem_me: what spoken language is that
13:41:24 <jethr0> > replicate 20 "(no title)"
13:41:26 <lambdabot>  ["(no title)","(no title)","(no title)","(no title)","(no title)","(no title...
13:41:32 <emu> portuguese?
13:41:39 <byorgey> Build me a program capable of simulating /only/ this universe
13:41:39 <ajudem_me> lol.. again, yes ;P
13:41:42 <Bourbaki> is there any haskell lib that is building up stuff like groups rings and fields and the like?
13:41:48 <byorgey> wow, it works!
13:42:01 <emu> Bourbaki: check out the math section of the wikiki
13:42:08 <jethr0> byorgey: doesn't simulating include the possibility of repetition?
13:42:15 <Bourbaki> on haskell.org?
13:42:21 <ajudem_me> do you guys know what's the problem?
13:42:25 <emu> that would be the one
13:42:35 <navi> Bourbaki: search for NumericPrelude
13:42:38 <Baughn_> jethr0: The issue with my simulation is that it simulates all universes that can be simulated by a turing machine
13:42:52 <jethr0> Baughn_: heh
13:42:56 <jethr0> :)
13:43:00 <emu> ajudem_me: try fromIntegral (-1) ... really
13:43:14 <emu> and how old is your Hugs
13:43:16 <ajudem_me> emu, where?
13:43:31 <ajudem_me> -> Sep 2006
13:43:34 <emu> ajudem_me: ... instead of -1
13:43:39 <byorgey> ajudem_me: d_erro ((-1) :: Int, (-1) :: Int, [], FIC)
13:43:42 <emu> > fromIntegral (-1) == -1
13:43:44 <lambdabot>  True
13:43:52 <byorgey> ajudem_me: that should work too
13:43:57 <emu> yea
13:43:59 <Cale> One especially nice trick is to implement a general monoid ring using an instance of Monoid and an instance of Num as parameters. You get lots of interesting rings for free from that.
13:44:34 <byorgey> Cale: hm, neat
13:44:43 <Cale> For example, using some bag datatype as the monoid, you essentially have the polynomial ring in arbitrarily many indeterminates.
13:45:02 <SamB> Baughn_: what if we want to simulate other universes with the same laws of physics?
13:45:24 <navi> Is it possible to do something like "instance Constraing a => SomeClass (a -> a) where ..."?
13:45:32 <Baughn_> SamB: There is no such thing, assuming you count initial conditions as part of those laws. (You should, really)
13:45:34 <Cale> navi: yep
13:45:46 <navi> ghc doesn't let me
13:45:54 <SamB> Baughn_: we don't have any idea what those conditions were, if there were any initial conditions
13:46:05 <ajudem_me> byorgey, emu, it did work. But why?
13:46:10 <Baughn_> SamB: True, but you can get around that by simulating all of them
13:46:16 <Cale> navi: maybe turn on -fglasgow-exts?
13:46:21 <emu> ajudem_me: for some reason it's assuming that integer literals are Integers
13:46:33 <navi> Cale, done already :-)
13:46:34 <SamB> Baughn_: that would be stupid
13:46:38 <Cale> hmm
13:46:39 <emu> @type fromIntegral
13:46:41 <lambdabot> forall a b. (Num b, Integral a) => a -> b
13:46:50 <Baughn_> SamB: It might be what the universe is actually doing, though
13:46:55 <emu> now that will take something that is an Integral and allow it to be used anywhere that a Num is allowed
13:47:09 <navi> Cale, I'll try to reproduce it, be back in a couple of minutes
13:47:23 <emu> ajudem_me: Integer vs Int is a type mismatch.  but if you convert it to Num a => a, then it is ok to match it with Int.
13:47:44 <Cale> class C a
13:47:44 <Cale> class S a
13:47:44 <Cale> instance (C a) => S (a -> a)
13:47:44 <ajudem_me> what's the diference between Int and Integer?
13:47:46 <emu> @type fromIntegral (-1)
13:47:46 <SamB> Baughn_: ... so you mean it started with one universe like THIS ONE?
13:47:48 <lambdabot> forall b. (Num b) => b
13:47:49 <Cale> that works in my GHC.
13:47:54 <glguy-> ajudem_me: bound
13:47:58 <emu> ajudem_me: Ints are machine sized, Integers are arbitrary precision
13:48:14 <ajudem_me> oh...
13:48:23 <Baughn_> SamB: I'm no longer sure what we're discussing, but heck, why not claim it started with one turing machine busily emulating all possible universes in parallel?
13:48:29 <emu> ajudem_me: normally, Haskell is supposed to silently wrap literals with (fromIntegral ...) but for some reason your hugs is not doing this.
13:48:33 <Cale> Integer will use machine ints when the numbers are still small enough though
13:48:33 <ajudem_me> emu, is there any more cases like that?
13:48:43 <Cale> (but the extra tests will make things a little slower)
13:48:47 <byorgey> Cale: really?  That's good to know
13:49:06 <Cale> byorgey: Well, it's not part of the standard, but GHC does that.
13:49:13 <emu> automatic promotion is something i'm used to from CL, so i am a bit annoyed by the Int/Integer disparity
13:49:18 <byorgey> Cale: oh, ok.
13:49:25 <Cale> emu: then just use Integer
13:49:29 <emu> which is what i do
13:49:42 <Cale> Unfortunately, lots of prelude functions use Ints
13:49:45 <emu> yep
13:49:50 <Cale> rather than being generic
13:49:51 <Bourbaki> is there anything build in haskell in the prelude that allows me to write function in a way that i can derive them?
13:49:55 <jethr0> stupidly
13:49:57 <Baughn_> emu: Or don't specify type when a typeclass will do
13:50:15 <emu> ajudem_me: so Int and Integer are separate types, but they share the Num (and Integral) class in common, so you just need to convince GHC that your value is of that class
13:50:28 <emu> er hugs
13:50:32 <byorgey> Bourbaki: what do you mean?
13:50:32 <navi> Cale, I get the following error: Illegal instance declaration for `Additive.C (a -> a)' (The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables)
13:50:44 <Cale> Bourbaki: no, not really. If you have a large number of boilerplate instances to write, Template Haskell might be an answer.
13:50:46 <int-e> navi: that shouldn't happen with -fglasgow-exts
13:51:01 <Bourbaki> byorgey id like to write down a polynomial and derive it paritally if possible
13:51:26 <byorgey> Bourbaki: ah, like calculus?
13:51:28 <Cale> navi: Yeah, that's a Haskell-98-only error
13:51:33 <navi> int-e, hmm, I have {-# -fglasgow-exts -fno-implicit-prelude #-} at the top of the file
13:51:35 <Bourbaki> byorgey yep
13:51:47 <int-e> navi: it's {-# OPTIONS_GHC ... #-}
13:52:04 <byorgey> Bourbaki: there's nothing like that in the prelude, but there are definitely libraries that let you do this sort of thing
13:52:15 <navi> int-e, oh, now I see :-)
13:52:27 <Bourbaki> byorgey i have written that stuff here in c++ but would like to do a rewrite in haskell
13:52:27 <Bourbaki> http://video.google.de/videoplay?docid=-979203120692178262&q=fluid+solver
13:52:29 <Cale> Bourbaki: oh, differentiate
13:52:30 <lambdabot> Title: Real Time Fluid Solver 3 - Google Video, http://tinyurl.com/288ohh
13:52:42 <navi> ok, now it works. Thanks!
13:52:46 <glguy-> What is the new pragma though? LANGUAGE_EXTENSIONS (something in that spirit)
13:52:49 <Cale> Bourbaki: I assumed that you meant derive in the sense of data ... deriving (...)
13:53:17 <Bourbaki> Cale no id like to more or less build some differential geometry framework
13:53:19 <Cale> Bourbaki: You can just construct an appropriate datatype for representing functions.
13:53:21 <Bourbaki> for that fluid stuff and such
13:53:41 <byorgey> Bourbaki: do these have to be polynomials in more than one variable?
13:53:46 <Bourbaki> Cale sure that should work but if someone did that stuff already i wont reinvent the wheel :)
13:53:50 <navi> Bourbaki, take a look at this blog post: http://augustss.blogspot.com/2007/04/overloading-haskell-numbers-part-2.html
13:53:52 <lambdabot> Title: Things that amuse me, http://tinyurl.com/ypvsr2
13:53:53 <byorgey> Bourbaki: with partial derivatives, etc.?
13:54:04 <Bourbaki> byorgey yes but its just one polynomial thats it based on
13:54:09 <Bourbaki> byorgey yep
13:54:13 <Cale> Bourbaki:  I'm sure that similar things have ended up on the Haskell mailing lists before.
13:54:28 <Bourbaki> navi thanks
13:54:46 <byorgey> Bourbaki: well, I've seen this sort of thing done for power series/single-variable polynomials but not multivariate
13:55:00 <byorgey> Bourbaki: although that definitely doesn't mean it hasn't been done, I don't know everything!
13:55:03 <Bourbaki> id just like to write the math stuff in haskell and do the rendering in c++ is there some easy way to export dlls from haskell?
13:55:42 <Excedrin> why do the rendering in C++? also, what rendering (graphs and such, or game stuff)?
13:55:51 <navi> Bourbaki, I'm actually writing some code which should work with multivariate polynomials and differentiation, but I'm not there yet
13:55:55 <Bourbaki> the math is easy but id like to implement it in a precise way and very concise
13:56:07 <Bourbaki> the fluid thingy is like 20 lines of code in c++
13:56:28 <Bourbaki> Excedrin the rendering like in the video surface with 1mio triangles and the water particles
13:56:41 <Bourbaki> navi cool
13:57:04 <newsham_> Baughn_: ahh, you got rid of the TH import and the code that needed it in ShowQ.hs.
13:57:12 <newsham_> doing the same fixes that particular error.
13:57:15 <Bourbaki> id like to go as far as exterior algebra in the end on manifolds
13:57:24 <newsham_> not sure the implications of that on functionality
13:57:40 <Bourbaki> i think that haskell would be so good for that kind of stuff
13:57:42 <navi> the best thing I was able to find was the NumericPrelude library, it even has the polynomials, but not multivariate (or they are not powerful enough for my needs)
13:57:57 <Bourbaki> theres still no lightweight haskell embedded interpreter for c++ right?
13:59:57 <dainanaki> isn't haskell pretty much good for everything
14:00:03 <dainanaki> ?
14:00:07 <Bourbaki> i have used that ogl stuff from ghc the other day but it wasnt very nice to use imho
14:00:12 <Bourbaki> sure :)
14:00:34 <Bourbaki> but for all that graphics stuff its a bit queer to use
14:00:37 <jethr0> dainanaki: well, in theory. but i still believe in "the right language for the job", even though haskell is indeed extremely versatile
14:00:43 <navi> dainanaki, hmm, I'm not sure if we can really write some hard-realtime programs in it
14:00:48 <emu> hopengl works nicely
14:00:49 <dainanaki> true
14:01:07 <emu> yea a hard-realtime program requires some hard-realtime GC and runtime techniques ..
14:01:14 <emu> someone, go outfit GHC with that!
14:01:15 <Bourbaki> emu yes but at least when i used it some years ago it was a pain to use
14:01:28 <emu> more of a pain than C++?
14:01:29 <Bourbaki> im used to write stuff in dx
14:01:32 <emu> oh
14:01:36 <Bourbaki> did that for a living
14:01:39 <navi> emu, there was an article which described, how it is possible to make the GHC GC predictable
14:01:40 <emu> ok .. i never use DX
14:01:49 <dainanaki> well any chance that haskell' will be able to do realtime stuff?
14:01:59 <emu> it's not the language which is about realtime, its the implementation
14:02:09 <Bourbaki> http://codemages.sourceforge.net/homotopy1.hs
14:02:16 <Bourbaki> i have written that stuff back then
14:02:18 <emu> generational GC tends to be fairly responsive but it's no RT GC
14:02:22 * jethr0 thinks that it would be possible to write a compiler to make haskell hard-RT (not sure about some corner cases of the report though). it's all a question of how smart and complex the compiler analysis is
14:02:24 <navi> emu, but that is not the only problem, you need predictable execution of the threads
14:02:40 <emu> every problem is solvable with a SSC
14:03:25 <navi> @google Non-stop Haskell
14:03:26 <lambdabot> http://research.microsoft.com/~simonpj/Papers/inc-gc.htm
14:03:26 <lambdabot> Title: Simon Peyton Jones: papers
14:03:30 <dainanaki> well i'm just waiting for haskell to soundly beat c at everything
14:03:30 <dainanaki> because i figure it's going to happen at some point
14:03:51 <saccade> there are some people in csail who use haskell to create hardware controllers for robotics
14:04:02 <saccade> but there's an additional layer of implementation there
14:04:07 <navi> dainanaki, I doubt it, but I'd be very happy if it is possible to make it
14:04:52 <Mr_Awesome> if i have data D = A, is there a way to check whether a D is an A without pattern matching (ie, a predicate for this)?
14:05:04 <navi> saccade, they are probably generating the realtime code, but not actually running it on the Haskell runtime
14:05:04 * jethr0 would contend himself with haskell being only as fast as hand-optimized C ^_^
14:05:08 <Botje> is_a (A _) True
14:05:15 <Botje> bleh. you get the gist
14:05:29 <saccade> Mr_Awesome: that's right
14:05:53 <Mr_Awesome> saccade: whats right?
14:06:29 <dainanaki> isn't ghc being rewritten to compile directly to assembly instead of c first?
14:06:44 <dainanaki> so that would increase speed i bet
14:07:13 <navi> dainanaki, and what about the predictability? :-)
14:07:46 <dainanaki> beats me, i'm just saying what i heard
14:07:47 <Saizan> it compiled to c because gcc produced faster code in the end, in HEAD this is no more true and the default is to compile directly to asm
14:07:50 <navi> I'm not sure how it should really work with lazy functions and all that stuff
14:08:36 <dainanaki> ok so it is doing that then
14:08:36 <dmead> what would be the problem?
14:08:36 <dmead> o0
14:08:56 <Mr_Awesome> Botje: iow, i should write my own predicate?
14:09:02 <byorgey> Mr_Awesome: you could use a case expression
14:09:12 <dmead> case x of
14:09:14 <byorgey> Mr_Awesome: as in, case d of A -> blah...
14:09:16 <dmead> A -> function
14:09:16 <navi> you can't estimate how long it would take to compute the value and how much memory it would take
14:09:28 <Saizan> why not?
14:09:54 <Saizan> given a predictable GC
14:09:55 <Mr_Awesome> that would be much more verbose than if i had a predicate though... oh well
14:10:10 <byorgey> Mr_Awesome: you could make your own predicate, as Botje suggested
14:10:18 <dmead> Mr_Awesome, you don't need predicates
14:10:23 <dmead> when you have pattern matching
14:10:23 <navi> because of the lazy execution you never know when the things get computed in reality
14:11:06 <byorgey> dmead: of course you don't NEED them, but I could maybe think of times when it would make something more understandable
14:11:08 <navi> and that poses a problem for the realtime app developer, because one usually doesn't want an extra calculations to kick in at the wrong time
14:11:32 <Saizan> navi, well realtime is only observable in the I/O, and we have IO to give us a predictable semantic
14:11:37 <dmead> byorgey, when can think in haskell, then it will be fine
14:11:46 <navi> but my understanding of the problem may be twisted and I'd be happy to learn that it's not true
14:12:06 <Mr_Awesome> dmead: that didnt make sense
14:12:31 <Baughn_> navi: Things are evaluated at need, but it is my understanding that said need is predictable; it won't evaluate anything /before/ it's needed.
14:12:48 <ajudem_me> what method do you use for debugging?
14:12:54 <navi> Saizan, but we also have some computations going on which are not IO and thus the data gets computed on by-need basis
14:13:06 <dmead> Mr_Awesome, predicate functions aren't useful when you have pattern matching as part of the language
14:14:11 <Saizan> navi: that doesn't make it less predictable, only less performant, and you could force that values when you decide
14:14:22 <navi> Baughn_, that may be a problem, when you can precompute the data during the low cpu-utilization period, but when the data is actually needed the utilization may be high and you can miss a deadline
14:14:27 <Saizan> s/decide/want/
14:14:59 <Baughn_> navi: You can force computation at need, though
14:15:42 <navi> Saizan, is it really that easy to force the computations for the other-than-obvious cases?
14:15:52 <navi> I haven't looked into that yet
14:16:54 <Saizan> for example to parallelize computations there's rnf == reduce to normal form in Control.Parallel.Strategies (?)
14:17:09 <Baughn_> navi: The forcing is done at-need, in that you have to somehow ask for a datum that, to be computed, will force the rest of the computation you want
14:17:28 <Baughn_> navi: However, if you're going to need the data later, presumably you'll have a way to /access/ it later. Use that.
14:17:56 <navi> Baughn_, yep, putting it that way helps
14:18:39 <Baughn_> navi: rnf is your best friend, as he said. seq will let you artificially create a dependency where none otherwise exists, useful outsid IO.
14:18:42 <navi> I guess now I'll be less skeptical about the possibilities of implementing realtime apps in Haskell some day
14:19:19 <Excedrin> lazy doesn't mean concurrent/asynchronous
14:19:28 <dainanaki> yay!
14:19:56 <Mr_Awesome> if i have three patterns in a row all with the same result, is there any way to combine them all in one line so i dont have to keep retyping the result?
14:20:12 <navi> ok, how about threads? Haskell uses green threads, right?
14:20:21 <Baughn_> navi: Using the accessors in advance is preferable to using rnf, though, since any halfway complex haskell app will likely be studded with infinite or nigh-infinite structures that you /really don't want to force/.
14:20:36 <byorgey> dainanaki: what's so exciting?
14:21:05 <dainanaki> that navi is less skeptical about realtime in haskell
14:21:12 <Baughn_> navi: Unspecified. Implementation-wise, GHC uses cooperative threads internally, but will also use multiple OS threads to take advantage of parallelism
14:21:49 <dainanaki> because he knows more than i do about haskell and programming, so that makes him more credible to me than what i gather from hearsay
14:21:52 <navi> Baughn_, something like one native thread per core?
14:22:21 <Baughn_> navi: The user specifies, but N+1 is best - it needs one to block on select.
14:22:36 <Baughn_> navi: Though I think it adds 1 to the number you specify anyhow. ;)
14:23:09 <Baughn_> navi: Now, if you really want hard realtime, you'll have to implement an incremental garbage collector. Otherwise collection breaks will kill you. (Of course, the same is true for manual management - malloc is *right out* for hard realtime)
14:23:11 <dainanaki> anyone in here want o try their hand at implementing lolcode in haskell?
14:23:54 <Igloo> CosmicRay: The binary package needs the version it was compiled against, so it ought really specify the version
14:24:11 <byorgey> dainanaki: not really =P
14:24:15 <navi> simulation of threads may be a problem for RT apps: you need some ways to ensure your thread is going to get CPU time periodically with high precision/low jitter
14:24:29 <dainanaki> byorgey i got that impression,
14:24:43 <dainanaki> but it would make monads way more fun
14:25:05 <dainanaki> can has x <- input?
14:25:06 <byorgey> dainanaki: I suppose you have a point...
14:25:11 <dainanaki> kthx
14:25:14 <navi> Baughn_, yep, I mentioned "Non-stop Haskell" paper above
14:25:26 <Baughn_> navi: If you're on a single-core system/don't need parallelism, the laziness gives you most of the advantages of threads without actually having threads
14:25:39 <Baughn_> navi: Also much finer control, though
14:26:08 <navi> Baughn_, good point :-)
14:26:19 <byorgey> dainanaki: check out http://groups.google.com/group/fa.haskell/browse_thread/thread/103d5bf02c4a655a/
14:26:21 <lambdabot> Title: data PLZ a - fa.haskell | Google Groups, http://tinyurl.com/26vfsw
14:26:51 <Baughn_> I wonder if lazy evaluation is actually equivalent to having continuations - it seems intuitively right, but I can't quite prove it
14:26:52 <newsham_> Baughn_: ahh, you got rid of the TH import and the code that needed it in ShowQ.hs.
14:27:03 <Baughn_> newsham_: Is that what I did? ^^;
14:27:05 <newsham_> that fixed my issue
14:27:12 <newsham_> (i diff'd)
14:28:17 <pejo> Baughn, how do you mean threads can be replaced by lazy evaluation?
14:28:53 <newsham_> lazy evaluation gives you something sorta like coroutines
14:29:54 <newsham_> think of coroutines/generators in other languages (like python)
14:30:21 <Baughn_> pejo: As he said. Also, since it replaces threads by having you specify the order of evaluation manually (inside the main-loop IO or similar), it gives you far greater control over said order
14:30:58 <Baughn_> Threads can be nicer and need less work, but if you're trying to control the exact timings of thread shifts, you're fighting against the very bits that make them useful
14:31:38 <Baughn_> ..it really is amazing just how much power something this simple buys you
14:32:01 <pejo> Baughn, why wouldn't you let the scheduler control thread shifts? If you're on a single CPU you know EDF is optimal.
14:32:27 <Baughn_> pejo: EDF?
14:32:35 <pejo> Baughn, Earliest Deadline First.
14:32:38 <Baughn_> pejo: As for why not, ask navi
14:32:57 <Baughn_> pejo: Sometimes you'll want to take a performance hit to gain predictability
14:33:17 <navi> pejo: how about priority inversion?
14:35:05 <Baughn_> Sometimes you want a scheduler that's really a scheduler. ISTR the last mars probe spends something like 30% of its cycles making sure no deadlines are /ever/ exceeded.
14:35:14 <navi> EDF is fine when you don't have locks, but they may be a problem if the scheduler is dumb enough (and you risk loosing predictability)
14:35:21 <Baughn_> ..though I doubt you can get that hard realtime with haskell
14:35:28 <pejo> navi, sorry, what is the original context? I was mostly curious about the threads vs lazy evaluation statement.
14:36:17 <navi> pejo, we are trying to figure out if it is at least distantly possible to have hard realtime programs written in Haskell some day
14:37:10 <pejo> navi, oh. Nifty. And tricky. :-)
14:37:32 <Baughn_> I see no fundamental barriers, though you may want to overbudget on CPU power
14:37:42 <dainanaki> one language to rule them all...
14:37:50 <shapr> It's easy to generate hard realtime programs in Haskell, but I don't know if the GHC runtime system will ever be good for that.
14:37:54 <navi> pejo, in lazy evaluation you don't care about the order of the computations (i.e., they are order on by-need basis)
14:38:20 <Baughn_> shapr: Unlike most other languages the binding is /optional/, though. :)
14:38:31 <Baughn_> Er, dainanaki
14:39:02 <byorgey> @hoogle right
14:39:03 <lambdabot> Control.Arrow.right :: ArrowChoice a => a b c -> a (Either d b) (Either d c)
14:39:03 <lambdabot> Prelude.Right :: b -> Either a b
14:39:03 <lambdabot> Distribution.InstalledPackageInfo.copyright :: InstalledPackageInfo -> String
14:39:05 <navi> pejo, using threads implies that you are in IO, which mandates the order and it is probably suboptimal when written manually
14:39:07 <Baughn_> shapr: GHC should at least be useful for /soft/ realtime as soon as someone sticks an incremental GC in there
14:39:20 <shapr> Well, get to it!
14:39:22 * shapr grins
14:39:30 * Baughn_ doesn't need it to. :P
14:39:35 <pejo> navi, are you talking about current implementations now?
14:39:40 <dainanaki> Baughn_?
14:40:00 <Baughn_> dainanaki: The next line of that verse. I'm thinking of >>= now.
14:40:20 <dainanaki> i knew binding would come up
14:40:37 <pejo> Baughn, didn't Marlow write a paper in 2004 about an incremental GC?
14:40:41 <Baughn_> Right, and haskell being about the only language that makes it optional
14:41:09 <Baughn_> pejo: I didn't even know who he was at the time
14:41:31 <navi> pejo, yep, I think so. But my knowledge of the current implementations may be wrong :-)
14:41:55 <navi> pejo, @google Non-stop Haskell
14:42:17 <navi> peko, but it talked about Haskell 4.something, I think
14:43:10 <pejo> navi, "Exploring the Barrier to Entry - Incremental Generational Garbage Collection for Haskell" - talks about GHC 6.2.
14:43:25 <navi> wow, I haven't seen this one
14:44:29 <pejo> Not totally fair to say it's Marlow, a whole bunch of great minds as authors for that article.
14:44:49 <dainanaki> how do i change modes again in emacs?
14:45:06 <navi> hmm, that's strange, it is on the same page as Non-stop Haskell, and I haven't seen it before
14:45:08 <pejo> dain, M-x and type the mode.
14:45:16 <byorgey> liftDark $ mapM unitRing $ find [1..]
14:45:22 <dainanaki> thanks pejo
14:46:03 <Baughn_> byorgey: I reacted to that as if it were a pun. Thank you; my indoctrination is now complete.
14:46:29 <byorgey> Baughn_: hehe =)
14:53:08 <dainanaki> how do i get emacs to indent
14:53:08 <fuzan> tab
14:53:08 <fuzan> you probably don't want to attempt to auto-indent your code, either
14:53:46 <dainanaki> ?
14:53:54 <byorgey> dainanaki: you can also mark a section (Ctrl-space at the beginning and move to the end), then C-c C-.
14:53:57 <dainanaki> when i hit tab it just says in single indent and doesn't do anything
14:54:00 <byorgey> dainanaki: your mileage may vary
14:54:15 <fuzan> dainanaki: probably because there's only one correct level of indention
14:54:37 <dmead> dainanaki, if you visit a new file with a given extension the mode for that filetype should be automatically loaded
14:54:39 <byorgey> dainanaki: you want it to indent some Haskell code, or you just want to indent in general?
14:54:57 <dainanaki> haskell code
14:55:08 <dainanaki> i'm trying to line some stuff up
14:55:13 <byorgey> dainanaki: OK, right, then what I said above
14:55:19 <dainanaki> so it looks like, for example,
14:55:32 <dainanaki> f []     = []
14:55:40 <dainanaki> f (x:xs)   = x
14:55:45 <dainanaki> oops
14:55:50 <byorgey> dainanaki: right, I know what you mean
14:55:54 <dainanaki> well like the equals line up and such
14:56:22 <byorgey> dainanaki: so yes, hit Ctrl-Space at the top of the code you want to indent, move the cursor to the bottom, then type Ctrl-C Ctrl-.
14:56:50 <dainanaki> ok
14:58:06 <byorgey> dainanaki: try typing Ctrl-H b, then scroll down and you can see some of the special keybindings in haskell mode
14:58:11 <dainanaki> doesn't seem to do anything?
14:58:18 <byorgey> dainanaki: are you in haskell mode?
14:58:32 <dainanaki> yes
14:58:47 <byorgey> dainanaki: hm, I don't know, it should work
15:00:18 <dainanaki> eh grr
15:03:00 <sorear> (hello)
15:03:00 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
15:03:12 <sorear> @messages
15:03:13 <lambdabot> sjanssen said 31m 46s ago: I tried your (do grab; select (not structureNotify); unmap; ungrab) idea last night. It lost windows on workspace switch
15:03:41 <dainanaki> that is a cool feature
15:03:50 <dainanaki> @message dainanaki "Testing"
15:03:50 <lambdabot> Maybe you meant: messages messages?
15:03:58 <sorear> @ask dainanaki Testing
15:03:58 <lambdabot> Consider it noted.
15:04:13 <dainanaki> @messages
15:04:13 <lambdabot> sorear asked 16s ago: Testing
15:04:31 <byorgey> dainanaki: you can also @tell
15:04:32 <dainanaki> ha lambdabot continues to impress me
15:04:45 <byorgey> @botsnack
15:04:45 <lambdabot> :)
15:04:51 <dainanaki> that is nifty
15:05:15 <dainanaki> it's like one of those tamagochi things on steroids
15:06:48 <byorgey> @remember dainanaki [lambdabot's] like one of those tamagochi things on steroids
15:06:49 <lambdabot> Done.
15:06:56 <byorgey> =)
15:07:10 <dainanaki> lol
15:07:11 <sorear> @flush
15:08:13 <dainanaki> what does flush do>
15:08:39 <sorear> @help flush
15:08:39 <lambdabot> flush. flush state to disk
15:10:28 <dainanaki> wow i've really been missing out on xcd lately
15:16:53 <sorear> @seen sjanssen
15:16:53 <lambdabot> I saw sjanssen leaving #xmonad and #haskell 16m 51s ago, and .
15:21:46 * SamB wishes for an intact Metroid Fusion rom...
15:22:09 <gwern> hey everyone - in an import statement (such as import Test.QuickCheck...) can one import type classes or just functions?
15:22:59 <augustss> anything the module exports
15:23:07 <JohnMeacham> gwern: to import a type class, use parens after it like import Prelude(Num(..))
15:23:10 <augustss> types, classes, values
15:23:23 <dmwit> Also, instances are implicitly exported.
15:23:25 <savanni> JohnMeacham: is that true of exporting the typeclass, also?
15:23:31 <gwern> JohnMeacham: ah, ok. I was having trouble import Arbitrary
15:23:36 <sorear> hi JohnMeacham.
15:37:37 <JohnMeacham> hello.
15:41:15 <defcons> is function funktion in german?
15:41:27 <defcons> yes
15:42:16 <Lemmih> Um, okay.
15:42:17 <dainanaki> schizophrenic much?
15:42:31 <gwern> defcons: germans are funkier
15:42:36 <gwern> they are often in a funk
15:42:53 <defcons> die funkzeit ist gepwnsteht!
15:43:28 <gwern> 'the function is pwn-ing'?
15:44:55 <sieni> and "funktio" in finnish
15:45:55 <defcons> gwern, yes
15:46:13 <defcons> funkzeit should mean funkdom
15:46:42 <defcons> whoops, zeit means time
15:51:52 <defcons> funkyzeit!
15:51:52 <defcons> I guess noone knows who Bruno is
15:51:52 <dancor> how do i figure out the -l flag i need to compile my SDL-image app (undefined reference errors)
15:51:52 <dancor> oh wait it looks like the libHSSDL-image-0.4.0.a fcns can't find the (non-haskell) sdl ones
15:52:59 <dancor> i do have /usr/lib/libSDL_image.so (gentoo v1.2.5-r1)
15:58:37 <defcon8_> is it possible to find the highest common factor of two numbers with a function with only two arguments?
15:58:43 <defcon8_> and no lets, etc
15:59:25 <Baughn_> defcon8_: It's amazing what you can do, if you're willing to twist the code enough. Almost certainly yes.
16:00:01 <ari> @src gcd
16:00:01 <lambdabot> gcd 0 0 = error "Prelude.gcd: gcd 0 0 is undefined"
16:00:01 <lambdabot> gcd x y = gcd' (abs x) (abs y)
16:00:01 <lambdabot>    where gcd' a 0  =  a
16:00:01 <lambdabot>          gcd' a b  =  gcd' b (a `rem` b)
16:00:01 <Baughn_> It's actually rather hard to restrict the language enough that it's no longer turing-complete
16:00:38 <defcon8_> oh yeah
16:00:43 <defcon8_> I forgot about euclid's method
16:04:30 <dancor> in ghc -v, it looks like there is -lSDL but no -lSDL_image
16:04:42 <dancor> how does ghc decide which -l's to use for gcc
16:04:59 <dancor> also can i squeeze another one in just to get something working
16:05:15 <dancor> export CFLAGS='-lSDL_image'   didn't seem to do it
16:11:53 * dmwit just learned what NP-complete really means.
16:11:56 <dmwit> Neat!
16:12:14 <lispy> the hardest problems in NP?
16:12:30 <dmwit> yeah
16:12:35 <lispy> dancor: hmm...i'd have to check the ghc manual, but it seems like it's possible to pass things to gcc
16:12:37 <dmwit> But I didn't know what NP meant, either.
16:12:52 <dancor> i'm editing the .cabal, i may be on to something
16:12:53 <sorear> -optc-foo
16:13:14 <sorear> but that won't work
16:13:14 <lispy> dancor: ah, sure do it the right way :)
16:13:17 <dancor> beautiful
16:13:20 <dancor> hah
16:13:24 <sorear> -l is NOT a valid option to the c compiler
16:13:40 <Baughn_> lispy: Hardest? Isn't it just a group of problems that are (to a polynomial approximaation) equivalent?
16:13:52 <dancor> threw in Extra-libraries: SDL_image
16:14:18 <dmwit> Baughn_: All other NP problems can be reduced to an NP complete problem.
16:14:20 <lispy> Baughn_: well, it's all the problems which are at least as hard as 3-SAT, right?
16:14:21 <dmwit> So, hardest, yes.
16:14:36 <chessguy> @seen procyon112
16:14:36 <lambdabot> I saw procyon112 leaving #gentoo-haskell, #haskell-blah and #haskell 22h 55m 39s ago, and .
16:15:10 <Mr_Awesome> so, im writing this module, and all of a sudden im realizing that it might be a monad
16:15:56 <dmwit> Cool!
16:16:03 <dmwit> Maybe you can even use one of the ones that's already written.
16:16:14 <Mr_Awesome> perhaps
16:16:29 <Mr_Awesome> im rather ignorant and inexperienced when it comes to monads though, so this could take awhile
16:16:45 <Jaggederest> what module is it? or, rather, what does it do?
16:19:12 <Mr_Awesome> it solves simple algebraic problems using constraints
16:35:46 <dainanaki> could i define an operator that looks like this: ####################################################!######!###########
16:35:52 <dainanaki> because that would be fantastic
16:36:02 <Mr_Awesome> try it
16:38:43 <lispy> > let (####################################################!######!###########) = (+) in 1 ####################################################!######!########### 2
16:38:44 <lambdabot>  3
16:40:25 <ivanm> dainanaki: why do you want such an operator?
16:41:12 <dainanaki> to use frequently with something that has perhaps one less # to inflict pain and confusion on anyone trying to decipher what it does
16:42:03 <ddarius> In other words, he wants to program with it.
16:42:42 <dainanaki> yes
16:42:52 <dainanaki> basically
16:42:57 <ivanm> ddarius: no, really? :p
16:43:03 <dainanaki> one of those things that obfuscates it without much work
16:43:30 <Baughn_> Why do you want to do /that/?
16:43:51 <dainanaki> just to be mean to people that want to read it
16:44:05 <dainanaki> for amusement purposes
16:44:07 <ddarius> It's his way of complying with the GPL without losing his IP.
16:44:25 <Binkley> most editors have a search-and-replace function, you know :-)
16:44:32 <dainanaki> i'm just curious if the compiler gets cranky after a while
16:44:43 <Binkley> GHC is always cheerful
16:44:49 <ddarius> dainanaki: It will when you run out of memory.
16:44:56 <dainanaki> right but thats why i have operators with +/- a few #'s
16:45:07 <Baughn_> Doesn't work. GPL requires you to release source in the preferred form for editing, which in my very nonlawyerish way I read as meaning that writing code in a form you don't personally like using is illegal. ;)
16:45:22 <ddarius> Baughn_: I know.
16:45:37 <Baughn_> ddarius: It's a good argument for letting me use my own indentation style
16:45:54 <geezusfreeek> what if i like coding directly in binary?
16:46:16 <Baughn_> geezusfreeek: Then you can code in binary
16:46:33 <geezusfreeek> yay, i am immune to gpl!
16:46:37 <geezusfreeek> :P
16:46:47 <SamB> geezusfreeek: you must release the same binary you would edit
16:47:01 <dainanaki> yeah just code in hex then
16:47:02 <SamB> not some kind of encrypted version
16:47:12 <dainanaki> or asm
16:47:20 <dainanaki> which most people still don't know
16:47:33 <ddarius> You'd still get patches coding in hex.
16:47:35 <geezusfreeek> what if i like coding directly in encrypted binary?
16:47:44 <Baughn_> dainanaki: If you want to obfuscate your code, the best way is to use haskell
16:48:18 <SamB> maybe dainanaki is wanting to enter the IOHCC?
16:48:25 <geezusfreeek> i'm not really trying to get you guys waste your time to answer silly questions, btw
16:48:25 <dainanaki> lol seems like a true statement
16:48:36 <dainanaki> nope
16:48:58 <glguy-> Is there anything standard in Haskell for parsing something like "2007-06-06T16:21:16Z"
16:49:17 <Baughn_> It's the same reason the usa used code-talkers in ww2. Sure, it's a nice language, but few people know it.
16:49:18 <dainanaki> i suck at haskell, so that might work well enough at helping me obfuscate things anyways
16:49:19 <ddarius> glguy-: Check the time libraries and some of the alternatives out ther.
16:49:20 <SamB> glguy-: what is the T for?
16:49:24 <Baughn_> ..though that advantage seems to be fading now
16:49:25 <geezusfreeek> glguy-: sure, it's jfjnsd6&$Ibf83n)F++-0-3--tg3=- nfnsu*($#N8f93n, but you have to have the right operators defined
16:50:18 <glguy-> SamB: I think that it means that the time portion is starting
16:50:29 <SamB> glguy-: well why didn't they just use a space?
16:50:39 <SamB> its a lot nicer looking that way...
16:51:05 <Baughn_> SamB: So you can parse it with words?
16:51:06 <glguy-> SamB: well, its a third party format... looked somewhat standard, but I'm not datetime expert
16:51:25 <SamB> Baughn_: no. so I can parse it with eyes ;-)
16:51:37 <Baughn_> SamB: Eh. Eyes are for people who don't have computers.
16:51:39 <SamB> also what the heck is the Z for
16:51:46 <Baughn_> Zulu
16:51:49 <geezusfreeek> time zone of some sort?
16:51:53 <ddarius> Yay Zulu!
16:51:53 <geezusfreeek> aha
16:52:12 <SamB> Baughn_: how is the computer going to help when you haven't got any eyes
16:52:24 <ddarius> text2speech
16:52:30 <dainanaki> anyone in here particularly amused by japanese culture?
16:52:46 <ddarius> dainanaki: I am.
16:52:52 <SamB> dainanaki: why do you say "particularly"?
16:52:58 <Baughn_> dainanaki: Amused? Rarely. Distraught, often. Amazed, quite frequntly.
16:53:36 <dainanaki> look at japansugoi.com/wordpress/page 5/
16:53:46 <dainanaki> how to freak out japanese idols on a variety show
16:53:51 <dainanaki> watch that
16:54:28 <lispy> dainanaki: that's not really #haskell appropriate, but it would be fine in #haskell-blah
16:54:46 <dainanaki> oh sorry
16:54:52 <lispy> dainanaki: np :)
16:55:05 <lispy> (you know for next time)
16:55:11 <dainanaki> it seemed like there wasn't any particularly on-topic stuff going on, so i thought i'd throw that in
16:55:55 <Binkley> #haskell-blah should definitely get more traffic :-)
16:56:41 <dainanaki> so bizarre
16:57:19 <Binkley> ?quote
16:57:19 <lambdabot> wilx says: I mean, besides the murders, it all looks so nice.
16:57:20 <SamB> Baughn_: the trouble with Haskell is that there would be haskell-capable individuals available in most regions of the world...
16:57:31 <sorear> ?quote
16:57:31 <lambdabot> bfulgham says: I now have trained-monkey-level skills in Haskell.  I can write really bad shootout code (that the real people rewrite correctly), and build stuff like darcs.
16:57:36 <SamB> so it doesn't make a good code-talk for algorithms
16:57:56 <monochrom> > reverse "ftw"
16:57:58 <lambdabot>  "wtf"
16:58:29 <dainanaki> indeed
16:59:13 <SamB> @quote
16:59:13 <lambdabot> you'll says: probably still want unsafeEquality or whatever, though
17:00:01 <dainanaki> @quote
17:00:02 <lambdabot> droundy says: With a higher-kinded monad and phantom existential witness types, darcs would be very fun... (not that it isn't already...)
17:00:10 <lispy> is there a mapReverse?
17:00:21 <SamB> lispy: what does it do?
17:00:28 <SamB> map reverse, or map . r
17:00:30 <SamB> er.
17:00:34 <dainanaki> couldn't you just make one?
17:00:40 <lispy> mapReverse xs = map f (reverse xs), but maybe there is a more efficient way
17:00:40 <SamB> damn, someone moved my \ key
17:00:42 <ddarius> @free reverse
17:00:44 <lambdabot> $map f . reverse = reverse . $map f
17:00:59 <SamB> map reverse, or \f -> map f . reverse ?
17:01:23 <lispy> ?pl \f xs -> map f (reverse xs)
17:01:23 <lambdabot> (. reverse) . map
17:01:39 <lispy> :t map f . reverse
17:01:41 <lambdabot> Not in scope: `f'
17:01:50 <ddarius> > let mapReverse f = flip ((:) . f) [] in mapReverse (+1) [1..4]
17:01:50 <lambdabot>   add an instance declaration for (Num [t])
17:01:58 <SamB> :t map ?f . reverse
17:02:00 <lambdabot> forall b a. (?f::a -> b) => [a] -> [b]
17:02:25 <ddarius> @. djinn type \f -> map f . reverse
17:02:26 <lambdabot> Cannot parse command
17:02:27 <lambdabot> -- f cannot be realized.
17:02:30 <ddarius> Shite
17:02:46 <ddarius> > let mapReverse f = foldl (flip ((:) . f)) [] in mapReverse (+1) [1..4]
17:02:47 <lambdabot>  [5,4,3,2]
17:02:57 <ddarius> It's a lot more effective with the recursion combinatior
17:03:05 <dmwit> > let reverseWords = unwords . map reverse . words . reverse in reverseWords "hey there guys!" -- or reverseWords = unwords . reverse . words, but that doesn't use map reverse
17:03:06 <lambdabot>  "guys! there hey"
17:03:43 <lispy> ddarius: would that mapReverse be more efficient than the one i gave? (map f (reverse xs))
17:04:01 <moconnor> Is hoogle broken?  A search for getOpt used to return System.Console.GetOpt, and now it returns other stuff (which are all broken links).
17:04:18 <ddarius> lispy: I don't think the foldl in reverse would fuse with the map but it may.  With stream fusion, no it should not be more efficient.
17:04:31 <lispy> ddarius: k, thanks
17:04:55 <lispy> ddarius: k, thanks
17:04:57 <lispy> oops
17:05:00 <lispy> wrong window
17:09:58 <glguy-> ?where parsedate
17:09:58 <lambdabot> I know nothing about parsedate.
17:10:11 <glguy-> ?where+ parsedate http://www.cs.chalmers.se/~bringert/darcs/parsedate/doc/
17:10:11 <lambdabot> Done.
17:10:19 <ddarius> @hoogle Date
17:10:19 <lambdabot> System.Locale.dateFmt :: TimeLocale -> String
17:10:19 <lambdabot> System.Locale.dateTimeFmt :: TimeLocale -> String
17:10:19 <lambdabot> Data.HashTable.update :: HashTable key val -> key -> val -> IO Bool
17:10:30 <Binkley> @hoogle System.Time
17:10:31 <lambdabot> No matches, try a more general search
17:12:44 <lispy> ?src length
17:12:44 <lambdabot> Source not found. Maybe if you used more than just two fingers...
17:13:52 <dainanaki> lol
17:13:57 <lispy> hopefully, length [] = 0; length (a:as) = 1 + lengthFL as, is reasonably efficient
17:14:01 <dainanaki> what?
17:14:09 <ddarius> It is not.
17:14:13 <lispy> er, that FL was a typo
17:14:19 <ddarius> Unless you have a lazy variant of numbers.
17:14:31 <lispy> okay...so what do you recommend using a fold?
17:14:36 <glguy> foldl'
17:14:38 <glguy> at least
17:15:20 <lispy> how could i make it strict without using a fold'?
17:15:25 <ddarius> Incidentally, your definition is foldr (const (1+) 0
17:15:34 <ddarius> lispy: Writing it out.
17:15:37 <lispy> ddarius: that's what's in src?
17:15:44 <ddarius> lispy: No.
17:15:55 <lispy> oh, you mean the one i gave amove
17:15:57 <lispy> er above
17:16:08 <lispy> and because of the foldr we expect it to blow the stack
17:16:25 <ddarius> lispy: Because (+) is usually strict we expect it to blow the stack.
17:16:49 <lispy> why did you mean "Writing it out."?
17:17:06 <ddarius> > foldl' (const id (1+)) 0 $ replicate 10 3
17:17:06 <lambdabot>      Occurs check: cannot construct the infinite type: a = b -> a
17:17:06 <lambdabot>     Probabl...
17:17:28 <ddarius> > foldl' (\a _ -> a+1) 0 $ replicate 10 3
17:17:29 <lambdabot>  10
17:17:38 <ddarius> @pl \a _ -> a + 1
17:17:38 <lambdabot> const . (1 +)
17:17:42 <ddarius> slick
17:17:44 <lispy> i see what you mean now
17:17:56 <ddarius> > foldl' (const . (1+)) 0 $ replicate 10 3
17:17:57 <lambdabot>  10
17:18:07 <ddarius> > foldl' (const . (1+)) 0 $ replicate 1000000 3
17:18:08 <lambdabot>  1000000
17:18:15 <lispy> i don't want to define foldl and foldr on my list type (for a time consuming reason to explain)
17:18:16 <ddarius> > foldr (const (1+)) 0 $ replicate 1000000 3
17:18:17 <lambdabot>  1000000
17:18:22 <ddarius> > foldr (const (1+)) 0 $ replicate 100000000 3
17:18:23 <lambdabot>  Exception: stack overflow
17:18:26 <lispy> but, looking at the source of fold' i think i might see how to get the strictness in there
17:18:31 <ddarius> > foldl' (const . (1+)) 0 $ replicate 100000000 3
17:18:37 <lambdabot> Terminated
17:18:46 <ddarius> Bugger
17:19:03 <ddarius> Hmm
17:19:16 <ddarius> > foldl' (const . (1+)) 0 $ take 100000000 $ repeat 3
17:19:22 <lambdabot> Terminated
17:20:14 <lispy> i think i need to use an accumlator argument
17:20:28 <ddarius> That's what foldl(') does.
17:20:39 <lispy> yeah, that's where i got the idea from in this case :)
17:20:45 <ddarius> @src foldl
17:20:45 <lambdabot> foldl f z xs = lgo z xs
17:20:45 <lambdabot>     where lgo z []     =  z
17:20:45 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
17:22:08 <lispy> ?where hpaste
17:22:08 <lambdabot> !paste
17:22:09 <hpaste> Haskell paste bin: http://hpaste.org/
17:22:39 * ddarius smiles at the cuteness.
17:22:50 <hpaste>  lispy pasted "my length function" at http://hpaste.org/201
17:23:05 <lispy> that's what i endedup with
17:23:37 <lispy> heh, doesn't compile though :)
17:24:08 <ddarius> You need an 'in'
17:24:11 <lispy> i'm missing "in n'"
17:24:12 <lispy> yeah
17:24:19 <Jaggederest> infinite lists may be the coolest thing ever.
17:24:30 <ddarius> But just do length' as $! n+1
17:24:51 <ddarius> Jaggerest: Nope.
17:25:06 <lispy> ddarius: you're sure that's equivalent?
17:25:28 <Jaggederest> no? :( not even a little cool?
17:25:28 <ddarius> @src ($!)
17:25:28 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
17:25:42 <ddarius> Jaggderest: They are a little cool.
17:25:59 <ddarius> lispy: From what I assume you meant the code to be, yes.
17:26:20 <lispy> ddarius: okay, well i think you understand what i want...
17:26:23 <lispy> so, i'll try that
17:26:24 <ddarius> Alternatively, you could enable bang patterns
17:27:24 <ddarius> Hmm, wow.  Strictness analysis can -almost- but not quite prove that length' is strict in n.  Exercise: Why isn't it?
17:27:53 <ddarius> Assuming we know (+) is strict.
17:28:22 <sorear> ddarius: it *is* strict in n
17:28:44 <ddarius> sorear: Excluding the strictness annotations, it is not.
17:28:55 <sorear> and strictness analysis can prove it.
17:29:24 <ddarius> Actually, I guess it's okay, since one _|_ equals another.
17:30:10 <lispy> so, why doesn't the ghc's prelude use $! in the definition of length?
17:30:44 <ddarius> What is the definition given?
17:31:07 <lispy> oh sorry, i'm thinking of foldl'
17:31:11 <lispy> ?src foldl'
17:31:11 <lambdabot> foldl' f a []     = a
17:31:11 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
17:31:14 <lispy> but same question
17:31:30 <dibblego> isn't seq defined in terms of $!?
17:31:34 <dibblego> ?src seq
17:31:34 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
17:31:39 <ddarius> $! is defined in terms of seq
17:31:41 <lispy> ?src ($!)
17:31:42 <lambdabot> Source not found. stty: unknown mode: doofus
17:31:42 <dibblego> yeah that
17:31:48 <ddarius> f $! x = x `seq` f x
17:32:14 <dibblego> lambdabot has lost the source
17:32:18 <int-e> pure speculation - maybe at some point, the compiler wasn't smart enough to inline $!?
17:32:28 <ddarius> lispy: Possibly because it's a bit more awkward in that case though still cleaner than that, but probably just because or for some crazy reason.
17:32:37 <dibblego> maybe $! simply didn't exist at that time and only seq did
17:32:50 <lispy> i see
17:32:51 <sorear> or maybe $! still doesn't exist at the time
17:32:57 <lispy> so i should stop worrying about it :)
17:32:57 <sorear> recursive modules are hard
17:34:21 <dons> moin
17:34:31 <dons> @seen dcoutts
17:34:31 <lambdabot> dcoutts is in #haskell-overflow, #haskell, #ghc and #gentoo-haskell. I last heard dcoutts speak 1d 18h 54m 14s ago.
17:34:33 <sorear> hiya
17:34:42 <dibblego> hola
17:36:57 <dons> ?users
17:36:57 <lambdabot> Maximum users seen in #haskell: 336, currently: 288 (85.7%), active: 49 (17.0%)
17:37:03 <dons> http://programming.reddit.com/info/1whvb/comments
17:37:04 <lambdabot> Title: Number Theory and Haskell: Greatest Common Divisor (reddit.com)
17:37:24 <ddarius> dons: More cdsmith stuff?
17:37:34 <dons> yup
17:38:16 <SamB> huh, I see dmwit on bash.org
17:38:21 <cdsmith> Whoa, I'm on reddit?
17:38:28 * SamB wonders if it is the same dmwit
17:39:16 <ddarius> Crap.  There is some series of blog posts or something that I am interested in seeing the continuation of.
17:39:22 <ddarius> But I can't remember what it was.
17:39:50 <dons> cdsmith: you've got a feed on planet.haskell.org?
17:39:59 <cdsmith> dons: yes
17:39:59 <dons> yes
17:42:01 <gravity> heh, pretty much everything on planet haskell seems to hit reddit
17:44:36 * ddarius eyes dons
17:47:06 <Binkley> ?yow
17:47:06 <lambdabot> Were these parsnips CORRECTLY MARINATED in TACO SAUCE?
17:47:32 <brainly-green> in terms of a typed lambda calculus, what is a "term"?  is it the same as an expression?
17:47:55 <Binkley> brainly-green: yes
17:47:59 <vagif> Hello all. Where do i find manuals or tutorials on following subjects: IORef, MVar, State
17:48:06 <brainly-green> ok thanks
17:48:38 <vagif> haskell wiki has empty page for these subjects: http://en.wikibooks.org/wiki/Haskell/State
17:48:55 <ddarius> Does Malcolm Wallace look like Jesus in real life?
17:49:07 <Binkley> ddarius: no
17:51:29 <Binkley> well
17:51:34 <Binkley> I don't know what Jesus looked like in real life.
17:53:57 <dmwit> Speak for yourself.
17:54:13 <Binkley> gifz plz
17:54:23 <dmwit> my drawng sux =(
17:54:32 <Binkley> :.-(
17:59:00 <Binkley> ?quote
17:59:00 <lambdabot> kc5tja says: Premature evil is the root of all optimization.
17:59:00 <brainly-green> so what exactly is a type environment?
17:59:12 <Binkley> brainly-green: a mapping from names to types
17:59:14 <Binkley> to put it simply
18:01:07 <ddarius> ozone always makes such nice webpages.
18:02:29 <shapr> @seen stepcut
18:02:30 <lambdabot> I saw stepcut leaving #xmonad, #haskell-blah and #haskell 1d 6h 58m 15s ago, and .
18:02:32 <shapr> @seen adept
18:02:33 <lambdabot> I saw adept leaving #haskell-soc 1d 11h 10m 24s ago, and .
18:02:35 <shapr> foo
18:03:01 <shapr> Has anyone used stepcut's Network.Protocol.XMPP or ADEpt's Network.XMPP?
18:03:24 <shapr> hiya flippo
18:03:36 <flippo> shapr, My my.  You're still here.
18:03:38 <sorear> shapr: i've tried to hack both... *shudder*
18:03:43 <shapr> flippo: Surprised?
18:03:48 <flippo> shapr, I shouldn't be.  %]
18:03:50 <shapr> sorear: Comments/thoughts?
18:04:04 <sorear> what, is flippo Philippa's evil twin?
18:04:05 <sorear> :P
18:04:38 <shapr> sorear: I just had the urge to try to hack in HAppS.Protocols.Jabber, but I wasn't sure if either lib is ready for that.
18:04:38 <flippo> sorear, Not to my knowledge.
18:04:41 <sorear> shapr: it was made unnecessarily difficult by the use of SAX-mode.  if I were rewriting it I'd use Lazy
18:05:06 <flippo> This channel has certainly grown.
18:05:12 <shapr> @users
18:05:12 <lambdabot> Maximum users seen in #haskell: 336, currently: 285 (84.8%), active: 49 (17.2%)
18:05:27 <shapr> flippo: http://www.cse.unsw.edu.au/~dons/irc/
18:05:27 <lambdabot> Title: Haskell IRC Activity
18:05:29 <sorear> shapr: I gave up months ago after not finding any reasonable way to keep a persistant connection :(
18:05:46 <sorear> @where stats :)
18:05:46 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
18:05:59 <ddarius> sorear: That's your problem right there, looking at reasonable solutions.
18:06:24 <flippo> shapr, is the credit all yours, or do you think there might be external factors at work?
18:06:57 <shapr> flippo: The credit isn't any one person's
18:07:24 <flippo> shapr, I'm wondering if haskell is suddenly taking off in some domain.
18:07:28 <sorear> flippo: Ashley should probably get a lot of it
18:07:28 <shapr> I think the credit goes to all the smart people who hang out here and politely answer questions.
18:07:40 <Binkley> yay warm fuzzies!
18:07:48 <Pseudonym> Binkley: You mean "monads"?
18:07:58 <Binkley> heh
18:08:48 <sorear> First ddarius, now flippo.  Is it just luck that so many haskellers of eld are returning now?
18:08:56 <Binkley> "haskellers of eld"?
18:09:24 <flippo> I miss the promise of a better programming language.  I had to come back and gaze enviously.
18:09:43 <sorear> hmm.  my dramatic language filter must have clogged again.
18:09:48 <flippo> heh
18:09:53 <shapr> flippo: A lot of pro-Haskell things have happened in the last few years: Perl6, darcs, ghc-smp, lambdabot, NDP
18:10:17 <dons> xmonad!
18:10:21 <sorear> HCAR
18:10:23 <shapr> dons!
18:10:31 <dons> shapr!
18:10:33 <shapr> heh
18:10:36 <Pseudonym> Group hug!
18:10:37 <ddarius> HC&AR has been going on for a while.
18:10:43 <dons> woot!
18:10:44 * sorear deflates
18:11:06 <shapr> The Haskell job market has expanded dramatically as well.
18:11:45 <dons> yeah
18:11:58 <Binkley> yeah, not too long ago the phrase "Haskell job market" would have provoked laughter
18:12:01 <Binkley> and possibly tears
18:12:06 <flippo> shapr, I googled everything on your list.  Looks very exciting.
18:12:38 <flippo> shapr, but why is perl6 on that list?
18:12:42 <ddarius> pugs
18:12:49 <ddarius> @where pugs
18:12:49 <lambdabot> http://www.pugscode.org/
18:12:49 <Pseudonym> "ML for the working programmer" still gives me a bit of a chuckle.
18:12:54 <shapr> @go tang pugs haskell perl
18:12:56 <lambdabot> http://www.perl.com/pub/a/2005/03/03/pugs_interview.html
18:12:56 <lambdabot> Title: perl.com: A Plan for Pugs
18:13:00 <dons> Pseudonym: :-)
18:13:05 <gravity> perl6 seems like it would still be total vapor without haskell
18:13:05 <ddarius> "Category Theory for the Working Mathematician"
18:13:54 <sproingie> perl6 still hasn't really made it to the solid phase yet
18:14:02 <Binkley> what is it, plasma?
18:14:09 <shapr> It's moving so fast.. it must be!
18:14:11 <sproingie> colloid perhaps
18:14:13 <ddarius> hot air, interesting.
18:14:29 <shapr> Still, some people are using pugs for commercial development.
18:14:41 <sproingie> larry wall needs to drop a final apocalypse that says: I take over again.  Ship it now.
18:14:55 <Excedrin> perl6 is a hallucination... I'd even go so far as to say that it's a bad trip.. man
18:15:21 <flippo> That's about the oddest thing I've ever read about perl.
18:15:41 <shapr> I like it. Perl6 and the latest version of Visual Basic both borrow neat ideas directly from Haskell.
18:16:07 <sorear> @quote imitation
18:16:07 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
18:16:08 <ddarius> Many mainstream languages are doing that nowadays.
18:16:19 <sorear> We need @proverb
18:16:36 <ddarius> sorear: Get some Haskell newbie to hack it into lambdabot
18:16:37 <shapr> Adam Turoff has a blog post about how Smalltalk is the pure distilled form of any OOP you find in Java, Python, C++, etc. He also says that Haskell is the pure distilled form of FP that's infecting everything now.
18:16:53 <sproingie> i like perl, i do a lot of it at work, but the typographic noise in perl6 just finally pushed me away
18:17:03 <lispy> shapr: what did VB borrow from Haskell?
18:17:10 <flippo> How come we never get to use the pure distilled version, then?
18:17:26 <lispy> flippo: too strong, you need to add creamer :)
18:17:31 <Pseudonym> Woo, nice.
18:17:34 <ddarius> lispy: The whole family of .NET languages borrow stuff from Haskell.
18:17:40 <sproingie> unlambda is pure distilled fp
18:17:45 <dons> nah. its impure
18:17:49 <Excedrin> wow, perl5 didn't have enough typographic noise? (also, I code more stuff in perl than any other language, I have a very love/hate relationship with it)
18:17:58 <dons> its the lisp of mini-fp languages.
18:18:05 <sproingie> Excedrin: perl6 makes perl5 look like python
18:18:14 <ddarius> Heck, C++ is borrowing stuff from Haskell.
18:18:16 <dons> Lazy-K , iirc, is the true pure distilled fp :-)
18:18:22 <sproingie> well some things are less noisy.  dot instead of -> is nice
18:18:35 <sproingie> it more than makes up for it in the end tho
18:19:01 <lispy> ddarius: other than generics (arguably they stole it from Java) i'm not sure what you and/or shapr are thinking of...just curious
18:19:05 <dons> sproingie: http://homepages.cwi.nl/~tromp/cl/lazy-k.html :-)
18:19:07 <lambdabot> Title: The Lazy K Programming Language
18:19:11 <dons> ?where+ lazy-k http://homepages.cwi.nl/~tromp/cl/lazy-k.html
18:19:11 <lambdabot> Done.
18:19:19 <sorear> lispy: List comprehensions
18:19:27 <lispy> VB has list comps?
18:19:34 <sorear> VFred
18:19:36 <ddarius> lispy: Well you could argue many stuff in the STL and certainly several boost libraries, but more directly, Concepts.
18:19:47 <ddarius> @where linq
18:19:47 <lambdabot> I know nothing about linq.
18:19:54 <dibblego> Java stole parametric polymorphism from Haskell - they just fugged it (as usual for a JSR team)
18:20:18 <lispy> dibblego: yeah, wadler helped invent java generics
18:20:35 <sorear> didn't java steal it from C++?
18:20:48 <dibblego> I've seen what happens when smart people interact with a JSR team
18:20:54 <dons> hah
18:20:57 <ddarius> C++ doesn't have parametric polymorphism.
18:20:58 <sorear> C++ reeks of Jean-Yves Girard's System F
18:21:14 <sorear> dons: Sure it does.  Templates!
18:21:38 <ihope> Hello, Haskell people!
18:21:44 <sorear> Hello ihope!
18:22:06 <lispy> ddarius: how do C++ templates different from parametric polymorphism...i've thought about this before and i faild to find a difference
18:22:08 <ihope> It's the person I can't resist conjugating!
18:22:15 <ddarius> sorear: Templates are some crazy substitution system that kinda sorta includes parametric polymorphism.
18:22:52 <ihope> SorearÃ©! SorearÃ¡s! SorearÃ¡! Sorearemos! SorearÃ©is! SorearÃ¡n! :-) But enough of that. Regarding this: http://en.wikibooks.org/wiki/Haskell/Zippers
18:22:53 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
18:22:58 <Pseudonym> The main thing about C++ templates is that the substitution isn't as clean.
18:23:06 <ddarius> lispy: What is the type of template<typename T> T f(T x) { return x+i; }
18:23:08 <Pseudonym> OTOH, it is more flexible as a result.
18:23:15 <lispy> ddarius: so, with templates you can define garbage that isn't found wrong until it's instantiated, is that the only difference?
18:23:20 <ddarius> Pseudonym: It's Turing-complete.  That's pretty flexible.
18:23:36 <lispy> ddarius: what is i?
18:23:40 <Pseudonym> So is the H98 typeclass system.
18:23:54 <ddarius> lispy: No, it's not wrong.  The types don't reflect the "actual" type.
18:23:59 <ddarius> I meant 1 for i.
18:24:02 <int-e> Pseudonym: without extensions?
18:24:11 <Pseudonym> I believe so.
18:24:20 <Pseudonym> You can implement a Turing machine using them.
18:24:22 <_frederik_> hello, sorry, what does this mean: "Cannot match a monotype with `(forall q[a4hB]..."?
18:24:23 <sorear> ddarius: /\T : * . Num T => T -> T
18:24:43 <ddarius> lispy: I can't trust the parametricity properties that the types seem to imply in Haskell.
18:24:53 <lispy> ddarius: well, anything that supports operator+(T,Num a), for a suitable Num a in terms of C++ should work there, no?
18:24:57 <ddarius> sorear: When C++ formalizes Concepts then you'll be good to ge.
18:25:01 <ddarius> s/ge/go
18:25:04 <sorear> _frederik_: Either you messed up a type signature, or you misused ST, or you found a compiler bug.
18:25:20 <_frederik_> "messed up a type signature"?
18:25:20 <ddarius> lispy: Yes, but it's not in the type and that is not parametric polymorphism.
18:25:42 <ddarius> Pseudonym: You need -fallow-undecidable-instances
18:25:52 <ihope> That seems to essentially give the derivative in A of "A + A * Node A + A * Node A * Node A" (under "differentiation of data types", below the exercises and code box) as "A + 2 * A * Node A". Just how does that work?
18:25:52 <Pseudonym> But what I was thinking of by "more flexible" is, for example, that "+" can mean different things depending on the template instance.
18:25:56 <_frederik_> sorear: thanks, i have almost the exact same function in another place, and it works, i am having trouble seeing what is different
18:26:04 <Pseudonym> It could be a built-in +, or an overloaded operator+, for example.
18:26:08 <lispy> ddarius: it may not be in the time, C++'s syntax doesn't really allow you to encode it in the type...but what property of parametric polymorphism is violated?
18:26:09 <ddarius> Pseudonym: I agree.
18:26:18 <ddarius> lispy: Parametricity
18:26:29 <Pseudonym> ddarius: Right.
18:26:35 <lispy> ddarius: but you can instantiate with different values of T
18:27:10 <ddarius> Parametricity is what says that (in a pure language) forall a. a -> a must be the identity function.
18:27:26 <ddarius> Parametricity is where the free theorems come from.
18:27:30 <byorgey> ihope: it's parallel to the fact that the derivative of a + ax + ax^2 is a + 2ax.
18:27:50 <ihope> ...Oh, that's the derivative in x, isn't it?
18:28:01 <ihope> I thought it'd be the derivative in a.
18:28:03 <byorgey> ihope: yes.
18:28:14 <ihope> The derivative in x does make more sense, really.
18:28:20 <ihope> Thanks!
18:28:23 <lispy> ddarius: can you explain that a bit more? i don't think i follow
18:28:24 <byorgey> ihope: it's the derivative with respect to the functor in question.
18:28:35 * ihope goes back to hacking data declarations
18:28:36 <byorgey> ihope: sure!
18:29:29 <ddarius> I cannot view a "function" template<typename T> T f(T x); as being the same as forall T. f :: T -> T.
18:30:58 <ddarius> It's not a single program parametric in the type, it's a collection of programs indexed over all types that it would typecheck with.
18:31:19 <lispy> okay, i finally see why forall a. a -> a, is id
18:31:25 <lispy> because you can't use any properties of a
18:31:33 <lispy> otherwise you'd have a less general type signature
18:31:53 <int-e> ddarius: it's more like class T a where f :: a -> a ... but not quite the same.
18:32:09 <lispy> i would disagree that your C++ code has the type signature forall T. f :: T -> T.
18:32:16 <ddarius> It doesn't.
18:32:44 <ddarius> But that's what it looks like it does if we equate templates with parametric polymorphism.
18:32:49 <int-e> ddarius: but with the implementation attached it's also an instance, which is rather hard to express in Haskell (because really all that's required is that T implements +)
18:33:49 <lispy> yeah, i want to say the type requires some structural subtyping or something
18:34:26 <lispy> interesting discussion
18:35:04 <ddarius> Something like Haskell's typeclasses would at least partially solve the problem rather well, and that's exactly the direction the C++ committee is heading.
18:35:09 <lispy> i never really thought about the how parametric polymorphism means that forall a. a -> a, must be id (ignoring _|_)
18:35:22 <shapr> lispy: I had a phone call, but Erik Meijer and other long-time Haskellers have been working on the next version of VB for MS
18:35:40 <shapr> @go haskell "visual basic"
18:35:43 <lambdabot> http://blogs.msdn.com/sriram/archive/2006/04/11/573731.aspx
18:35:43 <lambdabot> Title: Sriram Krishnan : A Haskell programmer becomes a fan of...Visual Basic
18:35:49 <Korollary> lies
18:35:52 <Pseudonym> Would you call Erik Meijer a Haskeller?
18:35:59 <Pseudonym> Haskell-friendly, certainly.
18:36:01 <lispy> shapr: i knew that actually...i know some Haskell studying PhDs that went to work at MSR recently...i just hoped for concrete examples :)
18:36:21 <shapr> Pseudonym: Yeah, but I get called a Haskeller, and I think I'm just Haskell-friendly, so I dunno.
18:36:32 <ddarius> He was close enough to a Haskeller back in the day.
18:36:34 <Pseudonym> You write Haskell.
18:36:51 <Pseudonym> I'm not sure that I've ever seen any Haskell code from Erik.
18:37:03 <Korollary> Eric Meijer suddenly started to endorse VB's optional static types after joining MS.
18:37:23 <Binkley> that's because MS puts stuff in their coffee
18:37:28 <Pseudonym> Oh, man, MS has claimed another one.
18:37:50 <Pseudonym> They did that to one of the Mercury guys, too.
18:38:12 <shapr> sorear: Which of the XMPP libs was more complete? stepcut's or ADEpt's?
18:38:30 <Korollary> That pdf was posted to LtU a year ago
18:38:51 <wchogg> When I've read stuff that Meijer has written, I sort of got the feeling that his goal was to include advanced type machinery into the mainstream as succesfully as possible, even when that mean theoretic compromises:  hence his work on VB.
18:39:41 <Nafai> wchogg: I'd agree
18:39:55 <chessguy> anybody read this book? http://www.pragmaticprogrammer.com/ppbook/index.shtml
18:39:56 <lambdabot> Title: The Pragmatic Programmer: From Journeyman to Master
18:40:08 <shapr> chessguy: Yeah, buy it now.
18:40:14 <chessguy> it has an awful lot of "oh, that's why haskell is so good" moments in it
18:40:27 <wchogg> chessguy:  How so?
18:40:31 <chessguy> even though it never mentions it :)
18:41:02 <chessguy> wchogg, because haskell embodies a lot of the principles the book tries to get across
18:41:05 <shapr> wchogg: Many of the 'points' are clearly seen in Haskell.
18:41:23 <Nafai> chessguy: Yeah, it's one of my favorites
18:41:26 <gravity> Is it worth reading the book then, if you know haskell?
18:41:36 <shapr> "Don't Repeat Yourself" "Domain Language"
18:41:41 <shapr> gravity: Yeah, I think so.
18:41:54 <Nafai> gravity: It's got a lot of good general advice that I imagine Haskell makes it nice to implement :)
18:41:57 <gravity> I loved their ruby book, so maybe I'll check it out
18:41:59 <chessguy> easy testing, decoupling, source code control, ...
18:42:32 <shapr> After that book was published they put more useful points on their wiki.
18:42:52 <chessguy> oh? link?
18:45:23 <dons> may as well post the lot, http://programming.reddit.com/info/1wi9a/comments
18:45:24 <lambdabot> Title: More Number Theory and Haskell: QuickCheck and Divisors (reddit.com)
18:45:50 <shapr> chessguy: Looks like it's gone. Seems the really outstanding wiki pages were turned into "articles."
18:46:13 <shapr> dons: Is there a NDP that takes advantage of ghc-smp?
18:46:20 <ddarius> dons: Have you considered having a bot do this for you?
18:46:24 <dons> yeah, NDP does.
18:46:41 <dons> ddarius: hmm. i have a bot -- google -- do the searching.
18:46:46 <dons> but not a submit / irc bot
18:47:02 <emu> linuxer has that bot
18:47:05 <dons> ddarius: i suspect 'linuxer' is a bot.
18:47:07 <dons> yeah
18:47:27 <dons> pretty sure he just submits all google blog hits for a set of keywords
18:47:45 <dons> at the same time everyday. might even be a cronjob
18:48:10 <emu> no captcha?
18:48:32 <dons> nope
18:48:52 <Nafai> dons: Hrm.  That sounds highly likely since I never see any comments...
18:48:56 <Korollary> You can work around captchas with mechanical turk anyways heh
18:51:27 <shapr> dons: Was it you who had some way to mix QC and HUnit?
18:51:27 <ddarius> shapr: Didn't you do that?
18:51:27 <shapr> I was trying to subsume HUnit by including static values, but HUnit handles IO so nicely I'd rather do it the other way around now.
18:51:27 <dons> shapr: stefan did that, HTF its called
18:51:27 <shapr> Ah, thanks.
18:52:06 <Nafai> Hi glguy
18:53:02 <dons> hey glguy
18:55:45 <Binkley> ?quote
18:55:45 <lambdabot> adaptec says: [in documentation for their raid chipsets] We have a disclaimer because there may be corner cases
18:56:12 <lispy> > 1 : 2 : 3
18:56:13 <lambdabot>   add an instance declaration for (Num [t])
18:56:18 <lispy> > 1 : 2 : 3 : []
18:56:19 <lambdabot>  [1,2,3]
18:56:32 <lispy> does that mean that (:) is infixr ?
18:56:37 <ddarius> Yes
18:56:42 <ddarius> Hence foldr
18:57:03 <lispy> do fixity declarations work with gadts?
18:57:14 <ddarius> Presumably.
18:57:25 <lispy> thanks
18:57:58 <lispy> ah hah, infixr 5  :
18:58:06 <lispy> i think that's what i need to mimic
18:58:52 <lispy> yup, did the trick
18:59:29 <ddarius> Evince, now with 50% more random display glitches.
19:00:12 <Binkley> at least it's better than xpdf
19:00:15 <ddarius> I should really write my own PDF viewer.
19:00:42 <lispy> dons: i think ddarius just named the next challenge for the haskell community...a real and usable pdf viewer
19:00:55 <ddarius> Binkley: It's rather nice.  It does what I want, or would if it didn't have glitches.  Luckily, they are not that big an issue.
19:00:57 <dons> hmm. that's not a bad idea.
19:01:09 <shapr> It'd be hard to suck worse than acroread.
19:01:13 <lispy> dons: yes, and i think the pieces are there...cairo would probably be handy
19:01:13 <dons> yeah
19:01:18 <chessguy> dons, it should be built into xmonad :)
19:01:19 <ddarius> lispy: It's easy and fun.  You just write a postscript interpreter which Haskellers should enjoy.
19:01:21 <dons> lispy: and i know how to write a basic ps viewer
19:01:43 <shapr> And Haskell is so good at writing interpreters!
19:01:53 <dons> that'd be cool actually, since haskellers read a lot of papers
19:01:54 <lispy> so it's setteled
19:01:55 <Binkley> well, Haskell doesn't write its own interpreters :-)
19:02:00 <dons> so people might actually use it
19:02:11 <lispy> dons: i'd use it assuming it works cross platform
19:02:19 <lispy> i guess that's the hardest part
19:02:23 <Korollary> Acroread 8.1 now has a "send to fedex kinko" button on the toolbar.
19:02:32 <Korollary> beat that
19:02:44 <dons> that'd be hard to beat
19:02:48 * emu beats fedex kinko with a large stick
19:02:54 <shapr> Korollary: I've heard it also submits user information if you have JavaScript turned on.
19:02:59 <lispy> i also love the tool bar thing in acroread that changes color every few seconds so that i endup looking at it...sheesh
19:03:01 <dons> shapr: yeah
19:03:19 <Korollary> lispy: that's gone
19:03:21 <shapr> lispy: Yeah, what a way to break your focus.
19:03:22 <byorgey> lispy: seriously, that's pretty annoying
19:04:36 <lispy> yeah, you know software is broken when people use postit notes to cover annoying parts of the screen while using the software
19:04:39 <chessguy> shapr, ah, i found it: http://wiki.pragprog.com/cgi-bin/wiki.cgi/MorePragmaticTips
19:04:40 <lambdabot> Title: Pragmatic Wiki: MorePragmaticTips
19:04:43 <shapr> chessguy: Spiffy
19:04:54 <chessguy> i assume that's it, anyway
19:05:18 <shapr> chessguy: Yeah, that's it.
19:05:18 <Korollary> Stop reading pdfs like people after knowledge.
19:05:26 <Korollary> You should be watching youtube
19:05:31 <Korollary> and clicking on ads
19:05:40 <emu> pdftube
19:05:48 <Binkley> I'll just watch videos on YouTube of other people reading PDFs
19:05:52 <Korollary> also don't watch Phil Wadler videos
19:05:56 <lispy> oh, that's what we can call the haskell pdf viewer, pdftube
19:05:58 <shapr> Hey, I played WoW for a coupla months, I've had my drool on the keyboard quota for this whole YEAR!
19:06:02 <Excedrin> pfftube
19:06:10 <Binkley> Korollary: why not?
19:06:19 <Korollary> Binkley: Too informative
19:06:23 <Binkley> heh
19:06:44 <lispy> yeah, actually that wadler video is hard to watch...he slings around theory jargon like it's nothing
19:06:45 <Binkley> I was thinking it was because you might see him topless as a result
19:07:00 <Korollary> lispy: It's offensive eh
19:07:07 <Korollary> Wadler: NSFW
19:07:26 <Binkley> to be fair, I've only been to three Wadler talks where he took off clothes
19:07:30 <shapr> Korollary: only when he takes his shirt off
19:09:23 <Binkley> ?yow
19:09:23 <lambdabot> ANN JILLIAN'S HAIR makes LONI ANDERSON'S HAIR look like RICARDO
19:09:23 <lambdabot> MONTALBAN'S HAIR!
19:09:50 <Korollary> How old are these quotes? Can we have some American Idol references?
19:10:25 <Jaggederest> something this century would be nice at least.
19:11:13 <dons> well. find a quotes file please.
19:12:04 <Jaggederest> problem with doing TSP in haskell: too efficient :( depending on my step size, the first iteration finds the answer. I have to artificially clamp it.
19:12:54 <Jaggederest> need a bigger problem set I think. 10 -> 100
19:17:29 <byorgey> is there a canonical way to define a sort of quickcheck "testsuite" that automatically checks a list of properties?
19:17:45 <ddarius> byorgey: Yes.
19:19:12 <byorgey> ddarius: what is it?  do you know of a link to a page that describes it?
19:20:46 <ddarius> http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
19:20:57 <lispy> canonical way?  well i created a hack using template haskell
19:21:16 <byorgey> ddarius: thanks!
19:21:50 <lispy> as part of the build process i used Language.Haskell to read in Tests.hs and some template haskell to generatea module that would run all the function that start with prop_ as a quick check property
19:22:34 * bos has nifty pty support added to System.Posix
19:22:46 <byorgey> lispy: nice.
19:22:56 <bos> (fd, pid) <- executePseudoTerminal "/bin/sh" False [] Nothing
19:23:12 <bos> h <- fdToHandle fd
19:23:19 <bos> hPutStrLn h "ls"
19:23:24 <dons> yeah, maybe provide a wrapped Handle version?
19:23:39 <dons> fdToHandle is a bit evil :-)
19:23:43 <bos> heh.
19:24:58 <lispy> byorgey: i detailed it on my blog if you want to try it out: http://blog.codersbase.com/2006/09/01/simple-unit-testing-in-haskell/
19:25:01 <lambdabot> Title: dagit.o » Blog Archive » Simple Unit Testing in Haskell, http://tinyurl.com/h6k97
19:25:34 <byorgey> lispy: thanks, I'll take a look
19:25:56 <byorgey> lispy: is your blog on Planet Haskell?
19:26:56 <ddarius> it is
19:27:42 <byorgey> ok, just making sure I didn't need to add it to my feed reader =)
19:28:02 <lispy> byorgey: it's on planet haskell but i rarely post
19:28:13 <lispy> and my most recent post was not haskell related :)
19:29:28 <sorear> re.
19:29:46 <sorear> shapr: don't recall.
19:29:58 <shapr> too bad
19:30:46 <byorgey> lispy: a marathon! congratulations.
19:31:29 <lispy> byorgey: thanks
19:32:07 <Pseudonym> Does anyone know of any good algorithms for finding roots of polynomials symbolically?
19:32:27 <Pseudonym> I'm leaning towards the "obvious" Galois theorem one, but it seems excessive.
19:33:09 <lispy> Pseudonym: doesn't that give up around the quintic?
19:33:16 <Pseudonym> No, it doesn't.
19:33:24 <Pseudonym> It doesn't work for all quintics.
19:33:33 <Pseudonym> But it works for the ones that it works for.
19:33:37 <Pseudonym> If you know what I mean.
19:33:41 <lispy> yes i do
19:33:56 <lispy> solver :: Polynomial -> Maybe [Root]
19:34:02 <lispy> somemthing like that?
19:34:18 <Pseudonym> Yeah.
19:34:29 <Pseudonym> If it helps, the polynomial is already squarefree.
19:34:33 <Pseudonym> That bit is easy.
19:34:48 <Pseudonym> So multiple roots are not a problem.
19:35:10 <lispy> i remember next to nothing about factoring polynomials
19:35:40 * Pseudonym nods
19:36:12 <lispy> in fact, i find darcs code to be really hard to grok :)
19:36:22 <sorear> I remember next to nothing about the mechanics of the galois theorem.  And I read a book about it *this year*.  Sad.
19:36:32 <lispy> (not that it's polynomials, but i feel intimidated lately by maths)
19:36:40 <Pseudonym> I remember next to nothing, too, but I know where to look it up,.
19:37:05 <lamvinhnguyen199> http://tunes.org/~nef/logs/haskell
19:37:06 <sorear> Pseudonym: System.Cmd
19:37:08 <lambdabot> Title: Index of /~nef/logs/haskell
19:38:17 <byorgey> Pseudonym: do you just want to find roots numerically?
19:38:21 <Pseudonym> No.
19:38:27 <Pseudonym> Symbolically.
19:39:03 <sorear> stefan@stefans:/tmp$ echo 'display2d: false; x^5+1 ,factor;' | maxima | grep o2 | cut -c7-
19:39:07 <byorgey> Pseudonym: so you want to factor it into irreducibles?
19:39:07 <sorear> (x+1)*(x^4-x^3+x^2-x+1)
19:39:09 <sorear> stefan@stefans:/tmp$
19:39:12 <sorear> Pseudonym: ^^^ take the easy way out
19:39:13 <Pseudonym> Yes.
19:39:23 <Pseudonym> Factor into irreducibles.
19:40:30 <sorear> Pseudonym: will forking maxima work?
19:40:35 <Pseudonym> No.
19:40:41 <Pseudonym> But reverse-engineering maxima might.
19:41:19 <sorear> Careful, it's written in Common Lisp
19:41:27 <Pseudonym> I've read Common Lisp before.
19:41:32 <Pseudonym> Hell, I've read MACLISP before.
19:42:01 <sorear> WTH AL UPCS MNGLD SBL NMS?
19:42:06 <lispy> maxima is common lisp?
19:42:13 <sorear> lispy: implemented in
19:42:19 <lispy> ah, i didn't realize that
19:42:28 <lispy> so, it's cool than i thought
19:42:43 <emu> macsyma is in MACLISP go go
19:42:50 * sorear tried to read Maxima's code while trying to grok Risch
19:42:56 * sorear failed miserably at both
19:43:02 <lispy> Risch?
19:43:08 <byorgey> Pseudonym: have you looked at the polynomial factoring page on Wikipedia?
19:43:22 <Pseudonym> Maxima uses the Risch-Norman algorithm, not the full Risch algorithm.
19:43:30 <Pseudonym> Yes, I know these things.
19:43:44 <Pseudonym> byorgey: No, I haven't!  Good suggestion.
19:43:46 <sorear> lispy: Fully automatic, guaranteed to work if it can be done at all, symbolic integration
19:43:58 <byorgey> Pseudonym: probably a good place to start, at least!
19:44:02 <lispy> sorear: neat-o....okay
19:44:04 <byorgey> http://en.wikipedia.org/wiki/Polynomial_factorization
19:44:04 <lambdabot> Title: Polynomial factorization - Wikipedia, the free encyclopedia
19:44:21 <Pseudonym> BTW, the Risch algorithm is exactly what I'm doing.
19:45:00 <Pseudonym> http://andrew.bromage.org/blog/
19:45:00 <lambdabot> Title: The BWAIN
19:45:03 <Pseudonym> No code posted yet.
19:45:10 <Pseudonym> However...
19:45:19 <Pseudonym> *PolyReduce_Test> prettyPrint p5
19:45:19 <Pseudonym> "x^2 + x + 1"
19:45:19 <Pseudonym> *PolyReduce_Test> prettyPrint ex5
19:45:20 <Pseudonym> "(1/3*x^3 + 1/2*x^2 + x,0)"
19:45:41 <Pseudonym> *PolyReduce_Test> putStrLn . prettyPrint $ p4
19:45:41 <Pseudonym> x^2*tan x^4 + tan x^2
19:45:41 <Pseudonym> *PolyReduce_Test> putStrLn . prettyPrint $ ex4
19:45:41 <Pseudonym> (1/3*x^2*tan x^3 + 1/3*x*tan x^2 + (-1)*x^2*tan x,4*x*tan x + (-1)*x^2)
19:45:53 <Pseudonym> The second element in the tuple is the bit that it can't deal with yet.
19:46:03 <ddarius> BWAIN!
19:46:12 <ddarius> That's it!
19:46:47 <Pseudonym> Sorry?
19:47:10 <Pseudonym> Another example.  The integral of:
19:47:12 <Pseudonym> x^2*(e^x)^2
19:47:13 <chessguy> heh. http://wiki.pragprog.com/cgi-bin/wiki.cgi/JavaIsUntyped
19:47:14 <Pseudonym> is:
19:47:17 <lambdabot> Title: Pragmatic Wiki: JavaIsUntyped
19:47:26 <Pseudonym> ((1/2*x^2 + 1/2*x + 1/4)*(e^x)^2,0)
19:47:34 <Pseudonym> It can handle that just fine.
19:48:43 <dibblego> is it possible to write foldr in terms of foldl?
19:48:57 <mauke> probably
19:49:52 <sorear> Pseudonym: why aren't you on p.h.o ?
19:50:05 <Pseudonym> Sorry?
19:50:17 <bos> @where planet
19:50:17 <lambdabot> I know nothing about planet.
19:50:21 <Pseudonym> Oh. planet haskell.
19:50:28 <Pseudonym> Because I have my own damn server.
19:50:39 <bos> @where+ planet http://planet.haskell.org/
19:50:39 <lambdabot> Done.
19:50:46 <bos> Pseudonym: it's just a syndication service.
19:51:04 <Pseudonym> Oh, OK.
19:51:11 <Pseudonym> Well, when I actually get some Haskell code posted, I will.
19:51:38 <mauke> :t \f k xs -> foldl (\z x -> z . f x) id xs k
19:51:43 <lambdabot> forall b a. (b -> a -> a) -> a -> [b] -> a
19:52:56 <ddarius> dibblego: No.
19:53:54 <sorear> dibblego: You can write foldl in terms of foldr, however.
19:54:12 <mauke> > (\f k xs -> foldl (\z x -> z . f x) id xs k) (:) [] "foo"
19:54:13 <lambdabot>  "foo"
19:54:21 <dibblego> sorear, yeah I know that much, thanks - I am just trying to write a QC property for foldr (in Scala)
19:54:35 <lispy> ah scala...
19:54:45 <lispy> i wonder if i ever submitted the bugs i found...
19:55:20 <ddarius> > foldr (++) [] $ repeat 'a'
19:55:21 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:55:27 <ddarius> > foldr (++) [] $ repeat "a"
19:55:28 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
19:55:43 <lispy> dibblego: you could express things in terms of scanl
19:55:46 <lispy> and scanr
19:56:00 <lispy> i forget how at the moment...but we figured it out once here, so it's in the logs
19:56:03 <ddarius> > (\f k xs -> foldl (\z x -> z . f x) id xs k) (++) [] $ repeat "a"
19:56:09 <lambdabot> Terminated
19:59:58 <Binkley> ?quote
19:59:58 <lambdabot> tennin says: [very #haskell] anyone know of any good books/papers on the application of category theory to databases?
20:16:56 <Binkley> ?yow
20:16:56 <lambdabot> I feel better about world problems now!
20:17:34 <dibblego> ?check \xs -> \ys -> reverse xs ++ reverse ys == reverse (ys ++ xs)
20:17:41 <lambdabot>  Add a type signature
20:17:59 <dibblego> ?check \(xs: [Int]) -> \(ys: [Int]) -> reverse xs ++ reverse ys == reverse (ys ++ xs)
20:18:00 <lambdabot>   Not in scope: data constructor `Int'
20:18:10 <mauke> ?check \xs ys -> reverse xs ++ reverse ys == reverse ("" ++ ys ++ xs)
20:18:11 <lambdabot>  OK, passed 500 tests.
20:18:11 <dibblego> er, I forget Haskell
20:18:20 <dibblego> ta
20:18:47 <dibblego> ?check \xs -> \ys -> reverse (xs :: [Int]) ++ reverse ys == reverse (ys ++ xs)
20:18:48 <lambdabot>  OK, passed 500 tests.
20:20:08 <dibblego> ?type concatMap
20:20:10 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
20:21:03 <chessguy> ?check \xs ys -> revers (xs ::[Int]) ++ reverse ys == reverse (ys ++ xs)
20:21:03 <lambdabot>   Not in scope: `revers'
20:21:11 <chessguy> ?check \xs ys -> reverse (xs ::[Int]) ++ reverse ys == reverse (ys ++ xs)
20:21:12 <lambdabot>  OK, passed 500 tests.
20:21:17 <byorgey> @src liftM
20:21:17 <lambdabot> liftM f m1 = do { x1 <- m1; return (f x1) }
20:21:27 <chessguy> why is reverse so popular for quickcheck anyway?
20:21:50 <dibblego> I used it for foldr
20:21:57 <byorgey> @src Monad fmap
20:21:58 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:22:10 <byorgey> @src Control.Monad fmap
20:22:10 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:22:18 <dibblego> but you can imply that ++ holds so long as reverse holds and asserting that reverse holds is easy
20:22:56 <byorgey> I'm assuming liftM should be the same as fmap?
20:23:25 <ddarius> Yes
20:23:59 <ddarius> liftM is the proof that all monads are functors
20:24:03 <dibblego> ?check \xs -> reverse (xs :: [Int]) == if(null xs) xs else reverse $ tail xs ++ [head xs]
20:24:03 <lambdabot>  Parse error
20:24:12 <ddarius> then
20:24:37 <byorgey> ddarius: ok, right.
20:24:38 <dibblego> ?check \xs -> reverse (xs :: [Int]) == if(null xs) xs else reverse (tail xs) ++ (head xs):[]
20:24:38 <lambdabot>  Parse error
20:25:05 <geezusfreeek> dibblego: you are missing a "then"
20:25:11 <chessguy> @src MonadT
20:25:11 <lambdabot> Source not found. That's something I cannot allow to happen.
20:25:17 <chessguy> @src MonadTrans
20:25:17 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:25:18 <dibblego> ?check \xs -> reverse (xs :: [Int]) == if null xs then xs else reverse $ tail xs ++ [head xs]
20:25:20 <lambdabot>  Falsifiable, after 1 tests: [3,1,-1]
20:25:26 <dibblego> thanks geezusfreeek, Scala is confusing me :)
20:26:29 <dibblego> > let f xs = reverse $ tail xs ++ [head xs] in f [3,1,-1]
20:26:34 <lambdabot>  [3,-1,1]
20:26:49 <dibblego> > let f xs = (reverse $ tail xs) ++ [head xs] in f [3,1,-1]
20:26:50 <lambdabot>  [-1,1,3]
20:27:01 <dibblego> ?check \xs -> reverse (xs :: [Int]) == if null xs then xs else (reverse $ tail xs) ++ [head xs]
20:27:02 <lambdabot>  OK, passed 500 tests.
20:27:45 <mauke> ?check \xs -> reverse (xs :: [Int]) == reverse (drop 1 xs) ++ take 1 xs
20:27:47 <lambdabot>  OK, passed 500 tests.
20:29:29 <dibblego> ?check \xs -> [head xs] == take 1 xs
20:29:30 <lambdabot>  Add a type signature
20:29:37 <dibblego> ?check \xs -> [head (xs :: [Int])] == take 1 xs
20:29:38 <lambdabot>  Falsifiable, after 1 tests: []
20:29:58 <dibblego> ?check \xs -> not $ null xs => [head (xs :: [Int])] == take 1 xs -- ?
20:29:59 <lambdabot>  Parse error
20:30:08 <mauke> ==>
20:30:13 <dibblego> ?check \xs -> not $ null xs ==> [head (xs :: [Int])] == take 1 xs -- ?
20:30:14 <lambdabot>  Couldn't match expected type `Bool'
20:30:30 <lispy> maybe need parens instead of $
20:30:40 <dibblego> ?check \xs -> not (null xs) ==> [head (xs :: [Int])] == take 1 xs -- ?
20:30:41 <lambdabot>  OK, passed 500 tests.
20:30:44 <dibblego> yay!
20:30:49 <dibblego> is there a biconditional?
20:30:54 <sorear> ==
20:31:34 <dibblego> ?check \xs -> isEmpty xs == (length xs == 0)
20:31:36 <lambdabot>   Not in scope: `isEmpty'
20:31:41 <dibblego> ?check \xs -> null xs == (length xs == 0)
20:31:41 <lambdabot>  Add a type signature
20:31:48 <dibblego> ?check \xs -> null (xs :: [Int]) == (length xs == 0)
20:31:50 <lambdabot>  OK, passed 500 tests.
20:31:59 <dibblego> how can I say that is biconditional?
20:32:04 <dibblego> oh wait
20:32:06 <dibblego> nothing :)
20:32:09 <ed1t> hmm wat is this?
20:32:21 <ed1t> wat u checking?
20:32:26 <dibblego> ed1t, QuickCheck (I am using ScalaCheck irl)
20:32:33 <ed1t> cool
20:32:56 <dibblego> I am checking that for all lists (xs) that null xs is equal to length xs == 0
20:33:09 <lispy> man, some of this darcs code really confuzzles me
20:33:20 <byorgey> Parsec q, for anyone: is there a way to force Parsec to consume all input?  i.e. I want it to be a parse error if there's anything left over.
20:33:21 <chessguy> @src null
20:33:21 <lambdabot> null []     = True
20:33:21 <lambdabot> null (_:_)  = False
20:33:31 <chessguy> what's so hard?
20:33:39 <mauke> byorgey: eof?
20:33:44 <SamB> byorgey: >> eof
20:33:47 <chessguy> @check \xs -> (length (xs :: [Int] ==0) == null xs
20:33:48 <lambdabot>  Parse error
20:33:53 <lispy> ?src eof
20:33:53 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
20:33:57 <chessguy> @check \xs -> (length (xs :: [Int] ==0)) == null xs
20:33:57 <lambdabot>  Parse error
20:34:00 <byorgey> mauke, SamB: ah, thanks! I hadn't seen that.
20:34:02 <chessguy> i hate quickcheck
20:34:05 <SamB> or, well, maybe you want a value back too.
20:34:13 <lispy> byorgey: check out the definition of eof,it's very elegant
20:34:17 <chessguy> @check \xs -> (length (xs :: [Int]) ==0) == null xs
20:34:19 <lambdabot>  OK, passed 500 tests.
20:34:19 <SamB> but that's the general idea.
20:34:26 <byorgey> lispy: ok, I will
20:34:46 <lispy> chessguy: what do you use?
20:35:03 <chessguy> i don't code much in haskell (yet)
20:35:06 <SamB> once I saw that someone had defined something like >> that returned the return value of the first computation instead of the return value of the second
20:35:20 <mauke> that's my <<
20:35:49 <SamB> mauke: that's a funky notation
20:35:56 <mauke> it looks cool
20:35:56 <chessguy> hmm, wouldn't that just be flip >>
20:35:59 <SamB> not saying that it is bad...
20:36:05 <mauke> char '(' >> expr << char ')'
20:36:09 <SamB> but, perhaps chessguy is correct
20:36:24 <lispy> mauke: oh, cool and then it returns expr?
20:36:29 <chessguy> SamB, that would be a rarity indeed
20:36:29 <mauke> yeah
20:36:38 <lispy> mauke: sneaky, but cool
20:36:53 <mauke> a << b = do { x <- a; b; return x }
20:36:55 <SamB> I mean, that (<<) ought to be flip (>>)
20:37:14 <byorgey> mauke: that's nifty!
20:37:16 <lispy> ?undo do { x <- a; b; return x }
20:37:16 <lambdabot> a >>= \ x -> b >> return x
20:37:20 * byorgey goes off to use <<
20:37:26 <lispy> ?pl a >>= \ x -> b >> return x
20:37:27 <lambdabot> (b >>) . return =<< a
20:37:40 <lispy> doh
20:37:47 <lispy> pl didn't grok the return
20:37:54 <chessguy> @pl f x y = y >> x
20:37:54 <lambdabot> f = flip (>>)
20:38:01 <mauke> @. pl undo \a b -> do { x <- a; b; return x }
20:38:01 <lambdabot> (. ((. return) . (>>))) . (>>=)
20:38:29 <lispy> :t (. return)
20:38:31 <lambdabot> forall c a (m :: * -> *). (Monad m) => (m a -> c) -> a -> c
20:41:12 <SamB> ?type (=<<)
20:41:14 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:43:23 <johnnowak> are there any purely functional languages that do not have monads nor uniqueness types?
20:43:48 <mauke> lambda calculus?
20:44:38 <johnnowak> software implementations then.
20:44:45 <ddarius> johnnowak: Haskell 1.something
20:44:58 <ddarius> Miranda, Orwell, probably Lazy ML
20:45:02 <lispy> johnnowak: iirc, you could use CPS instead of monads
20:45:19 <ddarius> Joy
20:45:32 <ddarius> What does Curry use?
20:45:56 <johnnowak> ddarius: What did Haskell use before it had monads?
20:46:06 <chessguy> i thought Curry was dead...
20:46:09 <ddarius> A stream based IO system I believe.
20:46:10 <shapr> What was that crazy pre-monad input/output that Haskell had? continuation streaming or something?
20:46:15 <johnnowak> ddarius: Ah.
20:46:21 <shapr> Sort of like a permanently tied knot...
20:46:25 <sorear> shapr: Streams.
20:46:34 <chessguy> on that note...
20:46:40 <sorear> shapr: We had CPS as a library module, iirc
20:46:43 <dibblego> what's a good QC property for concatMap?
20:46:44 <johnnowak> shapr: What's so crazy about streams?
20:47:01 <ddarius> dibblego: That it satisfies the monad laws for (>>=)
20:47:12 <ddarius> johnnowak: Streams are actually fairly crazy.
20:47:22 <shapr> johnnowak: I looked at some code that used that, and I found it much harder to understand than the monadic approach.
20:47:44 <dibblego> ddarius, no monad laws here
20:47:54 <ddarius> dibblego: ?
20:48:03 <dibblego> ddarius, I'm not using Haskell
20:48:10 <johnnowak> Ah, I've not seen any code that uses streams in a purely functional setting.
20:48:15 <ddarius> dibblego: So?
20:48:18 <johnnowak> Well -- For I/O anyway.
20:48:19 <shapr> Of course, both objects and monads required a conceptual leap of understanding... but I asked the Simons about the pre-monadic approach, and I got the impression that they preferred the monadic approach to IO.
20:48:25 <dibblego> ddarius, no higher-order polymorphism, no monads
20:48:44 <ddarius> So? concatMap = (>>=) for the list monad.  It should still satisfy the monad laws.
20:48:58 <dibblego> ok true
20:49:22 <shapr> Er, let me reprhrase that... objects and monads required some serious lead time and then a conceptual lightning bolt of understanding for me when I learned them.
20:49:41 <shapr> So it's possible I'd be equally comfortable with cps io streams after some time.
20:50:28 <ddarius> The CPSed version is okay, but still not grand.  Using streams directly is ridicularious.
20:50:47 <byorgey> mauke, chessguy: << isn't the same as flip (>>)
20:50:55 <shapr> In fact, I'm convinced that all of programming is totally unnatural, and pretty close to insane (from the hunter/gather/farmer viewpoint).... and the fact that we can still do it proves that humans are amazingly adaptable.
20:51:02 <byorgey> I checked with quickcheck
20:51:21 <shapr> ddarius: ooh, I love that word!
20:51:23 <mauke> duh?
20:52:09 <ddarius> Humans and cuttlefish
20:52:14 <johnnowak> Thanks for the answers.
20:52:33 <shapr> johnnowak: One thing that I would like to understand more thoroughly is exactly why IO cannot be implemented in Haskell.
20:53:14 <shapr> I realize it's a trapdoor between 'realities', but I'd still like to know more about the limitations.
20:56:18 <lispy> shapr: trapdoor meaning it gives a way around the type checker?
20:58:42 <shapr> No, I mean that shuttling data between the inside and outside of the RTS is like going from one universe to another.
20:59:41 <shapr> On the other hand, I may not understand something correctly, so feel free to tell me how much of that you understand and agree or disagree :-)
20:59:53 <Akumi> Hi everypeoples.
21:01:00 <lispy> shapr: hmm...so just when using the FFI or even when using getContents and such?
21:01:16 <bos> is there a way to set in-process ghci options from the command line?
21:01:44 <lispy> bos: please rephrase, i'm having a hard time understanding
21:01:47 <allbery_b> bos: meaning?
21:01:51 <allbery_b> heh
21:02:08 <bos> so ghci lets you do stuff like ":set +r"
21:02:12 <shapr> bos: I can only think of ~/.ghci for sure, but -e ":set foo" might work?
21:02:35 <bos> shapr: it "works", but never gives a prompt :-)
21:02:42 <geezusfreeek> shapr: are you familiar with the way that lambda calculus works?
21:03:07 <shapr> geezusfreeek: Somewhat, do you have a specific question?
21:03:25 <shapr> bos: That's odd...
21:03:31 <geezusfreeek> was going to attempt explaining why IO is so difficult to represent directly in haskel
21:03:33 <geezusfreeek> l
21:03:50 <sorear> geezusfreeek: It has to be a primitive.
21:03:51 <shapr> bos: Aha, it does work, try ghci -e ":?"
21:04:03 <shapr> geezusfreeek: Yes please!
21:04:19 <bos> shapr: yeah, but i don't have an interactive session then
21:04:23 <shapr> bos: At least you know that the commands are executed though
21:04:30 <bos> yeah.
21:04:44 <geezusfreeek> ha, well now that i have established a prerequisite, i still can't think of a good wording... lemme think a minute
21:05:11 <dibblego> geezusfreeek, because passing a file system as a function argument is difficult, because it is inherently updating destructively
21:05:40 <dibblego> some people subscript their file systems to assist this issue under the guise of "revision control systems"
21:05:50 <dibblego> they call these subscripts, "revision numbers"
21:06:04 <geezusfreeek> dibblego: true, but i think shapr understands that just fine... i think it's a deeper question of "why"?
21:06:11 <shapr> Yeah!
21:06:15 <dibblego> oh, well because!
21:06:31 <Akumi> I am thinking of getting an introductory book on Haskell/functional programming... does anyone have any recommendations?
21:06:33 <shapr> bos: I wonder if you could hack around it using ":main ..." ?
21:06:42 <dibblego> because hard disks (and the limitations of the physical universe) are finite
21:07:01 <dibblego> Akumi, YAHT (free download) or Craft of Functional Programming
21:07:20 <geezusfreeek> shapr: i think the simplest explanation would be to have you attempt (and fail) to represent IO in plain lambda calculus
21:07:31 <geezusfreeek> the socratic method :)
21:07:43 <bos> shapr: i'll probably do something else.
21:07:44 <ddarius> Um, it's quite simple.  IO is not computation.
21:07:48 <shapr> Akumi: I've heard good things about Thompson's "Haskell : The Craft of Functional Programming" and Hudak's "The Haskell School of Expression", but the SoE graphical libs only really work on Linux with gtk, since dcoutts wrote that version.
21:07:59 <bos> i'm writing an expect-like module so that i can screenscrape ghci sessions.
21:08:12 <bos> hence the pseudoterminal stuff earlier.
21:08:36 <shapr> Why not just hack ghci itself?
21:08:50 <bos> because i want to use stock ghci
21:09:12 <bos> the goal is to be able to say "type this at the terminal, and look what ghci prints!"
21:09:14 <shapr> Well, I was going to suggest a ghci clone that uses ghc-api, but if you want stock...
21:09:19 * Akumi amazons
21:10:59 * johnnowak wonders why he finds reading papers by Wadler so irritating
21:11:13 <ddarius> johnnowak: ?!
21:11:24 <johnnowak> ddarius: I know, odd, isn't it?
21:11:34 <johnnowak> It's surely me.
21:12:27 <bos> is it licit to start using LANGUAGE pragmas in base libraries now?
21:12:43 <bos> or should i be sticking with the old-school OPTIONS?
21:18:28 <Binkley> ?quote
21:18:28 <lambdabot> apfelmus says: Ah, yet another UndeadArray necromancer exhausting his stack of bones. May the forces of light suggest to structure the incantation of darkness?
21:19:01 <johnnowak> ddarius: I tend to find a lot of his arguments to be unconvincing. The "why calculating is better than scheming" is the worst for me.
21:19:50 <SamB_XP_> johnnowak: would you rather be doing some fun math, or planning to take over the world?
21:19:59 <Binkley> can't it be both?
21:20:06 <johnnowak> What's the difference?
21:21:19 <timthelion> there is a C shell, is there a haskell one?
21:21:25 <ddarius> @where hash
21:21:25 <lambdabot> I know nothing about hash.
21:21:33 <ddarius> @google Haskell shell hash
21:21:35 <lambdabot> http://lambda-the-ultimate.org/node/1506
21:21:35 <lambdabot> Title: Linspire chooses Haskell as preferred language | Lambda the Ultimate
21:22:26 <mauke> what do you mean by "C shell"?
21:22:46 <ddarius> @where hashell
21:22:46 <lambdabot> haskell.org/hashell
21:22:56 <johnnowak> as in, the the ones sold by the C shore
21:23:02 <ddarius> timthelion: There are some about.
21:23:10 <timthelion> mauke: there is one that unlike sh uses C syntax
21:23:38 <mauke> if you're talking about csh, that one's about as C as javascript is Java
21:23:42 <SamB_XP_> timthelion: ... C doesn't HAVE shell syntax
21:23:46 <timthelion> I just think haskell is the perfect language for string manipulation, which for me, is what the shell is all about
21:24:15 <johnnowak> "perfect"
21:24:32 <SamB_XP_> I thought rc(1) was kinda cool
21:24:36 <mauke> have you seen this thing called perl?
21:24:47 <mauke> it's probably better at string manipulation
21:25:08 <timthelion> I looked at it, it has this thing called regex, which makes my little non-dislexic brain feel very dislexic
21:25:26 <mauke> regexes are simple
21:25:39 <timthelion> simple, but lexicaly insane
21:25:47 <mauke> yep
21:25:48 <timthelion> /////g///.//o
21:25:52 <mauke> no
21:26:02 <SamB_XP_> timthelion: you must be confusing it with Emacs
21:26:03 <emu> regular languages go
21:26:08 <SamB_XP_> except in emacs it would be
21:26:19 <SamB_XP_> \\\\\g\\\.\\o
21:26:23 <bos> boy howdy do, i love StateT.
21:26:33 <mauke> "\\(foo\\|\\\\\\)"  ; go emacs
21:26:43 <SamB_XP_> and I wish someone hadn't put more Enter where the "\" key is supposed to be
21:27:03 <johnnowak> SamB_XP_: time for a new keyboard
21:27:12 <timthelion> time for xmodmap
21:27:17 <SamB_XP_> johnnowak: actually someone just gave me a new keyboard
21:27:25 <johnnowak> ah, very nice.
21:27:29 <mauke> (that's /(foo|\\)/ in perl)
21:27:30 <SamB_XP_> timthelion: xmodmap can cut keys in two ?
21:27:42 <timthelion> no. but you can figure something out
21:28:00 <johnnowak> the hammer you'll take to the keyboard after wasting time with xmodmap can
21:28:07 <SamB_XP_> johnnowak: but it has one of those big-old Enter keys, with a tiny backspace key and \ to the left of backspace...
21:28:17 <johnnowak> unfortunate
21:28:36 <SamB_XP_> so I'm considering going back to my old, near-sentient keyboard
21:28:47 <mauke> my \ is to the right of the right shift key
21:29:02 <timthelion> my / is where most people's p keys are
21:29:11 <SamB_XP_> timthelion: crazy
21:29:16 <mauke> / is to the left
21:29:21 * timthelion uses a highly modified dvorak which he loves
21:29:22 <SamB_XP_> what kind of keyboards do you people have?
21:29:37 <timthelion> ',.pyqgcr/=z\ is the top row
21:29:38 * ddarius has a laptop and is using its keyboard.
21:29:47 * johnnowak has a standard apple keyboard
21:29:53 <timthelion> this is on a laptop now, but I usualy use datahands
21:30:05 * siti uses colemak :p
21:30:06 <ddarius> Anyways, Haskell isn't a slouch at expressing string manipulation.
21:30:16 <johnnowak> timthelion: eccentric bastard
21:30:41 <SamB_XP_> ... datahands?
21:30:53 <timthelion> johnnowak: I'm not eccentric, I have a perfectly good center
21:31:04 <SamB_XP_> timthelion: you don't have two foci?
21:31:08 <ddarius> ',.pyfgcrl/= is Dvorak's top row
21:31:10 <timthelion> SamB_XP_: google it, I'm like the third hit
21:31:34 <SamB_XP_> @go datahands
21:31:34 <timthelion> ddarius: I said, highly modified
21:31:37 <lambdabot> http://www.datahand.com/
21:31:37 <lambdabot> Title: Ergonomic Keyboards By DataHand To Reduce Keying Stress.
21:31:43 <mauke> my keyboard looks mostly like http://upload.wikimedia.org/wikipedia/commons/3/3c/Cherry_keyboard_105_keys.jpg
21:31:45 <lambdabot> http://tinyurl.com/324y55
21:31:46 <ddarius> timthelion: I was just mentioning it for comparison
21:32:36 <ddarius> Why does it randomly have mu on it?
21:32:48 <mauke> except the area around enter/right shift looks like http://upload.wikimedia.org/wikipedia/en/d/d7/Taiwan_keyboard_bopomofo.JPG
21:32:50 <lambdabot> http://tinyurl.com/2bt67r
21:33:26 <ddarius> Bild?
21:33:54 <ddarius> Yay kana
21:37:41 <dibblego> why can't lambdabot find some source?
21:37:59 <ddarius> Read the source.
21:38:38 <ddarius> @version
21:38:38 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
21:38:39 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
21:43:13 <RyanT5001> what did haskell's IO look like before monads? is there a good paper on it?
21:43:27 <RyanT5001> (i'm trying to get a good sense of the historical progression of haskell)
21:44:11 <ddarius> http://www.haskell.org/haskellwiki/History_of_Haskell
21:44:13 <lambdabot> Title: History of Haskell - HaskellWiki
21:44:25 <RyanT5001> is that "being lazy with class"
21:44:28 <RyanT5001> that's what i'm currently reading
21:44:49 <Binkley> "Tackling the Awkward Squad" cites this paper:
21:44:55 <Binkley> http://citeseer.ist.psu.edu/30726.html
21:44:56 <lambdabot> Title: On the Expressiveness of Purely Functional I/O Systems - Hudak, Sundaresh, On (R ...
21:45:12 <RyanT5001> oh, nevermind
21:45:15 <RyanT5001> i found it :)
21:45:24 <RyanT5001> there's a whole section on it
21:49:22 <sorear> Wow.
21:49:40 <sorear> You know your keyboard is jammed when pressing , gives m
21:50:52 <Binkley> ?yow
21:50:52 <lambdabot> I'm also against BODY-SURFING!!
21:50:56 <Heffalump> are any other keys mismapped?
21:51:18 <Heffalump> work has this annoying Java Citrix connection app for remote access that occasionally gets into that state
21:57:53 <weitzman> sorear: I spilled something in a keyboard a few weeks ago and messed it up enough that pressing some keys would result in the correct letter followed by a completely different one
21:58:21 <weitzman> Like, "a" resulted in "a-"
21:58:47 <ddarius> Snowcones are bad for keyboards.
21:58:48 <mauke> a-wlees%o`mee&
21:58:55 <ddarius> Green tea not so much.
22:23:25 <bos> @hoogle [a] -> [([a], [a])]
22:23:25 <lambdabot> No matches, try a more general search
22:26:28 <bos> @type liftM2 zip inits tails
22:26:30 <lambdabot> forall a. [a] -> [([a], [a])]
22:28:00 <lispy> > liftM2 zip inits tails $ [1,2,3,4]
22:28:02 <lambdabot>  [([],[1,2,3,4]),([1],[2,3,4]),([1,2],[3,4]),([1,2,3],[4]),([1,2,3,4],[])]
22:28:07 <lispy> neat
22:28:51 <bos> useful.
22:28:54 <ozone> ddarius: i make nice webpages? :)
22:29:08 <lispy> bos: may i ask what you're using it for?
22:29:51 <bos> lispy: you can use it to construct a fast list search that gives you the prefix of the sublist you're looking for
22:31:15 <lispy> hmm...
22:31:38 <lispy> so the list is the second element of each tuple?
22:32:04 <bos> yes
22:32:31 <ddarius> ozone: Yes.
22:33:19 <lispy> sorear: esp. if your layout is dvorak
22:34:44 <sorear> took me a while to get :)
22:36:18 <lispy> i have the inverse problem about most keyboarding jokes these days, "What, why those letters? *looking at a qwerty layout for a bit* oh, i get it"
22:38:21 <Jaggederest> yep I just switched, quite a difference. Still not up to speed on the symbols, but I'm already faster on text
22:39:04 <Jaggederest> I get the feeling that either way, carpal tunnel syndrome is going to take me eventually
22:40:37 <lispy> probably but dvorak helped me a lot
22:41:27 <hpaste>  bos pasted "infix with prefix" at http://hpaste.org/202
22:43:03 <sorear> hello glguy
22:44:11 <lispy> bos: ah
22:44:13 <lispy> bos: cool
22:48:12 <hpaste>  bos annotated "infix with prefix" with "a useful variant" at http://hpaste.org/202#a1
22:49:26 <bos> i use the second one to search for a prompt string in my session transcript. if i don't find the command string, i still want to print what i saw.
23:23:27 <dmwit> :t maybe
23:23:29 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
23:23:54 <dmwit> ?hoogle (a -> Bool) -> a -> Maybe a
23:23:54 <lambdabot> No matches, try a more general search
23:24:20 <dmwit> :t if'
23:24:22 <lambdabot> Not in scope: `if''
23:25:30 <dmwit> :t let sometimes p x = if p then return x else mzero; maybeAny p = msum . map (sometimes p) in maybeAny
23:25:32 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => Bool -> [a] -> m a
23:25:48 <dmwit> :t let sometimes p x = if p x then return x else mzero; maybeAny p = msum . map (sometimes p) in maybeAny
23:25:50 <lambdabot> forall a (m :: * -> *). (MonadPlus m) => (a -> Bool) -> [a] -> m a
23:27:23 <roconnor> @hoogle [a] -> m a
23:27:24 <lambdabot> Prelude.head :: [a] -> a
23:27:24 <lambdabot> Prelude.last :: [a] -> a
23:27:24 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
23:28:12 <shapr> Hah, the Linux kernel really needs both Maybe and Either.
23:28:49 <shapr> I'm reading "The thorny case of kmalloc(0)" from the just released lwn.net weekly edition.
23:30:59 <shapr> If you try to kmalloc a zero sized object, you can't return NULL, because that represents allocation failure, or that a subsystem or structure has not been initialized.
23:39:25 <lispy> shapr: yeah, C (and languages based on it) really lose out from not having those
23:39:28 * shapr cheers for unit tests that pass!
23:39:30 <lispy> mainly Maybe
23:40:46 <shapr> To me it seems that it must be a very primitive programming language if it is forced to use "undefined" to represent Nothing, and if Nothing is not easy to define and use.
23:42:09 <vegai> why would you want to kmalloc a zero sized object?
23:42:17 <Pseudonym> Symmetry.
23:42:43 <Pseudonym> OK, maybe not kmalloc.
23:43:28 <vegai> some hardware detail?
23:43:36 <Pseudonym> But generally speaking, "Why would you want to X?"-type questions usually precede arbitrary restrictions.
23:44:07 <vegai> "Why would you want to have pure functions?" :P
23:44:27 <Pseudonym> Exactly.
23:44:51 <Pseudonym> When I implemented sorting for a database server, my then boss asked "why would you want to sort a zero-sized result set?"
23:45:07 <Pseudonym> He argued it should be an error.
23:45:11 <dmwit> !
23:45:15 <Pseudonym> Exactly!
23:45:28 <dmwit> So, if you don't explicitly check for empty results, your *sort* method would fail?
23:45:44 <dmwit> I would think that would make it to worsethanfailure.com or so. =P
23:45:47 <Pseudonym> Oh, hang on.
23:45:50 <Pseudonym> No, wait.
23:45:57 <Pseudonym> This was first-k sorting.
23:46:09 <Pseudonym> When you have a result set, and you ask for the first k results that would be in the sorted set.
23:46:23 <Pseudonym> You might use this, for example, to sort lazily.
23:46:23 <shapr> vegai: Kernel config could produce zero sized structs if none of those features are used. How would you get around kmalloc(0) in that case?
23:46:52 <Pseudonym> Say, on Google, where you only need the first screenfull to be sorted now, and the rest can be done if requested.
23:46:54 <dmwit> Mmm, so he claims it should signal an error if there weren't k results to return.
23:46:55 <flux> aren't structs always atleast one byte, or is that a c++ feature?
23:46:59 <Pseudonym> He said it should be an error if k=0.
23:47:10 <dmwit> o
23:47:15 <shapr> flux: Well, zero-size objects...
23:47:17 <Pseudonym> My first comment was that it takes exactly one extra line of code to implement it efficiently.
23:47:27 <Pseudonym> if (k == 0) return;
23:47:56 <Pseudonym> And THREE lines to implement it as an exception.
23:47:58 <shapr> flux: en tieda
23:48:48 <vegai> shapr: ah.
23:49:18 * vegai should try kernel-level coding some time
23:49:41 <shapr> vegai: I only tried it once shortly several years ago, so I'm only parroting what I just read on lwn.net
23:50:18 <shapr> I still think the big problem is the lack of Maybe.
