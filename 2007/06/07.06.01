00:19:01 <yakov> hello
00:19:10 <MechaBlue> Hello
00:27:59 <scodil> can you use forall to scope a type variable over multiple variants of a datatype? Like if I have data T = U (R a b) | V (S a b), and I want to enforce that a and b are the same in both variants
00:28:08 <scodil> i can't get it to parse
00:28:16 <scodil> and i don't really know if its possible
00:36:15 <whaleofconfusion> this may be blindingly obvious but I don't seem to be getting it--how do you create a loop in a linked list in a pure functional style?
00:36:45 <scodil> http://www.haskell.org/hawiki/TyingTheKnot
00:36:46 <lambdabot> Title: TyingTheKnot - The Haskell Wiki
00:36:55 <scodil> that page is kinda verbose
00:37:01 <scodil> but the answer is in there
00:37:11 <sethk> whaleofconfusion, you use pattern matching to operate on the head of the list, and recursively call the function with the tail of the list, until the tail is empty
00:40:27 <whaleofconfusion> hm ok actually this originated as a Lisp question, I just thought the pure functional side might be better represented here--is there a way to do it without lazy evaluation?
00:41:32 <Philippa> only by emulating it
00:45:08 <araujo> hello
00:54:59 <quicksilver> scodil: they should automatically be the same (your a and b)
00:55:09 <quicksilver> scodil: you don't need to do anything special to make that happen
00:55:19 <scodil> no its not... i can make then different
00:55:26 <quicksilver> scodil: well it needs to be data T a b
00:55:29 <quicksilver> not just T
00:55:32 <scodil> right
00:55:36 <scodil> a and b are phantom types
00:55:40 <scodil> er, one of em is
00:55:44 <scodil> lets say b
00:55:50 <quicksilver> consider data Tree a = Node a | Leaf (Tree a) (Tree a)
00:55:53 <scodil> and it complains that b is not in scope
00:55:57 <quicksilver> trust me this works :)
00:56:11 <quicksilver> otherwise recursive data in haskell would be totally broken
00:56:14 <osfameron> I blogged about trees this morning!
00:56:29 <quicksilver> scodil: maybe paste some of your code? maybe you're doing something else wrong
00:56:42 <quicksilver> scodil: I promise you, repeated type vars in data definitions refer to the same type
00:57:30 <scodil> right... my problem is that I need to bring that variable into scope across those definitions, but that type is not a field of the datatype
00:58:24 <scodil> data T a = U (R a b) | V (S a b)
00:58:30 <quicksilver> it must be T a b
00:58:30 <scodil> b is only on the rhs
00:58:38 <quicksilver> b must be on the lhs too
00:59:02 <quicksilver> otherwise it's just an unbound variable, plain and simple
00:59:18 <quicksilver> Types can be parameterised by type variables, and you list them on the LHS
00:59:27 <quicksilver> just like you list the parameters to a function on the LHS
00:59:45 <quicksilver> there's no other way to bind 'b', you see
00:59:52 <quicksilver> (except with GADTs and associated types)
01:01:26 <scodil> gotcha.. ok this was way easier than i though
01:01:28 <scodil> thought
01:58:11 <scodil> what does it mean when it says "the Coverage Condition fails for one of the functional dependencies" ?
02:04:20 <quicksilver> the coverage condition is a simple algorithm for functional dependencies
02:04:34 <quicksilver> I believe it says, that all the variables in the one type must be determined by the other type
02:04:48 <scodil> so if it fails then I'm not satisfying that condition
02:05:08 <quicksilver> yes
02:05:20 <quicksilver> http://haskell.galois.com/trac/haskell-prime/wiki/FunctionalDependencies
02:05:22 <lambdabot> Title: FunctionalDependencies - Haskell Prime - Trac, http://tinyurl.com/2ca4jj
02:05:25 <quicksilver> contains some of the background
02:05:36 <quicksilver> you can relax some of these rules with undecidable or incoherent instances
02:05:40 <quicksilver> may not be what you want, though
02:11:53 <Itkovian> meuning.
02:13:15 <arcatan> moaning
02:41:58 <quicksilver> holy hankerchiefs, batman!
02:42:13 <quicksilver> haskell on a FPGA
02:42:16 <quicksilver> that is cool
02:42:51 <osfameron> FPGA?
02:43:35 <quicksilver> Fully Programmable Gate Array
02:43:45 <quicksilver> essentially, a software-programmable chip
02:46:50 <notsmack> quicksilver: cool article.  FPGA specified in haskell, no less
02:50:51 <roconnor> @where FPGA in haskell
02:50:51 <lambdabot> I know nothing about fpga.
02:51:10 * earthy can only imagine what the fpga monsterbox that I once had the pleasure of being in the same room with would do with that
02:52:10 <earthy> (hardware design is... strange. they ran a machine with a couple of hundred fpga's to simulate their hardware design at a mere 1/1000th of the design speed. that allowed them to do traces beyond the first 10 ms. ;))
02:52:32 <roconnor> can I get a TCP/IP stack on that FPGA?
02:56:50 <quicksilver> roconnor: I imagine not
02:56:58 <roconnor> aww
02:56:58 <quicksilver> roconnor: you'd have to write one in haskell :)
02:57:04 <roconnor> sold
02:57:14 <quicksilver> roconnor: http://www-users.cs.york.ac.uk/~mfn/reduceron/index.html
02:57:17 <lambdabot> Title: The Reduceron
02:58:05 <quicksilver> "Somewhat strangely for a compiler, Tred will actually evaluate main using a Reduceron emulator, giving the program's expected result and its total heap usage."
02:58:11 <quicksilver> that is indeed unusual :)
02:59:10 * roconnor senses an optimization that the compiler could use.
03:00:10 <quicksilver> agreed
03:00:17 <quicksilver> it is only a proof-of-concept type piece of research
03:00:23 <quicksilver> but it's very, very, very cool nonetheless
03:01:27 <roconnor> wow, Xilinx looks like a real company
03:03:38 <pejo> roconnor, uh, they are?
03:04:03 <pejo> That came out wrong, I meant it as a statement, not a question.
03:04:23 <roconnor> and they use Haskell!
03:04:28 <roconnor> and they are not in finance
03:04:50 <quicksilver> microsoft are a real company, too :)
03:05:00 <swiert> isn't Xilinx where Satnam Singh worked?
03:05:08 <roconnor> quicksilver: does Microsoft use Haskell?
03:05:57 <swiert> roconnor: I believe Microsoft Research does ;)
03:06:23 <roconnor> :) I'm not convinced that MSR and MS are really the same company in any effective way.
03:06:35 <roconnor> I mean, by that reasoning Microsoft uses Coq too.
03:06:41 <quicksilver> which it does
03:07:01 <quicksilver> Byron Cook's work in MSR has directly impacted real tests that MS uses on 3rd party device drivers
03:07:12 <quicksilver> which have caught real bugs, by static analysis
03:07:13 <earthy> uhm, MSR is as much part of MS as Xerox PARC was part of Xerox
03:07:23 <roconnor> earthy: exactly :)
03:07:25 <pejo> quicksilver, is that SLAM and those other tools?
03:07:28 <quicksilver> pejo: yes
03:08:03 <quicksilver> some of MSR's work is less directly relevant to MS's core businesses than other parts, obviously
03:08:13 <quicksilver> but I don't think you can pretend there is no cross-over..
03:08:52 <roconnor> quicksilver: if I only consider functional programming, can I pretend?
03:08:59 <pejo> Any company with a large research budget will have speculative projects in thier budget, and they might not turn out to be useful.
03:09:08 * earthy nods
03:09:39 <earthy> heck, the Alto was marketed as the Star, IIRC
03:15:25 <earthy> drat!
04:22:48 <dons> ?yow
04:22:49 <lambdabot> Did I do an INCORRECT THING??
04:23:02 <Pseudonym> ?arr
04:23:02 <lambdabot> I'll keel haul ya fer that!
04:23:07 <olsner> ?yow
04:23:07 <lambdabot> I appoint you ambassador to Fantasy Island!!!
04:23:11 <olsner> yay!
04:23:26 <Pseudonym> Say hello to Herve for me!
04:29:22 <olsner> @type when
04:29:26 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
04:30:34 <olsner> @type undefined
04:30:36 <lambdabot> forall a. a
04:31:07 <olsner> @type ($=)
04:31:09 <lambdabot> Not in scope: `$='
04:34:08 <olsner> @type Rendering.Graphics.OpenGL.($=)
04:34:10 <lambdabot> Couldn't find qualified module.
04:34:13 <ToRA> class HasSetter s where
04:34:14 <ToRA> ($=) :: s a -> a -> IO ()
04:34:20 <ToRA> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
04:34:22 <lambdabot> http://tinyurl.com/24hd3h
04:34:22 <ToRA> olsner ;)
04:34:43 <olsner> yeah, just wondered if lambdabot could do it.. (had already checked in ghci)
04:35:28 <ToRA> @type Graphics.Rendering.OpenGL.($=)
04:35:30 <lambdabot> Couldn't find qualified module.
04:35:39 <ToRA> indeed not
04:37:46 <tommyd_> Hi all! I'm currently trying to learn Haskell with a tutorial located here: ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf
04:38:06 <tommyd_> this seems to assume that I use Hugs, however I have ghc 6.6.1 installed
04:38:32 <tommyd_> and somehow, certain things don't seem to work in ghc, like > f = putStr "hello world"
04:38:46 <mdmkolbe|work> tommyd_: are you using ghci?
04:38:51 <tommyd_> yep
04:38:57 <tommyd_> it tells me for the above line <interactive>:1:2: parse error on input `='
04:39:00 <mdmkolbe|work> > let f = putStr "hellow"
04:39:00 <lambdabot>  Parse error
04:39:13 <tommyd_> so let is missing ?
04:39:19 <mdmkolbe|work> tommyd_: yep
04:39:21 <tommyd_> ah, ok
04:39:25 <tommyd_> thanks for the quick help
04:39:31 <notsmack> tommyd_: it's valid without the let in a source file, but not the interpreter
04:39:38 <tommyd_> is there something similar to Perl's strict mode?
04:39:55 <notsmack> tommyd_: yeah, it's always on.  ;-)
04:39:58 <tommyd_> ok, thanks for the info =)
04:40:39 <tommyd_> I acutally always use strict when I do perl hacking, so I wondered if something similar to this could be the cause for the error
04:40:43 <tommyd_> thanks!
04:44:24 <mdmkolbe|work> tommyd_: there is a -W and -Wall flag you can use if you're concerned about writing clean code, but even without those flags Haskell will never(*) let you do anything that violates type safety.  (*) unless you use certain unsafe low level dangerous functions that are only there as a concession to when you realy realy need them, but as a new user you won't run in to those for a while
04:45:24 <notsmack> i'd imagine he'll be pleasantly surprised with how strict Haskell is
04:45:33 <tommyd_> ok... another question: in the tutorial, functions without arguments are called "constant functions", probably because there does not exist the concept of global variables in haskell
04:45:49 <tommyd_> thus the output of a function is always defined by its input, correct?
04:46:06 <Lemmih> They _are_ global variables.
04:46:11 <tommyd_> oh, ok
04:46:23 <Lemmih> They're just not mutable.
04:46:34 <tommyd_> because the question arises, how one could then read from devices
04:46:47 <mdmkolbe|work> tommyd_: yes, another way to say that is that are functions are "pure" mathematical functions.  (Haskell is a pure language)
04:46:51 <sieni> a variable that's no mutable sounds a bit... ahem... paradoxical
04:46:57 <tommyd_> (the output of such a, let us call it read function, should not be constant then)
04:47:21 <mdmkolbe|work> tommyd_: the answer to that questions lies in understanding Monads
04:47:22 <Lemmih> sieni: To vary is not the same as to mutate.
04:47:50 <tommyd_> mdmkolbe|work: ok, I'm probably thinking to fast / far away already
04:47:57 <tommyd_> I should understand the basics first =)
04:48:30 <mdmkolbe|work> tommyd_: well whenever that tutorial gets to monads would be the appropriate time to answer it
04:49:22 <tommyd_> hrm... it doesn't mention monads at all, a quick search showed... I should probably use another then
04:52:03 <tommyd> what prefix / language term do I have to use for function definitions?
04:52:12 <notsmack> tommyd: none
04:52:17 <notsmack> f x = 2 * x
04:52:27 <tommyd> because a simple > inc :: Integer -> Integer  throws errors as well
04:52:53 <tommyd> sorry, I meant declarations
04:52:53 <notsmack> ah, again, that's not really something the interpreters will deal with well
04:53:15 <notsmack> it sounds like you're looking at code that's meant to by typed into a file, which operates under slightly different rules
04:53:21 <tommyd> hrm... ok, I guess I have to leave the interactive consike then
04:53:31 <tommyd> console
04:54:53 <notsmack> tommyd: haskell doesn't work as well as some things interpreted because of its declarative nature.  order of definitions isn't important in a file, but interactively it inherently is
04:55:25 <mdmkolbe|work> tommyd: the usual mode of development is to have an editor open along with a terminal in which you've loaded the file (use ':r' to reaload it without exiting GHCi) so you can type expressions and experiment, but declarations can be typed in the file
04:55:57 <tommyd> mdmkolbe|work, notsmack: ok, will do that, thanks for the hints
04:57:35 <notsmack> tommyd: which tutorial are you working on?
04:58:03 <tommyd> notsmack: this one: ftp://ftp.geoinfo.tuwien.ac.at/navratil/HaskellTutorial.pdf
04:59:34 <mdmkolbe|work> tommyd: a quick look indicates that 'www.haskell.org/~pairwise/intro/intro.html' is probably a good tutorial.  'www.cs.utah.edu/~hal/docs/daume02yaht.pdf' is very thuought, but is more like a reference.  'cs.wwc.edu/KU/PR/Haskell.html' is good but more of a quick start/cheat sheet for the new user.  Finally, I'd avoid 'www.haskell.org/tutorial/' b/c it's not very "gental" in my optinion.
05:00:24 <tommyd> hah, "haskell for c programmers" - I'm not a c programmer =)
05:00:26 <bringert> dcoutts: I'm trying to build c2hs from darcs, and get an error because CParser.hs uses the Array module, which is in the haskell98 package, with is not a build dep
05:00:38 <dcoutts> bringert: ah, hmm
05:00:44 <mdmkolbe|work> tommyd: oh, yeah and then there's the wikibook (incomplete, but good where it is complete) http://en.wikibooks.org/wiki/Haskell
05:00:45 <lambdabot> Title: Haskell - Wikibooks, collection of open-content textbooks
05:01:00 <mdmkolbe|work> tommyd: are you a Java or python programmer?
05:01:24 <tommyd> well, I usually do procedural / oo programming, but partially also JavaScript which allows some kind of functional programming
05:01:29 <dcoutts> bringert: for me it generates:
05:01:29 <dcoutts> #if __GLASGOW_HASKELL__ >= 503
05:01:29 <dcoutts> import Data.Array
05:01:36 <bringert> hmm
05:01:51 <dcoutts> bringert: you're building with cabal right? and what version of happy?
05:02:09 <bringert> dcoutts: cabal and happy 1.15
05:02:31 <dcoutts> bringert: ah, I'm using 1.16, that's probably the difference
05:02:32 <Igloo> dcoutts: What generates that?
05:02:37 <Igloo> happy?
05:02:39 <dcoutts> Igloo: happy 1.16
05:02:55 <bringert> dcoutts: I have import Array in CParser.hs, with no #ifs
05:03:12 <dcoutts> bringert: is cabal passing -g or --ghc to happy for you?
05:03:23 <mdmkolbe|work> tommyd: close enough.  Haskell is so different from other languages that compared to Haskell most other languages are just clones of C.
05:03:30 <bringert> dcoutts: yes, -agc
05:03:39 <int-e> mdmkolbe|work: except prolog ;)
05:03:42 <tommyd> I guess so =)
05:03:58 <bringert> dcoutts: I guess happy 1.15 is old enough not to care about Array / Data.Array
05:04:03 <tommyd> I hated prolog in school =)
05:04:22 <dcoutts> bringert: we could add haskell98 back in I suppose
05:06:00 <tommyd> this haskell for c programmers tutorial is nicely written, I think I'll stick with that
05:06:35 <notsmack> tommyd: I started with that one, too.  no complaints.
05:07:13 <mdmkolbe|work> tommyd: when you've finished reading it (or as you're reading it take notes) I'd be interested to hear how it went.  Finding a good Haskell tutorial is actually quite hard.  (2 yr ago there were none that were any help to a new user)
05:07:39 <tommyd> mdmkolbe|work: did you write it?
05:08:12 <mdmkolbe|work> tommyd: no, but when someone askes for a Haskell tut, it would be nice to have a good answer
05:08:18 <tommyd> ah, ok =)
05:08:39 <quicksilver> part of the problem is that there are in fact very many tutorials out there now
05:08:41 <mdmkolbe|work> RE: not any help.  e.g. they would throw around terms like 'data type', 'class', 'instance' and 'constructor' without explaining that they mean something completely different than in C++
05:08:51 <quicksilver> especially if you include the blog ones
05:08:54 <tommyd> well, I see what I can do... I'm not a student anymore so I can't concentrate on this full time, but if I have annotations on it I#ll make notes
05:09:38 <mdmkolbe|work> notsmack: would you recommend that one for recommending to people?
05:10:17 <notsmack> mdmkolbe|work: honestly I don't really remember.  I think it answered a lot of my initial questions, but I pretty quickly needed to find supplemental sources.
05:10:17 <tommyd> the reason why I'm learning haskell is basically because I want to expand my knowledge to functional programming and there is a open source project using haskell which I'd like to hack =)
05:10:28 <notsmack> tommyd: which project is that?
05:10:41 <tommyd> DisTract, http://www.distract.wellquite.org
05:10:43 <lambdabot> Title: start [DisTract]
05:10:56 <tommyd> what is this bot doing here?!
05:11:22 <notsmack> tommyd: she's another helpful resource
05:11:25 <tommyd> I'm already hacking monotone, the system DisTract builds upon, so I'm fairly familiar with the concepts =)
05:11:29 <olsner> argh, colloquy is buggy! scrolling part certain points in the log makes the window go blank.. moving the cursor over words blanks them out... when the text you've entered wraps the line, resizing the input box, the log window goes blank too
05:11:49 <mdmkolbe|work> tommyd: observe
05:11:51 <mdmkolbe|work> > 1 + 1
05:11:57 <lambdabot>  2
05:11:58 <notsmack> > let fibs = 0 : 1 : zipWith (+) fibs (tail fibs)
05:11:59 <lambdabot>  Parse error
05:12:00 <mdmkolbe|work> :t 1
05:12:01 <tommyd> hehe =)
05:12:08 <lambdabot> forall t. (Num t) => t
05:12:15 <tommyd> nice, an interactive haskell compiler bot
05:12:16 <mdmkolbe|work> @djinn a -> a
05:12:17 <lambdabot> f a = a
05:12:25 * notsmack did that wrong
05:12:27 <mdmkolbe|work> @docs Control.Monad
05:12:27 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Monad.html
05:12:47 <notsmack> @type ( map (*4) )
05:12:50 <lambdabot> forall a. (Num a) => [a] -> [a]
05:12:51 <mdmkolbe|work> et cetera, et cetera, et cetera
05:12:57 <notsmack> @src foldr
05:12:58 <lambdabot> foldr k z xs = go xs
05:12:58 <lambdabot>     where go []     = z
05:12:58 <lambdabot>           go (y:ys) = y `k` go ys
05:13:24 <notsmack> @version
05:13:25 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
05:13:25 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
05:13:26 <tommyd> a general understanding problem: how does the Glasgow Haskell compiler relates to Hugs and the others?
05:13:40 <tommyd> I usually see people using ghc
05:13:54 <quicksilver> hugs is a (sort-of) interpreter
05:14:03 <tommyd> so I assumed it would be a good choice to start and deal with
05:14:06 <quicksilver> ghc is a compiler, which happens to ahve an interactive frontend too
05:14:14 <notsmack> tommyd: GHC has support for more recent extensions, too
05:14:14 <quicksilver> ghc is a good choice at the moment for deploymnet
05:14:18 <quicksilver> it's a good compiler
05:14:27 <quicksilver> ghc tends to implement extensions first
05:14:40 <tommyd> ok, I see... the community is broader =)
05:14:59 <quicksilver> most of the time, most people try to write most of their code in portable haskell
05:15:04 <quicksilver> and there are definitely fans of hugs
05:15:14 <quicksilver> it's helpful to the community to have several compilers out there
05:15:22 <tommyd> yeah, I think so
05:15:22 <quicksilver> in addition to the two you mentioned, there are also jhc and yhc
05:15:31 <notsmack> i'm surprised i'd never heard of DisTract, i've been wishing something like it existed
05:15:39 <quicksilver> there is also Bugs Everywhere, I think
05:15:46 <quicksilver> (I've used neither, though)
05:15:48 <tommyd> notsmack: oh, the project just started a few weeks ago
05:15:48 <notsmack> (and nhc?)
05:15:51 <tommyd> its bleeding edge =)
05:16:35 <notsmack> looks very impressive already
05:16:40 <tommyd> I contributed a port for Macports because I think its a very cool approach in a distributed world
05:17:11 <tommyd> so if you're on a Mac and have macports installed, all you need to do is $ sudo port install DisTract
05:18:03 <olsner> javascript calling local programs.. ugh... sounds like that kind of thing should be a job for a local web server
05:18:20 <notsmack> olsner: yeah, i just noticed that bit...
05:18:37 <tommyd> olsner: yes, I support that view as well, but the author hasn't yet answered my post wrt that
05:18:54 <tommyd> works only in Firefox currently
05:19:21 <tommyd> on the other hand it would be nice if it would get its own little webserver
05:19:21 <olsner> but hey, just factor out the calling-local-programs part and start work on the web server as an alternative back-end
05:19:47 <tommyd> because I don't like the idea of throwing in a fully-fledged webserver in the mix
05:19:52 <Jaggederest> javascript can be pretty slick if it's done functionally
05:19:53 <tommyd> (like Apache)
05:20:11 <quicksilver> real OSes make installing a local webserver painless :P
05:20:16 <tommyd> Jaggederest: indeed, JS just has a bad moan (sp?)
05:20:25 <notsmack> sure, but there's always HAppS and WASH, too
05:20:46 <olsner> I was thinking a dirt-simple embedded webserver, rather than CGI-on-apache or whatever
05:20:53 <quicksilver> there are any number of good mini-webservers out there
05:20:58 <tommyd> quicksilver: hehe =)
05:21:22 <tommyd> olsner: yeah, I was thinking of that as well... I've read that somebody has written a webserver in 1500 loc haskell
05:21:25 <olsner> @where wash
05:21:25 <lambdabot> http://www.informatik.uni-freiburg.de/~thiemann/haskell/WASH/
05:21:33 <quicksilver> but then again, all macs come with apache installed and under a decent BSD/Linux installing one is isomorphic to 'apt-get install apache2'
05:21:37 <tommyd> maybe this could be ripped off somehow, I don't know
05:22:03 <tommyd> the original author still has to share my point of view on the whole topic :/
05:22:16 <Jaggederest> HAppS' basic fileserve can be set up in ~15 LOC (of course it depends on the libs...)
05:23:01 <notsmack> Jaggederest: if most of that app is haskell it might be easier to just skip the fileserve part and jack in directly...
05:23:26 <DRMacIver> tommyd: I disagree. Javascript has a deservedly bad reputation, despite being basically a decent language.
05:23:26 <olsner> tommyd: no he doesn't - just fork ;-)
05:23:41 <tommyd> offtopic, but Douglas Crockford has opened my eyes wrt Javascript: http://javascript.crockford.com/javascript.html
05:23:42 <lambdabot> Title: JavaScript: The World's Most Misunderstood Programming Language
05:24:04 <Jaggederest> ya I'm just trying to learn HAppS... and my head hurts. Coincidence? I think not
05:24:27 <notsmack> Jaggederest: heh, I only played with it a bit but really liked it
05:24:30 <olsner> javascript is basically Self or Smalltalk in a C/Java syntax, and it has lexical closures.. so what's the problem? :P
05:24:37 <DRMacIver> tommyd: I'm aware of the article, and its point is valid. But making javascript work well is every bit as hard as its reputed to be. The language doesn't scale well to large code bases and the browser API is apalling.
05:25:07 <Jaggederest> browser API is the big problem
05:25:25 <notsmack> JS is way too dynamic for me
05:25:34 <DRMacIver> olsner: Language wise the major problems are that it's very hard to debug, has broken scoping rules, and it's too easy for other people to shoot you in the foot.
05:25:39 <tommyd> DRMacIver: after all there is no alternative browser language available (well, skip VB and all this crap), so at least for websites you have to stick with it
05:25:58 <tommyd> I don't think its useful anywhere else to actually use JS
05:26:01 <DRMacIver> tommyd: Sure. I'm not saying "Don't use Javascript". I even like the language (mostly). I'm just saying, its reputation as a bit of a nightmare is not undeserved. :)
05:26:19 <olsner> is it hard to debug because no-ones actually making good JS debuggers, or is there no JS debuggers because JS is hard to debug?
05:26:20 <tommyd> yeah, agreed
05:26:31 <notsmack> olsner: little of both
05:26:34 <tommyd> olsner: there is one debugger to my knowledge
05:26:42 <tommyd> but its slow and sometimes error-prone
05:26:49 <DRMacIver> There are a couple debuggers. The firebug debugger is quite reasonable.
05:26:54 <Jaggederest> JS has a full set of casts, for your explicitly static typed pleasure :)
05:26:58 <olsner> mozilla has venkman or what they call it, right?
05:27:03 <Apocalisp> I love firebug.
05:27:08 <DRMacIver> But there's no way to extract a stack trace out of the damn thing as far as I can tell. :)
05:27:17 <tommyd> oh, I didn't know Firebug... I only know Venkman
05:27:27 <Apocalisp> Firebug gives (cryptic) call stack traces.
05:27:40 <Jaggederest> I find myself debugging venkman in venkman, whenever I use it.
05:27:48 <tommyd> *L*
05:28:06 <Jaggederest> http://maps.jaggederest.com/
05:28:06 <olsner> debugging a debugger must make a confusing experience
05:28:07 <lambdabot> Title: Map Comparison Page
05:29:07 <Jaggederest> yes. It's not as brain-hurty as arrow notation or what have you, but... yeah, I'm glad I was getting paid for ti
05:29:19 <olsner> is that maps as in map f list, or maps as in graphical representations of extra-internet reality?
05:29:27 <Jaggederest> the latter
05:29:32 <osfameron> I could never get venkman to do anything interesting
05:29:37 <olsner> oh, and the page crashed my browser
05:29:39 <osfameron> firebug seems less powerful, but at least functional
05:30:39 <Jaggederest> yes, browser crashes are par for the course there... it's a property of the map toolkits :( don't play too well tegether
05:30:58 <Jaggederest> thus the relevance to JS debugging
05:31:56 <Jaggederest> firebug you use day to day, venkman is when trying to debug prototype or some such
05:33:07 <blackdog> javascript seems a bit naughty once you're used to haskell. it's like cheating on your wonderful wife with your slutty neighbour :)
05:33:24 <Jaggederest_> yep. night all :)
05:33:29 <olsner> someone should reinvent the web around a clean, orthogonal layout/content description language and a good scripting language with good API:s to the clean, orthogonal layout/content description
05:33:51 <passe> what does venkman have that firebug doesn't?
05:33:53 <blackdog> (am still feeling a bit wild after dynamically swapping the prototype of an object around to get a fairly trivial effect)
05:34:00 <passe> olsner, not gonna happen
05:34:01 <tommyd> blackdog: hehe =)
05:34:01 <blackdog> olsner: it's the panda principle
05:34:24 <olsner> panda principle?
05:34:29 <blackdog> js got in first, and the advantage of ubiquity means that even better technologies have no chance
05:34:33 <LeCamarade> blackdog: Panda Principle?
05:34:39 <blackdog> the panda has a piss-poor thumb
05:34:57 <blackdog> but it's good enough to stop other creatures muscling into the same ecological niche
05:34:57 <osfameron> nonsense, you just have to compile to a javscript virtual machine
05:35:05 <osfameron> google do it for java, so why not
05:35:18 <blackdog> because the code ends up kinda crap
05:35:24 <notsmack> osfameron: didn't yhc have something similar for haskell?
05:35:36 <blackdog> js is too dynamic to be a good compilation target
05:35:38 <passe> the web is going to keep evolving incrementally
05:35:39 <osfameron> notsmack: oooo, not heard of that
05:35:40 <LeCamarade> JS is good. Cross-browser quirks are what sucks.
05:35:46 <osfameron> yeah, JS is cute
05:35:59 <Apocalisp> aww
05:36:00 <notsmack> i've always thought the way to do it would be picking a subset of JS and making a good haskell DSL for it
05:36:05 <osfameron> it's the DOM and the implementations that are horrid
05:36:19 <LeCamarade> osfameron: The prob with GWT is Java. IMHO.
05:36:31 <LeCamarade> If it was more like ... Haskell. :o)
05:36:34 <blackdog> re panda principle: http://ozone.wordpress.com/2006/04/05/the-panda-principle/
05:36:35 <olsner> is GWT in Java or javascript?
05:36:36 <osfameron> LeCamarade: well, er, yeah, I'm not that keen on Java.  I just liked the concept.
05:36:36 <lambdabot> Title: The Panda Principle « Ozone
05:36:36 <notsmack> http://haskell.org/haskellwiki/Yhc/Javascript
05:36:38 <lambdabot> Title: Yhc/Javascript - HaskellWiki
05:36:45 <notsmack> olsner: it compiles java to javascript
05:36:53 <olsner> omgwtfbbq
05:37:03 <olsner> what a concept
05:37:06 <osfameron> and of course pugs has a javascript backend
05:37:17 <LeCamarade> osfameron: I had a similar thing boiling. It may come out sometime, although biggest chance is that it will stick here with me. :o(
05:37:36 <osfameron> :D
05:37:39 <LeCamarade> But not Java. I can't stand another for(;;) loop in my life.
05:37:53 <notsmack> LeCamarade: those are passe in java now, btw.
05:38:15 <blackdog> interesting article on GWT and the whole compiling-to-js approach:
05:38:17 <blackdog> http://www.ryandoherty.net/2007/04/29/why-google-web-toolkit-rots-your-brain/
05:38:21 <lambdabot> Title: RyanDoherty.net » Blog Archive » Why Google Web Toolkit Rots Your Brain, http://tinyurl.com/2p5wcm
05:38:28 <LeCamarade> notsmack: I should have said `destructive-update looping structures).
05:38:43 <LeCamarade> s/\)/\'/gi
05:38:48 <notsmack> LeCamarade: fair enough :-)
05:39:03 <olsner> for (;;) old-school C hackers.. while (1) or while (true) is the song of the times
05:39:07 <araujo> morning
05:39:27 <LeCamarade> blackdog: Pretty link, there.
05:40:01 <chrismbrown> I have a none haskell specific question here, is there a quick sed command I can use to remove those annoying ^M from windows files?
05:40:13 <LeCamarade> Oh, God. Some bugger I have caught piping to ghci with '-v0' flag on. As part of a shell command. Blasphemy.
05:40:14 <blackdog> dos2unix
05:40:30 <blackdog> oh, sorry. sed command.
05:40:58 <chrismbrown> blackdog: I originally thought dos2unix,but I don't have it on my mac system and just wanted something quick
05:41:01 <LeCamarade> Like: echo 'putStrLn "Salut, Monde!"' | ghci -v0
05:41:05 <LeCamarade> Evil.
05:41:22 * passe slaps notsmack around a bit with a large trout
05:42:04 <notsmack> passe: whoops!  should've looked harder for the accent key :)
05:42:06 <blackdog> there are a bunch of oneliners at http://sed.sourceforge.net/sed1line.txt
05:42:24 <olsner> there's some command line option to treat \n as a normal character instead of processing line-by-line.. I think.. then it should be a simple s/\r\n/\n/g .. I think ;-)
05:42:34 <olsner> or simply s/\r//g
05:43:05 <chrismbrown> great, thanks!
05:43:09 <notsmack> olsner: it probably doesn't treat \r as a newline anyway?
05:44:10 <olsner> if it's important to only change \r\n.. then again, that could be written s/\r$//g
05:45:15 <olsner> I am somewhat paranoid about those unix utilities, they tend to do strange things if fed the wrong incantations ;-)
05:45:51 <byorgey> olsner: well, they are Objects of Great Power, what do you expect? =)
05:46:58 <LeCamarade> blackdog: Nice, nice link. Nice to see someone who agrees with me so much, he's literally frothing at the mouth for me!
05:47:22 <blackdog> leCamarade: the GWT one? :)
05:47:34 <LeCamarade> While I still think Java is a very good language, I won't use it. I don't program like that anymore. Yes, the GWT one.
05:48:04 <chrismbrown> why doesn't windows just use the same protocol for an end of line as unix? grr.
05:48:36 <LeCamarade> Me, I will never be anti-Java. Java is very good. Just because Haskell is light-years ahead doesn't make Java bad. Okay, it does, depending. I just happen to have loved her (Java) once.
05:48:39 <dolio> How would you tell them apart if they didn't?
05:48:54 <LeCamarade> dolio: :oD LOL, LOL!!!
05:49:05 <tommyd> chrismbrown: without starting a line-ending flame war I guess Windows is still the nearest when it comes to standards
05:49:08 <blackdog> it's a strange idea, really - to me, compiling from Java to Javascript seems to be compiling from a less expressive language to a more expressive one
05:49:14 <byorgey> chrismbrown: I suspect a real answer to that question involves a graduate degree in history...
05:49:21 <chrismbrown> lol
05:50:09 <tommyd> after all what you normally want is a carriage return and a linefeed, thus two chars. old Mac and Linux/Unix just leave out one for purity (or whatever reasons)
05:50:11 <blackdog> LeCamarade: really? I find Java very difficult to love
05:50:11 <LeCamarade> blackdog: They should be shot. And you know the reason they gave for choosing Java?
05:50:14 <olsner> I would have to agree with the GWT design goal of removing the ugly "Web 1.9beta" mess as far away from me as possible, even though the way they've chosen seems far too enterprisey and WTF:y to take seriously
05:51:00 <Vq^> tommyd: normally? :)
05:51:16 <LeCamarade> blackdog: I was right off BASIC, at the time. ;o)
05:51:18 <byorgey> Vq^: what, you don't still use a typewriter?
05:51:20 <Vq^> tommyd: you're thinking of hardware implementing ascii?
05:51:38 <blackdog> LeCamarade: no, i missed that. i assume it was accessibility to the unwashed masses?:P
05:51:49 <tommyd> well, nowadays... I don't think writing bytes at particular positions on a console 80x25 screen matters anymore =)
05:52:05 <blackdog> olsner: sure, they just seem to be abstracting over the wrong part
05:52:12 <Vq^> byorgey: nah, i use stamps :o)
05:52:15 <olsner> let's see here... DOS comes from something like CP/M, right? did CP/M have CRLF, CR, LF, or some other control code?
05:52:41 <LeCamarade> They said 'twas for to get the benefits of the `tools' that had been built for Java. How can Google be encouraging brain-rot like that? Google? Aren't they supposed not to be evil?
05:52:46 <Vq^> and CP/M was inspired by UNIX
05:52:49 <blackdog> the things i'm finding most annoying about JS are things like minimal libraries, so everyone and his dog rolls his own slightly incompatible version
05:52:57 <tommyd> mail standard (rfc... I always forget the number) also has mandatory \r\n
05:53:02 <Vq^> but i would guess CP/M used CRLF
05:53:06 <chrismbrown> surely it just had something to do with the hardware these things ran on at the time perhaps?
05:53:07 <olsner> Windows NT, having VMS heritage, could have decided to have right file metadata describing the file format, and transcode everything to "the right format" - but I guess they went the DOS way just for fun
05:53:16 <LeCamarade> map, filter, take and lazy-eval would be the most important tools Java ever got. Not damn IDEs.
05:53:16 <olsner> right->rich
05:53:19 <blackdog> leCamarade: well.... the java tools _are_ preetty nice
05:53:22 <dolio> Wikipedia says CP/M used \r\n
05:53:32 <byorgey> LeCamarade: well, you can't get everything right...
05:53:35 <blackdog> i'd love to have intellisense for haskell
05:54:00 <blackdog> if you did it right, you could do intelligent type checking inside it, so you could only tab-complete values that typechecked
05:54:14 <blackdog> (or had some possibility of type-checking, anyway)
05:54:28 <LeCamarade> blackdog: Well, tools that tell me System.out.println takes a String? Is that sane? And Java doesn't even have a QuickTest yet (even if not IDE-integrated) and we still call those nice tools?
05:54:53 <blackdog> Haskell guys are language guys, so all our nice tools are language based
05:54:58 <blackdog> that shouldn't be surprising.
05:55:17 <blackdog> i'm just greedy, i'd like to have both.
05:55:41 * tommyd should leave this channel, far too interesting discussions and links are posted here, holding me back from learning haskell
05:55:52 <Vq^> tommyd: :)
05:56:06 <blackdog> if i'm writing a complicated fold, i'd quite like to have early feedback that i've stuffed something up
05:56:14 <chrismbrown> tommyd: have fun learning Haskell!
05:56:15 <osfameron> the Java IDEs are fantastic, they make programming in Java possible
05:56:25 <blackdog> osfameron: nicely put :)
05:56:39 <tommyd> rotfl
05:56:47 <tommyd> bah...
05:57:32 <osfameron> but actually, I really did like IDEA, it was unobtrusive, clever, smooth
05:57:41 <osfameron> (except for the occasional GC hang)
05:57:58 <LeCamarade> osfameron: You said it right. Java requires boilerplate, by design.
05:58:03 <LeCamarade> @quote java
05:58:03 <lambdabot> java says: public class Hello{ public static void main(String [] args){ System.out.println("Hello, World!"); } }
05:58:10 <LeCamarade> @quote java's
05:58:11 <lambdabot> dons says: Java's type system is unsuitable for young children, the elderly or infirm of constitution
05:58:18 <LeCamarade> Those two.
05:58:31 <edwinb> has anyone here used macports to install ghc/darcs/happy/etc... ?
05:59:02 <tommyd|away> edwinb: I used it for ghc
05:59:18 <byorgey> tommyd|away: hey, you're supposed to be learning Haskell! ;-)
05:59:28 <tommyd|away> (took some hours to compile, though)
05:59:37 <tommyd|away> byorgey: couldn't resist, dammit =)
05:59:56 <olsner> IDEA was just bloated and slow last time I tried it.. while eclipse is fast enough to compile your project in the amount of time it takes to move your hands off of Ctrl-S ;-)
06:00:11 <tommyd|away> well, I'm pretty bored here at work anyways, so having a good chat is not that bad
06:00:11 <edwinb> I'm getting an error I don't understand... 'Error: Unable to execute port: invalid command name "configure.cflags-append"'
06:00:27 <byorgey> tommyd|away: heh.  actually, #haskell is usually a very good place to learn Haskell, it just seems that people are talking about other things today =)
06:00:44 <tommyd|away> aha
06:00:52 <tommyd|away> will remember that =)
06:00:54 <olsner> edwinb: which port was that? I installed ghc and darcs without problems over here
06:01:28 <olsner> (and ditto the multiple-hour ghc compile time)
06:02:03 <tommyd|away> sadly, macports has the policy that every dependency has to be provided by macports as well
06:02:34 <tommyd|away> afaik there are native binaries for macs available for ghc, but any ghc-related macport still requires the ghc port
06:03:29 <edwinb> olsner: any one of ghc, darcs or happy
06:03:37 <edwinb> maybe it depends on something else...
06:04:34 <olsner> someone should macports-build a package and put it up for distribution (provided the generated packages register as installed in an existing macports system, which they should in a DTRT world)
06:07:52 <bringert> dcoutts: I want to have cabal run c2hs for me, but how do I tell it which header file to use? the normal cabal includes: doesn't seem to work
06:08:10 <dcoutts> bringert: get the latest cabal and it does
06:08:11 <bringert> dcoutts: or is there some directive I can put in the .chs file?
06:08:17 <bringert> ah, ok
06:08:24 <dcoutts> I fixed it recently
06:08:26 <tommyd|away> edwinb: usually just one port fails... look in your backlog what the most recent port was that macports handled
06:08:55 <dcoutts> bringert: the remaining thing to make c2hs work nicely with cabal is dependency analysis
06:09:09 <dcoutts> bringert: since .chs modules can {#import#} each other
06:11:44 <edwinb> hmm, everything else I need is in fink, so I may just get the ghc binary and install darcs and happy from source
06:12:10 <quicksilver> I really dislike source-based packages
06:12:17 <quicksilver> epsecially of slow-compiling things :)
06:12:46 * dmhouse installs most Haskell tools -- darcs, happy/alex, c2hs -- from source, to get the latest versions.
06:13:00 * LeCamarade loveth apt-get
06:13:23 <dmhouse> Well, apt doesn't have the latest versions. :)
06:13:26 <LeCamarade> Although I know I can't escape a compile of GHC, someday. And I'm gaining weight for the encounter.
06:13:45 <quicksilver> port install ghc <--- 8 hours. apt-get install ghc <--- 15 seconds.
06:13:48 <quicksilver> I know which I prefer.
06:14:05 <LeCamarade> dmhouse: I'm not scared of experimental and unstable, and I don't yet need [:Float:] yet, so apt serves the job. :o)
06:14:12 <quicksilver> (although having a 100M connection to a debian mirror helps)
06:14:39 <LeCamarade> quicksilver: Now you're bragging! :oD
06:14:43 <Baughn> I'd settle for a version of cabal-install that didn't require an incompatible version of cabal. -_-
06:15:12 <dmhouse> LeCamarade: [:Float:]?
06:15:25 <Lemmih> dmhouse: Happy floats.
06:15:55 * dmhouse throws Happy into a nearby pond to test that theory
06:15:58 <LeCamarade> Yeah. Some concurrency stuff. Still in HEAD, for now. Weird lecture SPJ gave in London.
06:16:14 <dmhouse> Lemmih: link?
06:16:27 <quicksilver> Lemmih: no, that's a Float being escorted to jail by two mad gorillas
06:16:28 <dcoutts> LeCamarade: parallelism, not concurrency
06:16:42 <dcoutts> nested data parallelism
06:16:46 <LeCamarade> dcoutts: My bad. :o)
06:16:51 <dmhouse> Err, I meant LeCamarade: link
06:17:02 <Lemmih> quicksilver: Oh, right.
06:18:28 <cdsmith> I've noticed this distinction between parallelism and concurrency recently.  Is it a Haskell-specific thing, or have I just been oblivious to the common meanings of these words for the last fifteen years?
06:19:07 <dcoutts> parallelism is about performance, concurrency isn't necessarily
06:19:21 <LeCamarade> dmhouse: Let me check about.
06:19:56 <LeCamarade> dmhouse: See: http://justtesting.tumblr.com/
06:19:59 <lambdabot> Title: Just Testing
06:20:01 <LeCamarade> Manuel's blog.
06:20:02 <ndm> @seen sorear
06:20:02 <lambdabot> I saw sorear leaving #happs, #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 8h 35m 6s ago, and .
06:20:09 <vegai> parallelism has become more important since multicore processors have become common, perhaps?
06:20:39 <cdsmith> dcoutts: okay.  So you're saying concurrency is the logical appearance of doing different things, while parallelism is the actual doing of separate things?
06:20:58 <dcoutts> concurrency is about a convenient style of programming to express certain problems, like serving multiple network clients
06:21:16 <quicksilver> might in actual fact things might be executed single threaded?
06:21:18 <dcoutts> concurrency needn't involve any parallelism :-)
06:21:30 <LeCamarade> Parallelism is a subset of concurrency.
06:21:35 <fasta> quicksilver: The behaviour we discussed yesterday(about ghci remembering expressions) is a bug.
06:21:45 <quicksilver> fasta: ah, ok :)
06:21:50 <quicksilver> fasta: I'm pleased :)
06:21:51 <cdsmith> dcoutts: hmm.  I see.
06:21:53 <roconnor> Coroutines!
06:22:11 <SamB_XP> fasta: ghci remembers expressions?
06:22:18 <cdsmith> dcoutts: I'd just never seen the words used in that way before the last month or so when I started looking into Haskell stuff.
06:22:32 <cdsmith> but that could just be a statement about me, rather than those words.
06:22:45 <fasta> SamB_XP: I didn't formulate very precisely now, since quicksilver knows what I mean.
06:23:00 <SamB_XP> fasta: of course
06:23:03 <blackdog> cdsmith: i think that's a fairly standard usage.
06:23:41 <fasta> SamB_XP: When it has (for example) computed a very large expression, evaluating the same expression with :set +r doesn't yield the same results w.r.t. trace messages.
06:23:42 <blackdog> it becomes more important in haskell because pure code offers chances for parallelism without rewriting
06:23:59 <fasta> SamB_XP: the +r feature is broken
06:24:00 <cdsmith> blackdog: okay, thanks
06:24:31 <SamB_XP> fasta: oh
06:25:01 <SamB_XP> I wonder if they did something on purpose that caused this by accident?
06:25:34 <fasta> SamB_XP: Simon declared it's a bug, so it's not on purpose :)
06:25:36 * SamB_XP laughs at xkcd
06:27:42 <olsner> reminds me of that dream where I was stuck in a monad
06:28:49 <fasta> Why doesn't 2 ^ (-1) work?
06:29:00 <fasta> > 2 ^ (-1)
06:29:02 <lambdabot>  Exception: Prelude.^: negative exponent
06:29:07 <fasta> > exp 2 (-1)
06:29:08 <lambdabot>   add an instance declaration for (Floating (a -> a1))
06:29:08 <lambdabot>     In the expression:...
06:29:08 <Pseudonym> ?type (^)
06:29:09 <Jaak> > 2 ** (-1)
06:29:11 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:29:12 <lambdabot>  0.5
06:29:21 <Pseudonym> ?type (^)
06:29:23 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:29:23 <Pseudonym> ?type (^^)
06:29:25 <Pseudonym> ?type (**)
06:29:26 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:29:27 <lambdabot> forall a. (Floating a) => a -> a -> a
06:29:30 <SamB_XP> fasta: oh, I definately agree that that is a bug
06:29:34 <Pseudonym> One ofr every occasion.
06:30:36 <fasta> SamB_XP: you mean the one featuring xkcd.com now?
06:30:40 <SamB_XP> > 2 ^^ (-1)
06:30:42 <lambdabot>  0.5
06:30:55 <SamB_XP> fasta: "Powers of One"
06:31:16 <SamB_XP> it help's that I've seen "Powers of Ten" ;-)
06:31:40 <fasta> SamB_XP: ok, since I didn't get the joke.
06:33:05 <fasta> http://www.jonhs.net/freemovies/powers_of_ten.htm
06:33:06 <lambdabot> Title: Free Movies & Documentaries - Powers of Ten (1977)
06:33:06 <tommyd|away> after showing that http://xkcd.org/c260.html to my girlfr^B^B wife she told me "why don't you do things like this for me!?"
06:33:08 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
06:33:51 <tommyd|away> "because I would be dead by now...?!" - stupid question
06:34:14 <SamB_XP> I'd say "hover the mouse over it"
06:38:26 <SamB_XP> oh great. someone is doing a presidential campaign on project wonderful?
06:43:39 <fasta> http://video.google.nl/videoplay?docid=7352118104883452737 <- impressive
06:43:41 <lambdabot> Title: Electric car vs Ferrari - Google Video
06:47:19 <dons> blackdog: yeah, xmonad's highly usable, at least for ion or dwm refugees
06:48:11 <SamB_XP> dons: "refugees"?
06:48:23 <SamB_XP> what happened to ion and dwm?
06:48:50 <dons> civil war?
06:48:53 <quicksilver> serious shelling from nearby wmii
06:49:10 <SamB_XP> oh.
06:49:13 <dons> "<arg> dwm is finished, only bugfixes and minor feature will be accepted"
06:49:32 <SamB_XP> wmii somehow told me exactly what kind of WM it must be, just from the name.
06:49:34 <dons> so , no xinerama support for you! :-) and tuomov is nuts. so .. ;)
06:49:37 <SamB_XP> how do you suppose that is?
06:52:21 <notsmack> he is nuts
06:54:51 <dolio> fasta: His time doesn't sound that impressive. I've heard of Corvettes doing better than 11s.
06:56:10 <tommyd|away> man, this fibonacci example from the haskell tutorial scares the shit out of me
06:56:17 <fasta> dolio: yes, I figured the cars weren't going as fast as they could do and that it would provide a biased view.
06:56:22 <notsmack> tommyd|away: which, zipWith?
06:56:45 <tommyd> the two-liner with zip and tail
06:56:46 <fasta> dolio: it's also the question what the top-speeds are of course.
06:56:52 <blackdog> dons: nice. i like the apple gui for some things, but half the time i just want a divided window with emacs and terminals :)
06:57:11 <fasta> dolio: a light car being faster on a small piece of road is not surprising.
06:57:11 <Baughn> tommyd: Remember, haskell doesn't have values; it has memoized, nullary functions.
06:57:32 <dons> blackdog: we've got at least one guy running the apple menu bar, with X fullscreen underneath.
06:57:38 <dons> so hmm, you could mix it up a bit?
06:58:02 <olsner> tommy: this one? fib = 1:1:[ a+b | (a,b) <- zip fib ( tail fib ) ]
06:58:06 <dolio> fasta: Yeah. Comparing a bare bones custom made car to one you could actually drive around in like the Ferrari isn't exactly unbiased. :)
06:58:14 <tommyd> olsner: yep
06:58:16 <dolio> fasta: Not that electric motors are bad or anything.
06:58:39 <tommyd> despite that its 0 : 1 : ...
06:58:48 <notsmack> tommyd: same result
06:59:05 <blackdog> Baughn: weird. i want to fight against that definition, but it's exactly right.
06:59:09 <tommyd> but to get to something like this I'd have to get to a whole new thinking
06:59:10 <notsmack> (close enough, i meant; not equivalent)
06:59:23 <olsner> I don't think fibonacci ever made 0 rabbits breed with 1 rabbit
06:59:49 <notsmack> tommyd: do you see how it works?
07:00:28 <tommyd> hrm... I'm used to the "concept" of not being able to use an expression right-side, as long as its not completly defined
07:01:04 <tommyd> I understood that the list is initally only [0, 1] and gets expanded on use
07:01:12 <tommyd> but, ugh =)
07:01:13 <Baughn> blackdog: Well, not really. It's more correct to say that values are defined to be memoized, nullary functions in haskell.
07:01:23 <Baughn> tommyd: You should look at fix sometime. ;)
07:01:25 <Baughn> @src fix
07:01:25 <lambdabot> fix f = let x = f x in x
07:01:38 <osfameron> eeeeeeek!
07:01:57 <tommyd> Baughn: what does that?
07:02:15 <tommyd> (whats the "in" operator?"
07:02:17 <tommyd> )
07:02:18 <Baughn> tommyd: It.. *mumble-mumble* finds the fixed point of a function
07:02:26 <Baughn> > let x = 4 in x
07:02:27 <lambdabot>  4
07:02:31 <Baughn> > fix (const 4)
07:02:32 <lambdabot>  4
07:02:54 <notsmack> > fix ((1:) . scanl (+) 1)
07:02:56 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
07:03:01 <osfameron> Baughn: you are a bad man
07:03:26 <quicksilver> tommyd: 'fix' encapsulates the power of recursion
07:03:27 <Baughn> osfameron: Drawing from personal experience, once you vaguely understand fix, everything else seems simple
07:03:45 <osfameron> Baughn: yeah, but let the poor guy understand "in" first
07:03:51 <olsner> tommyd: the use of fib in fib is the same as in other languages where functions can call themselves.. just that haskell allows otherwise infinite recursions to stop at the point where the continued result isn't needed
07:03:54 <quicksilver> tommyd: if you understand recursive functions and definition, fix is just a 'name' for that
07:04:02 <Saizan> well, fix f = f (fix f)
07:04:03 <osfameron> "fix" confused the hell out of me and made me incredibly bad tempered
07:04:13 <Baughn> osfameron: He already did. I just had to point out which already-existing mental structure he should use on it.
07:04:22 <osfameron> now that I vaguely understand it, I still feel bad tempered, and wished I'd left it till later to worry about it :-)
07:04:56 <tommyd> you all should better not assume what I've already understood ... its not that much :P
07:05:11 <olsner> I believe the usefulness of fix extends about as far as allowing #haskell to confuse newbies
07:05:20 <tommyd> back to the fibonacci thing
07:05:24 <olsner> at least that's the only use of it I've seen so far ;-)
07:05:26 <Baughn> Let's call it a rite of passage
07:05:26 <allbery_b> heh
07:05:30 <pejo> Baughn, call-by-need lambda calculus has values, doesn't Haskell's values coincide with those?
07:05:40 * allbery_b has seen real uses for it, but it's best considered an advanced technique
07:05:53 <fasta> olsner: the common idiom of using "loop" can be replaced with fix.
07:06:01 * desp is wrestling with layout
07:06:07 <bringert> dcoutts: c2hs seems to think that wchar_t is CInt, any tips?
07:06:17 <Baughn> pejo: It does, but they aren't the same kind of values as in eg. c. I was assuming he was more familiar with C than lambda calculus.
07:06:24 <notsmack> tommyd: you can follow through the expansion of that list by hand, you'll see it always has enough data to get the next element
07:06:26 <olsner> loop? is that a haskell construct I am not familiar with?
07:06:31 <dcoutts> bringert: that's probably because it's typedefed to be an int
07:06:35 <olsner> or are you just talking about loops in general?
07:06:43 <bringert> dcoutts: can I do anythign about that?
07:06:46 <osfameron> but you can only follow through the expansion if you already understand lazy evaluation...
07:06:50 <osfameron> it makes no sense otherwise
07:07:10 <desp> http://pastie.textmate.org/66857 -- any ideas why the inner 'do' isn't recognized correctly? ghc says "The last statement in a 'do' construct must be an expression". when I change the inner 'do' to non-layout style, it typechecks.
07:07:10 <dcoutts> bringert: we're considering baking in a bunch of typedefs and mapping them to Haskell types other than what they typedefs ultimately define them as
07:07:12 <lambdabot> Title: #66857 - Pastie
07:07:38 <dcoutts> bringert: so for the moment there's not much you can do
07:07:48 <tommyd> wrt fibs: I think I understood that [ a + b | (a, b) <- zip someListGeneratingFunction ] does add tupels (Int,Int) together coming from someListGeneratingFunction and appends it to the list
07:07:50 <dcoutts> bringert: except use conversions on the Haskell side
07:08:25 <bringert> hmm, maybe it's easier to just use plain foreign imports
07:08:27 <Baughn> tommyd: It does. zipWith (+) might or might not be more understandable; it does the same thing.
07:08:29 <roconnor> I like this spiraling window layout for xmonad.  One should make they spiral infinite.
07:08:48 <roconnor> then add rotate option to rotate the windows through the infinite spiral
07:08:53 <notsmack> tommyd: yeah, that's a list comprehension, which is designed to look like set builder notation.  They're a bit clearer once you understand monads, but it mostly works like you'd expect.
07:09:35 <olsner> with an infinite number of windows, you don't have to write any code, just find the window where it is already written!
07:10:09 <tommyd> what I don't understand is why "fibs (tail fibs)" just returns those new tupel it needs, since fibs should return the complete list so far, no?
07:10:11 <tommyd> fibs = 0 : 1 : [ a + b | (a, b) <- zip fibs (tail fibs)]
07:10:15 <Baughn> olsner: I want to contradict that, but I think you're right
07:10:16 <Saizan> tommyd: you need to give zip 2 lists
07:10:25 <olsner> notsmack: huh? where do monads touch on list comprehensions?
07:10:40 <roconnor> olsner: I was thinking of a cycle of window, but your idea isn't bad.
07:10:52 <notsmack> olsner: list comprehensions can be desugared to list monad code
07:11:17 <notsmack> tommyd: think about it this way
07:11:24 <Saizan> olsner: there were monad comprehensions in earlier versions of haskell :)
07:11:27 <tommyd> i.e. isn't the return value of fibs always the complete list?
07:11:43 <Baughn> > let fibs = 0 : 1 : (do (a, b) <- zip fibs (tail fibs); return (a+b)) in fibs
07:11:45 <lambdabot>  [0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,...
07:11:48 <shachaf> tommyd: fibs and (tail fibs) are the arguments to zip
07:11:49 <olsner> yeees, I see.. (do (a,b) <- zip ...; return a+b), right?
07:11:52 <notsmack> the first element of fibs and (tail fibs) go into making the second '1', and then they're no longer in the generator after 0:1:1:, it starts with the next pair
07:12:19 <tommyd> shachaf: ahh... dammit... you're right
07:12:27 <tommyd> this looked for me like a function call
07:12:37 <dcoutts> [ expr x y | x <- xs, y <- ys, condition x ] = do { x <- xs; y <- ys; guard (condition x); return (expr x y) }
07:12:48 <quicksilver> the key is to recognise that haskel funnctions can "return" before they're "finished"
07:12:55 <quicksilver> so the 0,1 are returned already
07:13:05 <quicksilver> and can be 'fed back' into the later occurences of fibs
07:13:27 <Saizan> or that lazy evaluation is outermost-first
07:13:28 <notsmack> quicksilver: hmm, i already understood it and that confused me.
07:13:56 <quicksilver> notsmack: then ignore what I said :)
07:14:02 <quicksilver> notsmack: there is more than one way to understnad it
07:14:39 <Baughn> tommyd: Think of the list "fibs" as a nullary function. More importantly, think of each separate tail of the list as a nullary function.
07:15:05 <Baughn> tommyd: When you evaluate the first element, you get the first element plus a function that, if evaluated, will give you the second element plus a... you get the idea.
07:15:05 <tommyd> Baughn: whats a "nullary function"?
07:15:07 <edwinb> olsner, tommyd: I fixed my macports problem. The problem was that I didn't RTFM.
07:15:12 <Baughn> tommyd: A function that takes no arguments
07:15:13 * edwinb shuffles away quietly
07:15:31 <tommyd> Baughn: the tutorial states that this is a "constant function"...
07:15:41 * notsmack points at what Baughn just said about an element plus a function
07:15:45 <Baughn> tommyd: Nullary function == constant function
07:15:48 <tommyd> ok
07:16:22 <notsmack> > [1..]
07:16:24 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
07:16:24 <Baughn> tommyd: The point is, no more is evaluated than actually is needed at the moment; the rest of the list exists in potentia, as a function.
07:16:33 <Baughn> tommyd: This is very important, seeing as the list is infinite
07:16:48 <tommyd> I think I understood that
07:16:58 <notsmack> tommyd: the way that expands is basically:  [1..], [1,2..], [1,2,3..], etc.  the same concept applies for your fibs definition
07:17:22 <quicksilver> you can imagine the reductions like this, i fyou like:
07:17:25 <quicksilver> fibs = <code>
07:17:26 <notsmack> it only evaluates the parts it needs to, adjusting the code to get the rest internally
07:17:30 <quicksilver> fibs = 0 : <code>
07:17:31 <tommyd> what I don't get right now is, why the result is not  [0, 1, 0, 1, 2, 0, 1, 3, 0, 1, 2, 3, 5, ...]
07:17:39 <quicksilver> fibes = 0 : 1 : 1 : <code>
07:17:50 <quicksilver> whenevever another ewlement is demanded it executes a 'bit' of the code
07:18:03 <quicksilver> and leaves the rest as an unevaluate lump of code, called a 'thunk'
07:18:16 <tommyd> ie. zips always goes over the complete (current) return value of fibs, not?
07:18:23 <tommyd> s/zips/zip/
07:18:26 <notsmack> tommyd: there's only one call to zip.
07:18:40 <notsmack> tommyd: that comprehension you're looking at is only run once
07:18:59 <tommyd> notsmack: doesn't it run recursivly?
07:19:03 <notsmack> it's using previously calculated values to fill in the current ones
07:19:10 <Baughn> tommyd: Calls are also only evaluated up to the point it needs to be. Ask for the 4th element of the list, and zip will stop after getting to that.
07:19:11 <notsmack> it's a recursive definition, not a recursive function
07:19:58 <Baughn> Haskell doesn't precisely have recursion the way you're used to - tail-recursion optimization is often a waste of time, or even impossible. That's a later lesson, though.
07:19:59 <osfameron> @src zip
07:19:59 <lambdabot> zip (a:as) (b:bs) = (a,b) : zip as bs
07:19:59 <lambdabot> zip _      _      = []
07:20:06 <osfameron> that looks recursive to me
07:20:07 <desp> no love for me and my layout problem?
07:20:09 <desp> :(
07:20:52 <Baughn> osfameron: That's the definition you're looking at, and it is indeed recursive
07:20:53 <quicksilver> desp: what layout problem?
07:20:58 <desp> http://pastie.textmate.org/66857 -- any ideas why the inner 'do' isn't recognized correctly? ghc says "The last statement in a 'do' construct must be an expression". when I change the inner 'do' to non-layout style, it typechecks.
07:20:59 <lambdabot> Title: #66857 - Pastie
07:21:34 <quicksilver> desp: using tabs, perhaps?
07:21:44 <desp> oh.
07:22:04 <osfameron> Baughn: the distinction between "recursive function" and "recursive definition" is too subtle for me
07:22:14 <Baughn> osfameron: Definition: source code. Function: code.
07:22:15 <desp> quicksilver: so tabs won't work? or do they need to be equal to a specific number of spaces?
07:22:25 <cdsmith> desp: 8 spaces
07:22:34 <Baughn> osfameron: The source goes through something that looks an awful lot like a CPS transformation while being compiled
07:22:34 <desp> quicksilver, cdsmith: thank you
07:22:45 <quicksilver> desp: don't use tabs
07:22:54 <quicksilver> desp: just don't, you will go mad :)
07:23:00 <osfameron> Baughn: oh, right, implementation details.  I'm not going to worry about those till I learn the language :-D
07:23:56 <tommyd> hrmm... as a haskell developer, do I have similar headaches to understand already written code each time?
07:24:11 <Baughn> tommyd: It becomes second nature after a while
07:24:12 <desp> quicksilver: indeed, 8-space tabs... no way
07:24:16 <tommyd> other: how long does it take until "haskell thinking" drops in?
07:24:17 <notsmack> tommyd: when that zip gets called, it's output is [(0,1), (1,x), (x,x)...];  on the recursive step the (0,1) has been dropped off and it's working with the (1,x) tuple, if you want to think of it that way
07:24:27 <quicksilver> desp: that looks suspiciously like an implementation of my HTTP api suggestion :)
07:24:30 <notsmack> tommyd: no, and it depends
07:24:51 <desp> quicksilver: oh, so it's you. :)
07:25:27 <desp> quicksilver: indeed; I was glad to see someone else suggest the same thing I had in mind :)
07:25:37 <Baughn> tommyd: As a rule of thumb, if there is any conceivable way that the code you're writing could possibly be evaluated without going into loops or wasting memory, it will be. Just have faith.
07:25:47 <Baughn> tommyd: It's a very bad rule of thumb, but it will suffice for now. ;)
07:27:01 <cdsmith> Baughn: hrmm.  I just went through a lot of confusion unlearning *that* rule of thumb.
07:27:34 <Baughn> It's only meant to be a stopgap measure. I can see how it could cause trouble..
07:27:55 <notsmack> > [ a+b | (a,b) <- zip [0,1,1,2,3,5] [1,1,2,3,5,8]]
07:27:57 <lambdabot>  [1,2,3,5,8,13]
07:28:05 <cdsmith> Baughn: I agree.  I just had to gripe.
07:28:11 <notsmack> > 0:1:[1,2,3,5,8,13]
07:28:12 <lambdabot>  [0,1,1,2,3,5,8,13]
07:28:42 <Baughn> zipWith (/) (repeat 1) [1..]
07:28:50 <Baughn> > zipWith (/) (repeat 1) [1..]
07:28:51 <lambdabot>  [1.0,0.5,0.3333333333333333,0.25,0.2,0.16666666666666666,0.14285714285714285...
07:29:13 <tommyd> notsmack: this is exactly (> [ a+b | (a,b) <- zip [0,1,1,2,3,5] [1,1,2,3,5,8]]) what I don't get in my head right now
07:29:53 <tommyd> I know how this builds a nicely list
07:30:00 <dolio> > zip [0, 1, 1, 2, 3, 5] [1, 1, 2, 3, 5, 8]
07:30:01 <lambdabot>  [(0,1),(1,1),(1,2),(2,3),(3,5),(5,8)]
07:30:02 <notsmack> tommyd: alright.  does that make sense if you forget the recursion?
07:30:04 <Jaak> > (iterate (\x -> x / 2 + 1 / x) 1) !! 100
07:30:05 <lambdabot>  1.4142135623730951
07:30:12 <Jaak> > sqrt 2
07:30:13 <lambdabot>  1.4142135623730951
07:30:24 <osfameron> tommyd: how long have you been learning haskell ?
07:30:46 <tommyd> but I don't get the fact that it doesn't start with creating the first tuples over and over again on each call/execution for another (not yet existing) entry
07:30:54 <tommyd> osfameron: only today
07:30:57 <osfameron> er
07:31:02 <osfameron> tommyd++
07:31:06 <notsmack> tommyd: alright, just a simple misunderstanding of list comprehensions
07:31:12 <osfameron> tommyd: you're braver than me, and I think those examples are over complicated
07:31:16 <notsmack> [ a | a <- [1,2,3] ]
07:31:17 <notsmack> > [ a | a <- [1,2,3] ]
07:31:18 <osfameron> list comprehensions are not day 1 material
07:31:19 <lambdabot>  [1,2,3]
07:31:24 <osfameron> zip is not day 1 material
07:31:26 <tommyd> osfameron: hehe =)
07:31:36 <osfameron> higher order operators (>) are not day 1 material
07:31:37 <notsmack> osfameron: i'd say zip is, but the comprehension seems excessive to me
07:31:41 <osfameron> guys, reality check?
07:32:03 <osfameron> zip is potentially, at the end of a long day, or if you've done a bit of FP before
07:32:20 <fasta> tommyd: how much programming experience do you have?
07:32:40 <tommyd> fasta: hrm... I don't think that counts... I'm not a pro in any language
07:32:56 <tommyd> started with Pascal in 1997 at school =)
07:33:02 <notsmack> > [ a+b | (a,b) <- [(0,1), (1,1), (1,2), (2,3)] ]
07:33:03 <lambdabot>  [1,2,3,5]
07:33:09 <fasta> tommyd: then I'd be surprised if you'd fully understand the fibs example after one day.
07:33:25 <notsmack> bah, he's almost there
07:33:41 <fasta> notsmack: with help, sure.
07:33:41 <tommyd> notsmack: so far, so good... understood that
07:34:09 <tommyd> its not my aim to understand everything and all, but this fibs thing makes me *ugh*
07:34:26 <tommyd> won't sleep tonight unless I get it =P
07:34:28 <notsmack> tommyd: well that's all we're doing in this expansion
07:34:50 <notsmack> the tricky part is the lazyness:  all of those tuples except (0,1) don't exist yet when we go to get the third element
07:34:55 <notsmack> but we don't need them, so who cares?
07:35:16 <tommyd> notsmack: I can see this going for a first call, ala > fib || 10
07:35:38 <notsmack> || ?
07:35:47 <tommyd> now, a second call to it like > fib || 20 has to build the elements 11 to 20, right?
07:35:52 <tommyd> oh, sorry, !, not |
07:36:02 <notsmack> tommyd: ah, yeah
07:36:24 <osfameron> tommyd: I would recommend using a nice tutorial - there's YAHT online, or I'm personally working through "Haskell School of Expression", they build up to that kind of thing a bit more gently
07:36:36 <notsmack> osfameron: he hit this example in a tutorial.
07:36:45 <osfameron> eeeeeeek!
07:36:54 <notsmack> tommyd: on the second call it already has the first 10 elements stored, right?
07:37:22 <tommyd> so, for the eleventh element it takes zip [ ... elements 1 - 10 ... ] [ ... elements 2 - 10 ... ]
07:37:28 <notsmack> and appended to that is a "thunk" that knows how to generate the 11th on.  that thunk isn't the same list comprehension, because part of it has been removed off the front
07:37:33 <tommyd> notsmack: right, the first 10 are stored
07:37:38 <fasta> CosmicRay: will the book also contain a chapter on references or is it only about functional programming?
07:38:08 <CosmicRay> fasta: I plan to talk about MVars.  I don't know that we're going to cover IORefs
07:38:18 <CosmicRay> they're basically a less-useful version of an MVar
07:38:39 <tommyd> notsmack: huh? "part of the list has been removed off the front"?
07:38:53 <tommyd> this is what I was wondering! how / where does that happen?
07:38:59 <fasta> CosmicRay: are STRefs also a less-useful version of MVars? AFAIK, they are for different purposes.
07:39:10 <notsmack> tommyd: automatically.  you don't need to worry about it.  :-)
07:39:12 <CosmicRay> I'm not sure if we're planning to cover STRefs
07:39:34 <byorgey> tommyd: it's not really that part of the list has been removed, only that it has already been calculated
07:39:42 <tommyd> umm... this is not satifying
07:39:49 <byorgey> tommyd: there's a nice illustration of what's going on if you scroll all the way to the bottom of http://en.literateprograms.org/Fibonacci_numbers_(Haskell)
07:39:50 <tommyd> satisfying, sorry
07:39:51 <lambdabot> Title: Fibonacci numbers (Haskell - LiteratePrograms
07:40:03 <dcoutts> CosmicRay: you're not covering the ST monad iirc so there's no point talking about STRefs
07:40:31 <tommyd> byorgey: will have a look into that
07:40:33 <notsmack> byorgey: ah, great visual
07:40:52 <byorgey> tommyd: the beginning of the list is still there, it's just that zipWith is done looking at it
07:40:54 <notsmack> tommyd: that uses zipWith instead of the list comprehension, but the idea is exactly the same
07:42:18 <quicksilver> it's actually  harder to understand, with the list comp, in my opinion
07:42:23 <quicksilver> because you can't "unfold" a list comp
07:42:25 <notsmack> quicksilver: i absolutely agree.
07:42:31 <quicksilver> you can look at the recursive definition of zipWith
07:42:36 <quicksilver> and thus see how the "unfolding" happens
07:42:43 <fasta> tommyd: you want to see the graph-reductions unfold before you?
07:42:44 <notsmack> @src zipWith
07:42:44 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
07:42:45 <lambdabot> zipWith _ _      _      = []
07:43:05 <fasta> tommyd: I think Hat or GHood or whatever it's called can do that for Haskell 98 code.
07:43:36 <tommyd> fasta: you mean this will give me the actual reduction steps?
07:44:03 <malcolmw> in particular, the hat-anim tool animates the reduction steps
07:44:05 <fasta> tommyd: I believe so, although I myself have never seen it in those tools, since I required more than Haskll 98.
07:44:21 <fasta> Hmm, oh no, I did use it once.
07:44:30 <fasta> foldr and foldl worked, IIRC.
07:44:37 <fasta> I didn't test more.
07:44:47 <fasta> Something Java based, IIRC.
07:44:48 <byorgey> malcolmw: that's pretty spiffy, I didn't know about that!
07:45:20 <notsmack> somebody should post an animation of the zipWith fibonacci to help when this is being discussed in here
07:45:25 <gour> @seen dons
07:45:26 <lambdabot> dons is in #rwh, #ghc, #haskell-overflow, #xmonad, #haskell-soc and #haskell. I last heard dons speak 14s ago.
07:45:36 <fasta> tommyd: that sounds like a good job for you.
07:45:55 <gour> dons: why don't you add another author to the book project so we can have a Haskell's Gang of Four?
07:46:02 <malcolmw> but beware that Prelude definitions (e.g. foldr) are trusted in Hat, so their animation doesn't appear in the trace.  You have to define it again in your own code, if you want to see the internals
07:46:20 <malcolmw> gour: what's wrong with a Holy Trinity?
07:46:35 <gour> malcolmw: too religious ;)
07:46:39 <fasta> gour: more authors don't necessarily make the book better.
07:46:41 <tommyd> where is hat-anim included?
07:46:50 <fasta> @google hat haskell
07:46:52 <lambdabot> http://www.haskell.org/hat/
07:46:52 <lambdabot> Title: Hat - the Haskell Tracer
07:46:54 <malcolmw> gour: Haskell troika then
07:47:10 <gour> malcolmw: (peres)troika :-)
07:47:30 <malcolmw> gour: the Triad
07:48:30 <cdsmith> http://en.wikipedia.org/wiki/Triad says Triad is a name for many branches of Chinese underground criminal organizations. :(  I liked Troika.
07:48:31 <lambdabot> Title: Triad - Wikipedia, the free encyclopedia
07:48:39 <gour> fasta: right, but the books looks to be bulky, so more authors can write it sooner
07:48:58 <quicksilver> not necessarily
07:49:05 <quicksilver> that sounds like a mythical man-month argument :)
07:49:51 <gour> :-)
07:52:14 <fasta> IMO, a book containing only FP, is not worth that much. There are probably at least 10 books on that subject alone. A useful book would only contain type class hackery, GADTs, non-trivial uses of ST, concurrency (e.g. the GPLib problem is somewhat nice), an implementation of an interpreter for Haskell, cool drawings of graph-reductions, something about using Haskell with FPGAs and those kinds of things :)
07:52:22 <notsmack> i know i gave up last time i tried to get hat working, so sending tommyd to it may be a bad idea...
07:52:34 <fasta> notsmack: I got it to work
07:52:38 <quicksilver> malcolmw: is there a 'screenshot' (transcript) of hat-anim usage anywhere? couldn't locate one
07:52:41 <ndm> fasta: sounds like a book of things you can gurantee will stop working as soon as its published
07:52:54 <quicksilver> fasta: that is a false dichotomy; most of the things are that list are FP.
07:52:59 <notsmack> fasta: cool, ignore that then
07:53:13 <malcolmw> quicksilver: i'm trying to create one now
07:53:24 <quicksilver> malcolmw: ah, excellent!
07:53:25 <fasta> quicksilver: Ok, I meant textbook FP.
07:53:40 <fasta> quicksilver: most textbooks contain the information other textbooks already contain.
07:53:43 <quicksilver> fasta: the book is to be about solving real problems in haskell
07:53:54 <quicksilver> fasta: that sounds like something which most textbooks don't have
07:53:57 <fasta> quicksilver: yes, and real problems often include e.g. ST.
07:54:24 <tommyd> bah... ".../hmake-3.13/lib/ix86-Linux/config:9: *** missing separator.
07:54:29 <fasta> quicksilver: Allmost all interesting problems require the use of ST sooner or later.
07:54:47 <quicksilver> fasta: I don't agree with that claim.
07:54:53 <quicksilver> (you've made it before)
07:54:53 <fasta> quicksilver: unless Turner and roconner are right.
07:55:22 <malcolmw> tommyd: oops, broken ghc-version detection I'm afraid
07:55:28 <quicksilver> but arguably, writing about STArrays is boring: there are loads of books written about algorithms with mutable arrays
07:55:39 <fasta> quicksilver: which they might be, but the algorithms wouldn't be the same anymore and would require some kind of almost manual memory management to reach the same complexity bounds.
07:55:39 * quicksilver shrugs
07:55:39 <tommyd> malcolmw: I have 6.6.1
07:55:57 <quicksilver> fasta: however many interesting programs fail to be CPU or memory bound
07:56:14 <fasta> quicksilver: ?
07:56:17 <tommyd> shall I replace 606 by 60601 in config?
07:56:29 <quicksilver> if you're not CPU or memory bound, then it doesn't matter if the complexity isn't optimal
07:56:42 <tommyd> (quick shot)
07:56:59 <malcolmw> tommyd: no, you need to delete any junk surrounding the 606 e.g. {-# line 1 "ghcsym.hs" #-}
07:57:06 <fasta> quicksilver: I don't find reading a file or serving webpages interesting, if that's what you mena.
07:57:10 <fasta> quicksilver: mean
07:57:25 <fasta> quicksilver: can you name something that requires thought?
07:57:38 <roconnor> fasta: I'm sure that ST make programs faster in practice
07:57:40 <malcolmw> beelsebob about?
07:57:49 <tommyd> malcolmw: what should this look like? http://pastebin.ca/528346
07:57:55 <quicksilver> fasta: all the programs currently running on my computer
07:58:00 <fasta> roconnor: I don't mean in practice, I mean in theory.
07:58:04 <quicksilver> fasta: text editors, email readers, web browsers
07:58:13 <quicksilver> fasta: web servers
07:58:16 <malcolmw> tommyd: GHCSYM=606, all on one line
07:58:22 <tommyd> ah, ok
07:58:28 <fasta> quicksilver: writing a text editor without using ST will probably be slow.
07:58:37 <tommyd> (I had the same problem with hat before, but thought this is because I was missing hmake)
07:58:54 <malcolmw> tommyd: you might need to fix one other place where the same thing happens - targets/.../ghcsym file
07:58:56 <roconnor> fasta: oh, I thought we were talking about real programming.
07:59:08 <roconnor> anyhow yes :)
07:59:29 <fasta> roconnor: ? Then you don't agree with Turner?
07:59:49 <tommyd> malcolmw: yep, that works... thanks!
08:00:00 <roconnor> fasta: I agree with Turner.
08:00:07 <quicksilver> fasta: algorithmic complexity is a fascinating subject and great algorithms are beautiful and elegant
08:00:20 <quicksilver> fasta: in many practical problems another factor of (log n) is quite acceptable
08:00:39 <quicksilver> fasta: (and the typical cost of a naive translation to functional structures is another (log n) or so)
08:00:45 <roconnor> fasta: I also agree that writing a text editor without using ST will probably be slow.
08:00:47 <malcolmw> tommyd: (you'll get the same problem, with the same fix, when installing Hat, assuming you are currently installing hmake)
08:00:51 <roconnor> slow in practice
08:01:25 <tommyd> malcolmw: yep, fixed that already
08:01:34 <sjanssen> I think you could do a reasonably fast text editor in a purely functional setting
08:01:44 <tommyd> I'm getting some warnings during the hat compilation, but nevertheless it seems to work
08:02:09 <tommyd> (not only some, but quite a bunch)
08:02:12 <quicksilver> fasta: in any case, I strongly suspect they'll cover some mutable state in the GUI chapter
08:02:17 <quicksilver> fasta: but who knows :)
08:02:23 <malcolmw> tommyd: there will be plenty of warnings, mainly due to deprecated library modules
08:02:43 <sjanssen> you can write a data structure that is all O(1) operations at the pointer, with O(log n) to seek
08:02:54 * malcolmw is finding that hat-anim seems to be broken currently
08:03:13 <tommyd> is hat-anim part of hat? the hat site doesn't list it
08:03:22 <fasta> sjanssen: you mean a zipper?
08:03:32 <malcolmw> tommyd: yep - it should be listed somewhere
08:03:32 <sjanssen> fasta: yeah, with FingerTrees for left and right
08:03:45 <fasta> sjanssen: yes, I wrote one
08:03:50 <fasta> sjanssen: (not based on FingerTrees)
08:04:07 <tommyd> malcolmw: it lists Hat-observe, Hat-trail, Hat-explore, Hat-stack and Hat-detect
08:04:10 <sjanssen> fasta: but with some sort of tree structure for left and right?
08:04:15 <malcolmw> tommyd: there it is, under "user-guides"
08:04:36 <tommyd> ah, nice...
08:04:38 <fasta> sjanssen: no, that's not necessary.
08:04:49 <sjanssen> fasta: FingerTrees are really handy because of their O(1) append properties
08:04:50 <fasta> sjanssen: I am talking about amortized complexity here, btw.
08:05:03 <sjanssen> fasta: how do you get seeking in O(log n)?
08:05:28 <fasta> sjanssen: AFAIK, splay trees have that property.
08:05:44 <sjanssen> right, some sort of tree structure :)
08:05:53 <osfameron> enfilades!
08:06:04 <fasta> sjanssen: oh, I thought some special tree structure.
08:06:04 <osfameron> or K-trees, or whatever they're really called
08:06:14 <fasta> osfameron: K-trees?
08:06:18 <quicksilver> osfameron: enchiladas, I believe
08:06:22 <quicksilver> (or is that something else?)
08:06:27 <fasta> osfameron: the original authors don't call them like that.
08:06:32 <osfameron> fasta: er, well, whatever the crazy Xanadu people called them
08:06:34 <olsner> "enchiladas"?
08:06:42 <sjanssen> a (size annotated) splay tree is another good idea for a text editor
08:06:54 <osfameron> but they referenced some other work which was like a POOMfilade, I think it was K-tree, but can't remember
08:08:18 <fasta> sjanssen: splay trees have not very good concurrency properties, so I heard.
08:08:50 <sjanssen> fasta: that's okay for a text editor, probably
08:08:55 <SamB_XP> fasta: they have concurrency properties?
08:08:59 <fasta> sjanssen: yes, probably.
08:09:06 <SamB_XP> sjanssen: what if you have two views on different parts of a file?
08:09:20 <CosmicRay> arjanoosting: will you be able to upload a new filepath, ready for ghc 6.6.1, soon?
08:09:43 <fasta> sjanssen: well, actually, until I write a text-editor myself (which I hope will never happen), I don't know :)
08:09:48 <Igloo> CosmicRay: 6.6.1 includes filepath
08:09:55 <CosmicRay> ah.
08:10:05 <CosmicRay> so I need to drop all deps on libghc6-filepath-dev?
08:10:06 <sjanssen> SamB_XP: you can probably serialize insertions -- you might have two views, but only one active cursor
08:10:23 <SamB_XP> sjanssen: um, just looking at splay trees is supposed to change them ;-)
08:10:40 <osfameron> very quantum :-)
08:10:41 <Igloo> CosmicRay: No, you should keep them, but the buildds, pbuilder etc might not work until the package is removed
08:10:52 <CosmicRay> err, why would I keep them then?
08:11:08 <osfameron> splay trees are supposed to have bad performance when you run lookups from [0..end]
08:11:08 <Igloo> Because that's the Right Thing to do
08:11:16 <CosmicRay> or should they be something like ghc6 (>= 6.6.1) | libghc6-filepath-dev
08:11:27 <osfameron> which might be something you'd do regularly in an editor
08:11:30 <sjanssen> yeah, splay trees probably suck for an editor
08:11:41 <CosmicRay> Igloo: I dunno, that seems to be maintaining useless cruft to me
08:11:45 <SamB_XP> figure out how zipperfs works
08:11:46 <sjanssen> 'twas a fun idea while it lasted
08:11:48 <SamB_XP> use that ;-)
08:11:51 <osfameron> though possibly splay tree + zipper ?
08:11:55 <SamB_XP> (how it works, I mean)
08:12:19 <Igloo> CosmicRay: But it should be automatically generated  :-)
08:12:25 <sjanssen> meh, FingerTrees are likely better anyway
08:12:32 <fasta> osfameron: ?
08:12:39 <fasta> osfameron: where do you get that nonsense?
08:12:40 <CosmicRay> Igloo: this is about the point where you point me to old irc logs, right? ;-)
08:12:50 * SamB_XP is pretty sure some kind of zipper is ideal
08:13:01 <Igloo> Heh, probably
08:13:02 <fasta> sjanssen: I implemented it in a zipper
08:13:15 <fasta> SamB_XP: I implemented it in a zipper
08:13:17 <fasta> sjanssen: sry
08:13:33 <SamB_XP> fasta: implemented what?
08:13:37 <fasta> It's not ideal, since it costs you some space.
08:13:40 <osfameron> fasta: oh well, I'm not all that well read on trees :-)  But I understood that zippers were good for moving to next door elements, which I'd understood splay trees were weak in.  I'll shut up now though if I'm talking nonsense :-)
08:13:49 <sjanssen> data Editor = E {left, right :: FingerTree Char} -- use ByteString chunks is Char is too slow
08:13:51 <Igloo> CosmicRay: Either removing it, or doing what you suggest above (more backport friendly) would work, though
08:14:15 <fasta> SamB_XP: a splay tree with a zipper with all the operations you might want.
08:14:51 <tommyd> hat install makes problems
08:14:52 <chessguy> 'morning
08:14:54 <SamB_XP> fasta: I meant, a zipper for text editors...
08:14:58 <fasta> SamB_XP: no
08:14:59 <tommyd> Installing hat as a ghc package:
08:15:00 <tommyd> Installing hat package for ghc under /usr/local/lib/hat-2.05/ix86-Linux/ghc-{-# LINE 1 "ghcsym.hs" #-}
08:15:01 <SamB_XP> not a splay-tree zipper...
08:15:02 <tommyd> 606
08:15:03 <tommyd> cp: omitting directory `/usr/local/lib/hat-2.05/ix86-Linux/ghc-{-#'
08:15:15 <tommyd> this path seems to be generated by make install on the fly
08:15:45 <fasta> I believe the Common Lisp people have done good research and I'd use what they use, after I verified their reasons.
08:16:04 <fasta> climacs (or whatever it'
08:16:07 <fasta> s called now)
08:16:17 <tommyd> (no matter how often I edit targets/ix86-Linux/ghcsym or lib/ix86-Linux/hatlib/ghc/ghcincdir)
08:16:43 <sjanssen> a purely functional zipper also gives you free undo
08:16:49 <malcolmw> tommyd: hmm, looks like the install code might re-detect the ghc version (badly)
08:17:32 <sjanssen> data Editor = E {left, right :: FingerTree Char, undo, redo :: [Editor]}
08:17:38 <tommyd> I'll stop for now and look into that next week
08:17:47 <SamB_XP> sjanssen: what about multiple views?
08:18:08 <sjanssen> SamB_XP: not sure about that one
08:18:24 <quicksilver> sjanssen: although, if you're not careful, you lose control of *how much* undo history you keep
08:18:29 <malcolmw> tommyd: it is easy to hack though
08:18:34 <quicksilver> sjanssen: and thus, your memory usage
08:18:41 <SamB_XP> also wouldn't you want the tree to store something besides chars?
08:18:48 <sjanssen> quicksilver: don't most editors keep all edit history?
08:18:59 <SamB_XP> sjanssen: all?
08:19:08 <quicksilver> sjanssen: yeah, amybe you're right
08:19:14 <SamB_XP> certainly they don't keep it as [Char]
08:19:20 <quicksilver> sjanssen: probably emacs just concatenates at save-time
08:19:22 <fasta> I think a real solution is not going to have such a trivial type.
08:19:23 <quicksilver> which is good enough
08:19:25 <malcolmw> tommyd: in script/confhat, about lines 25-28, is the detection code  - just delete and replace with GHCSYM=606
08:19:31 <sjanssen> SamB_XP: no, you'd probably use ByteString chunks
08:19:41 <quicksilver> SamB_XP: yes, I think you can understand Char as a placeholder for (Char,Attributes)
08:19:54 <quicksilver> SamB_XP: which in turn might be a placeholder for bytestring chunks :)
08:20:09 <quicksilver> but then, you can store attributes extternally in a second zipper
08:20:13 <quicksilver> which might be better, hmm
08:20:20 <notsmack> malcolmw: i hope your goal is to make him relieved to only have to deal with list comprehensions after this ;-)
08:20:29 <SamB_XP> quicksilver: externally?
08:20:42 <quicksilver> SamB_XP: well, let's simplify back to arrays
08:20:57 <quicksilver> SamB_XP: you could store [(Char,Attr)] or [Char],[Attr]
08:21:06 <quicksilver> SamB_XP: same notion applies with zippers + trees
08:21:17 <quicksilver> SamB_XP: you can 'interleave' the meta data with the chars themselves
08:21:24 <SamB_XP> you mean [:(Char, Atrr):] or ([:Char:], [:Attr:])
08:21:25 <quicksilver> SamB_XP: or you can store metadata in a second parallel structure
08:21:33 <quicksilver> yup :)
08:21:35 <SamB_XP> and those are supposed to be stored identically...
08:21:57 <sjanssen> SamB_XP: no, I don't think quicksilver means [: :]
08:22:09 <SamB_XP> sjanssen: he said arrays, not lists ;-)
08:22:14 <sjanssen> consider [] to be a general notation for some sequence thing
08:22:20 <SamB_XP> fine!
08:22:24 <quicksilver> my point is the same irrespective of the structure, to be honest :)
08:22:38 <quicksilver> it's just a generic point about bundling things together at nodes vs maintaining parallel structures
08:22:45 <SamB_XP> quicksilver: I think the Attr should be stored near characters
08:22:45 <sjanssen> right
08:23:02 <quicksilver> if you imagine attrs to be relatively sparse, compared to chars
08:23:14 <quicksilver> then your fingertree (or whatever it is) for the attrs will be simpler
08:23:16 <SamB_XP> but I'm not quite sure how near
08:23:17 <quicksilver> that might be a win
08:23:19 <quicksilver> I'm not sure :)
08:23:34 <malcolmw> notsmack: tommyd: got a paste of the animation for fibs with zipWith: http://pastebin.ca/528409
08:23:42 <sjanssen> you may also want extensible attrs
08:23:42 <quicksilver> in real text editors you might have attributes 'between' chars, too
08:23:53 <SamB_XP> quicksilver: between?
08:23:55 <quicksilver> anyone know what Yi uses?
08:24:11 <quicksilver> SamB_XP: well consider <b>, a.k.a. BOLD STARTS HERE
08:24:13 <sjanssen> quicksilver: some sort of array structure
08:24:19 <quicksilver> SamB_XP: that goes between chars
08:24:21 <SamB_XP> quicksilver: that isn't an attribute ;-)
08:24:28 <quicksilver> it is some kind of metadata
08:24:34 <quicksilver> which a text editor may want to store
08:24:42 <tommyd|away> malcolmw: thanks, I'll look into that later
08:24:45 <SamB_XP> possibly
08:25:09 <fasta> A text editor isn't a really interesting problem anymore, I guess. A structured editor is.
08:25:11 <malcolmw> tommyd|away: lots of ellipsis unfortunately - will try to expand it out a bit more
08:25:27 <Apocalisp> Yea, concurrent reads of splay trees require locking or queueing.
08:25:59 <tommyd|away> wow, this channel is always high-traffic (looking at the logs)
08:26:02 <SamB_XP> Apocalisp: well, that isn't so much of a problem
08:26:06 <fasta> Apocalisp: don't all trees require this?
08:26:09 <SamB_XP> tommyd|away: it depends on the time of day
08:26:12 <tommyd|away> anyways, I'm now really away =)
08:26:16 <SamB_XP> @where stats
08:26:16 <lambdabot> http://www.cse.unsw.edu.au/~dons/irc/
08:26:34 <Apocalisp> fasta: Only trees that change when you look at them. :-)
08:26:52 <chessguy> quantum trees? :)
08:27:15 * SamB_XP tries to learn something from http://okmij.org/ftp/Haskell/Zipper2.lhs
08:27:23 <fasta> Apocalisp: I forgot about purely functional implementation in #haskell ;)
08:28:05 <sjanssen> SamB_XP: I think there's a paper called "n-hole zipper", or some such
08:28:26 <SamB_XP> hmm.
08:28:32 <SamB_XP> @go "n-hole zipper"
08:28:33 <lambdabot> No Result Found.
08:28:52 <sjanssen> ask dons next time he's around
08:29:04 <sjanssen> it might just be an Oleg article
08:29:48 <SamB_XP> @go ZipperN
08:29:51 <lambdabot> http://hotitemsinfo.info/item,180062548853,ESPRIT_Hose_mit_coolen_Zippern__schwarz__Gr_36__NEU.html
08:29:51 <lambdabot> Title: hotitemsinfo.info - ESPRIT Hose mit coolen Zippern - schwarz - Gr. 36 - NEU
08:29:57 <SamB_XP> @go ZipperN.lhs
08:29:58 <lambdabot> No Result Found.
08:30:44 <chessguy> @go ZipperN filetype:lhs
08:30:45 <lambdabot> No Result Found.
08:32:20 <SamB_XP> I only see the one about 2-hole zippers...
08:33:04 <SamB_XP> whoa... how does it preserve sharing???
08:33:40 <quicksilver> magic, mostly
08:33:45 <quicksilver> and a little pixie dust
08:33:48 <tommyd|away> hehe... ESPRIT throusers =)
08:34:14 <sjanssen> perhaps other holes are themselves attrs?
08:34:42 <sjanssen> then you just scan left and right for them to render to the screen, switch views, etc.
08:34:57 <earthy> zippers are derivations of the datatype, right?
08:35:00 <SamB_XP> sjanssen: that sounds rather expensive
08:35:15 <quicksilver> earthy: that's one interesting mathematical way of looking at them
08:35:16 <SamB_XP> what if you have one view at the beginning, and another at the end, of a million-line file?
08:35:23 <sjanssen> SamB_XP: you can make it fairly cheap with Paterson-Hinze style fingertrees
08:35:28 <SamB_XP> hmm.
08:35:28 <quicksilver> earthy: but really they're just datatypes with a chosen ('marked') hole
08:35:55 * earthy nods
08:35:57 <sjanssen> probably something like O(x log n), where 'x' is the number of views, and n is the size of the file
08:36:16 <SamB_XP> is it a zipper if it doesn't correspond with a cursor on another datatype?
08:36:30 <earthy> I read the wikibook
08:36:37 <chessguy> are there any papers on zippers as derivatives?
08:36:52 <earthy> chessguy: there is one, but I can't seem to find it
08:36:55 <quicksilver> chessguy: yes, McBride
08:36:58 <sjanssen> chessguy: http://www.cs.nott.ac.uk/~ctm/diff.pdf
08:37:06 <quicksilver> there you go :)
08:37:08 <sjanssen> 'The Derivative of a Regular Type is its Type of One-Hole Contexts'
08:37:15 <earthy> gotcha. that's the one. ;)
08:37:18 <chessguy> thanks
08:37:24 <sjanssen> the link was literally on my screen at the time
08:37:34 <SamB_XP> oh, you mean like analysis?
08:37:42 <SamB_XP> so how do you integrate a zipper...
08:38:09 <sjanssen> SamB_XP: the integration of a zipper is the thing that turns it into the sequential structure
08:38:26 <cdsmith> @pl \x -> (-x) -- hmm
08:38:26 <lambdabot> subtract
08:38:44 <quicksilver> heh
08:38:45 <sjanssen> integrate (Stack ls x rs) = reverse ls ++ x : rs
08:38:47 <quicksilver> that's not true :)
08:38:53 <quicksilver> that's negate
08:38:55 <chessguy> @pl \x -> 0 - x
08:38:55 <sjanssen> plus an index, I suppose
08:38:55 <lambdabot> (-) 0
08:39:00 * quicksilver bops @pl
08:39:03 <cdsmith> quicksilver: right.
08:39:08 <SamB_XP> this paper needs better pictures
08:39:24 <chessguy> quicksilver, (-x) is not the negative of x
08:39:34 <chessguy> i don't think
08:39:44 <SamB_XP> chessguy: isn't it now?
08:39:52 <chessguy> > (-4) 1
08:39:53 <quicksilver> chessguy: on the contrary
08:39:54 <lambdabot>   add an instance declaration for (Num (t -> a))
08:39:54 <lambdabot>     In the expression: (- 4)...
08:40:04 <quicksilver> > (\x -> (-x)) 4
08:40:05 <syntaxfree> @unpl g [] = []
08:40:05 <lambdabot> g [] = []
08:40:06 <lambdabot>  -4
08:40:10 <syntaxfree> g (er.
08:40:14 <syntaxfree> @redo g [] = []
08:40:14 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 6}) "Parse error"
08:40:23 <syntaxfree> gah. I'm sorry.
08:40:24 <SamB_XP> @pl (\x -> (-x)
08:40:25 <lambdabot> (line 1, column 12):
08:40:25 <lambdabot> unexpected end of input
08:40:25 <lambdabot> expecting variable, "(", operator or ")"
08:40:26 <sjanssen> @ask dons any good refs on n-hole zippers?  We were talking about a purely functional editor today in #haskell
08:40:26 <lambdabot> Consider it noted.
08:40:29 <SamB_XP> oops
08:40:31 <SamB_XP> @pl (\x -> (-x))
08:40:31 <lambdabot> subtract
08:40:36 <syntaxfree> @redo t = [1..10] >>= (g . f)
08:40:37 <lambdabot> ParseFailed (SrcLoc {srcFilename = "<unknown>", srcLine = 1, srcColumn = 3}) "Parse error"
08:40:39 <quicksilver> chessguy: I wish (-x) was a section, but it isn't
08:40:43 <SamB_XP> hmm, pl is brokenm
08:40:45 <quicksilver> chessguy: stupid syntax exceptions
08:40:45 <syntaxfree> @redo  [1..10] >>= (g . f)
08:40:46 <lambdabot> do { a <- [1 .. 10]; (g . f) a}
08:40:51 <chessguy> indeed
08:40:58 <SamB_XP> it is broken just like chessguy is ;-)
08:41:02 <syntaxfree> i can't do
08:41:10 <cdsmith> SamB: yep.  I was thinking of fixing it.  Because my actual job is boring today.
08:41:12 <chessguy> SamB_XP, bite me
08:41:22 <SamB_XP> chessguy: okay, was
08:41:29 <syntaxfree> do { a <- [1..10]; x<- f a; y <- g x; return y;}?
08:41:30 <SamB_XP> are you happy now? ;-)
08:41:34 <quicksilver>  @pl doesn't use the 'real' haskell parser
08:41:43 <SamB_XP> quicksilver: would it help if it did?
08:41:44 <quicksilver> it uses a handspun one
08:41:54 <quicksilver> well it wouldn't maek that mistake :)
08:41:57 <syntaxfree> it's a greenspun parser?
08:42:20 <cdsmith> quicksilver: it uses Language.Haskell.something_or_another.  Part of the standard library
08:42:24 <bringert> dcoutts: I've got a #set hook for a struct field called "type", but c2hs barfs on that, saying "syntax error". I'm guessing it doesn't like haskell keywords being used a struct field names.
08:42:34 <bringert> s/a/as/
08:42:45 <quicksilver> cdsmith: that was not what I was told...
08:42:49 <dcoutts> bringert: it's a c2hs keyword, yes, so it messes up the parsing
08:42:50 <quicksilver> cdsmith: but maybe I was told wrong
08:43:11 <syntaxfree> @quote type
08:43:12 <lambdabot> ghc says: Inferred type is less polymorphic than expected
08:43:12 <cdsmith> quicksilver: well, I assure you that it does.  I fixed its precedence parsing about a month ago.
08:43:13 <dcoutts> bringert: mux tripped over that recently iirc we tried to fix it, but it didn't turn out to be so easy
08:43:18 * syntaxfree ducks and quits
08:43:21 <bringert> dcoutts: can I escape it or something?
08:43:25 <dcoutts> bringert: no
08:43:30 <bringert> damn
08:43:30 <quicksilver> cdsmith: ah, good. So why does it manage to confuse subtract and negate then?
08:44:08 <cdsmith> quicksilver: I'm not sure if that's a parsing error, or logic in pl itself.  The parser doesn't resolve symbols or their meaning.
08:44:39 <dcoutts> bringert: if you don't want to look at the c2hs code there's not a lot to do except write a wrapper in C
08:45:06 <sjanssen> cdsmith: no, pl uses a hacked up parser.  The rest of the plugins (unpl, undo, redo) use Language.Haskell
08:45:33 <cdsmith> sjanssen: Oh!  I am confused, then?
08:45:38 <sjanssen> yes
08:45:49 <cdsmith> drat!  Well, I'll look around.
08:45:51 <quicksilver> cdsmith: the parser does resolve that particular issue. Or perhaps the lexer, even?
08:46:08 <quicksilver> cdsmith: the stupid syntax of - is a special case that it handled before symbol resolution
08:46:28 <cdsmith> quicksilver: I take back what I said.
08:46:47 <quicksilver> and I hate this corner of the syntax
08:46:54 <quicksilver> I want (-4) to be a section
08:47:12 <quicksilver> I'm quite happy to write negate 4 or ~4 or whocaresaboutnegativenumbersanyway 4
08:47:15 <quicksilver> for the other case :P
08:47:31 <quicksilver> or 0-4
08:47:38 <bringert> dcoutts: the C code will be about as long as the haskell code for assigning a bunch of struct fields, so I maybe I'll go that route
08:48:25 <bringert> dcoutts: working with structs is a bit of a pain with all FFI tools I've seen
08:48:52 <dcoutts> bringert: aye, you want something to automatically assign all the struct members
08:49:08 <bringert> yeah
08:49:17 <olsner> hmm.. I'm parsing a file, and have extracted the header like this: take 4 $ concat $ map words $ skipComments $ lines inp - how do I get "the rest" of the input after that? (and I want it raw - all those other transformations remove information in the process, so just "break 4" instead of take 4 won't really do)
08:49:27 <dcoutts> bringert: but that runs into trouble when you only want a subset since some cannot be marshaled
08:49:49 <bringert> dcoutts: you can always give it a nullptr or something
08:50:14 <dcoutts> bringert: if we can figure out a design, it's something that c2hs could do as it's got enough info, hsc2hs cannot do it.
08:50:21 <dcoutts> cannot/could not
08:50:31 <davidL> is Cabal responsible for genearting the .buildinfo file?
08:50:49 <davidL> s/genearting/generating
08:54:54 <byorgey> olsner: hmm... sounds like you might want to actually use a parsing library =)
08:55:18 <olsner> perhaps ;-) but I've found a much uglier way to do it
08:55:53 <byorgey> olsner: I came up with several solutions in my head but realized that I was basically re-inventing the parser
08:55:58 <byorgey> olsner: I see.
08:57:39 <desp> I'm having a bit of a problem
08:58:15 <desp> I'm working with a stateful C library that needs to be initialized before use
08:59:03 <desp> I'm wondering if it's possible to initialize it (and remember the fact that it's been initialized) on the Haskell side
09:00:02 <SamB_XP> desp: you could abuse lazy evaluation
09:00:18 <Lemmih> It being? (I lost the last 10 minutes of chatter)
09:00:24 <SamB_XP> a c library
09:00:36 <dcoutts> or use a monad that brackets use of the library, initialising it at the beginning
09:00:39 <desp> Lemmih: a C library that needs to be initialized before making use of its functions
09:00:55 <desp> yes, the problem is that I would like to expose functions wrapping those C library functions in a module
09:01:04 <ToRA> desp: init :: MyCustomMMarkingThatTheLibraryIsInitedM a -> IO a
09:01:37 <ToRA> then the wrapped functions are all of type arg -> MyCustomMMarkingTatTheLibraryIsInitedM returntype
09:01:58 <DRMacIver> I think you need a shorter type name. :)
09:02:02 <desp> :)
09:02:20 <ToRA> DRMacIver, quite possibly - i don't have vim hippy-complete in bitchx :(
09:02:22 <Lemmih> GHC uses global mutable variables for initializing the linker, iirc.
09:02:51 <desp> I'll try that. however, won't that complicate using those functions?
09:02:52 <SamB_XP> desp: I would have a variable in the module, the forcing of which would trigger the initialization, and have the wrapper functions force it before beginning their work...
09:03:10 <desp> SamB_XP: yes, I was thinking the same thing, but how to have a variable in the module?
09:03:33 <SamB_XP> desp: you don't actually need *that* kind of variable...
09:04:14 <SamB_XP> you could have, say, initToken = unsafePerformIO init_C_library
09:04:47 <SamB_XP> and then put "initToken `seq` " at the beginning of all your wrappers...
09:05:36 <dcoutts> or just expose the fact that the lib needs initialising Gtk2Hs and wxHaskell do this for example
09:05:42 <desp> SamB_XP: so that will execute only once, the first time one of those functions is called?
09:05:55 <desp> dcoutts: thanks, I'll take a look
09:06:44 <SamB_XP> you could eqaully do nastyVariable = unsafePerformIO (newIORef ...)
09:14:15 <mdmkolbe|work> @seen dons
09:14:15 <lambdabot> dons is in #rwh, #ghc, #haskell-overflow, #xmonad, #haskell-soc and #haskell. I last heard dons speak 1h 28m 34s ago.
09:29:29 <maxslug> Anyone around for a little tech support?
09:30:29 <jfoutz> need to fix your modem?
09:30:51 * johnnowak_ needs to club his router
09:31:10 <maxslug> Yes, I have a Hayes External 1200 Baud modem that i'm using with my new 16540 UART ISA 8-bit card, and I have the port set to 4800 buaud n-7-1 and I can't seem to login to the BBS, any ideas?
09:32:08 <maxslug> Actually, i'm trying to bootstrap GHC on redhat WS3 and after following the Build wiki instructions I'm getting an error :
09:32:13 <jfoutz> heh
09:32:18 <maxslug> "*** No rule to make target `Apply.o', needed by `libHSrts.a'.  Stop"
09:32:59 <Igloo> maxslug: WS3?
09:33:23 <maxslug> WS3 == Red Hat Enterprise Linux WS release 3 (Taroon Update 5)
09:33:39 <Igloo> maxslug: So this is Linux/x86?
09:34:15 <maxslug> Yes, 2.4.21, gcc 3.2.3  (they force me to these old versions at work due to some ancient cad software)
09:34:25 <jfoutz> i haven't had that problem... i have 2 guesses, 1, maybe you checked out from CVS and it wans't in a good state. 2, config didn't detect a dependency correctly
09:34:32 <Igloo> maxslug: Easiest thing to do is to start with the generic bindist, then
09:35:28 <maxslug> jfoutz:  it's the 6.6.1 distro
09:35:41 <bringert> dcoutts: can I give an extra argument to a de-marshalling function when using #fun? I have a checkResult :: String -> CInt -> IO () that throws an exception if the CInt is non-zero, and I want the string to be the function name. I use this as a de-marshalling function like this: `()' checkResult*-
09:35:42 <maxslug> Igloo: I'll see if I can get one that works on this version of gcc,  I don't have root either
09:36:16 <bringert> dcoutts: I would like to be able to do  `()' (checkResult "nameOfThisFunction")*-
09:36:17 <dcoutts> bringert: I expect not, you can use {# call #} for the cases where {# fun #} is too simplistic
09:36:42 <bringert> dcoutts: I though #fun was the more advanced one?
09:36:51 <bringert> dcoutts: maybe I'm looking at old docs
09:36:57 <bringert> dcoutts: http://www.cse.unsw.edu.au/~chak/haskell/c2hs/docu/c2hs-2.html
09:36:57 <lambdabot> Title: The Binding Generator C->Haskell: Implementation of Haskell Binding Modules
09:37:10 <bringert> dcoutts: I could find sgml2html to build the docs from darcs
09:37:19 <dcoutts> bringert: it is, it does more for you, but if what it does for you isn't what you want...
09:37:26 <dcoutts> bringert: that seems like a natural thing to want to do, feel free to send the suggestion to the c2hs list so we don't forget
09:37:40 <maxslug> jfoutz: here is a related bug, but i couldn't find the matching patch in CVS to see what the fix was : http://hackage.haskell.org/trac/ghc/ticket/1284
09:37:42 <lambdabot> Title: #1284 (GHC 6.6 does not compile on Slackware 11.0 linux) - GHC - Trac
09:37:50 <maxslug> heh
09:39:05 <jfoutz> hmm. that ticket claims it was fixed in 6.6.1, which is what you're using.
09:39:59 <maxslug> jfoutz: correct.
09:40:40 <jfoutz> i'd open a new ticket. actualy i would try to compile Apply.o by hand, get frustrated and quit. but you should probably open a ticket :)
09:40:57 <jfoutz> you might also ask on #ghc
09:41:45 <maxslug> jfoutz: thanks,  I tried option 1 already, no mention of it in the Makefile.   I was unaware of #ghc, i'll slink over there.  Thanks for your help.
09:44:27 <bringert> dcoutts: thanks. mail sent.
09:44:32 <dcoutts> bringert: ta
10:19:33 <desp> @hoogle forkOS
10:19:33 <lambdabot> Control.Concurrent.forkOS :: IO () -> IO ThreadId
10:26:09 <Syzygy-> A comathematician is a device for turning cotheorems into ffee
10:26:48 * ari cringes
10:32:33 <fasta> Syzygy-: good party joke ;)
10:45:45 <Syzygy-> ?hoogle Eq a => [a] -> [a] -> [a]
10:45:46 <lambdabot> List.(\\) :: Eq a => [a] -> [a] -> [a]
10:45:46 <lambdabot> List.intersect :: Eq a => [a] -> [a] -> [a]
10:45:46 <lambdabot> List.union :: Eq a => [a] -> [a] -> [a]
10:45:52 <Syzygy-> Hmmm.
10:46:17 <Syzygy-> If I want to figure out what the longest initial part of one list is that is a sublist of another list?
10:46:40 <Syzygy-> Is there a stock function for me?
10:52:46 <jfoutz> list.isInfixOf is close
10:53:19 <Syzygy-> Doesn't deliver position, nor maximal infix length.
10:53:39 <Saizan> > map fst . takeWhile (snd) . zipWith (curry (uncurry const &&& uncurry (==))) "aaaaaaab" $ "aaaaaaaaaa"  -- you can have an overly complex one!
10:53:40 <lambdabot>  "aaaaaaa"
10:54:05 <Syzygy-> oO
10:54:11 <Syzygy-> Gleh
10:54:12 <int-e> > let matchLen as bs = length . takeWhile id $ zipWith (==) as bs in maximum (map (matchLen "abcdef" &&& id) (tails "xabyabczabcdutatbtctay"))
10:54:13 <lambdabot>  (4,"abcdutatbtctay")
10:54:18 <int-e> another one :)
10:54:48 <Syzygy-> Anyone know whether / what the best way to implement trees with any arity for each node might be?
10:54:53 <jfoutz> tails. that's what i was looking for.
10:54:58 <Syzygy-> int-e: Thanks. I'll steal that one - it seems to deliver what I wanted.
10:55:21 <Saizan> Syzygy-: Data.Tree uses Node a [Tree a]
10:55:58 <Syzygy-> Saizan: Ahhh. Good.
10:57:11 * Syzygy- wants to implement a program to handle calculations with the Saneblidze-Umble diagonal.... 
10:57:24 <Syzygy-> i.e. back to weird mathematical mistreatments of Haskell. :)
10:58:28 <desp> @src (++)
10:58:28 <lambdabot> (++) []     ys = ys
10:58:29 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
10:58:47 <sjanssen> @keal
10:58:48 <lambdabot> ithink has to do with hardcased government failsafe in chip
11:01:31 <cdsmith> @where zlib
11:01:31 <lambdabot> I know nothing about zlib.
11:03:04 <Choko> @src (!!)
11:03:04 <lambdabot> xs     !! n | n < 0 = undefined
11:03:04 <lambdabot> []     !! _         = undefined
11:03:04 <lambdabot> (x:_)  !! 0         = x
11:03:04 <lambdabot> (_:xs) !! n         = xs !! (n-1)
11:03:27 <Syzygy-> Ooooookay.
11:03:40 <Syzygy-> So I want to traverse a tree, and I want to number the leafs from left to right, and then output them....
11:03:50 <Syzygy-> State monad? Or can I do it purely?
11:04:37 <sjanssen> State monad == purely :)
11:05:09 <sjanssen> Szygy-: something like: zip [0..] . flatten $ t?
11:05:09 <fasta> Syzygy-: Real Programmers use higher-order folds.
11:05:33 <sjanssen> or do you also want a new tree with added labels?
11:05:42 <jfoutz> int-e, that substring finder is amazing.
11:05:48 <Syzygy-> sjanssen: A tree can be thought of as a distribution ofbracketings of a string of length # leafs.
11:05:53 <Syzygy-> I want this bracketing given a string.
11:06:27 <Botje> Syzygy-: if you look at Control.Monad.State , the example is about numbering a tree
11:06:31 <Botje> you're in luck
11:06:34 <fasta> Syzygy-: or attribute grammars.
11:06:36 <Syzygy-> So I need to traverse the tree to figure out the brackets, and I need to number the leafs appropriately.
11:06:51 <Syzygy-> Botje: Thanks.
11:06:57 <fasta> Syzygy-: or monads
11:07:03 <fasta> Syzygy-: or nothing fancy :)
11:07:19 <Syzygy-> I'm happy enough using monads, I was just curious whether there is a more straightforward way that I just don't see.
11:07:39 <fasta> Syzygy-: higher-order folds are pretty elegant, I think.
11:07:45 <jfoutz> numbering fringe is non-obvious.
11:07:56 <Syzygy-> fasta: Can ytou give me an example how to do it with that?
11:08:21 <fasta> Syzygy-: I can point you to a textbook which I think is online.
11:08:26 <fasta> Syzygy-: is that OK?
11:08:32 <Syzygy-> fasta: I'm on a flaky connection in T'bilisi.
11:08:34 <fasta> Syzygy-: I also can show you some of my code.
11:08:39 <Syzygy-> Big downloads is not very ok. Alas.
11:09:18 <fasta> Syzygy-: essentially you write a fold for your data type.
11:09:33 <Syzygy-> Oooook, the Control.Monad.State example was pretty irrelevant for my case.
11:09:43 <fasta> Syzygy-: you write an algebra for your problem
11:09:50 <fasta> Syzygy-: then apply the fold to the algebra.
11:10:06 <Syzygy-> I think you mean something different with "algebra" than what I usually mean by it.
11:10:23 <jfoutz> fasta, could you msg me the link to the textbook? or post it?
11:10:24 <fasta> Syzygy-: the algebra is simply a tuple that is isomorphic to the types of your constructors
11:10:33 <Syzygy-> Oo
11:10:55 <fasta> The dead tree version is somewhere around here. Let me search for it.
11:11:31 <Modius> Question from someone who's barely finished the Haskell tutorials here:  Is there a link to something that explains, for complex coroutines (not the low hanging fruit; but complex trees of ifs and such) techniques for rethinking the problem in terms of functional constructs?
11:12:14 <fasta> http://www.cs.uu.nl/docs/vakken/gont/diktaat.pdf <- higher order folds
11:12:27 <Syzygy-> Dammit. It may be that it's late, or that I'm daft, but I really don't understand the Control.Monad.State code.
11:12:57 <Saizan> ?docs Control.Monad.State
11:12:57 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html
11:13:09 <fasta> Syzygy-: it's 1.2MB
11:13:13 <dolio> Hmm, what's the type of fold for that tree? (a -> [b] -> b) -> Tree a -> b?
11:13:51 <Modius> Fasta:  Thanks
11:14:18 <Saizan> ?type foldr
11:14:20 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> b
11:14:48 <Procyon112> @djinn [a]->[a]->a->[a]
11:14:48 <lambdabot> f _ a _ = a
11:14:52 <Procyon112> lol
11:14:54 <fasta> Modius: I didn't answer your question.
11:15:22 <Syzygy-> Hmmm.
11:15:23 <jfoutz> fasta, thank you
11:15:45 <Modius> Fasta:  Sorry, I thought your link was in answer to my request for replacement for coroutines (that "higher order folds" was the answer :) )
11:15:46 <Syzygy-> What about if I just make my "printthissubtree" function return a number, and I work through the subtrees with care. That should do it, right?
11:15:47 <sjanssen> lisppaste *and* hpaste are down?
11:16:16 <Procyon112> @djinn [a]->[a]->[a]
11:16:17 <lambdabot> f _ a = a
11:16:29 <Saizan> Procyon112: djinn doesn't handle lists
11:16:49 <kaol> @djinn (a -> b -> b) -> b -> [a] -> b
11:16:50 <lambdabot> f _ a _ = a
11:17:26 <fasta> Modius: If you have an actual problem post it to the wiki or some paste site.
11:17:54 <sjanssen> http://rafb.net/p/0I6m7s22.html
11:17:55 <fasta> Modius: Haskell doesn't have coroutines, although it does have continuations in the continuation monad.
11:17:55 <lambdabot> Title: Nopaste - number a tree -- fold style
11:18:10 <Saizan> Modius: higher order folds are the answer to many questions ;), generators, visitor pattern, cursors, etc...
11:19:48 <fasta> sjanssen: where did you learn about that not so popular technique?
11:20:01 <jfoutz> > find (\(x,y) -> (x == y)) $ concatMap (\x -> map (\y -> (x,y)) $ inits "abc") $ tails "cde"
11:20:02 * sjanssen shrugs
11:20:03 <lambdabot>  Just ("","")
11:20:06 <sjanssen> it's just a fold
11:20:28 <fasta> sjanssen: do you know about the repMin problem?
11:20:40 <sjanssen> fasta: yeah, I've heard of it
11:21:18 <Modius> Fasta:  I was thinking of simpler situations (that I doubt would need a monad).  If you've seen C#'s IEnumerable -> Yield functions, some tutorial on how to build the fully functional (lazy-evaluated list) equivalents.
11:21:42 <Modius> I see the IEnumerable-Yield solutions to be a bit ghetto compared to functional solutions; but would like to see examples (if they exist) of someone writing them.
11:22:53 * dolio is baffled by his computer.
11:23:05 <drigz> > on
11:23:06 <lambdabot>   Not in scope: `on'
11:24:33 <dolio> Evidently, konqueror can only reach the newegg main page. Any other page on their site stalls. But everything works fine in firefox...
11:25:25 <Saizan> Modius: what does that do? is that yield similar to the python one?
11:28:24 <Modius> Saizan:  Don't know Python.  It returns a factory for an iterator into a lazy-evaluated list that executes by returning a value for each "yield" in the function's code.
11:29:06 <Modius> Saizan:  E.g. I'd implement Map by having it take a function and another IEnumerable, foreach through it, and :  yield function(currentValue); for each loop iteration.
11:29:07 <SamB_XP> Modius: you ... don't know python?
11:29:11 <SamB_XP> and you just said that?
11:29:34 <SamB_XP> are you *certain* that you do not know Python?
11:29:35 <Modius> He asked "is yield similar to the python one", and I described the yield I know from C#
11:29:52 <sjanssen> Modius: can several functions consume the same stream?
11:30:29 <SamB_XP> Modius: I say this because I would have concluded that you were explaining Python, if not for IEnumerable and "Don't know Python."
11:30:30 <Modius> sjanssen:  Yes.  Although I'm looking for ways to emulate the properties of the pure functional ones - I'm not looking for stateful here; but for some tutorial or other on elegantly rethinking these things into functional equivalents.
11:31:41 <drigz> why is it that two expressions with the same type will have their type printed using different letters?
11:31:59 <SamB_XP> Modius: does C# have lazy evaluation yet?
11:32:18 <Modius> SamB_XP:  Technically functions that return an IEnumerable and yield inside give you that.
11:32:37 <SamB_XP> Modius: Modius can you re-use the result of that?
11:32:40 <Modius> (As does putting something behind IEnumerable that is lazy evaluated, or writing your own)
11:32:45 <Modius> SamB_XP:  Generally, yes
11:32:55 <SamB_XP> oh, that's better than Python I think then
11:33:26 <Modius> SamB_XP:  There's no autocaching on it though, or inference of same (you can add it though), and if it has sideeffects or pulls outside data (including things like Guids), there's going to be grief from reuse.
11:33:45 <SamB_XP> Modius: oh. not so great then.
11:34:01 <Modius> It's part and parcel of not being Haskell - no other language can give you a safe lazy that I know of.
11:34:02 <SamB_XP> I implemented lazy lists in Slate.
11:34:05 <Modius> (GUARENTEED safe)
11:34:08 <SamB_XP> also suspensions, actually.
11:34:16 <sjanssen> Modius: so something like this works correctly: xs = map(f, someList); evens = filter(isEven, xs); odds = filter(isOdd, xs); ?
11:34:16 <Modius> Anything with first-class functions can technically support lazy
11:34:34 <Syzygy-> Hah!
11:34:35 <SamB_XP> Modius: its nice to have some lightweight syntax though
11:34:35 <Modius> SJanssen:  Yes, although stock it will reeval xs each time
11:34:36 <Syzygy-> I have it!
11:34:43 <SamB_XP> and what about that memoization?
11:34:49 <Modius> What's memoization?
11:34:51 <SamB_XP> (as Okasaki calls it)
11:35:08 <SamB_XP> Modius: where your suspensions get updated with the return value after it is computed
11:35:13 <Syzygy-> I basically let a helper function throw the indices back up again.
11:35:17 <Modius> (Note - I come here not to laud C# - I'm describing bits of C# 2.0 that put it considerably above C# 1.0, it doesn't hold a candle to Haskell)
11:35:18 <sjanssen> SamB_XP, Modius: generally called 'sharing'
11:35:38 <manveru> heya guys
11:35:44 <SamB_XP> sjanssen: I don't think it is *called* sharing
11:35:45 <sjanssen> the proprety that a thunk is never evaluated more than once
11:35:46 <Modius> I'd guess you'd have to implement it yourself, as I have done, essentially xs = cached(map(f, somelist))
11:36:00 <SamB_XP> it is useful to do in order to *have* sharing
11:36:12 <manveru> anyone up to help me with a small problem concerning xmonads Config.hs ?
11:36:19 <sjanssen> manveru: sure
11:36:20 <Modius> First requester will cause the value to be cached, next one through not so.  I won't bore you with implementation details; but it doesn't naively do caching of "all"
11:36:42 <manveru> sjanssen: i try to map ((modMask, xK_Return), spawn "xterm")
11:36:51 <Modius> Only (a language like haskell) with stateless no-input lazy can automatically intelligently cache such things.
11:36:53 <manveru> but it only works with .|. shiftMask
11:36:57 <SamB_XP> sjanssen: say, did I ever tell you about lazy blackholing?
11:37:08 <sjanssen> SamB_XP: no, I don't think so
11:37:10 <manveru> and i can't figure out why that is...
11:37:15 <sjanssen> we were wondering how it works, right?
11:37:24 <SamB_XP> we were?
11:37:24 <sjanssen> especially in the presence of many evaluators
11:37:40 <sjanssen> maybe I'm remembering something else, I dunno
11:37:50 <SamB_XP> actually now there are *two* flavours of unsafePerformIO
11:38:07 <sjanssen> manveru: is your capslock on?
11:38:10 <SamB_XP> one that allows unsharing and one that doesn't
11:38:14 <manveru> sjanssen: no
11:38:34 <SamB_XP> the one that allows unsharing is for things that are actually pure
11:38:41 <SamB_XP> and have no effects
11:39:15 <sjanssen> manveru: that keybinding is already taken, you have to delete it first
11:39:32 <manveru> sjanssen: oh my
11:39:38 <manveru> stupid me :)
11:39:40 <manveru> thanks
11:39:51 <SamB_XP> but, anyway, thanks to lazy blackholing you get unsharing when multiple threads evaluate a thunk in parallel
11:40:13 <Saizan> Modius: i'm quite convinced that most of the time you can just have a funcion that returns the list, instead of your generator
11:40:29 <SamB_XP> @google lazy blackholing
11:40:31 <lambdabot> http://www.cs.uu.nl/research/techreps/repo/CS-2004/2004-052.pdf
11:40:50 <sjanssen> SamB_XP: right, no locks in thunks
11:41:00 <sjanssen> I remember that from the threaded RTS paper
11:41:05 <Modius> Saizan:  That gets in the way of chaining up functional goodies, and prevents some of them from being able to represent things like infinite lists.
11:41:43 <Saizan> Modius: why?
11:41:47 <Modius> Saizan:  And in the language of concern here IEnumerable is an interface on a list anyway.
11:42:09 <Modius> Saizan:  So map will then work for both the lazy-eval case and the "I want a list" case; but it's hard to make it work the other way.
11:42:31 <manveru> sjanssen: out of curiosity, was wmii the main inspiration for the way xmonad behaves?
11:42:44 <Saizan> Modius: which other way?
11:43:12 <sjanssen> manveru: dwm (which is descended from wmii)
11:43:26 <Saizan> > sum . take 20 . map (+2) $ [1..] -- [1..] is an infinite list
11:43:28 <lambdabot>  250
11:43:54 <Modius> The convention of returning evaluated lists vs. lazy-evaluated IEnumerables.  It's easier to build a container (cache) when needed than to turn something that returns a fully evaluated container into lazy-eval.
11:44:30 <manveru> sjanssen: thanks a lot, works perfect now
11:45:02 <Saizan> Modius: so you want your functional way in C#, not in haskell?
11:46:26 <Modius> My original question on this channel today was not specific to either language.  However, I know that Haskell lacks (need for) "yield" functions; but people do without them with even more concise constructs.  I was after some examples of people converting from yielding functions to fully functional representations of same.
11:46:57 <SamB_XP> sjanssen: it seems that unsafePerformIO now uses unlazy blackholing
11:47:07 <Modius> E.g. "here is someone using Python/C# type "yield".  Here is the same algorithm rerepresented with map, folds, curry, etc."
11:47:16 <SamB_XP> or *something*
11:47:21 <Saizan> Modius: ok, give me the first part :)
11:47:32 <SamB_XP> http://darcs.haskell.org/packages/base/GHC/IOBase.lhs
11:47:46 <SamB_XP> @go unsafeDupablePerformIO
11:47:48 <lambdabot> http://darcs.haskell.org/packages/base/GHC/IOBase.lhs
11:48:14 <Modius> Saizan:  Kind of "on the job" right now, was hoping there was a manifesto on this I could deal with at my own pace
11:48:47 <Modius> If there isn't, I'll have to come back later with concrete examples (they'd involve ifs, bools/state, and loops)
11:51:03 <bos> Modius: the style of coding is so different, the representations wouldn't even look similar
11:52:15 <desp> @hoogle when
11:52:19 <lambdabot> Monad.when :: Monad a => Bool -> a () -> a ()
11:52:19 <lambdabot> Control.Monad.when :: Monad m => Bool -> m () -> m ()
11:52:47 <Modius> bos:  If by styles of coding between "yield"ing code and pure functional, I know they won't look similar - but there is a skill to creating the latter from (the mantal patterns by which the former was generated) that I hope to acquire, through seeing examles.
11:53:08 <SamB_XP> sjanssen: yeah. apparantly there is a new primitive for immediate blackholing
11:53:29 <SamB_XP> immediate and atomic
11:54:33 <SamB_XP> and killings too?
11:55:31 <SamB_XP> ... anyway, it should prevent readFile results from going haywire when you read 'em from multiple threads concurrently
11:55:38 <SamB_XP> er. in parallel
11:58:43 <Syzygy-> ?hoogle findWith
11:58:44 <lambdabot> Data.IntMap.findWithDefault :: a -> Key -> IntMap a -> a
11:58:44 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
11:58:51 <Syzygy-> ?hoogle find
11:58:52 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
11:58:52 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
11:58:52 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
12:25:22 <manveru> another thing
12:25:32 <manveru> the xclipboard doesn't seem to work in xmonad
12:26:29 <sjanssen> manveru: hmm?
12:26:32 <desp> {# call unsafe g_thread_init #} -- what does this mean?
12:26:46 <desp> it looks like a GHC-specific direct C function call
12:27:03 <manveru> sjanssen: like... you select text with the mouse
12:27:07 <sjanssen> desp: I think thats c2hs markup
12:27:11 <manveru> and paste it with middle-click
12:27:16 <desp> OIC. thanks
12:27:18 <sjanssen> manveru: works fine for me
12:27:31 <manveru> oh
12:27:35 <manveru> here it does
12:27:43 <manveru> but i have that problem at work
12:28:04 <manveru> dunno... the configuration should be nearly identical
12:28:25 <sjanssen> xmonad doesn't touch the clipboard at all, could it be something else?
12:28:42 <manveru> there is not much else running
12:28:52 <manveru> i'll see on monday
12:29:07 <desp> manveru: does it work with another wm?
12:29:09 <arcasin> IM IN UR X, MESSING UR CLIPBOARDZ
12:29:11 <manveru> yeah
12:30:51 <manveru> oh well
12:30:53 <tsdh> Hi. I'm trying to compile the X11 bindings, but I always get this error: http://pastebin.ca/529003 Does anyone know what's going on?
12:31:05 <manveru> i'll get back on that when i encounter it again :)
12:31:41 <sjanssen> tsdh: you should bug the Gentoo guys to upgrade to X11 1.2.2, it doesn't have this problem
12:31:50 <sjanssen> tsdh: this is an ebuild from the overlay, yeah?
12:32:01 <sjanssen> tsdh: maybe I'll go bug #gentoo-haskell too :)
12:32:31 <tsdh> sjanssen: It's from my local overlay. Where do I get 1.2.2 from?
12:33:05 <sjanssen> @hackage x11
12:33:05 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/x11
12:34:51 <sjanssen> @hackage X11
12:34:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
12:37:22 <dblhelix> this morning I sent a patch for ghc... does anyone know how I can track it? it's not that important, but I'd like to know whether it was received in good order
12:47:45 <ndm> @src map
12:47:45 <lambdabot> map _ []     = []
12:47:45 <lambdabot> map f (x:xs) = f x : map f xs
12:47:50 <ndm> lies! its a foldr!
12:48:21 <jfoutz> @src foldr
12:48:21 <lambdabot> foldr k z xs = go xs
12:48:21 <lambdabot>     where go []     = z
12:48:21 <lambdabot>           go (y:ys) = y `k` go ys
12:48:49 <dolio> @src sortBy
12:48:49 <lambdabot> sortBy cmp = foldr (insertBy cmp) []
12:48:54 <byorgey> where exactly does @src get its input?
12:49:14 <Heffalump> @src length
12:49:14 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:49:21 <Heffalump> that's weird
12:49:28 <kaol> @version
12:49:29 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
12:49:29 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
12:49:39 <byorgey> @src Prelude length
12:49:39 <lambdabot> Source not found. I feel much better now.
12:49:53 <byorgey> @help src
12:49:54 <lambdabot> src <id>. Display the implementation of a standard function
12:50:03 <dblhelix> @src length
12:50:03 <lambdabot> Source not found. Do you think like you type?
12:50:08 <dblhelix> @src Prelude.length
12:50:08 <lambdabot> Source not found. My pet ferret can type better than you!
12:50:09 <kaol> @type length
12:50:10 <lambdabot> forall a. [a] -> Int
12:50:25 <byorgey> odd
12:50:26 <dolio> That sortBy is from the report, I think. And that foldr is likely not.
12:50:37 <byorgey> @source length
12:50:37 <lambdabot> length not available
12:50:42 <dblhelix> @src GHC.List.length
12:50:42 <lambdabot> Source not found. That's something I cannot allow to happen.
12:50:46 <byorgey> @help source
12:50:46 <lambdabot> source <lib>. Lookup the url of fptools libraries
12:50:49 <jfoutz> is length a primative?
12:50:53 <dblhelix> @hoogle length
12:50:54 <lambdabot> Prelude.length :: [a] -> Int
12:50:54 <lambdabot> Data.PackedString.lengthPS :: PackedString -> Int
12:50:54 <lambdabot> Foreign.Marshal.Array.lengthArray0 :: (Storable a, Eq a) => a -> Ptr a -> IO Int
12:51:11 <byorgey> jfoutz: it's in the Prelude...
12:51:19 <jfoutz> so, no. gotcha
12:51:33 <byorgey> jfoutz: what do you mean by 'primitive'?
12:52:11 <byorgey> it's implemented in terms of more basic things, if that's what you mean
12:52:16 <DRMacIver> Haskell has relatively few primitives outside of the type system.
12:52:21 <jfoutz> well i could imagine some list length accounting to make length faster than just walking down the cons cells.
12:53:02 <byorgey> jfoutz: true, but that doesn't work very well for lazily evaluated lists
12:53:26 * jfoutz ponders...
12:53:55 <DRMacIver> byorgey: Not that ML does anything like that either...
12:53:56 <jfoutz> is there a layer of abstraction that handles memoization?
12:54:47 <dblhelix> @src head
12:54:48 <lambdabot> head (x:_) = x
12:54:48 <lambdabot> head []    = undefined
12:54:52 <dblhelix> @src length
12:54:52 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:55:04 <jfoutz> because, i could also imagine keeping information about lists as they are generated, perhaps to help the garbage collector.
12:55:06 <dblhelix> still, it's strange
12:55:13 <earthy> what?
12:55:15 <ventonegro> @where oleg
12:55:15 <lambdabot> http://okmij.org/ftp/
12:55:19 <dblhelix> @src Data.List.length
12:55:19 <lambdabot> Source not found. I feel much better now.
12:55:26 <dblhelix> @src List.length
12:55:26 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
12:55:43 <byorgey> jfoutz: at that level, I'm not sure
12:55:54 <dolio> length [] = 0 ; length (_:l) = 1 + length l
12:56:14 <dblhelix> @src null
12:56:14 <lambdabot> null []     = True
12:56:14 <lambdabot> null (_:_)  = False
12:56:52 <dblhelix> why does it read null _ = False in the second alternative?
12:57:06 <dblhelix> /s/does/doesn't
12:57:26 <dblhelix> that'd seem more efficient
12:57:36 <earthy> would it?
12:57:53 <earthy> now it's just a case switch on the top level constructor at core level
12:58:13 <jfoutz> i guess, by primative i mean a function that is provided by the runtime environment, rather than being provided by program source, or a library.
12:58:49 <Heffalump> dolio: I'm rather more interested in whether the GHC implementation uses foldl' or not.
12:59:01 <byorgey> jfoutz: right, I see.  I was pretty sure that length isn't primitive, but since we can't seem to find the source... =P
12:59:12 <jfoutz> :)
12:59:13 <dblhelix> earthy: I'm not sure, I guess it does not make a difference
12:59:18 <byorgey> Heffalump: one would hope so...
12:59:40 <Heffalump> does stream fusion work on foldl at all?
12:59:43 <byorgey> thunk (1 + (1 + (1+ (1 + (1+ (1 + ...
12:59:45 <dblhelix> but why oh why can't lambdabot find length?
12:59:56 <dolio> Heffalump: It uses a hand-coded loop, currently.
12:59:56 <byorgey> Heffalump: I think so
13:00:13 <Heffalump> dolio: oh, that was a paste of the real source?
13:00:16 <Heffalump> interesting.
13:00:22 <dolio> Heffalump: Manually unboxing the integer.
13:00:34 <dolio> Heffalump: No, that was a past of the reference implementation in the report.
13:00:39 <Heffalump> ah
13:00:53 <Excedrin> the ghc length uses explicit recursion also
13:01:00 <Excedrin> not fold*
13:01:16 <Excedrin> genericLength is exactly the same as length from the report
13:01:19 <Heffalump> I've been trying to make main = putStrLn $ show $ length [1..10000000] turn into the obvious loop
13:01:34 <Heffalump> it's really quite hard.
13:02:04 <dblhelix> length                  :: [a] -> Int
13:02:05 <dblhelix> length l                =  len l 0#
13:02:05 <dblhelix>   where
13:02:05 <dblhelix>     len :: [a] -> Int# -> Int
13:02:05 <dblhelix>     len []     a# = I# a#
13:02:06 <dblhelix>     len (_:xs) a# = len xs (a# +# 1#)
13:02:16 <dblhelix> that's how it's defined in GHC.List
13:02:43 <byorgey> dblhelix: what are the #'s?
13:02:55 <earthy> unboxed thingies
13:02:55 <byorgey> some sort of strictness annotation or something?
13:03:01 <byorgey> oh, unboxed, ok
13:04:18 <dblhelix> Heffalump: so, it does not use foldl in order to save some boxes
13:04:44 <byorgey> Heffalump: GHC can't optimize that into a loop?
13:04:54 <Heffalump> byorgey: nope
13:05:05 <byorgey> Heffalump: huh
13:05:18 <mauke> .oO( putStrLn . show better written as print )
13:05:23 <Excedrin> how do you view GHC's output?
13:05:25 <Heffalump> mauke: oh yes :-)
13:05:35 <byorgey> @src print
13:05:35 <lambdabot> print x = putStrLn (show x)
13:05:38 <byorgey> heh
13:05:41 <Heffalump> byorgey: well, there's no fusion rule
13:05:47 <Heffalump> [1..n] isn't even a build
13:05:51 <Excedrin> I mean for .hs -> .s
13:06:04 <Heffalump> -keep-s-files or somesuch
13:06:09 <ndm> Heffalump: i can optimise that into a loop with my optimiser
13:06:23 <ndm> entirely automatically, without any RULE's stuff
13:06:23 <Heffalump> ndm: without a special purpose rule?
13:06:26 <Heffalump> nice.
13:06:30 <Heffalump> how does it do it?
13:06:43 <ndm> Heffalump: http://www-users.cs.york.ac.uk/~ndm/downloads/slides-fastest_lambda_first-30_may_2007.pdf
13:06:46 <lambdabot> http://tinyurl.com/3ydml6
13:06:53 <ndm> it uses some clever stuff :)
13:07:06 <ndm> essentially it does church encoding and firstification
13:07:34 <ndm> in fact, the example in my slides is sum [0..n], which is virtually the same as that one
13:08:16 <Heffalump> is oversaturation safe in terms of space leaks?
13:08:36 <ndm> yes, but it may do redundant computation in some cases
13:08:43 <Heffalump> I was playing around with trying to forcibly saturate a foldl rewritten as a higher-order foldr.
13:08:56 <ndm> i.e. it unshares, rather than overshares (which is what space leaks usually are)
13:09:02 <Heffalump> (this is my current on-train project so I got cut off by arriving at the station earlier)
13:09:02 <Excedrin> I'm not sure what I'm looking at here... the generated code from that is really odd
13:09:10 <Heffalump> oh, yes, I meant laziness bugs.
13:09:19 <Heffalump> Excedrin: yes, it's very hard to follow.
13:09:22 <ndm> yeah, it does, if there is a let in the way
13:09:29 <ndm> are you trying to examine Core?
13:09:31 <Heffalump> Excedrin: if you want to understand the code, read the STG or the simplifier output.
13:09:35 <Heffalump> not the assembler
13:09:37 <ndm> -ddump-simple
13:09:42 <Excedrin> ok, thanks
13:09:44 <Heffalump> ndm: that doesn't sound very practical, then.
13:09:47 <dblhelix> ndm: is yhc's rts documented somewhere?
13:09:47 <ndm> thats the most human friendly Core output, by a long way
13:10:11 <dblhelix> how to extract the stg code?
13:10:12 <Excedrin> seems like -ddump-simple is unrecognised
13:10:14 <ndm> dblhelix: yes, http://haskell.org/haskellwiki/Yhc/RTS - very throughly
13:10:15 <lambdabot> Title: Yhc/RTS - HaskellWiki
13:10:33 <dblhelix> ndm: thanks
13:10:34 <ndm> Heffalump: you can analyse, and not do the oversaturation when you break laziness - usually its not important
13:10:59 <dblhelix> ndm: is it comparable to the stg machine?
13:11:04 <ndm> Excedrin: oops, no 'e' at the end, -ddump-simpl
13:11:22 <ndm> dblhelix: its based on the SPJ book on the STG machine, so yes, very similar
13:11:33 <Heffalump> fair enough
13:11:42 <Heffalump> dblhelix: you can dump STG too
13:11:49 <ndm> Heffalump: the laziness/space leak stuff isn't in that presentation, but it is in the tool
13:12:02 <Excedrin> ooo neat
13:12:04 <Heffalump> ndm: sounds cool
13:12:07 <dblhelix> Heffalump: yes, but which flag do I use for that?
13:12:15 <Heffalump> -ddump-stg IIRC
13:12:18 <Heffalump> read the GHC manual :-)
13:12:51 <ndm> section 4.17 is all the flags
13:12:56 <Excedrin> -ddump-simple is post simplifier core, and -ddump-stg is ??
13:12:56 <dblhelix> :-)
13:12:58 <ndm> since Google doesn't index it...
13:13:18 <dblhelix> ndm: do you have a stand-alone implementation of the rts?
13:13:42 <ndm> dblhelix: how do you mean, stand-alone? yhi is our implementation of the STG machine, which is pretty standalone
13:13:53 <ndm> we also have a Java one, a Python one, and sorear has an assembly one
13:14:21 <dblhelix> ndm: can I feed stg source files to it?
13:14:54 <ndm> dblhelix: they must be in Yhc.Bytecode format, so not GHC generated ones, but you can easily write a Yhc.Bytecode assembler (i think someone was doing that at one stage)
13:16:15 <dblhelix> http://www.eecs.tufts.edu/~rdocki01/yhc-bytecode.html?
13:16:16 <lambdabot> Title: Yhc Bytecode API
13:16:21 <ndm> yep, thats the one
13:16:46 <dblhelix> okay, nice
13:18:59 <ndm> doh, IMDb's quotes all have <a name=...> after them, but the id's are really unstable - they change weekly at least
13:51:02 <dainanaki> hey i'm having trouble converting an Int to a Float value. I'm using GHC, and according to the tour of the haskell prelude there is a function called fromInt, but GHC claims that isn't in scope
13:51:05 <dainanaki> what's up?
13:51:25 <dolio> > fromIntegral (3 :: Int) :: Float
13:51:29 <lambdabot>  3.0
13:52:03 <dainanaki> ok thank you
13:52:06 <dolio> There's no fromInt, to my knowledge. At least not currently.
13:52:22 <brad_> confused about something. what is the difference between "let a = [1,2,3]" and "let [a] = [1,2,3]" ?
13:52:38 <dainanaki> there used to be according to at least a couple of documents i have...
13:52:46 <dolio> > let [a] = [1, 2, 3] in a
13:52:47 <lambdabot>   Irrefutable pattern failed for pattern [a]
13:52:50 <mauke> brad_: the latter is an error :-)
13:53:09 <mauke> brad_: let [x,y,z] = [1,2,3] sets x to 1, y to 2, z to 3
13:53:20 <mauke> if they have a different number of elements, the match fails
13:53:24 <brad_> ah, okay thanks mauke!
13:53:38 <brad_> is it any different in a "do
13:53:39 <brad_> "
13:53:50 <brad_> i thought i saw "[a] <- foo" once
13:54:12 <Heffalump> it calls "fail" if the pattern-match fails, rather than "error"
13:54:27 <Heffalump> where fail may depend on the monad in use
13:54:28 <mauke> it's similar, but <- also extracts a value from a monad
13:54:42 <brad_> so basically i should follow the same rules?
13:55:07 <brad_> and only put the correct binding on the LHS regardless of monad or not?
13:56:42 <brad_> well thanks for the info and help! see you later folks.
13:59:27 <kaol> bah. my code, that type checke,d wasn't, after all, magically correct too
14:00:21 <mauke> file a bug!
14:01:17 <masak> GHC just asked me to add type classes to the type signatures until it was happy, whereupon it started to complain about ambiguities between the added type classes
14:01:23 <masak> is this a common scenario?
14:01:30 <masak> what should I do?
14:01:57 <mauke> think about what you actually want it to do?
14:02:03 <masak> yes...
14:02:08 <fbuilesv> Hello, what does the "=>" operator means in expressions like doSomething :: (Monad Someting) => a -> m b  ?
14:02:19 <masak> mauke: I actually think I need to declare both type classes
14:02:33 <mauke> fbuilesv: the => separates class constraints from the rest of the type
14:02:34 <masak> they are Integral and Bits, and I use both in the function
14:02:41 <chessguy> @type (+)
14:02:46 <lambdabot> forall a. (Num a) => a -> a -> a
14:02:58 <chessguy> fbuilesv, here, this means that a must be some member of the type class Num
14:03:20 <kaol> @type (<=)
14:03:22 <lambdabot> forall a. (Ord a) => a -> a -> Bool
14:03:22 <fbuilesv> Excelente, thank you.
14:03:24 <masak> mauke: I guess what I'm not clear about is the "Ambiguous type variable" error message itself
14:03:24 <chessguy> so the => separates the constraint on a from the actual type signature
14:03:25 <mauke> > let f :: (Read a, Show a) => String -> String; f = show . read in f
14:03:26 <lambdabot>      Ambiguous constraint `Show a'
14:03:26 <lambdabot>         At least one of the forall'd type ...
14:03:36 <masak> mauke: are Bits and Integral in conflict in some way?
14:03:42 <masak> what if I want to use both?
14:04:12 <mauke> masak: I need more context to help; can you paste your function somewhere?
14:04:14 <Excedrin> does yhc have an interactive mode?
14:04:24 <masak> mauke: yes. where? hpaste is down
14:04:28 <quicksilver> masak: they are not in conflict, no.. should be fine
14:04:29 <mauke> in general no, Bits and Integral are ok with each other
14:04:36 <mauke> http://rafb.net/paste
14:04:39 <masak> oki
14:05:11 <Excedrin> ah, there's yhe for that
14:06:25 <masak> http://rafb.net/p/QFvsOI60.html
14:06:26 <lambdabot> Title: Nopaste - I can&#039;t explain this error message: Ambiguous type
14:06:40 <masak> Excedrin: yhe?
14:06:50 <mauke> oh, the monomorphism restriction?
14:06:56 <masak> seems so.
14:07:00 <quicksilver> masak: you need to supply a type for g
14:07:04 <quicksilver> masak: it can't work it out
14:07:05 <Excedrin> york haskell evaluator I suppose
14:07:08 <mauke> just do what the message says
14:07:12 <masak> :)
14:07:14 <masak> ok
14:07:14 <quicksilver> masak: [Int] or [Integer] perhaps
14:07:23 <monochrom> the monomorphism restriction is a long story.
14:07:30 <mauke> or (Bits a, Integral a) => [a]
14:07:35 <quicksilver> or that
14:07:44 <quicksilver> if you really want the fully generic version
14:08:27 <masak> it works better now :)
14:08:39 <masak> thx
14:09:04 <masak> I now get a warning about lines 9 and 10
14:09:15 <masak> that the cases are overlapping -- which they are
14:09:24 <masak> should I write it differently somehow?
14:10:31 <quicksilver> overlapping cases are not bad style, IMO
14:10:35 <quicksilver> I find that warning annoying :)
14:10:41 <masak> ok :)
14:10:48 <masak> but is there an alternative?
14:10:50 <mauke> quicksilver: huh?
14:10:51 <quicksilver> I think overlapping cases are a perfectly sensible way to write code
14:10:56 <mauke> how so?
14:11:04 <lumi> masak: That doesn;t say what you mean
14:11:10 <Procyon112> chessguy: Oleg's configuration concept for ints/strings looked very good.  His config concepts for functions I wasn't thrilled with.
14:11:21 <quicksilver> mauke: nothing wrong in my opinion, with case x of Foo -> ... | Bar -> ... | _ -> ...
14:11:35 <chessguy> Procyon112, yeah, it may be overkill for what we need
14:11:37 <masak> lumi: please explain
14:11:38 <lumi> case x of { n -> blah} doesn't mean x == n
14:11:43 <mauke> quicksilver: he has case x of n -> ... | n + 1 -> ... | _ -> ...
14:11:47 <masak> lumi: oh.
14:12:03 <quicksilver> masak: I was talking about overlapping cases in general
14:12:07 <quicksilver> mauke: that was for you
14:12:08 <mauke> quicksilver: also, how is your code overlapping?
14:12:31 <Procyon112> chessguy: if anything, that stuff belongs in a runtime configuration library, not ours :)
14:12:46 <chessguy> fbuilesv, ya has encontrado a #haskell.es?
14:12:56 <lumi> masak: It's a pattern match, maybe you should replace it with 'if x == n' or so
14:12:57 <masak> guess I shouldn't use case at all then
14:13:08 <masak> lumi: right. I'll try that
14:14:36 <Botje> lumi: I thought that was how case expressions were compiled?
14:14:42 <Botje> blah
14:14:45 <Botje> nm, misread.
14:14:57 <fbuilesv> chessguy, yes :d
14:15:05 <chessguy> ok, good
14:15:10 <mauke> masak: http://rafb.net/p/kGI2bJ51.html
14:15:11 <lambdabot> Title: Nopaste - No description
14:15:21 <fbuilesv> chessguy, how'd you notice?
14:15:42 <chessguy> you said 'excelente' :)
14:15:58 <fbuilesv> :O
14:16:10 <fbuilesv> the chan. is dead most of the time anyway :P
14:16:13 <masak> mauke: nice. that's a cuter version of what I just wrote :)
14:16:20 <chessguy> yeah, unfortunately
14:16:34 <masak> though I'm sort of hoping for some builting prelude function to turn up and do all that work for me...
14:16:52 <chessguy> i have a hard enough time following haskell discussions in english, much less another language ;)
14:17:31 <fbuilesv> hehe
14:18:16 <monochrom> I can follow it in Chinese.
14:19:17 <masak> monochrom: æä¹å¯ä»¥
14:19:27 <monochrom> Oh no. :)
14:19:30 <masak> :)
14:19:32 <fbuilesv> O_O
14:19:37 <masak> though I'm not Chinese
14:19:37 <fbuilesv> ni hao
14:19:45 <masak> fbuilesv: hiya
14:19:46 <monochrom> He wrote "so can I" :)
14:20:00 <Procyon112> We got lifted into MonadChinese
14:20:10 <fbuilesv> that's all my understanding of chinese :P
14:20:11 <mauke> I read that as MonadCheese :(
14:20:18 * masak just discovered input methods in Emacs and is in heaven
14:20:19 <Procyon112> mmm... MonadCheese
14:20:22 <chessguy> @quote cheeseguy
14:20:22 <lambdabot> cheeseguy says: what the heck is so hard about spelling chess? it's C H E S S. 5 letters! not chees, or cheese, or chsesesseee or any other such combination
14:20:45 <fbuilesv> oh, its chess, not cheese...
14:20:52 <mauke> hahaha
14:20:52 <dolio> @fact chessguy
14:20:52 <lambdabot> chessguy: is not cheeseguy
14:20:55 <chessguy> MonadChess ftw!
14:21:01 <monochrom> MonadChess may be a good project.
14:21:02 <chessguy> @help fact
14:21:02 <lambdabot> fact <fact>, Retrieve a fact from the database
14:21:14 <fbuilesv> @help me
14:21:15 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:21:23 <fbuilesv> smart bot...
14:21:25 <chessguy> @fact Procyon112
14:21:26 <lambdabot> I know nothing about procyon112
14:21:37 <masak> monochrom: ææ¯çå¸ä¸­æçå­¦ç
14:21:51 <monochrom> Ah, sweet.
14:21:56 <dolio> There aren't many facts, so you're unlikely to find one by guessing.
14:22:05 <masak> monochrom: been studying for a year now
14:22:44 <Procyon112> do x <- getCheese; return . eat x
14:22:49 <monochrom> I don't think anyone has translated "monad" to Chinese.
14:23:15 <monochrom> But nevermind! We can just skip to "arrow".
14:23:29 <masak> :)
14:23:34 <lumi> Procyon112: You're a $ short!
14:23:44 <Procyon112> damn.  foiled again.
14:23:45 <dolio> eat `fmap` getCheese
14:23:48 <mauke> liftM eat getCheese
14:24:40 <monochrom> Some mathematician has translated "monoid" to Chinese. I think we can just vary that a bit for "monad".
14:25:00 <Procyon112> Yeah.. add an extra squiggly or something :)
14:26:24 <chessguy> just don't make it too squiggly or you'll suddenly be referring to your neighbor's uncle's pet monkey
14:26:56 <chessguy> which is unlikely to be monadic
14:27:22 <Procyon112> You don't wan't to be in your neighbor's uncle's monad... trust me.
14:27:52 <masak> chessguy: it might be too late to add squigglies... they'd have to revise the Unicode tables, which I hear is a lot of work
14:27:56 <Procyon112> You can't get out of it without an unsafePerformMonkey
14:28:03 <byorgey> Procyon112: lol!
14:28:34 <byorgey> Procyon112: I'm at work, too, so all my coworkers probably think I'm strange now
14:28:42 <Procyon112> hehe
14:28:52 <byorgey> not that they didn't already, I suppose... =)
14:29:36 <wchogg> Oh those poor monkeys.
14:30:20 <chessguy> byorgey, you'll be fine, just don't go all ape on them
14:31:14 <byorgey> well, I was just reading about bananas the other day...
14:31:25 <monochrom> Most squiggol symbols are already in unicode.
14:38:30 <Procyon112> @quote bubblesort
14:38:30 <lambdabot> No quotes match. Maybe if you used more than just two fingers...
14:38:40 <chessguy> @quote sort
14:38:40 <lambdabot> DRMacIver says: The number of genocides committed in sorting your array is asymptotically finite.
14:40:10 <chessguy> words to live by
14:42:59 <kaol> @hoogle (a -> Bool) -> [a] -> [[a]]
14:43:00 <lambdabot> No matches, try a more general search
14:43:16 <chessguy> @hoogle groupBy
14:43:17 <lambdabot> List.groupBy :: (a -> a -> Bool) -> [a] -> [[a]]
14:47:54 <fbuilesv> Did anyone took over the RSS/Atom aggregator (http://hackage.haskell.org/trac/summer-of-code/ticket/73) SoC project? Or, is someone planning to do it?
14:47:55 <lambdabot> Title: #73 (ATOM/RSS aggregator with GTK UI capable of handling big number of subscript ...
14:48:00 <brad_> can anyone give me a good short example of how to use Either?
14:48:23 <mauke> > Just 'x'
14:48:25 <lambdabot>  Just 'x'
14:48:31 <lumi> > Left 1
14:48:32 <lambdabot>  Left 1
14:48:35 <mauke> wait, that was Maybe
14:49:02 <brad_> like i have a function that returns an Either type
14:49:11 <brad_> for example, Either Bool String
14:49:15 <mauke> ok
14:49:26 <brad_> not sure how to get the results out and test for them
14:49:45 <mauke> case f x of Left b -> ...; Right s -> ...
14:49:57 <mauke> or use a function that does it for you
14:50:00 <mauke> @type either
14:50:02 <lambdabot> forall a c b. (a -> c) -> (b -> c) -> Either a b -> c
14:50:21 <brad_> okay mauke! that makes sense. thanks!
14:50:34 <fbuilesv> k
14:50:38 <dansa> I want to take a string such as "2.4" and write to a file a IEEE 754 floating point representation of that number. What would be the best way to acomplish that?
14:51:13 <Heffalump> how portable do you want this to be?
14:51:38 <mauke> @instance Storable
14:51:38 <Heffalump> there's no guarantee that the native types are IEEE representations, but in practice in GHC (at least) they are
14:51:38 <lambdabot> Maybe you meant: instances instances-importing
14:51:43 <mauke> @instances Storable
14:51:44 <lambdabot> Couldn't find class `Storable'. Try @instances-importing
14:51:58 <Heffalump> but I can also give you some code that explicitly constructs the IEEE representation
14:52:03 <mauke> @instances-importing Foreign.Storable Storable
14:52:04 <lambdabot> Bool, Char, Double, Float, Int
14:52:18 <kaol> > unfoldr (\b -> case b of "" -> Nothing ; b -> Just $ let (x,y) = span (/= ' ') b in (x,tail y)) "hello world again " -- good enough for me
14:52:19 <lambdabot>  ["hello","world","again"]
14:52:43 <mauke> > words "hello  world again "
14:52:44 <lambdabot>  ["hello","world","again"]
14:52:47 <dansa> Heffalump, hm, that should be ok for now
14:53:09 <Heffalump> dansa: which?
14:53:39 <dansa> the first option, unless there's already some library out there that will portably create the ieee 754 binary representation for me
14:53:56 <Heffalump> I have written code that can do it, but it's not in a standalone library
14:54:06 <Heffalump> but you're welcome to the code
14:54:17 <kaol> @type words
14:54:19 <lambdabot> String -> [String]
14:54:28 <Heffalump> for the first option, you have to play some games with unboxed things and unsafeCoerce#
14:56:02 <dansa> hm, I'd like to take a look in your code, if you can show it to me.
14:56:34 <Heffalump> ok, hangon a bit
14:56:35 <dansa> but I'm interessed in knowing the other way also, the unboxed things you're talking about is this: http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Array-Unboxed.html ?
14:56:37 <lambdabot> http://tinyurl.com/38qe2d
14:56:57 <Heffalump> no, lower level than that
14:57:01 <Heffalump> that stuff is unboxed arrays
14:57:16 <Heffalump> the underlying unboxed primitive types are in GHC.Exts and GHC.Word IIRC
14:57:23 <Heffalump> I have code that does both, anyway
14:57:39 <Heffalump> at least I will once I get it off my laptop
15:00:47 <monochrom> I'm stupid!  I enter "newtype X a = ReaderT Blah (State Foo) a" and get "kind error for State".  It is because the computer thought ReaderT was the name I gave for the new data constructor, not knowing I meant *the* ReaderT!  It should be "newtype X a = X (ReaderT Blah (State Foo) a)".
15:03:50 <mauke> splat x = map cc . unsafePerformIO . with x $ \p -> peekArray (sizeOf x) (castPtr p)
15:04:04 <mauke>  where cc :: CUChar -> Char; cc = toEnum . fromEnum
15:09:18 <Heffalump> dansa: oh, sorry, my code just does the reading side. Haven't got round to the writing side yet.
15:09:42 <Heffalump> @paste
15:09:42 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:09:45 <Heffalump> hah
15:10:25 <Heffalump> http://pastebin.ca/529391
15:10:35 <Heffalump> the commented out code decodes the IEEE rep explicitly
15:10:51 <Heffalump> the uncommented code uses unsafeCoerce# to cast it - readItem is something of mine
15:10:58 <Heffalump> you can do the reverse cast quite easily
15:12:01 <iskaldur> could someone help me install darcs on my macbook?
15:12:47 <roconnor> #darcs ?
15:12:56 <iskaldur> ah, okay
15:14:48 <dansa> hm, I see, thanks
15:18:23 <Saizan> uhm, i can easily host an hpaste on hpaste.no-ip.org if it's useful..
15:22:53 <sorear> hello.
15:24:39 <Heffalump> 'lo
15:30:29 <olsner> 683 new messages in #haskell while I was gone, wow
15:31:04 <byorgey> I tried to tell them to wait for you, but... sheesh
15:32:01 <mux> heh, there's that huge thread on the mathematical and philosophical reasons for False < True
15:32:14 <mux> I mean, in haskell-cafe
15:35:17 <Saizan> i think it's just silly.. a Boolean algebra is a preorder, where the "max" element is denoted by 1 and the "min" is 0, if you use "and" and "or" you have True and False, it just derives from the lattice structure and a bit of convention
15:35:21 * byorgey reads about Arrows
15:35:27 * byorgey 's brain is happy
15:36:11 <fasta> Saizan: "where the "max" element is denoted by 1"?
15:36:27 <fasta> Saizan: by who?
15:36:54 <DRMacIver> Boolean algebras form a ring. The max element is the multiplicative identity of that ring, the minimum element the additive identity.
15:37:05 <DRMacIver> It is conventional to denote multiplicative identities by 1, additive by 0.
15:37:21 <fasta> DRMacIver: that's notation.
15:37:29 <DRMacIver> Sure
15:37:31 <fasta> DRMacIver: 1 the number is not one the boolean
15:37:32 <Saizan> yeah, i was referring to that
15:37:34 <DRMacIver> But it's a notation that makes sense.
15:38:00 <fasta> The notation is not relevant, imho.
15:38:47 <fasta> Hmm, never mind.
15:38:49 <Saizan> fasta: uhm yes, but still False < True in the order
15:39:13 <fasta> Saizan: I misunderstood the first time.
15:39:20 <fasta> Saizan: I agree :)
15:40:28 <fuzan> hmm, what is the impact of laziness on the naive fib algorithm?: fib n = fib (n-1) + fib (n-2) ?
15:40:52 <fasta> fuzan: zero?
15:40:53 <fuzan> i was under the impression that it'd be o(2^n) -> o(n),
15:41:13 <Heffalump> laziness is not memoisation
15:41:18 <fasta> fuzan: that would be a wrong impression
15:41:32 <Botje> fuzan: laziness is abot not doing more than you have to
15:42:23 <sorear> WHY do so many people thing purity->memoization!?
15:42:29 <fasta> fuzan: even a + a can take time: time(a) + time(a)
15:42:33 <Saizan> fuzan: you'd need to make sharing explicit, a bit hard starting from that definition
15:42:41 <Botje> because it IS one of the possible advantages.
15:42:42 <DRMacIver> sorear: It's a common lie from zealots trying to promote purity.
15:42:57 <sorear> DRMacIver: Agreed.
15:42:59 <Botje> I seem to have a vague recollection of cobol doing automatic memoisation
15:43:03 <DRMacIver> sorear: OMG! Purity is so awesome because it lets the compiler memoise your functions and give you stuff for free!!!
15:43:04 <Saizan> laziness would probably make things worse by building a huge arithmetic thunk
15:43:18 <sorear> DRMacIver: Can we ban him, please?
15:43:28 <DRMacIver> 'him'?
15:43:37 <Botje> hmm
15:43:38 <Saizan> sorear: it's spread over the intarweb :D
15:43:49 <Botje> I wonder what would happen if you could tell the compiler to memoise a function.
15:43:57 <Botje> "hai compilar, memoise this kthx"
15:44:06 <Heffalump> you'd get memoised functions
15:44:18 <Heffalump> but you'd have to specify an expiry policy for the memo-table
15:44:19 <fuzan> haha, i think you guys missed the point.
15:44:25 <mux> sorear: I think it stems from the fact that some tutorials mention memoization as one of the advantage of purity, int that it allows it (they probably use that example because it's easy for people to figure it out)
15:44:29 <Heffalump> or you'd get memoised functions and then a massive memory blowup
15:44:36 <mux> sorear: I'm guilty myself of thinking such a thing
15:44:47 <mux> and I'm pretty sure I didn't invent it :-)
15:44:49 <byorgey> fuzan: ok, what
15:44:56 <Botje> i'm thinking a binary tree with a fixed number of nodes
15:44:57 <mux> nor do I think I'm a zealot :-P
15:44:57 <byorgey> 's your question then?
15:45:02 <Botje> should work
15:45:15 <byorgey> stupid Enter key... grumble
15:45:19 <fuzan> byorgey: there's obviously SOME computation being saved. if it's not simple previous computations, what is it?
15:45:29 <Heffalump> fuzan: in what, laziness?
15:45:30 <fasta> fuzan: we missed the point?
15:45:42 <byorgey> fuzan: computation only gets saved if it turns out to be unnecessary
15:45:42 <Heffalump> the computation that is saved is just things whose result is never used
15:45:43 <sorear> fuzan: Essentially, GHC memoizes 0-argument functions only
15:45:46 <Heffalump> in your example of fib, nothing
15:46:04 <sorear> In your example of fib, less than nothing.
15:46:15 <fuzan> i think that would have been a more valid answer as opposed to 13 year old goto-bashing.
15:46:36 <sorear> Going back up to nothing if you use -O
15:46:42 <byorgey> fuzan: sorry about that, I don't think any offense was meant =)
15:46:55 <fuzan> byorgey: i know :)
15:47:00 <mux> doesn't GHC do more memoization for top-level functions or something?
15:47:25 <byorgey> fuzan: a (very simple) example of computation actually being saved:
15:47:30 <sorear> mux: GHC memoizes all 0-arg functions
15:47:33 <byorgey> > sum . take 10 $ [1..]
15:47:35 <lambdabot>  55
15:47:42 <sorear> f = 2 + 2  -- will only be calculated once
15:47:50 <Heffalump> what's a 13 year old goto?
15:48:03 <fuzan> Heffalump: "GOTO STATEMTZ? OMGZ, NOOB"
15:48:03 <fasta> Heffalump: you are too old for that
15:48:04 <mux> okay, that explains the "memoized" variants of some code I've seen
15:48:17 * fasta is too old too. 
15:48:31 <fuzan> sorear: that's no different than constant folding.
15:48:42 <Heffalump> of course, only top-level things are likely to stay around for a long time
15:48:50 <fuzan> sorear: and copy propogation? i think that's the term.
15:49:05 <byorgey> fuzan: in my example above, the infinite list doesn't need to be calculated, since only ten elements are used
15:49:10 <fasta> fuzan: if you are looking for an optimizing compiler don't look at GHC.
15:49:20 <fasta> fuzan: GHC does some smart stuff, but not all.
15:49:27 <DRMacIver> fuzan: My comment wasn't really directed at you. It was an expression of irritation at why the "purity lets you memoise" meme gets perpetrated.
15:49:38 <infrared> won't fibonacci definition as a infinite list enable memoization?
15:49:46 <fuzan> byorgey: yah, i'm not that naive. :) i think i just have a few minor preceptions of laziness and automatic memoization.
15:49:46 <Heffalump> yes
15:50:00 <byorgey> fuzan: fair enough. =)
15:50:17 <fuzan> preconceptions? my english sucks.
15:50:39 <byorgey> fuzan: preconceptions, yes.
15:51:00 <Heffalump> if you can sensibly make the domain of your function an array index, you can easily memoise a function
15:51:49 <dcoutts> or Ord and you can use a Map
15:52:08 <Heffalump> I thought of that, but the Map would be huge.
15:52:24 <dcoutts> depends on the domain of your function
15:52:27 <Heffalump> well, I guess there may be small things that are Ord not Ix
15:52:43 <Heffalump> actually, I guess it wouldn't be that huge
15:52:46 <Heffalump> even Int would be ok
15:53:12 <kaol> what's the haskell equivalent of printf("%.2f",foo); (where foo is a float)? plain show results in a whole lot of decimals.
15:53:48 <fasta> @hoogle print
15:53:49 <lambdabot> Prelude.print :: Show a => a -> IO ()
15:53:49 <lambdabot> Text.Printf.Print :: class Print
15:53:49 <lambdabot> Text.Printf.printf :: PrintfType r => String -> r
15:54:12 <fasta> I don't know how convenient printf is to use in Haskell, though.
15:54:17 <dcoutts> kaol: showFFloat and the other two similar ones, from the Numeric module
15:54:21 <fasta> I thought it was, though.
15:54:31 <fuzan> > printf "%.2f" 10.4212512
15:54:32 <lambdabot>  Add a type signature
15:54:37 <dcoutts> > showFFloat (Just 2) 10.4212512
15:54:38 <lambdabot>  <[Char] -> [Char]>
15:54:41 <Saizan>  > printf "%.2f" 10.4212512
15:54:41 <dcoutts> > showFFloat (Just 2) 10.4212512 ""
15:54:42 <lambdabot>  "10.42"
15:54:48 <Saizan> > printf "%.2f" 10.4212512 :: String
15:54:49 <lambdabot>  "10.42"
15:55:00 <Saizan> or you can also use IO () as a type
15:55:19 <kaol> ok, either will do nicely. thank you.
15:55:21 * dcoutts does not believe in printf
15:55:41 <fuzan> alright, thanks for correcting my flawed logic, time to starcraft :)
15:55:43 <Saizan> dcoutts: why not? too many class dictionaries?
15:55:52 <fasta> > printf "%f %i" 10.1 10 ::String
15:55:54 <lambdabot>  Exception: Printf.printf: bad formatting char i
15:55:59 <dcoutts> Saizan: too much runtime interpretation
15:56:19 <fasta>  > printf "%f %d" 10.1 10 ::String
15:56:21 <Saizan> uhm yeah, no safety
15:56:27 <byorgey> fasta: everyone knows that the format string for ints is d.  Obviously. =P
15:56:43 <mux> C also accepts %i :-)
15:56:44 <dcoutts> well it's safe in the sense of runtime type checking
15:56:53 <sorear> it's perfectly safe
15:56:53 * Saizan thinks TH could ease this, also for checking regexes
15:56:58 <byorgey> mux: really?  amazing, I never knew that
15:57:06 <dcoutts> > printf "nasty dynamic type checking" :: String
15:57:07 <lambdabot>  "nasty dynamic type checking"
15:57:08 <kaol> there's ready library functions for everything, apparently. I just don't quite know where to go looking for them, yet.
15:57:13 <fasta> byorgey: I had %i and %d.
15:57:38 <fasta> > printf "%f %d" 10.1 10 ::String
15:57:39 <lambdabot>  "10.1 10"
15:58:18 <byorgey> fasta: I was just sarcastically commenting on the silliness of %d as a format specifier =)
15:58:42 <jfoutz> printf ("%f" ++ " " "%d") 1.1 10 ::String
15:58:47 <jfoutz> >printf ("%f" ++ " " "%d") 1.1 10 ::String
15:58:54 <fasta> byorgey: I don't think %d is silly.
15:58:59 <jfoutz> > printf ("%f" ++ " " "%d") 1.1 10 ::String
15:58:59 <lambdabot>  Couldn't match expected type `t -> [Char]'
15:59:00 <fasta> byorgey: why do you think it is?
15:59:17 <jfoutz> > printf ("%f" ++ " " ++ "%d") 1.1 10 ::String
15:59:18 <lambdabot>  "1.1 10"
15:59:26 <jfoutz> gah. sorry about the lambdabot spam.
15:59:33 <fasta> What I don't get is why we in Haskell need to specify the type (%f or %d)?
15:59:43 <byorgey> fasta: I don't know, maybe it does... I just think %i is more intuitive
15:59:59 <byorgey> fasta: when I want to print out an int, I'm usually not thinking about the fact that it's in base 10
16:00:12 <jfoutz> it should be a formatting rule, not a type rule...
16:00:22 <jfoutz> > printf ("%f" ++ " " ++ "%d") 1 10.1 ::String
16:00:22 <byorgey> jfoutz: fair enough
16:00:23 <lambdabot>  Exception: Printf.printf: bad argument
16:00:30 <jfoutz> but, it's not :)
16:00:47 <Heffalump> cos it's called printf
16:00:52 <byorgey> well, since I try to avoid writing code in C at all costs, I guess it's a moot point =)
16:02:03 <jfoutz> it's super handy when string concatination is hard. it's also nice for formatting. beyond that... i don't know.
16:04:26 <byorgey> jfoutz: I would argue that printf's usefulness for formatting is largely irrelevant these days... no one is much interested in precise formatting of text as text anymore...
16:04:45 <byorgey> if you want formatting, you use some sort of higher-order representation, like PDF or HTML or...
16:05:54 <mux> what about text protocols?
16:06:02 <mux> there are cases where you need precise formatting
16:06:19 <byorgey> mux: hmm, I guess you're right
16:09:29 <dmwit> :i Rational
16:10:02 <desp> how would you recreate a C enum in Haskell, for passing to FFI functions?
16:10:33 <dmwit> Maybe with a .hsc file?
16:10:37 <desp> I would ideally like to create a type that happens to be equal in size to CInt, and have numeric constructors
16:10:41 <dmwit> (But I don't understand them all that well.)
16:11:45 <mauke> what do you mean by "numeric constructors"?
16:12:21 <desp> mauke: a Haskell data type, with constructors Foo and Bar, that happen to actually be integer values
16:12:33 <desp> mapping onto the enum values on the C side
16:12:35 <mauke> huhu, "actually be"
16:12:49 <Heffalump> desp: C enums are not guaranteed to be int-sized are they?
16:12:50 <desp> yeah, a lot of wishful thinking
16:12:52 <mauke> that's just a matter of defining the right Storable instance
16:12:53 <desp> Heffalump: they are
16:13:08 <desp> in ANSI C, at least
16:13:10 <mauke> just implement Enum and Storable
16:13:19 <Heffalump> ok, perhaps not in C99
16:14:27 <desp> Heffalump: then FFI is missing a CEnum type :)
16:14:48 <dcoutts> Heffalump: I'd be surprised, C99 made the spec stricter in various ways, like adding fixed with ints, increasing limits etc
16:15:04 <dcoutts> I'd be surprised if they relaxed the types that enums fit into
16:16:08 <int-e> dcoutts: "[#4] Each enumerated type shall be compatible with an integer type. The choice of type is implementation-defined, but shall be capable of representing the values of all the members of the enumeration. The enumerated type is incomplete until after the } that terminates the list of enumerator declarations."
16:16:15 <int-e> dcoutts: says my copy of the draft.
16:16:28 <mux> that has been this way since long, I believe
16:16:28 <mauke> desp: each enum can have a different base type
16:16:44 <dcoutts> so it's some integral type, int, or long, or long long
16:16:58 <int-e> don't forget char and short
16:17:04 <dcoutts> yeah, or something smaller
16:17:20 <desp> interesting.
16:17:23 <mauke> char, signed char, unsigned char, short, unsigned short, int, unsigned int, long, unsigned long, long long, unsigned long long
16:17:27 <desp> so, blah
16:17:41 <mauke> or something funky like ptrdiff_t, intptr_t, or size_t
16:17:41 <desp> very blah.
16:18:12 <desp> mauke: could you point me in the right direction towards implementing Enum/Storable?
16:18:24 <mauke> huh? what's the problem
16:18:33 <desp> mauke: I'm not sure what you mean :)
16:18:35 <ddarius> @index Storable
16:18:35 <lambdabot> Foreign.Storable, Foreign
16:18:39 <mauke> for Enum it's probably just ... deriving (Enum)
16:18:41 <ddarius> @doc Foreign.Storable
16:18:41 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Foreign-Storable.html
16:19:12 <dcoutts> mauke: I'm not sure if those are allowed to be new fundamental types or just typedefs of other types
16:19:33 <mauke> AFAIK they can be new types
16:20:14 <fbuilesv> When parsing XML (RSS and Atom feeds), what's _the_ librayr? I'm seeing HaXML and HXml Toolbox but I don't know if I should pick a particular one.
16:21:27 <dcoutts> fbuilesv: they're different libs, you have to pick one
16:21:54 <fbuilesv> dcoutts: I know, but I'm wondering if there was any advantage of using one over the other
16:22:07 <fbuilesv> At least looking to know your opinions on it.
16:22:25 <dmwit> let doesn't end a do block, does it?
16:22:26 <dcoutts> I use HaXml, but I don't know much about HXT, so I can't give you any comparison
16:22:36 <dcoutts> dmwit: no
16:22:38 <dmwit> I'm confused about an error I'm getting.
16:23:10 <int-e> dmwit: no it doesn't.
16:24:39 * rt sighs.
16:24:47 <rt> i'm glad the weekend has nearly arrived.
16:25:51 <int-e> dmwit: but there's a confusing interaction between let in do and explicit layout: do let a = 1; return a  is wrong and has to be written as  do let { a = 1 }; return a
16:26:15 <dmwit> What's a good paste place?
16:26:21 <int-e> @where paste
16:26:21 <lambdabot> http://hpaste.org/new
16:26:38 <dmwit> heh
16:26:44 <dmwit> Doesn't work.
16:26:54 * notsmack gasps
16:26:58 <int-e> oh. paste.lisp.org then?
16:27:09 <mauke> http://rafb.net/paste
16:27:48 <dmwit> http://paste.lisp.org/display/42130
16:28:35 <int-e> dmwit: count your )
16:28:56 <mauke> unbalanced )
16:28:56 <dmwit> Nice, thanks.
16:29:24 <desp> looks like you need a real editor ;)
16:29:53 <fbuilesv> dcoutts: Before I forget, don't you think the Gtk2HS tutorial needs a "widgetShowAll window" in the source code examples?
16:30:04 <rt> what, you mean like "vi"?
16:30:09 * rt ducks.
16:30:14 <dmwit> Oh, vim isn't a real editor any more?
16:30:18 <dcoutts> fbuilesv: in which tutorial exactly? the glade one?
16:30:32 <fbuilesv> dcoutts: Yes, sorry, missed that part :P
16:30:38 <desp> dmwit: my vim does paren matching ;) but I was just kidding
16:30:43 <dcoutts> fbuilesv: I think by default glade sets windows as visible
16:30:45 * mux hands dmwit the % key in vim :-)
16:31:04 <dmwit> mux: Yeah, that's how I found the error... once I knew what it was. =)
16:31:14 <mauke> dmwit: vim 7?
16:31:18 <fbuilesv> dcoutts: Not with 3.0.2 in the Ubuntu package at least.
16:31:19 <dmwit> 6
16:31:27 <fbuilesv> I gotta explicitly set it for each example
16:31:29 <mux> mauke: I'm disabling this auto-hilight feature in vim 7
16:31:33 <mauke> yeah, paren matching is new in 7
16:31:34 <dcoutts> fbuilesv: so unless that's changed in glade 3, then I think the tutorial is ok, though it might be better to do it explicitly since it might confuse people when creating widgets in code
16:31:36 <mux> I find it quite disturbing
16:31:39 <mauke> mux: why?
16:31:44 <mux> it's not new in vim 7, what is new is the auto-hilight
16:31:49 <mux> even vim 6 has %
16:31:54 <dcoutts> fbuilesv: ok, lemme check my glade too, it may well have changed in version 3
16:32:06 <mauke> I like the highlighting better
16:32:20 <mux> it disturbs me and I don't really need it
16:32:30 <mux> I tend to lose track of my cursor with it
16:32:46 <mauke> what kind of highlighting are you using?
16:32:59 <mux> what do you mean what kind of hilighting?
16:33:20 <dcoutts> fbuilesv: yep, default now seems to be not visible
16:33:29 <mauke> I've set it to underline matching parens
16:33:38 <mauke> my cursor is a block
16:33:45 <mauke> so there's no conflict
16:34:02 <mux> mauke: I don't care enough to change the default highlighting, I'm happy without the feature really :-) I like to hit % when I'm in doubt, and it's enough for me
16:34:09 <fbuilesv> dcoutts: Just wanted to let you know :d
16:34:17 <dcoutts> fbuilesv: thanks
16:34:39 <mauke> hi MatchParen NONE
16:34:40 <mauke> hi MatchParen term=underline cterm=underline gui=underline
16:34:42 <fbuilesv> np
16:44:51 <desp> mauke: this is exactly what I meant with those numeric constructors earlier: http://pastie.textmate.org/67100
16:44:53 <lambdabot> Title: #67100 - Pastie
16:45:18 <mauke> those aren't constructors
16:45:25 <desp> yes, this is faking it
16:45:28 <mauke> and you get no type safety
16:45:32 <desp> of course
16:45:41 <desp> but can I achieve this effect with Storable?
16:45:46 <mauke> yes
16:46:15 <mauke> Storable says how to serialize your values into an array of bytes
16:46:20 <mauke> which is what the C side receives
17:12:07 <byorgey> @hoogle swap
17:12:11 <lambdabot> Control.Concurrent.MVar.swapMVar :: MVar a -> a -> IO a
17:12:11 <lambdabot> Control.Concurrent.STM.TMVar.swapTMVar :: TMVar a -> a -> STM a
17:12:11 <lambdabot> System.Win32.Info.sM_SWAPBUTTON :: SMSetting
17:13:52 <LoganCapaldo> @type fst &&& snd
17:13:54 <lambdabot> forall a b. (a, b) -> (a, b)
17:14:02 <mauke> :t uncurry (flip (,))
17:14:04 <lambdabot> forall b a. (a, b) -> (b, a)
17:14:49 <LoganCapaldo> @type snd &&& fst -- I meant this of course
17:14:51 <lambdabot> forall a b. (a, b) -> (b, a)
17:15:05 <bogdan> hey.
17:15:17 <bogdan> how can I convert a list of integers to a string?
17:15:25 <bogdan> is there any predefined function?
17:15:33 <LoganCapaldo> > show [1,2,3]
17:15:34 <lambdabot>  "[1,2,3]"
17:15:38 <bogdan> thanks :-)
17:16:33 <byorgey> bogdan: anything which is an instance of Show (which includes lots of things) can be converted to a string using the show function.
17:17:32 <LoganCapaldo> @type map ord
17:17:34 <lambdabot> [Char] -> [Int]
17:17:46 <LoganCapaldo> @type map chr
17:17:47 <bogdan> byorgey: yes, thank you. :)
17:17:48 <lambdabot> [Int] -> [Char]
17:17:59 <LoganCapaldo> > map chr [65,66,67]
17:18:00 <lambdabot>  "ABC"
17:18:31 <LoganCapaldo> @hoogle a -> String
17:18:31 <lambdabot> Prelude.show :: Show a => a -> String
17:18:32 <lambdabot> Text.Html.prettyHtml :: HTML html => html -> String
17:18:32 <lambdabot> Text.Html.renderHtml :: HTML html => html -> String
17:18:36 <byorgey> unwords . map show $ [1..5]
17:18:49 <byorgey> > unwords . map show $ [1..5]
17:18:51 <lambdabot>  "1 2 3 4 5"
17:19:22 <byorgey> hmm, I wonder how many sensible ways there are to "convert a list of integers to a string"? =)
17:19:38 <LoganCapaldo> A lot, I'm sure
17:20:11 <dmwit> ?hoogle [a] -> Int -> Maybe a
17:20:11 <lambdabot> No matches, try a more general search
17:20:38 <dmwit> :t \n -> listToMaybe . take 1 . drop n
17:20:40 <lambdabot> forall a. Int -> [a] -> Maybe a
17:22:17 <br1> @type &&&
17:22:19 <lambdabot> parse error on input `&&&'
17:22:25 <dmwit> :t (&&&)
17:22:26 <br1> @type (&&&)
17:22:27 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:22:29 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
17:22:35 <br1> hehe
17:22:37 <br1> thx
17:23:45 <br1> I'm studying a book on categories, data types and fixed points. What's the "!" function?
17:23:53 <dmwit> Array indexing.
17:24:02 <dmwit> It's like (!!) for lists.
17:24:04 <chessguy> @src (!)
17:24:05 <lambdabot> arr@(Array l u _) ! i = unsafeAt arr (index (l,u) i)
17:24:06 <dmwit> > [1..5] !! 3
17:24:07 <lambdabot>  4
17:24:39 <dmwit> It's also used for map indexing, and a few others.
17:24:51 <br1> can't be.  I'm not in haskell land, but in the Set category.  I think it's inclusion or something equally simple.
17:25:07 <dmwit> o
17:25:13 <dmwit> How about some context?
17:25:15 <chessguy> maybe ask #math
17:25:39 <chessguy> @hoogle unsafeAt
17:25:40 <lambdabot> No matches found
17:26:05 <br1> I'll try there.  thxs, dmwit, chessguy
17:26:27 <andun> > concat $ zipWith (++) (map show [1..3]) (repeat ", ")
17:26:28 <lambdabot>  "1, 2, 3, "
17:26:57 <andun> is there an easy way to get rid of the trailing ", "?
17:27:18 <ddarius> concat . intersperse
17:27:46 <andun> ah :D
17:27:46 <dmwit> > concat . intersperse ", " . map show $ [1..3]
17:27:47 <lambdabot>  "1, 2, 3"
17:28:25 <TSC> :t intercalate
17:28:27 <lambdabot> Not in scope: `intercalate'
17:29:43 <chessguy> @hoogle intercolate
17:29:44 <lambdabot> No matches found
17:31:16 <mauke> > join `fmap` intersperse ", " `fmap` fmap show $ [1..3]
17:31:17 <lambdabot>  "1, 2, 3"
17:31:50 <byorgey> o.O
17:32:09 <mauke> > join `fmap` intersperse ", " `fmap` fmap show `id` [1..3]
17:32:11 <lambdabot>  "1, 2, 3"
17:32:17 <mauke> huhu
17:33:25 <byorgey> @type id
17:33:27 <lambdabot> forall a. a -> a
17:33:34 <byorgey> @type `id`
17:33:36 <lambdabot> parse error on input ``'
17:33:40 <byorgey> @type (`id`)
17:33:41 <lambdabot> parse error on input `)'
17:33:59 <byorgey> ?  how can you use id as infix?
17:34:50 <Jaggederest> doesn't infix need to take two args?
17:35:10 <dmwit> ?index listToMaybe
17:35:10 <lambdabot> Data.Maybe
17:35:35 <byorgey> @type `f`
17:35:37 <lambdabot> parse error on input ``'
17:35:44 <byorgey> @type (`?f`)
17:35:46 <lambdabot> parse error on input `?f'
17:35:49 <Jaggederest> maybe bot is choking
17:36:03 <byorgey> I doubt it =)
17:36:11 <Jaggederest> @type id
17:36:13 <lambdabot> forall a. a -> a
17:36:32 <mauke> Jaggederest: every function takes exactly one argument
17:37:10 <dmwit> byorgey: `id` is the correct form.
17:37:15 <byorgey> > 3 `id`
17:37:15 <lambdabot>  Parse error
17:37:19 <dmwit> byorgey: But $ might be easier.
17:37:29 <dmwit> > (+1) `id` 3
17:37:30 <lambdabot>  4
17:37:44 <dmwit> postfix /= infix
17:38:17 <Jaggederest> >(+1) id 3
17:38:29 <Jaggederest> ah space
17:38:33 <Jaggederest> > (+1) id 3
17:38:33 <lambdabot>   add an instance declaration for (Num (a -> a))
17:38:34 <lambdabot>     In the expression: (+ 1)...
17:38:56 <byorgey> @type ((+1) `id`)
17:38:57 <dmwit> > (+1) (id 3) -- also acceptable, but for a different reason
17:38:58 <lambdabot> forall a. (Num a) => a -> a
17:38:59 <lambdabot>  4
17:39:18 <byorgey> @type (3 `id`)
17:39:19 <lambdabot> forall t. (Num t) => t
17:39:27 <byorgey> ok, I get it =)
17:39:29 <dmwit> > (3 `id`)
17:39:29 <Jaggederest> > (+1) $ id 3
17:39:30 <lambdabot>  3
17:39:31 <lambdabot>  4
17:39:34 <dmwit> Whoa!
17:39:40 <dmwit> I didn't know postfix was even possible.
17:40:00 <byorgey> dmwit: that's the point, `f` IS postfix
17:40:07 <dmwit> Right, nice.
17:40:12 <byorgey> dmwit: since functions take one argument and return a function
17:40:31 <dmwit> ?index gets
17:40:32 <lambdabot> Control.Monad.State, Control.Monad.RWS
17:40:33 <dmwit> ?index asks
17:40:33 <lambdabot> Control.Monad.Reader, Control.Monad.RWS
17:40:35 <byorgey> dmwit: of course, I mean, functions of 'more than one argument'
17:41:12 <Jaggederest> interesting. That might be fun... haskforth
17:42:02 <byorgey> @type intersperse "" `fmap` fmap show
17:42:04 <lambdabot> forall a. (Show a) => [a] -> [[Char]]
17:42:09 <Jaggederest> > 3 `+`
17:42:09 <lambdabot>  Parse error
17:42:18 <Jaggederest> eh yep :)
17:42:31 <chessguy> > 3 `+ 2`
17:42:31 <lambdabot>  Parse error
17:42:48 <byorgey> > 3 `(2+)`
17:42:48 <lambdabot>  Parse error
17:42:53 <Jaggederest> @type (+)
17:42:54 <lambdabot> forall a. (Num a) => a -> a -> a
17:43:14 <byorgey> > (3 `(2+)`)
17:43:14 <lambdabot>  Parse error
17:43:24 <kpreid> only identifiers can go in ``
17:43:47 <Jaggederest> @type 3 +
17:43:49 <lambdabot> parse error (possibly incorrect indentation)
17:43:52 <byorgey> kpreid: ok, got it
17:43:56 <Jaggederest> @type (3 +)
17:43:58 <lambdabot> forall t. (Num t) => t -> t
17:44:07 <kpreid> (if other things could, it would be unparseable; note that there are not distinct delimiters)
17:44:24 <byorgey> kpreid: ah, indeed!  I hadn't thought of that.
17:44:35 <kpreid> @type \1 -> 2
17:44:36 <lambdabot> forall t t1. (Num t, Num t1) => t -> t1
17:45:27 <byorgey> > (\1 -> 2) 1
17:45:28 <lambdabot>  2
17:45:33 <byorgey> > (\1 -> 2) 3
17:45:34 <lambdabot>   Non-exhaustive patterns in lambda
17:45:42 <byorgey> heh
17:45:42 <Jaggederest> oh now my head hurts
17:46:14 <byorgey> #haskell tends to do that =)
17:46:33 <fnord123> >(\3->4) 3
17:46:48 <Jaggederest> > (\x y -> y x) 2 +
17:46:48 <lambdabot>  Parse error
17:46:50 <byorgey> fnord123: the space after > is required
17:47:25 <Jaggederest> > (\x y -> y x) 2 (3 +)
17:47:26 <lambdabot>  5
17:47:39 <Jaggederest> hah, postfix math
17:48:42 <byorgey> hey there jfredett
17:48:54 <byorgey> did you see the code I pasted?
17:49:18 <fnord123> > (\x y -> \y x -> x) 1 2
17:49:19 <lambdabot>  Add a type signature
17:50:08 <kpreid> > 0 >>> ((+1) &&& (+2)) >>> (+)
17:50:09 <lambdabot>   add an instance declaration for (Num (c, c))
17:50:13 <Jaggederest> > (\x y -> (\y x -> x)) 1 2
17:50:13 <lambdabot>  Add a type signature
17:50:20 <kpreid> > 0 >>> ((+1) &&& (+2)) >>> uncurry (+)
17:50:20 <lambdabot>   add an instance declaration for (Num (b -> a))
17:50:51 <byorgey> > app (const 0) >>> ((+1) &&& (+2)) >>> uncurry (+)
17:50:51 <lambdabot>  Couldn't match expected type `b -> t'
17:50:57 <kpreid> > (((+1) &&& (+2)) >>> uncurry (+)) 0
17:50:58 <lambdabot>  3
17:51:01 <byorgey> > arr (const 0) >>> ((+1) &&& (+2)) >>> uncurry (+)
17:51:02 <lambdabot>  Add a type signature
17:51:17 <Jaggederest> @index &&&
17:51:18 <lambdabot> Control.Arrow
17:51:29 <Jaggederest> aah thus my ignorance
17:51:40 <kpreid> > ((+1) &&& (+2)) 10
17:51:41 <lambdabot>  (11,12)
17:51:41 <byorgey> Jaggederest: that way lies beautiful dragons =)
17:52:04 <kpreid> &&& just applies two arrows (in this case, functions) to one input
17:52:16 <olsner> beautiful, fire-spewing, treacherous dragons?
17:52:16 <Jaggederest> I gather. I'm still struggling with 'which way does fold go?'
17:52:26 <byorgey> olsner: yes.
17:52:38 <olsner> mmmm, the very best kind ;-)
17:53:11 <byorgey> olsner: but if you befriend them they will take you on thrilling rides over the mountains of Combinatoria
17:53:58 <Jaggederest> I see, so they act something like a SIMD unit
17:54:18 <Jaggederest> 'do this to these things'
17:54:26 <byorgey> Jaggederest: actually, MISD =)
17:54:56 <Jaggederest> ah so the opposite... you get out two results?
17:55:01 <byorgey> right
17:55:13 <Jaggederest> hmmm.
17:55:14 <byorgey> like what kpreid did above
17:55:18 <byorgey> > ((+1) &&& (+2)) 10
17:55:20 <lambdabot>  (11,12)
17:55:37 <ddarius_> @where arrow
17:55:38 <lambdabot> I know nothing about arrow.
17:55:40 <Jaggederest> I just laughed out loud
17:55:49 <ddarius_> http://www.haskell.org/arrows
17:55:50 <lambdabot> Title: Arrows: A General Interface to Computation
17:56:00 <byorgey> Jaggederest: why?
17:56:00 <kpreid> > ((+1) *** (+2)) (10,100)
17:56:01 <lambdabot>  (11,102)
17:56:05 <Jaggederest> that's pretty cool
17:56:13 <byorgey> indeed =)
17:56:20 <ddarius_> The picture on the introduction there are a good way to begin understanding arrows (from a programming perspective)
17:56:30 <olsner> is it just me, or are "arrows" just a kind of generalized 'map' on streams, as well as some convenience functions to map across fst/snd of a tuple?
17:57:00 <byorgey> olsner: well, they can also have state/side effects
17:57:13 <ddarius> olsner: Arrows are rather abstract.
17:57:29 <byorgey> olsner: so they're strictly more powerful than a map over streams.
17:57:39 * ddarius mumbles something about closed Freyd categories.
17:58:00 <Jaggederest> yeah it's like higher order mapping
17:58:04 * olsner gets confused about something about closed freyd categories
17:58:43 <byorgey> olsner: if you haven't read it, the original Hughes paper is actually quite readable
17:58:55 <byorgey> it doesn't mention anything about Freyd categories (whatever those are)
17:59:00 <olsner> with the state thing, I kind of get the analogy to robots on the wikibooks page
17:59:24 <olsner> everything about haskell is always so abstract, it's almost impossible to translate into better code
18:00:11 <byorgey> s/almost impossible/takes a lot of practice/ =)
18:00:41 <Jaggederest> well, at least it's there, no? when things balloon above 50k LOC it starts to matter, I gather
18:01:19 <fnord123> yeah when my dynamically typed projects get large, its hell to manage refactorings :(
18:01:49 <Jaggederest> BTDT, learning haskell now for a reason :)
18:02:09 <byorgey> Jaggederest: BTDT?
18:02:16 <Jaggederest> been there done that
18:02:20 <byorgey> ah
18:02:43 <Jaggederest> sometimes 'been there, done that, got the t-shirt'
18:02:52 <byorgey> heh
18:03:24 <olsner> I'd like to have a collection of bottom-up tutorials on that kind of stuff... more in terms of learning to see the patterns and translate them into monads, arrows, etc rather than having to learn and grok thousands of abstractions and eventually deriving the patterns from the abstractions
18:04:05 <byorgey> olsner: hmm, that's a good idea
18:04:06 <Jaggederest> have you done the 'scheme in 48 hours' project?
18:04:16 <byorgey> olsner: maybe I'll write some...
18:04:22 <Jaggederest> that made me feel warm and fuzzy
18:04:43 <Jaggederest> http://halogen.note.amherst.edu/~jdtang/scheme_in_48/tutorial/overview.html
18:04:45 <lambdabot> Title: Write Yourself a Scheme in 48 hours, http://tinyurl.com/l986o
18:04:59 <olsner> byorgey: let me guess, "any day now"? ;-)
18:05:19 <Jaggederest> very step-by-step from the basics up to monad transformers
18:05:26 <byorgey> olsner: right =)
18:07:25 <desp> is it possible to enable -fglasgow-exts in GHS using some source file pragma?
18:07:30 <desp> s/GHS/GHC/
18:08:11 <olsner> {-# OPTIONS -fblah -ffoo -fbar #-}
18:08:16 <desp> aha, thanks
18:08:21 <allbery_b> {-# OPTIONS_GHC -fglasgow-exts #-}
18:08:23 <mux> desp: have your first line be '{#- OPTIONS_GHC -fglasgow-exts -#}
18:08:27 <allbery_b> (OPTIONS is deprecated IIRC)
18:08:40 <mux> but there's a new extension pragma that is better
18:09:10 <olsner> @quote stereo
18:09:10 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:09:25 <desp> mux: yes?
18:09:32 <mux> I'm trying to look it up :-)
18:09:34 <Jaggederest> surround sound, morelike
18:09:34 <desp> :)
18:10:23 <mux> ah; it seems it's {-# LANGUAGE X #-}
18:10:24 <olsner> ... and an instance of the old adage that the best way to incite good answers is to shout out bad answers ;-)
18:10:36 <Modius> Are there any IDEs/editors (For windows) specifically rigged to aid with Haskell development?
18:10:39 <mux> ie, {-# LANGUAGE MultiParamTypeClasses #-}
18:10:56 <mux> this is saner since it's not GHC specific, and it can be implemented by other compilers
18:11:03 <Modius> I would like to exclude the Devstudio one here as I had it blitz my other project associations
18:11:04 <allbery_b> visual haskell, which is designed to plug into microsoft visual studio
18:11:07 <desp> mux: where are you finding this?
18:11:09 <allbery_b> ah
18:11:13 <Jaggederest> emacs has a nice haskell mode and plays well with windows
18:11:16 <mux> google, of course :-)
18:11:16 <desp> mux: I specifically need phantom data types
18:11:19 <desp> heh
18:11:30 <allbery_b> there's an immature plugin for eclipse
18:11:31 <desp> I was actually using the LANGUAGE option for ForeignFunctionInterface
18:11:39 <mauke> aren't phantom types haskell98?
18:11:53 <sorear> mauke: they aren't even a feature
18:12:00 <allbery_b> I thought phantom types are just using types you don't actually need, and perfectly valid h98
18:12:00 <desp> `CURLEasy' has no constructors (-fglasgow-exts permits this)
18:12:07 <sorear> mauke: phantom types is a design pattern
18:12:13 <desp> that's what GHC said on "data CURLEasy"
18:12:23 <mauke> desp: that's not phantom
18:12:25 <sorear> mauke: asking if they are h98 is like asking if singletons are standard c++
18:12:53 <mauke> sorear: dunno, in theory h98 could require every type parameter to be used
18:12:56 <ihope> Soreo, soreas, sorea, soreamos, soreÃ¡is, sorean. SoreÃ©, soreaste, soreÃ³, soreamos, soreasteis, sorearon. I mean, uh, ah! I've figured out what to write!
18:13:17 <mauke> desp: {-# LANGUAGE EmptyDataDecls #-}
18:13:24 <desp> pardon me, perhaps I mixed up the names
18:13:29 <sorear> ihope: ?
18:13:33 <olsner> lol... firefox on mac os calls the imported safari bookmarks "Imported IE Favorites"
18:13:39 <mauke> or data CURLEasy = CURLEasy
18:13:49 <ihope> sorear: it's really easy to think "ooh, a Spanish verb! Conjugate!" upon seeing your nick.
18:14:07 <ihope> Soreaba, soreabas, soreaba, soreÃ¡bamos, soreabais, soreaban...
18:14:20 <desp> mauke: thanks
18:14:35 <sorear> ihope: Hehe.  It's not even from se europe!
18:15:10 <sorear> ihope: 5 letters from Ireland and 1 from somewhere in the former Yugoslavia
18:15:20 <ihope> I'll wrap up with soreando and soreado before asking what I should use for... egad, I don't even know what they're called.
18:15:47 <ihope> Mutable lookup tables where you can add an item and it gives you the key.
18:16:33 <sorear> ihope: like a heap, you can allocate keys (with default values) ?
18:16:41 <sorear> ihope: I'd recommend using IORef
18:17:22 <ihope> Using createIORef or whatever the function is called, then passing around the IORefs?
18:17:23 <olsner> oh, was that Schem in 48 hours a *haskell* tutorial? that's a nice take on learning haskell!
18:17:35 <ihope> That's not a bad idea.
18:17:41 <allbery_b> yep.  intro to haskell by writing a mini-scheme
18:18:21 <ddarius> Very slowly.
18:19:08 <Jaggederest> well he covers most of the numeric tower. That's pratically a day right there
18:19:25 <ddarius> Nah, that could be done easily in an hour.
18:20:23 <Jaggederest> bases, floats, scientific notation, varying sizes of numerics, and infinite precision numbers
18:20:36 <Jaggederest> according to R5RS
18:20:59 <ddarius> Haskell's numeric types are inspired by the Lisp and Scheme numeric towers.
18:21:20 <olsner> by not starting coding until you actually know everything needed to implement it you can reduce the amount of coding time greatly... but to be really fair, you'd have to "start the clock" the moment the user opens a LISP book - certainly most people wouldn't go from nil to scheme in 48 hours
18:21:54 <olsner> then again, it's not really a contest ;-)
18:22:04 <Jaggederest> I figured I'd be faster too, but then I hit the IO primitives
18:22:51 <Jaggederest> the real trip is when he switches to defining the standard lib in scheme, using the REPL you build
18:23:22 <ddarius> Jaggederest: Where, presumably, it becomes a Scheme tutorial?
18:23:29 <Jaggederest> holy culture shock batman :) Yep dead on
18:23:52 <olsner> hmm... I guess you could be in a pinch when starting on IO, since most of the rest can be implemented purely, you might end up having to IO-ify most of the interpreter
18:24:16 <ddarius> Not if you were originally supporting continuations.
18:24:21 <ddarius> and state.
18:24:37 <Jaggederest> he does it pretty slick and teaches how to keep IO out of the way
18:25:09 <ddarius> The is no IO on the Tao.
18:25:13 <Jaggederest> as well as using three monads (Parser, IO, and Error)
18:25:39 <Jaggederest> the old solipsist philosopher optimization, eh?
18:25:51 <olsner> I should really go through that tutorial it seems! it's in the queue ;-)
18:26:17 <Jaggederest> 'how come my program compiles to one NOP?'
18:26:38 <Jaggederest> IO, therefore I am.
18:26:38 <emu> it does nothing!
18:26:59 <ddarius> There is no nop.
18:27:39 <Jaggederest> if you're compiling to machine code (x86) it's 0x80
18:28:01 <mauke> There is no .
18:28:25 <ihope> Indeed,  doesn't exist.
18:28:40 <olsner> NOP was 90h on x86, last time I memorized it
18:29:15 <fnord123> nop does not exist
18:29:50 <olsner> as expected from the user called 'fnord'
18:29:52 <dansa> nop should be 0x00
18:30:07 <ddarius> nop is 0x90
18:30:16 <olsner> I think 0x00 is some arithmetic function on x86
18:30:42 <Jaggederest> yeah I was one digit off :)
18:30:59 <olsner> can't recall which though.. I know I knew it once
18:31:08 <sorear> on x86 00 is the first byte of a two byte opcode
18:31:14 <ddarius> aaa
18:31:25 <Jaggederest> as Visa would have it, I owe, therefore I am
18:31:28 <sorear> ADD [mem8], reg8
18:31:40 <ihope> Hmm... what's likely to be a nice fast way to do an obscure operation on a Word16?
18:31:41 <sorear> 00 00 is ADD [EAX], AL
18:31:48 <ddarius> 0x90 is xchg al, al or xchg ah, ah if I remember correctly.  I believe the former.
18:31:51 <sorear> or ADD [AX+SI], AL  if your os is oldish
18:32:12 <sorear> xchg al, al *originally*, it's been a specially handled for ages now
18:32:19 <dansa> hm, I never knew any x86 opcode. I know a few instruction names, though
18:32:25 <olsner> according to ndisasm: 0000              add [bx+si],al
18:32:44 <ihope> Obscure as in "for each bit of the result, look at these bits, and if this bit is true and this many of these bits are true and say that the result bit is 1".
18:32:46 <sorear> indeed, on amd64 xchg al, al  masks off the top four bytes of rax;  nop doesn't
18:32:53 <ihope> Except more complex.
18:33:04 <fnord123> ive only programmed mips asm using an emulator. pretty piss poor for an embedded system engineer :-S
18:33:08 <Jaggederest> should have known #haskell would have ASM hackers
18:33:17 <edwardk> heh
18:33:25 <sorear> on 65xx NOP is EA
18:33:26 <ihope> I thought Haskell and ASM were exact opposites. :-)
18:33:36 <edwardk> ihope: iwish ;)
18:33:37 <ddarius> ihope: Nope.
18:33:39 <ihope> I mean, except for the fact that both are classical.
18:33:44 <sorear> Jaggederest: asm hackers don't know opcodes
18:33:48 <sjanssen> forall x. x hackers `elem` #haskell
18:33:52 * sorear has programmed in raw machine code
18:34:03 <ddarius> As have I.
18:34:06 <ddarius> It's not hard.
18:34:10 <ihope> Well, I guess you could extend Haskell with quantumness... and ASM, too.
18:34:12 <sorear> well, people who hack assembles know opcodes
18:34:24 <edwardk> many of us found our way to haskell after many years of prematurely optimizing assembly ;)
18:34:28 <dansa> I have done it for when I was writting emulators for a few classes I had along the way
18:34:41 <mauke> ihope: http://paste.lisp.org/display/42132
18:34:42 <edwardk> ihope: well, i have a good chunk of an assembler DSL and there is Harpy as well
18:34:59 <Jaggederest> well yes, but in the same way a debugger is to C, knowing machine codes is to ASM. how else do you check your work, prayer? :)
18:35:00 <ddarius> edwardk: Other than CPS breaking my heart, I haven't really lost my fondness for assembly.
18:35:06 <edwardk> and i think sigfpe or someone hass a quantum monad =)
18:35:20 <ihope> mauke: that's how you do obscure bitwise operations?
18:35:21 <dansa> I supose I knew a few x86 opcodes, as I did a z80 emulator once, they probably share a few opcodes.
18:35:50 <sorear> afair 8080 and 8086 are only source compatible
18:35:56 <ddarius> dansa: A Z80 emulator in assembly?
18:36:00 * ddarius has done that.
18:36:05 <dansa> no, it was in verilog
18:36:11 <edwardk> I've probably written disassemblers/assemblers for a good 8-9 different cpus over the years. how sad is that.
18:36:14 <dansa> I hated the class, byt the way
18:36:22 <ihope> ...That's ASM in Haskell, isn't it?
18:36:28 <newsham_> why is that sad?
18:36:35 <mauke> it's raw machine code in haskell
18:36:36 <newsham_> sounds like fun.
18:36:51 <edwardk> because it gets a tad bit repetitive ;)
18:36:54 <ddarius> I should design something using analog ASIC design.
18:37:06 <Jaggederest> well they keep changing architectures on the poor guy... 8 times! :)
18:37:25 <newsham_> i've gotten to write some assemblers, disassemblers, modellers and emulators for various cpus.
18:37:27 <edwardk> last one is started was my assembler DSL before i realized i wasn't writing the compiler in haskell, just the interpreter
18:37:29 <newsham_> always a lot of fun
18:37:41 <dansa> Jaggederest, you don't need to know the opcodes to check your asm work.
18:37:52 <dansa> Jaggederest, why would you?
18:38:44 <ihope> Oh, I guess I can figure out a fastish way to do my bit operations easily enough.
18:38:45 <Jaggederest> make sure the assembler is putting out sane instructions? never done it myself
18:39:15 <olsner> hmm... why List and DottedList instead of Cons LispVal LispVal?
18:39:17 <dansa> I never written a compiler in haskell, should be fun. I'm doing one in C++ for a class I have, I didn't think it was too bad so far.
18:39:34 <ddarius> olsner: Haskell does that to you.
18:39:40 <dansa> Jaggederest, well, you want to check that if you're writting the assembler or your assembler sucks :P
18:39:44 <ihope> Mmh, why is there no Word4?
18:39:56 <ddarius> dansa: A compiler from what to what?
18:40:01 <edwardk> Jaggederest: for most cpus most opcodes share a fairly simple addressing mode structure, and are consistently used. x86 is a bit of an exception to this norm, but there are clear generations of opcodes, and a bunch of random architectural corner cases, then the core follows that simple mode, so there isn't much to get wrong.
18:40:02 <ddarius> @index Word64
18:40:02 <lambdabot> Data.Word, Foreign
18:40:23 <dansa> ddarius, from a language pascal-like to a machine my teacher created. I had to do the interpreter also.
18:40:35 <ihope> Well, I could theoretically do Word16 -> Word4, or I could theoretically do Word64 -> Word16... and that makes sense.
18:40:38 <dan__> dansa, is it lolcode?
18:40:41 <dan__> :P
18:40:46 <ddarius> dansa: What parts have you done so far?
18:40:49 <dansa> lolcode? what's that?
18:40:51 <olsner> seems a tad irksome to have to convert lists to dottedlists if the cdr is, for example, mutated by setf/rplacd
18:40:54 <sorear> In general, first architectures are nice.
18:40:55 <dmead> lolcode.com
18:41:02 <sorear> AHHH!!!
18:41:04 <dmead> it's also pascalish :)
18:41:07 <dmead> hay sorear
18:41:27 <olsner> ddarius: what do you mean haskell does it for/to me?
18:41:28 <ihope> LOLCODE is an esoteric programming language that's popular for some reason.
18:41:30 <sorear> 8086 and 6502 are very clean and elegant instruction sets
18:41:41 <newsham_> heh.. 8086..
18:42:05 <edwardk> prop_wellatleastiamconsistent dacode = disassemble (assemble dacode) == dacode
18:42:05 <byorgey> ihope: it's popular because it was just invented a week ago.  give it a few weeks...
18:42:06 <dansa> ddarius, so far the lexer, parser, a translator from intermediary code (quadruples) to the machine code, an assembler and the interpreter
18:42:08 <sorear> 65816 and pentium4 are ultra ugly, because they needed more opcodes and stuck them wherever
18:42:11 <olsner> I like MIPS assembly... from about 30minutes of reading, you can understand almost all kinds of instruction encodings
18:42:16 <dansa> it won't be an optimizing compiler
18:42:21 <edwardk> 6502 was neat because if you knew how it worked internally you could synthesize a lot of non-official opcodes =)
18:42:24 <ddarius> olsner: I was using the general "you" or particularly directed at the auther of the article.  Haskell makes you like to distinguish between such cases.
18:42:35 <edwardk> because it didn't have any invalid opcode check in the pipeline =)
18:42:35 <dansa> so I guess there's just one thing left: actually generate the quadruples, probably the hardest part hehe
18:42:38 <newsham_> 6502 had some weird addressing modes and also some weird instructions due to instr decode design
18:42:44 <edwardk> new: yeah
18:42:49 <ddarius> dansa: Ah.  Do you even do register allocation?
18:42:52 <edwardk> that was the first disassembler i wrote as a kid =)
18:43:02 <dansa> ddarius, not really, it's a stack-based machine
18:43:05 <sorear> newsham_: The instructions aren't wierd at all
18:43:21 <ddarius> So it's a compiler minus all the hard parts.
18:43:25 <newsham_> the undocumented ones are
18:43:28 <sorear> newsham_: They are the natural interpolations between documented opcodes
18:43:35 <dansa> ddarius, yeah, something like that :)
18:43:37 <edwardk> sorear: the official ones, but if you set both bits in some opcodes you could get some pretty strange but occasionally useful ones
18:44:13 <sorear> edwardk: Let's pretend for a second I'm talkign about 6502.pdf rather than 6502-mask.bmp
18:44:28 <olsner> yeah, but the Cons is more general, and is the actual construct that Scheme programs use... just generally what you'd expect a scheme interpreter to have.. but I guess having the Haskell list available has its perks later on
18:44:34 <Jaggederest> heh. as designed, as built
18:44:41 <edwardk> sorear: =)
18:44:42 <dansa> ddarius, I know a bit of the theory for register allocation and code optimization, but we don't need to do them in this assignment, we wouldn't have the time.
18:44:51 <ihope> Wait a minute... this won't work elegantly unless it's Word16 -> Word4, or at least acts that way. I can pretend a Word8 is a Word4.
18:44:59 <edwardk> sorear: alas, i work in the real world, and you often need to disassemble unofficial opcodes ;)
18:45:10 <ddarius> dansa: The parts of a compiler that such most are: the parser for some languages, optimization, register allocation, and for "annoying" architectures opcode selection, and code generation.
18:45:16 <ddarius> s/such/suck
18:45:20 <sorear> edwardk: You do?
18:45:31 <sorear> edwardk: DB $31 isn't good enough?
18:45:33 <Jaggederest> Word8 -> list of booleans, take 4
18:45:47 <edwardk> sorear: i found quite a few of them while er.. backing up.. games
18:46:01 <Jaggederest> ah one of those... nice
18:46:13 <edwardk> sorear: depends on if you want to emulate the platform later ;)
18:46:17 <ihope> In GHC, at least, it all seems to be GHC.Prim.Word# anyway.
18:46:22 <dansa> ddarius, yeah, optimization seems kinda hard
18:46:48 <ihope> (Isn't even an unboxed tuple of booleans much bigger than a Word8?)
18:46:54 <dansa> there's just too much stuff to think about on the architetures nowdays
18:47:29 <Jaggederest> ihope: yes, much
18:47:50 <edwardk> I'll admit my views are somewhat muddled because I spent so much time flitting back and forth from getting a working disassembler, to a working assembler, to emulating the platform in a cycle correct manner, etc. on the 6502 in particular ;)
18:47:52 <dansa> my compiler will actually be really dumb :P
18:48:01 <Jaggederest> I was being unhelpful ;)
18:48:07 <ihope> Indeed. :-)
18:48:44 <ihope> Now, how can I get lambdabot to show me the implementation of a class member for a certain instance?
18:48:50 <edwardk> but even the undocumented opcodes for the 6502 are consistent in a bizarre sort of way
18:49:09 <ddarius> @src (->) Monad
18:49:09 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
18:49:13 <sorear> @src (->) return
18:49:13 <lambdabot> return = const
18:49:14 <ddarius> @src (->) return
18:49:14 <lambdabot> return = const
18:49:23 <Jaggederest> it's like bit twiddling in JS: every bit op converts 64 float -> 32 int -> 32 int (after) -> 64 float
18:49:29 <sorear> edwardk: I just said that.
18:49:38 <sorear> edwardk: 18:41 < sorear> newsham_: They are the natural interpolations between documented opcodes
18:50:10 <ihope> @src Word8 maxBound
18:50:10 <lambdabot> Source not found. Do you think like you type?
18:50:24 <ddarius> > maxBound :: Word8
18:50:25 <lambdabot>  255
18:50:36 <davidL> mux: ping
18:51:20 <ihope> @src Word8 enumFrom
18:51:20 <lambdabot> Source not found. You type like i drive.
18:51:37 <ihope> It's sort of not helping.
18:51:39 <Jaggederest> bot is sassy 0_o
18:52:05 <sorear> ihope: all enumFrom instances work basically the same way, they stop at the end
18:52:10 <ihope> You should see its @sudo command. :-P
18:52:14 <sorear> > [ 250 :: Word8 .. ]
18:52:15 <lambdabot>  [250,251,252,253,254,255]
18:52:36 <ihope> And I guess it's pretty obvious how to implement all these, really.
18:56:25 <edwardk> sorear: missed that line =)
18:56:29 <ihope> But I'd feel better if I could just take GHC's implementation of Word8 and convert it into an implementation of Word4.
18:56:39 <sorear> @src Word8
18:56:39 <lambdabot> Source not found. My mind is going. I can feel it.
18:56:49 <sorear> data Word8 = W8 !Word
18:56:55 <sorear> aprox
18:57:05 <olsner> Word4? is that a nibble? or are those that I thought were bits actually bytes?
18:57:07 <ihope> And then you have all those instance declarations.
18:57:14 <ihope> olsner: they're bits.
18:57:20 <olsner> good ;-)
18:57:45 <ihope> And yup, it's a nybble :-)
18:57:48 <sioraiocht> @src Word
18:57:49 <lambdabot> Source not found. The more you drive -- the dumber you get.
18:57:50 <sorear> ihope: thanks to the miracle of modulo math, i think you can get away with deriving Num
18:58:24 <ihope> If I derived it right from Word, I'd end up with 10 + 10 being 20.
18:58:29 <ihope> That's absolutely unacceptable.
18:59:42 <allbery_b> I suppose there's no way to trick Data.Fixed into doing this?  (wrong side f the decimal pont...)
18:59:44 <sioraiocht> ihope: just define arithmetic operations (mod4)?
19:00:01 <sioraiocht> I mean, you have more of a finite field than a true hardware Word4, but do you care?
19:00:13 <sorear> ihope: Why is it unacceptable?
19:00:24 <sorear> ihope: just define == so that 4 == 20
19:00:49 <ihope> Oh. Indeed.
19:01:40 <sioraiocht> is there anyway to do trinary infix operations in haskell?
19:02:12 <ddarius> sioraiocht: You can fake it or simulate it easily enough.
19:02:23 <ihope> Yeah, I don't think there's anything "real".
19:02:30 <sioraiocht> ddarius: yeah I figured, just swanted to make sure there wasn't an "official" way
19:02:46 <ihope> data PairThing a b = a :< b; a :< b % c = ...
19:03:18 <sioraiocht> hahaha colloquy's smiley faces totally made that more fun, ihope
19:03:20 <shapr> @yow !
19:03:20 <lambdabot> I'm having a RELIGIOUS EXPERIENCE ... and I don't take any DRUGS
19:03:30 <ihope> :-)
19:03:39 <ihope> a % b :< c is naturally also an option.
19:03:44 <johnnowak> sioraiocht: it'll be more fun after it corrupts your preferences
19:03:52 <olsner> @yar
19:03:52 <lambdabot> I'll crush ye barnacles!
19:03:55 <sioraiocht> johnnowak: been there, done that.
19:04:06 <johnnowak> sioraiocht: :)
19:04:09 <ihope> (And the :< user I see most often is a certain kaelis in a certain channel on a certain other network.)
19:04:27 <sioraiocht> OS X seems to have a certain flair for that, it happened in firefox and adium, too
19:05:06 <johnnowak> don't use firefox, there's that solved :)
19:05:13 <sioraiocht> johnnowak: safari?
19:05:16 <johnnowak> well, half solved.
19:05:16 <sioraiocht> camino?
19:05:20 <johnnowak> safari.
19:05:43 <edwardk> ihope: you're trying to just write a 4 bit word instance?
19:05:49 <ihope> Yup.
19:05:55 <ihope> We can derive Bounded, Num, Read and Real...
19:06:14 <edwardk> ihope: and you don't want to carry around the modulus or something like that?
19:06:28 <shapr> Are there any tutorials on designing and implementing monad transformers?
19:06:35 <ihope> Don't want to carry what around?
19:06:39 <edwardk> ihope like http://www.cs.rutgers.edu/~ccshan/prepose/prepose.pdf
19:06:43 <ddarius> shapr: Yes
19:06:55 <edwardk> then just have the type carry around an integer modulus of 16 or something
19:07:11 <sioraiocht> shapr: all about monads has some stuff
19:07:27 <shapr> sioraiocht: Ok, I'll look there first.
19:07:30 <sioraiocht> http://www.haskell.org/all_about_monads/html/
19:07:30 <lambdabot> Title: All About Monads
19:07:39 <sioraiocht> part III is all about monad transformers
19:08:05 <ihope> Ooh, cool: http://darcs.haskell.org/packages/base/Data/Word.hs
19:08:13 <ihope> ...maybe.
19:08:23 <shapr> ddarius: Do you know of some others?
19:08:42 <shapr> Ah, there's a few on google.
19:08:50 <ddarius> @google "Deriving Backtracking Monad Transformers"
19:08:52 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/ICFP00.ps.gz
19:08:53 <Korollary> shapr: Have you seent this? http://uebb.cs.tu-berlin.de/~magr/pub/Transformers.en.html
19:08:55 <lambdabot> Title: Monad Transformers Step by Step
19:09:25 <Korollary> It's about using them tho
19:09:26 <shapr> Korollary: Yeah, but it's about use, not about design and implementation.
19:10:10 <shapr> chessguy and Procyon asked me about how to restructure their Genetic Programming lib, and I think that turning into a bunch of monad transformers would be nice, but then I realized I have no idea how to do that :-)
19:10:11 <ihope> Okay, @source doesn't give me the inner module thingies.
19:10:30 * ddarius scolds @source
19:12:00 <ihope> Egad, time to go already?
19:12:21 <ihope> That... makes me want to extend Golly instead of writing it all from scratch. :-)
19:13:44 <sorear> ihope: Oh, nice, you're working on Golly too?
19:14:07 <sorear> ihope: I'm the guy who wrote the 1000 line general backgrounds patch
19:14:22 <TomMD> @seen ndm
19:14:22 <lambdabot> I saw ndm leaving #xmonad, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell 5h 52m 44s ago, and .
19:14:33 <TomMD> @help
19:14:33 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:14:38 <TomMD> @help remind
19:14:38 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:14:43 <TomMD> @help remember
19:14:43 <lambdabot> quote <nick>
19:14:43 <lambdabot> remember <nick> <quote>
19:14:43 <lambdabot> Quote somebody, a random person, or save a memorable quote
19:15:40 <olsner> that's not quite right is it? lambdabot doesn't search for quotes from a specific nick, but just any word in the quote, afaihs
19:15:55 <Korollary> Hmm
19:16:00 <Korollary> yes
19:16:11 <olsner> @quote barnacle
19:16:12 <lambdabot> No quotes match. Do you think like you type?
19:16:21 <olsner> @quote olsner
19:16:21 <lambdabot> olsner says: last night I dreamt I was stuck in a monad
19:16:25 <ddarius> olsner: It does both.
19:16:41 <ddarius> It tries nicks first than for any word.
19:16:45 <olsner> aah
19:16:47 <olsner> okay
19:16:56 <sorear> olsner: Nobody ever updates @help text
19:17:19 <ddarius> It's one line of documentation!
19:17:27 <Modius> What's the haskell to convert a numeric value to a string for putStrLn purposes?
19:17:33 <olsner> yah, it's not that important really... most people just learn from seing other people use the bot anyways
19:17:34 <ddarius> show
19:18:06 <Modius> Thanks
19:18:46 <Korollary> in fact, use print directly
19:18:49 <Korollary> @src print
19:18:50 <lambdabot> print x = putStrLn (show x)
19:19:13 <Korollary> unless there's a string build-up going on
19:20:01 <Modius> BTW - someone reminded me of the haskell devstudio addon, and I said it had destroyed my IDE configuration.  Whether it's changed since then or my IDE is installed differently now, the problem did not manifest itself when I installed (e.g. the IDE extension looks solid)
19:20:33 <TomMD> @tell ndm I have gotten Catch to run 'forever' on HPCs 'mate' test, just FYI.
19:20:34 <lambdabot> Consider it noted.
19:20:56 <dons> ?yow
19:20:56 <lambdabot> Now that I have my "APPLE", I comprehend COST ACCOUNTING!!
19:21:05 <sorear> hi dons!
19:24:32 <fuzan> hmm -- every time I try to do something with xmonad, it crashes ;)
19:25:18 <dons> fuzan: i hope you're not serious?
19:25:34 <fuzan> oh, i see.
19:25:49 <fuzan> it was dmenu crashing, and since it was the last item in my xinitrc, it was taking xmonad with it.
19:25:53 <Modius> Anyone know anything about .net haskell?  I see there is nothing to download, think it may be years out?
19:26:09 <dons> fuzan: oh, that's interesting. you don't have an 'exec xmonad' at the end?
19:26:18 <dons> Modius: there's a couple of grad students working on it
19:26:34 <fuzan> dons: now I do. still can't seem to get it to load a terminal. i'm trying mod4+enter to no avail.
19:26:43 <fuzan> kReturn = kEnter ?
19:27:33 <dons> fuzan: yes, but likely your mode key isn't bound.
19:27:39 <dons> xmonad uses mod1 by default
19:28:00 <dons> fuzan: check with `xmodmap' to see what your mod keys are bound to
19:28:04 <dons> the check against Config.hs
19:28:51 <TomMD> @where qc2
19:28:51 <lambdabot> http://darcs.haskell.org/QuickCheck/
19:29:01 <fuzan> mod{1,2,4} are bound
19:30:07 <dons> fuzan: and you're using mod1+ shift+ enter to launch a terminal?
19:30:21 <dons> "mod4+enter" isn't the key binding ;)
19:30:30 <fuzan> yeap. mod4+enter = crashes/closes/hides emdnu
19:30:38 <fuzan> well, it tried both :)
19:30:51 <fuzan> after seeing the modMask .|. shiftMask
19:30:53 <fuzan> lets try again...
19:30:58 <dons> modMask .|. shiftMask, xK_Return), spawn "xterm"
19:31:21 <fuzan> nothing.
19:31:24 <dons> dmenu crashes should have bug reports to dwm@suckless.org, i think.
19:31:36 <dons> fuzan: have you modified your Config.hs?
19:31:47 <sorear> fuzan: dmenu is not a daemon!
19:31:56 <fuzan> dons: not yet.
19:32:03 <dons> fuzan: what does, xmodmap| grep mod1
19:32:04 <dons> report?
19:32:07 <sorear> fuzan: it's SUPPOSED to exit immediately, if it does't hae options
19:32:21 <dons> yeah. its not a statusbar. fuzan, are you using dmenu as a status bar?
19:32:29 <dons> (you probably want dzen for that)
19:32:39 <dons> there's no reason to launch dmenu at startup, in fact.
19:32:46 <fuzan> mod1  Alt_L (0x40), Alt_L, 0x7d
19:32:48 <fuzan> etc.
19:32:58 <dons> ok, so alt+shift+enter   should lauch 'xterm'
19:33:05 <fuzan> no, i'm used to using dmenu as in wmii
19:33:19 <dons> yes, mod-p to launch it?
19:33:47 <fuzan> err, i see. i think dmenu was catchign the input
19:33:51 <fuzan> i was starting it in .xinitrc
19:34:11 <dons> i don't think you should be starting dmenu in your startup scrtips
19:34:33 <dons> right, it will steal all input, and what for that, before printing the result to stdout. probably not what you want
19:34:57 <dons> you can however, use dzen, at startup, as a statusbar, like in wmii:
19:34:58 <dons>   status | dzen2 -ta r -fg '#a8a3f7' -bg '#3f3c6d'
19:35:09 <dons>    exec /home/dons/bin/xmonad
19:35:20 <dons> would be the last lines of your startup file
19:35:47 <fuzan> don't even have dzen ;)  dmenu provided the statusbar and etc.
19:36:00 <fuzan> and reported on the desktops
19:36:21 <sorear> no it wouldn't have
19:36:21 <dons> hmm, don't think so. you sure you're not confusing dmenu with wmii's built in status bar?
19:36:41 <dons> dmenu is a simple command line menu program
19:36:47 <fuzan> i probably am. i never really learned what wmii was doing, only how to use it ^)^
19:37:12 <dons> ok. don't start dmenu in your .xinitrc. its not designed for that -- and will only confuse everythiing :-)
19:37:28 <fuzan> i've already left it out :)
19:37:36 <dons> xmonad running now?
19:37:55 <fuzan> yah. nicely. getting used to the keys -- the man mentions something about the restart, how does that work?
19:38:27 <dons> after you've changed your config.hs, and rebuilt, and reinstalled, mod-q will flush the state from the current xmonad, and pipe it into a newly forked xmonad
19:38:37 <dons> fuzan: perhaps go through the online tour?
19:38:49 <fuzan> dons: ah, didn't know one existed.
19:38:50 <dons> http://xmonad.org/tour.html
19:38:51 <lambdabot> Title: xmonad : a guided tour
19:39:01 <dons> man page also good, http://xmonad.org/manpage.html
19:39:02 <lambdabot> Title: Manpage of xmonad
19:39:14 <stepcut> maybe we should make some flash tutorials and post them on youtube/google video ;)
19:39:33 <dons> stepcut: definitely. screencasts please!
19:40:39 <stepcut> haha: a screencast on how to make linux screencasts: http://www.youtube.com/watch?v=NwNZDeB1k8s
19:40:47 <fuzan> somehow my emacs is floating around, xmonad supports a floating layer too? :)
19:41:04 <dons> it does in darcs, yes.
19:41:11 <dons> but i guess you're using the 0.2 release?
19:41:26 <fuzan> yah, most recent darcs pull.
19:41:27 <sorear> floating actually works pretty well
19:41:32 <sorear> jcreigh: jcreigh++
19:41:32 <fuzan> it's pretty smooth
19:41:51 <dons> yeah, mod-t to re-tile it, otherwise drag and move like in dwm
19:42:09 <chessguy> what's with the mass upload to Oleg's site today?
19:42:10 <stepcut> dons: did you see the 'problem' I had early with the floating layer ?
19:42:13 <fuzan> oh, that's what i'm doing.
19:42:26 <fuzan> if you try to alt-right drag to resize like in wmii, you pull it into the floating layer
19:43:26 <dons> fuzan: yeah, any mouse dragging will pull into floating.
19:43:32 <dons> there's no mouse resizing of the tiled layer
19:43:47 <dons> mod-h or mod-l to resize tiles
19:43:49 <fuzan> that's going to be painful to get used to :)
19:43:50 <dons> stepcut: oh?
19:44:05 <dons> fuzan: we might support it. floating is rather new, so still thinking about the interface.
19:44:12 <dons> the idea is , though , to put down the mouse :-)
19:44:18 <fuzan> i know, i know.
19:44:30 <stepcut> dons: I was in fullscreen mode, and accidently made konqueror into a floating window. After that I could not mod-tab to any other windows, and mod-space did not 'work' either.
19:44:35 <dons> stepcut: ah yes.
19:44:42 <stepcut> dons: eventually I realized what happened and did a mod-t
19:44:43 <dons> stepcut: that's interesting. hmm.
19:44:57 <dons> stepcut: some visual hint that its floating, eh?
19:44:58 <stepcut> dons: but I expect that will trip up a lot of people
19:45:06 <dons> maybe slightly resized, or a different border.
19:45:11 <dons> stepcut: yes.
19:45:37 <dons> yes, a little mod-button1 can lead to confusion
19:45:47 <fuzan> i need to find a replacements for my gtk apps.
19:46:01 <stepcut> dons: the border on my laptop in fullscreen mode is not very visible, so I am not sure if that would help
19:46:08 <dons> fuzan: what kind of ones?
19:46:12 <sorear> fuzan: Why?
19:46:17 <dons> stepcut: hmm. suggestions? :-)
19:46:21 <sorear> fuzan: gtk is perfectly compatible with xmonad?
19:46:24 <sorear> s/?/.
19:46:33 <sorear> stepcut: increase borderWidth then!
19:46:36 <dons> sorear: i'd imagine he means dock apps, not having set up the dock?
19:46:50 <fuzan> or at least, a black theme for my gtk apps.
19:47:12 <fuzan> black terminals and white gtk apps + harsh red borders, this is not zen.
19:47:33 <dons> ah yes.
19:48:05 <fuzan> this project is pretty sweet though :)
19:48:10 <dons> have a look at rob|'s theme, http://xmonad.org/images/screen-rob-status-spiral.png
19:48:20 <fuzan> would it even be feasible to use the opengl bindings to accelerate the wm?
19:48:34 <fuzan> i'm not entirely sure how aiglx/glx works
19:48:35 <stepcut> fuzan: yes, but no
19:48:38 <araujo> yes, xmonad seems working fine with gtk
19:48:40 <araujo> gtk+
19:48:41 <dons> heh. it would be another project. a fun one to try out.
19:49:28 <stepcut> fuzan: I believe that currently with aiglx, the widgets themselves are still drawn with the normal X primitives
19:49:45 <stepcut> fuzan: the composite extension lets you render the windows to an offscreen buffer
19:49:58 <sorear> fuzan: Yes, it would be possible to accelerate Xmonad with opengl
19:50:05 <fuzan> i mean, if you could integrate gl acceleration + something useful gl-powered desktop enhancements, xmonad would dominate the dynamic wm scene.
19:50:13 <dons> sorear: that might be a fun branch to work on.
19:50:14 <sorear> fuzan: Xmonad *already* uses hardare acceleration
19:50:23 <fuzan> sorear: how so?
19:50:31 <stepcut> fuzan: aiglx has a function GLX_EXT_drawable_to_texture, that can convert the windows to opengl textures
19:50:32 <Korollary> I think X uses it
19:50:39 <dons> fuzan: you think, tiling + composite stuff, would be killer features?
19:50:45 <sorear> fuzan: XDrawRectangle is a server primitive, so the graphics driver can implement it however it wants
19:50:48 <stepcut> fuzan: and then you can use opengl to paste the windows on the screen, or do other effects
19:50:55 <fuzan> stepcut: sounds pretty simple
19:51:04 <stepcut> fuzan: probably
19:51:16 <sorear> fuzan: there's a (dead) proof-of-concept Xgl server that uses gl's lines
19:51:17 <dons> i am interested in better composite support, actually. which might be a cheaper way to do nice effects.
19:51:19 <fuzan> dons: the desktop management can be pretty slick along with dynamic
19:51:20 <notsmack> dons: if something actually useful is done with it, maybe
19:51:21 <stepcut> fuzan: check out xcompmgr -- a standalone composite manager that works with xmonad
19:51:33 <dons> e.g. drop shadows, http://xmonad.org/images/xmonad_xcompmgr.png
19:51:49 <fuzan> dons: imagine tiling desktops along with windows, and then dragging windows around in desktops
19:51:59 <fuzan> stepcut: i'll look
19:52:00 <sorear> dons: I demand that either it be optional, or you implement the SiS315Pro 3d driver in Xorg
19:52:20 <dons> don't worry. xmonad will continue to work well on 36M mac68ks
19:52:21 <sorear> dons: 2d is accellerated fine, as is 3d on 300 and 330 SiSes - go figure
19:52:44 <dons> i'm interested in it: its an unexplored area for tiling wms.
19:52:45 <stepcut> fuzan: A good first step is probably to make a minimal xcompmgr 'clone' that does not tie into xmonad
19:52:52 <fuzan> i'm not really caring much for transparency, etc. i only want useful features :)
19:52:58 <dons> and given we already support xinerama, there's some room to further distinguish xmonad from wmii and dwm.
19:53:09 <fuzan> stepcut: i'll have to look into this.
19:53:17 <stepcut> transparency + tiling window manager == not very exciting ;)
19:53:28 <fuzan> very true :)
19:53:40 <dons> and we have transparency already. http://xmonad.org/images/screen-arcatan-trans.png
19:54:03 * ddarius considers making some kind of filtering wm that renders things as sketchy line drawings.
19:54:05 <dons> and its not very exciting :)
19:54:08 <fuzan> a feature ala apple's "spaces", but more dynamically attuned woudl be really neat.
19:54:21 <stepcut> fuzan: i think it would be cool to setup it up so that there is basic compositing, and then people can submit patches to XCompositeContrib, or something
19:54:59 <stepcut> fuzan: I was hoping to hack something together this week, but I am behind schedule :(
19:55:04 <fuzan> stepcut: yah. i'm already kindof gray in understanding X11's architecture. i'd need to do a bit of reading :(
19:55:39 <araujo> mm...
19:55:52 <stepcut> fuzan: ok, It may be easier to 'blindly' copy whatever is going on in xcompmgr.
19:56:18 <araujo> and how do you set a wallpaper on xmonad?
19:56:35 <dons> araujo: xpmroot foo.xpm & or some similar root window drawing.
19:56:45 <araujo> oh
19:56:47 <fuzan> stepcut: so waht does xcompmgr actually provide other than control of how one window is drawn?
19:56:48 <araujo> thanks dons
19:57:10 <dons> stepcut: i wonder if we can get sjanssen to think about compositing a bit , for his SoC proejct
19:57:21 <dons> stepcut: since it really needs someone to understand what's possible, and hook in a basic api.
19:57:44 <fuzan> iono how wm designers get away with overriding important emacs shortcuts ^_^
19:57:55 <dons> fuzan: by providing editable Config.hs
19:58:06 <jcreigh> mod4Mask, people! It's not that hard! :)
19:58:08 <dons> also, I don't use emacs, so I wouldn't know if I was overriding it ;)
19:58:23 <stepcut> fuzan: dunno, it does drow shadows and some other stuff. The useful part is, it is a lot smaller than compiz/etc, and just does compositing. So you don't have to try to seperate the compositing stuff from the window managing stuff
19:58:40 <araujo> dons, no plans to add floating windows?
19:58:43 <araujo> _yet_
19:58:52 <dons> araujo: they are supported, in the darcs head.
19:58:52 <jcreigh> araujo: darcs xmonad has a floating layer
19:58:54 <ddarius> It's subtle anti-emacs xmonad propaganda
19:59:05 <araujo> dons, oh cool ... since when?
19:59:12 <fuzan> do any of you prefer the current "bubblesort" technique of arranging windows more than wmiis?
19:59:12 <dons> about 3 days ago
19:59:15 <stepcut> araujo: a few hours after the 0.2 release ;)
19:59:15 <araujo> :-D
19:59:23 <araujo> cool
19:59:24 <dons> fuzan: i like it, i find it easy to sort windows into a given order.
19:59:30 <jcreigh> the timing was intentional.
19:59:48 <dons> fuzan: the challenge is: number windows 1 .. n randomly, then get them into sorted order with as few key strokes as possible.
20:00:06 <dons> fuzan: i found the bubble sort mechanism rather efficient for that, unlike wmii/dwm's promote.
20:00:27 <fuzan> i suppose i'll have to just get used to it.
20:00:37 <ddarius> fuzan: No you don't.
20:00:58 <dons> wmii/dwm's `promote' functionality is in the contrib library, btw.
20:01:11 <stepcut> dons: what if you did, mod-l to label the windows (like firefox does with links), and then you just press the numbers/letters to specify the order?
20:01:14 <dons> we just decided it wasn't terribly efficient.
20:01:23 <dons> stepcut: that'd be cool
20:01:37 <stepcut> of course, that would require xmonad to actually draw something, which I don't think it currently does ?
20:01:45 <dons> fuzan: but as a wmii user (i've not used wmii for a year or so) feedback is very welcome!
20:01:59 <dons> stepcut: right. it doesn't. external tools only for that --- dmenu could jsut about do it
20:02:01 <ddarius> How old is xmonad now?
20:02:10 <jcreigh> almost 3 months
20:02:14 <shapr> Yay xmonad!
20:02:18 <shapr> My favorite wm ever.
20:02:21 <dons> March 7. I started using it.
20:02:49 <shapr> I still couldn't get started with Yi
20:02:53 <stepcut> is there something like Data.Map that is efficient for looking things up in both directions?
20:02:56 <shapr> But I want to switch from xemacs to Yi, help me!
20:03:01 <jcreigh> poor dons. it was perfect from the start, but we keep adding bloat. :)
20:03:17 <dons> yeah, it was. all i ever use is fullscreen mode :-)
20:03:20 <dons> and that was 80 loc.
20:03:26 <ddarius> That's how I'd use it.
20:03:56 <dons> we should tell shapr about the restart key
20:03:58 <ddarius> Though some of the other abilities may be occasionally handy.
20:03:59 <fuzan> dons: the most useful feature about wmii's navigation is that i can navigate inbetween specific windows
20:04:09 <dons> fuzan: can you elaborate?
20:04:13 <fuzan> and move them in specific ways.
20:04:18 <notsmack> it doesn't have an ion tiling model hidden somewhere yet, does it?
20:04:50 <fuzan> dons: for example, if i have 3 windows open on a desktop, one main, and two stacked
20:05:15 <fuzan> dons: i could use mod j,modl to naviagate inbetween the main and the topmost on the right side
20:05:42 <dons> fuzan: right, mod-j is used for navigating .
20:05:49 <dons> shapr: you don't use mod-q to dynamically restart?
20:06:01 <shapr> dons: To dynamically restart xemacs?
20:06:07 <fuzan> dons: well, the issue is, if i had 5 windows open
20:06:11 <dons> oh oops. i assumed you were restarting xmonad :-)
20:06:11 <fuzan> and i tabbed over to a terminal
20:06:22 <fuzan> i'd have to hit modj 3 more times to get back to emacs
20:06:41 <shapr> dons: No, but if I could ever figure out Yi...
20:06:44 <fuzan> when i could just use "go left" in wmii.
20:07:38 <fuzan> oh, modk does previous window
20:07:39 <LoganCapaldo> fuzan: just use the terminal inside emacs. problem solved <g>
20:07:41 <fuzan> that does what I need anyways :)
20:07:59 <fuzan> LoganCapaldo: i would, but it has zsh issues and i've been lazy to figure out what it is.
20:08:00 <dons> fuzan: mod-k ?
20:08:08 <dons> fuzan: vim movement keys :-)
20:12:01 <fuzan> hmm -- "/usr/local/bin/xmonad: copyFile: resource busy"
20:12:15 <fuzan> what's the proper way to rebuild xmonad while running it?
20:12:46 <stepcut> fuzan: you have to rm the old version before install
20:14:00 <fuzan> :)
20:14:14 <SamB_XP> stepcut: what kind of stupid install code is that?
20:14:31 <jcreigh> SamB_XP: it's a cabal bug
20:14:34 <SamB_XP> install code is supposed to get the old version out of the way and *then* copy...
20:14:40 <stepcut> SamB_XP: dunno, scp does the same thing
20:14:41 <SamB_XP> jcreigh: I suspected as much
20:14:53 <SamB_XP> stepcut: scp isn't for installing software ;-)
20:15:02 <stepcut> SamB_XP: it is when I use it ;)
20:15:10 <Excedrin> can you run xmonad via runghc?
20:15:17 <SamB_XP> stepcut: don't expect to be supported in your misuse of software
20:15:45 <stepcut> Excedrin: yes, but if you make a mistake and it fails to load, then you are left in a weird state
20:15:46 <Excedrin> SamB_XP: are you advocating 'install' over cp?
20:16:11 <SamB_XP> Excedrin: for installation? I suppose.
20:16:11 <dons> Excedrin: you probably can run xmonad (bytecode interpreted) in ghci, yeah
20:16:17 <dons> Excedrin: no one has tried it. sounds fun
20:16:54 <Excedrin> it seems like it would be nice(er than having to rebuild to change stuff)
20:18:15 <dons> slower though :-)
20:25:08 <fuzan> is there no way to resize something vertically?
20:25:29 <fuzan> without switching to the other desktop mode, heh
20:25:36 <fuzan> then you can't size horizontally...
20:26:43 <dons> fuzan: not in the tiling modes, no. the mosaic extension allows this.
20:26:54 <dons> likely we'll generalise the tiling mode to allow that sometime though.
20:27:33 <SamB_XP> dons: does the mosaic extension allow non-rectangular tilings?
20:27:55 <jcreigh> err, what would a non-rectangular tiling be?
20:27:58 <dons> SamB_XP: um.?
20:28:19 <SamB_XP> well, real mosaics use stones of slightly different shapes ;-P
20:28:31 <jcreigh> X11 windows are rects
20:28:44 * SamB_XP is teasing
20:28:55 <fuzan> SamB_XP: I understood you, no worries.
20:29:29 <sorear> No, X windows are not rects anymore
20:29:41 <sorear> You set a bounding rect, but an arbitrary shape
20:29:57 <sorear> and then, totally orthogonal to the shape, windows have alpha channels!
20:29:59 <SamB_XP> sorear: but I bet you can't move the corners independantly ;-)
20:30:07 <sorear> ain't feature creep great?
20:30:43 <SamB_XP> how would you make alpha channel *not* orthogonal to shape?
20:30:56 <ddarius> Get rid of shape...
20:31:05 <SamB_XP> ddarius: how do you derive shape from alpha?
20:31:38 <ddarius> I'm sure there are a plethora of algorithms to do it.
20:31:40 <SamB_XP> lets put it like this: if I had window that looked like a sheet of glass, and one that looked like a mist...
20:32:13 <SamB_XP> ah, I know! materials!
20:32:20 <SamB_XP> that's just what we need ;-)
20:33:37 <SamB_XP> but, seriously, how would an algorithm tell a shadow or something like that from a semitransparent surface?
20:33:44 <byorgey> fully raytraced window compositing! woohoo!
20:34:21 <SamB_XP> byorgey: I suppose that could work
20:35:01 <SamB_XP> that way you say "look, don't make your own shadows, the scene manager will do it for you"
20:35:17 <byorgey> then you could have a special magnifying glass window that ACTUALLY WAS a magnifying glass!
20:35:49 <SamB_XP> but... could we use it to burn ants?
20:35:55 <Baughn_> You'd want to do reverse raytracing for extra accuracy and algorithm simplicity
20:36:09 <byorgey> SamB_XP: virtual ants, sure
20:36:22 <SamB_XP> Baughn_: what, you mean from the light source to the eye?
20:36:30 <SamB_XP> that is called forward raytracing
20:36:38 <Baughn_> SamB_XP: It works for physics. And no, it's not.
20:36:44 <SamB_XP> yes it is!
20:36:52 <SamB_XP> the normal kind is backwards ;-P
20:36:54 <Baughn_> How about we compromise?
20:37:07 <Baughn_> The normal kind is left raytracing, the other kind is right
20:37:18 <byorgey> lol!
20:37:20 <SamB_XP> that sounds about right ;-)
20:38:28 <fuzan> what if the window decoration says somethign entirely important
20:38:29 <fuzan> like,
20:38:39 <fuzan> "if you press ok, your system will blow up"
20:38:44 <jcreigh> hmm. is there an "ifM"?
20:38:59 <emu> guard
20:39:12 <byorgey> @type guard
20:39:14 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
20:39:29 <Baughn_> fuzan: If you do that as a decoration, clearly you /intend/ for the window to blow up
20:39:50 <ddarius> fiM b t e = guard b >> t `mplus` e
20:40:00 <byorgey> hmm... that couldn't work in xmonad, blowing up isn't typesafe
20:40:17 <ddarius> byorgey: Why do you say that?
20:40:22 <byorgey> I guess you could use an unsafePerformBlowup
20:40:41 <jcreigh> @src guard
20:40:41 <lambdabot> guard True  =  return ()
20:40:41 <lambdabot> guard False =  mzero
20:41:03 <SamB_XP> byorgey: I think the program that blows up is written in C
20:41:07 <ddarius> jcreigh: Other than when and unless, the answer to your question is no.
20:41:19 <jcreigh> ddarius: okay
20:41:19 <emu> @type when
20:41:21 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
20:41:27 <jcreigh> I'm looking for the equivilent of:
20:41:28 <emu> forgot about when =)
20:41:37 <jcreigh> do foo <- someThing blah
20:41:39 <jcreigh> if foo
20:41:40 <jcreigh> then lala
20:41:42 <jcreigh> else blah
20:41:42 <byorgey> SamB_XP: heh.  are there any that don't?
20:41:54 <SamB_XP> byorgey: I think true(1) might not
20:42:14 <ddarius> jcreigh: I.e. liftM (\b -> if b then t else e) ?
20:42:45 <Baughn_> SamB_XP: I found a buffer overflow in /bin/true once
20:42:47 <ddarius> But true(2) is a killer
20:43:03 <SamB_XP> Baughn_: !
20:43:15 <byorgey> see, I told you
20:43:18 <SamB_XP> damn GNU and their overcomplicated programs
20:43:20 <Jaggederest> true actually has non-zero complexity :( :( :(
20:43:28 <SamB_XP> byorgey: how about *BSD* true(1)
20:43:28 <Jaggederest> it's 14 lines
20:43:57 <byorgey> SamB_XP: hm, maybe
20:44:11 <byorgey> SamB_XP: I dare you to prove it, though =)
20:44:27 <jcreigh> ddarius: but liftM lifts the result..."blah" and "lala" already in the corrent monad in my example. (Guess I could have made that clear...)
20:44:35 <jcreigh> *correct
20:44:54 <ddarius> jcreigh: No, I just wasn't thinking.
20:45:46 <SamB_XP> liftM if'?
20:45:52 <byorgey> jcreigh: what's wrong with the code you posted, with an explicit if...then...else?
20:46:17 <byorgey> @src if'
20:46:17 <lambdabot> Source not found. Wrong!  You cheating scum!
20:46:23 <byorgey> SamB_XP: what's if'?
20:46:32 <jcreigh> byorgey: nothing....but Haskell has a nice combinator for everything!
20:46:41 <byorgey> jcreigh: ok, I understand =)
20:46:46 <LoganCapaldo> @djinn Bool -> a -> a -> a
20:46:46 <lambdabot> f a b c =
20:46:46 <lambdabot>     case a of
20:46:46 <lambdabot>     False -> c
20:46:46 <lambdabot>     True -> b
20:47:18 <byorgey> jcreigh: you could do it with arrows but that's probably overkill...
20:47:56 <byorgey> jcreigh: or just roll your own combinator.
20:48:25 <LoganCapaldo> @type arr True
20:48:27 <lambdabot>     Couldn't match expected type `b -> c' against inferred type `Bool'
20:48:27 <lambdabot>     In the first argument of `arr', namely `True'
20:48:54 <byorgey> ok, goodnight all
20:49:19 <SamB_XP> LoganCapaldo: wow.
20:49:22 <ddarius> SamB_XP: That's more what I was intending.
20:49:29 <LoganCapaldo> instance Arrow Bool where arr True = \x y -> x; arr False = \x y -> y;
20:49:42 <LoganCapaldo> SamB_XP: ?
20:49:49 <SamB_XP> I can't believe djinn actually built the *right* function
20:50:01 <LoganCapaldo> SamB_XP: I never tire of seeing that :)
20:50:03 <SamB_XP> it had like four choices after all
20:50:13 <SamB_XP> so how did it know we wanted that one?
20:50:48 <ddarius> It used the variables in order perhaps.  It (can) produce(s) all possibilities.
20:51:15 <SamB_XP> ddarius: it didn't either
20:51:26 <LoganCapaldo> yeah variable in order plus enumerating Bool to make the case perhaps
20:51:31 <ddarius> No, it didn't.
20:51:35 * ddarius should sleep.
20:51:38 <shapr> @where gplib
20:51:38 <lambdabot> http://www.haskell.org/haskellwiki/GPLib
20:51:48 <shapr> ddarius: Talk to me about MonadTs!
20:51:50 * shapr grins
20:51:55 <LoganCapaldo> well no that didn't work
20:52:02 * shapr teases ddarius
20:52:05 <LoganCapaldo> > [False..]
20:52:05 <lambdabot>  Parse error
20:52:16 <ddarius> MonadT's pity the foo.
20:52:19 <LoganCapaldo> > succ False
20:52:20 <lambdabot>  True
20:52:27 <ddarius> > [False .. ]
20:52:29 <lambdabot>  [False,True]
20:52:30 <LoganCapaldo> > let x = False in [x..]
20:52:30 <shapr> ddarius: argh
20:52:31 <lambdabot>  [False,True]
20:52:54 <ddarius> shapr: I agree
20:53:08 <MechaBlue> Hello
20:53:58 <Jaggederest> > negate (-0)
20:53:59 <lambdabot>  0
20:54:07 <Jaggederest> > negate 0
20:54:09 <lambdabot>  0
20:54:19 <Jaggederest> > 0 == (-0)
20:54:20 <lambdabot>  True
20:54:38 <Jaggederest> k just checking
20:54:40 <Baughn_> > (-0.0 :: Double) == (0.0 :: Double)
20:54:41 <lambdabot>  True
20:55:49 <Jaggederest> > negate (-0) == (-0)
20:55:50 <lambdabot>  True
20:56:33 <ddarius> > fix negate
20:56:34 <lambdabot>  Exception: <<loop>>
20:57:56 <Jaggederest> (\x y z -> z y x) 2 3 +
20:58:07 <Jaggederest> > (\x y z -> z y x) 2 3 +
20:58:07 <lambdabot>  Parse error
20:58:13 <Jaggederest> > (\x y z -> z y x) 2 3 (+)
20:58:15 <lambdabot>  5
20:58:23 <Jaggederest> RPN = happy
20:58:30 <sioraiocht> lol
20:58:32 <sioraiocht> I hate RPN
20:59:04 <Jaggederest> ? yourself screw go
20:59:07 <Jaggederest> :)
21:00:34 <Jaggederest> one of the guys from thoughtworks told me I should learn Forth
21:01:29 <SamB_XP> yourself screw apply
21:02:07 <SamB_XP> in the postscript-style raytracer microlanguage
21:02:29 <SamB_XP> I think
21:05:19 <Jaggederest> I think forth holds the distinction of being the only language with less syntax than Lisp
21:08:42 <edwardk> is there anyway to pass the -l<library> flag that you need to call ghci with when you use ffi function calls from a library in an {-# OPTIONS_GHC #-} kind of way? it gets a little repetitive when there are a bunch. trying -l<foo> in OPTIONS_GHC doesn't seem to work
21:09:34 <edwardk> "unknown flags in  {-# OPTIONS #-} pragma: -lidn"
21:10:03 <SamB_XP> edwardk: you could try adding them to a .ghci file?
21:10:16 <edwardk> ah never knew such a beast existed
21:10:37 <SamB_XP> :set -lidn
21:10:46 <SamB_XP> that will be the syntax if it works ;-)
21:10:46 <edwardk> woot that should work
21:14:12 <edwardk> doesn't appear to work in there, but that does alleviate some of my other config option needs
21:15:22 <SamB_XP> yeah. it seems like it never works when you most want it to.
21:15:26 <edwardk> =/
21:15:29 <SamB_XP> well, my next suggestion is a .sh file ;-)
21:26:37 <dcnstrct> hey could someone explain what the >> operator does ?  I'm new to haskell, and can't really google this one.
21:26:50 <Korollary> @src (>>)
21:26:51 <lambdabot> m >> k      = m >>= \_ -> k
21:27:09 <dcnstrct> ah!!
21:27:20 <dcnstrct> a shorthand for binding to an anonymous function
21:27:24 <bd__> @undo a >> b
21:27:24 <lambdabot> a >> b
21:27:29 <bd__> er
21:27:30 <bd__> @do a >> b
21:27:31 <lambdabot> a >> b not available
21:27:33 <bd__> aw
21:27:34 <LoganCapaldo> @undo do { a; b }
21:27:35 <lambdabot> a >> b
21:27:42 <LoganCapaldo> @redo a >> b
21:27:42 <lambdabot> do { a; b}
21:28:03 <LoganCapaldo> @undo do { x <- a; b x }
21:28:03 <lambdabot> a >>= \ x -> b x
21:28:52 <Baughn_> dcnstrct: Did that clear things up?
21:29:06 <LoganCapaldo> basically its for when you want to sequence two monadic computations a and b and b has type m something, and not something -> m somethingelse
21:30:15 <dcnstrct> yea that clears things up
21:30:19 <LoganCapaldo> @type (>>)
21:30:21 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> m b -> m b
21:30:43 <LoganCapaldo> @type (>>=)
21:30:44 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
21:33:13 <dcnstrct> seeing this: m >> k      = m >>= \_ -> k cleared things up
21:33:51 <dcnstrct> the type is still confusing
21:33:54 <dcnstrct> but I"ll learn
21:34:32 <dcnstrct> thnx people, back to the grindstone
21:34:40 <dancor> this are both possible in css: "a<sp>b<sp>{" and "a<sp>b<sp>c{".  <sp> is space to emphasize its tokenness.  does that mean css with whitespace tokens is not LALR(1)
21:34:45 <dancor> s/this/these
21:35:39 <dancor> bc after "a<sp>b" it is impossible to know based on just "<sp>" next if we are done with the pre-{ part?
21:37:44 <bdash> dancor: why is space a token and not just a separate between tokens?
21:37:50 <LoganCapaldo> dancor: I may be talking out my butt here, but I think you got it backwards. You don't look for the _end_ of pre-{ part, you look for the _start_ of the { part
21:38:09 <LoganCapaldo> iow, the '{' is your 1 token lookahead
21:38:29 <dancor> bdash: "a:b{}" is different from "a :b{}" and "c{a:b}" is a whole nother thing
21:39:00 <dancor> LoganCapaldo: yeah that makes sense.  i'm still getting killed on this space thing
21:39:56 <dancor> bdash: so i could tokenzie a:b as one thing but then it would be hacky for "c{a:b1 b2}"
21:40:12 <bdash> dancor: yeah, i see
21:41:30 <LoganCapaldo> dancor: theres always cheating.
21:41:42 <dancor> LoganCapaldo: what kind
21:41:47 <LoganCapaldo> use a different tokenizer inside the braces as opposed to outside
21:43:32 <LoganCapaldo> I don't recall if they can nest in CSS, but if they can't its not even _that_ evil
21:43:49 <bdash> dancor: you might want to have a look at http://trac.webkit.org/projects/webkit/browser/trunk/WebCore/css/CSSGrammar.y for some ideas
21:43:52 <lambdabot> Title: /trunk/WebCore/css/CSSGrammar.y - WebKit - Trac, http://tinyurl.com/369ht2
21:45:38 <LoganCapaldo> (and by recall, I really mean "don't know"
21:46:27 <bdash> LoganCapaldo: they can't, but i think that could make error handling tricky
21:47:01 <LoganCapaldo> mmm hmm
21:50:57 <LoganCapaldo> dancor, theres a finite number of a: for inside { correct?
21:50:58 <Korollary> http://en.wikibooks.org/wiki/Main_Page
21:50:59 <lambdabot> Title: Main Page - Wikibooks, collection of open-content textbooks
21:51:17 <LoganCapaldo> dancor: {a:b} is things like font-family: ...
21:51:19 <Korollary> "Write Yourself a Scheme in 48 Hours" is a featured wikibook
21:51:19 <LoganCapaldo> ?
21:54:04 <LoganCapaldo> dancor: assuming that's true, the grammar could look like <tokens for a:b or a :b etc> '{' (PROPERTY VALUE)* } where property could be "font-family" spaces* ':' | "color" spaces* : | ...  etc.
22:15:05 <Cale> Programming algorithms on Young tableaux *really* makes me wish that I had views, or some similar feature for pattern matching the same data in different ways.
22:15:46 <skew> pattern guards?
22:16:02 <Cale> mm, that might work
22:31:10 <lispy> i've never taken the time understand the proposal for views, but i've also never understood why it's unimplemented
22:32:33 <MechaBlue> Using functions in the pattern guards should work if type Maybe a is returned.  It's possible to get most of the funcitonality of Prolog that way, I think.
22:33:33 <MechaBlue> You may need to optimize it by calculating the result in a let or where section to avoid calculating it twice.
23:43:16 <MechaBlue> A newb question about Monads.  The type of the >>= function is m a -> (a -> m b) -> m b
23:44:30 <MechaBlue> I get a type mismatch error if I have x <- f in a do block if f is of type a -> m b but it works if f is of type m b
23:44:48 <MechaBlue> Is this correct behavior or am I doing something wrong?
23:45:11 <Lemmih> MechaBlue: do x <- f; ...   ===   f >>= \x -> ...
23:45:49 <Lemmih> MechaBlue: 'f' is the first argument to >>=, not the second.
23:47:23 <MechaBlue> Okay, thanks.  I'll fiddle some more and see if I can get my head around it.
23:54:17 <MechaBlue> The value that binds with x is the parameter of the second parameter of >>= when it is run?
23:54:30 <MechaBlue>     (>>=) (Log (ss, a)) fn = let
23:54:32 <MechaBlue>         (Log (ss', a')) = fn a
23:54:34 <MechaBlue>         in Log (ss ++ [">>="] ++ ss', a')
23:54:42 <MechaBlue> In this case it's a?
23:55:19 <Lemmih> Yes.
23:56:28 <MechaBlue> Thank you very much.  You've helped me out tremendously.
23:57:13 <Lemmih> You're welcome.
