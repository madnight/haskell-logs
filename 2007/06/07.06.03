00:00:08 <kolmodin> is Setup.hs or Setup.lhs the preferred name for setups in Cabal? I can't recall
00:00:19 <bos> lhs
00:00:41 <bos> it lets you use a "#!/usr/bin/env runhaskell" at the beginning of the script
00:00:54 <kolmodin> right, thanks
00:01:59 <kolmodin> that doesn't matter in this case, but sure
00:06:42 <jyp> ghc libs use .hs
00:08:18 <stick_figure> sjanssen, so mapM is like map for monad values?
00:08:30 <bos> stick_figure: yep
00:08:31 <sjanssen> stick_figure: correct
00:08:35 <sjanssen> @src mapM
00:08:35 <lambdabot> mapM f as = sequence (map f as)
00:08:41 <sjanssen> @type mapM
00:08:43 <lambdabot>     Ambiguous occurrence `mapM'
00:08:43 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
00:08:46 <sjanssen> grr
00:09:13 <sjanssen> dons: ^^^ can we fix that?
00:09:22 <sjanssen> @type Prelude.mapM
00:09:24 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
00:09:31 <sjanssen> @type Prelude.map
00:09:32 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
00:09:42 <dons> sjanssen: hmm. submit a patch against lambdabot?
00:09:49 <dons> i'm not sure why i haven't done it yet
00:11:38 <sjanssen> dons: are these imports part of RunPlugs?
00:13:37 <sjanssen> nevermind, found them
00:24:54 * Lemmih prefers not to have a setup script at all.
00:36:58 <Excedrin> this Frink thing is really neat
01:59:47 <vegai> http://code.google.com/p/scalacheck/
01:59:48 <lambdabot> Title: scalacheck - Google Code
01:59:54 <vegai> fascinating, I didn't know they could do that there :)
02:03:17 <LeCamarade> vegai: Now everyone is copying us. :o(
02:03:17 <LeCamarade> :oD
02:05:45 <Heffalump> scala isn't pure, is it?
02:06:19 <dons> right.
02:06:19 <LeCamarade> Heffalump: Can't be - it has a lot of imperativeness. And OO. A Java kind of thing.
02:10:35 <dibblego> Heffalump, no
02:10:51 <araujo> hello
02:10:52 <dibblego> I was actually working on QuickCheck for Scala; didn't know I was repeating work
02:10:57 <dibblego> but I think it can be done better
02:11:09 * araujo thinks scala is a java-like semi-functional language
02:11:19 <vegai> multi-paradigm language, rather
02:12:19 <LeCamarade> But if you give the imperative option, it will be used a lot at the expense of the functional one.
02:12:34 <araujo> well, one of the characteristic of java is that it tries to enforce two different paradigms .... isn't the same on scala?
02:12:37 <dons> would be interesting to see the implementation. QC in Haskell is remarkably small
02:12:46 <dibblego> LeCamarade, I have hundreds of LOC of Scala, with a single update for memoisation
02:13:17 <dibblego> dons, it is a single source file - in Scala, you can't reflect on type parameters so I don't know how it works (tomorrow's job)
02:14:01 <LeCamarade> Most things will almost always come in shorter in Haskell. That's an unfair comparison.
02:14:21 <dons> QC uses some very haskellish features though. it'd be particularly problematic
02:14:40 <dibblego> dons, I've had little trouble implementing many of Haskell's ideas in Scala
02:14:50 <araujo> dibblego, such as?
02:15:02 <dibblego> araujo, MPTC two days ago (fresh on my mind :))
02:15:12 <araujo> :-)
02:15:36 <dibblego> the Scala designer acknowledges the limitations of no higher-order polymorphism
02:15:57 <dibblego> e.g. list/for-comprehensions have no common interface, but rely on certain functions being implemented anyway
02:16:19 <dibblego> I could imagine a similar thing for do-notation should the language ever get it
02:18:26 <LeCamarade> dons said, in his latest blog post, that QC helped the xmonad people take radical turns while staying valid. Because the checks had already been wired in. Strengthens my views that QC-like stuff should be in the syntax.
02:18:54 <dibblego> in the syntax? what's wrong with a library?
02:19:30 <dons> LeCamarade: you mean embedded in comments , or near the code that it tests?
02:19:34 <dons> much like type declarations?
02:19:34 <LeCamarade> dibblego: Because a library may or may not be used. I want a compiler to compile only functions that won't break under a QC-like check.
02:20:02 <LeCamarade> dons: No, not in comments. Yes, like type declarations. As part of the syntax that the compiler deals with.
02:20:07 <dons> it did. we were able to be far more adventurous than i'd have dared in a wm written in C.
02:20:15 <araujo> LeCamarade, You mean, QC part of Haskell?
02:20:18 <dons> s/QC let us be wacky/
02:20:26 <dibblego> LeCamarade, "won't break under a QC-like check"?
02:20:47 <dibblego> LeCamarade, QC is non (necessarily) exhaustive and so does not form a proof
02:21:17 <LeCamarade> Of course there would have to evolve a neat notation. If a function can be proven wrong by QC, why should it compile? We give the Software Crisis more water, and then complain that it isn't dying.
02:21:47 <LeCamarade> Yeah, QC is not the ultimate. But it would be a beginning. :o) At least it checks enough.
02:22:11 <dibblego> but it doesn't check enough - you would get a false sense of security - I think even the paper mentions this
02:22:28 <LeCamarade> araujo: Yeah. I know the MetaOCaml guys have already linked Coq into the syntax. Vive la plus belle langage de programmation!!!
02:22:44 <dons> there are preprocessors for theorem provers in haskell too.
02:23:00 <dons> the Agda guys do that, and there's a lot of haskell/isabelle work.
02:23:16 <LeCamarade> dibblego: Nothing can prove absence of errors. Not in programming. But if the shallow QuickChecking can uncover an error, why should such a program compile?
02:23:43 <LeCamarade> dons: Okay, okay. *hands up*
02:23:44 <dibblego> LeCamarade, it shouldn't, by why should it be integrated into the compiler? for what benefit?
02:24:02 <LeCamarade> dibblego: To get checking done *always*. That's why.
02:24:23 <dibblego> to get checking done always requires a proactive effort on behalf of the developer anyway
02:24:54 <LeCamarade> dibblego: It should be like type-checking. A feature of the langauge that grabs bugs. That simple.
02:25:18 <dibblego> LeCamarade, you could argue such a thing already exists; surely there is a way to run a function during compilation?
02:26:11 <LeCamarade> Yeah. It exists. Or can be hacked into the compilation process. It's not novel in any way. What I am against is that it can be omitted, unlike, say, type-checking.
02:26:49 <dibblego> maybe I'm missing something but nothing can prevent it from being omitted
02:30:07 <araujo> mmm... if it should be added or not ... i am not sure ... i mean, you also can *always* use it as a library.
02:34:54 <dibblego> I can understand the desire for it to be an extension of the type system, but I don't think anything can be done to enforce anything, unless you fail compilation because of a minimum coverage or something; "your function accepts n inputs and your QC does not test the minimum (n/m) inputs"
02:37:29 <LeCamarade> dibblego: Think, for example, of ndm's Catch (is it ndm?) which tells you if you have taken care of all potential patterns. It's nifty. It's a checker. Should it be built into the syntax? Well, it is, in OCaml. And in OCaml you are warned about incomplete patterns.
02:37:37 <LeCamarade> That kind of thing.
02:38:38 <Heffalump> LeCamarade: on a local or a global level?
02:38:53 <Heffalump> GHC warns about incomplete patterns in any given function, if you ask it to
02:39:06 <Heffalump> the point of Catch is that if you have incomplete patterns, it checks whether they can actually arise or not
02:39:10 <LeCamarade> Heffalump: Yes. With flags. :o(
02:39:18 <LeCamarade> Heffalump: Oh.
02:39:34 * LeCamarade never used Catch; sticks to standard stuff. :o(
02:40:26 <LeCamarade> Heffalump: And I find it very sexy that it checks for those that can arise. Very, very nifty.
02:41:00 <Heffalump> the point about the type system is that although it only checks some properties, it does so in a complete and well-specified way
02:41:36 <Heffalump> checkers like QuickCheck and Catch, because they are essentially working on undecidable problems, can only provide a partial solution whose quality is very dependent on the quality of their implementation (whether of the tool itself or the tests you write using it)
02:41:55 <LeCamarade> *nod*
02:42:09 <Heffalump> so building that into the type system is a dubious proposition, because suddenly the set of programs that pass becomes dependent on the version of the tool you have.
02:42:15 <Heffalump> Unless you bake a particular algorithm in.
02:42:30 <Heffalump> and with QuickCheck, it checks random input data. So your program may randomly "type-check" or not
02:43:54 <LeCamarade> Isn't the QC algo sturdy enough? I mean, the C type-checking system is one that can be wrong at some point (due to some type-cast at some point). But it works well enough most of the time.
02:44:34 <LeCamarade> Actually, I see one function compiling now and failing the next time. I see.
02:44:42 <dibblego> the input data is random (see the type-class Arbitrary)
02:44:52 <LeCamarade> dibblego: Yeah.
02:48:26 <Heffalump> also, with Catch, suppose your program fails. What does that mean, apart from that it can never call an incomplete match but Catch isn't clever enough to detect it? It might also mean that it can never call an incomplete pattern-match because of constraints on the input Catch doesn't know about.
02:57:01 <filcab42> hi
02:57:08 <filcab42> does anyone else think this is weird?
02:57:11 <filcab42> func4' = map (+2) . filter ((flip elem) [1..10]) . (5:)
02:57:17 <filcab42> Main> :t func4'
02:57:17 <filcab42> func4' :: [Integer] -> [Integer]
02:57:33 <filcab42> Main> :t map (+2) . filter ((flip elem) [1..10]) . (5:)
02:57:33 <filcab42> map (flip (+) 2) . filter (flip elem (enumFromTo 1 10)) . (5 :) :: (Enum a, Num a) => [a] -> [a]
02:57:50 <filcab42> if I just copy & paste func4's definition, it gives me a different type :s
02:57:59 <Lemmih> filcab42: -fno-monomorphism-restriction
02:58:15 <filcab42> what does that do?
02:58:58 <Lemmih> Disables the monomorphism restriction.
02:59:04 <LeCamarade> @go monomorphism restriction site:haskell.org
02:59:06 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/monomorphism.html
02:59:06 <lambdabot> Title: 7.14. Control over monomorphism
02:59:10 <filcab42> right
02:59:14 <filcab42> thanks LeCamarade
02:59:15 <LeCamarade> filcab42: ^^
03:10:11 <araujo> morning
03:11:12 <fridim> foldl (max) 0 [3,10,14,6] is the same as (max (max (max (max 0 3) 10) 14) 6)  and fldr (max) [3,10,14,6] ?
03:12:06 <Saizan> foldr max 0 [3,10,14,6] = max 3 (max 10 (max 14 (max 6 0)))
03:12:20 <Saizan> in this case being max commutative the result is the same
03:12:33 <mux> @type maximum
03:12:40 <lambdabot> forall a. (Ord a) => [a] -> a
03:12:42 <mux> just in case you don't know this one :)
03:13:00 <mux> @src maximum
03:13:00 <lambdabot> maximum [] = undefined
03:13:01 <lambdabot> maximum xs = foldl1 max xs
03:13:36 <araujo> geez, that's the bad thing about Haskell ... it does so much stuff for you in such an easy way .......
03:14:02 <mux> this implementation works, using foldl or foldr with max and 0 would add the 0 element to the list of elements being considered
03:14:29 <mux> so you'd have maximum [-1,-2,-3] return 0 with your implementation
03:14:53 <fridim> mux it comes from a tutorial about foldr foldl filter, map
03:14:57 <fridim> I don't use it
03:15:23 <mux> I thought it might be useful to mention it anyways, whether you use it or not :)
03:15:32 <fridim> np :)
03:16:53 <fridim> foldl1 afunc x:xs= foldl afunc x xs ?
03:16:59 <xpika> i found a function 'run :: String -> IO String' in cpuperf is there a ghc library equivalent?
03:17:14 <fridim> @src foldl1
03:17:14 <lambdabot> foldl1 f (x:xs) = foldl f x xs
03:17:14 <lambdabot> foldl1 _ []     = undefined
03:17:30 <fridim> I nearly found it :)
03:25:37 <mdmkolbe|home> I'm writing a paper with lhs2TeX, any suggestions on how to format a sample GHCi interations?  (I've tried \eval{} and \perform{} but they act a little weird and I still have to descide on formatting stuff like the prompt.)
03:27:08 <kfish> mdmkolbe|home, i do something like this (faking the prompt):
03:27:10 <kfish> \begin{verbatim}
03:27:11 <kfish> *Main> :type undefined::Int
03:27:11 <kfish> \end{verbatim}
03:27:11 <kfish> \eval{:t undefined:: Int}
03:33:05 <mdmkolbe|home> kfish: for some reason, \eval{:t undefined :: Int} is producing "it :: () undefined :: Int :: Int"
03:35:07 <byorgey> @seen dons
03:35:07 <lambdabot> dons is in #xmonad, #haskell-soc, #haskell-overflow, #haskell and #ghc. I last heard dons speak 12m 50s ago.
03:35:27 <Lemmih> @type undefined :: Int
03:35:28 <Lemmih> @type (undefined :: Int)
03:35:29 <lambdabot> Int :: Int
03:35:30 <lambdabot> Int
03:35:41 <bartw> @type return
03:35:42 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
03:36:16 <kfish> mdmkolbe|home, i guess it gives whatever your ghci says ... but how does the lhs2Tex output look for you?
03:36:23 <dangb> I'm using iterate to do a calculation, as in iterate f x !! n to get the n-th result, which is the only element of that list which I need. For large n, I get a stack space overflow.
03:36:42 <dangb> I tried fixing this using: apply f x 0 = x
03:36:49 <dangb> apply f x n = apply f (f x) (n-1)
03:37:10 <dangb> which I think is tail recursive, but it didn't work either
03:37:18 <dangb> How do I fix this?
03:37:28 <Saizan> dangb: you need a little more strictness
03:38:05 <Saizan> ?src foldl'
03:38:06 <lambdabot> foldl' f a []     = a
03:38:06 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
03:38:55 <mdmkolbe|home> kfish: I just realized the problem, I had ":set +t" on, which I guess lhs2TeX doesn't play well with.  What do you mean by "how does the lhs2TeX output look for you"?
03:38:57 <bartw> ?src `seq`
03:38:57 <lambdabot> Source not found. Are you on drugs?
03:39:22 <Saizan> so apply f x n = let (x',n') = (f x,n-1) in x` `seq` apply f x' (n-1)
03:39:27 <Saizan> last is n'
03:39:30 <kfish> mdmkolbe|home, oh, your original question was about formatting ghci output for lhs2tex :-)
03:39:33 <Heffalump> I wish you luck trying to implement that in Haskell :-)
03:39:33 <dangb> Saizan: ok thanks
03:39:38 <mdmkolbe|home> bartw: "seq" forces the computation of the first argument then returns the value of the second argument
03:39:56 <mdmkolbe|home> kfish: what did you think I was asking?
03:40:26 <bartw> mdmkolbe|home : why is that needed in a lazy language ?
03:40:41 <Saizan> ?type \f x -> iterate (f.($!)) x !! n
03:40:43 <lambdabot> Not in scope: `n'
03:40:46 <Saizan> ?type \f x n -> iterate (f.($!)) x !! n
03:40:48 <lambdabot> forall a b. ((a -> b) -> a -> b) -> (a -> b) -> Int -> a -> b
03:41:05 <Saizan> ?type \f x n -> iterate (f $!) x !! n
03:41:06 <lambdabot> forall b. (b -> b) -> b -> Int -> b
03:41:09 <mdmkolbe|home> bartw: it's only needed for efficiency reasons b/c otherwise you can end up with space leaks
03:41:44 <bartw> eek, so its a way to second guess the engine ?
03:42:36 <syntaxfree> http://futureboy.us/frinkdocs/
03:42:38 <lambdabot> Title: Frink
03:42:45 <syntaxfree> some of that functionality can be written in Haskell I guess.
03:42:52 <mdmkolbe|home> bartw: typical use looks like "foo x y = a `seq` b where a = big_long_computation; b = other_computation_always_depending_on_b"
03:43:09 <Heffalump> bartw: kind of, yes
03:43:11 <Lemmih> Saizan: The (n-1) is already strict.
03:44:12 <bartw> won't that introduce dependencies on specific implementations of haskell ?
03:44:12 <Heffalump> the key point is that a might be a big computation (takes up lots of space when unevaluated) and b is a long computation that will take lots of time to get round to evaluating a
03:44:13 <Saizan> Lemmih: ah,  because of the first clause, right?
03:44:22 <Heffalump> bartw: it's part of the language spec
03:44:40 <Lemmih> Saizan: Yes, it's compared to '0' at every iteration.
03:44:47 <mdmkolbe|home> bartw: seq has no symanic effect, but if you know 'a' will always be used if ever 'b' is used and that 'a' occupies a lot of heap space until it gets forced (or that forcing it to late might cause a stack overflow) then using seq can save you from that
03:45:35 <Heffalump> it does have a semantic effect, if b actually doesn't use a and a is _|_, it introduces non-termination
03:45:43 <bartw> right, so collapse 'a' early so that more space is available for other stuff, but does it preserve lazy semantics ?
03:45:52 <Heffalump> bartw: no.
03:46:00 <Heffalump> it's a strictness annotation :-)
03:46:43 <bartw> _|_ i'm guessing means that it creates an infinite list or something ?
03:46:43 <mdmkolbe|home> bartw: using seq does not introduce any semantic dependance on a particular implementation but yes, like any optimization it might only be needed for some implementations and is usually added after the original code was written when a leak is discovered
03:46:48 <Saizan> bartw: however seq "collapses" only to weak head normal form, which means the first constructor
03:47:03 <Saizan> > Just undefined `seq` ()
03:47:05 <lambdabot>  ()
03:47:22 <mdmkolbe|home> bartw: _|_ is bottom/the non-terminating computation/undefined
03:48:01 <bartw> right, so 'seq' is a 'it doesn't work' 'give it a whack' sollution ?
03:48:20 <Heffalump> kind of, yes
03:48:22 <dangb> Saizan: pasted from the code I just compiled: apply f x n = let x' = f x in x' `seq` apply f x' (n-1)
03:48:24 <Heffalump> an infinite list is not _|_, btw
03:48:29 <dangb> this still doesn't work
03:48:34 <Heffalump> "let x = x in x" is bottom
03:48:50 <Saizan> dangb: do you compile with -O2?
03:49:02 <Heffalump> but you can do stuff with an infinite list, like look at a finite number of elements from it
03:49:17 <dangb> Saizan: no, that's probably it
03:49:41 <bartw> one q, where can i find a descrition of the 'in' func/keyword/operator ?
03:49:55 <dangb> Saizan: I tried that, no luck
03:50:03 <Pseudonym> bartw: It's always used with "let".
03:50:07 <Pseudonym> let pat = expr in expr
03:50:08 <mdmkolbe|home> bartw: it's a keyword.  let a = b; c = d in barf
03:50:20 <mdmkolbe|home> @where report
03:50:21 <lambdabot> http://www.haskell.org/onlinereport/
03:50:21 <Saizan> dangb: have you added the base case, right?
03:50:28 <dangb> yes
03:50:47 <dangb> for smaller n, the output is correct
03:50:53 <Heffalump> what is the definition of f?
03:51:20 <Heffalump> forcing the result to WHNF may not be enough
03:52:00 <Lemmih> Heffalump: Why wouldn't it be enough?
03:52:37 <Heffalump> because f might be building something bigger
03:52:42 <Saizan> dangb: uhm, which is the n you need?
03:52:42 <mdmkolbe|home> Lemmih: 'a `seq` b' => 'Just a `seq` b'
03:52:44 <Heffalump> e.g. a list of stuff
03:52:52 <Lemmih> Heffalump: That doesn't matter.
03:53:06 <dangb> Saizan: 1000000
03:53:13 <bartw> let x = x in x, where can i find some manual that can explain what this does ?
03:53:21 <Heffalump> why not? Are you deducing something from the fact that it's a stack overflow?
03:53:23 <Lemmih> Heffalump: We're just trying to collaps the call stack.
03:53:29 <dangb> it works with one zero less
03:53:58 <roconnor> > let x = x in x
03:53:59 <lambdabot>  Exception: <<loop>>
03:53:59 * Heffalump doesn't entirely understand what uses the stack
03:54:20 <Heffalump> but surely f $! x might turn into some quite complicated unevaluated thunk that has to be evaluated later?
03:54:22 <mdmkolbe|home> bartw: most haskell tutorials should cover that
03:55:12 <mdmkolbe|home> bartw: you could also read the haskell report (the spec for haskell) but it's not the most readable thing in the world
03:55:52 <Lemmih> Heffalump: 'x' used to be 'f (f (f ...)))'. That will quickly blow the stack. Using seq will collaps that call stack no matter how lazy 'f' is.
03:56:53 <Heffalump> fair enough, but does that guarantee that there's no other blowup?
03:56:56 <Saizan> with n=1000000 and f=(+1) it ends even without -O
03:56:56 <bartw> ah right, get it now
03:57:55 <Heffalump> if f x = 1:g x, won't we end up blowing up when we look at the final list produced, for example?
03:58:40 <dangb> Saizan: ok, I noticed that my f is constructed using partial application which uses parameters of the function that calls apply
03:58:41 <mdmkolbe|home> bartw: to help me become a better future professor, what should I have said that would have helped you understand quicker? (or if you prefer, what was the key insite that helped you understand?)
03:58:57 <roconnor> Isn't it only primops that use the stack?  like integer plus and times, etc?
03:59:12 <mdmkolbe|home> roconnor: all functions use the stack
03:59:17 <Lemmih> Heffalump: Indeed, but that manifestation is slightly different.
03:59:24 <dangb> Saizan: using seq on those didn't help, though
03:59:26 <Heffalump> mdmkolbe|home: you should learn to spell "insight" to become a better future professor ;-)
03:59:34 <Heffalump> Lemmih: ok, fair enough. What is it?
03:59:41 <roconnor> mdmkolbe|home: can you give me a program that only uses algebraic data types, and blows up the stack?
03:59:55 <mdmkolbe|home> Heffalump: I though bad spelling was one of those prerequisites of being a professor ;-)
04:00:08 <Heffalump> roconnor: foldr (+1) 0 [1..10000000]
04:00:22 <Saizan> dangb: can you paste the code?
04:00:23 <roconnor> Heffalump: + is a primop
04:00:27 <Heffalump> oh, I see
04:00:29 <dangb> yes
04:00:40 <roconnor> and those numbers aren't an algebraic data type
04:00:43 <Lemmih> Heffalump: You'd be able to access the the data structure as long as you keep it in WHNF.
04:00:46 <Heffalump> yes, I understand your point now
04:00:50 <dangb> throw_fuel_packet dm v_rel (m,v) = (m-dm, v - dm / m * v_rel)
04:00:51 <dangb>  
04:01:14 <Saizan> dangb: on hpaste
04:01:17 <Saizan> @paste
04:01:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
04:01:31 <Heffalump> Lemmih: ok, something that evaluates under a lambda
04:01:33 <bartw> mdmkolbe|home : i found the 'gentle introduction' and saw that let x = x in x transforms to somethign like "x defined by (x), evaluate x, apply the definition recursively" -> endless recursion on the definition
04:02:15 <mdmkolbe|home> bartw: ok, thx
04:02:42 <dangb> Saizan: ok
04:02:54 * mdmkolbe|home spends a moment meditating on the psychology entailed by that
04:03:45 <Lemmih> dangb: throw_fuel_packet dm v_rel (!m,!v) = (m-dm, v - dm / m * v_rel)
04:03:55 <Lemmih> dangb: (with -fbang-patterns)
04:03:57 <hpaste>  dangb pasted "(no title)" at http://hpaste.org/130
04:04:17 <roconnor> let x = x in x presumably builds a graph with a node that refers to itself.  There is no reduction rule for this, so the <<loop>> exception is thrown. (in GHC.)
04:04:28 <dangb> Lemmih: I'll try that
04:04:32 <Heffalump> GHC can detect it because it marks thunks it is evaluating
04:04:39 <Heffalump> so if it tries to enter such a thunk again it notices
04:04:56 <mdmkolbe|home> > let f () = f () in f ()
04:04:58 <lambdabot>  Exception: <<loop>>
04:05:00 <Heffalump> "let x () = x () in x ()" is a standard example of non-termination where it can't
04:05:03 <Heffalump> oh.
04:05:09 <Heffalump> well, I guess it's getting cleverer..
04:05:15 <roconnor> Heffalump: GHC is getting smarter
04:05:16 <mdmkolbe|home> Heffalump: heh, yeah
04:05:23 <Heffalump> > let f n = f (n+1) in f 0
04:05:25 <Heffalump> hah, that'll get it
04:05:28 <lambdabot> Terminated
04:05:52 <bartw> :)
04:06:07 <Lemmih> dangb: You can also use bang-patterns to remove that nasty 'seq'.
04:06:16 <mdmkolbe|home> > let f b x = if b then f x else False in f True ()
04:06:17 <lambdabot>      Occurs check: cannot construct the infinite type: t = Bool -> t
04:06:17 <lambdabot>     Prob...
04:06:21 <dangb> Lemmih: thanks, I just noticed
04:06:23 <mdmkolbe|home> > let f b x = if b then f b x else False in f True ()
04:06:25 <lambdabot>  Exception: <<loop>>
04:07:19 <mdmkolbe|home> ghah, just when I figured out when GHC will and wont detect loops, they change it on me (ok, I didn't figure it out; it was explained to me)
04:07:23 <mdmkolbe|home> @version
04:07:23 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
04:07:23 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
04:07:27 <Heffalump> what optimisation is GHC doing to detect that?
04:07:46 <Heffalump> and does lambdabot compile fragments with -O2?
04:07:52 <dangb> thanks Saizan and Lemmih, it works!
04:08:24 <Saizan> Lemmih: so we needed something more than reducing to WHNF?
04:08:41 <bartw> the 'in' keyword here is confusing
04:08:54 <dangb> by the way, why aren't bang patterns part of the standard? there is something like that for data types if I recall correctly
04:08:56 <Heffalump> bartw: it's just a keyword to split the definitions from the expression
04:09:02 <Lemmih> Saizan: Kinda, there were two problems.
04:09:33 <bartw> Heffalump : i expected to do somethign else
04:09:39 <mdmkolbe|home> Heffalump: a local ghci (6.6) doesn't seem to detect that loop
04:10:13 <Heffalump> mdmkolbe|home: did you try compiling with -O2?
04:10:22 <mdmkolbe|home> bartw: observe
04:10:23 <mdmkolbe|home> > let a = 1; b = 2 in a + b
04:10:25 <lambdabot>  3
04:10:44 <mdmkolbe|home> Heffalump: yep, both "ghci -O2" and "ghci" don't detect the loop
04:11:05 <Heffalump> what does ghci -O2 do?
04:11:05 <bartw> mdmkolbe|home : yes that i see, what i mean is that i expected it to bind a lhs to a value or domain specified by a rhs, something liek the imperative "x in [1..10]"
04:11:48 <mdmkolbe|home> bartw: ah, you mean like set/list membership/iteration ?
04:12:00 <Heffalump> ghc -O2 detects it for me
04:12:01 <Heffalump> also 6.6
04:12:08 <Heffalump> i.e. put it in a file, print it from main, compile, run
04:12:19 <Heffalump> I suspect that's what lambdabot is doing, roughly.
04:12:37 <bartw> mdmkolbe|home : thats what i expected, and why i didn't understand it, i expected let x = x in x to be : "let x = ( x in x )"  :)
04:12:54 <mdmkolbe|home> bartw: hehe, I see
04:13:38 <bartw> which also has a bit of semantic recursion possibilities, unless x is the U collection
04:13:44 <dangb> will bang-patterns be in the next haskell revision?
04:15:29 <mdmkolbe|home> how do I tell GHC to stop being smart when it claims "complication is NOT required" even though it is required b/c I changed the command line flags
04:15:56 <Saizan> -no-recomp ? (or is it the opposite?)
04:16:09 <Botje> touch the .hs file
04:16:23 <mdmkolbe|home> Botje: ok, that worked
04:16:33 <Saizan> -no-recomp works too
04:17:49 <bartw> laters
04:18:08 <Igloo> You can use the more intuitive -fforce-recomp these days
04:18:15 <mdmkolbe|home> Heffalump: ok, I see the same detection (but only under -O2 and GHC not GHCi).  I suspect the optimizer is doing something that just happens to expose a 'let x = x in x' sort of loop.
04:27:21 <LeCamarade> Igloo is a lot like a phantom. A mystery. Only speaks as though invoked by a ritual. And he solves your problem, then he vanishes.
04:28:34 <LeCamarade> Or to kickban some idiot or something. And I saw a picture of him from the Hackathon ... it all makes him seem mystical. Forgive me, but ... :o)
04:29:03 <mdmkolbe|home> LeCamarade: pic link?
04:29:29 <LeCamarade> @go haskell hackathon site:haskell.org
04:29:30 <lambdabot> http://haskell.org/haskellwiki/Hac_2007
04:29:31 <lambdabot> Title: Hac 2007 - HaskellWiki
04:31:16 <LeCamarade> Or, more accurately, http://haskell.org/haskellwiki/Hac_2007/GroupPhoto
04:31:17 <lambdabot> Title: Hac 2007/GroupPhoto - HaskellWiki
04:32:02 <mdmkolbe|home> awsome
04:35:16 <Cynos> Hi all. I'm a Haskell newbie, and just exploring the bits and bobs that I'd need to start writing a web scraper in Haskell.
04:35:26 <kfish> Hi Cynos
04:35:42 <Cynos> I'm currently playing with Network.Browser, and am a bit confused at the moment.
04:36:08 <Cynos> It's relating to a data definition as follows:
04:36:09 <Cynos> type FormVar = (String,String)
04:36:09 <Cynos> data Form = Form RequestMethod URI [FormVar]
04:36:13 <kfish> Cynos, you could try tagsoup
04:36:16 <kfish> @where tagsoup
04:36:16 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
04:36:17 <Cynos> Hi kfish :)
04:37:15 <Cynos> Hey, that's brilliant.
04:37:32 <Cynos> Thanks kfish, that resolves about 98% of my issues :)
04:40:37 <Cynos> However, I think I'm still going to need to use Network.Browser to retrieve the pages I'm after easily, as they require cookie authentication.
04:41:09 <Cynos> But TagSoup looks like Python's BeautifulSoup, so thanks once again. :)
04:41:37 <kfish> does it look like it's possible to plug the two together?
04:41:47 <kfish> ie. use Browser to fetch the data, and TagSoup to parse it?
04:42:06 <Cynos> yeah, definitely.
04:42:13 <Cynos> TagSoup has a readfile function.
04:43:07 <Cynos> At the worst, otherwise, all input to the parseTags function looks to be the results of openURL
05:20:34 <roconnor> wow, there is an http 3000!
05:20:36 <hpaste>  Japsu pasted "less ugly broken convolution" at http://hpaste.org/133
05:20:51 <Japsu> disregard that
05:21:37 <Cynos> Okay... here's another newbie question.
05:21:46 <Cynos> A function in Browser needs a URI.
05:22:26 <roconnor> parseURI ?
05:22:37 <Cynos> Yes, but it's returning Maybe URI for me?
05:22:54 <roconnor> well, you need to handle that error in some way
05:23:05 <roconnor> in case the string isn't a valid uri
05:23:19 <Cynos> Um.
05:23:22 <roconnor> what to do depends on how you got that string
05:24:17 <roconnor> In my case I have constant strings
05:24:20 <Cynos> Okay, so I'm providing the URI, so it's definitely correct.
05:24:41 <LoganCapaldo> > (\uri -> case uri of Just u -> u; Nothing -> "http://www.default.com") (Just "google.com")
05:24:42 <roconnor> so I just do (Just example) = parseURI "http://www.example.com/"
05:24:43 <lambdabot>  "google.com"
05:24:52 <LoganCapaldo> > (\uri -> case uri of Just u -> u; Nothing -> "http://www.default.com") Nothing
05:24:53 <lambdabot>  "http://www.default.com"
05:25:20 <roconnor> so example is a ``global variable''
05:25:47 <roconnor> (of course it doesn't vary)
05:27:29 <Cynos> Oh wow.
05:27:55 <Cynos> Okay, so that (Just x) thing is what I needed to do - I'd been trying it without the brackets.
05:28:46 <roconnor> So if you ever provide a broken string, you will get a runtime error when you use it. :(
05:28:52 <LoganCapaldo> Cynos: f Just x = two argument function; f (Just x) = one argument function matching a maybe value
05:29:16 <Cynos> LoganCapaldo - thanks. That was where my thinking was going wrong
05:29:44 <Cynos> So Just will "unwrap" a value passed from a Maybe?
05:30:05 <Cynos> I have to apologise, Haskell is a significant paradigm shift for me.
05:30:31 <roconnor> parse URI is returning a (Just somethingorother)
05:30:41 <roconnor> so you are doing a pattern match on the resulting value
05:30:49 <Philippa> Cynos: pattern-matching unwraps values
05:30:53 <roconnor> Just x pattern matches with (Just somethingorother)
05:31:04 <roconnor> the two Just s match each other
05:31:10 <Cynos> Ahhh.
05:31:12 <roconnor> and the x gets bound to whatever somethingorother is
05:31:25 <Philippa> f (Just x) = ... is sugar for f = \var -> case var of {Just x -> ...}
05:32:14 <Cynos> So what's being returned from parseURI is a value that maybe either just a URI or nothing... if I can coin an awkward phrase.
05:32:36 <Philippa> that's exactly right, yeah
05:32:37 <Cynos> Hence, until I determine which one it is, it's neither.
05:32:39 <Cynos> ?
05:32:54 <Philippa> until you determine which it is, you've no idea and can't do anything with it
05:33:00 <Cynos> Wow.
05:33:08 <Philippa> you can't get clawed to death by the POed cat until you open the box
05:33:23 <Cynos> Hahah, was trying to think of a suitable QM joke.
05:33:24 <Cynos> :D
05:33:36 <Cynos> Ah well, thanks heaps all, that was illuminating. :)
05:34:24 <Saizan> all of this because Maybe is defined like data Maybe a = Just a | Nothing
05:36:33 <LoganCapaldo> it's really like quantum mechanics, because pattern matching it really coudl change the value, since it might be a thunk :)
05:36:52 <roconnor> LoganCapaldo: except there is no superpositon
05:37:15 <roconnor> er
05:37:19 <LoganCapaldo> roconnor: I knew someone was gonna complain about the scientific soundness of my joke :)
05:37:30 <roconnor> :)
05:37:32 <roconnor> sorry
06:07:19 <Syzygy-> > log 25000 / log 6
06:07:21 <lambdabot>  5.651780430223261
06:09:02 <LoganCapaldo> > 6 ^ 5.651780430223261
06:09:03 <lambdabot>  Add a type signature
06:09:09 <LoganCapaldo> > 6.0 ^ 5.651780430223261
06:09:10 <lambdabot>  Add a type signature
06:09:16 <LoganCapaldo> > 6.0 ** 5.651780430223261
06:09:17 <lambdabot>  25000.00000000002
06:09:22 <LoganCapaldo> hoooray
06:09:34 <Syzygy-> :t (^)
06:09:35 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:09:43 <Syzygy-> That's why.
06:09:47 <LoganCapaldo> Does anyone else hate Haskell's exponent operators?
06:09:49 <Syzygy-> It requires the exponent to be integral.
06:10:00 <EvilTerran> it's a performance thing, i guess
06:10:15 <EvilTerran> both ^ and ** are traditionally used for exponentiation
06:10:15 <Syzygy-> I can see a point in not requiring all exponents to work in a completed domain too...
06:10:54 <LoganCapaldo> "Let's take all the common spellings for exponent, give them different types, but since their common spellings of exponent theres no easy way to remmeber which is which! Brilliant!"
06:11:08 <LoganCapaldo> It's nto that there ae 2 variations
06:11:20 <roconnor> :type (^)
06:11:24 <roconnor> @type (^)
06:11:26 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:11:28 <roconnor> @type (^^)
06:11:29 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:11:30 <LoganCapaldo> its that there are two variations that both look like "exponent operator"
06:11:34 <roconnor> @type (**)
06:11:36 <lambdabot> forall a. (Floating a) => a -> a -> a
06:11:38 <LoganCapaldo> well ok more than 2 variations :)
06:11:38 <EvilTerran> (^) is simpler to type, and in definition, than (**)
06:11:39 <roconnor> there are 3
06:11:57 <LoganCapaldo> I'm just ranting
06:12:00 <EvilTerran> (that's how I remember it, anyway)
06:12:02 <LoganCapaldo> and raving
06:12:15 * EvilTerran gives LoganCapaldo a glowstick
06:12:25 <tuukkah> @src (^)
06:12:25 <lambdabot> Source not found. I've seen penguins that can type better than that.
06:12:29 * LoganCapaldo shoves a pacifier in his mouth
06:12:31 <tuukkah> ta
06:13:29 <tuukkah> i bet the definitions give some sense
06:14:17 <EvilTerran> is there a good guide to Control.Parallel.Strategies around somewhere? the haddock leaves much to be desired
06:15:18 <eumenides> documentation is frowned upon in the haskell world
06:16:12 <mdmkolbe|home> ?type (^^)
06:16:14 <lambdabot> forall a b. (Integral b, Fractional a) => a -> b -> a
06:16:17 <mdmkolbe|home> ?type exp
06:16:19 <lambdabot> forall a. (Floating a) => a -> a
06:16:20 <mdmkolbe|home> ?type (^)
06:16:22 <lambdabot> forall a b. (Integral b, Num a) => a -> b -> a
06:16:24 <mdmkolbe|home> ?type (**)
06:16:26 <lambdabot> forall a. (Floating a) => a -> a -> a
06:16:40 <tuukkah> x ^^ n          =  if n >= 0 then x^n else recip (x^(negate n))
06:16:45 <mdmkolbe|home> did I miss any?
06:16:56 <EvilTerran> surely there's at least a technical paper or something?
06:17:51 * Heffalump isn't aware of one
06:17:59 <Heffalump> Use the source :-)
06:18:24 <tuukkah> (^) is implemented by multiplication
06:18:42 <tuukkah> > 2 ^ (-1)
06:18:44 <lambdabot>  Exception: Prelude.^: negative exponent
06:18:49 <tuukkah> like this
06:18:57 <tuukkah> > 2 ^^ (-1)
06:18:58 <lambdabot>  0.5
06:19:36 <EvilTerran> it would appear that I don't have the source. a quick look thru the GHC folder reveals nowt relevant but some .hi files
06:20:47 <Heffalump> http://darcs.haskell.org/ghc-6.6/packages/base/Control/Parallel/Strategies.hs
06:20:51 <lambdabot> http://tinyurl.com/22ed3w
06:22:06 <EvilTerran> ah. thankyou.
06:22:24 <Heffalump> http://www.macs.hw.ac.uk/~trinder/publications, and in particular section 4.3 of http://www.macs.hw.ac.uk/~trinder/papers/ParDistrHaskells.ps and the stuff referenced there, may also be useful
06:22:26 <lambdabot> Title: Phil Trinders Publications
06:22:48 <Heffalump> and then submit a patch ;-)
06:30:16 <tuukkah> and this you can't hope to have for rational numbers, can you: x ** y = exp (log x * y)
06:31:42 * EvilTerran wonders if it'd be possible to reduce these to a single exponentiation operator with data families
06:32:21 <tuukkah> multi-parameter type clae
06:32:24 <tuukkah> classes
06:32:45 <EvilTerran> or that
06:33:25 <EvilTerran> altho having a "class Exponential a b c" or what-have-you would be somewhat messy
06:41:21 <Heffalump> I don't see how data families would help you, per se.
06:41:30 <Heffalump> Inside a type class (i.e. associated types), yes
06:41:45 <Heffalump> but you won't be able to define (^) without some class restriction on the arguments
06:42:29 <EvilTerran> eh, true. i just read up a bit on data families; even with sth like that, you'd still need a class
06:43:02 <Heffalump> the other way it might become possible in future is if they support open functions.
06:43:19 <Heffalump> But then you'd get runtime failures when you weren't using the right types, which would kind of suck
06:43:21 <EvilTerran> so "class Exp a b c where (^) :: a -> b -> c" would be the way to go, then. for now, at least
06:44:06 <EvilTerran> (possibly with some Num restrictions in there)
06:44:13 <Heffalump> forever, IMO. The type constraint is precisely what you want.
06:44:35 <tuukkah> you don't need to separate a and c, at least in the current implementation
06:45:08 <Heffalump> I can't see what other type you'd want (^) to have than Exp a b c => a -> b -> c, unless you can actually encode what is and isn't possible in the type signature more orthogonally.
06:45:29 <EvilTerran> actually, i rathe rsuspect that sort of approach would give overlapping instances
06:45:48 <EvilTerran> given that you want something different for Integral b and Num b, say
06:45:49 <tuukkah> or, there's this problem of the negative exponent which turns an integer into a rational
06:46:25 <LoganCapaldo> make integer a subtype of rational :)
06:46:37 * LoganCapaldo whistles innocently
06:46:51 <tuukkah> and negative numbers a subtype of numbers
06:47:07 <LoganCapaldo> Now you've gone too far! :)
06:47:10 <tuukkah> no, make it supertype :-)
06:47:16 <EvilTerran> let's add some Olegs to it and do it in the typesystem
06:47:33 <EvilTerran> who needs runtime calculation anyway ;p
06:48:49 <EvilTerran> to change subject entirely, i've been reading about stream fusion etc. very cool stuff.
06:48:53 <cinimod> >1+2
06:49:03 <cinimod> @help
06:49:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
06:49:07 <EvilTerran> > {- <- that space is necessary -} 1+2
06:49:09 <lambdabot>  3
06:49:24 <cinimod> How embarassing
06:57:51 <EvilTerran> i had to think about it for a bit, but i eventually got my head around why you only need Done, Yield a s and Skip s (and not, say, YieldMany [a] s); with Skip, you could write concatStreams :: Stream (Stream a) -> Stream a, rendering sth like YieldMany redundant
06:59:34 <LoganCapaldo> mmmmm
06:59:49 <LoganCapaldo> EvilTerran: the type of the function jsut made me wonder something
06:59:57 <LoganCapaldo> Stream monad anyone?
07:00:14 <EvilTerran> i was just thinking that, to
07:00:15 <EvilTerran> o
07:00:33 <LoganCapaldo> I suppose its just the list monad effectively
07:00:38 <LoganCapaldo> maybe not
07:01:38 <EvilTerran> if/when streams become used internally for lists, it would kinda make sense to just make the list monad a wrapper for some stream monad
07:02:18 <EvilTerran> s/for lists/for optimising list processing pipelines/
07:08:03 <ajudem_me> Hi there
07:08:09 <ajudem_me> @paste
07:08:09 <lambdabot> Haskell pastebin: http://hpaste.org/new
07:08:35 <wolverian> xmonad needs alt-tab functionality
07:09:07 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/134
07:09:20 * Saizan is pretty sure tu have used alt-tab successfully with xmonad
07:09:46 <ajudem_me> can you help me with this?
07:10:01 <wolverian> there's alt-tab, but it's not the same thing as regular wms' alt-tab :)
07:10:02 <ajudem_me> it says that there's an error in "correcto = ..."
07:10:14 <arcatan> wolverian: in what sense it isn't?
07:10:16 <wolverian> you can't flip between two windows with it
07:10:23 <wolverian> it wants to always cycle through the list completely
07:10:45 <wolverian> (the behaviour I want is probably only useful in fullscreen mode.)
07:10:48 <twanvl> ajudem_me: That line needs to be indented the same as the programa = ...
07:10:58 <wolverian> (er, I take that back. it's useful generally.)
07:11:21 <daniel_larsson> You'd put the window in the master pane to make it act more like standard alt-tab
07:11:37 <ajudem_me> twanvl... isn't it?>?
07:11:41 <twanvl> A tab is 8 spaces in Haskell
07:12:07 <wolverian> daniel_larsson, hm?
07:12:12 <wolverian> I don't see how that makes any difference.
07:12:20 <ajudem_me> twanvl... I'm not getting it...
07:12:34 <arcatan> wolverian: oh. you might find dwmpromote useful
07:12:42 <arcatan> it's not that useful in fullscreen mode, though
07:13:10 <hpaste>  twanvl annotated "(no title)" with "It should be like this" at http://hpaste.org/134#a1
07:13:17 <wolverian> arcatan, thanks.
07:13:19 <arcatan> you can use it to switch between two topmost windows in the stack
07:14:16 <daniel_larsson>  I was thinking of swapping to master pane to make "alt-tab" + "alt-tab" to get you back to the original window
07:15:29 <int-e> ajudem_me: set your editor to use a tab size of 8, or not to use tabs at all; right now it appears to be using a tab size of 4 which is wrong.
07:15:45 <ajudem_me> twanvl, int-e, tnks... that's really the problem
07:15:54 <ajudem_me> do you know how to do that in eclipse?
07:23:12 <EvilTerran> ?type getChanContents
07:23:14 <lambdabot> Not in scope: `getChanContents'
07:23:24 <EvilTerran> getChanContents :: Chan a -> IO [a]
07:24:05 <EvilTerran> does that /\ block if there's nothing presently in the channel, or return []?
07:28:44 <desp>     Unacceptable result type in foreign declaration:
07:28:45 <desp>         FunPtr (Ptr () -> CSize -> CSize -> Ptr () -> IO ())
07:28:46 <EvilTerran> (a test says it blocks)
07:28:53 <desp> any clues why's that?
07:29:29 <desp> foreign import ccall "wrapper" mkWriteFunction :: CURLWriteFunction -> FunPtr (CURLWriteFunction)
07:29:42 <desp> where CURLWriteFunction is that type visible above
07:30:50 <desp> ahh, forgot IO.
07:31:03 <desp> sorry. :)
07:38:46 <hpaste>  ajuda pasted "what's wrong?" at http://hpaste.org/135
07:39:16 <ajuda> can you please tell me what's wrong here?
07:39:52 <Saizan> ajuda: the "in" should be aligned with "let"
07:41:03 <hpaste>  ajuda annotated "what's wrong?" with "(no title)" at http://hpaste.org/135#a1
07:41:14 <ajuda> stills wrong =\
07:41:24 <ajuda> still's wrong
07:42:22 <ajuda> nop... it isn't! ;)
07:55:40 <sioraiocht> wow, I'venever seen #haskell this quiet
07:55:58 <Heffalump> I have.
07:56:03 <Heffalump> But that was several years ago :-)
08:00:37 <hpaste>  ajuda pasted "illegal '_' in expression" at http://hpaste.org/136
08:00:47 <ajuda> any ideas?
08:01:38 <sioraiocht> yeah, you can't use _ in a comparison
08:02:00 <sioraiocht> what are you trying to compare p+linha to?
08:02:02 <ajuda> sioraiocht but I want to ignorate that part of the pair... how do I do it?
08:02:20 <sioraiocht> well, what are you comparing p_linha to, exactly?
08:02:48 <sioraiocht> or would like to
08:03:11 <ajuda> sioraiocht, the only part of the p_linha that I want to compare is prk_tk
08:03:20 <sioraiocht> ohhhh, okay
08:03:59 <sioraiocht> now the other issue is where is that tuple coming from
08:04:07 <sioraiocht> what you would do is have a where clause
08:04:27 <ajuda> how's that?
08:04:54 <sioraiocht> one sec
08:06:13 <hpaste>  sioraiocht pasted "analiza_s_program with where clause" at http://hpaste.org/137
08:06:18 <sioraiocht> try that
08:06:35 <sioraiocht> "some value" needs to be that you pattern matching to isolate prg_tk
08:07:04 <ajuda> I'm not sure that's what I want
08:07:16 <ajuda> hmm... programa is a list
08:07:23 <sioraiocht> a list of...?
08:07:24 <ajuda> of pairs
08:07:26 <sioraiocht> okay
08:07:28 <ajuda> like:
08:07:39 <ajuda> (Int, Int, [String])
08:07:42 <sioraiocht> okay
08:08:03 <sioraiocht> and what is this function supposed to do?
08:08:23 <ajuda> I want to make sure that th esecond it is "0"
08:08:28 <sioraiocht> ah!
08:08:32 <ajuda> and the first string is tk_str
08:08:47 <hpaste>  twanvl annotated "illegal '_' in expression" with "Use pattern matching" at http://hpaste.org/136#a1
08:08:53 <sioraiocht> and tk_str is a predefined variable?
08:10:30 <ajuda> twanvl tnks =)
08:10:37 <ajuda> I've never used data types
08:10:42 <ajuda> so I'm not very used to it
08:10:49 <ajuda> are they usefull??
08:10:59 <twanvl> Yes
08:11:03 <twanvl> Tuples are horrible
08:11:37 <Stinger> blasphemy
08:12:07 <hpaste>  sioraiocht annotated "illegal '_' in expression" with "(no title)" at http://hpaste.org/136#a2
08:12:19 <sioraiocht> that should work as well
08:12:26 <sioraiocht> haha I like tuples
08:12:39 <sioraiocht> depends on if you plan to unpack the whole tuple everytime or not, though
08:13:05 <twanvl> Pairs are fine, but if you do something complicated, like in this case, defining a data type will make your code much more readable
08:13:15 <sioraiocht> twanvl: I would agree
08:14:29 <twanvl> For a bad example of tuple abuse see: http://darcs.haskell.org/yhc/src/compiler98/CaseLib.hs
08:15:01 <ajuda> twanvl... well... I'm used to prolog, so It's more familiar to me in tuples way!;P
08:15:20 <ajuda> and I've to deliver this work tomorrow, so I think I'll stick to the plan ;)
08:15:32 <ajuda> but thnks a lot!! =)
08:15:45 <sioraiocht> ajuda: did any of the code get your question answered?
08:15:51 <sioraiocht> cuz that's what matters ;)
08:15:52 <ajuda> yup =)
08:15:54 <sioraiocht> k good
08:16:11 <sioraiocht> Linha..is that portuguese?
08:16:54 <sioraiocht> I've never seen programming done where the identifiers were in a different language than the keywords, lol
08:17:11 <emu> go unicode haskell
08:17:32 <sioraiocht> anyone here have experience with OCaml?
08:17:51 <LoganCapaldo> sioraiocht: I didn't either until I started hanging out on IRC. Apprently its more common than one might expect
08:18:33 <sioraiocht> LoganCapaldo: I guess it makes sense.  I would just be annoyed if keywords were in a different language.  but afaik Pascal is the only language with translations
08:19:15 <ajuda> sioraiocht, yes.. it's the portuguese word for "line" ;)
08:19:54 <sioraiocht> ajuda: thought so, enough of the words were spanish cognates.  are you brazilian or portuguese?
08:20:12 <sioraiocht> no one here does OCaml? I was wondering if it's worth learning/looking at
08:20:22 <ajuda> sioraiocht... yes, I'm portuguese (and I'll go to brasil in onde month!! ;))
08:20:31 <emu> most things are worth learning if you have time
08:20:35 <ajuda> *one
08:20:42 <sioraiocht> ajuda: I'm jealous!
08:21:01 <sioraiocht> emu: even LOLCODE?
08:21:02 <ajuda> lol.. =) you should!! that looks wonderfull!! ;P
08:21:02 <sioraiocht> =p
08:21:12 <emu> naturally
08:21:20 <sioraiocht> CANHAS 1?
08:21:25 <emu> hmm
08:21:33 <LoganCapaldo> especially LOLCODE
08:21:46 <emu> well, if ocaml drives you batty, you could just switch over to SML for a similar taste
08:22:05 <LoganCapaldo> SML: OCaml with half the calories :)
08:22:11 <bos> haskelly people tend not to be all that interested in ocaml
08:22:46 <emu> module functors are cool and worth learning about
08:23:15 <sioraiocht> bos: why's that? I noticed a lot of FP jobs ask for OCaml experience, that's why I ask
08:23:34 <sioraiocht> because doing FP programming appeals to me for a job after school, instead of find some job fixing someones broken C++ code
08:25:10 <bos> sioraiocht: i couldn't generalise. for me, i don't like ocaml's syntax, and the usual "but you can choose any syntax you want!" response seems entirely wrong.
08:25:41 <bos> and i don't find myself wanting any of ocaml's features, except for perhaps its module system.
08:25:46 <sioraiocht> bos: It's hard to love any syntax after haskell's, although Lua's is pretty, too
08:27:22 <bos> i also got started with haskell long before ocaml came on the scene.
08:27:30 <therp> I really MISS that per default not all Haskell ADTs are "deriving Show"
08:28:00 <therp> this makes the "I just print everything" debugging strategy unnecessarily hard
08:28:09 <therp> (and that's all there is for haskell)
08:31:11 <Heffalump> sioraiocht: what jobs are advertised for O'Caml, apart from Jane Street Capital?
08:32:49 <sioraiocht> Heffalump: other finance jobs
08:33:50 <sioraiocht> Heffalump: I've seen a few haskell jobs, too, out there.  Even google makes them hard to find, I find them by accident
08:35:39 <sioraiocht> and unless I get a faculty or research position, that's what I'd want to do
08:36:58 <desp> sioraiocht: I learned SML and OCaml before I started with Haskell. OCaml apparently has a pretty fast compiler.
08:37:49 <desp> while I rather liked the language itself, I feel Haskell is both more succint and expressive
08:38:35 <desp> actually, I'm certain of that. :)
09:37:12 <kolmodin> jcreigh: neat floating layers!
09:38:19 * ddarius may actually get Linux working with his wireless and will be able to start using it.
09:43:25 <desp> @hoogle String -> CString
09:43:25 <lambdabot> No matches, try a more general search
09:43:30 <desp> @hoogle String -> IO CString
09:43:31 <lambdabot> Foreign.C.String.newCAString :: String -> IO CString
09:43:31 <lambdabot> Foreign.C.String.newCString :: String -> IO CString
09:56:50 <desp> records--
10:04:30 <bos> desp: what are you trying to do?
10:05:29 <desp> bos: just disliking the syntax.
10:06:21 <desp> bos: I need to keep alive all strings passed to the library, so I thought of keeping a ForeignPtr with a finalizer for each string together with the library handle
10:07:17 <bos> you need to keep them alive until you get back some sort of completion notification?
10:07:33 <desp> keep them alive as long as the library handle is in use
10:07:50 <desp> well, or until the string in question is replaced by a subsequent function call
10:08:03 <bos> what kinds of strings are these?
10:08:10 <bos> what are they being passed to?
10:08:21 <desp> for example, the url string :)
10:08:40 <bos> ok, so you're holding onto them until e.g. a request completes.
10:10:20 <desp> mutiple requests may reuse the same options set on a handle
10:11:38 <bos> so the url is an option on the handle?
10:11:44 <desp> yes
10:11:53 <desp> see here: http://curl.haxx.se/libcurl/c/curl_easy_setopt.html
10:11:55 <lambdabot> Title: libcurl - curl_easy_setopt()
10:12:52 <bos> btw, i assume you're trying to keep the CString alive, not the String?
10:12:56 <desp> yes
10:13:38 <bos> ok
10:27:30 <roconnor> @src Network.listenOn
10:27:31 <lambdabot> Source not found. You speak an infinite deal of nothing
10:35:55 <edwinb> Hmmm. "happy: parE" That's helpful...
10:36:24 <roconnor> > iNADDR_ANY
10:36:25 <lambdabot>   Not in scope: `iNADDR_ANY'
10:37:26 <roconnor> @hoogle iNADDR_ANY
10:37:26 <lambdabot> Network.Socket.iNADDR_ANY :: HostAddress
10:38:12 <sorear> edwinb: I complained months ago to JaffaCake
10:38:45 <edwinb> Yes, I notice I'm not the first person to get this error...
10:38:46 <sorear> edwinb: his response was approximately "I have difficulty believing I ever wrote code that dumb"
10:38:50 <edwinb> heh
10:38:56 <sorear> followed by "but there it is"
10:39:17 <edwinb> any idea what causes it or if there's a workaround?
10:39:41 <sorear> (a) stupid programmers (b) yes
10:40:27 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/138
10:41:59 <edwinb> it sounds rather like I have to examine my grammar to find out what I've done wrong. ah well.
10:42:51 <msingh> is there a way to write map in terms of fold without reversing the list at the end?
10:43:24 <sorear> map f = foldr((:).f)[]
10:43:46 <sorear> @unpl \f->foldr((:).f)[]
10:43:47 <lambdabot> \ f -> foldr (\ c -> ((:)) (f c)) []
10:43:48 <Cale> Don't use foldl
10:44:00 <sorear> Not just in this case.
10:44:14 <sorear> Don't use foldl unless you have a very good reason
10:44:22 <Cale> right :)
10:44:58 <kpreid> what would be a good reason to use foldl?
10:45:03 <Cale> If you're going to use foldl, it's fairly likely that foldl' would be better.
10:45:24 <Cale> But right folds are more natural in most cases.
10:46:13 <Cale> foldl' is good for when you're collapsing the list down to something which can't be partially evaluated, because it forces the evaluation all the way down the list right away.
10:46:49 <kpreid> sorear: What would be a good reason to use foldl (not foldl')?
10:46:50 <Cale> foldl still requires recursing all the way down the list, but still leaves you with an expression that can be lazily evaluated
10:47:32 <msingh> what is the difference between foldl and foldl'?
10:47:56 <sjanssen> msingh: foldl' forces the accumulated value on each step
10:48:34 <msingh> oh it is to do with laziness?
10:48:37 <Cale> yeah
10:48:48 <Cale> foldl is still a bit lazy
10:49:01 <msingh> ok, thanks
10:49:38 <shachaf> Cale: Where would be a place where you'd want to use foldl?
10:51:23 <SamB> shachaf: I've been asking that question for years, and I always forget the answer, too!
10:51:41 <Cale> It's pretty rare actually. The conditions are that the combining function can possibly not need its first parameter, and that the thing is *really* a left fold, and not something you can naturally write as a right fold.
10:52:01 <Cale> (Of course, you can always do it in a convoluted way)
10:53:17 <Cale> foldl f z goes all the way down the list [1,2,3,4,5] and leaves you with an expression that looks like f (f (...) 4) 5
10:54:53 <Cale> If say, you're interested in using foldl to get the last even number in the list, then foldl will work better than foldl' :)
10:55:16 <Cale> (though that's a little funny)
10:55:19 <kpreid> huh, okay.
10:55:40 <kpreid> how does that compare to foldr f . reverse?
10:56:17 <Cale> Maybe we can characterise the set of things on which foldl does better as the set of things which foldr can stop early on with the reversed list
10:56:20 <Cale> grr, my local wired network connection keeps dropping
11:00:31 <Cale> foldl f z = foldr (flip f) z . reverse
11:01:16 <Cale> Except that foldl doesn't construct the intermediate list.
11:01:53 <Cale> Left folding is a pretty unnatural operation :)
11:02:12 <Heffalump> it kind of implicitly does, in the chain of thunks
11:02:25 <kpreid> I agree with Heffalump
11:02:47 <kpreid> hm, will each thunk contain a reference to f?
11:02:58 <Heffalump> yes, instead of being a cons cell
11:03:00 <Cale> yeah
11:03:31 <kpreid> so if there is no other significant difference, foldr+reverse is superior :)
11:03:46 <Cale> Hm?
11:03:50 <SamB> so... 4 words vs 3 words?
11:04:09 <Cale> foldr + flip + reverse is equivalent, but takes more typing
11:04:11 <SamB> (4 for the thunk, 3 for the cons cell)
11:09:31 <Cale> On a long list, foldr (flip f) z . reverse used a tiny amount more memory than foldl and took just a little bit more time, but they're close enough that the difference likely doesn't matter.
11:10:38 <Cale> (adding up a 200000 element list, the difference was a consistent 0.01 seconds and about 6% more memory)
11:10:51 <MarcWeber> What is going on here? Is only the first package databse taken into account? http://rafb.net/p/xwa1Iq77.html
11:10:52 <lambdabot> Title: Nopaste - No description
11:11:18 <Cale> MarcWeber: base2?
11:11:47 <MarcWeber> Cale What do you mean by base2 ?
11:12:05 <MarcWeber> oh
11:12:18 <MarcWeber> Thanks
11:12:41 <Cale> no problem :)
11:13:06 <msingh> does foldr start processing from the end of the list?
11:13:39 <Cale> No, it starts from the beginning.
11:14:12 <Cale> foldr f z [1..5] immediately gives f 1 (...)
11:14:24 <Cale> where the (...) is another call to foldr
11:14:29 <msingh> ok, weird in CL reduce seems to be a foldl by default - but if you say :from-end t then it is a foldr
11:14:40 <Cale> Right, CL is a strict language
11:14:45 <Cale> so everything is backwards
11:15:19 <Heffalump> or forwards, depending on your point of view.
11:15:40 <infrared> taken out of context this would make a nice quote of the week ;)
11:15:52 <infrared> "CL is a strict language so everything is backwards"
11:16:53 <Cale> In lazy languages, things are evaluated outermost first, and in strict ones, innermost first.
11:17:16 <Cale> Which is why foldr starts at the beginning of the list.
11:17:23 <emu> reduce being a foldl' makes sense in CL
11:17:28 <Cale> and it's foldl that runs all the way to the end
11:18:26 <MarcWeber> Can't I install a package into a package database if the dependencies are located in another?
11:19:00 <Cale> That's not the right way to think about foldr though. The right way is to picture foldr f z as replacing each (:) in the list with f and the [] with z
11:19:58 <Cale> It does this in essentially "constant time", though it adds up to linear time if you use the whole list.
11:20:32 <Cale> MarcWeber: I'm afraid I have no experience with multiple package databases.
11:21:55 <MarcWeber> Cale: I should start reading the code ;)
11:21:56 <pejo> Cale, I don't think it's fair to say that foldr is essentially constant time.
11:23:48 <Cale> It's constant time on each node of the list.
11:24:03 <Cale> But you might not even use them all, or any of them.
11:24:44 <Saizan> you pay only for what you take :)
11:25:01 <infrared> this way all lazy operations are constant time... until you use them ;)
11:25:32 <Heffalump> you should account for their memory usage too
11:26:16 <Cale> Well, actually, I could put it in a stronger way... if f returns a constructor in constant time, then foldr f z xs will return a constructor in constant time when evaluated to WHNF
11:27:03 <bartw> how can space ever be bigger then time ?
11:27:05 <Cale> So it's "potentially constant time under evaluation"
11:27:19 <bartw> it takes time to init/read/write the space
11:27:26 <drakferion> ( Could someone please help me with some really simple trouble? I'm stuck with data conversion from a type to another. In this case int to char, so i can concatenate an int between two strings and send it to a Java program. )
11:28:10 <Cale> drakferion: Int to String, or do you want the unicode character with that index?
11:28:21 <infrared> bartw: you usually count time/memory in accordance to application input
11:28:21 <drakferion> Int to Str.
11:28:28 <Cale> drakferion: show
11:28:31 <Cale> > show 35
11:28:33 <lambdabot>  "35"
11:28:47 <Cale> > show 32718
11:28:48 <lambdabot>  "32718"
11:28:49 <Excedrin> > "foo " ++ show 35 ++ " bar"
11:28:51 <lambdabot>  "foo 35 bar"
11:29:08 <Philippa> Cale: I'd say "linear in demand"
11:29:14 <Excedrin> does lambdabot have Text.Printf?
11:29:29 <Cale> Philippa: yeah, that's a reasonable way to put it
11:29:47 <shachaf> > printf "%d" 1 :: String
11:29:48 <lambdabot>  "1"
11:29:49 <drakferion> <3 ! show is precisely what i was looking for. Damned newbs, eh? Thanks for your time. :)
11:30:47 <Excedrin> > (printf "%s %d %s" "foo" 35 "bar") :: String
11:30:48 <lambdabot>  "foo 35 bar"
11:31:06 <allbery_b> newbs aren't damned, they're just not saved yet :)
11:31:20 <dcoutts> @seen troy
11:31:20 <lambdabot> I saw troy leaving #haskell 13h 46m 15s ago, and .
11:31:57 * drakferion smiles *
11:32:22 <drakferion> Sorry that i destroyed that higher-level convo. I'll idle about a bit and then go. :)
11:32:53 <Cale> drakferion: I think it was mostly over anyway :)
11:33:10 <Cale> drakferion: Feel free to stick around and ask questions
11:33:40 <drakferion> Surely, Cale. Thanks again.
11:38:21 <drakferion> Oh, let me bug you some more. :) I know how to program, just not haskell - yet. Learning it. So don't worry too much about being simple to understand, i'll ask for more thorough explanations if i need. :)
11:38:22 <drakferion> What does the dot do? Like in "readFile "file.txt" >>= print . lexer" ?
11:38:41 <Cale> that's function composition
11:38:46 <Cale> like in mathematics
11:38:48 <drakferion> I tried to hoogle it, didn't manage to understand.
11:38:57 <Cale> (f . g) x = f (g x)
11:38:57 <drakferion> f(g(x)) ?
11:39:11 <drakferion> So, print.lexer is the same as print(lexer) ?
11:39:15 <Cale> not quite
11:39:30 <Cale> but (print . lexer) when applied to a value x, will be print (lexer x)
11:39:50 <Cale> So it's the same as \x -> print (lexer x)
11:40:13 <Cale> Basically, in this case, it'll apply the lexer to the contents of the file, and then print the result.
11:40:28 <Cale> That code is clearer if you use the flipped version of >>=
11:40:39 <Cale> print . lexer =<< readFile "file.txt"
11:41:37 <drakferion> Hrm... i prefer >>=. Because i see it as "execute a and pass the output to b". Makes more sense in my little head. :)
11:42:15 <Cale> Yeah, it's just that in this case the data flows first to the left and then to the right. :)
11:42:41 <Cale> another way to write that code would be
11:42:52 <drakferion> with () ?
11:43:01 <Cale> do { x <- readFile "file.txt"; print (lexer x) }
11:43:09 <drakferion> Ah.
11:43:27 <drakferion> Those "do" are useful, but they seem like the c-coder's escape. =P
11:43:28 <Cale> It just avoids the intermediate variable.
11:43:37 <Cale> Well, sort of :)
11:43:46 <Cale> C coders might have a few issues :)
11:43:59 <Cale> for example, return x in the middle of a do-block is a no-op. :)
11:44:11 <emu> competing for happiest guy in #haskell stats?
11:44:21 <Cale> emu: hhe
11:44:21 <drakferion> ^^
11:44:25 <Cale> hehe*
11:45:10 <kpreid> the world where "let" isn't a do generator: do x <- [1..10]; y <- return $ x + 1; return (x,y)
11:46:30 <Cale> There is a subtle difference between let and return used like that with regard to types.
11:46:35 <Cale> But yeah :)
11:47:32 <emu> > do f <- return $ 1 : 1 : zipWith (+) f (tail f); return (take 10 f)
11:47:33 <lambdabot>   Not in scope: `f'
11:48:26 <kpreid> > mdo f <- return $ 1 : 1 : zipWith (+) f (tail f); return (take 10 f)
11:48:27 <lambdabot>  Parse error
11:48:32 <kpreid> aw
11:49:36 <Cale> do {let {mymap f = foldr ((:) . f) []}; print (mymap toUpper "Hello"); print (mymap (*2) [1..5]) }
11:49:39 <Cale> will typecheck
11:49:46 <Cale> do {mymap <- return (\f -> foldr ((:) . f) []); print (mymap toUpper "Hello"); print (mymap (*2) [1..5]) }
11:49:49 <Cale> won't typecheck
11:50:26 <Cale> The reason is that <- is actually a lambda binding, and so has to be monomorphic.
11:50:42 <Cale> But that's pretty subtle :)
11:52:46 <ndm> @seen sorear
11:52:47 <lambdabot> sorear is in #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 12m 57s ago.
11:52:50 <pejo> What is the advantage with the monomorphism restriction?
11:53:12 <ndm> pejo, performance more inline with what you expected
11:53:36 <ndm> foo = value, if value is not monomorphic then foo will be recomputed once per use
11:53:50 <sorear> hello ndm
11:53:54 <ndm> hi sorear
11:54:13 <ndm> sorear, AlexS was asking if you can write a deriveAll makeEq, which does derive on every data type in a file
11:54:30 <ndm> is that possible with TH? kind of like --derive=Eq, but in the TH layer
11:55:08 <ndm> if it is, we might be better off using that in the Derive script - could simplify some little  bits and have less parsing of Haskell
11:55:31 <sorear> ok...
11:55:39 <sorear> but what of {-! Eq !-} ?
11:56:04 <ndm> we'd still need to parse that, but its slightly less parsing
11:56:19 <ndm> probably not a great saving in parsing, but it is slightly neater
11:58:08 <Saizan> ?docs
11:58:09 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
11:59:08 <sorear> ndm: I suspect it can't be done.  GHC runs splices very early in the process, and needs to do funny dependancy stuff.  (But I'm looking at the Q docs now)
12:00:14 <sorear> ndm: I suppose it would be feasable to use currentModule, readFile, and haskell-src - but ick!
12:00:34 <ndm> sorear, that is indeed a bit ick...
12:01:19 <ndm> you could always do deriveTransitive, which follows data names used in the data type within the current module
12:01:34 <ndm> since usually there will be some all-inclusive data definition
12:02:39 <Saizan> if you can check "within the current module" you can implement deriveAll, i'd think
12:02:54 <sorear> Saizan: you can
12:06:57 <haskellnew> when we use "check" or "retry" it starts the transaction again , my question does it uses tight loops or  it will block until some tvar changes
12:07:51 <sorear> it blocks
12:08:03 <sorear> not only until some tvar changes
12:08:20 <sorear> it tracks the exact set of tvars you read, and only waits on those
12:09:10 <haskellnew> so it does not eat cpu time , thats cool , thanks
12:09:25 <pitecus> how do i create a profiling version of a package?
12:09:57 <emu> configure -p
12:10:18 <emu> and for exes --enable-executable-profiling
12:11:14 <pitecus> if i configure it like that and install will it overwrite the regular version?
12:18:18 <jfredett> hmm...
12:18:23 <jfredett> good morning people.
12:21:20 <norgul> morning.
12:22:40 <Heffalump> evening.
12:25:26 <pitecus> i dont understand the output of the profiler. I get smth like:  CAF   Main     330          50  98.0   97.9    98.0   97.9
12:25:40 <pitecus> there are ohter lines, with mostly zeros
12:25:48 <pitecus> whats that supposed to mean???
12:26:07 <EvilTerran> is there no header line?
12:26:17 <Igloo> It probably means you didn't compile with -caf-all
12:26:29 <pitecus> Igloo, what is that for?
12:26:40 <Cale> Most of the time is being spent computing constants.
12:26:50 <Igloo> Sorry, I mean -auto-all
12:27:15 <pitecus> still what does --auto-all do?
12:27:25 <Igloo> And it adds cost centres for all top-level functions
12:27:42 <Cale> --auto-all and --caf-all automatically add lots of cost centres
12:27:56 <pitecus> configure doesnt recognize this option
12:28:04 <Cale> The profiler report will typically be boring without them unless you add those.
12:28:08 <Cale> They're options to GHC
12:28:09 <pitecus> is it an otpion for build?
12:28:30 <Cale> er, sorry for the redundancy there :)
12:28:31 <Igloo> What do you mean by build?
12:28:35 <pitecus> so i should put it in ghc-options in the cabal file?
12:28:57 <Igloo> ghc-prof-options (if I remember the name correctly), yes
12:28:58 <pitecus> Igloo, runghc Setpu build
12:29:44 <stick_figure> What is the best way to do an append_map?  ie do a map or list comprehension where all of the elements of the list are lists that should be concatenated?
12:29:54 <Igloo> Hmm, Cabal probably ought to add that by default for executables
12:29:59 <Cale> stick_figure: concatMap?
12:30:14 <stick_figure> Cale, sounds good
12:30:24 <Cale> also, >>= in the list monad is the same thing
12:30:32 <Cale> or just use a list comprehension :)
12:30:52 <Cale> > concatMap (\x -> [x, x+10]) [1..5]
12:30:54 <lambdabot>  [1,11,2,12,3,13,4,14,5,15]
12:31:04 <Cale> > [1..5] >>= \x -> [x,x+10]
12:31:05 <lambdabot>  [1,11,2,12,3,13,4,14,5,15]
12:31:32 <Cale> > [y | x <- [1..5], y <- [x,x+10]]
12:31:34 <lambdabot>  [1,11,2,12,3,13,4,14,5,15]
12:31:36 <pitecus> -auto-all doesnt seem to have made any difference...
12:31:46 <Cale> !paste
12:31:46 <hpaste> Haskell paste bin: http://hpaste.org/
12:31:56 <stick_figure> Cale, and this is more efficient than doing a normal map and then using ++?
12:31:56 <Cale> pitecus: can you paste the .prof there?
12:32:02 <Igloo> Did it actually recompile it? You can use -v to be sure it is actually passing the flag
12:32:15 <pitecus> ok, let me make sure
12:32:16 <Cale> stick_figure: generally
12:32:23 <stick_figure> thanks :)
12:32:39 <Cale> stick_figure: Unless the compiler is really smart, which I don't think has quite happened yet.
12:33:16 <Cale> (though it will probably be soon, I think the plan is to use the same stream fusion stuff for lists as was used in Data.ByteString)
12:35:42 <pitecus> ok i had to delete the dist directory to make it properly recompile
12:47:01 <stick_figure> Is there a way to do something similar to concatMap in a list comprehension setting?  I'm making 16 lists of 4 tuples of (i,j,k) where in each list, k goes from 0 to 3 and i and j hold constant.
12:48:20 <Cale> List comprehensions are concatMaps in disguise.
12:48:40 <EvilTerran> > [x | y <- [1..3], x <- [1..y]]
12:48:41 <lambdabot>  [1,1,2,1,2,3]
12:48:45 <Cale> They in fact desugar into chains of applications of concatMap
12:48:57 <EvilTerran> > concatMap (\y -> [1..y]) [1..3]
12:48:59 <lambdabot>  [1,1,2,1,2,3]
12:49:09 <pitecus> Is it possible to find out somehow which function is causing stack overflow?
12:49:51 <Cale> pitecus: You can usually narrow it down fairly well from a profiling report.
12:50:35 <pitecus> Cale, what would be indicative?
12:51:15 <Cale> Well, usually stack overflows happen all with the same function, so I suspect that you could look at the 'entries' column
12:51:30 <EvilTerran> is it not possible to get a stack trace in the case of an overflow?
12:51:31 <Cale> It's quite common for stack overflows to be caused by tail recursion building up a large expression which, when forced, puts too many things on the stack.
12:51:43 <Cale> You can get a call-centre trace
12:51:53 <fasta> The standard stack size is also pretty small.
12:51:53 <Cale> with the -xc runtime system option
12:52:22 <MyCatVerbs> Cale: er, shouldn't tail-recursion optimization stop that from happening, though?
12:52:45 <Cale> MyCatVerbs: Tail recursion optimisation just helps it build the expression faster.
12:53:09 <Cale> You get a tight loop which builds up something that's left unevaluated
12:53:26 <Cale> Then when you evaluate that thing, it blows up the stack.
12:53:32 <pitecus> Cale the most entries I get are 13
12:53:46 <Cale> pitecus: can I look at your program?
12:54:00 <pitecus> Cale, Its rather big
12:54:06 <Cale> hmm
12:54:34 <MyCatVerbs> Cale: ...eh? That isn't even remotely how what-I-thought-TCO-was works. One of us is unclear on the concept here.
12:54:35 <Cale> Try running your program with +RTS -xc -RTS
12:54:52 <Cale> MyCatVerbs: Well, remember that evaluation is lazy.
12:54:59 <Cale> Let's do an example
12:55:17 <pitecus> Cale is the "entries" column how many times a function was called?
12:55:18 <Cale> foldl f z [] = z
12:55:42 <Cale> foldl f z (x:xs) = foldl f (f z x) xs
12:55:48 <Cale> That's tail recursive
12:56:11 <Cale> So, let's see what happens with foldl (+) 0 [1,2,3]
12:56:15 <pitecus> Thats what I get with -xc : <GramLab.Maxent.TempDir.withTempFilePath,GramLab.Maxent.ZhangLe.IntModel.fromByteString,GramLab.Maxent.ZhangLe.Model.fromByteString,Main.predict,GramLab.Commands.runCommand,GramLab.Commands.defaultMain,Main.main><GramLab.Maxent.ZhangLe.Model.fromByteString,Main.predict,GramLab.Commands.runCommand,GramLab.Commands.defaultMain,Main.main>Stack space overflow: current size 8388608 bytes.
12:56:18 <EvilTerran> pitecus, yes. the number of times the function is "entered"
12:56:52 <MyCatVerbs> Cale: yuhuh. And TCO allows the compiler to optimize that down to a while loop in strict languages.
12:56:53 <Cale> foldl (+) 0 [1,2,3]
12:57:04 <Cale> = foldl (+) (0 + 1) [2,3]
12:57:11 <Cale> = foldl (+) ((0 + 1) + 2) [3]
12:57:17 <Cale> = foldl (+) (((0 + 1) + 2) + 3) []
12:57:23 <Cale> = ((0 + 1) + 2) + 3
12:57:37 <Cale> Now, up to that point, that was accomplished with a simple loop.
12:57:40 <MyCatVerbs> ?
12:57:43 <Cale> But you're left with an expression
12:57:50 <Cale> ((0 + 1) + 2) + 3
12:57:54 <MyCatVerbs> Cale: and it doesn't evaluate (f z y) immediately?
12:57:56 <Cale> which still needs evaluating
12:57:58 <Cale> no
12:58:04 <Cale> Lazy evaluation is outermost first
12:58:38 <Cale> So in this case, there's a function called foldl' which fixes that.
12:58:49 <MyCatVerbs> Bloody Hell. That is scary inefficient. Surely the semantics of foldl are such that there would *never* be any point in not using $! to evaluate (f z y) eagerly?
12:58:52 <Cale> By forcing the evaluation of the z parameter as it goes along
12:59:13 <Cale> Well, sometimes you want to lazily evaluate the resulting expression.
12:59:23 <MyCatVerbs> Oh wait, list concatenation. Damn.
12:59:32 <Cale> No, that's foldr
12:59:39 <Cale> foldr is usually what you want
12:59:49 <Cale> because it returns quickly
13:00:09 <MyCatVerbs> Cale: foldl (++) returns the same result as foldr (++). When it *does* return, I mean.
13:00:15 <Cale> yeah
13:00:26 <Cale> but foldr (++) [] will work on infinite lists
13:00:30 <Cale> and foldl (++) [] won't
13:00:36 <mux> well, if you use foldl and have a function consuming the list one item at the time, startig with the leftmost element, then the list construction can be completely optimized out
13:00:47 <edwardk> foldr has the advantage that you can get to the first constuctor "faster", which makes it more efficient in a lazy setting.
13:00:51 <mux> foldl can be nice performance wise in this case
13:01:03 <Cale> mux: rightmost?
13:01:15 <stick_figure> that's so odd considering that foldl is better in most imperative settings.
13:01:21 <MyCatVerbs> edwardk: so...
13:01:31 <mux> Cale: ?
13:01:35 <Cale> stick_figure: it's exactly opposite, because the order of evaluation is exactly opposite
13:01:41 <stick_figure> yup
13:01:51 <MyCatVerbs> edwardk: we need to build a CPU that uses thunks as its function calling primitive, so that lazy evaluation will have zero overhead? =D
13:02:10 <Cale> mux: foldl starts with the end of the list :)
13:02:21 <mux> oh yeah, right, brain-o
13:02:33 <Cale> foldl f z = foldr (flip f) z . reverse
13:02:53 <MyCatVerbs> edwardk: ...actually, would that be all? I can't think of much else that'd be neccessary. 
13:03:14 <Cale> I'd like a hardware STG machine :)
13:03:17 <edwardk> mycatverbs: thats quite a big jump =)
13:03:50 <MyCatVerbs> edwardk: nahhh, s'nothing compared to a LispM.
13:03:51 <pitecus> Something i dont get: I have 13 entries in .prof for a function which is only called once...
13:04:42 <ddarius> Yay!
13:05:32 <MyCatVerbs> edwardk: I mean, you could almost do it with maybe two or three new opcodes. Create thunk and push onto stack, evaluate thunk and push onto stack. 'Bout all.
13:05:32 <ddarius> Now to install programs I actually want to use.
13:05:48 <ddarius> @where xmonad
13:05:48 <lambdabot> http://www.xmonad.org/
13:06:29 <sorear> @users #xmonad
13:06:30 <lambdabot> Maximum users seen in #xmonad: 39, currently: 34 (87.2%), active: 17 (50.0%)
13:06:39 <MyCatVerbs> edwardk: ...hrmn. Considerin' that a thunk is more-or-less freely interchangable with a continuation, would that mean it'd be possible to make a machine that could trivially be switched between working as a LISP machine and a Haskell machine? =D
13:06:43 <edwardk> mycatverbs: remember, memothunks, so it has to update itself
13:07:51 <pitecus> I suspect I ll have to spend a day or two before i can locate that stack overflow....
13:08:46 <MyCatVerbs> edwardk: memo thunk?
13:09:50 <edwardk> mycat: thunks in haskell overwrite themselves with their answers, its call-by-need not call-by-name
13:09:51 <MyCatVerbs> edwardk: google says strange things about methods of performing lazy evaluation in Scheme and Python, with memoization.
13:10:06 <Cale> pitecus: Look for places where you're either using an accumulator variable, or updating a lazy data structure repeatedly (like a non-strict array)
13:10:12 <Philippa> edwardk: that's still not too big a deal though
13:10:24 <Philippa> in that you can just swap the thunk type
13:10:25 <Cale> pitecus: those are the most likely candidates
13:10:51 <edwardk> Philippa: sure, it just complicates the machine.
13:10:53 <MyCatVerbs> edwardk: an implementation detail, surely. You could solve with a tag bit.
13:11:27 <Cale> pitecus: apparently GramLab.Maxent.TempDir.withTempFilePath is forcing the evaluation of something which is extremely complicated
13:11:39 <Cale> (which seems kind of ridiculous given its name)
13:11:40 <pitecus> Cale, I can see that, but in a largish project like this one it's bound to take a lot of time. I wish there was some way of finding it easier
13:11:57 <Cale> Well, you have that call centre trace.
13:12:05 <Cale> cost centre*
13:12:41 <pitecus> OK thanks for advice, Cale
13:12:46 <pitecus> gotta go now
13:13:48 <MyCatVerbs> edwardk: tag bits as either evaluated answers or unevaluated thunks. Make reading the value from a pointer to an expression cause evaluation. If it's not been evaluated yet, the CPU does so then returns to the caller with the result in the register you asked for it to be shoved into. If it has already been evaluated, shove the result into the CPU register you LW'd into.
13:13:56 <Philippa> MyCatVerbs: yeah, and you need the tag for blackholing thunks anyway
13:14:17 <Philippa> though eg STG doesn't tag evaluation - it just swaps the code pointer to a trivial return operation
13:14:25 <Philippa> (which I imagine tends to end up in cache pretty quick)
13:18:44 <norpan> http://coldestwinter.blogspot.com/
13:18:45 <lambdabot> Title: The coldest winter I ever spent...
13:18:49 <norpan> hoppsan
13:23:18 <MyCatVerbs> Philippa: blackholing?
13:24:13 <MyCatVerbs> Philippa: (somehow I get the impression that there are at least a thousand different ways of building an efficient Hmachine and at least nine hundred and ninety of them are completely insane. The rest merely won't work.)
13:26:04 <edwardk> mycatverbs: while you are executing a thunk, you replace its code pointer with a 'black hole' which will error out if the thunk tries to evaluate again before you fill in its answer, that way you can detect infinite loops and close certain garbage collection cycles.
13:26:25 <Cale> hehe, I was just about to type what edwardk did :)
13:26:38 <edwardk> =)
13:26:59 <edwardk> i should say detect certain forms of infinite loops. but you get the idea
13:27:18 <MyCatVerbs> edwardk: screw detecting infinite loops. These are Turing machines, people should be given more enough rope to hang themselves.
13:27:36 <edwardk> mycatverbs: it helps with certain garbage collection cases as well, so its not quite as optional as you think ;)
13:27:38 <MyCatVerbs> edwardk: and then some. And then we should give them even more rope, followed by a book on knot-tying.
13:27:56 <Cale> MyCatVerbs: well, it's just those infinite loops where you need to evaluate x in order to determine the top level constructor in x
13:28:22 <dolio> > let x = x in x + 1 -- detected
13:28:23 <lambdabot>  Exception: <<loop>>
13:28:36 <dolio> > let x = 1 : x in sum x -- not detected
13:28:42 <lambdabot> Terminated
13:29:09 <stick_figure> How do I create a new Data.Map?
13:29:14 <Cale> > let x = x + 1 in x
13:29:15 <lambdabot>  Exception: <<loop>>
13:29:24 <Cale> stick_figure: Well, you mean an empty one?
13:29:33 <stick_figure> Cale, yeah
13:29:34 <edwardk> @type unit
13:29:35 <MyCatVerbs> Cale: cooool. I still think it'd be more fun to add another dozen methods of causing the CPU to hang, just for fun.
13:29:36 <lambdabot> Not in scope: `unit'
13:29:45 <Cale> stick_figure: Usually you build them starting from a list of association pairs
13:29:45 <eumenides> @type Data.Map.empty
13:29:47 <lambdabot> forall k a. Data.Map.Map k a
13:29:58 <eumenides> @type Data.Map.fromList
13:30:00 <lambdabot> forall k a. (Ord k) => [(k, a)] -> Data.Map.Map k a
13:30:01 <EvilTerran> @docs Data.Map
13:30:01 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
13:30:17 <stick_figure> Cale, but the user is going to be inputing values which will be added as the program continues
13:30:19 <MyCatVerbs> On second though, fine. Leave the sensible features in. But add a Halt and Catch Fire instruction or ten on purpose.
13:30:21 <Cale> stick_figure: empty :: Map k a
13:31:04 <Cale> stick_figure: Of course you don't really "add" values to a map, you create a new map which has additional values.
13:31:16 <stick_figure> right
13:31:23 <Cale> It just happens that because of clever sharing, you can do that in log time :)
13:31:24 <stick_figure> thanks, got it
13:46:55 <spacemarine__> hello
13:47:15 <psi> good evening
13:47:20 <spacemarine__> I have to make a little haskell program for my university, and I'm having some trouble in it, could some of you guys give me a hand?
13:47:34 <kaol> @paste
13:47:35 <lambdabot> Haskell pastebin: http://hpaste.org/new
13:49:17 <hpaste>  spacemarine pasted "(no title)" at http://hpaste.org/139
13:49:23 <spacemarine__> ok...pasted
13:49:50 <spacemarine__> I know it's such an easy program...but I'm having a hell of a trouble
13:51:06 <spacemarine__> (I've putted what the program has to do on the paste bin)
13:51:31 <byorgey> spacemarine__: what exactly are you having trouble with?
13:51:42 <spacemarine__> byorgey
13:51:45 <spacemarine__> is like this
13:51:51 <spacemarine__> I can give this answer
13:51:58 <spacemarine__> (for 5 for instance)
13:52:09 <spacemarine__> [[4,1],[3,2],[],[],[]]
13:52:34 <spacemarine__> you see? I can't get the [3,1,1],[2,1,1,1]...
13:52:45 <spacemarine__> only for 2 numbers
13:52:59 <spacemarine__> why I can't get the sum of more than 2 numbers?
13:53:01 <spacemarine__> this is my problem
13:53:08 <jedai> Anyway wouldn't you want [2,2,1] too ?
13:53:18 <spacemarine__> yes
13:53:21 <spacemarine__> this is the issue
13:53:33 <jedai> It's not in your example
13:53:47 <spacemarine__> yeah...sorry
13:53:53 <spacemarine__> forgot about...
13:54:08 <spacemarine__> :$
13:55:03 <dmwit> > let sums 0 = [[]]; sums n = map (\x -> map (x:) (sums (n - x))) [n,n-1..1]
13:55:03 <lambdabot>  Parse error
13:55:10 <dmwit> > let sums 0 = [[]]; sums n = map (\x -> map (x:) (sums (n - x))) [n,n-1..1] in sums 3
13:55:11 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
13:55:11 <lambdabot>       Expected...
13:56:18 <dolio> You might want to consider a function g such that (g n m) is a list of lists that sum to n using numbers less than or equal to m.
13:56:24 <dmwit> > let sums 0 = [[]]; sums n = concatMap (\x -> map (x:) (sums (n - x))) [n,n-1..1] in sums 3
13:56:26 <lambdabot>  [[3],[2,1],[1,2],[1,1,1]]
13:56:28 <dolio> Then your solution is (g n n).
13:56:45 <dolio> And g shouldn't be too hard to define inductively.
13:57:07 <spacemarine__>  Jesus....
13:57:07 <dmwit> dolio: Yeah, that's a good idea.
13:57:13 <spacemarine__> I just can't understand haskell
13:57:15 <spacemarine__> :(
13:57:35 <dolio> For instance, g n 1 = replicate n g
13:57:45 <dolio> Er, replicate n 1.
13:57:46 <psi> don't expect to understand it right away
13:57:57 <spacemarine__> yeah....
13:58:28 <spacemarine__> I was thinking of what I've made
13:58:44 <spacemarine__> one of the things, it gives me right...
13:59:06 <spacemarine__> the answers can't be swapped....for instance...if I already have [3,2], I can't have [2,3]
13:59:23 <dmwit> spacemarine__: Check dolio's suggestion, it prevents that.
13:59:39 <spacemarine__> and this, I think this stupid 6 lines of code already make right?
13:59:53 <ndm> i keep getting a template haskell error...
13:59:54 <ndm> Template Haskell error: Can't do `reify' in the IO monad
14:00:04 <ndm> so how can you do reify?
14:00:17 <Cale> spacemarine__: enumerating partitions of n?
14:00:21 <ndm> runQ $ reify "name" doesn't work well at all
14:00:37 <ndm> eventually i'll want to do the entire thing in Q, but i will want to debug things before that...
14:00:38 <spacemarine__> ?
14:01:05 <Heffalump> doesn't Q let you do IO?
14:01:19 <ndm> it does, runIO
14:01:25 <Cale> spacemarine__: like partitions 5 = [[5],[4,1],[3,2],[3,1,1],[2,2,1],[2,1,1,1],[1,1,1,1,1]]
14:01:27 <Heffalump> I don't quite follow your problem then.
14:01:34 <ndm> but at GHCi, i want to do ghci> test
14:01:34 <byorgey> spacemarine__: your function 'checa' only tries to find a single number which will complete the sum.
14:01:43 <spacemarine__> Cale, yes...this is the answer
14:01:44 <ndm> where test is of type Q String, say
14:01:47 <Cale> spacemarine__: ah, yes, looking at your example, righ
14:01:47 <Cale> t
14:01:53 <ndm> but there is no show instance for Q
14:01:54 <spacemarine__> byorgey, is...I know...I just don't know how to fix it
14:01:58 <Heffalump> ah, right.
14:02:04 <byorgey> spacemarine__: instead, try calling 'exec' recursively to get all the partitions of what's left over
14:02:05 <Heffalump> And there's unlikely to be given that it embeds IO..
14:02:06 <ndm> and as soon as I do runIO test, so i can see it, i get the reify error
14:02:08 <Cale> spacemarine__: first write the program which produces the partitions of n with largest part at most k
14:02:14 <byorgey> spacemarine__: and then combine them appropriately
14:02:20 <Cale> spacemarine__: then call it with the right parameters to get your program
14:02:26 <ndm> exactly, i don't expect a show for Q, but i do want to lift Q into IO
14:02:41 <ndm> which i can do, but then the reify call starts failing, which is the unexpected bit
14:02:41 <Heffalump> but Q is a more featureful monad than IO
14:02:48 <Heffalump> it has access to GHC guts that IO doesn't know the name of
14:02:53 <spacemarine__> ok....one at a time please...I'm already brained washed for this
14:02:57 <Heffalump> (like StateT Foo IO is more featureful than IO)
14:03:01 <byorgey> spacemarine__: but really you should try following dolio and Cale's suggestion
14:03:05 <spacemarine__> so...I should use exec to do what?
14:03:08 <ndm> so is there any way to debug something whose result type is Q?
14:03:14 <Philippa> ndm: call liftIO $ print blah from within the Q monad
14:03:30 <spacemarine__> Cale, how do I write the program to produce the partitions?
14:03:42 <ndm> Philippa, then how do i debug it? I've tried calling error from within Q, but then GHCi complains there is no show for Q
14:03:47 <spacemarine__> I mean, what does the program should do?
14:03:56 <Philippa> you debug it the old-fashioned printf way
14:03:56 <Heffalump> why is it trying to show Q?
14:03:57 <ndm> I've tried adding Show Q,  but it doesn't force enough of Q to raise the error
14:04:01 <Philippa> prints /everywhere/
14:04:04 <ndm> Heffalump, GHCi
14:04:09 <byorgey> spacemarine__: 'exec' probably isn't a good name for your function, either... you will probably just end up getting confused yourself about what it is supposed to do!
14:04:13 <Cale> spacemarine__: well, let's write a program partitions' n k which produces the partitions of n whose largest part is at most k
14:04:14 <Philippa> you don't know the evaluation order, which is a bit tricky...
14:04:16 <ndm> Philippa, all i want is printf debugging, but its not something i've got
14:04:24 <Heffalump> I can't see how you would run TH splices inside GHCi at all.
14:04:32 <byorgey> spacemarine__: good names help a lot because they help you think about what your functions do
14:04:32 <Heffalump> without it providing some explicit support to let you
14:04:41 <Heffalump> (which presumably doesn't exist)
14:04:45 <ndm> [d| data Foo = Foo |] works fine
14:04:57 <ndm> and i can typecheck the example
14:04:57 <Igloo> ndm: You need to be in the typechecking Monad to do reification
14:05:11 <ndm> Igloo, oh, is that Q or something else?
14:05:22 <Igloo> That's TcM
14:05:23 <spacemarine__> Cale, ok...let's do this....
14:05:25 <Cale> If k > n, then we'll just reset it to start off so that k == n
14:05:39 <Cale> partitions' n k | k > n = partitions' n n
14:05:48 <ndm> Igloo, never heard of that? are you refering to GHC API stuff? i'm on 6.6 template haskell
14:05:50 <spacemarine__> Cale, n would be an integer right? and k a list?
14:06:00 <Heffalump> I get no instance for Show (Q ..) when I try to evaluate [d| ... |]
14:06:00 <Cale> no, k is an integer too
14:06:07 <Igloo> Q is a monad transformer nowadays
14:06:13 <spacemarine__> Cale, ok...you got me confused now
14:06:15 <Cale> spacemarine__: we're going to produce a list
14:06:22 <Cale> not take one as a parameter
14:06:28 <spacemarine__> ok...
14:06:32 <spacemarine__> and what's the n for?
14:06:35 <Igloo> You need to be running the TH as part of the compilation process, so it is wrapping TcM, for reification to work
14:06:40 <Cale> n is the sum of each partition
14:06:51 <Philippa> ndm: you've got printf debugging, you've just got a damn weird evaluation order
14:06:53 <Cale> k is a bound on the largest element of each partition
14:07:07 <spacemarine__> a..yes...so...a call like: partition 5 5  would get my example?
14:07:09 <ndm> Heffalump, runQ [d| ... |] works fine, since you can lift [| into IO
14:07:10 <sorear> ndm: Just splice it!
14:07:16 <Cale> spacemarine__: right, exactly
14:07:20 <sorear> ndm: $( thing_to_test )
14:07:23 <msingh> Cale, what problem is this - generating partitions?
14:07:24 <ndm> Philippa, no, i don't, i can't prod any of Q, so i can't evaluate any of it...
14:07:31 <byorgey> spacemarine__: so for example, partitions' 5 2 should be [[2,2,1],[2,1,1,1],[1,1,1,1,1]]
14:07:44 <spacemarine__> ahan...I c
14:07:50 <byorgey> all the partitions of 5 that only use numbers up to 2
14:07:50 <sorear> ndm: you can run full Q inside splices, because it's full TcM
14:08:02 <spacemarine__> yeah...it would solve my problem...part of it...but how to make this program?
14:08:22 <sorear> ndm: runQ :: Q a -> IO a  should probably never be used
14:08:25 <Philippa> ndm: okay, I may've missed any code fragment you pasted, could I see some code?
14:08:40 <Philippa> sorear: I can see a use for it
14:08:46 <sorear> Philippa: ?
14:08:50 <ndm> sorear, i think that should work, thanks :)
14:08:52 <Philippa> in fact, I can see many. Not all TH generates code
14:09:03 <Cale> Well, this program is easier to write because a partition of n into parts of size at most k is just a number j from 1 up to k, followed by a partition of (n-j) into parts of size at most j
14:09:29 <spacemarine__> hehe...u lost me
14:09:36 <spacemarine__> (again)...sigh
14:09:56 <Cale> Well, a partition of 5 into parts at most 3, it could start with 3, or 2, or 1
14:10:07 <spacemarine__> ok...so far soo good
14:10:14 <sorear> Philippa: All TH either reifies (runQ is useles) or doesn't reify (doesn't need Q and shouldn't be in it)
14:10:23 <sorear> Philippa: where can you see a use for runQ?
14:10:32 <Cale> If it starts with 2, then the rest of it is a partition of 3 into parts of of size at most 2
14:10:42 <Cale> Does that make sense?
14:10:47 <spacemarine__> yes...it makes
14:10:52 <Philippa> not reifying doesn't mean there wasn't a pile of AST generated, and doing so is still done in the Q monad
14:10:59 <spacemarine__> let's start shall we?
14:11:01 <Cale> okay
14:11:16 <sorear> Philippa: No.  Piles of AST are pure.
14:11:18 <spacemarine__> so...for the first line of program, I need to have a base case right?
14:11:24 <Cale> yeah
14:11:30 <spacemarine__> in this case
14:11:37 <Cale> There will be a few cases you want to take care of right away actually.
14:11:41 <Philippa> sorear: not necessarily, and if nothing else the sugar rapidly shifts stuff into Q even if you could've kept it in IO
14:11:50 <spacemarine__> ok....which would be?
14:12:09 <nomeata> Hi. Woudnt groupBy be more useful if itd always compare adjacent values, insead always use the first value?
14:12:25 <Cale> Well, one would be the list of partitions of 0 (into parts of any size)
14:12:25 <spacemarine__> since the n is the sum size, and k is the max sum number
14:12:32 <spacemarine__> ok
14:12:39 <nomeata> > groupBy (\a b -> b - a < 5) [1,2,10,14,15,16,17,20]
14:12:47 <lambdabot>  [[1,2],[10,14],[15,16,17],[20]]
14:12:48 <Cale> It's a little tricky, but we want there to be just one of those, in particular, the empty list.
14:12:50 <spacemarine__> so the first case should be something like: partition n 0 = [] ?
14:13:03 <nomeata> Id rather expect [[1,2],[10,14,15,16,17,20]]
14:13:09 <Cale> nomeata: as it is, it's useful for un-flattening tree structures
14:13:23 <Cale> spacemarine__: oh, that too
14:13:29 <nomeata> The result would be the same for transitive params to groupBy, such as ==.
14:13:29 <Philippa> oh, plus the other use of Q a -> IO a is if it reifies internally but doesn't yield any externally-visible new code
14:13:42 <spacemarine__> and partition 0 n = [] ?
14:13:48 <Cale> spacemarine__: partitions' 0 n = [[]]
14:13:52 <Cale> that's the first line
14:13:54 <nomeata> Cale: And my variant wouldnt provide that?
14:14:12 <spacemarine__> ok
14:14:14 <Cale> nomeata: I'll show you what I mean in a minute :)
14:14:16 <ndm> ok, i've got it so it at least gives something now
14:14:26 <ndm> $( ), then throwing up errors inside that
14:14:26 <spacemarine__> the second shouldn't be partition n 0 = [[]]?
14:14:43 <ndm> which doesn't give can't use reify error messages, but does throw up problems elsewhere
14:14:54 <Cale> partition n 0 = []
14:14:54 <ndm> `Data.Derive.PlateDirect.Foo' is not in scope at a reify
14:15:07 <Cale> Unless n is 0, there are no partitions of n into parts at most 0
14:15:19 <spacemarine__> ok
14:15:21 <ndm> Foo is a data name, which is declared just above
14:15:24 <ndm> data Foo = ...
14:15:28 <spacemarine__> now we need to actually build the list right?
14:15:48 <Cale> yeah, now comes the interesting case
14:15:51 <spacemarine__> which I think it would be something like:
14:15:58 <spacemarine__> partition n k |
14:16:05 <spacemarine__> and then...I have no more clues
14:16:06 <spacemarine__> hehe
14:16:38 <spacemarine__> Yeah...the case that gives me the creeps
14:16:41 <Cale> well, if k > n, then the partitions of n into parts of size at most k is the same as the partitions of n into parts at most n
14:17:07 <Cale> So take care of that first, so we don't have to worry about generating invalid partitions :)
14:17:10 <spacemarine__> can you give me some number please?
14:17:18 <spacemarine__> ok...
14:17:19 <Cale> hm?
14:17:35 <spacemarine__> so...till now this case is:
14:17:47 <spacemarine__> partition n k | (k>n) .........
14:17:50 <spacemarine__> what more?
14:17:58 <Cale> = partition n n
14:18:10 <jfredett> hmm...
14:18:19 <Cale> otherwise, we're going to have to produce the first element and recurse
14:18:25 <Cale> we'll use a list comprehension
14:19:28 <spacemarine__> ok
14:19:43 <spacemarine__> and the first element would be...what?
14:19:55 <Cale> Something taken from the list [k,k-1..1]
14:20:03 <spacemarine__> ok...so
14:20:11 <spacemarine__> |otherwise ........?
14:20:13 <spacemarine__> gsus
14:20:38 <Cale> | otherwise = [j : ... | j <- [k,k-1..1], ... ]
14:20:45 <spacemarine__> wtf?????
14:20:46 <Cale> where the ...'s are stuff we need to fill in
14:20:52 <spacemarine__> hehehhee
14:21:06 <spacemarine__> ok..what does the <- does?
14:21:15 <spacemarine__> (I'm really lame at haskell)
14:21:16 <Cale> Oh, you've never seen a list comprehension?
14:21:20 <spacemarine__> nope
14:21:20 <spacemarine__> hehe
14:21:42 <Cale> If this is for a course, it's possible we ought to avoid that, but let's finish this way.
14:21:50 <spacemarine__> ok...
14:22:08 <Cale> okay
14:22:19 <Cale> > [x^2 | x <- [1..10]]
14:22:27 <lambdabot>  [1,4,9,16,25,36,49,64,81,100]
14:22:33 <Cale> > [(x,x^2) | x <- [1..10]]
14:22:34 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
14:22:46 <Cale> > [(x,y) | x <- [1..10], y <- [1..x]]
14:22:47 <lambdabot>  [(1,1),(2,1),(2,2),(3,1),(3,2),(3,3),(4,1),(4,2),(4,3),(4,4),(5,1),(5,2),(5,...
14:22:49 <spacemarine__> Cale, what the hell?
14:23:03 <hpaste>  jfredett pasted "Help? I don't quite follow this type error" at http://hpaste.org/140
14:23:04 <Cale> Some examples so that my description will make some sense :)
14:23:08 <spacemarine__> now...THAT'S what I CALL A BOT!!!
14:23:18 <Cale> It evaluates haskell expressions.
14:23:29 <jfredett> Lambdy is pretty awesome
14:23:32 <spacemarine__> realy nice...
14:23:32 <jfredett> @botsnack
14:23:33 <lambdabot> :)
14:23:44 <spacemarine__> ok...so...back to business
14:23:49 * jfredett pets lambdabot
14:24:06 * jfredett gets back to hacking through type errors.
14:24:11 <Cale> okay, so do you understand the notation? I could give a proper description...
14:24:13 <spacemarine__> in the lest example....you tryed to make what?
14:24:22 <spacemarine__> I think I understood
14:24:33 <spacemarine__> let me see
14:24:55 <Cale> [expr | x <- somelist, y <- someotherlist] will construct the list of expr where x comes from somelist, and y comes from someotherlist in all possible ways
14:25:08 <Cale> (and presumably x and y are used in expr)
14:25:11 <spacemarine__> u got x and y...but "variables", if x was between 1 and 10, and y between 1 and 10, it would give you all the permutations?
14:25:29 <Cale> > [(x,y) | x <- [1..3], y <- [1..3]]
14:25:30 <lambdabot>  [(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
14:25:35 <Cale> Cartesian product :)
14:25:41 <spacemarine__> yeah...nice
14:25:44 <Cale> > [(x,y) | x <- [1..3], y <- [1..3], x < y]
14:25:45 <lambdabot>  [(1,2),(1,3),(2,3)]
14:25:52 <Cale> We can also put conditions on it
14:25:54 <spacemarine__> hehe..haskell IS nice...all I need is some practice
14:26:04 <spacemarine__> cool
14:26:15 <spacemarine__> so...for us
14:26:24 <spacemarine__> we still have this:
14:26:26 <spacemarine__> |otherwise = [j : ...... | j <- [k,k-1..1]
14:26:39 <spacemarine__> so
14:26:40 <Cale> [j : ... | j <- [k,k-1..1], ... ]
14:26:52 <spacemarine__> what's the last 3 dots?
14:26:54 <dmead> > liftM2 (,) [1..10] [1..10]
14:26:55 <lambdabot>  [(1,1),(1,2),(1,3),(1,4),(1,5),(1,6),(1,7),(1,8),(1,9),(1,10),(2,1),(2,2),(2...
14:26:58 <dmead> da
14:26:59 <spacemarine__> more stuff to put in?
14:27:07 <Cale> yeah, we're going to have another generator there
14:27:24 <spacemarine__> hum...
14:27:25 <Cale> Once we've picked the first element of the partition to be j, all the elements after it have to be at most j
14:27:41 <Cale> So the rest of the partition is a partition of (n-j) into parts which are at most j
14:27:45 <spacemarine__> so...j<k?????
14:27:50 <Cale> <=
14:27:56 <spacemarine__> yes
14:28:05 <Cale> We know that j <= k because j <- [k,k-1..1]
14:28:16 <Cale> and all the numbers in that list are less or equal to k :)
14:28:19 <spacemarine__> a....yes
14:28:42 <spacemarine__> so.....
14:28:52 <spacemarine__> we don't need to put the j<=k on the last 3 .?
14:29:01 <Cale> So, if we pick a partition of (n-j) into parts at most j, call that xs
14:29:08 <byorgey> jfredett: I'm looking @ your code...
14:29:08 <Cale> we want j : xs to go into our list
14:29:15 <jfredett> brilliant-
14:29:17 <spacemarine__> yes
14:29:21 <Cale> So:
14:29:29 <jfredett> i've been working on this particular type error for a while
14:29:35 <Cale> [j:xs | j <- [k,k-1..1], xs <- ...]
14:29:43 <jfredett> i actually resolved most of them-- I think I'm getting the hang of this  stuff.
14:29:45 <spacemarine__> calm down
14:29:46 <spacemarine__> so...
14:29:56 <spacemarine__> j is the head of the list, and xs is the rest right?
14:29:58 <Cale> yeah
14:30:00 <ariep> jfredett: did you solve paste 140?
14:30:05 <byorgey> jfredett: ah, I found the problem
14:30:09 <Cale> maybe should have called it js :)
14:30:18 <spacemarine__> and now, we need to generate xs <- ...
14:30:29 <byorgey> jfredett: I will annotate it
14:30:31 <spacemarine__> and put....
14:30:34 <jfredett> ariep, yep, I found a library, and now I can just completely ignore the problem
14:30:35 <spacemarine__> hum...
14:30:35 <Cale> and what did I say the rest was picked from?
14:30:44 <spacemarine__> the k list?
14:30:51 <jfredett> ariep solving problems by not solving them, :)
14:30:59 <jfredett> best way to code. :)
14:30:59 <jedai> Ok, I got it (I think
14:31:04 <jfredett> thanks for helping though
14:31:10 <ariep> jfredett: ok. I 'queried' you, but apparently it did not get through
14:31:22 <spacemarine__> Cale, the xs is from the j list
14:31:24 <jedai> spacemarine__:  Are you still in need of a solution ?
14:31:29 <spacemarine__> yeah
14:31:42 <spacemarine__> (and learning...of course)
14:31:55 <Cale> jedai: I'm leading him through a solution :)
14:31:56 <spacemarine__> the <- would do what with the xs?
14:32:11 <Cale> xs would become each element of the thing on the right of the <-
14:32:22 <spacemarine__> so...if xs was [1,2,3,4]
14:32:26 <hpaste>  byorgey annotated "Help? I don't quite follow this type error" with "(no title)" at http://hpaste.org/140#a1
14:32:26 <Cale> So whatever we put there is going to give us a list of lists
14:32:28 <jfredett> ariep, judging by the fact that I have no idea what being 'queried' entails (unless you mean you private messaged me, in which case i just didn't notice it
14:32:33 <spacemarine__> and I had xs <- [1..10]
14:32:42 <jfredett> i would assume yes- I appreciate the help though
14:32:47 <spacemarine__> the result would be....
14:32:52 <Cale> type error :)
14:32:53 <spacemarine__> ?
14:32:55 <spacemarine__> a
14:32:56 <spacemarine__> hehehehe
14:33:09 <Cale> because j : xs would be something like 5:1
14:33:13 <ariep> jfredett: yeah, probably. I do not have much irc xp
14:33:14 <Cale> and 1 isn't a list
14:33:21 <spacemarine__> hum...
14:33:28 <jfredett> lol, me neither
14:33:32 <ariep> :)
14:33:34 <spacemarine__> so what can I put in there to make it valid?
14:33:49 <MarcWeber> Do you know what hSplitByNats is supposed to do?
14:33:56 <jfredett> byorgey, yes, i mean x2,x3, x4, i actually noticed that after i pasted, and promptly smacked myself for doing that-
14:34:03 <Cale> spacemarine__: a list of lists
14:34:14 <Cale> spacemarine__: or a call to a function which is going to produce one for us
14:34:16 <byorgey> @type hSplitByNats
14:34:20 <spacemarine__> so...xs <- []
14:34:22 <Cale> namely, it'll be a call to partitions
14:34:25 <lambdabot> Not in scope: `hSplitByNats'
14:34:32 <spacemarine__> ahan....
14:34:33 <spacemarine__> lost
14:34:34 <spacemarine__> hee
14:34:39 <spacemarine__> I understood
14:34:42 <jfredett> would  : [[]] work? I had thought of that being the problem, I just didn't realize that : [] wouldn't cut it
14:34:45 <spacemarine__> but I didn't...got it?dhsua
14:34:50 <jfredett> i suppose I can just try
14:35:04 <byorgey> jfredett: uh, [] should work...?
14:35:09 <spacemarine__> I mean.. Cale, I understood what I have to do....but not how
14:35:11 <Cale> a partition of n into parts of size at most k is just a number j from 1 up to k, followed by a partition of (n-j) into parts of size at most j
14:35:14 <MarcWeber> hSplitByHNats' :: ns -> l -> (l',l'')
14:35:21 <jfredett> well, x1 : ... : [[]] works brilliantly
14:35:24 <Cale> This is the most important thing I've said so far in the conversation :)
14:35:27 <jfredett> i'll try it again w/ :[]
14:35:32 <MarcWeber> where ns is a list of numbers, l is the list to split
14:35:38 <jfredett> cool, :[] does work
14:35:45 <jfredett> it must have been something else i messed up
14:35:46 <jfredett> :)
14:35:51 <jfredett> thanks byorgey
14:35:55 <byorgey> jfredett: no problem
14:35:56 <jfredett> you rock, as usual
14:35:57 <spacemarine__> ok...
14:36:03 <spacemarine__> but how to implement it I mean
14:36:06 <jfredett> 40 quadrillion points to byorgey
14:36:13 <byorgey> woo! =)
14:36:20 <Cale> Well, how do we get the list of partitions of (n-j) into parts at most j?
14:36:37 <Cale> spacemarine__: we already have a function which does that
14:36:43 <Cale> It's the function which we're writing
14:36:53 <spacemarine__> yes....
14:37:06 <jedai> spacemarine__:  Try writing your partitions n j exactly like Cale is saying, with list comprehension
14:37:06 <jfredett> kickass, I'm 90% done with this problem now
14:37:07 <jfredett> :)
14:37:18 <Cale> partitions (n-j) j
14:37:21 <hpaste>  nomeata pasted "which is the better groupWhen?" at http://hpaste.org/141
14:37:39 <spacemarine__> Cale, this call would give me what?
14:37:42 <nomeata> Ive pasted to variants to implement the groupBy variant that Id prefer.
14:37:50 <spacemarine__> n partitions up till j?
14:37:52 <Cale> The list of partitions of n-j into parts of size at most j
14:37:58 <nomeata> Once is recursive, one uses foldr and an accumulator value. which would you recommend?
14:38:07 <spacemarine__> yea...ok
14:38:18 <emu> is there any blog software out there which does inline code fragments well? (haskell specialization would be nice)
14:38:26 <Cale> If we have one of those, then we stick j on the front of it, we'll have a new partition.
14:38:42 <spacemarine__> hum...
14:39:16 <Cale> So our list comprehension looks like [j:xs | j <- [k,k-1..1], xs <- partitions (n-j) j]
14:39:18 <spacemarine__> ok...but how does the <- thing work?
14:39:22 <spacemarine__> aaaaaaaaaaa
14:39:23 <spacemarine__> i c
14:39:30 <spacemarine__> this is the recursive
14:39:59 <spacemarine__> man
14:40:01 <spacemarine__> Cale,
14:40:04 <spacemarine__> YOU
14:40:05 <Cale> Pick a j from [k,k-1..1], then pick a partition of (n-j) into parts at most j, and you have a partition of n into parts at at most k
14:40:05 <int-e> nomeata: the one without ++
14:40:06 <spacemarine__> ARE THE MAN!
14:40:34 <ddarius> nomeata: Variant A is hideous.
14:40:40 <spacemarine__> ok
14:40:45 <spacemarine__> so let me understand this
14:40:58 <nomeata> clear votum :-)
14:41:00 <spacemarine__> the first 3 lines...no problem
14:41:12 <spacemarine__> the last line tough...
14:41:20 <spacemarine__> let's go on it...step by step ok?
14:41:34 <spacemarine__> first, it picks up a j, from a list right?
14:41:37 <Cale> yeah
14:41:39 <spacemarine__> wich is the head of the list
14:41:43 <int-e> @src groupBy
14:41:44 <lambdabot> groupBy _  []       =  []
14:41:44 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
14:41:44 <lambdabot>     where (ys,zs) = span (eq x) xs
14:41:50 <spacemarine__> then we have another guard
14:41:55 <nomeata> anyone else who thinks such a groupBy variant should be in Data.List or Data.List.Utils?
14:41:58 <spacemarine__> wich is doing like an if right?
14:42:04 <Cale> er
14:42:06 <Cale> oh
14:42:15 <nomeata> int-e: the problem with that one is that it always uses the first of a group to compare
14:42:16 * spacemarine__ is ashamed
14:42:24 <spacemarine__> ok...
14:42:29 <spacemarine__> the | is a guard right?
14:42:30 <Cale> oh, the | inside the list isn't a guard
14:42:36 <spacemarine__> aaaaaaaa
14:42:38 <spacemarine__> what is it?
14:42:42 <Cale> it's part of the syntax of list comprehensions
14:42:50 <nomeata> int-e: which is not always what you want, e.g. to split time events at larger holes
14:42:50 <spacemarine__> I c
14:42:51 <Cale> [<expr> | <generators>]
14:42:57 <spacemarine__> a...ok
14:42:59 <int-e> nomeata: yes, I saw that
14:43:05 <spacemarine__> so...the list comprehension here
14:43:20 <Cale> where <generators> is a list of things of the form  <pattern> <- <expr>, or <expr> (which is a boolean value)
14:43:38 <int-e> nomeata: yes, or to split a list into strictly increasing pieces (splitWhen (<) - if I'm reading that correctly)
14:43:58 <nomeata> int-e: yes, that should work as well
14:44:03 <spacemarine__> would pick up j (the head), combine j with k, ranging from k to 1, and recreating the xs for the next number ?
14:44:12 <Cale> For each thing of the form x <- xs, it picks x from xs in all possible ways
14:44:15 <nomeata> Maybe I should file a bug. But where? base libs or missingH?
14:44:35 <Cale> and for each boolean guard, it tests to see that it's true, and if not, it throws away that selection
14:44:53 <spacemarine__> ok...
14:44:56 <spacemarine__> so in our case
14:45:05 <Cale> > let k = 5 in [j | j <- [k,k-1..1]]
14:45:06 <spacemarine__> the j <- [k,k-1,..1]
14:45:13 <lambdabot>  [5,4,3,2,1]
14:45:16 <Cale> lambdabot is slow today
14:45:35 <spacemarine__> yeah...tought so...it putted on j, the number from 5 till 1
14:45:36 <Cale> > let k = 5 in [j:[37,42] | j <- [k,k-1..1]]
14:45:37 <spacemarine__> right?
14:45:38 <lambdabot>  [[5,37,42],[4,37,42],[3,37,42],[2,37,42],[1,37,42]]
14:45:39 <jfredett> he has a cold
14:45:51 <jfredett> @botsnack, its okay lambdy
14:45:51 <lambdabot> :)
14:46:08 <spacemarine__> it inserted on the list right?
14:46:16 <Cale> yeah, that's what : does
14:46:19 <spacemarine__> we had a list [37,41]
14:46:24 <Cale> > 1 : [37,41]
14:46:25 <lambdabot>  [1,37,41]
14:46:27 <spacemarine__> and it putted 5,4,3,2,1 at the start of it
14:46:35 <spacemarine__> hum....nice
14:46:39 <spacemarine__> ok
14:46:43 <spacemarine__> so for the next one
14:46:47 <spacemarine__> the comprehension
14:46:51 <spacemarine__> oops
14:46:54 <spacemarine__> recursive part
14:47:02 <spacemarine__> xs is a list right?
14:47:06 <Cale> yeah
14:47:10 <jedai> spacemarine__:  Yeah, that's it, j took all the value in the list at the right of <-
14:47:21 <Cale> it's each of the lists inside the list returned by what's on the right of its <-
14:47:22 <spacemarine__> and the partition (n-j) j will return me a list right?
14:47:27 <Cale> a list of lists
14:47:42 <spacemarine__> ok
14:47:47 <spacemarine__> so basicly
14:47:47 <Cale> and xs will in turn be set to each of them
14:48:07 <spacemarine__> I'm putting xs to be all the lists of the call like:
14:48:11 <ddarius> jfredett: "she"
14:48:21 <spacemarine__> j<- [5,5-1..1]
14:48:26 <spacemarine__> and then
14:48:34 <spacemarine__> j<-[4,4-1..1]
14:48:34 <Cale> xs is just some partition of (n-j) into parts of size at most j
14:48:37 <spacemarine__> and so on right?
14:48:43 <Cale> hm?
14:48:47 <Cale> xs is just some partition of (n-j) into parts of size at most j
14:48:49 <jfredett> oh, my finger must have missed the 's'
14:48:53 <Cale> It's each one of those
14:48:55 <jfredett> I'm sorry lambda
14:48:58 <Cale> in turn
14:49:12 <spacemarine__> so I create the partition
14:49:14 <spacemarine__> put on xs
14:49:17 <spacemarine__> go to the next
14:49:19 <spacemarine__> put on xs
14:49:21 <spacemarine__> and so on
14:49:30 <spacemarine__> until I have no more partition to run?
14:49:39 <Cale> and the list comprehension builds the list of all (j:xs) for each j and each xs
14:49:54 <spacemarine__> a....
14:50:04 <hpaste>  int-e annotated "which is the better groupWhen?" with "hmm, maybe have a "span" variant to go with it?" at http://hpaste.org/141#a1
14:50:06 <spacemarine__> so the list comprehension is actuall putting the limit?
14:50:21 <Cale> limit?
14:50:28 <spacemarine__> to don't go over k
14:50:38 <Cale> well, sort of
14:50:51 <Cale> j <- [k,k-1..1], so j isn't larger than k
14:50:53 <spacemarine__> so what I get
14:50:59 <spacemarine__> is a cartesian product
14:51:02 <Cale> and xs <- partition (n-j) j
14:51:03 <spacemarine__> right?
14:51:17 <Cale> so by definition xs has no part larger than j
14:51:35 <spacemarine__> because of the j <- [k,k-1..1] right?
14:51:46 <Cale> ultimately, yes
14:51:55 <hpaste>  dolio annotated "which is the better groupWhen?" with "foldl is ugly" at http://hpaste.org/141#a2
14:52:02 <spacemarine__> ahan
14:52:13 <spacemarine__> I think I'm getting it
14:52:22 <int-e> nomeata: note that the version I just pasted is also slightly lazier: it evaluates groupWhen (<) (a:_|_) to (a:_|_):_|_ instead of _|_.
14:52:35 <spacemarine__> so
14:52:39 <spacemarine__> let me see something
14:52:47 <spacemarine__> > j <- [k,k-1..]
14:52:47 <lambdabot>  Parse error
14:52:51 <spacemarine__> dan
14:53:07 <Cale> > [j | j <- [5,5-1..1]
14:53:08 <lambdabot>  Parse error
14:53:09 <Cale> > [j | j <- [5,5-1..1]]
14:53:10 <lambdabot>  [5,4,3,2,1]
14:53:19 <spacemarine__> hum..
14:53:28 <Cale> > [j | j <- [5,5-2..1]]
14:53:29 <lambdabot>  [5,3,1]
14:53:32 <spacemarine__> > [j | j <- [10,10-9..1]
14:53:32 <lambdabot>  Parse error
14:53:37 <spacemarine__> > [j | j <- [10,10-1..1]
14:53:37 <lambdabot>  Parse error
14:53:39 <Cale> ]
14:53:42 <spacemarine__> > [j | j <- [10,10-1..1]]
14:53:44 <lambdabot>  [10,9,8,7,6,5,4,3,2,1]
14:53:46 <spacemarine__> hehe
14:53:50 <spacemarine__> ok
14:53:54 <Cale> > [j | j <- [10,10-3..1]]
14:53:55 <lambdabot>  [10,7,4,1]
14:53:57 <spacemarine__> so this creates all the number from k to 1
14:54:00 <nomeata> int-e: thx. I linked it here: http://hackage.haskell.org/trac/ghc/ticket/1408
14:54:02 <lambdabot> Title: #1408 (groupWhen  a groupBy that compares consecutive values) - GHC - Trac
14:54:02 <Cale> > [j | j <- [1,4..100]]
14:54:04 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
14:54:06 <spacemarine__> hang a sec
14:54:12 <Cale> yeah
14:54:19 <dr_strangelove> > [j | j <- [10,0..1]
14:54:19 <lambdabot>  Parse error
14:54:25 <dr_strangelove> > [j | j <- [10,0..1]]
14:54:26 <lambdabot>  [10]
14:54:27 <jedai> > [j | j <- [1,4..]]
14:54:27 <Cale> [10,0..1]
14:54:29 <lambdabot>  [1,4,7,10,13,16,19,22,25,28,31,34,37,40,43,46,49,52,55,58,61,64,67,70,73,76,...
14:54:29 <Cale> > [10,0..1]
14:54:30 <lambdabot>  [10]
14:54:43 <Cale> > [10,5..1]
14:54:44 <lambdabot>  [10,5]
14:54:49 <jedai> > take 5 [j | j <- [1,4..]]
14:54:49 <Cale> > [10,6..1]
14:54:50 <spacemarine__> back
14:54:51 <lambdabot>  [10,6,2]
14:54:51 <lambdabot>  [1,4,7,10,13]
14:54:58 <beelsebob> anyone in here familiar with the Haskell XCode plugin?
14:55:05 <spacemarine__> ok
14:55:08 <int-e> dolio: but that version is not lazy at all.
14:55:10 <spacemarine__> so j creates all the numbers
14:55:13 <spacemarine__> sorry
14:55:16 <spacemarine__> has all the numbers
14:55:21 <spacemarine__> it is a list of numbers
14:55:23 <spacemarine__> from k to 1
14:55:31 <Cale> j is a single number at any one time
14:55:33 <spacemarine__> then comes why we pick up the j:xs
14:55:38 <Cale> it ranges over the numbers from k to 1
14:55:38 <spacemarine__> yeah
14:55:43 <spacemarine__> and xs is the rest of the list
14:55:56 <Cale> xs ranges over the partitions of (n-j) into parts at most j
14:55:57 <spacemarine__> then we say that we want xs to contain
14:56:30 <spacemarine__> yeah...the recursion
14:56:44 <spacemarine__> think I'm getting the hang of it
14:57:17 <spacemarine__> so
14:57:19 <spacemarine__> one last time
14:57:23 <spacemarine__> the last line says:
14:58:02 <dolio> int-e: True.
14:58:19 <spacemarine__> pick j from xs, create j from k to 1, and put a new list on xs wich would be the numbers from j to n-j ?
14:58:29 <nomeata> good night everyone
14:58:38 <Cale> pick j from xs?
14:58:45 <spacemarine__> head from xs
14:58:45 <Cale> pick j from [k,k-1..1]
14:58:46 <spacemarine__> j:xs
14:58:49 <Cale> oh
14:58:55 <Cale> we're building up that list
14:59:17 <spacemarine__> yeah......so I'm not picking it, i'm inserting it
14:59:23 <spacemarine__> so
14:59:37 <spacemarine__> insert j on xs , j from k to 1
14:59:46 <Cale> A partition of n into parts at most k is a list starting with a number j from k down to 1, and whose tail is a partition of (n-j) into parts of size at most j
15:00:09 <Cale> That's how I'd read it in English
15:00:22 <spacemarine__> a...it goes backwords from what I was thinking
15:00:42 <spacemarine__> ha...think I understood
15:01:05 <spacemarine__> so the recursive part, is just for the tail
15:01:12 <Cale> right
15:01:25 <Cale> We're putting one thing into the list for each recursive step.
15:01:32 <spacemarine__> since we already have build j, with the j <- [k,k-1..1]
15:01:35 <Cale> (into each list returned)
15:01:41 <Cale> yeah
15:01:54 <spacemarine__> easy program...hard as hell to understand it
15:01:58 <hpaste>  int-e annotated "which is the better groupWhen?" with "even lazier span1" at http://hpaste.org/141#a3
15:02:02 <spacemarine__> at least for me...
15:02:07 <Cale> spacemarine__: Well, it's mostly notation issues :)
15:02:16 <spacemarine__> yeah...basicly
15:02:28 <Cale> spacemarine__: Once you're used to it, programs like this are easy to write :)
15:02:39 <spacemarine__> I've programed in C for my at least past 12 yers....and on haskell for only 2 weeks
15:02:56 <jfredett> oof, C to haskell, thats hardcore.
15:03:14 <spacemarine__> hehhehe
15:03:22 <spacemarine__> I'm feeling it on my own skin
15:03:27 <jfredett> I started w/ Common lisp and Java, then I moved to Scheme.
15:03:38 <msingh> spacemarine__, i was workign on the same problem only 6 days ago :)
15:03:39 <Philippa> I shifted to haskell from C++, FWIW
15:04:01 <beelsebob> I'm not sure there are many of us that didn't switch from something C like
15:04:01 <jfredett> so I'm a pretty competent Functional Programmer coming into it, and its tough-- so much power makes my brain hurt
15:04:01 <Cale> dons went from Haskell to C (well, not really, but he learned C after)
15:04:03 <spacemarine__> msingh, you're not on my class are you?hudsahu
15:04:10 <Cale> at least, if I recall correctly
15:04:22 <msingh> space, no
15:04:30 <Cale> Learning C after is probably easier :)
15:04:40 <spacemarine__> easier...but one must hate it
15:04:44 <Cale> yeah :)
15:04:48 <jfredett> I think going from FP style to anything else is easier
15:04:53 <beelsebob> Cale: not so sure I agree
15:04:54 <jfredett> than anything else to FP style
15:04:58 <beelsebob> C requires so much more effort
15:05:06 <beelsebob> like horrific memory management nasties
15:05:11 <Cale> Well, sure. :)
15:05:18 <spacemarine__> my teacher says that C can give you cancer
15:05:18 <spacemarine__> hehe
15:05:24 <beelsebob> you have to think like a machine to write C
15:05:31 <beelsebob> instead of thinking like a human to write Haskell
15:05:33 <Cale> As something which is harder to do, it only seems natural that you'd learn it later.
15:05:52 <spacemarine__> yeah...but it's harder to think in haskell
15:05:54 <spacemarine__> I think
15:05:58 <jfredett> ...
15:06:07 <msingh> Cale, had you come across the partition thing before?
15:06:10 <Cale> Haskell's actually quite a bit closer to how humans think already :)
15:06:10 <byorgey> spacemarine__: only until you get used to it =)
15:06:11 <jfredett> then you obviously haven't been working with it long enough
15:06:16 <spacemarine__> I mean...I don't know...maybe I'm just used to think in C
15:06:18 <Cale> msingh: lots and lots and lots of times
15:06:35 <Philippa> yeah, you're a lot used to thinking in C
15:06:42 <jfredett> once your brain commits to being an FP programmer, in any FP language, you'll immediately be able to think previously impossible thoughts
15:06:47 <Cale> msingh: In fact, I'm in the middle of writing a set of libraries for combinatorics and partitions are one of the main things I'm working with :)
15:06:51 <Philippa> enough so that odds are to think in haskell you have to actively try not to think in C instead
15:07:03 <byorgey> Cale: nifty!
15:07:10 <spacemarine__> hehehe
15:07:15 <spacemarine__> I guess I have a LOT to learn
15:07:18 <msingh> Cale, heh. i see. are you using dynamic programming techniques to reduce memory usage?
15:07:19 <Philippa> expect to WTF at code that makes essential use of lazy evaluation for a while, for example
15:07:21 <Cale> I'm implementing a bunch of the algorithms from Fulton's book on Young tableaux.
15:08:06 <spacemarine__> I think the hardest thing, is to do what I do in C, in haskell
15:08:14 <spacemarine__> I mean
15:08:19 <spacemarine__> if I'd like to switch over
15:08:32 <spacemarine__> I'll have to get my own C programs, and put them in a haskell way
15:08:32 <Cale> I might. So far the emphasis hasn't been too much on efficiency, as I don't expect to be doing really huge cases. A little larger than what I can do on paper would make me happy :)
15:08:38 <spacemarine__> and THIS would be hell
15:08:41 <jfredett> no- the hardest thing will be realizing that haskell does everything you do in C implicitly, you just have to ask it nicely,
15:08:52 <jfredett> Haskell is as close to having a smart computer as is possible
15:08:52 <spacemarine__> hehehehhe
15:08:58 <siti> haskell rocks :p I used to love c and now only use it for low level stuff
15:09:03 <Philippa> jfredett: I wouldn't go that far
15:09:12 <Philippa> Epigram is considerably smarter for the things it knows how to do, for example
15:09:16 <spacemarine__> jfredett, can I make a file manager in OpenGL using haskell?
15:09:16 <Cale> Well, as is practical at present :)
15:09:20 <jfredett> sure
15:09:30 <spacemarine__> really?
15:09:35 <Cale> spacemarine__: GHC even comes with OpenGL libraries
15:09:35 <siti> yes :p
15:09:39 <jfredett> if you can write a kernel in it (it has been done) then why not?
15:09:47 <Philippa> spacemarine__: easy. HOpenGL, perhaps gtk2hs, IO via the IO monad
15:09:49 <spacemarine__> ahaha..cool
15:09:55 <msingh> Cale, ok. probably a good idea just to write them normally and then later use a memoization package
15:10:03 <Cale> Haskell is a very practical language :)
15:10:08 <spacemarine__> so I c
15:10:16 <spacemarine__> I'm actually doing one in C....
15:10:17 <spacemarine__> hehehe
15:10:20 <Cale> msingh: yeah
15:10:26 <jfredett> if you can write a WM (like xmonad) in ~500 lines, I'd bet you money you could write whatever the frak you want in haskell
15:10:35 <siti> Cale: there is no need for that wink, it truely is :p
15:10:47 <spacemarine__> it's stopped in almost a yer...no time to spend on it
15:10:49 <Cale> wink?
15:10:58 <Cale> that was just a smiley
15:10:59 <siti> your ";)"
15:11:03 <siti> oh oops
15:11:14 <siti> my smiley theme has issues :p
15:11:16 <Philippa> jfredett: there're things I wouldn't write just yet, like anything where I'd be wary about using a garbage collector
15:11:46 <jfredett> Philippa, granted, haskell might not be the _best_ choice, the point i was aiming for is that it _a_ choice
15:11:54 <jedai> spacemarine__:  You've seen xmonad ?
15:12:06 <spacemarine__> jedai, no
15:12:10 <spacemarine__> let me google
15:12:10 <Cale> msingh: I'm striving for algebraic niceness. I have a datatype for monoid rings in general, and then have the plactic ring implemented automatically by defining a monoid on tableaux, and the polynomial ring in x_1,x_2,... using partitions as my monoid.
15:12:12 <siti> yeah but not using a gc only leaves c/c++ ;)
15:12:32 <spacemarine__> good thing about google
15:12:36 <spacemarine__> put xmonad
15:12:39 <jedai> spacemarine__:  It's pretty awesome : http://xmonad.org/intro.html#dmenu
15:12:39 <spacemarine__> and it replyes
15:12:40 <lambdabot> Title: xmonad : an overview
15:12:46 <spacemarine__> did you mean limonad?
15:12:47 <spacemarine__> hehe
15:12:56 <Cale> Doing your own memory management in this day and age is irresponsible.
15:13:06 <Philippa> jfredett: it's not impossible that for small embedded tasks I'd build a low-level language as an EDSL and work from there, either
15:13:09 <siti> not for low level stuff
15:13:21 <jedai> spacemarine__:  It's a tiling Windows Manager in Haskell
15:13:28 <Philippa> though I say that as someone who isn't totally scared by the idea of writing a compiler (just put off by the tedium of doing stuff like register allocation)
15:13:30 <spacemarine__> I'm seeing....very nice
15:13:33 <spacemarine__> very nice indeed
15:13:43 <jedai> Was written extremely fast too and already great !! :)
15:13:48 <Cale> Well, there are such good garbage collectors that have already been implemented.
15:13:57 <hpaste>  int-e annotated "which is the better groupWhen?" with "woops, copying groupBy mostly unmodified wasn't a good idea." at http://hpaste.org/141#a4
15:14:31 <jfredett> Philippa, like I said, Haskell is _a_ choice, and thats the important thing. But in general, some problems are best suited to imperative solutions, some are best stated functionally, its all about the problem- when it comes down to it.
15:14:36 <emu> register allocation is an interesting problem
15:14:48 <emu> since it's NP-complete
15:14:51 <spacemarine__> nice
15:15:05 <Philippa> emu: it's not interesting to me, someone else can write the damn allocator :-)
15:15:10 <Cale> jfredett: hehe, that's what monads are for :)
15:15:27 <emu> well what fun is left if all the challenging bits are done by someone else? :P
15:15:36 <spacemarine__> guys...thanks a lot for the help
15:15:38 <Philippa> writing the stuff I want to get written?
15:15:45 <spacemarine__> for sure I'll be seeing more of haskell
15:15:47 <spacemarine__> I liked it
15:15:50 <spacemarine__> a little strange
15:15:54 <spacemarine__> but very nice
15:15:56 <spacemarine__> very nice indeed
15:16:09 <spacemarine__> as soon as I get some vacations
15:16:16 <spacemarine__> I'll start going more deep into haskell
15:16:23 <Cale> spacemarine__: come hang around any time you have questions
15:16:24 <spacemarine__> now I have other classes to finish
15:16:31 <spacemarine__> I will
15:16:38 <spacemarine__> even if I don't have any question
15:16:51 <spacemarine__> just to see..browse...talke...hehe :D
15:16:59 <spacemarine__> thanks a lot Cale, you saved my life :D
15:17:10 <ddarius> Speaking of xmonad, I should be booting into it in a few minutes.  Let me just check how to do -anything- in it first.
15:17:14 <jfredett> Cale, meh --
15:17:29 <jfredett> ddarius, lol...
15:17:47 <ddarius> And I'm sure I'm going to have to hack the keybindings...
15:18:06 <jfredett> see, I use Ion now, and its nice-- but I don't want to learn Lua (its ugly)
15:18:17 <jfredett> so maybe I should switch over to xmonad--
15:18:18 <jfredett> hmm
15:18:19 <siti> is there a deb repo for xmonad ;)
15:18:23 <ddarius> I used Ion a long time ago.  I liked it and I was using it in Windows.
15:18:35 <sorear>  nice++ xmonad++
15:18:35 <emu> speaking of which, maybe i will try implementing a linear scan allocator in haskell for kicks
15:18:44 <jfredett> damnit, sorry sorear
15:18:45 <spacemarine__> guys...thanks a lot...I have to go now
15:18:49 <ddarius> siti: There is cool stuff in the darcs version
15:18:49 <spacemarine__> U guys rock !!!!
15:18:52 <spacemarine__> c ya
15:18:54 <spacemarine__> good nite
15:19:05 <siti> ddarius: k
15:19:13 <ddarius> Anyways, be back in a minute hopefully...
15:19:24 <siti> I will just try out the 0.2 release and see if I like tiling window manager
15:19:26 <siti> s
15:19:32 <jfredett> I dunno, I'll have to look at xmonad.. if it's got similar features to ion, maybe I'll take the dive and switch
15:19:33 <jfredett> :)
15:20:02 <Eelis> jfredett: as an Ion3 user, i can say that xmonad is very different. (in a bad way, imho)
15:20:11 <psi> if you've used dwm, it's very similar
15:20:27 <jfredett> Eelis, see, all I really want is hotkeys, multiple WS's and no mouse
15:20:39 <jfredett> i hate my laptop touchpad
15:20:46 <sorear> jfredett: Xmonad can do all of those things easily.
15:20:54 <Cale> I'd be using xmonad if I could stand tiling window managers :)
15:21:05 <jfredett> oh- and it needs to be pretty damn scriptable
15:21:23 <psi> i dunno, i'm using openbox + gnome right now. i've turned away from these esoteric window managers.
15:21:24 <jfredett> Cale, I flip flop between Ion and KDE right now
15:21:29 <Cale> I'm way too used to having my windows a bit larger than I could with tiling.
15:21:39 <psi> they are cool but they cause troubles pretty often.
15:21:46 <Cale> Currently I'm running boring metacity.
15:21:50 <sorear> Cale: mod-space and switch into fullscreen :)
15:22:09 <Cale> sorear: but I need to be able to see them both! :)
15:22:13 <ddarius> Cale: I don't intend to use tiling much.
15:22:21 <psi> if you're running terminal applications mostly they're golden, of course.
15:23:27 <sorear> Cale: uh ... how can you see them both without tiling them?
15:23:30 <siti> hmm does xmonad hate panels :p?
15:23:35 <jfredett> damnit, I want 2 more monitors for my computers
15:23:36 <jfredett> :)
15:23:49 <ddarius> jfredett: xmonad can handle that
15:24:00 <jfredett> i know- thats why i want them
15:24:15 <sorear> siti: No.
15:24:21 <siti> ok
15:24:22 <psi> what about xmonad and splash screens? i tried to start open office, and it got confused.
15:24:38 <jfredett> i want to get 5 LCD monitors, 3 for my desktop (i use a CRT now, it hurts my eyes)
15:24:42 <jfredett> and 2 more for my laptop
15:24:51 <Cale> sorear: by overlapping them only partially
15:24:56 <ddarius> psi: The darcs version has floating window support.  I don't know if that will help.
15:25:12 <psi> ok
15:25:19 <jfredett> so I can have enough screen real estate to watch tv, browse the net, code, read articles, and monitor email
15:25:21 <jfredett> all at once
15:25:32 <Cale> In particular, I usually like at least a bit of my irc window visible so that I can see when new messages come in
15:25:52 <byorgey> jfredett: yeah right =)
15:26:10 <jfredett> byorgey, someday, byorgey... I'll send you pictures of my set up
15:26:17 <ulfdoz> Im brigen bin ich gegen obsd, weil nbsd viel besser ist. *tsch*
15:26:22 <ulfdoz> ECHAN, sorry
15:26:34 <jfredett> *hides* scary letters!
15:26:36 <byorgey> jfredett: heh, I look forward to it.  I have 2 monitors myself and it's pretty sweet =)
15:26:48 <jfredett> byorgey, i want a projector too
15:26:52 <jfredett> for movies... :)
15:26:55 <sorear> jfredett: jcreigh has 3
15:26:59 <jfredett> or video games
15:27:01 <jfredett> :)
15:27:12 <byorgey> @babel de en Im brigen bin ich gegen obsd, weil nbsd viel besser ist. *tsch*
15:27:13 <lambdabot>   In the brigen I am approximately obsd, because nbsd is much better * tsch *
15:27:29 <byorgey> jfredett: that would be pretty sweet
15:27:39 <jfredett> :)
15:27:57 <jfredett> I imagine playing Doom II on the side of my house
15:28:15 <byorgey> jfredett: watch out, you might start a #haskell monitors-race
15:28:22 <jfredett> lol
15:28:28 <jfredett> other people will win
15:28:32 <jfredett> i have no money
15:28:41 <byorgey> pretty soon you are going to be loggin on to brag about your 17 monitors only to find that everyone else has at least 38
15:28:47 <jfredett> yah-
15:28:57 <jfredett> 17 monitors would be a little much
15:29:04 <jfredett> i dont have the grfx card support for that
15:29:06 <jcreigh> two of my monitors were given to me, and the third I bought for $15 at the salvation army.
15:29:19 <byorgey> jcreigh: nice!
15:29:27 <jfredett> are they CRT's or LCD's?
15:29:31 <jcreigh> CRTs
15:29:43 <jfredett> yeh- I can't use those
15:29:50 <jfredett> I can't see in them anymore
15:30:05 <byorgey> jfredett is a monitor snob
15:30:14 <siti> I have 2*20"s but would like a 30" in the middle ;)
15:30:17 <jfredett> byorgey, no, i really cant see in them anymore
15:30:18 <stick_figure> Oh college, free CRTs falling out of windows...
15:30:23 <jcreigh> http://www.xmonad.org/images/screen-jcreigh.png
15:30:28 <byorgey> jfredett: just joking =)
15:30:44 <stick_figure> Techno trash everywhere... it's paradise.
15:30:52 <jfredett> I'm basically blind-- my standard font is 15 pt
15:30:55 <jfredett> :)
15:30:59 <jfredett> 13 if i have my glasses
15:31:00 <jfredett> :)
15:31:05 <jfredett> stick_figure, I  know what you mean
15:31:27 <jfredett> i go to Worcester Polytech, I've found more stuff in the ECE dept...
15:31:59 <weitzman> That reminds me of a time some people and I wanted to get some old mice and chop off most of the chords  to see if they were good for juggling
15:32:07 <weitzman> Had 6 mice in 10 minutes
15:32:21 <weitzman> Ah, the joy of university
15:32:47 <jcreigh> weitzman: here was me thinking you were chopping off the cords to see if the offspring would have cords when they reproduced. :)
15:33:13 <jcreigh> I think computer mouse genetics is a rich field of research that's been largely ignored. <g>
15:33:35 <weitzman> It was more of a problem with the chords all getting caught on stuff. Hardly mattered though: For the record, computer mice are damn hard to juggle
15:33:55 <weitzman> At least, with a short cord. Probably easier with no cord
15:34:27 <ddarius> Yeah.  It shouldn't be too hard with no cord.
15:37:44 <sorear> @karma test
15:37:44 <lambdabot> test has a karma of 1
15:37:54 <sorear> @ignore + sorear_
15:38:00 <sorear_> test++
15:38:06 <sorear> @karma test
15:38:06 <lambdabot> test has a karma of 1
15:38:13 <sorear> @ignore - sorear_
15:38:36 <kaol> test++
15:40:02 <byorgey> sorear: hmm, you can tell lambdabot to ignore people?
15:40:07 <sorear> byorgey: Yep.
15:40:18 <sorear> byorgey: it's a pretty new feature
15:40:41 <byorgey> sorear: hmm... what would you use it for?
15:40:51 <int-e> byorgey: to ignore other bots mostly
15:41:01 <byorgey> ah, makes sense
15:44:54 <filcab42> hi
15:45:11 <byorgey> hi there filcab42
15:45:39 <filcab42> I'm following "yet another haskell tutorial" and I'm getting an error trying to make my "List" class an instance of Show
15:45:49 <filcab42> I have (like in the tutorial):
15:45:55 <filcab42> instance Show List where
15:45:55 <filcab42>     show Nil = "[]"
15:45:55 <filcab42>     show Cons a l = (show a) ++ ":" ++ (show l)
15:46:06 <filcab42> I get: ERROR "/Users/filcab/dev/cs/coisas.hs":195 - Illegal type in class constraint
15:47:02 <sorear> List isn't showable, because it's incomplete
15:47:09 <sorear> you can show any List a
15:47:20 <sorear> ... instance Show (List a) where ...
15:47:31 <sorear> List a matches List Char, List Bool, etc
15:47:51 <psi> don't you need to say that a is an instance of Show, as well?
15:47:53 <filcab42> oh
15:48:11 <filcab42> should I say: instance (Show a) => (List a)
15:48:15 <filcab42> or is it not needed?
15:48:37 <Cale> filcab42: yes
15:48:51 <byorgey> filcab42: instance (Show a) => Show (List a)
15:48:52 <kpreid> filcab42: the parentheses are all unnecessary
15:49:10 <kpreid> er, right. okay, the ones on the left are unnecessary
15:49:29 <kpreid> also, show Cons a l = show a ++ ":" ++ show l
15:49:48 <filcab42> kpreid: shouldn't that have parenthesis?
15:49:56 <byorgey> show (Cons a l) = ...
15:49:57 <filcab42> show (Cons a l) = (show a) ++ ...
15:50:59 <kpreid> filcab42: no, because application has higher precedence than infix operators
15:50:59 <byorgey> filcab42: the parens around (Cons a l) are necesary but the parens around (show a) are not.
15:51:20 <kpreid> er, oops, I should have added those. sorry, I'm looking at things too narrowly
15:51:27 <kpreid> show (Cons a l) = show a ++ ...
15:52:40 <filcab42> instance Show (List a) where
15:52:41 <filcab42>     show Nil = "[]"
15:52:41 <filcab42>     show (Cons a l) = show a ++ ":" ++ show l
15:52:53 <filcab42> ERROR "/Users/filcab/dev/cs/coisas.hs":196 - Cannot justify constraints in instance member binding
15:52:53 <filcab42> *** Expression    : show
15:52:53 <filcab42> *** Type          : Show (List a) => List a -> String
15:52:53 <filcab42> *** Given context : Show (List a)
15:52:54 <filcab42> *** Constraints   : Show a
15:53:21 <byorgey> filcab42: don't forget that a has to be an instance of show for List a to be
15:53:27 <kpreid> filcab42: you need to write instance Show a => Show (List a) ...
15:53:40 <kpreid> as it is you're claiming that you can show List a for arbitrary a, which conflicts with the "show a" in the implementation
15:53:42 <filcab42> quite right
15:53:50 <filcab42> hmm... that makes sense
16:04:04 <filcab42> is there a way to use an action's return value withou binding it?
16:04:17 <filcab42> for example: putStrLn (getLine)
16:04:31 <byorgey> filcab42: getLine >>= putStrLn
16:05:15 <byorgey> or putStrLn =<< getLine
16:05:21 <filcab42> ah
16:05:25 <filcab42> I remember that
16:05:30 <byorgey> @type (>>=)
16:05:32 <filcab42> I skimmed the pdf
16:05:32 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
16:05:39 <filcab42> and saw that
16:05:43 <filcab42> but I'm not there, yet
16:05:47 <filcab42> thanks anyway ;)
16:05:50 <kpreid> or: join (fmap putStrLn getLine)
16:06:40 <byorgey> filcab42: do { x <- foo ; bar } just gets translated to (foo >>= \x -> bar)
16:07:00 <byorgey> filcab42: but if that doesn't make sense yet then don't worry about it =)
16:07:13 <filcab42> yes
16:07:20 <filcab42> I'll wait until I get there ;)
16:07:33 <byorgey> ok, sounds good.
16:08:46 <ddarius> Except that my vim installation is weird, I'm not sure what to do now.
16:08:56 <sieni> :q!
16:09:30 <sieni> (stupid joke, but someone had to say it)
16:09:42 <byorgey> ddarius: kick the monitor, that usually helps
16:09:48 <sieni> (I use vi keybindings with emacs)
16:10:45 <weitzman> sieni: Is using vi bindings in emacs relatively smooth?
16:15:06 <sieni> weitzman: well there are quite few bugs, but viper-mode is recommended if you want to do that.
16:16:23 <sieni> weitzman: I use emacs + viper-mode solely at work
16:16:35 <sieni> (well, vim for mail and such)
16:22:01 <sieni> weitzman: some default keybindings are annoying, but you can look at my .emacs if you spot something that annoys you
16:23:29 <weitzman> I'll check it out
16:23:55 <chessguy> hi all
16:24:57 <TSC> Hi chessguy
16:25:45 <chessguy> how goes?
16:25:52 <TSC> Goes well
16:27:16 <chessguy> lively bunch today
16:28:23 <TSC> It's early
16:30:35 <drakferion> Hello again. I'm trying to do pattern matching of strings inside strings on function headers, and not succeeding. Anyone has a good pointer to give me, even if it's just a "nah, that can't be done"?
16:30:50 <drakferion> example=   linha ("PROGRAM"++rest) = print "popo"
16:31:03 <fasta> Is it better to abstract code always? I have a case where I either do left or right things. So, set_left_foo_bar would map to set_right_foo_bar, "+" would map to "-" and more of these things. Ideally, I would like to say:"This is case is the same as that case, but replace symbols X with Y.
16:31:05 <drakferion> haskell won't let me use ++ on headers.
16:31:37 <fasta> drakferion: reading a tutorial will help
16:31:42 <fasta> drakferion: or a book
16:32:37 <drakferion> rtfm, i guess :)
16:32:42 <fasta> s/This is case/This case
16:33:01 <fasta> drakferion: yes, you need to do that sooner or later, anyway.
16:33:15 <Korollary> drakferion: You can use 'a':'b':_, but not "ab" ++ something else. ++ is not a data constructor.
16:33:58 <drakferion> I had tried the 'a':'b':rest, but it sounded too long to be decent.
16:34:10 * drakferion tips hat* Thanks anyway. :)
16:36:15 <dibblego> what do you call the set of all naturals except zero?
16:36:25 <weitzman> Whole numbers?
16:36:33 <fasta> dibblego: some people call those naturals
16:36:38 <psi> although n+1 works, even though it's not a data constructor. are there other special cases?
16:36:50 <chessguy> n+1 is deprecated
16:37:26 <psi> meaning it won't work at all in haskell'?
16:37:56 <sorear> Won't work in haskell-no-prime.
16:38:07 <chessguy> meaning its use is discouraged and may may not work in future (versions of) implementations
16:38:10 <sorear> Haskell is such a burden to implement everyone cuts corners
16:38:23 <sorear> GHC implements n+1, but most everyone else doesn't
16:38:29 <sorear> > let (x+1) = 5 in x
16:38:29 <lambdabot>  Parse error in pattern
16:38:42 <sorear> Even though it's in the specification.
16:38:51 <filcab42> :o
16:38:58 <filcab42> let should bind that?
16:39:02 <filcab42> omg
16:40:01 * SamB_XP wonders why this FPGA devboard looks just like a computer
16:40:38 <filcab42> [00:34] dibblego: what do you call the set of all naturals except zero? <- Positive naturals or positive whole numbers
16:40:45 <SamB_XP> http://www.altera.com/products/devkits/altera/kit-cyc2-2C20N.html
16:40:46 <lambdabot> Title: Cyclone II FPGA Starter Development Kit
16:48:38 <SamB_XP> oh lame, it only has 4-bit-per-channel DACs on the VGA...
16:49:24 <edwardk> samb: blech
16:50:07 <edwardk> how... amiga
16:51:02 <filcab42> if I do: a{b=c}
16:51:17 <filcab42> then a is updated or do I get a copy?
16:51:23 <filcab42> (I'm guessing it's the second
16:51:27 <edwardk> filcab42: its a copy
16:51:39 <edwardk> element by element, replacing the element at position b with value c.
16:53:03 <filcab42> yes
16:53:05 <filcab42> thankds
17:09:02 <psi> http://xmonad.org/images/screen-droundy-mosaic.png <- the guy looks like the villain from heroes
17:27:24 <chessguy> @pl \x -> x{foo=bar}
17:27:24 <lambdabot> (line 1, column 8):
17:27:24 <lambdabot> unexpected "{"
17:27:24 <lambdabot> expecting letter or digit, variable, "(", operator or end of input
17:31:45 <dolio> Jonesing for first-class record update, I see? :)
17:37:25 <ajudem_me> hi
17:37:31 <sorear> @users
17:37:32 <lambdabot> Maximum users seen in #haskell: 342, currently: 298 (87.1%), active: 41 (13.8%)
17:37:32 <sorear> hi
17:37:40 <ajudem_me> I'm trying to do something but I've no idea how to...
17:37:53 <ajudem_me> I want to create an type or data
17:38:07 <ajudem_me> that allows me to do something like this... w8
17:39:54 <petekaz> A big thanks to whoever wrote the zipper page in the wikibook:  http://en.wikibooks.org/wiki/Haskell/Zippers
17:40:02 <lambdabot> Title: Haskell/Zippers - Wikibooks, collection of open-content textbooks
17:40:03 <petekaz> I now understand them!
17:40:04 <hpaste>  ajuda pasted "(no title)" at http://hpaste.org/142
17:40:21 <ajudem_me> can you help me?
17:41:35 <dolio> data Statement = Iterator Int Statement | Loop Condition Statement | Conditional Condition Statement
17:41:56 <sorear> I feel so stupid.
17:42:13 <sorear> I just wrote a wrapper around mutt that locks a file first.
17:42:30 <sorear> Guess what I called this wrapper around mutt.  Guess what happened when I ran it. :)
17:42:52 <Pseudonym> wrapmutt?
17:42:53 <shachaf> sorear: I've done that once. :-)
17:42:54 <ajudem_me> dolio, but how can I access the Statement, for instance?? is it in a tuple or something? I'm not confortable with data types
17:43:10 <shachaf> sorear: It's the sort of mistake you don't repeat very often.
17:43:58 <shachaf> sorear: (If you lock the file, though, then the second time the script runs it should see the lock and not run mutt, no?)
17:43:59 <dolio> ajudem_me: You'd destructure it in a pattern match? Let me paste an example...
17:44:20 <sorear> shachaf: Right.  It locked the file, called itself, failed, ...
17:44:32 <sorear> fortunately the lock prevented infinite recursion
17:44:55 <shachaf> sorear: OK, so it's not as bad as mine... :-)
17:45:25 <byorgey> sorear: wait, you called the wrapper 'mutt'?
17:45:26 <kpreid> ajudem_me: case s of Iterator i s' -> ...; Loop c s' -> ...
17:45:36 <sorear> byorgey: Yes!
17:45:45 <byorgey> sorear: hehe =)
17:46:01 <hpaste>  dolio annotated "(no title)" with "example" at http://hpaste.org/142#a1
17:46:04 <Pseudonym> I don't think I've ever made that mistake.
17:46:18 <kpreid> ajudem_me: other than special syntax, tuples are just builtin data types
17:46:21 <kpreid> @src fst
17:46:21 <lambdabot> fst (x,_) =  x
17:46:24 <kpreid> @src snd
17:46:24 <lambdabot> snd (_,y) =  y
17:48:45 <byorgey> @type iterate fst
17:48:49 <lambdabot>     Occurs check: cannot construct the infinite type: a = (a, b)
17:48:49 <lambdabot>       Expected type: (a, b) -> (a, b)
17:49:25 <byorgey> don't mind me, just whacking types over the head =)
17:49:37 <ddarius> I've done the Haskell equivalent of it.
17:50:01 <byorgey> ddarius: of what? iterate fst?
17:50:27 <hpaste>  ajuda annotated "(no title)" with "(no title)" at http://hpaste.org/142#a2
17:50:42 <ajudem_me> dolio, please check it =)
17:51:29 <dolio> ajudem_me: It's a function, that when given an Iterator returns 1, when given a Loop return 2, and when given a Conditional returns 3.
17:51:51 <kpreid> byorgey: you can do that by inserting a newtype in there so that the type isn't infinite
17:52:03 <kpreid> byorgey: iterate (fst . unwrap)
17:52:37 <ajudem_me> dolio, but how can I put values in int, for instance??
17:52:38 <byorgey> kpreid: ah, I see.  nifty.
17:53:13 <dolio> ajudem_me: You mean, like, modify the int if given an Iterator?
17:53:47 <ajudem_me> dolio yes... or read it...
17:54:06 <kpreid> ajudem_me: to read it, use the variable i where dolio's example has a 1
17:55:15 <hpaste>  dolio annotated "(no title)" with "example2" at http://hpaste.org/142#a3
17:57:17 <dolio> ajudem_me: You don't really 'change' the int, though. What you do is get the content of the old one, and build and return a new one the way you want it.
17:57:56 <kpreid> dolio: you change it like you change a light bulb :)
17:58:06 <kpreid> or a diaper
17:58:07 <dolio> Heh.
17:58:35 <dolio> Well, even then, you're putting a new light bulb in the same socket.
17:58:50 <dolio> In this, you're buying a new house with working lightbulbs.
17:59:32 <dolio> Although, maybe your new house is partially constructed out of pieces cut off your old house.
18:00:33 <byorgey> dolio: but the General Hardworking Contractors did that for you, so you wouldn't necessarily know =)
18:00:51 <dolio> :)
18:01:02 <ajudem_me> dolio: yes... I know that the language is pure, but I can change the value, right? =P
18:01:17 <ajudem_me> dolio, are you korean? or do you like martial arts?
18:03:04 <dolio> Well, I'm not Korean.
18:03:21 <byorgey> @paste
18:03:22 <lambdabot> Haskell pastebin: http://hpaste.org/new
18:03:33 <dolio> I like martial arts movies. Can't say I've tried doing it myself, though. :)
18:04:12 <ajudem_me> dolio: lol... Because Dolio (I'm not sure how to right it in english) is the word for "high kick" in korean ;P
18:05:08 <dolio> Ah. Heh, I didn't know that. It's just a nickname someone came up with for me in high school.
18:05:12 <hpaste>  byorgey pasted "iterate (fst . unwrap)" at http://hpaste.org/143
18:05:31 <byorgey> kpreid: hmm, I can't get it to work... think you could take a look? (purely out of curiosity =)
18:05:36 <ajudem_me> dolio, lol... ok ;)
18:06:07 <ajudem_me> (before I meant write ;P I'm sleepy and it sounds likely ;P)
18:07:30 <mauke> byorgey: what is foo supposed to do?
18:08:24 <byorgey> mauke: nothing, really, I was just being silly and did '@type iterate fst' which gave an occurs check error, which makes sense.
18:08:36 <byorgey> mauke: but then kpreid said that if I used a newtype it could work.
18:08:41 <mauke> fst . unwrap has the type Pair a b -> a
18:08:47 <mauke> iterate requires c -> c
18:09:04 <mauke> you can't unify Pair a b and a because then you get infinite recursion
18:09:20 <byorgey> mauke: right, that's what I thought.  So I was trying to figure out what kpreid meant.
18:10:15 <dolio> I suspect it's the same trick you use to write the Y-combinator the traditional way. I forget the details, though.
18:11:43 <byorgey> byorgey: ah well, no matter.
18:11:57 * byorgey wonders why he said that to himself.
18:12:13 <mauke> byorgey: newtype R b = R { unwrap :: (R b, b) }
18:12:13 <mauke> foo = iterate (fst . unwrap)
18:12:52 <byorgey> aha!
18:13:15 <byorgey> ok, that makes sense.
18:13:31 <mauke> newtype R' a = R' a (R' a)
18:13:36 <mauke> which is an infinite list
18:14:03 <mauke> except that should be data
18:14:49 <byorgey> oh, I see now.  using a tuple instead of cons.
18:15:19 <mauke> :t iterate tail
18:15:21 <lambdabot> forall a. [a] -> [[a]]
18:15:41 <dmwit> > tails "hey, it's already made"
18:15:42 <lambdabot>  ["hey, it's already made","ey, it's already made","y, it's already made",", ...
18:16:28 <dmwit> > tails ",\",\","
18:16:29 <lambdabot>  [",\",\",","\",\",",",\",","\",",",",""]
18:16:30 <byorgey> yes, but here tail is isomorphic to (fst . unwrap).
18:17:12 <byorgey> gah!
18:17:18 <dmwit> hee hee!
18:17:35 <chessguy> @src tails
18:17:35 <lambdabot> tails []         = [[]]
18:17:35 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
18:17:59 <byorgey> @src inits
18:17:59 <lambdabot> inits []     =  [[]]
18:17:59 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
18:18:13 <byorgey> > inits $ Control.Monad.Fix.fix show
18:18:14 <lambdabot>  ["","\"","\"\\","\"\\\"","\"\\\"\\","\"\\\"\\\\","\"\\\"\\\\\\","\"\\\"\\\\\...
18:18:37 <mauke> @v
18:18:37 <lambdabot> "\""
18:18:48 <dons> ?yow
18:18:51 <lambdabot> A dwarf is passing out somewhere in Detroit!
18:19:04 <dolio> > iterate tail "oh noes"
18:19:05 <lambdabot>  Exception: Prelude.tail: empty list
18:19:47 <byorgey> > iterate tail $ "oh noes"
18:19:48 <lambdabot>  Exception: Prelude.tail: empty list
18:20:25 <dmwit> > tail "" -- =(
18:20:26 <lambdabot>  Exception: Prelude.tail: empty list
18:20:35 <byorgey> > takeWhile (not.null) $ iterate tail "oh noes"
18:20:36 <lambdabot>  ["oh noes","h noes"," noes","noes","oes","es","s"]
18:21:39 <byorgey> @help v
18:21:39 <lambdabot> let v = show v in v
18:21:52 <dmwit> takeWhile (not.error) $ iterate tail "oh noes" -- I wish
18:22:06 <byorgey> hehe
18:22:19 <ddarius> > takeWhile (not . isBottom) $ iterate tail "oh noes"
18:22:19 <lambdabot>   Not in scope: `isBottom'
18:22:23 <ddarius> @index isBottom
18:22:23 <lambdabot> Test.QuickCheck.Batch, Debug.QuickCheck.Batch
18:22:32 <dmwit> !
18:22:35 <ddarius> > takeWhile (not . Debug.QuickCheck.Batch.isBottom) $ iterate tail "oh noes"
18:22:36 <lambdabot>   Not in scope: `Debug.QuickCheck.Batch.isBottom'
18:22:46 <ddarius> > takeWhile (not . Test.QuickCheck.Batch.isBottom) $ iterate tail "oh noes"
18:22:47 <lambdabot>   Not in scope: `Test.QuickCheck.Batch.isBottom'
18:22:49 <ddarius> bah
18:23:06 <dmwit> What is it, isBottom x = x `seq` False ?
18:23:16 <byorgey> well, tail "" isn't bottom anyway
18:23:19 <ddarius> dmwit: No.
18:23:38 <byorgey> dmwit: heh
18:23:59 <dmwit> I mean, it seems like isBottom isn't really a decidable function.
18:24:18 <SamB> dmwit: no, it isn't really
18:24:21 <byorgey> true.
18:24:43 <byorgey> @src isBottom
18:24:43 <lambdabot> Source not found. Are you on drugs?
18:25:04 <dmwit> ?source Debug.QuickCheck.Batch
18:25:04 <lambdabot> http://darcs.haskell.org/packages/QuickCheck/Debug/QuickCheck/Batch.hs
18:25:34 <dons> there's something funny about icfpconference.org being called icfpconference.org
18:26:19 <Adamant> does it have something to do with ATM Machines?
18:26:20 <hpaste>  ajude_me pasted "Data types" at http://hpaste.org/144
18:26:21 <dmwit> Mmmm, of course it has to use unsafePerformIO. =P
18:26:22 <dolio> Like the department of redundancy department?
18:26:25 <dons> byorgey: btw, i was going to suggest (to find interesting unis to look at), looking at those mentioned in the committee of the major FP conferences, http://www.icfpconference.org/structure.html#Steering
18:26:26 <lambdabot> Title: The ACM SIGPLAN International Conference on Functional Programming (ICFP): Organ ...
18:26:41 <byorgey> dons: thanks, that's a good idea.
18:26:44 <ajudem_me> can you please check this out? http://hpaste.org/144
18:27:32 <dmwit> You need constructors.
18:27:51 <ajudem_me> dmwit, how's that?
18:28:11 <mauke> because you used 'data'
18:28:17 <hpaste>  dmwit annotated "Data types" with "with constructors" at http://hpaste.org/144#a1
18:28:33 <dmwit> Errr... that's not quite right.
18:29:02 <hpaste>  dmwit annotated "Data types" with "paying more attention this time" at http://hpaste.org/144#a2
18:29:03 <ajudem_me> no?
18:29:38 <dmwit> ajudem_me: The constructors act as the "tags" that you were trying to get with your strings.
18:30:00 <dmwit> So, later in the program, you can test if a given Stm is an Iterador by doing:
18:30:26 <dmwit> isIterador :: Stm -> Bool; isIterador (Iterador _ _) = True; isIterador _ = False
18:31:13 <dmwit> (for example)
18:31:16 <hpaste>  ajude_me annotated "Data types" with "(no title)" at http://hpaste.org/144#a3
18:31:40 <dmwit> yes
18:31:48 <ajudem_me> dmwit, oki,  tnks =)
18:31:57 <dmwit> Good luck, come back with more! =)
18:33:48 <ajudem_me> be sure I will!! I've to finish this work for tomorrow and I've lots of doubts about Haskell!
18:33:49 <ajudem_me> ;P
18:34:12 <mauke> s/doubts/questions/
18:35:41 <hpaste>  ajude_me pasted "(no title)" at http://hpaste.org/145
18:36:13 <ajudem_me> any ideas?
18:36:18 <mauke> you need constructors
18:36:19 <dmwit> ajudem_me: Constructors go first, not last.
18:36:43 <ajudem_me> dmwit, ??
18:36:50 <dmwit> ajudem_me: One sec, I'm typing. =)
18:37:19 <mauke> ajudem_me: data <TYPE> = <CONSTRUCTOR1> Type1 Type2 ... | <CONSTRUCTOR2> Type1 Type2 ... | ...
18:37:30 <dmwit> ... yeah
18:37:31 <mauke> your code is missing constructors
18:37:35 <dmwit> That's what I was typing, too. =P
18:37:49 <ajudem_me> hmmm... but what is the constructor?
18:37:55 <mauke> whatever you want
18:38:11 <dmwit> "data A = C Int | B Bool" says:
18:38:33 <mauke> you can use any identifier as long as it starts with an uppercase letter (and isn't already defined)
18:38:34 <dmwit> Create a new type, called "A", that can be made by either supplying an Int to the constructor "C", or by supplying a Bool to constructor "B".
18:39:03 <dmwit> So you might define something like
18:39:11 <dmwit> data Point = Coordinates Int Int
18:39:27 <dmwit> Then you could later make a Point by doing
18:39:32 <dmwit> Coordinates 3 5
18:40:13 <dmwit> ajudem_me: So, assuming you're using something like hpaste.org/144 ...
18:40:38 <dmwit> You can make a value of type "Stm" by doing something like "Iterador 3 5".
18:40:52 <dmwit> (Or "Ciclo 3 5", or "Condicional 3 5". ;-)
18:52:34 <ajudem_me> dmwit, ok... I got it ;)
18:52:35 <ajudem_me> tnks =)
18:52:35 <dmwit> great
18:59:13 <timthelion> aha, why wasn't it said like this in all those things I read about the IO monad?: The IO monad is the haskell version of scrodinger's cat, only upon observing the cat, does it live or die.
18:59:36 <dons> mmm. a new metaphor for the IO monad.
18:59:42 <dons> timthelion: now you get to write a tutorial!
18:59:58 <manveru> heya
19:00:09 <timthelion> I'm googling to see if any one else has done it
19:01:06 <ajudem_me> are there multiline comments?
19:01:11 <manveru> so, i'm back at my work machine and somehow the middle mouse-button doesn't work
19:01:33 <bos> a cat eating a crate of apples, in a spacesuit!
19:01:51 <kpreid> ajudem_me: {- ... -}
19:01:54 <manveru> uh, that is concerning the xmonad problem i had before the weekend :)
19:02:10 <timthelion> my essay, would be about how the evaluation of a haskell program is like the martian life in "Stranger in a Strange land" which is that the person lives their life, untill their journey of discovery is compleet(discovery of the value of main) and then the person dicorperates(dies)
19:02:28 <dons> manveru: drop by #xmonad perhaps?
19:02:35 <ajudem_me> kpreid tnks =)
19:02:35 <manveru> do they have a channel yet?
19:02:39 <dons> we sure do.
19:02:42 <timthelion> yep, alive and well
19:02:45 <dons> ?users #xmonad
19:02:46 <lambdabot> Maximum users seen in #xmonad: 39, currently: 32 (82.1%), active: 11 (34.4%)
19:09:56 * ddarius considers joining #xmonad, but probably won't.
19:11:05 <timthelion> dons, I'll write an tutorial, or essay, when I finaly map groking to actual syntax.  I mean I've only written two programs in Haskell that actually worked.  And often times, I find that their is no cat at all(putStr has no effect in many cases) and so I don't know that I'm really ready.
19:15:00 <qwr> putStr results in value - IO action. if the value is not used as component of IO action given as value of main, then it will be not executed...
19:16:14 <timthelion> hmm, so do putStr is not enough, I need to somehow "make the observation"
19:16:49 <mauke> IO x is a data structure representing a program
19:17:08 <mauke> you need to execute that program if you actually want it to do anything
19:17:20 <timthelion> but how do I do that?
19:17:24 <mauke> except you can't run it itself; you have to return it from main and let the haskell runtime do it
19:18:40 <mauke> your haskell program just constructs a single huge IO action, which is then run by the haskell runtime. or magic.
19:20:27 <qwr> to make things more interesting, the huge IO action is constructed lazyly like anything else in haskell ;)
19:21:15 <mauke> is it?
19:22:16 <timthelion> so I should write a type definition for main just to make sure everything lines up, but what would that be? what does main take?
19:22:37 <weitzman> main is not a function
19:22:49 <mauke> timthelion: main :: IO ()
19:22:51 <timthelion> Oh yes it is, if it ain't I quit
19:23:04 <weitzman> Don't quit!
19:23:07 <mauke> main is a constant
19:23:08 <sjanssen> you better quit then :)
19:23:25 <qwr> just a constant value ;)
19:23:25 <timthelion> mauke: what is the difference?
19:23:34 <mauke> timthelion: functions take arguments
19:23:45 <qwr> some might say it is zero-argument function
19:23:52 <timthelion> but then functions are just constants
19:24:00 <mauke> yeah, like 'x'
19:24:07 <timthelion> because one could say that the name of the function included an argument
19:24:43 <timthelion> ball, is not a function, red ball and blue ball, are two constants
19:24:44 <Cynos> Hi all, could someone please help me understand what the following type means?
19:24:50 <Cynos> *FirstCookie> :t cks
19:24:50 <Cynos> cks :: BrowserAction (BrowserAction [Cookie])
19:24:54 <timthelion> weitzman: it may be true, but it is meaningless to say
19:25:17 <weitzman> timthelion: Hmm?
19:25:29 <weitzman> timthelion: If you're actually responding to me, I think we disagree
19:25:40 <timthelion> as I said, a function is just a set of constants
19:25:48 <timthelion> we may
19:25:54 <Cynos> I know BrowserAction is a monad, an [Cookie] refers to a list of Cookie types, but it's the semantics of how they're combined that's got me.
19:25:58 <timthelion> disagreements exist in this world
19:26:24 <weitzman> Well, so first of all let us suppose that the idea of functions having side-effects is irrelevant as we discuss Haskell
19:27:15 <weitzman> Thus a "function" of no arguments does absolutely nothing but evaluate a constant the first time you refer to it
19:27:24 <weitzman> Then return the same constant in the future
19:27:42 <weitzman> I think a "function" is a silly name for something that static
19:28:06 <EvilTerran> call it a thunk, then
19:28:17 <weitzman> Sure, that's a good name. I like suspension too
19:28:35 <weitzman> But taking arguments, to me, is an important part of what a function is
19:28:46 <weitzman> When something has a side-effect but no arguments, I like to call it a method, perhaps?
19:28:47 <dolio> > let f ~() = 1 in f ()
19:28:52 <lambdabot>  1
19:28:58 <dolio> Is f a function?
19:29:17 <Pseudonym> > let f ~() = 1 in f undefined
19:29:18 <lambdabot>  1
19:29:22 <Pseudonym> > let f () = 1 in f undefined
19:29:23 <lambdabot>  Undefined
19:29:29 <jfredett> ... I got a job --, but i have to learn C...
19:29:32 <weitzman> I don't know what the ~() pattern match is doing, exactly
19:29:49 <Pseudonym> weitzman: It suspends the conformality check.
19:29:53 <EvilTerran> well, if it's got a side effect, it's an IO action
19:29:54 <Adamant> procedure is a better term, method usually implies OO
19:30:03 <jfredett> ahh- bittersweet employment! why must you tear me from the prettiness of FP!
19:30:17 <timthelion> weitzman: a function is just a set of constants, named after the function in combination with the arguments
19:30:17 <Pseudonym> Normally, for this rule to "fire", it needs to check that its argument is, indeed, a ().
19:30:17 <weitzman> Adamant: Ah, yes. You are right
19:30:18 <SamB> Adamant: or a class
19:30:22 <EvilTerran> (well, a monadit action)
19:30:29 <SamB> we use the term method to refer to things in classes here
19:30:29 <qwr> timthelion: value given to main does not do anything by itself. also it is not a haskell function.
19:30:30 <EvilTerran> *c
19:30:34 <SamB> probably some kind of pun
19:31:13 <timthelion> don't tell me ghc actually does something different for constants verses functions(other than maybe being more willing do memorize)
19:31:17 <EvilTerran> I tend to call side-effect-y stuff "actions" rather than "functions", anyway. i dunno if it's abuse of terminology, but people seem to understand me.
19:31:30 <SamB> timthelion: well, constants don't take arguments
19:31:51 <timthelion> SamB: it could be argued that function don't either. there's just more than one constant
19:32:11 <Adamant> a function is a procedure, a procedure is not necessarily a function, I think actions are procedures as well
19:32:28 <Adamant> unless this is C
19:32:54 <qwr> functions map argument values into another ones ;)
19:32:55 <Adamant> then it's all just "functions"
19:33:01 <timthelion> why would we speak of C? there is no difference but in the method of finding the result. and the method is not at question
19:33:11 <qwr> they don't do anything more
19:33:21 <Adamant> I'm talking nomenclature
19:33:32 <SamB_XP> yaawn
19:33:57 <weitzman> More importantly, whatever language you're using will define a function
19:34:10 <weitzman> And I'm pretty sure Haskell will use the work function to refer to something with an -> type
19:34:13 <weitzman> *word
19:34:33 * timthelion /ignore weitzman
19:34:41 <weitzman> It is, after all, a definitional issue
19:34:52 <SamB_XP> I think I even use it for nullary actions, for some reason
19:36:08 <qwr> timthelion: you get a mess if you call both IO actions and haskell functions functions in the context of haskell program
19:36:45 <qwr> they are different beasts
19:37:00 <timthelion> qwr, the argument was over whether main was a constant or a function like there was some kind of difference. I know that actions are different.
19:37:03 <kpreid> also, any sound taxonomy of Haskell entities must be able to classify maxBound
19:41:40 <timthelion> so the problem of course is that http://rafb.net/p/DYaqcY54.html doesn't do anything at all.
19:41:42 <lambdabot> Title: Nopaste - putStr don&#039;t work
19:42:19 <mauke> timthelion: o rly?
19:42:28 <mauke> timthelion: what happens when you run ./a.out; echo?
19:42:37 <dolio> timthelion: Are you sure it isn't being overwritten by your prompt?
19:42:39 * qwr . o O ( everything is constant in their scope... )
19:42:57 <timthelion> mauke: it works. wtf
19:43:08 <timthelion> when I echo afterwards
19:43:11 <timthelion> it works
19:43:14 <weitzman> Try "hi\n"
19:43:15 <timthelion> now I'm confused
19:43:32 <mauke> timthelion: your shell prompt overwrites stuff on the same line
19:43:39 <weitzman> or putStrLn "hi"
19:43:47 <timthelion> ok, so if I put \n it will wokr
19:43:50 <mauke> you can remove the hSetBuffering
19:44:25 <timthelion> wow, thanks, so it's not a bug in haskell, it's a (bug?) in my shell
19:44:31 <weitzman> It's not a bug exactly
19:44:36 <mauke> feature :-)
19:44:44 <mauke> I like \r in my PS1
19:47:00 <blackdog> i just googled "tail recursion javascript" and had a moment of clarity.
19:47:19 <mauke> what does the --user in 'runhaskell Setup.lhs install --user' do?
19:47:55 <hpaste>  qwr pasted "with getLine waiting you can look at the hi" at http://hpaste.org/146
19:48:00 <weitzman> I don't know, but I'd guess it's for people who don't have permission to write to the normal application data places
19:50:20 <mauke> hmm, xmonad also has it
19:57:09 <bos> mauke: it installs to your home directory, and updates your personal haskell package list.
19:57:31 <mauke> it does that anyway
19:57:37 <bos> some haskell compilers (ghc at least) maintain both a system-wide and per-user package list, and will check the user package list before the system one.
19:57:51 <mauke> because my ghc is in $HOME/usr/local
19:57:55 <chessguy> blackdog, what's so enlightening about that google search?
19:58:05 <bos> mauke: that's not the same thing.
20:03:13 <chessguy> hmm, can something be done equivalent to this in haskell? this is pretty
20:03:14 <chessguy> http://w3future.com/weblog/2006/02/
20:03:17 <lambdabot> Title: Sjoerd Visscher's weblog - w3future.com
20:07:32 <mauke> I don't think it looks pretty :/
20:08:01 <araujo> any haskell.org admin around?
20:08:40 <chessguy> mauke, well, the final ability to just optimize by adding .tailOptimized() is
20:09:14 <edwardk> chessguy: heh, i actually took that one step further and constructed an entire appel trampoline in javascript using that same trick. ;)
20:09:28 <chessguy> appel trampoline?
20:09:41 <edwardk> the trick that chicken scheme uses for blowing up the stack periodically
20:09:51 <chessguy> uhh
20:10:05 <edwardk> ok, the idea is this, javascript lacks tail call optimization right?
20:10:15 <chessguy> i have no idea what you're talking about, as usual, edwardk
20:10:18 <chessguy> :)
20:12:05 <edwardk> so what we do is we say, that we'll fake continuations by creating a 'trampoline' that will catch a thrown function and the arguments you expect to pass to it, then we'll keep track of how deep we've recursed using just continuations that can't return. when we go say 900 stack frames deep, we know that if we go too much deeper javascript will crash, so we throw the current function and its arguments out as an exception
20:12:11 <edwardk> er that probably got cut off
20:12:48 <edwardk> when we go say 900 stack frames deep, we know that if we go too much deeper javascript will crash, so we throw the current function and its arguments out as an exception, then catch them at the trampoline, and invoke that function with its arguments, so we kind of build up and tear down the stack over and over
20:12:51 <TSC> If I'm using cabal to run a preprocessor (alex), can I specify options to pass to it?
20:13:36 <edwardk> each time we blow up the stack makes a natural thread quantum, so you can do cooperative/pseudo-preemptive multithreading.
20:14:04 <chessguy> sounds interesting
20:14:05 <edwardk> the 'trampoline' is what that tailCallOptimized function is, it catches the exception, and re-executes.
20:14:16 <edwardk> in my case i just use it for continuations, not tail-calls
20:14:17 <chessguy> anyway, bedtime here. 'night all
20:14:49 <EvilTerran> thinking of tail-calls as continuation manipulation's an interesting thought, tho
20:15:52 <edwardk> works out nicely
20:15:53 <EvilTerran> (passing the continuation this fn was given, instead of the CC)
20:17:16 <edwardk> my chicken-scheme-like version is way faster than sjoerd visscher's tail call optimizer, because he pays the overhead every time it recurses back into itself. I pay it every few hundred function calls.
20:19:24 <Heffalump> wouldn't you just do what a normal tail call does and jump to the beginning, keeping the continuation in the same register/stack slot?
20:19:52 <edwardk> ganesh: if i had control over the execution environment, sure
20:20:48 <Heffalump> oh, right. I only started reading the Javascript context after responding to what EvilTerran said.
20:23:10 <edwardk> http://comonad.com/js/cps/Thread.js contains the appel trampoline stuff iirc
20:24:27 <ddarius> Beneath a Steel Sky is packaged for Ubuntu ?
20:24:53 <dolio> I prefer the ability to have tail call optimization by appending the empty string to my function definitions. :)
20:25:03 <edwardk> =)
20:25:26 <edwardk> ecmascript 4 bakes tail-call-optimization into the language specification as mandatory
20:25:44 <edwardk> thank you, Dave Herman.
20:25:44 <EvilTerran> doing that sort of thing in javascript's like working in intercal or sth, tho. you get a real sense of achievement from actually doing something useful.
20:34:35 <Cale> ddarius: I think so -- at least, it was in debian.
20:34:47 <Cale> let me check :)
20:34:58 <Cale> yep
20:35:41 <Cale> also, Flight of the Amazon Queen
20:43:07 * ddarius wonders if aspects of the book Spares was inspired by that game.
20:52:52 <magnus__> > fmap (\x -> x*x) (Right 3)
20:52:55 <lambdabot>  Right 9
20:53:24 <magnus__> Hmm, so it works on lambdabot. Why does that not work on my GHC?
20:55:11 <magnus__> I get "No instance for (Functor (Either a))" on my local ghci
20:56:01 <shachaf> magnus__: :m + Control.Monad.Instances
20:56:14 <magnus__> Thanks schachaf!
20:56:19 <magnus__> shachaf
20:57:01 <magnus__> yeah, now it works
21:03:02 <fuzan> why does the debian ghc6 package use gcc version 2.x ?
21:05:40 <sorear> fuzan: how old is your ghc?
21:10:55 <fuzan> sorear: this is a fresh install of debian, and it says 6.6r3?
21:11:48 <sorear> 6.6r3 doesn't make sense
21:11:55 <sorear> fuzan: debian what?
21:12:24 <fuzan> etch?
21:12:27 <fuzan> i'm not really sure.
21:12:27 <fuzan> heh
21:12:34 <fuzan> just installed of netinst 4.0 cd
21:12:58 <fuzan> gcc 4.1.2 is installed, it appears
21:14:07 <sorear> ghc -V ?
21:14:15 <fuzan> ghc's not installed.
21:14:21 <fuzan> not yet, at least
21:15:11 <fuzan> ah, installing g++ first and then ghc satisfies the gcc/g++ deps
21:16:44 <dcnstrct> hi guys.  a n00b here.  I'm looking for a function which will tell me if a given string is contained within another string.   so something like contains :: String -> String -> Bool
21:17:02 <sorear> isInfixOf
21:17:27 <dcnstrct> bingo
21:17:28 <dcnstrct> you the man
21:31:55 <Administ2ator> do anyone think haskell is a full replacement for perl?
21:32:15 <Adamant> for what?
21:32:20 <xpika> full
21:32:24 <xpika> well
21:32:30 <xpika> text jobs and scripting
21:32:47 <sorear> @goo Haskerl
21:32:53 <lambdabot> http://www.dcs.gla.ac.uk/~partain/haskerl.html
21:32:53 <lambdabot> Title: The Haskerl index
21:33:38 <Korollary> it's hard to replace a language that has regex syntax burnt in
21:33:48 <dmead> dons seems to think it is
21:34:00 <dmead> he wrote those tutorials last year
21:34:14 <Korollary> if you use parsec instead of regexes and splits, then it's better.
21:34:18 <dons> i don't argue it is a full replacement for perl. but more that you shouldn't use perl for anything larger than 50 lines.
21:34:23 <dons> nor regexes.
21:34:33 <dmead> ah
21:34:35 <dons> since neither perl nor regexes are easily maintainable.
21:34:42 <dmead> :)
21:35:03 <dmead> isn't python a decent perl replcement?
21:35:21 <dmead> *full replacement
21:35:49 <Korollary> probably
21:35:57 <c_> nope
21:36:04 <c_> not enough syncractic sugar
21:36:26 <stepcut> Haskell has HARP, but I have never used it
21:36:42 <Korollary> perl's syntactic sugar is not all great sugar, either.
21:36:45 <c_> isnt perl6 prototyped in haskell? maybe theres a full functional definition of all perl5's syntactic inanities, or are they not carrying those forward?
21:37:14 <stick_figure> How do I recover from a list monad "failure"?  It returns a "zero"?
21:37:23 <Heffalump> mplus
21:37:29 <Heffalump> well, there's lots of ways
21:37:41 <Heffalump> mplus is one way of catching it and providing an alternate computation
21:37:50 <Heffalump> another is to leave the monad and explicitly look for []
21:38:10 <stick_figure> Heffalump, what does it return if the procedure fails?
21:38:19 <Heffalump> actually, sorry, mplus will add extra stuff even if the first thing doesn't fail
21:38:22 <Heffalump> what does what return?
21:38:35 <Heffalump> the list monad just passes around a list of results
21:38:46 <Heffalump> if the list is [], that indicates failure (at some level)
21:38:47 <fuzan> hey -- any debian users here?
21:38:50 <Heffalump> me
21:39:00 <Heffalump> and I don't know about gcc 2.x
21:39:05 <fuzan> Heffalump: how do you usually get hte source of stufF?
21:39:14 <Heffalump> I think I have ghc6-libsrc installed
21:39:26 <fuzan> Heffalump: i'm trying to install Graphics.X11, yet, it says there's no X11 source availble
21:39:34 <Heffalump> libx11-dev ?
21:39:40 * Heffalump is guessing
21:39:55 <stick_figure> Heffalump, so if you go do xs <- a_list return 1 it basically returns a new list of 1's of length of a_list?
21:39:57 <fuzan> are *-dev packages only src?
21:40:01 <sorear> fuzan: libghc6-x11-dev
21:40:02 <Heffalump> apt-cache search x11 | grep dev
21:40:31 <Heffalump> stick_figure: yes
21:40:43 <Heffalump> assuming you had a ;  or newline between a_list and return 1
21:40:52 <Heffalump> fuzan: they're the headers, but that's probably what you need
21:41:22 <Heffalump> haskell dev packages (like the one sorear said) are a bit different cos of the way Haskell linkage works
22:24:51 <dmwit> > map (const 1) [3..7]
22:24:59 <lambdabot>  [1,1,1,1,1]
22:25:50 <magnus__> @pl a >>= (return . b)
22:25:50 <lambdabot> b `fmap` a
22:26:57 <edwardk> ok, dumb question, i'm moving over to visual haskell for a week because i'll be at a conference, what is a good #ifdef to check for windows in the c preprocessor under visual haskell with -cpp?
22:29:10 <mauke> depends on the preprocessor
22:29:27 <sieni> #ifdef WIN32 perhaps?
22:29:27 <mauke> check the usual suspects: __WIN32__, __WIN32, _WIN32
22:29:38 <xpika> is there any tutorial on using haxml?
22:30:20 <edwardk> checking the various __'d versions
22:31:33 <edwardk> tried WINDOWS WIN32 __WIN32__ __WIN32 _WIN32, __MSVC
22:31:56 <Korollary> doesnt visual haskell still use gcc?
22:32:00 <edwardk> mauke: in this case whichever one visual haskell uses =)
22:32:06 <edwardk> kor: no idea actually
22:32:59 <mauke> if it does, echo | cpp -dM | grep -i win
22:35:17 <edwardk> mauk: windows, echo, grep? ;) did find gcc.exe though, looking up the flags to get it to act like cpp
22:38:15 <edwardk> bah, the gcc in the visual haskell dir is buggered if you just try to run it directly, it can';t find anything
22:39:44 <edwardk> lovely, no platform specifics except __VERSION__ "3.2.3 (mingw special ...)"
22:41:41 <edwardk> (my current codebase requires libidn to do nfkc normalization on unicode strings, i was hoping to not rewrite that)
22:42:15 <edwardk> i was just going to stub it out for windows, but i can't seem to detect that i'm in windows
22:46:57 <edwardk> gave up and inverted the probem so i can control it, defaulting to assuming idn is unavailable, then tagging the platform when it is ;)
22:47:02 <edwardk> *sigh*
22:47:32 <ivanm> dons: with lambdabot, is it the correct behaviour that she won't detect you're online and thus inform you of messages if you're only passing her commands like @yarr!! ?
22:54:36 <dons> ivanm: well, there's no spec, so 'correct' is hard to say ;)
22:54:48 <ivanm> heh
22:54:58 <ivanm> fair enough
22:55:08 <ivanm> let me rephrase that question then...
22:55:41 <ivanm> with lambdabot, is she currently set up so that she won't detect you're online and thus inform you of messages if you're only passing her commands like @yarr!! ?
23:03:36 <lambdabot> I thought I heard the chirping of crickets.
23:04:19 <dons> she won't detect it. yes.
23:04:59 <dons> commands are filtered out from the contextual information other plugins use to track people's activity
23:05:53 <ibid> and even if that weren't the case, a person can be online without writing anything to a channel for days
23:06:48 <ivanm> *nod*
23:07:43 <ibid> (speaking as one who got lambdabot messages days later than necessary because i wasn't talking on #haskell)
23:17:58 <dons> darcs release 1.0.9 is out
23:18:13 <sorear> hurray!
23:18:37 <c_> git it while its hot
23:18:44 <earthy> *groan*
23:19:17 <sorear> 17:17 -!- Cale [n=cale@CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com] has quit [Remote closed the connection]
23:19:20 <sorear> 17:18 -!- Cale [n=cale@CPE004854805910-CM000e5cdd834a.cpe.net.cable.rogers.com] has joined #haskell
23:19:26 <sorear> ivanm, ibid: ^^^ that's why
23:21:17 <earthy> no announcement for 1.0.9, is there
23:22:21 <dons> earthy: [darcs-users] darcs release 1.0.9
23:23:08 <earthy> ah, not on the wiki yet then
23:34:38 <edwardk> is there any special bindings in visual haskell to generate haddock?
23:34:45 <edwardk> s/is/are
23:34:53 <earthy> the same ones that cabal uses...
23:35:05 <earthy> IIRC
23:35:14 <edwardk> k, was just curious if there was a quick keybinding or something goofy
23:35:28 <earthy> I'll ask the only other user of visual haskell that I know if I seem him today
23:35:32 <edwardk> k
23:35:33 <earthy> -m
23:36:02 <edwardk> this is my second or third time trying to bring myself to care about it, primarily because i'll have a long flight in a couple of hours and won't have access to my usual dev box ;)
23:36:19 <edwardk> so i figure i might as well learn how to use it, and maybe just use it for the whole trip
23:39:11 <Adamant> is there Haskclipse yet?
23:39:38 <scodil> are there any good docs/tutorials on understanding the output of -ddump-simpl?
23:40:45 <edwardk> http://eclipsefp.sourceforge.net/haskell/
23:40:46 <lambdabot> Title: Haskell support in Eclipse
23:42:37 <edwardk> doesn't exactly appear maintained though, ~2005 start and last update
23:43:59 <sm> good evening all!
23:45:06 <sm> I've been playing with haskell sdl (& opengl, a little)
23:45:30 <sm> I want to find out if it's possible to make fast simple graphical games with haskell
23:46:13 <notsmack> sm: any reason it wouldn't be?
23:46:23 <sm> I would love to compare notes or pair program, if anyone out there is interested
23:46:38 <sm> http://joyful.com/darcsweb/darcsweb.cgi?r=hbreakout;a=headblob;f=/breakout.hs is my current prototype
23:46:53 <lambdabot> Title: darcs - hbreakout, http://tinyurl.com/2ayc9x
23:47:08 <sm> notsmack: I've noticed underwhelming performance so far.. I'm sure the reasons are many
23:47:47 <sm> also, I wonder why such games have not yet appeared.. there must be things getting in the way
23:48:42 <sm> the above just bounces a ball around, with a bat
23:49:05 <sm> the first problem is, it's really irregular
23:49:51 <sm> I don't have a real-time OS here, but still I'd like to see if I can make something run somewhat smoothly
23:50:05 <edwardk> sm: some thoughts
23:50:10 <notsmack> have you tried to profile it?
23:50:18 <sm> the way my vic-20 games used to!
23:50:19 <edwardk> sm: try adding strictness anotations to a lot of the game state
23:50:36 <sm> notsmack: no, that would be a good next step
23:51:09 <sm> edwardk: could you explain briefly why that will help ? I imagined I have only a little state here
23:51:25 <sm> I have noticed that cpu usage keeps going higher as this runs :)
23:51:55 <edwardk> sm: if you buid up a bunch of say, position + 10 thunks before you inspect it, it will have to collapse (position + 10) + 10) + 10) + ...
23:52:06 <edwardk> each game state update will do that to you
23:52:34 <sm> what would qualify as inspecting it ? rendering to the SDL screen, no ?
23:52:39 <edwardk> the strictness annotation eliminates a lot of potential for things to go wrong of that sort
23:52:48 <sm> I see.. I'll read up on those
23:53:41 <edwardk> as a quick test, just take Game, Bat and Ball, real quick and stick ! after each of the fields, like data Game = Game { running :: !Bool, screenw :: !Int, } ...
23:54:14 <edwardk> another thought, is to break up what will change from what won't change, separating the environment from the state. every time you modify your state you make a copy of all of it
23:54:50 <edwardk> if you have a separate environment of immutable things like screen widths, etc. then it won't have to be copied from game-state to game-state every time you tweak the bat or ball.
23:55:14 <Excedrin> sm: have you seen Frag?
23:55:41 <Excedrin> sm: http://haskell.org/haskellwiki/Frag
23:55:42 <lambdabot> Title: Frag - HaskellWiki
23:56:11 <edwardk> implementing those changes should stop your gradual slowdown and initial speed issues.
23:56:28 <sm> ok, I'll try that first
23:56:30 <edwardk> frag does things another way base on functional reactive programming, which is a bit more advanced
23:56:43 <notsmack> sm: you may want to look into ST or similar mutable values, i'd suspect, though i haven't played with that too much
23:56:59 <sm> I'm also interested, very much so, in finding good ways to program this stuff functionally
23:57:13 <Excedrin> Frag answers the question, "[is it] possible to make fast simple graphical games with haskell"
23:57:21 <sm> it's been quite hard thinking, I assume it can get easier
23:57:30 <edwardk> sm: then in that case look into things like Yampa and functional reactive programming. that tends to be the 'right' way to implement this functionally
23:57:43 <edwardk> at least insofar as right means 'fast' =)
23:57:45 <notsmack> sm: also, have you seen the paper about space invaders and FRP?
23:58:02 <sm> notsmack: hmm yes, I'll look again
23:59:36 <sm> I am craving OO for these game objects.. what I'm doing now doesn't seem so scalable
