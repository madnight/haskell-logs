00:12:25 <dons> lovely wikibook article on the Cont monad, http://programming.reddit.com/info/20mu8/comments
00:12:27 <lambdabot> Title: Continuation passing style and continuations as monads (reddit.com)
00:23:50 <dolio> @djinn Cont r a -> (a -> Cont r b) -> Cont r b
00:23:50 <lambdabot> f a b c = a (\ d -> b d c)
00:25:42 <DRMacIver> Morning
00:26:30 <dons> @unmtl Cont r a -> (a -> Cont r b) -> Cont r b
00:26:30 <lambdabot> err: No applications
00:26:39 <dons> @mtl Cont r a -> (a -> Cont r b) -> Cont r b
00:26:39 <lambdabot> Maybe you meant: ft map msg pl unmtl url
00:27:41 <dolio> @. type djinn Cont r a -> (a -> Cont r b) -> Cont r b
00:27:44 <lambdabot> parse error on input `='
00:28:27 <dons> :t let f a b c = a (\ d -> b d c) in f
00:28:30 <lambdabot> forall t t1 t2 t3. ((t -> t1) -> t2) -> (t -> t3 -> t1) -> t3 -> t2
00:28:40 <dons> ?pl f a b c = a (\ d -> b d c)
00:28:40 <lambdabot> f = (. flip) . (.)
00:28:47 <dons> haskell is soo cool
00:28:54 <dons> :t (. flip) . (.)
00:28:56 <lambdabot> forall a b c c1. ((a -> c) -> c1) -> (a -> b -> c) -> b -> c1
00:29:35 <dolio> Is that right?
00:29:54 <dolio> I guess so.
00:30:11 <dons> looks right
00:30:37 <dolio> @djinn ((a -> Cont r b) -> Cont r a) -> Cont r a
00:30:37 <lambdabot> f a b = a (\ c _ -> b c) b
00:30:49 <dolio> @src Cont callCC
00:30:49 <lambdabot> callCC f = Cont $ \c -> runCont (f (\a -> Cont $ \_ -> c a)) c
00:31:11 <dons> nice
00:31:52 <dons> i think lambdabot might be the only irc bot that derives callCC on a regular basis
00:32:13 <dons> unless the bot in #php does too, not sure.
00:32:21 <dolio> Heh.
00:32:37 <dolio> I was going to suggest #scheme, but I guess they take it for granted.
00:32:51 <dons> yeah, wired in :-)
00:35:10 <dons> we should have a delimited continuatoin framework readily available
00:35:16 <dons> and a standard comonad library
00:37:37 <dons> i'd like to write a fast binding to openssl too
00:37:53 <dons> hmm. we really should have a library 'todo' list, for bored weekend programmers
00:38:03 <dolio> That's not a bad idea.
00:38:39 <dons> mmm yes. ok. i'll draft up a wikipage. we did have a suggestions page, but perhaps it needs to be more obvious
00:38:43 <dons> and cross referenced with hackage.
00:38:55 <dolio> Delimited continuations should be 'trivial'. You just have to pick between the several different papers Oleg's implemented them in. :)
00:38:58 <dons> or even hosted on hackage. categories, whether there's a library for them or not, and so on
00:39:04 <dons> dolio: exactly.
00:39:17 <dons> oleg doesn't write cabalised code though :(
00:39:28 <dons> and the delimited cont stuff has been mostly in ocaml, so needs transpoing
00:39:44 <dons> we should have zippers for core data types too
00:39:49 <dons> like [a] , Tree and some others
00:40:08 <dolio> His latest paper was haskell-esque, I think. The one about modelling operating system semantics.
00:40:28 <dons> ah yes, based on the zipperFS/OS haskell workshop demo
00:40:32 <dolio> Although I don't remember how complete his implementation was in there. He may have just assumed they were written.
01:05:58 <araujo> hello
01:06:03 <araujo> darcs.net down?
01:09:33 <Vq^> araujo: seems so
01:09:44 <araujo> thanks Vq^
01:11:53 <hpaste>  dankna pasted "I think I will understand this type error if I stare at it long enough, but..." at http://hpaste.org/378
01:12:17 <dankna> Newbie question.  I'm trying to use a case expression inside a do expression, as shown in the above snippet.
01:12:39 <dankna> how? :)
01:13:50 <oerjan> dankna: the right sides of the case must be IO () expressions
01:14:04 <dankna> and, as far as I can tell, are.
01:15:35 <dankna> yeah, that snippet uses functions you don't have the definitions for; it seemed like the question didn't really require putting together a reduced example - or at least like my time would be better spent looking for inspiration from within than doing that :)
01:15:56 <oerjan> it seems like it is expecting IO (IO ()) somehow
01:16:27 <dankna> hrm.
01:16:57 <oerjan> i really think we need the types for the missing functions.
01:17:05 <dankna> okay, one sec
01:17:15 <araujo> dankna, what is the type of drawArc?
01:17:30 <oerjan> and drawLine
01:17:59 <dankna> well, can't load this into ghci for some reason (probably because of the external C library dependency) but I can get you their declared types, which ought to be as good.  one sec.
01:18:16 <olsner> your x <- return y could also be written let x = y to better show what's monadic and what's not
01:18:24 <hpaste>  dankna annotated "I think I will understand this type error if I stare at it long enough, but..." with "(no title)" at http://hpaste.org/378#a1
01:18:50 <dankna> yeah, I kept wanting to do that at first, olsner, but I couldn't figure out the grammar for that, either :)
01:19:09 <dankna> and it wasn't as important because it doesn't improve the readability all that much.  this situation is though.
01:19:30 <dankna> obviously since these are my first steps with the language, I'm going to write a lot of code that I'll be really embarrassed about later; I've already accepted that :)
01:20:18 <araujo> dankna, and the drawCell? :-)
01:20:20 <Vq^> dankna: what type is drawCell ?
01:20:25 <dankna> oh!  sorry
01:21:45 <hpaste>  dankna annotated "I think I will understand this type error if I stare at it long enough, but..." with "drawCell type decl now at the top" at http://hpaste.org/378#a2
01:21:45 <treble> dankna: your drawline is missing a drawing argument?
01:22:00 <dankna> hmm...
01:22:09 <dankna> oh!
01:22:14 <treble> PlusPiece -> drawLine drawing...
01:22:27 <dankna> but I commented that line out already in my test version, heh.  but good catch.
01:22:39 <dankna> hmm
01:22:56 <dankna> one sec
01:23:05 <oerjan> ah! it believed it was in the -> monad
01:23:21 <dankna> -> is a monad?  heh!  sounds profound
01:23:53 <oerjan> it can be, there is a definition in a module somewhere
01:24:00 <dankna> ah-hah
01:24:02 <dankna> I see what happened
01:24:16 <araujo> dankna, drawLine misses an argument
01:24:16 <dankna> it gives me a much more informative error message now that I have the type declaration for drawCell
01:24:19 <dankna> I had been letting it infer that
01:24:28 <Philippa> -> isn't itself. A partial application of it is
01:24:29 <dankna> so it gave me a misleading message about drawArc instead, the next call after the erroneous one
01:24:44 <dankna> moral of the story, use type declarations, heh
01:24:51 <dankna> well, thank you, all
01:25:02 <dankna> Philippa - hm.  Not sure I get that.
01:25:26 * araujo recommends to learn monads using the monadic operators
01:25:30 <oerjan> this probably shows why it is a good idea _not_ to define the e -> monad directly.
01:25:45 <dankna> well, I think I understand how the monadic operators relate to the do notation, actually
01:25:52 <treble> > ( do { a <- succ; b <- pred; return (a,b) } ) 7
01:25:54 <lambdabot>  (8,6)
01:25:59 <dankna> for me the key revelation was that to make a type into a monad you have to define >>= for it
01:26:09 <dankna> (among whatever other stuff there is)
01:26:40 <olsner> how do you use lambdabot to see the implementation of e.g. >>= for different monads?
01:26:54 <oerjan> @src -> >>=
01:26:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
01:27:00 <treble> ?src Maybe >>=
01:27:00 <oerjan> @src -> (>>=)
01:27:00 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
01:27:00 <lambdabot> Source not found. My pet ferret can type better than you!
01:27:05 <Igloo> dons: ?
01:27:09 <treble> something like that :)
01:27:19 * dankna is amused
01:27:19 <olsner> @src (->) (>>=)
01:27:19 <lambdabot> f >>= k = \ r -> k (f r) r
01:27:21 <olsner> found it!
01:27:32 <oerjan> olsner++
01:27:56 <olsner> @pl \ r -> k (f r) r
01:27:56 <lambdabot> k =<< f
01:28:23 <dankna> hrm
01:28:41 <cinimod> @where bitSize
01:28:41 <lambdabot> I know nothing about bitsize.
01:28:51 <oerjan> that @src instance method  syntax is really awkward.  i never know whether i have got it wrong or whether lambdabot really doesn't have a particular source.
02:30:04 <olsner> @type promptP
02:30:06 <lambdabot> Not in scope: `promptP'
02:31:37 <olsner> @type liftIO
02:31:40 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
03:00:38 <guenni> hi, does anybody know if "Introduction to functional programming using Haskell" is available as a PDF?
03:20:18 <Baughn> guenni: No
03:32:13 <guenni> Baughn: damn
03:32:33 <Baughn> guenni: Visit a library. Take a remote loan. Ask questions here instead.
03:33:14 <guenni> Baughn: take a remote loan?
03:33:49 <guenni> what's that
03:33:59 <Baughn> guenni: Even if your local library doesn't have a copy, it should be able to get one from another library
03:34:09 <guenni> ok, sry
03:34:14 <Baughn> guenni: Depending on country. Norwegian libraries do so, at least.
03:34:37 <Vq^> swedish too
03:34:47 <guenni> well if you tell me it's good, I'll just order it from amazon
03:35:44 <Baughn> Can't say, but I liked the haskell school of expression.
03:35:50 <Baughn> guenni: MOre generally, readhttp://haskell.org/haskellwiki/Books_and_tutorials
03:35:51 <lambdabot> Title: Books and tutorials - HaskellWiki
03:35:58 <guenni> I have that one too
03:39:53 <rashakil> hash table lookups really have Omega(log n) access time when measuring access time of the worst performing key of n-element hash tables, don't they
03:41:11 <Cale> rashakil: The worst case lookup time for hashtables is O(n)
03:41:33 <rashakil> Cale: yes
03:43:01 <rashakil> Cale: I'm talking about measuring the worst performing key across all tables
03:43:13 <rashakil> even nice-looking ones
03:43:26 <Cale> ah
03:44:00 <rashakil> since the key size is necessarily of log(n) size
03:48:29 <Heffalump> the O(log n) is only really relevant if the keys become bigger than a word, though
03:48:36 <rashakil> shhhhh
03:48:46 <Baughn> rashakil: Keys are typically small enough to be considered of constant size / hash time is irrelevant to lookup time, but technically you're right
03:48:53 <Heffalump> up to that point it'll scale fairly linearly, with a big bump as you overfill each cache
03:49:20 <Baughn> rashakil: If that isn't the case, you really should be using a trie or something instead
03:51:27 <Heffalump> IM scale fairly constantly
03:52:18 <Cale> Heh, when you get right down to it, if you assume that the universe has finite information density and that information can't travel faster than the speed of light, all lookups take at least O(n^(1/3)) time.
03:52:32 <rashakil> yeah, you've said that :-)
03:52:36 <Cale> hehe
03:52:56 <Baughn> Cale: Now you're assming it's three-dimensional. A fractal architecture, with wormholes, could do a lot better.
03:54:08 <Cale> hehe
03:54:20 <Cale> Yeah, I suppose I'm also assuming that your computer doesn't have a wormhole inside it :)
03:54:29 <Baughn> *A* wormhole?
03:54:35 <Baughn> I'm referring to wormtronics.
03:54:47 <Cale> Well, if it doesn't have one, it can't have more than one :)
03:55:17 <Baughn> Are you sure that particular piece of math applies to physical reality? ^_^
03:56:14 <Cale> No :)
03:56:48 <Cale> However, I don't expect I'd personally make use of a system where that wasn't true :)
03:58:11 <rashakil> well at some point you've got to assume we can have CPU density equal to memory density and finagle our algorithms around that restriction
03:58:52 <Baughn> rashakil: O(n) sorting algorithms and whatnot?
03:59:05 <rashakil> of course at large enough sizes you have to take into account gravity and the structural limitations of your material
03:59:39 <rashakil> Baughn: sure, bring back bubblesort
03:59:49 <Baughn> rashakil: That's n^2..
04:00:30 <rashakil> not when you have one processor for every three memory cells
04:00:33 <Baughn> As for gravity, you can counteract it by having your computer components stay in free-fall, orbiting itself
04:01:06 <Baughn> Oh, right. I think I've seen a more efficient solution, but.. meh, that works.
04:01:46 <rashakil> but then you're down to two dimensional computers
04:02:18 <Baughn> Only in the simplest orbitals. You can perfectly well have a three-dimensional one, it just gets annoyingly hard to design.
04:02:49 <rashakil> oh right
04:02:52 <Baughn> (And possibly it'll require continual adjustment. Getting the computational power for that should not be an issue.
04:04:18 <int-e> but if they're orbiting they'll emit gravitational waves slowly losing energy nad eventually collapsing ;)
04:04:41 <Baughn> That's only for an *unpowered* computer. Why would you want that?
04:06:32 <Baughn> Remember, this thing is self-orbiting; presumably components continually pass within micrometers of each other at very high speeds, to get fast memory access and whatnot. It should be possible to use electromagnets to adjust the orbits and keep it up. ;)
04:07:10 <Baughn> (Just don't ask me to design or build it)
04:09:52 <rashakil> are you sure there's the amount of free-fall pellets you can fit in a sphere without collisions is O(r^3)?
04:10:28 <Baughn> rashakil: Quite sure. If nothing else, by changing orbits continually.
04:10:48 <Baughn> That isn't quite free-fall, granted
04:10:59 <rashakil> yes, but you are also limited in the force you can put on any particle
04:11:54 <DRMacIver> Remind me why you're building this in freefall rather than solid?
04:12:43 <rashakil> if you don't, the memory/processors in the middle will not survive
04:12:45 <Baughn> DRMacIver: To avoid gravitational collapse
04:14:51 <DRMacIver> I think if you have enough mass to cause graviational collapse, you have much bigger problems.
04:15:03 <rashakil> well yeah, that's why you need so much computational power
04:15:11 <Baughn> To solve the problems
04:15:19 <DRMacIver> In particular heat dissipation, which sticking your components in a vacuum surrounded by other components radiating just as much memory is going to aggravate. :)
04:15:23 <Baughn> Actually, I was thinking "as habitat"
04:15:26 <DRMacIver> s/memory/energy/
04:16:04 <rashakil> surely we can orbit in and out some radiation sinks
04:16:32 <Baughn> If not, heat-sink "lasers" would work
04:16:36 <DRMacIver> And I think you're only gaining a constant factor here, at the cost of significant communication time increase.
04:16:52 <Baughn> DRMacIver: It's the megacity of the future
04:17:01 <Baughn> Room enough for 10^90 AIs!
04:17:03 * int-e would expect the whole thing to evolve into a black hole soon anyway
04:17:21 <DRMacIver> int-e: Hence "only gaining a constant factor" :)
04:17:40 <DRMacIver> Anyway.
04:17:41 * DRMacIver goes back to trying to figure out mutt.
04:17:44 <Baughn> int-e: I considered the consequences of making it large enough that it would necessarily look as a black hole from the outside, but decided that before that point some components would be orbiting faster than light, so it isn't an issue
04:19:07 <Baughn> Of course, I haven't accounted for frame dragging. Hmm...
04:20:13 <rashakil> if you take cosmic expansion in account (if that truly exists) then you could avoid the gravity problem
04:20:50 <Baughn> There are limits to lag
04:21:19 <Baughn> Also, if it's accelerating, that means you can only avoid the gravity problem for a split second. After that, it flies apart.
04:22:21 <rashakil> The set of planets with boilable oceans is rather evenly distributed about the universe, right?
04:22:38 <Baughn> That's the common assumption, yes
04:28:08 <hpaste>  fasta pasted "Why does this type gets derived (Complete code can easily be loaded)" at http://hpaste.org/379
04:29:26 <Heffalump> fasta: what are you confused about?
04:29:41 <fasta> Heffalump: there is a question at the bottom
04:29:50 <Heffalump> I read that, but I don't understand the confusion.
04:30:04 <Heffalump> the let clause constrains b's type
04:30:09 <Heffalump> which indirectly constrains k's type
04:30:10 <fasta> Heffalump: I don't understand why s restricts the context in the way it does
04:30:36 <fasta> Heffalump: I do understand that it restricts it, but I don't see why it restricts it in this particular way
04:30:43 <Heffalump> it's just substitution, isn't it?
04:30:59 <Heffalump> the type on the left is the type on the right with a replaced by Z [Char]
04:31:03 <Heffalump> (and chain renamed to t1)
04:31:28 <Heffalump> oh, and b has become ()
04:31:56 * Heffalump tries to understand that
04:32:19 <fasta> Heffalump: All I say is that given type a, b is determined.
04:32:47 <fasta> Heffalump: and a is known, but for b there is no instance.
04:33:09 <fasta> Heffalump: AFAIK, () is not known nor derivable in any way, but I might very well be wrong.
04:33:34 <Heffalump> yeah, I can't see where that's come from either
04:33:45 * Heffalump --> play
04:34:00 <Heffalump> does glasgow-exts imply the new defaulting rules?
04:34:19 <fasta> Heffalump: what new defaulting rules? This is on 6.6.1, btw
04:34:36 <Heffalump> I think () gets included at the beginning of the list of defaultable types
04:35:10 <fasta> Any documentation for this odd feature?
04:35:23 <Heffalump> it's intended to make show [] work
04:35:31 <fasta> Heffalump: AFAIK, that only works in ghci
04:35:33 <Heffalump> and, errm, I guess so.
04:36:47 <Heffalump> if you deliberately give the more general type it typechecks
04:37:06 <fasta> What a gigantic misfeature.
04:37:11 <Heffalump> and note that b isn't free in the type
04:37:15 <Heffalump> so I think it's defaulting
04:37:39 <Heffalump> however, the fundep makes that rather silly
04:37:45 <Heffalump> since b could be determined later by fixing a
04:37:53 <fasta> b is not free?
04:37:55 <fasta> Why?
04:38:12 <Heffalump> it doesn't appear in the type
04:38:16 <Heffalump> it just appears in the constraint
04:38:26 <Heffalump> so, fundep aside, nothing could ever cause it to be fixed to a particular concrete type
04:38:33 <Heffalump> it's like writing Show a => String
04:39:30 <fasta> Heffalump: do you think this is a bug?
04:39:48 <Heffalump> it seems wrong to me, but I'm not an expert.
04:40:04 <Heffalump> I think it's worth asking glasgow-haskell-users about
04:44:27 <fasta> Heffalump: suppose there is an instance Zork s String Int, why wouldn't b be Int then?
04:44:36 <Heffalump> I'm just playing with that, hangon
04:44:53 <Heffalump> you mean Z String, not String
04:45:29 <Heffalump> ahah, here's some interesting behaviour
04:45:32 <Heffalump> instance Zork s (Z [Char]) Int
04:45:39 <Heffalump> stick that in the same module as your code, and it type checks fine.
04:46:08 <fasta> Heffalump: yes, indeed I meant that.
04:46:16 <Heffalump> stick it in a different module and import your existing one, and looking at type of foo results in a type error
04:57:24 <Saizan> "looking"? so not a compile time?
05:01:34 <Heffalump> well, in ghci I only get the errof rom :t foo
05:01:43 <Heffalump> s/errof rom/error from/
05:33:12 <cinimod> @seen shapr
05:33:12 <lambdabot> shapr is in #haskell. I last heard shapr speak 16h 44m 20s ago.
05:34:25 <cinimod> Can someone point me at the code that handles bitfields using template haskell?
05:59:18 <xho> are there any image libraries for haskell, for loading images and manipulating them?
05:59:46 <beelsebob> I have a library for manipulating pdfs
05:59:49 <beelsebob> but not loading them yet
06:00:08 <fasta> @where libraries
06:00:09 <lambdabot> I know nothing about libraries.
06:00:18 <xho> hm... SDL_image might work
06:00:24 <fasta> xho: there is a list on the wiki
06:00:37 <fasta> xho: but it might be an empty list ;)
06:02:49 <fasta> xho: GTK2HS probably has something too
06:04:12 <xho> that might be a bit too much for my needs
06:18:23 <xho> is there a haskell interface for dlopen?
06:28:50 <Lemmih> @index dlopen
06:28:50 <lambdabot> System.Posix.DynamicLinker
06:32:36 <notadev> > map \x= x*x <- [1..5]
06:32:36 <lambdabot>  Parse error
06:32:39 <notadev> meh
06:32:54 <notadev> > map (\x= x*x) <- [1..5]
06:32:55 <lambdabot>  Parse error
06:33:01 <notadev> > map (**) <- [1..5]
06:33:01 <lambdabot>  Parse error
06:33:05 <notadev> > map (**) [1..5]
06:33:08 <lambdabot>  [<Double -> Double>,<Double -> Double>,<Double -> Double>,<Double -> Double>...
06:33:26 * notadev scratches head and looks foolish
06:33:30 <Baughn> > map (^ 2) [1..5]
06:33:33 <lambdabot>  [1,4,9,16,25]
06:33:34 <notadev> ah
06:33:39 <notadev> thanks Baughn
06:33:44 <Baughn> notadev: ** takes /two/ arguments, and map only passes it one
06:33:49 <notadev> ahh
06:33:54 <Baughn> notadev: Both ^ and ** would work, by the way
06:34:01 <Baughn> (But ^'s exact)
06:34:04 <notadev> so how does one use \ there.. oh?
06:34:18 <Baughn> > map (\x -> x*x) [1..]
06:34:18 <notadev> yeah i prefer ^ notation
06:34:19 <lambdabot>  [1,4,9,16,25,36,49,64,81,100,121,144,169,196,225,256,289,324,361,400,441,484...
06:34:23 <notadev> excellent!
06:34:52 <Baughn> :t join
06:34:55 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:35:04 <Baughn> ..urk
06:35:18 <notadev> :t map
06:35:19 <int-e> > (2 :: Rational) ^^ (-8)
06:35:20 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
06:35:22 <lambdabot>  1%256
06:35:26 <Baughn> @djinn (a -> a -> b) -> (a -> b)
06:35:26 <lambdabot> f a b = a b b
06:35:33 <Baughn> @. pl djinn (a -> a -> b) -> (a -> b)
06:35:33 <lambdabot> f = join
06:35:35 <notadev> wtf is djinn?
06:35:48 <int-e> djinn is a genie that conjures up code
06:35:52 <notadev> hehe
06:35:57 <Baughn> notadev: It makes up functions that match a type signature. Very primitive, but it does know things I don't
06:36:12 <notadev> oic wow
06:36:23 <Baughn> Using join like that... there's the (->) monad, I guess. Haven't looked at that.
06:36:29 <int-e> technically it's a theorem prover for intuitionistic logic I think.
06:36:31 <DRMacIver> :t join
06:36:33 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
06:36:42 <DRMacIver> Ah ha. Cunning.
06:36:49 <int-e> a demonstration of 'programs are proofs'.
06:37:26 <notadev> -> is derives or..?
06:37:48 <DRMacIver> -> is the type constructor for function types.
06:38:09 <DRMacIver> i.e. Foo -> Bar is the type of a function which accepts an argument of type Foo and returns a value of type Bar
06:38:19 <Baughn> :kind (->)
06:38:29 <Baughn> @kind (->)
06:38:31 <lambdabot> ?? -> ? -> *
06:39:23 <DRMacIver> Hm. I'm not sure I understand how to read that. Are the different number of ?s just there to form different symbols or is there a deeper meaning?
06:39:30 <notadev> ah thanks Baughn
06:39:36 <int-e> DRMacIver: there's a meaning
06:39:36 <Baughn> DRMacIver: No, just different symbols
06:39:47 * DRMacIver is so confusered.
06:39:56 <Baughn> a -> b -> c, only for types
06:40:13 <DRMacIver> int-e: ?
06:40:28 <DRMacIver> Baughn: ok. That's what I thought it meant. Good. :)
06:40:31 <Baughn> "-> takes a type, and another type, and produces a concrete type"
06:40:58 <Baughn> Produces a *nonparametric* type, rather
06:44:12 <int-e> DRMacIver: hmm. different symbols. there are 3 basic kinds, * (normal), # (unboxed) and (#) (unboxed tuples); ?? can be * or # and ? can be all of the three. But I guess that makes then different symbols for you.
06:44:36 <int-e> (and all that is ghc specific)
06:45:08 <Baughn> And if you don't deal with optimization hackery, that's all just "some type".
06:45:31 <DRMacIver> Ah, right.
06:45:38 <int-e> so ?? -> ? -> * means that a function has a normal type, which can take boxed or unboxed values as parameters and can return that or an unboxed tuple.
06:46:13 <int-e> in the Haskell 98 fragment of ghc's language, the kind is effectively * -> * -> *
06:48:13 <|Steve|> What does * -> * mean? I've never seen that before.
06:49:59 <Baughn> |Steve|: It's a kind - means "type constructor that, if given a concrete type, returns a concrete type"
06:50:28 <|Steve|> Can you give an example?
06:50:33 <int-e> Maybe
06:50:36 <Baughn> |Steve|: [] is of kind * -> *, for example, while (,) has kind * -> * -> *
06:50:37 <int-e> Maybe has kind * -> *
06:51:20 <|Steve|> Okay, I see.
06:51:24 <int-e> you can think of kinds as "types" of type constructors. * is the "type" of a type (which can be regarded as a nullary type constructor)
06:51:48 <|Steve|> Hmm, when I ask for the type of Maybe in hugs it complains.
06:51:52 <int-e> and if k1 and k2 are kinds, k1 -> k2 is also a kind with the obvious meaning.
06:52:05 <int-e> :kind maybe? in ghci :kind works
06:52:17 <fasta> |Steve|: Maybe is not a value
06:52:22 <|Steve|> $ ghci
06:52:22 <|Steve|> ghc-6.6: not built for interactive use
06:52:33 <|Steve|> Stupid thing just does not want to work for me.
06:52:43 <int-e> hmm, did you build it yourself?
06:52:45 <fasta> |Steve|: now, now, don't blame the tools.
06:52:48 <|Steve|> Nope.
06:53:02 <fasta> |Steve|: it's working for a lot of people, if it's not working for you...
06:53:11 <|Steve|> http://bash.org/?772595
06:53:12 <lambdabot> Title: QDB: Quote #772595
06:53:13 <int-e> because that looks like a stage 1 ghc to me. (but maybe I'm wrong)
06:53:35 <int-e> nice quote.
06:53:40 <fasta> I agre
06:53:41 <fasta> e
06:53:50 <|Steve|> $ sudo apt-get install ghc
06:53:53 <|Steve|> That's how I got it.
06:53:56 <fasta> |Steve|: what platform?
06:54:04 <|Steve|> powerpc
06:54:37 <fasta> |Steve|: Did you read the Readme.Debian file which presumably was included?
06:54:56 <|Steve|> Heh, included where?
06:55:01 <fasta> |Steve|: or if you are on Ubuntu, I hope they have the same file.
06:55:07 <|Steve|> Ubuntu.
06:55:25 <|Steve|> slocate Readme.Debian shows nothing.
06:55:52 <fasta> |Steve|: Try slocate README.Debian| grep ghc
06:56:11 <|Steve|> Nothing.
06:56:18 <Baughn> |Steve|: If you just installed it, you need to run updatedb first
06:56:27 <|Steve|> slocate doesn't use updatedb.
06:56:28 <fasta> |Steve|: and just slocate README.Debian?
06:56:30 <Baughn> |Steve|: The database is otherwise only regenerated once per day
06:56:43 <|Steve|> And ghc has been installed on this computer for months.
06:56:52 <fasta> At 03:00, when the machine is powered off sometimes.
06:56:52 <|Steve|> But slocate README.Debian found many files.
06:57:04 <|Steve|> 313, to be exact.
06:57:14 <DRMacIver> Try /usr/share/doc/ghc6/README
06:57:23 <|Steve|> $ uptime
06:57:23 <|Steve|>  06:54:42 up 222 days,  8:53,  7 users,  load average: 0.17, 0.16, 0.10
06:57:43 <fasta> |Steve|:  cd /usr/share/doc/ghc6 and check for a README file
06:57:43 <|Steve|> Hey, that exists.
06:57:51 <|Steve|> Reading.
06:58:13 * DRMacIver -> out
06:58:24 <fasta> Hmm, that file is useless.
06:58:33 <|Steve|> Indeed.
06:58:41 <fasta> |Steve|: You should report a bug in Ubuntu that they build a decent GHC.
06:58:50 <fasta> |Steve|: or try to do it yourself
06:58:54 <DRMacIver> GHC worked fine out of the box for me on Ubuntu
06:58:58 <|Steve|> The ghc I installed on my other computers using darwinports has a working ghci.
06:59:02 <DRMacIver> It might be an architecture specific problem.
06:59:18 <fasta> PPC is not that special, is it?
06:59:24 * DRMacIver shrugs
06:59:32 <|Steve|> Ubuntu _just_ dropped support for it.
06:59:33 <DRMacIver> Ubuntu is pretty 'special' sometimes. :)
06:59:41 <DRMacIver> Anyway, really going now.
07:00:15 <fasta> |Steve|: Try this: deb http://haskell-unsafe.alioth.debian.org/archive/i386 . unstable testing stable
07:00:17 <lambdabot> Title: Index of /archive/i386
07:00:25 <fasta> |Steve|: oops
07:00:28 <fasta> |Steve|: don't try that
07:00:36 <|Steve|> Heh, probably wouldn't work so well.
07:00:56 <|Steve|> http://hackage.haskell.org/trac/ghc/ticket/631
07:00:57 <lambdabot> Title: #631 (GHCi doesn't work unregisterised) - GHC - Trac
07:02:35 <fasta> |Steve|: you can try an emulator :/
07:02:51 <fasta> |Steve|: or just work with the compiler first
07:03:20 <|Steve|> If I were going to that much trouble, I'd just use my faster computer, I suppose.
07:04:46 <|Steve|> I'll try building ghc myself.
07:07:14 <fasta> |Steve|: before that ticket is fixed, it will probably not work.
07:07:42 <|Steve|> The first comment says that his own works just fine.
07:09:44 <fasta> |Steve|: ok, my mistake. Good luck
07:09:51 <|Steve|> Thanks.
07:12:05 <xho> how does the FFI deal with const pointers?
07:14:18 <Baughn> xho: Near as I can tell, it doesn't
07:20:20 <xho> is there any way to do setjmp/longjmp from haskell?
07:20:36 <Baughn> xho: Why do you want to? What exactly are you trying to do?
07:21:04 <xho> trying to interface to a c library
07:21:23 <xho> what happens if a haskell function throws an exception in the middle of a foreign function call?
07:22:12 <Baughn> How could a foreign call throw a haskell exception?
07:22:32 <xho> if it calls a haskell function via function pointer
07:23:33 <SamB_XP> xho: two options: (1) read the FFI addendum (2) try it
07:23:47 <xho> ok thanks :)
07:24:07 <Baughn> xho: Probably you should wrap the haskell function in another haskell function that traps exceptions
07:24:25 <SamB_XP> that does seem rather likely ;-)
07:25:03 <|Steve|> I hope haskell will build more quickly since it doesn't have to bootstrap.
07:25:08 <|Steve|> er, ghc
07:25:46 * SamB_XP doesn't imagine many C libraries would appreciate being longjmped out of...
07:35:11 <xho> well i'm working with libpng and it expects you to longjmp out of it in your error handler function
07:35:26 <|Steve|> Isn't that horrible?
07:37:33 <xho> it's a primitive immitation of exceptions
07:37:48 <Baughn> xho: It's not that bad. It just expects to longjmp out of /libpng/.
07:38:15 <Baughn> xho: All you have to do is wrap its functions in a C function that calls setjmp first
07:38:27 <SamB_XP> oh, it's not horrible if it expects that
07:39:06 <SamB_XP> ... you might need to write a bit of C to hold your program together, though...
07:39:16 <SamB_XP> er. library.
07:39:23 <xho> i'm really trying to avoid that if possible
07:39:36 <Baughn> I'm afraid that isn't an option
07:39:46 <SamB_XP> Baughn: why not?
07:39:58 <Baughn> SamB_XP: Avoiding C isn't an option, I mean
07:40:04 <SamB_XP> oh good
07:40:26 <xho> @quote launch
07:40:26 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
07:40:26 <SamB_XP> hopefully you won't need *much* C
07:40:27 <Baughn> I'd like to say you only have to write /one/ C function, but there's no va_call in stdarg.h
07:40:53 <SamB_XP> of course he'd need at least two... one for setjmp, one for longjmp...
07:41:07 <Baughn> So you need one C function per distinct function type on the png side. Probably it's easier just to have one per png function.
07:41:29 <Baughn> On the plus side, they'll all be nearly identical. Use a macro.
07:42:51 <dankna> So, I'm having something of a conceptual issue here with classes.  (I'm new to Haskell, if that isn't obvious.)
07:43:25 <dankna> I suspect the trouble is mostly caused by me wanting C++/Java/Smalltalk-style polymorphism and Haskell having a different world-view
07:43:33 <xho> what happens if i try calling setjmp from haskell? is there a chance that it will work?
07:43:43 <SamB_XP> dankna: yeah. they are unlike classes in almost any other language
07:44:07 <Baughn> xho: setjmp is a macro, not a function
07:44:12 <dankna> Perhaps I can describe what I'm trying to achieve and how I'm presently doing it, and you can tell me if it makes any sense?
07:44:29 <SamB_XP> xho: it would screw things up, even if it were a function
07:44:32 <Baughn> xho: Moreover, jmp_buffers are invalidated when the function calling setjmp returns
07:44:45 <Baughn> xho: And haskell doesn't exactly /have/ a stack, the way it expects
07:44:56 <dankna> So I'm making an app that's intended to play multiple boardgames.  So I have a class Game.
07:45:16 <|Steve|> Uh, extern int setjmp(jmp_buf __env) __THROW; is my definition of it.
07:45:39 <xho> mine too
07:45:47 <dankna> It would be nice if each instance of Game also had an associated type Move that went with it, since the stuff that manages turn-taking could then deal with it totally abstractly and not care about what type of game it was
07:46:02 <dankna> But I can't tell whether such a concept exists
07:46:02 <SamB_XP> xho: you definately need to use C for this
07:46:07 <|Steve|> There's a macro #define setjmp(env) setjmp(env) but that doesn't really do much.
07:46:35 <Baughn> |Steve|: It's defined to be a macro, mostly because that adds restrictions to what you can do with it
07:46:44 <Baughn> No passing setjmp around as a function pointer, for example
07:46:44 <dankna> Complicating things a little, because it's a GUI program I need to give the window system (which happens to be Apple's Carbon, for now, although I have aspirations of portability) a pointer that it can give back to my callback.
07:46:49 <SamB_XP> dankna: we don't have associated types yet
07:46:56 <dankna> "Yet"?  Heh.
07:46:57 <|Steve|> Baughn: Sure you can.
07:47:01 <|Steve|> Just #undef it first.
07:47:14 <Baughn> |Steve|: Do that, and Knuth will watanagashi you.
07:47:28 <|Steve|> Actually, the preprocessor will just turn it into setjmp itself so that wouldn't change anything.
07:47:46 <dankna> I eventually figured out that what I wanted there was existential types, so I have a forall type AnyGame
07:48:06 <SamB_XP> but... why would you want to pass around a pointer to setjmp anyway?
07:48:09 <dankna> and that part works fine, I can pass a StablePtr to AnyGame to the window system, it passes it back to me, and I invoke methods on it
07:48:30 <dankna> I'm just not quite getting how Move is going to fit into the situation
07:48:52 <SamB_XP> dankna: the closest thing to what you want that we actually have right now is multiparameter type classes with functional dependencies
07:48:55 <|Steve|> $ echo '#include <setjmp.h>
07:48:55 <|Steve|> > #include <stdio.h>
07:48:55 <|Steve|> > int main() { printf( "%p\n", setjmp ); return 0; }'|gcc -x c -Wall -o a.out - [lonely:~] steve$ ./a.out
07:48:55 <|Steve|> 0x10000880
07:48:55 <lambdabot>  Parse error
07:48:56 <lambdabot>  Parse error
07:48:58 <dankna> oh?
07:49:04 <dankna> where can I read about that?
07:49:05 <|Steve|> Heh. (Sorry bot.)
07:49:16 <xho> is the problem that you want a function move :: Command -> Game -> Game
07:49:25 <dankna> yes.
07:49:26 <xho> and you need the Game type to be the concrete type?
07:49:39 <dankna> well, I'm not sure I understand that question
07:49:42 <dankna> but I think so
07:50:04 <xho> yeah, this is a case where OOP polymorphism works, where you can have a virtual void Move() function that updates the state of a concrete object
07:50:36 <dankna> yes, that accurately describes what I'm hoping to achieve
07:50:49 <xho> i think you are right that existential types can help you, but it's also possible without them
07:50:59 * dankna nods
07:51:23 <Saizan>  you can use a class HasMove x y where ... and instance HasMove GameFoo MoveFoo
07:51:36 <Philippa> xho: another way of looking at it's just that each 'object' interprets the messages it receives though - no biggie
07:51:50 <Saizan> class HasMove x y | x -> y , actually
07:52:54 <dankna> well, if I understand correctly, if my gui-event handler were being called by Haskell, it would always know what the types of its arguments were (the concrete types?  is that what I mean?); since it's called by the window system, though, it doesn't
07:53:07 <dankna> hence why I believe I need existentials; I don't know how or whether they relate to the move thing
07:53:08 <dankna> hmm
07:53:45 <SamB_XP> dankna: hmm?
07:53:52 <dankna> I'm digesting the thing about HasMove
07:53:55 <xho> dankna: maybe this can help: http://haskell.org/haskellwiki/Existential_type#Alternate_methods
07:53:56 <lambdabot> Title: Existential type - HaskellWiki
07:54:25 <dankna> I read that yesterday and it's not fresh in my mind, so I don't remember why it didn't seem relevant; I'll give it another look, heh
07:54:45 <dankna> possibly just because I was thinking about a different part of the problem yesterday
07:55:03 <dankna> hmmmm
07:55:26 <dankna> oh!  I get it.  so an instance of a class isn't necessarily a single type, it can be a bundle of types.
07:55:33 <dankna> that sounds like exactly what I want, in fact.
07:55:50 <dankna> (regarding Saizan's HasMove thing)
07:55:51 <Saizan> dankna: yes, that's an extension called Multi Parameter Type Classes
07:56:10 <dankna> I see.  Sounds useful.
07:56:37 <Saizan> do you happen to know the state monad?
07:56:48 <dankna> I haven't used it for anything nontrivial yet
07:57:39 <Saizan> well just to give and example of a MPTC, class MonadState s m | m -> s where get :: m s; put :: s -> m ()
07:58:05 <Saizan> and we have instances like instance MonadState s (State s) where ...
07:58:47 <Saizan> the m -> s part is a functional dependency, it means that for every m there has to be only one s
07:58:55 <dankna> okay, I believe I follow that.
07:59:09 <dankna> are functional dependencies also part of this extension?
07:59:13 <dankna> ah
07:59:19 <dankna> they wouldn't make sense with only one parameter
07:59:19 <Saizan> so that from State Int you can derive that s is Int
07:59:20 <dankna> so yes.
07:59:23 <int-e> they're yet another extension
07:59:25 <Saizan> yes
07:59:33 <dankna> haha, okay, so long as ghc actually supports all these :)
07:59:55 <Saizan> yup, they are bot used in the monad library
08:00:00 <Saizan> *both
08:00:00 * dankna nods
08:02:12 <Saizan> the fundep is there so that the compiler can infer s from m, so that you don't need explicit type signatures
08:02:48 <dankna> oh, so in other words if I had an instance of type m and I were calling one of the methods on it, it would know that the s was the particular type that goes with that m
08:03:03 <Saizan> exaclty
08:03:13 <Saizan> so he can pick the right instance
08:03:14 <dankna> hmm
08:03:16 <Saizan> *it
08:04:02 <dankna> now, let me think out how this is going to interact with my existential type
08:04:55 <dankna> I guess I would change the declaration forall a . (Game a) => AnyGame a, making it forall a . (HasMove a b) => AnyGame a
08:05:06 <sorear> x = 2
08:05:17 <sorear> is that a pattern binding or a function definition?
08:05:31 <dankna> sorear: a function definition (disclaimer: I'm new)
08:06:31 <sorear> hmm, I wonder what the effects of this are...
08:06:33 <dankna> is that going to work - when the only known information is that I have an instance of AnyGame, the compiler will be able to find the correct move type that's related to it?
08:07:23 <Saizan> i'm not sure if you can write that
08:07:29 * dankna nods
08:07:38 <Saizan> b is not in scoper
08:07:42 <Saizan> *scope
08:07:42 <dankna> it seems a little odd
08:08:06 <dankna> right.  but it seems like it needs to be a free variable (I know these are types and not variables, but) to express what I'm trying for.
08:08:28 <dankna> I can't just use an _ instead of b, can I?  presumably not...
08:08:53 <dankna> well, let me take a moment to reread that page on alternatives to existentials and see if it answers my question
08:10:05 <xho> is there something like memcpy for MArrays?
08:11:33 <ski> if 'a' determines 'b', then i think you can write like that
08:11:36 <ski> http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#type-restrictions
08:11:38 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
08:11:53 <ski> see point 1
08:12:17 <dankna> okay... the constructors and combinators approach there makes sense to me; the "universal instance" doesn't.  it's not obvious to me how either of those would be adapted to the multiparameter type-class situation though.
08:12:22 <dankna> oh!  good.  looking.
08:12:51 <dankna> indeed.  that looks right.
08:13:20 <dankna> well then, now I just have to try it and see.
08:14:31 <gkr> Where can I find a good resource about tupling techniques?
08:18:07 <Saizan> yes, you just have to quantify also over b
08:19:26 <dankna> uhhh... I take it that amounts to "it'll work", but what does it mean?
08:21:20 <Saizan> forall a b. (HasMove a b) => AnyGame a <-- that b becomes an existentially quantified type, so you have to use it only with methods of HasMove
08:22:01 <dankna> ah - got it
08:22:33 <Saizan> you can off course add another class constraint or a superclass to HasMove if you need them
08:22:46 <dankna> which is exactly what I want.  just like the actual type of a, I can't do anything that would depend on it being any particular instance, I can only do things that apply to all of them.
08:23:33 <dankna> hmm, you mean if I needed to pass around an AnyMove or something?
08:24:16 <dankna> pretty sure I don't require that right now, but good to know
08:24:56 <dankna> by the way, random unimportant question.  is there a reason it's called existentially quantified?  wouldn't "existentially qualified" make more sense?  I mean, there's no number involved...
08:25:26 <Saizan> it's a term from first order predicative logic
08:25:28 <kpreid> it's about the number of values the variable takes on
08:25:38 <dankna> hm
08:25:53 <kpreid> forall = everything; exists = at most one
08:26:00 <kpreid> er, at least one
08:26:11 * dankna nods
08:26:15 <sorear> forall = dependant exponential; exists = dependant product
08:26:32 <kpreid> how exactly existential types involve existential quantification, I have yet to understand :)
08:27:30 <dankna> kpreid: ah!  I see.  sorear: admit it, you just said that so I'd ask what it means. :)  which I am doing.
08:28:17 <sorear> dankna: forall x. (expression involving X) can be seen as a *function* of type  x:Type -> (expression involving x)
08:28:33 <sorear> dankna: this requires the ability for rhses to depend on lhses
08:29:04 <sorear> dankna: but it's a very nice and simple approach, since it means one typing rule can handle lambda and forall
08:29:47 <ski> sorear : confusingly some say 'forall' is 'dependant product', and 'exists' is 'dependant sum', though ..
08:30:43 <dankna> yes, the product/sum terminology makes slightly more sense to me.  presumably those people think in logarithms or something, ha.
08:31:12 <dankna> well, I don't understand all of that, sorear, but I think I understand enough of it.  cool.
08:32:48 <ski> f 0 + f 1 + .. + f (n - 1) = sum (\(i :: Nat_{< n}) -> f i)
08:33:16 <ski> in the case that 'forall i. f i = k' we get 'n * k'
08:33:32 <ski> f 0 * f 1 * .. * f (n - 1) = product (\(i :: Nat_{< n}) -> f i)
08:33:40 <ski> in the case that 'forall i. f i = k' we get 'k ^ n'
08:34:06 <dankna> ... hmm, I guess in order to parse moves I'm going to have to make the parse function be a method on HasMove, as well.
08:34:13 <ski> so you iterate a sum to get the 'exists' thing, thus some call it 'dependant sum' and others 'dependant product'
08:34:32 <ski> and you iterate a product to get the 'forall' thing, thus some call it 'dependant product' and others 'dependant exponential'
08:34:44 * dankna reads that, slowly
08:35:18 <ski> ('Nat_{< n}' is meant to mean the type of natural numbers less than 'n')
08:35:22 <dankna> got that, yeah
08:36:10 <ski> so if you think of 'exists x. f x' as a big 'sigma' "sum" expresion, it makes sense to call it 'dependent sum'
08:36:19 <dankna> okay.  I see how those expressions match up to the terminology.
08:36:53 <ski> otoh if you think of it as a product, where the second part happens to be dependant on the value of the first part, it makes sense to call it 'dependant product'
08:37:03 <dankna> I take it there's some profound motivation for viewing it in those terms, which seems a little weird.
08:37:19 <dankna> hm
08:37:31 <ski> mutatis mutandis with big 'pi' "product" sign and 'dependant product' vs 'dependant exponential/function'
08:37:51 <dankna> right, okay...
08:37:57 <Saizan> k is a type?
08:38:19 <ski> in the 'dependant' cases, yes
08:39:02 <ski> the haskell product type '(a,a)' is isomorphic to 'Bool -> a' (i.e. 'a^Bool') (at least if you ignore '_|_' things :)
08:39:27 <ski> and 'Bool' is iso to '1 + 1' (where '1' is the '()' unit type)
08:39:42 <ski> so the product type of 'a' with itself is just 'a' squared
08:40:08 <ski> ('(+)' is 'Either' of course)
08:41:16 <Saizan> ok, and forall a. a -> a would be?
08:41:24 <dankna> interesting concept, that you can perform arithmetic on a type
08:41:42 <ski> (a :: *) -> (a -> a)
08:41:51 <ski> or, if you will
08:41:57 <ski> (a :: *) -> ((_ :: a) -> a)
08:43:01 <Saizan> so, where the product comes out?
08:43:20 <ski> the dependent function type taking a value in '*' (i.e. a type), call it 'a', giving a (vacuosly) dependant function taking a value in 'a' (i.e. a value of that type), giving back a value of the type 'a'
08:46:13 <ski> data 1 = ()
08:46:21 <ski> data a * b * c = (a,b,c)
08:46:37 <ski> data a + b + c = (a | | )
08:46:48 <ski>                | ( | b | )
08:46:52 <ski>                | ( | | c )
08:47:01 <ski> foo :: 1 + 1 + 1 -> Int
08:47:14 <ski> foo (() | |) = 0
08:47:24 <ski> foo (| () |) = 5
08:47:31 <ski> foo (| | ()) = 17
08:47:48 <ski> expresses the "same" thing as
08:47:58 <ski> foo' :: Int * Int * Int
08:48:03 <ski> foo' = (0,5,17)
08:48:26 <ski> i.e. 'Int^(1+1+1)' is iso to 'Int * Int * Int'
08:48:35 <ski> this is the (nondependant) product
08:49:45 <ski> now assume we have a type
08:49:57 <Saizan> k
08:49:59 <ski> data Vector :: Nat -> * -> *
08:50:03 <ski>   where
08:50:16 <ski>   Nil :: forall a. Vector 0 a
08:50:39 <ski>   Cons :: forall (n :: Nat) a. a -> Vector n a -> Vector (n+1) a
08:51:00 <ski> now we can condsider a dependant product/function type
08:51:03 <ski> like
08:51:23 <Saizan> so Nat is a kind, right?
08:51:42 <ski> no, a type
08:52:00 <Saizan> what n :: Nat means then?
08:52:11 <Saizan> ooh, ok
08:52:13 <ski> bar :: (x :: 1 + 1 + 1) -> Vector (foo x) String
08:53:02 <ski> so 'bar' is still a function type from a type with three values, but the *type* of the return value is dependant on the *value* of the argument
08:53:29 <ski> in this case 'bar' would return a vector of length either 0, 5 or 17, depending on the input
08:53:43 <mrTime> hi, I've a problem with mutiple parameter classes, can someone help me?
08:55:14 <ski> in some systems one writes 'forall x :: 1 + 1 + 1. Vector (foo x) String' for the type of 'bar', instead
08:55:18 <ski> !paste
08:55:19 <hpaste> Haskell paste bin: http://hpaste.org/
08:55:40 <ski> mrTime : you may put your code there ^^
08:55:58 <ski> or you can try to explain what the problem is directly (or both)
08:56:11 <mrTime> aha, and what happens with my code if I put it there?
08:56:25 <ski> it becomes visible to us
08:56:38 <mrTime> ok :)
08:59:07 <ski> Saizan : i'm not sure if i answered your question ..
09:00:09 <hpaste>  mrTime pasted "problem with mutiple parameter classes" at http://hpaste.org/380
09:01:27 <sorear> mrTime: Set is a 2-parameter type class, but you only gave it 1 argument
09:01:36 <ski> mrTime : what are you trying to accomplish
09:01:37 <sorear> [a] (where a is a free variable)
09:02:04 <Saizan> ski: i still fail to see how you can specify universal quantification with product (\(i :: Nat_{< n}) -> f i) :\
09:02:05 <sorear> also, you don't need the functional dependency
09:02:29 <ski> probably *either* you should have '[a]' and 'a' as two arguments of the typeclass (with a fundep) *or* you should have '[]' as sole argument (with the 'Functor' superclass)
09:03:25 <sorear> Not all implementations of sets are usable functors.
09:03:32 <sorear> Some of them are cofunctors!
09:03:55 <ski> s/cofunctors/contravariant functors/
09:04:45 <ski> Saizan : generalize 'product (\(i :: Nat_{< n}) -> f i)' to 'product (\(a :: t) -> f a)' which can also be written as 'forall a :: t. f a' or '(a :: t) -> f a'
09:06:51 <hpaste>  dankna pasted "Huh - why does the instance type have to have parameters?" at http://hpaste.org/381
09:07:40 <dankna> (sorry to interrupt the discussion, which is still interesting but now over my head, not that that's a bad thing)
09:07:48 <ski> in the instance declarations, 'Set' should have the same number of parameters as in the class declaration
09:08:13 <Saizan> dankna: you don't have -fglasgow-exts in the module where you've written the instance, do you?
09:08:23 <dankna> er... good catch
09:09:01 <dankna> adding that gives me a more sensible error message, let me see if I can interpret this one on my own...
09:09:07 <ski> hm
09:10:01 <ski> mrTime : i think you need to change the class declaration
09:10:30 <mrTime> I tried that in many different ways, but none seemed to work
09:11:01 <ski> if you as currently have 'Set (a :: * -> *) (b :: *)', then there probably shouldn't be a fundep from 'a' to 'b'
09:11:33 <ski> if 'a' is '[]', then there can only be at most one 'b' coupled with this ..
09:11:56 <ski> .. and i assume you want to be able to use lists of more than one element type .. correct ?
09:12:27 <mrTime> ah, yes
09:12:50 <mrTime> ok, at that point I misunderstood tho docu
09:13:23 <mrTime> but b should be a type parameter of a
09:14:10 <mrTime> so can I write "(a :: b -> *)" ?
09:14:36 <ski> dankna : sorry, for some reason i thought you were commenting on mrTime's problem .. in "The instance type must be of form (T a b c) where T is not a synonym, and a,b,c are distinct type variables", there can be *zero* or more variables 'a','b','c',...
09:14:51 <ski> mrTime : no
09:14:52 <int-e> mrTime: there are no kind variables
09:15:07 <chessguy> 'afternoon ya'all
09:15:29 <emu> the world is filled with unkind variables
09:15:36 <mrTime> so how do I say, b is type parameter of a?
09:15:37 <ski> dankna : are 'Board' or 'Move' type synonyms, mayhaps ?
09:16:12 <dankna> ski: sorry, I should have clarified that adding the -fglasgow-exts did indeed fix that bit
09:16:22 <ski> dankna : *nod*
09:16:22 <dankna> I'm now staring at something else where it's telling me "Inferred type is less polymorphic than expected"
09:16:44 <dankna> since it looks like I would have to paste a fair chunk of code to show this one, I'm looking at it myself first
09:16:52 <emu> type annotate?
09:17:48 <chessguy> dankna, are you planning on specifying a game at runtime?
09:18:12 <xho> what's the way to do assert?
09:18:32 <Saizan> is drawBoard :: (Drawing drawing) => Board -> drawing -> IO () ?
09:18:54 <emu> @hoogle assert
09:18:55 <dankna> chessguy: yes, in fact, why?
09:18:55 <lambdabot> Control.Exception.assert :: Bool -> a -> a
09:18:55 <lambdabot> Test.HUnit.Base.assert :: Assertable t => t -> Assertion
09:18:55 <lambdabot> Control.Exception.assertions :: Exception -> Maybe String
09:19:16 <chessguy> dankna, i worked on a project like this before i had heard of haskell
09:19:20 <chessguy> consider yourself lucky
09:19:34 <dankna> and yes, that's the type of drawBoard... er... except it's undeclared, so let me add the declaration and see what that does
09:19:40 <fasta> I have a type class with 5 variables and one method f that has type <one of those variables>. I have a function myFun which when it doesn't call f type checks fine, but when I add f it claims it needs an instance Foobar <4 type variables> <specialized <one of those variables>>. How can I solve this?
09:20:11 <dankna> chessguy: heh, thanks.  well, it's mostly a learning exercise for me since it's large enough that I have to actually use the real power of Haskell.
09:20:19 <Saizan> fasta: mmh, adding phantom parameters to f?
09:20:24 <chessguy> i had an OO class where my semester-long group project was to build a web-based game server that would allow one to specify new games at runtime
09:20:28 <Saizan> fasta: or fundeps
09:20:44 <fasta> Saizan: I like fundeps more
09:20:54 <chessguy> well, s/web/sockets/
09:21:21 <fasta> Saizan: and what do you mean exactly by phantom parameters? Just _ repeated 4 times?
09:21:29 <dankna> group projects for undergrads are inherently kinda problematic
09:21:58 <chessguy> especially when dealing with an inherently flawed paradigm like OO :)
09:22:19 <fasta> Saizan: it's just that I am not entirely sure what fundep I would need to add. I guess that knowing the one parameter fixes the other 4?
09:22:36 <Saizan> fasta: say that class Foo a b c d e where f :: e -> SomeType,  instead f :: a -> b -> c -> d  -> e -> SomeType where f _ _ _ _ = oldf
09:22:46 <int-e> fasta: maybe put f in a separate type class with only one type argument?
09:23:07 <Saizan> fasta: you'd need enough fundeps to make a b c d inferrable from e
09:23:10 <int-e> fasta: class Foo a where f :: a; class Foo a => Bar a b c where ...
09:23:16 <hpaste>  dankna annotated "Huh - why does the instance type have to have parameters?" with "more code added..." at http://hpaste.org/381#a1
09:24:05 <int-e> fasta: not sure if that suits your problem.
09:24:33 <fasta> Saizan: I think that breaks the coverage condition.
09:24:34 <Serge> @src enumFrom
09:24:34 <lambdabot> Source not found. You speak an infinite deal of nothing
09:24:37 <Serge> @src enumFromTo
09:24:37 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
09:24:39 <Serge> hmm
09:25:04 <dankna> chessguy: well, that's a stronger complaint than I would make, but :)  anyway, I find this project exciting
09:25:11 <fasta> int-e: thanks, but this was part of an operation to move lots of related stuff in one class to reduce clutter in types.
09:25:22 <DRMacIver> chessguy: 'inherently flawed'?
09:25:45 <chessguy> dankna, as did i. it's interesting stuff.
09:25:46 <Serge> > enumFrom False
09:25:48 <lambdabot>  [False,True]
09:26:30 <chessguy> DRMacIver, too many things just don't work as objects
09:27:32 <chessguy> haskell's methods of abstraction are just obviously more powerful
09:27:34 <dankna> Hm, I think I may be out of time right now.  I appreciate the advice, ski, Saizan.  Perhaps I shall return later.
09:27:48 <chessguy> (even more so if they ever get around to first-class records
09:27:58 <emu> game server specifying new games at runtime? a MOO? practically a textbook case of OO ;)
09:28:15 <chessguy> MOO?
09:29:22 <emu> http://world.std.com/~franl/moo.html
09:29:24 <lambdabot> Title: MOO: MUD Object Oriented
09:29:38 <chessguy> no, not those kinds of games
09:29:55 <chessguy> maybe you should actually try to get the context before just diving into a conversation...
09:29:57 <dankna> actually, my architecture is peer-peer and now that I figured out what you meant by runtime, no, it doesn't actually support designing new games from scratch at runtime.  anyway, I'm heading off.
09:30:04 <emu> what, just because it's "web based"?
09:30:06 <emu> woopie do
09:30:46 <dankna> eh, emu's comment seems reasonable from where I stand ^^' I don't consider it at all obvious that objects are obsolete; people do try to apply them where they don't belong, but games are a pretty clear example where they do
09:31:25 <chessguy> i wasn't saying OO shouldn't be applied to this problem
09:31:32 <dankna> okay
09:31:37 <chessguy> after all, i did it
09:31:59 * dankna nods
09:32:17 <chessguy> i wasn't even really saying that objects are obsolete
09:32:38 <chessguy> just that they are inherently less powerful than haskell's abstraction methods, and thus, inherently flawed
09:34:36 <Saizan> mmh i'm starting to think that existentials + MPTC is a really bad thing to do
09:40:25 <fasta> How can I achieve with fundeps what otherwise would be "easy" with one extra class as described above? All earlier attempts resulted in violations of the coverage condition.
09:44:39 <DRMacIver> chessguy: I don't think "too many things just don't work as objects" is a problem for good OO languages any more than "too many things just don't work as functions" is a problem for functional languages. :)
09:45:29 <chessguy> no language would claim to have only functions
09:45:59 <xho> lisp
09:46:03 <therp> chessguy: closures are totally sufficient as an abstraction for data
09:46:13 <DRMacIver> unlambda? :)
09:46:16 <therp> see SICP on lisp
09:46:36 <Baughn> SICP is on scheme, not lisp - and a subset of scheme at that
09:46:41 <DRMacIver> chessguy: Anyway, you didn't complain about languages, you complained about the paradigm.
09:46:51 <Baughn> lisp-in-general is barely more than a common syntax
09:47:06 <chessguy> a paradigm which is full of languages in which "everything is an object"
09:47:07 <therp> baughn: I consider scheme to be part of the definition of Lisp
09:47:24 <Baughn> therp: I consider an unqualified "lisp" to refer to common lisp
09:47:27 <DRMacIver> In particular OO is possible within languages for which not everything is an object.
09:47:53 <chessguy> but that's not the norm in the paradigm
09:48:06 <Baughn> It's possible to have everything-is-an-object without it getting in the way of other paradigms, too; witness CLOS.
09:48:09 <hpaste>  fasta pasted "Avoiding overly general constraints with fundeps" at http://hpaste.org/382
09:48:41 <DRMacIver> chessguy: Define 'norm'. The most ubiquitous OO language in common usage has exactly that property. :)
09:50:07 <chessguy> why are you so insistent on picking a fight? my point was that haskell's methods of abstraction are more powerful
09:50:30 <fasta> chessguy: if they are so powerful, please solve my problem :)
09:50:36 <DRMacIver> 18:20 < chessguy> especially when dealing with an inherently flawed paradigm like OO :)
09:50:48 <DRMacIver> This doesn't sound like I'm the one picking a fight. :)
09:50:57 <chessguy> flawed with respect to haskell, obviously was my intent
09:51:07 <Saizan> dankna: ping
09:52:00 <hpaste>  fasta annotated "Avoiding overly general constraints with fundeps" with "(no title)" at http://hpaste.org/382#a1
09:52:02 <chessguy> the smiley face also indicates that i wasn't entirely serious
09:52:14 <chessguy> not that i was picking a fight
09:52:23 <jfredett> holy crap, derivative of a data structure? *mathgasm*
09:52:35 <chessguy> @where zipper
09:52:35 <lambdabot> I know nothing about zipper.
09:52:48 <jfredett> i know, I'm reading it in the haskell wikibook
09:52:54 <jfredett> @ haskell wikibook zipper
09:52:59 <jfredett> @google haskell wikibook zipper
09:53:00 <lambdabot> http://www.haskell.org/pipermail/wikibook/2007-February/000010.html
09:53:01 <lambdabot> Title: [Haskell wikibook] Article ANN: Theseus and the zipper
09:53:02 <jfredett> doh.
09:53:22 <DRMacIver> Fine. I'll drop the subject.
09:53:27 <jfredett> I dont know how to add it to lambda's where list
09:53:40 <chessguy> @go huet zipper
09:53:42 <lambdabot> http://lambda-the-ultimate.org/node/view/1036
09:53:42 <lambdabot> Title: Zipper-based file server/OS | Lambda the Ultimate
09:53:54 <Baughn> @where+ zipper http://www.haskell.org/pipermail/wikibook/2007-February/000010.html
09:53:55 <lambdabot> Done.
09:54:12 <jfredett> ahh, brilliant.
09:54:25 <Baughn> If that isn't the right url, just where+ it again
09:54:42 <chessguy> hm. where's the original huet paper?
09:55:01 <jfredett> i'd bet its in jstor somewhere
09:55:09 <jfredett> it was what, george huet?
09:55:13 <Saizan> fasta: with only fundeps you need to add c -> a, c -> s, c -> m or an equivalent combinantion (s -> m, c -> a, c -> s for example)
09:55:17 <int-e> fasta: to call foo you need an instance of the type class. the compiler will have to derive that instance somehow, and the signature of foo does not provide enough information for that. (I don't know why the declaration of foo is accepted like this)
09:55:24 <chessguy> i would think that would be a better ?where
09:55:42 <int-e> btw you can compres   a -> b, a -> c to a -> b c
09:56:21 <chessguy> gerard
09:56:23 <chessguy> found it
09:56:29 <jfredett> brilliant
09:56:37 <chessguy> @where+ http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
09:56:37 <lambdabot> Done.
09:56:38 <jfredett> i should have known that, thats my middle name... :/
09:56:45 <chessguy> @where+ zipper http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
09:56:45 <lambdabot> Done.
09:57:35 <Baughn> @where http://www.st.cs.uni-sb.de/edu/seminare/2005/advanced-fp/docs/huet-zipper.pdf
09:59:35 <jfredett> so if I'm understanding all this right-- Differentiation of data types is effectively translating a data type to an algebraic expression, taking a (partial) derivative (or two) and then reinterpeting the result as a new data structure?
09:59:54 <fasta> Saizan: When I do that I get an infinite type: m = ContT () m
10:00:18 <jfredett> the process therefore imparts some information thats useful in creating a metadatastructure
10:00:29 <jfredett> like the thread in the zipper?
10:01:04 <fasta> Saizan: and with just c -> a, c ->  s, c -> m, I get that the coverage condition fails
10:01:29 <Saizan> fasta: well i've not said that those fundeps have any sense in your case :)
10:02:24 <fasta> Saizan: That's true, but I don't see what would be the difference.
10:04:44 <Saizan> fasta: between?
10:05:13 <fasta> Saizan: between my actual types and what I asked
10:05:23 <int-e> fasta: you can fix this with phantom arguments. also, if the type c really determines which instance of foo to use, you can put foo in a separate type class. right now, foo can only work if the type c alone determines the Foobar instance to be used.
10:05:46 <Saizan> what int-e said
10:07:19 <int-e> because that's what the type checker does, it sees foo, and derives its return type from the environment in which it appears, and tries to determine the Foo instance to use from that information alone. not even type annotations will help there.
10:07:24 <fasta> int-e: The m in that type gets instantiated with at least two different types, I think. Could that be the reason for the infinite type?
10:08:10 <fasta> int-e: But... is there some inherent limitation in fundeps which makes that I cannot make it work now?
10:08:32 <fasta> int-e: I just would like to get somewhat more understanding, since it appears a bit arbitrary to me now.
10:09:17 <int-e> fundeps should work in principle, as far as I understand this.
10:09:37 <int-e> *if* the type c alone determines the Foobar instance.
10:10:06 <int-e> and I don't know where the infinite type comes from.
10:10:12 <Saizan> the big limitation is that they have to hold for your class
10:14:47 <Saizan> maybe we should extend the work on normalization in the relational model to typeclasses?
10:15:27 <araujo> hello
10:15:58 <xho> sup
10:19:20 <fasta> Saizan: did you get my message?
10:19:50 <Saizan> fasta: yes
11:41:54 <emu> does anyone use Reinke's vim-haskell stuff
11:44:31 <Syzygy-> ?hoogle foldlM
11:44:31 <lambdabot> No matches found
11:44:40 <Syzygy-> :t foldl
11:44:42 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:44:56 <Syzygy-> ?hoogle (a -> b -> m a) -> a -> [b] -> m a
11:44:57 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
11:44:57 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
11:45:17 <SL> how do I write a function which computes some value, but also prints it to the screen?
11:45:21 <Syzygy-> How do I fold into a monad?
11:45:44 <Saizan> ?type foldM
11:45:45 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
11:46:11 <Saizan> SL: that is generally a bad idea, you should keep I/O and your pure code separated
11:47:48 <Saizan> SL: however, you'll have something like this: foo input = do value <- compute input; putStrLn (show value)
11:48:25 <Saizan> which makes foo :: SomeInputType -> IO (), you need to be in the IO monad to do any Input/Output
11:51:47 <SL> Saizan, lets say I write a complex algorithm and I want to print some debug messages while computing
11:52:20 <dmhouse> SL: for printing debugging messages, check out Debug.Trace.
11:52:51 <dmhouse> If you want _logging_ messages as opposed to _debugging_ messages (i.e., messages you're planning to keep in there permanently), the Writer monad is a better fit.
11:59:49 <SL> dmhouse, ok, thanks
12:12:50 <xho> how do i call a c function that takes a pointer to a single integer and modifies the integer. Do I use IORef?
12:13:14 <Lemmih> xho: Nope, you use Ptr.
12:13:14 <lambdabot> Lemmih: You have 1 new message. '/msg lambdabot @messages' to read it.
12:14:11 <Lemmih> ?tell sorear ghc-src has bitrotted, I believe.
12:14:11 <lambdabot> Consider it noted.
12:14:22 <hpaste>  ptolomy pasted "haskell version of Rob Pike's newsqueak example (also squinting at power series)" at http://hpaste.org/383
12:14:26 <sorear> Oh well.
12:14:26 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
12:14:31 <sorear> @clear-messages
12:14:31 <lambdabot> Messages cleared.
12:15:36 <ptolomy> I was watching Rob PIke's google techtalk and I thought the message-passing channel-based concurrency prime example he showed was cool, so I re-did it in haskell (with less code, I might add. :-P)
12:15:39 <xho> hm.... i'm supposed to use mallocForeignPtr?
12:16:22 <sorear> xho: Ptr
12:16:33 <sorear> xho: look at alloca
12:16:36 <sorear> @type alloca
12:16:40 <lambdabot> Not in scope: `alloca'
12:16:41 <Lemmih> xho: No, alloca or malloc should do.
12:16:43 <ptolomy> Of course, blocking channels with generators is pretty much just backward lazy evaluation, sorta.
12:16:45 <sorear> @type Foreign.alloca
12:16:48 <lambdabot> forall a b. (Foreign.Storable.Storable a) => (GHC.Ptr.Ptr a -> IO b) -> IO b
12:17:53 <xho> hm... thanks
12:19:07 <xho> is alloca identical to malloc+free. or is alloca  somehow related to the alloca system call?
12:19:42 <Lemmih> xho: alloca is like malloc+free, just faster.
12:19:58 <xho> faster because it uses the stack?
12:20:08 <int-e> faster because it uses the heap
12:20:24 <kpreid> int-e: um...
12:20:25 <int-e> the garbage collected heap that is. not the C one.
12:20:40 <sorear> @src alloca
12:20:41 <lambdabot> Source not found. This mission is too important for me to allow you to jeopardize it.
12:21:49 <int-e> hmm. or a pinned bytearray. which, actually, is close enough.
12:21:57 <Japsu> How do I find out in Haskell whether stdin is a TTY or not?
12:22:34 <xho> int-e: how come ghc can't use the same technique for malloc/free?
12:22:37 <Japsu> Or hmm
12:22:40 <SamB> we need a posix -> Haskell dictionary...
12:22:50 <Japsu> Does it actually matter? Can I just use PureReadline with a non-TTY stdin...
12:23:08 <int-e> xho: because malloc/free pointers can be given out to C, and stored there.
12:23:11 <SamB> xho: those are supposed to allocate malloc/free compatible blocks...
12:23:20 <Lemmih> Japsu: Search System.Posix.
12:23:24 <int-e> xho: which would hide them from the garbage collector, asking for trouble.
12:24:44 <xho> int-e: i'm not allowed to pass pointer created with alloca to C?
12:25:07 <Japsu> Lemmih: Thanks! Let's see...
12:25:07 <int-e> xho: you can pass it, but the C side can't use it after the alloca is done.
12:26:02 <Lemmih> Japsu: http://www.haskell.org/ghc/docs/latest/html/libraries/unix/System-Posix-Terminal.html#v%3AqueryTerminal
12:26:04 <lambdabot> http://tinyurl.com/2786zp
12:27:54 <xho> ok thanks int-e
12:28:41 <int-e> xho: hmm "after the alloca is done", what I mean is that in  alloca f, the pointer passed to f is guaranteed to be valid until f finishs.
12:29:03 <xho> ok i understand
12:30:43 <Japsu> Lemmih: yeah, just what I was looking for, great :)
12:33:51 <bluestorm_> hm
12:34:07 <bluestorm_> little question : what's the name for ">>=" ?
12:34:13 <bluestorm_> hm
12:34:15 <Botje> bind
12:34:16 <bluestorm_> bind ?
12:34:16 <bluestorm_> ok
12:34:18 <bluestorm_> thanks
12:34:30 <bluestorm_> for some time i got confused between >>= and join, so..
12:34:52 <Botje> join f = f >>= id
12:35:07 <Botje> ?src join
12:35:08 <lambdabot> join x =  x >>= id
12:35:25 <mehrheit> :t join
12:35:27 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
12:35:49 <olsner> :t (>>=)
12:35:50 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
12:36:09 <olsner> :t (>>= id)
12:36:12 <lambdabot> forall (m :: * -> *) b. (Monad m) => m (m b) -> m b
12:36:17 <bluestorm_> and how do you write >>= with join ?
12:36:38 <olsner> :t (join . return)
12:36:41 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m a
12:36:49 <SL> is there a built in function which separates a list in two lists, one in which the elements hold a predicate, the other contains the elements which do not hold the predicate
12:37:06 <bluestorm_> you should use hoogle type search
12:37:08 <Lemmih> @type partition
12:37:09 <bluestorm_> http://www.haskell.org/hoogle/
12:37:10 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:37:10 <lambdabot> Title: Hoogle
12:37:15 <bluestorm_> it's very useful for that
12:37:52 <SL> ah, nice
12:38:51 <sorear> :t \a f -> join (fmap f a)
12:38:53 <lambdabot> forall a (m :: * -> *) a1. (Functor m, Monad m) => m a -> (a -> m a1) -> m a1
12:38:57 <sorear> @pl \a f -> join (fmap f a)
12:38:57 <lambdabot> (join .) . flip fmap
12:38:57 <bluestorm_> hm
12:39:01 <bluestorm_> so you need fmap
12:39:06 <sorear> yeah
12:39:13 <sorear> every monad is a functor
12:40:15 <sorear> with two natural transformations join and return (not that I really understand what a natural tranformation is :) )
12:41:00 <Japsu> @src replicateM_
12:41:00 <lambdabot> replicateM_ n x = sequence_ (replicate n x)
12:41:09 <sioraiocht> sorear doesn't understand something?
12:41:18 * sioraiocht gasps.
12:41:26 <Japsu> @src repeat
12:41:26 <lambdabot> repeat x = xs where xs = x : xs
12:41:28 <sioraiocht> That means I'll never bother with it, heheh
12:42:41 <Heffalump> it's not particularly relevant to using monads
12:43:25 <dmhouse> repeat x = x : repeat x -- much simpler definition
12:44:05 <mehrheit> :t unfoldr
12:44:06 <sorear> repeat = fix . (:)
12:44:07 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
12:44:13 <dmhouse> (Screws up CSE though.)
12:44:14 <Heffalump> but without the nicer operational behaviour without CSE
12:44:28 <Japsu> Hmm
12:44:34 <Japsu> Why isn't there a repeatM_?
12:44:35 <olsner> :t fix . (.)
12:44:38 <Japsu> (I just wrote one)
12:44:38 <lambdabot> forall c a. (c -> c) -> a -> c
12:44:44 <emu> @hoogle forever
12:44:45 <lambdabot> No matches found
12:44:51 <Japsu> forever?
12:44:53 <Japsu> hmm hmm
12:45:00 <emu> proposed, i think
12:45:09 <Japsu> repeatM_ :: Monad m => m a -> m ()
12:45:10 <Japsu> repeatM_ x = sequence_ (repeat x)
12:45:24 <sorear> repeatM_ = replicateM_ infinity
12:45:35 <Japsu> hmm, why not
12:45:39 <sorear> I wish we had proper lazy numbers :)
12:45:41 <Japsu> hehe
12:46:02 <sioraiocht> sorear: what are lazy numbers?
12:46:10 <dmhouse> sorear: Peano-style?
12:46:15 <emu> numbers without a proper worth ethic
12:46:16 <dmhouse> sorear: [()] :)
12:46:17 <emu> work
12:46:38 <emu> sioraiocht: think about (sum [1..] > 0)
12:46:38 <sorear> numbers that can take the form k + _|_ :)
12:46:39 <ddarius> \f -> join . liftM f
12:46:42 <ddarius> :t \f -> join . liftM f
12:46:46 <lambdabot> forall a a1 (m :: * -> *). (Monad m) => (a1 -> m a) -> m a1 -> m a
12:47:12 <sioraiocht> so a number whose value can be defined but not necessarily calculated/
12:47:17 <SL> how is this actually computed? "partition p xs == (filter p xs, filter (not . p) xs)" does haskell process the list two times where it could be done in one pass?
12:47:29 <mehrheit> @index unfoldr
12:47:29 <lambdabot> Data.List
12:47:36 <Heffalump> sorear: i.e. inductive naturals?
12:47:43 <emu> @src partition
12:47:43 <lambdabot> partition p xs = foldr (select p) ([],[]) xs
12:47:43 <lambdabot>     where select p x ~(ts,fs) | p x       = (x:ts,fs)
12:47:43 <lambdabot>                               | otherwise = (ts, x:fs)
12:47:50 <ddarius> In Haskell, a natural transformation is more or less equivalent to a polymorphic function.
12:48:20 <dmhouse> ddarius: between functors.
12:48:29 <bluestorm_> ddarius: do you have some accessible papers on the category-theoric part of haskell ?
12:48:57 <bluestorm_> (accessible to someone that is just beginning category theory _and_ haskell)
12:49:01 <ddarius> dmhouse: Almost all data types in Haskell are functors.
12:49:04 <dmhouse> bluestorm_: http://en.wikibooks.org/wiki/Haskell/Category_theory
12:49:07 <lambdabot> Title: Haskell/Category theory - Wikibooks, collection of open-content textbooks
12:49:12 <ddarius> (or rather type constructors)
12:49:18 <dmhouse> bluestorm_: if you're comfortable with type classes then that should be okay for you.
12:49:18 <bluestorm_> i found the Moggi paper but...
12:50:01 <bluestorm_> hm
12:52:34 <olsner> :t flip (>>=)
12:52:37 <lambdabot> forall (m :: * -> *) a b. (Monad m) => (a -> m b) -> m a -> m b
12:52:39 <ddarius> Categories were made so one could talk about functors and functors were made so one could talk about natural transformations.
12:54:11 <emu> does anyone code .lhs in vim?
12:54:31 <dmhouse> I've heard syntax highlighting with literate scripts is broken in Vim.
12:54:42 <dmhouse> That might just be FUD, though, it could be fixed by now.
12:54:43 <emu> just wondering if there was any way to keep Bird tracks from getting mixed up with indentation
12:55:01 <dmhouse> *cough*Use Emacs*cough*
12:55:08 * Japsu uses Vim
12:55:12 <Japsu> ^        ^
12:55:51 <emu> dmhouse: i normally do
12:55:53 <sorear> emu: I do it, and it works fine.
12:56:01 <ptolomy> Oh. My rip-off of the Newsqueak code showed by Rob Pike uses pretty much the same technique as the shootout chameneos code. Hm.
12:56:09 <emu> sorear: really? using >> on a line with a bird track causes it to indent the track
12:56:12 <sorear> dmhouse: synhl works almost perfectly
12:56:24 <emu> synhl isn't the problem
12:56:29 <sorear> emu: oh, hehe, I don't use intentation
12:56:35 <emu> sorear: what, none at all?
12:56:44 <sorear> emu: +automatic
12:56:53 <emu> well that just shifts code over
12:57:42 <emu> i don't use any automatic indentation plugins with vim, too tricksy.
12:57:56 <emu> on whitespace sensitive haskell
13:01:31 <Japsu> hmm,
13:01:44 <Japsu> haskell on Series 60 would be cool
13:02:12 <olsner> Series 60? is that Symbian mobile phones?
13:02:15 <Japsu> yep
13:02:17 <thorat> (and Windows Mobil)
13:02:21 <thorat> (and Windows Mobile)
13:02:33 <Botje> mobile windows? how does that work?
13:02:33 <Japsu> olsner: mostly Nokia, but some other manufacturers do S60 too
13:02:37 <Botje> you hand someone a frame?
13:02:40 <Japsu> :D
13:03:06 * ddarius just uses autoindent
13:03:52 <ibid> Botje: i think it's just before in the comics the guy comes running and smashes a glass that is being hauled around :)
13:03:52 <lambdabot> ibid: You have 1 new message. '/msg lambdabot @messages' to read it.
13:04:05 <ibid> i *hate* lambdabot messages!
13:04:13 <Japsu> :D
13:04:14 <thorat> Japsu: Series 60 development is done with gcc so maybe it would just work?
13:04:37 <thorat> Japsu: I was out of luck when I was developing for Pocket PC however
13:04:45 <ibid> DRMacIver: would have been faster to email me, or /msg me :)
13:04:45 <Japsu> thorat: yeah well, lately Nokia has released this wickedly cool "Open C" thingy which is... well, standard C api on S60
13:05:22 <Japsu> thorat: up until then people developing for S60 have been dependant on the not-so-cool Symbian S60 api
13:05:28 <thorat> ah, ok
13:05:41 <Japsu> which kinda... makes you want to hang yourself with barb wire
13:06:12 <Japsu> But I'm not exactly familiar with their cross-compiling system
13:06:28 <heanol> you should do a haskell -> j2me instead
13:06:28 <Japsu> correct me if I'm wrong, but isn't GHC mostly self-hosting?
13:06:28 <heanol> :)
13:06:38 <Japsu> that is, you need to have GHC to compile GHC?
13:06:47 <Heffalump> yes, unless you like extreme pain
13:06:56 <Japsu> :P
13:06:59 <Japsu> so hmm
13:07:00 <Heffalump> and have a convenient collection of .hc files generated by, you guessed it, GHC
13:07:09 <Japsu> how's cross-compiling with GHC then?
13:07:10 <thorat> Japsu: there was a gcc-pocketpc cross compiler on debian.  I never tried it.  Maybe that would have worked to run haskell on pocket pc
13:07:15 <Heffalump> (I believe the "extreme pain" aspect is getting better these days, though)
13:07:19 <Heffalump> it can't do it
13:07:29 <Heffalump> you port GHC to a new platform then compile on that
13:07:32 <ibid> DRMacIver: added, planet is updating
13:07:44 <Japsu> Heffalump: well, that sounds... even more painful than the "extreme pain" part
13:07:57 <Japsu> because that would mean compiling GHC on an actual S60 _phone_
13:08:26 <Heffalump> or a simulator
13:08:30 <Heffalump> but, yeah..
13:08:30 <xho> would be really cool to be able to cross compile GHC apps for GP2X console
13:08:30 <Japsu> yeah well
13:08:37 <Japsu> that's exactly what the S60 simulator is
13:08:42 <Japsu> a _simulator_, not an emulator
13:08:48 <Japsu> it runs code compiled for win32
13:09:01 <Japsu> that just calls the simulator runtime to display the S60 UI
13:09:08 <Heffalump> isn't not an instruction set emulator, then?
13:09:19 <Japsu> no, it's not an instruction set emulator afaik
13:10:00 <Heffalump> could you run S60 on qemu?
13:10:08 <Heffalump> I guess getting the images to run might be tricky
13:10:12 <Japsu> they have this pseudo-architecture thingy called "WINS" that basically uses the Visual C++ compiler to compile your Symbian app for Windows... or that's how it was done when I was still exposed to S60 stuff
13:10:45 <Japsu> since then they've switched from Visual C++ to an Eclipse-based Carbide.C++, dunno if that changes anything
13:10:50 <Japsu> hmm
13:10:57 <Japsu> haven't heard of anyone running S60 on qemu
13:11:29 <Japsu> that would require a qemu version that would emulate ARM and a helluva lot of specialized hardware, AND of course a rom image of an S60 phone
13:11:39 <Heffalump> qemu can emulate ARM
13:11:51 <Heffalump> the other hardware would be a bigger problem
13:11:56 <Japsu> yeah
13:12:24 <Japsu> dunno if "the other hardware" would be necessary for compiling stuff, but getting an S60 rom image to run without "the other hardware" might be nontrivial
13:12:33 <Japsu> assuming we had an S60 rom image
13:12:36 <Japsu> and well
13:12:46 <olsner> if the S60 binaries are dynamically linked, you could use your own library for UI and hardware interaction, run it locally in an emulator and use the same binary on the phone
13:12:52 <Japsu> tbh compiling ANYTHING on a S60 device, real or emulated, sounds... evil
13:13:17 <olsner> basically, that "WINS" thingy, but running "natively" on ARM
13:13:33 <Japsu> not sure I understand what you're saying
13:13:48 <Japsu> hmm
13:14:21 <olsner> but compiling GHC on a mobile phone sounds evil enough to be fun
13:14:27 <Japsu> no, I don't know about the ABI the S60 binaries use... well, you'd think they NEED to be dynamically linked because of the memory requirements on the platform
13:14:58 <Heffalump> or just have all the library code in the OS
13:14:59 <Japsu> olsner: :D
13:15:04 <Japsu> Heffalump: yeah
13:17:42 <xho> is there any way to pass a pointer to IOUArray into C?
13:17:54 <Binkley> ?yow
13:17:54 <lambdabot> Where's SANDY DUNCAN?
13:18:40 <olsner> compiling GHC took a couple of hours to compile on my 2GHz c2d - I guess it'd take days on a mobile phone
13:18:46 <Lemmih> xho: Do you want to access the array from C?
13:18:50 <Japsu> hmm hmm
13:18:56 <xho> Lemmih: yes, write to it
13:19:04 <Japsu> @remember olsner but compiling GHC on a mobile phone sounds evil enough to be fun
13:19:04 <lambdabot> Done.
13:19:05 <Lemmih> xho: Then use a Ptr.
13:19:08 <Japsu> ^_____^
13:19:19 <olsner> ;-)
13:19:19 <Japsu> Hmm hmm
13:19:23 <Lemmih> xho: Haskell types don't mix well with C.
13:19:25 <Japsu> I'm using a binary version of GHC
13:19:27 <Japsu> on Gentoo
13:19:44 <Japsu> perhaps what my computer'll do tonight would be compiling GHC
13:19:46 <olsner> oh, and why can't GHC be cross-compiled?
13:19:52 <xho> Lemmih: I wan't the array to be managed by garbage collection
13:20:01 <Japsu> Hmm
13:20:06 <Japsu> who said so, wait
13:20:13 <Japsu>  23:06   Japsu : how's cross-compiling with GHC then?
13:20:15 <Japsu>  23:06   Heffalump : it can't do it
13:20:16 <Japsu>  23:06   Heffalump : you port GHC to a new platform then compile on that
13:20:50 <mehrheit> so you port the .hc files?
13:21:00 <Japsu> Hmm
13:21:09 <Japsu> That sounds kinda chicken and egg
13:21:16 <Japsu> How does one port GHC to anything then?
13:21:31 <Heffalump> that was the bit about extreme pain and .hc files
13:21:36 <Japsu> Oh.
13:21:37 <Japsu> Right.
13:21:38 <Heffalump> those are platform-independent
13:21:39 <Japsu> Extreme pain.
13:21:42 <Heffalump> (in principle)
13:21:54 <Heffalump> I was exaggerating somewhat about the extreme pain, although I've never done it myself.
13:21:59 <Japsu> .hc, hardcore
13:22:06 <Heffalump> but I understand it's getting easier.
13:22:09 <Heffalump> "Haskell C".
13:22:11 <Japsu> :)
13:22:17 <Japsu> Hardcore sounds cooler.
13:22:41 <olsner> so, you'd go something like GHC -> *.hc -> ARM cross-gcc -> copy to the ARM -> bootstrap GHC using the cross-compiled GHC?
13:23:10 <Lemmih> xho: Doesn't matter. 'IOUArray ix a' is not guaranteed to isomorphic to an array in C.
13:23:25 <Heffalump> olsner: GHC works on ARM already, AFAIK
13:23:28 <Japsu> Yeah well. If S60 were ARM Linux, the "*.hc -> ARM cross-gcc" part might be quite a bit easier.
13:23:32 <Japsu> :)
13:23:36 <Japsu> Dunno how extensive this Open C thingy is though
13:23:47 <Heffalump> so you'd just "install GHC" if it was ARM Linux.
13:23:49 <xho> Lemmih: What about Data.Array.Storable?
13:24:17 <mehrheit> so the solution is: install gentoo on the mobile phone
13:24:23 <Japsu> mehrheit: Heh.
13:24:32 <Japsu> That'd be immensely cool
13:24:47 <olsner> (since the intermediate language is often called Core, HardCore could refer to a harder-to-read, harder-to-write, lower-level and generally cooler alternate Intermediate Language.. it'd be kinda funny too)
13:24:48 <Japsu> I wouldn't be able to make phone calls anymore, but I'd be able to ping localhost
13:24:53 <Japsu> AND run haskell programs!
13:24:59 <Japsu> YAY for Gentoo on mobile phone!
13:25:16 <Heffalump> you could just get one of those Nokias that run Linux...
13:25:44 <Japsu> They aren't phones.
13:25:50 <Japsu> They just have WLAN.
13:26:10 <Lemmih> xho: StorableArray is a C pointer with array operations defined for it.
13:26:48 <mehrheit> you could get a few of them, and make a cluster
13:27:01 <Heffalump> oh, I'd forgotten/not realised that
13:27:07 <mehrheit> with that computing power it could run emacs, so you could comfortably port ghc
13:27:18 <xho> Lemmih: newArray will allocate memory for the StorableArray, and it will be managed by the garbage collector, right?
13:27:29 <olsner> buy 50000 of them and build your own *mobile* super computer!
13:28:44 <Lemmih> xho: Yes, but you can also allocate the memory yourself.
13:28:53 <dmhouse> Is there any way to ask ghc-pkg where its package.conf file is?
13:29:37 <xho> Lemmih: using unsafeForeignPtrToStorableArray?
13:29:47 <Japsu> Huh
13:29:54 <Japsu> what a function name
13:30:03 <Lemmih> dmhouse: `ghc --print-libdir`/package.conf?
13:30:24 <dmhouse> Lemmih: nice! Thanks.
13:30:26 <Japsu> Can't quickly think of a longer one in Java.
13:30:40 <Japsu> getLastSelectedPathComponent is the longest I can think of
13:30:43 <Japsu> :P
13:31:16 <Lemmih> xho: Yes.
13:32:12 <xho> how does ghc know how to free the memory?
13:33:06 <Lemmih> xho: ForeignPtr's can have finalizaer
13:33:16 <Lemmih> xho: ForeignPtr's can have finalizers attached to them.
13:33:22 <xho> ah it all makes sense now. thanks
13:35:14 <Lemmih> You're welcome.
13:37:11 <xho> Lemmih: btw, you are in charge of hsSDL, right?
13:37:42 <Lemmih> xho: Yes.
13:37:52 <xho> are you planning on setting up a webpage for it?
13:39:17 <Lemmih> xho: Nope.
13:39:28 <xho> hm...... any particular reason?
13:40:35 <Lemmih> No need and no time. The documentation and repositories are easy to find.
13:40:56 <xho> ok
13:44:57 <sorear> r.
13:47:03 <int80_h> super happy dev house...weeeee
13:47:29 <jre2> Lemmih: would you happen to know how hSDL performs compared to other 2D engines speed/memory wise?
13:48:04 <Lemmih> jre2: SDL is pretty fast. Mostly because it doesn't actually do anything.
13:48:14 <jre2> yea, I use engine loosely
13:48:37 <sorear> Once we fix the pattern guards issue...
13:48:56 <sorear> I wonder how long it would take to bootstrap GHC using Hugs as the host compiler :)
13:49:07 <Lemmih> jre2: I only use SDL as a cross-platform window manager. All the drawing is done with OpenGL.
13:49:25 <xho> Lemmih: what are you working on?
13:49:44 <olsner> I thought GHC used some extensions that only GHC had? somewhat like how GCC requires GCC to compile itself
13:49:58 <jre2> oh, how different is that from just using hopengl then?
13:50:05 <sorear> olsner: Yes, namely pattern guards.
13:50:25 <olsner> then is it at all possible to bootstrap GHC using Hugs?
13:50:28 <sorear> olsner: which are being added to the other compilers
13:50:43 <sorear> 13:47 < sorear> Once we fix the pattern guards issue...
13:50:49 <Lemmih> jre2: OpenGL can't open windows or get input from the mouse/keyboard. You either have to use GLUT or SDL (or something third).
13:51:10 <Lemmih> jre2: And GLUT sucks balls.
13:51:22 <sorear> GLX!
13:51:39 <jre2> sorry, I meant hopenGL's GLUT (I just woke up, apparently can't think clearly yet)
13:51:42 <fasta> sorear: do you know what the difference is between :i and :t for a function?
13:52:02 <sorear> fasta: :i also displays the fixity and source location
13:52:15 <xho> glx isn't cross platform, and if you want joystick, then it's even less cross platform
13:52:16 <fasta> sorear: :i and :t also give different types
13:52:25 <sorear> fasta: Can't help you there.
13:52:30 <fasta> sorear: ok
13:52:41 <Lemmih> jre2: GLUT doesn't work properly with GHCi.
13:53:38 <jre2> Lemmih: I agree then, it looses by default then
13:54:35 <xho> (something third can also be gtk2hs)
13:54:49 <Lemmih> xho: None of my current projects involve SDL/OpenGL. I'm currently working on converting catenova to HAppS and my day job takes up the rest of my time.
13:55:02 <xho> cool
13:55:42 <jre2> I was planning on trying to write an app for procedural generation of 2d sprites, no ghci support would make that uneccessairly difficult
14:05:00 <beelsebob> can anyone remember where that comparison of distributed SCM systems was?
14:06:38 <Serge`> > [()..]
14:06:42 <lambdabot>  [()]
14:07:04 <sorear> deriving(Enum)++
14:07:15 <mehrheit> @instances ()
14:07:17 <lambdabot> Couldn't find class `()'. Try @instances-importing
14:07:20 <nominolo> anyone know why darcs send claims to be successful, but the mail doesn't reach it's target?
14:07:23 <kpreid> > [(False,())..]
14:07:24 <Serge`> ?instances Enum
14:07:25 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
14:07:25 <lambdabot>   add an instance declaration for (Enum (Bool, ()))
14:07:25 <lambdabot>     In the expression: [(...
14:07:34 <kpreid> huh
14:07:43 <sorear> nominolo: darcs send just sends mail, it doesn't magically check that it succeeds :)
14:07:43 <nominolo> i guess i need to configure sentmail or sth.
14:07:44 <kpreid> why no Enum a, Enum b => Enum (a,b)?
14:07:57 <SamB> kpreid: well...
14:07:57 <sorear> kpreid: Eh?
14:08:03 <dmhouse> kpreid: which semantics would that have, exactly?
14:08:05 <nominolo> sorear: how does it send?
14:08:06 <sorear> kpreid: it wouldn't make sense, for starters
14:08:07 <dmhouse> kpreid: diagonalisation?
14:08:10 <kpreid> oh, hm
14:08:13 <Serge`> > [(1,'a')..] :: [(a,b)]
14:08:14 <lambdabot>   'a'
14:08:15 <lambdabot>     In the expression: (1, 'a')
14:08:15 <lambdabot>     In the expression: [(1, 'a') .. ]
14:08:15 <sorear> nominolo: it sends mail
14:08:16 <SamB> what would [(1,3)..(2,0)] return?
14:08:16 <dmhouse> sorear: it could do.
14:08:27 <kpreid> it would need to be at *least* (Enum a, Bounded a) => ...
14:08:28 <nominolo> sorear: er
14:08:44 <nominolo> nominolo: using which smtp server?
14:08:48 <nominolo> er
14:08:53 <nominolo> at sorear
14:08:56 <mehrheit> > ([1..2], [3..0])
14:08:59 <lambdabot>  ([1,2],[])
14:09:02 <dmhouse> sorear: you can enumerate Z^2, for example.
14:09:10 <sorear> nominolo: it invokes the executable file named sendmail (which contrary to popular misconception HAS ABSOLUTELY NOTHING TO DO WITH the oss package sendmail)
14:09:11 <SamB> kpreid: are you sure that wouldn't be (Enum a, Enum b, Bounded b)?
14:09:13 <dmhouse> SamB: [], perhaps?
14:09:29 <kpreid> SamB: yes, more like that
14:09:36 <Serge`> > [(1,1)..] :: [(a,a)]
14:09:37 <lambdabot>   add (Num a) to the expected type of an expression
14:09:37 <lambdabot>     In the expression: 1
14:09:37 <lambdabot> ...
14:09:51 <kpreid> @src Enum
14:09:51 <lambdabot> class  Enum a   where
14:09:51 <lambdabot>     succ                     :: a -> a
14:09:51 <lambdabot>     pred                     :: a -> a
14:09:51 <lambdabot>     toEnum                   :: Int -> a
14:09:51 <lambdabot>     fromEnum                 :: a -> Int
14:09:53 <lambdabot> [3 @more lines]
14:09:57 <dmhouse> sorear: surely that depends on the system? I.e. sendmail(1) might be exim on some systems, postfix on others, but it could potentially actually be sendmail.
14:10:18 <nominolo> sorear: ok.  man sendmail works
14:10:21 <SamB> > succ maxBound
14:10:23 <lambdabot>  Add a type signature
14:10:26 <Binkley> dmhouse: right, darcs send invokes outlook on windoze systems, for example...
14:10:27 <SamB> > succ maxBound :: Int
14:10:30 <lambdabot>  Exception: Prelude.Enum.succ{Int}: tried to take `succ' of maxBound
14:10:32 <Serge`> > enumFrom False
14:10:33 <Binkley> or presumably, whatever you told windows your preferred mail app is
14:10:34 <lambdabot>  [False,True]
14:10:35 <Binkley> so it's not always sendmail
14:10:49 <nominolo> but i wonder if someone has configured it before
14:10:57 <SamB> kpreid: actually I think you'd also need Eq b
14:11:01 <dmhouse> Binkley: oh, really? I wonder if it's configurable then.
14:11:03 <nominolo> preferably with gmail
14:11:17 <kpreid> SamB: nah, compare the fromEnum of each :)
14:11:19 <Binkley> dmhouse: on Unix, there's presumably some environment variable it looks at...
14:11:24 <SamB> kpreid: that isn't safe
14:11:27 <dmhouse> nominolo: I started reading the exim manpage, then got very depressed.
14:11:38 <SamB> @type fromEnum
14:11:39 <kpreid> ah, yes
14:11:41 <lambdabot> forall a. (Enum a) => a -> Int
14:11:47 <SamB> Int is tiny
14:11:49 <sorear> dmhouse: not hard at all
14:11:51 <kpreid> whose bright idea was it to make fromEnum Int?
14:11:55 <Binkley> dmhouse: oh, there's a --sendmail-command option
14:11:56 <nominolo> dmhouse: yeah, i'd like to avoid that
14:11:58 <SamB> no clue
14:11:59 <sorear> dmhouse: dpkg-reconfigure exim
14:12:06 <Binkley> to darcs, that is
14:12:11 <sorear> nominolo: dpkg-reconfigure exim4
14:12:14 <SamB> kpreid: do you want to suggest it be changed to Integer?
14:12:15 <Binkley> the default program gets determined during configure
14:12:19 <dmhouse> nominolo: it's almost certainly possible to configure whatever MTA you have installed to send via SMTP to Gmail, but it won't be easy :)
14:12:24 <SamB> for Haskell prime?
14:12:33 <nominolo> hm
14:12:41 <nominolo> btw i'm on a mac
14:12:46 <sorear> dmhouse: it was trivial to set up exim4 to send via SMTP to the Cox smarthost
14:12:52 <sorear> dmhouse: which should google be harder?
14:13:02 <dmhouse> sorear: how did you do this?
14:13:19 <sorear> dmhouse: Debian config scripts!
14:13:19 <dmhouse> sorear: I tried to configure exim, but after a few hours spent reading the man pages, I was none the wiser.
14:13:36 <kpreid> SamB: someone's already said it: http://hackage.haskell.org/trac/haskell-prime/ticket/108
14:13:38 <lambdabot> Title: #108 (make toEnum and fromEnum take and return Integers) - Haskell Prime - Trac
14:13:45 <SamB> kpreid: oh nice
14:13:47 <dmhouse> sorear: what are they, exactly?
14:14:05 <sorear> dmhouse: ever install a program and it asks you questions?
14:14:18 <dmhouse> sorear: I see. :)
14:14:28 * dmhouse tries dpkg-reconfigure exim as instructed
14:14:41 * sorear checks if there is a mail configuration metapackage
14:14:42 <dmhouse> Gah, why isn't C-y paste everywhere?
14:15:26 <norpan> why is it paste anywhere? :)
14:15:35 <sorear> huh, looks like you want exim4-config
14:15:52 <dmhouse> sorear: already do. Do I want to dpkg-reconfigure that?
14:16:00 <SamB> dmhouse: yeah
14:16:00 <sorear> yes
14:16:36 <dmhouse> Thanks.
14:16:42 * sorear hasn't configured debian mail in about a year (testament to system stability!) and has forgotten most of the details.
14:17:09 <sorear> dmhouse: The one gotcha is that smarthost is MTA jargon for a relay server, like smtp.west.cox.net or similar
14:17:38 <dmhouse> What's smarthost, and do I want to send my mail via it?
14:17:43 <dmhouse> Oh, you said something about that. :)
14:18:18 <dmhouse> "internet site; mail is sent and received directly using SMTP" -- err, you can receieve mail over SMTP?
14:18:40 <kpreid> dmhouse: yes, by running an SMTP server.
14:19:02 <dmhouse> Does my system mail name have to be an actual domain name that's got an MX/A record?
14:19:16 <sorear> dmhouse: only if you are receiving directly
14:20:47 <sorear> dmhouse: after this, you should edit /etc/email-addresses to add a line like 'stefan: stefanor@cox.net' , otherwise your mail will be From: stefan@localhost :)
14:21:24 <dmhouse> sorear: I suspect Gmail will rewrite it anyway, but thanks
14:27:00 * fasta thinks configuring mail was the most difficult part of the Debian installation, but that was years ago, since, indeed, Debian does not require reinstalls like that "other OS". 
14:28:27 <dmhouse> sorear: done. How can I test it's working? What's the quickest way to write and send an email using exim?
14:29:15 <fasta> dmhouse: use the mail command
14:29:54 <Heffalump> echo "bar" | mail -s"foo" me@domain.com
14:30:26 <sorear> dmhouse: darcs send --to=dmhouse@gmail.com
14:30:49 <nominolo> i try msmtp now
14:31:19 <nominolo> seems to be simple enough
14:31:20 <alec> msmtp is nice, but doesn't provide a systemwide sendmail - ssmtp is nice for that
14:31:57 <nominolo> alec: does it replace sendmail?
14:32:25 <alec> ssmtp does, yes
14:33:14 <alec> nominolo: debian also has a msmtp-mta which provides sendmail (IIRC), but I've never used it
14:33:16 <fasta> Isn't the /etc/email-addresses system a bit broken?
14:33:30 <alec> I use both msmtp and ssmtp
14:33:54 <fasta> Since if it requires root rights to edit the file, it doesn't work, and if it doesn't it also doesn't work.
14:33:57 <sorear> fasta: don't know, don't care, it works and only needs to be touched when my hard drives fail :)
14:34:23 <fasta> I don't see a home dir override, but then again, I don't see the man page either
14:34:43 <Heffalump> fasta: it rewrites outgoing email addresses
14:34:54 <Heffalump> this is something that should be under the control of the sysadmin, not individual users
14:35:10 <dmhouse> Hmm, how do I tell exim what my TLS credentials are?
14:35:44 <dmhouse> Oh, /etc/exim4/passwd.client
14:37:22 <fasta> Heffalump: suppose I send something from fasta@<my made up domain>, where should it rewrite it to? The system administrator should be told this information by me, AFAIK, right?
14:38:11 <Heffalump> fasta: when you send mail using the local mail server, it controls your envelope from. Normally it'd be username@hostnameofmachine
14:38:51 <fasta> Heffalump: so, in the case the system administrator wants to hide this name, then it would be useful?
14:39:16 <fasta> Heffalump: since the reply address can be used by the user already
14:39:56 <Heffalump> you can't hide the name, it'll appear in received headers set by the receiving mail system
14:40:14 <fasta> Then what's the use?
14:40:15 <Heffalump> but if you want some other email address to be used, then that's what /etc/email-addresses is for, yes
14:40:34 <fasta> Used... for what purpose?
14:41:26 <Heffalump> in the envelope sender (and From header)
14:44:30 <fasta> All I understand is that you can change some value, but the receiving party will see the old value regardless of changing it. That seems pretty pointless to me.
14:45:00 <Heffalump> only if they read the Received headers
14:45:10 <Heffalump> which one only normally does when trying to debug problems
14:46:53 <fasta> Heffalump: ok, but why the system administrator needs to know about these email addresses is beyond me. It's probably because of security reasons, because the software cannot be trusted.
14:48:36 <Heffalump> because the system administrator is the one responsible for mail sent out by the mail server running on the machine
14:49:50 <dmhouse> Hmm, mail(1) seems to successfully send email, but I'm not seeing it come through. How can I debug this?
14:49:55 <tuukkah> well, the user can provide whatever they want in the from field
14:50:32 <Heffalump> dmhouse: check /var/log/exim/mainlog
14:50:35 <Heffalump> see if it got sent out
14:51:23 <dmhouse> Ah, I've got a load of messages like "2007-06-23 22:47:55 1I2DSV-0006Cx-QX == dmhouse@gmail.com R=smarthost T=remote_smtp_smarthost defer (-53): retry time not reached for any host"
14:52:20 <sorear> check /var/log/mail.*
14:53:14 <dmhouse> Nothing recent in there.
14:54:05 <Heffalump> pick one of those message ids (1I2DSV...QX) and grep just for that
14:54:24 <Heffalump> perhaps in /var/log/exim/mainlog.0, and zgrep /var/log/exim/mainlog.*.gz
14:54:32 <Heffalump> the earliest few entries should tell you the initial problem
14:54:51 <Heffalump> those messages are just telling you "something went wrong earlier, and I won't retry for a while to avoid wasting everyone's time"
14:56:00 <fasta> Heffalump: I agree with tuukkah on that.
14:56:25 <dmhouse> There was indeed an authentication problem earlier, but I thought I'd fixed that now.
15:00:24 * dmhouse tries exim -M
15:01:23 <Heffalump> some 'f's may help
15:01:27 <Heffalump> i.e. -Mff
15:01:39 <Heffalump> otherwise it'll just refuse until the retry timeout is reached
15:01:47 <tuukkah> would that be exim -qf
15:01:52 <Heffalump> in fact, exim -qff is generally the way to force it to rerun the entire queue
15:02:37 <dmhouse> It worked with just -M. Well, it sent it, and I've got a delivery failure report in my inbox.
15:02:47 <Heffalump> ah, ok
15:03:08 <dmhouse> It's still saying I'm david@gmail.com, despite a line in /etc/email-addresses: "david: dmhouse@gmail.com".
15:03:26 * dmhouse dislikes the fact that Unix thinks you'll have the same username everywhere
15:03:38 <Heffalump> ugh, you claimed your mail domain was gmail.com?
15:03:47 <Heffalump> that could cause all kinds of chaos, don't do it
15:03:56 <dmhouse> Okay. :)
15:04:12 <dmhouse> Does this call for another run of dpkg-reconfigure?
15:04:17 <Heffalump> I'm not aware of any situations where it does that and doesn't let you override it. It's just a convenient default.
15:04:20 <Heffalump> Guess so.
15:04:30 <Heffalump> I just edit configuration files, but I'm used to exim.
15:07:21 <agocorona> Hello guys, I have an undefined reference(_memcmp) when dynamically loading  a object file with hs.plugins. I dont know how to solve that
15:08:51 <sorear> agocorona: Not familiar with this; the author will be online in an hour or so, though
15:09:24 <agocorona> ok, lets wait
15:11:48 <dmhouse> Hmm, does fetchmail not fetch mail from myself or something?
15:12:01 * SamB wishes :r would un-evaluate any unsafePerformIOs, even if the module hasn't changed...
15:12:35 <sorear> SamB: :set -r
15:12:39 <Heffalump> dmhouse: what are you doing with it?
15:12:49 <dmhouse> Heffalump: fetching from Gmail's POP.
15:12:49 <sorear> dmhouse: you don't need fetchmail to send mail
15:13:03 <dmhouse> sorear: no, I need fetchmail to check whether my sent mail has come through or not.
15:13:14 <sorear> dmhouse: http://gmail.com :)
15:13:16 <dmhouse> I can see it through Gmail's web interface, but fetchmail doesn't seem to be fetching it.
15:13:19 <SamB> dolio: don't you mean +r
15:13:56 <falconair> Cabal docs say that I need to set "main = defaultMain" in Setup.hs ...  but the library I am trying to package doesn't have a main method ... can I just skip the "main = ..." line?
15:14:32 * LoganCapaldo uses getmail to fetch his mail from gmail (and a few other places)
15:14:32 <mauke> huh? what does your library have to do with Setup.hs?
15:14:42 <sorear> falconair: no
15:14:48 <Heffalump> dmhouse: it may only be fetching unread mail
15:15:07 <dmhouse> Heffalump: I haven't read the mail on http://gmail.com.
15:15:22 <Heffalump> it certainly shouldn't leave out mail from you
15:15:29 <Heffalump> have you tried it with verbose options to see what it's doing?
15:15:36 <falconair> it is actually Martin Erwig's "Probabilistic Functional Programming" library ... I thought I'd learn cabal by trying to package it (since ti doesn't already seem to be packaged) ...
15:16:02 <dmhouse> No, I'm currently running it in daemon mode, and it's waking up and going bck to sleep again. I'll run it verbosely.
15:16:24 <falconair> I followed the instruction and I get the following message: import Distribution.Simple
15:16:24 <falconair> main = defaultMain
15:16:56 <nominolo> falconair: yep the main is only for the setup program
15:16:57 <falconair> sorry, this message: Setup.hs:2:7: Not in scope: `defaultMain'
15:17:08 <dmhouse> Heffalump: it's certainly not fetching it, but it's definitely there, and -v doesn't give any clues.
15:17:13 <nominolo> import Distribution.Simple
15:17:29 <falconair> nominolo...oh, I think I see....
15:17:36 <dmhouse> Heffalump: can I mail you to ensure it's actually sending it?
15:18:13 <sorear> dmhouse: Or me (you already know my addr)
15:18:26 <falconair> thanks nominolo, I thought Setup.hs was supposed to import the package I was trying to package :)
15:18:30 <Heffalump> sure (ganesh@earth.li)
15:19:45 <nominolo> maybe we should advertise http://en.wikibooks.org/wiki/Haskell/Packaging more?
15:20:15 <dmhouse> Heffalump: I got a load of TLS errors, so I doubt it's come through :)
15:20:25 <Heffalump> no sign of it, certainly
15:20:30 <dmhouse> sorear: I probably do, but I doubt I've still got it hanging around.
15:21:03 <sorear> dmhouse: I mentioned it exactly 1 hour ago
15:21:23 <Heffalump> I'm going to bed soon, so sorear is probably a better test target.
15:21:28 <Heffalump> stefanor@cox.net IIRC
15:21:37 <dmhouse> Ah yeah, sorry, I remember.
15:21:43 <nominolo> dmhouse: google stops you frem pop3ing mail from yourself
15:21:49 <dmhouse> nominolo: ah!
15:21:52 <Heffalump> nominolo: why??
15:21:58 <nominolo> you can see it vio the web interface though
15:22:01 <nominolo> no idea
15:22:05 <Heffalump> is it trying to avoid mail loops?
15:22:14 <nominolo> possibly
15:22:34 * sorear guesses it has more to do with gmailfs style hacks
15:24:56 <dmhouse> Heffalump: can I send mail directly with exim, rather than through a MUA, and get it to print out a log of the SMTP conversation/
15:25:32 <nominolo> dmhouse: my msmtp setup works, btw
15:25:51 <sorear> dmhouse: you said something about TLS
15:26:01 <sorear> dmhouse: now you're talking about SMTP
15:26:06 <sorear> dmhouse: which is it?
15:26:12 <dmhouse> sorear: SMTP with STARTTLS.
15:26:29 <dmhouse> sorear: I'm apparently getting "Authentication required" from the SMTP server, which means that exim isn't properly sending my credentials.
15:27:03 <dmhouse> It should send STARTTLS, then USER dmhouse@gmail.com, then PASS <mypass>. But it's probably trying to do something before doing STARTTLS, causing smtp.gmail.com to complain.
15:27:14 <Heffalump> sorear: SMTP supports TLS..
15:27:53 <Heffalump> the point about TLS is that it is setup within the protocol it's protecting, not as a layer around it
15:27:58 <Heffalump> (AFAICT)
15:27:58 <sorear> dmhouse: I still haven't gotten your test message fwiw.
15:28:32 <dmhouse> sorear: I didn't send one to you. Heffalump didn't receive it, and I'm getting TLS errors, so I didn't bother sending one to you as well. Sorry for the miscommunication.
15:28:35 <Heffalump> dmhouse: errm, not sure.
15:28:41 <Heffalump> (re debugging)
15:29:00 <dmhouse> Perhaps I could tell mail to use the -v option to exim.
15:30:30 <dmhouse> Huh. I just managed to send a message successfully.
15:30:34 * dmhouse tries emailing sorear
15:31:18 <dmhouse> Nope, more TLS errors.
15:32:32 <dmhouse> *Sigh* I might just give up on exim and try msmtp.
15:34:36 <dmhouse> Or I might not bother. A working MTA would be nice to have, but not essential, as my MUA (VM in Emacs) speaks SMTP anyway.
15:34:53 <dmhouse> So it can deliver directly.
15:35:17 <sorear> Darcs.
15:35:50 <dmhouse> Yeah, I know, that's what it'd be nice to have it for.
15:35:53 <sorear> Besides, having a working MTA means that *all* MUAs work.
15:35:56 <dmhouse> Darcs should speak SMTP :)
15:36:10 <dmhouse> sorear: well, I only need one :)
15:36:17 <|Steve|> Ugh, setting up that stuff is horrible.
15:36:31 <sorear> dmhouse: VM understands darcs inventory files?
15:36:55 <dmhouse> sorear: "understand" in what way? VM has nothing to do with darcs...
15:37:35 <|Steve|> Getting postfix and courier-imap-ssl working took me ages.
15:40:31 <|Steve|> ages = 2 days
15:40:45 * dmhouse will be back in ten minutes
15:41:56 <|Steve|> Gah! Building ghc failed in the middle of the night and I think it just started over when I started making again.
15:43:57 <Igloo> It shouldn't have started over unless you changed something that meant it needed to
15:44:16 <|Steve|> Okay, I sure hope not.
15:55:30 <xho> what is StablePtr good for?
15:56:31 <ddarius> @. docs index StablePtr
15:56:31 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
15:56:41 <ddarius> bugger
15:56:53 <sorear> xho: Stable pointers!
15:56:57 <xho> i've read the docs, but i can't think of what they are good for
15:57:12 <sorear> xho: A stableptr is sortof the opposite of a foreign pointer.
15:57:33 <ddarius> complement
15:57:50 <sorear> A foreign pointer refers to a C object and is held by Haskell; when the Haskell garbage collector deletes the foreign pointer, the C object is finalized.
15:57:58 <LoganCapaldo> xho: imagine if you will that GHC has a copying collector, and you want to pass a haskell function into some C code
15:58:12 <LoganCapaldo> So you can make use of it
15:58:26 <sorear> A stable pointer refers to a Haskell object and is held by C; when C deletes the stable pointer, the Haskell object is no longer referenced;
15:58:32 <sorear> s/.$/./
15:58:39 <LoganCapaldo> if GHC were to garabe collect, and or move that pointer before C got its grubby hands on it, you'd have issues
15:58:52 <sorear> LoganCapaldo: GHC *does* have a copying collector.
15:59:00 <xho> but the C code can't do anything with the pointer, only give it back to haskell code
15:59:04 <LoganCapaldo> sorear: well i didn't know what it had :)
15:59:04 <sorear> xho: Right.
15:59:15 <sorear> xho: Stable pointers are opaque to C.
15:59:34 <sorear> xho: You would use them mostly as void *client_data; parameters
15:59:38 <xho> so why would i need to give a haskell object to C land, only so that C land will give it back to haskell land?
15:59:43 <xho> oh
16:00:02 <sorear> xho: Also, you can write C libraries in Haskell.
16:01:54 <xho> i'm having big problems with FunPtr. when a C function calls my haskell function via c function pointer, i just get a hang
16:04:09 <|Steve|> Wow. I don't know what Data/Tuple.hs is but it's been compiling it for 30 minutes now.
16:04:59 <Heffalump> it's probably just quite big with lots of instances for tuples of each size
16:05:21 <sorear> |Steve|: What compiler?
16:05:29 <Igloo> 30 mins is too long unless you're swapping
16:05:38 <Igloo> Or on a seriously slow machine
16:05:40 <sorear> Igloo: Is your disk light on?
16:05:56 <sorear> |Steve|: that was for you.
16:06:59 <|Steve|> Disk light? Uh, I can't see my harddrive.
16:07:37 <Heffalump> normally there's a light on your case that flashes when there's disk access
16:07:54 <Heffalump> though sometimes it's not wired up
16:07:57 <sorear> |Steve|: On most computers, there is an LED on the front panel wired to the \BUSY on the primary IDE cable
16:08:50 <|Steve|> No so much on a mac.
16:09:18 <xho> computers should have nice big lcd panels with system temperature statistics and cpu load
16:09:19 <sorear> |Steve|: Ok.. What does top say
16:09:24 <sorear> |
16:09:29 <|Steve|> My load averages are around 1.
16:09:47 <dmhouse> How is the load calculated, just out of interest?
16:09:48 <sorear> |Steve|: load average is not important here; what is the CPU usage breaksdown.
16:09:54 <|Steve|> Ah, okay.
16:09:59 <sorear> dmhouse: # of non-sleeping processes
16:10:08 <|Steve|> ghc-split is taking 99% of one process.
16:10:26 <|Steve|> Now it's running ghc-6.6.1 with 2 processes.
16:10:30 <sorear> |Steve|: Oh, that's (sadly) normal
16:10:37 <|Steve|> Ah, it finished that one just now.
16:10:40 <sorear> |Steve|: it isn't actually Data.Tuple's fault
16:10:44 <|Steve|> Now it's on to Monad.p.
16:10:56 <|Steve|> I'm sure it's my old computer.
16:11:29 <|Steve|> That was likely Monad.p_o.
16:11:29 <sorear> |Steve|: After each package is done it needs to link, which takes a looong time (5-ish minutes of disk activity on my 384MB P4)
16:11:43 <|Steve|> 384 MB?
16:11:55 <sorear> primary store
16:12:01 <|Steve|> I'm getting warnings.
16:12:08 <|Steve|> Warning: Pattern match(es) are overlapped
16:12:16 <sorear> normal. :(
16:12:20 <|Steve|> Weak.
16:12:52 <|Steve|> I try to ensure that my code has no warnings with -Wall if at all possible (obviously I don't do much haskell so I don't know what the equiv. flag is).
16:13:10 <mauke> -Wall
16:13:13 <SamB> |Steve|: heh
16:13:20 <SamB> not very obvious at all ;-)
16:13:20 <|Steve|> Heh.
16:13:39 <|Steve|> Just wait until I have questions about haskell. It'll be obvious then.
16:13:46 <sorear> |Steve|: the libraries are built with -Wall, and that warning is a non-default one
16:14:03 <|Steve|> Does anyone make a living writing haskell?
16:14:10 <sorear> |Steve|: also, I think it was in generated code.
16:14:20 <sorear> |Steve|: Language/Haskell/Parser.hs ?
16:14:30 <|Steve|> Num.lhs
16:14:39 <|Steve|> remInteger and quotInteger where the offenders.
16:14:47 <sorear> GHC/Num.lhs ... odd.
16:14:52 <|Steve|> GHC/Num.lhs:187:0:
16:14:52 <|Steve|>     Warning: Pattern match(es) are overlapped
16:14:52 <|Steve|>              In the definition of `remInteger':
16:14:52 <|Steve|>                  remInteger (S# a) (S# b) = ...
16:14:52 <|Steve|>                  remInteger (ia@(S# _)) (ib@(J# _ _)) = ...
16:14:53 <|Steve|>                  remInteger (J# sa a) (S# b) = ...
16:14:55 <|Steve|>                  remInteger (J# sa a) (J# sb b) = ...
16:14:58 <|Steve|> And similar.
16:15:51 <sorear> uhm, that's not an overlap
16:16:11 <|Steve|> I haven't the slightest clue what those even mean. What is #?
16:16:15 <sorear> assuming you pasted the whole message, that's a compiler bug :)
16:16:16 <mauke> it's a space station!
16:16:23 <sorear> |Steve|: an ancient and evil hack
16:16:25 <|Steve|> I did paste the whole message.
16:16:44 <|Steve|> There was a similar one for quotInteger.
16:16:48 <SamB> man it must be annoying to use computers with a mix of hebrew and english...
16:17:07 <sorear> |Steve|: back when GHC first decided "Let's extend Haskell!"  they decided to stick a H98-illegal symbol in all of the nonstandard identifiers
16:17:11 <sorear> |Steve|: hence #
16:17:22 <|Steve|> I try to stick to English...but why do you think that?
16:17:24 <|Steve|> sorear: Ah.
16:17:29 <SamB> sorear: do you know how those messages work?
16:17:35 <SamB> they don't include all cases in the function...
16:17:37 <sorear> |Steve|: the whole GHC.* namespace wasn't invented untill much later, but the weird names remain for compatibility
16:18:03 <|Steve|> So ghc has extensions not in h98?
16:18:13 <sorear> SamB: Not particularly, but I know "The overlap checker *really* needs to be rewritten" is a bug on trac
16:18:16 <sorear> |Steve|: yes
16:18:17 <SamB> sorear: I thought we used 'em because they make it clear when things are really really dangerous?
16:18:27 <SamB> sorear: oh, sure
16:18:38 <sorear> SamB: I thought that was what unsafe* was for.  +# is perfectly safe!
16:18:44 <SamB> er.
16:18:48 <SamB> maybe I meant "low level"
16:19:11 <SamB> obviously, the # in +# isn't just for compatibility...
16:19:41 <xho> ok i'm trying to use gdb to debug this FunPtr problem. does ghc lock a pthread mutex when a haskell function is called from the FFI?
16:21:12 <sorear> xho: probably, there are lots of fun stuff for incalls
16:21:50 <xho> well something must be going horribly wrong because the program just hangs
16:23:17 <sorear> xho: what are you passing, and how are you getting it?
16:24:09 <xho> i'm using the explanation from the docs: foreign import ccall "wrapper" mkFun :: (Int -> IO Int) -> IO (FunPtr (Int -> IO Int))
16:24:44 <mauke> whoa
16:24:45 <sorear> OK, now you have a funptr.
16:24:52 <sorear> What are you passing it to/
16:25:54 <xho> foreign import ccall unsafe "test_fun" test_fun :: CString -> FunPtr (Int -> IO Int) -> IO CInt
16:26:18 <sorear> AHA!
16:26:23 <sorear> *unsafe*
16:27:03 <Heffalump> lol
16:27:08 <sorear>    Optionally, an import declaration can specify, after the calling convention, the safety level that should be used when invoking an external entity. A safe call is less efficient, but guarantees to leave the
16:27:12 <sorear>    Haskell system in a state that allows callbacks from the external code. In contrast, an unsafe call, while carrying less overhead, must not trigger a callback into the Haskell system. If it does, the system
16:27:17 <sorear>    behaviour is undefined.
16:27:36 <sorear> second sentance describes your condition :)
16:27:37 <xho> doh!
16:28:00 <xho> this is why it's bad to copy&paste code without understanding what you are doing
16:28:17 <xho> i was wondering what that "unsafe" does..... where did you get those notes from?
16:28:38 <sorear> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
16:28:39 <lambdabot> Title: The Haskell 98 Foreign Function Interface 1.0
16:28:53 <sorear> Or, to be honest, I googled 'haskell ffi'
16:28:54 <sorear> :)
16:29:10 <sorear> I remembered reading it in the spec before.
16:30:59 <xho> alright thanks, it works!
16:32:13 <xho> now i have other problems :\
16:32:45 <|Steve|> Does anyone else find this not helpful:
16:32:47 <|Steve|> @help
16:32:47 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
16:32:49 <|Steve|> @list
16:32:49 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:33:12 <|Steve|> If it's not going to list them, then shouldn't it just give me the url in the help command?
16:33:32 <heanol> @free
16:33:32 <lambdabot> Pattern match failure in do expression at Plugin/Free/FreeTheorem.hs:54:20-34
16:33:41 <heanol> @freshname
16:33:41 <lambdabot> Hal
16:33:45 <heanol> @freshname
16:33:45 <lambdabot> Ham
16:34:06 <heanol> @yow
16:34:06 <lambdabot> Give them RADAR-GUIDED SKEE-BALL LANES and VELVEETA BURRITOS!!
16:35:51 <oerjan> |Steve|: i agree, although list is also useful since it can list related commands to a given one
16:35:55 <oerjan> @list yow
16:35:56 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
16:36:08 <dmhouse> |Steve|: it used to list them.
16:36:14 <dmhouse> |Steve|: but yes, probably.
16:36:17 <|Steve|> Ah.
16:36:33 <mauke> @ghc
16:36:33 <lambdabot> ghc says: Can't reify a non-Haskell-98 data constructor
16:36:47 <|Steve|> @ba en es testing
16:36:48 <lambdabot>   prueba
16:36:52 <xho> @quote launch
16:36:53 <lambdabot> lennart says: Should Haskell also provide unrestricted side effects, setjmp/longjmp, missile launching functions, etc?  After all, people who don't want to use them can just avoid them. :)
16:36:55 <|Steve|> Oh good.
16:36:57 <sorear> |Steve|: I think it's a bit of a relic
16:37:08 <ddarius> |Stever|: There's @listmodules and you can list the commands of a particular module
16:37:13 <sorear> |Steve|: Once upon a time, @list meant something different
16:37:15 <ddarius> @help list
16:37:15 <lambdabot> list [module|command]
16:37:15 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:37:15 <sorear> @list-all
16:37:15 <lambdabot> activity provides: activity
16:37:16 <lambdabot> babel provides: babel
16:37:16 <lambdabot> base has no visible commands
16:37:17 <lambdabot> bf provides: bf
16:37:19 <lambdabot> check provides: check
16:37:21 <lambdabot> compose provides: . compose
16:37:23 <lambdabot> dice provides: dice
16:37:25 <lambdabot> dict provides: dict dict-help all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
16:37:27 <lambdabot> djinn provides: djinn djinn-add djinn-del djinn-env djinn-names djinn-clr djinn-ver
16:37:29 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack thanks thx thank you wiki oldwiki docs source fptools hackage
16:37:30 <|Steve|> heh
16:37:32 <lambdabot> Plugin `system' failed with: IRCRaised thread killed
16:37:34 <dmhouse> Yeah. This is why it doesn't list them any more.
16:37:39 <|Steve|> That's something that should be in a pm.
16:37:43 <xho> sorear: I noticed that there is Foreign.C.Types.CJmpBuf. does this mean that ghc is compatible with setjmp/longjmp?
16:37:44 <sorear> but that got annoying fast, so they renamed it, made it admin-only, and added @list to print a URL
16:37:55 <mauke> @quote mauke
16:37:56 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
16:38:51 <oerjan> @listmodules
16:38:51 <lambdabot> activity babel base bf check compose dice dict djinn dummy elite eval fact figlet free fresh ft haddock help hoogle instances irc karma localtime log maya more offlinerc pl pointful poll pretty
16:38:51 <lambdabot> quote search seen slap small source spell state system tell todo topic type undo unlambda unmtl url version vixen where
16:38:57 <edwardk> sorear: of course @list needs to then be tweaked if you make any local plugins to point to some url of your own choosing, which gets annoying ;)
16:39:28 <ddarius> edwardk: Or you just change it to list-all
16:39:45 <edwardk> nah, i like not being spammed thank you =)
16:40:16 <ddarius> You don't have to use lambdabot over IRC
16:40:36 <sorear> Look at the file @list points to.
16:40:55 <sorear> It was very clearly optained by copy/paste from @List-all in an offline session.
16:41:11 <mgsloan> is it possible to have empty type classes?
16:41:23 <ddarius> mgsloan: Empty in what way?
16:41:32 <mauke> class Foo x
16:41:37 <ddarius> sure
16:41:45 <mgsloan> ok, cook
16:41:48 <mgsloan> *cool
16:42:01 <sorear> mgsloan:
16:42:03 <sorear> @where report
16:42:03 <lambdabot> http://www.haskell.org/onlinereport/
16:42:36 <sorear> |   class [scontext =>] tycls tyvar [where cdecls]
16:42:37 <mgsloan> working on a sensible version of the numerics prelude using multiple typeclass parameters...
16:42:43 <sorear> cdecls         ->  { cdecl[1] ; ... ; cdecl[n] }        (n>=0)
16:42:58 <mgsloan> yeah, I guess it makes sense that the where would be optional
16:43:18 <sorear> also, n=0 is allowed
16:43:53 <mgsloan> class (Addable a b a, Additive b) => Offsetable a b
16:43:54 <mgsloan> :)
16:44:29 <mgsloan> not exactly traditional math lingo, but this is for my own consumption..
16:52:15 <Svrog> when building ghc 6.7 under msys, after compiling one component the makefile complains it can't find make anymore and stops - would anyone here know how to fix that?
16:52:34 <Svrog> build continues just fine if i run make straight after that
16:52:44 <Svrog> but then halts on the next component
16:52:57 <Svrog> so i have to run make about 20 times in order to get ghc fully built
17:00:04 <xho> sorear: do you know what happens if a haskell function throws an exception in the middle of a FFI function execution?
17:00:29 <sorear> xho: It terminates the process
17:00:59 <xho> i can prevent this by catching the exception and not letting it through?
17:01:21 <sorear> yeah
17:01:49 <xho> but what if my exception handler throws an exception? can't everything in haskell potentially throw an exception, even "return ()" ?
17:02:18 <notadev> you can get bogged down in anxiety
17:02:29 <notadev> s/you/one/
17:02:47 <LoganCapaldo> that would be a mean monad that defined return as error "msg" :)
17:03:00 <notadev> heh
17:03:22 <notadev> i *think* i got that ;)
17:03:34 <xho> i was thinking more of the memory allocation failing
17:04:02 <notadev> what in your exception handler?
17:04:31 <Heffalump> you can get exceptions embedded inside error messages. Confusing, that :-)
17:04:53 <notadev> heh i find haskell confusing, full stop.
17:04:58 <mauke> error undefined
17:05:00 <xho> catch lotsofshit (\_ ->  return ())
17:05:02 <LoganCapaldo> if the meory allocation fails, it should crash and burn anyway
17:05:08 <LoganCapaldo> *memory
17:05:19 <LoganCapaldo> I don't think you want to continue at that point
17:05:33 <LoganCapaldo> at least IMO
17:05:57 <xho> i can delete unneeded stuff and try again
17:06:16 <LoganCapaldo> if it was uneeded why didn't you delete before you allocated?
17:06:29 <LoganCapaldo> hypothetical speaking of course
17:06:53 <LoganCapaldo> and that's assuming you can recover from a fialed allocation and the system is in a consistent state for you to be able to delete things
17:06:58 <xho> maybe i need to ask the user which of several objects he would rather delete
17:07:17 <LoganCapaldo> And your gonna ask him without allocating any memory how? :)
17:07:36 <LoganCapaldo> if nothing else you need to push a stack frame no?
17:07:38 <xho> in a low level language where you have full control over memory it's easy
17:07:51 <mauke> what, like asm?
17:07:53 <ddarius> > error "Error: an exc"++error "Oh Crap!"++"tion occurred."
17:07:54 <lambdabot>  Exception: Error: an exc
17:08:05 <ddarius> Interesting.
17:08:10 <LoganCapaldo> in a low level language you don't have exceptions though do you?
17:08:12 <xho> i meant like c
17:08:17 <mauke> xho: bzzt, wrong
17:08:20 <xho> event in c++ where you do have exceptions
17:08:31 <mauke> int i; /* can crash you */
17:08:37 <LoganCapaldo> and I still don't know that it's "easy"
17:08:42 <mauke> you don't have control over the stack
17:09:02 <xho> mauke: running out of stack is rarely a problem
17:09:20 <mauke> so is running out of memory
17:09:22 <mauke> > error $ "Error: an exc"++error "Oh Crap!"++"tion occurred."
17:09:23 <lambdabot>  Exception
17:09:25 <|Steve|> You've never written a recursive algorithm for a large data structure, have you?
17:09:27 <notadev> one can get bogged down in anxiety
17:09:31 <oerjan> The exception handler may not refer to all of the computation that caused the memory error, so it might be possible to free something by a new GC
17:09:45 <ddarius> mauke: Good call
17:09:47 <LoganCapaldo> running out of memory tends to imply your stack and heap have collided doesn't it?
17:09:52 <ddarius> Still interesting result.
17:10:08 <LoganCapaldo> not necessarily of course, but often
17:10:13 <notadev> yeah
17:10:14 <|Steve|> That single threaded model doesn't really make sense any more.
17:10:23 <|Steve|> Each thread has its own stack.
17:10:23 <notadev> somethings crapped out
17:10:30 <sorear> Threads don't make sense.
17:10:37 <|Steve|> They make perfect sense.
17:10:53 <mauke> I wish haskell had cooperative threads
17:11:00 <ddarius> Hugs does, or did.
17:11:04 <xho> hm... GHC docs say that it currently does not throw HeapOverflow exceptions. so what happens when it runs out of memory? crash?
17:11:07 <|Steve|> I like my threads uncooperative.
17:11:14 <mauke> does hugs guarantee no unwanted context switches?
17:11:27 <notadev> course not
17:11:32 <ddarius> mauke: In it's own system, it should.
17:11:54 <sorear> xho: Abort.
17:12:58 <xho> ouch
17:13:11 <nominolo> > error $ "bad thing" ++ undefined ++ " happened"
17:13:12 <mauke> what
17:13:13 <lambdabot>  Exception
17:13:15 <mauke> everyone does that
17:13:26 <ddarius> You'd prabably be just as fubared even if you could catch a HeapOverflow exception.
17:13:36 <nominolo> > catch $ error $ "bad thing" ++ undefined ++ " happened"
17:13:38 <lambdabot>  Add a type signature
17:13:43 <Svrog> should be relatively easy to implement cooperative threads in haskell and quite possibly using only haskell98
17:13:50 <ddarius> Svrog: It is.
17:13:59 <nominolo> > catch $ (error $ "bad thing" ++ undefined ++ " happened" :: IO ())
17:14:01 <mauke> with support for IO?
17:14:01 <lambdabot>  <(IOException -> IO ()) -> IO ()>
17:14:05 <mauke> I think you'd need select
17:14:08 <ddarius> :T catch
17:14:12 <ddarius> :t catch
17:14:15 <lambdabot> forall a. IO a -> (IOError -> IO a) -> IO a
17:14:36 <ddarius> @google "Unifying Events and Threads"
17:14:39 <lambdabot> http://www.seas.upenn.edu/~lipeng/homepage/unify.html
17:14:39 <lambdabot> Title: Unifying events and threads
17:15:53 <Svrog> ddarius: interesting
17:16:45 <Svrog> thanks for the link
17:17:17 <ddarius> @google "Poor Man's Concurrency Monad"
17:17:19 <lambdabot> http://www.cs.chalmers.se/~koen/pubs/jfp99-monad.ps
17:18:07 <desp> hm
17:18:11 <desp> @hoogle forM_
17:18:12 <lambdabot> No matches found
17:18:22 <desp> @hoogle Control.Monad.forM_
17:18:22 <lambdabot> No matches, try a more general search
17:18:27 <desp> @botsmack
17:18:27 <lambdabot> :)
17:18:29 <mauke> @index forM_
17:18:29 <lambdabot> bzzt
17:19:46 <oerjan> @src forM_
17:19:46 <lambdabot> forM_ = flip mapM_
17:20:54 <desp> I'm looking for a way to generate unique identifiers, suitable for use as keys in a hashtable
17:21:00 <desp> successive Integers?
17:21:28 <desp> I would prefer something that isn't potentially infinite in size
17:21:47 <mauke> successive Ints?
17:22:01 <desp> heh.
17:22:24 <mauke> successive ()
17:22:29 <mauke> very unique
17:22:36 <desp> indeed.
17:22:48 <desp> mauke++
17:22:50 <mauke> order now and you'll also get True, False and ((), ()) for free!
17:28:18 <olsner> @remember <mauke> order now and you'll also get True, False and ((), ()) for free!
17:28:18 <lambdabot> Done.
17:28:43 <olsner> @quote
17:28:43 <lambdabot> PoppaVic says: remember - this is akin to what I always say about "translators" or interp/compile: you can accomplish a LOT if you start thinking OO and such, but w/o OOP
17:28:54 <olsner> @quote
17:28:54 <lambdabot> Samus_ says: FUCKYOU
17:28:58 <olsner> @quote
17:28:58 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
17:29:16 <olsner> @quote oleg
17:29:16 <lambdabot> Pseudonym says: What was considered 100 milli-Olegs of type hackery five years ago is standard operating procedure these days
17:30:50 <Svrog> lol
17:31:03 <sorear> PoppaVic is in the lambdabot quote db?
17:31:03 <mauke> @quote
17:31:03 <lambdabot> Dios says: Cada vez que tizoc exprese su homosexualidad yo matare un gatito .
17:33:08 <desp> , eh
17:33:28 <dolio> @quote <mauke>
17:33:28 <lambdabot> <mauke> says: order now and you'll also get True, False and ((), ()) for free!
17:33:43 <desp> yes, olsner messed up
17:33:58 <dolio> Happens a lot.
17:34:12 <olsner> did I? I thought that was the format
17:34:24 <sorear> desp: look at Data.Unique
17:34:31 <oerjan> @quote mauke
17:34:31 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
17:34:35 <oerjan> @quote mauke
17:34:36 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
17:34:47 <SamB> @quote oleg
17:34:47 <lambdabot> simonpj says: Maybe if I had an Oleg implant I could express all this in the type system
17:34:48 <desp> sorear: whoops
17:34:54 <mauke> @quote
17:34:54 <lambdabot> DanPiponi says: Writing introductions to monads seems to have developed into an industry
17:35:01 <SamB> @quote oleg
17:35:02 <lambdabot> AshleyYakeley says: Expect a whole new batch of type shenanigans from Oleg
17:35:04 <olsner> should it be @remember nick: blah or @remember nick blah?
17:35:05 <desp> sorear: I really must read more documentation before asking questions, thanks.
17:35:06 <SamB> @quote oleg
17:35:06 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
17:35:19 <oerjan> @help remember
17:35:19 <lambdabot> quote <nick>
17:35:19 <lambdabot> remember <nick> <quote>
17:35:19 <lambdabot> Quote somebody, a random person, or save a memorable quote
17:36:17 <olsner> <nick> blah is what I get when copy-pasting in xchat
17:38:23 <oerjan> stripping off < and > (my client only has >) seems like a good idea.
17:39:30 <sorear> I'd also like it to strip off timestaps and permute actions.
17:40:07 <sorear> 14:59  * dmhouse tries exim -M
17:40:40 <|Steve|> @remember lambdabot remember <nick> <quote>
17:40:40 <lambdabot> Done.
17:40:51 <|Steve|> Heh. Oh meta humor.
17:42:03 <|Steve|> @quote lambdabot
17:42:03 <lambdabot> lambdabot says: Couldn't match kind `?? -> ? -> *' against `(* -> *) -> * -> *'
17:42:11 <desp> :D
17:42:47 <desp> `huh-huh to huh to splat`
17:43:25 <Svrog> would lambdabot be stuck in an infinite loop if it was made to remember a nickname like @remember and then asked to quote it?
17:43:39 <|Steve|> Heh.
17:43:48 <|Steve|> @remember @remember @remember
17:43:49 <lambdabot> Done.
17:43:56 <|Steve|> @quote @remember
17:43:57 <lambdabot>  @remember says: @remember
17:44:05 <|Steve|> Nope, it's too smart.
17:44:08 <Svrog> hehe
17:45:10 <kpreid> |Steve|: irc servers don't echo a client's own messages back
17:45:31 <|Steve|> Ah, I didn't know that.
17:46:22 <kaol> I remember that there were once two lambdabots on #haskell and someone made them to talk to each other iteratively, having both of them kicked out for flooding
17:46:31 <Svrog> haha
17:46:37 <|Steve|> Heh.
17:46:47 <|Steve|> @keal
17:46:47 <lambdabot> can haskell compile flash animations and java apps?
17:47:23 <sorear> kaol: that would have been about three weeks ago with me :)
17:47:38 <sorear> ?where ?where
17:47:39 <lambdabot> I know nothing about ?where.
17:47:42 <sorear> ?where loop
17:47:42 <lambdabot> I know nothing about loop.
17:47:46 <sorear> ?where recursion
17:47:46 <lambdabot> ?where recursion
17:47:46 <dolio> ?where zap
17:47:47 <lambdabot> ?where zap
17:48:04 <sorear> totally harmless as long as there is 1 bot
17:48:57 <mauke> why doesn't ?where use a leading space?
17:54:55 <agocorona> dons?
17:58:03 <sorear> maybe he
17:58:31 <sorear> 's just sleeping in, it is the weekend..
18:05:10 <LoganCapaldo> He might just not be near a computer :)
18:06:56 <Cale> Whoa, that was keal? That one sounds more like protontorpedo.
18:08:07 <hpaste>  Gwern annotated "A bot for archiving external links on Wikipedia" with "erroneous bytestring usage" at http://hpaste.org/334#a2
18:09:02 <Gwern-away> I am having a problem with the 'main = do mapM fetchArticleText $ liftM B.words $ B.getContents' line. it errors as 'Couldn't match expected type `[B.ByteString]' against inferred type `IO [B.ByteString]''
18:10:00 <kpreid> Gwern-away: mapM takes an [a] not an m [a]
18:10:08 <Gwern-away> but there's already fetchArticleText :: B.ByteString -> IO [B.ByteString] so I'm not sure why why it doesn't match
18:10:40 <kpreid> Gwern-away: you're giving mapM an IO [B.ByteString] where it wants a [B.ByteString]
18:11:18 <Gwern-away> kpreid: oh. so would a liftM mapM then work?
18:11:39 <kpreid> the result would be of IO (IO ...) -- you'd have to join it
18:11:41 <Gwern-away> (no, I guess not)
18:11:45 <LoganCapaldo> Gwern-away: just change the $ to a =<<
18:11:50 <LoganCapaldo> I think
18:11:52 <kpreid> yes
18:12:00 <kpreid> or, do it in more than one do line!
18:12:30 <LoganCapaldo> kpreid: blasphemy! :)
18:12:32 <Gwern-away> well, that changes the error message at least
18:12:34 <kpreid> do wordss <- liftM B.words $ B.getContents; mapM_ fetchArticleText wordss
18:12:46 * Gwern-away really needs to sit down and figure out monads one of these days
18:12:57 <kpreid> since you're not using the result list, use mapM_ not mapM
18:13:51 <Gwern-away> kpreid: does that actually result in an optimization or does it simply not return stuff (while still doing the same work as mapM)?
18:14:22 <LoganCapaldo> @src mapM_
18:14:23 <lambdabot> mapM_ f as = sequence_ (map f as)
18:14:30 <LoganCapaldo> @src mapM
18:14:30 <lambdabot> mapM f as = sequence (map f as)
18:14:33 <kpreid> @src sequence
18:14:34 <lambdabot> sequence ms = foldr k (return []) ms
18:14:34 <lambdabot>     where
18:14:34 <lambdabot>       k m m' = do { x <- m; xs <- m'; return (x:xs) }
18:14:45 <Gwern-away> @src sequence_
18:14:45 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
18:14:48 <kpreid> Gwern-away: I think so
18:14:48 <jfredett> hoogle is the best invention ever. period
18:15:09 <kpreid> Gwern-away: it'll avoid building the thunk which would trivially compute the list
18:15:16 <LoganCapaldo> searching by types is way easier than playing "guess the function name" that's for sure
18:15:59 <Gwern-away> no kidding
18:16:21 <SamB> now if only it knew how to find functions the names of which include (.)
18:17:11 <LoganCapaldo> SamB++
18:17:25 <LoganCapaldo> Just need to combine djinn with hoogle :)
18:17:26 <Gwern-away> wait, actually I do need mapM and not mapM_ since I need to feed the list of URLs to another function (which I do use mapM_ on)
18:17:33 <Gwern-away> djinn?
18:17:46 <LoganCapaldo> @djinn (a,b) -> a
18:17:46 <lambdabot> f (a, _) = a
18:18:14 <Gwern-away> ...did that just take a type and write a function based on it?
18:18:19 <LoganCapaldo> yes
18:18:41 <LoganCapaldo> my favorite being if
18:18:51 <Gwern-away> @djinn Bool -> Bool
18:18:51 <lambdabot> f a = a
18:18:52 <LoganCapaldo> @djinn Bool -> a -> a -> a
18:18:53 <lambdabot> f a b c =
18:18:53 <lambdabot>     case a of
18:18:53 <lambdabot>     False -> c
18:18:53 <lambdabot>     True -> b
18:19:28 <Gwern-away> impressive, but what do you use it for?
18:19:33 <Cale> @djinn (a -> Either b c) -> (b -> d) -> (c -> d) -> d
18:19:33 <lambdabot> -- f cannot be realized.
18:19:40 <Cale> @djinn (a -> Either b c) -> (b -> d) -> (c -> d) -> a -> d
18:19:40 <lambdabot> f a b c d =
18:19:40 <lambdabot>     case a d of
18:19:40 <lambdabot>     Left e -> b e
18:19:40 <lambdabot>     Right f -> c f
18:20:08 <LoganCapaldo> Parlor tricks?
18:20:28 <Cale> @djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:20:28 <lambdabot> f a b c = a (\ d -> b d c)
18:20:52 <Cale> That'd be bind in the continuation monad :)
18:21:03 <LoganCapaldo> Cale: was that >>= in Co...nvm
18:21:14 <mauke> @. pl djinn ((a -> r) -> r) -> (a -> ((b -> r) -> r)) -> ((b -> r) -> r)
18:21:14 <lambdabot> f = (. flip) . (.)
18:22:20 <Cale> @djinn callCC :: ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
18:22:20 <lambdabot> Cannot parse command
18:22:23 <Cale> err.
18:22:38 <Cale> @djinn ((a -> ((b -> r) -> r)) -> ((a -> r) -> r)) -> ((a -> r) -> r)
18:22:38 <lambdabot> f a b = a (\ c _ -> b c) b
18:22:49 <Cale> oh right, it's a question mark or something
18:23:51 <Cale> djinn isn't smart enough to write recursive programs, but it's handy if you have a complicated type you'd like some code for.
18:23:56 <desp> @help djinn
18:23:56 <lambdabot> djinn <type>.
18:23:56 <lambdabot> Generates Haskell code from a type.
18:23:56 <lambdabot> http://darcs.augustsson.net/Darcs/Djinn
18:24:04 <desp> hah
18:24:18 <ddarius> @. djinn type either
18:24:20 <lambdabot> f a b c =
18:24:20 <lambdabot>     case c of
18:24:20 <lambdabot>     Left d -> a d
18:24:20 <lambdabot>     Right e -> b e
18:24:32 <ddarius> @src either
18:24:32 <lambdabot> either f _ (Left x)     =  f x
18:24:32 <lambdabot> either _ g (Right y)    =  g y
18:27:48 * beelsebob wonders why djinn didn't do it with pattern matching
18:28:47 <LoganCapaldo> didn't do it with pattern matching?
18:28:51 <LoganCapaldo> I thought it did
18:29:04 <Saizan> mmh probably because it's easier to generate code that way..
18:29:38 <Saizan> LoganCapaldo: i think beelsebob means using clauses instead of case .. of
18:29:47 <LoganCapaldo> oh
18:30:29 <Saizan> but clauses are desugared to case anyway
18:30:40 <SamB> beelsebob: it doesn't know how to resugar ;-)
18:31:08 <sorear> I wonder...
18:31:21 <sorear> @djinn-add data Curry o = Curry (Curry o -> o)
18:31:25 <sorear> @djinn a
18:31:25 <lambdabot> Cannot parse command
18:31:26 <lambdabot> -- f cannot be realized.
18:31:32 <sorear> @djinn-env
18:31:32 <lambdabot> data () = ()
18:31:32 <lambdabot> data Either a b = Left a | Right b
18:31:32 <lambdabot> data Maybe a = Nothing | Just a
18:31:32 <lambdabot> data Bool = False | True
18:31:32 <lambdabot> data Void
18:31:34 <lambdabot> type Not x = x -> Void
18:31:36 <lambdabot> class Eq a where (==) :: a -> a -> Bool
18:31:38 <lambdabot> Error: Recursive types are not allowed: Curry
18:31:40 <lambdabot> type Cont r a = (a -> r) -> r
18:31:52 <sorear> aww
18:32:28 <Saizan> Curry paradox?
18:32:34 <sorear> yup
18:32:45 <LoganCapaldo> theres a Curry paradox?
18:32:48 <desp> HashTable or Map?
18:32:54 <Saizan> Map.
18:33:01 <LoganCapaldo> @go Curry paradox
18:33:03 <lambdabot> http://plato.stanford.edu/entries/curry-paradox/
18:33:03 <lambdabot> Title: Curry's Paradox (Stanford Encyclopedia of Philosophy)
18:33:09 <desp> Saizan: why?
18:33:23 <sorear> and yes that IS Haskell B.
18:33:38 <Saizan> LoganCapaldo: it's kind fo a generalization of the liar's one
18:33:51 <Saizan> desp: because it's pure!
18:34:07 <desp> I need it in the IO monad, anyway
18:34:18 <sorear> desp: AIUI Map is faster, too.  (quality of implementation issues)  You should time it.
18:34:20 <Gwern-away> are we allowed type declarations in 'where' clauses?
18:34:29 <sorear> Gwern-away: Yes
18:34:30 <LoganCapaldo> Saizan: I see how that could apply to recursive types
18:34:33 <Gwern-away> 'k
18:34:40 <sorear> Gwern-away: But only in the where clause of module declarations
18:34:58 <sorear> Gwern-away: Equations' where clauses must not have types.
18:35:11 <sorear> module Foo where type Moo = ()
18:35:16 <LoganCapaldo> well parts of them can have type annotations
18:35:24 <Gwern-away> sorear: I meant inside main
18:35:43 <Gwern-away> main = do ...; where foo :: foo -> foo; foo = bar x etc
18:35:48 <LoganCapaldo> main = foo where type A = Int no
18:35:49 <sorear> Oh!
18:35:54 <Gwern-away> well, seems to compile anyway
18:35:56 <sorear> Gwern-away: that's legal
18:35:57 <Saizan> i've written something like that, was i using an extension?
18:36:10 <LoganCapaldo> main = foo where f :: a -> a; f = ... yes
18:36:19 <sorear> Gwern-away: I thought you meant what LoganCapaldo was giving.
18:36:25 <LoganCapaldo> but that's an annotation, not a declaration aint it?
18:36:33 <Gwern-away> no, wasn't even paying attention to LoganCapaldo, was working on my bot
18:36:51 <Saizan> poor LoganCapaldo
18:37:07 <LoganCapaldo> thats ok, bots are more interesting than me :)
18:38:22 * ddarius reads a paper that is also more interesting than LoganCapaldo.
18:39:27 * LoganCapaldo feels conspicuously ignored
18:39:28 <Gwern-away> (zing!)
18:39:33 <SamB> @quote
18:39:33 <lambdabot> SyntaxNinja says: Let's imagine something that would be awesome.
18:39:36 <SamB> @quote oleg
18:39:36 <lambdabot> lambdabot says: I know nothing about oleg.
18:39:38 <SamB> @quote oleg
18:39:38 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
18:39:42 <Saizan> i've written a bot a week ago, and it worked just fine the first time.. amazing compared to the several runtime errors i experencied with a python one
18:39:43 <SamB> @quote oleg
18:39:43 <lambdabot> vincenz says: import Oleg
18:40:21 <Saizan> i think type families are roughly import Oleg
18:41:27 <sorear> Saizan: Think of type families as non-parametric type synonyms.
18:42:56 <Saizan> sorear: so, subtyping?
18:43:05 <sorear> no.
18:43:16 <mauke> templates?
18:43:42 <sorear> before, when you see Foo : * -> *   you know that Foo just holds objects and doesn't care what they are.
18:43:55 <sorear> but with assoc types you can have stuff like
18:44:05 <sorear> data Foo Int = [Int]
18:44:11 <sorear> data Foo Char = Bool
18:44:28 <sorear> (you need constructors)
18:44:37 <sorear> hmm.
18:44:47 <sorear> associated types are a lot like gadts
18:44:54 <sorear> data Foo where
18:45:03 <sorear>  FooA :: [Int] -> Foo Int
18:45:11 <sorear>  FooB :: Bool -> Foo Char
18:45:15 <LoganCapaldo> associated types look useful
18:45:27 <mauke> template<> struct Foo<int> { typedef int t[123]; }; template<> struct Foo<bool> { typedef char t; };
18:45:49 <sorear> mauke: yup, same idea.
18:45:51 <LoganCapaldo> mauke: good abuse :)
18:46:14 <sorear> C++'s type system is extremely underappreciated.
18:46:24 <mauke> that's because it sucks
18:46:25 <sorear> IIRC it is fully dependant.
18:46:38 <sorear> but the syntax is terrible :)
18:46:39 <Saizan> mmmh, you can also have type Elem [a] = a etc..
18:46:45 <sorear> and there is no inference
18:46:48 <sorear> Saizan: Yes!
18:46:54 <LoganCapaldo> Saizan: nice example :)
18:46:55 <ddarius> It is a lazy pure functional language.
18:47:11 <LoganCapaldo> Saizan: also harkens back to the C++ uses of such theings
18:47:49 <Saizan> sorear: can you do that with gadts?
18:48:09 <mauke> you can fake return-type based overloading in C++
18:48:15 <LoganCapaldo> template<typname T> struct Array { T elems[100]; typedef T elem_type; }
18:48:17 <ddarius> data Elem where AnElem :: a -> Elem [a]
18:48:20 <SamB> sorear: it's easier to appreciate it when you don't need to actually use C++
18:48:44 * Saizan can't parse C++
18:49:24 <Saizan> i should learn it sometime..
18:49:42 <ddarius> Saizan: Why?
18:50:37 <Saizan> ddarius: because it tends to appear in discussions :)
18:50:46 <ddarius> So?
18:51:16 <Saizan> so i'd like to have a clear idea of what it means?
18:51:35 <SamB> start with the typesystem turing machine ;-)
18:51:37 <Saizan> smae thing for scheme in oleg papers
18:51:50 <LoganCapaldo> these conversations would be more interactive if lb did type decls. :)
18:51:59 <ddarius> People don't usually talk that much using C++ about anything other than C++.
18:52:24 <LoganCapaldo> @data A a = A a
18:52:24 <lambdabot> Unknown command, try @list
18:52:42 <ddarius> LoganCapaldo: So add support for it to lambdabot.
18:52:55 <LoganCapaldo> ddarius: I'm scared :)
18:53:02 <Saizan> actually lb could just add them in the same way it supports #let
18:53:06 <Saizan> @let
18:53:08 <lambdabot> Defined.
18:53:12 <ddarius> Yep, you just paste into a file.
18:53:26 <mauke> @let data A a = A a
18:53:26 <lambdabot> Invalid declaration
18:54:07 <Saizan> i'd like ghci to support them too, so the lisp-people will stop complaining
18:54:24 <ddarius> Saizan: So add support for it to GHCi.
18:54:26 <edwardk> @seen igloo
18:54:26 <lambdabot> igloo is in #haskell-soc, #haskell-overflow, #haskell, #ghc and #darcs. I last heard igloo speak 2h 48m 48s ago.
18:55:44 <SamB> Saizan: then they'll want to be able to redefine them
18:55:46 <SamB> and save images
18:55:51 <SamB> and all sorts of foolishness
18:56:02 <sorear> just use hi
18:56:08 <LoganCapaldo> hello
18:56:20 <sorear> huh, I know I had hi installed
18:57:35 <ddarius> SamB: All of which is doable.
18:57:43 <LoganCapaldo> This hi? ftp://ftp.cs.york.ac.uk/pub/malcolm/hw00-draft.html
18:57:56 <sorear> malcomw's HMake Interactive
18:58:17 <SamB> ddarius: ... and they'll probably want let'd values to survive all of the above!
18:58:20 <sorear> works just like lambdabot
18:58:32 <sorear> and just as quickly, I might add :)
18:58:40 <ddarius> SamB: Still doable.
18:58:52 <SamB> even when they break the types!
18:59:33 <ddarius> SamB: That's when you have to start introducing some policy.
19:00:23 <SamB> also, I don't like to write an entire type definition in one line
19:00:36 <ddarius> You don't need to.
19:01:27 <SamB> and the python users will want interactive documentation access
19:01:35 <ddarius> Doable.
19:02:19 <LoganCapaldo> @. doc index Maybe
19:02:19 <lambdabot> Plugin `compose' failed with: IRCRaised Parse error: "doc"
19:02:26 <LoganCapaldo> @. docs index Maybe
19:02:26 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:02:31 <ddarius> @index Maybe
19:02:31 <lambdabot> Data.Maybe, Prelude
19:02:48 <LoganCapaldo> @docs Data.Maybe
19:02:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
19:02:51 <ddarius> @index elem
19:02:51 <lambdabot> Data.List, Prelude
19:03:06 <sorear> @index replicateM_
19:03:06 <ddarius> @index partition
19:03:06 <lambdabot> Control.Monad, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List
19:03:06 <lambdabot> Data.IntMap, Data.IntSet, Data.List, Data.Map, Data.Set
19:03:21 <sorear> @index nubBy
19:03:21 <lambdabot> Data.List
19:03:24 <sorear> @. docs index nubBy
19:03:25 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:03:32 <sorear> @. show index nubBy
19:03:32 <lambdabot> ""
19:03:38 <LoganCapaldo> Hmmmmm
19:03:52 <Saizan> @help show
19:03:52 <lambdabot> show <foo>. Print "<foo>"
19:03:58 <LoganCapaldo> @. id index nubBy
19:04:27 <LoganCapaldo> @id test
19:04:27 <lambdabot>  test
19:04:43 <LoganCapaldo> is @. broken?
19:05:00 <Saizan> does TAPL talk about dependent types?
19:05:14 <ddarius> Saizan: The table of contents is available.
19:05:18 <oerjan> @. id id test
19:05:18 <lambdabot>   test
19:05:26 <LoganCapaldo> guess not
19:05:37 <LoganCapaldo> @. id yow
19:05:37 <lambdabot>  ONE LIFE TO LIVE for ALL MY CHILDREN in ANOTHER WORLD all THE DAYS OF OUR LIVES.
19:05:51 <oerjan> @docs
19:05:51 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
19:06:00 <LoganCapaldo> @. id quote oerjan
19:06:00 <lambdabot>  oerjan says: @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
19:06:07 <SamB> @quote oleg
19:06:07 <lambdabot> OlegFacts says: Oleg solves NP-hard problems in N log N time... in the type system
19:06:17 <Saizan> @quote oleg
19:06:17 <lambdabot> lambdabot says: I know nothing about oleg.
19:06:27 <Saizan> @quote oleg
19:06:27 <lambdabot> Korollary says: an olegweek is a complex entity with an imaginary part
19:06:52 <LoganCapaldo> @. docs
19:06:52 <lambdabot> Not enough arguments to @.
19:07:11 <LoganCapaldo> @. docs id Data.Maybe
19:07:11 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Maybe.html
19:07:32 <LoganCapaldo> @docs Data.Maybe, Prelude
19:07:32 <lambdabot> Data.Maybe, Prelude not available
19:07:38 <oerjan> @. id index Maybe
19:07:48 <oerjan> it seems index is the culprit
19:07:52 <LoganCapaldo> indeed
19:08:03 <Saizan> @index Maybve
19:08:03 <lambdabot> bzzt
19:08:04 <Saizan> @index Maybe
19:08:05 <lambdabot> Data.Maybe, Prelude
19:09:04 <oerjan> probably using the wrong output function?
19:11:34 <LoganCapaldo> seems like a good guess
19:12:05 <oerjan> @help .
19:12:05 <lambdabot> . <cmd1> <cmd2> [args].
19:12:06 <lambdabot> . [or compose] is the composition of two plugins
19:12:06 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
19:12:45 <Saizan> for which monad?
19:13:03 <jfredett> hmm, if I have a datatype NumStatus a = Perfect a | Abundant a | Deficient a, can I use that with a function like:
19:13:03 <jfredett> numStatus :: Integer -> NumStatus
19:13:03 <jfredett> numStatus = <function which returns either Perfect k, Abundant k, etc.> ?
19:13:06 <MyCatVerbs> Saizan: all of them, BWAHAHAHHAHA! Alternatively, only the ones that hate kittens.
19:13:47 <oerjan> jfredett: yes, except you seem to be missing a k
19:13:49 <ddarius> jfredett: numStatus :: Integer -> NumStatus SomeType; numStatus anInteger = ...
19:13:53 <Saizan> jfredett: numStatus :: Integer -> NumStatus Integer, you mean?
19:13:55 <jfredett> oh, my bad.
19:14:02 <jfredett> well
19:14:07 <jfredett> I guess I want it to work like Maybe
19:14:16 <jfredett> but for Perfect/Abundant/Deficient numbers
19:14:22 <ddarius> It does.
19:14:25 <jfredett> so then I can write a function that only works on Perfect numbers
19:14:40 <jfredett> and eliminate this silly "Undef" thing
19:15:02 <Saizan> you don't get any guarantee that your function takes only Perfect numbers that way
19:15:23 <jfredett> even if I do Perfect Integer -> ExtPerfect Integer
19:15:35 <Saizan> Perfect is not a type constructor
19:15:39 <jfredett> hmm
19:15:41 <Saizan> is just a data constructor
19:15:42 <jfredett> I see.
19:16:01 <jfredett> so, heres what I'm aiming to do.
19:16:15 <jfredett> well actually
19:16:15 <ddarius> WHat you want is called refinement types which can be roughly encoded in Haskell.
19:16:21 <Saizan> you need newtype Perfect a = P a, data NumStatus a = Perfect (Perfect a)
19:16:24 <Saizan> ..
19:16:29 <jfredett> I have no idea what I want to do.
19:16:33 <jfredett> okay-
19:16:54 <jfredett> well- thats uglier than what I have now- :P
19:17:05 <Saizan> well NumStatus will become an union type, and yes it's uglier :)
19:17:15 <jfredett> I guess Undef isn't _that_ bad
19:18:01 <jfredett> my ultimate goal is to write some code which will return a tuple of number propertys, given a number.
19:18:21 <Saizan> partial functions are not so bad if you can check the precondition before calling them, like head
19:18:52 <ddarius> numberProperties :: Number -> (Property1, Property2); numberProperties n = (x,y) where x = ...; y = ...
19:19:01 <jfredett> vis a vis
19:19:01 <jfredett> classify :: Integer -> Classified Integer
19:19:01 <jfredett> Classified a = (NumStatus, blah blah blah)
19:19:21 <jfredett> or something like that
19:19:32 <jfredett> as an addenum to my Project Euler Library
19:19:33 <jfredett> :)
19:19:38 <Saizan> remember to fully apply NumStatus :)
19:20:26 <jfredett> ?
19:20:47 <jfredett> whatdya mean? should I be able to put Perfect/Abundant/Deficient/Undef or whatever in there?
19:20:50 <Saizan> if you have data Foo a = ... you can't use Foo as a type like that.
19:20:58 <jfredett> i see
19:21:10 <jfredett> well- right now, NumStatus is
19:21:23 <jfredett> NumStatus = Perfect | Abundant | Deficient | Undef
19:21:40 <Saizan> ah, ok :)
19:21:49 <jfredett> a wonderfully underuse of the powerful datatype system
19:21:50 <jfredett> :)
19:22:10 <oerjan> i think phantom types might be a possibility
19:22:18 <jfredett> cause it only makes sense over integers anyway
19:22:32 <jfredett> although-
19:22:37 <Saizan>  NumStatus = Perfect | Abundant | Deficient, and use Maybe NumStatus?
19:22:51 <ddarius> Aren't all Integers one of those?
19:22:51 <sorear> you can't have perfect numbers in an arbitrary ordered integral domain?
19:23:02 <oerjan> NumStatus st = NS Integer
19:23:03 <jfredett> well, then I'm juggling Just's and Nothings
19:23:14 <jfredett> sorear: you can, I just don't care about them
19:23:18 <oerjan> data Perfect ; data Abundant ; data Deficient
19:24:14 <oerjan> but only if the status really is statically determined
19:24:49 <jfredett> what I was going to say, is there a way to define a type based on the parameter? that is:
19:24:49 <jfredett> data SomeType a
19:24:49 <jfredett>      | Integer a = Foo Bar
19:24:49 <jfredett>      | Double a = Bar Baz
19:24:49 <jfredett>      | otherwise = zyzxx
19:24:51 <jfredett> ?
19:25:02 <Saizan> classify :: Integer -> (forall st. NumStatus st Integer) then? i don't think it works so well
19:25:12 <jfredett> err, s/zyzxx/zyzxx/
19:25:29 <jfredett> err, s/'s/zyzxx/zyzxx/'/s/zyzxx/Zyzxx/
19:25:31 <oerjan> jfredett: gadts, it think
19:25:40 <jfredett> oh dear, Acronyms
19:25:50 <jfredett> Algebraic DTs, right?
19:26:06 <LoganCapaldo> Generalized Algebraic DTs
19:26:07 <Saizan> 03:43     sorear : data Foo where
19:26:07 <Saizan> 03:43     sorear :  FooA :: [Int] -> Foo Int
19:26:07 <Saizan> 03:44     sorear :  FooB :: Bool -> Foo Char
19:27:03 <jfredett> hey, if they ever become extened GADTS, we could call them E GADTS! (err. supposed to sound like ee gads. sounds alot better in my head...)
19:27:17 <desp> jfredett++
19:27:50 <jfredett> ?
19:27:53 <jfredett> kickass?
19:27:59 <jfredett> @karma jfredett
19:27:59 <lambdabot> You have a karma of 2
19:28:14 <jfredett> whoo! 2! I'm prime karma'd!
19:28:15 <desp> I enjoy sentences using the word "egads"
19:28:19 <jfredett> lol
19:28:23 <sorear> Extended generalized algebraic data types sounds an awful lot like Standard generalized abstract nonsense
19:28:31 <jfredett> egadts, desp, egadts..
19:28:38 <desp> right
19:29:16 <jfredett> I hope someone writes a paper on EGADTS now...
19:29:29 <desp> with a really punny title
19:29:30 <jfredett> Algebra and Data and Types, EGADTS!
19:29:49 <Cale> @karma
19:29:49 <lambdabot> You have a karma of 46
19:29:53 <jfredett> there you go, community, thesis/dissertation title for you
19:29:58 <jfredett> go forth and dissertate
19:30:13 <jfredett> or thesise, or w/e
19:33:57 <SamB> sorear: I've never heard of SGAN
19:34:02 <SamB> I've heard of SGML though
19:34:17 <LoganCapaldo> SXGMLAN
19:34:22 <SamB> and if you use SGML for Alice in Wonderland or Dr. Suess, maybe that *would* be SGAN
19:35:01 * sorear was trying to be categorically funny
19:35:51 <desp> @karma
19:35:51 <lambdabot> You have a karma of 0
19:35:53 <jfredett> you need a functor from the sorear-funny category to the actually-funny category then... :)
19:36:34 <jfredett> if you find one, let me know- i might be able to use it to get out of the definitely-not-funny category
19:36:45 <SamB> jfredett is actually categorically funny ;-)
19:40:42 <desp> how about one-way-hash-funny? http://img256.imageshack.us/img256/7914/ermsu1.jpg
19:41:20 <LoganCapaldo> desp: I don't get it
19:41:41 <desp> I won't spoil the pleasure of getting it
19:41:55 <jfredett> ...
19:42:03 <LoganCapaldo> well would you spoil my current confusion?
19:42:08 <jfredett> omg. I get it
19:42:11 <jfredett> lol...
19:42:20 <jfredett> i think i do, anyway--
19:42:22 <desp> I already gave you a hint ;)
19:42:28 <Cale> @karma+ anyway
19:42:28 <lambdabot> anyway's karma raised to 0.
19:42:43 <jfredett> doh!
19:43:05 <jfredett> I kinda feel bad for those guys
19:43:23 <jfredett> after all that work....
19:43:57 * LoganCapaldo remains ignorant
19:44:08 <desp> LoganCapaldo: how did they get there?
19:44:32 <LoganCapaldo> aha
19:44:44 <jfredett> lol
19:44:54 <jfredett> i assume those guys put up the poles.
19:45:03 <LoganCapaldo> good thing I'm not on that construction crew
19:45:07 <jfredett> lol
19:45:12 <LoganCapaldo> because I would be of no help at all
19:45:17 <desp> :)
19:45:58 <jfredett> see- thats when you have to use some magic ID-10 T spray to get the van out
19:47:02 <Cale> It looks like there just might be enough space for the van to fit between the two posts at the bottom, but I doubt it.
19:47:39 <jfredett> that would be tough, but I bet it could happen
19:47:41 <desp> with a little luck...
19:47:43 <desp> maybe
19:47:45 <Saizan> Cale: it's a prospective effect, the van is 3.5 squares, and the poles are 3 away from each other
19:47:47 <jfredett> kinda defeats the purpose of the poles, though
19:48:06 <Cale> Saizan: there's a little more than 3 squares between them, really.
19:48:17 <Cale> A little under 4
19:48:22 <jfredett> maybe it was photoshopped.
19:48:31 <jfredett> all the ones on the left look suspiciously similar
19:48:34 <jfredett> around the tiles
19:48:54 <shapr> cinimod: Hiya Dominic!
19:50:42 <desp> @hoogle Ord k => Map k a -> k -> a
19:50:44 <lambdabot> Data.Map.(!) :: Ord k => Map k a -> k -> a
19:50:44 <lambdabot> Data.Map.findWithDefault :: Ord k => a -> k -> Map k a -> a
19:50:44 <lambdabot> Data.Map.lookup :: (Monad m, Ord k) => k -> Map k a -> m a
19:51:45 <jfredett> hmm, I have a problem. I cant test one part of my classification function for perfect numbers.
19:51:45 <jfredett> from wikipedia: "No quasiperfect numbers have been found yet..."
19:51:50 <jfredett> hmm...
19:53:38 <Saizan> test $ \x -> isQuasiPerfect x == False
19:53:48 <sorear> not!
19:54:09 <jfredett> yes, Saizan, but that doesn't test that it will ever return true
19:54:31 <jfredett> it could very well mean that isQuasiPerfect = False
19:54:34 <SamB> jfredett: well, if the test fails, you can see if you've found a quasiperfect number
19:55:16 <jfredett> well, two problems-
19:55:16 <jfredett> if a QP number exists, it's an odd square greater than 10^35, I don't think Quickcheck goes up that high...
19:55:38 <jfredett> and 2, if it did fail and find one-- I would have no way of knowing what it was, so I wouldn't be able to brag about finding it.
19:55:51 <Saizan> tests can only tell you if something is broken anyway, not prove if it's correct (unless they are exhaustive=
19:55:55 <LoganCapaldo> > 10 ^ 35 -- quickcheck could go up that high I think it would take really long
19:55:58 <lambdabot>  100000000000000000000000000000000000
19:56:19 <sorear> @test \x -> x == (0 :: I)  -- and it *would* tell you
19:56:20 <lambdabot> Maybe you meant: let list tell temp
19:56:24 <jfredett> well, Saizan, what I'm looking for is just proof that it will return true for _some_ input
19:56:24 <sorear> @check \x -> x == (0 :: I)  -- and it *would* tell you
19:56:26 <lambdabot>  Falsifiable, after 0 tests: 3
19:56:43 <dolio> one++
19:56:47 <desp> hm
19:57:02 <SamB> jfredett: you'd have to prove that there are some first, wouldn't you ?
19:57:09 <jfredett> and further that it returns true for something on the list of QP numbers.
19:57:16 <jfredett> SamB, yah, I suppose
19:57:27 <jfredett> it doesn't matter, I'll probably never need QP numbers anyway.
19:58:54 <Saizan> @source Data.Function
19:58:55 <lambdabot> Data.Function not available
20:04:05 <dankna> so, this morning I was getting rather enlightening help from Saizan and ski with http://hpaste.org/381#a1 , until I had to go
20:04:11 <jfredett> question, can I have a datatype:
20:04:12 <jfredett> data EPerfect = Almost | Quasi | Pluperfect Integer | ...
20:04:12 <jfredett> and then have my function return
20:04:12 <jfredett> isKPerfect :: Integer -> EPerfect
20:04:12 <jfredett> isKPerfect k = Plupeferect <some integer> ?
20:04:13 <dankna> any chance anybody around now knows anything about it?
20:04:26 <desp> so typeclass names and type names can't overlap?
20:04:33 <dankna> it's this thing with existential types and multiple-parameter type classes
20:04:43 <dankna> I'm pretty sure that I at least understand what I want now, which is progress...
20:04:54 <Cale> jfredett: uh, sure, except that you probably want to put some sort of condition on k.
20:05:11 <Saizan> dankna: i've found that you probably need HasMove game move | game -> move, move -> game
20:05:16 <jfredett> whatdya mean? I'm just looking to return a number.
20:05:34 <Cale> jfredett: You'd be returning an EPerfect of course, not just a number.
20:05:34 <jfredett> how would I put a condition on it?
20:05:41 <Saizan> Saizan: also, you can't print a move unless you add Show as a superclass
20:05:46 <jfredett> right-
20:05:47 <dankna> oh!  can test that out very easily.  why does it need it though?
20:06:08 <Cale> I mean, test that the number is actually Pluperfect
20:06:15 <jfredett> right
20:06:23 <LoganCapaldo> Did Saizan just address soemthing to himself?
20:06:33 <dankna> I think it was meant for me, since it seems to relate to my code :)
20:06:39 <Saizan> yes
20:06:47 <Saizan> misstyped :)
20:06:48 <jfredett> well- the problem is- a number n is called k pluperfect if the sum of its proper divisors is k*n
20:07:06 <jfredett> so i want to return Pluperfect k, to indicate that n is k Pluperfect
20:07:22 <jfredett> s/proper/improper
20:07:22 <dankna> I probably don't want to print moves anyway, except for debugging.  you mean I can't print it using the system routines, I assume; I could still print it with my own if I had some?
20:07:30 <Cale> So you probably want a guard to do that test.
20:07:44 <jfredett> okay- that makes sense.
20:08:07 <Saizan> dankna: you'd need some class constraint on move inside AnyGame that let's you convert it to something printable
20:08:28 <desp> looks like I have a similar problem
20:08:38 <Saizan> dankna: and you need move -> game because parseMove :: String -> move doesn't mention game
20:09:40 <dankna> hmmm, right...  I was basically hoping that the fact I use the move returned by that parse later on in another call that has both a move and a game in it would let it infer that
20:09:57 <hpaste>  desp pasted "Existential problem" at http://hpaste.org/384
20:10:08 <dankna> since if I'm understanding correctly, it's impossible to explicitly declare the type since it doesn't know it till runtime
20:10:12 <desp> Saizan: would you mind commenting on my problem, as well? :)
20:10:28 <LoganCapaldo> Haskell really raises a persons expectations as far as for what a language can figure out for itself at compile time.
20:10:47 <dankna> I tried the test with move -> game just now, I'm looking over the error it gives me to see if it's identical
20:12:43 <dankna> Logan: hah, yes
20:13:35 <desp> it would help if I could understand the compiler's error message
20:14:33 <dankna> desp: heh, similar to mine indeed
20:14:43 <Saizan> desp: is CURLEasyHdl c  a tuple?
20:14:53 <desp> Saizan: it's a record
20:15:30 <Saizan> desp: but return (multiInfo {easyHdlMapFld = Map.delete key (easyHdlMapFld multiInfo)}, easyHdl) gives a tuple
20:16:02 <desp> the return gives a tuple for modifyMVar
20:16:05 <Saizan> desp: however you just can't extract a value from inside StorableCURLEasyHdl like that
20:16:22 <desp> because modifyMVar takes a new MVar value, and a function return value
20:16:33 <desp> Saizan: ah. what would you suggest?
20:16:35 <hpaste>  dankna annotated "Huh - why does the instance type have to have parameters?" with "the trivial test I ran that doesn't have an obvious effect" at http://hpaste.org/381#a2
20:16:38 <Saizan> ?type modifyMVar
20:16:40 <lambdabot> Not in scope: `modifyMVar'
20:16:47 <Saizan> ?hoogle modifyMVar
20:16:48 <lambdabot> Control.Concurrent.MVar.modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
20:16:48 <lambdabot> Control.Concurrent.MVar.modifyMVar_ :: MVar a -> (a -> IO a) -> IO ()
20:17:03 <dankna> (that probably wasn't worth pasting, but owell, I did)
20:17:28 <Saizan> desp: you have to repack it inside StorableCURLEasyHdl
20:18:56 <desp> Saizan: so how do I get something out of the existential type?
20:19:42 <Saizan> desp: you don't. you can only use a class method on it to get something of a non quatified type
20:19:52 <desp> argh
20:19:54 <dankna> I believe the only way is to define a function on it which returns that field
20:20:08 <dankna> that's sort of part and parcel with why they're useful though
20:20:09 <Saizan> desp: you can't take it out because you don't know which type is it
20:20:24 <Saizan> it is
20:20:31 <dankna> it's a way of using the object even though you don't know its type, so of course you can't do operations that require you to
20:20:32 <desp> Saizan: I know it's of type parametrized with a that satisfies Storable a
20:21:02 <desp> so I thought I could write a function  extractFoo :: Storable a => ExistentialPackage -> a
20:21:06 <Saizan> dankna: ah, btw, how can parseMove input = reads input :: [(Move, String)] make parseMove :: String -> Move? have you changes the class declaration?
20:21:37 <dankna> oh, uh, did I post bits that were out of synch with each other?
20:21:40 <dankna> let me have a look at that
20:22:15 <mgsloan> hmm... I recently upgraded my ubuntu quite a bit, and now, with ghc:
20:22:15 <mgsloan> ghc Laws.hs
20:22:15 <mgsloan> compilation IS NOT required
20:22:15 <mgsloan> /usr/local/lib/ghc-6.6/libHSrts.a(Main.o): In function `main':
20:22:15 <mgsloan> Main.c:(.text+0xa): undefined reference to `__stginit_ZCMain'
20:22:15 <mgsloan> Main.c:(.text+0x24): undefined reference to `ZCMain_main_closure'
20:22:17 <mgsloan> collect2: ld returned 1 exit status
20:22:27 <Saizan> desp: you can't because ExistentialPackage contains only a single unknown a, not every a
20:22:49 <dankna> yeah, I see what you mean.  I noticed that while I was offline earlier and fixed it, yes, the class declaration is changed to match the instance one.
20:23:09 <LoganCapaldo> I don't think that type works, desp. I think it says "from an ExistentialPackage, return a value for any type thats Storable
20:23:20 <LoganCapaldo> Which is not what it does
20:23:32 <desp> extractEasyHdl :: Storable a => StorableCURLEasyHdl -> CURLEasyHdl a
20:23:36 <desp> this is what I meant
20:23:42 <dankna> I was originally going to do it the other way around, making a wrapper to extract just the first move value, but then I realized I actually do want the string that's left over after the parse, too, so I might as well do what reads wants me to do
20:23:45 <mgsloan> ah, the ghc package is not installed... i'll try that
20:24:22 <hpaste>  desp annotated "Existential problem" with "Extractor" at http://hpaste.org/384#a1
20:24:47 <desp> Saizan: hrm
20:25:21 <LoganCapaldo> desp: that's still the same problem as I undertand it. You've lost the information about _which_ storable it is, and the function claims to return any Storable (wrapped in a CURLEasyHdl)
20:25:37 <desp> right, that is the problem
20:25:56 <desp> but must the function be of only one type?
20:26:57 <desp> scratch that.
20:27:02 <LoganCapaldo> unless its a function in a type class, yeah I think it has to be of only one type
20:27:13 <desp> so it turns out that existential types won't solve my problem here
20:27:15 <Saizan> dankna: have you removed print move? i've similar code that typechecks
20:29:25 <hpaste>  Saizan annotated "Huh - why does the instance type have to have parameters?" with "this typechecks" at http://hpaste.org/381#a3
20:29:55 <dankna> oh - I had not, you said I should do that but I didn't make the connection.   but I just did and no dice.  looking at your annotation now.
20:30:39 <dankna> hm, okay... I'll just strip this down till it matches...
20:32:22 <Saizan> dankna: can you test my annotation with your compiler? i'm using ghc-6.7 maybe they have improved/fixed something
20:32:50 <dolio> @source Control.Monad.State
20:32:50 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/State.hs
20:33:40 <dankna> oh, sure.
20:34:56 <dankna> yeah, your snippet with nothing else compiles fine on my 6.6.1 ghc
20:36:29 <desp> snippet au naturelle
20:37:13 <Saizan> ?index MVar
20:37:13 <lambdabot> GHC.Conc, Control.Concurrent.MVar, Control.Concurrent
20:39:33 <Saizan> dankna: now i see! it's because you take the board twice!
20:40:27 <ed1t> is it elseif or else-if ?
20:40:30 <sorear> nominolo++
20:40:41 <ed1t> the syntax
20:40:51 <sorear> else if
20:40:56 <ed1t> thx
20:41:21 <dankna> I do?  ohhh.  yeah, I guess I do...
20:41:49 <sorear> nominolo: are you aware of darcs send --edit-description, for putting a more meaningful cover on a patch bundle?
20:42:45 <Saizan> dankna: for some weird reason the type of move is associated with the first board and so it can't match with the other
20:43:16 <ed1t> @src delete
20:43:16 <lambdabot> delete = deleteBy (==)
20:43:20 <oerjan> ed1t: you can also use guards
20:43:25 <ed1t> @src List.delete
20:43:25 <lambdabot> Source not found. You type like i drive.
20:43:41 <ed1t> wheres the source code for delete?
20:43:44 <oerjan> in many cases (like in a case)
20:43:45 <ed1t> @src deleteBy
20:43:45 <lambdabot> Source not found. Are you on drugs?
20:44:12 <treble> delete a (x:xs) | a == x = xs | otherwise = x : delete a xs
20:44:18 <treble> (in effect)
20:44:19 <oerjan> @index deleteBy
20:44:19 <lambdabot> Data.List
20:44:30 <oerjan> @src deleteBy
20:44:30 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:45:07 <oerjan> lambdabot's @src command is seriously warped
20:45:11 <Saizan> dankna: the funny part is that if you move (AnyGame board) <- takeMVar boardMVar before moveParses <- return $ parseMove input it typechecks :)
20:45:12 <desp> woop, cleverly worked around the problem by simplifying the API.  win-win!
20:45:13 <oerjan> @src groupBy
20:45:13 <lambdabot> groupBy _  []       =  []
20:45:13 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
20:45:13 <lambdabot>     where (ys,zs) = span (eq x) xs
20:45:28 <oerjan> @index groupBy
20:45:28 <lambdabot> Data.List
20:45:51 <oerjan> two functions in the same module, lambdabot finds one but not the other!
20:45:52 <ed1t> stupid me!
20:46:34 <SamB> oerjan: the data for @src is, afaik, entered manually
20:46:52 <oerjan> @list src
20:46:52 <Saizan> are lamdba bindings polymorphically limited in some way?
20:46:52 <lambdabot> source provides: src
20:47:07 <oerjan> SamB: that's ridiculous!
20:48:14 <oerjan> it can't be from IRC at any rate
20:48:24 <SamB> no, it isn't from IRC
20:48:37 <dankna> Saizan: that *is* funny!  hmmm.
20:50:01 <oerjan> anyway from http://www.haskell.org/onlinereport/list.html:
20:50:14 <oerjan> deleteBy                :: (a -> a -> Bool) -> a -> [a] -> [a]
20:50:14 <oerjan> deleteBy eq x []        = []
20:50:14 <oerjan> deleteBy eq x (y:ys)    = if x `eq` y then ys else y : deleteBy eq x ys
20:50:49 <SamB> @ask dons why deleteBy is not in @src
20:50:49 <lambdabot> Consider it noted.
20:51:32 <dankna> I guess they must be (lambda bindings).  That seems to be enough to make things work for me, but it would be nice to understand why, haha.
20:52:29 <Saizan> heh :)
20:53:54 <Saizan> this is the first type that i see MTPC mixed with existentials, too :)
20:53:59 <dankna> haha, okay.
20:54:21 <dankna> it doesn't seem like an unnecessarily complicated design though, does it?  it seems to me like both of those things really are the simplest way for what I'm doing.
20:55:09 <dankna> I definitely could never have figured this out without assistance.  So I said thanks earlier, but thanks again!
20:55:23 <dankna> And I learned stuff which is the whole point to begin with, so.
20:55:25 <Saizan> you're welcome :)
20:55:35 <|Steve|> Is it possible to write the Z-combinator in haskell? z f = (\x -> f (\y -> x x y)) (\x -> f (\y -> x x y)) isn't working for me.
20:55:52 <dcoutts> @seen dons
20:55:52 <lambdabot> dons is in #xmonad and #haskell. I last heard dons speak 20h 15m 22s ago.
20:56:00 <dcoutts> @localtime dons
20:56:00 <lambdabot> Local time for dons is Sun Jun 24 13:54:53 2007
20:56:01 <sorear> |Steve|: what does it do?
20:56:02 <ddarius> |Steve|: no.
20:56:11 <|Steve|> ddarius: I sort of suspected not.
20:56:12 <ddarius> At least not directly.
20:56:24 <|Steve|> sorear: It's just another fixed point pcombinator like the Y combinator.
20:56:27 <ddarius> sorear: CbV Y combinator.
20:56:35 <sorear> ah.
20:56:51 * jfredett hides:
20:56:57 * jfredett is afraid of combinators
20:57:01 <sorear> Any term is the pure untyped lambda calculus can be represanted using newtypes as fixpoints of contravariant functors.
20:57:08 <Saizan> ?type \x -> x x -- this in general is an infinite type, you need to go through a recurive type to make this work
20:57:11 <lambdabot>     Occurs check: cannot construct the infinite type: t = t -> t1
20:57:11 <lambdabot>     Probable cause: `x' is applied to too many arguments
20:57:36 <ddarius> Or hack equi-recursive types into the typechecker.
20:59:21 <|Steve|> Wow. ghc finished compiling.
20:59:27 <|Steve|> To the people who were helping me with this last night, ghci works just fine.
20:59:33 <Saizan> dankna: however i'm now exactly sure that you need an existential, but i know nothing of your framework
20:59:44 * oerjan wonders if lambdabot has any type that can be used for that combinator
20:59:55 <Saizan> s/now/not/
21:00:25 <dankna> well, the reason I think I need it is that most of the important work of the program happens inside a callback
21:00:47 <dankna> where the C API calls my Haskell function with a pointer that I had previously given it, identifying the game it's referring to
21:00:56 <Saizan> dankna: if you have a finite number of games you could use an union type for example data Game = G1 Game1 | G2 Game2 | ...
21:01:09 <dankna> well, I do have a finite number... hm
21:01:39 <dankna> but that doesn't let me define methods for them then, because I don't have a class
21:01:48 <|Steve|> Wow, an entire screenful of text just appeared.
21:02:08 <SamB> dankna: you could use a callback that already knows what type your game is...
21:02:17 <Saizan> you can still make Game1 .. GameN instances of that class
21:03:08 <dankna> Sam: you mean, install a different callback for each game type?  yes, I could do that.  it would be more setup on the C side of things, so I didn't want to, but that's definitely possible.
21:03:29 <dankna> but the callbacks really ought to have the same code, so how can I manage to not actually write it more than once, if I take that tack?
21:03:51 <dankna> Saizan: oh, hm.  yeah, I see.
21:04:36 <Saizan> dankna: the existential can be easier extended with more games later though
21:04:45 <Saizan> if you can make it work :)
21:05:53 * dankna nods
21:05:55 <dankna> that is why I like it :)
21:06:00 <Saizan> and you don't have to pattern match on different contructors when you receive a Game
21:06:05 <dankna> right!
21:06:07 <ed1t> say im searching through a list how do i find out the current position of a list and how to call it? im basically writing a function swap a b [....]
21:06:13 <dankna> so I only have to update things in one place, the code specific to that game
21:06:32 <dankna> instead of having one or two spots in the code that act as master lists of games and have to be updated and kept in synch
21:07:29 <Saizan> ?type findIndex
21:07:38 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
21:08:14 <oerjan> ed1t: doing things to lists by position is often a bad sign in Haskell
21:08:21 <ed1t> ooo
21:08:31 <ed1t> is there any other way for swapping elements?
21:08:34 <ddarius> oerjan: Doing things to singly-linked lists by position is often a bad sign in any language.
21:08:40 <oerjan> what are a and b?
21:08:52 <ed1t> swap a and b are the elements in the list
21:08:56 <ed1t> just swap them
21:09:06 <oerjan> so they are not indices?
21:09:26 <ed1t> swap 1 5 [5,3,2,1] -> [1,3,2,5]
21:09:35 <oerjan> ah
21:09:37 <Saizan> > let swap a b xs = swap' xs where swap' (x:xs) | x == a = b:xs | otherwise = x:swap' xs in swap 3 6 [1..10]
21:09:38 <lambdabot> Terminated
21:10:25 <Saizan> ah
21:10:30 <ed1t> ur good
21:10:31 <oerjan> swap a b l = map sw l where sw x | x == a = b | x == b = a | otherwise = x
21:10:48 <ed1t> wat does swap' mean?
21:10:50 <ed1t> the '
21:10:54 <jfredett> except, Saizan, what if we had a list [1,2,2,5]  and we wanted to swap indices 2, and 3 (indexing at 0)
21:11:06 <Saizan> it's just a name
21:11:11 <oerjan> ed1t: a helper function
21:11:14 <ed1t> ooo k
21:11:27 <jfredett> oh- they aren't indices
21:11:28 <jfredett> nvm
21:11:31 <jfredett> i misread
21:12:00 <Saizan> jfredett: i was implements it as "swap the first occurrence of a with b", missing the base case though
21:12:00 <oerjan> i don't think Saizan's solution is correct.
21:12:04 <ddarius> oerjan: Now make a version with maximal sharing.
21:12:09 <mgsloan> hmm, looks like in ghc, guards use monads
21:12:16 <ddarius> oerjan: It's obviously incorrect in a variety of ways.
21:12:31 <ddarius> mgsloan: ?
21:12:42 <ddarius> pattern guards you mean?
21:12:45 <mgsloan> yes
21:12:46 <oerjan> ed1t: as for mine, it replaces all a by b and vice versa, which may or may not be what you want
21:12:53 <dmwit> > let swap a b xs = let f x | x == a = b; | x == b = a; | otherwise = x in map f xs in swap 1 5 [0..6]
21:12:54 <lambdabot>  Parse error
21:13:14 <Saizan> ddarius: yup, wrong semantic and wrong implementation :)
21:13:20 <ddarius> dmwit: drop the ;
21:13:30 <mgsloan> I'm overloading the prelude, and got a few 'not in scope ">>"'
21:13:35 <dmwit> > let swap a b xs = let f x | x == a = b | x == b = a | otherwise = x in map f xs in swap 1 5 [0..6]
21:13:36 <lambdabot> Terminated
21:14:02 <dmwit> uh?
21:14:09 <ed1t> wat is | x == a = b | guards?
21:14:09 <oerjan> mgsloan: does this happen with do notation?
21:14:18 <oerjan> ed1t: right
21:14:22 <ddarius> > 3
21:14:24 <ed1t> i gotta learn those
21:14:25 <lambdabot>  3
21:14:38 <ed1t> > 2 + 2
21:14:38 <dmwit> ed1t: Those are normal guards.
21:14:40 <lambdabot>  4
21:15:05 <dmwit> > let f a b x | x == a = b | x == b = a | otherwise = x in f 0 1 2
21:15:06 <lambdabot> Terminated
21:15:25 * dmwit /msg's lambdabot
21:16:48 <oerjan> > map (+1) [1..10]
21:16:50 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
21:16:52 <ed1t> so x == a = b is doing if (a == a) then b ?
21:16:56 <Saizan> we could go zippery and have findPosition :: a -> [a] -> ([a],[a]) in Data.List
21:17:02 <ed1t> i mean if (x == a) then b
21:17:06 <oerjan> ed1t: yes
21:17:35 <dmwit> > let swap a b xs = let f x | x == a = b; f x | x == b = a; f x | otherwise = x in map f xs in swap 1 5 [0..6]
21:17:36 <lambdabot> Terminated
21:18:22 <desp> I need to execute freeFoo :: Foo -> IO () on every value in a Map Bar Foo
21:18:26 <dmwit> ed1t: In this case, f should replace a's with b's, and b's with a's.
21:18:35 <desp> should I convert it to a list?
21:18:35 <ddarius> It would probably be a good idea to start adding Zipper support to standard data structures.
21:18:43 <ed1t> dmwit, using map funtion
21:18:55 <oerjan> > let {swap a b l = map sw l where sw x | x == a = b | x == b = a | otherwise = x} in swap 1 5 [0..6]
21:18:56 <lambdabot> Terminated
21:19:09 <oerjan> > let {swap a b l = map sw l where {sw x | x == a = b | x == b = a | otherwise = x}} in swap 1 5 [0..6]
21:19:11 <lambdabot> Terminated
21:19:28 <dmwit> ed1t: No, on its own.  Then mapping it, does that replacement on all elements of the list... essentially "swapping" them.
21:19:28 <ed1t> got it
21:19:34 <ddarius> @docs
21:19:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
21:19:47 <oerjan> is there actually something wrong with this syntax?
21:20:06 <ed1t> pretty cool
21:20:09 <ed1t> and powerful
21:20:14 <dmwit> > let swap a b xs = let f x | x == a = b; f x | x == b = a; f x = x in map f xs in swap 1 5 [0..6]
21:20:15 <ddarius> desp: Map.fold?
21:20:17 <lambdabot>  [0,5,2,3,4,1,6]
21:20:58 <oerjan> > otherwise
21:21:00 <lambdabot> Terminated
21:21:01 <Saizan> @docs Data.Traversable
21:21:01 <lambdabot> Data.Traversable not available
21:21:03 <oerjan> wow
21:21:09 <ddarius> Well, that would explain it.
21:21:15 <dmwit> weird
21:21:16 <ddarius> @let otherwise = True
21:21:17 <lambdabot> <local>:7:0:     Multiple declarations of `L.otherwise'     Declared at: <loc...
21:21:24 <ddarius> @undefine
21:21:25 <lambdabot> Undefined.
21:21:30 <oerjan> > otherwise
21:21:31 <ddarius> > otherwise
21:21:34 <lambdabot>  True
21:21:34 <lambdabot>  True
21:21:53 <dmwit> I wonder if that was somebody's idea of a prank... =)
21:22:09 <ddarius> > let swap a b xs = map f xs where f x | x == a = b | x == b = a | otherwise = x in swap 1 5 [0..6]
21:22:11 <lambdabot>  [0,5,2,3,4,1,6]
21:22:11 <Saizan> _
21:22:24 <ed1t> can u do GUI in haskell?
21:22:29 <dmwit> gtk2hs
21:22:35 <ed1t> like simple hello world
21:22:37 <dmwit> ?faq
21:22:37 <lambdabot> The answer is: Yes! Haskell can do that.
21:22:44 <desp> dmwit++
21:22:51 <ddarius> ed1t: Haskell has a standard FFI.  You can do anything in it you can do in C.
21:23:01 <desp> if slightly painfully
21:23:08 * jcreigh snorts
21:23:10 <jcreigh> "slightly"
21:23:22 <ddarius> jcreigh: Well, you can do it in just C if you like.
21:23:36 <desp> jcreigh: actually, compared to some C++ code I've written, it actually *is* slightly ;)
21:23:45 <desp> actually!
21:23:46 <dmwit> ed1t: Don't mind them, just use gtk2hs and avoid all the FFI pain.
21:23:53 <ed1t> lol
21:23:54 <jcreigh> actually, Haskell's FFI is pretty nice. I just find it tedious to, eg, wrap struts.
21:24:17 <desp> no wonder, the FFI isn't supposed to work with Java
21:24:19 <jcreigh> of course, the whole idea of FFI is basically boilerplate code by definition, so maybe that's why I don't like it.
21:24:46 <ed1t> anybody here know Jaskell project?
21:24:55 <ed1t> Java & Haskell
21:25:03 <ddarius> Yes, C should be reflective enough that I can just ask compiled code what it's types and such are and generate bindings on the fly.
21:25:34 <desp> then it'd be Smalltalk
21:26:04 <jcreigh> Pet Peeve 0xB6: C library writers who implement some things as macros.
21:26:52 <ddarius> "Pet Peeve 0x04: CPP macros" ?
21:26:59 <jcreigh> haha. Perhaps.
21:27:52 <ed1t> haskell need an IDE
21:28:06 <dmwit> hIDE, yi, vi, emacs, Visual Haskell
21:28:13 <ddarius> eclipsefp
21:28:19 <desp> TextMate
21:28:27 <dmwit> Another IDE is exactly what is not needed; more work on the current ones would be just fine with me. =)
21:29:15 <ed1t> those are just syntax highlighting...
21:29:25 <dmwit> Which?
21:29:33 <dmwit> I think most of them have much more capability than that.
21:29:52 <ed1t> do they?
21:29:57 <ed1t> hows hIDE ?
21:30:05 <Svrog> especially yi, vi and emacs
21:30:15 <Svrog> hell emacs is not an ide, it's an operating system!
21:30:56 <dmwit> Based on the web activity, I'd guess hIDE is hIDEous.
21:31:03 <dmwit> Well, maybe not hideous.
21:31:13 <dmwit> But it probably isn't the best choice available today.
21:31:59 <ed1t> where do i get yi from?
21:32:02 <ddarius> I believe the best choices available today for comprehensiveness and reliability are vim or emacs.
21:32:04 <dmwit> ?where yi
21:32:04 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
21:32:58 <dmwit> ed1t: Do you mean an IDE written in Haskell, or an IDE for hacking Haskell?
21:33:28 <ed1t> IDE for hacking haskell
21:33:40 <dmwit> Yeah, okay.  Then I agree with ddarius.
21:33:59 <desp> @pl (\a -> \_ -> f a)
21:34:00 <lambdabot> const . f
21:34:06 <desp> @hoogle const
21:34:07 <lambdabot> Prelude.const :: a -> b -> a
21:34:07 <lambdabot> Data.Generics.Basics.constrFields :: Constr -> [String]
21:34:07 <lambdabot> Data.Generics.Basics.constrFixity :: Constr -> Fixity
21:45:21 <oerjan> @free a -> a
21:45:21 <lambdabot> Extra stuff at end of line
21:45:43 <desp> Now with even more extra stuff
21:45:48 <oerjan> @free f :: a -> a
21:45:48 <lambdabot> g . f = f . g
21:46:20 <|Steve|> What is free?
21:46:30 <oerjan> @help free
21:46:31 <lambdabot> free <ident>. Generate theorems for free
21:47:29 <|Steve|> Oh.
21:51:26 <desp> existentials--
21:51:53 <TSC> Is there a way to force evaluation of a list (but not necessarily its elements) that doesn't overflow the stack for large lists?
21:53:04 <oerjan> TSC: length?
21:53:41 <TSC> Er, yes
21:53:43 <TSC> Thanks (:
21:55:51 <desp> @pl (\f -> \_ -> f >> return ())
21:55:52 <lambdabot> const . (>> return)
21:55:59 <desp> is that an improvement in style?
21:56:30 <Saizan> ?type const . (>> return)
21:56:33 <lambdabot> forall b a a1 (m :: * -> *). (Monad m) => (a1 -> a) -> b -> a1 -> m a1
21:57:10 <oerjan> @type \f -> \_ -> f >> return ()
21:57:12 <lambdabot> forall t (m :: * -> *) a. (Monad m) => m a -> t -> m ()
21:57:58 <oerjan> that seems fishy
21:58:05 <desp> hmm.
21:58:37 <desp> see, I'm trying to do a Map.fold calling the values, which are of type IO ()
21:59:03 <oerjan> @pl \f -> (\_ -> (f >> (return ())))
21:59:03 <lambdabot> const . (>> return)
21:59:40 <oerjan> bug in @pl?
21:59:51 <Saizan> it seems
21:59:53 <sorear> desp: can't you just use traverse?
22:00:11 <desp> @hoogle traverse
22:00:12 <lambdabot> No matches found
22:00:17 <sorear> @type traverse
22:00:18 <oerjan> @pl \f _ -> f >> return ()
22:00:20 <lambdabot> Not in scope: `traverse'
22:00:20 <lambdabot> const . (>> return)
22:00:25 <sorear> @type Data.Traversable.traverse
22:00:28 <lambdabot> forall a (f :: * -> *) b (t :: * -> *). (Data.Traversable.Traversable t, Applicative f) => (a -> f b) -> t a -> f (t b)
22:00:34 <desp> ouch
22:00:52 <sorear> desp: mapM, generalized beyond reason :)
22:00:59 <oerjan> @type const . (>> return ())
22:01:02 <sorear> IO is Applicative, Map is Traverable
22:01:03 <lambdabot> forall b (m :: * -> *) a. (Monad m) => m a -> b -> m ()
22:01:17 <oerjan> @type \f -> \_ -> f >> return ()
22:01:20 <lambdabot> forall t (m :: * -> *) a. (Monad m) => m a -> t -> m ()
22:01:38 <ddarius> @pl ()
22:01:38 <lambdabot> ()
22:04:02 <desp> sorear: actually, don't I want Data.Traversable.sequence?
22:04:45 <sorear> desp: hmm.  No, you want Data.Traversable.mapM_ or perhaps Data.Foldable.*
22:05:19 <desp> "Evaluate each monadic action in the structure from left to right, and collect the results."
22:07:13 <desp> but I can't read its type
22:07:23 <desp> @type Data.Traversable.sequence
22:07:25 <lambdabot> forall (t :: * -> *) (m :: * -> *) a. (Data.Traversable.Traversable t, Monad m) => t (m a) -> m (t a)
22:07:53 <desp> Map (IO ()) -> IO (Map ())?
22:07:57 <desp> meh.
22:08:16 <desp> @type Data.Traversable.mapM_
22:08:19 <lambdabot> Not in scope: `Data.Traversable.mapM_'
22:08:26 <desp> sorear: I don't see that one in the docs
22:08:33 <Saizan> Ord k => Map k (IO ()) -> IO (Map k ())
22:08:45 <sorear> desp: Ignoring the standard libraries, what type would you *like* to see?
22:08:57 <desp> Map (IO ()) -> IO ()
22:09:04 <sorear> Really?
22:09:11 <sorear> You have a map of IO actions?
22:09:15 <desp> yes.
22:09:39 <whaleofconfusion> I am interested in other kinds of scope from lexical/dynamic, and if there is some formalism for describing arbitrary kinds of scope
22:10:07 <sorear> THen yes you want Data.Foldable.sequence_
22:10:14 <Saizan> desp, don't you want Map k a -> (a -> IO ()) -> IO () ?
22:10:24 <desp> Saizan, no, I don't.
22:10:37 <desp> I'm constructing the values with the parameter already inside.
22:10:49 <desp> otherwise there'd be no point in keeping an action in the map.
22:11:43 <desp> sorear: thanks!
22:11:57 <juhp_> yi: panic! .... loadObj: failed
22:24:11 <int-e> Haskell has the worst explanation:code ratio of all languages I know ;)
22:24:36 <juhp_> lol, hehe - yeah could well be, alas
22:25:34 <desp> int-e: hah, indeed
22:25:38 <crazy_coder> Hello everyone
22:25:57 <crazy_coder> I just wrote a function called divisors
22:25:59 <desp> int-e: I ended up writing four lines of code to solve a problem
22:26:10 <crazy_coder> divisors :: Int -> [Int]
22:26:11 <crazy_coder> divisors n = [x | x<-[1,2..n] , (n `mod` x == 0) ]
22:26:23 <desp> which took me several hours to understand and approach from various directions
22:26:30 <crazy_coder> now I wanted to write a function isPrime
22:26:33 <crazy_coder> so I did
22:26:41 <crazy_coder> isPrime :: Int -> Bool
22:26:41 <crazy_coder> isPrime n | (length(divisors n) == 2) = True
22:26:41 <crazy_coder> 	  | otherwise                 = False
22:26:59 <crazy_coder> Is it a good idea to use divisors here
22:27:26 <desp> ouch
22:28:20 <crazy_coder> The function works as it is expected
22:28:41 <crazy_coder> But is it good 'programming style' to do this ??
22:28:52 <crazy_coder> performance wise ?
22:29:07 <oerjan> using divisors in isPrime seems fair enough
22:29:19 <oerjan> although both could be slightly optimized
22:29:24 <desp> crazy_coder: I'd say it's not a question of 'programming style', but simply of choosing a better algorithm for primality testing
22:29:34 <crazy_coder> hmm
22:29:41 <int-e> try (null (drop 2 (divisors n))) for testing if the list has exactly 2 elements
22:29:49 <desp> http://en.wikipedia.org/wiki/Primality_test
22:29:50 <lambdabot> Title: Primality test - Wikipedia, the free encyclopedia
22:30:10 <crazy_coder> you mean to test only if x*x <= n right ?
22:30:11 <int-e> your divisors function is quite inefficient though, and personally I'd use a list of primes to implement divisors instead.
22:30:35 <crazy_coder> Oh Ok So I need to improve
22:30:39 <crazy_coder> Thanks
22:30:41 <crazy_coder> :)
22:30:43 <int-e> (an obvious optimization of the divisors function is to only test values up to sqrt(n), with some care for perfect squares)
22:30:59 <desp> (another obvious one would be to skip even numbers)
22:31:12 <crazy_coder> hmm
22:31:13 <desp> but that still won't be an efficient algorithm
22:31:40 <int-e> the best way to implement divisors is actually to factor the number into primes first and go from there.
22:32:50 <crazy_coder> int-e: oh right but it would make divisors inefficient by adding a clause to include only prime numbers ?
22:33:08 <int-e> crazy_coder: you can precompute a list of primes though
22:33:20 <int-e> lazily so you'll never compute more than you actually need.
22:33:33 <oerjan> finding divisors, or factoring, is in any case believed to be much more inefficient than primality testing
22:33:34 <crazy_coder> Ok
22:34:03 <crazy_coder> Thanks int-e, oerjan, desp
22:34:18 <desp> oerjen: exactly
22:34:39 <int-e> oerjan: oh. I was assuming that all numbers are reasonably small - up to 10^9 maybe.
22:34:46 <oerjan> but you need much more number theory to get efficient primality testing
22:35:01 <oerjan> int-e: well in that case...
22:36:36 <int-e> For larger numbers, yes, look at the Rabin-Miller primality test at least. (I know that it's probabilistic but it does usually well enough in practice, and is still fairly easy to understand.)
22:43:52 <Adamant> there is a deterministic method, it's just complicated and has crappy performance.
22:46:15 <psymort> Hi.  I was wondering if anyone would be able to give me some pointers on why this function I'm writing doesn't seem to be strict?  The function is as follows:
22:46:22 <psymort> delete_zipwise :: (Eq a) => [[a]] -> [[a]] -> [[a]]
22:46:28 <psymort> delete_zipwise ss [] = ss
22:46:34 <psymort> delete_zipwise ss (r:rs) = if (concat ss) == [] then ss else delete_zipwise [delete r' s | (s, r') <- zip ss r] rs
22:48:39 <psymort> It takes sublists from the second list and removes each element from the corresponding sublists in the first list.  Eg.  delete_zipwise [[1, 2], [3, 4]] [[1, 3], [2, 4]] = [[],[]]    or delete_zipwise [[1, 2], [3, 4]] [[1, 3], [2, 5]] = [[],[4]]
22:49:16 <psymort> Works ok - unless the second list (rs) is really, really big, eg:  delete_zipwise [[1, 2], [3, 4]] ((take 10000 (repeat [1, 3])) ++ [[2, 4]])
22:49:45 <psymort> In which case it just chews up space until I get an error
22:50:18 <psymort> I thought it would be strict in the first list (ss), and so it would just keep removing elements from rs without using additional space, but it seems I'm wrong...
22:53:32 <oerjan> psymort: concat ss == [] is the only thing i can see forcing evaluation of ss and only to the top constructor.
22:53:50 <psymort> If I step through that example, the first pattern match would make:  delete_zipwise [[1, 2], [3, 4]] [1, 3]:((take 9999 (repeat [1, 3])) ++ [[2, 4]]).  Then this would be resolved to:  delete_zipwise [(delete 1 [1, 2]), (delete 3 [3, 4])] ((take 9999 (repeat [1, 3])) ++ [[2, 4]]).  But then I thought the concat would force the first argment to be strict, and evaluate it to delete_zipwise [[2], [3]] ((take 9999 (repeat [1, 3]))
22:53:51 <psymort>  ++ [[2, 4]])
22:54:09 <psymort> oerjan - yeah....that's what I was hoping?  But am I missing something?
22:54:34 <oerjan> psymort: the test doesn't necessary evaluate ss deeply enough
22:54:49 <psymort> ok. Can you explain?
22:55:01 <oerjan> it needs only to evaluate until it finds an element of ss that is not []
22:55:06 <psymort> oh
22:55:09 <psymort> of course
22:55:21 <psymort> bugger! :)
22:55:47 <oerjan> for this particular case, try using length instead :)
22:56:26 <psymort> as in (length (concat ss)) == 0
22:56:28 <psymort> ?
22:56:30 <oerjan> right
22:56:37 <psymort> ok.  That is truely evil. :)
22:56:48 <Cale> btw, don't use == []
22:57:02 <Cale> There's a function called null
22:57:25 <psymort> ok - I'll look that up.  It's been years since I played with haskell - and I forget all these things :)
22:57:30 <Cale> Oh, you're trying to make it stricter?
22:57:56 <Cale> null will only evaluate the first cons
22:58:02 <psymort> Is there a more expressive way of indicating that I want ss to be strictly evaluated?  I like that using length will work - but it doesn't seem overly expressive of the intention...
22:58:14 <oerjan> like == [] but that also requires an Eq constraint
22:58:24 <Cale> Why do you want it to be strict?
22:58:39 <psymort> oerjan - I see.  That makes sense.  I'll look up null
22:58:46 <Cale> Oh, you're ending up with problems with large cases?
22:59:19 <Cale> ah, I see. You're accumulating the result.
22:59:27 <oerjan> psymort: i don't think there is a well-named predefined function
22:59:34 <psymort> cale - I want ss to be strict, because the rs list is (possibly) very, very large.  And the cost of evaluating the thunks built up on ss are much less than the space of the thunks themselves.
23:00:06 <Cale> Right, I see that.
23:00:10 <psymort> cale - especially since I want to evaluate them eventually anyway.
23:00:13 <Cale> You should write this as a foldl'
23:00:20 <Cale> (I think)
23:01:08 <psymort> oerjan - ok.  pity.  I saw some mention of DeepSeq somewhere, but I don't think it's in the standard libs.
23:01:35 <oerjan> Cale: however foldl' on the whole problem is essentially what psymort is already doing...
23:01:45 <psymort> cale - I'm not sure how I'd use foldl' to do this?
23:03:12 <oerjan> you could define forceSpine l = foldl' id l l, i think
23:04:53 <oerjan> btw maybe you want to do a filter (not . null) ss ?
23:05:19 <oerjan> er, maybe not
23:05:25 <desp> @bo
23:05:27 <desp> @bot
23:05:53 <psymort> oerjan - no.  I want the same number of sublists out as went in, just with all the appropriate elements removed.
23:06:14 <psymort> oerjan - forceSpine?  Hmm...need to go do some reading.  Why Spine?
23:06:33 <oerjan> the spine of a list are its constructors
23:06:42 <oerjan> as opposed to its elements
23:06:51 <psymort> ok, that makes sense then
23:07:02 <psymort> So your forcing it to evaluate it's constructors.
23:07:24 <psymort> And the identity function is strict in it's first argument?
23:07:53 <oerjan> it may be better than a true deepSeq if you don't actually want the elements forced
23:08:05 <oerjan> psymort: i should sincerely hope so :)
23:08:54 <psymort> oerjan - that makes sense
23:15:09 <Cale> hmm
23:15:40 <Cale> This is simpler to write after transposing. Also, you can map nub over the list of removals...
23:16:23 * oerjan predicts Cale will turn delete_zipwise into a pointfree one-liner :)
23:18:35 <oerjan> but if you transpose won't you essentially force most of the gigantic rs into memory?
23:19:11 <Cale> hmm, doesn't seem so bad here
23:19:15 <Cale> deleteZipwise ss rs = zipWith (\\) ss (map nub (transpose rs))
23:19:56 <Cale> Oh, hehe, yeah, perhaps it is.
23:21:12 * LoganCapaldo still sees points, although it is one line
23:21:36 <Cale> Yeah, that's not really worth points-freeing
23:22:00 <Cale> Well, there's a cheesy thing you can do, but it's cheating :)
23:22:13 * psymort is still trying to figure out how that works.
23:22:17 <Cale> You can nub the deletions list.
23:22:31 <LoganCapaldo> You're clearly not a true member of the PLF
23:22:33 <Cale> deleteZipwise ss rs = zipWith (\\) ss (map nub (transpose (nub rs)))
23:22:40 <Cale> PFL?
23:22:46 <LoganCapaldo> (Points Liberation Front)
23:22:50 <Cale> ah
23:23:04 <Cale> I thought it was the points-free league
23:23:06 <desp> Point Less Fight?
23:23:43 <LoganCapaldo> points free league isn't quite militant-sounding enough, don't you agree?
23:24:48 * LoganCapaldo cheats
23:25:10 <LoganCapaldo> @pl (\ss rs -> zipWith (\\) ss (map nub (transpose (nub rs))))
23:25:25 <Cale> aw, don't cheat
23:25:32 <Cale>  (. (map nub . transpose . nub)) . zipWith (\\)
23:25:35 <Cale> obviously
23:25:53 <LoganCapaldo> gross
23:25:59 <LoganCapaldo> put em back
23:26:01 <LoganCapaldo> :)
23:26:08 <Syzygy-> Front de Liberation des Pointes
23:26:09 <Syzygy-> :)
23:27:02 <crazy_coder> Hello whats wrong with this
23:27:04 <crazy_coder> matches::Int ->[Int] ->[Int]
23:27:04 <crazy_coder> matches n [] = []
23:27:04 <crazy_coder> matches n (x:xs) | (x == n) = x : matches xs
23:27:04 <crazy_coder> 	         | otherwise = []: matches xs
23:27:22 <Cale> It's clearly returning a list of lists
23:27:31 <Cale> Because of the second clause
23:27:38 <LoganCapaldo> crazy_coder: and therefore your type is wrong
23:27:58 <treble> also, you flooded to the channel ;)
23:27:59 <crazy_coder> I want to return a list of integers
23:28:04 <Cale> Are you looking for filter (==n) ?
23:28:05 <crazy_coder> sorry for that
23:28:09 <crazy_coder> yeah
23:28:15 <oerjan> crazy_coder: drop the []:
23:28:20 <crazy_coder> but not using pre-defined  function
23:28:24 <crazy_coder> *functions
23:28:27 <Cale> Yeah, you don't want that []:
23:28:35 <Cale> | otherwise = matches xs
23:28:46 <crazy_coder> oh Ok
23:28:54 <crazy_coder> Is this the only problem ?
23:28:57 <Cale> yep
23:29:01 <crazy_coder> thanks
23:29:02 <crazy_coder> :)
23:29:06 <psymort> cale - I'm just getting back into haskell.  Is there a good reference resource online I can use to figure out that function you wrote :)
23:29:13 <crazy_coder> Sorry for flooding the channel ;)
23:29:20 <Cale> crazy_coder: no problem
23:29:36 <Cale> psymort: Well, you should certainly know about the prelude and the GHC library docs
23:29:45 <Cale> http://haskell.org/onlinereport/
23:29:48 <Cale> that's the report
23:30:08 <psymort> yeah - I'm using that (& google :) )
23:30:09 <Cale> Chapter 8 (Standard Prelude) and chapters 12 through 27 are interesting
23:30:13 <crazy_coder> Sorry I am getting an error
23:30:19 <psymort> Googling '\\' doesn't work so well though ;-)
23:30:19 <crazy_coder> should I paste it ?
23:30:21 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/index.html
23:30:26 <treble> !paste
23:30:26 <hpaste> Haskell paste bin: http://hpaste.org/
23:30:28 <Cale> psymort: It's in the list library
23:30:32 <oerjan> @hoogle (\\)
23:30:35 <Cale> crazy_coder: sure
23:30:41 <psymort> cool
23:30:47 <Cale> crazy_coder: It might be the indentation?
23:30:50 <oerjan> lambdabot is sleeping
23:30:53 <LoganCapaldo> @type \n -> foldr (.) id . map (\x -> if x == n then (x:) else id) []
23:30:57 <Cale> crazy_coder: Your guards weren't lined up
23:31:07 <LoganCapaldo> She is?
23:31:08 <treble> When you pasted, there was a tab
23:31:09 <LoganCapaldo> doh
23:31:12 <psymort> cale - list difference.  cool.
23:31:15 <crazy_coder> Cale: No they are in the actual code
23:31:24 <treble> tabs are 8 spaces (but your editor might not know that)
23:31:27 <HWSOD> hey is there a more elegant way of doing this
23:31:44 <oerjan> Cale: guards don't need to be lined up
23:31:47 <HWSOD> getMoveAI us them game =
23:31:48 <HWSOD> 	do
23:31:50 <HWSOD> 		winingMove <- getMoveThat Win
23:31:51 <Cale> Yeah, one thing everyone using Haskell should do is to configure their editor not to produce tab characters.
23:31:51 <HWSOD> 		tieingMove <- getMoveThat Tie
23:31:53 <HWSOD> 		return maybe firstPossibleMove id $ msum [winingMove, tieingMove]
23:31:54 <HWSOD> 	where
23:31:56 <HWSOD> 		firstPossibleMove = head gamesPosibleToMoveTo -- getMove should not be called if there are no posible moves
23:31:58 <HWSOD> 		--GetMoveThat looks for a game that evals to lookingFor and returns the move that produces that game if it finds it and nothing other wise
23:31:59 <HWSOD> 		getMoveThat :: WinLoseOrTie -> IO (Maybe (Int,Int))
23:32:27 <treble> elegant way to flood the channel?
23:32:27 <psymort> cale - :set ts=4 sw=4 expandtab
23:32:33 <psymort> cale - it's rule no. 1
23:33:05 <HWSOD> whats flooding a channal?
23:33:16 <Cale> I also like smarttab
23:33:49 <desp> HWSOD: try using http://hpaste.org to show us code
23:33:51 <Cale> HWSOD: Putting more than a few lines of text into it :)
23:33:54 <psymort> cale - I'm assuming that (nub rs) must accumulate state somehow so it is still lazy over rs?
23:34:17 <treble> > head (nub [1..])
23:34:34 <Cale> psymort: yeah
23:34:42 <Cale> psymort: There's not really 'state' though.
23:34:51 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/385
23:35:04 <crazy_coder> Thats my paste
23:35:13 <desp> woop
23:35:15 <psymort> cale - what do you mean?  How would it tell which elements it's seen before then?
23:35:23 <Cale> nub [] = []; nub (x:xs) = x : nub [y | y <- xs, y /= x]
23:35:33 <Cale> It's productive, not tail-recursive.
23:35:43 <crazy_coder>  http://hpaste.org/385
23:35:45 <LoganCapaldo> crazy_coder: you still need to pass matches n again
23:36:05 <Cale> er, yeah
23:36:07 <Cale> sorry :)
23:36:09 <LoganCapaldo> it won't "remember" from invocation to invocation
23:36:11 <crazy_coder> LoganCapaldo: yeah
23:36:14 <crazy_coder> So silly of me
23:36:16 <Cale> There was another problem :)
23:36:16 <crazy_coder> Sorry
23:36:21 <crazy_coder> :)
23:36:25 <crazy_coder> Thankls
23:37:30 <psymort> cale - ow.  I think there'd be a space problem there for a very big rs!
23:37:47 <Cale> psymort: Well, it saves you from a space problem in this case.
23:37:58 <Cale> But yeah, there's still problems with this
23:38:12 <Cale> If rs is big and doesn't contain lots of duplicates... :)
23:38:12 <crazy_coder> Cale: But still I didn't understand how initially I was getting a type error for [] : matches ......
23:38:29 <Cale> crazy_coder: Well, what's the type of [] : xs?
23:38:33 <Cale> for any xs
23:38:34 <crazy_coder> Oh
23:38:37 <crazy_coder> Got
23:38:38 <crazy_coder> It
23:38:39 <hpaste>  LoganCapaldo annotated "(no title)" with "You could do something liek this, although its maybe overkill for this" at http://hpaste.org/385#a1
23:38:40 <psymort> cale: yeah.  which is probably true in my case.
23:38:40 <Cale> It's got to be a list of lists
23:38:41 <crazy_coder> sorry
23:38:46 <crazy_coder> yeah
23:38:55 <crazy_coder> [] is inserted in front of the list
23:39:07 <crazy_coder> i got confused
23:39:27 <crazy_coder> I was thinking is means nothin should be inserted at the front
23:39:31 <crazy_coder> but i got it
23:39:35 <crazy_coder> Thanks
23:40:01 <mgsloan> random: List is a good representation for streams, but not lists
23:40:18 <Cale> mgsloan: hm?
23:40:24 <psymort> cale & oerjan: thanks for your insights.  I'm going to go read some more preludes and play offline a bit.  Really useful stuff guys :)
23:40:45 <Cale> psymort: I'll writing a properly efficient one for you
23:40:51 <crazy_coder> psykotic: play what ?
23:41:36 <mgsloan> Cale: Well, List is a good representation for streams/iterators, but it isn't a good default for, say, strings
23:41:50 <LoganCapaldo> crazy_coder: if you want to use [] as nothing you could write it in the list monad: matches n xs = do { x <- xs; if x == n then return x else [] }
23:42:12 <mgsloan> (the random: thing was just indicating that it's not exactly on topic...)
23:42:30 <treble> guard (x == n)
23:42:48 <LoganCapaldo> treble: yeah but then you don't get to type "[]" :0
23:42:51 <crazy_coder> LoganCapaldo: I haven't reached monads yet. Still learning. Thanks for the advice though
23:42:55 <crazy_coder> :)
23:43:00 <treble> LoganCapaldo: :-p
23:43:35 <psymort> cale: you don't have to - but I'd love to see what it'd be and then try and figure out how it works :)
23:43:42 <treble> "nub" is useful when you don't have an instance of Ord
23:45:36 <Cale> nub is also good when you have an infinite list
23:46:11 <treble> but a version that carried along a Data.Set, say, would still perform better on a non-trivial infinite list
23:46:27 <treble> like [1,1..]
23:46:52 <Cale> Well, that one will be nonterminating no matter what you do
23:46:57 <Cale> 1:_|_
23:46:57 <psymort> cale - but it'll have to build up a list of thunks as large as the number of unique elements in the list
23:47:21 <Cale> psymort: limited by how many elements you actually ask for, of course
23:47:30 <psymort> cale: true
23:47:32 <treble> Cale, I don't mean: toList . fromList
23:47:36 <Cale> Which is proportional to the memory for the resulting list.
23:47:40 <Cale> treble: I know.
23:48:05 <Cale> treble: You mean carry along a Data.Set of the removals.
23:48:27 <treble> sure, so that nub [1..] doesn't return elements in quadratic time
23:48:29 <treble> was all
23:49:17 <hpaste>  HWSOD pasted "getMoveAI" at http://hpaste.org/386
23:49:59 <treble> (quadratic time based on position in the list)
23:50:14 <treble> (obviously the computation doesn't terminate)
23:54:41 <HWSOD> @Hoogle nun
23:54:47 <HWSOD> @Hoogle nub
23:55:31 <treble> Data.List.nub :: Eq a => [a] -> [a]
23:58:13 <HWSOD> nub would be very useful for the implementation of combinatorial games i was building (the only good way to make 2 * 2 == 4 take 3 minutes I've writen)
23:59:05 <HWSOD> is there any suport for partial orderings in haskell?
