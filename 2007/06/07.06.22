00:00:01 <dons> what's the contents of your .buildinfo file?
00:00:19 <stevan> its whatever the default is.
00:00:22 <dons> (interestingly, no one's reported this problem recently. perhaps it was fixed in darcs?)
00:00:32 <dons> stevan: can you show me the contents :-) its set by ./configure
00:00:43 <dons> stevan: also, is that X11-extras from hackage?
00:00:55 <stevan> yes
00:00:59 <sjanssen> ah, nevermind.  The fixity of 'ok' was just off
00:01:08 <dons> stevan: ah, yes, http://xmonad.org/faq.html#x11
00:01:10 <lambdabot> Title: xmonad : frequently asked questions
00:01:37 <hpaste>  s annotated "x11_extras" with "(no title)" at http://hpaste.org/357#a1
00:01:44 <dons> sjanssen: am i right in thinking we've not seen this missing Xinerama ld error in the darcs versoin, because its fixed/
00:02:03 <dons> stevan: yeah, that -R/usr/X11R6/lib looks wrong
00:02:17 <dons> you should be able to work around it by removing it, then continuing with the 'build' phase
00:02:30 <sjanssen> dons: no, I don't think it is fixed
00:02:32 <dons> or by adding that path to your extra-lib-dirs: field in the .cabal file
00:03:04 <dons> sjanssen: so again, its the -R thing some cabals like to insert (?)
00:03:41 <sjanssen> dons: -R? huh?
00:04:13 <dons> sjanssen: some cabals seem to insert a bogus -R/my/path after -L/my/path in the buildinfo file
00:04:28 <sjanssen> oh, I have no idea
00:05:03 <dons> stevan: anyway, you can fix it by setting the path as in the faq i linked to.
00:05:40 <stevan> working on it.
00:05:49 <DRMacIver> Morning
00:06:09 <dons> morning DRMacIver
00:06:26 * dons hunts around for a fun puzzle to distract DRMacIver from work
00:07:13 <timthelion> is he a rival or something?
00:07:26 <dons> no, but he likes puzzles in the morning.
00:08:44 <dons> DRMacIver: btw, ever thought of putting your blog on planet.haskell.org ?
00:11:33 <DRMacIver> There's very little Haskell content to it really.
00:11:45 <sorear> I'm doing something massively unorthodox with the qhc parser - completely removing the lexical distinction between varids and conids.  it will be interesting to see how this turns out
00:12:05 <sorear> DRMacIver: What does that have to do with anything?
00:12:23 <DRMacIver> Heh
00:12:26 <goltrpoat> sorear:  i've been trying to do that
00:12:52 <sorear> DRMacIver: A blog is eligible to Planet if it is being written by somebody who is active in the Haskell community, or by a Haskell celebrity; also eligible are blogs that discuss Haskell-related matters frequently,
00:12:53 <goltrpoat> i had varids, conids, varops, conops, and qualified versions of those, all as separate type synonyms
00:12:59 <goltrpoat> which got very unwieldy very quickly
00:13:11 <sorear> I just have varids and varsyms.
00:13:32 <DRMacIver> I don't think I qualify for any of those. :)
00:13:43 <dons> lazy java strings sound fun though :-)
00:13:56 <dons> at least under the 'humour' category mwhha
00:13:56 <sorear> Import declarations give me a S/R conflict (is import qualified  importing 'qualified', or qualified?)
00:14:00 <DRMacIver> Ha
00:14:07 <sorear> but that's the only issue I've seen so far.
00:14:46 <goltrpoat> i think you might start running into issues where you're parsing things that shouldn't get parsed
00:14:54 <DRMacIver> Well, I'm happy to put my blog on planet haskell if you think it's a good idea.
00:15:23 <goltrpoat> in patterns specifically
00:15:43 <sorear> goltrpoat: that's a job for a later pass :)
00:15:52 <goltrpoat> ah
00:16:16 <dons> DRMacIver: well, its up to you. if you expect to write stuff of interest to programming language people, just let ibid know the rss feed.
00:16:33 <dons> implementing lazy strings, compilers, and the like, is certainly of interest.
00:18:13 <DRMacIver> ok. I'll ask him to add it.
00:18:46 <sorear> goltrpoat: the alt text for your image is very ... odd :)
00:19:00 <goltrpoat> i have an image?
00:19:01 <sorear> oh wait, we were talking about DRMacIver's blog.
00:19:03 * sorear re-google
00:19:24 <sorear> <IMG SRC="goltrpoat.jpg" BORDER=0 ALT="Identity Matrix"></A>
00:19:26 <goltrpoat> my blog is happily imageless
00:19:36 <goltrpoat> oh crap
00:19:38 <DRMacIver> @message ibid Could you add "Desperately Unenterprise" to Planet Haskell? The feed url is http://unenterprise.blogspot.com/feeds/posts/default
00:19:38 <lambdabot> Maybe you meant: messages messages?
00:19:42 <DRMacIver> Oops
00:19:46 <goltrpoat> hehe
00:19:52 * DRMacIver doesn't understand lambdabot syntax. :)
00:19:57 <goltrpoat> that's literally from 10 years ago.
00:19:59 <olsner> you want @tell I think
00:20:03 <sorear> goltrpoat:  http://www.geocities.com/nnnn31337/pictures/goltrpoat.jpg <- this is a different guy?
00:20:11 <goltrpoat> no, that's me, as a young lad.
00:20:11 <DRMacIver> @tell ibid Could you add "Desperately Unenterprise" to Planet Haskell? The feed url is http://unenterprise.blogspot.com/feeds/posts/default
00:20:12 <lambdabot> Consider it noted.
00:20:45 <goltrpoat> NNNN is a guy from efnet #philosophy who used to run an archive of users' photos back when i was there.
00:20:56 <goltrpoat> 97 or so.
00:21:21 <goltrpoat> i'm not responsible for the alt text :)
00:22:33 <augnob> I can vouch that he was around on irc that long ago :)
00:22:40 <goltrpoat> haha
00:22:52 <sorear> Oh, D. R. MacIver is a real name?
00:23:19 * sorear parsed it as Dr. <tv character pronouced like makkiver>
00:25:01 <DRMacIver> Yes. :)
00:25:20 <Figs> :P
00:25:26 * Figs just woke up
00:25:27 <DRMacIver> It's in fact David Ritchie (Non TV character name pronounced like mac-eever)
00:25:43 <stevan> there we go, xmonad running :). thanks for the help and for the program dons. i used dwm since it came basically, but i thought i would give xmonad a chance -- i studied haskell and liked it after all.
00:26:03 <goltrpoat> somehow google has managed to capture my most inane irc logs.
00:26:11 <Figs> no if you changed your first name to Dennis... you could really fsck people up ;)
00:26:11 <dons> stevan: great. i hope you find xmonad a suitable replacment for dwm
00:26:15 <Figs> *now
00:26:26 <c> i think tahts its biggest prob - dwm works fine, and doresnt rqeuire ghc
00:26:27 <dons> its a bit easier to hack on and extend, and supports xinerama. otherwise, it behaves pretty much like dwm.
00:26:36 <dons> stevan: also, feel free to drop by #xmonad irc channel
00:26:38 <goltrpoat> i'm fairly certain i've said a fairly substantial number of informative things over the years.
00:27:12 <dons> c, that's true. but dwm doesn't do xinerama, or fullscreen, and its harder to extend. so there's a niche there, i think.
00:27:12 <Figs> ok, I'm gonna disappear for a while, bbl
00:27:16 <dons> paritcularly for tiling + xinerama.
00:27:40 <sorear> it also has a more active contrib-community.
00:27:45 <c> yeah it looks nice
00:27:46 <sorear> does dwm have tabs?
00:27:47 <sorear> :)
00:28:05 <c> i stil think it should be abstracted away from X so you can use it in direectFB.
00:28:08 <c> but then im a tweaker
00:28:09 <araujo> hello
00:28:27 <dons> c, but you're right on the main point. dwm is good for what it does, so its hard to compete when you need a non-standard compiler
00:28:29 <sorear> c: what use would a WM be in dFB?
00:28:42 <dons> you have to do something else, some killer feature, that people would bother installing ghc for.
00:28:50 <sorear> any compiler packaged in debian is not non-standard. :)
00:28:51 <c> well, i needed darcs long ago :)
00:28:57 <dons> and hopefully, xinerama + customisation, are enough
00:29:05 <araujo> what would be a good name for a function that does the following , f 'h' => h where the ' character can be any char?
00:29:14 <sorear> apt-get install ghc6  .....  decent PM's mean this is a non-issue...
00:29:17 <dons> also, i note that last couple of weeks bugs have appeared in dwm that had already been found and fixed in xmonad.
00:29:19 <sorear> araujo: eval
00:29:21 <dons> xmonad's moving a little faster
00:29:25 <c> yes quite a few on the ml
00:29:28 <sorear> araujo: I don't think you want to go there ;)
00:29:28 <araujo> sorear, yeah? ....
00:29:48 <araujo> sorear, well, h will be a string
00:29:54 <sorear> araujo: yeah.  looks like a very restricted lisp EVAL with static scoping?
00:29:59 <araujo> sorear, it's just parsing a line
00:30:08 <sorear> araujo: oh.  f 'h' = "h"  ?
00:30:15 <araujo> mm yeah
00:30:17 <sorear> araujo: return
00:30:25 <sorear> araujo: you will find it already exists :)
00:30:27 <dons> ramkrsna: hmm, "unwrap" ?
00:30:40 <araujo> mmm...
00:30:46 <araujo> dons, that's for me? :-)
00:30:53 <olsner> :t unwrap
00:30:55 <lambdabot> Not in scope: `unwrap'
00:31:11 <araujo> thanks guys
00:31:19 <dons> ?let unwrap = tail . init
00:31:22 <lambdabot> Defined.
00:31:23 <dons> > unwrap "'x'"
00:31:25 <lambdabot>  "x"
00:32:11 <c> sorear: minimalism and cutting back on bloat - i know ive seen screenies of gnome/gtk running in dfb, do you really need X if youre just running 3 urxvts, emacs (has dfb drawing and if not can run in term) and firefox (cairo has dfb backend)
00:32:16 <araujo> dons, hah nice
00:32:25 <c> sorear: i mean, xmonad would have a huge leg up on being the only dwm style wm in that environment
00:32:27 <olsner> :t let unwrap = do c <- anyChar; x <- anyChar; char c; return x in unwrap
00:32:30 <lambdabot> Not in scope: `anyChar'
00:32:30 <lambdabot>  
00:32:30 <lambdabot> <interactive>:1:35: Not in scope: `anyChar'
00:32:34 <dons> c, hmm, that is interesting.
00:32:40 <sorear> c: Last I heard, dFB runs one program at a time :)
00:32:43 <dons> the core data types are all independent of the backend.
00:32:54 <sorear> c: so a wm would be kinda pointless?
00:33:00 <dons> you could implement gnu screen underneath
00:33:22 <dons> whaddya reckon, sorear :-)
00:33:25 <dons> a screen backend?
00:33:34 <sorear> hehehe...
00:33:44 <dons> c, though i thin the window manager for dFB is a pretty small market
00:33:46 <sorear> unfortunately you can't run xpdf in screen
00:34:02 <sorear> or angband -mx11, but that's less of an issue :)
00:34:08 <dons> c, the other secret goal is to add compositing hooks
00:34:16 <dons> so you can write glitzy effects in the config file.
00:34:29 <dons> the compositing-extensible tiling wm market has size 0 currently.
00:36:14 * goltrpoat wonders what the overlap is between people who want compositing, and the people who want to write the compositing code
00:37:20 <dons> the main issue is more that the guys who write tiling wms don't care about compositing
00:37:35 <goltrpoat> sort of what i was getting at :)
00:37:42 <dons> but i've been surprised by the user written tiling algorithms
00:37:49 <goltrpoat> ah
00:37:52 <dons> so given suitable compositing api, maybe someone would have a go
00:38:14 <dons> circle layout, for example, http://xmonad.org/images/screen-rob-circle.png
00:38:14 <kfish> transparent terminal overlays, tile workspaces on a cube ...
00:38:26 <dons> yeah, tiling 3d space, not 2d
00:38:28 <dons> that's the future!
00:38:46 <goltrpoat> i still can't figure out if i like beryl or not
00:38:59 <goltrpoat> (re "workspaces on a cube")
00:39:02 <dons> there's some nice subtle effects you can do with compositing and tiles though.
00:39:08 <dons> like slightly fading the non-focused windows
00:39:11 <dons> casting shadows, and so on
00:39:30 <dons> a basic example of simple shadow effects in xmonad, http://xmonad.org/images/xmonad_xcompmgr.png
00:45:04 <Figs> http://rafb.net/p/upoACi72.html
00:45:10 <lambdabot> Title: Nopaste - No description
00:45:17 <Figs> why do I get -2?
00:45:42 <Figs> oh, nevermind
00:45:51 <Figs> I did get it to work right :P
00:46:08 <igli> dons: have you spoken to tuomov (ion3) ?
00:47:09 <igli> http://modeemi.fi/~tuomov/b// is his blog and he hangs out in #ion ; he's very grumpy tho, but i've been chatting with him about higher-level languages
00:47:10 <lambdabot> Title: Not a blog
00:47:17 <igli> @bot
00:47:17 <lambdabot> :)
00:47:18 <Saizan> i want a macid browser.. ff keeps forgetting my bookmarks
00:47:25 <goltrpoat> incidentally, we just had to write a ui system from scratch recently.  took about 8-9 months of me bitching at c++ in just about every possible way.
00:48:09 <dons> igli, he helped me write my first paper :-) (or second?)
00:48:10 <goltrpoat> to get to 1.0 anyway, it's still going on
00:48:22 <dons> we worked on yi together a fair bit in 2004.
00:48:23 <igli> wtf! excellent!
00:48:50 <igli> http://modeemi.fi/~tuomov/vis/ -> seems like perfect candidate for haskell
00:48:51 <kfish> anyone here used Network.CGI?
00:48:51 <lambdabot> Title: Vis/Vapourware Interface Synthesiser
00:49:15 <dons> he's written a few notable haskell programs, (riot, one of the first ncurses programs), and also the jed binding in yi.
00:49:15 <igli> well then i'd ask him to provide code for base if i were you
00:49:22 <igli> ah ok
00:49:35 <igli> didn't even know he liked haskell tbh ;)
00:49:38 <dons> 'code for base'?
00:49:54 <igli> er you must use C at some point?
00:50:03 <dons> who? xmonad?
00:50:06 <igli> yeah
00:50:15 <dons> well, it uses Xlib.
00:50:26 <dons> otherwise, its all haskell.
00:50:32 <igli> yeah which is C, dunno just thought he;s the guy with the knowledge
00:50:44 <igli> and i know he's thinking of shelving ion
00:51:00 <igli> heh
00:51:02 <dons> yeah, i remember talking to him about it
00:51:30 <igli> i like his ideas
00:51:32 <igli> heh
00:51:48 <goltrpoat> i thought ion was already shelved for all intents and purposes :)
00:51:52 <gour> igli: have you seen http://lists.berlios.de/pipermail/ion-general/2007-April/001949.html ?
00:51:54 <lambdabot> Title: xmonad: Haskell window management has arrived, http://tinyurl.com/2aoovf
00:51:59 <igli> no checking
00:52:09 * gour considers him quite offensive
00:52:10 <dons> heh
00:52:32 <igli> yeah he's not as bad as greycat, believe me ;P
00:53:02 <osfameron> hey, he's a Finn, he might have been trying to be polite :-)
00:53:05 <gour> don't know about him, but it's enough for me not to take even a single look at ion
00:53:19 <sorear> goodnight.
00:53:25 <dons> oh, ion's a ground breaking program in its domain.
00:53:35 <dons> dwm, xmonad, wmii all inherit from it
00:53:47 <gour> sure, but i consider authors too
00:54:15 <gour> that's the reason why i eg. do not want to use paludis package management and i opted for pkgcore
00:55:00 <dons> i made some nice graphs of xmonad contributors yesterday, some people might be interested, http://article.gmane.org/gmane.comp.lang.haskell.xmonad/1004
00:55:01 <lambdabot> Title: Gmane -- Mail To News And Back Again
00:55:23 <igli> nn sorear
00:55:23 * gour considers haskell community one of the big advantages for newbies to choose haskell over other alternatives (hmm, are there any?)
00:55:39 <sorear> yep.
00:55:41 <dons> gour, yeah, the community is very very very important
00:55:49 <sorear> clean, SML, ocaml, miranda, ...
00:55:52 <araujo> gour, yea!
00:56:00 <sorear> haskell was created specifically to have a big community
00:56:01 <igli> gour: i agree with you about paludis guys, but tuomov isn't in the same category imo
00:56:06 <therp> gour: full ack, the community and the people behind projects (authors) are quite important in my evaluation too.. ion just looses in this category (despite /me being a long term ion user)
00:56:22 <sorear> before haskell there were about 20 pure lazy typed functional languages
00:56:30 <sorear> each with no community to speak of
00:56:34 <igli> heh
00:56:41 <sorear> so they formed a committee to create a common language
00:56:47 <sorear> hence, Haskell
00:56:56 <gour> therp: i agree, just read about someone's experience with #lisp the other day
00:57:13 <sorear> now essentially all of the aforementioned languages are *completely* dead
00:57:33 <therp> gour: I left #lisp
00:57:35 <sorear> clean is (barely) alive
00:57:59 <sorear> sml didn't take full damage because it's not lazy, but is nevertheless dying
00:58:08 <araujo> gour, i finally see an interesting thread on the ion ml
00:58:11 <araujo> :-)
00:58:18 <dblhelix> sorear: rear, I'd not say "barely"; I'd just say it's alive
00:58:31 <gour> i'd say that nice people in #haskell, #gentoo-haskell keeps me in my learning curve :-)
00:58:51 <gour> araujo: which one? ;)
00:59:10 <osfameron> is there a #debian-haskell too?
00:59:15 <igli> you can't complain about that thread tho gour
00:59:25 <dons> osfameron: strangey, i don't think so. though debian talk tends to happen in here.
00:59:40 <igli> you guys were having a discussion about how to use xmonad ffs
00:59:56 <vincenz> dons: what's it like to live in australia
01:00:08 <vincenz> dons: and do you know of a way to encode type-known sized matrices of any dimension
01:00:15 <dons> hah
01:00:23 <dons> nice, maybe.
01:01:21 <Figs> how many of you guys still use imp. languages on a regular basis? (non-work)
01:01:31 <gour> igli: you can say that the topic is 'off', but namecalling is another issue
01:01:31 * dblhelix waits for dons to whip out some gadts and start encoding some peanos with those
01:01:41 <dons> yeah, hang on.. dblhelix
01:01:49 <dons> Figs: we tend to use haskell for work and play :-)
01:01:58 <DRMacIver> Figs: My big non-work project at the moment is in Java.
01:01:59 <dons> though C gets a run now and then
01:02:01 <osfameron> for some value of "we"  (/me is not part of that we...)
01:02:31 <dblhelix> vincenz: I could send you some "vectors as applicative functors" code, if you'd like
01:02:41 <dons> vincenz: see http://liftm.wordpress.com/2007/06/03/scientificdimension-type-arithmetic-and-physical-units-in-haskell/
01:02:44 <lambdabot> Title: Scientific.Dimension: Type Arithmetic and Physical Units in Haskell « Monad.lift ..., http://tinyurl.com/2fzx3c
01:02:49 <Figs> I saw a haskell joke earlier today...
01:02:50 <osfameron> Figs: (haskell is my main "learning" project, but if I need to get anything *done* for non-work, then I use Perl, as I can actually make it do stuff ;-))
01:02:51 <DRMacIver> Figs: Even if it is centered around ideas which I didn't so much borrow from Haskell as descend upon it in force and bodily abduct. ;)
01:02:53 <igli> gour: meh you're too sensitive imo, #haskell has spoiled you ;) just wait til you try #bash ;P
01:03:00 <vincenz> dons: thx
01:03:05 <dons> and http://haskell.org/haskellwiki/Smart_constructors#Enforcing_the_constraint_statically
01:03:07 <lambdabot> Title: Smart constructors - HaskellWiki, http://tinyurl.com/jx22g
01:03:16 <dons> vincenz: and when you get stuck, ask on -cafe@
01:03:30 <vincenz> dons: I plan to encode a generalized matrix multiplication
01:03:32 <vincenz> in one typeclass
01:03:35 <gour> igli: why would i want to jump from the horse to the ass ;)
01:03:53 <igli> hehe cos you're climbing a mountain-side? ;)
01:04:07 <Figs> 'haskell forces seperation between Church and state'
01:04:11 <Figs> (that was the joke)
01:04:21 <gour> ahh, then i'm better be firmly on my feet
01:04:26 <dons> its strange on the dwm list, people are greatful for any bug fixes, they don't expect bug fixes. interesting mind set.
01:04:33 <vincenz> dons: the issue is not with the typenumbers but with encoding the data someway..
01:04:54 <igli> heh
01:04:54 <Figs> ref. Alonzo Church :P
01:05:01 <dons> vincenz: encoding the dimension in the matrices?
01:05:11 <igli> yes gour, i agree ASM is the one true code ;)
01:05:22 <Figs> which asm? :P
01:05:22 <vincenz> dons: that's easy, just a typelevel list
01:05:26 <vincenz> dons: I need to encode the data tho
01:05:37 <igli> ARM ftw atm Figs ;)
01:05:46 <dons> sounds like (potentially) more type hackery than is sensible.
01:05:48 <gour> igli: today ASM is (probably) name for bytestring ;)
01:05:52 <vincenz> dons: nah ;)
01:06:00 <vincenz> dons: block by block
01:06:21 * igli drifts slowly back to the topic
01:06:35 <dblhelix> vincenz: and the type-level list type is polymorphic in its elements? :-S
01:10:30 <vincenz> nod
01:10:46 <olsner> :t guard
01:10:48 <vincenz> the idea is to express a generalized matrix multiplication
01:10:48 <lambdabot> forall (m :: * -> *). (MonadPlus m) => Bool -> m ()
01:10:51 <vincenz> so you can have
01:11:11 <vincenz> mat:: A*B*(C*D) x (C*D)*E*F -> A*B*E*F
01:11:14 <olsner> > guard False :: Maybe ()
01:11:16 <lambdabot>  Nothing
01:11:21 <vincenz> aka, multiplication constrained both by arguments and result type
01:11:23 <olsner> > guard True :: Maybe ()
01:11:25 <lambdabot>  Just ()
01:11:43 <vincenz> so dot product and cross product of 2 square matrices is just 2 special cases :)
01:13:08 <Figs> is there a church programming language yet?
01:13:09 <dons> lisp people can be weird, http://www.podval.org/~sds/ocaml-sucks.html
01:13:11 <lambdabot> Title: OCaml Language Sucks
01:13:24 <igli> people can be weird
01:13:29 <dons> that's true!
01:13:36 <vincenz> geeks are weird
01:13:40 <dons> also true
01:14:06 <dons> woot!
01:14:09 <dons> andygill++
01:14:11 <aspo> if I have a data type
01:14:12 <igli> "the mathematical integers do not overflow, and I expect a language to provide something at least somewhat resembling them"
01:14:13 <dons> ANNOUNCE: Haskell Program Coverage 0.4
01:14:15 <aspo> data Test a b = Test a b
01:14:21 <aspo> why is
01:14:22 <aspo> instance (Eq a) => Eq (b -> Test a b) where (Test a) == (Test b) = a == b
01:14:27 <dons> igli: hehe. haskell++ on that one.
01:14:28 <aspo> invalid?
01:14:35 <igli> heh
01:14:47 <igli> @karma haskell
01:14:48 <lambdabot> haskell has a karma of 25
01:14:51 <dons> aspo: equality on functions?
01:14:54 <Figs> I think people would make too many jokes if there was a language called 'church'
01:15:02 <aspo> are you not allowed to have that?
01:15:09 <dons> well, you can, but not like that.
01:15:17 <dons> how do you want to define equality on functions, and why?
01:15:29 <aspo> I was poking around and curious
01:15:37 <aspo> Test 1 == Test 1
01:15:40 <aspo> makes sense to me
01:15:53 <dons> and note your == isn't defining equality on all functions b -> Test a b, is it?
01:16:22 <vincenz> dons: can you have a typeclass with no methods?
01:16:25 <quicksilver> aspo: you have promised to define Eq on all b -> Test a b
01:16:26 <quicksilver> vincenz: yes
01:16:27 <dons> vincenz: yep.
01:16:31 <vincenz> spiffy
01:16:37 <vincenz> so you can use it as constriant
01:16:38 <quicksilver> aspo: but you only seem to define it on Test x
01:16:47 <quicksilver> vincenz: it is eentially a 'property' on types then
01:16:52 <Figs> cya all later
01:16:52 <vincenz> quicksilver: thank you
01:16:55 <quicksilver> vincenz: or a relation between types (if MPTC)
01:16:58 <vincenz> I'll post it as soon as I'm somewhere
01:16:59 <aspo> ahh
01:17:01 <dons>  const (Test 7 9) is also a function b -> Test a b too.
01:17:01 <vincenz> so yo can give me some feedback
01:17:12 <dons> undefined is as well
01:17:15 <aspo> yeah I udnerstand now
01:17:17 <vincenz> dons: what with type class families... this could prove interesting as you could encode special cases
01:17:27 <vincenz> like plain numbers (0 dimensionals)
01:17:29 <aspo> is there a way I can define that?
01:17:32 <vincenz> or plain 2d-arrays
01:17:34 <dons> aspo, it is an interesting insight into the brain though, seeing the way you were thinking about it.
01:18:00 <dons> well, Test has to be fully applied
01:18:20 <dons> so, hmm, ad hoc equality on Test constructors applied to one value.
01:18:42 <dons> seems hard. not sure you'd ever need it in practice?
01:18:59 <dons> you certainly can't pattern match on it till its fully applied anyway
01:19:00 <aspo> I'm more just poking around trying to figure out how things work
01:19:50 <dons> (Test a _) == (Test b _) = a == b -- is one way, but since you can't match on partially applied Test, its not qiute what you were thinking
01:20:07 <dons> http://projects.unsafePerformIO.com/hpc
01:20:08 <vincenz> quicksilver: when doing class without methods, do you still need where?
01:20:09 <lambdabot> Title: Haskell Program Coverage
01:20:17 <aspo> I guess thinking further it really doesn't make much sense
01:20:42 <aspo> because I can make an infinate set of functions that are functionally equivilent to Test 1
01:20:45 <dons> vincenz: nope, iirc.
01:21:03 <dons> aspo: yeah, there are some deep language issues at play here
01:22:14 <aspo> thanks
01:30:26 <quicksilver> vincenz: you can have an empty where, maybe you can miss it out completely
01:30:40 <vincenz> quicksilver: appears so
01:33:26 <dons> class Typeable a => Message a
01:33:28 <dons> e.g.
01:34:04 <dons> http://programming.reddit.com/info/20dkd/comments
01:34:05 <lambdabot> Title: Haskell Program Coverage (reddit.com)
01:47:34 * vincenz need shelp with the name of a class :/
01:47:56 <dons> C
01:48:02 <vincenz> it's a class that
01:48:04 <vincenz> given two lists
01:48:17 <vincenz> [a_1, ... a_m] and [b_1, ... b_n]
01:48:25 <vincenz> checks that the last l a's and the first l b's are the same
01:48:30 <vincenz> Overlap/
01:48:30 <vincenz> ?
01:55:57 <mux_> vincenz: mmm, Junction?
01:56:21 <osfameron> Junction is quite an overloaded word though
01:56:32 <osfameron> I think overlap is quite good
01:57:18 <mux_> to me, overlap would be more appropriate if, for instance [a_m-1, a_m] == [b_2, b_2]
01:57:31 <mux_> but I can't think of something better :)
01:58:43 <goltrpoat> surely there's some relational calculus term for that
02:00:15 <igli> intersection you mean?
02:00:22 <igli> set theory
02:00:48 <goltrpoat> ?
02:01:03 <goltrpoat> i mean it's a semijoin or something.
02:01:15 <vincenz> @hoogle display
02:01:15 <lambdabot> System.Console.Readline.forcedUpdateDisplay :: IO ()
02:01:15 <lambdabot> System.Console.Readline.redisplay :: IO ()
02:01:15 <lambdabot> System.Console.Readline.setRedisplayFunction :: Maybe (IO ()) -> IO ()
02:01:20 <Cheery> do you know any good papers about finding and locating stuff?
02:01:21 <DRMacIver> Why exactly is that a class as opposed to just a function?
02:02:09 <vincenz> this is getting spiffy
02:02:22 <vincenz> show you soon
02:02:23 <vincenz> busy busy
02:05:08 <goltrpoat> drm:  probably because he wants to do it at the type level :)
02:06:03 <vincenz> yep
02:06:40 <vincenz> \o/
02:09:07 <igli> goltrpoat: sorry it's been *years* wtf is a semi-join? or even a join?! ;)
02:09:24 <dons> see what hanging around in #haskell doe to your brain... poor vincenz
02:09:36 <vincenz> @hoogle reverse
02:09:37 <lambdabot> Prelude.reverse :: [a] -> [a]
02:09:37 <lambdabot> Data.PackedString.reversePS :: PackedString -> PackedString
02:09:39 <igli> hehe look what it's done to mine!
02:09:40 <vincenz> crap
02:09:52 <dons> you want type level reverse/
02:09:56 <vincenz> yep
02:10:00 <vincenz> I ahve it :)
02:10:03 <dons> maybe check rl's type level quicksort?
02:10:06 <vincenz> I just want it to actually have a member
02:11:15 <dons> http://haskell.org/haskellwiki/Type_arithmetic#An_Advanced_Example_:_Type-Level_Quicksort
02:11:20 <lambdabot> Title: Type arithmetic - HaskellWiki, http://tinyurl.com/2cvjlr
02:11:21 <dons> (for those wondering0
02:12:20 <vincenz> thx
02:14:21 <goltrpoat> igli:  a join on A and B is the set of all tuples in A and B that agree on some set of attributes.  i was trying to come up with some structure to put on the lists given an l
02:14:42 <igli> ah ok
02:14:55 <igli> i'd ask dons tbh :)
02:17:31 <dons> http://programming.reddit.com/info/20dsn/details :-)
02:17:32 <lambdabot> Title: Type hackery: implementing QuickSort on the type level (reddit.com)
02:17:58 <DRMacIver> Is it just me who finds reddit a waste of bytes?
02:18:18 <vincenz> yes
02:18:21 <DRMacIver> ok.
02:19:25 <dons> helps haskell be less insular
02:20:03 <dons> therp, you know where to get Xinerama-supporting tiling window managers, remember :-0
02:20:36 <therp> oh my mail to ion-.. is out? :) it seems
02:20:51 <dons> i got it, and thought: "hmm" :-)
02:21:14 <therp> dons: I can rather work on GHC or on xmonad :)
02:21:26 <dons> you know, tabbing is also supported in xmonad. droundy uses it as an ion that supports xinerama.
02:21:52 <therp> oh, that quick? I thought you were discussing how to support it on #xmonad recently
02:22:15 <dons> yeah, a couple of weeks ago. droundy wrote it as a contrib module. just import it in your Config.hs
02:22:24 <dons> let me see if i can find a screenshot
02:23:35 <dons> http://darcs.haskell.org/~sjanssen/XMonadContrib/Tabbed.hs is the relevant module
02:24:25 <vincenz> yes
02:24:31 <vincenz> whops
02:28:23 <vincenz> lol
02:28:27 <vincenz> type-programming is easy
02:28:36 <vincenz> \\o/
02:28:41 <vincenz> *Matrices> testReverse
02:28:41 <vincenz> [2,3,4]
02:28:41 <vincenz> [4,3,2]
02:28:48 <vincenz> that's made purely from type-level stuff :)
02:29:10 <kfish> vincenz, :-)
02:29:53 <pastorn> vincenz: huh? type-programming? paste plz?
02:30:08 <vincenz> basically if you have
02:30:14 <vincenz> instance (Foo a b) => (Bar b y)
02:30:16 <vincenz> you just do
02:30:20 <vincenz>     bar b y = foo a b
02:30:23 <vincenz> as method \o/
02:30:36 <dons> vincenz: better post the code somewhere
02:30:40 <vincenz> dons: I will soon
02:30:44 <pastorn> @paste
02:30:44 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:30:48 <dons> so all checks are removed statically?
02:30:48 <vincenz> ...
02:30:51 <dons> is it computed statically?
02:31:20 <vincenz> hmm, not quite
02:31:37 <vincenz> disply requires runtime computation
02:31:49 <vincenz> the only reason being that I don't know how to make displaying of number a static thign
02:33:04 <vincenz> hmm
02:33:09 <vincenz> I could use the numPred trick
02:34:05 <kfish> vincenz, if the matrix values are at type-level then it'll be computed statically
02:34:40 <vincenz> they won't be
02:34:53 <vincenz> dons: btw
02:34:57 <vincenz> any reason numPred = const undefined
02:35:00 <vincenz> iso numPred = undefined
02:37:54 * vincenz fixes it to static computations
02:37:56 <vincenz> dons: thx for that thought
02:58:27 <DRMacIver> Hm
03:26:48 <robyonrails> hi guys I'm a beginner, how can I use maxBound to see the max value of Int ?
03:27:01 <mauke> > (maxBound :: Int)
03:27:06 <lambdabot>  2147483647
03:27:12 <robyonrails> thanks :)
03:27:41 <mauke> > (maxBound :: Bool)
03:27:43 <lambdabot>  True
03:28:28 <kaol> > (maxBound :: Integer)
03:28:30 <lambdabot>   add an instance declaration for (Bounded Integer)
03:28:30 <lambdabot>     In the expression: ma...
03:28:36 <Japsu> :t maxBound
03:28:38 <lambdabot> forall a. (Bounded a) => a
03:29:45 <pastorn> vincenz: I had to leave for a while... did you make a paste?
03:30:03 <vincenz> no
03:30:04 <vincenz> not yet
03:30:08 <vincenz> I've done all the typelevel stuff
03:30:14 <vincenz> now how to encode data into it
03:31:31 <malcolmw> @tell fasta I fixed cpphs to delete //-style end-of-line comments in --strip mode, as per our conversation a few days ago
03:31:31 <lambdabot> Consider it noted.
03:36:39 <DRMacIver> Hm. For all I like to complain about them, relational databasi are really quite nice when they work.
03:37:17 <dons> things that work are nice.
03:37:52 <robyonrails> another stupid question: why in WinHugs when I type "  4 'mod' 2  " it gets to me: ERROR - Improperly terminated character constant
03:37:57 <robyonrails> ?
03:37:59 <DRMacIver> I disagree. Plenty of things which work are not nice.
03:38:04 <dons> robyonrails: back ticks
03:38:07 <dons> > 4 `mod` 2
03:38:11 <lambdabot>  0
03:38:13 <dons> > 4 'mod' 2
03:38:13 <lambdabot>  Improperly terminated character constant
03:38:16 <robyonrails> ah I guessed
03:38:19 <dons> :-)
03:38:24 <robyonrails> what is the ASCII code?
03:38:25 <dons> > 'x' -- char literal
03:38:26 <lambdabot>  'x'
03:38:31 <dons> > ord '`'
03:38:32 <lambdabot>  96
03:38:37 <robyonrails> thanks :D
03:38:41 <dons> sure!
03:39:10 <dons> DRMacIver: pity things that are nice don't always work!
03:39:26 <dons> hmm. maybe that's a nice slogan.
03:39:41 <dons> "Haskell: finally, something nice -- that works!"
03:42:40 <quicksilver> "Haskell: finally something that works -- and is nice!"
03:43:56 <Japsu> @hoogle ord
03:43:57 <lambdabot> Char.ord :: Char -> Int
03:43:57 <lambdabot> Prelude.Ord :: class Eq a => Ord a
03:43:57 <lambdabot> Text.Html.ordList :: HTML a => [a] -> Html
03:44:18 <Japsu> Char.ord, k
03:44:23 <mauke> @index ord
03:44:24 <lambdabot> Data.Char
03:44:29 <Japsu> yay
03:44:44 <Japsu> less flood than with hoogle, nice
03:45:10 <DRMacIver> dons: Indeed, pity that Nice doesn't work. ;)
03:45:55 <mauke> http://z0r.de/?id=714
03:46:01 <lambdabot> Title: ZOMG ZUFALL! #714
03:47:53 <mr_tenor> mauke: is the audio for that available somewhere?
03:48:02 <Cheery> what is the stuff called what.. say google search is?
03:48:02 <mauke> no idea
03:48:52 <robyonrails> the guards are cool
03:48:52 <Cheery> oh well, going, see ya!
03:49:04 <robyonrails> :P
03:58:58 <kolmodin> can ghc do -fasm to all the arches it supports?
03:59:37 <dons> nope
03:59:52 <dons> e.g. ia64 or mips64 or sparc64
03:59:53 <kolmodin> hmm.. ok. so which ones does it not support?
04:00:01 <kolmodin> ah
04:00:04 <dons> well, easier to ask which ones it does support
04:00:08 <kolmodin> :)
04:00:11 <dons> x86, powerpc, sparc, amd64
04:00:21 <kolmodin> ok
04:00:25 <dons> alpha is bitrotted
04:00:35 <kolmodin> right. too bad
04:00:47 <dons> yeah, i've got 3 alphas :-(
04:00:59 <dons> hmm. should do something with them
04:01:05 <kolmodin> as a gentoo user I'd like to make everything -fasm if possible :)
04:01:23 <dons> its good for improving build times, for one thing.
04:01:34 <kolmodin> yeah
04:01:41 <kolmodin> I just built hpc with -O2 on my box
04:01:46 <malcolmw> dons: an unregisterised -fvia-C port would be a good start
04:02:45 <dons> malcolmw: yeah, there's registerised (I think) alpha -fvia-C in debian
04:03:17 <dons> kolmodin: hpc the package, or ghc -fhpc ?
04:03:25 <malcolmw> how much slower is an unregisterised build than registered, I wonder
04:03:28 * dons is keen to hook hpc and quickcheck together.
04:03:33 <kolmodin> yes!
04:03:37 <dons> malcolmw: about 2x from what i remember on the sparc
04:03:40 <kolmodin> that's exactly what I thought
04:04:26 <dons> kolmodin: andy gill had an idea to hand out a 'HPC 100% covered' badge if you had tests that hpc verified exercised 100% of the code
04:04:52 <dons> i think the streams QCs would go pretty close to that, and the bytestring tests maybe 95%. so hmm, should really look at this.
04:05:04 <malcolmw> just using hpc to measure coverage of QC properties is easy
04:05:14 <malcolmw> but maybe you mean something more automatic and scripted
04:05:25 <kolmodin> yeah, hpc badge, catch badge, quickcheck...
04:05:56 <dons> malcolmw: yeah, hpc should just work when the QC properties are compiled with hpc?
04:05:56 <kolmodin> automatic is good :)
04:06:03 <malcolmw> I believe CR had a feedback loop that found a fixedpoint - keep running QC with ever larger numbers of tests, until coverage does not change
04:06:13 <dons> and then send of an email transcript to andy, to get the badge back in the post.
04:06:28 <dons> malcolmw: ah, that's interesting.
04:06:41 <dons> yes, that'd be cool to try on bytestring 1.0
04:06:47 <malcolmw> of maybe it was smallcheck
04:06:50 <dons> dcoutts__: ^^ we should do that.
04:07:35 <robyonrails> in the hiding clause in import clause you can specify only function names?
04:08:09 <malcolmw> robyonrails: no, you can hide type, constructor, and class names too
04:08:22 <kolmodin> dons: building hpc with -O2 takes 4m20s on my machine
04:08:23 <robyonrails> oki
04:08:27 <kolmodin> dons: just the package
04:08:47 <robyonrails> another rapid question: the if..then..else statement can be used only in one line?
04:08:56 <malcolmw> robyonrails: nope
04:10:12 <robyonrails> only by source, then?
04:10:27 <robyonrails> in the prompt I'm not able to do that :|
04:11:03 <kolmodin> dons: building with -O takes 3m20s. less difference than I thought
04:11:16 <mauke> yeah, the interactive interpreter works linewise
04:11:18 <malcolmw> robyonrails: the interactive prompt only ever takes one line
04:12:36 <kolmodin> m.... -O0 in 44s
04:15:00 <robyonrails> yes I realised
04:15:02 <robyonrails> :)
04:15:16 <robyonrails> ord and chr, where are defined?
04:16:00 <mehrheit> @index ord
04:16:00 <lambdabot> Data.Char
04:17:19 <nominolo> !paste
04:17:19 <hpaste> Haskell paste bin: http://hpaste.org/
04:17:38 <robyonrails> so have I to do: "Import Data.Char" ?
04:17:53 <hpaste>  nominolo pasted "darcs error" at http://hpaste.org/358
04:18:18 <mehrheit> robyonrails, import Data.Char (watch the case)
04:18:27 <nominolo> anyone can tell me what's going wrong here ^^^ ?
04:18:48 <Lemmih> nominolo: Perhaps you have too many open files.
04:19:14 <nominolo> not really
04:19:15 <robyonrails> ah ok mehrheit
04:19:25 <gkr> foldl can't deal with infinite lists?
04:20:01 <nominolo> it happens whenever i try to pull the latest ghc
04:21:30 <malcolmw> nominolo: use ulimit -a to find out your limit on open file descriptors, and increase it
04:22:16 <Igloo> malcolmw: Is cpphs 1.5 released?
04:22:27 <malcolmw> Igloo: I think so
04:22:38 <Igloo> malcolmw: The webpage doesn't  :-)
04:22:38 <malcolmw> Igloo: are you about to package it for debian?
04:22:43 <quicksilver> gkr: that's rather inherent in how it works, yes. think about the bracketing
04:23:01 * malcolmw thinks Igloo asked a trick question
04:23:06 <quicksilver> gkr: ((((( ... (a `f` b) `f` c) `f` d) ..... )
04:23:12 <Igloo> malcolmw: I was going to last night, but then I got confused
04:23:14 <quicksilver> gkr: infinite number of open brackets at the left
04:23:23 <Igloo> trick question?
04:24:18 <malcolmw> Igloo: ah, "the" webpage is the problem
04:24:35 <malcolmw> I uploaded to www.cs.york.ac.uk, but not to www.haskell.org
04:24:49 <Igloo> Ah, OK
04:24:52 <gkr> quicksilver AH! Since Haskell is lazy, on some functions using foldr when you pass to it an infinite list, it may happen that it ends, right?
04:25:05 <robyonrails> can I use something similar to "chr(c)>=48 && chr(c)<=57" as guard?
04:25:30 <mauke> robyonrails: isDigit c
04:25:33 <quicksilver> gkr: right
04:25:40 <quicksilver> gkr: becuase it can 'start working'
04:25:45 <malcolmw> Igloo: now fixed
04:25:51 <quicksilver> gkr: and if `f` is lazy in the right way
04:25:55 <quicksilver> gkr: it may get somewhere
04:26:06 <Igloo> malcolmw: Cool, thanks
04:26:12 <gkr> Great quicksilver ^.^ Thanks!
04:26:24 <robyonrails> how can I convert Char to Int?
04:26:29 <nominolo> malcolmw: is there a way to find out which application uses how many resources?
04:26:40 <malcolmw> Igloo: although, I just fixed another bug in cpphs, so maybe I'll need a 1.6 soon
04:26:44 <mehrheit> could someone give an example of foldr finishing on an infinite list?
04:26:46 <mauke> @hoogle Char -> Int
04:26:46 <lambdabot> Char.digitToInt :: Char -> Int
04:26:46 <lambdabot> Char.ord :: Char -> Int
04:27:01 <mehrheit> @type fromEnum
04:27:03 <lambdabot> forall a. (Enum a) => a -> Int
04:27:08 <nominolo> malcolmw: i rather suspect it's a darcs bug of some kind
04:27:15 <mauke> > foldr (\x z -> z) 42 [1 ..]
04:27:18 <robyonrails> ok ;)
04:27:21 <lambdabot> Terminated
04:27:36 <malcolmw> nominolo: the ulimit sizes are per-process, so one application should not interfere with another
04:27:37 <mauke> > foldr (\x z -> x) 42 [1 ..]
04:27:39 <lambdabot>  1
04:28:02 <malcolmw> nominolo: nevertheless, 'ps' will tell you lots about individual process resource usage
04:28:04 <mehrheit> ok
04:28:09 <nominolo> malcolmw: hm, i set it two 4-times the amount and i still get the same error
04:29:04 <nominolo> oh, ok
04:29:08 <nominolo> moybe not
04:29:21 <nominolo> set it in the wrong console
04:29:52 <malcolmw> nominolo: yes, ulimits are inherited through the parent shell
04:38:39 <fasta> Can I get GHC to print Control.Monad.State.Lazy.StateT as StateT in general?
04:38:39 <lambdabot> fasta: You have 1 new message. '/msg lambdabot @messages' to read it.
04:43:17 <hkBst> can lambdabot turn an expression into its fully-parenthesized equivalent?
04:45:52 <dons> import Data.Char
04:46:02 <dons> hkBst: hmm, no, but ghc can
04:46:33 <dons> hkBst: oh, hang on, maybe it can...
04:46:41 <dons> ?pretty a + 2 * x + y
04:46:41 <lambdabot> "Parse error" at column 14
04:46:46 <dons> ?pretty f = a + 2 * x + y
04:46:46 <lambdabot>  f = a + 2 * x + y
04:46:50 <dons> no, oh well.
04:47:00 <dons> Haskell http://haskell.org/haskellwiki/Indent#Use_GHC
04:47:01 <lambdabot> Title: Indent - HaskellWiki
04:47:02 <dons> hkBst: ^^
04:47:18 <dons> ghc --ddump-parsed does the job though
04:47:57 <Phillemann> Can something unexpected happen if I reuse a function parameter more than once?
04:48:34 <dons> in what sense?
04:48:37 <Phillemann> Ah well, that's too vague.
04:48:38 <dons> f x x = x ?
04:48:44 <dons> or f x = x + x ?
04:48:49 <Phillemann> dons: The latter. :)
04:48:58 <dons> define unexpected. :-)
04:49:05 <Phillemann> I'
04:49:08 <Phillemann> ll just paste code.
04:49:10 <vincenz> dons: simple Q
04:49:16 <vincenz> dons: do you think it'd be better to do
04:49:19 <vincenz> [a] -> Matrix a
04:49:20 <vincenz> or
04:49:25 <vincenz> [[a]] -> Matrix a
04:49:29 <Phillemann> I'm pretty new to Haskell and I'm not yet sure what the error messages mean. :)
04:49:30 <vincenz> where the number of list-nestings determines dimension
04:49:33 <dons> the former, I suspect, vincenz
04:49:38 <vincenz> easier to encode data?
04:49:43 * vincenz nods
04:49:44 <dons> vincenz: sort of like [(a,b)] -> Array a b
04:49:48 <vincenz> nono
04:49:49 <vincenz> for instance
04:49:54 <dons> actually ,sorry, the latter. [[a]]
04:50:00 <dons> more type information is better
04:50:03 <vincenz> toMatrix [1..9] :: Three (Three (Nil Int))
04:50:08 <vincenz> dons: I have to specify the output anyways
04:50:11 <vincenz> cause it's statically sized
04:50:13 <dons> ah i see.
04:50:20 <dons> then make it easy for the user :-)
04:50:20 <vincenz> so perhaps storing as flat list is easier to input
04:50:30 <hkBst> dons: ghc-6.6: unrecognised flags: --ddump-parsed
04:50:32 <dons> since they already have to specify how it is `parsed'
04:50:36 <vincenz> nod
04:50:39 <vincenz> ok!
04:50:44 <dons> hkBst: oh, interesting! let me check..
04:50:46 <vincenz> dons: output will be to [[a]] tho
04:50:58 <mauke> hkBst: try -ddump-parsed
04:51:00 <vincenz> so fromMatrix and toMatrix are not exactly inverses
04:51:18 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/359
04:51:18 <dons> hkBst: yes, -ddump-parsed
04:51:20 <dons> $ cat A.hs
04:51:21 <dons> main = print $ 1 + 2 * 2 + 3
04:51:21 <dons> $ ghc -ddump-parsed A.hs
04:51:21 <dons> ==================== Parser ====================
04:51:23 <dons> main = (((print $ 1) + 2) * 2) + 3
04:51:26 <Phillemann> http://hpaste.org/359
04:51:36 <dons> those parens seem wrong though..
04:51:42 <Phillemann> Ah.
04:51:51 <Phillemann> I now see the error. :D
04:52:15 <Phillemann> Sorry for disturbing you. :>
04:52:15 <dons> main = print (1 + 2 * 2 + 3)
04:52:15 <dons> $ ghc -ddump-parsed A.hs
04:52:15 <dons> ==================== Parser ====================
04:52:15 <dons> main = print (((1 + 2) * 2) + 3)
04:52:18 <dons> that's better.
04:52:25 <dons> still, wrong though..
04:52:32 <dons> so -ddump-parsed isn't very clever ;-(
04:52:40 <hkBst> dons: ok, that seems to be recognized. But it doesn't work on things like '(+) $ 3 4'... :)
04:53:20 <fasta> dons: what do you do when you get errors about instances that don't exist because you made an error by executing things at the wrong monad level?
04:53:24 <mnislaih> is there any reason for which one cannot create the ST Monad Transformer ?
04:53:30 <Saizan> Phillemann: (myListSum' a b 0 (n-1)) is :: a instead of :: [a]
04:53:34 <dons> anyone had experience running xmonad inside xnest?
04:53:50 <Phillemann> Saizan: The mistake I made was to use myListSum' a second time instead of myFoo. :)
04:53:53 <fasta> mnislaih: you mean MonadST?
04:53:58 <Phillemann> Pretty stupid mistake actually.
04:54:15 <fasta> mnislaih: oh, I see
04:54:18 <mnislaih> I mean Control.Monad.ST in Monad Transformer version
04:54:35 <mauke> same reason there's no IOT probably
04:54:44 <fasta> mauke: and why is there no IOT?
04:54:47 <fasta> mauke: :)
04:58:07 <vincenz> >   let x = toMatrix [1..10] :: Two (Two (Nil Int))
04:58:07 <vincenz> >   print $ fromMatrix $ x
04:58:07 <lambdabot>  Parse error
04:58:11 <vincenz> [[1,2],[3,4]]
04:58:14 <vincenz> \o/
04:58:15 <lambdabot>   Not in scope: `x'
04:58:15 <Saizan> because you can't get things outside of it?
04:58:38 <vincenz> Took me a while, my first type-level implementaiton was spiffy but wouldn't do it :/
04:58:42 <mnislaih> Saizan: but you can with ST
04:58:43 <vincenz> so I have all this code that has been tossed
04:59:02 <hkBst> dons: I want to see how it parses stuff that fails to be type-congruent(?) ?
04:59:10 <Saizan> mnislaih: but you lose the state
05:09:38 <quicksilver> being able to make FooT
05:09:49 <quicksilver> requires you to be able to 'freeze' all the internal 'monadness' of Foo
05:09:55 <quicksilver> and then 'thaw' it later
05:10:01 <quicksilver> for more Foo operations
05:10:17 <quicksilver> there aren't primitives to 'freeze' *all* of the ST state
05:10:29 <quicksilver> although you could make an STArrayT type thing for just one array
05:10:35 <quicksilver> (or a fixed number of arrays)
05:10:36 <quicksilver> I suspect
05:11:14 <fasta> quicksilver: that sounds a hell of a lot like continuations :)
05:15:59 <Japsu> @pl \l -> group l >>= (\x -> [length x, head x])
05:15:59 <lambdabot> (liftM2 (:) length (return . head) =<<) . group
05:17:29 <mehrheit> :t join
05:17:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
05:18:57 <Figs> I was just curious, but how many compilers are written in haskell?
05:19:12 <Figs> (in common practice)
05:19:33 <Wild_Cat> Figs: well, GHC is.
05:19:57 <dons> and pugs, the perl6 compiler
05:20:08 <Figs> ok, that's two.
05:20:11 <dons> we actually have a list somewhere, let me hunt..
05:20:13 <Figs> ok
05:20:18 <dons> jhc is written in haskell
05:20:34 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Compilers_and_interpreters
05:20:36 <lambdabot> Title: Applications and libraries/Compilers and interpreters - HaskellWiki, http://tinyurl.com/2dt77g
05:20:37 <dons> there you go.
05:20:47 <Figs> thanks
05:20:53 <dons> so quite a few
05:21:02 <dons> and there just the ones that people have bothered to add to the wiki
05:21:50 <dons> some say that haskell was designed primarily for writting compilers ;)
05:22:06 <Figs> ;P
05:22:33 <dons> if you think about it, pattern matching on AST data structures is just a killer feature for compiler writers
05:22:36 <Figs> since it seems like just about everything is a type transformation in haskell, it seems appropriate
05:23:00 <Figs> yes
05:23:01 <dons> compiler :: String -> Assembly
05:23:24 <Figs> you don't have to compile to assembly ;)
05:23:29 <Figs> you could compile to C :P
05:23:38 <dons> there's also a lot of compiler tools
05:23:45 <dons> http://haskell.org/haskellwiki/Applications_and_libraries/Compiler_tools
05:23:47 <Figs> which I think is at least as practical
05:23:47 <lambdabot> Title: Applications and libraries/Compiler tools - HaskellWiki, http://tinyurl.com/2p8tax
05:24:07 <dons> so if you need to come up with parsers, lexers, type checkers, pretty printers and all the other infrastructure around a compiler
05:25:29 <Figs> is a queue the same thing as a singlely linked list?
05:26:23 <Figs> hey, no C++ compilers in Haskell yet? :P
05:27:23 <yaarg> sounds like a spectacular waste of time
05:28:02 <Figs> you're assuming time is worth something ;)
05:28:12 <dons> there'd be money to be made, in adding static checking to C++
05:28:21 <dons> i'm sure you could sell a tool that found bugs in C++ programs
05:28:30 <Thomas2> heh, I know some people working on it :-)
05:28:30 <Figs> hmm
05:28:40 <Thomas2> turns out to be a little challenging at least
05:28:58 <dons> Thomas2: right! :-)
05:29:06 <Figs> I'd rather just write a language to prevent most of those errors
05:29:16 <Thomas2> they're taking more of a model-checking slant
05:29:42 <yaarg> i'd rather stab myself with a fork tbh
05:30:03 * Figs is an incurable C++ programmer
05:30:12 <Thomas2> yaarg: stress releiving?
05:30:26 <Figs> anyway, it's half past 5 in the morning, and I need to be up soon
05:30:28 <Figs> g'night all
05:35:48 <isaacd> I have a feeling this isn't supposed to happen:
05:35:49 <isaacd> <interactive>: exception :: GhcException
05:36:07 <isaacd> after I pressed control-C a bunch of times to try to get ghci to stop
05:36:32 <isaacd> it was busy printing [-1,-1,-1,-1,-1  ...
05:37:37 <isaacd> now I don't have a prompt or even readline active in that terminal (pressing delete prints ^?)
05:37:40 <Japsu> mwahaha, import qualified Personnel hiding (illegalImmigrants)
05:38:32 <isaacd> module Public where (module Personnel) and no-one'll know ;-)
05:38:46 <Japsu> :P
05:38:57 <dons> isaacd: sounds like time to quit ghci
05:39:16 <isaacd> yep
05:40:04 <isaacd> (ghci DID stop using CPU)
05:42:28 <mdmkolbe|work> How do I specify using the non-threaded RTS with GHC?
05:44:38 <vincenz> > let a <.> b = a * b in 1 <.> 2
05:44:40 <lambdabot>  2
05:49:26 <ndm> @seen malcolmw
05:49:27 <lambdabot> malcolmw is in #darcs, #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 7m 48s ago.
05:49:49 <malcolmw> ndm: yo
05:50:02 <ndm> @slap malcolmw
05:50:03 * lambdabot slaps malcolmw
05:50:06 <ndm> malcolmw: you broke Yhc with your cpphs changes
05:50:07 <lambdabot> ndm: You have 3 new messages. '/msg lambdabot @messages' to read them.
05:50:23 <malcolmw> ndm: ouch - how come?
05:50:42 <ndm> malcolmw: http://darcs.haskell.org/yhc/src/packages/yhc-base-1.0/Data/Array.hs
05:50:44 <lambdabot> http://tinyurl.com/ytnh9r
05:50:59 <ndm> our build bots now fail on line 13, i suspect you are dropping the (//), when you weren't before
05:51:13 <malcolmw> ah.  don;t use the --strip option then
05:51:40 <malcolmw> there shouldn't be any C comments in the haskell sources anyway?
05:54:07 <ndm> malcolmw: thanks, fixing now...
05:57:28 <ndm> eek, we include Types.h
05:57:33 <ndm> which does have /* comments */
05:57:50 <ndm> malcolmw: suggestions? is there a way to have comments that Haskell and C like?
05:58:45 <malcolmw> ndm: hmm.  nasty.  I don't even think there is an easy way to change cpphs options on a per-file basis
05:59:25 <Igloo> How does it work with cpp?
06:00:06 <Igloo> Hmm, maybe that just never comes up with GHC, actually
06:00:26 <malcolmw> cpp strips // comments.  it is new in cpphs to strip them too
06:00:51 <malcolmw> but normally, I would avoid calling cpp at all on a file with (//) defined in it
06:01:03 <ddarius> Hopefully no one said anything interesting in the last twelve hours.
06:01:14 <robyonrails> internally, Haskell's implementations add a ';' at the stard of each line ?
06:01:17 <ndm> hmm, i think i can remove them from that file
06:01:26 <malcolmw> hmake deliberately checks to see whether cpp is required on any particular module, but I guess yhc just blindly uses it everywhere
06:01:37 <dons> robyonrails: basically, you can also write them manually
06:01:42 <ndm> yes, pretty much
06:01:48 <robyonrails> oki
06:01:48 <dons> > let x = 1 ; y = 2 ; j = 3 in x + y * j
06:01:50 <lambdabot>  7
06:02:13 <robyonrails> yes I know that, I was interested in implementation issue :)
06:02:24 <Igloo> The details are in teh Haskell Report
06:02:30 <dons> check the section near the start of the haskell report on 'layout'
06:02:36 <robyonrails> ok thanks
06:03:53 <ndm> yay, Yhc is building once more
06:04:18 <Syzygy-> What was the workaround?
06:05:46 <ndm> change /* to {- in the .h file
06:05:55 <ndm> apparently the .h file isn't used from C anywya
06:07:28 <crazy_coder> hello everyone
06:08:02 <crazy_coder> Can anyone tell me some thumb rule to remember the indentation logic, i keep getting parsing errors
06:08:12 <crazy_coder> This is very different than C/C++
06:08:32 <crazy_coder> I read about the rules but didn't quite understand it
06:08:32 <dons> a single expression always indents further to the right
06:08:42 <dons> and lines that have the same level, indent the same amount
06:09:07 <dons> the 'then' and 'else' arms of an if-then-else indent the same amount, and more than the initial 'if'
06:09:07 <crazy_coder> Is there some better rule using braces ?
06:09:15 <crazy_coder> oh ok
06:09:20 <crazy_coder> But can I use tabs
06:09:31 <dons> you can, but they're strongly discouraged
06:09:40 <dons> if you do use tabs, you must set them to be 8 spaces
06:09:48 <dons> since haskell lexes them as 8 spaces in the layout
06:09:52 <crazy_coder> So basically each new statement indents further than the previous expression
06:10:06 <robyonrails> the capital letter of classes etc.. is just a convention or a mandatory bound?
06:10:08 <crazy_coder> *each new expression
06:10:13 <dons> statements that would be separated with ';' in another language indent the same amount
06:10:29 <dons> a single expression over multiple lines indents further to the right on each line
06:10:44 <dons> f = let x = 1
06:10:44 <dons>         y = 2
06:10:44 <dons>     in x + 2
06:10:44 <crazy_coder> oh thanks
06:11:01 <dons> f = x +
06:11:02 <dons>      2
06:11:20 <dons> note x and y indent the same amount in the first example
06:11:26 <crazy_coder> The y in the second line is exactly below x ???
06:11:38 <dons> yes.
06:11:46 <crazy_coder> Is it necessary ?
06:11:52 <dons> f = let x = 1 ; y = 2 in x + 2
06:11:53 <Saizan> robyonrails: mandatory
06:12:10 <crazy_coder> hmm.
06:12:11 <dons> crazy_coder: yep. see ';' in the exapmle above
06:12:14 <robyonrails> ok
06:12:25 <crazy_coder> Its a bit confusing still
06:12:31 <dons> crazy_coder: we've got some guidelines for this stuff, and it helps to read examples
06:12:34 <dons> let me find you some material
06:12:44 <crazy_coder> dons: Thanks
06:12:49 <crazy_coder> I appreciate that
06:13:00 <fasta> I always indent as less as possible, since I have limited horizontal space.
06:13:35 <crazy_coder> The problem is pressing and holding the space button
06:13:35 <dons> crazy_coder: there's some here http://haskell.org/haskellwiki/Programming_guidelines
06:13:36 <lambdabot> Title: Programming guidelines - HaskellWiki
06:13:46 <dons> crazy_coder: best to use tabs and have the editor insert them as spaces
06:13:50 <dons> :set expandtab   in vim
06:14:14 <dons> i use:
06:14:15 <dons> set tabstop=4
06:14:15 <dons> set shiftwidth=4                " auto indent width
06:14:15 <dons> set expandtab
06:14:19 <crazy_coder> dons: no idea about vim.  I am using KDevelope
06:14:22 <Saizan> or use emacs haskell-mode and hit tab until you get the right indentation
06:14:38 <dons> there's probably similar rules for KDevelop i suspect?
06:14:43 <crazy_coder> Saizan: emacs haskell mode?
06:15:00 <crazy_coder> Saizan: How to use emacs in haskell mode ?
06:15:04 <fasta> crazy_coder: google
06:15:14 <dons> yeah, the emacs haskell mode. its pretty good
06:15:20 <Saizan> @where haskell-mode
06:15:20 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
06:15:31 <crazy_coder> Thanks :)
06:15:56 <ddarius> Yay, hacking dons' code won't annoy me.
06:16:29 <dons> ddarius: whatcha doing? :-)
06:16:42 <ddarius> Getting ready for work.
06:17:47 <isaacd_> ndm: I suppose if you control the .h, you could use "#if 0 ...#endif"-style comments
06:17:51 <isaacd_> only
06:23:05 <ndm> isaacd_: thats a much better idea!
06:24:05 <isaacd_> hehe... "cpp style comments"
06:40:04 <ndm> @karma+ malcolmw -- merging Yhc
06:40:05 <lambdabot> malcolmw's karma raised to 1.
06:40:14 <ndm> i'm just going to go and fix up our build scripts...
06:40:16 <dons> yeah, super cool.
06:40:24 <dons> and good for everyone involved, i think.
06:40:32 <ndm> yep indeedy!
06:40:33 <isaacd_> what?
06:40:45 <ndm> Yhc and nhc's compilers just got merged
06:40:51 <isaacd_> whee
06:40:56 <SamB_XP> so I read
06:41:02 <dons> one bytecode compiler to rule them all!
06:41:10 <malcolmw> ndm: note, I have only ensured that both yhc and nhc98 compile - not that they do the same things they used to do...
06:41:29 <ndm> malcolmw: i'm making a copy of the repo first :)
06:41:29 <malcolmw> :-)
06:41:40 <ndm> Yhc is not just a bytecode copmiler
06:41:52 <ndm> its also a javascript compiler, has a C back end somewhere etc.
06:41:52 * malcolmw is going to be cautious with updating nhc98 too
06:43:29 <ndm> actually, i think i'll make it check out this to compiler, not compiler98
06:43:43 <ndm> then we can leave both in parallel for a while
06:46:05 <malcolmw> makes sense
06:48:26 <ndm> you totalled our sconscript
06:48:31 <ndm> accidentally, i'm sure ;)
06:50:27 * SamB_XP likes the gmail notifier that comes with Google Talk
06:52:31 <SamB> I guess this will save on monadizing when that's done?
06:53:19 <malcolmw> ndm: eh? how?
06:53:21 <SamB> say... does this make me an nhc hacker too?
06:54:04 <malcolmw>  /me thinks that most yhc hackers have always been nhc hackers, but too ashamed to admit it :-)
06:54:08 <SamB> dons: so... what's your excuse for not releasing dlist 0.2?
06:55:43 <ndm> malcolmw: scons hates me, and you - it globs in all files, and some shouldn't be globbed in
06:55:54 <ndm> malcolmw: /me is a windows hacker, hence not an nhc hacker
06:56:13 <SamB> ndm: and I hates it
06:56:44 <malcolmw> ndm: you mean it scons can't cope with source files existing that don't get compiled?
06:56:45 <SamB> and still doesn't know how you managed to get it to work for a compiler...
06:57:00 <SamB> malcolmw: I assume SCons can deal with it
06:57:06 <ndm> malcolmw: our build scripts compile everything in, basically *.hs
06:57:16 <ndm> which made perfect sense back when we had a directory
06:57:20 <malcolmw> well that's just silly
06:57:26 <Igloo> :-)
06:57:31 <malcolmw> ghc --make MainYhc.hs
06:57:39 <ndm> yes, i know
06:57:43 <ndm> or in Hugs it works fine too
06:57:58 <SamB> I just don't understand how you tell it "build this compiler before you try and use it to compile these libraries"
06:58:03 <ndm> but i think the worlds concensus is that if you want to build a program you should suffer pain
06:58:07 <ndm> not sure why, but it is
06:58:38 <ndm> is nhc going to move to heirarchical module names?
06:58:40 * dylan builds things without pain every day
06:58:43 <malcolmw> SamB the concept of sequence is quite well-known in CS circles :-)
06:59:04 <SamB> malcolmw: ... only in .bat build scripts, though ;-)
06:59:12 <SamB> or, well, also .sh
06:59:24 <SamB> but .bat seems more common somehow...
06:59:47 <SamB> dons: ... you haven't made any excuse yet?
07:00:26 <dons> SamB: i'm lazy.
07:00:35 <SamB> dons: so how long does it take to release?
07:00:39 <ndm> dons `seq` ()
07:00:46 <dylan> dons `seq` ()
07:00:54 <dylan> ...
07:00:57 <dylan> q stereo
07:01:02 <Saizan> rnf dons -- at this point
07:01:14 <dylan> hmm, I never remember lambdabot's quote command
07:01:17 <dons> forkIO dons
07:01:21 <dons> oh wait.
07:01:26 <Saizan> a clone!
07:01:32 <mauke> @quote stereo
07:01:33 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
07:01:33 <dylan> I had a dream where I forked myself.
07:01:49 <dons> i think i just made a dons fork bomb
07:02:02 <int-e> sequence_ (repeat (forkIO dons))
07:02:03 <dons> no one demand me.
07:02:43 <malcolmw> @remember dylan: I had a dream where I forked myself.
07:02:43 <lambdabot> Done.
07:02:48 <dylan> it was right after the first matrix movie... I was being attacked by something and I shouted "fork" like it was a magical incantation and felt myself split into two perspectives and then lose connection with each
07:03:13 * malcolmw thought you were just being suggestive
07:03:29 <dylan> No, pretty much everything I say is literal.
07:03:54 <mehrheit> I had a nightmare about strict infinite lists
07:04:01 <ndm> malcolmw: how many files in this tree did you move, and how many just have Yhc and nhc copies?
07:04:03 <dylan> mehrheit: seriously?
07:04:15 <mehrheit> yes, they filled all my heap
07:04:22 <malcolmw> there are some episodes of Kung Fu - the Legend Continues, where Kwai Chang Cain forks himself into multiple warriors to defeat the enemy
07:05:02 <ndm> plenty of things like Rename.hs seem to be floating around, but not building for me
07:05:10 <malcolmw> ndm: almost everything is shared
07:05:10 <dylan> the problem in my dream was the duplicate was permenant, and was exactly like me up until the point of fission.
07:05:19 <ndm> malcolmw: but are the old nhc ones still floating around?
07:06:09 <malcolmw> ndm: don't know what you mean - Rename.hs _is_ simultaneously both the old nhc98 version, and the yhc version
07:06:17 <malcolmw> they are the same thing...
07:06:33 <ndm> malcolmw: sure? Rename.hs won't compile for me - along with loads of other ones
07:07:38 <ndm> hmm, perhaps its scons having a mild heart attack
07:07:42 <malcolmw> ndm: won't compile, as in, it has errors in it?
07:07:58 <ndm> malcolmw: when compiling with scons, yes - when compiling with Hugs, no
07:08:02 <ndm> i'm blaming scons
07:08:32 <malcolmw> ndm: maybe you forgot to tell scons the location of the new compiler, so is getting confused with compiler98
07:09:07 <malcolmw> there are possibly 10000 lines of scons you need to check for such stuff :-)
07:09:08 <ndm> malcolmw: if it didn't know the new one it should work, if it did know the new one it should work - i can only imagine its half way between them
07:10:23 <malcolmw> have you tried just doing ghc --make MainYhc.hs -package filepath -I../libraries/core etc
07:13:29 <ndm> yeah, that works fine
07:13:38 <ndm> or rather doing the equivalent in Hugs, which should give the same result
07:13:42 <ndm> (but in 2 seconds)
07:14:45 <fasta> How can I find out what generates the constraint Control.Monad.Fix.MonadFix (Control.Monad.Cont.ContT ()  (ST s)) efficiently?
07:16:50 <malcolmw> fasta: using mdo notation?
07:17:04 <fasta> malcolmw: yes
07:17:15 <malcolmw> fasta: then that's what generates it
07:17:17 <dons> that's it then :-)
07:17:22 <fasta> no...
07:18:39 <fasta> The problem is that it gets generated by calling some function in some monadic function, but I don't know why it exactly needs that instance. I miss a lift somewhere, I am sure... but finding the exact location...
07:19:38 <fasta> In the end mdo is the one that generates a MonadFix m constraint, but something makes it a MonadFix (t m) constraint apparently, which then becomes what I see here.
07:20:06 <erider> good morning
07:20:34 <malcolmw> fasta; continuation monad layered over state transformer monad - so find operations that are continuation-specific, and see if any are missing a liftM
07:20:58 <fasta> malcolmw: you mean lift, since liftM does not exist
07:21:16 <malcolmw> fasta: or maybe there is an extra lift where one is not needed
07:23:45 <dons> nice "Gentle, yet insistent executive summary: If you don't know how compilers work, then you don't know how computers work. If you're not 100% sure whether you know how compilers work, then you don't know how they work."
07:32:25 <fasta> malcolmw: liftM does exist, my mistake
07:32:40 <fasta> But you meant lift, still ;)
07:36:04 <fasta> Ok, I found what's causing it.
07:47:30 <fasta> What's the difference between :i <function> and :t <function>, since the types differ?!
07:47:55 <dons> example?
07:48:15 <dons> it just uses the type defined in the documentation, :i, iirc.
07:48:27 <dons> but :t uses the inferred type, so there might be alpha-renaming.
07:48:31 <fasta> dons: and if there is none?
07:48:40 <fasta> dons: this is not alpha renaming
07:48:50 <fasta> dons: one type is strictly more general than the other
07:49:03 <dons> is it for a built in function?
07:49:20 <fasta> dons: no
07:49:24 <dons> i wasn't aware :info even worked on non-base library stuff
07:49:50 <dons> possible there's type constraints in the expression given to :t
07:50:18 <fasta> dons: and the constraints are solved in some smarter way?
07:50:55 <dons> well, ghci + :t has generalised defaulting
07:51:25 <dons> sorry, :t doesn't actually
07:51:40 <Saizan> heh, :t 1 doens't give Integer
07:51:56 <dons> Prelude> :t []
07:51:56 <dons> [] :: [a]
07:51:56 <dons> Prelude> []
07:51:56 <dons> []
07:52:03 <dons> see in the latter a particular show instance was picked.
08:01:50 <igli> dons: i like teh quote, where's it from? ;)
08:02:40 <mehrheit> @src div
08:02:40 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
08:02:50 <mehrheit> @type div
08:02:53 <lambdabot> forall a. (Integral a) => a -> a -> a
08:03:01 <mehrheit> @src Int div
08:03:01 <lambdabot> Source not found. I feel much better now.
08:03:16 <mehrheit> how does div/mod differ from quot/rem?
08:04:31 <Saizan> mehrheit: in how they handle negative numbers, one approximate to 0, the other to -infinity
08:04:48 <mehrheit> example?
08:06:42 <igli> er look up div in any C text
08:07:10 <Saizan> > (-1) `div` 2
08:07:12 <lambdabot>  -1
08:07:16 <Saizan> > (-1) `quot` 2
08:07:19 <lambdabot>  0
08:07:25 <edwardk> > (-2 `mod`6,-2 `rem` 6)
08:07:27 <lambdabot>  (-2,-2)
08:07:31 <edwardk> er
08:07:50 <mehrheit> > (1 `div` 2, 1 `quot` 2)
08:07:52 <lambdabot>  (0,0)
08:07:58 <Saizan> unary minus binds less than `` :)
08:08:10 <edwardk> hah
08:08:18 <edwardk> wrong language =)
08:08:25 <edwardk> i got confused for a sec
08:09:11 <edwardk> > ((-2) `mod`6,(-2) `rem` 6)
08:09:13 <lambdabot>  (4,-2)
08:09:16 <edwardk> better =)
08:15:59 * mehrheit thinks about writing a simple functional language -> Elektronika MK 61 machine code compiler
08:25:31 <ndm> malcolmw: have you checked the .obj files into the compiler darcs?
08:25:47 <malcolmw> ndm: what .obj files?
08:25:50 <ndm> i have half a patch to build Yhc with compiler, but it doesn't yet work
08:26:03 <ndm> M ./Util/Text.obj
08:26:20 <ndm> unless i've broken that since i rebuilt?
08:26:28 <ndm> all the .obj files are listed as modified
08:26:51 <ndm> hmm, they aren't in the repo
08:26:54 <malcolmw> there's no .obj in my repo
08:26:58 <ndm> i guess something has confused something somewhere
08:27:14 <ndm> i can now build compiler with Scons
08:27:22 <ndm> but it gives rather random error messages just after...
08:28:10 <malcolmw> I'm finding that the compiler does not accept flags like -Pdir/to/prelude
08:28:42 <ndm> and it did before?
08:29:00 <malcolmw> nhc98 did, but clearly yhc does not
08:29:43 <malcolmw> there's some rather cookie sanity checking on flags, that rejects -Pdir because it is not `elem` opts
08:30:05 <malcolmw> and of course, it could never be `elem` opts because the dir must differ
08:30:16 <ndm> i think we should both use to GetOpts based command lines
08:30:20 <ndm> make it 100% standardised
08:30:42 <malcolmw> didn't you write the current Flags-processing code? :-)
08:31:09 <ndm> yes :)
08:31:20 <ndm> on the plane to ICFP 05
08:31:27 <malcolmw> ah...
08:31:33 <ndm> which means i was still learning Haskell, and its over two years old
08:34:54 <ndm> do you mind if MainYhc.hs becomes Main.hs again?
08:35:08 <dmhouse> Hey, anyone use Emacs on Gentoo or Debian here?
08:35:12 <dmhouse> (And uses GHC.)
08:35:18 <ndm> i have no idea how to fix the Scons otherwise, since its in the GHC module for Scons, which is ~1000 lines on its own
08:35:31 <ndm> and i still don't know python...
08:36:09 <malcolmw> ndm: can't you just search for Main.hs and replace?
08:36:17 <ndm> malcolmw: not really, no
08:36:22 * dmhouse will brb
08:36:31 <ndm> malcolmw: can i change it now, and promise to change it back once i figure out how the hell scons does anything?
08:37:07 <malcolmw> ndm: you can do what you like in your own repo, provided it doesn't pollute the rest of us :-)
08:37:26 <ndm> malcolmw: not the way it works now...
08:38:19 * dmhouse returns
08:38:36 * Igloo reads Malcolm's message and can't help but think "[YN]hs-as-a-library"
08:38:55 <malcolmw> Igloo: it is the ultimate intention
08:39:06 <Igloo> Ah, cool
08:39:06 <dmhouse> No volunteers? :) I just need a new bit of code testing for haskell-mode, it'll take a few seconds.
08:39:17 <malcolmw> Igloo: needs to become more modular first though
08:39:24 <Igloo> dmhouse: I don't qualify to volunteer  :-)
08:39:30 <malcolmw> well-defined interfaces and all that
08:39:33 <dmhouse> Igloo: what are you using?
08:39:45 <ndm> we have Yhc.Core, and Yhc.ByteCode, and before we that we have Yhc.Pain
08:43:08 <byorgey> dmhouse: I use emacs and GHC on Ubuntu, is that close enough?
08:43:22 <dmhouse> byorgey: sounds good.
08:43:49 <byorgey> dmhouse: what do you need?
08:43:52 <hpaste>  dmhouse pasted "Finding haddock documentation" at http://hpaste.org/361
08:44:22 <dmhouse> byorgey: if you could copy that sexp, then paste it into scratch and press C-j with the point after it, then tell me the results
08:44:51 <Igloo> dmhouse: vim
08:45:04 <LeCamarade> :o)
08:45:34 <dmhouse> Igloo: *shudders* Ah. I see. *Backs away, slowly, smiling*
08:45:52 <dmhouse> Actually seeing some of the support Vim had for Haskell has inspired this latest hacking attempt :)
08:46:07 <byorgey> dmhouse: it just prints out "http://haskell.org/ghc/docs/latest/html/libraries")
08:46:15 <byorgey> erm, without the trailing )
08:46:25 <dmhouse> byorgey: okay. Do you have GHC installed, yes?
08:46:28 <byorgey> yup
08:47:27 <dmhouse> Do you have the documentation installed? I'd expect it to be at /usr/share/doc/ghc6.6-doc.
08:48:19 <byorgey> dmhouse: nope.  would you like me to install it and try again?
08:49:04 <dmhouse> byorgey: if you could, that would be convenient. It'd also be to your benefit, in case you ever need to hack Haskell without a network connection.
08:49:06 <dmhouse> :)
08:49:11 <byorgey> dmhouse: good point =)
08:49:22 <fasta> dmhouse: the directory is OK
08:49:38 <fasta> dmhouse: It's ghc6-doc
08:49:48 <dmhouse> fasta: right. Have you tried the code?
08:49:51 <fasta> dmhouse: no
08:49:58 <dmhouse> fasta: could you, pwease? :)
08:50:59 <byorgey> dmhouse: now it prints "file:///usr/share/doc/ghc6-doc/html/libraries"
08:51:13 <fasta> dmhouse: "file:///usr/local/share/ghc-6.5/html/libraries"
08:51:18 <fasta> dmhouse: you should sort by date
08:51:28 <fasta> dmhouse: and get the newest
08:51:36 <robyonrails> what are high-order functions?
08:51:38 <dmhouse> byorgey: Great. :) Is that the directory with the docs in it, I presume?
08:51:43 <byorgey> sure is
08:51:46 <dmhouse> robyonrails: functions that take other functions as arguments.
08:51:48 <fasta> dmhouse: and have it be overridden by a configuration option
08:51:54 <fasta> dmhouse: default should be newest.
08:51:57 <dmhouse> robyonrails: for example, map, filter...
08:52:00 <fasta> dmhouse: does that help?
08:52:05 <dmhouse> fasta: that's a good idea.
08:52:44 <fasta> dmhouse: are you distributing your improvements?
08:53:00 <dmhouse> fasta: this will hopefully form part of an improvement to haskell-mode, yes.
08:53:10 <fasta> dmhouse: now we only need documented functions ;)
08:53:27 <dmhouse> fasta: namely, an inferior-haskell-find-haddock function that allows you to look up the Haddocks of the identifier at point.
08:53:42 <dmhouse> fasta: in Haskell, you mean?
08:53:44 <fasta> dmhouse: Eldoc is _very_ nic
08:53:47 <fasta> nice*
08:54:06 <fasta> dmhouse: Haskell should move towards that, imho.
08:54:44 <fasta> dmhouse: it should also work for code that's not in that dir.
08:55:04 <dmhouse> fasta: it fits very nicely into Elisp's symbols concept. Perhaps it'd be harder to have in Haskell. IMO if you build the tools smart enough, then there's nothing wrong with Haddock.
08:55:25 <dmhouse> fasta: what should also work for code not in which dir? You mean local code, part of the current project?
08:55:37 <fasta> dmhouse: yes, I mean that
08:55:59 <dmhouse> That's the long-term plan.
08:56:17 <dukedave> Hey gang, I know we're generally not into specifying the order computations happen, but, with the following can I *always* guarantee that the (not . null) will catch [] before head fails on a pattern match.. ?
08:56:19 <fasta> dmhouse: I wonder whether that's even possible to do efficiently
08:56:23 <dukedave> > (\x xs -> (not . null) xs && ((== x) . head) xs) 'd' "dave"
08:56:25 <lambdabot>  True
08:56:27 <dmhouse> fasta: would you like to see the code as a whole? If you're interested. No pressure if not, Stefan (haskell-mode's maintainer) will be looking over anyway.
08:56:30 <dukedave> > (\x xs -> (not . null) xs && ((== x) . head) xs) 'd' []
08:56:31 <lambdabot>  False
08:56:38 <fasta> dmhouse: no
08:56:52 <dmhouse> dukedave: yes.
08:57:09 <dmhouse> dukedave: of course, you could also do (\x xs -> if not (null xs) then head xs == x)
08:57:21 <dukedave> Haha,
08:57:29 <dukedave> I knew there was a pretty way of expressing it
08:57:51 <dukedave> Was just about to ask, so thanks for preempting :)
08:58:05 <dmhouse> Err, actually, that's not as elegant
08:58:10 <robyonrails> thanks dmhouse I read right now
08:58:10 <dmhouse> As you'd need an 'else False' bit.
08:59:04 <dmhouse> dukedave: if you're writing this as a standalone function, incidentally, the idiomatic way of doing it would be as follows:
08:59:09 <dmhouse> func _ [] = False
08:59:26 <dmhouse> func x (y:_) = x == y
08:59:36 <Phillemann> I've got a data type for polynomials, defined simply: data Polynom a = Polynom [a]. I want to make it an instance of "Num", so I can operate on those via *,+,-. Is it correct to say: instance Num Polynom where (+) = polynomAdd [...]?
08:59:52 <dmhouse> Phillemann: yeah.
09:00:11 <dmhouse> Phillemann: it'd probably have to be data Polynum a = Num a => Polynum [a], by the way.
09:00:13 <Phillemann> ghc says: parse error on input `='
09:00:31 <Phillemann> dmhouse: You're right, I'll add the Num a.
09:00:33 <dmhouse> Phillemann: paste your code? hpaste.org
09:00:40 <Saizan> you want instance Num (Polynom a) where ..
09:00:47 <dmhouse> Also true.
09:00:55 <dukedave> dmhouse: Yeah, I have an odd case where that lead to having to give four pattern matches for a function, which was a little unnatural in context..
09:00:57 <Phillemann> dmhouse: Hmm, can I then also use Fractionals with Polynom?
09:01:05 <dukedave> But good service :)
09:01:08 <dmhouse> Phillemann: of course. Fractional is a subclass of Num.
09:01:10 <Saizan> instance Num a => Num (Polynom a) where
09:01:16 <Phillemann> dmhouse: Ah, great. :)
09:01:40 <dmhouse> Saizan: or stick the dictionary directly in the type, it'd be unnatural to have a polynomial over a non-Num field.
09:02:11 <Saizan> dmhouse: contenxt inside data doesn't work so well
09:02:14 <chessguy> 'ello
09:02:37 <dukedave> Weird,
09:02:38 <Phillemann> The syntax error actually occurs in the second line: (*) = polynomMulti
09:02:39 <dukedave> > (\x xs -> if not (null xs) then head xs == x)
09:02:39 <lambdabot>  Parse error
09:02:43 <dmhouse> Saizan: where wouldn't it work? I know context before the type's name is best avoided, but I thought before a constructor would be okay.
09:02:50 <dmhouse> Phillemann: paste the code. :)
09:02:54 <dmhouse> dukedave: you need an 'else' clause.
09:02:58 <Phillemann> dmhouse: Well, okay...
09:03:13 <dmhouse> dukedave: so it'd have to be if not (null xs) then head xs == x else False, which isn't as elegant as you're (&&)-version.
09:03:18 <dukedave> Haha
09:03:25 <dmhouse> *your
09:03:36 <dukedave> Coffee break time I think
09:04:16 <Saizan> dmhouse: oh, ok, i was confusing it with type
09:04:16 <dukedave> Or possibly I should write "#haskell less, think more" next to my keyboard :)
09:05:01 <dmhouse> Saizan: in the equations for (+) etc. you'd probably write Polynum x + Polynum y, so you have access to the dictionary if you were to use context before the constructor.
09:05:29 <dmhouse> ?remember dukedave I should write "#haskell less, think more" next to my keyboard :)
09:05:29 <lambdabot> Done.
09:05:45 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/362
09:05:57 <dmhouse> Gah, why is Emacs Lisp's list handling so rubbish. It doesn't even have filter without importing a huge Common Lisp library.
09:05:59 <Phillemann> http://hpaste.org/362
09:06:10 <quicksilver> dmhouse: it really is odd, isn't it?
09:06:28 <quicksilver> dmhouse: lisp is potentially a pleasant language, and elisp is unbareably crippled, by default...
09:06:38 <dmhouse> Indeed.
09:06:52 <dmhouse> It's the PHP of the Lisp world.
09:07:10 <hpaste>  wellwisher pasted "Implementing the show function" at http://hpaste.org/363
09:07:45 <wellwisher> could some one help me with  "Implementing the show function" at http://hpaste.org/363
09:07:46 <wellwisher> ?
09:07:52 <edwardk> what Multi doesn't take a list of its actual colors? =)
09:07:59 <quicksilver> wellwisher: you haven't got a show instance for 'Card'
09:08:02 <Saizan> ok, now i want to know the intended difference between data Foo a => D a = D a and data D a = Foo a => D a
09:08:07 <quicksilver> wellwisher: you've done all its components
09:08:11 <quicksilver> wellwisher: but not Card itself
09:08:11 <wellwisher> I know
09:08:13 <dmhouse> Phillemann: just looking.
09:08:24 <edwardk> ah you get it from Mana
09:08:36 <shapr> @remember dmhouse elisp is the PHP of the Lisp world.
09:08:37 <lambdabot> Done.
09:08:39 <quicksilver> wellwisher: well that's what your error means :)
09:08:53 <quicksilver> wellwisher: incidentally you're "abusing" show
09:08:59 <hpaste>  dmhouse annotated "(no title)" with "This works for me" at http://hpaste.org/362#a1
09:09:02 <mehrheit> and PHP is the PHP of what world?
09:09:11 <vincenz> @paste
09:09:11 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:09:15 <LoganCapaldo> the actual world?
09:09:15 <dmhouse> Phillemann: it worked for me, once I fleshed out some of the functions with stubs.
09:09:23 <hpaste>  vincenz pasted ":(" at http://hpaste.org/364
09:09:36 <dmhouse> vincenz: do you honestly forget that URL?
09:09:50 <quicksilver> Saizan: the *intended* difference, I suppose, is that the first is a constraint on the whole data type, not the constructor
09:09:55 <Phillemann> dmhouse: Strange...
09:09:56 <vincenz> dmhouse: my terminal allows me to click on links, what's it matter to you
09:09:58 <quicksilver> Saizan: of course as you surely know, haskell doesn't allow that
09:10:04 <wellwisher> I have been unable to find good examples of how to implement the show function for Card
09:10:15 <quicksilver> wellwisher: deriving Show should do OK
09:10:22 <wellwisher> k
09:10:26 <quicksilver> wellwisher: although what you're doing is not really what Show is for
09:10:41 <dmhouse> Phillemann: also, you don't need the Num constraints on polynomAdd etc as you already have the dictionaries when you unpack the constructors.
09:10:48 <mehrheit> LoganCapaldo, so lisp is a subset of the actual world, or a seperate world?
09:11:11 <LoganCapaldo> mehrheit: I'm not touching that one with a 10ft pole :)
09:11:12 <dmhouse> Yeah, you should pretty much never write your own Show instance, Show is for serialisation rather than pretty-printing.
09:11:34 <Saizan> quicksilver: what i get is that the first merely restrict the type of the contructor, where the second provide a context for a when pattern matching on D
09:11:35 <edwardk> wellwisher: you could also just go through and do something like instance Show Card where show (Card x y z ...) = show x ++ ":" ++ show y ++ ... or however you want to format it, but in general show is intended to be for something you can round trip through read, its 'bad form' to use show to actually show things ;)
09:11:50 <wellwisher> ok
09:12:11 <dmhouse> wellwisher: just write your own printCard function.
09:12:12 <Phillemann> dmhouse: Ah, damn, I accidently started the line with a tab.
09:12:19 <byorgey> interesting, for some reason I never knew that about Show.
09:12:21 <mehrheit> LoganCapaldo, why?
09:12:27 <edwardk> i often wish haskell had made the show/repr distinction that python has
09:13:04 <shapr> edwardk: me too!
09:13:28 <dukedave> I'll start using show properly when read isn't so cracktastic :)
09:13:30 <byorgey> so to "actually show things" one should create one's own Show-like class?
09:13:34 <edwardk> heh
09:13:35 <edwardk> yeah
09:13:36 <LoganCapaldo> mehrheit: I fear the potential fallout
09:13:38 <quicksilver> yup
09:13:42 <wellwisher> what is the syntax for deriving muliple types at a time
09:13:43 <edwardk> byorgey: pathetic i know
09:13:49 <quicksilver> wellwisher: deriving (Eq,Show)
09:13:51 <edwardk> wellwisher: deriving (Foo,Bar)
09:14:00 <edwardk> @stereo
09:14:01 <lambdabot> Unknown command, try @list
09:14:06 <edwardk> @quote stereo
09:14:06 <quicksilver> show is intended for debugging, really
09:14:06 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
09:14:14 <mehrheit> quote stereo should be aliased to stereo
09:14:24 <edwardk> yeah, its used so often these days
09:14:25 <mehrheit> or s
09:14:31 <LoganCapaldo> heck
09:14:43 <mehrheit> probably third most used after eval and type
09:14:44 <LoganCapaldo> lb should detect stereo answers and say it herself :)
09:15:06 <edwardk> hah
09:15:12 <byorgey> hmm... how exactly would "stereo detection" work?
09:15:15 <shapr> edwardk: But probably Show and Serialize would be better.
09:15:28 <mehrheit> LoganCapaldo, that would, of course, require lisp, the AI language
09:15:29 <LoganCapaldo> byorgey: same way as spell I imagine?
09:15:34 <quicksilver> shapr: even though Show/Read is not enough for 'real serialisation'
09:15:45 <quicksilver> shapr: I think there is some expectation Show produces stuff you can 'copy into your REPL'
09:15:47 <edwardk> well, i'd like a textual rep, and a good way to pickle
09:15:49 <byorgey> LoganCapaldo: hmm, probably
09:15:49 <quicksilver> shapr: at least, that's how I use it
09:15:59 <heanol> what's a repl?
09:16:00 <edwardk> and a good human readable text rep
09:16:04 <shapr> quicksilver: That's a good point.
09:16:05 <LoganCapaldo> If the levenstein distance between two close in time messages was small, @quote stereo
09:16:08 <quicksilver> that's why the Show instance of Data.Map produces fromList
09:16:16 <byorgey> heanol: Read-Eval-Print-Loop
09:16:18 <quicksilver> heanol: Read-Eval-Print-Loop
09:16:20 <quicksilver> heanol: like ghci
09:16:20 <edwardk> heanol: read-eval-print loop, its the interactive part of things like ghci
09:16:22 <byorgey> heh
09:16:26 <mehrheit> @quote stereo
09:16:26 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
09:16:28 <heanol> haha thanks
09:16:47 <byorgey> I think that was "trineo" or something
09:16:56 <quicksilver> "stereo" isn't about "two"
09:17:05 <byorgey> yeah, I just realized that after I hit Enter =P
09:17:07 <quicksilver> it's about "three dimensional / space filling" :)
09:17:12 <dukedave> Oh oh can I write the stereo detection? :)
09:17:20 <edwardk> yeah we're working up to quadraphonic sound
09:17:30 <dukedave> And is it the sort of thing I'm likely to be able to do in a few hours?
09:17:30 <byorgey> dukedave: go for it
09:17:44 <byorgey> dukedave: that depends.
09:17:50 <dukedave> ...Having never written a lambda bot plugin..
09:17:59 <edwardk> dukedave: getting lambdabot built may take more than a few hours ;)
09:18:05 <dukedave> Lmao
09:18:09 <edwardk> just to get the dependencies right, then its easy going
09:18:12 <Philippa> edwardk: and not THX?
09:18:12 <dukedave> @wiki lambdabot
09:18:13 <lambdabot> http://www.haskell.org/haskellwiki/lambdabot
09:18:27 <Saizan> just building lambdabot can take hourds
09:18:35 <shapr> herds?
09:18:36 <mehrheit> dukedave, that would require neural networks for detection of similarity of answers
09:18:59 <mehrheit> and the execution of quote stereo, when the sum of them reaches a certain threshold
09:19:09 <Saizan> shapr: yeah, you have to sacrifice something to the lambda gods, you know
09:19:27 <dukedave> Good job my masters is computational intelligence then :D
09:19:33 <mehrheit> you might as well create thresholds for 2.1, 5.1 and 7.1
09:19:45 <dukedave> That's an interesting way of looking at it incidentally..
09:22:58 <vincenz> http://notvincenz.blogspot.com/2007/06/generalized-matrix-multiplication.html
09:23:01 <lambdabot> Title: lambda.oasis: Generalized Matrix Multiplication, http://tinyurl.com/26eqqx
09:25:28 <dukedave> Does anyone know the site (wiki based) where solutions to common programming problems are given in all languages? I think it was mentioned on haskell-cafe a few days ago :|
09:26:25 <dukedave> Ah got it:   http://en.literateprograms.org/
09:26:28 <lambdabot> Title: LiteratePrograms:Welcome - LiteratePrograms
09:34:08 <mehrheit> > 1 :: BigFloat
09:34:16 <lambdabot>   Not in scope: type constructor or class `BigFloat'
09:47:08 <dmhouse> fasta: ping
09:47:18 <fasta> pong
09:47:34 <fasta> dmhouse: pong
09:47:38 <dmhouse> fasta: got a couple of moments to check the latest version of the haddock-detecting code? It should pick up which dir is newre.
09:47:43 <dmhouse> s/newre/newer/
09:47:47 <fasta> dmhouse: k
09:48:05 <fasta> dmhouse: what OS are you on?
09:48:22 * byorgey can provide regression testing =)
09:48:37 <dmhouse> fasta: Ubuntu GNU/Linux.
09:48:39 <dmhouse> byorgey: sure.
09:49:10 <hpaste>  dmhouse annotated "Finding haddock documentation" with "Latest haddock discovery" at http://hpaste.org/361#a1
09:49:19 <fasta> dmhouse: Ubuntu changed the location of the doc packages?.. Whoa
09:50:19 <dmhouse> fasta: ? No, the Ubuntu docs should be at /usr/share/doc/ghc6-doc. What makes you think it's otherwise?
09:50:32 <fasta> dmhouse: because you ask me to check
09:50:34 <dmhouse> (Incidentally, mine are at /usr/local/share/ghc-6.6.1, having compiled GHC from source.)
09:50:55 <fasta> dmhouse: "file:///usr/share/doc/ghc6-doc/html/libraries"
09:50:59 <dmhouse> fasta: oh, I was probably just being sure.
09:51:02 <fasta> dmhouse: seems to work
09:51:05 <dmhouse> Great.
09:51:08 <byorgey> dmhouse: still works for me too
09:51:14 <dmhouse> Thanks both.
09:51:33 <fasta> dmhouse: Another idea...
09:51:57 <fasta> dmhouse: what do you do when someone did compile it from source?
09:52:19 <dmhouse> fasta: they should end up at /usr/local/share/ghc-<version>, if they've used the default prefices.
09:52:40 <fasta> dmhouse: it's better to detect the current running version
09:53:06 <fasta> dmhouse: that is, assuming you want to write good software, not just something that works most of the times. :)
09:53:11 <dmhouse> fasta: how? By doing a ghc --version?
09:53:26 <fasta> dmhouse: no, haskell-program-name
09:53:43 <dmhouse> That's "ghci" for mel.
09:53:44 <dmhouse> *me
09:53:55 <fasta> dmhouse: oh, right, that was a wrong idea.
09:54:03 <fasta> dmhouse: mine is a script
09:54:41 <dmhouse> fasta: ah, okay.
09:54:55 <fasta> dmhouse: hmm, maybe there is another way to get it.
09:54:56 <sorear> Grumble, grumble.
09:55:01 <sorear> topdecls       : topdecls1   { () } |             { () }
09:55:04 <sorear> topdecls1      : topdecl     { () } | topdecls ";" topdecls1 { () }
09:55:30 <sorear> Sequence boilerplate -> errors.   I miss my HOFs.
09:55:30 <dmhouse> fasta: ghc --version would do it, but I'm not sure when that would differ from just finding the most recently modified docs.
09:55:49 <fasta> dmhouse: No, ghc --version would only call the one in the PATH
09:56:00 <fasta> dmhouse: not the one running in Haskell mode
09:56:27 <fasta> dmhouse: Still it must be possible to traverse the tree of processes in some way.
09:56:28 <dmhouse> fasta: ah, I see what you mean. Well, I could call haskell-program-name with --version, but still, it seems a bit pointless.
09:57:14 <fasta> dmhouse: It would be the correct solution, though.
09:57:26 <fasta> dmhouse: You can do the same as pstree does
09:58:35 <dmhouse> fasta: I think it's getting too pedantic. There's a tradeoff between code readability and accuracy. My current code will work in nearly all situation; I can't think why you want to modify old docs once you have newer ones.
09:58:59 <fasta> dmhouse: Is it about modifying docs?
09:59:05 <fasta> dmhouse: I thought it was about viewing docs
09:59:33 <fasta> dmhouse: When I have a stable installation and a bleeding edge, I want to see stable when running stable.
09:59:35 <dmhouse> It's for viewing docs, but the only way my code will fail is if you modify old docs so that their modification time is newer than your newer docs.
09:59:39 <fasta> dmhouse: I think that case is pretty common.
09:59:59 <fasta> dmhouse: What about the case I just described?
10:00:15 <dmhouse> That's a possibility.
10:00:42 <dmhouse> I'd still be inclined to push the code as-is and change it if it turned out to be an issue. We're talking very hypothetically here; it could easily be a non-issue.
10:00:56 <dmhouse> This is just the default value for a customisation variable anyway, one can always change it.
10:01:26 <fasta> dmhouse: It's polish. It makes the code smarter.
10:01:33 <fasta> dmhouse: but it's your call, of course.
10:03:05 <dmhouse> Perhaps unneccessarily smart, that's my only concern. There'll only be a problem if you have docs newer than the docs you want to use, _and_ those docs are incompatible, _and_ you can't be bothered to change the customisable variable.
10:04:10 <Phillemann> I get an error now saying: Could not deduce (Eq (Polynom a), Show (Polynom a)) from the context (Num a)
10:04:22 <dmhouse> Phillemann: code? :)
10:04:44 <Phillemann> Same as before.
10:04:54 <dmhouse> Which line?
10:05:11 <Phillemann> I had to remove "deriving Show" from the data-Line for Polynom though.
10:05:16 <Phillemann> dmhouse: "instance ..."
10:05:34 <dmhouse> Phillemann: ah, you'll need to declare instances for your Polynom type for Eq and Show.
10:05:58 <dmhouse> Phillemann: the reason is that (somewhat annoyingly) Eq and Show are superclasses of Num. I.e. the definition of Num is class (Eq a, Show a) => Num a where ...
10:06:11 <Phillemann> Ah, I thought of something like this.
10:06:24 <dmhouse> (For example in my annotation I declared two dummy instances.)
10:06:38 <Phillemann> So the compiler cannot (or does not want to) derive Show and Eq anymore. :/
10:08:12 <dmhouse> It's odd. I'm not sure why it doesn't do it. You know that the values in your list instantiate Show and Eq because they instantiate Num.
10:08:25 <quicksilver> haskell can't make that deduction
10:08:39 <quicksilver> it can't deduce (Eq a, Show a, Num a) => from (Num a) =>
10:08:49 <edwardk> wow, thats messed up
10:08:56 <dmhouse> quicksilver: it can decude Eq a and Show a given Num a.
10:09:04 <edwardk> it should be able to
10:09:19 <dmhouse> f :: Num a => a -> String
10:09:20 <dmhouse> f = show
10:09:23 <dmhouse> That compiles fine
10:09:34 <quicksilver> oh, does it?
10:09:53 <dmhouse> quicksilver: because the definition of Num is class (Eq a, Show a) => Num a, so anything that instatiates Num also instatiates Eq and Show.
10:10:04 <quicksilver> :t (f :: Num a => a -> String) = show
10:10:05 <edwardk> heh i guess it has to, i abuse that on a fairly frequent basis actually
10:10:07 <lambdabot> parse error on input `='
10:10:16 <quicksilver> :t let (f :: Num a => a -> String) = show in f
10:10:20 <lambdabot> forall a. (Num a) => a -> String
10:10:26 <quicksilver> so it does
10:10:29 <quicksilver> I stand corrected :)
10:10:36 <quicksilver> I really didn't think it did that
10:10:43 <dmhouse> quicksilver: otherwise there'd be no point placing Show and Eq constraints on the Num class.
10:11:35 <dmhouse> As they wouldn't give you any extra information when using Num values. The entire point of their being there is so you can write stuff like f 5 = blah, and not have to put an extra Eq constraint in your type signature.
10:11:58 * quicksilver nods
10:12:02 <quicksilver> good point
10:12:12 <dmhouse> I guess the Show is so when you type '5' into GHCi it doesn't say "Error: cannot deduce Show a from Num a", which would scare off the newbies.
10:12:32 <dmhouse> (Although there are better ways of solving that problem, defaulting being one of them.)
10:12:41 <byorgey> dmhouse: heh
10:12:44 <dmhouse> Actually, disregard my comment on Show, that doesn't work at all.
10:12:51 <edwardk> yeah, show is off the requirements in my numerical tower at the moment
10:13:02 <dmhouse> As it'd need to know _which_ Show instance to use, not just that one existed.
10:13:10 <dmhouse> So I have no idea why Show is a superclass of Num :)
10:13:29 <edwardk> though i wish the numerical tower started at 'magma' and built from there ;)
10:13:31 <edwardk> but i'm a purist ;)
10:13:35 <dmhouse> (Needing to know _which_ Show instance to use when you type 5 into GHCi is the entire reason for defaulting.)
10:16:50 <byorgey> @src filter
10:16:50 <lambdabot> filter _ []     = []
10:16:51 <lambdabot> filter p (x:xs)
10:16:51 <lambdabot>     | p x       = x : filter p xs
10:16:51 <lambdabot>     | otherwise = filter p xs
10:16:52 <fasta> I would like that everything was showable by default.
10:17:29 <dmhouse> fasta: it'd be nice to have a generic object printer, yeah. I think one was developed as part of the effort toward debugging in GHCi.
10:17:50 <dmhouse> http://haskell.org/haskellwiki/GHC/GHCi_debugger
10:17:51 <lambdabot> Title: GHC/GHCi debugger - HaskellWiki
10:18:00 <fasta> dmhouse: I also think we need to leave the text based interface for "object printing".
10:19:24 <LeCamarade> fasta: I agree with you profusely.
10:19:31 * sorear extracts a 300 line type error from ghc
10:19:57 * byorgey hands sorear a medal
10:20:03 <fasta> sorear: that's not much fun, eh?
10:20:34 <sorear> fasta: the happy docs DID warn me that tracking down type errors would be fun :)
10:20:35 <LeCamarade> sorear: And what has the doctor said?
10:20:45 <LeCamarade> :o)
10:21:36 <fasta> It's Open Sores software, so you should get plenty  ;) </troll>
10:25:16 <sorear> suprisingly painless :)
10:25:43 <sorear> and I can parse { type Foo a b = b -> a } now
10:26:03 <LeCamarade> vincenz: ping
10:32:11 <LeCamarade> @tell vincenz I wanted to talk to you about http://notvincenz.blogspot.com/2007/04/observations-from-date-2007.html.
10:32:12 <lambdabot> Consider it noted.
10:34:35 <mdmkolbe|work> heh, for the first time that I can ever recall I just created an off-by-one error in haskell
10:35:24 <LoganCapaldo> off by one really?
10:35:26 <LoganCapaldo> wow
10:36:49 <mehrheit> > 1:2:3:[] !! 1
10:36:51 <lambdabot>  Exception: Prelude.(!!): index too large
10:36:53 <mdmkolbe|work> LoganCapaldo: the problem is to take the list [(1, 'a'), (3, 'b')] and the minimum length 5 to generate the list [Nothing, Just 'b', Nothing, Just 'a', Nothing]
10:37:04 <mehrheit> > [1,2,3] !! 1
10:37:07 <lambdabot>  2
10:37:32 <DRMacIver> Hm. Curious. I wonder why !! has higher precedence than :
10:37:33 <mdmkolbe|work> (this is for implementing memory stack layouts in GHC)
10:37:34 <byorgey> > (1:2:3:[]) !! 1
10:37:36 <lambdabot>  2
10:37:56 <byorgey> DRMacIver: seems odd, doesn't it?
10:37:56 * LoganCapaldo doesn't think he understands how the function works
10:38:09 <LoganCapaldo> oh wait
10:38:20 <LoganCapaldo> I gotcha now
10:38:24 <mdmkolbe|work> :-)
10:38:47 <byorgey> @info (:)
10:38:47 <lambdabot> (:)
10:38:59 <byorgey> well that's useful
10:39:01 <LeCamarade> You know, I generally hate precedence. Sorry.
10:39:15 <LeCamarade> My ideal language would have undefined precedence.
10:39:23 <byorgey> LeCamarade: such an attitude is not without precedent.
10:39:29 <DRMacIver> LeCamarade: 'lisp'? :)
10:39:36 <LeCamarade> byorgey: :oD
10:39:44 <byorgey> LeCamarade: J also has no precedence
10:39:55 <mehrheit> isn't it possible to redefine precedence in haskell?
10:40:01 <LoganCapaldo> > map (flip lookup [(1, 'a'), (3, 'b')]) [0..4]
10:40:02 <LeCamarade> DRMacIver: Lisp? I'm offended. :o)
10:40:03 <lambdabot>  [Nothing,Just 'a',Nothing,Just 'b',Nothing]
10:40:05 <wellwisher> is there a function that is the oposite of show?
10:40:07 <sorear> read
10:40:13 <sorear> > read "2.0" :: Double
10:40:15 <lambdabot>  2.0
10:40:16 <DRMacIver> LeCamarade: Liskell then. ;)
10:40:22 <sorear> > read "\"foo\"" :: String
10:40:23 <byorgey> mehrheit: yes.
10:40:24 <lambdabot>  "foo"
10:40:39 <mehrheit> well, then LeCamarade could set all operators to the same precedence
10:40:45 <DRMacIver> I sortof agree though.
10:40:55 <LeCamarade> DRMacIver: It's the parens ... they make me a parser. I like to think I'm writing for a parser, not being a parser.
10:41:05 <mehrheit> DRMacIver, ((+) 2 2) -- liskell we have
10:41:15 <DRMacIver> mehrheit: I know.
10:41:24 <DRMacIver> It wasn't a name I picked at random. :)
10:41:39 <DRMacIver> LeCamarade: But if you ditch precedence, you get an awful lot more parentheses.
10:41:45 <LeCamarade> mehrheit: Yeah. All my code ignores precedence. ((1 + 2) * 3) is my kind of thing. _I don't know precedence!_
10:42:10 <LeCamarade> DRMacIver: Yeah. I get all the parens - but not when I'm trying to print `Hello, World!'! :o)
10:42:11 <sorear> 1 2 + 3 *
10:42:13 <sorear> ftw
10:42:21 <sorear> no parens AND no precedence
10:42:26 * byorgey fully parenthesizes and then removes them until something breaks
10:42:29 <LeCamarade> orbitz: Forth! Forth!
10:42:36 <hpaste>  mdmkolbe|work pasted "off-by-one demonstraied in haskell" at http://hpaste.org/365
10:42:44 <LeCamarade> *or*
10:42:46 <sorear> LeCamarade: where did orbitz come in?
10:42:47 <DRMacIver> Anyway, I'm ambivalent on the subject. Sometimes I agree with you, sometimes I find precedence improves readability dramatically.
10:42:58 <mehrheit> sorear, how do you write x*y + z*w in RPN?
10:43:02 <LeCamarade> sorear: Just tabbed in BitchX. :o( Meant `or'
10:43:05 <sorear> x y * z w *
10:43:07 <sorear> x y * z w * +
10:43:13 <sorear> mehrheit: ^^ easily
10:43:15 <LoganCapaldo> mdmkolbe|work: did you see how i did it?
10:43:16 <DRMacIver> sorear: Ah, RPN, combining the writability of lisp with the readability of perl. :)
10:43:25 <LeCamarade> 1 2 + 3 *  ( Forth! Forth! )
10:43:32 <LoganCapaldo> > map (flip lookup [(1, 'a'), (3, 'b')]) [0..4]
10:43:34 <mdmkolbe|work> LoganCapaldo: now I did
10:43:34 <lambdabot>  [Nothing,Just 'a',Nothing,Just 'b',Nothing]
10:43:42 <sorear> mehrheit: indeed it can be fully automated!
10:43:43 <fasta> DRMacIver: but you make really small words
10:43:55 <DRMacIver> fasta: Hm?
10:43:55 <fasta> DRMacIver: not that I buy that argument ;)
10:44:11 <fasta> DRMacIver: word is a Forth concept
10:44:12 <mehrheit> sorear, too bad my MK 61 has only two rpn registers, so that is not possible
10:44:21 <sorear> MK 61 ?
10:44:34 <mehrheit> russian programmable RPN calculator
10:44:36 <DRMacIver> fasta: Yeah, I know. I'm just not sure what the context of "You make really small words" is.
10:44:45 * DRMacIver has only a passing familiarity with forth.
10:44:45 <sorear> my computer can have over a hundred million registers!
10:44:47 <mdmkolbe|work> LoganCapaldo: the actual problem though has veriable sized values.  so 'a', might fill up to slots making that [Nothing,Just 'a',Just 'b',Nothing]
10:44:49 <LeCamarade> DRMacIver: I find Perl very inspirational (as did Matz of Ruby). Frankly, since languages are user interfaces, why are they so horribly skewed? Not that Perl isn't a turing tarpit ...
10:45:21 <fasta> 19:42 <DRMacIver> sorear: Ah, RPN, combining the writability of lisp with the readability of perl. :)
10:45:52 <DRMacIver> fasta: Which one is the really small words supposed to help with? :)
10:45:56 <fasta> DRMacIver: by writing small words definition, you enhance the readability.
10:46:10 * LeCamarade has to kick a Forth compiler to help in implement a thing like Dr. Massalin's kernel. In Haskell, of course.
10:46:12 <LoganCapaldo> mdmkolbe|work: ah
10:46:14 <DRMacIver> LeCamarade: Languages require a largeish community to be useful and are thus particularly vulnerable to the "90% of everything is shit" issue.
10:46:33 <mdmkolbe|work> yours also has an off by one
10:46:33 <mehrheit> sorear, but my calculator has shiny green vacuum flourescent display and takes about 5 seconds to calculate the remainder of two integers
10:46:37 <mehrheit> so it is cooler
10:46:45 <DRMacIver> fasta: Mm. Maybe. I've not actually read enough RPN to form a strong opinion on it really. I'm just randomly trolling. :)
10:47:03 <mdmkolbe|work> >let size = 5 in map (flip lookup [(1, 'a'), (3, 'b')]) [0..size]
10:47:09 <fasta> DRMacIver: I was not being serious.
10:47:15 <DRMacIver> ok. :)
10:47:16 <LoganCapaldo> that wan't my code <g>
10:47:19 <LeCamarade> DRMacIver: Luckily, I only design languages for myself. So I can even put keywords like `sendmemail' (final error handler?)
10:47:23 <LoganCapaldo> 4 = size - 1
10:47:35 <mdmkolbe|work> LoganCapaldo: yeah, which was the mistake that I made the first time
10:47:44 <LoganCapaldo> I gathered :)
10:48:03 <mdmkolbe|work> LoganCapaldo: I got so used to never having to thing about adding or subtracting an extra 1 in haskell, that it never crossed my mind
10:48:10 <LoganCapaldo> mmm hmm
10:48:27 <LoganCapaldo> well it helped that I thought about the problem in terms of a Map
10:48:41 <DRMacIver> LeCamarade: Heh
10:49:00 <mdmkolbe|work> oh, well.  I guess the three hours I lost just now are compensated by the thousands of seconds I save usually by not even thinking about off-by-one in haskell
10:49:07 <LoganCapaldo> but yeah that won't fly (at least not that simplistically) if 'a' can take up multiple spaces
10:49:14 <LoganCapaldo> yep
10:49:17 <LoganCapaldo> hopefully :)
10:50:31 <byorgey> mdmkolbe|work, LoganCapaldo: seems like there should still be a higher-order way to do it that doesn't use explicit recursion/keeping track of a size count.
10:50:45 <LoganCapaldo> byorgey: I think so too
10:50:50 <byorgey> although I don't have any suggestions ATM. =)
10:50:52 <LoganCapaldo> I jsut don't know what it is :)
10:51:58 <mdmkolbe|work> byorgey: I would love to do it that way and would be glad to hear suggestions, but the interface must still take a size (because of where it is used in the compiler)
10:52:22 <dukedave> pirate
10:52:28 <dukedave> @pirate
10:52:29 <lambdabot> Unknown command, try @list
10:52:39 <dukedave> @list
10:52:39 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:52:48 <DRMacIver> @arr
10:52:48 <lambdabot> I'll crush ye barnacles!
10:52:52 <byorgey> mdmkolbe|work: of course, the problem isn't using a size per se, it's manually keeping track of the remaining size through recursion
10:53:17 * byorgey thinks
10:53:44 <dukedave> I see :)
10:53:50 <Phillemann> Is there a function to append an element to a list?
10:53:57 <DRMacIver> Are instances of Num required to be commutative / associative?
10:54:10 <dukedave> So with lambda bot, would I be able to write a plugin which monitors all chat?
10:54:14 <DRMacIver> Phillemann: If you plan to do that much you should probably be using a Sequence
10:54:16 <mdmkolbe|work> DRMacIver: no, b/c of floats and doubles
10:54:26 <DRMacIver> mdmkolbe|work: Ah, good point.
10:54:33 <dukedave> @hello
10:54:33 <lambdabot> Maybe you meant: help tell
10:54:36 <LoganCapaldo> > let foo vals size = groupBy (\x y -> case (x, y) of { (Nothing, _) -> False ; (_, Nothing) -> False ; (Just a, Just b) -> a == b }) $ map (flip lookup vals) [0..(size - 1)] in foo [(1, 'a'), (2, 'a'), (3, 'b')] 5
10:54:38 * DRMacIver was wondering about more exotic things like quaternions and octonions. :)
10:54:38 <mdmkolbe|work> byorgey: yeah, the point of this function was to move away from error prone offset numbers and sizes.  turns out that doing that is itself a very error prone process
10:54:44 <lambdabot>  [[Nothing],[Just 'a',Just 'a'],[Just 'b'],[Nothing]]
10:54:56 <dukedave> @help plugins
10:54:56 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
10:55:04 <dukedave> @help list
10:55:04 <lambdabot> list [module|command]
10:55:04 <lambdabot> show all commands or command for [module]. http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
10:55:04 <LoganCapaldo> > let foo vals size = map head $ groupBy (\x y -> case (x, y) of { (Nothing, _) -> False ; (_, Nothing) -> False ; (Just a, Just b) -> a == b }) $ map (flip lookup vals) [0..(size - 1)] in foo [(1, 'a'), (2, 'a'), (3, 'b')] 5
10:55:06 <lambdabot>  [Nothing,Just 'a',Just 'b',Nothing]
10:55:25 <mdmkolbe|work> O.o
10:55:40 <LoganCapaldo> I'm not sure if that's what you meant by 'a' taking up multiple places
10:56:15 <mdmkolbe|work> LoganCapaldo: no
10:56:25 <LoganCapaldo> oh well :)
10:56:29 <byorgey> LoganCapaldo: I think there's supposed to be a function which given 'a' tells you how many places it's supposed to take up
10:56:34 <mdmkolbe|work> LoganCapaldo: the 'a' and such are values on the stack, some of them take up two words
10:56:40 <LoganCapaldo> ah
10:57:17 <mdmkolbe|work> LoganCapaldo: so if 'a' is a double, then it only has one entry in the lookup table, but we have a function that tells us it takes two words.  size is measured in words
10:57:25 <LoganCapaldo> k
10:59:28 <quicksilver> you mean sizeOf, in Storable?
10:59:41 <byorgey> maybe a two-pass sort of thing?  first do LoganCapaldo's thing with flip lookup, then go through the list looking for things that take up more than one word and delete the Nothings after them?
10:59:57 <byorgey> that seems kind of kludgy though, I guess
11:00:42 <quicksilver> with lazy evaluation, two-pass algithms are one-pass :)
11:00:51 <mdmkolbe|work> quicksilver: no, it's machRepSizeW on RegReps (I can get you the exact function names if you want)
11:00:53 <byorgey> quicksilver: right =)
11:01:50 <byorgey> quicksilver: of course by "two-pass" I really meant "the composition of two functions which..."
11:02:18 * quicksilver nods
11:02:50 <dukedave> Erm, the ghc-pkg tool, is that a full blow package manager like cpan ?
11:02:58 <dukedave> *blown
11:03:05 <dmhouse> Ish.
11:03:25 <dukedave> Can I automagically get packages?
11:03:25 <dmhouse> It can't download stuff, if that's what you mean. It's used for registering packages with GHC and querying details about them.
11:03:33 <dmhouse> That support is coming.
11:03:36 <dukedave> Ah
11:03:37 <dmhouse> ?where cabal-install
11:03:37 <lambdabot> I know nothing about cabal-install.
11:03:42 <dmhouse> ?google cabal-install
11:03:44 <lambdabot> http://haskell.galois.com/trac/hackage/wiki/CabalInstall
11:03:44 <lambdabot> Title: CabalInstall - Hackage - Trac
11:04:02 <dmhouse> ?where+ cabal-install http://haskell.galois.com/trac/hackage/wiki/CabalInstall
11:04:02 <lambdabot> Done.
11:06:51 <dukedave> Any idea where one  might find base-2.0
11:08:25 <dmhouse> GHC HEAD, I think. It might be in GHC 6.6.1, lemme check.
11:08:40 <dukedave> Hm, am I about to get out of my depth :)
11:08:50 <dmhouse> Yeah, it is. Wait, 6.6.1 might actually be HEAD...
11:09:14 <dmhouse> Nope, I'm actually running a stable version! How odd. So yeah, use GHC 6.6.1 :)
11:09:18 <dukedave> I've found the docs on hackage & they have arrows :o
11:10:08 <mdmkolbe|work> GHC HEAD is 6.7, it has base-2.1 in it
11:10:29 <dmhouse> I've got base-2.1.1 with GHC 6.6.1.
11:10:56 <dukedave> Gah, do I really want to update it? :|
11:11:02 <dukedave> Is that the easiest way?
11:11:27 <dukedave> I only wonder because currently (6.6) I just did an apt-get on Ubuntu & it magically appeared
11:11:28 <dmhouse> GHC? Sure, should be. Just download a binary from the website.
11:11:38 <dmhouse> 6.6.1 is the latest stable version anyway.
11:13:21 <monochrom> 6.6 is still good enough.
11:13:34 <dmhouse> Does it have base >= 2.0?
11:13:51 <dukedave> The lambdabot build is complaining
11:14:05 <monochrom> I use ubuntu but I don't apt-get my haskell stuff. I take the "generic binary" from ghc's download page.
11:14:19 <dukedave> configure: Dependency base-any: using base-2.0
11:14:19 <dukedave> configure: Dependency unix-any: using unix-1.0
11:14:19 <dukedave> Setup.hs: cannot satisfy dependency network-any
11:14:25 <monochrom> ghc 6.6 is at base 2.0
11:14:38 <dmhouse> dukedave: ghc --version
11:14:46 <dukedave> Ah, hang on,
11:14:56 <dukedave> I'm just not parsing the error message properly am I  :)
11:14:58 <jberg> hmm i have a char x and case x of '+' -> blah '-' -> bleh etc. but when it's any character from a-z i want to do something with that, how can i do that? i dont want to write case x of 'a' 'b' 'c' etc..
11:15:00 <dmhouse> monochrom: same here. All my Haskell binaries (GHC, happy, alex, c2hs) are installed from source because the apt versions were ancient.
11:15:09 <hpaste>  byorgey annotated "off-by-one demonstraied in haskell" with "how about this?" at http://hpaste.org/365#a1
11:15:18 <dukedave> It's the network-any it can't find :)
11:15:25 <dmhouse> dukedave: install the network package :)
11:15:41 <monochrom> apt-get install libghc6-* :)
11:15:45 <vincenz> re
11:15:46 <lambdabot> vincenz: You have 1 new message. '/msg lambdabot @messages' to read it.
11:15:52 <vincenz> LeCamarade: pong
11:16:02 <byorgey> mdmkolbe|work: the code I pasted works... although I suppose it's debateable whether it's more elegant
11:16:02 <dukedave> sudo apt-get install libghc6-network-dev   :D
11:16:05 <dmhouse> jberg: if char >= 'a' && char <= 'b' then ... else ...
11:16:26 <dmhouse> jberg: the magic of polymorphic (>=) and (<=) :) Go type classes!
11:17:33 <jberg> hm yeah, just found isAlpha to, thanks
11:17:49 <LoganCapaldo> byorgey: I find it easier to read
11:18:02 <LoganCapaldo> but that's just my opinion :)
11:18:15 <mdmkolbe|work> byorgey: why do you need the expand's second case?
11:18:18 <LeCamarade> vincenz: I have been thinking ... don't you think the nature of functional programs (esp. pure) where they allocate like mad, offsets the benefits you may get by saying, say, `every function can (attempt to) run on its own core'?
11:18:53 <vincenz> LeCamarade: hmm, move to #oasis?
11:18:56 <byorgey> mdmkolbe|work: I suppose you don't, actually.
11:19:31 <byorgey> mdmkolbe|work: originally I was pattern-matching on Just x : y : _
11:19:40 <byorgey> but then I changed it
11:20:11 <mdmkolbe|work> LeCamarade: it's offset more by the fact that most (functional) programs have very tightly constrained dependancy graph that effectively makes them single threaded
11:20:11 <LoganCapaldo> while nitpicking, you don't really need list@ in the last case either :)
11:20:25 <byorgey> LoganCapaldo: good point.
11:20:29 <byorgey> also, I leave implementing expand using foldr as an exercise =)
11:21:16 <LeCamarade> mdmkolbe|work: Oh. I'm willing, though, to let my mind wander beyond when Haskell is still cutting-edge. :o)
11:21:21 <Phillemann> Could a fractional number be not zero although show outputs it as "0.0"?
11:22:43 <LoganCapaldo> > let show _ = "0.0" in show 4.5
11:22:45 <lambdabot>  "0.0"
11:22:50 <byorgey> lol
11:22:59 <hpaste>  mdmkolbe|work annotated "off-by-one demonstraied in haskell" with "better or worse?" at http://hpaste.org/365#a2
11:23:02 <Phillemann> Oh my got! :D
11:23:06 <Phillemann> -t+d
11:23:57 * shapr cheers for code!
11:23:58 <byorgey> mdmkolbe|work: nice, I like that =)
11:24:08 <dukedave> Hum, is "Setup.hs: cannot satisfy dependency zlib-any" likely to be referring to a Haskell specific zlib, or just any implementation of the system?
11:24:26 <LoganCapaldo> mdmkolbe|work: I vote for better
11:24:30 <monochrom> haskell-specific zlib
11:24:44 <monochrom> libghc6-zlib-dev ?
11:24:48 <sorear> @src num
11:24:49 <lambdabot> Source not found. I've seen penguins that can type better than that.
11:24:52 <sorear> @src Num
11:24:52 <lambdabot> class  (Eq a, Show a) => Num a  where
11:24:52 <lambdabot>     (+), (-), (*)           :: a -> a -> a
11:24:52 <lambdabot>     negate, abs, signum     :: a -> a
11:24:52 <lambdabot>     fromInteger             :: Integer -> a
11:25:03 <sorear> shapr: hi!
11:25:22 <sorear> shapr: ignore my last ping, I found it
11:25:22 <dukedave> Tragically not monochrom
11:25:24 <shapr> hiya sorear, what's up?
11:25:31 <sorear> @seen Lemmih
11:25:31 <lambdabot> Lemmih is in #haskell. I last heard Lemmih speak 7h 6m 43s ago.
11:25:39 <shapr> sorear: I didn't see the ping... ?
11:25:46 <sorear> @tell Lemmih your link for ghc-src is out of date
11:25:46 <lambdabot> Consider it noted.
11:26:04 <sorear> shapr: I was mentioning that scannedinavian.org/~lemmih is a dead link.
11:26:09 <fasta> Suppose I have a function f of type (MonadST s m, more context) =>  m (), when I do runST(f >> return ()), shouldn't this only make the constraints from f more specific and not introduce additional constraints?
11:26:21 <shapr> sorear: Oh right..
11:27:07 <fasta> When I substitute every m parameter in the type of f by (ST s) (while renaming everything as I should) I get constraints that were not in function f.
11:27:15 <fasta> AFAIK, that should never happen.
11:27:21 <hpaste>  LoganCapaldo annotated "off-by-one demonstraied in haskell" with "Shouldn't this be like this?" at http://hpaste.org/365#a3
11:27:21 <dmhouse> fasta: surely introducing additional constraints is making them more specific, in the sense that fewer types are valid.
11:28:01 <monochrom> dukedave: http://hackage.haskell.org/cgi-bin/hackage-scripts/package/zlib-0.3
11:28:04 <lambdabot> http://tinyurl.com/ypj2uf
11:28:16 <fasta> Can anyone confirm this?
11:28:28 <fasta> dmhouse: yes, but that doesn't answer the question.
11:29:11 <mdmkolbe|work> LeCamarade: ah, yes, ty
11:29:29 <fasta> dmhouse: the question is whether new constraints are added or just that the old ones are either deleted (because there is only one solution) or specialized for (ST s)
11:29:40 <byorgey> mdmkolbe|work: you mean LoganCapaldo? =)
11:30:09 <mdmkolbe|work> heh, yeah
11:30:21 <dukedave> Ah cool, I was just getting 0.2 from Duncan's site :o
11:30:30 <dmhouse> fasta: which new constraints would be added?
11:30:53 <mdmkolbe|work> both have a capitol L and C in there name and are relatively long
11:30:58 <dukedave> Okay, I'm install Cabal, that seems sensible right? :)
11:31:05 <LoganCapaldo> foiled by tab completion again! :)
11:31:46 <sorear> mdmkolbe|work: LoganCapaldo's name has no capitols in it :)
11:33:05 <dukedave> Damnit,
11:33:40 <dukedave> Trying to build Cabal... Getting 'setup: cannot satisfy dependency filepath-any', but ghc-pkg list reports 'FilePath-0.11'
11:33:46 <dukedave> Surely the same?
11:33:48 <byorgey> sorear: maybe it does. 'LoganCapaldo' is just an ASCII transliteration.
11:34:16 <monochrom> Your GHC already comes with Cabal...
11:34:35 <sorear> dukedave: Nope, not the same.
11:34:47 <dukedave> Okay, sorry about this guys,
11:34:55 <sorear> dukedave: they changed the names when they made it part of corelibs
11:35:33 <dukedave> But I should already have Cabal anyway?
11:35:39 <hpaste>  wellwisher pasted "Read Implementation" at http://hpaste.org/366
11:36:00 <wellwisher> ideas?
11:36:02 <monochrom> If zlib-0.3 wants a version of Cabal you don't have, perhaps try zlib-0.2 or old instead.
11:37:08 <monochrom> Or bite the bullet and just get ghc 6.6.1
11:37:16 <LoganCapaldo> @src Read
11:37:16 <lambdabot> class Read a where
11:37:16 <lambdabot>   readsPrec    :: Int -> ReadS a
11:37:16 <lambdabot>   readList     :: ReadS [a]
11:37:16 <lambdabot>   readPrec     :: ReadPrec a
11:37:16 <lambdabot>   readListPrec :: ReadPrec [a]
11:37:22 <LoganCapaldo> @ wellwisher
11:37:27 <wellwisher> ?
11:37:35 <LoganCapaldo> those are the functions you have to define
11:37:39 <wellwisher> i have seen that
11:38:09 <dukedave> Erm well I was trying to get Cabal because I guessed I'd need it to 'install' the (now extracted) zlib-0.3 tarball I just got
11:38:20 <byorgey> wellwisher: if I were you, just forget about Show and Read and make your own classes... call them, I don't know, Showable and Readable
11:38:42 <dukedave> The extracted tarball gives me:   Codec  Setup.hs  zlib.cabal
11:38:44 <monochrom> You already have Cabal. That is the only way "Setup.hs" has worked for you, ever.
11:38:52 <byorgey> then you could say class Readable a where read :: String -> a
11:38:56 <wellwisher>  it would esstially be the same
11:39:07 <byorgey> and then you could use exactly the code you have already written
11:39:16 <dukedave> Ah, so, heh, remind me how I've made Setup.hs 'work' before ;)
11:39:20 <byorgey> no, not the same, since Read is somewhat more complicated (as you can see above)
11:39:31 <monochrom> runghc Setup.hs configure
11:39:37 <wellwisher> ill look into it
11:40:58 <monochrom> It won't do for wellwisher to "instance Read Rarity where read ..."   read is not a method of Read.
11:41:57 <monochrom> Also the correct return value is not anywhere near a simple Rare.
11:43:29 <byorgey> monochrom: right, that's why I suggested making a custom class instead of using Read.
11:44:19 <dukedave> Argh, monochrom, thanks for the help so far.. Haven't been through the dependency war in a few months.. build is dying now :(
11:44:29 <monochrom> Hudak's book has a good tutorial on Read.
11:44:48 * byorgey wishes tutorials didn't introduce Show as if it were for pretty-printing things if it really isn't
11:45:24 <monochrom> dukedave: ghc 6.6.1 has fewer dependency problems (simply by being the current stable, so everyone has to support it)
11:47:05 <notsmack> byorgey: what is it for?
11:47:09 <monochrom> And of course I don't mean the compiler itself, I mean the core libs and extra libs bundled with it, so you install nothing yourself.
11:47:14 <dukedave> Horrible page of errors from the zlib-0.3 build, am trying 0.2
11:47:31 <byorgey> notsmack: apparently, for serialization/debugging
11:47:56 <dukedave> Grumble, same with 0.2
11:47:58 <byorgey> notsmack: and you should always have  read . show == id
11:48:15 <byorgey> notsmack: I just learned this today =)
11:48:39 <byorgey> notsmack: easiest way to have read.show == id, of course, is to let the compiler derive both for you
11:49:55 <hpaste>  dukedave pasted "zlib-0.3 death" at http://hpaste.org/367
11:50:50 <sorear> dukedave: you need to install zlib
11:51:10 <sorear> dukedave: the C library with a confusingly identical name :)
11:51:16 <monochrom> OH!
11:51:24 <sorear> you probably just need the header files
11:51:42 <sorear> since zlib itself is pretty deep in the deps of most *nix installs
11:52:04 <monochrom> apt-get install zlib1g-dev
11:52:04 <dukedave> So something like /usr/src/linux-headers-2.6.20-15/include/linux/zlib.h   :
11:52:07 <dukedave> :)
11:52:28 <dukedave> Ah monochrom, am getting
11:52:49 <monochrom> Not just header file. Also the libzlib.a file because ghc will statically link.
11:53:01 <monochrom> In short, zlib1g-dev still
11:53:03 <sorear> monochrom: ghc only statically links haskell libs
11:53:14 <dukedave> Pft, and they say Linux isn't user friendly ;)
11:53:16 <monochrom> OH! Then need the .so
11:53:22 <dukedave> Thanks again, got build :)
11:53:26 <monochrom> still, zlib1g-dev :)
11:53:55 <hpaste>  LoganCapaldo annotated "Read Implementation" with "(no title)" at http://hpaste.org/366#a1
11:53:59 <byorgey> dukedave: what are you trying to build? lambdabot?
11:54:32 <monochrom> Several linux distros are user friendly.
11:55:07 <sorear> trying to build lambdabot is not usually a good idea.  it's big, has lots of dependencies, and was written *entirely* without any expectation that people would want to build it.
11:55:24 <monochrom> Haha
11:55:25 <LoganCapaldo> avast
11:55:42 <LoganCapaldo> But how will I ever get a lambdabot of my very own?
11:56:38 <monochrom> download "generic binary for linux" or "cab file for windows"...
11:57:03 <byorgey> @arr
11:57:03 <lambdabot> Aye Aye Cap'n
11:57:34 <dukedave> Unfortunately I've been resolving deps so long I'm in that "well I might as well get it to build now" stage :)
11:57:53 <byorgey> LoganCapaldo: if you just believe deep in your heart that someday you can have a lambdabot of your own
11:58:07 <weitzman> If there's anything I've learned from trying to make things work on linux, it's that you're never "sooo close"
11:58:17 <weitzman> You can be so close for years
11:58:42 <LeCamarade> weitzman: Truth.
11:58:51 <fasta> weitzman: Is there any OS where things work magically?
11:58:53 <LoganCapaldo> monochrom: if that was directed at me, I'd like to point out I'm running OS X PPC and AMD64 linux :)
11:58:55 <byorgey> @remember sorear trying to build lambdabot is not usually a good idea.  it's big, has lots of dependencies, and was written *entirely* without any expectation that people would want to build it.
11:58:56 <lambdabot> Done.
11:58:56 <weitzman> And on windows you have to download the dependencies independently, so I never even try to compile things
11:59:44 <weitzman> fasta: Inferno?
12:00:00 <dukedave> weitzman: I know the feeling :|
12:00:01 <byorgey> fasta: I'm actually writing a MagicOS.  I'm soooo close to being done.  If I can just get this one thing to build...
12:00:55 <Mayreel> Random question: should the main function go at the top or bottom of the file?
12:01:20 <weitzman> Mayreel: Which one do you prefer?
12:01:48 <Mayreel> I was just wondering if there was a standard style thing.
12:02:07 <monochrom> It should go at 3/4th from the top.
12:03:06 <byorgey> Mayreel: I think the answer is "no". =)
12:03:25 <Mayreel> I figured
12:03:32 <LeCamarade> Mayreel: Mu.
12:03:36 <LoganCapaldo> IME the main function ends up in teh center of the file
12:03:37 <byorgey> Mayreel: Haskell doesn't care about the order of declarations, so just use whatever is clearest to a human reading the file.
12:03:41 <sorear> Mayreel: Haskell completely does not care where you put values within a letrec :)
12:03:46 <weitzman> If you're doing literate haskell, you would arrange it in whichever way is easiest to explain
12:03:47 <LoganCapaldo> this is because I write it first
12:03:51 <Baughn> Mayreel: Use a proper IDE, and it doesn't matter for readability either
12:04:07 <LoganCapaldo> and then the placement of the other functions above or below it ends up being arbitrary :)
12:04:23 <byorgey> LoganCapaldo: development by accretion?
12:04:29 <LoganCapaldo> exactly
12:04:50 <Baughn> Mayreel: Put another way, do you use let..in or with?
12:04:50 <monochrom> Can programming be liberated from the Plain Text File?
12:05:00 <LoganCapaldo> i hope so
12:05:05 <Baughn> I hope not
12:05:14 <fasta> monochrom: it is already in some environments, but you know that too
12:05:46 <Mayreel> Baughn: what's "with"? Is it like "where"?
12:05:51 <monochrom> It rhymes with Backus's "from the von Neumann style" :)
12:05:53 <byorgey> DrScheme has an "extended" mode for saving Scheme files with all kinds of extra goodies in it... most annoying thing ever
12:06:00 <Baughn>  > x + x with x = 2
12:06:09 <Baughn> > x + x with x = 2
12:06:10 <lambdabot>  Parse error
12:06:12 <byorgey> Mayreel: I think Baughn meant "where"
12:06:17 <Mayreel> oh, ok
12:06:20 <Baughn> So I did.
12:06:48 <Baughn> I tend to prefer let..in myself, as you may have guessed. My main also ends up at the bottom of the file. :P
12:06:53 <byorgey> monochrom: so it does.  I caught the reference but not the rhyme. =)
12:07:10 <fasta> byorgey: it's not annoying if you know how to get access to the blobs in other ways
12:07:41 <Baughn> fasta: Anything that prevents me from editing with emacs is impossible to accept
12:07:49 <byorgey> fasta: well, I don't.  it's some sort of binary format.
12:07:59 <fasta> Baughn: you are assuming that those blobs will never be displayable in Emacs.
12:08:04 <byorgey> fasta: so if I'm on a computer without DrScheme...
12:08:19 <byorgey> fasta: this is from when I was teaching high school CS
12:08:24 <Baughn> fasta: No, I'm assuming that they're currently imposible to edit with emacs
12:08:48 <shapr> yarr!
12:09:08 <Baughn> @yarr, you mean
12:09:08 * byorgey is startled
12:09:08 <lambdabot> Yo ho ho, and a bottle of rum!
12:09:18 <Mayreel> psh. hexl-find-file!
12:09:43 <weitzman> Are there actually any structural editors out there?
12:09:50 <monochrom> MathSPad
12:09:57 <weitzman> The LEGO mindstorm language is visual
12:10:00 <monochrom> I use it to write my thesis.
12:10:10 <Baughn> weitzman: Depending on how you define it, emacs w/slime comes close
12:10:45 <byorgey> monochrom: for a moment there I thought you used LEGO mindstorm language to write your thesis, and about died
12:11:01 <Baughn> weitzman: You know, I've never actually met anyone who doesn't bypass that and write assembly or forth instead
12:11:01 <weitzman> I know a grad student who has an interesting editor http://www.cs.cmu.edu/~marmalade/barista.html
12:11:02 <lambdabot> Title: Natural Programming
12:11:09 <monochrom> Curiosity kills the cat. Satisfaction brings it back!
12:11:16 * dukedave is still going strong :)
12:11:29 <sorear> @remember byorgey monochrom: for a moment there I thought you used LEGO mindstorm language to write your thesis, and about died
12:11:30 <lambdabot> Done.
12:11:35 <sorear> hmm, feature idea
12:11:51 <byorgey> when I was 12 I saved up to get a LEGO mindstorm set... I was so excited
12:11:53 <monochrom> I want write Haskell for Lego Mindstorm.
12:12:02 <dukedave> monochrom: That would be nice :)
12:12:03 <shapr> monochrom: Can't you already do that?
12:12:06 <byorgey> then I got it and tried using the visual language and gave up in disgust
12:12:27 <sorear> @tell dons feature idea: give @remember ad-hoc support for parsing and DTRT-with-ing lines like "12:09 < byorgey> monochrom: for a moment there I thought you used LEGO mindstorm language to write your thesis, and about died"
12:12:27 <lambdabot> Consider it noted.
12:12:47 <shapr> I think Dan Piponi compiled from Haskell to mindstorms using the stuff from the latest TMR.
12:13:03 <Baughn> weitzman: Given it the nominal three seconds of brain time, it's using pretty pictures to describe a function that (a) is specifically well suited to be described this way, and (b) is simple enough not to need it. Also, it's doing the usual OO namespace-class/object confusion. :/
12:13:37 <vincenz> sorear: you're a strong typehacker?
12:13:50 <sorear> vincenz: slightly
12:14:16 <vincenz> sorear: any chance you saw my post?
12:14:16 <weitzman> Baughn: The editor I linked to has such features as not letting you enter code which is syntactically invalid, which from an HCI standpoint is very helpful to new programmers
12:14:17 * vincenz is stuck
12:14:27 <sorear> vincenz: yes
12:14:59 <Baughn> weitzman: That's a valid school of thought, but I've always been far more interested in helping experienced programmers
12:15:20 <weitzman> Baughn: I believe structured editing could help experienced programmers as well
12:15:45 <weitzman> balodja: For example, the computer could always know exactly what I've changed without a dumb text-based version control tying to piece it together
12:15:56 <weitzman> s/balodja/Baughn/
12:16:08 <shapr> monochrom: There's also Alexis Morris' MSc project running Yampa on YHC on the Mindstorms
12:16:16 <Baughn> weitzman: There were some interesting tricks there, such as changing font size per-block, that I'm going to import into emacs
12:16:58 <Baughn> weitzman: I agree with /that/. You should never be checking in code that doesn't work right, much less syntactically invalid code, so that's a win.
12:17:07 <weitzman> Baughn: I also think visual display of logic functions could be easier to read even for advanced programmers
12:17:25 <shapr> weitzman: Have you seen Wouter van Oortmerssen's languages at strlen.com ?
12:17:28 <dukedave> I was particularly impressed with this:  http://www.ni.com/labview/
12:17:29 <lambdabot> Title: LabVIEW - The Software That Powers Virtual Instrumentation - Products and Servic ...
12:17:50 <weitzman> shapr: Nope
12:18:10 <Baughn> weitzman: Prettyprinting math is fine, but I rarely deal with code that has a lot of math. Other than that, I'm not sure what you mean.
12:18:23 <shapr> Structured editing has problems when you want to go through illegal states to reach another legal state.
12:18:40 <weitzman> Baughn: I mean "if a & b then c else (if d then e else f)"
12:18:50 <weitzman> Baughn: Things of that nature
12:19:03 <weitzman> Baughn: With OR and AND and IF
12:19:06 <Baughn> weitzman: (if (and a b) c (if d e f))
12:19:14 <shapr> I think incremental parsing would help newbies more than structured editors alone.
12:19:41 <Baughn> weitzman: That sort of thing is why I prefer lisp-style syntax to haskell-style. It works far better for complex structures
12:19:51 <wellwisher> 1 instance Read String where
12:19:51 <wellwisher> 2  read "R" :: Rarity = Rare
12:19:51 <wellwisher> 3  read "U" :: Rarity = Uncommon
12:19:51 <wellwisher> 4  read "C" :: Rarity = Common
12:20:08 <shapr> Baughn: You can use Lisp-style syntax in Haskell.
12:20:08 <wellwisher> what is the correct type for #1?
12:20:09 <weitzman> Baughn: The ifs work well in lisp or haskell, but combinations of OR and AND take a moment to grok
12:20:18 <monochrom> Baughn, weitzman: Suppose I am to completely rewrite the interal or external doc for Control.Monad. I would really love to include a few commuting diagrams. Yes, even as internal comments. Suppose I write some code that uses arrows. I would love to include a dataflow diagram. Even better, the dataflow diagram is the code. This is what Barista is for.
12:20:27 <Baughn> shapr: Not to the degree you can do so in lisp, no
12:21:05 <shapr> Yeah, that's true for cases like (if d e f)
12:21:15 <Baughn> monochrom: Use literal haskell, put svg (or something) in the documentation text?
12:21:16 <dmhouse> Baughn: you could write that as (if' ((&&) a b) c (if' d e f)) given if' p x y = if p then x else y
12:21:56 <Baughn> dmhouse: Granted. That's certainly better than the original version, and shows off the flexibility of lazy evaluation. :)
12:21:57 <shapr> I think you may be able to write a polyvariadic args version too, if you like that.
12:22:00 <byorgey> wellwisher: I don't think that will work.
12:22:13 <wellwisher> why not?
12:22:24 <byorgey> wellwisher: why are you so set on using Read instead of making your own class?
12:22:42 <LoganCapaldo> wellwisher: did you see my annotation?
12:22:44 <weitzman> Baughn: But what's to be gained by separating the program code from the helpful images in your editor?
12:22:58 <weitzman> Baughn: It could still be stored on disk as literate haskell, even
12:23:11 <shapr> weitzman: Plain text is a lot easier to munge than binary structures.
12:23:30 <Baughn> weitzman: If you do that, then nothing. Emacs would certainly be able to parse literal haskell usefully.
12:23:55 <monochrom> Yeah, on the disk it can be svg or whatever. The editor should display my commuting diagram and also let me modify the diagram as a diagram (not as svg text editing).
12:24:00 <shapr> wellwisher: Are you writing an MtG library organizer?
12:24:01 <Baughn> weitzman: I've been wanting a /good/, slime-like emacs mode for haskell. Go ahead and try it. ;)
12:24:18 <byorgey> wellwisher: Read is sort of complicated.  The read function isn't even part of the Read class.
12:24:37 <hpaste>  dmhouse pasted "Layouts for nested ifs" at http://hpaste.org/368
12:24:54 <dmhouse> Baughn: ^^ any of those I find perfectly acceptable.
12:25:11 <wellwisher> what class?
12:25:21 <monochrom> "acceptable" is weak. I prefer a decision tree.
12:25:28 <dmhouse> Baughn: haskell-mode is improving. It will be SLIME-like one day :)
12:25:32 <Baughn> dmhouse: The last one is.. yucky.
12:25:45 <monochrom> Even Java is "acceptable".
12:25:46 <dmhouse> Baughn: it's hacky, but it's the prettiest.
12:25:47 <LoganCapaldo> wellwisher: http://hpaste.org/366#a1
12:25:50 <byorgey> wellwisher: sorry, I'm not sure what your question is
12:26:34 <dmhouse> Baughn: with http://hackage.haskell.org/trac/haskell-prime/wiki/MultiWayIf in haskell-prime this kind of corner case will be easy to do.
12:26:35 <lambdabot> Title: MultiWayIf - Haskell Prime - Trac
12:26:46 <dmhouse> Baughn: I find nested ifs come up fairly infrequently anyway.
12:27:16 <Serge> > 3
12:27:17 <hpaste>  Baughn annotated "Layouts for nested ifs" with "Less hacky version" at http://hpaste.org/368#a1
12:27:17 <lambdabot>  3
12:27:21 <shapr> Six years of #haskell!
12:27:56 <Baughn> dmhouse: *clicks link*.... oh.
12:28:13 <monochrom> Anyway it's an uphill battle. When can programming be liberated from the Plain Text File? We're fighting it against the self-selecting group that liked plain text files in the first place.
12:28:19 <SpoilSport> Hello friends, I have a simple Haskell query?
12:28:26 <dmhouse> Baughn: yes, that'd also be nice to have.
12:28:52 <Baughn> dmhouse: Happily, that one is a very short function
12:29:00 <byorgey> SpoilSport: well, you've come to the right place =)
12:29:04 <Saizan> dmhouse: doesn't the last version lack an "of" and a pattern?
12:29:04 <heanol> > 1 + 1
12:29:05 <lambdabot>  2
12:29:08 <SpoilSport> how would I make my maxList function generic so as it would work with floats, doubles, integers and all numeric type
12:29:11 <Serge> > 0/0
12:29:13 <lambdabot>  NaN
12:29:16 <Serge> > 1/0
12:29:18 <lambdabot>  Infinity
12:29:20 <Serge> > -1/0
12:29:22 <lambdabot>  -Infinity
12:29:25 <hpaste>  LoganCapaldo annotated "Layouts for nested ifs" with "minor variation on case" at http://hpaste.org/368#a2
12:29:28 <ari> @src maximum
12:29:28 <lambdabot> maximum [] = undefined
12:29:28 <lambdabot> maximum xs = foldl1 max xs
12:29:32 <ari> SpoilSport: By reading that
12:29:34 <ari> ;)
12:29:39 <Baughn> SpoilSport: Have you gotten to typeclasses in your tutorial yet?
12:29:41 <monochrom> maxList? You can make it so generic it works for all Ord types.
12:29:42 <SpoilSport> maxList lst = foldl (max) 0 lst
12:29:45 <weitzman> monochrom: An interesting theory I've heard is that unix came along and made administration almost synonymous with text processing
12:30:08 <weitzman> monochrom: It worked really well, but it made vim, grep, sed, awk, and piping things around into the finest tools for getting stuff done
12:30:11 <byorgey> SpoilSport: that already is generic.  unless I'm missing something?
12:30:17 <dmhouse> Saizan: yes, sorry. It should be case () of _ | ...
12:30:21 <SpoilSport> no I don't know what typeclasses are, I know only numeric types in Haskell
12:30:23 <Baughn> :t foldl (max) 0
12:30:25 <lambdabot> forall a. (Ord a, Num a) => [a] -> a
12:30:31 <Baughn> Yep, looks generic.
12:30:38 <dmhouse> ?type maximum
12:30:40 <lambdabot> forall a. (Ord a) => [a] -> a
12:30:44 <Serge> SpoilSport: Give it a polymorphic type
12:30:47 <SpoilSport> no I want to perform type check so it works only for numeci types
12:30:54 <SpoilSport> Int, Float, Double only
12:30:56 <Serge> Oh.
12:31:03 <byorgey> SpoilSport: ok, then give it a type like (Num a) => [a] -> a
12:31:10 <Baughn> SpoilSport: Haskell does that automatically anyway. You adding one is (mostly) for documentation and clarity.
12:31:14 <Philippa> monochrom: that's more or less a finished battle, XML&relatives've won
12:31:15 <SpoilSport> no characters and other custom datatypes
12:31:31 <byorgey> (Num a) => means "whenever a is a type in the class Num"...
12:31:37 <Baughn> SpoilSport: Also, the correct type in this case involves typeclasses, so.. wait until you read that chapter. ;)
12:31:40 <SpoilSport> maxList :: [Integer] -> Integer doesn't work
12:31:48 <monochrom> Philippa: Not yet, programmers still insist that XML is for data but not program.
12:31:50 <Serge> ?instances Num
12:31:51 <lambdabot> Double, Float, Int, Integer
12:31:59 <SpoilSport> ah
12:32:00 <byorgey> SpoilSport: see what I wrote above
12:32:38 <Baughn> SpoilSport: If you're used to Java, think of Num a => a as meaning "some type a that implements the interface Num". That's incorrect, but it's good enough in this case.
12:32:42 <monochrom> OK, some inroads have begun. Some build files (e.g. Ant) are in XML.
12:32:48 <SpoilSport> so how would I change my method definition to reflect tha (Num a), I do maxList :: [Num] -> Integer but it gives error
12:33:02 <byorgey> SpoilSport: maxList :: (Num a) => [a] -> a
12:33:17 <ari> byorgey: Num isn't in Ord, I think
12:33:31 <byorgey> ari: hm... good point
12:33:34 <SpoilSport> oh so Num doesn't work like Integer because its a class of types, is it?
12:33:37 <dmhouse> Num isn't a type.
12:33:40 <monochrom> OH!  Complex is Num but not Ord.
12:33:44 <Serge> ?instances Ord
12:33:44 <byorgey> maxList :: (Num a, Ord a) => [a] -> a
12:33:46 <Baughn> SpoilSport: Correct
12:33:46 <dmhouse> SpoilSport: correct.
12:33:46 <lambdabot> (), All, Any, Bool, Char, Double, Either a b, Float, Int, Integer, Maybe a, Ordering, Product a, Sum a, [a]
12:33:59 <dmhouse> SpoilSport: typeclasses are essentially sets of types.
12:34:06 <SpoilSport> Thank you for this confirmation friends
12:34:17 <Baughn> SpoilSport: Sets that can be extended by your own code, which is handy
12:34:21 <byorgey> > maximum ['a','b','c']
12:34:23 <lambdabot>  'c'
12:34:30 <Baughn> SpoilSport: Yes, you can instance Num and define your own numeric type.
12:34:37 <byorgey> > (maximum :: (Ord a, Num a) => [a] -> a) ['a','b','c']
12:34:38 <lambdabot>   add an instance declaration for (Num Char)
12:34:38 <lambdabot>     In the expression:
12:34:38 <lambdabot>         (...
12:34:40 <SpoilSport> but not every data has max and min defined
12:34:47 <Baughn> :t ord
12:34:49 <lambdabot> Char -> Int
12:34:49 <Baughn> :t max
12:34:51 <lambdabot> forall a. (Ord a) => a -> a -> a
12:35:02 <SpoilSport> for eg a class holding image data
12:35:09 <Baughn> SpoilSport: Right. As you can see from the last line, only those types that are in the Ord class have max defined.
12:35:44 <SpoilSport> so if I create my own data type and I want it to be under the Ord class, what should I do?
12:35:53 <SpoilSport> suppose the new data is node of a tree
12:35:57 <Japsu> SpoilSport: define an instance of Ord for it
12:35:59 <Japsu> @src Ord
12:35:59 <lambdabot> class  (Eq a) => Ord a  where
12:35:59 <lambdabot>     compare      :: a -> a -> Ordering
12:35:59 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
12:35:59 <lambdabot>     max, min         :: a -> a -> a
12:36:17 <Japsu> you need to implement those functions
12:36:29 <byorgey> actually, for Ord, you only need to implement e.g. <=
12:36:39 <byorgey> all the rest will get default implementations based on it
12:36:50 <SpoilSport> Ah, so implementing most of the standard functions defined in Prelude is it?
12:36:56 <byorgey> so you could say instance Ord MyType where a <= b = ...
12:37:36 <byorgey> SpoilSport: I don't understand your question
12:37:58 <SpoilSport> so when I extend the Ord class, do I need to overload most of the functions from Prelude.hs
12:38:07 <Baughn> SpoilSport: No, just <=
12:38:08 <byorgey> no
12:38:23 <SpoilSport> and the others will be deduced from this?
12:38:29 <byorgey> any functions from the Prelude that rely on Ord will automatically use your new definitions!
12:38:37 <Baughn> SpoilSport: Ye
12:38:38 <Baughn> p
12:38:56 <byorgey> so once you have made your type an instance of Ord, you could e.g. use the function max on values of your type
12:38:56 <Baughn> SpoilSport: Typically, your first instances will be Num [a] and Ord [a]
12:40:20 <Serge> Can't you just have your type derive Ord?
12:40:24 <SpoilSport> <byorgey> all the rest will get default implementations based on it
12:40:27 <SpoilSport> oh I get it
12:40:55 <byorgey> SpoilSport: in that case, I meant >=, <, > and so on will get implementations based on <=
12:41:13 <byorgey> SpoilSport: i.e. all the other functions in the Ord class
12:41:47 <byorgey> Serge: you can as long as none of your data constructors take any arguments, I think
12:42:07 <byorgey> Serge: otherwise it is not obvious what the derived implementation should be
12:42:11 <Serge> Ye
12:43:07 <SpoilSport> Does haskell run on the C runtime?
12:43:37 <Baughn> SpoilSport: Sure, just like absolutely everything else out there
12:43:46 <ari> Baughn: Did you mean that the first implementation that you're likely to write is Num [a]? Because I sure would like to see one ;)
12:44:05 <Baughn> ari: Peano arithmetic? I think I've got it somewhere..
12:44:20 <SpoilSport> But I though functional langauges were expressive enough to write themselves?
12:44:31 <Baughn> SpoilSport: Sure, but you asked about the /runtime/
12:44:32 <SpoilSport> I mean implement the lang is the lang itself
12:44:36 <LoganCapaldo> GHC is written in Haskell
12:44:55 <Philippa> SpoilSport: I think you're mostly thinking of lisp
12:45:07 <Baughn> SpoilSport: GHC is written in haskell. GHC-compiled programs (including ghc itself) use the C runtime to do things like.. everything.
12:45:24 <SpoilSport> oh
12:45:24 <Philippa> which isn't to say you can't implement haskell in haskell, but even lisps have something non-lisp involved somewhere when you run them on actual hardware
12:45:27 <Baughn> Philippa: No, even lisp doesn't do direct kernel calls via assembly and supply their own crt0.s file
12:45:38 <LoganCapaldo> would you rahter ghc had to know the syscalls for all the oses it ran on? :)
12:45:44 <Vulpyne> There's a bootable OS written in Haskell though, isn't there?
12:45:51 <Baughn> Several. :P
12:46:00 <shapr> Vulpyne: Yeah, House is awesome.
12:46:09 <shapr> The tcp/ip stack from House is lots of fun to play with.
12:46:15 <SpoilSport> how do functional languages survive when everything is recursive, so many stack frames would be formed
12:46:19 <Vulpyne> shapr: I actually am using it in a project at the moment.
12:46:30 <Baughn> SpoilSport: Tail recursion?
12:46:31 <shapr> Vulpyne: The os or the stack?
12:46:39 <Vulpyne> shapr: The packet parsing stuff from it.
12:46:51 <SpoilSport> Baughn: In which the recursion is the last call?
12:46:51 <shapr> Vulpyne: I'm doing something similar, have you extended the stack any?
12:46:54 <Baughn> SpoilSport: As for haskell, that doesn't apply. Lazy evaluation makes memory usage.. hard to predict, though generally smaller.
12:46:58 <Baughn> SpoilSport: Yes
12:47:00 <ari> I remember reading about a Lisp which implemented its own runtime in itself... the garbage collector was written carefully ensuring that it would never heap-allocate
12:47:08 <Vulpyne> shapr: I'm just using it to get the contents of sniffed TCP and UDP packets, so no.
12:47:13 <LoganCapaldo> tail calls period even :)
12:47:15 <heanol> can i map a list of ints into a list of pairs with ints? meaning something like: "map (...) [1,2,3]" to [(1,1),(2,2),(3,3)]?
12:47:20 <SpoilSport> but still there is a recursive call. It just delays the call
12:47:29 <LoganCapaldo> heanol: sure
12:47:30 <Baughn> @djinn a -> (a,a)
12:47:30 <lambdabot> f a = (a, a)
12:47:37 <dmhouse> > map (\x -> (x, x)) [1..3]
12:47:39 <lambdabot>  [(1,1),(2,2),(3,3)]
12:47:46 <Baughn> @. pl djinn a -> (a,a)
12:47:46 <lambdabot> f = join (,)
12:47:47 <ari> > map (join (,)) [1,2,3]
12:47:48 <dmhouse> heanol: if in doubt, write a small lambda :)
12:47:48 <lambdabot>  [(1,1),(2,2),(3,3)]
12:47:51 <heanol> ah, awesome
12:47:52 <Vulpyne> shapr: It was pretty hard to figure out as my first Haskell project. :)
12:47:54 <ddarius> http://lambda-the-ultimate.org/node/472#comment-3571
12:47:55 <lambdabot> Title: Ian Bicking: The challenge of metaprogramming | Lambda the Ultimate
12:47:59 <Baughn> > map (join (,)) [1,2,3]
12:48:01 <lambdabot>  [(1,1),(2,2),(3,3)]
12:48:04 <shapr> Vulpyne: I was thinking of setting a darcs repo for the stack if I ever found anyone else hacking on it.
12:48:08 <shapr> Vulpyne: Yeah, it's a little weird...
12:48:12 <ddarius> SpoilSport: That link re stack overflow
12:48:15 <heanol> dmhouse, i'm not really sure what a lambda is yet, but my impression is that it's a function?
12:48:27 <SpoilSport> yes reading it currently, thanks my friend
12:48:37 <Vulpyne> shapr: My first use of it was incredibly horrible.
12:48:41 <shapr> Vulpyne: I had some QC tests for the stack, not sure if I still have them. The stack had some parsing problems in its first incarnations.
12:48:43 <Vulpyne> But it kind of worked. Some of the time.
12:48:44 <Baughn> SpoilSport: In tail recursion, the program will discard/gc the last stack frame when recursing into the new one, since it is no longer needed
12:48:46 <dmhouse> heanol: exactly. Try Functions
12:48:51 <shapr> Vulpyne: Any working at all is nifty and fun :-)
12:48:53 <dmhouse> Err, try http://en.wikibooks.org/wiki/Haskell/More_on_functions#Anonymous_Functions
12:48:55 <lambdabot> http://tinyurl.com/yxvt8f
12:48:56 <LoganCapaldo> heanol: yeah without a name. the things that look like (\x -> x + 1)
12:48:57 <LeCamarade> heanol: Anonymous function, generally made to be used once and thrown away. Like a bomb.
12:49:09 <Baughn> heanol: It's a greek letter. Anything beyond that depends on context.
12:49:11 <heanol> lambdas are the bomb! got it!
12:49:14 <heanol> ;)
12:49:16 <LeCamarade> heanol: Watch:
12:49:16 <Serge> > zip [1..3] [1..3]
12:49:18 <lambdabot>  [(1,1),(2,2),(3,3)]
12:49:29 <dmhouse> heanol: basically let f x = (x, x) in map f [1..3] is exactly the same as map (\x -> (x, x)) [1..3]
12:49:31 <Vulpyne> shapr: :)
12:49:42 <LeCamarade> > (\x -> x * 2) 4 -- Multiply by two and forget you existed ever.
12:49:45 <lambdabot>  8
12:49:50 <Baughn> heanol: Which is the same as map (join (,)) [1..3], mind you
12:49:52 <heanol> dmhouse, aha, i understand now
12:49:57 <Vulpyne> I'm really enjoying using Haskell.
12:50:01 <heanol> me too
12:50:02 <ari> > join zip [1,2,3]
12:50:04 <lambdabot>  [(1,1),(2,2),(3,3)]
12:50:09 <heanol> really helpful people here too :)
12:50:15 * ari loev join
12:50:35 <Vulpyne> heanol: Agree.
12:50:48 <Baughn> @. pl djinn [a] -> [(a,a)]
12:50:48 <lambdabot> (line 1, column 1):
12:50:48 <lambdabot> unexpected "-"
12:50:48 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
12:50:56 <Serge> @src join
12:50:56 <lambdabot> join x =  x >>= id
12:50:58 <Baughn> ..sad.
12:51:04 <Serge> That is neat =o
12:51:20 <LoganCapaldo> doesn't djinn not do lists? I thought someone told me that?
12:51:23 <dmhouse> Serge: it's actually a function for dealing with monads, but one definition is join x = \z -> x z z.
12:51:34 <Serge> dmhouse: I see
12:51:36 <Baughn> Any time monad operations come up in non-monadic code, I run screaming
12:51:37 <LoganCapaldo> @djinn [a] -> [(a,a)]
12:51:37 <lambdabot> -- f cannot be realized.
12:52:02 <dmhouse> Baughn: yeah, often it's people being 'clever' with the ((->) a) monad, and just managing to obfuscate their code.
12:52:18 <dmhouse> join's fairly well used here, but I tend to think it's clearer to just write the argument twice :)
12:52:29 <heanol> :t Num
12:52:31 <lambdabot> Not in scope: data constructor `Num'
12:52:34 <dmhouse> Or in the case of, say, join (,), a small lambda is much clearer and still pretty concise.
12:52:41 <heanol> What's the difference between Num and Int?
12:52:42 <dmhouse> heanol: Num is the set of types which are numeric.
12:52:55 <heanol> meaning.. Int and Float?
12:52:57 <Serge> ?instances Num
12:52:57 <heanol> for example
12:52:58 <lambdabot> Double, Float, Int, Integer
12:52:58 <LoganCapaldo> of which Int is a member
12:52:59 <dmhouse> heanol: so Num contains Int, along with Double, Float and so on.
12:53:03 <Baughn> heanol: Int is a particular type, which is numeric
12:53:06 <heanol> I see
12:53:25 <dmhouse> heanol: so Num is not a type, but rather a type _class_. You'll learn about them at some point in your tutorial. :)
12:53:27 <Baughn> heanol: You can define your own numeric types. If you do, things like + will automatically work on it.
12:53:44 <Baughn> Well, it'll work because you defined it, but still
12:53:50 <heanol> dmhouse, yeah i've put the Types-chapter on hold until i grasp the other stuff
12:54:11 <Baughn> heanol: Once you get there, be sure to implement peano arithmetic. It's neat. Lazy math. ;)
12:54:22 <monochrom> @src foldr
12:54:22 <lambdabot> foldr k z xs = go xs
12:54:22 <lambdabot>     where go []     = z
12:54:22 <lambdabot>           go (y:ys) = y `k` go ys
12:54:34 <Baughn> Makes things like "length [1..] > 50" evaluate to True
12:55:09 <heanol> haha, that sounds.. Interesting
12:55:35 <vincenz> for those very new to haskell, this article might be interesting: http://notvincenz.blogspot.com/2007/06/simplistic-compiler-in-haskell.html
12:55:36 <lambdabot> Title: lambda.oasis: Simplistic compiler in Haskell, http://tinyurl.com/yvtgys
12:55:41 <dmhouse> Baughn: the best thing is that you can define infinity = Succ infinity, with the property that infinity > everything :)
12:55:56 <LoganCapaldo> Baughn: well you'd have to use genericLength and throw in some type anottations wouldn't you?
12:56:18 <Serge> > zipWith (.) [negate, recip] [recip, negate]
12:56:20 <lambdabot>  [<Double -> Double>,<Double -> Double>]
12:56:26 <Baughn> LoganCapaldo: Also a fromIntegral, but don't disturb the beautiful image, please
12:56:35 <LoganCapaldo> Baughn: sorry :)
12:56:52 <ddarius> Baughn: The fromIntegral is free
12:57:07 <Baughn> ddarius: Right, forgot the type of 50
12:57:56 <DRMacIver> Hm
12:58:06 <DRMacIver> Why isn't if a function?
12:58:21 <dmhouse> Because we like to making things non-first-class arbitrarily.
12:58:26 <dmhouse> It keeps the punters guessing.
12:58:30 <Baughn> The developers were drunk at the time
12:58:46 <DRMacIver> I was afraid of that.
12:58:48 <dmhouse> So we can type 'then' in our code. How pretty!
12:59:09 * Limbic_Region prepares to be admonished but asks anyway:  Does anyone know where one might obtain a good tutorial on SML that is geared towards extreme beginners but is also free?
12:59:28 <Baughn> In #sml or #ml?
12:59:30 <monochrom> why SML and not Haskell? :)
12:59:33 <vincenz> Limbic_Region: must it be sml? or can it be ocaml
12:59:36 <DRMacIver> What, a language which is not Haskell? How *dare* you??
12:59:40 <vincenz> Limbic_Region: if ocaml, the free o'reilly book is quite good
12:59:45 <Limbic_Region> monochrom - as I said, I was prepared for admonisment
12:59:47 <LoganCapaldo> data Then = Then; then = Then; if :: Bool -> Then -> a -> Else -> a -> a
12:59:52 <Limbic_Region> actually, I am trying to learn Alice
12:59:54 <dmhouse> There are _other_ languages?
12:59:56 <Limbic_Region> which is based on SML
12:59:58 <monochrom> How about the wikibook for haskell? After learning haskell, SML is easy. :)
13:00:00 <vincenz> Limbic_Region: well ocaml is similar
13:00:03 <Limbic_Region> but they do not have any introductory docs
13:00:05 <Baughn> LoganCapaldo: *wince*
13:00:06 <vincenz> Limbic_Region: check the o'reilly book on the ocaml website
13:00:10 <dmhouse> But those are all just DSLs written in Haskell, right?
13:00:25 <LoganCapaldo> Baughn: you know its a good compromise when it makes no one happy :)
13:00:26 <Limbic_Region> vincenz - thanks
13:00:32 <monochrom> I learned SML from Lawrence Paulson's book "ML for the working programmer".
13:00:42 <Limbic_Region> actually, thanks to all
13:00:49 <DRMacIver> I second the recommendation for larry's book.
13:00:53 * Limbic_Region speaks very infantile Haskell btw
13:01:09 <monochrom> I think Harper also has an online SML book or tutorial.
13:01:13 <slowriot> Are there any Haskell editors that properly display the type of an value on command?
13:01:19 <Baughn> dmhouse: Anyhow, go ahead and define iff. I did.
13:01:28 <DRMacIver> It's very well written, cheap and has a cute little explosion for demonstrating the problem with polymorphic references.
13:01:31 <Baughn> slowriot: Emacs sometimes does
13:01:42 <monochrom> I like explosions.
13:01:46 <slowriot> Baughn: yeah, but not all the time
13:01:55 <DRMacIver> @remember monochrom I like explosions.
13:01:55 <lambdabot> Done.
13:01:56 <slowriot> Baughn: I'm currently using emacs
13:01:58 <Baughn> slowriot: It lacks an inferior ghci mode
13:02:33 <SpoilSport> Is there any good IDE for Haskell since I am currently using a normal text editor?
13:02:47 <slowriot> SpoilSport: I think emacs haskell mode is the IDE of choice
13:02:49 <Baughn> Rewriting haskell-mode is somewhere in a fractal corner of my todo-list, but last time I tried to find it I got lost
13:03:01 <dmhouse> Baughn: why rewrite it?
13:03:05 <slowriot> SpoilSport: There's also Yi and Visual Haskell
13:03:06 <Baughn> SpoilSport: Emacs haskell-mode is horrible, but it's better than everything else
13:03:07 <dmhouse> Baughn: it's good, and it's improving.
13:03:18 <LoganCapaldo> > let bool True = const; bool False = flip const; max a b = bool (a > b) a b in max 3 2
13:03:20 <lambdabot>  3
13:03:23 <SpoilSport> does visual haskell require me to install .NET framework ?
13:03:30 <dmhouse> Baughn: if you know Emacs Lisp then patches would be very much appreciated. I'm hacking on it right now.
13:03:32 <Baughn> dmhouse: It tries to parse haskell on its own instead of using haskell-src. Also, last time I tried to edit it, I got terribly, terribly lost.
13:03:37 <LoganCapaldo> I think bool is a good name. it lines up with either and maybe
13:03:42 <slowriot> SpoilSport: I think you just need Visual Studio .NET
13:03:55 <dmhouse> Baughn: it only 'parses' Haskell insofar as it uses font-lock.
13:04:16 <SpoilSport> Hmm that would be too much to download for me :( How much MB is Yi?
13:04:20 <Baughn> dmhouse: There's probably a lot of code in there I wouldn't want to replace, but I can't be bothered to figure it out. I'd write something that looks a lot like slime instead.
13:04:29 <slowriot> SpoilSport: Not very much
13:04:34 <dmhouse> SpoilSport: I don't know whether Yi is usable yet. I may be wrong.
13:04:35 <Baughn> dmhouse: Well, that might change if I decided to actually /do/ it
13:04:49 <dmhouse> Baughn: what features would make it more SLIME-like?
13:04:54 <slowriot> oh, sorry. Yeah, I have never used Yi.
13:05:04 <SpoilSport> anything which has highlighting would do, I don't need autocompletion
13:05:21 <slowriot> Visual Haskell has highlighting
13:05:23 <slowriot> oh
13:05:30 <dmhouse> Baughn: perhaps debugging? The ability to send individual functions to the interpreter? Neither of these are really supported by GHCi yet.
13:05:41 <slowriot> you mean like syntax highlighting or error highlighting?
13:05:45 <SpoilSport> yes
13:05:46 <SpoilSport> when learning autocompletion is bad.
13:05:57 <SpoilSport> syntax highlighting
13:06:06 <slowriot> get emacs haskell-mode
13:06:07 <SpoilSport> I can find errors from the GHCi
13:06:12 <DRMacIver> vim or emacs can both do syntax highlighting for Haskell quite happily.
13:06:13 <Baughn> dmhouse: Keeping a ghci connection that it keeps in sync with the open files, having ghci do most of the actual work (leaving the elisp bits as tiny as possible), leveraging it to get debugging, single-stepping in source, types and such..
13:06:28 <SpoilSport> isn't emacs the one which has a lot of key combinations
13:06:39 <Baughn> dmhouse: Mostly it's because I've hacked on slime in the past, and am quite comfortable with that sort of architecture
13:06:40 <slowriot> SpoilSport: Yeah, but you don't have to use them.
13:06:45 <dmhouse> Baughn: GHCi does already most of the work. Have you seen inf-haskell.el?
13:07:02 <slowriot> SpoilSport: I use emacs and I think key combinations for everything are ridiculous.
13:07:12 <SpoilSport> so is there a workaround
13:07:15 <dmhouse> Baughn: it has, for example, inferior-haskell-find-definition, inferior-haskell-type, inferior-haskell-info, and I'm currently hacking on inferior-haskell-find-haddock.
13:07:15 <Baughn> dmhouse: As I said, I got lost. At the time I was trying to change the order indentation options were presented in, so I wasn't looking at the right parts to see that.
13:07:19 <fasta> I have a class (A a) => Foo a, why do I need to specify the same context in an instance again?
13:07:23 <SpoilSport> I mean using it as a normal editor
13:07:29 <fasta> Or is this yet another compiler bug?
13:07:37 <dmhouse> Baughn: indentation is tricky, there are multiple valid indentation levels for each syntactical context. haskell-mode's current indentation engine could stand to be more heuristic and pick the right level more often, but that code is, as you say, scary :)
13:07:40 <slowriot> SpoilSport: Yeah, just don't use the key combinations.
13:07:46 <SpoilSport> I hope i don't have to do :q or something for going in edit mode
13:08:03 <Baughn> dmhouse: Probably doesn't help that I don't have a working haskell build on my laptop, but depend on running it remotely
13:08:12 <Baughn> dmhouse: Slime handled that fine too. ;)
13:08:22 <SpoilSport> where can I download this Emacs you are talking about 'slowriot'
13:08:34 * ddarius is entertained
13:08:36 <slowriot> SpoilSport: The key config that it ships with is non-standard, but it's pretty easy to customize.
13:09:12 <ddarius> slowriot: And by "non-standard" you mean "preceded the 'standards'"
13:09:17 <slowriot> http://www.gnu.org/software/emacs/
13:09:20 <lambdabot> Title: GNU Emacs - GNU Project - Free Software Foundation (FSF)
13:09:35 <Baughn> SpoilSport: Emacs is an editor construction toolkit, not really an editor. You *must* eventually write a thousand-line initialization file, or you're missing the point.
13:09:36 <slowriot> ddarius: right. It's different from the current standards.
13:09:37 <dmhouse> Baughn: http://haskell.org/haskellwiki/Haskell_mode_for_Emacs has info on indentation.
13:09:38 <lambdabot> Title: Haskell mode for Emacs - HaskellWiki
13:09:42 <SpoilSport> are there any open source haskell out there?
13:09:49 <SpoilSport> haskell projects*
13:10:01 <SpoilSport> like the spew of java
13:10:03 <ddarius> SpoilSport: Practically all of them you'd here about
13:10:03 <Baughn> SpoilSport: hackage
13:10:17 <ddarius> s/here/hear
13:10:24 <SpoilSport> hackage?
13:10:28 <ddarius> To start off, all the implementations are open source
13:10:29 <Baughn> @where hackage
13:10:29 <lambdabot> http://hackage.haskell.org/trac/hackage
13:10:29 <SpoilSport> is it site name?
13:10:29 <ddarius> @hackage
13:10:30 <lambdabot> http://hackage.haskell.org
13:11:35 <Baughn> dmhouse: Wait, you mean 2.1 isn't the latest release?
13:11:37 <Baughn> Oh, happy day
13:11:52 <dmhouse> Baughn: nope, try 2.3! :)
13:12:45 <Baughn> dmhouse: I'm going to try making it work well with remote files, since that's what I'm using. You've gone and motivated me now.
13:13:13 <dmhouse> Baughn: I'm sure Stefan will appreciate your patches! :)
13:13:21 <dmhouse> (May be getting ahead of things a bit there.)
13:13:39 <Baughn> A bit. I estimate only a 30% chance that there will ever be any patches. :P
13:15:11 <sorear> ddarius: I've yet to find the source to the Snowball or Yale compilers.
13:15:29 <dmhouse> sorear: the what and the who now?
13:16:18 <sorear> dunno much about Snowball HC, dons told me about it yesterday
13:16:19 <Baughn> dmhouse: Maybe I'll write some monstrous adaptive indentation thing..
13:17:01 <dmhouse> Baughn: please do. haskell-mode already has two different indentation engines! :) But seriously, indentation is one thing that could stand to improvement.
13:17:04 <sorear> 2007.06.21.22.07.40 < dons> that's Andy Gill's Snowball Haskell Compiler
13:17:09 <sorear> 2007.06.21.22.10.00 < dons> we should try to get the source online
13:17:35 <dmhouse> Is it a new kid on the block or an antique?
13:17:59 <sorear> the Yale hc was one of the very first, compiling to Common Lisp.  I suggested that we should get it on nobench *greps logs*
13:18:08 <DRMacIver> I think it's an antique. I seem to recall reading the name in the history of haskell paper (by SPJ?)
13:18:16 <Baughn> dmhouse: Oh, but the wiki makes a good point. It doesn't parse haskell completely, and therefore it doesn't indent well. The first, at least, should be fixable.
13:18:29 <DRMacIver> Compiling to common lisp? Wow. :)
13:19:01 <wellwisher> How do define a type tag in an an argument for a function?
13:19:08 <dmhouse> Baughn: true. Parsing Haskell is Hard with a capital 'H', though.
13:19:22 <dmhouse> Baughn: unless we can somehow delegate it.
13:19:28 <Baughn> dmhouse: Exactly
13:19:52 <dmhouse> Baughn: any ideas in mind? You mentioned something called 'haskell-src' that I haven't heard of earlier.
13:20:23 <Baughn> dmhouse: libghc6-haskell-src-dev - Haskell module for manipulating Haskell source code for GHC
13:20:35 <Baughn> dmhouse: The only reason I know about it is because said package isn't working. I'd have to look into it.
13:20:53 <Baughn> lambdabot uses it, though
13:20:54 <dmhouse> Ah. Well, there's also the GHC API, but that's more for Haskell programs.
13:21:00 <sorear> /var/cache/stefan-downloads/irclogs/www.cse.unsw.edu.au/07.02.19-18:04:41 <dons> not even sure if the yale src was ever available for free anyway?
13:21:20 <Baughn> dmhouse: Why shouldn't haskell-mode be able to use haskell APIs? ;)
13:21:45 <sorear> dmhouse: look at shim :)  the number of layers is impressive
13:22:00 <dmhouse> Perhaps we could request a GHC option that parses a Haskell source file on stdin and prints it out in sexps or XML or something easier.
13:22:10 <dmhouse> Ooh, I remember thinking 'I need to look at shim'. What does it do
13:22:19 <sorear> emacs uses udp over localhost to communicate with a proxy which uses unix domain sockets to communicate with a haskell program that calls the ghc api
13:22:57 <dmhouse> Aha!
13:23:02 <dmhouse> "The aim of the shim (Superior Haskell Interaction Mode) project is to provide better support for editing Haskell code in VIM and Emacs by using the GHC-Api to provide features such as identifier completion, type lookup, background compilation and much more. It's heavily inspired by SLIME and Visual Haskell and even borrows some code from these projects. For now, there is only an Emacs mode that uses the shim server."
13:23:09 <dmhouse> This seems particularly pertinent.
13:23:11 <Baughn> dmhouse: SLIME keeps the common-lisp-indentation code in common lisp, and uses a network api to talk to emacs. I see no reason why that wouldn't work with haskell-mode.
13:23:30 <Baughn> Ah, I see someone else got ahead of me
13:23:57 <dmhouse> I hope it can be integrated into haskell-mode, there are a lot of good things there.
13:24:09 <Wechner> hello
13:24:10 <sorear> Obviously, we need a major mode for linking Yi's modes.
13:24:13 <sorear> helo, Wechner
13:24:15 <DRMacIver> dmhouse: XML?
13:24:18 <DRMacIver> dmhouse: *smite*
13:24:20 <Baughn> Or the other way around, but it might end up replacing haskell-mode the way slime replaced ilisp
13:24:30 <dmhouse> DRMacIver: I'd prefer sexps, but XML is more universal.
13:24:47 <dmhouse> Baughn: perhaps;
13:24:54 <dmhouse> Baughn: nonethless, it's something of note.
13:24:58 <SpoilSport> anyone done gopher here?
13:25:06 <Baughn> dmhouse: Yep. Installing it now.
13:25:15 <DRMacIver> dmhouse: Surely the obvious thing to output to is Haskell with the indentation replaced with { ; } and the precedence and prefixing resolved.
13:25:29 <SpoilSport> educational version of haskell?
13:25:39 <Binkley> oh, you mean gofer?
13:25:46 <SpoilSport> oh sorry
13:25:49 <SpoilSport> yes gofer
13:25:54 <dmhouse> DRMacIver: perhaps, that's still pretty hard to parse compared to XML and sexps though.
13:26:27 <LoganCapaldo> I thought hugs was gofer in a past life?
13:26:39 <SpoilSport> hmm
13:26:43 <Wechner> I have the following problem with linking statically with ghc: I am using the flags -static -optl-static to compile my haskell program but the linking fails then with "cannot find -lgtk-x11-2.0" although this library was dynamically linked before, what am I missing?
13:26:49 <sorear> SpoilSport: but we've got gopher fine too..  CosmicRay runs quux.org
13:26:51 <sorear> :)
13:27:00 <DRMacIver> dmhouse: It practically *is* sexps. :) If you desugar the dos as well then it's as near as dammit.
13:27:04 <dmhouse> Baughn: realistically nearly all of the features we're discussing shouuld be minor-mode level.
13:27:22 <dmhouse> DRMacIver: yes, but Emacs Lisp's READ function would still choke on it.
13:27:33 <sorear> dmhouse: just use deriving(Show)
13:27:38 <SpoilSport> Sorear: You lost me there. yes I know there is a protocol named gopher :)
13:27:39 <ddarius> HUGS: Haskell User's Gofer System
13:28:01 <sorear> dmhouse: showsPrec 11 foo "" will produce something close enough to s-exprs
13:28:16 <dmhouse> Baughn: oh, shim does integrate into haskell-mode. Yay!
13:28:20 <sorear> dmhouse: well, as long as you don't have infix ctors :)
13:28:34 <sorear> dmhouse: also, the String coding is different.
13:28:44 <dmhouse> sorear, DRMacIver: I guess. The better solution is to consult the GHC API with Shim anywy.
13:29:22 <SpoilSport> do anyone of you do haskell here for fun or are all of you haskell programmers?
13:29:33 * LoganCapaldo is here for the fun
13:29:38 <dmhouse> I think nearly everyone does it for fun.
13:29:42 <notsmack> both
13:29:43 <SpoilSport> I mean haskell for living
13:30:02 <fasta> Another compiler bug found...
13:30:06 <sorear> most of us are non-professional.s
13:30:12 <Vulpyne> I program for a living, but my boss doesn't really care what language I use.
13:30:13 <fasta> Are there any other Haskell compilers that actually work?
13:30:17 <DRMacIver> Just for fun here too. I applied for a Haskell job recently, but didn't really go for it in the end.
13:30:49 <SpoilSport> hmm even I am a java code monkey by day and a haskell toddler at night :)
13:30:55 <DRMacIver> aol.
13:31:10 <DRMacIver> (Although I do a fair bit of Java at home too)
13:31:20 <SpoilSport> java programs are so large
13:31:37 <dmhouse> DRMacIver: where did you apply?
13:31:43 <DRMacIver> dmhouse: Credit Suisse.
13:31:44 <SpoilSport> A simple site in J2EE starts spanning across 10-20 files
13:31:45 <heanol> work as a java coder too
13:31:46 <heanol> :p
13:31:54 <dmhouse> DRMacIver: oh, cool :)
13:32:05 <SpoilSport> haskell is expressive
13:32:16 <SpoilSport> more thinking and less coding
13:32:28 <SpoilSport> the same is for Scheme, Ocaml, etc
13:32:41 <DRMacIver> dmhouse: We were each interested but ambivalent about the other and I ended up accepting a different job before anything was resolved with them.
13:32:52 <dmhouse> Baughn: can you get shim to compile? Mine errors out.
13:33:10 <DRMacIver> SpoilSport: It's my impression that Haskell doesn't really solve the large program problem.
13:33:11 <dmhouse> DRMacIver: I see. Are you still Java-ing then?
13:33:29 <hpaste>  fasta pasted "Compiler bug?" at http://hpaste.org/369
13:33:54 <DRMacIver> SpoilSport: It's locally much more expressive than Java or the like, but large programs are still large and unwieldy. Probably more reliable, but with much the same problems as large programs in other languages.
13:34:17 <fasta> That's a complete example and only requires commenting a few lines, but otherwise should load directly, please have a look.
13:34:20 <DRMacIver> dmhouse: At the moment I'm still in my old job. In a little over a month I'll be moving to a Java + some Ruby job.
13:34:52 <DRMacIver> dmhouse: But unlike the current one it involves cool things in lackluster languages rather than lackluster things in lackluster languages, so I'm still pleased. :)
13:35:03 <dmhouse> DRMacIver: great :)
13:35:12 <dmhouse> DRMacIver: well, good luck :) Ruby is cool.
13:35:22 * DRMacIver is totally unexcited by Ruby.
13:35:39 <Baughn> dmhouse: Compiled fine here
13:35:57 <DRMacIver> But it looks pleasant enough. We'll see how I find it once I'm actually writing the stuff.
13:35:57 <dmhouse> Baughn: grr. Which GHC version?
13:36:00 <Baughn> 6.6
13:36:16 <dmhouse> I'm on 6.6.1, shouldn't think it'd make too much difference. Which version of FilePath?
13:36:28 <Baughn> Whatever's on hackage. 1.0, I think
13:36:28 <fasta> Nobody has time to look at the compiler bug?
13:36:55 <dolio> fasta: What's the error message?
13:37:11 <fasta> No instance for (MonadST s m)
13:37:12 <fasta>       arising from the superclasses of an instance declaration
13:38:09 <fasta> dolio: any idea?
13:38:18 <dolio> fasta: Well, off hand, I'd say you can't declare 'instance Weird s m' because you're trying to declare it forall s m, and there aren't MonadST s m instances forall s m.
13:38:36 <fasta> dolio: but why does the Monad declaration work then?
13:38:41 <ddarius> gopher://quux.org
13:38:42 <ddarius> lambdabot can't do gopher?  How disappointing
13:38:50 <ddarius> SpoilSport: Anyways, most of what was interesting about Gofer got folded back into Haskell.
13:38:54 <fasta> dolio: that's forall m
13:39:34 <dolio> Monad doesn't have a superclass.
13:39:43 <fasta> dolio: ok, good point.
13:40:05 <dolio> Although I don't know why it's letting you get away without defining return and (>>=).
13:40:17 <fasta> dolio: but why aren't the contexts automatically added?
13:40:31 <fasta> dolio: It could be that that is part of H98, though.
13:41:15 <fasta> dolio: I do, defining methods of a class is always optional.
13:41:47 <dolio> I don't know. I guess theoretically it could automatically restict it based on the class declaration.
13:41:54 <dolio> But, it doesn't. :)
13:42:28 <dolio> There might be some gotcha I don't know about, though.
13:42:32 <fasta> dolio: ok, so no compiler bug. Good.
13:43:31 <fasta> dolio: uhm, no, the issue is not cleared up
13:43:50 <fasta> dolio: take a look at instance Foobar Int
13:44:04 <fasta> dolio: why doesn't that need a context?
13:44:14 <fasta> dolio: because it's not dependent on A?
13:44:21 <fasta> dolio: yeah, that must be it.
13:44:21 <dolio> Int is a concrete type.
13:45:16 <fasta> dolio: ok
13:45:20 <fasta> dolio: thanks
13:45:45 <dolio> It's needed in 'instance (MonadST s m) => Weird s m' to restrict s and m to the right subsets of all types.
13:59:17 <sorear> @botsnack
13:59:17 <lambdabot> :)
13:59:53 <heanol> @botsnack
13:59:53 <lambdabot> :)
13:59:56 <heanol> hehe
14:01:47 <Binkley> ?yow
14:01:47 <lambdabot> I just got my PRINCE bumper sticker ... But now I can't remember WHO he is ...
14:02:41 <heanol> what are some good exerices for getting started with haskell?
14:06:01 <dcoutts> heanol: looking for a book or some exercises on the web?
14:06:57 <dcoutts> heanol: there's lots of links from haskell.org in the getting started section
14:07:16 <heanol> ok i'll look there :)
14:07:19 <dcoutts> like the "Haskell in 5 steps" and "Learning Haskell" sections
14:08:39 <Binkley> ?quote
14:08:39 <lambdabot> dukedave says: I should write "#haskell less, think more" next to my keyboard :)
14:08:51 <mauke> @quite
14:08:51 <lambdabot> Maybe you meant: quit quote
14:13:07 <sorear> 2
14:15:52 <Binkley> ?quote
14:15:52 <lambdabot> ClausReinke says: SPJ: advanced haskell processor, theory and practice
14:17:58 <ddarius> Yay, good server.
14:22:38 <Binkley> ?yow
14:22:38 <lambdabot> Is it NOUVELLE CUISINE when 3 olives are struggling with a scallop in a
14:22:38 <lambdabot> plate of SAUCE MORNAY?
14:23:12 <DRMacIver> Hm. What does quit do to lambdabot? :)
14:23:26 <Binkley> ?quit
14:23:26 <lambdabot> Not enough privileges
14:23:27 <Binkley> heh
14:23:30 <Binkley> Figures.
14:23:41 * Binkley feels underprivileged
14:27:27 <Vulpyne> You would use the power for evil.
14:27:48 <Binkley> it's true, I would
14:27:50 <DRMacIver> What else would be the point of having power?
14:28:30 <lambdabot> Taunting you, DRMacIver.
14:28:37 <Baughn> Chaos. Chaos is also good.
14:28:52 <fasta> If you try it 2^100 times you probably get permission.
14:29:08 <Baughn> By random glitch, if nothing else
14:29:21 <Binkley> sunspots
14:29:39 <sorear> All you have to do is be in the right place at the right time.
14:29:43 <DRMacIver> sequence $ [1..] >> quit
14:29:49 <Baughn> See? Chaos is the fundamental nature of the universe.
14:29:52 <Baughn> All hail Eris!
14:29:56 <DRMacIver> Or something like that.
14:30:09 <sorear> Like, Nov-ish 06 - Dons goes on vacation, looks around, sees that sorear is active.
14:31:50 <fasta> All you need to do is trick the OpenBSD devs into accepting a patch that enables you to break it. :)
14:32:57 <DRMacIver> I don't think I could get the OpenBSD devs to accept a patch from me full stop. :)
14:33:19 <sorear> With a few word games, I've done it.
14:33:22 * Baughn plots to make them accept a GPLed patch
14:33:48 <sorear> A certain openbsd dev accepted a patch from me so egregiously bad he obviously never read it :(
14:33:56 <DRMacIver> (My C is very weak)
14:34:01 <sorear> fortunately I managed to produce a fix soon.
14:34:14 <sorear> DRMacIver: there's an obsd dev who will accept haskell patches
14:34:14 <DRMacIver> Did he accept that? :)
14:34:20 <DRMacIver> Heh, really?
14:34:21 <sorear> yes
14:34:33 <DRMacIver> For which parts?
14:34:44 <sorear> The trick is, nobody said obsd dev implies that the project is obsd :)
14:34:52 <sorear> I am speaking of dons and lambdabot.
14:34:55 <DRMacIver> Oh, heh
14:35:05 <DRMacIver> *thwack*
14:42:47 <ddarius> Patch GHC so that when lambdabot is compiled it gives you admin permissions.
14:43:38 <quicksilver> no, patch GHC so that when GHC is compiled, then the resulting GHC, when  lambdabot is compiled it gives you admin permissions.
14:43:44 <quicksilver> that's much more subtle :)
14:43:48 <DRMacIver> I was about to say. :)
14:44:15 <Heffalump> don't forget the important step of removing your patch from the source afterwards
14:44:17 <DRMacIver> But really you need to patch the binary bootstrapper
14:44:25 <DRMacIver> So you can... err, yeah, what Heffalump said.
14:44:41 <Heffalump> you presumably have all read reflections on trusting trust?
14:44:59 <DRMacIver> Yeah
14:45:17 <monochrom> I did.
14:47:33 <scodil> what's the deal with build? Is this internal only or do you need to use it if you want to write "good producers" ?
14:48:00 <Heffalump> you need to use it to write good producers
14:48:06 <Heffalump> or use something based on build already
14:48:17 <Binkley> at least, until type-based deforestation takes over the world
14:48:45 <Heffalump> stream-based deforestation is taking over as of 6.8, AFAIK
14:49:12 <Binkley> I don't think they're mutually exclusive, but I haven't thought about it too much
14:49:24 <scodil> what is the equivalent to use for writing good consumers? foldr?
14:49:28 <Binkley> scodil: yes
14:49:41 <scodil> what about map?
14:50:01 <scodil> thats good at consuming and producing, right?
14:50:02 <Heffalump> I'd expect that to be both a good consumer and a good producer, but I'm not certain.
14:50:06 <Heffalump> @src map
14:50:06 <lambdabot> map _ []     = []
14:50:06 <lambdabot> map f (x:xs) = f x : map f xs
14:50:14 <Heffalump> that won't be :-)
14:50:14 <sjanssen> scodil: map is written in terms of both foldr and build
14:50:21 <scodil> cool
14:51:21 <sjanssen> map f xs = build (\c n -> foldr (\y ys -> f y `c` ys) n xs) -- IIRC
14:51:33 <ski> foldr cons nil (map f as) = foldr (cons . f) nil as
14:51:46 <ski> map f as = build (\cons nil -> foldr (cons . f) nil as)
14:56:55 <sorear> scodil: the google-term is "shortcut deforestation", if you're still curious
14:57:07 <scodil> i'll check that out
14:57:08 <sorear> Binkley: what's type based deforestation?
14:57:26 <Binkley> sorear: it's what I worked on for my master's thesis and then dropped on the floor rather than finishing
14:57:37 <Binkley> but if you're interested, look for "Type Inference Builds a Short Cut to Deforestation" by Olaf Chitil
14:57:55 <Binkley> or my thesis: http://lafalafu.com/krc/Writing/chevalier_ms_2004_type_inference.pdf
14:57:57 <lambdabot> http://tinyurl.com/2xz3xp
14:57:58 <Binkley> =)
14:58:05 <sorear> it'll be interesting to see what comes of ndm's thesis.
14:58:18 <ski> 'zipWith' in terms of 'build' and 'foldr' is fun
14:58:28 <sorear> defunctionalization + church encoding = deforestation
14:59:04 <Serge> > zipWith ($) [negate, recip, (*4)] [1..]
14:59:06 <lambdabot>  [-1.0,0.5,12.0]
15:01:22 <scodil> ski: fun how? That's one I actually need. Is it already in fusion-compatible form in GHC? Or do I need to do something special?
15:01:34 <scodil> The docs aren't super clear. It just says its a good consumer of one of the arguments, not both
15:02:10 <ddarius> sorear: In which order?
15:03:01 <ski> scodil : i don't know about if it's in ghc ..
15:03:02 <ski> hm
15:03:20 <ski> afaik it ought to be a good consumer of both arguments
15:03:40 <ski> at least my version uses foldr on both arguments
15:03:41 <scodil> zip, zipWith (but on one argument only; if both are good producers, zip will fuse with one but not the other)
15:03:45 <scodil> thats from the docs
15:05:32 <heanol> @yow
15:05:32 <lambdabot> I'm a fuschia bowling ball somewhere in Brittany
15:05:36 <ski> i haven't actually looked much on fusion in detail .. but if it suffices to only consume the list arguments by 'foldr' for 'build-foldr' fusion, then i can't see why my version wouldn't fuse with both arguments
15:05:38 <heanol> @yow
15:05:38 <lambdabot> I appoint you ambassador to Fantasy Island!!!
15:06:38 <ski> (scodil : would you like to see it ?)
15:06:43 <scodil> sure
15:06:44 <ihope> You know, I was thinking about the ability in English to "pull" certain words to the front of a sentence/phrase/clause/thing, and I was reminded of zippers.
15:07:26 <ihope> "I like to run"; "Like to run, I do"; "To run I like"
15:07:36 <ski> scodil : it is not directly expressed in terms of 'build' but rewriting to that is trivial
15:07:53 <oerjan> the second one is not English, it's Yoda :)
15:08:00 <ihope> Though so far, this looks like simple cycling.
15:08:02 <ihope> :-)
15:09:58 <ihope> "Though so far, this looks like simple cycling." "So far, though, this looks like simple cycling." "This looks like simple cycling so far, though." "Looks like simple cycling so far, though, this does." "Like simple cycling this looks so far, though." "Simple cycling this looks like so far, though."
15:10:20 <ihope> "Though", "so far", "this", "looks", "like", and "simple cycling".
15:11:39 <ihope> Like, so far, simple cycling, though, looks this.
15:12:17 <ihope> I tried to do "like so far this though looks simple cycling", but I realized I could only make something meaning "simple cycling looks like this".
15:12:40 <ihope> Anyway, this does seem sort of zipperish, doesn't it?
15:13:14 <Saizan> comonadic maybe :)
15:13:29 <oerjan> just a small step from gibberish
15:14:27 <oerjan> relative pronouns are zipper-like too
15:16:36 <ski> scodil :
15:16:50 <ski> http://www.mdstud.chalmers.se/~md9slj/code/FoldrZip.hs
15:18:47 <scodil> which one is the winner?
15:18:52 <vincenz> For all you pi-geeks, put your speakers on: http://pi.ytmnd.com/
15:18:53 <scodil> zipWith3?
15:18:53 <lambdabot> Title: YTMND - 3.141592653589793...
15:19:06 <ski> 'zipWith3' was the one i was talking about, yes
15:19:17 <ski> the others uses patternmatching on the lists
15:19:39 <heanol> @yow
15:19:39 <lambdabot> -- I love KATRINKA because she drives a PONTIAC.  We're going away
15:19:39 <lambdabot> now.  I fed the cat.
15:20:26 <ski> however, to express with 'build', the body should be wrapped in 'build (\consC nilC -> ...)' and the '[]','(:)' in the body be replaced with 'nilC','consC'
15:21:30 <ski> scodil : a while after i wrote it i realized oleg had made essentially the same solution two or three years before, iirc
15:21:57 <scodil> hah. of course.
15:22:10 <hpaste>  hpacheco pasted "class type constraining?" at http://hpaste.org/371
15:22:29 <dolio> Are the newtypes necessary or were they just to help you get the code correct?
15:22:32 <ihope> Who's oleg, exactly/
15:22:41 <scodil> nobody knows
15:22:45 <scodil> he's a mystery
15:22:47 <ski> i needed the newtypes to express the cyclic types
15:23:02 <ski> 'zipWith3' uses a kind of coroutine intuition
15:23:19 <Binkley> ihope: a wizardly hacker
15:23:23 <ihope> scodil: how do we know what oleg's done, then? :-P
15:23:31 <ski> @where oleg
15:23:31 <lambdabot> http://okmij.org/ftp/
15:23:33 <scodil> ancient scrolls
15:23:39 <ihope> Is "oleg" his entire name?... oh, hmm.
15:23:50 <ski> kiselyov, iirc
15:25:29 <ddarius> Yes, Oleg Kiselyov
15:25:46 <ski> dolio : the trick is to start the 'foldr' iteration on the first argument, and the suspend it while you start the iteration on the second argument, and the you need to pass back and forward the suspension state between the two
15:25:59 <ddarius> dolio: No, but they're nice.  You could use data which isn't exactly the same but close enough.
15:26:13 <ddarius> dolio: Um, ignore me.
15:26:16 <dmhouse> Anyone using Shim?
15:26:31 <dolio> ski: Ah. Okay.
15:26:39 <ski> the first passes an 'a' item to the second, the second combines it together with a 'b' item and returns that (yields to the externals iteration, if you will :)
15:27:08 <timthelion> what does this error even mean? XMonadContrib/EvenColumns.lhs line 15: unlit: Program line next to comment
15:27:25 <dolio> ski: I read the Oleg solution a little while back, and didn't remember him doing that. But he was already working with a fold type instead of lists.
15:27:26 <ihope> timthelion: you need a blank line between program lines and... other stuff.
15:27:28 <Binkley> timthelion: it means a program line is next to a comment :-)
15:27:34 <Binkley> in other words, you need to put in a blank line
15:27:36 <oerjan> > let zipInc z f l1 l2 = z (uncurry f) (zip l1 l2) in zipInc zipWith (,,) [1..10] [2..9] [3..8]
15:27:37 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8)]
15:28:03 <timthelion> Binkley: oh, that's silly
15:28:37 <hpaste>  ari pasted "short burrows-wheeler transform" at http://hpaste.org/372
15:29:26 <Binkley> timthelion: I'm not sure if there's a good reason for the syntax being like that... but it's easy enough to fix
15:29:32 <timthelion> Binkley: well thanks anyway, that fixed my problem
15:29:33 <ari> I can't be bothered to post to haskell-cafe for the first time for the sake of two lines, so consider that my participation in the Burrows-Wheeler transform thread ;)
15:30:02 <dolio> ari: Is it faster than the C++? :)
15:30:18 <ari> dolio: I haven't benchmarked it, but the answer is no :)
15:30:56 <ski> > let (<*>) = zipWith ($) in  repeat (,,) <*> [1..10] <*> [2..9] <*> [3..8]
15:30:57 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8)]
15:31:10 <igli> hmm
15:31:44 <dmhouse> > (,,) <$> [1..10] <*> [2..9] <*> [3..8] -- does it not work straight off?
15:31:45 <lambdabot>  [(1,2,3),(1,2,4),(1,2,5),(1,2,6),(1,2,7),(1,2,8),(1,3,3),(1,3,4),(1,3,5),(1,...
15:31:56 <ski> no, because that uses the list monad, not the stream monad
15:32:10 <igli> interesting
15:32:12 <dmhouse> Ah. You need newtype wrapping, then, IIRC>
15:32:16 <igli> what's the diff ski?
15:32:16 <oerjan> timthelion: it may be useful to warn against the case where your editor wrongly wraps a literate comment line
15:32:38 <igli> in a line
15:32:42 <ski> igli : the stream monad zips together, the list monad takes cartesian product
15:32:48 <igli> ah ok ty
15:32:48 <dmhouse> > (,,) <$> ZipList [1..10] <*> ZipList [2..9] <*> ZipList [3..8]
15:32:49 <lambdabot>        add an instance declaration for (Show (ZipList (a, a1, a2)))
15:33:02 <dmhouse> > getZipList $ (,,) <$> ZipList [1..10] <*> ZipList [2..9] <*> ZipList [3..8]
15:33:04 <lambdabot>  [(1,2,3),(2,3,4),(3,4,5),(4,5,6),(5,6,7),(6,7,8)]
15:33:10 <ski> nice
15:33:21 * dmhouse yearns for overloaded list notation
15:33:34 <ddarius> oerjan: Or if you miss a Bird track.
15:34:57 <dolio> @src genericLength
15:34:58 <lambdabot> genericLength []    = 0
15:34:58 <lambdabot> genericLength (_:l) = 1 + genericLength l
15:35:30 <oerjan> ddarius: yes, although it seems to me a wrapping editor would be the most likely way for that to happen.  I don't know I haven't used literate style.
15:37:59 <ddarius> I guess it's also possible to have code that looks like comments, though technically you should still be able to put a blank line although that would be atrocious.
15:39:22 <igli> ?
15:39:36 <igli> why ddarius?
15:39:50 <oerjan> ddarius: i think in Haskell that would require turning off layout to allow > at the beginning of a line.  And i don't think it is clear what would happen even if you had a blank line.
15:40:01 <igli> er in general then
15:41:13 <oerjan> er wait
15:41:54 <oerjan> that's nonsense, because in literate style > at the beginning of a line is never part of the code.
15:42:29 <ddarius> Er, yes I flipped it.
15:42:37 <ddarius> Still...
15:43:12 <oerjan> wait, that means it is actually the code that has to wrap wrongly.
15:44:07 <oerjan> well, i guess they put the blank line rule there because people have been burned by it.
15:51:06 <timthelion> damn, I'm not sure if I can live with having to put lines around my code in .lhs files. I wanted to write all my code in outline-minor-mode with lots and lots of comentary, like multiple lines of text per loc
15:51:48 <ddarius> So use normal comments
15:52:20 <timthelion> that's just as bad, having to write >-- instead of RET RET RET UP
15:52:46 <igli> --
15:53:00 <timthelion> igli: I'm in .lhs mode though
15:53:07 <dmhouse> timthelion: you can just use non-literate haskell and set outline-regexp to "-- \\*" or something like that.
15:53:11 <igli> ah ok wtf is that?
15:53:18 <igli> ah sorry
15:53:20 <igli> literate
15:53:38 <Saizan> there's the latex style literate code
15:53:42 <timthelion> igli: a mode where all lines of code are prefixed with > for to allow supersatuarted comments
15:54:04 <dmhouse> timthelion: if you've got multiple lines of text per line, I don't see that putting a blank line between it and your code will be too bd.
15:54:05 <dmhouse> *bad
15:54:42 <igli> hmm supersaturated=multi-line or..?
15:54:54 <dmhouse> igli: more comments than code.
15:55:10 <igli> heh
15:55:10 <timthelion> dmhouse: it's just annoying and doesn't look nice
15:55:12 <dmhouse> igli: for example, a tutorial-style email that includes some code -- the same file could be both the tutorial and the source code.
15:55:16 <ddarius> Like comment crystals start forming
15:55:26 <igli> dmhouse: sure i don't see what the issue is tho
15:55:33 * igli is not a haskell coder
15:55:35 <dmhouse> igli: or the manual for some software embedded alongside the code (darcs does this).
15:55:41 <igli> yeah
15:55:49 <dmhouse> timthelion: on the contrary, I think it serves as a nice visual break. It doesn't look that badly, at any rate.
15:56:03 <SamB> just don't use birds-feet literate style in a Re: ;-)
15:57:00 <timthelion> dmhouse: the way I code is that first I go into org-mode and write an outline, and then I flesh out the outline, and then I start with a new file, and I was thinking that I could use literate to make it so I could just flesh out the outline even more with code...
15:57:35 <dmhouse> timthelion: you could use LaTeX-style literate code.
15:57:42 <SamB> timthelion: you could do that with either style...
15:57:53 <dmhouse> There your code blocks are delimited with \begin{code} and \end{code}, and the blank-line limitation is removed.
15:58:00 <slava> i was horrified to notice that ghc source code uses C preprocessor
15:58:21 <timthelion> dmhouse: I think blank lines are better
15:58:22 <SamB> slava: how would you prefer it to work?
15:58:34 <slava> i'm not sure why a high-level language needs such preprocessing
15:58:35 <Modius> What's the cleanest haskell way to turn a list (literal) into a list of tuples?  E.g. 1 2 3 4 5 6 into [(1 2) (3 4) (5 6)] ?
15:58:50 <SamB> slava: it isn't perfect yet
15:59:23 <dmhouse> timthelion: with the LaTeX-style you also don't need the '> ' prefix.
15:59:26 <SamB> #ifdefs and numeric macros, at least, aren't that bad
15:59:32 <dmhouse> Modius: how long each?
15:59:40 <Modius> Say, size 2
15:59:46 <SamB> and there are some repetetive typeclass instances, too, I think
15:59:46 <dmhouse> Modius: is this homework? I've heard similar questions over the past few days.
15:59:58 <sorear> slava: Haskell doesn't have first class declarations.
16:00:17 <dmhouse> Modius: nothing wrong with that, but see http://haskell.org/haskellwiki/Homework_help if it is
16:00:18 <lambdabot> Title: Homework help - HaskellWiki
16:00:20 <Modius> No.  I'm 32 years old and honestly I'm implementing lazy-list stuff in a CL library I'm writing that blatantly rips off haskell
16:00:22 <slava> C preprocessor is bad hack IMO
16:00:23 <sorear> dmhouse: it's a commonish real world need
16:00:28 <dmhouse> sorear: true.
16:00:39 <dmhouse> Modius: okay :)
16:00:47 <SamB> slava: when we find a good hack we might replace it
16:00:48 <slava> it means that syntax errors can lurk in rarely-exercised combinations of flags
16:00:49 <Modius> I just want to know if there's a primitive that does this other than zipping offset lists
16:00:59 <slava> makes the code impossible to parse by tools, etc
16:01:00 <dmhouse> Modius: then I'd just write a good old-fashioned recursive function.
16:01:03 <DRMacIver> Honestly? The cleanest way is using simple pattern matching and doing the obvious recursive thing. But people will probably tell you half a dozen incomprehensible combinator based approaches. :)
16:01:04 <Modius> I.e. off of one literal
16:01:13 <slava> SamB: so the problem is that haskell is not reflective enough?
16:01:19 <SamB> slava: especially when they get rid of those pesky platform dependencies
16:01:21 <dmhouse> Modius: I'm not sure zipping offest lists will work.
16:01:27 <SamB> slava: how would being more reflective help?
16:01:35 <slava> SamB: sorear mentioned first class declarations
16:01:47 <sorear> slava: well, even without the preprocessor semantic errors frequently occur in unused code.
16:01:54 <oerjan> :t unfoldr
16:01:55 <dmhouse> Modius: e.g. zip xs (tail $ tail xs) where xs = [1..5] -> [(1, 3), (2, 4), (3, 5)], not [(1, 2), (3, 4)]
16:01:57 <lambdabot> forall b a. (b -> Maybe (a, b)) -> b -> [a]
16:01:58 <slava> i don't like CL code which is peppered with #+ and #- either; IMO read-time preprocessing should be avoided
16:02:09 <slava> sorear: static type checking helps there
16:02:11 <sorear> slava: on any given day, at least one of GHC HEAD's backends (-fasm and -fvia-C) doesn't work
16:02:25 <SamB> slava: well, some of the library ifdefs are actually to protect compilers from syntax they don't understand...
16:02:40 <oerjan> hm...
16:02:40 <slava> SamB: put that in a separate file which is compiled/linked as necessary
16:02:48 <igli> dmhouse: parse error
16:02:58 <slava> if you have a file with 3 #ifdefs, that's actually 2^3 source files in one
16:02:58 <dmhouse> igli: what is?
16:03:00 <Modius> Okay, just double-checking that there wasn't something in prelude/list that split lists into tuples
16:03:06 <SamB> slava: Haskell is not that good yet
16:03:06 <igli> er > zip xs (tail $ tail xs) where xs = [1..5] -> [(1, 3), (2, 4), (3, 5)], not [(1, 2), (3, 4)]
16:03:08 <dmhouse> > zip xs (tail $ tail xs) where xs = [1..5]
16:03:09 <lambdabot>  Parse error
16:03:25 <dmhouse> > let xs = [1..5] in zip xs (tail $ tail xs) -- silly pinnicky differences :)
16:03:27 <lambdabot>  [(1,3),(2,4),(3,5)]
16:03:52 <dmhouse> > let pairs [] = []; pairs [_] = []; pairs (x:y:xs) = (x, y) : pairs xs in pairs [1..5]
16:03:53 <lambdabot>  [(1,2),(3,4)]
16:03:57 <Modius> Okay, I stand corrected.  Mine was using iterate/drop-2, looking if there was something nicer.
16:03:58 <SamB> slava: and notice that breaking that file into those seperate files gives us 2^3-1 opportunities to forget to make a change
16:04:31 <dmhouse> Modius: if you can beat that recursive function for clarity, and even conciseness, I'd be surprised.
16:04:38 <ski> Modius : what if the list has odd length ?
16:04:51 <ski> > either snd id (foldr (\a -> either (\(a',bs) -> Right ((a,a'):bs)) (\bs -> Left (a,bs))) (Right []) [1..6])
16:04:53 <lambdabot>  [(1,2),(3,4),(5,6)]
16:04:54 <ski> > either snd id (foldr (\a -> either (\(a',bs) -> Right ((a,a'):bs)) (\bs -> Left (a,bs))) (Right []) [1..7])
16:04:56 <lambdabot>  [(2,3),(4,5),(6,7)]
16:04:58 <oerjan> > takeWhile (not . null) . map (take 2) . iterate (drop 2) $ [1,2,3,4,5]
16:04:59 <lambdabot>  [[1,2],[3,4],[5]]
16:05:22 <DRMacIver> <SoapBox>I think Haskell encourages you to go too far in trying to put things together with really cunning higher order functions and monadic operations etc. when you could just use simple recursion. Or at least, it seems to be a common reaction to Haskell programming. This is harmful and should be avoided.</SoapBox>
16:05:42 <dmhouse> DRMacIver: it's just #haskell algorithm golf. Don't take it too seriously.
16:05:44 <dmhouse> :)
16:06:05 <Modius> Acknowledged.  At my current stage in learning, though, I look at each situation as an opportunity to test my understanding of all the possible methods, even if some branches are the less elegant ones.
16:06:15 <SamB> DRMacIver: true
16:06:29 <DRMacIver> dmhouse: Well, I don't. :) It's good fun. That's really more or less what I'm saying though - this isn't something you should do in real code except when it's actually useful to do so.
16:06:30 <dmhouse> DRMacIver: but true nonetheless. Recursion and lambdas are underrated.
16:06:46 <DRMacIver> i.e. play with it, but don't take it too seriously.
16:06:56 <dmhouse> Clarity should always be your number one concern.
16:07:02 <SamB> dmhouse: I prefer functions named "f"
16:07:06 <DRMacIver> (And it is of course good practice for the many cases in which it *is* useful)
16:07:11 <SamB> it's hard to write recursive lambdas ;-)
16:07:12 <dmhouse> It's why I advocate, say, \x -> (x, x) instead of join (,).
16:07:27 <dmhouse> SamB: no it's not! fix them :)
16:07:33 <DRMacIver> Hm
16:07:36 <Modius> It was learning haskell that showed me (through self-referencing lazy-lists) that recursion and self-ref lazy-lists (continuation) CAN be analogous.
16:07:37 <DRMacIver> :t join
16:07:37 <SamB> :t id &&& id
16:07:40 <lambdabot> forall a. a -> (a, a)
16:07:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:07:54 <SamB> I'd write id &&& id for that ;-)
16:08:11 <oerjan> @list quote
16:08:11 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
16:08:21 <ski> it would be interesting if shivers' loop form could be adapted to statically typed languages
16:08:22 <Modius> What does $ mean?   (iterate (drop 2) $ [ 1, 2, 3, 4, 5])
16:08:22 <oerjan> @remember DRMacIver <SoapBox>I think Haskell encourages you to go too far in trying to put things together with really cunning higher order functions and monadic operations etc. when you could just use simple recursion. Or at least, it seems to be a common reaction to Haskell programming. This is harmful and should be avoided.</SoapBox>
16:08:22 <lambdabot> Done.
16:08:28 <ski> @src $
16:08:29 <lambdabot> f $ x = f x
16:08:40 <SamB> Modius: it doesn't do anything
16:08:40 <sorear> Modius: nothing
16:08:51 <Modius> Just change precedence?  Or literally nothing?
16:08:56 <SamB> the former
16:09:04 <heanol> is Maybe what i should use to give an optional argument to a function?
16:09:07 <DRMacIver> Modius: It's the operator for function application. It has a different precedence from the implicit one.
16:09:10 <dmhouse> > (fix $ \map f xs -> if null xs then [] else f (head xs) : map f (tail xs)) (+1) [1..4]
16:09:10 <SamB> er, or something
16:09:12 <lambdabot>  [2,3,4,5]
16:09:15 <dmhouse> SamB: ^^ :)
16:09:19 <dmhouse> heanol: most of the time, yes.
16:09:23 <SamB> what drbean said
16:09:26 <SamB> er.
16:09:29 <SamB> DRMacIver:
16:09:34 <SamB> I thought I typed an M
16:09:34 <dmhouse> heanol: if you need to give a lot of optional arguments, then it might call for a more complex solution.
16:09:50 <heanol> dmhouse, so.. f :: Maybe Int -> Bool
16:10:07 <dmhouse> DRMacIver: writing f $ big long expression is the same as writing f (big long expression). It can make things clearer by saving on brackets.
16:10:15 <heanol> how do i call that function without the param?
16:10:21 <dmhouse> heanol: f Nothing
16:10:24 <heanol> ah
16:10:35 <dmhouse> DRMacIver: oops, not you.
16:10:36 <DRMacIver> dmhouse: Yes, I know that. Why are you telling me? :)
16:10:40 <DRMacIver> Heh. ok
16:10:43 <dmhouse> Modius: writing f $ big long expression is the same as writing f (big long expression). It can make things clearer by saving on brackets.
16:11:05 * SamB feels better about accidentally addressing drbean ;-)
16:11:22 * cdsmith is still wondering who drbean is.
16:11:23 <dmhouse> Hehe. I wonder who drbean is.
16:11:28 <SamB> cdsmith: not a clue
16:11:29 <dmhouse> drbean: ping
16:11:41 * dmhouse hopes he's not sleeping
16:11:45 <SamB> drbean: animal, vegetable, or mineral?
16:12:16 <SamB> dmhouse: that'll teach him to leave his nick set to ring the bell ;-)
16:12:29 <dmhouse> SamB: :)
16:12:46 <Modius> dmhouse:  Thanks
16:13:04 * dmhouse has recently set up some annoying biff-type program that croaks whenever I get mail. But I only fetch mail once every half-hour in batches, so it just croaks for about thirty seconds every half hour.
16:13:17 <DRMacIver> Ha
16:13:22 <DRMacIver> What do you want that for? :)
16:13:57 <SamB> DRMacIver: to remind him to go to the bathroom?
16:14:18 <dmhouse> Well it's useful to have the icon in the GNOME taskbar, or whatever that particular widget is called, but I might turn off the sound effects.
16:14:48 * DRMacIver doesn't have speakers hooked up to his computer
16:15:04 <dmhouse> Don't you listen to music at all?
16:15:18 <DRMacIver> Headphones.
16:15:47 <DRMacIver> (This is a bug, not a feature. I just haven't got around to remedying it)
16:15:55 <dmhouse> Aha. I couldn't live with headphones long-term. They're nice occasionally, and when on the move, but I prefer to be a freer when I'm at home.
16:16:44 <DRMacIver> I use my ipod when I'm not sitting at the computer. :)
16:17:24 <cdsmith> I'm beginning to appreciate how much simpler my life is without music listening. :)
16:17:27 <dmhouse> I have a laptop so wherever I am, so is my computer :)
16:21:06 <SamB> cdsmith: you could listen to music on your pc speaker
16:21:40 <cdsmith> SamB: Nah.  I gave it up when my car stereo was stolen 9 months ago.
16:22:34 * DRMacIver -> bed
16:22:35 <DRMacIver> night
16:23:44 <heanol> i have two positions in a grid, like this (x,y) and (x1,y2)
16:24:07 <heanol> is there a nicer way to check if position2 is adjacent to position1 without checking each case?
16:24:13 <heanol> if someone understands what i mean.. :)
16:24:22 <cdsmith> heanol: define 'adjacent'?
16:25:23 <cdsmith> abs ((x - x1) * (y - y2)) == 1 is a tricky way, if you don't want diagonals.
16:25:23 <Botje> heanol: (x1-x)^2+(y2-y)^2 == 1 -- :)
16:25:52 <cdsmith> Wait, never mind what I said.
16:26:10 <beelsebob> was wondering what that was about cdsmith
16:26:20 <heanol> cdsmith, i do want diagonals too
16:26:21 <cdsmith> Just mental fluke.
16:26:22 <ddarius> cdsmith: Life is simpler withou music listening?
16:27:02 <cdsmith> heanol: well, my code detects diagonal; Botje's detects non-diagonal adjacent ones.  That's down to two cases.
16:27:13 <cdsmith> ddarius: it made sense in context.
16:27:31 <ddarius> cdsmith: Not to me.
16:28:02 <cdsmith> ddarius: Everyone was listing all the different devices needed for music listening in various contexts: headphones, speakers, iPod, etc.
16:28:08 <heanol> cdsmith, Yep, just what i needed, thanks :)
16:29:05 <cdsmith> heanol: a cute variation: (x1-x)^2+(y2-y)^2 == 1 || (x1-x)^2*(y2-y)^2 == 1
16:29:25 <ddarius> I'd probably kill people if I couldn't listen to music every now and again.
16:29:38 <oerjan> abs(x1-x)+abs(y2-y) <= 1
16:29:44 <cdsmith> ddarius: then I'm in favor of your continuing to listen to music. :)
16:30:07 <beelsebob> oerjan: doesn't that detect if it's within 1 unit?
16:30:11 <oerjan> (without diagonals)
16:30:20 <beelsebob> with diagonals
16:30:38 <beelsebob> (0,0) (0.5,0.5) would be within yours
16:30:53 <cdsmith> oerjan: is (0, 0) adjacent to (0, 0).  My intuition says no.
16:31:14 <oerjan> well, == 1 then
16:31:54 <cdsmith> beelsebob: I was assuming integers.  Otherwise, "adjacent" is tough to define.
16:32:01 <Saizan> however (x1-x)^2+(y2-y)^2 is the sqare of the distance, why do you also check (x1-x)^2*(y2-y)^2 == 1 ?
16:32:18 <Saizan> s/sqare/square/
16:32:23 <Botje> because it might be > 1
16:32:38 <ddarius> Saizan: Square of the Euclidean distance.  There are other distances.
16:33:02 <Saizan> Botje: note the (+) and the (*
16:33:11 <cdsmith> Saizan: the multiplication detects diagonals (assuming that coordinates are always integers)
16:33:20 <Botje> Saizan: yes, i just did. sorry :)
16:33:33 <oerjan> :t listArray
16:33:37 <lambdabot> forall i e. (Ix i) => (i, i) -> [e] -> Array i e
16:33:39 <Saizan> cdsmith: the sum detects them too!
16:33:52 <Saizan> or not?
16:34:00 <cdsmith> No: the sum evaluates to 2 when the squares are diagonal.
16:34:32 <oerjan> hm...
16:34:51 <cdsmith> ^^^ heanol: cdsmith, i do want diagonals too
16:34:52 <oerjan> max(abs(x1-x), abs(y2-y)) == 1
16:35:07 <Saizan> ah, right, silly me, diagonals are longer :)
16:35:35 <cdsmith> oerjan: works except that (x,y) compares adjacent to (x,y), which may or may not matter
16:35:52 <oerjan> cdsmith: no it doesn't
16:35:57 <cdsmith> No, you're right.
16:36:09 <cdsmith> I read that as the earlier <=
16:37:05 <oerjan> all of the L1, L2 and Linfinity norms have now been mentioned :)
16:37:38 <ddarius> Well that completes my day.  I'm going to go read a book.
16:38:11 <cdsmith> I wonder if heanol is still here to see the answer. :)
16:38:24 <heanol> hehe, i'm observing
16:38:35 <oerjan> personally i wonder if a case branch might actually be faster.
16:39:01 <cdsmith> oerjan: actually, I think your last one is pretty good.
16:39:57 <Saizan> oerjan: how'd you write such a case?
16:40:17 <oerjan> case (x1-x, y2-y) of ..., perhaps
16:40:35 <cdsmith> That's 8 cases, though!
16:41:37 <Saizan> plus the wildcard one
16:41:40 <oerjan> i said faster, not more compact.
16:42:20 <cdsmith> oerjan: it's hard for me to imagine 8 branch statements being faster than two abs, a max, and (==).  Might just be me, I guess.
16:42:31 <Saizan> patterns on numbers are calls to ==
16:43:32 <oerjan> Saizan: well i hope that can be avoided with an explicit Int declaration
16:45:21 <oerjan> i was assuming the case would become a table lookup.  however, i just realized it would have to check index bounds, and this would probably redo most of the work in the max and abs case...
16:47:34 <heanol> http://hpaste.org/374
16:47:37 <heanol> shouldnt that work?
16:48:16 <monochrom> > max 2 1
16:48:18 <oerjan> heanol: i should think so
16:48:21 <lambdabot>  2
16:48:21 <mauke> no
16:48:31 <mauke> max doesn't take a tuple
16:48:33 <monochrom> > max (2,1)
16:48:35 <lambdabot>  <(Integer,Integer) -> (Integer,Integer)>
16:48:41 <mauke> ok, so it does :-)
16:48:51 <mauke> but there is no instance Num (a,b)
16:49:01 <igli> eh?
16:49:03 <ddarius> mauke: There could be.
16:49:11 <monochrom> > max (2,1) (1,1)
16:49:12 <heanol> http://hpaste.org/375
16:49:13 <lambdabot>  (2,1)
16:49:14 <heanol> i get that error..
16:49:16 <oerjan> right, sorry
16:49:34 <monochrom> Have I answered the question?
16:49:49 <mauke> heanol: max (abs (fst pos2 - fst pos1)) (abs (snd pos2 - snd pos1)) == 1
16:50:02 <mauke> consider using pattern matching instead of fst/snd
16:50:09 <heanol> pattern matching?
16:50:32 <oerjan> isAdjacent (x1,y1) (x2,y2) = ...
16:50:35 <monochrom> You can click on "annotate" instead of "new".
16:51:00 <mauke> isAdjacent (x1, y1) (x2, y2) = max (abs (x2 - x1)) (abs (y2 - y1)) == 1
16:52:01 <heanol> oh, cool!
16:52:03 <heanol> thanks
16:52:26 <oerjan> why isn't hpaste saying anything?
16:52:45 <ddarius> !paste
16:52:45 <hpaste> Haskell paste bin: http://hpaste.org/
16:53:06 <heanol> oerjan, i deselected "announce" when i pasted if thats what you mean
16:53:14 <heanol> i didn't know where it would be announced :)
16:53:14 <oerjan> heanol: ok :)
16:53:27 <ddarius> @seen hpaste
16:53:27 <lambdabot> hpaste is in #haskell. I last heard hpaste speak 42s ago.
16:53:33 <monochrom> It announces right here.
16:56:57 <monochrom> abs (x2 - x1) `max` abs (y2 - y1), if anyone care.
16:58:30 <heanol> what's the easiest way to debug a haskell program?
16:58:45 <heanol> i want to step through a function and look at variables' values
16:59:16 <monochrom> At present, use Debug.Trace
16:59:27 <lispy> heanol: rummor has it, ghci will have such a feature soon
16:59:39 <monochrom> Soon ghci will support breakpoints.
16:59:39 <lispy> heanol: but, usually you can just apply algebraic reasoning to pure code
16:59:54 <ddarius> There's also Buddha, Freja, Hat, and Hood or whichever of those are still alive.
17:04:23 <sorear> monochrom: not soon, already
17:04:42 <sorear> it hasn't been announced yet
17:05:18 <monochrom> I am not going to suggest heanol to "darcs get ghc HEAD"!
17:05:59 <heanol> hehe
17:06:33 <heanol> does darcs have any direct advantages against other distributed version control systems?
17:08:00 <wi> it has a cooler name
17:08:11 <heanol> mercurial sounds pretty cool too :/
17:08:17 <wi> donno. therse some comparisons out there on bk<>git<>hg<>codeville<>monotone<>darcs
17:08:31 <wi> yeah hg is nice. git is faster, if you are doing a huge project ( at the expense of only running right on POSIX systems)
17:08:48 <heanol> yeah i've tried git and hg, like hg the best :)
17:08:54 <heanol> coming from a cvs background
17:13:01 <Binkley> ?yow
17:13:01 <lambdabot> Not SENSUOUS ... only "FROLICSOME" ... and in need of DENTAL WORK ... in PAIN!!!
17:14:02 <dolio> @keal
17:14:03 <lambdabot> i prove infinity never ends in both directions
17:14:05 <igli> @bot
17:14:05 <lambdabot> :)
17:14:11 <igli> there there lambdabot ;)
17:16:37 <heanol> i have a line of code that looks like this: all (\x -> length (foo Nothing x) > 0) [1..10]
17:17:12 <ddarius> @pl \x -> length (foo Nothing x) > 0
17:17:13 <lambdabot> (> 0) . length . foo Nothing
17:17:38 <heanol> but i want to rewrite that so somehow, all elements after the first gets the result from the previous foo-call as a parameter instead of Nothig
17:17:41 <ddarius> heanol: What are you using length for, also use not . null as opposed to length.
17:17:41 <heanol> *Nothing
17:18:00 <mauke> sounds like a fold
17:18:13 <ddarius> heanol: You want a fold of some type as mauke said
17:18:22 <heanol> oh ok, i'll look that function up
17:18:34 <mauke> foldl (\z x -> not (null (foo z x))) Nothing [1 .. 10]
17:18:38 <ddarius> @hoogle foldl
17:18:39 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
17:18:39 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
17:18:39 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
17:18:41 <ddarius> @hoogle fold
17:18:42 <lambdabot> Data.IntMap.fold :: (a -> b -> b) -> b -> IntMap a -> b
17:18:42 <lambdabot> Data.IntSet.fold :: (Int -> b -> b) -> b -> IntSet -> b
17:18:42 <lambdabot> Data.Map.fold :: (a -> b -> b) -> b -> Map k a -> b
17:18:47 <ddarius> shite
17:18:56 <mauke> wait, that doesn't make sense
17:19:31 <mauke> heanol: foo returns a list but takes a Maybe
17:19:35 <ddarius> mauke: Use pairs
17:19:37 <heanol> mauke, Yep
17:19:54 <mauke> so how can you feed its output back into the function?
17:20:17 <ddarius> foldM ...
17:20:29 <ddarius> Just
17:20:36 <Saizan> Just z?
17:21:47 <heanol> mauke, i don't know, i guess that's what i'm asking
17:22:42 <mauke> what is this function supposed to do?
17:23:17 <oerjan> :t scan
17:23:19 <lambdabot> Not in scope: `scan'
17:23:23 <oerjan> :t scanl
17:23:25 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
17:23:25 <heanol> it searches a grid for a character, and optionally takes a starting position and then only returns indexes if its adjacent to it
17:24:09 <mauke> :t foldM
17:24:11 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
17:25:21 <oerjan> something like all (not . null) $ scanl foo Nothing $ [1..10] perhaps?
17:26:14 <oerjan> scanl (+) 0 [1..10]
17:26:17 <oerjan> > scanl (+) 0 [1..10]
17:26:18 <lambdabot>  [0,1,3,6,10,15,21,28,36,45,55]
17:26:51 * ddarius decides to go run.
17:27:18 * lispy yays at running
17:27:45 <mauke> not . null $ foldM (\z x -> map Just (foo z x)) Nothing [1..10]
17:27:47 <Excedrin> sort of not-related-to-haskell, but on a amd64, are all memory reads and writes actually 64 bit? I don't think this is the case, but someone made this assertion
17:27:48 * timthelion yays louder and wishes he didn't have a hamstring injury because there is a 10k race tomorow
17:28:46 <lispy> Excedrin: well, i'm not sure...of course all the old 32bit instructions are available still
17:28:49 <oerjan> oh right, there needs to be a Just in there
17:29:13 <dpiponi> I have a little performance issue to mention. Check out my hpaste...
17:29:17 <hpaste>  dpiponi pasted "Monad third law and performance" at http://hpaste.org/376
17:29:21 <lispy> Excedrin: but i don't know how the hardware does it when you use them...mabye it tries to bunch them up and fetch 64bit at a time?  but I doubt it...
17:29:37 <dpiponi> test2 is much faster than test1
17:30:03 <oerjan> all (not . null) $ catMaybes $ scanl (Just . foo) Nothing $ [1..10]
17:30:13 <lispy> timthelion: it's getting OT, but i know how you feel...i had a to miss an 8k recently for an I.T. band injury :(
17:30:17 <notadev> interesting dpiponi
17:30:18 <ddarius> dpiponi: What do you think will happen if you hide (>>=) and give it a different associativity?
17:30:56 <Excedrin> lispy: yea, I agree... it seems more likely that it's x86 style, some accesses are 8 bit, some are 16 bit etc
17:30:57 <dpiponi> It's not straightforward to give it a different associativity. Associativity in monads is different to ordinary algebraic associativity. Changing the operator won't help.
17:31:17 <ddarius> True
17:31:18 <dpiponi> The compiler needs to use the 3rd monad law internally
17:31:44 <dpiponi> I think this was just an issue with the min-sum monad thing I wrote about in my blog. But it applies to the list monad too.
17:31:51 <dpiponi> s/think/thought/
17:32:19 <koala_man> all x86 memory fetches are at least 16bit, if it just needs 8 bits it'll throw the rest away. probably 32 bit too.
17:32:45 <ddarius> What if you fetch at the highest address
17:33:09 <notadev> koala_man: eh?
17:33:15 <Saizan> so test1 is not a loop but keeps everything in scope alive until it's done?
17:33:24 <notadev> er yeah 32 bit on 386+
17:34:03 <Saizan> (for some value of loop)
17:35:05 <dpiponi> test1 and test2 work very differently
17:35:30 <dpiponi> I think test1 is a loop within a loop within a loop...so to speak
17:35:34 <koala_man> notadev: it takes longer to fetch values that don't lie on boundaries
17:36:01 <notadev> yeah but only an idiot aligns to less than 4 chars
17:36:01 <dpiponi> test2 loops over a list. When that's finished it loops over a new list. When that's finished it loops over a new list.
17:36:59 <dpiponi> But, Saizan, it is kinda related to scope
17:38:09 <Excedrin> so, on x86-64, does it fetch 64bits at a time always?
17:38:33 <koala_man> no clue.
17:38:40 <notadev> Excedrin: for what?
17:38:47 <Excedrin> for all memory accesses
17:39:36 <notadev> no
17:39:44 <notadev> the CPU doesn't at least
17:48:09 <sorear> what's this mean: Pass/Parse.y: 166: multiple use of `"!"'
17:48:14 <sorear> happy
17:48:27 <notadev> hi sorear
17:54:03 <lispy> oh, i just had a thought for a (semipointless) lambdabot plugin
17:54:13 <mauke> @spl?
17:54:13 <notadev> hehe
17:54:13 <lambdabot> Maybe you meant: pl spell
17:54:32 <lispy> it would be @recommend-channel, it does a union of all the channles people in #haskell are in, and picks one at random
17:54:38 <notadev> lol
17:54:49 <notadev> that would take a lot of net traffic tho
17:55:10 <lispy> yeah
17:55:21 <lispy> ?users
17:55:21 <lambdabot> Maximum users seen in #haskell: 334, currently: 302 (90.4%), active: 12 (4.0%)
17:55:34 <lispy> 300 queries for channels
17:55:42 <oerjan> it could pick a nick randomly first
17:56:08 <lispy> yeah, although that could have a detrimental affect on the distribution
17:56:56 <sorear> every 5s, /whois somebody; then use the (slightly out of date) cached info
17:57:24 <notadev> ew
17:57:43 <notadev> what about @recommend sorear ?
17:57:55 <lispy> how about, when people part/join lambdabot finds out what channels they are in, and then maintains a list that way
17:58:01 <notadev> hmm i guess
17:58:05 <notadev> a lot of mem tho
17:58:25 <lispy> stored as a set it would be bounded by the number of channels on freenode :)
17:58:28 <notadev> and same amount of net traffic
17:58:30 <notadev> lol
17:58:44 <notadev> in one dimension yeah ;)
17:58:58 <lispy> less traffic potentially
17:59:05 <notadev> than initial yes
17:59:19 <lispy> people like me idle for a long time so we'd only be queried once
17:59:24 <notadev> lambdabot is watching YOU ;)
17:59:44 <notadev> it's bad enough that one logs everything.. :)
18:00:06 <lispy> i was thinking of it like amazon's recommended items
18:00:20 <lispy> "If you like #haskell you might also like #math."
18:00:46 <lispy> anyway, pointless plugin...
18:00:47 <lispy> :)
18:01:01 <mauke> @pl plugin
18:01:01 <lambdabot> plugin
18:15:50 <Saizan> wow, test1 40% GC time, test2 2%
18:16:37 * Saizan wishes he could make sense of the core
18:20:47 <Saizan> dpiponi: do a <- [...]; b <- [...]; return b desugars to [...] >>= (\a -> [...] >>= (\b -> return b)) right?
18:21:21 <cdsmith> I got there by mistake, but www.happs.com is sorta cool actually.
18:21:26 <dpiponi> Yes.
18:23:20 <dpiponi> The RHS of the first >>= is itself a function that is built from a >>=. If you have a long do-block the right hand side of the >>='s gets pretty complicated.In test2 the RHS of each >>= is a simple function.
18:24:01 <dolio> @undo do { a <- [1..5] ; b <- [6..10] ; return b }
18:24:02 <lambdabot> [1 .. 5] >>= \ a -> [6 .. 10] >>= \ b -> return b
18:24:07 <Saizan> dpiponi: ah so no wonder that changing the former to [...] >>= (\a -> [...]) >>= (\b -> return b) in test1 gives test2 performance
18:25:07 <dpiponi> Ah, wait. You got test2 performance from test1 with something trivial?
18:25:15 <Saizan> yup
18:25:34 <dpiponi> Unfortunately that won't apply to all monads.
18:25:57 <kpreid> if you consider infinite series of >> (or >>= as well I suppose) you can find cases where either left- or right-association is *necessary*, not just faster
18:26:41 <Saizan> well this is kind of a precedence issue, if the lambda closes before >>= you get better results :)
18:26:45 <kpreid> (e.g. left-association for execState; right-association for execWriter)
18:29:31 <dpiponi> Saizan: But that little thing you did to test1 also applies to test2. So there's still a performance issue.
18:31:30 <dpiponi> kpreid: I'll have to think about that. I guess it means that you can't expect the compiler to optimise using the third monad law unless you tell it whether you'd prefer left or right associativity.
18:31:38 <Saizan> applies in which sense? i thought test2 was ((>>=) ((>>=) ... ((>>=) [1..10] (\a -> ...)) (\b -> ...)) ...)
18:32:12 <hpaste>  dpiponi annotated "Monad third law and performance" with "(no title)" at http://hpaste.org/376#a1
18:32:17 <dpiponi> See new version
18:32:43 <dpiponi> (Did I interpret you right?)
18:32:52 <kpreid> dpiponi: that sounds right
18:32:53 <kpreid> (re needing a preference)
18:33:25 <kpreid> it's essentially like having the compiler pick foldr or foldl' for you
18:33:31 <dpiponi> Saizan: I see I didn't quite get that right.
18:33:46 <kpreid> (er, I'm not sure about that analogy...)
18:34:36 <dpiponi> kpreid: Yeah, I guess it is. The difference is that foldl/foldr don't come with a notation that leads you to pick one or the other when it may turn out to be less efficient.
18:34:39 <Saizan> dpiponi: yup, that test1 is still slow
18:35:28 <hpaste>  Saizan annotated "Monad third law and performance" with "this is what i meant" at http://hpaste.org/376#a2
18:37:13 <dpiponi> Saizan: That's just the normal desugaring of the original test1 isn't it?
18:37:52 <Saizan> dpiponi: no, the normal one closes all the lambdas at the end
18:37:57 <dpiponi> Saizan: Oh no, that's my test2.
18:38:08 <dpiponi> Saizan: You're doing the same thing as I did.
18:38:34 <sorear> re.
18:39:00 <Saizan> dpiponi: oh, ok, sorry, i'm just being deceived by do-notation :)
18:40:25 <dpiponi> Anyway, it's worth bearing in mind when doing logic programming in Haskell.
18:40:42 <sorear> dpiponi: you jump from semiring to monad very quickly, as if you'd covered it before .... I'ven't been paying enough attention, where should I start?
18:41:31 <dpiponi> sorear: I've already come to the conclusion that I need to write a post on semirings and monads.
18:42:09 <sorear> I thought I saw something about it a few months ago...
18:42:32 <dpiponi> I've already mentioned that vector spaces form a monad and this is a generalisation. But I ought to make it explicit because it makes a nice bridge between the algebraic and computational views of monads
18:42:56 <dpiponi> BTW The semiring I'm using is known as the "tropical semiring" so I'm staking my claim for the "tropical monad" :-)
18:43:56 <sorear> huh.  why do I have moire' banding on my lcd monitor?
19:02:29 <ddarius> Nothing like Ctrl-Alt-Backspace to regain responsiveness
19:04:01 <Saizan> apart from when it doesn't work
19:21:36 <Mayreel> I always press Control-alt-backspace accidentally when trying to find another keyboard shortcut
19:21:56 <Mayreel> is it control-backspace? no. alt-backspac? no. control-alt-backspace? argh
19:26:46 <sorear> Mayreel: you can rebind KillServer to a different key combination
19:26:54 <aixo> hello, i'm new here
19:26:57 <sorear> using the XKB system
19:27:01 <Cale> aixo: hello
19:27:10 <Cale> aixo: Have questions about Haskell?
19:27:16 <sorear> or failing the presence of xkb, just put Option "DontZap" in your xorg.conf
19:27:23 <aixo> i don't know what is haskell
19:27:33 <sorear> aixo: it's a programming language.
19:27:34 <Cale> It's a functional programming language.
19:27:37 <aixo> i came from ##c channel
19:27:57 <aixo> i'm asking about one problem, and i came here
19:28:02 <Cale> hmm
19:28:05 <aixo> ok, now i know
19:28:29 <aixo> anyway, can i ask my doubt here?
19:28:52 <sorear> sure!
19:28:57 <sorear> we like questions
19:29:17 <chessguy> (the answer's 42 though)
19:29:31 <notadev> hehe
19:29:58 <aixo> take the situation, you have 2 sorted sets, you join them
19:30:11 <aixo> and the algorithm has to find the median
19:30:44 <aixo> i need two algorithms DivideConquer and the brute power (Classic)
19:31:06 <ihope> Are the sizes of the sets known?
19:31:13 <aixo> yes
19:32:10 <aixo> i think that i have a idea for the classic algorithm
19:32:23 <aixo> merge(A, B)
19:32:53 <cdsmith> aixo: http://courses.csail.mit.edu/6.897/spring03/scribe_notes/L16/lecture16.pdf has the divide-and-conquer alg.
19:32:55 <lambdabot> http://tinyurl.com/28gc8s
19:33:02 <sorear> can't you just merge and pick the middle?
19:33:19 <ihope> Well, if whatever language you're doing this in has laziness... yes, you can merge and pick the middle.
19:33:31 <ihope> Otherwise, you're wasting time by merging stuff you won't use.
19:33:33 * notadev thinks it's C
19:34:09 <sorear> hmm, I just thought of a way to do it in O(log^2(N))
19:34:14 <aixo> uff, i think that i will have a long nigth
19:34:29 <aixo> one think is say one or two comments in a chat
19:34:45 <aixo> but have to read this...
19:34:50 <notadev> lmao
19:34:51 <aixo> anyway thanks
19:35:07 <notadev> thank YOU aixo :)
19:35:11 <aixo> thanks very much i didn't find nothing, even in google
19:35:34 <ihope> sorear: what's that?
19:35:36 <notadev> well ihope seemed to have an idea
19:35:44 <notadev> eep
19:35:52 <ihope> I did have an idea. :-)
19:36:00 <notadev> heh :-)
19:36:10 <cdsmith> aixo: ignore me; I should have read more context.
19:36:22 <ihope> Look at the smallest element of each set and discard whichever of the two is smaller. Repeat for about a number of times equal to half the sum of the sets' lengths.
19:36:39 <ihope> That's O(n) with respect to the lengths of the sets, isn't it?
19:36:45 <ddarius> "sorted set" ...
19:36:48 <notadev> yeah
19:36:53 <notadev> true
19:37:10 <ihope> Indeed, it could be done more efficiently.
19:37:17 <notadev> how?
19:37:38 <ihope> Well, it sort of depends on how the sets are structured and accessed.
19:37:58 <notadev> hmm ok
19:38:02 <ihope> It's harder to get the last element of a list than it is to get the rightmost element of a red-black tree.
19:38:02 <sorear> he said sorted
19:38:25 <ihope> (By list, I mean a linked list.)
19:38:29 <aixo> you follows...
19:38:32 <cdsmith> Hmm.  I think you could get O(log n) by performing two simultaneous binary searches... assuming O(1) indexed element access.
19:38:35 <notadev> well it's all algorithms, i'm sure it won't hurt to listen for a bit..
19:39:44 <aixo> i forget it, you can't use any other data type but vectors or lists
19:40:11 <ihope> Lists being linked lists? What are vectors?
19:40:21 <cdsmith> aixo: C+ stl vectors?
19:40:26 <cdsmith> *C++
19:40:31 <aixo> or arrays
19:40:37 <cdsmith> aixo: okay
19:40:48 <oerjan> random access at any rate.
19:40:57 <notadev> aixo: what about doubly-linked list?
19:40:58 <cdsmith> ihope: so vectors are O(1) access and O(n) insert
19:41:10 <ddarius> Has Haskell become the catch-all for programming questions?
19:41:18 <notadev> hehe
19:41:19 <ddarius> s/Haskell/#haskell
19:41:19 <aixo> no affect
19:41:20 <Excedrin> sure, why not?
19:41:33 <ddarius> What about skip lists?
19:41:36 <aixo> i need the divide-conque version
19:41:51 <aixo> i have the brute force version in mind
19:42:09 <notadev> man look it up on wikipedia fgs
19:42:26 <aixo> well, hold on
19:42:33 <Excedrin> what's fgs
19:42:40 <Excedrin> oh, got it
19:42:54 <notadev> :-)
19:44:55 <dolio> ddarius: haskell-cafe seems to be getting its share, too. :)
19:48:32 <aixo> i got it
19:48:41 <aixo> it's a simply binary search
19:48:48 <aixo> i saw it
19:49:46 <aixo> take at the left the set with the less value of the two sets
19:50:50 <aixo> try to find the less value of the other set
19:50:58 <aixo> it gives you a position
19:51:26 <notadev> s/less/smallest/ ?
19:51:38 <aixo> if the position is the end, means that the median is the greater value of the initial set
19:52:43 <aixo> define the binary search between that position and the end of the set, it gives you the median
19:54:07 <sorear> Hah, I found my happy problem from earlier.
19:54:13 <sorear>        "!"          { K.Tilde }
19:57:08 * ihope chants to himself: S. O'Rear. S. O'Rear. S. O'Rear. Not a Spanish verb.
19:57:49 <sorear> I'm a NOUN
19:57:59 <ihope> Indeed!
19:58:06 <aixo> O'Rear = orear = "put a thing to take the air"
19:58:21 <ihope> ...Put a thing to take the air?
19:58:45 <aixo> like dry
19:58:47 <dolio> Maybe you're a gerund.
19:59:20 <ihope> dolio: no, the gerund form is "soreando".
19:59:34 <aixo> yes, of course
19:59:40 <ihope> Stefan O'Reando.
19:59:41 <dolio> :) Techincalities.
19:59:47 <ihope> I like that :-)
20:00:22 <ihope> Anyway, in BF, a program consists of a series of--wait, did I just answer my own question?
20:01:26 <ihope> Ah well, I'll ask it anyway. In BF, a program consists of a series of instructions. This includes looping instructions: a closing bracket sometimes jumps to the corresponding open bracket, and an open bracket sometimes jumps to the corresponding closed bracket. This is all brackets do.
20:03:09 <ihope> For any two pairs of brackets, either one pair is inside the other or they are completely outside of each other. A program will be traversed by going through the list of instructions, and occasionally jumping between matching pairs of brackets.
20:03:45 <tessier> Do you ever run into a situation in haskell where you have to recurse over something but cannot do it using tail recursion and your algorithm ends up being O(n) in space?
20:03:54 <tessier> Or is it always possible to arrange it to be tail recursive?
20:04:02 <sorear> tessier: Mu.
20:04:31 <ihope> What's the best sort of data structure to hold a program, then, given that it will be read this way and only "written" once?
20:04:31 <sorear> tessier: You can make everything tail recursive - google CPS Transform.  But that buys you nothing.
20:04:33 <tessier> Also, is straight iteration impossible with haskell? If it is it seems like you would be required to always make things tail recursive.
20:04:41 <tessier> sorear: Mu?
20:04:57 <sorear> straight?
20:05:01 <ihope> Straight iteration is easy enough to simulate.
20:05:01 <dcoutts__> tail recursion is iteration
20:05:12 <ihope> ...what dcoutts said.
20:05:13 <allbery_b> iteration?  map / mapM / forM?
20:05:33 <ihope> (No modifications are necessary for my data structure, in other words.)
20:05:33 <sorear> ihope: what kind of implementation are you doing?
20:05:55 <ihope> sorear: oh, it's for a hypothetical BF interpreter.
20:05:59 <sorear> ihope: for an interpreter I'd use a graph
20:06:05 <oerjan> ihope: i have the following in a file: data Command = Plus | Minus | Left | Right | In | Out | Debug | Loop [Command] | Unmatched [Command] | Ignored String
20:06:18 <dcoutts> note that whether a monadic loop is tail recursive depends on the implementation of >>= for the type in question
20:06:19 <tessier> dcoutts: I know tail recursion is iteration in that iteration and recursion are computationally equivalent. But in a language like haskell where you generally don't want to or cannot iterate I am wondering if there are situations where tail recursion is not possible.
20:06:41 <dcoutts> and whether or not that gets inlined
20:06:51 <ihope> <sorear> tessier: You can make everything tail recursive - google CPS Transform. But that buys you nothing.
20:07:14 <ihope> oerjan: and having loops as lists like that does seem to be a good way of doing things.
20:07:17 <sorear> ihope: data Insn = Inc Insn | Dec Insn | Left Insn | Right Insn | In Insn | Out Insn | Branch Insn Insn
20:07:25 <tessier> ihope: Why does it buy you nothing?
20:07:33 <dcoutts> tessier: there are certainly cases where you can make something tail recursive but it's actually better not to, but to make it lazy instead
20:07:35 <sorear> ihope: or better yet, type Insn = IO ()
20:07:49 <ihope> tessier: ask sorear.
20:07:52 <ihope> sorear: :-)
20:08:28 <sorear> tessier: CPS creates huge accumulators that are just like stacks with the added insult of needing to be garbage collected.
20:08:45 <tessier> I see.
20:09:09 <sorear> tessier: Stackfully recursive code is faster because it just decrements pointers to free, not causing GC to run
20:09:25 <ddarius> As sorear said, you can get rid of all non-tail recursion via CPS but that doesn't buy you anything.
20:09:31 <tessier> Yes, I see how that would be much faster.
20:09:40 <edwardk> sorear: until you blow out your stack ;)
20:09:44 <tessier> Are you trading cpu time for space in that case?
20:09:46 <tessier> Exactly.
20:09:54 <tessier> Your options might be run longer or crash the stack.
20:09:59 <sorear> tessier: the space usage is the same
20:10:10 <sorear> tessier: only seriously broken systems impose a stack limit
20:10:19 <tessier> sorear: My system only has 1G of RAM. :)
20:10:19 <xpika> is there any function which evaluates haskell code?
20:10:27 <oerjan> ihope: yes, like sorear implies, in Haskell it may be possible to build the resulting program directly
20:10:34 <sorear> tessier: 1G of stack is no worse than 1G of heap
20:10:42 <xpika> i would like to write an alternative to GHCI
20:10:48 <tessier> sorear: The heap has to be gc'd no?
20:10:55 <ddarius> tessier: CPSing a function just turns stack space into heap space.
20:10:55 <tessier> hmmm...
20:10:55 <allbery_b> xpika: hs-plugins
20:11:01 <tessier> I see, I would run out of memory either way. Gotcha.
20:11:03 <int-e> xpika: ghc-api, hs-plugins. if you want a ghc-api example, look at ghci ;)
20:11:06 <sorear> tessier: exactly, which is why stacks are faster.
20:11:16 <ddarius> sorear: Not necessarily.
20:11:18 <allbery_b> yeh, and ghc-api
20:11:32 <sorear> ddarius: do tell?
20:11:51 * sorear would love to understand the prejudice people have against middle recursion
20:12:26 <int-e> sorear: it blows C stacks. But C compilers can't even be trusted to optimize tail calls so that doesn't fully explain it
20:12:40 <xpika> allbery_b: ill try that
20:12:59 <allbery_b> if you want to write a ghci replacement, I'd say ghc-api is the place to start
20:13:04 <sorear> int-e: it doesn't blow the stack unless you have more than SWAP of stuff to do :)
20:13:15 <allbery_b> since, as int-e mentioned, ghci is itself based on ghc-api
20:13:25 <sorear> int-e: I'll go along with tailrec for cases where the accumulator is bounded (fac)
20:13:34 <allbery_b> so you have all the tools plus a working example
20:13:40 <sorear> but I fail to see why people like writing reverse tailrecursively
20:14:23 <xpika> ok i found this on the ghc api
20:14:29 <xpika> http://haskell.org/haskellwiki/GHC/As_a_library
20:14:30 <lambdabot> Title: GHC/As a library - HaskellWiki
20:14:34 <xpika> ill try that instead
20:15:36 <allbery_b> (also, future hs-plugins is supposed to use ghc-api to avoid some of the compatibility issues it currently has, suckh as having to understand every ghc version's .hi file format)
20:15:51 <ddarius> http://citeseer.ist.psu.edu/appel87garbage.html though in the real world this particular argument doesn't really work out.
20:15:53 <lambdabot> Title: Garbage Collection Can Be Faster Than Stack Allocation - Appel (ResearchIndex)
20:16:06 <int-e> sorear: and if C compilers do optimize tail recursion they don't get it right in all cases.  void t() { t(); }  terminates (without stack overflow) when compiled with gcc-4.1.2 -O2 ;-)
20:16:28 <sorear> int-e: I'm not talking about tail recursion here.
20:16:32 <xpika> allbery_b: with package ghc can you import modules such as control.monad on the fly
20:16:38 <Svrog> can type constraints be placed on individual constructors in a GADT?
20:16:50 <int-e> sorear: well, what's the alternative to middle recursion that you had in mind then?
20:16:54 <xpika> allbery_b: or is that a case where i need hs-plugings specifically
20:16:54 <sorear> int-e: I'm talking about the folk wisdom that accumulating parameters are faster than stacks, period, end of discussion
20:17:14 <sorear> int-e: er, I'm not talking about tail vs. iteration
20:17:22 <allbery_b> I'd think you could since ghci can do it (:m +...) and ghci uses ghc-api to do it
20:17:24 <Svrog> or rather do they do anything useful - they don't seem to work for me, i have to add the same constraint to functions that work on the type
20:17:34 <xpika> allbery_b: thanks :)
20:17:38 <hpaste>  Svrog pasted "GADT problem" at http://hpaste.org/377
20:17:58 * allbery_b hasn't actually used either hs-plugins or ghgc-api, being not quite at that level of haskery quite yet :>
20:18:16 <ddarius> sorear: e.g. that foldl' sum is faster than foldr sum ?
20:18:22 <xpika> @hoogle runStmt
20:18:22 <lambdabot> No matches found
20:18:46 <sorear> ddarius: 20:12 < sorear> int-e: I'll go along with tailrec for cases where the accumulator is bounded (fac)
20:19:02 <dolio> Svrog: Are you using GHC 6.7?
20:19:04 <sorear> ddarius: it's more stuff like strict map that I find alarming when accumulatored
20:19:14 <Svrog> no - 6.6 or 6.6.1 - ill check
20:19:19 <kfish> @hoogle runSumthin'
20:19:20 <lambdabot> No matches found
20:19:23 <Svrog> 6.6
20:19:30 <Svrog> does this work in 6.7?
20:19:30 <dolio> Svrog: That's why it isn't packaging the contexts.
20:19:34 <Svrog> ah
20:19:55 <Svrog> so if i build 6.7 from source it should work?
20:20:16 <dolio> Svrog: Yeah.
20:20:20 <Svrog> great :)
20:20:22 <Svrog> thanks :)
20:20:26 <dolio> No problem.
20:20:39 <cdsmith> That's cool.  I didn't know 6.7 did that, but it's annoyed me on several occasions.
20:21:12 <ddarius> Well, in the particular case of reverse, it makes sense...
20:21:25 <oerjan> sorear: with reverse isn't it the case that the accumulating parameter is part of the final result, so it would be allocated anyhow, while you can then drop the stack frames?
20:21:54 <sorear> uhm, yeah
20:25:12 <int-e> I generally try to produce the outermost constructor as soon as possible, and use tail recursion (with strict accumulators where approrpriate) otherwise.
20:27:59 <stepcut> is there a unicode symbol that would be a good representation for >>=
20:28:44 <oerjan> isn't >>= sort of an ascii representation of a Kleisli star?
20:28:55 <stepcut> beats me
20:29:24 <oerjan> although it doesn't mean exactly the same, if i recall correctly.
20:29:29 <stepcut> I wonder if lhs2tex does anything special with it
20:29:58 <ddarius> :t (=<<)
20:30:04 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> m a -> m b
20:30:13 <treble> !paste
20:30:13 <hpaste> Haskell paste bin: http://hpaste.org/
20:30:39 <ddarius> It's not uncommon for (f =<<) to be represented by f^*
20:31:01 <oerjan> stepcut: googling for kleisli star shows up a symbol in the fifth hit, although my browser doesn't show it properly.
20:32:23 <sorear> stepcut: lhs2TeX does something with >>=, but not a unicode symbol
20:32:43 <oerjan> data Command = Plus | Minus | Left | Right | In | Out | Debug | Loop [Command] | Unmatched [Command] | Ignored String
20:32:47 <oerjan> oops
20:32:50 <int-e> â² â  â¸ (just kidding)
20:33:37 <sorear> Gah.
20:33:47 <sorear> data Foo = Bar Int
20:33:55 <sorear> data Foo = Bar Int `Baz` Bar Int
20:34:35 * sorear just *loves* haskell's syntax quirks...
20:34:43 <oerjan> data Bar a = a `Foo` Int ?
20:34:51 <sorear> that's 7 reduce-reduce conflicts
20:35:08 <int-e> isn't that a ghc extension?
20:35:13 <sorear> nope.
20:35:21 <int-e> evil.
20:35:26 <sorear>    constr         ->  con [!] atype[1] ... [!] atype[k]                (arity con = k, k>=0)
20:35:30 <sorear>                   |   (btype | ! atype) conop (btype | ! atype)        (infix conop)
20:35:49 <sorear> conop          ->  consym | `conid `                    (constructor operator)
20:36:33 <int-e> ah, but this is: type a `X` b = (a, b)
20:36:44 <sorear> this "parsing haskell" business is harder than it sounds...
20:37:00 <sorear> int-e: yes, infix type constructors are ghc only. (thank goodness)
20:37:01 <oerjan> thanks for breaking my illusion that there is a nice LR(1) language lurking inside Haskell somewhere :)
20:38:57 <sorear> haskell-src is 3265 loc :(
20:39:29 <allbery_b> â» ?
20:39:43 <oerjan> maybe this was why infix type constructors were left out of H98...
20:40:07 <dmead> ;/
20:40:35 <sproingie> â½
20:40:52 <allbery_b> possible unicode for >>=
20:41:10 <int-e> allbery_b: there are too many arrows in unicode. :/
20:41:44 <allbery_b> it's even 3 bytes!
20:42:06 <ddarius> Just use >>=
20:42:15 <dolio> Doesn't it just smash the >>= closer together so they look like one symbol?
20:42:18 <dolio> Same with ++?
20:42:31 <dolio> At least, I've seen that in various papers.
20:43:56 <allbery_b> actually what I wanted was = with a chevron in it
20:44:14 <allbery_b> too many arrows but never the right one :)
20:53:20 <stepcut> ddarius: sadly, in my case, using >>= is harder than using a unicode symbol :)
20:57:59 <stepcut> â  is close
21:00:48 <jbalint> whats "pl form"
21:01:11 <sorear> pointless I imaging
21:01:14 <stepcut> jbalint: in what context? pointless form perhaps?
21:01:37 <jbalint> yeah, makes sense. thanks
21:01:48 <sorear> @pl \a b c d e f g h i j k -> k j i d a e h e a j c b
21:01:51 <lambdabot> ((((const .) .) .) .) . ((((const .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip . (flip .) .
21:01:51 <lambdabot> ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . ap (
21:01:51 <lambdabot> flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip (flip . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .)
21:01:51 <lambdabot>  .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id))))
21:01:54 <lambdabot> id) id
21:01:56 <lambdabot> optimization suspended, use @pl-resume to continue.
21:02:03 <sorear> @pl-resume
21:02:09 <lambdabot> ((((const .) .) .) .) . ((((const .) .) .) .) . flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . ((((((flip .) .) .) .) .) .) . flip . (flip .) .
21:02:10 <lambdabot> ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((ap .) .) .) .) . (((((flip .) .) .) .) .) . join (
21:02:10 <lambdabot> flip . (flip .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .) .) .) .) . flip flip id . (ap .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (((((flip .) .)
21:02:10 <lambdabot> .) .) .) . ((flip .) .) . (((flip .) .) .) . ((((flip .) .) .) .) . (flip .) . ((flip .) .) . (((flip .) .) .) . flip (flip . (flip .) . ((flip .) .) . flip (flip . (flip .) . flip (flip . flip id)))
21:02:12 <lambdabot> )
21:02:14 <lambdabot> optimization suspended, use @pl-resume to continue.
21:02:18 <sorear> @pl-resume
21:02:22 * sorear stops.
21:03:00 <sproingie> stop flipping out
21:03:13 <dons> sorear--
21:03:21 <stepcut> dons: haha
21:03:38 <dons> so, who's going to implement a zipper-like interface to directory parsing?
21:03:43 <dons> i'd love to navigate around the filesystem, inside haskell, using a filesystem zipper
21:03:56 <dcoutts> I like the lazy dir tree style
21:04:09 <dons> dir trees are good too.
21:04:17 <dcoutts> would a filesystem be in IO ?
21:04:23 <sorear> dons: it would have to be Oleg, nobody else understands the case of zipping with concurrent modification
21:04:34 <dcoutts> doesn't bash and the cd command give you a filesystem zipper?
21:04:39 <dons> dcoutts: i think it would be some kind of monad that flushes on the end of a runFS ?
21:04:40 <sorear> or would we lock the OS while the zipper is open?
21:04:55 <dons> that'd be good :-)
21:05:09 <dcoutts> dons: hmm, so it doesn't make changes 'til the end?
21:05:21 <dons> i think it would have to be in IO, as sorear says
21:05:32 <dcoutts> that sounds hard if there have been changes between reads and writes
21:05:54 <dcoutts> changes by external agents
21:06:05 <dons> but, you could read a dir, and get it as a zipper/lazy tree, that you move up and down in, causing reads
21:06:22 <dons> but all the concurrency is not very nice, is it.
21:06:29 <dcoutts> in IO or not?
21:07:07 <dcoutts> since we already have one in IO, that's what changeDirectory and readFile etc do, no?
21:07:23 <dcoutts> is that not a fs zipper in the IO monad ?
21:07:25 <sorear> dcoutts: one
21:07:31 <dcoutts> ok, sure
21:07:33 <sorear> dcoutts: we want multiple fs zippers
21:07:37 <dcoutts> so we could have N of them
21:07:47 <dcoutts> and make it less posix fs
21:07:56 <dcoutts> so that's a VFS api
21:08:16 <lambdabot> (((((const . const) .) .) .) .) . flip . ((flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .)) .) . flip . ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip
21:08:16 <lambdabot> id . ((flip . ((flip . ((flip . (liftM2 flip .)) .)) .)) .) . (flip =<< ((flip . ((flip . ((flip . ((flip . (flip .)) .)) .)) .)) .) . flip flip id . ((ap . ((flip . ((flip . ((flip . (flip .)) .)) .
21:08:16 <lambdabot> ) . flip . ((flip . (flip .)) .)) .) . flip . ((flip . (flip .)) .)) .) . flip (flip . ((flip . (flip .)) .) . flip (flip . (flip .) . flip (flip . flip id))))
21:08:36 <cdsmith> Huh.  That took lambdabot a while.
21:08:44 <dons> yeah, weird.
21:08:55 <sorear> cdsmith: Lambdabot puts a 15 second timeout on all threads.
21:09:23 <cdsmith> sorear: or, in the twilight zone, 6 minutes?
21:09:25 * sorear wonders how distorted spacetime is in the vicinity of pill01
21:09:49 <dcoutts> it's pretty distorted, it's .au of course
21:09:51 <dons> fairly distorted
21:10:09 <dons> there's a hugh computation black hole produced by serenity near by
21:10:15 <dons> that distorts the flip flops
21:10:44 <dcoutts> how is serenity doing these days? getting more than 12 hours uptime?
21:10:55 <dons> yeah, i think its sorted now
21:11:13 <dcoutts> great
21:11:47 <ed1t> @src minimum
21:11:47 <lambdabot> minimum [] = undefined
21:11:47 <lambdabot> minimum xs = foldl1 min xs
21:11:48 <vincenz> dcoutts/dons: happen to see my code
21:11:56 <ed1t> @src min
21:11:56 <lambdabot> min x y = if x <= y then x else y
21:11:57 <vincenz> any reason you think it's not working/could be fixed?
21:11:58 <dcoutts> vincenz: what code was that?
21:12:04 <vincenz> the generalized matrix mult
21:12:40 <vincenz> dons: oh, and I posted a minicompiler online for noobs
21:12:45 <vincenz> the one I presented during my talk
21:12:50 <vincenz> well, didn't get to... cause we ran out of time
21:25:29 <stepcut> â¤
21:25:48 <stepcut> too bad that symbol is not in the font I use in emacs :(
21:26:10 <stepcut> 291C on this page: http://www.unicode.org/charts/PDF/U2900.pdf
21:26:20 * stepcut goes out for a snack
21:32:50 <dons> Igloo: around?
21:33:05 <vincenz> dons: think I should post another one
21:33:13 <vincenz> dons: with a slightly more complicataed compiler?
21:33:38 <dons> compilers are good.
21:33:53 <dons> you could write a series buliding up to a reasonabel mini compiler
21:33:59 * vincenz nods
21:34:03 <vincenz> the one I wrote is very simplistic
21:34:08 <vincenz> arithmetic expressions -> stack machine
21:34:09 <dons> i always thought ruby could be done as a demo of haskell
21:34:17 <vincenz> ruby has some nasty aspects
21:34:30 <dons> fp is easier
21:34:34 <vincenz> (to model cleanly without too many side-conditions)
21:34:48 <vincenz> you want a language that doesn't require a lot of special cases
21:34:51 <vincenz> so the code remains clear
21:34:57 <dons> we use miniML as the language in our compiler course
21:35:05 <vincenz> I doubt the semantics of ruby are ... very orthogonal
21:35:11 <dons> www.cse.unsw.edu.au/~cs3161 fwiw
21:35:11 <vincenz> I wrote a miniml compiler :)
21:35:30 <dons> do the type checker as a tutorial?
21:35:35 <dons> that'd be useful to some.
21:35:39 <vincenz> true
21:35:48 <vincenz> the typechecker is actually a rather clean part of it
21:35:50 <vincenz> the nasty part was modules
21:36:48 <vincenz> been wanting to develop a new language tho
21:36:51 <vincenz> maybe I could do that :)
21:36:59 <vincenz> would give me an excuse to do it + write
21:37:04 <vincenz> the two would leverage each other
22:15:24 <jfredett> I love when professors/teachers have grading schemes involving the min/max functions
22:15:41 <jfredett> I had one professor who managed to fit an integral in there
22:17:05 <jfredett> its how he calculated the average grade, 3 quizzes a week for 7 weeks, best fit curve, to those 21 points, integrate to get the area and then divide by something... it was the most obtuse thing I've ever seen.
22:18:40 <Korollary> If somebody who reads your GPA doesn't know exactly what it means, does it matter how he calculates it? It's all about doing the defensible thing.
22:19:54 <jfredett> I dont know -- it was an interesting system, for certain.
22:20:26 <jfredett> All I know is I got an A in the class. I don't particularly care about the details.
22:20:39 <jfredett> Calc was trivial...
22:20:41 <jfredett> :/
22:21:14 <Korollary> Numb3rs sux
22:21:25 <jfredett> The Show? or the thing
22:21:30 <Korollary> the show of course
22:21:37 <jfredett> i agree that numbers suck, I prefer letters.
22:21:41 <jfredett> I rather like Numb3rs
22:21:52 <Korollary> The characters are uninteresting
22:21:58 <jfredett> meh
22:22:05 <jfredett> its a nice concept- leastways
22:22:20 <jfredett> its a tough sell regardless
22:22:34 <jfredett> to geeky for non-geeks, not geeky enough for geeks
22:22:40 <Korollary> It wouldn't be if they could make the characters more interesting
22:22:47 <jfredett> i dunno
22:22:51 <jfredett> i like it
22:23:05 <Korollary> I watch House MD. I get none of the medicine. Way over my head.
22:23:20 <jfredett> well-- thats house-- though
22:23:30 <jfredett> and i think part of it is that you _dont_ get the medicine
22:23:40 <jfredett> my girlfriend is premed, and she cant stand house
22:23:43 <Korollary> Not necessarily.
22:23:45 <jfredett> because she gets the medicine
22:24:08 <jfredett> she thinks the characters are unreallistic and silly
22:24:25 <jfredett> it aids in your suspension of disbelief, methinks.
22:24:39 <jfredett> i dunno- i make her watch it with me to explain all the things going on
22:25:23 <vincenz> thats like hackers looking at their code in 3d
22:25:28 <vincenz> or typing on a keyboard
22:25:30 <vincenz> without pressing space
22:25:38 <sjanssen> well++ house++
22:25:41 <vincenz> or flying through a directory system
22:25:47 <jfredett> yah-- i always wondered how that worked...
22:25:50 <sjanssen> yah++
22:25:51 <jfredett> yah++
22:25:51 <vincenz> or seeing viruses as little bunnies
22:25:55 <sjanssen> :)
22:26:14 <vincenz> or having smoke come out of a computer when it crashes
22:26:17 <jfredett> is Isabelle (the theorem prover) written in ML or Haskell?
22:26:17 <vincenz> or ...
22:26:18 <vincenz> or ...
22:26:23 <Korollary> Isabell is in ML
22:26:38 <Korollary> so is Twelf iirc
22:26:38 <sorear> It would be a lot easier to follow if they actually bothered with reearch.
22:26:48 <Korollary> Coq is in ocaml
22:26:53 <vincenz> Eleven is in Ruby
22:26:57 <Korollary> Cayenne is in Haskell iirc
22:27:00 <vincenz> or is that Elfen
22:27:11 <jfredett> 24's use of computers makes my brain want to explode
22:27:19 <jfredett> "Pipe that disk over to my monitor"
22:27:24 * jfredett vomits
22:27:31 <Korollary> that's plumbing lingo
22:28:02 <vincenz> heh, what about that movie where the hacker had to hack 512bit RSA in 2 minutes with a blowjob
22:28:02 <sorear> The people behind Numb3rs want me to beleive combinatory logic is a branch of geometry.
22:28:19 <jfredett> its like they started to do research, but they hired half a dozen weed-smoking ITT Tech Students
22:28:25 <vincenz> I always love it how hackers just start typing when they're in some gui, and pronto, they're writing code 'into the system'
22:28:25 <jfredett> to do the research
22:28:38 <jfredett> with a what?
22:28:53 <vincenz> oral stimulation
22:28:58 <jfredett> i know that-
22:29:04 <jfredett> i was wondering if you mistyped it
22:29:06 <vincenz> it's a famous movie
22:29:10 <vincenz> with hale berry
22:29:11 <jfredett> what movie is it?
22:29:16 <jfredett> swordfish?
22:29:17 <Korollary> The weird thing is that nowadays with heavy penetration of computers in homes, everybody knows what an OS/GUI looks like. They don't need to make up fancy bizarre GUIs to make it look computer-y.
22:29:17 <vincenz> and ... what's the guy's name again
22:29:18 <vincenz> yeah
22:29:34 <vincenz> Korollary: microsoft?
22:29:34 <vincenz> :P
22:29:45 <Korollary> Anything
22:29:48 <jfredett> I always loved how movie-hackers can read 1000's of lines of Hex per second
22:29:53 <jfredett> and understand every bit
22:29:54 <jfredett> no comments
22:30:02 <Korollary> real men don't comment.
22:30:08 <vincenz> Korollary: i know, but then a hacker sits down, and suddenly he types text, and you have this black area in front of your gui where that code is being 'injected into the kernel'
22:30:13 <jfredett> people would always ask me after seeing those scenes, "Can you do that? Joe"
22:30:17 <sorear> jfredett: it's pretty easy when you've read the script already?
22:30:18 <vincenz> Korollary: real men only have two keys on their keyboard: 0 and 1
22:30:31 <sorear> s/?/.
22:30:34 <jfredett> and I'd be like, "I don't even need to read it, I just know.."
22:30:41 <vincenz> sorear: learn regexp
22:30:45 <vincenz> s/\?/.
22:31:19 <jfredett> I write my code in CPL...
22:31:54 <sorear> which one/
22:32:15 <sorear> there are at least three languages by that name :(
22:32:19 <jfredett> really?
22:32:20 <vincenz> s/\//?
22:32:31 <jfredett> i only know of one -- the comment programming language
22:32:46 <sorear> cambridge, combined, and one other I've forgotten
22:32:52 <vincenz> commodore?
22:32:54 <jfredett> the only valid programs are comments... :)
22:32:56 <sorear> snd3 was pred C
22:33:50 <Korollary> Ooh. Cake cutting algorithms.
22:34:00 <jfredett> lol, Cake!
22:34:49 <Korollary> "Implicit Pareto optimality"
22:35:16 <jfredett> buzzwords, aaah!
22:35:30 <jfredett> @google implicit Pareto Optimality
22:35:34 <lambdabot> http://links.jstor.org/sici?sici=0020-6598(198310)24:3%3C649:SPOATM%3E2.0.CO;2-1
22:35:35 <lambdabot> Title: JSTOR: International Economic Review: Vol. 24, No. 3, p. 649
22:35:52 <jfredett> I love it when Lambdabot gives me JSTOR links
22:35:56 <jfredett> @botsnack
22:35:56 <lambdabot> :)
22:36:19 <Korollary> It's not something you say in polite company
22:36:59 <jfredett> what?
22:37:01 <Korollary> "I'm going to throw jargon at my fellow FBI folks. They won't get any of it. But, I sound cool."
22:37:23 <jfredett> thats okay -- thats half the fun of being a mathematician
22:37:31 <jfredett> confusing the shit out of everyone you can
22:38:08 <sorear> but then people will just think you're a markov-model-bot
22:39:40 <jfredett> its why we come up with words like "morphism" and "functor" we could -- of course call them something far simpler, like "procedure" or "mapping from a category to a category"
22:39:52 <jfredett> but we like  to confuse. its in our nature. :)
22:40:30 <jfredett> besides, morphism sounds cooler.
22:43:41 <jfredett> necessito mas agua, brb.
22:48:43 <jfredett> sorear, I _am_ a markov model bot.
22:48:59 <jfredett> but my friends call my marky.
22:54:17 <mlh> primos had a cpl -- an unholy mixture of shell and pascal
22:55:27 <Korollary> There are bad men conjuring bad languages in dark rooms under a full moon. Their laughter freezes you.
22:57:25 <stepcut> is there a font for X that has all (or most) of the currently defined unicode symbols?
22:59:56 <Excedrin> cyberbit, unifont stuff, charis-sil, libertine fonts; there's a few, none are complete
23:00:54 <Excedrin> http://unifont.org/fontguide/ <- good guide
23:00:55 <lambdabot> Title: Unicode Font Guide For Free/Libre Open Source Operating Systems
23:01:00 <stepcut> thanks!
23:38:50 <moozilla> hey, I don't know if this has been brought up before but, there are imperative and functional programming languages, yet computer processors are all imperative (as far as I know), would it be feasible to make a functional processor?
23:39:26 <boyscared> like a lisp machine? :)
23:41:10 <sorear> moozilla: it is a very interesting subject
23:42:02 <sorear> moozilla: if you tally everything up, the potential computing power of a P4 home compute processor is *greater* than the realized power of the world's fastest supercomputer
23:42:14 <sorear> efficiency of the former being 0.00000001% or so
23:42:53 <sorear> all hundred million transistors, being used to execute a very small number (<10) of operations at once
23:43:44 <moozilla> sorear: then why don't they use P4's instead of supercomputers?
23:44:03 <sorear> moozilla: because of the inefficiencies.
23:44:15 <sorear> all current computers are that inefficient
23:44:17 <moozilla> ahh
23:44:52 <sorear> the Blue Gene/L has hundreds of thousands of times more raw power, at hundreds of thousands of times the power consumption and cost
23:45:19 <sorear> but you could get the same results if you were smart enough to fix the inefficiency of computers
23:45:30 <sorear> with the same cost, and the same power budget
23:45:43 <oerjan> why am i having flashbacks to the "We use only 10% of our brain" myth?
23:46:06 <Korollary> Why don't I know what the hell we're talking about?
23:46:53 <stepcut> moozilla: depends on what you mean by 'function processor', people have built custom processors for running lazy languages like haskell and miranda -- search for 'graph reduction machine'
23:49:27 <moozilla> stepcut: I believe that is exactly what I was talking about, thanks
23:51:42 <sorear> but even graph reduction machines are just neumannian one-thing-at-a-time memory-endowed finite state machines
