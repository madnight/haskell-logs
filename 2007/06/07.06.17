00:04:41 <emu> woot, i beat CAML on Prime gen
00:05:57 <dons> sweet!
00:15:50 <ddarius> dons, do you notice xmonad spazzing out when you right-click a link and choose Save Link As... in Firefox (in fullscreen mode)?
00:16:14 <cc> dwm has that prob too. theres a thread about it - ffox bug
00:16:22 <cc> you can fix it by expanding the 'details' pane
00:16:22 <ddarius> Ah, ok.
00:16:25 <dons> ddarius: as in, focus is lost on the background window?
00:16:27 <cc> then it stays expanded on future saves
00:16:32 <emu> b.c. of dialog box
00:16:33 <cc> you mean its resizing itself in a loop?
00:16:37 <dons> or can you elaborate on 'spazzing out' ?
00:16:47 <emu> ratpoison spazzes too
00:16:48 <ddarius> dons: It keeps changing size.
00:16:51 <emu> freezes up
00:16:58 <dons> oh , let's see.
00:17:25 <dons> fixed in the head branch of xmonad
00:17:35 <dons> that just pops up a full size window. no spazzing out
00:17:49 <dons> we handle hints properly now -- in 0.2 you'd probably get spazzing, yes.
00:17:53 <ddarius> As in a patch applied right now?  I just pulled and recompiled a few minutes ago.
00:18:15 <dons> ah no, just the head branch as is. hmm. at least i couldn't reproduce it
00:18:22 <dons> save as gives me a normal fullscreen tiled window
00:18:38 <dons> ddarius: can you ask on #xmonad, see if sjanssen or someone else can reproduce it
00:19:21 <dons> yes, i have no problems with 'save link as'. even if i pull it into the floating layer and resize it
00:19:31 <sjanssen> ddarius: it's a known bug in GTK
00:19:35 <dons> maybe that's changed into something more insidious in newer firefoxes?
00:19:46 <dons> ah ha
00:20:35 <cc> cant cause minefield-20070614 to spazz out
00:20:37 <dons> yeah, i'm using an older firefox, with an older gtk.
00:20:45 <dons> which seems to be no spazzy
00:21:21 <ddarius> dons: How friendly is conkeror with AJAXy sites in your experience?
00:22:25 <dons> haven't used conkeror. i used konqueror a while ago, but not ajaxy
00:23:01 <ddarius> I must have misremembered who it was.
00:23:40 <dons> stepcut maybe?
00:23:44 * cc tried conkeror for a couple days - plain ffox keybindings are a lot less insane than M-x h b, et
00:23:54 <cc> ctrl-t becomes C-x-5-2!
00:23:57 <cc> come on...
00:24:29 <ddarius> cc: I switched it to the vim keybindings then hacked those to work with a Dvorak layout and just other things I would want.
00:25:01 <sjanssen> ddarius: I suggest vimperator
00:25:21 <sjanssen> it's more stable than conkeror in my experience
00:26:18 <ddarius> sjanssen: Looks nice though I'll have to hack keybindings yet again.
00:35:50 <Moozilla> So, how would I do graphics type stuff in haskell?
00:36:34 <dons> what kind of graphics?
00:36:36 <dons> 3d, or 2d?
00:36:39 <ddarius> You go to the Applications and Libraries page linked to from haskell.org and then to the relevant section.
00:37:00 <Moozilla> 2d, are there any built in libraries?
00:37:03 <dons> in particular, there's gtk2hs for 2d stuff (including vector graphics)
00:37:22 <dons> ?where gtk2hs
00:37:22 <lambdabot> http://haskell.org/gtk2hs/
00:37:43 <Moozilla> Alright
00:37:44 <ddarius> Moozilla: For "standard libraries" you go to the standard library documentation page.
00:37:45 <ddarius> @doc
00:37:46 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
00:37:46 <dons> there's a few others, findable from hackage.haskell.org or the haskell.org page ddarius mentioned.
00:38:22 <Moozilla> Thanks
00:38:51 <Moozilla> So with this can I read images?
00:39:11 <dons> yeah, i think gtk2hs can read a few standard formasts now. there are other libraries too for that.
00:39:22 <Moozilla> Great
01:13:26 <dons> slides from last week's SAPLING workshop, http://programming.reddit.com/info/1z1yf/comments
01:13:27 <lambdabot> Title: Haskell fusion, generics, pattern calculus, index type families: slides from SAP ...
01:13:44 <dons> includes a talk on fusion, on indexed type families (in ghc now), and haskell on the gpu :-)
01:21:02 <cinimod> dons: how easy would it be to add bit twiddling operations to ByteStream?
01:21:59 <dons> to ByteString?
01:22:00 <cinimod> dons: I'd like to use it for the crypto library but ByteStream couldn't do xor last time I looked
01:22:12 <dons> just use Data.Bits for the bit fiddling
01:22:16 <cinimod> dons: oops yes ByteString
01:22:30 <dons> also, check the latest crypto libs, they use both bytestrings and bit fiddling
01:22:32 <dons> (on hackage.org)
01:22:58 <dons> lazy bytestrings are particularly well suited to crypto, in my opinion, since they stream in constanst space, and give you bytes pretty simply
01:23:31 <cinimod> dons: blimey I maintain crypto and I don't recall adding bytestrings
01:23:39 <cinimod> dons: I'll take a butchers
01:23:59 <dons> oh cinimod hehe /me realises who cinimod is  :)
01:24:11 <dons> yeah, there's this Dom guy you should talk to
01:24:14 <dons> :P
01:24:24 <dons> i thought you did lazy bytestring stuff during the hackathon?
01:24:46 <cinimod> dons: no because I needed Data.Bits
01:25:00 <cinimod> dons: are you saying ByteString is an instance?
01:25:23 <dons> so you want to xor 2 bytestrings directly?
01:25:48 <dons> there's no Bits instance for ByteString, but of course there is for the Word8's bytestrings are made up of.
01:26:04 <cinimod> dons: I'll have to check but yes that's pretty much it
01:26:45 <dons> if there's a sensible instance of Bits for ByteStrings (of either flavour) it'd make a useful patch to the bytestring lib (or maybe an extra library)
01:27:02 <dons> it might be confusing since people would not expect bytestrings themselves to be Bits-able
01:27:24 <cinimod> dons: ok I'll have to take another look.
01:27:40 <cinimod> dons: I'm in the middle of GADTs and ASN.1 at the moment
01:27:52 <dons> oh, sounds fun!
01:28:01 <cinimod> dons: and my brain can't switch easily - maybe next weekend
01:28:28 <dons> you should write up what you're doing with the GADTs.  enforcing some crypto properties, I presume?
01:28:34 <cinimod> dons: it seems to work well so far
01:28:56 <cinimod> dons: well it's not crypto (although it's used in X.509)
01:29:16 <dons> ah I see, you're using a GADT to embed the ASN data type?
01:29:30 <cinimod> dons: but yes I can enforce only integers to be used for e.g. a constrained INTEGER
01:29:39 <cinimod> dons: exactly
01:29:42 <dons> yeah, that's cool
01:30:13 <cinimod> dons: I will write it up but it's no small amount of work
01:30:42 <cinimod> dons: I'm actually doing PER (Packed Encoding Representation)
01:31:21 <cinimod> dons: and just the INTEGER encoding is a lot of work (constrained, semi-constrained and unconstrained)
01:32:28 <dons> yeah
01:43:35 <eivuokko> Is there other .net backend on haskell compilers than yhc's (or one seriously in works)?
01:43:50 <dons> there's a .Net binding for ghc in the works
01:44:36 <eivuokko> I've been playing with c# and f# using xna...I'd like haskell.
01:45:05 <eivuokko> ..and I need verifiable bytecode for that.
01:45:18 <eivuokko> (if I want to run the app in xbox)
01:45:28 <Heffalump> DYM managed?
01:45:30 <eivuokko> So just using libs isn't quite enough
01:46:25 <eivuokko> Yes, it is managed, and even more, verified = no unsafe pointers etc.
01:46:56 <Heffalump> oh, I thought managed implied verified
01:47:07 <Heffalump> and that managed was the .NET term, whereas verified is the JVM term
01:47:10 <Heffalump> but I could well be confused
01:47:28 <eivuokko> I am not that much of an expert, I just skimmed the specs and I recall them using word verified
01:47:45 <eivuokko> Might be that api docs use other terms
01:49:09 <eivuokko> Is that .net binding the stuff that's been on for year or two and has no published patches  or binaries?
01:49:29 <eivuokko> (except the stuff on main ghc repos, that doesn't work)
01:49:38 <xpika> @where flags
01:49:39 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
01:52:17 <Heffalump> http://www.cin.ufpe.br/~haskell/haskelldotnet/ exists but is still vapourware
01:52:20 <lambdabot> Title: The Haskell.NET Project
01:52:28 <eivuokko> Yes, that.
01:52:29 <Heffalump> but they've been making some noise lately, so perhaps they'll release something soon
01:52:52 <eivuokko> Mhm
01:54:21 <yakov> morning
01:54:40 <Heffalump> how much of a rush are you in?
01:54:59 <eivuokko> Not rush.  I can continue using c# and f# :-P
01:55:40 <eivuokko> And most fun stuff doesn't work on xna/xbox anyway, so can't do really interesting things anyway.
01:57:32 <LeCamarade> eivuokko: I use F#, and I am lovin' it. Of course, I pray for the Haskell.NET project everyday, but ... until then. :o)
01:57:45 <eivuokko> I miss monads.
01:58:53 <LeCamarade> eivuokko: Me too. And .NET has some ashamingly-procedural libraries. Too, too procedural.
01:59:13 <eivuokko> Hmm
01:59:17 <LeCamarade> And very little support for functional programming in the .NET runtimes.
01:59:24 <eivuokko> Indeed.
01:59:46 <eivuokko> Seen how f# compiler algebraic datatypes? -.-
01:59:49 <LeCamarade> They told the F# guy that `programs that allocate a lot' (like the functional ones) are bugs. :o(
02:00:16 <eivuokko> Yeah, I am kinda worried about that stuff.  They say on xbox the garbage collector is pretty bad.
02:01:36 <LeCamarade> Oh. Hadn't heard of that. And that the support for tail-recursion is a bit crippled. In fact, F# is a lot like an attempt to show that FP can be done on .NET. If it is something to prove, that causes fear.
02:02:17 <LeCamarade> But I've not had any intense programs, so I can't judge the performance. I'm just glad about having OCaml on .NET. :o)
02:02:19 <eivuokko> Hmm?  How is tail-recursion crippled?  Atleast there's an instruction for that.
02:02:50 <Adamant> what about .NET 3? I thought it was supposed to improve matters
02:03:01 <Adamant> for FP-ish programs
02:03:01 <eivuokko> Ah, you mean it cannot be verified in all cases...
02:03:30 <eivuokko> The quick glance I had on .net 3 stuff didn't seem such a big improvement, but I am not a compielr writer really.
02:07:37 <dmead> ?paste
02:07:38 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:08:39 <nomeata> lambdabot, messages?
02:09:12 <nomeata> can I make lambdabot forget a message I sent someone?
02:09:35 <nomeata> @tell dons ignore my last message, repo was up again, I did not forget, you got the patches by mail.
02:09:36 <lambdabot> Consider it noted.
02:09:53 <nomeata> @botsnack
02:09:53 <lambdabot> :)
02:14:15 <LeCamarade> eivuokko: On tail-recursion: I remember reading something about there being a kind of difficulty in just forcing the jumps, especially when working with other code written in them other languages. Still searching for the link ...
02:14:44 <LeCamarade> Not this one, but I'm getting close: http://geekswithblogs.net/jwhitehorn/archive/2007/06/06/113060.aspx
02:14:47 <lambdabot> Title: Tail Recursion Revisited, http://tinyurl.com/2fvgzx
02:15:30 <LeCamarade> Oh, actually, they were saying it had been healed: http://geekswithblogs.net/jwhitehorn/archive/2006/06/09/81257.aspx
02:15:33 <lambdabot> Title: Tail Recursion, http://tinyurl.com/23jx7j
02:15:34 <LeCamarade> :o)
02:16:09 <dmead> LeCamarade, IL gets translated to bytecode?
02:16:28 <dmead> when compilation is done
02:16:29 <dmead> etc
02:16:37 <LeCamarade> IL is bytecode ...
02:16:43 <dmead> oh
02:17:32 * LeCamarade steps away for a while ...
02:42:30 <DRMacIver> Hm
02:43:01 <DRMacIver> Trying to create eager functional data structures whose performance doesn't suck is really making me appreciate laziness. :)
02:43:15 <dons> DRMacIver: in Haskell?
02:43:15 <lambdabot> dons: You have 11 new messages. '/msg lambdabot @messages' to read them.
02:43:21 <DRMacIver> dons: No.
02:43:34 <dons> i've got a theory that haskell + bang patterns is rather good for eager structures (see lazy bytestrings for an example)
02:44:00 <DRMacIver> I need to read through the lazy byte strings stuff more carefully.
02:44:08 <DRMacIver> As what I'm doing at the moment is very close to it in some respects.
02:44:24 <DRMacIver> (It's a bit closer to Ropes really, but similar idea)
02:44:32 <dons> yeah, sounds related.
02:45:17 <DRMacIver> It is, unfortunately, implemented in Java, but that's a feature rather than a bug. :)
02:45:28 <dons> hehe
02:45:33 <dons> yeah, you'll miss laziness.
02:45:43 <DRMacIver> I'm using laziness in a few places where I can.
02:46:10 <dons> so i wonder: is it easier to build eager structures in lazy-by-default, or strict-by-default languages?
02:46:10 <DRMacIver> It does some lazy IO for example (or will do, not much of that is implemented right now)
02:46:33 <dons> the problem i suspect being that strict languages only have second class laziness support
02:46:40 <dons> while lazy languages have good strictness facilities
02:46:53 <DRMacIver> I discovered that trying to make laziness work in Java is really really difficult in certain cases.
02:47:05 <DRMacIver> I mean, you can do the basic calculate and cache thing.
02:47:08 <[LeCamarade]> DRMacIver: I remember you saying you'd built a laziness lib for Java. Was that a build-up to this?
02:47:28 <DRMacIver> That's easy. But making it thread safe without introducing horrific deadlocking potential is hard.
02:47:35 <dons> so the java guys probably never thought about laziness? you're breaking new ground doing it by hand?
02:47:36 <DRMacIver> [LeCamarade]: The laziness lib in Java rather failed. :-/
02:47:39 <[LeCamarade]> dons: It's why I think laziness should be the default - you can escape it if you don't want it.
02:47:54 <DRMacIver> [LeCamarade]: I couldn't make it work in the type system.
02:48:07 <hpaste>  gattocarlo annotated "problems with Xlib.FontStruct" with "solved problems with Xlib.FontStruct" at http://hpaste.org/312#a1
02:48:09 <dons> [LeCamarade]: yes, needs good good good support for strictness though (at a minimum,  bang patterns)
02:48:15 <dons> gattocarlo: good newS!
02:48:30 <DRMacIver> This is both more and less ambitious - it's a very narrow scope, but a much larger task. I'm essentially recreating the String class using a purely functional (ish) approach.
02:48:53 <DRMacIver> dons: I'm somewhat breaking new ground. I'm sure other people have done parts of this before. :)
02:48:55 <[LeCamarade]> DRMacIver: Ah. That's the sad part. Java wins, even while being ungood. :o(
02:49:07 <gattocarlo> dons: now I can write a dzen in haskell!
02:49:22 <DRMacIver> [LeCamarade]: Yeah. I figured out a way I could do it by basically making everything typed as Object until the last possible minute, but I couldn't be bothered.
02:49:26 <dons> gattocarlo: yeah, i was just about to say!
02:49:32 <dons> it looks like the stub of a dzen :-)
02:49:43 <dons> gattocarlo: so what was the problem, can you summarise?
02:49:47 <DRMacIver> [LeCamarade]: It was basically going to end up with me writing a dynamically typed lazy EDSL in Java. :)
02:50:02 <gattocarlo> dons: the same afecting Tabbed.hs
02:50:25 <dons> not an X11 binding problem, but just calling Xlib incorrectly?
02:50:42 <gattocarlo> yes, you need first to set the fonts with loadQueryFont
02:50:53 <dons> silly imperative languages :-)
02:50:58 <gattocarlo> otherwise FontStruct is not built
02:51:00 <LeCamarade> DRMacIver: I am writing me a language for my kind of work in the near future. I was worried to death of thinking I was going to be patching someone's language, as though there is a compiler tax.
02:51:09 <dons> gattocarlo: good work.
02:51:12 <LeCamarade> With all the bells and whistles. :o)
02:51:28 <gattocarlo> dons: thanks, I'll submit a patch for Tabbed.hs soon
02:51:43 <dons> cool.
02:53:08 <DRMacIver> LeCamarade: Heh. I must admit, I've never gotten around to actually writing a language. I keep wanting to, but I've never had a task for which it was worth the effort.
03:13:18 <olsner> anyone here using the haskell xcode plugin? just installed it - I'm getting "Internal error occurred while creating dependency graph: *** +[NSCFNumber count]: selector not recognized" when trying to build my project
03:15:56 <rhz> laziness makes debugging using trace somewhat difficult I'm finding
03:26:58 <xs> hi. i'm about to abandon haskell for a project i'm working on. i want opengl and i want threading (a separate render and event dispatch thread, at least). glut cannot do this. gtk2hs cannot do this (as i understand it). does anyone happen to have a glimmer of haskell hope?
03:31:10 <eis> i don't see why glut and gtk2hs wouldn't be able to do this
03:31:21 <eis> i know that gtk2hs used to have problems with threads, but those have been fixed
03:32:04 <dons> pretty sure gtk2hs works now. check with dcoutts
03:32:35 <xs> initGUI still spouts stuff at me saying "don't use a threaded RTS", which puts me off
03:32:49 <xs> glut isn't threadsafe (and is really only for toy applications, afaict)
03:33:14 <xs> i'll look again at gtk2hs. thanks.
03:33:23 <eis> another option is hsSDL
03:33:43 <dons> glut's been used in frag (a pretty big use case). what are you doing that you can choose between glut or gtk2hs -- aren't they wildly different?
03:34:37 <xs> i just want to dump opengl to the screen. i don't care how, really. whatever works. i presume i can do most of glut in gtk+.
03:35:00 <xs> eis: hm. there seem to be many haskell sdl bindings. is this one known-good?
03:35:34 <dons> check hackage.haskell.org to find whatever is latest
03:36:15 <dons> and perhaps double check on the mailing list about your problems with gtk and glut. there may be experts who know exactly whta you should be doing
03:36:38 <dons> since there's been quite a bit of graphics / 3d /gl stuff, i'd be really surprised if it wasn't possible with the current libs
03:40:09 <xs> dons: cheers. the libsdl people should be told of hssdl. they point to a dead sf.net project on their haskell language support bit right now.
03:43:01 <eis> xs: maybe you can tell them? :)
03:45:47 <xs> yup. am doing so
03:51:38 <eis> cool =]
03:55:24 <sphynx> I woner why \t -> (snd t, fst t) is pl-ed to "liftM2 (,) snd fst". Is tuple a monad too?
03:56:46 <Lemmih> sphynx: No, it's using the Reader monad.
03:57:35 <dons> Lemmih: can you help out xs with the SDL stuff?
03:59:06 <Lemmih> xs: Need help?
03:59:18 <Lemmih> xs: How's lscd doing, btw?
03:59:19 <dons> wow. the new gadt stuff in darcs looks cool
03:59:36 <dons> glad to see that's going forward. been hanging out for darcs + gadts since '05, iirc
03:59:37 <eis> dons: what's that?
03:59:53 <dons> check the darcs list, "darcs patch: start gadt stuff (and 29 more)"
04:00:28 <Heffalump> we first laid the plans for it in Estonia
04:01:21 <dons> yeah. good to see the code now. i guess the GADT embedding takes a while to settle in? :-)
04:01:36 <dons> also good to see David working on darcs, and not xmonad ;)
04:01:44 <kowey> doesn't even compile yet... but getting closer
04:01:58 <dons> so .. is the path to all glory for darcs?
04:02:00 <Heffalump> I think it just took ages for anyone to have time to implement it in darcs
04:02:06 <dons> yeah.
04:02:15 <Heffalump> also, we spent a lot of time prototyping GADT-based conflictor solutions that went nowhere
04:02:57 <dons> it'd be interesting to see a summary of the origins, side alleys , and path forward for the gadt stuff in darcs (and its type hacking in general)
04:03:39 <Heffalump> I think someone wrote a wiki page about it somewhere. I remember explaining it to them and then reviewing the page after they wrote it.
04:04:12 <Heffalump> the basic idea is pretty obvious, though it didn't seem so obvious at the time we designed this stuff (and GADTs were quite new then)
04:04:40 <Heffalump> http://wiki.darcs.net/index.html/GADTPlan
04:04:41 <lambdabot> Title: GADTPlan - DarcsWiki
04:05:06 <kowey> might be worth updating that with new notation
04:09:32 <DRMacIver> dons: If you're interested, the conclusion seems to be that even trying to do this lazily in Java will nuke your performance from orbit.
04:10:13 <dons> hehe. useful to know.
04:10:27 <dons> hmm. "disclosure.org" would make a cool FP domain name.
04:10:44 <dons> maybe `disclosure' should have been what sequence.complete.org was called.
04:18:34 <ClaudiusMaximus> @type (>>=)
04:18:36 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
04:19:40 <astrolabe> @seen ekidd
04:19:40 <lambdabot> I saw ekidd leaving #haskell 8h 24m 48s ago, and .
04:22:14 <hughperkins> Hi.  Was playing with adding package from packagedb.  Ran configure + build + install, then ghc-pkg list, but dont see the package
04:22:50 <hughperkins> Platform = Windows.  The files seem to end up in d:\program files\haskell , but the ghc instalaltion is at O:\devtools\ghc
04:23:25 <hughperkins> Tried messing around with the --prefix but no joy so far :-/  Seems like the Setup.lhs install is not registering the package?
04:23:38 <Heffalump> it ought to
04:23:44 <hughperkins> Yes :-)
04:23:46 <Heffalump> check that the configure step lists the right ghc
04:23:52 <hughperkins> Yes it does
04:23:59 <Heffalump> dons:\program files\haskell will be executables
04:24:12 <Heffalump> gah, s/dons/d/ # silly autocomplete
04:24:20 <Heffalump> what is the package?
04:24:47 <hughperkins> tried several.  at the moment haddock
04:25:18 <hughperkins> but the issue also exists with other packages, eg http
04:25:19 <Heffalump> oh, that's not a library
04:25:26 <Heffalump> haddock, that is
04:25:26 <hughperkins> Ah ok :-)
04:25:33 <Heffalump> http really ought to end up in ghc-pkg
04:25:43 <hughperkins> html is, but I dont see http
04:26:53 <hughperkins> retrying...
04:27:53 <Heffalump> and I do use Windows (at work, anyway) and I've never had a problem with installing things
04:29:07 <hughperkins> well... just tried rerunning configure, build , install for http, but not seeing it in ghc-pkg
04:29:20 <hughperkins> I'm on a public terminal, maybe something in the registry changes from machien to machine?
04:29:25 <hpaste>  ClaudiusMaximus annotated "any thoughts on this dynamic method dispatcher?" with "ah, so that's why Map.insert has the argument order that it does" at http://hpaste.org/265#a1
04:29:34 <hughperkins> oh wait, I'm blind, http is there Heh!
04:30:15 <hughperkins> Great!
04:32:52 <Heffalump> :-)
04:33:02 <Heffalump> there's no standard for capitalisation, which doesn't help
04:33:06 <Heffalump> cos the alphabetical list is confusing
04:34:23 <hughperkins> Ah yes...
04:42:26 <Saizan_> grep ftw
04:45:03 <hughperkins> Looking for a really simple example of reading a few values from an xml file?  something like reading <config value1="blah" value2="foo" /> or <config><value1>blah</value1><value2>foo</value2></config
04:45:13 <Heffalump> are you using HaXml?
04:46:12 <hughperkins> thats whats insatlled at the moment.  Is that the de facto standard?
04:47:27 <Heffalump> yeah
04:47:41 <Heffalump> it produces fairly verbose data structures, but that's kind of inevitable with XML
04:47:59 <Heffalump> my usual approach is to make a DTD and then use Haskell2Xml to make that into a custom parser for that DTD
04:48:04 <Heffalump> but that's not "really simple"
04:48:04 <psykotic> dons, hey :)
04:48:10 <hughperkins> Right :-)
04:48:24 <Heffalump> so I don't think I can provide any short examples
04:48:32 <hughperkins> Hmmm, ok
04:48:55 <hughperkins> In C# what I do is use reflection to read/write directly between arbitrary objects and xml.
04:49:10 <hughperkins> Trying to figure out how to map that onto haskell
04:53:15 <hughperkins> Ideally, I'd like to be able to be able to parse haskell types and use that to generate the xml, but I've no idea if that's even possible, so trying to code something "by hand" for now
04:57:39 <ClaudiusMaximus> @type Data.Map.lookup
04:57:41 <lambdabot> forall k a (m :: * -> *). (Ord k, Monad m) => k -> Data.Map.Map k a -> m a
04:59:06 <apfelmus> Is there a systematic way to predict space usage of a Haskell program?
04:59:39 <apfelmus> I mean, for running time, one can pretend that we are doing eager evaluation
05:00:02 <apfelmus> and know for sure that lazy evaluation will take less reduction steps
05:00:21 <olsner> wouldn't that be equivalent to determining at compile-time exactly when which data can be garbage collected?
05:00:23 <Igloo> Lazy evaluation might take longer if space usage is higher and the GCer has more work to do
05:00:49 <apfelmus> Igloo: yes, but let's put this aside :)
05:01:26 <apfelmus> i mean, if i want to know asymptotic time complexity
05:01:58 <pejo> apfelmus, 1 +1 will take the same amount of reduction steps under cbn/cbv.
05:02:37 <rhz> is there some reasonably straightforward way to get a screenshot in GLUT in Haskell?
05:02:40 <apfelmus> pejo: yeah, i mean <=, i always mix up those two
05:03:41 <apfelmus> in fact, running time analysis can be done with a lazy/strict hybrid evaluation model
05:04:13 <dons> hey psykotic
05:04:19 <dons> i just replied. thanks for the insight!
05:04:23 <psykotic> dons, does it make sense?
05:04:41 <dons> yeah, as long as you can fully construct the `type checked' value before you proceed to reduce it.
05:04:58 <dons> and indeed, looks like we've got a proper dual there. the checkers roughly reflect each other forward or backward a phase
05:05:21 <psykotic> yep, that's what i think is so nice about it
05:06:18 <dons> interestingly, in both cases the now-defeated built in checking has to run
05:06:37 <dons> in the static case it goes around checking everything is of type 'Universal'
05:06:51 <dons> while in the dynamic case, I presume the built in test-and-then-reduce checking remains
05:07:08 <apfelmus> i mean that you can perform some strict and some lazy reductions at any redex you want and always know that lazy evaluation will not take more step than such a hybrid
05:07:16 <pejo> apfelmus, doesn't reasoning about space usage include reasoning about space leaks? Which is quite hard, they claim.
05:07:22 <apfelmus> (any redex you want, but not inside lambda abstractions)
05:07:50 <Host47> hello
05:08:07 <LeCamarade> Hello.
05:08:13 <psykotic> dons: that is true, but in the formal sense that is irrelevant. the key is that you can guarantee beforehand (via the static phase) that a certain class of errors won't manifest. in a reduction system, you'd express it in terms of "stuck terms". in scheme, you'd do it in terms of "runtime errors".
05:08:57 <dons> yep, exactly.
05:09:06 <Host47> (2*).sum    [1..10] vs. ((2*).sum)    [1..10]  : why the parenthesis are needed?
05:09:26 <dons> now I wonder: how rich does the dynacmically typed language have to be to support the embedded phase distinction, without implementing a full interpreter?
05:09:37 <apfelmus> pejo: yep. but there are folklore examples and folklore intuition and i wonder whether their principles can be stated more or less formally
05:10:09 <LeCamarade> @type (2*)
05:10:11 <lambdabot> forall t. (Num t) => t -> t
05:10:27 <psykotic> dons: i think that has more to do with the dynamic semantics of the two languages. for example, if you don't have closures, then you have to do some kind of defunctionalization and closure conversion to get an embedding.
05:10:44 <LeCamarade> Host47: By putting the parens, you tell Haskell that you are not running the expression 2 *, but just currying the * function.
05:10:54 <LeCamarade> Observe:
05:11:09 <LeCamarade> let x = 2 * in 2
05:11:14 <dons> psykotic: yeah, that seems reasonable.
05:11:17 <LeCamarade> let x = (2 *) in x 2
05:11:22 <LeCamarade> >let x = (2 *) in x 2
05:11:24 <dons> its easier in scheme :-)
05:11:30 <Host47> LeCamarade: okok thx
05:11:39 <LeCamarade> Host47: Phew. :o)
05:11:49 <LeCamarade> @bot
05:11:49 <lambdabot> :)
05:11:56 <Saizan> Host47: because (2*) . sum [1..10] is parsed as (2*) . (sum [1..10]) which is wrong
05:12:02 <LeCamarade> lambdabot: Now why didn't you eval?
05:12:06 <LeCamarade> lambdabot--
05:12:22 <Saizan> Host47: function application has the highest precedency
05:12:35 <thorkilnaur> > let x = (2 *) in x 2
05:12:37 <lambdabot>  4
05:12:41 <Host47> Saizan: clear thx
05:13:15 <thorkilnaur> LeCamarade, because the space after > was missing, I think
05:13:38 <LeCamarade> #haskell: Who is captaining the Wikibooks page on Haskell/Denotational_semantics?
05:13:42 <apfelmus> however, the hybrid strict/lazy approach to time analysis fails for space analysis. Take for instance foldl (+) 0 [1..20]
05:13:51 <pejo> apfelmus, if you find any work on stating it formally, please let me know. :-)
05:14:32 <apfelmus> sure :D actually, i'm trying to write some wikibook contents about this
05:14:34 <LeCamarade> pango_: Oh. I wanted to tell him that I, in fact, had the source code for an OCaml IRC bot, if he wanted one.
05:14:43 <LeCamarade> Oops.
05:15:34 <apfelmus> evaluating foldl (+) 0 [1..n] with lazy evaluation takes O(n) space
05:15:53 <apfelmus> but evaluation it with eager evaluation takes O(n) space as well
05:16:32 <apfelmus> the trick is to apply lazy reduction steps on the list but strict reduction steps on the accumulated (0+...)
05:16:41 <apfelmus> the result is O(1) then
05:16:49 <apfelmus> O(1) space that is
05:17:41 <apfelmus> but to figure that out, you have to write down a complete trace of the graph reduction taking place
05:18:42 <pejo> apfelmus, Hutton and Hope had some work on accurate step counting. Not sure if it contains anything useful for you though.
05:19:13 <apfelmus> hm, i guess i should look into it again
05:19:33 <apfelmus> however, the more accurate the procedure, the worse for the programmer
05:20:14 <apfelmus> i mean, for time analysis, you can simplify a proof by evaluating redexes in advance
05:21:27 <apfelmus> i only have a bad example: http://www.mail-archive.com/haskell@haskell.org/msg19980.html
05:21:27 <lambdabot> Title: [Haskell] Re: Quicksearch vs. lazyness
05:23:15 <apfelmus> in the analysis, you can first expand (foldTree f [1..4]) to ((1 `f` 2) `f` (3 `f` 4)) and look how much time this takes
05:23:52 <apfelmus> then, you can wonder how lazy evaluation reduces this with f = merge
05:24:55 <apfelmus> of course, the real execution will interleave both phases to obfuscation
05:25:34 <apfelmus> but who have the _guarantee_ that this analysis can at worst overestimate the running time
05:26:08 <hughperkins> Hmmm, sometimes its ok to use brackets and sometimes not; hard for a newbie :-/
05:26:30 <hughperkins> Why does putStrLn( "Your name is: " ++ name )   need brackets, but o it again
05:26:51 <DRMacIver> It's because function application finds more strongly than operators.
05:27:03 <hughperkins> but hSetBuffering stdin LineBufferinghSetBuffering stdin LineBuffering does not
05:27:09 <DRMacIver> So putStrLn "Your name is: " ++ name gets parsed as (putStrLn "Your name is: ") ++ name
05:27:14 <hughperkins> argh, cant use mouse
05:27:16 <hughperkins> "hSetBuffering stdin LineBuffering"
05:27:39 <hughperkins> Why cant i do "hSetBuffering( stdin LineBuffering )"
05:27:48 <DRMacIver> The first parses as (hSetBuffering stdin) LineBuffering, which is correct. :)
05:28:07 <DRMacIver> The second is incorrect because you're trying to apply stdin to LineBuffering
05:28:14 <DRMacIver> Which is type unsound.
05:28:34 <DRMacIver> Functions never have brackets for their arguments. Brackets just group things.
05:28:35 <hughperkins> eh-heh, brain explodes
05:28:43 <hughperkins> Ah
05:28:52 <oerjan> hughperkins: parentheses must always be around a sinle expression
05:28:58 <oerjan> *single
05:28:59 <hughperkins> Ah ok
05:29:03 <DRMacIver> When you're doing hSetBuffering stdin LineBuffering you're applying the function hSetBuffering to stdin and are getting back a function which you then apply to LineBuffering.
05:29:06 <Baughn> hughperkins: Think lisp, if you like. (sqrt x), not sqrt(x).
05:29:27 <hughperkins> Ah ok, interesting :-)
05:29:29 <Saizan> (func arg1 arg2 .. argn) <-- right, wrong -> func(arg1 arg2 .. argn)
05:30:49 <hughperkins> So, basically, if Pustrln took two arguments, it could look like this:
05:30:50 <Saizan> we should put this in some of the tutorials, it's very different from the mainstream languages
05:31:14 <hughperkins> putStrLn ( "Your name is " ++ name ) SomeSecondParameter
05:31:30 <Baughn> hughperkins: Yes, exactly
05:31:34 <hughperkins> Ok
05:32:01 <Baughn> hughperkins: Though it has to be "someSecondParameter", as the intial letter's capital-ness is syntax. ;)
05:32:03 <hughperkins> Ok, cool, that makes sense
05:32:11 <hughperkins> Ah Heh! :-)
05:32:14 <olsner> shouldn't I have gotten HaskellSupport.framework installed with my ghc installation?
05:32:34 <gh_> hi, i'm trying to compile a haskell program written 4 years ago, it imports the module "IOExts" but it no longer exists in ghc, does anybody know by which one(s) it has been replaced ?
05:33:00 <Baughn> gh_: Do you have a type signature for any of the functions in it? Or just a name?
05:33:03 <hughperkins> IO?
05:33:52 <oerjan> gh_: if you don't know what functions they are, try commenting out the import to see what it complains about
05:34:03 <gh_> oerjan,  yes, i'm goign to d this
05:34:06 <gh_> do
05:34:38 <apfelmus> gh_: most likely in one of System.* now. Try System.IO for a start
05:34:53 <hughperkins> Saizan, where could be an appropriate page for me to add a couple of lines with " Functions never have brackets for their arguments. Brackets just
05:34:56 <hughperkins> +group things."?
05:35:06 <hughperkins> I mean, in the wiki?
05:35:46 <Saizan> yeah in the wiki, i don't know if there's a page on syntax or such..
05:39:30 <hughperkins> Hmmm, theres quite a few tutorials / wikis about!
05:40:42 <gh_> ok.. in fact i needed no more import to replace IOexts :)
05:49:40 <eis> rhz: glReadPixels is usually used for taking a screenshot
05:54:49 <hughperkins> newbie question: how do I do a nop or a "pass" in an if...else? eg "if count < 20 then my_function count + 1 else NOP
05:55:48 <oerjan> hughperkins: you need to return _some_ value.  It depends on what you want to do.
05:56:32 <erider> good morning
05:56:42 <hughperkins> its an imperative function that just has do putStrLn count
05:56:51 <hughperkins> then it loops
05:56:58 <oerjan> then return () is usually good
05:57:25 <eivuokko> Or possibly when.
05:57:28 <oerjan> as long as the then branch is IO ()
05:57:37 <_roconnor> @type until
05:57:38 <eivuokko> :t Control.Monad.when
05:57:40 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
05:57:40 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
05:57:47 <oerjan> @src when
05:57:47 <lambdabot> when p s = if p then s else return ()
05:58:25 <oerjan> when is an abbreviation, but it needs an import Control.Monad
05:58:45 <oerjan> but you usually want that anyway for imperative code
05:58:50 <_roconnor> @type while
05:58:52 <lambdabot> Not in scope: `while'
05:59:13 <_roconnor> > until (20<=) (^2) 1
05:59:19 <lambdabot> Terminated
05:59:25 <_roconnor> > until (20<=) (^2) 2
05:59:27 <lambdabot>  256
05:59:39 <rhz> another newbie (kind of) question: can I force a list to be strict?
05:59:52 <sieni> in what sense?
05:59:54 <_roconnor> > until (20<=) (\x -> 3*x+1) 1
05:59:55 <lambdabot>  40
06:00:04 <olsner> @type until
06:00:06 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
06:00:53 <_roconnor> @type mapM putStrLn [1..20]
06:00:55 <lambdabot>     Ambiguous occurrence `mapM'
06:00:55 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
06:02:02 <olsner> ... but if there is only one candidate - in what way is it ambiguous?
06:02:17 <rhz> The list is stored inside an IORef. I'm worried it is being reevaluated every time it is used.
06:02:21 <hughperkins> http://paste.lisp.org/display/42901
06:02:48 <oerjan> rhz: it should not be evaluated more than once
06:03:14 <hughperkins> getting error "Couldn't match expected type `()' against inferred type `IO t'"
06:03:21 <oerjan> olsner: lambdabot cuts off the error messages
06:03:52 <Saizan> ?type Data.Traversable.mapM
06:03:54 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
06:06:09 <Saizan> hughperkins: seems like you are nesting IO actions, if you get stuck you can paste the code on hpaste
06:06:13 <Saizan> @paste
06:06:13 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:06:34 <Saizan> with the error .)
06:06:40 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/313
06:06:47 <hughperkins> http://hpaste.org/313
06:07:16 <hughperkins> there are several versions ;-)  This one gives "parse error, possibly incorrect indentation"
06:07:22 <oerjan> rhz: unless you are using unsafePerformIO as well
06:08:00 <mehrheit> hughperkins, then and else should be indented more than if
06:08:55 <hughperkins> Ah.... thanks  merhrheit :-)
06:09:47 <hpaste>  Saizan annotated "(no title)" with "like this" at http://hpaste.org/313#a1
06:10:03 <oerjan> hughperkins: the problem in the when version was you forgot parentheses around the second argument
06:10:10 <Saizan> or you can put everything on one line
06:10:42 <hughperkins> Ok
06:12:27 <oerjan> hughperkins: the $ operator is good to use if a function takes a complicated last argument
06:12:29 <hughperkins> Ok cool that works :-)
06:12:35 <Saizan> when (count /= 30) $ function2 (count+1)
06:12:49 <hughperkins> ok
06:13:01 <Saizan> here $ is like a ( that is closed at the end of the expression
06:13:02 <oerjan> @quote stereo
06:13:02 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
06:13:40 <hughperkins> the whole function2(count+1) is a second parameter to the when which is a function?
06:13:48 <Saizan> yes
06:13:55 <hughperkins> Ok, interesting
06:14:00 <oerjan> @src when
06:14:00 <lambdabot> when p s = if p then s else return ()
06:14:41 <hughperkins> Ah ok that makes sense now :-)
06:15:24 <oerjan> @src ($)
06:15:25 <lambdabot> f $ x = f x
06:16:00 <hughperkins> Ummm, this is probably a newbie request that you hear many times but... is there any chance you could make functions implicitly return () so that if statements didnt require the else, which is currently required by the requirement to return()?
06:16:32 <dons> yes, you use the function 'when' or 'unless' :-)
06:16:34 <dons> ?src when
06:16:34 <lambdabot> when p s = if p then s else return ()
06:16:37 <dons> ?src unless
06:16:37 <lambdabot> unless p s = if p then return () else s
06:16:44 <hughperkins> :-)
06:16:45 <dons> they're in Control.Monad, so import that first
06:16:49 <hughperkins> Ok
06:17:06 <xpika> @src when
06:17:06 <lambdabot> when p s = if p then s else return ()
06:17:16 <dons> this is a nice introductory example of how to write your own control structures too, btw.
06:17:20 <dons> something to keep in mind.
06:18:53 <oerjan> > 1+2
06:19:01 <lambdabot>  3
06:19:27 <kpreid> hughperkins: re parentheses, here's something you might find interesting
06:19:48 <kpreid> > let f = uncurry replicate in f(3, "abc")
06:19:50 <lambdabot>  ["abc","abc","abc"]
06:20:10 <kpreid> > replicate(3)("abc")
06:20:11 <lambdabot>  ["abc","abc","abc"]
06:20:18 <kpreid> See, Haskell syntax is ordinary :-)
06:20:43 <dons> yes, whitespace layout and parens-only-for-grouping give you a bit of roll-your-own syntax.
06:21:06 <dons> you do see beginners use f(1,2) to write what we'd say as: f 1 2
06:25:15 <xpika> if you want parenthesis just type uncurry first
06:25:24 <xpika> >uncurry div(100,2)
06:25:30 <xpika> > uncurry div(100,2)
06:25:31 <lambdabot>  50
06:27:28 <Saizan> ?type uncurry foldr
06:27:30 <lambdabot> forall a b. (a -> b -> b, b) -> [a] -> b
06:28:01 <hughperkins> Ok, interesting.
06:28:20 <dons> :t uncurry
06:28:21 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
06:28:24 <dons> :t curry
06:28:25 <lambdabot> forall a b c. ((a, b) -> c) -> a -> b -> c
06:28:47 <hughperkins> curry/uncurry are just functions written in Haskell?
06:28:58 <Saizan> yes
06:28:58 <dons> yeah
06:29:00 <dons> ?src curry
06:29:00 <lambdabot> curry f x y = f (x, y)
06:29:02 <dons> ?src uncurry
06:29:02 <lambdabot> uncurry f p = f (fst p) (snd p)
06:29:09 <hughperkins> Hmmm, thats quite powerfull :-)
06:29:22 <dons> yeah, its a good way to mess with how functions glue together
06:29:25 <dons> ?src fst
06:29:26 <lambdabot> fst (x,_) =  x
06:29:27 <dons> ?Src snd
06:29:27 <lambdabot> Maybe you meant: rc src
06:29:31 <dons> ?src snd
06:29:31 <lambdabot> snd (_,y) =  y
06:29:36 <dons> another good couple to know are:
06:29:38 <dons> ?src flip
06:29:38 <lambdabot> flip f x y = f y x
06:29:42 <dons> to flip arguments around
06:29:44 <dons> and
06:29:45 <kpreid> uncurry could also be written uncurry f ~(x,y) = f x y
06:29:45 <dons> ?src (.)
06:29:46 <lambdabot> (.) f g x = f (g x)
06:29:50 <dons> function composition, of course.
06:30:05 <Saizan> hughperkins: note that in f(a,b), (a,b) is not just syntax, but a value, a 2 element tuple
06:30:14 <dons> flip/./curry/uncurry.   glue for functions! :-)
06:30:20 <dons> a new one in the mix is `on'
06:30:21 <dons> on :: (b -> b -> c) -> (a -> b) -> a -> a -> c
06:30:22 <dons> (*) `on` f = \x y -> f x * f y
06:30:34 <dons> so we can write:  sortBy (compare `on` fst)
06:30:40 <eivuokko> Is on on std libs?
06:30:53 <dons> in Data.Function yes. so it'll be in the next release of the base package
06:31:06 <eivuokko> Cool, no idea how many times I rolled my own.
06:31:13 <dons> me too!
06:31:22 <dons> almost every time i sort pairs
06:31:33 <kpreid> you know what would be neat?
06:31:48 <Saizan> ?type comparing
06:31:50 <lambdabot> forall b a. (Ord a) => (b -> a) -> b -> b -> Ordering
06:32:01 <dons> kpreid: no. what is neat?
06:32:06 <kpreid> if @pl could be told about new combinators (like on) and automatically generate optimization rules to and from it
06:32:18 <dons> ah hmm.
06:32:25 <dons> just as a set of rewrite rules
06:32:38 <dons> just being able to extend @pl would be good.
06:32:45 <dons> we really should talk more to the HaRe guy..
06:32:54 <kpreid> hmm
06:33:11 <dons> its a pretty simple system, and ndm redid his own in yhc (DrHaskell)
06:33:23 <dons> so we could either a) roll a new one, b) polish it up to make it easily extensible
06:33:36 <dons> needs a phd student interested in term rewriting to spend a couple of days on it
06:34:02 <dons> or, if you spend a couple of days on it, you should apply to also do a phd somewhere
06:34:07 <oerjan> does @pl ever factor out common subexpressions?  It seems that using `on` would require that.
06:34:24 <dons> it does also factor out, yeah. but its a bit ad hoc, as far as term rewriting engines go
06:35:32 <Saizan> ?pl  \x y -> f x * f y
06:35:33 <lambdabot> (. f) . (*) . f
06:35:54 <kpreid> hmm. there isn't really such a thing as : on :: ap :: liftM
06:36:13 <dons> ?unpl (f *** g)
06:36:13 <lambdabot> (f *** g)
06:36:25 <kpreid> lack of type inference
06:36:44 <dons> ?pl \f g (x,y) -> (f x, g y)
06:36:45 <lambdabot> flip flip snd . (ap .) . flip flip fst . ((.) .) . flip . (((.) . (,)) .)
06:36:52 <kpreid> even if it did, you'd have to ?unpl ((f :: a -> a) ** g)
06:37:15 <dons> yah, no type info. HaRe could do it though, I think
06:48:36 <eis> ...
06:49:54 <hughperkins> :t tail
06:49:57 <lambdabot> forall a. [a] -> [a]
06:50:03 <hughperkins> oops, wrong cmd
06:52:13 <pejo> dons, the supply of phd students is unfortunately limited. :-)
06:55:07 <dons> pejo: yes :-(
06:55:30 * dons is only weeks away from finishing, and real world (haskell!) pressures are taking away from my hacking time
06:57:22 <pejo> dons, can you fail and postpone the defense for another year? Gives you time to teach some other grad student your stuff. ;)
06:57:29 <dons> hehe
06:57:30 <eis> how much does haskell pay per hour?
06:57:46 <erider> happy father's day!
06:58:10 <dons> not sure you can get paid by the hour. all the haskell jobs i've seen recently were 1 year+ salaries
06:58:21 <dons> shapr might know
07:00:51 <eis> anyone familiar with yhc javascript output?
07:01:52 <pejo> dons, have a job waiting for you?
07:02:03 <dons> pejo: yeah, i'm heading off to galois
07:02:16 <pejo> dons, oh. Like all other grad students. :-)
07:02:22 <pejo> Or rather former grad students, heh.
07:02:24 <dons> apparently :}
07:02:30 <Igloo> Who else is?
07:02:56 <dons> well, i think i'm the only one so far in our generation, Igloo (?)
07:03:05 <dons> though glguy is there now too.
07:03:09 <pejo> Igloo, didn't Diatchki (sp?) go there too?
07:03:12 <dons> yeah.
07:03:24 <Igloo> OK
07:16:36 <dons> night all.
07:16:40 <dons> happy lambdas.
07:18:52 * araujo wonders if anyone has some server with some free space to share with a darc repo :-)
07:32:34 <hughperkins> "
07:32:51 <hughperkins> let valuesasnumbers = map read values" gives ambiguous type variable
07:33:23 <hughperkins> been staring at it for a while, trying to explicitly declare the type to solve the issue -> cant seem to figure this out.
07:33:34 <hughperkins> values is a list of strings
07:35:28 <dons> right, its not sure what type you're trying to read into
07:35:48 <dons> > map (read :: String -> Int) ["1", "2", "3"]
07:35:49 <lambdabot>  [1,2,3]
07:35:56 <dons> > map (read :: String -> Bool) ["1", "2", "3"]
07:35:57 <lambdabot>  Exception: Prelude.read: no parse
07:36:02 <dons> > map (read) ["1", "2", "3"]
07:36:03 <lambdabot>  [1,2,3]
07:36:11 <dons> well, that used defaulting, so I was sneaky.
07:36:25 <hughperkins> Ah, ok, cool :-)
07:36:28 <dons> but normally you don't have defaulting, so the above would produce an ambiguous type variable error
07:36:48 <eis> "file name does not match module name"
07:37:03 <eis> how do i solve that compile error? my module name definitely matches the filename
07:37:33 <dons> double check, module M where, M.hs
07:37:45 <eis> oops nm
07:38:05 <hpaste>  mc pasted "diviseur : more simple ?" at http://hpaste.org/314
07:38:06 <Igloo> dons: Does lambdabot do any defaulting beyond what GHC does?
07:38:52 <hughperkins> Cool, that works :-)
07:39:45 <Igloo> Oh, that's interesting. 'map read ["1", "2", "3"]' doesn't work in ghci but 'print (map read ["1", "2", "3"])' does
07:41:07 <Syzygy-> Cool.
07:44:55 <dons> Igloo: yeah,, it uses ghci-style defaulting (-fextended-defaulting)
07:45:18 <Igloo> Sorry, I meant GHCi. But the above is what confused me
07:45:31 <dons> the print adds the Show instance, which kicks in the other defaulting stuff, yep,
07:46:38 <psykotic> dons: do you know of any "well-known" compilers that use a dependently typed calculus as a core calculus in the compiler, even though the front-end language is non-dependently-typed?
07:46:41 <Igloo> Hmm, yeah, but it's not too nice from a user's PoV
07:47:16 <psykotic> dons: for ease and uniformity of encoding various type system features, say.
07:47:36 <Igloo> Actually, there's already a Read constraint, so I'm not sure it should matter with the extended rules
07:47:53 <Igloo> Oh, yes it does
07:49:22 <dons> psykotic: hmm. System Fc (the GHC with type coercions) is getting there. But JHC is the prime example. pure lambda cube intermediate form
07:49:48 <psykotic> oh, didn't know that about jhc. cool!
07:49:50 <dons> there's Henk too, another pure type system intermediate language, used in a couple of compilers.
07:49:57 <dons> (only researchy ones)
07:50:36 <dons> Igloo: hmm, that's a bit weird that Show adds defaulting that Read doesn't
07:54:39 <psykotic> dons: is there a good example of a type system feature jhc's encodes in its core PTS with much greater ease than ghc?
08:04:47 <dcoutts> @seen xs
08:04:47 <lambdabot> xs is in #haskell. I last heard xs speak 4h 18m 59s ago.
08:05:21 <dcoutts> xs: Gtk2Hs does have support for the threaded rts, but you do need to be a bit careful about what you do from particular threads
08:05:48 <ekidd>  dons: Thanks for your advice on writing papers! It was a huge help.
08:06:51 <dcoutts> xs: you'll note that the initGUI message mentions that you can use a separate function to initialise the GUI to use with the threaded rts. That's mainly so that casual users do not shoot themselves in the foot
08:07:22 <dcoutts> xs: because Gtk+ is still a single threaded toolkit, so using it from the threaded rts needs some care
08:15:13 <olsner> oh, henk sounds interesting
08:17:28 <hughperkins> exit
08:17:38 <dons> psykotic: it is suspected that GADTs and associated type families would be easier in JHC's core, than in System F-GHC style
08:17:55 <dons> but now GHC uses System Fc, a core with extended stuff for type witnesses
08:17:56 <psykotic> that makes sense. those are trivially encodeable in a dependently typed framework.
08:18:02 <dons> maing both those easier.
08:18:24 <dons> so, real world haskell stuff: not sure. experimental type system things, definitely
08:18:29 <vincenz> > 1
08:18:30 <lambdabot>  1
08:19:09 <psykotic> dons: today's experimental type system things: tomorrow's real world haskell stuff :)
08:19:32 <psykotic> the nested data parallellism stuff uses associated type families, right?
08:19:54 <dons> yep
08:20:01 <dons> to match up types with their distributed representation
08:20:05 <psykotic> right
08:32:07 <psykotic> dons: speaking of associated types, can you define 'instance' families abstracted over a type class?
08:32:36 <psykotic> for example, imagine you wanted one kind of representation for types that implement a Hashable type class, another for those that only implement Ord, yet another for those that only implement Eq.
08:32:56 <psykotic> (like for a map)
08:33:20 <dons> right. class associated classes :-) they're a new feature.
08:33:29 <psykotic> oh cool
08:33:31 <dons> eactly so you can do things like switch on Ord or Eq
08:33:53 <dons> see the slides on this here, (page 25) http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071?action=download&upname=chakravarty-slides071.pdf
08:33:55 <lambdabot> http://tinyurl.com/2donwk
08:34:01 <dons> http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071
08:34:02 <lambdabot> Title: &nbsp; : SAPLING - SAPLING 071 browse
08:34:13 <dons> (last week, Manuel gave a talk on precisely this feature)
08:34:33 <Cheery> you realise why haskell is more human-friendly than C?
08:34:37 <dons> also appears to solve the restricted monad issue, say for Set monad.
08:34:48 <dons> Cheery: hmm, no. why?
08:34:55 <dons> segfaults?
08:35:43 <Cheery> it's simple if you think of the code as a reflection of model in your mind
08:36:15 <Heffalump> dons: are class associated classes actually in HEAD now, then?
08:36:21 <monochrom> I know people who claim that it's natural to think up state-based mental models.
08:36:24 <Cheery> assembly in itself does not convey much of interesting from that model
08:37:08 <dons> Heffalump: nope. it's considered 2 days work though. so soon.
08:37:12 <Cheery> therefore you benefit only little from compressing bunch of instructions
08:37:34 <dons> Heffalump: mail chak et al if you want them sooner.
08:37:34 <Heffalump> how does it solve the restricted monad issue? Don't you still have to redefine Monad to take advantage?
08:37:48 <Heffalump> was just idly wondering, no urgent need.
08:38:07 <dons> there's an example in the talk. I think you wrap the class Monad with a class-associated Restricted type?
08:38:22 <dons> and then more restricted instances can fill out that type
08:38:37 <ekidd> dons: Ooh.
08:38:44 <ekidd> dons: sigfpe has been wanting that.
08:38:47 <dons> ekidd: how'd the paper go, get it submitted?
08:38:52 <Cheery> haskell, in other hand, wants code given in a more interesting form
08:38:53 <dons> yeah, i saw that right at the end of today's article
08:39:03 <dons> and mentioned it to sigfpe :-)
08:39:39 <ekidd> dons: It's submitted. http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
08:39:40 <Cheery> but fails at providing straightforward way to convert the reflected models into binary
08:39:41 <lambdabot> http://tinyurl.com/276u5w
08:39:51 <dons> yay, well done ekidd
08:40:16 <ekidd> dons: Many thanks to the Haskell community. I couldn't have done it without you all!
08:40:41 <dons> its cool how blogging can lead to papers these days!
08:40:49 <dons> now , just have to convince sigfpe to write some.
08:40:53 <vincenz> type families seem like a REALLY cool feature
08:41:09 <dons> vincenz: and so much simpler than functional dependencies
08:41:34 <dons> its fairly intuitive how they work. per-instance types, classes and so on. type programming in the functional style, not the logic style
08:42:59 <dons> ekidd: i like the coloured cross-refs in the .pdf. is that dvipdf?
08:43:18 <vincenz> dons: what are the synonym families, they're not explained in those slides
08:43:40 <ekidd> The hyperref package and pdflatex.
08:43:57 <dons> ah yes.
08:43:58 <ekidd> dons: You should also get a nice table of contents if you turn on bookmark view.
08:44:15 <dons> vincenz: maybe check http://haskell.org/haskellwiki/GHC/Indexed_types ?
08:44:16 <lambdabot> Title: GHC/Indexed types - HaskellWiki
08:44:46 <sorear> (hello)
08:44:48 <Heffalump> dons: I still don't see how you can do it without redefining Monad. But the redefinition would still be nicer than the current hacks people need.
08:45:28 <Heffalump> vincenz: AIUI, there's families where you define instances using data, and there's families where you define them using type. But I may be a bit confused.
08:45:49 * sorear wonders why dons is awake
08:45:59 <Heffalump> natural hacker behaviour?
08:46:14 <Heffalump> @localtime dons
08:46:15 * vincenz read that as "natural number behaviour"
08:46:17 <lambdabot> Local time for dons is Mon Jun 18 01:45:23 2007
08:46:36 <Heffalump> that's not late at all. Even I stay up that late at weekends occasionally nowadays.
08:50:33 <vincenz> Heffalump: how about week days?
08:50:54 <Heffalump> not a hope. I get up at 5:30 :-)
08:51:06 <ekidd> dons: Let me know if you notice any glaring errors while glancing at my paper. :-)
08:51:10 <vincenz> Heffalump: so what time do you hit the sack
08:51:16 <dons> yep. you should have sent me a copy before the deadline ;)
08:51:19 <Heffalump> 11:30 at the latest.
08:51:22 <ekidd> I'm headed out for brunch, but I'll check with lambdabot when I get back.
08:51:33 <vincenz> Heffalump: wow, 6h daily o.O
08:51:37 <dons> i'm headed for bed, will read it through tomorrow and send some notes.
08:52:02 <ekidd> dons: I know. :-/ I allocated a whole bunch of time to write it, and it still ended up taking me until almost the deadline.
08:52:24 <ekidd> Next time, I'll leave even more time.
08:52:27 <dons> hehe.
08:52:41 <dons> that's what I always say too. the last paper was handled in a 7.30 am, 30 mins before the deadline
08:53:14 <ekidd> I had no idea that "2 weeks before the deadline", was actually "leaving it for the last possible moment."
08:53:48 <pejo> ekidd, or as a colleague put it - "Writing a paper takes the amount of time available until the deadline". :-)
08:53:59 <Heffalump> vincenz: that's the absolute latest
08:54:12 <Syzygy-> You write towards deadlines? O.o
08:54:37 * vincenz does too
08:54:43 * Syzygy- is typing up his first two papers ... Gonna see about a good point to submit them to when I'm done. :P
08:55:01 <ekidd> Syzygy-: The paper was basically an excuse to go to Haskell Workshop and meet people, so submitting elsewhere wouldn't work. :-)
08:55:23 <vincenz> ekidd: yeah, writing papers takes time
08:55:28 <vincenz> ekidd: 2 weeks is really very little
08:55:56 <Syzygy-> ekidd: Right.
08:56:00 <Syzygy-> Oooooh, that reminds me...
08:56:12 <Syzygy-> One of my papers might be a good reason to get to go to Haskell/FP-workshop-thingies.
08:57:24 * Heffalump probably can't go to ICFP this year :-(
08:57:38 <desp> @hoogle Monad m => m (a -> m ()) -> [a] -> m ()
08:57:39 <lambdabot> No matches, try a more general search
08:57:54 <desp> er, wrong
08:58:03 <desp> @hoogle Monad m => (a -> m ()) -> [a] -> m ()
08:58:03 <lambdabot> No matches, try a more general search
08:58:04 <ekidd> vincenz: Well, this is the third time I wrote it (first time as a paper, second time on my blog), so I made the mistake of saying, "How hard can this be?"
08:58:20 <desp> @hoogle (a -> IO ()) -> [a] -> IO ()
08:58:21 <lambdabot> No matches, try a more general search
08:58:24 <Saizan> ?type Prelude.sequence_
08:58:26 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
08:58:34 <Saizan> ?type Prelude.mapM_
08:58:36 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
08:58:40 <desp> Saizan: thanks
08:58:40 <dons> http://programming.reddit.com/info/1z3or/comments
08:58:41 <lambdabot> Title: Type families in Haskell - and using them to do things (pdf) (reddit.com)
08:58:57 <dons> i linked directly to the slides (which are also a nice use of the 'beamer' latex style for slides, fwiw, hmm.)
08:59:17 <desp> why is m declared with an explicit kind here?
08:59:37 <Saizan> because it's not *, and ghci likes to specify it
08:59:37 <dons> lambdabot uses -fglasgow-exts for types, which prints the extra type info
08:59:47 <dons> and kinds are nice.
08:59:50 <olsner> > sequence [[1,2],[3,4]]
08:59:50 <lambdabot> Terminated
08:59:59 <dons> oh, that's fixed. i just need to update
09:00:06 <dons> > Prelude.sequence [[1,2],[3,4]]
09:00:07 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
09:00:56 <Saizan> dons: that thing on constraint equality is intentionally vague or what? Elem c1 ~ Elem c2 in merge
09:01:01 <olsner> that's cool.. I was mucking around with cartesian products before, but didn't find that one
09:01:58 <therp> is there any predefined function that takes an element into a singleton list?
09:02:04 <ekidd> dons: Oooh, clever. It's amazing what monad instances will do.
09:02:16 <Heffalump> > return 1 :: [Int]
09:02:17 <therp> hoogling for a -> [a] only give me (replicate 1)
09:02:18 <lambdabot>  [1]
09:02:28 <olsner> > (:[]) 42
09:02:29 <Heffalump> but it's a little obscure, I tend to use (:[])
09:02:29 <lambdabot>  [42]
09:02:38 <Heffalump> or just write it out properly
09:02:43 <therp> ah the monkey operator!
09:02:44 <vincenz> Heffalump: ah the robot smiley :)
09:02:54 <dons> ?quote ninja
09:02:54 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
09:02:56 <dons> ?quote ninja
09:02:57 <lambdabot> SyntaxNinja says: * SyntaxNinja does the type-checking dance ;)
09:03:01 <dons> ?quote monkey
09:03:01 <lambdabot> bfulgham says: I now have trained-monkey-level skills in Haskell.  I can write really bad shootout code (that the real people rewrite correctly), and build stuff like darcs.
09:03:05 <dons> ?quote robot
09:03:05 <lambdabot> No quotes match. You type like i drive.
09:03:08 <dons> doh!
09:03:16 <vincenz> dons: what was up with gcc y'day?
09:03:22 <olsner> @quote operator
09:03:22 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
09:03:29 <dons> vincenz: ghc, you mean?
09:03:35 <vincenz> dons: no, the lacking gcc
09:03:37 <dons> mega serious file server failure. lost data and all
09:03:38 <eis> @yow
09:03:38 <lambdabot> Somewhere in suburban Honolulu, an unemployed bellhop is whipping up a
09:03:38 <lambdabot> batch of illegal psilocybin chop suey!!
09:03:42 <vincenz> ouch
09:03:55 <dons> lucky i use darcs
09:03:59 <dons> distribute your repos!
09:04:08 <dons> ;)
09:05:30 <helmut> dons: Yeah. I got that case, too once. :-)
09:14:44 <monochrom> unemployed bellhop? type-incorrect haskell program? immortal mortal? dark light?
09:16:06 <olsner> :t (let x = x in x)
09:16:08 <lambdabot> forall t. t
09:16:16 <olsner> > (let x = x in x)
09:16:17 <lambdabot>  Exception: <<loop>>
09:16:39 <emu> the only thing that can be type forall t. t is _|_
09:19:13 <olsner> argh, what the heck is forall useful for?
09:19:14 <eis> i'm confused how to convert (IOUArray Int Word8) into (Ptr a)
09:19:25 <eis> so that i can write data to the array through the pointer
09:19:49 <olsner> what's the difference between f :: a and f :: forall a. a?
09:19:50 <ndm> @hoogle IOUArray Int Word8 -> Ptr a
09:19:50 <lambdabot> No matches, try a more general search
09:20:12 <Saizan> olsner: in haskell 98 every type variable is implicitly forall-ed
09:20:13 <ndm> olsner: nothing
09:20:23 <Saizan> ?type map
09:20:25 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
09:29:07 <eis> can something like the IO monad work in a non lazy language?
09:29:33 <Syzygy-> Sure. Why shouldn't it work?
09:29:35 <vincenz> yes
09:29:54 <vincenz> as long as you don't sequence IO actions, they're like statements wrapped in a little bubble
09:30:32 <dons> yeah, you can do it in say, O'Caml. helps to have overloading, and monadic sugar, and some way to delay evaluation (like wrapping in a bubble)
09:30:40 <eis> let a = putStrLn "yes" >> a
09:30:52 <vincenz> eis: that is somethng else
09:31:02 <eis> will i be able to evaluate that expression?
09:31:05 <vincenz> eis: that's whether you can make 'fix' lzy
09:37:33 <olsner> :t interact
09:37:41 <lambdabot> (String -> String) -> IO ()
09:43:10 <olsner> @hoogle ([String] -> [String]) -> IO ()
09:43:11 <lambdabot> No matches, try a more general search
09:43:40 <olsner> @pl interact (unlines . f . lines)
09:43:40 <lambdabot> interact (unlines . f . lines)
09:43:59 <olsner> @pl (\f -> interact (unlines . f . lines))
09:43:59 <lambdabot> interact . (unlines .) . (. lines)
09:44:37 <Syzygy-> That's just echo, isn't it?
09:45:36 <matthew-_> what's the standard solution to the lack of a ChangeLog field in cabal?
09:45:36 <lambdabot> matthew-_: You have 1 new message. '/msg lambdabot @messages' to read it.
09:45:59 <matthew-_> I've ended up adding ChangeLog.txt as an extra src file
09:46:16 <matthew-_> is there a better way? I just want to ensure it goes out with sdist...
09:47:02 <desp> CURLM_OUT_OF_MEMORY,   /* if you ever get this, you're in deep sh*t */
09:54:28 <eis> i've always been suspicious that curl has a lot of ugly code
09:55:17 <olsner> @remember <desp> CURLM_OUT_OF_MEMORY,  /* if you ever get this, you're in deep sh*t */
09:55:17 <lambdabot> Done.
09:55:39 <olsner> perhaps <libcurl> would've been more appropriate as the "originator" of that quote, but whatever
10:18:27 <Heffalump> @tell kowey isn't ghc 6.4.2 the latest 6.4 ghc?
10:18:27 <lambdabot> Consider it noted.
10:46:39 <jfredett> Do there exists any decent tutorials for Data.Tree? or is the Hoogle docs just about it?
10:47:14 <jfredett> s/exists/exist
10:47:47 <Lemmih> jfredett: There's the Haddock documentation.
10:48:19 <jfredett> right- but thats the same as the docs on Hoogle, right?
10:48:31 <jfredett> they're a little cryptic
10:48:42 <jfredett> I was hoping for something a little more straightforward-
10:49:56 <Lemmih> I thought Hoogle was a search tool.
10:50:45 <monochrom> I think the like of "The elements of a tree in pre-order" is clear enough.
10:52:18 <monochrom> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Tree.html
10:52:20 <lambdabot> http://tinyurl.com/29wgup
11:01:45 <jfredett> Lemmih: Well, yes- but I mean the docs linked to by hoogle,
11:01:45 <jfredett> monochrom: thanks, looks significantly easier to follow
11:02:10 <jfredett> I think I must have gotten a bad link to the docs
11:02:34 <jfredett> because the link i followed looked similar- but didn't have half of that information
11:03:38 <eis> http://www.youtube.com/watch?v=iGZXhUeLh90
11:06:17 <LeCamarade> eis: What's it about?
11:06:40 <LeCamarade> :oD
11:06:44 <olsner> haskell on youtube!?
11:06:55 <Saizan> youtube on #haskell
11:07:18 <eis> "Physics Guy Rap"
11:24:03 <jaapweel> I have a question about cabal
11:24:15 <jaapweel> what are reasonable minimum versions to specify for base and parsec?
11:24:24 <jaapweel> I'm using ghc 6.6 myself
11:25:36 <Lemmih> jaapweel: Those packages are pretty stable. Not specifying a minimal version would be fine.
11:25:50 <jaapweel> Lemmih, thanks
11:26:42 <jaapweel> I wrote a module for CSV files; it's a very simple thing, but partially I just wanted something simple to learn to properly use cabal and hackage
11:28:18 <igli> er it is actually preferred to specify a min; 6.6 is very diff to anything before as well
11:28:29 <mattam> "knocked for six" ?
11:28:59 <igli> http://www.peevish.co.uk/slang/a.htm
11:29:01 <lambdabot> Title: A dictionary of slang - "A" - English slang of the UK
11:33:48 <Lemmih> igli: There's no good way of selecting a min version. Much better to just say it has been tested with X, in my opinion.
11:34:13 <Igloo> Yeah, I wouldn't bother going to any effort to find out what the minimums are, just put some in if you get bug reports
11:34:29 <igli> oh sorry thought i was in #gentoo-haskell Lemmih
11:45:45 <cdiggins954> I'm new here, anyone mind if I ask a noob question about GHC?
11:46:36 <Igloo> Ask away!
11:47:43 <cdiggins954> Thanks Igloo. Here is my noob question: "let m f = f (f);;" fails in GHC: "infinite types, yadda yadda yadda". I kind of know what this is all about, it requires a recursive type. I'm wondering if there is anyway to get haskell to infer the types, or if there are Haskell dialects which can handle infering simple recursive types?
11:48:11 <quicksilver> not as far as I know
11:48:23 <quicksilver> there is a nice thread on haskell-cafe explaining why you probably don't want that
11:48:46 <quicksilver> basically, if you infer rectypes then every program becomes well-typed ;) just with an odd type
11:48:55 <quicksilver> so the type-checker doesn't catch errors any more
11:50:28 <quicksilver> http://groups.google.com/group/comp.lang.functional/browse_frm/thread/3646ef7e64124301/2a3a33bfd23a7184?lnk=st&q=ocaml+rectypes&rnum=2&hl=en#2a3a33bfd23a7184
11:50:31 <lambdabot> Title: comp.lang.functional | Google Groups, http://tinyurl.com/ypj9p3
11:50:35 <quicksilver> is one thread on the subject
11:50:51 <eivuokko> Hmm.  I think we call data/newtype that (possibly) contains itsels recursive.  The error is about infinite type, which I dunno how to explain..
11:51:17 <jaapweel> I have a question about hackage
11:51:19 <cdiggins954> quicksilver: thanks a lot for that.
11:51:34 <jaapweel> is there anything special I need to do so that haddock documentation will actually show up on the hackage web site?
11:51:57 <mauke> eivuokko: but the type is not infinite, it just refers back to itself
11:52:01 <jaapweel> I recently contributed some haddock documentation to Audrey Tang's HsSyck, and she stuck it in 0.4, but it doesn't seem to be linked to from hackage
11:53:50 <cdiggins954> quicksilver: however, I have doubt that "every program becomes well-typed" for example: let f = 1 + "hello" remains ill-tyepd.
11:53:54 <eivuokko> mauke, I am not sure the distinction makes much sense in haskell?
11:54:05 <cdiggins954> I can see how recursive types do wident the net of typable terms.
11:54:26 <mauke> cdiggins954: that one already is well typed
11:54:44 <mauke> f has the type [Char]
11:55:34 <cdiggins954> mauke: My ghc just rejected it with: "No instance for (Num [Char]) arising from the literal ...."
11:55:37 <oerjan> @type 1 + "hello"
11:55:39 <lambdabot>     No instance for (Num [Char])
11:55:39 <lambdabot>       arising from the literal `1' at <interactive>:1:0
11:55:44 <mauke> yeah, you need an instance Num [a]
11:56:06 <jaapweel> I think I've found the answer. Apparently you need to include the generated haddock documentation with the package.
11:56:24 <oerjan> @type 1 + 'h'
11:56:25 <lambdabot>     No instance for (Num Char)
11:56:26 <lambdabot>       arising from the literal `1' at <interactive>:1:0
11:56:37 <quicksilver> cdiggins954: yes, true, actually it's "every program in lambda calculus"
11:56:52 <quicksilver> cdiggins954: equating two primitive types does still fail unification
11:57:04 <mauke> > succ 'h'
11:57:05 <lambdabot>  'i'
11:57:07 <quicksilver> cdiggins954: although that particular one doesn't, in haskell :)
11:57:10 <Syzygy-> > (fromInteger 1) + 'h'
11:57:11 <lambdabot>   add an instance declaration for (Num Char)
11:57:11 <lambdabot>     In the expression: (fromInte...
11:58:14 <cdiggins954> quicksilver: would it type the omega combinator as well?
11:58:41 <quicksilver> cdiggins954: yes, I believe so
11:58:53 <quicksilver> you can play with ocaml -rectypes to find out
11:59:01 <mauke> what's omega?
11:59:01 <quicksilver> that is the inference algorithm you're looking for
11:59:19 <cdiggins954> mauke: let omega = m (m);
11:59:30 <cdiggins954> let m f = f (f);
12:00:13 <quicksilver> aka (\x . x x) (\x . x x)
12:00:24 <cdiggins954> quicksilver, I'm using a constrained recursive type in my type inference algorithm that allows me to reject omega, but accepts m.
12:00:25 <oerjan> basically everything has the type a = a -> a, i think
12:01:23 <cdiggins954> quicksilver: I'm calling it a "self" type for lack of a better name, and it is a reference to a function within itself.
12:01:34 <mauke> m :: a@(a -> b) -> b
12:01:53 <mauke> so omega :: b?
12:01:58 <cdiggins954> oerjan: I don't folllow. You mean when we use ocaml -rectypes?
12:02:26 <oerjan> i mean anything in lambda calculus if you allow recursive types
12:02:47 <cdiggins954> oerjan: I see.
12:03:01 <oerjan> but yes, ocaml -rectypes does that, i used it for an Unlambda "compiler" once
12:03:03 <cdiggins954> mauke: I am unfamiliar with the "@" syntax.
12:03:45 <mauke> it's taken from haskell's pattern syntax
12:03:50 <cdiggins954> oerjan: what was the overall experience writing an unlambda compiler?
12:03:52 <dolio> @type let { m :: (forall a. a -> b) -> b ; m f = f f } in m
12:03:54 <lambdabot> (forall a. a -> b) -> b ; m f = f f } in m :: forall b. (forall a. a -> b) -> b
12:04:04 <mauke> var@pattern matches pattern and also binds the value to var
12:04:18 <cdiggins954> mauke: thank you.
12:04:58 <cdiggins954> dolio: thank you.
12:06:02 <oerjan> cdiggins954: i did put it in quotes - it was very simple and not actually faster than an interpreter.  http://oerjan.nvg.org/esoteric/unl2caml/
12:06:04 <cdiggins954> The definition that dolio gave seems to be another solution other without using recursive types. I don't see why we couldn't infer it.
12:06:06 <lambdabot> Title: Index of /esoteric/unl2caml
12:06:20 <dolio> cdiggins954: GHC doesn't infer higher-ranked types.
12:06:42 <dolio> Rank-n inference might be undecidable in general. Not sure.
12:06:43 <cdiggins954> dolio: which language/implementation does?
12:06:58 <cdiggins954> dolio: rank-2 inference is known to be decidable.
12:07:02 <mauke> AFAIK rank-2 inference is complicated but possible
12:07:07 <mauke> rank-n is undecidable
12:07:44 <cdiggins954> rank-2 algorithm: http://citeseer.ist.psu.edu/33675.html
12:07:46 <lambdabot> Title: Rank 2 Type Systems and Recursive Definitions - Jim (ResearchIndex)
12:08:07 <swiert> MLF does arbitrary rank type inference.
12:08:14 <swiert> Although it does sometimes need annotations.
12:08:29 <cdiggins954> oerjan: the unlambda compiler, it would type everything? Was the type inference algorithm still useful?
12:08:31 <dolio> I also don't know if you can give all recursive types a nice rank-2 type, either.
12:08:44 <dolio> We had trouble figuring out the sub-terms of the Y combinator last time this came up, as I recall.
12:09:39 <cdiggins954> dolio: I am fairly sure that you can't give all recursive types a nice rank-2 type.
12:10:00 <cdiggins954> I beleive this is why it is possible to accept m and reject omega.
12:10:17 <cdiggins954> Mind you I am a bit in over my head ;-)
12:10:20 <oerjan> cdiggins954: well Unlambda itself has only one type, which is essentially a@(a -> a)
12:10:26 <chessguy> hi
12:10:30 <chessguy> @seen procyon112
12:10:31 <lambdabot> I haven't seen procyon112.
12:10:45 <chessguy> @tell procyon112 any progress on the class Evolvable?
12:10:46 <lambdabot> Consider it noted.
12:10:54 <dolio> cdiggins954: :) I only know what I've taken in by osmosis sitting around here and such, so I wouldn't worry about it.
12:11:35 <cdiggins954> oerjan: that is interesting about unlambda.
12:12:21 <cdiggins954> oerjan: unlambda is simply the S-K calculus, correct.
12:12:30 <dolio> > let { m :: (forall a. a -> b) -> b ; m f = f f } in m (const 5)
12:12:30 <lambdabot>  Parse error
12:12:36 <SamB> cdiggins954: it is not just that
12:13:01 <Saizan> dolio: '>' has not -fglasgow-exts
12:13:11 <dolio> Ah.
12:13:18 <oerjan> cdiggins954: with some weird add-ons that don't change the basic fact that everything is a function
12:13:38 <SamB> but they do make it impure...
12:13:51 <oerjan> SamB: very much so
12:14:03 <cdiggins954> SamB: I see.
12:14:14 <SamB> I tried to write an interpreter once but I messed up the evaluation order.
12:14:29 <SamB> so I just translated the sample C implementation into Haskell
12:14:32 <SamB> it ran faster!
12:14:57 <cdiggins954> SamB: cool.
12:15:26 <oerjan> i understand the C version was itself translated from the Java one
12:16:34 <SamB> the only explanation I could come up with was that GHC's garbage collector was faster because of (a) being precise and (b) taking advantage of the immutability of the values
12:17:17 <SamB> or maybe it's because, come allocation, it hasn't got to search a free list
12:17:46 <SamB> (the C implementation used libgc)
12:19:06 <cdiggins104> Thanks everyone for their help. I gotta fly, see you around.
12:46:15 <eis> how's everyone doing?
12:48:38 <astrolabe> It's the end of the weekend :o
12:49:11 <eis> shit happens :(
12:49:23 <Saizan> i'm in the middle of finals and i have no will to study :\
12:51:54 <eis> so what will you do?
12:52:52 <Saizan> i think i'll force myself..
12:53:21 <Saizan> and see if the little time that i have is enough
13:22:01 <ddarius> @seen sjanssen
13:22:01 <lambdabot> sjanssen is in #haskell and #xmonad. I don't know when sjanssen last spoke.
13:36:51 <fridim> @hoogle game
13:36:52 <lambdabot> No matches found
13:36:55 <fridim> @hoogle games
13:36:55 <lambdabot> No matches found
13:37:04 <fridim> are there games written in haskell ?
13:37:37 <dgriffi3> @where frag
13:37:37 <lambdabot> http://www.haskell.org/haskellwiki/Frag
13:37:43 <fridim> I can see : http://haskell.org/haskellwiki/Applications_and_libraries/Games
13:37:44 <lambdabot> Title: Applications and libraries/Games - HaskellWiki
13:38:49 <ClaudiusMaximus> > show ((+1)::Int->Int)
13:38:54 <lambdabot>  "<Int -> Int>"
13:39:29 <ClaudiusMaximus> > show (Data.Dynamic.toDyn ((+1)::Int->Int))
13:39:30 <lambdabot>  "<<Int -> Int>>"
13:56:26 <olsner> @quote
13:56:28 <lambdabot> Lemmih says: dons: I'm not exactly sure why my code works. It passed the testsuite so I must be doing something right.
13:56:34 <olsner> @quote
13:56:35 <lambdabot> bos says: algorithm analysis is generally questionable. most of the people who write analyses are analysing the compexity of their own algorithms, and have an axe to grind.
13:56:35 <fridim>  Could not find module `Data.FiniteMap'
13:57:28 <fridim> (i'am trying to compile "mage"
13:57:35 <oerjan> fridim: it has been deprecated
13:57:47 <fridim> oh, ok.
13:57:58 <oerjan> it's Data.Map now
13:59:42 <jaapweel> allright, here's yet another question about cabal
14:00:11 <jaapweel> i understand that for haddock documentation to show up on the hackage web site, i need to include the generated html files along with my source package, in the dist/doc/ directory
14:00:38 <jaapweel> but when I build a tarball with runhaskell Setup.hs sdist, the tarball omits the entire dist/ part of the tree (probably correctly)
14:00:48 <jaapweel> so do I have to manually add those files to the tarball somehow then?
14:22:09 <cdsmith> If dons is here, thanks for posting the presentation about type families to reddit.  Cool stuff.
14:22:22 <jaapweel> hmm... well, i finished uploading http://hackage.haskell.org/cgi-bin/hackage-scripts/package/csv , without documentation links, because I can't figure it out
14:31:06 <ClaudiusMaximus> @src maybe
14:31:06 <lambdabot> maybe n _ Nothing  = n
14:31:06 <lambdabot> maybe _ f (Just x) = f x
14:32:58 <ClaudiusMaximus> @pl \f x -> x f
14:32:58 <lambdabot> flip id
14:33:59 <Heffalump> Igloo++ # Cabal -> .deb instructions
15:08:36 <matthew-_> ok, so, GHC Head, dual core opteron. Given application compiled with -threaded, application does two forkIOs and has two threads with work to do running concurrently. Run with +RTS -N2, but top shows only one of the cpus is in use. Any ideas?
15:09:24 <eis> if you do two forkIOs won't you have 3 threads?
15:09:31 <matthew-_> yep
15:09:41 <matthew-_> one of them is blocking, waiting for the other 2 to finish
15:10:04 <matthew-_> and I've tried -N3 and no change
15:10:07 <eivuokko> Do they share data?
15:10:24 <matthew-_> yep, via a structure that's like a Chan
15:10:34 <matthew-_> and one's producing and one's consuming
15:10:44 <matthew-_> and I've just realised I'm running the wrong test...
15:10:45 <matthew-_> grrrrrrr
15:11:13 <matthew-_> sorry for wasting your time - in the test I'm running, the two threads move in lockstep, so it's not surprisng only 1 cpu is loaded...
15:11:57 <eis> i'm interested in running multithreaded haskell programs on multi cpu computers
15:13:07 <matthew-_> mmm. although, I've just switched to the right test, where one thread is the producer and the other consumes
15:13:12 <matthew-_> and it's the same story...
15:13:45 <matthew-_> mmm. one core is totally idle.
15:14:52 <eivuokko> I think RTS has some debugging/reportin towards thread scheduling.
15:15:07 <chadz> matthew-_: they're runtime threads, i think you're not going to see them behave the same way (especially in top) as os threads
15:15:36 <chadz> matthew-_: even though i think i remember -threaded should do more for you
15:15:46 <chadz> i may be wrong, someone please correct me
15:16:13 <chadz> performing forkIO n times will still show 1 process in top/ps
15:16:47 <matthew-_> well, my understanding is that the -RTS -Nx option will produce x OS-level threads
15:16:53 <eivuokko> Yeah
15:17:07 <matthew-_> which work through the available Haskell-threads as and when they can be reduced
15:17:37 <matthew-_> so if you have Haskell threads (via forkIO) that have work to do, 2 cores and +RTS -N2
15:17:44 <matthew-_> then you should see loading on both CPUs
15:17:59 <matthew-_> one CPU shouldn't be saying 99.9% idle...
15:18:05 <chadz> hmm. sure one's not blocked?
15:18:18 <matthew-_> chadz, there's a producer and a consumer
15:18:33 <matthew-_> I can make the consumer sleep for 5 secs before it starts work
15:18:34 <chadz> and there's something to consume?
15:18:49 <matthew-_> the producer has produced about 85,000 items in that time
15:18:54 <matthew-_> there's work to be done!
15:19:03 <eivuokko> Maybe you could try +RTS -vs?
15:19:26 <eivuokko> But I am not sure if you have to recompile with debug or something.
15:19:37 <chadz> matthew-_: no deadlock ?
15:21:01 <matthew-_> chadz: no deadlock - they're both making progress
15:21:31 <matthew-_> eivuokko: the -vs does produce a lot of output - I have a 20MB log file in no time!
15:21:59 <eivuokko> -.-
15:22:04 <chadz> matthew-_: you're set up for smp, right? :D
15:22:38 <chadz> ugh, I want a machine with n>1 processors.
15:23:05 <eivuokko> matthew, dunno, can't think much else you can do to debug it, except ofc tracing stuff yourself.
15:23:18 <matthew-_> eivuokko: the log shows two workers
15:23:42 <eivuokko> I am not really sure if you can be stuck like that with sharing lazy data, isn't that sort of sharing a busyloop...
15:23:54 <titusg> I have installed the latest Yi on GHC 6.6 without any apparent errors but I can't run it - the error includes "Could not compile Yi.main"...where would be the best place to ask for help on this?
15:24:46 <matthew-_> actually, there are 5 workers.
15:25:00 <matthew-_> so that'll be 3 for me, 1 GC and I guess a signal handler?
15:25:30 <eivuokko> Uh, does head have that sort of GC?
15:25:39 <matthew-_> dunno
15:25:40 <matthew-_> 70795 0x40800940, 4 0x41001940, 70771 0x41802940, 2 0x42003940, 1 0x42804940
15:25:43 <eivuokko> I thought the GC stops all threads.
15:25:50 <matthew-_> oh ok, I'm guessing
15:25:51 <eivuokko> Well, the major anyway
15:26:08 <matthew-_> the 0x is the worker id, the other number is the number of times that id appeared in the log
15:26:25 <ndm> @seen sorear
15:26:25 <lambdabot> sorear is in #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell. I last heard sorear speak 11m 24s ago.
15:26:30 <sorear> hi\
15:26:55 <ndm> sorear, what are you hoping to do with Yhc.Core? We currently haven't done much with primitives, but if you want it, its something we intend to do (plus its not too hard)
15:27:12 <ndm> we just left it until we had a user, otherwise you r un a real risk of picking a horrible design because you don't have a user
15:27:27 <araujo> hello
15:28:02 <sorear> ndm: Re-check your mailbox, I was about 2 words away from finishing my reply when you pinged :)
15:29:14 <ndm> sorear, in future send to ndmitchell -at- gmail rather than ndm, otherwise i have a 2 minute delay on my email
15:29:20 <sorear> also, imagine the possibility of 'foreign import javascript "abs(a)" js_abs' instead of 'js_abs a = unsafeJS "abs(a)"' ...
15:29:26 <sorear> ndm: ok
15:30:11 <ndm> sorear, we want to fully express primitives, and are happy to modify the syntax in whatever way that requires
15:30:29 <ndm> sorear, i recently added CorePrim specifically so we have somewhere to put this additional information
15:30:38 <sorear> cool
15:30:51 <ndm> do you want to knock up a design?
15:30:58 <ndm> i've never used the FFI features in Haskell, so have no idea what needs including
15:31:13 <ndm> Tom was talking about extending it so we can use Yhc.Core as the Core language in Yhc
15:33:03 <ndm> sorear, teh reason we didn't do javascript imports properly is because changing the front end of Yhc is painful, once we had it going properly, that is an option
15:33:31 <ndm> plus, if you use Yhc.Core as your intermediate form, then Reach/Catch can make use of it
15:33:58 <sorear> Reach?
15:34:57 <eis> i'm interested in the yhc javascript output
15:35:00 <ndm> the quickcheck property prover
15:35:09 <ndm> eis, i don't know much about it, but it does work
15:35:33 <ndm> there will be a paper on Reach in September, and a release hopefully within a month
15:35:34 <sorear> ndm: (How) are types represented in Yhc.Core?  I know expressions don't have types, but what about data Foo = Foo Int - (how) is the Int stored?
15:36:00 <ndm> look at CoreData
15:36:19 <sorear> ndm: There are no haddock comments.  All I see is String
15:36:35 <ndm> hmm, perhaps just as a String then
15:36:41 <sorear>   coreCtorFields :: [(String, Maybe CoreFieldName)]     in context
15:36:44 <ndm> again, we'd be happy to change that
15:36:59 <ndm> we didn't jump so far as we have no ohter types
15:37:13 <ndm> but quite a few places "half parse" those type declarations, so it makes sense if we do
15:39:55 <sorear> ndm: I also see a lot of code in Core that looks like it would be well done with Derive and/or Uniplate :)
15:40:09 <ClaudiusMaximus> @users
15:40:09 <lambdabot> Maximum users seen in #haskell: 328, currently: 312 (95.1%), active: 43 (13.8%)
15:40:12 <sorear> isCoreFoo most egregiously
15:40:25 <ndm> sorear, yes, the plan is to move to Derive once we get round to it
15:40:35 <ndm> sorear, but it does have Uniplate support already
15:41:56 <sorear> eis: Yeah, there is a standalone Yhc.Core -> Javascript converter.  Very standard spineless-G implementation, nothing fancy.
15:43:10 <matthew-_> eivuokko, chadz: weird. With -N2 -V1 -C10, I occasionally see %CPU go to 141, but generally it stays at 100%. But more interesting is the fact that the CPU summaries show that only about 40% is user, and the rest, when not idle, is System.
15:43:37 <matthew-_> I guess that must be a lot of mallocs/free on shared mem?
15:44:26 <sorear> Or sleep etc.
15:44:53 <eivuokko> I don't know about unixes, in Windows it could be a number of things.
15:45:30 <sorear> matthew-_: what's in your loops?
15:46:11 <matthew-_> sorear: one is writing to a chain of MVars - very much like a Chan
15:46:13 <matthew-_> the other is reading
15:46:25 <sorear> Chain of MVars?
15:46:27 <matthew-_> the strace shows endless futexs
15:46:32 <sorear> and what are you storing?
15:46:35 <matthew-_> ints
15:46:42 <matthew-_> and it's not strict
15:46:51 <sorear> does calculating these ints take a long time?
15:46:53 <matthew-_> no
15:47:09 <matthew-_> it's literally +1 each time
15:47:48 <sorear> fix $ \f n -> writeChan c n >> f (n+1)
15:47:49 <sorear> ?
15:48:15 <sorear> and how much code is in the consumer?  you shouldn't be doing that much communication
15:48:15 <matthew-_> well, in rather more words, but yes
15:48:35 <oerjan> a thought: is the producer doing any significant work other than filling the chain with unevaluated int thunks?
15:48:38 <matthew-_> consumer would be the obvious dual doing readChan
15:48:52 <matthew-_> (though readChan only readMVars, I actually takeMVar)
15:49:05 <matthew-_> nothing significant
15:49:06 <sorear> matthew-_: [1..] has no consumer dual?
15:49:44 <oerjan> then the consumer actually does that evaluation work, i guess...
15:49:48 <matthew-_> err, fix $ \f () -> readChan c >> f ()
15:49:56 <ndm> http://www.cs.york.ac.uk/fp/darcs/cabal-o-matic/
15:49:59 <lambdabot> Title: Cabal-O-Matic
15:50:10 <ndm> what do people think of that? not finished yet, not all the fields added, but a start
15:50:29 <matthew-_> the only other thing going on in the loop is that every 10,000 times through they print out progress to stdout
15:50:58 <sorear> http://members.cox.net/stefanor/1182120590.png
15:51:06 <sorear> very informative front page there :)
15:51:20 <ndm> sorear - Firefox and Safari only
15:52:00 <sorear> ndm: What would the point of that be?
15:52:25 * sorear assumes this is just like dons' mkcabal - is he wrong?
15:52:52 <ndm> sorear, its a GUI for that, in a web browser, with a nicer interface
15:53:12 * sorear is looking at the page source, and sees a whole lot of javascript but still has no clue what it's supposed to do...
15:53:15 <sorear> oh.
15:53:23 * sorear recommends <noscript>
15:55:08 <ndm> http://www.cs.york.ac.uk/fp/darcs/cabal-o-matic/demo.png
15:55:18 * ndm adds noscript, and there is a demo screenshot
15:55:28 <Igloo> Is BSD4 one of the licences Cabal knows about? We should fix it if so
15:55:40 <ndm> Igloo, it is
15:56:09 <Igloo> It's silly to have a licence that probably no Haskell software has ever used, and that we don't want people to use
15:56:36 <sorear> ndm: It could use more documentation :)  the tab names mean nothing to me, and the left one isn't self-explanitory
15:57:06 <ndm> sorear, its designed to be discoverable by use, but i can fix those bits easily enough
15:57:10 <ndm> sorear, now with a noscript tag!
15:57:43 * Igloo calls my licence files COPYING FWIW. Avoids LICENSE/LICENCE arguments too  :-)
15:57:48 <sorear> ndm: It works fine in my FF.  just I'd like to be prompted when FF is needed.
15:58:02 * sorear normally runs elinks, which is about ten times faster
15:58:05 <jaapweel> MIT should be one of the possible licenses, though
15:58:16 <matthew-_> MIT is 3-clause BSD isn't it?
15:58:19 <jaapweel> It's what is used for HsSyck, and we had to make it "Other" or some such option because it wasn't available
15:58:29 <jaapweel> no, it's the same as theX
15:58:33 <jaapweel> X license, sorry
15:58:35 <ndm> sorear, fair enough - i forgot that not everyone uses Firefox
15:58:52 <ndm> Igloo, base seems to always use LICENCE though?
15:58:57 <matthew-_> ahh, cabal people, how do you make sdist include a "ChangeLog.txt" file?
15:59:03 <Igloo> jaapweel: Why do you prefer MIT to BSD3?
15:59:06 <jaapweel> http://www.faqs.org/docs/artu/ch19s05.html#id3014860
15:59:07 <lambdabot> Title: Varieties of Open-Source Licensing
15:59:28 <jaapweel> I don't particularly like the MIT license, but Audrey picked it, and I think it's common with Perl folk
15:59:35 <Igloo> ndm: True (modulo spelling)
15:59:57 <sorear> ndm: Strange.  I can see the noscript tag in the source view, but the text isn't visible...
16:00:07 <jaapweel> I personally prefer to hit the evil proprietary software corps with strong copyleft ;-)
16:00:24 <ndm> sorear, weird... IE is having issue with it too
16:00:40 <swiert> motthew-_: extra-source-files
16:00:42 <sorear> ndm: though it doesn't matter much, one quickly gets the habit of flipping into highlighted-html mode ('\' key) at the first hint of rendering problems
16:00:52 <swiert> *matthew-_  even
16:00:59 <matthew-_> swiert: yeah, that's all I came up with. Seems somewhat "wrong" though.
16:02:15 <swiert> I think that's how your supposed to do it. Readme's etc. all go under there.
16:02:22 <matthew-_> oh ok, I didn't know that.
16:02:25 <chadz> hmm -- i'm going to write some gallery software to manage a webalbum.
16:02:39 <chadz> any interest? :D
16:02:56 <matthew-_> that's a reasonably round wheel already, chadz.
16:03:14 <notsmack> chadz: any interesting ideas beyond that?
16:03:16 <chadz> what isn't anymore?
16:03:39 <jaapweel> actually, given the existence of F#, it's not entirely impossible that at some point in the distant future, Microsoft will do something with Haskell outside of its open-source friendly research arm. They used a nasty shared source license for F#, and I think it would be a good idea if there were some crucial Haskell bits and pieces under GPL/LGPL so that Haskell cannot be embraced-and-extended into a "shared source" project. (To MS'
16:03:39 <jaapweel> s credit, I think they actually reimplemented everything for F#.)
16:03:54 <lumi> A shooting gallery web album?
16:04:00 <matthew-_> chadz: typesetting. I would argue there is a real need to replace LaTeX, but the man-hours needed makes that really hard.
16:05:03 <chadz> matthew-_: ah, just use the dom? hehe
16:05:24 <ndm> i agree, Latex does need killing
16:05:30 <ndm> something in Haskell would be perfect
16:05:32 <chadz> notsmack: i'd like something that maintained a gallery -- you place raw/jpgs in somewhat of a respository
16:05:51 <matthew-_> ndm: I think bits of it might be better in a pure constraint satisfaction language
16:05:59 <chadz> notsmack: and it'll maintain thumbnails, resizing, exif info, etc.
16:06:24 <matthew-_> ndm: I like LaTeX - it makes good output and I'm competant at using it, but it really does have a lot of warts and not a lot of purity
16:06:44 <ddarius> There's a Common Lisp LaTeX-alike.
16:06:48 <jaapweel> matthew-_, it's a weird situation. TeX is one of the very few sizeable software systems implemented pretty much without any bugs, but many of the design decisions are way outdated and trace back to memory limitations decades back. but to overcome the activation energy you have to live up to the quality of Don Knuth's freakishly well documented and debugged code...
16:07:24 <jaapweel> (I'm referring just to TeX and METAFONT when I say well documented and debugged, not to LaTeX and all the other assorted bits and pieces)
16:07:57 <matthew-_> right, bed time. night.
16:08:22 <MyCatVerbs> Hrmn. It's theoretically possible to make web frameworks that make things like SQL injection and XSS impossible by using the type system to distinguish between safe and unsafe inputs, right?
16:09:18 <jaapweel> don't even think it's that hard, at least in the case of SQL injection, if you construct all your SQL queries with combinators or macros rather than pasting strings together
16:09:29 <jaapweel> I believe there is at least one SQL interface for Haskell that does just that
16:09:42 <notsmack> MyCatVerbs: but sure, it is
16:09:55 <Saizan> taint monad?
16:09:58 <MyCatVerbs> jaapweel: oh, cool.
16:10:12 <jaapweel> not sure about XSS, it seems to refer to a set of bugs that is still expanding over time
16:10:16 <MyCatVerbs> Saizan: nah, but that'd work too.
16:10:40 <ddarius> http://www.fractalconcept.com/asp/cl-typesetting
16:10:43 <lambdabot> Title: Fractal Concept : CL-Typesetting home page
16:10:58 <chadz> what's the most proliferant xml library, haxml ?
16:11:17 <jaapweel> ddarius, neat
16:11:47 <jaapweel> chadz, haxml and hxt actuall do somewhat different things
16:11:50 <sorear> http://svn.openfoundry.org/pugs/Pugs.cabal.in
16:11:53 <MyCatVerbs> Was thinking more like defining unSafeString and various safeString types, not exporting the constructors and using functions with sigs like escapeHTMLChars :: unsafeString -> safeString.
16:12:05 <sorear> http://hackage.haskell.org/trac/c2hs/browser/c2hs.cabal
16:12:06 <lambdabot> Title: /c2hs.cabal - c2hs - Trac
16:12:14 <sorear> http://hackage.haskell.org/packages/archive/yi/0.2/yi.cabal
16:12:37 <jaapweel> haxml parses DTDs and then generates code to deal with XML in a strongly typed way, where the Haskell type checker will play XML validator for you
16:13:21 <jaapweel> hxt treats XML of all Schemas as belonging to the same type, which trades in some of the typechecking, but has a very neat framework for writing XML code that is generic and can operate on documents of different schemas
16:14:06 <jaapweel> also, the haxml DTD compiler chokes very badly on very large DTDs. I ran it once on a large DTD, and it came up with several megabytes of Haskell source, which in turn when I fed them to ghc overheated my CPU...
16:14:19 <sorear> darcs-monitor, darcs-graph, lambdabot, hoogle, hsutils, Related, arch2darcs, RBR
16:14:26 <chadz> jaapweel: heh.
16:14:51 <sorear> jaapweel: jhc is much better at that ime :)
16:15:03 <sorear> atkrec,
16:15:25 <jaapweel> sorear, yeah, I never dared run it. John Meacham is a nice enough guy, but he has a much better computer than I do
16:16:02 <sorear> http://www.google.com/search?hl=en&ie=ISO-8859-1&q=%22license%20gpl%22%20inurl%3acabal
16:16:17 <lambdabot> Title: "license gpl" inurl:cabal - Google Search, http://tinyurl.com/ywczxj
16:16:30 <sorear> jaapweel: ^^^
16:17:00 <sorear> jaapweel: I think lambdabot is pretty critical Haskell infrastructure :)
16:17:16 <jaapweel> yep! can't do without it ;-)
16:17:30 <ddarius> It's surprising how much impact lambdabot has had.
16:17:42 <chadz> hmm, i haven't done much work with XML at all. I'm thinking I could use something such as HXT to maintain some db/state of an album and then export XML documents to a directory that in turn could be served by a webserver -- is this reasonable?
16:18:08 <jaapweel> I missed some of the earlier discussion. why exactly do you need to use XML?
16:18:25 <DRMacIver> All applications need XML.
16:19:00 <jaapweel> if you are not constrained by external standards, you may want to consider using something simpler, like YAML. XML tools tend to be kinda big and clunky.
16:19:06 <ddarius> putStrLn "<greeting>Hello World</greeting>"
16:19:27 <sorear> chadz: Or better yet, Read/Show
16:19:31 <DRMacIver> jaapweel: But you should always use standards. Remember: Standard is way more important than useful. ;)
16:19:35 <Saizan> ddarius: you forgot the preamble!
16:20:07 <jaapweel> DRMacIver, YAML is perfectly well standardized. there is a very pretty standards document with lots of attention to character encodings and suchlike, and libraries that implement it for lots of languages
16:20:40 <Saizan> "that in turn could be server by a webserver" <-- so xml+xsl is a reasonable choice, if you don't want some template library for the html
16:20:42 <sorear> S-expressions have been standard for much longer than XML.
16:20:45 <jaapweel> I'm not sure it has the imprimatur of some acronymed agency, but the standard seems to be RFC quality
16:21:06 <jaapweel> sorear, they have been standard as in used a lot, but unfortunately there is no one clear standard for their syntax that is widely adopted
16:21:12 <DRMacIver> jaapweel: But XML is more standard because it's enterprisey.
16:21:27 <jaapweel> DRMacIver, yes! enterprisey! just like Haskell!
16:21:35 <DRMacIver> jaapweel: Exactly!
16:21:53 <DRMacIver> jaapweel: In case you haven't picked it up by now, I really hate XML and am not actually advocating its use. ;)
16:22:09 <sorear> jaapweel: Eh? there are incompatible extensions, sure, but () atoms and numbers work everywhere
16:22:37 <jaapweel> Saizan, there's a point to that. personally, I would prefer to write tree->tree transformations in a real functional languages rather than XSLT, but then again, I am prone to tendinitis, and apparently the XSLT people aren't
16:23:24 <chadz> jaapweel: yah -- i'm going to write some silly little app to generate webalbums from a directory of images; yet I really don't know much about applications of XML and libraries associated with them
16:23:25 <jaapweel> sorear, case-sensitivity is not standardized across Lisps, nor is whether you have bignums or just fixed size integers
16:23:30 <notsmack> how do s-exp people handle validity checking?
16:24:03 <jaapweel> notsmack, they don't; s-expressions are mostly used with lisp, which is quite radically dynamically typed
16:24:05 <sorear> notsmack: Read fails if the parens aren't balanced
16:24:10 <jaapweel> sorear, true, true
16:24:17 <notsmack> sorear: i said validity, not well formedness...
16:24:22 <sorear> notsmack: everything beyond that is semantics.
16:24:32 <sorear> notsmack: XML can't validate semantics either
16:24:43 <jaapweel> notsmack, well, in the case of S-expressions, there's only one type, which is the-one-lisp-type
16:24:45 <lumi> Saizan: It's not a preamble, it's a prolog!
16:24:50 <jaapweel>  it's perfectly typesafe, just not very informative
16:25:20 * sorear dares notsmack to construct an XML schema of GHC Core (note, it must be impossible for core lint to fail)
16:25:30 <sorear> Oh wait.
16:25:38 <sorear> I suppose XSL is turing complete?
16:25:53 <notsmack> yep
16:26:04 <jaapweel> http://www.unidex.com/turing/utm.htm
16:26:05 <lambdabot> Title: Universal Turing Machine in XSLT
16:26:16 <sorear> jaapweel: XSL, not XSLT.
16:26:22 <notsmack> but i don't see how that dare relates to chadz' problem, wherein it would be nice to have assured structure...
16:26:33 <Saizan> jaapweel: yup, it's quite verbose, maybe we need an haskell dsl to generate xsl :) it feels silly tough..
16:26:34 <sorear> XML Schema Language
16:26:35 <jaapweel> sorear, oops
16:27:27 <jaapweel> that's the newfangled variety of DTD, right?
16:28:19 <sorear> yeah
16:35:37 <jaapweel> it seems that hsffig (one of the FFI generators) was motivated largely by the need for an FFI interface to new-style (Sleepycat/Oracle) Berkeley DB, which uses lots of structs with function pointers in them; but it hasn't yet let to a new-style berkeley DB binding. I can't quite get it to work right, it seems much more fussy about header files than c2hs is. I'd like an interface to new-bdb, though...
16:36:01 <jaapweel> anyone got thoughts on what FFI tools deal best with funky uses of function pointers by a C library?
16:36:21 <jaapweel> s/yet let/yet led/
16:38:20 <chadz> I think it was HaPPs that had methods for serializing datastructures out to XML, what was that using?
16:39:39 <Saizan> chadz: haxml
16:39:41 <notsmack> chadz: HAppS uses HaXmL
16:39:47 <notsmack> Saizan: beat me to it
16:40:18 <Saizan> notsmack: you've lost time getting the capitalization right :)
16:43:48 <jaapweel> there is code in pugs that serializes data structures into YAML and back
16:44:00 <sorear> Yes?
16:44:00 <Saizan> i've TH code to generate Haskell <-> XML functions with HXT
16:44:08 <jaapweel> yes, it uses drift
16:44:11 <sorear> I'm sure it uses HsSyck?
16:44:22 <jaapweel> I believe so
16:44:27 <jaapweel> I looked at it a day or two ago
16:44:33 <sorear> jaapweel: we need to standardize on MY derivation lib! :)
16:44:41 <sorear> well mine and ndm's
16:44:52 <jaapweel> HsSyck was lifted out of the pugs tree and relicensed
16:45:00 <jaapweel> sorear, Data.Derive?
16:45:10 <sorear> jaapweel: that's the one...
16:45:36 <jaapweel> I'm sure you could get the pugs people to relicense the YAML serialization drift module as something other than GPL if you pulled it out into a nice cabalized library for them
16:45:58 <sorear> jaapweel: Uhm... why?
16:46:23 <sorear> jaapweel: Data.Derive is used only at build time.  it can be GPL and it won't affect anybody
16:46:27 <jaapweel> why am I sure? because they've been working on pulling out generally useful bits from the pugs tree and turning them into libraries.
16:46:45 <jaapweel> what is GPL here is the module from pugs i'm referring to, not data.derive, and not drift
16:46:45 <sorear> jaapweel: no, why would I want it !GPL
16:47:00 <jaapweel> ah, you're saying that because it's a code generator it wouldn't matter
16:47:09 <jaapweel> that might be true, hadn't thought of that
16:47:49 <jaapweel> but aside from the licensing, there was a bit of a move toward pulling generally interesting bits out from pugs and turning them into libraries
16:47:52 <jaapweel> hence HsSyck
16:48:31 <jaapweel> it may take a little work here and there if they depend on internal pugs utility functions that you don't want to pull into the library, but in this particular case there are only 2 of those
16:48:35 <Saizan> ?hackage hssyck
16:48:35 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/hssyck
16:48:41 <jaapweel> which do something with utf8
16:49:02 <sorear> jaapweel: which needs to be a library itself!
16:50:03 <jaapweel> sorear, yes, it probably should be. there is some UTF8 handling code in one of John Meacham's projects that would make a good library, i think, and in this particular case, the iconv binding might actually do the same job as that particular pugs function
16:50:50 <jaapweel> http://svn.pugscode.org/pugs/src/DrIFT/YAML.hs
16:51:06 <jaapweel> the culprits are import Pugs.Internals (encodeUTF8, decodeUTF8, addressOf, safeMode)
16:51:24 <jaapweel> and import qualified UTF8 as Buf
16:51:46 <jaapweel> the
16:52:20 <jaapweel> the latter being a self-contained BSD licensed module with haddock comments and all that could be readily cabalized, i believe, but really ought to be part of the standard bytestring stuff
16:52:40 <jaapweel> http://svn.pugscode.org/pugs/src/UTF8.hs
16:59:24 * araujo wonders if anyone would have a server with some free space to share with a darc repo
17:01:08 <ddarius> darcs.haskell.org
17:02:37 <Saizan> http://twan.home.fmf.nl/compact-string/doc/html/Data-CompactString.html <-- we have this for bytestrings
17:02:39 <lambdabot> http://tinyurl.com/2993hq
17:06:17 <jaapweel> araujo, the way that darcs works, you can in principle use some readily available svn hosting, like google code or sourceforge, and have a _darcs directory checked into svn. i'm not sure that's ideal and i've never tried it, though.
17:07:28 <araujo> jaapweel, yeah, i know there exist such a workarounds ... i would like something straight though
17:07:49 <araujo> ddarius, i already have an account there ... but i need to host a non-haskell related project
17:07:51 <araujo> so ...
17:08:49 <stepcut> araujo: how about https://www.nearlyfreespeech.net/ ? (I have no experience with that site, btw)
17:09:24 <araujo> i check
17:11:42 <jaapweel> hmm... i wonder how far you'd get with http://freeshell.org/
17:12:21 <jaapweel> you can get a shell account and a web page with CGI, more or less like a traditional user account at a CS department UNIX server
17:12:36 <jaapweel> but that's really all you need for darcs, no?
17:12:50 <araujo> well .. they need to have darcs installed too right?
17:13:07 <jaapweel> not last time i checked, they don't
17:13:36 <sjanssen> having darcs already is much more convenient
17:13:43 <sjanssen> but you can do things with rsync/ftp/scp
17:14:03 <jaapweel> sjanssen, whatever happened to Data.Bytestring.UTF8?
17:14:06 <araujo> sjanssen, yeah , i can use scp .. it's what i am actually using ....
17:14:18 * araujo would like darcs installed in the host though
17:14:24 <araujo> i wonder if i am asking for too much :-P
17:14:50 <jaapweel> sjanssen, I found it in the pugs tree, but it doesn't seem to be in the standard Bytestring thingamajigger
17:29:17 <chadz> as for the final question here: http://www.haskell.org/haskellwiki/HXT#Selecting_text_from_an_HTML_document (at the end of the document), what would you all say?
17:29:22 <lambdabot> Title: HXT - HaskellWiki, http://tinyurl.com/277hfo
17:30:09 <Cale> chadz: You mean in a generic fashion? (I'm not familiar with HaXml)
17:31:08 <chadz> Cale: yah, well.. generic enough to support the types I define
17:31:23 <sorear> re.
17:31:45 <Cale> Of course, you can just write functions yourself which produce XML trees from data. If you want to do it in a more generic way, perhaps there's a way to use Data.Generics.
17:33:07 <jaapweel> yeah, I thought about that. I think it could be done, but it would be slower than using Data.Derive/DrIFT, no?
17:33:30 <jaapweel> (not sure it would be *much* slower, but it seems you would do more at runtime and less at compile time)
17:33:32 <sorear> huh, that's odd
17:33:37 <sorear> 17:32 < jaapweel> yeah, I thought about that. I think it could be done, but it would be slower than using Data.Derive/DrIFT, no?
17:33:50 <sorear> ^^^ irssi beeped and highlighted that
17:34:05 <jaapweel> hmm, wacky
17:34:24 <jaapweel> it must dislike StuDLYCaPS even more than I do
17:35:06 <jaapweel> yeah, I thought about that. I think it could be done, but it would be slower than using Data.Derive/DrIFT, no?
17:35:10 <jaapweel> did it beep again?
17:35:14 <sorear> yup
17:35:29 <sorear> oh, heh.  I had data.derive -fullword in my /hilight list
17:35:54 <jaapweel> that would do it
17:38:15 <Cale> chadz: Ah, HaXml does it by using a class called XmlContent. It wouldn't be so hard to replicate that.
17:40:01 <chadz> Cale: and doens't DrIFT generate that?
17:40:21 <Cale> I don't know much about DrIFT myself.
17:42:24 <dcoutts> jaapweel: there is no standard Data.Bytestring.UTF8, though it may appear eventually as Data.PackedString or something
17:51:38 <chadz> what's the difference beween darcs and cabal build files?
17:52:02 <chadz> (what should I use if im using cabal to build a package I downloaded from darcs?)
17:52:34 <sorear> chadz: darcs doesn't have build files
17:53:01 <chadz> oh wait -- i'm stupid.
17:54:41 <jaapweel> dcoutts, would it hurt to take the Data.Bytestring.UTF8 that apparently made its way into pugs and turn it into a self-contained library, for the time being?
17:55:22 <dcoutts> jaapweel: I've no idea what's in pugs's Data.Bytestring.UTF8
17:55:35 <dcoutts> is it a full list api or just a couple conversion functions?
17:55:38 <jaapweel> http://svn.pugscode.org/pugs/src/UTF8.hs
17:55:48 * dcoutts takes a look
17:55:54 <sorear> jaapweel: Uhm, that's not data.bytestring.utf8
17:56:00 <sorear> jaapweel: that's UTF8, says the URL
17:56:33 <jaapweel> sorear, that's the file name, but the module name is Data.Bytestring.UTF8
17:56:43 <sorear> False
17:56:50 <jaapweel> weh
17:56:50 <dcoutts> but it doesn't really matter
17:56:56 <jaapweel> the haddock documentation modul ename is that
17:56:59 <sorear> jaapweel: anything starting -- is a comment in haskell
17:57:02 <jaapweel> the actual haskell module name is omething else
17:57:04 <jaapweel> I know
17:57:08 <jaapweel> i'm sleepy...
17:57:44 <jaapweel> and then there's *another* comment that refers to Data.Bytestring.Char8
17:58:08 <jaapweel> i'll need to go and get some sleep before coming back and asking more stupid questions ;-)
17:59:18 <jaapweel> it even says it was written by Martin Norback and not Spencer Janssen (admittedly in a comment)
17:59:27 <jaapweel> so i'm doubly wrong
18:02:21 <dancor> i do: openFile, c <- hGetContents, putStrLn c, hClose, return c.  that works.  if i take out putStrLn then return c gives me ""
18:02:25 <dancor> is this expected
18:02:38 <Cale> dancor: yes
18:02:40 <sorear> yes
18:02:47 <notsmack> dancor: laziness
18:02:50 <Cale> dancor: If you use hGetContents, don't use hClose
18:02:55 <dancor> ever?
18:02:57 <Cale> right
18:03:05 <dancor> is that good practice
18:03:08 <Cale> The file will close when you're finished reading the string.
18:03:15 <Cale> (It's magic)
18:03:21 <sorear> dancor: NEVER close the handle used by hGetContents, it will need to use it at unpredictable times
18:03:38 <dancor> sorear: what if i needed to guarantee i wasn't reading a file at some point
18:03:49 <slava> sorear: somehow that is scary :)
18:03:59 <sorear> dancor: There are no guarantees with hGetContents, period.
18:04:01 <Cale> If you close the handle, the string ends up being what had been evaluated of it up to that point in time.
18:04:04 <slava> are you saying that if the compiler optimizes away code which works with the result of hGetContents, the file handle won't be closed at all?
18:04:13 <sorear> slava: Yup.
18:04:23 <slava> ouch
18:04:41 <sorear> slava: There are good reasons you shouldn't use hGetContents in resource-critical code :D
18:04:46 <sjanssen> finalizers ensure that the handle is closed
18:05:02 <sjanssen> but you get zero guarantees on when
18:05:03 <Cale> If the string gets GC'd, I think it'll close the handle.
18:05:04 <dancor> could you use seq?
18:05:04 <slava> you might run out of file handles before running out of heap
18:05:05 <sorear> well, if you drop the lisp
18:05:15 <Cale> dancor: yep
18:05:17 <sorear> slava: Yes...
18:05:25 <Cale> dancor: Along with Control.Exception.evaluate
18:06:35 <Cale> dancor: evaluate (foldr seq () xs)
18:06:47 <Cale> will ensure that the entire file is read
18:07:01 <Cale> But you probably shouldn't have to do that.
18:07:18 <Cale> Unless you're planning on doing something like destroying the file on disk that you're reading from.
18:08:02 <Cale> (It'll also end up closing the handle, so you still shouldn't have to hClose)
18:14:25 <Pseudonym> OK, might as well ask here.  Does anyone know anything about Kalman filtering?
18:14:32 <Pseudonym> I'm sure SOMEONE does, just possibly not here.
18:17:08 <ddarius> I looked it up a long time ago but have since forgotten the details.
18:17:24 * Pseudonym nods
18:17:32 <Pseudonym> My sensor gives me good data, but it's very, very noisy.
18:17:55 <Pseudonym> The dark recesses of my brain said "Kalman filter", so I looked it up, and I realised I don't really understand it.
18:19:00 <ddarius> I came across it via control theory.
18:23:16 <edwardk> a kalman filter is just a low-pass IIR more or less right?
18:23:37 <Pseudonym> Errr... not quite.
18:23:42 <Pseudonym> It is a kind of low-pass IIR filter.
18:23:52 <Pseudonym> But it's constructed by modelling the process that generates the "signal".
18:23:58 <edwardk> yeah
18:24:16 <edwardk> its been a long time since i thought about digital signal processing which was when i first saw it
18:25:31 <edwardk> heh, i actually have a use for that, thanks for jogging my memory =)
18:49:51 <dancor> is there a built-in for \ x y -> (x, y)
18:50:05 <slava> isn't that just (,) ?
18:50:15 <LoganCapaldo> > (,) 2 3
18:50:16 <dancor> yes
18:50:16 <dancor> ok
18:50:18 <lambdabot>  (2,3)
18:50:48 <notadev> hey lambdabot :-)
18:50:53 <notadev> @botsnack
18:50:53 <lambdabot> :)
18:50:57 <LoganCapaldo> @type uncurry id
18:50:59 <lambdabot> forall b c. (b -> c, b) -> c
18:51:07 <notadev> hmm
18:51:27 <notadev> @type '->'
18:51:29 <lambdabot> lexical error in string/character literal at character '>'
18:51:38 <notadev> meh
18:52:09 <notadev> beer sry
18:54:39 <jfredett> okay, so I have information coming to me in the form IO Integer, what i want is the Integer thats inside it.
18:54:53 <jfredett> I can use case to do that, right?
18:55:03 <LoganCapaldo> no
18:55:06 <jfredett> ...
18:55:18 <LoganCapaldo> you can use >>= or do notatioatn to do th
18:55:24 <LoganCapaldo> gah
18:55:26 <jfredett> but I don't want it in the monad anymroe
18:55:29 <LoganCapaldo> I hate this touch pad
18:55:32 <jfredett> anymore*
18:55:42 <LoganCapaldo> you can't escape the IO monad
18:55:52 <jfredett> is there a way to escape any monad period?
18:56:14 <jfredett> cause I can probably get the same info in a different monad.
18:56:18 <LoganCapaldo> depends on the monad
18:56:32 <LoganCapaldo> eg, you can escape teh maybe monad with a case
18:56:49 <jfredett> hmm- how is that decided? that is- how do I know when I can escape a monad?
18:57:02 <shachaf> jfredett: It depends on the monad.
18:57:09 <shachaf> jfredett: There's no class MonadEscape.
18:57:14 <LoganCapaldo> if there exists a function for your monad m, m a -> a
18:57:17 <shachaf> jfredett: (As far as I know.)
18:57:18 <jfredett> so theres no general rule- hmm
18:57:21 <TSC> If there's an operation that has a type "m a -> a", you can escape
18:57:37 <TSC> (or some similar type)
18:58:04 <shachaf> jfredett: (That operation isn't always safe, though -- head :: [a] -> a fails on [], for example.)
18:58:28 <oerjan> for many of the fancier monads, the function to escape is called something of the form runXXX
18:58:32 <jfredett> one more question, is there any particular reason one has to be stuck in any particular monad?
18:58:32 <jfredett> that is-- is there any theory that says, "You can't have an escape from a monad if..."
18:58:39 <notsmack> jfredett: you can't escape IO because the constructors for it aren't exported, so there's nothing to type-match
18:59:07 <dancor> the real reason you can't escape IO is that the purpose of it is to encapsulate temporal dependencies
18:59:22 <dancor> like "read disk, then write disk"
18:59:23 <LoganCapaldo> yeah you don't really _want_ to escape IO
18:59:37 <notadev> use another monad
18:59:42 <jfredett> i see- so is it safe to say that if a monad has some sort of temporal dependency, is can't be escaped?
18:59:47 <oerjan> this is of course a lie: the unsafePerformIO function escapes the IO monad.  But it is hard to do right
18:59:47 <dancor> yeah
19:00:01 <dancor> because outside a monad, there is no strict time-ordering of things
19:00:02 <jfredett> or more generally, if the monad models state, then its unescapeable?
19:00:07 <notadev> runXXX oerjan?
19:00:12 <notadev> hmm
19:00:31 <jfredett> i think i follow now- I'm just trying to get random numbers
19:00:39 <oerjan> runState, runStateT at least
19:01:04 <dancor> anything that uses randomness will have to be inside IO
19:01:21 <edwardk> jfredett: if you are looking for something you can readily 'escape' from you are probably looking at something like a comonad. ;)
19:01:27 <jfredett> its weird- Monads seem to be things which -- if not properly controlled -- will overrun your program entirely
19:01:49 <TSC> They help to separate the pure parts
19:01:51 <notadev> well that's code for you
19:01:52 <jfredett> edwardk: fuck, there's comonads too? i'm never gonna get this... :/
19:02:07 <dancor> forget comonads, no one is even sure if they are useful
19:02:08 <notadev> not with that attitude you won't jfredett ;)
19:02:17 <edwardk> don't worry i only know like two useful ones
19:02:27 <dancor> haskell is supposed to only support tried and true methodologies :)
19:02:35 <jfredett> notadev: its alright- I actually enjoy being hopelessly confused
19:02:41 <notadev> hehe
19:02:43 <jfredett> its makes my brain hurt.
19:03:06 <notadev> http://en.wikipedia.org/wiki/Category_(mathematics) then jfredett ;)
19:03:14 <jfredett> lol, read that
19:03:20 <notadev> check link for Category Theory
19:03:32 <edwardk> jfredett: usually to get out of a monad you have to 'pay' something. you have to give it a starting state, or supply the environment to a reader monad or take back the monoid your writer was accumulating for you.
19:03:39 <jfredett> category theory is easy enough, right up till the hairy stuff
19:03:44 <notadev> lol
19:03:54 <notadev> til it gets hard iow ;)
19:04:12 <edwardk> for some you just can't 'pay' the cost, for IO, you just have to destroy the world ;)
19:04:22 <jfredett> edwardk: lol
19:04:28 <edwardk> or sweep the issues of what you are doing in that dirty little IO monad under the rug
19:04:47 <dancor> jfredett: a good way to do randomness might be to generate (in IO) an infinite list of random integers then pass them into your pure fcns
19:04:55 <jfredett> well- categories themselves are pretty simple- its the morphism stuff that makes them hairy, just like groups or rings...
19:05:11 <jfredett> dancor: right- well, heres what I want to do
19:05:21 <dancor> jfredett: do { rand_list <- .. ; putStrLn $ my_pure_fcn rand_list }  etc
19:05:34 <oerjan> @type RandomIOs
19:05:35 <lambdabot> Not in scope: data constructor `RandomIOs'
19:05:37 <oerjan> @type RandomIO
19:05:39 <lambdabot> Not in scope: data constructor `RandomIO'
19:05:41 <oerjan> er
19:05:47 <oerjan> @type randomIO
19:05:49 <lambdabot> forall a. (Random a) => IO a
19:05:59 <dancor> sorry for using _, too much python..
19:06:00 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/System-Random.html
19:06:03 <lambdabot> http://tinyurl.com/hch36
19:06:11 <edwardk> look there, you can get a stdgen, then use it functionally.
19:06:19 <jfredett> getRandElem :: [a] -> a
19:06:19 <jfredett> getRandElem ls =
19:06:19 <jfredett>         ls !! getRandOnRange (0, len-1) where len = length ls
19:06:22 <jfredett> more or less
19:06:27 <jfredett> thats all pseudohaskell, btw
19:06:42 <jfredett> issue being, I can't do that directly-
19:06:52 <edwardk> @type randoms
19:06:54 <lambdabot> forall g a. (Random a, RandomGen g) => g -> [a]
19:07:11 <edwardk> @type getStdGen
19:07:13 <lambdabot> IO StdGen
19:07:15 <dancor> oh duh, you just need the generator yeah.  even better
19:07:22 <jfredett> wait- what?
19:07:25 <edwardk> use io to get the stdgen, then use it with randoms
19:07:31 <edwardk> which you can do in a pure manner
19:07:33 <dancor> randoms is pure
19:07:39 <dancor> pure++
19:07:41 * jfredett hears the swish as the whole concept flys over him
19:07:50 <edwardk> ok, jfredett, starting at the beginning.
19:07:56 <edwardk> what you need is a random number 'seed' right?
19:08:03 <edwardk> that is the only impure part of the process
19:08:05 <jfredett> okay- sounds good
19:08:14 <jfredett> so I can use getStdGen
19:08:16 <edwardk> then you need something that manipulates that seed in a pure fashion to generate a list.
19:08:21 <edwardk> thats what randoms does
19:08:22 <edwardk> yeah
19:08:41 <edwardk> then you can map to spindle and mutilate that stream of random numbers into what you want
19:08:43 <jfredett> okay- so to get a random stream of truly "random numbers" (by session, at least)
19:08:52 <jfredett> i would do something like
19:09:07 <edwardk> yeah, if you look at the same number in the same position in the list, it doesn't change, but each number in the list is pseudo-random.
19:09:18 <jfredett> right
19:09:19 <edwardk> you want a new list, go get a new StdGen from IO.
19:09:24 <jfredett> brb
19:09:28 <edwardk> kk
19:09:43 <edwardk> er
19:09:46 <edwardk> actually you want a range
19:09:50 <edwardk> @type randomRs
19:09:52 <lambdabot> forall a g. (Random a, RandomGen g) => (a, a) -> g -> [a]
19:10:38 <edwardk> > randomRs (1,10) (mkStdGen 1)
19:10:39 <lambdabot>  [8,9,8,10,1,10,7,8,3,1,4,8,7,4,9,6,5,3,9,7,7,10,3,7,10,4,8,7,4,9,9,10,9,2,7,...
19:11:13 <dancor> how can i combine two Map's with different value types?
19:11:23 <dancor> i feel like i need some kind of fzipWith
19:11:47 <oerjan> dancor: what do you mean?
19:12:04 <edwardk> toList each, zip, map, then fromList the result?
19:12:10 <dancor> well i could do Map.map to do Map k a -> Map k (a, b)
19:12:21 <dancor> and same for b and then unionWith
19:12:30 <dancor> edwardk: is going to a list really the cool thing to do?
19:12:33 <edwardk> ah you want the union of some sort?
19:12:46 <dancor> yeah but union requires the same value types
19:12:54 <edwardk> don't you mean map to go to Either a b?
19:13:06 <dancor> i basically want to zip my lists
19:13:13 <dancor> my maps
19:13:14 <dancor> rather
19:13:19 <edwardk> zip != union
19:13:28 <edwardk> unless i'm seriously missing what you want
19:13:38 <dancor> i want Map k a -> Map k b -> Map k (a, b)
19:13:42 <kpreid> dancor: what do you want to happen in the cases where only one map has some key, and where both have some key?
19:13:46 <dancor> yes you can go to a list
19:13:54 <dancor> but that seems inappropriate
19:13:56 <sorear> phew.
19:13:57 <kpreid> dancor: do you want only the ones where both have a key?
19:13:57 <edwardk> ok, so you want the intersection of the keys, so where you have the same key in each?
19:14:21 <edwardk> @type intersectionWith
19:14:23 <lambdabot> Not in scope: `intersectionWith'
19:14:29 <edwardk> bah
19:14:33 <edwardk> @hoogle intersectionWith
19:14:33 <lambdabot> Data.IntMap.intersectionWith :: (a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
19:14:33 <lambdabot> Data.Map.intersectionWith :: Ord k => (a -> b -> c) -> Map k a -> Map k b -> Map k c
19:14:33 <lambdabot> Data.IntMap.intersectionWithKey :: (Key -> a -> b -> a) -> IntMap a -> IntMap b -> IntMap a
19:14:36 <edwardk> there
19:14:40 <edwardk> look at the data map one ;)
19:14:49 <edwardk> intersectionWith (,)
19:14:54 <dancor> ah.  duh
19:15:05 <edwardk> you were backwards you wanted an intersection, not a union
19:15:09 <kpreid> > M.intersectionWith (+) (M.singleton 'a' 1) (M.singleton a 2)
19:15:09 <lambdabot>  Couldn't match expected type `Char' against inferred type `Integer'
19:15:17 <kpreid> > M.intersectionWith (+) (M.singleton 'a' 1) (M.singleton 'a' 2)
19:15:18 <lambdabot>  fromList [('a',3)]
19:15:51 <dancor> > M.intersectionWith zip (M.singleton 'a' 1) (M.singleton 'a' "2")
19:15:52 <lambdabot>   add an instance declaration for (Num [a])
19:15:54 <kpreid> > M.intersectionWith (,) (M.singleton 'a' 1) (M.singleton 'a' "b")
19:15:55 <lambdabot>  fromList [('a',(1,"b"))]
19:15:57 <dancor> > M.intersectionWith zip (M.singleton 'a' '1') (M.singleton 'a' "2")
19:15:58 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Char'
19:16:12 <kpreid> dancor: use (,) for your example
19:16:23 <dancor> > M.intersectionWith (,) (M.singleton 'a' '1') (M.singleton 'a' "2")
19:16:24 <lambdabot>  fromList [('a',('1',"2"))]
19:16:44 <kpreid> zip is zipWith (,), and you want map instead of list, so (,) is what you want for the combination function
19:17:06 <oerjan> > P.map
19:17:07 <lambdabot>  Add a type signature
19:17:37 <oerjan> @type P.map
19:17:39 <lambdabot> Couldn't find qualified module.
19:17:45 <oerjan> grr
19:18:16 <oerjan> what are the module abbreviations?
19:18:32 <kpreid> I don't think there's any way to ask for them
19:18:37 <notadev> @type map
19:18:39 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
19:18:45 <oerjan> > 1 `P.+` 2
19:18:45 <lambdabot>  Parse error
19:18:53 <oerjan> > 1 P.+ 2
19:18:54 <lambdabot>  3
19:19:29 <oerjan> > P.map (+1) [1,2,3]
19:19:30 <lambdabot>  [2,3,4]
19:19:36 <oerjan> looks like Prelude
19:20:01 <kpreid> oerjan: http://www.cse.unsw.edu.au/~dons/lambdabot/scripts/RunPlugs.hs
19:20:10 <edwardk> oerjan: http://www.cse.unsw.edu.au/~dons/lambdabot/State/L.hs
19:20:16 <notadev> @help
19:20:17 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
19:20:21 <notadev> @list
19:20:21 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
19:20:59 <kpreid> @type SC.map
19:21:01 <lambdabot> Couldn't find qualified module.
19:21:07 <kpreid> @type M.map
19:21:09 <lambdabot> Couldn't find qualified module.
19:21:30 <kpreid> > const 1 SC.map
19:21:32 <lambdabot>  1
19:21:46 <dons> the qualified names aren't used in @type
19:21:52 <kpreid> okay, so the imports in the items from the list in RunPlugs.hs are
19:21:54 <dons> but you can of course use the full name
19:21:57 <kpreid> ...used
19:22:22 <kpreid> dons: why does L.hs have an import list which is different?
19:22:27 <dons> you can't import qualified into ghci, to @type it , anyway?
19:22:34 <dons> kpreid: hmm. probably no good reason
19:22:51 <kpreid> seems like they ought both to be generated from a common table
19:23:28 <dons> that would make sense, though.
19:23:34 <kpreid> especially as, say, having something unsafe present in L but not RunPlugs would be an unobvious hole
19:23:38 <kpreid> two places to change it, etc
19:24:50 <oerjan> what's L.hs used for?
19:25:05 <sorear> @let -- this is appended to L.hs
19:25:06 <dons> ?let foo = 1
19:25:08 <lambdabot> Defined.
19:25:08 <lambdabot> Defined.
19:25:15 <dons> > foo + 2
19:25:17 <lambdabot>  3
19:25:45 <dons> kpreid: yes, exactly.
19:25:53 <dons> are you interested in sending a patch? :-)
19:26:57 <slava> hey dons :)
19:27:51 <dons> hey slava, i was thinking about your points.
19:27:55 <kpreid> dons: mm, not very much at the moment. I'll put it on my list.
19:28:04 <dons> > 1+2 -- runtime code generation is solved
19:28:06 <lambdabot>  3
19:28:17 <dons> and deriving instances/boilerplate stuff also (TH + lightweight generics)
19:28:34 <dons> runtime macros though, that's MetaML and some others, so pretty edgy
19:29:04 <dons> then I wonder: is there anything you can do with runtime macros that we'd want to do anyway, that can't be done with laziness, and the ghc-api (i.e. a haskell interpreter available at runtime)
19:29:04 <oerjan> @list let
19:29:05 <lambdabot> eval provides: run let undefine
19:29:18 <oerjan> @help run
19:29:18 <lambdabot> run <expr>. You have Haskell, 3 seconds and no IO. Go nuts!
19:29:37 <dons> > last [1..]
19:29:43 <notadev> @list map
19:29:43 <lambdabot> Terminated
19:29:43 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools hackage
19:29:45 <dons> too slow! :-)
19:30:50 <slava> dons: it would be cool if there was something like McCLIM for haskell
19:30:53 <slava> s/Mc//
19:32:06 <oerjan> @help undefine
19:32:06 <lambdabot> undefine. Reset evaluator local bindings
19:33:22 <oerjan> @help choose
19:33:22 <lambdabot> choose. Lambdabot featuring AI power
19:33:30 <oerjan> @choose
19:33:30 <lambdabot> Choose between what?
19:33:42 <LoganCapaldo> @choose good evil
19:33:43 <lambdabot> good evil
19:33:49 <LoganCapaldo> erm
19:33:59 <oerjan> @choose between ninjas and pirates
19:33:59 <lambdabot> between ninjas and pirates
19:34:08 <oerjan> er, what AI? :)
19:34:13 <LoganCapaldo> @choose ninjas or pirates
19:34:13 <lambdabot> ninjas or pirates
19:34:32 <LoganCapaldo> fine
19:34:37 <LoganCapaldo> be that way
19:34:39 <notadev> @help choose
19:34:39 <lambdabot> choose. Lambdabot featuring AI power
19:34:44 <notadev> lol
19:34:53 <notadev> @list choose
19:34:53 <lambdabot> dummy provides: eval choose id read show dummy bug get-shapr faq paste learn map shootout botsnack wiki oldwiki docs source fptools hackage
19:34:59 <notadev> ah ok
19:35:12 <notadev> @help get-shapr
19:35:12 <lambdabot> get-shapr. Summon shapr instantly
19:35:16 <LoganCapaldo> @dummy what is this, echo?
19:35:17 <lambdabot> dummy
19:35:30 <LoganCapaldo> @id I guess this is
19:35:30 <lambdabot>  I guess this is
19:35:30 <notadev> @get-shapr
19:35:30 <lambdabot> shapr!!
19:35:45 <LoganCapaldo> @id @id recursive?
19:35:45 <lambdabot>  @id recursive?
19:36:21 <oerjan> @read
19:36:22 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
19:36:41 <notadev> hmm
19:37:02 <sorear> @. where+ read "boo \STXPING\STX"
19:37:02 <lambdabot> Done.
19:37:06 <sorear> @where boo
19:37:06 <lambdabot> PING
19:37:07 <oerjan> @read Left (Right Nothing)
19:37:07 <lambdabot> Plugin `dummy' failed with: IRCRaised Prelude.read: no parse
19:37:19 <sorear> @. where+ read "boo \001PING\001"
19:37:19 <lambdabot> Done.
19:37:20 <sorear> @where boo
19:37:25 <slava> dons: why is it that statically typed languages have traditionally fared worse when it comes to interactive development?
19:37:25 <oerjan> @help read
19:37:26 <lambdabot> read "<foo>". Print <foo>
19:39:09 <oerjan> @help where+
19:39:09 <lambdabot> where+ <key> <elem>. Define an association
19:39:42 <oerjan> @help .
19:39:42 <lambdabot> . <cmd1> <cmd2> [args].
19:39:42 <lambdabot> . [or compose] is the composition of two plugins
19:39:42 <lambdabot>  The following semantics are used: . f g xs == g xs >>= f
19:40:32 <oerjan> @. id id recursive
19:40:32 <lambdabot>   recursive
19:41:21 <chadz> ?hoogle Documen
19:41:21 <dons> slava: hmm, the phasing of checking and then runtime complicates things, basically
19:41:25 <lambdabot> Distribution.Extension.HereDocuments :: Extension
19:41:25 <lambdabot> System.Directory.getUserDocumentsDirectory :: IO FilePath
19:41:49 <LoganCapaldo> ghc has heredocs/
19:41:51 <LoganCapaldo> ?
19:42:38 <oerjan> @help learn
19:42:38 <lambdabot> learn. The learning page url
19:49:46 <oerjan> @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
19:49:50 <lambdabot>  @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
19:50:25 <LoganCapaldo> lambdabot quine!
19:50:43 <LoganCapaldo> brilliant!
19:51:41 <LoganCapaldo> @remember oerjan @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
19:51:41 <lambdabot> Done.
19:52:00 <LoganCapaldo> @quote oerjan
19:52:00 <lambdabot> oerjan says: @. read run (\s -> s ++ show s) "@. read run (\\s -> s ++ show s) "
19:52:10 <LoganCapaldo> goood
19:52:15 <oerjan> a bit bad with the extra space at the beginning though
19:52:38 <LoganCapaldo> ?
19:52:58 <oerjan> in lambdabot's response
19:53:19 <oerjan> @read "test"
19:53:19 <lambdabot>  test
19:54:00 <edwardk> nice, now put two lambdabots on the same channel
19:54:16 <oerjan>  @read "test"
19:54:32 <oerjan> i suppose the space may be there on purpose :)
19:54:36 <sorear> edwardk: been there, done that, lagged out just in time to not be able to stop it
19:54:39 <edwardk> ah yeah
19:54:51 <edwardk> the space would do that i guess
19:54:58 <edwardk> tricksy of dons
19:55:06 <sorear> if my connection hadn't dropped at exactly the wrong moment...
19:55:33 <sorear> there are of course ways around it.
19:55:40 <edwardk> ya
19:55:47 <sorear> @where+ bing ?where bing
19:55:47 <lambdabot> Done.
19:55:50 <sorear> ?where bing
19:55:50 <lambdabot> ?where bing
19:55:55 <edwardk> =)
19:56:21 <sorear> IRC does *not* do remote echo; it is thusly almost impossible to make a 1-bot loop.
19:56:26 <edwardk> wonder if the ideal quine-killing fix would be to prefix all lambdabot output with an extra space
19:56:49 <sorear> but ?where bing, is how I set up the lambdabot/mbot loop a few weeks ago
19:56:55 <edwardk> ah
19:57:04 <LoganCapaldo> it's a logic bomb!
19:57:05 <sorear> lambdabot listens to @part, but see above on lagging :)
19:57:07 <shachaf> @where+ recursion @where recursion
19:57:08 <lambdabot> Done.
19:57:24 <sorear> shachaf: nice try, but dons incompletly fixed that
19:57:28 <sorear> @where recursion
19:57:28 <lambdabot>  @where recursion
19:57:40 <shachaf> sorear: Oh, only with '?'?
19:57:42 <sorear> lambdabot space-escapes all @ in the output layer
19:57:45 <sorear> yes.
19:57:58 <sorear> BITD @ was the only command char
19:57:59 <shachaf> sorear: Right, I remember now.
19:58:12 <oerjan> hm...
19:58:19 <shachaf> ?where+ recursion ?where recursion
19:58:20 <lambdabot> Done.
19:58:24 <oerjan> ?. read run (\s -> s ++ show s) "?. read run (\\s -> s ++ show s) "
19:58:25 <lambdabot>  ?. read run (\s -> s ++ show s) "?. read run (\\s -> s ++ show s) "
19:58:33 <edwardk> there ya go =)
19:58:50 <shachaf> edwardk: @read always adds a space.
19:59:23 <edwardk> so we have a quine, now we just need a palindromic quine.
19:59:48 <shachaf> @. id . id . id . id . id . id . id . id id xyzzy
19:59:48 <lambdabot>          xyzzy
20:00:11 <edwardk> ?. id . id . id . id . id . id . id . id id xyzzy
20:00:11 <lambdabot>          xyzzy
20:01:16 <oerjan> er, what counts as a palindromic quine?
20:01:32 <sorear> asdfghjkl;;lkjhgfdsa
20:02:04 <shachaf> sorear: What language is THAT in?
20:02:16 <sorear> #! /bin/cat
20:02:22 <sorear> tac/bin/ !#
20:02:54 <edwardk> i have an old c one somewhere i wrote for an obfuscated c contest forever ago
20:02:55 <sorear> shachaf: .*
20:02:55 <shachaf> /dev/null is a palindromic quine in sh.
20:05:04 <oerjan> hm...
20:05:20 <monochrom> Are you ok, sorear?
20:06:00 <sorear> monochrom: yes?
20:06:44 <monochrom> Nevermind. I thought you were typing drunk. :)
20:09:25 <sorear> .* is a regular language; asdfghjkl;;lkjhgfdsa is the first fixpoint of reverse that came to mind; #! /bin/cat makes anything a quine; tac/bin/ !# completes the palindrome :)
20:12:33 <jcreigh> sorear: but using cat is cheating
20:12:34 <SamB> monochrom: drunks can't type straight
20:13:16 <SamB> drunks type like this: qazxcdertgbnmjuiol./'[]
20:14:01 <monochrom> haha that's a good one
20:14:05 <shachaf> SamB: Is there any reason irssi highlighted your last message?
20:14:25 <SamB> shachaf: ... is that one of your alternate nicks?
20:14:32 <sorear> shachaf: /hilight
20:14:35 <sorear> shachaf: sayz?
20:14:37 <shachaf> SamB: Must be.
20:14:38 <sorear> *says
20:14:49 <shachaf> Oh, right, I was just testing /hilight before.
20:14:50 <shachaf> Sorry.
20:15:05 <shachaf> I was /hilighting "cd".
20:15:05 <sorear> shachaf: ... and you happened to add WHAT?!
20:15:07 <chadz> ?hoogle stdout
20:15:07 <lambdabot> IO.stdout :: Handle
20:15:22 <sorear> cd
20:15:39 <SamB> it's kinda pathetic that Python needs "with" syntax
20:15:44 <SamB> where we have a pattern
20:18:18 <shachaf> Actually, CAN there be a palindromic /bin/cat quine in a "proper" (newline-terminated) file?
20:19:17 <SamB> shachaf: what if the first line is blank
20:20:00 <LoganCapaldo> "\n" is a palidrome isn't it?
20:20:08 <sorear> shachaf: There is nothing wrong with not newline-terminating files.
20:20:20 <sorear> They are [Word8], nothing more.
20:20:29 <jcreigh> I'd say isPalindrome xs = xs == reverse xs
20:20:35 <jcreigh> but that's just me
20:20:54 <sorear> i'd say ap (==) reverse, but that's just me
20:21:04 <LoganCapaldo> > let isPalindrome xs = xs == reverse xs in isPalindrome "\n"
20:21:05 <lambdabot>  True
20:21:19 <LoganCapaldo> > ap (==) reverse "\n"
20:21:20 <lambdabot>  True
20:22:15 <oerjan> @. read run (\s -> s ++ show s ++ ' ':'-':'-':' ': reverse(show s) ++ reverse s) "@. read run (\\s -> s ++ show s ++ ' ':'-':'-':' ': reverse(show s) ++ reverse s) " -- " )s esrever ++ )s wohs(esrever :' ':'-':'-':' ' ++ s wohs ++ s >- s\\( nur daer .@" )s esrever ++ )s wohs(esrever :' ':'-':'-':' ' ++ s wohs ++ s >- s\( nur daer .@
20:22:16 <lambdabot> Plugin `compose' failed with: IRCRaised Prelude.read: no parse
20:22:32 <oerjan> hm...
20:22:39 <LoganCapaldo> @src (->) return
20:22:39 <lambdabot> return = const
20:23:32 <shachaf> oerjan: (By the way, that last '(' should be a ')'.
20:23:41 <shachaf> s/.$/)./
20:23:52 <shachaf> oerjan: Or not.
20:23:57 <shachaf> oerjan: Not for a quine, never mind.
20:24:20 * shachaf feels foolish again.
20:24:25 <oerjan> let's see
20:24:32 <oerjan> @run (\s -> s ++ show s ++ ' ':'-':'-':' ': reverse(show s) ++ reverse s) "@. read run (\\s -> s ++ show s ++ ' ':'-':'-':' ': reverse(show s) ++ reverse s) " -- " )s esrever ++ )s wohs(esrever :' ':'-':'-':' ' ++ s wohs ++ s >- s\\( nur daer .@" )s esrever ++ )s wohs(esrever :' ':'-':'-':' ' ++ s wohs ++ s >- s\( nur daer .@
20:24:34 <lambdabot>  "@. read run (\\s -> s ++ show s ++ ' ':'-':'-':' ': reverse(show s) ++ reve...
20:24:47 <oerjan> whoops
20:29:09 <chadz> hmm -- is it a common issue for haxml with toXml to not close tags/
20:29:35 <notsmack> chadz: hmm, i don't remember ever seeing that
20:40:09 <oerjan> > replicate 150 'a'
20:40:11 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:40:34 <oerjan> > replicate 85 'a'
20:40:36 <lambdabot>  "aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa...
20:40:55 <Moozilla> hi, I'm trying to make an isSquare function, to tell if a number is a square but I keep getting type errors
20:41:44 <Japsu> @src ap
20:41:44 <lambdabot> ap = liftM2 id
20:41:47 <Japsu> !!
20:42:11 <sorear> YEAH!
20:42:12 <oerjan> Moozilla: what's your definition?
20:42:44 <Moozilla> isSquare n = (sqrt n) == floor (sqrt n)
20:43:16 <ddarius> :t floor
20:43:18 <ddarius> :t sqrt
20:43:18 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:43:20 <lambdabot> forall a. (Floating a) => a -> a
20:44:05 <Moozilla> so I need to convert floor back to a Floating
20:44:08 <Moozilla> but I don't know how
20:44:18 <oerjan> fromIntegral
20:45:05 <Moozilla> ah
20:45:08 <Moozilla> thanks
20:47:45 <Moozilla> but how do I convert from Num to Floating
20:47:49 <Moozilla> :: Floating ?
20:48:34 <oerjan> not completely possible, Num includes things like complex numbers
20:49:04 <Moozilla> okay, then how should I do isSquare, is there an isInt?
20:49:16 <oerjan> but fromIntegral will probably work for the numbers you want
20:49:50 <oerjan> since checking if a number is square only really makes sense for integral numbers
20:50:03 <Moozilla> yeah
20:50:33 <monochrom> isSquare makes sense for Double too.  Just test for >= 0. :)
20:51:06 <sorear> monochrom: not all positive doubles are square
20:51:14 <monochrom> Oh! Darn.
20:51:15 <sorear> eg, 2.0
20:51:30 <slava> when viewed as a real number, 2 is a perfect square
20:52:10 <oerjan> Moozilla: however, checking if floor is exactly equal may be a bit too precise for floating number comparison
20:52:17 <ddarius> sorear: All real numbers >=0 are the square of some other real number.
20:52:48 <Moozilla> how would I do isInt?
20:52:50 <monochrom> sorear means that Double is still not real.
20:53:17 <ddarius> isInt :: Int -> Bool; isInt = True
20:53:17 <oerjan> @type round
20:53:19 <lambdabot> forall a b. (RealFrac a, Integral b) => a -> b
20:53:23 <ddarius> isInt :: Int -> Bool; isInt _ = True
20:53:38 <dibblego> isInt = const True
20:53:41 <oerjan> use round instead of floor, and check if it is close rather than exactly equal
20:54:55 <hpaste>  chadz pasted "haxml output? " at http://hpaste.org/315
20:55:02 <oerjan> wait a moment...
20:55:21 <chadz> hey -- it doesn't seem to be generating valid xml. i'm probably doing something horribly wrong,but firefox is complaining.
20:55:50 <oerjan> there is a better way for checking squares: round, then square again, as an integer.  _Then_ you can use exact equality.
20:56:10 <oerjan> with the original number.
20:57:40 <LoganCapaldo> @type let isSquare n = not (null (filter (\x -> x * x == n) (takeWhile (<= n) (iterate (+1) 0)))) in isSquare -- general enough? Or no like the Ord?
20:57:42 <lambdabot> forall a. (Ord a, Num a) => a -> Bool
20:58:19 <LoganCapaldo> > let isSquare n = not (null (filter (\x -> x * x == n) (takeWhile (<= n) (iterate (+1) 0)))) in isSquare 25
20:58:20 <lambdabot>  True
20:58:48 <LoganCapaldo> > let isSquare n = not (null (filter (\x -> x * x == n) (takeWhile (<= n) (iterate (+1) 0)))) in isSquare 25.0
20:58:49 <lambdabot>  True
20:59:06 <Moozilla> > let isSquare n = not (null (filter (\x -> x * x == n) (takeWhile (<= n) (iterate (+1) 0)))) in isSquare 24.0
20:59:08 <lambdabot>  False
20:59:14 <Moozilla> great, thanks
20:59:16 <ddarius> @src Num
20:59:16 <lambdabot> class  (Eq a, Show a) => Num a  where
20:59:17 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:59:17 <lambdabot>     negate, abs, signum     :: a -> a
20:59:17 <lambdabot>     fromInteger             :: Integer -> a
20:59:44 <LoganCapaldo> it's definitely not the most efficient function ever :)
21:00:03 <dons> anyone want to port the scheme presentation EDSL to haskell + beamer/latex ?
21:00:08 <oerjan> LoganCapaldo: it would be better to move the squaring inside the takeWhile, at least
21:01:30 <dgriffi3> dons: which EDSL?
21:02:12 <dons> Robbie Findler wrote one a couple of years ago, iirc. there was a paper on it.
21:02:45 <emu> literate haskell + beamer/latex
21:02:47 <emu> ?
21:03:20 <dons> well, i'd like to just write slides.hs, which when run, spits out the latex file for the slides, using the beamer class
21:03:33 <emu> oh i misread that
21:03:43 <dons> so the slides can remain at a very high level, without getting bogged down in formatting
21:04:05 <dons> a GADT for slides, anyone ? :-)
21:04:17 <emu> paper available?
21:04:38 <dons> let's see.
21:05:34 <dons> http://people.cs.uchicago.edu/~robby/pubs/papers/icfp2004-ff.pdf
21:05:39 <dons> Slideshow: Functional Presentations
21:05:39 <dons> Findler, Flatt
21:05:51 <dons> gives us the basic language to start with
21:07:20 <ddarius> Well, that seems light enough that I may take a swing at it.
21:08:34 <dons> it would be really really good to have. this community tends to write a lot of slides..
21:09:01 <emu> what's wrong wit the PLT version?
21:11:49 <dons> ideally, you'd want to mix TeX and Haskell fairly freely, and compile to beamer (seems to be the best slide format)
21:12:02 <dons> these guys do somethiing quite different in the backend, iirc
21:12:04 <emu> i use beamer myself for presentations
21:12:17 <dons> yeah, it seems to becoming more and more common
21:12:27 <dons> its too gunky though: no abstraction
21:13:14 <emu> math is important too
21:13:32 <dons> i'd like a port of the usual pretty printing combinators, with slide specific stuff, and freeform TeX/math, in Haskell, which generates beamer stuff
21:14:52 <LoganCapaldo> @type let isSquare 0 = True; isSquare 1 = True; isSquare n = case find (== n) $ unfoldr (\x -> case x of { 0 -> Nothing ;  _ -> Just (x * x, x - 1) }) n of { Nothing -> False ; _ -> True } in isSquare
21:14:54 <lambdabot> forall a. (Num a) => a -> Bool
21:15:14 <ddarius> It sounds interesting enough to write and if it wasn't past 11 and I didn't have to get up at 6 I'd probably start right now.
21:15:18 <LoganCapaldo> No Ord needed!
21:15:21 <LoganCapaldo> woo :)
21:15:56 <ddarius> I'll read the paper tomorrow and probably start hacking something.  I'll probably harass you, dons, to work out the things you'd want since I don't make slides all that often.
21:16:06 <dons> ddarius: i agree. it would be fun. good power to effort ratio
21:16:29 <dons> ok. i can send example beamer slides that we'd want to generate
21:16:40 <Japsu> beamer... :<
21:16:49 <Japsu> beamer + unicode + verbatim environments = epic failure
21:17:01 <ddarius> dons: Do you have my email address?
21:17:21 <dons> ddarius: i don't think i have a current one
21:22:49 <slowriot> I need some advice. I want to learn about yampa. Yampa uses arrows, though, and I am not really that comfortable with monads yet. Should I start some intermediate haskell project to get more acquainted with monads, or should I go straight to studying arrows?
21:23:26 <ddarius> arrows and monads are different things.
21:23:50 <ddarius> That said, if you don't "get" monads, you'll have about the same trouble with arrows.
21:24:13 <ddarius> However, using a concrete arrow (as you would for Yampa) is easier than understanding them in general (and similarly for monads).
21:25:03 <slowriot> hmm... okay
21:26:31 <emu> @src Arrow
21:26:31 <lambdabot> class Arrow a where
21:26:32 <lambdabot>     arr, pure   :: (b -> c) -> a b c
21:26:32 <lambdabot>     (>>>)       :: a b c -> a c d -> a b d
21:26:32 <lambdabot>     first       :: a b c -> a (b,d) (c,d)
21:26:32 <lambdabot>     second      :: a b c -> a (d,b) (d,c)
21:26:33 <lambdabot>     (***)       :: a b c -> a b' c' -> a (b,b') (c,c')
21:26:36 <lambdabot>     (&&&)       :: a b c -> a b c'  -> a b (c,c')
21:27:32 <slowriot> I guess my next step will be to study arrows. Then I'll move onto Yampa.
21:28:09 <chadz> http://hpaste.org/315, what am I doing wrong here with generating xml?
21:30:10 <ddarius> slowriot: That would be harder than just learning Yampa.
21:31:37 <slowriot> ddarius: okay, but I want to learn arrows eventually. I like knowing the abstract concepts behind everything.
21:31:57 <slowriot> ddarius: thanks for the help
21:37:46 <oerjan> @type (\+)
21:37:48 <lambdabot> Not in scope: `\+'
21:37:53 <oerjan> @type (\-)
21:37:55 <lambdabot> Not in scope: `\-'
21:46:57 <dibblego> is there a good reason to check not $ null xs before calling xs.head rather than just catching the error? is the head function free to do whatever it wants for this case, including not terminating?
21:47:16 <dibblego> er head xs (Scala influence)
21:47:52 <ddarius> dibblego: You can only catch that error in the IO monad.
21:48:07 <ddarius> (And even then, not in Haskell 98)
21:48:07 <dibblego> oh, why?
21:48:29 <sorear> I suspect everyone who follows haskell-cafe is thinking some variation on "Why do I care what this Michael T. Richter guy thinks, if he won't learn emacs he's too stupid to be an asset to the haskell community anyway!"
21:48:34 <ddarius> dibblego: What error should you get for error "foo" + error "bar" ?
21:48:39 * sorear hopes he's wrong
21:48:46 <dibblego> ddarius, I see
21:48:58 <Japsu> hmm
21:49:10 <Japsu> In the output from @src Arrow, what does this syntax mean:
21:49:13 <ddarius> sorear: It's not because he won't learn emacs that I'd think that.
21:49:14 <Japsu>  07:25   lambdabot :     arr, pure   :: (b -> c) -> a b c
21:49:22 <Japsu> Does that define signatures for two functions?
21:49:25 <ddarius> Yes.
21:49:26 <sorear> yup.
21:49:33 <Japsu> Right, thanks.
21:49:50 <ddarius> > let f, g :: Int -> Int; f x = x; g x = 3 in f 2 + g 5
21:49:51 <lambdabot>  5
21:50:35 <ddarius> Japsu: Incidentally, in that case (for arrows) they are actually two names for the (conceptually) same function.
21:50:50 <Japsu> hmm
21:51:48 <SamB_XP> if anyone defines arr and pure to be different in some class, they messed up
21:51:54 <SamB_XP> er.
21:52:01 <SamB_XP> s/class/instance/
21:52:08 * SamB_XP is tired
21:57:47 <glguy> we noticed at work last week that isEmptyChan is blocking
21:58:01 <glguy> if another thread is waiting on an empty Chan with readChan
21:58:06 <glguy> isEmptyChan will block
21:58:19 <glguy> (speaking of Chans)
21:58:43 <dons> hey glguy
21:58:44 <sorear> Control.Concurrent is deeply broken
21:58:57 <sorear> well Chan/QSem/QSemN
21:58:58 <glguy> hi dons
21:58:59 <dons> oh sorear, don't be melodramatic!
21:59:18 <sorear> for instance, did you know that throwTo will corrupt the state?
21:59:22 <dons> isEmptyChan :: Chan a -> IO Bool
21:59:23 <dons> isEmptyChan (Chan read write) = do
21:59:23 <dons>    withMVar read $ \r -> do
21:59:23 <dons>      w <- readMVar write
21:59:23 <dons>      let eq = r == w
21:59:25 <dons>      eq `seq` return eq
21:59:31 <sorear> dons: uhm... how?
21:59:41 <sjanssen> use STM!
21:59:41 <lambdabot> sjanssen: You have 1 new message. '/msg lambdabot @messages' to read it.
22:00:14 <dons> glguy: yeah, looks blocking to me too. doesn't seem terribly useful in that form, does it?
22:00:19 <glguy> nope
22:00:30 <glguy> that seemingly unexpected behavior is also undocumented
22:00:31 <sjanssen> use STM!
22:00:34 <glguy> heh
22:00:36 <dons> needs a wrapper over tryTake*
22:01:04 <sorear> dons: it's perfectly reasonable.  the outer mvar is a lock to protect the control structure
22:01:14 <sjanssen> I'm being serious -- just wrap all the useful TChan functions in atomically to write Control.Concurrent.WorkingChan
22:01:17 <sorear> dons: ...thus readChan is in error for holding the lock
22:02:22 <dons> readChan :: Chan a -> IO a
22:02:23 <dons> readChan (Chan read _write) = do
22:02:23 <dons>   modifyMVar read $ \read_end -> do
22:02:23 <dons>     (ChItem val new_read_end) <- readMVar read_end
22:02:23 <dons> 	-- Use readMVar here, not takeMVar,
22:02:25 <dons> 	-- else dupChan doesn't work
22:02:28 <dons>     return (new_read_end, val)
22:03:11 <sorear> dons: Note that the Chan/QSem/QSemN code is essentially the same as that from the original, pre-throwTo, paper :)
22:03:33 <dons> yeah, that seems suspicious (Chan is a bit deprecated..)
22:03:48 <sorear> dons: it is?
22:04:04 <sorear> why haven't I read that before...
22:04:09 <sjanssen> I've never gotten that impression
22:04:32 <dons> just to the extend that new work is done with TChan et al, and no one seems to update *.Chan
22:04:37 <sjanssen> sorear: did you submit a bug about problems with Chan+asynch exceptions?
22:04:37 <dons> s/extent/
22:04:45 <sorear> sjanssen: I think so.
22:04:57 <dons> better double check, sorear .
22:05:08 <dons> a doc patch for the blocking in isEmptyChan would also be good
22:05:17 <dons> as would examples of how to use Chan
22:05:52 <dons> since you now owe some karma to the base library gods for `Control.Concurrent is deeply broken' ;)
22:06:02 <dons> 2 patches should balance that, if my calculations are correct
22:06:35 <glguy> ?docs Control.Concurrent
22:06:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
22:06:36 <dons> glguy: you ought to encourage your work colleagues to submit doc patches ;)
22:07:01 <dons> but I agree with sjanssen , STM seems more sensible for chan-like behaviour
22:07:21 <dons> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent-Chan.html
22:07:24 <lambdabot> http://tinyurl.com/y6u2cy
22:07:26 <dons> need some work.
22:07:58 <dons> sjanssen: waddya think about the 'fixed size means you float' window idea?
22:08:27 <sjanssen> dons: it seems useful
22:08:28 <sjanssen> dwm does it
22:08:46 <sjanssen> it's needed to make gmrum float automatically
22:11:30 <glguy> dons: you about ready to move?
22:11:45 <dons> getting there. still hmm 8 weeks away
22:11:58 <dons> doing paper work currently, and trying to finish my thesis :-)
22:12:17 <dons> there's a surprising amount of work involved in getting a work visa in the US. who'd have thought? :-)
22:13:00 <dons> how's the Portland summer, glguy ?
22:13:22 <glguy> dons: excellent so far!
22:13:48 <dons> good to know.
22:13:51 <glguy> *I* thought that ;) when I asked earlier this season
22:14:17 <dons> ?temp since its bloody cold here, can't wait to get out of winter :-)
22:14:18 <lambdabot>   now 13.9, min 10.7, max 14.7, rain 0.6mm, wind 39km/h SSW
22:14:38 <glguy> its beautiful up here this time of year
22:14:43 <glguy> 60s and 70s, and sunny
22:14:49 <glguy> basically... since I got here :)
22:15:03 <dons> nice
22:18:11 * dons `ap` bus
22:20:32 <chadz> Seattle's the place to be :D
22:20:47 <chadz> portland is like seattle--
22:21:20 <glguy> portland is like seattle before you decrement seatle??
22:21:43 <chadz> ugh, i KNEW you were going to say that :)
22:21:47 <chadz> (--portland)
22:21:54 <chadz> ugh. i messed up again!
22:21:56 <glguy> lol
22:21:58 <emu> hah
22:22:00 <chadz> got to lay off the vino.
22:22:05 <glguy> one less than portland is like seattle...
22:22:07 <glguy> I see now
22:22:10 <chadz> :(
22:25:57 <chadz> > "portland" < "seattle"
22:26:02 <lambdabot>  True
22:26:09 <chadz> proof by lambdabot
22:26:21 <chadz> okko
22:26:29 <glguy> have you been trying to figure that out since your last msg??
22:27:20 <glguy> > comparing length "portland" "seattle"
22:27:21 <lambdabot>  GT
22:27:30 <glguy> but size doesn't matter... right?
22:29:14 * Philippa suggests JaffaCak3 as an alt nick
22:31:20 <chadz> glguy: of course not, i'm multitasking!
22:32:57 <chadz> and i'm not expected to meet any deadlines.
22:35:33 <chadz>          putContents t1
22:35:45 <chadz> that's obviously not what i wanted to paste.
22:36:05 <glguy> espresso beans smell great
22:36:19 <chadz> http://hpaste.org/315     -- if anyone could advise me to as why this generates faulty xml, please do so!
22:36:20 <glguy> (this one in particular)
22:43:12 <chadz> ah, it looks like the comments included (for teh DTD?) aren't liked by firefox.
22:43:18 <chadz> <! as opposed to <!--
22:44:38 <SamB_XP> <! isn't a comment start...
22:45:03 <SamB_XP> in SGML, the -- is absolutely essential to it being a comment
22:45:35 <SamB_XP> (I guess a <!> is valid in SGML?)
22:45:44 <chadz> SamB_XP: i figured. why then am I getting it from haxml?
22:45:48 <chadz> haxml/drift, rather.
22:46:04 <SamB_XP> but <!DOCTYPE ...> is no comment
22:47:21 <hpaste>  (anonymous) annotated "haxml output? " with "(no title)" at http://hpaste.org/315#a1
22:47:29 <chadz> i just appended the xml it's generating
22:48:28 <hpaste>  (anonymous) annotated "haxml output? " with "(no title)" at http://hpaste.org/315#a2
22:48:35 <chadz> (and the firefox message)
22:57:36 <Shimei> Hmm. Interesting how the Wikipedia article on Clean lists Haskell as an influence and also lists Clean coming 3 years before Haskell.
22:58:30 <emu> i'm sure Clean has changed plenty since Haskell came along
22:59:09 <Shimei> Yeah, it's probably sucked some ideas up. I just find it amusing since the same article lists Haskell's influences as Miranda, ML and such.
23:05:01 <chadz> oh, firefox doesn't read dtds.
23:55:48 <kmb> @pl (a b -> (a', b') where a' = 1, b' = 2
23:55:48 <lambdabot> (line 1, column 6):
23:55:49 <lambdabot> unexpected ">"
23:55:49 <lambdabot> expecting variable, "(", operator or ")"
23:56:33 <kmb> @pl (\a b -> (a', b') where a' = 1, b' = 2)
23:56:33 <lambdabot> (line 1, column 28):
23:56:33 <lambdabot> unexpected "="
23:56:33 <lambdabot> expecting variable, "(", operator or ")"
23:56:58 <kmb> @pl (\a b -> (a * 2, b * 4))
23:56:58 <lambdabot> (. (4 *)) . (,) . (2 *)
23:57:25 <kmb> @pl (\a b -> (a * 2, b * a))
23:57:25 <lambdabot> ap ((.) . (,) . (2 *)) (*)
23:57:56 <kmb> @pl (\a b -> (a * 2, b a))
23:57:56 <lambdabot> ap ((.) . (,) . (2 *)) (flip id)
23:58:08 <Japsu> ...
23:58:10 <Japsu> evil
23:58:48 <kmb> @pl (\a b -> (a 2, b a))
23:58:49 <lambdabot> ap ((.) . (,) . ($ 2)) (flip id)
