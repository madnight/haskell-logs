00:01:30 <kmb> @pl (\a -> (x a, y a))
00:01:30 <lambdabot> liftM2 (,) x y
00:04:09 <Japsu> :O
00:04:25 <Japsu> tuple monad?
00:04:31 <Japsu> ...why not
00:04:33 <opqdonut> :t liftM2 (,)
00:04:35 <lambdabot> forall a1 a2 (m :: * -> *). (Monad m) => m a1 -> m a2 -> m (a1, a2)
00:04:51 <opqdonut> :t liftM2 (,) (+1)
00:04:54 <lambdabot> forall a2 a. (Num a) => (a -> a2) -> a -> (a, a2)
00:05:13 <opqdonut> no, the (->) monad
00:05:20 <Japsu> hmm
00:05:22 <Japsu> interesting
00:05:23 <opqdonut> otoh,
00:05:41 <opqdonut> > ((+1) &&& (*2)) 1
00:05:42 <lambdabot>  (2,2)
00:05:50 <opqdonut> gah bad example
00:05:51 <opqdonut> > ((+1) &&& (*2)) 2
00:05:52 <lambdabot>  (3,4)
00:05:56 <opqdonut> there ^_^
00:06:24 <Japsu> hmm hmm, &&& was some arrow-thingy?
00:06:34 <kmb> :t &&&
00:06:36 <lambdabot> parse error on input `&&&'
00:06:39 <wolverian> :t (&&&)
00:06:40 <Japsu> :t (&&&)
00:06:42 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:06:43 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
00:06:48 <wolverian> spammer!
00:06:52 <Japsu> hehe
00:07:12 <opqdonut> yeah arrows
00:07:30 <opqdonut> :t (***) -- is another nice one
00:07:32 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (Arrow a) => a b c -> a b' c' -> a (b, b') (c, c')
00:09:10 <Japsu> hmm, can I do this
00:09:26 <Japsu> > ((+1) &&& (+2) &&& (+3)) 1
00:09:27 <lambdabot>  (2,(3,4))
00:09:41 <Japsu> hmm, semi-expected
00:10:13 <hpaste>  kmb pasted "Anyone have a suggestion on how to write this in point-free style?" at http://hpaste.org/316
00:14:42 <kmb> @pl (\a -> ((f1 $ f2 y), y)) where y = f3 $ f4 a
00:14:42 <lambdabot> (line 1, column 34):
00:14:42 <lambdabot> unexpected "="
00:14:42 <lambdabot> expecting variable, "(", operator or end of input
00:25:10 <goltrpoat> wrote a quick uneducated expository article on feistel networks and DES in haskell, case anyone's interested:  http://vandreev.wordpress.com/2007/06/18/feistel-ciphers-and-des-in-haskell/
00:25:14 <lambdabot> Title: Feistel Ciphers and DES in Haskell. « codeland, http://tinyurl.com/26rdw2
00:26:07 <edwardk> kmb: (f1 . f2 &&& id) . (f3 . f4)
00:26:09 <edwardk> er
00:26:13 <goltrpoat> hey edwardk
00:26:15 <edwardk> i might have precedence wrong
00:26:20 <edwardk> heya goltrpoat, ltns
00:26:32 <goltrpoat> what are you up to?
00:26:41 <edwardk> ((f1 . f2) &&& id) . (f3 . f4) should work
00:27:09 <edwardk> not much, working on my toy compiler, moved to boston, i think thats new since we last talked.
00:27:17 <goltrpoat> ah
00:29:14 <edwardk> how is life in the wonderful world of the game industry? we were jabbering about it on #haskell-blah a little earlier.
00:30:03 <goltrpoat> eh.  slaving on contract work.  got an original title in production though, with a bigger one coming up.
00:30:58 <edwardk> reading your feistel writeup
00:32:22 <goltrpoat> cool.  i know remarkably little about the topic, so i figured i should write about it
00:32:30 <edwardk> have you seen http://www.haskell.org/crypto/ ?
00:32:31 <lambdabot> Title: The Haskell Cryptographic Library
00:32:55 <goltrpoat> i just started checking it out after posting that
00:33:55 <edwardk> i have some generic code for feistel networks in java that i used when i was maintaining my java cryptography provider some years back i was thinking about porting
00:33:59 <goltrpoat> i was mostly just trying to figure out if things like DES/AES/Blowfish/etc could be all written in terms of a generic Feistel network implementation
00:34:10 <edwardk> hrmm
00:34:12 <goltrpoat> ah cool
00:34:27 <edwardk> not sure they are all purely feistel, i'd have to check
00:34:44 <goltrpoat> well, DES is not purely Feistel for one
00:34:47 <edwardk> yeah
00:36:02 <goltrpoat> but the actual cipher (after key scheduling / plaintext preparation / etc) looks fairly elegant in terms of an existing feistel implementation as a HOF
00:36:17 <goltrpoat> or.. fairly elegant compared to my first straightforward version, anyway
00:36:23 <edwardk> i focused mostly on secure hashes, coz that was what struck my fancy at the time. still have a bunch of springer verlag journals i had to pay cold hard cash for because they were the only references for some algorithms like the korean HAS-V, etc.
00:36:33 <goltrpoat> ah
00:37:13 <goltrpoat> seems like fun stuff, all in all.
00:38:11 <edwardk> i hadn't gotten to abstracting the internals of different algorithms so much, as i spent most of my time figuring out how to cheat and pass out of band information to enable me to get a real class hierarchy to reflect different modes and paddings, etc through the horribly crippled JCA/JCE interface.
00:38:23 <goltrpoat> on a related note, i really wish wordpress would stop turning things like 0xff into 0\times ff
00:38:32 <edwardk> heh
00:38:46 <edwardk> does it do that in <code>?
00:38:57 <edwardk> never ran into that problem myself
00:38:58 <goltrpoat> it's doing that in embedded html and blockquotes
00:39:06 <goltrpoat> i never got <code> to actually like.. work
00:39:22 <goltrpoat> maybe they've fixed it since then
00:40:01 <edwardk> testing it on my copy
00:40:35 <edwardk> its not doing that to me inside OR outside of code for that matter. =/
00:40:36 <goltrpoat> i usually run code through HsColour and then put <font size="3"> </font> around it
00:40:42 <goltrpoat> hmm, odd.
00:40:59 <edwardk> i have a cheesy little hack that uses the perl vim color cpan module
00:41:08 <edwardk> that way i just write it up in the interface
00:41:11 <goltrpoat> ah
00:41:40 <edwardk> between that and another hack that lets me do inline latex i have official spent more time coding on my blog than writing on my blog ;)
00:41:46 <edwardk> er officially
00:41:47 <goltrpoat> haha
00:42:04 <goltrpoat> i'm fairly disappointed with the newfangled latex support
00:42:18 <goltrpoat> unless there's something i'm missing, and there's a way to get rid of the half an inch of whitespace it includes on both sides
00:42:57 <edwardk> what are you using to support latex?
00:43:09 <goltrpoat> that automatic differentiation post was before they added that, so i just used mathbin and inserted it as images
00:43:16 <goltrpoat> but then they added the $latex ...$ markup
00:43:54 <edwardk> ah
00:43:57 <goltrpoat> which.. is nice, but it pads it with rather remarkable amounts of whitespace
00:44:03 <edwardk> i tweaked a third party package for it
00:44:10 <goltrpoat> ah cool
00:44:54 <edwardk> primarily because i needed things like sequents, etc. like: http://comonad.com/reader/2006/overloaded-functions-with-subtyping/
00:44:58 <lambdabot> Title: The Comonad.Reader » Overloaded Functions with Subtyping, http://tinyurl.com/ys39ds
00:45:38 <edwardk> not that i've really gotten around to using it a whole hell of a lot
00:46:21 <goltrpoat> purdy.  you're running it locally though, right
00:46:30 <edwardk> yeah
00:46:37 <goltrpoat> i don't know how much i can do with wp hosting it
00:46:43 <edwardk> they have some sort of web service they are using?
00:46:47 <edwardk> ah
00:52:28 <goltrpoat> oh, another nice side effect of abstracting out the feistel portion is that going from DES to triple DES consists of just concatenating three key schedules
00:52:53 <edwardk> ah neat
00:52:55 <jpcosta> hello all
00:53:24 <edwardk> the problem of course being that by the time you add all the strictness annotations and contort things, etc. to make that thing speedy its going to be pretty horrendous ;)
00:53:32 <goltrpoat> oh absolutely
00:53:32 <goltrpoat> hehe
00:53:44 <jpcosta> i'm a newbie with a simple question :)
00:53:56 <edwardk> > filter (/= "goose") $ let typo (x:y:xs) s = (uncurry (++) . (id *** (((['a'..'z'] !! (y `mod` 26)) :) . tail)) $ splitAt (x `mod` length s) s,xs) in map (\x -> fst $ typo (randoms (mkStdGen x)) "goose") [1..10]
00:53:58 <lambdabot>  ["gdose","gpose","goqse","goosa","goosq","goosr","soose","goise","goese"]
00:54:02 <jpcosta> what does the error "irrefutable patterns" means?
00:54:07 <edwardk> the things we'll do when we get bored.
00:54:20 <goltrpoat> haha jesus
00:54:38 <goltrpoat> jpcosta:  what's the error message?
00:55:02 <edwardk> an irrefutable pattern is a lazy pattern, no? a ~ in the pattern side?
00:55:28 <edwardk> @src curry
00:55:29 <lambdabot> curry f x y = f (x, y)
00:55:33 <edwardk> @src uncurry
00:55:33 <lambdabot> uncurry f p = f (fst p) (snd p)
00:55:51 <edwardk> uncurry f ~(x,y) = f x y
00:56:22 <edwardk> if you have a case with multiple irrefutable patterns you probably get an error because it can't choose one.
00:56:46 <goltrpoat> edwardk:  there's a bunch of different constructions for irrefutable patterns
00:58:13 <jpcosta> the error is: "Irrefutable pattern failed for pattern ..."
00:58:16 <edwardk> let head' ~(x:xs) = x in head' []
00:58:19 <edwardk> er
00:58:25 <edwardk> > let head' ~(x:xs) = x in head' []
00:58:26 <lambdabot>   Irrefutable pattern failed for pattern (x : xs)
00:58:30 <edwardk> that sort of thing?
00:58:35 <jpcosta> yeah
00:58:46 <jpcosta> but i'm not using '~' anywhere
00:58:54 <edwardk> @hpaste
00:58:54 <lambdabot> Haskell pastebin: http://hpaste.org/new
00:59:02 <edwardk> can you paste the code in question to that url?
00:59:16 <jpcosta> it is quite large, but i'll paste
01:00:00 <edwardk> oh wait, let pattern bindings are also irrefutable aren't they?
01:00:38 <hpaste>  jpcosta pasted "irrefutable pattern" at http://hpaste.org/317
01:00:50 <goltrpoat> var@pat for irrefutable pat is irrefutable, variables, wildcards, and patterns of the form D pat where D is a newtype and pat is irrefutable
01:00:54 <edwardk> > let x:xs = [] in x
01:00:55 <jpcosta> i'm using guards
01:00:55 <lambdabot>   Irrefutable pattern failed for pattern x : xs
01:01:01 <jpcosta> in a function
01:01:14 <ClaudiusMaximus> can the character '<' occur in a type expression?  wondering if i could use it as sugar, like "f :: Int -> <Int, Int, Int>" to signify that f has three "outlets" (as opposed to one "outlet" that emits a tuple)
01:01:48 <jpcosta> can this can happen if two guards apply at the same time?
01:01:52 <edwardk> you can't sneak it in there in a legal syntactic way
01:01:55 <goltrpoat> jpcosta:  which line? :)
01:02:14 <jpcosta> oh, sorry
01:02:16 <edwardk> jp: guards are basically checked in order until one passes
01:02:22 <jpcosta> let me check
01:02:41 <edwardk> its probably something accessing insts or all when insts or all are []
01:02:50 <jpcosta> this line: " let (inner, outer@(outer_x:outer_xs)) = break (\(_, ident, _) -> ident == i) xs
01:03:27 <jpcosta> at the guard: | tok == "IF" =
01:03:39 <goltrpoat> :t break
01:03:42 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:04:52 <ClaudiusMaximus> edwardk: was that response in my direction?  the bit about legal syntax (because I don't have a problem unless it *is* legal syntax)
01:06:51 <edwardk> parseKarelBlock ((_,i,[]):xs) _ = parseKarelBlock xs i; parseKarelBlock ((_,i,"--":_):xs) _ = parseKarelBlock xs i -- might be a bit easier than the length insts == 0 check
01:07:29 <edwardk> ClaudiusMaximus: its not a legal syntax, and afaik there is no way to build such a construction so that it can be.
01:08:09 <jpcosta> edwardk, thanks for the tip =)
01:08:13 <jpcosta> I will change that
01:08:20 <goltrpoat> it would really help to break that function up into about 20 smaller functions :)
01:08:23 <edwardk> yeah
01:08:25 <ClaudiusMaximus> edwardk: great, thanks (context: that means i can use it as syntax in my preprocessor)
01:08:27 <edwardk> that is quite a monster =)
01:08:35 <jpcosta> and I think I know what's the problem now
01:09:08 <jpcosta> at the break, (inner, outer) etc...
01:09:20 <edwardk> claudius: you'll want to be careful because you can get some tricky syntactic cases where someone can legally say <a,b> in code inside things like (c <a,b> d)  returning a pair of booleans =)
01:09:22 <jpcosta> outer might be [] sometimes, but I'm using it afterwards
01:09:58 <edwardk> jpcosta ah
01:09:59 <goltrpoat> ah
01:10:13 <jpcosta> goltrpoat, i know.. i should look into it, but I knew little haskell when I started writing this :P
01:10:58 <goltrpoat> -nod- just saying :)
01:11:28 <edwardk> also if you can turn around and transform those tokens into data constructors, and move into steps you'll probably parse that a lot faster, thats a LOT of string comparing you're doing there
01:17:49 <ClaudiusMaximus> edwardk: sure, but as long as it's not in type annotations i'll be fine (the code i'm preprocessing is of the form ":: R -> S -> <S,R>;\nL r s -> [(Nothing, Just r),(Just s, Nothing)]\n", the API i'm using doesn't allow the characters "\{}" so i have to preprocess heavily in any case...
01:18:26 <edwardk> kk
01:19:27 <jpcosta> edwardk, how can I do that?
01:19:43 <edwardk> jpcosta: i'd need a little more context, what kind of tokens do you have?
01:20:08 <edwardk> i see WHILE, IF, etc. but i presume you have some form of identifier as well, and comments?
01:20:09 <jpcosta> I'm parsing text.. I can't see a way to transform it to data without a lot of text comparison...
01:20:34 <edwardk> sure, but you repeat that text comparison from guard to guard over and over.
01:20:48 <jpcosta> ohh, i see what you mean
01:20:59 <edwardk> | tok == "WHILE" && ...    | tok == "WHILE" && ...
01:22:26 <jpcosta> I can do that transformation
01:22:35 <edwardk> thats one issue, another is that it may be faster to go through and classify your tokens in a first pass, transforming them to a limited data type like data Token = WHILE | IF | COMMENT | IDENT String | ...      so that when you check | tok == WHILE its really fast behind the scenes
01:22:59 <edwardk> the value of that is somewhat lessened if you only do this one pass over the data
01:23:20 <edwardk> but it seems you are already chunking up some sort of original text into tokens anyways, so thats a decent time to do it
01:23:44 * goltrpoat mumbles something about Parsec
01:23:56 <jpcosta> eheh, I had issues with parsec
01:23:57 <edwardk> i was going to say the same thing, but i didn't want to scare him off =)
01:24:10 <quicksilver> parsec is not the only parsing library
01:24:16 <quicksilver> and there is nothing wrong with writing your own, either
01:24:23 <jpcosta> i also tryed alex and happy, but coulnt make it to work wither
01:24:27 <quicksilver> but having a datatype for tokens is likely to be sane
01:24:42 <quicksilver> I don't think alex + happy is a particularly good idea; they're quite heavywegith for what you're doing
01:25:12 <goltrpoat> of course there's nothing wrong with writing your own -- that was one of my first haskell projects actually
01:25:22 <goltrpoat> might be a good reference though, if anything
01:25:30 <jpcosta> the big problem is that the language I am parsing, although simple, has identation context
01:25:34 <jpcosta> like in python
01:25:54 <jpcosta> and I couldnt keep record of the identation with parsec
01:26:19 <jpcosta> i'm sure it is possible, but I couldnt find how
01:26:28 <edwardk> you can track it but you aren't parsing a string, you parse a string and an indentation state pair.
01:26:29 <quicksilver> parsec has state in it
01:26:36 <quicksilver> and that's what you use
01:26:37 <edwardk> or you carry state
01:26:47 <quicksilver> actually I like to solve that kind of problem with multiple passes
01:26:54 <quicksilver> first pass gets the lines and the indentations
01:26:55 <edwardk> parsing haskell-style layout rules has similar issues
01:26:59 <goltrpoat> or you convert it to indentation-agnostic form in a preprocess
01:27:05 <quicksilver> next pass tries to make the syntax tree
01:27:10 <quicksilver> multiple pass parsing may not be the fastest
01:27:17 <quicksilver> but it can be easier to understand and test
01:27:23 <jpcosta> i'm doing it now with a single pass
01:27:38 <edwardk> http://www.haskell.org/onlinereport/syntax-iso.html#layout gives the way haskell parses layout internally
01:27:39 <lambdabot> Title: Haskell 98 Syntax
01:27:39 <edwardk> yeah
01:27:47 <quicksilver> (lazy evaluation and a good optimizer quite often join your passes together at compile time)
01:28:30 <jpcosta> but i'm not too much worried with efficiency
01:28:38 <goltrpoat> jpcosta:  as a completely different angle, if you want to do it in a single pass, check out jack crenshaw's let's build a compiler series from the 80s
01:28:52 <edwardk> i wind up using a similar trick to that in a toy language of mine, i have a first pass which is a cheesy packrat lexer, i get back the indentations and the lexemes from that then i parse from there.
01:28:54 <goltrpoat> it's in pascal, and it's very much a toy language, but it's fairly elegant code
01:29:01 <jpcosta> i'm only parsing like 50-100 lines of text
01:29:03 <quicksilver> anyhow, back to jpcosta's code
01:29:05 <edwardk> =)
01:29:12 <edwardk> heh, you're probably fine there jp =)
01:29:13 <quicksilver> I think it's just good design to have a data type to represent your tokens
01:29:30 <quicksilver> helps you test 'bits' of your parsing algoriothm etc
01:29:30 <jpcosta> quicksilver, I've done that :)
01:29:56 <edwardk> heh while we've been talking about what he should do he has apparently been off doing it ;)
01:30:06 <goltrpoat> heheh
01:30:34 <hpaste>  jpcosta pasted "data tokens" at http://hpaste.org/318
01:30:44 <jpcosta> sorry the comments are in portuguese
01:32:18 <jpcosta> the parsing and running are almost done.. I'm just trying to fix some bugs now
01:32:19 <edwardk> i think by token the meaning was the lexemes, that is more of the abstract syntax representation
01:32:26 <edwardk> but whatever works
01:32:55 <jpcosta> that what I meant :p
01:33:42 <jpcosta> I bet the gods of compilers theory are looking down with anger to me eheheh
01:33:49 <edwardk> heh
01:34:18 <edwardk> no worries, i figure i'm first on their hitlist, when i go, THEN you'll know you're in trouble ;)
01:34:30 <goltrpoat> you might save yourself some typing by writing data KarelCondition = FrontIsClear | FacingNorth | ... | Not KarelCondition (instead of spelling out FrontIsBlocked, NotFacingNorth, etc)
01:35:02 <goltrpoat> depends on what the syntax looks like though i guess
01:35:12 <jpcosta> oh, but there isnt a 'not' keyword
01:35:29 <jpcosta> there's the 'facing-north' and the 'not-facing-north'
01:35:36 <goltrpoat> ah
01:35:54 <jpcosta> (i didn't make up this language :p )
01:35:58 <edwardk> ya but nothing prevents the intermediate language from being more expressive than the surface syntax ;)
01:37:01 <edwardk> parse ('n:'o':'t':'-':foo) = Not (parse foo)     and you cut your cases in half.
01:37:12 <edwardk> =)
01:37:16 <goltrpoat> heheh
01:37:23 <jpcosta> huhh, nice tip!
01:37:26 <jpcosta> thanks =)
01:38:58 <jpcosta> by the way: this language defines the movement of a robot, and I'm supposed to do a GUI in Java
01:39:16 <edwardk> how not-fun =)
01:39:30 <jpcosta> my teacher sugested sockets but... isn't there a better way?
01:40:01 <edwardk> so is this language the stream of messages that is going over the socket?
01:40:15 <edwardk> there are lots of ways, depends on what you're most comfortable coding.
01:40:15 <jpcosta> i might go against all his orders and do the GUI in haskell as well
01:40:23 <edwardk> sockets are easy and well understood
01:40:52 <edwardk> most importantly they can be easy to debug
01:41:00 <jpcosta> no, with haskell i'm supposed to parse and interpret the code
01:41:08 <jpcosta> tha java bit is just to show the movement
01:41:11 <edwardk> ah
01:41:28 <goltrpoat> if you're interpreting it, then i'd really trim down that AST a fair bit
01:41:35 <edwardk> you could just do the gui in haskell using one of the gtk interfaces
01:41:47 <jpcosta> wich one do you suggest?
01:42:03 <jpcosta> i've looked into wxHaskell but it seems a bit outdated
01:42:11 <edwardk> well, ifthen and ifthenelse can be merged, just use the empty list for else
01:42:17 <goltrpoat> was about to suggest that
01:42:25 <goltrpoat> the conditions can be trimmed down further as well
01:42:30 <jpcosta> yes
01:42:45 <jpcosta> uhh, it seems a lot of refactoring is neeeded
01:42:52 <edwardk> the conditions can be folded in on themselves by breaking them up a bit
01:43:19 <goltrpoat> something like data KarelCondition = IsClear Direction | Facing Facing | Beeper Proximity | BeepersInBag | Not KarelCondition
01:43:33 <goltrpoat> er.. NextToBeeper, not Beeper Proximity
01:43:59 <edwardk> data Side = Front | Back | Left | Right; data Dir = North | South | East | West; data Cond = Facing Dir | Not Cond | Clear Side | Blocked Side | NextToBeeper | BeepersInBag
01:44:37 <edwardk> even better Clear Side and Blocked Side are negations, so you can scrap Blocked Side =)
01:44:45 <goltrpoat> ?quote stereo
01:44:45 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
01:45:02 <edwardk> data Cond = Facing Dir | Clear Side | NextToBeeper | BeepersInBag | Not Cond
01:45:09 <jpcosta> I think that would mean a complete re-write
01:45:17 <edwardk> lot shorter than KarelCondition
01:45:55 <goltrpoat> actually, no.  you can quickly make it work by writing frontIsClear = Clear Front; notFrontIsClear = Not (Clear Front), etc
01:46:06 <goltrpoat> and decapitalizing the first letters of your conditions, unless you're pattern matching on them
01:46:11 <goltrpoat> then gradually phase it out
01:46:39 <jpcosta> but I have so much things I could improve.. I think I would benefit from a starting over
01:46:55 <jpcosta> i'm just afraid of not meeting the due date
01:46:57 <edwardk> the nice part is you rapidly start having code that refactors out this way
01:47:08 <goltrpoat> -nod-
01:48:04 <jpcosta> well, thanks for all your advices goltrpoat and edwardk
01:48:09 <edwardk> no problem
01:48:13 <goltrpoat> np
01:48:16 <edwardk> going to go get a couple hours sleep before work =)
01:48:23 <goltrpoat> likewise
01:48:31 <edwardk> don't be a stranger gp.
01:48:31 <goltrpoat> later
01:48:35 <jpcosta> i'm going for zen meditation and figure out what to do next :p
01:48:38 <edwardk> =)
01:48:41 <goltrpoat> hehe
01:48:45 <goltrpoat> see ya around
01:48:51 <jpcosta> see ya
01:50:16 <Syzygy-> ?hoogle (a,b) -> (b,a)
01:50:16 <lambdabot> Data.Graph.Inductive.Query.Monad.(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
01:50:24 <Syzygy-> Hmph.
01:51:18 <edwardk> @type snd &&& fst
01:51:20 <lambdabot> forall a b. (a, b) -> (b, a)
01:51:35 <DRMacIver> Nice.
01:52:10 <edwardk> i always thought haskell just needed a 'flip' in the prelude
01:52:25 <DRMacIver> ?t flip
01:52:25 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
01:52:29 <DRMacIver> ?type flip
01:52:31 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
01:52:35 <edwardk> ah
01:52:38 <edwardk> er one for pairs =)
01:52:53 <edwardk> swap even
01:52:55 <edwardk> @type swap
01:52:57 <DRMacIver> Yeah, I knew what you meant. I was pointing out that it did something else. :)
01:52:57 <lambdabot> Not in scope: `swap'
01:52:59 <edwardk> there =)
01:53:03 <edwardk> yeah
01:53:16 <edwardk> @djinn (b,a) -> (a,b)
01:53:16 <lambdabot> f (a, b) = (b, a)
01:53:18 <edwardk> =)
01:53:30 <edwardk> though with a lazy pattern
01:53:32 <DRMacIver> ?pl let f (a, b) = (b, a) in f
01:53:32 <lambdabot> uncurry (flip (,))
01:53:43 <DRMacIver> Ah. That's the one I was trying to come up with before you beat me to it. :)
01:53:59 <edwardk> yours is at least all prelude
01:54:07 <edwardk> mine cheats and drags on Control.Arrow
01:54:12 <DRMacIver> Yeah, but I didn't actually get mine to work. :)
01:54:15 <edwardk> =)
01:55:14 <edwardk> alright, sleepy time
01:55:22 <DRMacIver> Sleep well
01:55:29 <edwardk> night man
01:57:03 <DRMacIver> alrighy, worky time.
02:00:41 <edwardk> bah haskell.org: IOError: [Errno 13] Permission denied: 'data/pages/HaskellUserLocations/last-edited' =/
02:01:50 <edwardk> took the edit though, strange
02:01:55 <edwardk> oh well, night
02:19:40 <Serge> > (1,1) > (1,0)
02:19:41 <lambdabot>  True
02:19:43 <Serge> Neat.
02:19:55 <kaol> > (1,1) > (0,1)
02:19:56 <lambdabot>  True
02:20:01 <kaol> > (1,1) > (0,2)
02:20:03 <lambdabot>  True
02:20:07 <kaol> > (1,1) > (2,0)
02:20:08 <lambdabot>  False
02:21:28 <kolmodin> I've seen a t-shirt online with the print something like: "What about [types] do you not understand?"   where [types] is a bunch of rules. does anyone have the url? I can't find it anymore
02:22:32 <Serge> > (1,'b') > (1,'a')
02:22:33 <lambdabot>  True
02:22:50 <kaol> > True > False
02:22:51 <lambdabot>  True
02:22:55 <Serge> =0
02:23:23 <Serge> > [1..] > [3..]
02:23:25 <lambdabot>  False
02:23:40 <kaol> > [1..] < [3..]
02:23:42 <lambdabot>  True
02:24:17 <kaol> > [1..] < ([3..] ++ [1])
02:24:23 <lambdabot>  True
02:24:29 <kaol> what?
02:24:57 <Serge> Clever bot, can append to an infinite list =o
02:25:15 <kaol> nah, it only solved the halting problem
02:25:45 <andun> > [1..] == ([1..] ++ [1])
02:25:51 <lambdabot> Terminated
02:27:44 <Serge> > [1..] > (reverse [2..])
02:27:50 <lambdabot> Terminated
02:28:22 <Serge> > (tail [1..]) > [1..]
02:28:24 <lambdabot>  True
02:28:25 <Serge> hmm
02:29:07 <quicksilver> lexicographic ordering, calculated lazily
02:29:17 <quicksilver> it only needs the first element of tail [1..]
02:29:20 <quicksilver> since 2 > 1
02:29:23 <Serge> Ah.
02:29:42 <kaol> > ['a'..]
02:29:43 <lambdabot>  "abcdefghijklmnopqrstuvwxyz{|}~\DEL\128\129\130\131\132\133\134\135\136\137\...
02:30:01 <LeCamarade> > and $ map (\_ -> True) [1 ..]
02:30:07 <lambdabot> Terminated
02:30:14 <quicksilver> > [1,2,3,4]++[1..] < [1..]
02:30:15 <lambdabot>  True
02:30:21 <LeCamarade> > or $ map (\_ -> True) [1 ..]
02:30:23 <lambdabot>  True
02:30:24 <quicksilver> ^^ this one needs to get up to the 5th element
02:31:59 <Serge> > [1..] > [1,3..]
02:32:01 <lambdabot>  False
02:32:09 <Serge> Lexicographical again, eh
02:33:27 <Serge> > [2..] > [1,3..]
02:33:29 <lambdabot>  True
02:33:57 <chowmeined> sure, that makes sense
02:33:58 <opqdonut> [2..]<[2..]
02:33:59 <opqdonut> ^_^
02:34:02 <opqdonut> > [2..]<[2..]
02:34:07 <chowmeined> false
02:34:09 <lambdabot> Terminated
02:34:09 <kaol> > take 10 [2..]
02:34:11 <lambdabot>  [2,3,4,5,6,7,8,9,10,11]
02:34:34 <chowmeined> > [2..] > [1..]
02:34:36 <lambdabot>  True
02:34:40 <chowmeined> thats false
02:35:13 <opqdonut> how do you know < for lists satisfies the laws (transitivity, antisymmetry, comparativity) when all cases are not computable?
02:35:26 <opqdonut> (sure, they are provable, but the runtime can't prove them)
02:35:40 <chowmeined> well maybe it doesnt sum them
02:35:47 <chowmeined> how does it evaluate those?
02:35:50 <opqdonut> (i mean, how do you prove those laws for _this implementation_ not the relation itself)
02:35:58 <Cale> It's using the lexicographic order
02:36:00 <quicksilver> chowmeined: lexicographic ordering
02:36:08 <quicksilver> chowmeined: like a dictionary
02:36:18 <Cale> That is, it compares the first elements, then only if they're equal, will it compare the rest.
02:36:23 <chowmeined> ah
02:36:24 <quicksilver> > "aardvark" < "aardman"
02:36:25 <lambdabot>  False
02:36:49 <quicksilver> opqdonut: I don't understand your point
02:36:59 <quicksilver> opqdonut: the runtime doesn't have proof obligations, the programmer does
02:37:05 <quicksilver> opqdonut: and the programmer can prove them no problem
02:37:11 <quicksilver> opqdonut: the runtime just runs it and doesn't care
02:37:14 <LeCamarade> <NAIVE LANGUAGE=ANY_STRICT RELATED=HASKELL>Can one just chain statements with the `and' operator, which is usually lazily-evaluated, to fake lazy evaluation in strict languages?</NAIVE>
02:37:16 <opqdonut> quicksilver: yeah. how does the programmer prove the laws for _this implementation_
02:37:35 <opqdonut> as some relations (eg between [1..] and [1..]) are not defined
02:37:52 <opqdonut> well, i guess infinite lists aren't really in the problem domain here
02:37:53 <quicksilver> opqdonut: well you proof it's partially correct
02:38:12 <quicksilver> which is the best you can hope for in haskell anyway
02:38:15 <opqdonut> yeah, ignoring infinite lists is really not a problem
02:38:16 <opqdonut> yes
02:38:17 <dobblego> <dobblego>      how do you ask lambdabot for the source to an instance of a type class?
02:38:19 <quicksilver> since any value may be _|_
02:38:26 <dobblego> (sorry, my wireless dropped out)
02:38:27 <quicksilver> you don't ignore infinite lists, actually
02:38:33 <quicksilver> you prove partial correctness
02:38:40 <quicksilver> but some of the cases proved are definitly infinite
02:38:59 <opqdonut> yeah, okay
02:39:32 <Cale> It's called coinduction (although it follows from mathematical induction)
02:40:21 <quicksilver> of course, we shouldn't actually get too hung up on the rules for Ord
02:40:29 <quicksilver> since we violate all kinds of other proof obligation all the time
02:40:40 <Serge> > foldr1 (*) [1..100]
02:40:42 <lambdabot>  9332621544394415268169923885626670049071596826438162146859296389521759999322...
02:40:53 <quicksilver> > abs (negate (42::Word8)) == 42
02:40:55 <lambdabot>  False
02:41:08 <Cale> heh
02:41:31 <quicksilver> (however, the correct operation of Data.Map requires a sensible implementation of Ord, while nothing requires a sensible abs.negate law that I am aware of)
02:41:33 <sieni> > abs (negate (42::Word8))
02:41:34 <lambdabot>  214
02:41:56 <sieni> > negate (42::Word8)
02:41:58 <lambdabot>  214
02:42:21 <dobblego> where can I find the source to the State monad?
02:42:29 <Boney> > 255 - 42
02:42:30 <lambdabot>  213
02:42:38 <dobblego> (damn I hate searching through GHC source)
02:42:47 <sieni> > (-42) `mod` 256
02:42:48 <lambdabot>  214
02:42:50 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-State.html -- look at the top bar
02:42:52 <lambdabot> http://tinyurl.com/yx2t8w
02:43:12 <Cale> er, first click the link to go to Control.Monad.State.Lazy
02:43:19 <Cale> and then click the source link
02:43:53 <dobblego> all this time and I'd never seen that source link
02:43:56 <dobblego> thanks
02:44:15 <Cale> It's only a couple months old I think.
02:44:24 <dobblego> oh I feel better then :)
02:48:30 <araujo> morning
02:48:55 <araujo> a good synonym for 'description' ?
02:49:00 <kolmodin> araujo!!!!!!
02:49:03 <araujo> to be used as a keyword
02:49:05 <kolmodin> good morning to you
02:49:08 <araujo> kolmodin!!!!!!!
02:49:12 <araujo> @yarr!
02:49:13 <lambdabot> I want me grog!
02:49:17 <kolmodin> hey, you are a really early bird today!
02:49:29 <araujo> haha
02:49:38 <kolmodin> ?localtime araujo
02:49:39 <lambdabot> Local time for araujo is Mon Jun 18 05:43:32
02:49:39 <araujo> yeah :-)
02:49:44 <kolmodin> impressive, aye?
02:49:52 <araujo> hah, nah ....
02:50:03 <kolmodin> I woke at 7am and did 2 machines of laundry
02:50:07 <araujo> you can do the same with a good dose of coke :-)
02:50:08 <kolmodin> then I went to work :)
02:50:19 <kolmodin> not at the time I fell asleep
02:50:41 <araujo> so you have bee up very early too? :-)
02:50:58 <kolmodin> depends on who you are comparing with
02:51:12 <kolmodin> some of my collegues are already here before I wake up...
02:52:44 <kolmodin> s/with/to/
02:52:44 <araujo> oh
02:53:00 <kolmodin> yeah, they are here at 7am :) impressive
02:53:07 <kolmodin> not everyone, but hey
02:53:27 <araujo> aha, most jobs here start at 7am here too
02:53:33 <jpcosta> sometimes 7am is my bed time!!
02:53:41 <araujo> for me too
02:53:44 <kolmodin> araujo: whaaaat?
02:53:56 <kolmodin> araujo: most jobs start at 8am here, unless you wish differently
02:54:02 <kolmodin> araujo: and I don't :)
02:54:10 <araujo> interesting
02:54:47 * araujo used to take univ courses at 7am
02:54:52 <kolmodin> yeah, I have two friends with different oppinions on when to go to bed. they usually say hi in the morning. one says good morning and the other says good night
02:55:13 <araujo> though ... s/to take/to sleep at/ :-)
02:55:23 <kolmodin> :)
02:55:55 <LeCamarade> @remember kolmodin yeah, I have two friends with different oppinions on when to go to  bed. they usually say hi in the morning. one says good morning and the other says good night
02:55:56 <lambdabot> Done.
02:56:08 <kolmodin> :)
02:57:09 * araujo takes naps when he feels like so :-P
02:57:49 <jpcosta> at the peak of the semester my mom says i turn into the night shift
02:57:52 <jpcosta> lol
03:01:20 <araujo> they get worried at me when i get sleep at night actually :-P
03:01:33 <kolmodin> hah :)
03:01:42 <kolmodin> is something wrong? why did you go to bed before 2am?
03:01:58 <araujo> bad thing about this .. is that every 2~3 weeks, you get this 2 days sleeping straight syndrome :-)
03:02:13 <araujo> kolmodin, yeah
03:02:43 <kolmodin> araujo: that can't possibly be good :)
03:03:38 <araujo> yeah ... not good for 'real life' :-)
03:04:18 <araujo> i wake up asking to my parents who they are
03:04:20 <araujo> so :-)
03:07:18 <malcolmw> any Colloquy users know anything about solving a problem where all msgs on certain IRC channels are dropped (don't appear on screen)?
03:07:44 <Botje> those messages didn't get approved by steve jobs?
03:08:00 <kolmodin> araujo: ah, probably not good, no :)
03:24:21 <jao> malcolmw, i stopped using colloquy because of that problem. if you change the display theme, the messages appear (and you can then go back to your previous style). but that's a chore.
03:24:36 <malcolmw> jao: thx, will try that
03:35:57 <malcolmw> jao: excellent workaround - thank you
03:36:58 <jao> malcolmw, np :)
03:37:04 <johnnowak> jao: thanks from me as well :)
03:37:09 <johnnowak> now if you could just make it stop crashing...
03:37:32 <malcolmw> johnnowak: colloquy has never crashed for me
03:37:49 <johnnowak> it crashes for me several times a day. it seems related to the SILC support.
03:37:51 <jao> johnnowak, i did: i stopped using it ;)
03:38:02 <johnnowak> i would if i didn't need silc.
03:38:05 <malcolmw> jao: got a better client?  what is it?
03:38:25 <Igloo> irssi is quite nice
03:38:26 <johnnowak> best irc client: http://www.suckless.org/wiki/tools/irc
03:38:27 <jao> malcolmw, only if you're an emacs head: circe
03:38:28 <lambdabot> Title: irc it &mdash; tools/irc &mdash; suckless.org
03:40:48 <johnnowak> quick question: say I want to print a list of strings. In scheme, i'd do (map (lambda (x) (display x) (newline)) <list>)
03:40:54 <johnnowak> how can i achieve this in haskell?
03:41:19 <johnnowak> map putStrLn <list> doesn't seem to work because putStrLn isn't a normal function
03:41:24 <quicksilver> mapM
03:41:31 <johnnowak> thanks quicksilver
03:41:38 <quicksilver> :t mapM putStrLn
03:41:40 <lambdabot>     Ambiguous occurrence `mapM'
03:41:40 <lambdabot>     It could refer to either `mapM', imported from Control.Monad.Writer
03:41:43 <quicksilver> bah
03:41:44 <quicksilver> stupid LB
03:42:00 <quicksilver> :t Control.Monad.mapM putStrLn
03:42:03 <lambdabot> [String] -> IO [()]
03:42:08 <johnnowak> ahh, very good.
03:43:06 <johnnowak> i'm trying to keep a log of my issues as I run through yaht: http://johnnowak.com/heap/yaht.html
03:43:07 <lambdabot> Title: jn/heap/yaht.html
04:04:32 <Serge> > [1.1,1.2..3.0]
04:04:34 <lambdabot>  [1.1,1.2,1.2999999999999998,1.3999999999999997,1.4999999999999996,1.59999999...
04:04:38 <Serge> Eww :(
04:06:20 <quicksilver> that's floating point numbers for you
04:06:22 <scook0> > [1.1,1.2..3.0] :: [Rational]
04:06:23 <lambdabot>  [11%10,6%5,13%10,7%5,3%2,8%5,17%10,9%5,19%10,2%1,21%10,11%5,23%10,12%5,5%2,1...
04:06:25 <quicksilver> don't use them if it bothers you :)
04:06:57 <Serge> That's IEEE for you more like!
04:07:17 <Serge> And... binary floating point in general.. =P
04:07:25 <quicksilver> and, floating point in general
04:07:57 <Serge> Well, if you stored the numbers using a decimal radix
04:08:02 <Serge> As they're written
04:08:22 <Serge> Not that I'm suggesting that's a good idea, mind :P
04:08:46 <|Steve|> When I do that on my computer I get 1.3. Odd.
04:09:30 <Serge> Maybe you've got a processor that works in decimal!
04:09:31 <|Steve|> In fact, I just tried it on 3 different computers and got 1.3 on all of them.
04:09:54 <|Steve|> I tried it on 64 bit ppc (but was probably in 32 bit mode), a 32 bit ppc, and a 32 bit x86.
04:10:05 <Serge> Yeah, I'm kidding :P
04:10:23 <Serge> Maybe the compiler/interpreter you're using?
04:10:25 <Serge> I don't know :C
04:10:32 <|Steve|> Could be, I used hugs.
04:10:38 <Serge> Let me try it on hugs...
04:10:53 <|Steve|> Ah, I do get that with ghci though.
04:10:54 <Serge> Prelude> [1.1,1.2..3.0]
04:10:54 <Serge> [1.1,1.2,1.3,1.4,1.5,1.6,1.7,1.8,1.9,2.0,2.1,2.2,2.3,2.4,2.5,2.6,2.7,2.8,2.9,3.0]
04:11:12 <Serge> =o
04:13:43 <opqdonut> why isn't Float an instance of Enum? it is discrete on the implementation level
04:13:56 <Saizan> ?instances Enum
04:13:57 <lambdabot> (), Bool, Char, Double, Float, Int, Integer, Ordering
04:14:04 <opqdonut> woah it is
04:14:09 <opqdonut> wasn't the last time i checked
04:14:11 <opqdonut> nice :)
04:14:15 <Saizan> you can't use the [x..y] notation without Enum
04:14:23 <Serge> They sneaked it in, when you had your back turned ¬_¬
04:14:34 <opqdonut> Saizan: yeah i wondered
04:14:42 <opqdonut> > take 10 $ [1.0..]
04:14:44 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
04:14:48 <opqdonut> >_>
04:15:00 <opqdonut> > take 10 $ [1.0..] :: [Float]
04:15:01 <lambdabot>  [1.0,2.0,3.0,4.0,5.0,6.0,7.0,8.0,9.0,10.0]
04:15:09 <opqdonut> no, still doesn't do the right thing :)
04:15:12 <opqdonut> > take 10 $ [1.1..] :: [Float]
04:15:13 <Serge> takeWhile (<10.0) [1.1..]
04:15:14 <lambdabot>  [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1,10.1]
04:15:17 <Serge> =/
04:15:24 <opqdonut> mhmm
04:15:35 <Serge> takeWhile (<10.0) [1.0,1.1..]
04:15:42 <opqdonut> > minBound :: Float
04:15:43 <lambdabot>   add an instance declaration for (Bounded Float)
04:15:43 <lambdabot>     In the expression: minB...
04:15:48 <Serge> > takeWhile (<10.0) [1.0,1.1..]
04:15:49 <lambdabot>  [1.0,1.1,1.2000000000000002,1.3000000000000003,1.4000000000000004,1.50000000...
04:15:51 <opqdonut> oh, it's not even bounded :(
04:16:10 <Serge> > takeWhile (<10.0) [1.1..]
04:16:12 <lambdabot>  [1.1,2.1,3.1,4.1,5.1,6.1,7.1,8.1,9.1]
04:17:04 <quicksilver> opqdonut: it has always been an instance of enum, but I'm not sure it does what you expect
04:17:23 <quicksilver> > (fromEnum (1.1 :: Float))
04:17:24 <lambdabot>  1
04:17:32 <quicksilver> > (fromEnum (2.1 :: Float))
04:17:33 <lambdabot>  2
04:17:41 <arjanoosting>  /lastlog night
04:18:02 <opqdonut> quicksilver: yeah, noticed that
04:37:19 <Saizan> > succ . toEnum $ maxBound :: Integer
04:37:20 <lambdabot>  2147483648
04:38:05 <opqdonut> hehe
04:38:36 <opqdonut> :t toEnum maxBound
04:38:38 <lambdabot> forall a. (Enum a) => a
04:38:47 <opqdonut> :t maxBound
04:38:49 <lambdabot> forall a. (Bounded a) => a
04:39:03 <opqdonut> weird, toEnum maxBound not saying anything about Bounded
04:39:21 <Saizan> because toEnum force its fisrt argument to be Int
04:39:28 <opqdonut> ahh
04:39:35 <opqdonut> :t toEnum
04:39:37 <lambdabot> forall a. (Enum a) => Int -> a
04:39:42 <opqdonut> yes i see
04:40:07 <Saizan> otherwise it would have given an ambiguous type constraint, modulo defaulting
04:40:23 <Saizan> s/,/error,/
04:40:33 <opqdonut> yeah
04:40:47 <opqdonut> first i thought maxBound would default to Int or something
04:41:08 <Saizan> > maxBound
04:41:09 <lambdabot>  Add a type signature
04:41:29 <opqdonut> yeah, clearly not :)
04:42:22 <mux> > maxBound `asTypeOf` 'a'
04:42:23 <lambdabot>  '\1114111'
04:44:27 <opqdonut> woah
04:44:39 <opqdonut> :t asTypeOf -- seems nice
04:44:41 <lambdabot> forall a. a -> a -> a
04:44:53 <mux> very useful at times
04:45:03 <opqdonut> haven't really studied this side (enums and coercion) of haskell's type system
04:45:38 <Igloo> asTypeOf isn't a coercion, in the C sense of the word
04:45:46 <mux> and what's funny is that the implementation of it is the same as const, only the type signature changes
04:45:47 <quicksilver> asTypeOf is just a way of avoiding a type annotation, basically
04:45:47 <mux> @src
04:45:47 <mux> @src asTypeOf
04:45:48 <lambdabot> src <id>. Display the implementation of a standard function
04:45:48 <lambdabot> asTypeOf = const
04:46:02 <Igloo> It just arranges that things are used with the type you want due to its type signature
04:46:04 <opqdonut> yeah i thought it'd be something like that
04:46:09 <quicksilver> it's not needed if your haskell implementation allows type annotations everywhere
04:46:16 <quicksilver> (which haskell98 doesn't, but hugs and ghc both do)
04:47:20 <dukedave>  
04:47:20 <mux> quicksilver: I'd say it's a bit more than that because there are situations where you can't use a type signature
04:47:39 <mux> and where you are forced to use asTypeOf
04:47:54 <quicksilver> mux: oh yes, that's a good point
04:48:01 <quicksilver> mux: but that's a bug in the type annotation system :)
04:48:13 <quicksilver> mux: and it's already fixed in GHC isn't it?
04:48:32 <Saizan> it's the lack of scoped type variables?
04:48:42 <mux> heh :) do you think it would be sane for it to have something such as :: asTypeOf x ?
04:49:26 <mux> I wasn't even aware that something of this kind was being worked on
04:49:37 <quicksilver> scoped type variables
04:49:44 <quicksilver> or do I misremember and there is another issue?
04:50:34 <quicksilver> mux: http://www.haskell.org/ghc/docs/latest/html/users_guide/type-extensions.html#scoped-type-variables
04:50:34 <mux> I'm looking that up in GHC trac
04:50:36 <lambdabot> Title: 7.4. Type system extensions, http://tinyurl.com/uxvor
04:50:48 <mux> thanks
04:52:00 <quicksilver> also http://hackage.haskell.org/trac/haskell-prime/wiki/ScopedTypeVariables
04:52:01 <mux> nice, it looks like it would avoid the need for asTypeOf indeed
04:52:04 <lambdabot> Title: ScopedTypeVariables - Haskell Prime - Trac, http://tinyurl.com/3b2sn9
04:52:07 <quicksilver> which is the haskell' ticket for it
04:53:12 <mux> that being said, asTypeOf is nice, haskell98, and it's not even a primitive :)
04:54:51 <quicksilver> true
04:55:01 <quicksilver> it is an example of solving a problem by indirection
04:55:10 <quicksilver> you can program quite clever constraints into the type system
04:55:16 <quicksilver> by using auxiliary functions which do nothing
04:55:22 <quicksilver> but have particular types
04:55:29 <quicksilver> in this way you can "tap into" the unifier
05:09:16 <baboa> hi, quick question
05:09:41 <baboa> I'm trying to build Cabal from darcs, but it need package "pretty-any"
05:09:47 <baboa> where do I get it from?
05:10:21 <Igloo> Hmm, darcs.haskell.org/packages/pretty, but if you do get it then I think you'll just have more problems later on
05:10:33 <Igloo> Best is probably just to remove the dependency from the .cabal file
05:10:42 <Igloo> Assuming you have a released GHC that should work fine
05:10:49 <baboa> 6.6.1
05:10:57 <baboa> what is it for?
05:11:14 <Igloo> Some modules from base were split out into a separate package
05:12:34 <baboa> oh, I see
05:12:50 <baboa> I had to remove also some other packages, directory, old-time, process
05:20:52 <Igloo> baboa: Right, same thing with those
05:21:08 <baboa> thanks, it compiled
05:21:17 <baboa> and works as expected
05:21:39 <baboa> I had some problems on Vista, those are fixed in Cabal 1.1.7
05:29:30 <Serge> > fromEnum True
05:29:32 <lambdabot>  1
05:29:33 <Serge> > fromEnum False
05:29:34 <lambdabot>  0
05:39:15 <johnnowak> might anyone care to tell me the less long way around to solve this problem: http://pastie.caboo.se/71358
05:39:17 <lambdabot> Title: #71358 - Pastie
05:39:49 <quicksilver> johnnowak: there isn't one, really
05:40:08 <quicksilver> johnnowak: you could join together all the 'nothing' cases which would save you three lines
05:40:38 <quicksilver> johnnowak: and speaking from personal preference I probably wouldn't name the unused varaibles, so there would be lots of _ insteand of a b c
05:42:20 <johnnowak> hmm.
05:42:23 <ddarius> You could give the fields of the "tuples" labels, and then also join all the Just cases.
05:43:04 <johnnowak> i'm not sure i've gotten to that part of the tutorial yet. :)
05:43:33 <ddarius> Yeah, it actually wouldn't help much since you wouldn't be able to join the Nothing cases then.
05:43:49 <johnnowak> how would I join the nothing cases? I thought to do tuple4 (Tuple 4 a b c d) = Just d ; tuple4 _ = Nothing
05:43:58 <ddarius> Yep
05:44:08 <johnnowak> would that not then return Nothing for non-tuples?
05:44:22 <ddarius> johnnowak: The function can only take Tuples.
05:44:48 <johnnowak> ah, because of the previous case?
05:45:25 <ddarius> No, because of it's type.
05:45:56 <johnnowak> hm. but if I just did tuple4 _ = Nothing, how would it only take tuples?
05:46:25 <ddarius> johnnowak: I.e. if that was the whole definition?
05:46:41 <johnnowak> well, following tuple4 (Tuple4 a b c d) = Just d
05:47:14 <ddarius> johnnowak: The first clause of the definition would require that tuple4 :: Tuple a b c d -> Maybe d
05:47:32 <johnnowak> ah right -- that's what i meant by "ah, because of the previous case?"
05:47:44 <colw> quit
05:48:05 <ddarius> johnnowak: You could have a function that -could- work on all things, but restrict it's type.
05:48:23 <ddarius> e.g. tuple5 :: Tuple a b c d -> Maybe e; tuple5 _ = Nothing
05:48:40 <johnnowak> ah, i see the
05:48:44 <johnnowak> then.
05:49:04 <johnnowak> alright, thanks for the help. I just felt as if that couldn't possibly be the right answer. :)
05:49:55 <quicksilver> johnnowak: it's a simple exercise to show you've understood what's gonig on
05:50:03 <quicksilver> johnnowak: it's not clever or particularly realistic :)
05:50:13 <johnnowak> very good then
05:50:15 <quicksilver> johnnowak: it's also very commonly asked about here
05:50:23 <quicksilver> because nobody can believe that's the right way :)
05:51:55 <johnnowak> well I feel less silly then!
05:52:48 <ddarius> The right way is to use Scrap Your Boilerplate like techniques
05:56:27 <johnnowak> i'm more used to: Object clone do (a := b := c := d := nil)
05:56:38 <johnnowak> hence the surprise
05:57:45 <mux> that looks like Io
05:57:49 <johnnowak> it is
05:58:05 <Saizan> Io?
05:58:13 <johnnowak> htttp://www.iolanguage.com
05:58:34 <johnnowak> er, http://www.iolanguage.com
05:59:18 <quicksilver> htttp, web browsing made accessible to those with stutters. (See also htttp)
06:01:01 <johnnowak> :)
06:01:20 <LISAI> .
06:01:23 * DRMacIver should give Io another look.
06:01:27 <LISAI> Hi
06:01:40 <Cale> hi
06:02:06 <johnnowak> Io is the only oo language I really enjoy working with.
06:02:23 <LISAI> I have a problem with ghc 6.6.1 and hs-plugins 1.0. A index out of range appears when i call load
06:03:54 <DRMacIver> johnnowak: I think a better way to solve that would be to declare the TupleN to be different types entirely and use type classes.
06:04:05 <LISAI> Dons, did you have noticed such a error?
06:04:29 <johnnowak> DRMacIver: that'll have to wait until chapter 8
06:04:36 <DRMacIver> ok. :)
06:04:44 <johnnowak> thanks again everyone
06:05:06 <Saizan> johnnowak: ah, to do nothing in IO use return () rather than return []
06:06:08 <johnnowak> ahh
06:06:19 <Cale> They both do nothing, but return () does nothing and returns an empty tuple rather than just an empty list.
06:06:55 <Cale> (So the type of return () is IO () as opposed to IO [a])
06:07:00 <johnnowak> if () is the syntax for an empty tuple, and (a,b) the syntax for a pair.. how do I express a tuple with a single element?
06:07:08 <Cale> There is none.
06:07:12 <DRMacIver> Unit isn't really an empty tuple is it?
06:07:18 <Saizan> so it's more obvious that the action doesn't produce anything useful aside from sideffects
06:07:19 <ddarius> (a) which is isomorphic to a
06:07:20 <DRMacIver> For some value of 'really' that makes sense.
06:07:39 <ddarius> And in Haskell is equal to a (a) just being disambiguating parentheses.
06:07:47 <Cale> DRMacIver: Why not?
06:08:03 <DRMacIver> No good reason I suppose.
06:08:08 <DRMacIver> It just seems an odd way of looking at it. :)
06:08:10 <johnnowak> ddarius: right -- i was wondering if there was something hideous as in python for denoting tuples with a single element, like (a,)
06:08:41 <Cale> There'd be basically no reason to want a 1-tuple
06:08:43 <ddarius> Well, ((),a) and (a,()) is also isomorphic to a singleton tuple modulo bottoms.
06:08:51 <johnnowak> Cale: aye, just curious
06:09:07 <DRMacIver> Hm. Remind me, can I declare that for all a, a is an instance of a class Foo a ?
06:09:13 <Cale> In python, tuples act quite a lot more like lists than they do in Haskell, iirc.
06:09:19 <johnnowak> Cale: true
06:09:38 <johnnowak> well, they are lists. no idea why they call them tuples.
06:09:54 <johnnowak> but then they call arrays lists... so who knows what they're doing
06:10:00 <Cale> DRMacIver: I think it requires -fallow-undecidable-instances
06:10:01 <Saizan> DRMacIver: instance Foo a where? only with undecidable instances iirc
06:10:16 <quicksilver> Cale: well a single tuple would give you a lifted _|_
06:10:27 <quicksilver> Cale: so it would have a semantic consequence
06:10:36 <quicksilver> Cale: I'm not sure if it's desirable though
06:10:39 <Cale> quicksilver: that's true, but there's little reason to want it
06:10:44 <quicksilver> (obvioudly you can just use a new data type)
06:10:47 <Saizan> johnnowak: there are also "real" arrays in python :)
06:11:11 <Cale> There are lots of reasons to want things which are isomorphic to 1-tuples, but you give them interesting names :)
06:11:21 * quicksilver nods
06:11:24 <quicksilver> quite
06:13:23 <johnnowak> briefly back on the Tuple example ... if I use one of those constructors, it fails when trying to print it in the repl. do i have to define show for every type in order to be able to see its values?
06:13:35 <Saizan> yep
06:13:36 <quicksilver> yup
06:13:44 <quicksilver> you can just do 'deriving (Show)' though
06:13:44 <johnnowak> hm. fun.
06:13:47 <quicksilver> so it's not very hard
06:13:56 <johnnowak> ah.
06:14:06 <Syzygy-> dons: There?
06:14:42 <Saizan> data Tuple a b c d = .... deriving (Show)
06:15:56 <DRMacIver> Cale, Saizan: Ok, thanks.
06:19:17 <Serge> Can lambdabot get definitions from the prelude for me? =o
06:19:26 <ddarius> Yes and no.
06:19:35 <Serge> Explain!
06:19:44 <SamB_XP> well, someone has loaded it with some of them
06:19:46 <Serge> If you can be bothered.. :P
06:19:47 <quicksilver> @src head
06:19:47 <lambdabot> head (x:_) = x
06:19:47 <lambdabot> head []    = undefined
06:20:01 <Serge> Ah, thanks
06:20:06 <quicksilver> don't overuse it in the channel though, if people are trying to have conversations
06:20:09 <quicksilver> it all works in PM too
06:20:11 <SamB_XP> @src seq
06:20:12 <lambdabot> Source not found. Where did you learn to type?
06:20:20 <Cale> Some of them are not the definitions you want in order to understand what the programs do.
06:20:22 <Serge> Okey
06:20:25 <Cale> @src foldr
06:20:25 <lambdabot> foldr k z xs = go xs
06:20:25 <lambdabot>     where go []     = z
06:20:25 <lambdabot>           go (y:ys) = y `k` go ys
06:20:28 <Cale> like that
06:20:28 <SamB_XP> of course, seq doesn't actually have reasonable source ...
06:20:52 <Serge> Cale: What do you mean exactly?
06:20:55 <Cale> http://haskell.org/onlinereport/standard-prelude.html
06:20:56 <lambdabot> Title: The Haskell 98 Report: Standard Prelude
06:21:03 <Cale> foldr would be better defined as:
06:21:09 <Cale> foldr f z [] = z
06:21:20 <Cale> foldr f z (x:xs) = f x (foldr f z xs)
06:21:39 <Serge> Ahh, I see
06:21:49 <SamB_XP> so... what's with that other definition?
06:21:56 <Cale> The 'go' thing is a bit of a hack regarding GHC's optimisation.
06:22:05 <johnnowak> if I have two enumerated sets, is there any way to have a value with the same name in each set, or do I need to prefix every name or some such
06:22:26 <quicksilver> johnnowak: you mean enumerated data types, I think
06:22:27 <Cale> johnnowak: You can'
06:22:31 <SamB_XP> GHC isn't smart enough to float that in?
06:22:38 <quicksilver> johnnowak: the standard thing to do is put them in different modules
06:22:48 <johnnowak> eg. alright then
06:22:54 <Cale> johnnowak: You can't have two data types with the same value in them, unless one is actually more general.
06:23:07 <SamB_XP> Cale: he said name, not value
06:23:14 <Cale> Well, yeah :)
06:23:14 <quicksilver> Cale: I think he meant constructors of the same name, in two enumerated types
06:23:45 <Cale> okay
06:23:48 <quicksilver> data Colour = Red | Green | Clear; data Div = Inline | Block | Clear;
06:23:52 <quicksilver> that sort of thing, I imagine
06:23:57 <Cale> There would be trouble with type inference if that was allowed.
06:23:58 <johnnowak> aye
06:24:19 <SamB_XP> indeed
06:24:22 <quicksilver> Cale: well that's not really an insoluble problem, it's just convenient to avoid it
06:24:32 <SamB_XP> yeah, it's not apparantly insoluble...
06:24:43 <SamB_XP> agda seems to be okay with that problem...
06:24:45 <quicksilver> it has the usual 'comprehensible error messages' thing, for example :)
06:24:56 <quicksilver> which applies to most type inference extensions
06:25:15 <ddarius> SamB: It's just structural subtyping.
06:25:16 <Cale> It also probably makes type inference more expensive.
06:25:27 <ddarius> Cale: It can't make it cheaper.
06:29:49 * johnnowak just realizes that the answers are in the back
06:29:49 <baboa> I have a Cabal question
06:30:20 <baboa> How do I create a .cabal with a library and an executable that depends on this library?
06:37:02 <Saizan> ?paste
06:37:02 <lambdabot> Haskell pastebin: http://hpaste.org/new
06:37:14 <malcolmw> baboa: see e.g. cpphs for an example (basically, you need to list the modules twice)
06:39:01 <Saizan> http://www.cs.york.ac.uk/fp/darcs/tagsoup/tagsoup.cabal <-- or this
06:40:57 <kfish> ndm, hi
06:41:01 <baboa> thanks, good examples, but...
06:41:16 <baboa> my library uses some c-sources
06:41:32 <baboa> those aren't linked with the executable
06:41:43 <ndm> hi kfish
06:41:52 <kfish> is ~== gone from tagsoup?
06:41:59 <ndm> kfish: yes, but its coming back!
06:42:04 <kfish> good!
06:42:06 <ndm> kfish: if you use the tarball, that has it in
06:42:12 <kfish> i was in shock earlier today
06:42:26 <ndm> i'll be honest, I didn't realise that patch removing it actually removed it!
06:42:41 <kfish> after writing code yesterday that uses it, and then discovering it gone :-)
06:42:52 <kfish> heh
06:42:59 <baboa> I added: ld-options: dist/build/libHSmylib-0.1.a
06:43:23 <igli> wtf is ~== ?
06:43:36 <igli> regex match or.. ?
06:43:45 <malcolmw> baboa: so don't list the irrelevant parts in the executable stanza, only in the library stanza
06:43:50 <kfish> igli, an operator in tagsoup for doing fuzzy matching
06:44:05 <igli> ah ok similar to ~= then
06:44:06 <quicksilver> @where tagsoup
06:44:06 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/tagsoup/
06:44:13 <shapr> Good morning #haskell!
06:44:14 <malcolmw> baboa: the stanzas are separated by empty lines
06:44:16 <igli> ty quicksilver
06:44:24 <igli> morning shapr :-)
06:44:32 <kfish> igli, as opposed to =~ from Text.Regex ...
06:44:32 <quicksilver> ndm: will tagsoup work on HTML fragments?
06:44:35 * LeCamarade has a string operator that matches with Levenshtein distance spell-check. :o)
06:44:51 <kfish> LeCamarade, nice
06:44:53 <ndm> quicksilver: yes
06:45:19 <quicksilver> ndm: handy
06:45:31 <ndm> quicksilver: it will work on anything that has a "tag soup" feel - fully structured XML down to a toddlers attempt at matching tags
06:45:32 <quicksilver> ndm: does it support writing the HTML out again, having made some changes?
06:45:45 <ndm> quicksilver: yes, although i don't guarantee how stable that is currently
06:45:59 <ndm> quicksilver: i'm going to add a quickcheck property that asserts its correct shortly
06:46:02 * quicksilver nods
06:46:09 <igli> heh looks handy quicksilver might save me having to mess with xmlGawk; thanks!
06:46:15 <quicksilver> I woudl find that helpful for batch-transformation of HTML-fragments
06:46:24 <quicksilver> like renaming a CSS class
06:46:25 <quicksilver> that kind of thing
06:46:36 <quicksilver> (I currently use global-replace in an editor, but that's a bit fragile)
06:46:55 <ndm> its perfect for that
06:47:20 <ndm> you may loose spacing between attributes
06:47:26 <xho> ndm, you are the yhc guy, right?
06:47:34 <ndm> i.e. <foo                 x="neil"> may become <foo x="neil", but that should be about it
06:47:45 <quicksilver> ndm: spacing out in the CDATA chunks will be preserved though?
06:47:49 <ndm> xho: yes, one of them (also meet malcolmw, another Yhc guy)
06:47:53 <quicksilver> or whatever the right name for those i
06:48:01 <ndm> quicksilver: i'm not sure we support CDATA chunks yet, but we'd take a patch :)
06:48:13 <ndm> quicksilver: its something that does need adding, yes
06:48:20 <xho> ndm, what is the status of the javascript output?
06:48:24 <quicksilver> ndm: maybe I used the wrong word
06:48:28 <kfish> quicksilver, do you mean pcdata (tag text)?
06:48:33 <quicksilver> yes
06:48:36 <quicksilver> what kfish said :)
06:48:44 <quicksilver> just the 'texty' stuff between tags
06:48:46 <ndm> xho: works, but not entirely sure how well - I don't do the javascript back end, someone else does
06:49:00 <ndm> quicksilver: ah, it keeps that perfectly as you specified it, given the right options
06:49:07 <ndm> it may "unencode" entities
06:49:09 * quicksilver nod
06:49:14 <ndm> i.e. &amp; -> &
06:49:22 * malcolmw prefers to think of himself as a nhc98 guy rather than yhc
06:49:24 <ndm> and then on writing out, it should be able to do the reverse
06:49:34 <ndm> malcolmw: think of yourself as a nyhc guy
06:49:46 <quicksilver> "Pretty Fly, for an Nyhc Guy"
06:51:24 <SamB> malcolmw: you don't want to lose your purpose in life if we ever manage to kill nhc, do you?
06:51:25 <quicksilver> ndm: very nice. I will play with it.
06:51:26 * LeCamarade will just go back to Miranda if you guys keep this nonsense up. :o)
06:51:32 <LeCamarade> @quote tm
06:51:33 <lambdabot> sjanssen says: <font size="3">did I write something that had HTML in it?</font>
06:51:53 <xho> malcolmw: do you know about the status of the javascript output?
06:52:32 <kfish> quicksilver, http://blog.kfish.org/2007/06/review-tagsoup.html :-)
06:52:32 <lambdabot> Title: blog.kfish.org: Review: TagSoup
06:52:34 <malcolmw> xho: no - ask some of the yhc guys :-)
06:53:02 <xho> who is the best yhc guy?
06:53:30 <ndm> xho: Dimitry is the Yhc guy, ask on the yhc mailing list yhc -at- haskell.org
06:53:50 <xho> ok cool thanks
06:54:34 <baboa> more cabal questions: does Cabal keep the timestamps of sources and objects files? like make?
06:55:16 <quicksilver> kfish: neat. Thanks.
06:58:47 <fasta> How can I convince QuickCheck to only generate input lists of size > 10? Using the ==> operator results in QuickCheck always exhausting.
07:00:25 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/319
07:00:25 <the_dormant> Hirvinen, what's the best library for regex in haskell?
07:00:55 <ajudem_me> can anyone help me, please =)
07:01:59 <Saizan> ajudem_me: you have to align contents2 and the others with fileHandle
07:02:13 <Hirvinen> the_dormant: Please fix your irc client's nick completion settings or switch to a more sensible client.
07:02:54 <ajudem_me> Saizan, and what should I do?
07:03:14 <quicksilver> ajudem_me: he just told you
07:03:15 <the_dormant> sorry Hirvinen
07:03:19 <quicksilver> ajudem_me: you have to line them up :)
07:03:29 <ajudem_me> ohh... sorry... misread ;P
07:03:37 <quicksilver> ajudem_me: it looks likely that you are using tabs and have got confused by the tab-width in your editor
07:03:50 <quicksilver> ajudem_me: the advice is to not use real tabs in haskell layout code
07:03:58 <quicksilver> (if you really want to, make sure your tab width is 8)
07:04:15 <ajudem_me> yes... that's the problem.. I've changed the editor =\
07:04:39 <quicksilver> most editors have a 'spaces-instead-of-tabs' type setting
07:05:48 <Syzygy-> ?seen dons
07:05:48 <lambdabot> dons is in #haskell-books, #xmonad and #haskell. I last heard dons speak 8h 47m 36s ago.
07:05:56 <ajudem_me> yes.. I've changed it, tnks =)
07:08:26 <dolio> fasta: Maybe write a newtype with its own Arbitrary instance?
07:08:54 <fasta> dolio: It should also be possible to do so, without introducing a newtype.
07:09:08 <fasta> dolio: I know how to make a good Gen.
07:09:45 <fasta> dolio: All I need to know now it to actually use this Gen in some way.
07:10:14 <fasta> As always, the documentation only includes the most trivial examples...
07:11:16 <dolio> fasta: Ah. You're out of my depth, then. Sorry. :)
07:11:31 * dolio should get around to learning about QuickCheck in depth.
07:11:37 <Saizan> uhm, using forAll maybe?
07:11:47 <Saizan> ?docs Test.QuickCheck
07:11:48 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/QuickCheck/Test-QuickCheck.html
07:12:07 <quicksilver> the docs suggest that using 'forAll' is how you do it
07:12:17 <quicksilver> but they also seem to recommend the newtype approach
07:12:21 <fasta> quicksilver: right, I just found out that 5 seconds ago.
07:13:33 <fasta> Complaining is so easy, just look at the Emacs Is Not Windows-thread.
07:16:54 <Saizan> btw, if i have a tex-shell open and i C-c C-l in an haskell buffer it gets me to the tex one, instead of compiling
07:18:14 <ajudem_me> what does this: "Program error: Prelude.!!: index too large" means?
07:18:15 <fasta> Saizan: E-mail Monnier
07:18:30 <quicksilver> > [1,2,3] !! 8
07:18:32 <lambdabot>  Exception: Prelude.(!!): index too large
07:18:38 <quicksilver> ajudem_me: like that? :)
07:18:45 <quicksilver> ajudem_me: it means you went past the end of a lit
07:18:48 <quicksilver> list
07:19:18 <Saizan> fasta: who is he?
07:19:30 <ajudem_me> quicksilver... sorry.. I didn't get it...
07:19:32 <fasta> Saizan: the maintainer of Haskell mode
07:21:29 <matthew_-> it means that for some reason haskell's lists still aren't dependently typed with their length for no good reason...
07:22:20 <dolio> No good reason? :)
07:22:23 <ajudem_me> quicksilver... I think I found the problem, tnks ;)
07:23:42 <matthew_-> dolio: yeah. I would love to see the use of type classes to enforce indexes are statically proven to be less than the length of the list become standard
07:27:55 <dolio> Well, the static enforcement is nice. I'm just not sure the Haskell solution is nice enough to be used by default in the standard libraries.
07:28:05 <dolio> As opposed to a language designed for dependent types.
07:30:58 <xho> you guys see the "Physics Guy Rap"?
07:32:41 <dolio> If people get crazed about type errors like 'no instance Num [Char]', I can't imagine what they'd do with '... U (U (U B1 B0) B0) B1) B0 ...'
07:33:49 <matthew_-> dolio: right, I agree with that.
07:33:50 <fasta> How does QuickCheck automatically generate test values based on the number of arguments a functions has?
07:34:23 <sjanssen> fasta: typeclasses
07:34:31 <matthew_-> dolio: Jan Vitex recently said that he didn't like functional programming languages because you have to be too clever to do anything in them. This certainly wouldn't be easing that issue!
07:34:39 <sjanssen> instance Testable Bool
07:34:57 <sjanssen> instance (Arbitrary a, Testable b) => Testable (a -> b)
07:35:21 <fasta> sjanssen: ok, so, I basically have to use newtyping to use that mechanism
07:35:35 <sjanssen> fasta: maybe?
07:35:47 <sjanssen> do you want to restrict the values generated for a certain argument?
07:36:00 <fasta> sjanssen: I only want to create lists of size > 10 < 100
07:36:25 <sjanssen> yeah, you can use newtypes
07:36:41 <fasta> sjanssen: I first used the ==> mechanism to filter out everything < 10, but well, that didn't work. :)
07:36:46 <matthew_-> mmm. there hasn't been a haskell weekly news for *ages*
07:37:01 <quicksilver> matthew_-: dons pretty busy with other tuff, I believe
07:37:04 <sjanssen> fasta: you can also hand quickcheck the generator you'd like to use
07:37:18 <fasta> sjanssen: how?
07:37:42 <sjanssen> fasta: read the docs
07:37:53 <fasta> sjanssen: you mean forAll?
07:38:16 <sjanssen> fasta: yeah, that one
07:38:37 <matthew_-> quicksilver: how dare he?! ;-)
07:38:38 <fasta> sjanssen: ah, ok, that also works with a Testable, so I also get the auto param filling.
07:38:41 <fasta> sjanssen: thanks
07:40:31 <quicksilver> dolio: in principle, you don't need dependent types in your langauge, at all
07:40:37 <quicksilver> dolio: a 'tool' like ndm's catch
07:40:47 <quicksilver> dolio: could construct, and check, and then remove the annotations tatically
07:40:56 <quicksilver> dolio: and tell you if you have statically-detectable problems
07:41:30 <dolio> quicksilver: That sounds less sexy, though. :)
07:41:44 <ndm> my tool is sexy!
07:41:52 <ndm> or at least, slightly sexy
07:41:58 <quicksilver> I think it's *more* secy
07:41:59 <matthew_-> careful which tool we're talking about...
07:42:00 <dolio> Heh.
07:42:12 <quicksilver> it's more sexy if you can demonstrate that you don't need dependent types
07:42:23 <quicksilver> in the same way that Catch demonstrates that you don't need substructural typing
07:43:00 <ndm> and also that you don't need annotations - thats what i like most about Catch
07:43:23 <fasta> ndm: is Catch sound and complete?
07:43:40 <ndm> fasta: sound - i hope so, complete - no, its the halting problem
07:43:49 <fasta> ndm: right, that's what I though.
07:43:52 <fasta> ndm: thought
07:43:56 <ndm> well complete - it can solve everything, but sometimes approximates
07:44:10 <ndm> fasta: do you think dependent types are complete?
07:44:28 <DRMacIver> quicksilver: Isn't it to a certain extent true that what catch is basically doing is layering a simple type inferred dependent type system on top of Haskell's though? :)
07:44:35 <quicksilver> DRMacIver: yes
07:44:51 <ndm> DRMacIver: to a certain extent, but its not quite a type system - since a single function can have many types
07:44:56 <quicksilver> DRMacIver: that's exactly what it's doing. Although I wouldn't call it 'simple' personally
07:45:03 <fasta> ndm: not really my area of expertise, but IIRC, it is Turing Complete?
07:45:35 <DRMacIver> quicksilver: I guess I meant 'simpler than a fullblown dependently typed language like epigram'.
07:45:37 <ndm> fasta: some are, some aren't - some allow unbounded recursion, some don't - people haven't got the answers for dependent types yet
07:45:41 <DRMacIver> Not simple in the sense of easy. :)
07:46:02 <ndm> DRMacIver: restricted is better than simple - its not simple, but it is less powerful than Epigram types
07:46:10 <DRMacIver> Yes, true.
07:46:26 <xho> what is more powerful than epigram?
07:46:32 <quicksilver> god
07:46:39 <ndm> i still need to figure out if Catch can be modelled as a type system, but i don't know enough about Haskell
07:46:49 <ndm> xho: Haskell, epigram doesn't let you write non-terminating programs
07:46:51 <xho> what kind of type system does god have?
07:47:06 <ndm> god has extensible sorts
07:47:40 <quicksilver> ndm: did you mean '...can be modelled as a type class system..." ?
07:47:50 <xho> is there such a thing as a valid program that is non-terminating?
07:48:02 <ndm> quicksilver: i'm not sure what i mean
07:48:07 <quicksilver> xho: yes; an operating system
07:48:16 <dolio> Doesn't Epigram (currently) have a method of doing general recursion?
07:48:16 <ndm> xho: no, but there are infinitely many terminating programs which can't be proven terminating
07:48:29 <dolio> I thought they used it in their quicksort example in the intro paper.
07:48:39 <quicksilver> ndm: I'm quite sure it's a type system
07:48:52 <fasta> ndm: you mean by any fixed system of rules, right?
07:48:56 <dolio> Before they explained how to sort using structural recursion.
07:48:57 <ibid> quicksilver: even with an OS you need liveness properties, which are sort of related to termination :)
07:48:57 <quicksilver> ndm: I don't know enough type theory to know how to classsify type systems
07:49:06 <quicksilver> ibid: yes, related. but they aren't terminating.
07:49:07 <ndm> quicksilver: i really need a few hours with a type system expert and a whiteboard
07:49:11 <ibid> quicksilver: true
07:49:33 <ndm> fasta: yes, i think thats what the halting problem says
07:49:39 <quicksilver> ndm: but I'm sure it is one; a type system is really just a bunch of structural rules after all
07:49:54 <ndm> quicksilver: is there anything which isn't a type system?
07:50:03 <quicksilver> ndm: of course it is interesting to ask if it relates to existing well-studied rewrite systems, etc
07:50:13 <Codex_> ndm: just write down the typing rules... :)
07:50:40 <ndm> Codex_: i'm not a type system hacker, so i don't know much about the area, or how to write typing rules even
07:50:42 <quicksilver> ndm: well, it might be a question of degree, but operational semantics isn't a type system
07:51:00 <Codex_> ndm: start from modus ponens. And continue from that.
07:51:06 <fasta> ndm: well, "algorithm" to be more precise. Computations that go beyond a "mere"  algorithm might do it. Some believe that the human race as a whole is more powerful than a Turing-machine, but we had that discussion before.
07:51:32 <quicksilver> ndm: one convenient place to draw the line is that operational semantics is undecidable (halting problem) whereas type systems are decidable
07:51:35 <ndm> i'm half way through TAPL, once i get the whole way through hopefully i'll know type systems enough for what i need with Catch
07:51:53 <quicksilver> ndm: or, you might say that type systems are 'static' semantics and not 'dynamic'
07:52:12 <ndm> i guess that makes Catch a static semantics which terminates, so is a type system
07:52:23 <quicksilver> that is my instinctive categorsation, yes
07:52:39 <quicksilver> but I don't claim to have backed it up by careful thought :)
07:52:57 <Codex_> ndm: you might want your type checking to terminate though.
07:53:22 <ndm> Codex_: catch terminates
07:54:01 <Codex_> ndm: they use the "types get smaller when reducing" trick to get termination?
07:54:21 <ndm> Codex_: no idea, i have a proof of termination, which is based on finiteness and reduction
07:56:47 <xho> i've been trying to get past the introduction chapter of TAPL for about 7 months :/
07:57:35 <Codex_> what's tapl? (any good book?)
07:57:57 <Saizan> it's a good book, Types And Programming Languages
07:58:01 <xs> http://www.cis.upenn.edu/~bcpierce/tapl/
07:58:03 <lambdabot> Title: Types and Programming Languages
07:58:21 <Syzygy-> Are there any suggestions on how to cite the GHC compiler?
07:58:34 <xho> what we need is a book that teaches how to get through TAPL
07:58:35 <Syzygy-> In academic texts, that is.
08:02:21 <quicksilver> Syzygy-: I've definitely een it cited
08:02:28 <quicksilver> Syzygy-: there are PJ refs that people use
08:03:28 <Syzygy-> I found a "electronic bookshelf" with bibtex's for both GHC and Haskell98.
08:03:55 <Syzygy-> By the way - anyone here that I can talk to about publishing results/papers for the computer science/functional programming-crowd?
08:04:13 <edward1> as in  how to?
08:04:15 <Syzygy-> I have an algebra-paper (sort of) in preparation that with not much effort turns into a Haskell/FP/provable programs paper...
08:04:22 <matthew_-> Syzygy-: I use @misc
08:04:38 <Syzygy-> edward1: As in how to, where to, what to think about et.c. I know the ropes, kinda, in mathematics, but not in CS.
08:05:25 <Syzygy-> Also connected - which conference might I want to go to with a haskell implementation of a slightly obscure algorithm from homotopy theory...
08:05:48 <edwardk> a lot of the quiet lurker types here have a lot published. i'm probably not the best person to ask, as i always get distracted by a shiny new topic before writing up the last one.
08:06:30 <Syzygy-> Hehe
08:07:05 <edwardk> on the other hand it means i have a lot of idea back-stock, so when i ever run out of things to distract me i can have a really really prolific year ;)
08:07:54 <Syzygy-> edwardk: Nice.
08:08:07 <Syzygy-> For me, I'm slowly getting scared by the tempo I suddenly attained at producing output.
08:08:10 <quicksilver> Syzygy-: make two papers out of it
08:08:24 <edwardk> well not so nice, as by then everything will have been written up by someone else and i'll just get a ton of rejection letters. =)
08:08:27 <Syzygy-> quicksilver: I will make two papers out of it: one for mathematicians and one for the FP/CS crowd.
08:08:28 <quicksilver> Syzygy-: write one paper for the homotopists, de-emphasising the haskell detail but just explaining the advantages to them
08:08:50 <Syzygy-> quicksilver: And as I said, I know the ropes for mathematicians - and I have NO IDEA where to look for good venues for CS publishing.
08:09:01 <quicksilver> Syzygy-: write another for the haskellers, de-emphasiing the homotopy details and just explaining 'this is an important and cool problem', and explaining how haskell helped
08:09:13 <quicksilver> yeah, that's a good question which I can't answer :(
08:09:18 <edwardk> ICFP, POPL, not sure for something with such a mathematical emphasis
08:09:31 <Syzygy-> quicksilver: There are homotopists asking me to show them the implementation, so my current draft is a walkthrough of my source code, explaining why each statement is relevant for the mathematical definitions at hand.
08:09:33 <edwardk> can you turn it into something useful in a compiler? =)
08:09:50 <edwardk> may i ask what it implements?
08:10:02 <Syzygy-> quicksilver: And I wanted to write one for the CS crowd along the lines of "This is something that's cool in homotopy theory, and here are the issues I needed to control to be able to prove correctness of the code"
08:10:08 <Syzygy-> edwardk: The Saneblidze-Umble diagonal.
08:10:09 * quicksilver nods
08:10:23 <Syzygy-> For your reading pleasure: http://mpc723.mati.uni-jena.de/~mik/SaneblidzeUmble.pdf
08:10:26 <Syzygy-> The mathematician paper.
08:11:14 <edwardk> k. a little outside of my corner of mathematics, but adding to the reading list
08:11:25 <Syzygy-> Hehe
08:11:42 <ndm> Syzygy-: things like IFL, TFP are easier to get into, and still FP based
08:11:50 <Syzygy-> ndm: Ok...
08:12:01 <edwardk> though i have a former coworker who will really enjoy it i think, she was trying to find a good use for haskell and had to use a bunch of permutahedrons for things.
08:12:34 <ndm> Syzygy-: they are post-reviewed, so accept everything then you compete for publication after - can be easier to start with if you are new to FP
08:12:53 <Syzygy-> ndm: Ah.
08:13:06 <Syzygy-> edwardk: Neat - can you dig up details?
08:13:24 <edwardk> Syzygy-: on what she was using them for?
08:13:24 <Syzygy-> Hmph. The ICFP 2007 is nearby, but I will be gone to Australia when it comes here.... Blech.
08:13:29 <Syzygy-> edwardk: Yeah.
08:13:44 <Syzygy-> POPL seems to hav ewrong scope...
08:13:59 <Syzygy-> Though PADL might be closer
08:14:06 <edwardk> something to do with voting, she was working as a mathematician at university of michigan helping out a psychology department at the time.
08:14:15 <Syzygy-> Neat.
08:14:24 <Syzygy-> IFL gave me a sports website... Hmmmm.
08:14:32 <edwardk> sorted candidate preferences or something
08:15:21 <LeCamarade> Who did this YouTube vidoe of a guy making music on the Haskell Prelude? I know the culprit is in here.
08:15:47 <Syzygy-> LeCamarade: That's yaxu
08:15:55 <LeCamarade> yaxu++
08:15:57 <LeCamarade> yaxu++
08:15:58 <LeCamarade> yaxu++
08:16:00 <LeCamarade> Woo!
08:16:01 <Syzygy-> HAHAHAHAHA
08:16:05 <Syzygy-> Yeah, he's worth it.
08:16:13 * LeCamarade is trying to stop dancing
08:16:14 * Syzygy- grumbles.
08:16:29 <Syzygy-> Is it worth it to submit a paper to .. say .. IFL without attending the conference?
08:17:06 <oerjan> fizzie was there too (but not Bob, as far as i can tell)
08:17:12 <oerjan> argh
08:17:13 <edwardk> kinda ruins the whole presentation aspect ;)
08:17:27 <Syzygy-> edwardk: Yeah.
08:17:27 <oerjan> no idea why my window had changed
08:17:28 <Syzygy-> Bugger.
08:17:31 <edwardk> if you want to do that submit it to a journal
08:17:36 <Syzygy-> edwardk: I'll be in Sydney then. :(
08:19:03 <Syzygy-> TFP however looks pretty darn interesting, given that what I'm writing would end up being a Project article within validation and verification of functional programs. And early 2008 would be the timing where I can really attend things too.
08:19:10 <Syzygy-> So, assuming it's a yearly affair...
08:20:11 <edwardk> i need to get back into an academic mindset and start writing things up, slapping greek symbols on what i've been doing adding the occasional progress and preservation proof and clean out the project rubbish bin ;)
08:20:19 <ndm> Syzygy-: they don't like you submitting then not going
08:20:19 <Syzygy-> Hehe
08:20:24 <Syzygy-> ndm: Check.
08:20:55 <ndm> Syzygy-: i went to TFP in 2005, lots of type stuff, made my head hurt - although those things tend to have different focus every year, depending on what people are doing
08:21:08 <Syzygy-> Right.
08:21:19 <Syzygy-> It did sound like the conference that wants to be Trendier Than Thou.
08:21:51 <Syzygy-> What is the state of journal publishing in CS btw? Are there journals where this might fit? Is it worthwhile publishing in CS journals, or do people simply not care?
08:22:07 <matthew_-> there's the JFL
08:22:11 <matthew_-> err, JFP, rather
08:22:26 <Syzygy-> Journal of Family Practice? ;)
08:22:27 <matthew_-> and I thought journal special editions are occasionally read...
08:22:40 <matthew_-> journal of functional prodding
08:22:42 <edwardk> journal of functional programming
08:22:49 <Syzygy-> BWAHAHAHAHAHA!
08:23:07 <Syzygy-> This would then end up falling under "Applications", which is labeled as "the use of functional languages in solving real-world problems, either in isolation or as a basis for embedded systems, reports of practical experience, programming techniques, prototyping, and uses of functional languages in education"
08:23:24 <Syzygy-> This would be the first time I see my research labeled as a real-world problem, causing it to be applied something-or-other....
08:24:10 <shapr> Syzygy-: You could try a slightly-past-last-minute submission to Commercial Users of Functional Programming?
08:24:15 <shapr> Or maybe apply to the Haskell Workshop?
08:24:33 <edwardk> shapr: still looking for stuff for the CUFP thing?
08:24:53 <shapr> Is there something like replicate for sh? I want something like replicate 3 echo "foo"
08:25:04 <shapr> edwardk: Submission deadline is past, but nifty stuff might get in anyway.
08:25:10 <edwardk> ah
08:25:10 <SamB> heh. this guy fixed a problem in some python code without noticing that python used significant whitespace: http://www.oreillynet.com/onlamp/blog/2003/03/the_knuth_indentation_quote_re.html
08:25:13 <lambdabot> Title: The Knuth Indentation Quote rediscovered - O&#039;Reilly ONLamp Blog, http://tinyurl.com/22swms
08:25:14 <LeCamarade> @where+ music1 http://www.youtube.com/watch?v=eLS6GHXWMpA
08:25:14 <lambdabot> Done.
08:25:20 <LeCamarade> That's Haskell music.
08:25:58 <Syzygy-> shapr: Do I really qualify as a Commercial Users? O.o
08:26:15 <Syzygy-> Haskell workshop might be an idea, but isn't that also annoyingly timed?
08:26:41 <Syzygy-> shapr: One major constraint for me is that I'm in Sydney early september - late october.
08:26:41 <LeCamarade> @where+ music2 http://www.youtube.com/watch?v=xaoLbKWMwoU
08:26:42 <lambdabot> Done.
08:26:45 <LeCamarade> And the last one.
08:26:51 <Syzygy-> So all ICFP-connected things are out of bounds for me.
08:26:54 <shapr> Syzygy-: I don't remember.
08:27:01 <Syzygy-> Unless the conference pays for a backtrip, and that's not likely.
08:27:03 <Syzygy-> :-/
08:32:19 <fasta> How can I easily check whether the generator I have defined actually generated elements I want it to generate?
08:32:37 <fasta> I would expect something of type Gen a -> [a]
08:33:39 <Saizan> ?where dons
08:33:39 <lambdabot> http://www.cse.unsw.edu.au/~dons
08:36:39 <quicksilver> fasta: indeed, and it appears to have type generate?
08:36:51 <quicksilver> fasta: erm 'name' generate
08:37:41 <shapr> Does GHC RTS use poll or select for network serving?
08:38:26 <quicksilver> the default forkIO RTS uses select, I believe
08:38:47 <fasta> quicksilver: The first parameter of generate is of type Int, yet I have no idea what it's for..
08:39:02 <quicksilver> fasta: read the source, it's quite simple
08:39:25 <fasta> quicksilver: ok, but it's not documented.
08:39:39 <quicksilver> I didn't say it was
08:39:47 <quicksilver> quickcheck is not very well documented
08:39:52 <quicksilver> but the source is easy to understand
08:42:38 <fasta> quicksilver: yes, it is.
08:46:40 <Lemmih> shapr: select.
08:48:32 <johnnowak> Given that (+) :: (Num a) => a -> a -> a, is it possible to use (+) for, say, string concatenation as well? Not that I'd ever want to, and yes I realize ++... just as a hypothetical.
08:49:05 <sjanssen> johnnowak: sure, if you wrote such an instance
08:49:47 <quicksilver> johnnowak: yes, it would look omething like instance Num string where (+) = (++)
08:50:05 <quicksilver> johnnowak: although beware haskell98 doesn't like you make a type synonym (like String) a member of a class
08:50:10 <sjanssen> note that isn't valid Haskell '98
08:50:10 <edwardk> johnnowak: sure, but you'd need to change the requirements for (+) down to just the properties of a monoid. which i would much rather have.
08:50:22 <quicksilver> ghc will do it with appropriate flag though
08:50:31 <edwardk> or even down to an arbitrary magma, but then that gets a little silly
08:52:10 <johnnowak> hm. I don't understand why i'd so something like "instance Num string where (+) = (++)". why would Num be involved?
08:52:29 <edwardk> johnnowak: because haskell made the mistake of bundling (+) into Num.
08:52:31 <sjanssen> johnnowak: because (+) is a function in the Num type class
08:52:31 <edwardk> =)
08:52:43 <fasta> getStdGen and newStdGen <- what's the difference? I suppose calling get two times gets you the same StdGen.
08:52:56 <edwardk> primarily because they didn't want to make people define 30 different type classes to build a numeric class
08:53:15 <fasta> Never mind, it is documented.
08:53:18 <johnnowak> hm. so a name cannot be used in more than one type class?
08:53:43 <sjanssen> johnnowak: correct
08:53:51 <edwardk> and Num a => [a] -> a ... is a lot easier to say than (Additive a, Negative a, Subtractive a) => [a] -> a
08:53:56 <sjanssen> (modulo the usual module system caveats, like qualified imports)
08:53:58 <edwardk> john: unfortunately not
08:54:18 <johnnowak> Ah. Alright then, that's what I was wondering. Thanks.
08:56:38 <johnnowak> how can I introduce a new data type in the repl?
08:56:51 <quicksilver> unforatunately you have to put it in a file and load it
08:56:59 <johnnowak> hm.
08:57:08 <quicksilver> this is slightly annoying although it's not a huge problem in practice
08:57:16 <fasta> Is there some collection of standard QuickCheck Arbitrary instances somewhere?
08:57:36 <fasta> E.g. a generator for positive numbers is pretty common, etc.
08:57:38 <johnnowak> quicksilver: It's more that I find it somehow personally offensive than actually a problem. :)
08:58:20 <quicksilver> johnnowak: the ghci-repl is basically a do block in the IO monad
08:58:29 <quicksilver> this is not really very satisfactory
08:58:52 <johnnowak> aye
08:59:59 <johnnowak> is that specific to ghci, or is it in effect a requirement of the language?
09:00:53 <fasta> Hmm, QuickCheck isn't that hard after you write some stuff.
09:02:05 <quicksilver> johnnowak: it's the approach they took
09:02:13 <quicksilver> johnnowak: it's not the only approach you can imagine
09:02:22 <quicksilver> data types at the REPL do have their issues, though
09:02:29 <quicksilver> you end up with versioned types
09:02:34 <quicksilver> and incompatible data or functions
09:02:39 <quicksilver> this happens in the ocaml repl
09:04:57 <johnnowak> yes, makes sense
09:10:40 <shapr> fasta: yay QuickCheck!
09:13:26 <fasta> shapr: I do replicateM 1000 (quickCheck test_of_interest) to do some thorough testing. It seems to work nicely. :) It's not a complete solution, though. "Complete
09:13:39 <fasta> " like the GHC nightly testing infrastructure.
09:15:45 <chrismbrown> ?src (>>=)
09:15:45 <lambdabot> Source not found. I feel much better now.
09:15:59 <chrismbrown> ?pl (>>=)
09:15:59 <lambdabot> (>>=)
09:17:45 <quicksilver> chrismbrown: you can't get source for methods without naming the instance you want
09:17:54 <chrismbrown> quicksilver: ah
09:18:13 <quicksilver> @src [] (>>=)
09:18:13 <lambdabot> m >>= k     = foldr ((++) . k) [] m
09:18:14 <sjanssen> @src (>>)
09:18:14 <lambdabot> m >> k      = m >>= \_ -> k
09:18:27 <quicksilver> >> is not a method, of course :)
09:18:32 <sjanssen> it is
09:18:36 <quicksilver> oh
09:18:38 <emu> it has a default
09:18:42 <quicksilver> ok, @src will show you defaults then :)
09:18:58 <chrismbrown> @src Monad (>>=)
09:18:58 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
09:19:04 <sjanssen> @src negate
09:19:04 <lambdabot> negate x = 0 - x
09:19:08 <emu> when did lambdabot become polite
09:19:22 <quicksilver> are there interesting monads for which a specialised >> is really worth it?
09:19:50 <sjanssen> quicksilver: it might lead to better code with eg. the IO monad
09:19:56 <chrismbrown> quicksilver: IO?
09:20:04 <chrismbrown> @src IO (>>=)
09:20:04 <lambdabot> m >>= k     = bindIO m k
09:20:06 <quicksilver> sjanssen: you could use a RULE for that, though, I guess...
09:20:15 <chrismbrown> @src bindIO
09:20:15 <lambdabot> bindIO (IO m) k = IO ( \ s ->
09:20:15 <lambdabot>   case m s of (# new_s, a #) -> unIO (k a) new_s)
09:20:53 <sjanssen> ooh unIO sounds like a nice function
09:21:34 <sjanssen> @src unIO
09:21:34 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
09:21:38 <fasta> Is there newtype deriving for newtype Foo = Foo [a] to get fmap?
09:21:38 <quicksilver> well note the implicit unIO in the use of 'm', too :)
09:21:40 <emu> @src STM (>>=)
09:21:40 <lambdabot> Source not found. Do you think like you type?
09:21:47 <sjanssen> fasta: yes
09:21:56 <emu> lambdabot: very much so
09:21:58 <sjanssen> with generalized newtype deriving
09:21:58 <quicksilver> fasta: deriving Functor
09:21:59 <fasta> I tried deriving Functor
09:22:01 <Serge> Rev6k: lol.
09:22:33 <sjanssen> fasta: you need generalized newtype deriving (-fglasgow-exts or some such)
09:23:08 <johnnowak> perhaps this is a silly question... but how can I define something like "fact 0 = 1; fact n = n * fact(n-1)" in ghci?
09:23:14 <fasta> sjanssen: I see the problem. The type I provided was specialized for one type: PositiveNumber
09:23:21 <fasta> sjanssen: otherwise it will probably work
09:23:34 <quicksilver> sjanssen: it' annoying that the "extentsions" ection of the ghc manual doesn't tell you which flags you need for each extension :)
09:23:36 <Vulpyne> johnnowak: Might need to use let.
09:23:46 <quicksilver> johnnowak: by using the non-layout form
09:23:51 <johnnowak> Vulpyne: i normally use let, but it seems that let shadows the existing binding
09:24:02 <johnnowak> quicksilver: hm. alright.
09:24:03 <sjanssen> quicksilver: many extensions don't have their own flags :(
09:24:04 <quicksilver> let {fact 0 = 1;fact n = n * fact (n-1)}
09:24:17 <quicksilver> sjanssen: it could then say "turned on by -fglaggow-exts"
09:24:22 <johnnowak> ah! thanks.
09:24:23 <quicksilver> sjanssen: it could at least say something :)
09:25:00 <quicksilver> johnnowak: in ordinary layout code, the ; is understood by the newline
09:25:07 <quicksilver> johnnowak: but you cna't type multiple lines at once into ghci
09:25:14 <quicksilver> johnnowak: so you need the explicit {} and ;
09:25:20 <johnnowak> i see, makes sense
09:25:22 <quicksilver> actually I don't think you need the {} in that example
09:25:23 <shapr> fasta: SmallCheck lets you do QuickCheck-style testing, but with an ordered generator, so you could do proof-by-exhaustion.
09:25:25 <quicksilver> but it's a good idea
09:25:47 <johnnowak> ah -- it won't even let me enter successive lines if i leave an open {
09:26:03 <quicksilver> no, it doesn't do partial parse detection
09:26:21 <fasta> shapr: is SmallCheck well supported in that it is easily installable, documented etc?
09:26:23 <sjanssen> johnnowak: typing all your definitions at the ghci prompt isn't the suggested workflow
09:26:26 <quicksilver> the haskell rules say that all } are implicitly closed at eof
09:26:55 <sjanssen> quicksilver: seriously?  That's a new trick to me
09:26:56 <quicksilver> and the way ghci works, end of line is effectively eof :)
09:27:16 <oerjan> quicksilver: surely only the ones that were started by implicit {'s?
09:27:16 <quicksilver> sjanssen: the haskell parser has this nasty backtracking rule "in case of grammatical error, close } and try again"
09:27:32 <johnnowak> sjanssen: fair enough. i've been spending most of my time lately in Io and Self, so I have to switch gears is all.
09:28:03 <quicksilver> sjanssen: "A close brace is also inserted whenever the syntactic category containing the layout list ends; that is, if an illegal lexeme is encountered at a point where a close brace would be legal, a close brace is inserted."
09:28:18 <quicksilver> sjanssen: in this context 'EOF' is the illegal lexeme
09:28:24 <quicksilver> sjanssen: and the other } get inserted there
09:28:26 <quicksilver> AIUI
09:28:32 <sjanssen> ghc and hugs don't seem to do this
09:28:44 <quicksilver> then, I understood something wrong :)
09:28:46 <monochrom> Nasty!
09:29:05 <quicksilver> maybe they don't treat EOF like a lexeme....
09:29:05 <fasta> @where SmallCheck
09:29:06 <lambdabot> http://www.cs.york.ac.uk/fp/smallcheck0.2.tar
09:29:53 <oerjan> "The layout rule matches only those open braces that it has inserted; an explicit open brace must be matched by an explicit close brace."
09:30:11 <quicksilver> oerjan: ah, there you go
09:30:15 <quicksilver> sorry for the confusion :)
09:33:19 <retybok> Newbie question: how do I write a file in haskell?
09:33:22 <ptolomy> I don't recall who I was talking to about this a while back ( sjanssen? ) but I just updated the haskell code I wrote for http://tempe.st/2007/05/erlang-ruby-and-php-battle-it-out/ to use double2Int, and now it is Faster Than C on my machine. Way belated upate.
09:33:32 <lambdabot> Title: Erlang, Ruby and PHP battle it out! -- A Tempest of Thoughts
09:34:34 <quicksilver> retybok: openFile "name" WriteMode, normally
09:35:07 <hpaste>  ptolomy pasted "Pretty fast." at http://hpaste.org/320
09:35:40 <oerjan> @type writeFile
09:35:43 <lambdabot> FilePath -> String -> IO ()
09:36:17 <oerjan> retybok: writeFile may be used if you want to write all the file at once.
09:38:48 <oerjan> http://www.haskell.org/onlinereport/io.html
09:38:49 <lambdabot> Title: The Haskell 98 Library Report: Input/Output
09:38:57 <fasta> shapr: Do you use both SmallCheck and QuickCheck?
09:39:11 <fasta> shapr: Or can SmallCheck do everything QuickCheck can?
09:39:32 <quicksilver> smallcheck can only be exhaustive, I think
09:39:52 <quicksilver> so if it's more useful to have a statistical selection of 'fairly large' data
09:39:56 <quicksilver> rather than 'all' small data
09:40:03 <quicksilver> then quickcheck may be a better fit
09:40:43 <fasta> I turn a list into a tree and then check that the list and the tree contain the elements in the same order, so it's not exhaustive I guess.
10:00:05 * lispy notes that the # of editor threads on cafe is absured this week
10:00:26 <lispy> and i have this feeling like, adding another editor to the mix is not the solution
10:01:48 <dolio> You mean, the totally new editor that will be different from all other editors before it?
10:01:56 <ndm> fasta: you need both, smallkcheck and quickcheck work well together - neither does everything
10:02:09 * ndm wants supercheck, which does do both
10:02:30 <lispy> dolio: exactly
10:02:31 <ndm> me and Colin did try writing such a thing, but you can't do it using only the interface
10:02:38 <dolio> :)
10:03:03 * lispy thinks ndm has a good PhD position
10:03:04 <fasta> Why is coseries defined as it is?
10:03:13 <lispy> ndm: sounds like you work on fun projects
10:04:48 <Saizan> ?hoogle IO [String]
10:04:48 <lambdabot> System.getArgs :: IO [String]
10:04:49 <lambdabot> System.Console.Readline.filenameCompletionFunction :: String -> IO [String]
10:04:49 <lambdabot> System.Console.Readline.usernameCompletionFunction :: String -> IO [String]
10:04:51 <ndm> lispy: it is fun, that kind of thing technically isn't my phd though
10:04:57 <ndm> fasta: how else would you define it?
10:05:40 <fasta> ndm: I don't understand the intention, really.
10:06:00 <ndm> fasta: so you can smallcheck functions
10:06:09 <fasta> ndm: coseries takes a number and then generates a number of functions.
10:06:21 <ndm> fasta: if you don't want to check functions, just leave it out - its like coarbitrary for QuickCheck
10:06:34 <fasta> ndm: I'd like to understand :)
10:07:38 <ndm> fasta: how else would you smallcheck a function? you need to generate random functions, which is what coseries does
10:07:55 <fasta> ndm: it doesn't generate random functions
10:08:26 <ndm> fasta: no, it generates a series of functions
10:08:40 <ndm> fasta: where the depth bound is the amount of information about hte arguments that the function can examine
10:08:42 <fasta> ndm: Take the instance for Int.
10:08:58 <ndm> no, ignore that one - Int is always a bit funny in SmallCheck
10:10:36 <fasta> ndm: ok, Integer then?
10:11:04 <ndm> fasta: ignore that one too
10:11:11 <ndm> fasta: look at algebraic data types
10:14:50 <lispy> is there a way to install something from cabal just for my user instead of globally?
10:16:06 <lispy> oh wait, the package i want is in debian, n/m
10:16:13 <fasta> ndm: ok, for Bool, how does series ever return a tuple? The type of series is s.t. it returns lists.
10:16:29 <ndm> fasta: it returns [True,False]
10:16:31 <_case> if someone would ask you, what's the most generic type of the following expression: "tail.head", what would you say?
10:16:34 <ndm> i.e. all possible values
10:16:41 <ndm> @type tail . head
10:16:43 <lambdabot> forall a. [[a]] -> [a]
10:16:57 <_case> ndm, hmm ok :)
10:17:06 <fasta> ndm: ? In the source code it clearly says that it returns a tuple, it pattern matches against one.
10:17:23 <fasta> ndm: I know series has a type that returns a list, so, it doesn't make sense.
10:17:41 <fasta>  coseries d = [ \x -> if x then b1 else b2
10:17:41 <fasta>                | (b1,b2) <- series d ]
10:17:43 <ndm> fasta: oh, for coseries, i'm not entirely sure
10:18:44 <fasta> Something seems very wrong there.
10:18:58 <mauke> > let coseries d = [ \x -> if x then b1 else b2 | (b1,b2) <- series d ]; series _ = [False, True] in coseries 42
10:18:58 <lambdabot>  Couldn't match expected type `Bool' against inferred type `(a, b)'
10:18:59 <_case> ndm, i'm not quite sure if that is what they're asking (our teachers), but i couldn't think of anything else than your answer too
10:19:10 <tibbe> can I do something like: data (Show a) => Foo a = Foo a ?
10:19:17 <fasta> series :: (Serial a) => Int -> [a
10:19:20 <fasta> ]
10:19:34 <mauke> tibbe: you probably don't want to do that
10:19:48 <lispy> anyone installed shim lately?  I have ghc6.6, but cabal does not like shim's cabal
10:19:54 <fasta> mauke: I am looking at the source code of SmallCheck 0.2
10:20:10 <tibbe> mauke: I want the contructor to carry something that can be made into a string
10:20:13 <mauke> fasta: I'm just trying random things. is there an instance (Serial a, Serial b) => Serial (a,b)?
10:20:26 <fasta> Oh,  I see the problem partially.
10:20:34 <lispy> dagit@darcy:~/shim$ ./Setup.lhs configure --prefix=$HOME
10:20:34 <lispy> created shim.cabal from shim.cabal.in
10:20:34 <lispy> Setup.lhs: shim.cabal:11: Invalid syntax (no colon after field name)
10:20:34 <fasta> mauke: yes, that must be it
10:21:25 <edwardk> Gr1ff0n!
10:21:31 <edwardk> lol
10:21:37 <edwardk> nm
10:21:38 <Saizan> tibbe: that would define Foo :: Show a -> a -> Foo a, but won't provide you a Show context when using Foo a
10:22:05 <tibbe> Saizan: so what do I want to do then?
10:22:22 <tibbe> Saizan: I want to pack the context with the contructor
10:22:39 <Saizan> place the context on the functions that use Foo a
10:22:55 <lispy> ?seen beschmi
10:22:56 <lambdabot> I haven't seen beschmi.
10:23:05 <Saizan> or use GADT
10:23:11 <tibbe> Saizan: hmm, ok, but that would be some duplication since it only makes sense for Foo's with Show context
10:25:44 <LoganCapaldo> data Foo a where Foo :: (Show a) => a -> Foo a would be the GADT way??
10:25:49 <Saizan> yup
10:27:16 <LoganCapaldo> seems a bit clearer than data (Show a) => Foo a = Foo a.
10:27:53 <LoganCapaldo> Actually GADTs in general seem clearer :)
10:27:54 <Saizan> and it works, most notably :)
10:30:36 <fasta> Ok, the definition for Bool makes sense. :)
10:33:39 <Saizan> ?type (liftM . liftM) read readFile -- should i feel evil for using this?
10:33:47 <lambdabot> forall r. (Read r) => FilePath -> IO r
10:34:23 <LoganCapaldo> why would you feel evil?
10:34:42 <mauke> yes
10:34:44 <Saizan> the liftM . liftM
10:35:21 <mauke> ?type liftM liftM liftM read readFile
10:35:22 <dukedave> ?type liftM
10:35:23 <lambdabot> forall r. (Read r) => FilePath -> IO r
10:35:25 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:35:39 <LoganCapaldo> mauke++
10:35:40 <Saizan> mauke: fantastic! :D
10:35:41 <edwardk> mauke: haha
10:35:50 <emu> :t read`liftM`readFile
10:35:52 <lambdabot>     Couldn't match expected type `String'
10:35:52 <lambdabot>            against inferred type `IO String'
10:36:13 <mauke> it's just liftM read . readFile
10:36:17 <emu> listM, fmap and (.) are pretty much the same
10:36:51 <dukedave> Mm, I'm going to pretend I understand what's going on here :)
10:37:01 <edwardk> throw map into the mix and you have a nice simplification of the prelude ;)
10:37:04 <mauke> dukedave: you can replace (.) by liftM
10:37:07 <emu> right, i think cale champions that cause
10:37:16 <emu> :t (.)
10:37:18 <edwardk> yeah
10:37:18 <emu> :t liftM
10:37:19 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
10:37:21 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
10:37:39 <edwardk> when liftM is applied to the anonymous reader monad (->)e you get (.)
10:37:46 <emu> yea
10:37:50 <mauke> so liftM read . readFile ==> liftM (liftM read) readFile ==> (liftM . liftM) read readFile ==> (liftM `liftM` liftM) read readFile ==> liftM liftM liftM read readFile
10:38:27 <dukedave> "anonymous reader monad" ?
10:38:36 <edwardk> http://comonad.com/reader/2006/generalizing-dot/
10:38:42 <lambdabot> Title: The Comonad.Reader » Generalizing (.)
10:38:49 <dukedave> Cheers
10:39:26 <LoganCapaldo> @src (->)
10:39:26 <lambdabot> Source not found. stty: unknown mode: doofus
10:39:35 <LoganCapaldo> booo
10:39:42 <LoganCapaldo> @src (->) Monad
10:39:42 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
10:39:50 <LoganCapaldo> @src (->) (>>=)
10:39:51 <lambdabot> f >>= k = \ r -> k (f r) r
10:40:30 <Saizan> ?type [ap,=<<]
10:40:32 <lambdabot> parse error on input `]'
10:40:40 <Saizan> ?type [ap,(=<<)]
10:40:42 <lambdabot> forall a b. [(a -> a -> b) -> (a -> a) -> a -> b]
10:40:57 <edwardk> heh
10:41:12 <LoganCapaldo> @type do { x <- (+2); y <- (*2); return (x,y) }
10:41:14 <lambdabot> forall a. (Num a) => a -> (a, a)
10:41:29 <Saizan> with flipped arguments though :)
10:42:17 <LoganCapaldo> > let f = do { x <- (+2); y <- (*2); return (x,y) } in f 4
10:42:18 <lambdabot>  (6,8)
10:43:27 <edwardk> > let (.) :: Functor f => (a -> b) -> f a -> f b; (.) = fmap in ((+2) . (*3)) . [1..5]
10:43:29 <lambdabot>  [5,8,11,14,17]
10:43:41 <LoganCapaldo> > (do { x <- id; y <- id; z <- id; return [x,y,z] }) Nothing
10:43:42 <lambdabot>  [Nothing,Nothing,Nothing]
10:43:58 <LoganCapaldo> @src (->) ask
10:43:58 <lambdabot> ask = id
10:44:35 <LoganCapaldo> > runReader (+3) 2
10:44:36 <lambdabot>      The section `(+ 3)' takes one argument,
10:44:36 <lambdabot>     but its type `Reader r a' ha...
10:44:51 <dukedave> Can someone, in one line, explain what a functor is.. I still don't really get it :(
10:45:13 <dylan> a functor is something that you can fmap over.
10:45:40 <mauke> dukedave: a functor is something that can pretend to be a container
10:45:47 <edwardk> a functor is something we steal from category theory, that lets you peak inside and tweak its contents with fmap the way its used in haskell.
10:45:50 <monochrom> I can't explain functor in one line. I would need a million examples instead.
10:45:55 <dylan> >  fmap (+2) [1,2,3]
10:45:56 <lambdabot>  [3,4,5]
10:45:59 <edwardk> @type fmap
10:46:02 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
10:46:05 <dylan> >  fmap (+2) (Just 1)
10:46:07 <lambdabot>  Just 3
10:46:33 <edwardk> so you want to be able to change the 'container' by just changing all of the elements of it using the function, that doesn't hold for quite every functor, but its general enough to get the right intuition.
10:47:06 <LoganCapaldo> A functor is a thingy that takes a set of thingies, and a set of transformations for those thingies, and transforms it into a new set of thingies and transformations on those thingies.
10:47:27 <Saizan> it's more like you are changing the content rather than the container, imo
10:47:38 <dukedave> I love this channel so much :)
10:48:24 <Jaak> > liftM2 (*) (Just 4) (Just 6)
10:48:25 <lambdabot>  Just 24
10:48:29 <edwardk> list, maybe, either a, (a,), binary trees, etc. you can build a slightly different container by changing its contents with your function.
10:49:06 <monochrom> fmap f for trees will preserve the tree shape and just apply f to keys.
10:49:44 <monochrom> For monads, fmap happens to be liftM.
10:49:46 <edwardk> fmap f for a list preserves the 'shape' (i.e. length) of the list, and just applies f to each item in the list, etc.
10:50:02 <mehrheit> why is map seperate from fmap?
10:50:12 <edwardk> mehrheit: pedagogical reasons
10:50:14 <mauke> instance Functor [a] where fmap = map
10:50:14 <emu> mostly to prevent newbies from gettin gconfused
10:50:16 <dukedave> so fmap f = map f   on lists ?
10:50:23 <monochrom> map is just for lists.  you can stick to fmap if you like.
10:50:23 <edwardk> it gives scary errors if you don't know what a monad is ;)
10:50:24 <sjanssen> dukedave: correct
10:50:34 <emu> the same reason that (.) is not fmap, and there are no monad comprehensions :(
10:50:41 <edwardk> duke: yeah
10:50:51 <edwardk> emu: plus at the time there was no anonymous reader monad ;)
10:50:59 <emu> blargh
10:51:00 <edwardk> monad comprehensions i pine for.
10:52:13 <dukedave> > fmap length (Just "dave")
10:52:14 <lambdabot>  Just 4
10:52:38 * dukedave is wishing he understood this a lot longer ago!
10:52:43 <edwardk> =)
10:53:06 <mauke> > (fmap length show) 42
10:53:07 <lambdabot>  2
10:54:33 <dukedave> I'm intrigued you didn't need a composition there?
10:54:46 <LoganCapaldo> dukedave: there is a composition there
10:54:51 <dukedave> > (map length show) 42
10:54:51 <edwardk> fmap is the composition ;)
10:54:52 <lambdabot>  Couldn't match expected type `[[a]]'
10:54:53 <LoganCapaldo> bwahahahahahahahahahahahaha
10:55:01 <sjanssen> @src fmap ((->) a)
10:55:01 <lambdabot> Source not found. That's something I cannot allow to happen.
10:55:06 <dukedave> > map (length . show) 42
10:55:07 <monochrom> fmap length show = length . show
10:55:07 <mauke> dukedave: show is a container
10:55:07 <lambdabot>   add an instance declaration for (Num [a])
10:55:11 <edwardk> @src (->) fmap
10:55:12 <lambdabot> fmap = (.)
10:55:14 <edwardk> =)
10:55:35 <dukedave> It hurts!
10:55:38 <mauke> rather, a function a -> b is a container of elements of type b, indexed by keys of type a
10:55:44 <LoganCapaldo> > (show >>= return . length) 42
10:55:45 <lambdabot>  2
10:55:47 <edwardk> map is an instance of fmap for one container, like (.) is for a different 'container'
10:55:47 <mauke> think of it as Map a b
10:56:24 <edwardk> s/instance/implementation/
10:56:40 <LoganCapaldo> > (show >>= \x -> return (length x)) 42
10:56:42 <lambdabot>  2
10:56:42 <edwardk> @src [a] fmap
10:56:42 <lambdabot> Source not found. That's something I cannot allow to happen.
10:56:43 <dukedave> One sec, I need to get a pen & paper :)
10:56:45 <edwardk> @src [] fmap
10:56:46 <lambdabot> fmap = map
10:56:50 <edwardk> @src (->) fmap
10:56:51 <lambdabot> fmap = (.)
10:57:03 <edwardk> @src IO fmap
10:57:03 <lambdabot> fmap f x = x >>= (return . f)
10:57:05 <qwr> (.) = fmap would give staff like toUpper . "foo", which would be quite cool ;)
10:57:14 <edwardk> qwr: exactly =)
10:57:30 <edwardk> but it requires baking the (->)e monad into the prelude
10:57:40 <edwardk> at least its functor
10:57:45 <sjanssen> I fear the error messages
10:57:50 <edwardk> yeah
10:57:53 <monochrom> I love error messages.
10:57:55 <edwardk> i'm kind of fond of it
10:58:20 <edwardk> its written into my toy language's prelude already, i just don't have working typeclasses yet ;)
10:58:28 <LoganCapaldo> import Advanced :)
10:58:41 <emu> No instances found for Monad %&@#%$&$^*.  Suggested fix: go back to school for 10 more years.
10:58:59 <monochrom> import PreludeForRealProgrammers
10:59:09 <LoganCapaldo> import #Haskell
10:59:09 <mauke> import SimplifiedPrelude
10:59:17 <edwardk> i love haskell, its the only language where a working knowledge of category theory is required to truly comprehend hello world.
10:59:19 <emu> import Chapter1
10:59:27 <LoganCapaldo> emu++
10:59:33 <edwardk> emu: hahaha
10:59:43 <monochrom> @remember edwardk i love haskell, its the only language where a working knowledge of category theory is required to truly comprehend hello world.
10:59:43 <lambdabot> Done.
10:59:51 <LoganCapaldo> @remember emu import Chapter1
10:59:51 <lambdabot> Done.
10:59:52 <mauke> edwardk: not true
11:00:24 <edwardk> mauke: you can get by, but you don't really grok the power of do until you understand the monad laws.
11:01:12 <mauke> I trust my intuition
11:01:22 <emu> i always wondered why it was called "Prelude"
11:01:29 <emu> where's the book
11:01:32 <edwardk> its a prolog thing, no?
11:01:45 <edwardk> heh
11:01:52 <mauke> the book is your program
11:02:10 <LoganCapaldo> yeah. it's everything before the meat :)
11:02:51 <SamB> edwardk: how is knowing the monad laws equivalent to "a working knowlege of category theory"?
11:03:10 <SamB> or is that a horrible pun?
11:03:35 <edwardk> samb: its a start, i just kind of meant it in a tongue-in-cheek fashion.
11:03:56 <SamB> ah.
11:04:00 <SamB> okay then, carry on ;-)
11:04:31 <isaacd__> maybe importing Prelude.[AnyModule] should turn off the implicit import of Prelude, the same way importing Prelude does.
11:04:59 <edwardk> i just want a minimalist prelude
11:05:12 <emu> who knew i knew category theory
11:05:13 <SamB> yeah.
11:05:31 <SamB> if the Prelude started to have submodules, that would bother me.
11:05:34 <edwardk> i'm ok with importing almost everything myself if there is a standard set of places to pull them from.
11:05:56 <LoganCapaldo> import Prelude.Paragraph.One.Section.Two
11:06:01 <isaacd__> heh, so people could make Prelude.Numeric, Prelude.Simplified, Prelude.None ...
11:06:06 <emu> i get kinda annoyed by the sheer amount of imports sometimes though
11:06:14 <emu> need wildcarding
11:06:21 <SamB> it shouldn't be called Prelude if it gets split out, should it?
11:06:35 <isaacd__> , Prelude.Haskell98 ...
11:06:50 <isaacd__> maybe
11:06:53 <SamB> hmm.
11:07:44 <edwardk> samb: thats fine, move the rest of the list stuff into Data.List, etc.
11:08:21 <SamB> perhaps we should have a Prelude.Haskell98 or something like that
11:08:23 <isaacd__> Mainly so if someone made a package where they wanted their own selection of default imports, they could just make a module Prelude.MyPackage'sName and import that without having to do import Prelude() as well
11:08:46 <SamB> isaacd_: hmm.
11:08:50 <edwardk> that's kinda neat
11:09:03 <Syzygy-> edwardk++
11:09:04 <edwardk> isaacd__++
11:09:05 <SamB> something of that type might be nice
11:09:19 <edwardk> @karma edwardk
11:09:19 <lambdabot> You have a karma of 5
11:09:25 <edwardk> woot, i'm positive now
11:09:38 <SamB> @remember isaacd_ Mainly so if someone made a package where they wanted their own selection of default imports, they could just make a module Prelude.MyPackage'sName and import that without having to do import Prelude() as well
11:09:38 <lambdabot> Done.
11:09:43 <edwardk> back to the beer and hookers
11:09:49 <SamB> hmm. not quite right. oh well.
11:09:53 <SamB> @quote
11:09:53 <lambdabot> TimToady says: We're trying very hard to make different mistakes this time, and I believe we're succeeding. :-)
11:10:09 <Syzygy-> edwardk: Mine is for that lovely quote a short while back.
11:10:11 <benny99> hm :(
11:10:16 <edwardk> =)
11:10:16 <benny99> @quote
11:10:16 <lambdabot> gimboland says: at present i'd say "tinkering with a nuclear bomb" is approximately where i am with monads...
11:10:41 * benny99 afk
11:10:58 <mehrheit> is UTF-8 IO possible with GHC?
11:12:08 <sjanssen> mehrheit: you have to do the encoding yourself
11:13:33 <mehrheit> what do you mean?
11:13:44 <emu> @where utf
11:13:44 <lambdabot> I know nothing about utf.
11:13:45 <Syzygy-> It's disorienting to get back home from the office and suddenly need click-to-focus.
11:14:07 <mauke> @check \a b -> not (a && b) == (not a && not b)
11:14:08 <lambdabot>  Falsifiable, after 3 tests: False, True
11:14:46 <sjanssen> mehrheit: ghc does no encoding transformations -- you'll need to feed your input through a separate encoder/decoder
11:14:51 <sjanssen> @google UTF8.lhs
11:14:53 <lambdabot> http://abridgegame.org/repos/darcs/UTF8.lhs
11:15:26 <sjanssen> mehrheit: there's one encoder/decoder that people often use
11:15:50 <sjanssen> I believe there are iconv bindings in hackage nowadays
11:15:56 <sjanssen> @hackage iconv
11:15:56 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/iconv
11:18:03 <byorgey> @check \a b -> not (a && b) == (not a || not b) -- De Morgan
11:18:04 <lambdabot>  OK, passed 500 tests.
11:22:53 <sjanssen> @scheck \a b -> not (a && b) == (not a || not b) -- prove it
11:22:54 <lambdabot>   Completed 4 test(s) without failure.
11:25:35 <LoganCapaldo> proof by exhaustion!'
11:25:37 <LoganCapaldo> weee
11:29:22 * byorgey makes a mental note to learn more about smallcheck
11:30:26 <edwardk> mehrheit: its a pain in the butt. =/
11:31:26 <mehrheit> yes, I'm trying to figure it out now
11:32:58 <sjanssen> sadly, it seems that this issue bothers very few people
11:33:26 <mehrheit> strangely, it works in ghci ant ghc -e
11:35:06 <mehrheit> ghc -e/ghci prints the bytes seperately: "\197\161\197\171dai"
11:35:20 <edwardk> spencer: i was meaning to ask you, whatever happened to your utf8 over bytestring project?
11:35:31 <mehrheit> and ghc fed with a file adds them: "\353\363dai"
11:35:49 <sjanssen> edwardk: it turned into ByteString parameterized over any Storable type
11:36:03 <edwardk> ok, i want, can i have? =)
11:36:10 <sjanssen> yeah
11:36:32 <sjanssen> http://darcs.haskell.org/SoC/fps-soc/
11:36:34 <lambdabot> Title: Index of /SoC/fps-soc
11:37:14 <sjanssen> edwardk: that's a clone of the old ByteString repo -- it should be pretty easy to tear out StorableVector and compile it with GHC 6.6
11:37:43 <edwardk> so you then just treat unicode values as storable with the utf8 encoding?
11:37:47 <edwardk> or is there other magic
11:37:58 <sjanssen> the in memory encoding is more like UTF-32
11:38:03 <edwardk> yeah
11:38:07 <edwardk> i need utf8
11:38:21 <edwardk> i have one i ripped from pugs and tweaked into a usable form
11:38:28 <sjanssen> you might look at CompactString
11:39:00 <Astro> hi there
11:39:17 <sjanssen> greetings
11:39:27 <Astro> *Main> (get_size [1,2,3]) == 3
11:39:28 <Astro> True
11:39:34 <Astro> *Main> (3) / 2
11:39:34 <Astro> 1.5
11:39:43 <Astro> *Main> (get_size [1,2,3]) / 2
11:39:43 <Astro> <interactive>:1:19:
11:39:43 <Astro>     No instance for (Fractional Integer)
11:39:43 <Astro>       arising from use of `/' at <interactive>:1:19
11:39:55 <Astro> get_size returns Integer
11:40:09 <edwardk> > fromInteger (get_size [1,2,3]) / 2
11:40:10 <lambdabot>   Not in scope: `get_size'
11:40:11 <sjanssen> Astro: Haskell doesn't let you use (/) on Integers
11:40:12 <Syzygy-> Astro: The literal 3 means whatever it needs to mean.
11:40:13 <edwardk> er
11:40:22 <Astro> ouch
11:40:25 <edwardk> > fromInteger (length [1,2,3]) / 2
11:40:25 <Syzygy-> > (fromInteger . get_size $ [1,2,3]) / 2
11:40:26 <Astro> thanks alot
11:40:26 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
11:40:26 <lambdabot>   Not in scope: `get_size'
11:40:31 <edwardk> @type 3
11:40:33 <lambdabot> forall t. (Num t) => t
11:40:45 <sjanssen> Astro: you have two options: use `div` which rounds the result, or turn your Integer into a Double
11:40:45 <edwardk> 3 can be used as any numeric type
11:40:48 <Syzygy-> > (fromInteger . length $ [1,2,3]) / 2
11:40:49 <lambdabot>  Couldn't match expected type `Integer' against inferred type `Int'
11:40:50 <Astro> how do I divide Integers th... thanks!
11:40:58 <sjanssen> > length [1, 2, 3] `div` 2
11:40:59 <lambdabot>  1
11:41:00 <Syzygy-> > (fromIntegral . length $ [1,2,3]) / 2
11:41:01 <lambdabot>  1.5
11:41:09 <Astro> wow, what a really responsive channel
11:41:14 <edwardk> gah, beat me to it
11:41:14 <sjanssen> and Syzygy- has beat me to the other approach :)
11:41:15 <edwardk> heh
11:41:16 <edwardk> yeah
11:41:20 <edwardk> we try to be friendly around here
11:41:23 <Astro> you Haskelleers seem to be cool people
11:41:25 <notsmack> div doesn't round, it truncates
11:41:31 <Syzygy-> Astro: We are.
11:41:37 <edwardk> quot rounds, no?
11:41:46 <edwardk> i can't remember its semantics gah
11:41:47 <notsmack> > quot 2 3
11:41:48 <lambdabot>  0
11:41:52 <sjanssen> nah, none of them round
11:42:10 <edwardk> ah yeah, quot is the one that handles negative numbers the other way
11:42:11 <Botje> @pl \(a,b) -> a + b
11:42:11 <lambdabot> uncurry (+)
11:42:14 <Botje> haha
11:42:14 <Botje> right
11:42:18 <sjanssen> @src Int quot
11:42:18 <lambdabot> Source not found. Take a stress pill and think things over.
11:42:18 <Botje> I keep forgetting about uncurry
11:42:51 <sjanssen> @src quot
11:42:51 <lambdabot> Source not found. Do you think like you type?
11:43:50 <Botje> @pl (\(a,b) -> (head b, a++tail b) )
11:43:50 <lambdabot> uncurry (liftM2 (,) head . (. tail) . (++))
11:43:54 <Botje> hmm
11:43:56 <Botje> that's not half bad
11:44:12 <edwardk> hrmm, so a different storable instance for Char with the utf8 encoding rules would basically let your storable bytestring hold utf8, no?
11:44:26 <Japsu> hmm. uncurry takes an n-ary function and n arguments as a list, and applies the function to the arguments?
11:44:37 <sjanssen> edwardk: nah, Storable needs to be constant width
11:44:41 <edwardk> gah
11:44:43 <edwardk> oh well
11:44:45 <bos> @type uncurry
11:44:45 <edwardk> had hoped
11:44:47 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:45:06 <sjanssen> edwardk: look at CompactString
11:45:08 <notsmack> edwardk: it's easy enough to translate that to UTF8 and back though, isn't it?
11:45:48 <edwardk> notsmack: i have a lot of data that i want to keep in utf8 in memory.
11:46:23 <sjanssen> @google compactstring haskell
11:46:25 <lambdabot> http://sequence.complete.org/hwn/20070312
11:46:26 <lambdabot> Title: Haskell Weekly News: March 12, 2007 | The Haskell Sequence
11:46:28 <edwardk> all my source files, etc. right now i'm just using someone else's conversion of data.bytestring to utf8, but it lacks a data.bytestring.lazy port
11:47:05 <sjanssen> ah, I believe compactstring lacks .Lazy too
11:47:33 <edwardk> these things could be coming in over the network, etc. so laziness is good.
11:48:06 <sjanssen> edwardk: the solution is to make a lazy version of CompactString ;)
11:48:10 <edwardk> heh
11:48:18 <edwardk> i'd hoped you'd gone and done that for me ;)
11:49:06 <Codex_> if I have list of strings, how would I print it in such way that it prints "," between the elements. (should not have , after last element though :) (in c++ it seems there is no clean way to do this :)
11:49:12 <byorgey> @type uncurry
11:49:14 <lambdabot> forall a b c. (a -> b -> c) -> (a, b) -> c
11:49:17 <edwardk> @type intersperse
11:49:19 <lambdabot> forall a. a -> [a] -> [a]
11:49:37 <byorgey> Japsu: no, it takes a function of two arguments and a pair, and applies the function to the two arguments
11:49:40 <edwardk> > intersperse "," ["hello","world","how","are","you?"]
11:49:41 <lambdabot>  ["hello",",","world",",","how",",","are",",","you?"]
11:49:46 <edwardk> er
11:49:46 <Japsu> byorgey: right
11:49:52 <monochrom> Add concat.
11:50:00 <edwardk> > concat $ intersperse "," ["hello","world","how","are","you?"]
11:50:01 <lambdabot>  "hello,world,how,are,you?"
11:50:21 <Codex_> oh there is special purpose function available for it. :)
11:50:53 <Saizan> ?src intersperse
11:50:53 <lambdabot> intersperse _   []     = []
11:50:53 <lambdabot> intersperse _   [x]    = [x]
11:50:53 <lambdabot> intersperse sep (x:xs) = x : sep : intersperse sep xs
11:51:36 <dukedave> Hey, team fmap, I've been jotting down and have a question:
11:51:52 <dukedave> For [] fmap is map..
11:51:54 <edwardk> shoot
11:52:03 <dukedave> For Monads fmap is liftM
11:52:15 <dukedave> Right?
11:52:19 <edwardk> yep
11:52:43 <dukedave> If I say   "For functions fmap is... something"
11:52:49 <dukedave> Does that sort of make sense?
11:52:57 <dukedave> And if so what is the something :)
11:53:04 <Saizan> it's (.)
11:53:06 <edwardk> for functions from a value of type 'e', fmap is (.)
11:53:24 <dukedave> Ah, okay that's good because I was going to ask where this 'e' keeps coming in
11:54:24 <edwardk> fmap :: Functor f => (a -> b) -> f a -> f b   now using a function-like notation pretend f_e a = e -> a, then fmap_f_e :: (a -> b) -> (e -> a) -> (e -> b)
11:54:55 <dukedave> I liked mauke's statement that:  "a function a -> b is a container of elements of type b, indexed by keys of type a"
11:55:09 <mehrheit> why e?
11:55:15 <dukedave> Is it sensible to keep that in the back of my head?
11:55:30 <monochrom> e for "environment"
11:55:33 <edwardk> its chosen because the name is indicative that it is an 'environment' that you can read from
11:55:33 <dukedave> edwardk: Just processing that :)
11:57:42 <edwardk> dukedave: if you then compare than to the type of (.), modulo alpha-equivalence, you have the same type
11:57:44 <edwardk> @type (.)
11:57:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
11:59:07 <dukedave> edwardk: Excellent, I see that now!     (I presume the "modulo alpha-equivalence" is a clause so people don't jump on you for some reason?)
11:59:08 <monochrom> @type flip
11:59:10 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
11:59:31 <dukedave> @src (.)
11:59:32 <lambdabot> (.) f g x = f (g x)
11:59:38 <edwardk> dukedave: modulo alpha-equivalence just means you have to change the names of the variables being chosen by forall.
11:59:59 <dukedave> edwardk: Cool, that makes sense
12:00:03 <byorgey> dukedave: e.g. (e -> b) is the same type as (a -> b), modulo alpha-renaming
12:00:11 <edwardk> \x -> x, and \y -> y are the same function "modulo alpha-equivalence"
12:00:36 <dukedave> Mm, it's a very academia sounding term :)
12:00:39 <edwardk> its a way of saying the names of the variables don't matter
12:00:40 <edwardk> yeah
12:00:47 <byorgey> dukedave: the "alpha" bit is from lambda calculus
12:00:59 <byorgey> dukedave: yup, exactly =)
12:01:03 <weitzman> Usually "modulo alpha-equivalence" is implied, because you'd have to be doing something very strange to care what variables are named
12:01:05 <iakovz> hi
12:01:39 <dukedave> Ah, I'm off to the library tomorrow for a nice lambda calc primer tomorrow anyway
12:01:41 <monochrom> In the real world it's called "Refactor -> Change variable name".
12:01:47 <dukedave> Hehe
12:01:51 <sjanssen> @pl \x y -> compare (tag x) (tag y)
12:01:51 <lambdabot> (. tag) . compare . tag
12:01:55 <edwardk> the pointy-headed types have lots of equivalences, alpha for name-equivalence, beta for 'after you apply functions' equivalence, eta for (\x -> x) y == y, delta for expanding definitions, its just how anal retentive you want to be.
12:02:34 <weitzman> Incidentally, "label" is a good name for something which is like a variable but doesn't alpha convert
12:02:40 <emu> attack of the greek characters
12:03:32 * edwardk is currently wrestling with the semantics of named arguments for his toy language using just those 'labels' =)
12:03:41 <mehrheit> @pl \x -> f x n
12:03:41 <lambdabot> flip f n
12:04:27 <monochrom> eta is (\x -> f x) = f.
12:04:40 <edwardk> er yeah
12:05:15 <dukedave> edwardk: One last one?   Promise ;)
12:05:22 <edwardk> duke: sure
12:05:47 <dukedave> Given fmap f_e = (.)      What is the nature of this magic f_e  ?
12:06:47 <edwardk> dukedave, you can write it a couple of ways, one way would be to say "type Reader e a = e -> a" then say "instance Monad (Reader e) where fmap = (.)"
12:06:53 <monochrom> It has type: (a->b) -> (e -> a) -> (e -> b)
12:07:17 <edwardk> but the way the code does it is it says instance Monad ((->)e) where fmap = (.)    which uses the fact that (->) e a is just e -> a in prefix form.
12:07:32 <edwardk> er
12:07:42 <edwardk> s/instance Monad/instance Functor/g
12:08:25 <LoganCapaldo> @src Reader
12:08:26 <lambdabot> Source not found. Take a stress pill and think things over.
12:08:35 <edwardk> i just figured it was easier to explain using a term level function since you are probably more comfortable with those.
12:09:57 <Saizan> it was fmap_f_e which was intended as "fmap for functions from a type e", just a name, right?
12:09:58 <edwardk> so the former expands out when you look at the type of fmap as (a -> b) -> Reader e a -> Reader e b  which == (a -> b) -> (e -> a) -> e -> b, while the latter expands
12:10:43 <edwardk> (a -> b) -> (->) e a -> (->) e b   which == (a -> b) -> (e -> a) -> e -> b   the same thing
12:10:48 <edwardk> andrea: yeah
12:12:04 <mehrheit> let fmap = (.); (.) = fmap in (+1) . (id 1)
12:12:17 <mehrheit> > let fmap = (.); (.) = fmap in (+1) . (id 1)
12:12:18 <lambdabot>  Exception: <<loop>>
12:13:03 <mehrheit> the comonad.reader article redefines '(.) = fmap', but if 'fmap = (.)' for the Reader instance of Functor, why doesn't that result in undefined?
12:13:29 <Saizan> mehrheit: different modules
12:13:33 <edwardk> because the fmap = (.) in the reader functor is from the prelude
12:14:21 <mehrheit> oh, yes. must start thinking in terms of modules
12:14:27 <edwardk> you can rewrite it like fmap f g x = f (g x) if you want
12:14:50 <edwardk> @djinn (a -> b) -> (e -> a) -> e -> b
12:14:51 <lambdabot> f a b c = a (b c)
12:14:55 <edwardk> =)
12:15:36 <mehrheit> oh, a new toy
12:15:40 <mehrheit> @djinn a -> a
12:15:40 <lambdabot> f a = a
12:16:13 <mehrheit> @djinn [a] -> a
12:16:14 <lambdabot> -- f cannot be realized.
12:16:27 <edwardk> @djinn-add type C r a = (a -> r) -> r
12:16:55 <edwardk> @djinn ((a -> C r b) -> C r a) -> C r a
12:16:55 <lambdabot> f a b = a (\ c _ -> b c) b
12:17:03 <edwardk> there ya go, callCC, no muss, no fuss.
12:17:27 <dukedave> Thanks edwardk all slotting in to place nicely now :)
12:17:52 <edwardk> handy when you aren't sure if something is a monad
12:18:04 <edwardk> @djinn a -> C r a
12:18:04 <lambdabot> f a b = b a
12:18:07 <edwardk> it returns
12:18:18 <edwardk> @djinn C r a -> (a -> C r b) -> C r b
12:18:18 <lambdabot> f a b c = a (\ d -> b d c)
12:18:21 <edwardk> it binds
12:18:25 <edwardk> probably is a monad ;)
12:22:30 <dukedave> @djinn (a -> b) -> b
12:23:02 <dukedave> @djinn a -> a
12:23:35 <dukedave> Oh, have I broken it?  :S
12:24:02 <dukedave> Damn it, dinner is ready & still don't quite understand... Why can't cooking be lazy too :(
12:24:35 <jfredett> yeh- its too bad life is so often strictly evaluated
12:33:48 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
12:33:48 --- topic: set by dons on [Sun May 27 19:49:12 2007]
12:36:29 <edwardk> samb: yeah coz when you join you don't get the annoying funk in funktion message popping up in another window ;)
12:36:59 <SamB> edwardk: I meant, because then you get said message *again* when *it* rejoins
12:37:04 <edwardk> =)
12:37:22 <edwardk> i'd /ignore it if i didn't need to talk to it now and again ;)
12:37:45 <SamB> fortunately, my semantics are differently broken
12:37:52 <Syzygy-> edwardk: You could do a regexped ignor...
12:38:01 <edwardk> hrmm, guess i could just set up an alternate nick for talking to chanserv
12:38:04 <SamB> or rather broken
12:38:12 <edwardk> Syzygy-: in pidgin, its probably not that smart.
12:39:10 <SamB> so that chanserv's announcements are just deposited at random amongst some window's text...
12:40:05 <edwardk> in my case it always pops up in its own window, along side the irc server and nickserv, so everytime i get on i have to close 3 windows that pidgin warns me i shouldn't close because they told me stuff ;)
12:40:48 <edwardk> but at least its better than trillian
12:41:01 <edwardk> escape doesn't blow away the active window
12:41:29 <emu> can't you use something in a shell
12:41:48 <edwardk> windows box at work, can't access my linux boxes at home
12:41:56 <emu> mingw?
12:42:02 <edwardk> blech
12:42:39 <edwardk> plus there is somewhat of an advantage of having this just inline with sametime, aim, icq, msn, and all the other things i have to log into to keep in touch with people.
12:43:28 <Excedrin> you could use bitlbee for that
12:45:29 <dukedave> edwardk: The removal of Esc shortcut is bugging you as well then?
12:45:55 <dukedave> I can't see why they would take the option out :(
12:46:05 <dukedave> Sorry, a little off topic there!
12:46:07 <edwardk> i prefer to not have it
12:46:29 <edwardk> i spend too much time in vi, hitting escape is like a nervous reflex while i think. bad to have it blow away everything i'm typing as i type ;)
12:47:01 <dukedave> Haha, that's interesting, I've never had that too bad..
12:47:05 <edwardk> at least i don't sit there and type ^[:w!^[:w! over and over again like i used to.
12:47:06 <dukedave> :w
12:47:07 <dukedave> ;)
12:47:17 <dukedave> Lol, great minds ;)
12:48:01 <mauke> hah, who uses :w anyway?
12:48:02 <edwardk> people used to ask me what smiley that was supposed to be since i used it so often in chat.
12:49:35 <dukedave> I'm a compulsive :w'er, probably over 2 ':w' per minute... It's such an annoying affliction!
12:49:41 <dukedave> Lol edwardk
12:49:44 <araujo> hello
12:50:41 <edwardk> heh, the worst part is when I have an audible beep on, since people wonder why my machine keeps beeping, coz i'll just sit there and spam that over and over while i'm at rest thinking about something else.
12:51:13 <edwardk> i used to have many angry coworkers over that issue
12:52:15 <mehrheit> I remember typing :q! compulsively
12:52:54 <emu> you need viRC
12:52:59 <mehrheit> so I just aliased it to 'exit' in the shell
12:53:21 <dukedave> emu: Surely that should be YiRC ;)
12:53:25 <emu> yes
12:53:29 <emu> killer application go
12:53:34 <dukedave> Oh God, it really is going to turn in to Emacs isn't it ;)
12:53:43 <edwardk> i hope not
12:53:43 <emu> vim is already there
12:54:03 <edwardk> i'd have to defect to yi ;)
12:55:25 <mehrheit> emu, could you give a link? google returns some windows clients
12:58:28 <edwardk> mehrheit: for vim?
12:58:40 <mehrheit> for viRC
12:58:42 <edwardk> ah
12:59:46 <emu> oh i was making a suggestion
12:59:58 <emu> the name's perfect right? =)
13:00:02 <mehrheit> yes
13:00:47 <mehrheit> and the idea is not bad
13:00:55 <emu> :w
13:02:39 <dukedave> If I have a (partial) type like:      Functor ( (->) a) ) => ...
13:02:53 <dukedave> What would I call the (->) ?
13:02:59 <dukedave> "application" ?
13:03:17 <emu> a type constructor
13:03:27 <emu> @kind (->)
13:03:36 <lambdabot> ?? -> ? -> *
13:03:45 <dukedave> That's just crazy talk :o
13:03:46 <emu> er, maybe i'm wrong
13:03:58 <dukedave> Oh really?  I have no idea :)
13:04:05 <emu> @kind Monad
13:04:07 <lambdabot> Class `Monad' used as a type
13:04:12 <emu> @kind IO
13:04:14 <lambdabot> * -> *
13:04:16 <Saizan> (->) it's definitely a type constructor
13:04:38 <xs> Lemmih: hi! lscd is good afaik. busy. hsSDL appears not to support the timers of SDL? (they're nice bindings!)
13:04:38 <emu> Monads have kinds * -> * generally
13:04:51 <emu> hence (->) needs to be applied to something before it can be an instance of Monad
13:06:08 <edwardk> (->) :: * -> * -> *   no?
13:06:18 <emu> that's what i'd think but ?? -> ? -> *
13:06:34 <edwardk> (->) :: * -> * -> * applied to e :: *  yields (->) e :: * -> *
13:06:47 <edwardk> probably a notation to do with the order involved there
13:08:07 <edwardk> order (a -> b) = max (1 + order a) (order b) or something right? hadn't noticed ghc using that notation before, or maybe i'm just totally on the wrong track.
13:09:06 <Heffalump> edwardk: correct.
13:18:40 <dukedave> Sorry about that, so (->) is a (the?) type constructor?
13:18:41 <LoganCapaldo> @kind (->)
13:18:50 <lambdabot> ?? -> ? -> *
13:18:57 <LoganCapaldo> weird
13:19:19 <LoganCapaldo> Are there other type constructors with such odd kinds?
13:19:23 <Saizan> a type constructor just like [], Maybe, Either, etc..
13:19:40 <LoganCapaldo> @kind Arrow
13:19:42 <lambdabot> Class `Arrow' used as a type
13:19:58 <LoganCapaldo> @kind (Arrow a) => a
13:20:02 <lambdabot>     `a' is not applied to enough type arguments
13:20:02 <lambdabot>     Expected kind `*', but `a' has kind `* -> * -> *'
13:20:09 <shachaf> @kind Kleisli
13:20:11 <lambdabot> (* -> *) -> * -> * -> *
13:21:29 <LoganCapaldo> @kind (Arrow ?a) => ?a
13:21:31 <lambdabot> parse error on input `?a'
13:21:35 <Saizan> @kind ([])
13:21:37 <lambdabot> * -> *
13:21:42 <Saizan> @kind (#,#)
13:21:45 <lambdabot> parse error on input `,'
13:21:55 <Saizan> @kind (# , #)
13:21:58 <lambdabot> parse error on input `,'
13:22:06 <LoganCapaldo> @kind (,)
13:22:08 <lambdabot> * -> * -> *
13:22:14 <edwardk> i think (->) will be pretty much on its own unless you have a type defined in terms of (->)'s
13:22:23 <LoganCapaldo> @kind Int#
13:22:25 <lambdabot> Not in scope: type constructor or class `Int#'
13:22:55 <bos31337> int# is ghc-specific
13:23:02 <bos31337> it's of kind *
13:23:19 <LoganCapaldo> bos31337: isn't (#, #) ghc specific too?
13:23:29 <bos31337> yes
13:23:48 <mehrheit> what is a kind?
13:24:02 <edwardk> hrmm apparently -> is unique. if you define type Reader e a = e -> a, :kind Reader yields * -> * -> *, maybe its internally used so that you know you can apply -> to kinds.
13:24:09 <LoganCapaldo> it's a type of a type to be glib about it
13:24:37 <bos31337> mehrheit: they're the types of types
13:24:38 <edwardk> kinds are the types of types, if you view the type system as a simply typed lambda calculus, kinds are the type system of the type system.
13:24:50 * notsmack discovers and likes genericLength
13:25:02 <mehrheit> LoganCapaldo,  if you missed the it, it would rhyme
13:25:05 <bos31337> kind inference typechecks type declarations
13:25:19 <bos31337> er, type expressions, i mean
13:25:46 * mehrheit imagines typing kinds and typing kind types and kind type types
13:25:52 <edwardk> instead of Ints, Bools as builtins, etc. you have k ::= * | k -> k   as the set of valid types that types can have, a functor takes a type and returns a type, so it has kind * -> *
13:25:53 <LoganCapaldo> mehrheit: hmm, how would it rhyme?
13:26:21 <mehrheit> "it's a type of a type to be glib about"
13:26:25 <edwardk> kinds have a superkind, but there is only one, at that level the type system is boring in haskell.
13:26:58 <LoganCapaldo> You must prounouce about or type differently than me?
13:27:51 <mehrheit> probably, sorry then. I'm not a native english speaker (writer?)
13:28:18 <bos31337> native english typist?
13:31:04 <emu> sometimes its cruel to be kind
13:32:47 <LoganCapaldo> Native english poet <g>
13:33:04 <edwardk> i kind of liked hinze's paper on polytypic functions having  polykinded types,  http://haskell.readscheme.org/servlets/cite.ss?pattern=generic-hinze-R13 if you want more kind-goodness to chew on.
13:33:07 <lambdabot> Title: Citation: Polytypic values possess polykinded types, http://tinyurl.com/yr9brv
13:33:17 <Vulpyne> I have a bytestring that I need to escape in a simple manner, and then convert to a normal string. Wondering which of these methods would probably be faster: http://hpaste.org/321
13:33:23 <edwardk> then of course there is always Omega if you really like kinds,.
13:33:28 <LoganCapaldo> edwardk: providing that kink was rather kidn of you
13:33:39 <Vulpyne> I'm thinking probably escapeSQLUR or escapeSQLB?
13:33:56 <edwardk> *groan*
13:34:37 <edwardk> vulpyne: turn on -O2, and benchmark them ;)
13:34:39 * LoganCapaldo rephrases Vulpyne's question
13:34:53 <LoganCapaldo> How do I benchmark using <haskell implementation X>?
13:34:56 <LoganCapaldo> :)
13:35:09 <Vulpyne> LoganCapaldo: Well, sort of.
13:35:31 <Vulpyne> LoganCapaldo: I don't only ask so that I can select the best one, I also ask so that I can learn why and write more efficient code in the future. :)
13:36:12 <LoganCapaldo> well either way, I don't know <g>
13:36:47 <edwardk> escapeSQLUR is probably going to be faster iterating over a Bytestring converted to a string, and generating a bytestring on output
13:37:03 <edwardk> than escape SQLB
13:37:09 <edwardk> that said, you should probably benchmark it
13:37:43 <Vulpyne> Alright, thanks.
13:38:05 <Vulpyne> I figured the concatMap methods were probably the slowest.
13:40:07 <edwardk> Vulpyne: look at something like http://darcs.haskell.org/packages/ndp/examples/lib/Bench/ to get a good idea of how to time this sort of thing more rigorously
13:40:08 <lambdabot> Title: Index of /packages/ndp/examples/lib/Bench
13:40:16 <Vulpyne> Thanks.
13:41:05 <edwardk> it wasn't really intended for separate use, but its simple enough, and i think most of us have basically reinvented it over time
13:41:59 <Vulpyne> You may have overestimated my intelligence when you say "simple". :)
13:42:18 <edwardk> heh, one sec i might have something similar around that lacks the Options cruft
13:42:21 <edwardk> gah
13:42:26 <edwardk> can't access it, at work, sorry
13:43:17 <Vulpyne> No problem.
13:43:28 <edwardk> @type getCPUTime
13:43:30 <lambdabot> Not in scope: `getCPUTime'
13:43:45 <edwardk> @type System.CPUTime.getCPUTime
13:43:47 <lambdabot> IO Integer
13:44:20 <edwardk> anyways, that gets the current CPU timer in picoseconds, run it before and after your task suitably multiplied a few gajillion times, and subtract for the difference.
13:44:59 <edwardk> then multiply by 1,000,000,000,000 to get seconds or some smaller unit of time if you wish.
13:45:09 <Vulpyne> Ah. Would it be meaningful for calling the function with the exact same arguments?
13:45:42 <edwardk> probably not =) you could just generate a huge string and feed it.
13:46:07 <Vulpyne> Yeah.
13:46:27 <|Steve|> picoseconds? What's the resolution of the timer?
13:46:31 <edwardk> though then running out of memory might dominate your results.
13:46:37 <Heffalump> not better than picoseconds ;-)
13:46:44 <Heffalump> (platform dependent)
13:46:48 <|Steve|> And no where near picoseconds either, I'd imagine.
13:46:58 <Heffalump> indeed.
13:47:02 <edwardk> @type cpuTimePrecision
13:47:04 <lambdabot> Not in scope: `cpuTimePrecision'
13:47:07 <edwardk> gah
13:47:13 <Heffalump> but using picoseconds guarantees that any precision will be representable
13:47:15 <edwardk> @type System.CPUTime.cpuTimePrecision
13:47:17 <lambdabot> Integer
13:47:23 <edwardk> gives you the resolution in picoseconds ;)
13:47:51 <edwardk> until computers are waay too fast.
13:47:55 <edwardk> =)
13:48:09 <Vulpyne> I have an unrelated question: Say I use System.Posix.Time.epochTime which returns the type "EpochTime", is there some way I can convert it to a plain integer?
13:48:12 <dukedave> > System.CPUTime.cpuTimePrecision
13:48:13 <lambdabot>   Not in scope: `System.CPUTime.cpuTimePrecision'
13:48:35 <Heffalump> @type System.Posix.Time.epochTime
13:48:37 <lambdabot> IO System.Posix.Types.EpochTime
13:48:44 <edwardk> fromIntegral it i think
13:48:56 <Vulpyne> I tried that and it didn't work.
13:48:59 <edwardk> er fromEnum
13:49:01 <edwardk> its an Enum
13:49:06 <Vulpyne> Ahh.
13:49:07 <Vulpyne> Thanks.
13:49:23 <edwardk> or toInteger
13:49:27 <edwardk> either should do the same i think
13:49:32 <edwardk> @type toInteger
13:49:34 <lambdabot> forall a. (Integral a) => a -> Integer
13:49:35 <Syzygy-> :t toInteger
13:49:37 <lambdabot> forall a. (Integral a) => a -> Integer
13:49:38 <Syzygy-> :t fromEnum
13:49:40 <lambdabot> forall a. (Enum a) => a -> Int
13:49:49 <edwardk> ok, slight differences
13:49:56 <Vulpyne> toInteger/fromIntegral don't work, but fromEnum does.
13:49:58 <Vulpyne> Thanks.
13:50:09 <edwardk> no problem
13:50:33 <Syzygy-> Vulpyne: Just because it implements Enum, it doesn't have to implement Integral
13:50:44 <Syzygy-> nor Num
13:51:06 <edwardk> it is also an Integral, CTime is Read Show Typeable Eq Ord Num Enum Storable Bounded Read Integral Bits
13:51:14 <edwardk> its just apparently a crappy Integral ;)
13:51:22 <Syzygy-> Hehe
13:53:58 <dukedave> @kind Int
13:54:00 <lambdabot> *
13:54:11 <dukedave> @kind 3
13:54:13 <lambdabot> Only unit numeric type pattern is valid
13:54:55 <edwardk> 3 doesn't have a kind, as it is a term, terms have types, types have types. so 3 :: Int :: * would be one way to view a particular value of 3.
13:55:04 <edwardk> er types have kinds
13:55:25 <dukedave> Excellent :)
13:57:02 <oerjan> @kind MonadTrans
13:57:03 <Heffalump> @kind ()
13:57:05 <lambdabot> Class `MonadTrans' used as a type
13:57:07 <lambdabot> *
13:57:25 <LoganCapaldo> @instances MonadTrans
13:57:26 <lambdabot> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
13:57:31 <oerjan> er, classes _do_ have kinds, don't they?
13:57:38 <LoganCapaldo> @kind ContT
13:57:40 <lambdabot> * -> (* -> *) -> * -> *
13:57:44 <Heffalump> no, their parameters have kinds
13:57:58 <LoganCapaldo> oerjan: instances of classes have kinds, right?
13:58:10 <LoganCapaldo> Not the classes themselves
13:58:15 <dukedave> So (->) is a type constructor.. ?    Is there such thing as a kind constructor?
13:58:22 <Heffalump> yes, (->)
13:58:52 <oerjan> but all instances must have the same kinds, don't they?
13:58:55 <edwardk> classes are classes, classes have parameters, each parameter holds types all of the same kind
13:59:02 <dukedave> Wow I think it might be a little late for this
13:59:03 <dmhouse> * is the 'basic kind', and (->) is the only kind constructor.
13:59:09 <edwardk> (->) is also the only kind constructor
13:59:22 <edwardk> @quote stereo
13:59:22 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:59:23 <dmhouse> So the only way to make kinds is by grammatical combinations of * and ->
13:59:27 <dmhouse> ?quote stero
13:59:27 <lambdabot> No quotes match. You speak an infinite deal of nothing
13:59:33 <dmhouse> ?quote stereo
13:59:33 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
13:59:38 <dmhouse> I was a bit late on that one. :)
13:59:41 <edwardk> =)
13:59:57 <oerjan> i guess the problem is that the result would not be * if you gave classes a kind
14:00:15 <Heffalump> instances don't have kinds
14:00:28 <edwardk> its a nice thing about having so many ph.ds and would-be ph.d's on channel, they like to make sure they know the material, and the best way to make sure you know something is to try to teach it to someone else ;) makes for a very helpful channel.
14:00:42 <Heffalump> and it doesn't make sense for a class to have a kind, because you can't use a class where you would use a type
14:01:01 <dmhouse> I wonder how many people here are actually grad students or later.
14:01:03 <Syzygy-> Do we even dare to make a survey of education level for people here?
14:01:07 <oerjan> but that is only because a type kind needs to end with -> *
14:01:16 <Syzygy-> I'm working on my PhD....
14:01:21 <Syzygy-> I bet I'm not alone.
14:01:24 <Syzygy-> Not by far.
14:01:24 * dmhouse isn't even yet undergraduate
14:01:25 <oerjan> while a class kind would probably end with something like -> Prop ?
14:01:27 <Heffalump> oerjan: ok, I guess you could make a different kind that wasn't unifiable with *
14:01:33 <DRMacIver> I have transcended mere education.
14:01:35 <edwardk> I have a couple masters degrees and need to get around to starting a Ph.D program some time.
14:01:36 <Heffalump> but that'd be quite confusing, IMO
14:01:39 <Syzygy-> dmhouse: Whoa? Really?
14:01:57 <Heffalump> sorear isn't either, is he?
14:02:01 <oerjan> Heffalump: isn't that what the Calculus of Constructions does?
14:02:05 <Heffalump> (even yet undergraduate)
14:02:13 <dukedave> I think the reason I've stuck it out with Haskell is this channel and Haskell-chat, because you can get away with asking questions which would on a C++ forum only get you snide remarks or RTFMs etc.
14:02:24 <Heffalump> oerjan: away with your Lambda Calculus talk ;-) (no idea. Ignorant in that area, me)
14:02:29 <oerjan> more or less
14:02:31 <dmhouse> Syzygy-: not yet. I will be this October. I'm just self-taught in terms of Haskell. :)
14:02:37 * dmhouse reads a lot and asks a lot of questions
14:02:40 <edwardk> the Haskell community is awesome, it is what got me to stay.
14:02:40 <Syzygy-> dmhouse: I'm surprised, actually.
14:02:41 <oerjan> hey i don't know that much either
14:02:46 <Syzygy-> I had a completely different impression of you.
14:02:58 <Syzygy-> edwardk, dukedave: It really is a VERY nice community.
14:03:10 <Syzygy-> What pulled me in , thoguh, is the rampant category theory. :P
14:03:27 <Heffalump> eek, we'd better kill that off quick
14:03:36 <oerjan> ok maybe i do now a bit, it's just haphazardly collected
14:03:38 <DRMacIver> Syzygy-: As established previously in #haskell, Haskell is really an alien brainwashing technology for turning programmers into nice people. :)
14:03:48 <nominolo> :t flip maybe
14:03:48 <dmhouse> Syzygy-: well, I'm flattered. :)
14:03:50 <lambdabot> forall a a1. (a1 -> a) -> a -> Maybe a1 -> a
14:03:56 <DRMacIver> Syzygy-: It's the only explanation which makes sense.
14:04:01 <dmhouse> Syzygy-: I didn't know you were a grad student. Where at?
14:04:08 <dolio> DRMacIver: It doesn't always work, though. :)
14:04:14 <dukedave> Lol DRMacIver
14:04:22 <DRMacIver> dolio: Right. For example, I'm still around. ;)
14:04:31 <edwardk> haskell was the first excuse i had to really USE category theory
14:04:58 <edwardk> up until then it was as my math professors would say just so much 'abstract nonsense' ;)
14:05:03 <DRMacIver> Not surprising. It doesn't get used for anything interesting in mathematics. ;)
14:05:04 <DRMacIver> </troll>
14:05:08 <edwardk> DR: =)
14:05:19 * DRMacIver preemptively dodges away from Syzygy- 
14:05:41 <nominolo> @pl \m f -> maybe f return m
14:05:41 <lambdabot> flip (flip maybe return)
14:06:30 <nominolo> yuck
14:06:31 <edwardk> flip flip?
14:06:34 <LoganCapaldo> @type flip (flip maybe return)
14:06:37 <lambdabot> forall a (m :: * -> *). (Monad m) => Maybe a -> m a -> m a
14:06:47 <LoganCapaldo> ah
14:06:48 <edwardk> ah i see
14:06:55 <edwardk> intuition was wrong
14:07:01 <edwardk> er my intuition anyways
14:07:06 <dmhouse> ?type flip maybe return
14:07:08 <lambdabot> forall a (m :: * -> *). (Monad m) => m a -> Maybe a -> m a
14:07:13 <dmhouse> ?type maybe return
14:07:16 <lambdabot> forall a (m :: * -> *) a1. (Monad m) => (a1 -> a -> m a) -> Maybe a1 -> a -> m a
14:08:00 <LoganCapaldo> @type maybe
14:08:02 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
14:08:22 <Syzygy-> dmhouse: I'm doing a PhD in homological algebra at the university of Jena
14:08:28 <Syzygy-> (my net just hickuped)
14:08:32 <LoganCapaldo> I think maybe's arg order is all backwards
14:08:50 <Syzygy-> Missed the chance to shout at Heffalump for suggesting to kill off category theory too....
14:08:52 <nominolo> LoganCapaldo: most of the time, yup
14:08:56 <LoganCapaldo> Maybe a -> (a -> b) -> b -> b IMO
14:08:59 <dolio> It's the same as foldr.
14:09:00 <LoganCapaldo> would be better
14:09:44 <byorgey> LoganCapaldo: nah, that would make it harder to partially apply it in useful ways
14:09:52 <dukedave> http://www.uni-jena.de/ Syzygy-?
14:09:53 <lambdabot> Title: Friedrich-Schiller-Universität Jena -
14:10:02 <dmhouse> Syzygy-: cool :)
14:10:11 <Syzygy-> dukedave: That's the one.
14:10:14 <Syzygy-> dmhouse: Yeah.
14:10:43 <LoganCapaldo> byorgey: compromise, (a -> b) -> b -> (Maybe a) -> b ?
14:10:55 <dukedave> Know if they're looking for any cheap labour? :)
14:11:00 <Syzygy-> dukedave: Jena?
14:11:07 <dukedave> Yeah.!
14:11:15 <Syzygy-> Might be. What are you looking for?
14:11:29 <dukedave> I'm wrapping up my MSc in Sept. and looking forwards..
14:11:47 <byorgey> LoganCapaldo: yeah, that makes more sense to me
14:11:56 <Syzygy-> Ah.
14:12:08 <Syzygy-> So you're basically asking me whether we take on PhD students?
14:12:11 <dukedave> Ideally I'd like to get myself a funded PhD in something functional?
14:12:19 <Syzygy-> Hmmmm.
14:12:22 <Syzygy-> We're the wrong place then.
14:12:30 <oerjan> LoganCapaldo: maybe is supposed to turn a Maybe a into a cata-or-something-morphism
14:12:32 <Syzygy-> I'm more or less the only really functional head at the university. :P
14:12:39 <emu> start a dept!
14:12:43 <Syzygy-> Just like I'm the only homological head there.
14:12:48 <dukedave> Hehe
14:12:51 <Syzygy-> emu: WAY too early or that.
14:13:00 <LoganCapaldo> oerjan: what does that have to do with the order of the parameters? :)
14:13:11 <hpaste>  Botje pasted "How could I generalise this?" at http://hpaste.org/322
14:13:17 <dukedave> I did have to Wikipedia 'homological algebra' ;)
14:13:21 <Syzygy-> dukedave: Hehehe
14:13:42 <nominolo> :t unless
14:13:44 <monochrom> "maybe" is a catamorphism for "Maybe".
14:13:45 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
14:13:51 <Heffalump> dukedave: what's your MSc in?
14:13:59 <emu> yea i don't see too many haskelly depts in the States.  though there is an interesting proposal tomorrow that involves parallel functional programming and SPJ is on the committee
14:14:04 <emu> here
14:14:26 <Syzygy-> emu: Cooool.
14:14:48 * nominolo used to live in Jena
14:14:58 * Heffalump has never even heard of Jena :-(
14:15:07 <emu> Jena is where Frege lived
14:15:10 <emu> i think
14:15:13 <dukedave> Computational Intelligence... So I'm keep to get cracking on the AI Strikeforce stuff
14:15:13 <Syzygy-> Ayup.
14:15:22 <Syzygy-> We have a philosophy prof. dedicated to Frege studies.
14:15:37 <nominolo> also Schiller (for a while) iirc
14:15:42 <Syzygy-> nominolo: You did!?
14:15:44 <Syzygy-> nominolo: Where?
14:15:51 <Syzygy-> What did you do here?
14:16:01 <oerjan> LoganCapaldo: that it is a bijection between Maybe a and forall b. b -> (a -> b), i think, and with that viewpoint the first argument is the important one
14:16:13 <oerjan> * -> b
14:16:17 <nominolo> Syzygy-: go to kindergarden in lobeda ;)
14:16:22 <Syzygy-> Oh, right.
14:16:30 <Syzygy-> :)
14:16:45 <nominolo> Syzygy-: before the revolution
14:16:58 <Syzygy-> Heh
14:17:10 <emu> kindergarten eh.. what degree did you earn from there?
14:17:15 <byorgey> Botje: can't you just do something like map fst $ take n $ pickOne as?
14:17:33 <Botje> yes
14:17:45 <Botje> but that would only return one possibility, i think
14:17:59 <byorgey> oh, ok, I get it
14:18:03 <byorgey> hmm
14:18:03 <nominolo> emu: a "bienchen" maybe
14:18:17 <Botje> I was thinking along the lines of unfoldr
14:18:21 <Botje> but not sure how to tell it to stop
14:18:26 <Botje> or even if it'd work
14:18:33 <emu> takeWhile?
14:19:15 <Botje> could keep a counter too, of course
14:19:48 <dolio> Botje: Why not make a monad such that 'choose :: M s' selects, nondeterministically, one s from a supply of many s...
14:19:49 <emu> does anyone use takeWhile ... iterate sometimes?
14:19:54 <dmhouse> Botje: what's the task?
14:20:00 <dolio> Then it's 'replicateM n choose'
14:20:08 <byorgey> emu: sure
14:20:09 <dolio> Or something like that.
14:20:20 <Botje> dolio: interesting, i've never made my own monad before. this might be a good reason :)
14:20:33 <Botje> dmhouse: enumerating all of C_k^n
14:21:33 <Botje> ie enumerate all possible combinations of k choices from n numbers
14:21:58 <nominolo> :t orElse
14:22:00 <lambdabot> Not in scope: `orElse'
14:22:55 <oerjan> Botje: i did something like that, i used a StateT monad
14:23:18 <oerjan> to keep the remainder, although it was just a size integer
14:23:19 <emu> a Set monad would help =)
14:24:36 <emu> > sequence [[1..10],[1..10],[1..10]]
14:24:37 <lambdabot> Terminated
14:25:05 <Botje> that could work too
14:25:09 <oerjan> StateT [a] [], i guess
14:25:20 <Botje> just sequence a bunch of lists and check for unicity afterwards
14:25:45 <emu> this ain't gonna be particularly efficient though
14:26:03 <emu> particularly if you are afflicted by the lack of a non-deterministic turing machine
14:26:48 <oerjan> nominolo: i think you want ||
14:27:04 <emu> orElse is an STM combinator
14:27:29 <oerjan> oh
14:27:33 <Saizan> or an ArrowChoice method
14:27:43 <Saizan> ?hoogle orElse
14:27:44 <lambdabot> GHC.Conc.orElse :: STM a -> STM a -> STM a
14:27:44 <lambdabot> Data.Generics.Aliases.orElse :: Maybe a -> Maybe a -> Maybe a
14:27:48 <emu> or perhaps he was simply threatening lambdabot
14:27:54 <Saizan> and other things :)
14:27:55 <emu> vaguely
14:27:58 <monochrom> haha
14:28:16 <emu> ?type, OR ELSE
14:28:18 <lambdabot> Not in scope: data constructor `OR'
14:28:19 <lambdabot>  
14:28:19 <lambdabot> <interactive>:1:3: Not in scope: data constructor `ELSE'
14:28:49 <nominolo> i want mplus, mut with a more appropriate name
14:29:40 <monochrom> "or else" is still not an appropriate name.
14:29:41 <nominolo> > Just 42 `mplus` error "boom"
14:29:43 <lambdabot>  Just 42
14:30:01 <nominolo> > Nothing `mplus` Just 42 `mplus` error "boom"
14:30:02 <lambdabot>  Just 42
14:30:03 <dolio> > filter ((==3) . length) . filterM (const [False, True]) $ [1..10]
14:30:05 <lambdabot>  [[8,9,10],[7,9,10],[7,8,10],[7,8,9],[6,9,10],[6,8,10],[6,8,9],[6,7,10],[6,7,...
14:30:07 <oerjan> @type (+++)
14:30:09 <lambdabot> forall (a :: * -> * -> *) b c b' c'. (ArrowChoice a) => a b c -> a b' c' -> a (Either b b') (Either c c')
14:30:17 <Cale> What's inappropriate about mplus?
14:30:29 <oerjan> @src Monoid
14:30:29 <lambdabot> class Monoid a where
14:30:29 <lambdabot>     mempty  :: a
14:30:29 <lambdabot>     mappend :: a -> a -> a
14:30:29 <lambdabot>     mconcat :: [a] -> a
14:30:43 <nominolo> Cale: the name
14:30:56 <oerjan> nominolo: parsec uses <|>
14:31:14 <LoganCapaldo> > let frob = mplus in Just 42 `frob` Nothing
14:31:15 <lambdabot>  Just 42
14:31:48 <nominolo> since i have to work in IO I just stick with maybe and case
14:31:58 <LoganCapaldo> If we adopt this name for mplus, I guarantee that uses of that function will skyrocket
14:32:11 <emu> i use frob plenty
14:32:15 <nominolo> no need to prettify
14:32:37 <LoganCapaldo> See? it's already working
14:32:42 <nominolo> @dict frob
14:32:42 <lambdabot> Supported dictionary-lookup commands:
14:32:42 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
14:32:42 <lambdabot> Use "dict-help [cmd...]" for more.
14:32:42 <emu> what would be the type of 'grok'?
14:33:08 <nominolo> @dict jargon frob
14:33:09 <lambdabot> Supported dictionary-lookup commands:
14:33:09 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
14:33:09 <lambdabot> Use "dict-help [cmd...]" for more.
14:33:18 <nominolo> @jargon frob
14:33:20 <lambdabot> *** "frob" jargon "Jargon File (4.3.1, 29 Jun 2001)"
14:33:20 <lambdabot> frob /frob/ 1. n. [MIT; very common] The {TMRC} definition was "FROB =
14:33:20 <lambdabot>    a protruding arm or trunnion"; by metaphoric extension, a `frob' is any
14:33:20 <lambdabot>    random small thing; an object that you can comfortably hold in one hand;
14:33:20 <lambdabot>    something you can frob (sense 2). See {frobnitz}. 2. vt. Abbreviated
14:33:22 <lambdabot> [7 @more lines]
14:33:53 <Botje> @pl \(a,b) -> (f a, f b)
14:33:54 <lambdabot> f *** f
14:33:57 <nominolo> @more
14:33:59 <Botje> haha
14:34:02 <Botje> another nice one:)
14:34:18 <nominolo> :t on
14:34:20 <lambdabot> Not in scope: `on'
14:34:38 <nominolo> :t Data.Function.on
14:34:40 <lambdabot> Couldn't find qualified module.
14:34:49 <nominolo> meh
14:36:00 <dolio> @pl \a -> (f a, g a)
14:36:00 <lambdabot> liftM2 (,) f g
14:48:55 <oerjan> is nick++ a lambdabot abbreviation for @karma+ nick ?
14:49:06 <dolio> @karma nick
14:49:06 <lambdabot> nick has a karma of 3
14:49:18 <sieni> nick++
14:49:21 <sjanssen> oerjan: yes
14:49:22 <sieni> @karma nick
14:49:22 <lambdabot> nick has a karma of 4
14:49:27 <sieni> \o/
14:49:38 <sjanssen> nick-- nick--
14:49:42 <fasta> Can someone write a ps viewer in Haskell, please?
14:49:49 <sjanssen> fasta: yeah, I'll get right on it
14:49:53 <sjanssen> ;)
14:50:01 <fasta> sjanssen: it will be 5 minutes of work.
14:50:27 <fasta> sjanssen: with all those type classes, having Djinn doing all the work, getting it auto tested by QuickCheck.
14:50:37 <sjanssen> it is an interesting idea
14:50:42 <fasta> No, I don't get why all ps viewers fail to do it correctly.
14:50:47 <sjanssen> a PS viewer is essentially a programming language, right?
14:51:00 <fasta> Adobe acrobat reader also does the wrong thing.
14:51:03 <sjanssen> erm, programming language interpeter
14:51:10 <fasta> (I converted it to PDF too)
14:51:27 <fasta> Only Evince does the right thing, but it is limited to zooming to 400%.
14:51:30 <DRMacIver> sjanssen: Plus some fiddly rendering bits. :)
14:51:56 <fasta> I really don't get how people can do even that wrong, but maybe I am underestimating the complexity of such a program.
14:52:20 <DRMacIver> It's impossible to overestimate the complexity of a program written in C. ;)
14:52:39 <DRMacIver> </troll> again.
14:52:43 <pjd> fasta: maybe it's just that no Einstein has tackled this particular refrigerator
14:52:55 <fasta> pjd: maybe there are too little Einsteins.
14:53:07 <pjd> two little Einsteins?
14:53:36 <fasta> pjd: _too_, not two.
14:54:10 <fasta> It's incredibly funny to see what kghostview makes of it.
14:54:14 <pjd> but s/little/few/, i meant
14:54:28 <fasta> pjd: yes, that's better English.
14:54:53 <fasta> kghostview has a "mini-viewer" in the top left by default.
14:55:09 <fasta> Oh, well, I will just show some PICS!!
14:56:01 <Vulpyne> Is there a better (faster?) way of string formatting than ++ing a bunch of parts together?
14:56:53 <SamB> Vulpyne: is it recursive?
14:57:05 <monochrom> A better way is using a pretty-printer library.  I don't know about faster.
14:57:36 <Vulpyne> samb: Nope. It's just ++ing a bunch of [Char]s.
14:57:40 <DRMacIver> ++ is O(1), surely? :) How much faster do you want?
14:57:41 <Vulpyne> And functions that return string.
14:58:00 <Vulpyne> Only an O(0.5) function will satisfy me.
14:58:04 <dolio> (++) is not O(1).
14:58:19 <ddarius> xs ++ ys is O(length xs)
14:59:14 <Vulpyne> So that would make a ++ b ++ c ++ ... z not so great?
14:59:15 <DRMacIver> Not really, because it's lazily evaluated.
14:59:30 <DRMacIver> > head [1...] ++ [3]
14:59:30 <lambdabot>  Parse error
14:59:34 <DRMacIver> > head [1..] ++ [3]
14:59:35 <lambdabot>   add an instance declaration for (Num [a])
14:59:35 <lambdabot>     In the expression: 1
14:59:38 <ddarius> Vulpyne: No, that's fine
14:59:39 <fasta> http://img363.imageshack.us/my.php?image=screenshotlm1.png <- there is a funny screenshot.
14:59:39 <Vulpyne> But the whole thing would have to be evaluated each time.
14:59:41 <lambdabot> Title: ImageShack - Hosting :: screenshotlm1.png
14:59:48 <DRMacIver> > head $ [1..] ++ [3]
14:59:49 <lambdabot>  1
14:59:56 <fasta> It shows the complete stupidity of kghostview.
15:00:00 <dolio> (...(a ++ b) ++ c ++ ...) ++ z is bad.
15:00:08 <ddarius> ((xs++ys)++zs)++as is bad xs++(ys++(zs++as)) is fine.
15:00:09 <dolio> But that's not the default fixity of (++).
15:00:29 <Excedrin> fasta: what's it doing?
15:00:35 <sorear> hello.
15:00:50 <fasta> Excedrin: What do you mean?
15:00:54 <Vulpyne> So parenthizing an expression like that would probably be a good idea?
15:00:56 <fasta> Excedrin: whether it's using CPU?
15:01:09 <Excedrin> fasta: no, I can't tell what's stupid about that screenshot
15:01:11 <Vulpyne> Or did you mean the good one was the default fixity
15:01:19 <DRMacIver> Vulpyne: The good one is the default.
15:01:23 <fasta> Excedrin: look at the red square in the screen shot.
15:01:24 <Vulpyne> Ah, okay. Good.
15:01:29 <DRMacIver> Vulpyne: This is generally the case with Haskell fixity declarations. :)
15:01:35 <fasta> Excedrin: do you see that it contains green pixels?
15:01:39 <Vulpyne> I would hope so. :)
15:01:44 <Excedrin> yes
15:01:45 <fasta> Excedrin: that should correspond to the main screen.
15:01:55 <fasta> Excedrin: the main screen only contains white pixels.
15:02:02 <Excedrin> oh, ok
15:02:05 <fasta> Excedrin: which means kghostview is making a mistake
15:02:08 <Excedrin> does gv do that also?
15:02:21 <Cale> main screen turn on?
15:02:37 <Vulpyne> Thanks.
15:03:21 <monochrom> > head $ foldl (++) "" (cycle "h")
15:03:22 <lambdabot>  Couldn't match expected type `[Char]' against inferred type `Char'
15:03:25 <fasta> Cool, I crashed ghost script.
15:03:45 <fasta> Really, this pathetic mediocre software makes me sick
15:03:59 <Vulpyne> monochrom: That's the same as concat, isn't it?
15:04:06 <Excedrin> how'd you crash ghostscript?
15:04:14 <monochrom> Let me resolve the type error first.
15:04:39 <dolio> > cycle ["h"]
15:04:41 <lambdabot>  ["h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h"...
15:05:02 <monochrom> I see.  repeat would be more convenient.
15:05:08 <monochrom> > head $ foldl (++) "" (repeat "h")
15:05:14 <lambdabot> Terminated
15:05:16 <monochrom> > head $ foldr (++) "" (repeat "h")
15:05:17 <lambdabot>  'h'
15:05:25 <monochrom> That is the difference.
15:05:27 <Cale> Can't foldl over an infinite list.
15:06:03 <yakov> goodnight
15:06:34 <LoganCapaldo> > let xs = as ++ xs where as = ["h"] in xs
15:06:36 <lambdabot>  ["h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h","h"...
15:06:57 <monochrom> infinite list just highlights the computational complexity involved.  you really have just a list of length 1 million.
15:08:45 <davidL> ?index spawn
15:08:46 <lambdabot> bzzt
15:09:40 <dolio> But if the list is infinite, is infinity^2 > infinity? :)
15:09:41 <DRMacIver> fasta: I've written too much pathetic mediocre software for it to make me sick any more. ;)
15:11:25 <monochrom> Since I just ask for "head", it's just infinity > 1.
15:13:49 <dolio> But isn't that just due to the strictness, not the fact that one algorithm is asymtotically more complex?
15:13:54 <dolio> Although the two are related.
15:14:57 <DRMacIver> Hm
15:15:04 <DRMacIver> An amusing thought occurs to me. :)
15:15:27 <LoganCapaldo> > let i = (2.0/0.0) in (i, i**2 > i)
15:15:28 <lambdabot>  (Infinity,False)
15:15:45 <dolio> > let reverse [] = [] ; reverse (x:xs) = reverse xs ++ [x] in head (reverse [1..])
15:15:48 <lambdabot>  Exception: stack overflow
15:15:56 <DRMacIver> Most CS courses have a first year class called "Data structures and algorithms". If they thought it in Haskell they could rename it slightly, to "Data structures are algorithms".
15:15:57 <monochrom> Laziness is assumed throughout. (I didn't use foldl'.) I'm comparing the two with "all else being equal". So the conclusion is still that one algorithm is more complex than the other.
15:16:03 <DRMacIver> s/thought/taught/
15:16:16 <nominolo> @pl \x -> (x,[])
15:16:16 <lambdabot> flip (,) []
15:16:22 <dolio> > let reverse = foldl (flip (:)) [] in head (reverse [1..])
15:16:28 <lambdabot> Terminated
15:16:42 <LoganCapaldo> DRMacIver: Funny, I've always thought algorithms were data-structures :)
15:17:09 <DRMacIver> LoganCapaldo: Code is data, data is code. </lisp>
15:17:59 <LoganCapaldo> The present is the future past :)
15:18:40 <DRMacIver> Freedom is slavery.
15:18:46 <DRMacIver> Oops, wrong meme category. :)
15:18:54 <mauke> Ketchup is a vegetable.
15:19:43 <DRMacIver> Soylent green is people!
15:19:45 <dolio> monochrom: foldl is strict in the structure of the list even if you don't use foldl'.
15:19:54 <monochrom> "Freedom is slavery" and "ignorance is strength" are both true for good haskell programming. :)
15:20:30 <DRMacIver> monochrom: I see the former. Ignorance of what though?
15:20:37 <monochrom> abstraction
15:20:47 <DRMacIver> ("Trust the computer" is also true for good haskell programming)
15:20:54 <LoganCapaldo> ignorance of implementation. Willful ignorance :)
15:20:56 <DRMacIver> Ignorance of abstraction?
15:21:18 <monochrom> ignorance <== abstraction.  or what LoganCapaldo says.
15:21:25 <DRMacIver> I see.
15:22:04 <Excedrin> is it possible to convince people who believe that their strength as a programmer is knowing what happens at a low-level that they should code in a higher level language? (or maybe, what sorts of ideas should one present...)
15:22:09 <monochrom> Actually true for good any programming.  You want strong checks not freedom.  You want abstractions not details.
15:23:12 <monochrom> It is impossible to convince anyone anything after they have graduated from college.  For some people, after highschool.
15:23:29 <Excedrin> well, that's obviously untrue
15:23:41 <monochrom> OK, I'm exaggerating.
15:24:06 <dolio> I've probably been convinced of at least one thing since college. :)
15:24:32 <sorear> Excedrin: The only path to success is to have multiple hats.  I use high level languages *and* fully understand the operation of STG-style machine code.
15:24:33 <monochrom> But you will not convince me that what I said is untrue. :)
15:24:36 <jfredett> is there a way to pattern match a list backwards? that is--
15:24:36 <jfredett> instead of (x:xs) being the head/tail, have it be (xs:x) where xs is everything but the last element, and x is the last element? (trunk and tip? I guess?)
15:24:48 <dolio> Heh.
15:25:00 <Cale> jfredett: reverse the list first
15:25:04 <monochrom> No, there is no way.  You can ask for "init" and "last".
15:25:14 <sorear> is++
15:25:37 <dolio> Data.Sequence might be useful if you're doing a lot of that.
15:25:59 <Cale> Performance-wise, lists behave somewhat like stacks in that they're cheaply accessible from only one end.
15:26:00 <jfredett> Cale: issue is, the code starts getting really ugly when I start reversing these things
15:26:05 <Cale> (Sometimes they only have one end)
15:26:12 <Excedrin> sorear: I've never been able to convince someone who understands what C or C++ compiles into (and thinks that this understanding makes them "AEWSOME") that they should look at Haskell
15:26:17 <jfredett> okay- cool.
15:26:27 <sjanssen> sorear: we might have to add special logic to Plugin.Karma that ignores jfredett :)
15:26:35 <hedos> monochrom, I don't see what the "Freedom is slavery" mean.
15:26:39 <jfredett> sjanssen: thats not a bad idea
15:26:49 <Cale> You can use init and last, sometimes I like to combine the two into one function which extracts both at the same time.
15:27:01 <LoganCapaldo> jfredett: Do you need to view it both ways? Because if the list is "always revfersed" you can just do nothing, and pretend the head is the tip and the tail is the trunk
15:27:06 <Cale> (in one pass over the list)
15:27:10 <jfredett> I wrote a script thing- that was suppose to catch --, but somehow, my brain manages to type it anyway
15:27:16 <hedos> monochrom, oh, nevermind, I didn't read fully.
15:27:19 <monochrom> I guess I should say "can person P convince person Q to do Y instead of X" is dominated by P and Q rather than by X and Y.
15:27:20 <jfredett> LoganCapaldo: I need to access the end, not the begining
15:27:25 <LoganCapaldo> I know
15:27:36 <jfredett> I mean only the end
15:27:38 <LoganCapaldo> I'm saying treat the beginning as the end if you can
15:27:53 <Cale> You could create a new data structure for that.
15:28:11 <jfredett> right- so I was hopeing there was a magical way to pattern match a trunk-tip rather than a head-tail
15:28:21 <Excedrin> monochrom: that's a good point
15:28:37 <ddarius> jfredett: Just change your perspective.
15:28:40 <LoganCapaldo> And what I'm saying is if you are _only_ matching trunk-tip, matching head-tail is equivalent anyway
15:29:04 <LoganCapaldo> if you need to manipulate both ends, all bets are off of course
15:29:05 <notsmack> jfredett: yeah, it sounds like you're thinking backwards
15:29:23 <Cale> data SnocList a = Nil | (SnocList a) :> a
15:29:23 <jfredett> well- thats actually how I got into the trunk-tip problem in the first place
15:29:52 <jfredett> i'll just have to deal with the ugliness of reversing first
15:29:52 <Cale> Perhaps describe the wider problem a little?
15:30:11 <jfredett> sure, I'll paste some stuff, hang on
15:30:16 <LoganCapaldo> I do make sense to some people in here right? :)
15:30:24 <LoganCapaldo> I'm not crazy or anything
15:30:30 <Cale> LoganCapaldo: yes, what you're saying makes sense
15:42:09 <Mr_Awesome> Couldn't match expected type `v' (a rigid variable) against inferred type `VectorL'. Expected type: [v a] -> [v a] Inferred type: [VectorL b] -> [VectorL b]. i get this error even though VectorL is an instance of Vector, and v is declared Vector v => etc...
15:42:56 <mauke> something restricts the type to VectorL
15:43:46 <Mr_Awesome> but if VectorL is an instance of Vector, shouldnt Vector v => v and VectorL be interchangeable?
15:44:02 <mauke> no
15:44:40 <mauke> [a] is an instance of Functor, but that doesn't make [a] and Functor x => x interchangeable
15:44:48 <hpaste>  jfredett pasted "trunk-tip/head-tail PE problem 18, you've been warned" at http://hpaste.org/323
15:44:52 <mauke> e.g. length (Just 42) is an error
15:45:00 <Mr_Awesome> mauke: ok, i think i get it
15:45:00 <jfredett> thats the stuff I'm working on right now
15:45:51 <mauke> > let foo :: Functor f => f a -> Int; foo x = length x in foo
15:45:52 <lambdabot>   [a]
15:45:52 <lambdabot>       Inferred type: f a1
16:02:45 <Mr_Awesome> if the you have type GLfloat = Float, and GLfloat is an instance of the class VertexComponent, will Float's also work where VertexComponents are expected?
16:03:18 * fasta opens a ps file with The Gimp and gets a file of resoution 8500x10000....
16:03:43 <Saizan> mmh well it would, but you can't use type synonyms in instances declarations in haskell 98
16:03:46 <fasta> But it works :)
16:03:55 <Saizan> you'll need -fglasgow-exts
16:03:58 <fasta> @karma gimp++
16:03:59 <lambdabot> gimp++ has a karma of 0
16:04:05 <fasta> @karma+ gimp
16:04:05 <lambdabot> gimp's karma raised to 1.
16:04:13 <LoganCapaldo> @dharma gimp
16:04:13 <lambdabot> gimp has a karma of 1
16:04:17 <LoganCapaldo> hey
16:04:27 <LoganCapaldo> those aren't the same things
16:04:44 <fasta> LoganCapaldo: lambdabot has a simple algorithm for that
16:05:05 <fasta> LoganCapaldo: it's the same as dict uses.
16:05:41 <mauke> @kwote
16:05:41 <lambdabot> Maybe you meant: quote vote
16:06:11 <Sam__> @spell dharma
16:06:37 <oerjan> @list dharma
16:06:37 <lambdabot> No module "dharma" loaded
16:06:47 <oerjan> @kuote
16:06:48 <lambdabot> DukeDave says: what, if your kids start doing drugs? or worse, business school
16:06:49 <Sam__> @kwuot
16:06:49 <lambdabot> Unknown command, try @list
16:06:53 <Sam__> @kwuote
16:06:53 <lambdabot> sebazzz says: <sebazzz> vos no te diste cuenta, pero cuando estas en pedo, y si yo estoy, te saco del alcanse todo objeto contundente
16:07:22 <LoganCapaldo> @kwute
16:07:23 <lambdabot> Unknown command, try @list
16:07:37 <oerjan> @quota
16:07:37 <lambdabot> <skew> says: also, if you use ST you know the code is just using mutable variables, rather than formatting your hard drive
16:07:55 <LoganCapaldo> @quant
16:07:55 <lambdabot> Not enough privileges
16:08:02 <LoganCapaldo> ...
16:08:07 <oerjan> @quorte
16:08:07 <lambdabot> sm says: sms my kybad s stll akng
16:08:17 <LoganCapaldo> @quart
16:08:17 <lambdabot> Maybe you meant: part quit
16:08:28 <oerjan> @quoe
16:08:28 <lambdabot> knuth says: We will perhaps eventually be writing only small modules which are identified by name as they are used to build larger ones, so that devices like indentation, rather than delimiters,
16:08:28 <lambdabot> might become feasible for expressing local structure in the source language. ["Structured Programming with goto Statements", Computing Surveys, Vol 6 No 4, Dec. 1974]
16:08:51 <LoganCapaldo> LOL
16:09:10 <LoganCapaldo> awesome quote
16:11:08 <LoganCapaldo> > "2" ++ "2"
16:11:10 <lambdabot>  "22"
16:11:35 <Botje> > map length $ group $ fix show
16:11:41 <lambdabot> Terminated
16:11:45 <Botje> boo :[
16:11:49 <mauke> > join (++) "2"
16:11:50 <lambdabot>  "22"
16:12:07 <LoganCapaldo> > "2" ** "2"
16:12:08 <lambdabot>   add an instance declaration for (Floating [Char])
16:12:08 <lambdabot>     In the expression: "2...
16:12:30 <dolio> > group . fix $ show
16:12:31 <lambdabot>  ["\"","\\","\"","\\\\\\","\"","\\\\\\\\\\\\\\","\"","\\\\\\\\\\\\\\\\\\\\\\\...
16:13:10 <dolio> > (group $ fix show) !! 6
16:13:12 <lambdabot>  "\""
16:13:33 <dolio> > (map length . group $ fix show) !! 9
16:13:34 <lambdabot>  31
16:13:52 <xho> hello
16:14:29 <LoganCapaldo> > (map length . group $ fix show) !! 8
16:14:29 <lambdabot>  Illegal character ''\SI''
16:14:48 <LoganCapaldo> > (map length . group $ fix show) !! 8
16:14:49 <lambdabot>  1
16:14:57 <LoganCapaldo> > (map length . group $ fix show) !! 7
16:14:58 <lambdabot>  15
16:15:05 <LoganCapaldo> > (map length . group $ fix show) !! 6
16:15:07 <lambdabot>  1
16:15:17 <oerjan> @type join (++)
16:15:19 <lambdabot> forall a. [a] -> [a]
16:15:55 <LoganCapaldo> > [ (map length . group $ fix show) !! x | x <- [1..10] ]
16:15:56 <lambdabot>  [1,1,3,1,7,1,15,1,31,1]
16:16:05 <LoganCapaldo> > [ (map length . group $ fix show) !! x | x <- [1..25] ]
16:16:07 <lambdabot>  [1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191]
16:16:17 <ari> (fix show) is scary in a way
16:16:20 <dolio> > (map length . group $ fix show) !! 45
16:16:21 <oerjan> >fix show
16:16:26 <lambdabot> Terminated
16:16:36 <LoganCapaldo> fasciating pattern
16:16:38 <oerjan> > fix show
16:16:39 <lambdabot>  "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\...
16:17:01 <mauke>  > take 30 . map length . group $ fix show
16:17:06 <mauke> > take 30 . map length . group $ fix show
16:17:07 <lambdabot>  [1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,...
16:17:59 <dolio> > 2^23 - 1
16:18:01 <lambdabot>  8388607
16:18:36 <oerjan> > fix (show . (' ':))
16:18:38 <lambdabot>  "\" \\\" \\\\\\\" \\\\\\\\\\\\\\\" \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\" \\\\\\\\...
16:20:00 <oerjan> > fix (show . ('"':))
16:20:01 <lambdabot>  "\"\\\"\\\"\\\\\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\...
16:20:26 <oerjan> > fix (show . ('\\':))
16:20:27 <lambdabot>  "\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\...
16:22:10 <oerjan> > fix (show . intersperse '"')
16:22:11 <lambdabot>  Exception: <<loop>>
16:23:06 <oerjan> > fix (show . intersperse ' ')
16:23:07 <lambdabot>  Exception: <<loop>>
16:23:23 <fasta> There should be a rule for not showing of a cool trick more than once.
16:25:05 <mauke> > fix (const ":o")
16:25:06 <lambdabot>  ":o"
16:25:30 <oerjan> > fix (concatMap show)
16:25:32 <lambdabot>  Exception: <<loop>>
16:26:09 <oerjan> bah
16:26:12 <sjanssen> @v
16:26:12 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
16:30:55 <oerjan> @type fix fix
16:30:58 <lambdabot>     Occurs check: cannot construct the infinite type: a = a -> a
16:30:58 <lambdabot>     Probable cause: `fix' is applied to too many arguments
16:33:24 <ddarius> > intersperse 1 . map (subtract 1) . iterate (2*) 1
16:33:24 <lambdabot>  Couldn't match expected type `a -> [t]'
16:33:31 <ddarius> > intersperse 1 . map (subtract 1) $ iterate (2*) 1
16:33:32 <lambdabot>  [0,1,1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,...
16:33:46 <ddarius> > intersperse 1 . map (subtract 1) $ iterate (2*) 2
16:33:47 <lambdabot>  [1,1,3,1,7,1,15,1,31,1,63,1,127,1,255,1,511,1,1023,1,2047,1,4095,1,8191,1,16...
16:38:55 <dons> moin
16:44:51 <dons> ?uptime
16:44:51 <lambdabot> uptime: 3d 18h 46m 37s, longest uptime: 1m 10d 23h 44m 29s
16:44:52 <dons> ?users
16:44:52 <lambdabot> Maximum users seen in #haskell: 333, currently: 297 (89.2%), active: 49 (16.5%)
16:48:23 <dons> anyone applying to do the PhD on refactoring at Oxford? :-)
16:49:12 <sorear> hi dons.
16:49:29 <notadev> m00
16:49:41 <dons> i love apfelmus' mails. he's rather witty
16:49:47 <dons>  Trie it is,
16:49:48 <dons>  not balanced tree.
16:49:48 <dons>  A logarithm in this
16:49:48 <dons>  would be new to me.
16:52:05 <fasta> @moo
16:52:05 <lambdabot> Maybe you meant: map more msg todo yow
16:52:27 <notadev> lol
16:53:35 <sorear> ha.
16:53:47 <sorear> looking up information on parser theory, and...
16:53:55 <sorear>   From:         bromage@cs.mu.OZ.AU (Andrew Bromage)
16:56:16 <dmhouse> ?
16:57:38 <sorear>  /whois Pseudonym
16:57:39 <dons> hehe
16:57:52 <dons> and the nice old school oz.au domain too
16:59:26 <chessguy> 'evening
16:59:53 <wchogg> Good evening, Mr. Chessguy.
17:00:13 <chessguy> wow, so formal :)
17:01:09 <LoganCapaldo> Also prefixing Mr. makes teh guy bit redundant doesn't it?
17:01:13 <dons> Mr. Chessguy, 'evening sir. Can I take your hat and coat?
17:01:53 <chessguy> Mr. Chessguy is my dad. you guys can just call me chessguy
17:02:27 <dons> Very good, Sir.
17:02:35 <sorear> @remember chessguy Mr. Chessguy is my dad. you guys can just call me chessgu
17:02:35 <lambdabot> Done.
17:02:50 <LoganCapaldo> chessgu
17:02:51 <sorear> must... not... attribute... to... cheeseguy...
17:03:06 <LoganCapaldo> the y fell off
17:03:12 <dons> heh
17:04:32 <dons> http://programming.reddit.com/info/1zfw1/details
17:04:33 <lambdabot> Title: Category Theory and the category of Haskell programs (reddit.com)
17:05:08 <LoganCapaldo> I like the christmasy color scheme :)
17:05:53 <xho> ...
17:06:46 <sorear> xho: Hi?
17:07:01 <xho> sup?
17:07:17 <LoganCapaldo> "..than f is epic".
17:07:19 <LoganCapaldo> AWESOME
17:07:24 <LoganCapaldo> epic functions!
17:07:34 <LoganCapaldo> Math just got 2x as cool
17:07:54 <lpz> hi all
17:08:11 <lpz> is anybody here?
17:08:17 <sorear> 300-odd
17:08:22 <LoganCapaldo> I think I'm gonna have to read this article at least 5 times
17:08:29 <LoganCapaldo> lpz: No
17:08:38 <lpz> aw ok
17:08:45 <sorear> @users
17:08:45 <lambdabot> Maximum users seen in #haskell: 333, currently: 295 (88.6%), active: 53 (18.0%)
17:08:54 <lpz> so how about someone links me to a good haskell tutorial
17:09:12 <sorear> @remember lpz [addressing 295 people in #haskell] Is anybody here?
17:09:12 <lambdabot> Done.
17:09:12 <ddarius> LoganCapaldo: Start reading "Toposes, Triples, and Theories"
17:09:45 <Saizan> @where wikibook
17:09:45 <lambdabot> http://en.wikibooks.org/wiki/Haskell
17:09:49 <lpz> i need some help with compositions
17:10:02 <lpz> ok
17:10:03 <Saizan> lpz  ^^
17:10:19 <Saizan> if you have any question feel free to ask
17:10:24 <lpz> ok
17:10:37 <lpz> the problem is the following:
17:10:59 <LoganCapaldo> "A object which is initial and terminal is called the Zero object." best sentence ever.
17:11:11 <sorear> lpz: ?
17:11:22 <lpz> i need to make a function that given a list of functions and a int value, it returns the result of applying all the functions to the number
17:11:34 <ddarius> LoganCapaldo: Except that it is inconsistent.
17:11:35 <lpz> i can't figure it out yeyt
17:11:51 <sorear> > map ($ 4) [ negate, recip, (*2) ]
17:11:52 <lambdabot>  [-4.0,0.25,8.0]
17:11:56 <sorear> lpz: ^^^
17:12:04 <dons> the fold of that, i think
17:12:05 <lpz> those functions are in the prelude?
17:12:14 <sorear> yeah.
17:12:23 <lpz> is there another way to do it using composition?
17:12:24 <xho> anyone interested in joining my web chat written in haskell? if so please msg me for the url
17:13:00 <oerjan> @pl \l i -> map ($ i) l
17:13:01 <lambdabot> flip (map . flip id)
17:13:10 <LoganCapaldo> > foldr1 (.) [ negate, recip (*2) ] $ 4
17:13:10 <dons> > foldl (\i f -> f i) 4 [ negate, recip, (*2) ]
17:13:11 <lambdabot>   add an instance declaration for (Fractional (a -> a))
17:13:11 <lambdabot>     In the expression...
17:13:12 <lambdabot>  -0.5
17:13:31 <LoganCapaldo> > foldr1 (.) [ negate, recip, (*2) ] $ 4
17:13:33 <lambdabot>  -0.125
17:13:41 <sorear> lpz: do you want one number or a list?
17:13:42 <dons> > foldl (.) id [ negate, recip, (*2) ] $ 4
17:13:43 <lambdabot>  -0.125
17:13:50 <lpz> one number
17:13:59 <LoganCapaldo> dons: right. id good choice
17:14:00 <lpz> i thought it could be done simpler.. i'll try that tho
17:14:03 <dons> so you fold over the list of functions, accumulating the result, as above.
17:14:14 <dons> or write it as:  f . g . h . i $ 4
17:14:28 <lpz> yes but theres a list of functions..
17:14:30 <dons> > negate . recip . (*2) $ 4
17:14:31 <lambdabot>  -0.125
17:14:34 <ddarius> simpler than foldl (.) id ?!
17:14:37 <dons> is the expanded form of the list fold
17:14:49 <shachaf> > sequence [negate, recip, (*2)] 4
17:14:49 <lambdabot> Terminated
17:14:58 <dons> Prelude.sequence
17:15:02 <dons> (sorry!)
17:15:12 <shachaf> > P.sequence [negate, recip, (*2)] 4
17:15:13 <lambdabot>  [-4.0,0.25,8.0]
17:15:30 <dons> shachaf wins a prize for first use of the reader monad today
17:15:33 <lpz> does that bot interpret haskell code?
17:15:37 <ddarius> shacaf: That's the first one.
17:15:39 <ddarius> lpz: Yes.
17:15:43 <lpz> thats cool
17:15:45 <dons> lpz, yeah, (actually, it compiles it)
17:15:45 <ddarius> Among other thing.s
17:15:50 <shachaf> dons: I didn't come up with that, actually.
17:15:56 <lpz> let me try something
17:16:20 <fasta> newbie tries to do rm -rf
17:16:28 <fasta> and fails miserably
17:16:28 <dons> heh
17:16:34 <lpz> whot
17:16:35 <dons> damn you IO !
17:16:48 <xho> hey dons want to see a cool webchat coded in haskell?
17:16:53 <dons> > readFile "/etc/passwd"
17:16:54 <lambdabot>  <IO [Char]>
17:17:00 <fasta> Haskell takes all the fun out of owning other peoples machines!
17:17:01 <dons> xho: sure, where's the src?
17:17:03 <lpz> map (*3) [1,2,3]
17:17:10 <dons> > map (*3) [1,2,3]
17:17:11 <lambdabot>  [3,6,9]
17:17:17 <dons> > map (*3) [1..]
17:17:18 <lambdabot>  [3,6,9,12,15,18,21,24,27,30,33,36,39,42,45,48,51,54,57,60,63,66,69,72,75,78,...
17:17:23 <xho> dons: i'll give you the url of the darcs repos in the chatroom ;)
17:17:34 <dons> you should just dump it here :-)
17:17:43 <dons> since i'm sure everyone's interested.
17:17:53 <xho> dons: it's not ready for public announcement yet... a few more days
17:19:11 <lpz>  foldr1 (.) [ negate, recip (*2) ] $ 4
17:19:16 <lpz> foldr1 (.) [ negate, recip (*2) ] $ 4
17:19:24 <sorear> lpz: you *need* the >
17:19:27 <dons> use a leading '> '
17:19:35 <lpz> >foldr1 (.) [ negate, recip (*2) ] $ 4
17:19:39 <sorear> > foldr1 (.) [ negate, recip, (*2) ] $ 4
17:19:40 <lambdabot>  -0.125
17:19:43 <dons> to tell the bot its code, in amongst all the conversations
17:19:44 <sorear> lpz: '> '
17:19:51 <sorear> lpz: not '>'
17:20:00 <lpz> > foldr1 (.) [ negate, recip (*2) ] $ 4
17:20:01 <lambdabot>   add an instance declaration for (Fractional (a -> a))
17:20:01 <lambdabot>     In the expression...
17:20:03 <dons> lambdabot evaluates the channel as 'Bird' style literate code, fwiw
17:20:09 <dons> missing ,
17:20:15 <shachaf> lpz: You're missing a comma.
17:20:33 <lpz> :S
17:20:52 <shachaf> lpz: "recip, (*2)"
17:21:01 <dons> > foldr1 (.) [ negate, recip, (*2) ] $ 4
17:21:02 <lambdabot>  -0.125
17:21:27 <lpz> thanks
17:21:47 <sorear> Pseudonym: Are there any good non-dead-tree introductions to parser theory?
17:22:08 <dons> sorear: you'll have to ask for the dragon book for your birthday :-)
17:22:35 <shachaf> > foldr (.) id [negate, recip, (*2)] 4 -- Why not this?
17:22:36 <lambdabot>  -0.125
17:22:41 * sorear is trying to avoid learning how to ask for stuff
17:22:44 <fasta> sorear: where did you learn about how GHC currently works? If it's still the STG architecture, you just read that rather long paper about it?
17:23:00 <dons> sorear: dragon book is likely in your local university library?
17:23:04 * ddarius has mastered that skill.
17:23:05 <lpz> but if i need to write a function that does the same thing as foldr1.. how would that be? create a function that does a foldr1?
17:23:33 <oerjan> @src foldr1
17:23:33 <lambdabot> foldr1 _ [x]    = x
17:23:33 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:23:33 <lambdabot> foldr1 _ []     = undefined
17:23:33 <Serge`> @src foldr1
17:23:34 <lambdabot> foldr1 _ [x]    = x
17:23:34 <lambdabot> foldr1 f (x:xs) = f x (foldr1 f xs)
17:23:35 <lambdabot> foldr1 _ []     = undefined
17:23:39 <dons> you'd write a recursive loop, yep, with an accumulating parameter
17:23:47 <dons> ?src foldr
17:23:47 <lambdabot> foldr k z xs = go xs
17:23:47 <lambdabot>     where go []     = z
17:23:47 <lambdabot>           go (y:ys) = y `k` go ys
17:23:50 <sorear> fasta: That paper, Simon's 500 page book "The implementation of functional programming languages", and the papers on the wiki research papers section, and the commentary
17:24:35 * fasta has 26 terminals open :/
17:24:39 <lpz> this is heaven haha
17:24:57 <fasta> heaven? More like hell ;)
17:25:08 <ddarius> lpz: Wait 'til you see the crazy stuff.
17:25:13 <lpz> i started this course at university not long ago and we have to learn 3 different styles of programming in so little time: objects, functional and logic
17:25:15 <LoganCapaldo> @type foldr (.) id [read, show] -- problem with the folding . over a list approach
17:25:17 <lambdabot> String -> String
17:25:37 <LoganCapaldo> @type foldr (.) id [(+1), read, show] -- problem with the folding . over a list approach
17:25:39 <lambdabot>     No instance for (Num String)
17:25:39 <lambdabot>       arising from the literal `1' at <interactive>:1:16
17:25:51 <dons> lpz, ok. cool. foldr (with functions) is characteristic of the functional style :-)
17:25:53 <sorear> there's a difference?
17:26:02 <lpz> but we're not seeing the whole lenguage, we're focusing more on the functional side of the language
17:26:10 <LoganCapaldo> > (+1) . read . show $ 3
17:26:11 <lambdabot>  4
17:26:12 <monochrom> I also think it's a disservice to any paradigm to cramp 3 paradigms into one school term or semester.
17:26:57 <lpz> i'm having problems with this one.. functional.. object was not hard
17:26:58 * int80_h hugs room
17:27:19 <lpz> i'll check that foldr1 src out.. brb
17:27:20 <sorear> object not hard?
17:27:23 <fasta> int80_h: what's the _h for?
17:27:29 <sorear> fasta: hex
17:27:34 <lpz> at least it didn't take me longer to understand than functional
17:27:47 <monochrom> object is very hard. just that no one asked you the hard questions. example: multiple inheritance good or bad, how to do it properly?
17:27:47 <sorear> fasta: 80h is nasm syntax for 128
17:28:09 <monochrom> That allow is easily severall PhD theses.
17:28:13 <monochrom> s/allow/alone/
17:28:21 <sorear> fasta: interrupt vector 128 is reserved for supervisor calls on linux x86 (and most other nixen)
17:28:22 <fasta> I thought int80 was some part of a calling convention for some OS.
17:28:37 <lpz> mmm...
17:28:48 <lpz> i think we didn't make use of multiple inheritance in this course
17:29:05 <monochrom> see? it's hard, just that no one showed you the hard part.
17:29:17 <lpz> ur right.. the course is just not "complete"
17:29:28 <fasta> @where You
17:29:28 <lambdabot> I know nothing about you.
17:29:32 <fasta> @what You
17:29:32 <lambdabot> I know nothing about you.
17:29:36 <fasta> @what u
17:29:36 <lambdabot> I know nothing about u.
17:29:38 * Pseudonym thinks the estate tax should apply to multiple inheritance
17:29:39 <fasta> @where u
17:29:39 <lambdabot> I know nothing about u.
17:30:33 <Pseudonym> @seen a_purple_cow
17:30:33 <lambdabot> I haven't seen a_purple_cow.
17:30:51 <LoganCapaldo> Metaphorically, before you get to the computer program part, multiple inheritance makes sense. I have 2 parents after all :)
17:30:52 <fasta> monochrom: would the answer to "how to.. properly" be, Oleg's answer?
17:31:00 <notadev> hehe
17:31:12 <slowriot> I'm trying to hide the >>^ operator when I import. What is the correct syntax for that?
17:31:21 <sorear> hiding ((>>^))
17:31:25 <slowriot> thanks
17:31:26 <LoganCapaldo> import Foo hiding ( (>>^) )
17:31:29 <shachaf> slowriot: import Module hiding ((>>^))
17:31:38 <fasta> @stereo
17:31:38 <lambdabot> Unknown command, try @list
17:31:42 <fasta> @where stereo
17:31:42 <lambdabot> I know nothing about stereo.
17:31:48 <fasta> @quote stereo
17:31:48 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:31:56 <LoganCapaldo> the stereo quote has been updated to its own command now? :)
17:32:03 <fasta> LoganCapaldo: no
17:32:05 <LoganCapaldo> s/updated/upgraded/
17:32:14 <monochrom> I don't know whether anyone knows the answer. But oleg's are most likely good.
17:32:22 <slowriot> one set of parenthesis because it's infix... the other because parentheses are part of the 'hiding' syntax?
17:32:27 <nominolo> obviously not (yet)
17:32:32 <LoganCapaldo> slowriot: exactly
17:33:20 * LoganCapaldo builds mplayer and watches horrible warnings scroll by
17:34:08 <c> they should add some GPL-violation warnings to round out the fun..
17:34:30 <LoganCapaldo> Wheres the Haskell video player at?
17:34:37 <LoganCapaldo> I need it to go with XMonad
17:34:42 <fasta> LoganCapaldo: it plays 1 fps </troll>
17:35:04 <monochrom> that is better than 0.7 fps.
17:35:30 <xho> guys check out haskell powered web chat: http://feld.sh.nu:2000/
17:35:34 <LoganCapaldo> well 1fps is fine if that's what the video specifies :)
17:36:14 <sorear> Seen on #happs:
17:36:26 <sorear> 17:32 < xho> yeah, it's not the bandwidth i worry about though, it's the torture one must endure with each line of js that one writes :'(
17:36:29 <sorear> 17:32 < xho> if yhc compilation to javascript is the real deal, then there is a god
17:36:33 <lpz> so the common functions are all in the prelude right?
17:36:39 <sorear> lpz: most of them
17:37:02 <Pseudonym> Or if not a god, then at least a compiler writer.
17:37:07 <fasta> xho: seems to work
17:38:23 <notadev> lol
17:38:46 <ddarius> BYOG
17:39:02 <Excedrin> does yhc generated javascript depend on browser specific features?
17:39:18 <xho> i've heard that it doesn't work in safari
17:46:57 <sorear> allbery_b: is KF8NH a callsign?
17:47:05 <sorear> (OOC)
17:47:44 <emu> sounds like one
17:48:03 <emu> advanced class, some state out west
17:48:38 <sorear> well KC5TJA is 1 letter longer, and I guessed they were fixed length like automobile license "numbers"
17:48:49 <emu> no it depends on your class
17:48:58 <emu> shorter = higher level
17:49:06 * sorear does not actually know much about this stuff
17:50:28 <allbery_b> yep.  advanced
17:52:17 <allbery_b> ==emu although the extra class 4-character calls overflowed into the advanced space some time back, and in many zones overflowed the AA-AK prefix space as well and started using regular advanced-class calls.
17:52:25 <emu> yea and advanced doesn't exist anymore
17:52:25 <allbery_b> (then they rewired the system completely...)
17:52:33 <slowriot> I have a haskell project that was coded in an older version of ghc. It imports IOExts. How should I deal with this?
17:52:51 <slowriot> I tried searching for IOExts on haskell.org, but found nothing.
17:52:54 <dons> change it to import System.IO
17:52:57 <allbery_b> yeh, I'm grandfathered.  maybe someday I'll take the new theory and upgrade the rest of the way
17:52:57 <slowriot> okay
17:53:12 <emu> same
17:54:33 <allbery_b> although to be honest it wasn't the code holding me back --- I've always done lousy on the extra theory exams
17:54:52 <emu> i couldnt do 20wpm
17:55:36 <allbery_b> back when I was in NCARC (Lake County OH) they had a Morse speed-copying trial one meeting, I could copy up to 23wpm fairly well
17:56:07 <sorear> slowriot: IOExts is a lot of stuff actually, we can't say what the module should be without a symbol
17:56:15 <allbery_b> ...but I never mastered recognizing whole words directly, which is what you really need to copy fast code
17:57:23 <slowriot> it imports a few symbols. I think a lot of them are in IORef
17:57:29 <slowriot> where's unsafePerformIO?
17:57:50 <shachaf> @index unsafePerformIO
17:57:50 <lambdabot> System.IO.Unsafe, Foreign
17:57:50 <dons> that's in System.IO.Unsafe
17:58:00 <slowriot> okay
17:58:02 <dons> you can use @index or @hoogle to find the locations of missing functions
17:58:07 <dons> ?hoogle unsafePerformIO
17:58:08 <lambdabot> Foreign.unsafePerformIO :: IO a -> a
17:58:12 <dons> also there.
17:58:29 <slowriot> okay, index or hoogle
17:59:24 <lpz> i have another question.. and a stupid one :S
17:59:57 <oerjan> shoot
18:00:40 <lpz> when theres one or more variables that are not used in one line, for example: null (_:_)   = False .. is it neccesary to code it this way: null (x:xs) = False?
18:01:01 <sjanssen> lpz: both are valid
18:01:19 <shachaf> > let x (_:_) = False in x [1,2]
18:01:20 <LoganCapaldo> lpz: nope, _ is a wildcard, not a binding so its ok to have multiple _ in the same pattern
18:01:20 <lambdabot>  False
18:01:46 <lpz> ok thanks
18:01:50 <oerjan> no, _ is the usual one. in fact compilers may warn you if you name an unused variable something not starting with _
18:02:25 <shachaf> oerjan: Starting with _?
18:02:32 <shachaf> > let x (_xyzzy:_xyzzy) = False in x [1,2]
18:02:32 <lambdabot>      Conflicting definitions for `_xyzzy'
18:02:32 <lambdabot>     In the definition of `x'
18:02:36 <shachaf> Hmm.
18:02:54 <joao_costa> :t ~
18:02:57 <lambdabot> parse error (possibly incorrect indentation)
18:03:04 <oerjan> well only _ itself is duplicated, _something is if you want to name it even if it is unused
18:03:10 <oerjan> *can be
18:03:12 <dons> joao_costa: as in f ~(x,y) ?
18:03:21 <dons> (its a lazy pattern bind)
18:03:21 <joao_costa> dons, yes
18:03:31 <joao_costa> i was trying to understand the meaning of that
18:03:35 <LoganCapaldo> and it's irrefutable!
18:03:44 <dons> > let f Nothing = 7 in f (Just 2)
18:03:45 <lambdabot>   Non-exhaustive patterns in function f
18:03:48 <dons> > let f ~Nothing = 7 in f (Just 2)
18:03:50 <lambdabot>  7
18:04:03 <dons> since the pattern isn't required to be matched in 'f' (its not used in the body)
18:04:30 <dons> > let f ~(Just x) = x in f (Just 2)
18:04:31 <lambdabot>  2
18:04:31 <notadev> could someone please tell me what 'show' is for?
18:04:35 <dons> > let f (Just x) = x in f (Just 2)
18:04:36 <lambdabot>  2
18:04:40 <dons> notadev: printing a value into a string
18:04:46 <dons> like sprintf, but for arbitrary types
18:04:46 <notadev> ah ok thanks
18:04:50 <allbery_b> hm, actually I was accurate up to 23wpm and got >75% up to 33wpm or thereabouts, IIRC
18:04:54 <notadev> hmm lovely :)
18:04:57 <dons> > show (1,2,'x')
18:04:58 <lambdabot>  "(1,2,'x')"
18:04:58 <allbery_b> in any case the code wasn;t what held me back in any sense
18:05:03 <joao_costa> dons, so when is that usefull?
18:05:08 * araujo wonders if anyone would have a server with some free space to share with a darc repo
18:05:26 <sorear> joao_costa: it improves laziness sometimes
18:05:42 <dons> joao_costa: rarely. it does help increase sharing, so for example, its used in unzip.
18:05:46 <dons> unzip4                  =  foldr (\(a,b,c,d) ~(as,bs,cs,ds) ->
18:05:48 <dons>                                         (a:as,b:bs,c:cs,d:ds))
18:05:48 <lpz> laziness has something to do with infinite lists right?
18:05:50 <dons>                                  ([],[],[],[])
18:05:59 <dons> araujo! we have the code.haskell.org server now
18:06:11 <sorear> dons: that's not the reason it is used in unzip, the no-~ versions shares fine
18:06:12 <dons> lpz, sort of. infinite lists can be achieved, by using laziness
18:06:17 <joao_costa> ok, so it is one of those 'use-carefully' features, right?
18:06:25 <sorear> dons: its just too strict - no-~ unzip won't work on infinite lists
18:06:31 <araujo> dons, i have a haskell.org account .... the thing is, that it is non haskell code :-|
18:07:08 <dons> sorear: i've not had my coffee yet, but there's also an issue with sharing, last time I thought about it. (but that was writing the streams fusion, so i might have the details lost)
18:07:17 * joao_costa goes to the books
18:08:10 <dons> one of the few other places I know of it being used is in the arrows code,
18:08:10 <dons> (***) f g ~(x,y) = (f x, g y)
18:08:19 <dons> first (Kleisli f) = Kleisli (\ ~(b,d) -> f b >>= \c -> return (c,d))
18:08:57 <Saizan> that's like using fst and snd on the tuple, i think
18:12:28 <lpz> i'm having a look at the prelude, the (++) operator exactly.. and there seems to be an operator on the left side of one of the lines: []     ++ ys      = ys...  shouldn't there be only variables there?
18:12:45 <lpz> sorry for the dumb questions, but that just called my attention
18:13:32 <dons> ?src (++)
18:13:32 <lambdabot> (++) []     ys = ys
18:13:32 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
18:13:46 <lpz> i have this:
18:13:49 <lpz> (++)             :: [a] -> [a] -> [a]
18:13:50 <lpz> []     ++ ys      = ys
18:13:50 <lpz> (x:xs) ++ ys      = x : (xs ++ ys)
18:14:29 <allbery_b> yes, so?
18:14:29 <lpz> its sorta the same
18:14:47 <allbery_b> you caj define functions in operator syntax as well as function syntax
18:14:51 <allbery_b> the two are equivalent
18:14:58 <lpz> ah.. sorta like 3 'mod' 4 and mod 3 4
18:15:15 <Igloo> Right
18:15:15 <shachaf> lpz: Except with ``.
18:15:27 <lpz> yes, i know.. i just couldn't find that one symbol
18:15:58 <shachaf> lpz: Not underneath Esc?
18:16:14 <lpz> `mod´
18:16:18 <lpz> ´´
18:16:24 <lpz> no, but somewhere else
18:16:42 <lpz> ``
18:16:50 <allbery_b> yeh, that
18:16:59 <shachaf> > 3 `mod` 4
18:17:00 <lambdabot>  3
18:17:06 <lpz> mod 3 4
18:17:09 <lpz> > mod 3 4
18:17:10 <lambdabot>  3
18:25:08 <slowriot> how exactly does ghc search for the modules that you try to import?
18:26:22 <emu> it looks in the current dir, and also under dir subtrees corresponding to the hierarchical names
18:26:29 <dons> it looks in its package database, too.
18:26:35 <emu> and those specified with -i
18:26:38 <dons> so it can find modules in packages known via $ ghc-pkg list
18:26:48 <slowriot> okay
18:26:55 <notsmack> it looks in a surprising number of places
18:27:02 <dons> check the ghc user's guide for more details
18:27:10 <slowriot> package.conf has all the legal packages?
18:27:18 <slowriot> yeah, I should do that
18:33:02 <slowriot> does ghc only need a .hi file to import a module?
18:33:38 <dons> yep
18:33:49 <dons> well, it needs the .o if you ever want to link against it
18:33:56 <dons> but to just import it, the .hi file is sufficient
18:34:15 <slowriot> hm... okay
18:39:09 <slowriot> odd. I am using -idir, the .o and .hi files are in dir, and ghc still can't find the module
18:41:16 <slowriot> oh wait
18:51:46 <chad> dons: if yo'ure around, could you post your nice status script for dzen? :D
18:51:54 <dons> hehe
18:52:04 <dons> that's XMonadContrib.DynamicLog.hs
18:52:17 <dons> its a logHook in Config.hs (you mean the one that numbers workspaces:   1 [2] 3 4 ?
18:52:43 <dons> or do you mean the date/load avg one?
18:53:35 <chadz> the dynamic display :D
18:54:00 <dons> you should drop by #xmonad :-)
18:54:03 <chadz> alright -- i'll take a look at that once i figure out how xinerama works. it's about time i ditch fglrx
18:54:06 <chadz> okies!
18:54:12 <dons> ok cool. let us know how you go
18:56:54 <int80_h> test
18:57:07 <Shimei> ?where x11
18:57:07 <lambdabot> I know nothing about x11.
18:57:19 <Shimei> ?where X11
18:57:19 <lambdabot> I know nothing about x11.
18:59:51 <dons> ?hackage X11
18:59:51 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/X11
18:59:52 <dons> ?
19:05:44 <ddarius> What is most of the code in multi MLOC programs?
19:07:29 <sjanssen> ddarius: bugs
19:07:42 <dons> mostly
19:07:50 <dons> boilerplate
19:07:59 <dons> misfeatures
19:08:01 <dons> stuff like that.
19:09:32 <notsmack> lots of dead code
19:10:32 <lpz_away> thanks everyone for the help
19:10:41 <sproingie> gigantic change-management comments that contain the entire life story of a function's code
19:10:42 <lpz_away> to*
19:11:21 <sproingie> how many LOC is ghc anyway?
19:11:41 <sorear> 30k I hear
19:11:43 * sorear runs wc
19:12:06 <sproingie> gosh, less than 100 KLOC, how could it possibly be enterprise-worthy?
19:12:38 <sproingie> let's see some more boilerplate, folks
19:12:45 <sorear> 165433
19:13:08 <sorear> that's every *.{,l}hs file in ghc proper
19:13:18 <sorear> not counting the rts or libs
19:15:51 <sorear> oh, the horror! :
19:16:00 <sorear>    It's much better to write code that is transparent, than to write code that is short.
19:16:04 <sorear>                                                                                                                                                                                                                     
19:16:09 <sorear>    Often it's better to write out the code longhand than to reuse a generic abstraction (not always, of course). Sometimes it's better to duplicate some similar code than to try to construct an elaborate
19:16:13 <sorear>    generalisation with only two instances. Remember: other people have to be able to quickly understand what you've done, and overuse of abstractions just serves to obscure the really tricky stuff, and there's
19:16:17 <sorear>    no shortage of that in GHC.
19:16:59 <dons> yeah, its around 100k of code.
19:17:03 <dons> gcc is around 1M
19:17:09 <dons> probably means its a better compiler :-)
19:17:36 <sorear> how big is tcc?
19:17:57 <dons> bit smaller
19:18:08 <dons> NYFP meetup, http://lisp.meetup.com/59/
19:18:09 <lambdabot> Title: The New York Functional Programmers Meetup Group (Brooklyn, NY) - Meetup.com
19:18:16 <dons> (typed programmers only! ;)
19:18:57 <chessguy> wow, a state-side haskell meeting
19:19:02 <sorear> no erlangers, lispers, etc?
19:19:45 <ddarius> chessguy: There has recently been a bunch of them.
19:19:48 <dons> The NYFP meetup is for people using or interested in strongly typed
19:19:48 <dons> functional languages, such as Haskell, Ocaml, SML, etc.
19:20:17 <slowriot> ?hoogle HGL.Event
19:20:18 <lambdabot> No matches, try a more general search
19:20:24 <dons> german meeting a few days later, http://iba-cg.de/haskell.html
19:20:26 <lambdabot> Title: ||: iba Consulting Gesellschaft - intelligent business architecture:||
19:21:08 <Philippa> sorear: I agree with that guideline where the abstraction in question isn't sufficiently obvious to a typical reader
19:21:48 <sorear> Philippa: Aren't abstractions *more* obvious than boilerplate?
19:22:18 * sorear is kinda suprised
19:22:19 <Philippa> not if you don't know the abstraction
19:23:03 <sorear> if you don't know the pattern how are youe expected to understand boilerplate?
19:23:11 <Philippa> in the concrete
19:23:21 <sjanssen> I suppose it depends on the pattern
19:23:31 <hpaste>  int80_h pasted "how to use someone else's parser" at http://hpaste.org/325
19:23:39 <Philippa> remember, readability when you see a single instance counts
19:24:05 <sjanssen> some pointfree patterns are a bit obscure
19:24:11 <Philippa> sjanssen: right. If it's sufficiently abstract that the typical reader can barely get their head around it, you're in trouble
19:24:44 <Philippa> especially if the reader /can/ get their head around a more concrete rendering
19:26:01 <sorear> Philippa: my math books reuse patterns, but cite typical instantiations to explain the abstraction.  why isn't that approach also best for programs?
19:26:24 <Philippa> it's not necessarily best when there're only two instantiations in use anyway
19:26:49 <Philippa> (I tend to generalise when I've got two instances and expect to see a third, FWIW)
19:28:04 <Philippa> fact is, fully explaining an abstraction takes time and you might not need to fully explain it for one or two instances - there may be properties that just aren't used, things like that
19:29:48 <chessguy> we need to abstract out abstraction
19:31:44 <ddarius> lambda!
19:32:07 <ddarius> Actually, that's what you do when you convert lambda terms to the combinatory algebra.
19:33:12 <Philippa> sorear: one guideline is "do I have a sufficiently descriptive and mnemonic name for this abstraction when I instantiate it?"
19:33:36 <Philippa> if you don't, and you only instantiate it a couple of times, then it's actually more mental work than not using it because the reader's just going to substitute the thing in
19:35:44 <xho> i see "a + b + c" pattern a few times... i should abstract it into an add3 function =]
19:36:05 <dons> hehe
19:36:07 <Philippa> sum [a,b,c]
19:36:41 <kmb> @pl (\a b -> (x a, y a))
19:36:42 <lambdabot> const . liftM2 (,) x y
19:36:47 <Philippa> but that's kinda the point really - people tend not to write the latter. That's only partly due to the 'ick' factor in introducing a list
19:36:59 <kmb> :t const
19:37:08 <lambdabot> forall a b. a -> b -> a
19:37:19 <Philippa> const k _ = k
19:37:59 <kmb> @pl (\a b -> (x a, y b))
19:37:59 <lambdabot> (. y) . (,) . x
19:38:29 <kmb> @pl (\a -> (x a, y a))
19:38:30 <lambdabot> liftM2 (,) x y
19:40:03 <ddarius> @. djinn type const
19:40:05 <lambdabot> f a _ = a
19:55:09 <LoganCapaldo> @src const
19:55:09 <lambdabot> const x _ = x
19:55:50 * LoganCapaldo rewrites @src to be @. djinn type
19:57:07 <sorear> @. djinn type on
19:57:09 <lambdabot> Cannot parse command
19:57:18 <sorear> @. djinn type Data.Function.on
19:57:20 <lambdabot> -- f cannot be realized.
19:57:27 <LoganCapaldo> boo
19:57:36 <sorear> @. djinn type comparing
19:57:40 <LoganCapaldo> @type Data.Function.on
19:57:42 <lambdabot> Couldn't find qualified module.
19:57:54 <ddarius> :t on
19:57:56 <lambdabot> Not in scope: `on'
19:58:00 <ddarius> :t Data.Function.on
19:58:02 <lambdabot> Couldn't find qualified module.
19:58:14 <sorear> @. djinn type map
19:58:16 <lambdabot> -- f cannot be realized.
19:58:27 <sorear> @. djinn type maybe
19:58:29 <lambdabot> f a b c =
19:58:29 <lambdabot>     case c of
19:58:29 <lambdabot>     Nothing -> a
19:58:29 <lambdabot>     Just d -> b d
19:58:50 <LoganCapaldo> nice
19:59:06 <LoganCapaldo> @src maybe
19:59:06 <lambdabot> maybe n _ Nothing  = n
19:59:06 <lambdabot> maybe _ f (Just x) = f x
19:59:33 <oerjan> @. djinn type P.map
19:59:35 <lambdabot> -- f cannot be realized.
19:59:41 <oerjan> @type P.map
19:59:41 <LoganCapaldo> @. djinn type either
19:59:43 <lambdabot> Couldn't find qualified module.
19:59:45 <lambdabot> f a b c =
19:59:45 <lambdabot>     case c of
19:59:45 <lambdabot>     Left d -> a d
19:59:45 <lambdabot>     Right e -> b e
19:59:46 <ddarius> djinn doesn't do recursive types.
19:59:53 <oerjan> @type map
19:59:55 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
20:00:16 <oerjan> @type maybe
20:00:18 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
20:01:13 <oerjan> @. djinn type (.)
20:01:16 <lambdabot> f a b c = a (b c)
20:01:19 <LoganCapaldo> @type either Right Left
20:01:21 <lambdabot> forall a b. Either a b -> Either b a
20:03:00 <LoganCapaldo> @type let eflip = either Right Left in eflip . eflip
20:03:03 <lambdabot> forall a b. Either a b -> Either a b
20:04:03 <LoganCapaldo> @type let eflip = either Right Left in fix eflip
20:04:05 <lambdabot> forall b. Either b b
20:04:42 <LoganCapaldo> @run let eflip = either Right Left in fix eflip
20:04:44 <lambdabot>  Exception: <<loop>>
20:05:05 * sorear prooves Kleene's Theorem!
20:05:06 <LoganCapaldo> I'm a little surprised it type checked
20:05:19 * sorear is having a good day
20:05:31 <sorear> @quote type.check
20:05:31 <lambdabot> dons says: disable the type checker in ghc for 6 months and we'd have 5 debuggers at the end of it :)
20:05:33 <sorear> @quote type.check
20:05:33 <lambdabot> metaperl says: if you type check every suitor, you are bound to find an inconsistency somewhere... just get in there and get it over with!
20:05:35 <sorear> @quote type.check
20:05:35 <lambdabot> dons says: the type system is *great* for coding while sleepy.. you just hack any garbage together, and let the type checker deal with it
20:05:39 <sorear> @quote type.checke
20:05:39 <lambdabot> scsibug says: i could have sworn it was incorrect until it type-checked
20:06:00 * SamB wonders how dons is expecting anyone to make a debugger with no typechecker
20:06:16 * SamB also wonders how typeclasses are able to work with no typechecker
20:06:22 <sorear> SamB: Duh, it would be integrated with the RTS
20:06:30 <SamB> which?
20:06:36 <sorear> fst
20:06:45 <sorear> so the debugger is in C-- :)
20:06:50 <SamB> ewwwwwww
20:06:58 <SamB> how would that even WORK?
20:09:31 <LoganCapaldo> How did that type check anyway?
20:09:37 <LoganCapaldo> mmm
20:10:57 <oerjan> LoganCapaldo: you took fix of something of type Either a b -> Either b a
20:11:03 <LoganCapaldo> intuitively it makes sense
20:11:27 <LoganCapaldo> but I can't figure out how it "proved" it, or whatever it does
20:11:47 <oerjan> @type fix
20:11:50 <lambdabot> forall a. (a -> a) -> a
20:12:01 <oerjan> @type either Right Left
20:12:04 <lambdabot> forall a b. Either a b -> Either b a
20:12:10 <SamB> @type fix (either Right Left)
20:12:12 <lambdabot> forall b. Either b b
20:12:18 <LoganCapaldo> oh I see
20:12:21 <SamB> see, it unifies the a and the b
20:12:23 <LoganCapaldo> it was all a red herring
20:12:44 <LoganCapaldo> it has everything to do with fix's type, and nothing to do with either Right Left
20:12:56 <misterPhyrePhox> hello
20:13:21 <misterPhyrePhox> can you use case .. of inside a do block?
20:13:28 <LoganCapaldo> of course
20:13:32 <misterPhyrePhox> i'm doing so inside a do block (in the State monad), but it won't work
20:13:41 <misterPhyrePhox> even if i do just _ -> trace "BLAH" $ return ()
20:13:46 <misterPhyrePhox> it doesn't print "BLAH" :(
20:13:47 <desp> $type and
20:13:51 <desp> @type and
20:13:53 <lambdabot> [Bool] -> Bool
20:13:58 <desp> @type (&&)
20:14:01 <lambdabot> Bool -> Bool -> Bool
20:14:04 <SamB> misterPhyrePhox: indent it a bit more
20:14:11 <SamB> emacs is not very smart :-(
20:14:41 <monochrom> if you pastebin, I offer to indent it
20:14:55 <misterPhyrePhox> i'm pretty sure i've got it indented right; i'm not getting any errors. the case .. of is on the same indentation level as the rest of the do block, and the pattern matching part is indented
20:14:56 <LoganCapaldo> @type foldr (&&) True
20:14:59 <lambdabot> [Bool] -> Bool
20:15:32 <misterPhyrePhox> oh wait
20:15:33 <oerjan> is the return () of type IO () ?
20:15:37 <misterPhyrePhox> no
20:15:40 <misterPhyrePhox> does trace only work with IO ()?
20:15:46 <oerjan> no
20:15:49 <monochrom> trace works anywhere
20:16:00 <misterPhyrePhox> and i just found out that if i comment out the last part of the function, the trace works fine
20:16:20 <oerjan> but if it were you could have tried putStr instead
20:16:35 <misterPhyrePhox> let me paste...
20:16:49 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/326
20:17:09 <misterPhyrePhox> what hpaste said :P, please take a look
20:18:40 <monochrom> which monad is this?
20:18:48 <misterPhyrePhox> run :: State Machine ()
20:19:05 <monochrom> Control.Monad.State.Strict? Control.Monad.State.Lazy?
20:19:16 <misterPhyrePhox> uh, i just imported Control.Monad.State
20:19:41 <monochrom> That re-imports Control.Monad.State.Lazy. That explains it.
20:20:01 <misterPhyrePhox> oh
20:20:03 <misterPhyrePhox> is it like
20:20:08 <misterPhyrePhox> because the trace thing isn't referenced by anything
20:20:11 <misterPhyrePhox> it is lazily evaluated?
20:20:16 <monochrom> In the Lazy version, wholesome actions are skipped if they don't contribute to state modification or final return value.
20:20:29 <misterPhyrePhox> oh, i see!
20:20:48 <misterPhyrePhox> so i'll use the Strict version while i'm debugging
20:21:02 <SamB> I always trace like this...
20:21:13 <misterPhyrePhox> would there be any reason to switch back to Lazy once i'm done with my trace tomfoolery? for my simple needs?
20:21:20 <SamB> trace "hi!" $ -- whatever code comes next
20:21:46 <SamB> or possibly:
20:21:50 <monochrom> That may still not help, SamB.
20:21:54 <SamB> trace "hi!" $ return ()
20:22:08 <misterPhyrePhox> yeah it works now
20:22:13 <SamB> monochrom: oh?
20:22:14 <lispy> okay, i want to become an expert of GADTs and exstentials, where do i start?
20:22:17 <misterPhyrePhox> thanks alot, monochrom!
20:22:33 <SamB> I didn't know that about .Lazy and .Strict
20:22:45 <SamB> I've been using .Lazy all this time with no troubles afaik
20:23:13 <dolio> They're pretty new.
20:23:26 <dolio> It used to be all lazy, I think.
20:23:31 <SamB> oh.
20:23:43 <SamB> so what is the point of the .Strict one?
20:23:57 <monochrom> Reduce thunk sizes.
20:24:18 <dolio> I've run into stack overflows due to state being too lazy in the past.
20:25:11 <monochrom> Exactly. .Lazy comes with all blessings and curses of lazy evaluation. I am talking about the actions themselves, not the state component.
20:26:22 <dolio> I think the standard response on the mailing list in the past was "write a strict state monad" and now it's "import .Strict". :)
20:26:45 <monochrom> A reading of the source code, plus an appreciation of the difference between "let (a,b)=... in ..." and "case ... of (a,b) -> ..." will do wonder.
20:27:15 <monochrom> Yeah, the strict version is very popular.
20:27:18 <lispy> monochrom: case is stricter tahn let?
20:27:38 <monochrom> > let (_,_)=undefined in "hello"
20:27:39 <lambdabot>  "hello"
20:27:47 <oerjan> lispy: let bindings contain an implicit ~ at the beginning
20:27:51 <monochrom> > case undefined of (_,_) -> "hello"
20:27:52 <lambdabot>  Undefined
20:27:54 <monochrom> > case undefined of ~(_,_) -> "hello"
20:27:56 <lambdabot>  "hello"
20:28:13 <lispy> interesting, i don't remember what ~ does
20:28:14 <monochrom> That covers all three major groups.
20:28:34 <monochrom> ~ gives you back the same laziness as let. :)
20:28:38 <ddarius> lispy: monochrom just demonstrated what it does.
20:28:39 <dolio> > let !(_,_) = undefined in "hello"
20:28:39 <lambdabot>  Parse error
20:28:43 <dolio> Ah well. :)
20:28:58 <ddarius> > let (#_,_#) = undefined in "hello"
20:28:58 <lambdabot>  Parse error
20:28:59 <monochrom> And ! gives you back the strictness of case. :)
20:29:13 <oerjan> ~ makes a pattern succeed automatically, not actually matching until a variable is used
20:29:30 <lispy> oerjan: ah, is that why it's called irrefutable?
20:29:36 <oerjan> right
20:29:44 <monochrom> irresistible temptation :)
20:30:33 <int80_h_> quit
20:30:43 <lispy> i wonder why ~ isn't implemented as the token, 'unsafeMatch' instead :)
20:30:59 <ddarius> There's nothing unsafe about it.
20:31:01 <LoganCapaldo> it's not necessarily unsafe.
20:31:19 * lispy was teasing
20:31:21 <monochrom> It is just underappreciated.
20:31:36 <dolio> 'data Foo = Foo Int ... f ~(Foo i) = ...'
20:31:47 <SamB> it's unsafe when it isn't the last case...
20:31:52 <lispy> ddarius: well i'm sure some people would argue that unless the pattern match can't fail you shouldn't use it...which would be the 'unsafe'ness that i was teasing about
20:31:55 <dolio> Since there's only one constructor, it can't be anything else but bottom.
20:31:59 <ddarius> monochrom: I wouldn't say that.  It's rarely needed, but very nice to have when you do need it.
20:32:33 <monochrom> by "appreciate" I mean "understand" rather than "use".
20:32:36 <SamB> lispy: well, obviously if it is the last, er, alternative in the case, it doesn't matter whether the pattern can fail to match or not...
20:33:13 <SamB> it obviously won't work any worse than if the case fails...
20:33:31 <monochrom> But it would make me look like a programming nerd if I said "underunderstood". :)
20:34:12 <SamB> insufficiently well known?
20:36:36 <LoganCapaldo> @hoogle (Functor f) => f a -> f b -> f (a, b)
20:36:37 <lambdabot> Prelude.asTypeOf :: a -> a -> a
20:36:37 <lambdabot> Prelude.const :: a -> b -> a
20:36:37 <lambdabot> Prelude.seq :: a -> b -> b
20:37:00 <LoganCapaldo> @hoogle (Functor f) => f a -> f b -> (a -> b -> c) -> f c
20:37:01 <lambdabot> Prelude.flip :: (a -> b -> c) -> b -> a -> c
20:37:57 <ddarius> @djinn Functor f => f a -> f b -> f (a,b)
20:37:57 <lambdabot> Cannot parse command
20:38:06 <ddarius> @djinn (Functor f) => f a -> f b -> f (a,b)
20:38:26 <LoganCapaldo> oh wait
20:38:32 <LoganCapaldo> @type fmap (,)
20:38:34 <lambdabot> forall a b (f :: * -> *). (Functor f) => f a -> f (b -> (a, b))
20:38:54 <ddarius> LoganCapaldo: s/Functor/Monad and you'd have an argument permutation of liftM2
20:38:57 <lispy> ?seen Cale
20:38:57 <lambdabot> Cale is in #ghc, #haskell-overflow, #haskell and #oasis. I last heard Cale speak 5h 8m 26s ago.
20:39:05 <LoganCapaldo> ddarius: yeah
20:39:17 <Cale> hi
20:39:18 <LoganCapaldo> no fmap2?
20:39:18 <dolio> @type \m n -> (,) <$> m <*> n
20:39:20 <lambdabot> forall a a1 (f :: * -> *). (Applicative f) => f a -> f a1 -> f (a, a1)
20:39:30 <lispy> Cale: hey, i bet you know how to answer my question :)
20:39:47 <lispy> Cale: i want to become an expert on GADTs and existential types, where can I learn more!
20:40:19 <dons> papers!
20:40:19 <lispy> so i'm looking for papers, puzzles, problems, etc
20:40:31 <LoganCapaldo> > let fmap2 f m n = f <$> m <*> n in fmap2 (,) [1,2,3] ["a","b","c"]
20:40:33 <lambdabot>  [(1,"a"),(1,"b"),(1,"c"),(2,"a"),(2,"b"),(2,"c"),(3,"a"),(3,"b"),(3,"c")]
20:40:37 <dons> there's some great articles by apfelmus on the wikibook too
20:40:37 <lispy> dons: specifics please!
20:40:47 <LoganCapaldo> hmmm
20:40:48 <monochrom> perhaps the wikibook has stuff
20:40:49 <dons> LoganCapaldo: nice use of the applicative stuff
20:40:51 <Cale> Yeah, I suppose papers and the GHC documentation?
20:40:57 <LoganCapaldo> dons: not really
20:41:08 <LoganCapaldo> I stole it from like 3 lines up
20:41:08 <dons> LoganCapaldo: we don't see it much in here :-) its good to be remineded
20:41:14 <LoganCapaldo> thank dolio :)
20:41:17 <dons> ah yes, dolio :-)
20:41:19 <dons> dolio++
20:41:40 <dons> ?pl \m n -> (,) <$> m <*> n
20:41:40 <lambdabot> (<*>) . ((,) <$>)
20:41:42 <lispy> Cale, dons, others, thanks, looking at the wikibook stuff now
20:41:46 <dons> gotta love haskell
20:42:00 <ddarius> It's mandated by law.
20:42:09 <dons> ((<*>) . ((,) <$>)) [1,2,3] ["a","b","c"]
20:42:10 <Pseudonym> The law of modus ponens.
20:42:26 <oerjan> LoganCapaldo: Functor is not sufficient for "fmap2"
20:42:32 <LoganCapaldo> > let fmap2 f m n = f <$> m <*> n in fmap2 (,) (Just 1) (Just "a")
20:42:33 <lambdabot>  Just (1,"a")
20:42:42 <LoganCapaldo> oerjan: I see
20:42:47 <LoganCapaldo> What else do you need?
20:43:09 <LoganCapaldo> @src Functor
20:43:09 <lambdabot> class  Functor f  where
20:43:10 <lambdabot>     fmap        :: (a -> b) -> f a -> f b
20:43:20 <LoganCapaldo> a -> f a ?
20:43:22 <dolio> > let fmap2 f m n = f <$> m <*> n in getZipList (fmap2 (ZipList [1, 2, 3]) (ZipList ["a", "b", "c"]))
20:43:26 <lambdabot>  Couldn't match expected type `a -> a1 -> b'
20:43:48 <LoganCapaldo> @type fmap i
20:43:51 <lambdabot> Not in scope: `i'
20:43:52 <LoganCapaldo> @type fmap id
20:43:56 <lambdabot> forall a (f :: * -> *). (Functor f) => f a -> f a
20:44:01 <LoganCapaldo> mm
20:44:22 <dolio> > let fmap2 f m n = f <$> m <*> n in getZipList (fmap2 (,) (ZipList [1, 2, 3]) (ZipList ["a", "b", "c"]))
20:44:23 <lambdabot>  [(1,"a"),(2,"b"),(3,"c")]
20:45:20 <desp> @type flip
20:45:23 <lambdabot> forall a b c. (a -> b -> c) -> b -> a -> c
20:45:52 <LoganCapaldo> @type fmap . const
20:45:54 <lambdabot> forall a (f :: * -> *) a1. (Functor f) => a1 -> f a -> f a1
20:45:54 <desp> @type flip mapM_
20:45:57 <lambdabot> forall a (m :: * -> *) b. (Monad m) => [a] -> (a -> m b) -> m ()
20:46:09 <LoganCapaldo> ooooh
20:46:35 <bos> flip mapM_ == forM_
20:47:04 <LoganCapaldo> @type \x -> (fmap . const) x undefined
20:47:06 <lambdabot> forall (f :: * -> *) a. (Functor f) => a -> f a
20:47:10 <LoganCapaldo> woo
20:47:33 <LoganCapaldo> well maybe woo
20:47:44 <bos> Either Argh Woo
20:47:51 <LoganCapaldo> (\x -> (fmap . const) x undefined) 3 :: Maybe Int
20:47:57 <LoganCapaldo> > (\x -> (fmap . const) x undefined) 3 :: Maybe Int
20:47:58 <lambdabot>  Undefined
20:48:01 <LoganCapaldo> drat
20:48:21 <LoganCapaldo> I knew that was gonna happen :)
20:49:07 <desp> @src forM_
20:49:07 <lambdabot> forM_ = flip mapM_
20:49:10 <desp> :)
20:51:28 <LoganCapaldo> @type fix flip
20:51:31 <lambdabot> forall b c. b -> b -> c
20:51:55 <LoganCapaldo> >  fix flip 1 1
20:52:01 <oerjan> LoganCapaldo: i'm not sure yet but i suspect you can define the Applicative methods from fmap and fmap2
20:52:01 <lambdabot> Terminated
20:52:11 <oerjan> @src Applicative
20:52:12 <lambdabot> class Functor f => Applicative f where
20:52:12 <lambdabot>     pure  :: a -> f a
20:52:12 <lambdabot>     (<*>) :: f (a -> b) -> f a -> f b
20:52:24 <LoganCapaldo> ah pure
20:52:29 <oerjan> er, maybe not pure
20:52:34 <LoganCapaldo> that's the function you really need
20:53:07 <LoganCapaldo> @type \f a b -> pure f <*> a <*> b
20:53:09 <lambdabot>     Ambiguous occurrence `pure'
20:53:09 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
20:53:21 <LoganCapaldo> @type \f a b -> Control.Applicative.pure f <*> a <*> b
20:53:23 <lambdabot> forall a a1 b (f :: * -> *). (Applicative f) => (a -> a1 -> b) -> f a -> f a1 -> f b
20:53:42 <LoganCapaldo> well there's fmap2
20:53:47 <LoganCapaldo> @type \f a b -> Control.Applicative.pure f a <*> b
20:53:49 <lambdabot> forall t (f :: * -> *) a b. (Applicative ((->) t), Applicative f) => f (a -> b) -> t -> f a -> f b
20:54:33 <LoganCapaldo> @type \f a b -> (Control.Applicative.pure f <*> a) b
20:54:35 <lambdabot> forall a b t. (Applicative ((->) t)) => (a -> b) -> (t -> a) -> t -> b
20:54:43 <LoganCapaldo> heh
20:54:51 <LoganCapaldo> that's funy
20:54:53 <LoganCapaldo> *funny
20:55:17 <LoganCapaldo> Reader strikes again
20:55:35 <dolio> @type \f a b -> (return f `ap` a) b
20:55:38 <lambdabot> forall a b t. (Monad ((->) t)) => (a -> b) -> (t -> a) -> t -> b
20:56:53 <LoganCapaldo> @type ((<*>) . pure)
20:56:55 <lambdabot>     Ambiguous occurrence `pure'
20:56:55 <lambdabot>     It could refer to either `pure', imported from Control.Applicative
20:57:06 <LoganCapaldo> @type ((<*>) . Control.Applicative.pure)
20:57:10 <lambdabot> forall (f :: * -> *) a b. (Applicative f) => (a -> b) -> f a -> f b
20:57:15 <oerjan> @src <$>
20:57:15 <lambdabot> f <$> a = fmap f a
20:57:36 <LoganCapaldo> Using <$> is cheating :)
20:58:25 <lispy> i'm not understanding why [forall a. Show a => a] is a list of bottoms
20:58:44 <lispy> they say, forall a. a is the intersection over all types
20:58:45 <LoganCapaldo> > pure 1 ++ pure 2
20:58:46 <lambdabot> Terminated
20:58:48 <lispy> i think i get that
20:59:12 <LoganCapaldo> > pure 1 :: [Int]
20:59:12 <lambdabot> Terminated
20:59:18 <lispy> then they go on to say, [forall a. Show a => a] is the intersection over all types plus the constraint of Show
20:59:20 <LoganCapaldo> I don't get it
20:59:26 <dolio> Bottom is the only value that inhabits every type in the Show class.
20:59:50 <LoganCapaldo> > pure 1 :: Maybe Int
20:59:51 <lambdabot> Terminated
20:59:58 <lispy> but then if you do data ShowBox = forall s. Show s => SB s
21:00:16 <lispy> then you can have [ShowBox] and that's not full of bottoms
21:00:40 <lispy> so some how putting the forall in a data declaration makes it not be an intersection?
21:00:42 <ddarius> exists /= forall
21:01:01 <lispy> ddarius: well, in some sense i haven't use 'exists' yet :)
21:01:12 <dolio> > Control.Applicative.pure 1 :: Maybe Int
21:01:14 <lambdabot>  Just 1
21:01:18 <LoganCapaldo> oh duh
21:01:30 <LoganCapaldo> where was the ambiguity warning this time!?!?!
21:01:33 <LoganCapaldo> :)
21:01:40 <lispy> ddarius: but, this explanation is trying to make the point that exists is spelled forall in haskell and it's that explanation i'm not following
21:02:12 <LoganCapaldo> > Control.Applicative.pure 1 ++ Control.Applicative.pure 2
21:02:13 <lambdabot>  [1,2]
21:02:44 <LoganCapaldo> thre are so many ways to spell (:[]) in Haskell
21:03:18 <dolio> There are even more ways to spell (.)
21:03:22 <lispy> so does forall have a completely different meaning when it appears in a data declaration?
21:03:26 <ddarius> not a = forall r. a -> r, not (forall a.E) <=> exists a.not E,
21:04:12 <icarroll> @quote abstraction
21:04:12 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
21:04:12 <lambdabot> us until we're sure they're OK.
21:04:22 <icarroll> @quote abstraction dons
21:04:22 <lambdabot> No quotes for this person. It can only be attributed to human error.
21:04:36 <dolio> > (succ `fmap` succ . succ <*> succ `liftM` succ) 0
21:04:37 <lambdabot>      precedence parsing error
21:04:37 <lambdabot>         cannot mix `fmap' [infixl 9] and `(.)' ...
21:04:37 <monochrom> "data X = forall a. XCon a" is different from "data X = XCon (forall a. a)".  The former is existential type. The latter is still forall in 2nd-rank polymorphism.
21:04:38 <notsmack> @quote abstraction human error
21:04:38 <lambdabot> No quotes for this person. I can't hear you -- I'm using the scrambler.
21:04:47 <ddarius> lispy: Consider the different types for Pack in data Exists = forall s. Pack s, and data Exists = Pack (forall s. s)
21:04:50 <dons> @quote abstraction
21:04:50 <lambdabot> JonFairbarn says: I think we should call it "Abstraction Oriented Programming". It's got the "oriented" buzzword in it, and we don't need to tell folk that "abstraction" means more than one thing to
21:04:50 <lambdabot> us until we're sure they're OK.
21:04:56 <LoganCapaldo> Hmm, (.), fmap, liftM, <$>
21:04:58 <dons> @quote abstraction.*human
21:04:59 <lambdabot> No quotes match. Just what do you think you're doing Dave?
21:05:04 <monochrom> But everyone is scrolling the channel like crazy, so no one will notice I said anything.
21:05:07 <dons> @quote human.*error
21:05:07 <lambdabot> No quotes match. The more you drive -- the dumber you get.
21:05:12 <bos> @type handle
21:05:13 <dons> @quote
21:05:14 <lambdabot> Not in scope: `handle'
21:05:14 <lambdabot> emonk says: Quien desmorruga?
21:05:31 <bos> @type Control.Exception.handle
21:05:31 <lambdabot> forall a. (GHC.IOBase.Exception -> IO a) -> IO a -> IO a
21:05:34 <notsmack> (dons: just a joke about that error message)
21:05:39 <LoganCapaldo> monochrom: I noticed. I didn't understand but I noticed
21:06:03 <dons> @quit trying a patch out
21:06:37 <lispy> ddarius: what is the difference?
21:06:41 <dons> > sequence [[1,2],[3,4]]
21:06:49 <lambdabot> Terminated
21:06:51 <lispy> ddarius: both of them use existentials right?
21:06:59 <dons> > 1+2
21:07:03 <icarroll> @remember dons Abstraction is hard. Let's go shopping!
21:07:05 <lambdabot>  3
21:07:11 <lambdabot> Done.
21:07:12 <dons> icarroll: heh
21:07:16 <ddarius> No, as monochrom said, the former uses existentials the latter rank-2 universals.
21:07:22 <dons> > Prelude.sequence [[1,2],[3,4]]
21:07:23 <icarroll> dons: That's my quote for the day. :)
21:07:27 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
21:07:32 <lispy> i missed what monochrom said, very busy tonight
21:07:37 <dons> > sequence [[1,2],[3,4]]
21:07:38 <lambdabot> Terminated
21:07:41 <dons> ah well
21:07:45 <dons> ah i know. oops
21:07:52 <lispy> 21:03 <monochrom> "data X = forall a. XCon a" is different from "data X = XCon (forall a. a)".  The former is existential type. The latter is still forall in 2nd-rank polymorphism.
21:07:53 <dolio> > (succ <<< (succ `fmap` (succ <$> (succ . (succ `liftM` succ))))) 0 -- there we go
21:07:54 <lambdabot>  6
21:08:00 <lispy> that?
21:08:34 <ddarius> lispy: Yes.
21:08:37 <lispy> so should i stop learning about existentials and go study rank2 polymorphism first?
21:08:55 <ddarius> lispy: They are related.
21:09:06 <ddarius> If you have rank-2 types you have existentials.
21:09:09 <dons> > sequence [[1,2],[3,4]]
21:09:10 <lambdabot> Terminated
21:09:10 <monochrom> I think there is no harm learning one thing at a time.
21:09:57 <lispy> ddarius: back to your question, i think data Exists = forall s. Pack s, holds any type
21:10:08 <lispy> but i'd think that of the other case too
21:10:26 <lispy> if i had a Pack s, i would expect s to be anything
21:10:37 <monochrom> "data X = XCon (forall a. a)" would be very close to intersection type.
21:10:38 <lispy> so i certainly couldn't do much with it
21:11:04 <dons> > sequence [[1,2],[3,4]]
21:11:06 <lambdabot>  [[1,3],[1,4],[2,3],[2,4]]
21:11:09 <dons> victory is mine!
21:11:13 <ddarius> forall a.a is only inhabited by bottom
21:11:16 <lispy> monochrom: intersection type?
21:11:30 <monochrom> Didn't you bring up intersection type?
21:11:32 <lispy> ddarius: i find that hard to believ
21:11:34 <ddarius> So for the second Pack :: (forall s.s) -> Exists, it can only take bottom.
21:11:38 <Pseudonym> ?free bottom :: a
21:11:38 <lambdabot> f bottom = bottom
21:12:04 <dons> hah, strict languages
21:12:06 <ddarius> lispy: Well, I guess it's also inhabited by things like trace "foo" undefined and such.
21:12:21 <Philippa> ddarius: those don't count, they involve an unsafe* primitive
21:12:27 <oerjan> @help free
21:12:28 <lambdabot> free <ident>. Generate theorems for free
21:12:28 <ddarius> Philippa: I agree.
21:12:51 <lispy> but, i could put anything in Pack right? it's just that when i go to inspect it, i don't know what it is
21:12:53 <ddarius> lispy: But look at the type for the "existential" Pack (the first one), we have: Pack :: forall s. s -> Exists
21:12:57 <LoganCapaldo> @type id
21:12:59 <lambdabot> forall a. a -> a
21:13:02 <Philippa> lispy: think about it - that's the type "values that have any type". There aren't any (other than bottom) unless you have a primitive specifically to introduce them
21:13:05 <dons> ?free sortBy
21:13:07 <lambdabot> (forall x. g x = h (f x) . f) => $map f . sortBy g = sortBy h . $map f
21:13:11 <ddarius> Let's call the first one PackE and the second PackA
21:13:14 <Philippa> sorry, "values that have /all/ types"
21:13:25 <LoganCapaldo> if forall a. a is only inhabited by bottom why can I do id 3? How does that work?
21:13:35 <ddarius> The only thing you can put in PackA, i.e. the only expression you can have for PackA is PackA undefined
21:13:41 <Philippa> LoganCapaldo: because forall a.a != forall a. a -> a
21:13:52 <Philippa> LoganCapaldo: though id is the only non-bottom inhabitant of forall a. a -> a
21:14:00 <monochrom> PackE is glad to wrap around anything, but after wrapping you can't use it.
21:14:05 <Philippa> (sorry, non-bottom-involving - there's also const bottom)
21:14:27 <ddarius> For PackE, you can have PackE 3 or PackE "foo" or anything else.  Of course, since we know nothing about it we can't do anything with it later when we pattern match PackE
21:14:30 <Philippa> because if you don't know the type of something, the only thing you can do is pass it
21:14:35 <ddarius> exists a.a <=> ()
21:14:35 <monochrom> PackA refuses to wrap around anything (except bottom), but after wrapping you can use it anywhere.
21:14:53 <lispy> ddarius: so, PackE is the one that is full of bottom right?
21:15:14 <lispy> thats' what you guys are saying, because we don't know anything about the s inside, we have to treat it as bottom?
21:15:22 <ddarius> lispy: No, PackE essentially only holds (), whereas PackA essentially only holds undefined.
21:15:23 <monochrom> PackE 1, PackE 'a', PackE True, ... they all works.
21:16:13 <lispy> hmm...
21:16:24 <LoganCapaldo> Philippa: I get that a -> a is not the same as a, but even so, 3 does not inhabit all types, and neither does the result of the expression id 3. Unless my conception that forall a. a -> a is roughly equivalent to (forall a. a) -> (forall a. a) is incorrect.
21:16:24 <lispy> so why isn't PackA willing to wrap things?
21:16:26 <monochrom> In PackA you actually know the type of the argument.  It's forall a. a.  It's fully polymorphic, you can make it any type you like.
21:16:34 <Philippa> LoganCapaldo: it's incorrect
21:16:45 <ddarius> lispy: Looking at the type of PackE as I was saying above, we have: PackE :: forall s. s -> Exists.  I.e. We can choose an s, say Int, and then PackE will pack a member of that type into Exists
21:17:06 <lispy> your use of "-> Exists" confuses me
21:17:08 <LoganCapaldo> Philippa: so what is it roughly equivalent to then?
21:17:11 <Philippa> LoganCapaldo: imagine that each forall corresponds to a type lambda (in System F, it does). I'll write type lambdas as /tyvar.term for now...
21:17:22 <Philippa> id = /t.\v::t.v
21:17:37 <ddarius> lispy: data Maybe a = Nothing | Just a, Just :: a -> Maybe a, Nothing :: Maybe a
21:17:44 <Philippa> there can, must be only one forall in the type corresponding to that type lambda
21:17:52 <LoganCapaldo> with you thus far
21:18:04 <Philippa> there isn't an equivalent type. It's forall a. a -> a or nothing. In Haskell 98, the forall's implicit, that's all
21:18:06 <lispy> ddarius: okay, you're mixing normal notation with the GADTs style notation?
21:18:33 <Philippa> lispy: no, he's made an ordinary declaration and then a couple of statements about the types of data constructors
21:18:36 <ddarius> lispy: No, I'm just saying that constructors have types too, though GADT notation is very useful here.
21:18:48 <oerjan> @type Just
21:18:51 <lambdabot> forall a. a -> Maybe a
21:18:59 <Philippa> LoganCapaldo: if it helps, that's forall a.(a -> a)
21:19:04 <LoganCapaldo> Philippa: so PackE or whatever looks like /t.v::PackE sort of, if I can be abusive with the notation
21:19:11 <Philippa> (that is, those're the same type on an abstract syntax level)
21:19:21 <lispy> thanks everyone, this is helping
21:19:41 <Philippa> LoganCapaldo: a little bit, yes. More accurately, PackE takes a type parameter as well as a term one
21:19:52 <cona1> how about this answer: The types say that PackE's argument may have any type, while PackA's argument must have every type.
21:19:59 <lispy> so i think i see now, in the second case we have PackA (some type), and "some type" just happens to be so general than only _|_ lives there
21:20:12 <ddarius> lispy: Yep
21:20:15 <Philippa> cona1: yup
21:20:17 <sorear> cona1: hi, your nick ends with one
21:20:23 <monochrom> PackA has type (forall a. a) -> ...   PackE has type forall a. a -> ...
21:20:23 <cona1> lispy: rather, so *specific*
21:20:32 <ddarius> sorear: Quite astute.
21:20:41 <sorear> ddarius: Yup.
21:20:59 <lispy> cona1: why is specific a better word than general there?
21:21:03 <sorear> ddarius: Read the logs - conal has thanked me for pointing this out in the past.
21:21:14 <ddarius> sorear: I'll take your word for it.
21:21:17 <lispy> cona1: isn't forall a. a, fully polymorphic, which i relate to generalality
21:21:29 <Philippa> lispy: no
21:21:44 <Philippa> exists a.a is the "fully polymorphic" type you're thinking of
21:21:46 <cona1> sorear: yes, thanks for the "1" tip.  i didn't know.  would someone remind me how to fix it?
21:22:02 <Philippa> forall a. a -> ... is a function that's fully polymorphic in its first parameter
21:22:07 <ddarius> forall a.a implies anything, exists a.a is implied by anything.
21:22:11 <conal> uhm...  that didn't work :)
21:22:22 <sorear>  /nick conal
21:22:32 <Philippa> sorear: try /msg #haskell /blahblahblah next time
21:22:33 <conal> sorear: thanks!
21:22:51 <monochrom> /say /nick xxx
21:23:06 <conal> what's /say ?
21:23:06 <ddarius> (or categorically, forall a.a is initial and exists a.a is terminal
21:23:07 <ddarius> )
21:23:08 <LoganCapaldo> ///nick works for me
21:23:11 <sorear> @msg #haskell /nick xxx
21:23:11 <lambdabot> /nick xxx
21:23:18 <LoganCapaldo> I over sescaped that one
21:23:25 <lispy> ddarius: your jedi category theory will not work on me ;)
21:23:34 <LoganCapaldo> /nick blah
21:23:35 <lispy> ddarius: (as in, i'm ignorant to the cat theory)
21:23:46 <LoganCapaldo> //nick I mean
21:23:46 <ddarius> Hence parentheses.
21:24:04 <sorear> /////////////////////////////////like this?
21:24:45 <Hirvinen_> Also "/ /<stuff>" relays the "/<stuff>" part onto a channel in a lot of clients I think. In Irssi at least.
21:24:53 <conal> lispy: yes, i see your point about "general" vs "specific"
21:25:27 <Philippa> forall a.a requires a "most general value". It's thus a highly specific type
21:25:39 <Philippa> being specific about your generality, blah blah blah :-)
21:25:51 <lispy> i have a really hard time with, id :: forall a. a -> a meaning something completely different from data Foo = Foo (forall a. a)
21:26:25 <oerjan> lispy: note that is id :: forall a. (a -> a)
21:26:33 <monochrom> I once wrote a tale on the confusion between "forall" and "forsome".
21:27:41 <lispy> oerjan: okay, but data Foo = Foo (forall a. (a)), is still trouble :)
21:28:04 <oerjan> but Foo :: (forall a. a) -> Foo
21:28:18 <lispy> data Foo = Foo (forall a. (a->a)) -- this is not full of identity functions, right?
21:28:20 <LoganCapaldo> GADT syntax++
21:28:21 <ddarius> monochrom: I bet it would have been far more interesting had it been between "forall" and "foursome"
21:28:32 <monochrom> haha
21:28:40 <oerjan> lispy: yes it may be
21:29:05 <LoganCapaldo> data Foo where Foo :: a -> Foo
21:29:21 <LoganCapaldo> data Foo where Foo :: (a -> a) -> Foo
21:29:29 <lispy> okay, when i see Foo :: (forall a. a) -> Foo, i can see how problematic, because the 'a' just comes into existence out of the blue
21:30:56 <monochrom> http://www.vex.net/~trebla/allsome.txt  de-confusing "all" and "some".
21:31:28 <Philippa> lispy: it doesn't as such, it gets 'passed in' alongside the value
21:31:38 <lispy> monochrom: i'll check it out
21:31:53 <monochrom> Actually de-confusing ambiguous uses of "any", "every".
21:32:15 <Philippa> and yes, data Foo = Foo (forall a. (a->a)) is full of boxed identity functions, const bottoms and bottoms
21:32:30 <lispy> Philippa: ah right, but then i can't really look at it can i?
21:32:41 <Philippa> "can't really look at it"?
21:32:43 <lispy> give me a foo and i still don't know what 'a' is
21:32:47 <Philippa> right
21:33:04 <Philippa> so the usual pattern is this:
21:33:22 <Philippa> data Foo where Foo :: (forall a.(a, Int -> a, ...)) -> Foo
21:33:31 <Philippa> or the version with typeclasses:
21:33:43 <lispy> so data Foo where Foo :: (forall a.a) -> Foo, corresponds to data Foo = Foo (forall a.a) and not data Foo = forall a. Foo a, right?
21:33:46 <Philippa> data Foo where Foo :: (forall a. Num a => a) -> Foo
21:33:53 <Philippa> right
21:34:12 <Philippa> *but*, that doesn't make quite as much difference as you may expect
21:34:46 <Philippa> in data Foo = forall a. Foo a, the forall in Foo's type is still on the 'inside' of the function arrows
21:34:52 <lispy> how to write the second one? maybe like this: data Foo where Foo :: forall a. a -> Foo
21:35:02 <Philippa> that is, you end up with Foo :: (forall a. <parms) -> Foo
21:35:29 <Philippa> ... point, they end up the same in the single-parm case
21:35:38 <Philippa> it's different if you're taking more than one parm
21:35:42 <lispy> i'm not following you anymore :)
21:35:57 <Philippa> consider data Bar = forall a. Bar a a
21:36:18 <lispy> okay in this case 'a' can be anything, right? not just _|_?
21:36:26 <Philippa> hopefully the difference between that and data Bar' = Bar' (forall a.a) (forall a.a) is obvious?
21:36:29 <Philippa> yeah
21:36:41 <lispy> not obvious, but i think i see it now
21:36:53 <lispy> Bar' holds _|_s
21:37:11 <ddarius> Philippa: forall a. Foo a leads to forall a. a -> Foo
21:37:16 <Philippa> Bar' takes two parms of potentially different types
21:37:29 <monochrom> "any" is an ambiguous notion, ambiguous between two opposites actually, that's why this business is hard to understand.
21:37:33 <Philippa> ddarius: "<Philippa> ... point, they end up the same in the single-parm case"
21:37:50 <Philippa> lispy: Bar takes two parms of the same type, but it can be any type
21:37:55 <ddarius> Foo (forall a.a) leads to (forall a.a) -> Foo /= forall a.a -> Foo
21:38:23 <Philippa> d'oh. OK, yeah, I should probably duck out - my brain's not functioning too well this morning and I'm making mistakes in my syntactic manipulations
21:38:32 <lispy> Philippa: but I thought we said data Foo = Foo (forall a.a), the only 'a' taht works in _|_...so wouldn't that apply to Bar'?
21:39:21 <Philippa> lispy: like I said, I should duck out. Yes, you're right.
21:39:24 <lispy> forall a.a -> Foo == forall a. (a -> Foo)
21:39:25 <lispy> ?
21:39:34 <lispy> Philippa: thank you for your help
21:39:36 <monochrom> Yes.
21:40:32 <lispy> the differences are big, but the syntatic differences are small
21:40:48 <lispy> like all of programming i gues :)
21:40:57 <ddarius> lispy: It's precedence.
21:41:06 <monochrom> The difference is even smaller in English.
21:42:06 <Philippa> am I the only one who ever vaguely wishes we had the option to use explicit type lambdas instead of annotations with foralls in them in haskell?
21:42:43 <hpaste>  sorear pasted "#xmonad excerpty" at http://hpaste.org/328
21:43:11 <ddarius> Philippa: No, well maybe with that "vaguely"
21:43:13 <sorear> Philippa: Not at all.
21:43:18 <dons> Philippa: not the only one :-)
21:43:26 <monochrom> I think forall suffices, but people have to pay attention to where the forall's are placed, and have some basic training in predicate logic.
21:43:32 <dons>  /\ t . X t
21:43:35 <LoganCapaldo> Philippa: I didn't even know type lambdas existed before today. But now that I do, I'm all for it :)
21:43:45 <dons> all the PTS guys are into it too
21:44:14 <lispy> oh those pureists...
21:44:16 <lispy> ;)
21:44:40 <lispy> monochrom: i'm okay with #0 and #1
21:44:50 <lispy> monochrom: #2 is taking me longer to read
21:45:08 <oerjan> PTS?
21:45:14 <lispy> pure type system
21:46:00 <lispy> (forall n:nat. n:D ==> |D|>=1)
21:46:10 <lispy> maybe it's just the notation
21:46:15 * Philippa figures the real problem is that you couldn't put type lambdas in patterns...
21:46:45 <Philippa> though you certainly could have a "type pattern" construct
21:46:53 <lispy> could i choose to read it this way: forall n, such that n is in Nat. and n is in D implies size of D is greater than or equal to 1
21:47:03 <monochrom> Yes.
21:47:09 <dons> pure type systems, yeah, a nice theory and notation for describing value and type systems in a uniform way
21:47:23 <Philippa> (but then you need to decide what to do when there's only a type pattern in the corresponding place in one pattern)
21:47:23 <dons> the paper `Henk: ...' by SPJ et al is a great intro for haskell people to PTS.
21:47:43 * ddarius decides that sleep is the better part of valor.
21:49:01 <lispy> monochrom: so what does it mean if you say, (exist n:nat. n:D ==> |D|>=1) ?
21:49:44 <monochrom> First rewrite as (forall n:nat. n:D) ==> |D|>=1.  Now it reads: if every natural number is in D, then |D|>=1.
21:50:17 <lispy> how did you know you could rewrite it?
21:50:30 <monochrom> You can also just say, "for some natural number n, if n is in D then |D|>=1". But few people grok it.
21:50:37 <monochrom> Basic training in predicate logic.
21:50:43 <chadz> anyone play with the EXIF bindings?
21:51:13 <lispy> monochrom: my memory must be terrible, i have a BS in math and i don't recall this
21:52:53 <monochrom> I have a BS in math and I don't recall any class explicitly covering this either. You have to find it in a really, really good logic course. Normally mathematicians couldn't care less.
21:53:27 <lispy> my only course is logic was from the philosophy department and i don't like to talk about it :)
21:53:32 <lispy> er in logic
21:54:51 <lispy> okay, i think i actualy prefer, "if any natural number is in D, then the size of D is at least 1."
21:55:11 <lispy> and that's the (exist n:nat. n:D) ==> |D|>=1, case right?
21:55:37 <monochrom> "if every ... then ..." is by consensus different from "if any ... then ...".
21:55:39 <lispy> because i get to choose an n, (preferably in D) to satisfy the statement?
21:56:24 <lispy> monochrom: oh i think i may have confused you earlier with a question
21:56:25 <monochrom> "if any ... then ..." is used by all mathematicians to refer to "(exist ...) ==> ...", yes.
21:56:45 <lispy> i want to know, if i move the parens in the exists version, how it changes the meaning
21:57:30 <lispy> i asked about (exist n:nat. n:D ==> |D|>=1), and you said (I tihnk correctly) that it becomes (forall n:nat. n:D) ==> |D|>=1
21:57:40 * sorear groks LALR(1)!!!
21:57:48 * sorear jumps excitedly!
21:58:08 <monochrom> Did you know:  (x and y) => z  equals  (x=>z) or (y=>z).  (x or y)=>z  equals  (x=>z) and (y=>z)
21:58:16 <Korollary> attaboi
21:58:19 <lispy> monochrom: but i guess that doesn't really change the meaning does it in this case?
21:58:58 <lispy> monochrom: that looks really familiar, and i imagine it has a name although i can't recall it
21:59:00 <dons> while we're thinking about the haskell category, http://programming.reddit.com/info/1zhtf/comments
21:59:02 <lambdabot> Title: Hask, the category of Haskell types and functions (reddit.com)
21:59:21 <monochrom> Now just generalize "and" to "all", "or" to "some".
21:59:56 <lispy> monochrom: thanks for all your help, i think i need a break for a bit
22:00:21 <setuid_w00t> Is "ls ++ [x]" the preferred way to append an item to a list?
22:01:09 <Korollary> That works. Check out Data.Sequence if you think you'll be doing a lot of appending.
22:01:13 <dons> that's snoc, yes, setuid_w00t
22:01:26 <dons> if you do a lot of snocs, Data.Sequence or even Data.DList would be better
22:01:29 <lispy> setuid_w00t? lol
22:01:30 <dons> (e.g. for pretty printers)
22:01:38 <Korollary> w00tar
22:01:46 <lispy> that's a ridiculuous nick :)
22:01:57 <dons> ?let snoc xs x = xs ++ [x]
22:01:58 <lambdabot> Defined.
22:02:03 <dons> > [1..10] `snoc` 42
22:02:04 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,42]
22:02:15 <dons> setuid_w00t: note the complexity of `snoc` on lists
22:02:49 <setuid_w00t> lispy: I'm glad you like it  :)
22:02:56 <monochrom> Appending an item is not preferred.
22:03:33 <lispy> setuid_w00t: if you like it, my opinion is unimportant...but it made me chuckle so hey...it was at least worth a laugh :)
22:03:51 <setuid_w00t> yeah, that's the point
22:04:19 <Korollary> Mission accomplished.
22:04:53 <setuid_w00t> dons, thanks for the idea.  I realize that appending is expensive.  It has to rebuild the whole list right?
22:05:09 <monochrom> I am playing the old Command & Conquer game and hearing a lot of "mission accomplished" (exact wording) lately. :)
22:05:23 <Korollary> Da Comrade!
22:05:42 <blackdog> setuid_w00t: if you're only appending, one idiom that can be useful is to chuck it on the front and just reverse at the end...
22:07:10 <dons> setuid_w00t: right, is has to copy the spine to do ++
22:07:17 <dons> ?src (++)
22:07:17 <lambdabot> (++) []     ys = ys
22:07:17 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
22:07:43 <dons> yeah, so you can either cons instead, then reverse at the end, or use a structure supporting O(1) or O(log n) snoc
22:08:07 <monochrom> If you re-think your algorithm, you may eliminate appending altogether.
22:08:10 <dons> we use the cons/reverse approach to snoc to do some tricks in xmonad, fwiw
22:08:59 <setuid_w00t> I am reading through "The haskell school of expression".  If you are familiar with that book, it uses geometry for some examples.
22:09:14 <monochrom> Example. Someone gives you a list of numbers and asks you to increase them all by 1.
22:09:32 <notsmack> "Rather, we copy only the node to be modifiied and all those nodes that contain direct or indirect pointers to the node."
22:09:38 * notsmack was reading Okasaki
22:09:59 <dons> sounds like Okasaki :-)
22:10:05 <monochrom> Imperative eager programming mindset: Initialize a local list variable to empty, scan the input list, for each number seen, add 1 and append to the local variable. Return it.
22:10:39 <monochrom> Functional lazy mindset: f [] = []; f (x:xs) = (x+1) : f xs
22:11:01 <dons> yes, "add one to the first element, then do the same for the rest"
22:11:19 <dons> How to wash dishes:   wash the first one, then do the same for the rest
22:11:29 <dons> its how humans think, people! :-)
22:11:32 <SamB> and here I thought it was map (+1)
22:11:48 <SamB> or mapM_ washDish
22:11:50 <monochrom> SamB, I have a point to make.
22:12:15 <dons> SamB: its a mapAccumL I think
22:12:37 <dolio> I thought humans think in terms of line numbers and GOTO.
22:13:15 <sorear> I find it pretty amusing that both Happy and Frown are in their respective google top10.
22:13:15 <dons> mapAccumL (\water dish -> dish `and` water) water dishes
22:13:18 <chadz> dolio: i think in registers.
22:13:30 <chadz> super scalar, oop, the works.
22:13:37 <sorear> I think in LR proof grammers.
22:13:53 <lispy> sorear: i find grammars hard
22:14:09 <lispy> sorear: and i cite my transript for evidence :(
22:14:09 <dons> no no, its more natural to think in terms of type unification. that's easiest.
22:14:31 <dons> see how Oleg does it, for example. simple! natural! easy!
22:14:39 <lispy> au Oleg
22:14:50 <lispy> (it's french for simple)
22:14:52 <dons> I wonder if Oleg assigns types to his refrigerator contents.
22:15:09 <dons> and Refrigerator must be an interesting HList
22:15:09 * lispy wonders if you could use types to figure out when things expire
22:15:19 <lispy> or maybe the types tell you what to eat
22:15:21 <SamB> lispy: you have Cs in parsing?
22:15:30 <dons> you want to statically ensure your fridge cannot hold things that are out of date
22:15:40 <monochrom> So, do not think: "let me assume earlier answers done and append later answers to it". Instead, think: "let me prepend earlier answers and assume later answers done by another function or recursion".
22:15:51 <lispy> SamB: kinda, i did fine in compilers but i did terrible in a theory of automata class
22:15:55 <SamB> hmm, I was going to say something about fuzzy typing and cravings...
22:16:16 <SamB> but then it occured to me that you want to throw out the things with fuzzy types
22:17:52 <user317> for some reason edisons assosiative array takes a really long time to inset elements
22:18:02 <user317> like 2, 3 seconds for 20 elements
22:18:15 <user317> and eventually it just dies when trying inserting 50
22:19:43 <dons> something sounds wrong. better look at the code
22:23:23 <sorear> Heh.
22:23:23 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
22:23:30 <sorear> @messages
22:23:31 <lambdabot> kc5tja said 53s ago: I don't know how, but + somehow got broken again. 1 2 + . yields 2666 on my box. :(
22:24:04 <sorear> @msg kc5tja Double check that 2 . works :)
22:24:42 <sorear> as I was saying...
22:24:44 <sorear> Heh.
22:24:52 <user317> hmm, ok, i am computing some sha1 sums, and they are takin ga really lon gtime for some reason
22:25:02 <sorear> You don't actually need 'error' to implement the parse-error rule
22:25:13 <sorear> shift/reduce conflicts are enough
22:25:37 <sorear> user317: don't.  there is a perfectly good 'sha1sum' program available to you, and Haskell supports pipes.
22:26:02 <user317> sorear, i am using haskell-crypto, its not my own implementation
22:26:11 <sorear> oh.
22:41:39 <chadz> argh, http://www.cs.chalmers.se/~bringert/darcs/haskell-exif/doc/, isn't detecting my exif data :(
23:49:33 <dlewissandy> Is there anyone on that could give me some pointers on creating a Win32 dll using GHC.  I have tried the example in the user's guide and it won't compile.
23:56:40 <dlewissandy> I need help with Making a DLL in GHC.  I have tryied to compile the example in section 11.4 of the GHC user's guide, but the compiler chokes on the dllMain.h code.  Specificially it says
23:57:09 <dlewissandy> "dllMain.c 18:0 error: '__stgint_Adder' undeclared (first use in this function)
23:57:45 <dlewissandy> I am not a C programmer, and could use some pointers in figuring this out, since the Docs are a bit sparse.
23:59:30 <dlewissandy> I am using GHC 6.6.1 on a windows XP platform
23:59:56 <dons> i think this is best asked on haskell-cafe@haskell.org
