00:00:37 <crazy_coder> whats the difference between a lamda function and a normal function? Where the former useful ?
00:00:59 <crazy_coder> / is used insted of function name is one difference
00:01:45 <sieni> \ rather
00:01:54 <dolio> A lambda is, essentially, a function literal.
00:02:16 <sieni> well there isn't much difference except a lambda expression being anonymous
00:02:22 <dolio> So you'd use it whenever you want to pass a function to another function, but don't want to give it a name.
00:02:45 <dolio> Like you might say "reverse [1, 2, 3]" instead of "let l = [1, 2, 3] in reverse l"
00:02:58 <crazy_coder> dolio: but then it destroys the idea of using functions. the reusability is gone then
00:03:19 <sieni> huh? :-)
00:03:31 <DRMacIver> Yeah. And to further reuse, you should package up all your functions in named records. Let's call them 'thingies'.
00:03:57 <DRMacIver> Then we can write our Haskell programs in a 'thingy oriented' manner.
00:04:39 <crazy_coder> still unclear to me. maybe when I'll use it, I'll see sense in it
00:04:40 <crazy_coder> :)
00:04:45 <sieni> > let f x = x + 1 in map f [1, 2, 3]
00:04:47 <lambdabot>  [2,3,4]
00:04:51 <sieni> > map (\x -> x + 1) [1, 2, 3]
00:04:53 <lambdabot>  [2,3,4]
00:05:16 <sieni> there was the same thing twice, once using a named function and a second time using an anonymous function
00:05:26 <crazy_coder> oh so instead of local declarations , we use lambda ?
00:05:33 <sieni> although in Haskell you can use currying
00:05:42 <sieni> > map (+1) [1, 2, 3]
00:05:45 <lambdabot>  [2,3,4]
00:06:13 <crazy_coder> this '(+1)' can be called a lamda function ?
00:06:22 <crazy_coder> since it is anonymous
00:06:34 <crazy_coder> *lambda
00:08:28 <crazy_coder> >map (\x -> x+1) [1,2,3]
00:10:05 <dons> ?unpl (+1)
00:10:05 <lambdabot> (\ a -> a + 1)
00:10:17 <dons> ?pl (\ a -> a + 1)
00:10:17 <lambdabot> (1 +)
00:11:01 <glguy> (1 +) is a "section"
00:11:14 <DRMacIver> crazy_coder has already left.
00:11:20 <DRMacIver> (Thankfully)
00:11:33 <DRMacIver> Hm
00:11:40 <DRMacIver> ?unpl (1+)
00:11:41 <lambdabot> (\ a -> 1 + a)
00:11:54 <DRMacIver> Oh, right. Brain not awake yet.
00:11:59 <glguy> pl knows that + is commutative
00:12:21 <DRMacIver> ?pl (\ a -> 1 + a)
00:12:21 <lambdabot> (1 +)
00:12:31 <DRMacIver> I don't think it does.
00:12:34 <DRMacIver> And I'm not sure that it should. :)
00:12:37 <glguy> ?pl (\a -> a + 1)
00:12:37 <lambdabot> (1 +)
00:12:39 <glguy> see
00:12:58 <DRMacIver> Oh, hm.
00:13:15 <glguy> ?pl (\a -> a / 2)
00:13:16 <lambdabot> (/ 2)
00:13:18 <glguy> ?pl (\a -> 2 / a)
00:13:18 <lambdabot> (2 /)
00:13:33 <glguy> it knows that (.) is associative too
00:13:59 <glguy> ?pl \a b c -> a . (b . c)
00:13:59 <lambdabot> (. (.)) . (.) . (.)
00:14:06 <glguy> ?pl \a b c -> (a . b) . c
00:14:06 <lambdabot> ((.) .) . (.)
00:14:15 <glguy> or I'm wrong :)
00:14:52 <mgsloan> yeah, it'll also do funny things with subtract
00:14:59 <mgsloan> ?src subtract
00:14:59 <lambdabot> subtract x y = y - x
00:15:08 <mgsloan> for composition reasons
00:17:59 <glguy> This day of Internet radio silence is really cramping my style
00:18:55 <DRMacIver> glguy: As far as I can tell (admittedly I've not looked in the report yet) commutativity of + isn't specified by Num.
00:19:31 <DRMacIver> (I think Float was mentioned as an example where + isn't commutative? Maybe that was *)
00:20:24 <glguy> ?pl \x -> ( 2 * x, x * 2)
00:20:24 <lambdabot> liftM2 (,) (2 *) (2 *)
00:20:55 <glguy> DRMacIver: I think that (*) might not be associative for Float
00:20:55 <DRMacIver> I'm not saying you're wrong. :) I'm just saying it's a transformation which is not always valid.
00:21:09 <glguy> DRMacIver: I was checking, not using it for evidence :-p
00:21:13 <DRMacIver> ok. :)
00:21:28 <glguy> but I think that (*) would be commutative for Float
00:21:36 <DRMacIver> Possibly you're right.
00:21:49 <DRMacIver> I can't think of an example where it wouldn't be. :)
00:22:02 <DRMacIver> But it would be potentially useful to e.g. define and use quaternions, where it's really not commutative. :)
00:22:09 <mgsloan> or matrices
00:22:15 <DRMacIver> True
00:22:18 <mgsloan> or multiplications of vectors and matrices
00:22:31 <mgsloan> or scaling vectors with floats
00:22:32 <DRMacIver> Well that's not an instance of num.
00:22:38 <glguy> vectors and matrices don't really fit into Num though, do they?
00:22:52 <mgsloan> yeah, not really, but they deserve the basic arithmetic operators
00:23:41 <DRMacIver> Mm. I have to admit, I'm increasingly unconvinced by type classes as the sole overloading primitive. At least without a much finer granularity of type classes (Along the lines of Addable, Multiplicable, etc. :) )
00:23:54 <mgsloan> yeah
00:24:14 <DRMacIver> Maybe it would be nice if every function came with an implicit type class associated with it.
00:24:19 <DRMacIver> Well, every named function.
00:24:21 <glguy> That's more of an argument against Prelude than typeclasses, however
00:24:28 <dons> just stick them in libraries.
00:24:32 <mgsloan> that'd be duck typing, I think
00:24:39 <mgsloan> (type class per function)
00:24:41 <dons> there's the whole numeric prelude task force for this, after all
00:24:55 <glguy> mgsloan: duck typing doesn't typecheck
00:25:00 <mgsloan> it could
00:25:02 <glguy> mgsloan: one typeclass per function would though
00:25:20 <mgsloan> I don't think duck typing really says anything about typechecking or not
00:25:36 <DRMacIver> glguy: Well, it's a bit of both. I agree it's much more the prelude than type classes per se, but it's not just the prelude which groups operations together like this.
00:26:06 <glguy> DRMacIver: what I meant to convey was that your issue was with the implementation of the standard libraries
00:26:08 <mgsloan> (by typechecking i mean static typechecking)
00:26:14 <glguy> or at least that is what I thought
00:26:19 <DRMacIver> And there are a lot of cases where one would want to just define simple operators and not worry about whether they clashed with other type class's usage.
00:26:43 <mgsloan> right now I'm facing the issue that ghc appears to inextricably link negate and Num...
00:26:59 <DRMacIver> glguy: Yesno. I think the fact that everyone seems to use type classes in this manner suggests that it's the natural manner in which they're used. :)
00:27:20 <DRMacIver> If you see what I mean.
00:28:00 <DRMacIver> On the other hand, I suspect one type class per function (plus others of course. There would still be Num, etc. It woudl just contain the classes for +, *, ...) would lead to some of the atrocities usually ascribed to operator overloading.
00:28:08 <DRMacIver> Having + used for *everything* for example. :)
00:28:12 <mgsloan> yeah, my current lang designs involve unlimited overloads, as long as each domain value has one and only one range value
00:28:49 <glguy> There is a strong disadvantage to one typeclass per function
00:28:56 <DRMacIver> What's that?
00:28:59 <glguy> you expose a lot of your internal implementation
00:29:11 <glguy> you specify specifically which function need to be supported
00:29:12 <mgsloan> I'm not sure if it's possible to check the coverage of domain vals/range vals. I don't know enough formal theory to try to develop a formalism for it
00:29:16 <glguy> instead of what class of functions
00:29:36 <glguy> by saying you need a Num, you are free to use (*) later without changing your code
00:29:39 <DRMacIver> Mm. I think that's a feature rather than a bug. You can always specify a more general class for the function's type.
00:29:50 <glguy> while if you always have one to one class to function
00:30:06 <glguy> You are specifying what functions you need, not what class of data
00:30:32 * LeCamarade is extending the ANSI-C lambda hack to put lambdas in PHP.
00:30:41 <glguy> I just see your external interfaces changing more often in the one to one case
00:30:45 <LeCamarade> It's horrible what Haskell does to good, honest programmers.
00:31:06 <glguy> good honest programmer write PHP code?
00:31:07 <glguy> ;)
00:31:14 <LeCamarade> I never used to bitch and moan about like this. Now I want at least a lambda. Even in C! This is blasphemous!
00:31:14 <glguy> programmers*
00:31:21 <DRMacIver> glguy: Yeah, I see what you mean. I think that's a "good practice" issue though, where you should probably stick to a consistent set of type classes across modules.
00:31:30 <LeCamarade> glguy: The boss can be evil, sometimes. Now it is PHP. :o(
00:31:52 <glguy> my project lead expects Haskell code from me
00:31:58 <DRMacIver> glguy: e.g. if my module is concerned with fully numeric stuff then it should assume Num. If it's only concerned with vector spaces or rings it should assuem those. etc.
00:31:59 <glguy> :-p
00:32:10 <LeCamarade> And I think I should move it from Python to PHP, and make it cleaner, with a true AST. If I can afford that.
00:32:21 <DRMacIver> LeCamarade: Yeah, Haskell causes... hmm. What's the opposite of brain damage?
00:32:25 <LeCamarade> glguy: Now you're bragging? X^(
00:32:26 <glguy> DRMacIver: I think this "use-case" is covered by typeclass synonyms (or something similarly named)
00:32:38 <DRMacIver> glguy: Hm. What's a type class synonym?
00:32:51 <glguy> its a named group of type classes
00:33:04 <glguy> so your explicit type decl don't get out of hand
00:33:13 <glguy> when you have such fine grained classes
00:33:21 <DRMacIver> Ah
00:33:24 <glguy> and it adds a layer of abstraction
00:33:26 <mgsloan> that'd be nice
00:33:40 <glguy> so you don't have the implementation detail leak I worried about
00:34:00 <glguy> where you specify based on internal usage
00:35:17 <mgsloan> Once you get some decent numerics classes you can start doing fun stuff like (Double -> Double) + (Double -> Double)
00:35:42 <glguy> http://repetae.net/john/recent/out/classalias.html
00:35:43 <lambdabot> Title: Class Alias Proposal for Haskell
00:35:46 <glguy> That seems related
00:36:37 * glguy wonders why installers think I need a shortcut on my desktop
00:37:01 <mgsloan> why? because their program is the most importantest program in the world of course
00:37:31 <mgsloan> you'll probably have to use it every few minutes, so might as well have a shortcut on your desktop
00:37:53 <glguy> :-p
00:38:07 <glguy> my most importantest programs are in the list right above the start menu
00:38:07 <koala_man> I prefer desktop shortcuts over the start menu
00:38:21 <glguy> start button*
00:38:24 <mgsloan> heh start menu
00:38:46 * mgsloan prefers his deskbar
00:38:52 <glguy> doesn't help that I leave firefox running all day
00:39:01 <glguy> and that I start putty sessions from pageant
00:39:18 <glguy> and that I don't really use any of the other programs installed
00:41:43 <mgsloan> haha:
00:41:43 <mgsloan> lerp :: (Sub t t t, Add t t t, Mul (D2 t) t (D2 t)) => D2 t -> D2 t -> t -> D2 t
00:41:44 <mgsloan> lerp p1 p2 t = p1 + (p2 - p1)*t
00:41:59 <mgsloan> gorra love those fine grained classes
00:50:08 * glguy had a grumpy puppy, but now he has a sleepy puppy... hopefully that doesn't switch back when I put him in his crate
00:51:28 <notadev> hmm wait for him to fall sound asleep?
00:51:31 <dons> oh no, glguy quoted xah lee.
00:52:11 <glguy> dons: is that bad???
00:52:25 <dons> well...
00:52:42 <dons> maybe you haven't looked at the rest of his web space.
00:52:51 <glguy> nope
00:53:17 <Cale> Where's the Xah Lee quote?
00:53:31 <glguy> http://programming.reddit.com/info/21b0h/comments/c21b26
00:53:31 <dons> oh, just the 'tour of lambda logos' page.
00:53:32 <lambdabot> Title: Just stare at the Lambda... and repeat after me: "Lisp is great, Lisp is great . ...
00:53:35 <glguy> hardly a "quote"
00:53:48 <Cale> ah
00:53:54 <dons> btw, we have a haskell logo pag, http://haskell.org/haskellwiki/Haskell_logos
00:53:55 <lambdabot> Title: Haskell logos - HaskellWiki
00:54:21 <dons> i note its missing the quickcheck logo though
00:56:17 <glguy> dons: do you have a representative xah lee quote?
00:57:23 <Wild_Cat> glguy: "[language] sucks. Lisp is better."
00:58:05 <mgsloan> hmm, I wonder... I bet delta compilation could do a better job of type errors..
00:58:16 <DRMacIver> Who is xah lee?
01:00:16 <Cale> DRMacIver: http://xahlee.org/
01:00:17 <lambdabot> Title: redirect
01:00:21 <dons> glguy: hmm, more the rather disturbing misogyny :( very strange person.
01:00:33 <Cale> dons: yeah
01:00:47 <Wild_Cat> DRMacIver: a guy who regularly trolls a number of Usenet groups.
01:00:53 <dons> there's a reason he's banned in here
01:01:15 <glguy> The article about Guy Steele's disgusting abuse of macros demonstrating how you can invisibly restrict what functions you are allowed to use in a lambda expression lead to some terrible comments
01:01:19 <mgsloan> cool page, though...
01:01:51 <tessier> Wow, scary. I almost understand this quicksort implemented in haskell.
01:01:59 <glguy> and doing symbolic differentiation in haskell was as easy as writing an instance of Num that just replaces the functions with data constructors
01:02:03 <dons> ayrnieu tries to kill any haskell thread :/
01:02:12 <Wild_Cat> He often spouts some random crap in c.l.python about how Lisp is so much better than Python and how he blogged about it again. I think he uses a template engine to cross-post his messages to 10 or so c.l.[language] groups.
01:02:16 <glguy> the same for Fractional
01:02:20 <DRMacIver> Heh.
01:02:24 <tessier> However, hugs doesn't like it: ERROR "/home/treed/haskell/sum.hs":10 - Cannot justify constraints in explicitly typed binding
01:02:28 <tessier> Anyone know what this means?
01:02:31 <DRMacIver> Sounds charming. :)
01:02:44 <mgsloan> dons - yeah, i tried to be reasonable with him
01:03:17 <glguy> I don't understand the joyful expressions of ignorance :(
01:03:44 <glguy> and then the thread disintigrates into personal discussion
01:04:25 <tessier> And assuming hugs actually accepted the code how does p get chosen here in this quicksort? http://pastebin.ca/589893
01:04:33 <dons> ayrnieu and grauenwolf seem to attract that kind of degeneration, though, glguy :|
01:04:47 <tessier> I understand p is the pivot point. Normally it is randomly chosen.
01:04:57 <Cale> tessier: you need (Ord a) => [a] -> [a]
01:05:04 <mgsloan> yeah, ayrnieu is a lispophyte, and grauen is a MSophyte
01:05:23 <Cale> tessier: It's taking the first element of the list as pivot.
01:05:40 <Cale> tessier: (see the pattern match?)
01:05:40 <tessier> Cale: What does (Ord a) => [a] -> [a] do and where do I need it?
01:05:47 <Cale> In the type signature
01:05:56 <dons> i'm not sure about ayrnieu, he used to hang out here, but stated a few months ago he was going to criticise any haskell on reddit. hence hs is sort of this lone troll
01:06:04 <Cale> quicksort :: [a] -> [a] becomes  quicksort :: Ord a => [a] -> [a]
01:06:09 <tessier> Yes, at first I thought p:xs meant the first element of the list was p but that isn't normally how yo do a quicksort.
01:06:16 <tessier> ah, ok
01:06:26 <Cale> tessier: well, you might go to more trouble to find a pivot
01:07:20 <glguy> reddit really needs a "block" feature
01:07:23 <mgsloan> tessier: (Ord a) is a constraint that declares that a has functions which give an ordering
01:07:38 <Cale> (i.e. <= and >
01:07:39 <Cale> )
01:07:55 <oerjan> tessier: i don't think you normally do quicksort on linked lists. :)
01:09:13 <Cale> For a somewhat increased constant factor, you could look a bit further through the list and pick some element from the middle as the pivot.
01:09:22 <dons> morning swiert
01:10:43 <tessier> oerjan: What datatype would you use if you really wanted to sort a bunch of things/
01:10:44 <tessier> ?
01:10:52 * oerjan realized that Data.List.sort is not O(n log n), after someone implied out on haskell-cafe that is was made for maximal laziness.
01:11:04 <Cale> tessier: Well, on lists, a mergesort is better.
01:11:16 <Cale> tessier: You could of course use arrays.
01:11:40 <oerjan> tessier: presumably a mutable array or maybe diff array
01:12:05 <tessier> Wouldn't a mutable array count as state?
01:12:28 <dons> the mutation could be hidden inside runST
01:12:31 <oerjan> yes. and dif arrays cheat by being stateful under the hood.
01:12:31 <dons> since its pure on the outside
01:12:34 <mgsloan> yikes, ghc bypasses hiding (negate)...
01:12:41 <oerjan> *diff
01:12:50 * glguy discovers the vim command: g??
01:13:05 <dons> i'd really like ben lippmeijer's effect inference as a standalone tool for checking purity of FFI code
01:13:22 <oerjan> mgsloan: all syntactic sugar is supposed to go to the explicit Prelude functions.
01:13:23 <dons> glguy: maybe we could find a use for that at work. effect inference for FFI code.
01:13:35 <oerjan> i believe.
01:13:45 <mgsloan> I think you're right
01:13:49 <mgsloan> but it's annoiying as hell
01:13:49 <glguy> dons: link?
01:13:58 <mgsloan> means its impossible to make a proper numeric prelude
01:14:11 <mgsloan> Num will always sneak in somewhere
01:14:14 <tessier> hah
01:14:20 <dons> its a type system that infers side effects (like read/write memory etc). but it would make a great lint tool/checker for FFI code + unsafePerformIO
01:14:21 <tessier> Never try to evaluate [1..] :)
01:14:23 <glguy> dons: when are you starting?
01:14:30 <dons> you'd be able to verify that unsafePerformIO is being used safely
01:14:32 <oerjan> oh right.
01:14:33 <tessier> Because it does what you would expect it to do.
01:14:42 <dons> glguy: i'll be flying out of here around Aug 30.
01:14:47 <dons> so a few days after that
01:15:02 <dons> glguy: doing all the crazy pack-up-my-life stuff atm.
01:15:16 <quicksilver> mgsloan: -fno-implicit-prelude
01:15:18 <quicksilver> mgsloan: IIRC
01:15:23 <quicksilver> mgsloan: there is a flag to bypass it, anyhow
01:15:27 <mgsloan> ooh, sweet!
01:15:28 <mgsloan> thanks
01:15:29 <glguy> I had a finish the semester, get married, move , start new job phase too... so much fun
01:15:35 <TSC> dons: I guy here just packed up and left for a job in the US
01:15:37 <dons> :-)
01:15:46 <TSC> But he hasn't quite finished his PhD...
01:16:03 <kolmodin> is lippmeijer in #haskell every once in a while?
01:16:03 <dons> hehe, me too!
01:16:07 <dons> kolmodin: yeah.
01:16:16 <kolmodin> nick?
01:16:23 <dons> kolmodin: you remember him from the hackathon?
01:16:25 <dons> benl I think.
01:16:30 <kolmodin> yes I do :)
01:16:38 <kolmodin> that's why I'd like to say hi some time :)
01:16:51 <kolmodin> not only brilliant but also a nice guy
01:16:53 <dons> glguy: he gave a talk at sapling, http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071
01:16:53 <lambdabot> Title: &nbsp; : SAPLING - SAPLING 071 browse
01:17:24 <glguy> *bookmarked*
01:17:31 <glguy> I'll have to look at that at work tomorrow
01:17:35 <dons> he's working on a type system + effect inference, (i.e. to freely mix impure and pure code in a haskellish language, and have the compiler infer the monads). but i'd like to see the inference torn out as a standalone checker
01:17:51 <kolmodin> right
01:17:52 <dons> to verify things like bytestring and Data.Binary are indeed referentially transparent uses of the FFI
01:18:12 <kolmodin> yeah, I remember he said that the purity of haskell was causing trouble for efficiensy in some cases
01:18:18 <glguy> that would be quite cool
01:18:26 <DRMacIver> I always find the FFI somewhat amusing. :) (even though it's clearly a good idea)
01:18:35 <dons> yeah, we cheat by dropping into FFI + unsafePerformIO (e.g. to do fast inplace quicksort under the hood)
01:18:40 <dons> being able to check it would be nice.
01:19:01 <kolmodin> yeah, very nice
01:19:02 <dons> it would have caught one bug in the bytestring 0.8 api, for example
01:19:09 <kolmodin> oh?
01:19:35 <dons> yeah, withCString handed over to C, but if C changed the buffer, your pure haskell values would mutate
01:19:40 <kolmodin> the only bug I've hit (and noticed) is the L.append strictness issue
01:19:47 <dons>  or was it useAsCString
01:20:02 <kolmodin> right. bummer. I recall that now
01:20:44 <dons> yeah, the strictness issues will all be fixed for bytestring 1.0, I think, now we have strictcheck.
01:20:54 <Cale> tessier: well, it's harmless, apart from causing all your previous stuff to scroll off of your screen
01:20:55 <kolmodin> neat :D
01:21:11 <Cale> :)
01:21:37 <Cale> tessier: try:  let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
01:23:25 <DRMacIver> I can't help but feel that that a lot of the solutions like that are just pretty hacks.
01:23:27 <oerjan> mgsloan: http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#rebindable-syntax
01:23:29 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
01:24:57 <mgsloan> oerjan - ahah, cool
01:25:08 <mgsloan> no if overload, though, heh
01:25:14 <kolmodin> ?seen benl
01:25:14 <lambdabot> I haven't seen benl.
01:25:22 <mgsloan> not that i mind or anything
01:25:41 <glguy> dons: I'm quite jealous that you were a presenter at SAPLING 071, and I didn't even know about it
01:26:07 <glguy> Any chance it was recorded??
01:26:34 <dons> hmm, we should do that next time. no, only the slides.
01:26:38 <dons> i even wore my xmonad tshirt!
01:26:43 <glguy> :'-(
01:26:55 <glguy> every one of the talks looks quite interesting
01:27:00 <glguy> that isn't fair!
01:27:09 <dons> yeah, it was cool.
01:27:36 <glguy> SPJ is giving a talk at Galois in the coming months :)
01:28:36 <glguy> tomorrow Mark Tullsen is given a talk, Laziness: The Double-Edged Sword
01:28:40 <glguy> giving*
01:29:15 <dons> oh, nice.
01:29:20 <dons> we should record it!
01:29:21 <mgsloan> @pl vfold (&&) $ vzip (==) a b
01:29:21 <lambdabot> vfold (&&) (vzip (==) a b)
01:29:33 <glguy> Levent has been keeping a full tech talk schedule since I started
01:29:45 <dons> glguy: the talk i gave at galois was also a bit on laziness/ the double edge sword. interesting.
01:30:00 <dons> (mine was about strictness testing, and bugs in some lazy functions)
01:31:39 <glguy> when did you give it?
01:32:52 <glguy> ugh... if I'm going to bike in tomorrow I'm going to need to get some rest! good night all
01:35:04 <LeCamarade> Record that thing and put it up, please.
01:35:46 <LeCamarade> My biggest idea for thunks is on-the-fly recompilation. That can have big necessities in low-level code.
01:36:05 <LeCamarade> When done right, speedy, with optimisations and to be re-used a lot.
01:36:23 <mgsloan> My by biggest idea for thunks is to be able to serianlize em and send em over a network
01:36:36 <DRMacIver> LeCamarade: So... a JIT? :)
01:37:33 <LeCamarade> DRMacIver: Yeah, a JIT that works better than traditional JIT. And with a new attribute that allows you to take x [0, 2 ..]
01:37:55 <LeCamarade> And moving thunks to other cores that may be idle, et cetera.
01:38:21 <LeCamarade> There is a terrible paradigm of the kernel and compiler being different that is so rife today. It is simply wrong.
01:38:48 <LeCamarade> Dr. Massalin's kernel taught us that, if nothing else. The Synthesis kernel.
01:38:52 <mgsloan> tis not so bad
01:39:11 <mgsloan> At least this way we can have multiple compilers in an OS
01:40:03 <LeCamarade> mgsloan: How can a kernel know absolutely nothing about the apps it works with? Plus, we don't really need multiple compilers in an OS. That's for later. But think of modules/extensions as the compilers ... those can be multiple.
01:42:57 <mgsloan> Yes, it is definitely very nice to have that
01:49:36 <dons> ?where+ hslua http://home.agh.edu.pl/~gpolak/hslua
01:49:36 <lambdabot> Done.
01:49:41 <mgsloan> Excellent:
01:49:41 <mgsloan> *Moing.Prelude> up + right + right
01:49:41 <mgsloan> <2.0,1.0>
01:50:28 <dons> cool
01:50:32 <dons> http://programming.reddit.com/info/21bcw/comments
01:50:33 <lambdabot> Title: hslua:Haskell and Lua interoperability! (reddit.com)
01:51:32 <mgsloan> angleBetween up right = 1.5707963267948966, Rotate down * right = down, etc
01:52:08 <mgsloan> the up/right/down/left stuff isn't really as important as i make it out in these examples, but hey
01:52:11 <baboa> dons: thanks for adding me (hslua) to lambdabot :)
01:52:48 <dons> baboa: hi!
01:53:26 <dons> baboa, you're Gracjan Polak?
01:53:41 <baboa> dons: yes, that is me
01:53:56 <desp> baboa: cześć
01:54:01 <dons> great work on hslua. do you want to upload it to hackage too?
01:54:15 <dons> (i can give you an account, if you need one)
01:54:55 <baboa> dons: I'll, but la me settle some things in the library
01:55:06 <baboa> I'd like to wait a moment and see what people say
01:55:16 <baboa> then I'll surely upload it to hackage
01:55:38 <baboa> desp: czesc, sorry, no polish letters here :)
01:55:44 <desp> ;)
01:56:01 <baboa> desp: where are you from?
01:56:25 <desp> baboa: .pl, as well
01:56:47 <baboa> desp: and city?
01:57:10 <desp> baboa: Poznan, but studying at UWr
01:57:50 <baboa> desp: oh, I see, plenty of Haskellers lurking in this country :)
02:03:57 <psymort> Probably a naive question, but I'm not a mathematician (and relearning haskell).  In the description of seq, it says the value of seq ab is bottom if a is bottom, and otherwise equal to b.  What exactly does this mean?  (ie. can someone describe bottom - in one sentence or less? ;-) )
02:04:23 <quicksilver> psymort: well that description is a funny way of putting it
02:04:44 <quicksilver> psymort: more intuitive "it tries to calculate a, and then returns b"
02:05:09 <quicksilver> psymort: if calculating a goes into an infinite loop, or throws an exception, then a is bottom, and seq returns that bottom, too
02:05:09 <psymort> quicksilver: which begs the question, what does 'try' mean in this context?
02:05:31 <quicksilver> well it does what the haskell runtime normally does :)
02:05:40 <notadev> does that mean minimum?
02:05:41 <quicksilver> it calls functions, etc, as needed to evaluate it
02:05:48 <psymort> quicksilver: so how does it know it's gone into an infinite loop?
02:06:01 <quicksilver> it doesn't, actually
02:06:04 <quicksilver> it will never return
02:06:14 <notadev> woooh ;)
02:06:26 * notadev hides
02:06:34 <oerjan> psymort: "bottom" means any expression that does not return an actual value, like by not terminating or by raising an exception.
02:06:45 <quicksilver> (at least, it can spot a couple simple infinite loops, but it can't spot them all)
02:06:49 <psymort> ok.  so if I did, say, "seq (last [1..]) 2", it'll never return?
02:06:52 * quicksilver nods
02:06:59 <quicksilver> > seq (last [1..]) 2
02:07:07 <lambdabot> Terminated
02:07:11 <quicksilver> there you go :)
02:07:15 <psymort> cool
02:07:23 <quicksilver> lambdabot has a CPU time/real time timeout on it
02:09:32 <psymort> oerjan: that's a nice description
02:10:24 <quicksilver> psymort: the other important part of the puzzle is to remember that haskell only evaluates anything when it needs to
02:10:37 <quicksilver> psymort: so seq is a tool for forcing the evaluation of something that wasn't needed yet
02:11:18 <LeCamarade> > take 3 "sequence the evaluations" -- Is that the meaning of seq?
02:11:20 <lambdabot>  "seq"
02:13:43 <kaol> > let a = "something you want evaluated now" in a `seq` take 9 a
02:13:45 <lambdabot>  "something"
02:13:50 <psymort> So, essentially seq evaluates 'a' eagearly
02:13:56 <psymort> eagerly
02:14:26 <kaol> @src foldl'
02:14:27 <lambdabot> foldl' f a []     = a
02:14:27 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:14:39 <DRMacIver> > seq [1..] 5 -- But not very eagerly.
02:14:41 <lambdabot>  5
02:14:46 <ibid> t `seq` u means that t shall be evaluated when u is evaluated
02:15:16 <ibid> (which makes t `seq` t kinda pointless - and it's an easy mistake to make)
02:15:20 <quicksilver> psymort: actually, no :)
02:15:25 <quicksilver> psymort: it evaluates it up to WHNF
02:15:34 <psymort> > seq (repeat 1) 0
02:15:36 <lambdabot>  0
02:15:42 <quicksilver> psymort: i.e. up to the first constructor or lambda
02:15:53 <quicksilver> (first unsatisfied lambda)
02:16:05 <kaol> > let a = (repeat 1) in a `seq` take 5 a
02:16:08 <lambdabot>  [1,1,1,1,1]
02:16:46 <ibid> if a has the type Bool, then a `seq` b means the same as case a of True -> b ; False -> b (i think)
02:17:04 <ibid> similar case structures can be created for any algebraic type of a
02:17:29 <psymort> quicksilver: WHNF?
02:17:36 <quicksilver> psymort: Weak Head Normal Form
02:17:42 <psymort> quicksilver: ok
02:17:52 <quicksilver> psymort: up to the first constructor or unsatisfiable lambda
02:18:06 <quicksilver> So, if you have a data type data Bar = Bar Int Int
02:18:12 <quicksilver> and you 'seq' it
02:18:13 <quicksilver> you get
02:18:21 <quicksilver> <thunk> --~--> Bar <thunk> <thunk>
02:18:24 <quicksilver> and then it stops
02:18:29 <oerjan> psymort: basically it evaluates it just enough to test that it is not completely bottom
02:18:32 <quicksilver> it doesn't need to evaluate the 'int' parts "inside"
02:19:10 <yakov> hi
02:19:27 <psymort> ok....I think that makes some sense...
02:19:32 <oerjan> since in Haskell, something may have a value even though parts of it don't.
02:20:48 <DRMacIver> Is there actually a deepSeq function?
02:20:59 <oerjan> @index deepSeq
02:20:59 <lambdabot> bzzt
02:21:01 <DRMacIver> (I've seen it mentioned but couldn't find it documented)
02:21:02 <psymort> so, in the case of 'foo :: a    foo = seq (last [1..]) 0', we never actually construct a type 'a', so it goes bottom.  But 'unfoo :: a    unfoo = seq (repeat 1) 0', constructs an a, so it's not bottom?
02:21:06 <oerjan> @hoogle deepSeq
02:21:07 <lambdabot> No matches found
02:21:14 <DRMacIver> Yes, I tried that. :)
02:21:27 <DRMacIver> But hoogle e.g. also doesn't show up unsafeCoerce#
02:21:42 <mux> @type rnf
02:21:45 <lambdabot> forall a. (NFData a) => a -> Done
02:22:23 <oerjan> i guess you could define deepSeq with the Data typeclass, if that does what i think it does?
02:22:38 <mux> > rwhnf [1,2,undefined,3]
02:22:40 <lambdabot>  ()
02:22:43 <mux> > rnf [1,2,undefined,3]
02:22:45 <lambdabot>  Undefined
02:22:53 <DRMacIver> I see.
02:23:00 <oerjan> oh
02:23:02 <mux> rnf is from Control.Parallel.Strategies
02:23:23 <mux> since deepSeq can't be implemented automatically for each data structure, there's a NFData type class
02:24:12 <oerjan> psymort: yes
02:24:37 <psymort> > seq (repeat [1]) 1
02:24:40 <quicksilver> DRMacIver: deepSeq is a well understood name for a function which isn't straightforward to implement :)
02:24:40 <lambdabot>  1
02:24:53 <quicksilver> fortunately deepSeq is very, very seldom needed
02:24:58 <psymort> oerjan: is it that it constructs an a, or that it constructs anything?
02:25:22 <DRMacIver> quicksilver: Ah, I see. :)
02:25:23 <psymort> (seems like anything?)
02:25:36 <oerjan> psymort: well, the first argument of the seq doesn't need to have the same type as the second.
02:25:47 <psymort> oerjan: noted
02:25:48 <DRMacIver> I think I first saw it come up in the context of "Haskell is not not ML"
02:26:10 <quicksilver> DRMacIver: in fact it probably shuoldn't even be called a 'function'
02:26:18 <DRMacIver> Hm, why not?
02:26:20 <quicksilver> DRMacIver: 'operational hack' :)
02:26:25 <DRMacIver> Heh
02:26:27 <psymort> oerjan: oh....wait up.  So perhaps it would be correct to say that it'll evaluate it until the point where it could be used by anything in such a way that it wouldn't bottom?
02:26:33 <quicksilver> its functional semantics are those of const
02:26:38 <quicksilver> (almost)
02:26:41 <oerjan> psymort: exactly.
02:26:44 <quicksilver> it's only it's operational side effects we care about
02:27:20 <DRMacIver> It's unfortunate that lazy evaluation is a form of side effect. :)
02:27:21 <psymort> oerjan: or, in reverse, that it'll only bottom if there's absolutely no way that expression could be used in any way that wouldn't bottom.
02:27:49 <psymort> and it'll, of course, do the least it can do to work that out.
02:27:51 <LeCamarade> Five tools every Haskell hacker needs: GHC suite, Hugs, darcs, IRC Client for irc.freenode.org/#haskell, library to parse C-like langauges (from PHP to Java, via C/C++) into an AST.
02:27:57 <oerjan> psymort: actually that doesn't _quite_ hold for functions.
02:28:19 <LeCamarade> I need the last tool there - anybody have one?
02:28:25 <oerjan> e.g. \x -> undefined is not bottom, but cannot be used for anything.
02:29:00 <psymort> ok...now you've got me.  what is 'undefined'?
02:29:29 <quicksilver> bottom
02:30:08 <oerjan> the standard way of writing bottom in haskell
02:30:12 <quicksilver> undefined is roughly 'error "undefined"'
02:30:18 <oerjan> > seq (\x -> undefined) 1
02:30:20 <lambdabot>  1
02:30:39 <psymort> > seq undefined 1
02:30:42 <lambdabot>  Undefined
02:30:50 <osfameron> LeCamarade: why do we also need Hugs?
02:30:58 <oerjan> in this case you could say it is because there is no way of evaluating it further without actually supplying x.
02:31:17 <LeCamarade> osfameron: Many times someone is talking in Hugs context. Especially newbies.
02:31:20 <psymort> oerjan: yes - I think that makes sense
02:31:34 <LeCamarade> > let (_'_) = undefined in (_'_)
02:31:35 <lambdabot>  Undefined
02:31:50 <sieni> nice bottom
02:31:50 <osfameron> LeCamarade: ah ok.  (I found ghc easier to install :-)
02:31:59 <oerjan> o_O
02:32:28 <LeCamarade> osfameron: apt-get install ghc hugs --yes --force-yes. Never noticed a thing. :o)
02:33:10 <ski> @src undefined
02:33:11 <lambdabot> undefined =  error "Prelude.undefined"
02:33:15 <osfameron> oh I've never bothered with the --yes stuff (actually I use synaptic mainly...)
02:33:25 <psymort> oerjan: That would make sense because there is no way to know that \x -> undefined will be bottom without x, because until then it's only a partial function (which is a constructed value?)
02:33:48 <quicksilver> psymort: yes, roughly
02:34:02 <psymort> ok.   makes sense
02:34:18 <oerjan> psymort: yes, and the "undefined" could be replaced by something too complicated for the compiler to check even if it tried
02:35:13 <oerjan> something which actually _seemed_ to use x.
02:35:54 <quicksilver> \x -> universalturingmachine(n)
02:35:57 <quicksilver> or something
02:36:01 <ski> such as '\x -> undefined x'
02:36:23 <ski> (equal to 'undefined' by eta-contraction)
02:37:29 <dblhelix> seq (\x -> undefined x)
02:37:42 <dblhelix> ? seq (\x -> undefined x)
02:38:00 <dblhelix> oops, sorry
02:38:00 <ski> this is one case where 'seq' breaks the 'eta' law
02:38:08 <dblhelix> indeed
02:38:16 <ski> > seq (\x -> undefined x) ()
02:38:18 <lambdabot>  ()
02:38:24 <mux> seq seems to break an awful lot of laws
02:38:34 <dblhelix> > seq undefined ()
02:38:36 <lambdabot>  Undefined
02:38:46 <ski> (iirc, there was a similar issue with the 'IO'-monad)
02:38:52 <int-e> seq is unloved by theorists (and probably compiler implementors as well)
02:39:08 <ski> bring back 'Eval' !
02:40:05 <mux> are strictness annotations guilty of the same problems than seq is?
02:40:06 <oerjan> that _is_ something i was wondering.  if ghc is tagless, how can it evaluate seq?
02:40:20 <ski> parametric ones, yes
02:40:27 <int-e> mux: sure. you can define seq with strictness annotations
02:40:33 <ski> data Foo a = F !a
02:40:36 <int-e> > seq !a b = b
02:40:36 <lambdabot>  Parse error
02:40:48 <mux> yeah, that's quite logical indeed
02:40:51 <ski> seq a b = case F a of F _ -> b
02:40:56 <mux> well at least strictness annotations are nicer
02:41:07 <dblhelix> > let myseq !a b = b in myseq undefined ()
02:41:07 <lambdabot>  Parse error in pattern
02:41:12 <oerjan> @src seq
02:41:12 <lambdabot> Source not found. Listen, broccoli brains, I don't have time to listen to this trash.
02:41:17 <ski> they ought to introduce a constraint on 'Eval'
02:41:19 <psymort> @src foldl'
02:41:19 <lambdabot> foldl' f a []     = a
02:41:19 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:41:29 <psymort> So how would you implement foldl' with annotations?
02:41:44 <int-e> @src foldl
02:41:44 <lambdabot> foldl f z xs = lgo z xs
02:41:44 <lambdabot>     where lgo z []     =  z
02:41:44 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
02:41:44 <psymort> @type foldl'
02:41:46 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
02:41:59 <int-e> like that but with  lgo !z   instead of  lgo z
02:42:21 <int-e> hmm. oh. I need to be careful with that claim
02:42:26 <psymort> int-e: really?  Then why doesn't everyone do that?
02:42:29 <Syzygy-> > seq [1..] 5
02:42:32 <lambdabot>  5
02:42:34 <int-e> > foldl' (const 1) undefined [1..4]
02:42:35 <lambdabot>   add an instance declaration for (Num (b -> a))
02:42:43 <Syzygy-> > seq ![1..] 5
02:42:45 <lambdabot>  Couldn't match expected type `Array i e'
02:42:46 <int-e> > foldl' (flip const) undefined [1..4]
02:42:47 <mux> psymort: strictness annotations in function parameters are new since GHC 6.6
02:42:48 <lambdabot>  4
02:42:58 <psymort> mux: I see
02:43:06 <psymort> So not part of 98?
02:43:08 <Syzygy-> Is there some way to force strictness deeper than seq does?
02:43:11 <mux> psymort: indeed
02:43:27 <mux> Syzygy-: as I showed earlier, rnf from Control.Parallel.Strategies and the NFData type class
02:43:36 <Syzygy-> mux: Ah.
02:43:40 <mux> other than that I don't know
02:43:47 <Syzygy-> I've been afk for lunch - so I missed that.
02:43:56 <int-e> psymort: so actually what I said doesn't quite reproduce the strictness semantics of foldl'; it's too strict.
02:44:02 <mux> > rwhnf [1,2,undefined,3]
02:44:05 <mux> > rnf [1,2,undefined,3]
02:44:05 <lambdabot>  ()
02:44:07 <lambdabot>  Undefined
02:44:17 <mux> @type rnf
02:44:19 <dons> int-e, yeah, i think foldl' is buggy -- its not strict enough
02:44:20 <int-e> is rwhnf seq?
02:44:21 <lambdabot> forall a. (NFData a) => a -> Done
02:44:21 <psymort> int-e: oh?  The difference being?
02:44:34 <mux> int-e: it's x `seq` ()
02:44:34 <Syzygy-> :t Done
02:44:36 <lambdabot> Not in scope: data constructor `Done'
02:44:37 <Syzygy-> ?src Done
02:44:38 <lambdabot> Source not found. Just what do you think you're doing Dave?
02:44:41 <mux> Done == ()
02:44:44 <int-e> psymort: foldl' (flip const) undefined [1..4]  is not undefined
02:44:45 <Syzygy-> Ah.
02:44:52 <dons> it should be:
02:44:53 <dons> foldl' f z0 xs0 = go z0 xs0
02:44:53 <dons>   where
02:44:53 <dons>     go !z []     = z
02:44:53 <dons>     go !z (x:xs) = go (f z x) xs
02:45:11 <dons> but its
02:45:11 <dons> foldl' f a []     = a
02:45:11 <dons> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
02:45:27 <mux> @src rwhnf
02:45:27 <lambdabot> Source not found. It can only be attributed to human error.
02:45:31 <dons> > foldl' (flip const) undefined [1,2,3]
02:45:32 <psymort> > foldl' (flip const) undefined [1..4]
02:45:34 <lambdabot>  3
02:45:34 <lambdabot>  4
02:46:01 <dons> so you actually get worse code from ghc here, -- it doesn't generate an unboxed worker/wrapper split properly.
02:46:39 <int-e> I wonder if that change would actually break any code
02:46:55 <ski> > let {foldl' f z0 xs0 = go z0 xs0 where {go !z [] = z; go !z (x:xs) = go (f z x) xs}} in foldl' (flip const) undefined [1,2,3]
02:46:56 <lambdabot>  Parse error in pattern
02:47:10 <dons> i hope not -- no one should depend on precise laziness in particular arguments
02:47:14 <psymort> >foldl' const undefined [1..4]
02:47:16 <dons> since its entirely unspecified.
02:47:26 <oerjan> dons: strangely it would be simpler to write it the way you want, even in H98
02:47:41 <dons> yeah, its a bit strange.
02:47:50 <dons> along with things like sum and length being defined as foldl
02:47:58 <psymort> hmmm....broke lambdabot
02:48:08 <int-e> psymort: you forgot a space
02:48:17 <psymort> > foldl' const undefined [1..4]
02:48:18 <lambdabot>  Undefined
02:48:20 <psymort> int-e: ta
02:49:09 <psymort> ok....but I don't see why 'foldl' (flip const) undefined [1..4]' should be bottom?
02:49:40 <psymort> because (flip const) undefined 1, should be const 1 undefined, which should be 1?
02:49:56 <oerjan> psymort: it's about whether it starts seq'ing at the initializer or after one step
02:49:59 <dons> if you think about the `spec' of foldl' -- that its strict in the accumulator -- you'd imagine passing 'undefined' as the initial accumulator value would result in undefined.
02:50:24 <psymort> dons: ah - ok
02:50:25 <int-e> yep. it makes no sense to have a magical initial lazy step
02:51:22 <int-e> oerjan: I think the   f a | a `seq` True = ... trick is rather new, and without that the definition with a strict accumulator becomes cumbersome I think.
02:51:28 <dons> the various h98ers i've spoken to have all agreed foldl' should be stricter -- as strict as possible. since its not defined in h98, then we can improve it , anyway
02:51:28 <psymort> So it should be strict in the accumulator, whereas the current foldl' is strict in the result of each successive fold
02:52:05 <dons> yeah, bang patterns really make it simpler to specify strictness -- they're a lot clearer.
02:52:10 <dons> yay for bang patterns
02:54:59 <psymort> dons: but I guess seq is implemented in terms of h98?
02:55:05 <psymort> oops...sory
02:55:16 <psymort> dons: but I guess foldl' is implemented in terms of h98?
02:55:31 <dons> foldl' isn't defined in H98
02:55:58 <dons> and it is currently written in terms of `seq` -- it could remain that way, or the bang pattern version could be specified
02:56:07 <psymort> dons: no, that's given, but it only uses h98 concepts - whereas bang patterns aren't h98?
02:56:08 <dons> H' should really have laziness properties for standard functions
02:56:14 <dons> right.
02:56:22 <dons> very cool post, http://programming.reddit.com/info/21bo7/comments
02:56:23 <lambdabot> Title: Playing with Harpy: using Haskell to generating machine code directly into memor ...
02:56:58 <dons> hmm. we should use the Data.Binary put monoid to generating a nice buffer  abstraction for harpy.
02:57:31 <psymort> dons: so an implementation of foldl' using bang patterns might not be portable?  Or is that pretty common now anyway (everyone uses ghc?)
02:57:33 <dblhelix> dons: on a related matter, do you happen to know why the libraries currently define sum in terms of foldl instead of foldl'?
02:57:53 <dons> psymort: it'd be standardised for H'
02:57:53 <Igloo> Because that's what Haskell 98 says
02:58:03 <dons> dblhelix: that's what h98 (incorrectly, imo) says
02:58:17 <dons> but no one sensible does it that way anyway
02:58:25 <psymort> dblhelix: to jump in - I'd say because sum is in h98, and foldl' isn't?
02:58:35 <dons> length l                =  len l 0#
02:58:35 <dons>   where
02:58:35 <dons>     len :: [a] -> Int# -> Int
02:58:35 <dons>     len []     a# = I# a#
02:58:35 <dons>     len (_:xs) a# = len xs (a# +# 1#)
02:58:38 <dons> ghc hehe
02:58:50 <dblhelix> mmm... would it change the strictness properties of sum?
02:59:03 <Igloo> Things like that probably aren't necessary any more
02:59:24 <dblhelix> it would do for non-strict implementations of Num.(+)
02:59:26 <dons> Igloo: interestingly, duncan and I couldn't get that code out of ghc, when writing the streams lib
02:59:36 <dons> we could for some others, with bang patterns, but not length for some weird reason
02:59:59 <Igloo> That's odd. I wouldn't have thought you'd even need a strictness annotation
03:00:01 <dons> sumInt l = sum' l 0
03:00:02 <dons>   where
03:00:02 <dons>     sum' []      a = a
03:00:02 <dons>     sum' (x:xs) !a = sum' xs (a+x)
03:00:06 <dons> this works fine, for example
03:00:26 <dons> Igloo: sure you do, the count in length is never inspected
03:00:53 <Igloo> It's the result, though
03:01:08 <Igloo> so it'll be strict in it
03:01:16 <dons> regarding sum, for strict, atomic types, ghc already uses rewrite rules to pick strict versions of sum, maximum, and others.
03:01:19 <psymort> dons: where can I find info on H'?
03:02:30 <dons> psymort: on the haskell.org website.
03:02:36 <dons> there's a link on the front page
03:03:47 <psymort> dons: ok...that's so obvious it's embarrassing.  But now I get it: H' === Haskell'
03:03:48 <oerjan> int-e: i don't see the need for that trick, couldn't it just use foldl' f a (x:xs) = a `seq` foldl' (f a x) xs ?
03:04:28 <psymort> http://hackage.haskell.org/trac/haskell-prime
03:04:30 <lambdabot> Title: Haskell Prime - Trac
03:06:40 <int-e> oerjan: uhm. yes of course.
03:07:01 <int-e> thanks :)
03:07:19 <Igloo> dons: Hmm, it looks like it's deconstructing the Int dictionary to find the + method (in the HEAD)
03:07:21 <psymort> thanks all....dinner waiting.... :)
03:08:19 <dons> Igloo: ah, could be. most of the non-strict-enough issues we had rewriting Data.List were to do with dictionaries getting floated around.
03:09:39 <Igloo> Oh, it's a quickest HEAD, though, so it could just be that my libraries aren't optimised enough
03:09:49 * Igloo will try to look into it some time
03:12:04 <dons> yeah, it may well be fixed in the head -- there were a fair few changes wrt. strictness/dictionaries and so on, we reported during the streams work
03:14:43 <desp> the Haskell FunPtr generated using a wrapper function is a proper closure, right?
03:40:45 <Alneyan> /
03:43:26 <dons> dcoutts_:       Paper Submission: August 24, 2007
03:44:34 <matthew-_> that's padl
03:45:21 <dons> yup.
03:45:48 <dons> btw, this is a really nice little post, http://programming.reddit.com/info/21bo7/details
03:45:49 <lambdabot> Title: Playing with Harpy: using Haskell to generating machine code directly into memor ...
03:46:03 <matthew-_> is it just me or is haskell the only language that has really practically oriented workshops?
03:46:25 <matthew-_> I've never seen as many papers that actually talk about code as I have with haskell
03:46:28 <dons> hmm, there's no practical perl?
03:46:55 <dons> yeah, we try :-) but haskell is sort of a playground for CS language guys to try out new programming tricks
03:47:07 <dons> so you see these fun papers doing weird things to solve unusual problems.
03:47:20 <dons> e.g. all the boilerplate generics stuff for xml
03:47:28 <dons> now creeping into more boring languages
03:47:34 <matthew-_> yeah, that rings a bell ;)
03:48:19 <desp> dons: cool post
03:48:46 <desp> so this is basically inline assembly?
03:49:38 <dons> yeah, an asm generating library/monad
03:51:21 <desp> it's incredibly cool and wrong at the same time
03:53:26 <osfameron> now all we need is monadic inline Perl and you can really get things done in Haskell!
03:55:38 <desp> ;)
03:56:01 <quicksilver> desp: it's much stronger than inline assembly
03:56:11 <quicksilver> desp: the opcodes can be chosen at run time, not at compile time
03:56:20 <quicksilver> desp: it's an "inline JIT assembler"
03:56:26 <desp> oh.
03:56:37 <quicksilver> I mean, obviously, you *can* choose them at compile time :)
03:56:42 <quicksilver> but the power comes from doing so at runtime
03:56:57 <quicksilver> you can compile your own mini-language into that monad, and thus into assembler, and have runtime code generation
03:57:56 <oerjan> obviously the next step would be a profile-driven JIT compiler for Haskell itself :)
03:58:19 <dons> you could do it at compile time too, inside a TH splice.
03:58:24 <desp> quicksilver: sounds like something I'd use to build a fast VM for last year's ICFP contest
03:58:32 <dons> generating asm for your edls directly in ghc
03:58:59 <LeCamarade> :oO
04:03:17 <matthew-_> eek, under a month until icfp 2007 prog.contest
04:04:09 <matthew-_> better start drinking coffee now...
04:05:29 <Igloo> You don't want to do that, you'll build up a tolerance
04:05:31 <ivanm> matthew-_: won't that just de-sensitise you to the caffeine?
04:09:01 <matthew-_> yeah, I know.
04:09:13 <matthew-_> but there's time to detox between now and then
04:09:27 <matthew-_> I must see how much I can take before having a heart attack...
04:12:07 <matthew-_> have there been any fatalities attributed to the ICFP prog.contest previously?
04:15:06 <ivanm> lol
04:15:28 <araujo> morning
04:23:31 <_frederik_> is there something with type restricted to a -> a -> a which is (\x y -> y)? it seems like it would be useful for type assertions
04:24:01 <_frederik_> ah, asTypeOf hehe
04:24:35 <_frederik_> or rather 'flip asTypeOf' as i've stated it
04:25:54 <quicksilver> yes, and you're right, it's useful for type assertions
04:26:30 <quicksilver> although it's essentially un-necessary in the presence of ghc's generalised type signatures
04:28:42 <int-e> unnecessary, maybe, but in some cases where type signatures would be very long a function of suitable restricted type actually saves typing.
04:30:32 * int-e has been using functions like  stArray :: STArray i e -> STArray i e; stArray = id   to resolve MArray instances, for example.
04:30:54 <int-e> err. STArray s i e
04:32:52 <_frederik_> yeah me too
04:33:31 <_frederik_> it would be nice if i could leave parts of type signatures unspecified with '_'. usually most of the signature can be inferred by the compiler and i only want to specify a small part of it.
04:33:46 <_frederik_> (especially class constraints)
04:33:56 <int-e> I agree, that would be neat.
04:35:21 <int-e> > let x :: m Rational -> m Rational; x = id in x (Just 1)
04:35:23 <lambdabot>  Just (1%1)
04:36:16 <Syzygy-> > (3%2) + (3%4)
04:36:19 <lambdabot>  9%4
04:36:42 <int-e> > 3%6 + 1.001
04:36:44 <lambdabot>  1501%1000
04:37:09 <int-e> > 3%6 + toRational 1.001
04:37:12 <lambdabot>  3379951520341557%2251799813685248
04:37:31 <Syzygy-> o.O
04:37:46 <int-e> type classes and defaulting. very confusing :)
04:37:51 <Syzygy-> > 0%1 + 1.001
04:37:52 <lambdabot>  1001%1000
04:37:58 <Syzygy-> > toRational 1.001
04:38:01 <lambdabot>  2254051613498933%2251799813685248
04:38:06 <Syzygy-> Wtf?
04:38:16 <quicksilver> that converts 1.001 to a Double
04:38:20 <Syzygy-> > toFloat $ toRational 1.001
04:38:21 <quicksilver> where it can't be stored exactly
04:38:21 <lambdabot>   Not in scope: `toFloat'
04:38:27 <Syzygy-> quicksilver: Ah. :-/
04:38:29 <int-e> 2251799813685248 is a power of 2
04:38:30 <quicksilver> and then converts it back to rational
04:38:37 <Syzygy-> Weird.....
04:38:42 <quicksilver> it's defaulting
04:38:49 <quicksilver> > (1.001 :: Rational)
04:38:51 <lambdabot>  1001%1000
04:38:55 <_frederik_> > toRational 0.5
04:38:57 <quicksilver> you can have exact decimals :)
04:38:57 <lambdabot>  1%2
04:39:01 <quicksilver> just don't let it default on you
04:39:16 <int-e> @type 1.001
04:39:19 <lambdabot> forall t. (Fractional t) => t
04:39:45 <quicksilver> > (22/7 :: Rational)
04:39:48 <lambdabot>  22%7
04:39:52 <quicksilver> omg! it's pi!
04:39:59 <int-e> nonono
04:40:03 <int-e> > toRational pi
04:40:05 <lambdabot>  884279719003555%281474976710656
04:40:08 <sioraiocht> eww, 22/7 is NOT pie
04:40:08 <int-e> that's pi ;-)
04:40:16 <Syzygy-> int-e: Hrm.
04:40:28 <mux> > atan (-1) * (-4)
04:40:31 <lambdabot>  3.141592653589793
04:40:37 <sioraiocht> THAT's pie
04:40:41 <mux> ;-)
04:40:42 <sioraiocht> pi even
04:40:42 <int-e> > atan (-1) * (-4) == pi
04:40:44 <lambdabot>  False
04:40:48 <sioraiocht> lol
04:40:50 <Syzygy-> HAHAHA!
04:40:53 <sioraiocht> > pi
04:40:54 <mux> heh
04:40:55 <lambdabot>  3.141592653589793
04:40:55 <Syzygy-> Yeah, right....
04:41:05 <Syzygy-> > pi - atan (-1) * (-4)
04:41:07 <lambdabot>  -1.22514845490862e-16
04:41:12 <Syzygy-> Pbtbtbtbtbbtbtbt
04:41:26 <sioraiocht> gotta love IEEE 754
04:41:44 <_frederik_> i blame euler
04:41:58 <mux> I blame god
04:42:20 <_frederik_> that too
04:42:37 <sioraiocht> > e
04:42:38 <lambdabot>   Not in scope: `e'
04:42:40 <sioraiocht> no e?
04:42:59 <_frederik_> > exp 1
04:43:00 <lambdabot>  2.718281828459045
04:43:07 <sioraiocht> touché
04:43:15 <_frederik_> > exp (exp 0)
04:43:17 <lambdabot>  2.718281828459045
04:43:32 <sioraiocht> @src exp
04:43:32 <lambdabot> Source not found. Maybe if you used more than just two fingers...
04:43:43 * sioraiocht kicks lamdabot.
04:44:11 <Syzygy-> :t fix
04:44:13 <lambdabot> forall a. (a -> a) -> a
04:44:17 <Syzygy-> > fix exp
04:44:19 <lambdabot>  Exception: <<loop>>
04:44:23 <Syzygy-> :P
04:44:36 <Syzygy-> > fix (exp -1)
04:44:37 <lambdabot>   add an instance declaration for (Num (a -> a))
04:44:49 <Syzygy-> > fix (\l -> (exp l)-1)
04:44:51 <lambdabot>  Exception: <<loop>>
04:44:51 <mux> > fix (:1)
04:44:52 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
04:44:53 <lambdabot>       Expected...
04:45:00 <Syzygy-> > fix (1:)
04:45:02 <int-e> sioraiocht: in ghc they just map to expFloat# and expDouble# which presumably use the libc function.
04:45:02 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:45:16 <mux> fix ((1:) . scanl (+) 1)
04:45:22 <mux> > fix ((1:) . scanl (+) 1)
04:45:23 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
04:45:24 <sioraiocht> int-e: ah
04:45:27 <Syzygy-> Hehe
04:45:48 <int-e> > break (<100) $ fix ((1:) . scanl (+) 1)
04:45:52 <lambdabot>  ([],[1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,1094...
04:46:02 <int-e> > break (>100) $ fix ((1:) . scanl (+) 1)
04:46:03 <lambdabot>  ([1,1,2,3,5,8,13,21,34,55,89],[144,233,377,610,987,1597,2584,4181,6765,10946...
04:46:15 <mux> > nubBy (\x y -> gcd x y > 1) [2..]
04:46:18 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:46:28 <Syzygy-> mux: Oooooooooh!
04:46:39 <mux> this one is the absolute cutest one-liner
04:46:40 <dons> ?pl \x y -> gcd x y > 1
04:46:40 <lambdabot> flip flip 1 . ((>) .) . gcd
04:46:50 <LeCamarade> <lambdabot> Enough!
04:47:04 <mux> > nubBy ((>1 .) . gcd) [2..]
04:47:04 <lambdabot>  Parse error
04:47:06 <Syzygy-> @slap lambdabot
04:47:06 <lambdabot> why on earth would I slap lambdabot
04:47:10 <sioraiocht> mux: that's the same as a sieve, right?
04:47:12 <mux> > nubBy (((>1) .) . gcd) [2..]
04:47:13 <Syzygy-> Ooooooh, that one got fixed!
04:47:14 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:47:18 <Syzygy-> sioraiocht: Of course it is.
04:47:22 <dons> ?pl \y -> 1 <= gcd x y
04:47:22 <lambdabot> (1 <=) . gcd x
04:47:30 <dons> ?pl \x y -> 1 <= gcd x y
04:47:30 <lambdabot> ((1 <=) .) . gcd
04:47:37 <sioraiocht> Syzygy-: it's morning where I am, and I'm groggy =p
04:47:39 <int-e> > nubBy (\x y -> mod y x == 0) [2..] -- not an equivalence relation. evil!
04:47:41 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
04:47:44 <Syzygy-> sioraiocht: Hehe
04:47:47 <Syzygy-> sioraiocht: Where's that?
04:47:49 <sioraiocht> Syzygy-: I spelled pi as pie =p
04:47:54 <sioraiocht> Syzygy-: upstate NY
04:47:55 <mux> hmmmm, pie
04:47:58 <Syzygy-> Ah.
04:48:05 <dons> ?pl \x y -> 0 == mod y x
04:48:05 <lambdabot> ((0 ==) .) . flip mod
04:48:17 <Syzygy-> The place that didn't want me to teach college maths recently... :P
04:48:24 * Syzygy- almost applied for a position at Vassar
04:48:45 <sioraiocht> ah, are you faculty somewhere else right now?
04:48:46 <Syzygy-> But by the time I got more info, I had decided I couldn't take it, and they told me they'd already found someone.
04:48:50 <Syzygy-> Gods no!
04:48:54 <Syzygy-> I'm still grad student.
04:49:05 <sioraiocht> where?
04:49:09 <Syzygy-> Jena, Germany.
04:49:30 <sioraiocht> neat! :)
04:49:59 <sioraiocht> in mathematics, obviously?
04:50:07 <Syzygy-> Naturally.
04:50:17 <Syzygy-> Aoo-algebras, group cohomology, and computation thereof.
04:50:31 <sioraiocht> *blinks*
04:50:45 <Syzygy-> But now I need to run to get hold of some more cold coca cola before todays seminar...
04:50:53 <sioraiocht> hahah
04:51:04 <matthew-_> wow, even mathematicians have the same concerns as the rest of us!
04:51:07 <sioraiocht> well, coca cola tastes different in the US, just to warn you =p
04:51:11 <matthew-_> "staying awake during lectures"
04:51:25 <sioraiocht> matthew-_: so weird, like watching a dog walk on its hind legs.
04:51:34 <Syzygy-> matthew-_: It's more along the lines of "Gods, I don't want to go - need to bribe myself!"
04:51:49 <Syzygy-> matthew-_: What is? Seeing a mathematician?
04:51:55 <Syzygy-> sorry, that was for sioraiocht
04:52:03 * Syzygy- doesn't feel like a dog
04:52:06 <Syzygy-> Though I do walk upright.
04:52:24 <sioraiocht> Syzygy-: hahah I meant mathematicians exhibiting human-like characteristics
04:52:36 <Syzygy-> HAHAHAHAHAHAHAHA
04:52:47 <matthew-_> I guess there's not much precedence for it
04:52:57 <Syzygy-> Well, ehm, I do not know how to say this gracefully, but ... I've seen more humans among mathematicians than among CS folk. :P
04:53:04 <Syzygy-> Admitted, we're an airy-headed lot.
04:53:07 <Syzygy-> But still!
04:53:12 <matthew-_> yeah, you get females doing maths...
04:53:21 <Syzygy-> And now I -really- need to get away from my keyboard...
04:53:31 <matthew-_> take it with you!
04:53:39 <Syzygy-> matthew-_: And we have people doing maths -and- getting laid. Some of them simultaneously. :P
04:53:44 <int-e> > fix ((1:) . map (read . (>>= liftM2 (:) head (show . length)) . group . show))
04:53:46 <lambdabot>  [1,11,12,1121,122111,112213,12221131,1123123111,12213111213113,1122113113211...
04:53:51 <matthew-_> rotfl
04:53:52 <Syzygy-> int-e: Love it!
04:54:01 <sioraiocht> Syzygy-: touché =p
04:54:04 <Syzygy-> int-e: Didn't I write a similar oneliner on my blog once?
04:54:26 <int-e> Oh, was that you? I've seen something like that recently, yes.
04:54:43 <mux> int-e: nice eone :-)
04:54:55 <int-e> had fun reproducing it though.
04:54:59 <Saizan> isn't it reversed?
04:55:03 <sioraiocht> is this what goes on all night? this is what leaves 3k lines in my IRC logs? =p
04:55:13 <quicksilver> yes it's wrong
04:55:20 <matthew-_> sioraiocht: it's midday!
04:55:21 <quicksilver> '12' is read '1112'
04:55:22 <int-e> oh, it's reversed indeed. heh. :)
04:55:25 <quicksilver> not '1121'
04:55:46 <matthew-_> no
04:55:50 <matthew-_> ww
04:55:53 <quicksilver> indead, '11' is read '21' not '12' :)
04:55:56 <sioraiocht> matthew-_: you lie
04:55:57 <int-e> fix ((1:) . map (read . (>>= liftM2 (++) (show . length) (take 1)) . group . show))
04:56:00 <int-e> this then.
04:56:23 <quicksilver> > fix ((1:) . map (read . (>>= liftM2 (++) (show . length) (take  1)) . group . show))
04:56:23 <matthew-_> @remember Syzygy- And we have people doing maths -and- getting laid. Some of them simultaneously. :P
04:56:24 <lambdabot> Done.
04:56:25 <lambdabot>  [1,11,21,1211,111221,312211,13112221,1113213211,31131211131221,1321131112311...
04:57:15 <quicksilver> does every entry after the 5th contain at least one '3' ?
04:57:24 <int-e> yes
04:57:32 <int-e> once a digit is there it never disappears
04:57:46 <quicksilver> oh, of course
04:57:49 <quicksilver> duh
04:58:11 <quicksilver> I was thinking of 3s in the first place, not the second
04:58:19 <int-e> > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d
04:58:19 <quicksilver> as in '31' not '13'
04:58:19 <lambdabot>  Parse error
04:58:24 <int-e> sight
04:58:33 <int-e> > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d e = s d (+) $ s e (-) $ m (d+1) (e+2) in fix ((1:) . m 1 3)
04:58:35 <lambdabot>  [1,1,2,3,5,7,11,15,22,30,42,56,77,101,135,176,231,297,385,490,627,792,1002,1...
04:58:59 <quicksilver> what's that?
04:59:25 <int-e> the number of partitions of n, for n = [0..]
05:00:09 <quicksilver> nod
05:00:35 <int-e> Using Euler's pentagonal number formula. I'm rather proud of it.
05:00:53 <quicksilver> it's very nice
05:02:58 <LeCamarade> int-e: So that's what the int in your name meant all along?
05:03:45 <int-e> LeCamarade: I don't know what you mean, but you're probably wrong.
05:04:18 <LeCamarade> That you love ints. :o)
05:04:31 <LeCamarade> integer stuff all over ... makes my head hurt. :o(
05:04:50 <LeCamarade>  > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d e =
05:04:53 <LeCamarade>  > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d e =
05:04:54 <LeCamarade>  > let s n f g xs = take n xs ++ zipWith f (drop n xs) (g xs); m d e =
05:05:00 <LeCamarade> Ouch.
05:05:23 <gkr> Where can I find the definition of mplus for lists?
05:05:35 <int-e> @src [] mplus
05:05:35 <lambdabot> mplus = (++)
05:05:46 <mux> ooooh, neat
05:05:54 <mux> @src [] (>>=)
05:05:54 <lambdabot> m >>= k     = foldr ((++) . k) [] m
05:06:06 <mux> @src Maybe (>>=)
05:06:06 <lambdabot> (Just x) >>= k      = k x
05:06:06 <lambdabot> Nothing  >>= _      = Nothing
05:06:37 <gkr> int-e why do you need to pass it the [] thing?
05:06:47 <mux> to get the proper instance
05:06:54 <mux> @type mplus
05:07:03 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => m a -> m a -> m a
05:07:12 <gkr> @src mplus::([a]->[a]->]a)
05:07:12 <lambdabot> Source not found. Where did you learn to type?
05:07:16 <gkr> @src mplus::([a]->[a]->[a])
05:07:17 <lambdabot> Source not found. stty: unknown mode: doofus
05:07:18 <mux> mplus is defined differently for any instance of MonadPlus
05:07:23 <quicksilver> gkr: mplus is a method, you need to tell it which instance you want
05:07:35 <gkr> But, [] is the way to tell it you want for lists?
05:07:43 <gkr> @src Maybe mplus
05:07:44 <lambdabot> Nothing `mplus` ys  = ys
05:07:44 <lambdabot> xs      `mplus` _ys = xs
05:07:44 <int-e> gkr: it's defined in Control.Monad, fwiw
05:07:48 <gkr> Ah, ok.
05:07:50 <gkr> Thanks.
05:07:53 <int-e> [] a  is  [a]
05:08:05 <int-e> for types at least.
05:08:15 <int-e> i.e. [] is the list type constructor
05:09:00 <int-e> @src [a] mempty
05:09:00 <lambdabot> Source not found. My mind is going. I can feel it.
05:09:14 <quicksilver> [] is irregular in that it is used rather different as a type constructor and data constructor
05:09:21 <quicksilver> differently
05:09:25 <mux> [] is of kind * -> *
05:09:28 <mux> [a] is of kind *
05:09:35 <quicksilver> this is potentially confusing although surprisingly few people get confused by it :)
05:10:37 <int-e> > mconcat [EQ, EQ, LT, EQ, GT]
05:10:39 <lambdabot>  LT
05:11:43 <crazy_coder> hello everyone
05:12:13 <crazy_coder> I was wondering if anyone can suggest me a small project which I can implement in Haskell
05:13:00 <crazy_coder> I have never really worked on anything big before. So I want to start writing a small application maybe and then do something bigger
05:13:28 <gkr> An small language interpreter.
05:13:33 <crazy_coder> I have to still learn monads and stuff. Just completed the basic haskell
05:13:52 <crazy_coder> what does a language interpreter do ?
05:14:04 <crazy_coder> parse and then evaluate ?
05:14:09 <gkr> Yep.
05:14:27 <crazy_coder> hmm
05:14:33 <gkr> There're some parsing tools already done, you can use that for parsing, and just implement the evaluator.
05:14:46 <Philippa_> hell, you can start by deriving Read on your AST type
05:14:47 <crazy_coder> Thanks for the idea
05:15:02 <crazy_coder> AST type ?
05:15:05 <Philippa_> though you don't want to go too far before you write the parser, 'cos the syntax gets painful
05:15:07 <mux> if you want to learn monads and also need to parse stuff, Parsec is what you need, clearly
05:15:09 <Philippa_> "Abstract Syntax Tree"
05:15:12 <mux> or PP
05:15:13 <Philippa_> the thing the parser spits out
05:15:55 <crazy_coder> So parser is a good idea to start with as a project, it seems
05:16:37 <crazy_coder> Thanks everyone :)
05:17:08 <titto> talking about parsers, has anyone experience with frisby (http://repetae.net/computer/frisby/) ?
05:19:14 <crazy_coder> is there anything simpler ?
05:26:41 <crazy_coder> :)
05:26:58 <crazy_coder> Silence is golden
05:28:13 <DRMacIver> The traditional suggestion for toy Haskell projects is to reimplement your favourite unix command line tools.
05:28:35 <gkr> crazy_coder you can implement Huffman coding...
05:29:01 <crazy_coder> Ok
05:29:06 <gkr> Or graphs and DFS, BFS, Prime's algorithm, Kruskal's algorithm, etc.
05:29:10 <crazy_coder> :) Thanks
05:29:26 <crazy_coder> Yeah right, I wanted to implement all algos
05:30:00 <crazy_coder> Haskell is really cool. We can be really productive with it.
05:30:01 <mdmkolbe|work> crazy_coder: or a modular monadic interpreter (usually it's best to skip the parser and go strait to interpreting the AST if you go that route) (WARNING: contains high monad content and has been known to cause permanent brain warpage)
05:30:44 <DRMacIver> Write a javascript to unlambda compiler.
05:31:02 <crazy_coder> If we do a project in Haskell can we write it in our resume or is a project in Haskell considered very easy and hence trivial ?
05:31:31 <DRMacIver> And here I thought photon torpedo was fictional.
05:32:22 <profmakx> reimplement meat-axe in haskell, be faster than the c version *cough*
05:32:38 <crazy_coder> meat- axe ?
05:32:40 <ttfh> I mention Haskell as an interest in my CV, I figure not many people who read my CV will know what Haskell is, but those who know will like it
05:32:55 <DRMacIver> aol.
05:32:59 <mdmkolbe|work> crazy_coder: most resume styles that I'm familiar with don't include past projects, unless they were part of a job or maybe a semester long project with a significant deliverable
05:33:45 <gkr> crazy_coder I would upload my projects to a web page, and write down the url on the resume.
05:33:46 <crazy_coder> Actually the CV will be helpful for my PG admissions which is 2-3 yrs away
05:34:01 <dons> ok, now this is getting seriously cool, http://programming.reddit.com/info/21cel/comments
05:34:03 <lambdabot> Title: Writing a simple x86 compiler in Haskell (reddit.com)
05:34:05 <mdmkolbe|work> PG = graduate school?
05:34:14 <dons> augustus is on a roll today.
05:34:19 <crazy_coder> I am an undergraduate
05:34:31 <crazy_coder> Will be applying for post graduation
05:35:30 <crazy_coder> So to improve my chances of landing in a great US univ, I must do as many 'significant' projects as I can
05:35:46 <dons> this whole x86-compiler-in-20-lines is really nice
05:36:05 <mdmkolbe|work> crazy_coder: can you find a professor to do something like an honors project with?
05:36:20 <gkr> crazy_coder or do some stuff for Google SoC.
05:36:45 <crazy_coder> yeah, thats fine. But is a Haskell project considered good enough ?
05:36:53 <mdmkolbe|work> crazy_coder: or maybe take a graduate level course in haskell (I did it, it was hard but doable)
05:37:05 <mdmkolbe|work> crazy_coder: depends on how much the project does
05:37:40 <crazy_coder> They don't have a haskell course in my coll . But I am learning it myself because its real fun and exciting
05:37:44 <dons> @remember lennart I mean a real machine-code compiler, not some wimpy byte-code nonsense
05:37:44 <lambdabot> Done.
05:37:58 <mdmkolbe|work> crazy_coder: writting a lambda calculus interpreter is nice, but not really significant.  But writting the Yi editor is significant
05:38:02 <mdmkolbe|work> @where Ti
05:38:02 <lambdabot> I know nothing about ti.
05:38:05 <mdmkolbe|work> @where Yi
05:38:05 <lambdabot> http://www.cse.unsw.edu.au/~dons/yi.html
05:38:13 <mdmkolbe|work> (just as an example)
05:38:43 <dons> yeah, or work on libraries. we also have a set of haskell thesis projects you could look at . let me see..
05:39:01 <crazy_coder> mdmkolbe|work: you are right. Thats why I want to do some small projects first, so that till the end of this semester , I can think about something as good as Yi
05:39:05 <dons> here http://www.cse.unsw.edu.au/~pls/thesis-topics/
05:39:05 <lambdabot> Title: PLS 4th Year Thesis Topics
05:39:06 <chrismbrown> crazy_coder: does your undergraduate degree have some form of final year dissertation?
05:39:31 <dons> btw I think the `A window manager scriptable in Haskell' got done. so don't pick that one.
05:39:53 <mux> heh
05:40:00 <crazy_coder> what is dissertation? If it means a project, yes we have to do a big project in final year
05:40:12 <dons> this is a realy, really good post. i hope everyone is reading it: http://programming.reddit.com/info/21cel/comments
05:40:13 <lambdabot> Title: Writing a simple x86 compiler in Haskell (reddit.com)
05:40:24 <ivanm> why? cos its yours? :p
05:40:26 * mux opens link
05:40:29 <dons> x86 compiler, in haskell, in memory, in ou 20 liines or so.
05:40:37 <kolmodin> I just did :)
05:41:06 <chrismbrown> crazy_coder: I guess the question to ask is why would you use Haskell (over any other language) to implement the project you choose? Try to pick a project that has a motivation for using Haskell
05:41:14 <dons> and to think i spent my time at the start of the year generating C, and compiling that, from haskell.
05:41:25 <dons> shoulda just done the inner loops directly into memory
05:41:38 <ivanm> lol
05:41:41 <dons> kolmodin: we should look at fast bytestring buffers in this x86 code gen one day.
05:41:48 <ivanm> how much of assembler does that implement?
05:42:03 <int-e> harpy does that. hmm..
05:42:07 <dons> standard x86, i think.
05:42:16 <crazy_coder> chrismbrown: actually in Haskell I can do a lot of good projects in comparatively less time. Thats the main thing
05:42:17 <ivanm> the whole lot? nice!
05:42:20 <dons> int-e, you know the polymer simulation paper i'm talking about?
05:42:43 <dons> that was all 'generate C, optimise the C, link it back in and call it' -- like this, but less pretty :-)
05:43:01 <int-e> were those monte carlo simulations?
05:43:04 <dons> yeah
05:43:11 <int-e> ok, then I know it.
05:43:18 <kolmodin> dons: yeah, really cool :)
05:44:38 <crazy_coder> dons: why is it that when installing dependencies for Xmonad we have to do configure ..... path=/home/dons ? Have you written most of it ?
05:44:41 <chrismbrown> crazy_coder: sure, but I guess I'm bringing up a question of *why* is this better in Haskell -- I'm thinking this is content you can write for your project!
05:45:22 <sphynx> hi!
05:45:41 <dons> crazy_coder: i think that's been updated. use $HOME unless your user name is dons
05:45:49 <sphynx> I'm a bit confused with division and Double numbers in Haskell
05:45:56 <dons> crazy_coder: and yeah, i wrote that bit of the readme, it seems
05:46:07 <dons> sphynx: ah yes?
05:46:09 <crazy_coder> chrismbrown: I agree. anyways lets not argue :) I will first decide what I can do ;)
05:46:19 <chrismbrown> crazy_coder: I wasn't arguing!
05:46:20 <dons> > length "haskell " / 2 -- like this, sphynx (/me guesses)
05:46:21 <lambdabot>   add an instance declaration for (Fractional Int)
05:46:22 <lambdabot>     In the expression: (le...
05:46:35 <dons> > length "haskell " `div` 2 -- int division
05:46:37 <lambdabot>  4
05:46:47 <crazy_coder> chrismbrown: yeah I know sorry to hurt you :)
05:46:49 <dons> > fromIntegral (length "haskell ") / 2 -- floating point
05:46:51 <lambdabot>  4.0
05:46:52 <sphynx> I have following code: let a = length some1; let b = length some2; let m = InfoItem (DoubleValue (a/b)) "blabla"
05:46:57 * dons wins!
05:46:59 <apfelmus> > genericLength "haskell" / 2
05:47:00 <lambdabot>  3.5
05:47:01 <mux> > length "haskell" + length "curry" `div` 2
05:47:03 <lambdabot>  9
05:47:18 <dons> sphynx: genericLength, or use integer division (div)
05:47:31 <sphynx> but I need ration of two numbers
05:47:31 <apfelmus> > length "haskell"
05:47:33 <lambdabot>  7
05:47:41 <apfelmus> eh??
05:47:48 <sphynx> so I need to divide 42423 / 3123123 and get some Double
05:47:50 <apfelmus> > fromIntegral (length "haskell ") / 2
05:47:52 <lambdabot>  4.0
05:47:58 <apfelmus> > 7.0 / 2.0
05:47:59 <lambdabot>  3.5
05:48:01 <dons> sphynx: right. the issue is that 'length' returns Int
05:48:16 <dons> so you need to convert that to a Double, (using fromIntegral), or use genericLength to get a Double directly
05:48:24 <apfelmus> dons: ehm
05:48:27 <mux> I'd like it if length could become genericLength (same for take, drop, etc) for Haskell'
05:48:31 <sphynx> dons: Oh, I got it, cool
05:48:37 <sphynx> I will try. Thanks!
05:48:53 <apfelmus> dons: fromIntegral (length "haskell") does strange this.
05:49:08 <dons> apfelmus: ?
05:49:16 <int-e> harpy has pretty complete integer operation support. some more obscure operations are missing, like aam and aad (but they're rarely useful) FPU support seems to be planned.
05:49:17 <apfelmus> > length "haskell"
05:49:20 <lambdabot>  7
05:49:27 <sphynx> is there some article or manual about number types transformation in Haskell?
05:49:29 <apfelmus> dons: but 7/2 is never 4.0
05:49:35 <quicksilver> apfelmus: you had a stray space
05:49:38 <dons> didn't i have a trailing whitespace?
05:49:43 <apfelmus> ah
05:49:44 <chrismbrown> how the hell do you get out of emacs!?
05:49:46 <apfelmus> phew :)
05:49:50 <quicksilver> C-x C-c
05:49:50 <dons> > fromIntegral (length "haskell ") / 2 -- ah yes :-)
05:49:52 <lambdabot>  4.0
05:49:53 <quicksilver> or File > Quit
05:49:53 <dons> math is not broken! phew.
05:50:00 <chrismbrown> ah thanks!
05:50:14 <pastorn> dons: have you decided/gotten an animal for real world haskell yet?
05:50:15 <dons> chrismbrown: a revolver also should work.
05:50:17 <quicksilver> this message is displayed clearly on the banner when you launch emacs for the first time
05:50:29 <dons> pastorn: no, we've not talked about it. apparently they have a designer to pick these things :-)
05:50:30 <chrismbrown> dons: yes I did consider shooting myself out of pure frustration
05:50:33 <mdmkolbe|work> quicksilver: unless you do "emacs filename"
05:50:36 <int-e> . o O ( M-x shell Enter  *ducks*
05:50:49 <sphynx> :src genericLength
05:50:58 <sphynx> ?src genericLength
05:50:58 <lambdabot> genericLength []    = 0
05:50:58 <lambdabot> genericLength (_:l) = 1 + genericLength l
05:51:07 <dons> genericLength           :: (Num i) => [b] -> i
05:51:07 <dons> genericLength []        =  0
05:51:07 <dons> genericLength (_:l)     =  1 + genericLength l
05:51:10 <dons> oh, there it is.
05:51:23 <pastorn> dons: what would you pick if it was up to you? what is the "haskelliest" animal?
05:51:26 <dons> classic haskell, really.
05:51:32 <dons> pastorn: hmmm. not sure!
05:51:33 <int-e> @type sum . map (const 1)
05:51:35 <lambdabot> forall a a1. (Num a) => [a1] -> a
05:51:39 <dons> a unicorn?
05:51:42 <apfelmus> curried chicken perhaps
05:51:47 <pastorn> haha
05:52:04 <mux> what about the haddock?
05:52:09 <mux> that was a pretty good fit
05:52:14 <int-e> > foldl' (const (+1)) 0 "Hello, world!"
05:52:15 <lambdabot>   add an instance declaration for (Num Char)
05:52:20 <crazy_coder> how about a cheetah for being Fast
05:52:24 <dons> some animal too beautiful for this world.
05:52:40 <mdmkolbe|work> butterfly
05:52:40 <int-e> > foldl' (const . (+1)) 0 "Hello, world!"
05:52:42 <lambdabot>  13
05:52:50 <apfelmus> well, some people probably think that a beholder would be appropriate
05:52:53 <crazy_coder> :)
05:52:54 <mdmkolbe|work> (or sloth for being lazy)
05:52:55 <quicksilver> dons: really, it should be defined as foldr (const (1+)) or somethiing
05:53:00 <mux> the dodo!
05:53:07 <quicksilver> yeah, that's what I meant :)
05:53:16 <crazy_coder> or a cat
05:53:25 <apfelmus> isn't the dodo extinct?
05:53:32 <mux> precisely
05:53:33 <dons> yeah, not sure the dodo is terribly good
05:53:36 <pastorn> mux: cool idea, might send the wrong message though
05:54:11 <ToRA> crazy_coder: cat has been taken for SQL pocket reference
05:54:15 <pastorn> a jawning lion...
05:54:16 <quicksilver> the phoenix?
05:54:19 <dons> a gryphon?
05:54:29 <apfelmus> ha, i want a dragon!
05:54:29 <mux> I like the unicorn idea too
05:54:31 <dons> hmm. phoenix eh. rising from the ashes of lisp? :-)
05:54:35 <mux> a dragon would rock :)
05:54:41 <dons> oh, a dragon. yeah, that'd be cool
05:54:42 <mux> Ancalagon the Black
05:54:47 <pastorn> hehe
05:54:53 <mux> or Smaugh the Golden
05:54:53 <ToRA> a sloth? (it's lazy...)
05:55:21 <mux> an Ent :-)
05:55:22 <dons> gryphons and dragons. i like the gryphon in alice in wonderland. that'd fit.
05:55:29 <dons> ah yes, this guy: http://en.wikipedia.org/wiki/Image:Gryphon.gif
05:55:30 <lambdabot> Title: Image:Gryphon.gif - Wikipedia, the free encyclopedia
05:55:59 <quicksilver> tbh, I think something mythical gives a bad impression, too
05:56:11 <mux> do we really care?
05:56:13 <quicksilver> I like that shrimp with the incredible powerful jaw that someone posted on the -cafe
05:56:29 <gwern> when you use forkIO on something and that somethign would use putStrLn, would the string show up on stdout or does it just vanish because the forkIO has detached?
05:56:32 <pastorn> mux: would you buy a book with a haddock on the cover?
05:56:37 <mux> do you sincerely think the amount of people that are going to use haskell is going to vary significantly depending on wether we use an extinct animal or not? or a mythical one?
05:56:41 <quicksilver> gwern: it shows up
05:56:46 <quicksilver> gwern: no 'detaching' goes on
05:56:53 * pastorn hits the shower
05:56:56 <quicksilver> gwern: all your threads have access to file descriptions
05:56:57 <mux> oh yeah, the california shrimp
05:56:59 <gwern> quicksilver: really? weird then...
05:57:03 <dons> well, unicorns are obviously mythical. but dragons and gryphons are just cool
05:57:10 <quicksilver> gwern: descriptors
05:57:23 <mdmkolbe|work> does haskell have an existing mascot?
05:57:29 * gwern wonders why I'm not seeing output then
05:57:29 <mux> we have dons :)
05:57:43 <dons> there''s the lambda potato
05:57:44 <Saizan> lambdabot:
05:57:47 <crazy_coder> dons is a Don
05:57:50 <mux> lambdaman !
05:57:50 <gwern> I personally think we should go with diatoms meself
05:58:01 <apfelmus> superlambda!
05:58:02 <dons> oh, yeah, lambdaman
05:58:03 <mux> we need some lambdaman art
05:58:05 <mdmkolbe|work> @go lambda potato
05:58:06 <dons> he always saves the day.
05:58:06 <quicksilver> gwern: paste the code?
05:58:08 <gwern> lambdaman, lambda, reducing the lamdas he can...
05:58:09 <lambdabot> http://www.flickr.com/photos/loafer/490794391/
05:58:09 <lambdabot> Title: The Lambda Potato on Flickr - Photo Sharing!
05:58:48 <dons> ?go wadler lambdaman
05:58:53 <lambdabot> http://www.kinja.com/kindigest.knj?url=lambdaman.blogspot.com
05:58:53 <lambdabot> Title: One for the Morning Glory - browse related sites - Kinja, the weblog guide
05:58:59 <gwern> quicksilver: 'main = do mapM_ (forkIO . archiveURL)' ... 'archiveURL url = do B.putStrLnurl; openURL("....'
05:59:11 <gwern> quicksilver: could it be the mapM_?
05:59:35 <quicksilver> B.putStrLn hmmm
06:00:18 <quicksilver> how long is the list your mapM_'ing over? roughly?
06:00:20 <mux> lambdaman protects the world from the villain side-effects using his monadic powers
06:00:47 <dons> yeah, lambdaman is my hero
06:00:50 <int-e> unsafeStopLaunchingMissiles
06:01:04 <dons> we need some nice `sin city' style cartoon scenes with lambdaman kicking butt
06:01:11 <mux> yes
06:01:16 <mux> I wish I could draw
06:01:18 <apfelmus> you mean beta-reducing butt
06:01:33 <dons> defeating evil powers with his mighty graph machine!
06:02:13 <dons> and wrapping up his enemies in monadic bubbles
06:02:15 <int-e> then he discovers `par`, goes bad and we get to make a Matrix 3 remake.
06:02:19 <apfelmus> he traps enemies in an infinite list!
06:02:39 <dons> mwhaha! lambdaman triumphs over evil and dynamic typing!
06:02:59 <mux> lambdaman makes duck typing go quack
06:03:01 <dons> your side effects are useless on lambdaman!
06:03:19 <int-e> dons: that's not true :)
06:03:33 <mux> lambdaman purifies side-effects
06:03:35 <quicksilver> could we have count duckula doing a cameo to represent duck typing?
06:03:43 <int-e> on the contrary, without side effects, lambdaman would be powerless.
06:03:44 <apfelmus> "Bite the _|_, villain!"
06:03:47 <mux> hah
06:04:02 <dons> but you must be careful with his fatal flaw ... krypto^h^h^h unsafePerformIO
06:04:07 <int-e> of course lambdaman would have to be lazy
06:04:21 <TSC> He'd only rescue people on demand
06:04:32 <mux> because lambdaman is call-by-need
06:04:42 <kaol> and nobody would know in what order
06:04:42 <mux> you can't call lambdaman to the rescue if he isn't really needed
06:05:01 <mux> we could make some funny spoofs on that theme
06:05:06 <ski> you could use 'seq' for that purpose
06:05:19 <mux> I'm picturing a lambda projector like the one for batman, but obviously with a lambda rather than a bat
06:05:34 <int-e> . o O ( "Whaddya say? Somebody is planting a bomb on the <Name here> bridge? Well call me again when it has exploded. )
06:06:25 <gwern> quicksilver: at a guess, I'm checking 100 pages and each one would average between 10-100 links, so between a 1000 and 10000 entries in the list?
06:06:38 <mux> or we could have lambdaman 3: fight against the dark lambdaman
06:06:47 <quicksilver> gwern: odd. You should get a bunch of putStrLns right at the beginning
06:06:56 <quicksilver> gwern: I suggest you try cutting your example down
06:07:03 <ski> "tell him to wait long enough before triggering the bomb for me to disable it one second before it goes off (after my tea, please)"
06:07:06 <quicksilver> gwern: do a really simple forkIO putStrlng and see if that works
06:08:51 <apfelmus> http://uebb.cs.tu-berlin.de/~magr/gallery/misc-4.en.html
06:08:52 <lambdabot> Title: Misc #4: Lambda Man's Work
06:12:27 <kaol> what's up with HWN? I must've missed the reason why it's not updating.
06:12:46 <ndm> malcolmw: Yhc now builds with Nyhc, and i've just pushed all necessary sconscript stuff
06:13:08 <kaol> s/updating/being published/ (to be more precise)
06:13:38 <int-e> kaol: dons is too busy with whatever he's currently doing? (stream fusion still?)
06:13:42 <ttfh> a lambdaman cartoon would have to have monads, how would you draw them? interesting...
06:13:58 <dons> int-e: writing my thesis :}
06:13:58 <ski> hm .. why 'lambda*man*' ?
06:14:06 <mux> as warm fuzzy things
06:14:08 <int-e> dons: how boring ;)
06:14:08 <dons> but yes, i've an issue pretty much ready to go.
06:14:10 <profmakx> lambdaperson_
06:14:11 <ski> maybe 'lambdagerm' or something would be better ?
06:14:26 <dons> because wadler wore a tshirt with a big lambda on it, under the guise of lambdaman
06:14:27 <apfelmus> 'lambdabot'
06:14:31 <mux> ski: philip wadler has been giving talks showing a superman-like t-shirt but with a lambda instead of an S
06:14:39 <ski> ah
06:14:58 <ttfh> lambdaboy
06:15:08 <mux> spj could be lambdaboy
06:15:13 <gwern> weird. so I've main = mapM_ (forkIO . foobar) ["foobar", "baz"]
06:15:33 <gwern> and then foobar = do putStrLn arg; return ()
06:15:44 <ski> @type putStrLn
06:15:47 <lambdabot> String -> IO ()
06:15:47 <ttfh> lambdamans best friend, lambdadog
06:16:15 <ttfh> meanwhile, lambdacat is not amused
06:16:19 <gwern> and it prints in ghci but not when I compile with ghc
06:16:20 <ski> and lambdamans $DEITY being lambdagod
06:17:08 <apfelmus> lambdaman's favorite meal: curried haddocks
06:17:24 <gwern> why can't lambdaman be his own god? then it'd be a fixedpoint no?
06:17:48 <ski> maybe he'd be his own bottom ?
06:18:40 <apfelmus> that would be too strict
06:22:06 <int-e> > fix meal -- :/
06:22:08 <lambdabot>   Not in scope: `meal'
06:22:21 <_frederi1_> how do i parse "2006-05-01 00:00:24"?
06:23:05 <Saizan> ?hoogle isAlpha
06:23:06 <lambdabot> Char.isAlpha :: Char -> Bool
06:23:06 <lambdabot> Char.isAlphaNum :: Char -> Bool
06:23:31 <int-e> @index parseTime
06:23:31 <lambdabot> bzzt
06:23:40 <dons> _frederi1_: with the parsetime library?
06:24:21 <dons> or is it the 'time' library? ah ,this one, 2http://hackage.haskell.org/cgi-bin/hackage-scripts/package/parsedate-2006.11.10
06:24:24 <lambdabot> http://tinyurl.com/392dhu
06:25:49 <int-e> Prelude Data.Time> read "2006-05-01 00:00:24" :: LocalTime ===> 2006-05-01 00:00:24 (from the 'time' package)
06:30:33 <int-e> how many different time formats are there in the various haskell libs? and can any of these easily be marshalled as a struct timeval?
06:32:40 <dons> oh bulat. will you ever learn? /me reads another wacky bulat post.
06:33:31 <gkr> Is there anyfuction already defined such that it removes 'repeated' elements in a list? like: rem [1,2,1,3,2] = [1,2,3]
06:33:46 <apfelmus> gkr: nub
06:33:59 <dons> > nub [1,2,1,3,2]
06:34:02 <lambdabot>  [1,2,3]
06:34:09 <pastorn> are there any shirts anywhere with lambdas on them? could be cool to have one...
06:34:12 <pastorn> @where clothes
06:34:13 <lambdabot> I know nothing about clothes.
06:34:17 <dons> > group [1,2,1,3,2]
06:34:17 <gkr> In Data.Lists?
06:34:19 <lambdabot>  [[1],[2],[1],[3],[2]]
06:34:24 <apfelmus> ?src nub
06:34:24 <lambdabot> nub = nubBy (==)
06:34:28 <dons> pastorn: there's the xmonad tshirts. i think they're cool.
06:34:34 <gkr> @src nubBy
06:34:35 <lambdabot> nubBy eq []             =  []
06:34:35 <lambdabot> nubBy eq (x:xs)         =  x : nubBy eq (filter (\ y -> not (eq x y)) xs)
06:34:38 <dons> they have lambdas.
06:34:45 <apfelmus> gkr: either Prelude or Data.List
06:34:51 <apfelmus> or both
06:35:06 <dons> --> https://www.spreadshirt.com/shop.php?op=article&article_id=2125373
06:35:07 <lambdabot> http://tinyurl.com/ytra6y
06:35:08 <apfelmus> just import Data.List if it doesn't compile :)
06:35:13 <int-e> > map head . group . sort $ [2,1,3,2,1,4,5,2,2,1,0,2,4]
06:35:16 <lambdabot>  [0,1,2,3,4,5]
06:35:20 <dons> there's some other haskell tshirts on cafe press
06:35:24 <dons> (and fun type system tshirts)
06:36:53 <pastorn> dons: kinda cool, but it says Xmonad on the back... (/me uses e17)
06:36:54 <gkr> And a fucntion already defined that does f x xs = filter (/=x) xs?
06:37:46 <apfelmus> > [1,2,3,4] // [1]
06:37:48 <lambdabot>  Couldn't match expected type `Array i e'
06:38:01 <apfelmus> ?src (\\)
06:38:01 <lambdabot> (\\) = foldl (flip delete)
06:38:11 <apfelmus> > delete [1,2,3,4] 4
06:38:12 <lambdabot>   add an instance declaration for (Num [[t]])
06:38:19 <apfelmus> ?type delete
06:38:20 <lambdabot> forall a. (Eq a) => a -> [a] -> [a]
06:38:35 <apfelmus> > delete 5 [1,2,3,4,4,5,5,5,5]
06:38:37 <lambdabot>  [1,2,3,4,4,5,5,5]
06:38:46 <gkr> It uonly deletes the first occurence apparently :-/
06:39:14 <apfelmus> > [1,2,3,5,5,5] \\ 5
06:39:16 <lambdabot>   add an instance declaration for (Num [t])
06:39:21 <apfelmus> > [1,2,3,5,5,5] \\ [5]
06:39:25 <lambdabot>  [1,2,3,5,5]
06:39:29 <apfelmus> hm
06:40:06 <apfelmus> well, you just have to give your "f" a good name, right :)
06:40:46 <int-e> > let nub' xs = [x | (sx, x) <- zip (scanl (flip Data.Set.insert) Data.Set.empty xs) xs, not (x `Data.Set.member` sx)] in nub' [4,2,1,4,5,6,3,2,1]
06:40:48 <lambdabot>  [4,2,1,5,6,3]
06:42:39 <apfelmus> ah, a stable nub
06:43:02 <int-e> and lazy
06:43:25 <apfelmus> ah, indeed :)
06:44:08 <int-e> There was a discussion about this on haskell-cafe not too long ago, where these points were brought up.
06:44:32 <apfelmus> oh, i missed that
06:44:33 <int-e> Or was that on the libraries list? Hmm. I forgot.
06:44:47 <apfelmus> must have been libraries
06:47:54 <_frederi1_> dons, int-e: thanks... now, how do i convert a LocalTime to seconds since epoch (any will do)?
06:49:22 <sorear> hello!
06:49:23 <lambdabot> sorear: You have 1 new message. '/msg lambdabot @messages' to read it.
06:49:33 <sorear> @messages
06:49:33 <lambdabot> ndm said 41m 54s ago: "." ? making the current directory relative to the current directory is just "." is it not?
06:49:58 <sorear> ndm: I thought "." was a POSIXism :)
06:51:07 <quicksilver> [1,2,3,5,5,5] \\ [5,5,5]
06:51:11 <quicksilver> > [1,2,3,5,5,5] \\ [5,5,5]
06:51:13 <lambdabot>  [1,2,3]
06:51:20 <quicksilver> multi-set difference :)
06:51:40 <opqdonut> > [1,5,2,5,3] \\ [5,5]
06:51:43 <lambdabot>  [1,2,3]
06:51:45 <opqdonut> indeed :)
06:52:03 <ndm> sorear: no, its all
06:52:38 <sorear> huh.  ok.
06:52:38 <Syzygy-> @quote Syzygy-
06:52:38 <lambdabot> Syzygy- says: And we have people doing maths -and- getting laid. Some of them simultaneously. :P
06:52:42 <Syzygy-> Hah.
06:52:50 <Syzygy-> Wonder if that's my only registered quote. :P
06:52:56 <matthew-_> > [1,5,2,5,3] \\ (repeat 5)
06:53:00 <lambdabot> Terminated
06:53:07 <quicksilver> @quote Syzygy-
06:53:07 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
06:53:10 <quicksilver> @quote Syzygy-
06:53:10 <lambdabot> Syzygy- says: And we have people doing maths -and- getting laid. Some of them simultaneously. :P
06:53:12 <quicksilver> @quote Syzygy-
06:53:12 <lambdabot> Syzygy- says: Why do I get the feeling that the arrow code was written during "Speak like a pirate day"?
06:53:18 <Syzygy-> 'Right.
06:53:19 <quicksilver> just the two, it seems
06:53:21 <sorear> just read the state file!
06:53:28 <Syzygy-> sorear: I can do that?
06:53:45 <Saizan> ?src (\\)
06:53:46 <lambdabot> (\\) = foldl (flip delete)
06:53:47 <sorear> http://www.cse.unsw.edu.au/~dons/code/lambdabot/State/quote
06:53:51 <ToRA> > (repeat 5) \\ [1,5,2,5,3]
06:53:53 <lambdabot>  [5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5...
06:53:53 <sorear> be careful, it's gzipped
06:54:21 <matthew-_> ToRA: weird - I'd expect it to be lazy the other way round
06:54:23 <Saizan> > [1] \\ [2]
06:54:25 <lambdabot>  [1]
06:54:57 <quicksilver> sorear: if dons' web server sent it out with the correct mime headers, it would be transparently ungzipped by the browser
06:55:20 <sorear> quicksilver: And dons doesn't do that!
06:55:28 <ToRA> matthew-_: has to eval whole of rh list for each elem on lhs.  so can handle infinite on left list, but strict on right list
06:55:50 <matthew-_> yeah
06:55:52 <sorear> quicksilver: it is his fault that the files don't have a .gz extension :(
07:05:25 <gkr> Where can I find a list of function lists?
07:07:41 <gkr> I want to know if there's something like f xs ys = [x|x <- xs, x `elem` ys]
07:08:02 <glen_quagmire> i guess no one is working with haskell for their paid job
07:08:11 <matthew-_> glen_quagmire: not true
07:08:16 <ndm> gkr: hoogle?
07:08:18 <int-e> _frederi1_: looks like you need to do something silly like  truncate $ diffUTCTime (localTimeToUTC utc (read "2006-05-01 00:00:24" :: LocalTime)) epoch where epoch = (read "1970-01-01 00:00:00" :: UTCTime)
07:08:19 <ndm> @where hoogle
07:08:19 <lambdabot> http://haskell.org/hoogle
07:08:30 <ndm> glen_quagmire: i get paid to work on Haskell as a PhD
07:08:38 <glen_quagmire> matthew-_: in that case, i conquer your job
07:08:46 <glen_quagmire> ndm: rofl
07:08:51 <int-e> _frederi1_: which is a shame because the library *does* do conversions from C time at least internally but they aren't exposed.
07:08:54 <glen_quagmire> ndm: academic grant?
07:09:02 <ndm> glen_quagmire: yes
07:09:05 <matthew-_> glen_quagmire: yes, me too wrt PhD
07:09:14 <glen_quagmire> hah nerds
07:09:22 <matthew-_> but there are guys at credit suisse amongst other places using haskell
07:09:24 * glen_quagmire jokes
07:09:44 <int-e> _frederi1_: oh, in place of 'utc' use your actual time zone. (unless your times are already UTC in which case you can save a conversion from LocalTime)
07:10:09 <matthew-_> some folk at microsoft cambridge research working on Haskell I think. Not sure quite what they do though...
07:10:11 <matthew-_> ;)
07:10:34 <glen_quagmire> is it hard to write grant paper?
07:10:47 <glen_quagmire> "hey, ima learn haskell, give me money?"
07:10:52 <matthew-_> no. it's probably harder to get it accepted though
07:11:49 <int-e> _frederi1_: maybe use a different library. I wish I knew which one to suggest.
07:12:01 <sorear> gkr: intersect
07:13:31 <ndm> glen_quagmire: you don't get money just for learning, you have to do something new and exciting with it
07:13:41 <gkr> sorear thanks. I found this hoogle very nice.
07:14:13 <matthew-_> ndm: oh really?! then explain all those mind-numbingly dull PhD thesis out there!
07:14:14 <glen_quagmire> true. new and exciting.
07:14:42 <sorear> gkr: don't look at me, look at the initials of the guy who created hoogle :)
07:15:05 <ndm> matthew-_: its relatively hard to fail a phd, its more like time served thing...
07:15:11 <matthew-_> absolutely
07:16:17 <osfameron> really?
07:16:29 <osfameron> of course you have to do a first degree and a masters usually first
07:16:49 <Igloo> You don't have to do a masters in the UK
07:16:51 <Syzygy-> ndm: To a large extent this is because if you really don't have what it takes, you'll get nudged out before you even try to finish your degree.
07:17:34 <Syzygy-> matthew-_: PhD theses aren't produced for grant papers. In general, the PhDs tend not to write the grant applications, but rather their advisors or chairs...
07:17:43 <Syzygy-> Who in turn have more exciting things to put in the grant application. :P
07:17:58 <matthew-_> Syzygy-: you intended that for glen_quagmire, not me :)
07:18:02 <ndm> Syzygy-: yes, most "failing" phd students don't fail, but get "disappeared"
07:18:04 <Syzygy-> matthew-_: Possibly.
07:18:08 <Syzygy-> ndm: Exactly.
07:18:38 <Syzygy-> ndm: What I hear, the humanities fail people more often - to a large extent because you have higher density of people going up to a defense against their advisors explicit discouragement...
07:18:40 <ndm> Syzygy-: although thats usually because people give up, or are having arguments, or aren't trying - its rarely because someone just isn't clever enough
07:18:45 <matthew-_> in the last year or so, there's been one phd guy who didn't make the transfer from mphil to phd, he then got pushed out
07:19:25 <ndm> i recently had a friend fail his Maths PhD,  apparently all his proofs were wrong, all his research was poorly cited and mainly wrong
07:19:30 <matthew-_> err, qualify the above with "in my department"
07:20:08 <Syzygy-> ndm: Whoa!
07:20:37 <beelsebob> that sucks
07:20:45 <beelsebob> surely his supervisor spotted it?
07:20:55 <ndm> yep, he got given a year to rewrite and then try again
07:21:09 <Syzygy-> matthew-_: You tend to have an advisor who keeps an escape route half-open most of the time - a problem that he knows how to solve but couldn't be bothered doing, and would kick you through to get you out if you mess up.
07:21:15 <ndm> beelsebob: no, he didn't - which is a rather worrying thing. His supervisor has now take a sabatical to help this guy get his phd
07:21:26 <beelsebob> o.O
07:21:26 * Syzygy- has ended up doing things my supervisor doesn't understand anything of at all
07:21:30 <beelsebob> that's very worrying
07:21:39 <Syzygy-> I work with homotopy theory in homological algebra, and with a helping of Haskell on the side.
07:21:45 <matthew-_> "hi. Well we found some problems with your proof. The first issue is your assumption that P = NP..."
07:21:46 <beelsebob> Syzygy-: yeh, but surely your supervisor could at least follow the proof?
07:21:51 <Syzygy-> My supervisor knows the homological algebra where I apply stuff, but not much more.
07:21:56 <Syzygy-> beelsebob: He's struggling to keep up with me. :P
07:22:00 <beelsebob> fair enough
07:22:18 <beelsebob> I guess I'm lucky that my research area coincides so neatly with Olaf's
07:22:22 <Syzygy-> Last I heard, he was reading my haskell program^W^Wpaper draft trying to figure out what it says.
07:22:28 <beelsebob> (mostly through a lot of guidance from him)
07:22:45 <Syzygy-> beelsebob: He tried starting me on a subject very close to his own, but I had too many ideas and am too ... independent ... to stay with that.
07:22:56 <matthew-_> right, I need some help with IO Monads.
07:23:16 <matthew-_> let's say that this program lives in n worlds rather than just 1
07:23:19 <Syzygy-> On the other hand, I look enough at the other mathematician's shoes to build a good and large contact net quickly, and get a lot of help from a few of the giants in my field.
07:23:46 <matthew-_> so to do an IO calculation within any particular world, I have to supply and pass round the RealWorld myself
07:24:06 <matthew-_> these RealWorlds can also be passed between multiple threads
07:24:21 <matthew-_> and must only be used by one thread between passing it on
07:24:24 <ndm> i have the advantage that my supervisor knows everything in computer science...
07:24:31 <matthew-_> this seems to be a monad within a monad?
07:24:46 <matthew-_> any other ideas/thoughts?
07:24:49 <ndm> (and Maths as well, as it happens)
07:26:18 <matthew-_> in particular, higher-order communication of RealWorlds seems problematic
07:26:37 * matthew-_ gets the feeling no one's following him
07:26:58 <kfish> matthew-_, how do these RealWorlds differ from each other? are they derived from the same original state?
07:27:25 <matthew-_> kfish: no, they start as unique values
07:27:42 <matthew-_> kfish: eventually, you may be able to split one into m, but ignore that for the time being
07:28:52 <matthew-_> the problem is that everything's fine when one thread knows about a RealWorld. But when you pass it to another thread, now two know about it. And I must enforce that after being sent to the other thread, the originating thread cannot use that RealWorld
07:29:36 <matthew-_> which looks like ownership types or uniqueness types or monads. But the fact that it's between threads seems to either confuse me or make the situation more complex
07:30:13 <Syzygy-> How do you actually send things between threads?
07:30:44 <matthew-_> well, kinda ignore that. It actually uses MVars, but don't worry about the fact that that demands IO itself
07:31:42 <Syzygy-> matthew-_: What I'm thinking is that if the thread communication is explicit enough - viz a limited number of functions - then wrap those in things that flag the thingie as "Can not use"...
07:31:56 <Syzygy-> Possibly using somewhere a Maybe RealWorld that you hand around, or something.
07:32:10 <matthew-_> I don't think that's rigid enough
07:32:25 <matthew-_> because it can always be unpacked and then the value both sent and subsequently used
07:32:52 <Syzygy-> Oh, you want to protect yourself against malicious programmers too, eh?
07:33:01 <matthew-_> yes, at the type level
07:33:07 <Syzygy-> Ah.
07:33:19 <matthew-_> that's (one of the things) that monads get you...
07:35:04 <bluestorm_> hm
07:35:38 <bluestorm_> in the Sweeney presentation i heard of "lenient evaluation", that seemd to be different from strict and lazy evaluation
07:35:51 <bluestorm_> but i didn't manage to find anything on that topic
07:36:04 <LeCamarade> @go lenient evaluation
07:36:06 <lambdabot> http://lambda-the-ultimate.org/node/243
07:36:06 <lambdabot> Title: Combining lazy and eager evaluation of terms | Lambda the Ultimate
07:36:13 <matthew-_> yep. Sweeney doesn't like full lazy eval.
07:36:41 <bluestorm_> hm
07:38:10 <bluestorm_> thanks, i'll have a look
07:39:07 <Saizan> is there some ghc flag that only desugars without converting to GHC.Core? or a standalone list comprehension desugarer?
07:39:32 <sorear> Saizan: No, desugarer :: Haskell -> Core
07:42:59 <Philippa_> Saizan: GHC doesn't have a notion of "desugared Haskell"
07:43:48 <koala_man> soured haskell?
07:44:16 <Syzygy-> koala_man: Nono, desugaring removes the sugar. Souring doesn't do that.
07:44:28 <Syzygy-> However, adding yeast would do it. :P
07:44:57 <koala_man> yummy
07:45:19 <Syzygy-> Fermenting!
07:45:43 <Syzygy-> ferment :: Haskell -> Haskell
07:45:46 <Syzygy-> :P
07:46:15 <Syzygy-> It ends up being a surprisingly good metaphor: it would increase in size by fermenting too...
07:47:35 <Philippa_> yeah, but it won't get you drunk
07:47:36 <rretzbach1> I am reading some wikibooks to get started, but I don't get "let". Sometimes I see "=" used without a let, but ghci shows a parse error
07:47:59 <Philippa_> that's because you're looking at source files - you can't type them straight into ghci
07:48:07 <oerjan> rretzbach1: ghci's syntax is as inside do, not as module toplevel
07:48:07 <rretzbach1> Aha!
07:48:17 <hpaste>  Igloo pasted "overlapping instances problem" at http://hpaste.org/411
07:48:26 <rretzbach1> But I see "let" in source too!
07:48:54 <osfameron> ghci is annoying like that
07:49:03 <osfameron> it should probably give a more helpful error message
07:49:16 <rretzbach1> parse error on input `='
07:49:33 <chrismbrown> rretzbach1: are you just starting to learn Haskell?
07:49:34 <oerjan> rretzbach1: well for one thing do syntax exists in source too
07:49:41 <Igloo> Anyone got any idea whether the instances in the above paste should work?
07:49:41 <rretzbach1> chrismbrown: Yes.
07:50:15 <chrismbrown> rretzbach1: I really recommend Simon Thompson's book, the craft of functional programming. It really is a nice introduction
07:50:43 <rretzbach1> noted
07:50:49 <rretzbach1> Thanks for the advice.
07:50:55 <chrismbrown> rretzbach1: I believe you can get it from Amazon
07:50:58 <rretzbach1> First I will stick to the wikibooks.
07:50:59 <Philippa_> rretzbach1: what you don't see is let at top level
07:51:07 <sjanssen> Igloo: those instances can certainly overlap
07:51:07 <oerjan> rretzbach1: = is allowed inside a where or let.  the module toplevel is a where
07:51:20 <sjanssen> if there's "instance Xml Char"
07:51:24 <Philippa_> oerjan: ...that's misleading
07:51:30 <rretzbach1> oerjan: like module StringManip where
07:51:32 <rretzbach1> ?
07:51:35 <Igloo> sjanssen: Sure, but they're all marked "overlap ok"
07:51:36 <Philippa_> there're things you can only define at top level
07:51:37 <chrismbrown> rretzbach1: haskell is made up of equations, so you typically see a LHS = RHS.
07:51:39 <oerjan> rretzbach1: right
07:51:53 <oerjan> although maybe a few extra things are allowed at toplevel too
07:51:56 <sjanssen> Igloo: I don't really know what that means
07:51:57 <Igloo> sjanssen: And they get progressively more concrete: a, [a], [Char]
07:52:02 <chrismbrown> so you can make calls to the LHS and have the RHS evaluated, for instance
07:52:10 <oerjan> ok, its oversimplifying
07:52:20 <rretzbach1> I am listening.
07:52:20 <chrismbrown> also, sometimes , the LHS require parameters to evaluate their RHS...
07:52:20 <Igloo> sjanssen: That -fallow-overlapping-instances was used, basically
07:53:32 <oerjan> module toplevel can include anything in a where or let, but also type and class declarations, at least
07:53:55 <oerjan> and imports, of course
07:55:24 <Igloo> Hmm, I can't reproduce it in a small from-scratch module
07:55:51 <fasta> If I can decide in a few dereferences some information that I would otherwise pass along, would you delete the passing of that parameter from the program?
07:56:13 <oerjan> fasta: explain.
07:56:52 <fasta> oerjan: I am currently passing a direction parameter in a tree, but I can also recover that information via other means.
07:56:57 <qwr> fasta: probably
07:57:49 <qwr> i would write some function, that gives it - unless it is some speed-critical thing
07:58:22 <qwr> although it might not matter in structure
08:01:50 <hkBst> what's wrong with: parse s = if s !! 0 == '(' `and` s !! -1 == ')' then words s
08:02:40 <oerjan> hkBst: well, -1 is not a legal list index
08:02:48 <oerjan> and it would need parentheses, anyhow
08:03:04 <chrismbrown> hkBst: you need (-1)
08:03:05 <fasta> kpreid: and the type of and it wrong.
08:03:05 <oerjan> :t and
08:03:07 <lambdabot> [Bool] -> Bool
08:03:12 <fasta> er is
08:03:20 <oerjan> you want &&, not and (the latter takes a list)
08:03:24 <fasta> er hkBst
08:03:47 <chrismbrown> parse s = if s !! 0 == '(' `&& s !! (-1) == ')' then words s else something else
08:04:10 <hkBst> else is not optional?
08:04:13 <chrismbrown> no
08:04:36 <hkBst> ah, that explains the strange error: (possibly incorrect indentation)
08:04:40 <fasta> hkBst: what would the meaning be of an if without an else?
08:04:40 <oerjan> :i (!!)
08:04:44 <oerjan> :t (!!)
08:04:46 <lambdabot> forall a. [a] -> Int -> a
08:04:50 <chrismbrown> hkBst: you could put it in a guard if you like, but if the condition fails it won't be able to resolve it
08:04:54 <hkBst> fasta: undefined
08:04:59 <oerjan> oh right...
08:05:03 <chrismbrown> parse s |  s !! 0 == '(' `&& s !! (-1) == ')'  = words s
08:05:12 <fasta> hkBst: ok, well you can define such a function
08:05:16 <oerjan> s !! (-1) would be last s in Haskell
08:05:31 <oerjan> and s !! 0 _can_ be head s
08:05:50 <fasta> > let ifUn bool val  = if bool then val else undefined in ifUn True 5
08:05:51 <lambdabot>  5
08:05:53 <oerjan> @src (!!)
08:05:54 <lambdabot> xs     !! n | n < 0 = undefined
08:05:54 <lambdabot> []     !! _         = undefined
08:05:54 <lambdabot> (x:_)  !! 0         = x
08:05:54 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:05:57 <fasta> hkBst: see?
08:05:59 <chrismbrown> yes, you ideally need a parse [] = something
08:06:15 <fasta> > let ifUn bool val  = if bool then val else undefined in ifUn False 5
08:06:17 <lambdabot>  Undefined
08:06:22 <oerjan> it _would_ have been nice if Haskell indices worked as in python and the like, i guess
08:06:48 <gwern> anyone getting an error compiling TagSoup from darcs? I'm getting 'Setup: can't find source for Text.HTML.TagSoup.Test in ["."]
08:07:40 <hkBst> :t error
08:07:42 <lambdabot> forall a. [Char] -> a
08:08:29 <hkBst> thanks all
08:08:33 <chrismbrown> no worries
08:09:48 * LeCamarade has a Gabriel Garca Mrquez novel to read ... and Haskell is getting in the plan.
08:11:18 <kfish> (re: fermenting, earlier) monads are fermented syntactic sugar, you gotta give them time to brew
08:11:41 <sioraiocht> oh god
08:14:31 <hkBst> oerjan: "and s !! 0 _can_ be head s", there is no difference, right?
08:15:04 <ski> @type last
08:15:09 <oerjan> hkBst: right
08:15:13 <lambdabot> forall a. [a] -> a
08:15:15 <roconnor> > head ""
08:15:17 <lambdabot>  Exception: Prelude.head: empty list
08:15:22 <roconnor> > "" !! 0
08:15:24 <lambdabot>  Exception: Prelude.(!!): index too large
08:15:30 <oerjan> @src head
08:15:31 <lambdabot> head (x:_) = x
08:15:31 <lambdabot> head []    = undefined
08:15:35 <oerjan> @src (!!)
08:15:36 <lambdabot> xs     !! n | n < 0 = undefined
08:15:36 <lambdabot> []     !! _         = undefined
08:15:36 <lambdabot> (x:_)  !! 0         = x
08:15:36 <lambdabot> (_:xs) !! n         = xs !! (n-1)
08:15:50 <roconnor> ooh, they are the same
08:16:51 * oerjan wonders if there is something built in that can give the equivalent of s !! (-n) efficiently without holding to the beginning of the list
08:17:11 <quicksilver> nope
08:17:25 <oerjan> or some easy combination
08:17:28 <quicksilver> that would appear to break stuff :)
08:17:39 <roconnor> oerjan: the problem is that lists can share the same tail.
08:17:43 <igli> what does it do anyhow?
08:17:47 <quicksilver> the fact that you have to choose to  hold onto stuff is what makes the GC work :)
08:17:53 <oerjan> i don't mean without traversal
08:18:03 <hkBst> igli: index from the back of the list
08:18:04 <SamB_XP> reverse ?
08:18:05 <oerjan> i just mean without keeping a long list in memory
08:18:07 <igli> ah ok
08:18:12 <igli> ty hkBst
08:18:18 <LoganCapaldo> oerjan: there's definitely away
08:18:20 <quicksilver> oerjan: where else would it keep it, if not in memeory though ?
08:18:22 <LoganCapaldo> I mean a way
08:18:27 <igli> bit awkward for infinite lists
08:18:30 <earthy> oerjan: how would you get to the end of the list without traversing it?
08:18:37 <LoganCapaldo> because it was an interview question :)
08:18:42 <igli> i know how i would
08:18:52 <igli> but not in haskell unfortunately
08:18:56 <earthy> igli: how then? :)
08:18:58 <roconnor> > let x=[2,4] in (0:x,1:x)
08:19:00 <lambdabot>  ([0,2,4],[1,2,4])
08:19:00 <igli> in C?
08:19:16 <igli> it's called a ring ;)
08:19:28 <sorear> oerjan: I can do it in O(n)memory, where n is the index-from-tail
08:19:31 <kfish> gwern, yes, same here -- ndm was pushing a bunch of patches earlier today, perhaps its best to wait another day or so :-)
08:19:43 <sorear> oerjan: pootentially much smaller than the list length
08:19:47 <earthy> igli: you mean, you have a pointer to the end at the beginning? :)
08:20:03 <oerjan> sorear: so can i i think, i was just wondering if there was some idiom for it
08:20:05 <earthy> that's cheating and not doing it on a list. :)
08:20:12 * allbery_b mutters at darcs x11-extras
08:20:31 <quicksilver> oerjan: it may be that a list is not the structure you're looking for
08:20:49 <igli> earthy: which OS do you use?
08:20:55 <quicksilver> oerjan: maybe somethiing 'zipper' like that lets you go both ways, for example
08:21:01 <earthy> igli: currently, mac os x
08:21:03 <oerjan> quicksilver: it was not a practical question :)
08:21:14 <earthy> (oh, and the irssi is on a freebsd box that I don't administer)
08:21:26 <igli> well put it this way then: the linux kernel uses circular doubly-linked lists all over the place.
08:21:32 <Saizan> > let fromEnd n xs = head . last $ zipWith (const) (tails xs) (drop (n-1) xs) in fromEnd 1 [1..10]
08:21:35 <lambdabot>  10
08:21:43 <Saizan> > let fromEnd n xs = head . last $ zipWith (const) (tails xs) (drop (n-1) xs) in fromEnd 5 [1..10]
08:21:45 <lambdabot>  6
08:21:47 <earthy> igli: hey, I can also do it by changing the datastructure
08:21:48 <ndm> kfish, gwern: i updated the code, but not the .cabal - i'll do that now, give me two secs..
08:22:02 <igli> earthy: it's still a list
08:22:02 <hkBst> what's the name of the variant of fold for binary operators that doesn't require an initial element?
08:22:03 <sorear> > last $ ap (zipWith const) (drop 25) $ [0..1000000]
08:22:05 <lambdabot>  999975
08:22:11 <earthy> oerjan was asking about [], i.e. singly-linked lists, i.e. List
08:22:12 <igli> and i can do it a lot faster so meh :P
08:22:29 <LoganCapaldo> hkBst: foldr1, foldl1
08:22:43 <igli> well i did make it clear i am a C coder, wtf do you want from me? ;D
08:22:55 <LoganCapaldo> or @hoogle (a -> a) -> [a] -> a
08:22:56 <earthy> igli: clarity in your datastructers. ;)
08:22:57 <sjanssen> allbery_b: is there a problem with x11-extras?
08:23:02 <LoganCapaldo> @hoogle (a -> a) -> [a] -> a
08:23:03 <lambdabot> Prelude.foldl :: (a -> b -> a) -> a -> [b] -> a
08:23:03 <lambdabot> Prelude.foldr :: (a -> b -> b) -> b -> [a] -> b
08:23:03 <lambdabot> Data.List.foldl' :: (a -> b -> a) -> a -> [b] -> a
08:23:04 <earthy> structures, even
08:23:13 <LoganCapaldo> oop
08:23:19 <LoganCapaldo> I screwed up that type
08:23:25 <LoganCapaldo> @hoogle (a -> a -> a) -> [a] -> a
08:23:25 <lambdabot> List.maximumBy :: (a -> a -> a) -> [a] -> a
08:23:26 <lambdabot> List.minimumBy :: (a -> a -> a) -> [a] -> a
08:23:26 <lambdabot> Prelude.foldl1 :: (a -> a -> a) -> [a] -> a
08:23:28 <igli> and something tells me an extra pointer per node is still going to be slimmer than haskell.. i'd like to be wrong tho.
08:23:44 <allbery_b> sjanssen: not sure if it's it or me.  seems to be figiuring out it needs -L/usr/X11R6/lib but it doesn't use that when trying to link Extras_hsc_make.o
08:23:59 <earthy> nope, you're not
08:24:10 <allbery_b> I know my system is a trifle nonstandard (and a bit out of date) but didn't think it was that much so
08:24:15 <igli> allbery_b: you're change the makefile then
08:24:24 <igli> er s/you're//
08:24:29 <earthy> but that's because there's some extra metadata in Haskell that also keeps track of evaluation status
08:24:30 <allbery_b> can't find a makefile after configuring
08:24:36 <earthy> thereby enabling the laziness
08:24:47 <allbery_b> (after runhaskell Setup.lhs configure that is)
08:24:53 <allbery_b> or even after the failing build step
08:27:45 <oerjan> :t ap (zipWith const) . drop
08:27:47 <lambdabot> forall a. Int -> [a] -> [a]
08:28:58 <oerjan> :t ap
08:29:01 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m (a -> b) -> m a -> m b
08:29:04 <oerjan> :t zipWith const
08:29:07 <lambdabot> forall a b. [a] -> [b] -> [a]
08:29:45 <gkr> If I have something like: "f (n+1) | False = 0", it will try with the next ecuations of f? Like "f (n+1) = 4"?
08:29:55 <Philippa_> <igli> and something tells me an extra pointer per node is still going to be slimmer than haskell.. i'd like to be wrong tho. <- that's because you're not paying the cost of lazy evaluation in C. If you have a strict list it's different (but then it won't let you have the circularity). And you can just build it over arrays for what you actually /want/ to do with a ring
08:30:24 <igli> no you obviously don't code C, Philippa_, no offense
08:30:26 <Philippa_> (because if you're going out of your way to use rings you already care about comparatively fine memory layout details)
08:30:28 <LoganCapaldo> gkr: yes
08:30:42 <igli> doesn't mean i can't be flexible?
08:30:43 <Philippa_> I'm sorry? I grew up hacking this stuff, get over yourself
08:30:52 <igli> hehe
08:30:57 <igli> nice to emeet you too
08:31:17 <quicksilver> igli: what a ridiculous thing to have said :P
08:31:39 <igli> i know i'm terrible, do forgive me quicksilver. :)
08:31:52 <Philippa_> now, I can clone the C ring in Haskell to a far better extent than you probably realise
08:31:57 <Philippa_> this is because /I know Haskell better than you/
08:32:03 * earthy laughs
08:32:06 <igli> i never cast aspersions on that
08:32:08 <quicksilver> igli: in this channel, if in doubt, it's wise to assume that everyone is a genius :)
08:32:14 <Philippa_> so I know what to do if I fancy a little bitbanging
08:32:17 * earthy sees Ptr Int's appearing in Philippa's eyes. :)
08:32:20 <igli> er congratulations, Philippa_, i'm in awe
08:32:29 <igli> *plunk*
08:32:35 <earthy> or, really, Ptr Word8#? :)
08:33:14 <igli> someone refer the young lady to "Understanding the Linux Kernel" Daniel P. Bovet & Marco Cesati, O'Reilly | "Linux Device Drivers" Corbet, Russini & Kroah-Hartman, 3rd ed O'Reilly 2005 | "Linux Kernel Development" Robert Love, 2nd ed Pearson Ed 2005
08:33:21 <sorear> earthy: Kind error in application
08:33:45 <earthy> sorear: oh, most possibly. I've been away from computers and code for over 2 weeks
08:33:48 <Philippa_> igli: go on, what am I missing?
08:33:58 <matthew-_> err, can I suggest a cup of tea to various people?
08:34:15 <igli> yes thanks matthew-_
08:34:17 <LoganCapaldo> I hate IRC
08:34:22 <Philippa_> bear in mind I've used rings in my own C code...
08:34:24 <quicksilver> Philippa_: I imagine that by *plunk* he intends to denote that he has ignored you. I don't think you should waste much more of your time on him.
08:34:48 * earthy thought that sound was *ploink*
08:34:51 <earthy> oh well. :)
08:34:56 <Philippa_> quicksilver: if he's actually done that, he shouldn't then be trying to win the argument by proxy
08:35:03 <matthew-_> silly irc and it's lack of onomatapia
08:35:05 <igli> no the yanks use plonk hence the term "plonker"
08:35:26 <igli> i prefer plunk myself tbh
08:35:42 <matthew-_> err, onomatopoeia rather
08:36:08 <earthy> ah, right, plonk
08:36:09 <Philippa_> it's got all the onomatopoeia you want, just no actual sound
08:36:14 <earthy> it's been ages since I've been on usenet
08:36:23 <igli> hehe
08:36:47 <hpaste>  ndm pasted "GHC Bug in warnings?" at http://hpaste.org/412
08:36:55 <ndm> is that GHC going crazy?
08:37:06 <ndm> (Igloo?)
08:37:49 <igli> looks like a dupe sym to me
08:37:50 <Igloo> ndm: Load it in ghci and do :i fileName
08:38:25 <ndm> Igloo: fileName is defined as a record selector in another module, so i guess it is a name clash, but hte message isn't quite right#
08:38:43 <Igloo> Why not?
08:38:55 <Igloo> Oh, are you reading it as one English sentence?
08:38:59 <ndm> I guess it is, i guess what would help is saying where the other bit is defined
08:39:07 <shapr> Good morning #haskell!
08:39:12 <shapr> How's the code this fine morning?
08:39:15 <Igloo> Yes, that's true
08:39:21 <LoganCapaldo> shapr++
08:39:28 <shapr> LoganCapaldo: What did I do?
08:39:31 <sorear> Good morning shapr!
08:39:42 <shapr> Good Morning Mr West Coast Programmer!
08:39:44 <LoganCapaldo> shapr: positivity! :)
08:39:59 * shapr charges LoganCapaldo with positive ions!
08:44:34 <Philippa_> 'lo Souwh
08:44:45 <ndm> gwern: kfish: should all be working properly now
08:45:22 <Souwh> Hi Philippa_ :)
08:48:06 <sjanssen> allbery_b: http://xmonad.org/faq.html#x11 (if you haven't figured it out already)
08:48:07 <lambdabot> Title: xmonad : frequently asked questions
08:49:31 <allbery_b> mostlty I'm jkust whining
08:49:42 <shapr> igli: Hey man, it's a requirement to be nice and polite here on #haskell.
08:49:44 <allbery_b> can't work on it right now, is the real reason I'm whining :/
08:49:55 <roconnor> > 0.5**(-1/2)
08:49:56 <igli> shapr: i was civil sir.
08:49:57 <lambdabot>  1.4142135623730951
08:50:05 <allbery_b> want to build it but it's not for work purposes so...
08:50:09 <shapr> igli: Yeah, but civil isn't necessarily the same as nice and polite.
08:50:09 <allbery_b> mrf
08:50:25 * shapr comforts allbery_b with a handy sugar lambda.
08:50:35 <kfish> ndm, cheers, builds fine :-)
08:50:37 <igli> well it's an awful lot more than the condescending manner in which i was addressed imo
08:50:45 <roconnor> > (-0.5)**2
08:50:47 <lambdabot>  0.25
08:50:57 <roconnor> > (-0.5)**2.0
08:50:58 <lambdabot>  0.25
08:51:10 <roconnor> > (-0.5)**2.1
08:51:12 <lambdabot>  NaN
08:51:15 <shapr> igli: I don't think any condescendion was intended.
08:51:33 <igli> ok
08:51:47 <quicksilver> I read no condescension (reading back). And you weren't civil as defined in my dictionary. Far from it.
08:52:01 <shapr> er, condescension, dang.. I can't spell sometimes.
08:53:29 <shapr> igli: I do think that the "you obviously don't code C" comment was not civil.
08:53:53 <roconnor> > (-0.5)**2.00000000000000001
08:53:55 <lambdabot>  0.25
08:54:06 <igli> [16:28] <Philippa_> <igli> and something tells me an extra pointer per node is still going to be slimmer than haskell.. i'd like to be wrong tho. <- that's because you're not paying the cost of lazy evaluation in C. If you have a strict list it's different (but then it won't let you have the circularity). And you can just build it over arrays for what you actually /want/ to do with a ring
08:54:06 <igli> [16:29] <igli> no you obviously don't code C, Philippa_, no offense
08:54:16 <igli> that;s the full comment, in context
08:54:26 <igli> in a fast moving channel
08:54:31 <ndm> kfish: large portions got rewritten, so be on the lookout for regressions
08:54:35 <Syzygy-> igli: So how was that condescending?
08:54:39 <igli> when i am occupied in other channels as well
08:54:52 <igli> firstly i made it clear i wasn't being condescending myself.
08:55:12 <Syzygy-> (17:49) ( igli) well it's an awful lot more than the condescending manner in which i was addressed imo
08:55:23 <Syzygy-> You seem to claim that Philippa_ was condescending to you.
08:55:40 <igli> [16:29] <Philippa_> (because if you're going out of your way to use rings you already care about comparatively fine memory layout details)
08:55:47 <igli> [16:29] <igli> doesn't mean i can't be flexible?
08:55:58 <igli> [16:29] <Philippa_> I'm sorry? I grew up hacking this stuff, get over yourself
08:56:02 <igli> [16:29] <igli> hehe
08:56:06 <igli> [16:29] <igli> nice to emeet you too
08:56:10 <igli> [16:30] <quicksilver> igli: what a ridiculous thing to have said :P
08:56:22 <igli> [16:30] <igli> i know i'm terrible, do forgive me quicksilver. :)
08:56:26 <igli> [16:30] <Philippa_> now, I can clone the C ring in Haskell to a far better extent than you probably realise
08:56:27 <shapr> igli: I'm just saying that I don't think you were being nice and polite.
08:56:30 <igli> [16:30] <Philippa_> this is because /I know Haskell better than you/
08:56:34 <gwern> ndm: I just refetched tagsoup. I
08:56:36 <shapr> igli: I can read the scrollback.
08:56:37 <gwern> 'm not getting that same error
08:56:51 * shapr sighs
08:56:53 <shapr> Oh well.
08:57:02 * ari knocks on wood
08:57:59 * LoganCapaldo hands Philippa an underscore
08:58:07 <LoganCapaldo> I think you dropped this
08:58:08 <sjanssen> what the heck just happened?
08:58:17 <Philippa> sjanssen: we got trolled, basically
08:58:31 <chessguy> igli is quite immature, he's shown it before
08:58:45 <Syzygy-> Hmmmm. I seem to have missed substantial meta-activity by my aggressive filtering now.
08:58:51 <Syzygy-> Did igli possibly get kickbanned?
08:58:54 <Philippa> no
08:58:58 <Philippa> he left himself
08:59:06 <Syzygy-> ok
08:59:12 <shapr> Still, part of the goal of #haskell in my opinion, is to be clear about what behaviour is not acceptable here, so that people can be good citizens of #haskell if they wish to be.
08:59:27 <chessguy> oh, i agree shapr
08:59:27 * Syzygy- agrees
09:00:02 <Philippa> if he's not still talking to you in private then you might want to consider what the reaction to running away from a meta discussion with an op is
09:00:46 <roconnor> shapr: although I wasn't following, I do agree with you.  Generally speaking, it is exteremly important to maintain civil behaviour to allowing collaboration to function well.
09:01:13 * roconnor has been listening to Mark Shuttleworth
09:01:15 <chessguy> even more so as the size of the channel grows
09:01:55 <chessguy> i know! we should just adopt the same rules as ##c++, that'll solve the problem
09:02:36 <Philippa> what's ##c++'s ruleset, best warbot wins?
09:02:37 <mauke> what, "no sex and no fun"?
09:02:48 <Philippa> well, the sex goes in -blah
09:03:04 <roconnor> join ##c++-blah
09:03:11 <chessguy> ##c++'s ruleset is pretty much )_
09:03:13 <chessguy> err
09:03:15 <chessguy> ()
09:03:30 <Philippa> like I said... :-)
09:03:40 <sorear> Frightening.  To think this is the same igli who just a few weeks ago convinced me he was good enough for bot-admin status.
09:03:55 <gwern> chessguy: what rules do they follow?
09:03:55 <gwern> bleh. I really hate how cabal seems to install files with bad permissions when you do a sudo runhaskell Setup.hs install
09:04:15 <chessguy> gwern, they don't. it was a joke
09:04:20 <sorear> gwern: How did you configure?
09:04:27 <Philippa> sorear: it's like that sometimes. OTOH, the fact nobody here knew him should've been a warning - you live and you learn
09:05:00 <gwern> sorear: just 'runhaskell Setup configure'
09:05:08 <sorear> gwern: Odd.
09:05:39 <matthew-_> sorear: frankly, anyone who's actually asking for permission probably shouldn't have it
09:05:48 <gwern> sorear: I'm kind of used to it. 's been doing that ever since I first met a cabalized package
09:05:49 <matthew-_> ...is how I tend to operate
09:06:30 <chessguy> matthew-_, not a bad rule, as a rule of thumb anyway
09:06:46 <kfish> i'm not convinced igli was trolling, there was a gap in understanding what a "list" is -- ie. a sacred pure lazy data structure core to the language (and way of thinking) vs. a generic name for a custom sequential data structure
09:07:03 <DRMacIver> How bizarre. Typical IRC behaviour in Haskell.
09:07:06 <DRMacIver> I've not seen that before...
09:07:21 <chessguy> well it wasn't really trolling, per se. he was on topic, just not politefully so
09:07:32 <Philippa> chessguy: trolling doesn't have to be off-topic
09:07:35 <sorear> @protontorpedo
09:07:36 <lambdabot> how do we automate ftp file transfers with haskell?
09:07:37 <chessguy> hmm. did i just make up a word?
09:07:51 <chessguy> @all-dict troll
09:07:53 <lambdabot> *** "Troll" gcide "The Collaborative International Dictionary of English v.0.48"
09:07:53 <lambdabot> Troll \Troll\, n. [Icel. troll. Cf. {Droll}, {Trull}.] (Scand.
09:07:53 <lambdabot>    Myth.)
09:07:53 <lambdabot>    A supernatural being, often represented as of diminutive
09:07:53 <lambdabot>    size, but sometimes as a giant, and fabled to inhabit caves,
09:07:55 <lambdabot> [196 @more lines]
09:08:03 <sjanssen> I don't think igli was trolling
09:08:05 <SamB_XP> igli left with the message "have a good one ;-)".
09:08:08 <sjanssen> he just got a bit defensive
09:08:29 <chessguy> yeah, like i said, he's just a little immature
09:08:29 <SamB_XP> well.
09:08:36 <SamB_XP> modulo initial caps and noses
09:08:50 <opqdonut> @protontorpedo
09:08:50 <lambdabot> some dude called topmind says that oo is bs
09:09:20 <LoganCapaldo> where this topmind?
09:09:25 <matthew-_> I don't think he's a Troll
09:09:54 <opqdonut> @yhjulwwiefzojcbxybbruweejw
09:09:55 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
09:09:58 <opqdonut> @yhjulwwiefzojcbxybbruweejw
09:09:59 <lambdabot> "\"#$%&'()*+,\""
09:09:59 <rretzbach1> re from work
09:10:09 <rretzbach1> oh, sorry I got the wrong channel
09:10:15 <LoganCapaldo> re is a funny word
09:10:19 <matthew-_> they'd have to have really big keyboards otherwise they'd mash loads of keys at the same time. And I've never seen such a keyboard for sale...
09:10:20 <SamB_XP> also... someone could be trolling, but still not a troll. isn't trolling a kind of fishing?
09:10:59 <opqdonut> SamB_XP: trawling
09:11:07 <mauke> @yhjulwwiefzojcbxybbruweejw is a pretty awesome bot command
09:11:07 <oerjan> @list yhjulwwiefzojcbxybbruweejw
09:11:07 <oerjan> @help yhjulwwiefzojcbxybbruweejw
09:11:08 <lambdabot> "\""
09:11:08 <lambdabot> quote provides: quote remember ghc fortune yow arr yarr keal b52s brain palomer girl19 v yhjulwwiefzojcbxybbruweejw protontorpedo
09:11:08 <lambdabot> V RETURNS!
09:11:09 <SamB_XP> opqdonut: oh, is that what it's called?
09:11:19 <Philippa> SamB_XP: that message is his default
09:11:25 <LoganCapaldo> @all-dicts trolling
09:11:26 <lambdabot> *** "Trolling" gcide "The Collaborative International Dictionary of English v.0.48"
09:11:26 <lambdabot> Troll \Troll\, v. t. [imp. & p. p. {Trolled}; p. pr. & vb. n.
09:11:26 <lambdabot>    {Trolling}.] [OE. trollen to roll, F. tr[^o]ler, Of. troller
09:11:26 <lambdabot>    to drag about, to ramble; probably of Teutonic origin; cf. G.
09:11:26 <lambdabot>    trollen to roll, ramble, sich trollen to be gone; or perhaps
09:11:28 <lambdabot> [46 @more lines]
09:11:38 <SamB_XP> Philippa: still, it doesn't seem like the kind of part message a troll would have...
09:12:06 <SamB_XP> ah, see, that definately sounds like a kind of fishing...
09:12:13 <matthew-_> I think anti trolling should be encoded as types in our own haskell IRC server. Then we could, at compile time, assert that trolling would never happen
09:12:57 <Philippa> SamB_XP: actually if I were to start trolling I might well use a message like that
09:13:09 <oerjan> SamB_XP: the usenet term was derived from the fishing term, as i recall
09:13:12 <opqdonut> @v
09:13:12 <lambdabot> "\"\\\"\\\\\\\"\\\\\\"
09:13:13 <DRMacIver> matthew-_: So now you're bypassing regular expression types and skipping straight towards fullblown natural language types? ;)
09:13:18 <opqdonut> @v
09:13:19 <lambdabot> "\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\"
09:13:43 <matthew-_> DRMacIver: well, XHaskell's already been done!
09:14:44 <DRMacIver> Oh yes. I got confused - I thought you were working on regular expression types, but I got my wires cross with a conversation I had with Matthias RE his suggestion of how to encode some of your stuff in it.
09:14:55 <DRMacIver> But I don't remember what it is you're actually doing. :)
09:15:16 <matthew-_> DRMacIver: session types
09:15:30 <DRMacIver> Ah yes, that's the one.
09:16:53 <dmhouse> SQL needs let-blocks.
09:16:54 <oerjan> > 1+1
09:16:56 <lambdabot>  2
09:17:16 <DRMacIver> SQL *has* let blocks.
09:17:21 <dmhouse> Good. :)
09:19:10 <DRMacIver> with foo as (select stuff) (select other stuff from foo)
09:19:42 <DRMacIver> Unfortunately they don't nest. :)
09:19:46 <SamB> !
09:19:50 <SamB> that's stupid!
09:19:55 <SamB> how come?
09:19:59 <DRMacIver> Stupidity.
09:20:14 <DRMacIver> I'm not aware of a good reason for it.
09:20:40 <DRMacIver> (Note I'm specifically talking about Oracle's implementation. I don't know what the state of the let block is in other dialects)
09:22:52 <dmhouse> Why do hosts _still_ have MySQL 4.0 installed? There have been at least three releases since then. It doesn't even have subqueries, for goodness' sake.
09:23:33 <DRMacIver> See previous answer.
09:23:44 <quicksilver> interesting. Someone just cycled past playing a grand piano.
09:23:50 <DRMacIver> ??
09:23:58 <quicksilver> You don't see that every day.
09:24:26 <Syzygy-> quicksilver: WHA?
09:24:36 <dmhouse> Unless you live in a rather musical and sporting neighbourhood full of people who like to mix and match their hobbies.
09:24:40 <matthew-_> dmhouse: why do hosts have MySQL installed FULL STOP?!
09:25:33 <Syzygy-> matthew-_: For instance because some web publishing packages cooperate badly if at all with (other) RDBMs
09:25:38 <DRMacIver> matthew-_: Because there are no other free databasi out there ever.
09:25:44 <matthew-_> postgresql
09:25:52 <quicksilver> I guess you get all sorts in central London.
09:25:57 <matthew-_> oh wait! you were being sarcastic!
09:26:02 <DRMacIver> Yes. :)
09:26:09 <Syzygy-> I wasn't though.
09:26:18 <Syzygy-> I have encountered things that require MySQL.
09:26:23 <DRMacIver> matthew-_: But only in the sense that I've heard people seriously say things along those lines when asked why they use MySQL.
09:26:33 <matthew-_> Syzygy-: in which case, they're probably written badly, so they shouldn't be used anyway!
09:26:34 <Syzygy-> The "real" thing to do would be to rewrite them. But I couldn't be bothered.
09:27:06 <Syzygy-> matthew-_: Sorry. Not quite good enough. If I only ever use thigns that I both know intimately myself and that are Religiously Correct, I would get as good as nothing done.
09:27:25 <matthew-_> true. but you'd be pure
09:27:27 <matthew-_> ;-P
09:27:46 <Syzygy-> I can accept some poisoning.
09:27:58 <matthew-_> non-toxic levels of PHP eh?
09:28:05 <byorgey> pardon my ignorance, but what's so horrible about MySQL?  (I'm actually curious)
09:28:37 <matthew-_> byorgey: well, traditionally it's been very bad at supporting SQL to any decent level. That's improved over the last few years though
09:28:46 <DRMacIver> byorgey: It's not too bad these days. It's more that there are flat out better alternatives available under nicer licensing schemes, yet MySQL dominates.
09:28:48 <quicksilver> byorgey: traditionally, it lacked key features like foreign keys and transactions
09:28:54 <matthew-_> byorgey: but, if you use the default MyISAM engine then it's not ACID
09:29:07 <quicksilver> byorgey: these days, it has some support for these things, but it still has a weak SQL dialect
09:29:10 <matthew-_> byorgey: and if you switch to the InnoDB engine then it is ACID, but it's quite slow
09:29:34 * SamB doesn't see how anyone can possibly ever cycle while playing a grand piano
09:29:58 <SamB> sqlite doesn't seem to have "with"
09:30:00 <matthew-_> maybe it was a "baby grand"
09:30:03 <sjanssen> SamB: cycle as in bicycle?
09:30:16 <byorgey> ok, thanks
09:30:29 <SamB> sjanssen: well unicycle is even less likely...
09:30:33 <Philippa> SamB: gears, /big/ bike...
09:30:46 <quicksilver> it was a bicylce
09:30:49 <quicksilver> and it was a baby grand
09:30:55 <quicksilver> and it was still an impressive feat, IMO
09:30:58 <sjanssen> I've seen a trombonist on a unicycle before -- but that's not nearly as good
09:31:03 <matthew-_> no 9' steinway then?
09:31:10 <Philippa> yeah, you wouldn't want to screw your balance up with it
09:31:14 <quicksilver> no, but it was a good 6'
09:31:18 <Philippa> turning'd be a bitch
09:31:23 <matthew-_> was the bike in front or behind?
09:31:29 <quicksilver> (it could have been cheating with extra wheels: I was viewing it from above)
09:31:48 <quicksilver> matthew-_: underneath, but the rider was facing the keys (so he could play)
09:31:51 <byorgey> tuning'd be a bitch too
09:32:07 <matthew-_> what was he playing?
09:32:08 * SamB wonders how you steer that
09:32:33 <quicksilver> sounded like a cheerful jazz number
09:32:36 <quicksilver> not something I recognised
09:32:39 <matthew-_> quicksilver: are you sure it was real? are you sure it wasn't a dream / drug trip?
09:32:41 <matthew-_> ;-P
09:32:48 <quicksilver> I have a bunch of witness
09:32:53 <quicksilver> quicksil1er: wtf are you doing here?
09:34:33 <sjanssen> quicksilver: was the pianist playing 'The Entertainer'?
09:34:42 <sjanssen> that would make this story truly hilarious
09:35:32 <quicksilver> sjanssen: no, sadly. I'd have recognised that one :)
09:36:20 <fasta> How can I express that whenever I have "+" in my program the type of the operands should be Int or Integer? I think the default keyword should be used, but I don't know it by heart.
09:36:23 <ski> quicksilver : you were seeing double for a second there ?
09:36:53 <sjanssen> fasta: default(Integer, Int), perhaps?
09:37:03 <quicksilver> ski: I lost link to freenode, reconnected by hand, and then 5 minutes later my too-clever IRC client decided to auto-reconnect
09:37:22 <fasta> sjanssen: oh, right, type defaulting only worked for Num
09:37:41 <fasta> sjanssen: I wondered how to bind the Num class to it.
09:38:05 <flux> sjanssen, great going! now I keep whistling 'The Entertainer'. thanks a lot!
09:38:23 <sjanssen> flux: I started whistling it, and had to spread the curse
09:38:26 <sorear> fasta: defaults have nothing to do with this
09:38:38 <sorear> fasta: defaulting is only for type ambiguity
09:38:47 <sorear> fasta: it doesn't constrain anything
09:39:02 <ski> quicksilver : i take you're not running screen, then
09:39:09 <Apocalisp> What is it that lets me say [1,2,3] instead of 1:2:3:[] ?
09:39:17 <ski> syntactic sugar
09:39:21 <fasta> sorear: ok, so there is no way to express it?
09:39:24 <LoganCapaldo> Apocalisp: the parser
09:39:33 <Apocalisp> ok, so it's built into the compiler
09:39:42 <quicksilver> ski: I am running screen, but that doesn't help if my screen machine actually loses it's link to freenode
09:39:54 <quicksilver> Apocalisp: yes
09:39:59 <oerjan> fasta: you can define your own version of +, hiding the original
09:40:24 <Apocalisp> Can I make my own syntactic sugar like that without modifying the compiler?
09:40:30 <ski> no
09:40:36 <Apocalisp> :-(
09:40:40 <LoganCapaldo> yes
09:40:44 <Apocalisp> :-)
09:40:48 <sjanssen> @remember quicksilver interesting. Someone just cycled past playing a grand piano.
09:40:48 <lambdabot> Done.
09:41:11 <LoganCapaldo> But you'll have to write your own parser to preprocess it, transform it into valid Haskell and then feed it to ghc or whatever
09:41:18 <sjanssen> Apocalisp: not exactly, but you can go quite far with operator overloading, do syntax, etc.
09:41:33 <fasta> oerjan: that doesn't work for the "or"
09:41:57 <oerjan> fasta: it would be a bit verbose but something like this:
09:41:58 <ski> LoganCapaldo : that doesn't sound very different from modifying a compiler to me :)
09:42:10 <Apocalisp> Ok, so syntactic sugar for embedded DSL: no.
09:42:35 <LoganCapaldo> ski: but you're not modifying the compiler, you're wrapping it :)
09:42:47 <ski> i.e. creating a new compiler
09:42:52 <LoganCapaldo> Does map modify it's first argument? :)
09:42:54 <ski> but yes, it's arguable
09:43:20 <ski> s/it's/its/
09:43:31 <sorear> fasta: Why!?
09:43:49 <oerjan> import qualified Prelude ((+)); import Prelude hiding ((+)); class MyPlus a where (+) :: a -> a -> a; instance MyPlus Int where (+) = (Prelude.+); instance MyPlus Integer where (+) = (Prelude.+)
09:43:55 <fasta> sorear: Because now the code is expecting Num(t2 Int)
09:43:57 <sorear> we have overloading for a reason!
09:43:59 <oerjan> or thereabouts
09:44:17 <fasta> sorear: Since I never expect to do that, I consider that an error in my programs.
09:44:40 <oerjan> except now you couldn't get defaulting to either
09:44:47 <oerjan> by normal means
09:45:05 <ddarius> You can embed LR(1) languages into Haskell.
09:45:33 <Apocalisp> ddarius: Yes, but can you make them pretty?
09:45:50 <oerjan> (those ; need to be newlines, i don't think the indentation is right otherwise)
09:46:24 <ddarius> Apocalisp: You are only limited to tokens than parse as Haskell identifiers.
09:46:41 <ddarius> @google Typed Quote/AntiQuote
09:46:43 <lambdabot> http://www.informatik.uni-bonn.de/~ralf/publications/Quote.pdf
09:48:34 <Apocalisp> ooh, very nice
09:49:31 <fasta> sorear: do you often use Num(t <something>) instances?
09:49:52 <sorear> fasta: Not often, but I've done it
09:50:06 <sorear> fasta: The most natural expression of the Mandelbrot set uses them
09:50:19 <sorear> fasta: Namely Num (Complex Double)
09:51:05 <oerjan> not to forget Num (Ratio Integer)
09:51:36 <quicksilver> and a careful continued fraction implementation might look smoething like Num [Integer]
09:51:47 <quicksilver> although I don't claim to have thought hard about that
09:51:55 <opqdonut> quicksilver: yeah it should
09:52:26 <opqdonut> polynomials could also be represented as Num [Integer]
09:52:47 <fasta> sorear: do you have an URL for that particular use(Mandelbrot)?
09:52:52 <Syzygy-> opqdonut: As long as they are univariate.
09:52:53 <hpaste>  sjanssen pasted "Haskell's syntax is surprisingly flexible" at http://hpaste.org/413
09:52:57 <sorear> fasta: No.
09:53:01 <opqdonut> Syzygy-: yeah, univariate
09:53:11 <sorear> fasta: HPaste deleted it.
09:53:22 <Syzygy-> n-variate are, naturally, Num [(Integer, Integer, ... , Integer)]
09:53:27 <sorear> fasta: shapr can gve you a raw dump
09:53:29 <Syzygy-> And oo-variate are Num [[Integer]]
09:53:46 <sorear> OO-variate?
09:53:51 <opqdonut> sjanssen: nice
09:53:51 <sorear> oh, omega
09:53:52 <sjanssen> Apocalisp: http://hpaste.org/413 you can do many things with vanilla Haskell syntax, is syntactic extension really necessary?
09:54:05 <sorear> s/omega/aleph-null/
09:54:09 <sjanssen> opqdonut: I got the trick from Oleg IIRC
09:54:39 <DRMacIver> Doesn't all knowledge ultimately come from Oleg?
09:54:49 <Syzygy-> Most probably, yeah.
09:55:03 <sjanssen> @remember DRMacIver Doesn't all knowledge ultimately come from Oleg?
09:55:04 <lambdabot> Done.
09:55:17 <ddarius> @oldwiki InfixExpressions
09:55:18 <lambdabot> http://www.haskell.org/hawiki/InfixExpressions
09:55:34 <ddarius> @oldwiki InfixExpression
09:55:34 <lambdabot> http://www.haskell.org/hawiki/InfixExpression
09:56:16 <sjanssen> wow, the example is even the same
09:56:16 <DRMacIver> I seem to get quoted on lb alarmingly often. :)
09:56:35 <dmhouse> DRMacIver: say more boring things, then.
09:56:45 <sioraiocht> @quote Srzgzy-
09:56:46 <lambdabot> No quotes match. That's something I cannot allow to happen.
09:56:48 <dmhouse> Or rather, fewer quotable things.
09:57:11 <sjanssen> @remember DRMacIver I seem to get quoted on lb alarmingly often. :)
09:57:11 <lambdabot> Done.
09:57:20 <sioraiocht> @quote DRMacIver
09:57:21 <lambdabot> DRMacIver says: Doesn't all knowledge ultimately come from Oleg?
09:57:22 <LoganCapaldo> sjanssen: beat me to it! grr
09:57:33 <sjanssen> @flush
09:57:46 <titto> a silly question, shouldn't this work:  read "k" :: Char   ?
09:57:48 <dmhouse> ?help flush
09:57:48 <lambdabot> flush. flush state to disk
09:57:58 <LoganCapaldo> titto: no
09:57:59 <dmhouse> titto: what do you want to do? Convert a String to a Char?
09:58:08 <LoganCapaldo> > read "'k'" :: Char
09:58:11 <lambdabot>  'k'
09:58:18 <dmhouse> titto: if you _know_ it's a string of only one character long, then use head.
09:58:19 <sioraiocht> > read "k" :: Char
09:58:20 <titto> ah :-)
09:58:21 <lambdabot>  Exception: Prelude.read: no parse
09:58:23 <ddarius> > head "k"
09:58:24 <lambdabot>  'k'
09:58:27 <titto> thanks
09:58:42 <ddarius> The difference a single character makes...
09:59:09 <titto> indeed :-)
10:01:00 <titto> by the way, I am writing a little parser using frisby and it is really good, I advice everybody to have a look: http://repetae.net/computer/frisby
10:01:05 <titto> With respect to the 'classic' haskell parser has the advantage of being lazy, apparently should also be faster (unchecked).
10:02:01 <titto> http://repetae.net/computer/frisby/
10:04:29 <sorear> titto: JohnMeacham is a regular here :)
10:05:36 <ndm> titto: i was under the impression it required all the input to be in memory at once, which is definately not lazy
10:07:57 <titto> better ask John about that then :-), what I can see is that there is a test where it parses an infinite string returning just the first few hits.
10:08:48 <SamB> PEG parsers can be fully lazy, only as much of the input is read as is needed to satisfy the demand on the output, and once the output has been processed, the memory is immediately reclaimed since a PEG parser never backtracks
10:08:57 <SamB> from http://repetae.net/computer/frisby/
10:09:18 <shapr> yay PEG!
10:09:32 <shapr> hiya pesco! long time no see!
10:09:38 <SamB> yay for frisby and the packrats of nim
10:09:51 <ski> nimh ?
10:09:57 <pesco> Ahoj shapr! :)
10:09:58 <SamB> I suck at spelling
10:10:08 <SamB> I don't think I've actually read the book anyway
10:10:14 <shapr> 'nimh'
10:10:23 <shapr> short for national institute of mental health
10:10:30 <sorear> US gov't agency
10:10:32 <ddarius> nim
10:10:41 <SamB> I suspected it was nimh, actually...
10:10:41 <dylan> NIMH! I'm never going back!
10:10:44 * dylan rocks back and forth
10:11:08 <sorear> ndm: what does joinPath do?
10:11:22 <sorear> ndm: your properties would be satisfied by concat!
10:11:27 <hkBst> what's wrong with: (+) $ 3 4
10:11:39 <mauke> hkBst: 3 is not a function
10:11:40 <sorear> hkBst: it parses as (+) (3 4)
10:11:53 <ndm> sorear: can't remember...
10:11:57 <sorear> hkBst: and 3 is not normally a function
10:12:13 <ddarius> Nope, I'm wrong or thinking of something else.
10:12:19 <ndm> sorear:  joinPath (splitDirectories (makeValid x)) `equalFilePath` makeValid x
10:12:20 <dylan> > let 3 x = x in 3 4
10:12:20 <lambdabot>  Parse error in pattern
10:12:28 <ddarius> Who says 3 is not a function?
10:12:36 <sorear> ndm: And...?
10:12:36 <ndm> sorear: not all the joinPath properties are under joinPath, it puts the slashes between them
10:12:44 <rretzbach> What is the proper Haskell extension for code files? .h98?
10:12:49 <ddarius> .hs
10:12:49 <sorear> ah, I'll look elsewhere
10:12:51 <ddarius> or .lhs
10:12:51 <dmhouse> ddarius: the compiler, apparently. It just gave you an error ;)
10:12:59 <ndm> sorear: concat . intersperse "/" -- roughly
10:13:11 <rretzbach> Is hs also the abbreviation of the language?
10:13:13 <ndm> sorear: that should have a better description though, one sec..
10:13:14 <sorear> ndm: what about on macs?
10:13:17 <pesco> The grammar probably doesn't allow 3 as an identifier.
10:13:27 <ddarius> dmhouse: ? And did it say 3 is not a function?  No, it said something like missing instance Num (a -> b)
10:13:29 <ndm> sorear: macs have / as the separator
10:13:35 <sorear> I meant old ones.
10:13:39 <pesco> rretzbach: There is no official abbreviation for Haskell, I'd say.
10:13:44 <dmhouse> ddarius: no, it said 'Parse error in pattern', because numeric literals can't be used as names for functions.
10:13:55 <pesco> Which languages are there that have an official abbreviation?
10:13:59 <ndm> sorear: don't use old macs with FilePath :)
10:14:15 <rretzbach> So do you even shorten it or take the time and write it in its whole glory?
10:14:17 <mauke> Beginners' All-purpose Symbolic Instruction Code
10:14:19 <sorear> :)
10:14:19 <ndm> Igloo: under the library maintainership policy, can i just update the docs for filepath because i feel like it?
10:14:28 <ddarius> dmhouse: It's not a function identifier, but you can't write let (\x -> x) y = y either and \x -> x is a function.
10:14:29 <dmhouse> ddarius: of course, if you were to define instance Num (a -> b), then it would be a function, but that's not what you did.
10:14:35 <SamB> @pl \x -> testParser =<< readFile x
10:14:35 <lambdabot> (testParser =<<) . readFile
10:14:39 <ddarius> dmhouse: I didn't do anything.
10:14:53 <ndm> sorear: if there is a real need for using it with old macs, the solution is to add System.FilePath.CrappyMac and fix everything that way, then #ifdef in the appropriate one
10:14:54 <ddarius> dmhouse: I'm not dylan
10:14:55 <sorear> ndm: Uhm, why *wouldn't* you be able to patch it?
10:14:57 <dmhouse> ddarius: oh! *Smacks forehead* Sorry.
10:15:14 <ndm> sorear: its an official library package now, so there is the whole "changing the library" policy
10:15:18 <oerjan> rretzbach: haskell itself is normally not shortened but the specific version h98 may be
10:15:32 <ddarius> h5l Yay
10:15:34 <sorear> ndm: Ooops...
10:15:44 <Igloo> ndm: Yes
10:15:55 <ndm> cool :)
10:16:07 <oerjan> and i saw H' just today
10:16:09 <sorear> ndm: I patched template-haskell a few months ago without bothering to check for bureaucratic requirements!
10:16:21 <sorear> ndm: or does this only apply to direct pushes?
10:16:35 <rretzbach> I see, thanks for clarification.
10:16:47 <ndm> sorear: no idea, i'll just patch and push
10:18:01 <ndm> its only a one line comment which is automatically quickchecked :)
10:18:38 <ndm> not that the documentation will update, Igloo's change to importing directory broke that a while ago...
10:19:03 <DRMacIver> So, who is going to be at london HUG tomorrow? :)
10:19:58 <sorear> ndm: So joinPath = foldr (</>) "." ?
10:19:58 <Philippa> ...*D'oh*
10:20:08 <ndm> sorear: foldr combine "" x
10:20:09 <Philippa> I should've checked, shouldn't I? I'm not heading for london 'til thursday
10:20:24 <sorear> ndm: since when is "" a legal path ...
10:20:45 <ndm> sorear: since when is [] a list of legal paths?
10:20:48 * sorear is trying to avoid reading the code, because that would make hardwiring assumptions much easier
10:21:05 <sorear> good point.
10:21:18 <dmhouse> ndm: so use foldr1, surely?
10:21:19 <Philippa> ndm: it's a list of anything you like :-)
10:21:22 <ndm> i'll add a documentation point that joinPaths [] = "", since that is a corner case
10:21:37 <ndm> dmhouse: no function in FilePath will ever crash (i have a proof)
10:21:49 <Philippa> yeah, it's that or you have to wrap it in a Maybe
10:22:19 <dmhouse> ndm: that's a bit useless a claim if it makes it easier for the caller to crash.
10:22:46 <ndm> dmhouse: true, but joinPath isn't exactly on the list of common functions for filepath
10:22:48 <sorear> IMO joinPath [] should return "."
10:23:07 <dmhouse> ndm: why is that an argument?
10:23:11 <dmhouse> sorear: that sounds like the best option.
10:23:12 <ndm> sorear: "." in some systems is a symlink, which may not point at the current directory
10:23:17 <ndm> dmhouse: its not a good one...
10:23:56 <sorear> ndm: Oooh.  I'd never heard of that before
10:24:03 <ndm> i have tried to avoid the "." is current directory assumption
10:24:03 <dmhouse> *Sigh* all this could be circumvented if we had a way of statically tagging lists as empty or non-empty.
10:24:09 <sorear> ndm: I've heard of . beigng a hard link
10:24:18 <ndm> you certainly can't use ".." as parent...
10:24:38 <DRMacIver> dmhouse: I know of at least one non dependently typed language which does it. :)
10:24:48 <SamB> sorear: usually . *is* a hardlink
10:25:03 <ndm> sorear: hardlink means it can be changed though, right?
10:25:12 <SamB> ndm: you think so?
10:25:22 <ndm> SamB, i know that .. definately can be
10:25:34 <DRMacIver> dmhouse: All you need is to promote constructors to types, allow subtyping and multiple dispatch and you're sorted. ;)
10:25:39 <DRMacIver> Oops, got to go.
10:26:11 <SamB> ndm: to something other than the actual parent directory?
10:26:21 <SamB> ... *without* trashing your filesystem?
10:26:23 <ndm> SamB, YES! (aren't filepaths broken)
10:26:29 <Apocalisp> Is there an LL(k) parser generator for Haskell?
10:26:32 <SamB> and you care about people who do this why?
10:26:35 <ndm> i think the same is true of .
10:26:56 <ndm> SamB, do you remember the filepath flamewars?
10:26:59 <SamB> I think they should be left to deal with the consequences of their own stupidity
10:27:08 <sorear> 	 * Make sure that .. and the parent directory are the same;
10:27:08 <sorear> 	 * offer to fix it if not.
10:27:08 <sorear> 	 */
10:27:18 <sorear> ndm: that's a quote from the e2fsck source code
10:27:29 <SamB> okay, so it can be changed
10:27:46 <SamB> but e2fsck considers not having .. point to the parent 'broken'
10:28:04 <Igloo> ndm: Huh? Wasn't that a cpphs/cpp/haddock problem?
10:28:06 <sorear> Do you really want to support filesystems that can't be fscked?
10:28:07 <ndm> yes, but during the flamewar i got told that assuming . = current or .. = parent is wrong
10:28:28 <ndm> Igloo: ? with what?
10:28:32 <sorear> 06:48 < lambdabot> ndm said 41m 54s ago: "." ? making the current directory relative to the current directory is just "." is it not?
10:28:35 <Igloo> [18:17] < ndm> not that the documentation will update, Igloo's change to  importing directory broke that a while ago...
10:29:06 <ndm> Igloo: no, this is on linux, because you added directory as a dependency
10:29:22 <Igloo> Oh, so what breaks?
10:29:22 <ndm> Igloo: darcs filepath can't be build on GHC 6.6.1 anymore
10:29:35 * Igloo has flipping that dependency around on my TODO list
10:29:40 <Igloo> Ah, OK
10:29:40 <ndm> configure can't find directory
10:29:46 * Igloo AFKs
10:29:50 <sorear> ndm: URL?  (re filepath flamewars)
10:29:54 <ndm> sorear: thats a reasonable approximation
10:30:02 <ndm> sorear: haskell-cafe, two of them
10:30:34 <ndm> sorear: http://www.haskell.org/pipermail/haskell-cafe/2006-July/thread.html#16957
10:30:36 <lambdabot> Title: The Haskell-Cafe July 2006 Archive by thread, http://tinyurl.com/2y5g8a
10:31:01 <ndm> its _amazing_ how many people want filepaths that don't match reality in any remote way
10:31:37 <ndm> sorear: your extra joinPath documentation has been checked in: joinPath ["test","file","path"] == "test/file/path" (on Posix)
10:33:16 <vincenz> Lemmih: ping
10:33:17 <vincenz> ADEpt: ping
10:35:16 <SamB> ndm: who told you that that is wrong?
10:35:40 <ndm> SamB, can't remember, I'm sure JaffaCake said that .. was not parent directory
10:36:06 <matthew-_> yeah, I remember that conversation
10:36:06 <SamB> okay, JaffaCake is definately someone not to just ignore
10:36:11 <matthew-_> it was to do with symlinks
10:36:13 <mdmkolbe|work> ndm: windows or linux?
10:36:23 <ndm> mdmkolbe|work: either, the library has to be portable to both
10:36:34 <allbery_b> symlinks, mountpoints, and some nonstandard filesystems
10:36:41 * ndm invokes the power to the JaffaCake to win an argument, yay!
10:36:55 <allbery_b> well, I think mountpoints fake it.  usually
10:36:59 <SamB> ndm: it's nice to know what systems invalidate assumptions, etc.
10:37:09 <allbery_b> directory symlinks are a definite issue though
10:37:11 <mdmkolbe|work> ndm: this implies that "foo/../bar" is not always the same as "bar" right?
10:37:17 <ndm> mdmkolbe|work: yes
10:37:19 <allbery_b> yep
10:37:38 <SamB> directory symlinks have strange parents
10:37:39 <ndm> SamB, filepaths are silly things, with really stupid semantics - the closer you look, the more broken they get
10:37:42 <allbery_b> (also afs mountpoints, but those are secretly symlinks anyway)
10:38:08 <matthew-_> filesystems as a whole are stupid
10:38:34 <mdmkolbe|work> I heard of someone who used that trick to make "hidden" folders that could only be accessed via "..".  (Apparently they were a bit paranoid)
10:38:56 <allbery_b> hm.  stupid question?  if IArray provides a method for retrieving bounds, why is it conditional on the array element type?
10:39:10 <allbery_b> or, closer to where I'm actualy going here, how do I roll by own UArray
10:39:11 <allbery_b> ?
10:39:12 <SamB> I don't see how this makes ".." no longer parent
10:39:35 <allbery_b> the parent is the parent as seen from the original path of the symlink, not necessarily the one you followed
10:39:45 <SamB> yeah
10:40:07 <allbery_b> which leads to surprises if you think .. goes up the way you went down
10:40:14 <SamB> quite
10:40:46 <ndm> anyway, i'm off home
10:40:49 <ndm> bye!
10:41:01 <SamB> I think plan9 fixes this issue...
10:41:17 * ski imagines concurrent zippers traversing the fs
10:41:18 <hkBst> how can I get inferior ghci to calculate something when I reload my code? It doesn't seem to execute "main".
10:41:19 <Cale> allbery_b: Not all array types can hold all kinds of elements.
10:41:35 <SamB> ski: sorta like that, actually...
10:41:46 <Cale> allbery_b: In particular, unboxed arrays are restricted in the types of elements they support.
10:42:11 <SamB> well. actually you just mount the target on the source...
10:42:23 <mdmkolbe|work> hkBst: does ":set -main-is foo" help?
10:42:29 <Cale> allbery_b: I suspect that if you want to roll your own UArray at a high-ish level, you'll have to design it in terms of lower-level UArrays.
10:42:32 <mdmkolbe|work> (where foo is your main
10:43:05 <ski> SamB : one zipper for each "agent" with a current dir
10:43:20 <allbery_b> I noticed the instances didn't exist, but I washoping I could take a (hopefully) completely unboxed record and stuff in a uarray
10:43:32 <mdmkolbe|work> SamB: did plan9 have a separate path-relative ".." or something?
10:43:49 <allbery_b> I think they replaced symlinks with magic mounts
10:43:55 <hkBst> mdmkolbe|work: no, it does not
10:43:59 <SamB> allbery_b: not magic
10:43:59 <allbery_b> everything was done with filesystem mounts
10:44:08 <allbery_b> magic compared to unix
10:44:16 <Cale> allbery_b: It's probably easier to get a tuple of unboxed arrays, one for each field.
10:44:33 <allbery_b> not at all magic for plan9, since it was designed for such things
10:44:38 <mdmkolbe|work> hkBst: what about ":unset -no-hs-main"?
10:44:42 <SamB> its just like mount --bind on Linux
10:44:48 <sorear> Argh!!
10:45:01 <SamB> well.
10:45:08 <SamB> actually --rbind
10:45:13 <sorear> *I* took the time to read the entire thread, and look what happenned! :)
10:45:19 <mdmkolbe|work> hkBst: if that doesn't work, I don't know
10:45:26 <Cale> (but I'm probably the wrong person to ask, since I don't really do a whole lot of low-level stuff)
10:45:32 <SamB> sorear: when we hear "flame thread", we don't tend to want to go near it.
10:45:43 <hkBst> mdmkolbe|work: it says "can't unset GHC command-line flag"
10:46:16 <SamB> anyway, plan9 is the mountiest OS evar
10:46:43 <sorear> hkBst: ghci doesn't run code when reloading, ever
10:47:02 <hkBst> sorear: any wrokaround?
10:47:13 <sorear> hkBst: a macro maybe?
10:48:41 <oerjan> hkBst: have you tried the :main command?
10:49:48 <hkBst> oerjan: I just did. It executed my main once, but didn't when I C-C C-L reloaded it again.
10:50:30 <sorear> hkBst: :main :r :main - only mained once!?
10:51:06 <hkBst> sorear: I did ":main main"
10:51:21 <mdmkolbe|work> sorear: I think he ment that "C-c C-l" doesn't re-run the :main.
10:51:23 <sorear> hkBst: No.  Just :main
10:51:52 <sorear> hkBst: :main runs main, it doesn't set hooks, you run it *after* reloading
10:52:17 <hkBst> sorear: that's veru inconvenient to have to do over and over
10:53:38 <xsdnyd> hi
10:53:46 <sorear> Hello
10:53:59 <sorear> hkBst: Well, add the key and send a patch. :)
10:55:19 * hkBst wonders how other emacs users cope
10:55:22 <hpaste>  xsdnyd pasted "(no title)" at http://hpaste.org/414
10:56:07 <xsdnyd> hi, i get this error when compiling this code ("Main.hs:14:0: parse error (possibly incorrect indentation)").. .i am new to haskell and already checked the intention... i don't know why i get this error...
10:56:09 * allbery_b is not sure he wants to rewrite this again to use tuples of unboxed instead of unboxed records.  or wharecver
10:56:23 <Cale> xsdnyd: You have an if which is missing its else
10:56:33 <shapr> hkBst: What are you trying to do?
10:56:41 <allbery_b> if is an expression, not a statement
10:56:49 <Cale> xsdnyd: Moreover, it looks like the code which is in the 'then' part really should be in the 'else' part.
10:56:49 <oerjan> hkBst: i think you can define a shortcut with something like :def rr (":reload\n:main "++)
10:56:50 <allbery_b> (if p then t else e)
10:56:57 <hkBst> shapr: I want my program to be excuted when it is reloaded
10:57:58 <Cale> xsdnyd: Also, the indentation looks a bit off -- make sure you're not mixing tabs and spaces.
10:58:00 <xsdnyd> Cale, oh youre right... in haskell every if statement needs an else??
10:58:01 <shapr> hkBst: If you want to do something like run a piece of code after changing the source, try using -- Local Variables: \n-- compile-command: "ghc --make FileName.hs && ./FileName" \n-- End:
10:58:13 <Cale> xsdnyd: Yeah, because they're not statements, but expressions.
10:58:23 <shapr> hkBst: Then bind F12 to compile
10:58:52 <Cale> That is to say, they evaluate to a value, and that's all they're for.
10:59:01 <xsdnyd> Cale, thanks. i will check the spaces and tabs. what should i write in the if oder else case if there is nothing to do?
10:59:08 <Cale> return ()
10:59:22 <Cale> return () is always a no-op.
10:59:22 <xsdnyd> ok thanks
11:00:09 <allbery_b> xsdnyd: also consider then "when" function
11:01:52 <allbery_b> er.  *the* "when" function
11:01:59 <sieni> @src when
11:01:59 <lambdabot> when p s = if p then s else return ()
11:02:44 <sieni> :t when
11:02:46 <LoganCapaldo> I'm surprised it's not when p s = if p then s >> return () else return ()
11:02:46 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:02:47 <sieni> oops
11:02:56 <xsdnyd> ah ok. thank you very much :)
11:03:48 <xsdnyd> also can i use the "not" function to negate boolean expressions?
11:03:58 <sioraiocht> yes
11:04:01 <sioraiocht> > not True
11:04:02 <lambdabot>  False
11:06:02 <xsdnyd> the "when" function does not allow a series of commands with "do" or?
11:06:20 <olsner> :t (True) `when` (do print "blah")
11:06:22 <lambdabot> IO ()
11:06:28 <sioraiocht> :t when
11:06:31 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:06:59 <sioraiocht> > when True (do {print 4; print 5})
11:07:02 <lambdabot>  <IO ()>
11:07:08 <sioraiocht> looks fine to me
11:07:21 <sioraiocht> xsdnyd: yes, you can have a do block inside when
11:08:13 <xsdnyd> sioraiocht, yeah i used olsners code an put the commands in parenthesis
11:08:15 <xsdnyd> :D
11:08:16 <ski> @type unless
11:08:19 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
11:08:20 <LoganCapaldo> actions as values ftw
11:08:53 <sioraiocht> I've never seen someone use when as an operator, it displeases me (no offense)
11:09:23 <Cale> It's sort of grammatically strange to use it that way :)
11:09:42 <Cale> It would be better off flipped if you were going to use it as an operator
11:09:50 <sioraiocht> yeah
11:10:01 <allbery_b> using it as an operator makes me think of postscript
11:10:15 <sioraiocht> ...do a lot of PS programming, do you?
11:10:22 <xsdnyd> PS?
11:10:27 <allbery_b> not a lot, but far too much :)
11:10:27 <xsdnyd> no
11:10:45 <sioraiocht> allbery_b: isn't any too much?
11:10:54 <allbery_b> that was essengtially my point :)
11:11:00 <sioraiocht> tee hee
11:11:19 <Cale> My friend did all his fractals assignments in postscript.
11:11:50 <Cale> There's something funny about getting the printer to compute the M-set for you.
11:12:02 * allbery_b has to do things like port old postscript banner page templates to newer spoolers, and occasionally patch up buggy PPD files
11:12:43 <hpaste>  xsdnyd pasted "another error :-\" at http://hpaste.org/415
11:12:50 <xsdnyd> ok now i get another error :-\ " Main.hs line 20 The last statement in a 'do' construct must be an expression"
11:13:11 <allbery_b> that can be another indentation issue
11:13:33 <allbery_b> yep
11:13:37 <olsner> forth has some insane control constructs... all the do, while, repeat, until, if, else, etc keywords operate on some "control stack" and can be combined in essentially every way imaginable (and unimaginable)
11:13:49 <allbery_b> your return is indented too far and taken as a parameter to the function
11:13:50 <xsdnyd> mhh in the paste i see it too
11:13:53 <allbery_b> on the preceding line
11:14:07 <xsdnyd> i code this in eclipse, and there the display is normal... very strange...
11:14:21 <qwr> what's the point of do return () ? ;)
11:14:25 <allbery_b> also, what's with that dangling foldr?
11:14:27 <qwr> @undo do return ()
11:14:27 <lambdabot> return ()
11:14:30 <Cale> xsdnyd: See if you can get eclipse to turn tabs into spaces.
11:14:39 <sioraiocht> what's "undo" do?
11:14:40 <Cale> qwr: it's a no-op
11:14:53 <Cale> sioraiocht: desugars do-notation
11:14:55 <olsner> http://c2.com/cgi/wiki?ExampleForthCode has a begin..while..while..repeat..else..then loop :P
11:14:57 <lambdabot> Title: Example Forth Code
11:14:58 <xsdnyd> spaces are better for haskell?
11:15:00 <qwr> Cale: yes, like i thought
11:15:07 <allbery_b> xsdnyd: safer, yes
11:15:10 <Cale> xsdnyd: yes
11:15:19 <allbery_b> tabs may expand in different ways in different editors, etc.
11:15:39 <Cale> xsdnyd: Generally I configure my editor to turn tabs into spaces automatically, and treat multiple spaces as if they were a tab.
11:15:45 <allbery_b> and haskell compilers assume a specific meaning (next 8-space boundary) which may ir may not match what your editor does
11:15:49 <allbery_b> so spaces are always safer
11:16:03 <xsdnyd> aaah ok. learning much today :D thank you guys
11:16:13 <shapr> hkBst: Did that work for you?
11:16:26 * olsner wants an AST editor for haskell
11:16:36 <shapr> Me too! and I want it in Yi!
11:16:48 <shapr> I want to do AST macros just like emacs does text macros.
11:17:19 <ski> slime for haskell ?
11:17:41 <hkBst> shapr: I think I could make that work, but it would still be inconvenient. I'm looking into running "runhaskell" instead of ghci.
11:17:48 <olsner> I want it shiny and GUI (gooey?) too.. Text is so 1900:s
11:18:24 <shapr> hkBst: look at the automatic unit testing section of http://www.haskell.org/hawiki/HaskellMode
11:18:26 <lambdabot> Title: HaskellMode - The Haskell Wiki
11:18:41 <xsdnyd> i think i should've stopped with the indention errors... now i get even more and more strange errors...
11:19:07 <Cale> xsdnyd: Well, you are passing 5 parameters to putStrLn there :)
11:19:25 <xsdnyd> really? where?
11:19:36 <Cale> xsdnyd: Or else, if you've fixed the indentation, you have foldr (*) 1 nums on its own line in that do-block
11:19:51 <Cale> But foldr (*) 1 nums is a number, not an action to perform.
11:20:05 <Cale> So you probably want something like print (foldr (*) 1 nums)
11:20:21 <sorear> btw, foldr (*) 1 == product
11:21:11 <xsdnyd> Cale, ah ok i know what you mean
11:21:43 <Cale> did you also fix the indentation on the 'return (val : nums)' line?
11:21:57 <olsner> for added benefit, the haskell AST editor should have a newbie mode that points out all convenient library/prelude functions you're defining on your own
11:22:32 <Cale> olsner: I think ndm wrote something along those lines
11:22:39 <sorear> olsner: We almost have that
11:22:48 <sorear> @google drhaskell ndm
11:22:50 <lambdabot> http://www-users.cs.york.ac.uk/~ndm/drhaskell/
11:22:50 <lambdabot> Title: Neil Mitchell - Dr Haskell
11:22:52 <xsdnyd> Cale, yes i did
11:23:10 <xsdnyd> i only get an error now if i use this line in my code: putStrLn show(foldr (*) 1 nums)
11:23:17 <sorear> yeah
11:23:21 <sorear> bad syntax
11:23:33 <sorear> you need putStrLn (show (foldr (*) 1 nums))
11:23:47 <sorear> in Haskell, the parens go on the OUTSIDE
11:23:53 <Cale> Or if the parens are starting to bug you, use a $ :)
11:24:04 <olsner> and built-in @pl with some fitness/readability heuristics to "point out" things you're doing needlessly pointy
11:24:18 <Cale> putStrLn $ show (foldr (*) 1 nums)
11:24:24 <Cale> putStrLn . show $ foldr (*) 1 nums
11:24:39 <Cale> print $ foldr (*) 1 nums
11:24:57 <Cale> (print = putStrLn . show)
11:25:08 <sorear> print $ product nums
11:25:16 <sorear> (product = foldr (*) 1)
11:25:23 <xsdnyd> Cale, sorear, coool. it now works if i set the parents on the outside
11:26:35 <xsdnyd> really cool. thanks for all your help... the haskell community is very helpful :)
11:27:28 <sorear> We try. :)
11:28:44 * sorear wants a function to go from "Data.ByteString.Char8.Lazy" to ["Data", "ByteString", "Char8", "Lazy"]
11:28:47 <sorear> :(
11:29:22 <dcoutts> sorear: the ByteString module has one iirc
11:32:39 <byorgey> @hoogle (Char -> Bool) -> String -> [String]
11:32:40 <lambdabot> No matches, try a more general search
11:33:13 <kaol> @src words
11:33:13 <lambdabot> words s = case dropWhile isSpace s of
11:33:13 <lambdabot>     "" -> []
11:33:13 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
11:33:51 <kaol> a bit like that but with something besides isSpace?
11:34:36 <olsner> :t fields
11:34:38 <lambdabot> Not in scope: `fields'
11:35:01 <olsner> fields/unfields could be a name for a pair of functions to match lines and words
11:35:09 <sieni> @hoogle (a -> Bool) -> a -> [a]
11:35:10 <lambdabot> No matches, try a more general search
11:36:11 <Saizan>  @hoogle (a -> Bool) -> [a] -> [a]
11:36:15 <Saizan> @hoogle (a -> Bool) -> [a] -> [a]
11:36:16 <lambdabot> Prelude.dropWhile :: (a -> Bool) -> [a] -> [a]
11:36:16 <lambdabot> Prelude.filter :: (a -> Bool) -> [a] -> [a]
11:36:16 <lambdabot> Prelude.takeWhile :: (a -> Bool) -> [a] -> [a]
11:36:38 <sieni> oops
11:36:50 <sieni> @hoogle (a -> Bool) -> [a] -> [[a]]
11:36:51 <lambdabot> No matches, try a more general search
11:36:58 <sieni> dang
11:37:22 <kaol> > words $ map (\x -> if x == '.' then ' ' else x) "Data.ByteString.Char8.Lazy"
11:37:24 <lambdabot>  ["Data","ByteString","Char8","Lazy"]
11:37:58 <olsner> > words $ map (\x -> if x == '.' then ' ' else x) "Data.Byte String.Ch ar8.La zy"
11:38:00 <lambdabot>  ["Data","Byte","String","Ch","ar8","La","zy"]
11:38:18 <kaol> pfft, details
11:38:22 <dcoutts> @src lines
11:38:22 <lambdabot> Source not found. Take a stress pill and think things over.
11:39:07 <Saizan> > let isDot = (=='.') in filter (not.all isDot) . groupBy (\x y -> isDot x == isDot y) $ "Data.ByteString.Char8.Lazy"
11:39:09 <lambdabot>  ["Data","ByteString","Char8","Lazy"]
11:39:43 <olsner> > let f = (\x -> case x of '.'->' ';' '->'.') in map (map f) $ words $ map f "Data.Byte String.Ch ar8.La zy"
11:39:46 <lambdabot>   Non-exhaustive patterns in case
11:39:54 <olsner> oops
11:40:12 <olsner> > let f = (\x -> case x of '.'->' ';' '->'.';c->c) in map (map f) $ words $ map f "Data.Byte String.Ch ar8.La zy"
11:40:13 <lambdabot>  ["Data","Byte String","Ch ar8","La zy"]
11:41:00 <olsner> @src groupBy
11:41:00 <lambdabot> groupBy _  []       =  []
11:41:00 <lambdabot> groupBy eq (x:xs)   =  (x:ys) : groupBy eq zs
11:41:00 <lambdabot>     where (ys,zs) = span (eq x) xs
11:43:02 <allbery_b> okay, another sily question:  why the heck doesn;t gtk2hs use bytestrings, given that what it passes to gtk2 needs to be essentially bytestrngs anyway?
11:43:20 <dcoutts> allbery_b: it's a good deal older than ByteString
11:43:41 <dcoutts> and much of the time the size of string is small so the format is not important
11:43:48 <olsner> gtk2 takes UTF-8.. there should be a recode pass in there to convert Char to/from UTF-8
11:43:59 <dcoutts> it does do that
11:44:20 <dcoutts> Gtk2Hs treats String as a Unicode string
11:45:08 <olsner> but if it used ByteString, wouldn't it be restrained to 1 byte characters?
11:45:50 <dcoutts> olsner: at the moment yes, ByteString is not Unicode, that's another good reason not to use it instead of String
11:46:05 <dcoutts> the place you do want ByteString in Gtk2Hs is in a couple of places where we have to get/set large buffers
11:46:14 <dcoutts> like a TextBuffer's content
11:46:32 <dcoutts> and yes, that'll need to wait for a Unicode variant of ByteString
11:46:57 <quicksilver> wide-char-based rather than UTF8-based, that is
11:47:32 <quicksilver> although you could hack something together with compactstring (which is utf8-capable)
11:47:35 <allbery_b> oh well
11:47:36 <LoganCapaldo> what kind of GC does GHC use if I may ask?
11:47:37 <norpan> didn't we make UTF-8 bytestings
11:47:38 <quicksilver> and bypassing the current recoding
11:48:12 <dcoutts> norpan: I've seen some code, I'm not sure how well it's been reviewed and tested or tuned for performance
11:49:06 <norpan> going 16-bit or 32-bit should be no big worry, as [Char] takes much more space than that anyway
11:49:10 <dcoutts> it should be possible to make a unicode packed string impl using the bytestring fusion framework, which would give all 3 unicode encodings and fusion support
11:50:04 <dcoutts> all it needs for the fusible ops is a function to convert from the encoding in a chunk of memory to a Stream Char
11:51:57 <olsner> could that chunk of memory be chunked in the middle of a multibyte character? what happens then?
11:55:07 <quicksilver> you'd likely want that as an invariant
11:55:12 <quicksilver> (that that should never happen)
11:56:50 <sieni> in what kind of encoding?
11:57:26 <sieni> in utf-8 for example you can tell where the character boundaries lie just by looking at the bytes locally
11:57:34 <sieni> as designed
12:03:23 <olsner> presumably, the chunking process doesn't want to even look at the bytes
12:03:51 <sjanssen> dcoutts: is the polymorphic stream stuff in an accessible form?
12:06:56 <dcoutts> sjanssen: it's in our list repo
12:07:26 <dcoutts> http://www.cse.unsw.edu.au/~dons/code/streams/list/
12:07:26 <lambdabot> Title: Index of /~dons/code/streams/list
12:08:51 <dcoutts> olsner, sieni: I'm not sure that one could reasonably enforce that multi-byte chars do not cross chunk boundaries, eg think of reading a file in 4k chunks.
12:09:00 <wy> sorear: I'm back ;-)
12:09:02 <fnord123> hi all
12:09:16 <fnord123> > show [1]
12:09:18 <lambdabot>  "[1]"
12:09:57 <dcoutts> olsner, sieni: and I don't see that letting them cross chunk boundaries causes any particular problems
12:11:36 <sorear> LoganCapaldo: Compacting, with write barriers.  Beyond that it's too variable (command line options) for me to say.
12:12:32 <LoganCapaldo> sorear: thanks
12:12:42 <sorear> LoganCapaldo: By default it is a two-stage generational copying-compacting collector with a 2x hysteresis factor and a 256kb per-CPU nursery
12:12:59 <crazy_coder> ##c
12:13:18 <sorear> that's a noun
12:13:28 <sorear> we usually prefer sentances ;)
12:13:59 <crazy_coder> type :(
12:14:02 <crazy_coder> *typo
12:16:11 <LoganCapaldo> per-CPU nurseries. very fancy :)
12:17:25 <sorear> The Glasgow Haskell garbage collector *is* one of the most advanced in the world :)
12:17:44 <sorear> The only ooh-ahh feature it's missing is SMP-parallel collection,
12:17:51 <weitzman> What soft of garbage collector does ghc have?
12:17:59 <weitzman> *sort
12:18:14 <sorear> 12:08 < sorear> LoganCapaldo: Compacting, with write barriers.  Beyond that it's too variable (command line options) for me to say.
12:18:19 <sorear> 12:09 < sorear> LoganCapaldo: By default it is a two-stage generational copying-compacting collector with a 2x hysteresis factor and a 256kb per-CPU nursery
12:19:03 <weitzman> I guess the lack of references in Haskell means the usual worst-case scenario for generational collectors doesn't really come up
12:19:12 <fnord123> Does anyone know why quickQuery returns each value as SqlString in HDBC?  That seems weird since some of the values in my table I'm reading are Integers
12:19:30 <weitzman> Except in really, really crazy code
12:19:32 <dcoutts> weitzman: much less, and mutable references can be tracked specially
12:19:32 <sorear> weitzman: Right.  Although, indirections are a big deal
12:20:12 <weitzman> The thing that makes me nervious about generational collectors is that I know of a project that accidentally designed something that turned out to be the worst case for it
12:20:18 <sorear> If an unevaluated expression is retired (?), and then evaluated, it has to be added to the remembered set.
12:20:25 <weitzman> And wouldn't even run until the wrote a new garbage collector for SML, I believe
12:20:48 <dcoutts> weitzman: involving lots of mutable references I suppose?
12:20:48 <sorear> weitzman: We're way better, then.  +RTS -G1 -RTS
12:21:15 <dcoutts> which means just use one generation
12:21:18 <roconnor> @ba nl en gedonder
12:21:19 <lambdabot>   gedonder
12:21:44 <weitzman> dcoutts: It was a system for adaptive functional computations that lets you change the inputs and recalculate outputs with as little work as possible
12:21:52 <olsner> roconnor: wha?
12:22:16 <dcoutts> weitzman: lots of mutable refs then I guess to memoise intermediate results
12:22:30 <roconnor> olsner: I was trying to translate gedonder to english
12:22:36 <weitzman> dcoutts: Yes, and you go in and change very old refs to redo the computation
12:23:08 <roconnor> free translation says it means rumbling
12:23:27 <oerjan> roconnor: thunder i guess
12:23:30 <olsner> could be related to the word thunder
12:23:34 <dcoutts> weitzman: I wonder if it'd be faster to try and do that in a persistent style rather than using mutable cells
12:23:58 <int-e> @ba nl en donder
12:23:59 <lambdabot>   thunder
12:24:30 <olsner> @ba en jp thunder
12:24:30 <lambdabot> Plugin `babel' failed with: IRCRaised Error: Language jp not supported
12:24:40 <olsner> @ba en ja thunder
12:24:41 <lambdabot>   can't parse this language
12:24:56 <weitzman> dcoutts: I believe this was the project that ran into trouble: http://www.cs.cmu.edu/~sangria/publications/popl02.pdf
12:24:56 <pastorn> someone here has a good template for TeX with code?
12:25:34 <xs> hi! *** Exception: Data.ByteString.Lazy.groupBy: unimplemented! say it ain't so!
12:26:10 <dcoutts> xs: previously it was implemented but borken :-)
12:26:35 <xs> darn! oh well :)
12:26:37 <dcoutts> xs: I'll be looking at this soon for the next version of the bytestring package
12:26:45 <xs> cool. is it hard to do?
12:27:03 <dcoutts> xs: groupBy is tricky because of the chunked representation
12:27:15 <weitzman> dcoutts: There's some brief mention of the garbage collector problems here: http://www.cs.cmu.edu/~guyb/papers/ABBT06.pdf
12:27:30 <xs> dcoutts: hm, okay. thanks anyhow! :)
12:27:33 <dcoutts> weitzman: ta
12:29:00 <Cale> xs: on the other hand, groupBy on ordinary lists can operate lazily -- you'll likely lose some performance in the translation though
12:29:15 <sorear> dcoutts: Is it really that much harder than splitWith?
12:29:41 <dcoutts> sorear: I don't remember exactly, feel free to try it
12:31:39 <weitzman> dcoutts: I guess the question of the day is whether anyone's done performance testing with the Haskell port http://www.cse.ogi.edu/~magnus/Adaptive/
12:31:40 <lambdabot> Title: Adaptive -- Incremental Computations in Haskell
12:32:01 <weitzman> dcoutts: I looked into the Haskell port a bit back, but I don't remember how it's implemented anymore
12:32:49 <int-e> why do people want to have unlimited reflection?
12:33:04 <dcoutts> weitzman: looks like it uses IORefs or STRefs, which are the same from a GC-point of view
12:33:41 <ski> what is unlimited reflection ?
12:34:21 <int-e> well, in the current discussion on haskell-cafe, a mapping of type name and representation to a value.
12:35:19 <dcoutts> people have repeatedly pointed out that it's useless right?
12:35:34 <int-e> the "unlimited" was a qualification by me, not an established term. I meant that within limits (known type class) reflection has its uses.
12:35:53 <dcoutts> since you can't inspect a value where you don't know anything about its representation
12:36:09 <dcoutts> the best one can do is to parse into a generic structure
12:36:22 <sorear> dcoutts: Typeable
12:36:32 <dcoutts> bleugh
12:36:35 <sorear> dcoutts: (->)
12:37:03 <sorear> dcoutts: Known type classess with (->) fields
12:37:26 <dcoutts> so that's not quite "unlimited"
12:37:39 <sjanssen> when are you going to get data that you know absolutely nothing (not even the type!) about?
12:37:41 <dcoutts> known type classes makes it usable
12:38:43 <dcoutts> sjanssen: people seem to get confused between parameterising by representation and not knowing the representation
12:40:33 <weitzman> "Unlimited reflection" could be handy for aiding development than if not for actually writing code
12:40:39 <sorear> unsafeBreakParametricity :: a -> Dynamic a
12:40:52 <weitzman> Could be useful in writing debuggers, extracting documentation from dynamic plugins (if types supported annotations) and such
12:42:02 <ski> @free unsafeBreakParametricity :: a -> Dynamic a
12:42:03 <lambdabot> $map_Dynamic f . unsafeBreakParametricity = unsafeBreakParametricity . f
12:42:56 <sorear> @freee f :: a -> Dynamic
12:42:56 <lambdabot> f = f . g
12:43:42 <kpreid> @free f :: Typeable a => a -> Dynamic
12:43:43 <lambdabot> Extra stuff at end of line
12:43:50 <kpreid> aw
13:17:44 <jao> hi
13:18:18 <jao> i'm on debian/ppc, and there seems to be no ghci here. as a result, trying to setup cabal packages fails
13:18:29 <jao> is there a workaround?
13:20:00 <Saizan> you can compile the Setup.[l]hs instead of interpreting it
13:20:06 <shapr> cabal-setup compiles Setup.[l]hs to binaries.
13:20:37 <jao> aha. thanks, Saizan, sharp!
13:20:54 <jao> shapr, even
13:21:06 <shapr> hiya jao
13:21:24 <Saizan> also the packaged ghci on debian/ppc is known to not work, but i've read that if you build your ghc it works
13:21:37 <jao> hey shapr
13:22:06 <jao> hmm. what's the deb containing cabal-setup?
13:23:06 <jao> Saizan, that's interesting, because not having ghci is a bad thing (TM)
13:23:08 <shapr> I'd suggest darcs get --partial http://darcs.haskell.org/packages/cabal-setup
13:23:10 <lambdabot> Title: Index of /packages/cabal-setup
13:24:02 * jao darcs gets cabal-setup
13:24:19 <shapr> jao: And cabal-install! darcs get --partial http://darcs.haskell.org/packages/cabal-install
13:24:20 <lambdabot> Title: Index of /packages/cabal-install
13:24:27 <helmut> Hi. Could someone take some time (will take a bit to explain) helping me to implement "lift"?
13:25:10 <jao> shapr, so noted. thanks again :)
13:25:26 <Saizan> helmut: show us your monad transformer :)
13:25:38 <helmut> Saizan: what monad transformer?
13:25:51 <mauke> .oO( hey baby, let me show you my MONAD TRANSFORMER )
13:26:03 <mauke> @index lift
13:26:03 <lambdabot> Control.Monad.Trans, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Cont, Control.Monad.Error, Control.Monad.List, Language.Haskell.TH.Syntax, Text.
13:26:04 <lambdabot> ParserCombinators.ReadPrec, Text.Read
13:26:08 <Saizan> ?type lift
13:26:10 <lambdabot> forall (m :: * -> *) a (t :: (* -> *) -> * -> *). (MonadTrans t, Monad m) => m a -> t m a
13:26:17 <Saizan> are you referring to that lift?
13:26:38 <helmut> uhm. I probably mean something like Language.Haskell.TH.Syntax.
13:27:07 <Saizan> ?type Language.Haskell.TH.Syntax.lift
13:27:11 <lambdabot> forall t. (Language.Haskell.TH.Syntax.Lift t) => t -> Language.Haskell.TH.Syntax.Q Language.Haskell.TH.Syntax.Exp
13:27:12 <helmut> and not exactly that lift, because I'm implementing a lift for another language.
13:27:40 <Saizan> what does it do?
13:27:59 <helmut> Well I have two important types: type Expr which creates an abstract syntax tree of the language.
13:28:13 <helmut> (err data Expr = ..)
13:28:25 <helmut> and data Value for each possible value type.
13:28:36 <helmut> now my lift obviously has to be Value -> Expr
13:29:24 <helmut> Expr is defined in Parser.lg and doesn't know anything about Values whereas Value is defined in Evaluator.hs which imports the Parser.
13:29:35 <mauke> data Expr = ... | Literal Value | ...
13:29:36 <mauke> oh
13:30:07 <helmut> mauke: I thought about that, too until I noticed the extra dependency.
13:31:03 <Saizan> well you can data Expr' a = ... | Literal a | .. if you just worry about dependencies
13:31:55 <mauke> doesn't your parser have to know about values?
13:31:58 <helmut> as Parser.lg will be used by two other implementations I'd favour not modifying it.
13:32:21 <helmut> mauke: no. it has special Expr nodes for constants.
13:32:47 <mauke> bah
13:33:12 <Saizan> ah well, so you just have to pick the right node when lifting, or is there some other problem?
13:33:14 <helmut> and as the other implementations are compilers they don't know about values either.
13:33:36 <helmut> well Function is a Value.
13:34:01 <helmut> Functions have Closures attached and Exprs don't know about Closures either.
13:35:11 <helmut> My current implementations only lifts ints, strings, tuples and tree-like data structures (i.e. no memory (dirt ;-) or functions).
13:35:23 <helmut> because these things can be lifted to constants.
13:35:33 <Saizan> can you paste the two datatypes?
13:35:44 <helmut> yes
13:36:14 <fasta> shapr: how does one install cabal-install? I did runhaskell Setup.lhs configure, but I get Setup.lhs: Warning: Unknown field 'build-type'
13:36:17 <fasta> Setup.lhs: Error: Non-empty library, but empty exposed modules list. Cabal may not build this library correctly
13:36:38 <hpaste>  helmut pasted "Expr and Value" at http://hpaste.org/416
13:37:04 <dcoutts> fasta: the first one is just a warning, not an error
13:37:27 <fasta> dcoutts: I know that
13:37:35 <dcoutts> fasta: and the second error is from trying to build cabal-install too?
13:37:38 <helmut> I think Op, Decl, Closure, Address are missing, but can be imagined.
13:37:45 <fasta> dcoutts: yes
13:37:53 <dcoutts> fasta: what version of Cabal were you starting from?
13:38:03 <dcoutts> and using what version of cabal-install?
13:38:24 <fasta> dcoutts: Cabal is a concept not a binary, so what version are you referring to?
13:38:36 <dcoutts> the version of the Cabal library
13:38:42 <dcoutts> ghc-pkg list Cabal
13:39:21 <fasta> dcoutts: Cabal-1.1.6
13:39:33 <helmut> So you'd say I should add a Literal a to Expr?
13:39:49 <dcoutts> fasta: and using darcs version of cabal-install or some released version?
13:40:03 <fasta> dcoutts: Lemmih suggested me to use the darcs version
13:40:23 <mauke> one time I wrote an interpreter in java. it used a very simple expr type, like this:
13:40:31 <fasta> dcoutts: the version of cabal-install currently installed in unknown to me
13:40:39 <fasta> is*
13:40:43 <mauke> data Expr = Var String | Lit Value | Abstract String Expr | Apply Expr Expr
13:41:10 <fasta> dcoutts: I checked whether I could see --version or something similar but it wasn't there.
13:41:32 <mauke> that was enough to get a simple language working (it had bigints, strings, recursive functions, if/then/else, mutable variables, IO, etc)
13:41:36 * dcoutts is trying latest cabal-install with Cabal-1.1.6
13:42:03 <Saizan> helmut: can't you fake Closure using Let or even App?
13:42:22 <helmut> Saizan: I could, but I cannot fake Addresses.
13:44:53 <dcoutts> fasta: not sure what's going on there, but whatever it is, it's fixed in the current darcs version of Cabal
13:45:24 <dcoutts> fasta: darcs cabal-install tracks the darcs version of the Cabal lib so it's best to use them together
13:45:34 * helmut begins to like the idea of Literal Value.
13:45:35 <Saizan> helmut: right.
13:46:45 <Saizan> the compilers need to know how to deal with your addresses anyway, no?
13:47:12 <fasta> dcoutts: and how do I get this "darcs version of Cabal"?
13:47:14 <helmut> the compilers don't implement addresses yet.
13:47:41 <helmut> I doubt the compilers will implement metaprogramming at all
13:47:47 <dcoutts> fasta: same way you got the darcs version of cabal-install :-)  fasta: darcs get --partial http://darcs.haskell.org/Cabal
13:47:59 <dcoutts> oops
13:48:04 <dcoutts> fasta: darcs get --partial http://darcs.haskell.org/cabal
13:48:06 <lambdabot> Title: Index of /cabal
13:48:17 <dcoutts> wrong case :-)
13:49:49 <helmut> Saizan, mauke: I'll try to hack Literal Value. This will remove some Expr Nodes.
13:49:57 <mcnster> newbie q:  can i use haskell to pickup chicks?
13:50:45 <emu> there's a lot of tail
13:50:54 <fnord123> im too lazy
13:51:02 <mcnster> emu, what about a roll in the monad?
13:51:11 <emu> binding?
13:51:17 <emu> if you're into that
13:51:25 <fnord123> binding and strictness are the way forward.
13:51:43 <sjanssen> bang patterns?
13:51:51 <mcnster> q: how many lazy programmers does it take to change a lightbulb?
13:52:03 <Saizan> infinite?
13:52:07 <mauke> <thunk>
13:52:08 <fnord123> fingernails and barbed wire?
13:52:09 <mcnster> a: we don't know and we don't care (until the program runs)
13:52:30 <mcnster> >:)
13:53:37 <fasta> dcoutts: it says that I need pretty, which I should get from a location that gives a 404
13:54:01 <Saizan> fasta: those are modules derived from the splittage of base
13:54:08 <fasta> dcoutts: (all I want to communicate is that Cabal is not production quality by far)
13:54:16 <helmut> Saizan, mauke: I just noticed it would be getting worse. I'd actually need to define Closure and Address within the Parser. So whereas Literal a might look like a deal, I don't know how, as the parser has to produce an Expr a without knowing about a.
13:55:03 <daniel_larsson> fasta: well, to be fair, you're mixing releases
13:55:51 <Saizan> has cabal-install ever been released?
13:55:56 <fasta> Saizan: no
13:56:15 <fasta> daniel_larsson: AFAIK, I am told to get a certain package from a certain location and that location gives a 404. That's not my mistake.
13:56:18 <daniel_larsson> And it's cabal-install that's messing you up, not cabal
13:56:45 <fasta> daniel_larsson: good software should not cooperate with wrong versions.
13:56:49 <daniel_larsson> fasta: yes, but you're using "HEAD" versions of cabal
13:57:05 <fasta> daniel_larsson: what makes you think that?
13:57:12 <helmut> Can I somehow produce an Expr a without knowing a?
13:57:13 <fasta> daniel_larsson: it might be true, but still.
13:57:35 <Saizan> helmut: you can if you don't need to use the constructor that uses "a"
13:57:53 <daniel_larsson> fasta: You downloaded the darcs version of Cabal?
13:57:56 <fasta> daniel_larsson: and.. is there any other version I can use?
13:58:04 <helmut> Saizan: It won't be used, but how das haskell handle that?
13:58:10 <fasta> daniel_larsson: there are no releases, so, that would be no too.
13:58:18 <fasta> daniel_larsson: yes, I did what dcoutts suggested.
13:58:33 <Saizan> ?type Nothing -- like this
13:58:35 <lambdabot> forall a. Maybe a
13:58:41 <helmut> ah. :-)
13:58:50 <daniel_larsson> fasta: Right :). I'm not trying to cast any blame on you )
13:59:11 <sjanssen> fasta: the 'pretty' package is all of a week old
13:59:23 <sjanssen> fasta: that only exists in a development version of ghc
13:59:35 <daniel_larsson> fasta: If you want stability, go back to Cabal 1.1.6
13:59:44 <fasta> daniel_larsson: I still have it.
14:00:09 <fasta> daniel_larsson: but I was trying to install cabal-install, which depends on the above stuff, so is actually impossible.
14:00:27 <sjanssen> fasta: how can you possibly claim that "Cabal is not production quality by far" when you have a single problem with HEAD software?
14:00:28 <fasta> Which makes Cabal for the "ordinary user" not usable.
14:00:37 <daniel_larsson> Why?
14:00:50 <fasta> sjanssen: my definition of production quality is pretty high.
14:00:50 <daniel_larsson> Why do you need cabal-install to use cabal?
14:01:15 <fasta> sjanssen: I don't consider GhostScript to be production quality, yet thousands of people use it every day.
14:01:36 <sjanssen> fasta: I suggest you temper your statements then
14:01:58 <Excedrin> what's wrong with ghostscript?
14:02:03 <sjanssen> blanket statements like that just cause arguments
14:02:19 <daniel_larsson> If anything, you should blame cabal-install, not cabal :)
14:02:30 <daniel_larsson> but since it's not yet released...
14:02:42 <fasta> daniel_larsson: it's over 2 years old.
14:02:47 <fasta> sjanssen: ok, maybe more acceptable would be to say cabal-install is not perfect.
14:02:49 <daniel_larsson> cabal-install?
14:02:57 <helmut> Saizan: uhm. well I'd have to replace almost any code using Expr with Expr a. that sucks.
14:02:58 <fasta> daniel_larsson: yes
14:03:08 <sjanssen> the problem isn't with cabal-install either
14:03:21 <daniel_larsson> That was the original problem, as I understood it
14:03:22 <fasta> Ok, I do _not_ care who's fault it is.
14:03:35 <sjanssen> the problem is that the pretty package is not on hackage, because it barely exists
14:03:46 <Saizan> helmut: well mostly the type signatures
14:04:18 <fasta> Excedrin: it crashes on stuff that should work, no interest in explaining you specific cases.
14:04:24 <helmut> Saizan: I use them a lot
14:04:44 <sjanssen> helmut: search and replace :)
14:04:56 <emu> how many haskell programmers does it take to change a lightbulb? no more than necessary.
14:05:07 <sioraiocht> bwahahah
14:05:14 <fasta> @lusers
14:05:14 <lambdabot> Maximum users seen in #haskell: 338, currently: 327 (96.7%), active: 14 (4.3%)
14:06:29 <balodja> @loosers
14:06:29 <lambdabot> Unknown command, try @list
14:06:34 <balodja> :(
14:07:26 <fasta> @zusers
14:07:26 <lambdabot> Maximum users seen in #haskell: 338, currently: 325 (96.2%), active: 14 (4.3%)
14:07:47 <fasta> I think the actual command is @users.
14:07:58 <fasta>  @lusers is just a joke
14:08:00 <crackers> I like @lusers
14:08:04 <oerjan> @losers
14:08:04 <lambdabot> Maximum users seen in #haskell: 338, currently: 325 (96.2%), active: 16 (4.9%)
14:08:13 <sieni> @?users
14:08:18 <crackers> ?users
14:08:18 <lambdabot> Maximum users seen in #haskell: 338, currently: 325 (96.2%), active: 17 (5.2%)
14:08:32 <fasta> Anyway, what I think doesn't matter, if you want to know read the source.
14:09:48 <crackers> I have a newbie question about HOpenGL
14:09:58 <crackers> how do I create state variables?
14:11:37 <sorear> crackers: You join the OpenGL consortium and petition for a new one to be created.
14:12:19 <crackers> sorear: where do I do that?
14:13:09 <sorear> *blank stare*
14:13:31 <mauke> haha
14:13:40 <crackers> do they have a website?
14:13:52 <fasta> crackers: you are joking, I hope.
14:14:00 <crackers> yeah, I am
14:14:08 <crackers> not about the state variables though
14:14:17 <crackers> I really would like to know how to create them
14:15:19 <crackers> I just picked up Haskell a few days ago and I'm still trying to get a handle on it
14:15:35 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/OpenGL/Graphics-Rendering-OpenGL-GL-StateVar.html
14:15:37 <lambdabot> http://tinyurl.com/24hd3h
14:15:43 <crackers> the monads and any kind of state persistence is still fuzzy to me
14:15:55 <Cale> makeStateVar :: IO a -> (a -> IO ()) -> StateVar a
14:16:01 <oerjan> @type openFile
14:16:03 <lambdabot> Not in scope: `openFile'
14:16:23 <Cale> You pass it the read and write for any kind of reference you want -- in particular, perhaps you'd like an IORef.
14:16:24 <oerjan> @type stdin
14:16:27 <lambdabot> Not in scope: `stdin'
14:16:53 <oerjan> sheesh, i can't seem to get a Handle either.
14:16:57 <mauke> @type IO.stdin
14:17:00 <lambdabot> GHC.IOBase.Handle
14:17:09 <mauke> @type IO.openFile
14:17:13 <lambdabot> FilePath -> GHC.IOBase.IOMode -> IO GHC.IOBase.Handle
14:18:20 <Cale> Really, that StateVar library doesn't belong inside HOpenGL.
14:18:32 <crackers> that's kind of what I figured
14:19:11 <Cale> It's just something that I figure the HOpenGL library's creators decided would be a nice uniform way to deal with all the different bits of OpenGL state.
14:19:33 <Cale> If you're in IO and want mutable variables, you can use IORefs.
14:20:24 <Cale> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-IORef.html
14:20:26 <lambdabot> http://tinyurl.com/2llq3y
14:20:29 <Cale> the interface is pretty simple
14:20:56 <crackers> thanks
14:21:54 <Cale> If you're struggling with the IO monad, I have a little tutorial that I point everyone at
14:22:11 <Cale> http://haskell.org/haskellwiki/Introduction_to_IO
14:22:12 <lambdabot> Title: Introduction to IO - HaskellWiki
14:22:34 <Cale> It's very brief, but should serve to get the main idea across.
14:22:40 <desp> .
14:23:29 <helmut> Saizan: is there any other way?
14:23:52 <helmut> Saizan: I don't want to modify the other compilers unless absolutely necessary.
14:24:22 <Saizan> helmut: don't lift adresses?
14:25:32 <titusg> ?pl (\x ys -> ys ++ map (x:) ys)
14:25:33 <lambdabot> ap (++) . map . (:)
14:25:35 <Saizan> helmut: if the compilers don't handle addresses why do you want to  insert them in the AST?
14:26:53 <helmut> Saizan: hmm. addresses look implementation dependant and don't belong to the parser.
14:27:09 <helmut> Saizan: that's mixing interfaces
14:28:01 <Saizan> helmut: mmh but where does Values come from?
14:28:23 <helmut> from the evaluator
14:29:41 <Saizan> can you somehow encode them as functions?
14:30:02 <helmut> what signature?
14:32:16 <Saizan> good question, do you have any direct memory access primitive in the language?
14:33:09 <Syzygy-> Saizan: In Haskell?
14:33:21 <Syzygy-> Saizan: I think only through the FFI things...
14:33:44 <helmut> I can create memory (ref foo -> Ref Expr), look into it (!foo -> Deref Expr) and write (foo := bar -> Assign Expr Expr).
14:33:50 <Saizan> Syzygy-: err, i don't think helmut is writing an haskell compiler
14:34:37 <Syzygy-> Saizan: Ah, ok. I wasn't clear on what language you were talking about...
14:35:13 <helmut> Note that the only expression that evaluates to memory is Ref, the others only use it.
14:37:48 <Saizan> i don't know.. even in TH is hard to embed raw data, you have to go through the language literals
14:37:49 <helmut> Saizan: putting addresses and closures in Parser.lg will be getting wors when implementing continuations.
14:38:31 <helmut> Saizan: the stack frames and therefore every datastructure used in the evaluator will have to go into the parser.
14:40:38 <Saizan> that's why i think that lifting addresses into the AST is a bad idea
14:44:04 <helmut> Saizan: furthermore frown doesn't like Expr a
14:44:16 <helmut> Saizan: (it produces a syntax error)
14:49:59 <helmut> Saizan: so what do you suggest apart from lifting into the ast?
14:50:16 <helmut> Saizan: should lift return somethintg like Expr'?
14:58:04 * helmut 's getting out of ideas. :-(
14:58:18 <helmut> I tried type Expr' = Either Expr Value, which had to fail
14:58:51 <oerjan> helmut: does it help if you try (Expr a), in parentheses?
14:59:03 <helmut> oerjan: with frown?
14:59:12 <oerjan> yes
14:59:16 * helmut tries
14:59:36 <helmut> no
15:00:23 <oerjan> is it frown itself or the resulting program that gives a syntax error?
15:00:29 <helmut> frown
15:00:37 <oerjan> oh
15:01:29 <helmut> I could as a last resort duplcate Expr to Expr' with an additional Literate
15:01:31 <helmut> Literal
15:17:28 <helmut> is there a hacky way to extend a data type?
15:19:12 <shapr> Wrap it in a record?
15:20:08 <helmut> does that change the constructors?
15:22:24 <shapr> helmut: You could always try some of the Oleg tricks.
15:24:59 <helmut> "oleg tricks" doesn't seem to be woll known by google. :-(
15:25:17 <Saizan> ?where oleg
15:25:17 <lambdabot> http://okmij.org/ftp/
15:28:08 <dustin```> Has anyone looked at Beck cohomology for the various (co)-monads that arise in Haskell?
15:29:02 <sorear> Interesting ... I wonder if it has anything to do with the cohomology structure that (almost) exists on types?
15:29:49 <sorear> @users
15:29:49 <lambdabot> Maximum users seen in #haskell: 338, currently: 311 (92.0%), active: 11 (3.5%)
15:30:15 <dustin```> I have no idea.  Right now I'm looking at Beck cohomology exclusively in algebraic and topological categories
15:30:37 <dustin```> What's this about a cohomology structure that almost exists on types?
15:32:36 <sorear> An idea I had a couple months ago.  General terms (values, types, kinds) support an operator of degree 2 and a semiring structure that is at least somewhat related.
15:33:07 <dustin```> What's the degree two operator?
15:33:12 <sorear> I have nowhere near the level of mathematical skills needed to make it work, but it sure seems like it would be cool
15:33:18 <dustin```> hmmm
15:33:41 <sorear> The operator is type-of.
15:33:53 <sorear> The type of a value is a concrete type - with kind *
15:34:10 <sorear> the kind of any type is a concrete kind - with sort []
15:34:52 <sorear> In Haskell, it stops there.  But in the CoC the hierarchy continuous forever, always with the degree 2 property.
15:35:07 <sorear> The universe number seems analogous to a dimension.
15:35:10 <wchogg> CoC?
15:35:21 <sorear> Calculus of Constructions
15:35:25 * SamB thinks it was an awfully good idea to include a copy of the source code to MACRO1 in the internal operations manual
15:35:58 <sorear> (and I'm actually talking about the stratified variant here, not the vanilla *-has-no-type-at-all form)
15:36:06 * helmut gives up for today.
15:36:15 <helmut> thanks for your suggestions.
15:36:34 <sorear> dustin```: The semiring on types is formed by (,) and Either
15:36:41 <sorear> (,) commutes with type-of
15:36:56 <sorear> 1 :: Int   'a' :: Char    (1,'a') :: (Int,Char)
15:37:02 <wchogg> Right...so using , as a product and Either as a coproduct?
15:37:10 <sorear> Yes.
15:37:45 <sorear> However I'd say multiplication and addition because my abstract algebra is stronger than my category theory :)
15:38:13 <dustin```> okay, now what happens when we take the grothendieck completion to a ring?
15:38:46 <sorear> dustin```: sorear gets lost :)
15:39:02 <dustin```> sorear, the question might not be all that meaningful anyway
15:39:29 <dustin```> The grothendieck construction merely adds formal additive inverses to a semiring to make it a ring.
15:40:07 <dustin```> In classical constructions, you do it to the semiring of isomorphism classes of vector bundles over a space, with direct sum as addition and tensor as multiplication.
15:40:35 <dustin```> And that's where K-theory starts
15:40:54 <dustin```> But I have no idea what any of this means in the land of types
15:41:12 <sorear> dustin```: Oh, is the grothendieck completion same as the pair construction by which the integers are constructed from Peano naturals?
15:42:16 <sorear> data GD a = GD a a    instance ... => Eq (GD a) where GD a b == GD c d = a + d == c + b
15:42:20 <sorear> ?
15:43:48 <dustin```> Yeah that should work
15:43:56 <fnord123> is there a sweet snippet to convert a list of lists to a list of tuples? I want to say fold w/ unzip but i dont see it
15:44:27 <sorear> fnord123: that's not possible in general, what if the lists have different lengths?
15:44:44 <sorear> a list of tuples must be rectangular, a list of lists need not be
15:44:44 <fnord123> they are HDBC table records
15:45:06 <fnord123> hm though nullable fields would confound the rectangularity. :(
15:45:11 <sorear> I'd hold my nose and say [ (a,b,c,d,e) | [a,b,c,d,e] <- listoflists ]
15:45:29 <sorear> note that that will discard sublists of different lengths
15:45:39 <emu> sorear: then your code would have a french-sounding accent
15:45:51 <fnord123> haw haw haw givenchy
15:45:56 <sorear> emu: huh?
15:46:50 <Excedrin> I thought there was something about list-to-tuples on the mailing list a while ago
15:47:05 <Serge> ?babel el es house
15:47:06 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
15:47:19 <Excedrin> "something" meaning, "Oleg type system hackage"
15:47:50 <sorear> Excedrin: LONG time ago.  You're describing inductive tuples, AKA hlist.
15:47:53 <Serge> ?babel es fr cat
15:47:54 <lambdabot>   cat
15:48:06 <sorear> ?babel en fr cat
15:48:07 <lambdabot>   chat
15:48:10 <Serge> ?babel el fr cat
15:48:10 <sorear> Serge: ?
15:48:11 <lambdabot>   cat
15:48:19 <Serge> I wasn't testing that :>
15:48:20 <sorear> ENglish
15:48:49 <Serge> Read up
15:48:54 <Serge> ?babel el es house
15:48:55 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
15:49:03 <Serge> Since babel doesn't support el -> es
15:49:11 <dustin```> sorear, the other construction that I think of is to take the free abelian group on your original semiring, and then just "impose" the original multiplication and addition as relations
15:49:20 <Serge> Only certain languages to other certain languages, but the bot doesn't validate that
15:51:37 <sorear> Serge: now that's just silly; I'd convert between any two languages via English.  it would sometimes result in massive blowups (word XYZ in language FOO corresponds to ten english words, each of which corresponds to ten FOO words, so ?babel FOO FOO would expand XYZ into a hundred words) but it would always work...
15:52:15 <Serge> What I'm saying is, the bot should check if the language conversion is valid for babel
15:53:03 <chessguy> it would probably be rare for any word to translate to more than 2 or 3 words
15:53:22 <Excedrin> sorear: I guess I was thinking of the mapTuple thread actually (which isn't really related)
15:53:22 <Serge> And yeah, chessguy has a point.
15:53:38 <Serge> Either way, it's returning a nasty error as it stands :>
15:55:19 <chessguy> it should probably try a direct translation first, and resort to translating through an secondary language only if necessary
15:55:34 <MyCatVerbs> sorear: what if you broke it down to an abstract fact graph, then converted from that?
15:56:08 <sorear> MyCatVerbs: Too much work.
15:57:07 <MyCatVerbs> sorear: it'd let you translate English->English to optimize away crap writing style, though. ;)
15:57:35 <chessguy> @babel en en fruit
15:57:36 <lambdabot> Plugin `babel' failed with: IRCRaised Prelude.head: empty list
15:57:54 <MyCatVerbs> sorear: and make customized versions of certain languages, e.g. Hemingway English, Shakespearean English... :)
15:58:25 <Serge> And if you can find an example where a translation converts one word into 10, I'd be impressed :P
15:58:35 <MyCatVerbs> I can't think of any possible business product more awesome than a piece of software to put your bosses' useless fucking memos into iambic pentameter. That would rule.
15:59:06 <MyCatVerbs> (Your bobbes' useful memos could be put into, say, sonnets instead.)
15:59:16 <MyCatVerbs> s/bobbes'/bosses'/
15:59:26 <monochrom> Who is your bobbe? :)
15:59:42 <chessguy> searching for bobbe fischer :)
16:01:06 <sorear> @remember MyCatVerbs I can't think of any possible business product more awesome than a piece of software to put your bosses' useless fucking memos into iambic pentameter. That would rule.
16:01:07 <lambdabot> Done.
16:02:19 <sorear> @flush
16:02:58 <chessguy> @help flush
16:02:59 <lambdabot> flush. flush state to disk
16:03:02 <sorear> @tell dons lambdabot2 *does* use a different state dir, right?
16:03:02 <lambdabot> Consider it noted.
16:03:29 <mauke> MyCatVerbs: http://search.cpan.org/~dconway/Coy-0.05/lib/Coy.pm
16:03:30 <lambdabot> Title: The CPAN Search Site - search.cpan.org
16:04:07 <MyCatVerbs> ...help.
16:04:28 <MyCatVerbs> Every time I get quoted in here, it's outright embarrassing. Random profanity and shit. :(
16:04:33 <toko123> greetings
16:04:44 <sorear> Hello, toko123.
16:05:33 <toko123> on openbsd packages i tried to add ghc I get an error mesage no package base?
16:05:36 <sorear> Do not hesistate to ask questions, we don't bite.
16:06:02 <toko123> hugs works fine interactively
16:06:13 <toko123> I'd like to compile though
16:06:14 <sorear> toko123: Does oBSD use binary packages?
16:06:19 <Excedrin> MyCatVerbs: that's a good quote though
16:06:23 <MyCatVerbs> sorear: yes it does.
16:06:24 <toko123> yes
16:06:25 <MyCatVerbs> Excedrin: than you.
16:06:50 <sorear> toko123: What component gives you that error message?
16:07:07 <toko123> ghci from the command line
16:07:07 <MyCatVerbs> toko123: what version of OpenBSD are you using? I remember the prebuild ghc on OBSD 4.0 was partially broken, the interactive mode didn't work.
16:07:11 <MyCatVerbs> toko123: ah.
16:07:16 <toko123> 4.1 i386
16:07:17 <MyCatVerbs> toko123: I had the same problem myself.
16:07:41 <sorear> toko123: Hmm - maybe there is a libghc6-base-* package or similar you need to install?
16:07:41 <MyCatVerbs> toko123: do you have a lot of free machine time? ghc should still be working. I had the same problem myself.
16:08:15 <toko123> let me check libghc
16:08:17 <toko123> thansk
16:08:28 <MyCatVerbs> toko123: it turned out that even though ghci was broken, plain ghc still worked. Downloading and compiling and installing the ghc6.6 sources off haskell.org fixed it up perfectly.
16:08:44 <MyCatVerbs> toko123: took about six hours on my (fairly slow) machine.
16:08:51 <toko123> thanks
16:08:58 <dibblego> ?check \xs n -> n > 0 && n < length xs ==> length (fst $ splitAt n (xs :: [Int])) == n
16:09:00 <lambdabot>  Arguments exhausted after 243 tests.
16:09:13 <sorear> GHC 6.6.1 compiles *much* faster (I can explain why if you care)
16:09:34 <MyCatVerbs> sorear: !!!
16:09:44 * SamB notices that this program that he's been transcribing with a small amount of help from an OCR takes up multiple tapes
16:09:56 <MyCatVerbs> sorear: please do. And I'll have to get around to doing that tomorrow. :)
16:10:53 <sorear> MyCatVerbs: GHC 6.6.0 defaults to -fvia-C when -O is specified, because the GCC produces better code than the GHC internal codegen.
16:11:31 <sorear> MyCatVerbs: The codegen has gotten better, and in 6.6.1 they desided -fvia-C was for special occasions only.
16:11:58 <sorear> MyCatVerbs: Running GCC multiplies compilation time by 2-3x
16:11:59 <MyCatVerbs> sorear: ? Oh, cool.
16:12:36 <sorear> MyCatVerbs: Now, GHC is bootstrapped, and the stage2 + libraries (many 100's of kloc) are compiled with - you guessed it - ghc -O
16:12:46 <MyCatVerbs> sorear: wait, does that only affect building 6.6.1 with 6.6.1 or also building 6.6.1 using 6.6.0?
16:13:10 <sorear> MyCatVerbs: Both, because 80% ghc 6.6.1 is compiled using 6.6.1
16:13:18 <MyCatVerbs> sorear: ohhhh.
16:13:21 <sorear> Only the stage1 compiler is built using the host ghc
16:13:27 <MyCatVerbs> sorear: it only bootstraps using the host ghc?
16:13:32 <sorear> yeah
16:13:33 <MyCatVerbs> Kewlness. Thanks.
16:14:16 <sorear> On my system (P4 2.004GHZ) building 6.6.1 with all libraries took 84 minutes.
16:15:28 <sorear> :t fromDyn
16:15:30 <lambdabot> forall a. (Typeable a) => Dynamic -> a -> a
16:16:06 <MyCatVerbs> sorear: RAM?
16:16:15 <sorear> MyCatVerbs: 384MB
16:16:19 <MyCatVerbs> sorear: or, actually, what makes more difference?
16:17:06 * MyCatVerbs has something of a paucity of both on hand. But not an even paucity. ^_^
16:17:16 <sorear> MyCatVerbs: not sure.  I suspect L2 cache speed is very important since GHC spends much of its time creating and collecting garbage in the nursery (256kb of contiguous memory, by default)
16:17:24 <MyCatVerbs> sorear: !
16:17:51 <MyCatVerbs> sorear: heh. And I have a CPU with -no- L2 cache. S'a Duron. :)
16:19:01 <sorear> MyCatVerbs: there's a project to integrate GHC with the P4 performance counters, which means that somewhere on the internet you'll find an accurate breakdown of GHC's time usage by cost source (mispredicted branches, cache misses, etc.)
16:19:46 <sorear> probably Igloo knows
16:20:44 <MyCatVerbs> sorear: oh, man. That could lead to some *serious* tuning, at least on Intel hardware. Are those counters on Core chips, too?
16:20:56 <MyCatVerbs> Or are they specific to the P4 line?
16:21:33 <SamB> hmm, question: why does linux only report one figure for "cache size"?
16:21:55 <MyCatVerbs> SamB: good question. It hates you?
16:22:54 <SamB> it seems like it would be a good idea to make the nursery smaller than L2 -- since obviously things that aren't in the nursery are accessed too
16:24:57 * SamB wishes firefox supported profiling by tab
16:26:03 <sorear> SamB: My nursery is half the size of L2.
16:26:19 <MyCatVerbs> SamB: like, vary it to always be (sizeof(L2)/2)?
16:26:25 <SamB> MyCatVerbs: or less
16:26:41 <SamB> /proc/cpuinfo says:i
16:26:48 <SamB> cache size      : 256 KB
16:28:05 <MyCatVerbs> SamB: well, uh, for me, it's more. Since I don't have one, to the best of my knowledge, on *any* of the machines I own.
16:28:33 <dpiponi> Saizan: You there?
16:28:34 <SamB> have one what?
16:28:55 <sorear> MyCatVerbs: So /proc/cpuinfo says 0?
16:29:23 <sorear> huh.  irssi completes file names
16:30:14 <dpiponi> Saizan: I was going to say that my Monad is a perfectly decent Monad. It's just that Haskell is sometimes a poor approximation to mathematics...
16:30:48 <ddarius> dpiponi: Haskell is usually a poor approximation to mathematics.
16:32:07 <dpiponi> As programming languages go, Haskell is a pretty good approximation to mathematics.
16:32:26 <SamB> it's relatively good for an application programming language ;-)
16:32:27 <MyCatVerbs> sorear: not sure. Not using penguinism at the mo.
16:32:42 <MyCatVerbs> sorear: I think it identifies as something like 32k, from the L1 cache.
16:33:15 <sorear> 32k is awful big for a L1
16:33:34 <dpiponi> It's a bitt annoying that Haskell is supposed to be referentially transparent but you can aesily write functions so that x==y but f x/= f y
16:34:02 <sorear> You need a custom Eq instance to do that :)
16:34:10 <dpiponi> Yeah, but it
16:34:15 <dpiponi> 's still easy.
16:34:20 <SamB> sorear: ... or you could use Float or Double
16:34:51 <mauke> > let f k = 0 / k; x = 0; y = 0 in  (x == y, f x == f y)
16:34:52 <lambdabot>  (True,False)
16:35:22 <MyCatVerbs> SamB: 16k apiece, D and I?
16:35:44 <MyCatVerbs> sorear: er, it might be 4k apiece, more likely. I can' remember.
16:35:59 <sorear> I have 8K data and 12K code
16:36:34 <MyCatVerbs> sorear: oh. Methought most chips had both cache sizes equal?
16:36:55 <SamB> code is usually cached in an internal format anyway
16:37:31 <SamB> so code cache sizes won't necessarily tell you much
16:42:16 <desp> @pl foo a b c _ = bar a (b * c)
16:42:16 <lambdabot> foo = ((const .) .) . (. (*)) . (.) . bar
16:42:20 <desp> ouch
16:42:50 <desp> any sentient beings care to comment?
16:43:32 <mauke> @unpl foo a = (bar a .) . (*)
16:43:32 <lambdabot> foo a e h = bar a (e * h)
16:43:45 <SamB> desp: it would be eisier to comment if you used real names
16:44:20 <desp> SamB: not really, because both foo and bar are my own functions
16:45:03 <desp> mauke: hm. do you think that's easier to read than the original one?
16:45:27 <SamB> desp: I'd just use the original, I think
16:46:22 <ddarius> desp: Use the original
16:46:25 <desp> right
16:47:22 <ddarius> If you need a (.) section to "make it point free" then it's not worth it.  It often isn't worth it even when you don't.
16:50:09 <SamB> ddarius: I think *one* . section can be worth it
16:50:19 <SamB> maybe even two
16:50:31 <SamB> but, not nearly as nested
16:50:35 <ddarius> SamB: Explain to me what you gain.
16:51:39 <SamB> it can sometimes allow you to use HOFs that you otherwise couldn't use
16:52:02 <ddarius> What?
16:52:40 <SamB> @pl \x y -> f (g x y)
16:52:40 <lambdabot> (f .) . g
16:53:22 <ddarius> The question is: Is the latter better than the former and why?
16:53:26 <SamB> hmm.
16:53:37 <SamB> not in this case
16:54:15 <ddarius> @unpl ((f .) .) . g
16:54:15 <lambdabot> (\ e j m -> f (g e j m))
16:56:17 <SamB> well, anyway, I don't think it's a good rule to say that ". sections are never worth it"
16:56:34 <SamB> ... unless you can come up with a way to prove that
16:56:45 <mauke> is it bad to like flip id?
16:57:06 <SamB> @type flip id
16:57:09 <lambdabot> forall b c. b -> (b -> c) -> c
16:57:09 <ddarius> They can be, though not really for point-free style, more for the fact that (f .) and (. g) are the action of the Hom, (->), functor.
16:57:21 <SamB> mauke: try >>>
16:57:27 <SamB> no, wait.
16:57:31 * SamB silly
16:57:39 <SamB> mauke: what do you use it for?
16:58:08 <mauke> \fs x -> map (flip id x) fs  -- not a good example
16:58:22 <SamB> indeed not.
16:58:28 <SamB> @pl \fs x -> map (flip id x) fs
16:58:28 <lambdabot> flip (map . flip id)
16:58:34 <SamB> heh
16:58:36 <ddarius> Forget that, map ($ x) fs
16:58:56 <SamB> yeah, I was thinking it must be something like that...
16:59:33 <mauke> besides, that's just sequence
16:59:49 <SamB> oh, how handy
17:00:04 <mauke>  piece = liftM2 (flip id) atom (optionalS' id bounds)
17:00:59 <ddarius> mauke: Why not use that extra character and write flip ($)?
17:01:14 <mauke> because it's harder to type/read
17:02:00 <mauke> > (+) `id` 1 `id` 2
17:02:02 <lambdabot>  3
17:03:42 <Cale> ($) is easier to read than id when you mean function application
17:05:12 <Saizan> `id` has the right associativity though :)
17:05:23 <Saizan> (not the right precedence..)
17:07:15 <Saizan> Functor was a superclass of Monad, would liftM2 f m1 m2 = m1 >>= \x -> fmap (f x) m2 be the same as the current definition?
17:07:18 <mauke> that can be fixed
17:07:23 <Saizan> +if
17:07:43 <mauke> looks like it
17:08:48 <sorear> Saizan: Yes.  But notice that you're still using >>=
17:09:02 <sorear> Saizan: With just fmap, it's impossible to write liftM2
17:09:14 <sorear> Saizan: liftM2 is equivalent to Applicative
17:09:17 <edwardk> @type \f m1 m2 -> m1 >>= \x -> fmap (f x) m2
17:09:20 <lambdabot> forall (m :: * -> *) a a1 b. (Functor m, Monad m) => (a -> a1 -> b) -> m a -> m a1 -> m b
17:09:29 <edwardk> looks good to me
17:12:28 <Saizan> it's just that it can be more efficient that way, with two >>= you are wasting a join
17:13:01 <dibblego> ?type join
17:13:03 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
17:13:29 <dibblego> ?hoogle (Monad m) => m (m (m a)) -> m a
17:13:30 <lambdabot> Prelude.id :: a -> a
17:13:30 <lambdabot> Control.Monad.Error.throwError :: MonadError e m => e -> m a
17:13:30 <lambdabot> Prelude.asTypeOf :: a -> a -> a
17:13:35 <Saizan> well not literally the haskell join
17:13:53 <dibblego> oh, I wasn't listening anyway - just reminding myself of the type of join :)
17:14:26 <edwardk> @type zipWith
17:14:28 <lambdabot> forall a b c. (a -> b -> c) -> [a] -> [b] -> [c]
17:14:35 <edwardk> ah, never noticed that connection before
17:15:20 <edwardk> @type liftM3
17:15:22 <lambdabot> forall a1 a2 a3 r (m :: * -> *). (Monad m) => (a1 -> a2 -> a3 -> r) -> m a1 -> m a2 -> m a3 -> m r
17:15:23 <edwardk> @type zipWith3
17:15:25 <lambdabot> forall a b c d. (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d]
17:16:10 <edwardk> > zipWith (+) [1..3] [4..6]
17:16:12 <lambdabot>  [5,7,9]
17:16:19 <edwardk> > liftM2 (+) [1..3] [4..6]
17:16:21 <lambdabot>  [5,6,7,6,7,8,7,8,9]
17:16:24 <edwardk> ah oh well
17:16:26 <edwardk> just the types =)
17:16:39 <dibblego> @let zipWith3_ :: (a -> b -> c -> d) -> [a] -> [b] -> [c] -> [d];  zipWith3_ = liftM3
17:16:43 <lambdabot> Defined.
17:17:06 <mauke> > return (+) `ap` [1..3] `ap` [4..6]
17:17:07 <lambdabot>  [5,6,7,6,7,8,7,8,9]
17:17:44 <edwardk> it looked good on paper for a second ;)
17:18:22 <desp> @hoogle (a -> IO ()) -> Map a -> IO ()
17:18:23 <lambdabot> No matches, try a more general search
17:18:24 <Saizan> ?hoogle ZipList
17:18:24 <lambdabot> No matches found
17:18:34 <Saizan> ?docs Control.Applicative
17:18:34 <lambdabot> Control.Applicative not available
17:18:39 <Saizan> ?docs
17:18:39 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
17:18:44 <mauke> desp: huh?
17:18:49 <desp> @hoogle Monad m => (a -> m b) -> t a -> m b
17:18:50 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
17:18:50 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
17:18:50 <lambdabot> Data.Generics.Schemes.everywhere :: (a -> a) -> a -> a
17:19:00 <desp> hm, not quite.
17:19:25 <mauke> wait, Map a is not even a type
17:19:25 <desp> mauke: looking for one of those Traversable/Foldable functions...
17:19:48 <edwardk> http://www.haskell.org/ghc/docs/latest/html/libraries/base/Data-Foldable.html
17:19:50 <lambdabot> http://tinyurl.com/2xwe3t
17:20:22 <desp> @type traverse_
17:20:25 <lambdabot> Not in scope: `traverse_'
17:20:29 <Saizan> > liftA2 (ZipList [1..3]) (ZipList [4..6]) -- we have that only as an Applicative
17:20:30 <lambdabot>  Couldn't match expected type `a -> b -> c'
17:20:37 <Saizan> > liftA2 (+) (ZipList [1..3]) (ZipList [4..6]) -- we have that only as an Applicative
17:20:38 <lambdabot>   add an instance declaration for (Show (ZipList a))
17:20:52 <Saizan> > getZipList $ liftA2 (+) (ZipList [1..3]) (ZipList [4..6])
17:20:54 <lambdabot>  [5,7,9]
17:21:11 <mauke> :t mapM
17:21:13 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m [b]
17:21:18 <edwardk> :t getZipList
17:21:22 <lambdabot> forall a. ZipList a -> [a]
17:21:34 <edwardk> @hoogle ZipList
17:21:35 <lambdabot> No matches found
17:21:50 <Saizan> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Applicative.html#t%3AZipList
17:21:52 <lambdabot> http://tinyurl.com/yrwujr
17:22:05 <edwardk> nice
17:22:32 <mauke> desp: Data.Foldable.mapM_?
17:22:43 <desp> mauke: nah, Data.Foldable.traverse_
17:23:12 <mauke> same thing
17:23:27 <desp> mapM seems to take a list, so, no
17:23:41 <mauke> :t Data.Foldable.mapM_
17:23:44 <lambdabot> forall a (m :: * -> *) b (t :: * -> *). (Monad m, Data.Foldable.Foldable t) => (a -> m b) -> t a -> m ()
17:24:06 <desp> oh. hm.
17:24:18 <edwardk> Data.Foldable has a bunch of typeclasses that the prelude _should_ have =)
17:24:19 <desp> you're right, sorry.
17:24:54 <edwardk> though i also kind of think that functor and applicative should be superclasses of monad
17:25:23 <mauke> no
17:25:37 <edwardk> then Alternative and MonadPlus could merge
17:25:38 <mauke> maybe subinstances
17:26:22 <edwardk> class Functor f; class Functor f => Applicative f; class Applicative f => Monad f; class Applicative f => Alternative f
17:26:48 <edwardk> the problem is haskell's ucky requirement that you define them all as separate instances
17:27:04 <mauke> instance (Monad m) => Applicative m where
17:27:59 <edwardk> mauke: well, my current obsession is with trying to be able to define them all in one place with polymorphic records as dictionaries. then it becomes a lot cleaner ;) doesn't work for haskell though
17:34:27 <desp> hm
17:34:43 <desp> what's the difference between  data Foo a = Foo a a  and  data Bar a = Bar (a, a) ?
17:35:03 <desp> apart from the former being easier to type
17:35:44 <ddarius> A bottom and the type.
17:35:55 <desp> pardon?
17:36:03 <MyCatVerbs> desp: you can use (\Bar x->fst x) on the second? :)
17:36:18 <MyCatVerbs> desp: they'll behave a little differently under adverse circumstances, for example.
17:36:21 <ddarius> Bar has an extra bottom.
17:37:21 <MyCatVerbs> desp: also, AFAIK a tuple can never contain itself (you can't have, to the best of my knowledge, let x = Bar (3,x), whereas let y = Foo 3 y, is totally doable.
17:37:48 <Cale> MyCatVerbs: what type would y have?
17:38:08 <desp> ddarius: is there any way you could be a little less cryptic? :)
17:38:10 <ddarius> Cale: Indeed, and what type would 3 have...
17:38:23 <ddarius> Bar undefined has no corresponding value with Foo.
17:38:23 <MyCatVerbs> Cale: oh, my bad. Minor detail, honest. ;)
17:39:12 <Cale> Well, 3 would have the same type as y of course :)
17:39:26 <MyCatVerbs> let x = Bar (some other Bar,x) is impossible because it involves constructing an infinite type.
17:39:30 <Cale> Except that y would have an infinite type, which isn't allowed
17:39:50 <MyCatVerbs> Cale: hrmn? Circular references, totally kosher.
17:39:53 <Cale> no
17:40:08 <Cale> Its type would be the solution to  t = Foo t
17:40:17 <mauke> > let y = [y] in y
17:40:18 <Cale> which is infinite
17:40:18 <lambdabot>      Occurs check: cannot construct the infinite type: t = [t]
17:40:18 <lambdabot>       Expected...
17:41:44 <Cale> The real difference between them is as ddarius pointed out, that Bar has an extra partially-defined value.
17:41:51 <jre2> does anyone recommend any gui tookit over another for combining with hopengl?
17:42:12 <MyCatVerbs> jre2: yes. Raw xlib is more awesome than any of the alternatives.
17:42:44 <jre2> MyCatVerbs: hah
17:42:51 <MyCatVerbs> nowai
17:42:57 <MyCatVerbs> Raw X11R6
17:43:33 <kfish> jre2, have you tried gtk2hs? it's quite nice (haven't used it together with hopengl yet, but i'd like to :-)
17:43:47 <MyCatVerbs> (Since they didn't actually break backward compatibility with Xorg7 at all, which is when they are *supposed* to bump the revision number, in theory)
17:44:28 <MyCatVerbs> Pity you can't just chuck datatype definitions straight into ghci.
17:44:37 <jre2> I was looking at wxHaskell and gtk2hs mainly, but I have no experience with either
17:44:53 <MyCatVerbs> jre2: wx is evil, come to the gtk side?
17:45:06 <kfish> gtk2hs with glade is really easy to work with
17:45:42 <jre2> MyCatVerbs: any reason for that?
17:46:23 <MyCatVerbs> jre2: wx is reputed to be a screaming hell of endless dependancies to build, AFAIK.
17:46:49 <MyCatVerbs> jre2: sometimes with mutually incompatible versions getting involved in the process, *ouch*.
17:47:54 <jre2> I don't know...that sounds pretty awesome
17:49:16 <Cale> I don't remember wxHaskell being all that difficult to set up, but I do prefer Gtk2Hs.
17:49:28 <shachaf> What is the recommended library to write a Haskell GUI in general, actually?
17:49:32 <shachaf> Is there one?
17:49:39 <Cale> Those two, mainly.
17:51:07 <Cale> There's a new wxHaskell team, and they're getting things back together. If you're going to try it, don't get the packaged version, get the darcs repo, since it's now Cabalised.
17:51:38 <shachaf> Cale: They are both listed as "medium-level" on <http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries>.
17:51:38 <lambdabot> http://haskell.org/haskellwiki/Applications_and_libraries/GUI_libraries>
17:51:52 <Cale> shachaf: yeah, and they are.
17:52:09 <ddarius> shachaf: There are not yet any practical "high-level" GUI libraries.
17:52:10 <Cale> shachaf: There's no really practical high-level libraries.
17:52:13 <dons> http://programming.reddit.com/info/21j8z/details
17:52:13 <lambdabot> dons: You have 4 new messages. '/msg lambdabot @messages' to read them.
17:52:14 <lambdabot> Title: Writing a simple x86 disassembler in Haskell (reddit.com)
17:52:16 <emu> @quote stero
17:52:16 <lambdabot> No quotes match. stty: unknown mode: doofus
17:52:17 <emu> @quote stereo
17:52:17 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
17:52:27 <emu> @quote doofus
17:52:27 <lambdabot> No quotes match. I can't hear you -- I'm using the scrambler.
17:52:31 <Cale> dons: already upmodded it :)
17:53:23 <dons> hmm. i wonder if we could implement DSL front end and back ends pretty cheaply this way
17:54:07 <shachaf> All the "high-level" ones seem to be arrow-based.
17:54:43 <dons> yeah, it would be the low end ones
17:54:50 <dons> hmm. compiled regexes, perhaps?
17:55:00 <dons> or image transform stuff
17:55:07 <dons> FFTW.
18:00:38 * shachaf recalls having some problem with installing wxHaskell and unicode.
18:11:49 <sorear> back.
18:14:59 <sorear> Ooh, SYBWC!
18:15:14 <sorear> Igloo++ for popularizing cool technology
18:46:07 <Saizan> SYBWC?
18:46:42 <dons> scrap your boilerplate with class
18:46:54 <mauke> suck your big... oh
18:46:57 <SamB> dons: that sounds so passe
18:47:04 <SamB> scrap your scary types!
18:48:03 <desp> is there some sort of macro similar to C's __FUNCTION__?
18:48:21 <mauke> C has no __FUNCTION__, and it isn't a macro
18:48:50 <dons> what does __FUNCTION__ do?
18:48:51 <desp> eh, yes.  I meant FILE/LINE.
18:49:04 <dons> yes, there are FILE /LINE pragmas
18:49:10 <dons> check for pragmas in the ghc user's guide
18:49:16 <mauke> __func__ is a special token in C99. it behaves like a static const char [] containing the name of the current function
18:49:23 <SamB> dons: no, not pragmas
18:49:24 <sorear> dons: Every function in C logically starts with static const char __func__[] = "name of function";
18:49:46 <desp> okay, so is there a Haskell equivalent for __func__?
18:49:49 <xpika> :re
18:50:38 <dons> desp: a token that expands to the name of the current top level function?
18:50:43 <xpika> @pl (\[a,b,c,d]->(a,b,c,d))
18:50:43 <lambdabot> (line 1, column 3):
18:50:43 <lambdabot> unexpected "["
18:50:43 <lambdabot> expecting pattern
18:50:48 <desp> dons: yes
18:50:52 <dons> sort of. you can use 'assert' to roughly get that.
18:51:10 <dons> this is for debugging messages, i presume?
18:51:19 <desp> yep
18:51:23 <TSC> @pl (\ [a,b,c,d] -> (a,b,c,d))
18:51:23 <lambdabot> (line 1, column 4):
18:51:23 <lambdabot> unexpected "["
18:51:23 <lambdabot> expecting pattern
18:51:32 <xpika> @pl (\([a,b,c,d])->(a,b,c,d))
18:51:32 <lambdabot> (line 1, column 4):
18:51:32 <lambdabot> unexpected "["
18:51:32 <lambdabot> expecting pattern
18:51:35 <mauke> pl can't do patterns
18:51:38 <TSC> No pattern for you
18:51:39 <dons> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/loch-0.2
18:51:40 <dons> (for example)
18:51:42 <lambdabot> http://tinyurl.com/yqfuld
18:56:41 <Saizan> i think we should use shorter urls for hackage, like http://hackage.haskell.org/p/loch
18:57:30 <dons> i agree. can you suggest that to nominolo, he's doing hackage+cabal for his soc project
18:58:10 <Saizan> ?seen nominolo
18:58:10 <lambdabot> I saw nominolo leaving #ghc, #haskell-soc and #haskell 3h 29m 49s ago, and .
19:07:22 <ed1t> dons, u know of a rough estimate of when the book ur working is coming out?
19:07:36 <dons> next year some time
19:07:50 <ed1t> damn...thx
19:07:55 <ed1t> ive been waiting for the book
19:07:58 <ed1t> it looks good
19:13:20 <xpika> dons:  i see the book isnt just haskell98
19:14:12 <dons> that would be boring.
19:14:24 <dons> and who uses haskell98 in the real world anyway?
19:14:54 <xpika> dons: its would just be great to read a book which is up to date :)
19:15:25 <Saizan> ?source Control.Monad
19:15:25 <lambdabot> http://darcs.haskell.org/packages/base/Control/Monad.hs
19:16:11 <Korollary> The post-98 stuff isn't hard to pick up by themselves, but the hard part is to figure out when to use the extensions. That's what a book's supposed to show.
19:16:39 <mauke> read . show $ book
19:18:40 <xpika> are any of these > haskell98 ? http://www.haskell.org/haskellwiki/Books
19:18:42 <lambdabot> Title: Books and tutorials - HaskellWiki
19:21:07 <cdsmith> Howdy everyone.
19:23:32 <sorear> howdy!
19:26:11 <xpika> q2
19:35:19 <cpfr> hey is the type checker turing complete
19:35:31 <dons> yep
19:36:02 <cpfr> this is strange
19:39:31 <dons> here's an witnes to the turing completeness, http://haskell.org/haskellwiki/Type_SK
19:39:32 <lambdabot> Title: Type SK - HaskellWiki
19:41:39 <cpfr> hmm
19:41:49 <cpfr> well there goes that plan
19:42:12 <Korollary> What plan?
19:42:23 <cpfr> i wanted to write some mission critical code in a sub-language that is guarenteed to halt
19:42:40 <Korollary> It's not turing complete if you don't enable certain extensions.
19:42:41 <cpfr> and i thought the type system in haskell was designed to have that property
19:42:51 <cdsmith53> cpfr: you could avoid -fallow-undecidable-instances
19:42:56 <cpfr> oh ok
19:43:12 <Korollary> Check out epigram if you want to guarantee halting
19:43:18 <cpfr> so as long as i dont have that it stays kosher
19:43:34 <cdsmith53> Yeah, it'd still be a pain to write a lot of type-level code, IMO
19:43:48 <cpfr> can i call epigram code from within haskell
19:44:06 <dons> yeah, its only some evil extensions that introduce non-terminating type checkers
19:44:19 <dons> cpfr, not sure. better check the apigram site.
19:44:39 <dons> maybe via the FFI.
19:45:20 <dons> you can always embed your sub language inside a GADT in Haskell
19:45:51 <dons> and give it whatever type system you want.  if its really mission critical, i imagine you know what ou're doing anyway?
19:45:54 <cpfr> would that give me the decidability im looking for, (not sure what GADTs disallow)
19:46:06 <sorear> cpfr: Be careful, though; just because it halts doesn't mean it will happen anytime soon
19:46:24 <cpfr> im unit test this thoroughly
19:46:34 <cpfr> *ill unit test this
19:47:14 <cpfr> well thanks for the help
19:47:21 <sorear> cpfr: System F (equivalently: Second order peano arithmetic), the standard example of a strongly-normalizing language, admits a family of programs which require time O(a(N)) to run
19:47:40 <sorear> cpfr: where a(x) is the Ackermann function
19:48:16 <sorear> a(4) = 65536, a(5) = so large it wouldn't fit if you had a byte of memory for every atom in the universe
19:48:27 <cdsmith53> dons, by the way, told you so.  I wrote about how I put Haskell code in my blog as you suggested; over 24 hours later, planet.haskell.org hasn't picked it up yet. :(
19:49:18 <dons> cdsmith53: but you're syndicated on p.h.o?
19:49:34 <cdsmith53> dons: yeah, but it does weird stuff if I post things too often.
19:49:38 <dons> weird. better talk to ibid.
19:49:50 <dons> rss is so broken.
19:49:57 <sorear> Or if you don't post often enough :)
19:50:23 * sorear is looking at you, Anti-Juliani K-somthing
19:50:26 <cdsmith53> Well, I just got done writing another post... but I'm not sure what to do now.
19:52:02 <cdsmith53> (Well, even if p.h.o were working for me, I'm not sure how polite it would be to have the 15-page long diatribe on static/dynamic type systems show up there and bump everyone else down...)
19:53:54 <cdsmith53> I've disconnected?
19:54:11 <sorear> cdsmith53: Yes.
19:54:12 <cdsmith53> hmm
19:54:17 <cdsmith53> brb
19:54:22 <sorear> cdsmith53: And reconnected, it seems.
19:54:33 <cdsmith53> ok
19:54:37 <sorear> cdsmith53: cdsmith was a ghost
19:54:37 <cdsmith53> ack!  Still 53
19:54:47 <sorear> cdsmith53: /nick cdsmith
19:54:59 <cdsmith> cool.  Thanks!
20:02:44 <aeyakovenko> is there a make clean, or rebuild option for ghc?  because if change the compiler flags ghc does not rebuild the dependencies
20:04:01 <cdsmith> aeyakovenko: I thought make clean worked.  I don't want to try now because I don't want to have to wait hours for ghc to build again. :)
20:04:33 <aeyakovenko> not building ghc, but rebuilding things that you build with ghc --make
20:05:06 <cdsmith> aeyakobenko: oh!
20:05:53 <cdsmith> I just have 'rm -f *.o *.hi Main' in a Makefile
20:06:11 <sjanssen> aeyakovenko: ghc -no-recomp IIRC
20:07:40 <aeyakovenko> ah ok, its called -fforce-recomp, thanks for the tip
20:07:59 <sjanssen> aeyakovenko: also, I suggest putting your flags into a OPTIONS_GHC pragma
20:12:21 <cdsmith> Is there a description of 6.7 *.hi format somewhere, or do I need to read GHC source code?
20:18:11 <dons> its not an external format.
20:18:36 <dons> the user's guide has a description of the textual version youget with --show-iface, iirc.
20:19:12 <cdsmith> dons: Okay, but I'm curious if I can somehow stuff information into hi files in a way that won't break GHC.
20:19:33 <sorear> cdsmith: You can try to parse it, but look at the hs-plugins and think again :)
20:19:52 <cdsmith> sorear: I actually did look at hs-plugins.  Is that dead code?
20:19:57 <sorear> cdsmith: Have you evaluated {-# CORE #-} annotations :)
20:20:03 <sorear> > 2 + 2 -- no way
20:20:07 <dons> into .hi files. hmm. no.
20:20:09 <sorear> s/:)/?/
20:20:11 <lambdabot>  4
20:20:24 <sorear> cdsmith: I just excercised hs-plugins :)
20:20:30 <dons> sorear--
20:20:32 <wanu> whats the name of that haskell plugin with builtin support for multiple cores
20:20:33 <dons> .hi files are just a bit hard
20:20:46 <dons> wanu, you mean, ghc's SMP runtime?
20:21:02 <wanu> that might be it
20:21:03 <cdsmith> sorear: I mean the hi parser in there.  The reason I ask is that hs-plugins seems to be working fine with 6.7, but I thought the hi file format changed.
20:21:15 <sorear> dons: hmm, what was that for?  hs-plugins was an innocent casualty of the non-existance of the ghc-api
20:22:29 <sorear> cdsmith: IIRC hsplugins darcs works iff ghc >=6.6, and hsplugins 0.9 works iff ghc <6.6
20:22:35 <sorear> no version will work on both
20:23:09 <jre2> dons: do you think hs-plugins is quick enough to be used for scripting in a game?
20:23:39 <dons> jre2: nope.
20:23:45 <sorear> jre2: depends on how you use it
20:23:47 <dons> well, its quick, but its not really scripting
20:23:54 <dons> i'd use ghc-api for this, as yi does.
20:24:02 <sorear> jre2: loading a script takes ~0.5 seconds, but running one is instant
20:24:05 <cdsmith> sorear:: okay, thanks
20:24:09 <dons> hs-plugins are more for long-runing, or throw-away, closed code fragments
20:24:19 <sorear> jre2: since it calls the compiler
20:24:24 <jre2> dons: ah
20:24:44 <dons> ideal for plugins, or evaluators, but not so good for scripting internals in an application
20:25:32 <jre2> alright, I'll look into ghc-api then
20:25:41 <desp> Haskell++
20:25:41 <sorear> jre2: Also, due to limitations of the GHC dynamic loader, hs-plugins leaks memory, which could be a problem if you expect to load scripts hundreds of thousands of times
20:26:00 <Excedrin> ghc-api doesn't leak?
20:26:28 <jre2> sorear: good point
20:26:29 <dons> not sure if the bytecode is collected (its possible, on :reload)
20:26:42 <dons> the native code isn't collected in ghci/ghc-api either
20:26:52 <sorear> Excedrin: I don't know, actually.  It definitely will if you select native compilation
20:27:25 <dons> seems to be fine for ghci-like purposes
20:27:30 <dons> so i would imagine it would be fine for games.
20:28:16 <jre2> basically I wanted to be able to edit the game logic and what not on the fly for quick development (and perfer not using an inferior language), so I just started looking at hs-plugins today
20:28:40 <Excedrin> jre2: what kind of game? have you coded anything already?
20:29:07 <dons> jre2: you could do this in ghc-api, or hs-plugins. if you're thinking of just having reloadable components
20:29:30 <jre2> Excedrin: not really, I'm still quite unfamiliar with haskell so I'm studying what's available
20:31:58 <Saizan> has anyone written a compiler :: Haskell -> Graph with a graphical evaluator?
20:33:07 <sorear> What kind of graph?
20:33:18 <sorear> gnuplot or fgl?
20:34:02 <Saizan> what's fgl?
20:34:38 <Saizan> i mean this as an aid to visualize lazy eval
20:35:59 <sorear> hmm...
20:37:29 <jre2> dons: ideally I should just need to reload something so long as it isn't storing state, which sounds feasible. maybe I should look at frag a bit before I put my foot in my mouth though
20:38:15 <dons> you can also flush state out and back, if needed. but i'd work out what yo uneed first.
20:39:02 <sorear> Or even keep it in memory.  Hs-plugins preserves the heap
20:40:46 <dons> http://equi-nox.blogspot.com/2007/06/search-in-haskell.html
20:40:47 <lambdabot> Title: equinox: Search in Haskell
20:40:57 <dons> do we know Sasha?
21:06:31 <desp> @pl foo e = e /= 0 && e /= -1
21:06:31 <lambdabot> (line 1, column 7):
21:06:31 <lambdabot> unexpected "="
21:06:31 <lambdabot> expecting variable, "(", operator or end of input
21:06:49 <desp> @pl foo e = e /= 0
21:06:49 <lambdabot> foo = (0 /=)
21:06:54 <desp> @pl &&
21:06:54 <lambdabot> (line 1, column 1):
21:06:54 <lambdabot> unexpected "&"
21:06:54 <lambdabot> expecting white space, natural, identifier, lambda abstraction or expression
21:07:01 <desp> hm
21:07:15 <sorear> desp: (`notElem` [0, -1])
21:07:15 <dons> @pl \e -> e /= 0 && e /= -1
21:07:16 <lambdabot> (line 1, column 22):
21:07:16 <lambdabot> unexpected "-"
21:07:16 <lambdabot> expecting space or simple term
21:07:25 <dons> @pl \e -> e /= 0 && e /= (-1)
21:07:25 <lambdabot> liftM2 (&&) (0 /=) (-1 /=)
21:07:27 <desp> @unpl (&&) . (||)
21:07:27 <lambdabot> (\ c -> (&&) ((||) c))
21:08:01 <desp> sorear: interesting
21:08:06 <desp> is that efficient?
21:08:16 <desp> not that it matters in this case...
21:08:31 <sorear> desp: No, because literal lists don't fuse in foldr/build.
21:08:50 <sorear> they *could*, but that triggers pathological behaviour with Happy output
21:08:53 <desp> dons: aha
21:09:35 <dons> enumerations fuse though.
21:09:43 <dons> literals don't make much sense though.
21:10:01 <sorear> concat [x,y,z]
21:10:20 <dons> unless you like ghc taking even longer to compile that it already does.
21:11:41 <hpaste>  farshid61 pasted "farshid61" at http://hpaste.org/418
21:11:53 <sorear> There's a story that Wirth considered an optimization worth adding to the Oberon compiler iff it made the time required to bootstrap go *down*.
21:12:28 <dons> that's a nice heuristic.
21:22:25 <xpika> @src words
21:22:25 <lambdabot> words s = case dropWhile isSpace s of
21:22:25 <lambdabot>     "" -> []
21:22:25 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
21:24:49 <dons> cdsmith: i note your posts are in p.h.o now
21:24:54 <dons> or , some of them.
21:27:13 * shapr boings excitedly
21:27:48 * sorear smiles energetically
21:27:52 <dibblego> ?check \xs -> concat (group (xs :: [Int])) == xs && all (\ys -> case ys of [] -> True; (y:ys) -> all (==y) ys) (group xs)
21:27:55 <lambdabot>  OK, passed 500 tests.
21:28:47 <dibblego> @pl \xs -> concat (group (xs :: [Int])) == xs && all (\ys -> case ys of [] -> True; (y:ys) -> all (==y) ys) (group xs)
21:28:47 <lambdabot> (line 1, column 72):
21:28:48 <lambdabot> unexpected ">"
21:28:48 <lambdabot> expecting variable, "(", operator or ")"
21:28:59 <dibblego> @pl concat (group (xs :: [Int])) == xs && all (\ys -> case ys of [] -> True; (y:ys) -> all (==y) ys) (group xs)
21:29:00 <lambdabot> (line 1, column 65):
21:29:00 <lambdabot> unexpected ">"
21:29:00 <lambdabot> expecting variable, "(", operator or ")"
21:29:02 <cdsmith> dons: ah, cool
21:29:04 <dibblego> get stuffed
21:30:29 <cdsmith> dibblego: ???
21:30:40 <dibblego> sorry, talking to lambdabot
21:30:43 <dibblego> :)
21:30:46 <cdsmith> Oh!  Okay.
21:34:12 <LoganCapaldo> > 2 + 3
21:34:14 <lambdabot>  5
21:34:24 <LoganCapaldo> Ah phew. Still true
21:38:33 <sorear> :t foldM
21:38:35 <lambdabot> forall a b (m :: * -> *). (Monad m) => (a -> b -> m a) -> a -> [b] -> m a
21:39:48 <jfredett> LoganCapaldo, but check this out:
21:39:50 <jfredett> > round(2.4) + round(2.4) == round(2.4 + 2.4)
21:39:52 <lambdabot>  False
21:40:00 <jfredett> dun dun duuun!
21:40:23 <jfredett> in fact...
21:40:25 <jfredett> > round(2.4 + 2.4)
21:40:27 <lambdabot>  5
21:40:27 <jfredett> == 5
21:40:30 <jfredett> :)
21:40:44 <jfredett> so for large values of 2,
21:40:47 <jfredett> 2+2 == 5.
21:40:58 <jfredett> stick _that_ in your dataset and plot it.
21:41:24 <Saizan> "large values of 2"?:D
21:41:36 <jfredett> Saizan: yep, large values of two
21:41:42 <jfredett> or very small values of 5
21:41:55 <jfredett> significant figures are a bitch.
21:43:18 <Saizan> oh well it sounds funny to me, but i guess it's just the english technical jargon for this kind of things?
21:43:28 <jcreigh> haha
21:43:34 <jfredett> heh- its a joke, Saizan
21:43:37 <jfredett> just a joke-
21:43:42 <LoganCapaldo> I think it's more of a joke than jargon
21:43:51 <LoganCapaldo> what jfredett said
21:43:55 <jfredett> 2.4 == 2 according to significant figures.
21:44:12 <Saizan> k :)
21:44:12 <jfredett> so 2+2 == 4, but 2.4 + 2.4 = 4.8, which is 5 in significant figures
21:44:31 <jfredett> its a dumb, geeky joke- but just a joke.
21:44:33 <LoganCapaldo> based on the idea of things like 1/x = 0 for very large values of x
21:45:02 <jfredett> well, k/x, LoganCapaldo, but I'm a nitpick. :)
21:45:03 <Saizan> yeah, i did get the idea the first time
21:45:10 <jfredett> okay-
21:45:20 <LoganCapaldo> Correctness must make way for humor! :)
21:45:50 <jfredett> Pah, Correctness, leave that to the theoreticians and mathematicians! wait -- thats me.
21:45:56 <jfredett> damn!
21:46:18 <jfredett> God, I wish this company would get back to me
21:46:24 <jfredett> granted its 1 am
21:46:25 <treble> which company?
21:46:32 <jfredett> but the suspense is freaking killing me
21:46:34 <jfredett> ITA
21:46:49 <jfredett> there a software company I interviewed at in Boston yesterday
21:46:54 <shapr> they're ?
21:47:05 <jfredett> I think everything went pretty well.
21:47:07 <cdsmith> Hmm... "ITA Software - Solving the Travel Industry's Most Complex Problems"
21:47:10 <jfredett> s/there/they're, yes.
21:47:18 <jfredett> cdsmith: yep
21:47:23 <cdsmith> good luck
21:47:35 <jfredett> I've never been on a _real_ interview before
21:47:38 <treble> and they are a Haskell shop?
21:47:43 <jfredett> lisp
21:47:53 <jfredett> though I'll be working with the Java side of things
21:47:55 <treble> that'd be fun too
21:47:58 <treble> oh
21:48:10 <shapr> _Real_ interviews suck!
21:48:15 <cdsmith> There's always job advancement.
21:48:20 <jre2> hah
21:48:22 <weitzman> How do you know if an interview is _Real_?
21:48:26 <treble> shapr: go on :)
21:48:32 <shapr> weitzman: If you're sweating afterwards?
21:48:50 <jfredett> shapr: I agree, I prefer _Complex_ or _Transfinite_ interviews myself.
21:48:54 <weitzman> shapr: I don't think you and I are interviewing in the same industry...
21:49:04 <jfredett> though the occasional _Integer_ interview never hurts
21:49:18 <treble> shapr: What companies give sweat-inducing interviews?
21:49:26 <treble> Your current one? ;)
21:49:34 <cdsmith> shapr: last time I interviewed people, I asked candidates how they'd find the largest number in a list.  A third of them just walked out.  They were sweating, but that can say more about them than my questions.
21:49:40 <weitzman> I've enjoyed my interviews for the most part
21:49:43 <jfredett> BOFH's 'R Us?
21:49:44 <shapr> weitzman: Most of my _real_ interviews were for corporate wage slave jobs, and they were pushy.
21:49:53 <LoganCapaldo> cdsmith: hearing stories like that worries me
21:49:57 <bos> shapr gets paid to hack haskell, lucky dog.
21:49:57 <lambdabot> bos: You have 1 new message. '/msg lambdabot @messages' to read it.
21:50:10 <jfredett> cdsmith- uhm sort and grab?
21:50:14 <jre2> what do you do shapr?
21:50:18 <Modius> I'd imagine the things they were fishing for in a lisp job were the kind of things that would get you branded strange if you discussed them at a typical interview.
21:50:22 <weitzman> Sometimes I get lucky and someone only has one or two recycled questions to ask me, and I can spend the rest of the interview telling the interviewer how cool Haskell STM is or something
21:50:25 <LoganCapaldo> jfredett: you'd bother to sort?
21:50:26 <jfredett> or screw that, foldr1 max [list here please]
21:50:31 <glguy> Did someone say paid to write Haskell?
21:50:36 <shapr> Yeah, most of my recent jobs I didn't interview for, I got invited to do the job.
21:50:42 <cdsmith> jfredett: I think I'dve been happy with anything but a blank stare.
21:50:45 <jfredett> LoganCapaldo: depends if i needed more than just the max.
21:50:46 <glguy> ;)
21:50:47 <shapr> glguy: Why yes, where do you work these days? ;-)
21:50:54 <jre2> weitzman: I've done the same thing, although I chat about the actor model a bit too
21:51:11 <jfredett> cdsmith: if I'm allowed the fancy bits of the prelude, maximum listhereplease
21:51:15 <shapr> glguy: maybe OREGON?
21:51:34 <cdsmith> jfredett: it was actually a Java job I was hiring for at the time.
21:51:38 <shapr> jre2: I'm a professional Haskell programmer! w00!
21:51:46 <shapr> jre2: For ... six months or so now.
21:51:46 <jfredett> I was asked to write out factorial in scheme- then to write quicksort in w/e language I liked.
21:52:01 <Excedrin> shapr: what do you work on?
21:52:03 <brad_> this is a somewhat idtioic question (even for me), but i am wondering how to extract specific values (like tdDay) from the System.Time TimeDiff record structure, an example of which is: TimeDiff {tdYear = 0, tdMonth = 4, tdDay = 28, tdHour = 8, tdMin = 37, tdSec = 31, tdPicosec = 997392000000}
21:52:07 <jfredett> so I did that in Haskell, the interviewer (who hadn't heard of Haskell) thought it was pretty
21:52:10 <shapr> Excedrin: I get paid to hack on HAppS.
21:52:11 <weitzman> My theory of interviewing, not that I've ever done it myself, is that you should just ask the interviewee to tell you some stuff they find interesting in computer science
21:52:19 <jre2> shapr: damn, I have to use perl...
21:52:19 <Excedrin> shapr: o rite, I remember that
21:52:36 <Excedrin> shapr: how's HAppS these days? I haven't looked at it recently
21:52:37 <shapr> weitzman: You'd never pry me out of the office at that rate :-) I'd get excited and start telling you about the latest papers I've read.
21:52:44 <glguy> shapr: can you think of a word that rhymes with Galois?
21:52:44 <shapr> Excedrin: It's spiffy, and getting better.
21:52:48 <jfredett> weitzman: they did (more or less), I told them about Category theory
21:52:52 <glguy> I was going to be goofy, but I'm drawing a blank
21:53:03 <shapr> glguy: No, not really.
21:53:10 <jfredett> Faux Pas
21:53:15 <dons> brad_: tdDay is a record accessor
21:53:16 <kfish> brad_, the field names (like tdDay) are functions that return that value
21:53:17 <weitzman> shapr: That's exactly what I'd want, though. Then I would know what you're good at and what background you have -- isn't that what interviewer's are supposed to want?
21:53:23 <jfredett> though- thats two words
21:53:27 <weitzman> shapr: One day, I'd like to try out my interview technique
21:53:30 <glguy> jfredett: yeah, I guess it would be good to know French, eh :)
21:53:36 <jfredett> La Croix, technically two.
21:53:43 <SamB_XP> fo pah rhymes with ga-loy?
21:53:48 <jfredett> Oui, glguy
21:53:51 <brad_> thanks dons and kfish!
21:53:52 <shapr> SamB_XP: I thought it was gal-wah ?
21:53:54 <dibblego> ?check \xs n -> n >= 0 && n < length xs ==> inits (xs :: [Int]) !! n == reverse (drop (length xs - n) (reverse xs))
21:53:55 <lambdabot>  Arguments exhausted after 316 tests.
21:53:55 <SamB_XP> oh.
21:53:56 <glguy> shapr: it is
21:53:57 <jfredett> SamB_XP: its Gal wah
21:54:00 <SamB_XP> that would explain it
21:54:10 <shapr> glguy: bra rhymes...
21:54:19 <SamB_XP> wawa!
21:54:21 <shapr> glguy: And that means "good" in Swedish :-)
21:54:21 <dibblego> why are the arguments exhausted? it can keep generating lists - which the range of n depends on?
21:54:25 <jfredett> not enough syllables though, shapr
21:54:52 * shapr goes back to filtering through CUFP speakers...
21:54:57 <LoganCapaldo> weitzman: I think the problem with that method is that it doesn't necessarily indicate whether they are suitable for the job at hand, unless by some coincidence their answer happens to match up. OTOH this is a flaw it shares with most other interview techniques anyway, so maybe it's not so bad :)
21:55:00 <dons> ?scheck check \xs n -> n >= 0 && n < length xs ==> inits (xs :: [Int]) !! n == reverse (drop (length xs - n) (reverse xs))
21:55:00 <lambdabot>  Parse error
21:55:09 <brad_> those accessor methods - do they need to be called out if i am importing System.Time as a qualified package?
21:55:12 <dibblego> ?scheck \xs n -> n >= 0 && n < length xs ==> inits (xs :: [Int]) !! n == reverse (drop (length xs - n) (reverse xs))
21:55:16 <lambdabot>   Completed 325767 test(s) without failure.  But 195274 did not meet ==> cond...
21:55:22 <shapr> LoganCapaldo: Yeah, I agree with that. Knowledge and understanding /= ability to produce code.
21:55:26 <dibblego> what is scheck?
21:55:29 <dibblego> ah I see
21:55:32 <shapr> dibblego: smallcheck?
21:55:33 <dons> breadth-first quickcheck
21:55:43 <dons> rather than a random walk, and with different cut offs
21:56:03 <jfredett> s stands for super?
21:56:05 <SamB_XP> the only interview technique guarenteed to tell you if someone can do the job or not is to... have them try and do the job!
21:56:07 <glguy> ?scheck \ x -> x > (-2 :: Int)
21:56:09 <lambdabot>   Failed test no. 1. Test values follow.: -2
21:56:10 <dons> ?scheck \x y -> x && y
21:56:12 <lambdabot>   Failed test no. 2. Test values follow.: True, False
21:56:13 <glguy> ?scheck \ x -> x > (-3 :: Int)
21:56:15 <lambdabot>   Failed test no. 1. Test values follow.: -3
21:56:17 <dons> ?check \x y -> x && y
21:56:19 <lambdabot>  Falsifiable, after 0 tests: False, True
21:56:26 <glguy> ?scheck \ x -> x > (-30 :: Int)
21:56:28 <lambdabot>   Completed 13 test(s) without failure.
21:56:29 <dons> ?check \x -> x  || not x
21:56:31 <lambdabot>  OK, passed 500 tests.
21:56:32 <dons> ?scheck \x -> x  || not x
21:56:34 <lambdabot>   Completed 2 test(s) without failure.
21:56:34 <jfredett> SuperCheck 4000XPZ4, Checking your code hardcore since 20 minutes ago.
21:56:56 <SamB_XP> jfredett: small!
21:57:04 <shapr> SamB_XP: I agree with you. I think that pair programming with interviewees is a good way to do interviews.
21:57:30 <weitzman> One thing I'm disappointed about is that nobody really asked any trick questions in any of my interviews
21:57:45 <jfredett> weitzman: Really? Thats all I got-
21:57:46 <shapr> Yeah, but trick questions rarely come up in real day to day working!
21:57:47 <weitzman> Nothing about ropes and doors and hourglasses and stuff
21:57:47 <dibblego> was smallcheck a response to the Clean version?
21:57:51 <glguy> shapr: I've gotten to do a lot of pair programming recently
21:57:52 <SamB_XP> hah
21:57:53 <jfredett> i thought it was the norm
21:58:00 <glguy> shapr: I understand now why you were so excited about it before
21:58:19 <dons> dibblego: nope.
21:58:28 <shapr> glguy: yay!
21:58:50 <jre2> the real trick is when your interviewer is an idiot
21:59:02 <SamB_XP> jre2: is it called "run away"?
21:59:28 <SamB_XP> that's the ultimate attack of the anything-goes school of martial arts, isn't it?
21:59:28 <jre2> in this case, the company overall was good, just a few bad apples
21:59:42 <jfredett> all 4 of my interviewers had Masters or better. so I felt a little bit inferior...  :(
21:59:42 <weitzman> jfredett: My questions were mostly straight-ahead CS stuff. They weren't all necessarily easy, but they were all CS questions at least
21:59:44 <xpika> http://www.haskell.org/haskellwiki/Blow_your_mind#Other
21:59:45 <lambdabot> Title: Blow your mind - HaskellWiki
21:59:52 <xpika> where it says match a constructor
22:00:00 <xpika> is the {} equivalent to _
22:00:26 <SamB_XP> xpika: no... it is equivalent to "as many _s as it takes"
22:00:33 <weitzman> jfredett: There are all the legends of old Microsoft interview questions about buring ropes and getting people across bridges, but I didn't get any of that from MS
22:00:38 <shapr> jfredett: education /= clue
22:00:49 <weitzman> *burning
22:00:50 <glguy> xpika: typically its: RecordConstructor {} meaning, just match the constructor and not th efields
22:00:54 <jfredett> shapr: these people had some serious clues
22:00:59 <jre2> my roommate had an interviewer who had no idea about ACM (or apparently any academic side of CS)
22:01:12 <jfredett> I had a question about Movie titles-
22:01:14 <jfredett> that was fun
22:01:32 <SamB_XP> what was the question?
22:02:00 <jfredett> given a set of all movie titles, find the longest chain such that the last word of the kth title matches the first word of the k+1th title
22:02:23 <SamB_XP> oh
22:02:32 <SamB_XP> *all* movie titles?
22:02:42 <jfredett> yah,
22:02:50 <jfredett> any one ever made ever.
22:03:06 <SamB_XP> what if I made one and burned it, and didn't tell anyone about it?
22:03:17 <jfredett> still counts
22:03:19 * shapr smacks SamB_XP with the 'gotta be difficult' label.
22:03:28 * SamB_XP wears it proudly
22:03:30 <jfredett> the answer is that there is an infinitely long chain. "Live or Die another Day to Live ..."  (there are actually lots)
22:03:30 <shapr> (it's a copy of my own label, of course)
22:03:37 <SamB_XP> hahaha
22:03:52 <SamB_XP> or you could just go with Jaws
22:04:10 <jfredett> nope, 1 worders don't have a first or last word
22:04:15 <glguy> lies!
22:04:16 <SamB_XP> yes they do
22:04:16 <jfredett> i forgot to say that
22:04:21 <jfredett> so they dont count
22:04:25 <jfredett> no- they have 1 word
22:04:30 <jfredett> your not allowed to multitask them
22:04:33 <SamB_XP> > last (words "Jaws")
22:04:35 <lambdabot>  "Jaws"
22:04:39 <SamB_XP> > head (words "Jaws")
22:04:41 <lambdabot>  "Jaws"
22:04:43 <SamB_XP> see!
22:04:46 <glguy> ?all-dicts last
22:04:48 <lambdabot> *** "Last" gcide "The Collaborative International Dictionary of English v.0.48"
22:04:48 <lambdabot> Late \Late\ (l[=a]t), a. [Compar. {Later} (l[=a]t"[~e]r), or
22:04:48 <lambdabot>    {latter} (l[a^]t"t[~e]r); superl. {Latest} (l[=a]t"[e^]st) or
22:04:48 <lambdabot>    {Last} (l[.a]st).] [OE. lat slow, slack, AS. l[ae]t; akin to
22:04:48 <lambdabot>    OS. lat, D. laat late, G. lass weary, lazy, slack, Icel.
22:04:49 <SamB_XP> lambdabot agrees with *me*
22:04:50 <lambdabot> [303 @more lines]
22:04:57 <dibblego> LoganCapaldo, it's not just you :)
22:05:34 <jfredett> its either
22:05:36 <jfredett> data movieTitle a = (First a) (Last a) | (First a) (Middle a) (Last a)
22:05:49 <jfredett> there are no one word movies, as far as the problems concerned
22:06:02 <glguy> sounds like you are making this up as you go!
22:06:12 <glguy> I have these kinds of requirements
22:06:15 <jfredett> no- they were
22:06:50 <jfredett> it was all "now what happens if I say the titles have to loop alphabetically backwards in arabic!"
22:07:15 <SamB_XP> huh?
22:07:17 <xpika> SamB_XP: glguy: ok i got it to work
22:07:35 <jfredett> SamB_XP: thats what I said...
22:07:36 <jre2> glguy: that's how it is in the real world
22:08:02 <SamB_XP> well, I'm guessing at some point pango will get confused if that even makes any sense to start with
22:08:36 <glguy> jre2: I've seen the real world, and I decided against living it in ;)
22:08:57 <glguy> in it*
22:09:53 <shapr> I have a weird question...
22:09:56 * shapr picks on glguy 
22:11:01 <shapr> glguy: After reading all the CUFP talk proposals, I only see two 'flavors' of talks. There's 'develop safely' and 'how your FP language can be as popular as Ruby'. Is there any other major flavor that's interesting at a commercial FP gathering?
22:11:18 <jre2> glguy: how are you pulling that off? because right now, I'm writting foldr/map/curry functions to make perl less awful and somehow escaping sounds pretty good
22:11:25 <shapr> Even 'develop quickly' is the same as 'develop safely', right?
22:11:43 <bos> i'd prefer to see "how your FP language can be as popular as sex", because let's face it, ruby pales in comparison.
22:11:50 <shapr> True that.
22:12:00 <SamB_XP> bos: first you'd have to popularize thought
22:12:05 <jfredett> ... yep
22:12:12 <shapr> bos: Speaking of which, is the Linden VM spec public? LSL really bites.
22:12:13 <dons> shapr: hmm, 'developer faster code' ?
22:12:20 <glguy> I don't think that develop safely and develop quickly are necessarily the same boat
22:12:22 <SamB_XP> oooh, yeah, that one too!
22:12:24 <jre2> I think develop quickly = develop safely once the project is sufficiently large (sometimes sooner)
22:12:25 <jfredett> because If I found a language that was as good a sex, I'd use it, _alot_
22:12:31 <jfredett> ahem.
22:12:33 <SamB_XP> glguy: well, if you have less debugging to do it saves time...
22:12:33 <dons> shapr: (just wondering if our semi-commercial polymer simulator stuff in haskell would be relevant)
22:12:43 <bos> shapr: VM spec?  hahahahahahaha!
22:12:43 <shapr> @remember jfredett because If I found a language that was as good a sex, I'd use it, _alot_
22:12:44 <lambdabot> Done.
22:12:51 <glguy> SamB_XP: but I don' think that people necessarily do one for the purpose of doing the other
22:13:00 <jfredett> ooh- I got remembered
22:13:01 <shapr> dons: Yes, you've brought up a good point.
22:13:05 <bos> shapr: there is no spec, beyond what's already public.
22:13:10 <jfredett> kickass.
22:13:14 <dons> like the olympic ideal: faster, safer, better. or something.
22:13:22 <ddarius> You got remembered saying "alot"
22:13:31 <glguy> shapr: I think that understanding the hard requirements on time and space are current / important issues in FP
22:13:48 <shapr> So, actual source being close to spec?
22:14:02 <glguy> you can't get software certified for some of the highest levels of assurance if you can't prove that it won't run out of memory, for example
22:14:16 <dons> yes, shapr , "Swifter, Higher, Stronger." :-)
22:14:22 <jfredett> ddarius: damnit, i like alot better than a lot or allot or any of that nonsense, whoreallyneedsspacesanyway?hm?
22:15:06 <jfredett> :)
22:15:25 <jre2> and "sexier"
22:15:43 <bos> i'm stuck shaving yaks tonight. waiting for a vmware license key, so i can install vmware workstation, so i can install windows, so i can install ghc, so i can take screenshots as i go.
22:16:01 <erider> are clean questions fielded here as well?
22:16:11 <jfredett> shaving yaks? god i hope thats a euphemism.
22:16:13 <bos> only filthy ones.
22:16:18 <glguy> bos: why not vmware server? that's what I'm on now
22:16:20 <jre2> bos, windows over a real dev platform?
22:16:24 <weitzman> bos: If you're feeling committed, you can use VMware player to install windows
22:16:26 <bos> jre2: for the book
22:16:43 <jfredett> erider: we'll answer any question, clean or dirty
22:16:46 <bos> glguy: i tried installing freebsd under vmware server, and it hung my laptop repeatedly.
22:16:51 <ddarius> erider: We don't know jack about Clean.
22:16:58 <jfredett> erider: just expect it to come back dirtier than when it left
22:16:58 <weitzman> bos: There are guides for creating a blank computer in VMware player, on which you can install an OS
22:17:12 <jre2> bos: book?
22:17:12 <bos> weitzman: yeah, i know.
22:17:20 <bos> jre2: http://www.realworldhaskell.org/
22:17:23 <lambdabot> Title: Real World Haskell
22:17:46 <jre2> bos: oh nice, this is the problem with my word disallowing irc
22:17:47 <bos> never mind monads, here's a screenshot of a windows installer!
22:20:21 <jre2> bos: admitidly, problems with getting stuff to work on windows are usually the hardest I have to solve
22:20:24 <sorear> bos: Doesn't haskell use the same syntax on all platforms?
22:20:51 <bos> sorear: i feel compelled to write up how to install ghc.
22:21:13 <ddarius> Download, double-click, follow the simple directions...
22:21:40 <bos> ddarius: alas, people expect a little more hand-holding.
22:22:06 <Shimei> ... get a trojan, try to use spybot only to find the ad-ware blocks it, re-install, JMP to start...
22:22:07 <jre2> setting up ghc,darcs,hsSDL,hOpenGL might be more practicle
22:22:15 <glguy> people that want to learn Haskell who can't run an installer?
22:22:23 <dibblego> bos, fuck those people and write the book to target people who want to use Haskell in the real world
22:22:25 <jre2> since you have to teach the essentials of darcs, etc
22:22:26 <weitzman> ddarius: The question I always have for windows installers is whether they understand windows permissions
22:22:40 <dibblego> bos, we always have CoFP if we don't know how to install ghc/hugs
22:23:02 <sorear> Nah.
22:23:19 <weitzman> ddarius: Aside from a few Microsoft apps, Starcraft is the only program I can think of whose installer will go so far as automatically showing you the dialog to run it with higher permissions
22:23:20 <dibblego> I'm tired of books being held back by dimwits
22:23:21 <bos> shrug.  i like writing stuff that's helpful.  i haven't tried installing ghc on windows myself, so i can't write about any pitfalls there might be.
22:23:28 <sorear> bos: Just put a bootable *nix CD in the back cover, with GHC pre-installed. :P
22:23:33 <dibblego> I look forward to your book because I expect it won't be held back
22:23:44 <bos> sorear: i've definitely thought about a GHC live CD.
22:24:01 <bos> dibblego: if you don't want to be held back, skip those three pages.
22:24:14 <dibblego> bos, I just hope the rest of the book doesn't suffer is all
22:24:28 <weitzman> Oo, what about an xmonad + GHC vmware image
22:24:40 <dibblego> weitzman, that would be neat
22:24:47 <jre2> I agree
22:25:00 <sorear> dibblego: "held back" ?
22:25:18 <dibblego> sorear, be appealing to the very very lowest common denominator
22:25:20 <dibblego> *by
22:25:32 <bos> dibblego: you'll be able to judge for yourself, i'm sure.
22:25:39 <sorear> Ah.  As in the expression "to hold back".  I see.
22:26:05 <dibblego> bos, I will :)
22:45:17 <jre2> anyone know of any existing work on a hOpenGL graphics engine?
22:45:39 <dons> Frag?
22:46:47 <jre2> dons: I meant a bit more generalized
22:47:05 <dons> i don't know of a general purpose HOpenGL-based engine
22:47:53 <jre2> alright, didn't think so but wanted to check
22:47:57 <kfish> jre2, i'd be interested in that too, what are you building (what's your app/game)?
22:51:05 <bos> the best open source graphics engine is http://www.ogre3d.org/ if you're looking for inspiration
22:51:06 <lambdabot> Title: OGRE 3D : Open source graphics engine - Home
22:51:19 <jre2> kfish: I'm not really a fan of graphics programming (I see it as purely a means to an end)- my goals are mainly in ai (ie using GAs) within the context of games
22:52:36 <jre2> bos: yea, I did a visualizer for an AI contest our acm chapter hosted last year in OGRE, but using C++ wasn't a pleasant experience
22:53:11 <bos> yeah.
22:55:00 <jre2> also, long code/compile/run/test cycles
22:55:44 <jre2> on the other end, panda3d (in python) allows you to edit code at runtime quite nicely, allowing you to negate the long startup times and whatnot
22:56:03 <kfish> nice
22:56:53 <jre2> but lack of static type checking leads to me spending too much time fixing bugs that are a result of typos and mismatched types
22:57:35 <SamB_XP> jre2: yeah, I've noticed that too
22:58:11 <ClaudiusMaximus> Fluxus has Scheme bindings that let you edit code at runtime, was thinking of writing Haskell bindings for it one day...
22:58:36 <SamB_XP> it's to the point where I might rather use C than python because C complains when you refer to nonexistant things ;-)
22:58:48 <ClaudiusMaximus> http://pawfal.org/fluxus/
22:58:49 <lambdabot> Title: fluxus
22:59:08 <jre2> for large projects, I mostly agree
23:01:09 <jre2> also, I've been corrupted by the dark side (FP)
23:01:20 <SamB_XP> what's the dark side of FP?
23:01:31 <desp> LISP macros
23:01:35 <SamB_XP> heh
23:01:37 <jre2> SamB_XP: you can no longer stand anything else
23:01:42 <SamB_XP> oh, that.
23:01:51 <SamB_XP> that's not called the dark side...
23:03:02 <SamB_XP> that's called good taste ;-)
23:03:15 <jre2> hah
23:07:33 <jre2> so I figured what I really want is haskell with the ability to quickly test changes. which essentially means reloading modules on the fly
23:11:59 <dons> might be easier to just test in ghci though.
23:12:12 <dons> since purity means you can test in isolation, and ghci lets you reload modules quickly
23:13:11 <paganjew> Would it be possible to construct a computer algebra system from haskell as apposed to lisp?
23:13:44 <dons> sure, its been done.
23:13:56 <dons> see Docon, a very large CAS.
23:14:04 <paganjew> dons, ty
23:14:16 <paganjew> dons, i am very very new to haskell
23:15:24 <jre2> dons: I wasn't careful with my words, I meant less testing correctness and more testing intent
23:15:46 <dons> paganjew: see http://haskell.org/haskellwiki/Libraries_and_tools/Mathematics#Computer_Algebra
23:15:48 <lambdabot> Title: Applications and libraries/Mathematics - HaskellWiki, http://tinyurl.com/yshqfj
23:16:38 <sorear> :t M.singleton
23:16:42 <lambdabot> Couldn't find qualified module.
23:16:46 <sorear> :t Data.Map.singleton
23:16:49 <lambdabot> forall k a. k -> a -> Data.Map.Map k a
23:16:57 <jre2> i.e. spawning objects and tweaking them a la 'livecoding' to figure out what I actually want
23:17:59 <dons> jre2: right, so either ghci-based, or ghc-api, or hs-plugins.
23:18:02 <paganjew> dons, looks promising
23:18:05 <dons> hs-plugins and ghc-api are used in practice for this.
23:19:28 <jre2> yea, that seems the way to go
23:28:50 * SamB_XP wonders why accuweather and weather.com disagree so much for 19082...
23:39:26 <glguy> how well is GHC supported on the amd64 architecture?
23:39:41 <c> its compiled iyself (if it does) fine for years
23:39:49 <c> all i know is darcs works.
23:40:38 <glguy> My processor can run in 32 bit and 64 bit modes , and I'm wondering if there is any reason to run it in the 64 bit mode (Gentoo Linux)
23:40:54 <dons> bigger ints?
23:41:03 <c> twice as many general purpose registers - stuff is faster
23:41:06 <dons> faster Word64s -- by far
23:41:15 <dons> lazy bytestrings will be marginally faster
23:41:23 <glguy> are there downsides?
23:41:30 <dons> broken C apps?
23:41:34 <glguy> hmm
23:41:45 <dons> probably not many now. a lot of haskellers seem to be using amd64 machines
23:41:48 <glguy> I only use the linux install for apache and ghc
23:42:02 <dons> ghc on amd64 has a heaps good native code gen
23:42:06 <dons> faster fp math, for example
23:42:20 <glguy> this is a core 2 duo (mobile)
23:42:29 <glguy> same advantages, right?
23:42:44 <glguy> what does it do with those extra registers when running in 32bit mode?
23:42:45 <dons> yeah, sorry, i got stuck in a habit calling x86-64s amd64s
23:42:54 <sorear> glguy: I'd suggest using a 64 bit setup.  AMD64 chips support a transparent x86 emulation mode
23:42:55 <dons> turns them off? (not sure)
23:42:55 <glguy> Gentoo calls it amd64
23:43:11 <Korollary> I think 32-bit apps incur a penalty in 64-bit OS'
23:43:13 <dons> gentoo seems to sensibly follow bsd practices.
23:43:13 <sorear> glguy: they're still available, but only by using illegal instructions :)
23:43:18 <glguy> heh
23:43:28 <sorear> illegal on plain x86 that is
23:44:25 <sorear> just like you can do 32 bit math on a 386, even in 8086 compatibility mode
23:44:25 <dons> glguy: you could compare some apps for various characterisitics on each mode.
23:44:25 <glguy> I wonder why this laptop came with windows 32bit then...
23:44:25 <dons> and make an informed decision.
23:44:25 <alexj> are regulare strings now legacy?  are there contexts where one would prefer string to bytestring?
23:44:25 <dons> binaries will be twice as big
23:44:25 <sorear> glguy: I'm guessing win64 is exactly twice as expensive
23:44:25 <dons> alexj: if you're pattern matching, or need unicode
23:44:43 <dons> strings aren't deprecated or legacy, they're just not suitable for larger input/output to the outside world
23:44:47 <sorear> alexj: also, for short strings String is faster.
23:45:13 <alexj> ok.  so if you are parsing XML?
23:45:27 <dons> bytestrings, since those pages could be quite big
23:45:30 <dons> and they come from the outside world
23:45:42 <dons> if ... there's a bytestring capable xml paresr
23:45:45 <alexj> yeah.  I think most of my application contexts are becoming byutestring.
23:45:54 <alexj> libxml.
23:46:01 <alexj> ?
23:46:08 <glguy> does anyone know off-hand if vmware running on a 32-bit windows will run a native 64-bit linux? or if it emulates the 64 bit some how?
23:46:20 <dons> alexj: that'd be perfect. (communicating with C depends bytestrings)
23:46:29 <glguy> I've booted into the x86_64 livecd
23:46:34 <sorear> glguy: Quite possibly both. :)
23:46:55 <alexj> ok.  any native haskell libs that parse bytestring XML?
23:46:56 <sorear> glguy: 100% software emulators will run native-64 os'es
23:47:07 <dons> alexj: so my rule of thumb is: a) will the strings be > 10k, b) do they come off the wire, or file system c ) do they have to be passed to or from C? if any of those is true, use bytestrings
23:47:28 <dons> alexj: i don't know of any, but one may exist.
23:47:40 <dons> alexj: people seem to profitably use haxml + String though.
23:47:46 <dons> maybe only on smaller inputs.
23:47:54 <dons> (< 500k or so)
23:48:19 <dons> a bytestring binding to libxml would be pretty spfiffy
23:48:21 <TSC> dons: Can you explain part (b) again?
23:48:22 <alexj> using string appears to be somewhat incompatible with generic haskell.
23:48:44 <dons> TSC, if you expect to obtain these strings from the network, or from reading files, then bytestrings make sense
23:48:46 <TSC> Do you mean if they come either off a wire or off a file system, then use byte strings?
23:48:52 <dons> if they're say, typed in by users, [Char] should be fine.
23:48:52 <alexj> we now have a nice generic xml read/parse implementation.
23:48:52 <TSC> Ok, thanks
23:48:54 <alexj> thanks to igloo.
23:49:25 <dons> sybwc?
23:49:32 <alexj> yes
23:49:45 <dons> ah, so you prompted him to upload that?
23:49:48 <alexj> hope to get the repo more live tomorrow.
23:49:54 <dons> does happs use it?
23:50:00 <alexj> he was doing it for happs.
23:50:16 <alexj> I want the happs blog demo to be shorter than the RoR blog demo.
23:50:23 <dons> very nice. (does Igloo have a new job I didn't hear about?)
23:50:24 <dons> that's cool!
23:52:15 <alexj> I also want to kick RoR on performance.
23:52:22 <alexj> a libxml binding could do that
23:52:30 <alexj> but I don't want to raise the cost of installation.
23:52:55 <alexj> adding a step to download and install libxml seems annoying.
23:53:52 <alexj> the other advantage they currently have is not having to restart the web server with each app change....
23:54:13 <dons> pretty sure we can kick RoR for parsing.
23:54:54 <sorear> State is messy.
23:55:05 <dons> native code, highly optimised (and domain-specifically optimised) bytestrings won't leave much room for ruby
23:55:42 <glguy> RoR is a pretty low bar to shoot for, isn't it?
23:55:55 <dons> yeah :)
23:56:00 <dons> ducks in a barrel
23:56:04 <glguy> I don't remember reading anything that extolled RoR's speed advantages
23:56:12 <dons> strange that.
23:56:22 <alexj> glguy, to beat them we have to win on multiple fronts at once.
23:56:22 <glguy> Lots about how super leet using it makes you
23:56:39 <alexj> short code.  more correct.  more robust with respect to change.  10x performance.
23:56:53 <alexj> shorter code.
23:57:26 <glguy> yeah... but your code written for HaPPS actually has to type check, where even when joe noob slops something together in RoR is that technically wrong, he'll see results ;)
23:57:51 <glguy> but don't take my jokes the wrong way, I love what you are doing
23:57:53 <alexj> glguy :-)  the generic stuff is pretty cool.  a reasonable compromise.
23:58:17 <alexj> you define a haskell data structure.  and happs will infer render/parse xml.
23:58:29 <dons> on the shootout haskell is around 40x ruby (up to 500x faster)
23:58:46 <alexj> the ixset stuff means that you have a generic indexed collection type without having to deal with marshalling to an external rdbms.
23:59:02 <alexj> don't want to get us too focused on performance.
23:59:03 <glguy> yeah, but in ruby you can choose to either use or exclude the ( )'s around the function arguments!
23:59:08 <glguy> where are your priorities
23:59:12 <alexj> :- /
23:59:36 <alexj> sorear: you are right that state is messy.
23:59:56 <alexj> if you send me your email address, I will forward you the current internal discussion if you want to play.
