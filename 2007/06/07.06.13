00:00:03 <dons> Pseudonym: yeah, that's a bit weird.
00:00:19 <goltrpoat> so it's mid june or so, hot as hell, and it starts snowing.
00:00:36 <dons> Vacancy, PhD student on Real-life datatype-generic programming, Utrecht
00:00:38 <dons> sounds cool
00:00:56 <dons> ?temp
00:00:57 <lambdabot>   now 14.0°, min 6.6°, max 15.3°, rain 0.0mm, wind 24km/h SSW
00:01:07 <dons> that's pretty cold for sydney, today.
00:01:17 <dons> southerly, blowing up cold melbourne air
00:01:56 <pejo> dons, yearning to redo your phd? ;)
00:02:15 <dons> heh. no!
00:02:23 <goltrpoat> redo?  did you defend it already?
00:02:27 <dons> i've actually started writing up now. will be good to get this done.
00:02:41 <dons> nope. writing, writing, writing.
00:02:45 <Pseudonym> It's 10C outside, which is pretty typical for Winter.
00:03:05 <pejo> dons, can you fail the defense in australia?
00:03:27 <dons> hmm. I suppose so. i've not heard of it, but also, i've not met many who managed to submit either ;)
00:03:34 <goltrpoat> hehe
00:03:49 <dons> seems a good percent reach some kind of bad fixpoint
00:03:49 <pejo> Hehe. Except your supervisors?
00:04:03 <dons> well, they all did theirs in germany..
00:04:27 <dons> maybe no one graduates! its all a trap!
00:04:33 <pejo> Are you talking about phd students in general, in general in australia, at unsw, or in the pls-group?
00:05:02 <dons> oh, in ~pls (4 years old), we've had 1 finish, sean. and 3 are somewhere between writing and fixpointing.
00:05:27 <pejo> The fixpoint sounds very nasty.
00:05:30 <dons> at unsw, i've not met anyone who failed their defense. but i've met those who've failed masters reviews.
00:05:55 <pejo> Well, the reviews aren't public though, so you don't have to invite your family and all your friends to see you fail?
00:06:01 <dons> right.
00:07:05 <pejo> (Maybe grad students would be more motivated to finish if they had a german professor yelling "schnell" at them during their phd).
00:07:48 <dons> yes, i think that helps.
00:08:41 <syntaxfree> (?) is allowed in operators?
00:08:45 <syntaxfree> to be more precise, (-?>)
00:08:46 <dons> yup
00:08:51 <syntaxfree> thanks.
00:08:58 <dons> ?wiki Obfuscation
00:08:58 <lambdabot> http://www.haskell.org/haskellwiki/Obfuscation
00:09:03 <goltrpoat> i get this mental image of koch or pasteur, with that gigantic fuckoff facial hair type deal they used to have in those days, standing over a desk and screaming SOFORT@!!!
00:09:49 * syntaxfree is implementing sentential logic as he reads an introductory book.
00:10:08 <Excedrin> ?temp
00:10:09 <lambdabot>   now 14.1°, min 6.6°, max 15.3°, rain 0.0mm, wind 28km/h SSW
00:10:33 <dons> sorry, only lambdabot-local temp.
00:10:39 <scodil> where is that?
00:10:47 <dons> here.
00:10:54 <goltrpoat> syntaxfree:  i'm factoring gigantic polynomials.  i don't think they like me.
00:10:56 <scodil> oh ok ... ???
00:10:58 <dons> oh, i mean, 'there' from your perspective. /me points
00:11:23 <scodil> so that's the temperature in the case of the computer on which lambdabot is running?
00:11:57 <arcatan> there's wind of 28km/h in the case?
00:11:59 <dons> ah, hmm. let's see.
00:12:05 <scodil> the fans
00:12:06 <dons> who said it was a case measurement?
00:12:10 <scodil> that's how they keep it so cool
00:12:11 <goltrpoat> or, more likely, the local weather service's output for the locale in which lambdabot currently resides
00:12:15 <dons> indeed.
00:12:47 <dons> though i note there's a networked thermometer in the engineering building
00:12:50 <dons> i could pull data from that
00:13:14 <dons> how does one get temperature data from /proc on linux?
00:13:20 <dons> is there a /proc/sensors or something?
00:13:31 <scodil> sensors
00:13:39 <scodil> is a command, from lm_sensors package
00:13:54 <dons> ok
00:14:01 <Excedrin> /proc/acpi/thermal_zone/THM0/temperature
00:15:00 <goltrpoat> oh, nuts.
00:15:00 <dons> ah, not on lambdabot's machien though.
00:15:18 <goltrpoat> that actually appears to work.
00:15:30 <goltrpoat> on uh.. this here laptop.
00:15:38 <Excedrin> is lambdabot on openbsd?
00:15:51 <dons> used to be, currently its on a linux box maintained by the school
00:15:59 <dons> ?version
00:15:59 <lambdabot> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
00:15:59 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
00:16:59 <goltrpoat> except i get 45C, and this machine feels colder than a uh.. insert a reference to something crass and cold here.
00:17:27 <scodil> that's probably the chip
00:17:53 <scodil> or the sensor on the motherboard, which also gets warm
00:17:53 <goltrpoat> still a bit high.
00:18:07 <scodil> that seems right to me
00:18:13 <scodil> i got 44
00:18:52 <scodil> or maybe 55
00:19:01 <scodil> i can never remember which is the chip and which is the northbridge
00:19:06 <goltrpoat> hehe
00:21:54 <goltrpoat> my other laptop runs about 95F=35C after a while, and you can feel it
00:22:41 <goltrpoat> this one is a T30, it sits by the window 24/7, is actually used once a week, and could not generally be used to cook eggs on
00:22:47 <goltrpoat> which is why the 44 seems odd.
00:23:01 <scodil> yeah thats on the die though
00:23:07 <scodil> and obviously the cooling is working
00:23:13 <scodil> which is why the case feels cool
00:23:54 <goltrpoat> well, the 95F on the other one is on the die as well.  i get over 100F on the gpu, and there are some random spots i can monitor that get hot when they shouldn't.
00:24:04 <goltrpoat> but other than that, that one seems more normal.
00:25:00 <goltrpoat> anyway, cool about /proc/acpi/thermal_zone.
00:26:51 <takamura> hi
00:29:12 <goltrpoat> can someone explain to me how any of the books on the list at http://programming.reddit.com/info/1y0ux/comments are "language agnostic"
00:29:13 <lambdabot> Title: The Six Essential *Language Agnostic* Programming Books (reddit.com)
00:30:01 <syntaxfree> dang,sentential logic is hard to implement at some point.
00:30:34 <EvilTerran> goltrpoat, the first thing i notice is the lacking grammar
00:30:51 <nattfodd> goltrpoat: what's your exact question?
00:30:56 <pejo> goltrpoat, easy - restrict the class of languages to close relatives to C/C++.
00:31:00 <goltrpoat> i've only read GoF, fowler's book and code complete, but those three books are about as language agnostic as "ai: a modern approach"
00:31:24 <EvilTerran> the need for GoF-esque patterns betrays a failure in your language.
00:31:52 <EvilTerran> I am not a template preprocessor, I am a free man!
00:32:47 <nattfodd> goltrpoat: not having read any of those, my guess is that they are language agnostic because they write examples in pseudo-code and not a real language, and because they don't use any features linked to a specific paradigm, such as functional or object oriented
00:33:07 <hpaste>  trevor pasted "HaskellDB test" at http://hpaste.org/257
00:33:08 <nattfodd> i.e. plain imperative language
00:33:11 <goltrpoat> well, that's what i'd assume "language agnostic" means, correct. :)
00:33:34 <goltrpoat> those books don't quite fall in that category, though.
00:33:56 <nattfodd> ah
00:34:55 <nattfodd> then I have no idea, sorry
00:35:10 <osfameron> GoF didn't seem language neutral to me
00:35:20 <osfameron> it was all OO patterns, described in languages like C++
00:35:41 <osfameron> infact, it was the most useless "must have" IT book I've bought, so I sold it to someone else
00:36:58 <goltrpoat> i remember reading it about 12 years ago, enjoying it tremendously at the time, and never touching it again except to look up random trivia about decorators or visitors.
00:37:39 <Thunder> @seen dons
00:37:40 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 21m 41s ago.
00:37:44 <goltrpoat> i'm fairly certain they didn't intend it to be a cookbook.
00:38:03 <osfameron> I bought it at the same time as "A pattern language", which was immense fun, far more fun than a book on, er, town planning, has any right to be
00:38:10 <osfameron> and GoF was just dull
00:38:26 <goltrpoat> GoF references "A pattern language" a bunch of times, doesn't it
00:38:30 <osfameron> of course I can't use "Waist high shelves" in my web applications...
00:38:30 <weitzman_> I think GoF was mainly an attempt to give names to things people had been using in practice so that they would be easier to talk about
00:38:44 <goltrpoat> i've been meaning to pick that one up, not really for programming though.
00:38:52 <goltrpoat> weitz:  right.
00:38:59 <osfameron> yeah, it references it, but it doesn't have the same charm
00:39:16 <wode> A pattern language is the best structured book I ever read, FWIW :)
00:39:20 <osfameron> I think better patterns along Alexander lines are things like "Use version control", "Use sensible function names" etc.
00:40:36 <osfameron> I like dominus's articles on patterns, like http://perl.plover.com/yak/design/ and http://blog.plover.com/2006/09/11/
00:40:40 <lambdabot> Title: "Design Patterns" Aren't
00:40:55 <goltrpoat> i've read the first one.
00:41:02 <goltrpoat> i think erich gamma replied to it at some point.
00:42:06 <osfameron> there's a blog by Ralph Johnson on it I just read in the google search results
00:42:08 <EvilTerran> osfameron, so something like the opposite of code smells?
00:42:43 <osfameron> EvilTerran: yeah, there are some good "Antipatterns" described somewhere "Big ball of Mud" and "Ghetto"
00:43:04 <goltrpoat> there's an antipatterns wiki around somewhere.
00:43:07 <goltrpoat> good timewaster.
00:47:40 <syntaxfree> how fucked up. I just wrote about 30 lines of Haskell code to know that if it's not (not raining), then it's raining.
00:49:30 <quicksilver> the anti-apttern stuff is bit too much of an 'easy way out' to satisfy me
00:49:36 <goltrpoat> check out my prover from a while back.   utterly terrible code, but fairly readable.
00:49:53 <goltrpoat> (vandreev.wordpress.com, one of the recent posts)
00:49:55 <osfameron> quicksilver: how do you mean?
00:50:08 <goltrpoat> (syntaxfree, i mean)
00:50:25 <goltrpoat> (actually, you probably need no help here, so i'm just making an ass out of myself)
00:50:34 <goltrpoat> (i'll quit parenthesizing my sentences now)
00:50:40 <syntaxfree> I'm actually an absolute beginner following a textbook.
00:51:04 <syntaxfree> It looked like a good way to fixate ideas would be to write them out in Haskell. And it sure was.
00:51:09 <quicksilver> it's a bit too glib to sling mud at something successful and it's easy to get people laughing by doing so
00:51:11 <goltrpoat> oh, maybe it'll be helpful then, dunno.
00:51:27 <goltrpoat> check out the theorem prover post.
00:52:01 <osfameron> quicksilver: oh, you mean antipattern as in people being anti the patterns book, rather than antipattern as in "pattern of things to avoid" ?
00:52:05 <goltrpoat> quicksilver:  well, it's intended to be glib, right.
00:52:33 <syntaxfree> I tried to extend the textbook to a ten-valued logic, with interesting results.
00:52:55 <syntaxfree> anyway, I'm posting a cleaned-up version to my blog.
00:53:05 <syntaxfree> The Integer Logic thing is still not ready for prime time ;)
00:53:15 <goltrpoat> cool, i'll have to check it out.
00:53:34 <whaleofconfusion> I wonder if running alpha and beta reduction backwards in the lambda calculus has been considered
00:54:05 <goltrpoat> alpha reduction backwards?
00:54:08 <whaleofconfusion> deriving a function application from the final form
00:54:20 <whaleofconfusion> well I guess alpha reduction backwards is the same as alpha reduction forwards
00:55:00 <goltrpoat> \x.x x ==> \x2.x2 x2 ==> \x3.x3 x3? :)
00:55:28 <whaleofconfusion> so just beta reduction backwards then :)
00:55:32 <goltrpoat> :)
00:55:39 <syntaxfree> goltrpoat: it's really stupid. It's my first contact with this stuff.
00:57:21 <quicksilver> osfameron: people saying "patterns are only necessary because your language sucks, my language is so much better, na-na na na-na
00:58:47 <goltrpoat> well, there's some truth to that
00:59:02 <osfameron> quicksilver: fair enough.  I thought dominus's OO example was good though - if you move beyond "here is a pattern and how to work around it" to moving it in the language, you may gain some power and insight from it
00:59:27 <osfameron> then again, I think his main point was that Alexander is more interesting than what's in the GoF book
00:59:32 <osfameron> which is true
01:00:12 <goltrpoat> decorators are a good example of working around the lack of a particular facility in a particular language
01:00:20 <pejo> whaleofconfusion, are you talking about invertible programs?
01:00:56 <goltrpoat> visitors are your usual double dispatch stuff, but the pseudocode implementation in GoF is gigantic compared to how you'd actually want to do that in a language that does that sort of thing
01:01:13 <whaleofconfusion> no pejo I was thinking more along the lines of more local transformations
01:01:46 <goltrpoat> singletons are a big old workaround around the fact that we don't have substructural typing in mainstream languages.
01:01:48 <goltrpoat> etc.
01:01:57 <whaleofconfusion> for example, let's say you want a value v such that x v = a (x b)
01:02:05 <whaleofconfusion> where a and b are values contained within v
01:02:11 <osfameron> I also like his "Red Flags" which are kind of mini-antipatterns.  I came up with some like "doing string concatenation in a loop" (where you can replace with map and concatenate) etc.
01:02:12 <goltrpoat> so yeah, patterns of that sort are only necessary because language X sucks, at that particular thing.
01:02:21 <whaleofconfusion> you can find an a so that a (x b) = x v
01:02:30 <syntaxfree> goltrpoat: you were curious: http://syntaxfree.wordpress.com/2007/06/13/this-might-or-might-not-qualify-as-a-theorem-prover/
01:02:34 <lambdabot> Title: This might or might not qualify as a theorem prover « Data.Syntaxfree, http://tinyurl.com/25dt4t
01:02:39 <syntaxfree> I'm afraid you're going to be disappointed, though.
01:02:40 <whaleofconfusion> and if you could do it in reverse, unpacking the v, that would be more power
01:02:51 <goltrpoat> syntaxfree:  cool, reading.
01:03:12 <whaleofconfusion> i.e. v = (cons a b)
01:04:06 <pejo> whaleofconfusion, what do you mean by two values contained in another value?
01:04:12 <whaleofconfusion> just a cons
01:05:07 <whaleofconfusion> I haven't figured this through enough to determine if this is ultimately possible
01:05:54 <whaleofconfusion> maybe it ends up just restricting the values that a can take beyond usefulness
01:06:14 <pejo> whaleofconfusion, I don't really understand what you are trying to say. But you might be interested in eta reduction/eta conveersion
01:06:49 <syntaxfree> goltrpoat: I told you it wasn't much.
01:07:43 <goltrpoat> i think you missed the definition for 'stupid' in 'good'
01:07:49 <whaleofconfusion> I don't know pejo, it might be relevant
01:08:13 <goltrpoat> and wordpress ate a backslash in showF
01:08:31 <whaleofconfusion> basically what I'm saying is that if you're using a pure functional language like the untyped lambda calculus, reasoning is equational
01:08:43 <syntaxfree> goltrpoat: oh. I had deleted stupid and forgot to delete good.
01:08:46 <whaleofconfusion> so if you know (f x) = 3 then you can substitute (f x) anywhere you see 3
01:08:47 <goltrpoat> ah
01:08:52 <whaleofconfusion> it goes both ways
01:09:01 <syntaxfree> stupid was truth for (Num a) => Formula a
01:09:07 <goltrpoat> -nod-
01:09:21 <syntaxfree> except :+ was +, :* was * and a :-> b = b if a == b or an error.
01:09:23 <pejo> whaleofconfusion, Suppose f x = 42 + x. Then f 0 = 42, right?
01:09:35 <syntaxfree> good was the same, except it returned Just b or nothing.
01:09:41 <arcatan> whaleofconfusion is a great nick
01:10:15 <syntaxfree> will "read" read arbitrary data constructors?
01:10:27 <syntaxfree> I mean, will
01:10:30 <whaleofconfusion> yes pejo, what are you saying?
01:10:37 <syntaxfree> read "(Prim True) :+ (Prim False)" work?
01:10:48 <syntaxfree> I'd like to have a lil bit of interaction in a compiled executable.
01:10:49 <pejo> whaleofconfusion, so by that reasoning we can rewrite f x to f x = (f 0) + x.
01:11:28 <whaleofconfusion> well that's true but it removes information from the expression
01:11:42 <whaleofconfusion> once you've made that substitution you no longer know that (f 0) = 42
01:12:16 <whaleofconfusion> unless you store that information elsewhere
01:12:21 <pejo> whaleofconfusion, well, you obviuosly need a stronger condition for your substitution.
01:12:23 <goltrpoat> syntaxfree:  sure.  derive Read.
01:12:30 <syntaxfree> goltrpoat: good!
01:12:32 <syntaxfree> thanks.
01:12:55 <whaleofconfusion> well there certainly have to be conditions on reversing substitution to avoid variable scope conflicts
01:13:13 <whaleofconfusion> but I don't think that your example is a problem, it looks like an OK substitution to me
01:13:33 <pejo> whaleofconfusion, there are no variables in 42, nor f 0!
01:14:21 <whaleofconfusion> well, you could argue that 42, f, and 0 are all variables if you wanted to go nuts
01:14:28 <goltrpoat> is this a good time to mention that f x = 42 + x does not imply f 0 = 42?
01:15:01 <goltrpoat> er.
01:15:08 <pejo> goltrpoat, care to tell why?
01:16:01 <goltrpoat> forget me.  i had some argument with x = undefined, but i think i'm on crack.
01:16:36 <ski> 'f x = 42 + x' isn't really the same as 'forall x. f x = 42 + x'
01:17:27 <whaleofconfusion> mainly I'm trying to figure out how you might do Lisp's (values) expression in untyped lambda calculus
01:17:45 <whaleofconfusion> or expressions similar to it
01:18:42 <ski> whaleofconfusion : can you give an example of what you mean ?
01:19:03 <whaleofconfusion> so that, to simplify, (foo (values 1 2)) = (foo 1) unless foo is m-v-call in which case (m-v-call (values 1 2)) = (m-v-call 1 2)
01:19:25 <ski> yurgh
01:19:34 <whaleofconfusion> which is mangled from Lisp but it's the general idea
01:19:57 <ski> (by 'Lisp' do you mean 'Common Lisp','Scheme', or other ?)
01:20:37 <whaleofconfusion> as far as I know (values) is just common lisp but I'm just talking about the general idea, I mean I don't want to go into the detailed semantics of how it's used in CL
01:21:33 <ski> in scheme it is an error to do '(foo (values 1 2))' (unless 'foo' marks a special form)
01:21:54 <goltrpoat> i'm sure we'll do fine.
01:22:03 <whaleofconfusion> it's legal in CL
01:22:08 <ski> yes
01:22:08 <whaleofconfusion> e.g. (+ (values 1 2)) = 1
01:22:11 <goltrpoat> if anyone manages to misread something, we'll send an angry letter to the appropriate agency.
01:22:23 <ski> but is it sane ?
01:22:31 <whaleofconfusion> what do you mean sane?
01:23:10 <whaleofconfusion> it's useful
01:23:35 <ski> as i understand it, 'values' is to return as multiple arguments is to call
01:23:51 <whaleofconfusion> you can get a function foo to return a primary value that most functions that call it are interested in, and those functions don't have to worry about the other values that foo returns
01:24:11 <whaleofconfusion> but if another function wants those secondary values that foo returns, it can get them
01:24:14 <ski> so for symmetry, excess arguments to a call ought to be discarded as well, in such case
01:24:27 <pejo> whaleofconfusion, as for the arbitrary substitution things - Dave Sands has a bunch of publications on improvement theory from the mid 90's that highlight this.
01:30:53 <whaleofconfusion> is there anything in particular?
01:38:35 <goltrpoat> there was this relatively obscure (as in, overlooked) paper on directed search in optimization (code optimization, not "optimization").  trying to remember the name.
01:39:34 <goltrpoat> it was fairly cool in that it'd search over the class of eta-equivalent expressions.
01:40:32 <goltrpoat> it'd then come up with the shortest expression (by exhaustive search, with some heuristics to trim it down) that was eta-equivalent to what you gave it.
01:41:15 <goltrpoat> if anyone has read it, feel free to jump in, i can't remember the name and i'd have to start my other machine to actually get hold of it.
01:42:21 <goltrpoat> definitely not dave sands though.
01:44:47 <syntaxfree> shit.
01:44:49 <pejo> No, the issue Sands was tackling was correctness for fold/unfold transformations, basically.
01:44:54 <syntaxfree> I looked at the clock now.
01:45:03 <syntaxfree> I gotta wake up in two hours.
01:45:10 <syntaxfree> Another accidental all-nighter.
01:45:12 <goltrpoat> pejo:  this is a 200x paper :)
01:45:26 <goltrpoat> sf:  always fun.
01:45:42 <syntaxfree> damn. I'm better off not sleeping at all, I guess.
01:45:47 <pejo> goltrpoat, any idea about conference, or author, or anything?
01:45:54 <syntaxfree> I won't be able to wake up in two hours and I can't skip this class anymore.
01:46:11 <goltrpoat> sec, i'll just start up my other machine and look it up.
01:46:45 <whaleofconfusion> well.. I was just about to go to sleep
01:46:45 * syntaxfree goes rant on #haskell-blah about all-nighters
01:55:50 <goltrpoat> hah@
01:56:02 <goltrpoat> pejo:  'systematic search for lambda expressions'
01:56:06 <goltrpoat> susumu katayama
01:56:23 <goltrpoat> should be on google.
01:57:53 <goltrpoat> im guessing 2005 or so, but i don't really know, come to think of it.
02:00:48 <ttfh> how "Ready" is flippi? I've been assigned to set up a wiki at my workplace, and it would be nice to introduce software written in haskell :-)
02:04:08 <goltrpoat> shapr obviously has been running it for a while.  dunno beyond that.
02:14:19 <dobblego> ?where yaht
02:14:19 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
02:16:18 <dobblego> ?quote logic imperative
02:16:18 <lambdabot> No quotes for this person. The more you drive -- the dumber you get.
02:18:31 <roconnor> ?quote cats
02:18:31 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
02:19:15 <roconnor> ?quote cats
02:19:16 <lambdabot> sjanssen says: I suspect that planet.haskell.org has more content on catamorphisms than cats
02:23:18 <pejo> goltrpoat, tfp'05
02:29:19 <yakov> hi
02:49:03 <dons> these fakey conferences are funny:
02:49:10 <dons> "WWW and Internet
02:49:10 <dons>    had a huge development in recent years. Aspects of concern
02:49:10 <dons>    are no longer just technical anymore but other aspects have
02:49:10 <dons>    aroused."
02:51:45 <dobblego> fakey conferences?
02:55:11 <ClaudiusMaximus> dobblego, dons: even i get spammed by fake conferences "Dear Potential Speaker ... interdisciplinary conference ... stunning location ..."
02:55:53 <dobblego> cripes, I've never even heard of them; hope I haven't attended one unknowingly :)
02:56:08 <osfameron> ;-)
03:01:44 <matthew-_> ok, I want the equivalent of tryPutMVar but for Chan
03:01:58 <matthew-_> i.e. I want to only write to the Chan if it's empty
03:02:08 <matthew-_> any ideas how to do this?
03:05:21 <matthew-_> I think I'd have to rewrite/add to the Control.Concurrent.Chan module
03:05:32 <matthew-_> I basically need direct access to the MVars in the channel
03:05:33 <matthew-_> grrr
03:06:24 <Syzygy-> ?paste
03:06:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
03:07:43 <hpaste>  Syzygy- pasted "GHCi dies on TeXed lhs" at http://hpaste.org/259
03:07:54 <Syzygy-> Could someone help me figure out why this dies?
03:08:01 <Syzygy-> SaneblidzeUmble.lhs:59:0: parse error on input `type'
03:08:05 <Syzygy-> is the error given.
03:08:13 <Syzygy-> And the line number is the first Haskell statement in the paste.
03:09:05 <matthew-_> I'm guessing here, but try removing the empty line?
03:09:36 <matthew-_> (after \begin{code})
03:09:58 <Syzygy-> That's where I started. Same error.
03:10:05 <Zr40> I didn't know Haskell depended on whitespace.
03:10:25 <matthew-_> I tend to debug these things by just cutting it down to as little code as possible that actually works and then slowly add it back in
03:10:53 <Syzygy-> Zr40: It does. But not quite in that way.
03:10:57 <Syzygy-> matthew-_: Hmmmm.
03:12:26 <Syzygy-> GAH!
03:12:44 <Syzygy-> I cannot use, with Literate Haskell, both the > and the \begin{code} mode of entering code...
03:13:22 <matthew-_> oh yes
03:13:30 <matthew-_> whereas lhs2TeX allows it!
03:14:25 <matthew-_> oh, and is it just me or do other people have major issues with emacs, lhs2Tex, code blocks and the fact that emacs thinks that $ always toggles maths mode, thus turning off spell checking for math blocks.
03:14:54 <matthew-_> it's a complete pain as suddenly large sections of the paper go a) pink and b) have to be manually spell checked. grrr
03:15:45 <Zr40> I'd suggest another editor, but I figure that's not done :)
03:16:51 <matthew-_> Zr40: well, does, eg Vim, handle this much better?
03:17:22 <matthew-_> I know both quite well so I won't massively mind switching if it really is "better" for this...
03:17:58 <Zr40> I don't know. I haven't used Literate Haskell yet.
03:21:39 <Zr40> matthew-_: if I look at Darcs' Apply.lhs, Vim seems to be having the same problem
03:23:28 <matthew-_> yeah, they need to understand the meaning of \begin{code} ... \end{code} which is hard given that they may not know that lhs2TeX is in use
03:24:03 <matthew-_> really you want LaTeX highlighting outside code blocks and Haskell highlighting inside code blocks. That might be pretty hard to achieve
03:24:28 <swiert> matthew-_: I know that you should be able to use multi mode Emacs/Haskell lhs2tex.
03:24:41 <swiert> I've seen it in action, but never tried it myself.
03:24:48 <Zr40> well, Vim does know about HTML outside PHP blocks, so it should be possible to implement something similar for lhs
03:26:28 <kosmikus> swiert, matthew-_: yeah, I've had it working once, but not anymore
03:27:22 <dmhouse> There are things like mmm-mode and mumamo-mode for Emacs that allow you to use multiple major modes in a single buffer.
03:27:37 <matthew-_> mmm. I'm now having to spell check paragraph by paragraph with ispell-region. pita as emacs is utterly confused now.
03:27:57 <dmhouse> matthew-_: can't you use ispell-comments-and-strings?
03:28:59 <Zr40> matthew-_: I haven't tried them, but http://urchin.earth.li/~ian/vim/ looks useful
03:29:01 <lambdabot> Title: Index of /~ian/vim
03:29:56 <matthew-_> dmhouse: yeah, that's true, hadn't come across that. It does mean adding every latex command I use though.
03:30:17 <dmhouse> matthew-_: how does that differ from checking it paragraph by paragraph?
03:30:45 <matthew-_> dmhouse: well, I know which paras are code and which aren't
03:31:18 <Syzygy-> :t findIndices
03:31:19 <matthew-_> and I actually have sections of this file where neither ispell-buffer nor  ispell-comments-and-strings will check
03:31:20 <lambdabot> forall a. (a -> Bool) -> [a] -> [Int]
03:31:21 <dmhouse> matthew-_: when you say 'paragraph', I assumed you meant a paragraph full of LaTeX, i.e. a paragraph of the literate stuff.
03:31:27 <Zr40> matthew-_: actually, ignore that. It seems those are older than included with Vim itself.
03:31:59 <matthew-_> dmhouse: ok, I'm confused, what is ispell-comments-and-strings meant to do?
03:32:28 <dmhouse> matthew-_: check the comments and strings of your program. However, I think the literate sections of your file counts as a string (they're certainly rendered in the same face for me).
03:32:47 <Syzygy-> :t intersect
03:32:49 <lambdabot> forall a. (Eq a) => [a] -> [a] -> [a]
03:33:27 <matthew-_> dmhouse: are you in LaTeX mode or lhs mode?
03:33:56 <dmhouse> matthew-_: haskell-mode (so 'lhs', to answer your question).
03:33:59 <matthew-_> dmhouse: as I'm in LaTeX mode.
03:34:16 <matthew-_> right, so there lies the confusing. I want syntax highlighting for LaTeX more than for Haskell
03:34:21 <dmhouse> Right.
03:34:36 <dmhouse> Well I'd imagine the Haskell syntax to screw up the LaTeX highlighting.
03:35:29 <matthew-_> yep
03:35:35 <matthew-_> well, $ is the main problem
03:36:08 <dmhouse> It would be nice to get this working with something like mumamo-mode.
03:37:20 <matthew-_> indeed.
03:38:00 <matthew-_> on the other hand, the deadline is Friday and so I think I'll focus on writing the paper rather than improving emacs!
03:54:32 <ajudem_me> hi!
03:54:57 <ajudem_me> I've a type that can be either X | Y | Z
03:55:15 <ajudem_me> and in a function, I want to know what type it is...
03:55:19 <ajudem_me> how can I do that?
03:55:43 <integral> you mean you have: data SomeType = X | Y | Z?
03:55:48 <ajudem_me> yes
03:55:55 <integral> You can pattern match: func X = ...; func Y = ...; func Z = ...;
03:56:10 <dons> ?src Either
03:56:10 <lambdabot> Source not found. You speak an infinite deal of nothing
03:56:16 <dons> oh, that's a bit odd.
03:56:19 <integral> The X, Y, Z are *constructors* not *types*.
03:56:23 <integral> SomeType is the type.
03:56:47 <integral> (and func has type (exists x)(SomeType -> x)
03:56:49 <ajudem_me> integral... the "func" you wrote is "SomeType", right'
03:57:11 <ajudem_me> hmmm.. w8
03:58:22 <hpaste>  ajudem_me pasted "(no title)" at http://hpaste.org/260
03:58:29 <ajudem_me> like this...
04:01:11 <ajudem_me> integral, do you know?
04:02:22 <dmhouse> ajudem_me: that's fine.
04:02:25 <dmhouse> ajudem_me: all you need to do is this:
04:02:33 <dmhouse> function (X _) = True
04:02:38 <dmhouse> function _ = False
04:03:24 <dmhouse> Then whenever you pass it a value wrapped with the X constructor (i.e. that value is of type Instrucao), you'll get True back. Whenever you pass it something else, you'll get False.
04:03:38 <hpaste>  ajudem_me annotated "(no title)" with "(no title)" at http://hpaste.org/260#a1
04:04:21 <ajudem_me> dmhouse... sorry... I haven't explained quite well...
04:04:27 <dmhouse> ajudem_me: what do you mean by 'use its value', exactly?
04:04:52 <ttfh> what is the haskelly way of namin predicate functions? like ajudem_mes "function" for ex, should it be called "isFunction" or something? I rather like the scheme way, "function?"
04:05:13 <ajudem_me> data Statement = X Instruction | L Loop | C Condition
04:05:27 <dmhouse> ttfh: isFunction is about the best you can get. It'd be nice if '?' were allowed in identifiers, but they're not.
04:05:50 <ajudem_me> if Statement is a condition, then I want to call another function with the data in Condition...
04:06:07 <dmhouse> What does this other function do?
04:06:33 <ajudem_me> well... for example it can return a string
04:06:41 <ttfh> what does '?' do in haskell?
04:06:57 <dmhouse> ttfh: erm, nothing by default, but it's a valid name for a function.
04:07:02 <dmhouse> > let (?) = (+) in 2 ? 3
04:07:04 <lambdabot>  5
04:07:19 <dmhouse> ajudem_me: 'for example'? Remember that Haskell functions always have to return the same type.
04:07:28 <ajudem_me> yes... I know..
04:07:37 <seafoodX> It's also the syntax for implicit parameters right?
04:07:40 <ttfh> > let thing? _ = True
04:07:40 <lambdabot>  Parse error
04:07:49 <dmhouse> seafoodX: err, yeah, I think so.
04:08:04 <ttfh> hmm, ok so '?' is ok but not using it in an identifier?
04:08:11 <dmhouse> ttfh: function names must be either composed of [_-a-zA-Z0-9], or entirely symbols.
04:08:16 <dmhouse> seafoodX: yes.
04:08:37 <dmhouse> ajudem_me: okay, so it returns a Sting. What does it _do_, though? I think it'd be easier to help you if I had some kind of idea of what you were trying to achieve.
04:11:24 <hpaste>  ajudem_me annotated "(no title)" with "(no title)" at http://hpaste.org/260#a2
04:11:45 <ajudem_me> dmhouse, I think it's more explicit, now =)
04:12:32 <dmhouse> ajudem_me: firstly you pattern match on the _constructors_, not the _types_.
04:12:41 <dmhouse> Do you know what your datatype declaration means?
04:13:13 <ajudem_me> so I should use I and C, right
04:13:21 <ttfh> ajudem_me: is that portugese?
04:14:05 <ajudem_me> ttfh... yes (it's the 4st time someone asks it to me ;P)
04:14:12 <dmhouse> data Foo = I Int | B Bool means that you're declaring that any values like I 5, or I 17, or I 238903, are all of type Foo. 5, 17 and 238903 are themselves Ints, but wrap them in an I constructor (which you can later unwrap using pattern matching) and they become Foos. Same goes with Bools wrapped up in the B cosntructor.
04:15:22 <dmhouse> If you had a function bar :: Foo -> Bool, you could write it like this:
04:15:31 <dmhouse> bar (B b) = b
04:15:35 <dmhouse> bar (I _) = True
04:16:01 <ajudem_me> ok.. I got it ;)
04:16:02 <ajudem_me> tnks =)
04:16:05 <ttfh> ajudem_me: sorry about that :-)
04:16:15 <ajudem_me> ttfh... lol.. no problem at all ;)
04:16:17 <dmhouse> So that if you passed it a value wrapped up in a B constructor, bar would return the underlying Bool. If you passed it a value wrapped up in an I constructor, bar would return True.
04:16:35 <dmhouse> Sorry about ranting on like that but datatypes are pretty hard to understand so I though I'd add in some context. :)
04:17:08 <dmhouse> ajudem_me: okay, so you've said "If Stm is an Iterator then use its value and return true". Use its value in what way?
04:17:12 <ajudem_me> dmhouse, that's ok! I understanded it, and that's what matters! thks a lot =)
04:17:36 <dmhouse> If you always return True, then you're not really using the value of the function2 call.
04:17:54 <ajudem_me> yes.. It was just an example ;)
04:18:39 <dmhouse> Okay. Well have you got any more questions or did that little mini-lecture on datatypes clear things up?
04:18:58 <ajudem_me> I did understand ;)
04:19:07 <ajudem_me> I'm going back to work!
04:19:09 <ajudem_me> tnks =)
04:19:10 <ajudem_me> cya =)
04:19:22 <dmhouse> Enjoy. :)
04:53:22 <pitecus> Is there any particular reason why deriving Show, Ord etc doesnt work for existential types?
05:01:28 <dmhouse> pitecus: because a lot of the time it doesn't make sense.
05:01:37 <quicksilver> pitecus: Show would be feasible but simply hasn't been written
05:01:41 <quicksilver> pitecus: Ord would be rather hard :)
05:01:47 <dmhouse> pitecus: consider Eq. The compiler would have to write an instance like this:
05:01:58 <dmhouse> C a == C b = ...
05:02:18 <dmhouse> However, we don't know a and b are the same type, so it's not really reasonable to compare them for equality. Same goes for Ord.
05:03:50 <pitecus> Actually I need an Ord instance...
05:04:08 <dmhouse> pitecus: well, you can't define one :)
05:04:10 <pitecus> i guess using existentials isnt a good idea then
05:04:26 <dmhouse> I guess you have a type like the following: data OrdBox = forall a. Ord a => OB a
05:04:47 <pitecus> yep
05:05:06 <dmhouse> Then when you come to write your Ord instance: OB x `compare` OB y = ... You know that x and y are of types that instantiate Ord, but you don't know they're of the _same_ type. So you can't call compare on them or anything.
05:05:20 <pitecus> true
05:05:36 <ibid> you'd need Enum a => :)
05:05:38 <pitecus> i could compare show x to show y or somthing
05:06:06 <dmhouse> ibid: how would that help?
05:06:35 <ibid> dmhouse: compare fromEnum results
05:06:47 <ibid> dmhouse: it's like money, it makes everything comparable :)
05:06:55 <dmhouse> ?hoogle fromEnum
05:06:56 <lambdabot> Prelude.fromEnum :: Enum a => a -> Int
05:07:04 <dmhouse> Oh, I see. Clever.
05:07:09 <pitecus> ibid, but then some things are equal which yoiu dont wanna be equal no?
05:07:16 <dmhouse> pitecus: yes.
05:07:19 <pitecus> like False beging equal to 0
05:07:20 <ibid> pitecus: that depends on what you want to accomplish
05:07:27 <ibid> pitecus: and what the Enum instances are
05:07:45 * dmhouse goes for lunch
05:07:46 <pitecus> ibid, i want to put the existentials in a Map basically
05:07:49 <pitecus> as keys
05:07:58 <dmhouse> pitecus: ah, just declare a dummy instance then
05:08:00 <kfish> @where+ hogg http://www.kfish.org/software/hogg/
05:08:00 <lambdabot> Done.
05:08:05 <dmhouse> It doesn't really have to make any kind of sense.
05:08:44 <pitecus> dmhouse i still want (T False) to be a different key from (T 0)
05:10:25 <dmhouse> Hmm, I wonder if Map requires that the Ord instance be transitive.
05:10:41 <dmhouse> Because one could write instance Ord OrdBox where _ `compare` _ = GT
05:10:41 <ibid> probably does
05:24:29 <quicksilver> dmhouse: I'm quite sure it does, yes
05:24:36 <quicksilver> dmhouse: I imagine it requires it to be a total order, in fact
05:27:15 <ibid> well, it being a partial order would certainly break a lot of things
05:27:29 <ibid> as the only way to indicate undefinedness is ... undefined
05:27:52 <swiert> Can anyone think of a (Prelude) function that uses general recursion and can't do without it?
05:28:06 <dmhouse> ibid, Well, you could have class POrd p where pcompare :: p -> p -> Maybe Ordering
05:28:08 <swiert> I.e. not a fold.
05:28:21 <ibid> dmhouse: sure but w don't have one
05:28:28 <dmhouse> ibid, true.
05:28:28 <ibid> *we
05:28:33 <dblhelix> swiert: iterate?
05:29:25 <swiert> dblhelix: you can write it as an unfold.
05:29:33 <swiert> I should have been more specific.
05:29:43 <dblhelix> swiert: you're right
05:32:49 <swiert> (==) :: Eq a => [a] -> [a] -> Bool
05:33:03 <swiert> if the lists are identical and infinite.
05:34:33 <quicksilver> dmhouse: indeed, although what I really meant was 'not only transitive but also anti-symettric and reflexive'
05:36:32 <ski> http://groups.google.com/group/comp.lang.functional/msg/22ea87a1cb8abfb8  -- maybe somewhat relevant wrt existentials above
05:36:38 <lambdabot> http://tinyurl.com/2zjz4l
05:39:17 <hpaste>  benja_ pasted "working OrdBox using generics" at http://hpaste.org/261
05:40:21 <benja_> for values of different types, compares the string representation of the TypeReps
05:40:49 <quicksilver> benja_: why does that need Data and not merely Typeable?
05:41:25 <benja_> quicksilver: because dataTypeOf is in Data
05:41:34 <benja_> oh right, typeOf :-)
05:41:57 <benja_> so, only because I was confused :-)
05:42:00 <benja_> thanks
05:42:37 <hpaste>  benja_ annotated "working OrdBox using generics" with "use Typeable instead of Data (thanks, quicksilver)" at http://hpaste.org/261#a1
05:43:34 <benja_> I wonder why TypeRep doesn't have an Ord instance
05:43:44 <quicksilver> mkQ?
05:44:32 <benja_> hmm, Data.Typeable also has 'cast,' which I wasn't able to find in Data.Generics :)
05:44:50 <quicksilver> I'd use the build in compare instance for (,)
05:45:10 <quicksilver> so I'd compare (show . typeOf $ x , x) (show . typeOf $ y , y)
05:45:39 <benja_> quicksilver: x and y aren't necessarily of the same type (that's the point)
05:46:02 <benja_> so that would give you a type error
05:46:16 <quicksilver> ah
05:46:20 <quicksilver> good point that man :)
05:47:32 <benja_> that being what pitecus and dmhouse seem to have been struggling with, above :)
05:49:00 <benja_> this works: compare (show $ typeOf x, Just x) (show $ typeOf y, cast y)
05:49:49 <benja_> but is slightly less efficient because it shows and compares the typereps even if they're equal :)
05:51:00 <hpaste>  benja_ pasted "a simpler version, using 'cast'" at http://hpaste.org/262
05:51:46 <ski> @type \x y -> maybe (compare (show (typeOf x)) (show (typeOf y))) (compare x) (cast y)
05:51:48 <lambdabot> forall a a1. (Ord a, Typeable a, Typeable a1) => a -> a1 -> Ordering
05:52:30 <quicksilver> :t cast
05:52:32 <lambdabot> forall a b. (Typeable b, Typeable a) => a -> Maybe b
05:52:36 * quicksilver nods
05:52:58 <mauke> > cast 2.0 :: Float
05:52:59 <lambdabot>  Couldn't match expected type `Float'
05:53:05 <mauke> > cast 2.0 :: Maybe Float
05:53:07 <lambdabot>  Nothing
05:53:42 <quicksilver> > cast (2.0::Float) :: Maybe Float
05:53:43 <lambdabot>  Just 2.0
05:54:39 <opqdonut> > cast [] :: Maybe Int
05:54:40 <lambdabot>  Add a type signature
05:54:48 <opqdonut> > cast ([]::Int) :: Maybe Int
05:54:48 <lambdabot>  Couldn't match expected type `Int' against inferred type `[a]'
05:54:54 <opqdonut> > cast ([]::[Int]) :: Maybe Int
05:54:57 <lambdabot>  Nothing
05:55:01 <opqdonut> haha!
05:55:05 <benja_> :)
05:55:24 <TSC> > cast ([1] :: [Int]) :: Maybe Int
05:55:26 <lambdabot>  Nothing
05:55:35 <opqdonut> oh bummer
05:56:12 <opqdonut> > cast ([1,1] :: [Int]) :: Maybe Int -- maybe it takes the tail pointer?
05:56:14 <lambdabot>  Nothing
05:56:18 <opqdonut> no such luck
05:56:20 <Lemmih> > fmap head $ cast ([1] :: [Int]) :: Maybe Int
05:56:20 <benja_> it doesn't do conversions, it simply gives (Just x) if x is of the right type, and Nothing otherwise
05:56:21 <lambdabot>  Just 1
05:56:48 <opqdonut> benja_: ah, i thought it did a forced cast or something
05:56:52 <dons> yeah, its not a cast. its a type check with its context.
05:57:00 <opqdonut> ok
05:57:09 <opqdonut> is there an unsafeCast or something like that?
05:57:29 <benja_> unsafeCoerce
05:57:31 <dons> you can use it to move a type to a more specific type, (e.g. when unwrapping an existential)
05:57:35 <dons> fromMessage :: Message m => SomeMessage -> Maybe m
05:57:37 <dons> fromMessage (SomeMessage m) = cast m
05:57:40 <ski> you can build it with 'unsafePerformIO'
05:57:41 <dons> we use it for open data types in xmonad
05:57:58 <dons> data SomeMessage = forall a. Message a => SomeMessage a
05:58:02 <dons> class Typeable a => Message a
05:58:18 <opqdonut> :t unsafeCoerce
05:58:20 <lambdabot> Not in scope: `unsafeCoerce'
05:58:31 <dons> so you can hide a value in an existential, then conditionally deliver it to functions that accept things of that type. 'cast' does the test
05:58:47 <TSC> dons: So given a SomeMessage, you can check it against a few known messages and handle it if you know it, otherwise ignore it?
05:58:53 <dons> yep
05:59:04 <TSC> Mmm
05:59:23 <dons> so we can deliver events to extension modules, that can use or ignore them
05:59:32 <dons> and that can add their own extension values (i.e. new constructors) on the fly
05:59:55 <TSC> By adding them to the Message class?
06:00:09 <quicksilver> exactly
06:00:43 <dons> right. you add new 'constructors' to your open data type by specifying: instance  Message MyType
06:01:04 <dons> data Resize     = Shrink | Expand   deriving Typeable
06:01:04 <dons> instance Message Resize
06:01:16 <dons> for exapmle, adds a new event, to be handled by some layout
06:01:25 <TSC> So using cast (maybe with a pattern guard) is like pattern matching for an open data type
06:01:32 <dons> then cast will give us a Just x, if handed to a function taking Resizes
06:01:41 <dons> yeah, in a way
06:02:08 <TSC> Except it's a pretty simple "pattern" being matched
06:02:29 <quicksilver> you can also use rather cutely in a list comp
06:02:46 <quicksilver> [ x | Just x <- map cast mgs ]
06:03:03 <quicksilver> pulls out all the things of the 'right type' from that list of msgs
06:03:40 <benja_> I wish there were a good way to define the equivalent of Read for these open data types...
06:04:01 <quicksilver> not at all hard to write one
06:04:14 <quicksilver> if you believe that the show instance for TypeRep is 'stable'
06:04:50 <roconnor> I suspect that deforestation is important when using strict evalutaion.
06:05:09 <benja_> I mean, the problem is that you have to have a central function that has pointers to all the 'constructors' of the open type
06:06:04 <benja_> you can no longer extend the type by adding an instance declaration, you have to change declarations so that the central function has a pointer to the new constructor
06:06:25 <quicksilver> I don't think so, benja_
06:06:31 <quicksilver> I think generics gives you all that for free
06:06:53 <benja_> quicksilver: you'd have to have a way to cycle through the instances of a given class -- do you see such a way?
06:06:56 <benja_> if so, please show :)
06:07:08 <benja_> I wouldn't be at all unhappy to be proven wrong on this ;)
06:07:45 <quicksilver> can't you just use readConstr?
06:08:07 <Lemmih> benja_: HAppS is reading events of arbitrary types from disk.
06:08:28 <benja_> quicksilver: how do you obtain the DataType?
06:08:46 <benja_> Lemmih: oh, which module does that?
06:08:56 <quicksilver> benja_: you don't need to, per se
06:09:01 <quicksilver> :t readConstr
06:09:09 <lambdabot> Not in scope: `readConstr'
06:09:12 <benja_> readConstr :: DataType -> String -> Maybe Constr
06:09:19 <Lemmih> benja_: The trick is to not really do it.
06:09:20 <quicksilver> oh
06:10:48 <Lemmih> benja_: HAppS/MACID/Checkpoint.hs:91
06:10:56 <benja_> thanks :)
06:11:46 <Lemmih> (The code is quite unintelligible.)
06:12:38 <benja_> oh, but it uses the EvLoaders map, doesn't it?
06:12:50 <Lemmih> benja_: Indeed.
06:12:59 <benja_> that was the approach that I would like not to have to take ;)
06:13:12 <benja_> but believe you do have to take with Haskell
06:13:45 <benja_> or hmm. I may be guessing wrong how the map works
06:13:51 <benja_> (looks more closely)
06:13:59 <dons> hmm, usually you'd know what you're reading, and check the type reps as they come in, wouldn't you?
06:14:18 <dons> like the Data.Binary wrapper that tags types of each value, so we can check as we construct those values.
06:14:52 <quicksilver> dons: but he wants to do this with an open type
06:14:56 <benja_> dons: I mean when you have an open data type (implemented using existentials) like you mentioned, and you would like to have a function in a central place that can read values of the open type
06:14:59 <dons> ah ha
06:15:00 <quicksilver> dons: consider writing your messages to disk
06:15:12 <quicksilver> benja_: the key seems to be that there is no Read instance for Constr
06:15:14 <dons> yes, i see. existentials are much trickier beasts.
06:15:21 <quicksilver> benja_: I wonder if there is any good reason why there isn't
06:15:47 <dons> hmm. seems odd. could just be an oversight
06:15:56 <dons> (wasn't needed to the the SYB stuff...)
06:16:15 <quicksilver> benja_: and there isn'ta  read instance for TypeRep either
06:16:20 <quicksilver> benja_: (that would be another line of attack)
06:16:35 <dons> there'd be a haskell workshop paper in serialising open data types, in the various encodings of open data types we take
06:17:13 <dons> there's also another way to do full open data types with indexed type families. lotsa fun.
06:18:02 <Lemmih> Am I missing something or is what you're trying to do really evil?
06:18:31 <pitecus> benja_, quicksilver thanks for that Ord instance
06:18:59 <benja_> hm, I don't think having a read instance for constr and datatype would actually help
06:19:06 <benja_> pitecus: :)
06:19:20 <dons> Lemmih: i suspect so.
06:19:35 <quicksilver> benja_: I think it would help
06:19:41 <quicksilver> benja_: but, does gread not help?
06:20:09 <Lemmih> You want something like this, right: data Obj = forall x. (Show x, Read x) => Obj x; fn str = case Obj (read str) of Obj val -> print val
06:20:13 <benja_> the problem is that we want to go from a string to an existential data type encapsulating the object
06:20:51 <benja_> *somewhere* along the way the type system needs to know the type that we put *inside* the existential container
06:21:10 <dons> that seems hard, doesn't it.
06:21:17 <dons> serialising existentials
06:21:39 <dons> you certainly need Read/Show in the existential package
06:21:40 <benja_> and DataType and Constr aren't actually related, in the type system, to the type they represent
06:21:54 <dons> but how to pick the type. via reflection-y tricks.
06:22:11 <dons> right. somewhere you need to code in the type it must be. hmm. phantoms of some kind.
06:22:36 <benja_> yes, and I still think you either need to extend the compiler or build manually a master list that maps type names to an existential encapsulation of these type
06:22:39 <benja_> s
06:23:49 <benja_> it should suffice to have a (Map String Obj), where the values in the existential container are all 'undefined'
06:23:52 <igli> existential programming.. now i've heard it all ;)
06:26:36 <Lemmih> benja_: Why would that suffice?
06:29:13 <benja_> Lemmih: oread :: Map String Obj -> String -> String -> Obj
06:29:14 <benja_> oread m tag repr = case Map.lookup tag m of Just (Obj phantom) -> Obj (read repr `asTypeOf` phantom)
06:30:37 <dons> yeah, keep a type table
06:30:57 <dons> nice idea
06:31:38 <benja_> could construct the type table at the top of each module, next to the import/export section, and then have the 'main' function put the entire type table into an implicit parameter
06:32:27 <Lemmih> benja_: Is that code valid (Glasgow) Haskell?
06:32:40 <Lemmih> Ah, it is.
06:32:57 <dons> looks ok to me.
06:33:01 <benja_> I only tried after pasting it, but it turns out to be :)
06:33:05 * dons turns on brain -fglasgow-exts
06:33:41 <dons> implicit parameter, no! a type monad
06:34:41 <benja_> perhaps ... depends on how many places this is needed in :-)
06:35:00 <quicksilver> The thing is, I think there already *is* a table
06:35:07 <quicksilver> I think we just don't seem to have access to it
06:35:17 <quicksilver> I think derivign Data and Typeable mean the table is there
06:35:40 <benja_> quicksilver: no, SYB can be implemented without that much support from the compiler
06:35:58 <benja_> the SYB paper did make that point =)
06:36:43 <quicksilver> hmm
06:36:51 <benja_> what's required, iirc, is rank-2 types and a way to do type equality (which can be done manually, which is boring, or with some boilerplate generation code in the compiler)
06:36:58 * quicksilver nods
06:37:38 <quicksilver> ok, well let me just say that I think a suitable read instance for TypeRep or Constr would amount to the same thing
06:37:47 <quicksilver> it would, essentially, be the Map of which you speak
06:37:52 <dons> it would code in the lookup.
06:37:53 <quicksilver> disguised as a Read instance
06:39:22 <hpaste>  benja_ pasted "reading open data types through a type table, simple example" at http://hpaste.org/263
06:40:07 <benja_> quicksilver: I looked at the code for TypeRep and Constr, and, you see, it wouldn't
06:40:29 <benja_> because as I said above, neither of these is actually connected to the type they represent, in the type system
06:40:57 <SamB_XP> benja_: sure, in GHC that's true ;-)
06:41:10 <dons> i reckon you ought to start a thread on haskell-cafe@, something with a suitable subject to hook Oleg et al in.
06:41:21 <dons> i want to see the class associated types solution..
06:41:35 <SamB_XP> something about scantilly-clad types?
06:41:45 <dons> "... reading open data types ..."
06:41:55 <dons> find out what the generics guys have to say
06:42:14 <quicksilver> benja_: do 'fromConstr' and friends not connect the constr instances back into the type system?
06:42:20 <benja_> dons: hmm, ok
06:42:52 <benja_> quicksilver: no, *you* do it when you call them, by constraining their return type :)
06:43:09 <benja_> iiuc
06:46:47 <quicksilver> ah, I see what you mean
06:47:12 <quicksilver> there are no primitives which return generic functions
06:47:41 <ClaudiusMaximus> why doesn't this work as i expect it to?
06:47:42 <ClaudiusMaximus> > let showOrType x = case ((cast x)::((Typeable a, Show a) => Maybe a)) of { Nothing -> (("<")++).(++(">")) . show . typeOf $ x ; Just z -> show z } in (showOrType 1, showOrType "hello")
06:47:42 <lambdabot>  Parse error
06:47:49 <SamB_XP> what's a generic function?
06:48:14 <ClaudiusMaximus> oops
06:49:30 <benja_> ClaudiusMaximus: you're not constraining 'a' to be a particular type
06:49:34 <quicksilver> SamB_XP: a function with a type like (Data a => a) or so
06:49:44 <benja_> it's the same reason that (show $ read $ "7") doesn't work
06:50:13 <ClaudiusMaximus> benja_: ahh, interesting
06:51:32 <ClaudiusMaximus> benja_: so is there a way to say "i don't care what it is, i just care that i can do these particular operations?"
06:52:09 * ClaudiusMaximus reads back in the logs, seems it's been discussed further
06:53:33 <SamB_XP> quicksilver: that'd indeed by a very odd thing for a primitive to return
06:53:49 <quicksilver> SamB_XP: not for a primitve in the Data.Generics library, IMO
06:53:59 <quicksilver> but I think what benja_ has convinced me is that there would be a runtime cost
06:54:03 <quicksilver> and that's why they didn't do it
06:54:50 <benja_> quicksilver: but you don't need a primitive to return (Data a => a) ... what we need is something that returns an Obj, where data Obj = forall a. Data a => Obj a
06:55:26 <quicksilver> benja_: right, but that's the same thing, just with name :)
06:56:02 <benja_> when you return (Data a => a), when you write your function, 'a' is a fixed type, because the context in which your function is used fixes the type
06:56:14 <sjanssen> @keal
06:56:14 <lambdabot> i try make program called Glyph to do it but my script lang called T too slow. i invent T
06:56:53 <SamB_XP> what if you return (exists a. Data a => a)
06:58:05 <benja_> SamB_XP: is there a Haskell implementation that supports such a type?
06:58:11 <quicksilver> yes, you're right of course, benja_
06:58:18 <benja_> =)
06:58:23 <quicksilver> but that's also a good way to think of this problem
06:58:25 <SamB_XP> benja_: JohnMeacham gave me the impression that JHC supported naked existentials
06:58:32 <benja_> ok
06:58:37 <quicksilver> we have a fromConstr where the caller fixes the type
06:58:51 <quicksilver> and we want a fromConstr where the callee fixes the type
06:59:02 <benja_> SamB_XP: so if you have that, it would be the same as returning Obj, for the purposes of this discussion
06:59:12 <benja_> quicksilver: yep :)
06:59:30 <benja_> (by returning an existential type)
06:59:39 <SamB_XP> benja_: I guess so.
06:59:45 <SamB_XP> I missed where you defined Obj, somehow
06:59:48 <SamB_XP> before
07:00:16 <SamB_XP> I hates "forall" for existentials
07:00:30 <benja_> :)
07:00:51 <SamB> GHC should use the proper syntax
07:04:46 <quicksilver> if you add a new exists syntax you need to add new syntax to unwrap it, I believe?
07:05:00 <quicksilver> that's the advantage of the current setup, it just uses constructors which are already a feature
07:06:12 <ClaudiusMaximus> hmm  :t showOrType  ->  showOrType :: (Typeable a) => a -> [Char] ; seems to be missing a (Show a) constraint
07:08:31 <ClaudiusMaximus> nevermind, moving the (Show a) constraint onto the function definition doesn't fix it
07:13:14 <benja_> sent mail to haskell-cafe
07:13:35 <benja_> ClaudiusMaximus: what do you want showOrType to do?
07:14:26 <ClaudiusMaximus> benja_: act like lambdabot does when you tell it to evaluate something without a Show instance
07:14:30 <ClaudiusMaximus> > (+)
07:14:35 <lambdabot>  <Integer -> Integer -> Integer>
07:14:59 <ClaudiusMaximus> benja_: while also showing what does have a show instance
07:15:06 <benja_> hmm
07:15:08 <quicksilver> The problem is you can't express as a contraint (Show a or Typeable a)
07:15:14 <benja_> interesting ... I wonder if it's possible
07:15:16 <quicksilver> (only 'and')
07:15:49 <quicksilver> I think you can do with the type-class function extension in the 3rd boilerplate paper?
07:16:13 <quicksilver> but I didn't spend enough time to really understand that paper in detail
07:16:26 <benja_> > let showOrType :: Typeable a => a -> String; showOrType x = mkQ (show $ typeRep x) show x in showOrType 7
07:16:27 <lambdabot>   Not in scope: `typeRep'
07:16:44 <quicksilver> typeOf?
07:16:45 <benja_> > let showOrType :: Typeable a => a -> String; showOrType x = mkQ (show $ typeOf x) show x in showOrType 7
07:16:46 <lambdabot>   Not in scope: `mkQ'
07:17:15 <benja_> works in ghci
07:17:49 <ClaudiusMaximus> @index mkQ
07:17:49 <lambdabot> Data.Generics.Aliases, Data.Generics
07:18:26 <quicksilver> wow, it does
07:18:35 <quicksilver> mkQ does work quite how I expected then
07:18:39 * quicksilver ponders
07:18:49 <benja_> hmm, but it shows "[Char]" for strings, that can't be right
07:18:50 <quicksilver> I didn't think you could 'mkQ' to a type-class constrained type like that
07:19:11 <quicksilver> oh
07:19:14 <quicksilver> it's defaulting to Int
07:19:15 <quicksilver> I bet
07:19:16 <benja_> quicksilver: yeah, me neither, but I thought it would be worth a try :)
07:19:16 <quicksilver> :)
07:19:28 <quicksilver> I imagine it becomes an Int-mkQ
07:19:33 <quicksilver> so it will show only Ints
07:19:33 <benja_> hmm
07:19:46 <quicksilver> e.g. try 'Just 7'
07:20:00 <benja_> you seem to be right :-(
07:20:22 <quicksilver> I *think* lambdabot works by actually adding show instances
07:20:28 <quicksilver> rather than anything clever like this
07:21:12 <benja_> *I* think it works by using the show instance of Dynamic
07:21:14 <quicksilver> instance (Typeable a, Typeable b) => Show (a -> b) where show = show . typeOf
07:21:37 <quicksilver> > show (toDyn (1::Int))
07:21:39 <lambdabot>  "<<Int>>"
07:21:46 <quicksilver> then it would show that even for ints
07:21:48 <quicksilver> and it doesn't :)
07:22:00 <quicksilver> maybe it typechecks everything twice
07:22:04 <benja_> ok :)
07:22:05 <quicksilver> once as Show a => a
07:22:07 <quicksilver> and if that fails
07:22:23 <quicksilver> once more as Dynamic (with a toDyn in front)
07:22:36 <quicksilver> > \x -> x
07:22:37 <lambdabot>  Add a type signature
07:22:53 <quicksilver> > (\x -> x) :: forall a. a->a
07:22:53 <lambdabot>  Parse error
07:24:03 <drigz> is it defined that length [1..] will never return?
07:24:20 <drigz> could the compiler transform length x == 0 into null x?
07:25:16 <quicksilver> drigz: yes. No.
07:25:43 <quicksilver> drigz: hmm, that second No was a bit too emphatic. It could actually, but it doesn't.
07:26:07 <quicksilver> drigz: and it would break semantics in the way you point out
07:27:19 <drigz> quicksilver: ok, thanks
07:27:25 <ClaudiusMaximus> > (\x -> (null x, length x == 0)) (x : undefined)
07:27:26 <lambdabot>   Not in scope: `x'
07:27:30 <ClaudiusMaximus> > (\x -> (null x, length x == 0)) (1 : undefined)
07:27:32 <lambdabot>  Undefined
07:28:11 <quicksilver> drigz: however, you could imagine a different function which was safe to transform
07:28:18 <sjanssen> drigz: no, that isn't a valid transformation for a Haskell compiler to perform
07:28:18 <quicksilver> drigz: like, maybe, lengthAtMost
07:28:24 <quicksilver> (I'm not sure why you'd want to)
07:28:42 <sjanssen> @src genericLength
07:28:42 <lambdabot> genericLength []    = 0
07:28:43 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:29:09 <sjanssen> now, the compiler can optimize that one with the right Num instance
07:29:15 <drigz> quicksilver: it could be a lot faster
07:29:30 <drigz> because it doesn't seem unreasonably to write length xs < 10
07:29:38 <drigz> but if xs is very long, it will be slow
07:29:45 <quicksilver> so, write lengthAtMost 10
07:29:52 * quicksilver shrugs
07:30:04 <mdmkolbe|work> sjanssen: by that you mean a num that has information that is it definately not zero but with out finishing the complete addition?
07:30:04 <quicksilver> length does what it says it does
07:30:36 <sjanssen> mdmkolbe|work: yes.  Something like data Nat = Zero | Succ Nat
07:30:44 <mdmkolbe|work> @src Num
07:30:45 <lambdabot> class  (Eq a, Show a) => Num a  where
07:30:45 <lambdabot>     (+), (-), (*)           :: a -> a -> a
07:30:45 <lambdabot>     negate, abs, signum     :: a -> a
07:30:45 <lambdabot>     fromInteger             :: Integer -> a
07:30:56 <mdmkolbe|work> sjanssen: wouldn't (-) be a problem for that?
07:31:00 <mdmkolbe|work> @type 1
07:31:02 <lambdabot> forall t. (Num t) => t
07:31:35 <mdmkolbe|work> sjanssen: not to mention 'negate'
07:32:04 <sjanssen> Zero - (Succ _) = undefined; (Succ n) - (Succ m) = n - m
07:32:38 <DRMacIver> Hm.
07:32:46 <sjanssen> mdmkolbe|work: we already have types with strange/undefined behavior with negate/underflow
07:33:46 <DRMacIver> I wonder if one could arrange things so that something like length foo >= 3 only forced evaluation of the first 3 elements of the list.
07:34:27 <DRMacIver> You could probably do it with genericLength and an appropriate Num instance for peano arithmetic.
07:34:48 <mdmkolbe|work> sjanssen: true. but I think those tricks are only fair if the results are still compatable with whatever number laws are in force.  e.g. abs (negate n) === n would be a problem for this
07:35:21 <mdmkolbe|work> DRMacIver: like what sjanssen did? yes, it would work for free.
07:35:49 <DRMacIver> mdmkolbe|work: Oh, I actually didn't notice that sjanssen just brought up the same thing. Heh
07:36:27 * DRMacIver was thinking about something he's implementing at the moment and that that would be useful there.
07:37:00 <quicksilver> it's mostly useful when that information is available statically (at compile time)
07:37:05 <quicksilver> and then the compiler can do it
07:37:11 <quicksilver> (presumably you don't mind slow compilation)
07:37:23 <quicksilver> actually storing numbers in peano form at runtime is not generally very shiny :)
07:37:39 <DRMacIver> Yeah
07:38:09 <quicksilver> although haskell compilation of large programs is already pretty slow
07:38:21 <quicksilver> I don't know how much slower we want to make it, with today's hardware :)
07:39:08 <sjanssen> mdmkolbe|work: there are no number laws in force
07:39:44 <sjanssen> @check \x -> (x :: Float) == x + 1 - 1
07:39:48 <lambdabot>  Falsifiable, after 25 tests: 1.3333334
07:40:03 <SamB> @src genericLength
07:40:03 <lambdabot> genericLength []    = 0
07:40:03 <lambdabot> genericLength (_:l) = 1 + genericLength l
07:40:23 <SamB> yup, that'd work great
07:40:30 <quicksilver> > abs (negate (1::Word8))
07:40:31 <mdmkolbe|work> sjanssen: true ... unfortunately so true
07:40:32 <lambdabot>  255
07:40:44 <quicksilver> mdmkolbe|work: your law i already borken :)
07:40:56 <geezusfreeek> literate haskell and haddock are both forms of documentation, so why am i reading that they are orthogonal?
07:41:17 <quicksilver> a.k.a. we already have all-positive Num instances
07:41:38 <SamB> geezusfreeek: well, you do use them in different ways...
07:41:47 <geezusfreeek> i guess my question is, what are good practices for each of these?
07:41:57 <SamB> haddock is used for API documentation
07:42:10 <SamB> literate haskell works better for tutorials and things
07:42:26 <sjanssen> geezusfreeek: haddock is used as API/reference documentation
07:42:32 <sjanssen> literate Haskell is more prose style -- it generally documents the implementation itself
07:42:38 <geezusfreeek> ah, okay
07:43:15 <geezusfreeek> so in generalâ¦ haddock -> interface; literate haskell -> implementation ?
07:43:34 <lumi> Hi, where could I find out how to use the debugger?
07:44:02 <lumi> Or, how I even find it
07:44:31 <mdmkolbe|work> geezusfreeek: yeah.  e.g. the library sources are documented with hadoc.  I can't think of a good example of using lhs off hand
07:44:33 <mdmkolbe|work> @docs
07:44:34 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
07:45:08 <lumi> For GHC 6.7 which I built a week ago from darcs
07:45:24 <geezusfreeek> okay, thanks everybody
07:46:13 <lumi> Alrernately, how do I get a stack trace of some sort?
07:46:37 <lumi> On second thought that's not useful
07:47:38 <mdmkolbe|work> lumi: I'm not aware of any good documentation, but there is a paper in the works.  (It would be due out at the end of September.) Some posts to the haskell lists (unfortunately I don't remember which one) have scraps of information.
07:48:07 <quicksilver> geezusfreeek: literate haskell is used for letters and papers which contain haskell code
07:48:20 <quicksilver> geezusfreeek: one example is most of Oleg's posting to the haskell mailing lists
07:48:41 <masklinn> quicksilver, posts in blogs and stuff like that too
07:49:03 <quicksilver> yup
07:49:13 <quicksilver> letters, papers, and things in between :)
07:49:18 <geezusfreeek> but it's not used so much just for typical projects?
07:49:28 <masklinn> anywhere you need to intersperse haskell code and plain text in fact
07:51:28 <lumi> mdmkolbe|work: Thanks, I'll keep at it, then; I thought there might be something about it already
07:51:52 <mdmkolbe|work> geezusfreeek: parts of GHC are written in litterate style which sometimes helps when parts of the code need longish explanations
07:53:48 <ClaudiusMaximus> > let typefu x f = case y of { Nothing -> ("<"++) . (++">") . show . typeOf $ x ; Just z -> f z } where y = cast x in (typefu "hello" (show::String->String), typefu "hello" (show::Integer->String))
07:53:49 <lambdabot>  ("\"hello\"","<[Char]>")
07:54:37 <ClaudiusMaximus> not quite what i wanted, but it made me realize what i wanted was not what i needed :)
07:56:26 <SamB> @hoogle (a -> Bool) -> [a] -> ([a], [a])
07:56:27 <lambdabot> List.partition :: (a -> Bool) -> [a] -> ([a], [a])
07:56:27 <lambdabot> Prelude.break :: (a -> Bool) -> [a] -> ([a], [a])
07:56:27 <lambdabot> Prelude.span :: (a -> Bool) -> [a] -> ([a], [a])
07:57:04 <SamB> > break (=='\n') "Hello\nWorld"
07:57:05 <lambdabot>  ("Hello","\nWorld")
07:57:10 <SamB> > span (/='\n') "Hello\nWorld"
07:57:11 <lambdabot>  ("Hello","\nWorld")
07:57:32 <SamB> so span f = break (not . f) and vice versa...
07:58:23 <mdmkolbe|work> @type break
07:58:25 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:58:26 <mdmkolbe|work> @type span
07:58:28 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
07:58:36 <mdmkolbe|work> @pl break (not . f)
07:58:37 <lambdabot> break (not . f)
07:58:42 <mdmkolbe|work> @src break
07:58:43 <lambdabot> break p =  span (not . p)
08:02:26 <quicksilver> mdmkolbe|work: LB doesn't know all the equations :)
08:17:14 <bos> CosmicRay: ping
08:17:19 <bos> @seen CosmicRay
08:17:19 <lambdabot> CosmicRay is in #haskell-blah, #darcs and #haskell. I don't know when CosmicRay last spoke.
08:17:26 <bos> grm.
08:35:02 <CosmicRay> hi bos
08:37:54 <bos> CosmicRay: getting the build unwedged ATM
08:40:20 <CosmicRay> bos: great, thanks
08:44:24 <quicksilver> which of the haskell XML solutions is best suited to 'tranforming' some XML whilst preserving whitespace and comments? i.e. minimal changes?
08:46:22 <SamB> quicksilver: what sort of transformations do you have in mind?
08:46:47 <quicksilver> SamB: well, e.g. "add an attribute bar to every 'frob' which already has the attribute 'foo' with value 'apple'"
08:47:22 <quicksilver> and in fact, I'm lying when I say XML, because I really mean HTML, and ideally I'd like the tool not to enforce wellformedness more than it needs to for the task at hand
08:49:14 <gogonkt1> I darcs under windows xp, I got a error below, what's wrong?
08:49:15 <gogonkt1> D:\bot\lunaluna>darcs changes
08:49:19 <gogonkt1> Wed Jun 13 23:34:55 [_\d6_][_\d0_][_\b9_][_\fa_][_\b1_][_\ea_][_\d7_][_\bc_][_\c
08:49:19 <gogonkt1> a_][_\b1_][_\bc_][_\e4_] 2007  gogonkt@gmail.com
08:49:20 <gogonkt1>   * update ReadMe
08:49:24 <gogonkt1> Wed Jun 13 23:17:01 [_\d6_][_\d0_][_\b9_][_\fa_][_\b1_][_\ea_][_\d7_][_\bc_][_\c
08:49:24 <gogonkt1> a_][_\b1_][_\bc_][_\e4_] 2007  gogonkt@gmail.com
08:49:25 <gogonkt1>   * Initial import.
08:49:58 <LoganCapaldo> gogonkt1: please don't paste so many lines in channel
08:50:08 <SamB> quicksilver: ... you don't want to enforce well-formedness?
08:50:26 <quicksilver> SamB: no, because the files might be fragments
08:50:28 <SamB> what definition of well-formedniess are you using?
08:50:30 <gogonkt1> LoganCapaldo: sorry
08:50:38 <SamB> maybe you mean "validity"?
08:50:40 <quicksilver> SamB: so a file might open a tag which is closed in another file
08:50:42 <LoganCapaldo> gogonkt1: also i think you want to ask in #darcs
08:50:48 <SamB> quicksilver: ... ewwwww
08:50:59 <SamB> I don't think you'll find anything like that pre-build :-(
08:51:11 <gogonkt1> nice
08:51:12 <SamB> er. s/build/built/
08:51:39 <byorgey> quicksilver: easy.  Just implement a general AI, then explain to it what you want =)
08:52:34 <SamB> quicksilver: anyway, I'm pretty sure I haven't heard of anything that represents HTML in such a way that it remembers exactly how each tag looked. maybe you could do it for XML tags -- they're more regular...
08:55:24 <nomeata> Hi
08:55:27 <nomeata> Greetings from DebCamp
08:55:34 <nomeata> you are on the projector in a BoF about haskell
08:55:40 <quicksilver> SamB: hmm, nod, thanks
08:55:40 <nomeata> and wer are saying how nice the ommunity is
08:55:53 <byorgey> hello DebCamp!
08:55:57 <quicksilver> SamB: funnily enough the main reason I don't want to mess with whitespace is that I want the 'diff' to look sensible
08:55:59 <lispy> it is a nice ommunity
08:56:06 * LoganCapaldo waves
08:56:20 <quicksilver> SamB: suppose you change all foos to bars, and then commit it to darcs, or bzr, or whatever
08:56:20 <SamB> quicksilver: it probably wouldn't be too hard to make something that does what you want, though.
08:56:44 <quicksilver> SamB: if your program canonicalised the whitespace as it went then the diff won't look sensible
08:56:57 <quicksilver> (I didn't explain that very well but I'm sure you see what I mean)
08:57:33 <LoganCapaldo> quicksilver: perhaps canonicalize the current file's whitespace before any changes
08:57:36 <LoganCapaldo> commit that
08:57:41 <LoganCapaldo> and then do your transform
08:57:43 <quicksilver> yeah, that's certainly one option
08:57:56 <quicksilver> as long as the canonicalisation isn't really unpleasant to look at 'by hand'
08:58:04 <quicksilver> (given that these files are edited by hand sometimes too)
08:58:47 <byorgey> quicksilver: SamB is right, depending on your exact needs I wouldn't think it would be too hard to roll your own -- parse into a stream of whitespace and tags, transform the tags as required, then write back out
08:59:11 <sieni> dt
08:59:13 <sieni> oopos
08:59:24 <byorgey> quicksilver: especially if the transforms don't depend very much on the structure
08:59:46 <sphynx> hi all
09:00:27 <sphynx> I've written parser of centericq history (centericq is console ICQ client)
09:00:39 <sphynx> it looks pretty, but works too slow
09:00:44 <quicksilver> byorgey: I don't have a specific problem in mind, just knowledge of the general problem that arise when I need to factor a large website conisting of lots of HTML in lots of files
09:01:03 <quicksilver> byorgey: sometimes I want to write 'xpath-style' selectors to identify the bits to change
09:01:06 <byorgey> quicksilver: hm, I see
09:01:07 <quicksilver> byorgey: or 'css-style'
09:01:16 <quicksilver> byorgey: s/factor/refactor/, btw
09:01:23 <byorgey> quicksilver: well, that's harder then =)
09:01:24 <sphynx> I'm searching  ways of speeding it up, could you please take a look?
09:01:24 <SamB> quicksilver: well, if you keep your files well-formed, you'll be fine
09:01:34 <quicksilver> SamB: it's hard to keep a 'header' file reformed
09:01:40 <SamB> hmm?
09:01:50 <SamB> you could use some kind of templates
09:01:54 <byorgey> sphynx: sure, paste your code on hpaste
09:01:57 <byorgey> @paste
09:01:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
09:02:06 <quicksilver> SamB: the 'header' tends to contain "<html><body><div class="content">"
09:02:15 <quicksilver> SamB: I do use templates, and this is the problem :)
09:02:28 <quicksilver> SamB: then the footer closes those tags which were opened by the header...
09:02:37 <quicksilver> SamB: so neither is wellformed, independently
09:03:08 <quicksilver> SamB: the output is then header + content + footer
09:03:14 <quicksilver> SamB: although real pages are much more complex than that
09:03:20 <quicksilver> SamB: perhaps including 15-20 files
09:03:31 <quicksilver> although, actually, they are *mostly* well-formed, I think
09:05:16 <Saizan> ?docs Control.Concurrent
09:05:17 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
09:05:26 <hpaste>  sphynx pasted "CICQ history parser" at http://hpaste.org/264
09:05:57 <sphynx> byorgey: done
09:06:34 <sphynx> it takes 3.5 seconds for parsing ~3 megabyte history file
09:08:45 <byorgey> sphynx: hm, I don't see any obvious reasons why it would be slow
09:08:51 <byorgey> sphynx: have you tried profiling?
09:09:01 <SamB> quicksilver: maybe you should use XML with placeholder tags
09:09:22 <sphynx> byorgey: I don't know, maybe it is usual speed of parsec
09:09:23 <Lemmih> sphynx: How about using bytestrings and a lexer?
09:10:03 <sphynx> Lemmih: you mean Lexer from Parsec?
09:10:13 <quicksilver> 3.5 sec for parsing 3 meg isn't really very slow, IMO
09:10:21 <quicksilver> although sure, you'd like it to be faster :)
09:10:22 <byorgey> sphynx: could be, I've never used Parsec for something that large
09:10:50 <Lemmih> sphynx: No.
09:11:01 <sphynx> I need to parse ~100 of history files, so 3*100 will be 300 seconds )
09:12:05 <sphynx> quicksilver: BTW, Hugs gives up on 3 mb file and prints some error related to garbage collecting
09:12:20 <sphynx> but GHC works much faster
09:12:43 <Lemmih> sphynx: Do you some test input available online?
09:12:48 <SamB> line "<html xmlns:t="http://my-domain.net/templates/1.0"><body><div class="content"><t:placeholder name="body"></div></body></html>
09:13:00 <SamB> er. s/line/like
09:13:10 <sphynx> Lemmih: I will provide it for you. One second
09:13:18 <SamB> (you could output HTML fine afterwards)
09:13:58 <LoganCapaldo> Are GHC / whathaveyou regexps faster than Parsec?
09:14:06 <SamB> "faster"?
09:14:14 <LoganCapaldo> Cause it looks like a regular language to I
09:14:17 <quicksilver> SamB: true, true
09:14:31 <emu> regular languages are less complex to parse sure
09:14:44 <Vulpyne> LoganCapaldo: It's calls to a library in C code, so probably.
09:14:45 <quicksilver> sphynx: did you compile with -O2 ?
09:15:02 <LoganCapaldo> So that might be an option
09:15:08 <emu> LoganCapaldo: use regex-tdfa i think, not the builtin one which sucks because it calls a crappy C lib
09:15:08 <HairyDude> anyone here using QuickCheck on Ubuntu?
09:15:15 <byorgey> HairyDude: I am, why?
09:15:29 <HairyDude> I've installed libghc6-quickcheck-dev but I can't import QuickCheck
09:15:54 <Baughn> HairyDude: How are you compiling? You know to use -package or --make?
09:15:57 <sphynx> quicksilver: no, I will try
09:16:04 <sphynx> Lemmih: http://horna.org.ua/misc/history.his
09:16:11 <HairyDude> Baughn: with ghci?
09:16:29 <byorgey> HairyDude: I assume you did import Test.QuickCheck, not just import QuickCheck?
09:16:45 <HairyDude> byorgey: ah, that's not obvious from the docs
09:17:01 <HairyDude> byorgey: it says "import module QuickCheck" not "import module Test.QuickCheck"
09:17:08 <byorgey> HairyDude: yeah, QC doesn't have much in the way of docs... =P
09:17:15 <Baughn> On the note of ghci, anyone know how to make it handle linker scripts?
09:17:29 <byorgey> HairyDude: you have to just read the original paper about it
09:17:32 <HairyDude> byorgey: thanks, works now :)
09:17:38 <Baughn> I've got a number of .so's that work fine with ghc, but not with ghci due to them being scripts
09:17:42 <byorgey> HairyDude: np =)
09:17:53 <HairyDude> byorgey: bah, bloody academics ;)
09:18:20 <peter_12> haskell, erlang, ocaml, which to learn first?
09:18:31 <peter_12> all three are getting press
09:18:43 <osfameron> I'm going with Haskell then Erlang
09:18:52 <byorgey> peter_12: Haskell, obviously ;)
09:19:00 <SamB> Baughn: ... they ARE linker scripts?
09:19:00 <peter_12> well obviously
09:19:01 <Baughn> peter_12: Haskell is lazy and monadic, the others are not. If you want novelty (learning more), definitely haskell.
09:19:07 <ari> I don't understand why people ask questions like that on #haskell
09:19:07 <Baughn> SamB: Yes
09:19:12 <arcatan> peter_12: our answers might be bit biased
09:19:19 <Baughn> SamB: Gentoo does that sort of thing a lot
09:19:58 <arcatan> Erlang is really easy to pick up, if you understand tail recursion and non-mutable variables don't feel spooky
09:20:04 <SamB> Baughn: ... how does that ever work?
09:20:30 <byorgey> ari: well, if e.g. everyone in #haskell said "don't learn haskell first", I suppose that would be very useful information
09:20:34 <osfameron> people say that Ocaml is blindingly fast, so probably worth picking up once you really know FP but are having issues with performance
09:20:36 * SamB does not think ld.so can read linker scripts
09:20:50 <daniel_larsson> SamB: it's libtool, not ld that reads them, afaik
09:20:52 <Baughn> SamB: It doesn't need to. Here, have a paste.
09:21:20 <peter_12> osfameron: is Haskell known to be quite slow?
09:21:32 <Baughn> SamB: http://rafb.net/p/LUdI8092.html
09:21:34 <lambdabot> Title: Nopaste - No description
09:21:41 <arcatan> it's not that slow. most of time it's fast enough.
09:22:06 <Baughn> SamB: ld reads the script, and inserts a link to /lib64/libreadline.so instead
09:22:10 <osfameron> peter_12: I don't think so, but Ocaml is touted as being really fast
09:22:17 <peter_12> ahh
09:22:26 <byorgey> peter_12: it can be pretty fast, but sometimes figuring out how to make it so can be pretty arcane.
09:22:29 <Baughn> SamB: That's fine for ld, and this is a simple case.. some of them link to /multiple/ libraries, in quite complex ways
09:22:31 <arcatan> but if you really need the performance, then some other language might be better
09:22:33 <sphynx> how should I compile program which uses Parsec?
09:22:38 <osfameron> peter_12: http://wagerlabs.com/ has some really interesting comparisons on these 3 languages
09:22:40 <lambdabot> Title: Tenerife Skunkworks Trading & Technology
09:22:41 <sjanssen> sphynx: ghc --make
09:22:49 <SamB> Baughn: you don't like your linker scripts highlighted as haskell?
09:22:54 <sphynx> ghc --make cicq.hs produces only .o and .hi files :(
09:23:02 <Baughn> SamB: Didn't remember the address
09:23:03 <osfameron> unlike me, he's actually taken the time to implement real things in all 3 languages, so he's not just talking out of his arse
09:23:18 <Baughn> SamB: The upshot is that compiling with ghc works fine, but ghci refuses to work on grounds of text files not being ELF files
09:23:26 <peter_12> osfameron: thanks
09:23:45 <SamB> Baughn: um... so... like...
09:23:52 <SamB> "doctor, it hurts when I do this"?
09:23:57 <sjanssen> sphynx: are you sure?  ghc --make file.hs should produce an executable if there's a main function
09:24:03 <Baughn> SamB: You're telling me not to use ghci?
09:24:39 <SamB> Baughn: I was thinking more of Gentoo, actually
09:25:04 <Baughn> SamB: You're probably right, but that won't help the other people who use it
09:25:26 <SamB> Baughn: what do you wish would happen?
09:25:44 <sphynx> sjanssen: my parser is here: http://hpaste.org/264
09:25:51 <sphynx> sjanssen: it really contains main
09:26:09 <sjanssen> sphynx: compile with -main-is CicqParser
09:26:11 <LoganCapaldo> sphynx: main has to be in module Main
09:26:18 <LoganCapaldo> or I guess that works too :)
09:26:27 <Baughn> SamB: The sane thing would be if gentoo made them synlinks instead. That aside, it'd be nice if ghci parsed linker scripts and followed their instructions, the way ghc makes ld do.
09:26:30 * LoganCapaldo makes a mental note of  -main-is
09:26:38 <sphynx> oh, I forgot abt this, thanks!
09:26:47 <sjanssen> sphynx: Haskell '98 says that the main function must be in a module called Main (or, equivalently, in a module with no name)
09:26:50 <SamB> Baughn: does GHC do that on purpose, or does it just happen?
09:27:00 <Baughn> SamB: It happens because ghc uses ld for linking
09:27:03 <SamB> can dlopen open them?
09:27:07 <Baughn> No
09:27:12 <sphynx> sjanssen: Yeah, thanks!
09:27:37 <SamB> Baughn: are all the scripts that short?
09:27:49 <Baughn> SamB: Also no. Most of them are, but a few do more complex things
09:27:55 * Baughn tries to find one
09:29:56 <Baughn> SamB: Well, the most complex is probably GROUP ( /lib64/libpthread.so.0 /usr/lib64/libpthread_nonshared.a )
09:30:16 <Baughn> SamB: It's not a lot, but it would require dlopening a .a, unfortunately
09:30:37 <Baughn> SamB: (There are a few more like that. Some ODBC thingies, notably.
09:31:02 <sphynx> quicksilver: Compiling with -O2 gives ~0.5s difference
09:31:36 <byorgey> sphynx: well, that's something at least!
09:32:41 <sphynx> so now it works for ~2.8-3.0 s
09:33:23 <sphynx> Lemmih: did you get my sample history file?
09:38:14 <peter_12> osfameron: so that guy ended up choosing OCaml. Interesting
09:38:57 <sphynx> could happy-generated parsers be quicker than that my parsec parser?
09:39:55 <sjanssen> sphynx: most likely
09:40:04 <LoganCapaldo> sphynx: Talking out of my butt I suspect a happy parser could be quicker. the grammar is pretty simple, I think you could try it out pretty quickly
09:41:12 <sphynx> LoganCapaldo: I haven't worked with happy yet, but read earlier some basic article about it
09:41:31 <bos> happy will almost certainly be faster. especially if you use bytestrings.
09:41:41 <sjanssen> sphynx: you might consider parsing this by hand, anyway
09:41:51 <bos> it will also detect ambiguities in your grammar, which parsec can't do.
09:41:52 <sphynx> bos: Happy uses BS'es?
09:42:04 <sjanssen> a simple combination of unlines and some recursion should work
09:42:24 <bos> sphynx: there's a flag to make it do so, i believe
09:42:33 <sphynx> sjanssen: Yeah, then I can use ByteString and it should work faster?
09:43:16 <sphynx> It seems that I need to do two another variants: with happy and by hand
09:43:42 <bos> mind you, i can't find the alleged flag in the --help output
09:43:47 <sjanssen> sphynx: yeah, then you could use ByteString
09:43:49 <sphynx> ?where happy
09:43:49 <lambdabot> http://www.haskell.org/happy/
09:43:51 <bos> so i could be smoking crack
09:44:13 <sphynx> bos: :) ok
09:44:15 <sjanssen> sphynx: a custom parser is almost certainly the fastest in this case (and probably about as simple as happy/parsec)
09:44:24 <dcoutts__> bos: actually, it's alex that can use BS
09:44:39 <dcoutts__> bos: and iirc it's only in the darcs version of alex
09:44:42 <sphynx> BTW, some project of Google Summer code will translate Parsec to use ByteStrin, am I right?
09:45:45 <sjanssen> happy has custom input support IIRC
09:46:00 <sjanssen> perhaps that's just alex
09:46:15 <SamB> sjanssen: happy can use all manner of lexers
09:46:29 <bos> sphynx: no, that proposal didn't make it, iirc
09:46:39 <bos> dcoutts__: thanks
09:46:50 <SamB> which are easy to make with alex
09:47:46 <SamB> they dovetail nicely, but seem like works fine without the other as well
09:48:02 <SamB> s/but seem like/but each seems like it/
09:48:46 <SamB> I'm fairly certain that this is due to using Haskell ;-)
09:48:55 <SimonRC> hmm
09:49:55 <SimonRC> Is it possible that you can use immutability of datastructures to make GC easier?
09:50:08 <SamB> SimonRC: of course
09:50:29 <SimonRC> allowing it to be done in a separate thread?
09:50:56 <SimonRC> If you keep your mutable stuff (including optimisations) on one heap and your immutable stuff on another...
09:51:04 <SamB> dunno if it helps much with that or not
09:51:21 <SimonRC> the task of scanning the immutable stuff is not tarribly urgent
09:51:41 <SamB> anyway, the point being that the GC doesn't need to scan immutable objects for pointers to younger generations
09:51:43 <SimonRC> if you are slow about it, you will just be more conservative
09:51:48 <SimonRC> SamB: yes
09:52:21 <ndm> SimonRC: remember laziness is mutability on steroids
09:52:23 <SimonRC> The allocation system can just increase a pointer, in fact.
09:52:38 <SimonRC> ndm: yeah, hence "mutable stuff (including optimisations)"
09:52:39 <SamB> I think GHC keeps a list of objects in each generation that might contain pointers to younger generations?
09:53:11 <SimonRC> i.e. the mutable ones?
09:53:42 <SamB> well, the ones that might have been mutated, at least
09:53:47 <SimonRC> but a thunk will only replace itself by an object that contains data that was allocated by running the thunk, or was reachable from the thunk
09:53:54 <SamB> (there was some talk about some kind of write barrier for arrays)
09:54:40 <SamB> SimonRC: that's enough to have to scan the new object
09:54:57 <emu> supposedly 6.6+ deals with arrays and GC better
09:55:22 <SamB> emu: so they have a write barrier now?>
09:55:43 <SimonRC> SamB: no rescan needed if the GC considers the pointers that thunk knows about to be referenced by it
09:55:51 <SimonRC> yes you might be a bit conservative...
09:56:15 <SamB> SimonRC: um, but the thunk's code most likely did some allocation
09:57:05 <SimonRC> SamB: ah, good poitn
09:57:26 <SimonRC> you would have to scan-as-you-allocated or something
09:57:57 <SamB> I think it'd be faster to scan whatever the thunk is replaced in memory with...
09:58:21 <SamB> and probably work better too...
09:58:43 <SamB> anyway, a write barrier on thunks is easy
09:59:01 <SamB> references and byte arrays are a bit trickier
09:59:45 <HairyDude> hmm, Control.Monad.State exports fix... that's handy
10:01:47 <SimonRC> SamB: mybe you can put them on a seperate heap
10:02:03 <SamB> SimonRC: how will that help?
10:02:04 <SimonRC> it is not unreasonable that your program gets a bit slower if you have lots of mutable references
10:02:13 <oerjan> HairyDude: well for something that "should" have been in the Prelude...
10:02:26 <HairyDude> yes :)
10:02:28 <SamB> you still need to know what objects in, say, the nursery they reference
10:02:38 <HairyDude> oerjan: why "should"?
10:02:38 <SimonRC> The GC can be more careful when scanning the mutable things, by locking something before scanning them
10:02:49 <oerjan> ok, _should_ then
10:03:11 <SamB> SimonRC: I'm not certain the GC can get away with not locking the immutable things...
10:03:41 <oerjan> HairyDude: because the limits are always fuzzy
10:04:30 <SimonRC> a thunk is usually an array of pointers, right?  The function pointer followed by some dat only it understands
10:05:05 <SimonRC> a GC can just treat a thunk as a structure...
10:05:36 <SimonRC> ah, wait, the GC will have to note the position that alloction had got up to before when the scan started...
10:06:23 <SimonRC> then it assumes that any object newer than that point *might* have been allocated by a thunk running while the scan was taking place, so should be ignored until the next scan
10:06:59 <SimonRC> this is a bit more complicted that I thought
10:07:11 <SimonRC> but not too much
10:07:29 <SamB> A thunk is just like an immutable object, until it gets replaced with a new object (which might just say "look over there instead")
10:08:13 <LoganCapaldo> @hoogle Regex -> String -> ([String] -> c) -> [c]
10:08:18 <oerjan> SamB: so is a mutable object
10:08:37 <SimonRC> but the new object always keeps alive a subset of: the objects the thunk kept alive + objects that were allocated since you last looked at the thunk
10:08:50 <SamB> oerjan: except those get changed again and again
10:09:14 <SamB> SimonRC: yeah, but lots of objects could have been allocated since then
10:09:15 <SimonRC> a thunk is a mutable object with handy invariants in its mutation
10:09:44 <SimonRC> SamB: in that case wouldn't you get them on the next GC scan
10:09:57 <oerjan> >1+1
10:10:02 <SamB> SimonRC: what's the point of doing the scan, then?
10:10:48 <SimonRC> because you will collect *at least* all the objects that were dead at the time you started scanning
10:11:16 <oerjan> lambdabot seems dead
10:11:24 <SimonRC> @WAKEY WAKER!
10:11:26 <SimonRC> @WAKEY WAKEY!
10:13:00 <SimonRC> oerjan: indeed it does
10:13:24 <byorgey> > 1+1
10:14:06 <byorgey> dons?
10:14:26 * byorgey calculates time zones in head
10:14:45 * byorgey concludes dons is asleep
10:18:32 * shapr is also asleep
10:19:42 <byorgey> shapr must have read http://xkcd.com/c269.html
10:19:55 <arcatan> @pl \x -> length x > 3
10:20:24 <Botje> arcatan: (>3) . length
10:20:45 <sjanssen> @botsnack
10:21:03 <Botje> :)
10:21:24 <lamdbadot> (:
10:21:32 <HairyDude> heh
10:21:48 <kaol> > 1+1
10:21:53 <lamdbadot> -2
10:23:02 <oerjan> a _bit_ beta, i'ld say
10:24:33 <olsner> ooh, a new episode of bleach
10:24:39 * SamB wishes he could pipe the output of an IO action to less in GHCi
10:25:23 <jfoutz> so, how's wxhaskell going? anybody do gui on the mac?
10:25:34 <Saizan> yeah, we all wish for a shell based on ghci
10:25:59 <ari> ... I don't :(
10:29:16 <olsner> ari: traitor!
10:29:52 <oerjan> you can't do a pipe to an external program in haskell?
10:30:36 <Vulpyne> POpen.open?
10:31:02 <olsner> of course you can.. somehow... it's just not as easy as mapStdout (take 50 . lines) main
10:31:34 <olsner> (unless mapStdout exists and I don't know about it)
10:31:54 <LoganCapaldo> is readFile lazy?
10:32:20 <LoganCapaldo> Or should I just use hGetContents?
10:32:24 <oerjan> oh right the output of an IO action, that might be a bit harder than a string
10:33:38 <Lemmih> LoganCapaldo: It's lazy.
10:33:48 <LoganCapaldo> Lemmih: huzzah
10:34:17 <LoganCapaldo> thanks
10:35:56 <ndm> jfoutz: use gtk2hs, if you have a choice - much better maintained
10:35:57 * oerjan is surprised the Prelude doesn't define readFile in terms of hGetContents
10:36:11 <ndm> oerjan: Hugs Sep 06?
10:36:12 <sjanssen> @src readFile
10:36:24 <ndm> or library report?
10:36:26 <oerjan> ndm: no, the online report
10:36:33 <ndm> it is actually implemented that way
10:36:44 <ndm> where is readFile in the online report?
10:36:56 <oerjan> http://www.haskell.org/onlinereport/standard-prelude.html
10:36:58 <ndm> you have to define it with unsafeInterleaveIO
10:37:21 <oerjan> ndm: hGetContents already uses that
10:37:22 <ndm> but hGetContents is defined with unsafeInterleaveIO, so that usually suffices
10:37:46 <ndm> in Hugs Sep 06 it actually is defined as a primitive, but it the darcs head its hGetContents
10:39:03 <oerjan> i wish they would put out a new major version of Hugs, the Sep 06 one is too buggy
10:42:20 * LeCamarade is implementing lambdas in C. Because boss insists on C. :o( It is a dirty script for now, to ease the pain. Then comes the Prelude clone ... :o(
10:43:04 <Baughn> Oh dear. Greenspinning.
10:43:17 <ndm> oerjan: in what area?
10:43:20 <LeCamarade> Nobody tells you the hazards of being exposed to Haskell. It's not in any tutorial I have seen. Nobody tells you C will start to be Evil.
10:43:46 <Syzygy-> LeCamarade: It's even worse.
10:43:51 <Botje> LeCamarade: haskell can compile to C .
10:43:53 <Baughn> LeCamarade: That's because C was always Evil; it's just a matter of opening your eyes
10:44:08 <Syzygy-> I was Severely Cheeky to one of my teachers yesterday when he critizied my global variables as being nonpretty.
10:44:16 <Olathe> You just have to listen for the muffled insane laughter.
10:44:24 <LeCamarade> Greenspunning, yes. Every 10 lines of C remind you why you hang out at #haskell helping newbies, when the deadline is looming. n00b could be the boss!
10:44:28 <Syzygy-> My answer was basically "All languages I'm able to use are ugly, so I view this as the minor offense."
10:44:54 <Baughn> LeCamarade: "greenspun" is the past form of the verb
10:44:55 * emu takes a sip of his kool aide
10:44:56 <LeCamarade> Syzygy-: Great answer.
10:45:37 <oerjan> ndm: about everytime i try to do a slightly complicated calculation the output is broken, as if it is reading random bits of memory or the like.  it's a known bug.
10:45:42 <Syzygy-> Oh, and I'm currently writing a paper in homotopy theory - which is loadable and executable with at least GHC.
10:45:43 <LeCamarade> Baughn: You know, it is really funny that I once thought of these for(;;) loops as normal! I just can't believe it.
10:45:48 <Syzygy-> Should be Haskell98...
10:46:37 <DRMacIver> There's a much worse problem than Haskell making you feel other languages are evil.
10:46:43 <DRMacIver> You start trying to write them like Haskell.
10:46:45 <jaapweel> is anyone aware of an Atom/RSS parser library? (I can write one, but am somewhat put off by the multiple standards for such things)
10:47:09 <ndm> oerjan: The base libraries are getting tweaked in quite distructive ways, so Hugs can't release until those bugs are fixed
10:47:15 <Syzygy-> jaapweel: For Haskell? Or in general?
10:47:33 <jaapweel> Syzygy: for Haskell.
10:47:39 <Syzygy-> Ah. No, Don't know.
10:48:34 <LeCamarade> DRMacIver: You're right! And it doesn't work, because C pointers aren't lambdas. And your code gets depressing and depressed.
10:48:42 <DRMacIver> jaapweel: There are some simple examples out there for using HXT etc to parse RSS. I think Cale has one. I'm not aware of any fullblown libraries.
10:49:41 <DRMacIver> LeCamarade: I've done it in Java. And then I realised that this was making the code amazingly awful and I wasn't benefiting from any of the Haskell like features because they were so painful to write. So I rewrote it in idiomatic Java and it was frankly better in every way. :) (It would have been better still in Haskell, but never mind)
10:49:54 <DRMacIver> s/write/read and write/
10:50:14 * geezusfreeek did it in C for a homework assignment and it turned out to be a big mess
10:50:16 <jaapweel> DRMacIver, I was about to try something like that, but waiting for HXT to compile gave me ample time to first go out and check that I'm not reinventing things ;-)
10:50:44 <DRMacIver> jaapweel: I assume you've checked Hackage?
10:50:49 <LeCamarade> DRMacIver: I have to do .NET at work. It is why I have F# on the Win32 box. I just couldn't watch myself write C# when there was redemption in F#. But this should be noted to n00bs. That they may have to undo their skills, and that it may actually hurt badly.
10:50:59 <geezusfreeek> then again, the teacher made us index from 1, which messed things up anyway
10:51:02 * ndm manages to squeeze 27 references on to half a side of A4
10:51:05 <jaapweel> DRMacIver, yes. there are two rss generators there, which is useful but only part of what I need.
10:51:09 <DRMacIver> ok
10:51:55 <DRMacIver> LeCamarade: Yeah, F# looks like a rather nice advantage to working in .NET. Although C# 3.0 is acquiring a lot of coolness too. :)
10:52:27 <olsner> geezusfreeek: the pain
10:52:29 <jaapweel> LeCamarade, you'll often find C libraries where there are functions that take a void pointer and a function pointer to a function that takes a void pointer and some other stuff. it is then understood that the void pointer is passed to the function each time it is invoked. it's a very poor man's closure. libpcap works that way.
10:52:35 * DRMacIver is going to be stuck with Java for a while though, so tends to use it for home projects too.
10:52:35 <olsner> sorry, enter/backspace ;-)
10:52:55 <LeCamarade> DRMacIver: Nothing is going to take me back. C#. After all, F# was built to rock functional from the start - why need I replace it? And I was already an OCaml fan.
10:53:12 <DRMacIver> LeCamarade: Not even Linq? :)
10:53:35 <LeCamarade> jaapweel: Yeah, I have tried to survive with func pointers, but it isn't working. I need lambdas.
10:53:51 <olsner> ... the pain of being forced to 1-index in C which is made for 0-indexing ;-) makes everything feel like ported/rewritten pascal code
10:53:58 <DRMacIver> But yeah, I'm not really saying "You should switch back to C# because of 3.0" so much as "It's going to be possible to write in a mainstream language and not have it suck."
10:54:30 <LeCamarade> DRMacIver: Yeah. Idiomatic procedural rocks more than faked functional in procedural.
10:54:45 <mdmkolbe|work> Is there a way to get ghci to not print the expression when running the ":type" command.  i.e. I want 'Main* > :type True\nBool'
10:54:56 <LeCamarade> But you find you are looking for java.monad.* and finding it nowhere ...
10:54:57 <geezusfreeek> olsner: the teacher was actually a pascal freak
10:54:59 <mdmkolbe|work> ...instead of 'Main*> :type True\n True :: Bool'
10:55:02 <geezusfreeek> makes no sense to me
10:55:12 <DRMacIver> LeCamarade: Well, procedural / OO. Appropriately (ab)used method chaining and clever representation fiddling makes for some really pleasant code even in Java.
10:55:17 <jaapweel> DRMacIver,  I think I found the example code you were talking about at http://cale.yi.org/index.php/HRSS
10:55:40 <DRMacIver> jaapweel: Yes, that's the one I had in mind. I know it's not very involved, but it gives the idea. :)
10:55:43 <monochrom> yeah that's the one
10:56:53 <DRMacIver> LeCamarade: And there's no reason you can't borrow ideas from functional programming of course. You just need to find their natural representation in the language you're using rather than try to port them verbatim.
10:56:56 <SamB> hmm. my parser seems able to parse spacewar now!
10:57:34 <olsner> what kind of parser would that be?
10:58:00 <hpaste>  LoganCapaldo annotated "CICQ history parser" with "This appears a bit faster, but I only compared taking the head, my machine was tool slow for me to d" at http://hpaste.org/264#a1
10:58:10 <SamB> a parser for the PDP-1 assembly language implemented by "MACRO"
10:58:44 <SamB> with slight alterations related to the use of ASCII instead of the PDP-1's concise character codes
10:59:11 <LoganCapaldo> sphynx: You maybe want to try that on your machine, see if it really is faster
10:59:22 <LeCamarade> DRMacIver: Indeed, indeed. For example, I recurse a lot after my time in the functional ghetto. But them languages almost never do TCO!
10:59:22 <olsner> cool, sounds old school ;-)
10:59:43 <olsner> wasn't spacewar one of the first computer games or something like that?
11:00:03 <SamB> olsner: it was the first decent one anyway
11:00:22 <sproingie> first realtime graphical one more or less
11:00:32 <SamB> I used to play a version on DOS, but it got corrupted
11:00:38 <DRMacIver> LeCamarade: What I've been doing in my lazy strings for Java project is plot out the code recursively then pass to an explicit stack. Thus I can manually TCO myself. This has a number of other advantages as well, as it lets me create continuation / generator like objects.
11:00:43 <olsner> I assume the end goal is to make some kind of PDP-1 simulator?
11:00:44 <SamB> I wish I knew to copy disks back then...
11:01:01 <DRMacIver> Well, doing / plannign to do. There's not much code there yet.
11:01:07 <SamB> olsner: yeah, I was going to do that next. the one that is supposed to be in MESS seems like... a MESS.
11:01:24 <sproingie> tho i think pong on oscilloscopes predates it
11:01:34 <SamB> sproingie: hmm?
11:01:53 <SamB> sproingie: that was a computer game, or a discrete logic game?
11:02:19 <sproingie> pong before spacewar.  spacewar have been the first *programmed* graphical computer games ... that escaped the lab anyway
11:02:39 <LeCamarade> DRMacIver: I was thinking something more-brutal: parse the code, convert some tail-calls into while loops (better stack use, I think) and compile back to C. But I realised I was being an idiot.
11:02:45 <SamB> sproingie: they didn't make spacewar in a lab did they?
11:03:15 <SamB> anyway, spacewar is far far far more influential
11:03:36 <SamB> ever played ... asteroids? gravity well? gravitar? thrust?
11:03:45 <hpaste>  ClaudiusMaximus pasted "any thoughts on this dynamic method dispatcher?" at http://hpaste.org/265
11:03:48 <SamB> xpilot?
11:04:43 <sproingie> SamB: the computer lab.  don't know if spacewar was done in a lab, but at any rate it managed to be copied
11:04:55 <DRMacIver> LeCamarade: Yes, often you can just easily TCO directly to while loops as well. I do it manually though - the key point is idiomatic imperative code. :) Trying to hide that is harmful.
11:04:57 <SamB> sproingie: yeah they did that on purpose
11:05:12 <DRMacIver> Life is too short to use half assed compilers.
11:05:23 <SamB> DEC ended up shipping copies with all their PDP-1s
11:06:30 <LeCamarade> DRMacIver: Plus I didn't know where to begin ... :o) So I gave up. I'll only do that stuff if it becomes a real problem for me.
11:06:45 <SamB> so, you see, thus begun the practice of including free games with computers ;-)
11:08:13 <SamB> now what I don't understand is what ken needed UNIX for in order to play spacewar...
11:09:51 <LeCamarade> SamB: Maybe he just needed a running machine, and in writing an OS, he wrote Unix.
11:09:55 <monochrom> multi-user
11:10:05 <SamB> LeCamarade: but why the OS?
11:10:23 <LeCamarade> SamB: Maybe the PDP-10 had none. :o)
11:10:26 <SamB> monochrom: ... don't tell me it was just a way to deal with high scores?
11:10:37 <LeCamarade> :oD
11:10:44 <SamB> PDP-10?
11:10:51 <SamB> I never heard anything about him using a PDP-10
11:11:12 <SamB> anyway the PDP-1 doesn't need no stinkin' OS
11:11:33 <monochrom> Yeah, need concurrent file system to deal with high scores!
11:12:07 <SamB> did they add users before or after fork()?
11:12:17 <monochrom> No, I meant many players playing on the same computer.
11:12:36 <SamB> you mean unix has a multi-oscilliscope interface?
11:12:40 <monochrom> They fork() before adding users and fork() again after adding users.
11:12:51 <ddx_> !cheer windows
11:12:59 <monochrom> syntax error
11:13:06 <SamB> monochrom: I meant, before or after they added fork()
11:13:28 <monochrom> fork() first, I bet.
11:13:35 <SamB> for a while they just had a shell and a program, and that was the closest they had to processes...
11:13:45 <SamB> 'twas less flexible than DOS!
11:14:11 <monochrom> They needed fork all along.
11:14:38 <Baughn> They needed users before fork, for accounting
11:14:51 <SamB> Baughn: accounting what?
11:15:03 <Baughn> SamB: Time spent. Though perhaps not in unix.
11:15:16 <SamB> well, I meant in unix.
11:15:43 <Baughn> Normally I'd still say "users first", but given the hobbyist nature of early unix..
11:15:50 <monochrom> Heh, users existed before unix. :)
11:16:08 <olsner> how can there be users of something that doesn't exist?
11:16:17 <SamB> monochrom: yes, but did ken have any accounting? I thought he had somehow holed up in a closet with the computer...
11:16:25 <Syzygy-> olsner: The computer would exist even without an OS.
11:16:38 <SamB> er.
11:16:40 <monochrom> I mean the users were born before they had computers to use.  (duck)
11:16:40 <SamB> whoever!
11:16:59 <Syzygy-> And accounting would be even more important in that case, since that would have been at a time where the computer really was holed up in a closet^Wgigantic hall, with a priesthood staff controlling it
11:17:29 <SamB> Syzygy-: ... I thought Ken somehow got ahold of one for his personal use?
11:17:55 <SamB> an older model or something?
11:19:02 <Syzygy-> Ken?
11:19:36 <SamB> fine. ken.
11:19:58 <Syzygy-> I still don't know who you're talking about...
11:20:28 * SamB sighs
11:21:10 <gogonkt1_> hi
11:21:23 <emu> K&R ;)
11:21:25 <emu> oops
11:21:32 <gogonkt1_> <interactive>:1:0: Not in scope: `f'???
11:22:32 <oerjan> gogonkt1_: what command?
11:22:38 * LoganCapaldo is sad because his ruby version of CicqParser beats his Haskell version and sphynx's version
11:22:46 <gogonkt1_> yaht 3.5 type example of case
11:23:00 <gogonkt1_> f x = ....
11:23:23 <oerjan> i think you need to put let f = ...
11:23:31 <oerjan> i mean let f x = ...
11:23:48 <gogonkt1_> f x =
11:23:49 <gogonkt1_>         case x of
11:23:53 <gogonkt1_>            0 -> 1
11:23:53 <gogonkt1_>            1 -> 5
11:23:54 <gogonkt1_>            2 -> 2
11:23:55 <gogonkt1_>            _ -> -1
11:24:08 <matthew-_> in a normal Haskell program which doesn't do any crazyness, there's no dynamic type checking or dynamic dispatch is there?
11:24:08 <MyCatVerbs> > let f x = "pornography!" in f undefined
11:24:22 <gogonkt1_> vi it in test.hs then load it in ghci
11:24:33 <oerjan> what i mean is, you cannot do "f x = ..." interactively, you need a let first
11:24:49 <Baughn> MyCatVerbs: Typeclasses pretty much are, and so is pattern matching from a certain point of view
11:24:53 <Baughn> Er, matthew-_
11:25:18 <matthew-_> Baughn: oh really? For some reason I thought that the compiler was able to resolve everything at compile time
11:25:34 <Baughn> matthew-_: Not *everything*, but it certainly tries hard
11:25:44 <gogonkt1_> signum example is run ok
11:25:50 <jaapweel> matthew-_, no, typeclasses are typically implemented with something called dictionaries
11:25:56 <gogonkt1_> but f not
11:26:04 <Baughn> matthew-_: Consider how "data Foo = Left String | Right Int" is implemented
11:26:04 <matthew-_> jaapweel: yeah, I was just remembering that
11:26:06 <jaapweel> matthew-_, of course compilers are free to try to optimize
11:26:27 <matthew-_> jaapweel: so it is pretty much the same kind of idea as vtables in java/C++ ?
11:26:50 <jaapweel> matthew-_, very similar, except the compiler figures out statically what dictionary to pass
11:27:04 <matthew-_> jaapweel: ahhh! so that's the big issue with subtyping
11:27:20 <matthew-_> that subtyping prevents the compiler from being able to work that step out?
11:28:11 <jaapweel> matthew-_, i'm not sure exactly what you're getting at. typeclasses and subtyping are different things.
11:28:12 <SamB> Syzygy-: ken who wrote unix?
11:28:24 <gogonkt1_> oh!!! quit ghci reload file then it work -_-b....
11:28:42 <Syzygy-> SamB: Oh, Ken Thompson!!!
11:28:49 <matthew-_> jaapweel: sure, I know that. I was referring to a recent post by SPJ - he said something like introducing subtyping tends to make type checking undecidable
11:28:52 * Syzygy- is NOT good with all the names of computer history....
11:28:54 <Syzygy-> *.*
11:28:59 <gogonkt1_> Thx, all
11:29:02 <matthew-_> Syzygy-: he did C and Unix
11:29:07 <Syzygy-> Yeah...
11:29:09 <jaapweel> matthew-_, yes, it does.
11:29:09 <SamB> Syzygy-: I honestly didn't remember his last name for sure
11:29:32 <Syzygy-> SamB: And I simply didn't know who you were talking about based on that first name or that handle....
11:30:07 <pejo> matthew, in HM?
11:30:15 <jfoutz> it dosn't help that k&r stands for kernighan and ritchie
11:30:20 <matthew-_> pejo: can't remember the whole post
11:30:36 <Syzygy-> That was one of my first associations, jfoutz
11:30:42 <jfoutz> :)
11:30:42 <matthew-_> jaapweel: ok. But say you have two implementations and one does all kinds of clever tricks with type classes and stuff and the other doesn't, but, when it comes down to it, the critical path is the same, the performance should be the same right?
11:31:06 <matthew-_> I'm just trying to work out whether more complex types and type classes would actually affect performance of a program
11:31:21 <jfoutz> also, spacewar is much older than pong.
11:32:19 <jfoutz> wikipedia pegs pong at 1972, spacewar at 1962. which makes sense, because it would be far more expensive to build pong out of tubes, rather than ic's
11:32:21 <geezusfreeek> matthew-_: typeclasses are kind of like template programmingâ¦ they compile statically, even though they have apparently dynamic behavior
11:32:49 <oerjan> matthew-_: if the compiler is not clever enough specialize a function using a typeclass, then it may have to pass dictionaries
11:32:54 <jaapweel> geezusfreeek, no they don't. not always.
11:33:05 <geezusfreeek> jaapweel: well, they _can_ i mean
11:33:10 <jaapweel> geezusfreeek, sure
11:33:15 <matthew-_> geezusfreeek: right. And in my case I'm just using them to establish invariants at compile time - there are actually no functions in them being called
11:33:56 <oerjan> i think there are cases of polymorphic recursion when you cannot do all specializations because there are potentially infinitely many?
11:34:21 <geezusfreeek> that may be true, i'm not sure
11:34:25 <pejo> oerjan, that sounds similar to something Oleg did.
11:34:40 <matthew-_> I'm just doing loads of type-level computation. The actual runtime code doesn't extensively use functions from type classes. So are the type classes that have to functions in them totally erased?
11:34:49 <matthew-_> s/to/no/
11:35:10 <jaapweel> matthew-_, if you aren't actually calling any typeclass polymorphic functions i imagine you don't have to worry about dictionaries being passed around
11:35:17 <geezusfreeek> sounds like if there is any performance hit it would still be crazy tiny
11:35:36 <matthew-_> good. That's what I was hoping
11:35:52 <jaapweel> matthew-_, you may want to specify explicitly what is exported from your module, so your compiler isn't forced to keep dead code around in case it is called by other modules
11:36:06 <matthew-_> jaapweel: yeah, I'm doing that.
11:36:21 <matthew-_> compilation may take a long time and each 100s of MBs but the runtime shouldn't be affected. Good good.
11:36:35 <oerjan> matthew-_: if you are not using any functions, couldn't you just drop the typeclass constraint?
11:36:42 <jaapweel> matthew-_, in that case, you ought to be able to write as much dead code as you want and not have it affect performance.
11:36:52 <matthew-_> oerjan: nope!
11:37:05 <matthew-_> oerjan: I'm using type classes to do type level computation
11:37:24 <matthew-_> oerjan: this is as close to dependently typed languages as you can get in Haskell
11:37:44 <matthew-_> ok, thanks for all your thoughts
11:48:09 <sphynx> could you please tell me how should I convert Char to Word8?
11:48:19 <sphynx> I'm trying to work with ByteStrings
11:48:40 <sphynx> I'm splitting now in this way: BS.split 0xC someByteString
11:48:44 <Lemmih> sphynx: How about using Data.ByteString.Char8?
11:49:26 <sphynx> Lemmih: oh, thanks, I will try
11:50:25 <Cale> :t fromIntegral . fromEnum
11:51:14 <oerjan> Cale: that won't work with Unicode
11:51:26 <bos> @seen xerox
11:51:30 <oerjan> (which i realized the second before posting the same)
11:51:39 <bos> hmm, no lambdabot.
11:51:55 <Cale> oerjan: yeah, but neither will Data.ByteString.Char8
11:51:59 <bos> @slap lambdaboyt
11:52:23 <oerjan> fromIntegral . fromEnum :: (Enum a, Num b) => a -> b
11:56:01 * HairyDude wonders why there's no MaybeT in mtl
11:57:47 <edwardk> http://haskell.org/haskellwiki/New_monads/MaybeT
11:57:51 <edwardk> just no one got around to it
11:58:34 <HairyDude> a very useful one to leave out, methinks
11:58:45 <oerjan> HairyDude: Maybe you can use ErrorT ()
11:58:46 <edwardk> its just a pain to propagate all the MonadFoo instances, and no one felt the need yet i guess
11:59:23 <edwardk> plus you can simulate it with ErrorT () no?
12:10:51 <HairyDude> ?hoogle Read a => a -> Maybe a
12:11:07 <roconnor> @info Read
12:11:10 <HairyDude> oh, lambdabot is dead atm isn't it
12:11:19 <Baughn> @bot
12:11:36 <Baughn> Here, have a lambdabot.
12:11:42 <HairyDude> ?hoogle Read a => a -> Maybe a
12:11:43 <Baughnie> Prelude.Just :: a -> Maybe a
12:11:43 <Baughnie> Data.Generics.Twins.gzip :: (a -> b -> Maybe b) -> a -> b -> Maybe b
12:11:43 <Baughnie> Data.FiniteMap.lookupFM :: Ord key => FiniteMap key elt -> key -> Maybe elt
12:11:59 <HairyDude> thanks Baughnie
12:12:21 <roconnor> readList :: (Read a) => String -> [([a], String)]
12:12:36 <HairyDude> ?hoogle readlIst
12:12:36 <Baughnie> Prelude.readList :: Read a => ReadS [a]
12:12:36 <Baughnie> Text.Read.readListDefault :: Read a => ReadS [a]
12:12:36 <Baughnie> Text.Read.readListPrec :: Read a => ReadPrec [a]
12:12:49 <HairyDude> oh, that's in the prelude? wow
12:13:10 <oerjan> it's a class member i think
12:13:31 <HairyDude> oh, yes
12:13:41 <edwardk> heh, for a moment i thought gzip there was the compression kind of gzip =)
12:17:42 <sphynx> hehe, my centericq history parser parses 3.5 mb file in 0.017 sec now :) I'm using ByteStrings and write it by hand
12:17:56 <sphynx> with parsec it was ~2.8 secs
12:17:57 <LoganCapaldo> hooooray
12:18:20 <edwardk> bytestrings rock
12:18:26 <sphynx> could you please take a look on this code using ByteString?
12:18:29 <edwardk> dcoutts++ dons++
12:18:40 <sphynx> I will paste
12:18:41 <edwardk> sure
12:18:53 <edwardk> @hpaste away
12:18:54 <Baughnie> Haskell pastebin: http://hpaste.org/new
12:20:02 <HairyDude> ah, readList reads stuff like "[1,2,3]", which isn't really what I was after
12:20:20 <edwardk> hairy: what was your goal?
12:20:28 <roconnor> HairyDude: oh, sorry
12:21:25 <HairyDude> edwardk: just read, but returning Nothing instead of throwing an exception when it fails
12:21:53 <hpaste>  sphynx pasted "CICQ history parser (BS impl)" at http://hpaste.org/266
12:22:08 <HairyDude> @karma dons
12:22:08 <Baughnie> Unknown command, try @list
12:22:32 <sphynx> Parsec implementation here: http://hpaste.org/264
12:23:21 <oerjan> HairyDude: use reads
12:23:58 <HairyDude> aha
12:24:27 <edwardk> sphynx: only thing i see at first is you could take the parts = and transform it into part0:part1:part2:part3:parts' = tail . BS.split ...; and save a little bit of positional indexing.
12:25:12 <pitecus> @pl (\(x,y) -> [x,y])
12:25:13 <Baughnie> uncurry ((. return) . (:))
12:25:35 <edwardk> also, you tear the message apart only to rejoin, no?
12:26:23 <pitecus> is lambdabot impersonating someone?
12:26:23 <sphynx> edwardk: part0:part1:... sounds reasonable
12:26:27 <HairyDude> thanks oerjan
12:26:38 <HairyDude> I've written my own maybeRead with that
12:26:53 <edwardk> pitecus: lambdabot is dead, long live... er, well, actually she's just taking a nap, Baughn, supplied a replacement in the meantime
12:27:04 <sphynx> edwardk: about rejoining: I'm not sure if I understand correct your question
12:27:17 <pitecus> edwardk, i see
12:27:29 <Baughn> On that note.. any volunteers to make baughnie leav when lb returns?
12:27:33 <edwardk> sphynx: well, you incur a bit of overhead on the bytestring for the 'text' portion of your parseMessage result
12:27:37 <HairyDude> lambdabot isn't sleeping, she was drugged! ;)
12:28:18 <edwardk> sphynx: it might run a bit faster if you just ticked over to the 3rd or 4th '\n' and slurped the tail of the original bytestring
12:28:21 <sphynx> edwardk: Oh, yes I understood. it seems so
12:28:56 <sphynx> edwardk: I'm rejoining all parts after 4th. I will fix it
12:29:01 <pitecus> @pl (\x y -> [x,y])
12:29:01 <Baughnie> (. return) . (:)
12:29:09 <sphynx> edwardk: thank you very much!
12:29:17 <edwardk> after that you should be quite efficient
12:29:49 <sphynx> edwardk: cool!
12:30:30 <sphynx> edwardk: I've tried also to write happy grammar for this, but it seems to be overhead
12:30:53 <sphynx> I'm stuck with errors in happy-generated code
12:31:03 <edwardk> yeah
12:31:10 <edwardk> you have a really simple parser, no need to muck it up
12:32:23 <sphynx> yeah, I just  wanted to play with happy )
12:33:15 <edwardk> happy sometimes makes me sad
12:35:58 <olsner> shouldn't it be possible to write the parsers in MonadFix (I have only fluffy knowledge about those) or something, and generate a data structure that can be used to generate GLR or any other kind of parser?
12:36:09 <edwardk> you could probably get by with a pretty efficient set of breakFirsts to rip off the first 4 '\n's and just take the right hand side
12:36:18 <edwardk> @type breakFirst
12:36:20 <Baughnie> Not in scope: `breakFirst'
12:36:25 <edwardk> ah bah
12:36:41 <olsner> @type break
12:36:43 <Baughnie> forall a. (a -> Bool) -> [a] -> ([a], [a])
12:36:48 <edwardk> http://cvs.haskell.org/Hugs/pages/libraries/base/Data-ByteString.html#v%3AbreakFirst
12:37:01 <edwardk> skips the breaked at character
12:37:46 <olsner> aah, nice... I have had uses for that function, but didn't know about it until now
12:38:25 <edwardk> breakFirst c xs == let (x,y) = break (== c) xs in if null y then Nothing else Just (x, drop 1 y)
12:41:15 <olsner> hmm.. undelim c == unfoldr (breakFirst c)?
12:42:10 <edwardk> looks like it
12:42:56 <olsner> does breakFirst not exist in ghc-6.6.1?
12:43:30 <edwardk> hrmm, can't find it =)
12:43:50 <edwardk> the docs above were for hugs, but i'd just assumed the data.bytestring implementation was the same
12:44:56 <oerjan> actually, won't that definition of undelim drop everything after the last c?
12:45:20 <edwardk> er yeah
12:46:59 <olsner> :type Just Nothing
12:47:33 <olsner> come on! bot-subs, step up!
12:47:40 <oerjan> @type Just Nothing
12:47:41 <Baughnie> forall a. Maybe (Maybe a)
12:54:17 <ari> @bot
12:54:17 <Baughnie> :)
12:54:50 * ari looks at ##c
12:55:44 <ari> Isn't that kinda the wrong place for Haskell evangelism? I mean, if you're using C and are on ##c, chances are you know of different languages but also actually do need C...
12:56:44 <Vq^> quite probable
12:59:39 * SamB wonders how to nicely write a two-pass assembler...
12:59:39 <DRMacIver> I don't know. There are a lot of die hard C users.
12:59:51 <DRMacIver> Although most grudgingly admit that sometimes high level languages like C++ are called for. ;)
13:00:08 * SamB decides to read the operating instructions for the one who's language he's reimplementing
13:00:38 <Cheery> lots of die hard C users,, lots of people, lots of people who know very little and lots of ignorant people
13:00:40 <Vq^> DRMacIver: you don't think that it's more probable that they combine C with something more highlevel?
13:01:05 <DRMacIver> Vq^: I don't have the numbers to say whether or not it's more probable. I'm sure a lot of them do.
13:01:08 <Cheery> good night people
13:01:40 <SamB> DRMacIver: I think most would rather use Python or Perl or something than C++...
13:01:53 <pejo> Cheery, don't forget those who are so good at C that it will take *very* long to get up to the same speed in any other language, unless they switch class of language.
13:01:57 <Vq^> i would guess most hardcore C/unix hackers use tcl/lua/python or something such
13:02:35 <SamB> a couple of ##c's denizens use lisp
13:02:48 <Cheery> yes
13:02:50 <ari> Vq^: If they consider themselves hardcore unix hackers they don't use that newfangled stuff, they'll use sh and perl
13:02:56 <SamB> and C isn'
13:03:01 <jfoutz> there's a large fraction of programmers who get very good with one language. starting over from scrach is very very painful, given their high standards.
13:03:05 <SamB> t a fast language to write a program in
13:03:15 <Vq^> ari: tcl isn't newfangled
13:03:30 <SamB> ari: python isn't that newfangled
13:03:40 <SamB> and sh sucks for scripts of any length
13:03:58 <Cheery> pejo: I'm myself generated sort of feeling of malcontent to even haskell already
13:04:01 <ari> ):
13:04:12 <SamB> (by "any length", I mean, if the script is long rather than short)
13:04:16 <sphynx> LoganCapaldo: thank you for your Regex version of parser!
13:04:17 <Cheery> prolog as well, and bunch of others languages I've used
13:04:32 <DRMacIver> I wonder how long it will be 'till Haskell has blub programmers. :)
13:04:44 <Cheery> what are blub programmers?
13:04:58 <SamB> DRMacIver: I'm ditching ship if that happens
13:05:00 <LoganCapaldo> sphynx: you're welcome
13:05:09 <SamB> Cheery: people who can't imagine their language being better
13:05:21 <SamB> or, who can't imagine a better language
13:05:23 <ari> My opinion is that Haskell probably does have blub programmers
13:05:41 <masklinn> every language has blub programmers
13:05:55 <ari> Those who say that Lisp macros are only needed for implementing new control structures, and that you don't need them because of lazy evaluation
13:06:06 <DRMacIver> I guess that's true.
13:06:14 <araujo> this is kindof amazing
13:06:16 <MyCatVerbs> ari: but that *is* true.
13:06:27 <SamB> ari: I say that that is almost true
13:06:31 <MyCatVerbs> The only thing lisp macros do that you can't do with HOF is control evaluation order.
13:06:41 <Cheery> there's a flaw in whole programming-language-compiler -etc. -concept
13:06:51 <SamB> MyCatVerbs: well, consider deriving typeclass instances
13:06:56 <SamB> you can't do that with a HOF
13:07:19 <MyCatVerbs> And evaluation order, while relevant to LISP, is kinda irrelevant to Haskell what with the referential transparency thing.
13:07:25 <ari> MyCatVerbs: Consider DrIFT for instance
13:07:32 <SamB> ari: eww yuck
13:07:36 * araujo figured out an algorithm for a data structure he tried to write in python half of yesterday in just 30 secs. using Haskell today
13:07:38 <SamB> what about considering Derive instead?
13:07:51 <MyCatVerbs> SamB: ahhhh. But that'll be a different kind of macro entirely, shurely? I mean, Lisp is barely typed at all...
13:08:11 <SamB> MyCatVerbs: lisp has macros for similar purposes
13:08:29 <Cheery> btw. I've been a blub programmer with every language I've programmed in
13:08:31 <pejo> MyCatVerbs, the problem with evaluation order in a strict language is that it's hard to create a new construct which isn't strict wrt all its arguments.
13:08:32 <SamB> heard of CLOS?
13:08:57 <ari> Or, for that matter, all the derivations that have gotten built in to ghc
13:09:00 <LoganCapaldo> can you really "derive" a type class instance w/ a macro? I mean for some classes its obvious, but I don't think you can write a macro for a given class that will when you feed it a type derive that class for it, or decide it can'
13:09:02 <MyCatVerbs> SamB: yyes... damn.
13:09:03 <Cheery> realised there is a pattern that causes that every programming language sucks
13:09:18 <LoganCapaldo> The most the macro's are going to get you with that is saving keystrokes
13:09:20 <pitecus> does the following generate all possible substrings of w? It seems to:  f w =  fromList $ concat $ [ inits x | x <- tails w ]
13:09:44 <SamB> yeah, I think everyone is probably going to be in some ways a blub programmer while they're learning a language higher-level than anything they've seen before
13:09:53 <MyCatVerbs> LoganCapaldo: you could do it for some with stringisation and the sort of vaguely shitty ad-hackery that cpp macros use.
13:09:57 <edwardk> > fromList $ concat $ [ inits x | x <- tails "hello" ]
13:09:58 <Baughnie>   Not in scope: `fromList'
13:10:06 <Cheery> SamB: I've been also learned from high to low level
13:10:23 <pitecus> > concat $ [ inits x | x <- tails "hello" ]
13:10:23 <SamB> or
13:10:24 <Baughnie>  ["","h","he","hel","hell","hello","","e","el","ell","ello","","l","ll","llo"...
13:10:25 <Cheery> like.. python -> forth, haskell -> assembly
13:10:31 <SamB> hmm.
13:10:32 <weitzman_> > (\x -> [y | x <- tails s, y <- inits x]) "abc"
13:10:32 <Baughnie>   Not in scope: `s'
13:10:41 <weitzman_> > (\s -> [y | x <- tails s, y <- inits x]) "abc"
13:10:41 <Baughnie>  ["","a","ab","abc","","b","bc","","c",""]
13:10:49 <SamB> why would you be an ASM blub programmer after learning Haskell?
13:11:06 <SamB> how could you seriously not imagine a better ASM?
13:11:13 <edwardk> =)
13:11:28 <edwardk> samb: what do you need to write an assembler for?
13:11:33 <LoganCapaldo> MyCatVerbs: Assuming Lisp-level macros or better, how could you write a macro from a -> Monad a for instance? I just think that the deriving thing is a bad example for the utility of macros actually. Yes HOF can't do it, but I don't think macros can (meaningfully) either.
13:11:34 <Cheery> assembly is beautiful in it's nudity
13:11:39 <edwardk> samb: er what platform, not what reason ;)
13:11:46 <ari> > concatMap inits $ tails "hello"
13:11:47 <Baughnie>  ["","h","he","hel","hell","hello","","e","el","ell","ello","","l","ll","llo"...
13:11:50 <SamB> edwardk: well, I'm writing one for PDP-1
13:11:56 <edwardk> ah
13:11:59 <SamB> because I want to play spacewar
13:12:02 <edwardk> =)
13:12:54 <SamB> and I don't want to touch that one that's written in perl
13:12:54 <edwardk> i have a dos port of that somewhere
13:12:55 <SamB> ooooh
13:12:55 <SamB> I had that
13:12:56 <SamB> but it got corrupted
13:12:56 <edwardk> i'll see if i can find the disk when i get home
13:12:56 <MyCatVerbs> LoganCapaldo: oh aye, Christ, that's not doable. But things like serialisation (jah, show and read) and... limited variations on that, could be.
13:12:56 <weitzman_> Is lambdabot sleeping?
13:12:56 <SamB> maybe not the same one...
13:12:56 <Cheery> SamB: like I said, I realised a pattern
13:12:57 <byorgey> weitzman_: yes, apparently
13:12:57 <SamB> Cheery: what pattern?
13:13:01 <edwardk> can't remember where i got it some shareware disk or something
13:13:03 <SamB> the computer is an idiot?
13:13:18 <Cheery> the pattern is that given a language, you find a set of things that make it best
13:13:30 <SamB> elaborate?
13:14:14 <edwardk> cheery: something like how no one sees the point in using a language more powerful than the one they have, you mean?
13:14:25 <Cheery> haskell.. math problems, assembly.. hardware-near-stuff stupid evaluation, prolog.. logic problems, etc.
13:14:54 <Cheery> and therefore, they all equally suck
13:14:58 <SamB> hah
13:15:05 <SamB> what about INTERCAL
13:15:13 <Cheery> I don't know INTERCAL
13:15:17 <SamB> learn it
13:15:18 <edwardk> good at frustrating the user?
13:15:19 <edwardk> =)
13:16:03 <Cheery> languages we use right now for programming are clumsy and inefficient at expressing things
13:16:22 <Cheery> because of the nature that they are meant to be translated directly to programs
13:16:27 <LoganCapaldo> MyCatVerbs: yeah tht's what I meant when I said for some its obvious
13:16:27 <LoganCapaldo> :)
13:17:12 <MyCatVerbs> Suppose that fits in under "merely saves typing," though.
13:18:56 <Cheery> if you check out non-programming languages, they appear being capable to express variety of things concisely, without adding too much excess length or complexity
13:19:26 <edwardk> cheery: sure by building up a lot of context that the user has to have to understand what is being said, they have large 'environments' in scope
13:19:35 <byorgey> Cheery: by "non-programming languages" you mean, e.g. English?
13:19:40 <Cheery> yes
13:20:00 <LoganCapaldo> Hmmm
13:20:04 <oerjan> Cheery: they do so by being so ambiguous that you need at least human intelligence to decode their meaning, and even then sometimes fail
13:20:05 <byorgey> Cheery: try telling someone trying to learn English that there's "not too much excess length or complexity" =P
13:20:08 <Vq^> im not so sure english is better for expressing problems
13:20:12 <edwardk> use perl if you want pronouns, i.e. $_ =)
13:20:14 <LoganCapaldo> well if e all programmed in a gian distributed image <g>
13:21:58 <Cheery> another thing I think that's important is that natural languages seem to 'appear', they are never molded
13:22:05 <edwardk> the earlier inits/tails thing, repeats the
13:22:16 <edwardk> er repeats the 'empty' entry over and over in its output
13:22:31 <emu> natural languages are terrible for expression problems
13:22:33 <oerjan> hm...
13:22:38 <edwardk> > concatMap inits $ tails "123"
13:22:39 <Baughnie>  ["","1","12","123","","2","23","","3",""]
13:22:46 <emu> there are entire disciplines devoted to confusion arising from the problems of natural language!
13:22:50 <Vq^> Cheery: you prefer lojban? :)
13:23:28 <Cheery> nah, I don't think that you can get far by switching language
13:24:09 <emu> there's a good reason mathematicians and computer scientists work in formal languages
13:24:29 <Cheery> and using multiple totally different languages ends up with total mess
13:24:48 * edwardk gets a little inside chuckle every time he meets an undergrad who has decided he wants to rewrite all of mathematics in natural language.
13:25:14 <oerjan> > concatMap (tail . inits) . tails $ "123"
13:25:15 <Baughnie>  ["1","12","123","2","23","3"]
13:25:20 <Cheery> emu: yes, but I'd dare to say it also 'appears' mathematicians do not mold them
13:25:24 <edwardk> You wait a couple of years, then you notice that impulse silently vanish.
13:25:29 <Excedrin> I prefer specifying problems in the language of love
13:26:07 <edwardk> i prefer to avoid problems when using the language of love ;)
13:26:10 <Cale> > filterM (const [True,False]) "123"
13:26:11 <Baughnie>  ["123","12","13","1","23","2","3",""]
13:26:29 <oerjan> o_O
13:26:31 <emu> the base of the natural logarithm raised to the power of half the circumphrence of the unit circle multiplied by the number which when squared equals negative one, plus one, equals zero
13:26:41 <Cale> > filterM (const [False,True]) "123"
13:26:42 <Baughnie>  ["","3","2","23","1","13","12","123"]
13:28:53 <weitzman> In practice, I think the displine of software development has far more to fear from trying itself it inflexible platforms than minor quibbles over which language is textually nicer.
13:29:07 <weitzman> It's still impractical to integral multiple languages on a complex project
13:29:07 <Cheery> but lets talk about this later, my thoughts are not fully formed, even thought I think that programming languages suck
13:29:11 <weitzman> People still compile to native code
13:29:16 <Cheery> and I'm starting to feel tired
13:29:21 <weitzman> *integrate
13:29:30 <emu> well that's mostly due to runtime system variations
13:30:07 <weitzman> But the more people write code for linux or windows or whatever environment we've been using, the more they connect us to that environment and make change impossible
13:30:14 <weitzman> It's a bad cycle
13:30:31 <emu> whatcha talkin about, get one of them mythical "standalone executables" ;)
13:30:31 <Cheery> weitzman: it's a bad cycle now
13:30:55 <weitzman> weitzman: Yep, and it makes me very sad :(
13:31:00 <weitzman> I keep talking to myself
13:31:07 <emu> its a bad cycle
13:31:56 <byorgey> @src filterM
13:31:57 <Baughnie> Source not found. Just what do you think you're doing Dave?
13:31:59 <weitzman> It doesn't matter if people do cool stuff like Microsoft's Singularity OS 'cause people just plain can't use it
13:32:57 <Cheery> weitzman: realised that
13:33:01 <oerjan> @type filterM
13:33:02 <Baughnie> forall a (m :: * -> *). (Monad m) => (a -> m Bool) -> [a] -> m [a]
13:33:13 <Cheery> part why I'm thinking programming languages we have are clumsy and inefficient
13:33:26 <weitzman> Cheery: I don't think it's the language, though
13:33:29 <hpaste>  sphynx annotated "CICQ history parser (BS impl)" with "Revisited parseMessage (BS version)" at http://hpaste.org/266#a1
13:33:40 <weitzman> Cheery: I think it's partly how we compile the languages and run them
13:33:45 <weitzman> Cheery: Mostly that, even
13:33:59 <emu> fundamental computer architecture?
13:34:06 <weitzman> Not the PC, but the OS
13:34:24 <sphynx> edwardk: I've rewritten parseMessage with breaks by '\n'
13:34:29 <Daveman> :p
13:34:30 <Cheery> weitzman: yes, but problems are related to programming languages
13:35:07 <Cheery> if you wouldn't compile or run them, they wouldn't be programming languages like we think now they are
13:35:11 <weitzman> Cheery: Indeed. One think I like about the .NET idea is it gives us hope that one day software could all get along within some kind of VM/OS
13:35:33 <Cheery> I think that's doomed idea if you don't fix the cause
13:36:30 <weitzman> Cheery: I think the problem is really the platform, not the languages. If we had a platform where choice of language was harmless because it had no impact on those people interfacing with you, we could use any crap language we wanted
13:36:32 <Cheery> that means fixing something that forces you to do it right the way how you do it now
13:36:46 <emu> i'd like to see more formally grounded programming environments
13:37:00 <emu> an OS with a theorem checker and prover integrated ;)
13:37:21 <mdmkolbe|work> any one know of any documentation one tricks you can play with :def?  I'm looking for  a munged equivalent of :type.
13:37:49 <Cheery> I don't think it'd help *even* if we could choose our poison
13:37:59 <emu> mdmkolbe|work: why, btw?
13:38:10 <emu> i noticed you been asking this all day
13:38:47 <Excedrin> weitzman: what's the difference between .NET and the java stuff?
13:39:36 <weitzman> Excedrin: Sure people write languages fo the java VM, but that was never the goal of it.
13:39:53 <weitzman> Excedrin: .NET has that as an explicit goal
13:40:08 <thoughtpolice> interoperability between languages is a major .NET goal
13:40:14 <mdmkolbe|work> emu: I want to do things with lhs2TeX where I say "consider the expression |foo a| it has the type \eval{:type foo a}", and have it print like "consider the expression /foo a/ it has the type /Int/", but with GHCi's default behaviour I get "consider the expression /foo a/ it has the type /foo a :: Int/"
13:40:23 <DRMacIver> Between languages with almost identical type systems anyway. ;)
13:40:25 <weitzman> Actually the Java classfile has some pretty embarassingly bad design flaws
13:40:37 <Heffalump> DRMacIver: what, like O'Caml and Visual Basic? ;-)
13:41:02 <DRMacIver> Heffalump: No, like F# and Visual Basic.NET, which are two very different beasts from both of those examples. ;)
13:41:03 <Excedrin> what's the state of .NET on anything other than windows?
13:41:27 <weitzman> Excedrin: The mono project works, as far as I know, but I've never used it
13:41:28 <DRMacIver> Heffalump: And in fact both illustrate my point excellently as languages whose type systems were changed in order to make them run on .NET. :)
13:41:34 <emu> mdmkolbe|work: and you can't run it through sed or something?
13:41:35 <thoughtpolice> mono is 'there,' but it's playing a game of 'catch up'
13:41:36 <weitzman> Excedrin: Doesn't support windows forms, probably
13:42:00 <thoughtpolice> you have things like GTK# however, which works on mono and ms's implementation of the CLR.
13:42:25 <sphynx> hm, it seens I've got some GHC bug
13:42:26 <sphynx> internal error: interpretBCO: unknown or unimplemented opcode 18716
13:42:32 <Excedrin> are there any lazy functional languages on .NET?
13:42:57 <thoughtpolice> Excedrin: I don't know about lazy, but there're functional languages ontop of .net (f# and nemerle come to mind)
13:43:12 <DRMacIver> The advantages of .NET over the JVM for multi language infrastructure seem to be mostly marketing and having a VM design which doesn't suck. (Neither of which are trivial things mind you)
13:43:30 <mdmkolbe|work> emu: well I think sed would have to run between when ghci outputs it and when lhs2TeX starts to read it and I'm not sure if lhs2TeX allows that
13:43:32 <DRMacIver> (And TCO)
13:43:36 <thoughtpolice> .net is a fairly nice platform tbh; language integration and interoperability is fairly seamless.
13:43:37 <Heffalump> excedrin: http://kahu.zoot.net.nz/ is the only one I know of
13:43:52 <Heffalump> DRMacIver: and COM interop.
13:43:58 <DRMacIver> Hm. Fair point.
13:44:07 <Heffalump> though apparently it's rather slow
13:47:04 <edwardk> thoughpolice: my only real complains about the .net runtime come from the fact that it has a fairly heavy marshalling barrier to unmanaged code, which impedes my would-be uses for it
13:48:28 <thoughtpolice> edwardk: i haven't done much .net work outside of my little experiments with f# and nemerle and whatnot; I never had a reason to call native libraries, although I would assume in your transition you may hit a non-negligable performance bump
13:49:14 <edwardk> a large number of my primitives by way of sundry usage pattern guarantees (linearity, regions, etc) should ideally be one step removed from the garbage collection system, but the only way to 'opt out' is to say they are native, and then go through the p/invoke or c++ interop barrier
13:50:05 <edwardk> so i get stuck with all of these 30+ instruction interop thunks everywhere interfering with what was previously my 'fast' codepath. =/
13:50:33 <Excedrin> is there a way to call .net stuff from Haskell?
13:50:49 <edwardk> @where Ghc.Dotnet
13:50:49 <Baughnie> I know nothing about ghc.dotnet.
13:50:51 <edwardk> er
13:50:54 <edwardk> @hoogle Ghc.Dotnet
13:50:55 <Baughnie> No matches, try a more general search
13:50:57 <edwardk> hrmm
13:50:59 <Heffalump> I don't believe there's anything usable now
13:51:06 <edwardk> its there but i don't know if its maintained or usable
13:51:14 <Heffalump> but someone at UNSW is working on it, IIRC
13:51:19 <thoughtpolice> http://php.cin.ufpe.br/~haskell/haskelldotnet/
13:51:31 <Excedrin> it seems like compiling Yhc.Core to .NET might be a nice project
13:51:44 <Heffalump> that's the .NET backend for GHC, which is an alternate solution (but also not ready yet, AFAIK)
13:51:51 <mdmkolbe|work> emu: now that you mentioned it, I guess I'll just do sed on the output of lhs2TeX (as apposed to the output of Ghci).  Not the best but it seems to work.
13:52:29 <edwardk> i'd rather go from something like STG, where all the work has been done
13:52:55 <edwardk> though i think the hard part would be usable FFI, etc.
13:53:53 <Heffalump> I'd have thought C-- would be a nicer starting point.
13:53:53 <thoughtpolice> .NET would be a reasonable target platform imo.
13:54:27 <edwardk> i find c-- makes a few too many architectural decisions for me to like it as a starting point for a lot of things.
13:55:07 <edwardk> stg has all the closure conversion, etc done, and i can still try to find ways to exploit the specifics of the target platform
13:56:09 <edwardk> then maybe c-- would be better for .net, it was just bad when i looked at javascript, etc.
13:56:58 <edwardk> at least MSIL supports tail calls ;)
13:59:19 <oerjan> any sorta fans here?
13:59:30 <edwardk> heh the haskell.net folks use STG as a starting point as well
13:59:36 <oerjan> oops, wrong channel
14:00:01 <pejo> edwardk, are you claiming STG makes fewer architectural decisions than C--?
14:00:38 <hpaste>  kosmikus pasted "postprocessing :type output" at http://hpaste.org/267
14:00:57 <kosmikus> mdmkolbe|work: ^^^ quick hack
14:01:01 <edwardk> pejo: yeah
14:01:17 <edwardk> pejo: with STG i have a lot of control over HOW i implement thunks, etc.
14:02:50 <mdmkolbe|work> kosmikus: wow
14:02:54 * mdmkolbe|work gives it a shot
14:03:03 <kolmodin> ?localtime
14:03:06 <Baughnie> Local time for kolmodin is Wed Jun 13 23:00:04 2007
14:03:24 <kolmodin> what's up with lambdabot?
14:03:45 <edwardk> taking a short dirt nap
14:03:52 <edwardk> baughn sent in baughnie to fill in
14:04:17 <kolmodin> is Baughnie to shy to enter #gentoo-haskell ? :)
14:06:38 <edwardk> if baughn isn't awake i can send bottom
14:07:58 <Lemmih> edwardk: Why doesn't C-- give you control over how thunks are implemented, OOI?
14:09:45 <edwardk> lemmih: for one it assumes a register model, and stores to memory locations, etc. in say, javascript its generally faster for me to just take the STG and reimplement it raw in javascript maintaining the same variable names and mappings and not constructing an artificial notion of registers and locations.
14:10:37 <mdmkolbe|work> Lemmih: c-- is a portable assembly language so it doesn't concern itself with higher level constructs like thunks
14:11:08 <edwardk> by the time i get to c-- i've lost all useful structure
14:11:40 <edwardk> when i'm in core i still have boring work to do ;)
14:14:46 <Lemmih> mdmkolbe|work: Exactly, that why I asked why it didn't offer enough control.
14:15:49 <mcnster> hi.  foreign q:  is it possible to marshall an MVar?
14:16:31 <Lemmih> mcnster: It depends on what you want.
14:16:53 <mcnster> Lemmih, i would want to be able to put/take in a foreign C fn
14:17:37 <Lemmih> That is possible.
14:18:04 <mcnster> Lemmih, cool
14:18:13 <edwardk> lemmih: the problem is just that by the time you get there, any implementation for some platforms will be inefficient
14:19:54 <emu> whew, big storm here
14:20:00 <Lemmih> edwardk: Right, I understood.
14:20:25 <mdmkolbe|work> edwardk: not really.  most platforms have a concept of registers and memory, store/load, conditional branches, etc.  So quite a few compilers are designed to target some machine independant language before implementing machine specific back-ends.  In gcc this is (was?) RTL, in GHC it's C--.
14:20:56 <emu> c-- is a new thing in ghc
14:21:56 <mdmkolbe|work> emu: ?
14:23:24 <edwardk> mdmkolbe|work: sure, but the specificity of the design just doesn't suit my purposes ;) same problem I have with GRIN for the same set of platforms, one step too low level for efficient implementation.
14:23:53 <mdmkolbe|work> edwardk: what are you targeting?
14:23:57 <kosmikus> mdmkolbe|work: does it work?
14:24:13 <edwardk> mdmkolbe|work: well, last time i was targeting javascript
14:24:41 <mdmkolbe|work> kosmikus: not quite, b/c I'm using --code (IIRC, my remote terminal froze).
14:25:29 <mdmkolbe|work> edwardk: ah, now I understand.  Yeah, c-- is to low level for targetting javascript.
14:25:39 <edwardk> so when the target already has closures, but lacks tail-calls, so i have to implement a form of chicken-scheme style stack-exploding trampoline, etc, and i want to leverage the in-language closures to get better memory management and take advantage of the garbage collector, etc, c-- was pushing me towards the wrong architectural decisions
14:29:36 <mdmkolbe|work> kosmikus: err, I'm targetting --verb for the moment which seems to brake that particular incantation.  (An extra \text gets wrapped around but when I tried the \otext trick it through an error about an extra '}', and I know perl regex better than latex so that seems to be the easier route even if it's technically wrong.)
14:32:10 <hpaste>  mdmkolbe|work pasted "Def trick that gets me halfway there" at http://hpaste.org/268
14:32:33 <mdmkolbe|work> This trick also makes some of the cases clean enough to live with http://hpaste.org/268
14:42:43 <kosmikus> mdmkolbe|work: ok, I didn't know you're using verb
14:49:52 <hpaste>  kosmikus annotated "postprocessing :type output" with "adapted for --verb" at http://hpaste.org/267#a1
14:50:08 <kosmikus> mdmkolbe|work: ^^ version that should work with --verb
14:50:36 <Baughn> @bot
14:50:36 <Baughnie> :)
14:53:40 <mdmkolbe|work> kosmikus: that worked
14:53:48 <mdmkolbe|work> @help karma
14:54:23 <mdmkolbe|work> LB down, but kosmikus++ anyway :-)
15:26:09 <dibblego> ?where yaht
15:26:19 <dibblego> ?WTF is yaht
15:26:37 <dibblego> ?GOD DAMN YOU LAMBDABOT WHERE THE F!@# is yaht
15:26:54 <dibblego> lambdabot sucks donkey balls
15:27:28 * desp glares at dibblego
15:27:38 <fridim> @where yaht
15:27:42 * araujo prototyping on Haskell and coding on Python
15:27:59 <araujo> it is usually giving me cleaner and shorter code than straight from Python
15:29:59 <mdmkolbe|work> araujo: heh, yeah.  I had that happen to me and I was astonished considering that Python is known for being good at prototyping.
15:30:25 <mdmkolbe|work> araujo: why are you converting over to python after already prototyping in haskell, btw?
15:31:09 <araujo> mdmkolbe|work, i think Python lacks one important feature for prototyping ... ADTs
15:31:22 <araujo> mdmkolbe|work, the application is being written on Python
15:31:58 <mdmkolbe|work> ADT = abstract DT? or algebreic DT?
15:32:22 <araujo> abstract DT
15:33:18 <araujo> static typing is also fundamental for proper prototyping imho
15:43:02 <hpaste>  sphynx pasted "Getting values from monad" at http://hpaste.org/269
15:43:20 <sphynx> could you please take a look at this code?
15:43:46 <sphynx> I have a question about getting values from monad inside map function argument
15:45:31 <sphynx> I've tried to do something with liftM, mapM, but I'm getting stuck..
15:45:36 <sorear> sphynx: IO values are *actions* not values per se, so you'll have to run them in sequence
15:45:40 <sorear> @typ sequence
15:45:44 <sorear> ah ok
15:46:18 <hpaste>  sorear annotated "Getting values from monad" with "fixed" at http://hpaste.org/269#a1
15:47:49 <sphynx> sorear: Now I have     No instance for (Show (IO [(Int, Int)]))
15:48:07 <sphynx> @type mapM
15:48:57 <sorear> sphynx: are you sure?
15:49:09 <sphynx> sorear: 1 second
15:49:09 <sorear> that has to be <- not let =
15:49:31 <sphynx> sorear: ah, sorry, stupid me
15:50:02 <sphynx> sorear: yeah, now all works good! thanks
15:59:05 <hpaste>  fridim pasted "(no title)" at http://hpaste.org/270
16:02:55 <mdmkolbe|work> fridim: use pattern matching
16:04:12 <Cale> fridim: your definition of rectangle won't quite work
16:06:09 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/271
16:06:19 <fridim> something like that?
16:06:29 <fridim> Cale, how can I define rectangle?
16:06:46 <Cale> fridim: What should the type of rectangle be?
16:06:59 <Cale> Is it a test to see if a Shape is a rectangle?
16:07:15 <fridim> rectangle is a Polygon
16:07:25 <Cale> Or is it a means of creating a shape that is a rectangle
16:07:26 <Cale> ?
16:08:00 <Cale> Like, you already have a constructor Rectangle of Shape.
16:08:10 <hpaste>  mdmkolbe|work annotated "(no title)" with "try something more along these lines" at http://hpaste.org/271#a1
16:08:16 <Cale> So   Rectangle 5 3 :: Shape   already.
16:08:22 <fridim> Cale, it is an exercice in soe
16:08:41 <fridim> define functions rectangle and rtTriangle in terms of Polygon
16:09:02 <Cale> what are they supposed to do?
16:09:19 <fridim> the same as  square s
16:09:44 <fridim> square :: Side -> Shape
16:09:47 <Cale> ah, so instead of rectangle x y = Rectangle x y, you want a polygon with vertices?
16:10:06 <fridim> yes.
16:10:09 <Cale> okay
16:10:19 <fridim> I guess it is the exercice
16:11:12 <Cale> So if we're given that the side lengths are x and y, the easiest rectangle to construct with those side lengths would probably be the one which has (0,0) at one corner, and (x,y) at the other.
16:11:46 <Cale> So  rectangle x y = Polygon [(0,0), (x,0), (x,y), (0,y)]
16:11:54 <fridim> mh
16:11:57 <fridim> so easy
16:12:07 <fridim> I thought I had to define something more general
16:12:34 <Cale> The definitions you've been writing there look like something you might find in a logic/constraint language.
16:12:49 <fridim> Cale, indeed
16:12:54 <Cale> The only things you can put in a 'where' are declarations -- you can't just put boolean expressions.
16:13:13 <Cale> (though that is an interesting idea)
16:13:25 <SamB> okay...
16:13:39 <SamB> I don't get how the MR applies to implicit paramaters....
16:14:18 <sorear> SamB: the MR applies to constrained types, and implicit parameters are a kind of constraint
16:14:37 <SamB> sorear: ... and not to all things
16:14:59 <sorear> SamB: The MR does not apply to unconstrained polymorphic types.
16:15:11 <sorear> > let x = undefined in (x 'a', x True)
16:15:16 <SamB> er.
16:15:16 <Cale> fridim: For writing side, as mdmkolbe|work pointed out, it's simplest to use pattern matching. So you'll have something which looks like  side (x1,y1) (x2,y2) = ... formula for computing distance ...
16:15:18 <sorear> bah.
16:15:21 <sorear> @quit
16:15:41 <SamB> I mean, how come if I have a function that takes an implicit parameter, that's allowed?
16:15:56 * mdmkolbe|work wonders if there are any stats on how many queries are sent to LB each day
16:16:17 <fridim> Cale, ok
16:17:00 <hpaste>  fridim pasted "but what's correct syntax if I want something like that?" at http://hpaste.org/272
16:17:05 <MarcWeber> Yes there are. Somewhere has been a page stating who has sent how much messages .. And most messages of lb are replies.. ( except of tell etc ..)
16:17:19 <MarcWeber> But I don't remember the page
16:17:32 <fridim> (bad manip)
16:19:10 <hpaste>  mdmkolbe|work annotated "but what's correct syntax if I want something like that?" with "(no title)" at http://hpaste.org/272#a1
16:19:45 <fridim> ok.
16:19:48 <Cale> The only thing allowed in a guard is a boolean expression in terms of the matched variables.
16:20:10 <Cale> (well, there are pattern guards now, but that's an extension)
16:20:21 <chessguy> @bot
16:20:21 <lambdabot2> :)
16:21:14 <hpaste>  Cale annotated "but what's correct syntax if I want something like that?" with "You *could* write it like this with the pattern guards extension." at http://hpaste.org/272#a2
16:21:47 <mdmkolbe|work> 'where' gives you variable bindings (x, y, etc.),  pattern guard don't do that (IIRC, they might if you do (x, y) <- a, but that is a more obsure use)
16:21:48 <hpaste>  Cale annotated "but what's correct syntax if I want something like that?" with "something like this is more likely" at http://hpaste.org/272#a3
16:21:48 <SamB> @instances MonadTrans
16:21:50 <lambdabot2> ContT r, ErrorT e, RWST r w s, ReaderT r, StateT s, WriterT w
16:21:56 <SamB> hmm.
16:21:58 <SamB> @instances Monad
16:21:59 <lambdabot2> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
16:22:12 <mdmkolbe|work> heh, Cale beat me to it
16:23:35 <SamB> isn't there like an Id monad or something?
16:24:01 <Cale> @docs Control.Monad.Identity
16:24:01 <lambdabot2> http://haskell.org/ghc/docs/latest/html/libraries/mtl/Control-Monad-Identity.html
16:24:21 <SamB> oh, Identity
16:36:20 <igli> dons: ping
16:41:35 <igli> meh where's sorear then?
16:41:38 <igli> @sorear
16:41:38 <lambdabot2> Unknown command, try @list
16:41:48 <igli> ah lambdabot2 wtf is that?!
16:41:55 <igli> @seen sorear
16:41:55 <lambdabot2> I saw sorear leaving #haskell 16m 51s ago, and .
16:42:00 <igli> ffs
16:42:13 <igli> @join #friendly-coders
16:42:13 <lambdabot2> Not enough privileges
16:42:19 <igli> teh sigh
16:42:32 <igli> well lambdabot isn't responding
16:42:41 <igli> so tell one's master lambdabot2 ;-)
16:42:53 <igli> s/master/organic/ sorry
16:42:57 <igli> @botsnack
16:42:58 <lambdabot2> :)
16:44:20 <sphynx> hmmm, could you please tell how I can print something of type [ (String, IO Int) ] ?
16:44:36 <sphynx> in main function
16:46:01 <mdmkolbe|work> sphynx: you can't print an (IO Int)
16:46:30 <hpaste>  sphynx pasted "Getting from monad again..." at http://hpaste.org/273
16:46:58 <sphynx> mdmkolbe|work: could you please take a look on my code?
16:48:46 <mdmkolbe|work> sphynx: instead of doing an in-line lambda, try writting a full helper function with type, FilePath -> IO (FilePath, [Message])
16:49:32 <sphynx> mdmkolbe|work: hm, Ok. I'll try now. Thanks!
16:57:00 <shapr> duude, wassup?
16:57:07 <chessguy> shapr!
16:57:16 <shapr> y0 chessguy, wassup man?
16:57:36 <chessguy> not a heck of a lot
16:58:09 <shapr> I tried to figure out a monad transformer version of GPLib, but got distracted by work.
16:59:00 <shapr> In any case, GPLibT would be more about getting users to understand how to use monad transformers to implement their own specific flavor of GP algorithm.
16:59:22 <chessguy> well, speaking generally
16:59:44 <chessguy> suppose you wanted to add a few randomly-generated individuals every generation
16:59:53 <chessguy> are you saying that would be implemented via a transformer?
17:00:47 <shapr> I think so, but I'm not totally sure.
17:01:08 <shapr> I'm torn between the DSL view and the monad transformer view, and I'm not sure they're different views.
17:01:22 <chessguy> so the base monad would be a very plain, dull evolutionary process
17:01:36 <shapr> Er, I don't think so..
17:01:41 <shapr> I think the base monad would be Id
17:01:42 <chessguy> and all the fanciness would be added via transformers?
17:02:07 <shapr> Well, yeah...
17:02:16 <shapr> I think that would work.
17:02:16 <chessguy> well, maybe we could take a simpler example
17:02:37 <chessguy> suppose we started with some other, easy problem, and worked out this approach to it
17:02:54 <shapr> Like, modular interpreters using monad transformers?
17:03:17 <chessguy> if you think that's a good example
17:03:42 <shapr> That gets nearly 20k hits on google :-)
17:04:04 <shapr> er, 19.4k actually
17:04:07 <chessguy> probably about 3 are relevant? :)
17:04:34 <shapr> The first hundred are all relevant.
17:05:19 <mdmkolbe|work> monads provide the 'runtime support' that your DSL needs to use pervasively.  Cf. state, logging via writers, environments via readers, etc.
17:06:36 <shapr> chessguy: You could always write a GP interpreter built with MTs.
17:07:02 <chessguy> how is that really different from a DSL?
17:07:28 <shapr> It's not, it's just specific in how the DSL is implemented.
17:09:01 <chessguy> hmm. how?
17:09:01 <shapr> DSLs don't have to be implemented with monad transformers.
17:10:05 <chessguy> so it's a question of whether the end-user has to write transformers to modify the system or just write domain-specific code that is interpreted as a monadT layer which modifies the GP system
17:11:14 <shapr> chessguy: s/ interpreted as / interpreted by / but yes
17:11:20 <mdmkolbe|work> sounds like a question of whether the user is making chanages that can have implicit effects on other (non-local) parts of the code
17:12:04 <chessguy> shapr, that's fine, but it sounds like either way, we want a monadT layer that modifies the GP system, and once we have that, the DSL is just a layer on top of that
17:12:20 <shapr> chessguy: Do you want the user to be able to add/remove/change interpreter features, or do you want them to just write code in the DSL?
17:12:42 <chessguy> i have to choose? :)
17:12:54 <shapr> Not really..
17:14:18 <chessguy> my thinking is that we sould add the features at the transformer level, and then just make the DSL basically sugar over that
17:14:33 <shapr> I think that's a worthwhile approach.
17:14:40 <chessguy> to keep the DSL reasonable
17:15:01 <sorear> hi shapr
17:15:04 <chessguy> that said, i still have no concept of what the transformer level should look like
17:15:30 <shapr> I'm not really sure myself.. I started to read more about monad transformers, but like I said, I got distracted by work.
17:15:50 <chessguy> yeah, i need to do that too
17:15:56 <chessguy> read, that is, not get distracted by work
17:16:14 <shapr> heh
17:16:22 <shapr> I'm off to be distracted by more work :-)
17:16:25 * shapr &
17:16:33 <chessguy> shapr,  thanks for the discussion
17:17:06 <sphynx> is there some way to simplify this function?
17:17:08 <sphynx>  (length . my $ matched, length . your $ matched)
17:17:18 <dibblego> @pl length . my $ matched, length . your $ matched
17:17:18 <lambdabot2> (line 1, column 22):
17:17:18 <lambdabot2> unexpected ","
17:17:18 <lambdabot2> expecting letter or digit, variable, "(", operator, "$", "$!", "`seq`" or end of input
17:17:28 <dibblego> @pl (length . my $ matched, length . your $ matched)
17:17:28 <lambdabot2> (length (my matched), length (your matched))
17:17:59 <sphynx> I'd like something like: length --> (my, your) --> matched :)
17:18:12 <sorear> @join #xmonad
17:18:32 <MarcWeber> sphynx: Some time ago this function was posted on haskelcafe:
17:18:34 <MarcWeber> f `on` op = \x y -> f x `op` f y
17:18:52 <MarcWeber> So you should be able to do length `on` (,)  ...
17:19:13 <sphynx> MarcWeber: hm, cool. thank you!
17:19:58 <MarcWeber> The trouble is: it's neither in Prelude nor base package. So you have to copy paste it each time again. And then you are as fast as typing length twice :)
17:20:40 <mdmkolbe|work> @type second . first
17:20:42 <lambdabot2> forall d (a :: * -> * -> *) b c d1. (Arrow a) => a b c -> a (d, (b, d1)) (d, (c, d1))
17:21:21 <dibblego> @type iterate
17:21:23 <lambdabot2> forall a. (a -> a) -> a -> [a]
17:21:29 <dibblego> does lambdabot2 respond to /msg?
17:21:37 <mdmkolbe|work> @version
17:21:38 <lambdabot2> lambdabot 4p525, GHC 6.6 (Linux i686 2.66GHz)
17:21:38 <lambdabot2> darcs get http://www.cse.unsw.edu.au/~dons/lambdabot
17:21:39 <sorear> MarcWeber: it's in base
17:21:50 <sorear> dibblego: Yes.
17:22:00 <sorear> dibblego: You do need to configure yourself to listen
17:22:04 <mdmkolbe|work> @index on
17:22:05 <lambdabot2> bzzt
17:22:06 <dibblego> oh
17:22:06 <sorear> dibblego: /mode dibblego +6
17:22:29 <sorear> mdmkolbe|work: base-2.1, which is newer than lambdabot :)
17:22:36 <sorear> Data.Function
17:22:41 <MarcWeber> sorear: Really ? cool
17:22:41 <dibblego> I thought I was already listening
17:23:08 <chessguy> @tell shapr http://www.cs.yale.edu/homes/hudak-paul/hudak-dir/ACM-WS/position.html looks interesting
17:23:09 <lambdabot2> Consider it noted.
17:26:44 <dibblego> can lambdabot convert a let/in to a where?
17:28:08 <sorear> Not afaik.
17:29:35 <mdmkolbe|work> @uppl let x = y in f x
17:29:36 <lambdabot2> let { x = y} in f x
17:29:42 <dibblego> let (ys,zs) = span p xs' in (x:ys,zs)
17:29:48 <mdmkolbe|work> @uppl f x where x = y
17:29:49 <lambdabot2> Plugin `pointful' failed with: IRCRaised Lib/Pointful.hs:36:24-85: Non-exhaustive patterns in lambda
17:30:06 <mdmkolbe|work> @simplify f x where x = y
17:30:06 <lambdabot2> Unknown command, try @list
17:30:11 <mdmkolbe|work> @pl f x where x = y
17:30:12 <lambdabot2> f = const (const (const y))
17:30:20 <mdmkolbe|work> @. unpl pl f x where x = y
17:30:21 <lambdabot2> f _ _ _ = y
17:31:32 <dibblego> p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
17:35:39 <hpaste>  dons annotated "CICQ history parser (BS impl)" with "better 'dir'" at http://hpaste.org/266#a2
17:38:41 <sorear> dons: hello!
17:38:51 <sorear> dons: lambdabot's dead
17:40:11 <MarcWeber> Can I use $( within [| ? (template haskell)
17:41:17 <shachaf> MarcWeber: Yes.
17:43:38 <dmead> ?yow
17:43:38 <lambdabot2> MMM-MM!!  So THIS is BIO-NEBULATION!
17:43:39 <MarcWeber> shachaf: What's wrong with this line?   let cl_decl = [d| class (HList a) => $( mkName newClassName ) |]
17:43:51 <MarcWeber> I'm getting  parse error on input `$('
17:44:01 <dmead> in
17:44:03 <dmead> ?
17:44:04 <dmead> wheres your in
17:44:07 <MarcWeber> Is this message given if type errors occur?
17:44:08 <dmead> =/
17:44:19 <dmead> no, your syntax is just wrong
17:46:11 <Saizan> ?type mkName
17:46:19 <lambdabot2> Not in scope: `mkName'
17:46:27 <sorear> @join #perl6
17:46:37 <Saizan> ?type Language.Haskell.TH.mkName
17:46:39 <lambdabot2> String -> Language.Haskell.TH.Syntax.Name
17:46:44 <MarcWeber> I'm new to th. So mkName is propably plain wrong.
17:47:26 <Saizan> you need something in the quasimonad
17:47:54 <MarcWeber> Saizan: But that's a type error, not a parse error, right?
17:47:58 <MarcWeber> So the message is bad?
17:58:53 <MarcWeber> data Name = Name OccName NameFlavour  in case NameFlavout of   | NameU Int#			-- A unique local name
17:59:33 <MarcWeber> What is OccName set to? It's superfluous, isn't it? Becuase the Int value identifies the name.
18:01:37 * sorear suspects nobody understands the GHC Renamer anymore
18:03:49 <Saizan> i think that quoting is not a so convenient style to use TH, aside from simple cases
18:08:57 <jfredett> ... Hold up... Monad question
18:08:57 <jfredett> >>= binds a function to the monadic value, so does that mean: (psuedocodeish)
18:08:57 <jfredett> (IO 123) >>= (+ 123) ==> IO (123 + 123)? or is it just  (123 + 123) ?
18:09:52 <shachaf> jfredett: No that's fmap.
18:10:05 <jfredett> :/ then what does >>= do?
18:10:09 <emu> it would be (IO 123) >>= return . (+ 123)
18:10:15 <emu> which is basically fmap
18:10:23 <emu> (or liftM)
18:10:30 <emu> fmap on a monad
18:10:30 <jfredett> the wikipedia article is a bit tough to follow.
18:10:38 <ddarius> m :: IO Int; m >>= (+ 123) is not type correct
18:10:52 <ddarius> :t (m :: IO Int) >>= (+ 123)
18:10:57 <lambdabot2> Not in scope: `m'
18:10:57 <emu> the thing on the RHS of the >>= has to return a monadic value
18:11:03 <shachaf> jfredett: It might be easier working with a monad other than IO.
18:11:10 <ddarius> :t (?m :: IO Int) >>= (+ 123)
18:11:12 <lambdabot2>     Couldn't match expected type `IO b' against inferred type `Int'
18:11:12 <lambdabot2>     In the second argument of `(>>=)', namely `(+ 123)'
18:11:18 <shachaf> jfredett: E.g., [], Maybe, Identity.
18:11:29 <jfredett> [] is a monad?
18:11:34 <shachaf> jfredett: Yes.
18:11:36 <jfredett> i thought it was a list.
18:11:38 <jfredett> ...
18:11:58 <jfredett> wait- are monads like lists? in some confused way?
18:11:59 <shachaf> @instances Monad
18:12:00 <lambdabot2> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
18:12:06 <shachaf> jfredett: Lists are monads.
18:13:06 <jfredett> okay...
18:13:17 <emu> > [1,2,3] >>= return . (+1)
18:13:19 <lambdabot2>  [2,3,4]
18:14:02 <jfredett> so fmap effectively applies some function to a monadic variable?
18:14:13 <emu> > fmap (+1) [1,2,3]
18:14:14 <lambdabot2>  [2,3,4]
18:14:30 <shachaf> jfredett: It applies it to the value(s) inside the monad.
18:14:38 <jfredett> okay
18:14:44 <shachaf> > (+1) `fmap` [1]
18:14:45 <lambdabot2>  [2]
18:14:50 <shachaf> > (+1) `fmap` Just 1
18:14:51 <lambdabot2>  Just 2
18:14:52 <emu> list monad encompasses Non-deterministic computation.
18:15:08 <emu> that means it represents multiple possible computations simultaneously.
18:15:19 <dons> lambdabot2: @part #haskell
18:15:24 <dons> > 1+@
18:15:30 <lambdabot>  Parse error
18:16:00 <jfredett> okay- i guess my real problem with monads lies in the >>= function/operator thing
18:16:25 <emu> :t (>>=)
18:16:27 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
18:17:18 <emu> so you write a function which takes the value 'a' somehow and frobs it into any value 'b' and it has to return it to the monad
18:17:23 <shachaf> jfredett: (>>=) temporarily extracts the inside of the monad and gives it to your function, but only if your function promises that it'll return something wrapped in that same monad eventually.
18:17:32 <jfredett> OH!
18:17:58 <jfredett> so when you do fmap, you return something that isn't in the io monad
18:18:12 <jfredett> but when you do >>= the result is in the io monad
18:18:19 <jfredett> maybe
18:18:23 <jfredett> ?
18:18:26 <shachaf> jfredett: Yes, which is why you have to use return.
18:18:38 <jfredett> frakking brilliant
18:19:02 <emu> fmap f x (on a monad) = x >>= (return . f)
18:19:07 * jfredett 's cat is walking all over my keyboard...
18:19:19 <emu> your cat understands monads?!
18:19:23 <jfredett> i guess so
18:20:35 <jfredett> He says, "whats the problem with monads? They're just monoids on the catagory of endofunctors over some catagor, whats the big deal?" (I don't remember who said it, but thats a quote from someone on here.)
18:20:46 <jfredett> catagor -> catagory
18:20:47 <igli> sorear: ping
18:21:00 <igli> category even ;)
18:21:03 <dons> ?quote endofunctors
18:21:03 <lambdabot> psykotic says: [monads aren't hard] they're just monoids on the category of endofunctors over some category, what's the big deal?
18:21:06 <emu> CATegory?
18:21:14 <igli> catEgory
18:21:28 <emu> not in his case
18:21:31 <igli> hehe
18:21:33 <jfredett> catagory makes more sense
18:21:41 <jfredett> cat, a, gory
18:21:42 <igli> and whoot over my head nm
18:21:49 <igli> yes dear
18:21:53 <emu> he has the monadic cat
18:21:53 <jfredett> i'll email the people at oxford english dictionary
18:22:01 <jfredett> get them to change it
18:22:02 <jfredett> :)
18:22:10 <igli> dons: lambdabot got reloaded?
18:22:47 <shachaf> igli: Yes.
18:23:09 <igli> been dead for a while, waiting for one to come back online, no perm now dons, can you ask one to /j #friendly-coders please?
18:23:28 <igli> ty shachaf
18:23:43 <dons> will do
18:23:46 <dons> ?join #friendly-coders
18:23:48 <igli> thanks
18:23:57 <igli> @join no?
18:23:57 <lambdabot> Not enough privileges
18:24:03 <igli> ta
18:24:31 <dons> Cyclons. Why functional programming matters.
18:24:34 <dons> grr.
18:24:35 <dons> Cylons!
18:24:37 <dons> oh no!
18:24:40 <igli> lol
18:24:54 <igli> lambdabot doesn't love me no more.. oh noez ;)
18:25:07 <igli> Cycles?!
18:25:14 <dons> oh, no op permissions?
18:25:17 <igli> heh np
18:25:27 <igli> more curious about the Cylons tbh
18:25:38 <igli> biddy-biddy.. ok buck! ;)
18:25:53 * igli is getting old
18:25:59 <emu> construct more pylons
18:26:15 <igli> teh sigh
18:28:31 <dons> lovely post, http://programming.reddit.com/info/1y9e2/comments
18:28:32 <lambdabot> Title: Haskell: Preventing irreversible updates from HTTP GET with types (reddit.com)
18:28:59 <dibblego> I was gunna do that
18:39:19 <dibblego> .
18:43:52 <stmartin> I've been going through some past exam papers, and found this little beauty.
18:43:55 <stmartin> bar :: Integer
18:44:00 <stmartin> bar = bar + 1
18:44:09 <stmartin> What is the usual name for bar?
18:44:24 <cbrad> ?hoogle (a -> b) -> [a] -> [b]
18:44:25 <lambdabot> Prelude.map :: (a -> b) -> [a] -> [b]
18:44:25 <lambdabot> Control.Parallel.Strategies.parMap :: Strategy b -> (a -> b) -> [a] -> [b]
18:44:25 <lambdabot> Prelude.scanr :: (a -> b -> b) -> b -> [a] -> [b]
18:44:25 <stmartin> I'm thinking I would call it 'infinity'
18:44:33 <kpreid> stmartin: it is undefined
18:44:36 <cbrad> > 2 + 1
18:44:38 <lambdabot>  3
18:44:55 <cbrad> ?type iterate
18:44:57 <lambdabot> forall a. (a -> a) -> a -> [a]
18:45:03 <ddarius> > let bar :: Integer; bar = bar + 1 in bar
18:45:04 <lambdabot>  Exception: <<loop>>
18:45:08 <kpreid> stmartin: if it weren't defined to be Integer, it would work fine for a suitably lazy number type
18:45:25 <kpreid> stmartin: but that definition you gave yields bottom
18:45:34 <stmartin> :t bottom
18:45:36 <lambdabot> Not in scope: `bottom'
18:45:40 <ddarius> :t undefined
18:45:42 <lambdabot> forall a. a
18:46:30 <stmartin> I noticed ghc gives a stack exception, and hugs segfaults. What implementation does lambdabot use?
18:46:43 <kpreid> ghc
18:47:30 <stmartin> So how it is that lambdabot's ghc is smart enough to give a <<loop>> exception, but ghci gives a stack overflow?
18:48:13 <stmartin> (I'm running v6.6)
18:48:32 <shachaf> stmartin: Mine doesn't.
18:50:32 <stmartin> :t 0
18:50:34 <lambdabot> forall t. (Num t) => t
18:50:51 <stmartin> :t Num
18:50:53 <lambdabot> Not in scope: data constructor `Num'
18:52:19 <kpreid> stmartin: Num is a type class.
18:52:46 <stmartin> Yes, I realise that, I was hoping to see what its instances are.
18:53:02 <stmartin> I'm trying to understand how Haskell knows the type of  0
18:53:05 <kpreid> @src Num
18:53:06 <lambdabot> class  (Eq a, Show a) => Num a  where
18:53:06 <lambdabot>     (+), (-), (*)           :: a -> a -> a
18:53:06 <lambdabot>     negate, abs, signum     :: a -> a
18:53:06 <lambdabot>     fromInteger             :: Integer -> a
18:53:12 <kpreid> @instances Num
18:53:13 <lambdabot> Double, Float, Int, Integer
18:53:13 <stmartin> Ah, that's handy.
18:53:34 <kpreid> 0 has type Num t => t because it's defined to be that way.
18:53:56 <igli> yah odd that @type 2
18:53:59 <kpreid> Specifically, it's defined to be equivalent to (fromInteger <the Integer 0>)
18:54:14 <igli> ah ok
18:55:45 <Cale> (of course, there are quite a few more instances of Num, but they're not in the Prelude)
18:56:47 <stmartin> So is it the language tokenizer that ends up typing 0 as a Num, or is this managed elsewhere?
18:57:36 <kpreid> that's a question of implementation
18:57:43 <Cale> It's generally part of the desugaring process
18:58:26 <Cale> But yeah, the report isn't that picky about how it happens.
18:58:48 <igli> hmm desugar?
18:59:03 <igli> meaning compilation or.. ?
18:59:54 <stmartin> reformatting your indent-sensitive code etc to be something easier to parse, I should imagine.
19:00:54 <igli> heh compilation then ;)
19:01:48 <SamB_XP> desugar means, like, replace do notation with >>= and >>
19:01:58 <AtnNn> Ã©quit
19:02:14 <Cale> and list comprehensions with concatMap and filter
19:02:46 <shachaf> Cale: List comprehensions aren't replaced with (>>=)/return and guard?
19:02:54 <Cale> shachaf: not anymore
19:03:07 <Cale> shachaf: Though it would be nice to have an option to turn that back on.
19:03:33 <Cale> Monad comprehensions were removed in the change from Haskell 1.4 to Haskell 98.
19:04:12 <dibblego> ?hoogle listToMaybe
19:04:12 <lambdabot> Maybe.listToMaybe :: [a] -> Maybe a
19:04:31 <dibblego> > listToMaybe [1..10]
19:04:32 <lambdabot>  Just 1
19:04:37 <dibblego> > listToMaybe []
19:04:38 <lambdabot>  Nothing
19:04:44 <dibblego> ?src listToMaybe
19:04:44 <lambdabot> listToMaybe []        =  Nothing
19:04:44 <lambdabot> listToMaybe (a:_)     =  Just a
19:05:03 <igli> er head?
19:05:16 <igli> @src head
19:05:17 <lambdabot> head (x:_) = x
19:05:17 <lambdabot> head []    = undefined
19:05:22 <igli> hmm
19:13:49 <sorear> re.
19:14:06 <sorear> igli: pong
19:14:18 <igli> hi sorear :-)
19:14:21 <sorear> dons: ping, what happened to lambdabot?
19:14:23 <igli> lambdabot was down
19:14:53 <dons> sorear: url module timed out
19:15:01 <dons> and the bot didn't recover for some reason
19:16:14 <igli> yeah get that with fT
19:16:19 <dons> does anyone have suggestions on how this material should best be structured,
19:16:20 <dons>   http://haskell.org/haskellwiki/Blog_articles
19:16:21 <lambdabot> Title: Blog articles - HaskellWiki
19:16:28 <dons> its too big and hard to navigate
19:17:01 <igli> er i'd make it into a cloud
19:18:06 <dons> i'm not sure clouds are wikimedia friendly
19:18:38 <jfredett> omg, Monads are just like group theory, only for catagorys. pfft, that makes everything easier.
19:18:39 <jfredett> :/
19:18:59 <igli> thingies about thingies? ;)
19:19:00 <Cale> well, monoid theory :)
19:19:21 <jfredett> Cale, Groups, Monoids, it's all  Abstract Algebra to me.
19:19:22 <jfredett> :)
19:19:33 <SamB_XP> how are monads like monoids
19:19:34 <Cale> A monad is just a monoid object in the category of endomorphisms on a category.
19:19:59 <Cale> Whereas a monoid is a monoid object in the category of sets.
19:20:07 <jfredett> right
19:20:30 <jfredett> but that means theres a morphism from groups -> monoids -> monoid objects -> monads
19:20:58 <jfredett> so theres a chance I might understand them on a deeper level
19:21:00 <jfredett> someday
19:21:19 <Cale> Well, the chains of generalisation look like:  groups -> monoids -> monoid objects <- monads.
19:21:39 <jfredett> Cale, details details..
19:21:40 <jfredett> :P
19:24:32 * jfredett digs around for his abstract algebra bible
19:26:52 <peter_12> In "Yet Another Haskell Tutorial" in the Types Basics section all of a sudden they spring :t 'c' without explaining what :t means. What is this syntax?
19:27:11 <sorear> GHCi/hugs special command
19:27:15 <sorear> not haskell
19:27:22 <peter_12> ahh
19:27:35 <peter_12> these special commands always start with colon?
19:27:35 <shachaf> peter_12: Short for :type.
19:27:40 <shachaf> peter_12: Yes.
19:27:44 <peter_12> great thanks
19:27:57 <peter_12> it is just for the interactive shell?
19:28:06 <shachaf> peter_12: Yes.
19:28:12 <peter_12> got it
19:28:20 <peter_12> the tutorial is good. Enjoyable read
19:29:27 <Cale> peter_12: :t is your friend :) -- figuring out the type system is probably the fastest way to become comfortable with Haskell.
19:30:17 <peter_12> I haven't even installed Haskell yet ;)
19:31:00 <peter_12> I don't even know what I would do with Haskell yet
19:31:04 <peter_12> I can't use it for work
19:31:45 <shachaf> peter_12: "Enlarge your hat size!"
19:31:49 <sorear> most(?) of us can't, since we aren't professional programmers :)
19:40:17 <peter_12> it is possible to invent new types or type classes in Haskell?
19:41:02 <Korollary> yes
19:41:16 <shachaf> peter_12: "data ..."/"newtype ..."/"type ..."/"class ..."
19:41:30 <peter_12> ok now things are getting interesting
19:41:52 <peter_12> sort of a C struct-like thing?
19:41:53 <dons> hehe. it'd be pretty crippling if you couldn't declare your own types :-)
19:42:05 <peter_12> or more like an OOP class?
19:42:08 <dons> data is a bit like a C struct, and a C enum, and some other things not in C.
19:42:22 <dons> data T = T { foo :: Int , bar :: Char } -- like a C struct
19:42:34 <dons> data T = A Int | B Char | C -- not like a C struct
19:42:49 <dons> data List a = Nil | Node a (List a) -- also not (a recursive type)
19:43:02 <peter_12> lots to learn
19:43:03 <peter_12> thanks
19:43:20 <dons> class is a different thing again. its a way of grouping types with common operations, amongst other things.
19:43:56 <dons> so Eq is the set of types that implement (==)
19:44:13 <dons> hehe, http://www.youthink.com/quiz.asp?action=take&quiz_id=9827.
19:44:25 <dons> apparently i've a northeastern accent
19:44:38 <peter_12> I just got through that part of the tutorial and then started gettting the drift that I might be defining my own classes one day
19:44:57 <dons> yeah, you do when you find you have a common interface a number of types provide
19:45:03 <dons> and you want to allow any one of those types to be used.
19:45:19 <dons> so, where you'd use an interface in Java, to abstract over particular types
19:47:07 <dons> peter_12: it must be exciting finding a whole new land of programming ideas!
19:47:18 <peter_12> of course
19:47:28 <peter_12> I just need a project to motivate me to dive deeper
19:47:37 <dons> yeah. that's a good idea.
19:47:57 <dons> implementing an interpreter for a small language is a good way to cover many of the core language concepts
19:48:10 <dons> functions, data types, pattern matching and so on
19:48:28 <peter_12> haskell is big in financial analysis, isn't it?
19:48:43 <dons> its growing in use, at least.
19:49:15 <dons> in particular, Credit Suisse and Deutsche Bank state publically they use it, though there's a few others.
19:49:39 <peter_12> wow. They knew I have a Canadian accent
19:50:21 <dons> oh huh. that's interesting.
19:50:49 <peter_12> eh? ;)
19:57:37 <peter_12> square = \x -> x*x    is different from   square x = x*x ?
19:57:59 <_dolio> Due to the monomorphism restriction.
19:58:38 <peter_12> restriction on what?
19:58:50 <dolio> The type.
19:59:01 <peter_12> of x or of square?
19:59:13 <dolio> 'square = \x -> x*x' will have a monomorphic type, such as Integer -> Integer.
19:59:34 <dolio> While 'square x = x * x' will have 'Num a => a -> a'.
19:59:41 <dolio> In the absense of explicity annotations, that is.
19:59:57 <peter_12> it assumes Integer for the former?
20:00:09 <dolio> Well, Integer is the default for Num, I believe.
20:00:14 <shachaf> @ty let square = \x -> x * x in square
20:00:16 <lambdabot> forall a. (Num a) => a -> a
20:00:39 <sorear> nobody implements the MR exactly right, of course.
20:00:54 <sorear> haskell is too complicated to implement correctly
20:01:14 <peter_12> does that cause grief?
20:01:19 * sorear grumbles, wishes the committee had thought of implementation issues
20:01:48 <dolio> Does ghc not bother with the MR in a let?
20:02:24 <dolio> Or, anything that isn't a top-level binding, I suppose?
20:02:58 <sorear> Looks like.
20:03:49 <dolio> peter_12: Anyhow, it bites people from time to time, although if you annotate your functions (which is encouraged), I doubt it'd come up much.
20:04:06 <dolio> And if you want, you can turn it off with -fno-monomorphism-restriction in GHC.
20:04:30 <peter_12> ahh
20:05:50 <dolio> Well, as expected, I have the newscaster accent.
20:06:47 <Cale> I have a "Canadian" accent.
20:06:47 <dons> sorear is melodramatic.
20:06:50 <peter_12> OK now I need to install Haskell. Any recommendation for OS X? (no darwin ports)
20:07:09 <dons> Cale: huh. so it does seem to get that right. but i'd have thought a .au accent was closer to canadian than 'northeastern'
20:07:27 <dons> i wonder where the difference is  (i had to click 'different' for all but one of the questions, i noticed)
20:07:32 <Cale> dons: I don't know. There are some interesting differences :)
20:08:10 <shachaf> peter_12: PowerPC or Intel?
20:08:18 <peter_12> Intel
20:08:41 <Cale> I don't know what "northeastern" means exactly, but there's a fairly large set of differences between Australian and Canadian accents :)
20:08:50 <shachaf> peter_12: http://haskell.org/ghc/dist/6.6.1/ghc-6.6.1-i386-apple-darwin.tar.bz2 looks like what you want, then.
20:08:52 <lambdabot> http://tinyurl.com/23w4ds
20:08:56 <Cale> For example, we pronounce cot and caught the same way.
20:09:00 <shachaf> peter_12: (Though it's not in a package.)
20:09:15 <Cale> (and we pronounce our r's :)
20:09:56 <dons> oh, ok. cot and caught are different.
20:10:03 <dons> cot/hot caught/thought
20:10:33 <Cale> court sounds completely different from either of those
20:10:56 <dons> oh right. tennis court/caught a thief -- same sound.
20:11:37 <Korollary> Is this a computer trying to tell the difference?
20:12:03 <dons> a series of questions about vowel sounds, basically
20:12:06 <Cale> Korollary: Well, it actually is supposed to work for North America, and it does it based on a questionnaire.
20:12:13 <Korollary> Ah
20:12:32 <dons> and it dumps irish, australians and english into 'northeastern' NYC-area accents
20:12:50 <dons> but spots canadians correctly
20:13:47 <Korollary> http://www.pbs.org/speak/seatosea/americanvarieties/map/map.html
20:13:48 <lambdabot> Title: Do You Speak American . Sea to Shining Sea . American Varieties . Mapping | PBS
20:13:52 <dolio> I'm not sure I see the resemblance between Northeastern and British/Australian.
20:14:09 <dolio> But then, the latter doesn't seem that close to Canadian, either.
20:14:14 <Korollary> I don't know an american who did well at the test I posted.
20:17:02 <Korollary> Except for the extreme-southern accents, I can't spot anything.
20:19:39 <dolio> Wow, I only got four right.
20:20:45 <Korollary> dolio: where are you from?
20:20:51 <dolio> Midland.
20:22:17 <dolio> I must confess, the people marked as Western sound about like people here.
20:22:36 <dolio> As do the actual midland people, of course.
20:23:24 <Korollary> heh. "Actors and professional communicators (including some from the Midlands!) often take classes in "accent reduction" to lose any regional or social sounds in their speech. "
20:24:22 <peter_12> install problem...dyld: Library not loaded: GNUreadline.framework/Versions/A/GNUreadline but I know readline is on my computer and used for ruby
20:24:34 <dolio> You mean, some people from the Midlands take classes to sound *more* Midland? :)
20:24:49 <Korollary> Less Midland
20:25:08 <Korollary> Even Midland is too Midland heh
20:25:14 <dolio> :)
20:25:17 <Cale> peter_12: hmm...
20:26:34 <dolio> I suppose my other problem with that test was that I had no idea where to put the mid-Atlantic people.
20:26:41 <dolio> I guess I don't know many people from that area.
20:26:53 <dons> peter_12: missing path to readilne, i suspect.
20:26:55 <peter_12> readline is even where it is supposed to be
20:27:01 <dons> peter_12: google for this, seems to be a common problem on the mac
20:27:02 <Cale> peter_12: can you do an ldd?
20:27:13 <peter_12> ldd?
20:27:24 <peter_12> what is that?
20:27:32 <Cale> To see where the binary expects its libraries to be
20:27:48 <peter_12> ldd is not a command on my computer
20:27:50 <Cale> hmm
20:27:51 <Cale> okay
20:27:56 <peter_12> I'll look on google
20:28:38 <Cale> oh, apparently: otool -L <binary>
20:29:48 <Cale> Should tell you where it's looking for the library.
20:31:30 <peter_12> otool takes an object file as it's input
20:33:18 <peter_12> Cale: Thanks for the help. I'll fight with this tomorrow
20:33:28 * peter_12 hates installing software
20:34:02 <Cale> You're sure that otool doesn't work when applied to an executable?
20:34:05 <Cale> hmm
20:34:08 <Cale> oh well
20:49:43 <dons> anyone around who drinks yerba mate?
20:54:24 <Boney> I know someone who has tried it.
20:54:24 <dibblego> yerba mate?
20:54:24 <dons> i've got a big packet here, and am pondering how best to brew it up.
20:54:24 <Boney> yeah.
20:54:24 <dons> see if its less caffeine-ish than green tea
20:54:24 <Boney> *shrug*
20:54:24 <dons> ah, looks like the key is to use 70-80 degree water, not boiling.
20:54:24 <cbrad> http://en.wikipedia.org/wiki/Yerba_mate
20:54:24 <lambdabot> Title: Yerba mate - Wikipedia, the free encyclopedia
20:54:24 <dons> ah ha.
21:03:15 <cbrad> ?src enumFromTo
21:03:16 <lambdabot> Source not found. Take a stress pill and think things over.
21:03:52 <dons> its in GHC.Enum
21:04:22 <dibblego> ?src GHC.enumFromTo
21:04:22 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
21:04:26 <dibblego> ?src GHC.Enum.enumFromTo
21:04:26 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
21:04:44 <dibblego> lambdabot doesn't have GHC.Enum loaded?
21:05:01 <dons> not loaded into its @src database
21:05:05 <dibblego> ok
21:05:26 <dons> hmm. the yerba mate is kind of grassy, and greenish/cloudy. tastes ok.
21:06:07 <dons> ?temp its too cold!
21:06:08 <lambdabot>   now 14.5°, min 6.5°, max 15.3°, rain 0.8mm, wind 24km/h SSE
21:07:51 <dibblego> ?temp haha, Stinky Sydney Sucks!
21:07:51 <lambdabot>   now 14.5°, min 6.5°, max 15.3°, rain 0.8mm, wind 24km/h SSE
21:07:59 <dons> hehe
21:08:20 <dons> dibblego: they've just started the 'visit Queensland' ads down here. seems they always wait till the first big cold week of winter
21:08:25 <dibblego> I have a cold though, so I lose
21:08:45 <dibblego> it's cold up here too! though currently 20C
21:17:09 <Boney> dons: part of my family migrate north every winter.
21:17:33 <dons> makes sense :-)
21:17:58 <shapr> Does @temp take airport designations?
21:18:19 <dons> no, but a generalised @temp would be cool
21:18:20 <shapr> Oh, I guess not.
21:18:23 <dons> if someone knows of a database
21:18:29 <shapr> The NOAA has one.
21:19:42 <dibblego> temp :: Latitude -> Longitude -> Int
21:19:54 <shapr> Nah, -> Temp
21:19:58 <shapr> It should include units.
21:20:00 <dibblego> mk
21:20:00 <sjanssen> IO Temp
21:20:03 <shachaf> dibblego: Wouldn't it be IO Int/IO Temp?
21:20:03 <dibblego> agreed
21:20:10 <dibblego> yes that too
21:20:20 <dibblego> or, Time
21:20:34 <dibblego> temp :: Latitude -> Longitude -> Time -> Temp
21:20:51 <dibblego> > temp here tomorrow -- weather forecasting!
21:20:52 <lambdabot>   Not in scope: `tomorrow'
21:21:30 <shapr> In Birmingham it's 26Â°C right now, but it was was 34Â°C earlier today.
21:22:20 * shapr DCCs some thermal units to dons
21:22:37 <shachaf> dibblego: How about temp :: Point -> Time -> Temp or temp :: SpaceTime -> Temp ?
21:22:43 <dons> cheers, shapr
21:22:50 <dibblego> shachaf, I like it :)
21:23:08 <shapr> I just had fun doing init=/bin/sh , mount / -o remount,rw , nano /etc/shadow
21:28:48 <sorear> yeah, that's fun :)
21:32:15 <nburlett> 'evening
21:34:10 <nburlett> I'm trying to generate random array indexes
21:36:14 <nburlett> should I make an instance of Random for (Ix a, Ix b)?
21:37:42 <newsham> exec("/i386/init", argv);
21:52:18 <jfredett> is there a built in factorial function?
21:52:26 <jfredett> or do I have to write one?
21:52:32 <shapr> fac n = product [1..n]
21:52:45 <jfredett> cool
21:53:05 <whisky_> blackdog frequent here anymore?
21:53:14 <nburlett> > let fac n = product [1..n] in fac 10
21:53:15 <lambdabot>  3628800
21:53:20 <dibblego> ?seen blackdog
21:53:20 <lambdabot> I haven't seen blackdog.
21:53:25 <nburlett> > let fac n = product [n..1,-1] in fac 10
21:53:26 <lambdabot>  Parse error
21:53:35 <shapr> whisky_: Only seen him once in the last several months. Wasn't he in Thailand for awhile or something?
21:53:47 <shapr> After his stint in Qatar ...
21:54:00 <dons> whisky_: yeah, he's around, but only rarely.
21:54:07 <ddarius> I'd like to go to Thailand.
21:54:22 <shapr> I'd like to hang out with blackdog more often.
21:54:35 <nburlett> > let fac n = product [n,(n-1)..1] in fac 10
21:54:37 <lambdabot>  3628800
21:54:52 <dibblego> whisky_, /nickserv info blackdog
21:54:56 <whisky_> have you seen him use any ranzco connections lately?
21:55:21 <shapr> I thought only his bro was doing ranzco?
21:55:33 <whisky_> yeah i'm an efnet person, scew services.
21:55:43 <whisky_> shapr: he was fired.
21:55:53 <shapr> Er, Chris was?
21:55:59 <whisky_> yes
21:56:09 * shapr is surprised.
21:56:21 <shapr> whisky_: We should probably take this to #haskell-blah, since this channel is publically logged.
21:56:45 <whisky_> yeah, I found the logs... thats how I got here.
21:58:15 <sorear> dibblego: /nickserv is non-standard; ircii doesn't have it
21:58:21 <sorear>  /msg nickserv ...
22:12:53 <setuid_w00t> I am trying to learn a bit about IO in haskell through implementing some basic stuff.  What I am trying to do right now is write a grep program.  So essentially, what I want to do is treat a file as a list of lines and then filter the list.
22:13:11 <dibblego> ?type lines
22:13:13 <lambdabot> String -> [String]
22:13:16 <ddarius> @google Haskell grep
22:13:20 <lambdabot> http://www.freesoftwaremagazine.com/articles/haskell
22:13:20 <lambdabot> Title: Haskell
22:13:21 <setuid_w00t> I was getting there :)
22:13:23 <dibblego> ?type readFile
22:13:24 <lambdabot> FilePath -> IO String
22:15:23 <setuid_w00t> If I do lines . (readFile filename)  and then I try to filter that, will that read the entire file into memory all at once or is it on demand as the filter goes through the list?
22:15:35 <dibblego> no, laziness
22:16:09 <lucca> so, on-demand as something reads the list coming out of the filter
22:16:12 <dons> :t \f -> interact (unlines . f . lines)
22:16:14 <lambdabot> ([String] -> [String]) -> IO ()
22:16:15 <lucca> and only as far as it gets read
22:16:43 <dons> yeah, though you might find using lazy bytestrings a bit more efficient -- yet still read-on-demand
22:16:44 <setuid_w00t> ok
22:17:34 <setuid_w00t> I don't care about the last 10% efficiency.  I just wanted to make sure that it wasn't going to build up the entire file in memory before filtering.
22:17:49 <dons> nah, its not a strict language ;)
22:18:09 <dons> its probably worth 2 or 3x in speed to use a lazy bytestring for grepping, than to use [Char].
22:18:17 <setuid_w00t> I figured that was the case, but I just wanted to make sure
22:18:34 <setuid_w00t> I'll have to learn about bytestrings then  :)
22:18:37 <dons> iirc, filtering a terabyte took about twice as long with [Char], than a lazy bytestring. and lazy bytestring one liners were about 3-5% slower than grep itself
22:18:55 <jfredett> hmm... methinks PE problem 17 will be difficult...
22:20:06 <setuid_w00t> jfredett: what is PE problem 17?
22:20:23 <jfredett> "How many letters are needed to count all the numbers from 1 to 1000"
22:20:30 <setuid_w00t> jfredett: What are PE problems in general
22:20:42 <jfredett> Project Euler
22:20:49 <jfredett> projecteuler.net
22:20:54 <Olathe> jfredett: 2.
22:21:13 <jfredett> Olathe: ?
22:21:22 <Olathe> !
22:21:27 <lucca> base 1
22:21:39 <Olathe> Base 1 has one number.
22:21:42 <Olathe> It's funny.
22:22:13 <jfredett> no- base 1 has 1 symbol- it has all the numbers, represented as:
22:22:16 <jfredett>  
22:22:19 <jfredett> for zero
22:22:28 <jfredett> i for 1, ii for 2, ...
22:22:31 <Olathe> 09 = 9, right ?
22:22:36 <Olathe> So, 00 = 0.
22:22:52 <jfredett> okay
22:23:02 <Olathe> The tally system isn't a base.
22:23:20 <setuid_w00t> Is there a way to tell where a function is defined, so that I know where to look for the documentation?
22:23:23 <jfredett> i disagree.
22:23:24 <lucca> http://www.xkcd.org/c271.html is related
22:23:26 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
22:23:29 <lucca> (loosely)
22:23:35 <jfredett> Hoogle?
22:23:37 <Olathe> jfredett : What is the definition of base ?
22:23:54 <bos> setuid_w00t: not really.
22:24:11 <jfredett> Sum(a*(b^k)) for some range of k's
22:24:38 <bos> lambdabot has @src, and @hoogle will point you at a module that contains the name. but that module isn't guaranteed to define it.
22:24:45 <Olathe> Alright, so how does base 1 give anything other than zero, when a must be zero ?
22:24:53 <jfredett> I suppose in that case, a would have to be less than b
22:25:17 <jfredett> but my point is, any number (except for zero) can be represented by a series of one's
22:25:22 <jfredett> and I'd consider that a base.
22:25:34 <Olathe> It's not really a base. It's called the tally system.
22:25:41 <jfredett> zero would be represented by the absence of anything
22:25:51 <jfredett> i dunno, I must just have a looser definition of base
22:25:58 <lucca> hmmm
22:26:04 <lucca> well, for base one
22:26:10 <jfredett> I don't suppose it matters much, Who uses base one anyway?
22:26:34 <lucca> take a number 1111, which is 1x1^3 + 1x1^2 + 1x1^1 + 1x1^0
22:26:38 <Olathe> Lots of people use tallies.
22:26:39 <lucca> aka four
22:26:48 <Olathe> lucca: Then that's the same as 111.
22:26:58 <lucca> how do you figure?
22:27:07 <dibblego> is there a function that will execute all prop_* functions in a source file and produce some kind of QC report?
22:27:29 <Olathe> lucca: In bases, you have a symbol at every position, you just ignore the leading zeroes normally.
22:27:30 <jfredett> you mean like a unit test? as in
22:27:39 <olsner> shouldn't "base 1" have only the zero?
22:27:54 <jfredett> it executes: test_foo, test_bar, ...
22:27:56 <Olathe> lucca: So, you have a symbol at every position there, and you only have the symbol 1, so it must be something different.
22:28:05 <dibblego> jfredett, yes, but prop_ is the QC convention
22:28:12 <Olathe> lucca: ...11111111.
22:28:16 <lucca> hmmmm
22:28:24 <lucca> and fractions get even more problematic
22:28:32 <jfredett> you shouldn't need it, you could write an HOF for that
22:28:39 <jfredett> although
22:28:42 <jfredett> I suppose thats the problem
22:28:50 <jfredett> hmm
22:28:57 <bos> dibblego: http://www.cs.chalmers.se/~rjmh/QuickCheck/quickcheck
22:29:25 <olsner> @pl (\f x -> f (f x))
22:29:25 <lambdabot> join (.)
22:29:46 <olsner> (join (.)) (+) 0
22:29:51 <olsner> > (join (.)) (+) 0
22:29:53 <lambdabot>      Occurs check: cannot construct the infinite type: b = b -> b
22:29:53 <lambdabot>     Probabl...
22:29:53 <dibblego> bos, that looks useful, thanks
22:30:21 <olsner> > (join (.)) (+1) 0
22:30:22 <lambdabot>  2
22:30:41 <dibblego> cbrad, foo
22:30:51 <olsner> > let s = (join (.)) in s s s s (+1) 0
22:30:52 <lambdabot>  65536
22:31:10 <olsner> > let s = (join (.)) in s (s (s (s (+1) 0)))
22:31:11 <lambdabot>   add an instance declaration for (Num (b -> b))
22:31:33 <olsner> > let s = (join (.)) in s (s (s (s (+1)))) 0
22:31:35 <lambdabot>  16
22:38:27 <brad_> hi
22:38:38 <brad_> is there anything like conact in a monadic context?
22:38:42 <brad_> like concatM?
22:38:49 <brad_> i know this doesn't exist per se
22:39:24 <dolio> join?
22:39:41 <dolio> Or sequence?
22:40:08 <brad_> hmmm dolio - join might be what i am looking for!
22:40:31 <brad_> i have a function that creates IO [[(FilePath,ClockTime)]]
22:40:45 <brad_> would like to make that into IO [(FilePath,ClockTime)]
22:40:56 <brad_> more or less flatten the double list to a single
22:40:58 <dolio> Oh. That would be 'fmap concat'
22:41:13 <dolio> Or liftM rather than fmap.
22:41:19 <brad_> cool! i will check that out!
22:42:00 <olsner> why is liftM better?
22:42:00 <brad_> thanks dolio!
22:42:11 <olsner> fmap and liftM seem to do the same thing
22:43:18 * nburlett is confused
22:43:19 <nburlett> Illegal instance declaration for `Arbitrary Myarray'
22:43:21 <emu> :t fmap
22:43:23 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
22:43:24 <emu> :t liftM
22:43:26 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:45:00 <dolio> liftM is better in this case because it has a Monad constraint, so it doesn't bloat your type signature.
22:45:32 <dolio> Or, I suppose it doesn't really matter in this case, but in general.
22:46:04 <brad_> i'm a little confused as to what liftM does, does anyone have a trivial example?
22:46:04 <dolio> They do do the same thing, though.
22:46:04 <brad_> :t liftM
22:46:38 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
22:46:58 <dolio> It takes a function and makes it work on monadic values.
22:47:04 <dolio> fmap (+1) (Just 1)
22:47:14 <dolio> > liftM (+1) (Just 1)
22:47:16 <lambdabot>  Just 2
22:47:49 <brad_> ah, so i could say "liftM concat" in my case
22:47:54 <dolio> Right.
22:47:58 <brad_> ahhhhhhh
22:48:02 <brad_> now i see
22:48:03 <dolio> Since you want to concat the [[a]].
22:48:04 <brad_> thanks!
22:48:13 <dolio> liftM just handles the monad plumbing.
22:48:58 <brad_> very interesting
22:49:05 <brad_> well i will go off and try that!
22:49:11 <brad_> thanks dolio, you have been a big help!
22:50:24 <nburlett> does anyone know what "Illegal instance declaration"  means?
22:50:44 <nburlett> and how I can fix it?
22:52:02 <dons> slides from the sydney-area FP group meeting this week are online, http://www.comp.mq.edu.au/~asloane/pmwiki.php/SAPLING/SAPLING071
22:52:03 <lambdabot> Title: &nbsp; : SAPLING - SAPLING 071 browse
22:52:18 <dons> including fusion, index type families, and other stuff
22:53:17 <nburlett> ?paste
22:53:17 <lambdabot> Haskell pastebin: http://hpaste.org/new
22:54:17 <hpaste>  nburlett pasted "instance issue" at http://hpaste.org/274
22:55:11 <hpaste>  nburlett annotated "instance issue" with "(no title)" at http://hpaste.org/274#a1
22:55:46 <nburlett> can anyone help?
22:58:45 <dolio> nburlett: -fglasgow-exts, I belive.
22:58:59 <dolio> Otherwise you can't use type synonyms to declare instances.
22:59:05 <nburlett> hm
22:59:55 <dolio> At least, that's what that error looks like. I'm not very familiar with quickcheck, so I don't know if the rest is kosher or not.
23:00:10 <dibblego> it is
23:01:04 <nburlett> what's the magic to use -fglaskgo-exts in the source code?
23:01:31 <Cale> {-# OPTIONS_GHC -fglasgow-exts #-}
23:08:31 <nburlett> cool, thanks
23:10:01 <dibblego> can lambdabot convert a list comprehension to concatMap/filter?
23:10:40 <dons> no, it doesn't have that desugarer, afaik
23:10:51 <dons> would be a fairly small job to add -- the code is in ghc and pretty simple to use
23:12:11 <sjanssen> dibblego: that should be very easy to write -- start with Plugin.Undo
23:12:54 <brad_> okay here is another question - i am using System.getArgs to get an arg i will use as an Integer. but from the world of the command line it is ... "untyped" - how do i make sure the arg was given as an Integer, not a word or punctuation etc??
23:13:17 <quicksilver> sjanssen: or desugar first to monad notation and then use Undo to finish off
23:13:49 <quicksilver> brad_: all . isDigit, perhaps?
23:13:55 <quicksilver> > all . isDigit "1234"
23:13:56 <lambdabot>  Couldn't match expected type `Char' against inferred type `[Char]'
23:14:02 <quicksilver> > all . isDigit $ "1234"
23:14:03 <lambdabot>  Couldn't match expected type `a -> Bool'
23:14:03 <Cale> brad_: Well, getArgs is going to give you a string, and it's up to you to decide how to parse it. You can use reads.
23:14:11 <quicksilver> > all isDigit "1234"
23:14:12 <lambdabot>  True
23:14:15 <quicksilver> > all isDigit "1a234"
23:14:16 <lambdabot>  False
23:14:24 <dons> you attempt to parse it as an Integer, and catch the failure to parse in a monad
23:14:37 <brad_> thanks quicksilver, Cale!
23:14:41 <Cale> > reads "1234abc" :: [(Integer, String)]
23:14:42 <lambdabot>  [(1234,"abc")]
23:14:46 <Cale> > reads "x1234abc" :: [(Integer, String)]
23:14:48 <lambdabot>  []
23:14:56 <dons> f | [(x, "")] <- reads s = (x :: Integer) | otherwise = 10
23:15:26 <brad_> awesome guys!
23:15:47 <brad_> thanks!
23:15:52 <Cale> no problem :)
23:20:29 <dibblego> ?check \xs -> \ys -> intersect (xs :: [Int]) (ys :: [Int]) == filter (\y -> y `elem` ys) xs
23:20:30 <lambdabot>  OK, passed 500 tests.
23:21:04 <dibblego> why is intersectBy written as a list comprehension?
23:21:20 <dibblego> ?check \xs -> \ys -> intersect (xs :: [Int]) (ys :: [Int]) == filter (`elem` ys) xs
23:21:22 <lambdabot>  OK, passed 500 tests.
23:23:35 <ob> quick question... I'm using Parsec to parse a list of numbers separated by dots
23:23:45 <ob> and I have something like: rev = digit >> char '.' >> many1 (digit <|> char '.')
23:24:07 <ob> rev :: Parser String
23:24:21 <dibblego> ?where yaht
23:24:21 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
23:24:26 <setuid_w00t> I can run my program using  ghci, :load regexp.hs, :main "myParam"      but if I try to do "ghc regexp.hs" I get linker errors.  Is that normal?
23:24:39 <ob> the result is of course the last digit
23:26:46 <hpaste>  setuid_w00t pasted "Link error running ghc" at http://hpaste.org/275
23:33:03 <Cale> setuid_w00t: --make
23:33:59 <Cale> ghci is smart about choosing packages, you have to add the --make command line param to ghc to get that.
23:35:44 <Cale> I suspect that adding  -package regex-compat  would also work.
23:37:07 <setuid_w00t> Cale: Thanks.  That was it
23:37:17 <Cale> great
23:59:27 <dmead> > [ (x/y) | x <- [1..10], y <- [11..20]]
23:59:29 <lambdabot>  [9.090909090909091e-2,8.333333333333333e-2,7.692307692307693e-2,7.1428571428...
23:59:42 <dmead> > [ (x `div` y) | x <- [1..10], y <- [11..20]]
23:59:43 <lambdabot>  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0...
23:59:52 <dmead> > [ (y `div` x) | x <- [1..10], y <- [11..20]]
23:59:53 <lambdabot>  [11,12,13,14,15,16,17,18,19,20,5,6,6,7,7,8,8,9,9,10,3,4,4,4,5,5,5,6,6,6,2,3,...
