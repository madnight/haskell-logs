00:03:22 <notadev> lol
00:03:30 <notadev> not the one true path LeCamarade?
00:09:50 <chaoslawful> @unpl map.sqrt
00:09:50 <lambdabot> (\ c -> map (sqrt c))
00:10:43 <chaoslawful> > map.sqrt$[1,2,3]
00:10:48 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
00:11:04 <chaoslawful> @t map.sqrt
00:11:04 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
00:11:14 <chaoslawful> @type map.sqrt
00:11:16 <lambdabot> forall a b. (Floating (a -> b)) => (a -> b) -> [a] -> [b]
00:11:38 <chaoslawful> > (map.sqrt) [1,2,3]
00:11:39 <lambdabot>  Couldn't match expected type `a -> b' against inferred type `[a1]'
00:11:59 <chaoslawful> > (map.sqrt) [1,2,3]::Floating
00:12:00 <lambdabot>      Class `Floating' used as a type
00:12:00 <lambdabot>     In the type `Floating'
00:12:00 <lambdabot>     In an exp...
00:14:49 <chaoslawful> > (\x->map sqrt x)[1,2,3]
00:14:51 <lambdabot>  [1.0,1.4142135623730951,1.7320508075688772]
00:14:59 <chaoslawful> @pl (\x->map sqrt x)
00:14:59 <lambdabot> map sqrt
00:15:08 <chaoslawful> ...
00:18:09 <chaoslawful> \unpl (+).(*)
00:18:17 <chaoslawful> @unpl (+).(*)
00:18:17 <lambdabot> (\ c -> (+) ((*) c))
00:18:52 <chaoslawful> @src map
00:18:52 <lambdabot> map _ []     = []
00:18:52 <lambdabot> map f (x:xs) = f x : map f xs
00:18:57 <chaoslawful> @src foldl
00:18:58 <lambdabot> foldl f z xs = lgo z xs
00:18:58 <lambdabot>     where lgo z []     =  z
00:18:58 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
00:19:13 <chaoslawful> @src tails
00:19:13 <lambdabot> tails []         = [[]]
00:19:13 <lambdabot> tails xxs@(_:xs) = xxs : tails xs
00:22:40 <HairyDude> someone must know this: how do I get bibtex to sort "Simon Peyton Jones" under P?
00:23:06 <ivanm> Simon {Peyton Jones}
00:23:07 <ivanm> I think
00:23:09 <ivanm> try that
00:23:17 <HairyDude> tried that, still sorted under J
00:23:48 <ivanm> hmmm...
00:24:00 <wolverian> Peyton~Jones maybe?
00:24:08 <HairyDude> oh, actually it works... just won't let you add "et al." after it
00:24:16 <wolverian> gah!
00:24:21 <wolverian> "and et al."
00:25:11 <ivanm> heh
00:26:57 * HairyDude plumps with Simon {Peyton Jones et al.}
00:27:45 <LeCamarade> notadev: Nope. No GPG key. By intention.
00:27:51 <LeCamarade> Oops.
00:37:31 <notadev> hmm how do i type code to exec into lambdabot?
00:37:44 <wolverian> > 2+2
00:37:45 <lambdabot>  4
00:37:48 <notadev> > reverse $ take 2 $ reverse "OCaml"
00:37:49 <lambdabot>  "ml"
00:37:55 <notadev> ty wolverian
00:38:24 <notadev> what does $ do there; concat fun application?
00:38:24 <LeCamarade> > map Char.toUpper $ reverse $ take 2 $ reverse "OCaml"
00:38:26 <lambdabot>  "ML"
00:38:43 <notadev> thanks LeCamarade
00:39:02 <LeCamarade> Essentially, you can think of it as a one-sided parenthesis. Goes from where it is to the end of the expression.
00:39:13 <notadev> ah ic
00:39:54 <[LeCamarade]> ^^ means I'm stepping away for a while ... :o)
00:40:23 <notadev> heh np :)
00:47:57 <HairyDude> > reverse `id` take 2 `id` reverse "OCaml"
00:48:04 <lambdabot>  Couldn't match expected type `[a] -> [a]'
00:48:14 <HairyDude> must have the wrong fixity
00:50:12 <Cale> > reverse . take 2 `id` reverse "OCaml"
00:50:12 <lambdabot>      precedence parsing error
00:50:13 <lambdabot>         cannot mix `(.)' [infixr 9] and `id' [i...
01:05:59 <Thunder> Hi, does anybody know where to get the network6 patch? I get: Invalid repository:  http://darcs.serpentine.com/network6
01:10:36 <mdmkolbe|home> How do I convince GHC that an infix type constructor should be printed as an infix type constructor?  (Heh, maybe we need Show for types).  e.g. 'infixr :->; data a :-> b; :type undefined :: Int :-> Int' prints its type as '(:->) Int Int', but I want 'Int :-> Int'
01:43:13 <arcatan> btw, I used to think that it was awkward squid and not awkward squad
01:44:31 <arcatan> then I thought that those things to be tackled were the tentacles of the squid
01:45:26 <arcatan> I think it'd be quite interesting metaphor
01:58:06 <ibid> is "definant" an english word? if not, what is?  (i'm looking for a simple word that refers to the thing that is being defined)
02:00:25 <dons> no.
02:00:38 <dons> hmm.
02:00:51 <dons> "what which is being defined" :-)
02:00:54 <dons> s/that/
02:00:57 <ibid> google found a lot of uses that whs
02:01:01 <ibid> GAH
02:01:06 <dons> ?spell definant
02:01:18 <ibid> google found a lot of uses that were misspellings of "definite" and "defiant"
02:01:23 <dons> yeah
02:01:27 <ibid> but also one use with the meaning i referred to
02:01:37 <igli> ibid: term
02:01:53 <ibid> igli: "term" has another meaning in this context
02:02:23 <igli> term: def'n or word: meaning
02:02:43 <ibid> (i'm talking about mathematical definitions of the kind "x = ...")
02:02:52 <ibid> (and i'd like a word for "x" :)
02:03:18 <ibid> (a general word. of course in any specific situation i can just refer to the "x")
02:03:22 <Thunder> dons: I tried to use urlcheck. I it correct that it does not match href attributes but searchs http:// patterns only? Do I use a early version.
02:04:35 <ibid> i'm using "definant" until someone comes up with a better choice
02:08:12 <dons> Thunder: yes, i think that's right.
02:10:31 <Thunder> dons: Oh, that's bad. I'll switch to TagSoup.
02:10:45 <igli> ibid: referent
02:11:06 <igli> sry bath time bbiab
02:12:23 <scodil> definee
02:12:36 <scodil> counterpart to definer
02:12:42 <igli> meh not mathematical tho
02:12:49 <scodil> hah yeah i was joking
02:13:24 <scodil> but you said english, not math
02:13:34 <scodil> two very different languages
02:15:02 <igli> no ibid said maths actually, which is the English colloquialism for Mathematics
02:15:30 <igli> you speak a dialect of English
02:15:42 <igli> ;-P
02:15:59 <ibid> i'm actually talking about the informal english used in mathematics ;)
02:16:05 <nominolo> lhs
02:16:10 <scodil> there you go
02:16:34 <ibid> lhs might not work in all cases
02:16:51 <igli> then you say term fgs
02:16:58 <ibid> fgs?
02:17:17 <dons> Thunder: urlcheck is just a http wrapper.
02:17:33 <dons> hook it into tagsoup if you want -- that'd make much much more sense than my simple grabber.
02:17:38 <dons> and you'll get multicore support for free.
02:17:50 <apfelmus> Hi :)
02:17:52 <dons> really, urlcheck should be used just as an smp parallel driver for some html parser.
02:17:53 <igli> for God's sake ;)
02:18:28 <dons> Thunder: so please, tear out the string matcher, add tag soup support, and you'll have a multicore-ready link checker
02:18:41 <apfelmus> I'm currently uneducated about the gory details of outermost graph reduction
02:18:48 <apfelmus> and wanted to change that
02:18:56 <dons> anyway -- how does tagsoup address 404s -- that's all urlcheck tries to do
02:19:08 <apfelmus> Does anybody know a good resource for that?
02:20:17 <apfelmus> Further, I'm lacking a clear definition of weak head normal form
02:20:23 <Thunder> dons: Exactly: I'll change the matcher code, and add base URL support.
02:20:51 <ibid> apfelmus: spj's book on implementation of functional programming languages
02:21:10 <apfelmus> Can I get that online somewhere?
02:21:22 <apfelmus> I think I have the "implementing ... - a tutorial" from spj
02:21:36 <Thunder> Hi, does anybody know where to get the network6 patch? I get: Invalid repository:  http://darcs.serpentine.com/network6
02:22:01 <ibid> apfelmus: i think it is online, yes, and i'm not talking about the tutorial
02:22:15 <dons> Thunder: sounds cool
02:22:23 <dons> Thunder: ping bos.
02:22:32 <apfelmus> ibid: ok, gotta google
02:23:07 <ibid> apfelmus: go for spj's web page
02:23:16 <Thunder> dons: I have to check a whole site over all internel links and the external link border.
02:23:22 <ibid> apfelmus: i'm too lazy to go look for it for you, i have it in dead tree form :)
02:23:58 <Thunder> dons: So the main function has to be extended to a mutable stack or queue ...
02:23:58 <apfelmus> Dead tree?
02:23:59 <apfelmus> The question about WHNF that bugs me is whether (id f) is in WHNF
02:24:11 <dons> Thunder: sounds like a great use case for a parallel link checker. can't wait to see your patches.
02:24:15 * dons is glad urlcheck is useful
02:24:35 * Thunder thanx dons.
02:25:05 <ibid> apfelmus: is id in scope or is it a free variable=
02:25:06 <ibid> ?
02:25:22 <apfelmus> ibid: id is the normal Prelude function :)
02:25:39 <ibid> apfelmus: if id x = x is in scope, then id f is not WHNF
02:26:27 <apfelmus> ibid: i thought so. but now comes the thing that bugs me.
02:26:32 <ibid> apfelmus: ... because it's a redex
02:26:45 <apfelmus> ($) :: (a -> b) -> a -> b; ($) = id
02:26:54 <dons> anyone want to write a quick clone of this for haskell, http://blog.zhekov.net/2007/6/12/erlday1/
02:26:58 <lambdabot> Title: Bloggitation: Erlang for everyday use (1)
02:26:58 <dons> just on how to use hackage
02:27:09 <apfelmus> ibid: is (($) f) in WHNF?
02:27:41 <apfelmus> in a sense, it's not a saturated function application
02:28:12 <ibid> apfelmus: it's not, as it is a redex reducing to f
02:28:23 <dons> apfelmus: btw, have you considered writing a blog?
02:28:40 <dons> i'd be keen to see some regular writings on programming ... ;-)
02:28:42 * ibid is writing a blog entry about formally defininng recursion
02:28:52 <dons> ibid: i liked the informal one though!
02:29:02 <apfelmus> ibid: and when ($) f x = f x is in scope?
02:29:18 <dons> it always annoyed me the admin guys at uni had put "recursion: see recursion" as the joke screensave on our undergrad lab machines
02:29:39 <apfelmus> hehe
02:29:45 <ibid> dons: well, i was wrong about some things in there, so i needed to reflect on what recursion really is :)
02:30:29 <dons> yay, fusion paper accepted for icfp! :-)
02:30:32 <apfelmus> dons: in case I feel the need to publish something, I guess I'll use a POH (plain old homepage) :)
02:30:37 <ibid> i'm now convinced that "recursion: see recursion" is wrong, but not for the reason i originally gave. the correct joke is "self-reference: see self-reference"
02:30:44 <dons> boo, polymer paper not accepted. oh well :-) can't win 'em all
02:31:17 <dons> apfelmus: well true. but at least with rss, so we can find it on the daily news -- i mean -- on planet haskell
02:31:31 <ibid> apfelmus: it's still a redex
02:32:10 <apfelmus> dons: why not. but I probably won't get a POH anytime soon :)
02:32:19 <ibid> and i was also wrong claiming that "GNU = GNU's Not Unix" is not recursive :)
02:32:37 <dons> apfelmus: but you have so many interesting observations! it would be nice to collect them.
02:32:39 <apfelmus> ibid: Oh? ($) f ==reduces to=> ?
02:33:01 <ibid> apfelmus: (\x -> f x)
02:33:04 <dons> ibid: hmm, looks recursive though, in the fix (1:) style.
02:33:11 <ibid> dons: exactly
02:33:37 <dons> > fix $ \gnu -> "is not unix, " ++ gnu
02:33:39 <lambdabot>  "is not unix, is not unix, is not unix, is not unix, is not unix, is not uni...
02:33:44 <ibid> dons: it's easy to become confused, hence i need to write it down properly, hence the draft post
02:33:53 <apfelmus> dons: :) most will probably go into the wikibook.
02:34:07 <ibid> dons: that's wrong :)=
02:34:10 <dons> apfelmus: hm. yes. i wonder: could we get a feed of new pages on the wikibook...
02:34:21 <ibid> > fix $ \gnu -> gnu ++ " is not unix"
02:34:22 <ibid> :)
02:34:22 <lambdabot>  Exception: <<loop>>
02:34:37 <dons> walks from the wrong end ;)
02:34:52 <ibid> > fix $ \gnu -> "unix not is " ++ gnu
02:34:53 <lambdabot>  "unix not is unix not is unix not is unix not is unix not is unix not is uni...
02:35:07 <ibid> > fix $ \gnu -> "(unix not is " ++ gnu ++ ")"
02:35:08 <lambdabot>  "(unix not is (unix not is (unix not is (unix not is (unix not is (unix not ...
02:35:10 <apfelmus> ibid: So you mean that ($) f x = f x is syntactic sugar for ($) = \f -> (\x -> f x)?
02:35:10 <dons> yeah
02:35:22 <dons> ?unpl ($) f x
02:35:23 <lambdabot> (f x)
02:35:24 <ibid> apfelmus: yes
02:35:28 <dons> ?unpl ($)
02:35:28 <lambdabot> (\ a b -> a b)
02:35:36 <ibid> unpl?
02:35:43 <dons> reverse @pl :-)
02:35:43 <ibid> ah, pointless
02:35:48 <ibid> pointful
02:35:51 <dons> ?pl (\ a b -> a b)
02:35:52 <lambdabot> id
02:35:55 <dons> ?unpl id
02:35:55 <lambdabot> (\ a -> a)
02:35:55 <ibid> ?pointful ($)
02:35:56 <lambdabot> (\ a b -> a b)
02:36:09 <dancor> mac os x: my ghc-6.6.1 complains about ranlib (which i can fix) and -framework GMP (which i cannot)
02:36:10 <ibid> ah, it recognises it?
02:36:11 <ibid> nice
02:36:13 <dons> huh.
02:36:22 <apfelmus> ibid: aha, that means that there are no "multi-argument" redexes
02:36:26 <dons> lambdabot has features i'm not aware of. it has eery powers!
02:36:26 <ibid> ?pointful id . id
02:36:26 <lambdabot> (\ e -> e)
02:36:39 <dancor> the download page says there is a "post-install script" that fixes these very problems
02:36:43 <ibid> apfelmus: yep; though in practice it's not implemented like that
02:36:47 <dancor> do i have to do something after make install?
02:37:15 <ibid> apfelmus: i wrote a graph reduction implementation in C last year. interested?
02:37:17 <apfelmus> ibid: given semantics, that's unimportant :)
02:37:22 <ibid> :)
02:37:48 <apfelmus> ibid: well, I'm mainly interested in theoretical properties for now :)
02:38:06 <apfelmus> dons: actually, the set of wikibook pages remains rather stable
02:38:07 <jao> dancor, i guess you don't use fink, do you? (the fink ghc package compiles nicely on my macbook)
02:38:19 <apfelmus> dons: but the pages themselves change
02:38:20 <dancor> jao: no, no fink
02:38:34 <ibid> apfelmus: (http://antti-juhani.kaijanaho.fi/newblog/archives/107)
02:38:36 <lambdabot> Title: Antti-Juhani Kaijanaho » Blog Archive » Graph reduction
02:39:42 <apfelmus> ibid: thanks for the link, I'll have a look
02:40:00 <scodil> dancor: I've recently had luck with these binaries: http://www.haskell.org/pipermail/glasgow-haskell-users/2007-May/012576.html
02:40:01 <lambdabot> Title: ghc-6.6.1 Mac (Darwin) Binary Dists, http://tinyurl.com/2hya9r
02:40:18 <scodil> there's a link to the GMP framework on their
02:40:21 <scodil> if that's all you need
02:40:32 <scodil> there, even
02:40:54 <apfelmus> dons: unfortunately, emitting an rss on every small change is a bad idea. Manual rss-ification is probably the way to go
02:46:42 <apfelmus> I have another question, about lazy evaluation.
02:46:55 <apfelmus> I picked up somewhere that it's "optimal" in some sense
02:47:15 <apfelmus> There's optimal reduction, apparently more optimal than lazy evaluation
02:47:33 <apfelmus> But I'd like to know the exact sense in which lazy evaluation is optimal
02:47:42 <apfelmus> Does anyone have a pointer?
02:47:58 <bitwiseshiftleft> google for "weak head normal form"
02:48:34 * Vq^ would guess it's theoretically optimal in time
02:48:39 <malcolmw> apfelmus: it is optimal in the sense that, if any reduction strategy gives a defined result, then lazy evaluation will too
02:49:08 <apfelmus> Ah. I thought it was about the number of reduction steps...
02:49:13 <Thunder> http://www.cs.york.ac.uk/fp/haddock/tagsoup/Data-Html-TagSoup.html  contains wrong data. The *name* of the module is Data.HTML.TagSoup,  not Data.Html.TagSoup
02:49:15 <lambdabot> http://tinyurl.com/ywpexa
02:49:36 <malcolmw> apfelmus: I'm not sure about the number of reduction steps, it is possible that that is also true
02:50:17 <malcolmw> apfelmus: namely, that if any reduction order gives a defined result, then the lazy order is guaranteed to take the same or fewer reduction steps
02:50:31 <apfelmus> malcolmw: I've been told that there is also "optimal reduction" which probably takes fewer steps
02:50:53 <malcolmw> apfelmus: well, in that case laziness would not be optimal
02:51:29 <apfelmus> malcolmw: yes, seems to be the case. Still, I wonder whether this can be saved somehow
02:51:43 <malcolmw> apfelmus: I would guess that the "optimal reduction" order differs depending on what the expression is, and therefore it is not a single strategy
02:52:02 <apfelmus> malcolmw: I mean by adding a requirement on the kind of redex you may reduce
02:52:24 <Saizan> Thunder: i'll tell you more, there's nothing called Data.* in the current repository
02:52:36 <Saizan> http://www.cs.york.ac.uk/fp/haddock/tagsoup/
02:52:41 <apfelmus> malcolmw: For instance, lazy evaluation might take the least amount of steps if you're only allowed to reduce "green" redexes
02:52:52 <malcolmw> green?
02:53:07 <apfelmus> malcolmw: "purple-green checkered"
02:53:29 <DRMacIver> Hm
02:53:30 <apfelmus> malcolmw: :) any constraint on the choice of redexes
02:53:48 <malcolmw> oh I see
02:54:10 <apfelmus> malcolmw: apparently, the constraint "leftmost outermost" makes lazy evaluation optimal in this class :)
02:54:17 <malcolmw> but lazy evaluation is already defined as leftmost-outermost + sharing
02:54:18 <DRMacIver> Let's play "I'm thinking of a purely functional data structure". I need an eagerly evaluated list implementation with O(1) concat. Am I dreaming?
02:54:47 <apfelmus> malcolmw: but I'd like to reduce inner nodes here and there and know that lazy evaluation will not perform worse
02:54:52 <malcolmw> apfelmus: so you are proposing leftmost outermost "green" as a possible refinement
02:55:23 <apfelmus> malcolmw: no, for that would exclude lazy evaluation
02:55:39 <flux> drmaciver, hmm, I guess that should be possible, the cost of O(n) could be paid when iterating it
02:55:43 <malcolmw> apfelmus: no wait, you are proposing optimistic evaluation, where you can look inside lambdas
02:55:44 <apfelmus> malcolmw: some weaker constraint that allows for different strategies besides lazy evaluation but including lazy eval
02:56:01 <DRMacIver> flux: Well, that's basically making it lazy evaluated then. :)
02:56:27 <flux> drmaciver, well if you want to make a new list of length n+m, you must pay O(n+m) :)
02:56:50 <apfelmus> malcolmw: optimistic evaluation is rather "non-deterministic", right? I mean, redexes chosen depend on memory available
02:56:51 <flux> drmaciver, if you can mutate both the lists, I suppose you could use a two-way linked list and mutate the tail
02:57:09 <malcolmw> apfelmus: my terminology is wrong - optimistic is evaluating inner redexes, "full laziness" is evaluating inside lambdas
02:57:27 <DRMacIver> flux: Well, it needs to be immutable, although I guess they can be internally mutable.
02:58:07 <apfelmus> malcolmw: both always do more steps than lazy evaluation?
02:58:23 <swiert> apfelmus: I think there have been proposals about optimal reduction strategies. Let me find a link.
02:58:27 <apfelmus> malcolmw: and evaluating inside lambdas would be inner redexes, too
02:58:32 <malcolmw> apfelmus: optimistic = non-det, perhaps.  but you want to characterise the deterministic "green" property that would make optimistic optimal
02:59:22 <apfelmus> malcolmw: actually, I would be fine with the claim that "lazy evaluation is faster than any hand-crafted evaluation sequence"
02:59:30 <malcolmw> apfelmus: more steps than lazy?  I doubt it
03:00:03 <apfelmus> malcolmw: well, restricting your hands with a constraint, that is :)
03:00:38 <apfelmus> malcolmw: maybe "you may reduce arguments in a function application but may not reduce inside lambdas"
03:00:42 <malcolmw> apfelmus: faster is going to be difficult to establish.
03:00:44 <Thunder> Saizan: Sorry, of course, it is Text.
03:00:56 <apfelmus> malcolmw: well, less reduction steps
03:01:10 <apfelmus> malcolmw: but that's probably difficult, too :)
03:01:21 <swiert> apfelmus: http://www2.parc.com/csl/groups/sda/publications/papers/Lamping-POPL90/for-web.pdf
03:01:22 <lambdabot> http://tinyurl.com/2ygo25
03:01:39 <swiert> I think that is the classic reference. I'm sure there's been more work since then.
03:02:25 <malcolmw> apfelmus: I imagine there must be textbook stuff on this.  Barendregt's huge tome on the lambda calculus must cover this I bet
03:06:46 <apfelmus> swiert: thanks for the link! the diagrams have no lines for me, is that correct?
03:07:07 <swiert> apfelmus: I can't see the lines either.
03:07:18 <swiert> You might be able to find a better version online...
03:07:38 <apfelmus> swiert: but it should have lines? maybe in the PS-version?
03:07:47 <swiert> apfelmus: It should.
03:10:14 <pejo> apfelmus, there's a version on portal.acm.org if you have access there, and the pictures there contains lines.
03:11:24 <apfelmus> pejo: I wish I had access there :( mrpf, there using my taxes and but exclude me from access ...
03:12:33 <apfelmus> but that's probably the intended role of taxes: pay and never see them again ;)
03:13:41 <Wild_Cat> apfelmus: no, that's death, not taxes. taxes come back after some time. :(
03:13:59 <apfelmus> Wild_Cat: yeah, after death ;)
03:17:44 <apfelmus> swiert: looks like i've got to live with that. in any case, thanks :)
03:18:00 <apfelmus> malcolmw: is there any online material?
03:18:19 <malcolmw> apfelmus: no idea, sorry
03:18:45 <apfelmus> malcolmw: nevermind then :)
03:18:51 <malcolmw> apfelmus: maybe some university course notes might be available via google?
03:20:12 <apfelmus> malcolmw: he, you remind me that there's been some summer school somehwere with course notes abound. hm, I think it was about type systems, though
03:21:46 <bringert> dcoutts (or any other c2hs hackers): how do I get the value of a C (CPP) constant with c2hs?
03:21:55 <bringert> like the hsc2hs #const
03:35:15 <kolmodin> bringert: afaik, you don't
03:35:45 <bringert> kolmodin: do you know why not?
03:36:00 <kolmodin> not implemented, iirc
03:37:43 <kolmodin> bringert: so far I've used both c2hs and hsc2hs in projects that needs both
03:38:12 <bringert> yikes
03:38:29 <bringert> it seems easy enough to implement
03:38:54 <jedai> @src showList
03:38:54 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
03:40:39 <jedai> @src Data.Char.showList
03:40:39 <lambdabot> Source not found. Do you think like you type?
03:41:23 <jedai> @src print
03:41:24 <lambdabot> print x = putStrLn (show x)
03:41:37 <apfelmus> @src Show
03:41:38 <lambdabot> class  Show a  where
03:41:38 <lambdabot>     showsPrec :: Int -> a -> ShowS
03:41:38 <lambdabot>     show      :: a   -> String
03:41:38 <lambdabot>     showList  :: [a] -> ShowS
03:46:45 <matthew-_> any lhs2TeX experts awake?
03:47:00 <matthew-_> kosmikus: ping?
03:47:56 <swiert> matthew_-: what's up?
03:48:58 <matthew-_> I have an infix function ~||~
03:49:18 <matthew-_> inline, I'll have to refer to it as ~||||~
03:49:27 <matthew-_> but I want to specify a %format directive
03:50:01 <swiert> Ok. Rename it to ~!!~ (or any other choice).
03:50:27 <matthew-_> ahh, actually, I just realised I misspelt format as formal
03:50:38 <matthew-_> %format ~||~ = "boo"
03:50:43 <matthew-_> does actually work
03:51:10 <matthew-_> so it's just slight painful in code blocks and inline as ~||||~. I might rename it as you suggest then
03:51:13 <swiert> Operators with | can cause problems when you use them inline.
03:52:01 <swiert> You can always rename it, but have two formatting directives (one for generating .tex with --poly, one for generating .hs with --newcode).
03:53:04 <matthew-_> ok. It's a shame you can't specify a list of tokens that shouldn't be inspected for other markers and should be treated atomically
04:55:44 <takamura> hi
05:04:43 <dons> hey takamura
05:04:51 <dons> bit quiet round here. strange!
05:04:52 <dons> ?yow!
05:04:53 <lambdabot> YOU!!  Give me the CUTEST, PINKEST, most charming little VICTORIAN
05:04:53 <lambdabot> DOLLHOUSE you can find!!  An make it SNAPPY!!
05:05:43 <swiert> dons: impending Haskell Worksop deadline maybe?
05:05:44 <takamura> hi, dons, not very quiet in my machine, I have to finish an application this week :)
05:06:33 <aleator> Gah! Can't grok mutable arrays. How do I run code that eats a mutable array and outputs a number?
05:07:09 <mauke> depends on the array
05:07:26 <aleator> Well STArray seems appropriate..
05:07:54 <aleator> ie. anything outside IO
05:08:48 <mauke> foo :: STArray s i e -> ST Int
05:09:08 <dons> swiert: looks like we're going to miss that -- Duncan's on holiday. We'll probably send our paper off to PADL or sometthing like that.
05:09:13 <Saizan> s/ST/ST s/
05:09:17 <mauke> er, yes
05:09:29 <swiert> dons: what were you writing?
05:09:39 <mdmkolbe|work> Speaking of deadlines, anyone know what time zone the Haskell Workshop is?  Is it safe to assume 23:59:59 Samoan time?
05:10:10 <dons> swiert: eliminating bounds checking in high perf. haskell via rewrite rules, and its application to Data.Binary
05:11:35 <swiert> dons: Ah right. Congrats on the Fusion paper btw.
05:13:03 <dons> cheers.
05:16:47 <hpaste>  mauke pasted "silly STArray code" at http://hpaste.org/250
05:22:11 <malcolmw> dons: accepted at ICFP?
05:24:12 <dblhelix> dons: congrats!
05:25:05 <hpaste>  MathematicalOrc pasted "Generate all possible trees" at http://hpaste.org/251
05:28:45 <dons> malcolmw: yeah, fusion paper got in.
05:28:56 <dons> which is nice, 'cause fusion is fun.
05:30:30 <malcolmw> dons: cool.  is the ICFP acceptance list published yet?
05:31:08 <dons> doesn't seem to be.
05:37:56 <dancor> i installed ghc via fink
05:38:09 <dancor> but ld can't find -lHShaskell98
05:38:28 <dancor> even though it's right there in /sw/lib/ghc-6.6
05:38:38 <gkr> Any good tutorial about circular programming?
05:38:50 <dancor> i tried export LD_LIBRARY_PATH=/sw/lib/ghc-6.6
05:39:08 <swiert> dancor: have you tried ghc --make?
05:39:59 <dancor> swiert: "/usr/bin/ld: can't locate file for: -lHSbase"
05:40:10 <dancor> mac os x doesn't appear to have ldconfig
05:40:17 <swiert> dancor: do you have XCode installed?
05:40:23 <pejo> dancor, LD_LIBRARY_PATH is only for runtime linker, and that's not what osx uses.
05:42:09 <pejo> dancor, it's called DYLD_LIBRARY_PATH, documented in the manpage for dyld(1).
05:42:28 <dancor> swiert: i can't tell, should i?  there is gcc 4.0.1 here
05:44:42 <swiert> dancor: I assume you should have it installed. What does "ls /Developer" say?
05:45:40 <dancor> swiert: yeah it has stuff there
05:45:51 <swiert> dancor: you should have it then...
05:45:57 <dancor> such as "About Xcode Tools.pdf"
05:46:51 <dancor> pejo: same errors after export DYLD_LIBRARY_PATH=/sw/lib/ghc-6.6
05:47:32 <malcolmw> dancor: try ghc -optL-L/sw/lib/ghc-6.6
05:47:48 <pejo> dancor, yes, the linker doesn't look at that when it is trying to link stuff. malcolmw's suggestion should work though.
05:48:10 <malcolmw> dancor: it might be that fink's ghc has the wrong paths baked into it, e.g. /usr/local instead of /sw
05:50:38 <ibid> dons: http://antti-juhani.kaijanaho.fi/newblog/archives/201
05:50:39 <lambdabot> Title: Antti-Juhani Kaijanaho » Blog Archive » On recursion
06:04:08 <ndm> @seen Igloo
06:04:08 <lambdabot> Igloo is in #haskell-overflow, #haskell, #ghc and #darcs. I last heard Igloo speak 39s ago.
06:04:34 <ndm> Igloo: i note that sjanseen has a darcs repo in http://darcs.haskell.org/~sjanssen/xmonad
06:04:36 <lambdabot> Title: Index of /~sjanssen/xmonad
06:04:52 <ndm> how do i do that? specifically so i can have ~neil/guihaskell and ~neil/proplang
06:04:56 <MyCatVerbs> @seen ghosts
06:04:56 <lambdabot> I haven't seen ghosts.
06:05:01 <ndm> so my soc student can put their code public
06:05:04 <MyCatVerbs> Heehee.
06:07:33 <Igloo> ndm: put it in ~neil/public_html/guihaskell
06:08:37 <Igloo> ndm: you'll also need to at least chmod a+x ~neil so the webserver is allowed to enter the directory
06:09:37 <dons> you create public_html to start with, and ensure they have ssh access. but hmm, don't we want to put the soc guys on the community server?
06:10:29 <quicksilver> ndm: what project is your soc student doing?
06:10:46 <ndm> quicksilver: guihaskell
06:10:59 <ndm> dons: we do, but that was three weeks ago, and my student is producing code i can't see...
06:11:09 <ndm> dons: we'll move over after the community server works
06:11:44 <quicksilver> ndm: nice. will be interested to see progress
06:12:48 <ndm> quicksilver: me too :)
06:13:07 <ndm> i've prodded what i think i need to
06:13:11 <ndm> but it doesn't work: http://darcs.haskell.org/~neil/guihaskell/
06:14:02 <quicksilver> http://darcs.haskell.org/~neil/guihaskelll/
06:14:03 <lambdabot> Title: Index of /~neil/guihaskelll
06:14:09 <quicksilver> you have a surfeit of ls, my friend :)
06:14:59 <SamB_XP> ndm: too much tabbing!
06:15:15 <ndm> SamB_XP: ?
06:15:24 <ndm> oh, in guihaskell?
06:15:40 <SamB_XP> ndm: how else do you explain the extra l having survived?
06:16:15 <ndm> @karma++ SamB
06:16:15 <lambdabot> SamB's karma raised to 24.
06:16:25 <ndm> works now, thanks
06:16:36 <SamB_XP> @karma++ quicksilver
06:16:36 <lambdabot> quicksilver's karma raised to 2.
06:16:42 <SamB_XP> @karma++ quicksilver
06:16:42 <lambdabot> quicksilver's karma raised to 3.
06:17:20 <quicksilver> well, evidently my comment needed translation to click :)
06:17:29 <SamB_XP> apparantly!
06:24:23 <ndm> @karma+ quicksilver
06:24:23 <lambdabot> quicksilver's karma raised to 4.
06:24:46 <ndm> woops, i obviously don't have a good eye for 3 versus two ll's so missed that one entirely!
06:25:19 <quicksilver> ndm: however, the clue was the way that lambdabot came back with a title for it :)
06:30:21 <TSC> Is there some way I can tell how many bits a Double takes up?
06:31:01 <mauke> how many bits does id take?
06:31:46 <quicksilver> TSC: probably, yes. Why do you want to know?
06:32:35 <TSC> I think there's a bug in marshalling doubles on 64-bit machines in the OpenGL bindings
06:33:13 <TSC> So I'd like to compare the size of Double on 32 versus 64 bit machines
06:33:49 <quicksilver> > (sizeof (undefined::Double))
06:33:51 <lambdabot>   Not in scope: `sizeof'
06:33:54 <quicksilver> > (sizeOf (undefined::Double))
06:33:55 <lambdabot>   Not in scope: `sizeOf'
06:34:05 <quicksilver> TSC: like that
06:34:12 <quicksilver> TSC: i fyou have Foreign.Storable importaed
06:34:19 <TSC> Ok, thanks
06:34:24 <quicksilver> TSC: I'm pretty sure doubles are 64 bit on all 'common' platforms
06:35:31 <TSC> Yes, Double and double are 64-bit on both
06:35:39 <TSC> So something else must be wrong
06:36:13 <TSC> Bizarre
06:42:06 <TSC> Well, there's the problem; one of the arguments disappears
06:57:08 <SamB_XP> huh. I can't find my mouse pointer on my Linux box...
06:57:22 <DRMacIver> cat ate it.
06:58:10 <SamB_XP> my KVM is really wierd
06:58:56 <SamB_XP> it's shortcut key sequences are supposed to start with Scroll Lock Scroll Lock...
06:59:14 <SamB_XP> but they only seem to work if the light gets blinked
07:01:21 * SamB_XP wonders why linux discards scrollback when you switch VTs
07:02:33 <therp> samb: that's strange, yes.
07:03:00 <SamB> hmm, I shuffled my USB devices a bit and now it works
07:03:06 <matthew-_> would "you" say that a multi-parameter type class expresses a relationship between classes?
07:03:17 <SamB> matthew-_: heh
07:03:23 <SamB> between types, not between classes
07:03:29 <matthew-_> agh, yes, that's what I meant
07:03:47 <matthew-_> where as functional dependencies take that relationship to a mapping?
07:04:04 <SamB> sounds about right
07:04:09 <matthew-_> good good
07:04:34 <SamB> what was that nice new thing called...
07:05:09 <quicksilver> matthew-_: not necessarily (the last bit)
07:05:19 <quicksilver> matthew-_: mptcs define relations between types
07:05:34 <SamB> quicksilver: they make some kind of mapping...
07:05:41 <quicksilver> matthew-_: fundeps *may* turn a relation into a mapping, but may do something weaker
07:05:53 <matthew-_> yes quite. Due to the issues of open classes right?
07:06:05 <quicksilver> no, just because you have have more than 2 types in a MPTC
07:06:12 <quicksilver> if you just have MPTC a b | a -> b
07:06:17 <quicksilver> then that is in practice a mapping
07:06:25 <quicksilver> but if you have MPTC a b c | a -> c
07:06:30 <quicksilver> then it's still a relation..
07:06:34 <matthew-_> right right, yes indeed. Sure.
07:06:48 <SamB> that still establishes a mapping from a to c
07:06:59 <matthew-_> well, it's (a -> c) x b rather than a x b x c
07:07:33 <quicksilver> SamB: yup, but it doesn't make the whole relation into a mapping
07:07:39 <SamB> sure
07:09:38 <matthew-_> oh, and is it just me or do others write, given class F a b c, | a -> b c when they actually meant | a -> b, a -> c
07:09:53 <matthew-_> as the two turn out not to be the same!
07:09:58 <SamB> @hoogle Int -> String -> n
07:09:58 <lambdabot> No matches, try a more general search
07:15:11 <tom_> hi all
07:16:34 <tom_> I'm working on a ray tracer so I've defined a type "type Vector3 = (Double, Double, Double)". I was thinking it'd be convenient to make this an instance of the Num class, does that make sense at all?
07:16:47 <SamB> tom_: sort-of
07:17:07 <SamB> unfortunately our Num class assumes multiplication to be possible
07:18:06 <SamB> also, I'd suggest using:
07:18:20 <SamB> data Vector3 = V3 !Double !Double !Double
07:18:34 <tom_> I thought of maybe just defining multiplication as (x1*x2, y1*y2, z1*z2) although I'm not sure how useful that'd be
07:18:39 <SamB> probably with "deriving (Eq, Show)"
07:18:56 <tom_> Those !'s are make it strict, right?
07:18:59 <SamB> yeah
07:19:44 <SamB> I suppose you might also want an {-# UNPACK #-} pragma (or -funbox-strict-fields)
07:20:32 <tom_> I'll make a note of that
07:21:21 <SamB> tom_: you could also just leave * unimplemented
07:21:43 <tom_> Can I do that?
07:21:48 <SamB> you can
07:22:36 <matthew-_> I'd suggest that it's very dangerous though
07:22:37 <SamB> the compiler may complain loudly, and if something demands a value from it, it'll crash, but that's possibly a good thing
07:22:56 <matthew-_> ohh, sorry, I thought you were going to suggest using undefined
07:22:57 <SamB> matthew-_: more dangerous than defining it to do something stupid?
07:23:29 <tom_> so I just leave it undefined, or i define it as 'error "something wrong"' or some such?
07:23:33 <matthew-_> SamB: sorry, I misunderstood you. left without implementation is clearly better than a bad alternative...
07:24:11 <SamB> tom_: the former will work fine
07:24:37 <SamB> though the latter will result in the compiler complaining less
07:25:14 <tom_> Do you guys think it's a better idea to just define my own operators or to use the num class? I like the idea of being able to use the normal (+) and (-) operators
07:25:54 <matthew-_> if it was me, I'd define my own.
07:26:18 <SamB> you could define ones with similar names
07:26:28 <matthew-_> :+:, :-: etc
07:26:44 <SamB> matthew-_: aren't those constructor names?
07:26:52 <matthew-_> yep, I just realised that!
07:27:05 * matthew-_ goes back to sleep...
07:27:05 <SamB> +: and -:, anyway ;-)
07:27:23 <SamB> matthew-_: to be fair, I think they are operator names in Haskell 98
07:28:07 <tom_> Ok, I'll do that then, the extra : character's not much of a hardship
07:28:11 <tom_> thanks for the advice
07:28:18 <SamB> huh, my mom just tried to go to a train station that wasn't there...
07:30:16 <dons> ?users #darcs
07:30:16 <lambdabot> Maximum users seen in #darcs: 39, currently: 33 (84.6%), active: 3 (9.1%)
07:30:19 <dons> ?users #xmonad
07:30:20 <lambdabot> Maximum users seen in #xmonad: 46, currently: 45 (97.8%), active: 15 (33.3%)
07:30:23 <dons> do we get a prize? :-)
07:30:35 <dons> ?users #ghc
07:30:35 <lambdabot> Maximum users seen in #ghc: 21, currently: 21 (100.0%), active: 9 (42.9%)
07:30:46 <matthew-_> dons: I'm sure you've had many prizes already!
07:31:01 <dons> tshirts for all!
07:31:22 <dons> ?users #happs
07:31:22 <lambdabot> Maximum users seen in #happs: 1, currently: 0 (0.0%), active: 0 (NaN%)
07:31:27 <dons> oh, no bot there
07:31:33 <dons> ?join #happs
07:31:38 <dons> ?users #happs
07:31:38 <lambdabot> Maximum users seen in #happs: 0, currently: 10 (Infinity%), active: 2 (20.0%)
07:31:42 <dons> heh
07:31:54 <pitecus> is there something like the function "maybe" for arbitrary monads?
07:32:52 <kpreid> no
07:33:03 <dons> ?type Data.Maybe.maybe
07:33:06 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:33:07 <kpreid> for example, it would be equivalent to unsafePerformIO in the IO monad
07:33:28 <dons> so an automatic elimination form for any container, or any monad in general.
07:34:00 <kpreid> hmm
07:34:12 <kpreid> it occurs to me that this could exist:
07:34:50 <kpreid> class RunMonad m i o | m -> i, m -> o where run :: m a -> i -> (a, o)
07:34:59 <SamB> how about "case"? that's just a higher-order-function version of case over Maybe a...
07:35:13 <quicksilver> well 'fmap' is a bit like a general elimination
07:35:18 <quicksilver> except it doesn't actually eliminate :)
07:35:25 <quicksilver> but that's as good as you can do, in general
07:35:37 <quicksilver> (liftM, rather. same thing)
07:35:38 <pitecus> fair enough...
07:37:08 <pitecus> failing that, is there a library function that does it for the List monad?
07:37:30 <kpreid> which element do you want?
07:37:31 <swiert> maybe is just the fold over Maybe.
07:37:37 <swiert> if that makes sense.
07:37:54 <kpreid> pitecus: or, the answer is foldr
07:38:40 <pitecus> aha
07:45:48 <ToRA> mmm, going back a while in the conversation - does anyone know what is the difference between: class F a b c "| a -> b c" and  "| a -> b, a -> c" is?
07:46:12 <|Jedai|> Is there a way to do this more beautiful :
07:46:22 <|Jedai|> isAtom Atom _ = True
07:46:36 <|Jedai|> isAtom _ = False
07:46:41 <kpreid> |Jedai|: no.
07:46:57 <Thunder> ToRA: in the latter case b has to be a Type transformer
07:46:59 <geezusfreeek> i don't think it looks particularly unelegant
07:47:42 <|Jedai|> geezusfreeek: It don't by itself, but having to do that for all the constructor of a datatype looks stupid
07:48:03 <kpreid> |Jedai|: why do you want these functions?
07:48:14 <geezusfreeek> looks like you are replacing pattern matching
07:48:40 <mauke> :t maybe
07:48:43 <lambdabot> forall b a. b -> (a -> b) -> Maybe a -> b
07:49:07 <|Jedai|> geezusfreeek: In the tutorial "Write your Scheme interpreter in 48 hours" there's a question
07:49:13 <kpreid> Data.Generics.toConstr comes to mind
07:49:46 <|Jedai|> that ask to create type-testing primitives
07:49:55 <ski> Thunder : i think not
07:50:28 <kpreid> |Jedai|: so you're defining a Scheme 'atom?' using a primitive function in your value type?
07:51:08 <kpreid> |Jedai|: in that case, I'd write it as a local function in each primitive definition
07:51:48 <|Jedai|> kpreid: And how would that look ?
07:52:12 <|Jedai|> kpreid: It's what I did but it wasn't better
07:52:26 <kpreid> |Jedai|: show us the definition that ties atom? to isAtom
07:53:04 <kpreid> |Jedai|: another possibility is to in the Haskell layer implement a type-of operation, and built atom? on top of comparing the types
07:53:14 <|Jedai|> toConstr seems interesting
07:53:16 <kpreid> then instead of isAtom, isNumber, ... you can just write one typeOf
07:55:07 <Saizan> ?type typeOf
07:55:08 <lambdabot> forall a. (Typeable a) => a -> TypeRep
07:55:22 <kpreid> Data.Typeable.typeOf isn't relevant
07:55:57 <geezusfreeek> this is matching constructors though, really, so i think typeOf might not be the best name for it
07:56:18 <geezusfreeek> unless i misunderstand
07:56:27 <kpreid> well, it depends on whether you want to look at it from the Haskell or the overlaid-Scheme view
07:56:34 <geezusfreeek> ah, yeah
07:56:35 <|Jedai|> toConstr is good enough I think
07:57:04 <|Jedai|> \x -> toConstr x == toConstr (Atom "")
07:57:26 <kpreid> |Jedai|: it might not be what you want if the constructor alternatives don't *exactly* match the types the Scheme system sees, though
07:57:34 <geezusfreeek> > toConstr (Maybe 5)
07:57:34 <lambdabot>   Not in scope: data constructor `Maybe'
07:57:46 <emu> is Data.Set the best "priority queue" in the std libraries?
07:57:53 <|Jedai|> > toConstr (Just 5)
07:57:54 <lambdabot>   Not in scope: `toConstr'
07:57:58 <emu> (w/ minView etc)
07:58:01 <kpreid> > G.toConstr (Just 5)
07:58:02 <lambdabot>   Not in scope: `G.toConstr'
07:58:05 <kpreid> huh
07:58:12 <kpreid> > Data.Generics.toConstr (Just 5)
07:58:13 <lambdabot>  Just
07:58:15 <|Jedai|> > Data.Generics.Basics.toConstr (Just 5)
07:58:16 <lambdabot>   Not in scope: `Data.Generics.Basics.toConstr'
07:58:18 <geezusfreeek> aha
07:58:26 <kpreid> I thought it was imported as G, once
07:59:17 <|Jedai|> Or is there a way to write a case x of on one line ?
07:59:25 <kpreid> sure, semicolons
07:59:38 <kpreid> > case Just 1 of Just _ -> True; _ -> False
07:59:40 <lambdabot>  True
08:00:03 <|Jedai|> \x -> case x of Atom _ -> True; _ -> False
08:00:20 <|Jedai|> which is best ?
08:00:29 <kpreid> I'd do it that way
08:00:30 <ndm> |Jedai|: probably worth defining isAtom function, and then using that
08:00:45 <kpreid> assuming you don't have other uses for isAtom besides defining this primitive
08:00:58 <kpreid> ndm: that's what he started with
08:01:24 <ndm> i'd always define isAtom, it makes the code clearer, and the chances of it not being useful anywhere else are remote
08:01:27 <|Jedai|> Too bad you can't use Atom? or something like that
08:01:33 <ndm> or use Data.Derive, and do deriving Is
08:01:34 <geezusfreeek> \x -> if toConstr x == Atom then True else False
08:01:39 <geezusfreeek> ^ might look better
08:01:41 <kpreid> |Jedai|: you can use atomp :-)
08:01:49 <ndm> toConstr x == Atom
08:02:01 <ndm> never do if ... then True else False - its just the same as ...
08:02:02 <kpreid> geezusfreeek: that's a useless if
08:02:10 <geezusfreeek> oh, haha
08:02:17 <geezusfreeek> i have never done that before
08:02:19 <kpreid> in fact, that function is (== Atom) . toConstr
08:02:27 <geezusfreeek> that's like something from the daily wtf
08:02:43 <ndm> DrHaskell picks those things up automatically
08:02:47 <ndm> @where drhaskell
08:02:47 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/drhaskell/
08:02:54 <DRMacIver> I wonder how long it will be before there are daily wtf entries in Haskell. :)
08:02:55 <|Jedai|> Can you really write (== Atom) ?
08:03:10 <ndm> @where+ drhaskell http://www-users.cs.york.ac.uk/~ndm/drhaskell/
08:03:10 <lambdabot> Done.
08:03:21 <ndm> although its a bit broken at the moment, probably won't compile
08:03:37 <geezusfreeek> yes, you can do that
08:03:59 <|Jedai|> geezusfreeek: Here it complains that Atom lacks arguments
08:04:03 <kpreid> er
08:04:05 <ndm> you can't
08:04:11 <kpreid> whoops
08:04:21 <kpreid> (== toConstr (Atom undefined))
08:04:23 <emu> |Jedai|: only if Atom is a 0-ary constructor
08:04:34 <ndm> i'm not sure we should be promoting toConstr usage
08:04:37 <emu> heh
08:04:39 <|Jedai|> That's why I wrote \x -> toConstr x == toConstr (Atom "")
08:04:51 <|Jedai|> But it's ugly...
08:04:52 <ndm> its not Haskell, its GHC only (i think)
08:05:05 <kpreid> |Jedai|: I'd go with the one-line case over toConstr
08:05:05 <ndm> plus its not idomatic haskell
08:05:12 <ndm> and its not type safe
08:05:27 <geezusfreeek> gosh
08:05:42 <geezusfreeek> i guess i suck at life
08:05:58 <geezusfreeek> i'm gonna shut up now and not answer any more questions as if i know what i'm talking about :)
08:06:24 <ndm> no, don't do that - all answers are welcome!
08:06:31 <|Jedai|> And you can't do (case of Left _ -> True) val
08:06:36 <geezusfreeek> haha, even the wrong ones?
08:06:42 <geezusfreeek> or the stupid ones?
08:06:51 <ndm> yes, wrong answers help people learn what to do and not to do
08:07:10 <geezusfreeek> only if there is somebody around to make sure and correct things at the time
08:07:14 <ndm> they help you, so you learn, and they help the person who asked, so they get a reasonable choice of design, and can learn why one is best
08:07:25 <ndm> give it a week or so and all your answers will be perfect ;)
08:07:30 <geezusfreeek> ha
08:07:50 <geezusfreeek> i've actually been using haskell for a while nowâ€¦ i haven't been conversing about it very much though
08:13:59 <Botje> how do you transform the byte representation of an int to an acual int?
08:14:21 <ndm> Botje: as 4 individual bytes?
08:14:23 <Botje> use the FFI?
08:14:29 <Botje> yes
08:14:33 <|Jedai|> Byte representation ? In what form ?
08:14:34 <Botje> i've got 4 bytes, i want an int
08:14:40 <|Jedai|> Data.Binary ?
08:14:45 * Botje looks
08:14:47 <ndm> Botje: Data.Binary, or there is code in deferedbinary
08:15:07 <ndm> Botje: http://www.cs.york.ac.uk/fp/darcs/binarydefer/Data/Binary/Defer/Internal.hs
08:15:09 <lambdabot> http://tinyurl.com/ywu32e
08:15:24 <ndm> look at hGetInt in particular, that has the formula
08:15:26 <Botje> ah, thanks!
08:15:47 <ndm> i stole that from Data.Binary :)
08:16:02 <Botje> i'll do some stealing of my own then
08:16:03 <ndm> I then found that their version overflowed certain numbers, so had to patch it
08:16:04 <Botje> *copypaste*
08:24:09 <Botje> hmm
08:24:19 <Botje> hGetInt returns signed ints, not unsigned
08:24:35 <Botje> is there an easy way to convert to Words ?
08:24:42 <Botje> (just coerce?)
08:24:48 <quicksilver> fromIntegral
08:24:58 <quicksilver> :t hGetInt
08:25:00 <lambdabot> Not in scope: `hGetInt'
08:25:32 <Saizan> ?type shiftL
08:25:34 <lambdabot> forall a. (Bits a) => a -> Int -> a
08:25:43 <quicksilver> there should be other hGets I thought
08:26:09 <Saizan> ?type (.|.)
08:26:11 <lambdabot> forall a. (Bits a) => a -> a -> a
08:26:42 <Saizan> i don't get where Word8 becomes Int in that definition
08:26:57 <Saizan> ah..
08:27:09 <Saizan> getWord8 :: Handle -> IO Int
08:27:51 <matthew-_> ok, how would you define a phantom type? I thought it was just a type with no values (other than bottom). Eg data X
08:28:14 <Saizan> Botje: i think you can just add a fromIntegral to each call of getWord8
08:28:34 <Botje> looks like it's working
08:28:54 <Saizan> matthew-_: yes, but you need -fglasgow-exts
08:30:00 <matthew-_> Saizan: yes, sorry, I wasn't meaning "define in Haskell" I was meaning from a linguistic pov
08:30:20 <matthew-_> i.e. if you wanted to describe to someone what a Phantom type was, how would you do it?
08:30:52 <swiert> matthew-_: Phantom type or empty type?
08:31:08 <swiert> an empty type is like your data X.
08:31:16 <matthew-_> ok. and a phantom type is?
08:31:26 <swiert> a phantom type is something like Phantom a = Bla Int.
08:31:35 <ski_> phantom type *parameter* ?
08:31:44 <swiert> the a does not occur on the right hand side of the data declaration.
08:32:16 <matthew-_> oh, ok. so not data Foo a b where FC :: a -> b -> c -> Foo Int c ?
08:33:18 <matthew-_> right, gotcha. Sorry, I find it hard to translate back from GADT syntax...
08:33:28 <swiert> matthew-_: no. the a and b occur as constructors of FC.
08:33:38 <Saizan> http://www.haskell.org/hawiki/PhantomTypes
08:33:39 <lambdabot> Title: PhantomTypes - The Haskell Wiki
08:34:10 <Saizan> not much content but gives the idea
08:35:01 <matthew-_> yep. ta
08:36:47 <Botje> grr. how do i convert a word to an int?
08:36:56 <Botje> there's no toIntegral
08:37:07 <Saizan> ?type fromIntegral :: Word -> Int
08:37:09 <lambdabot> Word -> Int :: Word -> Int
08:37:13 <Botje> O_O
08:37:30 <Saizan> Word is an instance of Num
08:37:45 <Botje> ah
08:38:05 <Botje> yay! down to one type error
08:40:40 <Botje> heh
08:40:44 <Botje> it works, shiny!
08:40:46 <Botje> thanks, all
08:50:13 <araujo> morning
08:51:09 <byorgey> hey araujo
08:51:22 <byorgey> where are you, that it is morning?
08:51:26 <araujo> hello byorgey :-)
08:51:32 <araujo> byorgey, .ve
08:51:55 <araujo> well, it's almost noon :-)
08:51:57 <byorgey> araujo: ah, cool
08:52:35 <byorgey> araujo: yes, here too (Washington DC) =)
09:10:53 <mdmkolbe|work> if I have a type 'data a :-> b' is there some way to convice ghc to print it using infix instead of prefix format when it prints out types?
09:35:03 <ibid> dons: i point your attention to a denotational semantics tutorial benja_ just posted as a comment to my recursion blog post :)
09:44:44 <vincenz> Lemmih: ping
09:44:51 <Lemmih> vincenz: pong.
09:44:54 <vincenz> come to #oasis
09:52:20 <emu> i'm getting a dramatic speedup by copying the contents of a particular module from one file into the Main module instead of importing it.
09:52:27 <emu> what could that indicate?
09:54:51 <Excedrin> emu: there was some stuff on the mailing list about inlining or some other optimization that doesn't happen when things are in multiple modules
09:56:39 <emu> more fun: using unsafeRead/unsafeWrite is ok in the module, but not when i copy it.
09:56:45 <emu> i think this is now a bug
10:04:50 <Modius> Is there a haskell prelude function that does "interleave" (I ask realizing that such a function would be borderline unorthogonal due to the ease of doing this)?  E.g. turns funcname [1 2 3] 69 into [1 69 2 69 3]
10:05:15 <ari> Modius: Data.List.intersperse
10:05:57 <ari> > intersperse ' ' "hello"
10:06:00 <lambdabot>  "h e l l o"
10:06:37 <emu> when is unsafeWrite slower than writeArray?
10:07:08 <Botje> ?src unsafeWrite
10:07:08 <lambdabot> Source not found. That's something I cannot allow to happen.
10:07:44 <emu> answer: when you're me
10:08:12 <Modius> Ari:  Thanks
10:17:02 <whaleofconfusion> is there a more casual/off topic haskell channel?
10:17:53 <ndm> #haskell-blah
10:17:55 <shapr> whaleofconfusion: #haskell-blah
10:18:43 <ndm> emu: arrays and haskell are known to have issues, the performance isn't always what you'd expect
10:19:40 <whaleofconfusion> thanks
10:25:23 <whaleofconfusion> maybe this is close enough to on-topic to be posted here:  I'm designing syntax + semantics for a version of an untyped lambda calculus that has built-in pattern matching
10:26:04 <whaleofconfusion> Example:  (\ (foo &x) -> (foo 7) <- (* x 3)) = (* 3 7) = 21
10:27:30 <whaleofconfusion> the main difference is that the formal argument to a lambda can be any form whatsoever, and it pattern matches on the body of the expression
10:28:15 <wolverian> it took me a minute of uncomfortable brain gyrations to figure that out. now my head hurts.
10:28:29 <whaleofconfusion> the stuff after the <- is the argument "passed" to the lambda form
10:28:49 <Philippa> isn't <- just a long way to write function application there, then?
10:29:06 <whaleofconfusion> in the formal argument, if any term or expression is preceded by an & (at the top level), it does two things
10:29:48 <whaleofconfusion> it takes the expression after it and tries to match it to any arbitrary expression in the -> place
10:29:50 <emu> > shiftL 1 32 :: Word64
10:29:52 <lambdabot>  4294967296
10:30:57 <whaleofconfusion> and it takes the literal form of the expression (in this case the symbol x) and binds it over the <- place
10:31:26 <vincenz> whaleofconfusion: seems rather reverse
10:31:31 * geezusfreeek is a bit lost
10:31:33 <whaleofconfusion> so that this lambda binds (foo <some expression>) over the -> place, and it binds x to the value of that expression, in the <- place
10:31:33 <vincenz> normally the syntax would be something lke
10:31:56 <vincenz> (\(foo x) -> (* x 3)) (foo 7)
10:32:02 <vincenz> foo being a dataconstructor
10:32:31 <geezusfreeek> ah, now i see
10:32:48 <Shurique> is there a sleep() equivalent in Haskell?
10:32:54 <vincenz> whaleofconfusion: though I admit the way you explained it seems to not match what I understood... you pass ini the (foo 7) or the (* x 3)?
10:34:08 <whaleofconfusion> it's equivalent to ((\ foo -> foo 7) (\ x -> (* x 3)))
10:34:21 <vincenz> ah
10:34:34 <vincenz> then what is it really matching?
10:34:43 <whaleofconfusion> the &x
10:35:04 <vincenz> so
10:35:09 <vincenz> &x creates a dynamc scope?
10:35:10 <whaleofconfusion> it's looking for a pattern after the -> that consists of (foo <any arbitrary expression>) and it matches that expression
10:35:28 <whaleofconfusion> &x makes it try to match, and also puts x into the <- lexical scope
10:35:42 <vincenz> whaleofconfusion: so what if I ha
10:35:51 <vincenz> (\(foo x) -> (foo 7) < (* x 3))
10:36:08 <vincenz> and why are you using the \
10:36:24 <vincenz> (plus..wouldn't it be easier if you could pattern match against something coming from outside the form?
10:36:25 <whaleofconfusion> then the x after the <- would be a free variable
10:36:34 <vincenz> with what value?
10:36:39 <vincenz> oh ...
10:36:39 <whaleofconfusion> because normally lambda only creates bindings over the -> place
10:36:42 <vincenz> so what would the 'x' stand for?
10:36:52 <vincenz> what of
10:36:57 <whaleofconfusion> anything, it would have to be externally supplied or else it would be a syntax error
10:37:03 <vincenz> (\(foo &x) -> (foo x) <- (* x 3))
10:37:20 <vincenz> and why not
10:37:30 <vincenz> (\(foo &x) -> (* x 3)) ( foo x)
10:37:44 <vincenz> aka, something passed in from outside
10:37:49 <whaleofconfusion> the first one would become (* x 3)  (with the x in the -> place being free)
10:37:54 <vincenz> rght
10:38:00 <vincenz> which makes my notation more convenient
10:38:04 <vincenz> less scope-confusion
10:38:12 <vincenz> the foo x is obviously from a surrounding scope then
10:38:16 <whaleofconfusion> in the second one the foo and the x is free outside of the lambda form
10:38:33 <whaleofconfusion> and also the x in the -> place is free
10:38:44 <vincenz> whaleofconfusion: so the foo won't match?
10:38:52 <vincenz> requiring
10:39:13 <vincenz> (\pattern -> lexical value <- body) isn't very convenient
10:39:16 <whaleofconfusion> actually I'm not really sure that would be valid in this syntax because it doesn't have both a -> and a <-, I don't know how you would want that to work out
10:39:19 <vincenz> I'd like values to be passed in from the outside
10:39:25 <whaleofconfusion> hmm
10:39:28 <vincenz> whaleofconfusion: I was proposing a different syntax
10:39:38 <vincenz> (\pattern -> body) makes mre sense
10:39:43 <vincenz> then you can apply it like a function
10:39:48 <vincenz> ((\pattern -> body) somevalue)
10:39:56 <whaleofconfusion> well the reason I put the -> and the <- there is because they are kind of symmetric
10:40:00 <vincenz> + that would be moreconventional
10:40:09 <vincenz> whaleofconfusion: the symmetry makes no sense
10:40:16 <whaleofconfusion> for example:  (\ &x -> 4 <- (+ x 3)) = 7
10:40:18 <vincenz> except purely for having lexical symmetry of two arrows
10:40:25 <vincenz> whaleofconfusion: it's not very useful though as abstraction
10:40:29 <vincenz> whaleofconfusion: yu can't pass anything in
10:40:32 <vincenz> so you might as well do
10:40:38 <vincenz> let x = 4 in x + 3
10:40:39 <whaleofconfusion> yeah you're right about that
10:40:55 <geezusfreeek> i think he's using an odd syntax because of the complexity of the semanticsâ€¦ if you are passing in a value meant to be matched on the x, how do you know what x actually is supposed to represent?
10:41:06 <vincenz> I mean if you know the patterns -and- the values, why have patterns in the first place, just bind the variables directly
10:41:46 <vincenz> geezusfreeek: I disagree
10:41:47 <vincenz> see
10:41:49 <vincenz> how Isee it
10:41:51 <whaleofconfusion> but it works in a funny way so I'm not sure you want to be able to just apply these things anywhere
10:41:55 <vincenz> (\(foo &x) -> ...
10:41:56 <vincenz> is like
10:41:58 <geezusfreeek> i worded that weird, but i guess the whole conversation is worded weird :\
10:41:59 <vincenz> Foo x -> blablaa
10:42:01 <vincenz> ini haskell
10:42:06 <vincenz> nd \(foo x) -> ...
10:42:07 <vincenz> is like
10:42:08 <whaleofconfusion> because there is potentially a lot of interaction between the argument to the function and the definition of it
10:42:10 <vincenz> Foo X -> ...
10:42:12 <vincenz> in haskell
10:42:17 <vincenz> (aka the X is a dataconst)
10:42:24 <geezusfreeek> right
10:42:50 <geezusfreeek> yeah, i agree that the intuition of the syntax is really weird
10:43:00 <vincenz> whaleofconfusion: separation of concerns, patternmatching implies datatypes, datatypes should define those foo forms, and thus the binding between arguments and function patterns are through the data-type declaration
10:43:33 <vincenz> whaleofconfusion: if yu like the lispy syntax, take a look at match in the plt-library
10:43:36 <whaleofconfusion> well, as I have it now, it's simple form matching
10:43:46 <whaleofconfusion> just matching on the structure of a form
10:44:04 <vincenz> whaleofconfusion: you want value matching or lexical matching?
10:44:10 <vincenz> the former is datatypes/patternmatching the latter is macros
10:44:17 <whaleofconfusion> lexical... but this is one of the places where I'm not sure
10:44:30 <whaleofconfusion> because I want value matching also to be possible and I'm not sure if I need more syntax for that
10:44:33 <geezusfreeek> ah good insightâ€¦ this is macros
10:44:35 <vincenz> so I suggest you look at those two to compare and contrast with what you want
10:44:46 <geezusfreeek> pattern matching makes little sense to me outside of typed lambda calculus
10:44:48 <whaleofconfusion> or if there's a way to do it with what I have
10:45:00 <vincenz> geezusfreeek: plt-scheme has patternmatching and they're not typed
10:45:07 <geezusfreeek> orly?
10:45:10 <vincenz> nod
10:45:15 <vincenz> well, not compiletimetyped
10:45:15 * geezusfreeek looks it up
10:45:22 <vincenz> plt-match.ss I think
10:45:27 <geezusfreeek> oh, dynamically typed
10:45:32 <geezusfreeek> that still makes sense to me then
10:45:49 <vincenz> http://download.plt-scheme.org/doc/mzlib/mzlib-Z-H-34.html#node_chap_34
10:45:50 <whaleofconfusion> let me put to you a stranger example
10:45:52 <lambdabot> Title: PLT MzLib: Libraries Manual, http://tinyurl.com/2e22s2
10:46:11 <geezusfreeek> i'm just sayingâ€¦ he said it was "untyped" lambda calculusâ€¦ which would rule out even dynamic typing
10:46:34 <vincenz> geezusfreeek: I always imagine that any usable language would have at least some sort of datatypes, be it just cons/car/cdr or ints
10:46:38 <takamura> hi
10:46:54 <vincenz> geezusfreeek: or even WHNF form representation of unevaluated functions
10:47:14 <vincenz> btw, feel free to continue on #oasis, it's more pl-agnostic
10:47:16 <whaleofconfusion> (\ (foo &(+ &x 2)) -> (+ x (foo 30)) <- (+ 71 2))
10:47:18 <vincenz> than #_haskell_
10:47:33 <geezusfreeek> untyped lambda calculus could be considered to have exactly one type, couldn't it?
10:47:46 <vincenz> whaleofconfusion: that does not match does it?
10:48:11 <whaleofconfusion> well, first the outer form (foo &...) matches on (foo 30)
10:48:12 <vincenz> geezusfreeek: unityped :)
10:48:13 <geezusfreeek> aha, yes, i get it now
10:48:33 <whaleofconfusion> so then the value of 30 is bound to the expression (+ &x 2) in the <- place
10:48:42 <vincenz> whaleofconfusion: eh?
10:48:49 <vincenz> so yu acn have multiple <- ?
10:48:58 <whaleofconfusion> multiple &'s
10:49:05 <vincenz> whaleofconfusion: well n
10:49:09 <vincenz> whaleofconfusion: you must have multiple <-
10:49:11 <whaleofconfusion> I want them to switch back and forth between the places
10:49:18 <vincenz> whaleofconfusion: cause you're now patternmatching against the result, so you need to do something with that
10:49:22 <vincenz> or your language makes no sense
10:49:23 <whaleofconfusion> so that a second & puts you back in the -> scope
10:49:34 <geezusfreeek> the "data constructor" here would be just a lambda expression/applicationâ€¦ seems like it could be ambiguous if that is correct
10:49:41 <vincenz> whaleofconfusion: for consistency, you'd nee
10:49:42 <vincenz> d(\ (foo &(+ &x 2)) -> (+ x (foo 30)) <- (+ 71 2) <- (+ x 3))   = 71 + 3
10:49:45 <vincenz> aka
10:49:47 <vincenz> second <-
10:49:54 <whaleofconfusion> let me finish talking this through
10:49:59 <vincenz> caus you're now matching (+ 71 2)... for x, and then not using that x
10:50:07 <whaleofconfusion> you are using it, you're using it in the -> place
10:50:18 <vincenz> ponder
10:50:27 <whaleofconfusion> so it matches the &x to 71 in the -> place
10:50:30 <vincenz> what if yu have a third &
10:50:38 <whaleofconfusion> and it replaces (foo 30) with the value of the <- place
10:50:42 <whaleofconfusion> which is 73
10:50:47 <vincenz> whaleofconfusion: that makes -no- sense
10:50:54 <whaleofconfusion> so it all becomes (+ 71 73)
10:50:55 <vincenz> why is it replacng (foo 30) and not x
10:51:25 <vincenz> whaleofconfusion: that's very confusing...and what if you have more &?  And is there a usecase fr something so convoluted?
10:51:27 <whaleofconfusion> it replaces both of them
10:51:53 <vincenz> btw, move convo to #oasis?
10:52:06 <whaleofconfusion> fine
11:03:39 <shapr> Aw, I like having conversation here on #haskell :-(
11:05:14 <Syzygy-> Hmmm?
11:06:47 <shapr> Just that lambda calculus and programming language theory discussions are fun to read.
11:07:55 <Vq^> hello shapr
11:08:46 <emu> this is annoying.  i wrote my own ST array-based heap priority queue, and it is slower than simple Data.Set.
11:09:23 <ndm> emu: i did that but using IOArray and unsafePerformIO, and got wooped by Set
11:09:24 <SamB> arg. I have some shift/reduce conflicts that I don't get...
11:09:32 <shapr> hej Vq^
11:09:52 <emu> mine's generic to MArrays actually, but yea
11:10:00 <ndm> emu: Haskell is trying to force you to stay pure, by crippling anything impure
11:10:00 <shapr> Why is Data.Set so fast?
11:10:09 * shapr snickers
11:10:27 <ndm> Colin's got a benchmark showing lists outperform Data.Set, by over 100 times in his particular benchmark
11:10:35 <emu> for doing what?
11:10:35 <EvilTerran> because an obscene amount of effort's gone into making it fast, shapr?
11:10:41 <sjanssen> arrays have some major performance problems IIRC
11:10:55 <sjanssen> specifically with garbage collection
11:11:03 <ndm> even without GC, they suck
11:11:23 <ndm> i was using one IOArray, so no real GC to speak of, and they still lost to an IntMap
11:12:00 <ndm> I'm sure at some point someone will research it, figure out why, write a very cool paper on it, and we'll have faster arrays than C
11:12:03 <EvilTerran> they're not really laziness-friendly
11:12:17 <emu> i'm using unboxed arrays
11:12:27 <emu> i converted my data into Word64s
11:12:32 <sjanssen> shouldn't we be happy that purely functional structures are faster?
11:12:41 <emu> not fast enough :(
11:12:54 <emu> this is for BLINNET :P
11:13:29 <ndm> sjanssen: until we want a hash table
11:15:47 <hpaste>  SamB pasted "Parser.y -- where do the shift/reduce conflicts come from?" at http://hpaste.org/252
11:16:43 <Lemmih> SamB: Ask Happy?
11:18:05 <SamB> Lemmih: I did look at the .info file
11:18:15 <SamB> which tells me where they *are*
11:18:23 <SamB> but I still don't know how they came to be there
11:19:10 <Igloo> Where are they then?
11:19:14 <ndm> if you don't want shift-reduce, don't use Happy :)
11:19:23 <ndm> otherwise you tend to need to know how LALR(1) works
11:19:39 <shapr> EvilTerran: Probably so
11:20:15 <ndm> SamB, Term looks like it will generate a shift-reduce conflict
11:20:32 <ndm> those last two lines, "(" Expr, and "(" Expr ")", you probably need to left-factor them
11:20:41 <ndm> "(" Expr bracket, where bracket = ")" | empty
11:21:10 <ndm> and why not Term Terms, then you don't have to reverse the thing
11:21:14 <ndm> plus its more left-factored
11:21:45 <SamB> ndm: the documentation said to do it the other way...
11:22:08 <ndm> SamB, ok, its a while since i read up on happy
11:25:15 <SamB> ndm: that doesn't seem to help
11:25:19 <emu> IntSet outperforms straight up STUArray s Int Bool, wow
11:25:31 <SamB> no wait
11:25:39 * SamB forgot to *use* the new non-terminal ;-)
11:26:27 <SamB> nope, still nothing...
11:28:26 <Igloo> SamB: I haven't looked at the info file or anything, but I suspect the ambiguity is  ( e1 ( e2 )
11:32:44 <SamB> hmm.
11:32:49 <SamB> I see what you mean.
11:33:04 <SamB> well, this is PDP-1 assembler so guess how that's parsed?
11:33:16 <ndm> parsec?
11:33:23 <SamB> ndm: what?
11:33:44 <ndm> SamB, couldn't you use parsec? i tend to prefer that for syntaxes which are a bit ambiguous by nature
11:34:22 <LoganCapaldo> Parsec will never yell at you for shift / reduce conflicts. Unfortunately, Parsec will never yell at you for shift/reduce conflicts
11:34:30 <emu> i think i need to switch to Kruskal and hope i can optimize that better
11:34:50 <SamB> well I guess I've come to the conclusion that the three that are together, at least, are the shift/reduce conflict I was expecting when I started
11:35:17 <SamB> just wanted to make sure
11:35:51 <SamB> the last one also is (I hadn't actually looked at that one yet ;-)
11:36:24 <SamB> anyway, it seems to be fine
11:38:04 <SamB> but how those first three conflicts got to be where they are... I don't get that very well...
11:38:36 <SamB> they do go away when I comment out the case with the omitted ")", though
11:40:59 <SamB> thanks ;-)
11:41:01 <vincenz> yo bringert
11:41:45 <SamB> oh, and for the record, I really wish Parsec was easier to use with input of types other than [Char]
11:42:02 <Igloo> What's the problem?
11:42:15 <SamB> Igloo: problem?
11:42:28 <Igloo> With using Parsec with other token types
11:42:46 <SamB> lots of things are unduly constrained to Char
11:42:55 <Igloo> e.g.?
11:44:00 <SamB> everything in Text.ParserCombinators.Parsec.Char (a few would make sense for non-Char inputs)
11:44:33 * Heffalump really wishes GHC's profiling worked properly
11:44:33 <Igloo> Well, give Daan a concrete list or patch
11:44:42 <Igloo> "properly"?
11:44:56 * LoganCapaldo wished someone woudl make hima  sandwich
11:45:13 <Lemmih> SamB: All of those functions are Char or list specific.
11:45:19 <SamB> (oneOf, noneOf, satisfy, and something similar to anyChar but with a different name come to mind)
11:45:22 <Heffalump> attributed costs to the right place (I still need to make a test case for this to report it), didn't crash on most of the heap profiling options (see bugs reported by Lennart)
11:45:43 <Lemmih> Ah, I see.
11:47:46 <Igloo> SamB: Ah, I vaguely remember thinking the same in the past, but the problem is that it depends on the position updating function
11:48:29 <Heffalump> augustss: I was just having a moan about profiling :-)
11:48:33 <SamB> Igloo: Perhaps a typeclass is in order?
11:48:52 <SamB> (with position updating functions)
11:49:13 <Igloo> SamB: Perhaps, I don't know parsec's design well enough to comment
11:49:44 <SamB> but, I suppose if you go that far it might make sense to get rid of the lists too ;-)
11:51:01 * SamB wonders how hard it would be to adapt Parsec to work with a monadic input source
11:52:22 <EvilTerran> streams!
11:52:31 <mauke> just use getContents
11:52:34 <Heffalump> i.e. make it a monad transformer?
11:52:35 * dmhouse points out that Strings are, in fact, a monad
11:52:51 <SamB> heh
11:52:56 <SamB> not the right kind ;-P
11:53:29 <SamB> I'm using an adapted version of the "Alex" monad
11:53:56 <LoganCapaldo> Strings are a monad? Don't they have the wrong kind?
11:54:04 <LoganCapaldo> :k String
11:54:06 <lambdabot> *
11:54:09 <SamB> well, they are in the [] monad
11:54:24 <SamB> > return '!'
11:54:24 <lambdabot>   add an instance declaration for (Show (m Char))
11:54:34 <SamB> > return '!' :: [Char]
11:54:35 <lambdabot>  "!"
11:54:47 <LoganCapaldo> sure
11:54:52 <SamB> @pl return '!' :: [Char]
11:54:52 <lambdabot> return '!' :: [Char]
11:54:55 <dmhouse> LoganCapaldo: well, I meant "Strings are a monadic type".
11:55:07 <SamB> pl isn't very smart about types ;-P
11:55:43 <Heffalump> dmhouse: by that argument, anything is a monadic type (in the identity monad)
11:55:57 <dmhouse> Heffalump: up to isomorphism.
11:57:19 <SamB> hmm. I've messed up my parser a bit...
11:58:09 <SamB> or the lexer.
11:58:59 * SamB makes the lexer eat newlines at the beginning of the file (after the title)
11:59:32 <LoganCapaldo> A full lexer is a happy lexer
11:59:39 <LoganCapaldo> Mmm, newlines. delicious
11:59:39 <SamB> an alex lexer
11:59:46 <SamB> happy is for parsers
12:12:30 <SamB> evidently, the original assembler handled a good portion of it's syntax by jumping to routines it finds in the same table it looks for macros in...
12:12:40 <roconnor> > let f @@ x = case x of x -> f x in foldl (\x y -> (+) @@ x @@ y) 0 [0..1000000]
12:12:45 <lambdabot>  500000500000
12:12:59 <roconnor> > foldl (+) 0 [0..1000000]
12:13:01 <lambdabot>  500000500000
12:13:08 <roconnor> > foldl (+) 0 [0..1000000000]
12:13:14 <lambdabot> Terminated
12:13:18 <roconnor> > let f @@ x = case x of x -> f x in foldl (\x y -> (+) @@ x @@ y) 0 [0..1000000000]
12:13:23 <lambdabot> Terminated
12:13:39 <SamB> I wonder what I'd need to do to use that approach in Haskell...
12:13:58 <mauke> > foldl' (+) 0 [0..1000000000]
12:14:04 <lambdabot> Terminated
12:14:08 <roconnor> > let f @@ x = case x of x -> f x in (const 0) @@ undefined
12:14:09 <lambdabot>  0
12:14:24 <roconnor> > let f @@ x = case x of 0 -> f 0 | x -> f x in (const 0) @@ undefined
12:14:24 <lambdabot>  Parse error
12:14:32 <mauke> > 1000000000 * 1000000000 `div` 2
12:14:33 <lambdabot>  500000000000000000
12:14:39 <roconnor> > let f @@ x = case x of {0 -> f 0 | x -> f x} in (const 0) @@ undefined
12:14:40 <lambdabot>  Parse error
12:14:43 <mauke> > 1000000000 * (1000000000+1) `div` 2
12:14:45 <lambdabot>  500000000500000000
12:14:59 <roconnor> > let f @@ x = case x of {0 -> f 0 ; x -> f x} in (const 0) @@ undefined
12:15:00 <lambdabot>  Undefined
12:15:31 <SamB> hmm, some of these I'll need to do nasty things to my Lexer for...
12:16:21 <SamB> well... maybe not.
12:17:13 <roconnor> > let myseq x y = case x of {0 -> y ; x -> y} in undefined `myseq` 5
12:17:15 <lambdabot>  Undefined
12:17:54 <roconnor> > @type let myseq x y = case x of {0 -> y ; x -> y} in myseq
12:17:55 <lambdabot>  Parse error
12:18:03 <roconnor> @type (let myseq x y = case x of {0 -> y ; x -> y} in myseq)
12:18:05 <lambdabot> forall t t1. (Num t) => t -> t1 -> t1
12:18:58 <roconnor> suddenly seq isn't looking so bad to me
12:19:30 <roconnor> I can make my own seq for every inductive type
12:19:30 <roconnor> (and some primatives too)
12:22:43 <roconnor> > let myseq x y = case x of {() -> y;} in undefined `myseq` 5
12:22:43 <lambdabot>  Undefined
12:22:43 <roconnor> > let myseq x y = case x of {() -> y;} in () `myseq` 5
12:22:43 <lambdabot>  5
12:30:19 <gattocarlo> lambdabot question: if I'm set as operator in Config.hs, when I enter the channel I should become op, right or wrong? if the second, what am I supposed to do?
12:31:12 <SamB> oh, great, they said that CR and TAB were going to mean the same thing! but no... one pseudo-instruction treats them differently...
12:32:31 <SamB> huh. great. it turns out that PDP-1 characters can have bars over them... and they used this in their syntax too...
12:32:34 <hpaste>  bluestorm pasted "conway" at http://hpaste.org/254
12:34:51 <LoganCapaldo> SamB: My condolences
12:35:17 <hpaste>  bluestorm annotated "conway" with "conway bis" at http://hpaste.org/254#a1
12:38:42 <kpreid> gattocarlo: do yoou mean "admins"? no, that's nicks that can control the bot
12:38:43 <roconnor> I don't think I've ever use seq on a polymorphic type
12:38:58 <roconnor> I don't even recall ever using seq on a non Num type
12:40:45 * SamB wonders if their "not" character, which is rendered in this table as a tilde, should be identified with a tilde or with some unicode character...
12:45:39 <Shurique> is there a simple way to split a string into a list of strings, at points where a certain substring occurs in the original string? (for example splitFunc " - " "foo - bar - baz" = ["foo", "bar", "baz"]
12:46:52 * SamB uses the old bait-and-switch routine on Happy -- thankfully Happy actually *supports* bait-and-switch
12:48:03 <dmhouse> Shurique: for spaces and newlines there words and lines respectively.
12:48:59 <Shurique> dmhouse: I know, but they're not sufficient for this particular purpose
12:49:32 <dmhouse> Shurique: I don't think there is one in the standard libraries. It's one of those functions that everyone misses, and you can probably find some definitions online somewhere.
12:50:56 <EvilTerran> unfortunately, it's also one that everyone would implement differently
12:51:07 <EvilTerran> i suspect that's why it's left out
12:51:13 <mauke> really?
12:51:29 <CosmicRay> Shurique: MissingH has that
12:51:31 <EvilTerran> well, there's a few possibilities
12:51:35 <Heffalump> who cares what the implementation is? There's an obvious spec, surely?
12:51:44 <EvilTerran> eg, what to do with repeated separators
12:51:47 <Heffalump> I guess if you are splitting on substrings rather than characters then overlaps are harder.
12:51:50 <EvilTerran> the empty string
12:51:54 <EvilTerran> overlaps, yes
12:52:03 <EvilTerran> whether to use characters or substrings
12:52:19 <EvilTerran> etc
12:52:21 <CosmicRay> this is actually a list problem, not a string problem, imho
12:52:24 <swiert> What about splitAt?
12:52:36 <Heffalump> repeated separators are obvious; you want concat $ map intersperse foo $ split foo xs == xs
12:53:09 <EvilTerran> is the empty string one or no items?
12:53:11 <Shurique> CosmicRay: MissingH looks interesting, thanks
12:53:33 <Heffalump> EvilTerran: fair point
12:54:01 <mauke> EvilTerran: one item
12:54:14 <Igloo> You may claim it's obvious, but one of words and lines doesn't do the obvious thing
12:54:17 <EvilTerran> overlaps?
12:54:30 <Philippa> anyone got advice for somewhere to host a blog, or software to host a blog with, given that I'll want to do a lot of haskell and maths and will want syntax highlighting and LaTeX support?
12:54:42 <Igloo> Or maybe it's actually unlines or unwords that doesn't, I forget
12:54:51 <Heffalump> Igloo: and isn't an inverse of the opposite one?
12:54:51 <EvilTerran> words and lines, iirc
12:54:51 <CosmicRay> Igloo: depends on whose definition of obvious you adhere to
12:55:05 <mauke> EvilTerran: overlaps are ignored
12:55:06 <CosmicRay> >words "foo bar   baz"
12:55:17 <CosmicRay> bah what is the way to make the bot interpret something?
12:55:21 <EvilTerran> Heffalump, neither are inverse pairs
12:55:27 <mauke> >
12:55:35 <Igloo> Heffalump: Yeah
12:55:37 <CosmicRay> then why didn't it respond?
12:55:40 <EvilTerran> > words . unwords $ ["foo bar", "baz"]
12:55:42 <lambdabot>  ["foo","bar","baz"]
12:55:51 <CosmicRay> > words "foo bar   baz"
12:55:51 <mauke> because you forgot the
12:55:51 <lambdabot>  ["foo","bar","baz"]
12:55:51 <byorgey> Philippa: Wordpress has LaTeX support... no built-in support for syntax highlighting but not too hard to run through hscolour and paste HTML
12:55:54 <Igloo> Ah, it's words:
12:55:57 <Igloo> > unwords $ words "  "
12:55:58 <EvilTerran> > lines . unlines $ ["foo\nbar", "baz"]
12:55:58 <lambdabot>  ""
12:55:59 <lambdabot>  ["foo","bar","baz"]
12:56:07 <CosmicRay> mauke: the what?
12:56:14 <mauke> the space :-)
12:56:15 <Igloo> EvilTerran: Making it the inverse that way round just isn't possible, though
12:56:21 <Igloo> without a precondition, at least
12:56:32 <EvilTerran> > unlines . lines $ "foo\n\nbar"
12:56:33 <lambdabot>  "foo\n\nbar\n"
12:56:44 <CosmicRay> > unwords ["foo", "bar", "baz"]
12:56:45 <EvilTerran> > unwords . words $ "foo  bar"
12:56:45 <lambdabot>  "foo bar baz"
12:56:45 <Philippa> byorgey: thanks
12:56:46 <lambdabot>  "foo bar"
12:56:51 <CosmicRay> now to me, words is doing the obvious thing.
12:56:56 <Igloo> Oh, so maybe it's both of them in different ways
12:57:02 <Heffalump> EvilTerran: ok, but are they Galois Connections? (I think that's what I mean)
12:57:18 <mauke> > words " "
12:57:19 <EvilTerran> i have no idea what a galois connection is.
12:57:19 <lambdabot>  []
12:57:20 <CosmicRay> a "word" in this sense is a notion of English, not of mathematics
12:57:42 <Heffalump> I want words . unwords . words == words
12:57:48 <mauke> 'words' is an extract, not a split
12:58:17 <EvilTerran> Heffalump, i... think that's the case for both, both ways round
12:58:41 <gaal> recursive geography: http://www.elbruz.org/islands/Islands%20and%20Lakes.htm (is that a floating point or a fixed point?)
12:58:41 <byorgey> @qc \s -> (words . unwords . words $ s) == (words s)
12:58:41 <lambdabot> Not enough privileges
12:58:42 <lambdabot> Title: The Island and Lake Combination
12:58:43 <ski> forall x y. (f x <= y  <=>  x <= g y)
12:58:44 <ski> ?
12:58:47 <Vulpyne> %1
12:58:50 <Vulpyne> Oops.
12:58:55 <byorgey> @quickcheck \s -> (words . unwords . words $ s) == (words s)
12:58:56 <lambdabot> Unknown command, try @list
12:59:07 <byorgey> @list
12:59:08 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
12:59:29 <byorgey> @check \s -> (words . unwords . words $ s) == (words s)
12:59:31 <lambdabot>  OK, passed 500 tests.
13:00:05 <Heffalump> EvilTerran: and you should clearly learn what a Galois Connection is. Good for the soul.
13:00:11 <EvilTerran> heh
13:00:19 <byorgey> @check \s -> (unwords . words . unwords $ s) == (unwords s)
13:00:20 <lambdabot>  Falsifiable, after 5 tests: ["\80146\1013940\545689","","\292697\925273\4479...
13:00:29 <ski> Heffalump : hm, with galois connections, don't you only have inequalities ?
13:00:52 <EvilTerran> byorgey, O.o
13:01:04 <Heffalump> ski: I thought you have the equality I described. But it's been a long time since I learnt abuot them.
13:01:08 <byorgey> EvilTerran: I think the point is the empty string in there
13:01:15 <ski> f =< f . g . f  /\  g . f . g =< g
13:01:16 * SamB just hopes nobody ever uses the "char" pseudoinstruction on a capital letter
13:01:21 <byorgey> > unwords ["abc","","def"]
13:01:22 <lambdabot>  "abc  def"
13:01:27 <EvilTerran> aha
13:01:32 <byorgey> extra space
13:01:34 <EvilTerran> i c wut u did thar :P
13:01:49 <byorgey> > unwords . words . unwords $ ["abc","","def"]
13:01:50 <lambdabot>  "abc def"
13:02:02 <SamB> @hoogle a -> [a] -> Int
13:02:02 <lambdabot> No matches, try a more general search
13:02:11 <SamB> @hoogle [a] -> a -> Int
13:02:11 <lambdabot> No matches, try a more general search
13:02:14 <ski> Heffalump : istr someone saying adjunctions is a categorical generalizations of galois connections (in a sense), and with the former, you only get "inequalities" (natural transformations)
13:02:18 <SamB> @hoogle find
13:02:18 <lambdabot> List.find :: (a -> Bool) -> [a] -> Maybe a
13:02:18 <lambdabot> List.findIndex :: (a -> Bool) -> [a] -> Maybe Int
13:02:18 <lambdabot> List.findIndices :: (a -> Bool) -> [a] -> [Int]
13:02:26 <kpreid> @check \x -> x == unwords (words x)
13:02:28 <lambdabot>  Falsifiable, after 229 tests: "\929169\544256\359888\153172\170376\404231\58...
13:02:56 <EvilTerran> shurely there'd be better choices of testcases for that? O.o
13:02:56 <byorgey> > words "abc     def"
13:02:57 <lambdabot>  ["abc","def"]
13:03:05 <byorgey> > unwords $ words "abc     def"
13:03:06 <lambdabot>  "abc def"
13:03:07 <Heffalump> ski: I think you're right. Oh well.
13:03:21 <mauke> EvilTerran: here's the real problem: what should split "" do?
13:03:26 <SamB> :t findIndex
13:03:27 <ski> @check \x -> x == words (unwords x)
13:03:28 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
13:03:29 <lambdabot>  Falsifiable, after 13 tests: [""]
13:03:34 <byorgey> EvilTerran: well, they're random characters... =P
13:03:36 <EvilTerran> 2049<EvilTerran> the empty string
13:03:43 * SamB realizes that lambdabot imports Data.List anyway...
13:03:46 <EvilTerran> :D
13:04:41 <byorgey> words discards information.
13:04:52 <ski> so does pictures
13:05:02 * SamB realizes that he can derive Bits for his Pdp1Word type
13:05:31 <byorgey> is an unpicture worth a thousand unwords?
13:06:03 <mauke> Data.List> quickCheck $ \s t -> concat (intersperse s (unjoin s t)) == t
13:06:03 <mauke> OK, passed 100 tests.
13:06:18 <EvilTerran> unjoin?
13:06:32 <Heffalump> @check \x -> words x == words (unwords (words x))
13:06:33 <lambdabot>  OK, passed 500 tests.
13:07:21 <hpaste>  mauke pasted "unjoin" at http://hpaste.org/255
13:07:32 <byorgey> Heffalump: the other way doesn't work, though.
13:07:54 <Heffalump> yeah
13:08:11 <Heffalump> oh, you checked my way too, sorry
13:11:22 <byorgey> Heffalump: np =)
13:11:32 <byorgey> @help figlet
13:11:32 <lambdabot> figlet <text>. Run the figlet filter on <text>.
13:11:36 <byorgey> o.O
13:12:05 <byorgey> @figlet \x->x+1
13:12:05 <lambdabot> Couldn't run the figlet command.
13:12:08 <byorgey> aww
13:17:57 <ski> @check let x <= y = x `elem` foldr (\c ss -> map (c:) ss ++ ss) [""] y in \x -> x <= unwords (words x)
13:17:59 <lambdabot>  OK, passed 500 tests.
13:18:09 <ski> @check let x <= y = x `elem` foldr (\c ss -> map (c:) ss ++ ss) [""] y in \x -> unwords (words x) <= x
13:18:15 <lambdabot> Terminated
13:20:22 <kinduzikonch> what is this? :)
13:21:13 <ski> that depends on what "this" refers to :)
13:25:02 <kinduzikonch> this is what the bot did with the code. :)
13:29:17 <byorgey> kinduzikonch: it's an interface to quickcheck, which allows you to test properties with randomly generated test data
13:30:19 <ski> i was (attempting) to test some galois connection properties of 'words' and 'unwords'
13:31:35 <byorgey> ski: I've never heard of Galois connections (other than the name of the company).  any URLs/papers you could share?
13:31:40 <kinduzikonch> can i download quickcheck somewhere?
13:32:38 <ski> byorgey : i haven't actually read much on them .. maybe check WP ?
13:32:38 <byorgey> kinduzikonch: It's normally included with GHC, I think...?
13:32:38 <byorgey> ski: ok, thanks
13:32:38 <dmwit> kinduzikonch: You probably already have it.
13:32:38 <dmwit> Try,
13:32:40 <dmwit> ghc-pkg list | grep heck
13:32:41 <ski> @where quickcheck
13:32:41 <lambdabot> http://www.cs.chalmers.se/~rjmh/QuickCheck/
13:33:46 <kinduzikonch> thanks
13:33:58 * SamB wishes more attention had been payed to making the language extension names easy to memorize
13:34:10 <SamB> also easy to guess
13:35:10 <emu> sjanssen: did you have any tricks to speed-up kruskal?
13:38:33 <sjanssen> emu: how are you parsing the input?
13:40:29 <emu> strict bytestrings, readInt.  profiling indicates that it isn't the bottleneck
13:40:51 <sjanssen> and you're using Prim's algorithm?
13:41:01 <emu> i have implementations of Prim's and Kruskal's
13:41:11 <emu> about 7-8 different versions, different data structures
13:41:40 <emu> right now the best is the one which uses Prim's with an IntSet to track visited nodes, and my STArray Heap as the priority queue
13:41:52 <emu> *STUArray heap
13:42:00 <sjanssen> which sort do you use with Kruskal's?
13:42:06 <emu> I have 3 versions:
13:42:16 <SamB> Igloo: say, did you get that happy patch I sent you?
13:42:22 <emu>   * Data.Set sorting, * list sorting, * STArray heap sorting
13:42:39 <emu> none of them do particularly better than the other, and they're all worse than that Prim's
13:43:13 <emu> oh, i use an STUArray-based Union Find
13:43:18 <emu> for all
13:43:41 <SamB> @localtime Igloo
13:43:42 <lambdabot> Local time for Igloo is Tue Jun 12 21:43:01 2007
13:44:11 <sjanssen> emu: and you do the standard optimizations (path compression, tracking rank)?
13:44:14 <emu> yes
13:44:32 <sjanssen> that sucks
13:44:44 <emu> bottleneck on kruskals does appear to be sorting
13:44:56 <sjanssen> yeah, that's usual
13:44:59 <emu> bottleneck on Prim's is pulling the edges out of the heap
13:45:10 <sjanssen> I wonder if an IntMap sort can do better
13:45:25 <dmhouse> I though bottleneck on Kruskal's was checking for cycles?
13:45:33 <mdmkolbe|work> @where spec
13:45:33 <lambdabot> I know nothing about spec.
13:45:49 <emu> possibly, but i need to know target/source node as well as weight
13:46:05 <emu> dmhouse: well, i believe the union-find renders that O(n ack(n))
13:46:24 <sjanssen> yeah, you have to do something like IntMap Weight [EdgePair]
13:46:27 <emu> amortized anyhow
13:46:49 <emu> ah mm
13:46:57 <emu> if i toList that, will it be sorted?
13:47:06 <sjanssen> I believe so
13:47:22 <sjanssen> emu: one big optimization is strict data fields + -funbox-strict-fields
13:47:24 <sjanssen> do you do that already?
13:47:48 <emu> i'm using newtypes
13:48:01 <sjanssen> so you represent an edge as a tuple?
13:48:16 <emu> yes
13:48:44 <sjanssen> data Edge = Edge {from, to, weight :: !Int} should be a big win
13:49:03 <emu> vs newtype Edge = E (Int, Word) ?
13:49:06 <sjanssen> yes
13:49:40 <sjanssen> that tuple is represented as two pointers to boxed words
13:49:54 * SamB <3 {% ... }
13:49:59 <SamB> arg.
13:50:03 * SamB <3 {%% ... }
13:50:13 <sjanssen> a data type with strictness annotations and -funbox-strict-fields unpacks the words straight into the data type
13:50:36 <mdmkolbe|work> ok what's that word that sounds like 'loo' but means 'in place of'?
13:50:39 <sjanssen> emu: double check, but you should see a (small) instance performance boost with that
13:50:42 <Heffalump> lieu
13:50:51 <sjanssen> s/instance/instant
13:50:53 * mdmkolbe|work is better at spelling Latin than English
13:51:07 <mdmkolbe|work> Heffalump: thx
13:51:15 <Heffalump> I think that word is French, though I could be mistaken
13:52:04 <SamB> sjanssen: or
13:52:10 <SamB> {-# UNPACK #-}
13:59:39 <Shurique> is it possible to read a string such as "1.5" to a Double?
13:59:53 <SamB> > read "1.5" :: Double
13:59:54 <lambdabot>  1.5
14:00:03 <mauke> heh
14:00:28 <Shurique> oh, thanks :)
14:01:07 <SamB> you probably won't even need the :: Double most of the time
14:01:23 <emu> hm
14:01:27 <Shurique> well, read "1.5" without it raises an error
14:01:35 <emu> Shurique: only when it is ambiguous in context
14:01:57 <Shurique> ah of course
14:03:30 <emu> :/ no big change
14:04:00 <emu> guess i'll try intmap sorting
14:04:05 <Igloo> SamB: Yup, thanks
14:04:39 <SamB> Igloo: nice ;-)
14:05:43 <SamB> I tried to send that in ... sometime near the date on the patch. Of course, I haven't used happy much since the time immediately after that, before now
14:06:04 <shapr> I AM A MONAD!
14:06:12 <opqdonut> ok
14:06:16 <SamB> shapr: can I use you with Alex?
14:06:26 <opqdonut> ?remember shapr I AM A MONAD!
14:06:27 <lambdabot> Done.
14:06:29 <opqdonut> :)
14:06:32 <shapr> I'm already being used with Alex, sorry.
14:06:33 <mauke> ?quote
14:06:34 <lambdabot> xic says: and i imagine that lisp hasn't changed since it's creation in 1866
14:06:34 * shapr grins
14:06:41 <opqdonut> ?quote MONAD
14:06:41 <lambdabot> autrijus says: Well, ever since the monadic revolution of '98 Haskell people have started to do real world apps
14:06:48 <opqdonut> :(
14:06:52 <opqdonut> ?quote shapr
14:06:52 <lambdabot> shapr says: Aha, so that's the sticky stuff on my keyboard!
14:07:04 <shapr> aieee
14:07:05 <opqdonut> i thought that wouldn't work :)
14:07:07 <opqdonut> ?quote shapr
14:07:07 <lambdabot> shapr says: there's an important niche market for OSes that don't crash.
14:07:12 <opqdonut> :)
14:07:13 <SamB> do you suppose autrijus (is that audreyt?) meant things like PDP-1 assemblers?
14:07:39 <shapr> opqdonut: That's especially funny since the Python-Twisted quote file collection has "<shapr> I am an object!"
14:08:00 <SamB> shapr: I like our distribution method better
14:08:38 <shapr> I do too, I'm convinced that monads are a simpler abstraction that objects, but I don't yet have a good way to measure that.
14:08:57 <SamB> I meant, the way we get at our quote jar ;-)
14:09:15 <shapr> I think that 'options theory' based abstraction measurement paper is a good start, but I think they should have used economic principles, not made up their own.
14:10:10 <SamB> how does an economist reckon the cost of making a change to GHC?
14:11:25 <shapr> I bet an economist has a variety of ways of putting monetary value on the option to buy something.
14:12:09 <Heffalump> shapr: who should have used economic principles?
14:12:16 <shapr> Modularity in code is related to stock options in that it's a cost ahead of time that might pay off later.
14:12:22 <shapr> Heffalump: It's a recent paper on LtU.
14:12:23 <SamB> yes, but usually anyone who would sell such options would have some idea as to the cost of delivering the goods
14:12:49 <emu> sjanssen: intmaps do well, but not as well as prim's
14:12:56 <SamB> and I suppose so would those who would buy them would want to, as well.
14:13:08 <SamB> and they'd probably want to agree on a way to determine the price...
14:13:20 <Heffalump> shapr: I don't see it - how recent?
14:15:37 * shapr is looking for the paper...
14:17:54 <shapr> I've downloaded too many papers recently, it's lost in a welter of confusion :-(
14:18:07 <Heffalump> never mind, bedtime for me anyway
14:19:52 <shapr> I download a bunch of papers.. wish I read them as often as I download them :-)
14:26:07 <apfelmus> ?src inits
14:26:08 <lambdabot> inits []     =  [[]]
14:26:08 <lambdabot> inits (x:xs) =  [[]] ++ map (x:) (inits xs)
14:26:24 <apfelmus> > inits (1:undefined)
14:26:26 <lambdabot>  Undefined
14:26:33 * apfelmus complains
14:26:53 <dmwit> > head (inits (1:undefined))
14:26:55 <lambdabot>  []
14:27:05 * dmwit scolds apfelmus
14:27:21 <kaol> > take 2 (inits (1:undefined))
14:27:22 <lambdabot>  Undefined
14:27:24 <apfelmus> hehe
14:27:31 * apfelmus complains!
14:27:33 <kaol> > take 2 (inits (1:2:undefined))
14:27:35 <lambdabot>  [[],[1]]
14:27:50 <apfelmus> inits is too strict
14:28:14 * dmwit hits!  dmwit hits! <More>
14:28:15 <apfelmus> I expected inits (1:_|_) = [] : [1] : _|_
14:29:06 <dmwit> apfelmus: Yeah, it looks like it ought to be from that definition, too.
14:29:36 <apfelmus> yeah, indeed
14:29:49 <dmwit> Oh, I see, the (inits xs) is (inits undefined), which doesn't start with [[]] at all.
14:29:50 <SamB> you don't like [] : (1:_|_) : _|_?
14:30:11 <dmwit> SamB++
14:30:14 <apfelmus> no. And it's even worse
14:30:27 <SamB> ... oh yeah?
14:30:33 <apfelmus> > inits (1:undefined) !! 1
14:30:34 <lambdabot>  Undefined
14:30:41 <Saizan> the undefined blows on the pattern match
14:30:42 <apfelmus> > inits (1:undefined) !! 1!! 0
14:30:43 <lambdabot>  Undefined
14:31:03 <apfelmus> ?src map
14:31:04 <lambdabot> map _ []     = []
14:31:04 <lambdabot> map f (x:xs) = f x : map f xs
14:31:08 <dmwit> apfelmus: How is that different from the previous (take 2) version?
14:31:34 <dmwit> > inits (0:1:undefined) !! 1
14:31:35 <lambdabot>  [0]
14:31:37 <bos> @seen xerox
14:31:37 <lambdabot> I saw xerox leaving #haskell 2d 3h 52m 37s ago, and .
14:31:51 <dmwit> > take 2 $ inits (0:1:undefined)
14:31:52 <lambdabot>  [[],[0]]
14:32:04 <SamB> arg.
14:32:09 <SamB> what happened to ChasingBottoms...
14:32:13 <apfelmus> dmwit: in SamBs version, the second element is a list but only a partial one
14:32:43 <apfelmus> dmwit: but ghci does not give even that, the second element is just _|_
14:32:54 <dmwit> Ah, good point.
14:32:59 <SamB> huh.
14:33:04 <dmwit> That is a bit odd.
14:33:19 <apfelmus> I mean, currently inits (1:_|_) = [] : _|_
14:33:29 <SamB> ... I don't even see the :
14:33:50 <apfelmus> I think that map (x:) is to blame
14:34:12 <apfelmus> or maybe not
14:34:16 <apfelmus> inits is to blame
14:34:23 <dmwit> apfelmus: Also keep in mind that it isn't implemented in GHC quite the way it's written in the report.
14:34:33 <dmwit> ?source Prelude
14:34:33 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
14:34:48 <dmwit> ?index inits
14:34:48 <lambdabot> Data.List
14:34:51 <dmwit> ?source Data.List
14:34:52 <lambdabot> http://darcs.haskell.org/packages/base/Data/List.hs
14:34:54 <apfelmus> but I have guaranteed semantics :)
14:35:01 <apfelmus> actually, I think it's inits fault
14:35:13 <apfelmus> the common [[]] has to be factored out
14:35:51 <apfelmus> inits xs = [[]] ++ case xs of { [] -> []; (x:xs) -> map (x:) (inits xs); }
14:36:13 <SamB> try http://www.cse.unsw.edu.au/~dons/code/streams/ChasingBottoms/
14:36:13 <lambdabot> Title: Index of /~dons/code/streams/ChasingBottoms
14:36:43 <olsner> @pl (\x -> ap [(x:),id])
14:36:43 <lambdabot> ap . (: [id]) . (:)
14:37:24 <apfelmus> SamB: oh, that looks cool. Is there a webpage for it?
14:39:45 <olsner> @pl (\x->ap[id,(x:)])
14:39:45 <lambdabot> ap . (id :) . return . (:)
14:40:34 <SamB> apfelmus: I don't see one
14:40:45 <Saizan> i don't see why use [[]] ++ instead of []:
14:40:59 <SamB> the closest is http://www.cs.chalmers.se/~nad/software/ChasingBottoms/docs/
14:41:09 <apfelmus> Saizan++
14:42:30 <Saizan> however with your last version you are returning a []: before inspecting xs, so it works..
14:43:21 <apfelmus> SamB: Yummy, the library looks really great. I mean, it solves the halting problem ;)
14:43:30 <SamB> apfelmus: no...
14:43:50 <masklinn> SamB: prove it
14:43:52 <SamB> if you want it to deal with bona-fide non-terminating stuff, you need to use a timeout
14:44:14 <apfelmus> SamB: I'm just kidding ;)
14:44:25 <SamB> ... it only helps with exceptional bottoms
14:44:43 <SamB> and, really, exceptional bottoms are the only kind of bottoms you should ever chase ;-P
14:45:16 <Heffalump> ok, so it's just unsafePerformIO + catch
14:45:25 <monochrom> You should chase to the bottom of it.
14:45:27 <SamB> Heffalump: well, that's what isBottom is
14:45:42 * Heffalump is a little dubious that advertising such a facility is a good idea. It's rather dubious semantically, to say the least.
14:45:42 <apfelmus> well, the timeout can be very handy when you have an infinite structure and quickly want to know what's going on
14:45:43 <SamB> it also has something called approxShow
14:45:59 <SamB> approxShow has a recursion limit anyway
14:46:27 <monochrom> which library is it?
14:46:49 <SamB> huh?
14:46:51 <SamB> which library?
14:47:08 <SamB> Test.ChasingBottoms
14:47:22 <monochrom> the library that apfelmus says "looks really great". thanks.
14:47:33 <emu> i wish you could specify exe heap size with compiler options :/
14:47:50 <SamB> emu: instead of RTS options?
14:47:51 <Heffalump> http://www.cse.unsw.edu.au/~dons/code/streams/ChasingBottoms/
14:47:51 <lambdabot> Title: Index of /~dons/code/streams/ChasingBottoms
14:48:01 <Heffalump> (you joined just after it was mentioned)
14:48:04 <olsner> @index bottom
14:48:04 <lambdabot> Test.QuickCheck.Batch, Debug.QuickCheck.Batch
14:48:36 <apfelmus> Heffalump: Sure it's a hack. But in Haskell, even supposedly sinister hacks are of shining beauty :)
14:48:41 <fasta> Anyone of you using darcsweb? I want to use a symbolic link to point to a directory in /var/www/darcs
14:48:45 <emu> SamB: yae
14:48:54 <olsner> does bottom in those code examples refer to some constant bottom or to "any expression that raises an exception"?
14:48:56 <SamB> emu: so ... make a ticket?
14:49:00 <fasta> It looks like darcsweb doesn't recognize symbolic links.
14:49:10 <SamB> @where bugs
14:49:10 <lambdabot> I know nothing about bugs.
14:49:13 <SamB> @where bug
14:49:13 <lambdabot> I know nothing about bug.
14:49:22 <SamB> @trac
14:49:22 <lambdabot> Maybe you meant: rc src
14:49:23 <fasta> @bugs
14:49:24 <lambdabot> http://hackage.haskell.org/trac/ghc/newticket?type=bug
14:49:29 <SamB> oh.
14:50:11 <emu> eh, what ireally should do is figure out why i'm chewing up the GC
14:50:13 <SamB> hmm, bug isn't really the right ticket ype
14:54:33 <fasta> SamB: you can change it on that page.
14:54:42 <fasta> So... nobody use darcsweb?
14:55:00 <SamB> I think most of us just dump our repos in webspace...
14:55:09 * jao does
14:55:43 <fasta> jao: let me guess: you don't use symbolic links?
14:56:06 <jao> fasta, where? inside my repos?
14:58:25 <fasta> jao: no, from /var/www/darcs/ to somewhere else
14:59:21 <jao> fasta, well, sort of. my repos live in my home, and darcsweb reads them from there. the links are in the apache home.
14:59:30 <augustss> yo!
14:59:51 <fasta> jao: that's exactly what I need.
15:00:09 <jao> fasta, that's exactly what i do :)
15:00:09 <fasta> jao: how did you get that to work?
15:00:33 <fasta> jao: I get all kinds of XML parsing errors when I try that.
15:00:35 <jao> fasta, i've done nothing special, i think
15:00:48 <Modius> What's the haskell function for "terminate on predicate"?  E.g. SomeFunc predicate infinitelist
15:00:57 <fasta> jao: what permissions do you use?
15:01:01 <ddarius> takeWhile ?
15:01:19 <monochrom> dropWhile ?
15:01:20 <kpreid> Modius: until might be relevant.
15:01:27 <kpreid> @type takeWhile
15:01:29 <lambdabot> forall a. (a -> Bool) -> [a] -> [a]
15:01:31 <kpreid> @type until
15:01:33 <lambdabot> forall a. (a -> Bool) -> (a -> a) -> a -> a
15:01:35 <Modius> Thanks
15:01:52 <jao> fasta, my repos are in a machine with multiple virtual hosts. i'm the owner of the apache root for one of them, and the darcsweb cgi lives in that virtual host too
15:01:59 <monochrom> @index until
15:01:59 <lambdabot> Prelude
15:02:04 <monochrom> interesting!
15:03:38 <emu> hmm, significant changes to ByteString in ghc head vs 6.6.1?
15:03:40 <emu> or 6.6
15:03:43 <emu> yow
15:04:48 <shapr> YOW!
15:04:48 <ddarius> > until (uncurry (==)) (\(o,n) -> (o+(n*n - 2)/(2*n),n)) (0,1) :: (Double,Double)
15:04:50 <Igloo> emu: Not to the API
15:04:52 * jao still has to understand what's the difference between forall a.type[a] and just type[a]
15:04:54 <lambdabot> Terminated
15:05:02 <ddarius> > until (uncurry (==)) (\(o,n) -> (o-(n*n - 2)/(2*n),n)) (0,1) :: (Double,Double)
15:05:04 <lambdabot>  (1.0,1.0)
15:05:26 <Igloo> jao: The forall a. is just implicit in Haskell98
15:05:48 <ddarius> > until (uncurry (==)) (\(o,n) -> (o+2*n/(n*n - 2),n) (0,1) :: (Double,Double)
15:05:48 <lambdabot>  Parse error
15:06:00 <ddarius> > until (uncurry (==)) (\(o,n) -> (o+2*n/(n*n - 2),n)) (0,1) :: (Double,Double)
15:06:06 <lambdabot> Terminated
15:07:21 <jao> Igloo, oh that's what i thought... i guess that means that it won't in h'... but i don't see why that will be useful. i mean, is there any other way of interpreting an unqualified T a?
15:07:21 <fasta> jao: It is a permissions problem.
15:07:31 <fasta> jao: but darcsweb didn't bother to inform me of that.
15:07:49 <Igloo> jao: No, I meant Haskell 98 vs GHC (etc) extensions
15:07:52 <jao> fasta, aha! did you fix that?
15:07:56 <Igloo> Haskell' will also have implicit foralls
15:07:58 <sorear> 77 new messages in 8 hours!
15:08:09 <fasta> jao: I don't intend to learn Python.
15:08:38 <jao> Igloo, but ghc also has implicit forall, doesn't it?
15:08:43 <fasta> jao: Do you happen to know what the least amount of permissions it needs?
15:08:47 <monochrom> There are other ways of putting "forall"s.  forall a. (forall b. b -> b) -> a -> a
15:08:55 <fasta> jao: + is
15:09:39 <Igloo> jao: Yes, but it also allows explicit forall (which Haskell98 doesn't)
15:09:55 <augustss> igloo: how's ghc?  do you know if (installed) ghci works in HEAD yet?
15:10:49 <jao> fasta, hmmm, no. in my case, all files have read/write access for my user's group... but i'm not sure under what group is running apache (i don't think it's mine, but i don't know how exactly permissions are managed in apache's virtual hosts)
15:10:50 <sorear> augustss: ghci has worked in head for a while
15:11:03 <sorear> 0602 ghci works, fex
15:11:21 <augustss> sorear: have you tried 'make install' on a mingw machine?
15:11:25 <Igloo> augustss: I don't think I knew it wasn't working, but I just pushed a batch of build system changes, so it's more likely to now
15:11:32 <jao> Igloo, i see. so one could say that forall plays just a documentation/informational role in those cases?
15:12:22 <Igloo> jao: The reason it's now allowed is because it gives types different meaning when you have higher rank types
15:12:25 <augustss> igloo: I filed a bug report.  ghci works uninstalled, but once you install it it fails with some unresolved reference
15:12:37 <emu> > ord '-'
15:12:39 <lambdabot>  45
15:12:40 <emu> > ord '+'
15:12:41 <lambdabot>  43
15:12:45 <Igloo> augustss: Is this on Windows?
15:12:56 <augustss> igloo: yes.  mingw
15:13:30 <Igloo> augustss: OK, I'm pretty sure I've tested with the patches I just pushed on cygwin, but I haven't tried mingw
15:13:45 <jao> Igloo, i'll have to read about higher rank types before i really understand that reason. but thanks: i take a mental note on that.
15:14:03 <augustss> I'll try again tomorrow.  it's been failing for that last two months
15:14:27 <augustss> i'm sure it's something trivial
15:40:47 <sorear> @users
15:40:48 <lambdabot> Maximum users seen in #haskell: 332, currently: 308 (92.8%), active: 43 (14.0%)
15:44:58 * MyCatVerbs pokes the channel with a stick of -5 to Idleness.
15:45:02 <MyCatVerbs> @users
15:45:02 <lambdabot> Maximum users seen in #haskell: 332, currently: 309 (93.1%), active: 44 (14.2%)
15:45:10 <MyCatVerbs> w00t, statistical improvement!
15:45:54 * savanni has nothing to contribute, and thus lurks.
15:46:12 <MyCatVerbs> Yaaay, the rate increases further. ^^
15:48:30 <sorear> !paste
15:48:30 <hpaste> Haskell paste bin: http://hpaste.org/
15:49:43 <Saizan> ?docs Text.Regex
15:49:43 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Text-Regex.html
15:52:41 <emu> ugh, this is frustrating.  i have it down to C speed except for the GC overhead which is extreme
15:52:56 <SamB> emu: where are you getting allocation?
15:53:00 <sorear> @paste
15:53:00 <lambdabot> Haskell pastebin: http://hpaste.org/new
15:53:40 <SamB> hmm. it occurs to me that I'd like a way to see hotspots burning a hole in my screen
15:54:20 <SamB> ... not quite literally
15:54:35 <sorear> nominolo: Have you heard that recentish versions of xmonad (not the head and not 0.2, but an interval in between) won
15:54:52 <sorear> nominolo: 't build on GHC HEAD because of pretty-in-base variations?
15:55:17 <desp> hm
15:55:30 <sorear> desp: ?
15:55:40 <hpaste>  emu pasted "its ugly" at http://hpaste.org/256
15:55:42 <nominolo> sorear: did you really mean me?
15:56:06 <sorear> nominolo: I meant the Cabal Configurations guy who just asked about test cases.
15:56:12 <nominolo> oh
15:56:14 <sorear> nominolo: Is my nick/name memory failing?
15:56:20 <hpaste>  emu annotated "its ugly" with "prof data" at http://hpaste.org/256#a1
15:56:20 <desp> I'm wondering whether to use the strict or lazy variant of ByteString
15:56:24 <nominolo> right then it's me
15:56:32 <sorear> desp: how much data do you have?
15:57:31 <emu> what really puzzles me is the amount of allocation inside of the byte-string related functions
15:57:35 <desp> the data's potentially large, but usually << 2GB.  what's more important IMO, is that the data is going to be available in chunks, and should be composed into one BS.
15:57:55 <nominolo> sorear: so to test this i'd need ghc head, xmonad + deps, right?
15:58:09 <sorear> nominolo: ... yes. :(
15:58:27 <nominolo> too bad my cabal-install is broken
15:59:14 <hpaste>  emu annotated "its ugly" with "cut-off portion" at http://hpaste.org/256#a2
15:59:26 <desp> sorear: do you have any suggestions?
15:59:31 <nominolo> sorear: but thanks, consider it noted
15:59:43 <sorear> desp: Lazy.
16:00:47 <desp> mm.
16:01:43 <nominolo> desp: mhat interface do you have in mind?
16:03:28 <desp> nominolo: you didn't respond to Jules' mail, after all :)
16:03:55 <nominolo> yeah.  been kinda busy
16:04:08 <gattocarlo> hi, anyone know whre the Data.Bianary.Deferrer module can be found? (i'm lost in a dependency)
16:04:20 <sorear> @where binarydefer
16:04:20 <lambdabot> I know nothing about binarydefer.
16:04:36 <sorear> http://www-users.cs.york.ac.uk/~ndm/binarydefer
16:04:37 <lambdabot> Title: Neil Mitchell - Deferred Binary
16:04:50 <gattocarlo> great!
16:04:54 <monochrom> lost in compilation :)
16:04:54 <sorear> gattocarlo: OOC, what depends on it?
16:05:03 <gattocarlo> its a dependency of hoogle, indeed
16:05:06 <sorear> gattocarlo: it's not released...
16:05:12 <gattocarlo> (no mention in cabal, though)
16:05:24 <sorear> gattocarlo: ah yes, hoogle is in the no-mans-land between rewrites
16:05:42 <sorear> gattocarlo: try it, but don't blame yourself if you have to downgrade to 0.3
16:06:07 <gattocarlo> i'll try
16:07:06 <nominolo> desp: i think you should go for explicit chunking.  ie, some kind of fold
16:08:31 <desp> nominolo: chunking according to what, file structure?
16:09:08 <nominolo> number of bytes
16:09:28 <desp> so, byte-by-byte?
16:09:50 <nominolo> no chunk-bys
16:10:04 <nominolo> -chunk
16:10:18 <desp> pardon me, but I don't understand you.
16:10:34 <SamB> hmm. I want to put some tabs in a file...
16:10:38 <nominolo> possible _additions_ could be a predicate to specify semantic chunks (eg lines)
16:12:09 <nominolo> desp: processing function gets strict bytestrings of some specified size
16:12:30 <nominolo> *the
16:13:14 <nominolo> you can always add a lazy interface later an
16:13:18 <nominolo> *on
16:13:25 <desp> I'm not exactly sure yet how the lazy bytestring works, but I'd think that such non-deterministic chunking at this level is best hidden as an implementation detail
16:13:37 <desp> aren't lazy bytestrings basically sequences of strict bytestrings?
16:13:45 <nominolo> yep
16:14:29 <desp> so why redo the work?
16:14:34 <nominolo> but the i/o happens when required by the engine
16:14:48 <jao> wow, i was just reading Wadler's 'The essence of functional programming'... he mentions that the 'Glasgow compiler' uses monads virtually everywhere: is that still true of modern GHC?
16:15:10 <nominolo> desp: because you cannot handle resources that way
16:15:47 <sjanssen> newtype Data.ByteString.Base.LazyByteString = Data.ByteString.Base.LPS [Data.ByteString.Base.ByteString] -- Defined in Data.ByteString.Base
16:15:49 <nominolo> desp: since you never know when the consumer is done processing
16:16:36 <dmwit> jao: I'm sure it is.  Monads are a powerful concept.
16:16:43 <gattocarlo> sorear: I compiled the hoogle binary (what I needed) without problems (Deffered Binary is needed for web stuff I think). night
16:16:44 <dmwit> They are good for more than just I/O.
16:16:56 <nominolo> desp: also exceptions may be thrown in pure codo
16:16:59 <jao> dmwit, indeed. and lots of fun.
16:17:04 <nominolo> *code
16:17:37 <SamB> nominolo: I don't get you...
16:17:51 <desp> yes...
16:17:58 * nominolo just switched to dvorak -> slower typing, more errors
16:18:13 <nominolo> SamB: which part
16:18:26 <SamB> what was this about "you cannot handle resources that way"
16:18:42 <sjanssen> SamB: it's dangerous
16:19:22 <sjanssen> you can't expect functions to read to the end of a list -- but reading to the end might be required to free up critical resources
16:19:36 <SamB> sjanssen: oh.
16:19:48 <nominolo> SamB: see http://www.haskell.org/pipermail/haskell-cafe/2007-March/023073.html
16:19:50 <lambdabot> Title: [Haskell-cafe] Takusen and strictness, and perils of getContents, http://tinyurl.com/yp35rl
16:20:40 <sjanssen> on the other hand: lazy IO can be really really handly
16:21:37 <sjanssen> eg. readFile foo >>= writeFile (foo ++ ".gz") . gzip
16:22:32 <lispy> monochrom: congrats
16:22:34 <lispy> er
16:22:43 <lispy> monochrom: nevermind, bad tab completetion
16:22:47 <lispy> nominolo: congrts
16:22:53 <lispy> nominolo: dvorak for the win!
16:22:54 <SamB> ... I don't see why you can't expect functions to read to the end...
16:23:05 <SamB> anyway, what about finalizers?
16:23:16 <sjanssen> yeah, you need a finalizer
16:23:29 <sjanssen> but then you've got to worry about thunks and laziness
16:23:50 <SamB> so how can it be avoided?
16:24:03 <nominolo> lispy: i hope so :)
16:24:03 <sjanssen> by doing strict IO only
16:24:08 <Spark> all math is intuition, except the state of a theorem prover :)
16:24:23 <Spark> yay, wrong channel
16:24:24 <desp> I must be missing something here
16:24:37 <SamB> sjanssen: how does that solve a problem?
16:24:42 <sjanssen> you get exact control of resource use at a cost to convienience
16:25:07 <desp> sjanssen: if the IO in question is "receiving data from the internet", then it's by definition, strict -- no?
16:25:17 <SamB> desp: no.
16:25:20 <desp> i.e. you can't really exect to defer the act of "receiving".
16:25:24 <desp> expect*
16:25:28 <sjanssen> desp: no.  See getContents/unsafeInterleaveIO
16:25:35 <SamB> desp: ever loaded a large picture in your web browser?
16:25:54 <SamB> ... on dialup?
16:26:04 <desp> SamB: I have implemented an image library that does progressive loading, thank you very much
16:26:49 <desp> but there's a difference between waiting for more data to come, and lazily choosing not to receive data for an unspecified amount of time
16:26:59 <desp> at least to my, perhaps naive, eyes
16:27:00 <sjanssen> SamB: well, strict IO pushes resource management to IO, which is more reasonable (real exception handling, guaranteed execution, guaranteed order of execution)
16:27:08 <SamB> desp: you can't defer receipt of data at the Haskell level ;-)
16:27:23 <desp> yes, so I'm wondering what exactly are you talking about here
16:27:26 <SamB> the implementation can avoid read()ing it though
16:27:38 <SamB> (and any subsequent waiting)
16:28:41 <SamB> sjanssen: I suppose that works for some things.
16:29:03 <SamB> but for some things you'd need to turn your program inside-out to do that, wouldn't you?
16:29:19 <nornagon> hm, what should I use for idling? sleep()ish.
16:29:28 <sjanssen> desp: the question is whether 'fetchFromWeb "http://..."': a) reads the whole thing before returning; b) returns a 'Handle' like object that can be read from in the IO monad; c) returns something that is lazily unfolded over tiime
16:29:33 <SamB> @hoogle sleep
16:29:33 <lambdabot> System.Win32.Process.sleep :: DWORD -> IO ()
16:29:36 <SamB> no...
16:29:40 <SamB> @hoogle yield
16:29:40 <lambdabot> Control.Concurrent.yield :: IO ()
16:29:54 <bos> d) takes a fold as parameter
16:29:54 <SamB> nornagon: actually, why are you idling?
16:29:54 <sjanssen> SamB: yeah, sometimes it's less convenient
16:30:11 * sjanssen is skeptical of the fold, but could be convinced
16:30:17 <nornagon> SamB: because i'm writing a statusbar for xmonad, and it doesn't need to update more than once a second.
16:30:30 <desp> sjanssen: there are several traditional approaches, described in Jules' recent email at http://www.nabble.com/forum/ViewPost.jtp?post=10792916&framed=y
16:30:31 <lambdabot> Title: Nabble - Re: Network.HTTP+ByteStrings Interface--Or: How to shepherd handles and ...
16:30:41 <SamB> nornagon: ah.
16:30:49 <SamB> @hoogle wait
16:30:49 <lambdabot> System.Process.waitForProcess :: ProcessHandle -> IO ExitCode
16:30:50 <lambdabot> Control.Concurrent.QSem.waitQSem :: QSem -> IO ()
16:30:50 <lambdabot> Control.Concurrent.QSemN.waitQSemN :: QSemN -> Int -> IO ()
16:30:55 <SamB> @hoogle delay
16:30:55 <lambdabot> Control.Concurrent.threadDelay :: Int -> IO ()
16:30:56 <lambdabot> Network.Socket.NoDelay :: SocketOption
16:30:56 <lambdabot> System.Win32.File.mOVEFILE_DELAY_UNTIL_REBOOT :: MoveFileFlag
16:30:58 <sorear> nornagon: !? And every second, how do you get information?
16:31:05 <sorear> nornagon: use threadDelay
16:31:17 <nornagon> sorear: from the clock?
16:31:22 <sjanssen> desp: yeah, I caught the thread
16:31:25 <sorear> nornagon: ah, ok.
16:31:32 <nornagon> and from acpi.
16:31:35 <sorear> nornagon: there are less legitimate reasons to poll
16:31:49 <sorear> nornagon: but if you're displaying a clock, polling is fine
16:31:53 <SamB> nornagon: how do you make sure it happens *on* the second every second?
16:32:07 <nornagon> SamB: good question :) it's not of vital importance.
16:32:15 <sorear> SamB: duh, by waiting for the next second each time
16:32:32 <sorear> SamB: threadDelay takes usecs, after all
16:32:37 <desp> sjanssen: I was thinking about the c) option, but I'm not sure if I can implement what I have in mind
16:32:51 <SamB> sorear: how do you make sure (a) you start on the second and (b) you don't start to lag?
16:33:14 <sorear> SamB: By waiting for the next second each time!
16:33:38 <desp> sjanssen: would it be acceptable for the evaluation of a chunk in the lazy sequence to block?
16:33:52 <sjanssen> desp: c) is the option that makes some people nervous -- lazy IO is scary for resource usage
16:34:27 <desp> I believe the lazy part should only retrieve what has already been input
16:34:40 <sjanssen> desp: sure, blocking is okay
16:34:47 <sorear> wait_for_ps psec = getps >>= \ps -> threadDelay (min 0 (psec - ps) `div` 1000000)
16:34:58 <sjanssen> desp: you probably want to use non-blocking IO, though
16:35:45 <desp> sjanssen: the actual retrieval would keep happening in a separate thread, updating successive chunks that can be accessed lazily
16:36:08 <Saizan> ?docs Control.Concurrent
16:36:08 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html
16:36:37 <Saizan> Suspends the current thread for a given number of microseconds (GHC only).
16:36:38 <Saizan> There is no guarantee that the thread will be rescheduled promptly when the delay has expired, but the thread will never continue to run earlier than specified.
16:36:59 <bos> desp: have you in mind that chunks go onto a Chan, or an MVar?
16:38:56 <desp> bos: well, actually I think there should be several approaches provided.  letting the user receive chunks explicitly, through a Chan, might be one good approach
16:39:29 <desp> but I was thinking about a simpler interface -- just not sure how to merge it with ByteStrings.
16:39:38 <bos> desp: well, you don't want the receiver thread to continue to receive data if nobody is consuming it.
16:41:00 <bos> is the idea here that you'll fire up a single curl multi instance in a thread, and then have consumers give requests to that thread?
16:41:02 <desp> if the data isn't received, then it'll be eventually lost.  isn't it better to assume that since the user has made the request, the data is going to be eventually consumed?
16:41:13 <bos> no.
16:41:14 <nornagon> threadDelay $ fromIntegral (900000 - (ctPicosec ct `div` 1000000)) -- seems to work pretty well
16:41:24 <desp> after all, if the data is no longer needed, the GC will reclaim it
16:41:44 <desp> and the user could explicitly cancel the transfer
16:41:47 <nornagon> ct being a calendartime ... oh, hm.
16:42:05 <bos> well, i don't understand the plan that you have, so it's hard to get my head around the details.
16:42:35 <nornagon> where's getps coming from? :/
16:43:33 <desp> right now, I'm trying to understand what are the dangers in lazy IO, as seen from the curl perspective
16:44:17 <nornagon> let getps = return . ctPicosec =<< (getClockTime >>= toCalendarTime) -- right?
16:45:17 <nornagon> sorear: boo, hiss, your wait_for_ps doesn't typecheck ;P
16:46:15 <desp> bos: you're saying that the library shouldn't keep on receiving data that is not consumed.  but a lazy interface would be primarily a convenience, so an application that forsees a need to cancel transfers in mid-stream could use a more fine-grained interface, that'd offer chunks of data explicitly
16:46:23 <desp> do you agree?
16:46:26 <sorear> nornagon: it should typecheck just fine!
16:46:28 <bos> yes
16:46:36 <sorear> @type \ psec -> ?getps >>= \ps -> threadDelay (min 0 (psec - ps) `div` 1000000)
16:46:38 <lambdabot> Not in scope: `threadDelay'
16:46:45 <sorear> @type \ psec -> ?getps >>= \ps -> Control.Concurrent.threadDelay (min 0 (psec - ps) `div` 1000000)
16:46:47 <lambdabot> (?getps::IO Int) => Int -> IO ()
16:46:50 <sorear> see!
16:47:18 <nornagon> oh.
16:47:24 <sorear> nornagon: no, that getps is very wrong - it needs to not wrap around
16:47:29 <nornagon> i got something about Int vs Integer.
16:47:32 <nornagon> ah, I see.
16:47:49 <sorear> getps = getClockTime >>= \ (TOD a b) -> return $ a * 10^12 + b
16:48:31 <Modius> Do you remember where you were when you finally "got" fib = 1 : 2 : zipWith (+) fib (tail fib)
16:48:31 <nornagon> riight.
16:48:36 <Modius> ?  For me it was today :)
16:49:02 <nornagon> oh well, what i have already seems to work well enough
16:49:14 <nornagon> i'm not mad keen on picosecond-precise accuracy.
16:49:38 <nornagon> btw, the way i'm doing an infinite loop seems a little hacky; i just call main at the end of main
16:49:54 <nornagon> any adverse effects, or does it work how i'd expect?
16:50:06 <Saizan> ?src forever
16:50:06 <lambdabot> Source not found. Just what do you think you're doing Dave?
16:50:38 <Saizan> forever m = m >> forever m <-- it works
16:50:53 <nornagon> mm, that'd probably be more obvious.
16:50:55 <sorear> @type sequence_ . repeat -- in 6.7 this is Control.Monad.forever
16:50:57 <lambdabot> forall (m :: * -> *) a. (Monad m) => m a -> m ()
16:51:38 <nornagon> :t sequence_
16:51:40 <lambdabot> forall (m :: * -> *) a. (Monad m) => [m a] -> m ()
16:55:21 <nornagon> hmph, there must be a better way to get acpi info than parsing `acpi`
16:55:41 <dmwit> ls /proc/acpi
16:56:40 <nornagon> mm
16:58:36 <Saizan> uhm, any use of forever outside the IO monad?
16:59:15 <beelsebob> doom
16:59:16 <sorear> sure
16:59:23 <SamB> Saizan: why not?
16:59:57 <Saizan> lack of imagination?:)
17:00:14 <nornagon> dmwit: mm, easier to parse... but it's still parsing >.>
17:00:22 <dmwit> Heh, yeah.
17:00:30 <nornagon> and it means i need to do my own calculations
17:02:44 <kpreid> > runWriter (forever $ tell "abc")
17:02:45 <lambdabot>   Not in scope: `forever'
17:02:50 <kpreid> @index forever
17:02:51 <lambdabot> bzzt
17:03:08 <kpreid> > let forever x = x >> forever x in runWriter (forever $ tell "abc")
17:03:14 <lambdabot> Terminated
17:03:30 <kpreid> hmm
17:03:32 <kpreid> > let forever x = x >> forever x in runWriter (do forever $ tell "abc"; return ())
17:03:33 <lambdabot>  ((),"abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcab...
17:03:38 <kpreid> oh, I know
17:03:48 <kpreid> > let forever x = x >> forever x in execWriter (forever $ tell "abc")
17:03:50 <lambdabot>  "abcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabcabc...
17:04:06 <kpreid> anyway, there's a non-IO use of forever :)
17:04:33 <Saizan> > execWriter (sequence_ . repeat $ tell "asd")
17:04:35 <lambdabot>  "asdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasdasd...
17:04:37 <kpreid> of course, you could do that just as well with cycle, but imagine some generic MonadWriter code
17:04:39 <Saizan> k
17:05:19 <Saizan> > execState (sequence_ . repeat $  modify (++"asd")) []
17:05:25 <lambdabot> Terminated
17:05:54 <dmwit> You want something like coExecState (i.e. you want the state back, not the value).
17:06:00 <dmwit> :t execState
17:06:01 <lambdabot> forall s a. State s a -> s -> s
17:06:10 <dmwit> ...
17:06:11 * dmwit shuts up
17:06:41 <kpreid> dmwit: runFoo = value and extras; evalFoo = value only; execFoo = extras
17:07:03 * SamB thinks xterm is having trouble with the meaning of the term "combining"
17:07:05 <kpreid> @type (runWriter, evalWriter execWriter)
17:07:07 <lambdabot> Not in scope: `evalWriter'
17:07:12 <kpreid> @type (runWriter, evalWriter, execWriter)
17:07:13 <kpreid> @type (runWriter, execWriter)
17:07:14 <lambdabot> Not in scope: `evalWriter'
17:07:16 <lambdabot> forall w a w1 a1. (Writer w a -> (a, w), Writer w1 a1 -> w1)
17:07:24 <kpreid> @type (runState, evalState, execState)
17:07:26 <lambdabot> forall s a s1 a1 s2 a2. (State s a -> s -> (a, s), State s1 a1 -> s1 -> a1, State s2 a2 -> s2 -> s2)
17:07:39 <kpreid> hm, that doesn't work so well for names
17:07:53 <ddarius> Saizan: There are also monad transformed uses of IO.
17:07:56 * SamB wonders how this works. x Ì…x Ì…x
17:08:06 <SamB> hmm, x-chat doesn't fare much better.
17:08:20 <dmwit> Looks fine in my x-chat.
17:08:27 <dmwit> They're supposed to be overbars, right?
17:08:28 <dibblego> mine too
17:08:48 <SamB> I'm pretty sure they're supposed to go over top of some of those xes
17:08:58 <SamB> probably the last two xes
17:09:37 <SamB> maybe not...
17:10:10 <desp> a
17:10:17 <nornagon> SamB: looks fine in my irssi
17:10:27 <shachaf> Hmm, which layer stops me from seeing those? I doubt it's urxvt... Is it irssi or screen or ssh?
17:10:33 * shachaf suspects screen.
17:10:33 <desp> they look fine alone, but they do not combine
17:10:39 <nornagon> Â°âŒ£Â°
17:10:53 <Baughn> shachaf: ssh shouldn't do any interpretation at all
17:11:20 <shachaf> Baughn: Yes, I know... I just thought I'd mention it.
17:11:49 <shachaf> Baughn: And nornagon says irssi works.
17:11:52 <desp> SamB: they do combine in another app's text field. it's just my terminal that doesn't support these.
17:12:00 <Baughn> shachaf: For what it's worth, it's not the terminal. I've got the same setup with three different ones - all have the same problem.
17:12:39 <sorear> irssi/urxvt doesn't combine em
17:12:56 <desp> shachaf: you need to use in your shell, terminal, screen, screen shell and irssi
17:13:07 <desp> use UTF-8*
17:13:08 <EvilTerran> x-chat on 'doze butchers it, even with unicode fonts
17:13:24 <MyCatVerbs> sorear: irssi+urxvt+screen work for me. Unless I forget to make my locale a utf8-using one.
17:13:33 <desp> shachaf: if you're on Mac OS X, I wrote a short guide how to set it up properly
17:13:48 <shachaf> desp: No, not OSX.
17:13:54 * SamB wonders breifly if it works on plan9
17:14:02 <sorear> MyCatVerbs: Hmm, strange, I have urxvt and locale settings.
17:14:16 <MyCatVerbs> sorear: it doesn't work *nicely*, but it does work. :)
17:14:46 <SamB> you'd think we'd have brought computing at least to the level of the PDP-1 by now!
17:14:50 * beelsebob suggests just using Colloquy
17:15:02 <beelsebob> decent IRC client, with a nice UI, and using IRSSI as a back end
17:15:04 <MyCatVerbs> sorear: kinda, anyway. I do wish people would just use f'ckin' GNU readline instead of reimplementing their own though, so there'd only be a need for *one* line-editor-with-utf8 to be written.
17:15:05 <desp> beelsebob: I have enough RAM-gobbling apps, thanks
17:15:10 <desp> ;)
17:15:45 <beelsebob> desp: Activity monitor reports Colloquy using 16MB of ram just now
17:15:50 <beelsebob> hardly a ram guzler
17:16:04 <beelsebob> using a third of what finder is
17:16:09 <desp> beelsebob: I do use it from time to time, when my shell is down
17:16:15 <EvilTerran> MyCatVerbs, wouldn't that require GPLing your program?
17:16:45 <jao> Colloquy is GPL
17:16:50 <MyCatVerbs> EvilTerran: yes. That's not exactly a problem for irssi, though.
17:17:05 <EvilTerran> well, yes. but some people prefer not to.
17:17:27 <MyCatVerbs> EvilTerran: screw them, then.
17:17:40 * MyCatVerbs shrugs.
17:17:50 <SamB> it would also be nice if the terminal and readline would agree on how much space things are going to take
17:18:01 <emu> that includes BSD programs
17:18:05 <emu> not just commercial
17:18:12 <EvilTerran> MyCatVerbs, myself, for one. i much prefer MIT-esque lisences
17:18:23 <emu> why do you think we desperately want to replace / unlink from libgmp?
17:18:37 <SamB> BSD programs would still be allowed to use the BSD for their source files...
17:18:50 <MyCatVerbs> emu: I do happen to think the BSD license rather silly, myself. :P
17:18:51 <EvilTerran> i barely have the patience to read and digest the GPL, i don't want to subject my users to it as well
17:18:55 <MyCatVerbs> EvilTerran: oh, well.
17:19:16 <emu> why? it's pretty much the easiest way to say "please use this for whatever you want and don't bother me with liability"
17:19:30 <Baughn> EvilTerran: The non-lawyeriffic version is pretty simple. For my part, I don't like the freeloaders MIT invites.
17:19:36 <EvilTerran> and applying a lisence that i don't fully understand to one of my products is ridiculous at best
17:19:51 <SamB> EvilTerran: perhaps a simple permissive license is for you
17:19:52 <EvilTerran> "licence", sorry.
17:19:59 <EvilTerran> samB, hence MIT
17:20:15 <SamB> something along the lines of "use this however, just don't blame me if it eats your dog"
17:20:18 <MyCatVerbs> emu: because freeloaders can swipe it and use it without ever giving back anything more than minimal credit.
17:20:25 <emu> MyCatVerbs: but that's exactly what i want!
17:20:33 <EvilTerran> MyCatVerbs, am i bothered?
17:20:46 <MyCatVerbs> emu, EvilTerran: fair enough.
17:20:50 <SamB> MyCatVerbs: I'd worry about that if I had a project going
17:21:12 <EvilTerran> i'd rather make myself useful in a few dozen places where they freeload then never have my stuff used anywhere because of an overzealous licence
17:21:16 <SamB> and I thought that I had something someone was likely to try to hijack...
17:21:39 <SamB> i.e., steal all the users
17:21:52 <emu> also, nothing stops someone from using GPL code and not giving back.  after all, the rule is against distribution without source ;)
17:21:58 <Baughn> EvilTerran: That doesn't seem to bother the companies who use proprietary licenses
17:22:02 <MyCatVerbs> EvilTerran: "few dozen places where they freeload" <-- like having the entire TCP/IP stack lifted by a Redmond-based company?
17:22:03 <SamB> (and thus all the potential developers besides me)
17:22:14 <SamB> MyCatVerbs: yeah, like that
17:22:19 <EvilTerran> MyCatVerbs, yes. exactly.
17:22:23 <emu> MyCatVerbs: i wish they had; maybe windows would suck less
17:22:25 <EvilTerran> i'd rather my work be used.
17:22:29 <SamB> it's probably better than having them write their own...
17:22:42 <SamB> emu: I'm under the impression that they've gone back and stolen it better
17:22:44 <MyCatVerbs> emu: true. But it does prevent the bastards from selling your work without giving you access to what they'd built on it.
17:22:58 <SamB> MyCatVerbs: and we want windows why?
17:23:40 <MyCatVerbs> SamB: my point exactly. They'd never give it up for the sake of a TCP stack, so they'd just attempt to write their own instead, crash, burn and leave the world up for grabs for the Unix mafia. ;)
17:23:51 <SamB> anyway the TCP stack was developed under that license for a reason...
17:23:57 <EvilTerran> but then, i'm aiming for the heights of acedemia. don't trust my good sense. =P
17:24:00 <emu> dubious.  anyway the NT team had good people on it.
17:24:37 <MyCatVerbs> emu: a few, yes. And apparently they had to battle daily against chunks of the rest of the organisation, so...
17:24:53 <SamB> emu: yes but implementing a TCP stack is hardly going to be free of pain...
17:25:04 <EvilTerran> (for the same reason; i'd rather make a lasting, productive mark on the world than be horribly rich and then disappear without a trace when i die of excess)
17:25:05 <emu> windows is filled with pain
17:25:10 <emu> window pains
17:25:20 <EvilTerran> **rimshot**
17:25:36 <SamB> anyway, the TCP stack was developed there with the explicit goal of it being stealable, was it not?
17:25:52 * EvilTerran goes to bed
17:25:54 <SamB> it's good for people to steal TCP stacks, it increases the usefulness of TCP ;-)
17:26:06 <weitzman_> The windows kernel parts are more free of pain than the userland stuff
17:26:19 <SamB> weitzman: ... just ... wow.
17:26:36 <MyCatVerbs> SamB: there is that, I guess. *twitches at the tought of a NetBIOS-dominated world*
17:26:56 <emu> where's our ChaosNET dammit
17:27:19 <SamB> it was, like, the prototype, wasn't it?
17:27:37 <emu> no just an alternative afaik
17:27:50 <SamB> I meant, the BSD stack...
17:28:29 <SamB> anyway, didn't xiph.org do the same with Ogg Vorbis?
17:29:29 <SamB> though I think the fixed-point implementation might be copylefted...
17:30:45 <Baughn> Summing things up a bit: MIT licensing is good if you want open protocols, GPL is good if you want free software, and different people want different things.
17:33:22 <SamB> some people like a mixture of things
17:35:22 <Excedrin> is there a Network.HTTPS ?
17:35:39 <sorear> no.
17:35:42 <SamB> Excedrin: wouldn't it make more sense to juse use Network.HTTP?
17:35:49 <sorear> there is a libcurl binding
17:35:55 <Excedrin> SamB: does Network.HTTP do HTTPS?
17:36:22 <SamB> Excedrin: well what does it want with all that crypto code if it doesn't?
17:36:41 <Baughn> How about a Network.TLS?
17:37:00 <Excedrin> what crypto code?
17:37:13 <bos> the curl library does TLS, so desp's curl interface will be handy for some of that.
17:37:29 <bos> Network.HTTP doesn't do TLS.
17:39:24 <SamB> huh. the Network.HTTP I was using a while back had it, I'm pretty sure!
17:39:37 <jim__> Is there a way to store unstructured lists of tags and strings and pass those into functions?  For instance, in lisp I can represent html in list form and pass that into functions.
17:40:09 <SamB> @seen bringert
17:40:09 <lambdabot> I saw bringert leaving #ghc and #haskell 55m 41s ago, and .
17:40:22 <jim__> The problem with Haskell is that lists need the same type, and tuples of different sizes cant be passed into the same function.
17:40:39 <SamB> jim__: why don't you use a real datatype?
17:40:51 <Excedrin> aside from TLS, how do Network.HTTP and the curl binding compare?
17:41:02 <Baughn> jim__: Look into the data statement
17:41:02 <jim__> samB what is a real datatype?
17:41:12 <Baughn> jim__: Have you read any haskell tutorials
17:41:13 <Baughn> ?
17:41:34 <jim__> Oh, you mean data Html = Tag string....
17:42:15 <Baughn> jim__: That sort of thing. Also, there is already a html library in the standard library. (Or GHC's, at least)
17:43:08 <jim__> That has some problems though.  First it is difficult to type out (ie for a list of ints or string you need to label everything ie= list = [AString "qq", AnInt 2....]
17:43:22 <jim__> second it is not extendable.
17:43:40 <Baughn> jim__: If you want extendable, look into typeclasses
17:43:50 <jim__> you can not have separate tags built on the spot.
17:44:06 <Excedrin> oh, is this the curl binding: http://desp.night.pl/curl/ ?
17:44:10 <lambdabot> Title: Index of /curl
17:44:22 <jim__> one sec, I will go read about typeclasses
17:44:58 <Baughn> jim__: You very rarely /need/ heterogenous lists without any structure in them. Usually there's structure, and when there is, you can use that for the typing.
17:45:06 <desp> Excedrin: the CURL binding is currently being developed :)
17:45:39 <desp> it should be ready within a few weeks
17:47:53 <Excedrin> desp: cool!
17:48:22 <petekaz> where are the implicit parens in this expression? return (:) `ap` c `ap` sequence cs
17:48:52 <edwardk> jim: what is it you are trying to do? generate xml with lightweight syntactic overhead from haskell?
17:49:06 <jim__> Baughn: I am new to Haskell, so perhaps my thinking hasn't come around correctly yet, but I think I have a case where I want uninstructured lists.
17:50:47 <jim__> edwardk: sort of like that.  It is a bit more complicated but perhaps it is easier for me to just say that I want to store xml in haskell and work with that.  The twist is that I need to be able to define new types of stuff on the fly, so data Blah = A | B.... probably won't work
17:50:52 <Baughn> jim__: For html?
17:51:08 <Baughn> jim__: As I said, GHC already has a html library. Perhaps you should look at how that solves the issue.
17:51:38 <jim__> does it use typeclasses?
17:51:44 <bd_> jim__: New 'types'?
17:52:16 <bd_> Haskell's typechecker runs at compile time - so you can't directly implement new types, but you could greate a generic datastructure
17:52:17 <Baughn> jim__: Yes
17:52:20 <edwardk> jim: sure, but you CAN go through and define that sort of heavier data definition, even tagging the xml nodes with strings, like data Xml = Element String [Xml] | Attribute String String ..., then define nice little worker functions like p = Element "p"
17:55:02 <Manyfold> good evening
17:55:05 <jim__> bd: Yeah, kind of like the user would want to define an html table or something and assign it as a new type that can be used.  So for instance suppose I write my html like (false code)- [html [head [title "blah"]] [body [myTable]]], the myTable is defined elsewhere.  But the data keyword won't have myTable.
17:56:07 <bd_> jim__: You'd need to define a generic type which can hold whatever you need in XML, and create manipulation functions over it, I think.
17:56:10 <Manyfold> say i want to define an n-ary tree recursively but i don't know n beforehand . how to do this in haskell?
17:56:24 <bd_> Manyfold: You could use Data.Arrays for the leaf pointers
17:56:27 <emu> Manyfold: lists
17:56:56 <int-e> Manyfold: would  data Tree a = Node a [Tree a]  work for you?
17:57:57 <Manyfold> int-e: well the problem is the tree should be subdivided in leafs and branches
17:58:17 <jim__> bd: would that allow me to type something like the false code in above and have the myTable expand out (sorry for the basic questions, I am new to Haskell).
17:58:22 <int-e> Manyfold: data Tree a = Branch [Tree a] | Leaf a
17:58:30 <edwardk> jim: in the above data Xml = Element String [Xml] | Attribute String String | Text String thing you'd just say something like myTable = Element "myTable" [] if that is the literal tag you want, or myTable = table [tr [td [text "Hello World]], tr [td [text "World"]]] if you meant to refer to a particular table with suitable definitions for html style table, tr, td, and pcdata as text
17:59:03 <edwardk> jim: myTable in your example will be whatever 'myTable' variable is in scope.
17:59:14 <bd_> jim__: myTable can be an ordinary value, not a type
17:59:21 <int80_h> I'm trying to be able to get ghci to listen on a port that I can telnet to. I've made some progress, but have some problems. Is this the right channel for this problem?
17:59:48 <edwardk> jim: you can even make infinitely recursive documents. mytable = table [tr [td [mytable]]]
17:59:53 <bd_> jim__: eg, I don't know, myTable = Xml "table" [("bgColor", "blue")] [ Xml "tr" [] [Xml "td" [] [XmlString "foo"]]]
18:00:31 <bd_> you could ofc make helpers around this : tr = Xml "tr" []; td = Xml "td"; table = Xml "table"; myTable = table [] [tr $ td $ XmlString "foo"]
18:00:33 <EvilTerran> int80_h, i guess so. if your code might be wrong.
18:00:44 <int80_h> no it's not coding, it's an OS thing
18:01:08 <int80_h> I was hoping someone else was doing this, or could tell me my way was entirely wrong
18:01:12 <jim__> how can you put the table and td etc elements directly in, don't you need Element type specified?
18:01:26 <jim__> Oh, sorry I see what you said
18:01:28 <int80_h> I just put ghci as an entry into /etc/services and /etc/inetd.conf
18:01:33 <jim__> I hadn't read far enough down.
18:01:43 <int80_h> and I can telnet to the port I specified but I get no output
18:01:44 <edwardk> the idea there is to just use a string, rather than a separate constructor for each tag.
18:02:22 <EvilTerran> int80_h, buffering?
18:02:54 <int80_h> hmmm, how do I account for that then?
18:02:58 <jim__> bd: thanks for the suggestions.  It may do what I need, I still have to think about it.  Haskell is really a new way of doing things for me.
18:03:08 <int80_h> here's my inetd.conf entry
18:03:13 <jim__> bd: But that may have sent me in the correct direction.
18:03:16 <edwardk> jim__: lisper?
18:03:45 <int80_h> ghci            stream tcp      wait    root    /usr/bin/ghci
18:04:30 <jim__> edwardk: c -> xslt -> short period with lisp -> haskell
18:04:44 <jim__> edwardk: Actually I think in xslt.
18:04:44 <edwardk> ah
18:04:49 <edwardk> my condolences ;)
18:05:10 <edwardk> its turing complete but only barely =)
18:05:47 <jim__> edwardk: I prefer Haskell to xslt except I can't quite get my head around the unstructured data thing.  I can pretty much put in any tag I want in xslt, or lisp.
18:06:07 <desp> @hoogle ByteString.Lazy.fromChunks
18:06:07 <lambdabot> No matches, try a more general search
18:06:13 <desp> @hoogle fromChunks
18:06:14 <lambdabot> No matches found
18:06:29 <Baughn> @bot
18:06:30 <lambdabot> :)
18:06:41 <desp> anyhow -- that function is described as O(c), which I understand is the number of items in the list, right?
18:06:45 <jim__> edwardk: purely function though!
18:06:49 <edwardk> sure, which is both a blessing and a curse, haskell gives you types, so you can catch yourself when you are about to do something silly because of a misplaced parenthesis, but sometimes requires you to type more. otoh, with enough experience with typeclasses, it can also let you type less.
18:06:53 <desp> http://www.cse.unsw.edu.au/~dons/fps/Data-ByteString-Lazy.html#v%3AfromChunks
18:06:54 <lambdabot> http://tinyurl.com/2ysruq
18:07:15 <Baughn> Is someone I've got on ignore talking to lambdabot? -_-
18:07:45 <sorear> Baughn: I think you just insulted desp
18:07:51 <jim__> edwardk: going from xslt/lisp to Haskell reminds me of going from c to Java, pretty much the same idea.]
18:07:59 <Baughn> sorear: Ah, there we go.
18:08:13 <Baughn> desp: Sorry about that. I really need to figure out how to make these timed.
18:08:30 <desp> Baughn: I'm sorry that you found it necessary to ignore me
18:08:53 <sorear> Baughn: why a timed ignore?
18:09:05 <lambdabot> No matches, try a more general search
18:09:08 <Baughn> sorear: Otherwise I keep forgetting about them, and then this happens
18:09:25 <lambdabot> No matches found
18:09:36 <sorear> Baughn: Well, why ignore at all I mean, if you aren't serious about keeping it forever :)
18:09:47 <edwardk> of course, if you really just want to do a lot of xml style parsing and munging, there are always things like the haskell server pages project. then you can actually say things like mypara = <p color=getUserColor>Hello World!</p>
18:09:53 <edwardk> jim: http://www.cs.chalmers.se/~d00nibro/hsp/thesis.pdf
18:09:53 <lambdabot> :)
18:10:19 <edwardk> that said i'm not entirely sure you want to dive into a domain specific language extension rather than learn how to use 'the haskell way' right off.
18:10:30 <Baughn> sorear, desp: I haven't the foggiest idea. Looking at logs, desp didn't say anything that should make me ignore him.
18:10:36 <Baughn> Probably tab-completion bit me.
18:10:55 <desp> well, that's a relief
18:10:58 <desp> :)
18:11:14 <Pseudonym> desp: You can get a quick insult in now if you want.
18:11:22 <Pseudonym> He's listening.
18:11:29 <jim__> edwardk: I want to learn the Haskell way first, particulary since my end goal is more complicated than the examples I gave here (html was the simple analog).
18:12:00 <desp> Thou paunchy folly-fallen horn-beast!
18:12:13 <edwardk> jim: sure, i just thought i should mention it, given that it is actually kind of a nice syntax extension for this problem.
18:12:29 <jim__> I should probably look at it though to see what they have done.
18:13:58 <edwardk> i found it nice enough that i adopted part of it in my toy language project
18:14:58 <int-e> @src ($)
18:14:58 <lambdabot> f $ x = f x
18:15:13 <jim__> Thanks everyone, nice to see that the Haskell community is a helpful group!  Not all are.
18:15:14 <int-e> Manyfold: ;)
18:15:17 <jim__> I have to head out.
18:15:25 <edwardk> have fun, and good luck
18:15:29 <jim__> thanks.
18:36:57 <shachaf> aaa/win
18:37:03 <shachaf> Oops.
18:42:38 <Manyfold> > let n = 1 : 2 : [ a +1 | a <- tail  n, mod a 2 ==0] in n
18:42:40 <lambdabot>  Exception: stack overflow
18:42:50 <Manyfold> what went wrong here?
18:44:15 <Cale> Let's compute it
18:44:27 <Cale> The first and second elements are obviously defined
18:44:37 <centrinia> You  don't have a tail n.
18:44:46 <Cale> tail n exists
18:44:48 <Cale> once :)
18:44:53 <centrinia>  :p
18:44:57 <Baughn> > let n = 1 : 2 : [ a +1 | a <- tail  n, mod a 2 ==0] in n !! 2
18:44:58 <lambdabot>  3
18:45:02 <Baughn> > let n = 1 : 2 : [ a +1 | a <- tail  n, mod a 2 ==0] in n !! 3
18:45:03 <lambdabot>  Exception: stack overflow
18:45:07 <Cale> right :)
18:46:08 <Baughn> I would have expected <<Loop>>, though
18:46:17 <int-e> > let n = 1 : 2 : [ a +2 | a <- tail  n, mod a 2 ==0]
18:46:17 <lambdabot>  Parse error
18:46:21 <int-e> > let n = 1 : 2 : [ a +2 | a <- tail  n, mod a 2 ==0] in n
18:46:22 <lambdabot>  [1,2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52...
18:47:56 <Manyfold> so what happens if the condition evaluates to false?
18:48:10 <int-e> hmm, a first step: let n = 1 : 2 : n'; n' = [ a +2 | a <- tail (1 : 2 : n'), mod a 2 ==0] in 1 : 2 : n'
18:48:32 <Baughn> Manyfold: Then it checks the next element of a, and so on until it becomes true
18:49:05 <Baughn> Manyfold: That's your problem, since said next element is what's being computed at the moment. Though I really expected a loop exception.
18:49:09 <Manyfold> Baughn: i don't understand why this stack overflow occurs?
18:49:36 <Olathe> Manyfold: The first element of the tail doesn't fit, so it tries the next one, which it hasn't calculated yet. So, it calculates it.
18:49:37 <int-e> sorry. I meant a+1 not a+2 now. so  n' = [ a+1 | a <- tail  (1 : 2 : n'), mod a 2 ==0] reduces to n' = [a+1 | a <- 2:n', mod a 2 == 0], which reduces to n' = 3 : [a+1 | a <- n', mod a 2 == 0]
18:49:56 <Olathe> Manyfold: When it calculates it, the first element of the tail doesn't fit, so it tries the next one, which it hasn't calculated yet. So, it calculates it.
18:50:00 <Olathe> Manyfold: And so on.
18:50:23 <int-e> n' = 3 : n''; n'' = [a+1 | a <- 3:n'', mod a 2 == 0]. n'' = [a+1 | a <- n'', mod a 2 == 0]. And now the trouble begins.
18:51:03 <ed1t> KABOOM !!
18:51:10 <Olathe> Kaboom is it !
18:51:20 <ed1t> Olathe, how are you man? ltns
18:51:34 <Manyfold> @src (filter)
18:51:34 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
18:51:36 <int-e> n'' asks for the first element of itself which can't be evaluated yet. this failure manifests itself in a stack overflow in this case.
18:52:21 <int-e> the theorists will say that this n'' = bottom, which is the smallest fixed point of \x -> [a+1 | a <- x, mod a 2 == 0]. Don't know if that is helpful.
18:52:29 <Baughn> Manyfold: (+), but not (filter). @src filter
18:52:51 <Olathe> I'm doing pretty well.
18:53:03 <Olathe> There's some moth attacking my screen, though.
18:53:28 <Olathe> ed1t: How are you doing ?
18:54:54 <ed1t> Olathe, im good
18:56:34 <kfish> Olathe, bugs are trying to physically get into your haskell code?
18:57:02 <Baughn> kfish: I always wondered where they came from. Now I know.
18:57:17 <Olathe> Yes.
18:58:44 <kfish> ghc -fallow-invertebrate-instances
18:59:04 <Olathe> Heheh
18:59:35 <bd_> ghc -fchannel-oleg
18:59:42 <desp> :)
19:00:23 <kfish> with enough type-hackery, we prove that bugs turn into features :-)
19:00:42 <Baughn> You don't need type-hackery for that, you just need good PR
19:00:42 <monochrom> ghc -fno-metamorphism-restriction
19:00:51 <int80_h> no wonder microsoft is so sweet on haskell these days
19:01:16 <monochrom> bugs turn into butterflies!
19:01:38 <kfish> monochrom, heh
19:01:51 <Baughn> They're still bugs, then
19:22:23 <Baughn> > (length [1..]) > 50
19:22:29 <lambdabot> Terminated
19:24:29 <Cale> That'd work with a proper Nat
19:24:43 <Baughn> Nat?
19:24:55 <Cale> data Nat = Zero | Succ Nat
19:25:01 <Baughn> Ah.
19:25:15 <Baughn> I don't see why, though
19:25:25 <ddarius> Baughn: That definition is lazy.
19:25:39 <Baughn> Oh, for 50.. yes, I see.
19:26:07 <Baughn> I'm not sure it's worth switching to unary, though
19:42:55 <ddarius> You can use lazier version of positional number systems than Integer.
19:44:26 <Baughn> I was actually just checking to see if it'd specialize length to stop at 50
19:45:00 <kpreid> It's generally considered a bad thing to optimize away bottoms.
19:45:03 <kpreid> Right?
19:45:19 <Pseudonym> It sounds filthy, whatever it is.
19:45:23 <Korollary> Integer is more like a sum type. It would have to calculate it all.
19:45:52 <Korollary> Err, individual integers are more like individual constructors is what I meant
19:46:43 <ddarius> kpreid: It's generally considered a bad thing to change semantics.
19:47:05 <ddarius> But if you are, avoiding non-termination isn't the best way to change them.
20:07:39 <chessguy> hmm, quiet night in #haskell
20:08:17 <desp> *bump*
20:08:50 <Korollary> Everybody is working on the libraries whose lack everybody else complains about.
20:08:56 <desp> exactly
20:09:15 <chessguy> well then don't let me interrupt
20:22:26 <falconair> can we expect any updates on "real world haskell" soon?
20:23:35 <desp> does writeChan ever block?
20:23:54 <desp> I assume readChan blocks when the channel is empty
20:24:20 <sorear> no, and yes.
20:24:25 <desp> thanks
22:00:42 <dons> here's a scary thing:
22:00:43 <dons>   http://gmane.org/plot-rate.php?group=gmane.comp.lang.haskell.xmonad
22:00:45 <lambdabot> http://tinyurl.com/2eudmy
22:03:02 * SamB wishes GHC supported RTTI
22:05:11 <sorear> SamB: it does
22:05:56 <sorear> SamB: ghc uses non-overlapping tag values, so you can find the type of any value easily
22:06:10 <sorear> well, the leftmost type constructor anyway.
22:10:52 <SamB> actually I want to know the type involved in Prelude.read: no parse...
22:11:56 <sorear> +RTS -xc yet?
22:12:08 <sorear> how about ghci -fbreak-on-exception ?
22:12:29 <SamB> I haven't built for profiling...
22:14:05 <SamB> ghc-6.6: unrecognised flags: -fbreak-on-exception
22:14:12 <dons> -fvia-C ?
22:15:29 <sorear> dons: ghc*i*
22:15:43 <sorear> SamB: well, 6.6's don't have it :)
22:16:27 <SamB> sorear: yeah. ghci gives the error that way for some reason!
22:20:12 <SamB> oh. I figured it out... I need to finally implement radix switching in my lexer...
22:21:03 <adu> i need to learn haskell, any suggestions for something to do after a hello-world program?
22:21:43 <SamB> a lambda calculus interpreter
22:22:18 <Baughn> adu: If you don't have any ideas yourself, doing the exercises in one of the teaching books would help
22:22:59 <adu> ok
22:24:57 <adu> hi dfranke
22:25:13 <dfranke> hi
22:26:06 <Baughn> adu: For a quickie, try rimplementing the unix "head" command. It's a one-liner, if you neglect argument parsing and the more unusual modes.
22:26:57 <adu> ok
22:31:31 <dons> ?where simple unix tools
22:31:32 <lambdabot> I know nothing about simple.
22:31:36 <dons> ?google simple unix tools
22:31:38 <lambdabot> http://haskell.org/haskellwiki/Simple_unix_tools
22:31:39 <lambdabot> Title: Simple unix tools - HaskellWiki
22:31:42 <dons> ^^ cheat page ;)
22:31:46 <dfranke> main = sequence_ [ getLine >>= putStrLn | _ <- [1..10] ]
22:31:59 <SamB> dons: did you notice that that's being indexed again at last?
22:32:07 <dons> main = interact (unlines . take 10 . lines)
22:32:15 <dons> SamB: ah yes. good.
22:32:29 <dfranke> ?t take
22:32:29 <lambdabot> Maybe you meant: tell temp time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
22:32:33 <dfranke> :t take
22:32:36 <SamB> I got Igloo to add a question mark to robots.txt ;-)
22:32:39 <dfranke> > :t take
22:32:43 <dibblego> ?type take
22:33:39 * dfranke pokes lambdabot
22:33:45 <lambdabot> thread killed
22:33:46 <lambdabot>  Parse error
22:33:48 <lambdabot> forall a. Int -> [a] -> [a]
22:34:07 <dfranke> > take 10 [1..15]
22:34:08 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
22:34:13 <dfranke> ah, k.
22:34:21 * SamB wonders why his copy of spacewar.mac seems to lack a title line
22:38:04 <adu> :(
22:38:22 <peter_12> is there a "K&R" equivalent book in the Haskell world?
22:38:29 <adu> my head sucks
22:38:53 <adu> myprint x = putStr (hGetLine stdin) \n main io = map myprint [1..10]
22:39:03 <dons> peter_12: yeah, 'The Haskell 98 report"
22:39:26 <peter_12> dons: others would agree?
22:39:44 <adu> i obviously don't understand haskell IO
22:39:58 <dons> i'd imagine so, its the spec of haskell, the way K&R is the C spec.
22:40:02 <SamB_XP> it's only like the second half of K&R
22:40:07 <peter_12> ahh
22:40:14 <peter_12> I'm looking for the first half :)
22:40:16 <SamB_XP> (that is, the appendices)
22:40:20 <dons> to understand IO, best to start with one of the tutorials. perhaps 'Yet Another Haskell Tutorial'
22:40:30 <dons> or maybe one of the haskell textbooks
22:40:34 <adu> k
22:40:37 <dons> check the 'Books' link on haskell.org
22:40:45 <peter_12> I'm looking now :)
22:40:59 <SamB_XP> dons: so where do we keep the first half of our K&R?
22:41:14 <dons> the bit on how to program basic C?
22:41:25 <dons> that'd be say, 'The Craft of functional programming'
22:41:36 <dons> or 'Programming in Haskell'
22:41:37 <SamB_XP> Chapter 1: A Tutorial Introduction
22:41:48 <SamB_XP> Chapter 2: Types, Operators, Expressions
22:41:55 <SamB_XP> Chapter 3: Control Flow
22:42:08 <dons> whereas 'Real World Haskell' starts at roughly K&R's chapter on pretty priting function pointer expressions ;)
22:42:16 <SamB_XP> chapter 4: Functions and Program Structure
22:42:40 <SamB_XP> Chapter 5: Pointers and Arrays ...
22:43:06 <peter_12> God I hope there isn't a Chapter 5 in Haskell ;)
22:43:32 <SamB_XP> peter_12: that would be more like Chapter 11
22:43:51 <SamB_XP> yes I picked that number for mnemonic value ;-)
22:44:26 <SamB_XP> anyway, this has examples of all kinds of useful tasks...
22:44:57 <emu> hey dons
22:45:40 <SamB_XP> like, in chapter 6, they have a binary search tree
22:46:06 <SamB_XP> Chapter 6 being the chapter on Structures
22:46:36 <peter_12> K&R is still the best language book I've read
22:48:31 <SamB_XP> we have yet to touch the first half, I think
22:49:35 <SamB_XP> "the best of Cabal" might be an interesting way to come somewhat close...
22:50:00 <dons> its a good book. one of my favourites, K&R.
22:50:15 <dons> i notice it is #2 on the book stack above my desk atm.
22:50:29 <SamB_XP> what is #1?
22:50:38 <dons> undereath 'Practical aspects of declarative languages', and above 'The Craft of FP'
22:50:56 <dons> also on top of 'modern compiler impl. in ML'
22:51:05 <peter_12> #1 on mine is Gang of Four's Design Patterns
22:51:11 <SamB_XP> yuck
22:51:16 <dons> hehe.
22:51:26 <dons> you won't need that now though.
22:51:29 <SamB_XP> I don't have a stack of books above my desk, but I do have bookshelf next to it.
22:51:33 <SamB_XP> plus heaps of garbage
22:51:35 <peter_12> I live in object land
22:52:02 <dons> peter_12: welcome to the land of verbs!
22:52:08 <dons> > map (+2) [1..10]
22:52:10 <lambdabot>  [3,4,5,6,7,8,9,10,11,12]
22:52:11 <cdsmith> I actually like GoF.  Just that most people misuse it by copying its designs into their code.
22:52:19 <dons> no objects here :) but lots of fun new stuff
22:52:59 <peter_12> I get to use functional programming stuff in JavaScript all the time and think maybe learning some Haskell will help my JavaScript programming
22:53:27 <dons> should do. you'll get a sense for really what's possible with functional techniques.
22:53:53 <dons> people often say, `haskell made my $foo language programming better', since it delimits concepts more clearly that a lot of other languages
22:53:55 <Baughn> OTOH, learning a lazy language doesn't really help with understanding strict ones
22:54:08 <peter_12> the only think I keep wondering about is the side effects. The goal of JavaScript programming is to manipulate the DOM in the browser. That is a lot of side effect work
22:54:09 <dons> it might help realise that strictness is a property of the language though
22:54:31 <dons> sure, the DOM is just an implicit argument to all functions, in a sense
22:54:37 <dons> they implicitly operate on that argument
22:55:06 <peter_12> I thought about that but then isn't that cheating the whole idea? The global could be an implicit argument to all functions
22:55:37 <SamB_XP> it's easy to do that in monadic style...
22:55:42 <dons> cheating what idea? javascript as an imperative, strict language for manipulating a browser state?
22:55:42 <peter_12> there is definitely a sense of state in the browser
22:56:11 <dons> right. its the implicit state mutated by a lot of javascript actions
22:56:38 <peter_12> It will be interesting to see how far I can take Haskell ideas into the browser
22:56:46 <peter_12> I don't know how much will fit in well
22:57:09 <dons> i guess you'll have to find out. do you use higher order functions much in javascript?
22:57:24 <dons> or rich data types?
22:57:26 <emu> any idea why a function like unsafeTail would cons a lot?
22:57:36 <emu> in D.B.C8
22:57:42 <dons> hmm
22:57:47 <emu> er, base
22:57:52 <dons> `cons`?
22:58:11 <dons> unsafeTail :: ByteString -> ByteString
22:58:11 <dons> unsafeTail (PS ps s l) = assert (l > 0) $ PS ps (s+1) (l-1)
22:58:11 <dons> {-# INLINE unsafeTail #-}
22:58:18 <dons> its just pointer arithmetic
22:58:42 <emu> i know
22:58:58 <emu> but profiling shows it as allocating a good chunk overall
22:59:08 <emu> i don't understand why that would happen
22:59:12 <peter_12> I use higher order functions quite a bit already
22:59:12 <dons> the profiler is confused then. its happening somewhere else.
22:59:31 <dons> peter_12: do you use lazy lists or generators ever?
22:59:41 <peter_12> no
22:59:46 <dons> or do control flow via list traversals?
22:59:46 <peter_12> don't know what a lazy list is
23:00:01 <peter_12> there is lots to learn!
23:00:07 <dons> ah ok, well there's a hugh bunch of techniques to do with writing modular components you can learn about, based around laziness
23:00:27 <dancor> mac os x fink source build: if in /sw/lib/ghc-6.6 there is HShaskell98.o etc instead of libHShaskell98.a etc then something has gone horribly wrong, correct?
23:00:28 <Baughn> > let fibs = 1 : 1 : zipWith (+) fibs (tail fibs) in fibs
23:00:36 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
23:00:40 <Baughn> peter_12: That's a lazy list. A simple one, in this case
23:00:47 <adu> ok, so far, for head.hs i have:
23:00:48 <dons> > take 10 [1..]
23:00:48 <adu> main = map putStr [ getLine | n <- [0..10]]
23:00:49 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
23:01:32 <peter_12> what is so lazy about those lists?
23:01:40 <Baughn> adu: Monadic code is a bit beyond your level as yet. Try doing it in terms of interact
23:01:40 <adu> but it says its type "String -> IO ()" and it needs to be "IO String -> IO ()"
23:01:57 <Baughn> adu: Eg. the interact function in Prelude
23:02:05 <adu> ok
23:02:21 <dons> peter_12: only as many elements of the list are generated as the list consumer needs
23:02:33 <dons> so you write the generator to generate an infinite data structure
23:02:35 <Baughn> :t interact
23:02:37 <lambdabot> (String -> String) -> IO ()
23:02:42 <peter_12> ahh
23:02:44 <peter_12> interesting
23:02:47 <dons> and the consumer `demands' only the part of the structure it actually needs
23:02:48 <adu> i've read about implicit IO passing between statements in a do block
23:02:50 <Baughn> adu: So, "main = interact fun", and you get to write fun
23:03:16 <dons> > [1..] -- an infinite structure
23:03:17 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
23:03:28 <peter_12> interesting
23:03:32 <dons> > reverse . take 20 $ [1..] -- which we partially consume
23:03:33 <lambdabot>  [20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1]
23:03:40 <emu> adu: you need to understand that "String -> String" and "String -> IO String" are not the same type.  if a function requires one, it is not going to be happy with the other.
23:03:46 <dons> and then we didn't need to worry about modifying the generator to put an upper bound on it
23:04:04 <dons> so, imagine the generator is in a library -- it'll generatate ,say, elements in a tree, only when those tree nodes are accessed
23:04:08 <adu> emu: i understand that they're not the same, but what i don't understand is how to convert between them
23:04:14 <dons> rather than allocating an entire tree, even if you want to access only a small part of it
23:04:18 <dons> its a rather powerful technique
23:04:25 <dancor> adu: were you trying to do like    main = mapM_ (putStrLn . show) [1..10]   ?
23:04:41 <peter_12> very interesting
23:04:41 <peter_12> ok. I start reading "yet another haskell tutorial"
23:04:46 <Baughn> adu: That sort of thing is generally covered rather late in haskell tutorials. You could try skipping ahead, but using interact lets you sidestep the issue for now.
23:04:46 <peter_12> thanks guys
23:04:46 <dons> i note perl6 has lazy lists now, and you can fake them with 'yield' in python
23:04:48 <adu> my current view of "IO" is that it is kind of like a C++ template in that it "grabs" the string somehow, and that its not really two types, but the type IO<String> kind of
23:05:05 <dons> once you have a lazy structures, you can use them as control flow
23:05:13 <dons> for example, no need to write a for loop with indexes
23:05:16 <dancor> adu: yeah it's more like IO<String> than two different types sure
23:05:18 <dons> just fold over a lazy list
23:05:31 <adu> dancor: i guess
23:05:33 <dons> > map (\n -> n * 2) [1..10]
23:05:35 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
23:05:37 <Pseudonym> Templates and Haskell parametric polymorphism are very closely related.
23:05:43 <dons> a for loop ^^, as a data structure
23:05:46 <Pseudonym> And IO String is indeed parametric polymorphism.
23:05:53 <Baughn> adu: Sure, IO is a parametrized type. You get those everywhere; they're simple to define and quite useful.
23:06:00 <Baughn> adu: There's a lot more to IO than that, however
23:06:08 <emu> adu: the >>= operator can allow you to operate on values inside the monad
23:06:16 <emu> :t getLine
23:06:18 <lambdabot> IO String
23:06:23 <emu> :t (>>=)
23:06:25 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
23:06:26 <adu> is do a monad?
23:06:30 <peter_12> dons: thanks for the   info
23:06:33 <emu> do is syntactic sugar
23:06:37 <peter_12> I'll start studying
23:06:42 <adu> is 'IO' the monad?
23:06:49 <Baughn> adu: Yes
23:06:51 <adu> ok
23:06:52 <emu> :t getLine >>= \ line -> putStrLn line
23:06:53 <lambdabot> IO ()
23:07:07 <Pseudonym> You can think of do as like what C++ would do if you could overload the C++ operator ;
23:07:14 <adu> :t interact
23:07:16 <lambdabot> (String -> String) -> IO ()
23:07:25 <emu> your ghci prompt will also answer :t queries ;)
23:08:25 <SamB_XP> Pseudonym: also pass around { cout << "hi!" }
23:08:29 <emu> the >>= operator lets you take values out of the monad... but you must put them back when you're done
23:08:54 <emu> must put something back
23:09:00 <dancor> does anyone know why i would have .o files in /sw/lib/ghc-6.6 after my fink build?  maybe i should ask in gcc?  seems like a genericish weird thing that could happen
23:09:03 <adu> Pseudonym: that is way mind-bending
23:09:05 <emu> :t getLine >>= \ line -> return line
23:09:07 <lambdabot> IO String
23:09:30 <emu> there i took the line out, and i returned it right back
23:09:31 <Baughn> adu: It's mostly just syntax. Like this:
23:09:34 <Pseudonym> adu: But it makes sense in a language where imperative code is the exception rather than the rule.
23:09:41 <adu> :t getLine >>= (return)
23:09:42 <lambdabot> IO String
23:09:42 <Baughn> @undo do foo <- getLine; print foo
23:09:43 <lambdabot> getLine >>= \ foo -> print foo
23:09:51 * SamB_XP wonders if you can override operator >> and operator >>= to do monads in C++?
23:10:02 <emu> that's right, \ line -> return line is the same as just return, in this case
23:10:09 <Pseudonym> SamB: No.  Wrong precedence/associativity.
23:10:16 <SamB_XP> Pseudonym: awwwwww
23:10:26 <Baughn> SamB_XP: Add lispy parantheses, and it'll work
23:10:35 <Pseudonym> And you'll need Boost.Lambda or FC++.
23:10:40 <Baughn> That fits, since you're greenspinning
23:10:54 <SamB_XP> greenspinning?
23:11:22 <Baughn> Would greenspin, I guess
23:11:40 <emu> adu: now, any time you see: "foo >>= \ x -> bar x" you can translate it to "do x <- foo; bar x"  or back
23:11:40 <SamB_XP> who or what is greenspin?
23:12:01 <SamB_XP> @redo getLine >>= \ foo -> print foo
23:12:01 <lambdabot> do { foo <- getLine; print foo}
23:12:04 <adu> what does <- do?
23:12:05 <emu> greenspun ;)
23:12:19 <adu> i know \ x -> f is lambda
23:12:20 <emu> adu: it is syntactic sugar for ... >>= \ ... basically =)
23:12:41 <SamB_XP> green...span?
23:12:43 <adu> but i thought >>= was syntactic sugar for x <- foo;
23:12:48 <quicksilver> no
23:12:53 <quicksilver> >>= is the 'real' operator
23:12:55 <SamB_XP> adu: no, >>= is the unsugar
23:12:57 <quicksilver> <- is the sugar
23:12:58 <adu> ok
23:13:03 <Pseudonym> When you define your own monad, you define >>=
23:13:05 <Pseudonym> And return
23:13:09 <Pseudonym> And possibly fail.
23:13:09 <SamB_XP> it is only semi-sweetened ;-P
23:13:19 <adu> heh
23:13:39 <Baughn> SamB_XP: greenspins, is greenspinning, would greenspin, has greenspun, had greenspunned
23:13:44 <Pseudonym> do-notation is syntactic sucralose.
23:13:46 <lispy> Baughn: do my parenthises look lispy to you? ;)
23:14:03 <SamB_XP> those lambdas, though, might be pure sugar lambdas (shapr, iirc, likes to give those out.)
23:14:19 <lispy> Pseudonym: as in, it tastes bad?
23:14:29 <Pseudonym> Sucralose tastes bad?
23:14:41 <lispy> Pseudonym: is that the same as "splenda" ?
23:14:45 <Pseudonym> Yes.
23:14:52 * Pseudonym likes sucralose
23:14:52 <lispy> yes it tastes bad
23:14:53 <SamB_XP> is that the stuff that comes in the pink packets?
23:15:05 <adu> i can't find mapM_ in the Prelude
23:15:10 <lispy> Pseudonym: it's like rancid sugar for me
23:15:13 <Pseudonym> SamB: No.
23:15:15 <SamB_XP> @hoogle mapM_
23:15:16 <lambdabot> Prelude.mapM_ :: Monad m => (a -> m b) -> [a] -> m ()
23:15:16 <lambdabot> Data.FunctorM.fmapM_ :: (FunctorM f, Monad m) => (a -> m b) -> f a -> m ()
23:15:18 <Pseudonym> Maybe it's the maltodextrin.
23:15:40 <Pseudonym> I meant that it's like sugar only with none of the calories.
23:15:48 <lispy> ah :)
23:15:57 <SamB_XP> Pseudonym: "virtual sugar"?
23:16:13 * Pseudonym doesn't mind sucralose at all
23:16:21 <Baughn> SamB_XP: What you make syntactic sugar of
23:16:34 <Pseudonym> They released Coke Zero in Australia recently, only they used phenylalanine.
23:17:04 <Pseudonym> I can only taste the sweetner, not the coke.
23:17:42 <Pseudonym> Anyway, back to Haskell.
23:17:53 <{LeCamarade}> `Phenylalanine'. Just when I thought `monad' was an evil-sounding name ...
23:18:22 <SamB_XP> @go monads catholic
23:18:24 <lambdabot> http://www.newadvent.org/cathen/10447b.htm
23:18:25 <lambdabot> Title: CATHOLIC ENCYCLOPEDIA: Monad
23:18:55 <{LeCamarade}> :o)
23:20:57 * Pseudonym works in a chemistry lab
23:21:03 <Pseudonym> Some of the names around here sound really scary.
23:21:47 <Baughn> Pseudonym: Mercury fulminate scary?
23:21:48 <Pseudonym> The atomic force microscope downstairs sounds like something a mad scientists would use to spy on his enemies.
23:22:09 <Pseudonym> And destroy them when he found them.
23:22:44 <scodil> so if monad is to 1 what dyad is to 2, where does the haskell usage of monad come from? How is an instance of the monad typeclass in a state of "oneness"?
23:22:45 <{LeCamarade}> Pseudonym: Now that is scary. `Atomic force microscope'. The revolution should put a listening post there. ;o)
23:23:15 <adu> i give up
23:23:23 <Pseudonym> scodil: The Haskell usage is from category theory.
23:23:33 <Pseudonym> And it apparently has no relationship to the philosophical meaning.
23:23:37 <scodil> and that has nothing to do with the greek origins?
23:23:39 <scodil> oh ok
23:23:42 <Pseudonym> monoid + triad = monad
23:23:43 <Baughn> adu: main = interact (take 10 . lines)
23:23:54 <scodil> they just thought it sounded cool then
23:24:04 <SamB_XP> shouldn't that involve quat or quad ?
23:24:10 <Pseudonym> :t interact (take 10 . lines)
23:24:12 <lambdabot>     Couldn't match expected type `Char' against inferred type `String'
23:24:12 <lambdabot>       Expected type: String -> String
23:24:14 <Baughn> adu: Plus an unlines
23:24:28 <SamB_XP> Quadroid maybe ;-)
23:24:35 <scodil> tetrad
23:24:54 <adu> Baughn: that says "[Char] -> [[Char]]" does not match "String -> String"
23:25:00 <Pseudonym> The "monoid" part is because monads are generalisations of monoids.
23:25:15 <Pseudonym> m >>= return = return x >> m = m
23:25:27 <SamB_XP> Pseudonym: it just sounds like it means "one-liker" or smth
23:25:30 <scodil> is there any meaningful etymology to the name monad? or is it totally random?
23:25:31 <Pseudonym> And (a >> b) >> c = a >> (b >> c)
23:25:51 <syntaxfree> I want to hide the default Show instance for Bool from the Prelude.
23:25:55 <Pseudonym> That's the "monoid" part.
23:25:56 <SamB_XP> Mon-oid + Tri-ad = Mon-ad?
23:25:57 <scodil> was the original paper written by Frank Monad, hence we call them Monads?
23:26:02 <syntaxfree> is there a "hiding" syntax?
23:26:11 <SamB_XP> syntaxfree: no!
23:26:16 <Pseudonym> The "triad" part is that monads were traditionally defined in terms of join, return and map.
23:26:17 <syntaxfree> @remember scodil ee> is there a "hiding" syntax?
23:26:17 <lambdabot> Done.
23:26:26 <syntaxfree> jesus, not that.
23:26:44 <syntaxfree> @remember scodil was the original paper written by Frank Monad, hence we call them Monads?
23:26:44 <lambdabot> Done.
23:26:47 <scodil> @forget
23:26:47 <lambdabot> Unknown command, try @list
23:26:48 <Pseudonym> The "triad", "triple" etc is a category theory convention of choosing unimaginative names.
23:26:54 <scodil> @forget me
23:26:54 <lambdabot> Unknown command, try @list
23:26:57 <Baughn> adu: Thus the "plus an unlines" comment
23:27:10 <Pseudonym> Just about everyone after Saunders Mac Lane picked bad names.
23:27:11 <SamB_XP> dons: can you make lambdabot forget scodil ee> is there a "hiding" syntax?
23:27:13 <Pseudonym> Or bad conames.
23:27:14 <Baughn> adu: You need unlines to convert the list of strings back into a single string.
23:28:05 <adu> :t interact (unlines (take 10 . lines))
23:28:07 <lambdabot>     Couldn't match expected type `[String]'
23:28:07 <lambdabot>            against inferred type `String -> [String]'
23:28:10 <Pseudonym> @forget me not
23:28:10 <lambdabot> Unknown command, try @list
23:28:24 <Baughn> adu: That's not it. Do you know what the (.) function does?
23:28:26 <scodil> @don't you... forget about me
23:28:26 <lambdabot> Unknown command, try @list
23:28:35 <syntaxfree> sucks.
23:28:36 <adu> Baughn: composition
23:28:46 <syntaxfree> back to work/
23:28:52 <Baughn> adu: So, what did I do in there with take and lines?
23:29:52 <adu> Baughn: effectively make \x-> take 10 (lines x)
23:30:15 <Baughn> adu: Yes, I guess. How do you fit lins in there?
23:30:26 <Baughn> *unlines
23:30:42 <Baughn> adu: More importantly, unlines is of type [String] -> String. (take 10 . lines) is of type String -> [String], which does not match the [String] unlines wants - you're passing it a function instead of a list of strings
23:30:56 <adu> Baughn: as another function which operates on the output of that lambda
23:31:11 <Baughn> adu: Or just with . again, but sure
23:31:34 <dancor> adu: mapM_ is just mapM but it throws away the result
23:31:37 <adu> but don't we want unlines on the outside?
23:31:46 <dancor> adu: mapM is map for monads
23:31:50 <syntaxfree> what's the ascii value for the negation symbol?
23:31:52 <adu> dancor: ok
23:31:55 <syntaxfree> some people have it on their keyboards.
23:31:59 <syntaxfree> ask lambdabot, someone who has it?
23:32:00 <Baughn> adu: Outside of what?
23:32:02 <syntaxfree> the sidewats "L"
23:32:15 <Baughn> adu: You're not passing unlines a *value*; you're passing it a *function*. It wants a value.
23:32:30 <adu> :t interact (unlines . take 10 . lines)
23:32:32 <lambdabot> IO ()
23:32:37 <adu> o wow
23:32:45 <Baughn> adu: You don't want to be passing unlines anything at all; you want to compose unlines with the rest of the thing and pass the entire resulting composed function to interact.
23:32:50 <dancor> syntaxfree: i would use http://www.fileformat.info/info/unicode/char/search.htm
23:32:52 <lambdabot> Title: Unicode Character Search
23:32:56 <adu> hehehe
23:33:14 <adu> Baughn: ok
23:33:17 <dancor> though maybe you don't want unicode..
23:33:35 <Baughn> adu: (unlines . take 10 . lines) is equivalent to (\x -> unlines (take 10 (lines x))), but much shorter and easier to read
23:33:47 <adu> Baughn: i was thinking to data-ly and not enough functionally...
23:33:48 <syntaxfree> I want ascii.
23:33:49 <dancor> anyway it's U+00AC  NOT SIGN
23:33:51 <syntaxfree> i want to use chr
23:33:54 <syntaxfree> :t chr
23:33:56 <lambdabot> Int -> Char
23:33:58 <syntaxfree> see?
23:34:22 <adu> Baughn: then what is (unlines (take 10 . lines)) equiv to?
23:34:26 <dancor> > ord('Â¬')
23:34:26 <lambdabot>  Improperly terminated character constant
23:34:38 <adu> Baughn: just nonsense i guess?
23:34:42 <Baughn> adu: Nothing. It's a type error.
23:34:46 <adu> ok
23:34:49 <dancor> > chr(16*10+12)
23:34:50 <lambdabot>  '\172'
23:34:51 <Baughn> adu: Remember the type of lines
23:35:03 <Baughn> adu: It's String -> [String], meaning it's a function
23:35:17 <Baughn> adu: "lines x" is just [String], though x had better be a String
23:35:25 <dancor> ghc doesn't have utf8-ery/locales built-in yet
23:35:29 <adu> ok
23:35:42 <adu> cool
23:35:45 <adu> thanks :)
23:36:19 <Baughn> adu: Intuitively, . lifts away the parameter, constructing.. well, better show you
23:36:23 <Baughn> @src (.)
23:36:23 <lambdabot> (.) f g x = f (g x)
23:36:39 <Baughn> ..that was not what I had in mind
23:36:55 <adu> so anything (like 'interact') that returns IO () i can use as a definition of main?
23:37:10 <dancor> adu: yes
23:37:16 <adu> ic
23:37:17 <Baughn> adu: Yes. The type of main is IO (), so you can't use anything /else/ either
23:37:25 <adu> heh
23:37:28 <emu> :t putStrLn
23:37:30 <lambdabot> String -> IO ()
23:37:36 <adu> thats very liberating
23:37:38 <emu> :t mapM_
23:37:40 <lambdabot> forall a (m :: * -> *) b. (Monad m) => (a -> m b) -> [a] -> m ()
23:37:58 <emu> :t getLine >>= return ()
23:38:00 <lambdabot>     Couldn't match expected type `IO b' against inferred type `()'
23:38:00 <lambdabot>     In the first argument of `return', namely `()'
23:38:05 <emu> :t getLine >>= \_ -> return ()
23:38:07 <lambdabot> IO ()
23:38:26 <Baughn> adu: f . g = \x -> f (g x)
23:38:31 <SamB_XP> @pl getLine >>= \_ -> return ()
23:38:31 <lambdabot> getLine >> return
23:38:38 <Baughn> adu: That's what I was looking for
23:39:01 <SamB_XP> @src (.)
23:39:01 <lambdabot> (.) f g x = f (g x)
23:39:15 <Baughn> adu: Or you could simplify down to "main = interact (unlines . lines)"
23:39:28 <Baughn> adu: Hopefully it's obvious why "main = interact (unlines (lines))" doesn't work
23:41:31 <ura> hello
23:42:02 <ura> Is typecasts possible in haskell.
23:42:08 <Pseudonym> G'day.
23:42:10 <Pseudonym> Yes and no.
23:42:12 <adu> Baughn: i would assume because (lines) is a function and not of type [String]
23:42:13 <Baughn> ura: Why do you want one?
23:42:16 <Baughn> adu: Right
23:42:17 <Pseudonym> What type do you want to convert to what type?
23:42:27 <Baughn> adu: And take 10 . lines is /still/ a function
23:42:34 <adu> ok
23:42:55 <ura> I want to divide result of length function which has type signature that it returns Int
23:43:01 <Baughn> So is unlines . take 10 . lines, for that matter. It has to be; a function is what interact expects.
23:43:08 <Pseudonym> ura: Use `div` instead of /
23:43:18 <ura> I want to divide this result and got a fractional number
23:43:20 <dons> ura, you want to divide using integer division, or floating point division?
23:43:22 <dons> ok.
23:43:30 <ura> dons, I want fp division
23:43:33 * SamB_XP laughs at the SCO dialog in the ticker: http://www.ubersoft.net/d/20070606.html
23:43:34 <lambdabot> Title: Help Desk: Technology Is Not Your Friend
23:43:37 <dons> > fromIntegral (length "haskell") / 3
23:43:39 <lambdabot>  2.3333333333333335
23:43:45 <dons> > genericLength "haskell" / 3
23:43:47 <lambdabot>  2.3333333333333335
23:43:50 <Pseudonym> > floor (2/3)
23:43:52 <lambdabot>  0
23:43:53 <dons> > length "haskell" `div` 3
23:43:54 <lambdabot>  2
23:43:55 <Pseudonym> > ceiling (2/3)
23:43:57 <lambdabot>  1
23:43:58 <ura> dons, thank you very much!
23:44:02 <Pseudonym> > round (2/3)
23:44:03 <lambdabot>  1
23:44:26 <adu> YEY i just implemented 'cat' all by myself:
23:44:29 <adu> main = interact id
23:44:32 <dons> yeah!
23:44:33 <adu> :)
23:44:34 <dons> adu++ great
23:44:38 <ura> fromIntegral and genericLength works exactly as I want :)
23:44:43 <Pseudonym> Cool.
23:44:54 <Pseudonym> There's also:
23:45:00 <Pseudonym> > length "haskell" % 3
23:45:01 <lambdabot>  7%3
23:45:02 <dons> that's the essence of haskell right there, adu. if something can be 'pythonic' , main = interact id is `haskellesque'
23:45:16 <Pseudonym> If you want real fractions rather than floating point.
23:45:19 <adu> dons: :)
23:45:23 <Pseudonym> > length "haskell!" % 2
23:45:24 <lambdabot>  4%1
23:45:33 <adu> dons: Haskelly
23:45:53 <dons> haskellismo?
23:46:04 <adu> haskelltastic
23:46:04 <SamB_XP> haskellisimo!
23:46:08 <Baughn> "haskelly" sounds like some sort of nut
23:46:16 <adu> haskellish?
23:46:23 <dons> -ish is too weak though
23:46:41 <dons> haskellicious?
23:46:52 <dons> lambdastic?
23:46:57 <Baughn> Haskellicious it is
23:47:10 <adu> or how about [haskell..]
23:47:12 <SamB_XP> what did we decide last time?
23:47:16 <dons> haskel33t
23:47:26 <adu> that describes everything that is at all related to haskell, all infinite posibilities :)
23:47:29 <dons> x `elem` haskell
23:47:43 <adu> [Haskell]
23:48:17 <adu> \ ish -> (haskell . ish)
23:48:57 <Baughn> haskell .
23:49:19 <SamB_XP> :t ?haskell .
23:49:21 <lambdabot> parse error (possibly incorrect indentation)
23:49:21 <Baughn> :t haskell.
23:49:23 <lambdabot> parse error (possibly incorrect indentation)
23:49:28 <SamB_XP> :t haskell? .
23:49:30 <lambdabot> parse error on input `.'
23:49:32 <adu> i wish i knew haskell
23:49:38 <SamB_XP> :t (haskell? .)
23:49:40 <lambdabot> parse error on input `.'
23:49:46 <SamB_XP> :t (?haskell .)
23:49:46 <adu> its such a beautiful standard
23:49:47 <lambdabot> forall b c a. (?haskell::b -> c) => (a -> b) -> a -> c
23:50:04 <Baughn> SamB_XP: What does the ? do?
23:50:15 <SamB_XP> Baughn: implicit parameter
23:50:16 <Pseudonym> adu: Wishes don't cut it.  There's only one way.
23:50:24 <SamB_XP> you can see it in the context, to the left of =>
23:50:29 <Baughn> @src fix
23:50:30 <lambdabot> fix f = let x = f x in x
23:50:31 <adu> Pseudonym: move to italy?
23:50:33 <Pseudonym> adu: Play.
23:50:35 <Baughn> adu: Understand fix
23:50:42 <adu> Pseudonym: oh yes
23:50:51 <dons> italy? nah, has to be some cold place
23:51:04 <dons> haskell seems to develop better in cold climates
23:51:14 <adu> is that at all related to infix?
23:51:38 <dons> nope, fix is a loop function.
23:51:47 <dons> infix is a name for a kind of application syntax
23:51:53 <dons> > 7 `elem` [1..10]
23:51:54 <lambdabot>  True
23:51:57 <dons> > elem 7 [1..10]
23:51:58 <lambdabot>  True
23:52:01 <dons> > 2 + 3
23:52:02 <lambdabot>  5
23:52:04 <dons> > (+) 2 3
23:52:05 <lambdabot>  5
23:52:18 <dons> > fix (\x -> 1:x)
23:52:20 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
23:52:32 <dons> > fix (\gnus -> "(not unix " ++ gnus)
23:52:33 <lambdabot>  "(not unix (not unix (not unix (not unix (not unix (not unix (not unix (not ...
23:52:41 <Baughn>  > 1: `fix`
23:52:49 <Baughn> > 1: `fix`
23:52:49 <lambdabot>  Parse error
23:52:58 <dons> :T fix
23:53:00 <dons> :t fix
23:53:02 <lambdabot> forall a. (a -> a) -> a
23:53:06 <adu> is that ghci only?
23:53:09 <pejo> dons, we have esrange up north from here. Cold enough? :-)
23:53:10 <adu> cuz i'm using hugs
23:53:24 <dons> pejo, i guess that will do. :-)
23:53:28 <SamB_XP> adu: is what GHCi only?
23:53:39 <Baughn> dons: I was hoping it'd work anyway
23:53:59 <Pseudonym> dons: It isn't that cold out your way.
23:54:02 <adu> SamB: fix ...
23:54:02 <dons> it'd be a postfix unary op then
23:54:06 <Pseudonym> It never snows there, surely.
23:54:06 <dons> Pseudonym: it is today
23:54:11 <dons> Pseudonym: not so!
23:54:12 <SamB_XP> adu: no...
23:54:16 <Pseudonym> Really?
23:54:21 <Pseudonym> When did it last snow in Sydney?
23:54:27 <dons> let's see..
23:54:40 * Pseudonym remembers it snowing once in Melbourne in living memory
23:54:58 <SamB_XP> > fix ("(not unix "++)
23:54:59 <lambdabot>  "(not unix (not unix (not unix (not unix (not unix (not unix (not unix (not ...
23:55:07 <dons> http://www.oscommerce.com/ext/sydney/bondi_gallery__550x370.jpg
23:55:18 <dons> Pseudonym: light snow once in the morning (in January!) a few years ago.
23:55:29 <dons> but it snows up in katoomba every winter
23:55:35 <Pseudonym> Goodness,. though I must admit that looks like hail to me.
23:55:44 <dons> actually, that looks like hail
23:55:44 <Baughn> > let (|) = flip (.) in (words | reverse | unwords) "alfa beta"
23:55:45 <lambdabot>  Parse error
23:55:51 <Pseudonym> Katoomba I'd believe.
23:55:53 <adu> @src fix
23:55:53 <lambdabot> fix f = let x = f x in x
23:55:57 <dons> there was snow though. let's see if i can find the story
23:56:22 <Baughn> | is taken?
23:56:31 <adu> crazy
23:57:51 <pejo> dons, the very fact that there are stories about when it snowed sort of speaks for itself. ;)
23:57:58 <Pseudonym> Yeah.
23:58:02 <dons> Pseudonym: hehe, "Snow in Sydney is extremely rare. Since European settlement, there have been a few cases recorded of blowing snowflakes, but only 4 occurrences of snow on the ground in any real quantity. All these cases occurred during the icy winter of 1836"
23:58:28 <pejo> Oh, no wonder you can't remember that year.
23:58:28 <Pseudonym> Right.
23:58:29 <dons> there was a weird snow fall, very light, about 5 years ago, gone by 9am
23:58:32 <Pseudonym> http://www.smh.com.au/articles/2005/08/10/1123353352628.html
23:58:33 <lambdabot> Title: Snow falls in Melbourne - National - smh.com.au
23:58:40 <Pseudonym> The headline alone speaks for itself.
23:58:49 <Pseudonym> As pejo points out.
23:58:58 <Pseudonym> Three times in living memory: 2005, 1986 and 1951.
23:59:31 <Pseudonym> I especially like it that the headline is "Snow falls in Melbourne", but they could only find a picture of Canberra.
23:59:50 <Baughn> The relevant headline here would be "City free of snow". And that's how I like it.
23:59:58 <goltrpoat> i remember my father telling this story a bunch of times, about this one time he was in sophia, or maybe it was leipzig, or maybe frankfurt, or maybe bucharest, one of those places.
