00:00:31 <al> augnob: too true... I just handed in a networking assignment with a gigantic quadruple nested switch statement making up the brunt of the code, and just last semester they taught us how coroutines can completely eliminate that kind of state management
00:01:07 <davidL> Thanks for the help everyone, things are a bit clearer now. I am off to bed.
00:02:39 <augnob> al: coroutines are offlimits to a lot of real-world projects.. they'd probably prefer the switch statements
00:03:48 <al> yup... wonderful once you get going but more diffucult to understand than a simple switch statement
00:04:45 <al> this is the impression I get of haskell in general... once I finally figure out this monad trickiness I'm told I can do continuations, backtracking, you name it... but lord knows it's just not clicking yet
00:05:14 <Shimei> Weirdly, continuations made so much more sense to me in Haskell with monads than with scheme's thing.
00:06:12 <Shimei> Maybe Haskell's wikibook is just better than whatever scheme had to read at the time. :p
00:07:01 <augnob> al: when I got out of university, I was surprised by heavy usage of static-sized arrays (sized to suit the worst-case) along with bounds-checking assertions.. and hash tables to quickly index everything
00:07:31 <augnob> al: it depends on the application, but a lot of the time, the simplest of ideas can be effective at solving a lot of problems (and can be easily understood and debugged by anyone)
00:09:21 <augnob> it came as some shock after everything I'd seen in the past years was entirely dynamic, garbage collected, AVL-tree'd, etc.
00:10:52 <Cale> augnob: Then again, I don't need to understand binary balanced trees to use Data.Set :)
00:11:53 <Cale> al: Learning about monads?
00:12:00 <Cale> al: What have you read so far?
00:12:59 <Cale> If you're interested in just jumping right in and learning the IO monad, but don't know where to begin, I wrote a quick intro that's here: http://haskell.org/haskellwiki/Introduction_to_IO
00:13:00 <lambdabot> Title: Introduction to IO - HaskellWiki
00:13:14 <Cale> (shouldn't take longer than a couple minutes to read)
00:13:22 <al> well I've read a gentle introduction to haskell, http://en.wikibooks.org/wiki/Haskell/Understanding_monads, Yet Another Haskell Tutorial (same wiki), etc.
00:13:39 <Cale> I think probably the key to understanding monads is just seeing enough of them to get a handle on what's really being abstracted.
00:14:37 <al> yup... I think I get the gist of how you thread state through the computations, and this allows you to specify the evaluation strategy right?
00:14:44 <Cale> IO is sort of a hard example to start with, because it can't be implemented directly in Haskell (unless Haskell had some other system for doing IO)
00:14:55 <augnob> I haven't looked into monads yet.. Because it doesn't appear to be a construct of the language, and is rather a classification of a design pattern, it's hard to get a sense of just how people have chosen to classify it and why
00:14:58 <Cale> Well, in some monads, you carry along state.
00:15:12 <Cale> augnob: I'd say that's right.
00:15:20 <augnob> sometimes I can't understand something until I've seen enough to understand that there isn't something in particular to understand
00:15:26 <Cale> Basically, a monad is a particular kind of domain specific language.
00:15:39 <augnob> except for what works and the history that led to it being described in that way
00:16:03 <Cale> All that you need is a fundamental set of combining operations for combining the actions in your language, and you get all sorts of control structures for free from Control.Monad.
00:16:46 <Cale> (In particular, bind (>>=) and return will do)
00:17:06 <al> I've yet to try actually rewriting something like a State monad (without looking at the page where they do it)... I was just working through that YAHT, and the point-free style in particular, and that ended up leading to liftM, which leads to monads :-(
00:17:19 <Cale> From those, you get all sorts of things like foreach loops, and other kinds of sequencing.
00:17:49 <Cale> liftM f x = do { v <- x; return (f v) }
00:18:38 <Cale> Basically, it takes a function f and a computation x, and hands you a new computation which runs x, and returns f applied to the result.
00:19:57 <Cale> In the list monad, "computations" are lists, and "running" a computation means getting an element of the list in each possible way.
00:20:13 <Cale> > do { v <- [1,2,3,4,5]; return (v * 2) }
00:20:15 <lambdabot>  [2,4,6,8,10]
00:20:16 <al> but you have to run it inside another monad to get that x in the first place
00:20:17 <al> ?
00:20:30 <Cale> That x is some computation in your monad.
00:20:55 <Cale> (The monad refers to the type constructor, for example, Maybe, List, IO, State s, etc.)
00:21:21 <al> okay so the point of all this is that you use liftM inside a monad to be able to use a pure function?
00:21:23 <Cale> You're asking, to get the result of a computation, you have to be inside another computation?
00:21:40 <Cale> liftM just applies a pure function to the output of a computation, yeah.
00:21:48 <al> so wait... when I do:
00:21:48 <Cale> > liftM (*2) [1..10]
00:21:51 <lambdabot>  [2,4,6,8,10,12,14,16,18,20]
00:21:57 <Cale> On lists, it's just map
00:22:08 <Cale> > liftM (*2) (Just 5)
00:22:11 <lambdabot>  Just 10
00:22:25 <Cale> With Maybe, it does the obvious thing.
00:22:38 <Cale> hmm, have we got state here, I wonder? :)
00:23:11 <Cale> > evalState get 5
00:23:12 <lambdabot>  5
00:23:23 <Cale> > evalState (liftM (*2) get) 5
00:23:25 <lambdabot>  10
00:23:38 <Cale> (this is a pretty stupid example, I admit :)
00:24:07 <Cale> A good example from IO would be something like
00:24:39 <Cale> do { ls <- liftM lines getContents; ... }
00:24:52 <hpaste>  dolio annotated "delimited continuations + transformers" with "Getting uglier." at http://hpaste.org/390#a2
00:24:55 <Cale> getContents gets the contents of stdin
00:25:08 <Cale> and then lines will break its output into lines
00:25:24 <Cale> lines is just a function of type  String -> [String]
00:25:43 <Cale> You could also do:
00:25:53 <al> hrm... so why can't you do:    do { temp <- getContents; ls = lines temp; ... }
00:26:03 <Cale> do { cs <- getContents; let ls = lines temp; ...
00:26:06 <Cale> sure
00:26:19 <Cale> It's just sometimes convenient to write it more compactly.
00:26:24 <Cale> er...
00:26:30 <Cale> do { cs <- getContents; let ls = lines cs; ... }
00:27:38 <Cale> Another very important function is mapM (or forM which is mapM with the parameters flipped)
00:27:42 <al> okay... so the lift extracts the value from the monad, and applies a pure function to it in one step?
00:27:55 <Cale> from the computation
00:28:04 <Cale> and it gives you a new computation
00:28:29 <Cale> @type liftM
00:28:31 <lambdabot> forall a1 r (m :: * -> *). (Monad m) => (a1 -> r) -> m a1 -> m r
00:28:42 <Cale> bah, I could have written it nicer :)
00:28:54 <Cale> liftM :: (Monad m) => (a -> b) -> m a -> m b
00:29:22 <al> so is lift2 something like:   do { temp1 <- ...; temp2 <- ...; f temp1 temp2 } ?
00:29:23 <Cale> So it takes a pure function from a's to b's, and a computation that if run, will produce an a, and gives a computation which if run will produce a b.
00:29:39 <Cale> liftM2, yes, that's exactly it
00:29:59 <Cale> liftM2 f x y = do { v <- x; w <- y; return (f v w) }
00:30:11 <Cale> Don't forget the return, of course.
00:30:21 <al> right
00:30:41 <al> okay... let me dig up my original problem
00:30:51 <Cale> If we left the return out, the thing would still be valid, but it would do something a little different.
00:31:15 <Cale> @type let mystery f x y = do { v <- x; w <- y; f v w }
00:31:18 <lambdabot> <command line>:
00:31:18 <lambdabot>     Could not find module `L':
00:31:21 <Cale> @type let mystery f x y = do { v <- x; w <- y; f v w } in mystery
00:31:23 <lambdabot> forall t t1 (t2 :: * -> *) t3. (Monad t2) => (t -> t1 -> t2 t3) -> t2 t -> t2 t1 -> t2 t3
00:31:41 <Cale> Terrible choice of variables...
00:32:03 <Cale> (Monad m) => (a -> b -> m c) -> m a -> m b -> m c
00:32:19 <al> the return doesn't update the internal state and the other one does?
00:32:49 <scook0> a two-arg version of (=<<)
00:32:59 <Cale> In the case without the return, the f v w should evaluate to a computation, which will get run in that place.
00:33:01 <Syzygy-> Hmmmm.
00:33:25 <Syzygy-> I define, algorithmically, a lazy list, I filter this list, and I ask for the head of the filtered thingie.
00:33:35 <Syzygy-> After about a week of computation, it gives me a stack overflow.
00:33:43 <Syzygy-> What should I look for to figure out why?
00:34:10 <Cale> hmm
00:34:44 <al> Cale: hmm... okay I'll review that in a second... here was my original problem:
00:34:46 <al> @pl \l -> l ++ (map f l)
00:34:47 <lambdabot> ap (++) (map f)
00:34:54 <Cale> ah, hehe
00:35:07 <Cale> That's using the ((->) e) monad
00:35:21 <Cale> this is slightly mindbending, just to warn you :)
00:35:24 <al> so I hear,   ap == liftM2 id
00:35:33 <Cale> yeah, or liftM2 ($)
00:35:36 <setuid_w00t> How can I define a certain expression as non-lazy?  I have an expression that will be used many times, but I want it to only be computed once
00:36:07 <al> yup... just trying to figure this one thing out and I can get to bed (3:30am in the morning for me)
00:36:21 <Cale> setuid_w00t: Well, lazy evaluation will share the results of computing parameters to functions -- so when one gets computed, it should be shared with the others.
00:36:31 <kosmikus> setuid_w00t: you cannot make it non-lazy in general, but most implementations will only evaluate it once if you give it a name (either toplevel or via let/where).
00:36:39 <Cale> setuid_w00t: but if you really want the computation to occur earlier than it otherwise would, you can use seq
00:36:58 <Cale> al: okay
00:37:16 <Cale> Let's look at the type of ap, and splice in the monad in question
00:37:29 <vincenz> someone called?
00:37:40 <Cale> ap :: (Monad m) => m (a -> b) -> m a -> m b
00:37:49 <Cale> In this case, m = (e ->)
00:38:02 <Cale> So ap :: (e -> (a -> b)) -> (e -> a) -> (e -> b)
00:38:04 <setuid_w00t> so if I say "x = 12 * 4 + 3 / 5 * sin(2)"  and then I use  x a bunch of times, will it be computed more than once?
00:38:21 <Cale> setuid_w00t: no, unless it's polymorphic.
00:38:42 <Cale> setuid_w00t: If you define x as a Double or Float, you should be fine.
00:39:48 <Cale> al: That is, ap :: (e -> a -> b) -> (e -> a) -> e -> b
00:39:54 <Cale> so...
00:40:08 <Cale> ap f g x = f x (g x)
00:40:17 <Cale> (In this special case)
00:40:52 <al> okay... which is l ++ map f l
00:40:58 <Cale> right.
00:41:28 <Cale> > map (ap (,) (*2)) [1..10]
00:41:34 <al> so what about in the general case?  what is ap used for?... what is it short for, is it 'apply' or something?
00:41:36 <lambdabot>  [(1,2),(2,4),(3,6),(4,8),(5,10),(6,12),(7,14),(8,16),(9,18),(10,20)]
00:41:40 <Cale> yeah
00:42:06 <Cale> It actually sort of helps provide a generalisation of liftMn
00:42:12 <scook0> it applies a function-in-a-monad to a value-in-a-monad
00:42:21 <Cale> liftM2 f x y = return f `ap` x `ap` y
00:42:36 <Cale> liftM3 f x y z = return f `ap` x `ap` y `ap` z
00:42:39 <Cale> and so on
00:43:19 <al> okay, so just to backup to that new example... ap (,) (*2)
00:43:20 <Cale> Or, in the case of lists, you could use it to apply a list of functions to a list of values in all possible ways...
00:43:31 <pabloe> How do I make Hugs print control characters? e.g. "\n" will print a carriage return
00:43:40 <Cale> > ap [id, (*2), (*3)] [1,2,3,4]
00:43:43 <lambdabot>  [1,2,3,4,2,4,6,8,3,6,9,12]
00:44:09 <Cale> pabloe: putStr "\n"
00:44:21 <Cale> pabloe: Or putStrLn, if you always want an extra trailing \n
00:44:48 <pabloe> yay thanks
00:45:01 <al> Cale: wow that's amazing... hold on let me try to get my head around this though
00:46:15 <al> let me just talk through it... so the list and the end means we're in the list monad?... or we're still in the ((->) t) monad?
00:46:26 <Cale> That's the list monad
00:46:35 <Cale> (the one with ap applied to two lists)
00:46:48 <Cale> computations in the list monad work by choosing results in all possible ways
00:47:06 <Cale> So wherever you have  v <- x  in a do block, that's actually sort of a loop.
00:47:15 <Cale> (In the list monad)
00:47:29 <Cale> It tries all possibilities of choosing v from x.
00:47:41 <Cale> If you know about list comprehensions, it's essentially equivalent to that.
00:47:49 <DRMacIver> Morning
00:48:00 <Cale> > do { x <- [1,2,3,4]; y <- [5,6,7,8]; return (x,y) }
00:48:02 <lambdabot>  [(1,5),(1,6),(1,7),(1,8),(2,5),(2,6),(2,7),(2,8),(3,5),(3,6),(3,7),(3,8),(4,...
00:48:07 <al> right... okay so going back to the map then...  map (ap (,) (*2)) [1..10]
00:48:18 <Cale> Ah, that one's the ((->) e) monad
00:48:30 <Cale> So ap f g x = f x (g x)
00:48:38 <augnob> how do you pronounce monad?  seems like a terrible name
00:48:47 <Cale> So ap (,) g x = (,) x (g x) = (x, g x)
00:49:18 <Cale> augnob: I pronounce it mah-nad, some people pronounce it moh-nad
00:49:35 <Cale> augnob: It's a combination of 'monoid' and 'triad'
00:49:51 <augnob> cale: yeah.. I think mah-nad makes more sense probably.. from 'mono' or one perhaps
00:49:54 <Cale> augnob: Early in their development, monads were sometimes called triads.
00:50:01 <Cale> right
00:50:11 <augnob> cale: it's just unfortunate that it looks so much like gonad
00:50:22 <Cale> It has no etymological connection to the philosophical term 'monad'
00:50:42 <Cale> (apart from the 'mono-'
00:50:43 <Cale> )
00:51:06 <augnob> ah.  I didn't know about the philosophical term anyway.
00:51:10 <Cale> al: So does that make sense?
00:51:19 <Cale> > ap (,) (*3) 5
00:51:21 <lambdabot>  (5,15)
00:51:26 <Cale> > ap (,) (^2) 5
00:51:30 <lambdabot>  (5,25)
00:51:37 <Cale> > map (ap (,) (^2)) [1..10]
00:51:40 <lambdabot>  [(1,1),(2,4),(3,9),(4,16),(5,25),(6,36),(7,49),(8,64),(9,81),(10,100)]
00:51:52 <al> okay so basically both of those arguments to ap have to be in the same monad (so both be functions, or lists)
00:52:01 <Cale> Yeah.
00:52:02 <al> and then the results kind of depend on what monad we're in?
00:52:06 <Cale> Right.
00:52:47 <Cale> In the ((->) e) monad, computations are 'run' by applying them to a value of type e which is the same throughout the computation.
00:52:55 <Cale> For instance...
00:53:08 <al> so in the function monad, the result is to kind of thread the last argument all the way back to the first one
00:53:22 <Cale> > (do { x <- id; y <- (*2); z <- (^2); return (x,y,z) })  5
00:53:24 <lambdabot>  (5,10,25)
00:53:53 <Cale> In order to "run" the computations id, (*2) and (^2), each one is applied to the 5 which gets supplied in the end.
00:53:54 <al> ahh that makes so much sense with that last example...
00:54:16 <Cale> So...
00:54:53 <fasta> libghc6-network-dev cannot be installed in Debian (Testing) :(
00:55:38 <Cale> ap f g x = (do { h <- f; v <- g; return (h v)}) x
00:55:53 <Cale> And then h = f x
00:55:55 <al> so in your map example... first we run (,) on 1, which is (1,)... and then *2 on 1 which is 2, and then (1,) 2 which is (1,2)
00:55:57 <Cale> and v = g x
00:56:09 <Cale> and so h v = f x (g x)
00:56:14 <Cale> and that's what gets returned
00:56:25 <al> I guess the (,) doesn't work like that, but theoretically in terms of what's curried it's kind of like that?
00:56:33 <Cale> right
00:56:56 <Cale> Well, you can't actually write (1,), but that's just a syntax thing.
00:57:06 <Cale> (,) 1 is perfectly valid
00:57:10 <Cale> :t (,) 1
00:57:12 <lambdabot> forall t b. (Num t) => b -> (t, b)
00:57:29 <al> right right
00:57:42 <Cale> So these general monad combining functions tend to turn into really interesting things in special cases.
00:57:53 <Cale> Another really nice one is sequence
00:58:04 <Cale> sequence [] = return []
00:58:24 <Cale> sequence (x:xs) = do { v <- x; vs <- sequence xs; return (v:vs) }
00:59:02 <Cale> It takes a list of computations and produces a computation that returns a list.
00:59:04 <al> so it runs computations from a list in sequence?
00:59:09 <Cale> yeah
00:59:20 <Cale> > sequence [[1,2,3],[4,5],[6,7,8]]
00:59:22 <lambdabot>  [[1,4,6],[1,4,7],[1,4,8],[1,5,6],[1,5,7],[1,5,8],[2,4,6],[2,4,7],[2,4,8],[2,...
00:59:32 <Cale> In the list monad, that's a sort of Cartesian product.
00:59:51 <Cale> > sequence [(*2), (+1), (^2)] 5
00:59:52 <lambdabot>  [10,6,25]
01:00:13 <Cale> In the ((->) e) monad, it's sort of a swapped version of map.
01:00:27 <Cale> (applying a list of functions to a single value)
01:00:52 <Cale> In the state monad, it'll just run each of the state computations in a loop.
01:01:07 <Cale> (and return a list of all the results)
01:01:41 <al> how does the ((->) e) version look?
01:02:03 <Cale> Well, I showed an example there, you want to see it specialised?
01:03:21 <Cale> We can apply each of the cases of the sequence function to a parameter and using the ((->) e) monad reduce the definitions a little.
01:03:30 <Cale> sequence [] x = return [] x = []
01:04:13 <Cale> sequence (x:xs) e = (do { v <- x; vs <- sequence xs; return (v:vs) }) e
01:04:22 <Cale> Then v = x e
01:04:29 <Cale> and vs = sequence xs e
01:05:25 <Cale> So, sequence (x:xs) e = x e : sequence xs e
01:05:45 <Cale> (In this case)
01:06:00 <al> ahh I see...
01:06:29 <Cale> You can also derive what it must be my looking at the types
01:06:42 <Cale> sequence :: (Monad m) => [m a] -> m [a]
01:06:48 <Cale> So if m = ((->) e)
01:06:57 <al> then it's [e]
01:07:02 <Cale> sequence :: [e -> a] -> (e -> [a])
01:07:10 <Cale>           = [e -> a] -> e -> [a]
01:07:52 <Cale> and there's only really one completely sensible function which that could be.
01:10:01 <Cale> al: Is that all making sense?
01:10:34 <Cale> We also have mapM f xs = sequence (map f xs)
01:10:44 <Cale> That is,
01:10:51 <Cale> mapM f [] = return []
01:11:22 <Cale> mapM f (x:xs) = do { v <- f x; vs <- mapM f xs; return (v:vs) }
01:11:36 <Cale> This is effectively a foreach loop
01:12:14 <Cale> You pass it a function which says what to do given an element of the list, and a list, and it does each thing in turn.
01:13:27 <al> so it's like map except the functions are computed inside the monad then?
01:13:41 <Cale> Yeah
01:14:25 <al> so for pure functions we just use map... but for monadic functions like putStr, you use mapM?
01:14:33 <Cale> yeah
01:14:42 <Cale> mapM print [1..10]
01:14:48 <Cale> try that at the ghci prompt
01:15:02 <Cale> (or hugs)
01:15:23 <Cale> If you have 6.6, it'll also print the result, which is just a boring list of empty tuples.
01:15:59 <al> right... okay thanks for the detailed explanation, this is starting to pierce the shroud a little bit
01:16:15 <Cale> If you want to throw away the results of the iterations, you can use the variant mapM_ which runs the computations but doesn't store their results.
01:16:41 <al> I think I need to review this conversation a bit more and then try writing a few things myself before I can really grok this
01:16:53 <Cale> There's also forM and forM_ which are just like mapM and mapM_, but the parameters are flipped, so the list is written first, more like a traditional foreach loop.
01:17:20 <Cale> You can write things like:
01:17:35 <Cale> forM_ args $ \arg -> do
01:17:39 <Cale>   print arg
01:17:43 <Cale> etc...
01:18:42 <Cale> There's also a whole bunch of other things in Control.Monad which are fairly interesting, but less commonly used, like filterM
01:18:49 <al> and there's the foreach loop... fascinating...
01:19:05 <Cale> oh, replicateM is handy.
01:19:23 <Cale> replicateM n x will just run x in a loop n times
01:19:29 <Cale> (and give a list of results)
01:19:39 <Cale> replicateM_ n x will elide the list of results
01:20:58 <Cale> join is fun
01:21:07 <Cale> join :: (Monad m) => m (m a) -> m a
01:21:40 <al> hrm... I don't understand the ghc comment for join
01:21:49 <Igel> : join $ Just Nothing
01:21:57 <Igel> > join $ Just Nothing
01:22:00 <lambdabot>  Nothing
01:22:05 <Igel> :)
01:22:36 <al> so it's like doing a     temp <- Just Nothing  ?
01:22:55 <al> no wait...
01:23:18 <Cale> join x = do { y <- x; v <- y; return v }
01:24:21 <al> okay... so what's a practical snippet for that?
01:25:01 <Cale> Well, it specialises nicely in the simple monads...
01:25:07 <mgsloan> well, you can define >>= in terms of join and fmap.. well, maybe not so practical, but eh
01:25:15 <Cale> In ((->) e), we have join f x = f x x
01:25:27 <mgsloan> i think join == concat as well
01:25:30 <Cale> right
01:25:35 <Cale> In the list monad.
01:25:40 <mgsloan> > join ["foo", "bar"]
01:25:41 <lambdabot>  "foobar"
01:25:42 <mgsloan> yeah
01:26:25 <al> so would join [ (*2) (*3) ] work out to be *6?
01:26:36 <al> apply one then the other?
01:26:38 <Cale> No, that would mix monads.
01:26:58 <Cale> You need a list of lists, or a function returning a function, etc.
01:26:58 <mgsloan> yes, keep your monads to yourself ;)
01:28:25 <al> okay... so in that second example, it would return that second function
01:28:38 <Cale> > join (*) 5
01:28:40 <lambdabot>  25
01:28:41 <fasta> Hmm, an unexpected '(' at column 330! :(
01:28:54 <Cale> > join (++) "echo!"
01:28:57 <lambdabot>  "echo!echo!"
01:29:00 <fasta> Must be some evil macro expansion somewhere...
01:29:23 <mgsloan> > let sqr = join(*) in sqr 10
01:29:25 <lambdabot>  100
01:29:41 * mgsloan did not know that numbers were monads
01:29:58 <mgsloan> oh wait, -> e is the monad
01:30:03 <mgsloan> my bad
01:30:34 <al> @src join
01:30:34 <Cale> (->) e
01:30:34 <lambdabot> join x =  x >>= id
01:30:58 <Cale> I gave a perhaps simpler to understand version up there somewhere.
01:31:01 <Cale> join x = do { y <- x; v <- y; return v }
01:31:24 <Cale> So it runs x to get a computation y, which it runs to get a value v, and returns that.
01:31:28 <Cale> You could also write:
01:31:37 <Cale> join x = do { y <- x; y }
01:31:51 <Cale> Since the result of the last computation in a do-block is what gets returned.
01:33:45 <al> > join ["foo", "bar", "baz"]
01:33:47 <lambdabot>  "foobarbaz"
01:34:02 <Cale> > join [[1,2,3],[4,5],[6,7,8]]
01:34:05 <lambdabot>  [1,2,3,4,5,6,7,8]
01:34:39 <Cale> > do { y <- [[1,2,3],[4,5],[6,7,8]]; v <- y; return v }
01:34:41 <lambdabot>  [1,2,3,4,5,6,7,8]
01:35:46 <al> so the first line extracts the sublists out of the main lists... then the second one extracts the entries, and we yield individual values... which in the list monad get collected into a big list
01:36:39 <Cale> right
01:37:15 <Cale> The only really important thing I think we haven't covered yet is the meaning of do-notation in terms of (>>=)
01:37:55 <al> so one second... what is '<-' pulling out of (*) 5 ?
01:38:13 <Cale> The result of applying that function to the environment.
01:38:18 <Cale> (which was 5)
01:39:46 <al> not sure I understand that... y <- ??;
01:40:05 <quicksilver> means 'do the compautation and put the result in y'
01:40:07 <al> y <- (a->b) right
01:40:34 <Cale> join (*) 5 = (do {y <- (*); v <- y; return v}) 5
01:40:41 <Cale> and then y = (*) 5
01:40:51 <Cale> and v = y 5 = (*) 5 5
01:47:42 <al> hrm... the list version is so much easier to understand than the function version...
01:48:07 <Cale> In general
01:48:28 <dolio> @src Writer listen
01:48:28 <lambdabot> Source not found. And you call yourself a Rocket Scientist!
01:48:35 <Cale> join f x = (do { g <- f; v <- g; return v }) x
01:48:54 <Cale> and so g = f x, and v = g x = f x x
01:49:08 <Cale> and so join f x = f x x in that monad
01:49:54 <al> I guess the part I don't understand is how g <- f extracts values of x like that...
01:50:17 <Cale> okay, to really understand that, you have to look at what the do notation means and how this monad is defined
01:50:48 <Cale> You can just say that in the ((->) e) monad, computations are run by applying them as functions to the environment.
01:51:49 <Cale> Let's actually define what do-notation means though, and have a good look at this bind thing
01:52:15 <al> and the environment is the first value passed to the whole do block?
01:52:21 <Cale> do { v <- x; <stmts> } is translated to x >>= \v -> do { <stmts> }
01:52:40 <Cale> al: yeah, it's the '5' in the example I gave
01:53:51 <Cale> do { x } is translated to x
01:54:10 <Cale> do { x; <stmts> } is translated to x >> do { <stmts> }
01:54:25 <Cale> where x >> y = x >>= const y
01:54:38 <Cale> or x >> y = x >>= \k -> y
01:54:41 <Cale> if you prefer
01:55:06 <fasta> I call some zombie processes in my program when I exit it with C-c C-c. How can I avoid that?
01:55:07 <Cale> do { let {<decls>} ; <stmts> } is translated to let <decls> in do { <stmts> }
01:55:25 <fasta> Er s/call/create
01:55:28 <Cale> And that's basically it, except for a little detail which I'd rather not bother with at the moment :)
01:56:01 <Cale> So if you really want to understand how the environment parameter gets passed down to each of the computations, it's enough to understand what >>= is doing
01:56:10 <Cale> >>= is defined separately for each monad
01:56:14 <Cale> (as is return)
01:56:25 <Cale> and they're the two primitives that let all this happen
01:57:39 <Cale> In the ((->) e) monad,
01:57:43 <Cale> return = const
01:57:56 <Cale> f >>= k = \r -> k (f r) r
01:58:10 <Cale> This takes some digestion :)
01:58:49 <Cale> I suppose it might be helpful first of all to remember that x >>= f = do { v <- x; f v }
01:59:13 <Cale> So what's going on here...
01:59:37 <fasta> Cale: any idea on the zombie process problem?
02:00:18 <Cale> fasta: I'm not sure -- handle the signals and make sure the processes terminate cleanly?
02:01:02 <Cale> To be honest, I'm still not really all that familiar with unix internals.
02:01:38 <Cale> (despite the fact that I've been using linux exclusively for maybe 7 years or so)
02:02:02 <fasta> Cale: but doesn't that mean that I need to have access to some list of processes that I started then?
02:02:20 <Cale> al: So in general, x >>= f means to run the computation x, and take its result and apply f to it in order to get the rest of the computation to run
02:02:46 <Cale> fasta: Shouldn't you have their pids from when you created them?
02:03:05 <dolio> @source Control.Monad.Writer
02:03:06 <lambdabot> http://darcs.haskell.org/packages/mtl/Control/Monad/Writer.hs
02:03:22 <fasta> Cale: yes, but that doesn't mean I have access to them in the interrupt.
02:03:28 <fasta> Cale: handler
02:03:36 <Cale> fasta: ah, right
02:03:54 <fasta> Cale: what further complicates this is that I use unsafePerformIO only for testing purposes.
02:08:55 <Cale> al: So, in this case, x >>= f = \r -> f (x r) r -- it applies x to r in order to get the "result of running x", and then applies f to that, and passes the environment r along.
02:10:57 <Cale> (remember that it's producing a computation, which is a function from an environment to a result)
02:16:01 <baboa> hi, anybody here interested in Lua language?
02:16:12 <fasta> baboa: This is #haskell
02:16:30 <fasta> baboa: most people have an interest in more than one language, though.
02:16:45 <fasta> baboa: but a rather pointless question in this channel.
02:16:45 <baboa> yes, and I created a wrapper over Lua interpreter for Haskell :)
02:16:57 <baboa> looking for early testers :)
02:17:09 <baboa> does this make sense?
02:17:20 <ClaudiusMaximus> baboa: i have a little interest, but it was dampened by the seeming lack of FFI support for making C function pointers from Lua functions
02:17:27 <fasta> baboa: you should test for yourself
02:17:51 <fasta> baboa: just check whether two arbitrary programs have the same output in Haskell and Lua.
02:18:09 <baboa> fasta: :)
02:18:24 <baboa> fasta: and implement QuikCheck for Lua? no, thanks :)
02:18:27 <fasta> baboa: there is no need for "testers", imho.
02:18:38 <fasta> baboa: ?
02:18:47 <fasta> baboa: you can just use Haskell to do that.
02:18:58 <baboa> fasta: could you elaborate?
02:19:34 <al> Cale: sorry I'm a little slow, I'm just working out the example for two binds chained together
02:19:39 <fasta> baboa: write a quickcheck program that checks that a given piece of Lua source text evaluated by your interpreted yields the same answer as given to the real Lua interpreter.
02:19:48 <Cale> al: no problem
02:19:53 <fasta> baboa: Not rocket-science.
02:20:03 <baboa> I created only wrapper, no a standalone interpreter
02:20:11 <baboa> so by definition it is the same
02:20:23 <fasta> baboa: Oops
02:20:39 <fasta> baboa: My brain lazily evaluated your sentence incorrectly.
02:20:55 <fasta> baboa: still what would you need testers for?
02:21:03 <baboa> that is why I asked about people interested in Lua FFI wrapper for Haskell
02:21:09 <Cale> al: It's sort of tricky to understand larger examples when you expand out all the details, but it's fairly mechanical to compute them anyway.
02:21:16 <beelsebob> fasta: that's not rocket science... what is rocket science is writing the generator
02:21:20 <baboa> installation, for example
02:21:27 <beelsebob> write me a generator for valid Lua Code
02:21:57 <fasta> beelsebob: it depends on requirements.
02:22:01 <baboa> anyway, have a look at http://home.agh.edu.pl/~gpolak/hslua/, if you care
02:22:03 <lambdabot> Title: Scripting.Lua
02:22:29 <fasta> baboa: there more FFI's there are available for Haskell the better, of course.
02:22:32 <baboa> I dont think there is any reason to generate yet another interpreter
02:22:41 <fasta> baboa: announce it at the mailing lists.
02:23:07 <baboa> fasta: I'd at least two people that successfuly compile this on their computer, then I'll announce
02:23:27 <fasta> baboa: ok, sounds reasonable. Ignore what I said.
02:23:48 <baboa> fasta: I did already :)
02:23:54 <pabloe> Is it possible to create a monad M whose argument is always an Int? Like can I do what I mean by "data M = M Int" (of course that doesnt work)
02:23:55 <fasta> baboa: very good
02:24:17 <Cale> pabloe: no, monads have to be able to return any type of value
02:24:20 <eivuokko> pabloe, No.
02:24:46 <Cale> Really, a monad is a type constructor
02:24:57 <Cale> So it takes a type and gives you another type.
02:25:15 <pabloe> I see, and there's no way to make sure that that type is always a certain something
02:25:17 <Cale> (which is thought of as the type of computations returning a value of that type)
02:25:23 <Cale> right
02:25:26 <pabloe> I am thinking that there is no reason I would want to do that
02:25:30 <pabloe> and I just dont see that yet
02:26:23 <Cale> Well, it would be nice to be able to define monads on special subsets of Haskell types -- say all those which fall into a given typeclass.
02:26:46 <Cale> But it's not possible to make those instances of Monad presently, you have to define your own additional class.
02:26:59 <Cale> (which sort of defeats much of the original purpose)
02:27:28 <fasta> Original purpose defeated. You win!
02:27:32 <Cale> For instance, if we could do that with Ord, then Set would be a monad.
02:28:04 <Cale> You can define an OrdMonad class, but unless you have some other OrdMonads, there's not much point in defining it.
02:28:05 <al> ahh success!... I see how the r gets carried through
02:28:11 <Cale> al: great :)
02:30:59 <al> I mean intuitively it works just like you described, but I wanted to substitute types in and do the substitutions to see
02:31:36 <al> okay... and I think on that small victory I can call it a night... almost 6am now and I need to wake up soon :-)
02:32:06 <Cale> hehe
02:32:12 <Cale> 'night
02:32:29 <al> thanks for all the help... you don't know how helpful this little tutorial is to me
02:33:27 <Cale> al: No problem :)
02:35:12 <al> I'll start going through some of these functions and just working out how bind/return work in the list and reader monads for now
02:35:20 <al> anyway thanks again, good night!
02:36:39 <Cale> :)
02:54:36 <araujo> morning
02:57:13 <dolio> @instances MonadWriter
02:57:14 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/399
02:57:17 <lambdabot> w (ErrorT e m), w (RWS r w s), w (RWST r w s m), w (ReaderT r m), w (StateT s m), w (Writer w), w (WriterT w m)
02:57:33 <dolio> @instances MonadReader
02:57:34 <lambdabot> r ((->) r), r (ErrorT e m), r (RWS r w s), r (RWST r w s m), r (Reader r), r (ReaderT r m), r (StateT s m), r (WriterT w m), r' (ContT r m)
02:57:47 <dolio> Is there no ContT instance for MonadWriter?
02:58:38 <dolio> Or, further, is there no way to make one that behaves as expected?
03:00:28 <quicksilver> hmm
03:00:37 <quicksilver> well ContT Writer will backtrack the output
03:00:47 <quicksilver> but off-hand I don't see why that means you can't write the instance...
03:01:01 <dolio> Well, you can write tell easily enough.
03:01:10 * quicksilver nods
03:01:26 <dolio> But I've been tying my brain in knots for quite some time trying to write pass and listen for the delimited continuation monad...
03:01:56 <dolio> And finally got the idea to look at ContT, but it's not there.
03:02:07 <quicksilver> oh, I see
03:02:11 <dolio> So maybe it's not just me.
03:02:17 <quicksilver> yes, perhaps you can't write those
03:02:26 <quicksilver> I'm not sure though
03:02:31 <quicksilver> ContT always breaks my head
03:04:30 <dons> quicksilver: `Abuse of the Continuation monad can produce code that is impossible to understand and maintain' :-)
03:04:31 <dolio> I guess I at least know what pass and tell do now.
03:04:34 <dons> http://www.haskell.org/all_about_monads/html/contmonad.html#overview
03:04:36 <lambdabot> Title: The Continuation monad, http://tinyurl.com/22j5jr
03:04:44 <dolio> Er, pass and listen.
03:04:52 <dolio> It wasn't what I would have guessed.
03:06:52 <DRMacIver> dons: Yeah, and it has many other advantages as well. ;)
03:07:40 <dmhouse> All About Monads didn't really help me with continuations much.
03:08:03 <dmhouse> _Continuations_ themselves are fairly easy to understand, but Cont is a weird beast.
03:08:31 <dmhouse> http://en.wikibooks.org/wiki/Haskell/Continuation_passing_style might help.
03:08:33 <lambdabot> Title: Haskell/Continuation passing style - Wikibooks, collection of open-content textb ...
03:08:42 <quicksilver> I don't think Cont in isolation is too bad
03:08:45 <quicksilver> but ContT is
03:08:57 <quicksilver> understand how continuations should layer with other computational effects, in general
03:09:12 <Vq^> to bad many of the examples used Cont :/
03:10:13 <dolio> It isn't that bad, is it? Generally, in Transformer Cont, Cont can undo actions in transformer, but in ContT M, ContT can't undo actions in M.
03:10:56 <dolio> And in T (ContT M), you can undo things in T, but not in M.
03:12:06 <Vq^> dolio: a simpler monad might have suited better for the early Transformer examples
03:12:53 <quicksilver> dolio: ah, I think I got it backwards
03:13:18 <quicksilver> dolio: although I still find the notion of a ContT that can 'only undo some things' counter intuitive
03:13:55 <dons> we desugared ContT back to functions in Data.Binary, and it got a fair bit clearer
03:16:42 <dolio> quicksilver: I suppose it is weird.
03:21:51 <pabloe> Am I right in thinking that do { x <- f; f; y <- f } is equivalent to saying do { x <- f; neverEverUsed <- f; y <- f } ?
03:22:15 <Cale> pabloe: yes
03:22:26 <pabloe> thanks
03:22:32 <oerjan> yep, except you cannot end a do with y <- f
03:23:31 <opqdonut> yeah, something must be returned
03:45:13 <crazy_coder> hello everyone
03:45:40 <oerjan> hi
03:46:57 <crazy_coder> haskell is so easy yet so powerfull. Haskell rules!!
03:47:22 <fasta> crazy_coder: you have a lot to learn
03:47:36 <dons> crazy_coder: ;-)
03:47:51 <crazy_coder> yeah.  I am in love with haskell :)
03:48:01 <DRMacIver> Haskell is, in a lot of respects, fairly easy.
03:48:03 <Igloo> dons: What's the status of the bytestring package?
03:48:13 <DRMacIver> It's also fairly hard in a lot of other respects. :)
03:48:19 <dons> Igloo, the one in darcs.haskell.org/bytestring, Igloo ?
03:48:19 <osfameron> DRMacIver: rarr!
03:48:37 <dons> Igloo: duncan is working atm on getting it into 1.0 state.
03:48:43 <dons> Igloo: when's 6.8 expected?
03:48:45 * DRMacIver rolls his eyes at osfameron 
03:48:50 <crazy_coder> by the way, what all 'cool' things have been implemented in Haskell ?
03:48:53 <Igloo> dons: Aha, so is it safe to rip bytestring out of base now?
03:49:00 <dons> Igloo: no! not yet.
03:49:05 <Igloo> OK  :-)
03:49:14 <dons> we really should release bytestring 0.9 -- then rip it out
03:49:22 <dons> and duncan's working exactly on that.
03:49:30 <dons> how long do we have till 6.8?
03:50:16 <Igloo> "We are aiming for the first 6.8 release candidate at the beginning of September, and the 6.8 release at the beginning of October."
03:50:32 <dons> ok. we're aiming for bytestring 1.0 for sept.
03:50:41 <dons> and a 0.9 + rip-out round August or earlier
03:50:55 <Igloo> Cool, thanks for the update!
03:51:21 <dons> no worries.
03:52:12 <crazy_coder> what is bytestring package ?
03:52:33 <dons> Data.ByteString, and its related string modules
03:52:50 <crazy_coder> downloads available ?
03:53:19 <dons> well, its in the base library currently, so you can just use it :-)
03:53:35 <crazy_coder> i guess i saw that in the standard things provided......
03:53:39 <crazy_coder> oh right
03:53:54 <crazy_coder> whats the .hs filename ?
03:54:15 <crazy_coder> I have to import it right ?
03:54:40 <dons> import Data.ByteString :-)
03:54:51 <crazy_coder> Thanks :)
03:56:29 <crazy_coder> So you guys are revising it ? adding new functions?
03:57:36 <dons> just making it faster :-)
03:58:13 <crazy_coder> Thats the *most* important thing ;)
03:58:40 <DRMacIver> I really need to read through the code for that.
03:58:47 <DRMacIver> Find which bits I want to steal. :)
04:00:01 <dons> hehe
04:00:09 <crazy_coder> and the *most* difficult part too
04:02:10 <vincenz> @logs
04:02:10 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/index.html
04:02:41 <robyonrails> does a pseudo rubyforge for Haskell exist ?
04:03:12 <crazy_coder> anybody used Xmonad ?
04:03:23 <dolio> @where hackage
04:03:23 <lambdabot> http://hackage.haskell.org/trac/hackage
04:04:19 <robyonrails> thx
04:23:03 <fasta> http://hackage.haskell.org/ModHackage/Hackage.hs?action=view -> Bug
04:33:46 <ndm> anyone know any python?
04:34:34 <vincenz> ndm: what's up?
04:34:58 <ndm> vincenz: "_darcs/foo.hs".contains("_darcs") should return true
04:35:06 <ndm> apart from its not contains, and i have no idea what it is
04:35:17 <malcolmw> ndm: there is a #python channel here...
04:35:48 <ndm> malcolmw: i guess they want people who are trying to learn Python, not people who want to get in and out of a 10,000 line build script with as little scarring as possible
04:36:05 <vincenz> ndm: generically
04:36:08 <vincenz> dir(objecT)
04:36:08 <araujo> "_darcs/foo.hs".startswith("_darcs")
04:36:10 <vincenz> gives you it's methods
04:36:18 <araujo> ndm, that one?
04:36:23 <ndm> vincenz: i have no idea how to even start Python
04:36:23 <vincenz> dir("foo")
04:36:30 <vincenz> ndm: 'python'
04:36:31 <araujo> ndm, type, python
04:36:36 <quicksilver> ndm: go on, I bet you can guess :P
04:36:45 <ndm> araujo: no, i want isInfixOf (i.e. not the start, or the end, but hte middle)
04:36:55 <vincenz> hm
04:36:59 <vincenz> there's a __contains__ method
04:37:00 <araujo> ndm, you are a haskell'er , everything is possible for you
04:37:02 <araujo> :-)
04:37:04 <vincenz> I wonder what operator that maps to
04:37:22 <araujo> ndm, that one returns True ... isn't that what you want?
04:37:37 <ndm> araujo: yes, but i want to find "_darcs" anywhere in that string
04:37:47 <araujo> ndm, i would use regexp there then
04:37:50 <ndm> i.e. "compiler/_darcs/foo.hs".startswith("_darcs")
04:38:10 <araujo> something like, '*_darcs*'
04:38:47 <ndm> ok, seems .find("_darcs") != -1
04:38:52 <vincenz> nod
04:38:53 <ndm> that does the trick, i think
04:39:26 <vincenz> what I wonder: why are you editting python code if you don't even know how to opn the interpreter o.O
04:40:10 <ndm> necessity
04:41:31 <ndm> the Yhc build system is in Python, and i'm currently maintaining it
04:41:34 <ndm> all 10,000 lines
04:41:38 <ndm> without knowing Python
04:41:47 <ndm> i expect the experience to be painful
04:42:22 <araujo> sounds cool ndm
04:42:47 <araujo> you don't need to know python to code on it :-P
04:55:04 <fasta> I don't like all the __<foo> in Python.
04:55:27 <edwardk> fasta: yeah
04:55:56 <edwardk> it was one of my major gripes when i was using it a lot too. felt crufty
04:56:29 <fasta> I find it really annoying too that I just cannot install most libghc6-* packages.
04:56:44 <fasta> They all depend on ghc < 6.6.1
04:56:46 <crazy_coder> what is the pre defined function user to convert a char to its ascii value ?
04:56:54 <quicksilver> crazy_coder: ord
04:57:05 <quicksilver> crazy_coder: not necessarily ascii, though
04:57:06 <mux> > map ord "hello"
04:57:07 <fasta> Although, I _know_ that the one I am interested in only requires a recompile
04:57:08 <lambdabot>  [104,101,108,108,111]
04:57:10 <crazy_coder> I am getting an error
04:57:12 <quicksilver> crazy_coder: unicode point
04:57:33 <crazy_coder> it says ord : out of scope
04:57:40 <crazy_coder> when I run it in ghci
04:57:46 <mauke> import Data.Char first
04:57:59 <crazy_coder> Oh
04:58:02 <crazy_coder> Thanks
04:59:00 <fasta> I only use the Queue from Edison, though.
05:05:15 <fasta> Ok, problem solved :) aptitude is smarter than I thought. Nice
05:06:33 <edwardk> hrmm why is edison not standard? or rather what is wrong with edison? i only see it mentioned in passing from time to time
05:09:29 <dolio> It had, until recently, been sitting around unmaintained for a while.
05:13:36 <Boney> @help
05:13:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
05:15:05 <fasta> Edison only has functional data structures, though.
05:15:32 <fasta> And I suspect most have little practical value.
05:16:06 <Boney> @hoogle (a -> b) -> (c -> b) -> Either a c -> b
05:16:06 <lambdabot> Prelude.either :: (a -> c) -> (b -> c) -> Either a b -> c
05:16:13 <Boney> hrm.
05:16:48 <vincenz> fasta: that's a rather strong statement
05:16:56 <vincenz> "little practical value"
05:18:24 <fasta> vincenz: we had that discussion a zillion times already
05:18:43 <vincenz> fasta: 'we'?
05:19:12 <fasta> vincenz: I think we, but it might have been quicksilver
05:19:16 <vincenz> no
05:19:18 <vincenz> not you and I
05:19:47 <fasta> vincenz: not about Edison in specific but funcional data structures in general
05:20:01 <vincenz> nope
05:20:19 <dolio> Edison does have more data structures than Okasaki's book, no? That's a lot of implementations of the same general things.
05:20:29 <dolio> Not that some might not be better at specific tasks than others.
05:20:58 <fasta> dolio: yes, but again, I wonder about the practical value, especially when one considers the existing base libraries.
05:21:36 <fasta> What does Edison offer that base doesn't?
05:22:05 <dolio> Priority queues?
05:22:16 <dolio> I guess Map might do that.
05:22:28 <fasta> dolio: Map does that
05:22:44 <fasta> dolio: and otherwise use the finger tree.
05:37:28 <ndm> malcolmw: can i just push straight to the compiler directory?
05:37:59 <ndm> i think i have Yhc building with NYHC
05:38:10 <malcolmw> ndm: should be able to - but only when you located in src/compiler
05:38:15 <malcolmw> yay!
05:38:30 <ndm> purely changes to Sconscript
05:39:02 * malcolmw hasn't got nhc98 to build with NYHC yet - problems with interpreting commandline flags
05:39:12 <ndm> i got it building, not working...
05:39:28 <ndm> you could just give up and rewrite it with Getopts as a common flag parser for both
05:40:41 <malcolmw> i'm pondering which route will be least painful - rewrite completely, revert to original, or try to fix as is
05:40:49 <ndm> rewrite completely
05:41:01 <ndm> thats usually the least painful way when working with a "mature" code base
05:42:35 <hhalvors> can someone recommend a script to generate colorized-html of a Haskell source file?  Thanks.
05:42:43 <ndm> @where hscolour
05:42:43 <lambdabot> http://www.cs.york.ac.uk/fp/darcs/hscolour/
05:42:48 <ndm> hhalvors: ^^^
05:43:12 <malcolmw> ndm: but GetOpt doesn't deal with options in the same way as the existing nyhc code
05:43:22 <hhalvors> ndm: many thanks! just what I needed.
05:43:36 <ndm> malcolmw: no, it deals with them in a standard and consistent manner which matches the rest of linux
05:43:40 <Igloo> malcolmw: I'd say that's a bug in one or the other. Having flags handled consistently is really useful
05:44:41 <SamB_XP> what? "new york haskell compiler"?
05:45:14 <ndm> SamB_XP: the combination of nhc and yhc, just a temporary name while we're hacking things together
05:45:38 <SamB_XP> how about {n,y}hc?
05:45:50 <ndm> malcolmw: /home/darcs/bin/commit-messages-split.sh: line 33: .current-hash: Permission denied
05:45:54 <SamB_XP> or even [ny]hc
05:45:56 <ndm> SamB_XP: snappy :)
05:47:35 <malcolmw> ndm: .current_hash fixed
05:47:58 <ndm> malcolmw: just testing the Yhc side out, i'll know in a few minutes if it can actually pass our regression tests
05:48:09 <ndm> malcolmw: perhaps next thing to unify is the regression tests?
05:48:30 <ndm> inst\bin\yhc.exe -core -cpp -c src\packages\yhc-base-1.0\Data\Ix.hs
05:48:32 <ndm> Error: File not found, NHC.Internal
05:48:40 <ndm> did you bake NHC.Internal into the compiler?
05:48:54 <edwardk> neil: btw- started applying a 'firstification' pass in my toy compiler. thought you'd be amused ;)
05:49:10 <ndm> edwardk: based on what firstification algorithm?
05:49:13 <ndm> (and why?)
05:49:18 <SamB_XP> edwardk: how many toys have you compiled?
05:49:36 <oerjan> and what is firstification?
05:49:45 <ndm> oerjan: removing higher order functions
05:49:58 <oerjan> ah.
05:50:09 <Igloo> ndm: What sort of regression tests do you have? i.e. are they compiler independent, or do they test nyhc-specific things?
05:50:10 <edwardk> neil: based on the passing comments in your powerpoint slides and a lot of elbow grease because i have weird things to deal with
05:50:29 <edwardk> neil: its still broken horribly, but its coming along
05:50:41 <ndm> Igloo: they are rather pathetic, a bit random, but mainly independent
05:50:58 <ndm> edwardk: cool :) - what are you doing about termination? thats something i skipped in my slides
05:50:58 <Igloo> Heh, OK
05:51:03 <malcolmw> ndm: there was a rpsInternal defined in TokenId.hs, which I reverted from "Yhc.Internal" to "Nhc.Internal", whilst introducing a new rpsInternalY
05:51:06 <Igloo> Something Should Be done
05:51:15 <ndm> indeed!
05:51:20 <ndm> does Hugs even have regression tests?
05:51:34 <ndm> perhaps you can combine it with Cabal, so that Cabal runs the tests in some way
05:51:45 <edwardk> neil: haven't got a good answer to that, your defunctionalization solution may be the best i can hope for, then use GRIN-style flow analysis to reduce the size of the application cases.
05:51:47 <ndm> that way they can be compiler independent at all levels
05:51:50 <Igloo> Droppings in the GHC testsuite show that hugs used it at one point, but I don't think it does today
05:52:06 <ndm> malcolmw: so are you going to fix that back?
05:52:12 <edwardk> neil: but i haven't got a good clue to give the compiler as to when to stop, it was something i was going to ask you about ;)
05:52:30 <ndm> edwardk: thats what i'm solving on Wednesday - ask me then :)
05:52:47 <edwardk> i do like the specialize/inline cycle. its very clean.
05:52:57 <malcolmw> ndm: oh yes, and qualImpNHC was previously "YHC.something", using rpsInternal, so that was the reason for making rpsInternal point to the nhc name
05:53:24 <ndm> malcolmw: yes, it's lovely :)
05:54:07 <edwardk> it is seeming like a huge win for polymorphic records/variants in particular, field accessors more or less vanish.
05:54:50 <ndm> neat :)
05:55:07 <ndm> edwardk: does your compiler do Haskell? or some other language? and if so how is it not Haskell?
05:55:59 <edwardk> neil: 'some other language'. basically its a kitchen-sink of undecidable or semi-decidable typing features glued together by a 'best-effort' approach to handling the corner cases.
05:56:07 <ndm> cool :)
05:56:38 <edwardk> neil: my favorite part is the subset typing. hrmm, going to break the cardinal rule and paste one line.
05:57:23 <matthew_-> right, so gimme some ways around the silly restriction that types be finite.
05:57:24 <edwardk> sorted: (by: Ord a) => [a] -> Bool;sorted [] = True;sorted [x] = True;sorted (x::xs) = x <=_by head xs && sorted xs;insert: (by: Ord a) => a -> (xs: [a]) -> (ys:[a]|sorted xs==>sorted ys) | x /=_by y ==> insert x (insert y ys) <~> insert y (insert x ys);insert x [] = [x];insert x yys@(y::ys) = if x <=_by y then x::yys else y::insert x ys;sort: (by: Ord a) => [a] -> (xs:[a]|sorted xs);sort [] = [];sort (x::xs) = insert x (sort xs)
05:57:36 <edwardk> er i kind of cheated, that should be a lot of lines ;)
05:57:52 <edwardk> thats basically a 'proof' of correctness for a sorting routine, ala dana xu's esc/haskell.
05:58:32 <edwardk> but using a predicate subtype syntax. f : { x : T | pre x } -> { y : S | post x y }
05:59:40 <ndm> edwardk: have you seen Catch?
05:59:42 <edwardk> since i allow dictionaries to be arbitrary polymorphic records, some times you have to use them by name, this also lets them be passed as named parameters, so sort and sortBy can be merged.
05:59:48 <edwardk> neil: yeah
06:00:32 <edwardk> neil: my 'termination checking' obsession is going down the near-concrete interpretation/terminator route at this time, and i'm using local unrolling to spot bad cases, not regular expressions.
06:00:59 <ndm> edwardk: i don't use regular expressions anymore - if you read the latest Catch draft paper i have an alternative mechanism
06:01:07 <fasta> Did someone ever reasoned about the complexity of code and providing a lower bound for n for smallcheck s.t. together they form a proof?
06:01:24 <ndm> fasta: no, but i think its possible
06:01:38 <fasta> I am fairly sure one should be able to do that, but it would require me some time to work out the details.
06:01:45 <edwardk> er actually i did read that, but there is still quite a difference of approach. i go through with abstract interpretation using the information accumulated in the form of those predicate subtypes.
06:01:59 <ndm> yes, there does look quite a difference
06:02:08 <fasta> ndm: isn't it related to coverage?
06:02:29 <fasta> ndm: if you use that new coverage tool and see that all paths are used, it's correct?
06:02:38 <ndm> fasta: i'd have said the case complexity depth - its not enough to cover every path
06:02:58 <edwardk> i'm currently trying to merge the abstract interpretation approach with the 'near-concrete' approach for handling recursion, that has the benefit of getting better knowledge of termination.
06:05:10 <fasta> ndm: it seems that in well engineered code that approach could actually be practical.
06:06:49 <edwardk> neil: other than that, hrmm, a language level facility for pickling codata by transcribing thunks themselves as opposed to values. it has to be in the meta-language because it has to have knowledge of the code and be able to persist it, and to faithfully reproduce pointer sharing, mostly because i want to be able to use a copy-collector to evacuate-and-load code from runtime system to runtime system to handle NUMA. record field updates are p
06:07:00 <malcolmw> ndm: I've pushed a patch that clones the entities in TokenId.hs - yhc gets the existing names, nhc98 gets new copies.
06:08:44 <edwardk> the predicates on the right hand side can make reference to compile time features without requiring their annotation in the types, so you can enforce uniqueness, etc constraints without having to always annotate them. i break haskell's lexical scoping rules. ghc already keeps type variables in scope and quantifies them if they aren't with the right flags, i just make this apply in general which disambiguates my syntax at the cost of really n
06:09:05 <edwardk> there are other things, but i've already spouted enough vaporware promises ;)
06:09:26 <edwardk> basically its a nice lab for me to play with features i always wanted, but never got to have
06:09:37 <SamB_XP> edwardk: record field updates are p ?
06:10:03 <edwardk> polymorphic? yeah
06:10:10 <edwardk> oh hah, one sec,
06:10:22 <SamB_XP> edwardk: so, you are going to support that shiny NUCA technology people have been thinking about?
06:10:23 <edwardk> " are polymorphic in uniqueness of reference so it can do in place updates where possible"
06:10:30 <edwardk> nuca?
06:10:35 <SamB_XP> I just made it up
06:10:38 <edwardk> hah
06:10:46 <SamB_XP> it stands for "non uniform CPU architecture"
06:11:25 <dukedave> Hey gang, I'm writing a little toy app using Vty and it's working fine when I compile it with ghc. But when I try to load the (main) .hs into hugs I get:   "Error while importing DLL" and a missing .so error.
06:11:32 <edwardk> well, right now i'm leaning towards marshalling thunks as whatever native assembly they get compiled to, but that said, you could marshal bytecode, and jit on the other end
06:11:36 <dukedave> Is there someway I can create the .so ?
06:11:50 <gwern> I have a ByteString question. is there a reason that Data.ByteString.Lazy.Char8 and Data.ByteString.Lazy don't seem to have all the same functions?
06:12:08 <edwardk> what i'm trying to figure out is a good way to express a 'quotient' of a pickle, to construct a pickle with known shared content.
06:12:09 <SamB_XP> gwern: which functions in particular?
06:12:19 <gwern> for example, Char8 has lines, unlines, and words but just ByteString.Lazy doesn't seem to have those functions
06:12:46 <SamB_XP> well, those only make sense if your string holds characters ;-)
06:12:46 <int-e> gwern: some functions like lines and words only make sense for sequences of characters, not for sequences of bytes.
06:13:02 <fasta> Do you use hasktags?
06:13:05 <Saizan_> gwern: they use the same ByteString type, what would be the use of .Char8 if it doesn't have something more?
06:13:06 <SamB_XP> plain ByteStrings hold bytes
06:13:22 <SamB_XP> Saizan_: they shouldn't!
06:13:54 <fasta> Needing to run it every now and then by hand is not as nice as having it always in sync.
06:13:59 <int-e> Saizan_: .Char8 uses Char, not Word8, in most functions, doesn't it?
06:14:59 <SamB_XP> dukedave: there is like some ffihugs or something isn't there?
06:14:59 <Saizan> int-e: ah, yes, also that, but i think of Word8 as cheap Chars
06:15:53 <edwardk> has anyone here played with chameleon?
06:16:06 <SamB> dukedave: read hugs(1)
06:16:33 <SamB> or did you already do that?
06:17:17 <int-e> Saizan: they really aren't (or shouldn't be) cheaper in the bytestring context.
06:17:57 <SamB> Saizan: .Char8 can only fit 8-bit Chars, too -- hence the name
06:18:00 <quicksilver> Bytestring.Char is just a Byte which automatically casts to Char when you use it
06:18:05 <quicksilver> in a sense
06:18:10 <quicksilver> it's just a type system wrapper
06:18:14 <quicksilver> same stuff underneath
06:18:24 <quicksilver> CompactString is 'real chars'
06:18:41 <gwern> Saizan: well, my understanding of Char8 was that it only supported certain bits and pieces of unicode and was somehow faster
06:18:52 <SamB> Prelude Data.ByteString.Char8> pack "\256"
06:18:52 <SamB> "\NUL"
06:18:57 <roconnor> I don't understand ``Compiler Proof of Referential Transparency''
06:19:02 <gwern> (something about truncating and only representing ISO whatever...)
06:19:03 <SamB> look, it just silently discards the upper bits!
06:19:03 <roconnor> http://japple.blogspot.com/2007/06/proof-of-referential-transparency.html
06:19:05 <lambdabot> Title: Everyone Else is Crazy: Compiler Proof of Referential Transparency, http://tinyurl.com/274vxu
06:19:22 <crazy_coder> reduce :: [Int] -> [Int]
06:19:24 <crazy_coder> reduce [x] = 1
06:19:26 <crazy_coder> reduce (x : xs) = 1 : (reduce xs)
06:19:27 <roconnor> What does he mean by haskell can't do memoization?
06:19:28 <crazy_coder> can I do something like this ?
06:19:38 <gwern> SamB: doesn't that mess up exotic strings and characters?
06:19:42 <TSC> crazy_coder: What's it supposed to do?
06:19:48 <SamB> gwern: ... no duh!
06:20:03 <crazy_coder> It is supposed to replace all elements in a list of integers by 1
06:20:04 <SamB> Char8 is a solution for ISO 8859 users
06:20:09 <SamB> or ASCII users
06:20:15 <TSC> The first line should be "reduce [x] = [1]
06:20:17 <daniel_larsson> crazy_coder: reduce [x] = [1]
06:20:22 <crazy_coder> But is it descructive programmiing
06:20:22 <gwern> I mean, surely those upper bits wouldn't be there if they weren't doing *something* useful
06:20:24 <crazy_coder> yeah
06:20:29 <crazy_coder> i realised that
06:20:33 <SamB> well, I suppose technically it only works for ISO 8859-1 and ASCII
06:20:39 <TSC> crazy_coder: Or, replace the whole thing with "map (const 1)" (:
06:20:48 <crazy_coder> I changed it but still getting an error
06:21:10 <oerjan> crazy_coder: or reduce [] = [] , even
06:21:23 <gwern> SamB: then that's not so good for me, since I'm running the relevant program on Wikipedia stuff which I would swear uses every character and language known to man
06:22:04 <SamB> gwern: well, I think wikipedia actually uses something near ASCII to *store* the text...
06:22:22 <crazy_coder> Why am I getting an error ?
06:22:25 <gwern> so I can't use Char8 since it will fail on those exotic stuff, and I can't use just plain lazy because y'all tell me it makes no sense to have words/lines/unlines operating on ByteString.Lazy but I need them... this is distinctly odd
06:22:34 <matthew_-> is there a type level transformation from direct recursion to fix ?
06:22:55 <SamB> quicksilver: what is this CompactString?
06:23:08 <oerjan> crazy_coder: what error?
06:23:18 <SamB> ack
06:23:25 <gwern> SamB: there's the percentage escpaing stuff for URLs, but not necessarily. interwiki links will apparently use the foreign characters
06:24:15 <SamB> gwern: what wikipedia stuff are you processing?
06:24:40 <gwern> samb: pages and links
06:25:38 <Saizan> gwern: even with "plain lazy" you have 8-bit at a time, you have to know the encoding and decode them yourself
06:26:22 <Saizan> @where compactstring
06:26:23 <lambdabot> http://twan.home.fmf.nl/compact-string/
06:26:54 <Saizan> SamB: ^^ strict bytestrings + encodings
06:27:07 <robyonrails> proofs aren't very clean to me, who explain them to me in 10 words?
06:27:27 <gwern> hmm. guess the interwikis are escaped after all: <a href="http://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B"></a>
06:28:09 <SamB> gwern: oh, so you're messing with the generated HTML?
06:28:40 <quicksilver> @where compactstring
06:28:41 <lambdabot> http://twan.home.fmf.nl/compact-string/
06:28:50 <quicksilver> SamB: UTF-8 layered over bytestring, I think
06:29:12 <SamB> fascinating
06:29:34 <SamB> it seems to support multiple encodings
06:31:31 <fasta> robyonrails: what proofs?
06:36:08 <osfameron> robyonrails: you mean the point of proofs?  (I sometimes wonder that)
06:39:37 <robyonrails> mmmh I think they're only function definitions
06:40:12 <robyonrails> what change is only the "logical background"
06:40:18 <SamB> hmm, CompactString is very confused about what newline convention it uses...
06:49:11 <ndm> malcolmw: still the same error
06:49:30 <edwardk> quicksilver: isn't the compactstring encoding a funny not-quite-utf8 thing?
06:49:49 <SamB> edwardk: it seems to support a number of encodings
06:49:52 <edwardk> ah
06:50:13 <SamB> which happens to include such a funny coding, which may have been the only encoding at one time...
06:50:55 <robyonrails> infixl 9 >.>
06:50:55 <robyonrails> what is?
06:50:59 <edwardk> ok, the docs online seem to indicate its the only one, which is what scared me off
06:51:25 <edwardk> i just skimmed through its Base which has an Encoding class. much happier now
06:51:40 <edwardk> now if it only had a lazy bytestring layer i'd use it ;)
06:59:52 <siti> if only it didn't have bugs when compiled with -O0 >:(
07:01:48 <edwardk> siti: ouch
07:01:55 <edwardk> siti: what happens then?
07:02:08 <siti> I have had both segfaults and stack overflows :S
07:02:24 <siti> probably a ghc bug, but still annoying
07:02:29 <edwardk> ok, thats off the list. i'm currently using one i ripped out of pugs.
07:02:30 <siti> because -O0 is really really slow
07:02:34 <matthew_-> how do you declare ! as a function?
07:02:53 <matthew_-> > let ! = +5 in ! 10
07:02:53 <lambdabot>  Parse error
07:02:55 <edwardk> (!) :: a -> b -> c ?
07:02:59 <matthew_-> ahh
07:03:00 <matthew_-> ta
07:03:01 <SamB> siti: ... but not whenyou compile with -O1?
07:03:10 <edwardk> > let (!) = (+5) in (!) 10
07:03:12 <lambdabot>  15
07:03:15 <matthew_-> thanks
07:03:20 <edwardk> but keep in mind its infix
07:03:23 <edwardk> by default anyways
07:03:24 <matthew_-> mmm.
07:03:31 <quicksilver> s/by default//
07:03:36 <matthew_-> bummer.
07:03:41 <quicksilver> you can't un-infix things :) Except by bracketing.
07:03:45 <edwardk> yeah
07:03:50 <matthew_-> silly language...
07:03:51 <siti> SamB: I get a segfault with -O0 that seems to be do with compact strings, a gdb back trace showed up a function in compact strings
07:03:57 <SamB> > let x ! y = foldr (^) 1 (replicate y x) in 4 ^ 5
07:03:58 <siti> -O1*
07:03:58 <lambdabot>  1024
07:03:58 <siti> oops
07:04:03 <dolio> > let (!) = (+5) in (10!)
07:04:05 <lambdabot>  15
07:04:17 <siti> and stack overflows on -O2 :S
07:04:18 <edwardk> by "by default" i meant parenthesizing the expression ;)
07:04:43 <matthew_-> all non-alpha functions are infix?
07:04:54 <SamB> matthew_-: uh huh
07:05:03 * matthew_- groans
07:05:14 <SamB> you would like to write (*) 4 5 ?
07:05:23 <SamB> * 4 5, even
07:05:30 <matthew_-> I would like to be able to define what I want to write
07:05:39 <matthew_-> not to have some arbitrary defaults coded in
07:05:43 <edwardk> > let (!) 0 = 1; (!) n = n * ((n-1)!) in (5!)
07:05:46 <lambdabot>  120
07:05:46 <SamB> it isn't very arbitrary!
07:05:48 <kpreid> note that it's a GHC extension that (!) can have a type with fewer than 2 arguments
07:06:05 <matthew_-> SamB: it's not for mathematical operators. It is for everything else
07:06:06 <edwardk> hah, postfix ! =)
07:06:32 <quicksilver> matthew_-: it is a simplifying decision
07:06:35 <dolio> Yeah, too bad it needs parentheses, too. :)
07:06:43 <edwardk> oh well
07:06:44 <quicksilver> matthew_-: parsing becomes independent of actual definitions in-scope
07:06:45 <SamB> matthew_-: alphanumeric identifiers are prefix, punctuation-based are infix.
07:06:47 <edwardk> can't have everything =)
07:06:50 <SamB> that isn't particularly arbitrary...
07:07:04 <quicksilver> matthew_-: otherwise you have to had feedback from your scope environments to your parser
07:07:15 <quicksilver> matthew_-: which leeads to some pretty hair error messages
07:07:20 <SamB> it's what people want at least 90% of the time...
07:07:25 <quicksilver> it is, of course, possible.
07:07:30 <matthew_-> ok, I appreciate that it makes parsing harder.
07:07:39 <quicksilver> it doesn't make parsing hard, per se
07:07:44 <quicksilver> the people who wrote GHC are not stupid :P
07:07:45 <SamB> parsing is hard enough as it is, with configurable precedence
07:07:47 <kpreid> http://www.haskell.org/ghc/docs/latest/html/users_guide/syntax-extns.html#postfix-operators
07:07:49 <lambdabot> Title: 7.3. Syntactic extensions, http://tinyurl.com/y6v6by
07:07:53 <quicksilver> it makes it hard to give sensible error messages
07:08:05 <SamB> also it makes parsing harder for *humans* if you can do crazy shit
07:08:08 <quicksilver> and it forces you to interleave the parser with something a bit higher level
07:08:26 <quicksilver> at worst you end up interleaving the parsing with the type checker
07:08:35 <edwardk> samb: i still think precedence should be set up before you parse anything that has configurable precedence, then you could just read the files in your dependency list til you run out if infix[rl] definitions and then parse
07:08:39 <SamB> (as it is, precedence has to be resolved outside the parser)
07:08:57 <matthew_-> SamB: mmmm. No, I totally disagree with that. If used in a confusing manner then yes, it will be confusing. But that's not much of a reason to prevent people from using it in a sane manner
07:08:59 <edwardk> then you don't need to build up those fairly large intermediate structures and shuffle things around once you know precedence
07:09:47 <edwardk> the arbitrary interleaving of infix[rl] with regular code is one of the stranger design decisions in haskell to me
07:10:22 <SamB> edwardk: well, usually you want to put it near the definition of the operator...
07:10:44 <quicksilver> edwardk: don't forget you can define local operators
07:10:52 <quicksilver> edwardk: and thus, there is a need for local infixities
07:11:16 <quicksilver> let (***) = ... ; infixl 4 (***) ; .... in ....
07:11:33 <SamB> ... I never knew you could do that!
07:11:43 <matthew_-> it is a strange beast though - it's not a function which seems really odd.
07:12:08 <SamB> mathrick: what's strange?
07:12:11 <SamB> er,
07:12:14 <SamB> matthew_-:
07:12:20 <matthew_-> infix[rl] isn't a function
07:12:31 <SamB> what's so strange about that?
07:12:38 <matthew_-> not much in Haskell isn't a function
07:12:44 <edwardk> samb: the other gripe i have is that we tie fixities to numbers, i'd much rather have fixities be tied to relative to other fixities, i.e. i want !@#* to be of lower fixity than $# or something, leaving other fixities undefined, thereby transforming operator precedence to a partial order.
07:12:51 <matthew_-> module declarations, import statements, that's about it
07:12:55 <edwardk> i realize thats the prolog heritage in the language
07:13:04 <matthew_-> and they appear in well defined parts of the file
07:13:06 <SamB> edwardk: it would be nice in some ways
07:13:21 <matthew_-> partial ordering
07:13:31 <matthew_-> could lead to ambiguity
07:13:36 <matthew_-> must be total ordering
07:13:54 <edwardk> matthew: if you have a cycle its equality, if you have inequality and lack of parenthesization its a parse error.
07:13:56 <SamB> but then we'd need to mention the module in which the operator we want to declare relative precedence with resides...
07:14:10 <edwardk> matthew: no ambiguity, i've used this trick for years.
07:14:18 <edwardk> samb: yeah
07:14:30 <nominolo> @seen syntaxninja
07:14:30 <lambdabot> I saw syntaxninja leaving #haskell, #darcs and #haskell-blah 4d 17h 28m 19s ago, and .
07:14:31 <matthew_-> edwardk: ok fair enough - I was thinking "out loud"!
07:14:42 <quicksilver> matthew_-: it's OK, you'd just give an error on ambiguity
07:14:49 <quicksilver> matthew_-: that might even be the desired effect
07:14:51 <edwardk> matthew: i used it in toy computer algebra systems because you wind up with so many operators when you open the door to unicode.
07:14:58 <fasta> edwardk: I agree with you on that point.
07:15:00 <quicksilver> matthew_-: it might mean "these two operators are not really supposed to be used together"
07:15:21 <edwardk> quicksilver: yeah in my case i did the first stage of parsing in the editor, so i could redflag ambiguous parses before you got very far
07:15:31 <edwardk> it worked as a good prompting mechanism forcing people to be explicit
07:15:35 <quicksilver> matthew_-: anyhow, it wouldn't be that hard to write a GHC extension or just a preprocessor for arbitrary infix + postfix
07:15:44 <quicksilver> matthew_-: and you could see whether or not people liked it :)
07:15:45 <SamB> so... what happens if you accidentally make a cycle x < y < z < x ?
07:15:45 <fasta> edwardk: although, in practice I don't find that I need more than 9 levels.
07:15:58 <edwardk> that way you aren't trying to remember the relative precedence of circle plus and disjoint-union =)
07:16:23 <edwardk> and if you know a relative precedence and want to use it, add the fixity declaration locally and all is well.
07:16:25 <SamB> personally, I follow the rule: if in doubt, parenthesize
07:16:45 <fasta> I bend the rules.
07:16:53 <SamB> well, usually
07:16:57 <edwardk> fasta: i find more power in the absence of a relation than in the expressiveness of a larger number of tiers.
07:17:17 <fasta> edwardk: absence?
07:17:42 <SamB> fasta: he *likes* it to be less cut and dry
07:17:45 <mauke> SamB: disallow recursion in infix declarations
07:17:54 <edwardk> i mean in my experience you get more careful code from adding the partialness to the order, not so much in opening its scope.
07:18:09 <SamB> because it makes people parenthesize
07:18:30 * fasta is confused
07:19:41 <SamB> fasta: with a partial order for precedence, when two operators have no relation between them, that forces parentheses to be used
07:20:03 <fasta> SamB: ok
07:20:11 <edwardk> fasta: all i meant was that by making the order partial, people have to code more carefully, you get more readable code as a result. i'll admit i haven't needed more than 9 levels of precedence yet, but it 'came for free' by building the ordering relation and computing its transitive closure.
07:20:15 <SamB> you can't get that with numeric precedence levels
07:20:33 <fasta> SamB: I see
07:22:18 * SamB wants the weather from last night...
07:23:27 <ndm> @tell malcolmw you missed PreImport, it uses tNHCInternal, but should use tYHCInternal (or however you are meaning it to work)
07:23:27 <lambdabot> Consider it noted.
07:28:06 <matthew_-> well here's one I wasn't expecting: it's easier to embed the syntax of an imperative language in haskell's types than it is to embed the syntax of a functional/equational language
07:28:24 <matthew_-> the main problem with the latter is that recursion tends to generate infinite types
07:28:25 <edwardk> matthew_-: heh
07:28:43 <MyCatVerbs> matthew_-: methought functional languages were difficult to implement anyway.
07:28:43 <matthew_-> whereas imperative, the loop body is handled explicitly
07:29:03 <matthew_-> MyCatVerbs: I don't disagree with that
07:29:16 <matthew_-> MyCatVerbs: everything's hard to do right ;-)
07:29:27 <MyCatVerbs> matthew_-: nahhhh.
07:29:35 <MyCatVerbs> matthew_-: difficult but worth it.
07:29:59 <MyCatVerbs> matthew_-: and TCL implementations aren't usually mindblowingly difficult. ;)
07:30:30 <MyCatVerbs> Though to make them *fast* might be awkward, so much damn string concatenation.
07:30:57 <matthew_-> the issue is that the relationship between a recursive function and its type: the type does not reflect the name of the function which makes it hard to try to catch the recursive call and prevent blowup of the type
07:31:03 * matthew_- needs a better kind system
07:39:31 <DRMacIver> MyCatVerbs: That's ok. Just use LazyByteStrings. :)
07:39:51 <DRMacIver> Ick. Now the naming convention has infected my brain.
07:39:55 * DRMacIver purges his mind with bleach
07:44:20 <byorgey> @seen ibid
07:44:20 <lambdabot> ibid is in #haskell. I last heard ibid speak 23h 4m 44s ago.
07:44:55 <glen_quagmire> haskell is typed lambda calculus?
07:46:19 <byorgey> glen_quagmire: more or less, although I'm sure someone more knowledgable could delineate some specific differences/distinctions.
07:46:52 <Eelis> glen_quagmire: it's one brand of typed lambda calculus, yes
07:47:01 <dolio> It's got plenty of sugar over it.
07:47:21 <sjanssen> mmm, sugared lambdas
07:47:23 <quicksilver> glen_quagmire: type lambda calculus + type classes
07:47:28 <glen_quagmire> i see. so it's not turing complete
07:47:38 <quicksilver> sure it is
07:47:47 <quicksilver> what makes you think lambda calculus isn't turing complete?
07:47:52 <swiert> It adds a general recursion operator making it turing complete.
07:47:59 <fasta> It's only a thesis... ;)
07:48:00 <quicksilver> ok, I see
07:48:02 <swiert> Simply typed lambda calculus isn't turing complete.
07:48:13 <quicksilver> yes, typed lambda calculus + recursion, yes :)
07:48:29 <roconnor> it also has full algebraic data types, which also makes it turing complete.
07:48:50 <roconnor> er
07:49:01 <roconnor> full recursive algebraic data types?
07:49:18 <roconnor> anyhow, the types are not just simple types.
07:50:26 <ndm> Igloo: DMR?
07:50:35 <ndm> Igloo: is that <curse> plus MR ?
07:52:03 <MyCatVerbs> DRMacIver: oooh, I like the sound of that.
07:52:11 <sjanssen> WTFMR :)
07:53:03 <Igloo> ndm: Dreaded
07:53:26 <DRMacIver> MyCatVerbs: String concatentation should be fast. It's just all these silly pure array based implementations kicking around that prevents it from being so.
07:53:27 <ndm> Igloo: i'm with you on all your rant signature, but is the rest of the world with you?
07:54:26 <MyCatVerbs> DRMacIver: jah, I see what you mean.
07:54:27 <Igloo> ndm: We could disappear anyone at HW who doesn't agree  :-)
07:54:50 <ndm> Igloo: sounds like a plan :) - couldn't you just block the emails of h' if they object?
07:54:59 <DRMacIver> MyCatVerbs: This is of course a subject currently rather close to my heart given my main non-work project right now. :)
07:55:07 <Igloo> heh
07:55:16 <ndm> I'll only be at HW if one of my papers gets accepted (hopefully)
07:55:26 <MyCatVerbs> DRMacIver: people shy away instinctively from list-y implementations because they have high constants for things like reading and writing, but for something like TCL most of the *actual* runtime might be being spent in strncat anyway.
07:55:36 <MyCatVerbs> hw?
07:55:40 <ndm> Haskell Workshop
07:55:50 <shapr> Good morning #haskell !
07:56:04 * Igloo isn't sure whether or not I will be yet
07:56:08 <roconnor> Good morning #shapr
07:56:10 <MyCatVerbs> shapr: CONTRADICTION IN TERMS!
07:56:11 * shapr cheers
07:56:16 <MyCatVerbs> shapr: I mean, uh, good afternoon.
07:56:26 <shapr> Greetings Mr Verbs Sir.
07:57:06 <DRMacIver> MyCatVerbs: There isn't an especially high constant for reading and writing given a sensible approach (sequences of random access buffers for example).
07:57:56 <byorgey> MyCatVerbs: TCL?
07:57:59 <shapr> @users
07:57:59 <lambdabot> Maximum users seen in #haskell: 334, currently: 330 (98.8%), active: 20 (6.1%)
07:58:33 <byorgey> so close!
08:02:25 <MyCatVerbs> byorgey: Tool Command Language.
08:03:24 <byorgey> MyCatVerbs: oh, ok, for some reason I thought you were talking about something other than the language.
08:05:25 <MyCatVerbs> byorgey: nahh, I rather like the idea of TCL, in a vaguely abstract way. Possibly one of the few languages more powerful than Lisp, what with uplevel and such.
08:06:00 <byorgey> hmm, I don't actually know anything about TCL.  I'm reading about it now on WP.
08:09:20 <mehrheit> @src [] join
08:09:20 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
08:09:52 <mauke> join = concat
08:10:53 <shapr> Is there a comparison of cabal and debian packages somewhere?
08:11:19 <LeCamarade> Cabal is better.
08:11:24 <LeCamarade> shapr: ^^
08:11:53 <LeCamarade> #r. As in, F#. C#. #r <-- shapr.
08:12:39 <Igloo> shapr: What sort of a comparison?
08:13:18 <shapr> Igloo: I was just wondering what tasks debs cover that cabs don't.
08:13:34 <SamB> cabs are that crazy ms thing
08:13:47 <byorgey> LeCamarade: wouldn't that be sharpr?
08:14:06 <SamB> they hold, what, INFs and DLLs and VXDs and maybe even CPLs and EXEs?
08:14:37 <shapr> SamB: That wasn't what I meant.
08:14:48 <Igloo> shapr: I'm not sure what you mean by "tasks"
08:14:48 <shapr> SamB: I mean debian packages and cabal archives.
08:15:04 <shapr> Igloo: Debs can install cron jobs, but cabal can't, right?
08:15:14 <mehrheit> debs are uninstallable
08:15:29 <Igloo> shapr: Well, Cabal can do anything as you can write arbitrary code in Setup.hs
08:15:31 <SamB> cabal doesn't do much yet
08:15:45 <Igloo> And debs can do anything because you can write arbitrary code in some shell scripts
08:15:55 <SamB> Igloo: ... that doesn't really help much if you don't have infrastructure for that code to use
08:16:07 <SamB> which Debian has, and Cabal lacks
08:16:18 <Igloo> We have all the infrastructure that's needed, although it has a few rough edges
08:16:19 <SamB> possibly because Cabal is not a *nix distro?
08:16:58 <Igloo> Although for debs there is a helper specially for installing cron jobs if that's what you mean
08:17:12 <Igloo> It's not part of dpkg (which is roughly the equivalent of Cabal), though
08:17:22 <SamB> well, say I wanted to install an SGML declaration and some DTDs. how would I do that with Setup.lhs?
08:17:27 <Igloo> (dh_installcron, part of debhelper)
08:18:03 <SamB> Igloo: but there is no equivalent for the policy manual...
08:18:13 <Igloo> I don't know how you do it at all, but presumably with some copyFile and perhaps raySystem commands
08:18:37 <SamB> how would you know where to install it? how would you add it to the main catalogs?
08:18:58 <Igloo> This conversation doesn't seem to be going anywhere useful
08:19:01 <LeCamarade> byorgey: let s = (#r) in (take 3 s) ++ (drop 4 s)
08:19:37 <mehrheit> > (#r)
08:19:38 <lambdabot>   Not in scope: `r'
08:20:07 <SamB> I'm trying to blow a hole in your "can do anything" argument
08:20:43 <LeCamarade> > let (#) = "sharp" in (take 3 (#)) ++ (drop 4 (#)) ++ "r"
08:20:44 <lambdabot>  "shapr"
08:20:51 <Igloo> Well then you're going to fail, because you can write arbitrary code. You can re-implement dpkg in Setup.hs should you so wish
08:21:25 <SamB> are you under the impression that what debian packages can do is determined by dpkg and dpkg alone?
08:21:35 <byorgey> > let (#) x = "sharp" ++ x in (take 3 (#r)) ++ (drop 4 (#r))
08:21:36 <lambdabot>   Not in scope: `r'
08:22:02 <byorgey> > let {(#) x = "sharp" ++ x ; r = "r" } in (take 3 (#r)) ++ (drop 4 (#r))
08:22:03 <lambdabot>      The section `(# r)' takes one argument,
08:22:04 <lambdabot>     but its type `[a]' has none
08:22:22 <Igloo> I'm working on the belief that shapr meant .deb's, rather than packages intended to go into the Debian distribution
08:22:28 <SamB> anyway, if you like "can do anything" arguments, I'll supply one for using C code...
08:22:34 <shapr> Igloo: That's correct.
08:22:48 <SamB> shapr: ... what other kind of .debs is there?
08:23:16 <shapr> SamB: My actual question was, is it better to chose cabal or debian format when creating custom Haskell packages just for me that will be installed on a debian system?
08:23:37 <SamB> shapr: why the either/or?
08:23:51 <Igloo> You want to end up with a deb so you can do things like uninstall it easily
08:24:08 <shapr> Igloo: In this case, I can assume that uninstallation is not a problem.
08:24:15 <Igloo> But the simplest way to get there might be to cabalise it and then follow a "packaging Cabal packages for Debian" procedure
08:24:51 <shapr> I think I'll try that.
08:25:04 <Igloo> There are other benefits too. If it was me I'd probably go the -> Cabal -> deb route
08:25:28 <SamB> another thing is that .debs are generally platform-specific whereas tarballs with .cabal files in them aren't
08:26:37 <shapr> That's a good point.
08:27:50 <SamB> ... of course, source tarballs with debian/ dirs aren't so platform-specific either...
08:28:24 <SamB> though the debian/ dirs tend to be useless for those not on a debian-based distro...
08:39:00 <dylan> one can make use of debian-dirs on gentoo systems. :)
08:41:44 <ihope> all :: (a -> Bool) -> Bool; some :: (a -> Bool) -> Bool
08:42:02 <ihope> I think those functions are ones we won't be seeing for a while.
08:42:35 <mauke> what the
08:43:38 <quicksilver> ihope: you can do all: (Enum a, Bounded a) => (a -> Bool) -> Bool for both, though
08:43:52 <ihope> That's true.
08:44:03 <ihope> That can also be inefficient...
08:44:15 <mauke> :t flip all [minBound .. maxBound]
08:44:17 <lambdabot> forall a. (Bounded a, Enum a) => (a -> Bool) -> Bool
08:45:06 <quicksilver> well, what else could you want it to mean though?
08:48:11 <SamB> dylan: oh?
08:49:39 <dylan> there's tools for making ebuilds build things in .deb files, at least
08:49:55 <SamB> dylan: for... CL programs? elisp? python? SGML entities (including declarations, DTDs, catalogs)?
08:51:04 <dylan> hmm?
08:53:26 <LeCamarade> ICFP '08 will be about program comprehension? Wow.
08:55:28 <byorgey> LeCamarade: huh?
08:56:08 <byorgey> LeCamarade: where did you see that?
08:58:28 <LeCamarade> Um ... check the planet.
08:58:40 <LeCamarade> planet.haskell.org
08:58:54 <DRMacIver> Hack the planet?
09:00:29 <byorgey> wasn't that post about ICPC, not ICFP?
09:00:32 <LeCamarade> http://blogs.msdn.com/ralflammel/archive/2007/06/25/program-comprehension-in-banff-and-amsterdam.aspx
09:00:34 <lambdabot> Title: Grammarware, Haskellware, XMLware : Program Comprehension in Banff and Amsterdam, http://tinyurl.com/248gmm
09:00:47 <byorgey> unless they're the same thing...?
09:01:16 <LeCamarade> I think it is SAD how we emphasise space/time complexity, and never comprehension complexity.
09:01:39 <LeCamarade> Nobody hacks in Lambda Calculus.
09:02:09 <byorgey> LeCamarade: true.  I think it's mostly a holdover from the Old Days, when time/space were at a premium and only a few, really smart people were writing code
09:02:12 <LeCamarade> Turing tarpits. Lisp should die, also, now that we have Haskell.
09:02:24 <JKnecht> Bite Ur Tongue
09:03:31 <shapr> LeCamarade: I agree, understanding complexity should be the most important measurement.
09:03:34 <osfameron> Lisp is more conceptually beautiful and fundermental
09:03:39 <osfameron> -r
09:04:02 <JKnecht> at least until the first production quality Haskell app appears.
09:04:21 <LeCamarade> shapr: It's why I don't do malloc/free languages anymore. I've relegated that to assembly's league. :o)
09:04:44 <sioraiocht> does anyone know if there are any haskell bindings to FFT libraries in C?
09:04:54 <LeCamarade> osfameron: I am not a parser. Balancing all those parens should be automated.
09:05:20 <LeCamarade> JKnecht: There is darcs, there is GHC.
09:05:37 <sioraiocht> LeCamarade: best, quote, ever
09:05:43 <JKnecht> GHC doesn't count and darcs isn't production quality.
09:06:06 <LeCamarade> JKnecht: If cvs(1) was production quality ... ;o)
09:06:30 <byorgey> LeCamarade: that's not really a good argument for not using Lisp, most editors balance parens for you anyway...
09:06:58 <LeCamarade> byorgey: How about not needing an editor to write fibonacci?
09:07:03 <|Steve|> LeCamarade: You'd be surprised. A guy in my office writes lambda calculus all the time.
09:07:25 <LeCamarade> Parens hurt my head. Even Ruby is a better Lisp, not just an acceptable one.
09:07:34 <LeCamarade> |Steve|: :oO
09:07:47 <|Steve|> He made a typed lambda calculus too.
09:08:09 <JKnecht> I thought Ruby was a pidgin of Smalltalk
09:08:40 <LeCamarade> |Steve|: I was supposed to make a typed lambda calculus ... but that project is burried somewhere in backup-2006.tar.gz ... :o)
09:09:26 <|Steve|> As I understand it, he wrote the interpreter in Java.
09:09:29 <|Steve|> I
09:09:34 <|Steve|> Er, I've never looked at it.
09:09:50 <byorgey> *shudder*
09:09:59 <LeCamarade> Ruby has all the things about Lisp that I loved, loved, loved about Lisp, yet with a lower comprehension complexity for just about any algorithm. :o)
09:10:12 <|Steve|> I have no interest in writing lambda calculus beyond \x.\y.x and \x.\y.y for true and false, respectively.
09:10:14 <fasta> JKnecht: I think there are several production quality apps, they just might not be open-source.
09:10:47 <JKnecht> fasta: but commercially sold?
09:10:47 <|Steve|> Production quality apps written in Haskell?
09:11:21 <fasta> JKnecht: Or with services included via the web, either way they make money
09:12:24 <osfameron> LeCamarade: but the same would be true of Perl.  And neither of them have the regular syntax of Lisp, which is about 90% of the pain and the joy of it (from the little that I udnerstand, admittedly..)
09:12:24 <shapr> I suspect that all of Galois, Aetion and BlueSpec have production quality Haskell applications. I suspect that Credit Suisse and a few others either have, or ar close to having production quality Haskell applications.
09:13:00 <shapr> JKnecht: Also, what about Linspire's use of Haskell to replace shell scripting in their linux distro?
09:13:22 <DRMacIver> I'm not convinced production quality is neccessary to replace shell scripts. ;)
09:13:23 <fasta> Is there any market or possibility for closed-source libraries in Haskell?
09:13:29 <JKnecht> shapr: I will take your word for it (seriously).
09:14:09 <LeCamarade> osfameron: Yeah. Too much choice is bad. We don't code in English. :o) But too little choice,  la Lisp, is just as bad.
09:14:29 <shapr> JKnecht: The big downside of closed source production apps is that you don't get much of the feedback that could be used to improve production use of Haskell, but that's why there's CUFP.
09:14:48 <fasta> Editing Lisp code is pretty pleasant, imho. I changed opinion in the last few years :)
09:15:09 <quicksilver> poor lisp code can be pretty awful
09:15:15 <JKnecht> well let's be clear that production quality definitely doesn't imply closed source. Proprietary doesn't even imply closed source.
09:15:15 <quicksilver> but I'm sure that's true of every language
09:15:32 <fasta> shapr: hmm, I don't agree with that.
09:15:36 <quicksilver> more strongly, closed source certainly fails to imply production quality :)
09:15:39 <osfameron> I *loved* the SLIME video, but even that won't convince me to learn meacs unless I really seriously start on lisp...
09:15:49 <fasta> shapr: I think lots of bugs are exposed even without showing source.
09:15:54 <vincenz> quicksilver: true, but closed sourcec also fails to imply poor quality
09:16:05 <quicksilver> osfameron: You don't decide to learn emacs. Emacs decides to learn you. All you can do is be ready.
09:16:07 <fasta> shapr: it's about feedback and that doesn't need soource.
09:16:13 <fasta> shapr: source*
09:16:48 <LeCamarade> fasta: I agree.
09:17:05 <osfameron> quicksilver: I'm going straight home to stock up on water and barricade the doors.  Thanks for the warning!
09:18:21 <LeCamarade> osfameron: Or ... vi! vi! vi! *runs off to #vi-protection*
09:18:51 <ndm> @seen malcolmw
09:18:52 <lambdabot> malcolmw is in #haskell-soc, #ghc, #haskell-overflow, #haskell-blah and #haskell. I last heard malcolmw speak 3h 11m 52s ago.
09:19:31 <shapr> fasta: Yeah, but feedback is less likely when the source can't be shared, when the whole application is under NDA, that sort of thing.
09:20:10 <fasta> shapr: There are some cases where feedback is more difficult
09:20:18 <fasta> shapr: there are ways to work around that, though.
09:20:39 <LeCamarade> shapr: I think the sharing of source only affects feedback if you're hacking for hackers. Hence why it works on Unix very well.
09:23:03 <osfameron> LeCamarade: yeah, vim in my case.  Thought it a) doesn't have a sane scripting language, and b) is underpowered compared to emacs
09:23:33 <|Steve|> By that you mean it doesn't directly control hardware and check e-mail?
09:23:57 <fasta> shapr: After some more experience with *Check, they indeed both work nicely :)
09:24:15 <MyCatVerbs> |Steve|: by which he means it's damn mediocre at best.
09:24:24 * sjanssen is tired of hearing "OCaml generates faster code"
09:24:26 <shapr> fasta: Yay!
09:24:54 * LoganCapaldo tempts fate
09:24:54 <sjanssen> I have the Haskell ray tracer (recently posted to the list) running faster than the OCaml version
09:24:55 <|Steve|> MyCatVerbs: I gave up on emacs some time ago. I got tired of waiting for it to launch.
09:24:56 <LeCamarade> osfameron: I never need too much of Emacs' alleged power. Usually, I just want to startup before the day is over. Hence vim. On scriptability, well ... that's true. Yi! Yi!
09:25:02 <LoganCapaldo> OCaml generates faster code!
09:25:02 <SamB> sjanssen: ... it does ... if you write faster code in ocaml
09:25:25 <mehrheit> osfameron, doesent vim have a few scripting backends (perl, python ruby)?
09:25:31 <CosmicRay> shapr: boing!
09:25:33 <shapr> fasta: Sure, there are ways to work around most any difficulty, but in general it's more difficult to get feedback from commercial apps.
09:25:38 <shapr> CosmicRay: hiya! How's code?
09:25:46 <CosmicRay> shapr: good, you?
09:25:48 <ndm> how fast is OCaml at word counting? I can get Haskell to C speed, I doubt OCaml can
09:26:08 <shapr> CosmicRay: The code is flowing.
09:26:11 <MyCatVerbs> SamB: I've heard it theorised that the actual reason for OCaML's speed reputation is that the only people who use it are cleverer than the average C hacker.
09:26:14 <LoganCapaldo> mehrheit: All the vim scripting backends as far as I can tell are mostly just ways of sending strings of vim commands to vim w/ your favorite programming language
09:26:16 <arcatan> the code is floating!
09:26:20 <MyCatVerbs> s/C/C++/
09:26:28 * shapr throws a floating point at arcatan 
09:26:30 <fasta> shapr: In my case, since I still haven't decided what I want to do with my stuff, I just take on the role of an obfuscator and reduce the size of the file that generates the compiler bug.
09:26:35 <CosmicRay> shapr: how very zen of you
09:26:37 <fasta> shapr: that should be automated, though.
09:26:47 <SamB> MyCatVerbs: I bet they also have more time to spend on tuning
09:27:02 <shapr> fasta: Yeah, I agree. Something like 'shrink' in QuickCheck2 for example.
09:27:15 <mehrheit> too bad I couldn't get Yi to compile
09:27:27 <MyCatVerbs> SamB: ahhh yes, that'll be the other bit, since they won't have spent as long writing the damn program in the first place.
09:27:56 <LeCamarade> Is there a numbers-to-words lib for Haskell?
09:27:58 <fasta> shapr: right
09:28:02 <SamB> also, it is easier to use a good algorithm
09:28:14 <DRMacIver> ndm: I seem to recall that the Haskell string implementation is a bit a) dumb and b) low level.
09:28:22 <LoganCapaldo> mehrheit: IOW if you can't do it w/o some horrible hack in vimscript, you can't do it w/o the same horrible hack in <other programming language>
09:28:24 <SamB> LeCamarade: american or correct?
09:28:35 <LeCamarade> SamB: :oD
09:28:43 <quicksilver> DRMacIver: the haskell string implementation is high level, not low level
09:28:51 <quicksilver> DRMacIver: but good fusion means that may not matter
09:28:51 <ndm> DRMacIver: nope, its a linked list of Char - its pure, neat and easy to work with - its slow in GHC, not slow
09:28:55 <osfameron> LeCamarade: yeah, but Vim a) installs and b) works, which are significant benefits of current Yi
09:28:57 <DRMacIver> Argh
09:28:58 <DRMacIver> Sorry
09:29:00 <DRMacIver> Brain hiccup.
09:29:06 <DRMacIver> I meant to say OCaml string implementation.
09:29:10 <quicksilver> ah
09:29:12 <osfameron> mehrheit: yeah, but the Perl one is horrible!  string eval! eeeeek!
09:29:14 <ndm> ah
09:29:19 <ndm> but i think it is quite fast
09:29:22 * osfameron runs off home
09:29:23 <DRMacIver> Yeah, it's fast.
09:29:38 <DRMacIver> But isn't it fast because it's basically just a (mutable) array of characters? :)
09:29:52 <LeCamarade> The OCaml string feels like a wooden knife. This coming from an OCaml fan-a-tic.
09:30:43 <sjanssen> ndm: it can be fast on occasion
09:30:53 <DRMacIver> So I guess what I mean is that given OCaml's tendency to generate good low level code, I suspect OCaml word counting will compile to something very similar to C word counting.
09:31:01 <sjanssen> [Char] is always going to be slow if you keep megabyte or larger strings in memory
09:31:07 <ndm> sjanssen: String's in GHC? only if you generate them with build and consume them with foldr :)
09:31:24 <sjanssen> (persistently, not lazily)
09:31:45 <fasta> Why can't list have better cache behaviour?
09:31:52 <fasta> lists*
09:32:04 <DRMacIver> How do you mean?
09:32:04 <SamB> sjanssen: true
09:32:16 <SamB> DRMacIver: fusion doesn't work on persistant data...
09:32:21 <sjanssen> ndm: large [Char] (persistent, not lazily consumed and thrown away( is fundamentally slow, unless your compiler can turn it into an array
09:32:22 <fasta> I'd say that allocations should happen near each other, s.t. mapping over one has perfect cache behaviour.
09:32:50 <SamB> sjanssen: hmm, GHC could only turn that into an array under very limited circumstances...
09:32:56 <fasta> sjanssen: why do you qualify it as persistent?
09:33:06 <fasta> sjanssen: all data structures are persistent in H98
09:33:13 <sjanssen> fasta: because lazily consuming [Char] is acceptably fast
09:33:17 <SamB> fasta: he means in terms of how it is used
09:33:18 <sjanssen> fasta: I mean kept in memory
09:33:24 <fasta> sjanssen: ok
09:33:35 <DRMacIver> SamB: I'm not sure what that's in response to.
09:33:49 <LeCamarade> ndm was working on stuff like that, no?
09:34:04 <SamB> DRMacIver: sjanssen was talking about a compiler turning a persistant [Char] into an array...
09:34:05 <sjanssen> ie. fmap length (readFile "foo") is fast, but fmap (\x -> (x, length x)) (readFile "foo") is slow
09:34:19 <quicksilver> fasta: well the optimisation that most people aim for is eliminating the list entirely
09:34:21 <fasta> I think reducing memory requirements for functional languages in more important than raw speed, though.
09:34:27 <ndm> LeCamarade: i remove non-persistent lists, i don't do anything to persistent ones (apart from avoid them)
09:34:29 <DRMacIver> SamB: "How do you mean?" was directed at fasta's comment about cache behaviour.
09:34:32 <quicksilver> fasta: but yes, I agree that failing that, locality would be nice
09:34:32 <SamB> basically the only way that would happen is if you have a string literal that you use once...
09:34:46 <SamB> DRMacIver: oh, that "fusion" thing
09:34:50 <apfelmus> fasta: don't worry about the cache. when Haskell has taken over the world, hardware will become appropriate
09:35:04 <SamB> DRMacIver: ah, I see what you mean
09:35:11 <LeCamarade> apfelmus: I hope you know how right you are.
09:35:30 <apfelmus> well, it has already taken over myself :)
09:35:38 <fasta> apfelmus: oh, well, I just want Haskell to be acceptably fast. I didn't ever write a benchmark to compare against a C version.
09:35:51 <SamB> apfelmus: ... what's wrong with the cache now?
09:36:13 <apfelmus> absolutely nothing if you wait for Haskell World Domination Day :)
09:36:19 <LeCamarade> apfelmus: Even though I get flamed often for suggesting that it is not really as important as we pretend to worry about whether or not we run well on today's hardware. Especially memory.
09:36:26 <SamB> apfelmus: but *now* what's wrong with it?
09:37:06 <apfelmus> SamB: the cache doesn't like linked lists too much
09:37:18 <apfelmus> but i guess it's more a size problem
09:37:26 <apfelmus> how many bytes per Cons-cell?
09:37:33 <SamB> apfelmus: that's because they tend to be big, and do not necessarily have good locality of reference
09:37:38 <SamB> hmm...
09:37:47 <apfelmus> yes
09:37:51 <mehrheit> apfelmus, when haskell takes over the world the IO (also known as RealWorld) monad will be unneeded, since imperative reality will be deprecated in favor of a pure-functional one
09:37:52 <fasta> Wow, this is annoying. My machine has stalls.
09:37:56 <SamB> for the cons cell, I think it's 3 words
09:37:59 <fasta> Damn, nvidia.
09:38:02 <apfelmus> mehrheit: yup :)
09:38:08 <SamB> 4 in later generations
09:39:00 <fasta> apfelmus: you are joking?
09:39:26 <apfelmus> fasta: that IO's going to die by the hands of Haskell?
09:39:42 <fasta> apfelmus: The IO monad will never die.
09:39:58 <edwardk> fasta: a pity
09:40:00 <arcatan> tomorrow never dies
09:40:00 <LeCamarade> Now you've warned it! X-(
09:40:08 <vincenz> LeCamarade: bonjour
09:40:13 <SamB> fasta: ... not even if we cut it up into little tiny pieces?
09:40:15 <apfelmus> fasta: ok, a situation as in the MATRIX would be fine, too. Without Neo's causing distress, that is
09:40:25 <LeCamarade> vincenz: Ah!
09:40:28 <fasta> SamB: oh, that might be
09:40:35 <fasta> apfelmus: getting random numbers from a hardware number generator will always involve IO.
09:40:42 <LeCamarade> Bonjour, vincenz!
09:40:42 <SamB> the trouble is we have no clue where to cut...
09:40:42 <edwardk> samb: nah coz they'll still stitch it back up and show it to newbies ;)
09:41:09 <edwardk> fasta: well, you can get a seed, and go from there
09:41:35 <apfelmus> fasta: no. it produces an infinite list of random numbers :)
09:41:36 <edwardk> samb: carving out thread local references into ST was a nice start
09:41:56 <MyCatVerbs> edwardk: *random* numbers, not pseudo random. Hence the hardware.
09:41:58 <edwardk> er rather logically thread local
09:42:00 <mehrheit> http://imgs.xkcd.com/comics/random_number.png
09:42:12 <vincenz> 4
09:42:23 <edwardk> MyCatVerbs: even those are technically pseudorandom ;)
09:42:36 <fasta> edwardk: ?
09:43:07 <glen_quagmire> it's easy to make random number
09:43:08 <fasta> edwardk: Isn't that an open philosophical question?
09:43:19 <glen_quagmire> just set each bit randomly
09:43:37 <edwardk> fasta: possibly, just going by the interpretation i originally learned
09:43:39 <|Steve|> glen_quagmire: And how do you get the random bits?
09:43:42 <fasta> glen_quagmire: can I have the same drugs you are having?
09:44:15 <mehrheit> glen_quagmire, that is a recursive definition without end cases
09:44:25 <glen_quagmire> you write a function get_random_bit and tell your employee to implement it
09:44:55 * fasta declares glen_quagmire a troll
09:45:06 <glen_quagmire> i heard nasa.gov or something provides public random number generator stuff
09:45:29 <apfelmus> it's probably CIA-controlled
09:45:43 <fasta> glen_quagmire: if you need random numbers you are not going to depend on some 3rd party
09:45:44 <mehrheit> it probably logs the requests for random numbers
09:46:08 <glen_quagmire> isn't merssin twister good enough?
09:46:16 <ddarius> fasta: Why not?
09:46:36 <mehrheit> @users
09:46:36 <lambdabot> Maximum users seen in #haskell: 336, currently: 336 (100.0%), active: 24 (7.1%)
09:46:41 <mehrheit> yay
09:46:46 <|Steve|> glen_quagmire: Probably yes, but it's not random.
09:46:52 <fasta> ddarius: if you need them, and you cannot trust the source then it's pointless.
09:46:53 <ddarius> random.org
09:46:59 <LeCamarade> mehrheit: Oh! Max!
09:47:11 <ddarius> fasta: There are various use cases where trust is not required.
09:47:34 <fasta> ddarius: tell me one
09:47:42 <ddarius> Monte Carlo simulation
09:48:01 <fasta> ddarius: they could manipulate your research
09:48:47 <ddarius> fasta: To what end? and who cares that much (on either side)?
09:49:10 <ddarius> And you can apply tests to the data to evaluate it's randomness.
09:49:23 <fasta> ddarius: this is of course somewhat theoretical, but I said "if you _need_ them".
09:50:20 <crazy_coder> can anyone pls give me a hint on this one -
09:50:31 <oerjan> i am sure you could do some post-processing to remove any reasonable bias anyone had put into the source?
09:50:34 <fasta> crazy_coder: pls is not a word
09:50:46 <|Steve|> Good hint!
09:51:02 <crazy_coder> I want to write a function  f i l t e r F i r s t p x s which removes the first element of x s which does not have
09:51:03 <crazy_coder> the property p
09:51:28 <fasta> crazy_coder: you make my eyes hurt
09:51:54 <crazy_coder> The problem is that if I use a condition all elements that don't satisfy  the condition are removed
09:52:10 <crazy_coder> its filterFirst p xs
09:52:18 <mehrheit> > let r (x:' ':xs) = x:(r xs) in r "f i l t e r F i r s t "
09:52:19 <crazy_coder> i copy pasted it
09:52:20 <lambdabot>   Non-exhaustive patterns in function r
09:52:23 <ndm> crazy_coder: you mean you only want the first one removed?
09:52:32 <crazy_coder> yes
09:52:35 <oerjan> filterFirst p x s = case span p s of (f, r) -> f ++ drop 1 r
09:53:00 <oerjan> er maybe that was a bit much of a hint
09:53:05 <crazy_coder> x and s are not different
09:53:07 <crazy_coder> xs
09:53:27 <glen_quagmire> map Char.toUpper "Hello World"   works.     map(Char.toUpper, "Hello World") no works
09:53:46 * sjanssen sends his "OCaml is fast"-fallacy smashing email
09:53:50 <crazy_coder> btw I want to implement it without using built in functions
09:53:54 <oerjan> well then at least you have a little to do :)
09:53:59 <ddarius> glen_quagmire: ?
09:53:59 <ndm> sjanssen: to where?
09:54:03 <crazy_coder> I want to do it using recursion
09:54:04 <sjanssen> ndm: haskell-cafe
09:54:09 <glen_quagmire> how can I pass 2 arguments to a function?
09:54:25 <oerjan> glen_quagmire: use uncurry
09:54:28 <crazy_coder> func a b :)
09:54:32 <ibid> byorgey: ?
09:54:39 <sjanssen> moving a flag from the command line to an OPTIONS_GHC pragma takes a program from 60s to 20s :)
09:54:40 <|Steve|> > let f x y = x + y in f 5 4
09:54:42 <lambdabot>  9
09:54:47 <ddarius> glen_quagmire: It could be argued that you can't.
09:54:53 <DRMacIver> :t ($) . ($)
09:54:55 <ndm> @karma+ sjanssen
09:54:55 <lambdabot> sjanssen's karma raised to 50.
09:54:56 <lambdabot> forall a b. (a -> b) -> a -> b
09:55:01 <DRMacIver> Hm
09:55:02 <byorgey> ibid: hi there, I was just wondering if you'd gotten my request to be added to planet haskell
09:55:04 <ddarius> glen_quagmire: Simply because there are no multiargument functions in Haskell.
09:55:07 <byorgey> ibid: no rush though =)
09:55:22 <glen_quagmire> ddarius: oh. didn't know that
09:55:25 <mehrheit> :t ( . ) ( . )
09:55:27 <lambdabot> forall b c a a1. (a1 -> b -> c) -> a1 -> (a -> b) -> a -> c
09:55:54 <crazy_coder> does $$ mean previous evaluated expression ?
09:56:20 <glen_quagmire> then what is :  map func list ? is it doing uncurring automatically?
09:56:30 <oerjan> crazy_coder: well then i would do something like filterFirst p [] = ... ; filterFirst p (x:r) | p x = ... | otherwise = ...
09:56:34 <sieni> @pl  \x (y,z) -> x y z
09:56:35 <lambdabot> (`ap` snd) . (. fst)
09:57:07 <DRMacIver> glen_quagmire: It's (map func) list. (map func) evaluates to a function which is being applied to list.
09:57:19 <crazy_coder> oerjan: my basic framework is exactly the same, but I am missing something. Anyways I will think about it
09:57:27 <glen_quagmire> DRMacIver: thank you
09:57:47 <mehrheit> why is bottom written _|_ in tutorials?
09:58:02 <byorgey> mehrheit: as opposed to what?
09:58:04 <crazy_coder> oerjan: but the problem is | p x = ....... removes all elements not satisfying the condition
09:58:20 <mehrheit> byorgey, I don't know, but _|_ is not valid haskell
09:58:39 <crazy_coder> oerjan: somehow in the recursion , I want  to tell it to do it exactly once
09:58:41 <oerjan> crazy_coder: you _don't_ want to recurse in that branch.
09:58:50 <crazy_coder> oh
09:58:53 <crazy_coder> wait a sec
09:58:56 <crazy_coder> let me thinks
09:58:58 <ihope> mehrheit: well, there are multiple values that are bottom.
09:58:59 <Vulpyne> Bottom should be signified by whatever ascii art looks closest to a butt.
09:59:01 <crazy_coder> *think
09:59:02 <ihope> Not just one.
09:59:14 <oerjan> i mean, the other one.
09:59:16 <fasta> mehrheit: probably because they tell you it denotes undefined
09:59:20 <ihope> No, bottom should be signified by whatever ASCII looks closest to an up tack. :-P
09:59:31 <fasta> mehrheit: and if they don't the tutorial has a bug.
09:59:44 <Vulpyne> My vote is ((Y))
09:59:46 <fasta> mehrheit: in which case you will report the bug now
10:00:13 <byorgey> mehrheit: more generally, when people write about Haskell they tend to use symbols that have to be translated back into Haskell.  it's sort of an affectation of the academic community... =)
10:00:25 <fasta> _____|_____ <- average American bottom :)
10:00:31 <ihope> :-)
10:00:33 <byorgey> lol
10:01:10 <vincenz> fasta: you mean
10:01:12 <ihope> "The bottom type in type theory is a type that has no values. It is commonly abbreviated as bot, by the up tack symbol () or by its ASCII approximation _|_." http://en.wikipedia.org/wiki/Bottom_type
10:01:14 <lambdabot> Title: Bottom type - Wikipedia, the free encyclopedia
10:01:14 <mdmkolbe|work> mehrheit: the symbol _|_ is a mathematical symbol for bottom.  Just like some tutorials change "->" to be a single character arrow, some will change "undefined" to _|_.  I could give you more info on the math symbol if you want it.
10:01:14 <vincenz> [_________|___________]
10:01:19 <vincenz> iso (____|____)
10:01:20 <crazy_coder> oerjan: yeah thanks dude. I got the idea and it works exactly as I want it to . You rock
10:01:26 <vincenz> notice square brackets
10:01:36 <ihope> repeat '_' ++ "|" ++ repeat '_'?
10:01:41 <mehrheit> mdmkolbe|work, thank you, that clears it up
10:01:44 <vincenz> ihope: don't foget squareness
10:01:48 <mehrheit> ihope, i wanted to write that
10:02:05 <ihope> Really, this'll do: '[' ++ repeat '_'
10:02:11 <ihope> Er, :, not ++
10:02:15 <vincenz> :
10:02:34 <Vulpyne> You can make those pretty symbols appear in emacs: http://www.emacswiki.org/cgi-bin/wiki/PrettyLambda
10:02:36 <lambdabot> Title: EmacsWiki: PrettyLambda
10:02:54 * ihope kicks lambdabot for making the link move out of the way
10:03:08 <ibid> byorgey: yes, i have
10:03:12 <vincenz> I hear you can clean your toilet with emacs
10:03:21 <mehrheit> ihope, beating girls is bad
10:03:26 <Vulpyne> It also makes a mean cup of coffee.
10:03:39 <ihope> (in a heavily armored place)
10:03:39 <Vulpyne> Hopefully not related to the toilet cleaning function.
10:03:41 <DRMacIver>  Hopefully not at the same time.
10:03:42 <vincenz> vim :: Coffee -> IO Code
10:03:45 <ibid> byorgey: you'll note it was just one of the Big holidays (juhannus) here in finland :)
10:04:02 <ihope> vincenz: I thought type Code = IO ()
10:04:10 <ihope> Or something.
10:04:16 <ihope> IO (IO ()), then? :-)
10:04:25 <LeCamarade> Yeah, emacs can do all those funky things. We'll prove it when it starts up.
10:04:29 <oerjan> crazy_coder: :)
10:04:37 <vincenz> fixM $ hammer "ihope"
10:04:50 <Vulpyne> My current copy of emacs has probably been running about a month now. :)
10:05:06 <vincenz> my computer's uptime is not even 1 day
10:05:06 <mehrheit> LeCamarade, the halting problem for turing machines has an analogy for emacs
10:05:09 <mehrheit> the starting problem
10:05:09 <LeCamarade> Vulpyne: You don't want to reboot, eh?
10:05:14 <vincenz> then again, I move my laptop back-fro work
10:05:27 <Vulpyne> LeCamarade: I don't like to.
10:05:27 <vincenz> mehrheit: or the quitting problem :)
10:05:37 <Vulpyne> I run it on a server that I VNC to, so it doesn't get rebooted ofhen.
10:05:40 <Vulpyne> Often.
10:05:49 <vincenz> why vnc and not ssh?
10:05:55 <Saizan> there's a simple solution to the starting problem, never close emacs.
10:06:03 <vincenz> Saizan: so it has infinite time to start?
10:06:07 <Vulpyne> Because I can detach and go home and have all my windows open when I arrive at work the next day.
10:06:39 <fasta> Vulpyne: it's a waste of energy, though.
10:07:01 <Saizan> Vulpyne: screen
10:07:11 <Vulpyne> Saizan: VNC = screen for GUI apps.
10:07:14 <mdmkolbe|work> fasta: actually it's less energy for the user.  When I go home, I don't have to think about what files to save
10:07:36 <fasta> Smalltalk actually has this notion of persistence built-in.
10:07:58 <Vulpyne> It's a server in a datacenter anyway, not really feasable to turn it on and off every day.
10:08:15 <Vulpyne> But I wouldn't even if I could, because opening up 10 windows and sshing to a bunch of machines every day would be horrible.
10:08:17 <ihope> Well, you have to start emacs in the first place.
10:08:28 <fasta> Vulpyne: you work on a server? Do you use a GUI or everything via ssh?
10:08:42 <Vulpyne> fasta: I run Xvnc on the server.
10:08:57 <Vulpyne> And then a bunch of xterms (and I use screen in quite a few of them also)
10:09:01 <fasta> Vulpyne: how far are you away and how slow is it and what connection speed?
10:09:02 <Vulpyne> Bunch of emacs windows also.
10:09:14 <mehrheit> what is m17n?
10:09:23 * LeCamarade sticks to vi.
10:09:25 <Vulpyne> fasta: It's very fast most of the time. I'm not completely sure where the server is, it's either in the same building or the same city. :)
10:09:31 <mehrheit> (in analogy to l10n and i18n)
10:09:40 <fasta> Vulpyne: do you notice the delay?
10:09:49 <Vulpyne> fasta: Not when the network is functioning properly.
10:10:15 <ihope> Emacs has some chance of starting, and if it does start at all, it will require some amount of CPU time. The chance of starting might be extremely small, and the amount of CPU time might be extremely large. Therefore, we must give an infinite amount of CPU time to each of an infinite number of emacs processes.
10:10:22 <Vulpyne> My pings to it are 0.035ms. :)
10:10:45 <Vulpyne> You only need one emacs process. :)
10:10:57 <ihope> What if that's a process that'll never start?
10:11:04 <fasta> Vulpyne: I tried xvncviewer at home, but I couldn't stand the delays.
10:11:06 <Vulpyne> Then I would be sad.
10:11:19 <fasta> Vulpyne: isn't that the same software?
10:11:29 <Vulpyne> fasta: Probably.
10:11:35 <Vulpyne> fasta: Was it on the local network?
10:11:36 <fasta> Vulpyne: that was too a Windows machine, though.
10:11:39 <ihope> Start an emacs process. Wait for every emacs process to receive a certain amount of CPU time. Repeat.
10:11:40 <fasta> Vulpyne: yes
10:11:46 <fasta> Vulpyne: to*
10:11:56 <Vulpyne> fasta: Ohh, that's different. Xvnc is an X server that can export its display across VNC.
10:12:07 <ihope> ("A certain amount" must not go below some non-zero constant.)
10:12:12 <Vulpyne> fasta: When snooping a Windows machine, VNC has to do inefficient stuff like taking snapshots of the screen.
10:12:18 <fasta> Vulpyne: it is implemented in a sane way probably.
10:12:26 <fasta> Vulpyne: xvnc, I mean.
10:12:28 <Vulpyne> Yeah.
10:12:32 <slowriot> I want a fast way to locate which file a function is defined in. Is there some standard way to do this, or do I just have to write a program that searches for all function definitions in my source files?
10:12:45 <ihope> Eventually, an emacs process will finish starting. You may kill all the others.
10:13:00 <mdmkolbe|work> slowriot: there's "grep" and if on emacs or vi theres "TAGS"
10:13:06 <Vulpyne> fasta: Try it with Xvnc. The only latency you'll have will be based on your internet connection.
10:13:06 <mehrheit> grep -er '^function .* =' .
10:13:11 <mehrheit> , slowriot
10:13:15 <fasta> "X" is just a really nice concept.
10:13:20 <Vulpyne> And it's really very convenient to attach/detach a desktop.
10:14:12 <fasta> Vulpyne: is xvnc free software?
10:14:28 <Vulpyne> fasta: Open source, I believe.
10:15:08 <fasta> Vulpyne: I think I found the package.
10:15:13 <fasta> Vulpyne: thanks
10:15:33 <Vulpyne> No problem.
10:15:36 <dukedave> slowriot: if you've got hugs set up properly you can just do ":f myFunc" and it'll open the containing source at line number in your chosen editor..
10:16:18 <slowriot> dukedave: that sounds convenient. I'm just using ghci at the moment.
10:16:24 <byorgey> ibid: ah, I didn't know that.  After looking it up on WP I see that expressing a hope that it was much fun is appropriate. ;-)
10:16:36 <fasta> Vulpyne: it doesn't have an exploit every month, I hope?
10:17:52 <dukedave> slowriot: Yeah I've just ended up using hugs because that's what I used whilst learning the language so it's kind of integral to my Haskell development style now; but sometimes I get annoyed it's not ghci..
10:17:55 <mdmkolbe|work> fasta: only as many exploits as ssh has.  (you tunnel vnc over ssh and run as your own user's process if you care about security)
10:19:08 <ibid> byorgey: it was fun enough :)
10:19:30 <byorgey> ibid: glad to hear it.
10:19:41 <Vulpyne> fasta: Not that I've heard of. But you can make it only accept connections from local host and connect to the server via a SSH tunnel (which is what I do.)
10:21:28 * shapr boings cheerfully
10:21:54 * Vulpyne waves at shapr.
10:24:01 * shapr waves at Vulpyne 
10:24:04 <shapr> Vulpyne: How's code?
10:25:09 <Vulpyne> My little project ran over the weekend. :)
10:25:20 <Vulpyne> How's yours?
10:28:22 <shapr> Vulpyne: My work code is flowing, and I hacked a bit of fun code recently trying to simulate MtG. It's difficult, but fun to figure out how to represent MtG in Haskell.
10:28:57 <DRMacIver> MtG?
10:29:07 <Vulpyne> Magic: The Gathering.
10:29:13 <edwardk> magic the gathering? heh
10:29:31 <DRMacIver> Well, that's what I read it as as well, but I assumed it was probably something deeper. :)
10:29:51 <byorgey> Monad-transforming Gnomes
10:29:57 <edwardk> functional reactive MtG, its the future ;)
10:30:29 <shapr> edwardk: :-P
10:31:09 <shapr> I still have ~7000 cards left from ten years ago, thought I'd play around with them a bit. It got boring, so I thought I'd write code to represent them instead.
10:31:13 <apfelmus> nah, it's an anagram of the Tagless G-Machine
10:31:13 <edwardk> figuring out how to display the right tk dialogs to be able to let the end user pump the mana into all those effects must be interesting =)
10:32:12 <shapr> edwardk: A Yampa simulation is a very cool idea actually, hadn't considered that :-)
10:32:32 <DRMacIver> I need to figure out how G-machines work at some point. :)
10:32:33 <edwardk> glad i could help =)
10:32:39 <byorgey> edwardk: now look what you've done =)
10:32:51 <arcatan> shapr: then you can make code play with them instead of you
10:32:59 <arcatan> automatization rocks!
10:33:13 <edwardk> byorgey: don't worry, its shae, in about 3 hours he'll decide we wants to go outside and fly kites on his unicycle. its all good.
10:33:21 <shapr> edwardk: True that.
10:33:42 <byorgey> edwardk: heh, so I gather, although I've never yet had the privilege of meeting him in person =)
10:33:43 <edwardk> not that i'm much one to speak
10:33:49 <arcatan> ooooh, flying kites on unicycle
10:34:23 <byorgey> edwardk: NOW look what you've done. =)
10:34:28 <edwardk> muahaha
10:34:50 <edwardk> ADD is an easy thing to control, er rather people with ADD are easy things to ...
10:35:44 <shapr> :-P
10:35:56 * shapr throws ritalin at edwardk
10:36:51 <edwardk> i would probably be a lot more focused if i was on ritalin
10:38:11 * mdmkolbe|work thinks that *people* are easy things to control ... er, which he's absolutely not doing right now.  No sir, not at all.
10:38:29 <Vulpyne> You should have embedded a subliminal message into that.
10:39:06 * mdmkolbe|work is glad his message was subliminal enough to get past Vulpyne
10:40:23 <Vulpyne> Why do I suddenly feel like buying products from mdmkolbe?
10:40:25 <Vulpyne> What can you sell me?
10:41:38 <glen_quagmire> let f a b = a + b           f  1 2 returns 3. is it the same? f(1) returns a function  and that function takes 2?
10:42:01 <DRMacIver> Yes
10:42:12 <byorgey> glen_quagmire: right, f 1 returns a function which adds 1 to its argument
10:42:16 <Vulpyne> Giggety.
10:42:39 <glen_quagmire> is this y combinator or currying sutff?
10:42:45 <DRMacIver> This is currying.
10:42:53 <glen_quagmire> thank you
10:43:05 <DRMacIver> glen_quagmire: Incidentally, note that you can write f as (+)
10:43:23 <DRMacIver> glen_quagmire: And that the normall operators do this as well, so 1 + 2 is (+) 1 2
10:43:53 <glen_quagmire> oh this is interesting. i didn't know what (+) meant when i read tutorial
10:44:26 <glen_quagmire> only operators support infix? can i make my custom function f infix too?
10:44:40 <Vulpyne> Surround it with backticks like this: 1 `f` 2
10:44:50 <byorgey> > 24 `mod` 3
10:44:52 <lambdabot>  0
10:45:13 <glen_quagmire> this is cool
10:45:55 <DRMacIver> glen_quagmire: Basically alphanumeric identifiers (foo, bar, baz, 3, foo3, etc) are prefix, ones formed from other characters (+, *, >>-:), etc) are infix by default.
10:46:19 <DRMacIver> glen_quagmire: You can turn a prefix symbol into an infix one with ` ` or an infix one into a prefix one with ( )
10:46:39 <DRMacIver> Hm. >>-:) is of course not valid, because you can't use the )
10:46:49 <DRMacIver> >>:-:] then.
10:47:06 <mdmkolbe|work> > let >>:-:] = 3 in 5
10:47:06 <lambdabot>  Parse error
10:47:12 <mdmkolbe|work> > let >>:-: = 3 in 5
10:47:12 <lambdabot>  Parse error
10:47:12 <glen_quagmire> > (`mod`) 24 3
10:47:12 <lambdabot>  Parse error
10:47:18 <mdmkolbe|work> > let >>- = 3 in 5
10:47:18 <lambdabot>  Parse error
10:47:26 <mdmkolbe|work> > let (>>:-:]) = 3 in 5
10:47:26 <lambdabot>  Parse error
10:47:29 <mdmkolbe|work> > let (>>:-:) = 3 in 5
10:47:30 <lambdabot>  5
10:47:38 <byorgey> > let a >>:-:] b = a + b in 3 >>:-:] 5
10:47:38 <lambdabot>  Parse error
10:47:39 <DRMacIver> > let foo >>:-:] bar = [foo, bar] in "foo" >>:-:] "bar"
10:47:39 <lambdabot>  Parse error
10:47:47 <mdmkolbe|work> ']' is for lists
10:47:48 <DRMacIver> Hm
10:47:55 <DRMacIver> Ok, ] isn't valid either. My bad.
10:48:05 <DRMacIver> I always forget exactly which characters you can use and which you can't.
10:48:14 * dukedave notes first part of channel topic :)
10:48:27 <DRMacIver> ?
10:48:44 <Vulpyne> Write less? :)
10:48:45 <byorgey> general question: wouldn't it be more correct to say that backtick notation makes a function postfix rather than infix?
10:49:05 <byorgey> since functions actually only take one argument
10:49:09 <mdmkolbe|work> byorgey: not quote
10:49:20 <mdmkolbe|work> @type 1 `id`
10:49:24 <lambdabot> parse error (possibly incorrect indentation)
10:49:28 <dukedave> I do it all the time in hugs, just keep trying loads of edits until something works - I wonder if someone brought up just on declarative languages would "write less, think more"
10:49:32 <mdmkolbe|work> @type id `id` id
10:49:34 <lambdabot> forall a. a -> a
10:49:38 <mdmkolbe|work> @type id `id`
10:49:40 <lambdabot> parse error (possibly incorrect indentation)
10:49:53 <Vulpyne> Parens to make a section?
10:49:55 <byorgey> mdmkolbe|work: hm, strange.  is there a good reason for that limitation?
10:49:55 <mdmkolbe|work> @type (id `id`)
10:49:57 <lambdabot> forall a. a -> a
10:49:57 <Syzygy-> :t (id `id`)
10:49:58 <DRMacIver> byorgey: I don't think you can actually do plain postfix functions in Haskell unfortunately. Also that doesn't really agree with how the precedence works.
10:49:59 <lambdabot> forall a. a -> a
10:50:46 <mdmkolbe|work> Vulpyne: yes
10:50:51 <DRMacIver> (I have a Cunning Plan for how to make arbitrary user definable postfix, prefix and infix operators work in a consistent manner, but it's a) a lot of work, b) Requires me to know more about parsing than I currently do and c) Would result in truly and utterly unreadable code)
10:51:04 <byorgey> > let r x y z = [x,y,z] in 3 `r` 4 5
10:51:06 <lambdabot>   add an instance declaration for (Num (t1 -> t))
10:51:16 <mdmkolbe|work> > map (\f -> f 6) [(12/), (/3)]
10:51:18 <lambdabot>  [2.0,2.0]
10:52:23 <mdmkolbe|work> > let r x y z = [x,y,z] in (3::Int) `r` (4::Int) (5::Int)
10:52:25 <lambdabot>  Couldn't match expected type `t -> Int' against inferred type `Int'
10:52:26 <dukedave> One I've had on the back burner subject to the same constraints as DRMacIver just mentioned is 'underfix' notation :)
10:52:46 <mdmkolbe|work> dukedave: 2d operators?
10:52:52 <byorgey> > let r x y z = [x,y,z] in (3 `r` 4) 5
10:52:52 <dukedave> E.g. just the transpose of normal code..
10:52:54 <lambdabot>  [3,4,5]
10:53:21 <dukedave> I guess that's one way of putting it - don't know if you could come up with anything even remotely useful..
10:53:37 <byorgey> dukedave: an example?
10:54:23 <DRMacIver> Mine is in theory actually useful. :)
10:54:24 <mdmkolbe|work> dukedave: one of the original programming languages designed had 2d operators, unfortunately it was on the wrong side of the cold war so its ideas never spread
10:56:12 <edwardk> DRMacIver: i've got a version i've been toying with, but its a bit messy
10:56:19 <mdmkolbe|work> DRMacIver: yes, but you might need 1EB of RAM (1M ^ 3).  Things start to get very non-deterministic once you allow user specified fixities.
10:56:22 <edwardk> DRMacIver and makes whitespace very significant
10:56:30 <sphynx> hi all
10:57:36 <glen_quagmire> how do I see type info of a variable?
10:57:51 <glen_quagmire> type(f) => f is a function taking 2 arguments..etc
10:57:56 <Vulpyne> Usually :t expression
10:57:57 <mdmkolbe|work> glen_quagmire: at the GHCi prompt do ":type f"
10:57:59 <Vulpyne> In ghci at least.
10:58:06 <DRMacIver> mdmkolbe|work: I know. :)
10:58:09 <mdmkolbe|work> glen_quagmire: :i is also usefull
10:58:09 <glen_quagmire> thanks
10:58:12 <DRMacIver> mdmkolbe|work: It has a number of technical hurdles.
10:58:31 <DRMacIver> This is why I've not bothered doing more than toying with the concept.
10:58:34 <sphynx> I have some structure InfoItem. data InfoItem = InfoItem {value::Int, item::String}. Then I need to sort and display list of InfoItems
10:58:53 <sphynx> but now my values becomes not only Ints, but also times
10:59:01 <hpaste>  dukedave pasted "A terrible idea" at http://hpaste.org/400
10:59:04 <sphynx> times also can be sorted and displayed
10:59:11 <mdmkolbe|work> DRMacIver: though there may be some way to clip the complexity down below n^3 for operator languages and every predefined very high (low?) precidence keyword could break up the 'n'
10:59:31 <edwardk> my current approach basically takes identifiers as sequences of characters (modulo certain symbols that always terminate the identifier ( , ) ; etc. parse those as words, if not in scope in a closed context, then partition it at the boundaries between symbols and alphanumerics, and try to parse greedily from the left looking for prefix operators, in-scope symbols and then postfix operators. i'm currently not using any pre- or post- fix opera
10:59:38 <edwardk> and i probably got cut off =)
10:59:57 <sphynx> the question is: how can I change my InfoItem data (perhaps using Ord and Show classes) to to make possible using Ints and CalendarTimes as values?
11:00:13 <DRMacIver> mdmkolbe|work: Mm. Mine has the problem that arbitrary terms (not just identifiers) can have arbitrary fixities. I doubt it has a subexponential complexity parsing algorithm. :)
11:00:39 <mdmkolbe|work> DRMacIver: all CFG's have subexponential parsing algorithms
11:00:44 <byorgey> sphynx: well, you could add a time field
11:00:49 <DRMacIver> mdmkolbe|work: It's not context free.
11:01:02 <DRMacIver> At least I don't think it is.
11:01:06 <byorgey> sphynx: or you could make a separate Value type that contains an int and a time, then include that in the value field of your InfoItem type
11:01:17 <edwardk> drmaciver: you can probably build an operator precedence parser for it
11:01:21 <byorgey> sphynx: it depends what you want to do
11:01:46 <edwardk> with a dynamic classifier they can be quite expressive and are very simple
11:02:01 <mdmkolbe|work> DRMacIver: if you take the fixities of expressions away (or if you make that annotation very local (e.g. you always have to put parans)) you might make it CFG
11:02:57 <DRMacIver> mdmkolbe|work: Mm. Yes, you're probably right that for a fixed set of fixities it's probably context free.
11:03:18 <DRMacIver> Wait, that's not what you meant.
11:03:19 <DRMacIver> Sorry.
11:03:41 <DRMacIver> mdmkolbe|work: Yes, but the interesting part is the fixities of expressions, ideally without parentheses. :)
11:04:03 <araujo> hello
11:04:16 <sphynx> byorgey: so, I can add something like data Value = IntValue Int | TimeValue CalendarTime deriving (Ord, Show) and then InfoItem {value::Value, ...} ?
11:04:37 <mdmkolbe|work> DRMacIver: wouldn't there have to be some syntax to indicate you're not just using the fixity of the inner function application?  (maybe I missunderstand)
11:05:11 <byorgey> sphynx: well, that would mean that a value can be an Int, OR a time, but not both
11:05:17 <byorgey> sphynx: if that's what you want, then sure
11:05:19 <glen_quagmire> consing operator : is like foldr right? not foldl
11:05:24 <DRMacIver> mdmkolbe|work: It's not a very well thought out concept at the moment. It's entirely possible there are flaws. :)
11:06:07 <byorgey> glen_quagmire: right.
11:06:16 <sphynx> byorgey: yeah, exactly OR
11:06:27 <glen_quagmire> nice i get the hang of it
11:06:32 <byorgey> sphynx: then sure, that's exactly what you should do
11:06:42 <sphynx> byorgey: OK, thank you!
11:06:56 <byorgey> glen_quagmire: in fact, you can think of foldr f as replacing all the :'s in a list with `f`
11:07:35 <mdmkolbe|work> glen_quagmire: just remember foldr = parens on right -> (a `f` (b `f` (c `f d))), foldl = parens on left -> ((((a `f` b) `f` c) `f` d)
11:07:52 <byorgey> sphynx: sure
11:08:08 <glen_quagmire> oh crap. i don't get the hang of it
11:08:25 <mdmkolbe|work> > foldr (:) [] [1, 2, 3, 4]
11:08:26 <lambdabot>  [1,2,3,4]
11:08:28 <glen_quagmire> to do parens on the left, you have to exhuast all stacks
11:08:43 <mdmkolbe|work> > foldl (:) [] [1, 2, 3, 4]
11:08:44 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
11:08:44 <lambdabot>       Expected...
11:08:46 <glen_quagmire> that's why foldl can't work on infinite list
11:09:33 <mdmkolbe|work> glen_quagmire: yes, but since haskell is lazy the stack might not always be used the way you expect
11:10:05 <mdmkolbe|work> > foldl (flip (:)) [] [1, 2, 3, 4]
11:10:07 <lambdabot>  [4,3,2,1]
11:10:11 <byorgey> glen_quagmire: right.  in general foldl (even better, the strict version foldl') should be used to get some sort of "summary" value on a finite list, and foldr should be used to process a (possibly infinite) list lazily
11:11:09 <glen_quagmire> foldl (:) [] [1,2] fails because it tries to evaluate ([] : 1) first?
11:11:39 <dolio> > foldl (flip (:)) [] [1,2]
11:11:41 <lambdabot>  [2,1]
11:11:43 <byorgey> > [] : 1
11:11:44 <lambdabot>   add an instance declaration for (Num [[a]])
11:11:47 <mdmkolbe|work> glen_quagmire: no, it's b/c of a type error
11:11:51 <mdmkolbe|work> @type foldl
11:11:52 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> a
11:11:59 <mdmkolbe|work> @type (:)
11:12:01 <lambdabot> forall a. a -> [a] -> [a]
11:12:29 <mdmkolbe|work> glen_quagmire: (:) has a 'a -> b -> b' type, but foldl wants a 'a -> b -> a'
11:12:47 <mdmkolbe|work> (or 'b -> a -> b' if that helps you think though it better)
11:13:17 <byorgey> mdmkolbe|work: well, unifying a -> b -> b with a -> b -> a isn't a problem per se, the problem is unifying a -> b -> a with a -> [a] -> [a], which means a = [a]
11:13:43 <glen_quagmire> i need to read up on type to understand this conversation
11:14:30 <byorgey> glen_quagmire: probably a good idea.  Understanding the type system is 75% of understanding Haskell.
11:14:44 <byorgey> I made up the 75% number, but you get the idea.
11:15:03 <mdmkolbe|work> glen_quagmire: (:) expects an element as left argument and a list as right argument and produces a list, but to work with foldl the order of arguments needs to be swaped
11:15:22 <Vulpyne> And 20% of the remaining is understanding monads.
11:15:52 <byorgey> Vulpyne: right. =)
11:16:04 <bos> @users
11:16:04 <lambdabot> Maximum users seen in #haskell: 338, currently: 330 (97.6%), active: 19 (5.8%)
11:16:08 <bos> woo!
11:16:20 <desp> @hoogle CInt -> Int
11:16:20 <lambdabot> No matches, try a more general search
11:16:23 <desp> @hoogle CInt -> Integer
11:16:24 <lambdabot> No matches, try a more general search
11:16:26 <desp> hm
11:16:34 <byorgey> the other 5% is the interaction of the - operator with sections =P
11:16:36 <mdmkolbe|work> @index CInt
11:16:36 <lambdabot> Foreign.C.Types, Foreign.C
11:16:57 <mdmkolbe|work> @type toIntegral (undefined :: CInt)
11:16:59 <lambdabot> Not in scope: `toIntegral'
11:16:59 <lambdabot>  
11:16:59 <lambdabot> <interactive>:1:25: Not in scope: type constructor or class `CInt'
11:17:08 <mdmkolbe|work> @type toInteger (undefined :: CInt)
11:17:10 <lambdabot> Not in scope: type constructor or class `CInt'
11:17:28 <DRMacIver> byorgey: 75% seems a bit high. Understand lazy evaluation is probably a big part of it as well.
11:17:40 <DRMacIver> Particularly for people damaged by other languages :)
11:18:09 <mdmkolbe|work> DRMacIver: maybe, but once you "get" lazyness, you usually don't think about it
11:18:10 <byorgey> DRMacIver: yeah, you're probably right.  it wasn't a particularly well-thought-out number =)
11:18:16 <desp> mdmkolbe|work: ack
11:18:54 <byorgey> DRMacIver: My main point was just to emphasize the importance of learning the type system for someone who is new to Haskell
11:19:26 <DRMacIver> Yeah. And it's a valid point. :)
11:19:34 <DRMacIver> (Although I found the type system fairly intuitive)
11:20:17 * mdmkolbe|work loves how #haskell-ites so often talk by indirection (which of course is the essence of many forms of etiquette)
11:20:47 <tessier_> Does HAppS come with its own database or something?
11:21:04 * DRMacIver wonders what mdmkolbe|work means
11:21:11 <desp> ;)
11:21:17 <DRMacIver> tessier_: I think it comes with something approximating that.
11:22:03 <tessier_> DRMacIver: Cool. I am happy with zope's decision to do their own db so far. I hope HAppS turns out at least as good. Cramming everything into an SQL db like a lot of other systems do just seems like a bad idea.
11:22:42 <mdmkolbe|work> Michael (first name) David (middle name) Maxamillian Kolbe (confirmation name) (Adams (last name)) at work.  I just got tired of trying to find a globally unique name, and mdmkolbe seemed obsure enough to never (ever) get any collisions
11:23:06 <mdmkolbe|work> d'oh
11:23:19 <DRMacIver> Heh. That isn't what I was asking. :)
11:23:35 <mdmkolbe|work> name/reference ambiguity
11:23:39 <DRMacIver> (DRMacIver is constructed along the same principle)
11:23:52 <desp> Maxamillian, though?  The name is Maksymilian in Polish
11:24:11 <desp> interesting.
11:24:19 <mdmkolbe|work> I might have the spelling a bit off
11:24:36 <mdmkolbe|work> It's maximilian
11:24:40 <byorgey> mdmkolbe|work: you don't know how to spell your own name?
11:25:16 * mdmkolbe|work was never very good at spelling
11:27:03 <mdmkolbe|work> anyway, it's just cute how when someone asks a question, someone else answers by fiddling with LB.  or sometimes the question is asked via lambda bot
11:28:05 <DRMacIver> Ah, right. :)
11:28:46 <DRMacIver> We do something similar in ##java. Except in ##java we're rude to the newbies via javabot. :) Says it all really.
11:29:05 <LoganCapaldo> theres a javabot?
11:29:10 <DRMacIver> Yes
11:29:22 <DRMacIver> It does... very little really. It's a repository of factoids.
11:29:28 <oerjan> here in #haskell lambdabot is rude to us fiddling with her :(
11:29:28 <LoganCapaldo> Does it have an environment such that everything doesn't have to define some class on asingle line?
11:29:30 <LoganCapaldo> oh
11:29:54 <DRMacIver> And probably still takes more code than lambdabot :)
11:30:06 <DRMacIver> (Oh, and it tracks peoples' karma)
11:30:28 <mdmkolbe|work> speaking of which, I would be nice if hpaste had a syntax check or type check option
11:30:35 <mdmkolbe|work> s/I/it/
11:30:57 <LoganCapaldo> mdmkolbe|work: Is there some lib that can syntax check w/o too much effort?
11:31:18 <LoganCapaldo> Cause i'd be willing to try to put that together
11:31:20 <mdmkolbe|work> ghc might have a check syntax only option
11:32:30 <LoganCapaldo> I'd personally rather not have to shell out to check syntax.
11:32:39 * LoganCapaldo googles
11:34:52 <JKnecht> > are you female?
11:34:52 <lambdabot>  Parse error
11:36:05 <glen_quagmire> > (let asl = "14/f/fl") print asl
11:36:05 <lambdabot>  Parse error
11:36:25 <oerjan> lambdabot's source seems a safe bet for finding both syntax and type checks.
11:37:19 <mdmkolbe|work> oerjan: I think LB shells out for type checks at least (though not really using the real "shell", but definately spawning another proc)
11:37:23 <byorgey> glen_quagmire: you're missing an "in"
11:39:11 <glen_quagmire> oh I did this: let lol = "lo":lol in lol and it's infinite
11:39:35 <gkr> (join #scannedinavian
11:39:45 <gkr> Uhm, bad /
11:41:00 <mdmkolbe|work> > concat $ repeat "lo"
11:41:02 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
11:41:23 <dolio> > cycle "lo"
11:41:26 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
11:41:34 <nominolo> @src cycle
11:41:36 <lambdabot> cycle [] = undefined
11:41:37 <gkr> lol
11:41:38 <lambdabot> cycle xs = xs' where xs' = xs ++ xs'
11:42:12 <nominolo> that seems slow
11:42:22 <mdmkolbe|work> nominolo: why?
11:42:31 <mdmkolbe|work> nominolo: that is optimized code
11:43:04 <oerjan> > fix ("lo"++)
11:43:05 <lambdabot>  "lololololololololololololololololololololololololololololololololololololol...
11:43:12 <nominolo> i meat the src
11:43:31 <glen_quagmire> I press Ctrl+C. it stops (ghci). how do I get the prompt back?
11:43:42 <byorgey> glen_quagmire: as you can see, there's usually more than one way to skin a cat in Haskell =)
11:43:43 <nominolo> RET?
11:43:44 <glen_quagmire> cycle "a"      Ctrl+C
11:44:00 <mehrheit> > let ask x = if (fst . (randomR (0, 100)) . mkStdGen . length $ x) >= 50 then False else True in ask "are you female?"
11:44:02 <lambdabot>  True
11:44:29 <byorgey> glen_quagmire: strange, that should give you a prompt back
11:44:29 <mdmkolbe|work> glen_quagmire: doesn't it put you back at the GHCi prompt?
11:44:36 <oerjan> @src mkStdGen
11:44:36 <lambdabot> Source not found. The more you drive -- the dumber you get.
11:44:42 <nominolo> mdmkolbe|work: well, i guess it is ok
11:44:46 <glen_quagmire> no it gets stuck. i'm on Windows. probably that's why
11:45:04 <mdmkolbe|work> glen_quagmire: did you use ghcii or ghci?
11:45:13 <mdmkolbe|work> err, nm about that
11:45:22 <byorgey> @src (++)
11:45:22 <lambdabot> (++) []     ys = ys
11:45:22 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
11:45:33 <mdmkolbe|work> (ghcii is for cygwin people)
11:45:37 <mdmkolbe|work> (IIRC)
11:45:50 <glen_quagmire> ghci. after starting ghci, if I press Ctrl+C, it says Leaving GHCi but it gets stuck there
11:45:57 <glen_quagmire> Ctrl+Z (EOF) works fine
11:46:14 <mdmkolbe|work> glen_quagmire: do you have cygwin or mingw?
11:46:31 <glen_quagmire> i downloaded windows installer
11:46:33 <oerjan> > flip (foldr (:)) "hello, " "world!"
11:46:35 <Saizan> ?index Ord
11:46:42 <lambdabot>  "hello, world!"
11:46:44 <lambdabot> Prelude
11:47:16 <mehrheit> :t ask
11:47:18 <lambdabot> forall (m :: * -> *) r. (MonadReader r m) => m r
11:47:31 <mehrheit> :t question
11:47:32 <lambdabot> Not in scope: `question'
11:47:56 <mdmkolbe|work> glen_quagmire: ok, then you probably don't have them.  There's something about windows and ghci that don't always interact well.  It's a known problem
11:48:24 <glen_quagmire> i see
11:49:16 <mehrheit> @let question x = let val s = (length s)*20 + (sum $ map fromEnum s) in if (fst . (randomR (0, 100)) . mkStdGen . val $ x) < 50 then False else True
11:49:19 <lambdabot> Defined.
11:50:09 <shachaf> mehrheit: if x then False else True ?
11:50:24 <shachaf> mehrheit: Why not just "not x"?
11:50:38 <Saizan> does instance Ord (Collapse a) where compare _ _ = EQ violates the Ord contract?
11:51:00 <oerjan> Saizan: i don't think so
11:51:00 <mehrheit> shachaf, somehow my mind orders False before True
11:51:10 <mehrheit> so I typed them in in that order
11:51:16 <oerjan> it's a perfectly valid equivalence relation
11:51:22 <mehrheit> > False < True
11:51:30 <lambdabot>  True
11:51:45 <Saizan> oerjan: Ord is supposed to give a total order
11:51:47 <mdmkolbe|work> Saizan: if instance Eq (Collapse a) where _ == _ = True, then it certainly doesn't violate it
11:51:50 <shachaf> > (toEnum 0, toEnum 1) :: (Bool, Bool)
11:51:52 <lambdabot>  (False,True)
11:51:52 <DRMacIver> Steve Yegge is so cute when he gets worked up.
11:51:57 <mehrheit> > question "Does false go before true?"
11:51:57 <byorgey> > question "Is False < True?"
11:51:59 <lambdabot>  True
11:52:00 <lambdabot>  True
11:52:04 <mehrheit> lol
11:52:05 <byorgey> nice =)
11:52:19 <Saizan> mdmkolbe|work: right.
11:52:28 <mdmkolbe|work> > question "Are you feeling well today?"
11:52:31 <lambdabot>  False
11:52:43 <byorgey> aww
11:52:44 <byorgey> @botsnack
11:52:45 <lambdabot> :)
11:52:47 <mdmkolbe|work> > question "Can we cheer you up?"
11:52:49 <lambdabot>  True
11:53:14 <oerjan> Saizan: yes and with equality as mdmkolbe|work says, it is total.
11:57:28 <Saizan> ok, so the third law doesn't hold for sigfpe's last monad
11:58:35 * mdmkolbe|work thinks "a robot may not allow itself to come to harm"
11:59:14 <Saizan> it's the second sci-fi response that i get in two days!
11:59:22 <Saizan> *answer
12:00:58 <LoganCapaldo> @type let head2 (a:b:_) = (a,b) in head2
12:01:07 <lambdabot> forall t. [t] -> (t, t)
12:02:08 <LoganCapaldo> that function writes a check it can't cash
12:02:41 <LoganCapaldo> (w/o resorting to undefined anyway)
12:02:52 <LoganCapaldo> and you can tell by the type alone
12:02:59 <LoganCapaldo> interesting
12:03:12 <mdmkolbe|work> ?
12:03:22 <mdmkolbe|work> @type let head2 (a:b:_) = (a,b) in head2 [1, 2, 3]
12:03:25 <lambdabot> forall t. (Num t) => (t, t)
12:03:26 <mdmkolbe|work> > let head2 (a:b:_) = (a,b) in head2 [1, 2, 3]
12:03:28 <lambdabot>  (1,2)
12:05:22 <LoganCapaldo> > let head2 (a:b:_) = (a,b) in head2 ([] :: [Int])
12:05:24 <lambdabot>   Non-exhaustive patterns in function head2
12:05:30 <LoganCapaldo> > let head2 (a:b:_) = (a,b) in head2 [1]
12:05:32 <lambdabot>   Non-exhaustive patterns in function head2
12:05:37 <mdmkolbe|work> > head []
12:05:39 <lambdabot>  Exception: Prelude.head: empty list
12:05:43 <LoganCapaldo> yep
12:07:16 <LoganCapaldo> I just find it interesting that someone can give you a type like that [a] -> (a, a) and you can tell them modulo bottom or exceptions or whatever that the function doesn't exist
12:07:53 <LoganCapaldo> Just thinking out loud
12:07:59 <LoganCapaldo> into an IRC channel...
12:08:06 <LoganCapaldo> maybe I'm crazy
12:09:01 <oerjan> @djinn [a] -> (a, a)
12:09:02 <lambdabot> -- f cannot be realized.
12:09:15 <oerjan> indeed.
12:09:40 <mdmkolbe|work> oerjan: djinn doesn't understand lists
12:09:49 <oerjan> @djinn a -> [a]
12:09:50 <lambdabot> -- f cannot be realized.
12:09:53 <oerjan> alas
12:10:19 <ClaudiusMaximus> @type (\l -> (head l,  last l))
12:10:22 <lambdabot> forall a. [a] -> (a, a)
12:10:34 <notsmack> ClaudiusMaximus: exceptions
12:11:01 <ClaudiusMaximus> notsmack: yeah.
12:11:03 <mdmkolbe|work> in general any type (unit+a) -> b, can not exist
12:11:37 <dukedave> Hum, can anyone confirm hpaste is down?
12:11:40 <mdmkolbe|work> [a] -> a is just (unit + (a*[a])->a
12:11:54 <mdmkolbe|work> dukedave: works here
12:12:04 <byorgey> dukedave: works for me too
12:12:19 <dukedave> Weird, okay cheers I'll keep hammering it :)
12:12:36 <LoganCapaldo> its being rather sluggish for me
12:12:37 <dukedave> Ah, got it now.. very strange
12:13:18 <LoganCapaldo> I wonder if dukedave and I have the same interwebs bottleneck :)
12:13:22 <LoganCapaldo> the tubes is clogged
12:31:32 <oerjan> @src (^)
12:31:33 <lambdabot> Source not found. I can't hear you -- I'm using the scrambler.
12:32:20 <hpaste>  dukedave pasted "Propositional logic problem" at http://hpaste.org/401
12:32:39 <dukedave> Phew, that took a while to type out :)
12:33:51 <dukedave> So it anyone wants to have a look for me that'd be great, unfortunately I just can't let it go :(
12:36:16 <fasta> How can I remove libghc6-anydbm-dev?
12:36:35 <CosmicRay> fasta: what probelm are you having?
12:36:36 <fasta> The deinstallation script returns an exit status of 1
12:36:43 <CosmicRay> tracking sid?
12:37:13 <fasta> CosmicRay: testing currently
12:37:23 <CosmicRay> ah, that may be enough.  what vesion of the package?
12:37:52 <fasta> CosmicRay: 1.01
12:38:04 <oerjan> dukedave: start with A /\ B at the top instead of A, perhaps?
12:38:19 <CosmicRay> fasta: if you install 1.0.3, then remove it, it should work.
12:38:25 <yakov> hello
12:38:26 <fasta> CosmicRay: did you program your irc client to check for that package?
12:38:29 <CosmicRay> fasta: the other hack is to rm /var/lib/dpkg/info/libghc6-anydbm-postinst
12:38:36 <CosmicRay> fasta: no, I wrote it.
12:38:50 <oerjan> then use the rules for /\ to turn that into A or B where you need those
12:38:51 <CosmicRay> and I used packages.debian.org
12:39:18 <fasta> CosmicRay: So, it was just coincidence that you looked at my question
12:39:20 <fasta> CosmicRay: ?
12:39:32 <CosmicRay> yes, I happened to flip to this channel right when you asked
12:39:41 <fasta> CosmicRay: lucky me
12:39:45 <CosmicRay> heh
12:40:11 <sioraiocht> is there any good documentation on generating bindings for haskell for someone that's never done that beore?
12:40:19 <CosmicRay> if you had said "CosmicRay: blah", and my irc client wasn't minimized, my tab for #haskell would have been highlighted
12:40:26 <CosmicRay> but when I have to concentrate, I minimize irc
12:40:56 <fasta> CosmicRay: yes, I have my IRC client on a different virtual screen too.
12:41:25 <fasta> CosmicRay: Are you sure it cannot do any harm if I do the hackish solution?
12:41:49 <fasta> CosmicRay: it seems that GHC remembers the package in that case, doesn't there interfere with putting a newer version there?
12:41:50 <CosmicRay> fasta: the potential harm is leaving an old package registered with ghc-pkg
12:42:14 <fasta> s/there/that
12:42:16 <CosmicRay> fasta: the safer step would be to get the newer package but it will probably be OK for you to not do so though.
12:44:04 <dukedave> oerjan: Just working it :)
12:46:53 <fasta> Heh, Launchpad looks all fluffy when compared to Debian's BTS :)
12:47:41 <CosmicRay> I would be tempted to say launchpad *is* all fluffy... ;-)
12:48:16 <dukedave> Woop, oerjan you're a legend :D
12:49:02 <dukedave> Tragically I'm going to have to do a manual "I'm stupid" un-send on haskell-cafe  :(
12:49:29 <oerjan> ouch
12:52:02 <fasta> CosmicRay: that's not a really good solution, since that means I need to upgrade ghc too which in turn implies I need to deinstall Edison too, which I am actually using one module from.
12:54:57 <hpaste>  emu annotated "Propositional logic problem" with "coq proof" at http://hpaste.org/401#a1
12:57:36 <edwardk> emu: thats not nice =)
12:57:55 <emu> muhaha
12:58:30 <dukedave> Lol
12:58:37 <dukedave> I'm intrigued
12:58:38 <emu> dukedave: you need to split it into two proofs
12:59:12 <emu> the implication elimination on H : A -> B -> C will ask you to prove both A then prove B
13:01:28 <emu> edwardk: no, evil would have been "intuition"
13:01:41 <emu> which just works
13:02:23 <hpaste>  dukedave annotated "Propositional logic problem" with "Fixed" at http://hpaste.org/401#a2
13:03:02 <dukedave> @where coq
13:03:03 <lambdabot> I know nothing about coq.
13:03:15 <Philippa> lambdabot's innocent like that
13:03:26 <Philippa> @google coq
13:03:29 <lambdabot> http://coq.inria.fr/
13:03:29 <lambdabot> Title: The Coq proof assistant
13:15:31 <cdsmith> "#haskell - 333 users"... 333 = 666 / 2.  Coincidence?  You decide.
13:17:38 <fasta> cdsmith: it's not the first time that happens.
13:18:07 <cdsmith> Aye.  There are many warning signs of the apocalypse. :)
13:20:56 <mehrheit> haskocalypse, that is when the real world transforms from imperative to pure functional
13:22:12 <mehrheit> > question "\"#haskell - 333 users\"... 333 = 666 / 2.  Coincidence?"
13:22:12 <bos> any freebsd users around?
13:22:15 <lambdabot>  True
13:22:19 <cdsmith> robyonrails: I like your nick. :)
13:22:23 <robyonrails> ;)
13:22:26 <mehrheit> cdsmith, see, a coincidence
13:22:46 <kaol> @src question
13:22:46 <lambdabot> Source not found. My pet ferret can type better than you!
13:22:52 <cdsmith> mehrheit: no doubt there was a coincidence that just occurred... but it musta gone over my head.
13:22:59 <MyCatVerbs> @src tail
13:23:00 <kaol> @type question
13:23:00 <lambdabot> tail (_:xs) = xs
13:23:00 <lambdabot> tail []     = undefined
13:23:02 <lambdabot> Not in scope: `question'
13:23:05 <MyCatVerbs> Heeheehee.
13:23:21 <mehrheit> kaol, question x = let val s = (length s)*20 + (sum $ map fromEnum s) in if (fst . (randomR (0, 100)) . mkStdGen . val $ x) < 50 then False else True
13:25:00 <mux> if X then False else True <==> not X
13:25:36 <mehrheit> yes
13:25:40 <oerjan> @src not
13:25:40 <lambdabot> not True   =  False
13:25:40 <lambdabot> not False  =  True
13:25:53 <oerjan> wow, you're right!
13:26:44 <mehrheit> lambdabot's @let definitions should be editable in a wiki way
13:27:04 <oerjan> @help let
13:27:05 <lambdabot> let <x> = <e>. Add a binding
13:27:08 <oerjan> @list let
13:27:08 <lambdabot> eval provides: run let undefine
13:27:28 <mehrheit> @help undefine
13:27:28 <lambdabot> undefine. Reset evaluator local bindings
13:27:54 <sorear> @where newpopen
13:27:54 <lambdabot> darcs get http://www.cse.unsw.edu.au/~dons/code/newpopen
13:29:17 <cdsmith> Huh.  It's just dawned on me that Haskell has essentially two meanings of equality; one used in pattern matching, and the other being Eq.  Is this right?
13:29:47 <SamB> cdsmith: well... I don't know as pattern matching involves "equality"
13:30:21 <SamB> (except in the case of numeric literal patterns, which are actually more or less shorthand for guards)
13:30:22 <cdsmith> SamB: at least for finite types with accessible constructors, one could use it to define a sort of hyper-equality.
13:30:27 <mehrheit> :t let f 1 = 2 in f
13:30:35 <lambdabot> forall t t1. (Num t, Num t1) => t -> t1
13:31:11 <edwardk> cdsmith: the usual word is 'structural'
13:31:19 <sorear> .
13:31:24 <SamB> yeah.
13:31:51 <SamB> if you're exporting data constructors, you probably should be using structural equality for Eq
13:32:38 <cdsmith> Okay, so there's structural equality and Eq (granted 99% of the time they coincide)?
13:33:03 <SamB> also if you came up with the way floating point is treated in 99% of languages, you should be boiled in oil...
13:33:24 <cdsmith> SamB: ???
13:33:32 * SamB is talking about how 0 == -0, but they aren't actually the same thing
13:33:43 * cdsmith doesn't like boiling in oil.
13:33:52 <oerjan> > (0/0) == (0/0)
13:33:52 <mehrheit> @where compactstring
13:33:53 <lambdabot> http://twan.home.fmf.nl/compact-string/
13:33:54 <lambdabot>  False
13:33:59 <SamB> cdsmith: you didn't come up with the idea...
13:34:00 <mehrheit> @where bytestring
13:34:00 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
13:34:10 <SamB> oerjan: oh, yes, that's even worse...
13:34:12 <mehrheit> @botsnack
13:34:12 <lambdabot> :)
13:34:28 <cdsmith> SamB: Whew!  Though it does make sense to me, so maybe I;'m in danger anyway.
13:34:52 <SamB> cdsmith: does (0/0) /= (0/0) make sense to you?
13:35:23 <cdsmith> Yes, since the 0s could come from contexts where the quotients aren't equal, but all numbers are just too small to fit in a float.
13:35:33 <mehrheit> @where haskell-mode
13:35:33 <lambdabot> http://haskell.org/haskellwiki/Haskell_mode_for_Emacs
13:35:47 <SamB> ... but == is *supposed* to be an equivalence relation...
13:35:56 <SamB> x == x should *always* be true
13:36:14 <cdsmith> SamB: So the problems is that there should be no 'instance Eq Float' ?
13:36:46 <SamB> cdsmith: I was thinking that maybe 0/0 should be equal to 0/0
13:36:58 <SamB> nevermind whether it makes sense, at least it's an equivalence relation!
13:37:05 <cdsmith> There are clearly issues either way.
13:37:29 <sorear> cdsmith: Float math *is* exact.
13:37:40 <sorear> cdsmith: The results are completely predictable
13:37:48 <cdsmith> sorear: Sure, of course.  Where'd that come from?
13:37:52 <SamB> but the other way keeps the issues in the numerical stuff
13:38:27 <edwardk> samb: the problem is equality in floats is usually defined modulo some extremely small epsilon-like rounding factor, 0 and -0 can't be unequal or you get more common errors than having a -0 solves. the stated ieee purpose of -0 is just so the infinity cases retain their correct signs
13:39:40 <SamB> edwardk: well, you shouldn't be using (==) if what you meant was "approximately the same"
13:39:44 <SamB> so...
13:39:59 <edwardk> you'd need to define another field-like thing with a single negative infinitesimal to get the behavior you want.
13:40:22 * sorear doesn't believe acommodating to idiot programmers is at all wise
13:40:37 <SamB> edwardk: huh?
13:40:48 <edwardk> now, that said, i'd be perfectly ok with defining a lexical syntax so when you pattern matched with -0 or NaN you got what you wanted. ;) thats structural equality after all ;)
13:41:03 <SamB> @hoogle isnegative
13:41:06 <lambdabot> Prelude.isNegativeZero :: RealFloat a => a -> Bool
13:41:22 <edwardk> foo NaN = ... ; foo (-0) = ... perhaps
13:41:57 <SamB> actually, I already get what I want when I pattern match with (-0) in an appropriate type
13:42:14 <SamB> now, there's one problem with tihs NaN syntax
13:42:14 <edwardk> oh?
13:42:34 <SamB> namely that it starts with a capital N
13:42:49 <SamB> edwardk: by "appropriate type", I mean one where 0 /= -0
13:42:54 <edwardk> its a 'constructor-like' thing
13:43:07 <edwardk> if you want to be able to pattern match on it anyways
13:43:11 <SamB> oh, I guess you need views anyway?
13:43:25 <edwardk> in my case, yeah
13:43:47 <edwardk> i haven't done much with the corner cases of floats yet, so this is a fairly serious sounding-out discussion for me ;)
13:44:13 <SamB> anyway... I just wish that (==) would be return whether or not the two things were observationally equivalent...
13:44:31 <SamB> s/be //
13:45:52 <edwardk> maybe a javascript like === ? =)
13:46:18 <SamB> maybe!
13:46:26 <SamB> actually I don't do much with floats myself
13:46:50 <SamB> it just bothers me to know that (==) doesn't work right on them!
13:47:50 <int-e> -0 /= 0 would surprise a lot of people
13:48:04 <int-e> even though the two are distinguishable.
13:48:08 <edwardk> i wonder how useful an extra-linguistic === could be, that checked for equivalence in terms of the closures bound by the underlying thunks and/or pointer equality to infer the extra occasional equality, with semantics that allowed it to return true sometimes when it would otherwise return bottom.
13:48:51 <edwardk> but in the absence of proof on the === pass fell back to ==.
13:49:42 <sorear> edwardk: what is (takeALongTime `seq` (0/0)) === (takeALongTime `seq` (0/0)) ?
13:49:50 <int-e> @type GHC.Base.reallyUnsafePtrEquality#
13:49:52 <lambdabot> forall a. a -> a -> GHC.Prim.Int#
13:50:16 <sorear> better yet,   let slowThunk = takeALongTime `seq` 0/0 in slowThunk === slowThunk
13:50:20 <edwardk> that way if repeat 1 === repeat 1 used pointer sharing, then it would return trivially due to pointer equality, falling back from that to comparing the contents of the thunk, which would work if they inlined the same, otherwise it'll bottom out trying to walk an infinite structure like it would have with ==.
13:50:50 <sorear> edwardk: so === isn't always conservative.  sometimes it returns true when == returns false!
13:50:52 <edwardk> sorear: well, it'd try the pointer equality/thunk-walking pass, fail, then fall back to the == comparison.
13:51:02 <sorear> edwardk: why would it fail?
13:51:03 <DRMacIver> What makes reallyUnsafePtrEquality# more unsafe than unsafeCoerce#? :)
13:51:09 <sorear> edwardk: they're the same thunk!
13:51:15 <int-e> DRMacIver: it's also unreliable
13:51:19 <edwardk> hrmm
13:51:28 <DRMacIver> int-e: How so?
13:51:29 <glen_quagmire> how do I specify type in:  main = do  (name :: String) <- System.IO.getLine ?
13:51:41 <edwardk> ah because comparison on floats isn't an equivalence relation.
13:51:49 <SamB> DRMacIver: sometimes thunks mess it up...
13:51:49 <int-e> DRMacIver: the RTS is allowed to break sharing (and the parallel one will actually do that occasionally)
13:51:50 <glen_quagmire> > name <- getLine
13:51:51 <lambdabot>  Parse error
13:51:57 <DRMacIver> ok
13:52:04 <SamB> edwardk: I want (==) to be an equivalence relation always
13:52:11 <oerjan> :t getLine
13:52:11 <glen_quagmire> I want to specify type of variable namely 'name'
13:52:15 <lambdabot> IO String
13:52:16 <SamB> in terms of the public interface
13:52:24 <edwardk> sorear: ok, with a proof obligation that the underlying (==) is an equivalence relation =)
13:53:00 <edwardk> then SamB gets his semantics for floats ;)
13:53:35 <edwardk> where you can then define a quotient type over floats of some sort to get back the traditional ieee semantics
13:53:38 <DRMacIver> Hm
13:53:41 <oerjan> > do a <- "test" ; a :: Char ; return a
13:53:42 <lambdabot>  Couldn't match expected type `[t]' against inferred type `Char'
13:53:53 <edwardk> er
13:53:54 <edwardk> hrmm
13:53:57 <DRMacIver> Second question. Why does reallyUnsafePointerEquality# return an Int# ?
13:53:58 <edwardk> quotient type doesn't work
13:54:01 <edwardk> because NaN
13:54:08 <edwardk> it can fix -0 vs. 0 but not NaN
13:54:38 <edwardk> gah i hate floats
13:54:39 <oerjan> > do a <- "test" ; return a
13:54:41 <lambdabot>  "test"
13:54:45 <int-e> > (undefined :: Int) == undefined -- what about this?
13:54:47 <lambdabot>  Undefined
13:55:07 <sorear> DRMacIver: BITD Bool was a non-primitive type, defined in GHC.Base.  See recursive module dependancies.
13:55:12 <sorear> that's my guess
13:55:17 <SamB> int-e: oh, that's fine to bottom out
13:55:21 <edwardk> well, it looks like to be faithful you'd have to define another notion of equality for ieee compliance.
13:55:27 <DRMacIver> BITD?
13:55:39 <edwardk> and use something other than == for it in my toy lang, blech.
13:55:45 <int-e> SamB: you *could* bottom out on NaN, too.
13:55:56 <SamB> int-e: sure you could
13:55:59 <edwardk> int-e: brilliant
13:56:03 <SamB> but that would be incredibly annoying
13:56:07 <edwardk> heh
13:56:09 <edwardk> yeah
13:56:36 <bct> > let n = length [1..21] in product [1..n]
13:56:37 <SamB> what happens if I try to use NaN as a Map key?
13:56:39 <lambdabot>  -1195114496
13:56:46 <bct> ^-- how do i prevent that from overflowing?
13:57:03 <quicksilver> bct: use Integer
13:57:05 <int-e> bct: convert the result of length to Integer
13:57:10 <SamB> > let n = genericLength [1..21] in product [1..n]
13:57:12 <lambdabot>  51090942171709440000
13:57:17 <olsner> isn't length [1..21] just a fancy way to say 21?
13:57:19 <byorgey> @type getLine
13:57:20 <edwardk> > let length [1..21] in product [1..n] :: Integer
13:57:20 <lambdabot>  Parse error
13:57:20 <lambdabot> IO String
13:57:23 <bct> aaaah, thanks. didn't know about genericLength
13:57:26 <int-e> > let n = fromIntegral (length [1..21]) in product [1..n]
13:57:28 <lambdabot>  51090942171709440000
13:57:36 <int-e> @type length
13:57:38 <olsner> > product [1..21]
13:57:38 <lambdabot> forall a. [a] -> Int
13:57:39 <lambdabot>  51090942171709440000
13:57:46 <SamB> bct: that will also work if you have lists of extraordinary length ;-)
13:57:48 <byorgey> glen_quagmire: why do you need to specify the type of name?  the type of getLine guarantees it will be a String anyway
13:58:01 <int-e> bct: note that the literal 21 is polymorphic:
13:58:02 <int-e> @type 21
13:58:04 <lambdabot> forall t. (Num t) => t
13:58:10 <DRMacIver> > product [1..]
13:58:12 <DRMacIver> :)
13:58:15 <lambdabot> Terminated
13:58:20 <olsner> har har
13:58:22 <DRMacIver> Not that long, huh?
13:58:26 <olsner> @yow
13:58:26 <sorear> > product [0..]
13:58:26 <lambdabot> Vote for ME -- I'm well-tapered, half-cocked, ill-conceived and TAX-DEFERRED!
13:58:26 <bct> int-e, yes, but i'm obtaining n from 'length'
13:58:32 <lambdabot> Terminated
13:58:34 <glen_quagmire> byorgey: i thought i could declare a variable in do block
13:58:36 <int-e> bct: there's a defaulting rule that chooses Integer for this if the type can not be resolved otherwise, which is confusing.
13:58:37 <SamB> DRMacIver: [1..] is pretty darn long
13:58:38 <bct> i just didn't know how to convert Int to Integer
13:58:40 <sorear> why is (*) so strict? :)
13:58:48 <LoganCapaldo> seriously
13:58:51 <SamB> sorear: ... um.
13:58:59 <SamB> sorear: because we like it that way?
13:59:04 <int-e> bct: yes, length returns an Int (not an Integer) which has limited size and overflows.
13:59:07 <DRMacIver> SamB: Psht. It's not that long. It's even countable!
13:59:15 <SamB> DRMacIver: sure!
13:59:18 <LoganCapaldo> > foldl (*) [0..]
13:59:20 <lambdabot>   add an instance declaration for (Num [t])
13:59:23 <SamB> but you'll never reach the end
13:59:26 <LoganCapaldo> > foldl (*) 1 [0..]
13:59:28 <byorgey> glen_quagmire: well, you can (sort of), but no need to specify the type
13:59:31 <SamB> not at type [Integer]
13:59:34 <lambdabot> Terminated
13:59:35 <DRMacIver> SamB: That's a hardware problem.
13:59:41 <mux> @type maybeToBool
13:59:43 <lambdabot> Not in scope: `maybeToBool'
13:59:44 <mux> mm
13:59:48 <sorear> You can't make an infinite list of reals :(
13:59:48 <edwardk> so the cases that === may report a false positive would be any corner cases that are not in == but are in the reflexive closure of ==. in other words, the cases where you break the law that == should be an equivalence relation. i don't see much of a problem
13:59:49 <int-e> > scanl1' (*) [1..]
13:59:49 <mux> I could have sworn this existed
13:59:50 <lambdabot>   Not in scope: `scanl1''
13:59:52 <byorgey> glen_quagmire: the type will be automatically inferred
13:59:57 <int-e> > scanl1 (*) [1..]
13:59:59 <lambdabot>  [1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,87...
14:00:03 <SamB> DRMacIver: actually hardware problems will probably result in an exception at some point
14:00:03 <bct> thanks, you guys are on the ball.
14:00:09 <LoganCapaldo> @type fromMaybe (const True) False
14:00:11 <lambdabot>     Couldn't match expected type `Maybe (b -> Bool)'
14:00:11 <lambdabot>            against inferred type `Bool'
14:00:22 <LoganCapaldo> @type fromMaybe False (const True)
14:00:23 <mux> it's maybe True (const False) ...
14:00:24 <lambdabot>     Couldn't match expected type `Maybe Bool'
14:00:25 <lambdabot>            against inferred type `b -> Bool'
14:00:33 <mux> @type maybe True (const False)
14:00:37 <lambdabot> forall a. Maybe a -> Bool
14:00:44 <glen_quagmire> byorgey: ok. i thought putting type anotation was a good practice
14:00:47 <olsner> > (product . scanl (*)) [1..5]
14:00:48 <lambdabot>  Couldn't match expected type `[a]'
14:00:53 <DRMacIver> SamB: I mean that the fact that we're only running on a finitely fast machine is a hardware problem. ;)
14:01:14 <SamB> like, sometime before you reach 2^(2^(3+n)), where n is the word size
14:01:27 <olsner> :t (product . scanl (*))
14:01:30 <lambdabot>     Couldn't match expected type `[a]'
14:01:31 <lambdabot>            against inferred type `[a1] -> [a1]'
14:01:35 <SamB> > (1/0)
14:01:37 <lambdabot>  Infinity
14:01:43 <sorear> SamB: Ahem?  I can store integers way bigger than that.
14:01:44 <SamB> > (1/0)/(1/0)
14:01:46 <lambdabot>  NaN
14:01:52 <SamB> sorear: where?
14:01:55 <oerjan> :t isJust
14:01:56 <olsner> > product (scanl (*) [1..5])
14:01:58 <lambdabot>  Couldn't match expected type `[a]'
14:01:59 <lambdabot> forall a. Maybe a -> Bool
14:02:09 <sorear> SamB: In doubleword-addressed storage.
14:02:20 <SamB> sorear: not that word size!
14:02:23 <byorgey> glen_quagmire: indeed, it is, but that usually applies only to top-level declarations.
14:02:32 <SamB> sorear: DWORD on your system you smartass
14:02:35 <sorear> SamB: Namely my hard drive - the number you quoted works out to 32GB or so
14:02:43 <SamB> oh. that.
14:02:51 <glen_quagmire> oh i see. thanks byorgey
14:02:52 <olsner> > (product . scanl1 (*)) [1..5]
14:02:53 <lambdabot>  34560
14:02:55 <sorear> SamB: My hard drive requires double words to address.
14:02:57 <SamB> well, maybe the quixotic haskell compiler can manage that feat
14:02:58 <olsner> > (product . scanl1 (*)) [1..21]
14:03:00 <sorear> SamB: 64 bits!
14:03:00 <lambdabot>  6511133448234075558333703207915327604701889469427487120997333602346227558639...
14:03:24 <oerjan> mux: isJust
14:03:29 <mux> stupid me!
14:03:33 <mux> thank you.
14:03:43 <byorgey> > length . show $ (product . scanl1 (*)) [1..21]
14:03:45 <lambdabot>  176
14:03:51 <SamB> sorear: so does QHC store Integers in off_t-addressed storage?
14:04:19 <mux> @pl \x y -> not (foo x y)
14:04:19 <lambdabot> (not .) . foo
14:05:07 <sorear> SamB: QHC doesn't store integers.
14:05:11 <sorear> SamB: it's a *compiler*
14:05:12 <mux> that is so unfortunate
14:05:24 <SamB> sorear: well, I meant, it's RTS...
14:05:33 <LoganCapaldo> > isJust Nothing
14:05:35 <lambdabot>  False
14:05:37 <sorear> SamB: QHC doesn't have a RTS, it uses yhi.
14:05:42 <SamB> oh.
14:05:44 <sorear> which uses libgmp
14:05:55 <olsner> > fix (\n -> length $ show $ product [1..n])
14:05:56 <lambdabot>  Exception: <<loop>>
14:06:18 <SamB> well, libgmp as far as I know uses RAM to store the values...
14:06:31 <SamB> well, virtual memory, whatever
14:06:39 <olsner> > (\n -> length $ show $ product [1..n]) 1
14:06:42 <lambdabot>  1
14:06:54 <LoganCapaldo> @check (\x -> let f = isJust . Just in f x == const True x) :: Integer -> Bool
14:06:56 <lambdabot>  OK, passed 500 tests.
14:07:36 <olsner> > head $ filter (\n -> n == (length $ show $ product [1..n])) [1..]
14:07:39 <lambdabot>  1
14:07:44 <LoganCapaldo> @scheck (\x -> let f = isJust . Just in f x == const True x) :: Either () Bool -> Bool
14:07:46 <lambdabot>   Completed 3 test(s) without failure.
14:07:50 <olsner> > take 7 $ filter (\n -> n == (length $ show $ product [1..n])) [1..]
14:07:58 <lambdabot> Terminated
14:08:11 <glen_quagmire> can I write a wrapper to getLine so that its type will be IO Int ?
14:08:17 <olsner> perhaps 1 is the only possible answer :(
14:08:18 <LoganCapaldo> @scheck (\x -> let f = isJust . Just in f x == const True x) :: Either (Bool, Maybe ()) Bool -> Bool
14:08:21 <lambdabot>   Completed 6 test(s) without failure.
14:08:49 <LoganCapaldo> @scheck (\x -> let f = isJust . Just in f x == const True x) :: forall a. a -> Bool
14:08:49 <lambdabot>  Parse error
14:09:03 <oerjan> glen_quagmire: fmap read getLine
14:09:06 <glen_quagmire> wrapper = do a <- getLine; read a;
14:09:21 <bluestorm_> @src mapM_
14:09:21 <lambdabot> mapM_ f as = sequence_ (map f as)
14:09:32 <glen_quagmire> but read is String -> a
14:09:45 <glen_quagmire> it doesn't necessarily return Int
14:09:47 <bluestorm_> @src sequence_
14:09:47 <lambdabot> sequence_ ms = foldr (>>) (return ()) ms
14:10:07 <oerjan> > (read "10" :: Int, read "10" :: Integer)
14:10:08 <lambdabot>  (10,10)
14:10:13 <byorgey> glen_quagmire: that's fine, you can just use it in a context that requires an Int
14:10:48 <byorgey> @unpl \f g -> ((f .) .) . g
14:10:48 <lambdabot> \ f g e j m -> f (g e j m)
14:11:15 <byorgey> @unpl \f g h -> h . ((f .) .) . g
14:11:15 <lambdabot> \ f g h e -> h (\ n q -> f (g e n q))
14:11:39 <oerjan> > read "ahem" :: Int -- alas
14:11:40 <lambdabot>  Exception: Prelude.read: no parse
14:12:05 <byorgey> > read "1.2" :: Int -- curious?
14:12:08 <lambdabot>  Exception: Prelude.read: no parse
14:12:25 <oerjan> @src read
14:12:25 <lambdabot> read s = either error id (readEither s)
14:12:35 <byorgey> > read "1 2" :: Int
14:12:37 <lambdabot>  Exception: Prelude.read: no parse
14:12:41 <oerjan> @src readEither
14:12:41 <lambdabot> Source not found. stty: unknown mode: doofus
14:13:09 <glen_quagmire> lambdabot: help
14:13:29 <oerjan> > reads "1 2" :: [(Int, String)]
14:13:31 <lambdabot>  [(1," 2")]
14:13:48 <glen_quagmire> is there help about how to use lambdabot?
14:14:35 <oerjan> @help
14:14:36 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
14:14:59 <Vulpyne> http://haskell.org/haskellwiki/Lambdabot
14:15:00 <lambdabot> Title: Lambdabot - HaskellWiki
14:15:46 <Vulpyne> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS -- There's commands.
14:16:41 <glen_quagmire> nice thanks Vulpyne
14:23:08 <shapr> I wish someone had already hacked maak so that I could pass to it a list of directories containing darcs repositories, and it would do all the required cabal-install and cabal-setup calls by itself.
14:27:03 <sorear> maak?
14:27:15 <vincenz> sorear: still no answer to my post :(
14:27:34 <sorear> :(
14:29:06 <rretzbach> Hello, I'm new.
14:29:30 <rashakil> Hello new.
14:29:40 <rretzbach> Hello old one.
14:29:46 <sorear> @users
14:29:46 <lambdabot> Maximum users seen in #haskell: 338, currently: 328 (97.0%), active: 17 (5.2%)
14:29:59 <kpreid> > reverse "new"
14:30:00 <lambdabot>  "wen"
14:30:08 <kpreid> > map pred "new"
14:30:11 <lambdabot>  "mdv"
14:30:44 <rretzbach> is pred something like a decrease for chars?
14:30:46 <sorear> rretzbach: Ask questions :)
14:30:52 <rretzbach> lol
14:30:55 <sorear> rretzbach: generic decrease
14:30:56 <Excedrin> > pred 5
14:30:58 <lambdabot>  4
14:31:01 <rretzbach> I don't have questions :>
14:31:06 <rretzbach> I am just reading the wikibooks
14:31:32 <rretzbach> Is "pred" an abbreviation?
14:31:38 <sorear> predecessor
14:31:43 <dmhouse> rretzbach: which page is that on?
14:31:44 <rretzbach> Ahh, I see.
14:31:48 <rretzbach> 4
14:31:55 <dmhouse> rretzbach: :) What's the chapter name?
14:32:01 <rretzbach> http://en.wikibooks.org/wiki/Haskell/Lists_and_tuples
14:32:10 <rretzbach> I have to begin from the start :(
14:32:11 <dmhouse> Thanks, I'll make that clearer.
14:32:13 <kaol> > map pred "ibm"
14:32:15 <lambdabot>  "hal"
14:32:21 <rretzbach> omg
14:32:27 <sorear> good one!
14:32:32 <LoganCapaldo> it's a conspiracy
14:32:39 <dmhouse> rretzbach: hmm, you're sure it's that page? I don't see "pred" anywhere on that page.
14:32:45 <rretzbach> I bet you can even fiddle with 23 AND 42!
14:32:55 <sorear> > nubBy(((>1).).gcd)[2..]  -- obfuscated code sample of the day, rretzbach!
14:32:58 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
14:33:00 <LoganCapaldo> > map succ "vms"
14:33:03 <rretzbach> dmhouse: Oh, sorry I didn't understand your question then.
14:33:03 <lambdabot>  "wnt"
14:33:03 <kaol> a connection which was pointed out to A.C.Clarke after having written 2001. He says that the connection is accidental and he didn't think of it.
14:33:23 <rretzbach> I had enough samples in #ruby-de :DD
14:33:25 <dmhouse> rretzbach: well, presumably you saw "pred" somewhere on one of the Wikibook chapters and it confused you. Which chapter was that in?
14:33:33 <rretzbach> dmhouse: no
14:33:36 <rretzbach> I just saw it here.
14:33:39 <dmhouse> Okay.
14:33:42 <sorear> dmhouse: rretzbach didn't bring up pred
14:33:45 <rretzbach> And immeadiately asked.
14:33:48 <dmhouse> Ah, okay.
14:33:51 <sorear> 14:28 < kpreid> > map pred "new"
14:33:56 <rretzbach> !!
14:34:06 <sorear> rretzbach: ??
14:34:09 <kpreid> > "new" !! 1
14:34:10 <lambdabot>  'e'
14:34:11 <dmhouse> rretzbach: sorry for the misunderstanding :)
14:34:30 <rretzbach> dmhouse: np I just wasted some energie and oxygen.
14:34:42 <rretzbach> sorear: > ??
14:34:43 <dmhouse> rretzbach: feel free to drop any feedback on the Wikibook to wikibook@haskell.org.
14:34:43 <rretzbach> => 63
14:34:56 <rretzbach> Are you an author?
14:34:59 <sorear> rretzbach: I still don't get it.
14:35:11 <dmhouse> rretzbach: yes, I've written some of it (mostly the more advanced chapters).
14:35:59 <rretzbach> dmhouse: Well I aborted the gently tut from haskell org, because it was a bit hard to read for me.
14:35:59 <rretzbach> The wikibooks are easier as it seems.
14:35:59 <dmhouse> rretzbach: cool :)
14:36:24 <rretzbach> sorear: I just wanted to underline the fact that I indeed didn't start the pred-thingy with my two esclamation marks.
14:36:37 <sorear> rretzbach: Oh.
14:37:01 <rretzbach> The rest was pure confusion tactics.
14:37:09 <kpreid> are we all unconfused yet?
14:37:46 <rretzbach> Is kpreid a bot?
14:38:01 <sorear> haha
14:38:04 <dmhouse> kpreid: botsnack
14:38:10 <kpreid> :|
14:38:17 <rretzbach> kpreid: lart
14:38:36 <LoganCapaldo> I think we might need a blade runner
14:38:40 <sorear> no, kpreid is Kevin P. Reid, wrote @unpl
14:38:46 <LoganCapaldo> he could be faking it
14:38:48 <rretzbach> hi LoganCapaldo
14:38:51 <sorear> probably did something else with his life
14:38:56 <sorear> too
14:39:11 <LoganCapaldo> rretzbach: hi
14:39:12 <lambdabot> kpreid is definitely a bot
14:39:22 <lambdabot> As am I.
14:39:36 <rretzbach> So tell me: What would you guess is the percentage of on-topic questions in this channel?
14:39:40 * byorgey peeks behind the curtain...
14:39:46 <sjanssen> rretzbach: quite high
14:39:48 <sorear> rretzbach: Neglible
14:39:59 <rretzbach> If it's higher than 0.1 I'm off.
14:40:25 <sorear> rretzbach: try #haskell-blah then :)
14:40:31 <rretzbach> k
14:41:03 <LoganCapaldo> sorear: that's an anti-answer isn't it? Aren't _all_ questions on topic in -blah?
14:41:19 <rretzbach> No, haskell ones aren't. :\
14:41:49 <Cale> This channel is fairly on-topic, most of the time.
14:41:54 <sjanssen> sorear: the number of on-topic questions is negligible?
14:42:02 * sjanssen would say the opposite
14:42:18 <Cale> I'd say that at about 80% of the conversation is on-topic.
14:42:28 <Cale> Just as a guess :)
14:42:42 <rretzbach> What if haskell-blah didn't exist?
14:42:43 <sjanssen> even our off-topic conversations are somehow on-topic
14:44:13 <rretzbach> Why do I learn haskell btw?
14:44:42 <Cale> Isn't that something which only you could really answer?
14:44:45 <rretzbach> I just thought learning a logical(?) language would come in handy someday.
14:44:50 <LoganCapaldo> @check (\x y -> (x >= 0) && (y > 0) ==> x + y > x) :: Integer -> Property
14:44:51 <vincenz> Cale: any idea on my Q on -cafe?
14:44:57 <lambdabot>      The lambda expression `\ x y -> ...' has two arguments,     but its type...
14:44:59 <monochrom> Because someone whispers it into your ears every night.
14:45:04 <Cale> vincenz: I haven't been following -cafe. I'll have a look
14:45:05 <LoganCapaldo> @check (\x y -> (x >= 0) && (y > 0) ==> x + y > x) :: Integer -> Integer -> Property
14:45:07 <lambdabot>  Arguments exhausted after 317 tests.
14:45:13 <LoganCapaldo> loverly
14:45:15 <rretzbach> monochrom: Be honest, were you ever in my room?
14:45:21 <monochrom> Not me.
14:45:33 <sjanssen> the lambda fairy
14:45:43 <dmhouse> LoganCapaldo: sometimes thinking can solve inequalities for you, too! :)
14:46:11 <vincenz> Cale: I could jsut post my blog-link, it's all in there
14:46:24 <monochrom> YOu don't need x>=0 there.
14:46:32 <Cale> vincenz: ah, given two tensors A and B with rank M and N
14:46:33 <LoganCapaldo> dmhouse: I like to check my work.
14:47:27 <vincenz> nod
14:49:22 <Cale> vincenz: What do you mean by "cross multiplication"? Just what you've described there?
14:49:33 <vincenz> move to #oasis?
14:49:38 <Cale> sure
14:50:30 <hughperkins> Hi, trying to get fromConstrM to work, not doing very well :-(
14:51:21 <hughperkins> Does anyone have any hints or examples on getting it to work?
14:51:55 <hughperkins> I've looked at the source to gread,which is using ReadP, but for my own use it looks like I need my own monad?
14:52:30 <hughperkins> Maybe could work using a List???
14:52:38 <kpreid> well
14:53:29 <rretzbach> Can someone explain the term "monad" to me in less than two words?
14:53:41 <dmhouse> No.
14:53:43 <SamB_XP> thing!
14:53:45 <dmhouse> How's that?
14:53:46 <hughperkins> "no way"?
14:53:47 <kpreid> > evalState (Data.Generics.fromConstrM (do r <- gets head; modify tail; r) (Data.Generics.toConstr ("a","b"))) ["c","d"]
14:53:49 <sorear> rretzbach: Structure
14:53:54 <SamB_XP> hughperkins: that's not less than two words
14:53:55 <lambdabot>      Occurs check: cannot construct the infinite type: s = [State s a1]
14:53:55 <lambdabot>      ...
14:53:59 <SamB_XP> that's exactly two words
14:54:01 <hughperkins> Heh! :-)
14:54:01 <rretzbach> sorear: I see.
14:54:03 <monochrom> "monad" in one word is "monad".
14:54:12 <kpreid> > evalState (Data.Generics.fromConstrM (do r <- gets head; modify tail; return r) (Data.Generics.toConstr ("a","b"))) ["c","d"]
14:54:13 <lambdabot>      Inferred type is less polymorphic than expected
14:54:13 <lambdabot>       Quantified type va...
14:54:23 <rretzbach> monochrom: Your recursiveness melts my mind.
14:54:37 <dmhouse> rretzbach: you'll come on to monads at some point. Don't worry :) They're hard to get your head around, but on the upshot, there are as many tutorials as you could read in a lifetime about them...
14:54:48 <monochrom> Well, you impose impossible restrictions.
14:55:03 <SamB_XP> rretzbach: how about I just use this: ""
14:55:04 <rretzbach> Yes I do.
14:55:06 <monochrom> I recommend a thousand examples instead of any number of words.
14:55:10 <SamB_XP> is that few enough words for you?
14:55:10 <rretzbach> Impossible in *your* world.
14:55:29 <kpreid> > evalState (Data.Generics.fromConstrM (do r <- gets head; modify tail; return (cast r)) (Data.Generics.toConstr ("a","b"))) ["c","d"]
14:55:29 <monochrom> How about you explain to me OOP in one word?
14:55:29 <rretzbach> monochrom: Yes, I will read slowly through the books.
14:55:30 <lambdabot>   return (cast r)
14:55:33 <SamB_XP> that, and "monadlaws"
14:55:45 <DRMacIver> Monads are only hard to get your head around if you try to get your head around them. :)
14:55:48 <kpreid> > evalState (Data.Generics.fromConstrM (do r <- gets head; modify tail; return (Data.Typeable.cast r)) (Data.Generics.toConstr ("a","b"))) ["c","d"]
14:55:49 <rretzbach> monochrom: object
14:55:49 <lambdabot>   return (cast r)
14:55:49 <hughperkins> A monad is something like a way of transferring state across sequenced operations.  (Thats coming from a total newbie, so take with a pinch of salt)
14:55:56 <kpreid> hmf
14:56:06 <sorear> rretzbach: If you are familiar with the concept of a mathematical structure (group, field, bounded semilatice, ...) just remember that a monad is one too.
14:56:07 <rretzbach> monochrom: please send the money per paypal
14:56:23 <rretzbach> sorear: I only had math in school.
14:56:24 <edward1> monad in 2 words, "indivisible concept"? er wait, wrong monad.
14:56:26 <kpreid> hughperkins: I've forgotten how to make this stuff work, but all you need is an action that'll return one of the fields each time it's invoked
14:56:30 <monochrom> well see, "object" itself doesn't say much.
14:56:56 <SamB_XP> rretzbach: have you seen the monad laws?
14:57:02 <sjanssen> > length . words $ "The Monad class is an abstract interface to many models of computation"
14:57:05 <lambdabot>  12
14:57:07 <hughperkins> kpreid, ok...
14:57:17 <rretzbach> I know monad was a codename for the powershell, but that's it.
14:57:26 <SamB_XP> rretzbach: that's not a law
14:57:31 <rretzbach> Then no.
14:58:04 <monochrom> Before I learned OOP, (but definitely after I learned structured programming), "object" was only as in "object-verb-subject" grammar.
14:58:19 <monochrom> So do you mean OOP is about grammar?
14:58:26 <rashakil> OOP in one word is "oops"
14:58:29 <edward1> rretzbach: yeah but i think the monad in question behind powershell was the 'indivisible unit of thought' from liebniz's monadology, not quite the same thing.
14:58:40 <SamB_XP> monochrom: you never heard of a physical object?
14:58:42 <SamB_XP> like a chair?
14:58:55 <rretzbach> monochrom: Are you a bot with a serious bug in the humor module?
14:59:00 <edward1> s/liebniz/leibniz/
14:59:02 <DRMacIver> monochrom: "object" has the advantage that people think they understand objects, so by the time they realise that they don't they have a chance of knowing what it actually means. :)
14:59:04 <SamB_XP> or... an unidentified flying object?
14:59:08 <rretzbach> edward1: could be
15:00:05 <rretzbach> I think most people don't know how abstract the word object is.
15:00:09 <monochrom> No, I have only heard of a physical thing, an unidentified flying thing, ...  Are you saying OOP is about "thing"?
15:00:10 <SamB_XP> monad from Category Theory is badly named
15:00:13 <sorear> @remember rashakil OOP in one word is "oops"
15:00:13 <lambdabot> Done.
15:00:16 <edwardk> rretzbach: basically a monad is a really useful concept stolen from an obscure bit of mathematics called category theory. it states some laws that can be used to reason about your program if the idea in question is a monad. since SOOO many things are monads, this is a powerful concept.
15:00:25 <DRMacIver> 'obscure'?
15:00:31 <SamB_XP> monochrom: heh
15:00:34 <DRMacIver> You can't get away from the bloody stuff.
15:01:03 <monochrom> To paraphrase from some troll, "obscure" in your world.
15:01:05 <edwardk> it is something that lets you apply those laws equally well to processing lists, to performing IO, to transactions, to carrying extra state in computations, to reading from an environment, etc.
15:01:25 <edwardk> thats why the '1000 examples' is usually the way people finally grok what a monad is.
15:01:39 <edwardk> because its so ubiquitous in the things you use, that its hard to spot what makes it special.
15:01:43 <SamB_XP> DRMacIver: for some reason it seems to be obscure, in terms of who knows about it who isn't a Haskell users
15:01:56 <hughperkins> kpreid, which module does modifytail come from?
15:02:05 <DRMacIver> SamB_XP: Hm. I'd qualify that with "or actually a mathematician" :)
15:02:08 <rretzbach> edwardk: I don't understand what a monad is exactly, but I understood what you said :>
15:02:14 <rretzbach> Is that wrong? :\
15:02:18 <kpreid> @index modify
15:02:18 <lambdabot> Control.Monad.State, Control.Monad.RWS
15:02:20 <SamB_XP> a better question than "what is a monad?" is "what can a monad do for me?"
15:02:21 <kpreid> @index tail
15:02:21 <lambdabot> Data.List, Prelude
15:02:50 <monochrom> No one "understands" numbers "exactly", to put things into perspective.
15:02:51 <hughperkins> Ah, I removed a space in copy/paste :-D
15:02:53 <DRMacIver> (Or a string theorist apparently, but they're just a weird type of pure mathematician)
15:02:58 <SamB_XP> DRMacIver: I don't know too much about that
15:03:04 <sorear> monochrom: Do trolls ever make their real names this obvious?
15:03:22 <rretzbach> monochrom: Maybe you see now why I restricted the number of words for a description :)
15:03:26 <SamB_XP> but, ask the average college student if they've even heard of it?
15:03:36 <ddarius> Most mathematicians don't care about monads.
15:03:40 <ddarius> Explicitly.
15:03:48 <DRMacIver> ddarius: I meant category theory, not monads.
15:04:16 <SamB_XP> I, too, meant category theory
15:04:32 <ddarius> DRMacIver: s/monad/Category Theory, it still holds.
15:04:36 <edwardk> rretzbach: a monad in category theory is a special kind of 'functor', a functor is something that maps arrows in one category to arrows in another category. arrows in a category act a lot like functions, so a functor is a sort map from functions to functions that maintains a certain structure.
15:04:46 <DRMacIver> ddarius: I don't buy it. The damn stuff is everywhere these days.
15:05:05 <edwardk> if you've done much functional programming in other languages 'map' is the way you apply a list functor. you take something that transforms elements of some type to another, and you get back a function that transforms a list of those elements to a list of the result
15:05:07 <hughperkins> kpreid, can you recommend any tutorials or examples that could help me learn how to use actions?  I'm not really sure where to begin.
15:05:27 <DRMacIver> ddarius: It's hard to turn around in any subject within a stones throw of algebra, number theory, geometry, etc. without finding a functor looming over you.
15:05:28 <rretzbach> edwardk: it becomes clearer
15:05:29 <ddarius> DRMacIver: Everywhere you're looking. It can be applied practically everywhere doesn't mean the people in those areas use it.
15:05:39 <dmhouse> rretzbach: don't worry about Category Theory for now, that's another advanced-Haskell topic that you could come on to when/if you want. (Incidentally, I wrote the Wikibook chapter on Category Theory :))
15:05:48 <hughperkins> kpreid, basically I can get a list of the values of the fields, their names etc, but I've no idae how to parse those into the fromConstrM
15:05:50 <kpreid> hughperkins: er, action is just a word for something of type Monad m => m a
15:05:59 <rretzbach> dmhouse: Yeah, no need to rush.
15:06:02 <ddarius> dmhouse: That's not an "advanced Haskell" topic.  It's not a Haskell topic.
15:06:09 <rretzbach> heh
15:06:11 <edwardk> a functor is a useful tool, but it only gives you a couple of laws you can rely on. add a couple more functions to move things into and to manipulate things in the monad and you get a monad, where you have a whole host of laws that you can use to reason about simplifying calculations.
15:06:29 <dmhouse> ddarius: it's not a topic that's specific to Haskell, but it's a "Haskell topic" in that it's related to Haskell, which is what I meant.
15:06:37 <DRMacIver> ddarius: I'm fully aware that there are areas that don't need it. Most of my preferred ones don't. :) But the 'cool' modern areas increasingly use it.
15:06:43 <rretzbach> edwardk: sounds rather complex to me
15:06:49 <hughperkins> kpreid, Ok :-)   Well I've been playing with Reader and stuff, but there's a big gap between a Reader and what I need here?
15:06:53 <ddarius> dmhouse: As DRMacIver has said, it's related to practically everything remotely related to mathematics.
15:06:57 <edwardk> a good layman explanation of a monad is that it is like a wrapper you can put an object in, and then you can pass in functions that can manipulate the object, but it always hands it back to you wrapped.
15:07:02 <SamB_XP> rretzbach: that's because he hasn't told you the rules, probably...
15:07:03 <rretzbach> But often complex things make other things easier :>
15:07:05 <edwardk> rretzbach: it, unfortunately, is =)
15:07:38 <edwardk> @type fmap
15:07:41 <lambdabot> forall a b (f :: * -> *). (Functor f) => (a -> b) -> f a -> f b
15:07:47 <hughperkins> edwardk, thats a pretty good explanation :-)  I can understand taht :-)
15:08:08 <dmhouse> ddarius: other domains may _use_ CT, but you can actually explain CT in terms of Haskell structures. I think that's pretty different.
15:08:26 <ddarius> dmhouse: No you can't.
15:08:50 <edwardk> that definition there says that fmap is a function that takes an arbitrary functor, and a function from a -> b, and returns a function from f a -> f b, basically transforming a function into a function that manipulates something 'wrapped' in the functor.
15:08:54 <edwardk> @type map
15:08:57 <DRMacIver> SamB_XP: RE your comment about college students, I don't think "your average college student" is a good metric of obscurity in anything except brands of booze. :) I think if you qualified it to "Your average college student midway through a mathematics degree and not failing" they'd have a good chance of knowing what category theory was.
15:08:57 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
15:09:01 <edwardk> map is basically fmap specialized to lists
15:09:03 <ddarius> dmhouse: And you can explain it in terms of Set theory, algebra, geometry, topology etc. to the extent you can with Haskell.
15:09:09 <hughperkins> kpreid, I guess I somehow need to create a Monad that takes a list of the information about the fields, then lops off a field one at a time and returns it?  Course in practice I've no idae how to do that :-/
15:09:27 <kpreid> > evalState (Data.Generics.fromConstrM (do r <- gets head; modify tail; return ((fromJust . cast) r)) (Data.Generics.toConstr ("a","b"))) ["c","d"] :: (String, String)
15:09:29 <lambdabot>  ("c","d")
15:09:41 <kpreid> hughperkins: there, working example. maybe you can work from that
15:09:44 <edwardk> now, a monad lets you put something IN to the monad
15:09:46 <edwardk> @type return
15:09:47 <dmhouse> ddarius: you just said two contradictory things.
15:09:49 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
15:09:58 <hughperkins> Hmmm, interesting, let me play with that, and figure out what it does :-D
15:09:58 <monochrom> The number of words depends solely on the reader's education background. (Clearly.) There is was a South American civilization whose number system was only "one, two, many". You can't even explain the concept of "three" to them in "many" words. Yes, I'm saying when you learn monads you're like that tribe trying to learn three. It will be a lot of work because it's a leap.
15:10:12 <ddarius> dmhouse: Not too much.
15:10:30 <edwardk> i.e., given a value of any type, you can always generate a list of that type, just by creating the singleton list that contains only that element, so, so far a list meets the laws.
15:10:33 <DRMacIver> Best one word definition of a monad I can come up with: Fuggedaboutit.
15:10:52 <LoganCapaldo> monochrom: Monads are _that much_ of a leap? You're making me wonder if I need to go back and completely reexamine my understanding of them.
15:11:09 <dmhouse> DRMacIver: I have to say I'm quite a fan of the 'thingymajigger' school of thought.
15:11:11 <edwardk> and it lets you munge some things together with the rather scary 'bind' function: (>>=)
15:11:15 <DRMacIver> Clarification: You'll figure out what they actually mean when you need to. Until then, not worth the bother. :)
15:11:20 <edwardk> @type (>>=)
15:11:23 <lambdabot> forall (m :: * -> *) a b. (Monad m) => m a -> (a -> m b) -> m b
15:11:29 <DRMacIver> dmhouse: Yes, variants on "thingummy" come a close second. :)
15:11:32 <ddarius> One word explanation of monad: "spacesuit"
15:11:35 <ddarius> There you go.
15:11:50 <DRMacIver> Two word explanation of monad: "Analogies suck". ;)
15:11:55 <rretzbach> ddarius: thanks.
15:12:02 <rretzbach> Now it's easy to grasp.
15:12:05 <rretzbach> And even to remember!
15:12:24 <Botje> three word explanation: "monads are functors"
15:12:28 <Botje> or: "warm fuzzy thing"
15:12:38 <shapr> edwardk: I've already been distracted into writing parsers instead of doing MtG stuff :-)
15:12:40 <hughperkins> kpreid, ok, so you're getting the constructor for a pair ,which has 2 children, then - somehow - creating a monad that pumps out the constructors for the children?
15:12:48 <ddarius> rretzbach: http://koweycode.blogspot.com/2007/01/think-of-monad.html
15:12:49 <lambdabot> Title: koweycode: think of a monad...
15:13:04 <dmhouse> Botje: "monads are functors" doesn't really explain them, though. "Monads are functors with two specific natural transformations such that these diagrams commute", pethaps.
15:13:04 <edwardk> bind says, if i have something in my monad (m a), and a function that could take that value if it wasn't in the monad (a -> m b) that would give me back something else  in my monad, i know how to combine them to actually get the (m b) out.
15:13:12 <ddarius> Botje: Monads are more than functors.  "Squares are rectangles."
15:13:14 <kpreid> hughperkins: it's the state monad, with the state being a list which it walks down
15:13:29 <LoganCapaldo> @type gets
15:13:32 <lambdabot> forall s a (m :: * -> *). (MonadState s m) => (s -> a) -> m a
15:13:35 <hughperkins> Ok, cool, that sounds like exactly perfectly what I'm looking for :-)
15:13:56 <monochrom> Hey, while we are at it, what is "internet" in one word?
15:13:58 <edwardk> so, back to lists, for a second, if i have a list of values, and a function that takes values of the type contained in the list and returns me a list of values, if i just concatenated all those results, i'd get a new list
15:14:05 <ddarius> monochrom: tubes
15:14:10 <edwardk> @type concatMap
15:14:12 <lambdabot> forall a b. (a -> [b]) -> [a] -> [b]
15:14:17 <edwardk> er
15:14:21 <edwardk> @type flip concatMap
15:14:23 <lambdabot> forall a b. [a] -> (a -> [b]) -> [b]
15:14:32 <dmhouse> monochrom: procrastination.
15:14:38 <ddarius> distraction
15:14:42 <edwardk> flip concatMap is just (>>=) specialized to lists.
15:14:47 <kpreid> note that in a real use case, the fromJust.cast probably shouldn't exist, or should look like something else. that's there because I'm working from a monomorphic list. if you already have other generic-stuff then it probably won't have that sort of type
15:14:52 <cdtw> @type do { return "x"; }
15:14:54 <lambdabot> forall (t :: * -> *). (Monad t) => t [Char]
15:15:25 <DRMacIver> monochrom: memepool.
15:15:41 <hughperkins> kpreid, ok
15:15:42 <edwardk> so, basically a monad is a functor with 'return' and '>>=' with a few laws on how return and >>= interact.
15:16:58 <rretzbach> ddarius: this is hilarious.
15:17:00 * edwardk watches rretzbach fall asleep in the corner.
15:17:22 <ddarius> edwardk: I interneted him with the internet.
15:17:23 <rretzbach> I will go to bed in 15 minutes :>
15:17:42 <rretzbach> A hard day of ugly code awaits me.
15:19:40 <monochrom> LoganCapaldo: I'm thinking it's a great leap not just in idea but also in attitude. (Attitude greatly affects learning: for most people, if they don't see a need, they have a mental block.)  That tribe clearly have seen ample examples of three fish, three trees, three people, ...  that they still didn't develop their "three" seems to suggest that they couldn't care less. If you are to teach them "three", 99% of you effort wil
15:19:40 <monochrom> l be in convincing them why they should care.
15:21:04 <LoganCapaldo> monochrom: I see. Well I care so hopefully I don't have a totally distorted understanding. :)
15:21:26 <cdtw> I remember when I was trying to understand monads, my real problem was seeing why I couldn't just use function composition on functions that took the "state" parameter (or whatever) as an argument, and returned it in a touple with their result... (the point of using the type system to make sure they always actually did this was lost on me, I think. It is possible I still do not fully understand the difference, of course.)
15:21:56 <cdtw> So I guess my "lack of need" perception did form a mental block.
15:22:19 <Saizan> i'm always surprised by how much >>= can be lazy.. i don't really grasp how the evaluation happens
15:22:35 <rretzbach> Is there any sense in the space suit diagram?
15:22:54 <bos> rretzbach: only if there are apples inside
15:23:21 <edwardk> one of the few times i found paul graham to be spot on was when he said something about how people don't see the point of a programming language more powerful than their own. one might generalize this to say that people don't see the need for an abstraction more powerful than the one they are using.
15:23:54 <rretzbach> Now it becomes more and more philosophical
15:24:13 <edwardk> the irony of course, is that paul graham doesn't seem to see the point of types, because he spends all his time in lisp ;)
15:24:22 <rretzbach> lol
15:24:23 <monochrom> There is some made-up statistics that says only 60% of people gets the spacesuit analogy. I'm in the other 40%. Maybe you're too. Don't sweat over analogies --- they certainly work well for their authors but no authors of analogies ever perform any large-scale usability study.
15:24:36 <cdtw> edwardk: that strikes me as corrolary to Dijkstra's observation that the abstractions we use shape the way we think...
15:25:12 <rretzbach> monochrom: :)
15:25:15 <Botje> my view of monads: ignore the damn category theory and just use them.
15:25:39 <monochrom> edwardk: I think you nail it, the abstraction part.
15:25:40 <edwardk> cdtw: yeah, which goes back pretty much to the sapir-wharf hypothesis in linguistics that says language shapes the thoughts we can think
15:25:42 <sioraiocht> Botje: that works for most people, others just find the category theory any easy way to visualise them
15:26:27 <Botje> hmm, i guess
15:26:31 <LoganCapaldo> I didnt get any of the analogies really. I "got" monads after I "got" how to work out what type an expression had, logically
15:26:37 * ddarius understands the category theory and doesn't visualize monads at all.
15:26:53 <rretzbach> hehe
15:27:05 <nornagon> is there any way to uninstall Cabalized packages?
15:27:13 <Saizan> yeah, a firm understanding of typeclasses is crucial
15:27:37 <monochrom> nornagon: ghc-pkg unregister, then you can go hunt down and delete files safely.
15:28:00 <edwardk> i find that having three different ways to think about monads: as a useful programming hack involving data structures, as a logical necessity modality via the curry howard correspondence, and as a categorical concept expressing the existence of certain laws, really helps me find uses for them.
15:28:04 <pastorn> i just came back... could someone tell me what the space suit anology is?
15:28:12 <edwardk> the problem is you can't expect everyone to embrace all 3 =)
15:28:52 <monochrom> "monad is like space suit"
15:29:06 <pastorn> ehm...
15:29:07 <rretzbach> Do you think that there are also people who want to create a new plateau by creating a higher abstraction to distance themselves from others?
15:29:10 <edwardk> basically you can't take it off ;)
15:29:26 <nornagon> :t unsafePerformIO
15:29:32 <lambdabot> Not in scope: `unsafePerformIO'
15:29:39 <nornagon> nifty answer, sorry I asked.
15:29:45 <kpreid> :t Foreign.unsafePerformIO
15:29:47 <lambdabot> forall a. IO a -> a
15:29:50 <edwardk> rretzbach: you could argue that, but to be quite honest a monad has been a very effective abstraction for dealing with side-effects, and for a lot of the plumbing that you have to deal with explicitly and can screw up by accident in a lazy language.
15:29:54 <monochrom> rretzbach: yes, and for good reasons too.
15:30:03 <DRMacIver> Personally, I create higher abstractions to distance myself from the version of me that didn't understand the problem. :)
15:30:05 <LoganCapaldo> you might be able to take it off but, your not guaranteed to be able to take it off
15:30:46 <monochrom> (I certainly want to distance myself from most slashdot post writers, for example. I think we all do.)
15:30:47 <edwardk> DRMacIver: hehe
15:31:04 * DRMacIver is moderately serious.
15:31:11 <monochrom> Oh DRMacIver's is a better point.
15:31:12 <DRMacIver> Which is about as serious as I ever get. :)
15:31:22 <edwardk> rretzbach: besides, i don't use monads to try to distance myself from others, i use comonads for that ;)
15:31:29 <rretzbach> lol
15:32:16 * DRMacIver hasn't bothered figuring out why comonads are useful yet. :)
15:32:23 <DRMacIver> Except that presumably e-> is one.
15:32:43 <DRMacIver> (Or do I have that the wrong way round?)
15:33:03 <dmhouse> ((->) a) is a monad.
15:33:05 <dmhouse> (It's Reader.)
15:33:06 <edwardk> dr: (,)e is one
15:33:18 <LoganCapaldo> well ->e is the monad, and by the law of over simplifying things, e-> must be the comonad :)
15:33:37 <monochrom> Some people really behave like "I have graduated, I'm an adult, I will no longer learn anything". They probably don't even know it; it may be subconscious. It applies to programming, relationships, everything in life.  But a few people continues to look for new things to learn and improve. They will have to create new abstractions.
15:33:37 <DRMacIver> That was roughly my reasoning, yes. ;)
15:33:38 <dmhouse> LoganCapaldo: (-> e) isn't a monad.
15:34:04 <dmhouse> (Well, it isn't Reader. I suppose it might be a monad.)
15:34:05 <edwardk> logan, nah, the categorical opposite is (,)e through the hom-prod adjunction
15:34:07 <LoganCapaldo> dmhouse: sorry.
15:34:21 <rretzbach> Even TV shows tell me to never stop learning, otherwise my brain will rot much faster.
15:34:22 <LoganCapaldo> got all excited about munging symbols and making jokes
15:34:26 <DRMacIver> Oh, hm.
15:34:37 <edwardk> and (->e) can't be a monad because it is a contravariant functor.
15:35:10 <edwardk> its map has a type like opmap :: (a -> b) -> f b -> f a when you work it out.
15:35:32 <LoganCapaldo> that doesn't seem to compute :)
15:35:37 <glguy> Is there some way to make this possible: case x of This -> Just 'a'; That -> Just ""; _ -> Nothing   -- such that the type would become Maybe a where you couldn't get at what the Maybe might contain?
15:35:58 <Botje> I think the average word length in #haskell is higher than that of #java. even despite their love for long identifiers.
15:36:06 <dmhouse> glguy: existentials?
15:36:27 <edwardk> logan: take f = (->e), then, opmap :: Functor f =>  (a -> b) -> f b -> f a  = opmap :: (a -> b) -> (a -> e) -> b -> e
15:36:31 <glguy> dmhouse: yeah, but would I have to define a new data type with a universally qualified field?
15:36:34 <rretzbach> Botje: Is #java a french channel?
15:36:43 <dmhouse> glguy: if I understand you correctly: data S = forall a. S a; case x of This -> Just (S 'a'); That -> Just (S ""); _ -> Nonthing
15:36:45 <edwardk> er
15:36:45 <dibblego> rretzbach, ##java (no)
15:36:50 <edwardk> i typoed that somehow
15:36:54 <glguy> dmhouse: yeah
15:36:56 <Botje> rretzbach: should it be? :)
15:37:00 <rretzbach> ;)
15:37:09 <dmhouse> glguy: yes, because the only way to get existential types in Haskell is the mixture of datatypes and universal quantifiers.
15:37:19 <LoganCapaldo> edwardk: I just don't get how you go from a -> b to f b -> f a w/o some magic "reverse function" operation
15:37:19 <glguy> Just , just checking :)
15:37:26 <edwardk> ah i see what i screwed up
15:37:43 <edwardk> opmap :: (a -> b) -> (b -> e) -> (e -> a)
15:37:46 <edwardk> @type (.)
15:37:51 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
15:37:52 <dmhouse> It'd be nice to have some sugar to automatically define an existential box for a given set of constraints.
15:37:54 <LoganCapaldo> but you guys are using lot's of big words I don't know now
15:37:57 <edwardk> @type flip (.)
15:38:01 <lambdabot> forall b c a. (a -> b) -> (b -> c) -> a -> c
15:38:23 * Botje thinks it's time for #haskell-smallwords
15:38:23 <edwardk> gah i typoed again
15:38:35 <edwardk> opmap :: (a -> b) -> (b -> e) -> (a -> e)       there =)
15:38:46 <Saizan> opmap f g = g . f
15:38:55 <dmhouse> edwardk: is there such thing as a contravariant monad, then?
15:39:00 <edwardk> logan: the issue is the side of the arrow
15:39:26 <LoganCapaldo> so f = -> e in this example?
15:39:31 <edwardk> dmhouse: afaik no, but i just don't recall seeing anyone work up an analogous concept.
15:39:49 <LoganCapaldo> that makes sense
15:40:01 <dmhouse> edwardk: right, so "no, because we haven't found a use for them"?
15:40:09 <emu> ?djinn (a -> b) -> b -> a
15:40:09 <lambdabot> -- f cannot be realized.
15:40:30 <edwardk> @djinn-env type OpReader e a = e -> a
15:40:30 <lambdabot> data () = ()
15:40:30 <lambdabot> data Either a b = Left a | Right b
15:40:30 <lambdabot> data Maybe a = Nothing | Just a
15:40:30 <lambdabot> data Bool = False | True
15:40:30 <lambdabot> data Void
15:40:32 <lambdabot> type Not x = x -> Void
15:40:33 <edwardk> er
15:40:34 <lambdabot> class Eq a where (==) :: a -> a -> Bool
15:40:42 <edwardk> @djinn-add type OpReader e a = e -> a
15:41:05 <edwardk> @djinn (a -> b) -> OpReader e b -> OpReader e a
15:41:05 <lambdabot> -- f cannot be realized.
15:41:09 <dmhouse> You mean type OpReader = a -> e?
15:41:09 <edwardk> gah, i suck
15:41:11 <edwardk> yeah
15:41:37 <edwardk> @djinn-add type OpReader' e a = a -> e
15:41:45 <dmhouse> ?djinn-del OpReader
15:41:46 <edwardk> @djinn (a -> b) -> OpReader' e b -> OpReader' e a
15:41:46 <lambdabot> f a b c = b (a c)
15:41:49 <edwardk> there =)
15:42:06 <dmhouse> ?djinn-env
15:42:06 <lambdabot> data () = ()
15:42:06 <lambdabot> data Either a b = Left a | Right b
15:42:06 <lambdabot> data Maybe a = Nothing | Just a
15:42:06 <lambdabot> data Bool = False | True
15:42:06 <lambdabot> data Void
15:42:08 <lambdabot> type Not x = x -> Void
15:42:10 <lambdabot> class Eq a where (==) :: a -> a -> Bool
15:42:12 <lambdabot> type OpReader' e a = a -> e
15:42:54 <dmhouse> Go theorem provers! Now, what does the contravariant reader represent under Curry-Howard? :)
15:44:20 <bct> if i have a class X that inherits Show, can i define 'show' in the class so that all types that derive X are shown with that function?
15:44:32 <bct> or do i need to define 'show' on every type that derives X?
15:44:35 <LoganCapaldo> dmhouse: a implies b implies (not a implies not b) ?
15:44:40 <rretzbach> lol I just thought looking up "contravariant" in wiki would help.
15:44:41 <edwardk> dmhouse: well, if e is Bool, then given a function from values of type a to values of type b it maps it to predicates on type b to predicates on type a
15:44:43 <rretzbach> It surely did not.
15:45:23 <edwardk> rretzbach: the idea of contravariance is probably best explained in terms of c++-style OOP.
15:45:47 <dmhouse> bct: show is inherantly tied to the Show class. You can't 'move' it to a class you define.
15:45:50 <edwardk> rretzbach if you subclass a class, you can redefine a method on that class to 'accept more things' and 'promise more'.
15:46:25 <edwardk> in otherwords, you can return a 'more specific type' in your result if you are a 'more specific type', so the result varies 'covariantly'
15:46:43 <ddarius> You can make a monad built out of (->a) via the (self-)adjunction (->a)^op -| (->a)
15:47:21 <edwardk> and the opposite side of the coin is that you can choose to accept a 'more general' type, than your parent class's version of the method did, so the arguments to a function vary 'contravariantly'
15:47:36 <sorear> @users
15:47:36 <lambdabot> Maximum users seen in #haskell: 338, currently: 314 (92.9%), active: 26 (8.3%)
15:48:40 <rretzbach> edwardk: That was fairly easy.
15:48:52 <dmhouse> ddarius: is it a contravariant monad?
15:48:53 <rretzbach> wiki scared me with tex like formulas :\
15:49:25 <bct> dmhouse, so even if i have several types with identical structures i need to define identical 'show's for each of them?
15:49:32 <edwardk> this gives rise to a kind of paradox in object oriented type hierarchies, i.e. if you want 'child' to be a subtype of person, and you want to specialize baby-food and food, so that children can only eat baby-food, while people can eat any food, then 'baby-food' has to be a parent type of 'food', it can't be a subtype! that would require the arguments of a function to be able to vary covariantly.
15:49:33 <ddarius> dmhouse: No, when you compose a contravariant functor with itself (or more precisely, it's opposite) you get a covariant functor.
15:49:54 <ddarius> dmhouse: There is no such thing as a contravariant monad because monads (in Cat) are endofunctors.
15:49:58 <dmhouse> ddarius: oh, so you mean that (->a) itself isn't a monad? I'm not too familiar with adjunctions.
15:50:25 <ddarius> dmhouse: All adjunctions give rise to a monad, and in fact, some "common" ones give rise to very familiar monads.
15:50:53 <dmhouse> ddarius: could you give a one-sentence summary of adjunctions? Just to jog m memory.
15:50:54 <rretzbach> edwardk: Yes, it usually takes 20 years before a child knows more than its parents ;)
15:51:07 <ddarius> dmhouse: Do you know what hom-functors are?
15:51:17 <Vulpyne> But they think they do after 12. :)
15:51:21 <sorear> ddarius: What's skolemization again?
15:51:26 <Cale> A monad and a comonad.
15:51:38 <dmhouse> ddarius: roughly.
15:51:50 <dmhouse> bct: not necessarily, you could create a class which all your types instantiate, and then have instance YourClass s => Show s
15:51:52 <monochrom> bct: how did you arrive at this state of several types with identical structures? Perhaps you should refactor, e.g., unify those several types. (Then, to make them look different for the type checker, use "newtype X = X Unified deriving Show".)
15:52:03 <edwardk> rretzbach: that said, there have been attempts to go the other way to get the more 'intuitive' model, the language eiffel uses 'covariant' subtyping on function arguments, which forces it to jump through all sorts of hoops to compile it right and to deal with all sorts of runtime errors, when you try to feed people baby-food, or make a bag of birds that includes an ostrich 'fly' =)
15:52:06 <Cale> sorear: Removing existential quantifiers from a formula
15:52:29 <ddarius> sorear: What the?!  forall x. exists y. R(x,y) <=> exists f. forall x. R(x,f(x))
15:52:34 <rretzbach> edwardk: lol?
15:52:47 <edwardk> poor ostrich.
15:53:08 <Cale> http://planetmath.org/encyclopedia/Skolemization.html
15:53:10 <lambdabot> Title: PlanetMath: Skolemization
15:53:28 <ddarius> dmhouse: F -| U (F is left adjoint to U) iff \X Y.Hom(FX,Y) ~ \X Y.Hom(X,UY) where ~ means naturally isomorphic.
15:53:45 <sorear> ty.
15:54:27 <hughperkins> can someone remind me how to do default in case of please?
15:54:35 <Cale> hughperkins: _
15:54:42 <edwardk> _ -> error "my cow is on fire"
15:54:43 <ddarius> dmhouse: Alternatively you can see as two dual cases of (parameterized) representability.
15:54:49 <hughperkins> Hmmm tried that, ok, must be a different problem, thansk :-)
15:54:56 <ddarius> edwardk: Oh noes!
15:55:06 <emu> edwardk: bbq!
15:55:07 <Cale> !paste
15:55:07 <hpaste> Haskell paste bin: http://hpaste.org/
15:55:08 <edwardk> hughperkins: make sure the _ is lined up with the left hand side of the other cases
15:55:19 <Cale> hughperkins: paste the code and we can have a look :)
15:55:24 <ddarius> Hmm... ...
15:55:38 <hughperkins> What is paste url?
15:55:46 <hughperkins> Oh, you did it already :-)
15:55:56 <rretzbach> Good night, thanks for the warm welcome, I enjoyed my stay.
15:56:03 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/402
15:56:05 <edwardk> glad to have you rretzbach
15:56:08 <hughperkins> http://hpaste.org/402
15:56:14 <monochrom> In ancient Chinese history there was a battle won by setting bulls on fire and driving it towards the enemy.
15:56:39 <edwardk> dataTypeOf ?
15:56:41 <hpaste>  @yow pasted "yay abuse" at http://hpaste.org/403
15:56:45 <ddarius> Darn
15:57:03 <Cale> hughperkins: yeah, that first thing isn't a pattern
15:57:10 <hughperkins> Ah
15:57:10 <emu> monochrom: how flammable is your avg bull?
15:57:13 <hughperkins> needs to be in a let?
15:57:29 <Cale> hughperkins: Well, I'm not really sure what you mean by that
15:57:59 <monochrom> Not very flammable, but the commander added fuel to the bulls.
15:58:16 <ddarius> Like cow dung?
15:58:23 <monochrom> Like oil.
15:58:25 <Cale> If dataTypeOf is one of your functions, and you expect that it should return the constructor you want to match against, you should just write that constructor in that place.
15:58:40 <emu> hence the origin of the term "flaming bull shit"
15:58:42 <ddarius> That's not very sustainable.
15:58:45 <Cale> something like VInt or some such
15:58:51 <hughperkins> well... trying to make a polymorphic function that will correctly cast value according to its data type
15:58:57 <hughperkins> For now, if it works for int and string its ok
15:59:06 <hughperkins> I can only get it working for string for now :-/
15:59:21 <Cale> hughperkins: oh, if you need to do something different based on the type of a parameter, you need a typeclass
15:59:37 <monochrom> The idea was to get the bulls painful and roam like crazy, and also to set fire on enemy camps.
15:59:41 <Cale> Then instances of that class for each type you want to support.
15:59:55 <hughperkins> and that will be polymorphic?
16:00:01 <edwardk> hughperkins: one thought would be to say something like data Wrapped = Wrapped Int | Wrapped String
16:00:03 <Cale> Well, bounded polymorphic
16:00:03 <ddarius> And then have a nice meal after the enemy is defeated.
16:00:17 <Cale> It'll be something like (MyClass a) => a -> Foo
16:00:18 <edwardk> er
16:00:22 <bct> monochrom, thanks, that cleared things up
16:00:26 <edwardk> data Wrapped = WrappedInt Int | WrappedString String
16:00:35 <Cale> Or you can do that :)
16:00:41 <edwardk> then case datatype of WrappedInt i -> ...; WrappedString s -> ...
16:00:55 <hughperkins> The type of the function needs to be (forall a . Data a) => String -> a
16:01:12 <Cale> also, what's with this 'cast' thing?
16:01:16 <Cale> ah
16:01:18 <edwardk> now we're getting to the meat of things.
16:01:29 <hughperkins> i'm trying to parse xml to a haskell object
16:01:48 <monochrom> HaXML
16:01:49 <hughperkins> I've got as far as parsing the field values from the xml, and the fieldnames and datatypes from the haskell data type
16:01:59 <hughperkins> no no haxml needs a DTD
16:02:20 <hughperkins> Its possible to do this without a DTD, I just didnt figure it out yet
16:02:34 <Cale> okay, so you need to return a different kind of data based on the contents of the input string?
16:02:51 <hughperkins> right
16:03:03 <hughperkins> I have tons of input, not just the string ,also the datatype
16:03:11 <edwardk> hughperkins, sounds like you have a lot of   things like case () of _ | Just (i :: Int) <- cast datatype = dosomethingwithanint; | Just (s :: String) <- cast datatype = dosomethingwithastring ... in your future
16:03:32 <hughperkins> will that be polymorhpic?
16:04:21 <edwardk> if done right, the result would be Typeable based though.
16:04:40 <hughperkins> yeah, its ok if the result is constrinaed to be Data, Typeable
16:05:14 <chessguy> you'll probably want to use Catch on that code (if you can) to catch inexhaustive patterns
16:05:29 <edwardk> chessguy: thats why i moved them in to use pattern guards =)
16:05:31 <chessguy> or is Typeable a GHC thing?
16:06:13 <chessguy> ?hoogle Typeable
16:06:14 <lambdabot> Data.Typeable :: module
16:06:14 <lambdabot> Data.Typeable.Typeable :: class Typeable a
16:06:14 <lambdabot> Data.Typeable.Typeable1 :: class Typeable1 t
16:06:14 <Cale> It uses local universal quantification
16:06:17 <sorear> chessguy: Catch isn't GHC only!
16:06:48 <chessguy> sorear, no, i don't think it can handle anything GHC-specific, that was my point
16:06:48 <sorear> Cale: Catch works on untyped lambda terms, so adapting it to GHC would be <100 lines of glue, no thought required
16:06:57 <edwardk> Typeable is GHC only Typeable1, ... Typeablen whatever are haskel 98 iirc
16:07:27 <sorear> nah, Typeable is haskell98, except that it needs Unsafe.Coerce (a portable module)
16:07:44 <edwardk> ah
16:07:45 <hughperkins> pattern gaurds dont seem to be polymorphic
16:07:55 <sorear> deriving(Typeable) is ghc only
16:08:05 <ddarius> hughperkins: ?
16:08:05 <Cale> It's Data where things start to become troublesome
16:08:20 <hughperkins> `a1' is bound by the polymorphic type
16:08:32 <sorear> hughperkins: you *need* a type singature for this
16:08:46 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/404
16:08:50 <hughperkins> (the error message I get when I do http://hpaste.org/404
16:08:52 <sorear> hughperkins: J.B.Wells proved it's impossible to handle rank-N types without them
16:09:08 <sorear> hughperkins: that's not an error message
16:09:22 <hughperkins> no, its the code that gives the error message ;-)
16:09:25 <hpaste>  Cale annotated "(no title)" with "(no title)" at http://hpaste.org/404#a1
16:09:51 <sorear> hughperkins: -fglasgow-exts for a start
16:10:04 <edwardk> pattern guards are an extension
16:10:18 <sorear> hughperkins: also, cast :: String -> Maybe Int   is exactly equivalent to      const Nothing :: String -> Maybe Int
16:10:18 <hughperkins> same error message
16:10:23 <hughperkins> running with glasgow exts
16:10:25 <sorear> hughperkins: Please!!
16:10:28 <sorear> hughperkins: Tell us!!
16:10:36 <Cale> cast will always give Nothing if you constrain its type to String -> Maybe Int
16:10:50 <Cale> oh, sorear pointed this out already
16:10:51 <monochrom> Produce a reproducible experiment.
16:11:05 <sorear> hughperkins: paste the full failing function, too, not just one guard.
16:11:06 <hughperkins> ok, second
16:11:46 <monochrom> I forgot self-contained. Produce a reproducible, self-contained experiment.
16:11:59 <monochrom> (That should be taught in Question Asking 101, right?)
16:12:17 <ddarius> monochrom: But who takes Question Asking 101?
16:12:43 <monochrom> That is a glaring omission in the world's education.
16:12:43 <edwardk> um, what is the goal here, to read some text from a field?
16:12:50 <sorear> forall s. /me has never taken s 101
16:13:20 <sorear> edwardk: I think it's an IOHCC entry? :)
16:13:25 <edwardk> sorear: heh
16:14:21 <hpaste>  (anonymous) pasted "(no title)" at http://hpaste.org/405
16:14:22 <edwardk> or are you trying to generate a string?
16:14:27 <hughperkins> here: http://hpaste.org/405
16:14:39 <hughperkins> run "dotest" to reproduce
16:14:45 <hughperkins> You'll need HXT
16:15:51 <hughperkins> but I gotta go to sleep :-/  1:15am and I have work tomorrow :-/  If you figure it out, could you post it to the mailing list or email me at hughperkins@gmail.com please? (or just wait for me to come on another day :-D )
16:16:10 <edwardk> heh just check the paste, bookmark it
16:16:16 <edwardk> someone will probably get bored
16:16:20 <hughperkins> Ok :-)
16:17:00 <hughperkins> later :-)
16:18:08 <sorear> Apparently out of the 12 versions of GHC on my computer, not one has HaXml.
16:26:23 <edwardk> ah, found the source for that hughperkins thing http://www.defmacro.org/ramblings/haskell-web.html
16:26:24 <lambdabot> Title: Haskell and Web Applications
16:32:22 <ddarius> sorear: Why do you have 12 versions of GHC?
16:33:00 <sorear> ddarius: In case the newest one doesn't work!
16:34:52 <LoganCapaldo> mdmkolbe|work: ping
16:40:17 <Apocalisp> I'm looking for a Relation data structure. A relation has a heading and a body, the heading an unordered set of attributes. An attribute is an ordered (name,type) pair. The body is an unordered set of tuples. A tuple is an unordered set of (name, value) pairs where value is of the type declared for that name in the heading. Is there anything like that out there?
16:41:33 <chessguy> should be easy to create
16:41:38 <sorear> Apocalisp: Yes.
16:42:10 <Apocalisp> Have you a link to a good place to get started?
16:42:11 <sorear> Apocalisp: Possibly the simplest approach is [Row], where Row is a record type.
16:42:31 <ddarius> sorear: How far back do you go?
16:42:46 <sorear> ddarius: Nov '90 ?
16:42:59 <chessguy> sorear, i think he means your GHC builds
16:43:09 <ddarius> Damn, you were born in the 90s.
16:43:37 <sorear> ddarius: 6.4.2
16:44:52 <ddarius> Okay, 6.4.2, 6.6, 6.6.1, HEAD, I think there was a 6.4.3 but I may be mistaken.  Even throwing in development versions that still doesn't seem to add up to 12.
16:45:14 <Cale> Apocalisp: It sounds rather like a Data.Map with some additional checking.
16:45:54 <Cale> (in particular, you'll need to represent the 'type' information yourself)
16:47:04 <sorear> ddarius: There are a LOT of development versions.  Remember HEAD is 6.7.DATE_OF_LAST_PATCH
16:47:25 <Apocalisp> Cale: It's not like Data.Map at all. A set of Maps would come close, but they would have to be isomorphic and strongly typed. I specifically want type errors to be caught at compile-time.
16:47:57 <chessguy> huh? everything is strongly typed in haskell
16:48:05 <Cale> chessguy: This wouldn't be
16:48:23 <chessguy> ...
16:48:24 <Cale> Apocalisp: So you want the types in the column headings to be genuine Haskell types
16:48:25 <Apocalisp> chessguy: I mean the maps would all have to be identically typed.
16:48:34 <chessguy> oh!
16:48:38 <Apocalisp> Cale: Yes, absolutely.
16:49:10 <Cale> Apocalisp: okay, should this be reflected in the type of the relation?
16:49:30 <Apocalisp> I think so
16:49:44 <Apocalisp> I'm not sure what you mean exactly.
16:49:47 <Cale> I think so too, or else static checking becomes impossible.
16:49:59 <Apocalisp> ok, now I see what you mean
16:50:29 <Cale> So, it's like a Data.Set of tuples, together with a tuple of strings of the same length.
16:51:27 <Apocalisp> sort of
16:52:12 <Cale> Except that if you want a lookup operation which gets the component of a tuple having the given name, that's going to be hard to assign a type to.
16:52:22 <Cale> It would be something like  String -> ...
16:52:42 <Cale> but it's tricky to assign something to ...
16:52:57 <glen_quagmire> > a () = 1
16:52:57 <lambdabot>  Parse error
16:53:01 <Cale> especially since it varies based on the actual type of that field.
16:53:01 <Apocalisp> I found the "Strong Types for Relational Data" functional pearl. That might be what I'm looking for.
16:53:11 <Cale> You might be interested in HList.
16:53:17 <Cale> @where HList
16:53:18 <lambdabot> http://homepages.cwi.nl/~ralf/HList
16:53:52 <Cale> I think it basically solves the same problem as what you're talking about.
16:54:24 <Cale> It involves some pretty sophisticated typeclass swindling though :)
16:56:10 <Apocalisp> uh oh
16:56:21 <Apocalisp> I don't like swindling!
16:57:10 <Apocalisp> Maybe a DSL is in order.
16:59:23 <Apocalisp> hmm, no, what I want is definitely homogeneous
16:59:41 * sorear wonders how hard it would be to implement an interpreter for natural deduction notation
16:59:58 <sorear> Imagine, a full Haskell type checker in four pages of code! :)
17:01:30 <ddarius> sorear: The trickiest parts would simply be the surface syntax.
17:01:41 <LoganCapaldo> Apocalisp: I guess data ColumnVal = Name1 Type1 | Name2 Type2 | ... would be unacceptable?
17:01:44 <ddarius> sorear: But then there is Epigram.
17:03:00 <Apocalisp> LoganCapaldo: Not sure. How do I enforce that Name1 in the body is always of Type1?
17:03:22 <nominolo> sorear: you mean 2d?
17:03:25 <ddarius> @src uncurry
17:03:25 <lambdabot> uncurry f p = f (fst p) (snd p)
17:03:32 <LoganCapaldo> Well Name1 is actually :: Type1 -> ColumnVal
17:04:27 <LoganCapaldo> And then for a given tuple you'd use a Data.Set ColumnVal
17:04:55 <LoganCapaldo> (possibly with an intentionally broken meaning of ==)
17:06:27 <ddarius> ekidd: Wie geht's?
17:06:40 <ekidd> Good, and you?
17:06:53 <LoganCapaldo> Is there a version of Set (or Map) that's like Set (a -> a -> Ordering) a ?
17:07:20 * LoganCapaldo wondered aloud
17:07:41 <dibblego> why don't you just newtype a and redefine Ord?
17:08:08 <ddarius> ekidd: Today will be slightly better than most days, but that's not saying much.  Paper writing done?  What's the paper up to now?
17:08:20 <Cale> Apocalisp: Well, compile time checking something like that takes a bit of cleverness.
17:08:35 <LoganCapaldo> dibblego: I was thinking that once he got it out of the Set he'd want to compare it more normal ways, but I suppose you could have the set be a Set of newtypes actually
17:08:36 <ddarius> @oldwiki SchwartzianTransform
17:08:36 <lambdabot> http://www.haskell.org/hawiki/SchwartzianTransform
17:08:37 <ekidd> ddarius: http://www.randomhacks.net/darcs/probability-monads/probability-monads.pdf
17:08:39 <lambdabot> http://tinyurl.com/276u5w
17:08:51 <ekidd> It's been submitted to Haskell Workshop 2007.
17:09:08 <Apocalisp> Cale: Maybe I'm better off actually writing a compiler then.
17:09:44 <Apocalisp> Is there a compiler compiler for Haskell?
17:09:45 <Cale> Apocalisp: You can certainly dynamically enforce that the constraints hold easily enough.
17:09:49 <dibblego> ?hoogle (Int -> a -> b) -> [a] -> [b]
17:09:50 <lambdabot> No matches, try a more general search
17:10:31 <Cale> You could construct an embedded DSL to handle it.
17:10:33 <ddarius> dibblego: \f -> zipWith f [0..] ?
17:10:45 <dibblego> ddarius, yep :)
17:11:31 <glen_quagmire> look at left ->
17:11:45 <mauke> :t \f -> join (map . (f . length))
17:11:47 <lambdabot> forall a b. (Int -> a -> b) -> [a] -> [b]
17:12:37 <ddarius> Ah, the opulence of a listful style, \f -> catMaybes . zipWith f [0..] :: (Int -> a -> Maybe b) -> [a] -> [b]
17:13:25 <ddarius> Fusion and streaming behavior don't hurt either.
17:13:28 * ddarius hugs Haskell.
17:14:01 <glen_quagmire> Haskell is a manly man
17:14:05 <mauke> :t join . (map . (flip (.) length))
17:14:08 <lambdabot>     Couldn't match expected type `(->) [[a]]'
17:14:08 <lambdabot>            against inferred type `[]'
17:14:21 <glen_quagmire> :t (.)
17:14:24 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
17:14:34 <mauke> :t join . ((map .) . (flip (.) length))
17:14:38 <lambdabot> forall a b. (Int -> a -> b) -> [a] -> [b]
17:15:35 <ddarius> :t mconcat
17:15:36 <lambdabot> forall a. (Monoid a) => [a] -> a
17:15:41 <ddarius> :t msum
17:15:43 <lambdabot> forall (m :: * -> *) a. (MonadPlus m) => [m a] -> m a
17:15:47 <mauke> :t liftM join ((liftM `liftM`) `liftM` (`liftM` length))
17:15:49 <lambdabot> forall r a. (Int -> a -> r) -> [a] -> [r]
17:16:10 <ddarius> liftM `liftM` == liftM liftM
17:16:30 <mauke> it's just for symmetry
17:18:24 <glen_quagmire> > liftM 1 2
17:18:25 <lambdabot>   add an instance declaration for (Show (m r))
17:19:03 <mauke> @unpl join . ((map .) . (flip (.) length))
17:19:03 <lambdabot> (\ j -> (\ r -> map (j (length r))) >>= \ k -> k)
17:19:04 <ddarius> liftM == fmap
17:19:36 <ddarius> @. pl unpl join . ((map .) . (flip (.) length))
17:19:36 <lambdabot> join . (map .) . (. length)
17:19:46 <glen_quagmire> > liftM length [[],[],[1]]
17:19:48 <lambdabot>  [0,0,1]
17:20:02 <ddarius> > liftM sum [[],[],[1]]
17:20:04 <lambdabot>  [0,0,1]
17:20:28 <ddarius> > let length = sum . map (const 1) in length $ replicate 10 34
17:20:30 <lambdabot>  10
17:21:31 <mauke> :t liftM sum (liftM (return 1))
17:21:33 <lambdabot> forall a a1. (Num a) => [a1] -> a
17:21:58 <glen_quagmire> :t return
17:22:01 <lambdabot> forall a (m :: * -> *). (Monad m) => a -> m a
17:22:22 <dibblego> ?hoogle (Int -> a -> Bool) -> [a] -> [a]
17:22:23 <lambdabot> No matches, try a more general search
17:22:26 <dibblego> didn't think so
17:23:30 <ddarius> \p -> filter (uncurry p) . zip [0..]
17:24:08 <sorear> `
17:24:31 <mauke> :t join . (filter .) . (. length)
17:24:33 <lambdabot> forall a. (Int -> a -> Bool) -> [a] -> [a]
17:25:14 <xpika_> all: which do like better
17:25:26 <xpika_> func2 = foldr insertAnimal Map.empty animals  -- or
17:25:34 <xpika_> func2 = foldr insertAnimal Map.empty animals
17:25:42 <xpika_> func1 = runState (mapM_ (modify . insertAnimal) animals) Map.empty
17:26:25 <xpika_> do you think the fold is obfuscating or is that a good style.
17:27:21 <mauke> :t modify . ?insertAnimal
17:27:23 <lambdabot> forall s (m :: * -> *) a. (MonadState s m, ?insertAnimal::a -> s -> s) => a -> m ()
17:28:16 <mauke> I like func2 better
17:28:21 <xpika_> :)
17:28:41 <xpika_> its so un imperative though
17:28:47 <mauke> yes!
17:28:57 <mauke> also, shouldn't that be execState?
17:29:14 <xpika_> mauke: runState works for me
17:29:52 <mauke> but that returns a tuple
17:30:09 <mauke> ((), someMap)
17:30:22 <xpika_> mauke: oh, thanks :)
17:30:47 <dibblego> ?where ffi
17:30:47 <lambdabot> http://www.cse.unsw.edu.au/~chak/haskell/ffi/
17:31:27 <xpika_> do you want to see the code?
17:31:59 <mauke> not really
17:32:08 <hpaste>  xpika pasted "alphabet challenge" at http://hpaste.org/406
17:33:03 <mauke> pushmap looks suspicious
17:33:26 <xpika_> why?
17:36:18 <mauke> Map.insertWith (++) k [a] m
17:36:58 <ndm> kfish, very nearly reading to have a "ndm approved" tagsoup tree once more
17:37:06 <ndm> just fighting with laziness/strictness in my parser
17:37:12 <kfish> ndm, awesome :-)
17:37:14 <sorear> hello ndm.
17:37:32 <sorear> oops, forgot to write that lazy lexer generator :)
17:37:58 <dukedave> Yey, this seems like the perfect time to being in my Parsec question :)
17:38:13 <ndm> i managed to figure out how to do it with a state monad and an appropriate state
17:38:28 <ndm> its hard to balance between not lazy enough, too lazy, space leaking and stack leaking
17:38:41 <ndm> in fact, its a complete nightmare
17:39:31 <dukedave> I'm writing a pretty simple little toy program & I have a 'text input box', have been reading the Parsec tutorial and I'm wondering.. For my problem I'm only going to be doing very simple commands like "move 3" or "new window at 100 100"
17:39:37 <ndm> @karma+ Binkley
17:39:38 <lambdabot> Binkley's karma raised to 3.
17:39:39 <dukedave> Is Parsec going over board?
17:40:07 <ndm> dukedave, i'd use words and smiple pattern matching - depends how much error reporting you want
17:40:23 <ddarius> dukedave: Um, what ndm said
17:40:43 <dukedave> Heh
17:41:03 <sorear> dukedave: I'd use ghci.
17:41:17 <dukedave> I was wondering if I would use words as the lexer if that makes sense?
17:41:25 <sorear> dukedave: Define a function named move and a function named newWindow
17:41:35 <sorear> Program> move 100 100
17:41:43 <sorear> Re-use GHC's parser!
17:41:57 <ndm> yay! GADT support in the command language :)
17:42:09 <kfish> btw. ndm, thanks for winhugs -- i used it to teach some classes last week (introducing what programming is, to first year students at a local liberal arts college) -- worked great, they all installed and used it without any problems ;-)
17:42:23 <ddarius> sorear has been playing with Forth too much
17:42:23 <dukedave> sorear: Lovely idea
17:42:31 <ndm> kfish, neat :)
17:42:32 <dukedave> Except..
17:42:44 <dukedave> I've already written my buffering input :|
17:42:56 <sorear> huh?
17:43:04 <sorear> buffering input?
17:43:24 <dukedave> Heh, well
17:44:13 <kfish> ndm: we went from "what is source code?" to "ok, now install winhugs" to "now write your own line of code using map, filter, sum etc. to do XYZ" in about an hour ...
17:45:26 <dukedave> I'm using Vty to make a little curses style windowing app.. So every time a key is entered it gets appended to a buffer & then will be shipped to a parser, if it's a valid command then buffer is emptied & command runs, if not buffer stays
17:45:54 <sorear> dukedave: Interesting!
17:46:14 <dukedave> sorear: It feels a little dirty though :|
17:46:29 <sorear> dukedave: I'd probably use the Haskell built-in parser combinators.
17:46:47 <dukedave> Not Parsec?
17:47:12 <sorear> dukedave: They predate the invention of combinator error reporting technology, and they're a bit more verbose, but IME they take less thinking to use for small things.
17:48:03 <ddarius> dukedave: You automatically run a command as soon as it parses?
17:48:04 <dukedave> @hoogle parsers
17:48:05 <lambdabot> Text.ParserCombinators.Parsec.Prim.getParserState :: GenParser tok st (State tok st)
17:48:05 <lambdabot> Text.ParserCombinators.Parsec.Prim.setParserState :: State tok st -> GenParser tok st (State tok st)
17:48:14 <ddarius> :t reads
17:48:16 <sorear> [ Move x y | ("move", s2) <- lex s1 , (x, s3) <- reads s2 , (y, s4) <- reads s3 ]
17:48:17 <dukedave> ^ Is that what I'm looking at?
17:48:18 <lambdabot> forall a. (Read a) => String -> [(a, String)]
17:48:22 <sorear> dukedave: [ Move x y | ("move", s2) <- lex s1 , (x, s3) <- reads s2 , (y, s4) <- reads s3 ]
17:48:37 <sorear> list comprehensions!
17:48:39 <dukedave> ddarius: Yeah that's the plan
17:48:59 <ddarius> But, "move 100 1" parses, no?
17:49:25 <dukedave> Yes I can see that being a problem now you mention it :)
17:49:38 * dukedave looks up at channel topic 
17:50:17 <sorear> dukedave: what about it?
17:50:37 <dukedave> "think more"
17:51:46 <dukedave> So sorear, where does the lex function come from in your comprehension
17:51:53 <sorear> dukedave: The prelude
17:52:01 <sorear> > lex "23 abc"
17:52:04 <lambdabot>  [("23"," abc")]
17:52:13 <sorear> > lex "\"string\" rest"
17:52:14 <lambdabot>  [("\"string\""," rest")]
17:52:31 <sorear> it's a mostly haskell-compatible lexer
17:53:59 <dukedave> Cool thanks for the tip, I'll have a play
17:54:31 <ddarius> > lex ""
17:54:33 <lambdabot>  [("","")]
17:55:35 * LoganCapaldo wishes lambdabot imported Parsec
17:56:12 <LoganCapaldo> s/wishes/idly wishes/
17:56:26 <LoganCapaldo> > lex "123 + 34"
17:56:28 <lambdabot>  [("123"," + 34")]
17:56:32 <ddarius> Parsec is just monad transformers and combinators essentially.  You should be able to define it with @let
17:56:40 <LoganCapaldo> that's true
17:56:51 <Pseudonym> You can't define monad instances with @let.
17:56:58 <dons> ndm: any thoughts on TagSoup with lazy bytestrings?
17:57:09 <ddarius> Pseudonym: You don't need to.
17:57:13 <Pseudonym> True.
17:57:26 <LoganCapaldo> the types will all just have icky names
17:57:27 <dons> ndm, or does that already  work?
17:57:45 <ddarius> LoganCapaldo: Luckily we don't need to provide type annotations either
17:58:02 <LoganCapaldo> Also tru
17:58:38 <hpaste>  ndm pasted "Stack overflow problem" at http://hpaste.org/407
17:59:03 <ndm> dons, it doesn't - certainly not thinking of that at the moment, trying to bash tagsoup back into shape
17:59:17 <ndm> dons - i'll think about it once i've got the code stabilised
17:59:31 <ndm> in particular does anyone have any idea why i stack overflow in that example above?
18:00:03 <ndm> stack overflow in Hugs, but not GHCi
18:00:15 <sorear> Favorite line so far from a Haskell paper, in the More Questions section:
18:00:16 <ddarius> ndm: How does span fair by itself?
18:00:17 <sorear> Why is thinking about type inference addictive?
18:00:18 <ndm> or at least it didn't quickly stack overflow in GHCi, doesn't mean it won't
18:00:24 <ndm> ddarius, i have no idea
18:01:17 <ndm> ddarius, overflows
18:01:38 <xpika> ndm: tagsoup doesnt derive typable or data is that so that its not GHC specific?
18:01:40 <ndm> @src lines
18:01:40 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:02:11 <ndm> xpika, i hadn't thought of it doing so - but the GHC specific bit would make me reluctant to do it - perhaps CPP would be ok for that
18:02:17 <dukedave> > reads "dave" :: [(String, String)]
18:02:19 <ndm> @src words
18:02:19 <lambdabot> words s = case dropWhile isSpace s of
18:02:20 <lambdabot>     "" -> []
18:02:20 <lambdabot>     s' -> w : words s'' where (w, s'') = break isSpace s'
18:02:21 <lambdabot>  []
18:02:43 <dukedave> > reads "dave" :: [(String, String)]
18:02:45 <xpika> CPP = c plus plus?
18:02:45 <lambdabot>  []
18:03:07 <ndm> ooh dear, words (repeat 'a') stack overflows in Hugs...
18:03:21 <LoganCapaldo> > reads "\"dave\"" :: [(String, String)]
18:03:23 <lambdabot>  [("dave","")]
18:03:32 <ddarius> ndm: Perhaps it's the show instance.
18:03:38 <dukedave> Now that is interesting!
18:03:51 <LoganCapaldo> define "interesting"? :)
18:04:20 <dukedave> Ah it's to maintain duality with show right?
18:04:29 <LoganCapaldo> > reads "True" :: [(Bool, String)]
18:04:31 <lambdabot>  [(True,"")]
18:04:39 <ndm> ddarius, i see no reason why
18:04:40 <LoganCapaldo> @src read
18:04:40 <lambdabot> read s = either error id (readEither s)
18:04:49 <LoganCapaldo> @src readEither
18:04:49 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:04:52 <ddarius> ndm: It's Hugs...
18:04:53 <LoganCapaldo> ah well
18:05:14 <LoganCapaldo> I'm fairly sure read is (eventually) implemented in terms of reads
18:05:53 <LoganCapaldo> Or that there both implemented in terms of some other, more basic function
18:06:00 <LoganCapaldo> s/there/they're/
18:06:08 * LoganCapaldo fails to Grammar check
18:06:20 <ndm> ddarius, Yhc doesn't stack overflow...
18:06:43 <ddarius> ndm: Perhaps it's not pushing Hugs in the right directions.
18:07:02 <dibblego> LoganCapaldo, you needed a s/your/you're earlier :)
18:07:18 <LoganCapaldo> gah
18:07:35 <dibblego> shall I reprimand you?
18:07:36 <LoganCapaldo> It's like the more self-concious of it I become, the more often I make the mistake
18:08:08 <dibblego> Jun 26 08:29:04 <LoganCapaldo>  you might be able to take it off but, your not guaranteed to be able to take it off
18:08:16 <ddarius> While GHC has some arguably ill-implemented standard functions, my experience is Hugs has tended to be much worse in this regard.
18:08:40 <LoganCapaldo> dibblego: Just display my shame to the world!
18:08:43 * LoganCapaldo weeps
18:08:52 <dibblego> your OK :)
18:08:52 <geezusfreeek> heh
18:08:57 <geezusfreeek> oops, wrong window :P
18:17:09 <xpika> @where flags
18:17:09 <lambdabot> http://www.haskell.org/ghc/docs/latest/html/users_guide/flag-reference.html
18:18:40 <xpika> is there any way to ghc --make clean?
18:19:10 <sorear> xpika: not as such, but -fforce-recomp should do what you want
18:19:32 <sorear> that's like the -B option to some makes
18:19:46 <sorear> ignore dependencies and recompile everything
18:19:52 <dons> ndm, so its a bad imlementation of 'words' in hugs?
18:20:49 <xpika> sorear: i just wanted it to delete the .o and .hi files :)
18:22:26 <sorear> find . -name '*.o' -o -name '*.hi' -ok rm {} ;
18:22:29 <xpika> i guess adding && del *.o *.hi does the trick
18:22:39 <sorear> oh, del.  hehe
18:22:59 <xpika> sorear: are you laughing that im on windows/
18:23:15 <sorear> xpika: Laughing at my mistake.
18:23:28 <xpika> sorear: :-)
18:27:01 <ndm> dons, no - looks like the normal one
18:35:00 <dibblego> ?check \xs n -> n >= 0 ==> take (length xs) (drop (n * length xs) (cycle (xs :: [Int]))) == xs
18:35:02 <lambdabot>  OK, passed 500 tests.
18:37:46 <Saizan> > cycle []
18:37:48 <lambdabot>  Exception: Prelude.cycle: empty list
18:38:26 <Saizan> why not just cycle [] = [] ?
18:38:30 <LoganCapaldo> > fix ([] ++)
18:38:32 <lambdabot>  Exception: <<loop>>
18:38:47 <dibblego> why doesn't QC fail that property for []?
18:39:01 <LoganCapaldo> > let cycle xs = fix (xs ++) in cycle []
18:39:02 <lambdabot>  Exception: <<loop>>
18:39:08 <Saizan> dibblego: n >= ==>
18:39:21 <Saizan> n >= 0 ==>
18:39:21 <LoganCapaldo> I guess causes it's guaranteed to btoom out anyway so might as well let you know?
18:39:26 <dibblego> what does n have to do with anything?
18:39:36 <LoganCapaldo> > let cycle xs = fix (xs ++) in cycle [1]
18:39:38 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:39:53 <Saizan> oh right
18:40:22 <dibblego> ?check \xs -> length $ cycle (xs :: [Int]) > 0
18:40:23 <lambdabot>  Couldn't match expected type `[a]' against inferred type `Bool'
18:40:29 <shachaf> > let cycle = sequence . repeat in cycle [1]
18:40:32 <lambdabot>  Exception: <<loop>>
18:40:35 <shachaf> > let cycle = concat . repeat in cycle [1]
18:40:37 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:40:45 <shachaf> I wonder why I typed sequence, I meant concat.
18:41:51 <LoganCapaldo> > let repeat = cycle . (:[]) in repeat 1
18:41:53 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
18:41:59 <dibblego> ?check \xs -> (length $ cycle (xs :: [Int])) > 0
18:42:01 <lambdabot>  Exception: Prelude.cycle: empty list
18:42:16 <dibblego> ?check \xs n -> (length $ cycle (xs :: [Int])) > (0 * n)
18:42:26 <lambdabot> Terminated
18:42:43 <dibblego> ?check \xs n -> (head $ cycle (xs :: [Int])) > (0 * n)
18:42:45 <lambdabot>  Falsifiable, after 0 tests: [-2], 0
18:43:18 <dibblego> ?check \xs n -> (head $ cycle (xs :: [Int])) * 0 == (0 * n)
18:43:21 <lambdabot>  Exception: Prelude.cycle: empty list
18:45:33 <ndm> @seen kfish
18:45:34 <lambdabot> kfish is in #haskell. I last heard kfish speak 1h 1m 20s ago.
18:46:09 <ndm> kfish: what would you think of (~= "<li attr=value>") as a synonym for (~= TagOpen "li" [("attr","value")]) ?
19:06:47 <vincenz> :
19:19:09 <ddarius> @scheck \xs n -> n >= 0 ==> take (length xs) (drop (n * length xs) (cycle (xs :: [Int]))) == xs
19:19:11 <lambdabot>   Completed 325767 test(s) without failure.  But 150354 did not meet ==> cond...
19:29:58 <dibblego> ?where cofp
19:29:58 <lambdabot> http://www.cs.kent.ac.uk/people/staff/sjt/craft2e/
19:30:14 <dibblego> ?where yaht
19:30:14 <lambdabot> http://darcs.haskell.org/yaht/yaht.pdf
19:34:16 <dibblego> @tell me foo
19:34:17 <lambdabot> Consider it noted.
19:36:55 <sorear> dibblego: Speak!
19:37:03 <dibblego> bar!
19:37:18 <sorear> huh. lambdabot should've responded.
19:37:24 <dibblego> I was just testing if it was @tell or @message
19:37:24 <sorear> @activity-full 180
19:37:25 <lambdabot> 2*total 2*dibblego
19:37:28 <me> bar
19:37:28 <lambdabot> me: You have 3 new messages. '/msg lambdabot @messages' to read them.
19:37:30 <sorear> aha.
19:37:34 <me> @messages
19:37:35 <lambdabot> br1kok said 8m 14d 7h 8m 51s ago: hi
19:37:35 <lambdabot> zeeeeeee said 6m 1d 3h 3m 32s ago: aoeu
19:37:35 <lambdabot> dibblego said 3m 18s ago: foo
19:38:11 <sorear> twas trying for ndm:
20:03:49 <ed1t> dons, u there?
20:12:53 <dons> ed1t: yeah?
20:12:53 <lambdabot> dons: You have 1 new message. '/msg lambdabot @messages' to read it.
20:16:40 <ed1t> dons, im installing hs-plugins for lambdabot and im getting this message on ./configure...
20:16:42 <ed1t> sed: file ./confstatVV8236/subs-1.sed line 41: unterminated `s' command
20:19:49 <dons> check there's no meta-chars in the configure file.
20:21:17 <dibblego> about to put in a book order at work; Programming in Haskell, TaPL, SICP, Introduction to Algorithms, 2e - comments?
20:21:28 <ed1t> wat u mean by meta-chars?
20:22:07 <dons> funny escape chars , or something like that.
20:22:14 <Excedrin> dos line endings
20:25:38 <ed1t> dibblego,  introduction to algorithms by thomas cormen?
20:26:00 <dibblego> yes
20:26:23 <ed1t> i've used that book for one of my classes
20:26:44 <ed1t> its a good book
20:31:05 <LoganCapaldo> is that the one w/ the leaves?
20:31:14 <LoganCapaldo> name sounds familar
20:31:30 <ed1t> yea
20:31:37 <ed1t> leaves cover
20:32:05 <LoganCapaldo> yep so it is
20:32:55 <LoganCapaldo> that was one of my favorite classes
20:33:14 <LoganCapaldo> I don't think I wrote a single line of code to be fed to a compiler the whole class
20:33:32 <dibblego> the reviews looked good and the content looked good last I looked at it (a few weeks ago)
20:53:26 <sorear> @users
20:53:26 <lambdabot> Maximum users seen in #haskell: 338, currently: 298 (88.2%), active: 8 (2.7%)
21:46:00 * shapr boops
21:49:53 * Pseudonym boop boop be doops
21:51:08 <LoganCapaldo> bebop
21:53:25 * desp frobs
22:01:37 * sorear bounces
23:06:12 <dibblego> ?check \xs n -> (fst $ splitAt n xs) ++ (snd $ splitAt n xs) == (xs :: [Int]) && ((length $ fst $ splitAt n xs) == n || n < 0 || n >= length xs) && ((length $ snd $ splitAt n xs) == length xs - n || n < 0 || n >= length xs)
23:06:13 <lambdabot>  OK, passed 500 tests.
23:06:25 <dibblego> ?type (==>)
23:06:27 <lambdabot> Not in scope: `==>'
23:06:32 <dibblego> ?type (-->)
23:06:36 <lambdabot> parse error (possibly incorrect indentation)
23:07:05 <mgsloan> I take it it's impossible to make a data constructor for a type synonym?
23:07:52 <sorear> mgsloan: What would it mean?
23:08:07 <sorear> mgsloan: (and I'm not sure I understand you)
23:08:08 <dibblego> > let Foo = Just in Foo 7 -- ?
23:08:09 <lambdabot>   Not in scope: data constructor `Foo'
23:08:17 <dibblego> er
23:08:19 <mgsloan> well, I guess I mean a constructor synonym to go along with a type synonym
23:08:36 <dibblego> > let foo = Just in foo 7 -- ?
23:08:36 <sorear> mgsloan: lemme find the URL...
23:08:38 <lambdabot>  Just 7
23:08:48 <mgsloan> I've got:
23:08:48 <mgsloan> data D2 t = D2 t t
23:08:48 <mgsloan> type Vector = D2 Double
23:08:58 <sorear> http://hackage.haskell.org/trac/haskell-prime/wiki/PatternSynonyms
23:09:01 <lambdabot> Title: PatternSynonyms - Haskell Prime - Trac, http://tinyurl.com/2omqn9
23:09:10 <sorear> mgsloan: ^^^
23:09:16 <mgsloan> thanks!
23:09:36 <mgsloan> (for the curious about the above snippet, D2 is a general lifter of 1-d things into 2-d)
23:10:10 <sorear> mgsloan: It's not implemented anywhere yet, but if your code looks sufficiently good with them you might be able to plead for inclusion in GHC :)
23:10:10 <mgsloan> sorear - oh, is that in right now.. ?
23:10:19 <mgsloan> hehe
23:11:09 <dibblego> @pl p & (q | r | s) & (t | r | s)
23:11:10 <lambdabot> p & (q | r | s) & (t | r | s)
23:11:14 <mgsloan> My code doesn't look that good, it has some near-anarchic numerics classes :)
23:11:26 <dibblego> @pl p && (q || r || s) && (t || r || s)
23:11:27 <lambdabot> p && (q || r || s) && (t || r || s)
23:11:44 <mgsloan> but it would be nice to be able to pat match/construct on Vector rather than D2
23:12:06 <dibblego> @pl p || (q || r)
23:12:06 <lambdabot> p || q || r
23:12:16 <dibblego> @pl if p then true else q
23:12:16 <lambdabot> if' p true q
23:12:17 <sorear> dibblego: Are you expecting it to optimize boolean equations for you? :)
23:12:22 <dibblego> sorear, hoping :)
23:12:45 <mgsloan> I'm actually confused why data constructors are treated specially capitalizationwise
23:13:18 <dons> simplifies patterns a lot.
23:13:24 <dibblego> I looked for a web page that would do it once, but I couldn't find one
23:13:35 <mgsloan> does it?
23:14:07 <mgsloan> oh, yeah, of course
23:14:16 <dons> f (Constructor x y) = ... -- easy to see what is matching, and what is being bound.
23:14:23 <mgsloan> that is a pickle indeed
23:14:36 <sorear> dons: the only big conid/varid thing I see in the grammar is  Foo{ }
23:15:02 <sorear> fixities are necessary and sufficient to disambiguate pattens
23:15:27 <dons> doesn't mean it wouldn't be more confusing though, to flatten namespaces visibly.
23:15:42 <dibblego> ?check \ p q r -> p && q || r == p && (q || r)
23:15:43 <lambdabot>  Falsifiable, after 1 tests: False, False, True
23:15:46 <dons> its good to have some lexical distinctions
23:16:33 * sorear wishes !, +, -, as, qualified, hiding were treated more regularly
23:16:50 <mgsloan> I suppose I'll just make vector-users use the accessors
23:18:29 <mgsloan> what does qualified hiding do?
23:19:03 <mgsloan> (atm I just import the prelude, hide the ops, then import the prelude qualified)
23:19:32 <sorear> mgsloan: it imports qualified, but hiding completely some names
23:19:36 <sorear> ie, mostly useless
23:19:40 <mgsloan> oh
23:19:51 <mgsloan> yeah, what's the point?
23:21:08 <sorear> http://haskell.org/onlinereport/modules.html#sect5.3.4
23:21:10 <lambdabot> Title: The Haskell 98 Report: Modules
23:21:36 <dons> to absolutely rule out the use of some function?
23:22:10 <mgsloan> yeah, i suppose might be handy for large files or things like lambdabot
23:22:23 <mgsloan> though you'd probably want a better method than that
23:27:15 <mgsloan> the whole data constructor thing is one place where Scala is pretty interesting
23:31:02 <sorear> night all.
23:31:22 <mgsloan> 'night
23:32:15 <sorear> @users
23:32:15 <lambdabot> Maximum users seen in #haskell: 338, currently: 298 (88.2%), active: 6 (2.0%)
23:34:41 <mgsloan> hmm, I'm getting (the Coverage Condition fails for one of the functional dependencies) on this:
23:34:41 <mgsloan> instance (Add a b c) => Add (D2 a) (D2 b) (D2 c) where (+) = vzip (+)
23:36:30 <mgsloan> (the fundep is a b -> c)
23:37:59 <mgsloan> nevermind, just got an answer via google
23:38:55 <mgsloan> I must say that traits would probably be an adequate substitute for fundeps
23:39:21 <dibblego> sealed traits importantly (for a closed ADT)
23:45:08 <kfish> @tell ndm (==~ <li attr=value>) is pretty neat, esp if value can still contain whitespace [and also (==~ </li>) for TagClose :-]
23:45:08 <lambdabot> Consider it noted.
23:49:56 <mgsloan> argh
23:51:12 <mgsloan> unary - appears to be irascibly tied to the Prelude...
23:51:58 <mgsloan> > let negate = (+5) in -2
23:52:00 <lambdabot>  -2
23:52:26 <mgsloan> > let negate = (+5); foo = 2 in -foo
23:52:28 <lambdabot>  -2
23:52:33 <mgsloan> :(
