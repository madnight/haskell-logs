00:10:20 <quicksilver> or he might want rational :)
00:10:25 <quicksilver> depends what he wants...
00:11:23 <Figs> hey guys
00:11:25 * Figs is back
00:11:40 <Figs> on page 17 of that PDF
00:11:53 <Figs> (implimenting functional programming)
00:12:04 <Figs> there's a bit that talks about graph reduction
00:12:23 <Figs> the example given is in Miranda, I think, of
00:12:38 <Figs> f x = (x+1) * (x-1)
00:12:46 <Figs> and then evaluating f 4
00:13:12 <dons> well, that's haskell too.
00:13:22 <dons> ?let f x = (x+1) * (x-1)
00:13:24 <lambdabot> Defined.
00:13:26 <dons> > f 4
00:13:28 <lambdabot>  15
00:13:50 <Figs> *shrug*, anyway
00:13:53 <Japsu> How long does lambdabot remember functions defined that way? Can anyone define them?
00:14:06 <dons> Japsu: until the next @undefine, and yes.
00:14:11 <Japsu> k
00:14:20 <Figs> the graph setup is *identical* to everything I've seen when working on parser/compiler books related to imperative languages
00:14:38 <Figs> or any language, afaict
00:14:52 <dons> Figs, sure, programs are represented as trees or graphs
00:15:23 <dons> in imperative languages those graphs are flattened into blocks, and evaluated in a fixed order, but you can alsu reduce a graph using graph reduction :-)
00:15:34 <dons> which leads to some other fun ideas
00:16:14 <Figs> me brain aspload
00:16:21 <Figs> it makes too much sense
00:16:53 <Figs> I really wish that picture was the first thing I'd seen when I was introduced to functional programming ideas
00:17:03 <Figs> with that description you just gave me
00:17:34 <dons> :-)
00:17:43 <dons> you have to ask the right way
00:18:23 <Figs> now, I still think I was right in the structural thing I'm thinking of
00:18:34 <Figs> it's just a different way of looking at it though
00:18:46 <Figs> verticle instead of sequential
00:18:50 <Figs> *vertical
00:19:01 <Figs> (that wasn't intended to make sense)
00:19:12 <Figs> (it was a note to myself)
00:19:21 <opqdonut> normal-order versus call-by-value evaluation?
00:20:25 <DRMacIver> Morning
00:20:25 <Figs> ok, in a normal imperative approach, you make a crapload of these trees and then evaluate one after another depending on the state of the result of the last one, right?
00:21:08 <Figs> functional, you've basically just figured out that you can make a crapload of these trees, and turn them into one big tree and evaluate the branches as needed (lazy eval?) ?
00:21:34 <opqdonut> yep
00:21:40 <SamB> something like that.
00:21:47 <Figs> that makes too much sense
00:21:49 <Figs> :P
00:21:54 <SamB> certainly in Haskell virtually everything is an expression...
00:22:05 <opqdonut> it's called normal-order evaluation, check it up
00:22:24 <SamB> and I need sleep
00:23:13 <quicksilver> Figs: also, in side-effectful languages, these trees are evaluted in a context which can change as you go along
00:23:31 <quicksilver> Figs: the evaluation can change the context of the next bit of tree
00:23:56 <Figs> yeah
00:24:14 <Figs> hmm
00:24:19 <Figs> I've got an idea
00:24:46 <Figs> I'm sure it's not new
00:25:02 <Figs> but what about defining parts of the tree as sequential, and parts as non-sequential?
00:25:28 <Figs> so, when you find a bit that *is* sequential, it's evaluated as needed
00:27:54 <Figs> everything is call-by-value by default unless it's marked as call-by-ref, if it's required to refer to something then it's most likely going to be sequential
00:28:07 <Figs> depending on what it's refering to
00:28:32 <opqdonut> i think monads work a bit like that
00:28:41 <opqdonut> (e.g the io monad)
00:28:45 <opqdonut> not completely sure tho
00:28:56 <opqdonut> haven't really understood them on the eval-tree-level
00:28:58 <weitzman> Figs: My understanding from a dicussion I had with dibblego a while ago is that Scala works that way
00:30:42 <Figs> how is scala's syntax?
00:32:11 <DRMacIver> It's quite tolerable.
00:33:37 <Figs> how does functional programming handle event-driven styles?
00:33:44 <Figs> or can it?
00:33:53 <DRMacIver> I believe the relevant buzzword is 'functional reactive programming'
00:33:57 <DRMacIver> But I don't know what that actually means. :)
00:34:00 <Figs> :P
00:34:16 <DRMacIver> (But there exist non-trivial instances of it)
00:34:40 <Figs> wikipedia is almost empty on the subject
00:34:49 <Figs> 2 lines and a few links
00:35:25 <Figs> this is a weird way to think
00:35:27 <DRMacIver> The links are surely the interesting bit. :)
00:36:06 * Figs should try to figure out how the hell to merge the three ideas
00:36:08 <quicksilver> Figs: functional programming works fine with event-driven style
00:36:34 <quicksilver> Figs: functional programmings are likely to prefer the word 'action' to 'callback' but it isn't any different
00:36:51 <Figs> that's fine, I prefer action to callback anyway :P
00:37:17 <quicksilver> FRP is a higher-level abstraction which is pretty neat
00:37:29 <quicksilver> but nothing stops you using 'plain old event-driven programming' in an FP language
00:37:45 <Figs> how does it work?
00:38:27 <Figs> I know how EP works in GML and C++, but it makes less sense to me in an FP environment
00:38:39 <DRMacIver> GML?
00:38:45 <Figs> game maker language
00:38:46 <quicksilver> :t Control.Exception.bracket
00:38:49 <lambdabot> forall a b c. IO a -> (a -> IO b) -> (a -> IO c) -> IO c
00:38:57 <quicksilver> that's the kind of type y ou typically see
00:39:13 <Figs> what does that mean?
00:39:36 <quicksilver> that's not a very exciting event, but the idea is the same
00:39:51 <Figs> is the reply what would be called?
00:39:59 <Figs> (or performed, if you prefer)
00:40:12 <Syzygy-> quicksilver: What does that a -> IO b do in there?
00:40:22 <Syzygy-> The rest I can somehow understand...
00:40:26 <quicksilver> there are three paramters there: a 'steup' action, a 'finally' action, and a 'real work' action
00:40:39 <Syzygy-> Ah.
00:40:48 <Syzygy-> ?src Control.Exception.bracket
00:40:49 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
00:40:51 <Figs> and what does -> mean?
00:40:51 <quicksilver> the 'setup' action is called first, the 'real work action' is called to do something, and the 'finally' action is called (even) if an exception terminated the real wrok
00:41:09 <quicksilver> that's the function type contructor
00:41:24 <quicksilver> a -> b  is a function taking an 'a' and returning a 'b'
00:41:30 <Figs> ok
00:41:36 <Figs> can you only have one output in haskell?
00:42:02 <quicksilver> well you just build up a more complex datga type for your two outputs (or more)
00:42:03 <sieni> what do you mean?
00:42:05 <quicksilver> a -> (b,c)
00:42:15 <quicksilver> a -> (Either b c)
00:42:15 <Figs> ok
00:42:21 <quicksilver> are two simple examples
00:42:22 <Figs> oh, either?
00:42:25 * quicksilver nods
00:42:28 <Figs> not both?
00:42:35 <quicksilver> two possibilities there
00:42:39 <quicksilver> the first was both
00:42:43 <Figs> oooh ok
00:42:44 <quicksilver> the second wa one or the other
00:42:52 <Figs> I thought that was a clarification, not a second example
00:42:53 <Figs> thanks
00:42:53 <quicksilver> my 's' key doesn't work very well, sorry :)
00:43:00 <Figs> it's ok
00:43:04 <Figs> it makes sense
00:43:22 <Figs> how do you refer to 'c' supposing you have an a -> (b,c)?
00:43:46 <Syzygy-> snd . f
00:43:54 <Syzygy-> Supposing f is the a -> (b,c)
00:44:29 <Figs> I should probably just read a book on haskell
00:44:40 <quicksilver> something like this. Suppose f has type a -> (b,c)
00:44:42 <quicksilver> then you can write let (x,y) = f z
00:44:48 <quicksilver> and y has the 'c' p[art
00:44:58 <quicksilver> and x has the 'b' p art
00:45:21 <Figs> what is the equivalent of that in C?
00:45:57 <Figs> /*structure of x,y*/ f(z) {/*blah*/}?
00:46:07 <Figs> (pseudo-C)
00:46:21 <quicksilver> yes
00:46:44 <Figs> how do you specify blah for that?
00:46:50 <dons> what's happening with xmonad -- the charts and graphs musical -- http://www.haskell.org/pipermail/xmonad/2007-June/001116.html
00:46:51 <lambdabot> Title: [Xmonad] xmonad community: charts and graphs
00:46:54 <quicksilver> f would return a struct { b x, c y}
00:46:59 <quicksilver> but in C that feels like a cumbersome thing to do
00:47:08 <quicksilver> whereas in haskell it feels natural + easy
00:47:24 <quicksilver> (C makes you declare structs explicitly, etc)
00:47:25 <Figs> I had an idea for a reflective language where you could do
00:47:38 <Figs> struct Z = f(a);
00:47:47 <Figs> Z.whatever();
00:47:55 <Figs> where Z captures the output of f
00:48:03 <opqdonut> you can practically do that in lua
00:49:22 <Figs> has anyone written a language with both a prototype-based and hierarchy-based object system? (Lisp excluded)
00:50:10 <aspo> javascript sort of
00:50:28 <Figs> I guess I thought javascript was primarily prototype based
00:50:37 <Figs> I mean, seperate but equal
00:51:01 <Figs> two ways of defining objects
00:51:05 <aspo> ruby sort of
00:51:23 <Figs> I'll keep this in mind as an experiment for later
00:51:29 <aspo> actually no sort of about it for ruby
00:51:42 <Figs> definitely, or not at all?
00:51:52 * Figs isn't particularly familiar with ruby
00:52:21 <aspo> definitely
00:52:32 <aspo> although the prototype style takes a few more hoops
00:52:54 <opqdonut> Figs: an object system like that is implementable in lua :)
00:53:17 <Figs> heh, an object system like that can be built on top of C++ :P\
00:53:27 <opqdonut> i guess any sort of object system can be built on top of lua quite easily
00:53:34 <Figs> although I think it'd be a pain in the ass to do
00:54:04 <Figs> what are the basic types in Haskell?
00:54:23 <dons> hmm, `basic'?
00:54:45 <opqdonut> Figs: if you mean first-level, everything
00:54:46 <dons> built in , or `foundational' /
00:54:51 <Figs> primitive
00:54:56 <Figs> fundamental
00:55:03 <Figs> yeah, built-in, I guess
00:55:05 <dons> there aren't primitive types. types are defined in libraries.
00:55:10 <Figs> :|
00:55:15 <dons> ?src Bool
00:55:15 <lambdabot> data Bool = False | True deriving (Eq, Ord)
00:55:23 <opqdonut> numeric types, list, tuple are the most fundamental ones i guess
00:55:26 <dons> ?src []
00:55:26 <lambdabot> data [] a = [] | a : [a]
00:55:29 <opqdonut> but yeah
00:55:32 <opqdonut> they're defined too
00:55:48 <Figs> can you define haskell in haskell?
00:55:51 <opqdonut> so i guess "built-in" is down to numeric types
00:55:57 <opqdonut> Figs: why not, it's turing complete
00:56:06 <dons> it would be a bit weird if you couldn't.
00:56:07 <Figs> I mean like Lisp
00:56:18 <ibid> Figs: depends on what you allow as defining haskell in haskell, but yes
00:56:29 <dons> you mean, doesthe runtime support a metacircular interpreter stack? -
00:56:49 <ibid> Figs: you can certainly write a haskell interpreter in haskell
00:57:14 <Figs> that's not really what I meant
00:57:17 <Figs> but it's ok
00:57:32 <Figs> since I realized the answer isn't very meaningful either
00:57:59 <Figs> so my question is irrelevant
00:58:01 <Figs> forget it
00:59:11 <ibid> in lisp, you can write a very small core interpreter and then define everything else on top of it. that's not - quite - possible in haskell (but again, depends on what you mean by the terms:)
00:59:42 <dons> well.. you could define a very small core haskell interpreter too.
01:00:04 <Syzygy-> > 142559.83/3600
01:00:08 <dons> so its a bit vague. you don't get built in meta programming to implement the parser/evaluator hooks, you'd need a lib for that
01:00:08 <lambdabot>  39.59995277777777
01:00:17 <ibid> dons: as i said :)
01:00:25 <Syzygy-> > 10827716751560/(1024*1024)
01:00:29 <lambdabot>  1.0326115371284485e7
01:00:34 <Syzygy-> > 10827716751560/(1024*1024*1024)
01:00:38 <lambdabot>  10084.097042270005
01:01:20 <Syzygy-> Whoa.
01:01:28 <Syzygy-> That's a LOT of space to have allocated.
01:01:43 <dons> you were using [Char] i guess? ;)
01:01:45 <dons> mwhaha
01:02:07 <Syzygy-> dons: Me? No, [Int].
01:02:24 <Figs> ok, I think I've had as much as my mind can handle for now
01:02:26 <balodja> no diff :)
01:02:31 <Figs> I might bbl
01:02:34 <Figs> cya
01:02:34 <Syzygy-> The 142559.83 is the seconds, the 10827716751560 the space eaten in a calculation I did with :set +s for benchmarking
01:02:46 <opqdonut> hmm, [[Bool]]
01:03:03 <opqdonut> or you could do [(Bool,Bool,...)] as an optimization :P
01:03:04 <Syzygy-> [([[Int]],[[Int]])] ;)
01:03:20 <Syzygy-> (actually ended up using that type... :)
01:03:22 <opqdonut> ?src Integer
01:03:22 <lambdabot> data Integer = S# Int#
01:03:23 <lambdabot>              | J# Int# ByteArray#
01:12:42 <quicksilver> the basic types have "language support" insofar as there is special literal syntax
01:13:08 <quicksilver> also, the Num 'pseudo-constructors' are a slightly irregular from a language perspective
01:13:14 <opqdonut> literal syntax?
01:13:21 <quicksilver> "abc" <- string literal
01:13:25 <quicksilver> 3 <- numeric literal
01:13:35 <quicksilver> [1,2,4] <- list literal :)
01:13:47 <opqdonut> ahh
01:14:04 <Figs> how do you generate random numbers in haskell?
01:14:21 <quicksilver> well, in principle, just like in any other language
01:14:21 <Syzygy-> Figs: With a seed, or with quite some Monad juggling.
01:14:23 <opqdonut> ?hoogle random
01:14:23 <lambdabot> Random.random :: (Random a, RandomGen b) => b -> (a, b)
01:14:24 <lambdabot> System.Random.random :: (Random a, RandomGen g) => g -> (a, g)
01:14:24 <lambdabot> Random :: module
01:14:24 <quicksilver> with a psuedo-RNG
01:14:35 <quicksilver> there is a built-in pseudo-RNG in the standard library
01:14:39 <Figs> but how can you have a prng?
01:14:40 <quicksilver> but it's not language support
01:14:46 <Figs> (if there's no state)
01:14:51 <quicksilver> Figs: you have to keep feeding it the last seed
01:14:54 <quicksilver> you pass the state along
01:14:54 <opqdonut> Figs: the state gets passed
01:14:54 <Syzygy-> Figs: The pRNG has a state.
01:15:10 <quicksilver> although, there are language features which make this state-passing rather "transparent"
01:15:16 <quicksilver> but that's what's happening behind the scenes
01:15:21 <opqdonut> Random.random :: (Random a, RandomGen b) => b -> (a, b) -- you pass a seed and you get a random number and a new seed
01:15:30 <Figs> ok
01:15:42 <opqdonut> ?hoogle randomIO
01:15:43 <lambdabot> Random.randomIO :: Random a => IO a
01:15:48 <Syzygy-> ?doc Random
01:15:48 <lambdabot> Random not available
01:15:49 <opqdonut> or use the IO monad
01:15:59 <quicksilver> which is just a particular way of hiding that state
01:16:02 * Figs isn't taking this lightly, -- I'm trying to think my way through it all
01:16:10 <quicksilver> Figs: no, it was a very sensible question
01:16:21 <Figs> thanks
01:16:39 * Figs is never going to get to sleep tonight; I'll just keep being bothered by these things :P
01:17:46 <Figs> where can I get a haskell compiler or interpreter?
01:18:37 <opqdonut> Figs: haskell.org has links to the implementations
01:18:46 <opqdonut> ghc is quite widely used
01:19:20 <Figs> ok
01:19:24 <Figs> thanks
01:22:18 <Figs> how do you do graphics in haskell on a given system? (presume windows)
01:22:51 <opqdonut> there are a bunch of libraries, Graphics supports both windows and X iirc
01:22:58 <opqdonut> ?where Graphics
01:22:58 <lambdabot> I know nothing about graphics.
01:23:03 <opqdonut> ?hoogle Graphics
01:23:04 <lambdabot> No matches found
01:23:06 <opqdonut> bah
01:23:22 <Figs> is it uncommon to do windows programming in haskell?
01:23:50 <opqdonut> http://haskell.org/haskellwiki/Applications_and_libraries/Graphics
01:23:53 <lambdabot> Title: Applications and libraries/Graphics - HaskellWiki, http://tinyurl.com/3axmhe
01:24:36 <dukedave> opqdonut: I'm guessing Ascii art doesn't cut it?  :)
01:24:54 <opqdonut> :)
01:25:04 * dukedave still loves his terminal GUIs: http://www.cse.dmu.ac.uk/~cir06dt/project/pics/ncurses-fuzzy.png
01:25:22 <Figs> no
01:25:28 <Figs> sorry :P
01:25:33 <Figs> missed the directive
01:25:58 <dukedave> Oops, sorry Figs mean't to point that one at you..
01:26:07 <dukedave> Getting carried away again
01:26:10 <Figs> :P
01:26:41 <Figs> ascii's good for some things...
01:26:48 <Figs> but there's a lot I'd rather do with graphics
01:26:58 <Figs> how many video games have been written in haskell?
01:27:32 <dons> a few, Frag is a rather nic eone
01:27:46 <dons> visit haskell.org, click on 'Applications and libraries'
01:27:48 <quicksilver> Figs: the openGL binding work well
01:27:54 <quicksilver> Figs: so you can do 3D graphics pretty easily
01:28:02 <quicksilver> (well, as easily as openGL ever is, which is a bit of a nightmare)
01:28:17 <quicksilver> for 'application GUIs' there is a gtk binding and a wxwindows binding
01:28:22 <quicksilver> which are both cross-platform
01:28:26 <dons> http://haskell.org/haskellwiki/Frag is the main 3D shooter game written in haskell, using opengl
01:28:27 <lambdabot> Title: Frag - HaskellWiki
01:28:50 <quicksilver> having programming in openGL in quite a few languages, I'm happy to say that it's easier than haskell in most others
01:28:51 <lucca> dukedave: that's... horrible
01:28:55 <Figs> how on earth do you do openGL in a PF language?
01:28:55 <quicksilver> (much better than C or C++)
01:29:07 <lucca> dukedave: use the vt100 line characters to make a better vertical position approximation
01:29:14 <Figs> I thought OpenGL was based on a state machine
01:29:15 <quicksilver> Figs: the main 'spine' of the code looks pretty imperative
01:29:18 <quicksilver> it is
01:29:26 <quicksilver> and that statemachine gets passed around behind the scenes
01:29:32 <Figs> 0.0
01:29:34 <quicksilver> (in what is known as 'a monad')
01:29:46 <Figs> I'm starting to get the idea
01:29:47 <quicksilver> but the FP advantage really comes in when constructing scene graphs
01:29:47 <quicksilver> etc
01:29:57 <lucca> dukedave: http://www.accela.net/~lucca/image/ptload.png for example is a (transparent) xterm with a logarithmic loadavg grapher
01:30:01 <quicksilver> everything except the main GL spine
01:30:09 <dons> threading all the game entities is also rather nice
01:30:40 <Figs> I think I should put the language design on hold for a while
01:30:44 <quicksilver> if you program in openGL in C
01:30:49 <quicksilver> you find a massive amount of 'boilerplate'
01:30:54 <dons> there's an awful lot to language design :-)
01:30:54 <quicksilver> that is, annoyingly repetetive code
01:31:03 <quicksilver> which C is unable to abstract
01:31:14 <quicksilver> if you 'convert' that openGL program to haskell
01:31:15 <Figs> well, I don't do openGL in C :)
01:31:23 <quicksilver> you find you can abstract it very easily
01:31:27 <osfameron> I believe I saw an article suggesting that OpenGL could be faster in Perl than in C
01:31:30 <Figs> I don't usually do openGL at all, actually
01:31:34 <dons> to get a grip on how languages are designed, probably start here, http://haskell.org/haskellwiki/Research_papers
01:31:36 <lambdabot> Title: Research papers - HaskellWiki
01:31:49 <osfameron> because, obviously, 99% of the work is done in the library anyway, so the speed of C isn't really required for the scripting
01:31:53 <Figs> I've been working on this for a while
01:32:23 <Figs> and I have some good ideas, (I think)
01:32:40 <Figs> but more thinking will probably make a better product
01:33:29 <Figs> I'm starting to get a good idea about the high-level/low-level split
01:33:37 <Figs> I just wish there was a better way to bridge the two
01:33:46 <quicksilver> Figs: you might be amused to read abuot 'harpy'
01:33:56 <quicksilver> Figs: that's a system which embeds x86 assembler into haskell
01:34:01 <Figs> haa :P
01:34:04 <quicksilver> Figs: you can generate assembly at runtime
01:34:13 <quicksilver> (the actual opcodes can be chosen at runtime, not compile time)
01:34:19 <Figs> in protected mode? O.o
01:35:16 <opqdonut> hehe mutable code
01:36:21 <quicksilver> Figs: well this is under multi-user OSes so it would run in user-space
01:36:40 <quicksilver> Figs: if you had a kernel-mode haskell RTS
01:37:29 <quicksilver> then sure :)
01:37:37 <quicksilver> but I'm not aware of a kernel-side haskell project
01:38:45 <dons> house and sel4 are kernel-side haskell, in various ways
01:39:11 <quicksilver> interesting
01:39:13 <dons> and the original hOp too, just ghc haskell on bare metal.
01:39:16 <quicksilver> there is much I do not know :)
01:39:23 <dons> ?where house
01:39:23 <lambdabot> http://www.cse.ogi.edu/~hallgren/House/
01:39:41 <dons> quicksilver: its our flagship kernel!
01:39:47 <dons> behold the glory of the H monad.
01:40:10 <quicksilver> wow, house is pretty cool
01:40:34 <quicksilver> ah, another runciman student project?
01:40:40 <dons> uber-cool, i think. maybe mega-cool. nah, OGI guys.
01:40:58 <dons> the window system came from fudgets, iirc
01:40:59 <quicksilver> oh, that was 'gadgets' that was runciman-student
01:41:14 <dons> ah yes.
01:41:35 <quicksilver> damn I have too much work to do this morning. Must close web broweser and exert some self-control ;)
01:42:27 <osfameron> hehe
01:42:58 <Figs> I have too many damned languages to learn this summer
01:43:08 <Figs> haskell, java, javascript, scheme...
01:44:10 <Figs> I'm very likely to need to learn java for school, so I'd rather do it on my own and get it over with rather than waste a semester on relearning what a while-loop is...
01:44:37 <Figs> and never getting to the real stuff
01:44:52 <Figs> hmm
01:45:01 <Figs> I guess I am a tad impatient :P
01:45:27 <quicksilver> learning those four languages gives you an excellent cross-section actually
01:45:42 <quicksilver> add 'perl' to the list, perhaps, to represent 'pathological scripting'
01:46:51 <tibbe> @src lines
01:46:52 <lambdabot> Source not found. You type like i drive.
01:47:00 <tibbe> @src Prelude.lines
01:47:00 <lambdabot> Source not found. Wrong!  You cheating scum!
01:47:03 <dons> scheme, haskell, prolog, java. that'd be enough to cover most things.
01:47:05 <dons> toss erlang in.
01:47:05 <osfameron> perl|ruby|python all worth looking at
01:47:08 <dons> ditch scheme maybe.
01:47:26 <quicksilver> I think scheme's worth having in the list
01:47:33 <quicksilver> it's  properly homo-iconic
01:47:34 <osfameron> as in "any one of those", don't think it's worth learning all of them
01:47:40 <quicksilver> that's an unusual thing
01:47:48 <dons> yeah.
01:47:55 <quicksilver> osfameron: I vote perl because it's least similar
01:48:07 <quicksilver> osfameron: ruby is much like a mixture of javascript and haskell
01:48:19 <dons> and smalltalk
01:48:28 <quicksilver> in fact, there is very little in ruby/python which isn't in javascript
01:48:30 <osfameron> and perl :-)  but, yeah, ok, fair point
01:48:52 <dukedave> Bleugh, my undergrad language experience way dire.. A war between the Java / UML evangelists and the C purists. I was surprised anyone was turning up after the first month :(
01:49:09 <Figs> scheme's likely to show up in the academic world for me
01:49:40 <michie1> learning four languages... it takes years just to learn one properly imho
01:49:42 <Figs> I'll probably learn perl just to learn their quirky regex
01:49:45 * quicksilver shrugs
01:49:56 <quicksilver> michie1: it takes the same amount of time to learn four properly as one properly
01:49:59 <quicksilver> more-or-less
01:50:03 <quicksilver> they amortize together
01:50:03 <Figs> which has a near 1 - 1 correspondence with everything in my regex except references
01:50:16 <tibbe> how would I implement "lines"?
01:50:23 <tibbe> my brain is not working this morning
01:50:29 <tibbe> haven't had my thinking tea yet
01:50:40 <quicksilver> tibbe: takeWhile (/= "\n"), dropWhile (=="\n")
01:50:42 <quicksilver> tibbe: that sort of thing
01:51:02 <quicksilver> tibbe: you can do it in a oneliner with unfoldr and appropriate take/drop Whiles
01:51:23 <tibbe> hmm ok
01:51:26 <tibbe> @src lines
01:51:26 <lambdabot> Source not found. Take a stress pill and think things over.
01:51:31 <tibbe> why isn't src working?
01:51:35 <tibbe> @source lines
01:51:35 <lambdabot> lines not available
01:51:55 <Figs> michiel: I already have a very advanced level of knowledge in C++, so I'm not worried about Java except for two things: 1) memorizing their library, 2) I'm used to pointers...
01:53:03 <Figs> the rest of it seems like quirks and things called by different terms
01:53:12 <Figs> (from what I can tell)
01:53:26 <vincenz> dons: I wouldn't ditch scheme, the macro system and flexibility allows one to easily study different semanticsal models without having to worry too much about varying surface syntax
01:53:29 <tibbe> design might be a bit difference with java because of garbage colletion
01:53:39 <vincenz> dons: unless your list wasn't referring to learning
01:53:43 <Figs> true
01:54:13 <Figs> I think I was the one making the list, unless I missed a line...?
01:54:27 <Figs> *what'd I miss*
01:54:36 <vincenz> 7 minutes back
01:54:43 <Figs> oh, I see it
01:54:50 <Figs> yeah, prolog would be good
01:54:51 <tibbe> I'm feeling really stupid today
01:55:01 <Figs> I always feel stupid
01:55:05 <Figs> it's a good sign
01:55:12 <vincenz> Means you're climbing up, not down
01:55:14 <Figs> it means you've got a chance to learn something
01:55:27 <Figs> you should be worried when you feel smart
01:55:32 <Figs> :P
01:55:34 <Figs> 9/10 of the time
01:55:38 <tibbe> I have a list [Foo, Foo, Bar, Foo, Bar, Foo] which I want to split into [[Foo, Foo], [Foo], [Foo]] by having Bar act as a newline
01:56:04 <tibbe> which I should know how to do easily
01:56:12 <tibbe> but alas
01:56:21 <vincenz> @type span
01:56:23 <lambdabot> forall a. (a -> Bool) -> [a] -> ([a], [a])
01:56:33 <tibbe> so is it a fold of span or something?
01:56:35 <vincenz> tibbe: repeatedly apply span
01:56:41 <vincenz> not quite a fold, but ys
01:56:56 <vincenz> :t split
01:57:00 <lambdabot> forall g. (RandomGen g) => g -> (g, g)
01:57:34 <quicksilver> tibbe: here is an extraordinarly stupid way to write lines
01:57:38 <tibbe> what would the primitive recursion solution look like
01:57:42 <quicksilver> > let {mylines [] = []; mylines ('\n':xs) = []:mylines xs; mylines [x] = [[x]] ; mylines (x:xs) = (let (y:ys) = mylines xs in (x:y) : ys)} in mylines "a\nb\nc"
01:57:45 <lambdabot>  ["a","b","c"]
01:58:06 <vincenz> > span (== 'a') "bca"
01:58:08 <lambdabot>  ("","bca")
01:58:09 <vincenz> > span (== 'a') "bcabca"
01:58:10 <lambdabot>  ("","bcabca")
01:58:16 <vincenz> > span (/= 'a') "bcabca"
01:58:18 <lambdabot>  ("bc","abca")
01:58:42 <tibbe> thanks
01:59:06 <quicksilver> it's an unfold of span, rather than a fold
01:59:07 <vincenz> > let {split c [] = []; split c xs = let (h, t) span (/= c) in h:span (tail t)} in split 'a' "abcdabcda"
01:59:07 <lambdabot>  Parse error
01:59:13 <quicksilver> although arguably it's not a very idiomatic unfold
01:59:15 <vincenz> > let {split c [] = []; split c xs = let (h, t) = span (/= c) in h:span (tail t)} in split 'a' "abcdabcda"
01:59:16 <lambdabot>  Couldn't match expected type `a -> Bool'
01:59:27 <vincenz> > let {split c [] = []; split c xs = let (h, t) = span (/= c) xs in h:span (tail t)} in split 'a' "abcdabcda"
01:59:28 <lambdabot>  Couldn't match expected type `a -> Bool'
01:59:31 * vincenz sighs
01:59:33 <quicksilver> but I think unfolds are a complete primitive recursion pattern
01:59:35 <tibbe> why doesn't lambdabot's source function work?
01:59:45 <quicksilver> dons: what's up with @src?
02:00:04 <vincenz> > let {split c [] = []; split c xs = let (h, t) = span (/= c) xs in h:split (tail t)} in split 'a' "abcdabcda"
02:00:05 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a]
02:00:05 <lambdabot>     Probable c...
02:00:07 <vincenz> there we go, stupid typos
02:01:04 <vincenz> > let {split c [] = []; split c xs = let (h, t) = span (/= c) xs in h:split c (tail t)} in split 'a' "abcdabcda"
02:01:07 <lambdabot>  ["","bcd","bcd"]
02:01:08 <vincenz> at last
02:01:09 <ramesh> @src span
02:01:09 <lambdabot> Source not found. It can only be attributed to human error.
02:01:21 <ramesh> @source span
02:01:21 <lambdabot> span not available
02:01:34 <vincenz> not all functions are in @src
02:01:47 <quicksilver> however, today none of them are :)
02:01:49 <quicksilver> @src foldr
02:01:49 <lambdabot> foldr k z xs = go xs
02:01:49 <lambdabot>     where go []     = z
02:01:49 <lambdabot>           go (y:ys) = y `k` go ys
02:01:51 <quicksilver> oh
02:01:52 <tibbe> > 1 : 2 : 3 : []
02:01:54 <quicksilver> that one is
02:01:54 <lambdabot>  [1,2,3]
02:01:56 <quicksilver> off
02:01:58 <quicksilver> odd
02:02:04 <tibbe> hmpf
02:02:22 <vincenz> tibbe: what did you expect?
02:02:47 <tibbe> from that, what I got
02:02:52 <tibbe> from my code something else
02:02:56 <tibbe> lemme paste
02:02:57 <tibbe> @paste
02:02:57 <lambdabot> Haskell pastebin: http://hpaste.org/new
02:03:53 <Figs> I feel like a hillbilly talking about metaphysics without knowing the vocabulary of religion...
02:04:33 * quicksilver shrugs
02:04:42 <quicksilver> you'll find this one of the most helpful IRC channels in the world :)
02:04:54 <quicksilver> people are normally willing to talk about interesting programming stuff here
02:05:32 <hpaste>  tibbe pasted "Type error" at http://hpaste.org/348
02:05:47 <tibbe> I dont see it
02:06:53 <Figs> how does haskell handle lists of functions of different types?
02:07:20 <ibid> the same way it handles lists of anything with different types
02:07:42 <Figs> well, I mean different numbers of params
02:07:44 <Figs> but how's that?
02:07:49 <ibid> existential types are one option
02:08:17 <ibid> Figs: there are also some ways of faking it for the special case you indicated
02:08:28 <quicksilver> tibbe: you left-bracketed some of your (:)
02:08:32 <quicksilver> tibbe: I don't think that's what you meant
02:08:43 <tibbe> oh
02:08:46 <tibbe> that's why I did
02:08:50 <quicksilver> ((l1@(Lit _):s@(Sep _ _ b):l2@(Lit _)):ts)
02:08:50 <tibbe> >1:2:3:[]
02:08:55 <quicksilver> (l1@(Lit _):s@(Sep _ _ b):l2@(Lit _):ts)
02:09:02 <quicksilver> what you had was
02:09:05 <quicksilver> > (1:2:3):[]
02:09:06 <tibbe> oh
02:09:09 <quicksilver> effectively
02:09:10 <tibbe> tricky tricky
02:09:12 <quicksilver> and that's a type error :)
02:09:13 <lambdabot>   add an instance declaration for (Num [t])
02:09:32 <tibbe> perhaps I could go into I hate lisp and () rant right now? ;)
02:09:38 <tibbe> thanks
02:09:52 <Figs> what about a pair containing a list of functions of different # of params, and a list containing lists/pairs of data to pass to the functions?
02:09:55 <quicksilver> in a complex expression like that, I'd put spaces around the :
02:10:12 <quicksilver> Figs: it can be done, but it probably isn't a "list"
02:10:23 <ibid> Figs: if you can construct the list, there is no trouble putting that into a pair
02:10:24 <quicksilver> Figs: the definition of "list" in haskell is that every element is the same type
02:10:36 <quicksilver> Figs: there are ways around this to do what you want, though
02:10:58 <Figs> ok
02:11:28 <Figs> that kind of stuff is a pain to do in C++ :P
02:11:58 <quicksilver> tibbe: your isFoo predicate already checks that it's Lit
02:12:07 <quicksilver> tibbe: so arguably you don't need the pattern match too
02:12:08 <Figs> mmm...
02:12:20 <Figs> or actually never mind
02:12:22 <quicksilver> (although the pattern match is, in fact, probably fractionally faster)
02:12:33 <tibbe> quicksilver: true
02:12:33 <Figs> thought of better ways of doing that already
02:13:16 <tibbe> quicksilver: I was thinking of type predicates, what if I have a big struct Data type and don't want to do s@(Foo _ _ _ _ _ _) = foo s + bar s ?
02:13:24 <tibbe> constructor predicates
02:13:42 <tibbe> if I want to check just the contructor without saying that I don't care about the fields
02:13:48 <tibbe> I have functions to extract them
02:14:48 <quicksilver> tibbe: well I often end up with isFoo predicates, myself
02:15:01 <quicksilver> tibbe: sometimes I want an entire 'mirror type' which is only the constructors
02:15:15 <tibbe> exatcly
02:15:19 <tibbe> exactly
02:15:23 <quicksilver> data X = Foo a | Bar b ;  data XCT = XFoo | XBar
02:15:36 <quicksilver> and then ctype :: X -> XCT
02:15:37 <yakov> hi
02:15:37 <tibbe> *nods*
02:15:40 <tibbe> hi
02:15:53 <quicksilver> tibbe: this is something which could be automated with a tool like Data.Derive
02:15:59 <quicksilver> tibbe: but I have not got around to doing it yet
02:16:13 <quicksilver> tibbe: my existing code has 'isFoo' predicates in some places
02:16:24 <tibbe> yeah
02:16:39 <quicksilver> tibbe: (in fact, you want ctype to be a method of a typeclass HasConstructorType)
02:16:40 <tibbe> @where source
02:16:41 <lambdabot> I know nothing about source.
02:16:44 <yakov> hi
02:16:48 <vincenz> quicksilver: indeed, I think those predicates would be useful, I think I coded them once with the haskell template system..what's the name again
02:16:51 <tibbe> quicksilver: right
02:16:56 <quicksilver> ctype :: HasConstructorType a b => a -> b
02:16:56 <tibbe> where can I find the prelude source?
02:17:08 <vincenz> @src Prelude
02:17:08 <lambdabot> Source not found. Maybe if you used more than just two fingers...
02:17:14 <tibbe> @source Prelude
02:17:14 <lambdabot> http://darcs.haskell.org/packages/base/Prelude.hs
02:17:20 <tibbe> toooo easy
02:17:28 <quicksilver> @where Prelude
02:17:28 <lambdabot> I know nothing about prelude.
02:17:30 <eivuokko_> @where report
02:17:30 <lambdabot> http://www.haskell.org/onlinereport/
02:17:36 <quicksilver> @docs Prelude
02:17:36 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Prelude.html
02:17:42 <eivuokko_> Report also has examples for most stuff.
02:17:44 <quicksilver> tibbe: you can also go to the docs page
02:17:50 <quicksilver> tibbe: and click 'source' in the top-right
02:18:47 <tibbe> oh
02:18:50 <tibbe> didn't know that
02:19:45 <Figs> if
02:19:49 <Figs> inc n = n+1
02:19:53 <Figs> what does:
02:19:53 <Figs> inc (inc 3) => 5
02:19:54 <Figs> mean?
02:20:22 <vincenz> Figs: it means: applying inc to the result of applying inc to 3 gives 5
02:20:39 <Figs> does that evaluate to 'true'?
02:20:54 <vincenz> nono
02:20:58 <vincenz> I think the syntax => is meta-syntax
02:21:18 <vincenz> typically used in books to say "if you take this code on the left, it will evaluate to the result on the right"
02:21:41 <vincenz> Figs: where does this come from?
02:21:46 <Figs> a book :P
02:21:50 <Figs> or actually
02:21:54 <Figs> a website
02:22:02 <Figs> 'A gentle introduction to ...'
02:22:10 <Figs> which I suppose is also a book
02:22:19 <Figs> link: http://www.haskell.org/tutorial/goodies.html
02:22:20 <lambdabot> Title: A Gentle Introduction to Haskell: Values and Types
02:22:21 <vincenz> Yes, I think the => is meta-syntax
02:22:25 <Figs> ok
02:22:32 <Figs> oh, I see it now
02:22:34 <vincenz> Figs: he even states so
02:22:37 <Figs> there's a line above it I missed
02:22:38 <Figs> yeah
02:22:40 <vincenz> For pedagogical purposes, when we wish to indicate that an expression e1 evaluates, or "reduces," to another expression or value e2, we will write:
02:22:49 <vincenz> Note the different font on =>
02:22:49 <Figs> yeah
02:22:51 <vincenz> Though it's hard to tell
02:22:55 <Figs> I don't know how I missed that :P
02:23:09 <Figs> thanks
02:24:50 <quicksilver> Figs: unfortunately => is also syntax :)
02:24:56 <quicksilver> Figs: so it was a bad choice
02:25:03 <quicksilver> Figs: but, in this case, it was meta-syntax....
02:25:15 <vincenz> quicksilver: there's a slight difference in font but it's hard to spot :)
02:25:19 * quicksilver nod
02:27:32 <Figs> how do you actually get things to happen?
02:28:06 <Figs> is it the last statement in a program?
02:28:07 <quicksilver> what sort of things ? :)
02:28:11 <Figs> anything
02:28:16 <quicksilver> the special 'main' action
02:28:24 <quicksilver> is an IO action which the runtime calls for you
02:28:30 <quicksilver> if you compile to a standalone program
02:29:14 <Figs> if you want a particular sequence of actions, does it have to be done in a list?
02:29:59 <quicksilver> no, monads provide another structure
02:30:04 <quicksilver> which, among other things, can sequence actions
02:30:07 <Figs> ok
02:30:32 <quicksilver> :t do {putStrLn "hello"; putStrLn "world";}
02:30:34 <lambdabot> IO ()
02:30:43 <quicksilver> 'do' introduces a monadic block
02:31:28 <gattocarlo> I'm having trouble in understanding a sort of a memory leak: http://hpaste.org/349 in a loop I run the same program to read the output (the program is "date") and memory keep growing....
02:32:11 <gattocarlo> profiling doesn't show garbage collection
02:32:39 <gattocarlo> profiling for retainers (-hr) does not show anything...
02:33:06 <Botje> gattocarlo: it seems you're not closing those handles.
02:33:21 <gattocarlo> I tried closing the handles without changes
02:33:28 <Syzygy-> You create pipes without ever stopping using them.
02:33:45 <Syzygy-> ?doc System.IO
02:33:45 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/System-IO.html
02:35:21 <yakov> hello
02:35:26 <Syzygy-> gattocarlo: closeFd?
02:35:56 <Syzygy-> You not only need to close the handles, you need to close the File descriptors too.
02:36:38 <Syzygy-> So an > closeFd (handleToFd rh); closeFd (handleToFd wh) would close everything in sight at the end.
02:36:50 <Syzygy-> Put it just as you're done, so before the putStrLn or before the threadDelay...
02:39:58 <Figs> why does this work? http://rafb.net/p/lWxPH678.html
02:39:59 <lambdabot> Title: Nopaste - Haskell Factorial
02:40:11 <Figs> the first line throws me
02:40:50 <int-e> Figs: fac is defined below main.
02:40:58 <Figs> no, the 20
02:41:29 <int-e> hmm? that's just the argument for fac
02:41:35 <Figs> why 20???
02:41:45 <int-e> why not? it prints 20!
02:41:55 <Figs> it doesn't
02:42:00 <gattocarlo> Syzygy-: keep getting "Bad file descriptor" at runtime... I'm investigating
02:43:02 <int-e> Figs: it does. 20! is 1*2*...*20.
02:43:18 <hpaste>  gattocarlo annotated "space leak in reading output of external programs" with "Bad file descriptor" at http://hpaste.org/349#a1
02:43:19 <Figs> I'm trying to get it to run in GHCi, maybe I'm doing something wrong
02:43:28 <int-e> type 'main'
02:43:32 <Figs> but it wants me to run it like Fac 17, or fac 300
02:43:35 <int-e> after loading the file
02:43:44 <Figs> yes
02:43:59 <int-e> you can also use   print (fac 20)  in ghci
02:44:09 <Figs> ok
02:44:26 * Figs is being too logical again
02:44:33 <Figs> and missing the obvious
02:44:34 <Figs> thanks
02:49:59 <dukedave> Is it possible to be too logical in Haskell? :)
02:51:38 <Figs> based on bad assumptions, yes
02:56:02 <Figs> how do I make a function that takes multiple params?
02:56:57 <vincenz> foo a b c = a + b + c
02:57:06 <opqdonut> > let f a b c = a+b/c in f 1.0 2.0 3.0
02:57:08 <lambdabot>  1.6666666666666667
02:57:21 <opqdonut> :t let f a b c = a+b/c in f
02:57:22 <lambdabot> forall a. (Fractional a) => a -> a -> a -> a
02:57:32 <kaol> all functions take just one parameter. some just return functions. :-P
02:57:46 <opqdonut> :t (+)
02:57:48 <DRMacIver> kaol beat me to the pedantry. :)
02:57:49 <lambdabot> forall a. (Num a) => a -> a -> a
02:57:51 <opqdonut> :t uncurry (+)
02:57:52 <Figs> getN n (x:xs) = getN n-1 xs
02:57:53 <lambdabot> forall a. (Num a) => (a, a) -> a
02:58:03 <Figs> what's wrong with that?
02:58:07 <dukedave> kaol: I was wondering whether to jump in too.. Then I remembered what it was like when I was learning :)
02:58:07 <opqdonut> Figs: (n-1)
02:58:23 <opqdonut> otherwise it's parsed as (getN n)-(1 xs)
02:58:31 <opqdonut> function application has highest precedence
02:58:32 <Figs> ah
02:59:12 <Figs> wait, haskell has indent rules?
02:59:20 <Syzygy-> Figs: Yeah.
02:59:31 <DRMacIver> Alas, yes.
02:59:31 <opqdonut> well, theyre optional
02:59:32 <Syzygy-> Unless you tell it explicitly, with {;}, how to scope things, it does it by indentation.
02:59:36 <opqdonut> you can use {;} also
02:59:39 <quicksilver> you don't have to use them, if you don't want to
02:59:45 <quicksilver> so I don't know why DRMacIver says 'alas' :)
02:59:50 <quicksilver> I find them quite unobtrusive
02:59:57 <opqdonut> me too
03:00:00 <Syzygy-> quicksilver: He's just being very much DRMacIver.... ;)
03:00:02 <opqdonut> especially with a proper editor
03:00:02 <DRMacIver> quicksilver: Because I have to read other peoples' code who use them. ;)
03:00:27 <DRMacIver> Syzygy-: It's not my fault that everyone other than me is always wrong.
03:00:36 <Syzygy-> Exactly.
03:00:40 <opqdonut> :
03:00:44 <Syzygy-> The prosecution rests, your honour.
03:00:47 <opqdonut> *:)
03:00:59 <opqdonut> DRMacIver: you should just design your own language :)
03:01:11 <Syzygy-> Again.
03:01:24 <DRMacIver> opqdonut: It's on the to do list.
03:01:30 <opqdonut> :)
03:02:08 <Figs> what is the purpose of 'let'?
03:02:10 <DRMacIver> opqdonut: But that wouldn't solve this particular problem. :)
03:02:23 <DRMacIver> Figs: It creates a local definition.
03:02:23 <opqdonut> Figs: simplification of expressions
03:02:23 <quicksilver> Figs: to introduce a new lexical variable
03:02:36 <quicksilver> Figs: like having a local variable in an inner scope in C++
03:02:40 <Figs> ok
03:04:58 <Figs> why does print have ()'s?
03:05:08 <Figs> names = ["Bob","Joe]
03:05:13 <Figs> ppl = print(names)
03:05:15 <Figs> for example
03:05:19 <Figs> *"
03:05:27 <opqdonut> :t print
03:05:35 <lambdabot> forall a. (Show a) => a -> IO ()
03:05:40 <opqdonut> () is the unit type
03:05:43 <ibid> Figs: because you put them there?
03:05:46 <opqdonut> print doesn't return anything you see
03:05:52 <ibid> Figs: they're not required
03:06:03 <opqdonut> ahhh, parenthesis in func calls :)
03:06:09 <ibid> Figs: or are you referring to some other ()s?
03:06:26 <Figs> no, those
03:06:32 <opqdonut> Figs: print(names) == print (names) == print names
03:06:36 <Figs> I based off an example that said
03:06:41 <Figs> main = print(fac 20)
03:06:44 <Figs> earlier
03:06:56 <Figs> oh
03:06:58 <int-e> print(fac 20) = print (fac 20) = let x = fac 20 in print x
03:07:07 <ibid> Figs: ah, but there it's just order of evaluation stuff
03:07:10 <Figs> yeah
03:07:12 <opqdonut> Figs: well: print fac 20 == (print fac) 20 which doesn't make sense
03:07:12 <Figs> got it
03:07:33 * Figs isn't used to that order of operations
03:07:47 <Figs> thanks
03:08:11 <arcatan> :t printf
03:08:13 <lambdabot> forall r. (PrintfType r) => String -> r
03:09:13 <Figs> I think I'm going to go to sleep
03:09:20 <Figs> I'm getting too slow for this :P
03:09:32 <Figs> `night
03:10:59 <pharm> Any interest in a spot of optimisation?
03:11:00 <hpaste>  gattocarlo annotated "space leak in reading output of external programs" with "closing handles doesn't help" at http://hpaste.org/349#a2
03:11:32 <pharm> In odd spare moments, I took John Harrops simple ray tracer & made a Haskell version.
03:11:45 <pharm> written in idiomatic Haskell (I hope).
03:12:01 <gattocarlo> memory leak problem in reading output from file: closing handles doesn't help
03:12:02 <pharm> Unfortunately, it's about 3 times slower than the OCaML version.
03:13:26 <pharm> http://www.kantaka.co.uk/darcs/ray  //  http://www.kantaka.co.uk/cgi-bin/darcsweb.cgi?r=ray
03:13:28 <lambdabot> Title: Index of /darcs/ray
03:14:13 <pharm> Profiling show most of the time being eaten by intersect', which seems lazier than I expect from looking at -ddump-simpl output
03:14:17 <pharm> suggestions welcome!
03:15:14 <pharm> (I've already tried using seq to make intersect' stricter but it didn't make any difference to the laziness at all which surprised me.
03:15:16 <pharm> )
03:18:49 <pharm> nb. I'd also like to add that debugging floating point problems is icky. Never work with children, dogs or floating point numbers is my advice...
03:19:03 <pharm> s/dogs/animals/
03:22:10 * pharm coughs
03:22:42 <pharm> I can see you lot downloading the code you know.
03:22:50 <pharm> :)
03:24:56 <pharm> NB. Here's the ghc invocation I was using: ghc -O2 -funbox-strict-fields -optc-O3 -fexcess-precision -optc-ffast-math   ray.hs -o ray
03:25:20 <pharm> -optc-O3 makes a *big* difference: more than a factor of 2 speedup IIRC.
03:25:28 <Vq^> @bf ++++++++++[>+++++++>++++++++++>+++>+<<<<-]>++.>+.+++++++..+++.>++.<<+++++++++++++++.>.+++.------.--------.>+.>.
03:25:28 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
03:26:00 <pharm> And the ocaml invocation for completeness:
03:26:02 <pharm> ocamlopt -inline 20 ray.ml -o rayml
03:26:23 <Vq^> @ask dons is @bf broken?
03:26:23 <lambdabot> Consider it noted.
03:26:25 <pharm> Making the datatypes strict didn't help either btw.
03:27:11 <opqdonut> @bf +
03:27:11 <lambdabot>  fd:18: hClose: resource vanished (Broken pipe)
03:27:18 <pharm> (they're already unpacked primitives looking at the dump-simpl output)
03:27:19 <opqdonut> seems broken :)
03:27:52 <quicksilver> pharm: it might be interesting to post a link to your code to the -cafe with a comment that it's 3 times slower than ocaml
03:27:59 <quicksilver> pharm: there are people with the knowhow to optimise :)
03:28:37 <pharm> I could certainly do that...
03:29:07 * pharm wanders off to substribe to Haskell-cafe, since he currently only has read-only access via the Oxford newsserver.
03:30:14 <beelsebob> @tell dons I can give you source for a nice pure BF imlementation that doesn't use file IO at all
03:30:14 <lambdabot> Consider it noted.
03:30:43 <dmhouse> Quick feedback: where are the docs distributed with GHC stored on your system?
03:31:01 <dmhouse> I just need some idea of how it varies from system to system.
03:31:22 <beelsebob> hello world to you too Vq^
03:32:18 <ari> dmhouse: /usr/share/doc/ghc6-doc/html/ in Ubuntu, /usr/share/doc/ghc-6.6/html/ in Gentoo
03:32:22 <olsner> does anyone here know how I can hack firefox to add a View in browser as an option in the Open with/Save as dialog?
03:32:23 <opqdonut> dmhouse: /usr/share/doc/ghc6-doc/
03:32:29 <opqdonut> (debian)
03:32:40 <dmhouse> ari, opqdonut, thanks.
03:34:34 <dmhouse> Anyone on Windows could just answer that question?
03:38:19 <quicksilver> I'm betting it's something hideous like C:\Program Files\GHC-6\Html
03:38:23 <quicksilver> but I actually don't know
03:40:40 <araujo> morning
03:42:56 <beelsebob> dmhouse: on OS X it appears to be /usr/local/share/ghc-6.6/html/
03:43:07 <beelsebob> but that is worryingly empty on my system :/
03:44:05 <pharm> what does bf do?
03:44:09 <pharm> what does bf do?
03:44:12 <opqdonut> brainfuck interpreter
03:44:30 <beelsebob> my one also does ook!
03:44:31 <beelsebob> :P
03:45:20 <triplah_> ook is awesome
03:46:51 <eivuokko_> dmhouse, When installed with Visual Haskell, C:\Program Files\Visual Haskell\doc (and they are in some packed-together html files)
03:47:27 <dmhouse> eivuokko_: 'packed-together'? As in, there isn't a single file for each module?
03:47:46 <dmhouse> I suppose if you're using Visual Haskell then you're not going to be using Emacs, really, which is what I'm writing for.
03:47:51 <eivuokko_> HxS and HxT
03:48:04 <beelsebob> Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook!Ook?Ook.Ook?Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook?Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook?Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook?Ook.Ook.Ook?Ook.Ook?Ook.Ook?Ook.Ook?Ook.Ook!Ook!Ook?Ook!Ook.Ook?Ook.Ook.Ook.Ook.Ook!Ook.Ook.Ook?Ook.Ook.Ook!Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook.Ook!Ook.Oo
03:48:09 <beelsebob> :D
03:48:23 <beelsebob> it really should have the occasional eek in there
03:48:27 <eivuokko_> I know people who used to use emacs and Visual Studio together, but yea, prolly not.
03:48:53 <triplah_> beelsebob: i concur
03:48:58 <triplah_> thats the most missed language feature
03:49:02 <beelsebob> hehe
03:49:06 <dmhouse> eivuokko_: any chance you could email the files to me so I could take a look?
03:49:07 <triplah_> perhaps it should be a system exit
03:49:07 <triplah_> :)
03:49:08 <eivuokko_> Altho I'd install Visual Haskell just for those helps...they can be nicely searched etc with msdn client
03:49:19 <beelsebob> triplah_: lol, I was thinking loop open and close
03:49:24 <triplah_> hahaha true :)
03:49:29 <beelsebob> they're rare enough that one eek in there would make it look nice
03:49:35 <triplah_> yeah
03:49:49 <triplah_> eek consistantly is one of my favourite lines in any pratchett book :)
03:50:00 <beelsebob> hehe
03:50:09 <eivuokko> dmhouse, Yeah, I guess.
03:50:23 <beelsebob> my Ook interpretter also has the advantage that on parse failure it outputs "Out of cheese error, redo from start."
03:50:34 <opqdonut> :)
03:50:41 <opqdonut> great stuff
04:01:07 <pharm> right, the haskell-cafe post is in.
04:17:09 <pitecus> Any idea what that is supposed to mean: openFile: resource exhausted (Too many open files)
04:19:31 <profmakx> pitecus: your process does not have file-descriptors left
04:19:39 <profmakx> (whose count is limited somewhere)
04:20:41 <pitecus> profmakx, isnt a file supposed to be closed after the program is done reading it?
04:21:06 <profmakx> depends what you mean by "supposed to be closed"
04:21:45 <profmakx> and i for sure do not know how this is handled in haskell
04:22:25 <pitecus> :-(
04:22:34 <quicksilver> lazy IO doesn't handle this very well
04:22:54 <quicksilver> pitecus: one moment and I'll find you a thread to read
04:23:52 <profmakx> i suppose that laziness plays its part here
04:23:57 <profmakx> ah quicksilver already answered
04:24:46 <pastorn> hmmm... is (::) a function?
04:24:53 <quicksilver> pitecus: http://www.haskell.org/pipermail/haskell-cafe/2007-March/023498.html
04:24:55 <lambdabot> Title: [Haskell-cafe] Lazy IO and closing of file handles, http://tinyurl.com/2apf7f
04:24:59 <quicksilver> pastorn: no, it's syntax
04:25:04 <pastorn> or is it just something syntactic, above the language
04:25:06 <pitecus> thanks quicksilver
04:25:31 <pastorn> oh... thought it might have been a function that assigns a type to a function or something...
04:26:45 <quicksilver> this leads me to think that lazy IO is a bad thing
04:27:01 <quicksilver> but it leads other people to belive that it's just our implementation of lazy IO which is inadequate
04:27:04 * quicksilver shrugs
04:28:42 <pastorn> what are the selling points of lazy io?
04:29:05 <DRMacIver> Much the same as the selling points of lazy anything else as I understand it. :)
04:29:47 <pastorn> but it seems stupid for IO, the one place, where at least for me, procedual evaluation seems to make sense
04:30:09 <quicksilver> pastorn: (1) it's non deterministic (2) no one understands it (3) it can crash you program in any location you don't expect (4) it destroys referential transparency
04:30:16 <quicksilver> pastorn: and those are the good parts :)
04:31:50 <pastorn> is these what non-lazy io would do?
04:32:04 <quicksilver> no that's what lazy IO does :)
04:32:36 <opqdonut> :
04:33:06 <LoganCapaldo> opqdonut: trying to reload your code? :)
04:34:11 <pastorn> yay
04:34:53 <pastorn> quicksilver: couldn't you just add '!' every here and there and thus eliminate the lazyness?
04:35:41 <fasta> Is needing instance MonadState s (ST s1) a bug? Or can it easily be defined?
04:36:13 <gkr> How can I create a foldT, where T is a type I defined? Are there any standard form for folds?
04:36:25 <quicksilver> fasta: what type of state would you expect ST s1 to have?
04:36:27 <vincenz> gkr: in general?
04:36:39 <gkr> Yep.
04:36:40 <quicksilver> gkr: yes, it's the inverse of your constructors
04:36:42 <vincenz> gkr: well you need to have as many arguments as you have data-constructors
04:36:59 <gkr> folds look like homomorphirsm between monoids, but I am not sure :-/
04:37:10 <vincenz> data X a b = Foo a | Bar b | DumDum (X a b) | Powie Int
04:37:27 * dblhelix is back...
04:37:50 <vincenz> foldX :: (X a b) -> (a -> c) -> (b -> c) -> (c -> c) -> (Int -> c) -> c
04:37:50 <quicksilver> gkr: 'catamorphism' is the word
04:37:53 <vincenz> something like that?
04:38:07 <fasta> quicksilver: I think it's a bug. Essentially, I want to have access to things that come from code that runs in runStateT within the outer monad(i.e. the state monad for StateT).
04:38:17 <quicksilver> fasta: you didn't answer my question
04:38:34 <quicksilver> fasta: MonadState s m says "M is a monad encapsulating state of type s"
04:38:36 <gkr> Yep.
04:38:47 <quicksilver> fasta: what is 's' for "ST s1" ?
04:39:52 <gkr> Ea!, here is something: http://haskell.org/hawiki/WhatIsaFold
04:39:53 <lambdabot> Title: WhatIsaFold - The Haskell Wiki
04:41:23 <fasta> quicksilver: I don't know, since s1 is used to designate one state thread and the s is used as a type.
04:42:13 <vincenz> folds should be autogenerate
04:42:14 <vincenz> +d
04:42:28 <vincenz> data Bloo = .... deriving(Fold)
04:42:34 <fasta> quicksilver: but I can imagine it could implement any state(i.e. a), by storing everything in references.
04:43:05 <fasta> I think it's horrenduously stupid to do "deriving" anything. It should just derive it, unless I define it.
04:43:22 <vincenz> fasta: that's' orthogonal :)
04:43:40 <fasta> vincenz: I know
04:44:28 <ibid> fasta: and how is it supposed to know whether it's not defined in some other module?
04:44:40 <ibid> without whole-program analysis, that is
04:45:18 <fasta> ibid: it could do that in a variety of ways
04:45:57 <ibid> fasta: even in the presence of dynamic linking?
04:46:20 <fasta> ibid: it's a computable function, so yes.
04:46:26 <quicksilver> fasta: right, that's by point
04:46:36 <ibid> fasta: uh, it's not
04:46:52 <quicksilver> fasta: it is not an instance of MonadState because MonadState says you must have a specific 'type' which represents your state
04:46:56 <ibid> fasta: you can't compute without having the necessary inputs
04:47:02 <quicksilver> fasta: ST s1 does not have representable state
04:47:23 <fasta> quicksilver: ok, so I should use a transformer type somewhere.
04:47:33 <fasta> Refactoring Haskell code is non-trivial
04:47:41 <quicksilver> 'deriving' is a very harmful operation which damages program equivalence
04:47:50 <quicksilver> doing deriving automatically would be most unpleasant
04:47:56 <ibid> fasta: consider the case where i write a program, you write a plugin that defines a new instance of Eq of something my program uses.  how does my compiler know not to derive the Eq instance?
04:48:18 <fasta> ibid: the compiler does derive it, but it determines at run-time all instances.
04:48:38 <fasta> ibid: then it chooses the one added last or first depending on preferences.
04:48:46 <ibid> fasta: ah, so the derived instance is a "weak symbol", so to speak
04:49:02 <ibid> that might work
04:49:15 <fasta> ibid: I don't know that term
04:49:20 <ibid> though it's bound to create confusion
04:49:40 <fasta> Everything I can do a computer can do faster.
04:49:54 <fasta> Well, not everything, but it will some day.
04:50:07 <ibid> fasta: it's a dynamic linking term. a weak symbol is a symbol exported by a dynamic object that the entity using the object can override by defining its own version
04:50:29 <ibid> fasta: normally (ie. with non-weak symbols) this creates a link-time error
04:51:08 <fasta> ibid: such that the code in the dynamically linked object used the external symbol, right?
04:51:10 <DRMacIver> fasta: Great. Now I have a mental image of lambdabot singing "Everything you can do, I can do better". :)
04:51:16 <fasta> er uses
04:51:20 <ibid> fasta: generally, yes
04:51:27 <ibid> fasta: i think, at least
04:51:32 <fasta> DRMacIver: lambdabot 2200 will probably do that
04:51:57 <fasta> Unless someone pushes the Red Button.
04:51:59 <ibid> fasta: though it's possible to link the DO in such a way that its internal references are not resolved at link time
04:52:21 <fasta> ibid: ok, so "everything is possible" :)
04:52:40 <ibid> fasta: but this is how some of the malloc debuggers out there work; they override the malloc, realloc and free symbols :)
04:53:02 <ibid> fasta: also how the "fakeroot" utility works, afaik
04:53:31 <ibid> fasta: well, yes, everything that you can spec is possible. often it's the spec that's the problem :)
04:54:37 <fasta> ibid: heh, what a horrible way for a debugger to work.
04:55:42 <ibid> fasta: uh, malloc debuggers are quite unlike debuggers :)
04:56:14 <fasta> ibid: oh, ok, it is for debugging the memory allocator?
04:57:07 <ibid> fasta: it's for finding memory leaks and detecting uses of dangling pointers
04:57:32 <pharm> Although valgrind is much better at that than a malloc wrapper (usually)
04:57:38 <ibid> true
04:58:05 <ibid> valgrind is a newcomer to the scene, though
04:58:31 <ibid> and is harder to port
04:58:33 <opqdonut> valgrind <3
04:59:03 <ibid> but very useful, yes
05:00:15 <quicksilver> ibid: fakeroot uses LD_PRELOAD, I think
05:01:53 <ibid> quicksilver: yes, but that wouldn't work if the symbols weren't weak, afaik
05:04:21 <quicksilver> pharm: valgrind is awesome but it is rather slow :)
05:15:17 <pharm> quicksilver: Well, there is that :)
06:33:08 <SL> hello
06:34:06 <ttfh> hej
06:34:31 <SL> I have a type signature lets say "fun :: x -> y -> z" now I want to restrict x and y to typeclass Num. How do I do this?
06:35:14 <Saizan> fun :: (Num x,Num y) => x -> y -> z
06:36:37 <SL> thanks
06:37:18 <SL> is it also possible to say they must be both of the same type?
06:37:28 <ttfh> yes
06:37:28 <Saizan> sure
06:37:42 <Saizan> ?type (+)
06:37:45 <lambdabot> forall a. (Num a) => a -> a -> a
06:37:49 <LoganCapaldo> fun :: Num x => x -> x -> z
06:37:53 <ttfh> fun :: Num x => x -> x -> y
06:39:28 <ttfh> hmm, this reminds me of something
06:40:12 <ttfh> that type says that "fun" is a function taking two arguments of the same type
06:40:50 <Jaak> that fun is boring
06:40:52 <SL> yes, just had a blockhead
06:40:59 <Saizan> and returning something of any type, so it's f _ _ = undefined
06:41:02 <DRMacIver> Hm. I don't think I follow why lazy evaluation is needed for the O(1) dequeue operations of a finger tree.
06:41:05 <LoganCapaldo> Jaak: very boring
06:41:13 <SL> i tried to write a statetransformer for state monad
06:41:23 <SL> just in the process of learning monads
06:47:28 <fasta> I had some code which worked in the ST monad (actually MonadST), then I added a call to runStateT around that code. Only in a few places I use functions that belong to MonadState, but AFAIK, I need to lift all the rest now. So, I get do put <something>; lift(something in ST monad); get something; lift(something in ST monad) and so on. Can this be improved somehow?
06:48:16 <LoganCapaldo> @hoogle liftST
06:48:17 <lambdabot> No matches found
06:48:29 <LoganCapaldo> so much for that idea
06:49:05 <fasta> LoganCapaldo: I already have liftST
06:49:15 <LoganCapaldo> k
06:49:24 <LoganCapaldo> just trying things :)
06:49:32 <fasta> LoganCapaldo: but maybe that just works
06:51:31 <fasta> LoganCapaldo: hmm, it appears the lifts were already redundant.
06:54:18 <ttfh> hmm, why can't I write "f x x = ..."?
06:54:49 <DRMacIver> Patterns can only contain free variables.
06:55:17 <DRMacIver> Otherwise you could e.g. introduce implicit eq dependencies.
06:55:31 <DRMacIver> (And make the matching much harder)
06:57:34 <LoganCapaldo> its funny how you would think you need Eq to pattern match at all, but you really don't it turns out
06:57:51 <LoganCapaldo> I didn't quite grasp how that could work for a while
06:59:13 <DRMacIver> Hm.
06:59:23 <DRMacIver> I don't really follow why you would need to.
06:59:34 <DRMacIver> Well, I mean you don't. But I don't follow why one might think you do. :)
07:00:20 <mattam> To do the testing i guess
07:00:24 <ttfh> I *think* you can write patterns like that with Bigloo Schemes pattern matching extension
07:02:24 <SamB> LoganCapaldo: you do need Eq for number pattern matching ;-)
07:02:53 <LoganCapaldo> SamB: At least if you want any hope of efficiency :)
07:03:20 <SamB> LoganCapaldo: no, seriously, that's how the report says number patterns are matched ;-)
07:03:32 <LoganCapaldo> SamB: ah cool. didn't know that
07:03:38 <quicksilver> yes, but numbers aren't real pattern matching
07:03:41 <quicksilver> they're guards in disguise
07:03:46 <quicksilver> (which is a shame, perhaps)
07:03:50 <SamB> yeah, I was just thinking of that
07:03:58 <SamB> and personally I don't think it is at all a shame
07:04:06 <SamB> I think it's very handy
07:04:35 <LoganCapaldo> DRMacIver: coming from the land of traditional impertive programming where the only way to see if something is the same or similar was to compare with the equlity operator (or compare components with the equality operaqtor) you tend to assume that pattern matching is implemented in terms of ==
07:04:57 <quicksilver> You can imagine the semantics for f x x =
07:05:08 <SamB> LoganCapaldo: but didn't you know that == was implemented in terms of pattern matching (in most cases)
07:05:09 <SamB> ?
07:05:11 <vincenz> quicksilver: afaik that's illegal
07:05:13 <LoganCapaldo> Or at least if you subsittute "LoganCapaldo" for you in my last statement
07:05:14 <quicksilver> it is
07:05:19 <quicksilver> I'm just saying you coul dimagine how it might work
07:05:21 <SamB> hehe
07:05:25 <ttfh> so "f x x = ..." = "f x y | x == y = ..." it would be?
07:05:26 <quicksilver> but it would require imprecise exceptions
07:05:27 <DRMacIver> LoganCapaldo: They look more like switching on a property to me. :)
07:05:53 <LoganCapaldo> DRMacIver: yeah but switches are gotos in disguise :)
07:05:54 <quicksilver> everyime the thunk was forced, it would keep checking both ones had the same top-level
07:06:11 <DRMacIver> LoganCapaldo: Yeah. And they have many other good points too. :)
07:06:12 <SamB> it looks cather like switch foo.tag
07:06:14 <SamB> er.
07:06:19 <SamB> s/cather/rather/
07:06:25 * DRMacIver likes goto.
07:06:28 <SamB> maybe with more parens
07:06:52 <LoganCapaldo> ttfh: yes btw
07:08:28 <LoganCapaldo> switch thing.tag was initially how I thought it _had_ to work (or a giant nested if).
07:08:50 <LoganCapaldo> But I am a fool, and I learned :)
07:10:26 <ttfh> http://www-sop.inria.fr/mimosa/fp/Bigloo/doc/bigloo-7.html#Pattern-Matching
07:10:29 <lambdabot> Title: BiglooA ``practical Scheme compiler''User manual for version 3.0aMay 2007, http://tinyurl.com/29swfk
07:10:41 <SamB> LoganCapaldo: that *is* how it works ;-)
07:10:49 <ttfh> look in the examples
07:11:04 <LoganCapaldo> SamB: sure. But I thought that was the _only_ way you could do it
07:11:10 <SamB> hmm?
07:11:32 <mattam> That is the only way.
07:11:33 <SamB> oh, well, you can do it by vectored returns too...
07:11:42 <SamB> but that's not really any different...
07:12:05 <mattam> Isnt't it LoganCapaldo ?
07:12:12 <ttfh> Bigloo is my favorite Scheme implementation...
07:12:27 <SamB> Igloo > Bigloo
07:12:35 <ttfh> Igloo?
07:12:39 <LoganCapaldo> well if what SamB means by vectored returns is the same as what I'm thinking of, apparently it is the only way
07:13:54 <LoganCapaldo> I was thinking of church encoding things and transforming case e of Left x -> x ; Right y -> y to e (\x -> x) (\y -> y)
07:14:19 <SamB> LoganCapaldo: oh, sure, that also works
07:14:21 <ttfh> I wrote the coding parts of my thesis using Bigloo, I wanted to use haskell of course, but there wasn't time for learning a new language AND writing the thesis...
07:14:53 <SamB> Igloo is the most prominent Haskell Debian maintainer
07:14:57 <LoganCapaldo> it was learning about that that really opened the door for me for why you wouldn't necessarily want or need an Eq to do pattern matching
07:15:24 <ttfh> SamB: ok
07:15:50 <LoganCapaldo> you're not gonna use == to peek inside a function to see if its the same as another function after all
07:15:51 <SamB> actually, I rather like some functions that let you church encode a value ;-)
07:16:03 <LoganCapaldo> yeah either and maybe are cool
07:16:37 <LoganCapaldo> SamB: vectored returns ~= jump table?
07:16:46 <SamB> pretty much
07:27:41 <shapr> hej ttfh
07:29:08 <fasta> I wish I was able to see what generated a constraint...
07:30:06 <fasta> The algorithm to compute it isn't that difficult, it's just work.
07:35:34 <LeCamarade> You know, it will be long before I recover from the first time I saw this cartoon: http://shemesh.larc.nasa.gov/images/humor-zfc.jpg
07:37:15 <osfameron> apparently ZFC "is stronger than what is required for nearly all of everyday mathematics"
07:37:34 <LeCamarade> The guy only _insinuated_. And he got shot. That Type Theorist must be somewhere on c.l.l, if we need to arrest.
07:37:39 <osfameron> :-)
07:38:08 <vincenz> @google zfc
07:38:10 <lambdabot> http://en.wikipedia.org/wiki/ZFC
07:38:10 <lambdabot> Title: ZermeloFraenkel set theory - Wikipedia, the free encyclopedia
08:00:04 <therp> rain! finally!
08:00:29 <fasta> I have some code I use for debugging that generates a (MonadFix m) constraint, but when I use this code in a location that doesn't support MonadFix, (e.g. ContT) then it's not going to work. As a "solution" I can lift it, but this changes other types in my program, and while it's only "debugging code", that's not nice either.
08:11:29 <sjanssen> @keal
08:11:29 <lambdabot> i suggest you tear apart a 20q and plug it with the alg
08:11:49 <fasta> @photontorpedo
08:11:49 <lambdabot> what is haskell?
08:11:52 <fasta> @photontorpedo
08:11:52 <lambdabot> why haskell over smalltalk? I thought smalltalked rocked
08:12:06 <sieni> @lambdabot
08:12:06 <lambdabot> Unknown command, try @list
08:12:25 <sieni> @sieni
08:12:30 <fasta> photontorpedo said quite a lot :)
08:12:43 <fasta> @quote sieni
08:12:44 <lambdabot> sieni says: python, like php, is just training wheels without the bike
08:12:44 <sieni> @quote sieni
08:12:44 <lambdabot> sieni says: let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
08:12:51 <sieni> haha
08:13:08 <fasta> @quote fasta
08:13:08 <lambdabot> fasta says: MySQL is for people who think of PHP and MySQL as one concept.
08:13:14 <LoganCapaldo> > let {me = ('$':); the = me; money = "$"} in show $ me $ the $ money
08:13:16 <lambdabot>  "\"$$$\""
08:13:55 <fasta> @quote LoganCapaldo
08:13:56 <lambdabot> LoganCapaldo says: <sorear> I am not having any luck converting Chris Kuklewicz :( <LoganCapaldo> Does he implement Typeable?
08:14:09 <fasta> @quote sorear
08:14:09 <lambdabot> sorear says: a shattered vase is leaky
08:14:22 <sieni> @quote fasta
08:14:22 <lambdabot> fasta says: MySQL is for people who think of PHP and MySQL as one concept.
08:14:28 <sieni> only one?
08:14:30 <sieni> @quote sieni
08:14:30 <lambdabot> sieni says: the advantage of haskell is that it doesn't suck
08:14:41 <mauke> @quote mauke
08:14:41 <lambdabot> mauke says: also, int *(*where_is_your_god_now[123])[42];
08:28:05 <vincenz> @localtime dons
08:28:07 <lambdabot> Local time for dons is Fri Jun 22 01:27:05 2007
08:28:18 <vincenz> ODd localtime for australia..
08:28:21 <vincenz> anyone here from down under?
08:35:31 <LeCamarade>   [Placeholder for a long-promised entry which I haven't yet forgotten
08:35:32 <LeCamarade>   about.]
08:36:00 <eivuokko> o.O
08:37:40 * [LeCamarade steps out for a bit ...
08:38:55 <vincenz> Anyone from australia ?
08:40:32 <quicksilver> not so likely at this time of day :)
08:40:42 <vincenz> too early?
08:41:49 <desp> @hoogle a -> IO (Ptr a)
08:41:53 <lambdabot> No matches, try a more general search
08:41:57 <desp> @hoogle a -> Ptr a
08:41:58 <lambdabot> No matches, try a more general search
08:42:25 <desp> I may be missing something here, but how should I construct a Ptr to something?
08:43:10 <desp> ah, Foreign.Marshal.Alloc
08:43:11 <desp> right.
08:43:12 <eivuokko> You can allocate raw memory with various functions, and you can get them from C-apis.
08:44:01 <eivuokko> Very often you might want to use ForeignPtrs and with-style functions to keep memory handling easy.
08:44:12 <desp> eivuokko: right
09:20:03 * SamB thinks DeriveGuess should try for more readable output...
09:31:20 <LoganCapaldo> @type foldr (.) id . map (:) -- I think this is a cool way to define (++)
09:31:22 <lambdabot> forall a. [a] -> [a] -> [a]
09:31:49 <nomeata> is it a good way?
09:31:52 <nomeata> @src (++)
09:31:53 <lambdabot> (++) []     ys = ys
09:31:53 <lambdabot> (++) (x:xs) ys = x : xs ++ ys
09:31:57 <LoganCapaldo> I doubt it :)
09:32:23 <jfoutz> concat ["a", "b", "c"]
09:32:28 <jfoutz> >concat ["a", "b", "c"]
09:32:35 <jfoutz> > concat ["a", "b", "c"]
09:32:37 <lambdabot>  "abc"
09:32:43 <jfoutz> third time's the charm
09:33:00 <kaol> > ['a'..'c']
09:33:03 <lambdabot>  "abc"
09:33:07 <jfoutz> @src concat
09:33:07 <lambdabot> concat = foldr (++) []
09:33:32 <jfoutz> lambdabot is neat.
09:33:46 <Saizan> > let xs ++ ys = foldr (:) ys xs in [1..3] ++ [4..6]
09:33:47 <lambdabot>  [1,2,3,4,5,6]
09:34:00 <chessguy> @quote lambdabot
09:34:01 <lambdabot> lambdabot says: <dmwit> ?quote ?quote <lambdabot> Plugin `quote' failed with: IRCRaised regex failed: (ReturnCode 13,"repetition-operator operand invalid")
09:34:16 <LoganCapaldo> Saizan: it seems I overcomplicated :)
09:35:08 <jfoutz> so, foldr is generaly better than foldl? that's sorta hard to deal with... i'm so used to explicit accumulators for speed, but lazyness lets foldr skip unnessecary evaluation, is that right?
09:35:15 <LoganCapaldo> @type foldr (foldr (:))
09:35:17 <lambdabot> forall a. [a] -> [[a]] -> [a]
09:35:26 <LoganCapaldo> @type foldr (foldr (:)) []
09:35:28 <lambdabot> forall a. [[a]] -> [a]
09:35:51 <LoganCapaldo> obfuscated haskell contest would be a nightmare
09:36:02 <chessguy> that's what @pl is for ;)
09:36:08 <ari> jfoutz: Read the rather strangely named wiki page http://www.haskell.org/haskellwiki/Stack_overflow if you want to know what fold direction to use
09:36:09 <lambdabot> Title: Stack overflow - HaskellWiki
09:36:14 <SamB> (????) = (??) . (???)
09:36:28 <LoganCapaldo> chessguy: yeah but pl isn't necessarily pathalogical
09:36:44 <LoganCapaldo> Although it often is :)
09:37:02 <chessguy> @spell pathological
09:37:05 <ddarius> ari: The page is about stack overflows and uses folds as representative examples.
09:37:21 <chessguy> @dict pathalogical
09:37:21 <lambdabot> Supported dictionary-lookup commands:
09:37:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
09:37:21 <lambdabot> Use "dict-help [cmd...]" for more.
09:37:29 * chessguy kicks the stupid bot
09:37:35 <chessguy> @help spell
09:37:35 <lambdabot> spell <word>. Show spelling of word
09:37:39 <LoganCapaldo> @all-dicts pathological
09:37:41 <lambdabot> *** "Pathological" gcide "The Collaborative International Dictionary of English v.0.48"
09:37:41 <lambdabot> Pathologic \Path`o*log"ic\, Pathological \Path`o*log"ic*al\, a.
09:37:41 <lambdabot>    [Gr. ?: cf. F. pathologique.]
09:37:41 <lambdabot>    1. Of or pertaining to pathology.
09:37:41 <lambdabot>       [1913 Webster]
09:37:43 <lambdabot> [69 @more lines]
09:37:43 <jfoutz> ari, thanks.
09:37:50 <chessguy> @spell pathalogical
09:38:00 <chessguy> i guess that's broken
11:35:50 --- topic: '["The Haskell programming language: Write less, think more!","Home: http://haskell.org","Paste: http://hpaste.org","Logs: http://tunes.org/~nef/logs/haskell/","History: http://tinyurl.com/yowkle","The language of ICFP winners 3 years running"]'
11:35:50 --- topic: set by dons on [Sun May 27 19:49:12 2007]
11:35:53 <byorgey> suppose you turn on a lightswitch, then wait one second and turn it off, then wait a half second a turn it on, then wait a quarter second then turn it off, etc.
11:35:54 <emu> is it divisible by two?!
11:36:04 <byorgey> at the end of two seconds is it on or off? =)
11:36:16 <emu> it is broken
11:36:19 <shapr> Asymptotically on?
11:36:22 <byorgey> emu: lol
11:36:27 <xerox> emu, turns out, if you try to extend the operations of the real numbers to the extended reals, that is, the reals plus infinity, you always end up with some contradiction.
11:36:40 <shapr> hi xerox!
11:36:46 <xerox> hello shapr (:
11:36:50 <shapr> How's code?
11:36:53 <emu> omega?
11:37:03 <xerox> shapr, it's not! Sadly.
11:37:15 * araujo throws at shapr a lambda
11:38:04 * shapr catches the lambda, adds sugar and throws it back!
11:38:07 <shapr> xerox: Only math these days?
11:38:09 * sorear reads 11:36  * araujo throws a shapr at lambda
11:38:11 * xerox nods
11:38:16 <SamB> so... what exactly does it mean if I am running a program with +RTS -xc -B and I see a CAF or stack, but the beeping stops?
11:38:27 <emu> shapr: have any diet lambda?
11:38:33 <xerox> I'm exactly in the middle of this exam period. Fun, but exhausting.
11:38:40 <araujo> haha
11:38:41 <SamB> s/stops/doesn't stop immediately/
11:38:43 <SamB> sorry
11:38:49 * araujo wonders if shapr could help him
11:39:00 <sorear> SamB: ? maybe the exception was caught?
11:39:01 <astrolabe> hey xerox :)
11:39:03 <shapr> araujo: I'm working right now, but if it's something small and simple?
11:39:35 <SamB> sorear: could be
11:39:44 <araujo> shapr, well , i was wondering if you still have this site where you give small hosting for projects
11:39:51 <xerox> 'lo 'labe (:
11:39:57 <araujo> shapr, scandinnavian or something like that?
11:40:02 <shapr> araujo: community.haskell.org should be working soon
11:40:18 <shapr> In fact, I'll send an email to the admins list and ask if the process is complete now.
11:40:20 <araujo> shapr, the thing is that it is non-haskell related ....
11:40:25 <DRMacIver> xerox: Well, you can throw in more infinities and get consistent operations. :)
11:40:39 <araujo> and i am looking for a darcs repo
11:40:40 <xerox> DRMacIver, what happens to the ordering?
11:40:49 <DRMacIver> (You just can't throw in an infinity which is 1/0)
11:40:49 <araujo> it has not been easy to find one :-(
11:40:55 <xerox> shapr, what's happening in Haskelland these days?
11:41:28 <DRMacIver> xerox: Depends how you arrange it. There's no problem with having multiple infinities, one bigger than the other.
11:41:40 <shapr> xerox: Lots of work, exciting code!
11:42:06 <xerox> DRMacIver, if I see what you mean, you're not extending the real numbers, right?
11:42:25 <jfoutz> any news about the practical haskell book? isn't dons working on that?
11:43:33 * xerox is reminded of Baez stuff.
11:45:01 * xerox disappears.
11:45:25 <Philippa> 'lo xerox
11:45:26 <Philippa> d'oh
11:45:29 <Philippa> yay timing...
11:45:32 <byorgey> poof!
11:45:51 <xerox> Philippa, hi (:
11:45:59 <Philippa> good to see you online again
11:48:43 <DRMacIver> xerox: You can be. The surreal or hyperreal numbers are examples of extensions to the reals which contain infinitely large numbers.
11:48:50 <DRMacIver> Oh, he disappeared. :)
11:50:08 <sieni> DRMacIver: but they all have gaps!
11:50:30 <DRMacIver> Well, sure. The reals are the unique complete ordered field. You can't escape that. :)
11:53:17 <byorgey> jfoutz: I haven't seen any news about it recently
11:54:09 <sorear> DRMacIver: Hmm.  What do you get when you apply the dedekind completion construction to a superset of the reals?
11:54:41 <a9913> umm... how do i pause a program for a specified number of seconds?
11:54:55 <DRMacIver> sorear: Hm. Good question. I think I knew the answer to it at one point, but I don't remember offhand.
11:54:56 <sorear> threadDelay
11:54:59 <DRMacIver> Let's think...
11:55:12 <xerox> I think you have no dense set to start with, as sieni is saying. Well, better dash off ~~
11:55:13 <a9913> sorear, thanks
11:55:30 <sorear> a9913: in Control.Concurrent btw
11:55:43 <a9913> thanks :)
11:55:50 * DRMacIver digs up the notes from the textbook he was writing.
11:55:53 <sorear> a9913: hysterical raisins, since they added it for threading support but it's independantly useful
11:56:50 <a9913> sorear, threading? er... i just want the current script to pause for a few seconds.... like you have "sleep 3" in shells which makes it wait for 3 seconds before continuing...
11:57:15 <sorear> a9913: yes, threadDelay will do that
11:57:16 <LoganCapaldo> a9913: sorear was just oversharing
11:57:22 <a9913> oph
11:57:24 <a9913> *oh
11:57:24 <sorear> a9913: I was just explaining the name :)
11:57:26 <a9913> thanks:)
11:57:47 * bgeron understands Monads, but chokes on monad transformers. Will try again later.
11:57:57 <sorear> a9913: also, the argument is microseconds, so threadDelay 3 won't do anything useful :)
11:58:06 <a9913> oh
11:58:34 <LoganCapaldo> @ty threadDelay
11:58:34 <a9913> thanks :)
11:58:36 <lambdabot> Not in scope: `threadDelay'
11:59:16 <LoganCapaldo> newtype USec = USec Int :)
12:01:32 <LoganCapaldo> oldtype Int = USec
12:04:55 <DRMacIver> sorear: I've not run through which part of the proof fails, but short version: It's still complete, but some of the field operations have to fail (even addition can't work). I think what ends up failing is that you don't have additive inverses.
12:05:30 <sorear> DRMacIver: Ouch.
12:06:06 <DRMacIver> Hm. In fact, yes. If you have some ordered field extension of R it has to contain an infinite number. So N is bounded above. Let x = sup N. Then we have x + 1 = sup (N + 1) = x.
12:06:21 <DRMacIver> So x can't have an additive inverse, as then we'd have 1 = 0.
12:09:07 <sorear> what's N?
12:09:31 <sorear> oh, naturals
12:09:56 <a9913> can anyone suggest a good book on haskell?
12:11:07 <Serge> "Programming in Haskell" is alright for the basics
12:11:13 <dreameye> hi, anyone could point me to the darcs version of hs.plugins please?
12:11:37 <Serge> http://www.amazon.com/Programming-Haskell-Graham-Hutton/dp/0521692695/ref=pd_bbs_sr_1/104-5755984-3335116?ie=UTF8&s=books&qid=1182452983&sr=8-1
12:11:41 <lambdabot> http://tinyurl.com/ynmsma
12:11:54 <sorear> @where hs-plugins
12:11:54 <lambdabot> http://www.cse.unsw.edu.au/~dons/hs-plugins/
12:12:04 <Serge> Doesn't go that deep, nice primer tho'
12:12:40 <a9913> Serge, thanks :)
12:12:59 <astrolabe> http://www.amazon.com/Haskell-School-Expression-Functional-Programming/dp/0521644089
12:13:03 <lambdabot> http://tinyurl.com/y352ho
12:14:08 <a9913> thanks :)
12:14:58 * LoganCapaldo is gonna wait for the new haskell book
12:19:10 <SamB> so... any idea why the RTS doesn't call fflush after writing a sample to a heap profile?
12:19:23 <SamB> (or even have an option to do that?)
12:20:18 * SamB wants -caf-reallyall
12:20:26 <SamB> er.
12:20:37 <SamB> -auto-reallyall
12:20:53 <SamB> but there ought to be a "caf" in the names of those options somewhere
12:22:15 <LoganCapaldo> Mmm a big mug of delcious caf
12:29:49 <hpaste>  SamB pasted "find the loop in this uniplate code and win a free DS!" at http://hpaste.org/352
12:30:01 <Japsu> DS? :P
12:30:09 * SamB was kidding
12:31:26 <SamB> I get this:
12:31:33 <SamB> *Main> expandRepeats (MDef "sens" ["A"] [Repeat [TermNum 0o000003] [SymbolicParameterAssignment "A" [TermSym "A",TermSym "A"]],StorageWord [TermSym "szs",TermSym "A"]])
12:31:33 <SamB> MDef "sens" ["A"]
12:32:38 <SamB> oh.
12:32:42 <SamB> I think I found it myself now...
12:32:58 <SamB> *Main> fromIntegral (0o000003 :: Pdp1Word) :: Int
12:33:01 <SamB>  
12:33:47 <SamB> arg. I think I omitted a single ' in toInteger...
12:34:15 <byorgey> SamB: heh, that would do it
12:34:17 <LoganCapaldo> is a DS Lite?
12:34:21 <LoganCapaldo> I already have a DS
12:34:45 <byorgey> SamB: a good argument against using such "primed" names, IMO...
12:35:08 <byorgey> although I do it myself on occasion =P
12:35:24 <SamB> I'm just thinking that GHC should have been able to make it into a <<Loop>>
12:35:41 <SamB> look at the first equation for toInteger
12:36:00 <SamB> er, well, the first guarded rhs
12:36:56 <a9913> umm... i'm getting an error using threadDelay: http://cpp.sourceforge.net/?show=37496 (that program was written by someone else.. modified a bit by me (whatever i could make out))... i tried to fix it... but couldn't...
12:36:57 <lambdabot> Title: #C++ Pastebin
12:37:41 * SamB hopes oleg gets to hacking on Uniplate
12:38:13 <SamB> (I want to see what he can do to prevent loss of sharing)
12:38:33 <byorgey> @type threadDelay
12:38:35 <lambdabot> Not in scope: `threadDelay'
12:39:05 <byorgey> @type liftIO
12:39:09 <lambdabot> forall a (m :: * -> *). (MonadIO m) => IO a -> m a
12:39:25 <byorgey> a9913: try liftIO $ threadDelay 3000
12:39:33 <a9913> thanks
12:40:41 <a9913> yay! worked! thanks, byorgey!
12:40:48 <byorgey> a9913: that will lift the call to threadDelay (which is in the IO monad) into the enclosing monad (ReaderT BotData IO t)
12:40:55 <byorgey> a9913: you're welcome =)
12:41:32 <byorgey> a9913: but if you're not that comfortable with monads/monad transformers then I'd say don't worry about it too much yet =)
12:41:44 <a9913> byorgey, me is still a noob
12:41:47 <a9913> in a big way
12:41:56 <a9913> first hour with haskell...
12:42:04 <a9913> just for that program...
12:42:15 <a9913> reading up some online references and tutorials
12:42:16 <byorgey> a9913: I see.  well, welcome!
12:42:25 <a9913> thanks again :)
13:10:33 <Figs> hello
13:10:48 <Figs> what does "Tree a -> Tree a -> Tree a
13:10:51 <Figs> mean?
13:11:05 <Igel> its a function
13:11:14 <basti_> the type of a function, respectively
13:11:16 <Igel> that takes two "Tree a"s
13:11:21 <Igel> and returns another one
13:12:23 <Figs> (tree a -> tree a) -> tree a   (Ignoring case, is this the same?)
13:12:31 <nominolo> no
13:12:46 <nominolo> Tree a -> (Tree a -> Tree a) is the same
13:13:36 <LoganCapaldo> an important difference to keep in mind :)
13:14:09 <LoganCapaldo> @type fix
13:14:12 <lambdabot> forall a. (a -> a) -> a
13:14:16 <LoganCapaldo> @type const
13:14:18 <lambdabot> forall a b. a -> b -> a
13:14:27 <LoganCapaldo> @type asTypeOf -- I meant this one
13:14:30 <lambdabot> forall a. a -> a -> a
13:15:20 <Igel> Figs: (a -> a) -> a is a function with another function (a -> a) as an argument
13:15:51 <Figs> ok
13:16:15 <Figs> so, would it effectively be a function that returns a function?
13:16:26 <basti_> yep
13:16:28 <Figs> ok
13:16:33 <basti_> a currified multiparameter function
13:16:34 <nominolo> Figs: not the latter
13:16:44 <nominolo> the first one, yes
13:17:14 <Figs> then tree a -> (tree a -> tree a) is>
13:17:15 <Figs> *?
13:17:29 * SamB wishes it were possible to make a link that would point to http://hackage.haskell.org/trac/ghc/query?group=priority&reporter=SamB&order=id&desc=1 for him, and the equivalent for other users...
13:17:31 <lambdabot> Title: Custom Query - GHC - Trac, http://tinyurl.com/2o7fl5
13:18:02 <nominolo> :t \a -> \b -> a + b + 1 :: Int
13:18:05 <lambdabot> Int :: Int -> Int -> Int
13:18:25 <nominolo> :t \a b -> (a + b + 1 :: Int)
13:18:27 <lambdabot> Int -> Int -> Int
13:18:39 <nominolo> but:
13:18:50 <nominolo> :t \f -> (f 0 + 1 :: Int)
13:18:53 <lambdabot> forall t. (Num t) => (t -> Int) -> Int
13:19:06 <nominolo> :t \f -> (f (0 :: Int) + 1 :: Int)
13:19:11 <lambdabot> (Int -> Int) -> Int
13:19:48 <nominolo> Figs: you see want i'm trying to say? ;)
13:19:59 <Figs> not really
13:20:16 <Figs> => does what?
13:20:21 <basti_> i don't either.
13:20:24 <nominolo> Figs: ignore that
13:21:14 <nominolo>  a -> a -> a    can be seen in two way:
13:21:31 <nominolo> 1.  a function taking two arguments
13:22:03 <nominolo> 2. a function, that given only one argument returns a function of one argument
13:22:40 <nominolo> thus:  a -> a -> a   ===   a -> (a -> a)
13:22:57 <nominolo> whereas (a -> a) -> a
13:23:21 <Figs> I think I get it...
13:23:22 <nominolo> takes a function as an acgument but returns just a single "a"
13:23:26 <Figs> if I have f
13:23:33 <Figs> then f a b
13:23:40 <Figs> does the first fit for f a
13:24:00 <Figs> ie, you get (a -> a) b
13:24:04 <Figs> a->a as a function
13:24:09 <nominolo> yep
13:24:10 <Figs> (not sure what the syntax is)
13:25:22 <nominolo> yep, so the typechecker only needs to know about one-argument functions
13:25:43 <Figs> wacky.
13:25:52 <nominolo> but useful
13:25:57 <Figs> yeah
13:27:08 <nominolo> as an exercise try to figure out what type  (sum . map length)  has (and why)
13:27:38 <nominolo> :t (.)
13:27:46 <sorear> :t sum
13:27:46 <lambdabot> forall b c a. (b -> c) -> (a -> b) -> a -> c
13:27:48 <lambdabot> forall a. (Num a) => [a] -> a
13:27:48 <sorear> :t map
13:27:50 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
13:27:52 <sorear> :t length
13:27:54 <lambdabot> forall a. [a] -> Int
13:28:08 <nominolo> @src (.)
13:28:08 <lambdabot> (.) f g x = f (g x)
13:29:12 <Figs> http://rafb.net/p/tTULeV21.html <-- what's wrong with this, it says invalid type signature?
13:29:13 <lambdabot> Title: Nopaste - The tree example
13:30:13 <nominolo> Figs: remove lines 3 and 4
13:30:25 <nominolo> they're not needed
13:30:33 <Figs> they were in the example though...
13:30:40 <quicksilver> although they are, in fact, correct
13:30:41 <nominolo> (you can leave them as a comment
13:30:51 <quicksilver> but haskell doesn't expect you to give type sigs to constructors
13:31:06 <Figs> how to comment?
13:31:18 <nominolo> put "-- " in front
13:31:21 <Figs> ok
13:32:12 <nominolo> (multi-line comments look like "{- ... -}"
13:32:24 <dukedave> > 3 + {- testy -} 3
13:32:26 <lambdabot>  6
13:38:49 <Figs> is there a less cumbersome way to do:
13:38:49 <Figs> n = Branch (Branch (Leaf 1)(Leaf 2)) (Branch (Leaf 3)(Leaf 4))
13:38:50 <Figs> ?
13:39:50 <byorgey> Figs: not explicitly, no
13:39:54 <sorear> n = (L 1 :^: L 2) :^: (L 3 :^: L 4)
13:40:09 <byorgey> Figs: although you could e.g. write a special function to turn a list into a tree, or something like that
13:40:12 <sorear> this of course requires renaming your ctors
13:43:51 <nominolo> sorear: or l = Leaf;  b = Branch
13:44:22 <nominolo> er rather  (<+>) = Branch
13:45:39 <nominolo> > let l x = Just x; (<>) = (,) in (l 1 <> l 2) <> l 3
13:45:43 <lambdabot>  ((Just 1,Just 2),Just 3)
13:45:55 <nominolo> neato
13:46:51 <ed1t> > let f x = x * x
13:46:51 <lambdabot>  Parse error
13:46:58 <ed1t> > let blah x = x * x
13:46:59 <lambdabot>  Parse error
13:47:04 <ed1t> wats wron
13:47:06 <byorgey> Figs: you understand what sorear and nominolo are suggesting?
13:47:06 <LoganCapaldo> ed1t: you need the in
13:47:11 <nominolo> > let f x = x * x in f 3
13:47:13 <lambdabot>  9
13:47:17 <LoganCapaldo> > let blah x = x * x in blah 3
13:47:19 <lambdabot>  9
13:47:26 <ed1t> ahhh
13:47:30 <nominolo> why 3?
13:47:47 <nominolo> @ LoganCapaldo
13:47:49 <LoganCapaldo> why not?
13:47:58 <nominolo> because I picked it too!
13:48:00 <LoganCapaldo> lol
13:48:03 <nominolo> ;)
13:48:08 <byorgey> everyone knows that 3 is more random than other small numbers.
13:48:53 <nominolo> > let f x = x * x in f
13:48:55 <lambdabot>  <Integer -> Integer>
13:49:07 <nominolo> :t let f x = x * x in f
13:49:08 <yrlnry> byorgey: more so than 7?
13:49:09 <lambdabot> forall a. (Num a) => a -> a
13:49:24 <byorgey> yrlnry: hmm, 7 is pretty random too
13:49:24 <bos> @users
13:49:24 <lambdabot> Maximum users seen in #haskell: 334, currently: 321 (96.1%), active: 17 (5.3%)
13:49:35 <nominolo> of course the best is
13:49:40 <nominolo> > 3 * 7 * 2
13:49:42 <lambdabot>  42
13:49:45 <nominolo> !
13:49:53 <byorgey> heh
13:50:07 <nominolo> or
13:50:11 <nominolo> > 3 * 7 + 2
13:50:13 <lambdabot>  23
13:50:36 <byorgey> > 3 + 7 * 2 -- also pretty random
13:50:39 <lambdabot>  17
13:50:44 <nominolo> nah
13:50:53 <nominolo> @wiki 23
13:50:53 <lambdabot> http://www.haskell.org/haskellwiki/23
13:50:59 <yrlnry> 91 is the smallest number that looks prime but isn't.
13:51:08 <jfoutz> no. 51
13:51:12 <byorgey> yrlnry: yup!
13:51:20 <yrlnry> 51.  Okay.
13:51:25 <byorgey> jfoutz: 51 obviously isn't prime since 5+1 = 6
13:51:25 <nominolo> >17 * 3
13:51:30 <nominolo> > 17 * 3
13:51:31 <jfoutz> hehe
13:51:33 <lambdabot>  51
13:51:37 <LoganCapaldo> Since when has 51 looked prime?
13:51:38 <yrlnry> I would have said that 51 did not look prime, but I can see the argument.
13:51:48 <nominolo> it's odd!
13:51:56 <yrlnry> It's obvopisly divisible by 3.
13:52:07 <yrlnry> Wow, that was some typo.
13:52:20 <LoganCapaldo> by that logic 9 is the smallest number that looks prime but isn't :)
13:52:23 <nominolo> dvorak?
13:52:35 <LoganCapaldo> pi is prime!
13:52:55 <vincenz> LoganCapaldo: since when is pi in |N
13:53:04 <byorgey> > let isPrime p = True in isPrime pi
13:53:05 <lambdabot>  True
13:53:10 <byorgey> you're right!
13:53:17 <byorgey> amazing
13:53:19 <sorear> vincenz: Ahem?  Pi is 3!
13:53:31 <nominolo> > let pi = 3 in pi
13:53:33 <lambdabot>  3
13:53:37 <vincenz> sorear: illegal typecast, go back to C and try again
13:53:51 <nominolo> > pi
13:53:53 <lambdabot>  3.141592653589793
13:54:11 <LoganCapaldo> @type pi
13:54:14 <lambdabot> forall a. (Floating a) => a
13:54:16 <sorear>  > pi  really ought to end with ...
13:54:37 <sorear> lazily and all that
13:54:37 <LoganCapaldo> and @type pi should be (Irrational a) => a
13:54:39 * vincenz thinks there should be an instance of Floating specifically for Pi
13:54:40 <nominolo> > pi...
13:54:40 <lambdabot>  Parse error
13:54:48 <vincenz> instance FLoating Pi where
13:55:02 <LoganCapaldo> vincenz: what about e?
13:55:13 <vincenz> LoganCapaldo: obviously that's in instance FLoating E
13:55:19 <LoganCapaldo> aha
13:55:26 <nominolo> :t e
13:55:28 <lambdabot> Not in scope: `e'
13:55:36 <LoganCapaldo> we don't even have an e?
13:55:37 <nominolo> > log 1
13:55:38 <lambdabot>  0.0
13:55:40 <mehrheit> @type exp 1
13:55:42 <lambdabot> forall t. (Floating t) => t
13:55:44 <nominolo> > log 2
13:55:46 <lambdabot>  0.6931471805599453
13:55:47 <vincenz> > exp 1
13:55:49 <lambdabot>  2.718281828459045
13:55:53 <nominolo> > 1 / log 2
13:55:55 <lambdabot>  1.4426950408889634
13:55:57 <vincenz> > pi 1
13:55:58 <lambdabot>   add an instance declaration for (Floating (t -> a))
13:55:58 <lambdabot>     In the expression: ...
13:56:01 <LoganCapaldo> @let e = exp 1
13:56:03 <lambdabot> Defined.
13:56:05 <vincenz> > e
13:56:07 <lambdabot>  2.718281828459045
13:56:07 <LoganCapaldo> > e
13:56:08 <lambdabot>  2.718281828459045
13:56:14 <vincenz> @let pi = "
13:56:14 <lambdabot>  Improperly terminated string
13:56:16 <vincenz> @let pi = 3
13:56:18 <vincenz> > pi
13:56:18 <lambdabot> Defined.
13:56:19 <lambdabot> Terminated
13:56:22 <vincenz> > pi
13:56:23 <lambdabot> Terminated
13:56:26 <vincenz> o.O
13:56:29 <LoganCapaldo> lol
13:56:31 <nominolo> > pi * e
13:56:31 <vincenz> @unlet pi
13:56:31 <lambdabot>  Parse error
13:56:32 <lambdabot> Terminated
13:56:36 <vincenz> @forget pi
13:56:36 <lambdabot> Unknown command, try @list
13:56:39 <vincenz> @help let
13:56:39 <lambdabot> let <x> = <e>. Add a binding
13:56:40 <LoganCapaldo> lambdabot refuses to listen to your nonsense <g>
13:56:47 <vincenz> > e
13:56:49 <lambdabot>  2.718281828459045
13:56:51 <edwardk> hah
13:56:54 <vincenz> how do yo unlet
13:56:55 <Excedrin> vincenz: if you use BigFloat.hs, pi never terminates
13:57:04 <nominolo> @help unlet
13:57:04 <lambdabot> help <command>. Ask for help for <command>. Try 'list' for all commands
13:57:06 <byorgey> > floor pi
13:57:07 <lambdabot> Terminated
13:57:09 <vincenz> @list
13:57:09 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
13:57:19 <LoganCapaldo> > pi / pi
13:57:20 <lambdabot> Terminated
13:57:25 <LoganCapaldo> @type pi
13:57:29 <lambdabot> forall a. (Floating a) => a
13:57:33 <byorgey> > 3
13:57:34 <lambdabot>  3
13:57:37 <LoganCapaldo> @type e
13:57:37 <vincenz> @undefine pi
13:57:37 <byorgey> oh good
13:57:38 <nominolo> > derive e^x
13:57:39 <lambdabot> Not in scope: `e'
13:57:40 <lambdabot>   Not in scope: `derive'
13:57:40 <lambdabot> Undefined.
13:57:41 <vincenz> > pi
13:57:42 <lambdabot>  3.141592653589793
13:57:53 <mehrheit> does lambdabot have BigFloat.hs?
13:58:00 <vincenz> @let pi = 3.14
13:58:01 <lambdabot> Defined.
13:58:02 <vincenz> > pi
13:58:03 <lambdabot> Terminated
13:58:06 <nominolo> :t (<+>)
13:58:06 <vincenz> @undefine pi
13:58:07 <lambdabot> Undefined.
13:58:08 <lambdabot>     Ambiguous occurrence `<+>'
13:58:08 <lambdabot>     It could refer to either `<+>', imported from Control.Arrow
13:58:17 <vincenz> Or?
13:58:18 <edwardk> i think its because of the conflict with the imported one, you get the ambiguous reference
13:58:38 <LoganCapaldo> :t Control.Arrow.(<+>)
13:58:38 <byorgey> @let pi = 3.14
13:58:40 <lambdabot> Couldn't find qualified module.
13:58:40 <lambdabot> Defined.
13:58:43 <byorgey> > L.pi
13:58:44 <lambdabot>  3.14
13:58:46 <vincenz> @undefine pi
13:58:46 <edwardk> > Prelude.pi
13:58:49 <lambdabot> Undefined.
13:58:50 <lambdabot>  3.141592653589793
13:58:53 <LoganCapaldo> > L.e
13:58:54 <lambdabot>   Not in scope: `L.e'
13:58:57 <LoganCapaldo> > e
13:58:58 <lambdabot>   Not in scope: `e'
13:59:00 <vincenz> @let e = e
13:59:01 <lambdabot> Defined.
13:59:05 <LoganCapaldo> did we erase e?
13:59:06 <vincenz> > "
13:59:06 <lambdabot>  Improperly terminated string
13:59:08 <vincenz> > e
13:59:09 <lambdabot>  Exception: <<loop>>
13:59:11 <byorgey> > exp 1
13:59:12 <lambdabot>  2.718281828459045
13:59:21 <shachaf> Using @undefine resets the entire file.
13:59:24 <byorgey> LoganCapaldo: there's not a constant function for e like there is for pi
13:59:30 <LoganCapaldo> byorgey: I know :)
13:59:37 <LoganCapaldo> scroll up, I made it :)
13:59:44 <LoganCapaldo> of course now its undefined
13:59:49 <edwardk> @undefine
13:59:50 <lambdabot> Undefined.
13:59:51 <edwardk> @let e = exp 1
13:59:52 <lambdabot> Defined.
13:59:55 <vincenz> > e
13:59:56 <lambdabot>  2.718281828459045
13:59:58 <byorgey> oh, I see, I didn't realize it had been defined before
14:00:11 <vincenz> > e `toThe` i *pi
14:00:12 <lambdabot>   Not in scope: `i'
14:00:26 <vincenz> > e `toThe` i `times` pi
14:00:27 <lambdabot>   Not in scope: `times'
14:00:53 <mehrheit> > e :+ pi
14:00:54 <lambdabot>  2.718281828459045 :+ 3.141592653589793
14:01:02 <LoganCapaldo> > e ** ((0 :+ 1) * (pi :+ 0))
14:01:03 <lambdabot>  Couldn't match expected type `Double'
14:01:17 <nominolo> @let toThe x y | x == e && y == i = (-1); otherwise undefined
14:01:18 <lambdabot>  Parse error
14:01:20 <LoganCapaldo> can we not ** complexes?
14:01:24 <nominolo> @let toThe x y | x == e && y == i = (-1); otherwise = undefined
14:01:25 <lambdabot> <local>:2:27: Not in scope: `i'
14:01:38 <edwardk> @let i = (0 :+ 1)
14:01:39 <lambdabot> Defined.
14:01:43 <nominolo> @let toThe x y | x == e && y == i = (-1); otherwise = undefined
14:01:44 <lambdabot> Defined.
14:01:51 <edwardk> > exp (i * pi) + 1
14:01:52 <lambdabot>  0.0 :+ 1.2246063538223773e-16
14:02:05 <LoganCapaldo> > exp (0 :+ pi)
14:02:06 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
14:02:20 <byorgey> hurrah!
14:02:27 <nominolo> :t (0 :+ 1)
14:02:29 <lambdabot> forall t. (RealFloat t) => Complex t
14:02:39 <nominolo> intersting
14:02:41 <vincenz> a higher order number
14:02:41 <byorgey> > exp pi - pi
14:02:43 <lambdabot>  19.999099979189474
14:02:56 <vincenz> wrong, that should be 20!!!
14:03:00 <nominolo> rounding error!!!
14:03:01 <LoganCapaldo> hehehe
14:03:06 <byorgey> oh no, a bug in GHC!
14:03:08 <emu> floats suck
14:03:19 <emu> i want real Reals!
14:03:34 <vincenz> "who wants real Reals.... I want real Reals"
14:03:38 <nominolo> emu: it would still not be 20 then ;)
14:03:40 <vincenz> reminds me of this song... but don't know which
14:03:54 <vincenz> nominolo: it must be a bug in the type-system or the garbage collector
14:03:58 <vincenz> for sure
14:04:06 <nominolo> yes
14:04:16 <nominolo> or in the rule engine
14:04:17 <LoganCapaldo> keeping :: (Real it) => it
14:04:27 <nominolo> no, in teh semantcs
14:04:27 <byorgey> lol
14:04:30 <vincenz> LoganCapaldo: never seen the xkcd comic?
14:04:37 <vincenz> nominolo: what semantics?
14:04:39 <LoganCapaldo> I've seen it
14:04:46 <LoganCapaldo> hence the "hehehe"
14:04:48 <nominolo> vincenz: exactly!
14:05:00 <byorgey> vincenz: who in this channel hasn't, I wonder? =)
14:05:15 <vincenz> byorgey: I have my finger on the kick button
14:05:19 <vincenz> just in case
14:05:21 <vincenz> :)
14:05:25 --- mode: ChanServ set +o vincenz
14:05:31 --- mode: vincenz set -o vincenz
14:05:38 <nominolo> you have a kick button?
14:05:46 <nominolo> is it big and red?
14:05:47 <vincenz> for non-xkcders?
14:05:53 <vincenz> nominolo: it covers half my screen
14:06:00 * byorgey assures any lurkers who haven't read xkcd that they are still welcome here, but they should go read it.  now.
14:06:04 <vincenz> "punch here"
14:06:10 <LoganCapaldo> http://xkcd.com/c278.html the funniest part about this comic is that there really is (or was) a keyword: Linux
14:06:11 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:06:25 <vincenz> byorgey: I could feel the blood dripping from your clenched fists
14:07:23 <LoganCapaldo> vincenz: where were you standing exactly that you could feel that? :)
14:07:39 <vincenz> close to my kick button
14:07:45 <mehrheit> should exp pi - pi actually be 20? (I didn't quite understand that comic)
14:07:53 <vincenz> mehrheit: no, that's impossible
14:08:56 <LoganCapaldo> http://www.google.com/search?hl=en&safe=off&client=safari&rls=en&q=e+to+the+pi+minus+pi&btnG=Search
14:08:57 <lambdabot> Title: e to the pi minus pi - Google Search, http://tinyurl.com/27fkn7
14:09:11 <Figs> bye
14:09:19 <vincenz> @google e^pi - pi
14:09:20 <lambdabot> (e^pi) - pi = 19.9991
14:09:27 <LoganCapaldo> nice
14:09:29 <nominolo> http://xkcd.com/c179.html
14:09:30 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:09:40 <LoganCapaldo> @google 2 + 2
14:09:41 <lambdabot> 2 + 2 = 4
14:09:52 <LoganCapaldo> we can check lambdabots math against google :)
14:09:55 <nominolo> wrong
14:10:08 <nominolo> @go radiohead "2 + 2"
14:10:09 <vincenz> anyways, what is the reason e^pi-pi can't be rational
14:10:23 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
14:10:29 <ddarius> vincenz: Incidentally, @undefine does not remove a binding, it removes -all- of them.
14:10:31 <byorgey> vincenz: it could be, AFAIK
14:10:36 <nominolo> @google radiohead "2 + 2"
14:10:40 * LoganCapaldo twirls mustache nefariously
14:10:44 <byorgey> vincenz: although most likely not
14:10:51 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
14:11:14 <mehrheit> @index :+
14:11:15 <lambdabot> Data.Complex
14:11:25 <vincenz> http://xkcd.com/c217.html
14:11:26 <lambdabot> Title: xkcd - A webcomic of romance, sarcasm, math, and language - By Randall Munroe
14:11:40 <vincenz> I love the comment on it
14:12:19 <vincenz> "Also, I hear  the 4th root of (9^2 +19^2/22) is pi
14:12:25 <vincenz> "
14:12:40 <mauke> > sqrt $ sqrt $ (9^2 + 19^2/22)
14:12:43 <monochrom> hehehe
14:12:47 <nominolo> > sqrt (sqrt (9**2 + (19**2)/22))
14:12:48 <lambdabot>  3.1415926525826463
14:12:51 <lambdabot>  3.1415926525826463
14:12:55 <nominolo> > sqrt (sqrt (9**2 + (19**2)/22)) - pi
14:12:57 <lambdabot>  -1.0071469908057296e-9
14:13:03 <vincenz> LoganCapaldo: anyways he says "before they figured it out", I Think there must be a fundamental raeson about making rationals from irrationals
14:13:43 <ddarius> Try the Taylor series expansion of e^pi
14:13:54 <byorgey> ah, apparently exp pi is proven to be transcendental
14:13:59 <edwardk> yeah
14:14:03 <byorgey> but that still doesn't mean exp pi - pi can't be rational
14:14:46 <mehrheit> > (exp $ 1 :+ 0)**((pi :+ 0) * (sqrt $ (-1) :+ 0))
14:14:49 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
14:15:55 <LoganCapaldo> > exp ( 0 :+ pi ) -- mehrheit stop trying so hard :)
14:15:56 <dukedave> Aw, if someone mentioned xkcd, I can't not post my other favourite daily: geekologie.com
14:15:58 <lambdabot>  (-1.0) :+ 1.2246063538223773e-16
14:16:48 <nominolo> > (sqrt $ (-1) :+ 0))
14:16:48 <lambdabot>  Parse error
14:16:53 <nominolo> > (sqrt $ (-1) :+ 0)
14:16:54 <lambdabot>  0.0 :+ 1.0
14:16:58 <vincenz> anyone see the soap mouse?
14:17:12 <nominolo> the what?
14:17:29 <vincenz> soap mouse, at first I thought it was humor, but it's serious and home buildable
14:17:48 <vincenz> http://www.youtube.com/watch?v=hohu8SSpduM
14:18:42 <LoganCapaldo> does it keep your hands clean while you mouse?
14:18:45 <vincenz> no
14:18:50 <vincenz> it operates like a bar of soap
14:19:00 <vincenz> as in you can roll it in your hand like you can with a wet bar of soap
14:19:15 <vincenz> seems pretty usabl from their demos
14:20:38 <byorgey> bizarre
14:22:34 <LoganCapaldo> pretty cool
14:25:08 * LoganCapaldo feels tempted to construct one
14:26:52 <SamB> so... has everyone seen Data.DList?
14:26:58 <LoganCapaldo> no
14:27:04 <LoganCapaldo> Is it funny?
14:27:08 <SamB> no!
14:27:14 <LoganCapaldo> @doc Data.DList
14:27:14 <lambdabot> Data.DList not available
14:27:15 <SamB> it is tiny but useful
14:27:20 <SamB> @where dlist
14:27:20 <lambdabot> http://www.cse.unsw.edu.au/~dons/dlist.html
14:27:36 <LoganCapaldo> oooooo
14:27:52 <byorgey> nice
14:28:06 <LoganCapaldo> Oh is it similar to ShowS ?
14:28:15 <mauke> is it awesomer than Data.Sequence?
14:28:23 <SamB> indeed, it is basically a newtyped generalization of ShowS
14:28:24 * monochrom contemplates an elaborate experiment of working an entire project out of haskell-cafe.
14:28:31 <SamB> mauke: it is differetnly awesome
14:29:13 <SamB> (the newtype is new in version 0.2)
14:29:18 <mauke> oh, yes. that's an old trick :-)
14:29:28 <SamB> and apparantly dons has forgotten to regenerate the documentation for 0.2
14:29:50 <LoganCapaldo> I guess you lose pattern matching fun though
14:29:56 <SamB> DList a is also a Monoid
14:30:03 <LoganCapaldo> oh not really
14:30:11 <LoganCapaldo> since toList can be lazy
14:30:15 <LoganCapaldo> awesome
14:30:29 <mauke> it should be called ListBuilder or something like that
14:30:30 <LoganCapaldo> I've always thought ShowS was neato
14:31:02 <SamB> mauke: hmm.
14:31:24 <SamB> anyway, it replaces the old Monoid (a -> a) instance
14:32:34 <SamB> in terms of getting lists out of MonadWriter instances
14:33:41 <sorear> SamB: is it cooler than Endo?
14:35:27 <SamB> sorear: I think it's nicer when you just want a list out, yes
14:36:12 <SamB> and I'm still miffed about the old Monoid (a -> a) instance being replaced immediately after removal
14:36:31 <SamB> thus breaking people's code in a non-obvious way
14:36:55 <LoganCapaldo> > let singleton s = (s:); fromList l = (l ++); append l1 l2 = l1 . l2 ; snoc l a = l . singleton a; toList l = l; empty = flip const; in toList $ foldr snoc empty [1,2,3]
14:36:56 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> c
14:36:56 <lambdabot>     Proba...
14:37:34 <SamB> @ask dons why dlist 0.2 isn't released yet
14:37:34 <lambdabot> Consider it noted.
14:38:08 <xs> hi. http://www.haskell.org/ghc/docs/latest/html/libraries/base/Control-Concurrent.html#11 seems incorrect. a yield is required between forking children and waitForChildren at least (though i'm not sure that even this guarantees it will work)?
14:38:10 <lambdabot> http://tinyurl.com/y2q5k2
14:38:33 <LoganCapaldo> > let singleton s = (s:); fromList l = (l ++); append l1 l2 = l1 . l2 ; snoc l a = l . singleton a; toList l = l; empty = flip const id; in toList $ foldr snoc empty [1,2,3]
14:38:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> c
14:38:34 <lambdabot>     Proba...
14:38:55 <xs> (since the children MVar is initially []..)
14:39:01 <dolio> empty = id, no?
14:39:14 <LoganCapaldo> dolio: when your right your right
14:39:23 <LoganCapaldo> > let singleton s = (s:); fromList l = (l ++); append l1 l2 = l1 . l2 ; snoc l a = l . singleton a; toList l = l; empty = id; in toList $ foldr snoc empty [1,2,3]
14:39:24 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> c
14:39:24 <lambdabot>     Proba...
14:39:32 <LoganCapaldo> that's not the problem apparently :)
14:40:11 <dolio> foldr (flip snoc) empty ... ?
14:40:27 <LoganCapaldo> > let singleton s = (s:); fromList l = (l ++); append l1 l2 = l1 . l2 ; snoc l a = l . singleton a; toList l = l []; empty = id; in toList $ foldr snoc empty [1,2,3]
14:40:28 <lambdabot>      Occurs check: cannot construct the infinite type: a = [a] -> c
14:40:28 <lambdabot>     Proba...
14:40:41 <LoganCapaldo> > let singleton s = (s:); fromList l = (l ++); append l1 l2 = l1 . l2 ; snoc l a = l . singleton a; toList l = l []; empty = id; in toList $ foldr (flip snoc) empty [1,2,3]
14:40:43 <lambdabot>  [3,2,1]
14:40:46 <LoganCapaldo> huzzah
14:42:06 <vincenz> LoganCapaldo: I felt tempted too :)
14:42:40 <LoganCapaldo> vincenz: tempted to write it here?
14:42:47 <vincenz> no, building one
14:50:17 <vincenz> @localtime dons
14:50:18 <lambdabot> Local time for dons is Fri Jun 22 07:49:16 2007
14:50:30 <vincenz> odd hour
14:50:31 <Botje> tssk.
14:52:07 <sorear> vincenz: it's an odd hour for about half of the people on earth...
14:52:17 <vincenz> sorear: no I meant for australia
14:52:44 <ddarius> Sounds about right for Australia
14:56:03 <LoganCapaldo> OMG
14:56:10 <LoganCapaldo> Australia is in the future!
14:56:39 * SamB laughs at sorear's joke
14:56:42 <glguy> the movie Back to the Future makes more sense now
14:56:44 <LoganCapaldo> Quick, someone call my stock broken!
14:56:55 <LoganCapaldo> s/broken/broker/
14:57:15 <SamB> LoganCapaldo: your stock is broken
14:57:16 <glguy> LoganCapaldo: so is your grammar?
14:57:18 <glguy> ;)
14:57:24 <LoganCapaldo> clearly
14:59:33 <Igloo> Now you've got me wondering how well split people are between even and odd timezones...
15:01:12 <vincenz> Igloo: some are wider than others
15:01:31 <vincenz> not to mention those uneven number of timezones over the atlantic
15:01:33 <Igloo> vincenz: People or timezones?  :-)
15:01:35 <monochrom> All China is one time zone. :)
15:01:41 <vincenz> monochrom: even or odd?
15:01:51 <sorear> Vast numbers of people are not split at all!
15:01:53 <monochrom> Just turned even now :)
15:01:57 <vincenz> Igloo: depends on the zone you're in
15:02:15 <sorear> monochrom: hmm - India?
15:02:17 <vincenz> monochrom: you mean with summer time savings?
15:02:19 <vincenz> ooh
15:02:21 <vincenz> makes me wonder
15:02:31 <vincenz> how many people switch even/oddness when daylight savings goes in
15:02:38 <vincenz> I know europe switches to even
15:02:45 <glguy> it kind of depends on the hour
15:02:46 <vincenz> gmt+2
15:02:52 <sorear> vincenz: I switch even/oddness 24 times in a typical day!
15:03:01 <glguy> people switch even and odd hours in about 60 intervals
15:03:04 <vincenz> sorear: I meant as offset
15:03:08 <monochrom> Oh! I misunderstood the question.
15:03:10 <vincenz> glguy: 60 second?
15:03:15 <glguy> 60 minute
15:03:20 <glguy> :-p
15:03:33 * vincenz wonders how one can travel in 60 intervals
15:03:46 <sorear> @tell ndm No.
15:03:46 <lambdabot> Consider it noted.
15:03:53 <Botje> about twenty light.
15:04:11 * olsner is almost always odd
15:04:12 <vincenz> Botje: light american or light amstel?
15:04:34 <glguy> skinned
15:04:44 <vincenz> that's gory
15:04:53 <sorear> @tell ndm Because I (a) haven't gotten that far (b) need to support arcane features like type checking which want to annotate the AST (c) want to support GHC and non-GHC extensions
15:04:53 <lambdabot> Consider it noted.
15:06:32 <sorear> @ask ndm In supero - how about using pure Reynolds for the first stage.  The second stage should be able to clean up the mess just fine, and it would avoid the complexities of making code completely first order by the Mitchell algorithm.
15:06:32 <lambdabot> Consider it noted.
15:07:37 <SamB> sorear: so have you started working on your phd yet?
15:07:51 <sorear> SamB: no :)
15:37:16 <Mayreel> How do I make (-1) mean (\x -> x - 1) and not negative one?
15:37:30 <Syzygy-> Mayreel: (subtract 1
15:37:31 <Syzygy-> )
15:37:36 <Mayreel> thanks
15:39:06 <LoganCapaldo> @type ((-) 1)
15:39:09 <lambdabot> forall t. (Num t) => t -> t
15:39:17 <LoganCapaldo> alternatively
15:39:31 <LoganCapaldo> err
15:39:34 <olsner> > (-) 1 2
15:39:35 <LoganCapaldo> nope I'm wrong
15:39:38 <lambdabot>  -1
15:39:43 <LoganCapaldo> @type (flip (-) 1)
15:39:45 <lambdabot> forall a. (Num a) => a -> a
15:39:48 <olsner> > (- 1) 2
15:39:49 <lambdabot>   add an instance declaration for (Num (t -> a))
15:39:49 <lambdabot>     In the expression: (- 1)...
15:40:30 <olsner> @pl (\x -> x - 1)
15:40:30 <lambdabot> subtract 1
15:40:54 <LoganCapaldo> @unpl flip (-) 1
15:40:55 <lambdabot> (\ c -> c - 1)
15:41:14 <oerjan> :t (+ -1)
15:41:17 <lambdabot>     The operator `+' [infixl 6] of a section
15:41:17 <lambdabot>         must have lower precedence than the operand prefix `-' [infixl 6]
15:41:23 <oerjan> bah
15:41:28 <LoganCapaldo> :t (+ negate 1)
15:41:30 <lambdabot> forall a. (Num a) => a -> a
15:41:40 <olsner> :t negate
15:41:42 <lambdabot> forall a. (Num a) => a -> a
15:42:02 <LoganCapaldo> > (+ negate 1) 3
15:42:04 <lambdabot>  2
15:42:16 <Serge> > (-) 7 3
15:42:18 <lambdabot>  4
15:42:23 <olsner> how can (+ (... :: a -> a) 1) work?
15:42:33 <LoganCapaldo> it doesn't
15:42:49 <olsner> > (+ negate 1) 2
15:42:52 <lambdabot>  1
15:42:56 <LoganCapaldo> its (+ ( ... :: a))
15:43:13 <LoganCapaldo> > (+ (negate 1))
15:43:16 <lambdabot>  <Integer -> Integer>
15:43:22 <LoganCapaldo> @type (+ (negate 1))
15:43:24 <lambdabot> forall a. (Num a) => a -> a
15:43:29 <LoganCapaldo> @type (+ negate 1)
15:43:31 <lambdabot> forall a. (Num a) => a -> a
15:43:37 <LoganCapaldo> @type (+ (negate) 1)
15:43:40 <lambdabot> forall a. (Num a) => a -> a
15:43:40 <oerjan> :t (+(-1))
15:43:42 <lambdabot> forall a. (Num a) => a -> a
15:43:56 <LoganCapaldo> @type ((+ (negate)) 1)
15:43:58 <lambdabot> forall a. (Num a, Num (a -> a)) => a -> a
15:44:23 <olsner> aah, so it's the infix operator +, not the function + that's used, like in (x + f y)
15:44:43 <dreameye> hi people. I want  hs.plugins from http://cgi.cse.unsw.edu.au/~pls/cgi-bin/darcs.cgi/hs-plugins/?c=browse, but  Im an ingnorant of darcs and I can not get it using "darcs get <dir>"
15:44:44 <lambdabot> Title: darcs repository, http://tinyurl.com/2ddpqr
15:45:15 <dreameye> could someone help me?
15:45:34 <dreameye> sorry, Im an idiot
15:46:03 <Binkley> what happens if you do a darcs get?
15:46:24 <dreameye> I get a empty package (with a _darcs directory in)
15:46:44 <jaapweel> what exact command line do you use?
15:46:54 <dreameye> darcs get http://cgi.cse.unsw.edu.au/~pls/cgi-bin/darcs.cgi/hs-plugins/?c=browse
15:46:54 <mauke> docs point to darcs get --set-scripts-executable http://www.cse.unsw.edu.au/~dons/code/hs-plugins
15:46:55 <lambdabot> Title: Index of /~dons/code/hs-plugins
15:46:55 <lambdabot> Title: darcs repository, http://tinyurl.com/2ddpqr
15:47:23 <jaapweel> if you leave off the ?c=browse, does it help?
15:47:25 <Mayreel> Your shell could be interpreting the URL... try putting it in quotes
15:47:31 <heanol> can i define a function to take a list of lists?
15:47:37 <mauke> heanol: sure
15:47:38 <jaapweel> heanol, yes
15:48:10 <LoganCapaldo> @hoogle [[a]] -> _
15:48:11 <lambdabot> No matches, try a more general search
15:48:13 <oerjan> > let (-/) = subtract in (-/1) 3
15:48:14 <monochrom> > concat [[0],[1],[2]]
15:48:14 <LoganCapaldo> @hoogle [[a]] ->
15:48:15 <lambdabot>  -2
15:48:15 <lambdabot> No matches, try a more general search
15:48:16 <lambdabot>  [0,1,2]
15:48:26 <LoganCapaldo> @hoogle [[a]] -> b
15:48:27 <lambdabot> No matches, try a more general search
15:48:30 <LoganCapaldo> fine
15:48:31 <dreameye> mauke:Thanks. it seems to work!!
15:48:38 <mauke> @hoogle [[a]] -> [a]
15:48:39 <lambdabot> Prelude.concat :: [[a]] -> [a]
15:48:45 <LoganCapaldo> the point is, they exist. I swear! :)
15:48:51 <oerjan> > let (-/) = (-) in (-/1) 3
15:48:53 <lambdabot>  2
15:49:36 <Mayreel> oerjan has good ideas
15:49:38 <jaapweel> heanol, is there some particular function you want, or were you just generally intrigued by the concept?
15:50:01 <heanol> jaapweel, i'm trying to make a function.. first day of haskell though
15:50:07 <heanol> i want to make a recursive elemIndex
15:50:07 <monochrom> You can also define a function to take a function of function.
15:50:35 <jaapweel> the type of a function that takes a list of lists of things of type Foo as its first argument will look like [[Foo]] -> ...
15:51:11 <LoganCapaldo> or a function of a function of a function
15:51:19 <LoganCapaldo> its turtles all the way down
15:51:56 <monochrom> Naw, it's lambda calculi all the way down.
15:52:21 <oerjan> LoganCapaldo: it can't be turtles all the way down, that would be an infinite type.
15:52:30 <monochrom> newtype FTW
15:52:59 <monochrom> infinite types are allowed for theoretical purposes :)
15:53:50 <oerjan> but are they allowed for hypothetical tortoises?
15:54:17 <Mayreel> Unfortunately the world was written in C so it crashed after like ninety tortoises
15:54:20 <monochrom> Yes, that's theory too.
15:54:33 <LoganCapaldo> World was too strict apparently
15:54:45 <oerjan> it's still too strict
16:01:43 <heanol> map (== "c") "asdasdc"
16:01:46 <heanol> why isnt that possible?
16:01:54 <Binkley> heanol: "c" is a string
16:01:55 <heanol> i thought strings where just lists of chars
16:01:57 <Binkley> you want a character
16:01:57 <heanol> oh
16:02:04 <Binkley> > map (== 'c') "asdascdc"
16:02:05 <lambdabot>  [False,False,False,False,False,True,False,True]
16:02:06 <dibblego> ?type map
16:02:07 <heanol> ahh
16:02:09 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:02:15 <dibblego> ?type (== "c")
16:02:18 <lambdabot> [Char] -> Bool
16:02:27 <dibblego> ?type "asdascdc"
16:02:29 <lambdabot> [Char]
16:02:38 <dibblego> bzzzt wrong, see why?
16:02:54 <heanol> yep :)
16:03:00 <dibblego> good :)
16:03:02 <heanol> thanks
16:03:24 <LoganCapaldo> > map ("c" `isPrefixOf`) (tails "asdascdc")
16:03:27 <lambdabot>  [False,False,False,False,False,True,False,True,False]
16:04:55 <heanol> haskell is neat
16:05:14 <LoganCapaldo> Isn't it just :)
16:05:17 <sorear>  5760 stefan    15   0  359m 244m 8128 S  1.3 64.7   2:14.60 ghc-6.7.2007061
16:05:41 <sorear> ghc thrashes when fed alex output :(
16:06:55 <LoganCapaldo> > let tails [] = []; tails a@(x:xs) = [a]:tails xs in tails [1,2,3]
16:06:56 <lambdabot>  [[[1,2,3]],[[2,3]],[[3]]]
16:07:07 <LoganCapaldo> > let tails [] = []; tails a@(x:xs) = a:tails xs in tails [1,2,3]
16:07:08 <lambdabot>  [[1,2,3],[2,3],[3]]
16:07:18 <heanol> what are you doing?
16:07:31 <LoganCapaldo> > tails [1,2,3]
16:07:33 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:07:43 <LoganCapaldo> > let tails [] = [[]]; tails a@(x:xs) = a:tails xs in tails [1,2,3]
16:07:45 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:08:19 <sorear> it's so much simpler expressed as a paramorphism!
16:08:34 <LoganCapaldo> a what now?
16:09:03 <sorear> A paramorphism.
16:09:14 <Binkley> @google paramorphism
16:09:15 <lambdabot> http://www.thefreedictionary.com/paramorphism
16:09:23 <heanol> Hmm
16:09:26 <heanol> i think i need some help
16:09:31 <LoganCapaldo> well I clearly didn't not mishear you, so I was hoping for some elaboration <g>
16:09:35 <Binkley> that is not a helpful google result :-)
16:09:49 <heanol> for learning, i want to write a program that takes a grid of characters as input and a string, find the position of the string in the grid.. i know how i'd do it in other languages.. but i don't really know how to approach it in haskell :)
16:09:54 <LoganCapaldo> My head hurst from that double (tiple?) negative
16:10:11 <heanol> the actual searching is what i'm wondering is the haskell way to do
16:10:31 <monochrom> Consider storing the grid in a grid rather than lists.
16:10:34 <oerjan> :t findIndex
16:10:36 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
16:10:39 <heanol> oh.. there's a grid
16:12:00 <LoganCapaldo> Binkley: based on that definition I'd think sorear was advocating alchemy-oriented programming :)
16:12:54 <Binkley> we already have alchemy-oriented programming, it's called C :-)
16:13:14 <jfoutz> alchemy-oriented programming is perl
16:13:41 <jfoutz> C is more of a, better-than-assembler-oriented programming
16:14:00 <monochrom> alchemy-oriented programming is what most programmers do, independent of language or education or moon phase or ...
16:14:04 <Binkley> I was thinking it had to be C since you can cast anything into anything else
16:14:21 <oerjan> heanol: what is the type of your grid and how are the strings supposed to be laid out in it?
16:14:47 <LoganCapaldo> > scanr tail [1,2,3]
16:14:49 <lambdabot>  Couldn't match expected type `b -> b' against inferred type `[a]'
16:14:56 <monochrom> Well if you give them Haskell they'll still cast anything into anything else.
16:14:57 <LoganCapaldo> > scanr1 tail [1,2,3]
16:14:58 <lambdabot>  Couldn't match expected type `[a] -> [a]'
16:15:38 <LoganCapaldo> merp
16:15:39 <Saizan> ?type scanr
16:15:42 <lambdabot> forall a b. (a -> b -> b) -> b -> [a] -> [b]
16:15:45 <Igloo> > scanr (:) [] [1,2,3]
16:15:48 <lambdabot>  [[1,2,3],[2,3],[3],[]]
16:15:52 <heanol> oerjan, for starters i was just thinking a 3x3 grid and the strings may be anywhere in it, as long as all characters of the string is somewhere in it :)
16:15:53 <LoganCapaldo> there it is
16:16:24 <oerjan> heanol: they don't even have to be connected?
16:16:41 <heanol> oerjan, well, in the end, yes, but i thought it'd would be simpler to start without that requirement
16:17:15 <oerjan> heanol: anyway you might want an Array type
16:17:19 <monochrom> Use Data.Map from Char to (Int,Int) to stor the grid. Look up individual characters.
16:17:25 <oerjan> since you are going in all directions
16:17:26 <Saizan> ?type scanl
16:17:28 <lambdabot> forall a b. (a -> b -> a) -> a -> [b] -> [a]
16:17:33 <jfoutz> ?type unlines
16:17:35 <lambdabot> [String] -> String
16:17:48 <jfoutz> ?type find
16:17:50 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe a
16:18:11 <oerjan> monochrom: to [(Int, Int)], don't you mean?
16:18:12 <monochrom> Hrm, from Char to [(Int,Int)] may be better.
16:18:41 <jfoutz> find (=='b') $ concat ["abc","def","ghi"]
16:18:42 <monochrom> Heh, Char to Data.Set (Int,Int) :)
16:18:47 <jfoutz> > find (=='b') $ concat ["abc","def","ghi"]
16:18:48 <lambdabot>  Just 'b'
16:19:31 <mehrheit> @type findIndex
16:19:33 <lambdabot> forall a. (a -> Bool) -> [a] -> Maybe Int
16:19:37 <mehrheit> > findIndex (=='b') $ concat ["abc","def","ghi"]
16:19:39 <lambdabot>  Just 1
16:20:10 <jfoutz> @type transpose
16:20:14 <lambdabot> forall a. [[a]] -> [[a]]
16:20:22 <mehrheit> > let a = findIndex (=='f') $ concat ["abc","def","ghi"] in (a `div` 3, a `mod` 3)
16:20:23 <lambdabot>        add an instance declaration for (Integral (Maybe Int))
16:20:23 <lambdabot>     In the expr...
16:21:08 <oerjan> mehrheit: try working in the Maybe monad
16:21:11 <mehrheit> > let a = findIndex (=='f') $ concat ["abc","def","ghi"] in (a `fmap div` 3, a `fmap mod` 3)
16:21:11 <lambdabot>  Parse error
16:21:23 <LoganCapaldo> > do a <- findIndex findIndex (=='f') $ concat ["abc","def","ghi"] ; return (a `div` 3, a `mod` 3)
16:21:24 <lambdabot>  Couldn't match expected type `Bool'
16:21:30 <emu> abject-oriented programming
16:21:31 <mehrheit> well, Just an idea
16:21:39 <LoganCapaldo> > do a <- findIndex (=='f') $ concat ["abc","def","ghi"] ; return (a `div` 3, a `mod` 3)
16:21:41 <lambdabot>  Just (1,2)
16:21:43 <emu> @google abject-oriented programming
16:21:54 <emu> blargh
16:21:59 <lambdabot> Plugin `search' failed with: IRCRaised thread killed
16:22:04 <oerjan> mehrheit: btw there is a divMod
16:22:10 <mauke> emu: http://www.lsd.ic.unicamp.br/~oliva/fun/prog/resign-patterns
16:22:23 <LoganCapaldo> > do a <- findIndex (=='f') $ concat ["abc","def","ghi"] ; return $ a `divMod` 3
16:22:25 <lambdabot>  Just (1,2)
16:23:10 <jfoutz> mauke, those are great.
16:23:40 <mehrheit> > 1 `foldr (*)` [2, 2]
16:23:40 <lambdabot>  Parse error
16:23:45 <oerjan> > fmap (`divMod` 3) $ findIndex (=='f') $ concat ["abc","def","ghi"]
16:23:47 <lambdabot>  Just (1,2)
16:23:51 <mehrheit> can't curried functions be used in ``?
16:24:21 <oerjan> mehrheit: only identifiers
16:24:21 <mehrheit> I mean partially applied, of course
16:24:23 <LoganCapaldo> mehrheit: it has to be a single identifier
16:24:40 <LoganCapaldo> > let a = foldr (*) in 1 `a` [2,2]
16:24:42 <lambdabot>  4
16:25:05 <heanol> what does the backtick do
16:25:06 <heanol> ?
16:25:07 <heanol> `
16:25:28 <emu> allows functions to be used in infix form
16:25:48 <oerjan> heanol: it turns an ordinary function into an operator.
16:25:50 <emu> > 5 `div` 3
16:25:52 <lambdabot>  1
16:25:56 <heanol> oh, ok
16:25:56 <emu> > div 5 3
16:25:58 <lambdabot>  1
16:26:14 <heanol> and $?
16:26:19 <emu> function application
16:26:30 <mauke> heanol: f $ x = f x
16:27:05 <mehrheit> sometimes it makes code clearer, by allowing to omit a few parantheses
16:27:49 <olsner> f $ a b c d = f (a b c d), f $ a $ b c d = f (a (b c d)), etc
16:28:06 <heanol> i see
16:28:09 <heanol> :)
16:28:14 <emu> normal function application is left-associative
16:28:18 <emu> (((f a) b) c)
16:28:33 <emu> but sometimes you want (f a) (b c)
16:28:44 <LoganCapaldo> often even :)
16:30:48 <jfoutz> @t (+) 1
16:30:48 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:30:59 <jfoutz> @type (+) 1
16:31:02 <lambdabot> forall t. (Num t) => t -> t
16:31:05 <mehrheit> @thx
16:31:05 <lambdabot> you are welcome
16:31:21 <mehrheit> @you
16:31:21 <lambdabot> My NOSE is NUMB!
16:31:29 <olsner> @yow
16:31:29 <lambdabot> Mary Tyler Moore's SEVENTH HUSBAND is wearing my DACRON TANK TOP in a
16:31:29 <lambdabot> cheap hotel in HONOLULU!
16:31:41 <mehrheit> @todo
16:31:41 <lambdabot> 0. SamB: A way to get multiple results from a google search
16:31:41 <lambdabot> 1. dons: improve formatting of @dict
16:31:41 <lambdabot> 2. dons: write Haskell Manifesto
16:31:41 <lambdabot> 3. lispy: don't let lambdabot's prettyprinter split the sequence @foo across lines
16:31:41 <lambdabot> 4. TheHunter: priviledged users should get priviledged listcommands.
16:31:43 <lambdabot> [24 @more lines]
16:31:44 <LoganCapaldo> where does this _come from_?
16:31:57 <SamB> LoganCapaldo: @todo?
16:31:59 <LoganCapaldo> @yow I mean
16:31:59 <lambdabot> Now I understand the meaning of "THE MOD SQUAD"!
16:32:00 <jfoutz> lambdabot has been reading too much emacs yow
16:32:09 <jfoutz> emacs
16:32:11 <SamB> LoganCapaldo: Zippy the Pinhead, as far as I know
16:32:15 <olsner> ... and where does it goto?
16:32:31 <LoganCapaldo> @todo avoid Zippy the pinhead at all costs
16:32:31 <lambdabot> Plugin `todo' failed with: IRCRaised @todo has no args, try @todo-add or @list todo
16:32:31 <SamB> jfoutz: I thought Zippy the Pinhead was a comic
16:32:38 <LoganCapaldo> @todo-add avoid Zippy the pinhead at all costs
16:32:38 <lambdabot> Entry added to the todo list
16:32:49 <olsner> @where zippy the pinhead
16:32:49 <lambdabot> I know nothing about zippy.
16:32:50 <SamB> unfortunately, nobody ever cleans out the todo list
16:33:04 <SamB> sorear: can you clean it out some?
16:33:13 <LoganCapaldo> Isn't that an inherent property of todo lists? :)
16:33:24 <dibblego> ?check \p q -> (not p) && q == (not p) && q -- WTF?
16:33:26 <lambdabot>  Falsifiable, after 0 tests: True, False
16:33:43 <dibblego> gah, parentheses
16:33:45 <oerjan> > let coordList grid = [(c,(x,y)) | (y,l) <- zip [0..] (lines grid), (x,c) <- zip [0..] l] in coordList "ab\ncd"
16:33:47 <SamB> for some reason I thought lambdabot admins might do it sometime
16:33:49 <lambdabot>  [('a',(0,0)),('b',(1,0)),('c',(0,1)),('d',(1,1))]
16:33:55 <SamB> so I only allowed admins to do it
16:34:14 <SamB> I should write a patch that makes it use regexps for removing items
16:34:21 <SamB> and allow ordinary users to do it
16:34:46 <jfoutz> SamB: i guess it could be a comic... before my time. the only place i ever saw those quotes was "yow" in emacs. it's under games usually.
16:34:48 <mehrheit> don't forget s/// w/ perl regexps
16:34:49 <olsner> @pl  [(c,(x,y)) | (y,l) <- zip [0..] (lines grid), (x,c) <- zip [0..] l]
16:34:50 <lambdabot> [(c, (x, y)) | (y, l) <- zip [0..] (lines grid), (x, c) <- zip [0..] l]
16:36:11 <jfoutz> sure enough. from 1971, according to wikipedia.
16:36:32 <mehrheit> @list
16:36:32 <lambdabot> http://www.cse.unsw.edu.au/~dons/lambdabot/COMMANDS
16:37:00 <mehrheit> @help get-shapr
16:37:00 <lambdabot> get-shapr. Summon shapr instantly
16:37:08 <mehrheit> interesting
16:37:19 <astrolabe> he's a genie
16:37:23 <dibblego> how can I write a QC to prove that xs !! n will not memoise?
16:37:33 <dibblego> I need some kind of side-effect
16:37:34 <shapr> mehrheit: You called?
16:38:01 <olsner> shapr: but he didn't actually do it.. yet
16:38:03 <mehrheit> no, I haven't actually entered the command to summon you
16:38:16 <shapr> Aw...
16:38:26 * shapr goes back into his LAMP...
16:38:28 <Binkley> lol
16:38:43 <mehrheit> @help yhjulwwiefzojcbxybbruweejw
16:38:43 <lambdabot> V RETURNS!
16:38:54 <olsner> @yhjulwwiefzojcbxybbruweejw
16:38:55 <lambdabot> Just 'J'
16:39:03 <Binkley> @yhjulwwiefzojcbxybbruweejw
16:39:03 <lambdabot> Just 'J'
16:39:27 <olsner> > join (Just Nothing)
16:39:29 <lambdabot>  Nothing
16:39:42 <olsner> > Just join Nothing
16:39:44 <lambdabot>  Couldn't match expected type `Maybe a -> t'
16:39:48 <olsner> > Just join >> Nothing
16:39:50 <lambdabot>  Add a type signature
16:41:02 <olsner> shouldn't that find (>>) :: Maybe a -> Maybe b?
16:41:26 <mehrheit> @help id
16:41:26 <lambdabot> id <arg>. The identiy plugin
16:41:39 <olsner> where a is the signature of 'join' and b could be anything?
16:41:51 <olsner> Just (join Nothing)
16:41:59 <olsner> > Just (join Nothing)
16:42:02 <lambdabot>  Just Nothing
16:42:12 <oerjan> olsner: it doesn't know what Maybe type to Show
16:42:21 <olsner> aha
16:42:45 <mehrheit> @id 1
16:42:45 <lambdabot>  1
16:42:46 <oerjan> er, except your last one worked
16:43:06 <LoganCapaldo> @type Just (join Nothing)
16:43:09 <lambdabot> forall a. Maybe (Maybe a)
16:44:26 <olsner> I guess I'm not ever going to out-weird haskell
16:45:33 <SamB> > fix join
16:45:34 <lambdabot>      Occurs check: cannot construct the infinite type: a = m a
16:45:34 <lambdabot>       Expected...
16:46:01 <oerjan> @t join
16:46:01 <lambdabot> Maybe you meant: tell temp thank you thanks thx time tiny-url todo todo-add todo-delete topic-cons topic-init topic-null topic-snoc topic-tail topic-tell type . ft v
16:46:05 <oerjan> :t join
16:46:06 <lambdabot> forall (m :: * -> *) a. (Monad m) => m (m a) -> m a
16:46:29 <LoganCapaldo> I'm off to ed's fixit, to fix ed
16:46:36 <oerjan> > fix (return . join) -- :)
16:46:37 <lambdabot>   add an instance declaration for (Show (m (m a)))
16:47:21 <LoganCapaldo> > fix (return . join) :: Maybe (Maybe Int)
16:47:24 <lambdabot>  Exception: <<loop>>
16:47:39 <dolio> @pl return . join
16:47:39 <lambdabot> return . join
16:48:00 <LoganCapaldo> > fix id :: Maybe (Maybe Int)
16:48:03 <lambdabot>  Exception: <<loop>>
16:48:19 <oerjan> olsner: oh right, your last one worked because it could default to something simple, but that doesn't work for Just join
16:48:48 <mehrheit> > [1..]
16:48:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,...
16:49:17 <LoganCapaldo> > iterate (+1) 0
16:49:19 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
16:49:53 <LoganCapaldo> > iterate (^2) 2
16:49:55 <lambdabot>  [2,4,16,256,65536,4294967296,18446744073709551616,34028236692093846346337460...
16:49:59 <heanol> ok i'm still playing around with this stuff.. "Data.List.findIndices (=='c') (Data.List.concat grid)]" how can i enhance that so it doesnt just print the indices of c but the indices of every char in a string?
16:50:10 <heanol> or rather, evaluate .)
16:51:01 <mehrheit> map it to the string
16:51:08 <LoganCapaldo> map (\x -> findIndices (==x) grid) string
16:51:23 <LoganCapaldo> :t map
16:51:25 <heanol> thanks, just what i was looking for but couldn't express in a better way :)
16:51:26 <lambdabot> forall a b. (a -> b) -> [a] -> [b]
16:51:47 <heanol> i didn't know you could do the x-thingy..
16:51:59 <mehrheit> @pl \x -> findIndices (==x) grid
16:52:00 <lambdabot> flip findIndices grid . (==)
16:54:11 * sorear just completely failed to grok the parametricity theorem.
16:54:31 * LoganCapaldo picks up the pieces of his shattered worldview
16:55:06 <LoganCapaldo> sorear grokking things was the one constant in my life and now its gone :(
16:56:26 <SamB> @hoogle ([a] -> a) -> [Maybe a] -> Maybe a
16:56:27 <lambdabot> No matches, try a more general search
16:56:41 <dukedave> > (map (\x -> length x + 2) . words)  "You mean like this heanol?"
16:56:41 <SamB> @hoogle (m a -> a) -> m (Maybe a) -> Maybe a
16:56:42 <lambdabot> No matches, try a more general search
16:56:43 <lambdabot>  [5,6,6,6,9]
16:57:06 <SamB> @hoogle (m a -> a) -> m (n a) -> n a
16:57:07 <lambdabot> Prelude.($!) :: (a -> b) -> a -> b
16:57:08 <lambdabot> Prelude.($) :: (a -> b) -> a -> b
16:57:08 <lambdabot> Control.Monad.Error.catchError :: MonadError e m => m a -> (e -> m a) -> m a
16:57:24 <dibblego> why do ML people think function calls memoise all the time and that it is normal?
16:57:37 <dibblego> (normal default behaviour)
16:57:37 <SamB> dibblego: ... no idea...
16:57:56 <dibblego> I am having an argument with someone on the Scala list who uses F# as the premise (and Haskell, but gets it wrong)
16:57:57 <oerjan> :t catMaybes
16:57:58 <SamB> except that okasaki's terminology for thunks might have confused them
16:58:00 <lambdabot> forall a. [Maybe a] -> [a]
16:58:20 <dibblego> yes, okasaki is potentially to blame
16:58:49 <SamB> okasaki, as you presumably know, refers to thunks as "memoising" their values when they are first computed
16:59:03 <dibblego> I didn't know that specifically
16:59:33 <dibblego> is that in his thesis?
16:59:43 <dibblego> I have it somewhereon the book shelf
16:59:45 * dibblego reads
17:03:58 <dibblego> hi ChilliX
17:04:20 <ChilliX> Hi
17:05:27 <SamB> *I* have the actual book ;-)
17:05:35 <dibblego> me too
17:05:47 <dibblego> *mine* is covered for protection :)
17:05:51 <SamB> (which is suppposedly not the same as his thesis, despite sharing it's title)
17:05:56 <dibblego> yeah it has extra bits
17:05:59 <SamB> mine is softcover
17:06:00 <dibblego> I've diffed them before
17:06:10 <dibblego> the contents that is
17:08:15 <desp> what's wrong with:
17:08:16 <desp> type Storable (a, b) => Foo a b = Ptr a -> Ptr b -> ()
17:08:16 <desp> data Storable (a, b) => Bar a b = {fooFld :: Foo a b}
17:08:26 <desp> oh, wait.
17:09:08 <desp> no. what *is* wrong with it? :)
17:09:25 <SamB> desp: you mean besides the fact that those contexts are not going to be of any use to you?
17:09:33 <oerjan> for one thing, you cannot put class contexts on type
17:09:38 <desp> ah.
17:09:45 <SamB> and on data you ought not be allowed to do it
17:09:56 <SamB> it was silly to allow it, since it is useless
17:12:46 <SamB> so what would be of type Storable (a, b) => Ptr a -> Ptr b -> ()
17:14:30 <ihope> type Storable (a, b) = Storable (a, b) => Ptr a -> Ptr b -> ()?
17:14:30 <desp> well, I thought it could be a shortcut, instead of requiring functions that work on this type to have Storable (a, b) =>
17:14:45 <ihope> ...That doesn't work?
17:15:17 <ihope> Well, you can do "data Foo a = Bar a => Baz (Quux a)" and such, I think.
17:15:32 <ihope> As well as "data Foo = Bar a => Baz (Quux a)".
17:16:12 <oerjan> i don't _think_ the last one will work without a forall.
17:16:54 <ihope> Oh, right, you do need something like that.
17:16:54 <SamB> desp: what functions, though
17:17:01 <ihope> Probably.
17:17:02 <SamB> desp: I tried a shortcut like that once
17:17:05 <SamB> I got nowhere
17:17:51 <desp> well, the functions that I'm writing :)
17:17:54 <desp> never mind, though
17:34:50 <chessguy> 'evening
17:35:43 <chessguy> what are the practical implications of a language NOT being turing-complete?
17:35:51 <chessguy> (if any)
17:36:23 <Igloo> There are some programs that you can't write in it
17:36:31 <cdsmith> chessguy: Just that it's not Turing complete.  Whether that has any other implications depends on what particular deficiencies it has in computational power.
17:37:55 <chessguy> well, IIRC, if a language is turing complete, programs can't be guaranteed to terminate. if it isn't turing complete, can this be guaranteed?
17:38:06 <Igloo> Yes
17:38:17 <Igloo> e.g. the language in which the only instruction is "STOP"
17:38:18 <cdsmith> chessguy: yes, it can be guaranteed for some (but not all) non-Turing-complete languages
17:39:04 <rashakil> well, you can't write interpreters for turing-complete languages in it, for one.
17:39:06 <cdsmith> A more useful example: all well-typed terms in the simply typed lambda calculus are guaranteed to terminate.
17:39:38 <Igloo> You might also be interested in looking up "primitive recursive"
17:39:43 <dons> and epigram, notably, terminates, yet you can write some pretty useful programs in it :-)
17:40:26 <chessguy> what kinds of things can't you do with non-TC languages
17:40:27 <chessguy> ?
17:40:29 <Igloo> epigram has 3 levels: guaranteed to terminate, typing guaranteed to terminate and nothing guaranteed (or at least, it did last I knew)
17:40:49 * sorear *lightbulb*
17:40:53 <dons> chessguy: write turing machines.
17:40:56 <Igloo> You can't write a Haskell interpreter
17:41:08 <chessguy> well, sure
17:41:13 <notsmack> chessguy: mostly it depends on the language
17:41:27 <cdsmith> chessguy: there are only a few tasks that absolutely require a Turing complete language.  They are the set of Turing complete problems.  Other than that, it depends on the language.
17:41:34 <sorear> You can do a lot of things if you allow wrapping the type mu.
17:42:01 <sorear> newtype Mu f = Mu (f (IORef (Mu f))) -- arbitrary mutability
17:42:22 <sorear> eh,
17:42:25 <dons> these icfp blog posts are very mysterious!
17:42:28 <sorear> newtype Mu f = Mu (IORef (f (Mu f))) -- arbitrary mutability
17:42:38 <Igloo> Oh, I'd forgotten about the ICFP blog
17:42:39 <dons> `Close encounters of Arrow kind?' sounds promising though, i must say.
17:42:57 <sorear> newtype Mu f = Mu (Lazy (f (Mu f))) -- lazy nontermination even in an SN language
17:42:58 <cdsmith> dons: I was wondering about that earlier today.
17:43:08 <chessguy> oh, all those cryptic spaceship drawings are about the ICFP?
17:43:08 <sorear> where Lazy = Stream . Maybe
17:43:17 <sorear> where Stream = Colist
17:43:20 <desp> dons: do you think they'll beat the previous ICFP contest in terms of sheer coolness?
17:43:23 <sorear> Oh!
17:43:35 <desp> I don't think I've ever had so much fun coding as last year :)
17:43:42 <dons> last year was very cool
17:43:43 <sorear> newtype Mu r f = Mu (r (f (Mu r f))) -- MUAHAHAHA!!!
17:43:51 <cdsmith> chessguy: They are blog entries from the person organizing ICFP; whether they relate to the ICFP or not remains to be seen. :)
17:44:40 <dons> and those utrecht guys are famous for things like parsher combinatorsh and so forth. so hmm. could be fun.
17:44:48 <chessguy> anyway, i almost wonder if non-TC languages offer more benefits than disadvantages
17:45:03 <emu> drunk parsing?
17:45:13 <emu> chessguy: investigate Coq
17:45:16 <dons> oh, that was my dutch accent
17:45:23 <cdsmith> chessguy: as always, it will depend on the problem.  That won't be true if you want to write a general purpose scripting language interpreter, for example.
17:45:26 <sorear> Of course, recursive newtypes are not possible with SN; you need to fake it with church encoding (which silently does the wrong thing with contravariant functors (beats !SN I suppose))
17:45:45 <sorear> chessguy: I think people used to say the same thing about non-typeless languages :P
17:45:50 * desp blinks at sorear
17:46:33 <sorear> desp: I'm dumping my *lightbulb* into the channel so that the *real* geniuses can make a phd or two.
17:48:57 <chessguy> did i get booted?
17:49:02 <Korollary> no
17:49:04 <chessguy> @bot
17:49:04 <lambdabot> :)
17:49:05 <chessguy> ah
17:49:12 <chessguy> it just got quiet
17:49:49 <slowriot> suppose that I want to make a list of circle coordinates in a 3D space. I have: myPoints = [ (cos(a), sin(a), 0) | x <- [0..11] ]
17:50:01 <desp> @boot
17:50:01 <lambdabot> Unknown command, try @list
17:50:09 <slowriot> Is there a way to define a once based on x?
17:50:39 <slowriot> for example, a <- 2*pi*x/11 ?
17:50:49 <mauke> let a = 2*pi*x/11
17:51:15 <slowriot> does that work within the set builder notation?
17:51:22 <slowriot> where do I put that?
17:51:36 <cdsmith> [ (cos(a), sin(a), 0) | let a = 2 * pi * x / 11, x <- [0..11
17:51:44 <slowriot> okay, thanks
17:51:54 <cdsmith> > [ (cos(a), sin(a), 0) | let a = 2 * pi * x / 11, x <- [0..11] ]
17:51:55 <mauke> > [ (cos(a), sin(a), 0) | x <- [0..11], let a = 2*pi*x/11 ]
17:51:55 <lambdabot>   Not in scope: `x'
17:51:57 <lambdabot>  [(1.0,0.0,0),(0.8412535328311812,0.5406408174555976,0),(0.41541501300188644,...
17:52:02 <oerjan> wrong order
17:52:02 <chessguy> i think you can put it outside that too
17:52:17 <Figs> hey, I think I'm starting to get it
17:52:23 <Figs> http://rafb.net/p/ZSZKPV53.html
17:52:25 <lambdabot> Title: Nopaste - No description
17:52:26 <Figs> is this good?
17:52:28 <cdsmith> oerjan: yeah, oops
17:52:59 <chessguy> Figs, sure, that works
17:53:01 <cdsmith> Figs: yeah, but 'sum' is a Prelude function.
17:53:01 <notsmack> Figs: looks fine
17:53:02 <oerjan> @src sum
17:53:02 <lambdabot> sum = foldl (+) 0
17:53:24 <chessguy> ('m not sure what the n=[1,2,3,4] is for, but it's not invalid)
17:53:35 <notsmack> chessguy: it's just a test value i assume
17:53:37 <Figs> it's just for a variable so I can test
17:54:09 <chessguy> > let listsum [] = 0;
17:54:09 <chessguy> listsum (x:xs) = x + listsum xs in listsum [1..4]
17:54:09 <lambdabot>  Parse error
17:54:39 <oerjan> Figs: it works fine in theory but for long lists you may get stack overflow
17:54:45 <dibblego> ?src sum
17:54:45 <lambdabot> sum = foldl (+) 0
17:54:56 <notsmack> > let {listsum [] = 0; listsum (x:xs) = x + listsum xs} in listsum [1..4
17:54:57 <lambdabot>  Parse error
17:55:01 <Figs> haskell has stack overflows? :(
17:55:07 <cdsmith> Figs: yes
17:55:10 <notsmack> Figs: well it has stacks...
17:55:17 <dibblego> ?check \xs -> sum (xs :: [Int]) = listsum xs where listsum [] = 0; listsum (x:xs) = x + listsum xs
17:55:17 <lambdabot>  Parse error
17:55:17 <chessguy> > let listsum [] = 0 listsum (x:xs) = x + listsum xs in listsum [1..4]
17:55:18 <lambdabot>  Parse error
17:55:29 <dibblego> ?check \xs -> sum (xs :: [Int]) == listsum xs where listsum [] = 0; listsum (x:xs) = x + listsum xs
17:55:29 <lambdabot>  Parse error
17:55:32 <chessguy> > let listsum [] = 0; listsum (x:xs) = x + listsum xs in listsum [1..4]
17:55:34 <cdsmith> chessguy: typing is hard, eh?
17:55:35 <lambdabot>  10
17:55:40 <mehrheit> are folds optimised agains stack overflows in ghc?
17:55:44 <chessguy> cdsmith, it's been a long week :)
17:55:51 <sorear> > let { foo x = foo (x + 1) + foo (x + 1) } in foo 0 -- Figs
17:55:58 <SamB> @wiki stack overflow
17:55:58 <lambdabot> http://www.haskell.org/haskellwiki/stack_overflow
17:55:59 <lambdabot> Terminated
17:56:00 <dibblego> @let listsum [] = 0; listsum (x:xs) = x + listsum xs
17:56:01 <lambdabot> Defined.
17:56:04 <SamB> @wiki Stack overflow
17:56:04 <lambdabot> http://www.haskell.org/haskellwiki/Stack_overflow
17:56:07 <dons> mehrheit: most useful recursion and folds result in tail calls . i.e. gotos
17:56:08 <dibblego> ?check \xs -> sum (xs :: [Int]) == L.listsum xs
17:56:10 <lambdabot>  OK, passed 500 tests.
17:56:14 <SamB> dons: um.
17:56:17 <SamB> dons: ... no!
17:56:18 <Figs> well, what's it limited by?
17:56:30 <chessguy> whoah, @let is fixed?
17:56:43 <dons> SamB: sure they do. you just have to work out what i mean by 'useful'.
17:56:46 <chessguy> since when?
17:56:57 <dons> sum on Int, for example, does produce a tail call, due to strictness analysis
17:57:02 <SamB> dons: usually, when you get tail calls is exactly when you get stack overflows!
17:57:05 <oerjan> > let listsum [] = 0; listsum (x:xs) = x + listsum xs in listsum [1..1000000]
17:57:10 <lambdabot> Terminated
17:57:37 <cdsmith> SamB: only if you need the whole result at once.
17:57:42 <chessguy> > sum [1..1000000]
17:57:44 <lambdabot>  500000500000
17:57:47 <dons> the joy of laziness.
17:57:51 <dibblego> @let listsum' [] = 0; listsum' (x:xs) = x + listsum' $! xs
17:57:52 <lambdabot> <local>:5:39:     Occurs check: cannot construct the infinite type: t = [t] -...
17:58:07 <SamB> dons: usually, instead of a tail call you get a thunk
17:58:15 <dibblego> actually, won't strictness analysis make listsum run in constant stack for xs :: [Int]?
17:58:24 <dons> no, not usually :-) you write different code to me.
17:58:33 <SamB> dons: I suppose so!
17:58:36 <dons> dibblego: for the result :: Int, it should.
17:58:37 <sjanssen> dibblego: no, the compiler has to be even smart
17:58:40 <SamB> dons: you need to write more compilers
17:58:45 <sjanssen> smarter
17:59:01 <dibblego> ?type L.listsum
17:59:03 <lambdabot>     Interface file inconsistency:
17:59:04 <lambdabot>       home-package module `L' is mentioned,
17:59:04 <dons> > let listsum [] = (0 :: Int); listsum (x:xs) = x + listsum xs in listsum [1..1000000]
17:59:07 <lambdabot>  1784293664
17:59:14 <dons> > let listsum [] = 0; listsum (x:xs) = x + listsum xs in listsum [1..1000000]
17:59:20 <lambdabot> Terminated
17:59:24 <dons> ?src Int
17:59:25 <lambdabot> data Int = I# Int#
17:59:31 <dons> good data type.
17:59:43 <notsmack> ?src Integer
17:59:43 <lambdabot> data Integer = S# Int#
17:59:43 <lambdabot>              | J# Int# ByteArray#
17:59:44 <Figs> how to iterate instead of recurse?
17:59:46 <dibblego> ah right
17:59:50 <sjanssen> dibblego: the compiler would have to change (x + ( y + ...)) into ((x + y) ...)
17:59:55 <dibblego> Figs, use a different language
18:00:08 <dibblego> sjanssen, yes I see now since dons' example
18:00:09 * Figs just doesn't want it to overflow
18:00:19 <SamB> Figs: learn that tail recursion *is* iteration
18:00:19 <dibblego> Figs, use foldl or seq
18:00:30 <dibblego> er, foldl'
18:00:34 <chessguy> you could write it using an accumulator, manually
18:00:50 <Figs> just whatever the practical way of avoiding the problems are
18:01:24 <dibblego> ?type sum
18:01:26 <lambdabot> forall a. (Num a) => [a] -> a
18:01:47 <dibblego> dons, why is the source to sum using foldl instead of foldl' if it can't run in constant stack? (because of Num a => a)
18:02:05 <Figs> what is the ' for?
18:02:06 <dons> apparently its a bug in the report
18:02:06 <dibblego> can sum overflow the stack?
18:02:09 <dibblego> ok cool
18:02:10 <dons> because H98 didn't have foldl'
18:02:17 <dibblego> > sum [1..10000000]
18:02:23 <lambdabot> Terminated
18:02:27 <cdsmith> Figs: two things to look into: the foldl' function, and the "bang patterns" language extension for GHCi.  These make avoiding stack overflow easy enough.
18:02:28 <dons> > sum [1..1000000] :: Int
18:02:30 <lambdabot>  1784293664
18:02:31 <dons> > sum [1..1000000] :: Integer
18:02:33 <lambdabot>  500000500000
18:02:33 <dibblego> ok thanks
18:02:37 <dons> > sum [1..1000000]
18:02:40 <lambdabot>  500000500000
18:02:59 <SamB> someone made some lame excuse about lazy Num instances
18:03:03 <dibblego> Figs, foldl and foldl' are different functions (the latter runs in constant stack space i.e. "iteration")
18:03:12 <cdsmith> Oops, meant "GHC" not "GHCi"
18:04:27 <mehrheit> @src foldl'
18:04:27 <lambdabot> foldl' f a []     = a
18:04:27 <lambdabot> foldl' f a (x:xs) = let a' = f a x in a' `seq` foldl' f a' xs
18:04:46 <dibblego> has anyone ever suggested that foldl should just be foldl' anyway in later versions?
18:04:49 <oerjan> it seems like lambdabot runs out of time before it runs out of stack?
18:05:49 <cdsmith> dibblego: that would potentially break some things.
18:05:49 <dons> > scanr (*) 1 [1..]
18:05:53 <lambdabot>  Exception: stack overflow
18:06:07 <dibblego> what could it break?
18:06:37 <cdsmith> dibblego: folds where the accumulator evaluates to bottom, but the caller ignores it.
18:06:39 <sjanssen> dibblego: any folded function that isn't strict in the accumulator is at risk
18:06:52 <dibblego> yeah of course
18:06:53 <sjanssen> dibblego: which isn't incredibly often in practice
18:07:32 <cdsmith> In practice, it would probably break several uses of unsafePerformIO that I've seen.
18:08:09 <Figs> is scheme easier to learn that haskell?
18:08:21 <cdsmith> Figs: probably yes
18:08:47 <dibblego> Figs, easy-to-learn is generally inversely proportional to power on the language power continuum
18:09:22 <Figs> depends on perspective
18:09:30 <jcreigh> dibblego: well, I'd say that powerful languages aren't easy to learn, but the converse is not nessesarily true.
18:09:38 <oerjan> Figs: i am sure scheme's continuations can warp your head quite a bit
18:09:42 <Figs> :P
18:09:52 <dibblego> jcreigh, perhaps, but I find say Java/C/C++ etc. easy to learn
18:10:03 <dibblego> jcreigh, if you've already been tainted that is
18:10:08 <oerjan> on the other hand, Haskell has Control.Monad.Cont
18:11:09 <cdsmith> A non-technical question: I'm meeting with our CEO tomorrow and he wants assurance that it's possible to hire Haskell programmers.  What do I tell him?
18:11:23 <rashakil> he can hire me
18:11:24 <Binkley> tell him that Galois Connections rejects people sometimes :-)
18:11:40 <ed1t> @src zipWith
18:11:40 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
18:11:40 <lambdabot> zipWith _ _      _      = []
18:11:54 <cdsmith> Binkley: sounds promising.
18:11:55 <rashakil> tell him "anything is possible with enough money"
18:11:57 <dibblego> that they may be a little more difficult to find, but not 20 times harder to find than a Java/C++ programmer, and a Haskell programmer can most certainly achieve more than 20 times what a Java/C++ programmer can - all other things equal
18:12:21 <Binkley> rashakil: unfortunately, all the money in the world won't make somebody smart :-)
18:12:52 <Igloo> cdsmith: Can you say which company, OOI?
18:13:11 <cdsmith> Igloo: http://www.mindiq.com/
18:13:12 <lambdabot> Title: MindIQ - Elearning and Instructor-Led Training
18:13:19 <Boney> cdsmith: There are many people out there interested in taking such jobs.  I would be interested too if I wasn't so busy.
18:13:24 <dons> cdsmith: there's a community of thousdans (2000+ on the cafe mailing list), so should be possible to get someone ...
18:13:35 <Korollary> cdsmith: Which metro area?
18:14:01 <cdsmith> Korollary: hypothetically (we aren't hiring right now) it would be work-from-home arrangements.
18:14:53 <Igloo> cdsmith: All of the 4 companies that I know of have managed to find Haskell some people, and work-from-home makes it even easier
18:15:16 <Binkley> if I wasn't in grad school I'd snap up a work-from-home Haskell job in 2 seconds
18:15:38 <Figs> :P
18:15:45 <Figs> if I knew haskell, I'd take the job
18:15:54 <dons> Figs, better get learning then!
18:15:54 <cdsmith> Figs: :)
18:15:57 <Figs> hehehe
18:16:14 <Korollary> cdsmith: how many haskell programmers do you currently have?
18:16:14 <Binkley> not knowing Haskell is no barrier to some Haskell jobs
18:16:18 <Binkley> such as at my former employer
18:16:31 <cdsmith> Korollary: me, and I don't currently use Haskell at work.  We're looking at switching.
18:16:42 <dibblego> your former employer hired a Haskell programmer who didn't know Haskell?
18:16:49 <Korollary> cdsmith: how many are 'we'?
18:16:56 <dibblego> |we| = ?
18:17:14 <cdsmith> Korollary: Right now, there is me and two salespeople in the company.
18:17:14 <Binkley> dibblego: well, the people were hired for other purposes originally, but yes, they ended up writing haskell code
18:17:16 <Figs> I suppose (s)he's refering to the company
18:17:19 <Binkley> "learning" it as they "went along"
18:17:25 <Igloo> cdsmith: switching from what?
18:17:27 <dibblego> Binkley, scary shit
18:17:29 <cdsmith> Igloo: Java
18:17:40 <Korollary> Ah. Jackie Chan needs Chris Tucker
18:17:53 <Binkley> dibblego: you have no idea
18:18:00 <Figs> ok, I'll cya guys later
18:18:18 <jcreigh> Binkley: didn't work out that well, then?
18:18:32 <Binkley> jcreigh: I left after 2 months
18:18:40 <Binkley> but if anyone wants a job, they're hiring! :-D
18:18:51 <cdsmith> I'd hire programmings in some languages without their knowing the language first.  Haskell's a tough learning curve, though.
18:18:52 <jcreigh> Binkley: because of the novice Haskell coders?
18:19:02 <Binkley> jcreigh: lots of reasons. also because it was a defense contractor
18:19:10 <dibblego> cdsmith, I wouldn't, not Haskell
18:19:12 <Binkley> cdsmith: yeah, but these weren't very good programmers to start with
18:19:17 <desp> hrm
18:19:33 <desp> is there anything approximating a hashtable built in the standard libraries?
18:19:41 <mauke> Data.Map?
18:19:41 <Binkley> desp: Data.Map
18:20:00 <cdsmith> Well, I've definitely got the argument that hiring Haskell programmers ensures we get talented people. :)
18:20:03 <desp> @stereo
18:20:03 <lambdabot> Unknown command, try @list
18:20:10 <desp> @quote stereo
18:20:10 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
18:20:15 <desp> thanks
18:20:15 <Binkley> heh
18:20:26 <cdsmith> Binkley: disagree?
18:20:49 <oerjan> @hackage Data.HashTable
18:20:49 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/Data.HashTable
18:21:29 <Binkley> cdsmith: I agreer
18:21:32 <Binkley> er, I agree, even
18:21:45 <Binkley> I mean, the basic problem with the people I'm talking about not knowing Haskell was that they weren't very good
18:21:55 <Binkley> so having them writing Haskell made it even worse
18:21:56 <cdsmith> Binkley: ah.  I just misinterpreted the 'heh' then. :)
18:22:08 <desp> that URL isn't quite good
18:22:12 <oerjan> desp: oh wait, HashTable is actually in base.
18:22:22 <Binkley> OTOH if you were hiring people who knew Haskell, and needed them to write code in some other language too, even if they didn't know it, I wouldn't worry
18:22:24 <kpreid> desp: Data.HashTable *is* a hash table, but it's IO only. Data.Map requires Ord rather than hashing and is functional
18:22:35 <kpreid> @docs Data.HashTable
18:22:35 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-HashTable.html
18:22:45 <dibblego> Binkley, agreed, Haskell should be on the CV, even if you're doing blub work
18:22:47 <kpreid> s/functional/pure/
18:22:48 <desp> aha.
18:24:52 <Serge> Can anyone recommend any good tutorials/primers on Monads?
18:25:10 <mauke> http://sigfpe.blogspot.com/2007/04/trivial-monad.html
18:25:11 <lambdabot> Title: A Neighborhood of Infinity: The Trivial Monad
18:25:20 <Serge> mauke: Thanks =)
18:25:20 <Binkley> ?quote dons metaphor
18:25:21 <lambdabot> dons says: xerox: what analogy or metaphor did you use? monad-as-garbage-bin? monad-as-refrigerator? monads-as-unicycle?
18:28:54 <notsmack> @google You could have invented monads
18:28:57 <lambdabot> http://sigfpe.blogspot.com/2006/08/you-could-have-invented-monads-and.html
18:28:57 <lambdabot> Title: A Neighborhood of Infinity: You Could Have Invented Monads! (And Maybe You Alrea ...
18:33:02 <desp> @quote written monads
18:33:03 <lambdabot> No quotes for this person. Where did you learn to type?
18:33:11 <desp> @quote written
18:33:11 <lambdabot> mux says: "Their [Interactive LISP and TRAC] only great drawback is that programs written in them look like King Burniburiach's letter to the Sumerians done in Babylonian cuniform!"
18:33:14 <desp> meh.
18:33:24 <int80_h> is there a one stop web site for algorithms for fp in general, haskell in particular?
18:33:36 <Korollary> Okasaki's thesis/book
18:33:39 <int80_h> I've seen such things for C, and imperitive languages
18:33:50 <int80_h> oh sweet thanks, I shall google
18:35:27 <Korollary> Oleg's website also has stuff like that (in scheme, ocaml and haskell)
18:36:36 <int80_h> what's the url for oleg's site, and okasaki? I googled okasaki and came up with  boatload (okasaki and haskell I mean)
18:36:56 <Korollary> http://okmij.org/ftp/
18:36:57 <lambdabot> Title: This FTP site
18:37:12 <notsmack> okasaki's book: "Purely Functional Data Structures"
18:37:15 <oerjan> @where oleg
18:37:15 <lambdabot> I know nothing about oleg.
18:37:30 <oerjan> @where+ oleg http://okmij.org/ftp/
18:37:30 <lambdabot> Done.
18:37:52 <oerjan> @flush
18:37:52 <lambdabot> Not enough privileges
18:37:53 <Binkley> ?quote oleg
18:37:53 <lambdabot> shapr says: [on Oleg:]  And ccshan and he would argue furiously for a minute or two and then SPJ would say "Why don't you send an email to the Haskell list about that so we can have time to understand
18:37:53 <lambdabot>  what you just said?"
18:38:00 <int80_h> oooh found it :)
18:38:02 <desp> @where okasaki
18:38:02 <lambdabot> I know nothing about okasaki.
18:38:06 <desp> @where+ okasaki http://www.cs.cmu.edu/~rwh/theses/okasaki.pdf
18:38:07 <lambdabot> Done.
18:38:37 <shapr> desp: The book is better.
18:38:41 <desp> I know.
18:38:44 <Binkley> The movie is better
18:38:50 <shapr> Okasaki : The Movie.
18:38:57 <Binkley> "Hello, B-tree."
18:38:59 <int80_h> hmm I guess I need to suck it up and admit I should buy books
18:39:10 <desp> shapr: I had the pleasure of borrowing it from my school library
18:39:10 <Korollary> int80_h: you can start out with the thesis
18:39:19 <int80_h> cool, got it
18:39:32 <shapr> desp: I bought mine for 30% off at Haskell Workshop!
18:39:42 <Korollary> I stole mine
18:39:53 <desp> woop!
18:40:08 <Binkley> I bartered a goat and two pounds of lentils for mine
18:40:56 <desp> http://images.google.com/images?q=lentilky
18:40:57 <lambdabot> Title: lentilky - Google Image Search
18:44:28 <int80_h> hey this looks like exactly what I want.
18:50:06 <int80_h> I'm having trouble with the notation, but I should just spend more time with it
18:52:33 <int80_h> does the book use haskell for implementation?
18:56:57 <Figs> hey
18:57:05 <Figs> how do I comment the type of:
18:57:06 <Figs> foo a = a>3
18:57:06 <Figs> ?
18:57:42 <oerjan> :t \a -> a>3
18:57:46 <lambdabot> forall a. (Num a, Ord a) => a -> Bool
18:57:54 <Figs> ahh, it's a comma
18:58:09 <Figs> does the => mean 'consider'?
18:58:29 <oerjan> more like "implies"
18:58:52 <desp> "if a is from typeclasses Num and Ord, then this function has type a -> Bool"
18:59:54 <oerjan> (btw the forall a. part is not necessary to write)
19:00:20 <oerjan> and not H98
19:00:38 <dylan> any way of writing something like: manyTill anyChar (lookAhead end), that doesn't match the empty string?
19:00:46 <sproingie> i read it as for all a such that a has class Num and Ord, a -> Bool
19:00:48 <aspo> why is the forall part there?
19:00:59 <aspo> I can't quite tell why it is there sometimes and not others
19:01:38 <sjanssen> aspo: the 'forall' part is an extension available in some Haskell compilers
19:01:52 <sproingie> it's a categorical thing.. ii think there's existentials too, but i have no idea how to use them
19:01:59 <oerjan> aspo: Haskell puts an implicit forall of all type variables, lambdabot just writes it explicitly
19:02:12 <aspo> oergan: but when using :t and ghci
19:02:17 <aspo> sometimes I get a forall a.
19:02:20 <aspo> and sometimes not
19:02:29 <eivuokko> You get it when you have -fglasgow-exts on
19:02:29 <sjanssen> aspo: it happens when -fglasgow-exts is on
19:02:36 <sjanssen> @quote stereo
19:02:36 <lambdabot> Cale says: Welcome to #haskell where your questions are answered in majestic stereo!
19:02:38 <aspo> ah...
19:02:43 <aspo> thanks
19:02:53 <sproingie> death by stereo!
19:03:34 <Figs> I was guessing 'foo :: (Ord a|Num a) => a -> Bool
19:03:35 <Figs> thanks
19:03:43 <Figs> it's a comma :P
19:06:28 <oerjan> dylan: perhaps manyTill1 p end = liftM2 (:) p (manyTill p end)
19:06:39 <dylan> oerjan: just found that. :)
19:06:59 <dylan> it seems now my other parser never matches now, though
19:09:47 <dylan> aha
19:11:34 <dylan> so, now I can parse "fooo [% bar %] baz".
19:12:13 <dylan> Now to to translate that into something like... main = do putStr "fooo "; bar; putStr "baz"
19:13:57 <oerjan> dylan: mapM (putStr . (++" ")) bar, assuming bar is [String]
19:14:22 <dylan> bar is likely Monad m => m String.
19:15:06 <dylan> actually, I could probably just write a grammar for the template toolkit language. I'm not sure how I'd do conditional sections otherwise.
19:15:17 <oerjan> oh i thought it was the parse result.
19:15:30 <dylan> no, I'm writing a template compiler.
19:17:40 <oerjan> oh you mean that "main ..." thing is not your compiler but the produced program.
19:17:51 <dylan> yeah
19:32:03 * sorear has the brilliant idea of copying haskell-src for his compiler's parser
19:32:48 <SamB> sorear: ... haskell-src-ext?
19:32:50 <SamB> or -exts
19:32:53 <SamB> or whatever?
19:33:34 <sorear> SamB: Are there any fundamentally hard problems fixed in hsx?
19:33:49 <SamB> sorear: probably not...
19:33:52 <sorear> SamB: My set of extensions will not be equal to either :)
19:34:09 <SamB> well, wouldn't you prefer a head start?
19:34:49 <gwern> just to double check... compiling with 'ghc --make' statically links in libraries which binaries use, right? implying that if I send someone a binary making use of a bunch of libraries, they don't need those libraries installed, correct?
19:34:49 <dons> there's also Lemmih's external package for the ghc parser
19:34:57 <dons> gwern: right.
19:35:12 <dons> gwern: i'd also use -O2 :-) and -optc-static to ensure c libs are also linked statically
19:35:17 <dons> might even need -optl-static
19:35:23 <sorear> -optl-s :)
19:36:14 <gwern> dons: how would I know if c libs were not being linked in statically?
19:36:28 <gwern> does it do that by default, or would I have to be using the FFI or what?
19:36:38 <sorear> gwern: ldd
19:36:51 <sorear> gwern: by default, libc et al
19:36:56 <dons> use ldd on the binary, yes.
19:37:35 <gwern> hmm. libc is pretty big though isn't it?
19:39:22 <gwern> '/usr/lib/network-2.0/ghc-6.6/libHSnetwork-2.0.a(BSD.o): In function `rkB2_info':
19:39:27 <gwern> (.text+0xd8e): warning: Using 'endservent' in statically linked applications requires at runtime the shared libraries from the glibc version used for linking'
19:39:32 <gwern> <-- ?
19:39:45 <dons> nah, libc is tiny
19:40:11 <sorear> dons: on *bsd maybe :)
19:40:16 <sorear> -rwxr-xr-x 1 root root 1.3M 2007-05-30 03:30 /lib/libc-2.5.so
19:40:27 <desp> I'm confused.
19:40:33 <sorear> granted, some of that won't be linked
19:40:45 <gkr> Is there any function in the prelude that does \(a,b,c) -> a?
19:40:50 <sorear> gkr: no
19:40:55 <gkr> :-(
19:41:04 <sorear> dons: google 'lemmih ghc parser' gives me ghc-src, but lemmih's own repo link is dead
19:41:10 <sorear> shapr: ping
19:41:21 <dibblego> gkr: just use \(a,_,_) -> a
19:41:21 <desp> is it possible to have a list of values of type Foo a, where a could be different for each value?
19:41:35 <dibblego> desp, of course
19:41:44 <dibblego> > [Nothing, Just 7]
19:41:45 <lambdabot>  [Nothing,Just 7]
19:41:50 <dibblego> > [Nothing, Just 7] :: [Maybe Int]
19:41:51 <lambdabot>  [Nothing,Just 7]
19:42:05 <int-e> desp: not easily, no.
19:42:24 <dibblego> do you mean, of a different type?
19:42:41 <desp> int-e: not necessarily a list, then -- any way of combining such values?
19:42:52 <dibblego> a type-class?
19:42:54 <desp> dibblego: more like [Just 7, Just "a"]
19:42:55 <int-e> Hlists, or an existential wrapper.
19:42:57 <sorear> gwern: ah yes.
19:43:20 <sorear> gwern: I forgot to mention, that NSS would give you grief
19:43:34 <dibblego> desp, it usually indicates that an abstraction can be written over the type a
19:43:36 <int-e> data Foo' where Foo' :: Foo a -> Foo'
19:43:44 <sorear> gwern: I think the glibc manual has info on the gory details of statical linking
19:43:55 <int-e> [but you'll want some type class context there - otherwise Foo' values are useless]
19:44:22 <desp> I think I need some guidance from my mentor now.
19:44:24 <desp> :)
19:44:45 <desp> alas, he's offline.
19:44:47 <int-e> desp: before you dive into that, ask yourself why you're trying to do that. :)
19:44:53 <desp> yeah.
19:44:56 <gwern> sorear: hmm. well, better than nothing
19:47:44 <hpaste>  desp pasted "foo" at http://hpaste.org/354
19:47:52 <desp> int-e: ^
19:48:26 <desp> I need to provide a way for the user to set a callback function, taking an argument of user-defined typ
19:48:48 <desp> ...type, and also the value of the argument.  I need to store these two things in a structure.
19:48:51 <gkr> Is there any function in the prelude that does \x y xs -> (x,y):xs?
19:49:36 <sjanssen> @pl \x y xs -> (x,y):x
19:49:36 <lambdabot> (const .) . (flip =<< ((:) .) . (,))
19:49:41 <sjanssen> @pl \x y xs -> (x,y):xs
19:49:41 <lambdabot> ((:) .) . (,)
19:49:55 <desp> int-e: now, the problem is, I need to keep some of these structures together.
19:50:23 <gkr> sjanssen 'thanks' :-p
19:50:46 <oerjan> desp: are you talking about interaction with C?
19:50:53 <desp> oerjan: yes.
19:51:16 <desp> well, I guess I could just use Ptr () everywhere, and cast the pointers...
19:51:42 <desp> but I thought that since the callback/value will come from Haskell, I might as well keep their types proper
19:53:13 <desp> actually, wait.  since I'd like to allow the user to pass the value as just "a", and allocate/free the "Ptr a" myself, I do need the proper types.
19:53:20 <oerjan> desp: consider me out of it then.
19:53:29 <desp> heh, ok.
19:53:43 <gkr> What's the if' that lambdabot uses?
19:53:51 <gkr> Because it isn't defined on my Prelude apparently :-/
19:53:55 <oerjan> @src if'
19:53:56 <lambdabot> Source not found. Just what do you think you're doing Dave?
19:53:56 <sorear> gkr: A fictitios function...
19:54:02 <sorear> if True a b = a
19:54:06 <sorear> if False a b = b
19:54:11 <oerjan> @index if'
19:54:11 <lambdabot> bzzt
19:54:14 <sorear> alas, it's not standard
19:54:17 <int-e> @type Foreign.Ptr.castPtr
19:54:17 <sorear> (anywhere!)
19:54:21 <lambdabot> forall a b. GHC.Ptr.Ptr a -> GHC.Ptr.Ptr b
19:55:41 <gkr> What about ap?
19:55:51 <int-e> desp: why are you trying to lump them together?
19:55:58 <gkr> Nothing.
19:56:03 <oerjan> @src ap
19:56:03 <lambdabot> ap = liftM2 id
19:56:36 <oerjan> @unpl ap
19:56:36 <lambdabot> (\ d e -> d >>= \ b -> e >>= \ a -> return (b a))
19:56:52 <oerjan> eep
19:58:01 <desp> int-e: I'm trying to simplify memory management for the user. the C library I'm binding has a function that associates arbitrary numbers of structure Foo with structure Bar. when an instance of Bar is freed, one must free all the Foos. so, on the Haskell side, I'd like to keep references to all Foos together with a Bar reference.
19:58:12 <oerjan> aka ap d e = do b <- d; a <- e; return (b a)
19:58:16 <int-e> desp: if, for example, you just want to free a bunch of ptrs simultaneously, you can collect the corresponding IO actions in a list, [IO ()]
19:58:38 <desp> hm!
19:59:07 <desp> you're right, I didn't think of that.
20:01:19 <dons> yes, that's a good way. you could even tie up the finalisers for all these on the haskell side
20:01:25 <sorear> int-e: Or use a single IO ()
20:01:33 <dons> and have the Haskell GC free them on the C side, when it detects they go out of scope
20:01:36 <sorear> int-e: don't forget about (>>) and first class IO!
20:02:09 <dons> yeah, so addFinalizer (foldl (>>) [free x, free y, free z]) :-)
20:02:09 <desp> but freeing them isn't the only thing that I should eventually offer
20:02:38 <dons> desp, do you see the point about having the Haskell GC perform the free() though?
20:02:44 <dons> so the user need not worry about it
20:02:50 <sorear> also remember, ghc generates comparatively bad code for data structures.  functions (incl State# RealWorld -> (# (), State# RealWorld #) ) will allow much nicer optimization
20:03:00 <sorear> dons: sequence_ !
20:03:13 <dons> folding (>>) is more fun
20:03:14 <dibblego> is there a canonical documentation resource for using the Haskell FFI?
20:03:30 <dons> dibblego: yeah, the FFI specification.
20:03:38 <desp> dons: yes, I understand the benefit of using finalizers
20:03:42 <dibblego> the H98 FFI spec you mean?
20:03:47 <desp> sorear: pardon me, but I have no idea what you mean
20:03:52 <dons> FFI isn't H98. they're separate documents
20:04:03 <dibblego> that's what I thought
20:04:33 <desp> sorear: I don't think I should worry about optimization at this stage, though
20:04:41 <sorear> ok :)
20:04:41 <desp> roots of evil and all that
20:06:04 <sorear> @time shapr
20:06:04 <lambdabot> Local time for shapr is Thu Jun 21 22:05:02 2007
20:06:57 <Figs> what is the difference btw Num and Ord?
20:07:20 <oerjan> @src Ord
20:07:20 <lambdabot> class  (Eq a) => Ord a  where
20:07:20 <lambdabot>     compare      :: a -> a -> Ordering
20:07:20 <lambdabot>     (<), (<=), (>), (>=) :: a -> a -> Bool
20:07:20 <lambdabot>     max, min         :: a -> a -> a
20:07:25 <oerjan> @src Num
20:07:25 <lambdabot> class  (Eq a, Show a) => Num a  where
20:07:25 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:07:25 <lambdabot>     negate, abs, signum     :: a -> a
20:07:26 <lambdabot>     fromInteger             :: Integer -> a
20:08:55 <Figs> what does 'class' mean?
20:08:59 <oerjan> Ord is basic comparison, Num is basic arithmetic common to all the number classes
20:09:15 <oerjan> i mean number types
20:09:18 <int-e> sorear: I didn't forget about it, I just didn't want to suggest too much at once :)
20:09:33 <oerjan> a class is something that you can add types to
20:10:15 <Figs> ok...
20:10:19 <oerjan> @src Ord []
20:10:19 <lambdabot> Source not found. You speak an infinite deal of nothing
20:10:25 <desp> :)
20:10:52 <oerjan> @src [] Ord
20:10:52 <lambdabot> Source not found. BOB says:  You seem to have forgotten your passwd, enter another!
20:10:58 <Figs> :P
20:10:59 <int-e> desp: did you look at ForeignPtr?
20:11:16 <oerjan> @src [] compare
20:11:16 <lambdabot> Source not found. It can only be attributed to human error.
20:11:25 <oerjan> darn it
20:11:34 <Figs> @src compare
20:11:34 <lambdabot> compare x y | x == y    = EQ
20:11:34 <lambdabot>             | x <= y    = LT
20:11:34 <lambdabot>             | otherwise = GT
20:11:57 <oerjan> that is the default declaration.
20:11:57 <desp> int-e: yes, although it might not be the best fit for the situation
20:11:59 <int-e> desp: it's related (in that it supports finalizers) but it's impossible to tell if it's useful for your application.
20:12:11 <desp> int-e: yeah, I understand
20:12:34 <oerjan> i was trying to find an instance for a specific type.
20:12:42 <oerjan> @src [] (<=)
20:12:43 <lambdabot> Source not found. Just what do you think you're doing Dave?
20:12:46 <oerjan> @src [] <=
20:12:46 <lambdabot> Source not found. You type like i drive.
20:13:10 <oerjan> @src [] mfix
20:13:10 <lambdabot> mfix f = case fix (f . head) of
20:13:10 <lambdabot>            []    -> []
20:13:10 <lambdabot>            (x:_) -> x : mfix (tail . f)
20:14:21 * Figs is scared
20:14:26 <Figs> this is starting to make sense...
20:14:40 <oerjan> anyway each type that is an instance of a class defines its own version of the methods for it.
20:15:10 <oerjan> so each Ord type defines compare or <= (the rest may be given by defaults)
20:15:16 <oerjan> @src (<=)
20:15:17 <lambdabot> x <= y = case compare x y of { GT -> False; _other -> True }
20:15:54 <oerjan> @src Complex (+)
20:15:54 <lambdabot> Source not found. That's something I cannot allow to happen.
20:16:24 <oerjan> although for some reason Lambdabot will not show any of the enlightening examples I think of. :(
20:16:43 <sorear> @src Complex +
20:16:43 <lambdabot> Source not found. Have you considered trying to match wits with a rutabaga?
20:16:48 <sorear> @src [] >=
20:16:48 <lambdabot> Source not found. Take a stress pill and think things over.
20:16:50 <sorear> @src [] <=
20:16:50 <lambdabot> Source not found. Are you on drugs?
20:16:53 <sorear> @src [] compare
20:16:53 <lambdabot> Source not found. Maybe if you used more than just two fingers...
20:17:03 <Figs> I don't think it likes you :P
20:17:11 <Figs> @src compare [] []
20:17:11 <lambdabot> Source not found. Take a stress pill and think things over.
20:17:16 <oerjan> you know i have been wondering... :)
20:17:18 * Figs likes to guess too
20:17:30 <sorear> Figs: nah, it's just scared of me :)
20:17:33 <Figs> hehehe
20:17:40 <oerjan> oh wait
20:17:59 <oerjan> the Ord definition for [] is the derived one.
20:18:10 <Figs> hmm
20:18:46 <oerjan> so it doesn't have a source.  Haskell provides a derive mechanism for the most usual definitions of some classes.
20:19:27 <oerjan> not Num however.  The missing Complex must be a bug.
20:19:46 <oerjan> ah!
20:19:55 <oerjan> @src Char show
20:19:55 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
20:19:59 <oerjan> @src Char showsPrec
20:19:59 <lambdabot> Source not found. Sorry about this, I know it's a bit silly.
20:20:02 <Figs> Is it bad that I still prefer imperative thinking?
20:20:03 <int-e> @src []
20:20:03 <lambdabot> data [] a = [] | a : [a]
20:20:06 <oerjan> @src Char showList
20:20:07 <lambdabot> Source not found. My pet ferret can type better than you!
20:20:22 <int-e> wee. where does lambdabod take that from?
20:20:49 <Figs> aren't ferrets illegal as pets in california?
20:21:07 * Figs is now known as 'Mr. Left Field'
20:21:24 <sorear> Figs: lambdabot is in australia
20:21:45 <Figs> I didn't ask about lamdabot. I asked about funky ferret laws :P
20:21:59 <Figs> but thanks :)
20:22:24 <Figs> (my question still stands, however)
20:22:30 <int-e> ah, GHC.Base. GHC.Base actually defines an explicit instance of Ord for lists. but I guess the syntax  instance (Ord a) => Ord [a] where  confuses @src?
20:22:34 <Figs> @google ferret california
20:22:36 <lambdabot> http://www.ferretsanon.com/
20:22:36 <lambdabot> Title: Ferrets California
20:22:47 <sorear> Figs: It was in the news recentlyish, yes
20:23:07 <oerjan> int-e: except the last time i had this problem someone found a counterexample where it worked
20:23:09 <int-e> @src [a] compare
20:23:09 <lambdabot> Source not found. That's something I cannot allow to happen.
20:24:24 <int-e> @src [] fmap
20:24:25 <lambdabot> fmap = map
20:25:08 <oerjan> int-e: that doesn't quite count because Functor [] has no variable
20:25:35 <oerjan> @src [] Monoid
20:25:35 <lambdabot> Source not found. The more you drive -- the dumber you get.
20:25:53 <oerjan> er...
20:25:57 <oerjan> @src [] mappend
20:25:57 <lambdabot> Source not found. Do you think like you type?
20:26:03 <sorear> oerjan: we use bare constructors here.
20:26:07 <sorear> @src Maybe >>=
20:26:07 <lambdabot> Source not found. Do you think like you type?
20:26:10 <sorear> @src Maybe fmap
20:26:11 <lambdabot> fmap _ Nothing       = Nothing
20:26:11 <lambdabot> fmap f (Just a)      = Just (f a)
20:26:15 <sorear> @src Maybe (>>=)
20:26:15 <lambdabot> (Just x) >>= k      = k x
20:26:15 <lambdabot> Nothing  >>= _      = Nothing
20:26:19 <sorear> @src Maybe fail
20:26:19 <lambdabot> fail _      = Nothing
20:26:22 <sorear> @src Maybe return
20:26:22 <lambdabot> return              = Just
20:26:25 <sorear> @src Maybe (>>)
20:26:26 <lambdabot> (Just _) >>  k      = k
20:26:26 <lambdabot> Nothing  >>  _      = Nothing
20:26:29 <sorear> @src Maybe mplus
20:26:30 <lambdabot> Nothing `mplus` ys  = ys
20:26:30 <lambdabot> xs      `mplus` _ys = xs
20:26:32 <sorear> @src Maybe mzero
20:26:32 <lambdabot> mzero = Nothing
20:26:35 <sorear> @src Maybe mfix
20:26:35 <lambdabot> mfix f = let a = f (unJust a) in a where unJust (Just x) = x
20:27:01 * kpreid wondered why that doesn't use fromJust
20:27:10 <oerjan> me too
20:27:14 <sorear> @quote unJ
20:27:15 <lambdabot> SamB says: [on the subject of fromJust] SamB_XP thinks that unJust would be a more fun name for that
20:28:18 <oerjan> ok, a different approach.
20:28:30 <oerjan> > 3 :: Int
20:28:31 <lambdabot>  3
20:28:37 <oerjan> > 3 :: Double
20:28:39 <lambdabot>  3.0
20:28:47 <sorear> > 3 :: Complex (Complex Double)
20:28:48 <lambdabot>        add an instance declaration for (RealFloat (Complex Double))
20:28:48 <lambdabot>     In th...
20:28:53 <sorear> aww
20:28:57 <sorear> > 3 :: Complex Double
20:28:59 <lambdabot>  3.0 :+ 0.0
20:29:14 <sorear> imho Complex should be called, and work as, "Cayley"
20:29:17 <oerjan> Figs: you see how 3 can give values of different types?
20:29:41 <oerjan> @src Num
20:29:41 <lambdabot> class  (Eq a, Show a) => Num a  where
20:29:41 <lambdabot>     (+), (-), (*)           :: a -> a -> a
20:29:41 <lambdabot>     negate, abs, signum     :: a -> a
20:29:41 <lambdabot>     fromInteger             :: Integer -> a
20:30:47 <oerjan> in Haskell, 3 can be used for any type that is an instance of Num.  It acts as an abbreviation of fromInteger (3 :: Integer)
20:31:11 <Figs> I guess
20:31:16 <oerjan> (slightly circular definition there.)
20:31:41 <SamB> presumably, the latter is in a language where all integer literals are Integers ;-)
20:32:20 <sorear> nah, just make it S# 3# :)
20:32:29 <oerjan> and if you want to define a new number type, you can make it do the same by writing your own instance Num YourType declaration.
20:33:11 <Figs> hmm
20:33:14 <SamB> sorear: hah
20:33:24 <Figs> this is a lot like how I wrote my regex library
20:33:26 <Figs> in C++
20:33:44 <oerjan> yes, classes are Haskell's way of doing overloading.
20:33:48 <SamB> sorear: so... what does it look like when I have 0x500000000 :: Complex Double ?
20:34:04 <dons> some say type classes are the most innovative feature of haskell
20:34:12 <SamB> dons: aren't they?
20:34:28 <dons> maybe they are. esp. given say, indexed type families
20:34:51 <SamB> they are the foundation of all of our neatest gadgets, you know, dons ;-)
20:35:06 <sorear> SamB: J# 2# ((\(UArray x _) -> x) listArray (I# 0, I# 1) [ I# 0, I# 5 ])
20:35:08 <dons> that's right. and they're pretty simple.
20:35:20 <sorear> add # after those literals
20:35:26 <SamB> simple stuff like that is hard work to find ;-)
20:35:50 <SamB> sorear: ... listArray?
20:35:53 <SamB> seriously?
20:36:09 <sorear> SamB: what about it?
20:36:17 <sorear> SamB: notice my unpacking lambda
20:36:33 <sorear> SamB: it's the easiest way to get a ByteArray#
20:36:46 <dons> pretty evil.
20:36:59 <SamB>   lit_a1d6 =
20:36:59 <SamB>     fromInteger_a1fh
20:36:59 <SamB>       (GHC.Num.plusInteger
20:36:59 <SamB>          (GHC.Num.S# 10) (GHC.Num.timesInteger (GHC.Num.S# 10) (GHC.Num.S# 2147483647)));
20:37:05 <dons> and its relying on some coerce in there, isn't it?
20:37:24 <SamB> that's what ghci -ddump-ds tells me
20:38:30 <sorear> yow!
20:38:37 * SamB wonders how unsafeCoerce# got in here...
20:38:53 <sorear> there is no unsafeCoerce# in core
20:39:15 <sorear> it is unfolded by the desugarer into `cast` (:CoUnsafe @ foo ~ bar)
20:39:23 <dons> in the head.
20:39:42 <dons> i.e. it even gets an embedding in the type now. how nifty
20:41:31 <dibblego> executing xs !! n where xs is a bunch of thunks - does it run faster next time around?
20:41:54 * SamB wonders why GHCi seems to be doing "return [unsafeCoerce# it :: ()]"
20:42:51 <sorear> dibblego: yup
20:43:10 <sorear> SamB: GHCi is evil
20:43:26 <dons> it'll force the spine anyway, which'll stay forced.
20:43:46 <SamB> dons: got any ideas why it does such strange things?
20:43:49 <dons> still, !! and concerns about speed, usually mean the wrong structure is being used.
20:43:54 <sorear> dibblego: well, it depends on how trivial the thunks are.  in all (?  in any case, for a very very long time) versions of ghc, everything is a thunk
20:44:01 <dons> SamB: isn't that for the printing ?
20:44:08 <dons> ghci's prompty thing is weird
20:44:14 <dons> its a funny monad all of its own
20:44:22 <SamB> it is like this...
20:44:35 <sorear> the T in STG means that everything is a thunk
20:44:41 <SamB> print it >> return [unsafeCoerce# it :: ()]
20:44:56 <sorear> (only one type of object - the thunk - so we can get away with Tagless ness)
20:44:58 <SamB> sorear: not in the usual sense
20:45:04 <dibblego> > let xs = map (+2) [1..10] in xs !! 5 -- map was called once or twice?
20:45:06 <lambdabot>  8
20:45:10 <SamB> they are all enterable, sure
20:45:26 <sorear> funny, once upon a time indirect calls were faster than conditional branches.
20:45:41 <sorear> ghc would become rather faster if retargeted to a tagful AM
20:45:43 <SamB> sorear: that is a bit odd
20:45:48 <sorear> istr that's a soc project
20:46:09 <SamB> that would explain JHC's way of doing things rather nicely
20:46:13 <oerjan> dibblego: once
20:46:21 <dibblego> of course
20:46:53 <oerjan> (unless you count recursion)
20:48:09 <sjanssen> sorear: is http://research.microsoft.com/~simonpj/papers/ptr-tag/index.htm related?
20:48:10 <lambdabot> Title: Faster laziness using dynamic pointer tagging
20:48:17 <sorear> sjanssen: that's it
20:48:46 <dons> sorear: want a small project (1 day at most)?
20:48:51 <dons> but with good visibility?
20:49:12 <sorear> dons: hehe, sure.  until I can get ahold of shapr SHC is stalled
20:49:22 <dons> ok. you know darcs-graph?
20:49:26 <sorear> yeah
20:49:55 <dons> i'd like to either have a separate tool, or a flag to darcs-graph, to break down the commits by author, and render as a pie chart in .png form
20:49:59 <dons> like so, http://www.cse.unsw.edu.au/~dons/images/xmonad-extentsions-contrib-07-06-21.png
20:50:01 <lambdabot> http://tinyurl.com/2geaq6
20:50:16 <dons> to do that one i used 'piechart.c' and libplot  (gnu lib)
20:50:19 <dons> gnuplot doesn't do piecharts
20:50:28 <dons> but ... there must be some way to get this into darcs-graph
20:50:42 <sorear> ouch.
20:50:56 <sorear> autogenerating your Map would probably need strong ai
20:51:05 <dons> hmm?
20:51:07 <sorear> since there is no sorear in the world of e-mail
20:51:14 <dons> heh
20:51:14 <sorear> how did you convert stefanor?
20:51:22 <dons> i used some AI
20:51:32 <dons> ignoring that, you'd take the output of darcs --xml
20:51:40 <dons> | sed | sort | uniq -c | sort -nr
20:51:46 <dons> that becomes the input to piechart
20:51:49 <SamB> sorear: AI?
20:51:54 <SamB> what about your Real Name?
20:52:01 <SamB> er. Realname.
20:52:01 <dons> but.. can you think of a nice way to do this directly in darcs-graph, without needing say, libplot or piechart/
20:52:14 <sorear> dons: or coreutils! :)
20:52:22 <dons> or coreutils
20:52:39 <dons> darcs-graphs nifty commit plot rate comes from just reading _darcs/patch/* for example
20:52:57 <dons> http://www.cse.unsw.edu.au/~dons/images/commits/community/ghc-commits.png
20:52:59 <lambdabot> http://tinyurl.com/2yawtw
20:52:59 <dons> for example
20:52:59 <sorear> oh, it can't call darcs?
20:53:03 <dons> so it should be similarly as light
20:53:08 <dons> well, if you can do it without that'd be good
20:53:13 <sorear> methinks --xml + HaXml would be really cool :)
20:53:31 <dons> yes, if you want to go that route, i think darcs-piegraph as a separate tool
20:53:59 <dons> a separate tool could even depend on libplot
20:54:09 <dons> and call piechart.c, to make it really easy
20:54:20 <dons> but you might have fun generating vector graphics pie charts by hand.
20:54:42 <dons> ideally it would work for remote repos
20:54:43 <sorear> @google haskell graph
20:54:45 <lambdabot> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
20:54:45 <lambdabot> Title: Functional Graph Library/Haskell
20:54:46 <dons> like darcs-graph does now
20:54:51 <sorear> @google haskell graphing
20:54:52 <lambdabot> http://web.engr.oregonstate.edu/~erwig/fgl/haskell/
20:54:52 <lambdabot> Title: Functional Graph Library/Haskell
20:54:52 <dons> nha, its the 'charts' lib i think
20:54:57 <sorear> @google haskell charts
20:55:00 <lambdabot> http://www.dockerz.net/software/chart.html
20:55:00 <lambdabot> Title: A haskell chart library
20:55:29 <sorear> mmm.
20:55:43 <dons> the main problem with libplot and piechart.c is that its non standard
20:56:02 <dons> so if it could be self contained, or use only cabalised libs, or std C libs ,that'd be good
21:06:09 <sorear> dons: how do you want us ranked?
21:06:17 <sorear> dons: cardinality of patches?
21:06:20 <sorear> count
21:06:25 <sorear> s/^/er, /
21:07:03 <bos> edit distance from "sorear"
21:07:35 <sorear> bos: good idea ... :)
21:07:39 <dons> sort | uniq -c | sort -rn
21:07:50 <dons> so yes, to start with, patch count
21:07:55 <dons> but then you could think about lines of code
21:08:12 <dons> #          piechart.c   http://www.cse.unsw.edu.au/~dons/data/piechart.c
21:08:12 <dons> #          gnu plotutils-2.5
21:08:14 <dons> btw
21:08:40 <kombinator> what is the opposite of opaque datatypes?
21:09:21 <sorear> kombinator: transparent
21:09:26 <bos> sexy types!
21:09:53 <kombinator> thanks
21:14:23 <bos> damn norman walsh and all of his slithering sgml works.
21:15:17 <bos> i used a cross reference to an exercise in a chapter of the book. it broke john's build. his fix broke my build.
21:15:35 <bos> docbook makes me grumpy.
21:15:38 <sorear> john... goerzen?
21:15:40 <dons> :(
21:15:46 <bos> sorear: yep
21:15:53 * sorear automatically assumes meacham
21:16:08 <dons> bos, and i shouldn't even start how hard it is to get docbook going on *bsd. an infinite tower of reflective sgml interpreters
21:16:33 <bos> sorry for your troubles, dons.
21:16:38 <sorear> bos: so what are you using?  lhs2TeX ? :)
21:16:48 <dons> hehe. no, what doesn't kill my laptop, makes it stronger.
21:16:50 <sorear> hello_: hello!
21:16:57 <bos> sorear: oh, you don't even want to go there.
21:17:10 <bos> docbook has no support for presentation-oriented markup.
21:17:17 * sorear thought he liked lhs2TeX :)
21:17:46 * bos doesn't really like writing lhs
21:18:21 <sorear> what's not to like...?
21:18:22 <bos> mind you, it's a mild dislike. not like the throbbing docbook induces in my forehead.
21:18:43 <bos> it's hard to syntax-colour effectively, so it's hard to visually scan for code.
21:19:13 <bos> i like my angry fruit salad of syntax colouring.
21:19:15 <sorear> vim does it just fine :)
21:19:22 <bos> :p
21:19:25 <sorear> > 2 + 2  -- renders!
21:19:28 <lambdabot>  4
21:21:08 <bos> emacs's psgml-mode is the only bright light in my docbook firmament.
21:21:33 <hello_> Hi, I'm writing a data analysis program in Haskell, but a routine that appears to be tail recursive is instead resulting in a stack overflow, even with a 100MB stack allocation (compiled using GHC 6.6.1).  I've tried using the $! operator, but it did not seem to help the situation (perhaps I'm not using it correctly).  Any ideas on how I might debug this problem, or anyone bored and interested in taking a look at the code (it's fairly short)?
21:21:54 <bos> ah, tail recursive loops usually explode in your face.
21:22:11 <hello_> What would you recommend instead?
21:22:13 <bos> hello_: post it to http://hpaste.org/new
21:22:14 <sorear> hello_: if it's less than 5K and you don't mind sharing pass it to hpaste
21:22:35 <bos> everybody loves solving space leaks around here.
21:23:01 <sorear> hello_: tail recursion isn't what you think it is in haskell, laziness turns everything upside down
21:23:09 <sorear> @src map -- this is tail recursive
21:23:09 <lambdabot> Source not found. My mind is going. I can feel it.
21:23:15 <sorear> @src map            -- this is tail recursive
21:23:16 <lambdabot> Source not found. stty: unknown mode: doofus
21:23:19 <sorear> @src map
21:23:19 <lambdabot> map _ []     = []
21:23:19 <lambdabot> map f (x:xs) = f x : map f xs
21:23:30 <sorear> @src foldl
21:23:30 <lambdabot> foldl f z xs = lgo z xs
21:23:31 <lambdabot>     where lgo z []     =  z
21:23:31 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
21:23:33 <sorear> ^ that isn't
21:24:00 <sorear> hello_: coming from a sml/lisp background you would expect the opposite behavor from those two...
21:24:14 <dons> typical solutions to space leaks are to ensure arguments to recursive functions are strict:   f x = ... f $! x+1
21:24:23 <hello_> I see.  Are there any papers you recommend to get a better understanding of Haskell's memory usage?
21:24:25 <dons> this can be done with bang patterns too now, -fbang-patterns
21:24:29 <hello_> Yes, I tried $!
21:24:30 <dons> f !x = ... f (x+1)
21:24:46 <dons> hello_: you need to ensure its adding strictness hints to the correct argument, of course.
21:25:04 <dons> hello_: if the problematic function is small, paste it to hpaste.org
21:25:06 <hello_> Let me try posting it to hpaste; the only thing is, it needs a data file to run it on.
21:25:16 <bos> that's fine. just reading the code is often enough.
21:25:19 <sorear> hello_: usually we can infer that fine, we're human :)
21:25:24 <hello_> It's 3 modules, but overall the code is less than 5KB
21:25:29 <sorear> hello_: also, while you can write strict tail recursive loops in haskell it isn't (usually) good style
21:25:48 <dons> sorear: i dispute that :-)
21:25:54 <hello_> Oh, I understand, I was just trying to get it to work at all in the first place.
21:26:01 <sorear> hello_: Certainly.
21:29:14 <hpaste>  hello_ pasted "GainsMain.hs" at http://hpaste.org/355
21:31:36 <hello_> When I run this, it gets part of the way through calculating and writing the output, and then ends with a stack overflow.  For one thing, I'm not sure whether I'm using $! correctly; but moreover, I'd also like to know a way to write it without resorting to that.
21:33:37 <bos> well, there are a few potentially problematic looking bits of code.
21:33:49 <hello_> Ok, which parts?
21:34:22 <sorear> maxGains is an instance of zipWith
21:34:26 <sorear> @src zipWith
21:34:26 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
21:34:26 <lambdabot> zipWith _ _      _      = []
21:34:59 <dcoutts__> dons: I'm splitting the .Base module into .Internal and .Unsafe
21:35:07 <dcoutts__> I'm wondering what to do with:
21:35:08 <dcoutts__> -- | Construct a ForeignPtr from a Ptr Word8, with a free(3) finalizer
21:35:08 <dcoutts__> -- attached.
21:35:08 <dcoutts__> newForeignFreePtr :: Ptr Word8 -> IO (ForeignPtr Word8)
21:35:24 <dons> dcoutts__: hmm. do we use that outside?
21:35:38 <dons> probably should be in base though
21:35:38 <dcoutts__> dons: dunno, it's currently exported from .Base
21:35:45 <sorear> dcoutts__: smells more of low-level than unsafe
21:35:54 <bos> hello_: mean and functions that call it look a bit expensive
21:36:03 <dcoutts__> sorear: yeah
21:36:10 <oerjan> no it is not quite zipWith. lo is passed to maxGain.
21:36:11 <dons> hello_: also, your $! to force lists doesn't really do anything
21:36:17 <dcoutts__> dons: it's used in some other internal thing
21:36:22 <dons> the lists are only evaluated to their outermost cons node
21:36:28 <hello_> I see
21:36:32 <bos> all of the ListOps code looks fishy, in fact.
21:36:53 <dons> column n m = map (\r -> r !! n) m
21:36:58 <dcoutts__> dons: it's a really simple function too
21:36:58 <dons> for example, !! is O(n)
21:37:00 <dcoutts__> newForeignFreePtr p = newForeignPtr c_free_finalizer p
21:37:04 <bos> it's not "wrong", but it looks like there will be lots of unnecessary computation done.
21:37:10 <dcoutts__> dons: I don't see why it needs to be exported at all
21:37:22 <hello_> dons: Oh, I'm aware of that, I just wasn't sure of another way to go about it.
21:37:27 <dcoutts__> I'm included to not export it
21:37:39 <dons> dcoutts__: ok. i can't see an obvious reason either way
21:37:52 <sorear> hello_: I'd suggest using an application-specific data type
21:37:58 <dons> hello_: do you have a profiling trace of the misbehaving function?
21:38:07 <dons> hello_: ghc -O2 -prof -auto-all, to identify where it goes wrong.
21:38:13 <hello_> Let me try that.
21:38:19 <bos> this code is a little too involved to be amenable to eyeballing.
21:38:20 <dons> (but yes, a better-suited data structure than lists might be a good idea in the end)
21:38:31 <dcoutts__> ok, it's gone!
21:38:31 <dons> what was that recent CSV library posted a couple of days ago?
21:38:39 <sorear> dons: the code doesn't work
21:38:40 <bos> hello_: then run with myprogram +RTS -p -RTS
21:38:44 <sorear> dons: 21:30 < hello_> When I run this, it gets part of the way through calculating and writing the output, and then ends with a stack overflow.  For one thing, I'm not sure whether I'm using $! correctly; but
21:38:50 <sorear> +RTS -xc
21:39:14 <sorear> hello_: also try +RTS -xc -RTS   .. that will (if the stars are right) give you a backtrace
21:40:22 <xpika> how do i generate haddock documentations?
21:40:38 <xpika> from a haskell tarball
21:41:00 <sorear> haskell tarball?
21:41:09 <sorear> you'll need to unpack it first :)
21:41:19 <xpika> a source file with setup.hs
21:41:38 <sorear> runghc Setup.*hs configure
21:41:43 <sorear> runghc Setup.*hs haddock
21:41:52 <xpika> sorear: I'll try that
21:42:43 <shachaf> sorear: Is just "runghc Setup" not recommended?
21:42:56 * shachaf has been using that in his alias.
21:43:01 <sorear> shachaf: I had no clue it worked!
21:43:01 <sorear> :)
21:43:46 <xpika> Setup: No command given (try --help)
21:43:56 <shachaf> xpika: With and argument.
21:44:07 <xpika> oh, you were reffering to just omitting the extension
21:44:15 <shachaf> xpika: Yes. :-)
21:46:02 <xpika> either way i get an error
21:47:03 <xpika> "dist\\build\\tmp\\Data\\Html\\TagSoup.hs": 133:1: parse error in doc string: [TokSpecial '"',TokString " if no attribute present.\n"]
21:47:27 <sorear> xpika: that means ndm messed up
21:48:02 <sorear> xpika: haddock parse errors are best fixed by submitting patches
21:49:17 <xpika> :)
21:49:31 <xpika> Data.Binary generated alright :)
21:49:49 <xpika> is there any library which converts a haskell source file in to a tree of tokens?
21:50:54 <bos> Language.Haskell.Parser
21:50:58 <sorear> how do you want your tree structured?
21:51:19 <sorear> Language.Haskell.Parser produces an AST
21:52:32 <hello_> Thanks for your help, this turned out to be the culprit: "bt = if rann < bestRatio then t else bt".  I didn't realize the where binding was a let rec, and this sort of usage would be a static error in OCaml.
21:53:29 <goltrpoat> -nod- let=letrec in haskell
21:53:45 <xpika> > parseModule "n = 3\nmain = print 1\n"
21:53:46 <lambdabot>   Not in scope: `parseModule'
22:04:31 <dons> hello_: ah !
22:04:44 <dons> hello_: hehe. phew.
22:07:07 <goltrpoat> can someone explain to me what that eureka3d guy is saying this time
22:07:25 <goltrpoat> (the "programmer paradigms and programmer audiences" thing on reddit)
22:07:27 <edwardk> goltrpoat: ?
22:07:36 <edwardk> ah checking
22:07:46 <dons> heh goltrpoat
22:07:53 <sorear> hello goltrpoat
22:07:55 <dons> its 'decode mystery reddit comment' time again, is it? :-)
22:07:57 <goltrpoat> hey sorear
22:08:06 <goltrpoat> dons:  well, it's a whole post this time :)
22:08:08 <sorear> goltrpoat: is your haskell compiler done yet? :)
22:08:23 * sorear has finally started SHC
22:08:37 <dons> sorear: SHC is already taken!
22:08:45 <dons> that's Andy Gill's Snowball Haskell Compiler
22:08:55 <goltrpoat> sorear:  no, i do have a typechecker though.  i'm getting close, there's a core to G-machine compiler, and the frontend is close to done.
22:08:55 <dons> circa 1998 or so. (?)
22:09:03 <goltrpoat> been pretty busy with contract work as of late though
22:10:11 <edwardk> heh are you sure that was written by a person and it wasn't just a random sequence of programmer rants jumbled all together?
22:10:12 <dons> sorear: http://72.14.253.104/search?q=cache:wBPlB-ngbQkJ:www.unsafeperformio.com/projects.html+Snowball+Haskell+Compiler&hl=en&ct=clnk&cd=3&gl=au
22:10:13 <lambdabot> http://tinyurl.com/32xtpf
22:10:21 <sorear> saw it. google++
22:10:22 <dons> sorear: (seems unsafeperformio.com is abandoned now?)
22:11:05 <dons> we should try to get the source online
22:12:18 <dons> "Personally I find bondage and discipline languages to be best suited to the real world."
22:12:26 <goltrpoat> edwardk:  it's some gamedev guy who spent the past year detailing his uh.. journey.  now he's posting language rants apparently.
22:12:43 <goltrpoat> i'd be fine with it if it had any actual point to it.
22:12:48 <goltrpoat> as it is, i stand confused.
22:12:52 <dons> goltrpoat: so yeah, strange journey.
22:13:10 <dons> `Javascript - Sure itso the type of gpu expressions is s Lispy.' ??!
22:13:16 <dons> its lispy.
22:13:34 <dons> oh, embedded ^Y, expansion. bizarre
22:13:41 <goltrpoat> hehe
22:14:08 <dons> goltrpoat: so i'm not sure this guy has a point :-)
22:14:22 <dons> sort of a 'learn some different paradigms' post/
22:14:54 <sorear> dons: qhc haskell doesn't find anything on google.  i'll take it.
22:16:29 <sjanssen> sorear: where 'q' means?
22:16:47 <sorear> sjanssen: nothing :(
22:17:07 <dons> quality?
22:17:11 <dons> quackery?
22:17:18 <sjanssen> quackery++
22:17:28 <desp> "Record update for the non-Haskell-98 data type `Foo' is not (yet) supported"
22:17:39 <sorear> desp: Indeed the case.
22:17:48 <desp> that makes me sad.
22:17:57 <sorear> desp: This is what GHC HQ gets for running the typechecker before the desugarer! :)
22:18:04 <desp> :)
22:18:20 <sorear> there are just too many cases to handle.
22:18:42 <sorear> apparendly the simons got tired and gave up.  all for the sake of meaningful error messages :)
22:23:13 <dons> well, the other side is having type errors in terms of Foo @ (CoUnsafe x ~ y) :}
22:24:48 <sorear> also you'd need two desugarers ... since some of the dsing is type-directed (cf classes)
22:27:59 <dons> "and C++ programmers with symptoms of the Stockholm syndrome".
22:28:15 <dons> hmm, is there a blog in general about language communities and  Stockholm syndrome
22:29:10 <sorear> what is stockholm syndrome...
22:29:17 * sorear doesn't remember that
22:29:36 <TSC> Falling in love with captor
22:29:44 <dons> captives start to identify with, and love, their captor.
22:29:51 <dons> hostages, in particular
22:30:17 <dons> you are a hostage to the type system! you will be disciplined!
22:30:22 <dons> i love you mr. type checker.
22:30:39 <TSC> Ooh yeah, reject my program, you strict compiler
22:31:18 <dons> "Stockholm syndrome is a psychological response sometimes seen in an abducted hostage, in which the hostage shows signs of loyalty to the hostage-taker, regardless of the danger (or at least risk) in which the hostage has been placed."
22:33:56 <desp> @remember TSC Ooh yeah, reject my program, you strict compiler
22:33:56 <lambdabot> Done.
22:39:06 <Figs> what does case do?
22:39:22 <Thomas2> lots
22:39:34 <jcreigh> pattern matching
22:39:40 <Thomas2> yeah, that
22:39:50 <Thomas2> it's how you get at the contents of a constructor type
22:41:53 <quicksilver> it is, in a  sense, the converse of constructors; it's how you unpack a data type packed together by constructors
22:41:55 <sorear> @flush
22:42:10 <sorear> Case is the polymorphic deconstructor.
22:42:30 <quicksilver> dons: I don't think I understand this O(1) append thing in the presence of lazy eval (ob DList)
22:42:42 <quicksilver> dons: isn't (++) O(1), in a lazy language?
22:43:10 <bos> uh, what?
22:43:16 <jcreigh> quicksilver: no
22:43:30 <quicksilver> (++) doesn't do any work, at the time you call it
22:43:30 <sjanssen> quicksilver: nah, it has to look at and create O(n) cons cells
22:43:45 <quicksilver> it just makes a thunk
22:43:51 <jcreigh> quicksilver: well, by that definition, everything is O(1)
22:43:51 <quicksilver> and that thunk is a good producer
22:44:05 <bos> well, that's not a useful way to look at it.
22:44:22 <quicksilver> hence, my initial comment 'I don't think I understand' :)
22:44:52 <quicksilver> my argument was: the only thing you can do with a (++) expression is traverse it
22:44:59 <quicksilver> if you traverse it, it's O(n)
22:45:08 <quicksilver> but traversing was always going to be O(n)
22:45:15 <quicksilver> so how is it worse?
22:45:17 <aspo> so are guards and multiple function declarations with different patterns just syntactic sugar for case?
22:45:27 <sjanssen> aspo: exactly
22:47:23 <sjanssen> quicksilver: even though operations might be deferred for some time, you still need to count them if they happen
22:48:07 <lispy> did someone compare me to javascript?? /me faints in disgust ;)
22:48:17 <aspo> more on syntactic sugar
22:48:35 <aspo> fibs1 = 0:1:[a+b | (a, b) <- zip fibs1 $ tail fibs1]
22:48:38 <cdsmith> lispy: ha!
22:48:43 <aspo> fibs2 = 0:1:(map (uncurry (+)) (zip fibs2 $ tail fibs2))
22:48:57 <aspo> is there any difference between those two definitions?
22:49:03 <lispy> > fix $ \fibs -> 1 : 1 : zipWith (+) fibs (tail fibs)
22:49:09 <lambdabot>  [1,1,2,3,5,8,13,21,34,55,89,144,233,377,610,987,1597,2584,4181,6765,10946,17...
22:49:15 <sjanssen> aspo: no
22:49:20 <aspo> is there a reason besides code clarity to use one or the other?
22:49:35 <aspo> oohh, zipWith
22:49:41 <aspo> i should know that function by now
22:50:06 <aspo> ?src zipWith
22:50:06 <lambdabot> zipWith f (a:as) (b:bs) = f a b : zipWith f as bs
22:50:06 <lambdabot> zipWith _ _      _      = []
22:50:18 <lispy> zip = zipWith (,)
22:50:26 <quicksilver> sjanssen: let me try another line of argument. trick like DList mean you do no work at append time. But ultimately when you call 'toList' you do have to copy the cons cells
22:50:37 <quicksilver> similarly, though, (++) does no work at append time, in a lazy language
22:50:47 <quicksilver> when you actually traverse (if you do) it copies the cons cells too
22:50:58 <quicksilver> so, what's the difference?
22:51:51 <bos> augh, docbook. gnaaaurgh.
22:52:14 <cdsmith> quicksilver: if you append to something n times, then it's O(n) to access just the first element of the resulting list.
22:52:21 <syntaxfree> random batshit information about my psychiatric diagnoses about to start in #haskell-blah in 20 seconds.
22:52:46 <sjanssen> quicksilver: there are cases where a sequence of appends for dlists and [] have the same time complexity
22:53:35 <oerjan> quicksilver: consider foldl (++) [] [[i]|i <- [0..1000000]]
22:53:57 <sjanssen> quicksilver: (++) does no work immediately, but it does require work (linearly proportional to the first argument) to be done later
22:56:30 <quicksilver> cdsmith: yes, but that's consistent with append being O(1)
22:56:43 <quicksilver> cdsmith: "if you append n times" so you have n * O(1)
22:56:54 <oerjan> traversing that would actually be quadratic, i think
22:57:05 <dcoutts> yep
22:57:28 <cdsmith> quicksilver: But getting the second element would also be O(n), etc... so by that method of accounting you have O(1) append but O(n^2) list traversal.
22:57:34 <aspo> quicksilver, what if you are appending n^2 times where n is some variable
22:57:45 <aspo> that's not o(n)
22:57:53 <aspo> err
22:57:54 <aspo> O(1)
22:58:15 <aspo> so n * O(1) is O(n) with respect to n
22:58:22 <cdsmith> quicksilver: or, you can account for the extra work as a delayed append, in which case you have n * O(n) for appends and O(n) traversal.
22:58:23 <quicksilver> cdsmith: ah, maybe that's the bit I'm missing....
22:58:59 <quicksilver> although (++) fuses, doesn't it? so in the presence of a good consumer, (++) is free?
22:59:07 <quicksilver> (and a good optimiser)
22:59:18 <cdsmith> quicksilver: that I don't know.
23:01:59 <sjanssen> hmm
23:02:34 <bos> (++) could only be O(1) if it knew that the unconcatenated list would never be used again.
23:02:41 <bos> where "it" is the compiler.
23:05:16 <quicksilver> bos: yes
23:05:20 <quicksilver> bos: good point
23:05:31 <quicksilver> maybe the bit that's confusing me is I'm only thinking of one use of (++)
23:05:45 <bos> that's very sequential thinking :-)
23:05:45 <quicksilver> if you only use it once, then it won't change your asymptotic complexity
23:05:46 <jfredett> hmm, I think I broke ghci
23:06:01 <jfredett> its talking about unused opcodes
23:06:10 <quicksilver> the problem comes if you use (++) itelf O(n) times
23:06:26 <sjanssen> using it even once costs O(n)
23:06:31 <quicksilver> then you "wrap your thunks O(n) deep"
23:06:36 <sjanssen> O(n) wrt. the first argument
23:06:45 <quicksilver> sjanssen: yes, but only if you ever use the list; and if you ever use the list, you are O(n) anyway
23:06:52 <quicksilver> sjanssen: so it hasn't made things worse
23:06:56 <sjanssen> quicksilver: that is dangerous thinking
23:07:09 <sjanssen> this is probably how you became confused in the first place
23:07:27 <cdsmith> sjanssen: how so?  That thinking seems fine to me.
23:08:29 <bos> maybe he left out a comma
23:08:35 <bos> "that is dangerous, thinking"
23:08:46 <sjanssen> in this one case (traversing the result of ms ++ ns), the O(m + n) cost dwarfs the O(m) cost of the append
23:09:27 <sjanssen> so you can forget about the O(m) in this one case
23:09:40 <sjanssen> but forgetting it in other cases breaks your analysis
23:10:41 <cdsmith> sjanssen: Okay; I agree with all that, but still don't see how analyzing this case in this way is dangerous.
23:10:44 <cdsmith> Probably best to drop it.
23:12:34 <aspo> consider: ([1] ++ [2] ++ [3]) !! 2
23:12:59 <aspo> then think of the conses you have to do
23:13:12 <aspo> traversing to get the third element
23:13:54 <cdsmith> aspo: do you mean (([1] ++ [2]) ++ [3]) !! 2?  Or what you said?  They make different points.
23:13:56 <quicksilver> sjanssen: yes, I understand your comment
23:14:22 <aspo> do they?
23:14:27 <aspo> how so?
23:14:31 <quicksilver> although I submit that aspo's example is fusible
23:14:36 <quicksilver> because the lists are not used again
23:15:02 <aspo> oh do I have my associtivity wrong?
23:15:07 <cdsmith> aspo: Concatenating and traversing your list should be O(n) overall.
23:15:25 <quicksilver> ++ is right associative by design
23:15:28 <aspo> ahh
23:15:31 <sjanssen> I believe that a fully fused version of aspo's example will twist things around such that you lose the quadratic behavior
23:15:32 <quicksilver> because that keeps the longer list on the right
23:15:34 <aspo> sorry, I'm new at this stuff
23:16:03 <quicksilver> sjanssen: this is interesting, in that a good fusion algorithm can take you from O(n^2) to O(n)
23:16:10 <quicksilver> sjanssen: instead of merely improving a constant
23:16:16 <sjanssen> yeah
23:16:21 <sjanssen> I might be wrong, though
23:16:22 <quicksilver> that's not a posibility I'd thought of before
23:16:41 <sjanssen> actually, it makes sense
23:16:54 <sjanssen> the work that foldr/build does is very much like the DList transformation
23:20:02 <cdsmith> I guess I should sleep; I have a meeting with my boss in less than eight hours. :)
23:22:47 <dons> consecutive ++'s usually fuse
23:22:56 <dons> its a good idea, reducing complexity :-)
23:23:08 <dons> though you have to be careful
23:29:10 <sorear> dons: do we have a {-# RULES "++/++" forall a b c. (a ++ b) ++ c = a ++ (b ++ c) #-} or similar?
23:31:01 <dons> not for regrouping, i think.
23:31:26 <dons> "++"    [~1] forall xs ys. xs ++ ys = augment (\c n -> foldr c n xs) ys
23:31:58 <dons> but once you've got it in augment/foldr form, off you go.
23:32:12 * sjanssen is doing that derivation right now ;)
23:32:18 <dons> foldr k z (augment g xs) = g k (foldr k z xs)
23:32:28 <dons> augment g (build h) = build (\c n -> g c (h c n))
23:47:39 <sorear> stupid question: are jose` iborra and pepe iborra the same person?
23:50:50 <dons> not sure i know jose iborra
23:51:40 <sorear> he's credited as a major developer of the ghci debugger in SimonM's paper
23:52:02 * sorear thinks to check the web
23:52:21 <sorear> WP: Pepe is a nickname for any person called Jos,
23:52:40 <dons> oh, didn't know that.
23:52:52 <dons> mnislaih refers to himself as pepe, iirc.
23:54:19 <hpaste>  sjanssen pasted "(xs ++ ys) ++ zs fuses well" at http://hpaste.org/356
23:54:28 <sjanssen> quicksilver: ^^^
23:55:03 <dons> very nice sjanssen
23:55:18 <goltrpoat> cool.
23:55:52 <dons> sjanssen: you should check the lengths we go to to ensure ++ works with stream fusion... :-)
23:55:56 <quicksilver> sjanssen: nice
23:56:44 <sjanssen> oops, except I got it wrong :(
23:56:48 <dons> grep for `This is quite subtle' in Data.List.Stream
23:57:23 <quicksilver> I asked jaffacake the other day about RULES for re-associating asociative operators
23:57:32 <quicksilver> he seemed to think it was pretty tricky
23:57:53 <quicksilver> if you do it right, you can make 'naive factorial' run in constant space
23:58:15 <hpaste>  s pasted "x11_extras" at http://hpaste.org/357
23:59:30 <dons> who's the author of that paste ^^ ?
23:59:39 <stevan> that would be me :)
23:59:55 <stevan> i was just going to say it fails on me.
23:59:55 <dons> that error usually means the path to xinerama wasn't set properly
