00:38:58 <cinimod> @seen dons
00:38:58 <lambdabot> dons is in #xmonad, #haskell-soc and #haskell. I last heard dons speak 22m 37s ago.
00:39:48 <cinimod> Can someone tell me the status of data.binary?
00:40:09 <cinimod> I know you get ByteString free with ghc now but what about Binary?
00:40:31 <sjanssen> @hackage binary
00:40:32 <lambdabot> http://hackage.haskell.org/cgi-bin/hackage-scripts/package/binary
00:40:47 <sjanssen> cinimod: not included with ghc -- you can grab it there ^^^
00:41:20 <cinimod> sjanssen: thanks. any plans for getBit and putBit or do I roll my own?
00:41:35 <dons> there are plans, but we've not come up with the best way yet
00:42:51 <whitenoyce> difficulties with white space
00:43:01 <whitenoyce> why do i need 10 spaces after starting a do block or else i get
00:43:07 <whitenoyce>     The last statement in a 'do' construct must be an expression
00:44:15 <whitenoyce> this is very stressful
00:44:34 <whitenoyce> 11 spaces no, 9 no, 8 no, tab no, 2 tabs no
00:44:37 <whitenoyce> 10 spaces yes
00:44:46 <whitenoyce> main = do args <- getArgs
00:44:46 <whitenoyce>           putStrLn ("Hello, " ++ args !! 0 ++ " " ++ args !! 1)
00:44:58 <whitenoyce> exactly ten spaces to putStrLn
00:45:31 <whitenoyce> why isn't tab working?
00:46:28 <cinimod> dons: IIRC NewBinary had a way of doing this. Can't you just copy?
00:47:42 <kfish> whitenoyce, http://haskell.org/tutorial/patterns.html#sect4.6
00:47:42 <lambdabot> kfish: You have 1 new message. '/msg lambdabot @messages' to read it.
00:47:43 <lambdabot> Title: A Gentle Introduction to Haskell: Patterns
00:49:10 <kfish> whitenoyce, http://haskell.org/onlinereport/syntax-iso.html#layout
00:49:10 <lambdabot> Title: Haskell 98 Syntax
00:49:14 <dons> cinimod: its a very different library. the idea though, would be similar. we plan to support bit access soonish
00:49:32 <dons> but don't want to compromise speed to do it, the preferred idea is via a bit-level monad transformer
00:49:46 <dons> that would layer a bit access strategy over the current code
00:50:09 <DRMacIver> ?where arrows
00:50:09 <lambdabot> http://www.haskell.org/arrows/
00:50:19 <cinimod> dons: what should I do for now? State monad with getWord8 / putWord8?
00:50:43 <dons> yep, something like that.
00:51:05 <dankna> Hm.  Will I be duplicating anyone else's work if I figure out how to get c2hs to cough up a binding to Apple's Carbon?
00:51:12 <cinimod> ok but I don't want to re-invent wheels
00:51:16 <dankna> I'm only starting to read up on how to do it, so it may turn out to be trivial...
00:51:22 <whitenoyce> ah ok i get it
00:51:28 <whitenoyce> kfish, thank you
00:51:28 <whitenoyce> !
00:51:36 <whitenoyce> main = do       args <- getArgs
00:51:36 <whitenoyce>                 putStrLn ("Hello, " ++ args !! 0 ++ " " ++ args !! 1)
00:51:38 <whitenoyce> works
00:52:20 <dons> cinimod: there are no wheels. you'll be the first.
00:52:32 <dons> dankna: hmm. sounds a bit like Mocha/HOC
00:52:43 <dons> dankna: google for those, they were the first serious bindings to cocoa
00:52:50 <dankna> Yeah, I spent two days trying to do stuff with HOC.
00:53:16 <dankna> It's a nice package except there are things that are just plain unimplemented... essential ones for nontrivial programs, like init methods and calling superclass methods.
00:53:22 <DRMacIver> (Of course, I bet by the time I've understood arrows, someone will tell me "Oh, we don't use arrows any more. We've generalised them to chipmunks.")
00:53:35 <dankna> It might be that if I weren't so new to Haskell as well, I would be able to figure out how to go behind the type system's back.
00:53:47 <dankna> But Carbon is a non-OO API so it should be a lot easier to bind against.... in theory.
00:53:51 <cinimod> dons: ok I may have a look next weekend.
00:53:51 <DRMacIver> You shouldn't go behind the type system's back. ;)
00:54:03 <dankna> Right. :)
00:54:14 <cinimod> I'm finishing off Packed Encoding for integers (ASN.1) at the moment.
01:37:44 <lumi> 08:17 < sorear> Is there a standard symbol for a monad in CT?
01:37:44 <lumi> 08:18 -!- arjanb [i=borganis@borganism.student.utwente.nl] has quit ["bbl"]
01:37:44 <lumi> 08:20 < SamB_XP> Chrono Trigger has monads?
01:39:52 <opqdonut> :D
01:41:17 <lumi> Sorry, mispaste
01:41:31 <opqdonut> fun anyways
01:41:34 <lumi> (I found it amusing and stashed it)
01:41:49 <opqdonut> ?help remember
01:41:49 <lambdabot> quote <nick>
01:41:49 <lambdabot> remember <nick> <quote>
01:41:49 <lambdabot> Quote somebody, a random person, or save a memorable quote
01:42:11 <lumi> ?quote chrono
01:42:11 <lambdabot> SamB says: Chrono Trigger has monads?
01:42:17 <opqdonut> ah
01:42:26 <opqdonut> i was just about to ?remember the whole thing :)
01:43:52 <Jaggederest> @yow start
01:43:53 <lambdabot> RHAPSODY in Glue!
01:44:07 <Jaggederest> sounds about right
01:44:23 <Jaggederest> @paste
01:44:24 <lambdabot> Haskell pastebin: http://hpaste.org/new
01:45:03 <hpaste>  Jaggederest annotated "(no title)" with "More TSP stuff" at http://hpaste.org/189#a3
01:46:17 <Jaggederest> problems: it's too fast, I'm not using the nice permutation code yet, and it's not true hillclimbing yet
01:47:10 <Jaggederest> unless 'evaluate all the possible combinations and find the best one-step change' is hillclimbing.
01:49:32 <dankna> heh, I just noticed ghc jumped from version 6.4.2 to 6.6
01:49:58 <Igel> hello
01:50:05 <dankna> I bet there's a story to that :) oh well, all I need is for it to work.
01:50:06 <Igel> i got quite an ugly problem...
01:50:06 <dankna> ah, hi.
01:50:25 <Igel> is there a way to block a thread?
01:50:40 <Igel> i need to lock it to wait for input from a different thread
01:50:48 <Igel> and then return the results
01:51:19 <Igel> (spawning a gui, where the user asynchronously enters data)
01:53:20 <Igel> its like
01:53:26 <Igel> do -- IO ()
01:53:40 <Igel> dataRef <- newIORef
01:53:55 <Igel> spawnUserThread -- sets dataRef
01:54:10 <Igel> blockUntilDataRefIsSet
01:54:22 <Igel> readIORef dataRef >>= return
01:55:23 <Jaggederest> hmm need dataflow extensions. Oz 'just blocks'
01:57:11 <Igel> might it work using software transactional memory (STM)?
01:57:33 <Igel> i'm not so fit with that, so it might take me an hour finding out ;)
01:57:58 <Jaggederest> yeah I'm not fit with any of this so...heh
02:06:09 <Igel> hey that might work...
02:06:11 <Lemmih> Igel: Use an MVar.
02:08:03 <Igel> Lemmih: does readMVar block?
02:08:24 <Igel> the documentation doesnt say
02:10:19 <Lemmih> Igel: Yes, readMVar block on empty mvars.
02:10:34 <Igel> well thats good news :)
02:10:36 <Igel> thanks
02:10:39 <Lemmih> Igel: And the documentation _does_ say.
02:11:02 <Igel> hmm?
02:11:06 <Igel> oops
02:11:11 <Igel> :]
02:11:22 <Igel> following the link of takeMVar, it does
02:11:26 <Igel> i'm sorry
02:11:31 <Lemmih> No problem (:
02:12:11 <Jaggederest> ah also there's Control.Exception block which is interesting
02:12:41 <Jaggederest> hmm maybe not
02:20:27 <ddarius> dankna: There is no story.
02:21:19 <dankna> yeah, after I said that I figured out that you use the even-number-stable policy
02:21:21 <dankna> which makes sense
02:21:57 <ddarius> whitenoyce: Put a newline immediately after opening a 'do', and, no, being a superlative Haskell programmer does not mean you know all that much about monads beyond how they are used in Haskell.
02:24:40 <Igel> Lemmih, Jaggederest: i just wanted to tell you, i decided for software transactional memory
02:24:54 <Igel> the stms TVar fits best
02:25:13 <Igel> nonetheless thank you^^ :)
02:31:04 <Jaggederest> ok, so this one is a new one: ambiguous type variable 'a' in the constraints 'Read a' and 'Show a'
02:31:28 <Jaggederest> I'm trying to read a file in, parse it, and spit it back out
02:32:29 <Lemmih> Jaggederest: Parse it to what?
02:33:02 <Jaggederest> a list of arbitrary stuff. in this case list of lists of Float
02:33:48 <Jaggederest> distance matrix for the TSP [[0, 1], [1,0]] in the trivial case
02:34:00 <Lemmih> Jaggederest: Well, tell that to your Haskell compiler.
02:34:36 <Jaggederest> hmm so I have to wrap read up and tell it to do right, is all?
02:36:41 <Jaggederest> hmm, interesting, so you do have to specialize it like that. No general IO, I guess :)
02:38:56 <Lemmih> Jaggederest: Well, 'show . read' is problematic.
02:39:39 <Jaggederest> so if I feed it into a typed function (not a -> a) it'll maybe figure it out?
02:41:25 <Jaggederest> hey, readStuff :: String -> [[Float]] readStuff = read works heh silly compiler.
02:41:33 <Jaggederest> thanks Lemmih
02:46:19 <mehrheit> I got this GHC error message: â€žCould not find module `IO': it is a member of package haskell98, which is hiddenâ€œ; fixed by appending â€ž-package haskell98â€œ to cmdline. Shouldn't this be the default?
02:47:07 <Lemmih> mehrheit: How about using System.IO?
02:49:30 <mehrheit> oh, yes. hoogle returned only IO.hFlush after a search for â€žhFlushâ€œ.
02:50:49 <Lemmih> mehrheit: Alternatively, you can use --make to automagically include needed packages.
02:51:46 <mehrheit> don't cabal build scripts do it by default?
02:52:12 <Lemmih> mehrheit: No, not any more. That bug was fixed some time ago.
02:55:35 <mehrheit> why is that a bug?
02:56:18 <Jaggederest> package conflicts, I think
03:42:49 <olsner> why doesn't "instance Enum (Int, Int) where ..." work?
03:43:20 <Cale> olsner: -fglasgow-exts
03:43:51 <cinimod> or data Foo = MkFoo Int Int
03:43:59 <cinimod> instance Enum Foo where ...
03:44:05 <Lemmih> olsner: Enum (a,b) where?
03:44:55 <olsner> glasgow-exts seemed to do it.. but what's up with that? Is (,) some special thing that can't have instances or something?
03:45:04 <DRMacIver> olsner: Haskell 98 doesn't allow you to declare instances for particular values of type parameters, only for all type parameters (possibly bound by a type class). I forget the reasoning.
03:45:29 <cinimod> olsner: you can always create your own datatype as above
03:45:31 <DRMacIver> So (Foo a, Bar b) => Enum (a, b) would be allowed, but (Int, Int) wouldn't.
03:46:00 <olsner> mmkay, so it was specifying Int that didn't work
03:46:36 <DRMacIver> Yes.
03:46:47 <olsner> @pl (\f (x,y) -> (f x, f y))
03:46:47 <lambdabot> (`ap` snd) . (. fst) . (flip =<< (((.) . (,)) .))
03:46:52 <DRMacIver> (Enum a, Enum b) => Enum (a, b) would work I think (modulo me screwing up the syntax)
03:47:04 <DRMacIver> olsner: Isn't that one of the arrow operations?
03:47:25 <Saizan> ?type join (&&&)
03:47:27 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a b (c, c)
03:47:35 <Saizan> ?type join (***)
03:47:37 <lambdabot> forall (a :: * -> * -> *) b c. (Arrow a) => a b c -> a (b, b) (c, c)
03:47:47 <olsner> ?type (><)
03:47:48 <lambdabot> Not in scope: `><'
03:48:16 <DRMacIver> ?type (&&&)
03:48:18 <lambdabot> forall (a :: * -> * -> *) b c c'. (Arrow a) => a b c -> a b c' -> a b (c, c')
03:48:57 <olsner> seems *** is what I want
03:49:05 <olsner> or rather (f *** f)
03:57:05 <cinimod> > (-1) `div` 2
03:57:07 <lambdabot>  -1
03:57:41 <cinimod> > (-1) `mod` 2
03:57:42 <lambdabot>  1
03:58:30 <Jaggederest> wait what?
03:59:13 <Saizan> Jaggederest: ?
03:59:33 <Jaggederest> cinimod's thing above.
03:59:49 <Jaggederest> mod returning the abs
03:59:50 <Saizan> 2*(-1) +1 = -1
04:00:05 <bauchus> Haskells XHTML combinator library is great. It could even be improved by adding a readonly attribute...
04:00:07 <cinimod> Yes that's puzzling me but Saizan has said it already
04:00:15 <Jaggederest> ah right, long night.
04:00:24 <Jaggederest> forgot the mod identity
04:00:27 <Saizan> > ((-1) `quot` 2,(-1) `rem` 2)
04:00:28 <lambdabot>  (0,-1)
04:00:39 <cinimod> m = q*n + r
04:00:53 <cinimod> Ah so I need quot and rem not div and mod
04:03:00 <quicksilver> it's impossible to rememeber which is quotrem and which is divmod
04:03:05 <quicksilver> I have to check every single time :)
04:04:36 <Saizan> and i've seen many fail the checking because of the lower precedency of (-)
04:21:40 <dankna> hm
04:22:11 <dankna> is it correct that Data.FiniteMap disappeared from 6.4 to 6.6?
04:22:17 <dankna> er, in ghc
04:22:46 <dankna> or is the problem my local install
04:23:03 <dankna> my best guess is that it was renamed, but it's not obvious to what
04:23:25 <dankna> uh, this is me trying to build GreenCard, but it's pretty clear that's the reason it won't
04:25:21 <Saizan> to Data.Map i think
04:25:29 * dankna nods
04:25:29 <Saizan> ?docs Data.Map
04:25:29 <lambdabot> http://haskell.org/ghc/docs/latest/html/libraries/base/Data-Map.html
04:25:59 <dankna> let's see if the naive fix works, then...
04:34:05 <dankna> hmm, interface differs.... the parameters to Data.Map.lookup are different from those to Data.FiniteMap.lookupFM.
04:34:43 <dankna> ah.  because it now uses monads.  which must have been the point of the change.
04:45:38 <whitenoyce> if haskell is so functional, why do i see "do" in all the tutorial examples
04:45:46 <whitenoyce> http://en.wikibooks.org/wiki/Write_Yourself_a_Scheme_in_48_Hours/Parsing
04:45:48 <lambdabot> http://tinyurl.com/2yojoc
04:45:51 <beelsebob> ecause you're reading the wrong tutorial
04:46:10 <beelsebob> plus... do *is* functional
04:46:22 <beelsebob> it's not just a "do this bit imperatively" keyword
04:46:32 <beelsebob> it's syntactic sugar for a load of purely functional stuff
04:46:34 <qwr> whitenoyce: you can always write the "do" expression without do
04:46:41 <LeCamarade> whitenoyce: Haskell is functional, no matter what anything/anybody says. If Haskell isn't, nothing is.
04:47:32 <LeCamarade> /me slinks back to whence he came ...
04:47:50 <xpika> is it possible to write a funtion for map which can skip elements?
04:48:21 <beelsebob> xpika: so you want mapSkip :: (a -> a) -> (a -> Bool) -> [a] -> [a]
04:48:22 <beelsebob> ?
04:48:39 <olsner> xpika: (\x -> if (cond x) then f x else x)
04:48:42 <xpika> beelsebob: pretty much
04:49:38 <beelsebob> xpika: mapSkip _ _ [] = []; mapSkip f c (x:xs) = if c x then (f x):(mapSkip f c xs) else x:(mapSkip f c xs)
04:49:57 <beelsebob> should probably push the if inwards there
04:50:13 <qwr> @undo do { x <- getLine; putStrLn x }
04:50:14 <lambdabot> getLine >>= \ x -> putStrLn x
04:50:15 <beelsebob> mapSkip _ _ [] = []; mapSkip f c (x:xs) = (if c x then (f x) else x):(mapSkip f c xs)
04:50:31 <bartw> what is the (a -> a) for in mapSkip ?
04:50:43 <beelsebob> bartw: the function being mapped
04:50:46 <bartw> (a -> Bool) -> [a] -> [a] would seem enough ?
04:50:59 <beelsebob> it needs a function to map over things
04:53:54 <beelsebob> xpika: that of course is just a more general case of map
04:54:00 <beelsebob> less general even
04:54:25 <beelsebob> mapSkip f c = map (\x -> if c x then f x else x)
04:56:11 <dons> ?yow
04:56:11 <lambdabot> There's a little picture of ED MCMAHON doing BAD THINGS to JOAN RIVERS
04:56:11 <lambdabot> in a $200,000 MALIBU BEACH HOUSE!!
04:57:42 <bartw> pretty cheap house
04:58:16 <LeCamarade> Yeah. Cheap. Zimbabwe dollars aren't that cool.
04:58:52 <bartw> hmz ?
04:58:58 <xpika_> @let a=1
04:59:00 <lambdabot> Defined.
04:59:13 <xpika_> @L.a
04:59:13 <lambdabot> Not enough arguments to @.
04:59:17 <xpika_> > L.a
04:59:18 <lambdabot>  1
04:59:29 <xpika_> @let splitBy c xs = (filter (not . c) xs, filter c xs )
04:59:30 <lambdabot> Defined.
04:59:36 <bartw> a shed costs about half that around here (nl)
04:59:41 <xpika_> splitBy odd [1..10]
04:59:43 <xpika_> > splitBy odd [1..10]
04:59:45 <lambdabot>  ([2,4,6,8,10],[1,3,5,7,9])
05:00:08 <LeCamarade> @src break
05:00:08 <lambdabot> break p =  span (not . p)
05:00:31 <xpika_> beak odd [1..10]
05:00:32 <xpika_> > beak odd [1..10]
05:00:33 <lambdabot>   Not in scope: `beak'
05:00:36 <xpika_> > break odd [1..10]
05:00:37 <lambdabot>  ([],[1,2,3,4,5,6,7,8,9,10])
05:00:40 <xpika_> :(
05:00:49 <xpika_> splitBy!
05:00:54 <xpika_> ++
05:00:59 <dankna> hmmmmm, I got GreenCard half compiling, but it's generating one of its own source files with a wrong path to the matching header...
05:01:05 <LeCamarade> > groupBy odd [1 .. 10]
05:01:05 <lambdabot>  Couldn't match expected type `a -> Bool'
05:01:58 <roconnor> sweet, a make replacement in Haskell
05:02:07 <roconnor> I've been wanting one for weeks!
05:02:25 <dankna> eh?
05:02:25 <xpika_> hmake or Setup.hs?
05:02:44 <roconnor> http://ashish.typepad.com/ashishs_niti/2007/06/another_dsl_emb.html
05:02:46 <lambdabot> http://tinyurl.com/2dxvoc
05:10:21 <Cheery> there's bunch of AI projects around...
05:11:08 <Cheery> which ones of them are of value?
05:12:05 <Cheery> and which of those mimics closest the way how human processes information?
05:12:14 <dankna> that's an amazingly understated question
05:12:30 <dankna> also, I don't know
05:13:21 <Cheery> yes, I'm going to find out, just wondering, whether anyone other here has look around these
05:20:26 <Cheery> compilers tend to make lossy translations from languages to another, they are, in fact, never more efficient in doing that than other translators written
05:20:55 <Cheery> also, as much inflexible
05:29:24 <hpaste>  xpika pasted "constructor ?" at http://hpaste.org/237
05:29:42 <ndm> @seen Shimei
05:29:42 <lambdabot> Shimei is in #xmonad and #haskell. I last heard Shimei speak 1d 5h 42m 40s ago.
05:34:15 <ekidd> The advantage of writing a paper is that is forces you to realize *exactly* what you're talking about. Ouch.
06:02:31 <ndm> @pl f c = gmapQ DataBox (asTypeOf (fromConstr c) x)
06:02:31 <lambdabot> f = gmapQ DataBox . flip asTypeOf x . fromConstr
06:03:49 <araujo> morning
06:04:57 <Jaggederest> evening :)
06:12:01 <dankna> hmmm
06:12:25 <dankna> I got GreenCard to compile under ghc 6.6, after a few changes and faking an entry for ghc-pkg
06:12:35 <dankna> but when I try to build the examples that go with it, I get
06:13:39 <hpaste>  dankna pasted "attempt to run GreenCard on its example after modifications" at http://hpaste.org/238
06:14:16 <bartw> with and without version
06:14:32 <dankna> pardon?
06:14:43 <dankna> oh,
06:15:13 <dankna> ghc-pkg problem then.  go figure.
06:19:06 <dankna> hm, where is that even coming from.  maybe it's looking for a version 3.01 and getting a version 3.1....
06:19:21 <dankna> grepped that directory for any use of either number, found nothing, so it must be in how it's installed
06:21:31 <dankna> updated that, now there are no references to 3.01 anywhere that it ought to be able to see...
06:21:34 <dankna> surely the .hi file itself doesn't contain a version number
06:27:18 <dankna> well, it doesn't contain it as text, anyway, since grep would have caught that, and I don't see anything in the build process that could possibly be passing it that info anyway
06:28:24 <dankna> ..... I guess that's the problem, actually
06:29:34 <dankna> oh!  It *is* in the .hi file, the -package-name option to ghc
06:31:44 <araujo> http://ertos.nicta.com.au/research/sel4/
06:31:46 <lambdabot> Title: NICTA | ERTOS - http://www.ertos.nicta.com.au/research/sel4/home.pml
06:31:48 <araujo> nice
06:32:57 <dankna> looks like an interesting project, definitely
06:35:03 <dankna> all right!  it runs its demo programs
06:35:47 <araujo> yeah
07:06:10 * SamB discovers the joys of manually moving modules from the "hidden" list to the "exposed" list
07:06:48 <bos> not using "ghc-pkg expose"?
07:07:12 <SamB> that seems to be for *packages*
07:08:56 <SamB> oh, nice, our alex is number 10 on google...
07:38:54 <SimonRC> I had an epiphany just now.
07:39:12 <SimonRC> I grok how unsafePerformIO subverts the typesystem.
07:39:41 <SimonRC> It makes sense once you make the foralls explicit
07:40:42 <SimonRC> For example, if its input has type "forall a. IO (IORef a)", it is forcede to pretend that it actually has type "IO (forall a. IORef a)", in order to do its job.
07:41:26 <SimonRC> but no values of that type exist, so one of its concrete subtypes will probably be picked, but still presumed to have the polymorphic value.
07:41:39 <SimonRC> That is how one of the standard examples works.
07:44:52 <dons> kfish: available to translate? :-) http://d.hatena.ne.jp/tmatsuu/20070610#1181442828
07:44:53 <lambdabot> Title: ¤â¤·¤â¤·¡¢matsuu¤Ç¤¹¤¬...
07:45:15 <dons> kfish: seems to be a pretty glowing review?
07:45:17 <pejo> Be careful with the word 'subtype', people might interpret it different from the way you mean.
07:46:48 <SimonRC> Is there a better term?
07:47:34 * araujo wonders if dons knows something about seL4
07:48:16 <dons> araujo: only a little
07:48:26 <dons> araujo: talk to Thomas2
07:48:38 <araujo> nice
07:50:14 <mehrheit> what does forall mean?
07:50:28 <mehrheit> I notice it a lot, but can't find the description.
07:50:41 <mehrheit> (or a description)
07:52:12 <kpreid> mehrheit: http://en.wikipedia.org/wiki/For_all
07:52:36 <Heffalump> "forall a . foo" means "foo, for any possible value of a"
07:54:01 <SimonRC> mehrheit: If it displays correctly, this symbol:   âˆ€
07:54:55 <kpreid> @type reverse
07:55:04 <lambdabot> forall a. [a] -> [a]
07:55:13 <SimonRC> good example there
07:55:35 <SimonRC> consider how it is different from "(forall a. [a]) -> (forall a. [a])"
07:55:38 <araujo> @type id
07:55:40 <lambdabot> forall a. a -> a
07:55:42 <kpreid> so this means: "For any type, let's call it a, this is a function from [a] to [a].
07:55:54 <SimonRC> kpreid: yes, roughly
07:55:58 <mehrheit> how does it differ from simple [a] -> [a]?
07:56:06 <kpreid> mehrheit: it doesn't; the forall is implicit
07:56:09 <SimonRC> [a] -> [a] is an abbreviation
07:56:38 <kpreid> In Haskell 98, there's always an implicit forall just after the ::.
07:56:53 <kpreid> That's the effect of the specified rules of type variable scope.
07:57:04 <SimonRC> Though in ghc if you put in explicit foralls in your top-level type signatures, that turns on lexically-scoped types, ISTR
07:57:49 <SimonRC> which means that any types within the function do *not* have implicit foralls, but instead free type variables refer to, erm....
07:58:15 <SimonRC> ... other type variables of the same name, though I don't konw the exact rules
07:58:56 <SimonRC> It's needed when the types in signatures within the function depend on the types of the arguments in a way too complicated for the compiler to figure out.
07:59:01 <SimonRC> I think
07:59:10 <SimonRC> i.e. very rarely
08:00:11 <kpreid> lexically scoped type variables are mostly (iiuc) interchangeable with sufficiently clever uses of asTypeOf
08:02:18 <SimonRC> kpreid: yes, though the former is elegant and the latter is a slight hack
08:07:55 <roconnor> > x231C
08:07:59 <lambdabot>   Not in scope: `x231C'
08:08:00 <roconnor> > 0x231C
08:08:01 <lambdabot>  8988
08:16:24 <geezusfreeek> @pl forever a = a >> forever a
08:16:24 <lambdabot> forever = fix (ap (>>))
08:16:36 <geezusfreeek> what is "fix"? i can't find it
08:16:40 <kpreid> @index fix
08:16:41 <lambdabot> Control.Monad.Fix, Control.Monad.Reader, Control.Monad.Writer, Control.Monad.State, Control.Monad.RWS, Control.Monad.Identity, Control.Monad.Error
08:16:51 <geezusfreeek> aha, thanks
08:16:54 <kpreid> geezusfreeek: import Control.Monad.Fix
08:17:12 <kpreid> afaik, it's there just because having defined mfix, there ought to be a fix available too
08:17:23 <kpreid> @src fix
08:17:23 <lambdabot> fix f = let x = f x in x
08:17:37 <geezusfreeek> oh, it's that function
08:20:33 <Heffalump> for f :: (a -> b) -> (a -> b), does changing the definition to "fix f = let x a = f x a in x" change the semantics?
08:26:19 <fasta> I am currently passing a few functions a few levels through my code. If I put those functions in type classes, I don't need to do that anymore. What is better?
08:26:37 <Heffalump> whichever is more natural
08:26:48 <Heffalump> are they obviously global properties of the type in question?
08:26:54 <Heffalump> you could also use implicit parameters
08:27:22 <geezusfreeek> fasta: try it and see what it feels like :)
08:27:25 <fasta> Heffalump: they set the fields of nodes in a tree of a specific type correctly.
08:27:51 <fasta> Heffalump: for every type there are specific functions associated with it.
08:29:09 <geezusfreeek> sounds like a job for typeclasses to me
08:38:51 <MarcWeber> I want to listen to mouse events on a remote computer. I've written some small functions converting the 3 byte data chunks (ps2 protocol) from /dev/../usb..mouse to some event datatype.
08:39:59 <MarcWeber> When a client connects I could open the device again and interprete the data stream again. But How is this done if I want to transform the data stream first and then duplicate it to send it to more than one client?
09:12:49 <|Jedai|> @source foldr
09:12:49 <lambdabot> foldr not available
09:13:23 <lumi> @src foldr
09:13:23 <lambdabot> foldr k z xs = go xs
09:13:23 <lambdabot>     where go []     = z
09:13:23 <lambdabot>           go (y:ys) = y `k` go ys
09:13:23 <|Jedai|> @src foldr
09:13:24 <lambdabot> foldr k z xs = go xs
09:13:24 <lambdabot>     where go []     = z
09:13:25 <lambdabot>           go (y:ys) = y `k` go ys
09:14:22 <SimonRC> why the inner function
09:14:44 <SimonRC> surely any sensible compiler can optimise out the passed-through parameter?
09:15:10 <Heffalump> the definition may have been written before and not changed
09:16:38 <bluestorm_> @src foldl
09:16:39 <lambdabot> foldl f z xs = lgo z xs
09:16:39 <lambdabot>     where lgo z []     =  z
09:16:39 <lambdabot>           lgo z (x:xs) = lgo (f z x) xs
09:17:58 <Philippa> SimonRC: some sensible compilers will only do that after translating into a rather similar form anyway
09:21:25 <Philippa> if you want to look at it one way, it makes the loop invariants totally obvious
09:26:15 <SimonRC> Philippa: true
09:31:30 <Philippa> it shouldn't be too big a surprise if you see library code written in a form that bears a close resemblance to one of the IRs involved
10:12:02 <clanehin> I'm not the first person to say this right?  Shouldn't: ++ be generalized to equal `mappend`
10:15:40 <ibid> clanehin: ++ used to be mappend, then it was specialized and mappend was created
10:15:59 <Heffalump> clanehin: the argument against doing that is that the type confuses beginners
10:17:11 <ibid> there were a number such changes in 1.4->98
10:18:40 <clanehin> I see.
10:23:32 <DRMacIver> ?where lazy bytestring
10:23:32 <lambdabot> I know nothing about lazy.
10:23:36 <DRMacIver> Hm
10:24:13 <bos> @where fps
10:24:14 <lambdabot> http://www.cse.unsw.edu.au/~dons/fps.html
10:24:25 <bos> that's what you want
10:28:50 <DRMacIver> Thankee.
10:35:32 <igli> @botsnack
10:35:32 <lambdabot> :)
10:48:18 <roconnor> > sort ["20050507T111000Z","20050507T1010Z"]
10:48:21 <lambdabot>  ["20050507T1010Z","20050507T111000Z"]
10:51:17 <igli> @src fix
10:51:17 <lambdabot> fix f = let x = f x in x
10:51:23 <igli> @botsnack
10:51:23 <lambdabot> :)
10:51:33 <igli> there there lambdabot :)
10:57:06 <chessguy> 'ello
10:57:26 <augustss> 'allo, 'allo
10:57:41 <igli> this could get boring ;)
10:57:44 <chessguy> yes, pardon my yankee accent
10:58:03 <igli> eh?
10:58:03 <emu> hi
10:58:17 <igli> #haskell-blah chessguy ;)
10:58:31 <chessguy> hm?
10:58:40 <igli> er
10:59:15 <augustss> ah
10:59:22 <igli> ..
10:59:30 <igli>  
10:59:31 <chessguy> this is what i love about haskell, such deep, intellectual conversations
10:59:39 <kaol>  
10:59:49 <igli> yeah well make some sense then :D
11:00:22 <igli> or talk crap in #haskell-blah ;)
11:00:28 <augustss> chessguy: talk to the bot if we're not good enough for you
11:00:35 <igli> #haskell-blah chessguy ;)
11:00:48 <augustss> :)
11:00:57 <chessguy> igli, we're not that strict usually
11:01:03 <igli> who's we?
11:01:14 <chessguy> i mean, if there's going to be an extended discussion, it's usually directed to -blah
11:01:19 <chessguy> we, the citizens of #haskell
11:01:20 <augustss> me and the mice in my pocket
11:01:28 <igli> well direct it then
11:01:48 <chessguy> but there's no need to be a jerk about it
11:02:00 <igli> oh man, i do it so well ;D
11:03:19 * igli really really tries
11:03:21 <chessguy> so DSLs keep coming up lately. what's a good example of a large DSL in haskell
11:03:36 <igli> meh is this haskell code then?
11:03:38 <Vq^> chessguy: yampa?
11:03:55 <chessguy> Vq^, was that a question or an answer?
11:04:19 <igli> #haskell-blah chessguy ;)
11:04:31 <Vq^> chessguy: an answer coupled with the question, "will this do?" :o)
11:04:50 <chessguy> ah, ok.
11:04:54 <chessguy> @where yampa
11:04:54 <lambdabot> http://www.haskell.org/yampa/
11:04:56 * igli waits for some actual code
11:05:34 <chessguy> oh, that's the porting of the HSOE stuff to arrows, isn't it?
11:05:50 * igli waits for some actual code
11:06:13 <daniel_larsson> Go browse a darcs repo for actual code, if that's what you're looking for )
11:06:44 * igli waits for a kick ;)
11:06:50 <igli> er ni
11:06:53 <igli> no*
11:06:57 <igli> sorry :D
11:07:08 <bos> @seen sorear
11:07:08 <lambdabot> I saw sorear leaving #ghc, #xmonad, #haskell-overflow, #haskell-blah and #haskell 10h 27m 53s ago, and .
11:07:48 <Tanuk> What's #haskell-overflow?
11:07:58 <Vq^> Tanuk: an irc-channel
11:08:09 <Tanuk> Vq^: Thanks.
11:08:09 <chessguy> Tanuk, for extended on-topic discussions about haskell
11:08:46 <Vq^> chessguy: on-topic=
11:08:51 <Vq^> s/=/?/
11:09:01 <chessguy> meaning about haskell
11:09:16 <Vq^> chessguy: #haskell-blah isn't about haskell
11:09:21 <fasta> class Foo a b where
11:09:23 <fasta>   foob:: a -> b -> a
11:09:23 <fasta>  
11:09:23 <fasta> some_code a = do
11:09:23 <fasta>    foob a
11:09:23 <fasta>    return False
11:09:36 <Vq^> chessguy: you must be confusing it with #haskell-overflow
11:09:37 <igli> as in real code you're having real probs with imo
11:09:37 <chessguy> Vq^, i never said it was
11:09:39 <fasta> Is there any context where some_code should not give an error?
11:09:53 <chessguy> Vq^, either that or i'm answering the question about what #haskell-overflow is
11:09:55 <Vq^> chessguy: oh, i must have misinterpretted you, sorry
11:10:05 <igli> <fasta> Is there any context where some_code should not give an error?
11:10:26 <fasta> igli: foob is applied to one argument.
11:10:48 <igli> un-huh
11:11:32 <igli> why so?
11:12:03 <chessguy> fasta, what do yhou mean by 'context'?
11:12:21 <fasta> @dict context
11:12:21 <lambdabot> Supported dictionary-lookup commands:
11:12:21 <lambdabot>   all-dicts devils easton elements foldoc gazetteer hitchcock jargon lojban vera web1913 wn world02
11:12:21 <lambdabot> Use "dict-help [cmd...]" for more.
11:12:35 <fasta> @all-dicts context
11:12:37 <lambdabot> *** "Context" gcide "The Collaborative International Dictionary of English v.0.48"
11:12:37 <lambdabot> Context \Con*text"\, a. [L. contextus, p. p. of contexere to
11:12:37 <lambdabot>    weave, to unite; con- + texere to weave. See {Text}.]
11:12:37 <lambdabot>    Knit or woven together; close; firm. [Obs.]
11:12:37 <lambdabot>    [1913 Webster]
11:12:39 <lambdabot> [64 @more lines]
11:12:44 <fasta> @more
11:12:44 <lambdabot>  
11:12:44 <lambdabot>          The coats, without, are context and callous. --Derham.
11:12:45 <lambdabot>    [1913 Webster]
11:12:46 <lambdabot>  
11:12:49 <lambdabot> *** "Context" gcide "The Collaborative International Dictionary of English v.0.48"
11:12:51 <lambdabot> [59 @more lines]
11:13:01 <fasta> Well, anyway, context as it's used in English.
11:13:11 <fasta> Not the Haskell concept of context.
11:13:25 <chessguy> fasta, i'm not looking for a denotational definition of the wor
11:13:25 <chessguy> d
11:13:31 <fasta> Read "situation".
11:14:01 <fasta> I question whether there is any situation where one would want that that code is accepted by the compiler.
11:14:32 <bos> fasta: if a is of type IO something
11:15:02 <bos> which would not be unusual at all
11:15:22 <bos> or in fact if a is of type Monad m => m something
11:19:21 <fasta> One thing I find annoying is that sometimes when you forget an argument, you get back something which compiles, but has some function type in a really weird place. The problem is that coming up with a formal definition of "weird" is difficult without introducing new syntax.
11:20:05 <igli> hmm
11:20:25 <emu> heya sjanssen
11:20:38 <chessguy> yeah, that's when you see things of types like a -> [b] instead of type [b]
11:20:55 <chessguy> > foldr (+) [1..10]
11:20:56 <lambdabot>   add an instance declaration for (Num [t])
11:21:11 <chessguy> > foldr 0 [1..10]
11:21:12 <lambdabot>        add an instance declaration for (Num (a -> [t] -> [t]))
11:21:16 <chessguy> wheee
11:21:39 <sjanssen> hello emu
11:21:43 <roconnor> @hoogle Alpha
11:21:43 <lambdabot> Test.QuickCheck.Poly.ALPHA :: type ALPHA
11:21:43 <lambdabot> Language.Haskell.TH.Lib.alpha :: [(Name, Name)] -> Name -> ExpQ
11:21:43 <lambdabot> Text.ParserCombinators.Parsec.Char.alphaNum :: CharParser st Char
11:21:48 <roconnor> @hoogle Alphanum
11:21:49 <lambdabot> Text.ParserCombinators.Parsec.Char.alphaNum :: CharParser st Char
11:21:49 <lambdabot> Char.isAlphaNum :: Char -> Bool
11:22:05 <sorear> (hello)
11:22:12 <emu> i managed to get a program to run in 2 seconds, but for some reason i'm stuck with WA (using Prim's)
11:22:13 <igli> !hi
11:23:00 <sorear> igli: wrong channel
11:23:02 <fasta> chessguy: A popular way to "solve" it, often given by people who only write simple programs, is to "add type annotations".
11:23:17 <igli> heh sorry sorear :) beg pardon
11:23:24 <sorear> np
11:23:30 * igli hides and listens to code
11:23:34 <roconnor> > isAlphaNum ':'
11:23:35 <lambdabot>  False
11:25:03 <gogonkt1> hi,all
11:25:20 <sjanssen> emu: did you see that "The sum of all connections is not greater than 2^32-1."?
11:25:28 <emu> yes
11:25:30 <sjanssen> (ie. use Word)
11:25:43 <emu> is that better than Int?
11:25:49 <emu> i'm using IntSets and IntMaps too
11:26:24 <emu> i mean it runs "fast enough" i don't know why it's incorrect.  i can't find any examples where it is wrong.
11:26:37 <gogonkt1> How can I handle no-utf-8, e.g. GBK, GB2312 ?
11:27:30 <sjanssen> emu: you need the extra precision Word offers
11:27:40 <roconnor> gogonkt1: what do you want to do with it?
11:27:55 <emu> ugh, Int is signed
11:28:00 <sjanssen> Int only gives you 2^31 - 1 -- the problem says it might be as high as 2^32 - 1
11:28:25 <roconnor> 0::Int64
11:28:27 <roconnor> > 0::Int64
11:28:28 <lambdabot>  0
11:28:37 <gogonkt1> I'm writing a bot read from a room u8, print it in windows control,win is GBK
11:28:52 <Syzygy-> (2::Int64)^63
11:28:56 <roconnor> sjanssen: Int give you a navtive integer size, not necessarily 32 bit.
11:29:00 <Syzygy-> > (2::Int64)^63
11:29:02 <lambdabot>  -9223372036854775808
11:29:16 <Syzygy-> > (2::Int64)^62
11:29:18 <lambdabot>  4611686018427387904
11:30:45 <gogonkt1> Any module can conver between utf-8 and GBK or other no-utf-8?
11:30:57 <bos> gogonkt1: not built-in, no.
11:31:37 <sorear> roconnor: Int gives you -2^29 to 2^29-1.  Overflow behavior is undefined.
11:31:54 <sorear> roconnor: specifically chosen to allow tagged *non-native* formats
11:32:33 <gogonkt1> My bot must face this in china, :(
11:34:26 <emu> nope :(
11:35:57 <SamB> I'm pretty sure Word only gives you 0 to 2^30-1...
11:36:13 <emu> > maxBound :: Word
11:36:14 <lambdabot>  4294967295
11:36:20 <emu> > 2^32 - 1
11:36:21 <lambdabot>  4294967295
11:36:37 <SamB> emu: I meant that, if Word were in the report, the report would state that as the minimum range
11:36:42 <roconnor> sorear: even on a 64 bit machine?
11:36:50 <roconnor> that fucking sucks!
11:37:12 <igli> ahh
11:37:13 <Syzygy-> ?index Word
11:37:13 <lambdabot> Data.Word, Foreign, GHC.Exts
11:37:14 <SamB> roconnor: try Int32/Word32
11:37:18 <sorear> roconnor: the available size of Int is platform independant
11:37:28 <Syzygy-> > maxBound :: Word
11:37:28 <Syzygy-> 18446744073709551615
11:37:29 <lambdabot>  4294967295
11:37:33 <igli> might be 32 bit kerne;
11:37:34 <Syzygy-> (my box is a 64-bit box)
11:37:36 <roconnor> sorear: that's terrible.
11:37:43 <SamB> sorear: not exactly...
11:37:55 <sorear> roconnor: Remember what I said about undefined overflow behavor.
11:37:59 <roconnor> if I wanted platform independence I would have said Int32
11:38:12 <roconnor> sorear: oh, right
11:38:33 <SamB> roconnor: if it helps, CInt is likely to be 32-bit on 64-bit systems too
11:38:35 <roconnor> so you can get maybe 2^64 on a 64 bit machine, maybe.
11:38:47 <sorear> > 2^31  -- on dons' 32 bit box, GHC uses 32 bit Int's
11:38:48 <lambdabot>  2147483648
11:38:59 <roconnor> SamB, I don't want to incoporate C's failings into Haskell.
11:39:06 <Syzygy-> ?index CInt
11:39:07 <lambdabot> Foreign.C.Types, Foreign.C
11:39:13 <SamB> roconnor: well what exactly do you *want*?
11:39:31 <roconnor> I want Int to be the fastest available integer for whatever platform I'm on.
11:39:34 <sorear> roconnor: C int can be anything 16 bits or more, again with undefined overflow?
11:39:40 <Syzygy-> Foreign.C> maxBound :: CInt
11:39:40 <Syzygy-> 2147483647
11:39:42 <sorear> roconnor: that's exactly what it is
11:39:43 <SamB> roconnor: it should be so
11:39:49 <SamB> that is the intent of the Report
11:39:51 <roconnor> yay!
11:39:56 <SamB> that is the intent of the implementors
11:40:11 <roconnor> > bitsize (0::Int)
11:40:12 <lambdabot>   Not in scope: `bitsize'
11:40:16 <roconnor> > bitSize (0::Int)
11:40:17 <lambdabot>  32
11:40:34 <SamB> and I think that C's int is the same in most contexts
11:40:38 <opqdonut> > bitSize (0::Integer)
11:40:39 <lambdabot>  Exception: Data.Bits.bitSize(Integer)
11:40:43 <opqdonut> awww
11:40:54 <sorear> hmm, on a trinary computer it would be pretty hard to implement instance Bits Int
11:41:10 <SamB> sorear: hmm, yes.
11:41:28 <sorear> C's int and Haskell's Int are basically the same, although Haskell requires 30 bits while C only requires 16
11:41:37 <SamB> Haskell^XXVI is looking into it
11:41:54 <opqdonut> sorear: how come?
11:42:01 <Philippa> sorear: "are similarly defined", it's a bad idea to assume that they're the same thing
11:42:05 <opqdonut> yep
11:42:23 <SamB> Philippa: by "basically the same", he means they are similarly vague
11:42:27 <sorear> Philippa: I was talking equivalence of concepts, not sizes, sorry
11:42:43 <Philippa> sorear: yeah, just quibbling with the ambiguity :-)
11:42:49 <sorear> ok :)
11:46:45 <gogonkt1> Are there any project about asia language handle?
11:57:14 <roconnor> gogonkt1: I'm not aware of any :(
11:57:54 <gogonkt1> Perl do well, but hs ... :(
11:58:16 <gogonkt1> Perl do it well, but haskell ... :(
11:59:45 <Philippa> gogonkt1: I suspect most of it's contingent on getting our IO story settled - nominally Char is a unicode character, but that's about it so far
12:00:03 <Philippa> you might want to talk to people working on GUI lib bindings about how they're handling the issues
12:00:57 <gogonkt1> Philippa: good news, Thx! :)
12:02:20 <sorear> gogonkt1: there is nothing stopping you from writing your own encoding code in the meantime; implementing UTF8 requires ~10 lines
12:02:21 <fasta> "Arguments exhausted after 13 tests." <- this means the 13 tests were distinct?
12:02:33 <sorear> yes
12:02:35 <nattfodd> fasta: yes
12:02:35 <gogonkt1> Why haskell don't let us handle any encoding?
12:02:43 <gogonkt1> en, yes
12:02:44 <sorear> gogonkt1: it does
12:02:48 <Philippa> it does, it just doesn't provide the code to do it for you
12:03:02 <sorear> gogonkt1: haskell lets you handle any encoding you want just fine
12:03:03 <Philippa> and that's because it's been far from obvious what the right way to do it's been until now
12:03:07 <SamB> wow. the PDP-1 had both lower and upper case!
12:03:29 <sorear> Philippa: "until now" - you mean someone's finally figured it out?
12:03:31 <ddarius> SamB: The wave of the future.
12:03:54 * sorear waits for mezanine case
12:04:07 <gogonkt1> hehe :D
12:04:14 <SamB> unfortunately it uses multi-"byte" coding for them...
12:05:01 * ddarius wonders what sorear means by "mezanine"
12:05:18 <Philippa> sorear: heh, you got me. Though at least we've got sufficient power that we know the Right Way ought to be expressible in GHC now
12:06:26 <sorear> ddarius: It is a (misspelled) type of floor found between upper and lower ones, not extending the entire width of the building.
12:07:03 <ddarius> "We can embed the Calculus of Inductive Constructions into the type system, -surely- we can handle character encoding now... right?"
12:07:08 <ddarius> sorear: Yeah, I got that...
12:09:32 <DRMacIver> It seems to be a classic Haskell problem that people would much rather work on the cool theoretical stuff than getting the annoying practical details done. :)
12:09:37 <Philippa> ddarius: Right Way involves usability as well though - GADTs're a big improvement there
12:11:08 <ddarius> DRMacIver: That is not it at all, nor is that actually very typical of the language.  It's the classic Haskell problem that people want to do it "the Right Way".
12:11:39 <DRMacIver> Fair enough.
12:12:10 <ddarius> sorear: Ah.  When I look at the context I get what you meant, I thought you were still responding to Philippa.
12:12:46 <ddarius> sorear: Incidentally, have you taken a public speaking class?
12:12:56 <sorear> No.
12:13:09 <ddarius> Does your high school offer one or something similar?
12:13:28 <Shimei> So I have a question about Data.ByteString.split. It takes a GHC.Word.Word8, how can I turn a '\n' into a Word8 for this function? I think newer versions of ByteString take Char instead now.
12:13:57 <ddarius> @hoogle Char -> Word8
12:13:58 <lambdabot> No matches, try a more general search
12:14:09 <Saizan> ?index split
12:14:09 <lambdabot> Data.IntMap, Data.IntSet, Data.Map, Data.Set, GHC.Exts, Language.Haskell.TH.Ppr, System.Random
12:14:14 <SamB> Shimei: toEnum . fromEnum?
12:14:29 <Saizan> ?type Data.ByteString.Char8.split
12:14:31 <lambdabot> Char -> Data.ByteString.Base.ByteString -> [Data.ByteString.Base.ByteString]
12:15:24 <Shimei> Ah, I see. I have that function. Thanks.
12:15:50 <Shimei> SamB: When I tried that it seemed to break something else.
12:20:46 <sorear> Shimei: Data.ByteString is for bytes; if your bytestrings logically contain text, you should probably be using Data.ByteString.Char8
12:20:59 <sorear> Shimei: which has a readymade 'lines' function
12:21:08 <SimonRC> Is there a ghc extention that allows you to specify just part of a type, and let the compiler infer the rest, like "Int -> _ -> [Int]" or whaever?
12:21:32 <Igloo> No
12:21:39 <SimonRC> odd
12:21:43 <SimonRC> I see F# has it
12:22:03 <opqdonut> F#?
12:22:32 <SimonRC> microsoft's version of ML for .NET
12:22:41 <SimonRC> quite good from what I have seen
12:23:14 <Philippa> it's largely derived from ocaml
12:23:30 <Philippa> looks not bad, but ultimately it's a .NET lang still
12:23:42 <ddarius> Which means?
12:24:10 <SimonRC> ddarius: exactly what it says?
12:24:12 <Philippa> well, probably not too much given that it's also an ML :-)
12:24:20 <Philippa> but then I'm a purist, me
12:24:52 <SimonRC> plus ML's type syntax is dreadful
12:25:09 <centrinia> Would a context-sensitive language parser make sense?
12:25:10 <Philippa> you can remove the "type" bit there
12:25:12 <ddarius> SimonRC: "it's a .NET language" is perfectly clear, I was asking about the "but ultimately"
12:25:31 <ddarius> centrinia: Most are.
12:25:55 <Philippa> ddarius: in the long run neither JVM nor CLR can become the One True VM for All Time
12:25:58 <sorear> SimonRC: hugs has it
12:26:06 <centrinia> Oh. :p
12:26:07 <Philippa> and I'm picky
12:26:33 <SimonRC> sorear: bah
12:26:37 <SimonRC> (mutter, mutter)
12:26:42 <centrinia> What about a parser generator for context-sensitive languages?
12:27:04 <Philippa> can do
12:27:13 <Philippa> depends on the level of context-sensitivity you want
12:27:19 <Philippa> combinators're easier
12:27:21 <ddarius> I'm not sure that it wouldn't just be easier to write a Turing-complete language at that point.
12:27:39 <Philippa> ddarius: it's probably including snippets from one for semantics anyway, no?
12:28:18 <ddarius> 2-level van Wijnngaarden grammars anyone?
12:28:24 <ddarius> s/nn/n
12:28:54 <roconnor> Obviously UM is the one true VM.
12:29:02 <Philippa> FWIW, I'd still like to write a nearly-arrow-flavoured parsing combinator lib that'd have an optional code generation pass for optimisation
12:29:14 <Heffalump> why nearly arrow?
12:29:17 <Philippa> roconnor: it can't even /represent/ All Time :-)
12:29:21 <Philippa> Heffalump: want identity on computations
12:29:23 <centrinia> Just give something like: S -> a b c; S -> a S Q; Q -> b c; and a string such as aabcccc or accbbbb and it'll tell you acceptable and unacceptable respectively. :p
12:29:42 <Philippa> it wouldn't be (the equivalent of) ArrowApply, it would be ArrowChoice
12:29:55 <Philippa> I could write it as an arrow in an impure lang, I guess
12:29:57 <centrinia> Sometimes you don't have identity.
12:30:30 <Heffalump> I don't follow.
12:30:35 <Philippa> centrinia: like when you're working in Haskell. But the EDSL I'm describing would have it, and it'd be viable because it doesn't do higher-order computation
12:30:58 <Philippa> Heffalump: then all the arrow combinators can bake identity into the computations as appropriate
12:31:13 <Philippa> or do you not follow why something Arrow-like?#
12:31:19 <Philippa> (or why I'd want identity?)
12:31:39 <Heffalump> I don't follow why you can't do this with an arrow.
12:32:01 <fasta> How can I raise the number of tests in QuickCheck? I already did defaultConfig{configMaxTest = 1000}, but it still is exhausted after 13 to 15 tests.
12:32:13 <Philippa> okay. Specifically why I can't do the identity, or what I could do with identity that I couldn't without?
12:32:31 <Heffalump> why you can't do the identity
12:32:47 <Heffalump> I assume you mean "identity" as in "unique name" rather than "\a -> a"
12:32:51 <Philippa> yeah
12:32:59 <centrinia> Oh.
12:33:17 <Philippa> and the answer is: because the arrow combinators (at least in a pure lang) don't have room for the necessary name supply
12:33:32 <Philippa> and if you don't do it at construction time, it's too late
12:33:42 <centrinia> isomorphism :: (a -> a) -> (a -> a)
12:33:46 <Philippa> you then can't deal with any loops
12:34:07 <Heffalump> why not just pass around some state?
12:34:23 <Philippa> yeah, but you have to do that when you're building the computations, not within them
12:34:26 <centrinia> State? :O
12:34:28 <centrinia> State is bad. :(
12:34:47 <Philippa> so suddenly you're doing something that's like an arrow built from inside something with state, not an arrow
12:34:48 <SamB_XP> hey! google's indexed our wiki again!
12:34:48 <ddarius> How about an arrow construction language
12:35:07 <Philippa> hmm. You could build it as an arrow transformer constrained to arrows with state
12:35:13 <Heffalump> I still don't see why the arrow can't have state in it.
12:35:26 <centrinia> Arrows can have state in it? :O
12:35:26 <Philippa> it can. It's just that that doesn't fix the problem
12:36:04 <sorear> @google listt done right
12:36:07 <lambdabot> http://blog.omnigroup.com/2007/05/14/omnifocus-pre-release-early-birds-get-the-bugs/
12:36:07 <lambdabot> Title: The Omni Mouth » OmniFocus pre-release: early birds get the bugs
12:36:24 <Heffalump> it's not obvious to me why this isn't enough to do loop detection
12:36:48 <Philippa> it would be in a strict language
12:37:03 <Philippa> on account of any actual loops having fallen over for you neatly
12:37:10 <Philippa> ...no, wait, it's not
12:37:28 <Philippa> not unless you bake in various combinators you wouldn't have to otherwise, anyway
12:37:41 <Philippa> so you still don't get loop detection, you just get forced to avoid building any loops in the first place
12:38:01 <Philippa> consider many:
12:38:28 <Philippa> it calls itself
12:38:33 * ddarius considers implementing van Wijngaarden grammars.
12:38:39 <Philippa> specifically, that loop's a haskell-level loop
12:38:49 <Philippa> so the recursion is present in the meta language, if you like
12:38:57 <Philippa> in the object language, you don't have recursion: you have an infinite graph
12:39:16 <Philippa> having state in the object language doesn't fix it
12:39:45 <Heffalump> ok, then how does not being an arrow help?
12:40:16 <Philippa> depends on the value of "not an arrow" :-)
12:40:47 <Philippa> there still isn't a sufficiently pretty solution in Haskell at the moment
12:41:14 <Heffalump> what's the ugly one?
12:41:48 <Philippa> build all your computations from inside something stateful, and mercilessly taunt anyone who writes a version of many where the recursion's on the raw haskell level
12:42:33 <Philippa> actually, if your value of "something stateful" is the IO monad and you're working with GHC then haskell-level recursion's okay...
12:42:47 <Philippa> because then you can use stable names
12:44:36 <Philippa> the bonus there is that you only need to build the computation in the IO monad - not its description. So you only need a "runParser" or "compileParser" function in the IO monad
12:45:30 <Shimei> So, I've been trying to re-write a script I wrote in ruby in haskell. However, I have been unable to make the haskell perform better than ruby. Anyone see any performance issues here? http://hpaste.org/239
12:46:22 <Philippa> centrinia: it sounds like you're in need of an explanation of one of the deeper 'mysteries' of Haskell, namely how things like Arrows and Monads can support state?
12:47:02 <Philippa> (also, it's unconstrained state that's bad: if a problem is inherantly stateful, making use of that directly can abstract away further possibilities for error)
12:47:02 * Shimei wonders if that foldl is performed for every time or memoized 
12:47:19 <Heffalump> there is no automatic memoisation
12:47:38 <centrinia> Yeah, I guess I meant unconstrained state.
12:47:41 <Heffalump> of functions, anyway
12:47:48 <Heffalump> variables are implicitly memoised as you might expect
12:47:53 <SimonRC> I think the rationale is that just about anything can be safely put in a variable if the programmer wants CSE
12:48:13 <roconnor> Shimei: my first reaction is that foldl is almost always wrong to use
12:48:15 <Philippa> SimonRC: whereas automatic memoisation is potentially unsafe for memory usage
12:48:23 <SimonRC> Heffalump: as long as the monomorphism restriction is turned on.  If you turn it off you can get a nasty suprise.
12:48:30 <Shimei> roconnor: What would be the idiomatic way around that?
12:48:32 <Heffalump> you should definitely lift that foldl out
12:48:38 <Philippa> centrinia: okay. Want the explanation re monads and arrows?
12:48:53 <Heffalump> does =~ fail early?
12:49:02 <Heffalump> if so, you should definitely be using foldr.
12:49:07 <centrinia> I'll try to read up on it.
12:49:13 <centrinia> Thanks for the thought. :)
12:49:23 <roconnor> Shimei: foldr in this case, and foldl' in cases where you really want a left fold.
12:49:33 <Heffalump> SimonRC: I just adjust my concept of what a "variable" is :-)
12:49:39 <Philippa> yeah, I can simplify it without having to explain monads as a whole though, let alone arrows - you're unlikely to get a neat answer to just that question if you read around
12:49:49 <roconnor> Shimei: wait
12:49:52 <roconnor> maybe I'm wrong
12:49:52 <Heffalump> foldl' would be completely inappropriate here, since ++ is not nearly strict enough to help
12:50:02 <roconnor> @src concat
12:50:02 <lambdabot> concat = foldr (++) []
12:50:08 <centrinia> Okay, explain then. :)
12:50:26 <Heffalump> is (|) the regex choice operator?
12:50:31 <roconnor> Shimei: My inexpert opinion is that you should use foldr here
12:50:32 <Philippa> centrinia: okay, supposing I wrote an interpreter for a stateful language in haskell - you'd say that programs run within it exhibit state, right?
12:50:39 <Shimei> Heffalump: Yeah, it is.
12:50:43 <Heffalump> does it optimise stuff?
12:50:52 <Heffalump> if not, why not do the comparisons individually?
12:51:00 <centrinia> Yeah.
12:51:10 <roconnor> Shimei: and maybe you want concat (intersperse "|" days)
12:51:20 <Shimei> Not sure how optimized the regex library is.
12:51:28 <roconnor> > concat (intersperse "|" ["foo","bar","baz"])
12:51:30 <lambdabot>  "foo|bar|baz"
12:51:44 <Heffalump> I would certainly try doing the comparisons separately, thus saving the regex library from having to parse stuff.
12:51:46 <Philippa> centrinia: okay. Monads and arrows are both related to the idea of programming by interpreting another language within Haskell - only for languages that happen to include haskell as well
12:52:14 <roconnor> Shimei: anyhow, you need to profile to find out where you are spending time.
12:52:35 <Philippa> in a sense, arrows and monads are one of the more interesting and odd examples of metaprogramming to actually see regular use
12:52:37 <Saizan> foldl and ++ are a huge waste anyhow
12:52:51 <Philippa> that make sense to you?
12:52:51 <centrinia> I never though of them as DSL related. Hmm.
12:53:13 <Philippa> Heffalump: as perhaps the on-duty Picky Person, any arguments with what I'm saying?
12:53:20 <ddarius> Shimei: Use foldr (and when, though that's not a performance thing)
12:53:23 <ddarius> @type when-
12:53:25 <lambdabot> parse error (possibly incorrect indentation)
12:53:26 <ddarius> @type when
12:53:28 <lambdabot> forall (m :: * -> *). (Monad m) => Bool -> m () -> m ()
12:53:44 <centrinia> Yeah, it makes sense.
12:53:59 <Heffalump> I was wondering whether to argue with your entire premise (about interpreting another language), but it's probably one way of looking at things.
12:54:05 <centrinia> So the monad features extend Haskell?
12:54:40 <Philippa> centrinia: the only monad 'features' in Haskell are syntactic sugar :-) That's the cute bit
12:54:42 <ddarius> Yes and no.
12:54:57 <centrinia> Ah.
12:55:05 <Philippa> Heffalump: *nod* - sufficiently so that I can 'defuse' monads like Maybe or [] into an AST/interpreter pair
12:55:47 <ddarius> Generically no less!
12:56:16 <Heffalump> the IO monad extends "pure" Haskell
12:56:47 <SimonRC> The list Monad is like having some of the power of Icon available.
12:57:16 <Philippa> Heffalump: yeah, fair point - sloppy phrasing on my part
12:57:38 <Philippa> but even then, it can be treated as pretty strictly an RTS feature
12:57:51 <SimonRC> (or maybe *all* the power of Icon, though I presume that faking Icon's cool bits with the list monad won't *always* work.)
12:58:07 <newsham> is there an informal article on concurrency/stm in the wiki?
12:58:24 <SimonRC> the IO monad and related stuff is a minilanguage for describing IO actions and similar stuff
12:58:42 <Philippa> SimonRC: you'd have to describe Icon's semantics for me to comment, I guess - I won't be surprised if there's another monad or other structure that can do it
12:58:43 <ekidd> @tell dons Thanks for your help earlier! I have a few pages of the paper left to write, but the overall structure is clearly visible, and most of the material is there. Whew.
12:58:44 <lambdabot> Consider it noted.
12:58:47 <ddarius> newsham: Ask Google!
12:58:53 <newsham> i did, dd.
12:58:58 <Philippa> possibly even just layering transformers on top of list
12:58:58 <newsham> i came up empty
12:59:29 <Korollary> @tell dons Your belly button sticks out too far.
12:59:29 <lambdabot> Consider it noted.
12:59:31 <newsham> references to the STM paper, and references to the GHC documentation (which is near nonexistant on stm)
12:59:58 <centrinia> Philippa, so ( a >>= b >>= c ) passes the state of a to b, and the state of b to c.
12:59:59 <SimonRC> Icon has a "generators" concept, which as far as I can see is very like the nondeterminism given by the list Monad
13:00:16 <newsham> generators are also present in python.
13:00:26 <newsham> i would think they're more like lazy evaluation than anything else
13:00:36 <newsham> coroutines that can yield a value one at a time
13:00:37 <Philippa> centrinia: in a stateful monad, yeah
13:00:53 <ddarius> newsham: Lazy evalution only leads to one answer being produced.
13:01:01 <Philippa> it can be a little more complicated, because sometimes the 'ordering' in a monad is still lazy
13:01:12 <centrinia> Ah.
13:01:32 <newsham> http://www.thenewsh.com/%7Enewsham/x/machine/lazyFunc.py for example
13:01:33 * SamB wonders how best to discard the first line of a string...
13:01:41 <ddarius> To add expressive power to a language requires a global transformation, monadic style is a global transformation.
13:01:52 <ddarius> lines . head . unlines
13:02:03 <SimonRC> ddarius: ITYM "tail"
13:02:13 <SamB> ddarius: that doesn't seem particularly efficient
13:02:18 <ddarius> Er yeah tail
13:02:26 <Heffalump> ddarius: monadic style as in changing pure code to be monadic?
13:02:29 <ddarius> newsham: Lazy -streams- are not lazy evaluation
13:02:32 <SimonRC> or maybe "tail . dropWhile (/= '\n')
13:02:37 <Heffalump> (as opposed to introducing do notation, which is purely local)
13:02:40 <newsham> ok, perhaps i should have said lazy lists
13:02:41 <ddarius> Heffalump: Yes
13:03:42 <centrinia> Is it worthwhile for me to play with an arbitrary context sensitive language acceptor by generating more and more strings in the language and comparing with an input string.
13:04:03 <centrinia> It will not terminate unless it accepts. :(
13:04:08 <SamB> centrinia: is it fun?
13:04:16 <centrinia> Yes. :D
13:04:29 <ddarius> centrinia: You should be able to get it to terminate either way.
13:04:42 <Philippa> yeah, context-sensitive doesn't imply turing-complete
13:04:50 <centrinia> Of course.
13:05:00 <centrinia> Turing Complete is implied by Chomsky type-0.
13:05:19 <ddarius> Eventually the only strings remaining will be longer than the input unless you're going to allow infinite input.
13:05:24 <Syzygy-> Type 0 is the most constrained of the Chomsky types, isn't it?
13:05:29 * Syzygy- can't remember which way they went...
13:05:31 <ddarius> But then it won't accept either...
13:05:32 <Heffalump> or an infinite character set
13:05:43 <SamB> SimonRC: thanks
13:06:00 <SimonRC> SamB: remember, Know Your Prelude
13:06:18 <ddarius> Of course, it may as well be non-terminating for as long as it will take on some inputs...
13:06:28 <centrinia> Is there an easy way to compare two grammars to see if they produce the same set of strings?
13:06:45 <ddarius> Wouldn't that be wonderful.
13:06:52 <sorear> centrinia: Yes... for some grammars
13:06:55 <centrinia> It would. :)
13:07:00 <Philippa> Syzygy-: least constrained
13:07:11 <sorear> centrinia: it can be done pretty easily for regular langs, but it undecidable for context free
13:07:14 <newsham> anyone familiar with an informal article discussing concurrent programming in haskell?
13:07:26 <SimonRC> centrinia: the magic computational class 8-ball says: That problem is NP-hard.
13:07:31 <Philippa> sorear: what's the result for unambiguous context free?
13:07:39 <opqdonut> SimonRC: :)
13:07:39 <SimonRC> I wouldn't trust me though
13:07:52 <centrinia> newsham, didn't Simon Peyton Jones write something about STM?
13:07:56 <sorear> Philippa: unambiguity is undecidable itself, no need to add equality
13:07:57 <newsham> isnt the question of grammar equivalence undecidable?
13:08:01 <sorear> (or so WP says)
13:08:17 <newsham> centrinia: yes, there's a good, fairly technical, paper on the STM
13:08:24 <Philippa> sorear: suppose for a moment that I've found a way to force it...
13:08:26 <newsham> i was looking for something less formal and more programmer oriented
13:09:02 <Philippa> I guess I should see what theory's been done on PEGs
13:09:15 <SimonRC> As a rule of thumb, most problems are either O(1), O(log n), O(n), O(n log n), O(n^2), NP-complete, or undecidable.
13:09:31 <ddarius> ... ?
13:09:54 <sproingie> what about O(n!)
13:09:55 <ddarius> Like type checking, or finding the dominators of a graph or... wait
13:09:57 * centrinia inserts O(n^3) in there from linear algebra schooling.
13:10:04 <SimonRC> sproingie: that's rare
13:10:10 <Heffalump> what about O(n^2.78) ?
13:10:15 <sproingie> or O(2^n)?
13:10:15 <SimonRC> rare too
13:10:17 <SimonRC> rare too
13:10:22 <centrinia> A lot of O(n!) are reducible to O(2^n)
13:10:29 <newsham> as a rule of thumb, we usually arent very exact when talking about O(...)
13:10:31 <ddarius> O(\alpha(n)n)
13:10:31 <sorear> Schoenhage-Strassen!
13:10:32 <SimonRC> actully, exponential should be in there too, probably
13:10:37 <Philippa> yes, it should
13:10:43 <sorear> O(n log n log log n)
13:10:52 <centrinia> That's bit complexity. :p
13:10:53 <Heffalump> where \alpha = inverse-ackermann?
13:11:01 <newsham> sproingie: he did say "NP-complete" didnt he?
13:11:05 <ddarius> Yes, but I forget what the whole complexity is.
13:11:13 <SimonRC> ddarius: heh
13:11:18 <centrinia> The arithmetic complexity of Schoenhage-Strassen is still O(n log n) I think.
13:11:20 <SimonRC> ddarius: union-find?
13:11:22 <sorear> newsham: the complexity of np-complete problems is not known
13:11:41 <Heffalump> most people have a pretty good guess, though :-)
13:11:46 <ddarius> SimonRC: As applied to finding the dominators of a graph
13:11:50 <centrinia> The log log n is there is supposed to take care of instances where the input integers are on the order of 2^{2^n}
13:11:53 <SimonRC> I am assuming that P!=NP, which is true in practice so far even if not actually true
13:12:00 <sproingie> i suppose NP covers it
13:12:01 <SimonRC> ddarius: yeah
13:12:06 <sorear> NPC /= EXPTIME has been proven
13:12:25 <centrinia> What????!
13:12:43 <centrinia> Is NPC subset EXPTIME?
13:12:53 <sorear> Certainly.
13:13:00 <centrinia> Hmm.
13:13:12 <SimonRC> Actually, undecidable problems are Busy-Beaver-time, but no-one konws what that is, because it's uncomputable.
13:13:24 <newsham> because it's uncomputable.
13:13:28 <SamB> hehe
13:14:07 <newsham> [10:09] < sorear> NPC /= EXPTIME has been proven
13:14:09 <newsham> url
13:14:55 <SimonRC> (If you could calculate busy-beaver numbers, you could put an upper bound in the running-time of a halting turing machine given its size, which would allow you to tell non-halting machines from ones that just take a very long time.)
13:16:42 <sorear> newsham: Forgot the "Says WP" qualifier
13:16:54 <newsham> wp?
13:18:13 <sorear> Says a MISREADING of WP at that.  Sorry.
13:18:17 <sorear> wikipedia
13:18:28 <ddarius> newsham: sorear has a problem of talking in acronyms
13:18:55 * sorear managed somehow to read that as "talking in oranges"
13:19:56 <sorear> hmm.  there is an undecidable problem with a scalar answer
13:20:10 <Heffalump> heh. I was reading WP too and trying to figure out where it was incorrect given what sorear had said :-)
13:20:26 <SimonRC> sorear: define "scalar answer"
13:20:29 <sorear> some of the BB numbers are computable; for these there exists a proof BB(k) = foo
13:20:34 <sorear> SimonRC: not an infinite list
13:20:40 <sorear> or similar
13:20:48 <sorear> within a space of size omega
13:21:12 <SimonRC> but every list, pair, etc is a scalar!
13:21:29 <SimonRC> see: GÃ¶del's work
13:21:34 <newsham> NP-complete == exp except its not, except it really is (except its not)
13:21:42 <SimonRC> newsham: heh
13:21:42 <sorear> now, suppose ALL of the BB numbers were computable.  then by enumerating proofs, you would have a TM which generates all the bb numbers
13:22:16 <sorear> by contradiction, there exists some BB numbers which cannot be decided.  pick one, by the well ordering of N
13:22:39 <pejo> sorear, how do you mean some BB numbers are computable?
13:23:06 <Philippa> pejo: that it can be proven that they're what we think they are
13:23:08 <sorear> pejo: For some of the numbers, we've been able to compute them
13:23:32 <sorear> hello ndm
13:23:51 <pejo> sorear, for anything larger than 4?
13:23:54 <ndm> hi sorear
13:24:19 <sorear> pejo: Right.  We haven't been able to compute them all
13:24:28 <sorear> pejo: ANd there is no general way to do it
13:25:13 * SamB wonders why alex's "monad" wrapper doesn't report positions with errors...
13:25:15 <sorear> pejo: but if you could prove <for all K, there exists a number N and a proof of BB(K)=N>, then there would exist a simple (arbitrarily slow!) algorithm for enumerating BB's
13:25:31 <ndm> BB's?
13:25:37 <pejo> ndm, busy-beaver
13:25:37 <SimonRC> Can all mathematical proofs be turned into termination proofs?
13:25:41 <sorear> pejo: ergo, !<for all K, there exists a number N and a proof of BB(K)=N>
13:26:03 <sorear> pejo: ergo, <exists K. not exists (N, proof of BB(K)=N)>
13:26:05 <newsham> irc channel finds proof for century old problem in 5 minutes.  news at 11.
13:26:27 <ndm> SimonRC: most can
13:26:58 <Philippa> SimonRC: I imagine constructivist ones can?
13:27:07 <sieni> SimonRC: In what sense?
13:27:11 <sorear> SimonRC: All can.  Theorem proof is semidecidable, so P is provable == prover(P) terminates
13:27:41 <ndm> you can also encode them all as potential pattern match errors
13:28:50 <centrinia> Would anyone disagree with me if I conjecture that an 3-CNF encodable with O(n) bits should not be equivalent to any DNF with O(2^n) bits?
13:29:20 <kaol> > if all (\(xy,z) -> xy /= z) [(x^n+y^n, z^n) | n <- [3..], x <- [1..], y <- [1..], z <- [1..]] then True else False
13:29:26 <lambdabot> Terminated
13:29:38 <centrinia> Terminated!
13:30:00 <sorear> centrinia: Absolutely.   I think you used the wrong quantifier for the second 'any'
13:30:11 <centrinia> Sorry, remove the O( ) in my statement. :)
13:30:21 <ndm> if ... then True else False == ...
13:30:24 <ddarius> \b -> if b then True else False = id
13:30:34 <ndm> DrHaskell picks that one up :)
13:31:26 <sorear> centrinia: What you said parses as a restriction of: forall a. forall b. a == b
13:31:31 <Heffalump> ddarius: that's a bit stricter
13:31:55 <centrinia> I guess I should have said, "a 3-CNF with n terms should not be equivalent to any DNF with O(2^{2^n}) ".
13:31:56 <ndm> Heffalump: you sure about that?
13:32:05 <ddarius> id is strict
13:32:13 <Heffalump> oh yeah, duh
13:32:16 <Heffalump> sorry :-)
13:32:34 <ndm> we really do need a
13:32:46 <ndm> equational reasoner for haskell, just like the one demo'd at least years HW
13:33:25 <sorear> centrinia: (a|b|c) & (a|b|c) & (a|b|c)  is == to   (a) | (b) | (c)    disproof.
13:33:26 <Saizan> ndm: is there a way to write a relaxed comparison for the attributes of a TagOpen in tagsoup? like ~== TagOpen "a" [("href","?cat=")] that matches <a href="?cat=w"> for any string w? or i just have to extract the attribute and check by myself?
13:33:50 <centrinia> Oh.
13:33:55 <ndm> Saizan: there is no wildcard support in the patterns, yet
13:34:01 <centrinia> I should not have used big O notation.
13:34:17 <ndm> Saizan: adding a regular expression thingy to it would be a sensible step forward, if Haskell had a reliable and cross-compiler regexp library
13:34:53 <Philippa> ndm: would parameterising on a matcher be viable?
13:35:07 <sorear> ndm: does yhc support libraries yet?
13:35:12 <Philippa> assume that the matcher determines the pattern type
13:35:19 <centrinia> Isn't the upper bound on the size of the corresponding DNF of an n term 3-CNF supposed to be O(2^{2^n})
13:35:24 <ndm> Philippa: its already basically parameterised on the matcher
13:35:50 <ndm> Philippa: the matcher is a HOF
13:35:52 <Saizan> (~==) :: (TagComparison a) => Tag -> a -> Bool
13:36:03 <ndm> sorear, not really
13:36:16 <ndm> oh, thats even more parameterisable :)
13:36:44 <ndm> i haven't looked at tagsoup in a while, people send me patches, i apply blindly
13:36:56 <Saizan> heh, i thought regex-base was fairly standard
13:37:15 <ndm> doesn't work on Hugs at all
13:41:34 <ndm> sorear, the libraries support should be doable, actually - it doesn't support cabal, just if you have a directory under packages it will look their for libraries
13:51:21 <gwern> I'm having a bit of a senior moment here - given a tagsoup list with entries like 'TagText "NGE",TagClose "i",TagText ", ",TagOpen "a" [("href","/wiki/Gainax"),("title","Gainax")]', how I do match on just ones starting with TagOpen "a"? I want to say something like 'match TagOpen "a" _ = True", but that doesn't seem to work
13:53:29 <sorear> match (TagOpen "a" _) = True
13:53:51 <sorear> patterns are like expressions, and apposition is infixl 10
13:53:51 <gwern> why are the parentheses needed?
13:54:16 <gwern> 'apposition'?
13:54:36 <sorear> because declaration tries to mirror use, and in usage  match (TagOpen "a" foo)  is completely different from  match TagOpen "a" foo
13:54:39 <ndm> ~== TagOpen "a" []
13:54:44 <ndm> or isTagOpenName "a"
13:54:46 <ndm> i think
13:54:46 <sorear> application by juxtaposition
13:54:58 <ndm> its been too long since i looked at how tagsoup works...
13:55:08 <gwern> ndm: didn't you write tagsoup?
13:55:15 <ndm> gwern: yes...
13:55:36 <ndm> gwern: but i've accepted quite a lot of patches since then, and not looked at it for a while
13:55:40 <gwern> sorear: oh. I think I see. so without the parentheses it looks like I'm trying to do something, but with the parentheses it looks like a pattern?
13:56:01 <gwern> ndm: I'm currently whacking on the googleTechNews example so I can get a list of http links out of wikipedia articles
13:56:04 <sorear> gwern: without the parenthesis it looks like three patterns
13:56:23 <gwern> ok. that does make a certain sense
13:56:26 <ndm> gwern: that should be just a minor tweak to the googleTechNews example, i think?
13:57:17 <marcusf> hey, a newbie-question: I'm working through YAHT, and battling with an excercise about data-types. I've defined a datatype Tuple = Single a | (...) | Quad a b c d, and now I'm to write a function Tuple1 :: Tuple a b c d -> Just a. I've no clue at all about how it should look. Any helpers?
13:57:21 <gwern> ndm: mm. it's proving harder than I expected. I'm sort of close to the end, though, I think
13:57:28 <marcusf> am I all wrong here?
13:57:29 <ekidd> gwern: Depending on exactly what you're doing, you might also be interested in downloading all of Wikipedia and processing it offline.
13:57:40 <Cale> marcusf: It should pattern match against each of the cases
13:57:50 <Cale> So it will look like:
13:57:50 <chessguy> all of wikipedia? wouldn't that be huge?
13:57:56 <Cale> tuple1 (Single x) = ...
13:58:06 <Cale> ...
13:58:08 <gwern> ekidd: oh, I am very familiar with the database dumps. more than I want to be
13:58:13 <Cale> tuple1 (Quad x y z w) = ...
13:58:15 <marcusf> Cale: So I need to write tuple1 (Single a) = Just a, ..., tuple1 (Quad _ _ _ d) = Just d
13:58:18 <ekidd> marcusf: You want to name it tuple1, not tuple1. :-)
13:58:37 <gwern> ekidd: once I get it working in the googleTechNews example, I'm going to rewrite it to use interact so I can pipe through the XML article dump
13:58:47 <ekidd> chessguy: Yeah. But there's no other data set like it, unless you grab the entire web like Google.
13:58:53 <gwern> chessguy: it depends on what you want of Wikipedia
13:58:53 <Cale> marcusf: That may be a type error -- I think you want the first of the 4 values.
13:59:04 <Cale> marcusf: but essentially, yes
13:59:07 <marcusf> Cale: Ofcourse, thanks. just a typo
13:59:09 <chessguy> ermm, why is it returning a Maybe a then?
13:59:20 <ekidd> I mean, all the links between all that knowledge. Fun with data mining!
13:59:30 <gwern> chessguy: the full SQL dump is like 80 gigs and that's the really really compressed version. and let's not even talk about getting a dump of Commons/en's multimedia
13:59:49 <chessguy> only 80 gigs? that's not as bad as i thought
14:00:09 <Cale> chessguy: presumably there will be a tuple2 and so on
14:00:10 <chessguy> Lemmih!
14:00:19 <Lemmih> chessguy!
14:00:20 <chessguy> Cale, oh, duh
14:00:23 <gwern> chessguy: it uncompreses to somewhere around 200gigs, I think
14:00:37 <sorear> chessguy: the current content of WP uncompresses to 4gigs
14:00:49 <gwern> heck, just mainspace's articles in XML when compressed is a good 2 gigs and change
14:00:53 <ekidd> gwern: That's still pretty small. I saw a 750GB external drive for $199 in a store recently...
14:01:10 <sorear> chessguy: the 200gigs figure includes archive pages, which pretty much nobody wants
14:01:10 <gwern> sorear: you sure? I was pretty sure the mainspace uncompressed to around 8 gigs
14:01:44 <gwern> sorear: mirrors would want that. I know the internet archive uses the archive dumps
14:01:48 <sorear> hmm. no, I'm not sure at all
14:01:52 <sorear> in fact:
14:01:53 <sorear> -rw-r--r-- 1 stefan stefan 19G 2007-04-08 19:48 /var/cache/stefan-downloads/enwiki-20070402-pages-meta-current.xml
14:02:23 <gwern> ah, it's including the non-article space stuff as well?
14:02:35 <sorear> yeah, that file includes Talk: foo etc
14:02:40 <ekidd> sorear: 19G? That's not bad at all.
14:03:03 <ekidd> OK, time to stop procrastinating and go back to paper writing. :-)
14:05:23 <shapr> yay!
14:05:23 <lambdabot> shapr: You have 1 new message. '/msg lambdabot @messages' to read it.
14:05:35 <sorear> What's the standard symbol for return types (eg in CPS) - I know you use 'r' when you are restricted to Latin
14:08:34 <ddarius> r or a or whatever you want
14:09:11 <ddarius> It depends.  Are you talking about a monomorphic return type of "answers" or an quantified type variable?
14:09:30 <sorear> snd
14:09:34 <ddarius> Either way, there is no special treatment usually.
14:09:49 <sorear> ok
14:29:22 <ndm_> sorear, is that CPS question related to anything i'm writing?
14:31:15 * ddarius randomly darcs pulls xmonad
14:33:15 <wolverian> error, not enough interesting haskell posts in my google reader
14:33:46 <ndm> wolverian: i assume you are already RSS'ing planet?
14:33:53 <wolverian> yup
14:34:18 <ndm> you could always write an interesting post
14:34:41 <sorear> ndm: No.
14:34:43 <wolverian> I'm better at reading
14:35:01 <wolverian> hm. aldor looks like an interesting language. too bad it's not free.
14:35:06 <sorear> ndm: I'm writing hmenu, and having a little too much fun with lhs2TeX
14:35:26 <ndm> sorear: what is hmenu, and why are you using lhs2tex?
14:35:42 <ndm> i only use lhs2tex for papers and stuff, other stuff is much more pleasant in HTML
14:36:10 <sorear> a haskell menu program, and uh ... uh ... uh ...
14:36:43 <ndm> ala dmenu?
14:37:01 <sorear> very different
14:37:08 <ndm> same purpose?
14:37:14 <sorear> similar
14:37:32 <sorear> definitely intended to work with xmonad :)
14:37:44 <jcreigh> sorear: oh, nice. How does/will it work?
14:42:06 <ndm> yeah, i had wondered why people hadn't started cloning the things xmonad cooperates with closely
14:42:06 <sorear> jcreigh: code or ui?
14:42:06 * jcreigh notes that not *every* existing tool is broken. :)
14:42:06 <jcreigh> sorear: UI wise
14:42:06 * ndm notes that won't stop someone from rewriting everything in Haskell
14:42:06 <jcreigh> TouchÃ©
14:42:06 <sorear> jcreigh: pops up in the center of the screen, allows mouse and kb usage, 1 level at a time
14:42:06 * ndm remembers menu systems like that from Lotus 1-2-3 for DOS
14:42:06 * sorear doesn't :(
14:42:06 <ndm> apart from the mouse usage of course
14:42:06 <ndm> do these Haskell versions not take up more memory than C versions?
14:42:06 <sorear> ndm: Suprisingly, no.
14:42:14 <jcreigh> xmonad seems to take up an amount of memory comparable to dwm. (Maybe due to xlib overhead in both cases?)
14:42:14 <ndm> i know Gtk2Hs programs are horrible compared to C programs using the Windows API
14:42:30 <ddarius> That's understandable.
14:42:36 <sorear> ndm: Xlib contains enough data-segment bloat to dwarf the GHC RTS
14:42:57 <ddarius> xmonad doesn't build for me anymore.  I think I need a newer xlib
14:42:58 <ndm> ddarius: but means i still have to do C coding against the Win32 API, which is uber-ugly
14:43:25 <ddarius> What about using the Win32 API in Haskell?
14:43:54 <ndm> ddarius: that sounds extra painful, using a half-implemented API which is completely mis-designed for the language...
14:43:56 <wolverian> Nanar, how about using another language's gtk bindings?
14:44:01 <jcreigh> ddarius: you probably need a newer x11-extras
14:44:14 <Nanar> wolverian: ?
14:44:17 <ddarius> It was one of those things.
14:44:38 <ndm> wolverian: i think its as much gtk, as it is gtk2hs - i'd rather not use gtk at all
14:44:47 <wolverian> Nanar, sorry, that was to ndm :)
14:44:49 <Nanar> wolverian: I suspect a completion typo, because I am begginer with haskell ;)
14:45:11 <Nanar> wolverian: no pb, that happen often, include me
14:45:17 <wolverian> ndm, gtk isn't supposed to be a horrible memory hog, certainly. please submit bugs if you spot bad offenses :)
14:45:41 <ndm> wolverian: on Windows, its a lot slower than win32 api, and doesn't "respond" as quickly, very subjective
14:45:56 <wolverian> I can believe that.
14:46:07 <wolverian> though I have used gaim on win32, and it seemed ok.
14:46:09 <ddarius> Ah the README warns of exactly that.
14:46:12 <wolverian> er.. pidgin
14:54:20 <ddarius> Not that it's hard to figure out, but it would probably be beneficial to list the addresses of the X11-extras darcs repository somewhere.
14:54:52 <sorear> ndm: Note, there is no graphical Debian-type menu program compatible with xmonad.
14:55:17 <ndm> sorear, i'm sure whatever you come up with will be the one to use :) - i'm just curious why the use of lhs2tex...
14:55:36 <ndm> but i don't think i'll be moving to xmonad until you've made your windows port
14:55:36 <sorear> it's easier to read that way!
14:55:48 <ndm> the manual for hmenu?
14:55:51 <ndm> or hmenu itself?
14:55:55 <sorear> snd
14:56:28 <ndm> hmm, now i am curious
15:00:34 <gwern> hey, ndm I think I've finally got the link-extractor right
15:00:46 <gwern> probably should filter out the internal WP links though
15:01:26 <ndm> yay!
15:02:21 <hpaste>  gwern pasted "tagsoup - getting a list of URLs" at http://hpaste.org/240
15:06:41 <hpaste>  gwern annotated "tagsoup - getting a list of URLs" with "modify wp to remove internal links" at http://hpaste.org/240#a1
15:07:06 <gwern> ...oh dear. that's not quite right
15:07:56 <ndm> hmm, looks like a list comp could really cut out the two maps
15:08:13 <gwern> ndm: do you know what I'm doing wrong? It's filtering admirably, but an entire wiki page stuffed with links to other websites is only producing '["","http://wikimediafoundation.org/wiki/Fundraising","http://wikimediafoundation.org/wiki/Privacy_policy"]' when run through
15:08:13 <lambdabot> http://wikimediafoundation.org/wiki/Fundraising","http://wikimediafoundation.org/wiki/Privacy_policy"]'
15:08:32 <ndm> gwern: my knowledge of tagsoup is rather limited...
15:08:41 <gwern> ndm: oh, I don't doubt list filters could improve it, but correctness first and then readability
15:08:59 <Saizan> gwern: why not filter (~== TagOpen "a" []) tags instead of filter (isTagOpen) $ concat $ sections (~== TagOpen "a" []) tags ?
15:09:01 <ndm> gwern: often readability makes the subtle bugs more obvious
15:09:02 * gwern would like to note ndm has considerably more understanding than myself
15:10:01 <Saizan> concat . sections seems just a waste
15:10:05 <gwern> Saizan: I think that was because of the deuced nesting of tags within tags
15:10:25 <ndm> [b | TagOpen "a" [(a,b),_] <- tags, "http://" `isPrefixOf` b]
15:10:27 <Saizan> deuced?
15:10:34 <ndm> does that not do what you want?
15:10:50 <gwern> ndm: I'll take a look
15:11:07 <ndm> gwern: i think the nub, sections and concat are cancelling each other out
15:11:08 <gwern> Saizan: yes, a more mild curse than d-mned and company
15:11:53 <ndm> oh, you are requiring tags to have exactly two attributes
15:12:00 <ndm> my guess is that is why some tags get skipped
15:12:18 <Saizan> i'd use lookup "href" anyway
15:12:19 <ndm> [x | TagOpen "a" atts <- tags, (_,x) <- atts, "http://" `isPrefixOf` x]
15:12:38 <gwern> yeah, I guess my 'match _' is doing that, since I was looking for the (href, "http://...") pair
15:12:54 <ddarius> [x | TagOpen "a" ((_,x):_) <- tags, ...
15:12:58 <ndm> you don't mention href
15:13:41 <gwern> wasn't sure how to mention it
15:13:46 <ndm> i think there is a lookup attribute function, but not sure what it is
15:14:08 <Saizan> fromAttrib :: String -> Tag -> String
15:14:37 <Saizan> crashes on non-TagOpen, and returns [] if the attribute is not found
15:15:09 <ndm> my haddocks obviously aren't updating themselves properly
15:15:15 <ndm> i'll try and get that fixed tomorrow
15:15:17 <gwern> near as I can tell, let links = [x | TagOpen "a" atts <- tags, (_,x) <- atts, "http://" `isPrefixOf` x] would work
15:16:05 <ndm> should do
15:16:07 <gwern> I don't see fromAttrib in http://www.cs.york.ac.uk/fp/haddock/tagsoup/Data-Html-TagSoup.html no wonder it didn't seem too helpful
15:16:10 <lambdabot> http://tinyurl.com/ywpexa
15:16:27 <ndm> gwern: the docs are out of date, i'll fix them monday - although they should be done by cron once a day
15:16:33 * Saizan darcs getted and runghc Setup haddock
15:17:08 * gwern nods. I see. no big hurry I guess
15:18:03 <ndm> http://www.cs.york.ac.uk/fp/haddock/tagsoup/tagsoup/
15:18:11 <ndm> thats where the correct documentation is...
15:18:17 <ndm> must have screwed up the copying over script
15:21:17 <ndm> fixed :)
15:21:21 <DRMacIver> Bleh. Trying to emulate Haskell in Java makes me sad inside.
15:23:05 <Korollary> imagine how java feels
15:23:20 <DRMacIver> It deserves it.
15:23:21 <ddarius> sad outside?
15:23:44 <MyCatVerbs> DRMacIver: but it's a good excuse to give all your classes really snarky and insulting names.
15:23:55 <Korollary> that's unprofessional
15:24:12 <MyCatVerbs> DRMacIver: class TheOtherSecondClassFunction extends IHateYouMisterMcNealy
15:24:30 <Korollary> McNealy didnt hold a gun to our heads
15:24:34 <Korollary> you hate your management
15:24:55 <DRMacIver> Believe it or not, this isn't work code.
15:24:57 <MyCatVerbs> Wait, no, if we're looking to reimplement Haskell idioms in Java, that should be class SecondClassFunction implements DamnYouAllToHell.
15:25:14 <Korollary> ooh. s&m action
15:25:59 <DRMacIver> Actually mostly what I'm tring to emulate is laziness and having recursion optimised in a sensible manner.
15:26:29 <DRMacIver> I've suffered enough without defining FunctionN interfaces. :)
15:27:20 <Korollary> use scala maybe. or get some aspirin.
15:27:45 <ndm> DRMacIver: why? if not for work, why use java?
15:28:25 <hpaste>  gwern annotated "tagsoup - getting a list of URLs" with "Cleaned up version of tagsoup program" at http://hpaste.org/240#a2
15:28:30 <DRMacIver> I increasingly find I don't have a good answer to that question.
15:28:56 <DRMacIver> Normally the answer is "Libraries". In this case it's "This was a proof of concept which I didn't realise when I embarked upon it that I'd be trying to write it like Haskell"
15:29:37 <DRMacIver> Plus practice at abusing Java helps for work related stuff. :)
15:29:51 <DRMacIver> (But that's a justification more than a reason)
15:30:17 <hpaste>  ndm annotated "tagsoup - getting a list of URLs" with "never have IO [()]" at http://hpaste.org/240#a3
15:30:29 <gwern> ndm: is it bad style?
15:30:42 <ndm> gwern: usually it means you want to use mapM_ instead
15:31:19 <ndm> gwern: only build up a complex IO result if you need it, or if its easier - in this case the use of mapM_ is more efficient (much more) and shorter
15:31:29 <ndm> mapM_ is tail recursive, mapM isn't, i think
15:31:51 <gwern> oh. didn't know that it made a difference, effiency wise
15:32:10 <gwern> ndm: wait, I remember reading a long thread on haskell-cafe about how tail recursion doesn't really matter in haskell...
15:32:51 <ndm> gwern: it doesn't really mean what it used to mean in haskell, but mapM_ is quite a bit more efficient than mapM - but of course just use the one that fits your purpose best - which is mapM_
15:32:57 <ndm> saves you that return () at the end
15:33:27 <ddarius> gwern: Tail recursion still matters, but you have think about it differently.  Haskell is not just a lazy language.
15:33:38 <hpaste>  ndm annotated "tagsoup - getting a list of URLs" with "shorter" at http://hpaste.org/240#a4
15:34:14 <gwern> well, I don't really mind. it cuts off a line and a pair of brackets at the expense of another underscore, so it's a good buy length-wise
15:35:35 <gwern> anyway, thanks for the help ndm
15:37:59 <ndm> gwern: no probs, glad tagsoup is being of use
15:39:04 <gwern> sure beats hacking together something with the old unix shell tools
15:39:21 * gwern tries not to think about how complex a regexp for matching http links would be
15:39:33 <gwern> ndm: tagsoup would also work on xml, right?
15:40:44 <ndm> gwern: it sees tags, be them xml, html or otherwise
15:41:11 <gwern> ok. I was just musing about piping in the WP XML database dump
15:42:51 <ndm> should be just fine
15:43:07 <ndm> although i've not looked at the tagsoup code for a while... i know its definately lazy
15:45:28 <Saizan> mmh class Match a where match :: String -> a -> Bool with instances String, newtype Prefix = Prefix String, and (String -> Bool) might be nice for wildcard patterns..
15:45:59 <sorear> you shouldn't need tagsoup for valid XML
15:45:59 <lambdabot> sorear: You have 2 new messages. '/msg lambdabot @messages' to read them.
15:46:04 <sorear> @messages
15:46:04 <lambdabot> kosmikus said 31m 1s ago: I'm afraid it's difficult to change -- I'm very reluctant to change the underlying formatting routine because it would affect all old documents.
15:46:04 <lambdabot> kosmikus said 30m 8s ago: you can always work around such formatting problems if you're willing to use lhs2TeX as a preprocessor for both LaTeX and Haskell itself
15:46:29 <ndm> sorear, you might not need tagsoup for  valid xml, but when it comes to extracting all the links etc, it can often be faster to write and to run
15:46:35 * SamB wonders why happy produces superfluous states
15:46:50 <sorear> it's state-happy?
15:46:55 <ndm> SamB, are you 100% sure they are superfluous?
15:47:06 <ndm> SamB, the states required changes as the actions are added/removed to productions
15:47:35 <ndm> you have to remember that LALR(1) is incredibly fragile
15:51:25 <gwern> are there any functions for printing strings which are lazy?
15:51:34 <SamB> unreferenced states are probably not required for anything...
15:52:35 <Saizan> it's quite hard to print a string without forcing it..
15:55:49 <sorear> gwern: all of the standard string printing routines will print the beginning before computing the end
15:56:48 <ndm> gwern: if you turn off buffering, you may see the behaviour more clearly
15:56:52 <ndm> @hoogle setbuffering
15:56:53 <lambdabot> IO.hSetBuffering :: Handle -> BufferMode -> IO ()
16:00:20 <gwern> ok.
16:00:45 <gwern> another question: I know how to import particular typeclasses and functions, but what's the syntax for importing a data constructor?
16:01:09 <ddarius> The same.
16:01:30 <ddarius> Sorry, TypeConstructor(DataConstructor)
16:02:01 <gwern> hmm.
16:08:48 <kpreid> and TypeConstructor(..) imports all of the data constructors
16:08:51 <emu> sigh
16:14:20 <MyCatVerbs> emu: ennui much?
16:16:31 <emu> just frustration
16:25:25 <fasta> @where haskell-v8
16:25:25 <lambdabot> I know nothing about haskell-v8.
16:25:43 <fasta> What is haskell-v8?
16:26:10 <sorear> nothing, afaik
16:26:23 <fasta> http://darcs.complete.org/haskell-v8/ <- it's that
16:26:25 <lambdabot> Title: Index of /haskell-v8
16:26:41 <sorear> complete.org is CosmicRay's site
16:26:47 <chessguy> haskell for vegetarians?
16:26:51 <fasta> sorear: I know
16:27:05 <fasta> I just found something on my harddrive and wondered wth it was :)
16:27:30 <sorear> it looks like some random project of his.
16:27:33 <sorear>  @ask
16:28:03 <chessguy> @pl pH = p (h s)
16:28:03 <lambdabot> pH = p (h s)
16:28:08 <fasta> sorear: AFAIK, the idea was to write some book on Haskell
16:29:34 <Baughn> > let ($) = (*) in 2 + 3 $ 4
16:29:35 <lambdabot>  14
16:30:08 <Baughn> > let a ($) b = a * b in 2 + 3 $ 4
16:30:08 <lambdabot>      Occurs check: cannot construct the infinite type: t = t2 -> t -> t1
16:30:08 <lambdabot>     ...
16:30:29 <Baughn> > let a $ b = a * b in 2 + 3 $ 4
16:30:30 <lambdabot>  14
16:30:43 <chessguy> hmm. http://darcs.complete.org/haskell-v8/monads-v8.txt looks interesting
16:31:02 <Baughn> I'd have expected 20. Oh well..
16:41:54 <chessguy> @seen cosmicray
16:41:54 <lambdabot> I haven't seen cosmicray.
16:54:28 <int-e> > let infixr 0 $; ($) = (*) in 2 + 3 $ 4
16:54:28 <lambdabot>  20
16:54:31 <fasta> How do you make your backups of your homedir?
16:54:48 <fasta> (including source code, etc)
16:55:09 <fasta> All the GUI programs assume that the user has ordered his data perfectly.
16:56:11 <fasta> Writing it directly against cdrecord would take quite some time, I think.
16:58:57 <Baughn> fasta: rsync. ;)
16:59:27 <Baughn> int-e: Right. I'm just surprised that 0 isn't the default.
17:00:50 <sorear> @botsnack
17:00:50 <lambdabot> :)
17:01:17 <chessguy> Lemmih, ping
17:01:23 <int-e> Baughn: it's a new infix operator, so it gets the default fixity (5, and left associative I guess)
17:02:21 <Baughn> > let infixr -1 +; infixr -2 * in 2 + 3 * 4
17:02:21 <lambdabot>  Parse error
17:02:35 <Baughn> > let infixr 1 +; infixr 0 * in 2 + 3 * 4
17:02:39 <lambdabot>   Not in scope: `*'
17:03:03 <Baughn> ..how very odd, but no negative priorities for me, I see.
17:03:06 <int-e> Baughn: if you'd inherit the outer scope's fixities, added imports could change the semantics of local definitions. that sounds like a bad idea.
17:04:19 <Baughn> int-e: It would be. Considering what I just saw, though, it seems to me that 5 is the "center" of fixiness. I just assumed it was 0.
17:04:34 <int-e> ah.
17:04:40 <fasta> Baughn: isn't that a network only application?
17:04:45 <Baughn> fasta: It is
17:05:22 <fasta> Baughn: I'd like to have some my data on a more mobile medium.
17:05:30 <Baughn> fasta: For CD archival, tar still has the -g option
17:05:48 <sorear> I use tar jcf and scp
17:05:50 <Baughn> May take some assembly, but you should be able to do incremental backups
17:06:06 <Baughn> sorear: Eh? But that's so /sloow/...
17:06:16 <sorear> Baughn: cron
17:06:39 <sorear> actually that last part is wishful thinking.
17:06:45 <Baughn> sorear: With my current homedir size, and over the internet, such a cronjob would take more than a day to complete
17:06:50 * sorear needs to stop lazily evaluating backups
17:07:18 <sorear> Well I'm less prolific than you :)
17:07:29 * Baughn runs backup.sh every hour, on the dot. It takes four minutes to backup 60 gigabytes, most of which doesn'T change much.
17:07:42 <fasta> sorear: you use a machine that's not at your location?
17:07:59 <fasta> sorear: otherwise ftp would have worked too
17:08:01 <sorear> fasta: FSVO not
17:08:14 <sorear> fasta: it's about 20 feet away
17:08:28 <Baughn> rsync pipelines file transfers; scp appears not to, so rsync is still faster even on a local net
17:08:40 <fasta> sorear: why do you use scp then?
17:08:42 <Baughn> (Unless you tar things up first, I guess, but that's less handy)
17:09:08 <Baughn> fasta: Why would you ever use ftp if scp works?
17:09:19 <sorear> fasta: Because it's a WLAN (also the remote machine is not running a ftpd)
17:09:19 <fasta> Baughn: scp is slow?
17:09:30 <Baughn> fasta: rsync, then. ;)
17:09:36 <sorear> fasta: On my 802.11g network, scp is not cpu bound.
17:09:37 <fasta> Baughn: I have never gotten my 100MB network full with scp.
17:09:52 <Baughn> sorear: scp stalls every time a file is completed, however
17:09:56 <fasta> Baughn: 100Mb ;)
17:10:21 <Baughn> fasta: It should work, for a sufficiently large file
17:10:27 <sorear> Baughn: Uhm... how does it know when a file is completed?  I didn't know it could parse bzipped tarballs
17:10:36 <fasta> Baughn: maybe it were averages I saw then
17:10:48 <Baughn> sorear: I am not, of course, referring to your case
17:10:52 <twanvl> Hi, I am working on imroving the html output of haddock, would anyone like to comment? http://twan.home.fmf.nl/haddock-prime/demo/Control-Monad-State.html
17:10:55 <lambdabot> Title: Control.Monad.State -- Haddock' demo, http://tinyurl.com/ypf4en
17:11:32 <Baughn> sorear: Does scp take files on stdin, though?
17:11:42 <fasta> In my situation it would be most practical if I could boot up one of the other machines in the network at night, then do the backup, and then stop both machines.
17:11:45 <sorear> twanvl: You could use a better color scheme for the Portability... header
17:11:59 <sorear> twanvl: on my terminal it shows up as white on light grey
17:12:06 <fasta> (and then using rsync, I guess)
17:12:13 <Baughn> fasta: Tried wake-on-lan?
17:12:39 <fasta> Baughn: I have wake-on-lan and at some point it worked, but now it doesn't anymore. But I think I can solve that.
17:13:00 <twanvl> sorear: it is the same as the normal haddock colors
17:13:03 <sorear> twanvl: Also, the sumNumberedTree example would be better if it was indented further than the surrounding text
17:13:23 <chessguy> @seem bringert
17:13:24 <lambdabot> I saw bringert leaving #ghc and #haskell 45m 11s ago, and .
17:13:28 <fasta> Baughn: I need one machine that wakes at a particular time then, a bootscript that reads the time and when it's a certain time, does it's thing.
17:13:30 <chessguy> @seen bringert
17:13:30 <lambdabot> I saw bringert leaving #ghc and #haskell 45m 17s ago, and .
17:13:51 <chessguy> @bot
17:13:51 <lambdabot> :)
17:14:09 <Baughn> fasta: Sometimes the bios has an alarm clock option
17:14:21 <fasta> Baughn: yes, my BIOS has, AFAIK.
17:14:31 <Jaggederest> or wake-on-lan
17:14:53 <sorear> twanvl: there must be a css difference then, the standard haddocks for C.M.S render black-on-white
17:14:53 <fasta> Jaggederest: how can it wake when no machine is awake?
17:14:54 * chessguy sighs
17:15:11 <fasta> Baughn: are you aware of any tools to select the files I want to include in the backup?
17:15:34 <fasta> Baughn: or would that just be "find and friends"?
17:15:38 <Baughn> fasta: Based on what criteria?
17:15:48 <fasta> Baughn: e.g. no .o files
17:15:54 <byorgey> twanvl: the "Instances" list expanding when you mouse over it is clever, but sort of annoying
17:16:00 <Baughn> fasta: rsync has --exclude for that sort of thing, but it's a bit crude
17:16:08 <Baughn> fasta: "find and friends" works find
17:16:10 <byorgey> twanvl: I'd rather have a little plus that you could click on to expand it
17:16:11 <fasta> Baughn: some directories I specify that need to be added recursively.
17:16:11 <Baughn> *works fine
17:16:32 <twanvl> byorgey: I know, it should not collapse as often
17:16:39 <Baughn> fasta: Use find and friends? *shrug*
17:16:58 <fasta> Baughn: ?
17:17:18 <Baughn> fasta: I see no particular reason to look for another tool. It'd be a very short shell script in any case.
17:17:20 <fasta> Baughn: I was still enumerating the things that I needed.
17:17:51 <fasta> Baughn: in my case about 100 lines, I think. I have lots of exceptions.
17:18:07 <Baughn> fasta: rsync --files-from should be about all you need
17:18:09 <fasta> Baughn: but I could reorganize my homedir to compensate for that
17:18:55 <Baughn> fasta: If your filesystem supports extended attributes, you could try using those.
17:18:59 <twanvl> What do you think of the previews? They are only based on the url of the link and a simple javascript file, so they could also be used on the wiki for example.
17:19:08 <fasta> Baughn: ext3 doesn't I think?
17:19:23 <Baughn> fasta: It does. OTOH, lots of tools won't retain them, so it's probably a bad idea.
17:20:28 <fasta> Baughn: I think I actually have a viable plan for a backup solution now. Thank you
17:22:50 <int-e> twanvl: comparing to previous docs, I think I'd miss the synopsis, because that gave the types of the defined functions in a quite compact way.
17:23:48 <twanvl> int-e: Maybe I could make a toggle button to collapse all sections, leaving only the type signatures
17:26:02 <byorgey> twanvl: I like the previews.  It's quite useful to have that extra information accessible immediately without having to click through to a new page.
17:28:37 <int-e> twanvl: things I like: complete context for the instances, and an index on the left. personally I think it's too colorful (especially the newtype ...) (but that's really a bikeshed question), and I'd like to have the Synopsis back (which affects usability for me).
17:29:32 <int-e> twanvl: oh and if possible I'd like something that is usable without Javascript (added functionality with javascript is ok, but no information should be hidden without it).
17:30:41 <dons> moin
17:30:41 <lambdabot> dons: You have 7 new messages. '/msg lambdabot @messages' to read them.
17:33:08 -ChanServ(ChanServ@services.)- dons!i=dons@pill00.orchestra.cse.unsw.EDU.AU ACCESS [#haskell] ADD bos 38
17:33:26 <bos> dons: thanks
17:33:43 <dons> no worries.
17:38:10 <bos> wow, ghci's error messages are god's gift to book authors.
17:38:25 <bos> write a one-line expression and get half a page of the book autowritten!
17:39:44 <Korollary> Try g++ and a big class. Misspell the method name. Then wade through the candidates.
17:40:17 <bos> yeah, i've seen identifiers in excess of 4KB long from g++
17:40:30 <chessguy> anybody know if Peter Thiemann has a nick on here?
17:42:39 <emu> whenever you make a type error, ghci writes a dissertation explaining why
17:42:55 <bos> i thought it killed a kitten?
17:43:43 <Baughn> No, that's only if it catches a type error at runtime
17:44:22 <emu> unsafePerformIO killKitten
17:44:57 <Baughn> ...just so long as you don't use the value, it should be okay
17:45:06 <Baughn> What is the value of a dead kitten, anyway?
17:45:30 <chessguy> saves a trip to the grocery store
17:46:14 <emu> it puzzles quantum physicists
17:46:30 <chessguy> only when in a quantum box :)
17:46:37 <Korollary> The value of a dead kitten is not calculated until absolutely needed.
17:46:50 <Baughn> What puzzlement? A quantum kitten is perfectly reasonable.
17:47:29 <Baughn> Well, it is if you follow the many-worlds interpretation. ^_^
17:48:14 <emu> sorry, i meant, it puzzles confused old doddering Copenhagen-following physicists
17:48:49 <Baughn> I've had one of those tell me that it doesn't matter, because cats have no souls. >_<
17:49:21 <Baughn> The soul being the collapse-inducing agent. Oh my.
17:53:19 <sorear> Yow.  I was playing with SCIM, and X.org stopped respondign.  Completely.
17:53:26 <sorear> MagicSysrq++
18:05:14 <chessguy> hmmm, so i've been thinking. couldn't QuickCheck revolutionize GUI testing for haskell apps?
18:06:12 <chessguy> i mean, usually you have to get very specialized 3rd-party software to test your gui
18:06:58 <chessguy> but i would think QC could do that much better
18:08:49 <byorgey> chessguy: although it seems like it could be difficult to reduce UI testing to a collection of Boolean properties.  or maybe not... without trying it I'm not sure.
18:09:47 <chessguy> byorgey, well, you can model mouse/keyboard actions as a simple data type, which you couold make an instance of Arbitrary
18:10:14 <chessguy> and then have certain invariants that should be true after any sequence of actions
18:10:20 <byorgey> chessguy: true.
18:10:43 <chessguy> and also specific interactions which should always cause certain things to be true
18:11:20 <byorgey> chessguy: I guess it would be useful, although you would probably want to mix in some other testing methods as well
18:12:56 <chessguy> yes, but the idea is that once you are aware of any particular kind of misbehavior, you can almost guarantee to be able to eliminate it
18:13:39 <byorgey> chessguy: that's true.
18:13:52 <byorgey> chessguy: has no one ever used QC for UI testing before?
18:13:57 <chessguy> beats me
18:15:36 * byorgey goes off to make cookies
18:25:16 <emu> @hoogle modexp
18:25:16 <lambdabot> No matches found
18:27:10 <emu> is there a modular exponentiation floating around base?
18:27:13 <sorear> emu: If you define an instance of Num for Z mod whatever, (^) will work fine
18:27:38 <sorear> emu: not explicitly, but overloading will make one if you provide modular arithmetic
18:27:47 <emu> eh, i'll just write one real quick
18:27:50 <sorear> (^) uses squaring, so it will do fine as modexp
18:27:54 <sorear> @src (^)
18:27:54 <lambdabot> Source not found. I've seen penguins that can type better than that.
18:27:57 <sorear> @src ^
18:27:57 <lambdabot> Source not found. Do you think like you type?
18:29:11 <ndm> @seen Shimei
18:29:11 <lambdabot> Shimei is in #xmonad and #haskell. I last heard Shimei speak 5h 37m 50s ago.
18:29:27 <emu> seems like a pain in the butt to write the instance though
18:35:28 <stepcut> ndm: I have a complaint about v_fail_n
18:35:35 <ndm> stepcut: go on? is it wrong?
18:35:54 <stepcut> n is not unique between functions
18:36:00 <ndm> indeed
18:36:14 <stepcut> it seems like all the other variables get nice unique names, but not v_fail_n
18:36:16 <ndm> do you want it to be?
18:36:44 <ndm> uniqueVars = runFreeVars . uniqueBoundVarsCore
18:37:15 <ndm> stepcut: just run uniqueVars over your Core first, then you get unique variables everywhere - Yhc does not guarantee that variables within functions are unique, and indeed they may not be in some situations
18:37:47 <stepcut> ok. In general, I am not clear what, if anything, Core promises
18:38:10 <ndm> there is a page on the invariants in Yhc.Core
18:38:19 <stepcut> ok, I will look there
18:38:37 <SamB_XP> hmm, exalead went from 146 indexed wiki pages to 226
18:38:40 <ndm> stepcut: http://haskell.org/haskellwiki/Yhc/API/Core#Invariants
18:38:41 <lambdabot> Title: Yhc/API/Core - HaskellWiki
18:38:59 <SamB_XP> yahoo went from 25 to 45
18:38:59 <stepcut> ndm: cool
18:39:02 <ndm> stepcut: we are working on an invariant based model for Yhc.Core - where you can say what invaraints you want, and it ensures them
18:39:18 <SamB_XP> google found descriptions for most of the ones it already had...
18:39:24 <twanvl> int-e: I added a 'synopsis view' that collapses all sections. Same url, http://twan.home.fmf.nl/haddock-prime/demo/Control-Monad-State.html
18:39:26 <stepcut> ndm: nifty
18:39:27 <lambdabot> Title: Control.Monad.State -- Haddock' demo, http://tinyurl.com/ypf4en
18:39:53 <ndm> stepcut: what are you trying to do with Yhc.Core?
18:40:08 <SamB_XP> live.com seems to have the same number of results...
18:40:15 <stepcut> ndm: same as before, yhc->flash byte code
18:40:23 <ndm> stepcut: ah, cool :)
18:40:44 <stepcut> ndm: I think I am somewhat close to making recursive functions work correctly
18:40:52 <ndm> yay!
18:40:54 <stepcut> ndm: then I have to figure out updates and garbage collection
18:41:04 <stepcut> ndm: and then I have to dump it and start over  ;)
18:41:25 <ndm> stepcut: well if you do want to put anything in the central Yhc repo, let us know (send us a public key and you can have commit access)
18:41:53 <int-e> twanvl: works for me.
18:42:00 <stepcut> ndm: sure, when it does something that ressembles working
18:48:57 * SamB_XP wonders if he still has commit access -- has a vague idea that the yhc repo has moved
18:49:23 * sorear has commit access, and has never used it
18:49:57 <SamB_XP> isn't it nice to be able to google the wiki again?
18:50:30 <SamB_XP> hmm, not too many hits for optimization...
18:51:40 <SamB_XP> hmm, still a number of pages for google to crawl...
18:52:02 <SamB_XP> like www.haskell.org/haskellwiki/Performance
18:52:14 <SamB_XP> and www.haskell.org/haskellwiki/Performance/GHC
18:53:25 <SamB_XP> It's kind of funny the way you see some pages in the results twice, once with and once without the www.
18:54:19 * SamB_XP wonders if getting search results including a page increases it's crawl priority
19:00:52 * SamB_XP wonders how google knows about all the Performance pages on the wiki...
19:03:26 <SamB_XP> are we supposed to have non-english pages on our wiki? http://haskell.org/haskellwiki/Programare_Functionala_-_O_introducere_utilizand_limbajul_Haskell
19:03:29 <lambdabot> Title: Programare Functionala - O introducere utilizand limbajul Haskell - HaskellWiki, http://tinyurl.com/yo8pss
19:04:05 <SamB_XP> also maybe they should have some kind of dedicated namespace?
19:10:00 <daniel_larsson> The main page is in /Ro at least
19:10:58 <SamB_XP> heh
19:11:22 <SamB_XP> apparantly if another Haskell compiler can beat GHC's performance for a particular program, it counts as a bug.
19:11:32 <sorear> Yep.
19:11:47 <sorear> JHC did that once.  It was reported and fixed.
19:11:48 <SamB_XP> I hope that doesn't last for too long
19:11:52 <SamB_XP> cool
19:11:59 <SamB_XP> so we have while loops in generated code now?
19:12:06 <SamB_XP> or for loops?
19:12:28 <SamB_XP> (or did they use -fasm instead?)
19:12:44 <sorear> no, but we do have goto loops
19:12:52 <sorear> not even indirect
19:13:05 <SamB_XP> oh. were they indirect before?
19:13:26 <sorear> yeah
19:14:09 <SamB_XP> JohnMeacham had seemed to indicate that the problem was the use of goto loops
19:14:30 <SamB_XP> but I can't blame him for not being able to detect an indirection in the GHC output...
19:14:59 <SamB_XP> ... that stuff is really hard to read
19:19:19 * SamB_XP discovers that he doesn't know how to pronounce the name of the country Igloo is from
19:22:48 * sorear can't even remember which of Liechtenstein and Lithuania it is!
19:23:46 <SamB_XP> Liechtenstein
19:24:05 <SamB_XP> I know how to pronounce lithuania
19:24:32 * byorgey knows how to pronounce "Liechtenstein" but is unsure how to explain it over IRC
19:24:56 <daniel_larsson> lich-ten-stein (german "stein") sort of :)
19:25:07 <SamB_XP> oh, okay.
19:25:14 <SamB_XP> that was the only idea I could come up with...
19:25:34 <byorgey> also, german "ch" in "Liech", as in "Bach"
19:25:42 <SamB_XP> well yeah
19:26:18 <SamB_XP> that *is* how you pronounce the word lich, isn't it?
19:26:22 <daniel_larsson> Hmm... as in Bach? ...
19:26:44 * byorgey didn't know "lich" was a word?
19:27:07 <SamB_XP> isn't it related to necromancy?
19:27:24 <hpaste>  Boney pasted "Parametric type instace of Monad" at http://hpaste.org/241
19:27:42 <byorgey> SamB_XP: oh, ok, I guess I've heard of that but I've no idea how it's pronounced.
19:27:47 <Boney> ok. so that's what announce does.
19:27:49 <daniel_larsson> "In modern fantasy fiction, a lich (sometimes spelled liche) is a type of undead creature" (WP)
19:28:19 <Boney> I'm having trouble making my type "Result a b" an instance of Monad
19:28:21 <byorgey> "The standard pronunciation of lich rhymes with itch, but it is sometimes pronounced 'like'." (from the same page)
19:28:36 <SamB_XP> oh.
19:28:45 <daniel_larsson> Hmm, ok, not how I thought it was pronounced :)
19:30:08 <Boney> Does somone know what I'm doing wrong?
19:30:45 <SamB_XP> oh, look, someone is on-topic
19:31:12 <hpaste>  byorgey annotated "Parametric type instace of Monad" with "should work? (untested)" at http://hpaste.org/241#a1
19:31:15 * chessguy stares at Boney 
19:31:19 <kpreid> Boney: you need to swap a and b, and leave out a in the Monad instance
19:31:36 <Boney> Thanks.
19:31:42 <byorgey> Boney: what kpreid said is exactly what I just did in the annotation.
19:31:50 <Boney> ah ic.
19:31:51 <kpreid> Boney: why not just use Either?
19:32:07 <byorgey> Boney: a Monad has to have kind (* -> *), i.e. it takes some type and produces a new type.
19:32:46 <Boney> kpreid: I wanted to illistrate the semantics I want by lableing my constructors with Success and Fail.
19:33:14 <Boney> byorgey: I'm confused by a class having a kind like this.\
19:33:43 <SamB_XP> Boney: you could have cut/pasted the Monad (Either a) instance
19:33:48 <byorgey> Boney: are you confused about kinds in general?  Or just about kinds in the context of a class?
19:34:07 <Boney> byorgey: probably the latter, but I'm unsure.
19:34:36 <Boney> Is 'kind' the word for the number of arguments something takes, it's arrity?
19:34:48 <byorgey> Boney: no
19:34:48 <sorear> Boney: kind : type :: type : value
19:35:03 <Boney> SamB_XP: I didn't realize (Either a) was a monad.
19:35:18 <SamB_XP> @instances Monad
19:35:19 <lambdabot> ((->) r), ArrowMonad a, Cont r, ContT r m, Either e, ErrorT e m, IO, Maybe, RWS r w s, RWST r w s m, Reader r, ReaderT r m, ST s, State s, StateT s m, Writer w, WriterT w m, []
19:35:37 <byorgey> Boney: the type of any simple piece of data (like 3 or [1,2,6], etc.) has kind *
19:36:02 <Boney> ok.
19:36:14 <byorgey> Boney: so e.g. Integer has kind *.
19:36:30 <byorgey> Boney: then you have things like, e.g. the list constructor [], which has kind * -> *
19:36:36 <Boney> is the * supposed to look like a wild card.
19:36:41 <Boney> OH IC
19:36:44 <byorgey> Boney: right, it can stand for any type
19:36:57 <byorgey> Boney: since [] takes a simple type and makes it into a new type (a list of blah).
19:36:58 <Boney> so Either a b has kind * -> * -> *
19:37:08 <byorgey> Boney: right!
19:37:18 <Boney> since it takes 2 other types to make it's self erm, concrete.
19:37:21 <byorgey> Boney: well, technically, Either has kind * -> * -> *.
19:37:50 <byorgey> Boney: if you include the a and the b, Either a b just has kind *.
19:38:01 <byorgey> and Either a has kind * -> *.
19:38:02 <Boney> Ok.  So why does Monad have a kind when it is not a type but a typeclass?
19:38:32 <daniel_larsson> To make a monad instance, the type needs to be kind * -> *
19:38:36 <byorgey> Boney: Monad doesn't have a kind; it's just that any type which is an instance of Monad must have kind * -> *.
19:38:44 <chessguy> Boney, think of it this way: a monad accept type arguments
19:38:45 * SamB_XP wishes monad had a kind
19:38:53 <chessguy> (an instance of monad, that is)
19:38:55 <SamB_XP> then I could find out what kind it was by...
19:39:02 <SamB_XP> :k Monad
19:39:04 <lambdabot> Class `Monad' used as a type
19:39:14 <byorgey> SamB_XP: yeah, that would be nice
19:39:21 <chessguy> :k Tree
19:39:23 <lambdabot> * -> *
19:39:32 <SamB_XP> :k (Either a)
19:39:34 <lambdabot> Not in scope: type variable `a'
19:39:37 <SamB_XP> aww.
19:39:42 <daniel_larsson> :k (Either String)
19:39:44 <lambdabot> * -> *
19:39:56 <SamB_XP> :k (forall a. Either a)
19:39:58 <lambdabot>     `Either a' is not applied to enough type arguments
19:39:58 <lambdabot>     Expected kind `*', but `Either a' has kind `* -> *'
19:39:59 <Boney> I can see a pattern, [] has kind * -> * and Mabye has kind * -> *.
19:40:02 <kpreid> :k IO
19:40:03 <lambdabot> * -> *
19:40:05 <Boney> which are both Monads.
19:40:08 <kpreid> :k Maybe
19:40:09 <SamB_XP> what the heck?
19:40:10 <lambdabot> * -> *
19:40:11 <byorgey> Boney: right.
19:40:25 <Boney> but I don't see why Monad instances must have this kind.
19:40:44 <SamB_XP> Boney: if they had other kinds, the Monad methods would have kinds other than *
19:40:55 <SamB_XP> or, rather, would be ill-typed...
19:40:58 <chessguy> Boney, because they are a type class. that is, they accept a type as an argument, and return a type
19:40:59 <kpreid> :k StateT () Identity
19:41:01 <lambdabot> * -> *
19:41:02 <SamB_XP> and ill-kinded
19:41:10 <int-e> :k Control.Monad.RWS.RWST
19:41:12 <lambdabot> * -> * -> * -> (* -> *) -> * -> *
19:41:15 <kpreid> Boney: to allow the value carried by monadic values to have different types while using the same instance.
19:41:41 <SamB_XP> the term "constructor class" comes to mind...
19:41:48 <chessguy> Boney, think of it this way. what does it mean when i say data Tree a = Leaf a | a (Tree a) (Tree a)
19:42:14 <chessguy> what is Tree, in that case?
19:42:18 <Boney> chessguy: that's a paremetric type, of a tree.
19:42:23 <Cale> Leaf a | Branch a (Tree a) (Tree a)
19:42:32 <chessguy> yeah, typo, sorry
19:42:34 <Boney> a hetrogenious tree.
19:42:39 <Boney> of any type.
19:42:41 <chessguy> Boney, what do you mean by parametric?
19:42:51 <chessguy> yes
19:43:04 <Boney> it's a type which takes a parameter of another type.
19:43:09 <Cale> Boney: Tree takes a type a and gives the type of binary trees of a's.
19:43:17 <Boney> giving a-ha, a third type.  Like you where saying about the Monad.
19:43:19 <chessguy> so it accepts a type, any type, and creates a new type, a tree of that type
19:43:53 <chessguy> that's what * -> * mean
19:43:54 <chessguy> s
19:44:23 <Boney> that's a really funcional flavor to classes, types and functions..
19:45:22 <Boney> Ok.  So all typeclasses have kind * -> *?  (Otherwise I'd imagine instance declrations getting very messy).
19:45:41 <chessguy> :k Either
19:45:43 <lambdabot> * -> * -> *
19:45:53 <chessguy> @src Either
19:45:53 <lambdabot> Source not found. Are you on drugs?
19:46:09 <chessguy> lambdabot, not nearly often enough
19:46:14 <Boney> Either is not a monad but Either e is?
19:46:28 <chessguy> @kind Either String
19:46:28 <Boney> which is * -> *.
19:46:29 <dons> right.
19:46:30 <lambdabot> * -> *
19:46:51 <byorgey> Boney: so what about your Result type?
19:46:57 <Cale> All instances of Monad have kind * -> *
19:47:15 <Boney> Cale: does that extend to all instaces of any class?
19:47:18 <Cale> no
19:47:35 <Cale> Most classes have parameters with type *
19:47:36 <chessguy> Boney, i just proved that it doesn't extend to all instances
19:47:39 <Cale> er, kind *, rather
19:48:10 <daniel_larsson> chessguy: Boney asked about typeclasses though, not types
19:48:22 <Cale> For example, Ord is a class, and an instance of (Ord a) defines a method (<) :: a -> a -> Bool
19:48:38 <Boney> Cale: I didn't get that, you showed :k Either which AFAIK isn't an instance of any particular class.
19:48:39 <Cale> So 'a' is just supposed to be an ordinary type there.
19:48:52 <chessguy> hey dons, do you know if stuff in http://darcs.complete.org/haskell-v8/ is going in the book?
19:48:53 <lambdabot> Title: Index of /haskell-v8
19:48:54 <Cale> Either could be an instance of some class
19:49:22 <chessguy> Boney, err, you're right, sorry
19:49:26 <Cale> But on its own it's not, though Either a b is an instance of Eq whenever a and b both are.
19:49:38 <Boney> ah.
19:49:46 <chessguy> Boney, you caught me doing too many things at once :)
19:49:50 <Cale> I could define my own class:
19:49:53 <Boney> That example of Eq (Either a b) helped.
19:49:56 <Cale> class Foo e where
19:50:02 <Cale>   foo :: e a b -> Bool
19:50:27 <Cale> and then I could define an instance Foo Either where foo (Left x) = True; foo (Right y) = False
19:53:00 <Boney> ok.  there's one thing left..  to make my program work byorgey swapped a and b in my type Result a b making it Result b a
19:53:17 <Boney> and changed my instance declaration to be Monad (Result b)
19:53:20 <Cale> hmm, I came in late
19:53:30 <Boney> I understand why this is Monad (Result _)
19:53:43 <Cale> I think I've found the paste...
19:53:45 <byorgey> Boney: you could do it either way, actually
19:53:49 <Boney> but I don't understand why b is choosen or why a and b have been swapped.
19:53:56 <Cale> oh, right...
19:54:01 <byorgey> Boney: it just makes more sense to have the monad instance parameterized on the Success type
19:54:11 <Cale> Note that for any failure type, your type is a monad
19:54:34 <Boney> byorgey: byorgey what are the concequences?
19:55:14 <Cale> That is, for any b,  (/\a -> Result a b) is a monad, where /\ is type-lambda. But Haskell doesn't have type-lambda.
19:55:17 <byorgey> Boney: the way I did it, throughout an entire monadic computation (i.e. do-block) you'd have to use the same failure type, but could have different success types
19:55:25 <Cale> But it does have partial application of type constructors
19:55:41 <Boney> byorgey: ah awesome!
19:55:55 <byorgey> Boney: that makes more sense than being able to have different failure types but being stuck with the same success type
19:55:56 <Cale> So if you define it like  data Result b a = Success a | Fail b, then Result b is a monad for any b
19:56:45 <Boney> byorgey: yes.  once something fails the type of the failure is not going to change.
19:56:55 <Boney> but I will want to change the type of the success.
19:56:55 <Cale> Yeah, you could do it the other way around, but Success would act like you'd expect failure to behave :)
19:56:58 <Boney> cheers.
19:57:07 <byorgey> Boney: right.
19:57:22 <chessguy> Cale, just an implementation detail :)
19:58:36 * byorgey wishes there was a way to share chocolate chip cookies over IRC
19:59:10 <Boney> byorgey: if there was.  I would have introduced many many people to Tim Tams.
19:59:29 <byorgey> Boney: is that a type of cookie?
19:59:29 <Baughn> Boney: There is the Cookie Transfer Control Protocol
19:59:51 <chessguy> by the way, cale, what do you think of http://darcs.complete.org/haskell-v8/monads-v8.txt (other than the lack of formatting)? looks like an interesting way to think of monads in terms of DSLs
19:59:59 <Boney> and for all those times on IRC when somone has offered me a beer for helping them,  And I would give you guys beers right now.
20:00:21 <Boney> byorgey: Yep.  Sold here in Australia.
20:00:27 <Boney> it's very very popular.
20:00:50 <Boney> http://en.wikipedia.org/wiki/Tim_Tam
20:00:51 <lambdabot> Title: Tim Tam - Wikipedia, the free encyclopedia
20:00:54 <chessguy> oh, i thought for a minute that Tim Tams was the name of a famous chef or something, i was confused
20:01:14 <byorgey> Boney: ah.  Well, someday when I visit Australia I'll have to try some! =)
20:01:36 <Cale> chessguy: yes, that's the right way to think about it
20:02:04 <chessguy> Cale, interesting stuff. i wonder if it's going to go in their book
20:02:20 <chessguy> (that's CosmicRay's site)
20:03:03 <byorgey> chessguy: CosmicRay is one of the authors of Real-World Haskell?
20:04:49 <chessguy__> byorgey, yes
20:05:27 * chessguy sighs
20:05:30 <chessguy> stupid wireless
20:09:18 <chessguy> legos would be an interesting analogy for monads. i'm not sure how that would work
20:09:37 <SamB_XP> transformers...
20:10:33 <chessguy> well, where you have transformers, you have to have monads :)
20:11:01 <byorgey> chessguy: legos?  hmm...
20:16:53 <emu> is it possible to define an expmod function which operates entirely without overflow in Int or Word (assuming smaller modulus)?  Montgomery exponentiation looks promising.
20:18:40 <dons> legos are like functions though. and the types describe the ways  they can click together.
20:18:49 <hpaste>  Boney annotated "Parametric type instace of Monad" with "Tested corrections." at http://hpaste.org/241#a2
20:18:52 <dons> things like flip / (.) / const let you join them on different stubs.
20:53:18 <TSC> Wow, scrapping my boilerplate is great
20:53:52 <Jaggederest> how's that?
20:59:51 <dmead> is there a channel where hardware gurus hang out ?
21:01:46 <bos> not that i know of.
21:02:01 <bos> what kind of hardware?
21:02:14 <bos> kitchen knives? atomic force microscopes?
21:23:52 <Paredes> Hi. I need some sort of way to interface Java with Haskell. I checked Lambada but I think it is way more complex than what I need, I just need to pass some output from an Haskell program to Java.
21:25:32 <Philippa> Paredes: FFI + JNI?
21:26:55 <Paredes> thank you
21:27:00 <Paredes> I'll check that
21:56:16 <xpika> has anyone here used glade to show an image
21:58:10 <wolverian> anyone know how to use a panel, e.g. kicker or gnome-panel in xmonad?
21:58:28 <wolverian> they want to show as normal windows for me, which is a bit suboptimal
22:01:49 <wolverian> hm, apparently randall munroe, of xckd fame, uses ion3 :)
22:01:49 <wolverian> I'm sure we can turn him to xmonad..
22:01:49 <dons> mmm.
22:01:49 <dons> wolverian: yeah, there's a demo for how to use kicker on the web site
22:01:58 <dons> basically, it is a dock app, so doesn't set 'override-redirect'.
22:02:04 <dons> currently, the solution is to manually unmanage it.
22:02:21 <dons> dzen's a fair bit nicer, but we do plan full dock app support for 0.3
22:06:57 <wolverian> I don't know how to manually unmanage arbitrary programs, and the FAQ doesn't tell me how to do it for even e.g. kicker
22:06:57 <wolverian> did I miss a page specifically on it?
22:06:57 <wolverian> dzen is nice, but I miss my notification area..
22:06:57 <ivanm> dons: what kind of timeframe you looking at for 0.3?
22:06:57 <lambdabot> ivanm: You have 1 new message. '/msg lambdabot @messages' to read it.
22:06:57 <dons> about hmm, 3 weeks.
22:06:57 <ivanm> *nod*
22:06:57 <dons> wolverian: on the mailing list only. you can bind a key to:   withFocused unmanage
22:06:57 <wolverian> dons, ah. thanks!
22:06:57 * ivanm is amazed how fast xmonad is being written
22:06:57 <wolverian> uh.. also.. how do I move a window to the gap space? :)
22:06:57 <dons> wolverian: right, you pull it into the floating layer. (mod-button1 drag)
22:06:57 <sorear> manually
22:06:57 <dons> then set it in place, resize as required. then unmanage.
22:06:57 <dons> that works for now. a quick hack
22:06:57 <dons> sjanssen: is that how you did the kicker?
22:06:57 <dons> ivanm: we got tabbed mode today
22:06:57 <wolverian> xmonad has a floating layer? heh. nice.
22:07:00 <dons> yeah, in the darcs version.
22:07:05 <ivanm> dons: ohhh, nice...
22:07:14 <ivanm> yeah, I've been trying to keep track of the mailing list
22:07:16 <wolverian> oh, right. getting that
22:07:16 <dons> its just an extension script david roundy wrote.
22:07:31 <ivanm> I'll have to look at xmonad a bit more when exams are over
22:09:21 <xpika> my glade image is not showing :(
22:13:49 <sjanssen> wolverian, dons: yeah, I just unmanaged kicker (with an extra keybinding)
22:14:07 <sjanssen> it moved to the bottom of the screen by itself
22:18:58 <ivanm> sjanssen: any way of setting up the config file for that to happen automatically?
22:19:10 <sjanssen> ivanm: not at the moment
22:19:13 <ivanm> or do you have to do that each time you start xmonad?
22:19:14 <ivanm> :(
22:19:49 <sorear> ivanm: -geometry
22:20:11 <ivanm> hmmm
22:20:18 <sorear> ivanm: every standard X program will let you do -xrm '*overrideRedirect: True' -geometry '1024x15+0+0
22:20:21 <sorear> '
22:20:34 <sorear> note that gtk programs are not X programs :(
22:21:01 <ivanm> they aren't? :(
22:21:06 <ivanm> @slap gtk
22:21:06 * lambdabot smacks gtk about with a large trout
22:21:10 <wolverian> help! I moved gnome-panel with mod-button1 and now I can't change focus with mouse and windows don't resize to fill the window!
22:21:10 <ivanm> yay!
22:21:12 <ivanm> @botsnack
22:21:13 <lambdabot> :)
22:21:34 <wolverian> am I in some strange mode?
22:21:55 <wolverian> oh, wait. I _can_ change focus with mouse, xmonad just doesn't draw the outline for me. hm. I wonder if it's running at all :)
22:22:08 <wolverian> no, it isn't.
22:23:20 <wolverian> hrm. how do I resize the panel window? now that xmonad is running, it only shows half of gnome-panel.
22:23:35 <wolverian> (and is still drawing the focus border around it, even though the focus is not on it.)
22:23:36 <sjanssen> wolverian: edit Config.hs
22:23:49 <wolverian> sjanssen, hm?
22:24:15 <sjanssen> wolverian: the status dimensions are stored in Config.hs
22:25:44 <wolverian> I can only find the gap size there, not "resize unmanaged windows to this size"
22:25:59 <wolverian> I meant it shows half of gnome-panel horizontally.
22:26:43 <sjanssen> oh, you've already unmanaged it?
22:26:56 <wolverian> yes.
22:27:09 <sjanssen> xmonad can't do anything then
22:27:13 <wolverian> oh.. I see. I can always fullscreen it first
22:27:22 <sjanssen> wolverian: this really isn't supported yet
22:27:39 <sjanssen> (this being correct management of statusbars)
22:30:15 <wolverian> I'll wait for 0.3 then :)
22:33:19 * ddarius would hack on xmonad, but it does everything he wants already.
22:33:22 <ddarius> (and then some)
22:34:22 <dr_strangelove> I have a data type:   data MyMap = forall s. (Show s, Read s) => MyMap Map Int s
22:34:53 <dr_strangelove> cat I derive read and show somehow automatically?
22:35:16 <dr_strangelove> deriving (Read, Show) doesn't work
22:35:30 <ddarius> That isn't copied and pasted from your code is it?
22:35:43 <dr_strangelove> no
22:35:54 <Cale> dr_strangelove: why not just make it a Map Int String ?
22:36:16 <ddarius> But if you tried it and it doesn't work then the answer is no.  You could try some of the Derive type stuff, but I doubt it will do any better.
22:36:37 <ddarius> It should be easy enough to do yourself.
22:36:59 <Cale> What's the point of having an instance of Read on an existential datatype?
22:37:09 <ddarius> crap!
22:37:11 <dr_strangelove> Cale, s can be different types
22:37:19 <Cale> er, I mean, in the sense that you've included Read as a constraint on s
22:37:54 <dr_strangelove> Cale, I want to serialize and deserialize the data
22:38:14 <Cale> Think about how you'd write read manually, not knowing the type s
22:38:20 <ddarius> dr_strangelove: The only thing you can do is convert it to and from a String, so you might as well just have a String.
22:38:24 <Cale> You couldn't, right?
22:38:52 * ddarius will have to rip his DVD in Windows.
22:39:01 <Cale> ddarius: hmm?
22:39:05 <ddarius> Or mount the NTFS partition as RW.
22:39:11 <Cale> ah
22:39:17 <dr_strangelove> Cale, I could call the read function for s
22:42:03 <Cale> But you don't know what s is.
22:42:18 <Cale> Let's take a simpler example
22:42:35 <Cale> data Readable = forall s. (Read s) => Readable s
22:43:23 <sorear> re.
22:43:34 <Cale> How would you implement read for that?
22:43:48 <Cale> (or readsPrec, really)
22:44:17 <dr_strangelove> well, perhaps you need another (Type s) constraint
22:44:39 <Cale> You need to know what type of value you're trying to read in in order to apply read
22:44:55 <Cale> but you can't possibly know that, unless you just pick a type arbitrarily
22:45:25 <dr_strangelove> yes, with show you write:   show s = typeOf s ++ ":" ++ show s
22:46:10 <Cale> nope, because you've already forgotten that
22:46:20 <Cale> The type isn't around at runtime.
22:46:36 <Cale> All types are erased by compilation.
22:46:50 <dr_strangelove> does it work with Data.Typeable?
22:47:34 <Cale> Data.Typeable gives you a way to explicitly record the types of things, supposing you haven't already forgotten them with the use of existentials.
22:48:45 <Cale> You can think of applying the existential constructor as being a way to forget the original type and only remember that it belongs to certain classes.
22:50:16 <Cale> You can write generic serialisation for Typeable values, and that's actually done in Data.Generic
22:50:37 <Cale> But it's sort of a strange way to do things
22:50:51 <Cale> Data.Generics, rather
22:51:00 <dr_strangelove> why is it strange?
22:51:53 <Cale> Because you usually know which types you actually support.
22:52:28 <Cale> and in this case, there's no real difference between your type and  Map Int String  anyway.
22:52:53 <Cale> If all you know is how to show the values, what you really have are strings.
22:53:36 <dr_strangelove> It is good for modularisation. you can write plugins and don't have to modify the core system
22:54:24 <Cale> Yeah. It's always possible to re-encode things to avoid using existentials though, by storing functions instead.
22:54:47 <Cale> (or at least, almost always, as I don't really have a proof of that handy)
22:56:11 <Cale> Though, if what you're storing amounts to a bunch of class dictionaries, existentials can save you effort.
22:56:17 <xpika> hi
22:56:21 <Cale> hi
22:56:47 <xpika> does anyone know the GHC option for just checking and not compiling or a list of all the ghc compile options?
22:57:28 <sorear> Yes!
22:57:31 <sorear> -fno-code
22:57:35 <sorear> and the manual
22:57:43 <Paredes> :)
22:57:46 <sorear> http://haskell.org/ghc/dist/current/docs/users_guide/index.html
22:57:46 <lambdabot> Title: The Glorious Glasgow Haskell Compilation System User's Guide, Version 6.7.200706 ...
22:59:29 <sorear> note that -fno-code takes effect rather late in the compilation pipeline, so you should still use -Onot
23:00:32 <sorear> goodnight all.
23:45:22 <ttfh> at my university, we had a course, "Object Oriented Modelling" or something like that, which I took many years ago. We used UML to modell stuff. How does this modelling fit in with functional programming? Do you have to modell differently in some way? my intuition is that you should be able to model in about the same way
23:47:11 <ulfdoz> ttfh: Imho Sequence-diagrams are the only feature really applicable for haskell.
23:47:57 <dons> since modelling state changes isn't so relevant.
23:48:48 <dons> in fact, the first hit for UML Haskell seems to be a guy who points out UML has far too much emphasis on stateful, mutable data
23:48:58 <dons> objects, any way
23:50:15 <Korollary> UML is not used much even in the OOP community
23:50:27 <ulfdoz> Yes, I think that's the point. Controll flow orientation vs. state orientation. As there is no object with a state, control flow matters.
23:50:45 <weitzman> That kind of system might be more applicable to an application that using something in the spirit of concurrent ML
23:51:06 <weitzman> If each thread acted like an object
23:51:14 <Korollary> As a formalism UML has not proven itself worthy of its own overhead.
23:51:28 <Korollary> And it's got a lot of overhead
23:51:38 <dons> and for formalising Haskell, you certainly wouldn't go the UML path
23:51:45 <ulfdoz> Korollary: Yes, unfortunately many universities like the colourful pictures.
23:51:55 <dons> not the good ones ;) mwhaha
23:52:03 <ttfh> ulfdoz: they definitely do
23:52:18 <Korollary> ulfdoz: They sorta feel obligated to use something I think.
23:53:46 <ttfh> Hmmm, now that I'm almost done with my education, I wish I'd questioned the teachers more, but I don't think I had the knowledge to do so then
23:54:02 <Korollary> In the end it comes down to whether class A should be coupled with class B or where should method X be. The pictures don't point to the solution. It's mostly personal taste of developers.
23:54:09 <dons> speaking of colourful pictures, i can't wait to find a use for this tool, http://prefuse.org/gallery
23:54:10 <lambdabot> Title: prefuse | gallery
23:54:29 <dons> just a pity language papers tend not to have very rich data
23:54:29 <ulfdoz> From my experiences, UML is a complete waste of time if you don't exactly know what you want. It does not help to find out, what you actually want. Often the design is heavily constrained from third party libs, which are not known well enough at the design stage.
23:54:34 <weitzman> I think UML is more commonly used as an explanitory tool rather than a design tool
23:54:44 <weitzman> Written on whiteboards, erased shortly later
23:54:47 <weitzman> At least, I hope that's the case
23:54:58 <weitzman> Surely more people are trying to understand systems any give day then create them
23:55:03 <weitzman> *given
23:55:10 <dons> weitzman: but we use haskell for that now :-)
23:55:23 <dons> at least around where i work, haskell is the whiteboard notation of choice.
23:55:24 <Korollary> That's what you read in most OOD books. "Draw simple diagrams on the whiteboard."
23:55:50 <dons> then again, around where i work, \alpha is variable name of choice.
23:55:58 <opqdonut> :)
23:55:59 <Korollary> dons: That'll change
23:56:05 <Korollary> You'll get used to it
23:56:31 <dons> Korollary: what, at my new job? :-)
23:56:53 <Korollary> dons: Yes. Or will you be doing research there?
23:57:02 <ulfdoz> In my projects, I gave up, drawing UML diagrams before implementing. This doesn't work. Instead I generate them automatically with the source code documentation.
23:57:06 <dons> hacking + research
23:57:12 <flux> dons, but haskell isn't pretty pictures :(
23:57:22 <dons> we'll see how much uml they use...
23:57:22 <Korollary> Pictures aren't pretty anyway
23:57:31 <dons> ulfdoz: hah
23:57:34 <Korollary> We're talking about boxes and lines
23:58:11 <dons> anyone know of a tool for computing cyclomatic complexity of haskell source?
23:58:26 <weitzman> Some figures are pretty. I've always wondered of grad students and professors actually have massive skills with graphviz and whatnot or whether making figures is as painful for them as for me
23:58:35 <Korollary> dons: Isn't CC bogus anyway?
23:58:36 <flux> korollary, potentially with shading! and lines can have curves!
23:58:50 <dons> Korollary: maybe. i was going to try it on a few projects to see.
23:59:00 <weitzman> *if
23:59:04 <dons> seems a reasonablly accurate replacement for loc though.
23:59:24 <flux> graphviz and uml remind me of a project on freshmeat: a description language for the purpose of generating uml pictures
23:59:30 <SamB> dons: well, I need to figure out how to make a cyclomat first
23:59:48 <dons> weitzman: i've noticed chemistry grad students can be geniuses with gnuplot
23:59:49 <ulfdoz> weitzman: graphviz rocks, I like it. For some graph implementations I "visually verify" the implementation using graphviz.
