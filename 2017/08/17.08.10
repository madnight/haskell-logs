00:00:52 <quchen> (And before you worry, being confused by this is very common. It’s also remarkably clear once you get it, and helps you in all sorts of situations, not only when folds are involved. I think this example is key to understanding Haskell.)
00:01:57 <quchen> Bonus: it’s also key or at least useful to understanding recursion in many other languages in a principled way ;-)
00:22:43 <lthoang> hello
00:44:51 <ab9rf> olleh
01:44:09 <tsahyt> How would I construct a lens from [Either a b] to [a]? Can this even be a proper lens?
01:46:59 <quchen> > [Left "Hello", Right ()] & (traverse . _Left) %~ length -- tsahyt 
01:47:01 <lambdabot>  [Left 5,Right ()]
01:47:20 <quchen> Ah wait no.
01:47:25 <quchen> Correct answer, but not to your question. :-s
01:51:37 <tdammers> tsahyt: http://hackage.haskell.org/package/lens-4.15.4/docs/Control-Lens-Each.html should be helpful
01:52:34 <tsahyt> :t each . _Left
01:52:36 <lambdabot> (Applicative f, Each s t (Either a c) (Either b c)) => (a -> f b) -> s -> f t
01:52:49 <tsahyt> :t view (each . _Left)
01:52:50 <lambdabot> (Monoid a, Each s s (Either a c) (Either a c), MonadReader s m) => m a
01:52:58 <tsahyt> tdammers: the problem is the monoid here
01:53:06 <tsahyt> I want to accumulate a monoid, but not *that* monoid
01:56:37 <cocreature> tsahyt: you can’t even make a lawful traversal for that. what would happen if you add elements to the list in "over"
01:56:45 <tsahyt> that's what I thought
01:57:14 <tsahyt> but can I at least define a Getter?
01:57:14 <cocreature> tsahyt: what exactly are you trying to do?
01:57:38 <tsahyt> cocreature: exploring, mostly
01:58:09 <cocreature> > [Left "Hello", Right ()] ^.. traverse . _Left
01:58:11 <lambdabot>  ["Hello"]
01:59:04 <cocreature> :t to (toListOf (traverse . _Left)) :: Getter [Either a b] [a]
01:59:05 <lambdabot> (Functor f, Contravariant f) => ([a] -> f [a]) -> [Either a b] -> f [Either a b]
01:59:12 <tsahyt> ah
01:59:23 <tsahyt> I should set some time aside to properly learn the lens library
01:59:41 <tdammers> :t view
01:59:43 <lambdabot> MonadReader s m => Getting a s a -> m a
01:59:44 <tsahyt> I still find it rather confusing once I need anything beyond over/set/view into pretty standard nested records
02:00:06 <quchen> over/set/view are the ones you should use.
02:00:19 <tsahyt> then what about the other 99% of lens?
02:00:19 <quchen> Avoid the rest, use it if you have to.
02:00:32 <cocreature> toListOf is not so bad
02:00:36 <cocreature> I use that one all the time
02:00:42 <quchen> I count that as view
02:00:44 <quchen> But yes
02:00:51 <tdammers> I like the operators for when I want to write in a pseudo-imperative style inside a MonadState
02:00:52 <cocreature> heh fair enough
02:01:06 <quchen> When you write »filtered . alongside . confusing« your code is probably a write-only mess.
02:01:06 <tsahyt> :t toListOf
02:01:08 <lambdabot> Getting (Endo [a]) s a -> s -> [a]
02:01:15 <tsahyt> that does look like the missing piece
02:01:24 <quchen> toListOf = ^..
02:01:26 <cocreature> tsahyt: read the docs, they have better type signatures than :t :)
02:01:31 <quchen> :t confusing
02:01:33 <lambdabot> Applicative f => LensLike (Data.Functor.Day.Curried.Curried (Data.Functor.Yoneda.Yoneda f) (Data.Functor.Yoneda.Yoneda f)) s t a b -> LensLike f s t a b
02:01:33 <quchen> :t alongside
02:01:35 <cocreature> oh they don’t
02:01:35 <lambdabot> LensLike (Control.Lens.Internal.Getter.AlongsideLeft f b') s t a b -> LensLike (Control.Lens.Internal.Getter.AlongsideRight f t) s' t' a' b' -> LensLike f (s, s') (t, t') (a, a') (b, b')
02:02:02 <cocreature> the docs of (^..) have alternative signatures
02:02:10 <cocreature> although it looks like the haddock is broken
02:02:15 <cocreature> *adds to list of things to fix*
02:02:20 <tsahyt> what's the practical difference between traverse and each when used as lenses? they often seem to work somewhat interchangeably
02:02:44 <cocreature> they’re both not lenses so using them as one is going to be hard :)
02:03:01 <cocreature> I think if both work they usually do the same thing
02:03:12 <cocreature> but e.g. each works for tuples where all elements have the same type
02:03:14 <cocreature> or Text
02:03:15 <jared-w> cocreature: anything's possible if you try hard enough :p
02:03:34 <cocreature> jared-w: there is a reason why I said “it’s going to be hard” and not “it’s impossible” :P
02:07:05 <tsahyt> cocreature: I suppose it'd be better to just provide the lens to the a itself (it's deeper in a structure than just a list of eithers), and then use toListOf when the actual list is needed
02:08:16 <cocreature> tsahyt: yeah that sounds reasonable
02:17:38 <freeside> i have a situation, and i don't know if my situation calls for dependent types, or existential quantification, or something else. can you help me think this through? Suppose I have a container, into which I can put a certain amount of a Thing. Now, there are three kinds of Things: Things which are measured by weight, like coffee beans; Things which are measured by unit count, like coconuts; and Things which are measured by volume, like
02:17:38 <freeside> beer. Is there a best practice for my situation?
02:19:25 <cocreature> freeside: how about "data Thing = MeasuredByWeight … | MeasuredByUnitCount … | MeasuredByVolume …" 
02:19:40 <cocreature> maybe with better names ;)
02:20:40 * hackagebot Taxonomy 1.0.3 – Libary for parsing, processing and vizualization of taxonomy data – https://hackage.haskell.org/package/Taxonomy
02:20:41 <ertes-w> elo
02:20:55 <cocreature> suddenly a wild ertes-w appears
02:20:55 <freeside> now what if i want to use record syntax, and have a "name" field? then it would be data Measure = ByWeight Float | ByCount Int | ByVol Float; data Thing = Thing { name :: String, quantity :: Measure }
02:21:19 <cocreature> yeah
02:21:43 <ertes-w> ertes-wild
02:22:02 <freeside> thanks. i will see if this works. i am not as smart as i would like to be.
02:22:39 <cocreature> freeside: in general, try to go for simple solutions if they work for you and don’t start reaching for things like existential quantification if you don’t have to
02:23:10 <cocreature> existential quantification in particular is something that people new to Haskell often see as a solution to their problems only to find out that it doesn’t help or that there are better solutions :)
02:23:41 <freeside> yeah, that's why i want to be careful not to be too smart for my own good
02:23:49 <freeside> i have trouble being even minally smart enough most of the time
02:23:51 <tsahyt> there are few things that are really helped by existential quantification
02:24:29 <cocreature> the only case where I use existentials are for wrapping GADTs since there you can actually recover the type info by pattern matching
02:24:56 <cocreature> well an GADTs themselves are technically also just existentials but I tend to ignore that fact ;)
02:26:54 <tsahyt> is there some quick way to dump the output of ghci's :browse into a file?
02:33:46 <Marisa> Given a [Int], what is the most beautiful way to sort only the even number (and have the odd number stay at old place)? 
02:34:27 <freeside> okay, now, should my coconuts and my beer be types, or should they be variables? I want a basket, into which i can put [Thing]; each Thing should have a specific quantity; but the quantity should be of the right type of measure which the thing calls for.
02:35:28 * hackagebot array-primops 0.2.0.1 – Extra foreign primops for primitive arrays – https://hackage.haskell.org/package/array-primops
02:35:33 <Marisa> freeside, that depend on what do you want to do with your 'coconuts or beer'
02:36:36 <Marisa> like, do you want to print them, or do you have more advance use case?
02:36:57 <freeside> a coconut is a Thing which is measured by UnitCount, so the qty for a coconut Thing should be an Int; but beer is a Thing which is measured ByVol, so the qty for a beer Thing should be a float.
02:37:32 <freeside> i want to do simple comparisons, but mostly i want to make sure i don't accidentally measure three pints of coconuts.
02:38:09 <Marisa> if you have two (one unit of coconut), do you want to join them?
02:38:42 <freeside> yes, i should be able to combine them that way
02:39:37 <freeside> i want to be able to say, "you can add Beers, Coconuts, and Coffee Beans to your shopping cart. In your shopping cart you currently have this much of this thing and that much of that thing."
02:40:52 <freeside> my current approach is to distinguish `data Measure = ByUnit | ByVol | ByWeight; data Measurement = Units Int | Vol Float | Weight Float` but i feel like i'm repeating myself.
02:41:28 <BL[m]> Hello. I am writing a little parser with Parsec and there seems to be a lot of code wich looks like this (https://pastebin.com/DBecvwAn), but I can't find a good way to write it better, abstracting out p_left, p_right, lrsep and Instruction constructor. The only way I say was to write a constructor adding dummy argument to an arbitrary function and then use liftM3. But I might be missing an easy way, does anyone know one?
02:41:55 <Marisa> It looks like it will be easiest to use String - beer is a Liquid 3 (liter), and Coconuts is a Solid 2 (unit), rice is a SmallSolid (I am very bad at naming) 3 (kg)
02:42:11 <BL[m]> whoops, in the last sentence not a constructor, but a combinator
02:42:26 <dibblego> BL[m]: pretty sure you want return (something … 
02:42:26 <boj> BL[m]: you may want to look into Applicative syntax
02:42:34 <freeside> hmm
02:42:34 <Marisa> data Stuff = SmallSolid Double | Solid Int | Liquid Double
02:42:57 <dibblego> Instruction <$> p_left *> lrsep <*> p_right
02:42:59 <matrium> hi, is there something like an "nappend :: SemiSequence seq => NonNull seq -> seq -> NonNull seq" in mono-traversable? I can't find anything
02:43:21 <Ferdirand> what dibblego said
02:43:22 <Marisa> or for even more type safety, newtype Weight = Weight {runWeight :: Double}, so you wont mix up weight with volume
02:43:49 <BL[m]> dibblego: yes, sorry, that was a typo
02:44:32 --- mode: dibblego set -o dibblego
02:44:50 * hackagebot DeepDarkFantasy 0.2017.8.10 – A DSL for creating neural network. – https://hackage.haskell.org/package/DeepDarkFantasy
02:45:02 <Ferdirand> shouldn't that be "p_left <* lrsep" ?
02:45:04 <BL[m]> dibblego: thank you exactly what I was looking for.
02:45:18 <boj> Ferdirand: yes
02:45:41 <boj> err
02:45:53 <dibblego> Ferdirand has a correction
02:46:10 <dibblego> point the wings of the spaceship toward the value you want to keep
02:46:12 <boj> Instruction <$> p_left *> lrsep <* p_right - i think? ignore everything asterisk side
02:46:30 <boj> Oh.
02:46:33 <boj> hah
02:46:35 <dibblego> Instruction <$> p_left <* lrsep <*> p_right
02:47:31 <Ferdirand> incidentally
02:48:29 <Ferdirand> is there a significant operational difference between (I <$> a <* s <*> b) and (I <$> a <*> (s *> b)) ?
02:52:08 <BL[m]> Wouldn't that depend on l?
03:14:32 <ertes-w> Marisa: i have a lens for that…  gimme a moment to dig it out
03:14:50 <Marisa> Ooh, never know lens can sort
03:15:39 <ertes-w> Marisa: no, but lens can give you a view into a list of just the even numbers
03:15:48 <ertes-w> then you can sort that list under the lens
03:16:11 <Marisa> So what happend if you return a smaller/larger list?
03:17:06 <ertes-w> then you break the contract =)
03:17:43 <Marisa> I see = =
03:20:36 <Iceland_jack> Oh? I see dead people
03:21:53 <ertes-w> Marisa: https://gist.github.com/anonymous/2de54eb7083679a853eb59d08ebffa34
03:22:09 <ertes-w> λ> [0..9] & listFiltered even %~ reverse
03:22:10 <ertes-w> [8,1,6,3,4,5,2,7,0]
03:25:04 <guest235> hey, I'm doing a tutorial on building a free monad DSL and it's giving me an error about missing an applicative instance for the type that holds my AST
03:25:11 <guest235> This is the tutorial: http://www.haskellforall.com/2012/06/you-could-have-invented-free-monads.html
03:26:08 <guest235> In the tutorial there's only an explanation for giving the DSL a functor type class, I guess since it was written in 2012 and you didn't need to provide an applicative instance for a monad?
03:26:21 <guest235> But I can't figure out what the applicative instance should be
03:27:10 <guest235> (In the blog post the type I need the applicative instance for is "data Toy b next..."
03:28:59 <Iceland_jack> > over (partsOf (traversed.filtered even)) reverse [0..9]
03:29:01 <Iceland_jack> close
03:29:02 <lambdabot>  [8,1,6,3,4,5,2,7,0,9]
03:37:46 <bobthecreator>  Hello, anybody here have a working YouTube partner program?
03:38:23 <ertes-w> oh, that's what partsOf does!
03:38:51 <bobthecreator> partsOf?
03:39:35 <ertes-w> Marisa: Iceland_jack's version is better than mine…  use that one =)
03:39:42 <ertes-w> i didn't know about partsOf
03:40:09 <ertes-w> bobthecreator: this is a channel about the programming language haskell
03:40:11 <Marisa> Ooh, sure
03:40:35 <bobthecreator> someone sent me here from #freenode
03:41:00 <Iceland_jack> bobthecreator: It's a good channel, Haskell is a good language
03:41:04 <Iceland_jack> you ought to stay
03:41:15 <bobthecreator> I know Java
03:41:18 <bobthecreator> how does it compare to Java
03:42:03 <ertes-w> bobthecreator: much less line noise, besser type system, better abstractions, better refactoring
03:42:17 <bobthecreator> a photo on google shows me that it looks like C
03:42:27 <bobthecreator> closer to Python even
03:42:47 <ertes-w> bobthecreator: that photo is lying…  it looks more like python, but apart from indentation-sensitive layout it's hardly even comparable to python
03:42:48 <boj> you were in here the other day bobthecreator 
03:42:53 <bobthecreator> This language is completely unreadable
03:43:07 <bobthecreator> This is my first time in this channel or even hearing about Haskell
03:43:32 <Iceland_jack> bobthecreator: Here is how you multiply a list by 10
03:43:34 <boj> must have been a similar name then
03:43:38 <Iceland_jack> > map (* 10) [1..10]
03:43:39 <bobthecreator> possibly
03:43:41 <lambdabot>  [10,20,30,40,50,60,70,80,90,100]
03:43:56 <bobthecreator> multiply a list?
03:44:00 <Iceland_jack> each element
03:44:02 <bobthecreator> you mean, multiply each integer in a list
03:44:19 <bobthecreator> do you still call them integers in haskell
03:44:22 <ongy> doesn't have to be integer, just a type that can be multiplied
03:44:28 <bobthecreator> yea
03:44:30 <bobthecreator> numeric
03:44:44 <ertes-w> bobthecreator: we have a bunch of integral types, but Integer is the type of integers
03:44:44 <bobthecreator> float, double, integer
03:44:56 <ertes-w> bobthecreator: all others are constrained
03:45:10 <ongy> we have different things. The Integer is a specific type for unbound integers, there's also Int, which corresponds to the signed machine integer of your platform
03:45:25 <bobthecreator> map (* -10) [1..10]
03:45:27 <bobthecreator> what would that do
03:45:36 <ertes-w> > map (* (-10)) [1..10]
03:45:39 <lambdabot>  [-10,-20,-30,-40,-50,-60,-70,-80,-90,-100]
03:45:47 <bobthecreator> oh
03:45:53 <bobthecreator> i just realized thats a bot
03:45:57 <Marisa> > [0..]
03:46:00 <lambdabot>  [0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
03:46:10 <bobthecreator> question
03:46:14 <bobthecreator> what does modulo look like
03:46:18 <bobthecreator> in java its %
03:46:35 <ertes-w> > iterate (\x -> (x*x + 1) `mod` 101) 0
03:46:38 <lambdabot>  [0,1,2,5,26,71,93,65,85,55,97,17,88,69,15,24,72,34,46,97,17,88,69,15,24,72,3...
03:46:40 <ongy> > (`mod` 7) [1..10]
03:46:42 <lambdabot>  error:
03:46:42 <lambdabot>      • Ambiguous type variable ‘t0’ arising from a use of ‘show_M235573135417...
03:46:42 <lambdabot>        prevents the constraint ‘(Show t0)’ from being solved.
03:46:50 <bobthecreator> :o
03:46:51 <ongy> disregard me being stupid :)
03:46:56 <bobthecreator> okay :)
03:47:00 <bobthecreator> how aboutttt
03:47:05 <bobthecreator> making a list of all the prime numbers
03:47:06 <ertes-w> better drop the first few items =)
03:47:06 <Marisa> wait, why doesnt lambdabot hang?
03:47:18 <ongy> hang on what?
03:47:26 <ongy> bobthecreator: efficient, or simple?
03:47:31 <bobthecreator> hmm
03:47:48 <bobthecreator> you mean, minus readability for efficiency
03:47:48 <Marisa> I mean on ghci that hang, so what does lambdabot do that prevent it from hanging
03:47:51 <ertes-w> @let isPrime x = x > 1 && all (\d -> x `mod` d /= 0) [2..x - 1]
03:47:54 <lambdabot>  Defined.
03:47:56 <ongy> > filter even [1..] -- if you have a isPrime, you can do it like this. but that's probably way to slow for real live
03:47:58 <ertes-w> > filter isPrime [2..]
03:48:00 <lambdabot>  [2,4,6,8,10,12,14,16,18,20,22,24,26,28,30,32,34,36,38,40,42,44,46,48,50,52,5...
03:48:03 <lambdabot>  [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,...
03:48:05 <bobthecreator> lol
03:48:11 <bobthecreator> isPrime is an actual function xD
03:48:21 <boj> no
03:48:23 <ertes-w> bobthecreator: i just defined it one line earlier
03:48:26 <boj> ertes-w: defined it
03:48:27 <bobthecreator> oooohhh
03:48:32 <Iceland_jack> bobthecreator: ertes-w just defined it
03:48:45 <bobthecreator> im sorry im having difficulty following the conversation :)
03:48:52 <ertes-w> bobthecreator: of course this particular list of primes is not very efficient =)
03:49:00 <boj> a lot of excited people wanting to help :)
03:49:03 <Iceland_jack> bobthecreator: This is how Booleans are defined: data Bool = False | True
03:49:10 <bobthecreator> what
03:49:11 <bobthecreator> wait
03:49:15 <bobthecreator> you dont have Boolean types
03:49:26 <ongy> that is the boolean type
03:49:30 <bobthecreator> eh
03:49:34 <ongy> > if True then "x" else "y"
03:49:37 <lambdabot>  "x"
03:49:38 <bobthecreator> thats an object
03:49:42 <bobthecreator> with two values
03:49:42 <ertes-w> bobthecreator: it's just not built-in
03:49:45 <bobthecreator> yea...
03:49:51 <Iceland_jack> You're in #haskell now bobthecreator B)
03:49:52 <qbmaniac> Hi everyone
03:49:55 <qbmaniac> is Haskell good?
03:50:00 <Iceland_jack> qbmaniac: yeah
03:50:04 <bobthecreator> in my opinion tho
03:50:09 <universalpackage> is haskell compilable
03:50:19 <Iceland_jack> my current project isn't :(
03:50:20 <ertes-w> bobthecreator: (it's defined in the base library for you, so you don't actually have to define it yourself, but the point is that it doesn't need to be primitive)
03:50:23 <bobthecreator> this looks like a language best reserved for people who know math well
03:50:39 <bobthecreator> im not very good at math
03:50:40 <ongy> it doesn't hurt. But I'd say I got more interested in the math after learning the language
03:50:46 <bobthecreator> hmm
03:51:03 <ertes-w> bobthecreator: i would put it this way: haskell definitely encourages you to learn some math, but you get immediate reward for doing that
03:51:11 <bobthecreator> yes
03:51:42 <Peaker> hi, is there a way to emit a compile-time warning that is not a deprecation and without incurring a dependency on template-haskell?
03:51:50 <bobthecreator> how do you print data?
03:51:57 <universalpackage> can hskell be compiled into a stand alone program
03:51:58 <Iceland_jack> print [1,2,3,4]
03:52:02 <Peaker> bindings-GLFW has a silly dep on template-haskell just for the warning, and an upper bound that keeps getting hit and costing maintenacne
03:52:05 <universalpackage> haskell*
03:52:05 <ertes-w> universalpackage: yes
03:52:13 <bobthecreator> why didn't the bot respond
03:52:15 <universalpackage> ok
03:52:31 <boj> bobthecreator: start with >
03:52:36 <Marisa> > print [1..4]
03:52:38 <lambdabot>  <IO ()>
03:52:45 <universalpackage> is haskell recommended for making bots with?
03:52:47 <bobthecreator> @let result x = 10 * 2
03:52:49 <lambdabot>  Defined.
03:52:50 <bobthecreator> > print result
03:52:52 <ertes-w> bobthecreator: there is a type for actions called IO, but lambdabot will not execute IO actions
03:52:53 <lambdabot>  error:
03:52:53 <lambdabot>      • No instance for (Typeable t0) arising from a use of ‘print’
03:52:53 <lambdabot>      • In the expression: print result
03:53:01 <bobthecreator> heelp
03:53:09 <ertes-w> bobthecreator: it will only evaluate pure code
03:53:11 <Iceland_jack> bobthecreator: The bot is limited, on purpose
03:53:14 <bobthecreator> ahh
03:53:22 <bobthecreator> would what i just did work normally tho
03:53:51 <bobthecreator> > print (10*2)
03:53:53 <Marisa> maybe someone should setup a sandbox that allow doing impure lewd stuff
03:53:53 <lambdabot>  <IO ()>
03:53:54 <ertes-w> bobthecreator: not quite
03:54:00 <ertes-w> bobthecreator: you were trying to print a function =)
03:54:05 <bobthecreator> ohhh
03:54:07 <bobthecreator> heheheh
03:54:10 <ertes-w> :t print (\x -> 10 * 2)
03:54:12 <lambdabot> error:
03:54:13 <lambdabot>     • No instance for (Typeable t0) arising from a use of ‘print’
03:54:13 <lambdabot>     • In the expression: print (\ x -> 10 * 2)
03:54:19 <ongy> universalpackage: depending on what your bot should do, it's really nice to do in haskell. The way lambdabot works (outside of the @define stuff) is stateles and can be easily written in a pure way and then wrapped into a really simple interact-like IO wrapper
03:54:22 <Marisa> :h
03:54:25 <bobthecreator> :V
03:54:34 <boj> :o
03:54:37 <bobthecreator> ur bot is broked
03:54:39 <universalpackage> ok
03:54:53 <universalpackage> could u teach me how to make one?
03:54:58 <ertes-w> bobthecreator: it gave the expected response =)
03:54:58 <boj> well, broke on purpose
03:55:04 <bobthecreator> aha
03:55:09 <ertes-w> this is a type error: print (\x -> 10 * 2)
03:55:17 <ertes-w> because i'm trying to print a function
03:55:21 <bobthecreator> aha
03:55:30 <Iceland_jack> > words "hello #haskell world"
03:55:33 <lambdabot>  ["hello","#haskell","world"]
03:55:38 <Iceland_jack> > reverse (words "hello #haskell world")
03:55:40 <lambdabot>  ["world","#haskell","hello"]
03:55:43 <Iceland_jack> > unwords (reverse (words "hello #haskell world"))
03:55:44 <ertes-w> bobthecreator: (\x -> 10*2) is the function that ignores its argument and returns 20
03:55:45 <boj> > (\x -> 10 * x) 2
03:55:46 <lambdabot>  "world #haskell hello"
03:55:47 <lambdabot>  20
03:55:58 <bobthecreator> oh
03:56:04 <universalpackage> i wish pacman had globbing ;-;
03:56:13 <bobthecreator> wait a second
03:56:22 <bobthecreator> you dont need to return values explicitely
03:56:30 <bobthecreator> they just get returned
03:56:35 <boj> yes, the last expression gets returned
03:56:39 <Peaker> > "hello #haskell world" & words & reverse & unwords
03:56:39 <bobthecreator> interesting
03:56:41 <lambdabot>  "world #haskell hello"
03:56:50 <bobthecreator> what happens if you want to return a value before completing operation
03:57:03 <ongy> bobthecreator: you are simply writing expressions. (warning: there's a return in Haskell, but it's not what you expect)
03:57:08 <ertes-w> bobthecreator: a function is not a procedure the way it is in java…  it is literally just a function, taking an argument and returning a result
03:57:18 <ertes-w> bobthecreator: something like 'return' would just be line noise
03:57:24 <bobthecreator> so its more of a command line language
03:57:27 <Peaker> bobthecreator, foo :: A -> IO (B, IO C) -- takes an A, acts, returns B and an action to continue and return C
03:57:38 <Peaker> bobthecreator, it's general-purposoe
03:57:38 <Iceland_jack> not at all bobthecreator
03:57:52 <bobthecreator> hmmm
03:57:57 <ertes-w> bobthecreator: nope…  but this really can't be explained on IRC…  at this point, if you're intrigued, you should just pick up a tutorial and learn haskell =)
03:58:05 <bobthecreator> buuuuttt
03:58:12 <bobthecreator> how would i use it
03:58:18 <boj> same way you use java
03:58:20 <ertes-w> bobthecreator: much like python
03:58:21 <ertes-w> err
03:58:22 <ertes-w> java
03:58:23 <bobthecreator> what are the largest implementations
03:58:27 <universalpackage> haskel has its own haskell bot o.o
03:58:30 <Iceland_jack> bobthecreator: It may also bring joy to your life
03:58:34 <ertes-w> bobthecreator: GHC
03:58:37 <bobthecreator> doubt that
03:58:42 <bobthecreator> GHC?
03:58:49 <boj> the primary compiler
03:58:50 <bobthecreator> hadron colider?
03:58:52 <ongy> GHC is the (main) haskell compiler
03:58:54 <ertes-w> bobthecreator: there are some others, but most people should just go with GHC
03:58:56 <bobthecreator> oh right
03:59:19 <bobthecreator> i never really learned how to use compilers
03:59:26 <ertes-w> bobthecreator: GHC is the The Glorious Glasgow Haskell Compilation Sy…  you know…  the glasgow haskell compiler =)
03:59:32 <bobthecreator> i usually code in an IDE with a compiler doing all the work
03:59:43 <ertes-w> GHC is so glorious, it also comes with an interpreter =)
03:59:54 <bobthecreator> sounds like too advanced for my own good
04:00:15 <bobthecreator> id rather stick to System.out.println("hello world);
04:00:31 <bobthecreator> forgot the end quote.. 
04:00:36 <universalpackage> wtf how is this possible 0.0
04:00:38 <universalpackage> Total Download Size:    63.42 MiB
04:00:39 <ongy> but `printLn "Hello World"` is prettier ;)
04:00:40 <universalpackage> Total Installed Size:  908.09 MiB
04:00:46 <bobthecreator> yea
04:00:51 <ongy> good compression
04:00:55 <ongy> what are you installing? ghc?
04:01:07 <ertes-w> bobthecreator: install GHC and write the following into blah.hs:  main = putStrLn "Hello world!"
04:01:09 <universalpackage> 908 mb compressed in just 63 mb?
04:01:11 <bobthecreator> you could import System and then just use println();
04:01:12 <universalpackage> 0.0
04:01:15 <ertes-w> bobthecreator: then type:  runhaskell blah.hs
04:01:27 <boj> bobthecreator: what brought you in here? functional programming curiosity?
04:01:32 <bobthecreator> no
04:01:35 <bobthecreator> Youtube questions
04:01:46 <bobthecreator> i came for youtube stayed for the curiosity
04:01:51 <ertes-w> boj: apparently someone on #freenode thought that #haskell is a youtube channel =)
04:01:56 <bobthecreator> yea
04:01:56 <boj> apparently
04:01:56 <ongy> boj: The inital question was unrelated and apparently (mis)directed from #freenode. I'm rather surprised aswell
04:02:00 <universalpackage> lol
04:02:12 <bobthecreator> someone named VladimirTrump
04:02:18 <bobthecreator> im not surprised he was unreliable
04:02:18 <boj> i was curious if the lead up had anything to do with fp or haskell, apparently not
04:02:21 <ongy> sounds like a sane person
04:02:25 <bobthecreator> indeed.
04:02:26 <boj> nice that you stayed bobthecreator :)
04:02:29 <universalpackage> a haskell script can be compiled into a stand alone binary right?
04:02:34 <bobthecreator> thank you for teaching me things
04:02:38 <boj> universalpackage: yes
04:02:41 <universalpackage> ok
04:02:41 <ertes-w> perhaps you were asking your initial question wrong: "is there a functional youtube channel?"
04:02:45 <bobthecreator> what platforms does it run on
04:02:47 <ertes-w> "functional?! that must be haskell!"
04:03:14 <boj> bobthecreator: most desktop OSes. a few projects have it building to ios/android
04:03:18 <ongy> universalpackage: I'd say a haskell applicaton can also be run like a script with runhaskell. Since the compiled binary version is usually what's used, not the script like interpreted version
04:03:24 <bobthecreator>  <bobthecreator> anybody here have a YouTube partnership program working? <VladimirTrump> bobthecreator: try #youtube or #google or #haskell
04:03:36 <bobthecreator> aaaah
04:03:38 <bobthecreator> I said program
04:03:59 <bobthecreator> he thought i meant programming as in development
04:04:35 <boj> well, all downhill from here.
04:04:44 <boj> the curiosity will burn, and by the end of the year you with loath java
04:04:48 <ongy> and kind of depends on your requirements for stand alone. it still dynamicly links to a lot of libraries (pthread/libc/gmp), but the haskell parts are compiled into the binary
04:05:24 <bobthecreator> have there been any successful attempts at a user interfaced haskell implementation
04:05:34 <boj> user interfaced?
04:05:40 <bobthecreator> im making stuff up
04:05:45 <boj> i see
04:05:59 <bobthecreator> is there a UI which is based on haskell
04:06:16 <boj> quite a few wrappers to popular UI libraries
04:06:27 <bobthecreator> for instance, Microsoft has .NET for UI
04:06:29 <boj> reflex-dom if you are into web stuff
04:06:36 <bobthecreator> hmm
04:06:44 <bobthecreator> okayy
04:06:45 <ertes-w> bobthecreator: BTW, if you want to maintain your love for java, you should leave right now…  if you stay any longer, those feelings will be doomed
04:06:52 <bobthecreator> lol
04:07:01 <ertes-w> bobthecreator: together with any potential to love most other languages =)
04:07:01 <bobthecreator> I made an Android App, I already hate Java enough
04:07:10 <tdammers> bobthecreator: .NET is not primarily for UI, it's an everything-and-the-kitchen-sink framework
04:07:18 <boj> haskell has seriously ruined my programming career, sigh
04:07:19 <bobthecreator> lol yea
04:07:41 <bobthecreator> thats Microsoft for you
04:07:44 <bobthecreator> disorganized
04:08:16 <bobthecreator> Windows 7 has been unmatched in the Windows line since XP
04:08:31 <bobthecreator> im still using 7 for its stability and simple user interface
04:08:57 <bobthecreator> Ive got Debian on my old macbook
04:09:05 <bobthecreator> i do some bash and dash programming there
04:09:10 <ertes-w> bobthecreator: want me to send you down another rabbit hole?
04:09:11 <bobthecreator> and Java console apps
04:09:17 <bobthecreator> depends,
04:09:21 <bobthecreator> will i find true love
04:09:25 <ertes-w> yes
04:09:36 <ertes-w> but you can never ever leave
04:09:36 <bobthecreator> i cant say no to true love
04:09:55 <bobthecreator> tbh you value your language too highly
04:10:04 <bobthecreator> xD
04:10:09 <boj> indeed
04:10:16 <ongy> well, you are in a channel literally named after said language :)
04:10:20 <bobthecreator> you are the equivalent of French speakers of programming languages
04:10:22 <ertes-w> how to ruin yourself for all operating systems: https://nixos.org/
04:10:37 <boj> that's probably a good analogy
04:10:39 <ongy> and it's not that we don't have gripes with Haskell, it's more that it tends to show the obvious holes when working with other things
04:10:59 <boj> haskell does have quite a few warts
04:11:14 <ertes-w> i complain about haskell a lot, but these complaints tend to be very high-level
04:11:19 <ongy> I want to play with linear types and comact reasons...
04:11:35 <ertes-w> ("why the hell is RankNTypes not standard?!")
04:11:35 <bobthecreator> i dont know what those are
04:11:54 <bobthecreator> In java im just trying to figure out how lambda expressions work
04:11:58 <boj> my buddy was complaining about refelx vs. js-framework yesterday and talked himself into why reflex was ultimately better, lol
04:12:02 <bobthecreator> im guessing there is no such thing in haskell
04:12:07 <bobthecreator> since you dont have classes
04:12:20 <ertes-w> bobthecreator: i showed you one a few minutes ago =)
04:12:25 <ertes-w> :t \x -> 2*10
04:12:26 <bobthecreator> yea?
04:12:27 <lambdabot> Num a => t -> a
04:12:31 <bobthecreator> oh
04:12:40 <bobthecreator> yea the arrow thing ->
04:12:48 <bobthecreator> no idea what that does
04:12:52 <bobthecreator> even in java i dont get it
04:12:54 <boj> bobthecreator: turns out haskell is built on the lambda calculus
04:12:56 <ertes-w> in fact you have even seen an abbreviated form of that as the very first example we showed you =)
04:13:05 <bobthecreator> oh dear
04:13:07 <ertes-w> > map (* 10) [0..9]
04:13:10 <lambdabot>  [0,10,20,30,40,50,60,70,80,90]
04:13:16 <boj> bobthecreator: you can ignore that though
04:13:18 <ertes-w> that (* 10) is the function that returns its argument multiplied by 10
04:13:24 <bobthecreator> it seems i fell upon a language that is based on the thing i dont understand
04:13:40 <boj> sweep that thought away then, nothing lost
04:13:46 <ertes-w> bobthecreator: it's just that
04:13:46 <bobthecreator> x)
04:13:51 <bobthecreator> NixOs looks cool
04:14:01 <ertes-w> a function, but without a name and written directly where it's used
04:14:02 <bobthecreator> it has to be good when it has a NixCon
04:14:12 <bobthecreator> ehh
04:14:17 <bobthecreator> i see
04:14:24 <bobthecreator> anonymous function
04:14:26 <bobthecreator> ?
04:14:28 <boj> yep
04:14:31 <bobthecreator> \o/
04:14:41 <bobthecreator> okay
04:14:55 <bobthecreator> i need a female in my life :(
04:15:04 <boj> good luck
04:15:13 <bobthecreator> how do i print a female
04:15:24 <bobthecreator> > unword ["female"]
04:15:24 <Iceland_jack> ookay
04:15:27 <lambdabot>  error:
04:15:27 <lambdabot>      • Variable not in scope: unword :: [[Char]] -> t
04:15:27 <lambdabot>      • Perhaps you meant one of these:
04:15:34 <bobthecreator> yeap... my life is an error
04:15:35 <ertes-w> functional languages tend to make functions non-special, so just the way you can write an integer literal without first giving it a name ("3"), you can also write function literals without first giving them a name ("\x -> …")
04:15:39 <ongy> :t unwords
04:15:41 <lambdabot> [String] -> String
04:15:53 <bobthecreator> thats what i did
04:16:12 <bobthecreator> ertes-w: hold up
04:16:14 <bobthecreator> you lost me
04:16:14 <Iceland_jack> it needs a -list- of strings
04:16:18 <ongy> there's an additional 's' there. but it's really not that spectacular with your list of strings
04:16:20 <ertes-w> bobthecreator: then ignore that =)
04:16:24 <ongy> > unwords ["female"]
04:16:27 <lambdabot>  "female"
04:16:34 <bobthecreator> thats what i typed
04:16:44 <boj> close
04:16:48 <bobthecreator> ohhhhh
04:16:50 <ongy> unwordS the S (well, lower case)
04:16:56 <bobthecreator> aha
04:16:59 <bobthecreator> also one more question
04:17:08 <bobthecreator> is this a case sensitive language like java
04:17:12 <ongy> > words "When you know where the name come froms, it's intuitive"
04:17:14 <boj> yeah
04:17:15 <lambdabot>  ["When","you","know","where","the","name","come","froms,","it's","intuitive"]
04:17:40 <Iceland_jack> > map length (words "When you know where the name come froms, it's intuitive")
04:17:42 <lambdabot>  [4,3,4,5,3,4,4,6,4,9]
04:17:50 <ongy> does java enforce some capitalizations?
04:17:52 <Iceland_jack> > sum (map length (words "When you know where the name come froms, it's intuitive"))
04:17:55 <lambdabot>  46
04:17:55 <bobthecreator> yea
04:18:03 <bobthecreator> String s = "1";
04:18:03 <ertes-w> more so than java…  to maintain brevity we even tell variables from types and constructors by how they are capitalised =)
04:18:07 <bobthecreator> String S = "2";
04:18:12 <bobthecreator> two different variables
04:18:25 <universalpackage> haskell it is nowhere in the archlinux repo 0.0 (yet it is accessable to pacman)
04:18:26 <universalpackage> haskell is*
04:18:35 <bobthecreator> simply, String s = "1", S = "2";
04:18:41 <ertes-w> > let sx = "blah"; sX = "blubb" in sx ++ sX
04:18:44 <lambdabot>  "blahblubb"
04:18:53 <bobthecreator> hehe
04:19:02 <bobthecreator> is that how you do incatination
04:19:03 <ertes-w> you can't capitalise the first letter, because otherwise haskell will think that it's a constructor
04:19:05 <ongy> universalpackage: you need the ghc package
04:19:33 <bobthecreator> whats the word im looking for
04:19:37 <ongy> > let s = "1" in s -- most of the time we don't even need to tell the compiler the type
04:19:37 <bobthecreator> concatination
04:19:39 <lambdabot>  "1"
04:19:43 <ertes-w> bobthecreator: concatenation
04:19:48 <bobthecreator> yeas thank u
04:20:01 <bobthecreator> so is that the most efficient way
04:20:06 <bobthecreator> string1 ++ string2
04:20:17 <bobthecreator> in java, using a + for concat is frowned upon
04:20:32 <bobthecreator> you use StringBuilder and use .append("new string to append);
04:20:41 <ongy> the String type in Haskell is a simple list of characters, that's just list concatenation. it's rather slow and has issues (one of the gripes with Haskell....)
04:20:51 <bobthecreator> return "string 1".append("string 2");
04:20:52 <ertes-w> bobthecreator: that question is…  hard to answer without taking a massive tangent…  we should return to it after you understand how lists work
04:21:03 <ertes-w> no, (++) is not slow in general
04:21:25 <bobthecreator> yeas, but if you ++'d 10 thousand strings
04:21:40 <bobthecreator> would it work fast or slower than other ways that it can be done
04:22:00 <tdammers> it doesn't make sense to discuss the performance of String and ++ before you understand what String is in Haskell
04:22:06 <bobthecreator> xD
04:22:07 <ertes-w> > foldr (++) [] (map show [0..9999])
04:22:09 <lambdabot>  "012345678910111213141516171819202122232425262728293031323334353637383940414...
04:22:15 <bobthecreator> okay thats fast...
04:22:31 <tdammers> we have other string types in Haskell that are more suitable for general-purpose text manipulation
04:22:32 <ertes-w> > foldr (\x ys -> x ++ "," ++ ys) [] (map show [0..9999])
04:22:35 <lambdabot>  "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:22:43 <tdammers> and we also have Builder types that do roughly what StringBuilder does in Java
04:22:44 <ertes-w> bobthecreator: that's 10000 strings
04:22:49 <ertes-w> bobthecreator: let's try infinitely many
04:22:53 <ertes-w> > foldr (\x ys -> x ++ "," ++ ys) [] (map show [0..])
04:22:54 <bobthecreator> eheh..
04:22:55 <Marisa> > foldr (++) (map show [1..])
04:22:56 <lambdabot>  "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:22:58 <lambdabot>  <[[[Char]]] -> [[Char]]>
04:23:11 <Iceland_jack> > intercalate "," (map show [0..])
04:23:13 <lambdabot>  "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,2...
04:23:20 <Athas> bobthecreator: yes, repeatedly concatenating strings is slow in Haskell.
04:23:21 <bobthecreator> intercalate
04:23:30 <ertes-w> bobthecreator: as you can see even infinitely many strings works
04:23:31 <Athas> Whenever you do 'x++y', it has to find the end of 'x' first.
04:23:31 <ertes-w> =)
04:23:38 <bobthecreator> aha
04:23:56 <bobthecreator> im not sure technically speaking what StringBuilder does when appending, but its faster than using +
04:24:24 <Athas> StringBuilders precompute the final size in order to perform just one allocation, and not have so many intermediate results.
04:24:25 <ertes-w> bobthecreator: but this won't make much sense until you understand how lists work in haskell
04:24:34 <bobthecreator> ive tested this, and ive brought down 300ms run time into viscinity of 20ms
04:24:44 <ongy> I'd have to check, probably not appending at all until you try to get the final string, thus avoiding all the copy and realloc stuff
04:24:55 <Athas> But Haskell Strings have the additional problem that finding the end or length is O(n), where it is O(1) in most languages with a sane string type.
04:25:21 <ertes-w> bobthecreator: try this code:  main = print [1..]
04:25:22 <bobthecreator> and what does the n symbolize
04:25:34 <Athas> bobthecreator: the length of the string(s) involved.
04:25:39 <ertes-w> bobthecreator: this is basically printing a concatenation of an infinite number of strings
04:25:48 <bobthecreator> yeas
04:25:57 <bobthecreator> > print [1..]
04:26:00 <lambdabot>  <IO ()>
04:26:01 <tdammers> Athas: and that is what Haskell's "proper" string types (Text / lazy Text) are for
04:26:02 <bobthecreator> ew
04:26:04 <Athas> The String type in Haskell is probably not suitable for any use where you are worried about the cost of concatenating lots of them.  Use Text instead.
04:26:11 <ertes-w> bobthecreator: not only will it be fast, but it will even run in constant memory
04:26:21 <bobthecreator> Text?
04:26:25 <bobthecreator> thats news to me ^_^
04:26:34 <Athas> Look at the Data.Text module.
04:26:50 <ongy> Athas: we bullied bobthecreator into larning haskell. Don't go to far :D
04:26:51 <ertes-w> String is perfect for concatenation
04:26:54 <bobthecreator> when you make a default "string", does it get processed as String type of as Text type
04:27:01 <Athas> It's a String.
04:27:13 <Athas> But there is a GHC extension (OverloadedStrings) that permit it to be interpreted as a Text.
04:27:13 <bobthecreator> so you have to implicitely declare it as Text
04:27:22 <bobthecreator> i see
04:27:38 <bobthecreator> what was the variable declaration schema
04:27:46 <bobthecreator> Text variable = "hello"
04:27:47 <ertes-w> Text is actually *terrible* for concatenation, because it would do exactly what java would do without string builder
04:27:54 <bobthecreator> ahh
04:27:54 <ertes-w> and lazy Text is the best of both worlds…  almost =)
04:28:13 <Athas> ertes-w: sure, Text only gets you to the same level as plain Java strings.  From there, you need a TextBuilder or whatever.  But plain String is even worse.
04:28:30 <ertes-w> Athas: no, String is perfect for concatenation
04:28:36 <bobthecreator> i found this https://repl.it/languages/haskell
04:28:50 <bobthecreator>   putStrLn "Hello"
04:28:54 <bobthecreator> >  putStrLn "Hello"
04:28:58 <lambdabot>  <IO ()>
04:29:01 <ertes-w> Athas: what String is not perfect for is concrete in-memory realisation
04:29:11 <ertes-w> but if you never do that, String is just perfect
04:29:37 <ongy> bobthecreator: that looks cool to try things out. The bot here is a bit more suited for showing simple things (cause that's what it's intended for)
04:29:40 <ertes-w> print [1..]  -- there is no way to make this faster (other than perhaps to write it directly as a tight loop, or perhaps to improve the integer rendering algorithm)
04:29:55 <bobthecreator> Guys
04:29:58 <bobthecreator> wait for a second
04:30:03 <bobthecreator> im gonna paste something
04:30:08 <ongy> ertes-w: that's not concatenation of strings
04:30:11 <Athas> ertes-w: is (++) left- or right-associative?
04:30:14 <ertes-w> ongy: it is
04:30:14 <ongy> @lpaste -- please use lpaste to paste
04:30:14 <lambdabot> Haskell pastebin: http://lpaste.net/
04:30:19 <bobthecreator> > fizz :: Int -> String fizz n | n `mod` 15 == 0  = "FizzBuzz"        | n `mod` 3  == 0  = "Fizz"        | n `mod` 5  == 0  = "Buzz"        | otherwise = show n  main :: IO() main = mapM_ putStrLn $ map fizz [1..100]
04:30:22 <lambdabot>  <hint>:1:30: error: parse error on input ‘|’
04:30:23 <bobthecreator> oops
04:30:26 <ertes-w> ongy: print = putStrLn . show
04:30:35 <boj> @where lpaste
04:30:35 <lambdabot> http://lpaste.net/
04:30:42 <bobthecreator> the pipe seems to work on the compiler website
04:30:56 <bobthecreator> what do you use pipe for anyway
04:31:03 <ongy> that's called guards.
04:31:03 <Iceland_jack> @let fizz n | n `mod` 15 == 0  = "FizzBuzz"        | n `mod` 3  == 0  = "Fizz"        | n `mod` 5  == 0  = "Buzz"        | otherwise = show n
04:31:05 <lambdabot>  Defined.
04:31:07 <Athas> Ah, (++) is right-associative.  That's good.
04:31:08 <ertes-w> Athas: it's right-associative and should be used like that, too
04:31:12 <Iceland_jack> > map fizz [1..100]
04:31:15 <lambdabot>  ["1","2","Fizz","4","Buzz","Fizz","7","8","Fizz","Buzz","11","Fizz","13","14...
04:31:18 <bobthecreator> yeeey
04:31:21 <Iceland_jack> > unwords (map fizz [1..100])
04:31:23 <lambdabot>  "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buz...
04:31:32 <bobthecreator> awesome
04:32:03 <universalpackage> do i need anything else aside from haskel-binary and gsh
04:32:08 <ertes-w> Athas: if you have left-associated concatenation you should use (String -> String) for String and Builder for Text
04:32:12 <universalpackage> ghc*
04:32:23 <bobthecreator> what are the guards used for
04:32:33 <bobthecreator> is that like a new line
04:32:37 <Iceland_jack> bobthecreator: Notice how "n `mod` 3 == 0" is repeated pattern?
04:32:42 <Iceland_jack> @define d `divides` n = n `mod` d == 0
04:32:44 <lambdabot>  Defined.
04:32:45 <universalpackage>  /usr/lib/ghc-7.10.3/bin/ghc-pkg: error while loading shared libraries: libncursesw.so.5: cannot open shared object file: No such file or directory
04:33:10 <bobthecreator> :?
04:33:28 <bobthecreator> is this some kind of for loop
04:33:29 <ongy> universalpackage: seems like your repos are missing an dependency. what distro are you using?
04:33:33 <Iceland_jack> @let fizz' n | 15 `divides` n = "FizzBuzz" | 3 `divides` n = "Fizz" | 5 `divides` n = "Buzz" | otherwise = show n
04:33:34 <lambdabot>  Defined.
04:33:37 <universalpackage> chakra
04:33:39 <Iceland_jack> > unwords (map fizz' [1..100])
04:33:41 <lambdabot>  "1 2 Fizz 4 Buzz Fizz 7 8 Fizz Buzz 11 Fizz 13 14 FizzBuzz 16 17 Fizz 19 Buz...
04:33:53 <bobthecreator> ooog
04:33:57 <bobthecreator> ooooohh
04:34:03 <Iceland_jack> (15 `divides` n) reads a lot better than (n `mod` 13 == 0)
04:34:04 <Iceland_jack> *15
04:34:08 <bobthecreator> the actual for loop doesn't happen until you use the map command
04:34:32 <bobthecreator> its almost like giving the instructions for the 'for loop' outside of the loop
04:34:35 <Iceland_jack> Yes, (fizz :: Int -> String) is just a function that operates on a single number
04:34:42 <Iceland_jack> > fizz 10
04:34:44 <lambdabot>  "Buzz"
04:34:47 <universalpackage> /lib/libncursesw.so
04:34:48 <universalpackage> /lib/libncursesw.so.6
04:34:49 <Iceland_jack> > fizz 15
04:34:50 <universalpackage> /lib/libncursesw.so.6.0
04:34:52 <lambdabot>  "FizzBuzz"
04:35:07 <ongy> then you probably need some ncurses-5 or ncurses-compat package (which is hopefully provided)
04:35:16 <universalpackage>  ghc-7.10.3-1-x86_64                                                   63.2 MiB  34.5K/s 31:14 [########################################################] 100%
04:35:18 <universalpackage>  haskell-binary-0.8.3.0-1-x86_64                                      264.6 KiB  36.8K/s 00:07 [########################################################] 100%
04:36:18 * hackagebot EntrezHTTP 1.0.4 – Libary to interface with the NCBI Entrez REST service. – https://hackage.haskell.org/package/EntrezHTTP
04:36:45 <universalpackage> i dont have that
04:36:49 <sphinxo> why does this in my stack.yml http://lpaste.net/932490983973584896
04:36:54 <sphinxo> yield Error in $['extra-deps'][7]: failed to parse field 'extra-deps': expected PackageIdentifier, encountered Object
04:37:09 <sphinxo> reference: https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#git-and-mercurial-repos
04:37:48 <bobthecreator> in java id need to make an for loop like this:  String result; for (int i = 0; i <= 100; ++i) { result = (i % 15) ? "FizzBuzz" : ((i % 3) ? "Fizz" : ((i % 5) ? : "Buzz" : i.toString())) ; System.out.println(result); }
04:38:36 <bobthecreator> I used nested ternaries for space wise
04:38:48 <Iceland_jack> bobthecreator: It's good to separate the control (looping) from the functionality (actually computing the string based on a single value (fizz :: Int -> String))
04:39:25 <bobthecreator> basically the equivalent to what Haskell does it like a making a function to accept the (n) argument
04:40:44 <bobthecreator> i forgot something in my math
04:40:53 <bobthecreator> where i put (i % 15)
04:40:58 <bobthecreator> i was supposed to write
04:41:04 <bobthecreator> (i % 15 == 0)
04:41:32 <Iceland_jack> @let (%) = mod
04:41:33 <lambdabot>  Defined.
04:41:34 <Iceland_jack> :3
04:41:35 <bobthecreator> that means that the variable modulo 15 is 0
04:41:39 <bobthecreator> lol
04:41:45 <Iceland_jack> > 5 % 15 == 0
04:41:48 <lambdabot>  error:
04:41:48 <lambdabot>      Ambiguous occurrence ‘%’
04:41:48 <lambdabot>      It could refer to either ‘Data.Ratio.%’,
04:41:51 <bobthecreator> :D
04:41:53 <Iceland_jack> hah.. already exists
04:41:59 <Iceland_jack> @let (%%) = mod
04:42:00 <sphinxo> how do I include a github project as a dependency?
04:42:01 <lambdabot>  Defined.
04:42:02 <Iceland_jack> > 5 %% 15 == 0
04:42:04 <lambdabot>  False
04:42:06 <bobthecreator> yeeey
04:42:10 <Iceland_jack> > 30 %% 15 == 0
04:42:12 <lambdabot>  True
04:42:14 <sphinxo> tried https://github.com/commercialhaskell/stack/blob/master/doc/yaml_configuration.md#git-and-mercurial-repos but getting what I put above
04:42:18 <bobthecreator> \o/ awesome
04:42:24 <Iceland_jack> > let 2 + 2 = 5 in 2 + 2
04:42:27 <lambdabot>  5
04:42:27 <Iceland_jack> ;)
04:42:34 <bobthecreator> hah
04:42:38 <kuribas> lol
04:42:40 <bobthecreator> why you do dis
04:42:40 <boj> sphinxo: could you post the whole stack.yaml? not sure the section you showed us is the actual problem
04:42:51 <Iceland_jack> bobthecreator: because I should be at lunch :)
04:42:53 <kuribas> > let 2 + 2 = 5 in 2 + 3
04:42:56 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function +
04:43:03 <bobthecreator> > let 0 = 1 in 5 / 0
04:43:05 <lambdabot>  Infinity
04:43:10 <bobthecreator> did i do something wrong
04:43:14 <Iceland_jack> > let x = 1:x in x
04:43:17 <lambdabot>  [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1...
04:43:23 <bobthecreator> one oneoneoneoneoneoneone
04:43:24 <sphinxo> boj oh wait, I think I need to location: and then git stuff
04:43:37 <bobthecreator> > let 5 / 0 = 1 in 5 / 0
04:43:40 <lambdabot>  1
04:43:42 <bobthecreator> yey
04:43:43 <universalpackage> i cant install haskell ;-;
04:43:43 <boj> sphinxo: ah, yep
04:44:13 <bobthecreator> so you can do whatever you want
04:44:21 <boj> been using nix for awhile now, should probably stop trying to answer stack questions
04:44:32 <bobthecreator> > let 0 / 0 = 1 in 0 / 0
04:44:35 <lambdabot>  1
04:44:40 <bobthecreator> > 0 / 0
04:44:42 <lambdabot>  NaN
04:44:55 <bobthecreator> (0/0)
04:44:57 <bobthecreator> face ^
04:45:05 <ongy>  > let 0 / 0 = 1 in 0  /  0
04:45:13 <ongy> > let 0 / 0 = 1 in 0  /  0
04:45:16 <lambdabot>  1
04:45:23 <boj> bobthecreator: check out the linear library. has a lot of fancy anime face operators
04:45:28 <ongy> I'm surprised this works, but cool to know
04:45:39 <bobthecreator> tbh i cant understand why you would need this
04:45:49 <bobthecreator> show me a result to a math operation that i have predefined
04:46:16 <kuribas> bobthecreator: you can rebind all operators.
04:46:24 <bobthecreator> what the NOT operator look like
04:46:28 <bobthecreator> in java its !
04:46:29 <ongy> > let 0 / 0 = 1 in 1 /  0
04:46:32 <lambdabot>  *Exception: <interactive>:3:5-13: Non-exhaustive patterns in function /
04:46:33 <ongy> > not True
04:46:35 <lambdabot>  False
04:46:45 <bobthecreator> > let not True = True in not True
04:46:48 <lambdabot>  True
04:46:50 <bobthecreator> xDDDDD
04:47:02 <bobthecreator> im dying here
04:47:04 <Marisa> BTW when is backpack getting in ghc trunk?
04:47:09 <ongy> that shadows the definition of not btw. so this will be an error
04:47:12 <kuribas> bobthecreator: operators behave just like functions and variables.
04:47:14 <ongy> > let not True = True in not False
04:47:16 <lambdabot>  *Exception: <interactive>:3:5-19: Non-exhaustive patterns in function not
04:47:30 <kuribas> bobthecreator: with respect to scoping rules.
04:47:38 <bobthecreator> aha
04:47:46 <bobthecreator> so you can define a type as a variable?
04:47:59 <bobthecreator> or, redefine a type
04:48:02 <ongy> if only...
04:48:12 <bobthecreator> but thats what ive been doing
04:48:15 <bobthecreator> let me try something
04:48:39 <bobthecreator> > let not True = "this is a string being applied to a boolean expression" in not True
04:48:41 <lambdabot>  "this is a string being applied to a boolean expression"
04:48:45 <boj> you can define some arbitrary value that shadows a function to a new function of your choosing
04:48:50 <ongy> what you can do is shadow an existing definition. So the function called "not" will not be the one defined somewhere before, but the function you define there
04:48:59 <bobthecreator> yeap
04:49:08 <bobthecreator> you both said same thing in different ways
04:49:17 <bobthecreator> funny
04:49:33 <bobthecreator> > let 1+1= not True in 1+1
04:49:36 <lambdabot>  False
04:49:42 <bobthecreator> 1+1 = False
04:49:44 <bobthecreator> :)
04:50:10 <bobthecreator> can someone explain when this  might be necessary
04:50:20 <ongy> > let 1 + 1 = True in 1 + 2 -- As you can see here, this shadows the entire (+) function.
04:50:23 <lambdabot>  *Exception: <interactive>:3:5-16: Non-exhaustive patterns in function +
04:50:32 <hpc> :t let 1+1 = False in (+)
04:50:34 <lambdabot> (Eq a1, Eq a, Num a1, Num a) => a1 -> a -> Bool
04:50:59 <bobthecreator> im confused
04:51:04 <bobthecreator> by all the lambdas
04:51:26 <ongy> this will produce a warning when you compile with -Wall. Shadowing can sometimes be nice to have descriptive names even when they got used before. But IMO it's just confusing
04:51:40 <bobthecreator> yeas
04:51:42 <bobthecreator> i agree
04:51:51 <t7> how can i add a class constraint to a type variable in an instance ?
04:51:53 <bobthecreator> developers must have had something in mind when they made shadowing
04:52:15 <t7> for example     instance Subst [a] where (and    Subst a)
04:52:19 <boj> bobthecreator: sometimes you really want "id" as a record field name and not the id function
04:52:26 <bobthecreator> oh
04:52:58 <boj> :t id
04:53:00 <lambdabot> a -> a
04:53:12 <ongy> t7: instance Show a => Show [a] where ...
04:53:26 <bobthecreator> > let map = "this is the map string" in unwords map
04:53:29 <lambdabot>  error:
04:53:29 <lambdabot>      • Couldn't match type ‘Char’ with ‘[Char]’
04:53:29 <lambdabot>        Expected type: [String]
04:53:33 <bobthecreator> eh
04:53:38 <t7> ongy: ah cheers
04:53:42 <bobthecreator> haalp
04:53:49 <ongy> :t unwords -- unwords takes a list of strings, not a single string
04:53:51 <lambdabot> [String] -> String
04:54:07 <ongy> > unwords ["like", "this", "list", "of", "words"]
04:54:09 <lambdabot>  "like this list of words"
04:54:19 <bobthecreator> > let map = "this is the map string" in words map
04:54:21 <lambdabot>  ["this","is","the","map","string"]
04:54:24 <bobthecreator> yeeyyy
04:54:52 <bobthecreator> so i just took a name of a function and made it a variable
04:55:10 <bobthecreator> id like to experiment for something funny
04:56:52 <bobthecreator> im thinking maybe you can nest let commands
04:57:15 <boj> bobthecreator: you should install GHC and try this in the ghci repl
04:57:51 <Fekinox> heyo, figure I should introduce myself after lurking for so long
04:57:57 <boj> hello
04:59:48 <bobthecreator> > let (words (let words = "words") = "let") in words (let words = "words")
04:59:50 <lambdabot>  <hint>:1:32: error: parse error on input ‘)’
05:00:02 <bobthecreator> well, i tried
05:00:36 <bobthecreator> > let (words (let words = "words")) = "let" in (words (let words = "words"))
05:00:39 <lambdabot>  <hint>:1:32: error: parse error on input ‘)’
05:00:41 <bobthecreator> nope
05:00:56 <ongy> bobthecreator: you can try such things in query with lambdabot
05:01:06 <boj> bobthecreator: let is an actual language keyword
05:01:10 <bobthecreator> doesn't work anyhow ^_^
05:01:22 <bobthecreator> you cant  let let mean something else
05:01:31 <ongy> but what you are doing here, doesn't work. You can't rebind the entire text, but you rebind the function and the previous examples worked due to pattern matching.
05:01:49 <bobthecreator> yes
05:01:51 <ongy> to understand that, and why/what works you'd have to understand the basics.
05:01:54 <bobthecreator> you cant rebind a function
05:01:55 <ongy> @where cs192
05:01:56 <lambdabot> I know nothing about cs192.
05:02:04 <ongy> can someone link the tutorial?
05:02:08 <Fekinox> > let (+) = (-) in 2+2
05:02:10 <lambdabot>  0
05:02:20 <ongy> shadow, not rebind. sorry
05:02:29 <bobthecreator> @where the_dead_body
05:02:29 <lambdabot> I know nothing about the_dead_body.
05:02:33 <bobthecreator> xD
05:02:44 <bobthecreator> interrogating a bot
05:03:33 <bobthecreator> > let let = "let" in words let
05:03:36 <lambdabot>  <hint>:1:9: error:
05:03:36 <lambdabot>      parse error on input ‘=’
05:03:36 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:04:14 <bobthecreator> so, no?
05:04:22 <Fekinox> doesn't look like it
05:04:24 <bobthecreator> you cant redefine let
05:04:33 <Fekinox> let isn't a function, it's a syntactic construct it seems
05:04:37 <boj> bobthecreator: https://wiki.haskell.org/Keywords
05:04:41 <ongy> let is a keyword, so it behaves different. kinda like you can't have a variable called 'new' in java
05:04:44 <bobthecreator> syntacstic what
05:04:52 <Fekinox> keyword's a simpler term
05:05:02 <ertes-w> :t lunch
05:05:04 <lambdabot> pizza
05:05:25 <ongy> > lunch
05:05:27 <lambdabot>  *Exception: Curious?
05:05:46 <boj> :t lunch
05:05:48 <lambdabot> pizza
05:05:54 <kuribas> lambdabot: are you hungry?
05:06:00 <bobthecreator> is lunch a keyword?
05:06:02 <ongy> pizza isn't even valid as a type name, is it?
05:06:16 <bobthecreator> > lunch
05:06:17 <ongy> not usually. probably an easteregg in lambdabot
05:06:18 <lambdabot>  *Exception: Curious?
05:06:20 <ertes-w> ongy: it is…  it's a variable =)
05:06:23 <bobthecreator> maybe
05:06:29 <kuribas> :t type
05:06:31 <lambdabot> error: parse error on input ‘type’
05:06:38 <ertes-w> @let blah :: blubb; blah = error "Uhh!"
05:06:39 <Marisa> > show lunch
05:06:40 <lambdabot>  Defined.
05:06:41 <lambdabot>  "*Exception: Curious?
05:06:44 <ertes-w> :t blah
05:06:45 <lambdabot> blubb
05:06:52 <Marisa> > fix error
05:06:53 <boj> ahh
05:06:54 <lambdabot>  "*Exception: *Exception: *Exception: *Exception: *Exception: *Exception: *Ex...
05:06:59 <bobthecreator> oh dear
05:07:04 <ongy> hmm, I thought type names have to start with capital letter. seems I'm misinformed
05:07:14 <Marisa> :k pizza
05:07:14 <bobthecreator> :t Type
05:07:15 <lambdabot> error: Not in scope: type variable ‘pizza’
05:07:16 <lambdabot> error: Data constructor not in scope: Type
05:07:17 <hpc> type constructors do, type variables don't
05:07:19 <ertes-w> ongy: it's a type *variable*
05:07:27 <hpc> :t (lunch + 1)
05:07:29 <lambdabot> Num a => a
05:07:33 <bobthecreator> :t pizza
05:07:35 <hpc> :t not lunch
05:07:35 <lambdabot> error: Variable not in scope: pizza
05:07:36 <lambdabot> Bool
05:07:36 <ertes-w> ongy: i could just as well have typed "lunch :: a", like 'undefined'
05:07:37 <ongy> ertes-w: oh, then it makes sense.
05:08:00 <Marisa> not lunch
05:08:04 <Marisa> > not lunch
05:08:06 <lambdabot>  *Exception: Curious?
05:08:24 <ongy> > error "Curious?" -- :)
05:08:27 <lambdabot>  *Exception: Curious?
05:08:56 <bobthecreator> @let lunch = "spaghetti" -- enough pizza for one day
05:08:58 <lambdabot>  .L.hs:164:1: error:
05:08:58 <lambdabot>      Multiple declarations of ‘lunch’
05:08:58 <lambdabot>      Declared at: .L.hs:160:1
05:09:04 <bobthecreator> :D
05:09:11 <Fekinox> > data Topping = Pepperoni | Sausage | Mushroom | Pineapple; data Pizza = CheesePizza | PizzaWithToppings [Topping]
05:09:13 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
05:09:31 <Fekinox> eh, an attempt was made
05:09:33 <bobthecreator> why did you use a semicolon
05:09:55 <ongy> it's syntax you can use when you can't use a linebreak (e.g. because you are feeding the bot)
05:10:04 <bobthecreator> interesting
05:10:05 <Fekinox> yeah, it's to separate the statements
05:10:13 <ongy> but in most code, a linebreak would be used, since it's more readable when you have a file
05:10:18 <bobthecreator> and yet semi colons arent necessary normally
05:11:42 <bobthecreator> > Int num = 10; unwords map [0..num]
05:11:44 <lambdabot>  <hint>:1:9: error:
05:11:44 <lambdabot>      parse error on input ‘=’
05:11:44 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:11:56 <bobthecreator> mmm
05:12:03 <bobthecreator> didnt i declare the variable correctlyu
05:12:23 <quchen> > data Foo = Int Int
05:12:26 <lambdabot>  <hint>:1:1: error: parse error on input ‘data’
05:12:29 <quchen> ?define data Foo = Int Int
05:12:31 <lambdabot>  Defined.
05:12:32 <Marisa> Fekinox, you remind me of Dan Friedman :)
05:12:50 <quchen> > let Int x = 10 in show x
05:12:52 <lambdabot>  error:
05:12:52 <lambdabot>      • No instance for (Num Foo) arising from the literal ‘10’
05:12:52 <lambdabot>      • In the expression: 10
05:13:01 <quchen> Arr. Nevermind.
05:13:09 <quchen> ?undef
05:13:09 <lambdabot> Undefined.
05:13:36 <bobthecreator> > unwords map [0..(2 * 10)]
05:13:38 <lambdabot>  error:
05:13:39 <lambdabot>      • Couldn't match expected type ‘[Integer] -> t’
05:13:39 <lambdabot>                    with actual type ‘[Char]’
05:14:19 <ongy> bobthecreator: unwords works on lists of strings. and you have a list of Integers
05:14:40 <bobthecreator> how do you cast it to string or wrap it
05:14:52 <quchen> > unwords (map show [1..10])
05:14:55 <lambdabot>  "1 2 3 4 5 6 7 8 9 10"
05:15:08 <Fekinox> :t show
05:15:09 <lambdabot> Show a => a -> String
05:15:18 <bobthecreator> aha
05:15:33 <bobthecreator> > words show not True
05:15:35 <lambdabot>  error:
05:15:35 <lambdabot>      • Couldn't match expected type ‘(Bool -> Bool) -> Bool -> t’
05:15:35 <lambdabot>                    with actual type ‘[String]’
05:15:42 <bobthecreator> oh dear
05:15:52 <ongy> > words (show (not True))
05:15:55 <lambdabot>  ["False"]
05:15:58 <bobthecreator> x)
05:16:03 <bobthecreator> parenthesis
05:16:32 <Fekinox> words $ show $ not True
05:16:41 <Fekinox> > words $ show $ not True
05:16:43 <lambdabot>  ["False"]
05:16:48 <bobthecreator> ohh :o
05:16:51 <ertes-w> > (words . show . not) True
05:16:53 <bobthecreator> :t $
05:16:54 <lambdabot>  ["False"]
05:16:54 <lambdabot> error:
05:16:55 <lambdabot>     parse error on input ‘$’
05:16:55 <lambdabot>     Perhaps you intended to use TemplateHaskell
05:17:04 <Akii> :t ($)
05:17:06 <lambdabot> (a -> b) -> a -> b
05:17:14 <bobthecreator> :k ($)
05:17:15 <lambdabot> error:
05:17:15 <lambdabot>     Not in scope: type constructor or class ‘$’
05:17:22 <ertes-w> bobthecreator: if you want to refer to an operator without applying it, you need to (wrap it in parentheses)
05:17:36 <Fekinox> bobthecreator: to clarify, f $ x = f x
05:17:50 <ongy> :k String -- :k works on types, :t on values
05:17:52 <lambdabot> *
05:17:59 <Fekinox> but the $ operator has extremely low precedence so it is evaluated last
05:18:06 <bobthecreator> does that mean f $ x * 2 = f (x*2)
05:18:16 <Fekinox> yeah
05:18:28 <Logio> namely, f . g $ x = f (g (x))
05:18:36 <ertes-w> and: f $ g $ x = f $ (g $ x)
05:19:01 <bobthecreator> whats difference of . and $
05:19:56 <bobthecreator> > 1+1 * 2
05:19:59 <lambdabot>  3
05:20:03 <bobthecreator> > 1+1 . * 2
05:20:05 <lambdabot>  <hint>:1:7: error: parse error on input ‘*’
05:20:10 <Iceland_jack> bobthecreator: ($) literally does nothing
05:20:14 <Logio> bobthecreator: . is function composition
05:20:23 <Iceland_jack> > show $ 100
05:20:26 <lambdabot>  "100"
05:20:26 <Iceland_jack> > show 100
05:20:30 <lambdabot>  "100"
05:20:33 <bobthecreator> fascinating
05:20:52 <bobthecreator> > 1+1-2+2
05:20:54 <lambdabot>  2
05:21:04 <bobthecreator> > 1+ $ 1-2 $ +2
05:21:06 <lambdabot>  <hint>:1:4: error:
05:21:06 <lambdabot>      parse error on input ‘$’
05:21:06 <lambdabot>      Perhaps you intended to use TemplateHaskell
05:21:19 <bobthecreator> > 1 $ 1-2 $ 2
05:21:21 <lambdabot>  error:
05:21:21 <lambdabot>      • Could not deduce (Num t0)
05:21:21 <lambdabot>        from the context: (Num (t -> t2), Num (t2 -> t3), Num t)
05:21:39 <Iceland_jack> > (10 +) $ 5
05:21:40 <ertes-w> bobthecreator: (f . g) is the function that first applies g, then applies f
05:21:41 <lambdabot>  15
05:22:03 <ertes-w> bobthecreator: it's defined like this:  (f . g) x = f (g x)
05:22:13 <bobthecreator> > (1+) $ 1-2 $ (+2)
05:22:15 <lambdabot>  error:
05:22:15 <lambdabot>      • Could not deduce (Num a0)
05:22:15 <lambdabot>        from the context: (Num ((a -> a) -> a1), Num a, Num a1)
05:22:20 <Fekinox> :t 1-2
05:22:21 <lambdabot> Num a => a
05:22:26 <thimoteus> this is why i like to PM lambdabot
05:22:39 <ertes-w> bobthecreator: so for all f, g and x, whenever you write (f (g x)) you can write ((f . g) x) and get the same result
05:22:57 <bobthecreator> but sometimes precendence changes the result
05:23:05 <ertes-w> bobthecreator: this is another advantage of haskell: you can use equational reasoning like that, because "=" introduces equations
05:23:21 <ertes-w> it's not assignment like in java
05:23:28 <bobthecreator> aha
05:24:22 <bobthecreator> 1 + (2 / 3) not = (1 + 2) / 3
05:24:59 <Logio> > let 2 + 2 = 5 in 2 + 2
05:25:01 <lambdabot>  5
05:25:29 <bobthecreator> > show (1 + (2 / 3)) . ((1 + 2) / 3)
05:25:32 <lambdabot>  error:
05:25:32 <lambdabot>      • Couldn't match type ‘[Char]’ with ‘b0 -> c’
05:25:32 <lambdabot>        Expected type: b0 -> c
05:25:48 <bobthecreator> > show (1 + (2 / 3)) $ ((1 + 2) / 3)
05:25:50 <lambdabot>  error:
05:25:50 <lambdabot>      • Couldn't match expected type ‘Double -> t’
05:25:50 <lambdabot>                    with actual type ‘[Char]’
05:25:55 <bobthecreator> good grief
05:26:04 <bobthecreator> > show (1 + (2 / 3)); show ((1 + 2) / 3)
05:26:06 <lambdabot>  <hint>:1:19: error: parse error on input ‘;’
05:26:13 <bobthecreator> im done..
05:26:29 <ertes-w> > (show (1 + 2/3), show ((1 + 2)/3))
05:26:31 <lambdabot>  ("1.6666666666666665","1.0")
05:26:44 <Iceland_jack> I'm enjoying your work bobthecreator
05:26:46 <Logio> bobthecreator: Haskell is not forgiving of writing code before thinking
05:26:55 <bobthecreator> every command i think of has a completely different way of being written to what i expected
05:27:16 <ertes-w> bobthecreator: you should learn the basics
05:27:22 <ongy> bobthecreator: don't get discouraged. Most of us started out like that. But I would really recommend using a proper tutorial
05:27:26 <Logio> bobthecreator: note that function application has the highest precedence
05:27:46 <bobthecreator> why is it that semicolon works when separating commands before
05:27:56 <ertes-w> bobthecreator: https://www.cis.upenn.edu/~cis194/
05:27:57 <bobthecreator> cant you have two successive show commands
05:27:59 <quchen> Logio: Quite the opposite, Haskell is very forgiving! Imagine what a Python program does that you write without thinking!
05:28:18 <ertes-w> bobthecreator: what's a "command"?
05:28:22 <bobthecreator> whats worse, if you write without thinking in Java, the program works, but inefficiently
05:28:23 <ertes-w> 'show' is just a function
05:28:30 <bobthecreator> eh
05:28:54 <bobthecreator> > (show 1)
05:28:57 <lambdabot>  "1"
05:29:02 <bobthecreator> > (show 1); (show 2)
05:29:05 <lambdabot>  <hint>:1:9: error: parse error on input ‘;’
05:29:11 <bobthecreator> blahp
05:29:26 <ertes-w> bobthecreator: you have a very imperative way of thinking…  you seem to think in terms of sequences of actions, but haskell has a different model
05:29:39 <Logio> quchen: true, launching missiles is perhaps less forgiving than a compiler error
05:29:44 <bobthecreator> my brain is incompatible atm xD
05:29:51 <ertes-w> bobthecreator: 'show' is a function…  it takes an argument and returns a result, nothing more
05:29:59 <bobthecreator> yes
05:30:06 <bobthecreator> why cant i have two?
05:30:21 <ertes-w> bobthecreator: you can, but whatever you want to do, it has to be an expression
05:30:28 <bobthecreator> an expression...
05:30:32 <Iceland_jack> bobthecreator: Do you think this makes sense? "hi" ; "oh" ; "bye"
05:30:33 <ertes-w> for example you could concatenate the results
05:30:45 <Iceland_jack> if not; why not
05:30:46 <bobthecreator> no that doesnt
05:30:51 <ertes-w> > show 1 ++ show 2
05:30:51 <Fekinox> or return them as a tuple
05:30:53 <bobthecreator> because ooooof
05:30:54 <lambdabot>  "12"
05:30:55 <bobthecreator> ooooh
05:30:58 <Iceland_jack> bobthecreator: :)
05:31:04 <Fekinox> > (show 1, show 2)
05:31:06 <lambdabot>  ("1","2")
05:31:09 <bobthecreator> > (show 1) ++ (show 2)
05:31:11 <lambdabot>  "12"
05:31:18 <bobthecreator> interesting
05:31:45 <Iceland_jack> Haskell makes the distinction between values ("foo") and actions/commands (putStrLn "foo") very clear
05:32:04 <bobthecreator> > putStrLn "foo"
05:32:05 <ertes-w> bobthecreator: this will become particularly true when you get to the IO section of your favourite tutorial
05:32:06 <lambdabot>  <IO ()>
05:32:18 <ertes-w> IO is expression-like the same way String and Integer are
05:32:21 <Iceland_jack> bobthecreator: The semicolon (;) is actually a function in Haskell
05:32:21 <bobthecreator> do i already have a favorite tutorial :D
05:32:27 <Iceland_jack> called (>>) :: IO a -> IO b -> IO b
05:32:28 <ertes-w> bobthecreator: yes, the one i linked =)
05:32:33 <Iceland_jack> :t print 1 >> print 2
05:32:35 <lambdabot> IO ()
05:32:35 <bobthecreator> ahhhh
05:32:38 <Iceland_jack> :t print 1 >> print 2 >> print 3
05:32:39 <lambdabot> IO ()
05:32:51 <Iceland_jack> so when you write (do print 1; print 2; print 3) it DESUGARS to what I wrote
05:32:54 <bobthecreator> IO () is lamdabot's equivalent of a poker face
05:33:07 <Iceland_jack> po po po poker face
05:33:15 <bobthecreator> xD
05:33:40 <quchen> > unwords (replicate 4 "po") ++ "ker face"
05:33:42 <lambdabot>  "po po po poker face"
05:33:43 <bobthecreator> what does DESUGARS mean
05:34:12 <tdammers> bobthecreator: "desugar": remove syntax sugar. translate code that uses syntax sugar into code that doesn't
05:34:17 <quchen> Desugaring is a form of evaluation, namely one that is just there to make the syntax nicer.
05:34:19 <tdammers> in this case, do notation is the sugar
05:34:32 <bobthecreator> ohhh
05:34:40 <bobthecreator> thats the kind of code execution that i understand
05:34:43 <quchen> [1..10] is actually just sugar for writing »enumFromTo 1 10« for example.
05:34:48 <quchen> > enumFromTo 1 10
05:34:51 <lambdabot>  [1,2,3,4,5,6,7,8,9,10]
05:35:00 <bobthecreator> yea, now just imagine for a moment
05:35:06 <boj> :t enumFromTo
05:35:08 <lambdabot> Enum a => a -> a -> [a]
05:35:14 <bobthecreator> i would compeltely be fine with writing an entire program desugared
05:35:21 <bobthecreator> because that would be easier for me to understand
05:35:32 <bobthecreator> coming from something like Java
05:35:33 <tdammers> bobthecreator: and you are encouraged to do just that
05:35:50 <bobthecreator> because to me [1..10] doesn't say anything to me code wise
05:35:54 <Logio> too much syntax sugar is bad for the brain
05:36:00 <bobthecreator> agreed.
05:36:29 <bobthecreator> all this time i thought haskell was over slimplified
05:36:36 <boj> bobthecreator: you mean the do-notatin makes more sense, yeah?
05:36:56 <bobthecreator> yea, it gives a logical structure to the execution order of code
05:36:57 <tdammers> and once you've written a lot of code in this sugar-free style, you'll start seeing patterns; and for some of these patterns, Haskell has a few shorthands that will make your life easier.
05:37:00 <ertes-w> bobthecreator: [1..10] = enumFromTo 1 10 = 1 : enumFromTo 2 10 = 1 : (2 : enumFromTo 3 10) = …
05:37:05 <boj> bobthecreator: that is actually the sugared syntax :)
05:37:26 <tdammers> bobthecreator: do notation does not necessarily determine execution order
05:37:40 <bobthecreator> hmmmmm
05:37:48 <bobthecreator> i would hope tho
05:37:55 <tdammers> > last $ do { x <- [1,2,3]; y <- [4,5,6]; return (x + y) }
05:37:57 <Logio> tdammers: or rather, neither does the desugared version
05:37:57 <lambdabot>  9
05:38:14 <bobthecreator> why are the arrows looking the other way
05:38:14 <Iceland_jack> > "oh" >> "hello" >> "world"
05:38:16 <lambdabot>  "worldworldworldworldworldworldworldworldworldworld"
05:38:29 <Akii> wat
05:38:33 <bobthecreator> xDDDD
05:38:42 <tdammers> Iceland_jack: that's a mean one
05:38:45 <Iceland_jack> :) sorry
05:38:52 <Akii> waaat
05:38:54 <Iceland_jack> bobthecreator: Oh, didn't I tell you: OUR semicolon is overloaded
05:38:54 <Akii> : (>>)
05:38:55 <Iceland_jack> ;)
05:38:56 <bobthecreator> is that some kind of shift register code
05:38:56 <quchen> Only Cont could be worse
05:39:07 <Akii> is that like on the list monad?
05:39:11 <Iceland_jack> yeah
05:39:11 <Logio> Akii: yes
05:39:18 <ertes-w> > [ w | o <- "oh", h <- "hello", w <- "world" ]
05:39:20 <lambdabot>  "worldworldworldworldworldworldworldworldworldworld"
05:39:21 <Akii> okay then I have a vague idea why
05:39:24 <ertes-w> Akii: ^
05:39:27 <Akii> thanks
05:39:37 <bobthecreator> im lost
05:39:41 <bobthecreator> where are the lights
05:39:43 <Iceland_jack> sorry bobthecreator
05:39:46 <ertes-w> same thing…  you just ignore the o-s and h-s
05:39:48 <bobthecreator> some flick the light switch
05:39:56 <Iceland_jack> data Switch = Off | On
05:39:56 <bobthecreator> someone
05:39:59 <bobthecreator> thanks
05:40:02 <bobthecreator> x)
05:40:09 <Akii> best to forget that again xD
05:40:13 <Iceland_jack> flip :: Switch -> Switchflip Off = On ; flip On  = Off
05:40:15 <Akii> mean Iceland_jack
05:40:23 <bobthecreator> @let Switch = Off | On
05:40:23 <lambdabot>  Parse failed: Parse error: |
05:40:23 <ertes-w> Akii: you get one (h, w) for each o, and you get one w for each h
05:40:35 <Iceland_jack> @let data Switch = Off | On deriving Show
05:40:37 <lambdabot>  Defined.
05:40:40 <tdammers> bobthecreator: the string example is mean because it abuses the list monad, and the fact that strings are lists of characters
05:40:47 <bobthecreator> > "0" >> "1"
05:40:49 <lambdabot>  "1"
05:40:53 <tdammers> bobthecreator: and the combination isn't exactly intuitive here
05:40:55 <bobthecreator> > "1" >> "1"
05:40:58 <lambdabot>  "1"
05:41:04 <Iceland_jack> bobthecreator: (deriving = GHC writing code for you)
05:41:07 <bobthecreator> > "2" >> "2"
05:41:08 <lambdabot>  "2"
05:41:11 <bobthecreator> help
05:41:12 <Logio> bobthecreator: don't worry about that one too much yet 
05:41:23 <ertes-w> > do [1,2]; [1..5]; "world"
05:41:24 <tdammers> bobthecreator: to solve this riddle, you need to know the definition of the Monad instance for lists
05:41:26 <lambdabot>  "worldworldworldworldworldworldworldworldworldworld"
05:41:30 <Iceland_jack> @let data Pair a = P a a deriving (Show, Foldable)
05:41:32 <lambdabot>  Defined.
05:41:34 <Iceland_jack> > sum (P 10 20)
05:41:37 <lambdabot>  30
05:41:37 <tdammers> bobthecreator: and then you can translate the monadic code back into plain old list manipulation
05:41:41 <Iceland_jack> > toList (P 10 20)
05:41:42 <bobthecreator> > "" >> "222"
05:41:44 <lambdabot>  error:
05:41:44 <lambdabot>      Ambiguous occurrence ‘toList’
05:41:44 <lambdabot>      It could refer to either ‘F.toList’,
05:41:44 <lambdabot>  ""
05:41:51 <tdammers> :t (>>=)
05:41:52 <lambdabot> Monad m => m a -> (a -> m b) -> m b
05:41:53 <Iceland_jack> > F,toList (P 10 20)
05:41:55 <lambdabot>  <hint>:1:2: error: parse error on input ‘,’
05:41:55 <tdammers> :t concatMap
05:41:57 <lambdabot> Foldable t => (a -> [b]) -> t a -> [b]
05:42:01 <Iceland_jack> ah forget it
05:42:03 <bobthecreator> did i mention im terrible at math
05:42:08 <bobthecreator> and big words
05:42:18 <ertes-w> bobthecreator: this is mostly just symbolic thinking
05:42:18 <bobthecreator> xD
05:42:31 <bobthecreator> i prefer more practical languages xD
05:42:35 <bobthecreator> less symbolic
05:42:46 <bobthecreator> VB6 for example
05:42:50 <bobthecreator> x"D
05:42:53 <ertes-w> bobthecreator: symbolicness and practicality are orthogonal…  i'm using haskell in practice ;)
05:43:04 <bobthecreator> big wooordsss
05:43:11 <ertes-w> in fact symbolicness makes the language far more practical once you get used to it
05:43:14 <Logio> bobthecreator: mostly, haskell leaves the details to the compiler
05:43:23 <bobthecreator> okayyyyy
05:44:01 <ertes-w> bobthecreator: if you just follow the tutorial i linked, all of this will make perfect sense…  and ruin you for "practical" languages =)
05:44:18 <Akii> ^ he's right you know
05:44:21 <bobthecreator> > foo x y = x + y * 2
05:44:23 <tdammers> haskell is very high-level, which means that you think more about the general properties of your problem and less about the technical details of solving it
05:44:24 <lambdabot>  <hint>:1:9: error:
05:44:24 <lambdabot>      parse error on input ‘=’
05:44:24 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
05:44:30 <bobthecreator> > @let foo x y = x + y * 2
05:44:32 <lambdabot>  <hint>:1:1: error: parse error on input ‘@’
05:44:37 <bobthecreator> > let foo x y = x + y * 2
05:44:39 <lambdabot>  <no location info>: error:
05:44:40 <lambdabot>      not an expression: ‘let foo x y = x + y * 2’
05:44:44 <bobthecreator> blah
05:44:52 <ertes-w> bobthecreator: "@let", not "> @let"
05:44:59 <Iceland_jack> @let foo x y = x + y * 2
05:45:01 <lambdabot>  Defined.
05:45:02 <Iceland_jack> > foo 10 5
05:45:04 <lambdabot>  20
05:45:13 <bobthecreator> hmm
05:45:13 <Logio> I would say that when writing Haskell, it's easier to think it as just defining the things you want precisely (as in, _what_ they are, not _how_ they come about)
05:45:21 <Fekinox> bobthecreator: once you learn functions like map, filter, and fold you wouldn't want to touch for/while loops with a ten foot pole
05:45:31 <bobthecreator> heh
05:45:39 <bobthecreator> yes, but do you have simple for loops
05:45:44 <Logio> no
05:45:52 <bobthecreator> for (object o : objectCollection()) { }
05:45:53 <Logio> map is infinitely better
05:46:00 <ertes-w> bobthecreator: we have folds, which are for-loops on steroids
05:46:00 <tdammers> for loops are never simple
05:46:06 <bobthecreator> woahh
05:46:12 <Iceland_jack> #haskell : we have the folds!
05:46:20 <tdammers> when for loops are simple, they are generally special cases that can be better expressed as traversals or folds
05:46:45 <bobthecreator> was this language designed by nuclear theoretical physicists or something?
05:46:57 <Logio> bobthecreator: worse, category theorists
05:47:03 <raek> haha
05:47:03 <bobthecreator> what even is that!!
05:47:05 <tdammers> how often have you written code like `for (i = 0; i < items.length; i++) { do_something(items[i]); }?
05:47:06 <Iceland_jack> bobthecreator: ;)
05:47:18 <bobthecreator> tdammers: all the time
05:47:19 <ertes-w> i don't think category theory was on their radar when they first imagined haskell
05:47:33 * Iceland_jack . o O (( It's working y'all, soon we will draw bobthecreator to the dark side ))
05:47:39 <bobthecreator> xDDDD
05:47:45 <yushyin> well, we do have for_ ;)
05:47:48 <tdammers> bobthecreator: exactly, but the variable 'i' in there, and the fact that you're incrementing it, and all that, are completely irrelevant to what you are trying to do
05:47:49 <Iceland_jack> for_ is much better
05:47:50 <Akii> anyone told him we have cookies?
05:48:00 <bobthecreator> wait wait wait tdammers
05:48:12 <Akii> data Cookie -- <- there
05:48:13 <bobthecreator> did you just say iterating 'i' is irrelevant xD
05:48:23 <ertes-w> bobthecreator: it is
05:48:24 <Akii> nobody tell him its type tho
05:48:28 <tdammers> bobthecreator: yes. as far as the problem domain is concerned, i doesn't exist
05:48:35 <bobthecreator> oh dear my brain xD
05:48:36 <tdammers> bobthecreator: you invented it just so you could iterate over items
05:48:41 <Fekinox> it's just used so that you can do something to each element of the list
05:48:43 <bobthecreator> well yea
05:49:00 <tdammers> bobthecreator: some languages allow you to write this instead: for (item in items) { do_thing(item); }
05:49:01 <ertes-w> bobthecreator: the counting variable and step-wise incrementation are all products of your particular way of tackling the problem of repetition
05:49:09 <bobthecreator> there are some other ways to iterate over collections without for loops in java
05:49:22 <ertes-w> bobthecreator: all of them boil down to for-loops
05:49:28 <tdammers> but really what you want isn't even iteration, usualluy
05:49:34 <bobthecreator> :\
05:49:39 <tdammers> what you want most of the time is this:
05:49:45 <tdammers> 1. I have a collection of things
05:49:48 <bobthecreator> yes
05:49:53 <tdammers> 2. I have a way of turning a thing into some other thing
05:49:58 <tdammers> 3. I want a collection of other things
05:50:06 <bobthecreator> you lost me at 2
05:50:28 <ertes-w> bobthecreator: like applying a function to each member of the collection
05:50:32 <bobthecreator> right
05:50:32 <tdammers> 2. you know how to turn things of type A into things of type B
05:50:39 <tdammers> or
05:50:41 <bobthecreator> hheheheh
05:50:50 <tdammers> 2. you know how to turn apple seeds into apple trees
05:50:57 <bobthecreator> stop with the sugar already xD
05:51:15 <tdammers> so what you want is not "look at every apple seed individually"
05:51:26 <bobthecreator> its not?
05:51:31 <tdammers> what you really want is "turn these 10 apple seeds into apple trees"
05:51:32 <Iceland_jack> 2.5. You add HFCS
05:51:37 <bobthecreator> buuut
05:51:48 <bobthecreator> sometimes iteration is not just as easy as that
05:51:58 <bobthecreator> you might need to do something to fifth apple seed
05:51:59 <tdammers> true; sometimes you want more than that
05:52:17 <tdammers> for example, treating certain indexes specially
05:52:17 <bobthecreator> because there was a folklore about every fifth apple seed makes bad trees
05:52:27 <tdammers> detecting whether it's the first element or not
05:52:41 <Iceland_jack> filter goodSeeds :
05:52:43 <Iceland_jack> :)
05:52:48 <bobthecreator> xD
05:52:51 <tdammers> or you may need to know something about the next apple seed in the list while processing the current one
05:53:05 <tdammers> that's why there are *other* special cases of for loops
05:53:22 <tdammers> but there's only a small handful of them, and everything else can be expressed in terms of those
05:54:04 <Iceland_jack> (sum . filter odd) = I want to sum all odd numbers
05:54:14 <Iceland_jack> > sum (filter odd [1,2,3,4])
05:54:15 <bobthecreator> so, does that mean most of the time there are rarely code that takes forever to execute
05:54:16 <lambdabot>  4
05:54:23 <tdammers> that's orthogonal
05:54:37 <tdammers> remember, the collection we're acting on may be infinite
05:54:43 <bobthecreator> question
05:54:44 <tdammers> map (+ 1) [1..]
05:54:48 <tdammers> > map (+ 1) [1..]
05:54:51 <lambdabot>  [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29...
05:55:13 <Fekinox> foldr (+) [1..100^82130142]
05:55:17 <Fekinox> > foldr (+) [1..100^82130142]
05:55:19 <bobthecreator> oh dear
05:55:20 <lambdabot>  error:
05:55:20 <lambdabot>      • No instance for (Typeable t0)
05:55:20 <lambdabot>          arising from a use of ‘show_M666951891854915825531722’
05:55:43 <bobthecreator> wait a sec
05:55:53 <bobthecreator> dont you have something like Integer.MAX_INT
05:56:00 <Iceland_jack> > maxBound :: Int
05:56:02 <tdammers> Integer is bignum
05:56:02 <lambdabot>  9223372036854775807
05:56:05 <tdammers> Int is not
05:56:13 <bobthecreator> :o
05:56:18 <Fekinox> yeah, Integer is arbitrary-precision
05:56:19 <tdammers> > maxBound :: Integer
05:56:21 <lambdabot>  error:
05:56:21 <lambdabot>      • No instance for (Bounded Integer)
05:56:21 <lambdabot>          arising from a use of ‘maxBound’
05:56:22 <Fekinox> i.e. it can get as big as needed
05:56:28 <tdammers> see, Integer isn't bounded :D
05:56:29 <Iceland_jack> bobthecreator: maxBound is polymorphic
05:56:32 <Iceland_jack> > maxBound :: Char
05:56:34 <lambdabot>  '\1114111'
05:56:37 <bobthecreator> oooh
05:56:40 <tdammers> > maxBound :: Bool
05:56:42 <lambdabot>  True
05:56:47 <tdammers> > maxBound ()
05:56:48 <bobthecreator> yea cuz false is 0
05:56:50 <lambdabot>  error:
05:56:50 <lambdabot>      • Ambiguous type variable ‘a0’ arising from a use of ‘show_M110553325189...
05:56:50 <lambdabot>        prevents the constraint ‘(Show a0)’ from being solved.
05:56:54 <tdammers> no, false isn't 0
05:57:03 <Logio> > False == 0
05:57:05 <lambdabot>  error:
05:57:06 <lambdabot>      • No instance for (Num Bool) arising from the literal ‘0’
05:57:07 <lambdabot>      • In the second argument of ‘(==)’, namely ‘0’
05:57:09 <tdammers> False just comes before True
05:57:19 <tdammers> [False..True]
05:57:19 <ab9rf> > maxBound :: Int64
05:57:21 <tdammers> > [False..True]
05:57:23 <lambdabot>  9223372036854775807
05:57:25 <lambdabot>  error:
05:57:25 <lambdabot>      Not in scope: ‘False..’
05:57:25 <lambdabot>      No module named ‘False’ is imported.error:
05:57:25 <bobthecreator> no i mean, false is always first
05:57:35 <bobthecreator> it doesn't mean that false has an actual value
05:57:39 <Iceland_jack> yes
05:57:40 <tdammers> it does. False.
05:57:41 <bobthecreator> it just always comes by default
05:57:44 <ab9rf> bobthecreator: it happens to be first. it doesn't HAVE to be, but it is.
05:57:45 <Iceland_jack> > [minBound .. maxBound] :: [Bool]
05:57:47 <lambdabot>  [False,True]
05:57:54 <bobthecreator> but thats the rule of boolean
05:57:55 <Iceland_jack> could be the other way 'round
05:58:05 <tdammers> indeed
05:58:07 <bobthecreator> all things are false until proven true
05:58:09 <tdammers> booleans aren't even special
05:58:09 <bobthecreator> :D
05:58:17 <tdammers> if Haskell didn't have booleans, you could implement them yourself
05:58:26 <bobthecreator> like the light switch
05:58:28 <Fekinox> they're literally just data Bool = False | True
05:58:48 <tdammers> you could even implement `if` yourself (although the syntax would be slightly different)
05:58:49 <ab9rf> you could define your own boolean type  data MyBool = True | False and it would work more or less the same,
05:58:59 <bobthecreator> > sum (filter odd [1..(maxBound :: Int64)])
05:59:05 <lambdabot>  mueval-core: Time limit exceeded
05:59:09 <bobthecreator> :D
05:59:12 <ab9rf> (you'd hve to use constructors other than True and False though)
05:59:12 <tdammers> if :: Bool -> a -> a -> a; if True t f = t; if False t f = f
05:59:33 <bobthecreator> > sum ([1..(maxBound :: Int64)])
05:59:39 <lambdabot>  mueval-core: Time limit exceeded
05:59:42 <bobthecreator> > sum ([1..(maxBound :: Int)])
05:59:48 <lambdabot>  mueval-core: Time limit exceeded
05:59:50 <bobthecreator> nop
05:59:51 <Logio> :t bool
05:59:53 <lambdabot> a -> a -> Bool -> a
05:59:54 <ongy> ab9rf: why would I not be able to use True and False? Aren't they just imports from Prelude?
05:59:58 <ab9rf> bobthecreator: lambdabot has runtime limiting so you can't make it cry
06:00:02 <bobthecreator> xD
06:00:33 <ab9rf> ongy: you'd have to import Prelude with the True and False constructors hidden
06:00:34 <ongy> > maxBound :: Int
06:00:36 <ongy> > maxBound :: Int64
06:00:37 <lambdabot>  9223372036854775807
06:00:39 <lambdabot>  9223372036854775807
06:00:44 <Fekinox> > foldl1' (+) [1..(maxBound :: Int)]
06:00:50 <lambdabot>  mueval-core: Time limit exceeded
06:01:03 <ab9rf> > sum [(1..(maxBound :: Word8)] -- for bobthecreator 
06:01:05 <lambdabot>  <hint>:1:8: error: parse error on input ‘..’
06:01:07 <Ferdirand> can't it be shown that it would be equal to 0 anyway ?
06:01:27 <ab9rf> > sum ([1..(maxBound :: Word8)]) -- for bobthecreator 
06:01:27 <ongy> what?
06:01:29 <lambdabot>  128
06:01:35 <Ferdirand> if maxBound is odd, which it should be
06:01:37 <ab9rf> bobthecreator: explain that result :)
06:01:55 <bobthecreator> > show Word8
06:01:57 <lambdabot>  error:
06:01:57 <lambdabot>      Data constructor not in scope: Word8 :: ()
06:02:07 <bobthecreator> whats a word8
06:02:13 <Fekinox> an 8-bit value
06:02:14 <bobthecreator> :t Word8
06:02:16 <lambdabot> error: Data constructor not in scope: Word8
06:02:23 <bobthecreator> :k Word8
06:02:25 <lambdabot> *
06:02:38 <ongy> > maxBound :: Word8 -- It's the unsigned 8-bit integer type
06:02:41 <lambdabot>  255
06:02:44 <Fekinox> (minBound :: Word8, maxBound :: Word8)
06:02:53 <bobthecreator> so, 0-255
06:02:55 <Fekinox> > (minBound :: Word8, maxBound :: Word8)
06:02:56 <ongy> yes
06:02:57 <lambdabot>  (0,255)
06:03:04 <bobthecreator> handy
06:03:17 <bobthecreator> generating IP addresses and RGB colors
06:03:21 <bobthecreator> :D
06:03:46 <bobthecreator> how do you random a thing
06:04:17 <bobthecreator> > randomRIO (1, 10)
06:04:19 <Logio> bobthecreator: I don't think you are ready yet for an answer to that
06:04:20 <lambdabot>  <IO Integer>
06:04:27 <bobthecreator> xDDDD
06:04:48 <bobthecreator> > 1 + randomRIO (1, 10)
06:04:50 <lambdabot>  error:
06:04:50 <lambdabot>      • No instance for (Typeable a0)
06:04:50 <lambdabot>          arising from a use of ‘show_M407974586121038491932324’
06:05:00 <bobthecreator> random is broken
06:05:11 <ongy> :t randomRIO
06:05:13 <lambdabot> Random a => (a, a) -> IO a
06:05:29 <bobthecreator> @let g <- newStdGen
06:05:29 <lambdabot>  Parse failed: TemplateHaskell language extension is not enabled. Please add ...
06:05:34 <Iceland_jack> bobthecreator: remember the difference between value and action?
06:05:35 <bobthecreator> :(
06:05:36 <ongy> it's just that the function returns an IO value, which lambdabot doesn'te execute (remember, pokerface)
06:05:44 <bobthecreator> yeas
06:06:05 <bobthecreator> as you can see things get confusing
06:06:16 <bobthecreator> because randomRIO looks like a function to me
06:06:27 <Logio> bobthecreator: it is, but not of the type you think
06:06:28 <Fekinox> do num <- randomRIO (1, 10); show num
06:06:32 <Fekinox> > do num <- randomRIO (1, 10); show num
06:06:34 <lambdabot>  error:
06:06:34 <lambdabot>      • Couldn't match type ‘[]’ with ‘IO’
06:06:34 <lambdabot>        Expected type: IO Char
06:06:51 <ongy> it is. but it returns an IO action, otherwise it would have to be the xkcd kind of random
06:07:11 <bobthecreator> i somehow think ive seen that before
06:07:43 <bobthecreator> yea i saw it before
06:07:51 <ongy> > do num <- randomRIO (1, 10); print num -- Fekinox
06:07:53 <lambdabot>  <IO ()>
06:08:00 <bobthecreator> popopopoker face
06:08:05 <Iceland_jack> x)
06:08:05 <Fekinox> aha
06:08:10 <Fekinox> was trying to see where I goofed there
06:08:19 <bobthecreator> well the code worked tho
06:08:47 <bobthecreator> I like how there is something called IO.Unsafe
06:08:49 <ongy> show is -> String, which is [Char]. So it tried to unify the [] and IO type, which clearly isn't possible
06:09:07 <ongy> yea, it's unsafe. Not something beginners should play around with
06:09:17 <bobthecreator> but its funny because its labeled Unsafe
06:09:32 <bobthecreator> and everyone is saying NONO dont touch that!!!
06:09:33 <Logio> bobthecreator: you could think of IO as a magic box, the contents of which you can only see by stepping inside it yourself
06:09:42 <Logio> bobthecreator: for a good reason
06:09:47 <bobthecreator> and Unsafe is pandoras box?
06:10:03 <Logio> Unsafe is the Warp, where horrors lie
06:10:13 <Logio> as far as beginners are concerned
06:10:17 <bobthecreator> yea Pandoras box
06:10:19 <geekosaur> well, the most common result of using it is the thing you tried to cheat with only happens the first time
06:10:36 <ongy> bobthecreator: the real gem in the unsafe named family is https://github.com/haskell/bytestring/blob/master/Data/ByteString/Internal.hs#L591
06:10:38 <geekosaur> because you told the compiler "it's pure, I promise" and it believed you
06:10:58 <bobthecreator> accursedUnutterablePerformIO xD
06:11:04 <bobthecreator> accursed OMG
06:11:15 <Logio> bobthecreator: the main thing is, you can build these magic boxes without stepping into them
06:11:52 <bobthecreator> what next? demonicImmutableIO ?
06:12:08 <Logio> and when you have everything you want, you can pass through into the realm of IO and reap the rewards
06:12:22 <bobthecreator> reminds me of the Nether in minecraft
06:12:44 <bobthecreator> anybody played minecraft here?
06:12:57 <geekosaur> what next was an unsafe "optimization" in the containers library that corrupts memory in a multithreaded context, iirc
06:13:57 * hackagebot boomerang 1.4.5.3, happstack-server 7.5.0.1, hsx2hs 0.14.1.1, web-routes-th 0.22.6.2, … and 1 more
06:13:57 * hackagebot  → https://hackage.haskell.org/packages/recent
06:14:19 <bobthecreator> that snippet of code ongy looks like chinese to me
06:14:41 <bobthecreator> albeit, its internals
06:15:14 <geekosaur> it's just an unboxed tuple. and in fact it's the same *code* as unsafeDupablePerformIO
06:15:29 <Logio> bobthecreator: I should mention, that even after you pass beginner stage, you generally don't touch Unsafe
06:15:44 <geekosaur> but it's marked to be inlined in callers, which means suddenly the compiler can see stuff it shouldn't, and optimizes the result into nightmare
06:15:48 <ongy> mostly because at that point you want the safety
06:15:52 <bobthecreator> trust me, i dont feel like using unsafe
06:16:19 <bobthecreator> its not like your code gets deleted if you compile something wrong
06:16:33 <ongy> not anymore...
06:16:37 <geekosaur> heh
06:16:39 <bobthecreator> xD
06:16:47 <Iceland_jack> funny you should say that
06:16:50 <Fekinox> the temptation is strong
06:16:56 <bobthecreator> are you referring to EPROMs
06:16:56 <ab9rf> i've never used unsafe
06:16:58 <Logio> that looks like a challenge for Template Haskell :P 
06:17:06 <Fekinox> i have stared into the void
06:17:10 <Fekinox> and the void stared back
06:17:16 <bobthecreator> what did the void say
06:17:20 <ab9rf> except once just to try to undertsand what it does, and it didn't really enlighten me
06:17:26 <bobthecreator> "hi tim nice seeing ya again"
06:17:34 <ongy> https://twitter.com/bos31337/status/116372971509121025 we are refering to this (first thing I found on google for it)
06:17:52 <bobthecreator> hahhahahah
06:17:57 <geekosaur> there was a ghc bug at one point where it was supposed to remove a partial output file on a certain compile error but a typo meant it removed the source instead
06:18:34 <Fekinox> that sounds like a pretty interesting challenge
06:18:34 <bobthecreator> amazing
06:18:42 <Fekinox> writing a program without running into a single compile-time error
06:18:49 <Rembane> It was a good bug. 
06:19:29 <ongy> I've heard someone (somewhat seriously) say he wishes the old times back, when he had to hack at home and didn't have a computer good enough to typecheck and compile. since that forced people to actually think before they code
06:19:31 <bobthecreator> if you use an IDE the IDE will tell you what is an error
06:19:58 <ongy> in that case it would delete your file while you are writing in it, since it tries to compile it
06:19:59 * bobthecreator pats the IDEs head *pat pat good IDE*
06:20:21 <Logio> ongy: that would be even better, instant feedback
06:20:22 <bobthecreator> does haskell have an IDE?
06:20:42 <bobthecreator> or do you all just use notepad to make programs
06:20:46 <Logio> https://wiki.haskell.org/IDEs
06:20:56 <Fekinox> close, sublime text
06:21:00 <srhb> bobthecreator: I think most people probably use one of vim, emacs, sublime or atom.
06:21:01 <bobthecreator> hey i use intellij
06:21:03 <Logio> bobthecreator: I'd wager most just use some editor
06:21:17 <bobthecreator> Notepad++ anybody :D
06:22:08 <bobthecreator> sudo vim sourcefile
06:22:27 <Logio> sudo? :o
06:22:38 <bobthecreator> Debian
06:23:01 <ongy> by why edit as root?
06:23:02 <Logio> I mean, why would you edit a source file as root
06:23:06 <bobthecreator> lol
06:23:12 <bobthecreator> sometimes i put source files in system folders
06:23:25 <bobthecreator> for scripts related to the OS
06:23:31 <ertes-w> is leksah any good?
06:24:42 <ongy> the editor isn't vim, so.... I thought it was ok, not great. But I didn't want to invest too much time, so it may have some features I didn't see
06:25:29 <bobthecreator> Hey guys, how is my Haskell programming coming along?
06:25:29 <bobthecreator> https://i.imgur.com/nYOeBiA.png
06:26:04 <Fekinox> perfect.
06:26:13 <bobthecreator> \o/
06:26:14 <ongy> bobthecreator: you probably need a 'main =' before that. (it's similar to what is `public static void main(String[]) {` in java)
06:26:30 <bobthecreator> yas
06:26:33 <bobthecreator> interesting
06:26:42 <bobthecreator> main = do
06:26:46 <bobthecreator> > main = do
06:26:49 <lambdabot>  <hint>:1:6: error:
06:26:49 <lambdabot>      parse error on input ‘=’
06:26:49 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:27:04 <bobthecreator> > main = do show 1 + 1
06:27:06 <lambdabot>  <hint>:1:6: error:
06:27:06 <lambdabot>      parse error on input ‘=’
06:27:06 <lambdabot>      Perhaps you need a 'let' in a 'do' block?
06:27:11 <bobthecreator> > do show 1 + 1
06:27:13 <lambdabot>  error:
06:27:13 <lambdabot>      • No instance for (Num String) arising from a use of ‘+’
06:27:13 <lambdabot>      • In a stmt of a 'do' block: show 1 + 1
06:27:28 <bobthecreator> > do (1 + 1)
06:27:31 <lambdabot>  2
06:27:34 <bobthecreator> > do show (1 + 1)
06:27:37 <lambdabot>  "2"
06:27:44 <bobthecreator> paranthesis...
06:27:49 <cheater> if my package contains a demo executable which i would like to be able to run with something similar to cabal run, but it should not normally be installed especially if the package is a dependency, how do i specify that in the cabal file?
06:27:59 <Fekinox> main is usually defined to be of type IO ()
06:28:47 <bobthecreator> my code so far
06:28:47 <bobthecreator> main = do show (1+1)
06:29:28 <bobthecreator> > do show $ 1+1
06:29:30 <lambdabot>  "2"
06:29:34 <bobthecreator> improvements
06:29:58 <bobthecreator> can i get rid of the "do" in this case
06:30:12 <bobthecreator> main = show $ 1+1
06:30:14 <Fekinox> it's an incredibly simple function, so I don't see why not
06:30:32 <Fekinox> again main is of type IO () and so it does need do-notation
06:30:38 <Logio> bobthecreator: you will find that does not compile
06:30:43 <Fekinox> main = do putStrLn (show $ 1 + 1)
06:30:47 <Fekinox> or something like that
06:30:49 <ertes-w> Fekinox: wrong
06:30:54 <ongy> Fekinox: it doesn't *need* do notation, it's just easier most of the time
06:30:56 <bobthecreator> :O
06:31:03 <Fekinox> huh, bad wording
06:31:05 <Fekinox> my b
06:31:28 <ongy> bobthecreator: To do what lambdabod does with show here, `main = print $ 1 + 1` would be the most simple haskell code to compile
06:31:28 <bobthecreator> so does main always need do?
06:31:33 <Logio> bobthecreator: no
06:31:47 <Logio> bobthecreator: but it needs to be something of type IO ()
06:31:59 <Fekinox> yeah it's not necessary
06:32:16 <bobthecreator> do you guys also look at bytecode, the same way people do in java
06:32:16 <Logio> and some things that are written with do thing1; thing2 are of that type
06:32:30 <Cale> bobthecreator: do-notation glues multiple IO actions together into a single one
06:32:46 <ongy> barely. sometimes it's good to look at core (an intermediate compile step) but that's not something beginners should worry about
06:33:23 <bobthecreator> nah i was just asking because id was curious about whether print $ 1 + 1 evaluates the same bytecode as print (1+1)
06:33:24 <Logio> if I wanted to look at the dirty internals, I would code in C
06:33:45 <Cale> bobthecreator: Haskell usually gets compiled to native machine code, and I don't think many people look at that (unless you're writing a compiler backend maybe)
06:33:48 <ongy> Logio: you mean C--? :P
06:34:14 <Logio> ongy: well, just referring to dirty internals in general, not just Haskell :P
06:34:22 <bobthecreator> when you say native machine code you mean assembly right
06:34:37 <bobthecreator> movx
06:34:54 <Fekinox> assembly itself is a very small layer of abstraction over machine code I think
06:34:56 <ongy> assembly isn't the same as machine code (though there's a one to one mapping)
06:35:13 <bobthecreator> interesting
06:35:43 <bobthecreator> welp,im getting hungry
06:35:54 <bobthecreator> it was very interesting conversation this
06:36:03 <bobthecreator> glad to have found this by accident
06:36:10 <Iceland_jack> same
06:36:31 <Iceland_jack> also try: main = print 1 >> print 2 >> print 3
06:36:34 <Iceland_jack> get some food
06:36:37 <bobthecreator> im not so sure about my future career being affected by haskell, considering im actually a video producer
06:37:02 <bobthecreator> if its anything like your last code the output would be "33333333333333333"
06:37:14 <Iceland_jack> haha
06:37:15 <dysfun> haskell is a surprisingly useful automation tool
06:37:29 <Iceland_jack> bobthecreator: Haskell is remarkably good at changing your perspective in other languages
06:37:36 <mnoonan> ongy, even the 1-1 mapping is a bit fictional (e.g. redundant instruction encodings)
06:37:45 <bobthecreator> yea, definitely a completely unique perspective
06:37:50 <Iceland_jack> You get an acute sense of values v commands
06:38:10 <bobthecreator> yea, i am still trying to understand that
06:38:25 <Logio> Iceland_jack: and a general sense of unease about program state in other languages
06:38:28 <Iceland_jack> ;)
06:38:33 <Iceland_jack> indeed
06:38:37 <Iceland_jack> and I always think in Haskell type signatures, even when working in untyped languages
06:38:38 <ongy> mnoonan: it's also hard to reconstruct label names. So one direction should be obvious/non ambigious, the other one is a bit trickier
06:38:43 <bobthecreator> One last question before I go
06:38:46 <Iceland_jack> shoot
06:39:03 <bobthecreator> Do you guys think its possible to make a super operating system based on Haskell
06:39:08 <Zowlyfon> no
06:39:25 <bobthecreator> and reason?
06:40:02 <geekosaur> what is a "super" operating system?
06:40:07 <mnoonan> ongy: that's what I mean to say, even the "obvious" direction of asm -> machine code isn't quite, because there is often a choice about how to encode a mneumonic into bytes. usually your assembler would choose the shortest encoding or something, but it isn't a requirement.
06:40:09 <bobthecreator> something better than today
06:40:10 <ongy> the execution model (at least of GHC) requires some liberal handling of memory, which e.g. hardware interupt contexts don't always allow
06:40:37 <Iceland_jack> Haskell could generate the asm
06:40:42 <Logio> bobthecreator: https://wiki.haskell.org/Applications_and_libraries/Operating_system
06:40:47 <bobthecreator> so does that mean haskell PC would need to be a custom built
06:40:50 <Logio> some attempts exist
06:40:54 <geekosaur> ignoring the "super" part, http://programatica.cs.pdx.edu/House/
06:41:57 <Zowlyfon> geekosaur: does it run well?
06:42:07 <mnoonan> ongy, here's an interesting example of what I mean: http://koru.se/post/6695565488/x86-assembly-steganography
06:42:09 <bobthecreator> okay so it seems these are in primitive stages
06:42:12 <Cale> bobthecreator: It's a thing that could be done, but you'd need a really good reason to do it, since not supporting existing software is a great way for an operating system to be relatively useless for a long while. For more specialised applications though, people do write OS-level stuff in Haskell.
06:42:21 <geekosaur> considering it's from 2006, and expects things like a ps/2 mouse...
06:42:27 <Cale> House did it mainly as a research project
06:42:28 <bobthecreator> XD
06:42:30 <Zowlyfon> I remember discussing this with someone a while back
06:42:42 <bobthecreator> perhaps it could be a replacement server OS
06:42:43 <Cale> It was never intended as something that people would actually use
06:42:52 <bobthecreator> forget people, how about servers
06:42:57 <Zowlyfon> And it came to implementing some of the runtime stuff Haskell needs in kernel not being great
06:43:07 <Logio> bobthecreator: there is also Nix, which is quite nifty
06:43:16 <bobthecreator> yeas but isn't that Unix based
06:43:37 <Cale> https://github.com/GaloisInc/HaLVM is kind of close
06:43:45 <Logio> yeah, but as an example of a system utility in Haskell
06:44:08 <ongy> mnoonan: I see 2 different assembly lines which should result in 2 different opcodes (+ params). It's the same on a logical level though
06:44:12 <Cale> It's basically a way to run Haskell programs directly on top of the Xen hypervisor, without an OS
06:44:33 <Cale> and people actually do use that in production from what I understand
06:44:40 <bobthecreator> fasctinating
06:44:49 <bobthecreator> BTW
06:44:50 <bobthecreator> HaLVM
06:44:56 <bobthecreator> sounds a lot like Halva
06:45:03 <bobthecreator> which is a traditional sweet where im from
06:45:29 <Zowlyfon> I remember reading that running stuff at the kernel level as opposed to userspace has a performance increase of about 15%
06:45:31 <ongy> Cale: are you using halvm at work?
06:45:46 <ongy> oh that last line probably means no
06:45:47 <bobthecreator> interesting
06:46:05 <Zowlyfon> Depending on how many systemcalls the program has to make
06:46:18 <geekosaur> Zowlyfon, you're not context switching in the kernel, so sure. the downside is nothing else is able to run while your code is running, so either you yield a lot or the rest of the system suffers.
06:46:19 <mnoonan> ongy: the point there is that "cmp eax, ebx" has two different encodings, and it is up to the assembler to pick one. so here, asm -> x86 is 1-to-2 (at least)
06:46:23 <inkbottle> Hi, where do I find module CoreUtils? A direct load seems to fail; so does install
06:46:28 <Cale> ongy: no, we don't need anything that low level
06:46:37 <ongy> if you are syscall heavy, you probably don't have too much fun in haskell either. since it's all IO :(
06:46:43 <bobthecreator> so apart from the fact that the use-case is limited, is it plausible to assume that an Operating System based on Haskell could be more stable or more efficient than other OSes?
06:46:54 <mnoonan> anyway, this isn't really #haskell related, I just work in binary static analysis so it's close to mind :)
06:46:55 <Cale> ongy: Haskell is a really good language in which to write I/O code
06:47:13 <ongy> mnoonan: cmp eax, ebx and cmp ebx, eax. are you sure the assembler is allowed to just switch those out?
06:47:39 <ongy> Cale: I'm aware. But it's less fun, since that's where the type system tends to not help as much (at least I can't get it to with my stuff)
06:48:05 <Zowlyfon> bobthecreator: There is a project to write a kernel in Rust
06:48:14 <Zowlyfon> Its not haskell, but it is memory safe
06:48:24 <mnoonan> ongy: no, it's that the one line "cmp eax,ebx" can be encoded two ways
06:48:36 <bobthecreator> if it were possible to make an all haskell system tho?
06:48:45 <bobthecreator> would it be better than anything else?
06:48:51 <mnoonan> a "OP mod-r/m, reg" encoding, and a "OP reg, mod-r/m" encoding
06:49:04 <Logio> bobthecreator: for some definition of better, probably
06:49:10 <bobthecreator> xD
06:49:12 <mnoonan> but mod-r/m can denote a reg itself, hence the redundancy
06:49:18 <geekosaur> inkbottle, http://hayoo.fh-wedel.de/?query=CoreUtils --> http://hackage.haskell.org/package/extcore (probably; snap apparently also has a CoreUtils)
06:49:20 <Fekinox> bobthecreator: in terms of stability, it seems like it could be pretty safe considering that run-time errors are fairly rare in the language
06:49:34 <Logio> though I would dread the thought of updating a Haskell kernel and recompiling the whole system
06:49:37 <Zowlyfon> bobthecreator: I don't think it would be very fast
06:49:39 <bobthecreator> unlike Java and Android OMG shoot me in the face with the run time errors
06:49:42 <Fekinox> efficiency, not so much it seems
06:49:43 <ongy> mnoonan: ohh, argh. damn x86 *shakes fist*
06:49:54 <inkbottle> geekosaur: OK, I read that
06:49:58 <bobthecreator> ohhh
06:50:11 <bobthecreator> so this would be an OS focused on mission critical things and less about speed
06:50:18 <bobthecreator> like NASA computers
06:50:31 <bobthecreator> guided misiles
06:50:34 <Fekinox> idiomatic haskell runs about half as fast as equivalent C code (which is still pretty fast but slow for an OS)
06:50:34 <Zowlyfon> NASA writes C code without dynamically allocation memory to make it more safe
06:50:38 <brynedwards> You could just write Android apps in Haskell https://brianmckenna.org/blog/eta_android
06:50:53 <bobthecreator> brynedwards: Amazing!
06:51:53 <inkbottle> geekosaur: there is a CoreUtils here: https://downloads.haskell.org/ghc/latest/docs/html/libraries/ghc-8.2.1/CoreUtils.html
06:51:58 <Cale> bobthecreator: It's really quite general purpose. We use Haskell to build web and mobile applications where I work, both for the backend (compiled to native x64 code) and for the frontend, compiled to ARM native code to run on phones, or Javascript to run on the web
06:52:09 <inkbottle> geekosaur: but I don't know how to load it
06:52:31 <geekosaur> inkbottle, the ghc package is hidden by default
06:52:36 <bobthecreator> but what would you say is the performance when compared to Java?
06:52:56 <bobthecreator> its like you are programming Java from within Haskell
06:53:05 <inkbottle> geekosaur: OK (how do I unhide it?)
06:53:06 <bobthecreator> interpreter and then compiler?
06:53:31 <Logio> bobthecreator: I would say Java performs much faster when producing the wrong results
06:53:45 <bobthecreator> that sounds about right
06:53:51 <Cale> bobthecreator: Wait, Java?
06:53:58 <Cale> bobthecreator: Javascript and Java aren't the same thing
06:54:05 <bobthecreator> you mentioned mobile apps
06:54:14 <Cale> Yeah, that's ARM code, not Java
06:54:25 <bobthecreator> so you mean like Windows phone?
06:54:30 <bobthecreator> thats not even a thing anymore
06:54:32 <Cale> No, Android and iOS
06:54:34 <geekosaur> inkbottle, the preferred way is to use a cabal or stack project; if you list the ghc library as a dependency, it will be unhidden for you
06:54:43 <bobthecreator> Im confused
06:54:44 <foldr> Is there a tool that can find any references to any given function in Haskell source code? For example, find all occurrences of the function `Foo.Bar.baz'.
06:54:52 <bobthecreator> ARM code is written in what?
06:54:54 <inkbottle> geekosaur: OK, thanks a lot
06:54:55 <geekosaur> if you are building manually, add -package ghc
06:55:06 <Cale> ARM is the processor family that phones tend to use
06:55:15 <geekosaur> it is best *not* to modify the package database to globally expose that library
06:55:18 <Zowlyfon> ARM is an assembly language
06:55:23 <Zowlyfon> ARM code*
06:55:35 <bobthecreator> and so you are programming mobile apps directly in haskell for ARM?
06:55:36 <Cale> There's a small amount of Java code in our app that we use to set up a webview, but then we run most of the application in native ARM, not in Java
06:55:52 <Cale> (Compiled from Haskell)
06:56:04 <Zowlyfon> Cale: are there any specific libraries your using for that?
06:57:03 <Cale> Zowlyfon: Some of it is in reflex-platform on the mobile branch, but we're still working on open sourcing it. Our intention is to eventually make it easy to develop mobile apps by leveraging the stuff we've done in that direction.
06:57:04 * hackagebot pandoc-crossref 0.2.6.0 – Pandoc filter for cross-references – https://hackage.haskell.org/package/pandoc-crossref
06:57:15 <Zowlyfon> cool
06:57:27 <bobthecreator> sounds very cool
06:57:51 <bobthecreator> could we know what company this is?
06:58:01 <Cale> Obsidian Systems
06:58:30 <bobthecreator> fasctinating
06:58:38 <bobthecreator> i assumed this was american
06:59:55 <bobthecreator> i wonder how much MEAN research was actually accomplished in america on a statistical comparison with the rest of the world
07:00:14 <bobthecreator> america would have you believe they invented everything and solved everything
07:00:50 <Cale> bobthecreator: The company is based in NYC.
07:01:05 <Cale> bobthecreator: I live in Canada though, and work remotely for them.
07:01:13 <cheater> how do i put haskell code in a github issue report? the backticks make it difficult
07:01:13 <bobthecreator> Im Canadian \o/
07:01:15 <bobthecreator> woot
07:01:39 <bobthecreator> which part canada u living :D
07:02:01 <Cale> I'm in Brantford Ontario
07:02:02 <ongy> cheater: gist and attach? When you have enough that backticks become an issue, inlining it may not be the best approach either way
07:02:14 <cheater> hm ok
07:02:21 <Cale> cheater: Maybe use ``` ?
07:02:22 <brynedwards> I think you can use three backticks?
07:02:28 <brynedwards> Yeah that
07:02:51 <bobthecreator> ahh thats like an hour drive from my family :D
07:03:02 <ongy> let's all visit Cale \o/ :P
07:03:06 <bobthecreator> yeeeey
07:03:44 <cheater> thanks that worked
07:04:44 <bobthecreator> welp i better get going
07:04:49 <bobthecreator> i gotta do something productive
07:05:20 <bobthecreator> bye guyyysss
07:05:59 <kadoban> Yay, nightly is now on ghc 8.2.1
07:07:30 <gremdrus> I am trying to get C-c C-l working in intero, and I am getting this error: haskell-mode-enable-process-minor-mode: Run ‘C-h f haskell-mode‘ for instruction how to setup a Haskell interaction mode.
07:11:34 <gremdrus> do people use intero and haskell-mode simultaneously?
07:12:22 <eschnett> gremdrus: yes — isn’t that the standard way?
07:12:22 <ertes-w> gremdrus: unlikely, although intero might actually depend on haskell-mode
07:13:04 <ertes-w> gremdrus: but i thought intero is preconfigured to just work
07:13:45 <brynedwards> ...do you have intero-mode on?
07:14:20 <glguy> I've been using dante when I use emacs
07:15:49 <ertes-w> glguy: does it improve on haskell-mode?
07:17:49 <glguy> improves on intero in particular
07:18:32 <glguy> works with new-build and stack and other modes
07:18:47 <AlainODea> quickcheck question: I can generate an arbitrary ByteString, but it kills the underlying C code, because it's defined for ASCII only. How do I constrain the arbitrary ByteString to ASCII elements?
07:19:14 <ertes-w> glguy: i'd like to know if it's better than plain haskell-mode, whether there are features i'm missing out on
07:20:50 <cocreature> AlainODea: you can generate an arbitrary ascii String using the ASCIIString newtype and then convert it to a bytestring.
07:21:02 <AlainODea> cocreature: thanks! I'll give that a shot
07:21:11 <hello1453> Does anybody know where I can find haskell projects that need contributors?
07:21:27 <lyxia> ghc
07:22:29 <hello1453> I'm a bit rusty so preferably something easier, to get going
07:22:44 <mnoonan> glguy, do you know if dante works over tramp?
07:23:01 <dramforever> wow dante looks promising
07:23:08 <dramforever> t
07:23:32 <dramforever> That 'apply suggestion from GHC' is pretty interesting, tbh
07:25:34 <glguy> mnoonan: I don't know what tramp is
07:25:45 <geekosaur> remote file editing
07:26:04 <geekosaur> current iteration of ange-ftp, roughly
07:28:01 <eschnett> emacs’s version of sshfs
07:29:52 <mnoonan> yeah, I should probably just switch to sshfs anyway
07:30:26 <glguy> ertes: the readme for it tells you all of what it does
07:30:57 <kadoban> hello1453: https://github.com/commercialhaskell/stack I've found quite friendly to contribute to. It's a big project, so maybe not the easiest, but you can just focus on whatever small parts you find interesting/accessable.
07:31:38 <hello1453> kadoban, thank you for the suggestion! I'll check it out
07:34:39 <AlainODea> cocreature: I get "Not in scope: type constructor or class ‘ASCIIString’". ASCIIString is exported by Test.QuickCheck and I have import Test.QuickCheck in my module. What am I missing? https://hackage.haskell.org/package/QuickCheck-2.10.0.1/docs/src/Test-QuickCheck.html#line-156 
07:35:19 <cocreature> AlainODea: I suspect that you might be using an older version of QuickCheck. ASCIIString is new in 2.10
07:35:47 <cocreature> AlainODea: before 2.10, you should be able to just use the instance of String itself
07:36:02 <AlainODea> cocreature: okay! That makes perfect sense. I'll try the newer QuickCheck package
07:44:14 <werner291> Hello, I'm trying to create a datatype to represent some symbolic expression. So far, I have this (https://hastebin.com/defijobiva.rb). However, is it possible to move the GetX/getY/GetZ and DotProduct operations out of the definition of SymScalar? Those operations are specific to vectors, so I'd prefer not making them so strongly connected to the definition of a scalar. (I'm very new to haskell, so 
07:44:21 <werner291> this may be very simple...)
07:45:55 <AlainODea> cocreature: got it working. I copied ASCIIString, its instance of Arbitrary, and arbitraryASCIIChar and customized them to return printable chars only (another undocumented "type" error in the C code). Thank you for your help :)
07:46:44 <byorgey> werner291: no, the way you have organized things, it's not possible.  and actually I would say that those operations are specific to scalars too, because they return scalars. =)
07:47:10 <byorgey> werner291: basically what you have here is a language with two types: scalars and vectors.  And you have one data type to represent expressions of each type.
07:47:45 <byorgey> werner291: the benefit of this is that there is no way to represent type errors (e.g. taking the dot product of a vector and a scalar).
07:48:46 <byorgey> werner291: the downside is that it forces you to mix parsing and typechecking, and is not very scalable: if you start adding more stuff to your language you will quickly run into a situation where you can't adequately encode what you want as separate data types
07:50:10 <byorgey> (also, out of curiosity, why does the 'Negation' constructor take a [Scalar]  rather than a single  Scalar ?)
07:50:37 <werner291> That's a mistake, actually. I mostly just hacked that code together for a quick demonstration of what I meant.
07:50:44 <byorgey> ok, fair enough =)
07:51:18 <begriffs> Looking for a slick way to do this... I have a multi-line string where I want to treat the first line as summary, and the rest as description. So I can do `(summary, desc) = breakOn "\n" foo`. However what if foo is Maybe Text? Is there a nice way to make my resulting type (Maybe Text, Maybe Text)?
07:52:09 <werner291> Supposing I wanted to make it a bit more scaleable, possibly by sacrificing a bit of safety, what would be the Haskell-way of doing it?
07:52:11 <byorgey> werner291: are you just going to be writing these symbolic expressions directly as Haskell values?  Or are you planning to write a parser that can read a String and turn it into a representation as Haskell data?
07:52:51 <werner291> A parser would be great, but I'd rather focus on just getting a good representation.
07:53:07 <byorgey> begriffs: why (Maybe Text, Maybe Text)?  Wouldn't you want  Maybe (Text, Text)?
07:53:17 <byorgey> begriffs: either you get nothing or you get both, unless I am misunderstanding
07:53:31 <mnoonan> werner291, you could have a type F that represented functions from Vector3 to Scalar, and then have a generic "Apply F Vector3" term for Scalar
07:53:57 <mnoonan> and F could look like "GetX | GetY | GetZ | Dot Vector3"
07:55:04 <begriffs> byorgey: yeah I could `breakOn "\n" <$> foo` but ultimately I want those two Maybe Text values for use later on. I'll be passing them each to separate library functions that want Maybe Text.
07:56:41 <byorgey> begriffs: ok, so something like   (fmap fst &&& fmap snd) (breakOn "\n" <$> foo)
07:57:03 <byorgey> werner291: what I would do is to make a single data type representing expressions, which would have all the constructors for both SymScalar and SymVector3.
07:57:50 <begriffs> byorgey: ahh, &&& thanks
07:58:01 <byorgey> werner291: then make   'data Type = Scalar | Vector3', and write a type checker   inferType :: Expression -> Maybe Type
07:58:51 <byorgey> werner291: then once you learn about GADTs you could get fancier and regain the type safety by making your Expressions indexed by the Type, e.g.   Expression Scalar  or  Expression Vector3
08:00:45 <byorgey> werner291: shameless plug: you may be interested in going through some of the materials from a programming languages course I taught, which walks you through how to build a lot of this kind of stuff in Haskell: http://ozark.hendrix.edu/~yorgey/360/
08:01:34 <byorgey> I tried to make it fairly practical, and the course materials are essentially organized like a big hands-on tutorial
08:04:02 <werner291> Thanks, I'm going to check that out. Haskell looks like a very interesting language to learn... I previously tried building something like this in Kotlin while trying to achieve compile-time type safety, but I ended up with al kinds of ugly stuff.
08:04:23 <werner291> (What I was trying to do was a bit mroe complex than this)
08:04:27 <werner291> *more
08:08:10 <byorgey> interesting, I had not heard of Kotlin
08:09:28 <werner291> It's basically Java, but better.
08:09:57 <werner291> Basically, a lot of the times where Java is like "why do I have to do this", it's fixed in Kotlin
08:10:13 <michi7x7> Any ideas how to make this faster? countTrue = Data.Vector.foldr' (\b -> if b then succ else id) 0
08:10:23 <dysfun> werner291: i second that
08:10:44 <werner291> But since it's fully Java-interoperable, you still get most of Java's advantages.
08:14:03 <dolio> Is kotlin the one where they intentionally made the type system unsound?
08:14:08 <dolio> I have trouble keeping track.
08:14:17 <dysfun> that's scala
08:14:29 <tdammers> dolio: wasn't that Scala, and also Clojure, and pretty much everything else that runs on the JVM?
08:14:45 <dysfun> tdammers: oh hello smug haskell weenie from #clojure :)
08:14:46 <dolio> I don't think it's scala.
08:14:58 <tdammers> then again, I don't know if "let's not really have a type system at all" counts as "intentionally making the type system unsound"
08:14:59 <dolio> Scala is unintentionally unsound.
08:15:00 <tdammers> yow dysfun 
08:15:15 <dysfun> got a job yet?
08:15:21 <dysfun> (i do!)
08:15:22 <tdammers> yes
08:15:29 <dysfun> awesome
08:15:50 <tdammers> I got one, and then I didn't get paid, so I forced the company to go bankrupt, and now I have another job
08:16:41 <dysfun> woohoo
08:16:57 <dolio> The one I'm thinking of was like, "Lists should be covariant, but then List a can't contain a method cons(x : A): List[A]"
08:17:01 <tdammers> unfortunately I really have to go take a shower now, and then pick up the kids
08:17:04 <dolio> "But we'll make it covariant anyway."
08:17:37 <dolio> Mixed by syntax a bit there.
08:29:39 * hackagebot fitspec 0.4.3 – refining property sets for testing Haskell programs – https://hackage.haskell.org/package/fitspec
08:34:58 <ertes-w> i need a type of concurrent mutable variable with the following semantics:  there is a writing end, and one can subscribe arbitrarily often to the read end, and each reader gets notified about changes…  specifically this should be *state*, not a *channel*, so one can read as often as one wants, but each reader can wait for the next change independently and transactionally
08:35:03 <ertes-w> does something like that exist?
08:35:29 <michi7x7> If I use memoize2 from Data.Function.Memoize like so: https://gist.github.com/michi7x7/8c03e377256269775fb520411045fa11 , how can I find out why It wouldn't work?
08:35:50 <ertes-w> it's fairly easy to code, but i'd like to know if there is a ready-made library for that available
08:37:35 <michi7x7> ertes-w: Control.Concurrent.Chan ?
08:38:18 <michi7x7> ertes-w: oh sorry, didn't finish reading your question ^^
08:38:58 <ertes-w> michi7x7: problem with TChan is: if a thread has not waited on it for a while, messages pile up, even though the thread is only interested in *whether* it changed
08:39:11 <ClaudiusMaximus> sounds like samplevar
08:39:17 <ertes-w> if it weren't for that, TChan would be perfect
08:40:23 <ClaudiusMaximus> but i don't think samplevar has "wait until next change", hm
08:40:47 <ertes-w> alright, looks like i'll be inventing this one =)
08:41:48 * hackagebot speculate 0.2.7 – discovery of properties about Haskell functions – https://hackage.haskell.org/package/speculate
08:41:48 * hackagebot Villefort 0.1.1.1 – Villefort is a task manager and time tracker written in haskell. – https://hackage.haskell.org/package/Villefort
08:42:12 <ertes-w> (i basically need reflex' Dynamic, and i would actually just use reflex, if it could handle concurrency)
08:45:07 <shapr> That hackagebot announcement of the fitspec package got me reading the paper: https://matela.com.br/paper/fitspec.pdf This is nifty!
08:45:37 <shapr> aand now I have to also read the speculate paper.
08:48:53 * hackagebot extrapolate 0.2.1 – generalize counter-examples of test properties – https://hackage.haskell.org/package/extrapolate
08:50:42 <tinytusk> Hi. I am using poistgresql-simple, and I am trying to produce a static binary on alpine. I am getting linker "undefined reference" errors for libldap symbols. I checked, and OpenLDAP is actively hostile against providing a pkgconfig file for their product.
08:50:58 <tinytusk> What is the best course of action?
08:51:09 <ezyang> Marisa: It's already in :) 
08:51:10 <ickabob> specifically the signature for 'main' given in the documentation's example leaves out the EXCEPTION effect.
08:51:41 <tinytusk> Should I simple pass a bunch of "-optl/usr/lib/foo.a" parameters to GHC?
08:51:45 <tinytusk> simply*
09:00:32 <gremdrus> how do I pass -fno-ghci-sandbox to ghci using intero?
09:02:29 <WinchellsM> Does anyone here use intero for emacs? If so, can you confirm that jumping to function definitions is ONLY supported for those functions which are defined locally, and not i.e., imported from arbitrary stack modules?
09:12:51 <dminuoso> Hi. I have a terminology problem. Why is "Maybe" itself a functor? Wouldn't it be more correct that fmap itself is the functor?
09:15:12 * hackagebot creatur 5.9.19 – Framework for artificial life experiments. – https://hackage.haskell.org/package/creatur
09:15:36 <Iceland_jack> dminuoso: Categorically, a functor maps types (Maybe) and arrows (fmap)
09:16:37 <Iceland_jack> but the Maybe type constructor (Maybe :: Type -> Type) is what is an instance of the Functor type class, just like we say that (->) is a category because there is an (instance Category (->))
09:19:17 <lyxia> cocreatur - Framework for artificial death experiments.
09:24:17 <ertes-w> dminuoso: (Maybe, fmapMaybe) is a functor
09:24:57 <ertes-w> dminuoso: however, Functor is special in that every algebraic type as at most one correct Functor instance
09:25:17 <michi7x7> How can I make GHC memoize this list? https://gist.github.com/michi7x7/8c03e377256269775fb520411045fa11
09:25:37 <ongy> lyxia: sounds like fun. Sign my brother up ;)
09:25:44 <ertes-w> dminuoso: categorically a Functor requires both an object map (in this case mapping types to types, i.e. Maybe) and a morphism map (in this case mapping (a -> b) to (f a -> f b), i.e. fmap)
09:26:16 <ertes-w> dminuoso: and haskell's Functor class is actually wrongly named…  it should be EndofunctorOnHask
09:29:41 <lyxia> michi7x7: what makes you think it's not being memoized
09:29:47 <byorgey> michi7x7: that list will only be computed once.
09:29:56 <byorgey> repeatedly looking up in the list with !! will be slow though.
09:31:39 <michi7x7> byorgey, lyxia: I added a trace to the computation, also the time remained the same
09:32:50 <michi7x7> the input should give a huge difference in runtime
09:35:17 <byorgey> michi7x7: I don't see how using the list cnt should improve the runtime.  You only ever use each item in the list once.
09:36:14 <michi7x7> byorgey: ah, yeah I'm tired. sorry
09:36:28 <byorgey> no worries
09:37:18 <ertes-w> michi7x7: i wonder why 'cnt' even exists
09:37:24 <ertes-w> cnt !! i = i
09:37:30 <ertes-w> so just use 'i'
09:37:36 <ertes-w> oh, wait
09:37:47 <ertes-w> nevermind…  your naming scheme is really confusing
09:38:26 <ertes-w> but yeah, i see no reason to even memoise it…  just use cnt' directly
09:39:07 <dminuoso> ertes-w, well I have accepted that the entire world of functional programming languages seem to understand endofunctors as functors, so I'm not too worried about that part.
09:41:32 * hackagebot log-base 0.7.2.0, log-elasticsearch 0.9.1.0, log-postgres 0.7.0.2
09:41:32 * hackagebot  → https://hackage.haskell.org/packages/recent
09:42:11 <cocreature> angerman: I guess I was right that llvm 5.0 rc2 won’t be released on time :)
09:42:19 <michi7x7> byorgey, ertes-w: yeah, it's a sliding window. the only value to really memoize is the computation over the whole vector.  should have used smth like "if x == 0 && y == n then memo else compute" from the beginning
09:46:43 <ertes-w> michi7x7: if you care about efficiency, you can construct the bit field in such a way that you can ask for the hamming weight of any slice efficiently
09:46:52 <ertes-w> michi7x7: you can use a finger tree for that purpose
09:47:02 <ertes-w> @package fingertree
09:47:03 <lambdabot> http://hackage.haskell.org/package/fingertree
09:47:39 <ertes-w> michi7x7: also note that Data.Vector is about the worst way to store bit fields =)
09:48:10 <ertes-w> Data.Vector.Unboxed would be much better, but still far from the optimum by a factor of 8
09:49:12 <ertes-w> if you don't want to work with Data.Vector.Unboxed.Vector Word64 and do the bit operations yourself you can use the old 'array' library, which knows how to store bit vectors properly
09:50:07 <kadoban> Yeah I was surprised a while back when Data.Array magically did really well for an unboxed array of Bools. Was quite handy.
09:50:16 <ClaudiusMaximus> !hackage bitwise -- there's also this which i wrote, may be appropriate depending what you need to do
09:50:18 <kadoban> Or maybe it wasn't unboxed, I forget.
09:50:51 <ertes-w> ClaudiusMaximus: i very much prefer the way bitvec does it: by providing a proper Unbox instance
09:51:01 <ClaudiusMaximus> ertes-w: ok
09:51:17 <ertes-w> however, in my last benchmark bitvec was slower than manual bit twiddling by a factor of 5
09:51:27 <ertes-w> so the ideal solution would be to fix bitvec =)
09:51:43 <ertes-w> @package bitvec
09:51:43 <lambdabot> http://hackage.haskell.org/package/bitvec
09:52:50 <ertes-w> i don't know why it's that slow…  it probably handles slicing badly
09:53:17 <ClaudiusMaximus> in my defence bitvec wasn't on hackage when i uploaded the first version of bitwise :)
09:54:07 <ClaudiusMaximus> oh wait, wrong version - still about the same ere, spring 2012
09:55:07 * hackagebot vcf 0.9.0 – A package to parse VCF files inspired in similar python libraries – https://hackage.haskell.org/package/vcf
09:56:19 <ertes-w> ClaudiusMaximus: oh, it wasn't meant to be criticism =)
09:56:26 <ClaudiusMaximus> ertes-w: cool :)
09:57:36 <michi7x7> ertes-w: Yeah, if it were about performance I would have started differently. I'm just doing some coding exercises online and one testcase took a little to long, so I tried to fix it the "quick and easy" way
09:58:17 <ertes-w> michi7x7: a quick fix would be to change the vector type to unboxed vectors…  that alone should improve the run-time of your algorithm massively
09:58:37 <ertes-w> michi7x7: and all you need for that is a different import:  Data.Vector.Unboxed =)
10:03:21 <qmmm> https://clojure.org/reference/transducers what is the difference between combinators and transducers?
10:04:28 <michi7x7> ertes-w: unboxed vector seems to be about twice as slow (40 instead of 20 seconds)
10:04:53 <michi7x7> the fold is terribly slow now
10:06:29 <ertes-w> michi7x7: why is it a right fold?
10:08:36 <michi7x7> ertes-w: hm, dunno. I thought it wouldn't change much, considering the memory is linear
10:09:01 <michi7x7> but a left fold is just as slow
10:09:09 <ertes-w> weird
10:09:54 <michi7x7> ertes-w: but a non-strict fold is way slower
10:10:16 <ertes-w> michi7x7: yeah, foldl' is the proper fold to use here
10:10:42 <ertes-w> although for vectors foldr' might indeed just fold from the right
10:10:52 <dolio> Pretty sure it does.
10:11:01 <dolio> Well, unless it's streaming.
10:11:09 <ertes-w> yeah, streaming might be a problem
10:11:37 <ertes-w> but i don't see why unboxed vector is slower
10:11:52 <dolio> Slower than what?
10:12:07 <ertes-w> the only way i can think of is that the individual Bools are actually expensive to compute, and 'prop' only ever looks at a small subset, so that computation is saved
10:12:16 <ertes-w> dolio: slower than Data.Vector
10:12:26 <dolio> Oh.
10:13:43 <lyxia> qmmm: this definition of transducer seems to be the same as what we call combinators
10:14:30 <michi7x7> ertes-w: this is the performance report: https://gist.github.com/michi7x7/8c03e377256269775fb520411045fa11
10:14:39 <michi7x7> *profiling
10:14:43 <ertes-w> dolio: slower than Data.Vector (sorry, got disconnected)
10:14:45 <michi7x7> man, I'm tired ^^
10:15:47 <dolio> michi7x7: What's that huge number?
10:16:08 <ertes-w> is that memory by any chance?
10:16:34 <ertes-w> michi7x7: have you removed cnt?
10:17:34 <michi7x7> dolio: that's "entries"
10:17:35 * hackagebot drifter 0.2.3 – Simple schema management for arbitrary databases. – https://hackage.haskell.org/package/drifter
10:18:05 <michi7x7> ertes-w: It's still the same algorithm, I just thought you focused on the vector
10:18:32 <qmmm> lyxia: that's why i was asking :)
10:18:34 <ertes-w> michi7x7: you should remove cnt first
10:18:41 <ertes-w> use cnt' directly
10:19:01 <ertes-w> michi7x7: sharing cnt will most likely make things *much* worse
10:19:20 <ertes-w> also (!!) is just bad in general
10:19:57 <ertes-w> if you ever actually need this kind of memoisation use a vector, not a list =)
10:21:56 <ggVGc> wish my brain had better memoization
10:22:41 <cocreature> ggVGc: have you tried replacing the list in your brain by a vector?
10:23:00 <michi7x7> ertes-w: this is everything I have https://gist.github.com/michi7x7/8c03e377256269775fb520411045fa11
10:23:02 <ggVGc> quite certain it's a lookup table with randomized access cost
10:23:02 <dolio> > 40348^2
10:23:04 <lambdabot>  1627961104
10:23:42 <michi7x7> well, I'm pretty much done with the example, but I sure wonder why Vector.Unboxed is slower
10:23:58 <qmmm> if transducers are combinators, then what is the point of this library? https://deque.blog/2017/08/04/transducers-in-idris-2/
10:24:40 <ertes-w> michi7x7: that 'if' is just there to avoid needless slicing, right?
10:24:56 <phadej> qmmm: https://deque.blog/2017/07/28/implementing-clojure-like-transducers-in-idris-part-1/
10:25:01 <ertes-w> michi7x7: if yes, don't bother…  slicing is very cheap =)
10:25:07 <phadej> qmmm: first part answers it
10:25:42 <phadej> qmmm: in idris "consume . map f . produce " is bad idea if the stream is big
10:25:54 <michi7x7> ertes-w: no, if k ~ n the window goes way beyond the vector bounds. that's the reason for min, max. so this is the only memoized value I need
10:26:29 <ertes-w> michi7x7: i'm not entirely sure, but i think 'slice' doesn't mind going beyond bounds…  you'll just get an empty vector
10:26:46 <dolio> I feel like there's probably a better way to compute this number.
10:27:40 <ertes-w> michi7x7: nevermind, i was wrong
10:27:57 <ertes-w> michi7x7: you can just use 'take' and 'drop' though
10:28:33 <ertes-w> michi7x7: countTrue (V.drop x (V.take y v))
10:29:27 <michi7x7> ertes-w: one example input is for n=10000 k=9125, so most calls to countTrue are for the whole vector. cnt' is this value, memoized
10:30:09 <ertes-w> michi7x7: there is only one vector in memory…  you're really just changing start indices and lengths here
10:30:51 <michi7x7> ertes-w: cnt' is just memoization
10:31:11 <ertes-w> michi7x7: oh, now i see what you mean…  of course
10:33:18 <michi7x7> ertes-w: I still don't get why the unboxed vector is ~2 times slower
10:34:18 * hackagebot ftp-client-conduit 0.5.0.0 – Transfer file with FTP and FTPS with Conduit – https://hackage.haskell.org/package/ftp-client-conduit
10:34:18 * hackagebot ftp-client 0.5.0.0 – Transfer files with FTP and FTPS – https://hackage.haskell.org/package/ftp-client
10:40:26 <dolio> michi7x7: Hard to say without more low-level digging.
10:40:39 <ertes-w> michi7x7: me neither…  but i can't say that i really understand on a high level what your code is doing
10:42:28 <dolio> It looks like it's replacing each set bit with the sum of the bits set in a window around that bit, and then taking the sum of those numbers.
10:42:48 <ertes-w> yeah, that part i understand
10:43:01 <ertes-w> the only explanation i have is that perhaps something gets evaluated in the unboxed variant that doesn't get evaluated in the boxed one
10:43:44 <ertes-w> so for cases where only a small part of the vector is actually needed, a boxed vector might perform better…  but it would have to be a very small part
10:44:08 <ertes-w> the mere cost of indirection in boxed vectors should quickly outweigh that benefit
10:44:21 <ertes-w> + the added GC cost
10:47:18 <michi7x7> ertes-w: well, as said, it's just a stupid challenge I found online: https://www.hackerrank.com/challenges/sherlock-and-probability
10:47:19 <dolio> Maybe mediating between bytes and booleans is actually not faster than just storing booleans.
10:47:49 <dolio> Or maybe some optimization is failing.
10:48:06 <ertes-w> i could imagine that 'sum' somehow fails to be optimised to a left fold
10:48:14 <ertes-w> but that should hardly make a difference
10:49:23 <ertes-w> dolio: consider that the boxed variant stores pointers, and that the way 'main' is written there is unlikely to be any sharing
10:49:53 <michi7x7> dolio: this is a different users submission: https://gist.github.com/michi7x7/1abe26d249b385ca140166ff85e33155 he just sticks to bytes, but I think he's optimized the algorithm better than me
10:49:58 <ertes-w> on 64 bit architectures this makes the vector larger by a factor of 8, and then you also need to store all those Bool thunks
10:50:50 <ertes-w> michi7x7: a 1-to-1 translation of that to unboxed (Vector Bool) should perform better
10:52:02 <ertes-w> michi7x7: are you compiling with profiling enabled?
10:52:16 <michi7x7> hmm, he has the same sliding window. instead of my slicing, he has map take . tails
10:52:30 <michi7x7> ertes-w: yeah. hm, lemme try without
10:54:02 <michi7x7> compiling without profiling gives the same factor ~2 (with unboxed being slower than boxed)
10:54:29 <ertes-w> i'm assuming that you use -O
10:56:33 <michi7x7> ertes-w: ah, I compared -O2 with -O0 way back when it didn't make any difference. Well, it does now
10:57:03 <michi7x7> unboxed is now twice as fast as boxed
10:58:17 <ertes-w> michi7x7: thanks, i was about to go crazy…  there is just no way unboxed vector could be slower =)
10:58:43 <ertes-w> in fact i'm still going crazy, because the factor is much smaller than i expected
11:00:04 <dolio> I think you're over-estimating how bad the boxed booleans are.
11:00:57 <dolio> There's only one True and one False, so once evaluated, there's no 'lack of sharing' going on.
11:01:18 <ertes-w> dolio: but they still need their own memory block, don't they?
11:01:20 <dolio> Also the pointer tagging GHC does is perfect for booleans, because they have no content.
11:01:35 <the_2nd> how can I profile a program where the used libraries weren't compiled with profiling flags?
11:01:42 <ertes-w> dolio: oh?  so it pretty much just stores the booleans directly?
11:02:09 <dolio> So eventually it might basically be like storing booleans using 64 bits instead of 8 bits.
11:02:18 <ertes-w> i see
11:02:51 <ertes-w> dolio: does that happen for all types that are statically known to be sufficiently smaller than a pointer?
11:03:00 <ertes-w> does it happen for, say, Int32?
11:03:23 <dolio> It's not storing the boolean, it's tagging the pointers with which constructor it contains.
11:03:32 <ertes-w> oh, of course!
11:03:51 <ertes-w> and since there are no fields, there is no pointer to chase
11:03:52 <dolio> Because it has some extra bits in the pointer due to being aligned.
11:03:56 <dolio> Right.
11:04:05 <ertes-w> ok, that makes sense =)
11:04:26 <ertes-w> so basically the same would happen for Ordering
11:04:40 <dolio> Yeah.
11:04:49 <dolio> Any type with few enough nullary constructors.
11:04:56 <ertes-w> and for Nothing
11:05:16 <dolio> It might help for constructors with content, too.
11:05:38 <ertes-w> what about Just True?  it will need to chase in this case, right?
11:05:40 <dolio> But if all you can do is branch on which constructor it is, you can get away with only looking at the pointer once it's evaluated.
11:05:50 <dolio> Yeah, it's not going to flatten that.
11:06:35 <shapr> asthasr: are you angersock?
11:07:03 <Noxarivis[m]> Haskell interpreter for android?
11:07:09 <asthasr> shapr: No, I'm asthasr. Was actually mildly making fun of angersock :)
11:07:20 <ertes-w> dolio: is that the reason GHC has adopted that weird virtual memory behaviour that makes it look like the program is using terabytes of RAM?  so it can use pointer tagging?
11:07:26 <the_2nd> I have a Vector a, and f :: a -> Char and want to build a Text
11:07:36 <dolio> ertes-w: No.
11:07:55 <shapr> asthasr: I saw the reference, cool :-)
11:08:01 <the_2nd> what's the most efficient way? Currently using foldr' with : and pack afterwards
11:08:18 <lyxia> the_2nd: pack . map f . toList
11:09:03 <dolio> ertes-w: The pointer tagging is available because boxed stuff is 4 or 8 byte aligned, I think.
11:09:16 <ertes-w> ah, yeah…  makes sense
11:09:24 <ertes-w> so it's using the low bits
11:09:28 <dolio> The lower two or four bits would always be zero, so you can store whatever you want there and mask them off.
11:10:53 <the_2nd> lyxia, doesn't seem faster
11:11:01 <the_2nd> I like the definition more, tho
11:11:17 <ertes-w> dolio: so essentially something like Nothing (heh) needs no memory at all, unless you store it in a data structure, in which case it's fully encoded in the pointer itself
11:11:21 <the_2nd> Any reason it should be faster? Or was it just the way you'd do it?
11:11:35 <lyxia> the_2nd: yeah I don't think it would be faster than how you'd do it.
11:12:46 <ertes-w> or at least no heap memory
11:13:31 <ertes-w> in other words: GHC will not actually need to allocate a Nothing…  it will just construct an arbitrary pointer with the proper tagging
11:14:04 <nshepperd> dolio: how does that work? if I do something like case x of { Just True -> $foo } does it modify the Just contructor at $foo to replace the pointer to True with the tagged pointer?
11:15:18 <the_2nd> lyxia, It's a string of 10k elements and it seems to take forever :/
11:15:35 <ertes-w> nshepperd: the way i imagine it: if 'x' happens to be a Just, then it's a pointer to the boolean, which is itself a pointer tagged to be True
11:15:49 <ertes-w> nshepperd: and if it's a Nothing, it's basically just a dummy pointer tagged to be Nothing
11:16:26 <lyxia> the_2nd: doesn't that mean f is just slow?
11:17:05 <the_2nd> maybe, but it's just :
11:17:15 <nshepperd> like I would assume that when I create a 'Just (some boolean expression)' the pointer in there is not tagged (or tagged with 'unevaluated') because the constructor is not known yet. so when does it become tagged?
11:17:15 <the_2nd> f Grass = 'g'   f Forest = 'f' etc
11:17:52 <nshepperd> perhaps all pointers are updated whenever they are entered?
11:17:55 <lyxia> the_2nd: 10k elements really seems small
11:18:03 <ertes-w> nshepperd: i would assume that it's tagged from the start
11:18:06 <the_2nd> lyxia, I send the string via happstack to a client, maybe there's some real overhead
11:18:16 <ertes-w> nshepperd: and that "unevaluted" has its own tag value
11:18:36 <ertes-w> probably 0, because then the pointer can be followed directly to evaluate it
11:18:36 <dolio> nshepperd: I don't know exactly how it works.
11:23:50 * hackagebot debug-me 1.20170810 – secure remote debugging – https://hackage.haskell.org/package/debug-me
11:28:26 <dolio> nshepperd: I think the most straight forward thing it could do is, when something unevaluated becomes evaluated, the previous thunk gets replaced by forwarding information to the evaluated data.
11:29:25 <dolio> And eventually the old pointers get fixed up (by the garbage collector) to point directly to the data, at which point the tags would get fixed, too.
11:30:03 <dolio> You can probably opportunistically fix up while following pointers, too.
11:32:29 <gremdrus> does anyone know how to pass parameters to ghci using intero?
11:38:19 <jared-w> paramaters? Like what
11:40:06 <sfuwvo> Is there a way to transfer build packages between machines (e.g. to provide the packages for a Travis build)?
11:40:15 <sfuwvo> s/build/built/
11:47:46 <the_2nd> Can someone help me out? I'd like to create a png image with juicy pixels. Not load it, but create it from a function
11:49:02 <Cale> Where are you getting stuck?
11:49:23 <the_2nd> No idea on how to create the initial image
11:49:45 <Cale> Perhaps generateImage?
11:50:31 <the_2nd> looks promising
11:52:33 <sfuwvo> Can I, for example, just simply copy a "dist-newstyle" directory from one machine to another, if they're both on the same OS and have the same OS-packages?
11:56:33 <the_2nd> Cale, got it to work, thanks :)
11:57:38 <Cale> the_2nd: cool
11:59:10 <sfuwvo> My underlying problem is, Travis is dying with an OOM while building dependencies (mainly haskell-src-exts)
11:59:29 <sfuwvo> Those dependencies are the same each time, so I wonder if there's a way to skip the building altogether
11:59:40 <nitrix> Has hot-reloading/live-patching ever been attempted for Haskell?
12:04:18 <Zemyla> Is lambdabot down?
12:04:42 <sfuwvo> nitrix: yes, simon marlow has done some work on it recently. you can also check out the 'foreign-store' package
12:04:46 <shapr> @quote Cale 
12:04:51 <shapr> :-(
12:04:52 <lambdabot> Cale says: Basically, we've known how to implement first class functions efficiently for 20 or 30 years now, and we've known about their importance to abstraction in  programming since before the
12:04:57 <shapr> oh yay!
12:04:58 <lambdabot> advent of electronic computers. There's no excuse to still be writing new programs in languages without them.
12:05:09 <lyxia> @quote shapr
12:05:12 <shapr> uh oh
12:05:16 <lambdabot> shapr says: In honor of functional programming typos, I propose that the first day of every week be called Monady.
12:05:24 <shapr> :-)
12:05:26 <shapr> @quote lyxia
12:05:34 <lambdabot> No quotes match. My pet ferret can type better than you!
12:05:36 <shapr> aww
12:05:48 <lyxia> :)
12:05:52 <Tuplanolla> How does lambdabot harvest the quotes?
12:06:00 <lyxia> you tell it to
12:06:02 <shapr> they're entered manually
12:06:09 <Tuplanolla> Laaame.
12:06:09 <shapr> @quote segfault
12:06:10 <Zemyla> Also, there is no Haskell Platform 8.2.1 for Windows yet?
12:06:16 <lambdabot> Japsu says: segfault cat is watching you unsafeCoerce
12:06:29 <shapr> Tuplanolla: what would be better?
12:06:31 <ertes-w> nitrix: https://hackage.haskell.org/package/rapid
12:06:38 <Tuplanolla> Sentience, shapr.
12:06:48 <shapr> I don't know how to implement that.
12:06:55 <shapr> Tuplanolla: put up a PR?
12:07:06 <Tuplanolla> I'll get right to it.
12:07:17 <nitrix> sfuwvo: ertes-w Checking both. Thanks for the clues.
12:08:42 <nitrix> ertes-w: That's fascinating. How does it handles things like StateT over a datatype that is modified (say a new field is added to a record)? How will it know the initial state value to use?
12:09:26 <sfuwvo> So are there any common strategies for avoiding rebuilds of dependencies on Travis/
12:09:27 <sfuwvo> ?
12:10:10 <nitrix> sfuwvo: Travis lets you cache your .stack-work/.cabal-sandbox folder
12:10:55 <gremdrus> I'm currently working on something using gloss. When I type main the program runs, but when I quit I get "Process intero finished". When I run it in ghci, and then exit, it does not return to ghci, but goes to bash.
12:11:06 <sfuwvo> Oh cool
12:11:15 <sfuwvo> does that work with cabal new-build?
12:11:20 <nitrix> sfuwvo: By making those folders persistent, stack/cabal behaves just like you would expect with the incremental compilation.
12:11:46 <sfuwvo> So the idea is, if you can build it once it stays?
12:11:51 <sfuwvo> And you can reuse it?
12:12:15 <nitrix> sfuwvo: I've transitioned from cabal to stack, I wouldn't know, but you can extrapolate from how it works on your local machine and making the relevant files persistent on travis.
12:13:01 <nitrix> sfuwvo: Yeah it'll upload & download the folders you want persisted to so storage area of theirs on every build.
12:13:37 <nitrix> Takes a few seconds and bandwidth for them, but it's still faster than complete rebuilds + cpu cost.
12:13:43 <cocreature> sfuwvo: https://github.com/hvr/multi-ghc-travis will set up your travis config using new-build + caching
12:13:47 <Franciman> Hello
12:13:55 <Franciman> Is there an equivalent of MonadIO for ST?
12:14:04 <sfuwvo> So I assume I have to get the whole thing to build correctly once?
12:14:25 <sfuwvo> I.e. I can't have it fail halfway through, but then that first half is cached, then make it farther on the next build?
12:15:12 <nitrix> Franciman: Possibly STT, but you have to be extremely careful with it to not break referential transparency.
12:15:15 <cocreature> yeah I think failing builds won’t update the cache
12:15:45 <cocreature> Franciman: PrimMonad
12:15:51 <Franciman> ok thank you
12:15:55 <nitrix> :o
12:16:07 <michi7x7> @quote php
12:16:07 <lambdabot> AaronBallman says: i often wonder if php is the best language ever
12:16:23 <cocreature> wait no ignore me that’s not an equivalent of MonadIO
12:16:50 <Franciman> I'll explain my use case. I have ReaderT (ST s)
12:16:56 <Franciman> in a newtype
12:17:11 <Franciman> I'd like to use generalizednewtypestuff to directly run ST operations
12:17:38 <Franciman> cocreature, I guess it works PrimMonad
12:17:47 <nitrix> Franciman: STT's documentation says "Safe monads include the monads State, Reader, Writer, Maybe and combinations of their corresponding monad transformers."
12:17:53 <nitrix> STT would work with ReaderT.
12:18:04 <Franciman> nitrix, in which package is STT?
12:18:11 <ertes-w> nitrix: sorry, i can't explain it right now, but the tutorial at the top of the Rapid module should explain everything
12:18:11 <nitrix> STMonadTrans
12:18:19 <cocreature> PrimMonad allows you to write code that is polymorphic but can use features available in ST and IO but it doesn’t give you something like "liftST"
12:18:36 <Franciman> cocreature, but ReaderT implements it
12:18:45 <Franciman> if its underlying monad does
12:18:49 <Franciman> so if I run primitive
12:18:57 <Franciman> it should be fine?
12:19:03 <Franciman> thanks nitrix 
12:19:27 <cocreature> ah it provides "stToPrim"
12:19:30 <cocreature> that’s the liftST
12:19:34 <cocreature> equivalent
12:19:39 <lyxia> Franciman: MonadBase is a generalization of MonadIO
12:20:09 <ertes-w> nitrix: BTW, rapid is for development, not for production
12:20:13 <Franciman> ok thanks
12:20:23 <Franciman> thanks everybody for the help
12:20:24 <ertes-w> nitrix: i do hot reloading in production by using separate processes
12:21:29 <nitrix> ertes-w: Noted. I want to see how the various problems are approached for my own implementation that will be in a different language. But I'm also curious how they made Haskell's lazyness plays nice with it :P
12:22:05 <ertes-w> nitrix: my personal opinion is: don't do it =)
12:22:11 <ertes-w> do unix, use separate processes
12:22:33 <nitrix> ertes-w: I want to do Actor-based hot-reloading. They are basically processes.
12:22:56 <nitrix> State is kept locally, sharing is done by communicating.
12:23:36 <ertes-w> nitrix: sounds like that should be easy to split into processes
12:23:43 <ertes-w> all you need is proper fault tolerance
12:24:22 <ertes-w> you don't necessarily need multiple programs, just one program running multiple times, doing different things in each instance
12:24:49 <ertes-w> you could even try distributed-process (a.k.a. cloud haskell), but i didn't like it very much
12:24:55 <nitrix> Yup. Isolating and all is more or less simple. Patching the code for future/existing processes is alright too. I'm mostly worried about state variables and their data types.
12:25:20 <nitrix> Any changes to a data type in the newer version means I have to do some kind of migration of the values of that type in the previous version.
12:25:55 <nitrix> Removing a field is no problem, it's not used anymore, but adding a field raises the problem of initialization. What value will it be initialized too?
12:26:14 <ertes-w> nitrix: if your interchange format is reasonably dynamic, like JSON, that shouldn't be much of a problem
12:26:16 <nitrix> Normally the code performs initialization, but here you're hotpatching so there's no code ran to perform the initialization.
12:26:24 <ertes-w> ironically removing a field in this case is more problematic than adding one =)
12:26:28 <nitrix> So what value do they obtain? It puzzles me :P
12:26:47 <nitrix> ertes-w: Is it though? You remove the field and nothing uses the field anymore. I don't see a problem.
12:27:23 <ertes-w> nitrix: wait, are you talking about transferring state from one component to its updated version?
12:27:31 <ertes-w> or about communication between components?
12:27:31 <nitrix> ertes-w: Correct.
12:27:56 <nitrix> Communication is the second problem, but shouldn't be as bad to tackle.
12:28:00 <ertes-w> oh, in that case i always try to make them as self-initialising as possible…  and all state is stored in sqlite
12:28:34 <nitrix> So... you have predefined default values for all your types?
12:28:47 <ertes-w> if you need a table that doesn't exist, create it, if you need a column that doesn't exist, add it to the table, etc.
12:29:13 <ertes-w> nitrix: i rather come up with a way to handle lack of a value
12:29:16 <nitrix> Mhhh, actually thinking of it in terms of a table seems easier indeed.
12:30:05 <ertes-w> the idea is: load the information you get, infer the missing pieces…  if that fails, throw an exception
12:30:40 <ertes-w> and sqlite also makes sure that your data is consistent
12:30:49 <nitrix> Backtracking, I have processes communicating via messages. Then you hotpatch. Existing processes can upgrade their code without problem. Then there are the two issues mentioned (1) converting old state to new state (2) converting queued messages to new messages
12:31:18 <nitrix> (2
12:31:26 <nitrix> Whoops.
12:31:32 <ertes-w> don't convert…  use a non-rigid format and infer missing pieces
12:32:01 <ertes-w> in short: be fault-tolerant =)
12:32:34 <nitrix> ertes-w: Sounds like a good idea. Though the language uses some form of pattern matching.
12:33:08 <ertes-w> i gotta go…  good luck =)
12:34:15 <nitrix> ertes-w: Hehe~ Thanks still, you gave me the little kick I needed to thinker about all of this.
12:34:22 <nitrix> I should be able to solve it on my own.
12:40:41 <gremdrus> how do you debug a library? I want to git clone a library and use that modified version instead of stack going to hackage. How do I do that?
12:41:42 <lyxia> gremdrus: you add the path to the library in the packages field of stack.yaml
12:43:25 <gremdrus> lyxia: could you show me an example? I am looking at https://docs.haskellstack.org/en/v1.0.2/yaml_configuration/ and it's not making any sense to me
12:44:48 * hackagebot gotta-go-fast 0.1.4.0 – A command line utility for practicing typing – https://hackage.haskell.org/package/gotta-go-fast
12:45:01 <kadoban> gremdrus: Look at - location: vendor/binary  (and the extra-dep thing below it) in the example below "To tie this all together"
12:45:22 <kadoban> So you'd just download the library as a subdirectory of your project and specify it like that
12:46:49 <gremdrus> kadoban: but those examples use location to specify an hg/git repo, not a file directory.
12:47:15 <kadoban> gremdrus: The one with vendor/binary is just a (relative) directory.
12:48:04 <gremdrus> kadoban: ah, okay I think I got it
12:52:06 <gremdrus> now I am trying "stack install" and I am getting an error saying that "but no .cabal file could be found there."
12:52:35 <gremdrus> also I'm not sure what 'vendor/binary' means. I think it's a relative path, right?
12:52:53 <gremdrus> and the project doesn't have a cabal file, just a stack one
12:53:09 <kadoban> gremdrus: It should have a .cabal file too.
12:53:17 <kadoban> And yes, it's a relative path.
12:53:35 <gremdrus> kadoban: https://github.com/benl23x5/gloss doesn't have one
12:53:54 <lyxia> it's a project with multiple packages
12:54:07 <gremdrus> kadoban: that's funny, I tried "libs/gloss" but it seemed to just want to check the current folder for gloss
12:54:28 <lyxia> add my/path/gloss/gloss
12:54:42 <lyxia> add my/path/gloss/gloss-rendering
12:54:43 <gremdrus> lyxia: thank you, that makes sense now
12:55:28 <gremdrus> so it should look like this, right? https://gist.github.com/gremdrus/3f1331dcf4fabf82eacc7c755a170153
12:57:27 <lyxia> it should look like   packages:  - gloss/gloss
12:57:54 <kadoban> gremdrus: You probably want to specify it's an extra dep, so you usually do want the location: syntax. But I'm not sure what line 2 is doing.
12:58:25 <kadoban> That's pointing somewhere where there's no .cabal file, right? Also you don't have - .    in the packages list, is that intentional?
12:59:10 <kadoban> Or - '.'   whatever it is
12:59:15 <gremdrus> kadoban: on the first point, I mistakenly thought that you specified the name and then  the location, but that's not true, it's just the path/name/repo
12:59:26 <gremdrus> kadoban: but that second point is right, but I don't understand why I need it
12:59:59 <kadoban> Because otherwise it's not going to look in the current directory for a cabal file or anything to build or anything I don't think.
13:00:07 <kadoban> Or you mean the extra-dep part?
13:01:56 <gremdrus> kadoban: okay, I understand now. The - . tells it to include the current directory.
13:02:10 <gremdrus> kadoban: but I don't understand anything about extra-dep, or why I should use it
13:05:17 <kadoban> gremdrus: It means you're only using that specified thing as a dependency. I'd have to look up the exact effects, something like it doesn't build it unless it needs to (you specify in your .cabal file that you depend on it for example), and it makes the test suites and benchmarks not usually run.
13:12:08 * hackagebot prim-array 0.2.1 – Primitive byte array with type variable – https://hackage.haskell.org/package/prim-array
13:19:25 <Chobbes> So, here's a silly question. Say I want to take a Double and convert it to an Int, and if it's too big to fit in the Int I want it to overflow? Currently it seems to give 0 as a value.
13:20:55 <Cale> Chobbes: hm?
13:21:51 <Chobbes> Cale: so, if my integer bounds are between -10 and 10, and I have a floating point number 11, when I convert to the int I want to get -9.
13:23:30 <Chobbes> Whereas, `floor 11.0` would yield 0 currently.
13:23:43 <Chobbes> (using made up bounds for Int)
13:24:28 <Hafydd> Chobbes: what is a concrete example of this happening?
13:24:51 <lyxia> > floor 10e100
13:24:54 <lambdabot>  9999999999999999770495132652453366284468427199241500061299959747319934521807...
13:24:55 <lyxia> > floor 10e100 :: Int
13:24:58 <lambdabot>  0
13:25:13 <cocreature> > fromIntegral (floor 10e100 :: Integer) :: Int
13:25:15 <lambdabot>  0
13:25:28 <cocreature> huh I thought that overflowed
13:25:29 <Hafydd> > (floor 10e100 :: Integer, floor 10e100 `mod` 2^26 :: Integer)
13:25:31 <lambdabot>  (999999999999999977049513265245336628446842719924150006129995974731993452180...
13:25:48 <Hafydd> > floor 10e100 `mod` 2^64 :: Integer
13:25:50 <lambdabot>  0
13:26:11 <Chobbes> I guess I could just go to Integer and then to Int.
13:26:12 <jared-w> > 10e100 `mod` 2^64 :: Integer
13:26:14 <lambdabot>  error:
13:26:14 <lambdabot>      • No instance for (Fractional Integer)
13:26:14 <lambdabot>          arising from the literal ‘10e100’
13:26:30 <Hafydd> It does overflow; it's just that the floor of 10e100 overflows to exactly 0.
13:26:35 <cocreature> oh lol
13:26:38 <lyxia> 10e100 is probably divisible 2^whatever as a Double
13:27:04 <Tuplanolla> Surely you all mean wrap instead of overflow.
13:27:06 <jared-w> > floor 10e97 :: Int
13:27:11 <lambdabot>  0
13:27:36 <jared-w> > floor 10e100 `mod` 2^64 :: Integer
13:27:39 <lambdabot>  0
13:27:40 <Hafydd> Yes, more specifically I mean wrapping due to overflow.
13:27:45 <Chobbes> Tuplanolla: yeah :)
13:27:51 <jared-w> @src floor
13:27:51 <lambdabot> Source not found. Your mind just hasn't been the same since the electro-shock, has it?
13:27:58 <jared-w> lol
13:28:25 <NickHu> Has anyone got any advice for profiling a program that gets OOM killed?
13:28:29 <lyxia> > floor 10e10 :: Int
13:28:31 <lambdabot>  100000000000
13:28:38 <lyxia> > floor 10e40 :: Int
13:28:38 <NickHu> I'm passing an rtsopt of -p but it gives me an empty .prof file
13:28:40 <lambdabot>  0
13:28:51 <jared-w> floor x = if r < 0 then n - 1 else n where (n,r) = properFraction x
13:28:51 <Hafydd> > floor 10e20 :: Int
13:28:54 <lambdabot>  3875820019684212736
13:29:09 <jared-w> properFraction (10e10 :: Int)
13:29:14 <jared-w> >properFraction (10e10 :: Int)
13:29:30 <codeshot> Is there any neat mathematical type (eg, Monoid, etc) that has an associative operator that is (.) for functions, but can be something else for other types ?
13:30:01 <Tuplanolla> Like `Semigroup`, codeshot?
13:30:11 <codeshot> oh, thanks
13:30:14 <lyxia> NickHu: download more RAM
13:30:34 <Franciman> codeshot, Monoid, where you have for Int that the associative operator is either (+) or (*)
13:30:42 <NickHu> lyxia: ...
13:30:42 <Franciman> you choose
13:31:14 <mnoonan> codeshot: "category"!
13:31:18 <michi7x7> @pl \x y -> x + 1
13:31:18 <lambdabot> const . (1 +)
13:31:26 <jared-w> Franciman: are those the only ones for Int? I thought we had more possible ones, perhaps
13:31:37 <Franciman> jared-w, yeah, I was just giving examples
13:32:03 <Franciman> jared-w, no wait
13:32:24 <lyxia> max, min
13:32:29 <Franciman> oh ok!
13:32:45 <Chobbes> > floor (1.5 * 9223372036854775807 :: Double) :: Int
13:32:48 <lambdabot>  -4611686018427387904
13:32:57 <Chobbes> > floor (3.5 * 9223372036854775807 :: Double) :: Int
13:32:59 <lambdabot>  -4611686018427387904
13:33:01 <lyxia> land, lor, lxor
13:33:20 <Chobbes> Maybe it does wrap...?
13:33:26 <lyxia> it does
13:33:51 <Chobbes> Okay, nevermind then :). Thanks!
13:33:52 <codeshot> Ultimately I want to write this in a neater form id . id . id <> id . (map blah) <> transpose . id <> transpose . (map blah)
13:34:04 <lyxia> Chobbes: you may be getting 0 because your numbers are too big. (Big floats are powers of 2.)
13:34:08 <codeshot> too many "id" at the start
13:34:56 <codeshot> but I wanted to condense it to something "like" (id <|> transpose) <> (id <|> (map blah)
13:35:11 <codeshot> (I know Alternative isn't the one for this but just to get an operator in there ...
13:35:24 <Chobbes> lyxia: yeah, I was realizing that :P. Is there a convenient way to just extract the mantisa of a Float / Double in Haskell?
13:35:31 <codeshot> This way I can build up a much bigger table of all combinations succinctly
13:35:47 <lyxia> Chobbes: properFraction
13:36:18 <codeshot> But I don't want to make it type specific so I'm looking for a class but I'd like it to word for lists so the order is specified by the expression
13:36:57 <XorSwap> @type <>
13:36:59 <lambdabot> error: parse error on input ‘<>’
13:37:02 <XorSwap> @type (<>)
13:37:04 <lambdabot> Monoid m => m -> m -> m
13:38:54 <lyxia> > intercalate " <> " [a ++ " . " ++ b | a <- ["id", "transpose"], b <- ["id", "map blah"]] -- codeshot
13:38:57 <lambdabot>  "id . id <> id . map blah <> transpose . id <> transpose . map blah"
13:39:00 <jared-w> Chobbes: in fact, float actually uses properFraction under the hood
13:39:29 <jared-w> floor**
13:39:31 <Chobbes> jared-w: I thought Float was an IEEE-754 float...?
13:39:33 <codeshot> Is there a generalised class with a method that is "intercalate" for Lists ?
13:39:42 <jared-w> Chobbes: I wrote float when I meant floor; m'bad :p
13:39:56 <Chobbes> Ooooh, I see.
13:40:16 <codeshot> oh
13:40:19 <codeshot> haha
13:40:22 <lyxia> codeshot: I don't think so.
13:40:39 <Chobbes> lyxia: that's not quite what I meant, though. I literally mean take the bits for the mantisa of the double, and put them in an Int.
13:41:06 <codeshot> same here :) not quite what I meant
13:41:30 * jared-w is confused as to what intercalate does, exactly
13:42:08 <jared-w> ahh gotcha, I see what it does now
13:42:44 <lyxia> Chobbes: ah. uh.
13:42:55 <jared-w> intercalate is just `concat (intersperse xs xss)` yeah I don't think there's any generalized class for that
13:43:36 <Chobbes> lyxia: yes, I'm in bit level hacking land in Haskell. The saddest little canyon on Earth.
13:43:45 <jared-w> However, anything that's Foldable also has toList, so you could just intercalate on toList versions of the structures, codeshot 
13:44:06 <codeshot> I'm not trying to "print" it as a string. I'm trying to build a haskell function that builds a term in a monoid over composed cartesian products
13:44:41 <Tuplanolla> It's pretty miserable without numeric types that throw exceptions on overflows, Chobbes.
13:45:52 <codeshot> This is to create a complete selection of symmetries without writing them all out and apply the selection to any monoid that supports those symmetries. The examples I gave above are list specific but I'd like to understand how to describe such things in general
13:47:04 <codeshot> well, maybe "symmetries" should be "transforms"
13:47:44 <jared-w> edwardk would be the guy to ask about blending category theory with cartesian products
13:48:02 <codeshot> thanks anyway
13:48:14 <jared-w> (also we need a ?where CT-nerds function, I think...)
13:48:26 <lyxia> Chobbes: https://hackage.haskell.org/package/data-binary-ieee754-0.4.4/docs/Data-Binary-IEEE754.html#v:doubleToWord
13:48:53 <lyxia> https://hackage.haskell.org/package/reinterpret-cast-0.1.0/docs/Data-ReinterpretCast.html
13:49:42 <Chobbes> lyxia: oh, that's probably the terrible magic I want :).
13:51:34 <ClaudiusMaximus> :t decodeFloat  -- the RealFloat way, doesn't handle nans or infs though
13:51:35 <Profpatsch> parseFoo :: Sth -> Validation (NonEmpty ParseError) Foo
13:51:35 <lambdabot> RealFloat a => a -> (Integer, Int)
13:51:37 <Profpatsch> or
13:51:41 <Profpatsch> parseFoo :: Sth -> Either (NonEmpty ParseError) Foo
13:51:44 <Profpatsch> or
13:51:51 <Profpatsch> parseFoo :: Sth -> Either [ParseError] Foo?
13:52:19 <lyxia> codeshot: If you ignore the String aspect of my snippet you are left with the list comprehension which conveniently expresses cartesian products.
13:52:26 <Profpatsch> First one takes the explicit import of Data.Either.Validation for the user
13:52:47 <Profpatsch> Second one can use Foldable to work with NonEmpty.
13:52:54 <Profpatsch> Third one is inaccurate.
13:53:00 <Profpatsch> So probably expose the second one?
13:53:08 <Profpatsch> And use Validation internally only?
13:53:34 <Profpatsch> Since NonEmpty is in base now, that should be ok?
13:53:56 <Profpatsch> API design folks, help me out. :)
13:56:49 <lyxia> Second one +1
13:58:35 <jared-w> I'd go for the second one for sure; explicit imports mean you're leaking implementation details everywhere
14:00:00 <jared-w> Third one isn't super terrible because it seems like you can work around the inaccuracy of a potentially-empty list. Second one seems nicer though
14:00:01 <hatds> For Lazy Bytestrings the function unpack :: ByteString -> [Word8] returns a lazy list, right?   I'm using an audio library to effectively do  'last $ unpack bs' and feel it should run in constant memory, but it runs out of memory instead.
14:00:04 <Profpatsch> Ah, and the user shouldn’t use my error type to add new cases, but create their own.
14:01:18 <Profpatsch> So they wouldn’t need the Validation ErroList in any case, but the ability to do easy matching (which Left/Right supports)
14:01:37 <Profpatsch> API design is hard.
14:01:51 <lyxia> hatds: That sounds right.
14:02:54 <jared-w> Profpatsch: make 2-3 different "users" and use the library through their perspective. Find all the commonalities they want and disregard everything else. Then use the library for some stuff; every time something sucks, make it suck less. Go through some overhauls, and eventually it'll be a bit more polished
14:03:03 <hatds> Thanks lyxia.  Anyone here ever use the 'WAVE' package by chance?
14:04:52 <jared-w> Alternatively, I'm quite fond of the philosophical "what are the laws of my tool" approach. Figuring out a consistent base from which to build up and reason about features and implementations is very helpful for me. It's why the lens library, though complex, feels very flexible and easy to use--it feels like learning a new concept that's baked into programming rather than learning "the library"
14:06:50 * hackagebot dejafu 0.7.1.0, hunit-dejafu 0.7.0.0, tasty-dejafu 0.7.0.0
14:06:50 * hackagebot  → https://hackage.haskell.org/packages/recent
14:08:01 <tdammers> jared-w: I think edward kmett once said something like how he started with just lenses, but then he discovered that there are more concepts that are closely related, and then even more, until things fell into place and it all came full circle, and that's why the lens library looks the way it does - it all fits together and forms a complete abstraction
14:11:06 <gremdrus> when I edit the cabal of a project created with "stack new hgamer simple" and try to add a dependency, I get this: https://gist.github.com/gremdrus/a113d7fc6021c467416d545f9d18d7aa
14:11:29 <gremdrus> am I supposed to also add it to the stack.yaml?
14:11:53 <gremdrus> I forget which new project I made, but the first one worked fine just by modifying the .cabal
14:12:51 <kadoban> gremdrus: When the resolver you're using doesn't specify a version of hgamer3d, you have to do it yourself yes. In the stack.yaml file. If it's not in hackage, you have to tell it where to find it as well.
14:13:27 <gremdrus> kadoban: it is in hackage, but wait what's this about a resolver?
14:14:17 <t7> is there  a pattern for   map (map f) g
14:15:02 <kadoban> gremdrus: In stack.yaml there will be a resolver specified. A resolver is a set of packages with exact versions.
14:15:36 <Profpatsch> t7: When you have [[a]] you probably want a more descriptive type anyway.
14:16:23 <Profpatsch> Like Matrix a or Buffer a or something similarly domain specific.
14:16:43 <Profpatsch> Which doesn’t export the implementation and provides a nice interface.
14:17:39 <Profpatsch> But of course you can write a function twomap f g = map (map f) g
14:17:52 <algebra> t7: map (map f) = (map . map) f.  
14:20:54 <algebra> t7: if you nest more, you compose more maps. (map . map . map) :: (a -> b) -> [[[a]]] -> [[[b]]]. 
14:21:21 <t7> quick code review please?: http://lpaste.net/357587
14:26:34 <lyxia> I would use less bindings and more function compositions
14:29:29 <orzo> Has anyone written tips on optimizing compile time?
14:30:12 <phadej> stack build --fast
14:30:13 <orzo> i was going to use this package, store, for serialization, but it took so damn long to compile, that I don't want to depend on it now
14:30:27 <koz_> phadej: That's an actual option?
14:30:31 <phadej> koz_: yes
14:30:31 <orzo> the store authors put special effort into optimizing for space and time
14:30:39 <phadej> it's essentially does -O0
14:30:50 <orzo> but they need to account for compile time
14:31:11 <phadej> (but probably/hopefully not for snapshot dependencies)
14:31:31 <geekosaur> +RTS -A512M ?
14:31:36 <orzo> well, that's fine, but i mean, there are probabl tricks an author can do to reduce burden on the compiler
14:32:09 <boj> like avoid TH
14:32:15 <orzo> yeah
14:32:30 <orzo> but it'd be nice to have a collected list of tips
14:32:43 <koz_> orzo: Start one! You've already got one answer.
14:32:51 <koz_> Then invite people to contribute.
14:33:04 <sbrg> FWIW work is being done on compile time. the newest ghc shows some improvement
14:33:20 <phadej> it really depends, avoiding TH helsp compiler but sacrifices programmer productivity
14:33:25 <phadej> tip #1: buy better computer
14:33:27 <orzo> i'm using 8.0.1 which is fairely recent
14:33:35 <AlainODea> What is a good a constant time compare == (ie not short circuit false) for ByteStrings? I need it for secure hash comparison
14:33:55 <boj> i think it was SPJ that pointed out that for each regression that slows GHC down, there's an optimization which slows it down as well. keeping GHC fast sounds like a tough problem
14:34:02 <sbrg> AlainODea: You can implement your own that doesn't short-circuit. 
14:34:07 <sbrg> you just cover all patterns.
14:34:27 <dmwit> sbrg: Purely out of curiosity: any relation to srhb? (Your nicks even hash to the same color in my client!)
14:34:35 <sbrg> nope
14:34:38 <sbrg> but not the first time i'm asked
14:34:44 <orzo> really, it'd be nice to know what ghc is really good at doing fast, and what imposes more burden on it
14:34:47 <dmwit> heh, I bet
14:34:47 <codeshot> lyxia, I got it
14:35:02 <orzo> something ghc hackers could give more insight to than simple tips like "avoid TH"
14:35:22 <monochrom> I think what's on that list. But every item is an antithesis to good programming practices. For example, Always Repeat Yourself. For example, Unmodularize Your Code. For example, Handwrite All Possible Combinations And Hand-Optimize Them.
14:35:33 <dmwit> AlainODea: I think there's a package on Hackage for that.
14:35:37 <geekosaur> it varies. I think in 8.0.1/2 heavy type family usage might be a problem?
14:35:37 <phadej> monochrom: indeed.
14:35:38 <dmwit> Let me see if I can find it.
14:36:17 <monochrom> There is an exception though. One item says, Do As Richard Bird Told You To.
14:36:32 <phadej> orzo: you should write idiomatic code and bitch about it
14:36:42 <AlainODea> sbrg: dmwit: thank you. I've got this so far, which may be garbage ;) http://lpaste.net/357588
14:36:50 <phadej> then ghc devs will notice "damn, that's normal haskell code, we should compile it fast"
14:37:01 <sbrg> aaah. 
14:37:13 <phadej> but good advice is, don't use {-# INLINE #-}
14:37:32 <orzo> is INLINABLE faster?
14:37:39 <monochrom> But is INLINABLE OK?
14:37:39 <koz_> orzo: Potentially.
14:37:39 <orzo> than INLINE
14:37:45 <koz_> Inlining is a very tricky optimization.
14:37:49 <phadej> if you don't use RULES, you don't need INLINE
14:38:07 <phadej> inlining is something you should do when you have benchmarks in place
14:38:14 <phadej> (fine-tuning inlining)
14:38:33 <orzo> is there a switch to turn off INLINE so you can measure comiple time
14:38:40 <monochrom> Ah OK, yeah, benchmark before micromanaging.
14:38:43 <orzo> for someone else's code
14:39:39 <orzo> he did a lot of benchmarks to optimize for memory use and time, and got tremendous improvements over cereal
14:39:54 <orzo> but i wonder if he didn't just make the code really fat with a lot of INLINE
14:40:54 <hatds> Here's a 20 line program that runs out of memory using Lazy Bytestring when I wasn't expecting it to:  http://lpaste.net/357589    Is hGet not lazy perhaps?
14:41:30 <orzo> maybe when optimizing, kyou should reach for some kind of progress monad pattern before INLINE
14:41:40 <monochrom> Depends on whose hGet. And depends on all factors you haven't thought of.
14:42:16 <glguy> hatds: Hopefully hGet isn't lazy given that you closed its handle straight away
14:42:48 <hatds> glguy: isn't that what "semi-Closed" is all about?
14:43:09 <monochrom> Wait what? hGet is not hGetContent.
14:43:17 <orzo> i think the store author used INLINE to reduce memory use, but a Progress pattern, similar to https://www.well-typed.com/blog/2016/01/efficient-queues/
14:43:26 <phadej> hGet doesn't seem to do any interleaveIO
14:43:28 <orzo> might work
14:43:29 <phadej> so it's not lazy
14:43:34 <glguy> No, semi-closed doesn't mean that you should close it yourself
14:43:34 <monochrom> Now what does hGet's doc really say?
14:44:07 <glguy> hatds: Once you use a lazy IO operation like hGetContents on a Handle, the handle isn't yours to close anymore
14:44:24 <hatds> okay, so this library is bugged them
14:44:38 <lyxia> hGetContents emphasizes the fact that it's lazy, so the other functions are probably strict by default.
14:44:39 <glguy> No, the library appears to be working as documented
14:45:07 <koz_> orzo: Thanks for that link - that's really quite interesting.
14:45:13 <hatds> I mean the WAVE package, which says "The audio reader and writer are sufficiently lazy that files larger than memory can be processed."
14:45:21 <monochrom> Wait why are we talking about semiclosed? This is openFile-hGet-hClose. What semiclosed?
14:45:45 <hatds> monochrom: I was mixed up
14:45:56 <monochrom> OK so your mind is bugged.
14:46:56 * hackagebot tibetan-utils 0.1.1.3 – Parse and display tibetan numerals – https://hackage.haskell.org/package/tibetan-utils
14:47:08 <koz_> Mind bugs are worst bugs.
14:47:18 <glguy> "this" was ambiguous in the original "bugged" comment
14:47:36 <orzo> koz_: you're welcome, i read it recently and found it very instructive
14:48:14 <monochrom> OK I see. Sorry.
14:48:18 <orzo> i'm going to keep the technique in mind and hope to find application in my code
14:49:26 <hatds> How should I fix this library so it reads the entire file into a Lazy ByteString correctly?  Can I write a 'hGet n'  that is lazy?
14:49:56 <monochrom> No, hGet won't be lazy.
14:50:08 <monochrom> Use hGetContent or pipes or conduits or machines.
14:50:34 <hatds> If you use hGetContents after reading an initial part of the file, does it only read the remaining part?
14:50:56 <monochrom> I think yes.
14:51:27 <hatds> so take n <$> hGetConents, and make sure no one else touches the handle I guess..
14:52:42 <monochrom> That's why people switch to pipes or conduits. They are more disciplined.
14:53:46 <monochrom> More disciplined than exploiting the fragile interplay between evaluation and I/O.
14:54:00 <ab9rf> i've used conduits to very great advantage
14:54:22 <ab9rf> conduits have allowed me to write ETL applications that are easy to express, fast, and use very little memory
14:54:42 <hatds> monochrom: I wrote my program with enough discipline, only to find out the library wasn't :)
14:55:12 <orzo> i used to use conduits, but i felt like they were taking over my code
14:55:16 <orzo> heh
14:55:20 <ab9rf> orzo: yes, they do that
14:55:41 <ab9rf> orzo: they're good for what they're good for
14:55:46 <jared-w> orzo: do you use pipes now, then?
14:56:09 <orzo> jared, no
14:56:23 <orzo> i use TCHan and the like
14:56:28 <ab9rf> i haven't used pipes much; i needed a solution to a problem and i was able to figure out how to use conduits so i used conduits. pipes look to be another perfectly good solution to a similar set of problems
14:56:29 <orzo> IO/STM
14:57:01 <ab9rf> no library is a solution to every problem; you need to use the approach that solves your problem, not conform yhuor problem to someone else's solution
14:57:24 <orzo> i don't like the monad transformer style
14:57:49 <orzo> MonadIO smells bad
14:58:03 <sbrg> orzo: there are conduit "adapters" that let you stream things directly to and from tchans and the like
15:00:17 <monochrom> Another option is to still use hGetContents but give it to attoparsec
15:00:43 <orzo> whenever i see MonadIO, i suspect design bug
15:01:17 <monochrom> And you write a parser instead of thinking for yourself "when do I read 5 bytes now?"
15:01:33 <orzo> anyone else have that feeling regarding MonadIO?
15:01:39 <monochrom> And instead of attoparsec you may also choose binary.
15:02:01 <sbrg> orzo: no. why do you have it? There's nothing wrong with that pattern, even though it's not perfect. 
15:02:18 <sbrg> and since we can't just write pure code that doesn't interact with the outside world, things will need to happen in IO sometimes.
15:03:20 <orzo> i don't have a problem with IO
15:03:28 <orzo> I have a problem with MonadIO
15:03:40 <boj> what is the problem though?
15:04:10 <orzo> I see MonadIO, and I suspect Monad fever and some monad exists and likely offers no real benifit
15:04:20 <orzo> in fact, has costs
15:04:28 <orzo> design flexibility is hurt
15:05:30 <orzo> i've not really got solid arguments for my intuition, but i'm not really interested in counter arguments.  If i'm bigoted against MonadIO, so be it.
15:05:39 <boj> well then
15:05:57 <sbrg> what do you mean? If you see a function `foo :: MonadIO m => m ..`, the only thing that signature says is that `m` is a monad which can perform IO. If that is the case, then it most likely needs to perform IO. *shrug*
15:06:05 <orzo> i was more interested if someobdy else could provide me the solid arguments to back up my attitude
15:06:14 <sbrg> but of course, code that can be pure should preferably be kept pure, etc. 
15:06:23 <boj> sbrg summed it up well
15:07:26 <orzo> well, i'm not saying MonadIO can't be used effectively, i'm just saying it sets off my internal alarms
15:07:59 <orzo> if you have a monad that can do IO, then what else does it do?  Can IO do that?  If so, screw it.
15:08:52 <orzo> you guys never encounter pointless MonadIO instances?
15:09:33 <boj> do you have an example of one?
15:09:38 <sbrg> Well, the type signature of the function says that it can't perform anything other than IO.
15:09:56 <sbrg> but it also says that it can "run" in a monad that can do other things, as long as it can perform IO
15:10:06 <jle`> orzo: the thing is, when you say "encounter MonadIO", there are really two things you can mean
15:10:30 <jle`> or maybe several
15:10:35 <orzo> in the (mostly unmaintained) bittorrent package and it's related dependencies, there is a DHT monad and a monad class KRPCMonad that shouldn't exist
15:10:38 <jle`> that are completely different
15:11:01 <jle`> you might mean functions are polymorphic on all MonadIO in what they take
15:11:10 <jle`> you might mean functions that are polymorphic on all MonadIO in what they output
15:11:35 <jle`> we aren't really sure what you even mean
15:11:47 <jle`> or you might mean things that are actually instances of MonadIO
15:11:55 <jle`> but in those cases, they are MonadIO's whether or not their MonadIO instance exists or not
15:12:06 <orzo> i dont understand your question, jle`, by "encounter" i mean, in somebody elses's design, you see a MonadIO instance that you don't like and cannot see a justification for
15:12:12 <jle`> oh
15:12:21 <jle`> yes that's very different from waht we are all thinking of
15:12:42 <jle`> but that's sort of a weird  way of looking at types
15:12:46 <jle`> are you upset that that *type* exists?
15:12:52 <jle`> or are you upset that it exists *and* has a MonadIO instance?
15:13:16 <jle`> if it existed, and did not have a MOnadIO instance, would you not be as suspect?
15:13:19 <orzo> that it exists, i guess
15:13:27 <jle`> so you don't really have an issue with MonadIO the typeclass
15:13:30 <orzo> i'm not sure what a non-monadio version would be 
15:13:48 <jle`> you have an issue with types ... that have a MonadIO instance?
15:13:56 <phadej> instance MonadIO Proxy where liftIO _ = Proxy
15:14:03 <phadej> :P
15:14:18 * phadej doesn't have anything else to contribute in this discussion
15:14:19 <jle`> it's not exactly clear what design thing you're actually talking about
15:14:20 <sbrg> If you don't think that it should have a MonadIO instance, then I guess you think that the design should be "more modular" and the IO effects should be contained elsewhere? Of course, that is certainly possible, but that's probably a matter of design preference, etc. 
15:14:45 <jle`> do you have an issue with types that can sequence arbitrary IO actions...?
15:14:47 <orzo> no, i don't want MonadIO to vanish, but when i encounter code making use of it, i approach it with skepticism
15:15:02 <jle`> making use of MonadIO, as in making use of the typeclass?
15:15:14 <jle`> does the typeclass actually have anything to do with what you are skeptical of?
15:15:29 <jle`> if that type did not have a MonadIO instance, but instead offered an IO a -> Foo a, would that be better and non-skeptical?
15:15:29 <sbrg> I'm probably guilty of having written some code at some point where I realized "things would probably be easier if i could just perform IO in this monad.." and then just derived it with GNTD *shrug*
15:15:52 <jle`> do you have an issue with the MonadIO *typeclass*, or about types that can sequence arbitrary IO in them?
15:16:22 <orzo> uh
15:16:55 <jle`> i suspect you actually aren't talking about the typeclass at all
15:17:08 <jle`> but instead about the design pattern of having types that can sequence arbitrary IO
15:17:26 <jle`> but i could be wrong, since you started off with talking about MonadIO
15:17:54 <orzo> i'm talking about a design rule of thumb.  If you're thinking to use MonadIO, question whether the type should exist
15:18:09 <orzo> if it cannot be justified, it's not good
15:18:19 <jle`> what do you mean by "use MonadIO"
15:18:32 <orzo> instance MonadIO Foo
15:18:40 <orzo> does Foo need to exist?
15:18:41 <jle`> you mean, write an instance of MonadIO for your type
15:18:42 <orzo> justify it
15:18:50 <jle`> or do you mean write a type that could possibly be an instance of MonadIO
15:19:01 <orzo> eh
15:19:07 <orzo> i dont see how i'm being unclear
15:19:13 <phadej> orzo: you are
15:19:17 <jle`> you mean "use MonadIO", it could mean "use liftIO" 
15:19:18 <phadej> I have no idea what you talk about
15:19:19 <jle`> from a user standpoint
15:19:24 <geekosaur> there is a school of thought that thinks that an IOref is better than StateT IO
15:19:32 <boj> yeah, can't really tell what you are trying to drive home really
15:19:33 <orzo> in imperitive programming, if you use "goto", you should think twice
15:19:34 <jle`> like, a user imports your library, and you have a type that is an instance of MonadIO
15:19:44 <jle`> and i "use MonadIO" by using liftIO for your type
15:19:49 <orzo> if i see MonadIO, i think twicde
15:19:57 <geekosaur> it's slower, it is potentially visible in other thread/scomputations, but somehow it's preferable
15:19:58 <geekosaur> wat
15:20:22 <geekosaur> (then my type is usually a "type" not a "data")
15:20:29 <jle`> "using goto" has one meaning, but "seeing MonadIO" has several different potential meanings
15:20:38 <jle`> and like i said, even "use MonadIO" can mean completely different things
15:20:44 <jle`> it could mean, as a user, using a MonadIO instance of a type
15:20:53 <jle`> it could mean, as an application developer, writing a a MonadIO instance for your types
15:20:56 <jle`> *as a library developer
15:21:03 <geekosaur> aside from that school of thought, what you are complaining about is unclear
15:21:14 <geekosaur> aside from "MonadIO bad, bad!"
15:21:29 <geekosaur> which as a general statement is, at best, unproven
15:21:31 <jle`> it could mean, as a library developer, writing a type that is also incidentally a potential MonadIO instance
15:21:34 <phadej> fwiw there will be MonadIO Q in next template-haskell \o/
15:21:52 <jle`> it could mean, as a library developer, desiging your API around a type that that supports an IO a -> Foo a
15:22:13 <orzo> how about this.  You implement MonadIO, and then it turns out you didn't provide MonadBaseControl, and you need to provide it
15:22:13 <jle`> it could mean, as a user, using values of type (forall m. MonadIO m => m a)
15:22:35 <tesan> Without trying to start a war... which tk do/would you use to make a gui for a haskell desktop application?
15:22:38 <orzo> if you instead of instancing MonadIO, simply use IO directly, not gonna happen
15:23:05 <jle`> i'm not sure how to understand that last sentence :|
15:23:07 <jle`> is it missing a word?
15:23:07 <orzo> if you did not use IO directly, WHY?  stop and ask the question.  That's all i'm saying
15:23:13 <Zowlyfon> tesan: I used GI.Gtk
15:23:22 <phadej> orzo: not all MonadIO instancs are newtype Foo a = Foo { runFoo :: IO a }
15:23:32 <jle`> who is "you"; the application developer and the user of a library, or "you" as in the person writing a library?
15:23:52 <phadej> MonadBaseControl is something unclear to me
15:23:59 <phadej> whether it's good design or not
15:24:04 <jle`> and by "use", do you mean use as an output of your function, or as an input of your function?
15:24:16 <tesan> Zowlyfon: Thank you. PS:  Is it trivial to use that library or nerve wrecking?
15:24:24 <jle`> because yes if you have a function that just does IO, you could just write foo :: a -> IO a
15:24:28 <Zowlyfon> I didn't have too much trouble
15:24:30 <jle`> or foo :: X -> IO B
15:24:38 <orzo> phadej: thats true, a lot of them are ways to use global state that gets carried aroiund throught your program
15:24:45 <Zowlyfon> I was using it with reactive banana
15:24:45 <orzo> like global variables
15:24:56 <orzo> but if i said i distrusted global variables, people wouldn't be giving me a hard time
15:25:06 <jle`> yes becuase people would know what you mean
15:25:09 <jle`> we aren't giving you a hard time about your viewpoint
15:25:15 <jle`> we just don't understand what your viewpoint is
15:26:01 <phadej> geekosaur: btw, ReaderT (IORef x) IO is nice with MonadControl. i.e. if you use lifted-async
15:26:08 <phadej> and one can discuss about *that*
15:26:15 <jle`> "if you instead of instancing MonadIO, simply use IO directly, not gonna happen"
15:26:15 <phadej> whether that' good thing or not
15:26:23 <jle`> i'm not sure if anyone here could understand that sentence
15:26:25 <orzo> if you design uses globals, think twice before implementing MonadIO and blindly carying on with the attitude that you don't actually have globals
15:26:45 <jared-w> To be honest, it seems more to me that you don't quite understand MonadIO since you can't give any clear reasons for it or really address any of the nuances jle` is mentioning. I'm not accusing you of not understanding MonadIO, I'm just saying that's how it's coming across
15:27:01 <ab9rf> i don't understand why you'd object to MonadIO
15:27:08 <geekosaur> phadej, yes, scoped IORef like that is nice for threads. the mentality I was tallking about is "you have IORef, you don't need either StateT or ReaderT"
15:27:17 <jle`> i don't understand what about MonadIO you are objecting to
15:27:18 <geekosaur> which may be the mentality orzo is talking about...
15:27:29 <jared-w> orzo: which 'you'? Also, what about MonadIO makes you equate it with globals? And are you equating it in the library, or in the application or what?
15:27:34 <geekosaur> but it's not the usual use case
15:27:47 <ab9rf> MonadIO is just a typeclass of which IO is the only standard instance
15:28:00 <geekosaur> and in fact I think most Haskell programmers reject the argument that having IO access makes StateT/ReaderT unnecessary
15:28:04 <orzo> ab9rf: do you understand why i would object to global vairables?  Do you see how a MonadIO instance that takes over all your code and holds a state with it is the same damn thing even if it's technically not a global variable?
15:28:08 <jle`> maybe it would help if you showed a specific situation, with code, demonstrating shady things
15:28:17 <ab9rf> orzo: i don't agree with that argument.
15:28:43 <ab9rf> what you're just describing is undisciplined coding
15:28:48 <jle`> orzo: hm, ok, it looks like you don't actually object to the MonadIO typeclass, but rather to monadic API's that allow you to sequence arbitrary IO
15:28:59 <jle`> which is possible with or without the MonadIO typeclass
15:29:06 <orzo> i gave a specific situation when sbrg asked, i pointed you to the bittorrent package and their DHT monad
15:29:21 <jle`> and yes, i am suspicious of that as well
15:29:23 <jle`> many people are
15:29:37 <geekosaur> (again, an IORef in a ReaderT is not the same thing, it's needed when synchronizing data across FFI callbacks for instance. and sometimes for threads although there are better solutions to that one usually)
15:29:39 <jle`> that's one of the reasons why there's been a big surge in interest of free/operational in the past couple of years
15:29:54 <jle`> to address that very concern
15:30:10 <ab9rf> orzo: it's lazy coding to casually allow IO injection into all of your code, but MonadIO isn't what leads to that
15:31:19 <ab9rf> all MonadIO is a typeclass that allows for other monads that implement the same interface as the standard IO instance, but don't necessarily operate in the same way
15:31:54 <ab9rf> IO is a black box anyway, so this is just genericism
15:32:10 <orzo> shrug
15:32:24 <orzo> you guys think i dont undersand what IO is or what MonadIO is
15:32:32 <orzo> which is silly
15:32:34 <jared-w> orzo: would you prefer something like the Eff language--dealing with "IO" in a more segregated and principled manner?
15:32:35 <ab9rf> orzo: that is a reasonable conclusion :)
15:32:48 <jle`> from what i gather from your examples and what you actually say, you are suspicious of API's that let you sequence arbitrary IO actions within them, which is a common sentiment, actually
15:32:57 <orzo> yes, jle
15:32:57 <ab9rf> orzo: i don't understand why you'd object to MonadIO but not to IO 
15:33:08 <jle`> orzo: i don't think you don't understand what IO or MonadIO are.  i just had trouble understand what aspect of them you were skeptical of
15:33:15 <orzo> i see ReaderT/MonadIO used together in bad ways
15:33:24 <jle`> but i see now
15:33:45 <jle`> i think your issue really isn't with MonadIO at all, but with that arbitrary-io-action design pattern for api's
15:33:46 <ab9rf> so you object to undisciplined coding. blame the programmer, not the tools.
15:34:06 <jle`> well, i mean,  this is a valid concern
15:34:07 <orzo> eh
15:34:17 <jle`> ab9rf: that's not the haskell way
15:34:18 <ab9rf> the imperative style is strong with most programmers
15:34:21 <hoc> Orzo What did you mean by "globals"
15:34:23 <jle`> the haskell way is to blame the tools, not the programmer
15:34:25 <ab9rf> jle`: i suppose
15:34:27 <jle`> :p
15:34:32 <jared-w> orzo: but those types of APIs have nothing to do with MonadIO, specifically. It's like getting mad at Foldable because it makes everything have a toList function and 'lists are bad'
15:34:38 <jle`> the haskell way is to provide your tools in such a way that the programmer can't do anything wrong
15:34:45 <orzo> hoc, globals are things used by any function aywhere that are not represented in the functions type
15:34:55 <ab9rf> jle`: i have a suspicion that that's impossible :)
15:35:18 <orzo> hoc, a monad can hide specific state from the type even though it's technically "represented"
15:35:22 <jle`> it might be impossible completely, but it's the guiding principle behind the development of all haskell tools
15:35:28 <jle`> and the haskell design philosophy
15:35:50 <jle`> that's sort of...the main point about using haskell in the first place, heh
15:36:01 <jle`> and yes, offering a type that can sequence arbitrary IO is a huuuuuuge red flag
15:36:40 <ab9rf> i have seen people do things with MVars that make me twitch
15:36:59 <ab9rf> and, yes, it is very possible to abuse IO to recreate globals
15:37:48 <hoc> Ok, that all makes sense now. I thought it might be an alternate usage 
15:37:56 <ab9rf> i'm reminded of an argument i got into with a java programmer over how the singleton antipattern is always wrong
15:38:05 <orzo> once you have a ReaderT/MonadIO everhwere, it's trivial to add one more field to your ReaderT state, and over time you end up with a monlithic state object
15:38:29 <ab9rf> orzo: i avoid that by not having ReaderT or IO/MonadIO everywhere
15:38:50 <ab9rf> yhou can certainly write Haskell code in which everything is embedded in IO
15:39:03 <AlainODea> ab9rf: I'm doing terrible things with MVars like that now :D https://gist.github.com/AlainODea/3d7990371efa55b6b368a7c6dafda30a#file-ex1_strawhouse_cgnu_edition-hs
15:39:04 <ab9rf> you can write totally imperative haskell if you like
15:39:15 <jared-w> ab9rf: Were you of the opinion that it was always wrong or not? Just curious
15:39:33 <ab9rf> jared-w: with extremely limited exceptions, i'm of the opinion that it's always wrong
15:40:03 <ab9rf> jared-w: and the exceptions really only deal with limitations of the underlying architecture
15:40:11 <orzo> i dont consider singleton always wrong
15:41:15 <Tuplanolla> Is time part of the architecture, ab9rf?
15:41:34 <ab9rf> orzo: but singletons are just global variables wrapped in cheese.
15:41:35 <jared-w> Same. There's enough diversity in programs and needs that it's pretty much impossible for /something/ to /never/ be the right choice. That being said, I'd try litreally everything else in the book before I resorted to singletons :p
15:42:02 <orzo> ab9rf: right, but i dont even consider global variables always wrong.  I merely treat them skeptically and think twice.  There's a differencde
15:42:33 <ab9rf> https://www.quora.com/Fast-forward-into-modern-times-Are-goto-statements-and-global-variables-still-that-bad/answer/Kelly-Kinkade-1
15:46:15 * hackagebot madlang 2.4.0.2 – Randomized templating language DSL – https://hackage.haskell.org/package/madlang
15:46:24 <AlainODea> Haskell is a exceptionally good imperative language. I think embracing that is good for commercial adoption
15:46:25 <orzo> there's a minor cost to allowing multiple instancdes too though.  If such a use is really really unlikely, then it's can be silly to disign for.  For example, take the objective-c runtime inspector.  Should they make you specifiy which objective-c runtime you are inspecting whenever you use it?
15:47:33 <orzo> or if haskell were IO, would we not use singleton for the garbage collector object?
15:47:40 <orzo> er,s/IO/OOP
15:48:14 <orzo> its not really very hard in practice to encounter justifiable Singleton instances
15:48:34 <mniip> orzo, not having it as a global variable would allow for easy cross-inspection support
15:49:26 <ab9rf> i can think of situations where yhou might want multiple garbage collectors.
15:49:39 <ab9rf> or even multiple indpendent memory managers
15:49:45 <orzo> mniip: singleton is easily changed to a reference to a "current" object, and any code that actually uses multiple could recognize there are others but "current"
15:50:18 <ab9rf> orzo: and then anybody who wants to use an alternative has to have functionality for saving the current state and switching it
15:50:24 <ab9rf> that's WAY worse
15:50:38 <AlainODea> ab9rf: Erlang has an interesting use of multiple GCs for greenthread/process isolation within a single OS process
15:50:43 <orzo> not really, you would have another interface besides singlton for the new code
15:50:51 <ab9rf> orzo: bleah
15:50:57 <ab9rf> orzo: now you're multiplying APIs
15:51:04 <orzo> lol
15:51:07 <AlainODea> I think it did something with separate heaps (mem mgrs) too
15:51:11 <orzo> for an unlikely scenario
15:51:45 <orzo> what if your object represents the actual system's memory use?  Singleton?
15:51:46 <tesan> What did I just read?
15:51:59 <tesan> "Haskell is an exceptionally good imperative language"????
15:52:06 <orzo> it is
15:52:08 <ab9rf> tesan: it is :)
15:52:08 <tesan> AlainOdea: Please explain yourself
15:52:27 <tesan> Isn't declarative the antonym from imperative?
15:52:56 <ab9rf> orzo: what if your application runs on multiple systems simultaneously?
15:53:28 <AlainODea> tesan: it's a callout to a talk by Simon Peyton-Jones ages ago where he said that upon integrating Monad and monadic do syntax they'd made Haskell the finest imperative language or something to that effect
15:53:53 <orzo> ab9rf: that likely incurs more burden on your up-front design than merely deciding not to use singleton.  If you aren't going to bother with it, don't bother with it.
15:54:33 <tesan> AlainOdea: Ohh okay, thanks.
15:54:38 <orzo> OOP is supposed to make it easy ot reuse code, not make it so that any code you write can be used for every purpose ever
15:55:13 <tesan> orzo: But even then, traditional haskell code is also extremely reusable, right?
15:55:16 <AlainODea> tesan: no problem :)
15:55:57 <orzo> tesan: haskell i think emphasizes reusability less, i think it is more about adapting and hacking code to new purposes
15:56:03 <orzo> rather than reusing black boxes
15:56:24 <Zowlyfon> I don't think hacking is the right word
15:56:58 <aijony> tesan: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/07/mark.pdf page 3
15:57:17 <orzo> OOP assumes you wont be reading the code your using, haskell assumes you likely will
15:57:22 <orzo> heh
15:57:30 <jared-w> can someone ping my name really quick?
15:57:34 <Zowlyfon> jared-w: 
15:57:35 <tesan> orzo: So you mean, instead of using or importing, in haskell you copy paste the original file and change it?
15:57:59 <jared-w> Sweet, thanks. I was hoping that would work ¯\_(ツ)_/¯
15:57:59 <orzo> tesan: i certainly copy paste in haskell more so than i did in c++
15:58:10 <Zowlyfon> I don't copy and paste that much
15:58:20 <orzo> tesan: although, importing is still more often than copy/pasting overall
15:58:29 <tesan> orzo: Sounds like a bad thing, almost.
15:58:30 <Zowlyfon> Mainly because its not that easy on vim :P
15:59:27 <orzo> haskell is more pastable than c++ because its easier to isolate code bits 
15:59:44 <tesan> aijony: Reading that pdf right no
16:00:05 <jle`> tesan: when we say haskell is a good imperative language, we mean that haskell is a good language for doing imperative programming
16:00:16 <jle`> which it is :)
16:00:21 <jle`> the type system helps you a lot
16:00:24 <orzo> sometimes i prefer taking the package off of hackage and puting the files in my tree instead of importing because i know the upstream is unmaintained and i want to feel free to hack around 
16:00:27 <tesan> orzo: Ohh, now I see.
16:00:28 <jle`> you get all of the maintainability benefits
16:00:49 <jle`> well, many of them, at least
16:01:17 <tesan> jle: Thanks, and sorry. I barely coded anything in haskell yet so I I'm quite ignorant to most facts.
16:01:28 <dmwit> For what it's worth, you don't need to treat orzo's experience as necessarily typical. 
16:01:30 <jle`> no need to say sorry haha
16:01:48 <jle`> tesan: if i need to write an imperative algorithm, i'd rather write it in haskell than anything else
16:01:57 <jle`> just because of the type system and maintainability and safety guaruntees
16:02:05 <dmwit> I for one thoroughly enjoy avoiding copying code by adding a dependency instead.
16:02:16 <jle`> i...never copy and paste code in haskell, heh
16:02:54 <ab9rf> almost invariably, when I've come to the conclusion "I'll never need to support an alternative source of X" i've ended up needing to support an alternative source of X
16:03:01 <monochrom> It is possible to enjoy both copying code and adding dependencies. :)
16:03:38 <tesan> jle: I am fascinated by the ideas Haskell has to offer, and I would like to learn how to do some haskell programming before I get tinte by the computer science related degree I join in one month
16:03:45 <dmwit> There you have it. Four people and three different stances on the matter.
16:03:45 <tesan> tainted*
16:03:59 <ab9rf> dmwit: only three? there should be at least five.
16:04:00 <dmwit> Probably if you ask me again after I've forgotten what I just said you'll get a fourth stance.
16:04:08 <sbrg> tesan: chances are you will touch upon some functional programming during your degree. 
16:04:20 <monochrom> Now just need a mathematician to declare "I hate code".
16:04:20 <sbrg> at any rate, it's never a bad idea to get ahead :)
16:04:26 <dmwit> ab9rf: There's sort of a Murphy's Law in the offing. "Anything that can vary, will."
16:04:40 <ab9rf> monochrom: i'm not a mathematician, but i'll declare that i hate code just for completeness.
16:04:47 <Zowlyfon> tesan: what language does your comp sci degree use if any?
16:04:47 <monochrom> \∩/
16:04:53 <AlainODea> tesan: http://haskellbook.com/ is really good. I really benefited from it after many years of floundering
16:05:13 <tesan> sbrg: Surely, but for probably just an hour. Mine is specialized on IoT so I am unsure if they like Haskell.
16:05:25 <nisstyre> does anyone have a really good use for delimited continuations?
16:05:31 <nisstyre> just wondering
16:05:39 <codeshot> I've got a generic function "projections" that returns an (Alternative a), what functions 'f' are there so I can do (f . projections) to get a version that returns a ([a]), or (Maybe a), or various other interesting instances of Alternative?
16:05:48 <sbrg> aah. well, FWIW, I don't think the Haskell ARM story is completely miserable these days. so you might be able to do some haskell programming on some IoT devices :)
16:05:59 <codeshot> Any other way in the ghci REPL where I don't have to state the "a" variable?
16:06:12 <tesan> Zowlyfon: It's a totally new degree that I am joining so they didn't release much info. As far as I know, first year will be C/c++ programming principles and web technology (html, css js). Python is seen on one of their teaser pics .etc
16:06:27 <Zowlyfon> They said we could use any language for the final project for last year, so I chose Haskell
16:06:34 <codeshot> It should be really handy to type - no long "let {type annotation; etc...}"
16:06:40 <tesan> AlainODea: Thank you, I will bookmark it right away
16:07:05 <AlainODea> tesan: my pleasure :)
16:07:21 <AlainODea> codeshot: projections :: Type is not working or is it something else?
16:07:40 <sbrg> codeshot: you just ask it for the type
16:07:48 <tesan> sbrg: That would be really nice. Though... the gc does not get in the way on IoT, does it?
16:07:49 <sbrg> foo :: [Int] .. foo :: Maybe Int
16:08:13 <sbrg> tesan: it probably can, but it depends on what you're doing and how constrained the resources are. 
16:08:27 <codeshot> projections :: [a] isn't working
16:08:44 <codeshot> I don't want to type the full 'a' bit so I want to leave it to be deduced
16:08:46 <AlainODea> codeshot: a isn't a type. Try projections :: [Int]
16:08:54 <codeshot> as above
16:09:00 <codeshot> I don't want to type the full 'a' bit so I want to leave it to be deduced
16:09:20 <codeshot> I need the general technique so even large type signatures are practical
16:09:21 <sbrg> codeshot: you can write helper functions, I guess
16:09:23 <AlainODea> Oh. You'll need to use it in a way that GHC can deduce. It's not psychic :)
16:09:24 <centril> hmm... what is the point of zero param type classes now again? I can't find much info on it on the webz...
16:09:33 <codeshot> GHC can deduce
16:09:35 <centril> as in: class Partial where ;
16:09:44 <AlainODea> gotta jet. Time to hit the road
16:09:44 <codeshot> I think
16:09:51 <codeshot> ... yeah it can
16:10:15 <codeshot> it deduces in a module where this is used with "join $ projections"
16:10:40 <codeshot> that forces it to be a list
16:10:41 <tesan> AlainODea:   :c  Time for me to save up some money for that book. Funny, I want to program to make a living off of it, but I need money to learn it first.
16:10:50 <codeshot> but also isn't an identity
16:11:07 <ggVGc> making money from haskell program requires a lot more than being able to program :)
16:11:16 <orzo> another thought: haskell libraries, over the years, have been less stable than c++ libraries, so dependencies are sometimes less maintainable rather than more than pastes
16:11:18 <ggVGc> I think landing a haskell job is at least 70% luck
16:11:46 <orzo> not that that's a good thing
16:11:48 <orzo> heh
16:12:00 <codeshot> ah this is ok: (id :: [a] -> [a]) $ projections
16:12:06 <tesan> For my luck, I am in a zone where there aren't any great programmers... let's say, these people here are like uncivilized. I could make my own business
16:12:16 <codeshot> reasonable solution found
16:12:43 <tesan> ggVGc: Forgot to tag you to be able to read my previous post.
16:12:57 <ggVGc> tesan: unfortunately starting your own business requires customers and doesn't depend so much on the quality of the programmers around you
16:13:51 <codeshot> even better: type Force a = a -> a; force = id; (force :: [a]) $ projections
16:14:04 <codeshot> I mean: type Force a = a -> a; force = id; (force :: Force [a]) $ projections
16:14:16 <tesan> ggVGc: Well, I know some businessmen who are in queue to get some proper stuff done. One wants to get a private management page for tournaments. Haskell + Yesod would help his business, wouldn't it?
16:14:52 <codeshot> I'm loving Alternative and Applicative!
16:14:53 <tesan> Right... Yesod is still actively in use, yes?
16:15:02 <sbrg> codeshot: yeah, useful abstractions
16:15:27 <ggVGc> tesan: sounds good
16:15:33 <ggVGc> good luck!
16:15:52 <ggVGc> I've been freelancing for several years, but I haven't been able to sneak in haskell or anything else fun in my work yet
16:15:55 <tesan> Some of the documentation for Haskell looks like it comes straight from the permian era :|  Like some of the "popular" modules who apparently are in disuse already while the website claims otherwise.
16:16:08 <codeshot> Now I can specify a set of alternative possible transforms, compose them, and apply them with any choice of search and fail policy
16:16:27 <codeshot> soooo good
16:16:27 <tesan> ggVGc: Why not? Does someone control what you use in your programs or was haskell just not good for the task?
16:16:29 <centril> codeshot: If you apply yourself you will never have to return!
16:16:37 <codeshot> haha
16:16:53 <centril> tesan: documentation?! you have types... what more do you need?!
16:16:59 <ggVGc> tesan: because when working for clients I can't just throw in what I'd like
16:17:08 <ggVGc> there are many other responsibilities
16:17:15 <ggVGc> and also most of my work is dealing with existing systems
16:17:18 <ggVGc> and fixing broken shit
16:17:22 <ggVGc> or maintaining it
16:18:05 <tesan> ggVGc: I feared so already. It looks very dreadful to me.
16:19:05 * hackagebot brainheck 0.1.0.4 – Brainh*ck interpreter in haskell – https://hackage.haskell.org/package/brainheck
16:19:05 * hackagebot wolf 0.3.26 – Amazon Simple Workflow Service Wrapper. – https://hackage.haskell.org/package/wolf
16:19:16 <tesan> Btw, has this "bonus" person who wrote learnyouahaskell been here recently?
16:19:31 <codeshot> I've decided to define these handy operators: -.- -.^ ^.- ^.^ and also for -*-, -$-
16:19:55 <codeshot> oh not -$-, -|- instead
16:20:03 <Zowlyfon> codeshot: anyone who didn't know haskell would think they were smily faces
16:20:20 <tesan> Zowlyfon: Err... I was about to say that.
16:20:22 <codeshot> because haskell makes you happy :)
16:20:41 <codeshot> applicative composition, application and alternatives, where - means the arg on that side is already applicative or alternative and ^ means to apply pure first
16:20:48 <tesan> Zowlyfon: Do they have an actual use in Haskell? ^^;  [not an operator right here]
16:21:09 <Zowlyfon> tesan: codeshot said he made them
16:21:14 <codeshot> so you can do: id ^|^ map foo -|^ fn -|- somebigalternative
16:21:41 <tesan> Zowlyfon: Ohh okay that explains everything.
16:21:44 <codeshot> instead of (pure id) <|> (pure (map foo)) <|> ... blah
16:21:45 <boj> pretty sure edwardk was watching anime when he wrote linear
16:21:49 <cobreadmonster> How do you do numerics in Haskell?
16:21:51 <codeshot> so much faff removed
16:22:17 <codeshot> I have to see what happens with the associativity
16:22:24 <codeshot> I forgot about that :(
16:22:31 <cobreadmonster> Is there any guiding wisdom?
16:23:21 <parsnip> is `rm -rf ~/.stack` a decent way to test installation speed?
16:24:02 <centril> boj: the other time he was inspired by lens law
16:24:06 <codeshot> operator associativity is annoying
16:24:29 <MarcelineVQ> parsnip: probably, be sure to run stack update and/or stack setup if you don't want hacakge and ghc setup time to count
16:24:54 <centril> codeshot: sue them - operators deserve to choose left or right for themselves - freedom of association you know!
16:25:06 <codeshot> hooray!
16:25:20 <orzo> can TypeApplications give me a better syntax for (Proxy :: Proxy t)?  I know it can be used to pass t to a polymorphic function, but sometimes the function takes a proxy already and i just want a short-hand for making the proxy
16:25:48 <orzo> maybe (Proxy @t) ?
16:25:49 <parsnip> hmm, yeah maybe next time i won't delete the ghc, i don't think i have any toggles that could speed that up. would `docker:\n  enable: true` effect `stack setup`?
16:26:12 <MarcelineVQ> dunno anything about docker
16:26:41 <jared-w> Docker is awesome
16:26:53 <codeshot> is there any way to denote a custom notation to apply pure without all the visual noise of all nested and nested parentheses ? like template haskell: $[p|map reverse|]
16:27:01 <codeshot> somethig like that?
16:27:02 <MarcelineVQ> if you only care about dependency build timings deleting your ~./stack/snapshots should be all you need
16:27:05 <centril> orzo: should work - but... be wary of TypeApplications in general (especially when you have more than 1 parameter...) because switching the order of the parameters would screw shit up
16:27:34 <centril> codeshot: got example of some noise?
16:27:41 <jared-w> parsnip: what are you trying to do with docker?
16:28:20 <parsnip> jared-w: speed up haskell installs
16:28:57 <MarcelineVQ> speed up? why are you deleting stack things then :X
16:29:07 <jared-w> parsnip: https://gist.githubusercontent.com/psftw/74e310e911d83518af37958912ca5090/raw/253ef3c4fa8e23fc5080d731f2827ad0a85448d9/gistfile1.txt does this help at all?
16:29:29 <codeshot> (pure id <|> pure (map reverse)) <.> (pure id <|> pure transpose) <.> (pure id <|> pure othertransform)   vs  ($[p|id] <|> $[p|map reverse]) <.> ($[p|id] <|> $[p|transpose]) <.> etc
16:29:29 <parsnip> MarcelineVQ: iterate to see what installs are fastest ;)
16:29:48 <jared-w> MarcelineVQ: because docker is a container so it's a VM that's spun up on command. Ideally you want to mount some 'saved stable state' to the docker container so you don't have to download the whole world and build everything from scratch every time
16:30:14 <jared-w> Then you want to cache as much as possible without losing "idempotency"
16:30:28 <codeshot> The different brackets look much neater because the real grouping uses on style and the $[p|] can be highlighet in a different colour
16:30:48 <duncan^> it's technically not  a VM
16:30:56 <tesan> What do people here think of the functional package manager from NixOS?
16:30:58 <duncan^> it shares the same kernel
16:31:04 <duncan^> as the host
16:31:08 <duncan^> and more
16:31:25 <jared-w> right, it's not; that's just my default way to explain it to people. I forget I'm talking to technical people sometimes since this is #haskell and not, say, #sysadmin :p
16:31:27 <codeshot> I'd prefer even less 
16:31:28 <centril> codeshot: i'd define a function that does   stuff f = pure id <|> pure f   first
16:31:39 <duncan^> it's like a fancy chroot, so it's trivial to break out of
16:31:51 <Zowlyfon> jared-w: I was going to say that but decided not to
16:32:06 <codeshot> but then you are limited to two and you lose the impact of the <|> notation
16:32:06 <Zowlyfon> jared-w: I'm not a huge fan of docker
16:32:20 <codeshot> so you can't have a nice table-like layout, etc
16:32:23 <jared-w> Zowlyfon: why not?
16:32:34 <centril> codeshot: yes, but you have 3 identical cases
16:32:37 <Zowlyfon> I prefer FreeBSD Jails and lxc
16:32:39 <parsnip> is coreos' rkt safer?
16:32:51 <codeshot> for the moment
16:33:06 <centril> codeshot:  stuff (map reverse) <.> stuff transpose <.> stuff othertransform
16:33:09 <codeshot> but the future is full of many more things than these few minutes where I write it
16:33:14 <jared-w> I think it gets used a little too liberally for "all the things" but it's still a solid solution for what it's made for. It's also more cross-platform than Jails and lxc :p
16:33:27 <codeshot> Is there a way to define a pre or postfix operator ?
16:33:35 <jared-w> Zowlyfon: although Jails and lxc do look pretty awesome, from what I've heard about them
16:33:37 <codeshot> so I can do ^^id, etc ?
16:34:00 <codeshot> that would be so pleasant to work with
16:34:18 <Zowlyfon> jared-w: I mean for just running an application with seperation docker is probably easier
16:34:24 <Zowlyfon> but Jails and lxc seem more powerful
16:34:33 <centril> codeshot: you can make any binary operator prefix by wrapping it in parenthesis,  a + b == (+) a b
16:34:38 <boj> Zowlyfon: yep, that sums it up really
16:35:03 <boj> path of least resistance has everyone using docker
16:35:06 <codeshot> a unary prefix operator
16:35:17 <Zowlyfon> boj: also marketing
16:35:18 <jared-w> Right :p but the main purpose of Docker (that I've seen so far) is really to just have a very reliable and /consistent/ setup of an application in order to get rid of "it works on my machine" and "I don't remember how I set this up because it was never written down" type of bugs
16:35:21 <boj> agreed
16:35:43 <jared-w> the separation really doesn't seem to be /that/ important compared to the rest of the stuff, honestly
16:35:46 <tesan> Jails is built-in, default on freeBSD, yes?
16:35:55 <centril> codeshot: https://mail.haskell.org/pipermail/haskell-cafe/2007-September/031544.html
16:35:55 <Zowlyfon> tesan: I think it only works with ZFS installs
16:35:58 <Zowlyfon> might be wrong
16:36:05 <Zowlyfon> but i think it uses ZFS itself to do stuff
16:36:13 <centril> codeshot: https://stackoverflow.com/questions/3406320/prefix-form-of-unary-operator-in-haskell
16:36:14 <parsnip> jared-w: hmm, interesting, trying out, thank you
16:36:21 <boj> zfs doesn't apply to jails, just makes managing them easier
16:36:29 <geekosaur> ^
16:36:37 <Zowlyfon> tesan: You might have to enable a few options, and wrappers like ezjails make life easier
16:36:41 <geekosaur> there's a jail manager that relies on zfs, but jails themselves do not
16:36:52 <Zowlyfon> geekosaur: ahh
16:36:57 <jared-w> ZFS is awesome for that, though; it and things like btrfs make stuff way easier. It's like having version control baked into your entire file system
16:37:14 <Zowlyfon> jared-w: last time I used btrfs my entire system corrupted
16:37:23 <tesan> Surely it may come in handy for my future IoT devices
16:37:26 <boj> i love freebsd/jails, but linux/docker has kind of won that game :(
16:37:52 * johnw 's off-topic bat signal is shining
16:37:56 <jared-w> parsnip: no problem. I just googled 'docker cache haskell stack' and looked at the first link :p
16:38:01 <tesan> boj: Because a vast majority of programmers is more familiar with docker, and docker being like more announced than jails?
16:38:14 <jared-w> Zowlyfon: that's a shame :( it's been rock solid for me ever since I started using it a few years ago ¯\_(ツ)_/¯
16:38:41 <boj> tesan: as Zowlyfon said, marketing. and johnw is right, tad bit offtopic. i'll stop here
16:38:55 * johnw hugs boj
16:39:09 <jared-w> tesan: I'd say docker's marketing played a huge part. The other /major/ thing that nobody really talks about is that docker is more cross-platform than most stuff out there. That doesn't matter to a lot of people, but the big companies and corporate backing care a lot about it. In turn, that trickles down and developers tend to use stuff they already know from work
16:39:27 <jared-w> (but yeah I'll shush now since I've gone way OT)
16:39:36 <Zowlyfon> johnw: oops, sorry
16:40:16 <tesan> Yeah thanks, it's nice to get some experience from people who have been longer in the business.
16:40:21 <mibaz_1> Is there a way to lint for partial functions?
16:40:39 <jared-w> mibaz_1: hlint will check for that. I believe intero will as well
16:41:33 <jared-w> (and most other dev tools will as well iirc. Case checking is standard bread and butter for most haskell tools)
16:43:59 <mibaz_1> jared-w: thanks, I'll check hlint again
16:45:13 <mibaz_1> On the topic of domains, is LiquidHaskell generally used and liked?
16:46:12 <jared-w> It went through some drama a few years ago, I think, but it seems like a solid presence in the community now. I wouldn't say it's used very pervasively, but that's only because people tend to not really need refinement types much in how Haskell is usually designed
16:46:49 <centril> apparently LiquidHaskell is not very liked at Chalmers
16:47:24 <Squarism> I have a type "MyType a b". How can i invoke "TH.Syntax.reify" on a?
16:47:24 <johnw> mibaz_1: I like LiquidHaskell, but I haven't used it much yet
16:47:41 <johnw> Squarism: do you mean, on a particular type like MyType Int Float?
16:47:58 <johnw> if you reify the type (of kind *), you can access the arguments from the TyCon
16:48:09 <mibaz_1> centril: Why's that?
16:48:28 <Squarism> johnw, Oh.. sorry. No on a VALUE of type "MyType a b"
16:48:36 <centril> mibaz_1: don't remember exactly, just remember that it wasn't liked... they have a competing project or something
16:48:38 <mibaz_1> jared-w: Ok, good to know. Wouldn't want to learn something not used.
16:49:05 <johnw> Squarism: either way, if you examine the type of the value, you can access the type constructor arguments
16:49:09 <jared-w> mibaz_1: you might look at the HSOC project dedicated to proving the base with liquid haskell. They kinda went off track into a research project, but it's still chugging along
16:49:19 <centril> I prefer well integrated dependent types instead
16:49:38 <mibaz_1> I was going to say, won't dependent haskell replace liquidhaskell?
16:49:48 <Squarism> johnw, examine? 
16:49:53 <mibaz_1> dependent types were the first thing i thought of when reading the documentation
16:50:05 <centril> mibaz_1: dependent haskell won't deal with totality
16:50:11 <centril> but partially, yes.
16:50:21 <jared-w> mibaz_1: no. Dependent types are dependent types; liquid haskell provides refinement types
16:50:39 <mibaz_1> centril: I just meant on the matter of restricting function domain to ease the construction of total functions
16:50:52 <centril> mibaz_1: yea
16:50:55 <Squarism> johnw, Im quite new to TH so im not at all fluent in it =D
16:51:02 <johnw> Squarism: using lookupValueName, then reify that name, then get the DataConI, then lookup the type from that name (1st arg).  I think, not trying to code it right now.
16:51:21 <johnw> oh no, just the Type (2nd arg of DataConI)
16:52:06 <mibaz_1> I think I'll wait it out for dependent types, then. 
16:52:29 <centril> mibaz_1: it could take some time
16:52:35 <centril> mibaz_1: meanwhile... thought about Idris?
16:52:48 <johnw> and just having dependent types isn't what you want; you also want feature that make dependent pattern matching convenient to use
16:53:18 <johnw> Coq has full blown dependent types, but they can be a pain to program with.  Agda is much better at this.
16:53:23 <centril> johnw: well yes - dependent types that are ergonomic - as with any feature
16:53:39 <centril> johnw: agreed on Agda & Coq
16:53:52 <mibaz_1> centril: in the year 2050 I will get down with some sweet haskell dependent typing
16:54:02 <centril> mibaz_1: OK; not that long
16:54:15 <johnw> even though I choose to do all of my dependently-typed programming in Coq, mind you. It's better enough at other things for what I'm doing.
16:54:17 <mibaz_1> centril: I was thinking about learning a dependent language out of curiousity
16:54:24 <mibaz_1> so yeah I have considered it
16:54:45 <centril> mibaz_1: in the year 2050, ASI has killed us all, if not some other armageddon before that
16:54:50 <mbw> Is it ok to ask a question I asked on #haskell-lens here as well? Do some fanning out so to say
16:55:00 <mibaz_1> johnw: just as an observer, coq syntax does look horrible.
16:55:02 <MarcelineVQ> mbw: yes
16:55:05 <centril> mbw: shoot
16:55:11 <mbw> Say I have (mt :: Maybe Text) and want to turn it into a Maybe Int using (Prelude.read :: String -> Int) (I know I can just use the functions from Data.Text...). However, mt & each.unpacked %~ (read :: String -> Int) does not work, since in this case read is required to be monomorphic (String -> String) and the overall result is of type Maybe Text again. Why is this the intended behavior, and how can I make 
16:55:17 <johnw> mibaz_1: the extensible parser can alleviate a lot; but dependent pattern matching can often be awful
16:55:17 <mbw> this work using this particular Iso?
16:55:57 <centril> mbw: first off...  read :: String -> Int is not a total function - make sure you use a function readMay :: String -> Maybe Int
16:56:40 <mibaz_1> johnw: So you would recommend agda over idris?
16:56:46 <centril> then just use mt >>= readMay :: Text -> Maybe Int
16:56:49 <mbw> centril: This is just a contrived example, since Text provides its own parsing primitives.
16:56:54 <centril> mbw: ah
16:56:58 <mibaz_1> centril: Have you considered that dependend-haskell will be the apocalypse that ends it all?
16:57:06 <mbw> I just wanted to know how to "lens this" :)
16:57:18 <johnw> mibaz_1: I have barely used idris, so my opinion in that regard is pretty worthless
16:58:13 <centril> mibaz_1: nah - the AI folks need to study some theoretical computer science and think about the incompleteness theorem, halting problem, p vs np, etc.
16:58:18 <johnw> > Just "200" & mapped %~ (read :: String -> Int)
16:58:21 <lambdabot>  Just 200
16:58:43 <johnw> you can just add a ". unpack" there
16:59:46 <mbw> johnw: But why doesn't "(Just "200" :: Maybe Text) & mapped.unpacked %~ read" work? If I do this, read is _required_ to be of type String -> String!
16:59:48 <centril> mibaz_1: Idris is a general purpose programming language (GPL) wheras Agda is not. Agda is an (interactive) automated theorem prover mainly used by theorists
17:00:16 <centril> mibaz_1: while you can do it, no one in their right mind would write an actual program for production in Agda.
17:00:18 <hpc> idris just needs libraries imo
17:00:24 <mbw> To be fair, I got it to work with a traversal, returning an [Int].
17:01:07 <centril> mibaz_1: in case you need to learn some dependent types, I recommend following the contents of this course: http://www.cse.chalmers.se/edu/year/2016/course/DAT140/
17:04:01 <mibaz_1> centril: Excellent, thanks. I may take a look at that
17:04:33 <centril> mibaz_1: its also very nice because it features the main people behind both Coq and Agda
17:04:34 <tesan> I guess saying good night is off-topic. Well, people can recursively get the meaning of this.
17:04:41 <centril> mibaz_1: and you're most welcome
17:05:41 * hackagebot tweet-hs 1.0.1.0 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
17:06:47 <monochrom> w00t twitter on the command line. Now I can tweet in DOS!
17:09:58 <johnw> mbw: I believe it's because unpacked is an Iso', so you can change the type
17:14:08 <mbw> johnw: Makes sense. I still have a way to go when it comes to grokking the types.
17:15:39 <e2> haxx0r
17:17:16 <Squarism> johnw, reify on value gives a VarI value?
17:17:35 <e2> nice
17:17:37 <johnw> ok, that has a Type field also
17:17:46 <Squarism> yep
17:18:14 <Squarism> How do i get the type arguments from that Type?
17:18:40 <johnw> case on the type
17:18:45 <johnw> it should be a ConT
17:19:02 <johnw> (i.e., a type constructed from type arguments)
17:20:03 <Squarism> http://lpaste.net/357590
17:20:47 <e2> need vpn
17:20:55 <e2> for polari
17:21:13 <e2> and proxy for firefox
17:22:32 <e2> only for me,sercured with password
17:23:43 <johnw> e2: this isn't the place to ask
17:23:49 <e2> ok
17:24:01 <johnw> Squarism: ah, right, AppT, I forgot
17:24:30 <johnw> Squarism: AppT (AppT FooT a) b, where FooT :: ConT, is the type "Foo a b"
17:24:41 <e2> bash?
17:24:45 <johnw> well, not ":: ConT", but I hope you get the idea
17:24:51 <johnw> it's a Type constructed by ConT
17:24:59 <johnw> to which AppT is used to apply the type arguments
17:25:38 <Squarism> So i need to decompose that structure then. Theres no "gimme 2nd type argument" function
17:25:47 <johnw> no, there isn't
17:25:56 <johnw> but it's easy to write a custom function Type -> [Type]
17:26:11 <johnw> I have a bunch of such helpers lying around...
17:26:26 <Squarism> thanks for holding my hand / me keeping sanity. 
17:26:27 <Squarism> =D
17:26:34 <johnw> you're just walking a parse tree, really
17:26:43 <Squarism> yeah i understand
17:26:45 <johnw> where AppT is a custom, left-associated list
17:30:08 <e2> left or right
17:30:27 <e2> not answer
17:30:39 <e2> but u can type right too
17:34:00 <e2> dont hack me currency
17:34:11 <funkycrunchy> :exit
17:35:27 --- mode: ChanServ set +o monochrom
17:35:37 --- mode: monochrom set +b *!*@ppp109-252-72-30.pppoe.spdop.ru
17:35:37 --- kick: e2 was kicked by monochrom (e2)
17:36:24 --- mode: monochrom set -b $a:kastengraeber
17:36:31 --- mode: monochrom set -o monochrom
18:00:26 <nykros> hi, why in the pure function of the Applicative class has that name?
18:01:57 <Axman6> because it should be "pure", it should have no side effects, where "side effect" is defined by whatever applicative functor you're talking about
18:02:53 <Axman6> pure for State makes no modifications to the state
18:03:05 <mbw> nykros: I presume because you apply a "pure function" to the results of effectful ones, e.g. (pure (,) :: Int -> Int -> (Int,Int)) <*> impure1 <*> impure 2 :: Maybe (Int,Int) or something along those lines.
18:03:15 <Axman6> for list, it produces exactly one 1, which means it has no effect on anything else
18:03:17 <monochrom> I prefer to just say "effect".
18:03:37 <Axman6> yeah, effect is probably better
18:03:46 <Welkin> not front effects?
18:03:49 <Welkin> or back effects?
18:04:13 <monochrom> "side effect" came from 50 years ago when the pioneers haven't made up their minds what "function" means.
18:04:32 <Welkin> technically, most "functions" in programming are not even functions
18:04:35 <Welkin> in the mathematical sense
18:05:25 <mbw> There has to be some mathematician out there who silently sets errno.
18:05:35 <monochrom> That's OK. But neither choice justifies adding the "side" adjective. You really have to engage in double-think to do that.
18:05:45 <erisco> you have discovered a new class between Functor and Applicative that is also pointed... what new name do you come up with?
18:05:56 <nykros> Can I think in "pure" as this function takes something pure and converts into something else? 
18:06:07 <Welkin> erisco: you mean like Apply in purescript?
18:06:18 <monochrom> PointyFunctor :)
18:06:23 <Welkin> what do you mean by "pointed"?
18:06:29 <monochrom> has "pure"
18:06:29 <Vermie> Excuse me
18:06:31 <erisco> monochrom, I mean for your return/pure equivalent
18:06:37 <Vermie> does anyone know about type systems for proofs?
18:06:48 <Welkin> Vermie: Coq or Agda
18:06:48 <monochrom> I think I'll stick to "pure".
18:06:50 <Vermie> Or type systems that allow iterations over procedures?
18:06:59 <Vermie> procedure elements*
18:07:12 <erisco> monochrom, but now due to name clashes people don't like using your new class =\
18:07:33 <Vermie> Welkin: Cool. Do you know about type systems that allow for iteration over elements in a procedure?
18:07:56 <erisco> Welkin, F is pointed if there is some f :: a -> F a
18:08:30 <rmnd551> wow
18:08:44 <monochrom> No, the middle class should be a parent class of Applicative so that "pure" can migrate to the middle class so existing source code just keeps working.
18:09:01 <Vermie> ...does anybody have an answer?
18:09:01 <monochrom> OK except when you write "instance Applicative"
18:09:07 <Vermie> ...
18:09:12 <MichaelBurge> Is there a way to "negate" a pattern match? So if "data X = A | B" then "case x of !A -> ()" matches if x doesn't match the constructor A.
18:09:34 <erisco> monochrom, well, maybe after much discussion and a few years you'll get it in as a parent class ;)
18:09:39 <mnoonan_> Vermie: what do you mean by “iteration over elements in a procedure”?
18:09:46 <Welkin> MichaelBurge: match on A, then use _ to catch everything else
18:10:03 <monochrom> OK there has been many alternative proposals to the "pure" name even back then when we were looking at Applicative, so you can choose one of those.
18:10:05 <Vermie> mnoonan_: For example, if I have a struct, how can I describe a procedure to iterate over elements on a heterogenously-typed struct?
18:10:40 <Welkin> Vermie: perhaps Dependent types or Linear types may be of interest here?
18:10:45 <MichaelBurge> Welkin: You could probably always desugar it to do that, but it's a little more inconvenient when mixing multiple nested patterns in a complex match.
18:11:01 <monochrom> Anyway, my gripe with "side" in "side effect" is like Yoda's. Do or do not, there is no side.
18:11:23 <Vermie> For example, if I have a struct of {Func a, Func b, Func c}, what type of system would I need to be able to perform logic based on the types and then mutate the type flexibly?
18:11:35 <Welkin> MichaelBurge: I think that would make code a lot more difficult to read. Just look at how common negative logic is in imperative code (like javascript, or java, etc.) It is a disaster
18:11:59 <monochrom> Although I wonder why he didn't say "no try there is".
18:12:19 <dolio> He doesn't always speak backwards.
18:12:43 <erisco> MichaelBurge, imagine  data X = A | B | C  then what does !A tell you? still not sure if it is B or C
18:12:50 <mnoonan_> Vermie: sorry, can you get more concrete? it still is sounding a bit nonsensical to me. can you show me a concrete input and desired output?
18:12:55 <monochrom> Is that defensible or is it just scriptwriter inconsistency?
18:13:06 <dolio> I don't know.
18:13:27 <Vermie> mnoonan_: For example
18:13:32 <Vermie> Suppose I have a procedure that looks like this:
18:13:50 <MichaelBurge> erisco: Consider the view pattern "case 6 of x@(even -> True) -> ()". You don't know whether x is any even number, which is infinitely more uncertain.
18:14:35 <Vermie> { Int a; (Int a, Int _ ==> Int b); ==> b} where it describes a type that takes a single Integer a, puts it through a binary function that returns an Int, and then returns the result of it?
18:14:40 <erisco> MichaelBurge, view patterns are an extension, not part of Haskell 2010, and not a fundamental part of the language like case and pattern matching is
18:14:57 <Vermie> Where the type actually encodes the nature of composition as well as the state and variables involved
18:15:22 <MichaelBurge> erisco: I think all types are inductive, and so closed. Which means that negation can always be expressed as a positive match, and so it wouldn't be core either.
18:15:31 <Vermie> Then you could have higher-order functions which can directly mutate the type by going like, substitute Int --> String or something
18:15:55 <Vermie> Or, substitute IntMultiply into element 2.
18:16:05 <Vermie> Anybody know anything about typing of procedures?
18:16:17 <erisco> MichaelBurge, no, it cannot, because what is the positive match for !A when data X = A | B | C? you need *two* matches, not just one
18:16:47 <Vermie> MichaelBurge: Why not just do nothing matching for A, and then leave a wild card to perform the negated logic?
18:16:56 <monochrom> I'm wondering if I should say "if you're worrying about nesting, you should be using lens".
18:17:00 <erisco> MichaelBurge, it is not an inconceivable feature but you generally learn nothing about the value with a negative match
18:17:08 <Vermie> monochrom: Are you talking to me?
18:17:13 <monochrom> No.
18:17:29 <Welkin> are *you* talkin tah *me*?
18:17:59 <Vermie> But does this not exist?
18:18:16 <Vermie> I'm guessing that this would correspond to typing of proofs or programs themselves by the Curry-Horward Isomorphism
18:18:30 <Vermie> Should I be looking into Godel then due to its relationship with the Incompleteness Theorem?
18:21:33 <Vermie> :(
18:21:59 <Welkin> Vermie: have you looked into Coq or Agda?
18:22:16 <Welkin> haskell is not meant for proof writing
18:22:43 <erisco> but you can do it, and with TypeInType you can even add inconsistency
18:23:24 <pacak> bottoms spoil all the things if you want to prove things with haskell.
18:23:31 <Vermie> Welkin: No.
18:23:48 <Vermie> Welkin: And this is not necessarily a Haskell question -- it's more theory
18:24:04 <erisco> well... it is a #haskell channel you know
18:24:23 <erisco> there is #typetheory
18:24:29 <Welkin> erisco: I was just going to ask
18:24:37 <Welkin> I knew there was a category theory channel
18:24:41 <Welkin> was wondering about type theory
18:24:43 <Vermie> erisco: it's 3 people
18:25:05 <Vermie> category theory is also 3 people
18:25:08 <Welkin> is there a #coq ?
18:25:08 <erisco> if you just want a lot of people you can join #linux or #python, I think they have more ;)
18:25:31 <erisco> Welkin, they all have a channel ... at least the proof assistants I have tried
18:25:35 <Welkin> Vermie: it should have a lot more than that #catgeory-theory
18:25:37 <erisco> kind of essential to figure out how to do anything :P
18:26:11 <angerman> cocreature: seems like it :)
18:26:28 <erisco> Vermie, you can ask about typing in Haskell though ... maybe that will help you
18:26:42 <Welkin> I mean #categorytheory
18:26:52 <HallaSurvivor> Hey all! I'm using the Text library for hte first time (usually I don't care about efficiency)
18:26:54 <Welkin> or was it two #?
18:27:00 <Welkin> I can never remember
18:27:06 <HallaSurvivor> what's the equivalent of s1 ++ show n ++ s2 for T.Text?
18:27:18 <HallaSurvivor> I can't seem to find anything better than T.cons :/
18:27:19 <Welkin> HallaSurvivor: use <>
18:27:32 <Welkin> from Data.Monoid or Data.Semigroup
18:27:55 <HallaSurvivor> Welkin, thanks!
18:27:59 <Welkin> + is a specialized form of <> for lists
18:28:02 <Welkin> er
18:28:04 <Welkin> ++ is a specialized form of <> for lists
18:28:16 <HallaSurvivor> And I'll need to convert show n from a String to a T.Text, right?
18:28:19 <HallaSurvivor> overloadedStrings doesn't handle that
18:28:23 <Welkin> don't use show
18:28:26 <Welkin> use T.show
18:28:28 <HallaSurvivor> :O
18:28:31 <HallaSurvivor> ty
18:28:37 <erisco> Vermie, if you are wondering how to analyse procedural programs then consider Hoare Logic and operational semantics
18:29:20 <Welkin> HallaSurvivor: you also may want to look into the OverloadedStrings pragma
18:29:33 <Welkin> so you can type string literals in your code and have them be Text
18:29:40 <HallaSurvivor> Yeah, I'm currently using it!
18:30:03 <HallaSurvivor> I wasn't sure if it handled all string conversion, or just things I type in ""
18:30:11 <HallaSurvivor> but given T.show exists, it's probably just "" stuff
18:30:58 <Vermie> Welkin: There are 0 people in #category-theory
18:31:01 <Vermie> erisco: Cool.
18:31:06 <Welkin> Vermie: yeah, wrong channel
18:31:17 <Welkin> ##categorytheory I think it is
18:31:41 <Welkin> 73 people
18:31:49 <Welkin> many of them from here
18:33:54 <erisco> your client should let you search the channel list
18:34:02 <Vermie> Found it
18:34:07 <Vermie> But it looks dead too
18:35:29 <erisco> there are also just a limited number of people who are involved in the field, and not many then spend a lot of time on IRC
18:35:46 <erisco> that is true as you become more niche with anything
18:36:51 <erisco> also try books, blogs, papers, courses
18:36:51 <Vermie> erisco: :(
18:37:03 <Vermie> I have a feeling I need to look into HM and System F soon
18:37:23 <Vermie> It's so hard to learn type theory...
18:38:48 <erisco> it is focused on functional programs ... I am sure it is more broad than I realise but there is certainly a lot of material just for that
18:39:52 <ab9rf> erisco: searching channel lists on some networks is virtually impossible due to the size of the channel list. some servers don't even allow requesting the channel list, although i don't think freenode does this
18:40:33 <ab9rf> i could stand to spend some time learning category theory, but figuring out how to get started is nontrivial
18:40:35 <erisco> ab9rf, my client (HexChat) has a text search feature to help
18:41:09 <erisco> Vermie, are you familiar with logic?
18:41:22 <Welkin> Vermie: there is a great book on Type Theory and Programming called "Types and Programming Languages" by Benjamin Pierce
18:41:26 <ab9rf> erisco: i remember back in the day when /list would cause a disconnect because the list was so long that you'd time out before you could receive it all
18:41:31 <Welkin> it covers HM and System F
18:41:57 <erisco> ab9rf, that's what fiber is for ;)
18:42:13 <Welkin> ab9rf: there is a book for that too! It's called "Conceptual Mathematics" by Lawvere
18:42:14 <ab9rf> erisco: yes, well, i'm a bit older than that :)
18:42:30 <ab9rf> Welkin: will look into it
18:42:43 <Welkin> it's meant for high school through undergrads to learn category theory
18:42:44 <erisco> Vermie, there are excellent lecture series here but to get started watch Frank Pfenning's https://www.cs.uoregon.edu/research/summerschool/summer12/curriculum.html
18:42:59 <ab9rf> yow. $58.50
18:43:34 <Welkin> ab9rf: that's a good price, for the quality, especially to typical text books that are 3-4 times more
18:43:43 <ab9rf> Welkin: yes, but it's more than i want to pay just now
18:43:56 <ab9rf> Welkin: i'll have to see if my library can find a copy
18:44:22 <Welkin> that's a good idea
18:44:49 <erisco> Vermie, Programming in Martin-Lof's Type Theory (http://www.cse.chalmers.se/research/group/logic/book/book.pdf) is also a good introduction. It has a history of the field at the beginning which can point you to other materials
18:45:43 <ab9rf> mmm, apparently not
18:46:19 <ab9rf> not anywhere in the entire statewide system
18:46:29 <Vermie> i see
18:46:47 <Welkin> ab9rf: see if you can request your local library to buy a copy
18:47:03 <ab9rf> Welkin: that won't happen
18:47:11 <Welkin> or just save up and buy it
18:47:43 <Welkin> you should be able to buy a used copy for cheaper
18:48:34 <erisco> Vermie, I think a lot of difficulty is the obtuseness that comes from how logic is traditionally discussed
18:48:36 <Welkin> ab9rf: https://www.abebooks.com/servlet/BookDetailsPL?bi=22507463098&searchurl=tn%3Dconceptual%2Bmathematics%26sortby%3D17%26an%3Dlawvere
18:48:42 <Vermie> erisco: Are you from there?
18:48:43 <Welkin> There, I found a copy for $24
18:48:57 <Welkin> abebooks is owned by amazon and I have used them before
18:49:05 <erisco> Vermie, no, it was just a resource I was referred to when I wanted to learn more about type theory
18:49:35 <Vermie> erisco: I see. Are you a hobbyist?
18:49:48 <erisco> academically I suppose I am
18:49:57 <Vermie> I see
18:51:26 <erisco> you're walking in on an old discussion between logicians and trying to herd it back to something that looks like programming, and that takes a while, or at least it is taking a while for me
18:51:39 <Welkin> I recently bought a book on cantonese through abebooks. It was a used copy (in nearly perfect condition) for 1/5th the normal price. And included all the CDs
18:51:58 <ab9rf> Welkin: amazone had a used copy at $22.50, iirc
18:52:21 <ab9rf> Welkin: mind yhou, i'm not ruling it out, but it'll have to wait a bit
18:52:31 <ab9rf> my wife just changed jobs and our finances are a little complicated right now
18:52:49 <ab9rf> they'll be fine in a couple of weeks, but there's no money for discretionaries right now
18:52:49 <Welkin> ab9rf: that looks like a rental
18:53:15 <ab9rf> Welkin: you might be right
18:53:26 <Welkin> the abebooks one is the cheapest
18:53:31 <Welkin> it ships from the UK, lol
18:53:43 <Welkin> yeah, I understand that
18:53:49 <Welkin> I've been there before, counting pennies
18:54:30 <ab9rf> Welkin: it's really just about minimizing the amount of money we pull out of savings until her paychecks start rolling in again
18:54:47 <erisco> Vermie, the boons I am seeing so far are firstly how to go about designing a language, i.e. what do you need to think about and what pieces do you need
18:54:48 <ab9rf> mostly it's just because she went from being paid on time to being paid in arrears
18:55:13 <Vermie> erisco: I wanted to create a language with extreme metaprogramming abilities with a strong type system
18:55:15 <ab9rf> new job pays more, so in the long term we'll be ahead
18:55:34 <erisco> Vermie, and then also understanding properties such as soundness, completeness, consistency, and such like, i.e. things you could ask about any language
18:55:35 <Welkin> Vermie: metaprogramming is the worst...
18:55:38 <Vermie> erisco: take Lisp's homoiconicity and turn it up to 11 with a static type system
18:55:41 <Welkin> I stay far away
18:55:50 <ab9rf> what about paraprogramming?
18:55:56 <Welkin> have fun debugging or testing that
18:56:10 <Welkin> or having any idea what is going on
18:56:13 <ab9rf> i am not fond of metaprogramming
18:56:39 <ab9rf> metaprogramming environments hae a tendency to become rubegoldbergian
18:56:53 <Vermie> Welkin: I mean, if you think about it, a procedure is a higher-order operation on a tuple of statements or procedures with a common context
18:57:37 <Vermie> So you could potentially describe the context for a program with a struct of data and procedures as well as store how they are composed
18:57:57 <Vermie> But I'm having a hard time thinking about how you would type such a program
18:58:23 <Vermie> For example, parallelism? Branches? Joins? It seems it's going to take on the qualities of SSA or CPS somewhere
18:58:32 <erisco> Vermie, in one of Harper's lectures, I think, he mentioned a system which included eval, which might be what you are talking about, but I don't know anything else about it
18:59:58 <Vermie> erisco: Sounds interesting
19:00:07 <Vermie> I could take a trip to Oregon this weekend lol
19:00:34 <erisco> they went through a list of different logics and corresponded them to PLs with different features ... can't remember which was what
19:01:17 <erisco> I am not sure having eval is as enticing as you feel it
19:02:02 <erisco> do you really want to be generating code? that is usually obnoxious relative to what you want accomplished
19:02:21 <erisco> just do some stuff with TH and see how you enjoy it
19:02:29 <Vermie> erisco: It's more I want to work on a meta-level with programs
19:02:46 <Vermie> For example, search and replace on a type-level with arbitrary logic
19:03:05 <Vermie> Or, creating a procedure to apply monadic-like logic to a procedure
19:03:11 <erisco> but why search and replace? I don't know, seems unnecessary
19:03:27 <Vermie> Testing two procedures to see if they satisfy the same implementation requirements by inclusion of types in its structure
19:03:44 <erisco> well that's just types, you don't need metaprogramming
19:04:19 <erisco> maybe there is a good application for extending compilers
19:06:19 <erisco> there are languages such as Numerle (http://nemerle.org/About) which have metaprogramming capabilities
19:07:39 <erisco> and also projects such as JetBrain's MPS come to mind ... there is a place for metaprogramming when code generation is appropriate, such as in a compiler
19:07:52 <erisco> but I do not think that is the way you'd want to work regularly
19:09:12 <erisco> Vermie, dependent types already let you express just about whatever you want
19:09:29 <mnoonan_> does anybody have recommendations for signal processing libraries? audio, specifically; doesn’t need to be real-time.
19:12:37 <erisco> Vermie, a point of types is to have a simpler description of a program. If your program is a product of metaprogramming then it is no simpler than the metaprogramming language.
19:13:20 <erisco> and so you'll still be vying for some way to describe this metaprogramming language
19:13:49 <Vermie> erisco: That's true. But it does allow for powerful abstractions and perhaps more power to describe the full compilation process
19:14:45 <Profpatsch> Am I just blind or is this function nowhere to be found in normally used libraries?
19:14:47 <Profpatsch>         mayPred :: (a -> Bool) -> a -> Maybe a
19:14:49 <Profpatsch>         mayPred pred a = if pred a then Just a else Nothing
19:15:54 <pacak> Profpatsch: Looks something like pureIf :: Alternative f => (a -> Bool) -> a -> f a ; pureIf pred a = if pred then pure a else empty
19:16:15 <pacak> But I think it's not there.
19:16:37 <Profpatsch> It’s defined *lots* of times in libraries http://hayoo.fh-wedel.de/?query=(a+-%3E+Bool)+-%3E+a+-%3E+Maybe+a
19:17:25 <mnoonan_> Profpatsch: I guess you can do “find p [x]”, though its pretty ugly
19:17:31 <pacak> Yes. Also Alternative or MonadPlus.
19:19:00 <mnoonan_> Profpatsch: oh, new hoogle finds this: http://hoogle.haskell.org/?hoogle=%28a+-%3E+Bool%29+-%3E+a+-%3E+Maybe+a&scope=set%3Astackage
19:19:26 <MarcelineVQ> muahaha
19:21:07 <Profpatsch> mnoonan_: yeah, that’s what hayoo found.
19:21:19 <mnoonan_> ah whoops, sorry
19:21:39 <Profpatsch> I think partial :: (a -> Bool) -> a -> Maybe a should go to Data.Maybe probably.
19:22:09 <Profpatsch> It’s very helpful when chaining Maybes with >>=
19:24:26 <erisco> Vermie, I don't know, I am not convinced it offers much for abstraction
19:25:05 <erisco> Vermie, I see it used in two ways... one is just to generate a bunch of boilerplate more concisely
19:26:16 <Vermie> erisco: It's more about manipulation, not generation
19:26:19 <erisco> which is just a matter of convenience, and it is rather confusing because you don't have the generated definitions to look at unlike the rest of your code
19:26:43 <Vermie> erisco: I'm thinking about it in the context of IDE support and refactoring and analysis
19:26:54 <erisco> then the other use is to generate more efficient code because other methods of abstraction won't suffice
19:27:10 <erisco> which isn't about having more abstraction, it is just about improving the implementation
19:28:05 <Vermie> erisco: I still think it can be incorporated into more visualization and manipulation
19:28:16 <Vermie> Especially if you execute the type system well
19:29:48 <pacak> Profpatsch: It's not specific to Maybe.
19:33:48 <Profpatsch> pacak: I can’t find a pureIf
19:35:08 <cdsmith> Hmm... https://www.haskell.org/ghc/download.html is missing the link for 8.0.2.  I should know where to report that...
19:35:36 <glguy> cdsmith: Mention it in #haskell-infrastructure
19:35:57 <erisco> Vermie, the questions I can think of, for typing, is first that the syntax constitutes a valid program, and second what is the type of this program
19:36:32 <erisco> also keep in mind you might have quasi-quotation
19:37:53 <Profpatsch> pacak: What would you call the Alternative version of the function? partial doesn’t seem to make sense for `IO a`, `STM a` or `Parser a`.
19:38:24 <erisco> Vermie, in Haskell we can do that with GADTs. it is what we call an eDSL or embedded domain-specific language
19:38:31 <pacak> Profpatsch: pureIf
19:38:50 <pacak> At least that's how it's called in our custom prelude.
19:39:05 <Profpatsch> That’s a pretty weak name imho.
19:40:12 <Profpatsch> pacak: Ah, I’m an idiot https://hackage.haskell.org/package/protolude-0.2/docs/Protolude.html#v:guarded
19:40:21 <Profpatsch> That’s the package I wanted to add the function to. :P
19:41:10 <Profpatsch> Yes, guarded is a good name.
19:41:38 <pacak> :t guard
19:41:40 <lambdabot> Alternative f => Bool -> f ()
19:41:47 <pacak> Hmm... Yea, I guess so.
19:42:28 * pacak dislikes custom preludes
19:43:44 <Profpatsch> pacak: Why?
19:44:11 <Profpatsch> I mean it’s like a utils library with an interface people actually think about.
19:44:36 <Profpatsch> I haven’t yet found a bad function in protolude.
19:44:58 <pacak> If you want to submit a bugreport to ghc - first you need to unfuck all the changes caused by custom prelude.
19:45:27 <Profpatsch> With the inclusion of Traversable and Foldable there is not that much going on anymore.
19:45:33 <pacak> If you want to submit a patch to some other library/package - first you need to figure out wtf is guarded, why there's no head in scope or some bullshit.
19:45:54 <Profpatsch> protolude has the StringConv class, but that’s about it and only done explicitely.
19:46:29 <Profpatsch> That’s why everything else is imported qualified by default. :)
19:47:39 * hackagebot happstack-foundation 0.5.9.1 – Glue code for using Happstack with acid-state, web-routes, reform, and HSP – https://hackage.haskell.org/package/happstack-foundation
19:47:40 <pacak> Yea, but if you going to submit a ghc bug - you'll need to unfuck it anyway, whatever it's qualified or not, otherwise the first question will be "wtf is Foo?"
19:48:34 <glguy> pacak: But how do you really feel about alternate preludes?
19:49:12 * glguy also avoids them
19:49:13 <Profpatsch> How often do you submit GHC bugs for that to matter? oO
19:49:30 <pacak> Profpatsch: Once a month? Depends.
19:50:49 <pacak> glguy: I hate them.
19:51:15 <pacak> They are causing me nothing but troubles.
19:52:26 <Profpatsch> I find Protolude has increased my joy of writing Haskell code by a lot.
19:52:54 <Profpatsch> Most of what I normally reach for is in scope, and it’s generally stuff people already know and import from e.g. Safe.
19:53:02 <pacak> Profpatsch: You are not writing haskell. You are writing some cryptic dialect of haskell.
19:53:12 <Profpatsch> Or Bifunctor first/second
19:53:23 <Profpatsch> pacak: Well, then Haskell is pretty shit.
19:53:33 <Profpatsch> :)
19:53:48 <pacak> Profpatsch: Try to improve it then.
19:54:13 <Profpatsch> If you want to improve base, you should take a look at Protolude is all I have to say.
19:58:15 <bozza> what is haskell and why is it so popular on freenode?
19:59:09 <kadoban> Haskell is a programming language. And it's popular on freenode because it's awesome and freenoders know this.
20:00:08 <bozza> :) thanks kadoban
20:00:24 <kadoban> Anytime
20:00:43 <bozza> what is it used to program? web apps, desktop apps or mobile apps?
20:00:51 <glguy> Yup
20:00:56 <kadoban> Yes yes and sometimes
20:01:33 <bozza> is there some popular framework that it is being used with?
20:01:44 <kadoban> It's a general purpose programming language. It's type system is particular fun and it has quite different semantics compared to most languages. (it's a purely functional programming language)
20:01:59 <kadoban> Not particularly
20:02:49 <bozza> it sounds quite new??
20:02:55 <boj> quite old actually
20:02:59 <bozza> oh
20:03:50 <MarcelineVQ> it's been around for awhile, but it's eternally new
20:04:28 <Profpatsch> bozza: '91, so older than Java, Python and all that fuzz
20:05:12 <bozza> ohh
20:05:25 <bozza> yet really popular on freenode :)
20:05:34 <boj> bozza: are you a developer?
20:05:40 <Profpatsch> But the efficient libraries for Text/Byte/Json handling have only been added in the mid '00s
20:06:26 <glguy> Profpatsch: It'd be hard to support JSON much before JSON existed
20:06:28 <bozza> boj I like to develop an app or a website from time to time
20:06:41 <boj> cool. what do you typically use?
20:06:44 <HallaSur1> bozza, what do you normall;y work in
20:06:55 <Profpatsch> glguy: good point :P
20:07:08 <bozza> I usually work in higher level libraries and frameworks
20:07:13 <bozza> currently Qt and c++
20:07:45 <bozza> c++ is low level I know I know
20:07:51 <bozza> but I use it with libraries
20:07:57 <boj> makes sense
20:08:15 <bozza> also some python
20:08:23 <bozza> never really liked django all that much 
20:08:30 <bozza> even though it was THE thing
20:09:02 <boj> ever tinker with a functional language?
20:09:06 <bozza> but I am considering getting into some sort of JS stack website
20:09:23 <erisco> C is a high level language, as is C++
20:09:23 <bozza> with some fancy JS as the frontend 
20:09:41 <bozza> erisco: true
20:09:50 <kadoban> erisco: :-/
20:09:58 <bozza> lower level than python or java I think?
20:10:09 <boj> haskell has an interesting FRP library called Reflex that builds into JS frontends. not for the feint of heart, but pretty cool
20:10:10 <bozza> boj: don't think so
20:10:31 <erisco> if it aint assembly it is high level
20:10:46 <erisco> beyond that there is no hierarchy I have ever heard of
20:11:09 <kadoban> erisco: Then the term "high level" is not very useful, right? Might as well just never use it except in relative terms.
20:11:37 <erisco> kadoban, it was probably more interesting at the time most people were programming in assembly ;)
20:11:56 <kadoban> Yes, I'm just saying the semantic usefulness has probably passed, if that's the criteria.
20:12:09 <boj> i suppose "high level" one step above c/c++ would refer to runtimes vs. manual memory management
20:12:43 <boj> that would put rust in an awkward place though? hmm
20:12:45 <mnoonan_> at least calling C a high-level language helps dilute the notion that you just write some C and the “obvious” machine code pops out the other end (whatever that means)
20:12:48 <bozza> I love python and even bash to be honest
20:12:51 <erisco> kadoban, meh, maybe assembly is high level now since CPUs do not actually execute it as wrote
20:13:04 <kadoban> Haha
20:13:24 <bozza> bash as in the *nix command line :)
20:14:06 <boj> bozza: it's a little outdated but if you are curious poke at http://learnyouahaskell.com/
20:14:35 <bozza> thanks boj, will take a look. also having a look at the reddit site
20:15:14 <boj> large chunk of the community on /r/haskell - great place to ask questions
20:15:20 <bozza> boj: what makes a functional language functional? 
20:15:29 <bozza> cool!
20:15:32 <boj> bozza: you use functions :D
20:15:54 <mnoonan_> boj: are you a reflex user? does the warning about ghcjs builds working best with 16G refer to building ghcjs itself, or building *with* ghcjs?
20:16:31 <erisco> bozza, you use mathematical functions and so there is no state or mutability
20:16:42 <mnoonan_> I’ve been wanting to play around with it, but I don’t know if my laptop is up to the task (which seems wrong, but whatever)
20:16:44 <boj> mnoonan_: probably both, tends to be memory intensive
20:16:49 <kadoban> mnoonan_: I have like 5-6GB and I can build ghcjs and things with ghcjs fine. So I'm not sure what that is.
20:16:50 <erisco> bozza, there are also no statements, only expressions
20:16:59 <boj> i use an 8gb VM just fine
20:17:02 <mnoonan_> kadoban: ah, nice. maybe i’ll give it a shot then.
20:17:32 <mnoonan_> I guess my perception of ghcjs was wrong.. I thought it was basically just normal GHC, with something to translate core and the runtime to JS?
20:17:45 <boj> mnoonan_: that about sums it up actually
20:17:48 <kadoban> That sounds like about it, ya.
20:18:00 <mnoonan_> on the surface, I wouldn’t expect that to have very different requirements from vanilla ghc
20:18:17 <boj> you can pull the majority of hackage in, which is the big win
20:18:34 <kadoban> It seems similarly resource intensive, yeah. I think it takes longer to compile a bit? Hard to say.
20:22:17 <boj> i suppose the pain point with ghcjs, and reflex specifically, is that you basically need to buy into nix to get an env bootstrapped correctly
20:22:37 <HaskellLord69> agreed
20:23:28 <kadoban> You can use stack if you copy some magic incantations. The "try-reflex" stuff from reflex is nice though, I don't know any nix and it works well
20:23:34 * boj dropped stack in favor of nix and hasn't looked back
20:23:54 <boj> i think they are actively trying to make it stack buildable
20:24:11 <glguy> I heard a song about not looking back today (... goes off to find the lyrics)
20:25:27 <glguy> Tame Impala's Elephant: "He pulled the mirrors off his Cadillac (yeah) ‘Cause he doesn’t like it looking like he looks back"
20:26:35 <erisco> (yeah) then he was rear ended at a stop sign (yeah) wish he had those mirrors... (chorus x4)
20:27:28 <glguy> If he was *really* cool, he'd also drive in reverse all the time without looking abck
20:27:31 <bozza> people on reddit love haskell
20:27:45 <bozza> are there any popular frameworks that use it?
20:28:07 <erisco> for, what, web? yes, there is Yesod and Snap and Happstack and others
20:28:31 <bozza> and for desktop? :)
20:29:15 <erisco> there's bindings to lots of libs
20:30:08 <bozza> thanks thanks.. was just a quick question while reading up on haskell
20:30:19 <boj> bozza: https://wiki.haskell.org/Applications_and_libraries/GUI_libraries
20:30:30 <bozza> ty
20:30:58 <erisco> I am not sure if there is a GUI lib written in Haskell, but probably
20:31:58 * hackagebot tweet-hs 1.0.1.1 – Command-line tool for twitter – https://hackage.haskell.org/package/tweet-hs
20:36:59 <dmj`> bozza: if you’d like to use the browser there’s good options. https://flatris.haskell-miso.org/
20:38:57 <bozza> thanks
20:39:57 <sqooq> I am really good ... at writing bad code
20:41:23 <sqooq> what is wrong here?
20:41:24 <sqooq> http://lpaste.net/357592
20:43:22 <sqooq> LMAO
20:43:31 <sqooq> I forgot to give it an empty list to start with when testing
20:43:35 <sqooq> nevvveeerrrrmiiiind soz
20:43:47 <HaskellLord69> lol
21:12:55 <zomg> HaskellLord69: that is a pretty great nick
21:19:57 <iqubic> It sure is
21:27:18 <HaskellLord69> ty ty
21:28:03 <HaskellLord69> There was a guy floating around with the name HaskellAndChill, i thought that was a good one as well.
21:35:10 <crucify_me> http://lpaste.net/357593  sorry I don't understand the purpose of this exercise, where we set Mon == Mon , weekday == weekend' , dayOfMonth == dayOf Month'  . we're writing instances for typeclass Eq .. I'm confused at this stage
21:37:00 <erisco> crucify_me, what is your question?
21:37:26 <kadoban> crucify_me: Are you confused what the code means, or something pedagogical, or?
21:37:44 <crucify_me> well..
21:38:06 <jle`> hm interesting formatting glitch in haddock http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#t:ZipList
21:38:41 <crucify_me> we're creating data types that are set equal to themselves and set equal to True. isn't that elaborate for such a thing.?
21:39:01 <jle`> crucify_me: oh you're not setting things to equal to themselves...
21:39:05 <jle`> you're defining a function (==)
21:39:09 <jle`> with different possibilities
21:39:15 <sqooq> I need advice
21:39:25 <sqooq> who here is aware of my parsing mayhem
21:39:37 <jle`> crucify_me: what if i told you i wanted to you write a function that took two DayOfWeek's and told me whether or not they were equal
21:39:42 <jle`> how would you do this?
21:39:46 <jle`> that's a pretty important thing to be able to do
21:40:48 <erisco> in other words of what jle` said, you are defining equality for DayOfWeek and Date
21:41:00 <HaskellLord69> They aren't equal by default
21:41:05 <crucify_me> so lines 7 through 15 are written to guarantee that that would happen? 
21:41:10 <crucify_me> jle`, 
21:41:10 <jle`> that what would happen
21:41:37 <crucify_me> that would make it impossible for two days of the week to be equal
21:41:57 <jle`> two days of the week are allowed to be equal, heh
21:42:02 <jle`> how about i show a simpler example
21:42:10 <crucify_me> please do
21:42:12 <jle`> let's write a function that takes two bools and tells you if they were equal
21:42:25 <jle`> equalBool False False = True
21:42:29 <jle`> equalBool True False = False
21:42:33 <jle`> equalBool False True = False
21:42:36 <jle`> equalBool True True = True
21:42:47 <mnoonan_> crucify_me: are you familiar with writing the definition of a function by cases, as in the first few examples here? http://learnyouahaskell.com/syntax-in-functions
21:42:48 <jle`> do you see how that function works?
21:42:48 <crucify_me> okkk, straight logic got that
21:43:02 <jle`> if you give it False and False, then it'll say "yes they are equal"
21:43:11 <jle`> if you give it False and True, it'll say "nah they're not equal"
21:43:12 <crucify_me> it is based on a truth table
21:43:34 <crucify_me> not P or Q
21:43:34 <jle`> yeah, you're basically writing the same thing
21:43:48 <jle`> equalDayOfWeek Mon Mon = True
21:43:54 <jle`> equalDayOfWeek Mon Tue = False
21:43:57 <jle`> etc.
21:44:17 <jle`> you're basically handling every possible choice of inputs, and telling if those two inputs are equal (True) or not equal (False)
21:44:22 <jle`> you're giving the truth table "by hand"
21:44:37 <crucify_me> ok got that thanks....
21:44:46 <jle`> you're not setting things to be equal
21:44:56 <jle`> you're basically defining the concept of "equality" on your type
21:45:00 <iqubic> jle`: There should be a simpler way to do that. 
21:45:09 <jle`> "what does it mean for two values of DayOfWeek to be  equal"
21:45:13 <jle`> "what is equality, even...?"
21:45:18 <HaskellLord69> Some newcomers are surprised when they define a type like DayOfWeek and then try to do Sun == Sun and find out it doesnt work.  That's what the EQ instance is for, to explicitly define that concept of equality
21:45:19 <crucify_me> so what about where we're using the prime weekend' et al.
21:45:21 <jle`> and your answer is "well, Mon and Mon are equal."
21:45:31 <jle`> "and if you have Tue and Mon, well, they're not equal."
21:45:41 <jle`> "and if you have Wed and Tue, well, i'm going to arbitrary say that they are not equal"
21:45:48 <iqubic> equalDayOfWeek Mon Mon = true
21:45:56 <jle`> nothing is actaulyl stopping you from saying that Wed and Thu are "equal" (return True)
21:46:04 <iqubic> equalDayOfWeek Mon _ = false
21:46:13 <jle`> crucify_me: primes are just normal characters in variable names
21:46:14 <iqubic> if you put that second, then it just works
21:46:32 <jle`> crucify_me: try walking through the logic.  how would you tell me if two Day's are equal?
21:46:49 <jle`> equalDay (Day w1 d1) (Day w2 d2) = ???
21:46:56 <jle`> sorry, Date's
21:47:13 <crucify_me> (==) Sun Mon = True
21:47:47 <jle`> sorry, i mean Date's
21:47:48 <iqubic> crucify_me: that is valid. Is that what you want
21:47:53 <HaskellLord69> Some people want to watch the world burn
21:47:54 <jle`> how would you write if two Date's are true
21:48:04 <jle`> equalDate (Date w1 d2) (Date w2 d2) = ???
21:48:20 <erisco> I mean it is basically the same thing... Sunday is just a day for worrying about work on Monday...
21:49:13 <Shawn|4650M> howdy
21:49:15 <crucify_me> equalDate (Date w1 d2) (Date w2 d2) = True  I gues
21:49:48 <HaskellLord69> That means any 2 different dates would be equal
21:50:44 <jle`> crucify_me: yeah, that's like saying that equalDate _ _ = True
21:51:06 <jle`> why don't you walk through the logic...if i told you about two dates, how would you tell me that they are equal?
21:51:15 <jle`> would your answer be "they are equal no matter what" ?
21:51:19 <crucify_me> well you use the prime notation or naming convention, is that what you mean?
21:51:28 <iqubic> No.
21:51:37 <jle`> i mean, in english
21:51:38 <mnoonan_> jle`: a timeless answer
21:51:43 <jle`> this is something that you can answer in normal words
21:51:50 <iqubic> It's doesn't matter how we refer the dates.
21:51:53 <jle`> with like your everyday experiences
21:52:18 <jle`> like, if i told you "First Monday" and "Second Tuesady", are those equal?
21:52:34 <jle`> draw from your everyday experiences as a human being
21:53:07 <iqubic> And can you explain why or why not "First Monday" and "Second Tuesady" are equal
21:53:08 <crucify_me> well, since we don't have the year accounted for , 2 March 2016 and 2 March 2017 are equal
21:53:18 <jle`> how do you know that they are equal?
21:53:19 <iqubic> Alright, why.
21:53:23 <jle`> like, how did you make that conclusion in your head
21:53:29 <jle`> you seem to know that they are equal
21:53:45 <iqubic> But why? What exactly lead you to that conclusion.
21:53:49 <iqubic> ??
21:54:31 <crucify_me> well
21:54:46 <MichaelBurge> instance Show a => Eq a where (==) a b = show a == show b
21:55:02 <iqubic> MichaelBurge: Sure. That works
21:55:13 <erisco> lol
21:55:20 <jle`> crucify_me: like, from what i see, it seems that you are fully able to recognize that 2 March is the same as 2 March
21:55:25 <jle`> but, what is your thought process?
21:55:33 <jle`> did you, like, ask a friend
21:55:37 <crucify_me> I am thinking in terms of years
21:55:42 <jle`> and the friend told you that they are equal?
21:55:55 <jle`> ok, you are thinking, but what is your thought process?
21:56:00 <jle`> i know you are thinking
21:56:07 <iqubic> How do years help you identify that the two dates are the same?
21:56:17 <erisco> you don't know that crucify_me isn't a Chinese Room
21:56:45 <jle`> hopefully a chinese room would also contain the answer to this inquiry so it would be indistinguishable from a thinking person
21:56:51 <crucify_me> because its a cycle
21:57:06 <jle`> okay, what if i came up to you and said "is 3 March the same as 5 May?"
21:57:18 <jle`> you would tell me ...?
21:57:24 <iqubic> WHat do you answer, and why?
21:57:37 <SrPx> What exactly is the difference between having an universe of types, and just having Set : Box (one level far)?
21:58:27 <crucify_me> no-n, they each have a different day and a different month. no criteria makes them equal
21:58:34 <HaskellLord69> bingo
21:58:56 <jle`> hooray
21:59:03 <crucify_me> hooray hooray
21:59:06 <jle`> so, if they have a different day and a different month, then they are not equal
21:59:45 <jle`> so (Date w1 s1) == (Date w2 s2) = not (w1 /= w1   &&    s1 /= s2)
21:59:54 <erisco> now formalise in logic and find the contrapositive :)
21:59:54 <jle`> from what you said
21:59:56 <crucify_me> okkk, so we need to spell out a truth table, since we are learning using instances of the type class Eq, although surely there are easier ways to define a calendar
21:59:58 <jle`> and you're good to go
22:00:06 <jle`> nah we're already done
22:00:13 <iqubic> Are we?
22:00:31 <jle`> oh sorry
22:00:42 <jle`> equalDate (Date w1 s1) (Date w2 s2) = not (w1 /= w1   ||    s1 /= s2)
22:00:55 <iqubic> How do you figure? Don't we need to define equality for days and for weeks?
22:00:56 <jle`> if either the day is different and the number is different, then they're not equal
22:01:07 <jle`> we already did earlier in the excercise heh
22:01:18 <iqubic> Ah, I must have missed that.
22:02:11 <jle`> from there you can also use de Morgan's Law if you want
22:02:35 <jle`> to see that not (w1 =/ w2   ||    s1 /= s2) is the same as (w1 == w2) && (s1 == s2)
22:03:00 <jle`> so equalDate (Date w1 s2) (Date w2 s2) = (w1 == w2) && (s1 == s2)
22:03:06 <erisco> if you think this is a fruitless exercise then think again... I had to write these definitions in production C# code
22:03:16 <jle`> two Date's are equal if the first fields are equal, and also if the second fields are equal
22:03:24 <erisco> they don't have deriving Eq, sadly
22:03:26 <HaskellLord69> wait until you find out about derive Eq
22:03:30 <crucify_me> I understand those posts as they stand alone. no I'm certainly not saying its fruitless
22:03:58 <jle`> writing Eq is kind of boilerplatey, admittedly, but it's a good exercise in writing arbitrary functions
22:04:02 <jle`> using pattern matching
22:04:11 <jle`> i could have asked you to tell me if two dates are equal
22:04:22 <jle`> but i could have also asked you to tell me if one date is *earlier than* another date
22:04:29 <erisco> I hope one of the exercises as an equality that is not just structural
22:04:38 <jle`> which is essentially the exact same question with the exact same techniques
22:04:54 <jle`> er, which is a question that requires the exact same techniques and skills
22:04:56 <erisco> an easy one is lists as sets
22:07:01 <jle`> crucify_me: so the real "skill" here is writing functions to implement some logic, be it equality, or less than, or maybe adding two days together, etc., using pattern matching
22:07:22 <jle`> 'are they equal' is just one such logic/relationship that you can implement as an example
22:07:48 <jle`> and writing functions using pattern matching is one of the most fundamental haskell skills :)
22:08:00 <crucify_me> so this program does nothing near giving the date. it is illustrating how we create a data type that needs to be an instance of Eq. so we are 'hand writing' a  truth table so to speak
22:08:07 <sqooq> ok here's my question
22:08:28 <jle`> yeah, this program doesn't give any dates
22:08:31 <sqooq> I have a tree structure that I do stuff with but I basically need Blank spots and also something called Rests
22:08:36 <sqooq> which get treated differently
22:08:55 <sqooq> I also think it's quite useful to define functor, applicative, and monad for my tree
22:08:57 <jle`> instead of 'writing an instance of Eq', you can think of it as just defining a function whose goal is to tell the caller if two input items are "equal"
22:09:32 <sqooq> by making Rest and Blank just two more value constructors in the data definition, a lot more pattern matching is needed
22:10:18 <sqooq> I could in theory represent either by using the tree definition from Data.Tree but using negative numbers like Node -1 [] for Blank
22:10:25 <crucify_me> thanks jle` you mean the 'two input items' being day of week and date.
22:10:36 <sqooq> but I'd still in my functions have to pattern match against that pattern
22:10:56 <iqubic> jle`: Defining an Ord instance for a date sounds hard.
22:11:13 <sqooq> but at least monad, functor, applicative, value finding, etc. are quite simple (and already done for me if I use Data.Tree)
22:11:44 <erisco> sqooq, do not be afraid to define your own type
22:12:08 <sqooq> erisco, my current code does have it defined myself
22:12:10 <jle`> crucify_me: yeah, defining two different functions, one for day of week, and one for date
22:12:21 <sqooq> `data Tree a = Branch [Tree a] | Leaf a | Blank | Rest `
22:12:21 <crucify_me> but jle` this tells the caller if two input items are "equal" ... to what?    sorry not sure
22:12:33 <jle`> sqooq: if your Tree is parameterized, then you can implement your new tree in terms of that
22:12:37 <jle`> crucify_me: to each other
22:12:56 <erisco> sqooq, also there is Free, which is a tree, so maybe that will work for you
22:13:06 <jle`> sqooq: if you had data Tree a = Branch [Tree a] | Leaf a
22:13:26 <jle`> and you had data Extras = Blank | Rest
22:13:37 <jle`> then your new type is Tree (Either Extras a)
22:13:43 <mnoonan_> sqooq: this sounds a little bit like a case of the “expression problem”
22:13:47 <jle`> or (Tree :.: Either Extras) a
22:13:55 <crucify_me> ok so the caller is asking for specific pattern matches for x reason(s)  jle` 
22:13:56 <jle`> and you get a free Functor instance and Applicative instance
22:13:57 <erisco> sqooq, and also Cofree, if you wanted something like the rose tree
22:13:59 <jle`> woo hoo :)
22:14:20 <jle`> crucify_me: the caller of equalDate will give two dates, and equalDates d1 d2 will return whether or not the two dates are equal
22:14:31 <MarcelineVQ> gosh, yow lambda jam 2017 is so packed with good talks it's hard to believe
22:14:33 <sqooq> jle`, aaaahh that's how you do it? 
22:14:38 <jle`> that's one way to do it
22:14:42 <jle`> and it lets you re-use some code
22:14:42 <sqooq> I think that's a worthy solution
22:14:49 <sqooq> that was my first idea but I didn't know how to do it
22:14:54 <crucify_me> jle` ok I'll run with that thanks  ALL!
22:14:57 <sqooq> didn't think it was possible
22:15:06 <erisco> sqooq, particularly, Tree = Cofree []
22:15:09 <jle`> yeah (:.:), from GHC.Generics, or Compose (from Data.Functor.Compose) gives you a free Functor or Applicative instance
22:15:24 <jle`> if both sides are FUnctor and Applicative
22:15:33 <jle`> it also gives you a nice free Alternative instance too if the first thing is Alternative
22:15:36 <jle`> neat right
22:16:16 <jle`> but one thing it doesn't give is a Monad instance
22:16:27 <sqooq> damn I need Monad the most probably
22:16:51 <jle`> hm
22:16:51 <sqooq> erisco: where is Free?
22:17:14 <erisco> sqooq, the package is called "free"
22:18:12 <sqooq> seems complicated
22:18:20 <jle`> hm
22:18:24 <jle`> actually, i think i was wrong
22:18:29 <erisco> they're just trees, sqooq
22:18:47 <jle`> well, maybe i was right but in a unhelpful way
22:18:58 <jle`> sqooq: your type is `ExceptT Extras Tree`
22:19:04 <jle`> and that should give you a Monad instance for free
22:19:12 <erisco> but instead of choosing that children are held in a list, or whatever, you get to choose
22:19:34 <jle`> er, sorry, i was right initially, and wrong the second time.
22:19:38 <sqooq> lmao
22:19:49 <erisco> and then you get Monad and Comonad instances for free, if you chose a Functor
22:19:53 <erisco> which sounds like what you wanted
22:20:01 <jle`> your type is `Free (Either Extras :.: [])`, and that gets you a free Monad instance, but at this point it's probably just better to write your own type
22:20:02 <sqooq> erisco, not sure I understand
22:20:04 <jle`> hehe
22:20:25 <erisco> oh I guess you need Alternative for the Monad from Cofree
22:20:41 <sqooq> ok so I need advice
22:20:46 <sqooq> where do I go next
22:21:03 <sqooq> I hate how my code looks now with "data Tree a = Branch [Tree a] | Leaf a | Blank | Rest"
22:21:24 <jle`> the simplest way, if you want to re-use your code, is to write `data NewTree a = NTBlank | NTRest | Tree a`
22:21:37 <jle`> er, data NewTree a = NTBlank | NTRest | NTTree (Tree a)
22:21:55 <sqooq> well my code is already adjusted for "data Tree a = Branch [Tree a] | Leaf a | Blank | Rest" where I include it in there
22:22:02 <erisco> I distinctly remember doing that when toying with how to have extensible ASTs...
22:22:02 <sqooq> I'm ok with fixing everything
22:22:12 <pacak> Recursion schemes all the way, no?
22:22:12 <sqooq> if I do something more extreme
22:22:23 <sqooq> I want that nice beautiful code
22:22:27 <jle`> i think that's fine really
22:22:31 <erisco> then I remember deciding that there are so many bloody parameters that it is not worth it
22:22:40 <sqooq> jle` but the fmap definition is so ugly
22:22:40 <pacak> Recursion schemes are pretty!
22:22:42 <jle`> beautiful code sometimes requires ugly costs
22:22:47 <erisco> but then thought of something else that was cleverer... and since forgot
22:22:48 <sqooq> like 7 patterns
22:22:51 <jle`> you have to make some blood sacrifices
22:23:02 <sqooq> Actually just 4
22:23:02 <jle`> sqooq: you could absorb some of your patterns together
22:23:06 <jle`> Blank and Rest are really the same thing
22:23:21 <sqooq> You're right
22:23:36 <glguy> Why are there 7 patterns?
22:23:45 <sqooq> there are 4
22:23:46 <sqooq> my bad
22:23:51 <sqooq> I remembered it being more lol
22:23:59 <sqooq> I think I'm thinking of one of my functions
22:24:05 <jle`> Free, Fix, (:.:), ExceptT, etc. are sort of extremely generic tools that you can use to do your thing, but sometimes the simplest way is the best
22:24:08 <sqooq> It's down to 3 now
22:24:23 <sqooq> jle` yeah it seems too general
22:24:27 <crucify_me> jle`, sorry is there is typo here ?     equalDate (Date w1 s1) (Date w2 s2) = not (w1 /= w1   ||    s1 /= s2)
22:24:42 <jle`> yes there is a typo
22:25:35 <crucify_me> thanks sorry I suck and its late.
22:26:06 <erisco> yeah, this https://github.com/erisco/extensible-ast/blob/master/example02/main.hs
22:26:12 <jle`> if i wrote that, i should be the one who is sorry :)
22:26:29 <jle`> sqooq: writing haskell does sometimes come with an abstraction temptation
22:27:05 <erisco> at the time I was thinking of some sort of eDSL where you could plug in features
22:27:08 <sqooq> jle`, I'm not sure I should even bother making functor, monad, and applicative instances
22:27:14 <crucify_me> no you people are the best
22:27:25 <jle`> sqooq: i know right
22:27:31 <sqooq> currently, I just need one function with maybe two helper functions
22:27:33 <jle`> well Functor and Applicative are almost always useful if possible
22:27:42 <jle`> and Functor can be automatically derived by GHC
22:27:49 <sqooq> and I'm currently impementing it in probably the most ugly way possible
22:27:49 <jle`> so it's like no big deal to just add 'deriving (Functor)
22:27:51 <sqooq> wanna see?
22:27:56 <jle`> sure
22:27:59 <jle`> crucify_me: no u
22:28:01 <jle`> r the best
22:28:06 <sqooq> you can derive functor?
22:28:36 <pacak> sqooq: Yes.
22:28:39 <erisco> there is only one Functor you can make per type, if any, and so yes
22:28:42 <pacak> {-# LANGUAGE DeriveFunctor #-}
22:29:02 <jle`> you can derive Functors for simple enough types
22:29:03 <sqooq> ahhh an extension is needed
22:29:06 <crucify_me> !!
22:29:15 <Xnuk> !
22:29:20 <jle`> that's because writing a Functor instance for ADT's is like, pretty mechanical
22:29:23 <erisco> it is the least creative thing to implement by hand
22:29:26 <jle`> you just handle it on a constructor-by-constructor basis
22:29:33 <jle`> like, for data Maybe a = Nothing | Just a
22:29:45 <jle`> if the constructor has no fields (like Nothing), just return itself
22:30:02 <jle`> if the functor has any a's, then map over the a's
22:30:05 <jle`> *if the constructor
22:30:06 <erisco> no, you have to construct a different Nothing, not keep the same one
22:30:20 <jle`> if th constructor has (t a), and t is a Functor, the fmap over the (t a)
22:30:22 <jle`> and you're good :)
22:30:26 <erisco> hehe :P
22:30:29 <jle`> :P
22:30:39 <jle`> you can keep the same one, just unsafeCoerce
22:30:42 <HaskellLord69> neat, didnt know about DeriveFunctor
22:30:46 <MarcelineVQ> that is a really important distinction to make though :X
22:31:03 <sqooq> o wait my function is incomplete
22:31:07 <suzu_> does DeriveFunctor work on: data Foo a = Bar a a a a a ?
22:31:12 <sqooq> I would still need to implement Rest and Blank
22:31:13 <jle`> yeah
22:31:14 <sqooq> but here it is
22:31:14 <sqooq> http://lpaste.net/357595
22:31:17 <jle`> it does the logic over all of the a's
22:31:24 <jle`> over each of the fields in the constructor
22:31:29 <suzu_> how about data Foo a b = Bar a b
22:31:37 <jle`> yea
22:31:40 <suzu_> because then this is a Bifunctor
22:31:50 <jle`> it is a bifunctor, but DeriveFunctor doesn't care
22:31:57 <suzu_> but there's two type variables
22:32:17 <suzu_> what is `f` in fmap :: (a -> b) -> f a -> f b
22:32:18 <jle`> yeah, it derives a Functor instance for (Foo a)
22:32:19 <suzu_> for Foo?
22:32:21 <suzu_> Foo a?
22:32:23 <suzu_> ah ok i see
22:32:23 <jle`> it's Foo a
22:32:24 <mnoonan_> there is some template haskell in one of ekmett’s libraries (I think) that derives Bifunctor for you, but it isn’t built in to GHC
22:32:27 <suzu_> yup got it
22:32:31 <suzu_> that'd be how you'd have to do it tbh
22:32:36 <suzu_> makes sense
22:32:39 <jle`> it's the standard way to do it
22:32:43 <jle`> for like, Either e, too
22:32:44 <jle`> and (->) r
22:32:46 <suzu_> yup
22:32:46 <jle`> and (,) a
22:33:31 <sqooq> how does my terrible function look?
22:34:14 <suzu_> looks complex, lol
22:34:54 <sqooq> What it does is take a tree and list (empty to start) and takes the length of current branch and constructs 1/length with the rest of the leaf information for all leaves on that branch, but every subbranch it multiplies the 1/L with the 1/L for the subbranch
22:35:15 <sqooq> the list keeps track of all the 1/L's
22:35:34 <sqooq> I think there's got to be a better way to do this, writing it was hell
22:35:46 <sqooq> and I haven't even implemented Blank yet which is even more hell
22:36:19 <sqooq> that's why I'm thinking monad,functor,applicative can help
22:37:18 <suzu_> i think Foldable and Functor will help you a lot
22:37:33 <sqooq> I tried to use fmap first but couldn't do it
22:37:44 <sqooq> because fmap automatically maps the function across every leaf possible
22:37:50 <sqooq> even subleafs
22:37:53 <suzu_> right
22:38:14 <erisco> what is the length of a branch?
22:38:15 <sqooq> and idk I couldn't figure out how to get it to do alter the function its mapping when it hits a branch
22:38:29 <suzu_> didn't you ask about this very problem quite some time ago
22:38:34 <sqooq> erisco, like what is it used for or what actually is it?
22:38:45 <sqooq> suzu_ maybe
22:38:45 <erisco> what is it
22:38:57 <sqooq> Branch List, Length of that list
22:39:08 <erisco> what is a Branch List?
22:39:28 <sqooq> I can't tell if you're being serious
22:39:34 <sqooq> data Tree a = Branch [Tree a] | Leaf a | Blank | Rest
22:39:36 <erisco> I seriously don't know what you are talking about
22:40:04 <erisco> so your branch length is the number of children, okay
22:40:05 <sqooq> Branch [Tree a], if pattern matched ;  f (Branch list) = length list
22:40:20 <sqooq> yeah idk the terms
22:40:28 <erisco> well that is why I didn't know
22:40:33 <sqooq> soz
22:40:48 <erisco> I was thinking you meant the tree height
22:40:53 <sqooq> o
22:40:55 <sqooq> nah
22:41:05 <suzu_> what is Blank vs Rest?
22:41:07 <pacak> sqooq: How is Branch [] different from Blank or Rest btw?
22:41:33 <sqooq> Well something different must occur for Blank and Rest
22:41:40 <sqooq> Blank acts more like a leaf
22:41:52 <sqooq> Rest too
22:42:06 <jle`> maybe write your function on Tree (Either Extra [Double])
22:42:29 <erisco> sqooq, I am trying to grok your algorithm but am not understanding some things
22:42:49 <sqooq> I think in math terms it might be easier
22:42:52 <erisco> sqooq, when you say "with the rest of the leaf information", is this collecting all the a's at the leaves and putting them in a list?
22:42:55 <sqooq> but not on here
22:43:02 <sqooq> erisco: yes
22:43:17 <sqooq> the a's are currently always [Double]
22:43:37 <sqooq> so I just (:) (1/dur) [x]
22:43:45 <erisco> sqooq, and when you say for every sub branch (so, sub tree), it multiplies 1/L with the 1/L for that sub branch, can you clarify that?
22:44:16 <erisco> so we already have a 1/L, and now a list of a's from the leaves... what exactly are we returning?
22:44:34 <sqooq> like if you have [ 1 2 [ 1 2 ] ], there are 3 elements for the top branch so each leaf gets 1/3, but the inner branch has 1/2, but each leaf actually gets 1/2*1/3=1/6
22:44:47 <sqooq> each leaf in the inner branch that is
22:44:50 <sqooq> and this carries on
22:45:04 <suzu_> this is melting my brain
22:45:12 <sqooq> so [ 1 2 [ 1 [ 1 2 ] ] ], the super inner branch gets 1/3*1/2*1/2
22:45:23 <erisco> sqooq, when you say it "gets" that, what do you mean?
22:45:36 <sqooq> suzu_ it's funny because this notation is intuitive as crap to actually use, but a pain to calculate with computers
22:46:01 <erisco> well, maybe it is not a pain... I just want to understand it so I can decide for myself
22:46:04 <sqooq> erisco: that's the value that gets (:) to the a of the leaf
22:46:20 <suzu_> it makes more sense with singleton lists in my head
22:46:31 <sqooq> if i could draw
22:46:37 <suzu_> e.g. [ 1 2 [ 1 2 ] ] -> [ [1] [2] [1 2] ]
22:46:41 <erisco> sqooq, is this some sort of flow calculation?
22:46:47 <sqooq> then it would probably be clearer
22:46:54 <sqooq> erisco: it's music
22:46:59 <suzu_> so toplevel has three children
22:47:08 <sqooq> the leaves start off having pitch and octave information
22:47:11 <suzu_> third child has two children
22:47:15 <erisco> sqooq, okay, I think I might understand what this algorithm is supposed to do now
22:47:19 <sqooq> then I give them duration information
22:47:29 <sqooq> the duration is calculated based on the tree structure
22:47:39 <sqooq> in the way you hopefully understand now
22:48:05 <erisco> yes, I think I do, now I'll contemplate it
22:48:20 <sqooq> page 18+ of this slideshow helps too
22:48:20 <sqooq> http://musicnotation.org/wp-content/uploads/2013/03/Gould_Equiton_Slides.pdf
22:49:16 <sqooq> you can see "invisible symbols", what I've been calling Blank, on page 20
22:49:33 <sqooq> it's duration value gets added to the left note
22:49:38 <erisco> I actually wrote a higher order function for this pattern a few years ago but nowadays I might know a better method for it
22:49:58 <sqooq> and if there are multiple Blanks after a note then it gets the sum of all of their durations
22:50:14 <erisco> sqooq, are you adding things to the algorithm now?
22:51:25 <erisco> actually, I definitely misunderstood the algorithm now that I look at the type of addDur again
22:51:48 <erisco> when you said this product is consed to the leaf I thought it meant we were building a new tree
22:51:52 <erisco> but that does not seem to be the case
22:51:56 <sqooq> no i'm not adding anything until i decide how to best represent the tree
22:52:12 <erisco> so unfortunately I am still confused =\
22:52:43 <sqooq> erisco: nah, I could build a new tree which might be nice if I later wanted to do more things, but I figured that would be harder and technically once duration is added, the tree structure is redundant
22:52:54 <sqooq> erisco: check the slideshow
22:53:00 <sqooq> to see where this all comes from
22:53:12 <sqooq> page 18
22:53:14 <erisco> you start with a tree and end with a list of lists... what does the list of lists mean in relation to the tree?
22:53:33 <sqooq> the list of lists is every leaf and it's information
22:53:49 <sqooq> every list within the list is a leaf representation basically
22:53:52 <sqooq> well a note representation
22:54:03 <sqooq> so it will have [duration,pitch,octave]
22:54:17 <sqooq> and we need a list for every note in the structure
22:54:28 <erisco> why not use a triple?
22:54:39 <sqooq> I did
22:54:41 <sqooq> I changed it
22:54:57 <sqooq> Everythings a double anyways and it's easier to add and remove stuff to it that way
22:55:08 <erisco> okay, so actually we are returning [(Duration, Pitch, Octave)] where Duration = Pitch = Octave = Double
22:55:28 <erisco> don't do that to yourself :P keep the data organised
22:55:34 <sqooq> Like right now my notation doesn't account for amplitude/volume, but later I might implement that so it would be nice to just add it in there
22:55:41 <erisco> we have all these typing features to make use of
22:55:54 <erisco> yeah, so make it a quintuple and away you go
22:55:58 <sqooq> but since tuples are unchangable
22:56:01 <sqooq> that's hard
22:56:12 <erisco> different data requires different code. that's life.
22:56:26 <sqooq> k
22:56:34 <sqooq> i'm starting over eventually anyways
22:56:39 <sqooq> so then I can do it
22:56:41 <erisco> you are going to have code that is relying on certain data being at certain indexes in that list
22:56:46 <erisco> and depending on it being a certain length therefore
22:56:49 <tdammers> hmm, this equiton thing doesn't look very mature yet
22:57:00 <erisco> and so you are kidding yourself to think you can change the data freely without consequence
22:57:09 <sqooq> tdammers: the rhythm part is perfection, i don't give a crap about the pitch part
22:57:15 <erisco> if you want to reduce the maintenance load then look at record notation
22:57:21 <sqooq> tdammers: I've been using the rhythm part for years
22:57:24 <erisco> that will let you project specific fields without needing to reference others
22:57:45 <tdammers> well, the pitch part would be my main gripe, yes
22:57:46 <erisco> and therefore you can add fields without modifying existing code (that doesn't need them, and so long as it doesn't construct that data)
22:58:10 <erisco> though it can update it with record notation
22:58:11 <tdammers> traditional pitch notation is based on diatonic tonality, which is why C# and Db are not the same notation
22:58:15 <sqooq> erisco: yeah but in the actual functions and stuff, I'll have to change everything to work with quintuples no?
22:58:26 <erisco> sqooq, no, just read what I said above about records
22:58:28 <sqooq> wait if I use a data
22:58:34 <sqooq> erisco, yeah I understand
22:58:42 <sqooq> I actually had one for pitch a while ago
22:58:54 <sqooq> scrapped it in favor of lists
22:58:57 <tdammers> and any violinist will tell you that they are in fact not the same - the technique for playing either is different
22:59:14 <sqooq> tdammers: lmao
22:59:33 <sqooq> tdammers, don't let the classical formality ruin music for you
22:59:42 <tdammers> wat
22:59:54 <tdammers> it's not a formality
23:00:00 <sqooq> It is 100%
23:00:08 <tdammers> tempered intonation is a compromise
23:00:14 <erisco> tdammers, I am a violinist, of non-zero skill, and I can confirm that C# is different than Db, although none of my C#'s are the same either...
23:00:23 <sqooq> I'm talking about the fact that C# and Db are "not the same"
23:00:43 <tdammers> C# is a slightly higher pitch than Db
23:00:52 <tdammers> at least in diatonic music
23:00:56 <sqooq> No
23:01:00 <sqooq> In just intonation
23:01:36 <tdammers> tempered intonation ignores this to make key-neutral chromatic music possible
23:01:40 <sqooq> tdammers: It's much more complex than it being "C#" though, if you're talking about just intonation
23:02:08 <sqooq> That C# can vary quite widely
23:02:13 <sqooq> and adding more sharps doesn't quite cut it
23:02:14 <tdammers> well yes it can
23:02:19 <sqooq> or flats
23:02:36 <sqooq> A few people have tried to come up with better notations for it
23:02:47 <pacak> C# and not programming language...
23:02:49 <pacak> On #haskell
23:03:03 <Axman6> it's curious that someone coming in hear earlier today asking for some type theory help was told to go elsewhere, and yet a discussion of violin playing seems to be fine...
23:03:32 <tdammers> Axman6: I think we're deep in #-blah territory by now, but this discussion did originate around a Haskell project, so...
23:03:35 <HaskellLord69> Tonight is friday night equality extravaganza, test your theories
23:03:38 <erisco> sqooq, so I see the slides but I don't know what you're doing with them... I am just seeing this as some function which takes a tree and does a thing with it
23:04:15 <erisco> sqooq, and I am still trying to figure out what the thing is... what operation do I look for in the slides? 18 is "Rhythmic Divisions"
23:04:19 <HaskellLord69>  week == week' && day == day' && c# /= Db
23:04:24 <sqooq> erisco: I'm calculating based on the slide. Go to slide 19
23:04:38 <sqooq> see how the circles have 1/4, 1/4, 1/2
23:04:53 <sqooq> then try to imagine based on my explanation earlier how that's calculated
23:05:11 <erisco> well I see how that can be calculated, but I don't know what your function does
23:05:13 <sqooq> the 1/4 comes first from it being a part of the first 1/2 and then being further divided 1/2
23:05:30 <sqooq> erisco: I mean I'm ok with scrapping my function. it's baaaad.
23:05:46 <erisco> so you have some tree where the leaves are not annotated like this, okay, and now we want a tree that is annotated like this
23:05:57 <pacak> Any links to read on programming with cartesian closed categories?
23:05:59 <erisco> so therefore why aren't we making a function that annotates the leaves of the tree
23:06:09 <Axman6> pacak: have you read Conal's paper?
23:06:20 <erisco> pacak, also Conal's blog... just a sec
23:06:20 <Axman6> the results are truly awesome
23:06:23 <sqooq> erisco, what do you mean annotate
23:06:25 <pacak> Axman6: I did.
23:06:37 <pacak> erisco: I guess I'll keep on reading  his blog.
23:06:38 <Axman6> youy're all set then!
23:06:40 <Axman6> :P
23:06:42 <pacak> Sounds like a good idea.
23:06:46 <sqooq> erisco, thanks for your help btw
23:06:49 <pacak> Axman6: There must be something else :)
23:06:55 <erisco> pacak, http://conal.net/blog/?s=ccc
23:07:30 <pacak> erisco: Thanks
23:07:53 <erisco> sqooq, annotate means to add a note to something
23:07:56 <sqooq> tdammers: I would talk more in offtopic but I want to work on my function. Needless to say, I'm still sticking that it's mostly formalities and doubt that violinists actually require the distinction between enharmonic notes (which I have further arguments for but won't get into)
23:08:12 <erisco> sqooq, particularly for the purpose of remarking on or describing what it is attached to
23:08:20 <sqooq> tdammers, (my argument has to do with how different keys are represented in the same notation)
23:08:51 <sqooq> erisco, I asked because someone else told me to do that and that's what I assumed but I don't see how that's possible
23:09:08 <sqooq> unless I made a new datatype with another field to store this information
23:09:22 <sqooq> (the length information)
23:09:28 <tdammers> sqooq: let's just say traditional music notation is heavily biased towards diatonic music; whether that is desirable is up to the individual
23:10:12 <sqooq> tdammers: kek, we're just going to keep going let's jsut go offtopic, I'll try my best to respond
23:11:02 <erisco> sqooq, realistically I would not actually put these annotations on the leaves... it is inefficient
23:11:05 <MarcelineVQ> pacak: if you're interested in ccc check out  https://www.youtube.com/watch?v=vzLK_xE9Zy8   but the same material is covered in http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf
23:11:30 <erisco> sqooq, every time you change a parent you will have to recalculate the whole tree underneath, and that is a disaster
23:11:56 <Axman6> pacak: conal is also someimes on IRC (as conal)
23:12:04 <MarcelineVQ> the video has examples of the different things compiled to which is p. neat
23:12:39 <erisco> sqooq, so what I would do is guided by what a cranky games programmer taught
23:12:49 <MarcelineVQ> I saw a function for getting half of a list without knowing its length the other day, and felt like a fool for not already knowing it, but it's going to affect how I think about things
23:13:04 <erisco> sqooq, don't start with how you are going to represent the data. rather, start with how you are going to use the data
23:13:21 <erisco> sqooq, starting that way will inform you on how it is most conveniently, and efficiently, represented
23:14:08 <pacak> MarcelineVQ: I've seen this video and checked this paper. There's also a repository in github with more code. Trying to bend my brain around it looking for some more examples.
23:14:54 <MarcelineVQ> pacak: I think the next step is to try it, it's pretty interesting, actually there was a call for help about it somewhere... I don't think I have the log, let's see
23:16:07 <sqooq> erisoc: thanks
23:16:21 <pacak> MarcelineVQ: I wrote some code as well. A monstrosity with abominated type signature that can either be executed as haskell or be rendered as javascript.
23:16:30 <MarcelineVQ> pacak: ah it was just this https://mail.haskell.org/pipermail/haskell-cafe/2017-August/127687.html
23:16:51 <erisco> MarcelineVQ, thanks. I read the blog material but hadn't check out the other materials yet... sounds even more interesting
23:17:22 <erisco> half a list without knowing its length... will have to think about that one
23:17:24 <MarcelineVQ> depending what Target Digital is doing you may see more of ccc sometime soon :>
23:17:37 <MarcelineVQ> erisco: it's pretty cool, the list problem
23:17:37 <erisco> does the algorithm really not traverse the whole list?
23:18:16 <MarcelineVQ> I don't think I​ made that claim, that's a much harder problem
23:18:36 <erisco> I didn't say you did, but I am inquiring because it is only interesting if it doesn't :P
23:18:45 <erisco> if you traverse the whole list then that is the same as knowing the length
23:20:47 <MarcelineVQ> I'm not sure I agree there
23:21:14 <erisco> what work do you have to do to discover the length of the list?
23:22:08 <MarcelineVQ> You need to examine the spine of a list and tally the count of cells as you do.
23:22:59 <erisco> so we're taking just as much time as that
23:23:28 <erisco> and creating the new list is proportional to the length, whereas the tally can be log to the length if we're smart
23:24:15 <erisco> so speaking of the time, the space, and what we have to evaluate (a question of strictness) to find the answer ... it is the same ... asymptotically
23:27:09 <MarcelineVQ> can you elaborate on your second line just now?
23:27:28 <erisco> but I am sure the way it is implemented is eye opening, especially if conal wrote it :)
23:28:38 <erisco> MarcelineVQ, we have to construct a new list which is half the length, and we have to construct a count which is log of the length
23:29:20 <erisco> but even if we used Peano naturals it wouldn't change the outcome
23:29:39 <MarcelineVQ> ah, I ​must not understand what log of the length means
23:29:52 <MarcelineVQ> *I do not understand
23:30:02 <erisco> how many digits it takes to state the length of the list
23:30:30 <erisco> that's the memory we are using to keep the counter
23:31:29 <han-solo> is this broken? https://www.tryhaskell.org/
23:32:02 <erisco> han-solo, it is responding for me
23:32:17 <erisco> although  λ id "hello world"   gives a strange response
23:32:21 <MarcelineVQ> aren't we computing 'the length' what is log's involvement?
23:32:41 <erisco> as I said, that is how much space we need to store the counter
23:33:12 <han-solo> erisco: no, i mean mueval-core: Time limit exceeded
23:33:13 <han-solo> ExitFailure 1
23:33:33 <han-solo> erisco: yeah, that's whati mean
23:33:56 <erisco> han-solo, I guess it has the lambdabot backend? means the server is busy or what you are asking it to compute takes a long time
23:34:00 <MarcelineVQ> erisco: I see, it's just about space, thank you
23:34:32 <han-solo> okay, all i did was (:number, :char)
23:34:51 <han-solo> and i can only see 2 active users
23:35:04 <MarcelineVQ> "<erisco> but I am sure the way it is implemented is eye opening, especially if conal wrote it :)" actually I saw it from edwin brady, it's so direct it made me feel like a little baby in functional thinking :>
23:35:05 <erisco> I don't know what that is han-solo ... but it is not timing out for me, no sure
23:35:40 <Axman6> han-solo: it loosk to be working for me
23:35:45 <erisco> MarcelineVQ, so it is some definition which is surprisingly elegant... was it part of some other domain of discourse? like CCCs?
23:36:05 <han-solo> yeah, i seem to be having the problem
23:36:28 <erisco> han-solo, do ctrl+shift+j or whatever for your browser's console and see if you have JavaScript errors
23:36:36 <MarcelineVQ> it just happened to be in an exercise
23:36:41 <MarcelineVQ> @let half xs = h xs xs where h (_:_:zs) (y:ys) = y : h zs ys; h _ _ = [];
23:36:42 <lambdabot>  Defined.
23:36:47 <MarcelineVQ> > half [1..13]
23:36:49 <lambdabot>  [1,2,3,4,5,6]
23:37:01 <erisco> so... you are just going to spoil it for me? :P
23:37:08 <han-solo> erisco: i was thinking about installing it, rather than using some stupid script.
23:37:37 <han-solo> how would one install haskell?
23:37:42 <han-solo> link? word?
23:37:51 <erisco> hm, that's a neat idea, but it is literally using the list as a Peano natural for the length
23:37:56 <MarcelineVQ> oops :X  We were doing so much talking I figured you weren't working on it
23:38:32 <han-solo> apt-get install ghc?
23:38:56 <han-solo> sorry if i didn't mention, i'm new here
23:38:58 <erisco> well I had to understand the scope in which it was to be solved... there are oodles of ways to imagine finding half a list :P
23:39:38 <erisco> han-solo, well I am too stupid to think about OS stuff so I just downloaded the Haskell Platform for Windows and clicked through the installer
23:39:41 <MarcelineVQ> The idea that recursively taking 2 elements will yeild you half a list worth of steps was just kind of surprising for me, in that it's obvious and I missed it
23:39:54 <ab9rf> the Platform is a decent way to get started
23:40:04 <han-solo> erisco: yeah, can't do that
23:40:05 <erisco> han-solo, I suspect on the Ubuntus and so on you can get it from the package manager... though I was hearing of issues on Arch
23:40:36 <han-solo> well, ghc seems to be installing
23:40:41 <jared-w> MarcelineVQ: that reminds me
23:40:47 <ab9rf> there's some version of ghc in debian, but i have no idea how old it is
23:41:05 <erisco> MarcelineVQ, it is a nice idea, and can be seen by the relationship between lists and Peano numbers, and of course a division algorithm
23:41:07 <han-solo> hold on, this ubuntu things seems pretty broken. (bash on windows)
23:41:09 <jared-w> I had a Theory of computation test last quarter and had to write a DFA diagram for doing something involving the second half of a list
23:41:35 <ab9rf> jared-w: how do you define "half of a list"
23:41:43 <jared-w> My method was to use a fast runner and a slow runner where the fast runner went two items and the slow runner went one. When the fast runner hit the end of the list, the slow runner was at the midpoint
23:41:49 <erisco> MarcelineVQ, [()] is isomorphic to the Peano naturals, lets call it Nat, but also [a] -> Nat, so all lists are a natural
23:42:07 <erisco> MarcelineVQ, now we think of the stupidest division algorithm, which is repeated subtraction
23:42:34 <jared-w> ab9rf: I forgot the exact question--it was something to do with "write a machine that validates a string that must have..." and one of the requirements was "every item from the midpoint on must be a '1'
23:42:34 <erisco> MarcelineVQ, so then that clever solution falls together
23:42:47 <fabian_> hi, is it possible to sort an "Eq a => Data.NonNull [a]" without having to unpack and repack the nested list?
23:42:58 <ab9rf> jared-w: ugh!
23:43:09 <MarcelineVQ> erisco: makes sense :>
23:43:18 <jared-w> The point was that my solution was incredibly fucking overengineered, somewhat inefficient, and took like 4x the amount of states that everyone else's did
23:43:58 <MarcelineVQ> jared-w: did they also ask you to double every other number, from the right? I've got a couple solutions to that one sitting in a dusty corner somewhere
23:44:07 <ab9rf> MarcelineVQ: heh
23:44:26 <jared-w> Like, it was bad enough that the teacher gave me a 3/10 on the question. Not because I was wrong, but because I had so /thoroughly/ missed the point it was ridiculous
23:45:07 <ab9rf> it has been SO long since i had to dea with DFAs i don't even remember what they are now
23:45:10 <jared-w> MarcelineVQ: nah, that's a lot more complicated. It was something like "for the first half of the string, it's 1010... from the second half on, it's just 1s"
23:45:17 <ab9rf> i mean, i do remember what they are
23:45:20 <MarcelineVQ> and a couple more on the way involving Views <_<
23:45:25 <ab9rf> but not any of the theorems on what they can and can't do
23:45:34 <jared-w> ab9rf: imagine category theory diagrams, but useless /s
23:45:35 <ab9rf> that was almost 30 years ago, and i've never used it since
23:46:36 * hackagebot hw-excess 0.2.0.0 – Excess – https://hackage.haskell.org/package/hw-excess
23:47:17 <jared-w> The easy way I remember is that DFA == regex. PDA == Context-free grammars. Turing machine == computable functions.
23:47:38 <ab9rf> jared-w: PDA?
23:47:45 <jared-w> and everything else fits into one of those 3 levels (at least, everything else they care about in an undergrad course)
23:47:58 <jared-w> pushdown automata. Basically it's a state machine with a stack for its memory
23:48:08 <ab9rf> ok, i remember those
23:48:33 <ab9rf> there's collections that are larger than CFG but smaller than computable, though
23:48:40 <ab9rf> LR(n), stuff like that
23:49:09 <jared-w> right, most of that isn't really covered in a basic Theory of Computation course for undergrads, I think--at least I don't really remember hitting those. Or if we did, we just did it with Turing machines
23:49:27 <ab9rf> jared-w: we covered the differences in intro compiler theory
23:49:33 <ab9rf> undergrad class :)
23:49:53 <ab9rf> but this was in 1989
23:49:56 <jared-w> ahh gotcha. We have a separate compiler class from theory of computation so that's probably where we're gonna get more into the finer degrees of things
23:49:59 <ab9rf> things may have changed pedagogically
23:50:50 <jared-w> I don't think it's changed too much, honestly. I mean, compilers are either simple enough for undergrads to understand, or they're using research that's newer than 1970 :p
23:51:07 <ab9rf> heh
23:51:18 <ab9rf> my compilers class actually talked about ML :)
23:51:56 <jared-w> Really? Sweet. I hope mine does. My school's professors have a pretty strong presence in FP so hopefully that's allowed to bleed into the cirriculum a bit :)
23:52:00 <ab9rf> we didn't use it, but it was MENTIONED
23:52:14 <ab9rf> mostly for its type theory
23:52:18 <mibaz_1> Not sure how to ask this question: I have a bunch of types but I want to able to refer to them as the same set of types. Like if type constructors were types themselves. 'data Set = One | two' 'foo :: Set -> Int' 'bar :: One -> Int'.
23:52:30 <mibaz_1> This is probably obvious
23:52:37 <jared-w> (we're also a bit of a feeder school for Intel so our whole 'intro to programming' course was very low level and practical oriented rather than theory/FP oriented)
23:53:27 <mibaz_1> At least I think that's what I need. Confusing myself
23:53:41 <jared-w> mibaz_1: at first glance, that sounds like DataKinds. Which is a pretty good indicator that it's not what you need :)
23:54:00 <ab9rf> heh
23:54:10 <ab9rf> mibaz_1: why do you want to do this?
23:54:16 <erisco> mibaz_1, where do you use this set of types?
23:56:11 <mibaz_1> Sorry accidentally closed my client XD
23:56:27 <jared-w> no problem
23:56:32 <jared-w> mibaz_1: at first glance, that sounds like DataKinds. Which is a pretty good indicator that it's not what you need :)  <-- this is what I sent
23:56:47 <mibaz_1> A while ago I made a little terminal tic tac toe. Was revisiting it and thought I could represent the board with better types
23:57:33 <jle`> a haskell story if i ever saw one :)
23:57:42 <jared-w> How'd you decide to use better types?
23:57:52 <ab9rf> heh
23:58:08 <boj> :)
23:58:22 <cocreature> dependently typed tic tac toe is the new dependently typed printf
23:58:37 <ab9rf> tic-tac-cotie
23:58:37 <jle`> mibaz_1: the example in your case is a bit too small to let us give you meaningful advice
23:58:40 <ab9rf> cotoe
23:58:58 <jared-w> cocreature: and the upgrade is 'typing the technical interview'? :p
23:59:04 <jle`> mibaz_1: if your constructors had fields then i'd recommend just having foo and bar work on those fields
23:59:08 <mibaz_1> It's currently in a horrible experimental state, so let me see if I can get the jist
23:59:15 <jle`> like data Set = One Double | Two Bool
23:59:19 <jle`> foo :: Double -> Int
23:59:22 <jle`> bar :: Bool -> Int
